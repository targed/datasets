

COMPILER 
DESIGN 
IN 
c 
Allen I. Holub 
Prentice Hall Software Series 
Brian W. Kernighan, Editor 
PRENTICE HALL 
Englewood Cliffs, New Jersey 07632 
Library of Congress Cataloging-In-Publication Data 
Holub, Allen I. 
Comp1ler des1gn InC 1 Allen I. Holub. 
p. em. --CPrenttce-Hall software sertes) 
Includes blb11ograph1cal references. 
ISBN 0-13-155045-4 
1. Conpllers (Computer programs) 2. C (Computer program language) 
I. T1tle. II. Ser~es. 
CA76.76.C65H65 1990 
005.4'53--dc20 
Editorial/Production supervision: Kathleen Schiaparelli 
Cover design: Allen I. Holub and Lundgren Graphics Ltd. 
Manufacturing buyer: Margaret Rizzi 
© 1990 by Allen I. Holub. 
Published by Prentice-Hall, Inc. 
A division of Simon & Schuster 
Englewood Cliffs, New Jersey 07632 89-38733 
CIP 
All Rights Reserved. No part of the book may be reproduced in any form or by any means without 
permission in writing from the author. 
Trademark Acknowledgments: TEX is a Trademark of the American Mathematical Society. U:X, 
because it is a visual pun on TEX is used with the kind permission of Donald Knuth. There is no 
other connection between either Dr. Knuth or the AMS and the programs or text in this book. U:X, 
occs, LLama, autopic, and arachne are all trademarks of Allen I. Holub. UNIX is a trademark of 
Bell Laboratories. MS-DOS, Microsoft, and QuickC are trademarks of Microsoft, Inc. Turbo-C is a 
trademark of Borland, Inc. PostScript is a trademark of Adobe Systems. AutoCad and AutoSketch 
are trademarks of AutoDesk, Inc. EROFF is a trademark of the Elan Computer Group. DEC, PDP, 
and VAX are trademarks of Digital Equipment Corporation. Macintosh is a trademark of Apple 
Computer, Inc. 
LIMITS OF LIABILITY AND DISCLAIMER OF WARRANTY: The author and publisher 
11ave used their best efforts in preparing this book. These efforts include the development, research, 
and testing of the theories and programs to determine their effectiveness. The author and publisher 
make no warranty of any kind, expressed or implied, with regard to these programs or the 
documentation contained in this book. The author and publisher shall not be liable in any event for 
incidental or consequential damages in connection with, or arising out of, the furnishing, 
performance, or use of these programs. 
Printed in the United States of America 
10 9 8 7 6 5 4 
ISBN 0-13-155045-4 
Prentice-Hall International (UK) Limited, London 
Prentice-Hall of Australia Pty. Limited, Sydney 
Prentice-Hall Canada Inc., Toronto 
Prentice-Hall Hispanoamericana, S.A .. Mexico 
Prentice-Hall of India Private Limited, New Delhi 
Prentice-Hall of Japan, Inc., Tokyo 
Simon & Schuster Asia Pte. Ltd., Singapore 
Editora Prentice-Hall do Brasil, Ltda, Rio de Janeiro 
For Deirdre 
errata follows page 924 
Contents 
Preface .................................................... xiii 
1. Basic Concepts .............................................. 1 
1.1 The Parts of a Compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 
1.1.1 The Lexical Analyzer ....................................... 3 
1.1.2 The Parser .............................................. 3 
1.1.3 The Code Generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 
1.2 Representing Computer Languages ................................ 6 
1.2.1 Grammars and Parse Trees ................................... 7 
1.2.2 An Expression Grammar ..................................... 9 
1.2.3 Syntax Diagrams .......•................................. 12 
1.3 A Recursive-Descent Expression Compiler .......................... 13 
1.3.1 TheLexical Analyzer ...................................... 13 
1.3.2 The Basic Parser ......................................... 17 
1.3.3 Improving the Parser ...................................... 21 
1.3.4 Code Generation ......................................... 24 
1.4 Exercises ................................................. 30 
2. Input and Lexical Analysis .................................. 32 
2.1 The Lexical Analyzer as Part of a Compiler* ......................... 32 
2.2 Error Recovery in Lexical Analysis* .............................. 34 
2.3 Input Systems* ............................................. 35 
2.3.1 An Example Input System* .................................. 36 
2.3.2 An Example Input System-Implementation ...................... 39 
2.4 Lexical Analysis* ........................................... 50 
2.4.1 Languages* ............................................. 52 
2.4.2 Regular Expressions* ...................................... 54 
2.4.3 Regular Definitions* ...................................... 56 
2.4.4 Finite Automata* ......................................... 56 
2.4.5 State-Machine-Driven Lexical Analyzers* ....................... 60 
2.4.6 Implementing a State-Machine-Driven Lexical Analyzer ............. 63 
vii 
viii Contents 
2.5 l!'X-A Lexical-Analyzer Generator* ............................. 81 
2.5.1 Thompson'sConstruction: From a Regular Expression to an NFA* ...... 81 
2.5.2 Implementing Thompson's Construction ......................... 83 
2.5.2.1 Data Structures ....................................... 83 
2.5.2.2 A Regular-Expression Grammar ........................... 87 
2.5 .2.3 File Header .......................................... 87 
2.5 .2.4 Error-Message Processing ................................ 88 
2.5.2.5 Memory Management ................................... 88 
2.5.2.6 Macro Support ........................................ 93 
2.5.2.7 I§X's Lexical Analyzer .................................. 95 
2.5.2.8 Parsing ............................................ 101 
2.5.3 Interpreting an NFA-Theory* .............................. 113 
2.5.4 Interpreting an NFA-Implementation ......................... 115 
2.5.5 Subset Construction: Converting an NFA to a DFA-Theory* ......... 122 
2.5.6 Subset Construction: Converting an NFA to a DFA-Implementation ... 124 
2.5.7 DFAMinimization-Theory* ............................... 132 
2.5.8 DFA Minimization-Implementation .......................... 135 
2.5.9 Compressing and Printing the Tables .......................... 140 
2.5.9.1 Uncompressed Tables .................................. 140 
2.5.9.2 Pair-Compressed Tables ................................ 141 
2.5.9.3 Redundant-Row-and-Column-Compressed Tables .............. 146 
2.5.10 Tying It All Together .................................... 152 
2.6 Exercises ................................................ 162 
3. Context-Free Grammars .................................. . 166 
3.1 Sentences, Phrases, and Context-Free Grammars ..................... 166 
3.2 Derivations and Sentential Forms ................................ 168 
3.2.1 LLand LR Grammars ..................................... 170 
3.3 Parse Trees and Semantic Difficulties ............................. 170 
3.4 E Productions .............................................. 173 
3.5 The End-of-Input Marker ..................................... 173 
3.6 Right-Linear Grammars ...................................... 174 
3.7 Lists, Recursion, and Associativity ............................... 175 
3.7.1 SimpleLists ........................................... 175 
3. 7.2 The Number of Elements in a List ............................ 178 
3.7.3 Lists with Delimiters ..................................... 179 
3.8 Expressions ............................................... 180 
3.9 Ambiguous Grammars ....................................... 182 
3.10 Syntax-Directed Translation .................................. 183 
3.10.1 AugmentedGrammars ................................... 183 
3.10.2 Attributed Grammars .................................... 186 
3.11 Representing Generic Grammars ............................... 192 
3.12 Exercises ................................................ 193 
4. Top-Down Parsing ....................................... . 195 
4.1 Push-Down Automata* ....................................... 195 
4.1.1 Recursive-Descent Parsers as Push-Down Automata* ............... 198 
4.2 Using a PDA for a Top-Down Parse* ............................. 201 
4.3 Error Recovery in a Top-Down Parser* ............................ 201 
4.4 Augmented Grammars and Table-Driven Parsers* .................... 202 
4.4.1 Implementing Attributed Grammars in a PDA * ................... 203 
4.5 Automating the Top-Down Parse Process* ......................... 208 
4.5.1 Top-Down Parse Tables* .................................. 208 
Contents ix 
4.6 LL(l) Grammars and Their Limitations* ........................... 211 
4.7 Making the Parse Tables* ..................................... 213 
4.7.1 FIRSTSets* ........................................... 213 
4.7.2 FOLLOW Sets* ......................................... 215 
4.7.3 LL(l)Selection Sets* ..................................... 217 
4.8 Modifying Grammars* ....................................... 218 
4.8.1 Unreachable Productions* .................................. 219 
4.8.2 Left Factoring* ......................................... 219 
4.8.3 Comer Substitution* ...................................... 221 
4.8.4 Singleton Substitution* .................................... 223 
4.8.5 Eliminating Ambiguity* ................................... 223 
4.8.6 Eliminating Left Recursion* ................................ 226 
4.9 Implementing LL(l) Parsers ................................... 229 
4.9.1 Top-Down, Table-Driven Parsing- The LLama Output File .......... 229 
4.9.2 Occs and LLama Debugging Support-yydebug.c ................. 242 
4.10 Llama-Implementing an LL(l) Parser-Generator .................. 270 
4.10.1 LLama'sParser ........................................ 270 
4.1 0.2 Creating The Tables ..................................... 304 
4.10.2.1 Computing FIRST, FOLLOW, and SELECT Sets ............. 304 
4.1 0.3 The Rest of LLama ..................................... 304 
4.11 Exercises ................................................ 333 
5. Bottom-Up Parsing ........................................ 337 
5.1 How Bottom-Up Parsing Works* ................................ 338 
5.2 Recursion in Bottom-Up Parsing* ............................... 340 
5.3 Implementing the Parser as a State Machine* ....................... 343 
5.4 Error Recovery in an LR Parser* ................................ 348 
5.5 The Value Stack and Attribute Processing* ......................... 348 
5.5.1 A Notation for Bottom-Up Attributes* ......................... 353 
5.5.2 Imbedded Actions* ...................................... 354 
5.6 Creating LR Parse Tables- Theory* ............................. 354 
5.6.1 LR(O) Grammars* ....................................... 354 
5.6.2 SLR(l) Grammars* ...................................... 361 
5.6.3 LR(l)Grammars* ....................................... 361 
5.6.4 LALR(l) Grammars* ..................................... 365 
5.7 Representing LR State Tables .................................. 368 
5.8 Eliminating Single-Reduction States* ............................. 373 
5.9 Using Ambiguous Grammars* .................................. 375 
5.10 Implementing an LALR(l) Parser-The Occs Output File .............. 381 
5.11 Implementing an LALR(l) Parser Generator-Occs Internals ........... 401 
5.11.1 Modifying the Symbol Table for LALR(l) Grammars ............. .401 
5.12 Parser-File Generation . . 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .408 
5.13 Generating LALR(l) Parse Tables .............................. 408 
5.14 Exercises ................................................ 442 
6. Code Generation .......................................... 445 
6.1 Intermediate Languages ...................................... 446 
6.2 C-code: An Intermediate Language and Virtual Machine ............... 449 
6.2.1 Names and White Space ................................... 450 
6.2.2 Basic Types ............................................ 450 
6.2.3 The Virtual Machine: Registers, Stack, and Memory ............... 451 
6.2.4 Memory Organization: Segments ............................. 455 
6.2.5 Variable Declarations: Storage Classes and Alignment .............. 457 
X Contents 
6.2.6 Addressing Modes ....................................... 462 
6.2. 7 Manipulating the Stack .................................... 465 
6.2.8 Subroutines ............................................ 466 
6.2.9 Stack Frames: Subroutine Arguments and Automatic Variables ........ 467 
6.2.10 Subroutine Return Values ................................ .472 
6.2.11 Operators ............................................ 473 
6.2.12 Type Conversions ....................................... 473 
6.2.13 Labels and Control Flow ................................. .474 
6.2.14 Macros and Constant Expressions ........................... .475 
6.2.15 File Organization ...................................... .476 
6.2.16 Miscellany .......................................... .476 
6.2.17 Caveats .............................................. 478 
6.3 The Symbol Table .......................................... 478 
6.3.1 Symbol-Table Requirements ................................ 478 
6.3.2 Symbol-Table Data-Base Data Structures ....................... 480 
6.3.3 Implementing the Symbol Table ............................. .485 
6.3.4 Representing Types-Theory .............................. .489 
6.3.5 Representing Types-Implementation ......................... 490 
6.3.6 Implementing the Symbol-Table Maintenance Layer .............. .497 
6.4 The Parser: Configuration ..................................... 509 
6.5 The Lexical Analyzer ........................................ 518 
6.6 Declarations .............................................. 522 
6.6.1 Simple Variable Declarations ............................... 522 
6.6.2 Structure and Union Declarations ............................. 543 
6.6.3 Enumerated- Type Declarations .............................. 550 
6.6.4 Function Declarations ..................................... 552 
6.6.5 Compound Statements and Local Variables ...................... 559 
6.6.6 Front-End/Back-End Considerations ........................... 563 
6.7 The gen () Subroutine ....................................... 564 
6.8 Expressions ............................................... 572 
6.8.1 Temporary- Variable Allocation .............................. 572 
6.8.2 Lvalues and Rvalues ...................................... 578 
6.8.3 Implementing Values, Higher-Level Temporary- Variable Support ...... 583 
6.8.4 Unary Operators ........................................ 593 
6.8.5 Binary Operators ........................................ 617 
6.9 Statements and Control Flow ................................... 637 
6.9.1 Simple Statements and if/else ............................. 637 
6.9.2 Loops,break, and continue .............................. 642 
6.9.3 The switch Statement .................................... 642 
6.10 Exercises ................................................ 651 
7. Optimization Strategies .................................... 657 
7.1 Parser Optimizations ........................................ 657 
7.2 Linear (Peephole) Optimizations ................................ 658 
7 .2.1 Strength Reduction ....................................... 658 
7 .2.2 Constant Folding and Constant Propagation ...................... 659 
7 .2.3 Dead Variables and Dead Code .............................. 660 
7 .2.4 Peephole Optimization: An Example .......................... 665 
7.3 Structural Optimizations ...................................... 667 
7 .3.1 Postfix and Syntax Trees ................................... 667 
7 .3.2 Common-Subexpression Elimination .......................... 672 
7 .3.3 Register Allocation ...................................... 673 
Contents xi 
7.3.4 Lifetime Analysis ........................................ 673 
7 .3.5 Loop Unwinding ........................................ 675 
7 .3.6 Replacing Indexes with Pointers ............................. 675 
7.3.7 Loop-Invariant Code Motion ................................ 676 
7 .3.8 Loop Induction ......................................... 677 
7.4 Aliasing Problems .......................................... 677 
7.5 Exercises ................................................ 678 
Appendix A. Support Functions ............................... 680 
A.l Miscellaneous Include Files ................................... 681 
A.l.l debug .h-Miscellaneous Macros ............................. 681 
A.1.2 stack.h and yystack.h -Generic Stack Maintenance ............... 686 
A.1.3 l.h and compiler.h ....................................... 689 
A.2 Set Manipulation ........................................... 690 
A.2.1 Using the Set Functions and Macros .......................... 690 
A.2.2 Set Implementation ...................................... 695 
A.3 Database Maintenance-Hashing: ............................... 710 
A.3.1 Hashing-Implementation ................................. 715 
A.3.2 Two Hash Functions ..................................... 723 
A.4 The ANSI Variable-Argument Mechanism .......................... 724 
A.5 Conversion Functions ....................................... 726 
A.6 Print Functions ............................................ 731 
A. 7 Sorting ........ · .......................................... 738 
A. 7 .I Shell Sort-Theory ...................................... 739 
A.7.2 Shell Sort-Implementation ................................ 741 
A.8 Miscellaneous Functions ..................................... 741 
A.9 Low-Level Video 1/0 Functions for the IBM PC ..................... 746 
A.9.1 IBM Video I/O-Overview ................................ 749 
A.9.2 Video I/O-Implementation ................................ 753 
A.IO Low-level-I/O, Glue Functions ................................ 771 
A. II Window Management: Curses ................................. 774 
A.ll.l Configuration and Compiling .............................. 775 
A.ll.2 Using Curses .......................................... 776 
A.ll.2.1 Initialization Functions ................................ 776 
A.ll.2.2 Comguration Functions ............................... 776 
A.ll.2.3 Creating and Deleting Windows ......................... 777 
A.ll.2.4 Subroutines That Affect Entire Windows ................... 779 
A.ll.2.5 Cursor Movement and Character 1/0 ...................... 781 
A.11.3 Curses-Implementation ................................. 783 
Appendix B. Notes on Pascal Compilers ........................ 802 
B.1 Subroutine Arguments ....................................... 802 
B.2 Return Values ............................................. 803 
B.3 Stack Frames ............................................. 803 
Appendix C. A Grammar for C ............................... 806 
Appendix D. U:X ............................................ 812 
D.l Using IJX and Occs Together .................................. 812 
D.2 The LEX Input File: Organization ................................ 814 
D.3 The LEX Rules Section ....................................... 816 
D.3.1 ~X Regular Expressions .................................. 816 
D.3.2 The Code Part of the Rule .................................. 820 
D.4 ~X Command-Line Switches .................................. 825 
xii Contents 
D.5 Limits and Bugs ........................................... 826 
D.6 Example: A Lexical Analyzer for C .............................. 829 
D.7 Exercises ................................................ 834 
Appendix E. LLama and Occs ................................ 836 
E.1 Using The Compiler Compiler .................................. 836 
E.2 The Input File ............................................. 837 
E.3 The Definitions Section ...................................... 837 
E.4 The Rules Section .......................................... 839 
E.5 The Code Section .......................................... 842 
E.6 Output Files .............................................. 842 
E.7 Command-Line Switches ..................................... 843 
E.8 The Visible Parser .......................................... 845 
E.9 Useful Subroutines and Variables ............................... 852 
E.IO Using Your Own Lexical Analyzer .............................. 855 
E.11 Occs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 856 
E.1l.l Using Ambiguous Grammars ............................... 856 
E.11.2 Attributes and the Occs Value Stack .......................... 858 
E.11.3 Printing the Value Stack .................................. 863 
E.11.4 Grammatical Transformations .............................. 865 
E.11.5 The yyout.sym File ...................................... 867 
E.11.6 The yyout.doc File ...................................... 868 
E.11.7 Shift/Reduce and Reduce/Reduce Conflicts ..................... 871 
E.11.8 Error Recovery ........................................ 875 
E.11.9 Putting the Parser and Actions in Different Files .................. 875 
E.1l.l0 Shifting a Token's Attributes .............................. 877 
E.11.11 Sample Occs Input File .................................. 879 
E.11.12 Hints and Warnings .................................... 881 
E.12 LLama ................................................. 883 
E.12.1 Percent Directives ...................................... 883 
E.12.2 Top-Down Attributes .................................... 883 
E.12.3 TheLLama Value Stack .................................. 884 
E.l2.4 The llout.sym File ...................................... 885 
E.12.5 Sample LLama Input File ................................. 885 
Appendix F. A C-code Summary .............................. 889 
Bibliography ............................................... 894 
Index ...................................................... 897 
Cross Reference by Symbol .................................. 913 
Preface 
This book presents the subject of Compiler Design in a way that's understandable to 
a programmer, rather than a mathematician. My basic premise is that the best way to 
learn how to write a compiler is to look at one in depth; the best way to understand the 
theory is to build tools that use that theory for practical ends. So, this book is built 
around working code that provides immediate practical examples of how given theories 
are applied. I have deliberately avoided mathematical notation, foreign to many pro­
grammers, in favor of English descriptions of the theory and using the code itself to 
explain a process. If a theoretical discussion isn't clear, you can look at the code that 
implements the theory. I make no claims that the code presented here is the only (or the 
best) implementation of the concepts presented. I've found, however, that looking at an 
implementation-at any implementation--can be a very useful adjunct to understanding 
the theory, and the reader is well able to adapt the concepts presented here to alternate 
implementations. 
The disadvantage of my approach is that there is, by necessity, a tremendous amount 
of low-level detail in this book. It is my belief, however, that this detail is both critically 
important to understanding how to actually build a real compiler, and is missing from 
virtually every other book on the subject. Similarly, a lot of the low-level details are 
more related to program implementation in general than to compilers in particular. One 
of the secondary reasons for learning how to build a compiler, however, is to learn how 
to put together a large and complex program, and presenting complete programs, rather 
than just the directly compiler-related portions of those programs, furthers this end. I've 
resolved the too-many-details problem, to some extent, by isolating the theoretical 
materials into their own sections, all marked with asterisks in the table of contents and in 
the header on the top of the page. If you aren't interested in the nuts and bolts, you can 
just skip over the sections that discuss code. 
In general, I've opted for clarity in the code rather than cleverness or theoretical 
efficiency. That is, since the main purpose of this book is to teach compiler-design con­
cepts, it seemed reasonable always to go with a more understandable algorithm rather 
than an efficient but opaque algorithm. For example, I've used Thompson's Construction 
to make DFA's in LEX rather than the more direct approach recommended in Aho's book, 
because Thompson's construction is more understandable (it also introduces certain key 
concepts [like closure], in a relatively easy-to-understand context). My method for 
xiii 
xiv 
Prerequisites Preface 
computing LALR( 1) lookaheads is also less efficient than it could be, but the algorithm is 
understandable and fast enough. I usually point the reader to the source for the more 
efficient algorithms, should he or she want to implement them. 
In a sense, this book is really an in-depth presentation of several, very well docu­
mented programs: the complete sources for three compiler-generation tools are 
presented, as is a complete C compiler. (A lexical-analyzer generator modeled after the 
UNIX lex utility is presented along with two yacc-like compiler compilers.) As such, it is 
more of a compiler-engineering book than are most texts-a strong emphasis is placed 
on teaching you how to write a real compiler. On the other hand, a lot of theory is 
covered on the way to understanding the practice, and this theory is central to the discus­
sion. Though I've presented complete implementations of the programs as an aid to 
understanding, the implementation details aren't nearly as important as the processes 
that are used by those programs to do what they do. It's important that you be able to 
apply these processes to your own programs. 
The utilities are designed to be used as a learning aid. For example, LLama and 
occs (the two compiler compilers) can create an interactive window-oriented debugging 
environment, incorporating a "visible parser" that lets you watch the parse process in 
action. (One window shows the state and value stacks, others show the input, output, 
and a running commentary of what the parser's doing.) You can see the parse stack grow 
and shrink, watch attributes being inherited and synthesized, set breakpoints on certain 
conditions (a token being input, reduction by a particular production, a certain symbol 
on the top of stack, and so forth), and if necessary, log the entire parse (including 
snapshots of the stack) to a file. I've found that actually watching a bottom-up parse in 
action helps considerably in understanding how the parse process works, and I regularly 
use this visible parser in the classroom to good effect. 
The C Compiler presented in Chapter Six implements an ANSI-compatible subset of 
C-I've left out a few things like floating point which would make the chapter even 
larger than it is without adding any significant value. I have tried to cover all of the hard 
implementation details that are usually omitted from books such as the present one. For 
example, the complete declaration syntax of C is supported, including structures and 
declarations of arbitrary complexity. Similarly, block nesting of declarations and the 
more complex control structures, such as switches, are also covered. 
All the source code presented here is ANSI C, and is all portable to UNIX as well. For 
example, window management is done on the IBM-PC by emulating a standard UNIX 
window-management package (curses). The complete source code for the emulator is 
provided. All of the software is available electronically-versions are available for the 
UNIX, MS-DOS, and Macintosh environments. 
I'm assuming throughout this book that you will actually read the code as well as the 
prose descriptions of the code. I don't waste space in the text discussing implementation 
details that are described adequately by the code itself. I do, however, use a lot of space 
describing the non obvious parts of the programs. 
The primary prerequisite for using this book is a thorough knowledge of ANSI C in 
particular and programming in general. You should be familiar both with the language 
itself and with the standard library functions described in the ANSI standard. 
I've used structured programming techniques throughout the book, and have made 
heavy use of data abstraction and similar techniques, but I haven't described what these 
techniques are or why I'm using them. The more complicated data structures are 
explained thoroughly in the text, but a previous knowledge of basic data structures like 
stacks and binary trees is assumed throughout. Similarly, a knowledge of basic set 
theory and a familiarity with graphs is also useful. Finally, familiarity with assembly­
language concepts (like how a subroutine-call works) is mandatory, but an in-depth 
knowledge of a specific assembly language is not required (because I've used a C subset 
Preface xv 
for generated code rather than assembly language). 
Though a knowledge of C is mandatory, a knowledge of UNIX or MS-DOS is not. This 
book is UNIX oriented only in that several UNIX tools are constructed. The tools were all 
developed on an IBM-PC and run nicely in that environment. By the same token, 
several MS-DOS implementation details and portability concerns are discussed in depth 
here, but I've been careful to make the code itself as portable as possible. The only 
potential confusion for non-UNIX users is in Appendixes D and E, where differences 
between my own programs and the UNIX versions are occasionally mentioned in foot­
notes. Just ignore these notes if you're not going to use the UNIX tools. 
The book is organized so that you can use it in two ways. If you have no interest in Organization 
theory and just want to build a compiler, an overview of compiler design in general is 
presented in Chapter One, instructions for using the compiler construction tools (LEX and 
occs) are in Appendixes D and E, and code generation is discussed in Chapter Six. With 
these chapters behind you, you can get to the business of writing a compiler immedi-
ately, and go back later and absorb the theory. 
A more rigorous approach goes through the book sequentially. You don't have to 
read every word of every chapter-if you're not interested in the nuts-and-bolts, just skip 
past those sections that describe the programs' inner workings. I'd strongly suggest 
reading the code, however, and reading Appendixes D and E before leaping into the text 
that describes these programs. 
Various support functions that are used internally by the programs are concentrated 
in Appendix A. Covered functions do set manipulation, window management, and so 
forth. I've put them in one place so that the rest of the book isn't cluttered with function 
descriptions that aren't germane to the discussion at hand. This appendix shouldn't be 
viewed as an adjunct, however. The functions described in it are used heavily 
throughout the rest of the book, and you should be familiar with them-or at least with 
their calling syntax-before trying to read any of the other code. 
One major organizational issue is the positioning of the theoretical and practical 
parts of the book. It's tempting to put all the theoretical material together at the head of 
each chapter so that you can skip past implementation details if you're not interested. 
I've opted, however, to intermix theoretical material with actual code because an exami­
nation of the code can often clarify things on the theoretical side. As I mentioned ear­
lier, I've resolved the problem, somewhat, by isolating the theoretical material into indi­
vidual sections. I often discuss the theory in one section and put a practical implementa­
tion in the following section. The theoretical sections in chapters that mix theoretical 
and practical material are marked with asterisks in the table of contents. This way you 
can skip past the implementation-related material with little difficulty, should you desire 
to do so. 
A few compiler-related subjects are not covered here. Optimization is not discussed 
beyond the overview presented in Chapter Seven-I discuss how various optimizations 
move the code around, but I don't discuss the mechanics of optimization itself beyond a 
few, simple examples. Similarly, only the most common parse strategies are discussed 
(operator-precedence parsing is not mentioned, for example). All the material usually 
covered in an upper-division, undergraduate compiler-design course is covered here. 
All the code in this book is written in ANSI C (I've used the Microsoft C compiler, Source Code and 
version 5.1, for development purposes). For the most part, the MS-DOS code can be con-Portability 
verted to the UNIX compiler by changing a few #defines before compiling. The disk 
that contains the code (see below) is shipped with the source of a small UNIX preproces-
sor that handles other conversion details (it does string concatenation, token pasting, 
etc.), and the output of this preprocessor can be submitted directly to UNIX cc. I'm 
assuming that the UNIX compiler supports those ANSI features that are implemented in 
most UNIX systems (like structure assignment). 
xvi 
Getting the Code 
Bug Reports and 
Electronic Mail Preface 
If you intend to use the code directly (without UNIX preprocessing), you'll need an 
ANSI-compatible compiler that supports function prototypes, and so forth. In particular: 
• <stdarg.h> is used for variable-argument lists. 
• white space around the # in a preprocessor directive must be permitted. 
• structure assignment is used. 
• unsigned char must be supported. 
• function prototypes are used heavily. 
• isdigi t (),etc., may not have side effects. 
• string concatenation is used in a few places. 
• 16-character names must be permitted. 
My only deviation from strict ANSI is in name lengths. In theory ANSI allows only six 
characters in an external name but I'm assuming that 16 are supported. I am also using 
the old, Kernighan & Ritchie style, subroutine-declaration syntax: 
lorenzo( argl, arg2 ) 
char *argl; 
double *arg2; 
rather than: 
lorenzo( char *argl, double *arg2 ) 
I've done this because many compilers do not yet support the new syntax, and the old 
syntax is still legal in the standard (even though it's declared obsolescent). 
I've deliberately avoided using special features of the Microsoft compiler: I've 
ignored things like the existence of the far keyword and huge pointers in favor of using 
the compact model even though the foregoing would make some of the code more 
efficient. By the same token, I haven't used register variables because the Microsoft 
compiler does a better job of assigning registers than I can do myself. 
Unfortunately, the 8086 has an architecture that forces you to worry about the under­
lying machine on a regular basis, so the code has a certain amount of 8086-speci fie 
details. All of these details are isolated into macros, however, so that it's easy to port the 
code to a different environment by changing the macros and recompiling. I do discuss 
the foibles of the 8086 here and there; just skip over this material if you're not interested. 
All of the source code in this book-along with executable versions of LEX, LLama, 
and occs-is available on disk from: 
Software Engineering Consultants 
P.O. Box 5679 
Berkeley, California 94705 
( 415) 540-7954 
The software is available right now for the IBM-PC and UNIX. (The UNIX version is 
shipped on an IBM-PC, 5-1/4 disk, however. You'll have to upload it using KERMIT or 
some other file-transfer protocol. It has been tested under UNIX System V, BSD 4.3-1 
can't vouch for any other UNIX variant.) The cost is $60.00 by a check or money order 
drawn on a U.S. bank. Please specify the disk size (5Y." or 3W'). California residents 
must add local sales tax. No purchase orders or credit cards (sorry). A Macintosh 
version will be available eventually. Binary site licenses are available for educational 
institutions. 
The code in this book is bound to have a few bugs in it, though I've done my best to test 
it as thoroughly as possible. The version distributed on disk will always be the most 
recent. If you find a bug, please report it to me, either at the above address or electroni­
cally. My internet address is holub@violet.berkeley.edu CompuServe users can access 
internet from the email system by prefixing this address with >INTERNET: -type 
help internet for information. My UUCP address is .. .!ucbvax!violet!holub. 
Preface xvii 
The UNIX USENET network is the official channel for bug fixes and general discussion 
of the material in this book. The comp.compilers newsgroup should be used for this pur­
pose. USENET messages have a way of filtering over to other networks, like BIX, but 
the best way to get up-to-date information is via USENET itself. Most universities are 
connected to this network, and you can get access to it by getting an account on a 
machine at a local university. (Most schools have a mechanism for people in the com­
munity to get such accounts.) I'd prefer for all postings to be sent to me-1'11 digest 
them and post them to comp.compilers via its moderator. If you want to make a submis­
sion to comp.compilers directly, you have to mail it to the moderator, who will post it to 
the network. Type help bboard usenet moderators to get his or her name. 
This book was written largely because my students found the "standard" text-Acknowledgments 
Alfred Aho, Ravi Sethi, and Jeffrey Ullman's excellent, but at times abstruse Compilers: 
Principles, Techniques, and Tools-to be too theoretically oriented. The current volume 
owes a lot to Aho et al, however. I've used many of their algorithms, and their insights 
into the compiler-design practice are invaluable. I'm also indebted to Mike Lesk, Eric 
Schmidt, and Steve Johnson, the creators of UNIX's lex and yacc utilities, after which the 
programs in this book are modeled. My neighbor, Bill Wong, provided invaluable com­
ments on the early drafts of this book, as did many of my students. Finally, I'm grateful 
to Brian Kernighan, Johnson M. Hart, Andrew Appel, Norman C. Hutchinson, and N.H. 
Madhavji (of Bell Labs, Boston University, Princeton University, The University of 
Arizona, and McGill University respectively) all of whom reviewed this book before it 
went to press. Their comments and suggestions have made this a much better book. I 
am particularly indebted to Brian Kernighan, whose careful scrutiny of the entire 
book-both the text and the code--caught many errors that otherwise would have made 
it into print. 
Allen Holub 
Berkeley, California 
This book was typeset on an IBM PC/AT using EROFPM, a version of the UNIX troff Typesetting Notes 
typesetter ported to MS-DOS by the Elan Computer Group. PostScript Times Roman and 
Italic were used for the text, Helvetica for chapter headings, and Courier, Courier Bold, 
and Courier Italic for the listings. Page proofs were generated using an Apple Laser-
Writer, and the final typesetting was done on a Linotronic phototypesetter using 
EROFF-generated PostScript. The following command line was used throughout: 
arachne file ... I autopic I tbl I troff -mm 
The arachne preprocessor is a version of Knuth's WEB documentation system that's 
tailored for C and troff (rather than Pascal and TEX). It runs under MS-DOS on an IBM­
PC. With it, you can put the code and documentation together in a single input file. Used 
one way, it extracts the code and writes it out to the correct files for compilation. In a 
second mode it processes the code for troff, performing the necessary font changes, and 
so forth, needed to "pretty print" the code. It also automatically generates index entries 
for subroutine declarations. It adds line numbers to the listings and lets you reference 
xviii Preface 
these line numbers symbolically from the text (that is, you can add lines to the listings 
and the line numbers in the text automatically adjust themselves). Finally, it lets you dis­
cuss global variables and so forth where they're used, because it automatically moves 
them to the top of the output C program. 
The second preprocessor, autopic, translates drawings generated by two commer­
cially available drafting programs (AutoCad™ and AutoS ketch ™) into trotf graphics 
primitives. It is much more useful than pic in that you have both a WYSIWYG capability 
and a much more powerful drawing system at your disposal. Since trotf commands are 
generated as autopic output, the drawings are readily portable to any trotf system. 
Autopic and arachne are both compilers, and as such serve as an example of how 
you can apply the techniques presented in this book to applications other than writing 
compilers for standard programming languages. MS-DOS versions of autopic and 
arachne are available from Software Engineering at the address given earlier. Write for 
details. 
1 
Basic Concepts 
This chapter introduces the basic concepts of compiler design. I'll discuss the inter­
nal organization of a compiler, introduce formal grammars and parse trees, and build a 
small recursive-descent expression compiler. Before leaping into the text, however, a 
word of encouragement, both about this chapter and the book in general, seems in order. 
Compilers are not particularly difficult programs to understand once you're familiar with 
the structure of a compiler in a general sort of way. The main problem is not that any 
one part of a compiler is hard to understand; but, rather, that there are so many parts­
and you need to have absorbed most of these parts before any of them make sense. For 
now, my advice is to forge ahead without trying to figure out how it all ties together. 
You'll find that you will eventually reach a "click point" where the system as a whole 
suddenly makes sense. 
1.1 The Parts of a Compiler 
Compilers are complex programs. As a consequence, they're often broken into 
several distinct chunks, called passes, that communicate with one another via temporary Compiler passes. 
files. The passes themselves are only part of the compilation process, however. The pro-
cess of creating an executable image from a source-code file can involve several stages 
other than compilation (preprocessing, assembly, linking, and so forth). In fact, some 
operating systems (such as Microsoft's OS/2) can delay the final creation of an execut-
able image until a program is actually loaded at run-time. The situation is muddled 
further by driver programs like UNIX's cc or Microsoft C's cl, which hide a good deal of 
the compilation process from you. These driver programs act as executives, controlling 
the various component programs that make up the compiler in such a way that you don't 
know that the components are being used. For the purposes of this book, I'll define a "Compiler' defined. 
compiler as a program or group of programs that translates one language into another-
in this case the source code of a high-level computer language is translated into assem-
bly language. The assembler, linker, and so forth are not considered to be part of the 
compiler. 
The structure of a typical four-pass compiler is shown in Figure 1.1. The preproces- Structure of a four-pass 
sor is the first pass. Preprocessors typically do macro substitutions, strip comments from compiler. 
the source code, and handle various housekeeping tasks with which you don't want to 
1 
2 
The back end. Basic Concepts-Chapter I 
Figure 1.1. Structure of a Typical Four-Pass Compiler 
L source code 
\ I 
(pass 1) 
preprocessor 
- --- - - - - -
\I 
/ 
lexical analyzer -... 
' 
10 
I 
I 
!'" ____ \!( ____ , 
I symbol I 
I ~-----:> I table I I L----------' 
- - - - - - - - --
-- - -
parser 
II\ 
\1 
code 
generation 
-r--(p 
-
-ass 2) 
-, 
...J 
intermed iate code 
'II 
optimization (pass 3) 
intermed iate code 
\I! 
back end (pass 4) 
'II 
assembly language or binary 
burden the compiler proper. The second pass is the heart of the compiler. It is made up 
of a lexical analyzer, parser, and code generator, and it translates the source code into an 
intermediate language that is much like assembly language. The third pass is the optim­
izer, which improves the quality of the generated intermediate code, and the fourth pass, 
the back end, translates the optimized code to real assembly language or some form of 
binary, executable code. Of course, there are many variations to this structure. Many 
compilers don't have preprocessors; others generate assembly language in the second 
pass, optimize the assembly language directly, and don't have a fourth pass; still others 
generate binary instructions directly, without going through an ASCII intermediate 
language like assembler. 
This book concentrates on the second pass of our model. There are several opera­
tions here too, but they interact in more complicated ways than the higher-level passes, 
and they share data structures (such as the symbol table) as well. 
Section 1.1 -The Parts of a Compiler 
1.1.1 The Lexical Analyzer 
A phase is an independent task used in the compilation process. Typically, several 
phases are combined into a single pass. The lexical analyzer phase of a compiler (often 
called a scanner or tokenizer) translates the input into a form that's more useable by the 
rest of the compiler. The lexical analyzer looks at the input stream as a collection of 
basic language elements called tokens. That is, a token is an indivisible lexical unit. In 
C, keywords like while or for are tokens (you can't say wh ile), symbols like>,>=, 
>>,and>>= are tokens, names and numbers are tokens, and so forth. The original string 
that comprises the token is called a lexeme. Note that there is not a one-to-one relation­
ship between lexemes and tokens. A name or number token, for example, can have 
many possible lexemes associated with it; a while token always matches a single lexeme. 
The situation is complicated by tokens that overlap (such as the>,>=,>>, and>>=, used 
earlier). In general, a lexical analyzer recognizes the token that matches the longest 
lexeme-many languages build this behavior into the language specification itself. 
Given the input>>, a shift token is recognized rather than two greater-than tokens. 
A lexical analyzer translates lexemes into tokens. The tokens are typically 
represented internally as unique integers or an enumerated type. Both components are 
always required-the token itself and the lexeme, which is needed in this example to 
differentiate the various name or number tokens from one another. 
One of the early design decisions that can affect the structure of the entire compiler is 
the choice of a token set. You can have a token for every input symbol, or several sym­
bols can be merged into a single token-for example, the >, >=, >>, and >>=, can be 
treated either as four tokens, or as a single comparison-operator token-the lexeme is 
used to disambiguate the tokens. The former approach can sometimes make code gen­
eration easier to do. Too many tokens, however, can make the parser larger than neces­
sary and difficult to write. There's no hard-and-fast rule as to which is better, but by the 
time you've worked through this book, you'll understand the design considerations and 
will be able to make intelligent choices. In general, arithmetic operators with the same 
precedence and associativity can be grouped together, type-declaration keywords (like 
int and char) can be combined, and so forth. Phases. 
Scanner, tokenizer. 
Tokens. 
Lexemes. 
Lexemes are translated 
to tokens. 
Choosing a token set. 3 
The lexical analyzer is typically a self-contained unit that interfaces with the rest of 
the compiler via a small number (typically one or two) of subroutines and global vari­
ables. The parser calls the lexical-analyzer every time it needs a new token, and the 
analyzer returns that token and the associated lexeme. Since the actual input mechanism 
is hidden from the parser, you can modify or replace the lexical analyzer without 
affecting the rest of the compiler. Scanner is self-contained 
unit. 
1.1.2 The Parser 
Compilers are language translators-they translate a high-level language like C into 
a low-level language like 8086 assembler. Consequently, a good deal of the theoretical 
side of the subject is borrowed from linguistics. One such concept is the idea of parsing. 
To parse an English sentence is to break it up into its component parts in order to Parse, defined. 
analyze it grammatically. For example, a sentence like this: 
Jane sees Spot run. 
is broken up into a subject ("Jane") and a predicate ("sees Spot run"). The predicate is 
in tum broken up into a verb ("sees"), a direct object ("Spot"), and a participle that 
modifies the direct object ("run"). Figure 1.2 shows how the sentence is represented by 
a conventional sentence diagram like the ones you learned to make in the sixth grade. 
A compiler performs this same process (of decomposing a sentence into its com-The parser phase. 
ponent parts) in the parser phase, though it usually represents the parsed sentence in a 
4 
Syntax diagrams and 
trees. 
Syntax trees. 
Parse trees. 
Sentence: formal 
definition. Basic Concepts-Chapter 1 
Figure 1.2. A Sentence Diagram for Jane Sees Spot Run 
sees Spot Jane I \ 
~-_ru_n __ 
tree form rather than as sentence diagram. (In this case, the sentence is an entire pro­
gram.) 
The sentence diagram itself shows the syntactic relationships between the parts of 
the sentence, so this kind of graph is formally called a syntax diagram (or, if it's in tree 
form, a syntax tree). You can expand the syntax tree, however, to show the grammatical 
structure as well as the syntactic structure. This second representation is called a parse 
tree. A parse tree for our earlier sentence diagram is shown in Figure 1.3. Syntax and 
parse trees for the expression A*B+C*D are shown in Figure 1.4. A tree structure is used 
here primarily because it's easy to represent in a computer program, unlike a sentence 
diagram. 
Figure 1.3. A Parse Tree for Jane Sees Spot Run 
sentence 
/~ 
subject predicate 
I I~ 
noun verb object 
I~ 
Jane sees noun participle 
I 
Spot run 
A sentence, by the way, is also a technical term, though it means the same thing as it 
does in English. It's a collection of tokens that follow a well-defined grammatical struc­
ture. In the case of a compiler, the sentence is typically an entire computer program. 
The analogy is evident in a language like Pascal, which mirrors English punctuation as 
well as its grammar. A Pascal program ends with a period, just like an English sentence. 
Similarly, a semicolon is used as punctuation to separate two complete ideas, just as it 
separates two independent clauses in English. 
To summarize: A parser is a group of subroutines that converts a token stream into a 
parse tree, and a parse tree is a structural representation of the sentence being parsed. 
Looked at another way, the parse tree represents the sentence in a hierarchical fashion, 
moving from a general description of the sentence (at the root of the tree) down to the 
specific sentence being parsed (the actual tokens) at the leaves. Some compilers create a 
physical parse tree, made up of structures, pointers, and so forth, but most represent the 
Section 1.1.2-The Parser 
Figure 1.4. Syntax and Parse Trees for A *B + C*D 
+ ~ 
* 1\ 1\ 
A B c D 
expression 
factor +factor 
----------------- factor *factor factor *factor 
I I I I 
A B c D 
parse tree implicitly.1 Other parse methods just keep track of where they are in the tree, 
without creating a physical tree (we'll see how this works shortly). The parse tree itself 
is a very useful concept, however, for understanding how the parse process works. 
1.1.3 The Code Generator 
The last part of the compiler proper is the code generator. It's somewhat misleading 
to represent this phase as a separate component from the parser proper, because most 
compilers generate code as the parse progresses. That is, the code is generated by the 
same subroutines that are parsing the input stream. It is possible, however, for the parser 
to create a parse tree for the entire input file, which is then traversed by a distinct code 
generator, and some compilers work in this way. A third possibility is for the parser to 
create an intermediate-language representation of the input from which a syntax tree can 
be reconstructed by an optimization pass. Some optimizations are easier to perform on a 
syntax tree than on a linear instruction stream. A final, code-generation pass can 
traverse the optimizer-modified syntax tree to generate code. 
Though compilers can generate object code directly, they often defer code genera­
tion to a second program. Instead of generating machine language directly, they create a 
program in an intermediate language that is translated by the compiler's back end into 
actual machine language. You can look at an intermediate language as a sort-of super 
assembly language that's designed for performing specific tasks (such as optimization). 
As you might expect, there are many flavors of intermediate languages, each useful in 
different applications. 
There are advantages and disadvantages to an intermediate-language approach to 
compiler writing. The main disadvantage is lack of speed. A parser that goes straight 
from tokens to binary object code will be very fast, since an extra stage to process the 
intermediate code can often double the compile time. The advantages, however, are 
I. A physical parse tree is useful for some kinds of optimizations, discussed further in Chapter Seven. Intermediate languages, 
back ends. 5 
Advantages and disad­
vantages of intermediate 
languages. 
6 
Interpreters. 
C Code: The intermedi­
ate language used in this 
book. 
Anonymous temporaries. Basic Concepts-Chapter I 
usually enough to justify the loss of speed. These are, in a nutshell, optimization and 
flexibility. A few optimizations, such as simple constant folding-the evaluation of con­
stant expressions at compile time rather than run time-can be done in the parser. Most 
optimizations, however, are difficult, if not impossible, for a parser to perform. Conse­
quently, parsers for optimizing compilers output an intermediate language that's easy for 
a second pass to optimize. 
Intermediate languages give you flexibility as well. A single lexical-analyzer/parser 
front end can be used to generate code for several different machines by providing 
separate back ends that translate a common intermediate language to a machine-speci fie 
assembly language. Conversely, you can write several front ends that parse several 
different high-level languages, but which all output the same intermediate language. 
This way, compilers for several languages can share a single optimizer and back end. 
A final use of an intermediate language is found in incremental compilers or inter­
preters. These programs shorten the development cycle by executing intermediate code 
directly, rather than translating it to binary first, thereby saving the time necessary for 
assembling and linking a real program. An interpreter can also give you an improved 
debugging environment because it can check for things like out-of-bounds array index­
ing at run time. 
The compiler developed in Chapter Six uses an intermediate language for the output 
code. The language itself is described in depth in that chapter, but some mention of it is 
necessary here, because I'll be using the language informally for code-generation exam­
ples throughout this book. Put simply, the intermediate language is a subset of C in 
which most instructions translate directly to a small number of assembly-language 
instructions on a typical machine (usually one or two). For example, an expression like 
x=a+b*c+d is translated into something like this: 
tO a 
tl b 
tl *= c 
tO += tl 
tO += d 
The t 0 and t 1 in the foregoing code are temporary variables that the compiler allocates 
to hold the result of the partially-evaluated expression. These are called anonymous tem­
poraries (often shortened to just temporaries) and are discussed in greater depth below. 
The underscores are added to the names of declared variables by the compiler so that 
they won't be confused with variables generated by the compiler itself, such as tO, and 
tl (which don't have underscores in their names). 
Since the intermediate language is soC like, I'm going to just use it for now without 
a formal language definition. Remember, though, that the intermediate language is not C 
(there would be little point in a compiler that translated good C into bad C)-it is really 
an assembly language with a C-like syntax. 
1.2 Representing Computer Languages 
A compiler is like every other program in that some sort of design abstraction is use­
ful when constructing the code. Flow charts, Warnier-Orr diagrams, and structure charts 
are examples of a design abstraction. In compiler applications, the best abstraction is 
one that describes the language being compiled in a way that reflects the internal struc­
ture of the compiler itself. 
Section 1.2.1-Grammars and Parse Trees 
1.2.1 Grammars and Parse Trees 
The most common method used to describe a programming language in a formal way 
is also borrowed from linguistics. This method is a formal grammar, originally 
developed by M.I.T.'s Noam Chomsky and applied to computer programs by J.W. 
Backus for the first FORTRAN compilers. 
Formal grammars are most often represented in a modified Backus-Naur Form (also 
called Backus-Normal Form), BNF for short. A strict BNF representation starts with a 
set of tokens, called terminal symbols, and a set of definitions, called nonterminal sym­
bols. The definitions create a system in which every legal structure in the language can 
be represented. One operator is supported, the ::=operator, translated by the phrase "is 
defined as" or "goes to." For example, the following BNF rule might start a grammar for 
an English sentence: 
sentence : := subject predicate 
A sentence is defined as a subject followed by a predicate. You can also say "a sentence 
goes to a subject followed by a predicate." Each rule of this type is called a production. 
The nonterminal to the left of the ::=is the left-hand side and everything to the right of 
the ::= is the right-hand side of the production. In the grammars used in this book, the 
left-hand side of a production always consists of a single, nonterminal symbol, and every 
nonterminal that's used on a right-hand side must also appear on a left-hand side. All 
symbols that don't appear on a left-hand side, such as the tokens in the input language, 
are terminal symbols. 
A real grammar continues with further definitions until all the terminal symbols are 
accounted for. For example, the grammar could continue with: 
subject 
noun noun 
JANE 
where JANE is a terminal symbol (a token that matches the string "Jane" in the input). 
The strict BNF is usually modified to make a grammar easier to type, and I'll use a 
modified BNF in this book. The first modification is the addition of an OR operator, Backus-Naur Form 
(BNF). 7 
Terminal and nonterminal 
symbols. 
The : : = and ~ opera­
tors. 
Productions. 
Left-hand and right-hand 
sides (LHS and RHS). 
represented by a vertical bar (1). For example, Modified BNF: the I 
noun 
noun noun .. -
.. -
.. -JANE 
DICK 
SPOT 
is represented as follows: 
noun ::=DICK I JANE I SPOT 
Similarly, a~ is often substituted for the::= as in: 
noun ~ DICK I JANE 
I use the ~ in most of this book. I also consistently use italics for nonterminal symbols 
and boldface for terminals (symbols such as + and * are also always terminals-they'll 
also be in boldface but sometimes it's hard to tell.) 
There's one other important concept. Grammars must be as flexible as possible, and 
one of the ways to get that flexibility is to make the application of certain rules optional. 
A rule like this: 
article ~ THE 
says that THE is an article, and you can use that production like this: operator. 
~ used for : : = 
Terminals=boldface. 
nonterminals=italic. 
Optional rules and E. 
8 
Epsilon (E) productions. 
Recognizing a sentence 
using the grammar. Basic Concepts-Chapter I 
object ~ article noun 
In English, an object is an article followed by a noun. A rule like the foregoing requires 
that all nouns that comprise an object be preceded by a participle. But what if you want 
the article to be optional? You can do this by saying that an article can either be the 
noun "the" or an empty string. The following is used to do this: 
article ~ THE I E 
The E (pronounced "epsilon") represents an empty string. If the THE token is present in 
the input, then the 
article ~ THE 
production is used. If it is not there, however, then the article matches an empty string, 
and 
article ~ E 
is used. So, the parser determines which of the two productions to apply by examining 
the next input symbol. 
A grammar that recognizes a limited set of English sentences is shown below: 
sentence ~ subject predicate 
subject ~ noun 
predicate ~ verb object 
object ~ noun opt _yarticiple 
opt _yarticiple ~ participle I E 
noun ~ SPOT I JANE I DICK 
participle ~ RUN 
verb ~ SEES 
An input sentence can be recognized using this grammar, with a series of replace­
ments, as follows: 
(1) Start out with the topmost symbol in the grammar, the goal symbol. 
(2) Replace that symbol with one of its right-hand sides. 
(3) Continue replacing nonterminals, always replacing the leftmost nonterminal with 
its right-hand side, until there are no more nonterminals to replace. 
For example, the grammar can be used to recognize "Jane sees Spot run" as follows: 
sentence 
subject predicate 
noun predicate 
JANE predicate 
JANE verb object 
JANE SEES object 
JANE SEES noun opt_yarticiple 
JANE SEES SPOT opt _yarticiple 
JANE SEES SPOT participle 
JANE SEES SPOT RUN apply sentence~subject predicate to get: 
apply subject~noun to get: 
apply noun~JANE to get: 
apply predicate~verb object to get: 
apply verb~SEES to get: 
apply object~noun op_participle to get: 
apply noun~SPOT to get: 
apply opt _yarticiple ~participle to get: 
apply participle~RUN to get: 
done-there are no more nonterminals to replace 
These replacements can be used to build the parse tree. For example, replacing sentence 
with subject predicate is represented in tree form like this: 
Section 1.2.1 -Grammars and Parse Trees 
sentence 
subject predicate 
The second replacement, of subject with noun, would modify the tree like this: 
sentence 
subject predicate 
I 
noun 
and so forth. The evolution of the entire parse tree is pictured in Figure 1.5. 
A glance at the parse tree tells you where the terms terminal and nonterminal come 
from. Terminal symbols are always leaves in the tree (they're at the end of a branch), 
and nonterminal symbols are always interior nodes. 
1.2.2 An Expression Grammar 
Table 1.1 shows a grammar that recognizes a list of one or more statements, each of 
which is an arithmetic expression followed by a semicolon. Statements are made up of a 
series of semicolon-delimited expressions, each comprising a series of numbers 
separated either by asterisks (for multiplication) or plus signs (for addition). 9 
Terminals are leaf nodes. 
Nonterminals are interior 
nodes. 
Note that the grammar is recursive. For example, Production 2 has statements on Recursion in grammar. 
both the left-and right-hand sides. There's also third-order recursion in Production 8, 
since it contains an expression, but the only way to get to it is through Production 3, 
which has an expression on its left-hand side. This last recursion is made clear if you 
make a few algebraic substitutions in the grammar. You can substitute the right-hand 
side of Production 6 in place of the reference to term in Production 4, yielding 
expression ~factor 
and then substitute the right-hand side of Production 8 in place of the factor: 
expression ~ ( expression ) 
Since the grammar itself is recursive, it stands to reason that recursion can also be used 
to parse the grammar-1'11 show how in a moment. The recursion is also important from 
a structural perspective-it is the recursion that makes it possible for a finite grammar to 
recognize an infinite number of sentences. 
The strength of the foregoing grammar is that it is intuitive-its structure directly 
reflects the way that an expression goes together. It has a major problem, however. The 
leftmost symbol on the right-hand side of several of the productions is the same symbol 
that appears on the left-hand side. In Production 3, for example, expression appears both 
on the left-hand side and at the far left of the right-hand side. The property is called left 
recursion, and certain parsers (such as the recursive-descent parser that I'll discuss in a 
moment) can't handle left-recursive productions. They just loop forever, repetitively 
replacing the leftmost symbol in the right-hand side with the entire right-hand side. 
You can understand the problem by considering how the parser decides to apply a 
particular production when it is replacing a nonterminal that has more than one right­
hand side. The simple case is evident in Productions 7 and 8. The parser can choose 
which production to apply when it's expanding afactor by looking at the next input sym-
bol. If this symbol is a number, then the compiler applies Production 7 and replaces the Left recursion. 
Why left recursion 
causes problems-an ex­
ample. 
10 Basic Concepts-Chapter 1 
Figure 1.5. Evolution of a Parse Tree 
(I) (2) (3) (4) 
sentence sentence sentence sentence 
(5) 
(7) 
(9) /~ /~ /~ 
subject predicate subject predicate subject predicate 
I I 
noun noun 
I 
Jane 
sentence (6) sentence 
/ ~ / ~ 
subject predicate subject predicate 
I I ~ I I~ 
noun verb object noun verb object 
I I I 
Jane Jane sees 
sentence (8) sentence 
/ ~ /~ 
subject predicate subject predicate 
I I ~ I I~ 
noun verb object noun verb object 
I I I ~ I I I ~ 
Jane sees noun opt _yarticple Jane sees noun 
I opt _yarticple 
Spot 
(10) sentence 
/~ 
subject 
I predicate 
I~ 
verb object 
I I~ 
noun opt _yarticple 
I I 
Spot particple sees sentence 
/ ~ 
subject predicate 
I I ~ 
noun verb object 
I I I ~ 
Jane sees noun opt _yarticple 
I I 
Spot particple noun 
I 
Jane 
I 
run 
factor with a number. If the next input symbol was an open parenthesis, the parser 
would use Production 8. The choice between Productions 5 and 6 cannot be solved in 
this way, however. In the case of Production 6, the right-hand side of term starts with a 
factor which, in tum, starts with either a number or left parenthesis. Consequently, the 
parser would like to apply Production 6 when a term is being replaced and the next input 
symbol is a number or left parenthesis. Production 5-the other right-hand side-starts 
with a term, which can start with a factor, which can start with a number or left 
parenthesis, and these are the same symbols that were used to choose Production 6. To 
Section 1.2.2-An Expression Grammar 
Table 1.1. A Simple Expression Grammar 
I. statements ~ expression ; 
2. I expression ; statements 
3. expression ~ expression + term 
4. I term 
5. term ~ term *factor 
6. I factor 
7. factor ~ number 
8. I ( expression ) 
summarize, the parser must be able to choose between one of several right-hand sides by 
looking at the next input symbol. It could make this decision in Productions 7 and 8, but 
it cannot make this decision in Productions 5 and 6, because both of the latter produc­
tions can start with the same set of terminal symbols. 
The previous situation, where the parser can't decide which production to apply, is 
called a conflict, and one of the more difficult tasks of a compiler designer is creating a 
grammar that has no conflicts in it. The next input symbol is called the lookahead sym­
bol because the parser looks ahead at it to resolve a conflict. 
Unfortunately, for reasons that are discussed in Chapter Four, you can't get rid of the 
recursion by swapping the first and last production element, like this: 
expression~term + expression 
so the grammar must be modified in a very counterintuitive way in order to build a 
recursive-descent parser for it. Several techniques can be used to modify grammars so 
that a parser can handle them, and all of these are discussed in depth in Chapter Four. 
I'll use one of them now, however, without any real explanation of why it works. Take it 
on faith that the grammar in Table 1.2 recognizes the same input as the one we've been 
using. (I'll discuss the 1-and E that appear in the grammar momentarily.) The modified 
grammar is obviously an inferior grammar in terms of self-documentation-it is difficult 
to look at it and see the language that's represented. On the other hand, it works with a 
recursive-descent parser, and the previous grammar doesn't. 
Table 1.2. Modified Simple-Expression Grammar 
I. statements ~ 1-
2. I expression ; statements 
3. expression ~ term expression' 
4. expression' ~ + term expression' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor term' 
8. I E 
9. factor ~ number 
10. I ( expression ) Conflicts and look­
aheads. 
Modified expression 
grammar. 11 
The 1-symbol is an end-of-input marker. For the purposes of parsing, end of file is End-of-input symbol (1-). 
treated as an input token, and 1-represents end of input in the grammar. In this grammar, 
Production I is expanded if the current input symbol is end of input, otherwise Produc-
tion 2 is used. Note that an explicit end-of-input marker is often omitted from a 
12 
Applying E. 
E is a terminal, but not a 
token. 
Translating grammars to 
syntax diagrams. Basic Concepts-Chapter I 
grammar, in which case 1-is implied as the rightmost symbol of the starting production 
(the production whose left-hand side appears at the apex of the parse tree). Since elim­
inating the 1-symbol removes the entire right-hand side in the current grammar, you can 
use the following as an alternate starting production: 
statements ~ E I expression ; statements 
In English: statements can go to an empty string followed by an implied end-of-input 
marker. 
The replacement of the left-hand side by E (the empty string) occurs whenever the 
current input symbol doesn't match a legallookahead symbol. In the current grammar, a 
term' is replaced with the right-hand side *factor term' if the lookahead symbol (the next 
input symbol) is a*· The term' is replaced withE if the next input symbol isn't a*· The 
process is demonstrated in Figure 1.6, which shows a parse of 1 + 2 using the modified 
grammar in Table 1.2. The E production stops things from going on forever. 
Figure 1.6. A Parse of 1 + 2 
statements ~~ 
expression ~~ 
term expression' /1 /1~ 
factor term' + term expression' 
I I I I 
1 E factor E 
I 
2 
Note that E is a terminal symbol that is not a token. It always appears at the end of a 
branch in the parse tree, so it is a terminal, but it does not represent a corresponding 
token in the input stream Uust the opposite in fact-it represents the absence of a partic­
ular token in the input stream). 
1.2.3 Syntax Diagrams 
You can prove to yourself that the grammar in Table 1.2 works as expected by 
representing it in a different way-as a syntax diagram. We saw earlier that a syntax 
diagram can represent the entire syntactic structure of a parse, but you can also use it in a 
more limited sense to represent the syntax of a single production. Syntax diagrams are 
useful in writing recursive-descent compilers because they translate directly into flow 
charts (that's the main reason we're looking at them now). You can use them as a map 
that describes the structure of the parser (more on this in a moment). They are also 
somewhat more intuitive to an uninitiated reader, so they often make better documenta­
tion than does a formal grammar. 
I'll translate our grammar into a syntax diagram in two steps. First, several of the 
productions can be merged together into a single diagram. Figure 1.7 represents Produc­
tions 3, 4, and 5 of the grammar in Table 1.2 on page 11. The E production is represented 
by the uninterrupted line that doesn't go through a box. You can combine these two 
Section 1.2.3 -Syntax Diagrams 
graphs by substituting the bottom graph for the reference to it in the top graph, and the 
same process can be applied to Productions 6, 7, and 8. 
Figure 1.7. Syntax Diagram for Productions 3, 4, and 5 
expression --->3>1 '--l __ t_er_m_---'r------'>3>11 expression' > 
expression' 
term 
The entire grammar in Table 1.2 is represented as a syntax diagram in Figure 1.8. The 
topmost diagram, for example, defines a statement as a list of one or more semicolon­
delimited expressions. The same thing is accomplished by 
statements ~ expression ; 
I expression ; statements 
but the BNF form is harder to understand. 13 
The merged diagram also demonstrates graphically how the modified grammar Diagram shows how 
works. Just look at it like a flow chart, where each box is a subroutine, and each circle or modified grammar works. 
ellipse is the symbol that must be in the input when the subroutine returns. Passing 
through the circled symbol removes a terminal from the input stream, and passing 
through a box represents a subroutine call that evaluates a nonterminal. 
1.3 A Recursive-Descent Expression Compiler 
We now know enough to build a small compiler, using the expression grammar 
we've been looking at (in Table 1.2 on page 11). Our goal is to take simple arithmetic 
expressions as input and generate code that evaluates those expressions at run time. An 
expression like a+b*c+d is translated to the following intermediate code: 
tO a 
tl b 
t1 *= c 
tO += tl 
tO += d 
1.3.1 The Lexical Analyzer 
The first order of business is defining a token set. With the exception of numbers and Expression token set. 
identifiers, all the lexemes are single characters. (Remember, a token is an input symbol 
taken as a unit, a lexeme is the string that represents that symbol.) A NUM_OR_ID NUM_OR_ID 
token is used both for numbers and identifiers; so, they are made up of a series of con-
tiguous characters in the range ' 0' -' 9' , ' a'-' z' , or 'A'-' z' . The tokens them-
selves are defined with the macros at the top of lex.h, Listing 1.1. The lexical analyzer 
translates a semicolon into a SEMI token, a series of digits into a NUM_OR_ID token, 
14 
yytext, yyleng. 
Simple, buffered, input 
system. Basic Concepts-Chapter I 
Figure 1.8. A Syntax Diagram 
statement -----,t.------->~1 expression f--->:o>~G)r-----~~---=>:;. 
~--'~J 
expression' 1 
expression term 
term 
term' 
term factor 
factor 
factor 
expression 
and so on. The three external variables at the bottom of lex.h are used by the lexical 
analyzer to pass information to the parser. yytext points at the current lexeme, which 
is not ' \0' terminated; yy 1 eng is the number of characters in the lexeme; and 
yylineno is the current input line number. (I've used these somewhat strange names 
because both lex and LEX use the same names. Usually, I try to make global-variable 
names begin with an upper-case letter and macro names are all caps. This way you can 
distinguish these names from local-variable names, which are always made up of lower­
case letters only. It seemed best to retain UNIX compatibility in the current situation, 
however.) 
The lexical analyzer itself starts on line nine of /eX,(:, Listing 1.2. It uses a simple, 
buffered, input system, getting characters a line at a time from standard input, and then 
isolating tokens, one at a time, from the line. Another input line is fetched only when the 
entire line is exhausted. There are two main advantages to a buffered system (neither of 
which are really exercised here, though the situation is different in the more sophisti­
cated input system discussed in Chapter Two). These are speed and speed. Computers 
like to read data in large chunks. Generally, the larger the chunk the faster the 
throughput. Though a 128-byte buffer isn't really a large enough chunk to make a 
Section 1.3.1-The Lexical Analyzer 
Listing 1.1. lex.h-Token Definitions and extern statements 
I #define EOI 0 I* end of input 
2 #define SEMI 1 I* ; 
3 #define PLUS 2 I* + 
4 #define TIMES 3 I* * 
5 #define LP 4 I* ( 
6 #define RP 5 I* ) 
7 #define NUM OR ID 6 I* decimal number or identifier 
8 
9 extern char *yytext; I* in lex.c 
10 extern int yyleng; 
II extern int yylineno; 
difference, once the buffer size gets above the size of a disk cluster, the changes are more 
noticeable, especially if you can use the unbuffered 1/0 functions to do your reading and 
writing. The second speed issue has to do with lookahead and pushback. Lexical 
analyzers often have to know what the next input character is going to be without actu­
ally reading past it. They must look ahead by some number of characters. Similarly, 
they often need to read past the end of a lexeme in order to recognize it, and then push 
back the unnecessary characters onto the input stream. Consequently, there are often 
extra characters that must be handled specially. This special handling is both difficult 
and slow when you're using single-character input. Going backwards in a buffer, how­
ever, is simply a matter of moving a pointer. 
Listing 1.2. lex.c-A Simple Lexical Analyzer 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include 
#include 
#include 
char 
int 
int 
lex() 
{ "lex.h" 
<stdio.h> 
<ctype.h> 
*yytext ""; I* 
yyleng 0; I* 
yylineno 0; I* Lexeme (not , \0, 
Lexeme length. 
Input line number 
static char input_buffer[l28]; 
char *current; terminated) *I 
*I 
*I *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
Lookahead and push­
back. 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 current yytext + yyleng; I* Skip current lexeme *I 
while( 1 ) 
{ 
while( !*current ) 
{ I* Get the next one *I 
I* Get new lines, skipping any leading white space on the line, 
* until a nonblank line is found. 
*I 
current = input_buffer; 
if( !gets( input_buffer ) ) 
{ 
*current = '\0' 
return EOI; 15 
.... 
16 Basic Concepts-Chapter I 
Listing 1.2. continued ... 
31 
32 
33 
34 
35 
36 
37 
38 39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
Reading characters: 
input_buffer, 
current. 
Tokenization. for( 
{ ++yylineno; 
while( isspace(*current) 
++current; 
*current ; ++current ) 
/* Get the next token */ 
yytext 
yyleng current; 
1; 
switch( *current 
{ 
case EOF: return EOI 
case ' i , : return SEMI 
case '+' : return PLUS 
case ' *, : return TIMES 
case , ( , : return LP 
case , ) , : return RP 
case , \n' : 
case , \ t, : 
case break; 
default: 
if( !isalnum(*current) 
fprintf(stderr, "Ignoring illegal input <%c>\n", *current); 
else 
{ 
while( isalnum(*current) 
++current; 
yyleng = current -yytext; 
return NUM_OR_ID; 
break; 
The input buffer used by lex () is declared on line 11 of Listing 1.2. current (on 
line 12) points at the current position in the buffer. On the first call, the increment on 
line 14 initializes cur rent to point at an empty string (yy leng is 0 at this juncture, and 
yytext points at an empty string because of the initializer on line five). The while 
statement on line 18 tests true as a consequence. This while loop has two purposes. It 
gets lines (and increments the line number), and it skips past all blank lines (including 
lines that contain only white space). The loop doesn't terminate until input_ buffer 
holds a nonblank line, and current will point at the first nonwhite character on that 
line. 
The for loop starting on line 37 does the actual tokenization. Single-character lex­
emes are recognized on lines 46-51, white space is ignored by the cases on lines 53-55, 
and the multiple-character NUM _OR_ ID token is handled in the else clause on lines 
Section 1.3.1 -The Lexical Analyzer 
6Q-67. An error message is printed if an illegal character is found. When the loop ter­
minates, yytext points at the first character ofthe lexeme, and yyleng holds its length. 
The next time lex ( ) is called, the code on line 14 adjusts the current pointer to 
point past the previous lexeme, and then, if the input buffer hasn't been exhausted, the 
while test on line 18 fails and you go straight to the token-isolation code. lex ( ) won't 
get another input line until it reaches the end of the line-* current is '\0' in this 
case. 
The remainder of lex.c (in Listing 1.3) addresses the problem of lookahead. The Solving the lookahead 
parser must look at the next input token without actually reading it. Though a problem. 
read/pushback scheme similar to getc () /ungetc () could be used for this purpose, it's 
generally a good idea to avoid going backwards in the input, especially if you have to 
push back entire lexemes rather than single characters. The problem is solved by using 
two subroutines: match (token) evaluates to true if the next token in the input stream match 0. advance 0. 
matches its argument-it "looks ahead" at the next input symbol withou~ reading it. 
advance () discards the current token and advances to the next one. This strategy elim-
inates the necessity of a push-back subroutine such as ungetc (). 
The Lookahead variable (on line 74) holds the lookahead token. It's initialized Lookahead. 
to -1, which is not used for any of the input tokens. It's modified to hold a real token the 
first time match () is called. Thereafter, the test on line 81 will become inoperative and 
match () simply returns true if Lookahead matches its argument. This approach is 
relatively foolproof-though the fool in this case is myself. I know that I'll regularly 
forget to call an initialization routine before calling match ( ) , so I'll let match () ini-
tialize itself the first time it's called. The advance ( ) function just calls lex ( ) to 
assign a new value to Lookahead. 
Listing 1.3. lex.c-Match and Advance Functions 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 89 
90 
91 
92 static int Lookahead = -1; 
int match( token ) 
int token; 
{ /* Lookahead token */ 
/* Return true if "token" matches the current lookahead symbol. */ 
if( Lookahead == -1 ) 
Lookahead lex() ; 
return token == Lookahead; 
void advance () 
/* Advance the lookahead to the next input symbol. */ 
Lookahead =lex(); 
1.3.2 The Basic Parser 
Moving on to the parser, since I'm planning to start with a naive implementation and 
refine it, I've isolated main ( ) into a small file (Listing 1.4) that I can compile once and 
then link with the parser proper. The parser itself is called statements ( ) . statements 0. 
The most naive parser for our grammar is shown in Listing 1.5. I've reproduced the 
grammar here for convenience: 17 
18 Basic Concepts-Chapter 1 
Listing 1.4. main.c 
1 
2 
3 
4 main() 
{ 
statements(); 
I. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
9. 
10. statements 
expression 
expression' 
term 
term' 
factor ~ expression ; 1-
I expression ; statement 
~ term expression' 
~ + term expression' 
I E 
~ factor term' 
~ *factor term' 
I E 
~ num or id 
I ( expression ) 
Subroutines correspond 
to left-hand sides, imple­
ment right-hand sides. The parser generates no code, it just parses the input. Each subroutine corresponds to 
the left-hand side in the original grammar that bears the same name. Similarly, the struc­
ture of each subroutine exactly matches the grammar. For example, the production 
E recognized. expression ~ term expression' 
is implemented by the following subroutine (on line 23 of Listing 1.5): 
expression () 
{ 
term (); 
expr _prime () ; 
The E production in 
expression' ~ PLUS term expression' I E 
Subroutines advance 
past recognized tokens. is implemented implicitly when the test on line 37 fails (if it's not a PLUS, it's an E). 
Note that each subroutine is responsible for advancing past any tokens that are on the 
equivalent production's right-hand side. 
Listing 1.5. plain.c- A Naive Recursive-Descent Expression Parser 
1 /* Basic parser, shows the structure but there's no code generation */ 
2 
3 #include <stdio.h> 
4 #include "lex.h" 
5 
6 statements () 
7 { 
8 /* statements -> expression SEMI 
9 * expression SEMI statements 
10 */ 
II 
12 expression(); 
13 
14 if ( match ( SEMI ) ) 
15 advance () ; 
.... 
Section 1.3.2-The Basic Parser 
Listing 1.5. continued ... 
else 16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 68 
69 
70 
71 
72 fprintf( stderr, "%d: Inserting missing semicolon\n", yylineno ); 
if( !match(EOI) ) 
statements(); 
expression () 
{ 
/* expression -> term expression' */ 
term (); 
expr_prime(); 
expr_prime () 
{ /* Do another statement. */ 
/* expression' -> PLUS term expression' 
* epsilon 
*I 
if( match( PLUS ) ) 
{ 
term() 
{ advance(); 
term(); 
expr _prime(); 
/* term -> factor term' */ 
factor(); 
term_prime(); 
term _prime () 
/* term' -> TIMES factor term' 
* epsilon 
*I 
if( match( TIMES ) ) 
{ 
factor() 
{ advance(); 
factor(); 
term_prime(); 
/* factor 
* -> 
*I NUM OR ID 
LP expression RP 19 
.... 
20 Basic Concepts-Chapter 1 
Listing 1.5. continued ... 
73 if( match(NUM_OR ID) 
74 advance(); 
75 
76 else if( match(LP) 
77 { 
78 advance(); 
79 expression(); 
80 if ( match (RP) 
81 advance(); 
82 else 
83 fprintf( stderr, "%d: Mismatched parenthesis\n", yylineno); 
84 
85 else 
86 fprintf ( stderr, "%d Number or identifier expected\n", yylineno ) ; 
87 
The recursion in a 
recursive-descent parser. 
Subroutine calling se­
quence mirrors the parse 
tree. You can now see why a production like 
expression ~expression + term 
can't be used by a recursive-descent parser. You can implement the foregoing as fol­
lows: 
expression () 
{ 
expression(); 
if ( !match ( PLUS ) ) 
error(); 
else 
advance(); 
term(); 
But the first thing that expression () does is call itself, the recursion never stops, and 
the program never terminates-at least not until it runs out of stack space and is abnor­
mally terminated by the operating system. 
At this point I'd suggest doing an exercise. Using a pencil and paper, trace what hap­
pens as the expression 1 + 2 is evaluated by the parser in Listing 1.5. Every time a sub­
routine is called, draw a downward pointing arrow and write the name of the called sub­
routine under the arrow; every time the subroutine returns, draw an arrow at the other 
end of the same line. As the parser advances past tokens, write them down under the 
name of the current subroutine. A partial subroutine trace for this expression is shown in 
Figure 1.9. The diagram shows the condition of the parser when it is in subroutine 
expr _prime ( ) just before the term ( ) call on line 40. It's advanced past the 1 and 
the current lookahead token is the plus sign. If you finish this diagram, an interesting 
fact emerges. The subroutine trace is identical to the parse tree for the same expression 
in Figure 1.6 on page 12. So, even though no physical parse tree is created, a parse tree 
is implicit in the subroutine-calling sequence. 
Section 1.3.2-The Basic Parser 
Figure 1.9. A Partial Subroutine Trace for 1 + 2 
statements 
/ expression /~ term expr_prime 
/~ 
factor 
1 
1.3.3 Improving the Parser term_prime 
E 
The naive parser discussed in the previous section is useful for explaining things, but 
is not much use in practice. The main difficulty is the tremendous amount of unneces­
sary recursion. Glancing at the syntax diagram for our grammar (in Figure 1.8 on page 
14), two changes come to mind immediately. First, all the right recursion-productions 
in which the left-hand side also appears at the far right of the right-hand side-can be 
replaced by loops: If the last thing that a subroutine does is call itself, then that recursive 
call can be replaced by a loop. Right recursion is often called tail recursion. 
The second obvious improvement is that the same merging together of productions 
that was done to make the second and third graphs in Figure 1.8 can be applied to the 
subroutines that implement these productions. Both of these changes are made in Listing 
1.6. 
Listing 1.6. improved.c- An Improved Parser 
I 
2 
3 
4 
5 
6 
7 
8 
9 I* Revised parser 
#include <stdio.h> 
#include "lex.h" 
void factor 
void term 
void expression 
10 statements () 
II I *I 
void ) ; 
void ) ; 
void ) ; 21 
Eliminate right recursion. 
Merging productions into 
a single subroutine. 
12 I* statements -> expression SEMI 1 expression SEMI statements *I 
13 
14 while ( ! match (EOI) 
15 { 
16 expression(); 
17 
18 if( match( SEMI ) ) 
19 advance(); 
20 else 
21 fprintf( stderr, "%d: Inserting missing semicolon\n", yylineno ) ; 
22 
23 
24 
.... 
22 Basic Concepts-Chapter 1 
Listing 1.6. continued ... 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 void 
{ expression () 
/* expression -> term expression' 
* expression' -> PLUS term expression' 
*I 
if( !legal_lookahead( NUM_OR_ID, LP, 0 ) ) 
return; 
term(); 
while( match( PLUS ) ) 
{ 
void advance(); 
term(); 
term() 
if( !legal_lookahead( NUM_OR_ID, LP, 0 ) ) 
return; 
factor(); 
while( match( TIMES ) ) 
{ 
void 
{ advance(); 
factor(); 
factor() 
if( !legal_lookahead( NUM_OR_ID, LP, 0 ) ) 
return; 
if( match(NUM_OR ID) 
advance(); 
else if( match(LP) 
{ 
advance(); 
expression(); 
if( match(RP) 
advance(); 
else epsilon 
fprintf( stderr, "%d: Mismatched parenthesis\n", yylineno ) ; 
else 
fprintf( stderr, "%d: Number or identifier expected\n", yylineno ) ; 
Error recognition, FIRST 
sets. I've made one additional change here as well. I've introduced a little error recovery 
by adding code to each subroutine that examines the current lookahead token before 
doing anything else. It's an error if that token cannot legitimately occur in the input. For 
example, expressions all have to start with either a NUM _OR_ ID or an LP. If the loo­
kahead character is a PLUS at the top of expression ( ) , then something's wrong. 
This set of legitimate leading tokens is called a FIRST set, and every nonterminal 
Section 1.3.3-Improving the Parser 23 
symbol has its own FIRST set. FIRST sets are discussed in depth in Chapter Three-the 
informal definition will do for now, though. 
The legal_lookahead ( ) subroutine in Listing 1.7 checks these FIRST sets, and Error recovery: 
if the next input symbol is not legitimate, tries to recover from the error by discarding all legal_lookahead ( > · 
input symbols up to the first token that matches one of the arguments. The subroutine 
takes a variable number of arguments, the last one of which must be zero. I've used the 
ANSI variable-argument mechanism here, so the routine can take any number of argu-
ments as parameters, but the last one must be a 0. (This mechanism, and the <stdarg.h> 
file, is described in Appendix A if you're not already familiar with it.) 
One final C style note is needed to head off the inevitable criticism of the qoto state- Style note: the goto. 
menton line 118 of Listing 1.7. Though many programmers contend with almost reli-
gious fervor that the qoto should be obliterated from all structured programs, I strongly 
feel that there are a few situations where a judiciously used qoto makes for better code. 
Here, the qoto branch to a single label is vastly preferable to multiple return state-
ments. A subroutine that has a single exit point is much more maintainable than one 
with several exit points. You can put a single breakpoint or debugging diagnostic at the 
end of the subroutine instead of having to sprinkle them all over the place. You also 
minimize the possibility of accidentally falling off the bottom of the subroutine without 
returning a valid value. My rules of thumb about qotos are as follows: 
• Goto's are appropriate in two situations: (I) to eliminate multiple return statements 
and (2) to break out of nested loops. You can also do (2) with a flag of some sort 
(while ( ! done) ), but flags tend to make the code both larger and harder to read, so 
should be avoided. 
• Don't use a qoto unless it is the only solution to the problem. You can often elim-
inate the need for a qoto by reorganizing the code. 
• A subroutine should have at most one label. 
• All qoto branches should be in a downwards direction to that single label. 
• The target of a qoto branch should be in the same block or at a higher (more outer) 
nesting level than the qoto itself. Don't do this: 
goto label; 
label: 
Listing 1.7. improved.c- Error Recovery for the Improved Parser 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 #include <stdarg.h> 
#define MAXFIRST 16 
#define SYNCH SEMI 
int legal_lookahead( first arg 
int first_arg; 
{ 
/* Simple error detection and recovery. Arguments are a a-terminated list of 
* those tokens that can legitimately come next in the input. If the list is 
* empty, the end of file must come next. Print an error message if 
* necessary. Error recovery is performed by discarding all input symbols 
* until one that's in the input list is found 
* * Return true if there's no error or if we recovered from the error, 
* false if we can't recover. 
24 Basic Concepts-Chapter I 
Listing 1.7. continued ... 
91 
92 
93 
94 
95 
96 
97 
98 
99 *I 
va list 
int args; 
tok; 
lookaheads[MAXFIRST], *p 
error_printed 0; int lookaheads, *current; 
int 
int rval = 0; 
va_start( args, first_arg ); 
if( !first_arg ) 
{ 
else 
{ if( match(EOI) 
rval = 1; 
*p++ = first_arg; 
while( (tok = va_arg(args, int)) && p < &lookaheads[MAXFIRST] ) 
*++p = tok; 
while( !match( SYNCH ) ) 
{ 
for( current = lookaheads; current < p 
if( match( *current ) ) 
{ 
rval 1; 
goto exit; 
if( !error_printed 
{ ++current ) 
fprintf( stderr, "Line %d: Syntax error\n", yy1ineno ); 
error_printed = 1; 
advance(); 100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 exit: 
Recognizers. va_end( args 
return rval; 
1.3.4 Code Generation 
The parsers that we just looked at are, strictly speaking, recognizer programs in that, 
if they terminate without an error, the input sentence is a legal sentence in the grammar. 
All they do is recognize legal input sentences. Our goal is to build a compiler, however, 
and to do this, you need to add code generation to the bare-bones recognizer. Given the 
input 
1 + 2 * 3 + 4 
a typical compiler generates the following code: 
Section 1.3.4-Code Generation 
tO 1 
t1 2 
t2 3 
t1 *= t2 
tO += t1 
t1 4 
tO += t1 
An optimizer will clean up the unnecessary assignments. It's useful, for now, to look at 
the raw output, however. The temporary variables (tO, and so forth) are maintained 
internally by the compiler. A real compiler typically uses registers or the run-time stack 
for temporaries. Here, they're just global variables. The expression is evaluated opera­
tor by operator, with each temporary holding the result of evaluating the current subex­
pression. Sometimes (as is the case in this example) several temporaries must exist 
simultaneously in order to defer application of an operator because of precedence or 
associativity problems. Here, t 0 holds the left operand of the addition operator until the 
higher-precedence multiply is performed. 
You can also look at the temporary-variable assignments in terms of a syntax tree. 
The syntax tree for 1+2*3+4 is shown in Figure 1.10. The nodes are marked with the 
names of the temporaries that hold the evaluated subexpression represented by the sub­
tree. 
Figure l.lO.Syntax Treefor1+2*3+4 
+tO ~ 
+tO ~ 4 t1 
1\ l tO * tl 
2 t1 3 t2 
The first thing you need to generate code is a mechanism for allocating temporaries. 
Ideally, they should be recycled-the temporaries should be reused after they are no 
longer needed in the current subexpression. A simple, but effective, mechanism to do 
this is shown in Listing 1.8. (We'll look at a more elaborate system in Chapter Six.) A 
stack of temporary-variable names is declared on line one. When a new name is 
required, newname () pops one off the stack. When the temporary is no longer needed, a 
freename () call pushes it back. 
The next code-generation problem is determining the name of the temporary that 
holds the partially-evaluated expression at any given moment. This information is 
passed around between the subroutines in the normal way, using arguments and return 
values. 
To demonstrate the differences between the two methods, I'll show two parsers, one 
that uses return values exclusively, and another that uses arguments exclusively. The 
subroutine-calling tree for a parse of 1 +2*3+4; (using the improved parser) is in Figure 
1.11. The subroutines that generated this tree (and the earlier code) are in Listing 1.9. 
The arrows are marked to show the flow of temporary-variable names during the parse. 
Control flow goes counterclockwise around the drawing (the nodes are subscripted to 
show the order in which they're visited). Temporary variables at 
run time. 25 
Temporaries on the syn­
tax tree. 
Compile-time, 
temporary-variable 
management. 
newname (), 
free name (). 
Using return values in 
parser. 
26 Basic Concepts-Chapter I 
Listing 1.8. name.c- Temporary-Variable Allocation Routines 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 char *Names [] 
char **Namep { "tO", "tl", "t2", "t3", "t4", "t5", "t6", "t7" }; 
Names; 
char * newname ( ) 
{ 
if( Namep >=&Names[ sizeof(Names)/sizeof(*Names) ] ) 
{ 
fprintf( stderr, "%d: Expression too complex\n", yylineno ); 
exit( 1 ); 
return( *Namep++ ); 
freename(s) 
char *s; 
if( Namep > Names 
*--Namep = s; 
else 
fprintf(stderr, "%d: (Internal error) Name stack underflow\n", 
yylineno ); 
Figure 1.11. A Subroutine Trace of 1 + 2 (Improved Parser) 
statements, 
li-to 
expression 2 ~~ 
term 3 term 5 term 8 
lJ_tO ~t 2 lJ_tl 
factor 4 factor 6 factor 7 factor 9 
I I I I 
1 2 3 4 
Section 1.3.4-Code Generation 
Listing 1.9. retval.c- Code Generation Using Return Values 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 #include <stdio.h> 
#include "lex.h" 
char 
char 
char *factor 
*term 
*expression void ) ; 
void ) ; 
void ) ; 
extern char *newname( void ); 
extern void freename( char *name); 
statements () 
{ 
/* statements -> expression SEMI expression SEMI statements */ 
char *tempvar; 
while ( !match (EOI) 
{ 
tempvar =expression() 
if( match( SEMI ) ) 
advance(); 
else 
fprintf( stderr, "%d: Inserting missing semicolon\n", yylineno ); 
char 
{ freename( tempvar ) ; 
*expression() 
/* expression -> term expression' 
* expression' -> PLUS term expression' 
*I 
char *tempvar, *tempvar2; 
tempvar =term(); 
while( match( PLUS ) ) 
{ 
advance(); 
tempvar =term(); epsilon 
printf(" %s += %s\n", tempvar, tempvar2 ); 
freename( tempvar2 ); 
char 
{ return tempvar; 
*term () 
char *tempvar, *tempvar2 
tempvar =factor(); 
while( match( TIMES ) ) 
{ 
advance(); 
tempvar2 
printf (" factor(); 
%s *= %s\n", tempvar, tempvar2 ); 27 
.... 
28 Basic Concepts-Chapter 1 
Listing 1.9. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 freename( tempvar2 ); 
return tempvar; 
char *factor() 
( 
char *tempvar; 
if( match(NUM_OR_ID) ) 
{ 
/*Print the assignment instruction. The %0.*s conversion is a form of 
* %X.Ys, where X is the field width andY is the maximum number of 
*characters that will be printed (even if the string is longer). I'm 
* using the %0. *s to print the string because it's not \0 terminated. 
* The field has a default width of 0, but it will grow the size needed 
* to print the string. The ". *" tells printf () to take the maximum-
* number-of-characters count from the next argument (yyleng). 
*I 
printf(" %s %0.*s\n", tempvar newname(), yyleng, yytext ); 
advance(); 
else if( match(LP) 
{ 
else advance(); 
tempvar =expression(); 
if ( match (RP) ) 
advance(); 
else 
fprintf(stderr, "%d: Mismatched parenthesis\n", yylineno ); 
fprintf( stderr, "%d: Number or identifier expected\n", yylineno ); 
return tempvar; 
Generate t 0=1. A likely place to generate instructions of the form tO=l is in factor (),the subrou­
tine that reads the 1. factor () calls newname () to get an anonymous-temporary 
name, generates the code to copy the input number into the temporary, and then returns 
the name to its parent. Similarly, the best place to generate multiplication instructions is 
the place where the times signs are read: in term (). After the two factor () calls, 
tempvar and tempvar2 hold the names of the two temporaries. Code is generated to 
do the multiplication, one of the temporaries is freed, and the other (which holds the 
result of the multiply) is passed back up to the parent. So, this temporary, the one that 
holds the result of the subexpression evaluation, is used in the next step. Addition is 
handled the same way in expression (). Generate arithmetic in­
structions. 
Using subroutine argu­
ments to pass informa­
tion. Just to make sure that you understand the process, I suggest taking a moment to run 
through a parse of 1 * ( 2 + 3) * 4 by hand, creating a subroutine-calling graph as in the 
previous example and watching how the code is generated. 
Listing 1.10 shows the parser, modified once more to use subroutine arguments rather 
than return values. Here, instead of allocating the names when the instructions are gen­
erated, the temporary variables are allocated high up in the tree. Each subroutine passes 
Section 1.3.4-Code Generation 
to its child the name of the temporary in which it wants the subexpression result. That is, 
the high level routine is saying: "Do what you must to evaluate any subexpressions, but 
by the time you're finished, I want the result to be in the temporary variable whose name 
I'm passing to you." Recursive-descent compilers often use both of the methods just 
discussed-neither is more or less desirable. The code can be easier to understand if you 
restrict yourself to one or the other, though that's not always possible. 
Listing 1.10. args.c- Code Generation Using Subroutine Arguments 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include "lex.h" 
void 
void 
void factor 
term 
expression char *tempvar ) ; 
char *tempvar ); 
char *tempvar ); 
extern char *newname( void ) ; 
extern void freename( char *name); 
statements () 
{ 
/* statements -> expression SEMI 
char *tempvar; 
while ( ! match (EOI) 
{ 
expression( tempvar newname() ); 
freename( tempvar ); 
if( match( SEMI 
advance(); 
else expression SEMI statements *I 10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 fprintf( stderr, "%d: Inserting missing semicolon\n", yylineno ); 
void 
char 
{ expression( tempvar ) 
*tempvar; 
/* expression -> term expression' 
* expression' -> PLUS term expression' 
*I 
char *tempvar2; 
term( tempvar ); 
while( match( PLUS ) ) 
{ 
advance(); 
term( tempvar2 = newname() ); epsilon 
printf(" %s += %s\n", tempvar, tempvar2 ); 
freename( tempvar2 ); 29 
.... 
30 Basic Concepts-Chapter 1 
Listing 1.10. continued ... 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 void term( tempvar 
char *tempvar; 
{ 
char *tempvar2 
factor( tempvar ); 
while( match( TIMES ) ) 
{ 
advance(); 
factor( tempvar2 = newname() ); 
printf(" %s *= %s\n", tempvar, tempvar2 ); 
freename( tempvar2 ); 
void 
char 
{ factor( tempvar 
*tempvar; 
if( match(NUM_OR ID) 
{ 
printf(" %s = %0.*s\n", tempvar, yyleng, yytext ); 
advance(); 
else if( match(LP) 
{ 
else advance(); 
expression( tempvar ); 
if ( match (RP) ) 
advance(); 
else 
fprintf( stderr, "%d: Mismatched parenthesis\n", yylineno ) ; 
fprintf( stderr, "%d: Number or identifier expected\n", yylineno ) ; 
1.4 Exercises 
1.1. Write a grammar that recognizes a C variable declaration made up of the follow­
ing keywords: 
int char long float double signed unsigned short 
const volatile 
and a variable name. 
1.2. Write a grammar that recognizes a C variable declaration made up only of legal 
combinations of the following keywords: 
int char long float double signed unsigned short 
const volatile 
and a variable name. The grammar should be able to accept all such legal 
declarations. For example, all the following should be accepted: 
Section 1.4-Exercises 
volatile unsigned long int x; 
unsigned long volatile int x; 
long unsigned volatile int x; 
long volatile unsigned int x; 
but something like 
unsigned signed short long x; 
should not be accepted. Remember that the int keyword is optional in a 
declaration. 
1.3. Modify your solution to the previous exercise so that declarations for arrays, 
pointers, pointers to arrays, arrays of pointers, arrays of pointers to arrays, and so 
on, are also recognized. That is, all legal combination of stars, brackets, 
parentheses, and names should be recognized. 
1.4. Write a grammar (and a recursive-descent compiler for that grammar) that 
translates an English description of a C variable into a C-style variable declara­
tion. For example, the input: 31 
x is a pointer to an array of 10 pointers to functions that return int. 
y is an array of 10 floats. 
z is a pointer to a struct of type a struct. 
should be translated to: 
int 
float (* (*x) [10]) (); 
y [ 10 l; 
struct a_struct *z; 
1.5. Modify either of the expression compilers (in Figures 1.11 or 1.1 0) so that the C 
++and-- operators are supported. 
1.6. LISP uses a prefix notation for arithmetic expressions. For example, 1+2 is 
represented as (+ 1 2), and 1+2*3 is (+ 1 (* 2 3)). Modify the expres­
sion compiler so that it translates infix expressions to prefix. 
1.7. Write a LISP-to-infix translator. 
1.8. Modify the expression compiler so that it translates expressions into postfix nota­
tion, such as that used by a Hewlett-Packard calculator. For example, the expres­
sion ( 1+ 2) * ( 3 + 4 ) should be translated to: 
1 2 + 3 4 + * 
1.9. Modify the expression compiler so that it prints the parse tree created by its input. 
I suggest creating a physical parse tree (with structures and so forth) and then 
printing the tree by traversing the physical parse tree. 
1.10. (This is a very difficult problem.) 
a. Try to write a context-free grammar that correctly parses both "time flies like 
an arrow" and "fruit flies like a banana." 
b. One of the things that defines context-free grammars is that the left-hand side 
always consists of a single nonterminal symbol. How would the foregoing work 
if you were permitted to use more than one terminal or nonterminal symbol on a 
left-hand side? Try to write a parser for this sort of grammar. 
2 
Input and Lexical Analysis 
This chapter looks at input strategies and at lexical analysis. I'll discuss a set of 
buffered input routines and construct IJX, a program modeled after the UNIX lex utility, 
that translates regular expressions into a lexical analyzer. It's worth understanding how 
IJX works, even if you're not going to build a version of your own. Various theoretical 
concepts such as finite automata and E closure will crop up again when I discuss how 
programs like occs and yacc generate bottom-up parse tables, and you need to be able to 
understand how these tables are created in order to use these programs effuctively. The 
concepts are easier to understand in the context of IJX, however, so the theoretical 
material in this chapter is actually an introduction to the concepts that you'll need later. 
I'm using a bootstrap approach in that IJX itself uses a hard-coded lexical analyzer and a 
recursive-descent parser to do its work. As such, it's a good example of a compiler built 
by hand, without special tools. 
The techniques used for lexical analysis are useful in many programming applica­
tions other than compilers. Efficient 1/0 is a concern in virtually every computer pro­
gram. Similarly, lexical analyzers are pattern-recognition engines-the concepts dis­
cussed here can be applied to many programs that need to recognize patterns: editors, 
bibliographic data-base programs, and so forth. You can extend the techniques to do 
things like assembly-line quality control and network-protocol processing. 
If you intend to read the implementation parts of this chapter rather than just the 
theory, you should read Appendix D, which contains a user's manual for IJX, before 
proceeding. Also many of the support routines used by IJX are presented in Appendix A 
(the set routines are used heavily in the code that follows, and the hash functions are 
used as well). 
2.1 The Lexical Analyzer as Part of a Compiler* 
The main purpose of a lexical analyzer in a compiler application is to translate the 
* An asterisk appended to a section heading is used throughout this and subsequent chapters to indicate 
theoretical material. Implementation-oriented sections are not so marked. 
32 
Section 2.1 -The Lexical Analyzer as Part of a Compiler* 33 
input stream into a form that is more manageable by the parser. It translates input strings 
or lexemes, into tokens-arbitrary integer values that represent the lexemes. A token can Lexemes, tokens. 
have a one-to-one relationship with a lexeme. For example, the keyword while is asso-
ciated with a single token. More generic tokens such as identifiers or numbers have 
several lexemes associated with them. Lexical analyzers often have auxiliary functions 
as well. For example, a lexical analyzer can discard comments and skip over white 
space. Isolating this housekeeping from the parser can simplify the parser design (and 
the grammar of the language). The analyzer can keep track of the current line number so 
that intelligent error messages can be output by the parser. Program listings that show 
the source code intermixed with error messages are usually created by the lexical 
analyzer. 
The lexical analyzer is an independent compilation phase that communicates with Interface to parser. 
the parser over a well-defined and simple interface. The relationship is pictured in Fig-
ure 2.1. The parser calls a single lexical-analyzer subroutine every time it needs a new 
token, and that subroutine returns the token and associated lexeme. 
Figure 2.1. Interaction Between the Lexical Analyzer and Parser 
code ~ parser generation output code 
token and ';' request I 
lexeme next token I 
r-_y_-----
lexical I symbol I 
analyzer ~---~ table 
L--------
source text ---? input 
system 
This organization has several things going for it. Since it's an independent phase, the 
lexical analyzer is easy to maintain because changes to the analyzer do not affect the 
compiler as a whole, provided that the interface is not changed. Moreover, much of the 
code that comprises the lexical analyzer is the same for every compiler, regardless of the 
input language, so you can recycle much of the lexical analyzer's code. The only things 
that change from language to language in the table-driven lexical analyzers described 
later in this chapter are the tables themselves. Other advantages include speed-an 
independent lexical analyzer can optimize character-read times because it can read large 
amounts of data at once, and portability-the peculiarities of reading the source code 
under a particular operating system are all confined to the lexical analyzer itself. Notice 
that the actual input system in Figure 2.1 is isolated completely from the parser, even 
though it's closely linked to the lexical analyzer. 
Sometimes a more complex interaction between lexical analyzer and parser is 
required. For example, the typedef statement in C effectively creates new keywords in 
the language. After the parser has processed the statement: 
typedaf int alphonso; 
the lexical analyzer must treat the input string alphonso as if it were a type token rather 
than as an identifier token. This sort of high-level communication is usually done 
through a shared data structure such as the symbol table. In this case, the parser can enter Advantages of indepen­
dent lexical analyzers. 
Shared symbol table. 
34 
Attributes. 
Discarding characters. Input and Lexical Analysis -Chapter 2 
alphonso into the symbol table, identifying it as a typedef name, and the lexical 
analyzer can check the symbol table to determine if a string is a type or identifier token. 
A lexical analyzer can also do work other than simple pattern recognition. For 
example, when it reads a numeric constant, it can translate that constant into the associ­
ated number [in a manner similar to atoi ()] and return that number along with the 
token and lexeme. When an identifier is read, the analyzer can look up the identifier in 
the symbol table and return a pointer to a symbol-table entry along with the token. 
These additional values associated with individual tokens are called attributes. (Note 
that the lexeme is also an attribute of the token, because it's a quantum of information 
that is associated with the token.) In general, it's best to restrict the lexical analyzer to 
simple pattern-recognition tasks in order to make it easier to maintain. If the analyzer is 
an independent module that performs only one task (pattern recognition), it's a simple 
matter to replace it if necessary. 
There's one final point to make. Lexical analysis is often complicated if a language is 
not designed with ease-of-compilation in mind. For example, 1 PL/1 keywords are not 
reserved-you can use them as identifiers-and the lexical analyzer has to determine 
what it's looking at based on surrounding context. You can say something like this in 
PL/1: 
if then then then = else; else else = then; 
Separating the keyword then from the identifier then can be quite difficult. 
2.2 Error Recovery in Lexical Analysis* 
It's possible, of course, for errors to occur in the lexical-analysis as well as the pars­
ing phase. For example, the at sign (@) and backquote ( ') are both illegal outside of a 
string in a C program. The lexical analyzer can recover from these errors in several 
ways, the simplest of which just discards the offending character and prints an appropri­
ate error message. Even here, there are some choices that are driven by the application, 
however. If the last character of a multiple-character lexeme is incorrect, the analyzer 
can discard the entire malformed lexeme or it can discard only the first character of the 
lexeme and then try to rescan. Similarly, the lexical analyzer could try to correct the 
error. Some operating systems have a "do what I mean" feature that works along these 
lines. When faced with an error, the operating system's command-line interpreter (which 
is a compiler) tries to determine what the user meant to type and proceeds accordingly. 
If a word has only one misspelled letter, it's not too difficult to correct the problem by 
simple inspection. 2 
I. This example (and the other PL/1 example, below) is borrowed from [Aho], p. 87 and p. 90. 
2. There are other, more sophisticated techniques that can be used to determine the similarity of two words. 
The most common technique is the "soundex" algorithm developed by Margaret Odell and Robert Russel, 
and described in [Knuth], vol. 3, pp. 391-392. Also of interest is the Ratcliff/Obershelp algorithm, 
described in [Ratclift], and Allen Bickel's algorithm, described in [Bickel] and implemented in C' in 
[Howell]. 
Section 2.3-Input Systems* 
2.3 Input Systems* 
Since the input system is usually an independent module, and since the concerns here 
are divorced from the mechanics of recognizing tokens, I'll look at input systems in 
depth before moving on to the issues of lexical analysis per se. 
The lowest-level layer of the lexical analyzer is the input system-the group of func-
tions that actually read data from the operating system. For the same reason that the The input system is an 
analyzer should be a distinct module, it's useful for the input system itself to be an independentmodule. 
independent module that communicates with the analyzer via well-defined function 
calls. Since the analyzer itself can be isolated from the input mechanics, the resulting 
code is more portable. Most of the system-dependent operations of the analyzer are con-
centrated into the input layer. 
Issues of optimization aside, most compilers spend a good portion of their time in the 
lexical analysis phase. Consequently, it's worthwhile to optimize lexical analysis for 
speed. The standard C buffered input system is actually a poor choice for several rea-Optimizing for speed. 
sons. First, most buffered systems copy the input characters at least three times before 
your program can use them: from the disk to a buffer maintained by the operating sys-
tem, from that buffer to a second buffer that's part of the FILE structure, and finally from 
the FILE buffer to the string that holds the lexeme. All this copying takes both time and 
buffer space. Moreover, the buffer size is not optimal. The more you can read from the 
disk at one time, the faster your input routines tend to be (though this is operating-system 
dependent-there's not much advantage under UNIX in reading more than one block at a 
time; MS-DOS, however, performs much better with very large reads). 
The other issue is Iookahead and pushback. The lexical analyzer may have to look Lookahead, pushback. 
ahead several characters in the input to distinguish one token from another, and then it 
must push the extra characters back into the input. Consider the earlier PL/1 expression: 
if then then then = else; else else = then; 
The lexical analyzer can distinguish the else keyword from the else identifier by look­
ing at the characters that follow the lexeme. The else must be an identifier if it is fol­
lowed by an equal sign, for example. Another example is a PL/1 declare statement 
like this: 
declare ( argl, arg2, ... , argN) 
The lexical analyzer can't distinguish the declare keyword from an identifier (a sub­
routine name in this case) until it has read past the rightmost parenthesis. It must read 
several characters past the end of the lexeme, and then push the extra characters back 
into the input stream once a decision has been made, and this lookahead and pushback 
must be done as efficiently as possible. 
A final, admittedly contrived, example demonstrates that pushback is necessary even 
in recognizing individual tokens. If a language has the three tokens xxyy, xx, and y, and 
the lexical analyzer is given the input xxy it should return an xx token followed by a y 
token. In order to distinguish, however, it must read at least four characters (to see if 
xxyy is present) and then push the two y's back into the input stream. 
Most programming languages are designed so that problems such as the foregoing 
are not issues. If the tokens don't overlap, you can get by with only one character of 
pushback. IJX however, can't make assumptions about the structure of the lexemes, so 
must assume the worst. 
The push back problem means that you can't use the normal buffered input functions 35 
because ungetc () gives you only one character of pushback. You can add a layer ungetc () inappropriate. 
around getc () that gives you more pushback by using a stack, as is demonstrated in Stack-based pushback. 
Listing 2.1. Push back a character by pushing it onto the stack, and get the next input 
36 Input and Lexical Analysis -Chapter 2 
character either from the stack (if it's not empty) or from the real input stream (if it is). 
UNIX lex uses this method. A better method is described in the remainder of this section. 
Listing 2.1. Using a Stack for Multiple-Character Pushback 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 #include <stdio.h> 
#define SIZE 128 /* Maximum number of pushed-back characters 
/* Pbackbuf is the push-back stack. 
* Pbackp is the stack pointer. The stack grows down, so a push is: 
* *--Pbackp=c and a pop is: c=*Pbackp++ 
*get() evaluates to the next input character, either popping it off the 
* stack (if it's not empty) or by calling getc(). 
* unget(c) pushes c back. It evaluates to c if successful, or to -1 if the 
* pushback stack was full. 
*/ 
int Pbackbuf[SIZE); 
int *Pbackp = &Pbackbuf[SIZE); 
#define get(stream) 
#define unget(c) (Pbackp < &Pbackbuf[SIZE) ? *Pbackp++ 
? -1 
void 
char 
int (Pbackp <= Pbackbuf 
ungets( start, n ) 
*start; 
n; getc(stream) 
(*--Pbackp= (c)) 
/* Push back the last n characters of the string by working backwards 
* through the string. 
*I 
char *p =start+ str1en(start); 
while( --p >= start && --n >= 0 ) 
if( unget(*p) == -1 ) /* Find the end of the string. */ 
fprintf( stderr, "Pushback-stack overflow\n" ); 
2.3.1 An Example Input System* *I 
Input-system design cri­
teria. This section describes the input system used by a IJX-generated lexical analyzer 
(though not by LEX itself). This input system has many of the qualities that are desirable 
in a compiler's input system, and as such can be taken as characteristic. There are, of 
course, other solutions to the input problem,3 but the current one has proven quite work­
able and provides a good example of the sorts of problems that come up. Several design 
criteria must be met: 
• The routines should be as fast as possible, with little or no copying of the input 
strings. 
• Several characters of push back and lookahead must be available. 
• Lexemes of a reasonable length must be supported. 
• Both the current and previous lexeme must be available. 
3. A system that's more appropriate in a Pascal environment is described in [Aho] pp. 88-92. 
Section 2.3.1-An Example Input System* 
• Disk access should be efficient. 
To meet the last criterion, consider how a disk is accessed by most operating systems. 
All disks are organized into sectors which must be read as a unit. Disk reads must be 
performed in sector-sized chunks. If your disk has 512-byte sectors, then you must read 
512 bytes at a time. This limitation is imposed by the hardware. If you request one byte 
from the disk, the operating system will read an entire sector into a buffer, and then 
return a single byte from the buffer. Subsequent reads get characters from the buffer 
until it is exhausted, and only then is a new sector read. Some operating systems (MS­
DOS is a case in point) impose further constraints in that a group of several sectors 
(called a cluster or block) is the smallest possible unit that can be accessed directly, so 
you have to read an entire cluster at once. The minimum number of bytes that can be 
read is called an allocation unit, and, for the sake of efficiency, all reads must be done in 
terms of allocation units. That is, the number of bytes read from the disk at any one time 
should be a multiple of the allocation unit. Typically, the larger the buffer, the shorter 
the read time. Many operating systems reward you for doing block-sized transfers by 
not buffering the input themselves, as would be the case when an odd-sized block was 
requested from a low-level read call. The operating system transfers the data directly 
from the disk into your own buffer, thereby eliminating one level of copying and 
decreasing the read time. For example, MS-DOS read and write times improve dramati­
cally when you read 32K bytes at a time. 
The other design criteria are met by using a single input buffer and several pointers. 
My system is pictured in Figure 2.2. The drawing on the top shows the condition of the 
buffer just after it is loaded the first time. BUFSIZE is the actual buffer size. MAXLEX is 
the maximum lexeme length, and the disk reads are always in multiples of this number. 
Start_ buf marks the physical start of the buffer, and END marks the physical end of the 
buffer. End_buf points at the logical end of buffer. (Since reads are in multiples of 
MAXLEX, and since the buffer itself isn't an even multiple of MAXLEX in length, there is 
usually a scrap of wasted space at the end of the buffer. End_buf points just past the 
last valid character in the buffer.) Finally, Next points at the next input character. (I'll 
discuss DANGER and MAX LOOK momentarily.) 
The middle picture in Figure 2.2 shows the buffer in its normal state, after the lexical 
analyzer has processed several tokens. Various pointers have been set to mark the boun­
daries of various lexemes: pMark points at the beginning of the previous lexeme, 
sMark points at the beginning of the current lexeme, and eMark points at the end of the 
current lexeme. The lexical analyzer has scanned several characters past the end of the 
current lexeme (Next is to the right of eMark). If the lexical analyzer finds a longer lex­
erne than the current one, all it need do is move the eMark to the current input position. 
If, on the other hand, it finds that it has read too far in the input, it can push back all the 
extra characters by setting Next back to the eMark. 
Returning to MAXLOOK , this constant is the number of lookahead characters that are 
supported. The DANGER marker tells the input routines when the Next pointer is getting 
too close to the end of the buffer (there must be at least MAXLOOK characters to the right 
of Next). When Next crosses the DANGER point, a buffer flush is triggered, giving us the 
situation shown in the bottom picture in Figure 2.2. All characters between the pMark 
and the last valid character (pointed to by End_ buf) have been shifted to the far left of 
the buffer. The input routines fill the remainder of the buffer from the disk, reading in as 
many MAX LEX-sized chunks as will fit. The End_ buf pointer is adjusted to mark the 
new end of the buffer, and DANGER scales automatically: it's positioned relative to the 
new end of buffer. This may seem like a lot of copying, but in practice the lexemes are 
not that large, especially in comparison to the buffer size. Consequently, flushes don't 
happen very often, and only a few characters are copied when they do happen. 37 
Disk access, sectors. 
Clusters, blocks. 
Allocation units. 
Input system organiza­
tion: buffers and pointers. 
Buffer pointers, BUF­
SIZE, MAXLEX, END, 
Start_buf, End buf. 
Lexeme markers, 
pMark, sMark, eMark. 
MAXLOOK, DANGER. 
Buffer flush. 
38 Input and Lexical Analysis -Chapter 2 
Figure 2.2. The Input Buffer 
End buf -
Sta rt_buf DANGER E ND 
1 Next 
/ 
1:::::: ~ After initial read 
MAXLOOK-1 <E-
3xMAXLEX 
BUFSIZE 
Start_buf DANGER 
Next 
pMark sMark eM ark 
I 
previous lexeme current lexeme 1 
I 
BUFSIZE End_buf 
Normally 
Start_buf DANGER END 
M k Next 1 ,P ~ar sMark eMark End_buf 
1p;re~v~io~us~l~ex~em~eJv~cu~rr~en~t~le~xe~m~•li:====J·W··li··li·========:~===~~§§~~ After flush 
-1 n x MAXLEX r-
BUFSIZE 
This approach has many advantages, the main one being a lack of copying. The lexi­
cal analyzer can just return the sMark as the pointer to the next lexeme, without having 
to copy it anywhere. Similarly a pushback is a single assignment (Next=eMark) rather 
than a series of pushes and pops. Finally, the disk reads themselves are reasonably 
efficient because they're done in block-sized chunks. 
Section 2.3.2-An Example Input System-Implementation 
2.3.2 An Example Input System-Implementation 
The foregoing is all implemented by the variables and macros declared at the top of 
input.c, in Listing 2.2. At this point we've looked at most of them, the others are dis­
cussed as they're used in the code. The macro definitions on lines 15 to 19 take care of a 
few system dependencies-COPY () is mapped to merrunove ( ) for the Microsoft C com­
piler [because Microsoft'smemcpy ( ) doesn't support overlapping strings]. Portability problems: 
COPY(). 
Listing 2.2. input.c- Macros and Data Structures 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 #include <stdio.h> 
#include <stdlib.h> 
#include <fcntl.h> 
#include <tools/debug.h> 
#include <tools/l.h> 
#include <string.h> /* Needed only tor prototypes */ 
/* " *I 
/*------------------------------------------------------------------------
* INPUT.C: The input system used by LeX-generated lex~cal analyzers. 
*------------------------------------------------------------------------
* System-dependent defines. 
*I 
#ifdef MSDOS 
# define COPY(d,s,a) memmove(d,s,a) 
#else 
# 
#endif define COPY(d,s,a) memcpy(d,s,a) 
#define STDIN 0 /* standard input */ 
/*----------------------------------------------------------------------*/ 
#define MAXLOOK 
#define MAXLEX 16 
1024 /* Maximum amount of lookahead */ 
/* Maximum lexeme sizes. */ 
#define BUFSIZE (MAXLEX * 3) + (2 * MAXLOOK) ) /* Change the 3 only */ 
#define DANGER End buf -MAXLOOK /* Flush buffer when Next */ 
/* passes this address */ 
#define END (&Start_buf[BUFSIZE]) /* Just past last char in but */ 
#define NO MORE_CHARS() ( Eof_read && Next >=End buf 
typedef unsigned char uchar; 
PRIVATE 
PRIVATE PRIVATE 
PRIVATE 
PRIVATE 
PRIVATE PRIVATE 
PRIVATE uchar 
uchar 
uchar 
uchar 
uchar 
uchar 
int 
int Start_buf[BUFSIZE]; /* Input buffer 
PRIVATE int 
PRIVA'l'E int 
PRIVATE int 
PRIVATE int *End buf 
*Next 
*sMark 
*eMark 
*pMark 
pLineno 
pLength 
Inp_file 
Lineno 
Mline END; 
END; 
END; 
END; 
NULL; 
0; 
0; 
STDIN; 
1 
1 
Termchar = 0; /* 
/* 
/* 
/* Just past last character 
Next input character 
Start of current lexeme 
End of current lexeme 
/* Start of previous lexeme 
/* Line # of previous lexeme 
/* Length of previous lexeme 
/* Input tile handle 
/* Current line number 
/* Line # when mark_end() called 
/* Holds the character that was *I 
*I *I 
*I 
*I *I 
*I 
*I 
*I 
*/ 
*I 
*I 39 
40 Input and Lexical Analysis -Chapter 2 
Listing 2.2. continued ... 
52 I* overwritten by a \0 when we *I 
53 I* null terminated the last *I 
54 I* lexeme. *I 
55 PRIVATE int Eof read 0; I* End of file has been read. *I 
56 I* It's possible for this to be *I 
57 I* true and for characters to *I 
58 I* still be in the input buffer. *I 
59 
60 extern int open(), close(), read() ; 
61 
62 PRIVATE int 
63 PRIVATE int 
64 PRIVATE int 
Change low-level input 
routines, ii _ io o . 
Open new input file, 
ii_newfile (). 
Reassigning standard in­
put. 
Binary (untranslated) in­
put. 
First read is delayed until 
first advance. (*Openp) () open I* Pointer to open function *I 
( *Closep) () close I* Pointer to close function *I 
(*Readp) () read I* Pointer to read function *I 
The actual code starts in Listing 2.3 with two initialization functions. The first, 
ii_io () on line 65 of Listing 2.3, is used to change the low-level input functions that 
are used to open files and fill the buffer. You may want to do this if you're getting input 
directly from the hardware, from a string, or doing something else that circumvents the 
normal input mechanism. This way you can use a LEX-generated lexical analyzer in an 
unusual situation without having to rewrite the input system. 
The ii_newfile () routine on line 81 of Listing 2.3 is the normal mechanism for 
opening a new input file. It is passed the file name and returns the file descriptor (not the 
FILE pointer) for the opened file, or -1 if the file couldn't be opened. The previous 
input file is closed unless it was standard input. i i _new f i 1 e ( ) does not actually read 
the first buffer; rather, it sets up the various pointers so that the buffer is loaded the first 
time a character is requested. This way, programs that never call ii_newfile () will 
work successfully, getting input from standard input. The problem with this approach is 
that you must read at least one character before you can look ahead in the input (other­
wise the buffer won't be initialized). If you need to look ahead before advancing, use: 
ii_advance(); I* Read first bufferfull of input *I 
ii_pushback(l); I* but put back the first character *I 
The default input stream [used if ii _ newfile ( ) is never called] is standard input. 
You can reassign the input to standard input (say, after you get input from a file) by cal­
ling: 
ii_newfile(NULL); 
It's also okay to do a ii_newfile("/dev/tty") (in both MS-DOS and UNIX), but 
input is actually taken from the physical console in this case. Redirection won't work. 
An i i _ newf i le (NULL) allows for redirected input, however. 
Note that the indirect open () call on line 103 of Listing 2.3 uses the 0 _BINARY 
input mode in MS-DOS systems (it's mapped to zero in UNIX systems). A CR-LF 
(carriage-return, linefeed) pair is not translated into a single '\n' when binary-mode 
input is active. This behavior is desirable in most LEX applications, which treat both CR 
and LF as white space. There's no point wasting time doing the translation. The lack of 
translation might cause problems if you're looking for an explicit '\n' in the input, 
though. 
Note that the input buffer is not read by ii _ newfile ( ) ; rather, the various pointers 
are initialized to point at the end of the buffer on lines Ill to 114 of Listing 2.3. The 
actual input routine (advance (), discussed below) treats this situation the same as it 
would the Next pointer crossing the DANGER point. It shifts the buffer's tail all the way 
to the left (in this case the tail is empty so no characters are shifted, but the pointers are 
Section 2.3.2-An Example Input System-Implementation 41 
Listing 2.3. input.c- Initialization Routines 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 void 
int 
int 
int ii io( open funct, close funct, read funct 
(*open_funct) (); 
(*close_funct) (); 
(*read_funct) (); 
/* This function lets you modify the open(), close(), and read() functions 
* used by the i/o system. Your own routines must work like the real open, 
* close, and read (at least in terms of the external interface. Open should 
*return a number that can't be confused with standard input (not 0). 
*I 
Openp 
Closep 
Readp open_funct; 
close funct; 
read_funct; 
/*-------------------------------------------------------------------*/ 
int ii newfile( name ) 
char *name; 
{ 
/* Prepare a new input file for reading. If newfile() isn't called before 
*input() or input_line() then stdin is used. The current input file is 
*closed after successfully opening the new one (but stdin isn't closed). 
* 
* Return -1 if the file can't be opened; otherwise, return the file 
*descriptor returned from open(). Note that the old input file won't be 
* closed unless the new file is opened successfully. The error code (errno) 
*generated by the bad open() will still be valid, so you can call perror() 
* to find out what went wrong if you like. At least one free file 
*descriptor must be available when newfile() is called. Note in the open 
* call that O_BINARY, which is needed in MS-DOS applications, is mapped 
* to 0 under UNIX (with a define in <tools/debug.h>). 
*I 
int fd; /* File descriptor */ 
MS( if( strcmp(name, "/dev/tty") == 0) 
MS ( name = "CON" ; 
if( (fd 
{ !name? STDIN: (*Openp) (name, 0 RDONLYIO_BINARY)) 
if( Inp_file != STDIN 
(*Closep) ( Inp_file ) ; 
Inp file fd; -Eof read 0; 
Next END; 
sMark END; 
eMark END; 
End buf END; 
Lineno l; 
Mline l; 
return fd; ! = -1 ) 
42 
Access functions. 
Limiting scope, 
PRIVATE. 
Functions to access lex­
emes: ii _text () , 
ii _length(), 
ii_lineno(), 
ii _ptext (), 
ii _plength () , 
ii _plineno () . 
Functions to mark lex­
erne boundaries, 
ii_mark_start (), 
ii_mark_end(). 
Move start marker, 
ii_move_start(). 
Restore pointer to previ­
ous mark, 
ii_to_mark (). 
Mark previous lexeme, 
ii _mark _prev (). 
Advance input pointer, 
ii_advance (). Input and Lexical Analysis -Chapter 2 
moved), and then loads the buffer from the disk. I've taken this approach because it's 
sometimes convenient to open a default input file at the top of a program, which is then 
overridden by a command-line switch or the equivalent later on in the same program. 
There's no point in reading from a file that's not going to be used, so the initial read is 
delayed until a character is requested. 
The input.c file continues in Listing 2.4 with several small access functions. For 
maintenance reasons, it is desirable to limit external access of global variables, because 
the linker assumes that two global variables with the same name are the same variable. 
If you inadvertently declare two variables with the same name, one of them will seem to 
magically change its value when a subroutine that accesses the other is called. You can 
avoid this problem by declaring the variables static, thereby limiting their scope to 
the current file. PRIVATE is mapped to static in debug.h, discussed in Appendix A. 
It's still necessary for external subroutines to access these variables however, and the 
safest way to do so is through the small routines in Listing 2.4. These subroutines are 
used for maintenance reasons only-two subroutines with the same name will result in 
an error message from the linker, unlike two variables with the same name, which are 
silently merged. 
The ii _text ( ) , ii _length ( ) , and ii _lineno ( ) routines (lines 120 to 122 of 
Listing 2.4) return a pointer to the current lexeme, the lexeme's length, and the line 
number for the last character in the lexeme. The ii _ptext (), ii _plength (),and 
ii _plineno ( ) routines (lines 123 to 125) do the same thing, but for the previous lex­
erne. The ii_mark_start () routine (line 127) moves the sMark to the current input 
position (pointed to by Next). It also makes sure that the end-of-lexeme marker 
(eMark) is not to the left of the start marker. ii _mark_ end ( ) (line 134) does the 
same for the end marker (eMark). It also saves the current line number in Mline, 
because the lexical analyzer might sweep past a newline when it scans forward looking 
for a new lexeme. The input line number must be restored to the condition it was in 
before the extra newline was scanned when the analyzer returns to the previous end 
marker. 
The i i _move_ start ( ) routine on line 140 of Listing 2.4 lets you move the start 
marker one space to the right. It returns the new start marker on success, NULL if you 
tried to move past the end marker (sMark is not modified in this last case). 
ii _to_ mark ( ) (line 148) restores the input pointer to the last end mark. Finally, 
ii_mark_prev () modifies the previous-lexeme marker to reference the same lexeme 
as the current-lexeme marker. Typically, ii _mark _prev ( ) is called by the lexical 
analyzer just before calling ii _mark_ start ( ) (that is, just before it begins to search 
for the next lexeme ). 
The next group of subroutines, in Listings 2.5 and 2.6, comprise the advance and 
buffer-flush functions. ii_advance (),on line 168 of Listing 2.5, returns the next 
input character and advances past it. The code on lines 180 to 191 is provided for those 
situations where you want an extra newline appended to the beginning of a file. LEX 
needs this capability for processing the start-of-line anchor-a mechanism for recogniz­
ing strings only if they appear at the far left of a line. Such strings must be preceded by a 
newline, so an extra newline has to be appended in front of the first line of the file; other­
wise, the anchored expression wouldn't be recognized on the first line.4 
4. ~X Usage Note: This pushback could conceivably cause problems if there is no regular expression in the 
~X input file to absorb the newline, and YYBADINP is also #defined (You'll get an error message in this 
case). A regular expression that absorbs white space is usually present, however. 
Section 2.3.2-An Example Input System-Implementation 
Listing 2.4. input.c- Small Access Routines and Marker Movement 
PUBLIC char *ii text -PUBLIC int ii length -
PUBLIC int ii lineno -PUBLIC char *ii _ptext 
PUBLIC int ii_plength 
PUBLIC int ii_plineno 
char *ii mark start() 
{ 
Mline = Lineno; 
eMark = sMark Next; 
return( sMark ) ; 
PUBLIC char *ii_mark_end() 
{ 
Mline = Lineno ; 
return( eMark =Next); 
PUBLIC char *ii_move_start() 
{ 
if ( sMark >= eMark 
return NULL; 
else 
return ++sMark 
PUBLIC char *ii_to_mark() 
{ 
Lineno = Mline 
return( Next eMark ); 
char *ii_mark_prev() 
{ () return( sMark 
() return( eMark -
() return( Line no 
() return( pMark 
() return( pLength 
() return( pLineno 43 
) ; 
sMark ) ; 
) ; 
) ; 
) ; 
) ; 120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 /* Set the pMark. Be careful with this routine. A buffer flush won't go past 
* pMark so, once you've set it, you must move it every time you move sMark. 
* I'm not doing this automatically because I might want to remember the 
* token before last rather than the last one. If ii_mark_prev() is never 
* called, pMark is just ignored and you don't have to worry about it. 
*I 
pMark 
pLineno 
pLength 
return( sMark; 
Lineno; 
eMark -sMark; 
pMark ) ; 
The NO_ MORE_ CHARS ( ) macro is used on line 193 to detect end of file. It was Detect end of file, 
defined in the header as follows NO_ MORE_ CHARS 0 · 
#define NO_MORE_CHARS() ( Eof_read && Next >= End_buf ) 
Eof read is set to true when end of file is encountered. You must use both Eof read Eof react. 
and Next to detect end of input because EOF might have been read while the lexical 
analyzer was looking ahead. In this case, characters may have been pushed back after 
44 
End of input. Input and Lexical Analysis -Chapter 2 
reading the EOF. You have to see both if end of file has been encountered and if the 
buffer is empty. This is a case where end of input and end of file are different things, 
because there still may be characters in the input buffer long after end of file has been 
read. The ii_flush () call on line 196 flushes the buffer if necessary, and the line 
number is advanced on line 199. The next input character is returned normally, 0 is 
returned on end of file, and -I is returned if the buffer couldn't be flushed for some rea­
son. 
Listing 2.5. input.c- The Advance Function 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 int ii_advance () 
/* ii_advance() is the real input function. It returns the next character 
* from input and advances past it. The buffer is flushed if the current 
* character is within MAXLOOK characters of the end of the buffer. 0 is 
* returned at end of file. -1 is returned if the buffer can't be flushed 
*because it's too full. In this case you can call ii_flush(l) to do a 
*buffer flush but you'll loose the current lexeme as a consequence. 
*I 
static int been called 0; 
if( !been_called ) 
{ 
I* 
* Push a newline into the empty buffer so that the LeX start-of-line 
anchor will work on the first input line. 
*I 
Next = sMark = eMark 
*Next= '\n'; 
--Lineno ; 
--Mline 
been called 1; 
if( NO_MORE_CHARS() 
return 0; END -1; 
if( !Eof read && ii_flush(O) < 0 ) 
return -1; 
if( *Next== '\n' 
Lineno++; 
return( *Next++); 
Flush input buffer, 
ii_flush (). The actual buffer flush is done by ii _flush ( ) , which starts at the top of Listing 
2.6. The test on line 248 checks to see that there will be enough room after the move to 
load a new MAXLEX-sized bufferfull of characters-there might not be if the buffer con­
tains two abnormally long lexemes. The test evaluates true if there isn't enough room. 
Normally, the routine returns -1 if there's no room, and I is returned if everything is 
okay. If the force argument is true, however, the buffer is flushed even if there's no 
room, and 1 is returned. The flush is forced by setting the start marker to the current 
input position and the left_edge of the character to be shifted to the Next pointer, 
effectively destroying the current lexeme. The code on lines 259 and 246 figures out force. 
Section 2.3.2-An Example Input System-Implementation 45 
how many characters have to be copied (copy_ amt) and the distance that they have to 
be moved (shift_amt). The shift is done on line 260, and a new buffer is loaded by the copy_amt, shift amt. 
ii fillbuf () call on line 262. COPY was defined earlier (on line 16 of Listing 2.2) to 
map to either memmove ( ) or memcpy ( ) , depending on the compilation environment. 
The rest of the routine adjusts the various markers to compensate for the move. 
Listing 2.6. input.c- Buffer Flushing 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 240 
241 
242 
243 
244 
245 
246 
247 248 
249 
250 
251 
252 
253 
254 
255 int 
int 
{ ii flush ( force 
force; 
/* Flush the input buffer. Do nothing if the current input character isn't 
* in the danger zone, otherwise move all unread characters to the left end 
*of the buffer and fill the remainder of the buffer. Note that input() 
* flushes the buffer willy-nilly if you read past the end of buffer. 
*Similarly, input_line() flushes the buffer at the beginning of each line. 
* 
* 
* 
* 
* 
* Start but 
I 
v pMark 
I DANGER 
I 
sMark eMark INext 
II I II 
w v w End but 
I 
v 
* +-----------------------+----------------+-------+ 
* I this is already read 1 to be done yet I waste I 
* +-----------------------+----------------+-------+ 
* 
* 
* 1<----- shift_amt ----->1<-- copy_amt -->1 
I 
* 1<------------------ BUFSIZE ------------------->1 
* * Either the pMark or sMark (whichever is smaller) is used as the leftmost 
* edge of the buffer. None of the text to the right of the mark will be 
* lost. Return 1 if everything's ok, -1 if the buffer is so full that it 
* can't be flushed. 0 if we're at end of file. If "force" is true, a buffer 
* flush is forced and the characters already in it are discarded. Don't 
* call this function on a buffer that's been terminated by ii_term(). 
*I 
int copy_amt, shift_amt 
uchar *left_edge; 
if( NO_MORE_CHARS() 
return 0; 
if( Eof read ) 
return l; /* nothing more to read */ 
if( Next >= DANGER I I force ) 
{ 
left edge 
shift amt pMark? min(sMark, pMark) 
left_edge -Start_buf 
if( shift amt < MAXLEX 
{ 
if ( ! force 
return -1; sMark; 
/* if(not enough room) */ 
left_edge = ii mark start(); /*Reset start to current character*/ 
ii_mark_prev(); 
46 Input and Lexical Analysis -Chapter 2 
Listing 2.6. continued ... 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 shift amt left_edge -Start buf 
copy_amt = End_buf -left_edge; 
COPY( Start_buf, left_edge, copy_amt ); 
if( !ii_fillbuf( Start_buf + copy_amt) ) 
ferr("INTERNAL ERROR, ii flush: Buffer full, can't read.\n"); 
if( pMark 
pMark shift_amt; 
sMark shift_amt; 
eMark shift_amt; 
Next shift_amt; 
return 1; 
/*----------------------------------------------------------------------*/ 
PRIVATE int 
unsigned char 
{ ii_fillbuf( starting_at 
*starting_ at; 
/* Fill the input buffer from starting_at to the end of the buffer. 
* The input file is not closed when EOF is reached. Buffers are read 
* in units of MAXLEX characters; it's an error if that many characters 
*cannot be read (0 is returned in this case). For example, if MAXLEX 
* is 1024, then 1024 characters will be read at a time. The number of 
* characters read is returned. Eof read is true as soon as the last 
* buffer is read. 
* * PORTABILITY NOTE: I'm assuming that the read function actually returns 
* the number of characters loaded into the buffer, and 
* that that number will be < need only when the last chunk of the file is 
* read. It's possible for read() to always return fewer than the number of 
* requested characters in MS-DOS untranslated-input mode, however (if the 
*file is opened without the O_BINARY flag). That's not a problem here 
* because the file is opened in binary mode, but it could cause problems 
* if you change from binary to text mode at some point. 
*I 
register unsigned need, 
got; /* Number of bytes required from input. */ 
/* Number of bytes actually read. */ 
need= ((END- starting_at) / MAXLEX) * MAXLEX 
D( printf( "Reading %d bytes\n", need); 
if ( need < 0 ) 
ferr("INTERNAL ERROR (ii_fillbuf): Bad read-request starting addr.\n"); 
if( need == 0 
return 0; 
if ( (got = (*Readp) (Inp_file, starting_ at, need)) -1 ) 
ferr("Can't read input file\n"); 
Section 2.3.2-An Example Input System-Implementation 
Listing 2.6. continued ... 
315 
316 
317 
318 
319 
320 
321 End buf starting_at + got 
if( got < need 
Eof read 1; 
return got; /* At end of file */ 
The final routine in Listing 2.6 is ii _ fillbuf ( ) , starting on line 278 . It is passed Load input buffer, 
a base address, and loads as many MAXLEX-sized chunks into the buffur as will fit. The ii_fillbuf 0 · 
need variable, initialized on line 302, is the amount needed. The logical-end-of-buffer need. 
marker is adjusted on line 315. Note that a single read ( ) call does the actual read on 
line 312. (Readp is initialized to point at read () when it is declared up at the top of 
the file.) This can cause problems when a lexeme can span a line, and input is fetched 
from a line-buffered input device (such as the console). You'll have to use ii io ( ) to 
supply an alternate read function, in this case. 47 
Listing 2.7 shows the lookahead function, ii _look ( ) . It returns the character at Lookahead, ii_look 0. 
the offset from the current character that's specified in its argument. An ii _look ( 0) 
returns the character that was returned by the most recent ii _advance () call, 
ii_look(l) is the following character, ii_look(-1) is the character that precedes 
the current one. MAXLOOK characters of lookahead are guaranteed, though fewer might 
be available if you're close to end of file. Similarly, lookback (with a negative offset) is 
only guaranteed as far as the start of the buffer (the pMark or sMark, whichever is 
smaller). Zero is returned if you try to look past end or start of the buffer, EOF if you try 
to look past end of file. 
Listing 2.7. input.c- Lookahead 
int ii look( n ) 322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 /* Return the nth character of lookahead, EOF if you try to look past 
* end of file, or 0 if you try to look past either end of the buffer. 
*I 
uchar *p; 
p = Next + (n-1) 
if( Eof read && p >= End buf 
return EOF; 
return( p < Start buf I I p >= End buf ? 0 *p 
Listing 2.8 contains the pushback function, ii _pushback (n). It is passed the 
number of characters to push back. For example, i i _pushback ( 5) pushes back the 
five most recently read characters. If you try to push past the sMark, only the characters 
as far as the sMark are pushed and 0 is returned (1 is returned on a successful push). If 
you push past the eMark, the eMark is moved back to match the current character. 
Unlike ungetc ( ) , you can indeed push back characters after EOF has been reached. 
The remainder of input. c, in Listing 2.9, provides support for '\0' -terminated 
strings. These routines are not-strictly speaking-necessary, because the lexeme ii __pushback (n). 
\a-terminated-string sup­
port. 
48 Input and Lexical Analysis -Chapter 2 
Listing 2.8. input.c- Push back 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 int ii_pushback( n ) 
/* Push n characters back into the input. You can't push past the current 
* sMark. You can, however, push back characters after end of file has 
* been encountered. 
*I 
while ( --n >= 0 && 
{ 
if( *--Next 
--Lineno; 
if( Next < eMark ) 
{ 
eMark 
Mline Next; 
Lineno; Next 
I \nl 
return( Next> sMark ); > sMark ) 
II ! *Next 
length is always available. It's occasionally useful to have a terminator on the string, 
however. Note that these functions should be used exclusively after the string has been 
terminated-the other input functions will not work properly in this case. 
Terminate/unterminate 
current lexeme, 
ii_term(), 
ii_unterm(). The termination is done with a call to ii _term ( ) (on line 358). It saves the char­
acter pointed to by Next in a variable called Termchar, and then overwrites the charac­
ter with a' \0'. The ii _ unterm ( ) function (on line 366) puts everything back. 
Listing 2.9. input.c- Support for ' \0' -terminated Strings 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 void 
/* 
void ii_term() 
Termchar = *Next 
*Next = 1\01 
- - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
ii_unterm() 
if( Termchar ) 
{ 
*Next = Termchar; 
Termchar = 0; 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
int ii input() 
int rval; 
Section 2.3.2-An Example Input System-Implementation 
Listing 2.9. continued .•. 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 if( Termchar 
{ 
else 
{ ii_unterm(); 
rval = ii_advance(); 
ii_mark_end (); 
ii_term (); 
rval = ii_advance(); 
ii_mark_end (); 
return rval; 
I* - - - - - - - - - - - - - - - - - - - - - - - - - -*1 
void ii_unput( c 
if( Termchar ) 
{ 
else ii_unterm(); 
if( ii_pushback(l) 
*Next = c; 
ii_term(); 
if( ii_pushback(l) 
*Next = c; 
I* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*1 
int ii_lookahead( n ) 
return (n == 1 && Termchar) ? Termchar ii_look(n) 
I* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*1 
int ii flushbuf() 
if( Termchar ) 
ii_unterm(); 
return ii_flush(l); 
This approach is better than putting the ii_unterm() code into ii_advance (), 
because the latter approach slows down all i i _advance ( ) calls. On the other hand, 
you have to remember to call ii_unterm () before calling ii_advance (). For this 
reason, an ii_input () function has been provided (on line 377) to make sure that the 
lexeme is unterminated and then reterminated correctly. That is, ii_input () is a 
well-behaved input function meant to be used directly by the user. The function also 49 
50 
ii_unput (). 
ii _lookahead (). 
Ring buffers. 
Why ring buffers are inap­
propriate here. 
Lookup tables in hard­
coded scanners. 
Hard-coded scanners: 
advantages and disad­
vantages. Input and Lexical Analysis -Chapter 2 
moves the end marker, making the lexeme one character longer (moving the null termi­
nator if necessary), and it returns the new input character, or 0 at end of file. -1 is 
returned if another character couldn't be read because the buffer was full. 
ii_unput () (on line 400) is a reverse-input function. It backs up the input one 
notch and then overwrites the character at that position with its argument. 
i i _ unput ( ) works correctly on both terminated and unterminated buffers, unlike 
ii _pushback ( ) , which can't handle the terminator. 
The ii _lookahead ( ) function bears the same relation to ii _look () that 
ii input() bears to ii _advance ( ) . That is, ii _lookahead ( 1) functions 
correctly for strings that have been terminated with ii _term () calls, ii _look () does 
not. Similarly, ii flushbuf ( ) flushes a terminated buffer by unterminating it before 
calling ii_flush (). 
One final note on strategy. The buffer-flush approach that I've used here allows me to 
take advantage of C's pointer mechanism when scanning the input. This approach isn't 
appropriate in a language like FORTRAN, where arrays must be referenced using an 
index. Here, you're better off using a circular array or ring buffer. For example, the 
input buffer would be declared with 
char input_buf[ SIZE]; 
and the next character would be accessed with 
x = input_buf[ current character% SIZE]; 
You would load a new chunk from the disk into the far left of the array when 
current_ character was greater than or equal to SIZE, being careful not to overwrite 
the current lexeme in the process. 
The problem here is that a lexeme can span the buffer. That is, a situation may arise 
where the first half of a lexeme is far right of input_ buf and the other half is at the far 
left. As long as you're accessing all the characters with an array index modulus the array 
size, this is not a problem. C, however, wants its strings in contiguous memory so that it 
can scan through them using a pointer. Moreover, the array index and modulus operation 
needed to access every character is inherently less efficient than a simple pointer access; 
more inefficient, even, than the moves that are part of a buffer flush. Consequently, a 
ring buffer isn't particularly appropriate in a C implementation. 
2.4 Lexical Analysis* 
Now that we've developed a set of input routines, we need to apply them in a 
lexical-analysis application. There are two approaches to lexical analysis, both useful. 
First, you can hard code the analyzer, recognizing lexemes with nested if/else state­
ments, switches, and so forth. If the lexemes aren't too long one effective approach uses 
a series of lookup tables to recognize tokens. (Lookup tables tend to be faster than 
switchs or if/else statements.) Listing 2.10 shows such a system for recognizing the 
following tokens: 
> >= < <= != 
The basic strategy is to vector from one table to another until a complete lexeme is 
identified. 
The hard-coded approach has its advantages-hard-coded lexical analyzers tend to 
be very efficient, but hard-coded analyzers are difficult to maintain. When you're 
developing a new language, it's handy to be able to add new tokens to the language or 
take some away without too much work. This problem is solved by programs like lex 
Section 2.4-Lexical Analysis* 
Listing 2.10. Using Lookup Tables for Character Recognition 
I 
2 
3 
4 
5 
6 
7 
8 
9 #define LESS THAN 1 
#define GREATER THAN 2 
#define EQUAL 3 
#define NOT 4 
#define LESS THAN OR_EQUAL 5 -#define GREATER_THAN_OR_EQUAL 6 
#define NOT_OR_EQUAL 7 
#define ASSIGN 8 
#define ERROR -1 
#define CONTINUE 0 
#define SIZE OF CHARACTER SET 128 
char first [SIZE OF CHARACTER SET]; 
char second[ SIZE OF CHARACTER SET]; 
int s, f; 51 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 memset( first, -1, SIZE OF CHARACTER SET); /*Initialize to error token. *I 
memset( second, -1, SIZE OF CHARACTER SET ) ; /* Note that there's an implicit */ 
/* conversion of -1 to 255 here */ 
/* (signed int to unsigend char).*/ 
first '>' GREATER THAN; 
first '<' LESS THAN; -first I! I NOT; 
first '=' ASSIGN; 
second[ '=' EQUAL; 
c = 
if( 
if( 
{ 
else getchar(); 
(f = first [c]) 
return ERROR; 
(s = second[c]) 
ungetchar(); 
return( f ) ; 
if( s == EQUAL ) 
switch( f ) 
{ 
case ASSIGN: ERROR 
ERROR 
case LESS THAN: 
case GREATER THAN: 
case NOT: 
return ERROR; ) 
) /* discard bad character */ 
/* 1-character lexeme */ 
/* 2-character lexeme */ 
return EQUAL ; 
return LESS THAN_OR_EQUAL ; 
return GREATER_THAN_OR_EQUAL 
return NOT_EQUAL 
/* discard both characters */ 
and I.!'X, which translate a description of a token set into a table-driven lexical analyzer. 
(Hereafter, when I say IJX, I'm actually referring to both programs). LEX itself just 
creates the tables, the remainder of the analyzer is the same for all IJX-generated source 
code. The fact that a IJX-generated analyzer is typically slower than a hard-coded one 
is, more often than not, a small price to pay for faster development time. Once the 
52 
Alphabets, strings, 
words. 
e, the empty string. 
Empty versus null strings 
Languages, sentences, 
grammars. Input and Lexical Analysis -Chapter 2 
language is stable, you can always go back and hard code a lexical analyzer if it's really 
necessary to speed up the front end. 
2.4.1 Languages* 
Before looking at U::X itself, we'll need a little theory. First some definitions. An 
alphabet is any finite set of symbols. For example, the ASCII character set is an alpha­
bet; the set {' 0' ,' 1' } is a more-restricted, binary alphabet. A string or word is a 
sequence of alphabetic symbols. In practical terms, a string is an array of characters. 
There is also the special case of an empty string, represented by the symbol E (pro­
nounced epsilon). In C, the ' \0' is not part of the input alphabet. As a consequence, it 
can be used as an end-of-string marker because it cannot be confused with any of the 
characters in the string itself, all of which are part of the input alphabet. An empty string 
in C can then be represented by an array containing a single ' \0' character. Note, here, 
that there's an important difference between E, an empty string, and a null string. The 
former is an array containing the end-of-string marker. The latter is represented by a 
NULL pointer-a pointer that doesn't point anywhere. In other words, there is no array 
associated with a null string. 
A language is a set of strings that can be formed from the input alphabet. A sentence 
is a sequence of the strings that comprise a language. A language can be as small as one 
string and still be useful. (Zero-element languages are possible, but not of much utility.) 
The ordering of strings within the sentence is defined by a collection of syntactic rules 
called a grammar. Note that this definition does not attribute meaning to any of the 
strings and this limitation has important practical consequences. The lexical analyzer 
doesn't understand meaning. It has to distinguish tokens solely on the basis of surround­
ing context-by looking at the characters that surround the current word, without regard 
to the syntactic or semantic structure of the input sentence (the tokens that precede and 
follow the current token). [Aho] introduces several other useful terms and definitions, 
paraphrased here:5 
prefix 
suffix A prefix is a string composed of the characters remaining after zero or 
more symbols have been deleted from the end of a string: "in" is a 
prefix of" inconsequential". Officially, Eisa prefix of every string. 
A suffix is a string formed by deleting zero or more symbols from the 
front of a string. "ible" is a suffix of" incomprehensible". The 
suffix is what's left after you've removed a prefix. E is a suffix of every 
string. 
substring A substring is what's left when you remove both a suffix and prefix: 
"age" is a substring of "unmanageable". Note that suffixes and 
prefixes are substrings (but not the other way around). Also E, the empty 
string, is a substring of every string. 
proper X A proper prefix, suffix, or substring of the string x has at least one ele­
ment and it is not the same as x. That is, it can't be E, and it can't be 
identical to the original string. 
sub-sequence A sub-sequence of a string is formed by deleting zero or more symbols 
from the string. The symbols don't have to be contiguous, so "iiii" 
and "ssss" are both sub-sequences of "Mississippi". 
5. [Aho], p. 93. 
Section 2.4.1 -Languages* 53 
Several useful operations can be performed on strings. The concatenation of two String concatenation. 
strings is formed by appending all characters of one string to the end of another string. 
The concatenation of" fire" and "water" is" firewater". The empty string, E, can 
be concatenated to any other string without modifying it. (In set theory, E is the identity 
element for the concatenation operation. An arithmetic analogy is found in multiplica- E is the identity element. 
tion: I is the identity element for multiplication because x=xxl.) The concatenation 
operation is sometimes specified with an operator (typically ax or·), so you can say that 
fire · water = firewater 
If you look at concatenation as a sort of multiplication, then exponentiation makes String exponentiation. 
sense. An expression like X" represents x, repeated n times. You could define a language 
consisting of the eight legal octal digits with the following: 
L(octal) =I 0, I, 2, 3, 4, 5, 6, 7 I 
and then you could specify a three-digit octal number with L(octal) 3• 
The exponentiation process can be generalized into the closure operations. If L is a Kleene Closure(*). 
language, then the Kleene closure of L is L repeated zero or more times. This operation 
is usually represented as L*. In the case of a language comprised of a single character, 
L* is that character repeated zero or more times. If the language elements are strings 
rather than single characters, L* are the strings repeated zero or more times. For exam-
ple, L(octal)* is zero or more octal digits. If L(vl) is a language comprised of the string 
Va and L(v2) is a language comprised of the string Voom, then 
L(v/)* · L(v2) 
describes all of the following strings: 
Voom VaVoom VaVaVoom VaVaVaVoom etc. 
The positive closure of Lis L repeated one or more times, usually denoted L+. It's other- Positive closure(+). 
wise just like Kleene closure. 
Since languages are sets of symbols, most of the standard set operations can be Set operations on 
applied to them. The most useful of these is union, denoted with the u operator. For languages, union (u). 
example, if letters is a language containing all 26 letters [denoted by L(letters)] and 
digits is a set containing all 10 digits [denoted by L(digits)], then I L(letters)uL(digits) I 
is the set of alphanumeric characters. Union is the equivalent of a logical OR operator. 
(If x is an element of AuB, then it is a member of either A OR B.) Other set operations 
(like intersection) are, of course possible, but have less practical application. 
The foregoing can all be applied to build a language from an alphabet and to define 
large languages (such as token sets) in terms of smaller languages (letters, digits, and so 
forth). For example 
L(digit) = I I, 2, 3, 4, 5, 6, 7, 8, 9 I 
L(alpha) = I a, b, c, ... , z I 
you can say: 
L(digit)+ 
L(digit)* L(alpha) u L(digit) 
(L(alpha) u L(digit))* 
L(alpha) 
· (L(alpha) u L(digit) )* is a decimal constant inC (one or more digits). 
is an optional decimal constant (zero or more digits). 
is the set of alphanumeric characters. 
is any number of alphanumeric characters. 
is a C identifier. 
54 
Forming regular expres­
sions. Metacharacters. 
Regular expression con­
catenation. 
Wildcard character. 
Start-of-line anchor. 
End-of-line anchor. 
Character classes. Input and Lexical Analysis -Chapter 2 
2.4.2 Regular Expressions* 
Programs like IJX use the foregoing language theory to specify a token set for a lexi­
cal analyzer. The possible lexemes that correspond to individual tokens are all defined 
using a series of set operations applied to previously defined languages, with a base 
alphabet of the ASCII character set. The programs then translate that language 
specification into the C source code for a computer program that recognizes strings in 
the language. 
Both programs use a notation called regular expressions for this purpose. Strictly 
speaking, a regular expression is any well-formed formula over union, concatenation and 
Kleene closure-as was the case with the examples in the previous section. A practical 
implementation of regular expressions usually add other operations, however, to make 
them easier to use. I'll examine an extended regular-expression syntax in the current 
section. 
The simplest regular expression is just a series of letters that match a sequence of the 
same letters in the input. Several special characters, called metacharacters, can be used 
to describe more complex strings. Though there are variations in the notation used for 
regular expressions, the following rules are used by LEX to form a regular expression and 
can be taken as characteristic: 6 
c A single character that is not a metacharacter is a regular expression. The 
character c forms a regular expression that matches the single character c. 
ee Two regular expressions concatenated form a regular expression that recog­
nizes a match of the first expression followed by a match of the second. If a, 
n, and d are regular expressions recognizing the characters a, n, and d, they 
can be concatenated to form the expression and which matches the pattern 
and in the input. Note that there's no explicit concatenation operator here, 
the two strings are just placed next to each other. 
A period (pronounced dot) matches any character except a newline. For 
example, the expression a . y matches any, amy, and the agy in magyar. 
An up arrow anchors the pattern to the start of the line. The pattern ~and 
matches the string and only if it comprises the first three characters on the 
line (no preceding white space). Note that any newline character that pre­
cedes the and is not matched. That is, the newline is not part of the lexeme, 
even though its presence (or a start-of-file marker) is required for a success­
ful match. 
$ A dollar sign anchors the pattern to end of line. The pattern and$ matches 
the string only if it is the last three characters on the line (no following 
white space). Again, the newline character is not part of the lexeme. The 
pattern ~and$ matches the word only if it's the only thing on a line. 
[ ••• ] [A ... ] Brackets match any of the characters enclosed in the brackets. The [ and ] 
metacharacter form a character class which matches any of the characters 
listed. For example, [ 012 3 4 56 7 8 9) matches any single decimal digit. 
Ranges of characters can be abbreviated using a dash, so [ 0-9) also 
matches a single decimal digit. [ 0-9A-Fa-f J matches a hexadecimal 
digit. [a-zA-z) matches an alphabetic character. If the first character fol­
lowing the bracket is an up arrow n. a negative character class (which 
matches any character except the ones specified) is formed. [ ~a-z) 
6. Other UNIX utilities, like grep, vi, and sed, use a subset of these rules. 
Section 2.4.2-Regular Expressions* 
*+? 
e{n,m} 
ele 
(e) matches any character except a lower-case, alphabetic character. Only 
seven characters have special meaning inside a character class: 
II 
\ Start of macro name. 
End of macro name. 
End of character class. 
Range of characters. 
Indicates negative character class. 
Takes away special meaning of characters up to next quote mark. 
Takes away special meaning of next character. 
Use\),\-,\\, and so forth, to put these into a class. Since other metachar­
acters such as*,?, and+ are not special here, the expression [ * ?+] matches 
a star, question mark, or plus sign. Also, a negative character class does not 
match a newline character. That is, [ ~a-z] actually matches anything 
except a lower-case character or newline. Note that a negative character 
class must match a character. That is, [ ~a-z] $ does not match an empty 
line. The line must have at least one character, though it may not end in a 
nonalphabetic character. 
A regular expression followed by a * (pronounced star) matches that Closure operators. 
expression repeated zero or more times; a + matches one or more repeti-
tions, a ? matches zero or one repetitions. These three metacharacters 
represent closure operations. They are higher precedence than concatena-
tion. 11 ?ama matches two strings: llama and lama. The expression 
l+ama matches lama, llama, and llllllllllllama. The expression 
1 * ama matches all of the above, but also matches ama. The expression -
0 [xX] [0-9a-fA-f] +matches a hexadecimal number inC syntax; [0-
7] [ 0-7] ? matches one or two octal digits. 
Matches n to m repetitions of the expression e. This operator is recognized Multiple matches. 
by lex, but not IJX. 
Two regular expressions separated by a vertical bar recognize a match of The OR operator. 
the first expression OR a match of the second. OR is lower precedence than 
concatenation. The expression either 1 or matches either either or or. 
Parentheses are used for grouping. The expression: Grouping. 
(frank l·john) ie 
matches both frankie, and johnie. The expression 
(frank I john) (ie)? 55 
matches frank and john as well. You can add a newline to the characters 
recognized by a negative character class with something like this: Add '0 to negative char­
acter class. 
([~a-z]l\en) 
Surrounding a string that contains metacharacters with double quotes ( 11 * 11) or 
preceding a single metacharacter with a backslash (\*)takes away its special meaning. 
(A character preceded by a backslash is said to be escaped.) The operator precedence is 
summarized in the Table 2.1. All operators associate left to right. 
Note that regular expressions can only define sequences of characters. They cannot 
do things like recognize any number of properly nested parentheses, something that can 
be recognized grammatically (by the parser). This is one of the main reasons that the 
lexical analyzer and parser are separate modules. The lexical analyzer is in charge of 
recognizing simple sequences of characters, and the parser recognizes more complex 
combinations. Escaping metacharac­
ters, quotes marks. 
Limitations of regular ex­
pressions. 
56 
Elementopr 
Recognizers. 
Finite automata, state 
machines. 
States. 
Transitions. 
Start state. 
Accepting states. 
Transition diagram. Input and Lexical Analysis -Chapter 2 
Table 2.1. Regular-Expression Operator Precedence 
operator description level 
() parentheses for grouping I (highest) 
[ l character classes 2 
* + ? closure: 0 or more, I or more, 0 or I 3 
cc concatenation 4 
I OR 5 
~ $ anchors to beginning and end of line 6 (lowest) 
2.4.3 Regular Definitions* 
There is an alternate way of describing a language's token set that takes a more 
grammatical approach, and which is used in many language specifications. A regular 
definition builds up a language specification using a combination of regular-expression 
operators and production-like specifiers. For example: 
keyword 
digit 
digit _sequence 
sign 
exponent _yart 
floating_ constant ~ long I int I double I while I ... 
~ 011121 ... 19 
~ digit+ 
~ +1-
~ e sign? digit _sequence 
I E sign? digit_sequence 
~ digit_sequence. digit_sequence? exponent_yart? 
I digit _sequence? . digit _sequence exponent _yart? 
digit _sequence exponent _yart 
Occasionally you see an opt subscript used to denote an optional element, such as digit"P' 
rather than digit?. This grammatical approach to languages is discussed in greater depth 
in the next chapter. 
2.4.4 Finite Automata* 
A recognizer program, such as a lexical analyzer, reads a string as input and outputs 
yes if the string is a sentence in a language, no if it isn't. A lexical analyzer has to do 
more than say yes or no to be useful, so an extra layer is usually added around the recog­
nizer itself. When a certain string is recognized, the second layer performs an action 
associated with that string. LEX takes an input file comprised of regular expressions and 
associated actions (code). It then builds a recognizer program that executes the code in 
the actions when a string is recognized. LEX builds the recognizer component of the 
analyzer by translating regular expressions that represent the lexemes into afinite auto­
maton or finite state machine (usually abbreviated to "state machine" or "FSM"). 
Strictly speaking, an FSM consists of the following: 
• A finite set of states. 
• A set of transitions (or moves) from one state to another. Each transition is labeled 
with a character from the input alphabet. 
• A special start state. 
• A set of final or accepting states. 
State machines are best understood by looking at one. Figure 2.3 is a transition 
diagram for a state machine that recognizes the four strings "he", "she", "his", and 
"hers". 
Section 2.4.4-Finite Automata* 
Figure 2.3. A State Machine 
start 
The circles are individual states, marked with the state number-an arbitrary number 
that identifies the state. State 0 is the start state, and the machine is initially in this state. 
The lines connecting the states represent the transitions, these lines are called edges and 
the label on an edge represents characters that cause the transition from one state to 
another (in the direction of the arrow). From the start state, reading an h from the input 
causes a transition to State 1; from State 1, an e gets the machine to State 3, and an i 
causes a transition to State 5; and so on. A transition from State N to state M on the char­
acter cis often represented with the notation: next(N,c)=M. This function is called the 
move function by some authors, [Aho] among them, but I feel that next better describes 
what the function is doing. 
The states with double circles are called accepting states. Entering an accepting 
state signifies recognition of a particular input string, and there is usually some sort of 
action associated with the accepting state (in lexical-analyzer applications, a token is 
returned). Unmarked edges (for example, there are no outgoing edges marked with an i, 
s, r, ore from State 0) are all implied transitions to a special implicit error state. 
State machines such as the foregoing can be modeled with two data structures: a sin­
gle variable holding the current state number and a two-dimensional array for computing 
the next state. One axis is indexed by the input character, the other by the current state, 
and the array holds the next state. For example, the previous machine can be represented 
by the arrays in Table 2.2. Two arrays are used, one to hold the state transitions and 
another to tell you whether a state is accepting or not. (You could also use a single, two­
dimensional array of structures, one element of which was the next state and the other of 
which was the accepting-state marker, but that would waste space.) The next state is 
determined from the current state and input character, by looking it up in the table as fol­
lows: 
next_state = Transition_table[ input_character ] [ current state ]; 
if( Accepting[ next_state ] == 1 ) 
do_an_accepting_action( next_state ) ; 
This input character is usually called the lookahead character because it's not removed 
from the input until the next-state transition is made. The machine derives the next state 
from the current state and lookahead character. If the next state is not the error state, 
then set the current state to that state and advance past the lookahead character (typically 
by reading, and discarding, it). 
The machine we just looked at is called a deterministic finite automaton or DFA. A 
DFA is "deterministic" in that the next state can always be determined by knowing the 
current state and the current lookahead character. To be more specific, a DFA is a state 57 
Edges. 
next(N,c)=M. 
Accepting states. 
Modeling state machines 
with arrays. 
Lookahead character 
used to compute next 
state. 
Deterministic finite 
automata (DFA). 
58 
Nondeterministic finite 
automaton (NFA). 
e transitions match empty 
string. Input and Lexical Analysis -Chapter 2 
Table 2.2. Representing the State Machine 
Transition Table 
Lookahead Character Accepting 
e h i r s 
0 -I - - 7 0 
I 2 -5 -- 0 
2 - - - 3 - I 
cur-3 --- - 4 0 
rent 4 - - - - - I 
state 5 - - - - 6 0 
6 - - - - - I 
7 -8 -- - 0 
8 9 - - - - 0 
9 - --- - I 
machine in which all outgoing edges are labeled with an input character, and no two 
edges leaving a given state have the same label. There is also a second, more general 
type of state machine called a nondeterministic finite automaton or NFA, which is more 
useful in many applications, including the current one. (All DFAs are also NFAs, but not 
the other way around.) An NFA has no limitations on the number and type of edges: 
Two outgoing edges can have the same label, and edges can be labeled with the empty 
string, E. This last type of edge is called an epsilon edge or epsilon transition. Since an E 
transition matches an empty string, it is taken without advancing the input and is always 
taken-regardless of the input character. For example, how can the regular expression 
(and/any) be represented as a state machine? A DFA for this expression looks like this: 
y 
Unfortunately, DFA's are difficult to construct directly from regular expressions 7-
NFA's are easy to construct. Two possibilities are: 
and 
7. It is possible to construct a DFA directly from a regular expression, though I won't discuss how to do it 
here. See both [McNaughton] and [Aho] pp. 135-141. 
Section 2.4.4-Finite Automata* 
a n 
a n 
The second machine is preferable because it's easier to represent in a computer program 
(we'll see how in a moment). As you can see, the NFA can be an awkward data structure 
to use. It can have many more states than the equivalent DFA, and it's difficult to write a 
state-machine driver (a program that uses the state machine to do something, such as State-machine driver. 
recognize tokens) that can use it directly. 8 I.!'X solves the problem by creating the state 
machine in a two-step process. It first makes an NFA representing the input regular 
expressions, and it then converts that NFA to a DFA, which it in tum outputs. I'll discuss 
how IJX performs this feat later in this chapter. 
The state-machine representations we've been looking at are, of course, just one of 
many ways to represent them. You can generalize the definitions for NFAs and DFAs. A NFA: formal definition. 
nondeterministic finite automaton, or NFA, is a mathematical model consisting of: 
(1) A set of states, S. 
(2) A special state in S called the start state. The machine is initially in this state. 
(3) A set of states inS called accepting states, entry into which denotes Tecognition of 
a string. Some sort of action is usually associated with each of the accepting states. 
(4) A set of input symbols (an input alphabet). 
(5) A next function that, when given a state and an input symbol, returns the set of 
states to which control is transferred on that symbol from the indicated state. I'll 
describe this next function in greater detail in a moment-note, however, that the 
next function returns a set of states. The main implementation difference between 
an NFA and a DFA is this next function. The next function for a DFA always 
yields a single next state. The equivalent NFA function can yield several next 
states. 
A deterministic finite automaton or DFA is an NFA with the following restrictions: 
(1) No state can have an outgoing E transition (an edge labeled with E, the empty 
string). 
(2) There may be no more than one outgoing transition from any state that is labeled 
with the same character. 
In practical terms, the foregoing definition describes only the data structures (the set 
of states and the way that the transitions are represented) and the next function that 
determines the next state from the current one. In other words, it tells us how to make a 
transition matrix. There is no information here about how the state machine is used; and 
automata can, in fact, be used in different ways depending on the application. The state 
machine is itself distinct from the driver program-the program that uses that machine. 
8. In fact, a theoretical NFA often has fewer states than an equivalent DFA because it can have more edges 
leaving a single state than the DFA has. Nonetheless, this sort of NFA is difficult to represent in a 
computer program because it has an indeterminate number of outgoing edges. The NFA's discussed in the 
current chapter all have more states than the equivalent DFA's because the extra states help smooth over 
these difficulties. I' II show how in a moment. DFA: formal definition. 
The state machine and 
driver are distinct. 
State-machine driver. 59 
60 
Using state machines for 
lexical analysis. 
Transition matrix. 
The greedy algorithm 
(matches longest string). Input and Lexical Analysis -Chapter 2 
2.4.5 State-Machine-Driven Lexical Analyzers* 
This section demonstrates how state machines are used for lexical analysis by look­
ing, at a high level, at the method used by a LEX-generated lexical analyzer. I'll describe 
a simple table-driven lexical analyzer that recognizes decimal and floating-point con­
stants. The following regular expressions describe these constants: 
[0-9]+ 
([0-9]+1 [0-9]*\. [0-9]+1 [0-9]+\. [0-9]*) (e[0-9]+)? return ICON; 
return FCON; 
The code to the right of the regular expression is executed by the lexical analyzer when 
an input string that matches that expression is recognized. The first expression recog­
nizes a simple sequence of one or more digits. The second expression recognizes a 
floating-point constant. The ( e [ 0-9] +) ? at the end of the second regular expression is 
the optional engineering notation at the end of the number. I've simplified by not allow­
ing the usual+ or-to follow thee, and only a lower-case e is recognized. The 
( [0-9] + [0-9]*\. [0-9]+ [0-9] +\. [0-9] *) 
recognizes one of three patterns (I've added the spaces to clarify what's going on­
they're not really there): The [ 0-9] + is a simple sequence of decimal digits. It's for 
numbers like 10e3. Because of the way that LEX works, the [0-9] +on the previous 
line of the input specification takes precedence over the current one-an ICON is 
returned if a number does not have a trailing e, otherwise an FCON is returned. The 
[ 0-9] * \ . [ 0-9] + recognizes numbers with at least one digit to the right of the decimal 
point, the [ 0-9] + \. [ 0-9] * recognizes numbers with at least one digit to the left. You 
can't use [ 0-9] *\. [ 0-9] * because that pattern would accept a decimal point without 
numbers on either side. All of the following numbers are accepted: 
1.2 l. .1 1.2e3 2e3 
and, of these, the last is an ICON and the others are FCONs. 
IJX uses a state-machine approach to recognize regular expressions, and a DFA that 
recognizes the previous expressions is shown in Figure 2.4. The same machine is 
represented as an array in Table 2.3. The next state is computed using that array with: 
next_state = array[ current_state ] [ input ] 
A dash indicates a failure transition (no legal outgoing transition on the current input 
character from the current state). This array is typically called a transition matrix or 
transition table. There are three accepting states (states from which a token is recog­
nized) in the machine: 1, 2, and 4. State 1 accepts an integer constant, and the other two 
recognize floating-point constants. The accepting states are recognized in an auxiliary 
array that is also indexed by state number, and which indicates whether or not a state is 
accepting. 
As I mentioned earlier, the state machine itself and the driver program that uses that 
machine are distinct from one another. Two algorithms are commonly used in lexical 
analysis applications, and the same state machine (transition matrix) is used by both 
algorithms. A greedy algorithm, shown in Table 2.4, is used by LEX (because that's 
what's required by most programming-language specifications). This algorithm finds the 
longest possible sequence of input characters that can form a token. The algorithm can 
be stated informally as follows: If there's an outgoing transition from the current state, 
take it. If the new state is an accepting state, remember it along with the input position. 
If there's no outgoing transition (the table has a a dash in it), do the action associated 
with the most-recently seen accepting state. If there is no such state, then an error has 
occurred (IJX just ignores the partially-collected lexeme and starts over from State 0, in 
this situation). 
Section 2.4.5-State-Machine-Driven Lexical Analyzers* 
Figure 2.4. State Machine That Recognizes Floating-Point Constants 
Table 2.3. State Machine in Figure 2.3 Represented as an Array 
lookahead character accepting action 0-9 e 
0 3 I --
I 2 I 5 return ICON; 
current 2 - 2 5 return FCON; 
state 3 - 2 - -
4 - 4 -return FCON 
5 - 4 --
I'll do two examples to show the workings of the machine, the first with the input 
1.2e4. LEX starts in State 0. The I causes a transition to State I and the input is Example: 1.2e4. 
advanced. Since State I is a potential accepting state, the current input position and state 
number is remembered. The dot now gets us to State 2 (and the input is advanced again). 
Since State 2 is also an accepting state, the previously remembered input position and 
state number are overwritten by the current ones. The next input character (the 2) causes 
us to go from State 2 to itself. State 2 is still an accepting state, so the current input posi-
tion overwrites the previously saved one. The e now gets us to State 5, which isn't an 
accepting state, so no other action is performed; and the final 4 causes a transition to 
State 4, which is an accepting state, so the current input position overwrites the previous 
one. The next input character is the end-of-input marker. There is no legal transition out 
of State 4 on end of input, so the machine enters the failure state. Here, the action asso-
ciated with the most-recently seen accepting state (4) is performed and the machine 
returns FCON. The next time the subroutine is called, it returns zero immediately, 
because the lookahead character is end of input. 61 
The second example looks at the incorrect input 1.2e, with no number following the Bad-inputexample: 1.2e. 
e. This input causes a failure transition from State 5, because there's no legal outgoing 
transition on end of input from State 5. When the failure occurs, the most recently seen 
accepting state is State 2, so the input is backed up to the condition it was in in State 2 
(the next input character is an e) and an FCON is returned. The next time the algorithm is 
entered, there will be a failure transition from the start state, because an e can't occur at 
the beginning of the number. Thee is discarded, and the algorithm goes to State 0 (and 
terminates). 
62 Input and Lexical Analysis -Chapter 2 
Table 2.4. Algorithm Used by the LEX State-Machine Driver 
current_state = 0; 
previously_seen_accepting_state = none_seen; 
if( lookahead character is end-of-input ) 
return 0; 
while( lookahead character is not end-of-input ) 
I 
if( there is a transition from the current state on the current lookahead character) 
I 
else current_state = that state; 
advance the input; 
if( the current state is an accepting state ) 
I 
remember the current position in the input 
and the action associated with the current state; 
if( no accepting state has been seen ) 
I 
else There's an error: 
Discard the current lexeme and input character. 
Current_state = 0; 
back up the input to the position it was in when it saw the last accepting state 
perform the action associated with that accepting state; 
Disadvantages of greedy 
algorithm. Note that the greedy algorithm does have its disadvantages: It's tricky to implement 
and tends to be relatively slow. It can also cause the recognizer to behave in sometimes 
unexpected ways. (The LEX input expression ( \n 1 . ) * tries to absorb the entire input 
file, for example.) It is nonetheless the best (and sometimes the only) choice in most real 
lexical-analysis applications. 
The nongreedy algorithm 
(matches first string). 
Terminal nodes. The second type of algorithm (the nongreedy algorithm) is much simpler. Here, the 
shortest possible input string is recognized, and the machine just accepts as soon as an 
accepting state is entered. A nongreedy recognizer program is much simpler to imple­
ment than a greedy one, and is much faster as well. Nonetheless, this algorithm can be 
used only when all the accepting states in the machine are terminal nodes-when they 
have no outgoing transitions. 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 
2.4.6 Implementing a State-Machine-Driven Lexical Analyzer 
This section shows how the machine in the previous section is implemented by 
analyzing a U::X output file in depth. You may want to skip over this section if you're not 
interested in this level of detail. You should read Appendixes A and D, in which various 
support functions and U::X itself are described, before continuing. A LEX input file that 
recognizes the floating-point constants we've been looking at is shown in Listing 2.11 
Listing 2.11. numbers.lex- A LEX Input File to Recognize Floating-Point Constants 
%{ 
%} #define FCON 1 ; 
#define ICON 2; 63 
!!'X input file for floating­
point constants. 
I 
2 
3 
4 
5 
6 
7 
8 
9 D [0-9] /* a single decimal digit */ 
%% 
{D)+ 
({D)+ I {D)*\. {D)+ I {D)+\. {D)*) (e{D}+)? 
%% return ICON; 
return FCON; 
The lex output file-/exyy.c-begins in Listing 2.12.9 The first two lines are from the 
header portion of the original LEX input file. They are followed by a comment that 
describes the state machine that U::X created. If a state is an accepting state, the first few 
characters of the equivalent code are printed (tabs are mapped to \t), along with the 
input line number. The goto transitions are shown along with the characters that cause 
the transitions. If several edges (outgoing transitions) all go to the same state, they are 
represented like this: 
goto 2 on 0123456789 
The state goes to State 2 if the input character is a digit. The entire comment is sur­
rounded with an #ifdef __ NEVER __ in case a *I should accidentally come up in one 
of these lists of transition characters. 
The next part of the LEX output file is copied directly from the template file 
(llib!lex.par by default, but a different file can be specified with the -m command-line 
switch). This template file is separated into three parts by formfeed (Ctri-L) characters. 
Everything from the beginning of the file up to the first formfeed is copied into the out­
put file at this juncture. The relevant code is shown in Listing 2.13. 
The #ifndef directive on line 35 of Listing 2.13 lets you define YYPRIVATE in the 
U::X-input-file header, without having to #undef it first. Most of the global variables in 
the file are declared as YYPRIVATE, which normally translates to the keyword static. 
Redefining this macro to an empty string makes these variables true globals, which can 
be accessed from outside the current file. I'm using the definition of NULL on line 39 to 
determine if <stdio.h> was included previously, and including it if not. Finally, if 
YYDEBUG is defined, various debugging diagnostics are activated. These are printed 
only if the variable yydebug is also true, thus the if statement on line 45. It's best to 
9. Note that there are two kinds of text in lexyy.c: (I) text copied verbatim from the template file /ex.par and 
(2) text generated by ~X itself. The listings that describe those parts of lexyy.c that are copied from the 
template file are labeled lex.par in the following discussion. ~X-generated text is in listings labeled 
lexyy.c. Line numbers carry over from one listing to another because there's really only a single output 
file. State-machine descrip­
tion in !!'X output file. 
NEVER --
Template-file organiza­
tion, lex.par 
YYPRIVATE. 
YY_D, yydebug, 
YYDEBUG 
64 Input and Lexical Analysis -Chapter 2 
Listing 2.12./exyy.c- State-Machine Description 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 #define FCON 1 
#define ICON 2 
#ifdef NEVER 
/*--------------------------------------------
* DFA (start state is 0) is: 
* 
* State 0 [nonaccepting] 
* goto 3 on . 
* goto 1 on 0123456789 
* State 1 [accepting, line 7 <return ICON;>] 
* goto 2 on 
* goto 1 on 0123456789 
* goto 5 on e 
* State 2 [accepting, line 8 <return\tFCON;>] 
* goto 2 on 0123456789 
* goto 5 on e 
* State 3 [nonaccepting] 
* goto 2 on 0123456789 
* State 4 [accepting, line 8 <return\tFCON;>] 
* goto 4 on 0123456789 
* State 5 [nonaccepting] 
* goto 4 on 0123456789 
*I 
#endif 
see how the macro works by looking at an example; if YYDEBUG is defined, then a 
debugging diagnostic like: 
YY_D( printf("aaaaaghhhh!!!") ); 
is expanded to: 
if( yydebug ) { printf("aaaaaghhhh!! !"); } else; 
Trailing else in 
multiple-statement 
macro. Note that the semicolon following the else comes from the original macro invocation 
and the semicolon following the print f ( ) follows the x in the macro definition. That 
trailing else is important in order to make something like the following work correctly: 
if( something ) 
YY_D(printf("aaaaaghhhh!! !") ) ; 
else 
something_else(); 
The foregoing expands to: 
if( something ) 
if( yydebug ) 
{ 
printf("aaaaaghhhh!! !"); 
else 
else 
something_else(); 
If the else weren't present in the macro definition, then the else 
something_ else () clause in the original code would incorrectly bind to the 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 65 
Listing 2.13. lex.par- Various Definitions Copied Into lexyy.c 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 /* YY TTYPE is used for the DFA transition table: Yy nxt[}, declared below. 
* YYF marks failure transitions in the DFA transiti~n table. There's no failure 
* state in the table itself, these transitions must be handled by the driver 
* program. The DFA start state is State 0. YYPRIVATE is only defined here only 
* if it hasn't be #defined earlier. I'm assuming that if NULL is undefined, 
* <stdio.h> hasn't been included. 
*I 
#ifndef YYPRIVATE 
# define YYPRIVATE static 
#endif 
#ifndef NULL 
# include <stdio.h> 
#endif 
#ifdef YYDEBUG 
int yydebug = 0; 
# 
#else 
# 
#endif define YY_D(x) if( yydebug ) { x; }else 
define YY_D(x) 
typedef unsigned char 
#define YYF YY_TTYPE; 
( ( YY_TTYPE ) (-1)) 
unsigned char *ii_text (); 
if (yydebug) rather than the if (something). If YYDEBUG isn't defined in the 
header, then the argument to YY _D effectively disappears from the input (the macro 
expands to an empty string). In this case, the printf ( ) statements go away. 
The code on lines 50 and 51 of Listing 2.13 are used to declare and access the 
transition-matrix array. YY _TYPE is the type of one array element, and YY _F marks 
failure transitions in the array. This latter value cannot be used as a state number. Note 
that the cast to unsigned char effectively translates -1 to 255. Similarly, -1 's in the 
tables are all silently converted to 255 as part of the initialization. 
The next part of the LEX output file is the state-machine transition matrix. It is used 
to compute the next state from the current state and lookahead symbols. This array can 
take three forms. The first, uncompressed form is shown in in Figure 2.5 and Listing 
2.14. I've simplified the picture by leaving all the error transitions blank. (They're ini­
tialized to -1 in Listing 2.14.) An uncompressed array is generated by specifying a-/ 
(for fast) switch on the IJ'X command line. The next state is computed with: 
Yy_nxt[ current_state] ] [ lookahead_character ] 
This operation is encapsulated into the yy _next (state, c) macro on line 147 of List­
ing 2.14. 
Notice that several columns in the uncompressed array are identical. All columns 
not associated with a period, e, or digit are the same-they're all error transitions. All 
the columns for the digits are the same. By the same token, the rows associated with 
States 4 and 5 are the same. (The states aren't equivalent because one is an accepting 
state and the other isn't.) This situation holds with most state machines that recognize 
real token sets. Taking C as a case in point, all the control characters and the space char­
acter are ignored, so the columns for these are identical. With a few exceptions like L YY_TYPE, YYF. 
Transition matrix 
representations. 
Uncompressed transition 
matrix. 
Compressed transition 
matrix. Redundant row 
and column elimination. 
66 
Figure 2.5. The Uncompressed Transition Table 
Yy_nxt [] [] 
0 
1 
2 
3 
4 
5 3 
2 0123456789 
1111111111 
1111111111 
2222222222 2222222222 
4444444444 
4444444444 
Listing 2.14. lexyy.c- The Uncompressed Transition Table 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 YYPRIVATE YY TTYPE 
{ 
I* 00 *I -1, 
} , -1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, -1, -1, 
I* 01 *I { -1, 
} , -1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, -1, 
-1, 
-1, 
I* 02 *I { -1, 
-1, 
-1, 
-1, 
-1, 
2, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, Yy_nxt[ 6 ] [ 128 ] = 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
1, 1, 1, 1, 1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
1, 1, 1, 1, 1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
5, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
2, 2, 2, 2, 2, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
5, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, -1, 
-1, 
-1, 
-1, 
3, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
2, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, -1, 
2, 
-1, -1, 
-1, 
-1, 
-1, 
-1, 
-1, -1, 
-1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1 
-1, 
-1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, -1, 
-1, 
-1 
-1, 
-1, 
-1, 
-1, 
-1, 
2, 
-1, -1, 
-1, -1, 
-1, 
-1, 
-1 Input and Lexical Analysis -Chapter 2 
-1, -1, 
-1, -1, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
1, 
-1, -1, -1, -1, -1, -1, -1, 
-1, 
-1, 
-1, 
-1, 
2, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, e 
5 
5 
-1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, -1, 
1, 
-1, 
-1, 
-1, -1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-1, 
2, 
-1, -1, 
-1, 
-1, 
-1, 
-1, 
-1, return ICON 
return FCON 
return FCON 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 
Listing 2.14. continued ... 
97 }, 
98 /* 03 *I { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
99 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
100 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
101 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
102 -1, -1, -1, -1, -1, -1, -1, -1, 2, 2, 
103 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 
104 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
105 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
106 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
107 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
108 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
109 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
110 -1, -1, -1, -1, -1, -1, -1, -1 
Ill }, 
112 /* 04 *I { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
113 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
114 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
115 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
116 -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 
117 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
118 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
119 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
120 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
121 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
122 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
123 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
124 -1, -1, -1, -1, -1, -1, -1, -1 
125 }, 
126 /* 05 *I { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
127 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
128 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
129 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
130 -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 
131 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
132 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
133 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
134 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
135 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
136 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
137 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
138 -1, -1, -1, -1, -1, -1, -1, -1 
139 } 
140 } ; 
141 
142 /*-----------------------------------------
143 * yy_ next (state, c) is given the current state and input 
144 * character and evaluates to the next state. 
145 *I 
146 
147 #define yy_ next(state, c) Yy_ nxt [ state l [ c l 
and x, all the columns for the letters are identical, as are most of the digit's columns. 
Moreover, at least half of the states in a typical machine have no legal outgoing transi­
tions, so the rows associated with these states are identical-every cell holds -I. 
LEX's default compression technique takes advantage of this situation and eliminates 
the redundant rows and columns by creating two supplemental arrays. The compressed 67 
68 
Yy_cmap[], Yy_nxt [] 
Yy_rmap[]. 
Compression ratio. 
Pair-compressed transi­
tion matrix. 
Yy_nxtN, Yy_nxt[]. Input and Lexical Analysis -Chapter 2 
Figure 2.6. Transition Table With Redundant Rows and Columns Eliminated 
Yy_rmap[] Yy_nxt [] [] 
0 0 -1 3 -I 0 
I -1 2 1 5 1 
2 -1 -1 2 5 2 
3 -1 -1 2 -1 3 
4 -1 -I 4 -1 4 
5 0 1 2 3 
table is shown in Figure 2.6 and in Listing 2.15. The Yy _ cmap [ J array is indexed by 
lookahead character and holds the index of one of the columns in the Yy _ nxt [] array. 
When several columns in the original array are equivalent, the matching entries in 
Yy _ cmap [ ] hold the index of a single column in Yy _ nxt [ ]. For example, the columns 
associated with digits in the original table are all identical. Only one of these columns is 
present in the compressed array (at Yy _ nxt [ x] [ 2] ), and all columns corresponding to 
digits in Yy _ cmap hold a 2 . The rows are compressed in the same way using 
Yy _ rmap [ ] . Since rows 4 and 5 are identical in the uncompressed array, Yy _ rmap [ 4] 
and Yy _ rmap [ 5] both hold a 4, and Yy _ nxt [ 4] [ x] holds the original row from the 
uncompressed table. 
An array element is accessed using: 
Yy_nxt[ Yy_rmap[current_state] ] [ Yy_cmap[lookahead_character] 
rather than the 
Yy_nxt[ current_state] ] [ lookahead_character ] 
that's used for the uncompressed table. The yy _next macro for this type of table is 
defined on line 102 of Listing 2.15. 
Redundant-row-and-column elimination is usually the best practical compression 
technique. The access time is fast, and the compression ratio is usually quite good. (In 
this example, the ratio is about 4: I -154 bytes, as compared to 640 bytes. The C lexi­
cal analyzer presented in Appendix D does even better, with a compression ratio of 
about 7: 1 -1,514 bytes versus 10,062 bytes.) 
A second compression method yields better compression if the transition matrix is 
particularly sparse, though the access time is slower. The rows are split into distinct 
one-dimensional arrays, accessed indirectly through an array of pointers (see Figure 2.7). 
The rows are all named Yy _ nxtN, where N is the original row index in the 
uncompressed table (row 5 is in Yy _ nxt 5 [ ] ), and the array of pointers is called 
Yy _ nxt [ ] . The current tables are compressed in this way in Listing 2.16. 
If the first cell of the Yy _ nxtN array is zero, then the remainder of the array is 
identical to the original row, and can be accessed directly using the lookahead character. 
To simplify a little: 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 69 
Listing 2.15. lexyy.c- Transition Table With Redundant Rows and Columns Eliminated 
54 /*-----------------------------------------
55 * The Yy_cmap[ 1 and Yy_rmap arrays are used as follows: 
56 * 
57 * next state= Yy_nxt [ Yy_rmap[current_ state} }[ Yy_cmap[input_ char} }; 
58 * 
59 * Character positions in the Yy_cmap array are: 
60 * 
61 * '@ 'A 'B 'C 'D 'E 'F 'G 'H 'I 'J 'K 'L 'M 'N '0 
62 * ·p 'Q 'R ·s 'T ·u ·v ·w 'X -y ·z A [ A\ '} 
63 * # $ % & ( ) * + I 
64 * 0 1 2 3 4 5 6 7 8 9 ; < > ? 
65 * @ A B c D E F G H I J K L M N 0 
66 * p Q R s T u v w X y z [ I 1 
67 * a b c d e f g h i j k 1 m n 0 
68 * p q r s t u v w X y z { I DEL 
69 *I 
70 
71 YYPRIVATE YY TTYPE Yy_cmap[128] = 
72 { 
73 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
74 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
75 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
76 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 
77 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
78 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
79 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
80 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
81 } ; 
82 
83 YYPRIVATE YY TTYPE Yy_rmap[6] 
84 { 
85 0, 1, 2, 3, 4, 4 
86 } ; 
87 
88 YYPRIVATE YY TTYPE Yy_nxt[ 5 l [ 4 ]= 
89 { 
90 /* 00 *I -1, 3, 1, -1 }, 
91 /* 01 *I -1, 2, 1, 5 }, 
92 /* 02 *I -1, -1, 2, 5 }, 
93 /* 03 *I -1, -1, 2, -1 }, 
94 /* 04 *I -1, -1, 4, -1 } 
95 } ; 
96 
97 /*-----------------------------------------
98 * yy_next(state,c) is given the current state number and input 
99 * character and evaluates to the next state. 
100 *I 
101 
102 #define yy_next(state,c) (Yy_nxt [ Yy_rmap[state] l [ Yy_cmap[c] l) 
YY TTYPE *row; 
row = Yy_nxt[ current state l ; 
if( *row == 0 
next state = (row + 1) [ lookahead character l ; 
If the first cell of the Yy _ nxtN array is nonzero, then the array holds a sequence of 
character/next-state pairs and the first cell holds the number of pairs. For example, 
70 
Figure 2.7. Pair-Compressed Tran~ition Table 
Yy_nxt [] 
0 
2 
3 
4 
5 
Listing 2.16. lexyy.c- Pair-Compressed Transition Table 
54 YYPRIVATE yy TTYPE Yy_ nxtO [] = { 11, 
55 , . , '3, , 0', 1, , 1,, 1, , 2', 1, , 3', 1, 
56 , 4', 1, , 5', 1, , 6', 1, , 7', 1, , 8', 1, 
57 , 9', 1}; 
58 YYPRIVATE yy TTYPE Yy_ nxt1 [] = { 0, 
59 -1, -1, -1, -1, -1, -1, -1, 
60 -1, -1, -1, -1, -1, -1, -1, 
61 -1, -1, -1, -1, -1, -1, -1, 
62 -1, -1, -1, -1, -1, -1, -1, 
63 -1, -1, -1, -1, -1, -1, 2, 
64 1, 1, 1, 1, 1, 1, 1, 
65 -1, -1, -1, -1, -1, -1, -1, 
66 -1, -1, -1, -1, -1, -1, -1, 
67 -1, -1, -1, -1, -1, -1, -1, 
68 -1, -1, -1, -1, -1, -1, -1, 
69 -1, 5, -1, -1, -1, -1, -1, 
70 -1, -1, -1, -1, -1, -1, -1, 
71 -1, -1, -1, -1, -1, -1, -1, 
72 YYPRIVATE yy TTYPE Yy_ nxt2 [] = { 11, 
73 , 0', 2, , 1,, 2, , 2', 2, , 3', 2, , 4', 2, 
74 , 5', 2, , 6', 2, , 7', 2, , 8', 2, , 9', 2, 
75 'e', 5}; 
76 YYPRIVATE yy TTYPE Yy_ nxt3 [] = { 10, 
77 , 0', 2, , 1,, 2, , 2', 2, , 3', 2, , 4', 2, 
78 , 5', 2, , 6', 2, , 7', 2, , 8', 2, , 9', 2 
79 } ; 
80 YYPRIVATE yy TTYPE Yy_ nxt4 [] = { 10, 
81 , 0', 4, , 1,, 4, , 2', 4, , 3', 4, , 4', 4, 
82 , 5', 4, , 6', 4, , 7', 4, , 8', 4, , 9', 4 
83 } ; 
84 YYPRIVATE yy TTYPE Yy_nxt5 [] = { 10, 
85 , 0', 4, , 1,, 4, , 2', 4, , 3', 4, , 4', 4, 
86 , 5', 4, , 6', 4, , 7', 4, , 8', 4, , 9', 4 
87 } ; 
88 
89 YYPRIVATE yy TTYPE *Yy_ nxt [ 6 l = 
90 { 
91 Yy_ nxtO , Yy_ nxt1 , Yy nxt2 , Yy_ nxt3 , Yy_ r'lxt4 -Input and Lexical Analysis -Chapter 2 
-1, -1, 
-1, -1, 
-1, -1, 
-1, -1, 
-1, 1, 
1, -1, 
-1, -1, 
-1, -1, 
-1, -1, 
-1, -1, 
-1, -1, 
-1, -1, 
-1}; 
, Yy_ nxt5 -1, 
-1, 
-1, 
-1, 
1, 
-1, 
-1, 
-1, 
-1, 
-1, 
-11, 
-1, Yy_nxtO [] 
Yy_nxtl [] 
Yy_nxt3[] 
Yy_nxt4 [] 
Yy_nxt5 [] 
.... 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 
Listing 2.16. continued ... 
92 
93 
94 
95 
96 
97 
98 
99 } ; 
/*---------------------------------------------------------*/ 
YYPRIVATE YY TTYPE yy_next( cur_state, c ) 
unsigned int c ; 
int cur state 
/* Given the current state and the current input character 
* return the next state. 
*I 
YY TTYPE *p = Yy_nxt[ cur state 
register int i; 100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 if( p ) 
{ /* there are transitions */ 
if ( ( i = *p++) == 0 
return p [ c l ; 
for( ; --i >= 0 ; p += 2 ) 
if( c == p[O] ) 
return p[l]; 
return YYF; /* row is uncompressed 
/* row is in in pairs 
Yy _ nxt 0 [ ] in Figure 2. 7 contains 11 pairs (because 11 is in the first cell). The first pair 
is {' .', 3), which means that if the next input character is a dot, then the next state is 
State 3. The next pair is {' 0', 1 )-if the lookahead character is a ' 0' , go to State 1, and 
so forth. If you get to the end of the list without finding the current lookahead character, 
there is a failure transition on that character. Again, simplifying a little: 
YY_TTYPE *row; 
row= Yy_nxt[ current state ]; 
if( *row != 0 
{ 
for( num pairs = *row++ ; --num_pairs >= 0 
if( row[O] == lookahead_character ) 
{ 
next state= row[l]; 
break; row += 2) 
The foregoing is implemented by the code on line 112 of Listing 2.16. 
A third situation, unfortunately not illustrated in this example, occurs when a state 
has no legal outgoing transitions. In this case, Yy _ nxt [state] is set to NULL, so: 
if( Yy_nxt[current_state] ==NULL ) 
next_state = FAILURE ; 
This transition is activated when the test on line 107 of Listing 2.16 fails. *I 
*I 71 
Note that further compression can be achieved at the expense of error recovery by Using a default transition. 
providing a default state other than the error state. Hitherto, an error was indicated when 
you got to the end of the pair list. You can use the most common nonerror transition 
instead of the error transition in this case, however. For example, Yy _ nxt 2 contains 
72 
Setting pair-compression 
threshold in L!X 
Pair compression, 
compression ratio. 
Accepting-state array, 
Yyaccept [) . these pairs: 
[' 0', 2] 
[' 5' ,2] [' 1', 2] 
[' 6' ,2] [' 2' ,2] 
[' 7' ,2] [' 3' ,2] 
[' 8' ,2] Input and Lexical Analysis -Chapter 2 
[' 4' ,2] 
[' 9' ,2] ['e' ,5] 
All but one of the transitions are to State 2, so if you use the transition to State 2 as the 
default (rather than a transition to the error state), the row could be compressed as fol­
lows 
YYPRIVATE YY TTYPE Yy_nxt2 [] = { 1, 2, 'e' ,5 }; 
The first number (1) is the pair count, as before. The second number (2) is the default 
next-state transition. If the next function gets through the entire list of pairs without 
finding a match, it will go to this default next state. The remainder of the array is the one 
pair that doesn't go to the default state. This extreme compression isn't very useful in a 
lexical-analyzer application because you can't really afford to discard all the error infor­
mation, but it's sometimes useful in parser applications. The UNIX yacc utility uses a 
variation on this method to compress its tables. 10 Of course, if there are more transitions 
to an explicit state than to the error state, you can put the error transitions into the pair 
list and use the explicit state as the default state. This way you won't loose any informa­
tion. 
Pair compression is activated in LEX with a -eN command-line switch. N is the thres­
hold beyond which pairs are abandoned in favor of a simple array indexed by lookahead 
character. The example we've been looking at had the threshold set at II, so any state 
with more than II outgoing transitions is handled with a simple array, and states with II 
or fewer outgoing transitions are represented with character/next-state pairs. The default 
threshold-used when noN is given on the command line-is four. 
The compression ratio here tends not to be as good as with redundant-row-and­
column elimination in programming-language applications. The current example uses 
247 bytes, versus I 54 for the other method. The C lexical analyzer uses 3,272 bytes for 
the pair-compressed tables, versus I ,5I4 for the default method. It does do better when 
the data in the matrix is both sparse and randomly distributed, however. The -v 
command-line switch to IJX causes the final table sizes to be printed, so you can judge 
which method is more appropriate for a given application. 
You'll note that the redundant-row-and-column elimination could be combined with 
the pair-compression technique. For example, since the last two rows in the table shown 
in Figure 2.7 are the same, you really need to store only one of them and keep two 
pointers to it. I haven't implemented this combined method. 
The next part of lexyy. cis the accepting-state array, Yyaccept [),shown in List­
ing 2.17. The array is indexed by state number. It evaluates to 0 if the state is not an 
accepting state. Other values set the conditions under which the lexeme is accepted. It 
holds I if the string is anchored to the start of the line (a A was the leftmost symbol in the 
original regular expression-an extra newline will be at the far left of the lexeme in this 
case). It holds 2 if the string is anchored to the end of the line (a $ was the rightmost 
symbol in the original regular expression-an extra newline will be at the far right of the 
lexeme in this case). It holds 3 if the lexeme is anchored both to the beginning and the 
end of the line, and 4 if the lexeme is always accepted-no anchors were present in the 
original regular expression. 
10. The method is described in [Aho], pp. 144-146. They use separate arrays for the pairs and the default 
transitions, but the rationale is the same. 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 73 
Listing 2.11./exyy.c- Accepting-State Identification Array 
118 /*-----------------------------------------
119 * The Yyaccept array has two purposes. If Yyaccept[i] is 0 then state 
120 * i is nonaccepting. If it's nonzero then the number determines whether 
121 * the string is anchored, l=anchored at start of line, 2=at end of 
122 * line, 3=both, 4=line not anchored 
123 */ 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 YYPRIVATE 
{ 
0 
4 
4 
0 
4 
0 
} ; YY TTYPE 
/* 
/* /* 
/* 
/* 
/* Yyaccept [ l = 
State 0 *I 
State 1 *I 
State 2 */ 
State 3 *I 
State 4 *I 
State 5 *I 
The remainder of lexyy.c file is the actual state-machine driver, shown in Listing 
2.18. The first and last part of this listing are the second and third parts of the Ctrl-L­
delimited template file discussed earlier. The case statements in the middle (on lines 287 
to 295 of Listing 2.18) correspond to the original code attached to the regular expres­
sions in the input file and are generated by LEX itself. 
The various global variables that communicate with the parser are declared on lines 
138 to 141. Note that yyout is provided for UNIX compatibility, but you shouldn't use it 
if you're using occs (because it will mess up the windows in the debugging system). 
Same goes for the output ( ) and ECHO macros on lines 147 and 148. UNIX supports 
them but they shouldn't be used in an occs environment. It's best to use the actual output 
functions, or to supply similarly-named replacement functions that you can use to debug 
your lexical analyzer (assuming that the functions you supply will eventually be 
replaced by the occs versions). These replacement functions are shown in lex_io.c (List­
ing 2.18 ). Link this file to the lexical analyzer when you're debugging a lex output file 
without a parser. Use the versions of the routines that are in /.lib, and which support the 
occs debugging environment, when you're using an occs-generated parser. 
The YYERROR ( ) macro on line 151 of Listing 2.19 prints internal error messages. 
There's no UNIX equivalent because lex doesn't print error messages. In the occs 
environment, you should redefine YYERROR () to use yyerror () rather than 
fprintf (). (Do it in a'%{ %I' block in the definitions section.) 
The yymore ( ) macro on line 154 of Listing 2.19 just sets a flag to true. It forces 
the driver to continue processing the current lexeme, ignoring the current accepting 
action. unput ( ) and yyless ( ) (on lines 156 and 157) are the two pushback func­
tions. They unterminate the current lexeme, push back any requested characters, and 
then reterminate the lexeme. I've made extensive use of the comma operator here in 
order to squeeze several instructions into a single macro. The comma operator just exe­
cutes the comma-delimited statements in sequence. It evaluates to the rightmost state­
ment in the list, but neither of these macros take advantage of this behavior-they'd be 
declared void if they were functions. Braces can't be used here because of the binding 
problems discussed earlier. Note that the conditional on line 158 sets 'yyleng' to zero if 
the ii _pushback () call fails, as it will if you try to push back too many characters; 
otherwise, 'yyleng' is just reduced by the number of pushed-back characters. 
The input ( ) function on line 162 of Listing 2.19 is complicated enough to be a 
subroutine. It has to return a value, and the contortions necessary to do this with a !!'X state-machine driver. 
yyout, output (), 
ECHO. 
YYERROR(). 
yymore (), yyless (), 
unput (). 
input(). 
74 Input and Lexical Analysis -Chapter 2 
Listing 2.18. lex io.c-Debugging Output Routines for IJ'X-Generated Analyzer 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 #include <stdio.h> 
#include <stdarg.h> 
I* This file contains two output routines that replace the ones in yydebug.c, 
* found in l.lib and used by aces for output. Link this file to a LeX-
* generated lexical analyzer when an aces-generated parser is not present. 
*Then use yycomment() for messages to stdout, yyerror() for messages to 
* stderr. 
*I 
PUBLIC 
char void yycomment{ fmt, ... ) 
*fmt; 
{ 
I* Works like printf(). *I 
va list 
va_start( 
vfprintf( 
va end ( args; 
args, fmt ); 
stdout, fmt, args ); 
args ); 
PUBLIC void yyerror( fmt, ... ) 
char *fmt; 
{ 
I* Works like printf() but prints an error message along with the 
* current line number and lexeme. 
*I 
va list args; 
va_start( args, fmt ); 
fprintf ( stderr, "ERROR on line %d, near <%s>\n", yylineno, yytext ) ; 
vfprintf( stderr, fmt, args ); 
va end ( args ); 
comma operator are not worth the effort. 
yylex (), yystate. The lexical analyzer itself, yylex () starts on line 177 of Listing 2.19. The current 
state is held in yystate, which initially set to -1-a value that's not used as a state 
number. The code on lines 187 to 192 is executed only once because yystate is set to 
-1 only the first time the subroutine is called. The 
ii_advance(); 
ii_pushback(l); 
forces an initial buffer load so that ii look ( ) can be used later on. 
Control-flow in yylex ( >. The actual control flow through the program is unusual in that one branch of the 
main loop exits the subroutine entirely and reenters the loop from the top. In other 
words, if an action in the original input file contains a return statement, then control 
passes out of the loop at that point, and passes back into the loop on the next call. A nor­
mal path through the loop is also available when no such return is executed. The 
situation is illustrated in Figure 2.8. The initializations can't be done at the top of the 
loop because they're performed only on accepting a lexeme, not on every iteration of the 
loop. 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 
Figure 2.8. Flow of Control Within yy lex () 
First call 
Subsequent calls 
r----------------------r---------, 
1 yylex () 
Noreturn 1 
in accepting 1 
action { \I 
I One-time initializations I 
~ 
I Normal initializations I 
' / 
while ( 1 ) 
{ 
if( do"ng an accepting action ) 
{ 
~~--------------~ 
'----------1 1 Normal Initializations I return 
statement in 
accepting action 
The initializations on lines 194 to 198 of Listing 2.19 are executed every time the 
loop is entered from the top, and these initializations are duplicated on lines 303 to 315 
for those situations where an accepting action does not contain a return statement. 
This code unterminates the previous lexeme (ii _ unterm () ), sets the start marker for 
the current lexeme (ii_mark_start ()),and sets yylastaccept to zero to signify 
that no accepting state has been seen (the start state, which is always State 0, cannot be 
an accepting state). The ii_unterm () call does nothing if the string is not' \0' ter­
minated, as is initially the case. 
Listing 2.19. lex.par- State-Machine Driver Copied to lexyy.c 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 /*-----------------------------------------------------------------
* Global variables used by the parser. 
*I 
char 
int 
int 
FILE *yytext; /* Pointer to lexeme. 
yyleng; /* Length of lexeme. 
yylineno; /* Input line number. 
*yyout = stdout; *I 
*I *I 
/*-----------------------------------------------------------------
* Macros that duplicate functions in UNIX lex: 
*I 
#define output(c) 
#define ECHO putc(c,yyout) 
fprintf(yyout, "%s", yytext ) 75 
76 Input and Lexical Analysis -Chapter 2 
Listing 2.19. continued ... 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 #ifndef YYERROR 
# define YYERROR(t) fprintf(stderr,"%s", t 
#endif 
#define yymore() 
#define unput(c) 
#define yyless(n) yymoreflg = 1 
(ii_unput(c), --yyleng 
( ii_unterm(), \ 
yyleng -= ii_pushback(n) ? n 
ii_term() \ yyleng ), \ 
int input () /* This is a macro in UNIX lex */ 
int c; 
if( (c = ii_input ()) && (c != -1) ) 
{ 
yytext ii_text(); 
yy1ineno ii 1ineno(); 
++yyleng; 
return c; 
/*----------------------------------------------------------------------*/ 
yylex () 
( 
int yymoreflg; 
static int yystate -1; 
int yy1astaccept; 
int yyprev; 
int yynstate; 
int yy1ook; 
int yyanchor; 
if( yystate == -1 ) 
{ 
yy_init_lex(); ii _advance () ; 
ii_pushback(1); 
yystate 0; 
yy1astaccept 0; 
yymoreflg 0; 
ii_unterm(); 
ii_mark_start (); 
while( 1 ) 
{ /* Set when yymore () is executed 
/* Current state. 
/* Most recently seen accept state 
/* State before yylastaccept 
/* Next state, given lookahead. 
/* Lookahead character 
/* Anchor point for most recently seen 
/* accepting state. 
/* One-time initializations */ 
/* Top-of-loop initializations */ 
/* Check end of file. If there's an unprocessed accepting state, *I 
*I 
*I 
*I 
*I *I 
*I 
*I 
* yylastaccept will be nonzero. In this case, ignore EOF for now so 
* that you can do the accepting action; otherwise, try to open another 
* file and return if you can't. 
*I 
.... 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 
Listing 2.19. continued ... 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 while ( 1 ) 
{ 
if( (yy1ook=ii 1ook(1)) != EOF ) 
{ 
yynstate 
break; yy_next( yystate, yy1ook ); 
else 
{ 
if( yy1astaccept ) 
{ 
yynstate = YYF; 
break; 
else if( yywrap() 
{ 
else 
{ yytext = ""; 
yy1eng = 0; 
return 0; 
ii advance(); 
ii_pushback(1); /* still something to do */ 
/* another file? */ 
/* no */ 
/* load a new buffer */ 
if( yynstate != YYF 
{ 
else YY_D ( printf (" Transition from state %d", yystate ) ) ; 
YY D( printf(" to state %don <%c>\n", yynstate, yylook) ); 
if( ii advance() < 0 
{ /* Buffer full */ 
YYERROR( "Lexeme too long, discarding characters\n" ) ; 
ii flush (1); 
if(yyanchor 
{ Yyaccept[ yynstate ]) /* saw an accept state */ 
yyprev 
yylastaccept 
ii_mark_end (); 
yystate yynstate; 
if( !yylastaccept ) 
{ yystate 
yynstate 
/* Mark input at current character. */ 
/* A subsequent ii_to_mark() */ 
/* returns us to this position. */ 
/* illegal input */ 
#ifdef YYBADINP 
YYERROR( "Ignoring bad input\n" ) ; 
#endif 
ii advance(); /* Skip char that caused failure. *I 77 
.... 
78 Input and Lexical Analysis -Chapter 2 
Listing 2.19. continued ... 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
yymoreflg. else 
{ 
ii to mark(); /* Back up to previous accept state */ 
if( yyanchor & 2 ) ii _pushback ( 1) ; /* If end anchor is active */ 
/* push back the CR or LF */ 
if( yyanchor & 1 ) 
ii_move_start(); /* if start anchor is active */ 
/* skip the leading newline */ 
ii term() ; 
yyleng 
yytext 
yylineno /* Null-terminate the string */ ii _length () ; 
ii text (); 
ii lineno (); 
YY_D( printf("Accepting state %d, ", 
YY_D ( printf ("line %d: <%s>\n", 
switch( yylastaccept ) 
{ 
case 1: 
return ICON; 
break; 
case 2: 
return FCON; 
break; 
case 4: 
return FCON; 
break; 
default: yylastaccept ) 
yylineno, yytext 
/* State 1 
/* State 2 
/* State 4 
YYERROR( "INTERNAL ERROR, yylex\n" ); 
break; *I 
*I 
*I ) ; 
) ; 
ii unterm(); 
yylastaccept 0; 
if ( ! yymoreflg 
{ 
yystate = 0; 
ii_mark_start(); 
else 
{ 
yystate 
yymoreflg yyprev; 
0; /* Back up */ 
The yymoreflg that is tested on line 306 of Listing 2.19 is set true by yymore ( ) . 
If yymoreflg is false, the machine behaves normally: the next state is State 0 and the 
start-of-lexeme marker is reset so that the machine can collect a new lexeme (on lines 
308 and 309). Ifyymoreflg is true, the machine backs up one state rather than going to 
State 0, and the start-of-lexeme marker isn't modified, so additional characters are added 
Section 2.4.6-Implementing a State-Machine-Driven Lexical Analyzer 79 
to the end of the current lexeme. The only use of yyprev is to remember the last state yyprev 
so that the machine can back up. 
Generally, backing up is the correct action to take for yymo re ( ) . For example, the Problems with 
naive string-processing algorithm discussed in Chapter Two looked like this: yymore <) · 
\"[-\"]*\" if( yytext[yyleng-2] == '\\' ) 
yymore(); 
else 
return STRING; 
This expression creates the following machine: 
The problem is that the machine is in State 2 after the close quote is recognized. In order 
to continue processing the string, it needs to back up to State I (so that another close 
quote can get it back to State 2). The back up that's initiated by yymore ( ) can cause 
problems (not very often, but, as Shiva says, to be four-armed is to be forewarned). One 
of my original attempts to handle the escape-sequence-in-a-string problem looked like 
this: 
\"[-\"\\]* if( ii lookahead(l) == '\\' ) 
{ 
else input(); 
input(); 
yymore(); /* Skip the backslash */ 
/* and the character that follows. */ 
/* it's a " */ 
input(); /*Get the close quote */ 
return STRING; 
The idea was to break out of the regular expression if either a backslash or quote was 
encountered, look ahead to see which of the two possible characters were there, and then 
absorb the escape sequence with input () calls. The state machine looks like this: 
~Anything but'' or\ 
The problem arises when you try to handle a string like: 
"\"" 
The machine starts out in State 0, the quote puts it into State I, and then the machine ter­
minates because there's no outgoing transition from State I on a backslash. The code is 
now activated and the if statement tests true. The two input ( ) calls absorb the 
backslash and the second quote, and yymore ( ) backs us up to the previous state-State 
0. Now the third quote is encountered, but the machine treats it as a start-of-string char­
acter, not as an end-of-string character. The code associated with State I won't be exe­
cuted until a fourth quote or another backslash is encountered. The best solution to this 
problem prevents the backup by using: 
yyprev = yystate; 
yymore (); 
rather than a simple yymore ( ) invocation. To see what's happening here, consider that 
yyprev holds the number of the state to back up to-the previous state; yystate holds 
80 
Finding the next state. 
End-of-file processing, 
yywrap(). 
Failure transitions in 
yylex (), 
yylastaccept. 
YYBADINP Input and Lexical Analysis -Chapter 2 
the current state number. The assignment of the current state to the previous state means 
that the machine will back up to the current state when yymore () is invoked. That is, it 
won't back up at all. 
Alternately, you could use the following: 
ii_unterm(); 
continue; 
instead of yymore, but I think that this latter solution is more confusing. (Look at the 
code to see what a continue will do here.) You don't want to break out of the loop 
because the existing lexeme is discarded in this case. 
Returning to Listing 2.19, the while loop on lines 208 to 234 (page 77) gets the next 
input character and puts it into yylook-the input is not advanced by ii _look ( ) . 
The normal situation of not being at end of file is handled on line 212, where the next 
state is computed. The else clause deals with end of file. Ifyylastaccept is true on 
line 217, then the machine hasn't executed the accepting action for the last lexeme in the 
file, so end-of-file processing is delayed until the action is done. If it's false, then 
yywrap ( ) is called to open a new input file. This user-supplied subroutine can be used 
to chain together several input files. The default, library version just returns zero. If you 
have several input files, you can replace the default version with one that opens the next 
input file (and returns 1 until there are no more files to open). So, if yywrap ( ) returns 
false, it's not time to wrap up and the code loops back up to line 208. The next state is 
then recomputed using the first character in the new file (as if the EOF had not been 
encountered). The code loops until a nonempty file is opened. There's some potential 
confusion here in that yywrap ( ) returns true if the program should terminate, even 
though a false return value would be more intuitive in this situation. Remember, the 
name yywrap () stands for "go ahead and wrap up."11 
When the loop terminates, yylook holds the current lookahead character, and the 
potential next state is figured on line 212. The machine has not changed state yet 
because yystate hasn't been modified. The machine is looking ahead at what the next 
state is going to be, given the current lookahead character. 
If the next state is not a failure transition, the input is advanced (on line 242) and the 
machine looks to see if the new state is an accepting state (on line 248). If so, the 
accepting state is remembered in yylastaccept, and the state preceding the accepting 
state is also remembered for yymore ( ) processing. Finally, the driver switches to a 
new state by modifying yystate on line 257. 
The else clause that starts on line 259 handles failure transitions. In this case you 
want to perform the accepting action associated with the most recently seen accepting 
state (which you just remembered in yylastaccept). Ifyylastaccept is zero, then 
no such accepting state was encountered and you're looking at a bad lexeme (one that is 
not described by any regular expression in the input file). An error message is printed if 
YYBADINP is true and ii _advance ( ) is called to skip the offending character. 
If an accepting state had been encountered, the input is restored to the condition it 
was in at that time by the ii_to_mark () call on line 270. The test on line 271 checks 
for an end-of-line anchor, in which case the newline (which is part of the lexeme at this 
point) must be pushed back into the input (in case it is needed to match a start-of-line 
anchor in the next lexeme). The lexeme is terminated, and the global variables that com­
municate with the parser are initialized on lines 277 to 280. The if clause on the next 
II. I've, perhaps wrongly, perpetuated the problem in order to keep UNIX compatibility. 
Section 2.4.6-lmplementing a State-Machine-Driven Lexical Analyzer 81 
line removes a newline that's at the start of the lexeme as the result of a beginning-of­
line anchor. 
The switch on line 285 contains all the accepting actions that were part of the origi-Accepting actions in 
nal input file. The case statements are all generated by U'X itself -the case values are yylex ( > · 
the state numbers of the associated accepting state. The default case on line 297 
should never be executed. It's here as insurance, in case an unknown bug in U'X gen-
erates a bad state number in the switch. 
2.5 LEX-A Lexical-Analyzer Generator* 
The remainder of this chapter presents the complete source code for UlX, along with 
the underlying theory. You must read Appendix A if you intend to look at the implemen­
tation details. The set routines presented there are used heavily in this chapter, and a 
familiarity with the calling conventions for these routines will be useful. 
2.5.1 Thompson's Construction: From a Regular Expression to an NFA* 
I.!'X constructs NFA's from regular expressions using a system called Thompson's 
Construction, developed by Ken Thompson at Bell Labs for the QED editor. It works as 
follows: 
The simplest possible regular expression is a single character, and this expression Simple expressions. 
can be represented by a correspondingly simple NFA. For example, a machine that 
matches an a is shown below: 
The concatenation of two regular expressions is also straightforward. The following Concatenation. 
machine represents the expression ab by constructing individual machines for each 
subexpression (the a and b), and then connecting the machines with an E edge: 
This method needlessly wastes states, however. A better solution merges the ending 
state of the first machine with the start state of the second one, like this: 
There are two situations in a U'X application where an OR of two regular expressions is 
required. The first is the input specification itself. That is, the U'X input contains many 
regular expressions, but a single machine must be output that recognizes all of these 
expressions. This means that all the input expressions are effectively ORed together to 
create the output DFA. LEX does this high-level OR using the system shown in Figure 
2.9. Each of the boxes is an NFA that represents an entire regular expression, and all of 
these are connected together using several dummy states and E edges. 
The second OR situation is the OR operator (the vertical bar) which can appear in the 
regular expression itself (as in alb). U'X processes the OR operator by constructing the 
machine shown in Figure 2.1 0. Again, the seemingly empty boxes in the pictures 
represent machines for entire subexpressions. Figure 2.11 shows how the expression 
((alb)lcd) would be represented. UlX starts out by making two machines to recognize the 
a and b, and connects the two using the OR construction shown in Figure 2.10. U'X then 
creates two more machines to recognize the c and d, concatenating them together by 
merging the end state of the first machine with the start state of the second. Finally, it Logical OR at the top 
level. 
OR operator (1). 
82 
Closure operators: * + ? 
Evolution of a complex 
regular expression. Input and Lexical Analysis -Chapter 2 
Figure 2.9. Connecting the Regular Expressions in a UX Input File 
to other machines 
processes the second OR operator, applying the same construction that it used earlier, 
but this time using the machines representing the more-complicated subexpressions (a/b) 
and cd in place of the boxes in Figure 2.1 0. 
Figure 2.10. Generic NFA for the OR operator 
E 
The machines to recognize the three closure operators are a little more complicated 
looking. They are shown in Figure 2.12. Note that the machines that recognize + and ? 
are special cases of the machine for the * operator. 
Figure 2.13 shows the evolution of a machine that recognizes a subset of the 
floating-point constants discussed earlier. The expression used is (D*\ .DID\ .D*). It 
recognizes numbers with one digit to the right of the point and zero or more digits 
preceding it and it also recognizes the inverse-one digit to the left of the decimal point 
and zero or more digits following the decimal point. LEX starts out constructing an 
expression for the first Din the expression [in Figure 2.13(a)]. It then reads the leftmost 
* and substitutes the first machine into the closure machine, yielding Figure 2.13(b). It 
then reads the dot, and tacks it on to the right edge of the partially constructed machine 
[Figure 2.13(c)], and it does the same for the next D [Figure 2.13(d)]. Encountering the I 
operator, UX holds onto the previously constructed expression for a moment, and then 
constructs a second machine for the next subexpression (D\. D*), not shown in the 
figure. Finally, it connects the two machines for the subexpressions together, using the 
OR construction [Figure 2.13(e)]. 
Section 2.5.1-Thompson's Construction: From a Regular Expression to an NFA* 
Figure 2.11. An NFA That Recognizes ((alb)lcd) 
r 
£ £ 
£ £ £ 
9 L _j 
£ .., £ 
c 7 d 8 
L _j 
Figure 2.12. Representing the Closure Operators 
E 
* 
E 
E 
E + 
? 
E 
2.5.2 Implementing Thompson's Construction 
This section presents a low-level implementation of the theory in the previous sec­
tion. Skip forward to Section 2.5.3 if you're not interested in this level of detail. 
2.5.2.1 Data Structures. A machine built with Thompson's construction has several 
useful characteristics: 
• All the machines that recognize subexpressions-no matter how complicated-have 
a single start state and a single end state. 
• No state has more than two outgoing edges. Characteristics of a 
Thompson machine 83 
84 
The NFA structure. 
next, next2, and edge 
fields of an NFA. Input and Lexical Analysis -Chapter 2 
Figure 2.13. Constructing an NFA for (D*\.DID\.D*) 
(a) 
E 
(b) 
E 
(c) 
E 
E 
(d) E 
E 
(e) E 
E 
E E 
E E 
E 
• There are only three possibilities for the labels on the edges: ( 1) there is only one 
outgoing edge labeled with a single input character, (2) there is only one outgoing 
edge labeled with E, and (3) there are two outgoing edges labeled with E. There are 
never two outgoing edges labeled with input characters, and there are never two 
edges, one of which is labeled with an input character and the other of which is 
labeled with E. 
The NFA data structure in Listing 2.20 uses these characteristics to implement an 
NFA state. The next field either points at the next state, or is set to NULL if there are no 
outgoing edges. The next2 field is used only for states with two outgoing E edges. It is 
set to NULL if there's only one such transition. The edge field holds one of four values 
that determine what the label looks like: 
Section 2.5.2-Implementing Thompson's Construction 
• If there is a single outgoing edge labeled with an input character, edge holds that 
character. 85 
Single, non-E edge. 
• If the state has an outgoing E edge, then edge is set to EPSILON. 
• If a transition is made on a character class, all characters in the class are elements of 
the SET pointed to by bi tset, and edge holds the value CCL. The set elements are 
just the ASCII values of the characters. For example, if an ASCII ' 0' , which has the 
value 4810, is in the character class, the number 48 will be in the set. E edges, EPSILON. 
Character classes, CCL, 
bit set. 
• If the state has no outgoing transitions, edge is set to EMPTY. Terminal states, EMPTY. 
Listing 2.20. nfa.h-Data Structures and Macros 
I /*--------------------------------------------------------------
2 * Nfa state: 
3 *I 
4 
5 typedef struct nfa 
6 { 
7 int edge; /* Label for edge: character, CCL, EMPTY, or *I 
8 /* EPSILON. *I 
9 SET *bit set; /* Set to store character classes. *I 
10 struct nfa *next; /* Next state (or NULL if none) *I 
II struct nfa *next2; /* Another next state if edge==EPSILON *I 
12 /* NULL of this state isn't used *I 
13 char *accept; /* NULL if not an accepting state, else *I 
14 /* a pointer to the action string *I 
15 int anchor; /* Says whether pattern is anchored and, if *I 
16 /* so, where (uses #defines above). *I 
17 NFA; 
18 
19 #define EPSILON -1 /* Non-character values of NFA.edge *I 
20 #define CCL -2 
21 #define EMPTY -3 
22 
23 /* Values of the anchor field: *I 
24 #define NONE 0 /* Not anchored *I 
25 #define START 1 /* Anchored at start of line *I 
26 #define END 2 /* Anchored at end of line *I 
27 #define BOTH ( START I END ) /* Anchored in both places *I 
The accept field in the NFA structure is NULL for nonaccepting states; otherwise, it Storing accepting strings, 
points at a string holding the action part of the original input rule-the code to be exe-accept. 
cuted when that state is accepted. The string itself is of variable length. The first int 's 
worth of characters hold the line number and the remainder of the array holds the string. 
For example, in a machine with a 16-bit int, the first two bytes of the string are the 
line number (in binary) and the remainder of the string is the actual input text. The 
pointer to the actual string is stored. 
saved pointer 
input line number accepting string 
sizeof(int) 
86 
The anchor field. 
NFA_MAX, STR MAX Input and Lexical Analysis -Chapter 2 
Ifp is a pointer to an NFA structure, the actual string is accessed with p->accept, and 
the line number can be accessed by casting accept into a pointer to int and backing up 
one notch-like this: 
( (int*) ( p->accept ) ) [ -1] 
Because of various alignment problems, some care has to be taken to integrate the line 
number into the string in this fashion-the mechanics are discussed shortly. The tech­
nique is useful, not only in the current application, but also for doing things like attach­
ing a precomputed string length to a string. The string can still be handled in the normal 
way, but the count is there when you need it. 
The macros on lines 24 to 27 of Listing 2.20 are possible values of the anchor field. 
They describe whether a ~, $,or both were present in the regular expression. 
The reminder of nfa.h, in Listing 2.21, holds other definitions needed to make the 
machine. NFA _MAX is the maximum number of NFA states that can be in the machine, 
and STR _MAX is the total space available for all the accepting actions combined. The 
rest of the file is just prototypes for the externally-accessible functions discussed below. 
Listing 2.21. nfa.h-Other Definitions and Prototypes 
28 #define 
29 
30 
31 #define 
32 
33 
34 void 
35 void 
36 NFA 
37 void 
Global-variable 
definitions: globals.h 
CLASS and I (X) 
macros, ALLOC. NFA MAX 768 /* Maximum number of NFA states in a *I 
/* single machine. NFA MAX * sizeof (NFA) *I 
/* can't exceed 64K. *I 
STR MAX (10 * 1024) /* Total space that can be used by the *I 
/* accept strings. *I 
new_macro( char *definition ) ; /* these three are in nfa.c *I 
printmacs( void ) ; 
*thompson( char *(*input funct) (), int *max state, NFA **start state); 
print_ nfa( NFA *nfa, int len, NFA *start ) ; /* in printnfa.c */ 
The other file you need to look at before starting is globals.h, in Listing 2.22. This 
file holds definitions for all the true global variables in the program (globals that are 
shared between modules). All other globals are declared static, so their scope is lim­
ited to the file in which they are declared. For maintenance reasons, it's desirable that 
both the definition and declaration of a variable be in a single file. That way you don't 
have to worry about maintaining two files, one in which space is allocated and the other 
containing extern statements describing the variables. The problem is solved in 
globals.h using the CLASS and I (x) macros defined on lines three to seven of Listing 
2.22. The following two lines are found in only one file [typically in the same file that 
contains main () ]: 
#define ALLOC 
#include "globals.h" 
All other files include globals.h without the previous ALLOC definition. When ALLOC 
exists, CLASS evaluates to an empty string and I (x) evaluates to its argument. So, the 
input line: 
CLASS char *Template I(="lex.par"); 
expands to 
char *Template ="lex.par"; 
If ALLOC doesn't exist, then CLASS expands to extern and I (x) expands to an empty 
string. The earlier input line expands to: 
Section 2.5.2-Implementing Thompson's Construction 
extern char *Template; 
The variables on lines II to I5 of globals.h are set by command-line switches; the ones 
on lines I6 to 22 are used by the input routines to communicate with one another. 
Listing 2.22. globals.h- Global-Variable Definitions 
I 
2 
3 
4 
5 
6 
7 
8 
9 I* GLOBALS.H: Global variables shared between modules *I 
#ifdef ALLOC 
# define CLASS 
# define I(x) x 
#else 
# 
# 
#endif define CLASS extern 
define I (x) 
#define MAXINP 2048 I* Maximum rule size *I 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 CLASS int Verbose I ( 0 ) ; I* Print statistics *I 
CLASS int No lines 
CLASS int Unix I ( 0 ) ; I* Suppress #line directives *I 
I ( 0 ) ; I* Use UNIX-style newlines *I 
CLASS int Public I ( 0 ) ; I* Make static symbols public *I 
CLASS char *Template 
CLASS int Actual lineno 
CLASS int Lineno I(="lex.par"); 
I ( 1 ) ; 
I ( = 1 ) ; I* State-machine driver template *I 
I* Current input line number *I 
I* Line number of first line of *I 
I* a multiple-line rule. *I 
CLASS char Input_buf[MAXINP]; 
CLASS char *Input file_name; 
CLASS FILE *Ifile; I* Line buffer for input *I 
I* Input file name (for #line) *I 
I* Input stream. *I 
CLASS FILE *Ofile; I* Output stream. *I 
#undef CLASS 
#undef I 
2.5.2.2 A Regular-Expression Grammar. The code in nfa. c, which starts in List­
ing 2.23, reads a regular expression and converts it to an NFA using Thompson's con­
struction. The file is really a small compiler, comprising a lexical analyzer, parser, and 
code generator (though in this case, the generated code is a state-machine description, 
not assembly language). The grammar used to recognize a LEX input specification is 
summarized in Table 2.5. This is an informal grammar-it describes the input syntax in 
a general sort of way. Clarity is more important here than strict accuracy. I'll fudge a 
bit in the implementation in order to get the grammar to work. Precedence and associa­
tivity are built into the grammar (the mechanics are described in depth in the next 
chapter). Concatenation is higher precedence than I; closure is higher precedence still; 
everything associates left to right. The various left-recursive productions have not yet 
been translated into an acceptable form, as was discussed in Chapter One-I'll do that as 
I implement them. 
2.5.2.3 File Header. The header portion of nfa.c is in Listing 2.23. The ENTER and 
LEAVE macros on lines 2I to 28 are for debugging. They expand to empty strings when 
DEBUG is not defined. When debugging, they print the current subroutine name (which is 
passed in as an argument), the current lexeme and what's left of the current input line. 
An ENTER invocation is placed at the top of every subroutine of interest, and a LEAVE 
macro is put at the bottom. The text is indented by an amount proportional to the 
subroutine-nesting level-Lev is incremented by every ENTER invocation, and decre­
mented by every LEAVE. Levx4 spaces are printed to the left of every string using the 
printf () s * field-width capability. To simplify, the following printf () statement Debugging: ENTER, 
LEAVE. 87 
88 Input and Lexical Analysis -Chapter 2 
Table 2.5. A Grammar for U'X 
machine 
rule 
action 
expr 
cat_expr 
factor 
term 
white _space 
character 
string 
Error messages: 
Errmsgs, 
parse_err (). 
ManagingNFA structures. 
new(), discard(). 
Stack strategy, 
Nfa _states [ ]. Productions Notes 
~ 
I 
~ 
I 
I 
~ 
I 
I 
~ 
I 
~ 
I 
~ 
I I 
I 
~ 
I 
I 
I I I I 
~ 
~ 
~ rule machine A list of rules 
rule END OF INPUT 
expr EOS -action A single regular expression followed by an accepting action. 
A expr EOS action Expression anchored to start of line. 
expr $ EOS action Expression anchored to end of line. 
white _space string An optional accepting action. 
white _space 
e 
expr I cat_expr A list of expressions delimited by vertical bars. 
cat_expr 
cat_ expr factor A list of concatenated expressions. 
factor 
term* A subexpression followed by a *. 
term+ A subexpression followed by a+. 
term? A subexpression followed by a ?. 
term 
[ string] A character class. r string] A negative character class. 
[ ] (nonstandard) Matches white space. 
n (nonstandard) Matches everything but white space. 
Matches any character except newline. 
character A single character. 
( expr) A parenthesized subexpression. 
one or more tabs or spaces 
any single ASCII character except white_space 
one or more ASCII characters 
outputs Lev spaces by printing an empty string in a field whose width is controlled by 
Lev. 
printf( 11%*s11, Lev, 1111 ); 
2.5.2.4 Error-Message Processing. The next part of nfa.c is the error-message 
routines in Listing 2.24. I've borrowed the method used by the C buffered 1/0 system: 
possible error codes are defined in the enumerated type on lines 35 to 51, and a global 
variable is set to one of these values when an error occurs. The Errmsgs array on lines 
53 to 68 is indexed by error code and evaluates to an appropriate error message. Finally, 
the parse_ err ( ) subroutine on line 70 is passed an error code and prints an appropri­
ate message. The while loop on line 76 tries to highlight the point at which the error 
occurred with a string like this: 
The up arrow will (hopefully) be close to the point of error. parse_ err ( ) does not 
return. 
2.5.2.5 Memory Management. Listing 2.25 contains the memory-management rou­
tines that allocate and free the NFA structures used for the states. Two routines are used 
for this purpose: new ( ) , on line 105, allocates a new node and discard ( ) , on line 
131, frees the node. I'm not using malloc ( ) and free () because they're too slow; 
rather, a large array (pointed to by Nfa _states) is allocated the first time new ( ) is 
called (on line 112-the entire if statement is executed only once, during the first call). 
A simple stack strategy is used for memory management: discard ( ) pushes a 
pointer to the discarded node onto a stack, and new ( ) uses a node from the stack if one 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.23. nfa.c-File Header 
1 
2 
3 
4 
5 
6 
7 
8 
9 I* NFA.C---Make an NFA from a LeX input file using Thompson's construction *I 
#include <stdio.h> 
#ifdef MSDOS 
# include <stdlib.h> 
#else 
# include <malloc.h> 
#endif 
#include <ctype.h> 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 #include <string.h> 
#include <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslhash.h> 
#include <toolslcompiler.h> 
#include <toolslstack.h> 
#include "nfa.h" 
#include "globals.h" I* defines for NFA, EPSILON, CCL *I 
I* externs for Verbose, etc. *I 
#ifdef DEBUG 
int Lev = 0; 
# define ENTER(f) printf("%*senter %s [%c] [%1.10s] \n", 
Lev++ * 4, 1111 , f, Lexeme, \ 
Input) 
\ 
Input) # define LEAVE(f) printf("%*sleave %s [%c] [%1.10s] \n", 
--Lev * 4, .... f, Lexeme, , 
#else 
# define ENTER (f) 
# define LEAVE(f) 
#endif 
is available, otherwise it gets a new node from the Nfa_states [] array (on line 124). 
new ( ) prints an error message and terminates the program if it can't get the node. The 
new node is initialized with NULL pointers [the memory is actually cleared in dis­
card () with the memset () call on line 136] and the edge field is set to EPSILON on 
line 125. The stack pointer (Sp) is initialized at run time on line 116 because of a bug in 
the Microsoft C compact model that's discussed in Appendix A. edge initialized to 
EPSILON. 89 
There's an added advantage to the memory-management strategy used here. It's con­
venient when constructing the NFA to create a physical machine with one node per state 
and actual pointers to the next state. Later on, it will be convenient to have the NFA 
represented as an array because you can use the array index as the state number. The 
stack gives you both representations in a single data structure. The only disadvantage is 
that any nodes that are still on the stack when the NFA construction is complete will be 
holes in the array. It turns out that there is at most one hole, but there's no way to know 
in advance where it's going to be. The same data objects 
form both an array and a 
graph. 
The other memory-management function in nfa.c is the string-management function, 
save ( ) , also in Listing 2.25. This function is passed a pointer to a string, and returns a 
pointer to a copy-in static memory--of that string. The pointer is preceded in memory 
by an int-sized line number, as was discussed earlier on page 85. The array pointer 
(Strings, on line 100) is declared as a pointer to int for portability reasons. Many 
machines require ints to be aligned at more restrictive addresses than chars. For 
example, an int might have to be at an address that is an even multiple of four, but a 
char could be at any address. A run-time error would happen if you tried to put an int 
into an illegal address (one that was not an even multiple of four). Making Strings an String management: 
save(). 
Alignment problems 
caused by leading line 
number in string. 
90 Input and Lexical Analysis -Chapter 2 
Listing 2.24. nfa.c-Error-Processing Routines 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 55 56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 1*----------------------------------------------------------------
* Error processing stuff. Note that all errors are fatal. *----------------------------------------------------------------
*I 
typedef enum err num 
{ 
E_MEM, 
E_BADEXPR, 
E_PAREN, 
E_STACK, 
E_LENGTH, 
E_BRACKET, 
E_BOL, 
E_CLOSE, 
E_STRINGS, 
E_NEWLINE, 
E_BADMAC, 
E_NOMAC, 
E MACDEPTH 
ERR_NUM; I* Out of memory 
I* Malformed regular expression 
I* Missing close parenthesis 
I* Internal error: Discard stack full 
I* Too many regular expressions 
I* Missing [ in character class 
I* · must be at start of expr or eel 
I* + ? or * must follow expression 
I* Too many characters in accept actions 
I* Newline in quoted string 
I* Missing } in macro expansion 
I* Macro doesn't exist 
I* Macro expansions nested too deeply. 
PRIVATE char 
{ *Errmsgs[] I* Indexed by ERR NUM *I 
"Not enough memory for NFA", 
"Malformed regular expression", 
"Missing close parenthesis", 
"Internal error: Discard stack full", 
"Too many regular expressions or expression too long", 
"Missing [ in character class", 
.,. must be at start of expression or after [", 
"+ ? or * must follow an expression or subexpression", 
"Too many characters in accept actions", *I 
*I 
*I *I *I 
*I 
*I *I 
*I 
*I 
*I 
*I 
*I 
"Newline in quoted string, use \\n to get newline into expression", 
"Missing ) in macro expansion", 
"Macro doesn't exist", 
"Macro expansions nested too deeply" 
) ; 
PRIVATE void 
ERR NUM type; 
{ parse_err( type ) 
fprintf(stderr, "ERROR (line %d) %s\n%s\n", Actual_lineno, 
while( ++S_input <= Input ) 
putc('_', stderr); 
fprintf( stderr, n•\n" ) ; 
exit( 1 ); Errmsgs[ (int)type], S_input); 
Section 2.5.2-Implementing Thompson's Construction 
int pointer takes care of the alignment problem at the cost of a little wasted space-the 
size of the region used to store the string itself must be rounded up to an even multiple of 
the int size. I'm assuming that a char will have less restrictive alignment rules than an 
int-a pretty safe assumption. 91 
A single large array that will hold all the strings is allocated the first time save() is 
called on line 155 of Listing 2.25, thereby avoiding multiple inefficient malloc () calls 
every time a new string is required. The line number is put into the string on line 164, 
the pointer is incremented past the number, and the string itself is copied by the loop on 
line 166. A char pointer (textp) is used for the purpose of copying the string com­
ponent. The test on line 161 is for lines starting with a vertical bar, which say that the 
action for the next line should be used for the current rule. No strings are copied in this 
situation-the same pointer is returned here as will be returned by the next save () call. 
That is, when the input string is a " 1 ", several pointers to the same accepting string are 
returned by consecutive save () calls. A pointer to the string itself (as compared to the 
line number) is returned on line 182 in order to facilitate debugging-this way you can 
examine the string directly without having to skip past the line number. The line number 
can be accessed later on, using an expression like the following: Getting the line number 
from the left of the string. 
char *str = save("string"); 
line number = ( (int *)str) [-1]; 
Listing 2.25. nfa.c-Memory Management-States and String 
PRIVATE NFA *Nfa states /* State-machine array 
PRIVATE int Nstates = 0 /* # of NFA states in machine 82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 PRIVATE int Next_alloc; /* Index of next element of the array 
100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
Ill 
112 
113 
114 #define SSIZE 32 
PRIVATE NFA *Sstack[ SSIZE l ; /* Stack used by new() 
PRIVATE NFA **Sp &Sstack[ -1 l ; /* Stack pointer 
#define STACK _OK() INBOUNDS(Sstack, Sp) ) /* true if stack not 
/* full or empty 
#define STACK_ USED () (Sp-Stack) + 1 /* slots used 
#define CLEAR_STACK () Sp = Sstack -1 /* reset the stack 
#define PUSH(x) *++Sp = (x) /* put X on stack 
#define POP() *Sp-- /* get x from stack 
/*--------------------------------------------------------------*/ 
PRIVATE int *Strings; 
PRIVATE int *Savep; /* Place to save accepting strings 
/* Current position in Strings array. 
/*--------------------------------------------------------------*/ 
PRIVATE NFA *new() 
{ 
NFA *p; 
static int first time 1; 
if( first_time ) 
{ /* NFA management functions */ 
if( ! ( Nfa_states = (NFA *) calloc(NFA_MAX, sizeof(NFA)) )) 
parse_err( E MEM ); *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I *I 
*I 
*I 
*I 
*I 
92 Input and Lexical Analysis -Chapter 2 
Listing 2.25. continued ••• 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 first_time = 0; 
Sp = &Sstack[ -1 ]; 
if( ++Nstates >= NFA_MAX ) 
parse_err( E LENGTH); 
/* If the stack is not ok, it's empty */ 
p = !STACK_OK() ? &Nfa_states[Next_alloc++] 
p->edge = EPSILON; 
return p; POP(); 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void discard( nfa to discard 
NFA *nfa to_discard; 
{ 
--Nstates; 
memset( nfa_to_discard, 0, sizeof(NFA) ); 
nfa_to_discard->edge = EMPTY 
PUSH( nfa_to_discard ); 
if( !STACK_OK() ) 
parse_err( E STACK); 
/*----------------------------------------------------------------------*/ 
PRIVATE char *save ( str ) /* String-management function. */ 
char 
char 
int *str; 
*textp, *startp; 
len; 
static int first time = 1; 
if( first_time ) 
{ 
if( ! (Savep =Strings= (int *) malloc( STR MAX)) ) 
parse_err( E_MEM ); 
first time = 0; 
if( *str =='I') 
return (char*) ( Savep + 1 ); 
*Savep++ = Lineno; 
for( textp = (char *)Savep ; *str *textp++ = *str++ 
if( textp >= (char*) (Strings+ (STR_MAX-1)) ) 
parse_err( E STRINGS ) ; 
*textp++ = '\0' ; 
/* Increment Savep past the text. "len" is initialized to the string length. 
* The "len/sizeof(int)" truncates the size down to an even multiple of the 
* current int size. The "+(len % sizeof(int) != 0)" adds 1 to the truncated .... 
Section 2.5.2-Imp1ementing Thompson's Construction 
Listing 2.25. continued ••. 
175 * size if the string length isn't an even multiple of the int size (the != 
176 *operator evaluates to 1 or 0). Return a pointer to the string itself. 
177 *I 
178 
179 startp (char *) Savep; 
180 len textp -startp; 
181 Savep += (len I sizeof(int)) + (len% sizeof(int) != 0); 
182 return startp; 
183 
2.5.2.6 Macro Support. The next code segment (in Listing 2.26) comprises the 
macro-support routines. new_macro () (on line 202) is passed a pointer to a line that 
contains a macro definition and it files the macro in a small symbol table. The 
expand_ macro (char * *namep) routine on line 264 is passed a pointer to a charac­
ter pointer, which in tum points at a macro invocation. The routine advances *namep 
past the invocation, and returns a string holding the macro's contents. The print­
macs ( ) subroutine on line 300 of Listing 2.26 prints the macros. The various hash rou­
tines and the HASH_ TAB structure that are used here are discussed in Appendix A. 
Listing 2.26. nfa.c-Macro Support Macro substitution: 
new_macro (), 
expand_ macro () . 
printmacs () 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 1*--------------------------------------------------------------
* MACRO support: 
*I 
#define MAC NAME MAX 3 4 
#define MAC TEXT MAX 80 I* Maximum name length *I 
I* Maximum amount of expansion text *I 
typedef struct 
{ 
char name [ MAC NAME MAX ] ; 
char text[ MAC TEXT MAX ]; 
MACRO; 
PRIVATE HASH_TAB *Macros; I* Symbol table for macro definitions *I 
l*------------------------------------------------------------*1 
PUBLIC void new_macro( def ) 
char *def; 
I* Add a new macro to the table. If two macros have the same name, the 
* second one takes precedence. A definition takes the form: 
* name <whitespace> text [<whitespace>} 
* whitespace at the end of the line is ignored. 
*I 
unsigned hash_add(); 
char *name; 
char *text; 
char *edef; 
MACRO *p; 
static int first time 1; I* Name component of macro definition 
I* text part of macro definition 
I* pointer to end of text part *I 
*I 
*I 93 
94 Input and Lexical Analysis -Chapter 2 
Listing 2.26. continued ... 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 if( first time 
{ 
first_time 0; 
Macros= maketab( 31, hash_add, strcmp ); 
for( name= def; *def && !isspace(*def) def++ ) /* Isolate name */ 
if ( *def ) 
*def++ = '\0' ; 
/* Isolate the definition text. This process is complicated because you need 
* to discard any trailing whitespace on the line. The first while loop 
* skips the preceding whitespace. The for loop is looking for end of 
* string. If you find a white character (and the \n at the end of string 
* is white), remember the position as a potential end of string. 
*I 
while( isspace( *def ) ) 
++def; /* skip up to macro body *I 
text def; /* Remember start of replacement text */ 
edef 
while ( 
{ NULL; 
*def 
if ( ! is space (*de f) 
++def; 
else /* strip trailing white space 
for(edef def++; isspace(*def) ++def ) 
if( edef ) 
*edef = '\0'; */ 
/* Add the macro to the symbol table */ 
p = (MACRO*) newsym( sizeof(MACRO) ); 
strncpy( p->name, name, MAC NAME MAX); 
strncpy( p->text, text, MAC TEXT MAX); 
addsym( Macros, p ); 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE char *expand_macro( namep 
char 
{ **namep; 
/* Return a pointer to the contents of a macro having the indicated 
* name. Abort with a message if no macro exists. The macro name includes 
* the brackets, which are destroyed by the expansion process. *namep 
* is modified to point past the close brace. 
*I 
char *p; 
MACRO *mac; 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.26. continued ... 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 if( !(p = strchr( ++(*namep), '}'))) 
parse_err( E BADMAC ); /* skip { and find } */ 
/* print msg & abort */ 
else 
( 
*p++ = , \0'; /* Overwrite close brace. */ 
if( ! (mac= (MACRO*) findsym( Macros, *namep )) ) 
parse_err( E NOMAC ); 
*namep = p ; 
return mac->text; /* Update name pointer. *I 
return "ERROR"; /* If you get here, it's a bug */ 
/* - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE print_a_macro( mac 
MACRO 
{ *mac; /* Workhorse function needed by */ 
/* ptab() call in printmacs(), below*/ 
printf( "%-16s--[%s]--\n", mac->name, mac->text ); 
PUBLIC void printmacs() 
{ /* Print all the macros to stdout */ 
if ( ! Macros ) 
printf("\tThere are no macros\n"); 
else 
printf("\nMACROS:\n"); 
ptab( Macros, print_a_macro, NULL, 1 ); 
2.5.2.7 LEX's Lexical Analyzer. The lowest-level input functions are in input.c, 
Listing 2.27. get_ expr ( ) on line eight is the actual input function. It gets an entire 
rule-both the regular expression and any following code-from the input file (pointed 
to by !file) and puts it into Input _buf [ ]. Multiple-line rules are handled here in 
that lines that start with white space are concatenated to the previous line. Two line­
number variables are modified in this routine. They are Lineno, which holds the input 
line number of the first line of the rule, and Actual_lineno, which holds the current 
input line number. get_ expr () normally returns a pointer to the input string (in 
Input _buf [] ). It returns NULL either at end of file or when a line starting with a%% is 
encountered. Since %% is treated as an end of file, the third part of the input file, which 
contains C source code that is passed directly to the output, is ignored by the parser. get_expr () 
Input buffers: Ifile, 
Input_buffer. 
Multiple-line actions: 
Line no, 
Actual lineno. 
I.!'X's lexical analyzer. 95 
Listing 2.28 holds the lexical analyzer itself. The token set is defined in the 
enumerated type on lines 310 to 330. The L token (L for literal) is used for all characters 
that aren't represented by explicitly defined tokens. Escaped characters and characters 
within quoted strings are also returned as L tokens, even if the lexeme would normally 
be an explicit token. The EOS token is returned at end of the regular expression, but the 
input buffer holds the entire rule, including a multiple-line accepting action. The parser 
uses this fact to pick up the accepting action when an EOS is encountered. Note that end 
of input is also treated as a token. Literal characters: the L 
token, EOS. 
96 Input and Lexical Analysis -Chapter 2 
Listing 2.27. input.c- Low-Level Input Functions 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 #include <stdio.h> 
#include <ctype.h> 
#include <toolsldebug.h> 
#include "globals.h" 
I* INPUT.C 
PUBLIC char 
{ Lowest-level input functions. *I 
*get_expr () 
I* Input routine for nfa(). Gets a regular expression and the associated 
* string from the input stream. Returns a pointer to the input string 
* normally. Returns NULL on end of file or if a line beginning with % is 
* encountered. All blank lines are discarded and all lines that start with 
* whitespace are concatenated to the previous line. The global variable 
* Lineno is set to the line number of the top line of a multiple-line 
* block. Actual lineno holds the real line number. 
*I 
static int lookahead = 0; 
int space_left; 
char *p; 
p = Input_buf; 
space_left = MAXINP; 
if( Verbose > 1 ) 
printf( "b%d: ", Actual lineno ); 
if( lookahead == '%' 
return NULL; I* next line starts with a % sign 
I* return End-of-input marker 
Lineno = Actual lineno 
while( (lookahead = getline(&p, space_left-1, Ifile)) != EOF) 
{ 
if( lookahead == 0 ) 
lerror(l, "Rule too long\n"); 
Actual lineno++; 
if ( ! Input_buf [0] 
continue; 
space_left = MAXINP- {p-Input_buf); 
if( !isspace(lookahead) 
break; 
*p++ = '\n' 
if( Verbose > 1 ) 
printf( "%s\n", lookahead ? Input_buf 
return lookahead ? Input_buf : NULL ; I* Ignore blank lines *I 
"--EOF--" ); *I 
*I 
1*----------------------------------------------------------------------*l 
.... 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.27. continued ... 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 88 
89 
90 
91 
92 
93 
94 
95 
96 PRIVATE int getline( stringp, n, stream) 
char **stringp; 
FILE *stream; 
{ 
I* Gets a line of input. Gets at most n-1 characters. Updates *stringp 
*to point at the '\0' at the end of the string. Return a lookahead 
*character (the character that follows the \n in the input). The '\n' 
* is not put into the string. 
* * Return the character following the \n normally, 
* EOF at end of file, 
* 0 if the line is too long. 
*I 
static int lookahead = 0; 
char *str, *startstr; 
startstr str = *stringp; 
if( lookahead 0 ) 
lookahead = getc( stream); 
if( n > 0 && lookahead != EOF ) 
{ 
while( --n > 0 ) 
{ 
*str 
lookahead lookahead 
getc (stream); 
if ( *str == '\n' I I *str == EOF ) 
break; 
++str; 
*str 
*stringp '\0'; 
str ; 
return (n <= 0) ? 0 : lookahead I* initialize *I 
Listing 2.28. nfa.c-IJX's own Lexical Analyzer 
310 typedef enum token 
311 { 
312 EOS = 1, I* end of string *I 
313 ANY, I* *I 
314 AT_BOL, I* *I 
315 AT_EOL, I* $ *I 
316 CCL_END, I* 1 *I 
317 CCL_START, I* [ *I 
318 CLOSE_CURLY, I* } *I 
319 CLOSE_PAREN, I* ) *I 
320 CLOSURE, I* * *I 
321 DASH, I* *I 
322 END_OF_INPUT, I* EOF *I 
323 L, I* literal character *I 
324 OPEN_CURLY, I* { *I 
325 OPEN_PAREN, I* ( *I 97 
.... 
98 Input and Lexical Analysis -Chapter 2 
Listing 2.28. continued ... 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 OPTIONAL, 
OR, 
PLUS CLOSE 
TOKEN; 
PRIVATE TOKEN 
{ I* ? 
I* 
I* + 
Tokmap[] = *I 
*I 
*I 
I* A@ AA AB Ac AD AE AF AG AH AI AJ AK AL AM AN *I 
L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* Ao AP AQ AR As AT Au Av Aw Ax AY Az Ar A\ Al *I 
L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* SPACE # $ % & *I 
L, L, L, L, L, L, AT_ EOL, L, L, L, 
I* * + *I 
OPEN_PAREN, CLOSE_PAREN, CLOSURE, PLUS_CLOSE, L, DASH, ANY, 
I* I 0 1 2 3 4 5 6 7 8 9 ; < 
L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* > 
L, 
I* @ A B ? 
OPTIONAL, 
c D E F G H I J K L M N 
L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* 0 p Q R s T u v w X y z 
L, L, L, L, L, L, L, L, L, L, L, L, 
I* [ 
CCL_START, L, 
I* a b c 1 
CCL_END, 
d e AT_BOL, 
f g h i j k 1 m 
L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* n 0 p q r s t u v w X y z 
L, L, L, L, L, L, L, L, L, L, L, L, L, 
I* DEL 
OPEN_CURLY, OR, CLOSE_CURLY, L 
} ; 
I* Input function pointer *I 
*I 
*I *I 
*I 
*I 
*I 
*I 
PRIVATE char *(*Ifunct) () 
PRIVATE char *Input = 1111 
PRIVATE char *S_input 
PRIVATE TOKEN Current tok I* Current position in input 
I* Beginning of input string 
I* Current token *I 
string *I 
*I 
*I 
PRIVATE int Lex erne I* Value associated with LITERAL *I 
#define MATCH(t) (Current_tok (t)) 
1*----------------------------------------------------------------
* Lexical analyzer: 
* 
* Lexical analysis is trivial because all lexemes are single-character values. 
* The only complications are escape sequences and quoted strings, both 
*of which are handled by advance(), below. This routine advances past the 
* current token, putting the new token into Current tok and the equivalent .... 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.28. continued ... 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 * lexeme into Lexeme. If the character was escaped, Lexeme holds the actual 
* value. For example, if a "Is" is encountered, Lexeme will hold a space 
* character. The MATCH(x) macro returns true if x matches the current token. 
*Advance both modifies Current tok to the current token and returns it. 
*I 
PRIVATE int advance() 
{ 
static int inquote = 0; 
int saw_esc; 
static char *stack[ SSIZE ], 
**sp = NULL; 
if( !sp ) 
sp = stack -1; 
if( Current tok EOS 
{ 
if( inquote 
do 
{ parse_err( E NEWLINE); I* 
I* 
I* 
I* 
I* 
I* 
I* Processing quoted string *I 
Saw a backslash *I 
Input-source stack *I 
and stack pointer. *I 
Initialize sp. *I 
Necessary for large model *I 
Get another line *I 
if ( ! (Input = (*Ifunct) ()) ) 
{ I* End of file *I 
Current tok 
goto exit; END_OF_INPUT; 
while( isspace( *Input ) ) 
Input++; 
while !*Input ); 
S input Input; 
while( *Input == '\0' ) 
{ 
if( INBOUNDS(stack, sp) ) 
{ 
Input = *sp-­
continue; 
Current_tok = EOS; 
Lexeme = '\0'; 
goto exit; 
if ( ! inquote ) 
{ 
while( *Input == '{' 
{ 
*++sp 
Input Input ; 
expand_macro( sp ); 
if( TOOHIGH(stack,sp) 
parse_err(E_MACDEPTH); I* Ignore leading *I 
I* white space ... *I 
I* and blank lines. *I 
I* Remember start of line *I 
I* for error messages. *I 
I* Restore previous input source *I 
I* No more input sources to restore *I 
I* ie. you're at the real end of *I 
I* string. *I 
I* Macro expansion required }*I 
I* Stack current input string *I 
I* and replace it with the macro *I 
I* body. *I 
I* Stack overflow *I 99 
.... 
100 Input and Lexical Analysis -Chapter 2 
Listing 2.28. continued ••• 
if( *Input 
{ '"' ) 
inquote = -inquote; 
if ( ! *++Input ) 
{ 
Current tok = EOS 
Lexeme = 1\01; 
goto exit; 
saw_esc = (*Input I\\ I); 
if ( ! inquote ) 
{ 
else 
{ if( isspace(*Input) 
{ 
Current tok = EOS 
Lexeme = 1\01; 
goto exit; 
Lex erne esc( &Input); 
if( saw_esc && Input[l] 
{ 
else Input += 2; 
Lexeme 1"1; 
Lex erne *Input++ I* At either start and end of a quoted 
I* string. All characters are treated 
I* literals while inquote is true). 
'"' ) as *I 
*I 
*I 446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 Current_tok = (inquote I I saw_esc) ? L 
exit: Tokmap[Lexeme] 
return Current_tok; 
Ifunct, Input, 
S_input,Current_tok, 
Lex erne 
MATCH(t) 
advance() The translation problem is simplified by the fact that all lexemes are single charac­
ters. ( [~,which starts a negative character class, is treated as a CCL_START/AT_BOL 
pair). The Tokmap [) array on lines 332 to 369 is used to translate these single­
character lexemes into tokens. It is indexed by ASCII character, and evaluates to the 
token value associated with that character. 
Various other variables are needed by the lexical analyzer, all declared on lines 371 
to 375 of Listing 2.28. I funct points at the current input function, which should work 
like gets ( ) , returning either the next input line or NULL at end of file. Input points at 
the current input line, and S_input is the current position on that line. Current_tok 
holds the current token, and Lexeme holds the associated lexeme (which is only needed 
for L tokens). The MATCH (t) macro on line 377 of Listing 2.29 evaluates true if t is the 
current lookahead token. 
The advance () function on lines 392 to 483 of Listing 2.28 advances the input by 
one character, modifying Current_ tok and Lexeme as appropriate, and also returning 
the current token. An END OF INPUT token is returned at end of file. This subroutine 
is probably the most complicated routine in the parser, and is also a little long for my 
taste, but it seemed best to keep the whole lexical analysis phase in a single subroutine 
Section 2.5.2-Implementing Thompson's Construction 
for maintenance reasons. A new line is fetched on lines 402 to 419 only if the end of the 
previous line has been reached (Current_ tok is EOS). 
Lines 421 to 444 of Listing 2.28 handle macro expansion. Macros are delimited by 
braces, and they are recognized in the while loop on line 436, which finds the leading 
brace. It's a loop because macro definitions might be nested-if the first character of the 
macro body is also an open brace, the loop will expand this inner macro as well as the 
current one. Nested macros are handled with a stack. When an inner macro is encoun-
tered, the current input buffer is pushed onto a stack, and Input is modified to point at 
the macro-replacement text. The loop on line 421 is activated when you get to the end of 
the replacement text. The previous input string is restored at the top of the loop by pop-
ping it off the stack. The code on lines 429 to 431 is activated only if the stack is empty 
and no more characters are found in the current input source, in which case end of string 
has been reached. The qoto statement on line 431 is functioning as a return statement 
here. I generally shun multiple return statements in favor of multiple qoto branches 
to a label that precedes a single return statement. This way, the subroutine has only a 
single exit point so it's easier to set up breakpoints and debugging diagnostics. 101 
Macro expansion. 
Quotes are recognized on line 446, and inquote is set to true when processing a 
quoted string. Similarly, saw_ escape is set to true on line 457 when a backslash is 
encountered. The clause on lines 461 to 467 handles normal text. EOS, which marks Quotes in regular expres-
the end of the regular expression, is returned if any white space is encountered, and 
escape sequences are expanded by the esc ( ) call on line 467. The following else 
clause handles quoted strings. The test on line 471 is looking for a ", which must be 
treated as a literal quote mark. All other characters, including white space, are con-
sidered to be part of the regular expression and are just returned in the normal way. 
Finally, the current token is put into Current_tok on line 480. If you're in a quoted 
string or if the current character is preceded by a backslash, then the current character is 
treated literally and an L token is returned; otherwise, the character is translated to a 
token by looking it up in Tokmap [ ] . 
2.5.2.8 Parsing. LEX's parser begins in Listing 2.29. The prototypes at the top of the 
listing are necessary, both for debugging and because the parser itself is highly 
recursive-there is no way to arrange the subroutines to avoid all forward references. 
The parser is a straightforward implementation of the grammar presented earlier. The sions. 
topmost routine, machine ( ) on line 508 of Listing 2.29, collects a series of rules and machine () 
chains them together using E transitions and dummy states (as was pictured in Figure 2.9 
on page 82). The rule () calls on lines 516 and 522 return pointers to NFA's that rule() 
represent each regular expression on the input line. 
The rule ( ) subroutine on line 531 of Listing 2.29 gets a single regular expression 
and associated action. Most of the work is done by expr ( ) , called on lines 554 and expr () 
557. The routine is passed two pointers to NFA pointers. When expr ( ) returns, these 
two pointers will have been modified to point at the first and last nodes in the machine 
(there will be only one of each). That is, synthesized attributes are used here (and 
throughout the rest of the parser), but I can't use the actual return value (the argument to 
a return statement) because there are two attributes. Consequently, I'm passing 
pointers to variables to be modified. (Put another way, I'm doing a call by reference 
here-passing pointers to the object to be modified). 
Beginning- and end-of-line anchors are processed directly in rule () on lines 550 to Anchor processing. 
554 of Listing 2.29. An extra node is created with an outgoing transition on a newline so 
that the -is treated as if it were a regular expression that matched a newline. The 
anchor field is modified on line 552 to remember that this newline is there as the result 
of an anchor, as compared to a specific match of a \n. The newline has to be discarded 
in the former case; it remains in the lexeme if a specific match was requested, however. 
102 Input and Lexical Analysis -Chapter 2 
Listing 2.29. nfa.c-Parser, Part I: machine () and rule () 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 498 
499 
500 
501 
502 
503 
504 
505 
506 
507 
508 
509 
510 
511 
512 
513 
514 
515 
516 
517 518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
"530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 PRIVATE int advance void ) ; 
PRIVATE void cat _expr NFA**, NFA** ) ; 
PRIVATE void discard NFA* ) ; 
PRIVATE void dodash SET* ) ; 
PRIVATE void expr NFA**, NFA** ) ; 
PRIVATE void factor NFA**, NFA** ) ; 
PRIVATE int first in cat TOKEN ) ; 
PRIVATE NFA *machine void ) ; 
PRIVATE NFA *new void ) ; 
PRIVATE void parse_err ERR NUM ) ; 
PRIVATE NFA *rule void ) ; 
PRIVATE char *save char* ) ; 
PRIVATE void term NFA**, NFA** ) ; 
/*--------------------------------------------------------------
* The 
* 
* 
* 
* 
* 
* 
*I Parser: 
A simple recursive descent parser that creates a Thompson NFA for 
a regular expression. The access routine [thompson()} is at the 
bottom. The NFA is created as a directed graph, with each node 
containing pointer's to the next node. Since the structures are 
allocated from an array, the machine can also be considered 
as an array where the state number is the array index. 
PRIVATE NFA 
{ *machine() 
NFA *start; 
NFA *p; 
ENTER ("machine"); 
p = start 
p->next new(); 
rule() ; 
while( !MATCH(END_OF_INPUT) 
{ 
p->next2 
p 
p->next new(); 
p->next2; 
rule (); 
LEAVE ("machine"); 
return start; 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE NFA *rule() 
{ 
/* rule --> expr EOS action 
* expr EOS action 
* expr$ EOS action 
* 
* action --> <tabs> <string of characters> 
* epsilon 
*I 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.29. continued ... 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 NFA *p; 
NFA *start 
NFA *end 
int anchor NULL; 
NULL; 
NONE; 
ENTER("rule"); 
if( MATCH( AT BOL 
{ 
start 
start->edge 
anchor I= 
advance(); ) ) 
new() 
'\n' 
START 
expr( &start->next, 
else &end 
expr( &start, &end); 
if( MATCH( AT_EOL ) ) 
{ ) ; 
/* pattern followed by a carriage-return or linefeed (use a 
* character class) . 
*I 
advance(); 
end->next new() 
end->edge = CCL 
if( ! ( end->bitset newset()) 
parse_err( E_MEM ); 
ADD ( end->bitset, '\n' ) ; 
if( !Unix ) 
ADD( end->bitset, '\r' ) ; 
end 
anchor end->next 
1= END 
while( isspace(*Input) 
Input++ 
end->accept 
end->anchor 
advance(); 
LEAVE("rule"); 
return start; save ( Input ) ; 
anchor; 
/* skip past EOS */ 
This information is eventually output as a table that will be used by the LEX-generated 
driver when it processes the newline at run time. The end-of-line anchor is handled in a 
similar way on lines 566 to 579 of Listing 2.29, though the extra node is put at the end of 
the machine rather than at the beginning. 103 
104 Input and Lexical Analysis -Chapter 2 
Ms-oos, end-of-line prob­
lems in anchors. Anchors are recognized with a character class that matches either a carriage return or 
linefeed (as compared to a literal match of a' \n' character). You must recognize both 
characters in MS-DOS "binary-mode" input, because all input lines are terminated with a 
CR-LF pair (in that order). Lines are terminated by a single newline only in 
"translated" mode. Since I don't want to worry about which of the two input modes are 
used, I'm testing for both possibilities. When expr ( ) returns, the input is positioned at 
the start of the accepting action, which is saved on line 585 (remember, an entire 
multiple-line action is collected into the input string). 
OR and concatenation: 
expr (), cat_expr ()-Subroutines expr () and cat_expr () are in Listing 2.30. These routines handle the 
binary operations: I (OR) and concatenation. I'll show how expr ( ) works by watching 
it process the expression AlB. The cat_expr () call on line 621 creates a machine that 
recognizes the A: 
&-G 
*startp and *endp are modified to point at Nodes 0 and I, and the input is advanced 
to the OR operator. The MATCH on line 623 succeeds and the OR is skipped by the subse­
quent advance ( ) call. The second cat_ expr ( ) call (on line 625) creates a machine 
that recognizes the B: ~ 
and modifies e2_start and e2_end to point at nodes representing States 2 and 3. The 
two machines are then joined together to create the following machine: 
Node 4 is created on lines 628 to 630 and * startp is modified to point at Node 4 on 
line 631. Node 5 is set up in a similar way on the next four lines. 
Listing 2.30. nfa.c-Parser, Part 2: Binary Operators 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 PRIVATE void expr( startp, endp ) 
NFA **startp, **endp ; 
{ 
/* Because a recursive descent compiler can't handle left recursion, 
* the productions: 
* 
* 
* 
* expr -> expr OR cat_expr 
cat_expr 
* must be translated into: 
* 
* 
* 
* 
* expr 
expr' -> cat_expr expr' 
-> OR cat_expr expr' 
epsilon 
* which can be implemented with this loop: 
* 
* cat_expr .... 
Section 2.5.2-Imp1ementing Thompson's Construction 
Listing 2.30. continued ... 
* 
* 
* *I while( match(OR) ) 
cat_expr 
do the OR 
NFA *e2 start 
NFA *e2 end 
NFA *p; NULL; I* expression to right of I *I 
NULL; 
ENTER ( "expr"); 
cat_expr( startp, endp ); 
while( MATCH( OR ) ) 
{ 
advance(); 
cat_expr( &e2_start, &e2 end ) ; 
p = new (); 
p->next2 e2 start 
p->next *startp 
*startp p; 
p = new(); 
(*endp)->next p; 
e2 end ->next p; 
*endp = p; 
LEAVE("expr"); 
I* - - - - -
PRIVATE void cat_expr( startp, endp 
NFA **startp, **endp ; 
{ - - - - - - - - - - - - - -*1 105 
610 
611 
612 
613 
614 
615 
616 
617 
618 
619 
620 
621 
622 
623 
624 
625 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 638 
639 
640 
641 
642 
643 
644 
645 
646 
647 
648 
649 
650 
651 
652 
653 
654 
655 
656 
657 
658 
659 
660 
661 
662 
663 
664 
665 
666 
667 668 
669 I* The same translations that were needed in the expr rules are needed again 
* here: 
* 
* 
* 
* cat_expr -> cat_expr I factor 
factor 
* is translated to: 
* 
* 
* * 
*I cat_expr -> factor cat expr' 
cat_expr' -> I factor cat_expr' 
epsilon 
NFA *e2_start, *e2_end; 
ENTER("cat_expr"); 
if( first in_cat( Current tok) ) 
factor( startp, endp ) ; 
while( first_in_cat( Current_tok 
{ 
factor( &e2_start, &e2 end); 
.... 
106 Input and Lexical Analysis -Chapter 2 
Listing 2.30. continued ... 
670 
671 
672 
673 
674 
675 
676 
677 
678 
679 
680 
681 
682 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 memcpy( *endp, e2 start, sizeof(NFA)); 
discard( e2_start ) ; 
*endp = e2_end; 
LEAVE("cat_expr"); 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE int 
TOKEN tok; 
{ first_in_cat( tok ) 
switch( tok 
{ 
case CLOSE PAREN: 
case AT EOL: -case OR: 
case EOS: 
case CLOSURE: 
case PLUS CLOSE: 
case OPTIONAL: 
case CCL END: 
case AT BOL: 
return 1; return 0; 
parse_err( E CLOSE ) ; return 0; 
parse_err( E BRACKET); return 0; 
parse_err( E BOL ); return 0; 
Concatenation is a somewhat harder problem because there's no operator to look for. 
Problems with implicit 
concatenation operator, 
first_in_cat (). The problem is solved by first_in_cat () on line 681 of Listing 2.30, which looks to 
see if the next input token can reasonably be concatenated to the current one. That is, 
there is a set of tokens that can not just be concatenated-such as the parenthesis that 
terminates a parenthesized subexpression or an OR token-and the loop must terminate 
when one of these is encountered. These symbols are identified by the case statements 
on lines 686 to 689. The other cases test for obvious error conditions such as a close 
bracket (CCL_END) without a preceding open bracket or one of the closure operators 
without anything in front of it. 
Concatenation. Concatenation is performed in a manner similar to OR: The first operand is fetched 
with the factor () call on line 664 (which returns with *startp and *endp modified 
to point at the endpoints of a machine that recognizes the operand). The second and sub­
sequent operands are fetched by the factor ( ) call on line 668, and the two are con­
catenated by overwriting the contents of the end node of the first operand with the con­
tents of the starting node of the second operand (with the memcpy ( ) call on the next 
line). The now redundant start node of the second operand is then discarded. 
As an example of the process, if the input expression is D* \. D, the first factor ( ) 
call processes the D*, modifying * startp and *endp to point at nodes representing 
States 2 and 3 of the following machine: 
Section 2.5.2-Implementing Thompson's Construction 
The second call modifies e2 start and e2 _end to point at Nodes 4 and 5 of the fol­
lowing machine: 
They are concatenated together by ovt_!rwriting Node 3 with Node 4, yielding: 
E 
Node 3 is then discarded. The factor ( ) call in the next iteration of the loop modifies 
e2 _start and e2 _end to point at the ends of: ~ 
(The discarded Node 3 is picked up again here because it will be at the top of the push­
back stack.) This new machine is concatenated to the previous one by overwriting Node 
5 with the contents of Node 3. 
The unary closure operators are all handled by factor (), in Listing 2.31. It 
behaves just like the earlier routines, except that it builds a closure machine like the ones 
shown in Figure 2.12 on page 83. The code is simplified because the machines for+ and 
? are subsets of the one for *· The same number of extra nodes is created in all three 
situations. The backwards-pointing E edge is created only if a '*' or a '+' is being pro­
cessed; the forward-pointing edge is created only for a'*' or a'?'. 
Single-character matches and parenthesized subexpressions are handled by term ( ) , 
in Listing 2.32. The actual NFA structures are allocated and connected to each other on 
lines 761 and 762. The edge field is then initialized to the character or CCL, as appropri­
ate. A dot is treated as a character class that matches everything but a newline. Normal 
character classes are assembled by dodash ( ) 12 on line 811 of Listing 2.32. This rou­
tine converts the input tokens representing the class into a SET. A set can have one ele­
ment ( [ x) ) or several elements- [a-zA-z J and the following large character class are 
equivalent: 
[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] 
Note that the dash notation is expanded as sequential numbers. Since your machine 
probably uses the ASCII character set, this means that [A-z) contains the entire alpha­
bet plus the following symbols: 
12. Camptown ladies sing this song, dodash () , dodash (), Camptown race track five miles long ... 107 
Closure operators: fac­
tor(). 
Single characters and 
parenthesized subex­
pressions: term () . 
Character classes, do­
dash(). 
108 Input and Lexical Analysis -Chapter 2 
Listing 2.31. nfa.c-Parser, Part 3: Unary Operators (Closure) 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 
719 
720 
721 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 PRIVATE void factor( startp, endp ) 
NFA **startp, **endp; 
{ 
I* 
*I factor --> term* I term+ I term? 
NFA *start, *end; 
ENTER("factor"); 
term( startp, endp ); 
if( MATCH(CLOSURE) I I MATCH(PLUS_CLOSE) I I MATCH(OPTIONAL) ) 
{ 
start 
end new() 
new() 
start->next *startp 
(*endp)->next =end 
if( MATCH(CLOSURE) I I MATCH(OPTIONAL) 
start->next2 = end; 
if( MATCH(CLOSURE) I I MATCH(PLUS_CLOSE) 
(*endp)->next2 = *startp; 
*startp start 
*endp end 
advance(); 
LEAVE ("factor"); 
\ I* * or ? 
I* * or + *I 
*I 
You can get a dash into a character class with a\-, as in [_\-],which recognizes either 
a dash or an underscore. Note that the only metacharacters recognized as such in a char­
acter class are a ~ that immediately follows the bracket, a dash, and a close bracket (] ); 
so [ *? . ] recognizes a star, question mark, or dot. The " and { that trigger a macro 
expansion are also active in a character class, but they are handled by the input routines. 
You can use\] to get a] into a class: [ [ \ ]] recognizes either an open or close bracket. 
Listing 2.32. nfa.c-Parser, Part 4: Single Character Matches 
733 
734 
735 
736 
737 
738 
739 
740 
741 
742 
743 
744 PRIVATE void term( startp, endp ) 
NFA **startp, **endp; 
{ 
I* Process the term productions: 
* *term --> [ ... ] [] I (expr) I <character> 
* 
* The [] is nonstandard. It matches a space, tab, formfeed, or newline, 
* but not a carriage return (\r). All of these are single nodes in the 
* NFA. 
*I 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.32. continued ... 
NFA *start; 
int c; 
ENTER ("term") ; 
if( MATCH( OPEN_PAREN ) ) 
{ 
advance(); 
expr( startp 1 endp ); 
if( MATCH( CLOSE_PAREN ) ) 
advance(); 
else 
{ else 
parse err( E PAREN ); 
*startp 
*endp start 
start->next = new (); 
new(); 
if ( ! ( MATCH ( ANY ) I I MATCH ( CCL_START) ) ) 
{ 
else 
{ start->edge 
advance(); Lexeme; 
start->edge = CCL; 
if( ! ( start->bitset = newset()) 
parse_err( E MEM ); 
if( MATCH( ANY ) ) 
{ 
else 
{ ADD ( start->bitset 1 1 \n1 ) ; 
if ( ! Unix ) 
ADD( start->bitset 1 1\r1 ) ; 
COMPLEMENT( start->bitset ); 
advance(); I* dot (.) *I 
if( MATCH( AT BOL ) ) 
{ I* Negative character class *I 
advance(); 109 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 757 
758 
759 
760 
761 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
779 
780 
781 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 
796 797 
798 
799 
800 
801 
802 
803 
804 ADD( start->bitset 1 1\n1 ); I* Don't include \n in class *I 
if( !Unix ) 
ADD( start->bitset 1 1\r1 ); 
COMPLEMENT( start->bitset ) ; 
if( ! MATCH( CCL_END ) ) 
dodash( start->bitset ); 
else 
for ( c = 0; c <= 1 1 ; ++c 
ADD( start->bitset 1 c); 
advance(); I* *I 
.... 
110 Input and Lexical Analysis -Chapter 2 
Listing 2.32. continued ••• 
805 
806 
807 
808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 
827 
828 
829 
830 LEAVE("term"); 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void dodash( set ) 
SET 
{ *set; /* Pointer to eel character set */ 
register int first; 
for(; !MATCH( EOS ) && !MATCH( CCL END 
{ 
if ( ! MATCH ( DASH ) 
{ 
else 
{ first = Lexeme; 
ADD( set, Lexeme ); 
advance(); 
for(; first <= Lexeme ; first++ ) 
ADD ( set, first ) ; advance() ) 
The final workhorse function is printnfa ( ) , starting on line 57 of Listing 2.33, 
which is for debugging. It prints out the entire machine in human-readable form, show­
ing the various pointers, and so forth. 
Access routine: thomp­
son(). Nfa.c finishes up with a high-level access routine, thompson ( ) , in Listing 2.34. 
(Everything else was declared PRIVATE, so was inaccessible from outside the current 
file). It is passed a pointer to an input function, and it returns two things: a pointer to an 
array of NFA structures that represents the state machine and the size of that array (the 
number of states in use). 
Listing 2.33. printnfa.c- Print NFA to Standard Output 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 18 
19 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include "nfa.h" 
PRIVATE void 
PRIVATE char 
PUBLIC void printccl 
*plab 
print_nfa SET* ); 
NFA*, NFA* ) ; 
NFA*, int, NFA* ); 
/*--------------------------------------------------------------
* PRINTNFA.C Routine to print out a NFA structure in human-readable form. 
*I 
PRIVATE void printccl( set ) 
SET *set; 
{ 
static int i; .... 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.33. continued ... 
20 
21 putchar(' ['); 
22 for ( i = 0 ; i <= Ox7f; i++ ) 
23 { 
24 if{ TEST(set, i) ) 
25 { 
26 if ( i < , , 
27 printf( ""%c", i + '@' ); 
28 else 
29 printf ( "%c", i ) ; 
30 
31 
32 
33 putchar(']'); 
34 
35 
36 /*--------------------------------------------------------------*/ 
37 
38 PRIVATE char *plab( nfa, state ) 
39 NFA *nfa, *state ; 
40 { 
41 /* Return a pointer to a buffer containing the state number. The buffer is 
42 *overwritten on each call so don't put more than one plab() call in an 
43 *argument to printf(). 
44 */ 
45 
46 static char buf[ 32 ]; 
47 
48 if ( ! nfa I I ! state ) 
49 return("--"); 
50 
51 sprintf( buf, "%2d", state- nfa ); 
52 return ( buf ); 
53 
54 
55 /*--------------------------------------------------------------*/ 
56 
57 
58 
59 
60 
61 
62 PUBLIC 
NFA 
int 
{ 
NFA void 
*nfa, 
len; 
*s = print_ nfa ( nfa, len, start ) 
*start; 
nfa ; 
63 printf( "\n----------------- NFA ---------------\n" ); 
64 
65 for (; --len >= 0 ; nfa++ ) 
66 { 
67 printf ( "NFA state %s: ", plab (s, nfa) ) ; 
68 
69 if ( ! nfa->next ) 
70 printf("(TERMINAL)"); 
71 else 
72 { 
73 printf( "--> %s ", plab(s, nfa->next) ); 
74 printf( "(%s) on", plab(s, nfa->next2) ); 
75 
76 switch( nfa->edge ) 
77 { 111 
112 Input and Lexical Analysis -Chapter 2 
Listing 2.33. continued ... 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 case CCL: printccl( nfa->bitset ) ; 
case EPSILON: printf ( "EPSILON " ) ; 
default: pchar ( nfa->edge, stdout ) ; 
} 
if( nfa == start ) 
printf(" (START STATE)"); 
if( nfa->accept ) 
printf(" accepting %s<%s>%s", nfa->anchor & START ? 
nfa->accept, 
nfa->anchor & END 
printf( "\n" ); 
printf( "\n-------------------------------------\n" ); break; 
break; 
break; 
11"11 ..... 
• I 
? "$" : II II ) ; 
Listing 2.34. nfa.c-The High-Level Access Function 
831 
832 
833 
834 
835 
836 
837 
838 
839 
840 
841 
842 
843 
844 
845 
846 
847 
848 
849 
850 
851 
852 
853 
854 
855 
856 
857 
858 
859 
860 
861 
862 
863 
864 
865 
866 
867 PUBLIC NFA *thompson( input function, max_state, start state 
char *(*input function)(); 
int *max_state; 
NFA **start_state; 
{ 
/* Access routine to this module. Return a pointer to a NFA transition 
* table that represents the regular expression pointed to by expr or 
* NULL if there's not enough memory. Modify *max_state to reflect the 
* largest state number used. This number will probably be a larger 
* number than the total number of states. Modify *start_state to point 
*to the start state. This pointer is garbage if thompson() returned 0. 
* The memory for the table is fetched from malloc(); use free() to 
* discard it. 
*I 
CLEAR STACK(); 
Ifunct = input_function; 
Current tok = EOS; 
advance(); 
Nstates 0; 
Next alloc 0; 
*start state 
*max state machine(); 
Next alloc 
if( Verbose > 1 ) /* Load first token *I 
/* Manufacture the NFA */ 
/* Max state # in NFA */ 
print_nfa( Nfa states, *max_state, *start state ) ; 
if( Verbose ) 
{ 
printf("%d/%d NFA states used.\n", *max_state, NFA_MAX); 
printf("%d/%d bytes used for accept strings.\n\n", Savep -Strings, 
STR MAX ) ; 
.... 
Section 2.5.2-Implementing Thompson's Construction 
Listing 2.34. continued ••• 
868 return Nfa_states; 
869 
2.5.3 Interpreting an NFA-Theory* 
Now that we've constructed an NFA, we need to tum it into a DFA. The method 
used here is called subset construction; it is developed over the next few sections. First, 
let's look at how an NFA can be used directly to recognize a string. (Note that interpret­
ing an NFA directly can make more sense in some applications, such as editors, in which 
the time required to manufacture the DFA from the NFA can be greater than the search 
time.) 
The basic strategy makes use of the fact that, from any state, you are, for all practical 
purposes, also in every state that can be made by traversing E edges from the current 
state. I'll demonstrate with a concrete example. The NFA for 
(D*\.DID\.D*) 
is reproduced in Figure 2.14, and I'll recognize the string 1. 2. using this NFA. 
Figure 2.14. NFA for (D*\. DID\. D*) 
£ 
£ 
£ £ 
The terminal states (the ones with no outgoing edges) are all accepting states. Starting in 
the start state (State 0), you can take all E transitions, regardless of the input character, 
and without reading any input. If the machine is in State 0, it is, for all practical pur­
poses, simultaneously in States 1, 3, 4, 5, and 12 as well. (These states are all at the end 
of E edges that start in State 0. For example, State 4 is there by traversing three edges, 
from State 0 to State 12 to State 3 to State 4.) This set of states-the ones that can be 
reached by making E transitions from a given set of start states-is called the £-closure 
set. This set also includes the start state-there's an implied E transition from every state 
to itself. In this case, the set of start states has only one element: { 0 I, and you can make 
transitions to a set of five states: { 1, 3, 4, 5, I2 I. So: 
£-closure( {01 )= {0, I,3,4,5, I21. 
Reading the 1 from the input, the next state is determined by looking at all transitions 
that can legitimately be made on a D from any of the states in the £-closure set that was 
just created. There is a transition from State I to 2 on a D, and another from State 5 to 8; 
so from the states in the set {0, I, 3, 4, 5, I2l, you can make transitions to states in the 
set { 2, 8 I on a D. This set of states is called the move set by [Aho], and it's created by a 113 
Using an NFA to recog­
nize strings. 
£ edges effectively merge 
states. 
114 
Greedy and nongreedy 
algorithms. Input and Lexical Analysis -Chapter 2 
move() function.13 More formally, move(S,c )-where S is a set of states and c is an input 
character-is the set of states that can be reached by making transitions on c from any of 
the states in S. In this case: 
move( {0, 1,3,4,5, 121. D)= {2,81. 
From States 2 and 8 the machine is also in all states that can be reached by making E 
transitions out of States 2 and 8. There are E transitions from State 2 to States 1 and 4, 
but there are no E transitions out of State 8. So: 
£-closure( { 2, 8 I ) = { 1, 2, 4, 8 I 
(Remember, the £-closure set includes the original states.) Now get another input char­
acter, this time the dot, and look for outgoing transitions from the previously-computed 
£-closure set. There is a transition from State 8 to 10 on a dot, and another from State 4 
to 6: 
move( { 1, 2, 4, 8), • ) = { 6, 10 I. 
Continuing the process: 
£-closure( {6, 101) = {6, 9, 10, 13, 141 
State 14 is an accepting state, and the machine can accept if any of the states in the £­
closure set are accepting states. So the machine can accept at this point. Since there's 
more input, however, more processing is required-the same greedy algorithm that's 
used by the I.!'X-generated analyzer is used here. Reading the 2 : 
move( {6,9, 10, 13, 14), D)= {7, 111 
and: 
£-closure( {7, 111 )= {7,9, 11, 13,141. 
This represents an accepting state because State 14 is present. Reading the end-of-input 
marker, 
move( {7,9, 11, 13,141, END_OF_INPUT)=0 
The resulting set is empty-there's nowhere to go. This situation is the equivalent of a 
failure transition, so the machine executes the most recently seen accepting action and 
accepts State 14. 
The algorithm is stated more formally in Tables 2.6 and 2.7. The first of these algo­
rithms is a greedy algorithm. It recognizes the longest possible string that matches a reg­
ular expression. The second algorithm is non greedy. It accepts the first string that 
matches a regular expression. The main difference between these algorithms is that the 
greedy algorithm doesn't accept an input string until a failure transition out of some state 
occurs, whereupon it accepts the string associated with the most recently seen accepting 
state (which could be the current state if the machine fails out of an accepting state). 
The non-greedy algorithm just accepts as soon as it enters any accepting state. 
13. The move() function is the same thing as the next() function that we've been using to find the next state in a 
DFA. 
Section 2.5.3-Interpreting an NF A-Theory* 
Table 2.6. Greedy NFA Interpretation (Terminates on Failure) 
current is the set of NFA states that represents the current position in the machine. 
c is the current input character. 
accept if the most recently computed £-closure set includes an· accepting state, this is the 
state number, otherwise it's false (0). 
last_accept =FALSE; 
current= £-closure( state_state ); 
while( c = nextchar( ) ) 
I 
if( £-closure( move( current, c) ) * 0) 
I 
if( accept) 
last_accept = accept ; 
current = next; 
else if( last_accept ) 
I 
else ACCEPT( last_accept ); 
last_accept =FALSE; 
current = £-closure( state_state ); 
ERROR; 
Table 2.7. Non-Greedy NFA Interpretation (Terminates on First Accepting State) 
current 
c 
accept is the set of NFA states that represents the current position in the machine. 
is the current input character. 
if the most recently computed £-closure set includes an accepting state, this is the 
state number, otherwise it's false (0). 
current = £-closure( state_state ); 
while( c = nextchar( ) ) 
I 
if( £-closure( move( current, c)) is not 0) 
I 
if( accept) 
I 
ACCEPT( accept ); 
current = £-closure( state_state ); 
else 
current = next; 
2.5.4 Interpreting an NFA-Implementation 
The foregoing theory is all implemented by the code in terp.c, which starts in Listing 
2.35. The LARGEST_ INT macro on line 19 evaluates to the largest positive integer that 
can be represented in an int. It is portable-the actual size of an int is immaterial. It 115 
Computing largest posi­
tive integer: 
LARGEST INT 
116 Input and Lexical Analysis -Chapter 2 
works by shifting a number that contains all 1 's to the right by one bit, shifting a 0 into 
Nfa,Nfa_states,nfa() the high bit. The cast to unsigned defeats sign extension on the right shift. Nfa is a 
pointer to the NFA that represents the regular ex pression, and N fa_ states is the 
number of states in that NFA. The nfa ( ) subroutine on line 26 is passed a pointer to an 
input routine. It creates an NFA using the routines developed earlier, and returns the 
free_nfa 0 state number of the start state (its index in the array). The free_ nfa ( ) routine on line 
43 discards the NFA created with the previous nfa ( ) call. 
Listing 2.35. terp.c-File Header 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 38 
39 
40 
41 
42 
43 
44 
45 
46 #include <stdio.h> 
#include <ctype.h> 
#include <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslcompiler.h> 
#include "nfa.h" I* defines for NFA, EPSILON, CCL *I 
1*----------------------------------------------------------------------
* Prototypes for subroutines in this file 
*I 
PUBLIC int 
PUBLIC void 
PUBLIC SET 
PUBLIC SET nfa 
free nfa 
*e closure 
*move char * (*) () 
void 
SET*, char**, 
SET*, int ) ; 
) ; 
int* ) ; 
) ; 
1*----------------------------------------------------------------------*l 
#define LARGEST INT (int) (((unsigned) (-0)) >> 1) 
PRIVATE NFA *Nfa; 
PRIVATE int Nfa_states; I* Base address of NFA array 
I* Number of states in NFA *I 
*I 
1*----------------------------------------------------------------------*l 
PUBLIC int nfa( input_routine 
char * (*input_routine) (); 
{ 
I* Compile the NFA and initialize the various global variables used by 
*move() and e_closure(). Return the state number (index) of the NFA start 
*state. This routine must be called before either e_closure() or move() 
*are called. The memory used for the nfa can be freed with free_nfa() 
* (in thompson. c). 
*I 
NFA *sstate; 
Nfa = thompson(input_routine, &Nfa_states, &sstate); 
return( sstate- Nfa ); 
l*----------------------------------------------------------------------*1 
PUBLIC void free_nfa() 
{ 
free( Nfa ); 
Section 2.5.4-Interpreting an NFA-Implementation 
The £-closure set is computed by e _closure ( ) , in Listing 2.36. It uses the NFA 
created by a previous nfa ( ) call. It is passed a pointer to a set of states (input) and 
returns the £-closure set, which is empty if either the input set or the £-closure set is 
empty. If the £-closure set contains an accepting state, it returns two additional values 
indirectly through pointers-* accept is modified to point at the string that holds the 
action code, and *anchor is modified to hold the value of the NFA structure's anchor 
field. *accept is set to NULL if there is no accepting state in the closure set. Since all 
members of the original set are also in the closure set, the output set is created by modi­
fying the input set. That is, e _closure () returns its own first argument, but the set is 
modified to contain the elements of the closure set in addition to the initial elements. 
If the £-closure set contains more than one accepting state, the accepting action that 
has the lowest NFA state number is used. This way, conflicting states that are higher in 
the input file take precedence over the ones that occur later. The accept_ num variable 
declared on line 69 of Listing 2.36 holds the state number of the last-assigned accepting 
state. If the current state has a lower number, the other state is overwritten. It is initial­
ized to the largest positive integer. The algorithm in Table 2.8 is used. 14 The numbers in 
the algorithm reference comments in the code. 
Table 2.8. Algorithm for Computing £-Closure 
input 
N 
1: 
2: 
3: 
4: 
5: 
6: 
7: set of input states. 
the current NFA state being examined. 
state number of a next state that can be reached from State i. 
Push all states in the input set onto a stack. 
while( the stack is not empty ) 
I 
Pop the top element into i. 
if( State i is an accepting state ) 
*accept = the accept string; 
if( there's an E transition from State ito State N) 
I 
if( N isn't in the closure set) 
I 
Add N to the closure set. 
Push N onto the stack. 
The move set is figured with the move ( ) subroutine in Listing 2.37. It returns either 
the set of states that can be reached by making transitions on a specified input character 
from a specified set of states, or NULL if there are no such transitions. 
The for loop on lines 129 to 143 does the work. The if statement at the top of the 
loop evaluates true for every element of the input set, and any next states are added to 
the output set on line 140. Note that the output set is not created unless there's some­
thing to put into it. 
14. It is derived from the one in [Aho] p. 119. Computing£ closure: 
e _closure () 117 
Resolving ambiguous ac­
cepting actions. Higher 
actions, higher pre­
cedence 
Computing the move set: 
move(). 
118 Input and Lexical Analysis -Chapter 2 
Listing 2.36. terp.c-The £-Closure Function 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 PUBLIC 
SET 
char 
int SET *e_closure( input, accept, anchor ) 
*input 
**accept 
*anchor 
{ 
I* input is the set of start states to examine. 
* *accept 
* is modified to point at the string associated with an accepting 
state (or to NULL if the state isn't an accepting state). 
* *anchor 
* is modified to hold the anchor point, if any. 
* Computes the epsilon closure set for the input states. The output set 
* will contain all states that can be reached by making epsilon transitions 
* from all NFA states in the input set. Returns an empty set if the input 
* set or the closure set is empty, modifies *accept to point at the 
* accepting string if one of the elements of the output state is an 
* accepting state. 
*I 
int stack[ NFA MAX l ; I* Stack of untested states *I 
int *tos; I* Stack pointer *I 
NFA *p; I* NFA state being examined *I 
int i; I* State number of " *I 
int accept num LARGEST INT 
if( ! input ) 
goto abort; 
*accept 
tos NULL; 
& stack[-1]; I* Reference to algorithm: *I 
I* 1 *I 
for( next_member(NULL); (i 
*++tos = i; 
while( INBOUNDS(stack,tos) 
{ 
i = *tos-- ; 
p = & Nfa[ i ]; next_member(input)) >= 0 ;) 
if( p->accept && (i < accept_num) 
{ 
accept_num 
*accept 
*anchor i ; 
p->accept 
p->anchor 
if( p->edge == EPSILON 
{ 
if( p->next ) 
{ 
} i = p->next -Nfa; 
if( !MEMBER(input, i) 
{ 
ADD( input, i ); 
*++tos = i; 
if( p->next2 
{ 
i = p->next2 -Nfa; I* 2 *I 
I* 3 *I 
I* 4 *I 
I* 5 *I 
I* 6 *I 
I* 7 *I 
Section 2.5.4-lnterpreting an NFA-Implementation 
Listing 2.36. continued ••. 
105 
106 
107 
108 
109 
110 if( !MEMBER(input, 
{ 
ADD( input, i 
*++tos = i; 
Ill 
112 
113 abort: 
114 return input; 
115 
Listing 2.37. terp.c-The Move Function 
PUBLIC SET *move( inp_set, c ) i) I* 5 *I 
) ; I* 6 *I 
I* 7 *I 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 SET 
int *inp_set; 
c; I* input set *I 
I* transition on this character *I 
I* Return a set that contains all NFA states that can be reached by making 
*transitions on "c" from any NFA state in "inp_set." Returns NULL if 
* there are no such transitions. The inp set is not modified. *I -
int i; 
NFA *p; 
SET *outset = NULL; 
for( i = Nfa states; --i >= 0; 
{ 
if( MEMBER(inp_set, i) ) 
{ 
p = &Nfa[i]; I* current NFA state 
I* output set 
if ( p->edge==c I I (p->edge==CCL && TEST (p->bitset, c))) 
{ 
if ( ! outset ) 
outset= newset(); 
ADD( outset, p->next- Nfa ); 
return( outset); 
Listing 2.38 uses the previous subroutines to build a small egrep-like program that 
copies standard input to standard output, printing only those lines that contain a match of 
a regular expression passed into the program on the command line. The next_ char ( ) 
subroutine on line 156 of Listing 2.38 gets the next input character. It buffers entire lines 
because terp must print the entire line when a match is found [otherwise getc ( ) could 
be used]. getline () on line 177 is the input function passed to nfa (). It just passes 
along the regular expression that was on the command line. (Expr is initialized on line 
215.) The remainder of the subroutine is a straightforward implementation of the non­
greedy algorithm discussed in the previous section. *I 
*I 119 
120 Input and Lexical Analysis -Chapter 2 
Listing 2.38. terp.c-A Simplified Egrep 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 193 
194 
195 
196 
197 
198 
199 
200 
201 
202 #ifdef MAIN 
#define ALLOCATE 
#include "globals.h" 
#define BSIZE 256 
PRIVATE char Buf[ I* externs for Verbose *I 
BSIZE l ; I* input buffer 
PRIVATE char *Pbuf = Buf; I* current position in input buffer 
PRIVATE char *Expr; I* regular expression from command line 
int next char () 
1*-if( ! *Pbuf ) 
{ 
if( !fgets(Buf, BSIZE, stdin) ) 
return NULL; 
Pbuf = Buf; 
return *Pbuf++; 
- - - - - - - - - - - - - - - - - - - - - - - - - *I 
PRIVATE void 
{ printbuf () 
fputs(Buf, stdout); 
*Pbuf = 0; I* Print the buffer and force a read 
I* on the next call to nextchar(). 
1*--------------------------------------------------------------*l 
PRIVATE char 
{ *get line() 
static int first time called 1; 
if( !first time called 
return NULL; 
first time called 0; 
return Expr; 
l*--------------------------------------------------------------*1 
main( argc, argv 
char **argv; 
{ 
int sstate; 
SET *start dfastate; -SET *current; 
SET *next; 
int accept; 
int c; 
int anchor; 
if( argc == 2 ) I* Starting NFA state *I 
I* Set of starting nfa states *I 
I* current DFA state *I 
I* cur. DFA state is an accept *I 
I* current input character *I 
fprintf(stderr,"expression is %s\n", argv[l] ); *I 
*I 
*I 
*I 
*I 
.... 
Section 2.5.4-Interpreting an NFA-lmp1ementation 
Listing 2.38. continued ... 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 else 
I* 
* fprintf(stderr,"usage: terp pattern <input\n"); 
exit(l); 
1: Compile the NFA; initialize move() & e_closure(). 
2: Create the initial state, the set of all NFA states that can 
* 
* 3: be reached by making epsilon transitions from the NFA start state. 
Initialize the current state to the start state. 
*I 
Expr argv[l]; I* 1 *I 
sstate nfa ( get line ) ; 
next= newset(); I* 2 *I 
ADD( next, sstate ); 
if( ! (start_dfastate = e_closure(next, &accept, &anchor)) 
{ 
fprintf(stderr, "Internal error: State machine is empty\n"); 
exit(l); 
current= newset(); I* 3 *I 
assign( current, start_dfastate ); 
I* Now interpret the NFA: The next state is the set of all NFA states that 
* can be reached after we've made a transition on the current input 
* character from any of the NFA states in the current state. The current 
* input line is printed every time an accept state is encountered. 
* The machine is reset to the initial state when a failure transition is 
* encountered. 
*I 
while( c = nextchar() ) 
{ 
if( next= e_closure( move(current, c), &accept, &anchor) ) 
{ 
} 
#endif if( accept ) 
printbuf(); 
else 
{ 
delset( current); 
current 
continue; 
delset ( next ) ; next; 
assign( current, start dfastate ); I* accept *I 
I* keep looking *I 
I* reset *I 121 
122 
Subset construction: an 
example. Input and Lexical Analysis -Chapter 2 
2.5.5 Subset Construction: Converting an NFA to a DFA-Theory* 
You can apply the foregoing procedure to translate NFA's to DFA's by computing the 
£-closure and move sets for every possible input character. This generalized method, 
called subset construction, takes advantage of the fact that all NFA states connected with 
E edges are effectively the same state. A single DFA state represents all NFA states that 
are connected in this manner. The outgoing edges from the DFA state are just the sum of 
the outgoing edges from all states in the £-closure set. I'll demonstrate with an example. 
Using the NFA in Figure 2.14 on page 113, the starting DFA state consists of the £­
closure of the starting NFA state: 
£-closure({ 12}) = {0, 1, 3, 4, 5, 12} (new DFA State 0) 
The next states in the DFA are then computed by figuring move(current_state, c), for 
every possible input character. The input alphabet (the set of all possible input charac­
ters) contains only two elements: D and dot(.), so DFA States 1 and 2 are computed as 
follows: 
move({O, 1, 3, 4, 5, 12), D) 
move({O, 1, 3, 4, 5, 12), .) = {2, 8} 
= {6} (new DFA State 1) 
(new DFA State 2) 
This procedure is then applied to the two new states. Starting with State 2: 
DFA State 2 = {6} 
£-closure( { 6}) 
move({6), .) 
move({6}, D) = {6} 
=0 
= {7} (new DFA State 3) 
DFA State 1 = {2,8} 
£-closure( { 2,8}) 
move({ 1, 2, 4, 8}, D) 
move({ 1, 2, 4, 8}, .) =I 1, 2, 4, 8} 
= {2} (new DFA State 4) 
(new DFA State 5) = {6, 10} 
If the move operation results in an empty set-as is the case with move( { 6}, .), 
above-then there are no outgoing transitions from that state. Applying the procedure 
again to the three new DFA States: 
DFA State 3 = {7} 
£-closure( { 7}) 
move({?, 13, 14}, .) 
move({?, 13, 14}, D) 
DFA State 4 = {2) 
£-closure( { 2}) 
move({1,2,4}, .) 
move( { 1, 2, 4}, D) 
DFA State 5 = {6, 10} 
£-closure( { 6, 10}) 
move({6, 9, 10, 13, 14}, .) 
move({6, 9, 10, 13, 14), D) ={7,13,14} 
=0 
=0 
=I 1, 2, 41 
= {6} 
= {2} 
= {6, 9, 10, 13, 14} 
=0 
= {7, 11} (existing DFA State 4) 
(existing DFA State 2) 
(existing DFA State 4) 
(new DFA State 6) 
DFA States 3 and 5 are accepting states because their £-closure sets all contain an 
accepting state (NFA State 14). This last expansion introduced only one new state, 
which is now expanded: 
Section 2.5.5-Subset Construction: Converting an NFA to a DFA-Theory* 
DFA State 6 = {7, 11} 
£-closure( {7, 11 }) 
move({7,9, 11, 13, 14), .) 
move({?, 9, 11, 13, 14 ), D) = {7, 9, 11, 13, 14} 
=0 
= { 11 } (new DFA State 7) 
And then this new state is expanded in tum: 
DFA State 7 = { 11 } 
£-closure( { 7, 11 } ) 
move({9, 11, 13, 14), .) 
move( {9, 11, 13, 14), D) = {9, 11, 13, 14} 
=0 = { 11} (existing DFA State 7) 
DFA States 6 and 7 are accepting states because they contain NFA accepting State 14. 
The process is summarized in Table 2.9, and the complete DFA is pictured in Figure 
2.15. The procedure is formalized with the algorithm in Table 2.10Y Note that the state 
machine that this algorithm generates is not optimal. It has several more states than 
necessary. I'll look at how to remove these extra states in a moment. 
Table 2.9. Converting NFA in Figure 2.14 (page 113) to a DFA 
DFA NFA move(D) move(.) £-closure Accepting State State NFA DFA NFA DFA 
0 {0} {0,1,3,4,5,12} {2,8} I {6} 2 no 
I {2,8} {1,2,4,8} {2} 4 {6, 10} 5 no 
2 {6} {6} {7} 3 0 - no 
3 {7} {7,13,14} 0 -0 - yes 
4 {2} {1,2,4} {2} 4 {6} 2 no 
5 {6,10} {6,9,10,13,14} {7,11} 6 0 - yes 
6 {7, II} {7,9,11,13,14} {II} 7 0 - yes 
7 {II} {9,11,13,14} {II} 7 0 - yes 
Figure 2.15. DFA for NFA in Figure 2.14 
D 
15. Adapted from [Aho], p. 118. 123 
124 Input and Lexical Analysis -Chapter 2 
Table 2.10. Algorithm to Convert an NFA to a DFA 
Output-table type: TTYPE 
Failure transitions: F 
The ROW type. Dstates is an array of DFA states. Each state is represented by a set of NFA states and a 
Boolean mark field. 
Dtran is the DFA transition matrix, an array as wide as the input 
character set and as deep as the maximum number of states. 
Dtran[current_state][input_character] =the next state 
i 
nstates s is the index in Dtran of the current state. 
is the index in Dtran of the place where a new state will be inserted. 
is a set of NFA states that defines a DFA state. 
c is a possible input symbol. 
Initially: Dstates[O].set =£-closure of NFA start state 
Dstates[O] is not marked. 
Nstates =I. 
i= 0. 
Sis empty. 
Dtran is initialized to all failure transitions. 
while( there is an unmarked state at Dstates[i]) 
{ 
Dstates[i].mark =TRUE; 
for( each input symbol c ) 
{ 
S =£-closure( move( Dstate[i].set, c)); 
if( S is not 0 ) 
{ 
if( a state with set=S isn't in Dstates) 
else add a new unmarked state at Dstates[Nstates], with set=S 
Dtran[i][c] = Nstates++ 
Dtran[i][c] =index of exiting state in Dstates 
2.5.6 Subset Construction: Converting an NFA to a DFA-Implementation 
This section shows how IJlX applies the theory in the previous section to make the 
output DFA. It uses thee_ closure () and move() functions to build a complete DFA 
transition matrix from a previously constructed NFA. As before, you need to start with 
some constant and data-structure definitions, found in dfa.h, Listing 2.39. 
The maximum number of DFA states is defined on line seven of Listing 2.40 to be 
254. This number is more than adequate for most applications and has the added advan­
tage of fitting into an unsigned char. The tables used for the transition matrix can be 
smaller as a consequence. You can make the number larger if you wish, but you'll have 
to change the driver discussed at the beginning of this chapter to compensate for the 
change in type. The TTYPE definition on line 12 is the type of the output tables-it must 
match the declared type of the tables in the state-machine driver. The internal versions 
of the same tables are all arrays of int. The F macro, defined on line 18, marks failure 
transitions in the internal tables. It must be -1, but hiding the -I in a macro makes the 
code a little more readable. The ROW type on line 21 is one row of the DFA transition 
matrix. Declaring a row as a distinct type helps you use pointers to traverse individual 
Section 2.5.6-Subset Construction: Converting an NF A to a OF A-Implementation 
Listing 2.39. dfa.h-Definitions for a DFA 
I 
2 
3 
4 
5 
6 
7 
8 
9 1*--------------------------------------------------------------
* DFA.H: The following definitions are used in dfa.c and in 
* minimize.c to represent DFA's. *--------------------------------------------------------------
*I 
#define DFA MAX 254 
typedef unsigned char TTYPE; 
#define F 
#define MAX CHARS -1 
128 I* Maximum number of DFA states. If this 
*number>= 255, you'll have to change the 
* output routines and driver. States are 
* numbered from 0 to DFA MAX-1 
*I 
I* This is the type of the output DFA *I 
I* transition table (the internal one is *I 
I* an array of int). It is used only to *I 
I* figure the various table sizes printed *I 
I* by -v. *I 
I* Marks failure states in the table. *I 
I* Maximum width of dfa transition table. *I 
typedef int ROW[ MAX CHARS]; I* One full row of Dtran, which is itself *I 
I* an array, DFA_MAX elements long, of *I 
I* ROWs. *I 1*--------------------------------------------------------------*l 
typedef struct accept 
{ 125 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 char *string; 
int anchor; I* Accepting string; NULL if nonaccepting. *I 
I* Anchor point, if any. Values are defined in NFA.H. *I 
ACCEPT; 
1*----------------------------------------------------------------------
* External subroutines: 
*I 
SET *e closure (SET*, char ** int * ) ; I* terp.c ' void free nfa (void ) ; I* terp.c 
SET *move (SET*, int ) ; I* terp.c 
int nfa (char * ( *) () ) ; I* terp.c 
int dfa (char * ( *) ()' ROW*[], ACCEPT** ) ; I* dfa.c 
int min dfa (char * ( *) ()' ROW*[], ACCEPT** ) ; I* minimize.c 
int ttypesize (int ) ; I* printdfa.c 
void pdefines (FILE*, int ) ; I* pdefines.c 
int columns (FILE*, ROW*, int, int, char* ) ; I* columns.c 
void cnext (FILE*, char* ) ; I* columns.c 
void pheader(FILE *fp, ROW dtran[], int nrows, ACCEPT *accept); 
void pdriver(FILE *output, int nrows, ACCEPT *accept); 
columns, because incrementing a pointer to an entire row will skip as many array ele­
ments as are in the row, effectively moving you down to the next element of the current 
column. For example, the following code allocates a NUM_ROWS element array (a 
two-dimensional array of size MAX_ CHARS x NUM_ROWS) and then prints the sixth 
column. It initializes the column pointer (p) to the head of the sixth column, and moves 
the pointer to the next element of the same column with a simple increment on each *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I *I 
I* print. c 
I* print. c *I 
*I 
126 
ACCEPT structures 
DFA_STATE:accept, 
group, anchor, set 
fields 
The transition matrix: 
Dtran, Nstates 
Create a DFA: dfa <). Input and Lexical Analysis -Chapter 2 
iteration of the loop. Note that two stars are needed to get an array element in the 
printf () statement.16 
#define NUM_ROWS 10 
static ROW Array[ NUM ROWS]; 
ROW *p; 
int i; 
p = (ROW *) ( &Array[O] [6] ) ; /* Initialize p to head */ 
/* of column 6. *I 
for( i = NUM_ROWS; --i >= 0; printf("%d ", **p++) 
Returning to Listing 2.39, the ACCEPT structure on line 26 keeps track of the accept­
ing strings, which are copied to an array of ACCEPT structures so that the memory used 
for the NFA can be discarded once it is translated into a DFA. The remainder of the file 
is just function prototypes. 
The actual conversion routines start in Listing 2.40 with a few more definitions. The 
DFA_STATE structure, typedefed on lines 23 to 31, represents a single state in the 
DFA. The group field is used for minimization, discussed in the next section. The 
accept and anchor fields are the accepting string and anchor point copied from the 
NFA state in the case of an accepting state; set is the set of NFA states that comprise 
the current DFA state. Dstates, an array of DFA structures, is defined on line 33. The 
DFA state number is the array index. The actual transition matrix Dtran is declared on 
line 36, and the number of states Nstates is declared on the next line. 
The routines that create the DFA are all local to dfa.c and are accessed via the 
dfa ( ) routine, also in Listing 2.40(on It is passed an input function, and returns the 
number of states in the transition matrix, the matrix itself, and an array holding the 
accepting string (the last two are returned indirectly through pointers). For the most part, 
this function is just allocating memory for the new tables and discarding memory for 
other tables once they're no longer needed. The NFA is constructed on line 69; it's con­
verted to a DFA on line 81; the accepting strings are copied to the target array on line 
91; and if verbose mode is active, a diagnostic message is printed on lines 101 to 114 of 
Listing 2.40. 
16. C note: You need two stars because p points at a two-dimensional array. To see why, inC the square 
brackets can always be interpreted with the following identity: p [i] = * (p+i). If i is 0, then p [O]=*p. 
Applying this identity to a two-dimensional array: p [0] [O]::(*p) [0] =**p. Looked at another way, ifp 
is a pointer to an array, then *p must be the array itself. But arrays are always represented in C by a 
pointer to the first element. Consequently, ifp is a pointer to an array ofint, then *p must be an array of 
int, which is represented by a pointer to the first element-a pointer to an int. Both p and *p will hold 
the same address, but p is of type "pointer to array of int" and *p is of type "pointer to int." 
Using a pointer here is much more efficient than something like this: 
for( i = 0; i < NUM ROWS; i++ ) ' 
printf("%d ", Ai"ray[i] [6] ) 
because the array index forces the compiler to multiply i by the size of a row at every iteration of the loop. 
The following is better, but still not as good as the original version: 
ROW *p; 
for( p=Array, i=NUM_ROWS; --i >= 0; printf("%d ", (*p++) [6] ) 
Section 2.5.6-Subset Construction: Converting an NF A to a DFA-Implementation 
Listing 2.40. dfa.c-NFA to DFA Conversion: File Header and Access Function 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 55 
56 
57 #include <stdio.h> 
#ifdef MSDOS 
# include <stdlib.h> 
#else 
# include <malloc.h> 
#endif 
#include <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslcompiler.h> 
#include "dfa.h" 
#include "globals.h" I* externs for Verbose, etc. *I 
1*----------------------------------------------------------------
* DFA.C 
* Make a DFA transition table from an NFA created with 
Thompson's construction. *----------------------------------------------------------------
* Dtran is the deterministic transition table. It is indexed by state number 
* along the major axis and by input character along the minor axis. Dstates 
* is a list of deterministic states represented as sets of NFA states. 
* Nstates is the number of valid entries in Dtran. 
*I 
typedef struct dfa state 
{ 
unsigned group 8; 
unsigned mark 1; 
char *accept; 
int anchor; 
SET *set; 
DFA_STATE; I* Group id, used by minimize() 
I* Mark used by make_dtran() 
I* accept action if accept state 
I* Anchor point if an accept state 
I* Set of NFA states represented by 
I* this DFA state *I 
*I 
*I 
*I 
*I 
*I 
PRIVATE DFA STATE *Dstates ; I* DFA states table *I 
l*---------~----------------------------------------------------*1 
PRIVATE ROW 
PRIVATE int 
PRIVATE DFA STATE *Dtran I* DFA transition table *I 
Nstates I* Number of DFA states *I 
*Last_marked;l* Most-recently marked DFA state in Dtran *I 
extern char *bin_to_ascii ( int, int ); I* in compiler.lib *I 
1*--------------------------------------------------------------
* Prototypes for subroutines in this file: 
*I 
PRIVATE DFA STATE *get_unmarked (void ); 
PRIVATE int in dstates (SET* ); 
PRIVATE void free sets (void ); 
PRIVATE void make dtran ( int ); 
PUBLIC int dfa (char*(*)(), ROW*[], ACCEPT**); 
1*----------------------------------------------------------------------*l 
int dfa ( ifunct, dfap, acceptp ) 
char * ( *ifunct ) () ; 
ROW * ( dfap[] ) ; 
ACCEPT * ( *acceptp ) ; 
{ 127 
.... 
128 Input and Lexical Analysis -Chapter 2 
Listing 2.40. continued ... 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 /* Turns an NFA with the indicated start state (sstate) into a DFA and 
* returns the nurr~er of states in the DFA transition table. *dfap is 
* modified to point at that transition table and *acceptp is modified 
* to point at an array of accepting states (indexed by state number). 
* dfa() discards all the memory used for the initial NFA. 
*I 
ACCEPT 
int 
int *accept_states; 
i; 
start; 
nfa ( ifunct ) ; 
0; /* make the nfa */ start 
Nstates 
Dstates 
Dtran 
Last marked (DFA_STATE *) calloc( DFA_MAX, sizeof(DFA_STATE) ); 
(ROW* ) calloc( DFA_MAX, sizeof(ROW) ); 
Dstates; 
if( Verbose 
fputs("making DFA: ", stdout); 
if ( ! Dstates I I ! Dtran 
ferr ( "Out of memory!" ) ; 
make_dtran( start ) ; 
free_nfa(); /* convert the NFA to a DFA */ 
/* Free the memory used for the nfa */ 
/* itself (but not the accept strings). */ 
Dtran 
accept states (ROW *) realloc( Dtran, Nstates * sizeof(ROW) ); 
(ACCEPT*) malloc ( Nstates * sizeof(ACCEPT)); 
if( !accept states I I !Dtran ) 
ferr( "Out of memory!!" ); 
for( i = Nstates ; --i >= 0 ; ) 
{ 
accept_states[i] .string 
accept_states[i] .anchor 
free( Dstates ); 
*dfap Dtran; 
*acceptp = accept_states; 
if( Verbose ) 
{ Dstates[i] .accept; 
Dstates[i] .anchor; 
printf("\n%d out of %d DFA states in initial machine.\n", 
Nstates, DFA_MAX); 
printf("%d bytes required for uncompressed tables.\n\n", 
Nstates * MAX CHARS * sizeof(TTYPE) /* dtran */ 
+ Nstates * sizeof(TTYPE) ); /*accept*/ 
if( Verbose > 1 
{ 
printf("The un-minimized DFA looks like this:\n\n"); 
pheader(stdout, Dtran, Nstates, accept_states); 
Section 2.5.6-Subset Construction: Converting an NF A to a OF A-Implementation 
Listing ~.40. continued ••• 
117 return Nstates 
118 
Several support functions are needed to do the work, all in Listing 2.40. The 
add_ to_ dstates () function on line 23 adds a new DFA state to the Dstates array and add_to_dstates 0 
increment'> the number-of-states counter, Nstates. It returns the state number (the 
index in J tates) of the newly added state. in_ dstates () on line 31 is passed a set in_dstates 0 
of NFA states, and returns the state number of an existing state that uses the same set (or 
-1 if there is no such state). The routine just does a linear search, which is probably not 
the best strategy here. Something like a binary tree would be better. 
Listing 2.41. dfa.c-NFA to DFA Conversion: Support Functions 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 int add_to_dstates( NFA_set, accepting_string, anchor ) 
SET *NFA_set; 
char 
int 
/*-*accepting_ string; 
anchor; 
int nextstate; 
if( Nstates > (DFA_MAX-1) ) 
ferr("Too many DFA states\n"); 
nextstate = Nstates++ ; 
Dstates[ nextstate ] .set 
Dstates[ nextstate ] .accept 
Dstates[ nextstate ] .anchor 
return nextstate; NFA_set; 
accepting_ string; 
anchor; 
- - - - - - - - - - - - - - *I 
PRIVATE int in_dstates( NFA set 
SET *NFA_set; 
{ 
/*-/* If there's a set in Dstates that is identical to NFA_set, return the 
* index of the Dstate entry, else return -1. 
*I 
DFA_STATE *p; 
for( p = &Dstates[Nstates]; --p >= Dstates 
if( IS_EQUIVALENT( NFA_set, p->set ) ) 
return( p-Dstates ); 
return ( -1 ) ; 
- - - - - - - - - - - - - - - - - - - - */ 
PRIVATE DFA STATE 
{ *get_unmarked () 
/* Return a pointer to an unmarked state in Dstates. If no such state 
* exists, return NULL. Print an asterisk for each state to tell the 
* user that the program hasn't died while the table is being constructed. 
*I 129 
.... 
130 Input and Lexical Analysis -Chapter 2 
Listing 2.41. continued ••• 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 /*-for(; Last_marked < &Dstates[Nstates] 
( 
if( !Last_marked->mark ) 
( 
putc 
fflush '*' , stderr ) ; 
stderr ) ; 
if( Verbose > 1 
{ ++Last marked 
fputs("----------------\n", stdout ); 
printf("working on DFA state %d = NFA states: ", 
Last_marked-Dstates); 
pset( Last_marked->set, fprintf, stdout ); 
putchar('\n'); 
return Last_marked; 
return NULL; 
- - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void 
( free_ sets() 
/* Free the memory used for the NFA sets in all Dstate entries. */ 
DFA_STATE *p; 
for( p = &Dstates[Nstates]; --p >= Dstates 
delset( p->set ); 
get _unmarked 0 A pointer to the next unmarked state is returned by get_ unmarked ( ) , declared on 
line 157. The Last_ marked variable was initialized by dfa ( ) on line 38 of Listing 
2.40. Since new states are always added to the end of the table, everything above 
Last_ marked will have been marked with a previous expansion, so these states don't 
have to be examined now. The asterisk that's printed on line 168 of Listing 2.41 actually 
has two purposes. It tells the user that the program hasn't hung (it takes a while to make 
the tables), and it lets the user terminate the program with a Ctri-Break (a SIGINT under 
UNIX). It's needed because MS-DOS ignores Ctri-Breaks until a system call of some sort is 
made by a program. No such call is made while creating the tables, but a system call is 
required to print the asterisks. 
free_sets 0 Finally, free_ sets() on line 188 of Listing 2.41 goes through the entire Dstates 
array, deallocating the memory used for the sets of NFA states. 
NFA to DFA Conversion: The actual NFA to DFA conversion is done by make_ dtran (),in Listing 2.42. It is 
make-dtran ( > · a straightforward implementation of the algorithm in Table 2.10 on page 124. 
Section 2.5.6-Subset Construction: Converting an NF A to a DFA-Imp1ementation 
Listing 2.42. dfa.c-NFA to DFA Conversion: Conversion Function 
PRIVATE void make_dtran( sstate ) 
int sstate; 
SET 
DFA STATE 
int 
char 
int 
int *NFA set; 
*current; 
next state; 
*isaccept; 
anchor; 
c; I* Starting NFA state. *I 
I* Set of NFA states that define *I 
I* the next DFA state. *I 
I* State currently being expanded. *I 
I* Goto DFA state for current char. *I 
I* Current DFA state is an accept *I 
I* (this is the accepting string). *I 
I* Anchor point, if any. *I 
I* Current input character. *I 
I* Initially Dstates contains a single, unmarked, start state formed by 
* taking the epsilon closure of the NFA start state. So, Dstates[O} 
* (and Dtran[O]) is the DFA start state. 
*I 
NFA_set = newset() ; 
ADD( NFA_set, sstate ); 
1; 131 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 
230 
231 
232 
233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 248 Nstates 
Dstates[O] .set 
Dstates[O] .mark e_closure(NFA_set,&Dstates[O] .accept,&Dstates[O] .anchor); 
0; 
while( current = get_unmarked() 
{ 
current->mark = 1; 
for( c = MAX_CHARS ; --c >= 0 ; ) 
{ 
if( NFA set move(current->set, c) ) I* Make the table *I 
NFA set e_closure( NFA_set, &isaccept, &anchor); 
if( !NFA_set ) I* no outgoing transitions *I 
nextstate = F; 
else if( (nextstate in_dstates(NFA_set)) != -1) 
delset( NFA set ); 
else 
nextstate = add_to_dstates( NFA_set, isaccept, anchor); 
Dtran[ current-Dstates ] [ c ] = nextstate ; 
putc( '\n', stderr ); I* Terminate string of *'sprinted in 
* get_unmarked(); 
*I 
free_sets (); I* Free the memory used for the DFA STATE sets *I 
132 Input and Lexical Analysis -Chapter 2 
2.5.7 DFA Minimization- Theory* 
The DFA created earlier (in Figure 2.I5 on page I23) is not an optimal DFA. Only 
six of the eight states are actually required. A somewhat simplified version of the transi­
tion matrix for the original machine is reproduced in Table 2.11. A quick inspection of 
this table shows that States 6 and 7 are equivalent because they have identical next-state 
transitions and they're both accepting states. If all transitions into State 6 were replaced 
with transitions to State 7, the machine would still accept the same strings as before. 
One additional state can be eliminated, however, and simple inspection is not good 
enough for finding this extra state. I'll discuss how to find the extra state in this section. 
Table 2.11. DFA Transition Matrix for DFA in Figure 2.I5 
Look ahead Accepting D 
0 I 2 no 
I 4 5 no 
2 3 - no 
3 - - yes Current state 4 4 2 no 
5 6 - yes 
6 7 - yes 
7 7 - yes 
Finding equivalent states. You find equivalent states by systematically eliminating those states that can't be 
Implicit failure state. 
' .. .is distinguished .. .' equivalent-partitioning the initial array into potentially equivalent states, and then gra­
dually partitioning the partitions. When you're done, states that share a partition are 
equivalent. Initially, you partition the matrix into two parts, one for accepting states and 
another for nonaccepting states: 
0 
2 
4 
3 
5 
6 
7 D 
I 
4 
3 
4 
-
6 
7 
7 2 
5 0 -
2 
-
-1 -
-
(The partition number is on the right.) The implicit failure state is alone in a special, 
unnumbered partition that's not shown in the foregoing table. The next step in the 
minimization process creates a set of new partitions by looking at the goto transitions 
for each state and eliminating states that are not equivalent. If the outgoing transitions 
from two states go to different partitions, then the states are not equivalent. You do the 
elimination on a column-by-column basis. Starting with the D column, States 0, I, and 4 
all go to a state in Partition 0 on a D, but State 2 goes to Partition I on a D. Conse­
quently, State 2 must be removed from Partition 0. Formally, you say that State 4 is dis­
tinguished from the other states in the partition by a D. Continuing in this manner, State 
3 is also distinguished from States 5, 6, and 7 by a D because State 3 goes to the failure 
state on a D, but the other states go to a state in Partition I. The failure state is not in 
Partition I, so State 3 is distinguished by a D. 
Section 2.5.7-DFA Minimization-Theory* 
D 
0 I 2 
4 5 0 
4 4 2 
2 2 3 -
-- 3 3 
5 6 -
7 -6 1 
7 7 -
Now you go down the dot (.) column. The dot distinguishes State I from States 0 and 4 
because State I goes to a state in Partition I on a dot, but States 0 and 4 both go to States 
in Partition 2. The new partitions are: 
0 
4 
2 
3 
5 
6 
7 D 
I 
4 
4 
3 
-
6 
7 
7 2 
2 0 
5 4 
-2 
-3 
-
--
Next, you go through the array a second time, column by column. Now, D distinguishes 
State 0 from State 4 because State 0 goes to a state in Partition 4 on aD, but State 4 goes 
to a state in Partition 0 on a D. No other states can be distinguished from each other, so 
we're done. The final partitions look like this: 
D 
I 2 0 0 
4 2 4 5 
2 
3 
5 
6 
7 4 
3 
-
6 
7 
7 5 4 
-2 
-3 
---
The next step is to build a new transition matrix. Each partition is a single state in 
the minimized DFA, and all next states in the original table are replaced by the number 
of the partition in which the state is found. For example, since States 5, 6, and 7 are all 
in Partition I, all references to one of these states in the original table are replaced by a 
reference to the new State I. The new table looks like this: 133 
134 
D 
0 4 2 
1 I 
2 3 
3 
4 5 
5 5 2 Input and Lexical Analysis -Chapter 2 
The algorithm is fonnalized in Table 2.12. The transition diagram for the new state 
machine is in Figure 2.16. 
Table 2.12. DFA-Minimization Algorithm 
c 
group 
groups 
new 
first 
next 
goto_first 
goto next 
Initially: A character in the alphabet used by the DFA. 
A set of potentially equivalent states (a partition of the original transition matrix). 
A collection of groups. 
The set of states that have been distinguished from other states in the current group. 
First state in a group. 
One of the other states in a group, FALSE if there is no such state. 
A transition on c out of the first state comes here. 
A transition on c out of the next state comes here. 
Partition the original states into a series of groups. All nonaccepting states are in a single 
group, and accepting states that have the same accepting string are grouped together. A 
one-element group containing a single accepting state is pennissible. 
Repeat the following until no new groups are added to groups: 
for( each group in groups) 
{ 
new=0 
first = the first state in the current group. 
next= the next state of the current group or FALSE if none. 
while( next ) 
{ 
I for( each character c ) 
{ 
I goto _first = state reached by making a transition on c out of first. 
goto _next = state reached by making a transition on c out of next. 
if( goto _first is not in the same group as goto _next ) 
move next from the current group into new 
next =the next state in the current group or FALSE if none. 
if( new is not empty ) 
add it to groups 
Section 2.5.7-DFA Minimization-Theory* 
Figure 2.16. Minimized DFA for (D*\. DID\. D*) 
2.5.8 DFA Minimization-Implementation 
The algorithm in the previous section is implemented by the code starting in Listing 
2.43. The Groups [] array on line 16 is the collection of partitions. The array index is 
used as the partition number, and each group is a SET of NFA state numbers. Num­
groups, on line 17, is the number of groups currently in the array. Ingroup [],on line 
18, is the inverse of Groups [ ]. It is indexed by state number and evaluates to the group 
in which the state is found. All three of these are initialized to zeros by the access func­
tion min_dfa () (on lines 43 to 45). The DFA is created by the dfa () call on line 47, 
and it's minimized by the subroutine minimize ( ) , called on the next line. 
The Groups [] and In group [] arrays are initialized in ini t _groups ( ) , at the 
top of Listing 2.44. The program decides which group to place a state in by looking at 
the accepting-string pointer for that state. Since all nonaccepting states have NULL 
accepting strings, they'll all end up in a single group-Group 0 because DFA State 0 is 
always nonaccepting. The other groups in the initial partitioning contain accepting 
states. If two such states have the same accepting string, they are considered equivalent 
and are put into the same group. Note that since the starting state (0) always goes into 
Group 0, and since the minimization algorithm never moves the first element of the 
group to another partition, the starting state is still 0 after the minimization is complete. 
The goto statement on line 78 of Listing 2.44 is necessary because it has to break 
out of a doubly nested loop in order to avoid forming a new group. The same thing 
could probably be done with a Boolean flag of some sort, but the goto seems cleaner. 
The actual minimization is done by minimize ( ) starting on line 104 of Listing 
2.44. It is passed the number of states in the DFA transition table, a pointer to the DFA 
table itself, and a pointer to the accepting-state table. Note that there's an extra level of 
indirection in both of these last two parameters. That is, addresses of pointers to the two 
tables are passed to minimize ( ) . I've done this because entirely new tables are 
created to replace the existing ones-*dfap and *accept are modified to point at the 
new tables. The memory used for the old tables is discarded automatically by minim­
ize (). 
The routine is a straightforward implementation of the algorithm in Table 2.12 on 
page 134. It terminates when an entire pass is made through the set of groups without 
adding a new group. The test on lines 143 to 146 is complicated by the failure transi­
tions, which have no explicit existence. There is no physical group that holds the failure 
state, so I have to test here to make sure that neither of the two next states are failure 135 
The partitions: 
Groups [ ], Ingroup [ ], 
Numgroups 
Access function: 
min_dfa () 
Group initialization: 
init_groups (). 
Minimization: minim­
ize() 
136 Input and Lexical Analysis -Chapter 2 
Listing 2.43. minimize.c- Data Structures and Access Function 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 #include <stdio.h> 
#ifdef MSDOS 
# include <stdlib.h> 
#else 
# include <malloc.h> 
iendif 
linclude <toolsldebug.h> 
linclude <toolslset.h> 
linclude <toolslhash.h> 
linclude <toolslcompiler.h> 
linclude "dfa.h" 
linclude "globals.h" I* externs for Verbose *I 
I* MINIMIZE.C: Make a minimal DFA by eliminating equivalent states. 
PRIVATE SET *Groups DFA MAX l ; I* Groups of equivalent states in 
PRIVATE int Numgroups; I* Number of groups in Groups 
PRIVATE int Ingroup [ DFA MAX l ; I* the Inverse of Group *I 
Dtran 
1*----------------------------------------------------------------------
* Prototypes for subroutines in this file: 
*I 
PRIVATE void fix dtran ROW*[], 
PRIVATE void init _groups int, 
PUBLIC int min dfa char * (*) ()I 
PRIVATE void minimize int, 
PRIVATE void pgroups int ACCEPT** ) ; 
ACCEPT* ) ; 
ROW*[], ACCEPT** ) ; 
ROW*[], ACCEPT** ) ; 
) ; 
l*----------------------------------------------------------------------*1 
PUBLIC 
char 
ROW 
ACCEPT 
{ int min_dfa( ifunct, dfap, acceptp ) 
*( *ifunct ) (); 
* ( dfap [ J ) ; 
* ( *acceptp ) ; *I 
*I 
*I 
I* Make a minimal DFA, eliminating equivalent states. Return the number of 
* states in the minimized machine. *sstatep = the new start state. 
*I 
int nstates; I* Number of DFA states 
memset( Groups, 0, sizeof(Groups) ); 
memset( Ingroup, 0, sizeof(Ingroup) ); 
Numgroups = 0; 
nstates = dfa( ifunct, dfap, acceptp ); 
minimize ( nstates, dfap, acceptp ); 
return Numgroups; 
transitions before allowing an index into the Ingroup [] array. *I 
Removing redundant 
states: fix_dtran() The fix_dtran () routine on line 177 of Listing 2.44 uses the previously­
computed Groups [ ] to remove redundant states from the table. It's difficult to do the 
compression in place because the original states are randomly distributed throughout the 
groups, so two new arrays are allocated on lines 199 and 200. The original arrays are 
Section 2.5.8-DFA Minimization-Implementation 137 
freed on lines 218 and 219, and the array pointers are changed to point at the new arrays 
on the next couple of lines. 
The remainder of minimize.c consists of a few debugging routines in Listing 2.45. 
pgroups ( ) prints out all the existing groups and is used for very-verbose-mode (-V) Print the groups: 
diagnostics. pgroups < > 
Listing 2.44. minimize.c- Minimization Functions 
52 PRIVATE void init_groups( nstates, accept ) 
53 ACCEPT *accept; 
54 { 
55 SET **last 
56 int i, j 
57 
58 
59 
60 
61 
62 
63 
64 last 
Numgroups 
for( i = 
{ 
for( 
{ 0; 
j & Groups[O] 
0; 
i < nstates i++ 
= i; --j >= 0 ; ) 
65 /* Check to see if a group already exists that has the same 
66 * accepting string as the current state. If so, add the current 
67 * state to the already existing group and skip past the code that 
68 * would create a new group. Note that since all nonaccepting states 
69 * have NULL accept strings, this loop puts all of these together 
70 * into a single group. Also note that the test in the for loop 
71 * always fails for group 0, which can't be an accepting state. 
72 */ 
73 
74 if( accept[i] .string== accept[j] .string 
75 { 
76 ADD( Groups[ Ingroup[j] ], i ); 
77 Ingroup[i] = Ingroup[j]; 
78 goto match; 
79 
80 
81 
82 /* Create a new group and put the current state into it. Note that ADD() 
83 * has side effects, so "last" can't be incremented in the ADD 
84 * invocation. 
85 */ 
86 
87 *last= newset(); 
88 ADD( *last, i ); 
89 Ingroup[i] = Numgroups++; 
90 ++last; 
91 
match:; /* Group already exists, keep going 
} 
if( Verbose > 1 ) 
{ 92 
93 
94 
95 
96 
97 
98 
99 printf "Initial groupings:\n" ) ; 
100 
101 pgroups nstates ) ; *I 
138 Input and Lexical Analysis -Chapter 2 
Listing 2.44. continued ... 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 1*----------------------------------------------------------------------*l 
PRIVATE void minimize( nstates, dfap, acceptp ) 
int nstates; I* number of states in dtran [ 1 *I 
ROW * ( dfap[] ) ; I* DFA transition table to compress *I 
ACCEPT * ( *acceptp ) ; I* Set of accept states *I 
{ 
int old_numgroups; I* Used to see if we did anything in this pass. 
int c; I* Current character. 
SET **current; I* Current group being processed. 
SET **new ; I* New partition being created. 
int first; I* State # of first element of current group. 
int next; I* State # of next element of current group. 
int goto_ first; I* target of transition from first [c). 
int goto_next; I* other target of transition from first [c). 
ROW *dtran 
ACCEPT *accept *dfap; 
*acceptp; 
init_groups( nstates, accept ); 
do 
{ 
old_numgroups = Numgroups; *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
for( current= &Groups[O]; current< &Groups[Numgroups]; ++current ) 
{ 
if( num_ele( *current ) <= 1 ) 
continue; 
new 
*new &Groups[ Numgroups ]; 
newset(); 
next_member( NULL); 
first= next_member( *current); 
while( (next= next_member(*current)) >= 0) 
{ 
for( c = MAX_CHARS; --c >= 0 ;) 
{ 
goto_first 
goto_next dtran[ first] [ c ]; 
dtran[ next ] [ c ]; 
if( goto_first != goto_next 
&&( goto_first ==-F 
I I goto_next == F 
I I Ingroup[goto_first] != Ingroup[goto_next] 
REMOVE( *current, next); 
ADD ( *new, next ) ; 
Ingroup[ next ] = Numgroups 
break; 
if( IS_EMPTY( *new ) 
delset( *new); I* Move the state to 
I* the new partition *I 
*I 
.... 
Section 2.5.8-DFA Minimization-Implementation 139 
Listing 2.44. continued ... 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 else 
++Numgroups; 
while( old_numgroups != Numgroups ) ; 
if( Verbose > 1 ) 
{ 
printf("\nStates grouped as follows after minimization:\n"); 
pgroups( nstates ) ; 
fix_dtran( dfap, acceptp ); 
l*----------------------------------------------------------------------*1 
PRIVATE void fix_dtran( dfap, acceptp ) 
ROW *( dfap[] ); 
ACCEPT *( *acceptp); 
{ 
I* Reduce the size of the dtran, using the group set made by minimize(). 
* Return the state number of the start state. The original dtran and accept 
* arrays are destroyed and replaced with the smaller versions. 
* Consider the first element of each group (current) to be a 
* "representative" state. Copy that state to the new transition table, 
*modifying all the transitions in the representative state so that they'll 
* go to the group within which the old state is found. 
*I 
SET **current 
ROW *newdtran 
ACCEPT *new accept 
int state 
int i 
int *src, *dest 
ROW *dtran *dfap; 
ACCEPT *accept = *acceptp; 
newdtran 
new accept (ROW *) calloc( Numgroups, sizeof(ROW ); 
(ACCEPT*) calloc( Numgroups, sizeof(ACCEPT) ); 
if( !newdtran I I !newaccept ) 
ferr("Out of memory!!!"); 
next_member( NULL); 
for( current= &Groups[Numgroups]; --current>= Groups; ) 
{ 
dest 
state 
src &newdtran[ current-Groups ] [ 0 ]; 
next_member(*current) ; 
& dtran[ state] [ 0 ]; 
newaccept[ current-Groups ]=accept[state]; I* All groups have at *I 
I* least one element. *I 
I* Struct. assignment *I 
for( i = MAX_CHARS; --i >= 0 ; src++, dest++ 
*dest = (*src ==F) ? F : Ingroup[ *src ]; 
140 Input and Lexical Analysis -Chapter 2 
Listing 2.44. continued ••• 
218 free ( *dfap ) ; 
219 free ( *acceptp ) ; 
220 *dfap newdtran 
221 *acceptp = newaccept 
222 
Listing 2.45. minimize.c- Debugging Routines 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 PRIVATE void pgroups( nstates ) 
int nstates ; 
/* Print all the groups used for minimization. */ 
SET **current; 
for( current= &Groups[Numgroups] ; --current>= Groups 
{ 
printf( "\tgroup %d: {", current- Groups); 
pset( *current, fprintf, stdout ); 
printf( "}\n" ) ; 
printf("\n"); 
while( --nstates >= 0 ) 
printf("\tstate %2d is in group %2d\n", nstates, Ingroup[nstates] ); 
Dead states. There are actually two additional minimizations that could be done here and are not: 
dead states-nonaccepting states that have no outgoing transitions other than ones that 
loop back into the current state--can be removed, as can unreachable states-states with 
no incoming edges. In practice, both types of states are rare, so it didn't seem worth the 
effort to remove them. I'll leave this further minimization as an exercise. Unreachable states. 
Generate yy _next () 
function: defnext () 
Printing two-dimensional 
arrays: print_array () 2.5.9 Compressing and Printing the Tables 
The remainder of this chapter describes the remainder of LEX-primarily housekeep­
ing and table-printing functions. Skip to the next chapter if you're not following the 
implementation details. 
This section discusses three table-output routines: one for uncompressed tables, one 
for pair-compressed tables, and a third routine that eliminates redundant rows and 
columns and prints the result. The first two of these are of sufficient general 1 ility to be 
put in a library. The third routine is used only by IJX. 
2.5.9.1 Uncompressed Tables. The uncompressed tables are printed by two sub­
routines in two separate input files. The defnext ( ) routine in Listing 2.46 prints the 
yy _next ( ) macro definition-yy _next () figures the next state from the current state 
and input character. The array access is hidden in a macro so that the state-machine 
driver can call yy _next ( ) for the next state, regardless of the compression method 
used. Each compression method supplies a different version of yy _next ( ) . 
The uncompressed two-dimensional array is output by print_array () in Listing 
2.47. The routine is passed a FILE pointer for the output stream, a pointer to the array, 
and the two dimensions. It is configured to print an array of ints, but you can change 
Section 2.5.9-Compressing and Printing the Tables 
Listing 2.46. defnext.c- Print Next-State Macro: Uncompressed Table 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/compiler.h> /* needed only for prototype */ 
PUBLIC void defnext(fp, name) 
FILE *fp; 
char *name; 
{ 
/*Print the default yy_next(s,c) subroutine for an uncompressed table. */ 
static char *comment text[] = 
{ 
} ; "yy_next(state,c) is given the current state and input character and", 
"evaluates to the next state.", 
NULL 
comment( fp, comment_text ); 
fprintf( fp, "#define yy_next(state, c) %s[ state] [ c ]\n", name); 
this type by modifying the typedef for A TYPE on line eight. The array is treated inter- ATYPE 
nally as a one-dimensional array having nrows x ncols cells. The main use of the row 
size (nrows) is to print the inner brackets on lines 28 and 43. NCOLS, defined on line NCOLS 
nine, determines how many array elements are printed on each output line. It controls 
formatting only-not any of the actual array dimensions. print_array () just prints 
the initialization part of the declaration (and the terminating semicolon). It doesn't print 
the actual declaration. Use it like this: 
printf("unsigned char Array[%d] [%d]=\n", nrows, ncols ); 
print_array( stdout, array, nrows, ncols ); 
The declared type of the output array (unsigned char above) is immaterial, even 
though the input array must be ints. It's up to you to make sure that all values in the 
input array fit into the cells of the output array. In the current example, no cell in the 
input array can have a value greater than 255 or the number will effectively be truncated. 
2.5.9.2 Pair-Compressed Tables. The next set of routines, in Listing 2.48, produce 
pair-compressed tables, as were pictured in Figure 2.7 on page 70. Various macros on 
lines 21 to 26 control the names and types used for both the input and output array. 
A TYPE and NCOLS are used as before: they are the declared type of the input array and ATYPE, NCOLS 
the number of columns on one line of the output array. The other three definitions are 
used for the storage class of the array and the type of one array cell. The printed tables 
assume that the table type and storage class are defined somewhere-you have to put 
something like the following at the top of the file in which the tables are placed: 
typedef unsigned char YY_TTYPE; 
#define YYPRIVATE static 
Note that the yy _next () , which figures the next state, can be declared with a different 
storage class than the tables themselves (though it isn't in the current configuration). 
This way you can have a public decoding routine and static tables. 141 
The table-generation routine, pairs (),starts on line 29 of Listing 2.48. It is passed 
three more arguments than print _array ( ) . The name argument is the name used for 
the output arrays. The names for the arrays that represent rows are manufactured by Printing pair-compressed 
tables: pairs () 
142 Input and Lexical Analysis -Chapter 2 
Listing 2.47. print ar.c-Print A Two Dimensional Array 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 43 
44 
45 
46 #include <stdio.h> 
#include <toolsldebug.h> 
#include <toolslcompiler.h> I* for prototypes only *I 
1*----------------------------------------------------------------------
* PRINT AR.C: General-purpose subroutine to print out a 2-dimensional array. 
*I 
typedef int ATYPE; 
#define NCOLS 10 I* Number of columns used to print arrays *I 
1*----------------------------------------------------------------------*l 
PUBLIC void 
FILE *fp; print_array( fp, array, nrows, ncols ) 
A TYPE *array; 
nrows; 
ncols; I* DFA transition table *I 
*I 
*I int 
int 
{ I* Number of rows in array[] 
I* Number of columns in array[] 
I* Print the C source code to initialize the two-dimensional array pointed 
* to by "array." Print only the initialization part of the declaration. 
*I 
int 
int i; 
col; I* Output column 
fprintf ( fp, " { \n" ) ; 
for( i = 0; i < nrows i++ 
{ 
fprintf(fp, "I* %02d *I , , i ) ; 
for( col = 0; 
{ col < ncols; col++ 
fprintf(fp, "%3d", *array++); 
if( col < ncols-1 
fprintf(fp, ", "); *I 
if( (col % NCOLS) == NCOLS-1 && col != ncols-1 ) 
fprintf (fp, "\n 
if( col > NCOLS ) 
fprintf( fp, "\n 
fprintf( fp, " }%c\n", 
fprintf(fp, "};\n"); ) ; 
i < nrows-1 ? ") ; 
, , , , ) ; 
threshold argument to 
pairs() putting a numeric suffix at the end of this string. The array of pointers to rows uses the 
string without modification. The threshold argument determines the point at which 
character/next-state pairs are abandoned in favor of a one-dimensional array. If the 
number of transitions in a row are less than or equal to threshold, then pairs are used, 
otherwise an array is used. Finally, numbers controls the output format of the character 
part of the pair. If it's true, a decimal number is used (an ASCII 'a', for example, is 
output as 97); if false, character constants are used (an 'a' is printed as an 'a'). 
The pairs ( ) routine returns the number of cells used to store the row arrays. The 
number of bytes used by the entire table is: 
Section 2.5.9-Compressing and Printing the Tables 
(number_ of_ cells x sizeof (TYPE) ) + (nrows x sizeof (TYPE*) ) 
The rows are printed in the loop that starts on line 52 of Listing 2.48. The loop on 
line nine counts the number of nonfailure transitions in the row, and the row is generated 
only if there are nonfailure transitions. The elements themselves are printed in the loop 
on line 75. The second half of the subroutine, on lines 110 to 129 prints out the array of 
pointers to the rows. The pnext ( ) subroutine that starts on line 135 prints the next­
state subroutine (it's too big to be a macro). 
Listing 2.48. pairs.c- Pair Compression 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <toolsldebug.h> 
#include <toolslcompiler.h> I* for prototypes only *I 
I* PAIRS.C 
* 
* 
* 
* Yy_nxt: This module contains the routines to compress a table 
horizontally (using char/next pairs) and then print the 
compressed table. The compressed array looks like this: 
Yy_nxtDD: 
* * +------+ +-------+----------------------------------------+ 
*--1---->1 0 I Next state array, indexed by character I 
* +------+ 
* +-------+----------------------------------------+ 
* +------+ +-------+----+----+----+----+-----+ 
* *--1---->1 count I cl I sl I c2 I s2 I ... I 
+-------+----+----+----+----+-----+ * +------+ 
* I NULL I 
* +------+ 
*I (there are no non-failure transitions if NULL) 
typedef int A TYPE; I* Declared type of input tables *I 
#define NCOLS 10 I* Number of columns used to print arrays *I 
#define TYPE "YY TTYPE" I* Declared type of output tables. *I 
#define SCLASS "YYPRIVATE" I* Storage class of all the tables *I 
#define D SCLASS "YYPRIVATE" I* Storage class of the decoding routine *I 
1*----------------------------------------------------------------------*l 
PUBLIC int pairs( fp, array, nrows, ncols, name, threshold, numbers ) 
FILE *fp; I* output file *I 
A TYPE *array; I* DFA transition table *I 
int 
int 
char 
int int 
{ nrows; I* Number of rows in array[ 1 *I 
ncols; I* Number of columns in array[ 1 *I 
*name; I* Name used for output array. *I 
threshold; I* Array vs. pairs threshold *I 
numbers; I* Use numbers for char. part of pair *I 
I* Generate the C source code for a pair-compressed DTRAN. Returns the 
* number of cells used for the YysDD arrays. The "numbers" argument 
* determines the output format of the character part of a 
* character/next-state pair. If numbers is true, then normal numbers 
*are used, otherwise ASCII characters are used. For example: 'a',lOO 
*as compared to: 97,100 ('a'== Ox61 == 97, decimal). 
*I 143 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 int 
int i, j, ntransitions, nprinted, ncommas; 
num cells = 0; I* cells used for rows *I 
A TYPE *p; 
144 Input and Lexical Analysis -Chapter 2 
Listing 2.48. continued ... 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 char *bin_to_ascii(); 
for( i = 0; i < nrows ; i++ 
{ 
ntransitions = 0; 
for( p =array+ (i * ncols), j 
if ( *p ! = -1 ) 
++ntransitions 
if( ntransitions > 0 ) 
{ ncols; --j >= 0; p++ ) 
fprintf(fp, "%s %s %s%-2d[] = { ", SCLASS, TYPE, name, i ); 
++num cells; /*}*/ 
if( ntransitions > threshold 
fprintf(fp, "0,\n 
else II) i 
fprintf (fp, "%2d, ", ntransitions ) ; 
if( threshold > 5 ) 
nprinted 
ncommas fprintf (fp, "\n " ) ; 
NCOLS; 
ntransitions; /* array */ 
/* pairs */ 
for( p =array+ (i * ncols), 
{ 0; j < ncols; j++, p++ 
if( ntransitions > threshold 
{ 
++num cells 
--nprinted 
fprintf (fp, "%3d" , *p ) ; 
if ( j < ncols-1 
fprintf(fp, ", "); 
else if( *p != -1 ) 
{ 
num cells += 2; 
if( numbers ) 
fprintf(fp, "%d,%d", j, *p ); 
else /* array */ 
/* pairs */ 
fprintf(fp, "'%s',%d", bin to_ascii(j,O), *p ); 
nprinted -= 2; 
if( --ncommas > 0 ) 
fprintf(fp, ", "); 
if( nprinted <= 0 ) 
{ 
fprintf(fp, "\n 
nprinted = NCOLS; 
fprintf(fp, "};\n" ); " ) ; 
Section 2.5.9-Compressing and Printing the Tables 
Listing 2.48. continued ••• 
fprintf(fp,"\n%s %s *%s[ %d ] =\n{\n 
nprinted = 10; 
for( --nrows, i = 0; i < nrows 
{ 
ntransitions = 0; i++ ) ", SCLASS, TYPE, name, nrows ); 
I* 10 elements on a line *I 
for( p =array+ (i * nco1s), j 
if( *p != -1 ) 
++ntransitions ; nco1s; --j >= 0; p++ ) 
fprintf(fp, ntransitions ? "%s%-2d, " 
if( --nprinted <= 0 
{ 
fprintf(fp,"\n "); 
nprinted = 10; 
fprintf(fp, "%s%-2d\n);\n\n", name, i ); 
return num_ce1ls; "NULL, ", name, i ); 
1*----------------------------------------------------------------------*l 
PUBLIC void pnext( fp, name ) 
char 
FILE 
{ *name; 
*fp; 
I* Print out a next(state,c) subroutine for a table compressed *I 
I* into char/next-state pairs by the routines in pairs.c. *I 
static char *toptext[]= 
{ 
"unsigned int C ... 
I I 
"int cur state 
"{", ·" I I 145 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 157 158 
159 
160 
161 
162 
163 
164 
165 
166 167 
168 
169 I* Given the current state and the current input character, return", 
* the next state.", 
*I", 
1111 
I 
NULL 
) ; 
static char *boptext[]= 
{ 
II 
1111 
I 
1111 
I 
II 
II} II f 
NULL 
) ; int l .... 
I I 
if ( P ) II 1 
{", 
)", if( (i = *p++) == 0 )", 
return p[ c ];", 
for( ; --i >= 0 ; p += 2 )", 
if ( C == P [ 0 ] ) II 1 
return p[1];", 
return YYF; ", 
146 
Listing 2.48. continued ••• 
170 
171 
172 
173 
174 
175 fprintf 
fprintf 
printv 
fprintf 
printv Input and Lexical Analysis -Chapter 2 
(fp, "\n/*--------------------------------------------------*1\n"); 
(fp, "%s %s yy_next( cur_state, c )\n", D_SCLASS, TYPE ); 
(fp, toptext ) ; 
(fp, " %s *p = %s[ cur state] ;\n", TYPE, name); 
(fp, boptext ) ; 
2.5.9.3 Redundant-Row-and-Column-Compressed lables. The routines to 
print the array with redundant row and columns removed are in Listing 2.49. Since these 
are used only in IJ'X, I've taken less pains to make them as flexible as possible. The sub­
routine goes through the array column by column using the algorithm in Table 2.13. The 
same algorithm is used to compress the rows. Note that the row compression creates a 
single row that contains nothing but failure transitions. This approach seems better than 
setting the map-array entries to a failure marker because it makes the array access both 
more consistent and faster at the cost of only a few bytes-you don't have to test for 
failure before indexing into the map array. 
Table 2.13. Algorithm to Eliminate Redundant Columns 
array 
map 
save 
i,j 
Initially: array to compress 
the map array being created 
is the set of columns that are not redundant 
counters 
save is empty. 
for( i =each column in array ) 
I 
} 
j=O; while( i is a column that's already been marked as redundant) 
++i; 
add i to save set; 
j = i+l ; 
while( j < rightmost column ) 
if( column i = column j ) 
I 
column mapUJ = i; 
mark j as redundant; 
for( i = each element of save set ) 
I 
copy column ito columnj; 
++j; 
Section 2.5.9-Compressing and Printing the Tables 
Listing 2.49. squash.c- Redundant Row and Column Elimination 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 #include <stdio.h> 
#include <ctype.h> 
#ifdef MSDOS 
# include <stdlib.h> 
#else 
# include <malloc.h> 
#endif 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/compiler.h> 
#include "dfa.h" 
#include "globals.h" 
/* SQUASH.C --This module contains the routines to compress a table 
* horizontally and vertically by removing redundant columns and rows, and 
* print the compressed table. I haven't been as careful about making this 
* routine general purpose because it's only useful to LeX. The pairs 
* compression routines in pairs.c are used to compress the aces-and 
* llama-generated tables so they're a little more complicated. 
*I 
PRIVATE int Col_map[ MAX CHARS l ; 
PRIVATE int Row_map[ DFA MAX l ; 
#define NCOLS 16 
#define TYPE "YY TTYPE" /* Declared type of output tables. *I 
#define SCLASS "YYPRIVATE" /* Storage class of all the tables *I 
/*----------------------------------------------------------------------
* Subroutine in this file: 
*I 
PRIVATE int col _equiv int*, int*, int ) ; 
PRIVATE void col _cpy int*, int*, int I int I int ) ; 
PRIVATE void reduce ROW*, int*, int* ) ; 
PRIVATE void print_col_map FILE* ) ; 
PRIVATE void print_row_map FILE* I int ) ; 
PUBLIC void pmap FILE* I int*, int ) ; 
PUBLIC void cnext FILE* I char* ) ; 
PUBLIC int squash FILE* I ROW*, int I int, char* ) ; 
/*----------------------------------------------------------------------*/ 
#define ROW_EQUIV(rl,r2,ncols) 
#define ROW_CPY(rl,r2,ncols) (memcmp( rl, r2, ncols * sizeof(int))==O 
(memcpy( rl, r2, ncols * sizeof(int)) 
/*----------------------------------------------------------------------*/ 
PUBLIC int squash( fp, dtran, nrows, ncols, name ) 
FILE 
ROW 
char *fp; 
*dtran; 
*name; 
/* Compress (and output) dtran using equivalent-column elimination. 
* Return the number of bytes required for the compressed tables 
* (including the map but not the accepting array). 
*I 147 
then 
148 Input and Lexical Analysis -Chapter 2 
Listing 2.49. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 int oncols 
int onrows ncols; 
nrows; I* original column count *I 
I* original row count *I 
reduce( dtran, &nrows, &ncols ); 
print_col_map 
print_row_map fp ); 
fp, onrows ); I* Compress the tables *I 
fprintf(fp, "%s %s %s[ %d] [ %d ]=\n", SCLASS, TYPE, name, nrows, ncols); 
print_array( fp, (int *)dtran, nrows, ncols ) ; 
return( nrows * ncols * sizeof(TTYPE)) 
+( onrows * sizeof(TTYPE)) 
+( oncols * sizeof(TTYPE)) ); I* dtran *I 
I* row map *I 
I* col map *I 
1*----------------------------------------------------------------------*l 
PRIVATE 
int int col_equiv( coll, col2, nrows ) 
*coll, *col2; 
{ 
I* Return 1 if the two columns are equivalent, else return 0 *I 
while( --nrows >= 0 && *coll == *col2 ) 
{ 
coll += MAX_CHARS; 
col2 += MAX_CHARS; I* Advance to next cell in the column *I 
return( ! (nrows >= 0) ); 
1*- - - - - - - - - - - *I 
PRIVATE void col_cpy( dest, src, nrows, n src cols, n dest cols -int *dest; I* Top of destination column *I 
int *src; I* Top of source column *I 
int nrows; I* Number of rows *I 
int n_src_cols; I* Number of columns in source array *I 
int n_dest_cols; I* Number of columns in destination array *I 
I* Copy a column from one array to another. Both arrays are nrows deep, 
* the source array is n src cols wide and the destination array is 
* n dest cols wide. 
*I 
while( --nrows >= 0 
{ 
*dest 
dest 
src *src; 
+= n dest_cols; 
+= n_src_cols; 
1*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *I 
PRIVATE void reduce( dtran, p nrows, p_ncols 
ROW 
int 
int *dtran; 
*p_nrows; 
*p_ncols; I* DFA transition table 
I* # of states in dtran 
I* Pointer to column count *I 
*I 
*I 
Section 2.5.9-Compressing and Printing the Tables 
Listing 2.49. continued ... 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
!50 
!51 
!52 
!53 
!54 
!55 !56 
!57 
!58 
!59 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 I* Reduce dtran horizontally and vertically, filling the two map arrays 
* with the character mapping to the final, reduced transition table. 
* Return the number of columns in the reduced dtran table. 
* 
* Col_map is the x (character) axis, Row_map is the y (next state) axis. 
*I 
int nco1s = *p_nco1s; I* number of columns in original machine 
int nrows = *p_nrows; I* number of rows in original machine 
int r nco1s; I* number of columns in reduced machine -int r nrows; I* number of rows in reduced machine -SET *save; I* rows or columns that will remain in table 
int *current; I* first of several identical columns 
int *compressed; I* pointer to compressed array 
int *p; 
int i, j; 
I* ........................................................... . 
* First do the columns. 
*I 
memset( Co1_map, -1, sizeof(Co1_map) ); 
save newset(); 
for( r nco1s = 0 ;; r_nco1s++ ) 
{ 
I* Skip past any states in the Col map that have already been 
* processed. If the entire Col_map has been processed, break. 
*I 
for(i r_nco1s; Co1_map[i] != -1 && i < nco1s 
if( i >= nco1s 
break; i++ ) 
I* Add the current column to the save set. It eventually ends up 
* in the reduced array as column "r_ncols" so modify the Col_map *I 
*I 
*I 
*I 
*I 
*I 
*I 
* entry accordingly. Now, scan trough the array looking for 
*duplicates of the current column (pointed to by current). If you 
* find a duplicate, make the associated Col_map entry also point to 
* "r ncols." 
*I 
ADD( save, i ) ; 
Co1_map[i] r_nco1s; 
current &dtran[O] [i]; 
p current + 1; 
for( j = i; ++j < nco1s ; p++ ) 
if( Co1_map[j]==-l && col_equiv(current, p, nrows) ) 
Co1_map[j] r nco1s 
I* Compress the array horizontally by removing all of the columns that 
*aren't in the save set. We're doing this by moving all the columns 
* that are in the save set to the proper position in a newly allocated 
* array. You can't do it in place because there's no guarantee that the 149 
... 
150 Input and Lexical Analysis -Chapter 2 
Listing 2.49. continued ... 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 * equivalent rows are next to each other. 
*I 
if( ! (compressed= (int *) malloc(nrows * r ncols * sizeof(int))) ) 
ferr ("Out of memory") ; 
p = compressed; 
for( next_member(NULL); (i = next_member(save)) != -1; ) 
col_cpy( p++, &dtran[O] [i], nrows, ncols, r_ncols ); 
/* ........................................................... . 
* 
* 
* 
*I Eliminate equivalent rows, working on the reduced array 
created in the previous step. The algorithm used is the 
same. 
memset( Row_map, -1, sizeof(Row_map) ); 
CLEAR ( save ) ; 
for( r_nrows 0 ;; r_nrows++ ) 
{ 
/* for{ i r_nrows; Row_map[i] != -1 && i < nrows; i++ ) 
if( i >= nrows 
break; 
ADD( save, i ); 
Row_map[i] r_nrows; 
current compressed+ ((i ) * r ncols ); 
compressed+ ((i+1) * r ncols ); p 
for( j = i; ++j < nrows ; p += r_ncols ) 
if( Row_map[j]==-1 && ROW_EQUIV(current, p, r_ncols) 
Row_map[j] r nrows 
* Actually compress rows, copying back into the original array space. 
* Note that both dimensions of the array have been changed. 
*I 
p = (int *)dtran; 
for( next_member(NULL); (i 
{ next_member(save)) != -1; ) 
ROW_CPY( p, compressed+ (i * r_ncols) , r ncols ); 
p += r_ncols; 
del set save ) ; 
free compressed ) ; 
*p_ncols r ncols 
*p_nrows r nrows 
Section 2.5.9-Compressing and Printing the Tables 151 
Listing 2.49. continued ... 
l*----------------------------------------------------------------------*1 
PRIVATE void print_col_map( fp ) 
FILE *fp; 
{ 
static char *text[] = 
{ 
"The Yy_cmap [] and Yy_rmap arrays are used as follows:", 
"" I 
" next state= Yydtran[ Yy_rmap[current_ state] l [ Yy_cmap[input_char] ]·" -I I 
"" I 
"Character positions in the Yy_cmap array are:", 
II 
I 
A@ AA AB Ac AD AE AF AG AH AI AJ AK AL AM AN "'0", 
Ap AQ AR As AT Au Av Aw Ax Ay Az A [ A\\ A l A " I 
\" # $ % & ( ) * + /", 
0 1 2 3 4 5 6 7 8 9 < > ?II 
• I 
@ A B c D E F G H I J K L M N 0", 
p Q R s T u v w X y z [ \\ l II 
I 
a b c d e f g h i j k 1 m n o", 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 p q r s t u v w X y z { I DEL", 
NULL 
} ; 
comment(fp, text); 
fprintf(fp, "%s %s Yy_cmap[%d] =\n{\n 
pmap (fp, Col_map, MAX CHARS); 
PRIVATE void print_row_map( fp, nrows ) 
FILE *fp; 
int nrows; 
{ 
fprintf(fp, "%s %s Yy_rmap[%d] =\n{\n 
pmap (fp, Row_map, nrows ); 
PRIVATE void pmap( fp, p, n ) 
FILE 
int 
int *fp; 
*p; 
n; 
/* Print a one-dimensional array. 
*I 
int j; 
for( j = 0; j < (n-1); j++ ) 
{ 
fprintf(fp, "%3d," , *p++ ); 
if( (j % NCOLS) NCOLS-1 ) 
fprintf(fp, "\n "); 
fprintf( fp, "%3d\n};\n\n", *p ); ", SCLASS, TYPE, MAX CHARS); 
", SCLASS, TYPE, nrows ); 
/* output stream *I 
/* pointer to array */ 
/* array size */ 
... 
152 Input and Lexical Analysis -Chapter 2 
Listing 2.49. continued ••• 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 1*----------------------------------------------------------------------*l 
PUBLIC void cnext( fp, name ) 
FILE *fp; 
char *name; 
{ 
I* Print out a yy_next(state,c) subroutine for the compressed table. 
*I 
static char *text[] = 
{ 
} ; "yy_next(state,c) is given the current state number and input", 
"character and evaluates to the next state.", 
NULL 
comment( fp, text); 
fprintf ( fp, 
) ; "#define yy_next (state, c) (%s [ Yy_rmap [state] ] [ Yy_cmap [c] ] ) \n", 
name 
2.5.1 0 Tying It All Together 
LEX is completed by the subroutines presented in this section. (in Listings 2.50, 2.51, 
2.52, and 2.53 ). These listings are commented sufficiently that additional comments here 
would be tedious. Read the code if you're interested. 
I should also add, at this point, that there are more efficient methods than the one I've 
just described for converting a regular expression to a finite automata. (See [Aho] pp. 
134-141.) I've chosen the current method because it serves to introduce several con­
cepts (like closure) that will be useful later on. 
Listing 2.50. signon.c- Print Sign-on Message 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 18 
19 #include <stdio.h> 
#include <toolsldebug.h> 
signon () 
{ 
I* Print the sign-on message. Since the console is opened explicitly, the 
* message is printed even if both stdout and stderr are redirected. 
*I 
FILE *screen; 
UX( if( ! (screen= fopen("ldevltty", "w")) 
MS( if( ! (screen= fopen("con:", "w")) 
screen = stderr; 
I* The ANSI 
I* The DATE DATE macro yields a string of the form: "Sep 01 1989". *I 
+7 gets the year portion of that string. *I 
Section 2.5.10- Tying It All Together 
Listing 2.50. continued ... 
20 fprintf (screen, "LeX 1. 0 [%s]. (c) %s, Allen I. Holub. " 
21 "All rights reserved.\n", DATE DATE +7 ); 
22 
23 if( screen != stderr 
24 fclose(screen); 
25 
Listing 2.51. print.c- Print Remainder of Output File 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <ctype.h> 
#include <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslcompiler.h> 
#include "dfa.h" 
#include "nfa.h" 
#include "globals.h" 
I* 
* *I PRINT.C: This module contains miscellaneous print routines that do 
everything except print the actual tables. 10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 43 
44 
45 
46 PUBLIC void pheader( FILE *fp, ROW dtran[], int nrows, ACCEPT *accept); 
PUBLIC void pdriver( FILE *output, int nrows, ACCEPT *accept); 
1*------------------------------------------------------------*l 
PUBLIC 
FILE 
ROW 
int 
ACCEPT 
{ void pheader( fp, 
*fp; 
dtran[]; 
nrows; 
*accept; dtran, nrows, accept 
I* output stream 
I* DFA transition table 
I* Number of states in dtran[] 
I* Set of accept states in dtran[] *I 
*I 
*I *I 
I* Print out a header comment that describes the uncompressed DFA. *I 
int 
int 
int 
char i, j; 
last transition 
chars _printed; 
*bin_to_ascii () 
fprintf (fp, "#ifdef NEVER \n" ) ; 
fprintf(fp, "1*---------------------------------------------------\n"); 
fprintf(fp, " * DFA (start state is 0) is:\n *\n" ); 
for( i = 0; i < nrows ; i++ 
{ 
if( !accept[i] .string ) 
fprintf(fp, " *State %d [nonaccepting]", i ); 
else 
fprintf(fp, " * State %d [accepting, line %d <", 
i , ( (int *)(accept [i] .string)) [-1] ) ; 
fputstr( accept[i] .string, 20, fp ); 
fprintf(fp, ">]" ); 153 
.... 
154 Input and Lexical Analysis -Chapter 2 
Listing 2.51. continued ... 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 if( accept[i] .anchor ) 
& START ? "start " 1111 , fprintf( fp, " Anchor: %s%s", 
accept[i] .anchor 
accept[i] .anchor & END ? "end" II II ) ; 
last transition = -1; 
for( j = 0; j < MAX_CHARS; j++ ) 
{ 
if( dtran[i] [j] != F ) 
{ 
if( dtran[i] [j] != last_transition ) 
{ 
fprintf(fp, "\n * 
chars_printed 0; goto %2d on ", dtran[i] [j] ) ; 
fprintf(fp, "%s", bin_to_ascii(j,l) ); 
if( (chars_printed += strlen(bin_to_ascii(j,l))) >56) 
( 
fprintf(fp, "\n * 
chars_printed = 0; 
last transition 
fprintf (fp, "\n"); 
fprintf(fp," *1\n\n" ); 
fprintf(fp,"#endif\n" ) ; dtran [i] [ j]; II ) ; 
1*--------------------------------------------------------------*l 
PUBLIC void pdriver( output, nrows, accept 
FILE *output; 
int 
ACCEPT 
( nrows; 
*accept; I* Number of states in dtran[] 
I* Set of accept states in dtran[] *I 
*I 
I* Print the array of accepting states, the driver itself, and the case 
* statements for the accepting strings. 
*I 
int i; 
static char *text[] = 
( 
"The Yyaccept array has two purposes. If Yyaccept[i] is 0 then state", 
"i is nonaccepting. If it's nonzero then the number determines whether", 
"the string is anchored, !=anchored at start of line, 2=at end of", 
"line, 3=both, 4=line not anchored", 
NULL 
} ; 
comment( output, text); 
fprintf(output, "YYPRIVATE YY TTYPE Yyaccept[] =\n" ); 
fprintf(output, "{\n" ); 
.... 
Section 2.5.10- Tying It All Together 
Listing 2.51. continued ... 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 for( i = 0 ; i < nrows ; i++ /* accepting array*/ 
{ 
if( !accept[i] .string ) 
fprintf( output, "\tO " ) ; 
else 
fprintf( output, "\t%-3d",accept[i] .anchor? accept[i] .anchor :4); 
fprintf (output, "%c /* State %-3d */\n", 
i == (nrows -1) ? ' ' i ) ; 
fprintf (output, "}; \n\n" ) ; 
driver 2( output, !No_1ines ); 
for( i = 0 ; i < nrows ; i++ 
{ 
if( accept[i] .string 
{ /* code above cases */ 
/* case statements */ 
fprintf(output, "\t\tcase %d:\t\t\t\t\t/* State %-3d */\n",i,i); 
if( !No_1ines ) 
fprintf(output, "#line %d \"%s\"\n", 
fprintf(output, "\t\t 
fprintf(output, "\t\t 
driver 2 ( output, !No lines ) ; *( (int *)(accept[i].string)- 1), 
Input file_name ); 
%s\n", 
break;\n" accept[i] .string 
) ; ) ; 
/* code below cases */ 
Listing 2.52./ex.c- main () and Other High-Level Functions (Part 1) 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 #include <stdio.h> 
#include <ctype.h> 
#include <stdarg.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include "dfa.h" 
#define ALLOCATE 
#include "globals.h" /* For vprintf() */ 
/*----------------------------------------------------------------------*/ 
PUBLIC void error (int usage, char *fmt, ... ) ; 
PUBLIC int main (int argc, char **argv); 
PRIVATE int get line (char **stringp, int n, FILE *stream); 
PRIVATE void do file (void); 
PRIVATE void tail (void); 
extern char *get_expr (void); /* in input.c *I 155 
... 
156 Input and Lexical Analysis -Chapter 2 
Listing 2.52. continued ... 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 1*----------------------------------------------------------------------*l 
#define DTRAN NAME "Yy_nxt" I* Name used for DFA transition table. Up to *I 
I* 3 characters are appended to the end of *I 
I* this name in the row-compressed tables. *I 
#define E(x) fprintf(stderr,"%s\n", x) 
PRIVATE int 
PRIVATE int Column_compress 
No_compression 
Threshold 1; I* Variables for command-line switches *I 
0; 
PRIVATE int 
PRIVATE int 
PRIVATE int 
extern int 
extern int 
extern int No header 
Header_only 
Verbose; 
No_lines; 
Lineno; 4; 
0; 0; 
I* in globals.h *I 
I* in globals.h *I 
I* In globals.h, the line number *I 
I* used to print #line directives. *I 
1*----------------------------------------------------------------------*l 
PRIVATE void cmd_line_error( usage, fmt, ... ) 
char *fmt; 
{ 
I* Print an error message and exit to the operating system. This routine is 
* used much like printf(), except that it has an extra first argument. 
* If "usage" is 0, an error message associated with the current value of 
* errno is printed after printing the format/arg string in the normal way. 
* If "usage" is nonzero, a list of legal command-line switches is printed. 
* * I'm using the ANSI conventions for a subroutine with a variable number of 
* arguments. These differ a little from the Unix V conventions. Look up 
* doprnt() [it's in the "printf(3S)" entry] in the Unix Programmer's 
* Manual for details. A version of the <stdarg.h> macros used here is in 
* Appendix A. 
*I 
extern char *sys_errlist[]; 
extern int errno; 
va list args; 
va_start(args, fmt); 
fprintf ( stderr, "lex: " ) ; 
vfprintf( stderr, fmt, args ); 
if( !usage ) 
fprintf( stderr, "(%s)\n", sys_errlist[errno] ); 
else 
{ 
E("\n\nUsage is: LeX [options] file" 
E("-f for (f)ast. Don't compress tables." 
E("-h suppress (h)eader comment that describes state machine." 
E("-H print the (H)eader only." 
E("-1 Suppress #(l)ine directives in the output." 
E("-mS Use stringS as template name rather than lex.par." 
E("-cN use pair (c)ompression, N =threshold (default 4) ." 
E("-t Send output to standard output instead of lexyy.c" 
E("-u UNIX mode, newline is \\n, not \\nor \\r" 
E("-v (v)erbose mode, print statistics." 
E("-V More (V)erbose, print internal diagnostics as lex runs." ) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; ... 
Section 2.5.1 0-Tying It All Together 
Listing 2.52. continued .•• 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
Ill 
112 
113 
114 115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 exit(l); 
va_end(args); 
/*----------------------------------------------------------------------*/ 
PUBLIC void lerror ( status, fmt, ... ) 
char 
{ *fmt; 
/* Print an error message and input line number. Exit with 
* indicated status if "status" is nonzero. 
*I 
extern int errno; 
va list args; 
va_start(args, fmt); 
fprintf ( stderr, "lex, input line %d: ", Actual lineno ); 
vfprintf ( stderr, fmt, args ) ; 
if( status ) 
exit( status); 
va_end(args); 
/*----------------------------------------------------------------------*/ 
PUBLIC main( argc, argv ) 
char 
{ **argv; 
static char *p 
static int use stdout 0; 
signon(); 
for( ++argv, --argc; argc && *(p 
{ 
while ( *++p 
{ 
switch( *p 
{ 
case , f': No _compression 
case 'h': No header 
case 'H': Header_only 
case , 1': No lines 
case 'm': Template 
case 'p': Public 
case 't': use stdout 
case 'u': Unix 
case 'v': Verbose 
case 'V': Verbose 
case , c': Column _compress *argv) 
1; 
1; 
1; 1; 
p + 1; 
1; 1; 1; 
1; 
2; 
= 0; 
if( !isdigit(p[l]) ) 
Threshold = 4; 
else 
{ '-'; ++argv, --argc ) 
break; 
break; break; 
break; 
goto out; 
break; 
break; 
break; 
break; 
break; 
Threshold atoi ( ++p ) ; 157 
.... 
158 Input and Lexical Analysis -Chapter 2 
Listing 2.52. continued ... 
140 while( *p && isdigit( p[l] ) ) 
++p; 141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 default: 
out:; 
if ( argc > 1 ) break; 
cmd line_error(l, "-%c illegal argument.", *p); 
break; 
cmd_line_error( 1, "Too many arguments. Only one file name permitted" ); 
else if( argc <= 0 ) 
cmd_line_error( 1, "File name required"); 
else I* argc == 1 *I 
{ 
if( Ifile = fopen(*argv,"r") 
Input_file_name = *argv; 
else 
cmd_line_error( 0, "Can't open input file %s", *argv ) ; 
if( !use_stdout ) 
if( ! (Ofile = fopen( Header_only? "lexyy.h" : "lexyy.c", "w"))) 
cmd_line_error( 0, "Can't open output file lexyy. [ch]" ); 
do file (); 
fclose ( Ofile ) ; 
fclose ( !file ) ; 
exit ( 0 ) ; 
1*----------------------------------------------------------------------*l 
PRIVATE void do_file( 
( 
int nstates; 
ROW *dtran; 
ACCEPT *accept; 
FILE *input, *driver 1(); 
int i; 
I* Process the input file *I I* Number of DFA states 
I* Transition table 
I* Set of accept states in dfa 
I* Template file for driver *I 
*I 
*I 
*I 
head( Header_only ); I* print everything up to first %% *I 
nstates = min_dfa( get_expr, &dtran, &accept); 
if( Verbose ) 
( I* make DFA *I 
printf("%d out of %d DFA states in minimized machine\n", nstates, 
printf("%d bytes required for minimized tables\n\n", 
nstates * MAX CHARS * sizeof(TTYPE) 
+ nstates * sizeof(TTYPE) ); DFA MAX ) ; 
I* dtran *I 
I* accept *I 
.... 
Section 2.5.1 0-Tying It All Together 
Listing 2.52. continued ... 
if( !No header 
pheader( Ofile, dtran, nstates, accept ); 
if( !Header_only 
{ I* print header *I 
I* comment. *I 
I* first part *I 
I* of driver. *I 
if( ! (input= driver_l( Ofile, !No_lines, Template )) ) 
( 
perror( Template ); 
exit (1); 159 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 if( No_compression 
( I* compressed tables *I 
fprintf (Ofile ,"YYPRIVATE YY TTYPE %s[ %d] [ %d] =\n", 
DTRAN_NAME, nstates, MAX_CHARS); 
print_array( Ofile, (int *)dtran, nstates, MAX CHARS ); 
defnext ( Ofile, DTRAN NAME); 
else if( Column_compress ) 
{ I* column-compressed tables. *I 
else 
{ i = squash 
cnext 
if( Verbose ) Ofile, dtran, nstates, MAX_CHARS, DTRAN NAME 
Ofile, DTRAN NAME ) ; 
) ; 
printf("%d bytes required for column-compressed tables\n\n", 
i I* dtran *I 
+ (nstates * sizeof(int)) ) ; I* Yy_accept *I 
I* pair-compressed tables *I 
i pairs ( Ofile, (int *) dtran, nstates, 
if( Verbose ) 
{ MAX_CHARS, DTRAN_NAME, Threshold, 0); 
I* Figure the space occupied for the various tables. The 
*Microsoft compiler uses roughly 100 bytes for the yy_next() 
* subroutine. Column compression does yy_next in line with a 
* macro so the overhead is negligible. 
*I 
i = (i 
+ (nstates 
+ (nstates 
+ 100 * sizeof(TTYPE )) 
* sizeof(TTYPE*)) 
* sizeof(TTYPE )) I* YysDD arrays 
I* Dtran [] 
I* Yy_accept [ 1 
I* yy_next () *I 
*I 
*I 
*I 
printf("%d bytes required for pair-compressed tables\n", i ); 
pnext( Ofile, DTRAN NAME); 
pdriver( Ofile, nstates, accept); 
tail() ; I* print rest of driver *I 
I* and everything following *I 
I* the second %% *I 
160 Input and Lexical Analysis -Chapter 2 
Listing 2.52. continued ... 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 1*----------------------------------------------------------------------
* Head processes everything up to the first %%. Any lines that begin 
* with white space or are surrounded by %{ and %} are passed to the 
* output. All other lines are assumed to be macro definitions. 
* A %% can not be concealed in a %{ %} but it must be anchored at start 
* of line so a %% in a printf statement (for example) is passed to the 
* output correctly. Similarly, a %{ and %} must be the first two characters 
* on the line. 
*I 
PRIVATE head( suppress_output 
int suppress_output; 
int transparent = 0; I* True if in a %{ %} block *I 
if( !suppress output && Public ) 
fputs( "#define YYPRIVATE\n\n", Ofile ); 
if ( !No_lines ) 
fprintf( Ofile, "#line 1 \"%s\"\n", Input file_name); 
while( fgets( Input_buf, MAXINP, Ifile) 
{ 
++ Actual lineno; 
if( !transparent ) 
strip_comments( Input_buf); I* Don't strip comments *I 
I* from code blocks. *I 
if( Verbose > 1 ) 
printf ( "h%d: %s", Actual_lineno, Input_buf ) ; 
if( Input_buf[O] == '%' 
{ 
if( Input_buf[1] == '%' 
{ 
if( !suppress_output ) 
fputs( "\n", Ofi1e ); 
break; 
else 
{ 
if( Input_buf[1] == '{' 
transparent = 1; 
else if( Input_buf[1] 
transparent = 0; 
else , }' ) I* J {*I 
lerror(O, "Ignoring illegal %%%c directive\n", 
Input_buf[1] ); 
else if( transparent I I isspace(Input_buf[O]) 
{ 
else 
{ if( !suppress_output ) 
fputs( Input_buf, Ofile ); 
new_macro( Input_buf ); 
Section 2.5.10-Tying It All Together 
Listing 2.52. continued ... 
319 
320 
321 
322 
323 
324 
325 
326 
327 328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365· 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 if( !suppress_output ) 
fputs( "\n", Ofile ); I* Replace macro def with a blank *I 
I* line so that the line numbers *I 
I* won't get messed up. *I 
if( Verbose > 1 ) 
printmacs(); 
1*----------------------------------------------------------------------*l 
strip_comments( string 
char *string; 
{ 
I* Scan through the string, replacing C-like comments with space 
* characters. Multiple-line comments are supported. 
*I 
static int incomment = 0; 
for(; *string ; ++string 
{ 
if( incomment ) 
{ 
else if( string[O]=='*' && string[!]==' I' ) 
{ 
incomment 0 
*string++ ' '; 
if( !isspace( *string) ) 
*string = ' '; 
if( string[O]=='I' && string[!]=='*') 
{ 
incomment 1 
*string++ ' '; 
*string ' '; 
1*----------------------------------------------------------------------*l 
PRIVATE void 
{ tail() 
fgets(Input_buf, MAXINP, Ifile); I* Throw away the line that 
I* had the %% on it. 
if( !No_lines ) 
fprintf( Ofile, "#line %d \"%s\"\n", 
Actual lineno + 1, Input_file_name) ; *I 
*I 161 
.... 
162 Input and Lexical Analysis -Chapter 2 
Listing 2.52. continued ••• 
377 while ( fgets (Input_buf, MAXINP, Ifile) ) 
378 ( 
379 if ( Verbose > 1 ) 
380 printf ( "t%d: %s", Actual lineno++, Input_buf ) ; 
381 
382 fputs(Input_buf, Ofile); 
383 
384 
2.6 Exercises 
2.1. Modify the simple expression grammar used in Chapter I so that COMMENT 
tokens can appear anywhere in the expression. This exercise demonstrates graph­
ically why it's useful for a lexical analyzer to do things like remove comments 
from the input. 
2.2. Write a lexical analyzer that processes the PL/1 statement 
if then then then = else; else else = then; 
correctly, distinguishing the keywords from the identifiers. 
2.3. Write a regular expression that can recognize all possible integer constants in C. 
All of the following should be recognized: 
Ox89ab 0123 45 'z' '\t' '\xab' '\012' 
2.4. Write a regular expression that recognizes a C identifier. Construct an NFA for 
this expression using Thompson's Construction, convert the NFA to a DFA using 
Subset Construction, and minimize the DFA. 
2.5. Write a set of input functions that can handle interactive input from a human 
being more elegantly than the ones in input.c. (They should support command­
line editing, and so forth). Your routines must work with the default driver gen­
erated by LEX (they must use the same interface as the default ones). The routines 
should be able to get input directly from the console, rather than from standard 
input. 
2.6. Use LEX to rewrite its own lexical analyzer. 
2.7. Write a set of regular expressions that can recognize C subroutine declarations. 
You can assume that the entire declaration is on one line. Declarations such as 
the following should be recognized: 
TYPE 
unsigned char 
int 
but not the following 
extern int 
sam( dave); *doo( wha, ditty ) 
( * foo () ) [ 10] 
( *signal (signal, ptr) ) () 
*signal (int signal, {*ptr) ()) ) (); 
2.8. Use the regular expressions developed in the previous exercise to write a U'X pro­
gram that inputs a list of C programs whose names are listed on the command 
line, and which outputs all subroutine declarations along with the name of the file 
in which they are found and their input line numbers. 
Section 2.6-Exercises 
2.9. Modify the previous exercise so that only the subroutine name is printed, rather 
than the entire declaration. 
2.10. Various UNIX editors support the \ ( and \) operators, which bracket subexpres­
sions in a regular expression. For example, an expression like this: 
\(abc\)def\(ghi\) 
recognizes the string abcdefghi, and the two substrings abc and ghi can be 
accessed later using the notation \1 and \2 respectively. Modify 1.9X to support a 
similar feature, but as follows: 
A subexpression in a regular expression is indicated with parenthesis. 
a. Modify 1.9X so that repeated subexpressions in the regular expressions them­
selves can be referenced using the notation \0, \1, and so forth. \0 refer­
ences the first subexpression, \ 1 the next one, and so forth. A 
subexpression's number is derived by counting the number of open 
parentheses to the left of the one that starts that subexpression. For example, 
the following regular expression recognizes three, comma-delimited decimal 
numbers: 
[0-9] +, [0-9] +, [0-9] + 
You should be able to express the same thing as follows: 
([0-9]+) (,)\0\1\0 
The \0 in the regular expression tells LEX to duplicate the first subexpression 
( [ 0-9) + ), the \1 duplicates the second (, ). 
The double-quote character and double backslash should still work as 
expected. Both of the following expressions should recognize an input string 
like "12 3 4 \ 1 \2 \ 1 ": 
( [0-9] +) (,) 11\1\2\1 II 
([0-9]+) (,)\\1\\2\\1 
The backslashes are treated as literal characters here. 
b. Modify 1.9X so that the lexemes associated with the matched subexpression 
can be accessed in an action using an argv-like array of string pointers called 
yyv: yyv [ 0) holds the lexeme that matches the first subexpression, yyv [ 1) 
the second, and so on. An integer called yyc should hold the number of valid 
entries in yyv. For example, the expression in the following rule recognizes 
the input pattern abcdefghi: 
((abc (def)) (ghi)) 
The associated action prints: 
abcdefghi 
abcdef 
def 
ghi while( --yyc >= 0 ) 
printf ("%s\n", *yyv++ ) ; 
2.11. Modify 1.9X to support a unary NOT operator. It should be higher precedence 
than the closure operators and lower precedence than concatenation. It should 
precede its operand. For example, ! c matches anything except the character c; the 
expression a! (be) should match an a followed by any sequence of characters 
other than the two character sequence be; ! (and 1 or) should match any string 
except and or or; finally, ! [a-z) should work just like ra-z]. Be careful of the 
newline, which should not be matched by any of the foregoing patterns. 163 
164 Input and Lexical Analysis -Chapter 2 
2.12. Add the I lookahead operator to I.FX. The expression alb-where a and bare 
both regular expressions -matches a, but only if it is followed by b. The charac­
ters that match b should not be put into the lexeme. In fact, they should be pushed 
back into the input after being recognized. For example, the regular expression 
abc/def should match an abc only if it's followed by a def, and the de/should be 
pushed back into the input for subsequent processing. You can simulate the $ 
operator with xxx/ [ \ r \n ). Similarly, the following pattern matches the string 
if, but only if the next nonwhite character isn't a semicolon, plus sign, minus sign, 
or asterisk: 
if/ [\s\t\n\r] * [-; +-*]' 
By the same token, if I [ \ s \ t \n \ r) * ( matches an if only if the next nonwhite 
character is an open parenthesis. 
2.13. Add the REJECT directive to I.FX. This directive selects the next alternative 
accepting action when regular expressions conflict. For example, the following 
recognizes the word he, even if it's imbedded in she: 
int he=O, she=O; 
%% 
he 
she ++he; REJECT; 
++she; REJECT; 
(.I \n) 
%% 
main() 
{ I* ignore *I 
yy1ex(); 
printf("Saw %d he's and %d she's\n", he, she); 
It recognizes the she first, then the REJECT action causes it to execute the code 
associated with the he regular expressions too. Note that it's not doing anything 
special with the input, it's only executing all possible accepting actions for the 
expression. The program should print 
Saw 2 he's and 1 she's 
when given the input: 
he she 
2.14. Add the X{a,b} operator to I.FX. This expression matches X repeated a to b times. 
For example 1 { 1, 3} ama recognizes lama, llama, and lllama. 
2.15. Add left-context sensitivity to I.FX. Do it like this: The statement 
%START NAME 
is placed in the first, definitions part of the I.FX input file. It creates a class of reg­
ular expressions that are active only in certain situations (discussed below). NAME 
can be an arbitrary name having up to eight characters. All regular expressions 
that start with <NAME> are placed in the class. The angle brackets must be present, 
like this: 
<NAME>(alb)* { some_code(); } 
Activate all states in the class with the following line anywhere in the code part of 
a rule: 
BEGIN NAME; 
That is, the earlier regular expression, (a/b)*, won't be recognized until a BEGIN 
Section 2.6-Exercises 
NAME has been executed in a code block. Use BEGIN 0; to disable all special 
regular expressions. An expression can be put into several classes like this: 
<NAME1,NAME2,NAME3>expression { some_code(); } 
Once an expression is activated, the usual input-file precedence rules are also 
active. That is, if a special expression occurs earlier in the input file than a 
conflicting expression, the special one takes precedence once it's activated. 
2.16. Modify IJlX to detect which of the two compression methods yields the smallest 
tables, and then use that method automatically. 
2.17. Add a command-line switch to IJlX that causes the two compression methods to 
be combined: Pair compression should be applied first, then a map array should 
be used to compress the uncompressed rows in the pair-compressed tables. Only 
one copy of two or more identical rows should be kept, with several pointers in 
Yy _ nxt [ ] addressing the single copy of the row. 
2.18. Modify the minimization routines to remove dead states-nonaccepting states 
that have no outgoing transitions other than ones that loop back into the current 
state. 
2.19. Modify the minimization routines to remove unreachable states-states that have 
no incoming edges. 
2.20. Sometimes it's useful for a program's users to be able to modify the token set 
when they install a program. This way, they can customize a program's input syn­
tax to fit their own preferences. Modify IJlX so that it produces a file containing 
binary representations of the state and auxiliary tables rather than C source code. 
Modify yylex () so that it reads the tables from this file into memory the first 
time it is called. This way, the user can change the IJlX input file and generate a 
new state table without having to recompile the program that is using that state 
table. 
Note that the actions still have to be put into the compiled program-there's no 
way to read them from disk at run time. Consequently, though the regular expres­
sions can be modified at installation time, the number of regular expressions must 
stay the same. The position of the regular expression from the top of the file 
determines the action to execute when that expression is recognized. That is, the 
second action in the original input file is executed when the second regular 
expression is matched, even if that expression is changed at installation time. 165 
Alphabet. 
String, word. 
Token. 
Language, sentence. 
Grammar, production. 
Syntax. 
Context-free grammar. 
Backus-Naur Form, ~. 
Left-hand side (LHS). 3 
Context-Free Grammars 
The discussion of formal grammars started in Chapter One continues here. I discuss 
the general, more theoretical aspects of grammars, but with emphasis on building real 
grammars, discussing precedence and associativity, list and expression grammars, and so 
forth. Attributed and augmented grammars are introduced as well, and they are put into 
the context of a recursive-descent parser. Grammars are discussed further in Chapter 
Four, where various grammatical transformations are presented. 
3.1 Sentences, Phrases, and Context-Free Grammars 
This section quickly summarizes the terms introduced in Chapters One and Two and 
extends these terms somewhat. 
An alphabet is a collection of characters. The ASCII character set is a good example 
of an alphabet. A string or word is a specific sequence of symbols from an input alpha­
bet. In compiler parlance, a word in the language is called a token-an indivisible lexi­
cal unit of the language. 
A language is a set of words, and a sentence is a sequence of one or more of the 
words that comprise the language. Strictly speaking, there is no inherent ordering of the 
words within the sentence, and that's where a grammar comes into play. A formal gram­
mar is a system of rules (called productions) that control the order in which words may 
occur in a sentence. 
The syntax of a sentence determines the relationships between the words and phrases 
in a sentence. That is, the syntax of a language controls the structure of a sentence and 
nothing more. Taking English as an example, the syntax of English requires that the sub­
ject precede the verb, or that an adjective must precede the noun that it modifies. The 
syntax rules tell you nothing about what the sentence actually means, however. 
Informally, a context1ree grammar is a system of definitions that can be used to 
break up a sentence into phrases solely on the basis of the sequence of strings in the 
input sentence. A context-free grammar is usually represented in Backus-Naur form 
(BNF), in which productions are represented as follows: 
part_of_speech ~definition 
The ~operator (often represented as ::=) is the "is defined as" or "goes to" operator. 
166 
Section 3.1-Sentences, Phrases, and Context-Free Grammars 167 
The left-hand side of the production (often abbreviated to LHS), is the name of the syn­
tactic unit within the language (noun, verb, prepositional phrase, and so forth). The 
right-hand side (or RHS) is a list of symbols that define the LHS. For example: Right-hand side (RHS). 
sentence ~subject predicate PERIOD 
A sentence is a subject, followed by a predicate, followed by a PERIOD. There are two 
types of symbols on the right-hand side: Nonterminal symbols are terms that have to be 
defined further somewhere in the grammar (they have to appear on a left-hand side), and 
terminal symbols such as tokens which need no further definition. The nonterminal 
nodes form interior nodes in the parse tree; the terminal nodes are all at the ends of 
branches. There are terminal symbols other than tokens, discussed below. 
So, a context-free grammar is one in which all input sentences can be parsed strictly 
on the basis of syntax. Formally, a context-free grammar is composed of the following: 
• A finite set of terminal symbols or tokens. 
• A finite set of nonterminal symbols. 
• A finite set of productions of the form s~a.. where s is a nonterminal symbol, and a. 
is a list of zero or more terminal and nonterminal symbols. s is called the left-hand 
side of the production and a. is called the right-hand side. Every nonterminal symbol 
that appears in the right-hand side in some production must also appear on a left­
hand side. No terminal symbols may appear on a left-hand side. 
• A single start or goal symbol from which all the productions derive. 
It's theoretically possible to have a "context-sensitive" grammar that does consider 
semantics when analyzing a sentence, but this type of grammar is beyond the scope of 
this book and won't be discussed further. 
A grammar cr.n also distinguish groups of words that are related syntactically. For 
example, in English, the syntax of the language helps separate a subject from a predicate, 
recognize prepositional phrases, and so forth. Each of these syntactically related lists of Nonterminal and terminal 
symbols. 
Context-free grammar: 
formal definition. 
words are called phrases. In a computer language, a loop-control statement and associ- Phrase. 
ated body is a phrase, as is an entire subroutine declaration. Note that the phrases can be 
organized hierarchically -a sentence can contain a predicate, which can in tum contain 
a prepositional phrase. A grammatical phrase can be as short as a single word: in C, a 
single identifier can comprise a phrase. It can also be empty-I'll discuss this case 
below. A production is a rule that describes the syntax of a single phrase. 
Syntactic rules are used to break a sentence into its component parts of speech and Parsing. 
analyze the relationship of one part to another (this process is called parsing the sen-
tence). The term is used in both linguistic and compiler theory. A parser is a computer 
program that uses a context-free grammar to parse an input sentence-to isolate the 
component parts of speech for subsequent processing. Most parser programs are also 
recognizer programs. They accept (returns yes) only if the input forms a syntactically Recognizer programs. 
correct sentence. The fact that a parser can also generate code is actually immaterial 
from a theoretical point of view. 
The parser can analyze only the structure of the sentence. Even in English, the syn­
tax of a sentence tells you nothing about what the sentence means. Meaning comes 
under the purview of semantics. A context-free grammar defines the structure of the sen-Semantics and syntax. 
tence only. It tells you nothing about the semantics-the meanings of the words-
except that you can sometimes infer meaning from the position of the word within a sen-
tence. For example, a grammar could tell you that a variable declaration is comprised of 
a sequence of type-specification tokens (int, lonq, short, and so forth) followed by a 
single identifier, but it is just manipulating sequences of strings, it has no idea what the 
strings mean. In the case of a declaration, it knows nothing about the characteristics of 
the individual types-as far as the grammar is concerned, the following declarations are 
168 
Syntax-directed transla­
tion. 
Derivations. 
Start, goal symbol. 
The~ symbol. 
Leftmost derivation. Context-Free Grammars-Chapter 3 
all reasonable because they're all sequences of type specifiers followed by a single 
identifier: 
long john_silver; 
short stop; 
long short muddle; 
What the grammar does do is distinguish the specifiers from the identifiers. If a type 
specifier were redefined so that it could represent an int only, then the meaning of the 
specifier could be extrapolated from the syntax. That is, when the parser encountered a 
type specifier, it would know that the specifier was an int, because that was the only 
possibility. This sort of degenerate case is not much use in natural languages like 
English, but it can be used effectively in languages with limited syntactic and semantic 
scope, such as programming languages, which might have only a few verbs (while, do, 
for), and the same number of nouns (int, float, double). 
In syntax-directed translation, code is generated (the input language is translated to 
the output language) strictly on the basis of the syntax of a sentence-the meaning of a 
phrase or word is inferred from its position within the sentence. In practical terms, the 
parser performs certain code-generation actions as it traverses a parse tree which is 
created using syntactic rules. It performs a code-generation action every time a node on 
the tree is visited. 
3.2 Derivations and Sentential Forms 
A derivation is a way of showing how an input sentence can be recognized with a 
grammar. You can also look at it as a type of algebraic substitution using the grammar. 
As an example of the derivation process, you start a leftmost derivation with the topmost 
nonterminal in a grammar, called the start or goal symbol. You then replace this nonter­
minal with one of its right-hand sides. Continue in this manner-but replace the left­
most nonterminal created from the previous step with one of the right-hand sides of that 
nonterminal-until there are no more nonterminals to replace. 
The following grammar recognizes a simple semicolon-terminated expression con-
sisting of interspersed numbers and PLUS tokens: 
1: stmt ~ expr SEMI 
2: expr ~ factor PLUS expr 
3: I factor 
4: factor ~ NUMBER 
All you need do to prove that an input sentence (like 1 + 2; ) can be recognized for this 
grammar is come up with a derivation that can match the input sentence, token for token. 
The following derivation does just that (the ~symbol means derives), 
stmt ~ expr SEMI by Production 1 
~ factor PLUS expr SEMI by Production 2 
~ NUMBER PLUS expr SEMI by Production 4 
~ NUMBER PLUS factor SEMI by Production 3 
~ NUMBER PLUS NUMBER SEMI by Production 4 
This process is called a leftmost derivation because you always replace the leftmost non­
terminal in the partially-parsed sentence with the equivalent production's right-hand 
side. Start with the goal symbol (the topmost symbol in the grammar) and then replace 
the leftmost nonterminal at each step. The :b operator signifies a leftmost derivation. 
x:b Y means "X derives Y by a leftmost derivation." You can say that 
Section 3.2-Derivations and Sentential F orrns 
expr SEMI :b factor PLUS expr SEMI 
by substituting expr for its right-hand side. The foregoing derivation was created in a 
top-down fashion, starting with the topmost symbol in the grammar and working down to 
the tokens. This process is called a top-down parse. 
Each of the steps in the earlier example (each partial derivation) is formally called a 
viable prefix. You can look at a viable prefix as a partially parsed sentence. Another 
useful term is a handle, which is the portion of the viable prefix that is replaced at each 
step in the derivation. The handle is always a contiguous sequence of zero or more sym­
bols at the far right or far left of the viable prefix (depending on how the derivation is 
done). 
You can also have a rightmost derivation which starts with the goal symbol and 
replaces the rightmost nonterminal with each step. The ::lb operator can be used to indi­
cate this kind of derivation. It's also possible to have a bottom-up parse--one that starts 
with the leaves of the tree and works its way up to the root. Bottom-up parsers use 
right-most derivations. They start with the input symbols and, when a right-hand side is 
encountered in a viable prefix, replaces the symbols that comprise the right-hand side 
with the equivalent left-hand side. You still go through the input from left to right, but 
you always replace the rightmost handle in the viable prefix. Using the same grammar 
and input as before, you can derive the goal symbol from the input symbols as follows: 
NUMBER PLUS NUMBER SEMI 
Jb factor PLUS NUMBER SEMI 
Jb factor PLUS factor SEMI 
Jb factor PLUS expr SEMI 
Jb expr SEMI 
Jb stmt Start with the input. 
Apply factor~ NUMBER 
Apply factor~ NUMBER 
Apply expr~factor 
Apply expr~factor PLUS expr 
Apply stmt~expr SEMI 
The parser scans the viable prefix (the partially-parsed sentence) for a handle that 
matches the right-hand side of some production, and then replaces the handle with the 
left-hand side of that production. For example, NUMBER is the right-hand side of 
factor~NUMBER, and this production is applied in the first derivation, replacing the 
NUMBER with the factor. factor PLUS doesn't form a right hand side, so the parser 
moves to the next symbol, the second NUMBER, for the next replacement, and so forth. 
A practical bottom-up parser, which uses a rightmost derivation, is discussed in great 
detail in Chapter Five, so don't worry about it if the foregoing didn't sink in. 
Note that top-down parsers that do rightmost derivations and bottom-up parsers that 
do leftmost derivations are theoretically possible, but they are difficult to implement. 
Similarly, you can go through the input from right to left rather than left to right, but 
again, the practice is not common. 
In general, the ~. :b, and Jb symbols mean that only one substitution has occurred 
between the left-and right-hand side of the equation. Several other forms of the ~ sym­
bol are commonly used: ~ and b means derives in zero or more and in one or more 
steps, respectively. The various forms can also be combined in reasonable ways: :b :b 
R R * + 
~'7· 
We need one more term before continuing: if S~a (if there is a leftmost derivation 
of the viable prefix a from the nonterminal S), then a is sometimes called a left-Top-down parse. 
Viable prefix, handle. 
Rightmost derivation. 
Bottom-up parse. 
sentential form of S. Right-sentential form is used for a rightmost derivation and a just Sentential forms. 
plain sentential form is used when the type of derivation isn't known or doesn't matter. 
For example, NUMBER PLUS expr SEMI is a left-sentential form of stmt because 
L stmt~NUMBER PLUS expr SEMI. 169 
170 
LL parsers and gram­
mars. 
LR parsers and gram­
mars. 
Semantic difficulties in 
parsing. Context-Free Grammars-Chapter 3 
3.2.1 LL and LR Grammars 
The concepts of left and right derivations apply directly to the two types of parsers 
that are discussed in Chapters Four and Five. In fact, the derivation closely follows the 
process that a parser uses to analyze the input sentence. Chapter Four discusses LL 
parsers, which go through the input stream from left to right (that's the first L), perform­
ing a leftmost derivation (that's the second L). Recursive-descent parsers, such as the 
ones examined in Chapter I, are also LL parsers. 
An LL grammar is a grammar that can be parsed by an LL parser. (There are many 
grammars that can't be so parsed.) An LL(l) grammar is a grammar that can be parsed 
by an LL parser with one symbol of lookahead. That is, if a nonterminal has more than 
one right-hand side, the parser can decide which one to apply by looking at the next 
input symbol. 
It's possible to have an LL(k) grammar, where k is some number other than 1, and 
which requires k symbols of lookahead, but such grammars are not very practical. If the 
number is missing, I is assumed. 
The other type of parser that we'll look at in this book is an LR parser which goes 
through the input from left to right, but does a bottom-up, rightmost derivation. The 
class of grammars that can be parsed by LR parsers are LR(k) grammars, and as before, 
we're interested primarily in LR( 1) grammars, which require the parser to look ahead 
only one symbol to recognize a handle. LALR(k) grammars ("Look-Ahead" LR gram­
mars), which are also discussed in depth in Chapter Five, are a special case of the more 
general LR(k) grammars. 
3.3 Parse Trees and Semantic Difficulties 
The grammar in Table 3.1 recognizes a very limited set of English sentences: A sen­
tence is a subject and a predicate. Subjects are made up of nouns with an optional 
preceding article; predicates are either single verbs or a verb followed by a prepositional 
phrase; a prepositional phrase is a preposition followed by an object; and so on. A noun 
can be one of the tokens time or arrow. 
You can use this grammar to parse the sentence: Time flies like an arrow. with the 
following leftmost derivation: 
sentence b subject predicate by Production 1 
b noun predicate by Production 2 
b time predicate by Production 9 
b time verb prep _yhrase by Production 5 
b time flies prep _yhrase by Production 13 
b time flies preposition object by Production 6 
b time flies like object by Production 14 
b time flies like article noun by Production 8 
b time flies like an noun by Production 12 
b time flies like an arrow by Production 10 
The derivation process can be represented diagramatically as a parse tree, a graph in 
which the root node of each subtree is a nonterminal symbol in the language, and the 
subtree itself represents the right-hand side of a replaced symbol. The goal symbol is 
always at the apex of the parse tree. The parse tree for the previous derivation is in Fig­
ure 3.1. 
Note that the parser would happily have applied noun~time in the last step of the 
derivation, even though time flies like a time is not a reasonable sentence, and this is an 
example of a semantic versus a syntactic problem-a meaning-related versus a structural 
Section 3.3 -Parse Trees and Semantic Difficulties 
Table 3.1. A Grammar for an English Sentence 
Production Production 
Number Leji-hand Side Right-hand Side 
I. sentence ~ subject predicate 
2. subject ~ noun 
3. I article noun 
4. predicate ~ verb 
5. I verb prep _yhrase 
6. prep _yhrase ~ preposition object 
7. object ~ noun 
8. I article noun 
9. noun ~ time 
10. I arrow 
II. article ~ a 
12. I an 
13. verb ~ flies 
14. preposition ~ like 
problem. This situation often arises in computer-language implementations. The fore­
going problem could probably be fixed grammatically, but it's not always possible to do 
so, and the resulting grammar will always be larger than necessary (the larger the gram­
mar, the slower the parser). There's an even more serious problem that becomes clear 
when you add the following productions to the grammar: 
noun ~ fruit I banana 
The grammar now parses: 
Fruit flies like a banana 
without errors. Nonetheless, the sentence is actually parsed incorrectly because flies is 
being treated as a verb, not a noun. That is, you've just given bananas the capability of 
independent flight. You could try to rectify the situation by adding the following pro­
ductions: 
adjective 
noun ~ fruit 
~ flies 
and modifying sub} as follows: 
sub}~ noun I adjective noun 
But now, the grammar has become almost impossible to parse because the parser has to 
know the meanings of the various words in order to figure out which of the productions 
to apply. Making the wrong choice causes further errors (like the existence of a time fly, 
which can move forward or backwards in time to avoid being swatted). To parse both 
time flies like an arrow and fruit flies like a banana correctly, you'd have to know that 
there are no such things as time flies and that fruit can't fly, and it's very difficult (if not 
impossible) to build this semantic knowledge into a context-free grammar. 
The foregoing example illustrates the limitations of context-free grammars, which 
can only specify syntax, not semantics. Though there are a few exceptions in artificial­
intelligence applications, most real parsers are limited by the limitations of the 
grammar-they only know about syntax. Consequently, if semantic knowledge is 171 
172 Context-Free Grammars-Chapter 3 
Figure 3.1. Evolution of a Parse Tree for Time Flies Like An Arrow 
(a) (b) (c) (d) (e) 
sentence sentence sentence sentence sentence 
/~ /~ /~ /~ 
subject predicate 
I subject predicate subject predicate 
I subject 
I predicate I -
noun noun noun verb (prep _phrase) 
I I 
time time 
(f) (g) (h) 
sentence sentence sentence 
/~ /~ /~ 
subject predicate subject predicate subject predicate 
I 
noun 
I 
time I - I I ~ I I ~ 
verb (prep_phrase) noun verb prep _phrase noun verb prep _phrase 
I I I I I I ~ 
flies time flies time flies preposition object 
(i) (j) 
sentence sentence 
/~ /~ 
subject predicate subject predicate 
I I~ I I~ 
noun verb prep _phrase noun verb 
I I I ~ I I 
time flies preposition object time flies preposition object 
I I I~ 
like like article noun 
(k) (I) 
sentence sentence 
/~ /~ 
subject 
I 
noun 
I 
time predicate subject predicate 
I~ I I~ 
verb prep _phrase noun verb prep _phrase 
I I~ I I I~ 
flies preposition object time flies preposition object 
I I~ I I~ 
like article noun like article noun 
I I I 
an an arrow 
necessary to control the parse of a specific grammar, it becomes very difficult to build a 
computer program that can parse an input sentence. It's usually not possible to resolve 
all the semantic ambiguities of a computer language in the grammar. For example, the 
grammar itself can't tell you whether a variable is of the correct type when it's used in an 
expression, it can't recognize multiple declarations like int x, long x;, and so 
forth. To do the foregoing, you need to know something about meaning. Errors like the 
foregoing are best detected by the code-generation part of the compiler or by auxiliary 
code in the parser, not in the grammar itself. 
Section 3.4-E Productions 
3.4 E Productions 
I mentioned earlier that a grammatical phrase (a right-hand side) can be empty. 
More correctly, it's permitted for a right-hand side to match the empty string,£. Produc­
tions of the forms~£ are called £productions (pronounced "epsilon productions"). 
Consider the following grammar that recognizes compound statements: 
1: 
2: 
3: compound _stmt ~ 
stmt ~ 
I LEFT CURLY stmt RIGHT CURLY - -NUMBER 
£ 
I've simplified by defining a statement as either a single number or an empty string. This 
grammar supports empty compound statements, as does C. First, note that an £ produc­
tion can effectively disappear from a derivation. The input { ) generates the following 
derivation: 
compound _stmt :b LEFT CURLY stmt RIGHT CURLY - -:b LEFT CURLY RIGHT CURLY - -
The application of expr~£ effectively removes the nonterminal from the derivation by 
replacing it with an empty string. This disappearance is important when you consider 
how an LL parser decides which of several productions to apply when the nonterminal 
being replaced has several right-hand sides. There's no problem if all of the right-hand 
sides start with different terminal symbols; the parser can decide on the basis of the look­
ahead symbol. If the current lookahead symbol matches one of the terminals, then the 
production whose right-hand side starts with that symbol is used. This kind of S grammars. 
grammar-where the leftmost symbols of all the right-hand sides of any given nontermi-
nal are different terminal symbols-is called an S grammar, and S grammars are among 
the simplest of the LL( I ) grammars to recognize. 
An £ production causes problems because the parser has to look beyond the current 
production to make its decision. The parser still decides whether or not a symbol 
matches an empty string by looking at the next input symbol, but it also has to look at the 
grammatical symbols that can follow the nonterminal that goes to £. In the current 
example, if the next input symbol is a NUMBER, then the parser can apply 
stmt~NUMBER. It applies the £ production if the next input symbol is a 
CLOSE_CURLY. The reasoning here is that, if an empty string is matched, then the 
current nonterminal can effectively disappear from the derivation, and as a consequence, 
the next input symbol must be a symbol that can follow that nonterminal. 
Since the parser can decide which production to apply in the current grammar by 
looking at a single lookahead character, then this is an LL( l) grammar. If a stmt could 
start with a CLOSE_CURLY, or if a NUMBER could follow a stmt, then the parser 
wouldn't be able to decide what to do, and the grammar would not be LL(l). The real 
situation is a little more complicated than the foregoing would indicate-I'll discuss the 
ins and outs of LL( l) grammars in depth in the next chapter. The current example serves 
to illustrate the sorts of problems that are involved, however. 
3.5 The End-of-Input Marker 
Another symbol that bears mentioning is the end-of-input marker, represented by 1-. The 1-symbol. 
Strictly speaking, the end-of-input marker is treated as a token, and it always follows the 
rightmost symbol on the right-hand side of the start production-the one with the goal 
symbol on its left-hand side. An explicit 1-is often omitted from a grammar, however. 
The 1-is still there-it's just not shown. This omission doesn't present problems in many 173 
174 
State machines and 
grammars. 
Right-linear grammars. 
Translating a right-linear 
grammar to a DFA. Context-Free Grammars-Chapter 3 
situations. Consider the case of a Pascal program that has to end in a period. The starting 
production in a Pascal grammar could look like this: 
program ~ definitions PERIOD 
and the parser would just look for the period to detect the end of the input sentence. Any 
input that followed the period, including the t--, could be ignored in this situation. The 
situation is complicated in C, because the start production can look like this: 
program ~definitions I E 
In this case, the parser has to look for an t--marker, even though there's no explicit 
marker in the grammar. Just mentally tack at--to the end of all the right-hand sides of 
the start production. (Remember, E is an identity element for string concatenation, so et-­
is the same thing as t--.) 
3.6 Right-Linear Grammars 
This section moves away from a general discussion of grammars to the specifics of 
implementing them. Chapter Two described how state machines can be used for lexical 
analysis, and the notion of a regular definition, a grammatical representation of the input 
language, was also introduced. It turns out that all languages that can be represented as 
state machines can also be represented grammatically, and I'll use this similarity to 
demonstrate the relationships between the two systems here. 
Grammars that can be translated to DFAs are called right-linear grammars. A gram­
mar is right-linear if the right-hand side of each nonterminal has at most one nonterminal 
in it, and that nonterminal is at the far right of the right-hand side. (A left-linear gram­
mar is the same, except that the nonterminal symbol must be at the far left.) 
A right-linear grammar can be translated directly into a DFA if all productions in the 
grammar are either of the form a~E or a~ X b. That is, the right-hand side must either 
be E, or it must be made up of a single terminal symbol followed by a single nonterminal 
symbol. To make a DFA, you must add the further restriction that, if a production has 
more than one right-hand side, the right-hand sides must all start with different symbols. 
(If they don't, you have an NFA.) The state machine is created from the grammar as fol­
lows: 
(1) The set of terminal symbols in the grammar form the DFA's input alphabet. 
(2) The set of nonterminal symbols in the grammar form the states in the DFA. The 
start production is the DFA start state. 
(3) If a production takes the form a~E. then State a is an accepting state. 
(4) If a production takes the form a~X b, then a transition is made from State a to 
State b on the character X. 
Figure 3.2 shows both a state machine and grammar for recognizing a subset of the C 
floating-point constants (the regular expression D* \.DID\. D* is recognized). 
A parser for this sort of grammar is, of course, trivial to implement. In fact, that's 
what the IJX-generated state-machine driver is-a parser for a right-linear grammar. 
State transitions are made based on the current state and input character, and an action is 
executed when an accepting state is entered. A right-linear grammar that doesn't have 
the properties discussed earlier can easily be modified to have the required properties 
using the transformation rules discussed in Chapter Four. 
Section 3.6-Right-Linear Grammars 
Figure 3.2. State-machine and Grammar That Recognizes D * \ . D 1 D \ • D * 
0 ~ DIGIT 4 
DOT 2 
1 ~ DIGIT 1 
DOT accept 
2 ~ DIGIT 3 
DOT error 
3 ~ DIGIT accept 
DOT accept 
4 ~ DIGIT error 
DOT 1 
5 ~ DIGIT 5 
DOT 2 
3. 7 Lists, Recursion, and Associativity 
Probably the most common grammatical structure is a list. Programs are lists of vari­
able declarations and subroutines, subroutines are lists of statements, expressions are 
lists of identifiers and constants delimited by operators, and so forth. We've actually 
been using lists informally up until now, but it's worthwhile to look at them in depth. 
3.7.1 Simple Lists 
Lists are loops, and loops are implemented grammatically using recursion. You can 
see what's going on graphically by looking at the grammatical representations of States 
1 and 5 in Figure 3.2 on page 175. The loops in these states recognize lists of digits, but 
you can use the same grammatical structure to recognize loops of any sort. 175 
The recursion can be implemented in two ways. A left-recursive production is one Left and right recursion. 
where the left-hand side appears as the leftmost symbol on the right-hand side. A right-
recursive production is the other way around, the left-hand side is duplicated at the far 
right. Note that a grammar can be right (or left) recursive and not be right (or left) linear 
because there can be more than one nonterminal on the right-hand side. 
The following grammar provides an example of a simple, left-recursive list of state­
ments: 
stmt list ~ stmt list stmt 
I stmt 
If you also supply a simple definition of stmt as one of three terminal symbols: 
stmt ~ A I B I C 
then the list ABC generates the parse tree in Figure 3.3. 
A typical parser creates the parse tree from left to right as it reads the input, but it 
does a left-to-right, depth-first traversal of the parse tree as it generates code. (The tree is 
traversed left-to-right, but the nodes further down on the tree are visited first.) The sub­
scripts in Figure 3.3 show the order in which nodes are visited. Assuming that the code 
that processes a statement is executed when the stmt _list nodes are traversed, the list ele­
ments are processed from left to right. That is, the elements in the list associate from left 
to right. This is always the case. Left-recursive productions always associate fro~ left to 
right. Associativity and recur­
sion. 
176 
Fudging left associativity 
with a right-recursive 
grammar. Context-Free Grammars-Chapter 3 
Figure 3.3. Parse Tree for a Simple, Left-Recursive List 
stmt list 
/-~ 
stmt list stmt 
/-~ 18 
stmt list stmt c1 I 3 I 5 
'j" 
Changing the grammar to a right-recursive form illustrates the change to right associ­
ativity. The new grammar looks like this: 
stmt list ~ stmt stmt list I stmt 
stmt ~ A I B I C 
and the parse tree for ABC is shown in Figure 3.4. Again, a depth-first traversal causes 
the nodes to be visited in the indicated order, and the important thing is the order in 
which the stmt _list nodes are visited. The elements in this list are processed from right 
to left. 
Figure 3.4. Parse Tree for a Simple, Right-Recursive List 
stmt list 
/-~ 
T' stmt list 
/-~ 
stmt stmt list 
I 4 I 7 
T· 
Recursive-descent parsers can cheat and generate code as the tree is built from the 
top down. This cheating can give surprising results, because a list can be processed from 
left to right, even though the grammar would indicate otherwise. For example, Listing 
3.1 shows the list being processed from left to right, and Listing 3.2 processes the same 
input from right to left. The grammar is the same, right-recursive grammar in both list­
ings, but the position of the process statement () subroutine has been changed. In 
Listing 3.1, process_statement () is called before the recursive stmt_list () 
call, so the list element is processed before the subtree is built. In the second listing, the 
Section 3.7.1-Simple Lists 
processing happens after the recursive call, so the subtree will have been traversed 
before the list element is processed. 
Listing 3.1. Left Associativity with a Right-Recursive Grammar 
I stmt_list() 
2 { 
3 /* Code is generated as you create the tree, before the subtree is 
4 * processed. 
5 *I 
6 
7 remember= stmt(); 
8 
9 process statement( remember); 
10 
II if( not_at_end_of_input () 
12 stmt_list(); 
13 
14 
15 stmt () 
16 { 
17 return( read() ); 
18 
Listing 3.2. Right Associativity with a Right-Recursive Grammar 
I stmt_list() 
2 { 
3 /* Code is generated as you create the tree, after the subtree is 
4 * processed. 
5 */ 
6 
7 remember= stmt(); 
8 
9 if( not_at_end_of_input() 
10 stmt_list(); 
II 
12 process_stmt(); 
13 
14 
15 stmt () 
16 { 
17 return read(); 
18 
Since you can't have left recursion in a recursive-descent parser, this technique is 
often useful, but it can also cause maintenance problems, because some code is gen­
erated as the tree is created, but other code must be generated as the tree is traversed. 
You can't apply this technique in processing expressions, for example. Consequently, it's 
usually best always to generate code after the call to a subroutine that visits a subtree, 
not before it. In Chapter Four, we'll look at a method for modifying grammars that can 
eliminate the left recursion but maintain the left associativity; in general, this is the best 
approach. 
There is one maintainable way to get left associativity with a right-associative gram­
mar, though this method can be used only occasionally. Looking again at Figure 3.4, 
you'll notice that the stmt nodes are processed from left to right, even though the 177 
178 
Productions executed 
first or last. Context-Free Grammars-Chapter 3 
stmt _list nodes go from right to left Consequently, if the statements can be processed in 
stmt rather than in stmt _list, the associativity is effectively reversed. 
Strictly speaking, the grammars we've been looking at are self left or right recursive. 
Self recursive productions are those where the left-hand side appears at one end or the 
other of the right-hand side. It's also possible for a grammar to have indirect recursion, 
however. Here, one or more steps have to be added to a derivation before the recursion 
becomes evident For example, the following grammar has indirect left recursion in it: 
I. s ~ aAHH 
2. a ~ cCHOO 
3. c ~ sDOO WOP 
because, all derivations that start with s ultimately end up with an s on the far left of the 
viable prefix (of the partial derivation): 
s aAHH 
cCHOO AHH 
s DOO WOP CHOO AHH by Production 1 
by Production 2 
by Production 3 
In general, indirect recursion is not desirable in a grammar because it masks the fact 
that the grammar is recursive. 
3.7.2 The Number of Elements in a List 
The grammar we just looked at creates a list with at least one element in it It's pos­
sible for a list to be empty, however. The following productions recognize zero or more 
declarations: 
dec/ list ~ dec/ list declaration 
I E 
Since a decl_list can go toE, the list could be empty. Parse trees for left and right recur­
sive lists of this type are shown in Figure 3.5. Notice here, that the decl_list~E produc­
tion is the first list-element that's processed in the left-recursive list, and it's the last 
list-element processed in the right-recursive list The same sort of thing was also true in 
the nonempty lists that we looked at in the last section-the stmt_list~stmt production 
was processed only once in both types of lists, and it was processed first in the left­
recursive list and last in the right-recursive list This fact comes in handy when you're 
doing code generation, because you can use the E production to trigger initializations or 
clean-up actions. The technique is used heavily in Chapter Six. 
It's also possible to specify a limited number of repetitions, using something like the fol­
lowing: 
list ~ element 
I element element 
I element element element 
The method is cumbersome, but workable. Though this method is the only way to do it 
with a grammar, you can solve the limited-number-of-repetitions problem semantically 
rather than syntactically. Instead of building the counts into the grammar, you can use a 
more general-purpose list and have the parser keep track of how many times the list pro­
ductions are applied, printing an error message if there are an incorrect number of repeti­
tions. 
Section 3.7.2-The Number of Elements in a List 
Figure 3.5. Lists Terminated with E Productions 
dec/ list ~ dec/ list declaration 
I E dec/ list ~ declaration dec/ list 
I E 
dec/ list dec/ list /-"" /-"" 
dec/ list declaration declaration dec/ list /-"" /-"" 
dec/ list declaration declaration dec/ list 
E E 
3.7.3 Lists with Delimiters 
Most lists must incorporate delimiters of some sort into them, and the delimiters can 
be handled in two ways. In C, for example, a comma separates multiple names in a 
declaration, as in: 
int x, y, z; 
Semicolons terminate elements of a list of several declarations, however. Both types of 
lists are illustrated in the following grammar: 
dec/ list ~ dec/ list declaration 
I E 
declaration ~ declarator list specifier _list SEMICOLON 
declarator list ~ TYPE declarator 
I E 
specifier _list ~ specifier _list COMMA NAME 
I NAME 
A decl_list is a list of zero or more declarations (it's left associative). The declaration 
production defines a single list element. It is made up of declarators followed by 
specifiers, and is terminated with a SEMICOLON. Since SEMICOLON is a termina­
tor, it's at the far right of the production that describes the list element, rather than being 
in the list-production (the decl_list) itself. A declarator _list is a simple list of zero or 
more TYPE tokens. Finally, a specifier _list is a COMMA-separated list of identifiers. 
Here, the COMMA, since it is a separator, is part of the list-definition production itself. 
The specifier _list is left recursive. A right-recursive version of the same thing could 
be done like this: 
specifier _list ~ NAME COMMA specifier _list 
I NAME 
The relative positions of the COMMA and NAME must also be reversed here. Common 
ways to do the various types of lists are all summarized in Table 3.2. 179 
180 Context-Free Grammars-Chapter 3 
Table 3.2. List Grammars 
No Separator 
Right associative Left associative 
At least one list ~ MEMBER list I MEMBER list~ list MEMBER I MEMBER element 
Zero elements list ~ MEMBER list I £ list~ list MEMBER I£ okay 
Separator Between List Elements 
Right associative Left associative 
At least one 
list~ MEMBER delim list I MEMBER list ~ list delim MEMBER I MEMBER element 
Zero elements opt _list ~ list I £ opt _list ~ list I£ 
okay list ~ MEMBER delim list I MEMBER list ~ list delim MEMBER I MEMBER 
A MEMBER is a list element; it can be a terminal, a nonterminal, or a collection of terminals and nontermi-
nals. If you want the list to be a list of terminated objects such as semicolon-terminated declarations, 
MEMBER should take the form: MEMBER~ a TERMINATOR, where a is a collection of one or more termi-
nal or nonterminal symbols. 
Depth-first traversal. 3.8 Expressions 
One special form of a list is an expression. For example 1+2+3 is a plus-sign­
delimited list of numbers. Table 3.3 shows a grammar that recognizes a list of one or 
more statements, each of which is an arithmetic expression followed by a semicolon. A 
stmt is made up of a series of semicolon-delimited expressions (exprs), each a series of 
numbers separated either by asterisks (for multiplication) or plus signs (for addition). 
This grammar has several properties that are worth discussing in depth. 
Table 3.3. A Simple Expression Grammar 
I. stmt ~ expr; 
2. I expr; stmt 
3. expr ~ expr +term 
4. I term 
5. term ~ term *factor 
6. I factor 
7. factor ~ number 
8. I ( expr) 
Figure 3.6 shows the parse tree generated by the foregoing grammar when the input 
statement 1 +2 * ( 3+4) +5; is processed. The code-generation pass does a depth-first 
traversal of the tree-the deeper nodes are always processed first. The subscripts in the 
figure show the order in which the nodes are visited. Assuming that code is generated 
only after an entire right-hand side has been processed, the depth-first traversal forces 
the 3+4 to be done first (because it's deepest in the tree and the expr associated with the 
subexpression 3+4 is processed before any of the other exprs); then, moving up the tree, 
the result of the previous addition is multiplied by the 2; then 1 is added to the accumu­
lated subexpression; and, finally, the 5 is added into the total. 
Section 3.8-Expressions 181 
Figure 3.6. A Parse Tree for 1+2* (3+4) +5; 
statements 30 ~~ 
expression 28 ; 29 ~~~ 
expression 23 term 27 
~~~ I 
expression 4 + 5 term 22 I~~~ factor 26 
I 
term 3 
I term 8 
I * 9 factor 21 5 25 ~~~-
factor 2 
I factor 7 
I ( 10 expression 19 ) ,11 
~~~-
1/ 26 expression i4 
I + 15 term 18 
I 
term13 factor 17 
I I 
factor 1, I -4/6 
3// 
Note that the order of evaluation is what you would expect-assuming that multipli- Order of evaluation as 
cation is higher precedence than addition, that addition associates from left to right, and controlled by grammar. 
that parenthesized expressions are evaluated first. Since the parse tree in Figure 3.7 is 
the only possible one, given the grammar used, this means that associativity and pre-
cedence are actually side effects of the grammatical structure. In particular, subtrees that 
are lower down on the parse tree are always processed first, and positioning a production 
further down in the grammar guarantees a lower relative position in the parse tree. 
Higher-precedence operators should then be placed lower down in the grammar, as is the 
case in the grammar used here. (The only way to get to a term is through an expr, so 
multiplication is always further down the tree than addition.) Parentheses, since they are 
at the bottom of the grammar, have higher precedence than any operator. The associa-
tivity is still determined by left or right recursion, as is the case in a simple list. 
Unary operators tend to be lower in the grammar because they are usually higher pre-Unary operators. 
cedence than the binary operators. You can add unary minus to the previous grammar by 
modifying the factor rules as follows: 
182 Context-Free Grammars-Chapter 3 
I. stmt ~ expr; 
2. I expr; stmt 
3. expr ~ expr +term 
4. I term 
5. term ~ term* unop 
6. I unop 
7. unop ~ -factor 
8. I factor 
9. factor ~ number 
10. I ( expr) 
The placement of the new productions insure that unary minus can be applied to 
parenthesized subexpressions as well as single operands. 
Unary operators can sometimes be treated as lists. For example, the C pointer­
dereference operators(*), can pile up to the left of the operand, like this: ***p. You can 
introduce a star into the previous grammar by adding the following list production: 
factor ~ *factor 
Note that the right recursion correctly forces right-to-left associativity for this operator. 
3.9 Ambiguous Grammars 
The expression grammar just discussed is a unambiguous grammar because only one 
possible parse tree can be created from any given input stream. The same parse tree is 
generated, regardless of the derivation used. It's possible to write an ambiguous gram­
mar, however. For example, expressions could be represented as follows: 
statement 
expr ~ expr; 
~ expr+expr 
I expr * expr 
( expr) 
number 
A grammar is ambiguous when the same nonterminal appears twice on a right-hand side 
(because the order in which the nonterminals are evaluated is dependent on the deriva­
tion). Two of the possible parse trees that can be generated for A+B*C are shown in Fig­
ure 3.7. 
Ambiguous grammars are generally to be avoided exactly because they're ambigu­
ous. That is, because there are two possible parse trees, the expression can be evaluated 
in two different ways, and there's no way to predict which one of these ways will be used 
from the grammar itself. Precedence and associativity can't be controlled by the gram­
mar alone. Ambiguous grammars do tend to be smaller, however, and easier to read. So, 
parser-generation programs like yacc and occs generally provide mechanisms for using 
them. These programs can force specific associativity or precedence by controlling the 
parse in predetermined ways when an ambiguous production is encountered. The tech­
nique is discussed in depth in Chapter Five. 
Section 3.9-Ambiguous Grammars 
Figure 3.7. Parse Trees Derived from an Ambiguous Grammar 
statements ~~ 
expression 
~~~ 
expression + expression 
I~~~ 
A expression * expression 
I I 
B c 
statements ~~ 
expression 
~~~ 
expression * expression 
~~~I 
expression + expression C 
I I 
A B 
3.10 Syntax-Directed Translation 
I mentioned earlier that if the syntactic scope of a language was sufficiently limited, 
you could derive semantic information from a formal grammar-from the position of 
particular symbols in the input sentence, and by extension in the grammar itself. This is 
how compilers, in fact, generate code-by executing code-generation actions at times 
that are controlled by the positions of various strings in the input sentence. We did this 
on an ad-hoc basis in Chapter One, first by building a parser for a grammar, and then by 
adding code-generation actions to the parser. The process is discussed in greater depth 
in this section. 
3.1 0.1 Augmented Grammars 
In an augmented grammar, code-generation actions are placed in the grammar itself, Augmentations. 
and the relative position of the action in the grammar determines when it is executed. 
For example, a production like this: 
expr' ~ + term { op ( ' +' ) ; } expr' 
could be coded in a recursive-descent parser as follows: 183 
184 
Generating code to 
evaluate expressions. 
Anonymous temporaries. expr_prime () 
{ 
if( match( PLUS ) ) 
{ 
term(); 
op (' +'); 
expr_prime(); Context-Free Grammars-Chapter 3 
I'll demonstrate how an augmented grammar works by generating code to evaluate 
expressions. You need two subroutines for this purpose, both of which generate code. In 
addition, between the two of them, they manage a local stack of temporary-variable 
names. An expression of the form 1 + 2 + 3 generates the following code: 
tO = 1; 
t1 = 2; 
tO += tl; 
t1 = 3; 
tO += tl; 
The variables tO and tl are known as anonymous temporaries (or just plain tem­
poraries) because the compiler makes up the names, not the programmer. The actual 
code is generated with the following sequence of actions (the numbers identify indivi­
dual actions, several of which are repeated): 
(I) Read the 1. 
(2) Get a temporary-variable name (tO), and output tO 1. 
(3) Push the temporary-variable name onto a local stack. 
(4) Read the"+" and remember it. 
(I) Read the 2. 
(2) Get a temporary-variable name (tl), and output t1 = 2. 
(3) Push the temporary-variable name onto a local stack. 
(5) Pop two temporary-variable names off the stack and generate code to add them 
together: tO += tl [you're adding because you remembered it in (4)]. 
(6) Push the name of the temporary that holds the result of the previous operation and 
discard the second one. 
(4) Read the "+" and remember it. 
(I) Read the 3. 
(2) Get a temporary-variable name (tl), and output tl = 3. 
(3) Push the temporary name onto a local stack. 
(5) Pop two temporary-variable names off the stack and generate code to add them 
together: t 0 += t 1. 
(6) Push the name of the temporary that holds the result of the previous operation and 
discard the second one. 
When you're done, the name of the anonymous temporary that holds the evaluated 
expression is at the top of the stack. Many of the previous actions are identical-the 
time that the action is executed is the important factor here. 
The subroutines that do the work are in Listing 3.3. Temporary-variable names are 
allocated and freed with the newname () and freename () calls on lines nine and ten 
using the method described in Chapter One. You allocate a name by popping it off a 
stack (declared on line six), and free the name by pushing it back. I've removed the 
error-detection code to simplify things. 
The rest of Listing 3.3 shows the code-generation actions. The create_ tmp () sub­
routine (on line 14) does two things, it generates the code that copies the current lexeme 
Section 3.10.1-Augmented Grammars 185 
Listing 3.3. expr.y- Action Code for the Augmented Grammar 
#include <toolslstack.h> I* Described in Appendix A. *I I 
2 
3 
4 
5 
6 
7 
8 
9 stack_dcl(Temporaries, char*, 128); I* Temporaries: stack of 128 char ptrs. *I 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 1*----------------------------------------------------------------------*l 
char *Names [] 
char **Namep { "tO", "tl", "t2", "t3", "t4", "t5", "t6", "t7" }; 
Names; 
char *newname() 
void freename(s) char *s; return( *Namep++ ); 
*--Namep = s; 
1*----------------------------------------------------------------------*l 
create_tmp( str ) 
char *str; I* Create a temporary holding str and push its name. *I 
char *name= getname(); 
yy_code(" %s = %s;\n", name, str ); 
push( Temporaries, name); 
op( what ) 
int what; 
char *left, *right; 
right 
left pop( Temporaries ) ; 
tos( Temporaries ) ; 
yy_code(" %s %c= %s;\n", left, what, right); 
freename(right); 
into an anonymous temporary, and it pushes the name of that temporary onto the Tem­
poraries stack. The op () subroutine on line 22 generates code to do the actual opera­
tion. It takes two temporary-variable names from the Temporaries and generates the 
code necessary to perform the required operation. Note that only one of the temporaries 
is actually popped. The other remains on the stack because it holds the result of the gen­
erated operation. The popped name is recycled for future use on line 31. 
Now, armed with the proper tools, you can design the parser. The augmented gram- Designing the parser. 
mar in Table 3.4 performs the actions described earlier in the correct order. The 
"remember it" action is implicit in the grammar itself (because, to get to the op () call 
in Production 4, for example, you must have passed a previous+). The order of evalua-
tion is controlled, as usual, by the structure of the parse tree and the fact that you're 
doing a bottom-up traversal. Action symbols in the grammar are treated like other termi-
nal symbols-they're just put onto the parse tree in the appropriate places and executed 
when that node is traversed. A parse tree for 1+2+3 is shown in Figure 3.8. The sub-
scripts indicate the order in which nodes are visited. 
An exercise is in order at this juncture. Take a pencil and piece of paper and draw 
both the parse tree and the contents of the Temporaries stack (which holds the 
temporary-variable names) as the expression 1+2*3 is parsed. Note how the Tem­
poraries stack keeps track of the name of the variable that holds the 1 until after the 
higher-precedence multiplication operator is processed. The 2 is stored in the same way 
until the parenthesized subexpression can be handled. Also, note how the name at top of 
186 Context-Free Grammars-Chapter 3 
Table 3.4. An Augmented Expression Grammar 
1. stmt ~ E 
2. I expr; stmt 
3. expr ~ term expr' 
4. expr' ~ + term { op ( ' +' ) ; } expr' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor { op ( ' * ' ) ; } term' 
8. I E 
9. factor ~ number_or_id { create_tmp (yytext);} 
10. I ( expr) 
Figure 3.8. Augmented Parse Tree for 1 + 2 + 3 
numl {rvalue(yytext);)2 
(I) 
Attributes. numg {rvalue(yytext);)9 
(2) 
num16 {rvalue(yytext);l 17 E19 
(3) 
stack always holds the value of the most recently processed subexpression. 
3.1 0.2 Attributed Grammars 
So far, the concept of an attribute has been used in a limited, informal way. An attri­
bute is a piece of information that is associated with a grammatical symbol. Tokens all 
have at least one attribute-the associated lexeme. They can have other attributes as 
well. For example a NUMBER token could have an integer attribute that was the 
number represented by the lexeme. A NAME token could have an attribute that was a 
pointer to a symbol-table entry for that name. Attributes of this type are usually 
represented with subscripts. For example, the two attributes attached to a NUMBER 
could be represented as follows: 
NUMBER<"156". 156) 
Section 3.10.2-Attributed Grammars 
The first attribute is the lexeme, the second is the numeric value of the lexeme. 
Nonterminal symbols can have attributes as well. Take, for example, a recursive­
descent parser. You can look at the subroutines that implement nonterminals as symbols 
that represent the non terminal, not the other way around. Looked at in this way, a 
subroutine's argument or return value represents a quantum of information that is 
attached to the grammatical symbol-to the nonterminal that the subroutine is imple­
menting, so the subroutine arguments and return values can be viewed as the attributes 
of the associated non terminal symbol. 
There are two types of attributes that are attached to nonterminals, and these two 
types correspond to the two methods used to pass information around in the two parsers 
presented at the end of Chapter One. An inherited attribute is passed down the parse 
tree, from a parent to a child, so in a recursive-descent compiler, inherited attributes are 
subroutine arguments. A synthesized attribute goes in the other direction, up the tree 
from a child to a parent. In a recursive-descent compiler, synthesized attributes are 
return values. 1 The best way to keep track of which term is which is to think of the actual 
English usage of the two words. Children "inherit" something from their parents, not 
the other way around. So, an "inherited" attribute is one that's passed from the parent to 
the child in the parse tree. The code-generation in the previous section was done without 
the benefit of attributes. That is, all information was passed between code-generation 
actions using global variables rather than attaching the information to the grammatical 
elements themselves. Drawing an analogy to recursive-descent parsers, it's as if you 
didn't use subroutine arguments or return values anywhere in the parser. 
The attribute mechanism can be extended to grammars in general and is very useful 
in designing a compiler. The attributes can help you specify code-generation actions in 
the grammar in greater detail than would be possible with an augmented grammar alone. 
A grammar to which attributes have been added in this way is called an attributed gram­
mar. In a typical compiler design, you put attributes into the grammar in a manner simi­
lar to the augmentations used in the previous sections. That is, the first step in the design 
process is the creation of an augmented and attributed grammar. It's easier to under­
stand the concepts, however, if you start with working code, so I'll demonstrate the pro­
cess by going backwards from a working parser to an attributed, augmented_ grammar. 
The naive recursive-descent parser in Listing 3.4 implements the following grammar: 
I. stmt ~ E 
2. I expr; stmt 
3. expr ~ term expr' 
4. expr' ~ +term expr' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor term' 
8. I E 
9. factor ~ number 
IO. I ( expr) 
This parser is essentially the naive parser developed in Chapter One, where you'll find 
the match () and advance () subroutines that comprise the lexical analyzer, 
newname () and freename () were discussed earlier. The parser uses inherited 
I. In ALGOL-like languages such as Pascal, an inherited attribute is a subroutine argument that's passed by 
value; a synthesized attribute is either passed by reference or is a function's return value. 187 
Attributes for nontermi­
nals. 
Inherited and synthesized 
attributes. 
Attributed grammar. 
188 Context-Free Grammars-Chapter 3 
attributes, which are passed down the parse tree from parent to child as subroutine argu­
ments. 
Listing 3.4. naive.c- Code Generation with Synthesized Attributes 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 void factor char *t ) ; 
void term char *t ) ; 
void expr char *t ) ; 
stmt () I* stmt 
{ 
char *t; 
while ( !match (EOI) 
{ 
expr( t = newname() ); 
freename( t ); 
if( match( SEMI ) ) 
advance(); -> expr SEMI I* Prototypes to avoid *I 
I* forward references *I 
I* in the code. *I 
expr SEMI stmt *I 
1*----------------------------------------------------------------------*l 
void expr( t ) I* expr -> term expr' *I 
char *t; 
{ 
term ( t ) ; 
expr_prime( t ); 
1*----------------------------------------------------------------------*l 
expr_prime( t ) I* expr' ->PLUS term expr' I epsilon *I 
char *t; 
{ 
char *t2; 
if( match( PLUS ) ) 
{ 
advance(); 
term( t2 newname() ) ; 
printf(" %s += %s\n", t, t2 ); 
freename( t2 ) ; 
expr_prime( t ); 
1*----------------------------------------------------------------------*l 
void term( t ) I* term -> factor term' *I 
char *t; 
{ 
factor t ); 
term_prime t ); 
1*----------------------------------------------------------------------*l 
term_prime( t ) I* term' -> TIMES factor term' I epsilon 
char *t; 
{ 
char *t2 *I 
.... 
Section 3.10.2-Attributed Grammars 189 
Listing 3.4. continued ... 
56 if ( match ( TIMES ) ) 
57 { 
58 advance(); 
59 
60 factor( t2 = newname() ); 
61 
62 printf(" %s *= %s\n", t, t2 ); 
63 freename( t2 ); 
64 
65 term_prime( t ); 
66 
67 
68 /*----------------------------------------------------------------------*/ 
69 void factor( t ) /* factor ->NUMBER OR ID I LP expr RP */ 
70 char *t; 
71 { 
72 if( match(NUMBER_OR ID) ) 
73 { 
74 printf(" %s = %0.*s\n", t, yyleng, yytext ); 
75 advance(); 
76 
77 else if( match(LP) 
78 { 
79 advance(); 
80 
81 expr( t ); 
82 
83 if( match(RP) 
84 advance(); 
85 
86 
Now, consider the flow of attributes (the temporary-variable names) through the 
parse tree as the expression 1 + 2 * 3 is processed. The parser generates the following out­
put: 
tO 1 
tl 2 
t2 3 
t1 *= t2 
tO += tl 
and the associated parse tree is shown in Figure 3.9. The flow of attributes is shown in 
this figure by labeling edges in the graph with the attribute's value. That is, the fact that 
stmt () passes t 0 to expr () is indicated by labeling the edge between the stmt and 
expr nodes with a tO. The attribute is in boldface when the calling function creates that 
attribute with a newname () call; otherwise, the attribute came into a function as an 
argument and was passed to a child function. You should trace through the first few sub­
routine calls in the parse to see what's happening. Remember, each child node in the 
tree represents a subroutine call made by the parent, and the attributes are subroutine 
arguments, so they flow down the tree from the parent to the child. 
You can represent the flow of attributes by borrowing the notation used for argu­
ments in a programming language. Each attribute has a name just like subroutine argu­
ments have names. All attributes that are passed into a production are listed next to the 
name on the left-hand side of that production, like a formal argument list in a subroutine 
declaration. Those attributes can then be referenced by name by the symbols on the Borrow attribute notation 
from subroutine-calling 
conventions. 
190 Context-Free Grammars-Chapter 3 
Figure 3.9. The Flow of Inherited Attributes Through a Parse Tree for 1 + 2 * 3 
stmt ~~~ 
expr stmt ~~ I 
term expr' E 
7~ ~1~ 
factor term' + term expr' 
I I ~~I 
number or id E factor term' E 
I /tt~ 
number or id * factor term' 
I I 
number or id E 
right-hand side of the production, as if they were used in the subroutine. For example, 
say that an attribute, t, represents a temporary variable name, and it is attached to an 
expr; it is represented like this in the subroutine representing the expr: 
expr( t ) 
char *t; 
and like this in the grammar: 
expr<,) ~ ... 
At attribute would also be attached to every expr on a right-hand side, as if it were the 
argument to a recursive subroutine call: 
stmt ~ expr<•) ; stmt 
If the same attribute appears on both the left-and right-hand sides, then that attribute 
comes into the subroutine as an argument, and is passed down to a child subroutine, in 
tum. An attribute can also be used internally in an action, as if it were a variable. 
Attributes can also be created within an action in a manner analogous to local vari­
ables, and that new attribute can be, in tum, passed to another grammatical symbol (to a 
subroutine) as an attribute (as an argument). Note that a leftmost derivation requires the 
flow of attributes to be from left-to-right across the production, just like the flow of con­
trol in a recursive-descent parser that implements the grammar. So, in an LL parser 
(which uses a leftmost derivation), inherited attributes can be passed from a left-hand 
side to a symbol on the right-hand side, and an attribute can be passed from a code­
generation action to a symbol to its right. Synthesized attributes are used differently, and 
are discussed in depth in Chapter Five along with the bottom-up parsers that use this 
type of attribute. 
Section 3.10.2-Attributed Grammars 191 
An attributed version of our expression grammar is shown in Table 3.5. The attribute 
names are taken from the previous recursive-descent compiler. An attribute attached to 
a left-hand side is treated like a formal argument in a subroutine declaration-it's the 
attribute that is passed to the current production from its parent in the tree. An attribute 
on the right-hand side is treated like an argument in a subroutine call; it is passed down 
the tree to the indicated production. 
Table 3.5. An Attributed Grammar 
I. stmt ~ E 
2. I expr1t, ; stmt 
3. expr1t, ~ termttJ expr'ttJ 
4. expr'1t, ~ + term1t2, expr'1t, 
5. I E 
6. term1t, ~ factor term' 
7. term' ttl ~ * factor tt2J term' (t) 
8. I E 
9. factor ttl ~ number or id 
10. I ( expr1t, ) 
The attributes by themselves are not much use. You need to augment the grammar to Augmented, attributed 
show how the attributes are manipulated. Remember that the flow of control in a top-grammar. 
down parser is from left to right across the grammar, so an action can affect only those 
symbols to its right and can use only those symbols that are initialized to its left (or 
which appear as an attribute ofthe left-hand side). An augmented, attributed grammar is 
shown in Table 3.6. The code-generation actions are taken from the previous recursive-
descent parser. 
Table 3.6. An Augmented, Attributed Grammar 
I. stmt ~ E 
2. I !t=newname o; l expr1t, ; stmt 
3. expr1t, 
4. expr'1t, 
5. 
6. term ttl 
7. term' ttl 
8. 
9. factor ttl 
10. ~ 
~ 
~ 
~ 
~ term1t, expr'ttJ 
+ {t2=newname ();) term(t2) {printf ( "%s+=%s\n"' t, t2); freename (t2);) expr'(t) 
E 
factor term' 
* {t2=newname();) factor1t2J {printf("%s+=%s\n",t,t2); freename(t2);) term'!tJ 
E 
number or id { printf ("%s=%0. *s\n"' t, yyleng, yytext); ) 
( expr1t,) 
As I said at the beginning of this section, I've demonstrated the process in a topsy­
turvey fashion. Generally, you would create the augmented, attributed grammar first, 
and then use that grammar as a specification when coding. The compiler-generation 
tools developed in the next two chapters take augmented, attributed grammars as their 
input, and output parsers for these grammars, thereby eliminating the necessity of coding 
a parser at all. You still have to write the grammar, however, and figure out how to gen­
erate code by adding actions to it in appropriate places. 
One final note: It's possible for a single grammar to use both inherited and syn­
thesized attributes, but it's not a good idea. In a recursive-descent parser-the only kind 
192 
Generic symbols. 
Greek letters represent 
sequence of symbols. Context-Free Grammars-Chapter 3 
of parser in which combined attribute types are really practical-maintenance becomes a 
problem because it's more difficult to follow the flow of data as the parser executes. 
Other types of parsers, such as the one-pass, table driven ones discussed in the next two 
chapters, can handle only one type of attribute. 
3.11 Representing Generic Grammars 
As we discuss grammars in the remainder of this book, it will be handy, occasionally, 
to discuss generic productions. In these discussions, when I don't say otherwise the term 
symbol, without the word "terminal" or "nonterminal," is used for when something can 
be either a terminal or nonterminal. As usual, italics are used for nonterminals and bold­
face is used for terminals, but I'll use upper-case letters that look like this: 
to represent an unspeci tied symbol. A production like this: 
s~Jl 'B 
has two symbols on its right-hand side, and these can be either terminals or nonterminals. 
The following production has three symbols on its right-hand side: the first is a nonter­
minal, the second is a terminal, and the third can be either a terminal or nonterminal: 
s~aTJl 
To confuse matters further, I'll use Greek letters to represent a sequence of symbols. 
For example, a generic production can be written like this: 
s~ a 
sis a nonterminal because it's in italics, and a represents an arbitrary sequence of termi­
nals and nonterminals. Unless I say otherwise, a Greek letter represents zero or more 
symbols, so something like this: 
s~aA~ 
represents all productions that have s on their left-hand side and an A somewhere on 
their right-hand side. The A can be preceded by zero or more symbols (terminals or non­
terminals), and it can be followed by zero or more symbols. A sequence of symbols 
represented by a Greek letter can go to E. That is, it can be replaced in the equation by 
an empty string, effectively disappearing from the production. For example, the produc­
tion 
s~AaB 
has to start with an A and end with a B, but it can have any number of terminals and non­
terminals (including zero) in between. 
Multiple right-hand sides, If a generic production has several right-hand sides, I'll represent these with sub-
an. scripts. For example, in the following generic grammar, the nonterminal s has n different 
right-hand sides, one of which could bee: 
Multiple tokens, T n· By the same token (so to speak), the following represents n different terminal sym­
bols: T1 T2 ••• Tn. 
Section 3.11-Representing Generic Grammars 
All the foregoing may seem abstruse, but it will sink in once you've used it a few 
times. I'll call out exactly what's going on if the generic production gets too compli­
cated. 
3.12 Exercises 
3.1. Show a step-by-step leftmost derivation of the expression 
1 + 2 * ( (3+4) + 5) + 6; 
using the following grammar: 
I. statements ~ E 
2. I expr ; statements 
3. expr ~ term expr' 
4. expr' ~ +term expr' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor term' 
8. I E 
9. factor ~ number 
10. I ( expr) 
3.2. Build a recursive-descent parser that implements the augmented grammar in Table 
3.6 on page 191. 
3.3. The following regular expression recognizes a series of binary digits, with the pat­
tern 000 used to terminate the series: 
(011)*000 
Translate that expression into a right-linear grammar. 
3.4. Assuming that each character in the ASCII character set forms a token, create a 
grammar that recognizes all C integer and character constants. All of the follow­
ing should be recognized by your grammar: 
Oxabcd 0123 45 'a' '\t' '\xOa' '\123' 
3.5. In LISP, a simple expression is formed as follows: ( + a b) represents a+b, 
( + a ( * b c) ) represents a+b*c, and so forth. Write a grammar that recog­
nizes all such LISP expressions, with an arbitrary level of parentheses nesting. 
The +, -, *, and I operators must be supported, + and -should be lower pre­
cedence than *, and I. 
3.6. Write an expression grammar that supports variable names, an assignment opera­
tor, a plus operator and array references. Array references are done in a 
FORTRAN-like fashion: a three-dimensional array element can be accessed 
using the notation a [ x, y, z ) . x is the minor axis, so the list of array indexes 
should be processed from right to left. Similarly an expression like a = b[2] = 
c[ 1 ,2] should be recognized, and the assignment operator should associate right to 
left. Addition associates left to right, however. The order of precedence should 
be brackets (highest precedence), then addition, then assignment. 
3.7. Write a grammar that recognizes Pascal subroutine declarations. Draw the parse 
tree that results from a top-down parse of the following declaration: 
function subr( var arg1: string; x: integer; s: string): 
integer; 193 
194 Context-Free Grammars-Chapter 3 
3.8. Write a grammar for 8086 assembly language (or whatever assembly language 
that you know). 
3.9. Write a grammar that describes the input language used by your calculator. Every 
key on the calculator represents a token in the language. 
3.10. Listing 3.5 shows a specification for a DFA transition matrix. The state state­
ments define the rows of the matrix; each goto statement controls the contents of 
a column in that row. The accept statements say that the current state is an 
accepting state, and the code that follows is to be executed when the accepting 
action occurs. The outer braces are part of the accept statement itself, but the 
included code must also be able to have braces in it. Unspecified transitions are 
filled with the number specified in the error statement. 
Listing 3.5. A State Machine Specification 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 rows 4; 
columns 128; 
error -1; /* Number of rows in the table. 
/* Number of columns in the table. 
/* Use this value for all unspecified table elements. *I 
*I 
*I 
state 0 
{ 
go to 
goto 
go to 
go to 
loop 0 
1 
2 
2 
on on 
on 
on 
on I a I; 
I b'; 
'c'; 
100; 
Ox65; /* = Ox64 = 'd'. */ 
accept /* Ox65 = 'e', same as "goto <current state>."*/ 
/* Define an accepting action for this state. */ 
{ 
state 1 
state 2 
state 3 execute this_code(); 
goto 2 on b; } 
goto 3 on c; } 
accept{ hi_there("BOO!"); } } /* Not accepting. */ 
/* Not accepting. */ 
(a) Write a grammar for the language just described. 
(b) Augment the grammar with sufficient code-generation actions and attributes 
that a parser could be coded that reads in a state-machine specification, and 
which outputs C source code, which, when compiled, implements those 
tables. Two array declarations and a subroutine should be output. The first 
array should be the transition matrix itself, the second array should be 
indexed by state number and should evaluate to I if that state is an accepting 
state. The subroutine should contain a switch statement which, when 
passed the state number of an accepting state, executes the associated code. 
(c) Implement the grammar developed in (b). 
3.11. Modify your solution to the foregoing exercise so that you can give symbolic 
names to a state and then use those symbolic names in goto statements. Names 
are declared implicitly by using them instead of a number in a state statement. 
The compiler must assign state numbers in this case, and you should make sure 
that a state number supplied by the compiler doesn't conflict with one supplied in 
a state statement. Forward references should be permitted. 
4 
Top-Down Parsing 
This chapter develops the idea of recursive-descent parsing by discussing ways to do 
the same thing in a more maintainable, table-driven fashion. The chapter includes a 
description of top-down parsing techniques and an in-depth discussion of LL grammars, 
including techniques for modifying grammars to be LL( 1 ). A yacc-like utility called 
LLama-which translates an augmented, attributed LL( 1) grammar into a parser-is 
constructed. If you intend to read the implementation parts of this chapter, you should 
read Appendix E, which contains a user's manual for LLama and occs, before continu­
ing. 
One thing I'm not doing here is presenting an extended example of how to use 
LLama. I've left this out because LLama is, in itself, not nearly as useful a tool as is 
occs. The main reason this chapter is here, in fact, is to present several concepts and pro­
cedures that are used later to construct occs (but in a somewhat simpler context than occs 
itself). That is, LLama, is just a step on the way to occs. I do present a short example of 
using LLama in that I use LLama to rewrite its own parser. Also, a significant part of 
the code used by LLama is also used by occs, and the common code is presented only in 
the current chapter. 
4.1 Push-Down Automata* 
We saw in Chapter Three that certain right-linear grammars can be converted 
directly to DFAs. If you can represent a programming language in this way, you can 
implement a parser for it as a state machine with a code-generation action associated 
with each state. Consider the following simple grammar that recognizes expressions of 
the form number+ number. 
* As in Chapter Two, asterisks mark sections containing theoretical material. 
195 Parsing with a state 
machine. 
196 
State machines can't 
count. 
Push-down automata 
(PDA). E~numberA 
A~+B 
B~numberC 
C~E Top-Down Parsing-Chapter 4 
This grammar satisfies the conditions necessary for implementation as a DFA: it's right 
linear, and every production is of the form a~E or b~Xc, where a, b, and care nonter­
minals and X is a terminal. Consequently, you can represent this grammar with the state 
machine in Figure 4.1 and can parse that grammar using the state machine. 
Figure 4.1. Using a State Machine for Parsing 
8 number >81----+---3>1 
The problem with a straightforward state-machine implementation of a real grammar 
is that a simple state machine can't count; or to be more precise, it can count only by 
adding additional states. Of course, most grammars can't count beyond I either. For 
example, the only way to get one, two, or three of something is with: 
s ~ stooge I stooge stooge I stooge stooge stooge 
Nonetheless, a grammar can handle nested structures, such as parentheses, and keep 
track of the nesting level without difficulty, and a simple DFA cannot. For example, the 
following grammar recognizes properly nested lists of parentheses: 
list ~ plist I plist list 
plist ~ ( list ) I E 
The grammar accepts input like the following: ( ( ) ( ( ) ) ) , but it rejects expressions 
without properly-nested parentheses. This grammar can't be parsed with a state machine 
alone, precisely because the state machine can't count. A straightforward state machine 
that recognizes nested parentheses is shown in Figure 4.2. 
Figure 4.2. A State Machine to Recognize Nested Parentheses 
This machine works fine as long as you don't have more than three levels of nesting. 
Each additional nesting level requires an additional state tacked on to the right edge of 
the machine, however. You don't want to limit the nesting level in the grammar itself, 
and it's not a great idea to modify the state machine on the fly by adding extra states as 
open parentheses are encountered. Fortunately, the situation can be rectified by using a 
state machine augmented with a stack. This state-machine/stack combination is called a 
push-down automaton or PDA. Most table-driven parsers are push-down automata. 
They are driven by a state machine and use a stack to keep track of the progress of that 
state machine. 
Section 4.1-Push-Down Automata* 
A push-down automaton that recognizes nested parentheses is shown in Figure 4.3. 
The associated state table is in Table 4.1. A PDA is different from a normal state 
machine in several ways. First of all, the stack is an integral part of the machine. The 
number at the top of stack is the current state number. Secondly, the contents of the state 
table are not next-state numbers; rather, they are actions to perform, given a current state 
(on the top of stack) and input symbol. Four types of actions are supported: 
accept 
error 
pushN 
pop A sentence in the input grammar has been recognized. 
A syntax error has been detected in the input. 
Push N onto the stack, effectively changing the current state toN. 
Pop one item from the stack, changing the current state to whatever state 
number is uncovered by the pop. The input is advanced with each push or 
pop. 
Figure 4.3. A Push-Down Automata to Recognize Nested Parentheses 
I \ 
1 error 1 
\ '- / start 
\ 
I -' I,..,... -'' 
I II 1accept 
\\ II ,....._ __ // 
Table 4.1. State Table for PDA in Figure 4.3 
Input Symbol 
( ) 1-
State I ~ push 1 error accept 
push 1 pop error 
The following algorithm is used to parse an input sentence: 
Push the number of the start state. 
while( (action = state_table[ top_of_stack_symbol ][ input_symbol ]) ::1= accept ) 
I 
if( action = error ) 
reject; 
else 
do the indicated action. 
The parse stack and input stream for a parse of ( ( ) ( ( ) ) ) is summarized in Table 4.2. Using a PDA to count 
parentheses. 197 
This PDA is using the stack as a counting device. The 0 marks the bottom of the stack, Stack used for counting. 
and the I is used as a nesting-level marker. The marker is pushed every time an open 
parenthesis is encountered and popped when the matching close parenthesis is found. 
The machine accepts an input string only if the start-state marker is on the stack when 
end of input is encountered. 
198 
How recursive-descent 
parsers use the stack. 
Stack frame. Top-Down Parsing-Chapter 4 
Table 4.2. A Parse of ( () ( () ) ) 
Parse Stack Input Next Action 
0 ( ( ) ( ( ) ) ) I-push I and advance 
0 I ( ) ( ( ) ) ) I-push I and advance 
0 I I ) ( ( ) ) ) I-push I and advance 
0 I ( ( ) ) ) I- pop and advance 
0 I I ( ) ) ) I- push I and advance 
0 I I 
I ) ) ) I- pop and advance 
0 I I ) ) I- pop and advance 
0 I )I- pop and advance 
0 I- accept 
This machine has several advantages over the previous one. Not only can it handle 
any level parenthesis nesting (or, at least, the only limitation in that regard is the depth of 
the parse stack), but it has many fewer states than would a straight DFA for a reasonable 
nesting level. We'll look at how to use pushdown automata in more sophisticated ways 
in a moment. 
4.1.1 Recursive-Descent Parsers as Push-Down Automata* 
It's instructive to see how the foregoing applies to a recursive-descent parser. Most 
programming languages use a run-time stack to control subroutine calls and returns. The 
simplest possible situation is an assembly-language, subroutine-call instruction like 
JSR addr, which pushes the address of the instruction following the JSR onto the run­
time stack, and then starts executing instructions at addr. A matching RET instruction 
pops an address off the stack and starts executing code at that address. In this simple 
case, the stack frame consists of nothing but the return address. 
A programming language that supports recursion must use the stack more exten­
sively. The actual details are discussed in depth in Chapter Six, but for now, suffice it to 
say that space for subroutine arguments and automatic local variables are allocated from 
the stack as part of the subroutine-call process. A C subroutine call, for example, usually 
involves the following sequence of operations: 
(I) Push the arguments onto the stack. 
(2) Call the subroutine. 
(3) Allocate space for local variables by decrementing the stack pointer by some con­
stant (I'm assuming that the stack grows towards low memory, as is usually the 
case). 
Everything is done in reverse order when the subroutine returns, except that the argu­
ments are discarded rather than being popped. 
This entire block (arguments, return address, and local variables) comprises the 
subroutine's stack frame. Figure 4.4 shows the various stack frames as they're created 
and destroyed as the naive recursive-descent parser in Chapter One processes the expres­
sion 1+2 using the grammar in Table 4.3. Each new stack frame represents a subroutine 
call, and when the stack frame disappears, the subroutine has returned. The input is 
shown on the right as it is gradually absorbed. In terms of compilers, the entire stack 
frame represents a nonterminal-the left-hand side of some production, and the local 
variables and argument components of the stack frame are the attributes associated with 
that nonterminal. 
Section 4.1.1-Recursive-Descent Parsers as Push-Down Automata* 
Table 4.3. An LL( 1) Expression Grammar 
1. stmt ~ E 
2. I expr; stmt 
3. expr ~ term expr' 
4. expr' ~ +term expr' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor term' 
8. I E 
9. factor ~ number or id - -
10. I ( expr) 
Figure 4.4. The Parser's Stack Frames 
statements 1 + 2 
statements expression 1 + 2 
statements expression term 1 + 2 
statements expression term I factor I 1 + 2 
statements expression term + 2 
statements expression + 2 
statements expression expr prime I + 2 
statements I expression expr prime I term 2 
statements expression expr_primel term I factor I 2 
statements expression expr prime I term 
statements expression expr primel 
statements expression expr_primel expr_primel 
statements expression expr_primel 
statements expression 
statements 
The question to ask is: what are these stack frames really doing as the parse 
progresses? They're doing two things. First, they're keeping track of the current posi­
tion on the parse tree. The stack always holds the path from the root down to the current 
node on the tree. You can traverse up to a parent by popping one stack element. Second, 
the stack keeps track of attributes; since a stack frame represents a subroutine call, it also 
represents a nonterminal symbol in the parse tree. If you view a subroutine's arguments 
and local variables as attributes of the nonterminal, then the portion of the stack frame 
that holds these objects represents the attributes. The same nonterminal symbol can be 
on the stack in several places, but since each instance of the associated subroutine has its 
own stack frame (with its own local variables and arguments), each instance of the 199 
Stack used to remember 
attributes and position on 
parse tree. 
Recursive subroutines 
have unique stack 
frames, attributes. 
200 
Replace recursion with 
loop and explicit stack. Top-Down Parsing-Chapter 4 
associated nonterminal can have a unique set of attributes attached to it. For example, 
when expr _prime () calls itself recursively (in the fifth stack from the bottom of Fig­
ure 4.4), there are two stack frames, each with a unique set of local variables and argu­
ments. 
You can make the transition from recursive descent to a table-driven parser by realiz­
ing that neither the recursion nor the subroutines themselves are actually necessary, pro­
vided that you can simulate the recursive-descent parser's stack frames using a local 
stack. That is, instead of using the implicit, run-time stack to keep track of the attributes 
and the position in the parse, you can maintain an explicit stack that does the same thing. 
That explicit stack can then be controlled by a nonrecursive subroutine and a table. For 
example, a production like this: 
factor ~ MINUS unop 
unop ~ NUMBER 
I IDENTIFIER 
can be implemented in a recursive-descent parser as follows: 
factor() 
{ 
if( match( MINUS ) ) 
else 
unop() 
{ 
if match( NUMBER advance(); unop(); 
error(); 
else if( match( IDENTIFIER 
else advance(); 
advance(); 
error(); 
And these subroutines can be simulated as follows: 
#define factor 1 
#define unop 2 
push( factor); /* Push the goal symbol */ 
while( stack_not_empty() ) 
{ 
switch( top_of_stack_symbol 
{ 
case factor: if( match(MINUS) 
else advance(); push( unop ); 
error(); 
case unop: pop(); 
break; 
if match( NUMBER 
else if( match( IDENTIFIER 
else 
pop(); 
break; advance(); 
advance(); 
error(); 
Rather than calling a subroutine, a symbol representing that subroutine is pushed onto a 
local stack. The pops replace the return statements. Since the foregoing loop is, in 
effect, a DFA, you can translate it to a table with little difficulty. 
Section 4.2-Using a PDA for a Top-Down Parse* 
4.2 Using a PDA for a Top-Down Parse* 
A top-down parse can be implemented using a grammar, a stack, and the following 
algorithm. The parse stack is initialized by pushing the goal symbol (the topmost pro­
duction in the grammar). 
(0) If the parse stack is empty, the parse is complete. 
(1) If the item at top of stack is a nonterminal, replace it with its right-hand side, push­
ing the symbols in reverse order. For example, if you have a production: a~b c d, 
and a is at the top of stack, pop the a and push the right-hand side in reverse order: 
first the d, then the c, and then the b. In the case of an E production (a production 
withE as its right-hand side), an item is popped, but nothing is pushed in its place. 
Goto (0). 
(2) Otherwise, if the item at top of stack is a terminal symbol, that symbol must also be 
the current lookahead symbol. If it's not, there's a syntax error, otherwise pop the 
terminal symbol and advance the input. Goto (0). 
Note that step (2), above, requires certain symbols to be in the input at specific times 
because tokens at the top of stack must match the current input symbol. The parser is 
effuctively predicting what the next input token will be. For this reason, the parser just 201 
Rules for top-down pars­
ing with a PDA. 
described is often called a predictive parser. Note that only certain classes of grammars Predictive parsers. 
(which I'll discuss shortly) can be parsed by predictive parsers. Table 4.4 shows the 
parse stack as 1 +2; is processed using the grammar in Table 4.3 on page 199 and a 
predictive parser. 
4.3 Error Recovery in a Top-Down Parser* 
One of the advantages of top-down parsers is that effective error recovery is easy to 
implement. The basic strategy makes use of a set of tokens called a synchronization set. 
Symbols in this set are called synchronization tokens. Members of the synchronization 
set are typically symbols that can end blocks of code. 
A syntax error occurs in a predictive parser when a token is at top of stack and that 
same token is not the current lookahead character. The synchronization set is used to 
recover from the error as follows: 
(1) Pop items off the parse stack until a member of the synchronization set is at top of 
stack. Error recovery is not possible if no such item is on the stack. 
(2) Read input symbols until the current lookahead symbol matches the symbol at top 
of su ;k or you reach end of input. 
(3) If you are at end of input, error recovery failed, otherwise you have recovered. 
An alternate method, which is harder to implement but more robust, examines the 
parse stack and creates a list of those synchronization symbols that are on the stack when 
the error occurred. It then reads the input until any of these symbols are encountered, 
and pops items off the stack until the same symbol is at top of stack. 
Ideally, every production should have its own set of synchronization symbols, which 
are changed when the production is activated. To do this properly, you must have a stack 
of synchronization sets, and replacing a nonterminal with its right-hand side involves the 
following operations: 
(1) Push the associated synchronization set onto the synchronization-set stack. 
(2) Pop the nonterminal from the parse stack. 
(3) Push a special pop marker onto the parse stack. 
(4) Push the right-hand side of the nonterminal onto the parse stack in reverse order. Synchronization set, 
tokens. 
Synchronization-set 
stack. 
202 Top-Down Parsing-Chapter 4 
Table 4.4. A Top-Down Parse of 1 + 2; 
Parse Stack Input Comments 
stmt 1+2; I-Apply stmt~expr ; stmt 
- 1+2;1--
stmt 1+2; I-(This stmt is the one on the right of stmt~expr ; stmt) 
stmt; 1+2; I-
stmt; expr 1+2;1-- Apply expr~term expr' 
stmt; 1+2;1--
stmt; expr' 1+2;1--
stmt ; expr' term 1+2;1-- Apply term~factor term' 
stmt; expr' 1+2;1--
stmt ; expr' term' 1+2;1--
stmt ; expr' term' factor 1+2;1-- Apply factor~num _or _id 
stmt ; expr' term' 1+2;1--
stmt ; expr' term' num _or _id 1+2;1-- TOS symbol matches lookahead, pop and advance 
stmt ; expr' term' +2;1-- Apply term'~£ 
stmt; expr' +2;1-- Apply expr' ~+ term expr' 
stmt; +2;1--
stmt; expr' +2;1--
stmt ; expr' term +2 ;I-
stmt ; expr' term + +2 ;I-TOS symbol matches lookahead, pop and advance 
stmt ; expr' term 2; I-Apply term~factor term' 
stmt; expr' 2; I-
stmt ; expr' term' 2; I-
stmt ; expr' term' factor 2; I-Apply factor~num _or _id 
stmt ; expr' term' 2; I-
stmt ; expr' term' num _or _id 2; I-TOS symbol matches lookahead, pop and advance 
stmt ; expr' term' ;I- Apply term'~£ 
stmt; expr' ;I- Apply expr' ~£ 
stmt; ;I- TOS symbol matches lookahead, pop and advance 
stmt I- Apply stmt~E 
- I- Done 
When a pop marker is found on the parse stack, one set is popped from the 
synchronization-set stack. The set at the top of the synchronization-set stack is used 
when an error is encountered. 
In practice, a synchronization-set stack is usually not worth the effort to implement 
because most synchronization sets have the same tokens in them. It's usually adequate 
to have one synchronization set that can work in most situations and is used universally 
whenever an error is encountered. Taking Cas an example, a good choice of synchroni­
zation tokens would be a semicolon, comma, close-brace, and close parenthesis. In other 
words, symbols that end commonly occurring phrases in the input language are good 
choices. 
4.4 Augmented Grammars and Table-Driven Parsers* 
Though the parser just described is nice, it's not very useful because there's no provi­
sion for code generation. It's like the initial stab at a recursive-descent parser back in 
Chapter One, before the code generation had been added to the actions. Fortunately this 
omission is easy to rectify. 
Section 4.4-Augmented Grammars and Table-Driven Parsers* 203 
As was discussed in Chapter Three, an augmented grammar is one in which code­
generation actions are inserted directly into the grammar. An augmented version of the 
previous grammar is shown in Table 4.5. (It's the augmented grammar from the last 
chapter.) The augmented grammar is parsed just like the unaugmented one. The actions 
are just pushed onto the parse stack along with other symbols. When an action is at the 
top of the stack, it's executed. Top-down code genera­
tion using augmented 
grammar. 
Table 4.5. An Augmented LL(l) Expression Grammar 
I. statements ~ I-
2. I expression ; statements 
3. expression ~ term expression' 
4. expression' ~ +term { op (' +') ; } expression' 
5. I E 
6. term ~ factor term' 
7. term' ~ *factor { op ( ' * ' ) ; } term' 
8. I E 
9. factor ~ number_or_id {create_tmp(yytext);} 
10. I ( expression ) 
The action subroutines that do the code generation (op () and create_ tmp ()) 
were discussed in Chapter Three, but to summarize: 
• The create_ tmp ( ) subroutine generates code to copy the operand into an 
anonymous temporary variable, and it pushes the name onto a local Temporaries 
stack. 
• The op ( ) subroutine performs the operation on the two previously-generated tem­
porary variables, popping their names off the stack, generating code to perform the 
operation, and then pushing the name of the temporary that holds the result. 
A sample parse of 1 + 2 is shown in Table 4.6. Note that the op ( ) call follows the term 
in expr' ~+ term { op (' +' ) ; } expr'. Since the temporaries are generated indirectly by 
the terms, two names will exist on the Temporaries stack when the op ( ) call is exe­
cuted. 
4.4.1 Implementing Attributed Grammars in a PDA* 
The previous example generated code without benefit of attributes. It is possible to 
use attributes in a PDA, however. A top-down parser such as the one we're looking at Actions executed as 
parse tree traversed. 
uses inherited attributes (the equivalent of subroutine arguments) exclusively. It's very Inherited attributes in 
difficult to represent return values (synthesized attributes) in this kind of parser, though top-down parser. 
the situation is reversed in the bottom-up parsers discussed in the next chapter. 
We'll support attributes by introducing a second stack, called an attribute or value Value, attribute stack. 
stack, which simulates that part of a subroutine's stack frame that holds the subroutine 
arguments. This stack is a stack of structures, one field of which is used to hold the attri-
bute associated with a production's left-hand side, and the other element of which is used 
to hold a symbol's own attribute. Every time a symbol is pushed onto the normal parse 
stack as part of a replacement operation, the attribute attached to the left-hand side that's 
being replaced is pushed onto the value stack ,(it's copied to both fields of the structure). 
An action is executed when it's at the top of the stack, and all symbols to the right of 
the action in the production are still on the parse stack when the execution occurs. For 
example, when the action () in the following production is executed: 
204 Top-Down Parsing-Chapter 4 
Table 4.6. A Top-Down Parse of 1 + 2; Using the Augmented Grammar 
stmt 
stmt 
stmt; 
stmt; expr 
stmt; 
stmt; expr' 
stmt ; expr' term 
stmt; expr' 
stmt ; expr' term' 
stmt ; expr' term' factor 
stmt ; expr' term' Parse Stack 
stmt; expr' term' {create_ tmp (yytext) ; ) 
stmt; expr' term' {create _tmp (yytext);} n 
stmt ; expr' term' {create_ tmp (yytext) ; } 
stmt ; expr' term' 
stmt; expr' 
stmt; 
stmt; expr' 
stmt ; expr' { op ( ' +' ) ; } 
stmt ; expr' { op ( ' +' ) ; } term 
stmt; expr' {op ('+');}term+ 
stmt; expr' {op ('+');}term 
stmt ; expr' { op ( ' +' ) ; } 
stmt ; expr' { op (' +' ) ; } term' 
stmt ; expr' { op (' +' ) ; } term' factor 
stmt; expr' { op (' +');} term' 
stmt; expr' { op (' +' ) ; } term' {create_ tmp (yytext) ; } 
stmt ; expr' { op (' +' ) ; } term' {create_ tmp (yytext) ; } n 
stmt; expr' { op (' +' ) ; } term' {create_ tmp (yytext) ; } 
stmt; expr' { op (' +');} term' 
stmt ; expr' { op (' +' ) ; } 
stmt; expr' 
stmt; 
stmt Input Comments 
1+2; 1-Apply stmt~expr; stmt 
1+2; 1-
1+2;1-
1+2;1-
1+2; 1-
1+2;1-
1+2; 1-
1+2;1-
1+2; 1-
1+2; 1-
1+2; 1-
1+2;1-
1+2;1-
1+2;1-
+2;1-
+2;1-+2;1-
+2;1-
+2;1-
+2; 1-
+2; 1-
+2; 1-
2;1-
2;1-
2;1-
2;1-
2;1-
2;1-2;1-
;1-
;I-
; I­
;I-
; I­
I-
I-Apply expr~term expr' 
Apply term~factor term' 
Applyfactor~n {create_tmp(yytext);} 
TOS symbol matches lookahead, pop and advance 
Generate t 0= 1 ; 
Apply term'~£ 
Apply expr' ~+ term { op ( ' +' ) ; } expr' 
TOS symbol matches lookahead, pop and advance 
Apply term~factor term' 
Apply factor~n {create_ tmp (yytext) ; } 
TOS symbol matches lookahead, pop and advance 
Generate t1=2; 
Apply term'~£ 
Generate t0+=t1; 
Apply expr' ~£ 
TOS symbol matches lookahead, pop and advance 
Apply stmt~£ 
Done 
num or id is abbreviated as n so that the table can fit onto the page. 
a~ b {action();} c d 
The action symbol itself is at the top of the stack, c is directly underneath it, and d is 
under the c. The attribute for a symbol can be modified from within an action by modi­
fying the right-hand-side field of an attribute-stack structure. The distance from the top 
of stack to the required structure is the same as as the distance in the grammar from 
action to the required symbol. In the earlier example, dis two symbols to the right of the 
{act ion() } and its attributes are two symbols beneath the {action() } 's attributes 
on the value stack. If that action wants to modify the attribute for d it need only modify 
the attribute at offset 2 from the top of the attribute stack. 1 The value stack can be imple­
mented using the modified top-down parse algorithm in Table 4.7. 
I. It's also possible to keep track of attributes on the parse stack itself rather than on an auxiliary value stack. 
See [Lewis], pp. 311-337. This method is difficult to implement so is not discussed here. 
Section 4.4.1 -Implementing Attributed Grammars in a PDA * 
Table 4.7. Top-Down Parse Algorithm with Attributes 
Data Structures: A parse stack of ints. 
A value stack of the following structures: 
typedef struct 
{ 
YYSTYPE left; 
YYSTYPE right; 
} 
yyvstype; 
YYSTYPE is an arbitrary type-it is a character pointer in the current example. 
A variable, lhs, of type YYSTYPE. 
Initially: Push the start symbol on the parse stack. 
Push garbage onto the value stack. 
(0) If the parse stack is empty, the parse is complete. 
( 1) If the item at the top of the parse stack is an action symbol: execute the associated code and pop 
the item. 
(2) If the item at the top of the parse stack is a nonterminal: 
(a) lhs=the right field of the structure currently at the top of the value stack. 
(b) replace the symbol at the top of the parse stack with its right-hand side, pushing the sym­
bols in reverse order. Every time an item is pushed onto the parse stack, push an item onto 
the value stack, initializing both fields to lhs. 
(c) Goto (0). 
(3) Otherwise, if the item at the top of the parse stack is a terminal symbol, that symbol must also be 
the current lookahead symbol. If it's not, there's a syntax error, otherwise pop the terminal sym­
bol and advance the input. Goto (0). 
I'll give an example of how to use this attribute-passing mechanism in a moment. 205 
First, however, I need to introduce a new notation for attribute management. Attributes Attribute notation {$N). 
need only be referenced explicitly inside an action. Rather than giving attributes arbi-
trary names, all you need is a mechanism to reference them from the perspective of the 
action itself. The following notation, similar to the one used by yacc, does the job: The 
attribute associated with a left-hand side is always called $$,and attributes for symbols 
on the right-hand side are referenced by the notation $1, $2, and so forth, where the 
number represents the offset of the desired symbol to the right of the current action. 
Consider this production: 
expr' ~ + {$1=$2=newname();} 
term {printf ("%s+=%s\n", $$, $0); freename ($0);} 
expr' 
(That's one long production, split up into several lines to make it easier to read, not three 
right-hand sides.) The $1 in { $1=$2=newname ();} attaches an attribute to the term 
because term is one symbol to the right of the action. When the parser replaces this term 
with its right-hand side, the symbols on that right-hand side can all use$$ to access the 
206 Top-Down Parsing-Chapter 4 
attribute associated with the term. In the current right-hand side, the $$ in the 
printf () statement references an attribute that was attached to the expr' at some ear­
lier point in the parse. The $2 in { $1=$2=newname () ; } references the second action, 
which is two symbols to the right of { $1=$2=newname () ; } . The second action can 
get at this attribute using $0. That is, the value assigned to $2 in the first action is 
accessed with $ 0 in the second action. 
LLama can translate the dollar notation directly into value-stack references when it 
outputs the switch statement that holds the action code. When an action is executed, 
$$ is the left-hand-side field of the structure at the top of the value stack, $0 is the right­
hand-side field of the same structure, $1 is the structure at offset one from the top of the 
stack, $2 is at offset two, and so forth. 
The entire grammar, modified to use our new notation, is shown in Table 4.8. You 
can see how all this works by looking at the parse of 1 + 2 that is shown in Table 4.9. 
Remember that the symbols on the right-hand side of a replaced nonterminal inherit the 
attributes in the nonterminal's right field-both the left and right fields of the 
attribute-stack structure are initialized to hold the right field of the parent nonterminal. 
Table 4.8. An Augmented, Attributed Grammar Using the$ Notation 
I. stmt ~ E 
2. I { $1=$2=newname ();) expr { freename ($0);) ; stmt 
3. expr ~ term expr' 
4. expr' ~ + {$1=$2=newname();) term {printf("%s+=%s\n",$$,$0); freename ($0);) expr' 
5. E 
6. term ~ factor term' 
7. term' ~ * { $1=$2=newname ();) factor {printf ( "%s*=%s\n", $$, $0); freename ($0);) term' 
8. E 
9. factor ~ number_or_id {printf ( "%s=%0. *s\n", $$, yyleng, yytext);) 
10. ( expr) 
Section 4.4.1-Implementing Attributed Grammars in a PDA * 207 
Table 4.9. A Parse of 1 + 2 Showing Value Stacks 
Parse and Value Stacks Notes 
stmt stmt-'iexpr ; stmt 
[?,?] 
stmt ; { 1) expr {0) $1=$2=newname(); 
[?,?] [?,?] [?,?] [?,?] [?,?] $1 references expr, $2 references { 1 ) 
stmt ; { 1) expr expr-'iexpr' term 
[?,?] [?,?] [?,tO] [?,tO] 
stmt ; { 1) expr' term term-'>term' factor 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] 
stmt ; { 1) expr' term ' factor factor-'>num or id 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] [tO,tO] 
stmt ; { 1) expr' term' {3) n num_or_id token matches I in input 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] [tO,tO] [tO,tO] 
stmt ; { 1) expr' term' {3) printf("%s=%0.*s\n",$$,yyleng,yytext); 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] [tO,tO] outputs: tO=l 
stmt ; { 1) expr' term' term'-'>£ 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] 
stmt ; { 1) expr' expr' -'>+ term expr' 
[?,?] [?,?] [?,tO] [tO,tO] 
stmt ; { 1) expr' {2) term {0) + + token matches + in input 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tO] [tO,tO] [tO,tO] [tO,tO] 
stmt ; {1) expr' {2) term {0) $1=$2=newname(); 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tO,tl] [tO,tO] $1 references term, $2 references { 2) 
stmt ; {1) expr' {2) term term-'ifactor term' 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tO,tl] 
stmt ; { 1) expr' {2) term' factor factor-'inum or id 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tl,tl] [tl,tl] 
stmt ; {1) expr' {2) term' {3) n num_or_id token matches 2 in input 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tl,tl] [tl,tl] [tl,tl] 
stmt ; { 1) expr' {2) term' {3) printf("%s=%0.*s\n",$$,yyleng,yytext); 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tl,tl] [tl,tl] outputs: t1=2 
stmt ; { 1) expr' {2) term' term'-'>£ 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] [tl,tl] 
stmt ; { 1) expr' {2) printf("%s+=%s\n",$$,$0);freename($0); 
[?,?] [?,?] [?,tO] [tO,tO] [tO,tl] outputs: tO+=tl 
stmt ; { 1) expr' expr'-'>£ 
[?,?] [?,?] [?,tO] [tO,tO] 
stmt ; { 1) freename($0); 
[?,?] [?,?] [?,tO] 
stmt ; ; token matches ; in input 
[?,?] [?,?] 
stmt stmt-'i£ 
[?,?] 
n = num_or_id 
{0) = { $1 = $2 = newname(); ) 
{1) = { freename($0); ) 
{2) = { printf("%s+=%s\n", $$, $0); freename($0);) 
{3) = { printf("%s=%0.*s\n",$$, yyleng, yytext); ) 
Value-stack elements are shown as [left, right] pairs; [$$, $0] in attribute notation. 
208 
PDA's in top-down pars­
ing, parse tables. 
Numeric values for sym­
bols. 
Executing actions. Top-Down Parsing-Chapter 4 
4.5 Automating the Top-Down Parse Process* 
Now that we have an algorithm, we need a way to automate the parse process. The 
solution is a push-down automata in which a state machine controls the activity on the 
stack. I'll start by looking at how a table-driven top-down parser works in a general 
way, and then I'll examine a LLama output file in depth by way of example. I'll discuss 
how LLama itself works, and how the tables are generated, in the next section. 
4.5.1 Top-Down Parse Tables* 
The tables for the push-down automata used by the parser are relatively straightfor­
ward. The basic strategy is to give a numeric value to all the symbols in the grammar, 
and then make tables of these numeric values. For example, the numeric values in Table 
4.10 represent the symbols in the augmented grammar in Table 4.5 on page 203. 
Table 4.10. Numeric and Symbolic Values For Symbols in Expression Grammar 
Symbolic Value Numeric Value Notes 
LP 5 Terminal Symbols 
NUM_OR_ID 4 
PLUS 2 
RP 6 
SEMI I 
TIMES 3 
EOI 0 (End of input marker, created by LLama) 
expr 257 Nonterminal Symbols 
expr' 259 
factor 260 
stmt 256 
term 258 
term' 261 
{op('+');} 512 Actions 
{op(' *');} 513 
{create tmp(yytext);} 514 
The various symbol types can be distinguished by their numeric value. The end-of­
input marker is always 0, tokens are all in the range 1-6, nonterminals are in the range 
256-261, and actions are in the range 512-514. The parse stack contains these numbers 
rather than the terminals, nonterminals, and actions that they represent. For example, 
every appearance of an expr in a stack picture corresponds to a 257 on the real stack. 
The earlier parse of 1 + 2 is shown in both symbolic and numeric form in Table 4.11. For 
clarity, I will continue to use the symbolic names rather than the numbers, but remember 
that the stack itself actually has the numeric, not the symbolic, values on it. 
The parser takes care of actions with a switch statement controlled by symbolic 
constants-like the one in Listing 4.1.2 The switch is executed when a number 
representing an action is encountered at top of stack-that same number (actnum) is 
used as the argument to the switch, and there's a case for every action symbol. 
The parse itself is accomplished using two tables, Yy _push tab and Yy _ d, shown in 
Figures 4.5 and 4.6. The algorithm is in Table 4.12. Yy _push tab holds the right-hand 
2. This switch statement could be made easier to read by using macros to convert the numbers to a more­
readable string, but this mapping would make both LLama itself and the output code more complex, so I 
decided not to do it. The symbol table is available from LLama if you need to examine the output code. 
Section 4.5.1 -Top-Down Parse Tables* 
Table 4.11. A Parse of 1 + 2 Showing Both Symbols and Numeric Equivalents 
Stack (Symbols) Stack (Numbers) 
stmt 256 
- -
stmt 256 
stmt; 256 I 
stmt; expr 256 I 257 
stmt; 256 I 
stmt; expr' 256 I 259 
stmt ; expr' term 256 I 259 258 
stmt; expr' 256 I 259 
stmt ; expr' term' 256 I 259 261 
stmt ; expr' term' factor 256 I 259 261 260 
stmt ; expr' term' 256 I 259 261 
stmt ; expr' term' { 2 ) 256 I 259 261 514 
stmt ; expr' term' { 2 ) n 256 I 259 261 514 4 
stmt ; expr' term' { 2 ) 256 I 259 261 514 
stmt ; expr' term' 256 I 259 261 
stmt; expr' 256 I 259 
stmt; 256 I 
stmt; expr' 256 I 259 
stmt ; expr' { 0 ) 256 I 259 512 
stmt ; expr' { 0 ) term 256 I 259 512 258 
stmt ; expr' { 0 ) term + 256 I 259 512 258 2 
stmt ; expr' { 0 ) term 256 I 259 512 258 
stmt ; expr' { 0 ) 256 I 259 512 
stmt ; expr' { 0 ) term' 256 I 259 512 261 
stmt ; expr' { 0 ) term' factor 256 I 259 512 261 260 
stmt ; expr' { 0 ) term' 256 I 259 512 261 
stmt ; expr' { 0 ) term' { 2 ) 256 I 259 512 261 514 
stmt ; expr' { 0 ) term' { 2 ) n 256 I 259 512 261 514 4 
stmt ; expr' { 0 ) term' { 2 ) 256 I 259 512 261 514 
stmt ; expr' { 0 ) term' 256 I 259 512 261 
stmt ; expr' { 0 ) 256 I 259 512 
stmt; expr' 256 I 259 
stmt; 256 I 
stmt 256 
- -
{ 0) represents $1=$2=newname (); 
{2) representsprintf ("%s+=%s\n", $$, $0); freename ($0); 
Listing 4.1. Executing Actions from a switch 
1 
2 
3 
4 
5 
6 
7 
8 
9 switch( actnum ) 
{ 
case 512: 
case 513: 
case 514: op (' +'); 
op (' *'); 
create_tmp(yytext); break; 
break; break; 
default: printf("INTERNAL ERROR: Illegal action number\n"); 
break; 
sides of the productions in reverse order (because you have to push them in reverse order 
when you do a replace operation). The index into the Yy _push tab array is the produc­
tion number-an arbitrary, but unique, number assigned to each production. Here, the 
topmost production in the grammar is Production 0, the next one is Production 1, and so 209 
210 Top-Down Parsing-Chapter 4 
forth.3 The right-hand sides are represented by zero-terminated arrays of the earlier sym­
bolic values. Yy _ d is used to determine the actual replacement to perform. It is indexed 
by potential lookahead symbols along one axis, and nonterminals along the other, and is 
used with the parse algorithm in Table 4.12. 
Figure 4.5. LLama Parse Tables: Yy _push tab [] 
Yy pushtab -
0 I 
_I 256, I, 257, 0 I -I stmt SEMI expr 
_I 259, 258, 0 
I ~I expr' term 
_I 259, 512, 258, 2, 01 -I expr' { op !ADDJ;} term PLUS 
' 0 I 
_I 261, 260, 0 I I term' factor 
_I 261, 513, 260, 3, 01 
I term' {op(MULTIPLY}J factor TIMES 
0 I 
J 514, 4, 0 
I ·1 {rvalue (yytext)) NUM OR ID 
-.J 6, 257, 5, 0 
I I RP expr LP 
Figure 4.6. LLama Parse Tables: Yy _ d [ J 
Yyd f-SEMI PLUS TIMES NUM_OR_ID LP 
stmt 0 -1 -1 -1 
expr -1 -1 -1 -1 2 2 
term -1 -1 -1 -1 5 5 
expr' -1 4 3 -1 -1 -1 
factor -1 -1 -1 -1 8 8 
term' -1 7 7 6 -1 -1 RP 
-1 
-1 
-1 
4 
-1 
7 YypOO 
YypOl 
Yyp02 
Yyp03 
Yyp04 
Yyp05 
Yyp06 
Yyp07 
Yyp08 
Yyp09 
At this point, I'd suggest running through the parse of 1 + 2 again, using the algorithm 
and tables just discussed. 
3. Production numbers for LLama-generated parsers can be found by looking at the l/out.sym file generated 
by LLama's -D, -S, or -s switch. 
Section 4.6-LL( I) Grammars and Their Limitations* 211 
Table 4.12. Top-Down Parse Algorithm, Final Version 
a stack of ints parse stack 
value stack a stack ofyyvstype structures, with left and right fields, as described earlier. This stack 
is the same size as the parse stack. 
Yy_d 
Yy pushtab 
Initially: one of the two tables in Figure 4.6. 
the other of the two tables in Figure 4.6. 
Push the numeric value of the goal symbol onto the parse stack. Push a meaningless place 
marker onto the value stack so that it is in phase with the parse stack. 
while( the parse stack is not empty ) 
I 
if( the symbol at top of stack represents an action ) 
I 
Execute the associated code and pop the action item. 
} 
else if( the symbol at top of stack represents a terminal ) 
I 
} 
else 
I if( that symbol doesn't match the input symbol ) 
Syntax error. 
else 
I 
Pop one item off the parse stack. 
Advance. 
/*top-of-stack symbol is a nonterminal */ 
what _to_ do = Yyd [ top-of-stack symbol ] [ current lookahead symbol ] ; 
if( what_to_do == -1) 
Syntax error. 
else 
I 
val= right field of item at top of value stack 
Pop one item offboth the parse and value stacks. 
Push all the items listed in Yy _push tab [ what_to _do ] onto the parse stack. 
Push the same number of items onto the value stack, 
initializing both fields to val. 
4.6 LL(1) Grammars and Their Limitations* 
The concept of an LL( 1) grammar was introduced in Chapter Three. This class of 
grammar can be parsed by a parser that reads the input from left to right and does a left­
most derivation of the parse tree. It needs at most one character of lookahead. There are 
LL(O) grammars, which require no lookahead, but they're too limited to be useful in a LL(O) grammars. 
compiler-all that they can do is recognize finite strings. LL(O) grammars are a subset 
212 
How a parser decides 
which productions to 
apply. Top-Down Parsing-Chapter 4 
of the right-linear grammars discussed in the last chapter-they can have no E produc­
tions in them. 
The main task of a program like LLama is to manufacture the parse tables from the 
tokenized input grammar. The basic parse table (called Yyd in the previous section) is a 
two-dimensional array, the rows are indexed by nonterminal symbols and columns by 
terminal symbols. The array contains either an error indicator or the number of the pro­
duction to apply when a specified nonterminal is at the top of the parse stack and a par­
ticular terminal is in the input stream. This parse table can only be created if the input 
grammar is an LL(l) grammar. 
An LL(1) grammar is limited in many ways, which are best explained by looking at 
how the parser determines what productions to apply in a given situation, and by looking 
at grammars that the parser can't use because it can't make this determination. Consider 
the following production that recognizes simple expressions comprised of numbers, 
parentheses and minus signs. 
1: expression ~ OPEN_PAREN expression CLOSE_PAREN 
2: I NUMBER MINUS expression 
If an expression is on top of the parse stack, the parser must determine which of the two 
possible productions to apply. It makes the decision by looking at the current lookahead 
token. If this token is a OPEN_PAREN, the parser applies the top production; if it's a 
NUMBER, the bottom production is applied. If any other symbol is the lookahead sym­
bol, then an error has occurred. Note that if you were to add a production of the form 
expression ~NUMBER PLUS expression 
to the foregoing grammar, you could no longer determine which of the two right-hand 
sides that start with a NUMBER to apply when an expression was on top of the stack. 
The grammar would not be LL( 1) in this case. 
The situation is complicated somewhat in the following grammar: 
1: expression 
2: 
3: term 
4: ~ OPEN_PAREN expression CLOSE PAREN 
I term MINUS expression 
~ NUMBER 
I IDENTIFIER 
Here also, the top production is applied when an exp.ression is on top of the stack and an 
OPEN_PAREN is in the input. You need to look further than the actual production to 
determine whether you can apply Production 2, however. Since the second production 
starts with a nonterminal, you can't tell what to do by looking at Production 2 only. You 
can resolve the problem by tracing down the grammar, looking at the symbols that can 
occur at the beginning of the nonterminal. Since a term begins the second production, 
and a term can start with either a NUMBER or IDENTIFIER, the parser can apply the 
second production if an expression is on top the stack and the input symbol is a 
NUMBER or IDENTIFIER. Note that problems would arise if you added a production 
of the form 
expression ~ NUMBER 
in the previous grammar, because, if a NUMBER were the lookahead symbol, the parser 
couldn't determine whether to apply Production 2 or the new production. If this situa­
tion existed, the grammar would not be LL(1). 
Let's complicate the situation further with this grammar, which describes a simple 
compound statement that can either contain another statement or be empty: 
Section 4.6-LL(l) Grammars and Their Limitations* 
1: statement ~ OPEN_CURLY expression CLOSE CURLY 
2: I expression SEMICOLON 
3: expression ~ OPEN_PAREN expression CLOSE PAREN 
4: I term MINUS expression 
5: E 
6: term ~ NUMBER 
7: I IDENTIFIER 
Production 1 is applied if a statement is on top of the stack and the input symbol is an 
OPEN_ CURLY. Similarly, Production 2 is applied when a statement is on top of the 
stack and the input symbol is an OPEN_PAREN, NUMBER, or IDENTIFIER (an 
OPEN_PAREN because an expression can start with an OPEN_PAREN by Production 
3, a NUMBER or IDENTIFIER because an expression can start with a term, which can, 
in tum, start with a NUMBER or IDENTIFIER. The situation is complicated when an 
expression is on top of the stack, however. You can use the same rules as before to 
figure out whether to apply Productions 3 or 4, but what about the E production (Produc­
tion 5)? The situation is resolved by looking at the symbols that can follow an expres­
sion in the grammar. If expression goes to E, it effectively disappears from the current 
derivation (from the parse tree)-it becomes transparent. So, if an expression is on top 
of the stack, apply Production 5 if the current lookahead symbol can follow an expres­
sion (if it is a CLOSE_CURLY, CLOSE_PAREN, or SEMICOLON). In this last 
situation, there would be serious problems if CLOSE_CURLY could also start an 
expression. The grammar would not be LL(l) were this the case. 
4.7 Making the Parse Tables* 
I'll now formalize the foregoing rules and show how to use these rules to make a 
top-down parse table such as the one in Figure 4.6 on page 210. This section discusses 
the theory; code that implements this theory is presented later on in the chapter. 
4.7.1 FIRST Sets* 
The set of terminal symbols that can appear at the far left of any parse tree derived 
from a particular nonterminal is that nonterminal's FIRST set. Informally, if you had a 
bunch of productions that all had expression on the left-hand side, FIRST( expression ) 
(pronounced "first of expression") would comprise all terminals that can start an expres­
sion. In the case of the C language, this set would include numbers, open parentheses, 
minus signs, and so forth, but it would not include a close parenthesis, because that sym­
bol can't start an expression. Note that E is considered to be a terminal symbol, so it can 
appear in a FIRST set. First sets can be formed using the rules in Table 4.13. I'll demon­
strate how to find FIRST sets with an example, using the grammar in table 4.13. 
The FIRST sets are put together in a multiple-pass process, starting out with the easy 
ones. Initially, add those nonterminals that are at the far left of a right-hand side: 
FIRST( stmt) 
FIRST( expr) 
FIRST( expr') 
FIRST( term) 
FIRST( term' ) = I I 
= I I 
{PLUS} 
I I 
= {TIMES} 213 
Computing FIRST sets, 
an example. 
214 Top-Down Parsing-Chapter 4 
Table 4.13. Finding FIRST Sets 
( 1) FIRST(A), where A is a terminal symbol, is {A}. If A is E, then E is put into the FIRST set. 
(2) Given a production of the form 
s~Aa 
where s is a nonterminal symbol, A is a terminal symbol, and a is a collection of zero or more ter­
minals and nonterminals, A is a member of FIRST( s ). 
(3) Given a production of the form 
s~ba 
where sand b is are single nonterminal symbols, and a is a collection of terminals and nontermi­
nals, everything in FIRST( b) is also in FIRST( s) . 
This rule can be generalized. Given a production of the form: 
s~a 'Bj3 
where s is a non terminal symbol, a is a collection of zero or more nullable non terminals, t 'B is a 
single terminal or nonterminal symbol, and 13 is a collection of terminals and nonterminals, then 
FIRST( s) includes the union of FIRST( 'B) and FIRST( a). For example, if a consists of the three 
nullable nonterminals x, y, and z, then FIRST( s) includes all the members of FIRST(x ), 
FIRST( y ), and FIRST( z ), along with everything in FIRST( 'B). 
t A nonterminal is nullable if it can go to E by some derivation. E is always a member of a nullable 
nonterminal's FIRST set. 
Table 4.14. Yet Another Expression Grammar 
FIRST(factor) = {LEFT_PAREN, NUMBER} 
Next, close the sets (perform a closure operation on the initial sets) using the foregoing 
rules. Everything in FIRST(factor) is also in FIRST( term) because factor is the left­
most symbol on the right-hand side of term. Similarly, everything in FIRST( term) is 
also in FIRST( expr ), and everything in FIRST( expr) is also in FIRST( stmt ). Finally, 
expr is a nullable nonterminal at the left of stmt's right-hand side, so I'll add SEMI to 
FIRST( stmt ). Applying these relationships yields the following first sets: 
FIRST( stmt) 
FIRST( expr) = {LEFT_PAREN, NUMBER, SEMI} 
= {LEFT_PAREN, NUMBER} 
Section 4.7.1-FIRST Sets* 
FIRST( expr') = 
FIRST( term ) = 
FIRST( term') 
FIRST(factor) {PLUS} 
{LEFT_PAREN, NUMBER} 
{TIMES} {LEFT_PAREN, NUMBER} 
One final note: the FIRST notation is a little confusing because you see it used in 
three ways: 
FIRST( A) (A is a terminal) is A. Since E is a terminal, then FIRST( E)= { E}. 
FIRST( x) (xis a non terminal) is that non terminal's FIRST set, described above. 
FIRST( a.) (a. is a collection of terminals and nonterminals) is the FIRST set computed 
using the procedure in Rule (3), above: FIRST(a.) always includes the 
FIRST set of the leftmost symbol in a.. If that symbol is nullable, then it is 
the union of the FIRST sets of the first two symbols, if both of these symbols 
are nullable, then it is the union of the first three symbols, and so forth. If 
all the symbols in a. are nullable, then FIRST( a.) includes E. 
A subroutine that computes FIRST sets is presented towards the end of the current 
chapter in Listing 4 27 on page 305. 
4.7.2 FOLLOW Sets* 
The other set of symbols that you need in order to make the parse tables are the FOL­
LOW sets. A terminal symbol is in a non terminal's FOLLOW set if it can follow that 
nonterminal in some derivation. You can find a nonterminal's FOLLOW set with the 
rules in Table 4.15. To see how Rule 3 in Table 4.14 works, consider the following 
grammar: 
1: compound _stmt ~ OPEN CURLY stmt list CLOSE CURLY - - -2: stmt list ~ stmt list stmt 
3: stmt ~ expr SEMI 
CLOSE_ CURLY is in FOLLOW ( stmt _list ) because it follows stmt _list in Production 1. 
CLOSE_CURLY is also in FOLLOW(stmt) because of the second of the following 
derivations: 
compound_stmt b OPEN CURLY stmt list CLOSE CURLY - - -b OPEN CURLY stmt list stmt CLOSE CURLY - - -b OPEN_CURLY stmt_list expr SEMI CLOSE_CURLY 
The stmt _list in the first sentential form was replaced by the right-hand side of Produc­
tion 2 (stmt _list stmt), and in that derivation, a CLOSE_ CURLY followed the stmt. 
I'll demonstrate how to compute FOLLOW sets with the earlier grammar in Table Computing FOLLOW 
4.14 on page 214. In the initial pass, apply the first two rules for forming FOLLOW sets: sets, an example. 
SEMI and RIGHT_PAREN are added to FOLLOW(expr) because they actually follow 
it in Productions I and 9; PLUS is added to FOLLOW (term) because everything in 
FIRST( expr') must be in FOLLOW( term) by Production 4; TIMES is added to 
FOLLOW (factor) because everything in FIRST( term') must be in FOLLOW (factor) 
by Productions 6 and 7. The initial pass looks like this: 
FOLLOW ( stmt) 
FOLLOW ( expr) 
FOLLOW ( expr') = {f-} 
= {SEMI, RIGHT_PAREN} 
I I 215 
216 Top-Down Parsing-Chapter 4 
Table 4.15. Finding FOLLOW Sets 
(1) If sis the goal symbol, 1-(the end-of-input marker) is in FOLLOW(s ); 
(2) Given a production of the form: 
s~ ... a'B ... 
where a is a nonterminal and '13 is either a terminal or nonterminal, FIRST( 'B) is in FOLLOW(a ); 
To generalize further, given a production of the form: 
s~ ... a a 'B ... 
where s and a are nonterminals, a is a collection of zero or more nullable nonterminals and '13 is 
either a terminal or non terminal. FOLLOW( a) includes the union of FIRST( a) and FIRST( 'B). 
(3) Given a production of the form: 
s~ ... a 
where a is the rightmost nonterminal on the right-hand side of a production, everything in 
FOLLOW( s) is also in FOLLOW( a). (I'll describe how this works in a moment.) To generalize 
further, given a production of the form: 
s~ ... a a 
where s and a are nonterminals, and a is a collection of zero or more nullable nonterminals, 
everything in FOLLOW( s) is also in FOLLOW( a). 
FOLLOW (term) = 
FOLLOW( term') = 
FOLLOW (factor) = {PLUS} 
I l 
{TIMES} 
Now close the FOLLOW sets by making several passes through them, applying Rule 3 
repetitively until nothing more is added to any FOLLOW set. The following holds: 
• Everything in FOLLOW(expr) is also in FOLLOW(expr') by Production 2. 
• Everything in FOLLOW (term) is also in FOLLOW (term') by Production 7. 
• Since expr' is nullable, everything in FOLLOW( expr') is also in FOLLOW (term) 
by Production 4. 
• Since term' is nullable, everything in FOLLOW( term') is also in FOLLOW (factor) 
by Production 7. 
The first closure pass applies these identities to the original FOLLOW sets, yielding the 
following sets: 
FOLLOW(stmt) = I 1-l 
FOLLOW ( expr) = {SEMI, RIGHT_PAREN} 
FOLLOW( expr') = {SEMI, RIGHT_PAREN} 
FOLLOW( term) = {PLUS, SEMI, RIGHT_PAREN} 
FOLLOW( term') = {PLUS} 
FOLLOW (factor) = I TIMES, PLUS l 
Another pass, using the same identities, adds a few more elements: 
FOLLOW(stmt) 
FOLLOW( expr) = {1-} 
= {SEMI, RIGHT_PAREN} 
Section 4.7.2-FOLLOW Sets* 
FOLLOW(expr') = {SEMI, RIGHT_PAREN} 
FOLLOW (term) = {PLUS, SEMI, RIGHT_PAREN} 
FOLLOW(term') = 
FOLLOW (factor) = {PLUS, SEMI, RIGHT_PAREN} 
{TIMES, PLUS, SEMI, RIGHT_PAREN} 
A third pass adds nothing to the FOLLOW sets, so you're done. A subroutine that com­
putes FOLLOW sets is presented towards the end of the current chapter in Listing 4.28 
on page 307. 
4.7.3 LL(1) Selection Sets* 
To review a bit, an LL( 1) parse table looks like this: 
input symbol 
or production number nonterminal error marker 
The columns are indexed by input symbol, the rows by nonterminal symbol. The table 
holds either a marker that signifies a syntax error or the number of a production to apply, 
given the current top-of-stack and input symbols. Each production has a unique, but 
arbitrary, production number. Typically, the start production is Production 0, the next 
one is Production 1, and so forth. 
The LL( 1) selection set for a given production is the set of nonterminals for which LL(1) selection set. 
there are legal entries in any given row of the parse table. For example, a grammar could 
have the following productions in it: 
1. terminal ~ PERKIN_ELMER pk 
2. I ADM3adm 
3. dec term 
4. dec term ~ VT 52 
5. I VT 100 
The parse table for this grammar looks like this: 
PERKIN ELMER ADM3 VT 52 VT100 
terminal 1 2 3 3 
dec term error error 4 5 
The number 1 is in the PERKIN_ ELMER column of the terminal row, because Produc­
tion 1 is applied if a term is at top of stack and PERKIN_ ELMER is the lookahead sym­
bol, and so forth. The same relationships are indicated by these selection sets: 
SELECT( I) = { PERKIN_ELMER } 
SELECT(2) = I ADM3} 
SELECT(3) = { VT_52, VT_100} 
SELECT(4) = I VT_52 l 
SELECT(5) = I VT_100} 
SELECT(3) indicates that Production 3 is selected if the left-hand side of Production 3 is 
on the top of the stack, and the current lookahead symbol is VT_52 or VT_100. In gen­
eral, if you have both a production N (which takes the form s~a) and a token T, then T 
is in SELECT(N) if production N should be applied when s is on the top of the parse 
stack and T is the current lookahead symbol. Note that the selection sets are attached to 
the individual productions, not to the nonterminals. For a grammar to be LL(l), all pro­
ductions that share a left-hand side must have unique selection sets, otherwise the parser 
wouldn't know what to do in a given situation. [This is the real definition of LL(l).] The 217 
218 Top-Down Parsing -Chapter 4 
Table 4.16. Finding LL( 1) Selection Sets 
(1) A production is nullable if the entire right-hand side can go to E. This is the case, both when the 
right-hand side consists only of E, and when all symbols on the right-hand side can go to E by 
some derivation. 
(2) For nonnullable productions: Given a production of the form 
S-HX 'B ... 
where s is a nonterminal, a. is a collection of one or more nullable nonterminals, and 'B is either a 
terminal or a nonnullable nonterminal (one that can't go to E) followed by any number of addi­
tional symbols: the LL(l) select set for that production is the union of FIRST(a.) and FIRST('B). 
That is, it's the union of the FIRST sets for every nonterminal in a. plus FIRST( 'B). If a. doesn't 
exist (there are no nullable nonterminals to the left of 'B), then SELECT(s)=FIRST('B). 
(3) For nullable productions: Given a production of the form 
s~a. 
where s is a nonterminal and a. is a collection of zero or more nullable nonterminals (it can be E): 
the LL(l) select set for that production is the union of FIRST(a.) and FOLLOW(s). In plain 
words: if a production is nullable, it can be transparent-it can disappear entirely in some deriva­
tion (be replaced by an empty string). Consequently, if the production is transparent, you have to 
look through it to the symbols that can follow it to determine whether it can be applied in a given 
situation. 
LL( 1) selection sets are formed using the rules in Table 4.16. 
Translating SELECT sets 
into an LL(1) parse table. Note that E is used to compute the selection sets because s is nullable if FIRST( s) 
contains E. Nonetheless, E is not itself a member of any selection set. The selection sets 
can be translated into a parse table with the algorithm in Table 4.17. 
Table 4.17. Translating SELECT Sets into LL(l) Parse Tables. 
Initialize the table to all error transitions; 
for( each production, N, in the grammar ) 
I 
lhs = the left-hand side of production N; 
for( every token in SELECT(N) ) 
parse_table[ lhs ][ token ] = N; 
4.8 Modifying Grammars* 
All top-down parsers, including recursive-descent parsers, must use LL( 1) grammars, 
which are are quite limited. The main problem is that LL(l) grammars can't be left 
recursive. Since you can't just dispense with left associativity, LL(l) grammars would 
not be very useful unless some mechanism existed to translate left-recursive grammars 
into left associative, LL( 1) grammars. This section looks at various ways that you can 
manipulate grammars algebraically to make them LL( 1 ); the techniques are useful with 
other classes of grammars as well. 
Section 4.8-Modifying Grammars* 
The following discussion uses the generic-grammar notation discussed at the end of 
Chapter Three without always calling out what everything means. Just remember that 
Greek letters represent collections of terminals and nonterminals, letters like .91. and '13 
represent a single terminal or nonterminal, italics are used for single nonterminals, and 
boldface is used for single terminals. 
4.8.1 Unreachable Productions* 219 
An unreachable nonterminal is one that can't possibly appear in a parse tree rooted Unreachablenonterminal. 
at the goal symbol. That is, there's no derivation from the goal symbol in which the 
unreachable nonterminal can appear in the viable prefix. For example, in the following 
grammar: 
1. s ~ a 
2. a ~ TERM 
3. b ~ TERM TWO 
Production 3 is clearly unreachable because b appears on no right-hand side. The situa­
tion is not always so cut and dried. Productions 3 and 4 are both unreachable in the fol­
lowing grammar, even though b and c both appear on right-hand sides: 
1. s ~ 
2. a ~ 
3. b ~ 
4. c ~ a 
TERM 
TERM TWOc 
TERM TOOb 
Many of the transformation techniques discussed below create unreachable nonterminals 
and, since productions with these nonterminals on their left-hand sides have no useful 
function in the grammar, they should be removed. You can use the algorithm in Table 
4.18. 
4.8.2 Left Factoring* 
A production like the following has two problems: It is clearly not LL( 1) because the 
left-hand sides of both productions start with an IF token so they can't possibly have dis­
joint selection sets. Also, it is ambiguous because the same nonterminal appears twice 
on the right-hand side: 
statement ~ IF test THEN statement ELSE statement 
I IF test THEN statement 
Note that this is also a pretty serious ambiguity because it controls the ways that if and 
else statements bind. Input like the following: 
if( expr ) then 
if( expr2 ) then 
statement(); 
else 
statement(); 
can create either of the trees pictured in Figure 4.7. The top parse causes the else to 
bind to the closest preceding if-the behavior required by most programming 
languages. In the second parser, though, the else incorrectly binds to first if. 
Both problems can be solved by a process known as left factoring, which isolates the Ambiguity in if/else, 
binding problems. 
common parts of two productions into a single production. Any production of the form: Left factoring. 
220 Top-Down Parsing-Chapter 4 
Table 4.18. Eliminating Unreachable Productions 
Data structures: A stack 
A list of reachable non terminals. 
Initially: Both the stack and the list are empty. 
(1) Add the goal symbol to the set of reachable nonterminals 
and push the goal symbol onto the stack. 
(2) while( the stack is not empty ) 
I 
s =pop one item off the stack 
for( each nonterminal, x, on a right-hand side of s) 
if( x is not in the list of reachable nonterminals ) 
I 
push x; 
add x to the list of reachable nonterminals 
I 
I 
(3) Remove from the grammar all productions whose left-
hand sides are not in the list of reachable non terminals. 
Figure 4.7. Parse Trees of an Ambiguous IF/ELSE Grammar 
statement ~ IF test THEN statement ELSE statement 
IF test THEN statement 
statement ~ 
IF test THEN statement 
IF test THEN statement ELSE statement 
statement 
IF test THEN statement ELSE statement ~ 
IF test THEN statement 
Section 4.8.2-Left Factoring* 
where a is a sequence of one or more symbols that appear at the start of every right-hand 
side, a;·.l 131 to 13. are dissimilar collections of zero or more symbols, can be replaced by 
the fo: · '.ving: 
a ~ aa' 
a' ~ 131 
The a' is just an arbitrary name for the new left-hand side. In the current example: 
a corresponds to 
a corresponds to 
131 corresponds to 
132 corresponds to statement 
IF test THEN statement 
ELSE statement 
E 
132 goes to E because there's nothing in the second production that corresponds to the 
ELSE statement in the first production. You can plug the foregoing into our equation 
and replace the original productions with the following: 
statement ~ IF test THEN statement opt_ else_ clause 
opt_ else_ clause ~ ELSE statement 
I E 
Note that this replacement has also eliminated the ambiguity, because only one parse 
tree can now be generated from the earlier input. 
4.8.3 Corner Substitution* 
In general, given a left-hand side with one or more right-hand sides: 
and given a production of the form: 
s ~ 13 p y 
this last production can be replaced with several productions of the form: 
s ~ 
I 
13 a. y 
This process is called a substitution. Substitution. 
In a production of the form a~)( a, the leftmost symbol on the right-hand side ()() is 
said to be a corner of a. An E production doesn't have a corner. In a corner substitution Corner. 
you replace one or more of the nonterminal corners in a grammar with that corner's 
right-hand sides. 
For example, consider the following grammar, which recognizes a list of one or more 
ATOMs. The ATOMs can be single ATOMs, they can be followed by a bracketed 
number (LB and RB stand for left and right bracket), or they can be preceded by any 221 
222 
Corner substitution 
preserves LL(1) proper­
ties. 
Q Grammars. Top-Down Parsing-Chapter 4 
number of STARs. 
I. atom list ~ ATOM 
2. I list ele atom list - -
3. list ele ~ ATOM LB NUMBER RB 
4. I STAR list ele 
This grammar is not LL(l) because, ATOM is in FIRST(list_ele) by Production 3, and 
as a consequence, is also in SELECT(2). A substitution of the list_ele comer of Produc­
tion 2 can help fix this situation. First, you replace all instances of list_ ele in Production 
2 with the right-hand sides of the two list_ele productions (3 and 4), yielding: 
I. atom list ~ ATOM 
2a. I ATOM LB NUMBER LB atom list 
2b. STAR list ele atom list 
3. list ele ~ ATOM LB NUMBER RB 
4. I STAR list ele 
The grammar is still not LL(l) because Productions I and 2a both start with an ATOM, 
but that situation can be rectified by left factoring: 
I. atom list ~ ATOM atom list' 
2b. I STAR list ele atom list 
lb. atom list' ~ LB NUMBER RB atom list 
lc. I E 
3. listj:le ~ ATOM LB NUMBER RB 
4. I STAR list ele 
Comer substitution preserves the LL(l) properties of a grammar-grammars that start 
out LL(l) are still LL(l) after the comer substitution is made. You can see why if you 
consider how FIRST sets are computed. If x is a comer of production s, then FIRST( s) 
includes FIRST( x ), and FIRST( x) is computed by looking at the right -hand side of x. 
Substituting x for its right-hand side does not affect this computation. 
One common use of comer substitution and left factoring takes advantage of this 
property by rearranging the grammar so that every right-hand side in the grammar either 
starts with a unique terminal symbol or is E. That is, if a nonterminal has several right­
hand sides, then all those right-hand sides will start with different terminal symbols or be 
E. This particular type of grammar is called a Q grammar and is handy when you build 
recursive-descent parsers because it's very easy to code from a Q grammar. That is, 
given a Q grammar like the following: 
P ~ TI a.I 
I T2 <lz 
where T1 ••• T. are unique terminal symbols, you can code it like this: 
Section 4.8.3 -Comer Substitution* 
p() 
{ 
switch( lookahead character 
{ 
case T1 : advance () ; <X1 
case T2: advance () ; <X2 
case Tn : advance () ; a" 
default: /* Handle the epsilon production */ 
} 
4.8.4 Singleton Substitution* 
Generally, it's not productive to replace symbols that aren't corners-you shouldn't 
replace nonterminals that aren't at the far left of a right-hand side. The problem here is 223 
that the substitution usually creates several productions that have the same corner, and as Substitutions can create 
a consequence the resulting grammar won't be LL(l). For example, substituting the ambiguity. 
num_or _id for its right-hand side in the following grammar: 
1. 
2. 
3. expr 
num or id ~ UNOP num or id 
~ NAME 
I IDENTIFIER 
yields the following, non-LL(l) grammar: 
1. expr ~ 
Ia. I UNOPNAME 
UNOP IDENTIFIER 
You've just done a reverse left factoring. 
If a production has only one right-hand side, of course, the substitution is harmless. 
In fact, it can reduce the size of the grammar by eliminating productions and is often 
useful for this reason. This sort of production is called a singleton. 
It's sometimes desirable to create singletons by breaking out a group of symbols 
from the middle of a production. That is, the following: 
s ~ aj3y 
can be changed into: 
s ~ as' y 
s' ~ 13 
This technique is used primarily in bottom-up parsers, in which action symbols must be 
at the far right of the production. As a consequence, a production like this: 
s ~ tempest {act ( 1) ; } scene _5 
must be implemented like this: 
s ~ tempest s' scene _5 
s' ~ {act ( 1) ; } 
4.8.5 Eliminating Ambiguity* 
Ambiguous productions are those that have more than one occurrence of a given 
nonterminal on their right-hand side. As we've seen, left factoring can be used to Singleton substitution 
used to isolate actions for 
bottom-up parser. 
224 
Controlling associativity 
when eliminating ambi­
guity. Top-Down Parsing-Chapter4 
eliminate ambiguity, moving the rightmost of these nonterminals further down the parse 
tree by introducing a new production. In general given an ambiguous production of the 
form: 
s ~ a.pj3py 
you can eliminate the ambiguity by introducing a new production, as follows: 
s ~ a.p j3s' 
s' ~ p 'Y 
If the grammar has a production of the form: 
p ~ s 
this transformation makes the grammar left-associative, because there is now an indirect 
left recursion, demonstrated with the following derivation: 
s'~ PY~ sy 
If an ambiguous right-hand side is one of several, then all of these right-hand sides 
must move as part of the substitution. For example, given: 
e ~ e+e 
I NUM 
you transform the grammar to be left-associative like this: 
e e +tIt 
~ e 
I NUM 
or right-associative like this: 
e t + e It 
~ e 
I NUM 
Note that the foregoing transformation introduced a production of the form e~t into 
the grammar. You can use this production to modify the grammar again: 
e t + e It 
~ t 
I NUM 
A production of the form t~t does nothing useful, so it can be eliminated: 
e t + e It 
NUM 
To generalize, given grammars of the form: 
s as j3sy I a., 1. .. I a., 
you can eliminate the ambiguity in favor of right associativity by replacing the foregoing 
with the following: 
s ~ a.s'j3sy Is' 
s' ~ s I a, I. .. I a, 
Now, because a production of the form s~s' has been created you can substitute the s's 
for s"s in the new production, yielding: 
Section 4.8.5-Eliminating Ambiguity* 
s ~ as'~sy I s' 
s' ~ s' I a1 I. .. I a. 
and since that production of the form s' ~s' doesn't do anything useful, it can be elim­
inated, yielding: 
s ~ as' j3sy I s' 
s' ~ a1 1. •. 1 a. 
The same applies in a left-associative situation. Productions of the form: 
s ~ as ~ s y I a1 I. .. I a. 
can be disambiguated in favor of left-associativity by replacing the right occurrence of s 
rather than the left one in the initial step. 
If a grammar has several ambiguous productions, it can be modified by repetitive 
application of the previous transformation. Similarly, if the s in the earlier general 
example appears on more than one right-hand side, then it can be replaced with s' in all 
the right-hand sides. For example, starting with the following expression grammar: 
I. e 
2. 
3. ~ e+e 
I e*e 
I NUM 
I'll eliminate the ambiguity one production at a time. Note that the order in which the 
disambiguating rules are applied also affects operator precedence-the operators that are 
lower down in the grammar are of higher precedence. In an expression grammar like the 
current one, you want to start with the right-hand side that has the lowest-precedence 
operator, Production I. Since addition must be left associative, the transformed produc­
tion must also be left associative, so you must replace the right e in Production 1, yield-
ing: 
la. e ~ e + e' 
lb. I e' 
lc. e' ~ e 
2. I e*e 
3. I NUM 
Now, since a production of the form e~e' exists, you can substitute e's for e''s in Pro­
ductions lc, and 2, yielding: 
Ia. e ~ e + e' 
lb. I e' 
lc. e' ~ e' 
2. I e' * e' 
3. NUM 
Production lc now does nothing useful because the left-and right-hand sides are identi­
cal, so it can be removed from the grammar: 
Ia. e ~ e + e' 
lb. I e' 
2. e' ~ e' * e' 
3. I NUM 
You can now apply the same process to Production 2 to get the following grammar: 225 
Controlling precedence 
when eliminating ambi­
guity. 
226 
LL(1) grammars cannot 
be left recursive. Top-Down Parsing-Chapter 4 
Ia. e ~ e + e' 
lb. I e' 
2a. e' ~ e' * e" 
2b. I e" 
2c e" ~ e' 
3. I NUM 
and substituing the e' for e" in Production 2c, you get: 
la. e ~ e + e' 
lb. I e' 
2a. e' ~ e' * e" 
2b. I e" 
2c. e" ~ e" 
3. I NUM 
Finally, removing the redundant production yields: 
la. e ~ e + e' 
lb. I e' 
2a. e' ~ e' * e" 
2b. I e" 
3. e" ~ NUM 
This grammar is left associative, and+ is lower precedence than*· 
4.8.6 Eliminating Left Recursion* 
LL(l) grammars cannot be left recursive. The basic proof of this statement is as fol­
lows: 
(1) In all practical grammars, if any right-hand side of a production is left recursive, 
there must be at least one nonrecursive right-hand side for the same nonterminal. 
For example, if a grammar has a singleton production of the form s~s a., all deriva­
tions that use that production go on forever: 
s ~ sa. 
~ sa.a. 
~ sa.a.a. 
You need to add a nonrecursive right-hand side of s for the derivation to terminate. 
(2) If x is a left-recursive nonterminal, the selection sets for all productions with x on 
their left-hand side must contain FIRST( x ), so, in all practical grammars, left­
recursive productions must have selection-set conflicts. 
Unfortunately, you need left recursion to get left associativity in a list. Fortunately, 
you can always eliminate left recursion from a grammar in such a way that the translated 
grammar recognizes the same input strings. The basic strategy looks at what left­
recursive list grammars actually do. A list such as an expression (a list of operands 
separated by operators) is either a single operand or a single operand followed by one or 
more operator/operand pairs. You can express this structure with the following left­
recursive grammar: 
list ~ operand 
I list operator operand 
Section 4.8.6-Eliminating Left Recursion* 
The following nonrecursive grammar recognizes the same input strings, however: 
list ~ 
list' ~ 
I operand list' 
operator operand 
E 
So, our goal is to translate lists of the first form into lists of the second form. If a produc­
tion is a self left recursive like the following: 
s~sal~ 
(the left-hand side is duplicated as the first symbol on the right-hand side: s is a single 
nonterminal; a and ~ are collections of terminals and nonterminals), you can make it 
nonrecursive by shuffling the production around as follows: 
s ~ ~s' 
s' ~ as' 
I E 
Applying this translation rule to the following productions: 
expr ~ expr +term { act2} I term {act 1} 
the following relationships exist between the s, a, and ~ in the rule and the real produc­
tions: 
s ~ s a ~ 
expr ~ expr +term { act2} term { act1} 
s, which is a single nonterminal, corresponds to an expression; a, which is a collection of 
terminals and nonterminals, corresponds to the + term, and ~. which is also a collection 
of terminals and nonterminals, corresponds to the second term (in this case, it's a collec­
tion of only one symbol). Productions like the foregoing can be shuffled around to look 
like this: 
s ~ ~s' 
s' ~as' 
I E 
The s' is a new nonterminal. You could call it anything, but just adding a ' is easiest. 
Applying the foregoing to the real productions yields: 
s 
expr ~ ~ 
~ term { act1} 
s' ~ a 
expr' ~ +term { act2} s' 
expr' 
s' 
expr' E 
E 
Figure 4.8 shows a parse for the input 1 + 2 + 3 for both the untranslated and translated 
grammars. The important thing to notice is that, even though the parse tree for the 
translated grammar is now right associative (as you would expect from looking at the 
grammar), the order in which the terminal nodes are processed is identical in both trees. 
That is, the actions are performed in the same sequence relative to the input in both 
grammars. So there is still left associativity from the point of view of code generation, 
even though the parse itself is right associative. 
The foregoing substitution process can be generalized for more complex grammars 
as follows: 227 
Order in which actions 
are executed with 
transformed grammar. 
228 Top-Down Parsing-Chapter 4 
Figure 4.8. Parse Trees for Translated and Untranslated, Left-Associative Grammars 
expr ~ expr + term {act2} 
I term {actl} 
term ~ NUMBER 
expr14 ~ 
expr9 +10 term 12 {act2} 1J ~ 
term1 {act2} 8 NUMBER11 
I 1+2+3 
expr ~ term {actl} expr' 
expr' ~ + term {act2} expr' I £ 
term ~ NUMBER 
expr16 ~ 
{actl}J expr'15 ~ 
NUMBER I {act2 h expr' 14 ~ 
term2 lactllJ NUMBER 6 NUMBERS +. term10 {act2f! 1 expr'1J 
I 
NUMBER I 
Corner substitution 
translates indirect recur­
sion to self recursion. s ~ s a1 I s ~ I ... I s 
a. I 131 I 132 I. .. I 13m 
you can replace the foregoing with: 
s ~ l31 s' I l32 s' I ... I 13m s' 
s' ~ a1 s' I ~ s' I ... I a. s' I E NUMBER 9 
Though the method just described works only with self-recursive productions, it's an 
easy matter to use a comer substitution to make an indirectly recursive grammar self 
recursive. For example, in a grammar like this: 
I. 
2. 
3. expr 
ele list ~ ele list 
~ NUMBER 
I expr PLUS NUMBER 
you can use a comer substitution to make the grammar self-recursive, replacing the 
ele _list comer in Production I with the right-hand sides of Productions 2 and 3 to yield 
the following: 
Ia. 
lb. 
2. 
3. expr 
ele list ~ NUMBER 
I expr PLUS NUMBER 
~ NUMBER 
I expr PLUS NUMBER 
Productions 2 and 3 are now unreachable, so can be eliminated from the grammar. 
Section 4.9-Implementing LL(I) Parsers 
4.9 Implementing LL(1) Parsers 
The remainder of this chapter discusses implementation details for the foregoing 
theory. Skip to the next chapter if you're not interested. 
4.9.1 Top-Down, Table-Driven Parsing- The LLama Output File 
First, an in-depth look at the LLama output file, in which the top-down parse algo­
rithm is actually implemented, seems in order. A user's manual for LLama is presented 
in Appendix E, and you should read that appendix before continuing. This section exam­
ines the LLama output file created from the input file at the end of Appendix E. Listing 
4.2 shows token definitions that are generated from the %term directives in the LLama 
input file. These are the same symbolic values that are used in the previous section. 
Listing 4.2. llout.h- Symbolic Values for Tokens 
I #define EOI 0 
2 #define PLUS 1 
3 #define TIMES 2 
4 #define NUM OR ID 3 
5 #define LP 4 
6 #define RP 5 
7 #define SEMI 6 
The LLama C-source-code output file begins in Listing 4.3. Most of the file is 
copied from the template file llama.par, in a manner identical to the IJX template file 
described in Chapter Three4. Lines three to 23 were copied from the input file, and the 
remainder of the listing was generated by LLama. Lines 28 to 33 define the boundaries 
of the numbers that represent terminals, nonterminals, and actions on the stack (as were 
described in the previous section). The minimums won't change, but the maximums 
will. 
The next part of llout.c (in Listing 4.4) is copied from the template file. <stdarg.h> 
is included on Line 42 only if it hasn't been included earlier. The <toolslyystack.h> file 
included on the next line contains various stack-manipulation macros, and is described 
in Appendix A. The macros on lines 45 to 47 determine what xis, using the earlier lim­
its. The remainder of the listing is macros that define various parser limits described in 
Appendix E. These definitions are active only if you haven't defined the macros yourself 
in a % { %} block at the top of the input file. YY _ TTYPE (on line 34) is used to declare 
the tables. 
Various stacks are declared on lines 89 to 108 of Listing 4.4. The <yystack.h> mac­
ros described in Appendix A are used for this purpose, and various <yystack.h> macros 
are customized on lines 90 to 94 for the current use-yyerror () works like printf () 
but doesn't mess up the windows when it's used. The parse stack is defined on line 98, 
and the value to stack is on lines 100 to 108. Note that the <yystack.h> macros can't be 
used here because the value stack is a stack of structures. 
The next part of llout.c (in Listing 4.5) is generated by LLama. It contains the 
definitions for the parse tables discussed in the previous section. The tables in Listing 
4. That's why some of the following listings are labeled /lama.par and others are labeled /lout.c". The tables 
(which are generated by LLama) are in listings labeled /lout.c. I'm sorry if this is confusing, but it's the 
only way I can keep track of what's where. Definitions generated 
from %term. 229 
Numerical limits of token­
ized input symbols. 
Parse-and value-stack 
declarations. 
Parse-table declarations. 
230 Top-Down Parsing-Chapter 4 
Listing 4.3./lout.c- File Header-Numeric Limits 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 #include <stdio.h> 
#define YYDEBUG 1*------------------------------------------------------------
* Temporary-variable names are stored on a stack. name() pops a name off 
* the stack and freename(x) puts it back. A real compiler would do some 
* checking for stack overflow here, but there's no point in cluttering the 
* code for now. 
*I 
char 
{ *Namepoo1[] = 
"tO", "tl", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9" 
} ; 
char **Namep = Namepoo1 
char *newname () 
char *freename( char *x) 
extern char *yytext; 
extern int yy1eng; 
#define YYSTYPE char* return(*Namep++); 
return(*--Namep = x); 
1*--------------------------------------*1 
#include "11out.h" 
#define YY MINTERM 1 I* Smallest terminal. 
#define YY MAXTERM 6 I* Largest terminal. 
#define YY MINNONTERM 256 I* Smallest nonterminal. 
#define YY MAXNONTERM 261 I* Largest nonterminal. 
#define YY START STATE 256 I* Goal symbol (push to start 
#define YY MINACT 512 I* Smallest action. parse) . *I 
*I 
*I 
*I 
*I 
*I 
Listing 4.4. /lama.par- File Header-Macro Definitions 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 typedef unsigned char YY_TTYPE; I* Type used for tables. *I 
I* Failure transition in table. *I #define YYF (YY_TTYPE) ( -1 ) 
1*--------------------------------------------------------------
* Parser for llama-generated tables 
*I 
#ifndef va start 
#include <stdarg.h> 
#endif 
#define YY_ISTERM(x) 
#define YY_ISNONTERM(x) 
#define YY_ISACT(x) 
#ifndef YYACCEPT (YY_MINTERM <= (x) && (x) <= YY MAXTERM 
(YY_MINNONTERM <= (x) && (x) <= YY_MAXNONTERM) 
(YY_MINACT <= (x) ) 
# define YYACCEPT return(O) I* Action taken when input is accepted. 
#endif *I 
.... 
Section 4.9.1-Top-Down, Table-Driven Parsing- The LLama Output File 231 
Listing 4.4. continued ... 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 #ifndef YYABORT 
# define YYABORT return(l) /* Action taken when input is rejected. */ 
#endif 
#ifndef YYPRIVATE 
# define YYPRIVATE static /* Define to a null string to make public. */ 
#endif 
#ifndef YYMAXERR 
# define YYMAXERR 25 
#endif 
#ifndef YYMAXDEPTH 
# define YYMAXDEPTH 128 
#endif 
#ifndef YYSTYPE 
# define YYSTYPE int 
#endif 
extern int 
extern int 
extern char 
extern int 
extern char 
extern int 
extern char 
extern void yylineno; 
yyleng; 
*yytext; 
ii_plineno () 
*ii_ptext () 
ii_lineno () 
*ii_text () 
ii_mark_prev () /* Abort after this many errors. */ 
/* Parse- and value-stack depth. */ 
/* Used to declare fields in value stack. */ 
/* Supplied by LeX. *I 
/* in l.lib::input.c. *I 
void yyerror( char *fmt, ... ); 
/*----------------------------------------------------------------------
* Parse and value stacks: 
*I 
#include 
#undef 
#define 
#undef 
#define <tools/yystack.h> 
yystk_cls 
yystk_cls YYPRIVATE 
yystk_err 
yystk_err (o) ( (o) ? (yyerror ("Stack overflow\n" ) , exit (1)) \ 
(yyerror("Stack underflow\n"),exit(l)) ) 
#define yytos(stk) yystk_item( stk, 0 ) /*Evaluates to top-of-stack item. */ 
yystk_dcl( Yy_stack, int, YYMAXDEPTH ); 
typedef struct 
{ /* Typedef for value-stack elements. */ 
YYSTYPE left; 
YYSTYPE right; /* Holds value of left-hand side attribute. */ 
/* Holds value of current-symbol's attribute. */ 
yyvstype; 
yyvstype Yy_vstack[ YYMAXDEPTH ]; 
yyvstype *Yy_vsp = Yy_vstack + YYMAXDEPTH; /* Value stack. */ 
/* Value-stack pointer. */ 
.... 
232 Top-Down Parsing-Chapter 4 
Listing 4.4. continued ... 
110 @ 
Ill @ Tables go here. LLama removes all lines that begin with @ when it copies 
112 @ llama.par to the output file. 
113 ~L 
4.5 are identical in content to the ones pictured in Figure 4.6 on page 210. Note that the 
Yyd table on lines 179 to 184 is not compressed because this 0utput file was generated 
with the -fswitch active. Were -fnot specified, the tables would be pair compressed, as 
is described in Chapter Two. The yy _act () subroutine on lines 199 to 234 contains the 
switch that holds the action code. Note that$ references have been translated to expli­
cit value-stack references (Yy _ vsp is the value-stack pointer). The Yy _ synch array on 
lines 243 to 248 is a -}-terminated array of the synchronization tokens specified in the 
%synch directive. 
Listing 4.5. llout.c- Parse Tables 
114 /*-----------------------------------------------------
115 * The YypNN arrays hold the right-hand sides of the various productions, listed 
116 * back to front (so that they will be pushed in reverse order), NN is the 
117 *production number (to be found in the symbol-table listing output with a -s 
118 * command-line switch). 
119 * 
120 * Yy_pushtab[} is indexed by production number and points to the appropriate 
121 * right-hand-side (YypNN) array. 
122 *I 
123 
YYPRIVATE int Yyp07[]={ 0 } ; 
YYPRIVATE int Yyp06 [] ={ 2 61, 517, 260, 516, 2, 
YYPRIVATE int Yyp09[]={ 5, 257, 4, 0 } ; 
YYPRIVATE int Yyp08 [] ={ 518, 3, 0 } ; 
YYPRIVATE int Yyp04[]={ 0 } ; 
YYPRIVATE int Yyp03[]={ 259, 515, 258, 514, 1, 
YYPRIVATE int Yyp05 [] ={ 261, 260, 0 } ; 
YYPRIVATE int Yyp02[]={ 259, 258, 0 } ; 124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 YYPRIVATE int YypOl[]={ 256, 6, 513, 257, 512, 
YYPRIVATE int YypOO []={ 0 } ; 
135 YYPRIVATE int *Yy_pushtab[] 
136 { 
137 YypOO, 
138 Yyp01, 
139 Yyp02, 
140 Yyp03, 
141 Yyp04, 
142 Yyp05, 
143 Yyp06, 
144 Yyp07, 
145 Yyp08, 
146 Yyp09 
147 } ; 
148 0 } ; 
0 } ; 
0 } ; 
149 /*-----------------------------------------------------
150 * Yyd[] [} is the DFA transition table for the parser. It is indexed 
151 * as follows: 
Section 4.9.1-Top-Down, Table-Driven Parsing-The LLama Output File 233 
Listing 4.5. continued ... 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 * 
* 
* 
* 
* 
* 
* Input symbol +----------------------+ 
L Production number 
H or YYF 
s +----------------------+ 
* The production number is used as an index into Yy_pushtab, which 
* looks like this: 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* Yy_pushtab YypDD: 
+-------+ +----------------+ 
*---1------>1 
+-------+ +----------------+ 
*---1----> 
+-------+ 
*---1----> 
+-------+ 
* YypDD is the tokenized right-hand side of the production. 
* Generate a symbol table listing with llama's -1 command-line 
* switch to get both production numbers and the meanings of the 
* YypDD string contents. 
*I 
YYPRIVATE YY TTYPE Yyd[ 6 l [ 7 
{ 
I* 00 *I 0, -1, -1, 1, 1, -1, -1 ), 
I* 01 *I -1, -1, -1, 2, 2, -1, -1 ), 
I* 02 *I -1, -1, -1, 5, 5, -1, -1 ), 
I* 03 *I -1, 3, -1, -1, -1, 4, 4 ), 
I* 04 *I -1, -1, -1, 8, 9, -1, -1 ), 
I* 05 *I -1, 7, 6, -1, -1, 7, 7 ) 
) ; 
1*-----------------------------------------------------
* yy_next(state,c) is given the current state and input 
* character and evaluates to the next state. 
*I 
#define yy_next(state, c) Yyd[ state ] [ c ] 
1*-----------------------------------------------------
* Yy_act() is the action subroutine. It is passed the tokenized value 
* of an action and executes the corresponding code. 
*I 
YYPRIVATE int yy_act( actnum) 
{ 
I* The actions. Returns 0 normally but a nonzero error code can be returned 
* if one of the acts causes the parser to termina.te abnormally. 
*I 
switch( actnum 
{ 
case 512: 
{ (Yy_vsp[1] .right)=(Yy vsp[2] .right)=newname();) 
break; 
234 Top-Down Parsing-Chapter 4 
Listing 4.5. continued ... 
210 case 513: 
211 {freename((Yy_vsp[O] .right));) 
212 break; 
213 case 514: 
214 { (Yy_vsp[l] .right)=(Yy_vsp[2] .right)=newname();) 
215 break; 
216 case 515: 
217 { yycode ("%s+=%s\n", Yy_vsp->left, (Yy_vsp[O].right)); 
218 freename( (Yy_vsp[O] .right));) 
219 break; 
220 case 516: 
221 { (Yy_vsp[l] .right)=(Yy_vsp[2] .right)=newname() ;) 
222 break; 
223 case 517: 
224 {yycode ("%s*=%s\n", Yy_vsp->left, (Yy vsp [0]. right)); 
225 freename((Yy_vsp[O] .right));) 
226 break; 
227 case 518: 
228 { yycode("%s=%0.*s\n",Yy_vsp->left,yyleng,yytext); 
229 break; 
230 default: printf ("INTERNAL ERROR: Illegal act number (%s) \n", actnum); 
231 break; 
232 
233 return 0; 
234 
235 
236 l*-----------------------------------------------------
237 * Yy_synch[] is an array of synchronization tokens. When an error is 
238 * detected, stack items are popped until one of the tokens in this 
239 * array is encountered. The input is then read until the same item is 
240 * found. Then parsing continues. 
241 *I 
242 
243 YYPRIVATE int Yy_synch[] 
244 { 
245 RP, 
246 SEMI, 
247 -1 
248 ); 
249 
250 l*-----------------------------------------------------
251 * Yy_stok[] is used for debugging and error messages. It is indexed 
252 * by the internal value used for a token (as used for a column index in 
253 * the transition matrix) and evaluates to a string naming that token. 
254 *I 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 char 
{ 
) ; *Yy_ 
I* 
I* 
I* 
I* I* I* 
I* stok [ l 
0 *I 
1 *I 
2 *I 
3 *I 
4 *I 
5 *I 
6 *I = 
II EOI II 
' "PLUS", 
"TIMES", 
"NUM OR ID", -"LP", 
"RP", 
"SEMI" 
Section 4.9.1-Top-Down, Table-Driven Parsing- The LLama Output File 
Listing 4.5. continued ... 
267 
268 #ifdef YYDEBUG 
269 
270 l*-----------------------------------------------------
271 * Yy_snonterm[] is used only for debugging. It is indexed by the 
272 * tokenized left-hand side (as used for a row index in Yyd[]) and 
273 * evaluates to a string naming that left-hand side. 
274 *I 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 char 
{ 
} ; *Yy_ snonterm[] 
I* 256 *I "stmt", 
I* 257 *I "expr", 
I* 258 *I "term", 
I* 259 *I "expr'", 
I* 260 *I "factor", 
I* 261 *I "term'" 
286 l*-----------------------------------------------------
287 * Yy_sact[] is also used only for debugging. It is indexed by the 
288 * internal value used for an action symbol and evaluates to a string 
289 * naming that token symbol. 
290 *I 
291 
292 char *Yy_sact [] = 
293 { 
294 II { 0 } II I II { 1 } II I II { 2 } II I II { 3 } II I II { 4 } II I II { 5 } II I II { 6 } II 
295 } ; 
296 
297 #endif 235 
The arrays following line 256 provide human-readable diagnostics; they translate the 
various numeric values of the symbols into strings representing those symbols. 
Yy _ stok, on lines 256 to 265, is indexed by token value and evaluates to a string 
representing the token's name. Similarly, Yy _ snonterm [] on line 276 translates non­
terminals, and Yy _ sact [ ] on line 431 puts the actions in some sort of readable form. 
The { 0}, and so forth, are mapped to the actual code in the llout.sym file, generated by 
giving LLama a-s, -S, or -D command-line switch. Symbol-to-string conver­
sion arrays: Yy_stok, 
Yy_snonterm,Yy_sact. 
Listing 4.6 starts moving into the parser proper. The streams declared on lines 300 to 
302 are used for output to the code, bss, and data segments respectively. They're all ini­
tialized to stdout, but you can change them with an fopen () call. 
The remainder of Listing 4.6 provides alternate versions of functions and macros for 
debugging (YYDEBUG defined) production modes. The macros and subroutines on lines 
306 to 431 are used if debug mode is active, otherwise the same macros and subroutines 
are redefined on lines 431 to 497 not to print diagnostics, and so forth. 
If YYDEBUG is defined, a second parse stack (Yy _ dstack) is defined on line 308. 
This second, symbol stack exactly parallels the normal parse stack, but it holds strings 
representing the symbols, which are in tum represented by the numbers on the normal 
parse stack. For example, an expr is represented by the number 257 on the parse stack, 
and every time a 257 is pushed on the normal parse stack, the string "expr" is pushed 
onto the debugging stack. A string is popped (and discarded) from the symbol stack 
when a number is popped from the normal parse stack. This symbol stack is used in the 
debugging environment to make stack activity a little easier to follow. Output streams. 
Debugging functions and 
macros, YYDEBUG. 
Symbol stack, 
Yy_dstack. 
236 Top-Down Parsing-Chapter 4 
Listing 4.6.llama.par- Macros for Parsing and Debugging Support 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 348 
349 
350 
351 
352 
353 
354 
355 /*----------------------------------------------------------------------*/ 
FILE *yycodeout 
FILE *yybssout 
FILE *yydataout 
int yynerrs stdout 
stdout 
stdout 
0; /* /* 
/* 
/* Output stream 
Output stream 
Output stream 
Error count. for code. *I 
for initialized data. *I 
for uninitialized data. *I 
*I 
/*----------------------------------------------------------------------*/ 
#ifdef YYDEBUG /* Debugging parse stack. *I 
yystk_dcl( Yy_dstack, char*, YYMAXDEPTH ); 
YYPRIVATE char *yy_sym( sym ) 
{ 
/* Return a pointer to a string representing the symbol, using the 
* appropriate table to map the symbol to a string. 
*I 
return ( YY_ISTERM( sym ) I I !sym 
( YY_ISNONTERM( sym ) 
/* assume it's an act ? Yy_stok [sym]: 
? Yy_snonterm [sym -YY_MINNONTERM]: 
*/ Yy_sact [sym -YY_MINACT] 
/* Stack-maintenance. yy_push and yy_pop push and pop items from both the 
* parse and symbol stacks simultaneously. The yycomment calls in both routines 
* print a message to the comment window saying what just happened. The 
* yy_pstack() call refreshes the stack window and also requests a new command 
*from the user. That is, in most situations, yy_pstack() won't return until 
*the user has typed another command (exceptions are go mode, and so forth). 
* yy_pstack() also checks for break points and halts the parse if a breakpoint 
* condition is met. 
*I 
YYPRIVATE 
int 
YYSTYPE 
{ 
yypush 
yypush_ yy_push(x, val) 
x; 
val; 
Yy_stack, x 
Yy_dstack, yy_sym(x) 
--Yy_vsp; 
Yy_vsp->left = Yy_vsp->right = val; ) ; 
) ; 
yycomment( "push %s\n", yy_sym( x) ); 
yy_pstack( 0, 1 ); 
YYPRIVATE yy_pop() 
{ 
int prev_tos = yypop( Yy_stack ); 
++Yy_vsp; /* Push 
I* Push 
I* 
/* 
yycomment( "pop %s\n", yypop_( Yy_dstack) ); 
yy_pstack ( 0, 1 ); 
return prev_tos; this onto the state stack.*/ 
this onto the value stack.*/ 
The push() macro checked *I 
for overflow already. *I 
.... 
Section 4.9.1-Top-Down, Table-Driven Parsing- The LLama Output File 237 
Listing 4.6. continued ... 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 YYPRIVATE yy say_whats_happening(tos_item, production) 
int tos_item; 
int production; 
{ /* Item at top of stack */ 
/* production number we're about to apply*/ 
/* Print a message in the comment window describing the replace operation 
* about to be performed. The main problem is that you must assemble a 
* string that represents the right-hand side of the indicated production. 
* I do this using the appropriate Yy_pushtab element, but go through the 
* array backwards (the Yy_pushtab arrays have been reversed to make the 
*production-mode parse more efficient--you need to unreverse them here). 
*I 
char 
int 
int buf[80]; 
count; 
*start, *end; /* Assemble string representing right-hand side 
/* Maximum size of string representing RHS. 
/* Start and end of Yy_pushtab array that holds here.*/ 
*/ 
RHS. */ 
for( start= end= Yy_pushtab[ production]; *end; end++) /*Find end.*/ 
*buf '\0'; 
for( count= sizeof(buf); --end>= start && count> 0 ;) 
{ /* Assemble */ 
/* string. *I 
strncat( buf, yy_sym(*end), count); 
if( (count-= strlen( yy_sym(*end) + 1)) < 1 ) 
break; 
strncat( buf, "", --count); 
yycomment( "Applying %s->%s\n", yy_sym(tos item), buf ); 
/* Use the following routines just like printf() to create output. In debug 
*mode, all three routines print to the output window (yy_output() is in 
* yydebug.c). In production mode, equivalent routines print to the associated 
*streams (yycodeout, yybssout, or yydataout). The first argument to 
* yy_output() tells the routine which stream is being used. If the stream is 
* still set to the default stdout, then the message is written only to the 
* window. If the stream has been changed, however, the output is sent both 
* to the window and the associated stream. 
*I 
yycode( fmt ) 
char *fmt; 
{ /* Write something to the code-segment stream. */ 
va list args; 
va_start( args, fmt ); 
yy_output( 0, fmt, args ); 
yydata( fmt ) 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
yy_output( 1, fmt, args ); /* Write something to the data-segment stream. */ 
.... 
238 Top-Down Parsing-Chapter 4 
Listing 4.6. continued ... 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 yybss( fmt ) /* Write something to the bss-segment stream. */ 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
yy_output( 2, fmt, args ); 
/*Debugging versions of yycomment() and yy_error() are pulled out of yydebug.c 
*when YYDEBUG is defined. Similarly, yy_break(), which halts the parse if a 
* break-on-production-applied breakpoint has been triggered, is found in 
* yydebug.c. It is eliminated from the production-mode output by defining it as 
*an empty macro, below. Finally, yy_nextoken(), which evaluates to a yylex() 
* call in production mode, and which is defined in yydebug.c, both gets the 
* next token and prints it in the TOKEN window. 
*I 
#else /*-- - - - - - - - - - - - - - - */ 
# define yy_push(x,v) yypush(Yy_stack, x), \ 
--Yy_vsp, Yy_vsp->left=Yy_vsp->right=v ) 
# define yy_pop () ++Yy_vsp, yypop(Yy_stack) 
# define yy _ nextoken () yylex () 
# define yy_quit_debug () 
# define yy_sym () 
# define yy_say_whats_happening(tos 
# define yy_redraw_stack() 
# define yy_pstack(refresh,print_ 
# define yy_break(x) 
#ifndef va_list 
# include <stdarg.h> 
#else 
# ifdef va_dcl it) item, prod) ) 
MUST USE ANSI VARIABLE-ARGUMENT CONVENTIONS IN <stdarg.h> 
# endif 
#endif 
void 
char 
void 
char yycode ( fmt, ... ) 
*fmt; 
va list args; 
va start ( args, 
vfprintf( yycodeout, 
yydata ( fmt, ... ) 
*fmt; fmt 
fmt, 
va list args; 
va_start( args, fmt ); ) ; 
args ) ; 
vfprintf( yydataout, fmt, args ); 
void 
char 
{ yybss ( fmt, ... ) 
*fmt; 
va list args; 
va_start( args, fmt ); 
Section 4.9.1-Top-Down, Table-Driven Parsing-The LLama Output File 
Listing 4.6. continued ... 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 void 
char 
{ 
void 
char 
} 
#endif vfprintf( yybssout, fmt, args ); 
yycomment( fmt, ... ) 
*fmt; 
va_list args; 
va_start( args, fmt ); 
vfprintf( stdout, fmt, args ); 
yyerror( fmt, ... ) 
*fmt; 
va list args; 
extern char *yytext; 
extern int yylineno; 
va_start( args, fmt ) ; 
fprintf ( stderr, "ERROR (line %d near %s): ", yylineno, yytext ) ; 
vfprintf( stderr, fmt, args ) ; 
fprintf ( stderr, "\n" ) ; 
The symbol stack is manipulated in the push () and pop () subroutines on lines 331 
to 354. Stack boundary checking is done only on the actual parse stack because, since 
all stacks are the same size and they all run in parallel, additional checking is redundant. 
These subroutines are translated into macros on lines 433 to 436 if YYDEBUG isn't 
active. Most other details are called out in comments in the listing, to which you are 
referred. I'll look at yydebug.c, which holds all the debug-mode support routines, in a 
moment. 
The rest of llout.c is the error-recovery code and the actual parser, in Listing 4.7. 
Error-recovery is done with two subroutines on lines 502 to 545. yy _in_ synch () (on 
line 502) checks to see if the symbol passed to it is in the set of synchronization symbols 
given to the %synch directive and listed in the Yy _synch table. yy _synch () does the 
actual error recovery. The error-recovery algorithm is described in the comment on line 
516. 
Listing 4.1.llama.par- The Parser 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 508 
509 
510 
511 
512 /*------------------------------------------------------------
* ERROR RECOVERY: 
*I 
YYPRIVATE yy_in_synch( sym 
{ 
/* Return 1 if sym is in the synchronization set defined in Yy_synch. */ 
int *p 
for( p Yy_synch; *p && *p > 0 
if( *p == sym ) 
return 1; 
return 0; p++ ) 239 
240 Top-Down Parsing-Chapter 4 
Listing 4.7. continued ... 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 YYPRIVATE yy_synch( lookahead ) 
{ 
I* Recover from an error by trying to synchronize the input stream and the 
* stack. Return the next lookahead token or 0 if we can't recover. Yyparse() 
* terminates if none of the synchronization symbols are on the stack. The 
* following algorithm is used: 
* * (1) Pop symbols off the stack until you find one in the synchronization 
* set. 
* (2) If no such symbol is found, you can't recover from the error. Return 
* an error condition. 
* (3) Otherwise, advance the input symbol either until you find one that 
* matches the stack symbol uncovered in (1) or you reach end of file. 
*I 
int tok; 
if( ++yynerrs > YYMAXERR ) 
return 0; 
while( !yy_in synch( tok 
yy_pop(); 
if( yystk_empty(Yy_stack) 
return 0; yytos( Yy_stack )) \ 
&& !yystk_empty( Yy_stack )) 
while( lookahead && lookahead != tok ) 
lookahead = yy_nextoken(); 
return lookahead; I* 1 *I 
I* 2 *I 
I* 3 *I 
1*---------------------------------------------------------------------
* The actual parser. Returns 0 normally, -1 if it can't synchronize after an 
* error, otherwise returns a nonzero value returned by one of the actions. 
*I 
int yyparse () 
{ 
# int *p; I* General-purpose pointer. 
YY TTYPE prod; I* Production being processed. 
int lookahead; I* Lookahead token. 
int err code = 0; I* Error code returned by an act. 
int tchar; I* Holds terminal character in yytext. 
int actual lineno; I* Actual input line number. 
char *actual _text; I* Text of current lexeme. 
int actual _leng; I* Length of current lexeme. 
YYSTYPE val; I* Holds $$ value for replaced nonterm. 
ifdef YYDEBUG 
if( !yy init_debug( Yy_stack, 
Yy_dstack, 
Yy_vstack, &yystk_p(Yy_stack), 
&yystk_p(Yy_dstack), 
sizeof(yyvstype), YYMAXDEPTH) 
YYABORT; *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
Section 4.9.1-Top-Down, Table-Driven Parsing-The LLama Output File 241 
Listing 4.7. continued ... 
570 
571 # 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 
616 
617 
618 
619 
620 
621 
622 
623 
624 
625 
626 
627 
628 
629 yystk_clear(Yy_dstack); 
endif 
yystk_clear(Yy_stack); 
Yy_vsp = Yy_vstack + YYMAXDEPTH; 
yy_push( YY_START_STATE, (Yy_vsp-1)->left ); /* Push start state onto *I 
/* parse stack and junk *I 
/* onto the value stack. */ 
/* User-supplied init. */ yy_init_llama( Yy_vsp ); 
lookahead = yy_nextoken(); 
while( !yystk_empty(Yy_stack) 
{ 
if( YY_ISACT( yytos(Yy_stack) ) ) 
{ /* if TOS is an action, do */ 
/* it and pop the action. */ 
yylineno 
yytext 
tchar 
yytext[yyleng] ii_plineno () 
ii_ptext () 
yytext[ yyleng 
, \0' ii_plength() ]; 
if( errcode = yy_act( yytos(Yy_stack) )) 
return errcode; 
yy_pop (); 
yy_redraw_stack(); 
yytext[ yyleng ] = tchar 
else if( YY_ISTERM( yytos(Yy_stack) )) /*Advance if it's a terminal.*/ 
{ 
if( yytos(Yy_stack) != lookahead) /*ERROR if it's not there. */ 
{ 
yyerror( "%s expected\n", Yy_stok[ yytos(Yy_stack) ]) ; 
if( ! (lookahead = yy_synch(lookahead)) ) 
YYABORT; 
else 
else 
{ /* Pop the terminal symbol at top of stack. Mark the current 
*token as the previous one (we'll use the previous one as 
* yytext in subsequent actions), and advance. 
*I 
yy_pop (); 
ii_mark_prev (); 
lookahead 
actual lineno 
actual text 
actual_leng yy_nextoken(); 
yylineno; 
yytext 
yyleng 
/* Replace a nonterminal at top of stack with its right-hand side. 
* First look up the production number in the table with the 
* yy_next call. If prod==YYF, there was no legal transition and 
* error-processing is activated. Otherwise the replace operation 
* is done by popping the nonterminal, and pushing the right-hand 
* side from the appropriate Yy_pushtab entry. 
242 Top-Down Parsing-Chapter 4 
Listing 4.7. continued ... 
yylineno 
yytext 
yyleng *I 
prod= yy_next( yytos(Yy_stack)-YY_MINNONTERM, lookahead ); 
if( prod == YYF 
{ 
else 
{ yyerror( "Unexpected %s\n", Yy_stok[ lookahead] ); 
if( ! (lookahead yy_synch(lookahead)) ) 
YYABORT; 
yy say_whats_happening( yytos(Yy_stack), prod); 
yy_break( prod); 
val = Yy_vsp->right 
yy_pop (); 
for( p = Yy_pushtab[ prod 
yy_push( *p, val ) ; *p ++p ) 
actual lineno 
actual text 
actual leng /* Make these hold reasonable values in case */ 
/* the remainder of the input file must be */ 
/* processed further. */ 630 
631 
632 
633 
634 
635 
636 
637 
638 
639 
640 
641 
642 
643 
644 
645 
646 
647 
648 
649 
650 
651 
652 
653 
654 
655 
656 
657 
658 
659 
660 yy quit debug(); 
YYACCEPT; 
Top-down parser: 
yyparse (). 
Phase problems with 
yytext. The actual parser, yyparse (),starts on line 552 of Listing 4.7. For the most part, it 
is a straightforward implementation of the algorithm in Table 4.12 on page 211. The one 
difficulty not covered in the algorithm is the lexeme, yytext, which must be valid when 
the action is executed. The problem is that the match-and-advance operation that's trig­
gered when a lexeme is on top of the stack overwrites yytext with the new lexeme. 
Consequently, you have to mark the current lexeme as the previous one before advanc­
ing, using the ii _mark _prev () call on line 614 (which was put into the input routines 
described in Chapter Three for this very purpose). When a subsequent action is actually 
performed (starting on line 586), yytext is modified to reference the previous lexeme, 
not the current one-it references the lexeme associated with the token that we just 
advanced past, not the lookahead token. The code on lines 588, 589, and 596 is just null 
terminating the lexeme. 
The remainder of llout.c is just copied from the input file at the end of Appendix D. 
won't reproduce it here. 
4.9.2 Occs and Llama Debugging Support---yydebug.c 
This section discusses the debug-mode support routines used by the LLama­
generated parser in the previous section. The same routines are used by the occs­
generated parser discussed in the next chapter. You should be familiar with the interface 
to the curses, window-management functions described in Appendix A before continu­
ing. 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 243 
The debugging module, yydebug. c, starts in Listing 4.8 with various definitions, 
which you should read now (there are extensive comments that describe what the vari­
ables and definitions do--I'll discuss some of them a bit more in a moment). 
Listing 4.8. yydebug.c- Definitions 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 #include <stdio.h> 
linclude <ctype.h> 
#include <sysltypes.h> 
#include <sysltimeb.h> 
#include <curses.h> 
#include <signal.h> 
#include <stdarg.h> 
#include <io.h> 
#include <string.h> 
#include <stdlib.h> 
#include <toolsldebug.h> 
#include <toolsll.h> 
extern char *yytext; 
extern int yylineno; 
extern int yyleng; I* ANSI/UNIX time functions. 
I* ANSI/UNIX time functions. 
I* Window functions. 
I* Needed by signal. 
I* ANSI variable-argument lists. 
I* Prototypes for access(). 
I* Prototypes for string functions. 
I* Prototypes for other library functions. 
I* Various macros. 
I* Prototypes for all of l.lib, including all 
I* functions in the current file. 
I* Generated by LeX and lex. 
I* If your system doesn't have an <stdarg.h>, use the following: 
* *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
* typedef char *va_list; 
*#define va_start(arg_ptr,first) 
* #define va_arg(arg_ptr,type) arg_ptr = (va_list)&first + sizeof(first) 
((type*) (arg_ptr += sizeof(type))) [-1] 
* #define va_end() *----------------------------------------------------------------------
* The following macros take care of system dependencies. They assume a 25-line 
* screen on the IBM and a 24-line screen under Unix. Code put inside an MS() 
* macro compiles only if MSDOS is #defined. Code in a UX() macro compiles only 
* if MSDOS is not #defined. The NEWLINE define takes care of a bug in the UNIX 
* curses package that isn't present in the DOS version presented in this book 
* (it clears the bottom line after a scroll). box.h (in Appendix A) holds 
* #defines for the IBM Box-drawing characters. #define NOT_IBM_PC to use the 
*more portable defines in that file ('+' is used for corners, 'I' for vertical 
* lines, and '-' for horizontal ones) rather than the less-portable IBM 
*graphics characters. fcntl() is also used only in UNIX mode. 
*I 
#ifdef MSDOS 
# include <toolslbox.h> 
# define SCRNSIZE 25 
# define NEWLINE(win) (Interactive? waddch( win, '\n') :0) 
#else 
# define NOT IBM PC 
include <toolslbox.h> 
include <fcntl.h> 
define SCRNSIZE 24 # 
# # 
' define NEWLINE(win) (Interactive? (waddch( win, '\n'), wclrtoeol(win))\ 
0 ) 
#endif 
I* ----------------------------------------------------------------------
* Defines for the windows. STACK_TOP is the top line of the stack window. 
* DEFSTACK is the default size of the text area of the stack window. 
* STACK WINSIZE is the height of the stack window, including the border. IO TOP 
* is th~ top line of both the I/0 and comments windows, and IO_WINSIZE is the 
* height of the text area of those windows. It should use the whole screen 
244 Top-Down Parsing-Chapter 4 
Listing 4.8. continued ... 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 * less the area used for the stack and prompt windows. 
*I 
#define STACK TOP 
#define DEFSTACK 
#define STACK WINSIZE 
#define PROMPT TOP 
#define PROMPT WINSIZE 
#define IO TOP 
#define IO WINSIZE 
#define TOKEN WIDTH 
#define PRINTWIDTH 
#define ESC Ox1b 0 
11 
(Stacksize +2) 
(SCRNSIZE -3) 
3 
(STACK_WINSIZE-1) /* Stacksize=DEFSTACK by default. */ 
( (SCRNSIZE- (STACK_WINSIZE +PROMPT WINSIZE)) + 2) 
22 /* Width of token window including border. *I 
79 /* Only this many characters are printed on each 
* line by the write-screen (w) command. Extra 
* characters are truncated. 
*I 
/* ASCII ESC character. *I 
I* ----------------------------------------------------------------------
* Breakpoints. A breakpoint is set with a 'b' command. It causes automatic-mode 
* operation to terminate immediately before applying a specific production or 
* when a specified symbol is on the top of stack. P_breakpoint holds the 
* production breakpoint; T_breakpoint holds the top-of-stack breakpoint; 
* I_breakpoint is the input breakpoint. The former is an int because it's 
* always a number. The latter two are strings because they can be symbolic 
* names as well as numbers. The last variable, £_breakpoint, is the input­
* line breakpoint. 
*I 
#define BRKLEN 33 /* Longest lexeme recognized in a breakpoint + 1. *I 
PRIVATE int p _breakpoint -1 ; 
PRIVATE int L_breakpoint -1 ; 
PRIVATE char S_breakpoint[ BRKLEN '\0' 
PRIVATE char I_breakpoint[ BRKLEN { '\0' 
/*----------------------------------------------------------------------
* I've attempted to isolate these routines as much as possible from the actual 
* parser. They do need to know where all the stacks are, however. The following 
* variables are initialized at run-time by an access routine [yy_init_debug()] 
* and are used to access static variables in the parser itself. Note that the 
* addresses of the stack pointers are stored, not the contents of the stack 
* pointers. 
*I 
PRIVATE int 
PRIVATE char 
PRIVATE int 
PRIVATE char 
PRIVATE char 
PRIVATE int 
PRIVATE int 
PRIVATE int Abort 
*Vstack 
Vsize 
**Dstack 
***P_dsp 
*Sstack 
**P sp 
Depth /* Force input routine to return EOI. */ 
/* Base address of value stack (or NULL */ 
/* if called by llama-generated parser).*/ 
/* Size of one element of value stack. */ 
I* Base address of debug (symbol) stack.*/ 
/* Pointer to debug-stack pointer. */ 
/* Base address of state stack. */ 
/* Pointer to state-stack pointer. */ 
/*Stack depth (all three stacks). */ 
/*----------------------------------------------------------------------
* The following variables are all used internally 
*I 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 245 
Listing 4.8. continued ... 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 PRIVATE WINDOW *Stack window 
PRIVATE WINDOW *Prompt_window 
PRIVATE WINDOW *Code window 
PRIVATE WINDOW *Comment window 
*Token window I* Windows for the debugging screen. *I 
PRIVATE WINDOW 
PRIVATE int Stacksize = DEFSTACK;/* Number of active lines in the stack */ 
PRIVATE int Onumele 
PRIVATE int Interactive 
PRIVATE int Singlestep 
PRIVATE long Delay 
PRIVATE int Inp_ fm file 
PRIVATE FILE *Log 
PRIVATE int No_comment_pix 
PRIVATE int No_stack_pix 
PRIVATE int Horiz stack_pix 
PRIVATE int Parse_pix; 
PRIVATE int Sym_pix; 
PRIVATE int Attr_pix; 0; 
1; 
1; 
OL; 
0; 
NULL; 
0; 
0; 
0; /* 
/* 
/* 
/* 
I* 
I* 
/* 
I* 
I* 
/* /* window (doesn't include border). */ 
/* Number of elements on the stack. */ 
/*Interactive mode (not nor N). *I 
I* Single step through parse if true. */ 
/* Amount of time to wait after printing */ 
/* each stack update when not single */ 
/* stepping (milliseconds). *I 
1 if input file is open. *I 
Pointer to the log file if one is open.*/ 
1 if no comment-window output is printed.*/ 
1 if no stack pictures are to be printed *I 
in the log file.*/ 
1 if stack pictures are printed horiz- */ 
ontally in the log file. */ 
if(Horiz_stack_pix), print state stack. */ 
if(Horiz stack pix), print symbol stack. */ 
if(Horiz=stack=pix), print attrib. stack.*/ 
#ifndef MSDOS /*------------------ UNIX SYSTEM V ONLY -----------------------*/ 
PRIVATE int Char avail 0; 
#define kbhit() Char avail /* Since MS-DOS has a system call that 
* gives the keyboard status, detecting 
* if a key has been pressed without 
* reading the character is easy. In 
* UNIX you must use SIGIO to set a 
* flag (Char_avail). kbready() is the 
* SIGIO exception handler. 
*I 
#else 1*--------------------DOS VERSION ONLY -------------------------*/ 
extern int kbhit ( void ) ; /* Microsoft function. returns 1 if a */ 
/* character is waiting to be read *I 
/* from the keyboard buffer. This */ 
/* function is provided in most *I 
/* MS-DOS compiler's libraries. */ 
/* The Map[} array converts IBM box-drawing characters to something that's 
* printable. The corners are converted to plus signs, horizontal lines go to 
* dashes, and vertical lines map to vertical bars. The conv() subroutine is 
* passed a character and returns a mapped character. It must be a subroutine 
*because of the way that it's used below. It would have unacceptable 
* side-effects if rewritten as a macro. 
*I 
PRIVATE unsigned char Map[] = 
{ 
'I'' '+', '+', '+', '+'I '+', '+', 'I', '+'I '+', '+', , +', I+' I I+' I 
'+', I+' I '+'I '_, I+' I I+' I '+', '+', '+'I '+', '+', I+' I '=' I+' I ' '+'I '+'I '+'I , +'' I+' I , +'' '+'' '+', '+'I '+', '+'I '+' 
} ; 
246 Top-Down Parsing-Chapter 4 
Listing 4.8. continued ••. 
175 PRIVATE int conv(c) 
176 { 
177 return (VERT <= c && c <= UL) ? Map[c -VERT] : c ; 
178 } 
179 #endif /*--------------------------------------------------------------*/ 
Initialize debugging: 
yy_init_debug (). 
Getting keyboard status 
underUNIX, SIGIO. 
Disable curses on abort. 
q command raises 
SIGINT. 
Parsing command-linear­
guments: 
yy_get_args (). The actual code starts in Listing 4.9. The yy _ ini t _debug () function on line 180 ini­
tializes the debugging functions. It is passed pointers to various variables in the parser 
proper that it needs to draw the windows (things like the base addresses of the stacks). 
Note that pointers to the stack pointers are passed, rather than the contents of the stack 
pointers. This way the parser can push and pop stuff at will without having to tell the 
debugging routines every time it does a push or pop. The debugging routines can just 
examine the pointers themselves. The vstack argument is NULL if a LLama-generated 
parser is active (because LLama doesn't use a value stack). In this case, the value stack 
is not printed in the log file or the stack window. 
The signal() call on line 197 is used to determine keyboard status in UNIX sys­
tems. (The ux macro is defined in debug.h. It's discussed in Appendix A.) The SIGIO 
signal is generated every time a key is struck. Here, the signal activates the kbready () 
function (declared on line 257) which sets a global flag (Char _avail) to true. This flag 
can be examined when you're looking to see if a character is ready. The flag is explicitly 
set back to zero when the character is finally read. The fcntl () call on line 198 
enables SIGIO (the signal is not generated otherwise). 
The second signal () call on line 211 is used to disable curses when a Ctrl-Break 
(Ctri-C or DEL in UNIX) comes along. Curses must be turned off explicitly in this case to 
prevent the screen from being left in an unknown state (with characters not echoing, and 
so forth). The handler is on line 263. Note that it disables SIGINT on line 265 so that 
another Ctrl-Break won't interrupt the shut-down process (this is not a problem on newer 
UNIX, versions, but it can't hurt). The q command to the debugger quits by raising the 
SIGINT signal, which will execute the handler. This way, any cleaning up of temporary 
files that is done by a signal handler in the compiler itself is also done when you quit the 
debugger. You can use the a command if you want to leave the debugger without clean­
ing up. 
Input buffering and character echo is turned off on line 213 of Listing 4.9. Note that 
this is necessary in the BSD curses that runs on the UNIX system that I use, but may be 
contraindicated on other systems. Ask your system administrator if this is the correct 
thing to do with your implementation. The windows themselves are opened on the next 
few lines. The boxwin () function (defined on line 287) works much like a standard 
newwin () call. It opens up two windows: the outer one as a subwindow to stdscr, 
and the inner one as a subwindow to the outer one. The outer window holds the box and 
the inner window holds the text. This way, text written to the inner window won't 
overwrite the box. The window title is printed, centered, in the top line of the box. 
The final routine of interest in Listing 4.9 is the yy _get_ args () function on line 
320. This routine parses the command line for a stack size (specified with -s) and an 
input-file name. If you don't want to get this information from the command line, you 
can do the following: 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 247 
floccinaucinihilipilification() 
{ 
static char *vects[] = 
{ 
} ; "" , 
"-slB", 
"test" 
yy_get_args( 3, vects ) ; /* Simulate argv. 
/* Junk 
/* Stack-window size 
/* Input file name. *I 
*I 
18 lines. */ 
*I 
Listing 4.9. yydebug.c- Initialization 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 218 
219 
220 
221 
222 
223 
224 
225 
226 PUBLIC int yy_init_debug(sstack, p_sp, dstack, p_dsp, vstack, v ele size, depth) 
int *sstack; /* Base address of state stack. *I 
int **p_sp; /* Address of state-stack pointer. *I 
char **dstack; /* Address of debug stack. *I 
char ***p_dsp; /* Address of debug-stack pointer. *I 
void *vstack; /* Base address of value stack or NULL for LLama. *I 
int 
int v ele size; /* Size of one element of value stack. 
depth; /* Number of elements in all three stacks. 
I* Initialize for interactive I/0 for curses. Return 1 on a successful 
* initialization, 0 otherwise. 
*I 
char buf [ 80]; 
UX ( int flags; 
UX( signal( SIGIO, kbready); 
UX( flags= fcntl( fileno(stdin), F_GETFL, 0 ); 
UX( fcntl( fileno(stdin), F_SETFL, flags I FASYNC ); 
Sstack 
Dstack 
Vstack 
Vsize 
P_sp 
P_dsp 
Depth 
Abort sstack; 
dstack; 
(char *) vstack; 
v ele size; 
p_sp; 
p dsp; 
depth; 
0; 
initscr(); 
signal( SIGINT, die_a_horrible death ) ; *I 
*I 
noecho(); 
crmode(}; /* Don't echo input characters automatically. */ 
MS( nosave(); 
Stack window 
Comment window 
Code window 
Prompt_window 
Token window /* Don't buffer input. */ 
/* Don't save region under windows (my curses only). *I 
boxwin( STACK_WINSIZE, 80, STACK TOP, 0, "[stack]" ) ; -boxwin( IO_WINSIZE, 40, IO TOP, 0, "[comments]" ) ; -boxwin( IO_WINSIZE, 41, IO TOP, 39, "[output]" ) ; -
boxwin(PROMPT_WINSIZE, (80 -TOKEN _WIDTH) + 1, 
PROMPT_TOP, 0, "[prompts]" ); 
= boxwin(PROMPT_WINSIZE, TOKEN_WIDTH, PROMPT_T.OP, 
80-TOKEN_WIDTH, "[lookahead]" ); 
scrollok( Stack_window, TRUE ) ; 
248 Top-Down Parsing-Chapter 4 
Listing 4.9. continued ... 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 258 
259 
260 
261 
262 
263 
264 
265 
266 
267 268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 scrollok( Comment window, 
scrollok( Code window, -scrollok( Prompt_window, 
scrollok( Token_window, 
wrapok ( Token_window, 
Onumele 0; 
while( !Inp_fm_file 
{ TRUE ) ; 
TRUE ) ; 
TRUE ) ; 
TRUE ) ; 
FALSE ) ; 
/* If you don't have an input file yet, get one. yyprompt() prints the 
* prompt in the PROMPT window, and fills buf with the reply. 
*I 
if ( ! yyprompt ( 11 Input file name or ESC to exit: 11, buf, 1 ) ) 
{ 
yy_quit_debug (); 
return 0; 
new input_file( buf ); 
) 
delay(); 
return 1; /* Wait for a command before proceeding.*/ 
/*----------------------------------------------------------------------
* Exception handlers: 
*I 
#ifndef MSDOS 
PRIVATE void 
{ kbready () 
Char avail = 1; 
) 
#endif /* Called when new character is available. *I 
PRIVATE void die_a_horrible_death() 
{ /* Come here on a SIGINT */ 
/* or 'q' command. */ 
signal( SIGINT, SIG_IGN ); 
yy_quit_debug(); 
exit ( 0 ) ; 
PUBLIC void yy_quit_debug() 
{ 
echo(); 
nocrmode(); 
move( 24, 0 ); 
refresh(); 
endwin(); 
if( Log ) 
fclose( Log); 
stop_prnt(); 
signal( SIGINT, SIG DFL ); /* Normal termination. */ 
I* Turn echo and editing back on. */ 
/* Put the cursor on the bottom of the screen. */ 
/* Turn off curses. */ 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 249 
Listing 4.9. continued ... 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 /*----------------------------------------------------------------------*! 
PRIVATE WINDOW *boxwin( lines, cols, y_start, x_start, title ) 
int 
int 
int 
int 
char 
{ lines; 
cols; 
y_start; 
x_start; 
*title; 
/* This routine works just like the newwin() except that the window has a 
* box around it that won't be destroyed by writes to the window. It 
* accomplishes this feat by creating two windows, one inside the other, 
* with a box drawn in the outer one. It prints the optional title centered 
* on the top line of the box. Set title to NULL (or "") if you don't want 
* a titl?. Note that all windows are made subwindows of the default window 
* to facilitate the print-screen command. 
*I 
WINDOW *outer; 
outer= subwin( stdscr, lines, cols, y_start, x_start); 
box( outer, VERT, HORIZ ) ; 
if( title && *title 
{ 
wmove outer, 0, (cols- strlen(title))/2 ); 
wprintw( outer, "%s", title); 
wrefresh (outer); 
return subwin( outer, lines-2, cols-2, y_start+l, x start+l ); 
/*----------------------------------------------------------------------*/ 
PUBLIC int yy_get_args( argc, argv) 
char 
{ **argv;-
/* Scan argv arguments for the debugging options and remove the arguments 
* from argv. Recognized arguments are: 
* * -sN 
* 
* 
* Set stack-window size to N lines. The size of the other windows 
scale accordingly. The stack window is not permitted to get so 
large that the other windows will disappear, however. 
* The first argument that doesn't begin with a minus sign is taken to be 
* the input file name. That name is not removed from argv. All other 
* arguments are ignored and are not removed from argv, so you can process 
* them in your own program. This routine prints an error message and 
* terminates the program if it can't open the specified input file. 
* Command-line processing stops immediately after the file name is 
* processed. So, given the line: 
* 
* 
* program -x -s15 -y foo -sl bar 
* Argv is modified to: 
* 
* 
* program -x -y foo -sl bar 
* The file "foo" will have been opened for input and the stack window will .... 
250 Top-Down Parsing-Chapter 4 
Listing 4.9. continued ••• 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 * be 15 lines high. Return new value of argc that reflects the removed 
* arguments; 
*I 
char **newargv; 
char **oldargv argv; 
char *filename NULL; 
int ssize DEFSTACK; 
newargv = ++argv; 
for( --argc; --argc >= 0; ++argv 
{ 
if( argv[O] (OJ != '-' 
{ 
filename *newargv++ 
break; *argv; 
else if( argv[O] [1] == 's' ) 
ssize = atoi ( &argv[O] (2] ) ; 
else 
*newargv++ = *argv; I* -s *I 
I* Don't copy to *newargv here. *I 
I* -? *I 
Stacksize ssize < 1 ? DEFSTACK 
ssize > (SCRNSIZE-6) ? SCRNSIZE-6 
I* ssize is in bounds *I ssize 
if( filename ) 
{ 
I* Open input file if one was specified on the command line. *I 
if( ii_newfile(filename) != -1 ) 
Inp_fm_file = 1; 
else 
{ 
perror( filename ) ; 
exit ( 1 ) ; 
return newargv -oldargv; 
Output functions: yyer­
ror (). The next listing (Listing 4.1 0) holds all the output functions. There is one such rou­
tine for each window. In addition, yyerror () (on line 510), writes to the comment 
window and simulates the standard yyerror () function by adding an input line number 
and token value to the error message. In addition to the standard output functions, 
display_file () (on line 558 of Listing 4.10) is used by the/command to print a file 
in the stack window, and write_screen () is used by the w command to save the 
current screen to a file. Note that, since everything's a subwindow to stdscr, the 
stdscr functions can be used on line 654 to read the entire screen (rather than doing it 
window by window). 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 251 
Listing 4.10. yydebug.c- Window Output Functions 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 398 
399 
400 
401 
402 
403 
404 
405 
406 
407 408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 438 
439 
440 
441 
442 
443 
444 PRIVATE void 
WINDOW *win; 
{ prnt_putc(c, win) 
I* All output done through prnt_putc is suppressed in Go mode. Also note 
*that the arguments are reversed from addch(). This reversal lets you use 
*the prnt() subroutine (described in Appendix A), which expects a putc()­
* like output function. Newlines are suppressed here so that you can have 
* more control over scrolling. Similarly, sequences of white space are 
* replaced by a single space character to conserve space in the window. 
* Test_c is used to take care of the IBM graphics characters that form 
* the vertical line separating the stream-identification column from the 
*actual output. The cis mapped to a 'I' if it's too large to be an ASCII 
*character (so isspace() will work properly). 
*I 
static WINDOW *last win NULL; 
static int last c 0; 
int 
if( 
{ test c; -
Interactive && c != , \n' ) 
test c = {c < Ox7f) ? c : , I , ; 
-
if( ! (win==last win && isspace(test_c) && isspace(last_c)) 
waddch( win, isspace(test_c) ? : c); 
last win 
last c win; 
test_c; 
PRIVATE void refresh_win( win 
WINDOW *win; 
{ 
I* Refresh the windows if you're not in go mode. (If you are, nothing will 
* have been written, so there's not point in doing the refresh 
*I 
if( Interactive ) 
wrefresh( win); 
1*-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *I 
PUBLIC 
int 
char void yy_output( where, fmt, args ) 
where; 
*fmt; 
va list args; I* Generate code *I 
I* Works like vprintf(), but sends output to the code window. In the window, 
* it ignores any newlines in the string but prints a newline after every 
*call. All code sent to yycode(), yydata(), and yybss() is funneled 
* here. "where" should be one of the following: 
* 
* 0 code 
* 1 data 
* 2 bss 
* 
* Note that if the three associated streams (yycodeout, yybssout, and 
252 Top-Down Parsing-Chapter 4 
Listing 4.10. continued ... 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 /*-* yydataout--all declared in the parser output file) are not directed to 
* stdout, output is sent to that stream TOO. Don't modify these to point 
* at stderr (or any other stream that accesses the console: /dev/tty, con, 
*etc.) or you'll mess up the screen. 
* *Note that the real yycode(), etc (ie. the ones supplied when YYDEBUG 
* is not defined) don't do anything special with newlines. In particular, 
* they are not inserted automatically at the end of the line. To make both 
* sets of routines compatible, your output strings should all have exactly 
* one newline, placed at the end of the string (don't imbed any in the 
* middle) . 
*I 
extern FILE *yycodeout, *yydataout, *yybssout; 
if( Log ) 
{ 
fprintf ( Log, where == 0 ? "CODE->" 
where == 1 ? "DATA->" 
prnt ( fputc, Log, fmt, args ); 
fputc( '\n', Log ) ; 
NEWLINE( Code_window ); 
prnt_putc( where==O ? 'C' 
prnt_putc( VERT, where==l ? 'D' 
prnt( prnt putc, Code_window, fmt, args ); 
refresh_win( Code_window ); 
if( where == 0 && yycodeout != stdout 
vfprintf( yycodeout, fmt, args ); 
if( where == 1 && yydataout != stdout 
vfprintf( yydataout, fmt, args ); 
if( where == 2 && yybssout != stdout 
vfprintf( yybssout, fmt, args ); "BSS-->" ) ; 
'B' I Code window ) ; 
Code window ) ; 
- - - - - - - - - - - - - - - - */ 
PUBLIC void yycomment( fmt, ... ) 
char *fmt; 
{ 
/* Works like printf() except that it automatically prints a newline 
* IN FRONT OF the string and ignores any \n's in the string itself. Writes 
* into the comment window, and outputs a message to the log file if 
* logging is enabled. 
*I 
va list args; 
va_start( args, fmt ); 
if( Log && !No_comment_pix 
prnt( fputc, Log, fmt, args ); 
.... 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 253 
Listing 4.10. continued ... 
503 
504 
505 
506 
507 
508 
509 
510 
511 
512 
513 
514 
515 
516 
517 518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 NEWLINE( Comment_window ); 
prnt( prnt_putc, Comment_window, fmt, args ); 
refresh_win( Comment window); 
1*-- - - - - - - - - - -
PUBLIC void yyerror( fmt, 
char 
{ *fmt; - - - - - - - - - - - - - - - - - - *I 
I* Debugging version of the error routine. Works just like the nondebugging 
*version, but writes to the comment window. Note that yycomment() copies 
* the error message to the Log file. Interactive mode is temporarily 
1*-* enabled to assure that error messages get printed. 
*I 
int old_interactive; 
va list args; 
va_start( args, fmt ) ; 
old interactive 
Interactive Interactive; 
1; 
yycomment( "ERROR, line %d near <%s>\n", yylineno, yytext ); 
if( Log ) 
prnt( fputc, Log, fmt, args ) ; 
Comment_window ); NEWLINE 
prnt 
refresh win prnt_putc, Comment_window, fmt, args ); 
Comment_window ); 
Interactive old_interactive; 
Singlestep 1; I* Force a breakpoint *I 
yy_pstack( 0, 1 ); 
- - - - - - - - - - - - - - - - *I 
PRIVATE void yy_input( fmt, ... ) 
char *fmt; 
{ 
I* This is not an input function; rather, it writes to the INPUT window. 
* It works like printf(). Note that nothing is logged here. The logging 
*is done in nextoken(). Ignores all In's in the input string. 
*I 
va list args; 
va_start( args, fmt ); 
prnt( prnt_putc, Prompt_window, fmt, args ); 
refresh_win( Prompt_window ); 
1*----------------------------------------------------------------------*l 
PRIVATE void display_fi1e( 
char 
int *name; 
buf_size; 
int print_lines; name, buf_size, print_1ines ) 
I* Initially holds the file name, but *I 
I* recycled as an input buffer. *I 
.... 
254 Top-Down Parsing-Chapter 4 
Listing 4.10. continued ... 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 
595 
596 
597 598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 
610 
611 
612 613 
614 
615 
616 
617 
618 
619 
620 
621 
622 /* Display an arbitrary file in the stack window, one page at a time. 
* The stack window is not refreshed by this routine. 
*I 
FILE *fd; 
int i; 
int lineno = 0; 
if( ! (fd = fopen( name, "r")) 
{ 
else NEWLINE 
wprintw 
wrefresh 
press key Prompt_window 
Prompt_window, 
( Prompt_window 
() ; "Can't open %s", ) ; 
name ) ; 
) ; 
/* Note that order of evaluation is important in */ 
/* the following while statement. You don't want */ 
/* to get the line if i goes past 0. */ 
for( i = Stacksize-1 ;; i = (*name==' ') ? 1 : Stacksize- 2 ) 
{ 
while( --i >= 0 && fgets(name, buf_size, fd) ) 
{ 
if( print_lines ) 
wprintw( Stack_window, "%3d:", ++lineno ); 
wprintw ( Stack_window, "%s", name); 
wrefresh( Stack window); 
if ( i > 0 ) 
break; 
if(!yyprompt("ESC quits. Space scrolls 1 line. Enter for screenful", 
name, 0) ) 
break; 
yyprompt("*** End of file. Press any key to continue 
fclose ( fd ) ; ***" , name, 0 ); 
/*----------------------------------------------------------------------*/ 
PRIVATE void write_screen( filename ) 
char 
{ *filename; 
/* Print the current screen contents to the indicated file. Note that the 
* right edge of the box isn't printed in order to let us have 79-character 
* lines. Otherwise, the saved screen shows up as double-spaced on most 
* printers. The screen image is appended to the end of the file. In MS-DOS, 
* Use "prn:" as the file name if you want to go to the printer. 
* * Syserrlist and errno are both defined in <stdlib.h> 
*I 
char buf[2]; 
char *mode = "a"; 
int row, col, y, x; 
FILE *file; 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.10. continued ••• 
623 
624 
625 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 
638 
639 
640 
641 
642 
643 
644 
645 
646 
647 
648 
649 
650 
651 
652 
653 
654 
655 
656 
657 
658 
659 
660 
661 
662 
663 if( access( filename, 0 ) == 0 ) 
if( !yyprompt("File exists, overwrite or append? (o/a): ", buf, 0) ) 
{ 
else NEWLINE ( Prompt_window ); 
yy_input( "Aborting command." ); 
presskey(); 
return; 
if( toupper(*buf) 
mode = "w"; '0' ) 
if( file= fopen( filename, mode) ) 
else 
{ yy_input(" ... %s %s ... ", 
*mode=='w' ? "overwriting" "appending to", filename); 
yy input( "Can't open %s: %s.", filename, sys_errlist[errno]); 
presskey(); 
return; 
getyx( Prompt_window, y, x ); 
for( row = 0; row < SCRNSIZE; row++ 
{ 
for( col = 0; col < PRINTWIDTH; col++ 
{ 
UX( fputc( mvinch(row,col) , file); 
MS( fputc( conv( mvinch(row,col) ), file); 
fputc ( '\n', file ) ; 
fclose ( file ) ; 
wmove( Prompt_window, y, x ); 255 
The routines in Listing 4.11 do the real work. yy _pstack () (on line 664) is called by 
the parser every time the stack is modified. The stack is printed to the log file, if neces­
sary, on line 700 to 773. Interactive is false on line 775 if the debugger is in nonin­
teractive mode (initiated with an n command). In this case, a speedometer readout that 
tells you that the program is actually doing something is updated (it can take a while to 
parse a big input file, even in noninteractive mode) and the routine returns. A Stack 
breakpoint is triggered on line 785 if necessary (the debugger is just thrown back into 
single-step mode if one is found). Update stack window, 
yy _pstack (). 
The delay () call on line 874 does one of two things. If you're not single stepping, 
it just delays by zero or more seconds (you can modify the number with the d command). 
delay () gets and executes a command if you're single stepping or you hit a key during 
the delay. delay () doesn't exit until one of the commands that starts up the parse again 
(space to singlestep, n to enter noninteractive mode, or g to go) is executed. The 
delay () subroutine itself starts at the top of the following Listing (Listing 4.12). Note Stack breakpoint. 
Main command loop, 
delay(). 
256 Top-Down Parsing-Chapter 4 
that I'm using the UNIX/ANSI time ftime () function here to get the time in milliseconds. 
It loads the time_ buf structure with the elapsed number of seconds since January 1, 
1970 (time_buf.time) and the number of milliseconds as well (in 
time _buf. milli tm). The Delay variable holds the desired delay (in milliseconds). 
Listing 4.11. yydebug.c- Stack-Window Maintenance and the Control Loop 
664 
665 
666 
667 
668 
669 
670 
671 
672 
673 
674 
675 
676 
677 
678 
679 
680 
681 
682 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 PUBLIC void yy_pstack( do refresh, print it ) 
int 
int 
{ do refresh; /* redraw entire window rather than update *I 
print it; /* if true, print the stack to the log file *I 
/* Print the state, debug, and value stacks. 
* 
* The library routine yypstk() (which returns an empty string by default) 
* is called to print value stack items. It should return a pointer to a 
* string that represents the value-stack contents. Just provide a similarly 
* named routine to print your real value stack. The LLAMA parser passes 
*garbage to yypstk(), so use the default routine in LLAMA. The OCCS parser 
*passes yypstk() a pointer to a value-stack item and it should return a 
*pointer to a string representing attributes of interest. The line should 
* not contain any newlines and it should be at most 58 characters long. 
* If do refresh is true, the entire stack window is redrawn, otherwise 
* only those parts of the window that have been changed are modified. 
*I 
int numele /* # of elements on the stack 
int *toss /* top of state stack 
char **tods /* top of debug stack 
char *tovs /* top of value stack 
int *state /* current state-stack pointer 
char **debug /* current debug-stack pointer 
char *value /* current value-stack pointer 
int width /* Width of column in horiz. stack 
static 
char 
int int times 
*p 
i 
*P sp; 
*P_dsp; called -1 
Depth -(state -Sstack); /* # of times 
state 
debug 
numele 
value (Vstack + (Depth- numele) * Vsize); 
if( Log && !No_stack_pix && print it ) 
{ this subroutine 
/* Print the stack contents out to the log file. */ 
if( !Horiz stack_pix 
{ 
fprintf (Log, " 
if( numele <= 0 +---+------------------+\n"); called *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
fprintf( Log," * I * I 
else ************ Stack is empty.\n"); 
toss 
tods state; 
debug; 
tovs value; 
for(i = numele; --i >= 0; ++toss, ++tods, tovs += Vsize 
fprintf ( Log, "%3d I %3d I %16 .16s I %1. 52s\n", 
toss -state, *toss, *tods, yypstk (tovs, *tods)); 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.11. continued ... 
else 
{ fprintf (Log, " +---+------------------+\n"); 
if( state < Sstack ) 
fprintf( Log,"*** Stack empty ***\n"); 
else 
I* Print horizontal stack pictures. Note that you have to go 257 
718 
719 
720 
721 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 
733 
734 
735 
736 
737 
738 
739 
740 
741 
742 
743 
744 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 
757 758 
759 
760 
761 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 * through the stack from bottom to top to get the top-of-stack 
* element on the right. 
*I 
for( 
{ i = 0; i <= 2; ++i 
if( !Parse_pix && i 
if( !Sym_pix && i 
if( !Attr _pix && i 
switch( i ) 
{ 
case 0: fprintf ( Log, 
case 1: fprintf ( Log, 
case 2: fprintf ( Log, 0 
1 
2 
II 
II 
II continue; 
continue; 
continue; 
PARSE ");break; 
SYMBOL"); break; 
ATTRIB" ); break; 
toss Sstack + (Depth- 1); 
tods Dstack + (Depth- 1); 
tovs Vstack + ((Depth- 1) * Vsize); 
for(; toss >= state; --toss, --tods, tovs -= Vsize 
{ 
I* Find width of the column. I'm assuming that the 
* numbers on the state stack are at most 3 digits 
* long, if not, change the 3, below. 
*I 
p 
width yypstk( tovs, *tods ); 
3; 
if( Sym_pix width max( width, str1en(*tods) ) ; 
if( Attr _pix width max( width, str1en(p) ) ; 
switch( i ) 
{ 
case 0: fprintf ( Log, "%-*d II width, *toss ) ; break; ' case 1: fprintf( Log, "%-*s II width, *tods ) ; break; ' case 2: fprintf( Log, "%-*s II width, p ) ; break; ' } 
fputc( '\n', Log); 
if( !Interactive ) 
{ 
.... 
258 Top-Down Parsing-Chapter 4 
Listing 4.11. continued ... 
777 
778 
779 
780 
781 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 
796 
797 
798 
799 
800 
801 
802 
803 
804 
805 
806 
807 
808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 827 
828 
829 
830 
831 
832 
833 
834 
835 
836 if( ++times_called % 25 == 0 ) 
{ 
wprintw ( Stack_window, "working: %d\r", times called); 
wrefresh( Stack window); 
return; 
if( *S_breakpoint && state < Sstack + Depth 
{ 
/* Break if the breakpoint is a digit and the top-of-stack item has that 
* value, or if the string matches the string currently at the top of 
* the symbol stack. 
*I 
if( isdigit(*S_breakpoint) 
{ 
if( atoi(S_breakpoint) 
Singlestep = 1; *state ) 
else if( !strcmp(S_breakpoint, *debug) ) 
Singlestep = 1; 
if( do_refresh ) 
yy_redraw_stack(); /* Redraw entire stack */ 
else if( numele > Onumele 
{ 
else /* The stack has grown. Redraw only those parts of the stack that have 
* changed. (I'm assuming only by one element.) The main difficulty 
* here is that only the top few elements of a large stack are 
* displayed. Consequently, the stack window may have to scroll up 
* or down a line if the stack size is hovering around the window size. 
* There's no portable way to scroll the window up under UNIX curses, so 
*we have to redraw the stack to scroll up in this situation. We'll 
* overwrite the top element with itself by the wprintw() call, but 
* that's no big deal, and it simplifies the code. 
*I 
if( numele > Stacksize 
{ /* scroll down, opening up top line */ 
else MS( wscroll( Stack_window, -1 ) ; 
UX( yy_redraw_stack(); 
wmove( Stack_window, 0, 0 ); 
wmove( Stack_window, Stacksize -numele, 0 ) ; 
wprintw( Stack_window, "%3d%c %16.16s %c %1.52s", 
*state, VERT, *debug, VERT, yypstk(value, *debug) ); 
wrefresh( Stack window); 
/* The stack has shrunk, perhaps by several elements. Remove them one at 
* a time. (It's too confusing if several elements disappear from the 
* stack at once. It's best to watch them go one at a time.) If the 
* number of elements on the stack (i) is greater than the window size, .... 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.11. continued ... 
* you can pop an element by scrolling up and then writing in a new 
* bottom line, otherwise, just go to the correct line and erase it. 
* Do a refresh after each pop. 
*I 
for( i = Onumele; i > numele; --i 
{ 
} 
delay(); if( i > Stacksize 
{ 
else I* Do a pop by scrolling up, the easiest way to scroll is to 
* move to the right edge of the bottom line and then issue 
* a newline. After the scroll, overwrite the now-blank bottom 
* line with the appropriate stack information. The involved 
* expression that is the first argument to yypstk is doing: 
* (Vstack + Depth) [ -i + Stacksize 1 
* It must do the pointer arithmetic explicitly, however, by 
*multiplying by the size of one value-stack item (Vsize). 
*I 
wrnove 
NEWLINE Stack_window, Stacksize-1, 77 
Stack window ) ; 
) ; 
wprintw Stack_window, "%3d%c %16.16s %c %1.52s", 
(Sstack +Depth) [ -i + Stacksize ], VERT, 
(Dstack + Depth) [ -i + Stacksize ] , VERT, 
yypstk( (Vstack + (Depth*Vsize)) + 
( (-i + Stacksize) * Vsize), 
(Dstack + Depth) [ -i + Stacksize ] ) 
) ; 
wrnove Stack_window, Stacksize- i, 0 ); 
wclrtoeol( Stack window ) ; 
wrefresh( Stack window ) ; 
wrefresh( Stack window); 
Onumele = numele; 
1*----------------------------------------------------------------------*l 
PUBLIC void yy_redraw_stack() 
{ 259 
837 
838 
839 
840 
841 
842 
843 
844 
845 
846 
847 
848 
849 
850 
851 
852 
853 
854 
855 
856 
857 
858 
859 
860 
861 
862 
863 
864 
865 
866 
867 
868 
869 
870 
871 
872 
873 
874 
875 
876 
877 
878 
879 
880 
881 
882 
883 
884 
885 
886 
887 
888 
889 
890 
891 
892 
893 
894 I* Redraw the entire stack screen by writing out the top Stacksize elements 
* of the stack in the stack window. Note that scrolling is turned off so 
* that the screen won't scroll when you print the last line. Unlike 
* yy_pstack(), this routine won't pause for a command. 
*I 
int i; 
int numele; I* Number of elements on the stack *I 
int *state *P _sp; I* Pointer to top of state stack *I 
char **debug *P_dsp; I* Pointer to top of debug stack *I 
char *value; I* Pointer to top of value stack *I 
260 Top-Down Parsing-Chapter 4 
Listing 4.11. continued ... 
895 
896 
897 
898 
899 
900 
901 
902 
903 
904 
905 
906 
907 
908 
909 we rase 
scrollok Stack_ window ) ; 
Stack_window, FALSE); 
Depth- (state- Sstack); numele 
value Vstack + ((Depth- numele) * Vsize); 
wmove( Stack_window, numele <= Stacksize? Stacksize- numele : 0, 0 ); 
for( i=min(Stacksize, numele); --i >= 0; ++state, ++debug, value+= Vsize 
wprintw( Stack_window, "%3d%c %16.16s %c %1.52s\n", 
*state, VERT, 
*debug, VERT, yypstk(value, *debug) ); 
scrollok( Stack_window, TRUE); 
Listing 4.12. yydebug.c- Delay and Main Control Loop 
910 
911 
912 
913 
914 
915 
916 
917 
918 
919 
920 
921 
922 
923 
924 
925 
926 
927 
928 
929 
930 
931 
932 
933 
934 
935 
936 
937 938 
939 
940 
941 
942 
943 
944 
945 
946 PRIVATE void delay() 
{ 
/* Print a prompt and wait for either a carriage return or another command. 
*Note that the time returned by time{) is the elapsed time, in seconds, 
*from 00:00:00, January 1, 1970 GMT. Since there are roughly 31,557,600 
* seconds in a year (365.25 * 24 * 60 * 60) and the largest (signed) 
* 32-bit long int can hold 2,147,483,647, the time won't roll over until 
* January 18, 2038 at 2:56:02 A.M. Don't use this program on January 18, 
* 2038 at 2:56:02 A.M. 
*I 
long 
char start, current; 
buf[80]; 
int print_lines; 
struct timeb time_buf; 
if( !Interactive 
return; 
if( !Singlestep && kbhit() 
{ /* defined in sys/timeb.h */ 
/* n command (noninteractive) issued */ 
/* If we're not single stepping (a 'g' command has been issued) and 
* there's a key pressed, stop single stepping and get the character. 
*I 
input_char(); 
Singlestep = 1; 
if ( ! Single step 
{ 
/* If we're still doing a go command (no key was found in the previous 
*if statement), then delay for a while. Must use two if statements 
* here because we don't want to delay if we've just stopped go-ing. 
* If a key is hit while we're delaying, stop looping immediately and 
* revert back to single-step mode. 
*I 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.12. continued ... 
947 
948 
949 
950 
951 
952 
953 
954 
955 
956 
957 958 
959 
960 
961 
962 
963 
964 
965 
966 
967 
968 
969 
970 
971 
972 
973 
974 
975 
976 
977 
978 
979 
980 
981 
982 
983 
984 
985 
986 
987 
988 
989 
990 
991 
992 
993 
994 
995 
996 
997 
998 
999 ftime( &time_buf ) ; 
start 
while( 1 ) 
{ (time_buf.time * 1000) + time buf.millitm; 
ftime( &time_buf ) ; 
current= (time_buf.time * 1000) +time buf.millitm; 
if( current -start >= Delay ) 
break; 
if( kbhit() 
{ 
input_char(); 
Singlestep = 1; 
break; /* If a key is hit, stop delaying */ 
/* and revert back to single-step */ 
/* mode. */ 
if ( ! Single step 
return; 
while( 1 ) 
{ /* If we're still not single stepping, then 
/* we're done (don't get a command), 
/* otherwise, fall out of this block and 
/* enter the command loop, below. 
yyprompt( "Enter command (space to continue, ? for list): " buf, 0 ); 
switch ( *buf 
{ 
case '\0' 
case 
case '\n' 
goto outside; 
case '?' 
cmd_list(); 
NEWLINE (Prompt window); 
presskey(); 
yy_redraw_stack(); 
break; 
case 'a': 
Abort = 1; 
Singlestep = 0; 
goto outside; 
case'b': 
breakpoint(); 
yy_redraw_stack(); 
break; 
case 'd': /* singlestep *I 
/* help *I 
/* abort *I 
/* breakpoints *I 
/* set delay time */ 261 
*I 
*I 
*I 
*I 
1000 
1001 
1002 
1003 
1004 if(yyprompt("Delay time (in seconds, CR=O, ESC cancels): ", buf,l)) 
Delay = (long) ( atof (buf) * 1000.0 ) ; 
break; 
.... 
262 Top-Down Parsing-Chapter 4 
Listing 4.12. continued ... 
1005 
1006 
1007 
1008 
1009 1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 1028 
1029 
1030 
1031 
1032 
1033 
1034 
1035 
1036 
1037 
1038 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 1048 
1049 
1050 
1051 
1052 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 
1062 
1063 case 'f': /* read file */ 
if( !yyprompt( "Print line numbers? (y/n, CR=y, ESC cancels): ", 
buf, 0)) 
break; 
print_lines = *buf != 'n'; 
if ( ! yyprompt ( "File name or ESC to cancel: ", buf, 1) ) 
break; 
werase( Stack_window ); 
display_file( buf, sizeof(buf), print lines ); 
yy_redraw_stack(); 
break; 
case 'g': 
Singlestep = 0; 
goto outside; 
case 'i': /* go! *I 
if( yyprompt( "Input file name or ESC to cancel: ", buf, 1 ) ) 
new_input_file( buf ); 
break; 
case '1': 
to_log( buf ) ; 
break; 
case 'N': 
Log NULL; 
No stack_pix 1; 
Interactive 0; 
Singlestep 0; 
Delay OL; 
werase( Stack_window ); 
goto outside; 
case 'n': 
if( !Log && !to_log(buf) 
break; 
Interactive 0; 
Singlestep 0; 
Delay OL; 
werase( Stack_window); 
goto outside; 
case 'q': 
raise( SIGINT ); 
exit(O); 
case 'r': 
yy_redraw_stack(); 
break; /* enable logging */ 
/* noninteractive w/o logging */ 
/* noninteractive mode w/ log */ 
/* exit to operating system */ 
/* as if Ctrl-C was entered */ 
/* redraw the stack window */ 
case 'w': /* write screen to file */ 
if( yyprompt( "Output file name or ESC to cancel: ", buf, 1) ) 
write_screen( buf ) ; 
break; 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.12. continued .•• 
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 1083 
1084 
1085 
1086 
1087 1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 1109 1110 
1111 case 'x': /* show lexemes */ 
[%0.*s]\n", yyleng, yytext ); 
[%0.*s]\n", ii_plength(), ii_ptext() ); yycomment( "current 
yycomment( "previous 
break; 
case OxOl: yyhook_a(); break; 
case Ox02: yyhook_b(); break; /* Ctrl-A debugger hook (see text) */ 
/* Ctrl-B */ 
default: 
yyprompt( "Illegal command, press any key to continue", buf, 0 ); 
break; 
outside: 
werase Prompt_window ); 
wrefresh( Prompt_window ); 
/*----------------------------------------------------------------------*/ 
PRIVATE void cmd_list() 
{ 
/* Print a list of commands in the stack window & prompt for an action. */ 
we rase 
wmove 
wprintw 
wprintw 
wpri11tw 
wprintw 
wprintw 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wmove 
wprintw 
wrefresh (Stack_window ) ; 
(Stack_window, 0, 0 ) ; 
(Stack_window, "a (a) bort parse by reading EOI \n"); 
(Stack_window, "b modify or examine (b)reakpoint \n"); 
(Stack_window, "d set (d)elay time for go mode \n"); 
(Stack_window, "f read (f)ile \n"); 
(Stack_window, "g (g) o (any key stops parse) \n"); 
(Stack_window, "i change (i)nput file \n"); 
(Stack_window, 0, 39 ) ; 
(Stack_window, "1 (l)og output to file"); 
(Stack_window, 1, 39 ) ; 
(Stack_window, "n (n) oninteractive mode"); 
(Stack_window, 2, 39 ); 
(Stack_window, "q (q)uit (exit to dos)"); 
(Stack_window, 3, 39 ); 
(Stack_window, "r (r)efresh stack window"); 
(Stack_window, 4, 39 ); 
(Stack_window, "w (w)rite screen to file or device\n"); 
(Stack_window, 5, 39 ); 
(Stack_window, "x Show current and prev. le(X)eme\n"); 
(Stack_window, 7, (78-29) /2 ) ; 
(Stack_window, "Space or Enter to single step" ) ; 
(Stack_window ) ; 263 
One point of note is the Ctri-A and Ctri-B commands, processed on lines 1069 and 1070 
of Listing 4.12. These commands call the yyhook _a () and yyhook _b () subroutines 
(in Listings 4.13 and 4.14), which do nothing at all. Their purpose is twofold. First, if 
you are running the parser under your compiler's debugger, these commands give you a 
hook into that debugger. You can set a breakpoint at yyhook_a (),and then issue a 
Ctri-A to transfer from the running parser to the debugger itself. These hooks also let 
you add commands to the parser without having to recompile it. Since yyhook _a () 
and yyhook _b () are alone in separate files, customized versions that you supply are Debugger hooks for Ctri­
A, Ctrl-8: yyhook _a () , 
yyhook_b(). 
264 Top-Down Parsing-Chapter 4 
linked rather than the default ones in the library. You can effectively add commands to 
the parser's debugging environment by providing your own version of one or both of 
these routines. For example, it's convenient to print the symbol table at various states of 
the compilation process so you can watch symbols being added. You can add this capa­
bility to the parser by writing a routine that prints the symbol table and calling that rou­
tine yyhook_a( ). Thereafter, you can print the symbol table by issuing a Ctri-A at the 
parser's command prompt. 
Listing 4.13. yyhook a.c-Debugger Hook I 
void yyhook_a() {) I* entered with a AA command *I 
Listing 4.14. yyhook b.c-Debugger Hook 2 
void yyhook_b() {) I* entered with a AB command *I 
Production breakpoints. 
Token input: 
yy _ nextoken () calls 
yylex (). Listing 4.15 contains support for the input and production breakpoints. (Stack break­
points were handled in yy _pstack ()-the code of interest starts on line 785 of Listing 
4.10, page 258). The yy _ nextoken () function (starting on line 1112 of Listing 4.15) 
gets an input token from yylex (), though if Abort is true, then an a command has 
been issued, and the end-of-input marker (0) is used rather than the next token. The rou­
tine then echoes the new token to the input window, and triggers a breakpoint (on line 
1142) if necessary, by setting Singlestep true. Singlestep causes delay () to wait 
for a command the next time it's called (after the next stack-window update). 
yy_break () (on line 1167) does the same thing, but for production breakpoints. It is 
called from the LLama-generated parser just before every production is applied (when a 
nonterminal on the stack is replaced by it's right-hand side). In occs, it's called just 
before a reduction takes place. breakpoint() (on line 1187 of Listing 4.15) takes 
care of setting the breakpoints, and so forth. It processes the b command. 
The remainder of the file (in Listing 4.16) comprises little support functions which 
are adequately commented and don't require additional discussion here. 
Listing 4.15. yydebug.c- Breakpoint Support 
1112 PUBLIC int yy _ nextoken () 
1113 { 
1114 I* Input a token from yylex() and echo to both the token and comment 
1115 *windows. Yy_comment() writes to the log file too. Break if the input 
1116 * breakpoint is set and the required token has just been read. The token 
1117 * name is centered in the token window if it's short enough. It's 
1118 * truncated at TOKEN WIDTH characters otherwise. 
1119 *I 
1120 
1121 I* current token *I static int tok = -1; 
1122 
1123 
1124 
1125 int 
char 
char 
char width; 
*str; 
*lexeme; 
buf[ TOKEN WIDTH l ; 
1126 I* Generated by occs and llama *I extern char *Yy_ stok [ J; 
1127 
1128 if ( tok >= 0 && (Interactive I I Log) ) 
1129 yycomment ( "Advance past %s\n", Yy_stok [tok] ) ; 
1130 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 
Listing 4.15. continued ... 
1131 
1132 
1133 
1134 
1135 
1136 
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 1148 
1149 
1150 
1151 
1152 
1153 
1154 
1155 
1156 
1157 
1158 
1159 
1160 
1161 
1162 
1163 
1164 
1165 
1166 
1167 
1168 
1169 
1170 
1171 
1172 
1173 
1174 
1175 
1176 
1177 
1178 
1179 
1180 
1181 
1182 
1183 
1184 
1185 
1186 
1187 
1188 lexeme = ((tok =Abort? 0 yylex ()) 
if( Interactive I I Log 
yycomment( "Read %s <%s>\n", str 
if( Interactive ) 
{ 
NEWLINE( Token_window ); 0) ? yytext; 
Yy_stok[tok], lexeme ); 
concat( TOKEN_WIDTH, buf, str, "", lexeme, NULL); 
wprintw( Token_window, "%0.*s", TOKEN_WIDTH- 2, buf ); 
if( L_breakpoint != -1 && L_breakpoint <= yylineno 
{ 
L_breakpoint = -1; 
Singlestep 1; 
yy_pstack( 0, 1 ); 
else if( ( *I_breakpoint && 
( ( isdigit(*I_breakpoint) && tok == atoi(I breakpoint) 
I 1 !strcmp( lexeme, I_breakpoint) 
I 1 !strcmp( Yy_stok[tok], I_breakpoint) 
Singlestep = 1; 
yy_pstack( 0, 1 ) ; 
delay(); 
return tok; 
1*----------------------------------------------------------------------*/ 
PUBLIC void yy_break( production_number 
int production_number; 
/* Handles production-number breakpoints. If a break is required, start 
* single stepping and print the stack. Stack breakpoints are handled in 
* yy_pstack and input breakpoints are done in yy_nextoken(). 
* 
* 
* If production_number == -1, a break is forced regardless of the value 
of P_breakpoint; 
*I 
if( production_number 
{ 
Single step = 1; 
yy_pstack( 0, 1 ); P_breakpoint I I production_number -1 ) 
l*----------------------------------------------------------------------*1 
PRIVATE int breakpoint() 
{ 265 
.... 
266 Top-Down Parsing-Chapter 4 
Listing 4.15. continued ... 
1189 
1190 
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 
1201 
1202 
1203 
1204 
1205 
1206 
1207 
1208 
1209 
1210 
1211 
1212 
1213 
1214 
1215 
1216 
1217 
1218 
1219 
1220 
1221 
1222 
1223 
1224 
1225 
1226 
1227 
1228 
1229 
1230 
1231 
1232 
1233 
1234 
1235 
1236 
1237 
1238 
1239 
1240 
1241 
1242 
1243 
1244 
1245 
1246 /* Set up a breakpoint by prompting the user for any required information. 
* Return true if we have to redraw the stack window because a help screen 
* was printed there. 
*I 
int 
char 
char type; 
**p; 
buf[80]; 
int rval 0; 
static char *text[] = 
{ 
} ; "Select a breakpoint type (i,l,p,or s) or command (cor 1) :", 
"Type: Description: Enter breakpoint as follows:", 
i input ..................... number for token value", 
or string for lexeme or token name", 
1 input line read ........... line number", 
p reduce by production ...... number for production number", 
s top-of-stack symbol ....... number for state-stack item", 
or string for symbol-stack item", 
c clear all breakpoints", 
d display (list) all breakpoints", 
NULL 
if ( ! yyprompt ("Enter type or command, ? for help, ESC aborts: ", buf, 0) ) 
return 1; 
if ( *bU f == I ? I 
{ 
rval 1; 
we rase 
wmove (Stack_window); 
(Stack_window, 0, 0); 
for( p text; *p; p ) 
wprintw(Stack_window, "%s\n", *p++ ); 
wrefresh (Stack_window); 
if ( ! yyprompt ("Enter breakpoint type or command, ESC aborts: ", buf, 0)) 
return rval; 
if ( (type = *buf) == 'p' ) 
{ 
if( yyprompt("Production number or ESC to cancel: ", buf, 1 )) 
{ 
if ( ! isdigit ( *buf ) ) 
yyprompt("Must be a number, press any key to continue.", buf,O); 
else 
P_breakpoint 
else if( type== '1' ) 
{ atoi( buf ); 
if( yyprompt("Input line number or ESC to cancel: ", buf, 1 )) 
L_breakpoint = atoi( buf ); 
else if( type== 'i' I I type== 's' 
{ 
.... 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 267 
Listing 4.15. continued ... 
1247 
1248 
1249 
1250 
1251 
1252 
1253 
1254 
1255 
1256 
1257 
1258 
1259 
1260 
1261 
1262 
1263 
1264 
1265 
1266 
1267 
1268 
1269 
1270 
1271 
1272 
1273 
1274 
1275 
1276 
1277 
1278 
1279 
1280 
1281 
1282 
1283 
1284 
1285 
1286 
1287 
1288 
1289 
1290 else if( yyprompt("Symbol value or ESC to cancel: ", buf, l )) 
strncpy( type== 'i' ? !_breakpoint S_breakpoint, buf, BRKLEN ); 
switch( type 
{ 
case 'c': 
P_breakpoint -1; 
L_breakpoint -1; 
*S_breakpoint 0; 
*!_breakpoint 0; 
break; 
case 'd': 
rval 
we rase 
wmove 1; 
(Stack_ window) ; 
(Stack_window, 0, 0); 
wprintw(Stack_window, 
none\n" P_breakpoint == -1 ? "Production 
"Production %d\n", P_breakpoint); 
default: wprintw (Stack_ window, "Stack = %s\n", 
*S_breakpoint ? S_breakpoint "none" ) ; 
wprintw(Stack_window, "Input = %s\n", 
*!_breakpoint ? I_breakpoint "none" ) ; 
wprintw(Stack_window, 
!_breakpoint == 0 ? "Input line none\n" 
"Input line %d\n", !_breakpoint); 
wrefresh(Stack_window); 
NEWLINE (Prompt_window); 
presskey(); 
break; 
yyprompt("Illegal command or type, Press any key.", buf, 0); 
break; 
return rval; 
Listing 4.16. yydebug.c- Input Routines 
1291 
1292 
1293 
1294 
1295 
1296 
1297 
1298 
1299 
1300 PRIVATE int new_input file( buf) 
char 
{ *buf; 
/* Open up a new input file. Input must come from a file because the 
* keyboard is used to get commands. In theory, you can use both standard 
* input and the keyboard (by opening the console as another stream), but I 
* had difficulties doing this in a portable way, and eventually gave up. 
* It's not that big a deal to require that test input be in a file. 
*I 
.... 
268 Top-Down Parsing -Chapter 4 
Listing 4.16. continued ... 
1301 
1302 
1303 
1304 
1305 
1306 
1307 
1308 
1309 
1310 
1311 
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 NEWLINE( Prompt_window ); 
wrefresh( Prompt_window ); 
if( ii_newfile( buf ) != -1 
Inp_fm_file = 1; 
else 
{ 
wprintw(Prompt_window, "Can't open %s.", buf ); 
presskey(); 
return Inp_fm_file; 
/*----------------------------------------------------------------------*/ 
PRIVATE FILE *to_log ( buf ) 
char 
{ *buf; 
/*Set up everything to log output to a file (open the log file, etc.). */ 
if( !yyprompt("Log-file name (CR for \"log\", ESC cancels):", buf,l)) 
return NULL; 
if ( ! *buf ) 
strcpy( buf, "log" ); 
if( ! (Log= fopen( buf, "w")) 
{ 
NEWLINE(Prompt_window ); 
wprintw(Prompt_window, "Can't open %s", buf ); 
presskey(); 
return NULL; 
if( !yyprompt("Log comment-window output? (y/n, CR=y): ", buf,O) ) 
return NULL; 
else 
No_comment_pix = (*buf == 'n'); 
if( !yyprompt( "Print stack pictures in log file? (y/n, CR=y): ",buf,O)) 
return NULL; 
if( ! (No_stack_pix = (*buf == 'n')) ) 
{ 
if( !yyprompt( "Print stacks horizontally? (y/n, CR=y): ",buf,O) ) 
return NULL; 
if( Horiz_stack_pix = (*buf != 'n') ) 
{ 
if( !yyprompt("Print SYMBOL stack (y/n, CR=y): ",buf,O)) 
return NULL; 
Sym_pix = (*buf != 'n'); 
if( !yyprompt("PrintPARSE stack (y/n, CR=y): ",buf,O)) 
return NULL; 
Parse_pix = (*buf != 'n'); 
if( !yyprompt("PrintVALUE stack (y/n, CR=y): ",buf,O)) 
return NULL; 
Attr_pix = (*buf != 'n'); .... 
Section 4.9.2-0ccs and LLama Debugging Support-yydebug.c 269 
Listing 4.16. continued ... 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 return Log; 
/*----------------------------------------------------------------------*/ 
PRIVATE int input char( void) 
{ 
/* Get a character from the input window and echo it explicitly. If we've 
* compiled under Unix, reset the character-available flag. 
*I 
int c; 
if( (c = wgetch(Prompt_window) & Ox7f) !=ESC ) 
waddch( Prompt_window, c); 
UX( Char avail = 0; ) 
return c; 
/*----------------------------------------------------------------------*/ 
PUBLIC int yyprompt( prompt, buf, getstring 
char *prompt, *buf; 
int getstring; /* get entire string (as compared to a single character */ 
{ 
I* Print a prompt and then wait for a reply, load the typed characters into 
* buf. AH (destructive backspace) is supported. An ESC causes yyprompt() 
* to return 0 immediately, otherwise 1 is returned. The ESC is not put 
* into the buffer. If "getstring" is true, an entire string is fetched and 
* prompt returns when the newline is typed. If "getstring" is false, then 
*one character is fetched and yyprompt() returns immediately after getting 
* that character. Leading and trailing white space is stripped from the 
* line if getstring is true. (You can get a single space character if it's 
* false, however.) 
*I 
register int c; 
int y, x; 
char *startbuf buf; 
NEWLINE Prompt_window ); 
wprintw Prompt_window, "%s", prompt); 
wrefresh( Prompt_window ); 
if ( ! get string 
c = *buf++ 
else input_char (); 
while( (c =input char()) != '\n' && c !=ESC ) 
{ 
if( isspace(c) && buf==startbuf ) 
continue; 
if( c != '\b' 
*buf++ = c; /* skip leading white space */ 
270 Top-Down Parsing-Chapter 4 
Listing 4.16. continued •.. 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 else /* handle destructive backspace */ 
getyx( Prompt_window, y, x ); 
if( buf <= startbuf ) 
wmove ( Prompt_window, y, x+l ); 
else 
waddch( Prompt_window, ); 
wmove ( Prompt_window, y, x ) ; 
--buf; 
wrefresh( Prompt_window ); 
while( isspace( buf[-1] && buf > startbuf ) 
--buf; /* Strip trailing white space */ 
*buf 0; 
return (c !=ESC); 
/*----------------------------------------------------------------------*/ 
PRIVATE void presskey() 
{ 
/* Ask for a key to be pressed and wait for it. Note that this command 
* does a refresh, but it intentionally does not clear the window before 
*printing the prompt. 
*I 
wprintw ( Prompt_window, "Press any key: "); 
wrefresh( Prompt_window ); 
input_char(); 
4.10 Llama-Implementing an LL(1) Parser-Generator 
The remainder of this chapter discusses how LLama works. Much of the following 
code is used by both LLama and occs (all the files whose names start with ll are used 
only by LLama, everything else is used jointly). As usual, I expect you to actually read 
the code (I've not repeated in the text those things that are adequately described in com­
ments in the code itself). I also expect you to be familiar with the set and hash-table 
functions described in Appendix A. 
4.10.1 Llama's Parser 
Llamas own, recursive­
descent parser. This section describes LLama's own parser. It provides a good example of a work­
ing recursive-descent compiler for a small programming language (LLama is itself a 
compiler, after all). It translates a very high-level language (a grammatical description 
of a programming language) to a high-level language (C). 
Section 4.10.1-LLama's Parser 271 
I built LLama in a two-step process, initially developing yet another recursive­
descent parser (the last one we'll look at in this book) that supports a bare-bones input 
language. I then used this recursive-descent version of LLama to rebuild its own parser, 
substituting the LLama output file for the recursive-descent parser when I linked the 
new version. This process is typical of how a language is brought up on a new machine. 
You first construct a simple compiler for a subset of the target language using the tools at 
hand-typically an assembler. The output of this compiler is typically the same assem­
bly language that the compiler itself is written in. Using your subset language, you then 
write a compiler for a more complete version of the language. Bootstrapping a compiler 
using language subsets. 
For example, you could start writing a C compiler with a very small subset of C, 
written in assembly language-an adequate subset would support simple expressions (no 
fancy operators like conditionals), global variables of type int and char (but no local 
variables), one-dimensional arrays of int and char, simple control-flow statements 
(while, if, and else are adequate), and some sort of block structure. Note that, at this 
level, a compiler is little more than a macro translator. (See [Angermeyer]. pp. 51-92, 
where all of the foregoing are implemented as macros using the Microsoft macro assem­
bler, MASM.) 
In the next step, you write a larger subset of C using the language defined in the pre­
vious step, and compile it using the subset-of-C compiler. Typically, this second level 
would add better typing (introducing structures, for example), support local variables 
and subroutine arguments, and so forth. Continuing in this manner, you can bootstrap 
yourself up to a full language implementation. 
LLama, like most compilers, is easily divided into several distinct phases. The lexi­
cal analyzer is created with LEX. (The specification is in Listing 4.17 and the required 
token definitions are in Listing 4.18.) Note that white space (a comment is treated like 
white space) is ignored if the global variable Ignore (declared on line 27) is true, other­
wise a WHITESPACE token is returned. The variable is modified using the access rou­
tines on lines 215 and 216. Also note how actions are processed on lines 73 to 153. The 
entire action is treated as a single token. LEX recognizes an initial open brace, and the 
associated code absorbs everything up to and including the matching close brace. That 
is, the code doesn't terminate until a close brace is found at nesting level 1, as defined by 
nest lev. Other close braces are absorbed into the lexeme. 
Listing 4.17. parser.lex- IJX Input File for occs/LLama Lexical Analyzer 
%{ 
#include <stdio.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
#include <tools/set.h> 
#include "llout.h" Llamas lexical analyzer, 
tokens, LeX input 
specification. 
I 
2 
3 
4 
5 
6 
7 
8 
9 #define CREATING_LLAMA_PARSER 
#include "parser.h" /* Suppress various definitions in parser.h */ 
/* that conflict with LeX-generated defs. */ 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 /* ----------------------------------------------------------------------
* Lexical analyzer for both llama and yacc. Note that llama doesn't support 
* %left, %right, %noassoc, or %prec. They are recognized here so that we can 
*print an error message when they're encountered. By the same token, yacc 
* ignores the %synch directive. Though all legal llama input files can be 
* processed by yacc, the reverse is not true. 
* Whitespace, comments, and otherwise illegal characters must be handled 
*specially. When we're processing code blocks, we need to get at 
272 Top-Down Parsing-Chapter 4 
Listing 4.17. continued ... 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 * the characters so that they can be passed to the output, otherwise, the 
*characters should be ignored. Thews() and nows() subroutines (at the 
* bottom of the file) switch between these behaviors by changing the value 
* if Ignore. If Ignore is true, white space is ignored. 
*I 
PRIVATE int 
PRIVATE int Ignore = 0; 
Start line; /* starting line number */ 
I* ----------------------------------------------------------------------
* Prototypes for functions at the bottom of this file: 
*I 
void striper p ( ( 
void nows p ( ( 
void WS p ( ( 
%) 
c name [A-Za-z 
%% 
"/*" char *src ) ) ; /* Remove carriage returns (but not */ 
/* linefeeds) from src. */ 
void ) ) ; /* Ignore white space, etc */ 
void ) ) ; /* Don't ignore white space, etc */ 
] [A-Za-z 0-9]* 
end:; /* Absorb a comment (treat it as WHITESPACE) */ 
int i; 
int start = yylineno; 
while( i input() 
{ 
if ( i < 0 ) 
{ 
ii unterm () ; 
ii_flush(l); 
ii_term(); 
lerror(NONFATAL,"Comment starting on line %d" \ 
"too long, truncating\n", start); 
else if( i == '*' && ii_lookahead(l) == '/' ) 
{ 
input(); 
striper( yytext ); 
if ( Ignore 
else goto end; 
return WHITESPACE; 
lerror(FATAL, "End of file encountered in comment\n"); 
/* Suck up an entire action. Handle nested braces here. 
* This code won't work if the action is longer than the 
* buffer length used by the input functions. If this is a 
* problem, you have to allocate your own buffer and copy 
* the lexeme there as it's processed (in a manner similar to 
* the %{ processing, below). If space is really a problem, 
* the code blocks can be copied to a temporary file and the 
*offset to the start of the text (as returned by ftell())-+ 
Section 4.1 0.1 -LLama's Parser 
Listing 4.17. continued ... 
81 
82 
83 
84 \ { 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 133 
134 
135 
136 
137 * can be stored rather than the string itself. 
*I 
int i; 
int nestlev; /* brace-nesting level 
int lbl; /* previous character 
int lb2; /* character before that *I 
*I 
*I 
int in string; /* processing string constant -int in char const; /* processing char. constant 
int in comment; /* processing a comment 
lbl = lb2 
in_string 
in char canst 
in comment 
Start line 0; 
0; 
0; 
0; 
yylineno; 
for( nestlev=l; i=input(); lb2=lbl, lbl=i 
{ 
if ( lb2==' \n' && lbl==' %' && i==' %' ) 
lerror( FATAL, 273 
*I 
*I *I 
"%%%% in code block starting on line %d\n", 
Start line); 
if( i < 0 ) 
{ 
ii_unterm(); 
ii flush(l); 
ii term (); 
lerror( FATAL, /* input-buffer overflow */ 
"Code block starting on line %d too long.\n", 
Start line); 
/* Take care of \ {, "{", '{', \}, "} ", '}' *I 
if ( i == , \\, 
{ 
if( ! (i =input()) 
break; /* discard backslash */ 
else 
continue; /* and following char */ 
if( i == '"' && ! (in char const II in comment) 
in_string !in string; 
else if( i == '\'' && ! (in_string II in_comment) 
in char const = !in char const; 
else if( lbl == '/' && i == '*' && !in string 
in_comment = 1; 
else if( lbl == '*' && i 
in comment = 0; ' I' & & in comment 
.... 
274 
Listing 4.17. continued ... 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 -"%%" 
156 
157 
158 "%{"[\s\t]* 
159 
160 
161 
162 
163 
164 
165 
166 
167 168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 188 
189 
190 
191 
192 
193 
194 
195 
196 
197 <{c name}> -"%union" 
"%token" 
"%term" 
"%type" 
"%synch" 
"%left" Top-Down Parsing-Chapter 4 
if( ! (in_string I I in char canst I I in_comment) 
{ 
if ( i == I {I ) 
++nest lev; 
if( i == 1 )1 && --nestlev <= 0 ) 
{ 
striper( yytext ); 
return ACTION; 
lerror(FATAL 1 "EOF in code block starting on line %d\n" 1 
Start line ) ; 
return SEPARATOR; I* Must be anchored because *I 
I* it can appear in a printf *I 
I* statement. *I 
I* Copy a code block to the output file. *I 
int c1 looking_for_brace = 0; 
Iunde£ output I* replace macro with function *I 
I* in main.c *I 
if ( ! No lines 
output( "\n#line %d \"%s\"\n" 1 
yylineno 1 Input_file_name ); 
while ( c = input() I* while not at end of file *I 
{ 
if( c ---1 ) I* buffer is full, flush it *I 
ii flushbuf () ; -
else if( c != 1\r1 
{ 
if( looking_for_brace ) I* last char was a % *I 
{ 1*{*1 
if( c == 1 )1 ) break; 
else else output( "%%%c" 1 c); 
if( c 
else 1%1 ) looking_for_brace = 1; 
output( "%c" 1 c ) ; 
return CODE BLOCK; -
return FIELD; I* for occs only *I 
return PERCENT UNION; I* for occs only *I -
return TERM_SPEC; 
return TYPE; I* for occs only *I 
return SYNCH; I* for llama only *I 
return LEFT; I* for occs only *I ... 
Section 4.10.1-LLama's Parser 
Listing 4.17. continued ... 
"%right" return RIGHT; /* for aces only 
"%nonassoc" return NONASSOC; /* for aces only 
"%prec" return PREC; /* for aces only 
"%start" return START; /* for error messages 
"·" return COLON 
"I" return OR 
";II return SEMI 
II [II return START OPT 
"]II I 
II]* If return END _OPT; 
["\xOO-\s%\{} [\]()*:I;,<>]+ 
\xOd return NAME; 
; /* discard carriage return (\r) */ 
if( !Ignore ) return WHITESPACE; [\x00-\x0c\x0e-\s] 
%% only 
/*----------------------------------------------------------------------*/ 
PUBLIC void nows () Ignore 1; /* Ignore white space, etc. 
PUBLIC void WS () Ignore 0; /* Don't ignore white space, etc. 
PUBLIC int start action () /* Return starting line number of most *I 
{ /* recently read ACTION block *I 
return Start line; 
} 
/*----------------------------------------------------------------------*/ 275 
*I 
*I 
*I 
*I 
*I 
*I 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 230 
231 
232 PRIVATE void striper( src ) /* Remove all \r's (but not \n's) from src. */ 
char *src; 
{ 
char *dest; 
for( dest = src ; *src src++ ) 
if( *src != '\r' ) 
*dest++ = *src; 
*dest = '\0'; 
LLama's parser uses the LEX-generated lexical analyzer to parse the LLama input 
file, creating a symbol table with what it finds there. A symbol table is a large data struc­
ture, indexed by symbol name (the lexeme associated with the name in the input file). A 
good analogy is an array of structures, one field of which is a string holding the symbol 
name. The other fields in the structure hold things like the numeric value assigned to 
each symbol (the token value) and the symbols's type (in the current case, the type is ter­
minal, nonterminal, or action, as compared to the more usual int, lonq, and so forth). 
LLama's symbol also stores tokenized versions of the right-hand sides as elements of 
the symbol-table entry for each nonterminal. I'll discuss the details of this process in a 
moment. The LLama code-generation phase is passed the symbol table, which in this 
case serves as a representation of the entire input language, and outputs code-the parse 
tables needed to parse an input file in the target language. It also copies the output 
parser from the template file to the output file. 
The parser.h file, which starts in Listing 4.19, is #included in most of the files that 
comprise both LLama and occs. It starts out on lines six to 12 with conditional­
compilation macros that work like the D () macro in <toolsldebug.h> (described in 
Appendix A). The argument to the LL () macro compiles only if you're making LLama 
(I usually define LLAMA on the compiler's command line with a cc -DLLAMA), the oppo­
site applies to the OX () macro. The listing also contains a few predefined exit codes. LLama's symbol-table. 
Conditional compilation 
macros: LL(), OX(). 
276 Top-Down Parsing-Chapter 4 
Listing 4.18. llout.h- LLama Token Definitions 
1 #define EOI 0 
2 #define ACTION 1 
3 #define CODE BLOCK 2 
4 #define COLON 3 
5 #define END OPT 4 
6 #define FIELD 5 
7 #define LEFT 6 
8 #define NAME 7 
9 #define NONASSOC 8 
10 #define OR 9 
11 #define OTHER 10 
12 #define PREC 11 
13 #define RIGHT 12 
14 #define SEMI 13 
15 #define SEPARATOR 14 
16 #define START 15 
17 #define START OPT 16 
18 #define SYNCH 17 
19 #define TERM SPEC 18 
20 #define TYPE 19 
21 #define PERCENT UNION 20 
22 #define WHITESPACE 21 
Listing 4.19. parser.h- Compilation Directives and Exit Stati 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 /* 
* 
* *I PARSER.H 
#ifdef LLAMA 
#define LL(x) x 
#define OX(x) 
#else 
#define LL(x) 
#define OX(x) x 
#endif This file contains those #defines, etc., that 
are used by both llama and yacc. There's also 
a yacc.h file that's used only by the yacc code. 
/*----------------------------------------------------------------------
* Various error exit stati. Note that other errors found while parsing cause 
* llama to exit with a status equal to the number of errors (or zero if 
* there are no errors). 
*I 
#define EXIT ILLEGAL ARG 255 /* Illegal command-line switch *I 
#define EXIT TOO MANY 254 /* Too many command-line args *I 
#define EXIT NO DRIVER 253 /* Can't find llama.par *I 
#define EXIT OTHER 252 /* Other error (syntax error, etc.) *I 
#define EXIT USR ABRT 251 /* Ctrl-Break *I 
Token values: MINNON­
TERM, MINACT. Parser.h continues in Listing 4.20 with the definitions of the numbers that represent 
terminals, nonterminals, and actions. You can change the values of MINNONTERM and 
MINACT (on lines 29 and 30), but they must always be in the same relative order. The 
Section 4.10.1-LLama's Parser 
following must hold: 
( 0 = _EO! ) < (MINTERM = 1) < MINNONTERM < MINACT 
Zero is reserved for the end-of-input marker (_ EOI _), and MINTERM must be I. Also 
note that there must be at least one hole between the maximum terminal and minimum 
nonterminal values. This hole is generated with the -2 in the MAXNONTERM definition on 
line 41. It's required because the symbolic value used forE is one more than the largest 
number actually used to represent a terminal symbol; the hole guarantees that there's 
enough space for the E. (EPSILON is defined on line 65.) The listing finishes with a few 
miscellaneous definitions for various file names, and so forth. 
Listing 4.20. parser.h- Numeric Limits for Token Values 
#define MAX NAME 32 /* Maximum length of a terminal or nonterminal name 
#define MAXPROD 512 /* Maximum number of productions in the input grammar 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define MINTERM 
MINNONTERM 
MINACT 
MAX TERM 
MAXNONTERM 
NUMTERMS 
NUMNONTERMS 
USED TERMS 1 /* Token values assigned to terminals start here *I 
256 /* nonterminals start here *I 
512 /* acts start here *I 
/* Maximum numeric values used for terminals 
* and nonterminals (MAXTERM and MINTERM), as 
* well as the maximum number of terminals and 
* nonterminals (NUMTERMS and NUMNONTERMS). 
(MINNONTERM 
(MINACT * Finally, USED_TERMS and USED_NONTERMS are 
* the number of these actually in use (i.e. 
* were declared in the input file). 
*I 
-2) 
-1) 
((MAXTERM-MINTERM) +1) 
((MAXNONTERM-MINNONTERM)+1) 
( (Cur_term -MINTERM) +1) 
USED NONTERMS ((Cur nonterm -MINNONTERM) +1) 277 
*I 
*I 25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 /* These macros evaluate to true if x represents 
* a terminal (ISTERM), nonterminal (ISNONTERM) 
#define ISTERM(x) 
#define ISNONTERM(x) 
#define ISACT(x) * or action (ISACT) 
*I 
((x) && (MINTERM <= (x)->va1 && (x)->val <= MAXTERM )) 
((x) && (MINNONTERM <= (x)->val && (x)->val <= MAXNONTERM)) 
((x) && (MINACT <= (x)->val )) 
/* Epsilon's value is one more than the largest 
* terminal actually used. We can get away with 
* this only because EPSILON is not used until 
* after all the terminals have been entered 
* into the symbol table. 
*I 
#define EPSILON (Cur_term+1) 
/* The following macros are used to adjust the 
* nonterminal values so that the smallest 
* nonterminal is zero. (You need to do this 
*when you output the tables,. ADJ_VAL does 
* the adjustment, UNADJ VAL translates the .... 
278 Top-Down Parsing-Chapter 4 
Listing 4.20. continued ... 
71 * adjust value back to the original value. 
*I 72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 #define ADJ_VAL(x) ((x)-MINNONTERM 
#define UNADJ_VAL(x) ((x)+MINNONTERM 
l*----------------------------------------------------------------------*1 
#define NONFATAL 
#define FATAL 
#define WARNING 
#define DOLLAR DOLLAR 0 
1 
2 I* Values to pass to error() and lerror(), *I 
I* defined in main.c. *I 
( (unsigned) -0 » 1) I* Passed to do_dollar() to *I 
I* indicate that $$ is to *I 
I* be processed. *I 
1*----------------------------------------------------------------------*l 
#ifdef LLAMA I* Various file names: *I 
# define TOKEN FILE "llout.h" I* output file for token #defines *I 
# define PARSE FILE "llout.c" I* output file for parser *I 
# define SYM FILE "llout.sym" I* output file for symbol table *I 
# define DOC FILE "llout.doc" I* LALR(l) State machine description *I 
# define DEF EXT "lma" I* foo.lma is default input extension *I 
# define PAR TEMPL "llama.par" I* template file for parser *I 
# define PROG NAME "llama" 
#else 
# define TOKEN FILE "yyout.h" I* output file for token #defines *I 
# define PARSE FILE "yyout.c" I* output file for parser *I 
# define ACT FILE "yyact.c" I* Used for output if -a specified *I 
# define TAB FILE "yyoutab.c" I* output file for parser tables (-T) *I 
# define SYM FILE "yyout.sym" I* output file for symbol table *I 
# define DOC FILE "yyout.doc" I* LALR (1) State machine description *I 
# define DEF EXT "ox" I* foo.ox is default input extension *I 
# define PAR TEMPL "occs.par" I* template file for PARSE FILE *I 
# define ACT TEMPL "occs-act.par" I* template file for ACT FILE *I 
# define PROG NAME "aces" 
#endif 
Definitions for output 
functions, YY _ TTYPE Listing 4.21 shows several definitions used by the output functions. The typedefs 
for YY _ TTYPE on lines 115 and 116 are used only to predict the size ofthe output transi­
tion tables. They should agree with the the YY _ TTYPE definitions in the parser­
template files. 
Symbol-table data struc­
tures. 
SYMBOL structure. The next part of parser.h, the SYMBOL and PRODUCTION structures declared in List­
ing 4.22, are used for LLama's symbol table. Symbol tables tend to be the most com­
plex data structure in the compiler, and the LLama symbol table is no exception. Figure 
4.9 shows a symbol table containing an entry for the following three productions: 
expr ~ term PLUS expr 
I term 
term ~ NUMBER {create_tmp(yytext);} 
For clarity, I've left out unimportant fields, and NULL pointers are just left blank in the 
picture. 
The symbol table itself is made up of SYMBOL structures, shown in the dashed box in 
Figure 4.9. This box is actually a hash table, put together with the functions described in 
Section 4.10.1-LLama's Parser 279 
Listing 4.21. parser.h- Simple Types 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 /* The following are used to define types of the OUTPUT transition tables. The 
* ifndef takes care of compiling the llama output file that will be used to 
* recreate the llama input file. We must let the llama-generated definitions 
* take precedence over the the default ones in parser.h in this case. 
*I 
#ifndef CREATING LLAMA PARSER 
LL ( typedef unsigned char 
ox ( typedef int 
#endif YY TTYPE 
YY TTYPE 
Listing 4.22.parser.h- The SYMBOL and PRODUCTION Data Structures 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
!50 
!51 
!52 
!53 
!54 
!55 
!56 /*SYMBOL structure (used tor symbol table). Note that the name itself*/ 
/* is kept by the symbol-table entry maintained by the hash function. */ 
#define NAME MAX 32 
typedef struct _symbol 
{ 
char 
char 
unsigned 
unsigned unsigned unsigned 
unsigned 
char 
struct _prod_ 
SET 
LL( SET 
} SYMBOL; name 
field 
val; 
used; 
set; NAME MAX ] ; 
NAME MAX ] ; 
lineno; 
*string; 
*productions; 
*first; 
*follow; ) /* Max name length + 1 */ 
/* symbol name. Must be first */ 
/* %type <field> */ 
/* numeric value of symbol */ 
/* symbol used on an rhs */ 
/* symbol defined */ 
/* input line num. of string */ 
/* code tor actions. */ 
/* right-hand sides if nonterm*/ 
/* FIRST set */ 
/* FOLLOW set */ 
#define NULLABLE(sym) ( ISNONTERM(sym) && MEMBER( (sym)->first, EPSILON) ) 
/*----------------------------------------------------------------------*/ 
/* PRODUCTION Structure. Represents right-hand sides. */ 
#define MAXRHS 31 
#define RHSBITS 5 /* Maximum number of objects on a right-hand side 
/* Number of bits required to hold MAXRHS *I 
*I 
typedef struct _prod_ 
{ 
unsigned 
SYMBOL num; 
*rhs[ MAXRHS + 1]; 
SYMBOL *lhs; 
unsigned char rhs len; 
unsigned char non_acts; 
SET *select; 
struct _prod_ *next; 
OX( int prec; ) 
PRODUCTION; /* production number */ 
/* Tokenized right-hand side */ 
/* Left-hand side */ 
/* # of elements in rhs[] array */ 
/* that are not actions */ 
/* LL(l) select set */ 
/* pointer to next production */ 
/* tor this left-hand side. */ 
/* Relative precedence */ 
Appendix A. A SYMBOL contains the name of the symbol (name) and the internal 
numeric value (val). If the symbol is an action, the string field points at a string that 
holds the code specified in the LLama input file. In the case of a nonterminal, the 
280 
PRODUCTION structure. Top-Down Parsing-Chapter 4 
Figure 4.9. Structure of the LLama Symbol Table 
name: expr 
val: 257 
string: 
productions: 
name: term 
val: 258 
string: 
productions: 
name: PLUS 
val: 2 
string: 
productions: 
name: NUMBER 
val: 4 
string: 
productions: 
name: {2} 
val: 514 
string: {rvalue(yytext);} 
productions: 
productions field points at the head of a linked list of PRODUCTION structures, one 
element of the list for each right-hand side. The right-hand side is represented within the 
PRODUCTION as an array of pointers to symbol-table entries for each element of the 
right-hand side. The size of this array obviously limits the size of the right-hand side. I 
opted for this approach rather than keeping an array of numeric values for the symbols, 
because the latter would require an additional table lookup every time I had to access a 
symbol on a right-hand side. Note that the PRODUCTIONs form a doubly linked list in 
that the lhs field of each PRODUCTION points back to the production's left-hand side. 
The next field is just the next element in the linked list. 
Other fields in the PRODUCTION are the production number (num)-an arbitrary, but 
unique, number assigned to each production; rhs _len is the number of symbols in the 
rhs [] array; non_acts is the number of elements in rhs [ l that are not actions; 
finally, select is the LL(l) select set. (I'll discuss exactly what this is in a moment.) 
The prec field holds the relative precedence level of the current production if you're 
compiling for occs. This number is usually the precedence level of the rightmost 
Section 4.10.1-LLama's Parser 281 
terminal on the right-hand side, but it can be changed with a %prec directive. 
Other fields in the SYMBOL structure are: lineno-the input line number on which 
the symbol is defined; used is set true when a symbol is used on a right-hand side; and 
set is set true when a symbol is defined with a %term or by appearing as a left-hand 
side. It's a hard error for a symbol to be used without having been defined (set). It's just 
a warning if the symbol is defined but not used, however. Actions are set implicitly by 
being used. I'll discuss the first and follow fields in a moment. 
The next data structure of interest is the PREC TAB structure defined on lines 159 to 
164 of Listing 4.23. This structure is used only by occs-it holds precedence and associ­
ativity information for the terminal symbols. An array of these (defined on line 200) is 
indexed by nonterminal value. This information could also be incorporated into the 
SYMBOL structure, but it's easier to keep it as a separate table. The remainder of parser.h 
comprises global-variable and subroutine declarations. Space is allocated for the vari­
ables if ALLOCATE is defined before parser.h is #included. Precision table: 
PRECTAB 
Listing 4.23. parser.h- Declarations and Type Definitions 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 178 
179 
180 
181 
182 
183 
184 
185 
186 
187 188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 #ifdef occs 
typedef struct _prectab_ 
{ 
unsigned char level; 
unsigned char assoc; /* Relative precedence, O=none, 1=lowest */ 
/*associativity: 'l'=left,'r'=right, '\O'=none */ 
PREC_TAB; 
#define DEF FIELD "yy_def" 
#endif 
#ifdef 
# 
# 
#else 
# 
# 
#endif ALLOCATE 
define CLASS 
define I (X) X 
define CLASS extern 
define I (x) 
CLASS int Debug I( 
CLASS char *Input file_name I( 
CLASS int Make actions I( 
CLASS int 
CLASS int 
CLASS int 
CLASS int 
CLASS FILE 
CLASS int 
CLASS int 
CLASS int 
CLASS int 
CLASS int 
CLASS int Make_parser 
Make_yyoutab 
No lines 
No_warnings 
*Output 
Public 
Symbols 
Threshold 
Uncompressed 
Use stdout 
Verbose I ( 
I ( I ( I ( I ( 
I ( 
I ( 
I ( 
I ( I ( 
I ( 
CLASS SYMBOL *Terms[ MINACT ]; /* Field name for default field in a 
/* %union. *I 
*I 
0 /* If ALLOCATE is true, allocate space 
/* activate the initializer, otherwise 
/* storage class is extern and the 
/* initializer is gobbled up. and */ 
the */ 
*I 
*I 
I* The following are set in */ 
/* main.c, mostly by command- */ 
/* line switches. */ 
); /*True for debug diagnostics */ 
"console" 
1 ); /*Input file name */ 
); /* ==0 if -p on command line */ 
1 ); /* ==0 if -a on command line */ 
0 ); /* ==1 if-Ton command line */ 
0 ); /*Suppress #lines in output */ 
0 ); /*Suppress warnings if true */ 
stdout ); /*Output stream. */ 
0 
0 
4 
0 
0 
0 ); /*Make static symbols public */ 
); /*Generate symbol table. */ 
); /*Compression threshold */ 
); /*Don't compress tables */ 
); /* -t specified on command line*/ 
); /*Verbose-mode output (1 for */ 
/* -v and 2 for -V) */ 
/* This array is indexed by terminal or 
* nonterminal value and evaluates to a 
* pointer to the equivalent symbol-table 
* entry. 
*I .... 
282 Top-Down Parsing-Chapter 4 
Listing 4.23. continued ... 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 OX( CLASS PREC TAB Precedence[ MINNONTERM ]; ) /* Used only by aces. Holds *I 
/* relative precedence and *I 
/* associativity information *I 
/* for both terminals and *I 
/* nonterminals. *I 
LL( CLASS SET *Synch; ) /* Error-recovery synchronization */ 
/* set (specified with %synch). */ 
/* Synch is initialized in acts.c */ 
/* It is used only by llama. */ 
CLASS char *Template I(=PAR_TEMPL); /* Template file for the parser; */ 
/* can be modified in main.c */ 
CLASS HASH TAB *Symtab; /* The symbol table itself */ 
/* (initialized in yyact.c) */ 
CLASS SYMBOL *Goal_symbol I(=NULL); /*Pointer to symbol-table entry */ 
/* for the start (goal) symbol */ 
/* The following are used */ 
/* by the acts [in llact.c} */ 
CLASS int Cur term I(= MINTERM-1 ); /*Current terminal */ 
CLASS int Cur nonterm I(= MINNONTERM-1); /* nonterminal */ 
CLASS int Cur act I(= MINACT-1 ); /* action */ 
CLASS int Num_productions I(= 0 ); /*Number of productions */ 
#undef CLASS 
#undef I 
/*----------------------------------------------------------------------*/ 
#define outc(c) putc(c,Output); /* Character routine to complement */ 
/*output() in main.c */ 
LLama's parser does one thilig: it loads the symbol table with the grammar 
represented by the input file. The process is analogous to creating a physical parse 
tree-the input language can be represented entirely by the symbol table, just as normal 
programming language can be represented by the parse tree. 
Llama input language: 
recursive-descent gram­
mar, Llama input file. An augmented grammar for the simple, recursive-descent version of the LLama 
parser is shown in Table 4.19. The LLama input file in Listing 4.24 speci ties the com­
plete input grammar for both LLama and occs. I'll build a recursive-descent LLama 
first, and then build a more complete parser later, using the stripped-down version of 
LLama for this purpose. 
Recursive-descent parser 
for Llama. The recursive-descent parser for LLama is in Listing 4.25. It is a straightforward 
representation of the grammar in Table 4.19. 
Section 4.10.1-LLama's Parser 
Table 4.19. LLama Grammar (Small Version) 
Production 
spec ~ definitions {first_ sym () } body stuff 
definitions ~ TERM_ SPEC tnames definitions 
I CODE_BLOCK definitions 
I SYNCH snames definitions 
I SEPARATOR 
I EOI - -snames ~ NAME {add_synch(yytext)} snames 
tnames ~ NAME {make_term (yytext)} tnames 
body ~ rule body 
I rule SEPARATOR 
I rule EOI --rule ~ NAME {new_nonterm(yytext, 1)} COLON right_sides 
I E 
right_sides ~ {new_ rhs () } rhs OR right_sides 
I {new_ rhs () } rhs SEMI 
rhs ~ NAME {add_to_rhs (yytext, 0)} rhs 
I ACTION {add to rhs (yytext, start 
Listing 4.24. parser.lma- LLama Input Specification for Itself 
%{ 
#include <stdarg.h> 
#include <toolsldebug.h> 
#include <toolslhash.h> 
#include <toolslset.h> action () ) } rhs Implemented in 
this subroutine 
yyparse () 
definitions ( ) 
definitions ( ) 
definitions () 
definitions () 
definitions () 
definitions() 
definitions () 
body() 
body() 
body() body() 
body() 
right_sides () 
right_sides () 
rhs () 
rhs () 
1 
2 
3 
4 
5 
6 
7 
8 
9 #define CREATING LLAMA PARSER 
#include "parser-:-h" -I* Suppress various definitions in parser.h *I 
I* that conflict with llama-generated defs. *I 283 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 I* This file is a llama input file that creates a parser for llama, like a snake 
*eating its tail. The resulting yyparse.c file can be used in place of the 
* recursive-descent parser in llpar.c. Note that, though this file is certainly 
* easier to write than the recursive-descent version, the resulting code is 
*about lK larger. nows() should be called before firing up the parser. 
*Most of the external subroutines called from this module are in acts.c. 
* Exceptions are: 
*I 
extern char 
extern int 
extern void 
#define YYSTYPE 
%} 
%token ACTION *yytext; 
yylineno; 
nows () , ws () ; 
char* 
I* 
%token CODE BLOCK I* 
%token COLON I* 
%token END OPT I* 
%token FIELD I* 
%token LEFT I* I* Generated by lex *I 
I* Generated by lex *I 
I* Declared in llama.lex. *I 
I* Value-stack type. *I 
{str} *I 
%{ %} *I 
*I 
1 1 * *I 
<name> *I 
%left *I 
284 Top-Down Parsing-Chapter 4 
Listing 4.24. continued ... 
%token NAME /* name *I 
%token NONASSOC /* %nonassoc *I 
%token OR /* *I 
%token OTHER /* anything else *I 
%token PREC /* %prec *I 
%token RIGHT /* %right *I 
%token SEMI /* ; *I 
%token SEPARATOR /* %% *I 
%token START /* %start *I 
%token START OPT /* [ *I 
%token SYNCH /* %synch *I 
%token TERM SPEC /* %term or %token *I 
%token TYPE /* %type *I 32 
33 
34 
35 
36 
37 
38 39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 %token PERCENT UNION /* %union *I 
%token WHITESPACE 
%synch 
%% 
spec 
end 
55 defs 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 fnames 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 tnames 
pnames SEMI 
85 opt names 
86 
87 
88 snames 
89 rules 
90 
91 OR /* 0 <= c <= , , *I 
defs SEPARATOR { first sym (); } rules end 
{ WS ();} SEPARATOR 
/* empty *I 
SYNCH snames defs 
PERCENT UNION ACTION 
TYPE union def( yytext ) ; } defs 
TERM SPEC 
LEFT 
RIGHT 
NONASSOC 
CODE BLOCK 
START 
{ new lev 
new lev 
new lev 
new lev -/* the 
lerror( NONFATAL, ( 0 ) ; 
(, l,) ; 
(' r'); 
(, n') ; 
block is fnames {new_field("") ;} defs 
tnames {new_field("");} defs 
pnames {new_field("") ;} defs 
pnames {new_field("") ;} defs 
pnames {new_field('"');} defs 
copied out by yylex */ defs 
"%start not supported by occs. The first\n" 
"\t\t\tproduction is the start production\n"); 
opt names defs 
/* empty */ 
NAME { new_nonterm (yytext,O); fnames fnames 
FIELD { new_field (yytext); 
/* empty */ 
NAME { make_term(yytext); 
FIELD { new_field(yytext); 
/* empty */ 
NAME { prec list(yytext); 
FIELD { new field(yytext); -/* empty */ 
NAME opt names 
/* empty */ tnames 
tnames 
pnames 
pnames 
NAME { add_synch(yytext); } snames I /* empty*/ 
rule rules 
/* empty */ 
Section 4.10.1-LLama's Parser 
Listing 4.24. continued ... 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 rule NAME 
FIELD new_nonterm(yytext,l); 
new_nonterm(yytext,l); COLON right_sides 
COLON right sides 
right sides 
end rhs 
rhs { new_rhs(); } rhs end rhs 
OR right sides 
SEMI 
NAME 
FIELD add to 
add to rhs(yytext, -rhs(yytext, -0 
0 
ACTION add to rhs(yytext, start 
PREC NAME 
START OPT 
rhs END 
rhs 
/* empty */ 
%% 
yy_init llama( tovs 
yyvstype *tovs; 
{ 
tovs->left = tovs->right 
char *yypstk(tovs, tods) 
yyvstype *tovs; 
char *tods; 
{ 
static char buf[l28]; prec 
OPT 
if ( *tovs->left I I *tovs->right 
{ -(yytext 
start_opt( yytext ) ; 
end_opt ( yytext ) ; 
sprintf(buf,"[%s,%s]", tovs->left, tovs->right); 
return buf; 
else 
return ""· ' ) ; 
) ; 
action()); 
) ; rhs 
rhs 
rhs 
rhs 
Listing 4.25./lpar.c- Recursive-Descent Parser for LLama 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 #include <stdio.h> 
#include <stdarg.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "llout.h" 
#include "parser.h" 
/* LLPAR.C: 
* 
* 
*I A recursive-descent parser for a very stripped down llama. 
There's a llama input specification for a table-driven parser 
in llama.lma. 285 
286 Top-Down Parsing -Chapter 4 
Listing 4.25. continued ••. 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 void advance 
void lookfor 
void definitions 
void body 
void right_sides 
void rhs 
int yyparse p ( ( 
p ( ( 
p ( ( 
p ( ( 
p ( ( 
p ( ( 
p ( ( void 
int 
void 
void 
void 
void 
void 
extern int yylineno; 
extern char *yytext; 
extern int yylex(); ) ) ; /* local */ 
first, ... ) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; /* public */ 
/* Created by lex.*/ 
!*----------------------------------------------------------------------*/ 
PUBLIC int yynerrs; 
PRIVATE int Lookahead; /* Total error count 
/* Lookahead token *I 
*I 
/*====================================================================== 
* Low-level support routines for parser: 
*I 
#define match(x) ((x) == Lookahead) 
PRIVATE void advance() 
{ 
if( Lookahead != EOI ) 
while( (Lookahead = yylex()) WHITESPACE ) 
/*----------------------------------------------------------------------*/ 
PRIVATE void lookfor ( first, ... ) 
int first; 
/* Read input until the current symbol is in the argument list. For example, 
* lookfor(OR, SEMI, 0) terminates when the current Lookahead symbol is an 
* OR or SEMI. Searching starts with the next (not the current) symbol. 
*I 
int *obj; 
for( advance() ;; advance() ) 
{ 
for( obj 
if ( *obj 
break; &first; *obj && !match(*obj) 
/* Found a match *I 
else if( match(_EOI ) ) obj++ ) 
lerror(FATAL, "Unexpected end of file\n"); 
/*====================================================================== 
* The Parser itself 
*I 
PUBLIC int yyparse() 
{ 
extern yylineno; /* spec definitions body stuff *I 
.... 
Section 4.10.1-LLama's Parser 287 
Listing 4.25. continued ... 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 128 
129 
130 
131 
132 133 
134 
135 Lookahead = yylex(); 
definitions(); 
first_sym(); 
body(); /* Get first input symbol */ 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
{ definitions() 
/* 
* definitions TERM SPEC tnames definitions implemented at: 
1 
* CODE BLOCK definitions 
* SYNCH snames definitions 
* SEPARATOR 
* EOI 
* snames 
* tnames 
* NAME {add_synch} snames 
NAME {make_term} tnames 
* Note that LeX copies the CODE BLOCK contents to the output file 
* automatically on reading it. 
*I 
while( !match(SEPARATOR) && !match(_EOI ) 
{ 
if( Lookahead == SYNCH ) 
{ 
for( advance(); match(NAME); advance() ) 
add_synch( yytext ); 
else if( Lookahead == TERM SPEC 
for( advance(); match(NAME); advance() 
make_term( yytext ); 
else if( Lookahead != CODE BLOCK 
{ 
lerror(NONFATAL,"Ignoring illegal <%s> in definitions\n", 
advance(); 2 
3 
4 
4 
5 
6 
/* 4 
/* 3 
/* 5 
/* 1 
/* 6 
/* 2 
yytext 
advance(); /* advance past the %% */ 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
{ body() *I 
*I 
*I 
*I 
*I 
*I 
) ; 
/* 
* body rule body implemented at: 
1 
* 
* 
* rule 
* *I rule SEPARATOR 
rule EOI 
NAME {new_nonterm} COLON right_sides 
<epsilon> 
while( !match(SEPARATOR) && !match(_EOI ) 
{ 1 
1 
2 
3 
/* 1 */ 
.... 
288 Top-Down Parsing-Chapter 4 
Listing 4.25. continued ... 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 188 
189 
190 
191 
192 
193 
194 
195 if( match(NAME) 
{ I* 2 *I 
new_nonterm( yytext, 1 ); 
advance(); 
else I* 3 *I 
lerror(NONFATAL, "Illegal <%s>, nonterminal expected.\n", yytext); 
lookfor( SEMI, SEPARATOR, 0 ) ; 
if( match(SEMI) ) 
advance(); 
continue; 
if( match( COLON ) ) 
advance(); 
else 
lerror(NONFATAL, "Inserted missing' :'\n"); 
right sides(); 
WS (); I* Enable white space (see parser.lex) *I 
if( match(SEPARATOR) 
yylex () ; I* Advance past %% 
l*----------------------------------------------------------------------*1 
PRIVATE void 
{ right sides () 
I* right_sides {new_rhs} rhs OR right_sides 
{new_rhs} rhs SEMI * *I 
new rhs (); 
rhs () ; 1 
2 *I 
while( match(OR) 
{ I* 1 *I 
advance(); 
new_rhs(); 
rhs (); 
if( match(SEMI) I* 2 *I 
advance(); 
else 
lerror(NONFATAL, "Inserted missing semicolon\n"); 
1*----------------------------------------------------------------------*l 
PRIVATE void 
{ 
I* rhs 
I* rhs () 
NAME {add_to_rhs} rhs *I 
ACTION {add_to_rhs} rhs *I 
while( match(NAME) 11 match(ACTION) ) 
{ 
add_to_rhs( yytext, match(ACTION) ? start_action() 0 ); .... 
Section 4.10.1-LLama's Parser 289 
Listing 4.25. continued ... 
196 advance(); 
197 
198 
199 if( !match(OR) && !match(SEMI) ) 
200 { 
201 lerror (NONFATAL, 11 illegal <%s>, ignoring rest of production \n 11, yytext) ; 
202 lookfor( SEMI, SEPARATOR, OR, 0 ); 
203 
204 
The action subroutines, in Listings 4.26, 4.27, and 4.28. work as follows: 
add_synch(char *yytext) 
Add the symbol named by yytext to the synchronization set used for error 
recovery. 
add_to_rhs(char *yytext, int isact) 
Add the symbol named by yytext to the current right-hand side. The isact 
argument should be true if the symbol is an action. 
1 end_opt (char *yytext) 
Mark the end of an optional production. This routine processes occs' [ ... ], 
[ ... l * operators by adding extra elements to the production. 
first sym(void) 
This routine finds the goal symbol, which is the left-hand side of the first produc­
tion that follows the first%% directive. The problem here is that, in occs, a nonter­
minal can be declared explicitly in a previous %type directive, so you can't 
assume that the first non terminal that's declared is the goal symbol. 
lerror(int error_type, char *format, ... ) 
This routine prints an error message. The first argument should be FATAL, NON­
FATAL, or WARNING (these are defined at the top of parser.h). If the error is 
FATAL, all files are closed and LLama is terminated, otherwise parsing contin­
ues. The input file name and line number is automatically appended to the front 
of the message. This routine works like fprintf () in other respects. 
make_term(char *yytext) 
Make an entry for a terminal symbol. 
new_field(char *yytext) 
Change the name of the %union field to which subsequent input symbols are 
attached. 
new_lev(int associativity) 
Increment the precedence level by one notch (all subsequent arguments to a 
%left, %right, or %nonassoc use this new level). Also change the current 
associativity as speci tied. This argument should be ' 1' for left , ' r' for right, 
'n' for none, or 0 for unspecified. Llama actions: 
Listing 4.28, lines 628 
and 690. 
Listing 4.27, line 488. 
Listing 4.28, line 596. 
Listing 4.27, line 380. 
In main.c. 
Listing 4.27, line 335. 
Listing 4.28, lines 675 
and 793. 
Listing 4.28, lines 648 
and 698. 
290 Top-Down Parsing-Chapter 4 
Listing 4.27, line 391. new_nonterm(char *yytext, int is_lhs) 
Create a symbol-table entry for a nonterminal if one doesn't already exist. 
yytext is the symbol name. is _lhs tells the subroutine whether the nontermi­
nal was created implicitly (whether it was used before appearing on the left-hand 
side of a production). is _lhs zero in this case. Return a pointer to the SYMBOL 
or NULL if an attempt is made to use a terminal symbol as a left-hand side. 
Listing 4.27, line 460. new_ rhs (void) 
Stop adding symbols to the current right-hand side, and start up a new (and 
empty) right-hand side. 
In main.c. output(char *format, ... ) 
Works like fprintf (Output, ... ); sends the string to the current output 
stream, typically standard output but it can be changed from the command line. 
Listing 4.28, lines 659 
and 735. prec(char *yytext) 
Process the argument to a %prec directive. (Change the precedence level of the 
current right-hand side from the default level to the one indicated in yytext.) 
Listing 4.28, lines 671 
and 710. prec_list(char *yytext) 
Process an argument to %left, %right, or %nonassoc. 
Listing 4.28, line 581. start_opt(char *yytext) 
Mark the start of an optional or repeating portion of a right-hand side [see 
end_opt () ]. 
Listing 4.28, lines 665 
and 762. union_def(char *yytext) 
Create a typedef for the occs value stack, using the %union definition in 
yytext. 
Listing 4.26. acts.c- LLama Action Subroutines 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 linclude <stdio.h> 
#include <malloc.h> 
#include <ctype.h> 
#include <string.h> 
linclude <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslhash.h> 
#include <toolslcompiler.h> 
linclude <toolsll.h> 
#include <toolslstack.h> 
#undef stack cls 
#define stack_cls static 
#include "parser.h" 
#include "llout.h" I* stack-manipulation macros 
I* Make all stacks static *I 
*I 
I* ACTS.C 
* Action routines used by both llama and aces. These build 
up the symbol table from the input specification. 
*I 
Section 4.10.1-LLama's Parser 291 
Listing 4.26. continued ... 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 void find _problems p ( ( 
int c identifier p ( ( SYMBOL *sym, 
char *name void *junk )); /*local*/ 
) ) ; 
void print_ tok p ( ( FILE *stream, 
void pterm p ( ( SYMBOL *sym, char *format, 
FILE *stream int arg )); /*public*/ 
) ) ; 
void pact p ( ( SYMBOL *sym, FILE *stream ) ) ; 
void pnonterm p ( ( SYMBOL *sym, FILE *stream ) ) ; 
void print_symbols p ( ( FILE *stream ) ) ; 
int problems p ( ( void ) ) ; 
void init acts p ( ( void ) ) ; 
SYMBOL *make term p ( ( char *name ) ) ; 
void first _sym p ( ( void ) ) ; 
SYMBOL *new nonterm p ( ( char *name, int is lhs ) ) ; 
void new rhs p ( ( void ) ) ; 
void add to rhs p ( ( char *object, int is an action ) ) ; 
void start _opt p ( ( char *lex ) ) ; 
void end_opt p ( ( char *lex ) ) ; 
void add_synch p ( ( char *yytext ) ) ; 
void new lev p ( ( int how ) ) ; 
void prec list p ( ( char *name ) ) ; -void prec p ( ( char *name ) ) ; 
void union def p ( ( char *action ) ) ; 
int fields active p ( ( void ) ) ; 
void new field p ( ( char *field name ) ) ; 
/*----------------------------------------------------------------------*/ 
extern int 
PRIVATE int 
PRIVATE int yylineno; 
Associativity; 
Prec lev = 0; /* Input line number--created by LeX. */ 
/* Current associativity direction. */ 
PRIVATE char 
PRIVATE int 
PRIVATE int Field_name[NAME_MAX]; 
Fields active = 0; /* Precedence level. Incremented 
/* after finding %left, etc., 
/* but before the names are done. 
/* 
/* Field name specified in <name>. 
Fields are used in the input. 
/* (If they're not, then automatic 
/* field-name generation, as per 
/* %union, is not activated.) 
Goal symbol is_next =0; /* 
/* If true, the next nonterminal is 
the goal symbol. 
/*-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* The following stuff (that's a technical term) is used for processing nested 
* optional (or repeating) productions defined with the aces [] and []* 
* operators. A stack is kept and, every time you go down another layer of 
* nesting, the current nonterminal is stacked and an new nonterminal is 
*allocated. The previous state is restored when you're done with a level. 
*I 
#define SSIZE 8 
typedef struct cur_sym_ 
{ /* Max. optional-production nesting level */ 
char 
SYMBOL 
PRODUCTION 
CUR_SYM; lhs_name[NAME_MAX]; /*Name associated with left-hand side. */ 
*lhs; /* Pointer to symbol-table entry for */ 
/* the current left-hand side. */ 
*rhs; /* Pointer to current production. */ 
CUR SYM Stack[ SSIZE ], /* Stack and */ 
*Sp =Stack+ (SSIZE-1); /*stack pointer. It's inconvenient to use*/ *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
292 Top-Down Parsing-Chapter 4 
Listing 4.26. continued ... 
81 I* stack.h because stack is of structures. *I 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 I*====================================================================== 
* Support routines for actions 
*I 
PUBLIC void print_tok( stream, format, arg 
FILE 
char *stream; 
*format; I* not used here but supplied by pset() *I 
int arg; 
I* Print one nonterminal symbol to the specified stream. *I 
if ( arg -1 fprintf(stream, "null " ) ; 
else if( arg -2 fprintf (stream, "empty " ) ; 
else if( arg EOI fprintf(stream, "$ " ) ; 
else if( arg EPSILON fprintf (stream, "<epsilon> " ) ; 
else fprintf(stream, "%s " Terms[arg]->name ) ; I 
1*----------------------------------------------------------------------
* The following three routines print the symbol table. Pterm(), pact(), and 
* pnonterm() are all called indirectly through ptab(), called in 
* print_symbols(). They print the terminal, action, and nonterminal symbols 
* from the symbol table, respectively. 
*I 
PUBLIC void pterm( sym, stream ) 
SYMBOL *sym; 
FILE *stream; 
{ 
int i; 
if( !ISTERM(sym) 
return; 
LL( fprintf( stream, "%-16.16s 
OX( fprintf( stream, "%-16.16s %3d\n", sym->name, sym->val ); 
%3d %2d %c <%s>\n",\ 
sym->name,\ 
sym->val,\ 
Precedence[sym->val] .level,\ 
(i = Precedence[sym->val] .assoc) ? i 
sym->field ) ; ) I _I I\ 
1*----------------------------------------------------------------------*l 
PUBLIC void pact( sym, stream) 
SYMBOL *sym; 
FILE *stream; 
{ 
if ( ! ISACT (sym) 
return; 
fprintf( stream, "%-5s %3d,", sym->name, sym->val ); 
fprintf( stream, "line %-3d: ", sym->lineno ); 
fputstr( sym->string, 55, stream); 
fprintf ( stream, "\n") ; 
Section 4.10.1-LLama's Parser 
Listing 4.26. continued ... 
/*----------------------------------------------------------------------*/ 
PUBLIC char *production_str( prod ) 
PRODUCTION *prod; 
{ 
/* return a string representing the production *I 
int i, nchars, avail; 
static char buf[80]; 
char *p; 
nchars 
p 
avail sprintf(buf,"%s ->", prod->lhs->name ); 
buf + nchars; 
sizeof(buf) -nchars -1; 
if( !prod->rhs_len ) 
sprintf(p, " (epsilon)" ) ; 
else 
for( i = 0; i < prod->rhs_len && avail > 0 ; ++i ) 
{ 
nchars = sprintf(p, "%0.*s", avail-2, prod->rhs[i]->name ); 
avail nchars; 
p += nchars; 
return buf; 
/*----------------------------------------------------------------------*/ 
PUBLIC 
SYMBOL 
FILE void pnonterm( sym, stream ) 
*sym; 
*stream; 
{ 
int 
char 
PRODUCTION 
int i; 
*s; 
*p; 
chars_printed; 
stack_dcl( pstack, PRODUCTION*, MAXPROD ); 
if( !ISNONTERM(sym) 
return; 
fprintf( stream, "%s (%3d) %s", sym->name, sym->val, 
sym == Goal_symbol? "(goal symbol)" 
OX( fprintf( stream, "<%s>\n", sym->field ); 
LL( fprintf( stream, "\n" ); 
if( Symbols > 1 ) 
{ II II ) ; 293 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 /* Print first and follow sets only if you want really verbose output.*/ 
fprintf( stream, " FIRST : " ); 
pset( sym->first, print_tok, stream ) ; 
LL( fprintf(stream, "\n FOLLOW: "); 
LL( pset( sym->follow, print_tok, stream); 
.... 
294 Top-Down Parsing-Chapter 4 
Listing 4.26. continued ... 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 fprintf(stream, "\n"); 
/* Productions are put into the SYMBOL in reverse order because it's easier 
* to tack them on to the beginning of the linked list. It's better to print 
* them in forward order, however, to make the symbol table more readable. 
* Solve this problem by stacking all the productions and then popping 
* elements to print them. Since the pstack has MAXPROD elements, it's not 
* necessary to test for stack overflow on a push. 
*I 
for( p = sym->productions 
push( pstack, p ); p p p->next ) 
while( !stack_empty( pstack ) ) 
{ 
p = pop(pstack); 
chars _printed = fprintf (stream, n %3d: %s", 
p->num, production_str( p )); 
LL( for( ; chars_printed <= 45; ++chars_printed 
LL( putc( '.', stream); 
LL( fprintf(stream, "SELECT: "); 
LL( pset( p->select, print_tok, stream); 
OX( if( p->prec ) 
OX( { 
OX( for( ; chars_printed <= 60; ++chars_printed ) 
OX ( putc ( ' . ', stream ) ; 
OX( if( p->prec ) 
OX( fprintf(stream, "PREC %d", p->prec ); 
OX( 
putc('\n', stream); 
fprintf(stream, "\n"); 
/*----------------------------------------------------------------------*/ 
PUBLIC void print_symbols( stream) 
FILE *stream; 
{ 
/* Print out the symbol table. Nonterminal symbols come first for the sake 
*of the 's' option in yydebug(); symbols other than production numbers can 
* be entered symbolically. ptab returns 0 if it can't print the symbols 
* sorted (because there's no memory. If this is the case, try again but 
*print the table unsorted). 
*I 
putc( '\n', stream); 
fprintf( stream, "----------------Symbol table ------------------\n" ); 
fprintf( stream, "\nNONTERMINAL SYMBOLS:\n\n" ); 
if( ptab( Symtab, pnonterm, stream, 1 ) == 0 ) 
ptab( Symtab, pnonterm, stream, 0 ); 
.... 
Section 4.10.1-LLama's Parser 
Listing 4.26. continued ... 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 310 
311 
312 
313 
314 
315 
316 
317 
318 
319 fprintf( stream, "\nTERMINAL SYMBOLS:\n\n"); 
OX( fprintf( stream, "name value prec assoc 
LL( fprintf( stream, "name value\n"); 
if( ptab( Symtab, pterm, stream, 1 0 ) 
ptab( Symtab, pterm, stream, 0 ); 
LL( fprintf( stream, "\nACTION SYMBOLS:\n\n"); 
LL( if( !ptab( Symtab, pact, stream, 1 ) ) 
LL( ptab( Symtab, pact, stream, 0 ) ; field\n"); 
LL( fprintf( stream, "----------------------------------------\n" ) ; 
/*----------------------------------------------------------------------
*Problems() and find_problems work together to find unused symbols and 
* symbols that are used but not defined. 
*I 
PRIVATE void find_problems( sym, junk) 
SYMBOL *sym; 
*junk; void 
{ /* not used */ 
if( !sym->used && sym!=Goal_symbol ) 
error( WARNING, "<%s> not used (defined on line %d)\n", 
sym->name, sym->set ); 
if( !sym->set && !ISACT(sym) ) 
error( NONFATAL, "<%s> not defined (used on line %d)\n", 
sym->name, sym->used ); 
PUBLIC int problems() 
{ 
/* Find, and print an error message, for all symbols that are used but not 
* defined, and for all symbols that are defined but not used. Return the 
* number of errors after checking. 
*I 
ptab( Symtab, find_problems, NULL, 0 ) ; 
return yynerrs; 
/*----------------------------------------------------------------------*/ 
PRIVATE int hash_funct( p ) 
SYMBOL *p; 
{ 
if ( ! *p->name 
lerror( FATAL, "Illegal empty symbol name\n" ); 
return hash_add( p->name ); 
PUBLIC void init_acts() 
{ 
/* Various initializations that can't be done at compile time. Call this 
* routine before starting up the parser. The hash-table size (157) is 
* an arbitrary prime number, roughly the number symbols expected in the 
* table. 
*I 295 
296 Top-Down Parsing -Chapter 4 
Listing 4.26. continued ... 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 extern int 
static SYMBOL strcmp (); 
bogus_ symbol; 
strcpy( bogus_symbol.name, "End of Input" ); 
Terms[O] 
Symtab &bogus_symbol; 
maketab( 157, hash_funct, strcmp ); 
strncpy( Sp->lhs_name, "garbage", NAME MAX); 
LL( Synch = newset () ; ) 
1*----------------------------------------------------------------------*/ 
PUBLIC SYMBOL *make_term( name ) /* Make a terminal symbol */ 
char 
{ *name; 
SYMBOL *p; 
if( !c_identifier(name) 
lerror{NONFATAL, "Token names must be legitimate C identifiers\n"); 
else if( p = findsym(Symtab, name) ) 
lerror(WARNING, "Terminal symbol <%s> already declared\n", name ); 
else 
{ 
if( Cur_term >= MAXTERM ) 
lerror(FATAL, "Too many terminal symbols {%d max.) .\n", MAXTERM ); 
p = (SYMBOL*) newsym( sizeof(SYMBOL) ); 
strncpy ( p->name, name, NAME MAX); 
strncpy ( p->field, Field_name, NAME MAX); 
addsym { Symtab, p ); 
p->val 
p->set ++Cur term 
yylineno; 
Terms[Cur_term] = p; 
return p; 
!*----------------------------------------------------------------------*/ 
PRIVATE c_identifier( name ) 
char 
{ *name; 
if( isdigit( *name ) ) 
return 0; 
for(; *name ; ++name ) 
if( ! ( isalnum(*name) I I *name 
return 0; 
return 1; /* Return true only if name is */ 
/* a legitimate C identifier. */ 
, , ) ) 
Section 4.10.1-LLama's Parser 297 
Listing 4.26. continued ... 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 418 
419 
420 
421 
422 
423 
424 
425 
426 
427 428 
429 
430 
431 
432 433 
434 
435 
436 
437 /*----------------------------------------------------------------------*/ 
PUBLIC void 
{ first_sym() 
/* 
* 
*I This routine is called just before the first rule following the 
%%. It's used to point out the goal symbol; 
Goal_symbol_is_next 1; 
/*----------------------------------------------------------------------*/ 
PUBLIC SYMBOL *new_nonterm( name, is lhs 
char 
int *name; 
is_lhs; 
/* Create, and initialize, a new nonterminal. is_lhs is used to 
* differentiate between implicit and explicit declarations. It's 0 if the 
* nonterminal is added because it was found on a right-hand side. It's 1 if 
* the nonterminal is on a left-hand side. 
* * Return a pointer to the new symbol or NULL if an attempt is made to use a 
* terminal symbol on a left-hand side. 
*I 
SYMBOL *p; 
if( p = (SYMBOL *) findsym( Symtab, name ) ) 
{ 
if ( ! ISNONTERM ( p ) ) 
{ 
lerror(NONFATAL, "Symbol on left-hand side must be nonterminal\n"); 
p = NULL; 
else if( Cur_nonterm >= MAXNONTERM ) 
{ 
lerror(FATAL, "Too many nonterminal symbols (%d max.) .\n", MAXTERM); 
else /* Add new nonterminal to symbol table */ 
p = (SYMBOL*) newsym( sizeof(SYMBOL) ); 
strncpy ( p->name, name, NAME MAX); 
strncpy ( p->field, Field_name, NAME MAX); 
p->val = ++Cur_nonterm ; 
Terms[Cur_nonterm] = p; 
addsym ( Symtab, p ); 
if( p ) /* (re)initialize new nonterminal */ 
{ 
if( Goal_symbol_is_next 
{ 
Goal_symbol = p; 
Goal_symbol is_next 0; 
.... 
298 Top-Down Parsing-Chapter 4 
Listing 4.26. continued ... 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 if( !p->first 
p->first 
LL ( if ( ! p->follow ) newset(); 
LL( p->follow = newset(); 
p->lineno = yylineno 
if ( is_lhs ) 
{ 
strncpy( Sp->lhs_name, name, NAME MAX); 
Sp->lhs p ; 
Sp->rhs NULL; 
Sp->lhs->set yylineno; 
return p; 
1*----------------------------------------------------------------------*l 
PUBLIC void new_rhs() 
{ 
I* Get a new PRODUCTION and link it to the head of the production chain. 
*of the current nonterminal. Note that the start production MUST be 
*production 0. As a consequence, the first rhs associated with the first 
* nonterminal MUST be the start production. Num_productions is initialized 
* to 0 when it's declared. 
*I 
PRODUCTION *p; 
if( ! (p = (PRODUCTION*) calloc(l, sizeof(PRODUCTION))) 
lerror(FATAL, "Out of memory\n"); 
p->next 
Sp->lhs->productions Sp->lhs->productions; 
p; 
LL( p->select = newset(); 
if( (p->num = Num_productions++) >= MAXPROD 
lerror(FATAL, "Too many productions (%d max.)\n", MAXPROD ); 
p->lhs 
Sp->rhs Sp->lhs; 
p; 
1*----------------------------------------------------------------------*l 
PUBLIC void add_to_rhs( object, is_an_action ) 
char *object; 
int is_an_action; I* 0 of not an action, line number otherwise *I 
SYMBOL *p; 
PRODUCTION *prod; 
int i; 
char bu£[32]; 
Section 4.1 0.1 -LLama's Parser 299 
Listing 4.26. continued ... 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 
508 
509 
510 
511 
512 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 /* Add a new element to the RHS currently at top of stack. First deal with 
* forward references. If the item isn't in the table, add it. Note that, 
* since terminal symbols must be declared with a %term directive, forward 
* references always refer to nonterminals or action items. When we exit the 
* if statement, p points at the symbol table entry for the current object. 
*I 
if( ! (p = (SYMBOL*) findsym( Symtab, object)) ) /*not in tab yet*/ 
{ 
if( !is an action 
{ 
else 
{ if( ! (p = new_nonterm( object, 0 )) ) 
{ 
/* Won't get here unless p is a terminal symbol */ 
lerror(FATAL, "(internal) Unexpected terminal symbol\n"); 
return; 
/*Add an action. All actions are named "{DDD}" where DDD is the 
* action number. The curly brace in the name guarantees that this 
* name won't conflict with a normal name. I am assuming that calloc 
* is used to allocate memory for the new node (ie. that it's 
*initialized to zeros). 
*I 
sprintf(buf, "{%d}", ++Cur_act- MINACT ); 
p = (SYMBOL*) newsym( sizeof(SYMBOL) ); 
strncpy ( p->name, buf, NAME MAX); 
addsym ( Symtab, p ); 
p->val 
p->lineno Cur act 
is an action 
if( ! (p->string = strsave(object)) 
lerror(FATAL, "Insufficient memory to save action\n"); 
p->used = yylineno; 
if( (i = Sp->rhs->rhs_len++) >= MAXRHS ) 
lerror(NONFATAL, "Right-hand side too long (%d max)\n", MAXRHS ); 
else 
{ 
LL( if( i == 0 && p == Sp->lhs 
LL( lerror(NONFATAL, "Illegal left recursion in production.\n") ;) 
OX( if( ISTERM( p ) ) ) 
OX( Sp->rhs->prec Precedence[ p->val ] .level ; ) 
Sp->rhs->rhs[ i 
Sp->rhs->rhs[ i + 1 
if ( ! ISACT (p) p; 
NULL; 
++( Sp->rhs->non acts ); /* NULL terminate the array. */ 
300 Top-Down Parsing-Chapter 4 
Listing 4.26. continued ... 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 /*----------------------------------------------------------------------
* The next two subroutines handle repeating or optional subexpressions. The 
* following mappings are done, depending on the operator: 
* 
* s : A [B) c ; s -> A 001 c 
* 001 -> B I epsilon 
* * s A [B)* C ; s -> A 001 c (aces) 
* 001 -> 001 B I epsilon 
* 
* s A [B)* C ; s -> A 001 c (llama) 
* 001 -> B 001 I epsilon 
* 
* In all situations, the right hand side that we've collected so far is 
* pushed and a new right-hand side is started for the subexpression. Note that 
* the first character of the created rhs name (001 in the previous examples) 
* is a space, which is illegal in a user-supplied production name so we don't 
* have to worry about conflicts. Subsequent symbols are added to this new 
* right-hand side. When the ), }, or *) is found, we finish the new right-hand 
* side, pop the stack and add the name of the new right-hand side to the 
* previously collected left-hand side. 
*I 
PUBLIC void start_opt( lex ) 
char *lex; 
char name[32], *tname; 
static int num = 0; 
--Sp; 
sprintf( name, "%06d", num++); 
new_nonterm( name, 1 ) ; 
new_rhs(); 
new_rhs (); /* Start an optional subexpression */ 
/* Push current stack element *I 
/* Make name for new production */ 
/* Create a nonterminal for it. */ 
/* Create epsilon production. */ 
/* and production for sub-prod. */ 
/*- - - - - - - - - - - - - - - - - - - - - - - - */ 
PUBLIC void end_opt( lex 
char 
{ *lex; 
char *name Sp->lhs_name 
SYMBOL *p; 
int i; 
if ( lex [ 1] == ' *' 
{ 
add to rhs( name, 0 ); 
#ifdef occs 
i = Sp->rhs->rhs len -1; 
p = Sp->rhs->rhs[ i ]; /* end optional subexpression */ 
/*Process a [ ... }* *I 
/* Add right-recursive reference. */ 
/* If aces, must be left recursive.*/ 
/* Shuffle things around. */ 
memmove ( & (Sp->rhs->rhs) [1], & (Sp->rhs->rhs) [0], 
#endif 
} Sp->rhs->rhs[ 0 ] = p ; i * sizeof( (Sp->rhs->rhs) [1] ) ) ; 
Section 4.10.1-LLama's Parser 301 
Listing 4.26. continued ... 
616 
617 
618 
619 
620 
621 
622 
623 
624 
625 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 
638 
639 
640 
641 
642 
643 
644 
645 
646 
647 
648 
649 
650 
651 
652 
653 
654 
655 
656 
657 658 
659 
660 
661 
662 
663 
664 
665 
666 
667 
668 
669 
670 
671 
672 
673 
674 ++Sp; /* discard top-of-stack element */ 
add_to_rhs( name, 0 ); 
/*====================================================================== 
* The following routines have alternate versions, one set for llama and another 
* for aces. The routines corresponding to features that aren't supported in one 
* or the other of these programs print error messages. 
*I 
#ifdef LLAMA 
PUBLIC void add_synch( name ) 
char *name; 
{ 
/* Add "name" to the set of synchronization tokens 
*I 
SYMBOL *p; 
if( ! (p (SYMBOL*) findsym( Symtab, name )) ) 
lerror(NONFATAL,"%%synch: undeclared symbol <%s>.\n", name ) ; 
else if( !ISTERM(p) ) 
lerror(NONFATAL,"%%synch: <%s> not a terminal symbol\n", name ) ; 
else 
ADD( Synch, p->val ); 
/* - - - - - - - - - - - - - - - - - - - - - */ 
PUBLIC void new_lev( how 
{ 
switch( how ) 
{ 
case 0 /* initialization: 
case I 1': lerror (NONFATAL, 
case 'r': lerror (NONFATAL, ignore 
"%%left 
"%%right it *I 
not recognized by LLAMA\n" ) ; 
not recognized by LLAMA\n" ) ; 
default lerror (NONFATAL, "%%nonassoc not recognized by LLAMA\n"); 
} 
PUBLIC void prec( name ) 
char *name; 
lerror( NONFATAL, "%%prec not recognized by LLAMA\n" ); 
PUBLIC void union_def( action ) 
char 
{ *action; 
lerror(NONFATAL,"%%union not recognized by LLAMA\n"); 
PUBLIC void prec_list( name) char *name; 
{ 
} break; 
break; 
break; 
break; 
.... 
302 Top-Down Parsing-Chapter 4 
Listing 4.26. continued ... 
675 
676 
677 
678 
679 
680 
681 
682 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 
719 
720 
721 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 PUBLIC void new field( field name 
char 
{ *field_ name; 
if( *field_name ) 
lerror(NONFATAL, "<name> not supported by LLAMA\n"); 
PUBLIC make_nonterm(name) 
char *name; 
{ 
lerror(NONFATAL, "%type not supported by LLAMA\n"); 
#else 1*============================================================*1 
PUBLIC void add_synch(yytext) 
char *yytext; 
{ 
lerror(NONFATAL, "%%synch not supported by OCCS\n"); 
I* - - - - - - - - - - - - - - - - - - - - - - *I 
PUBLIC void new_lev( how 
{ 
I* I* Increment the current precedence level and modify "Associativity" 
* to remember if we're going left, right, or neither. 
*I 
if( Associativity 
++Prec_lev; how ) I* '1', 'r', 'n', (0 if unspecified) *I 
- - - - - - - - - - - - - - - - - - - - - - - *I 
PUBLIC void prec_list( name ) 
char 
{ *name; 
I* Add current name (in yytext) to the precision list. "Associativity" is 
*set to '1', 'r', or 'n', depending on whether we're doing a %left, 
* %right, or %nonassoc. Also make a nonterminal if it doesn't exist 
* already. 
*I 
SYMBOL *sym; 
if( ! (sym = findsym(Symtab,name)) 
sym = make_term( name); 
if ( ! ISTERM (sym) ) 
lerror(NONFATAL, "%%left or %%right, %s must be a token\n", name ) ; 
else 
{ 
Precedence[ sym->val ] .level 
Precedence[ sym->val ] .assoc Prec_lev ; 
Associativity 
Section 4.10.1-LLama's Parser 303 
Listing 4.26. continued ... 
733 
734 
735 
736 
737 
738 
739 
740 
741 
742 
743 
744 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 
757 
758 
759 760 
761 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
779 780 
781 
782 783 
784 
785 
786 
787 
788 789 
790 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PUBLIC void prec( name 
char *name; 
/* Change the precedence level for the current right-hand side, using 
* (1) an explicit number if one is specified, or (2) an element from the 
* Precedence[] table otherwise. 
*I 
SYMBOL *sym; 
if( isdigit(*name) 
Sp->rhs->prec = atoi (name); /* (1) *I 
else 
{ 
if( ! (sym = findsym(Symtab,name)) 
lerror(NONFATAL, "%s (used in %%prec) undefined\n" ); 
elseif( !ISTERM(sym)) 
lerror(NONFATAL, "%s (used in %%prec) must be terminal symbol\n" ) ; 
else 
Sp->rhs->prec Precedence[ sym->val ] .level; /* (2) */ 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PUBLIC void union_def( action ) 
char 
{ *action; 
/* 
* 
* 
* create a YYSTYPE definition for the union, using the fields specified 
in the %union directive, and also appending a default integer-sized 
field for those situation where no field is attached to the current 
symbol. 
*I 
while( *action && *action != '{' ) 
++action; 
if( *action ) 
++action; 
output( "typedef union\n" ); /* Get rid of everything up to the */ 
/* open brace */ 
/* and the brace itself */ 
output( "{\n" ) ; 
output ( " int %s; /* Default field, used when no %%type found */", 
DEF FIELD); 
output ( "%s\n", action ) ; 
output( "yystype;\n\n" ); 
output( "#define YYSTYPE yystype\n" ); 
Fields active = 1; 
PUBLIC fields_active() 
{ 
return Fields active /* previous %union was specified */ 
304 Top-Down Parsing-Chapter4 
Listing 4.26. continued ••• 
791 
792 
793 
794 
795 
796 
797 
798 
799 
800 
801 
802 
803 
804 
805 
806 
807 808 
809 
810 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PUBLIC 
char void new field( field name 
*field_name; 
{ 
/* Change the name of the current <field> */ 
char *p; 
if( !*field_name 
*Field name= '\0' 
else 
if( p = strchr(++field_name, '>') ) 
*p = I \0' ; 
strncpy( Field_name, field name, sizeof(Field_name) ); 
#endif 
4.1 0.2 Creating The Tables 
The next step is to create the parse tables from the grammar we just assembled, and 
the LL( I) select sets are needed to do this. 
4.1 0.2.1 Computing FIRST, FOLLOW, and SELECT Sets. LLama starts by 
creating the FIRST sets, using the code in Listing 4.27, which implements the algorithm 
described earlier. The subroutine first (),on line 21, figures the FIRST sets for all the 
nonterminals in the symbol table. The ptab () call on line 30 traverses the table, calling 
first_closure () (on line 37) for every table element (ptab () is one of the hash 
functions described in Appendix A). Multiple passes are made through the table, until 
nothing is added to any symbol's FIRST set. 
The first_ rhs () subroutine on line 97 computes the first set for an entire right­
hand side, represented as an array of SYMBOL pointers. (They're stored this way in a 
PRODUCTION structure). first_ rhs () won't work if called before first(). 
The subroutines in Listing 4.28 compute FOLLOW sets for all nonterminals in 
LLama's symbol table, again using the procedure described earlier in this Chapter. 
Finally, LLama uses the FIRST and FOLLOW sets to create the LL(I) selection sets in 
Listing 4.29. 
4.1 0.3 The Rest of LLama 
The remainder of LLama is Listings 4.30. to 4.37. All that they do is print out the 
tables, and so forth. They are adequately commented and need no further description 
here. 
Section 4.1 0.3-The Rest of LLama 
Listing 4.21.first.c- Find FIRST Sets 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/* FIRST.C Compute FIRST sets for all productions in a symbol table. *-------------------------------------------------------------------------
*I 
int 
void 
int first closure 
first 
first rhs P(( SYMBOL *lhs )); /*local*/ 
P((void)); /*public*/ 
P(( SET *dest, SYMBOL **rhs, int len)); 
PRIVATE int Did_something; 
/*----------------------------------------------------------------------*/ 
PUBLIC void first( ) 
{ 305 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 /* Construct FIRST sets for all nonterminal symbols in the symbol table. */ 
D( printf("Finding FIRST sets\n"); ) 
do 
{ 
Did_something = 0; 
ptab( Symtab, first_closure, NULL, 0 ); 
while( Did_something ); 
/*----------------------------------------------------------------------*/ 
PRIVATE first_closure( lhs ) 
SYMBOL *lhs; /* Current left-hand side *I 
{ 
/* Called for every element in the FIRST sets. Adds elements to the first 
* sets. The following rules are used: 
* * 1) given lhs-> ... Y ... where Y is a terminal symbol preceded by any number 
* (including 0) of nullable nonterminal symbols or actions, add Y to 
* FIRST(x). 
* * 2) given lhs-> ... y ... where y is a nonterminal symbol preceded by any 
* number (including 0) of nullable nonterminal symbols or actions, add 
* FIRST(y) to FIRST(lhs). 
*I 
PRODUCTION *prod; 
SYMBOL **y; 
static SET *set NULL; 
int i; 
if( !ISNONTERM(lhs) 
return; /* Pointer to one production side */ 
/* Pointer to one element of production */ 
/* Scratch-space set. */ 
/* Ignore entries for terminal symbols */ 
306 Top-Down Parsing-Chapter 4 
Listing 4.27. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 if ( ! set /* Do this once. The set isn't free()d */ 
set= newset(); 
ASSIGN( set, lhs->first ); 
for( prod = lhs->productions; prod 
{ 
if( prod->non_acts <= 0 ) 
{ 
ADD( set, EPSILON); 
continue; prod prod->next ) 
/* No non-action symbols */ 
/* add epsilon to first set */ 
for( y = prod->rhs, i 
{ prod->rhs_len; --i >= 0; y++ 
if ( ISACT ( *y 
continue; /* pretend acts don't exist */ 
if( ISTERM( *y ) ) 
ADD ( set, (*y) ->val ) ; 
else if ( *y ) /* it's a nonterminal */ 
UNION ( set, (*y) ->first ) ; 
if ( ! NULLABLE ( *y ) ) 
break; /* it's not a nullable nonterminal */ 
if( !IS_EQUIVALENT(set, lhs->first) 
{ 
ASSIGN( lhs->first, set); 
Did_something = 1; 
/*----------------------------------------------------------------------*/ 
PUBLIC int first_rhs( dest, rhs, len ) 
SET *dest; /* Target set */ 
SYMBOL **rhs; /* A right-hand side */ 
int len; /* # of objects in rhs */ 
/* Fill the destination set with FIRST(rhs) where rhs is the right-hand side 
* of a production represented as an array of pointers to symbol-table 
* elements. Return 1 if the entire right-hand side is nullable, otherwise 
* return 0. 
*I 
if ( len <= 0 ) 
{ 
ADD( dest, EPSILON); 
return 1; 
for(; --len >= 0 ; ++rhs ) 
{ 
if( ISACT( rhs[O] ) ) 
continue; 
.... 
Section 4.1 0.3-The Rest of LLama 
Listing 4.27. continued •.• 
119 if( ISTERM( rhs [0] ) 
120 ADD( dest, rhs[O]->val ); 
121 else 
122 UNION( dest, rhs[O]->first ); 
123 
124 if( !NULLABLE( rhs[O] ) ) 
125 break; 
126 
127 
128 return ( len < 0 ) ; 
129 
Listing 4.28.follow.c- Find FOLLOW Sets 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
#include "llout.h" 
/* FOLLOW.C 
* 
* Compute FOLLOW sets for all productions in a 
symbol table. The FIRST sets must be computed 
before follow() is called. 
*I 
int 
int 
void 
void follow closure 
remove_epsilon 
in it 
follow P(( SYMBOL *lhs )); 
P(( SYMBOL *lhs )); 
P(( SYMBOL *lhs )); 
P ( ( void ) ) ; I* local */ 
/* public */ 
/*----------------------------------------------------------------------*/ 
PRIVATE int Did_something; 
/*----------------------------------------------------------------------*/ 
PUBLIC void follow() 
{ 
D( int pass= 0; 
D( printf( "Initializing FOLLOW sets\n" ) ; ) 
ptab( Symtab, init, NULL, 0 ) ; 
do 307 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 /* This loop makes several passes through the entire grammar, adding 
*FOLLOW sets. The follow_closure() routine is called for each grammar 
* symbol, and sets Did_something to true if it adds any elements to 
* existing FOLLOW sets. 
*I 
D( printf( "Closure pass %d\n", ++pass ) ; 
D( fprintf( stderr, "%d\n", pass); 
.... 
308 Top-Down Parsing-Chapter 4 
Listing 4.28. continued ... 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 Did_something = 0; 
ptab( Symtab, follow_closure, NULL, 0 ); 
while( Did_something ); 
I* This last pass is just for nicety and could probably be eliminated (may 
* as well do it right though). Strictly speaking, FOLLOW sets shouldn't 
* contain epsilon. Nonetheless, it was much easier to just add epsilon in 
* the previous steps than try to filter it out there. This last pass just 
* removes epsilon from all the FOLLOW sets. 
*I 
ptab( Symtab, remove_epsilon, NULL, 0 ); 
D( printf("Follow set computation done\n"); 
1*----------------------------------------------------------------------*l 
PRIVATE void init( lhs 
SYMBOL *lhs; I* Current left-hand side *I 
( 
I* Initialize the FOLLOW sets. This procedure adds to the initial follow set 
* of each production those elements that won't change during the closure 
* process. Note that in all the following cases, actions are just ignored. 
* * (1) FOLLOW(start) contains end of input ($). 
* * (2) Given s-> ... xY ... where xis a nonterminal andY is 
* a terminal, add Y to FOLLOW(x). x andY can be separated 
* by any number (including 0) of nullable nonterminals or actions. 
* * (3) Given x-> ... xy ... where x andy are both nonterminals, 
* add FIRST(y) to FOLLOW(x). Again, x andy can be separated 
* by any number of nullable nonterminals or actions. 
*I 
PRODUCTION *prod; 
SYMBOL **x; I* Pointer to one production *I 
I* Pointer to one element of production *I 
SYMBOL **y; 
D( printf("%s:\n", lhs->name); 
if ( ! I SNONTERM ( lhs) 
return; 
if( lhs == Goal symbol ) 
{ 
D( printf( "\tAdding EOI to FOLLOW(%s)\n", lhs->name ); ) 
ADD( lhs->follow, EOI ); 
for( prod= lhs->productions; prod ; prod 
{ 
for( x = prod->rhs ; *x 
{ x++ ) 
if ( ISNONTERM ( *x) ) 
{ 
for( y = x + 1 ; *y 
{ ++y ) prod->next ) 
Section 4.1 0.3-The Rest of LLama 
Listing 4.28. continued ... 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 147 
148 
149 
!50 
!51 
!52 
!53 
!54 
!55 
!56 
!57 
!58 
!59 
160 
161 if ( ISACT ( *y) 
continue; 
if( ISTERM(*y) 
{ 
D( printf("\tAdding %s ", 
D( printf("to FOLLOW(%s)\n", (*y)->name ); 
(*x) ->name ) ; 
ADD ( ( *x) ->follow, ( *y) ->val ) ; 
break; 
else 
{ 
UNION ( (*x) ->follow, (*y) ->first ) ; 
if ( ! NULLABLE ( *y) ) 
break; 
/*----------------------------------------------------------------------*/ 
PRIVATE follow_closure( lhs ) 
SYMBOL *lhs; 
{ /* Current left-hand side *I 
/* Adds elements to the FOLLOW sets using the following rule: 
* 
* 
* 
*I Given s-> ... x or s-> ... x ... where all symbols following 
x are nullable nonterminals or actions, add FOLLOW(s) to FOLLOW(x). 
PRODUCTION *prod; /* Pointer to one production side */ 
/* Pointer to one element of production */ SYMBOL **x, **y 
D( printf("%s:\n", lhs->name ) ; 
if( ISACT(lhs) II ISTERM(lhs) ) 
return; 
for( prod = lhs->productions; prod ; prod = prod->next ) 
{ 
for( x = prod->rhs + prod->rhs len; --x >= prod->rhs 
{ 
if ( I SACT ( * x) 
continue; 
if ( IS TERM ( *x) 
break; 
if ( ! subset ( ( *x) ->follow, lhs->follow ) ) 
{ 
D( printf("\tAdding FOLLOW(%s) ", lhs->name ); 
D( printf("to FOLLOW(%s)\n", (*x)->name ); 
UNION( (*x)->follow, lhs->follow ); 
Did_something = 1; 309 
.... 
310 Top-Down Parsing-Chapter 4 
Listing 4.28. continued ... 
162 
163 if( ! NULLABLE(*x) 
164 break; 
165 
166 
167 
168 
169 /*----------------------------------------------------------------------*/ 
170 
171 PRIVATE remove_epsilon( lhs ) 
172 SYMBOL *lhs; 
173 { 
174 /* Remove epsilon from the FOLLOW sets. The presence of epsilon is a 
175 * side effect of adding FIRST sets to the FOLLOW sets willy nilly. 
176 *I 
177 
178 if ( I SNONTERM ( lhs) ) 
179 REMOVE( lhs->follow, EPSILON); 
180 
Listing 4.29. llselect.c- Find LL( 1) Select Sets 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/* LLSELECT.C 
* 
* * Compute LL(l) select sets for all productions in a 
symbol table. The FIRST and FOLLOW sets must be computed 
before select() is called. These routines are not used 
by aces. 
*I 
/*----------------------------------------------------------------------*/ 
void find select set 
void select P(( SYMBOL *lhs )); 
P(( void )); /* local */ 
/* public */ 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
SYMBOL *lhs; 
{ find_select_set( lhs ) 
/* left-hand side of production */ 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 /* Find the LL(l) selection set for all productions attached to the 
*indicated left-hand side (lhs). The first_rhs() call puts the FIRST sets 
* for the initial symbols in prod->rhs into the select set. It returns true 
* only if the entire right-hand side was nullable (EPSILON was an element 
* of the FIRST set of every symbol on the right-hand side. 
*I 
PRODUCTION *prod; 
.... 
Section 4.1 0.3-The Rest of LLama 
Listing 4.29. continued ... 
35 for( prod = lhs->productions; prod ; prod = prod->next ) 
36 { 
37 if( first_rhs( prod->select, prod->rhs, prod->rhs_len) ) 
38 UNION( prod->select, lhs->follow ); 
39 
40 REMOVE( prod->select, EPSILON); 
41 
42 
43 
44 /*----------------------------------------------------------------------*/ 
45 
46 PUBLIC void select( 
47 { 
48 /* Compute LL(1) selection sets for all productions in the grammar */ 
49 
50 if( Verbose ) 
51 printf("Finding LL(l) select sets\n"); 
52 
53 ptab( Symtab, find select_set, NULL, 0 ); 
54 
Listing 4.30.llcode.c- Routines That Make the Parse Tables 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <stdlib.h> 
#include <ctype.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
LLCODE.C Print the various tables needed for a llama-generated 
LL(1) parser. The generated tables are: 311 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 /* 
* 
* 
* * * * 
* 
* * * * 
* 
* 
* 
* 
* 
* 
* 
* 
* * 
* Yyd[] [] The parser state machine's DFA transition table. The 
horizontal axis is input symbol and the vertical axis is 
top-of-stack symbol. Only nonterminal TOS symbols are in 
the table. The table contains the production number of a 
production to apply or -1 if this is an error 
transition. 
YydN[ 1 
Yy_pushtab [ 1 
YypDD[ 1 
Yy_snonterm[ 1 
Yy_sact [ 1 
Yy_synch [ 1 
yy_act () (N is 1-3 decimal digits). Used for compressed tables 
only. Holds the compressed rows. 
Indexed by production number, evaluates to a list of 
objects to push on the stack when that production is 
replaced. The YypDD arrays are the lists of objects 
and Yy_pushtab is an array of pointers to those lists. 
For debugging, indexed by nonterminal, evaluates to the 
name of the nonterminal. 
Same but for the acts. 
Array of synchronization tokens for error recovery. 
Subroutine containing the actions. 
312 Top-Down Parsing -Chapter 4 
Listing 4.30. continued ... 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 * * Yy_stok[] is make in stok.c. For the most part, the numbers in these tables 
* are the same as those in the symbol table. The exceptions are the token 
* values, which are shifted down so that the smallest token has the value 1 
* (0 is used for EOI). 
*I 
#define DTRAN "Yyd" /* Name of DFA transition table 
/* array in the PARSE_FILE. 
/*----------------------------------------------------------------------*/ 
extern void tables p ( ( void ) ) ; /* public *I 
*I 
*I 
static void fill row p ( ( SYMBOL *lhs, void *junk ) ) ; /* local *I 
static void make_pushtab p ( ( SYMBOL *lhs, void *junk ) ) ; 
static void make_yy_pushtab p ( ( void ) ) ; 
static void make _yy_dtran p ( ( void ) ) ; 
static void make _yy synch p ( ( void ) ) ; 
static void make _yy_ snonterm p ( ( void ) ) ; 
static void make _yy_ sact p ( ( void ) ) ; 
static void make acts p ( ( SYMBOL *lhs,void *junk ) ) ; 
static void make _yy act p ( ( void ) ) ; 
/*----------------------------------------------------------------------*/ 
PRIVATE int *Dtran; /* Internal representation of the parse table. 
* Initialization in make_yy_dtran() assumes 
*that it is an int [it calls memiset()]. 
*I 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ tables () 
/* Print the various tables needed by the parser. */ 
make_yy_pushtab(); 
make_yy_dtran(); 
make yy_act(); 
make yy_synch(); 
make_yy_stok(); 
make_token file(); 
output( "\n#ifdef YYDEBUG\n"); 
make yy snonterm(); 
make_yy sact(); 
output( "\n#endif\n" ) ; 
/*----------------------------------------------------------------------
* fill_row() 
* 
* 
* 
* 
* 
* 
* 
* Make one row of the parser's DFA transition table. 
Column 0 is used for the EOI condition; other columns 
are indexed by nonterminal (with the number normalized 
for the smallest nonterminal). That is, the terminal 
values in the symbol table are shifted downwards so that 
the smallest terminal value is 1 rather than MINTERM. 
The row indexes are adjusted in the same way (so that 
Section 4.1 0.3-The Rest of LLama 
Listing 4.30. continued ... 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 * row 0 is used for MINNONTERM) . 
* 
* Note that the code assumes that Dtran consists of byte-size 
* cells. 
*I 
PRIVATE void 
SYMBOL *lhs; 
void 
{ *junk; fill_row( lhs, junk ) 
PRODUCTION *prod; 
int *row; 
int i; 
int rowsize; 
if( !ISNONTERM(lhs) 
return; 
USED_TERMS + 1; /* Current left-hand side *I 
rowsize 
row Dtran + ((i = ADJ_VAL(lhs->val)) * rowsize ); 
for( prod = lhs->productions; prod ; prod = prod->next ) 
{ 
next_member( NULL); 
while( (i = next_member(prod->select)) >= 0 ) 
{ 
if( row[i] == -1 ) 
row[i] = prod->num; 
else 
error(NONFATAL, "Grammar not LL(1), select-set conflict in"\ 
"<%s>, line %d\n", lhs->name, lhs->lineno ); 
/*----------------------------------------------------------------------*! 
PRIVATE void 
SYMBOL *lhs; 
void *junk; make_pushtab( lhs, junk ) 
/* Make the pushtab. The right-hand sides are output in reverse order 
* (to make the pushing easier) by stacking them and then printing 
* items off the stack. 
*I 
register int 
PRODUCTION 
SYMBOL 
SYMBOL i 
*prod 
**sym 
*stack[ MAXRHS ], **sp; 
sp = &stack[-1] 
for( prod = lhs->productions ; prod ; prod= prod->next 
{ 
output ( "YYPRIVATE int Yyp%02d [] = { ", prod->num ) ; 
for( sym = prod->rhs, i = prod->rhs_len ; --i >= 0 ;) 
*++sp = *sym++ ; 313 
314 Top-Down Parsing-Chapter 4 
Listing 4.30. continued ... 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 for(; INBOUNDS(stack,sp) output ("%d, ", {*sp--) ->val) ) 
output ( "0 } ; \n", prod->rhs [0] ) ; 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void 
( make_yy_pushtab() 
/* Print out yy_pushtab. */ 
register int 
register int i; 
maxprod 
*text [] Num_productions -1; 
static char 
( 
} ; "The YypNN arrays hold the right-hand sides of the productions, listed", 
"back to front (so that they are pushed in reverse order), NN is the", 
"production number (to be found in the symbol-table listing output", 
"with a -s command-line switch).", 
1111 , 
"Yy_pushtab[] is indexed by production number and points to the", 
"appropriate right-hand side (YypNN) array.", 
NULL 
comment( Output, text ); 
ptab ( Symtab, make_pushtab, NULL, 0 ); 
output( "\nYYPRIVATE int *Yy_pushtab[] =\n{\n"); 
for( i 0; i < maxprod; i++ ) 
output( "\tYyp%02d,\n", i ); 
output( "\tYyp%02d\n};\n", maxprod ); 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
{ make_yy_dtran( ) 
/* Print the DFA transition table. */ 
register int i; 
int nterms, nnonterms; 
static char *text[] 
{ 
"Yyd[] [] is the DFA transition table for the parser. It is indexed", 
"as follows:", .... , 
" , Input symbol", 
+----------------------+'', 
L Production number 1", 
H or YYF 1", 
s I", 
+----------------------+'', 
"The production number is used as an index into Yy_pushtab, which", 
"looks like this:", 
Section 4.1 0.3-The Rest of LLama 
Listing 4.30. continued ... 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 } ; .... , 
" 
" 
" 
.... , Yy_pushtab YypDD: ", 
+-------+ +----------------+'', 
*---1------>1 1", 
+-------+ 
*---1---->", 
+-------+", *---1---->", 
+-------+", +----------------+'', 
"YypDD is the tokenized right-hand side of the production.", 
"Generate a symbol table listing with llama's -1 command-line", 
"switch to get both production numbers and the meanings of the", 
"YypDD string contents.", 
NULL 
nterms 
nnonterms USED_TERMS + 1; 
USED_NONTERMS; /* +1 for EOI */ 
i = nterms * nnonterms; /* Number of cells in array */ 
if( ! (Dtran = (int *) malloc(i * sizeof(*Dtran)) )) /*number of bytes*/ 
ferr("Out of memory\n"); 
memiset( Dtran, -1, i ); /* Initialize Dtran to all failures */ 
/* and fill nonfailure transitions. */ ptab( Symtab, fill row, NULL, 0 ) ; 
comment( Output , text ); /* Print header comment */ 
if( Uncompressed ) 
{ 
else fprintf( Output,"YYPRIVATE YY TTYPE %s[ %d ] [ %d ] =\n", 
DTRAN, nnonterms, nterms ); 
print_array( Output, Dtran, nnonterms, nterms ); 
defnext (Output, DTRAN ); 
if( Verbose ) 
printf("%d bytes required for tables\n", i * sizeof(YY_TTYPE) ); 
i pairs( Output, Dtran, nnonterms, nterms, DTRAN, Threshold, 1); 
pnext( Output, DTRAN ); 
if( Verbose ) 
printf ("%d bytes required for compressed tables\n", 
(i * sizeof(YY_TTYPE)) + (nnonterms * sizeof(YY TTYPE*))); 
output("\n\n"); 
/*----------------------------------------------------------------------*/ 
PRIVATE void make yy_ synch () 
{ 
int mem /* current member of synch set *I 
int i; /* number of members in set *I 315 
316 Top-Down Parsing-Chapter 4 
Listing 4.30. continued ... 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 static char *text[] = 
{ 
"Yy_synch[] is an array of synchronization tokens. When an error is", 
"detected, stack items are popped until one of the tokens in this", 
"array is encountered. The input is then read until the same item is", 
"found. Then parsing continues.", 
NULL 
} ; 
comment( Output, text ); 
output( "YYPRIVATE int Yy_synch[] =\n{\n" ); 
i = 0; 
for( next_member(NULL); (mem = next_member(Synch)) >= 0 ;) 
{ 
output( "\t%s,\n", Terms[mem]->name); 
++i; 
if( i == 0 ) 
output( "\t_EOI \n" ); 
output( "\t-1\n};\n" ) ; 
next_member( NULL); /* No members in synch set *I 
!*----------------------------------------------------------------------*/ 
PRIVATE void make_yy_snonterm() 
{ 
register int i; 
static char *the_comment[] 
{ 
"Yy snonterm[] is used only for debugging. It is indexed by the", 
"tokenized left-hand side (as used for a row index in Yyd[]) and", 
"evaluates to a string naming that left-hand side.", 
NULL 
} ; 
comment( Output, the_comment ); 
output( "char *Yy_snonterm[] =\n{\n"); 
for( i = MINNONTERM; i <= Cur_nonterm; i++ 
{ 
if( Terms[i] 
output( "\t/* %3d*/ 
if( i != Cur nonterm 
outc( ',' 
outc( '\n' ); 
output( "};\n\n" ); \"%s\"", i, Terms[i]->name ); 
Section 4.1 0.3-The Rest of LLama 317 
Listing 4.30. continued ... 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 388 
389 
390 
391 /*----------------------------------------------------------------------*/ 
PRIVATE void 
{ make yy _ sact () 
/* This subroutine generates the subroutine that implements the actions. */ 
register int i; 
static char *the_comment[] = 
{ 
"Yy sact[] is also used only for debugging. It is indexed by the", 
"internal value used for an action symbol and evaluates to a string", 
"naming that token symbol.", 
NULL 
} ; 
comment( Output, the_comment ) ; 
output("char *Yy_sact[] =\n{\n\t" ); 
if( Cur_act < MINACT ) 
output("NULL /*There are no actions */"); 
else 
for( i = MINACT; i <= Cur_act; i++ ) 
{ 
output( "\"{%d}\"%c", i-MINACT, 
if ( i % l 0 == 9 ) 
output ("\n\t"); 
output("\n};\n"); i < Cur act ? ' ' ' , , ) ; 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
SYMBOL *lhs; 
void 
{ *junk; make acts( lhs, junk ) 
/* Current left-hand side */ 
/* This subroutine is called indirectly from yy_act, through the subroutine 
* ptab(). It prints the text associated with one of the acts. 
*I 
char *p; 
int num; 
char *do_dollar(); 
char fname[80], *fp; 
int i; 
if( !lhs->string 
return; /* The N in $N */ 
output ( case %d:\n", lhs->val ) ; 
if ( No lines 
output( "\t\t" ); 
else 
output( "#line %d \"%s\"\n\t\t", lhs->lineno, Input file_name ) ; 
for( p = lhs->string ; *p ; ) 
{ 
318 Top-Down Parsing-Chapter 4 
Listing 4.30. continued ... 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 448 
449 
450 
451 if( *p == '\r' 
continue; 
if( *p != '$' 
output( "%c", *p++ ); 
else 
{ 
/* Skip the attribute reference. The if statement handles $$ the 
* else clause handles the two forms: $N and $-N, where N is a 
*decimal number. When you hit the do_dollar call (in the output() 
* call), "num" holds the number associated with N, or DOLLAR DOLLAR 
* in the case of $$. 
*I 
if( *++p != '<' ) 
*fname = '\0'; 
else 
if( 
{ 
else ++p; /* skip the < */ 
fp = fname; 
for(i=sizeof(fname); --i>O && *p && *p != '>'; *fp++ 
*fp = '\0'; 
if( *p == '>' 
++p; 
*p --'$' ) 
num = DOLLAR _DOLLAR; 
++p; 
num = atoi ( p ) ; 
if ( *p == '-' ) 
++p ; 
while( isdigit(*p) 
++p ; 
output( "%s", do_dollar(num, 0, 0, NULL, fname) ); 
output( "\n break;\n" ); *p++ ) 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void 
{ make _yy _act () 
/*Print all the acts inside a subroutine called yy_act() */ 
static char *comment_text[] 
{ 
"Yy_act() is the action subroutine. It is passed the tokenized value", 
"of an action and executes the corresponding code.", .... 
Section 4.1 0.3-The Rest of LLama 319 
Listing 4.30. continued ... 
NULL 
} ; 
static char *top[] 
"YYPRIVATE int yy_act( actnum )", 
"{", 452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 /* The actions. Returns 0 normally but a nonzero error code can", 
* be returned if one of the acts causes the parser to terminate", 
} ; "" , 
" 
NULL * abnormally.", 
*/", 
switch( actnum )", 
{", 
static char *bottom[] = 
default: printf(\"INTERNAL ERROR: "\ 
"Illegal act number (%s)\\n\", actnum);", 
break;", 
}", 
return 0;", 
"}", 
NULL 
} ; 
comment( Output, comment text 
printv ( Output, top 
ptab ( Symtab, make_acts, NULL, 0 
printv ( Output, bottom ) ; 
) ; 
) ; 
) ; 
Listing 4.31. lldriver.c- Routines That Make Driver Subroutines 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/*----------------------------------------------------------------------*/ 
extern void file header 
extern void code header 
extern void driver P(( void)); 
P ( ( void ) ) ; 
P ( ( void ) ) ; /* public */ 
/*----------------------------------------------------------------------*/ 
PRIVATE FILE *Driver file = stderr ; 
.... 
320 Top-Down Parsing-Chapter 4 
Listing 4.31. continued ... 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 /*----------------------------------------------------------------------
* Routines in this file are llama specific. There's a different version 
* of all these routines in yydriver.c. 
*----------------------------------------------------------------------
*I 
PUBLIC void file_header() 
{ 
/* This header is printed at the top of the output file, before 
* the definitions section is processed. Various #defines that 
* you might want to modify are put here. 
*I 
output( "#include <stdio.h>\n\n" ); 
if( Public ) 
output( "#define YYPRIVATE\n" ) ; 
if( Debug ) 
output( "#define YYDEBUG\n" ); 
output( "\n/*-------------------------------------------*1\n\n"); 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ code_ header () 
/* This header is output after the definitions section is processed, 
* but before any tables or the driver is processed. 
*I 
output( "\n\n/*--------------------------------------*1\n\n"); 
output ( "#include \"%s\"\n\n", TOKEN FILE ) ; 
output( "#define YY MINTERM 
output( "#define YY MAXTERM 
output( "#define YY MINNONTERM 
output( "#define YY MAXNONTERM 
output( "#define YY START STATE 
output( "#define YY MINACT 
output( "\n" 1\n" 
%d\n", 
%d\n", 
%d\n", %d\n", 
%d\n", ) ; 
Cur term ) ; -MINNONTERM ) ; 
Cur nonterm ) ; -MINNONTERM ) ; 
MINACT ) ; 
) ; 
if( ! (Driver file= driver_l(Output, !No_lines, Template) ) ) 
error( NONFATAL, "%s not found--output file won't compile\n", Template); 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ driver() 
/* Print out the actual parser by copying the file llama.par 
* to the output file. 
*I 
driver 2 ( Output, !No_lines ) ; 
fclose( Driver file); 
Section 4.1 0.3-The Rest of LLama 321 
Listing 4.32. stok.c-Routines to Make yyout.handyy stok [) 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 43 
44 
45 
46 
47 
48 
49 
50 
51 
52 53 54 55 56 
57 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/*----------------------------------------------------------------------*/ 
extern void make _yy _ stok P ( ( void ) ) ; 
extern void make token file P ( ( void ) ) ; /* public */ 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ make _yy _ stok () 
/* This subroutine generates the Yy stok[} array that's 
* indexed by token value and evaluates to a string 
* representing the token name. Token values are adjusted 
* so that the smallest token value is 1 (0 is reserved 
*for end of input). 
*/ 
register int i; 
static char *the_comment[] 
{ 
"Yy_stok[] is used for debugging and error messages. It is indexed", 
"by the internal value used for a token (as used for a column index in", 
"the transition matrix) and evaluates to a string naming that token.", 
NULL 
} ; 
comment( Output, the_comment ); 
output ( 
output ( "char 
"\t/* *Yy_stok[] =\n{\n" ); 
0 */ \"_EOI \",\n" ); 
for( i = MINTERM; i <= Cur_term; i++ 
{ 
output( "\t/* %3d*/ 
if( i != Cur term ) 
outc ( ',' ) ; \"%s\"", (i-MINTERM)+l, Terms[i]->name ) ; 
if ( ( i & Oxl l 0 I I i 
outc( '\n' ); 
output( "};\n\n"); Cur term /* Newline for every */ 
/* other element */ 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ make_token_file() 
.... 
322 Top-Down Parsing -Chapter 4 
Listing 4.32. continued ... 
/* This subroutine generates the yytokens.h file. Tokens have 
*the same value as in make_yy_stok(). A special token 
* named EOI (with a value of 0) is also generated. 
*I 
FILE *tokfile; 
int i; 
if ( ! (tokfile = fopen ( TOKEN_FILE , "w") ) ) 
error( FATAL, "Can't open %s\n", TOKEN FILE); 
D( else if( Verbose ) 
D( printf("Generating %s\n", TOKEN_FILE ); 
fprintf( tokfile, "#define EOI 0\n"); 
for( i = MINTERM; i <= Cur term; i++ 
fprintf( tokfile, "#define %-lOs %d\n", 58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 Terms[i]->name, (i-MINTERM)+l ); 
fclose( tokfile ); 
Listing 4.33. main.c- Command-Line Parsing and main () 
1 #include <stdio.h> 
2 #include <ctype.h> 
3 #include <stdarg.h> 
4 #include <signal.h> 
5 #include <malloc.h> 
6 #include <errno.h> 
7 #include <time.h> 
8 #include <sys/types.h> 
9 #include <sys/timeb.h> 
10 #include <process.h> 
11 
12 #include "date .h" 
13 
14 #include <tools/debug.h> 
15 #include <tools/set.h> 
16 #include <tools/hash.h> 
17 #include <tools/compiler.h> 
18 #include <tools/l.h> 
19 
20 #ifdef 
21 # 
22 # 
23 # 
24 #else 
25 # 
26 # 
27 # 
28 #endif 
29 
30 PRIVATE 
31 PRIVATE 
32 PRIVATE 
33 PRIVATE LLAMA 
define 
include 
undef 
define 
include 
undef 
int 
int 
char 
FILE ALLOCATE 
"parser.h" 
ALLOCATE 
ALLOCATE 
"parser.h" 
ALLOCATE 
Warn exit 
Num_warnings 
*Output fname 
*Doc file 0; 
0; 
"????"; 
NULL; /* Set to 1 if -w on command line 
/* Total warnings printed 
/* Name of the output file 
/* Error log & machine description *I 
*I *I 
*I 
... 
Section 4.1 0.3-The Rest of LLama 
Listing 4.33. continued ... 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 #define VERBOSE(str) if(Verbose) { printf( str ":\n" ) ; }else 
/*----------------------------------------------------------------------*/ 
void onintr p ( ( 
int parse_args p ( ( 
int do file p ( ( 
void symbols p ( ( 
void statistics p ( ( 
void tail p ( ( 
int main p ( ( 
void output p ( ( 
void !error p ( ( 
void error p ( ( 
char *open_errmsg p ( ( 
char *do dollar p ( ( void 
int argc, char 
void void 
FILE *fp 
void 
int argc, char 
char *fmt, 
int fatal, char 
int fatal, char 
void 
int num, int rhs **argv 
**argv 
*fmt, 
*fmt, 
size, int -) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
lineno, /* local */ 
/* public */ 
PRODUCTION *prod, \ 
char *fname)); 
/*----------------------------------------------------------------------
* There are two versions of the following subroutines--used in do_file(), 
* depending on whether this is llama or aces. 
* The aces versions is discussed in the next Chapter. 
* 
* subroutine: llama version in: aces version in: 
* 
* file_header () lldriver.c yydriver.c 
* code_ header () lldriver.c yydriver.c 
*driver() lldriver.c yydriver.c 
* tables () llcode.c yycode.c 
* patch() yypatch. c 
* select() llselect.c 
* do_dollar () lldollar.c yydollar.c 
* 323 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 * Also, several part of this file are compiled only for llama, others only for 
* aces. The llama-specific parts are arguments to LL() macros, the occs-
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 * specific parts are in OX() macros. We'll look at what the aces-specific 
* parts actually do in the next Chapter. *----------------------------------------------------------------------
*I 
PUBLIC main( argc, argv ) 
char **argv; 
{ 
amblksiz 2048; 
signon(); 
signal( SIGINT, onintr ); 
parse_args( argc, argv ); 
if( Debug && !Symbols 
Symbols = 1; 
if( Make_parser 
{ 
if( Verbose 1 ) 
{ /* Declared in malloc.h 
/* Print sign on message 
/* Close output files on Ctrl-Break. 
OX( 
OX( 
OX( 
OX( 
OX( OX( if( ! (Doc_file fopen( DOC_FILE, "w") ) ) 
ferr( "Can't open log file %s\n", DOC FILE); *I 
*I 
*/ 
.... 
324 Top-Down Parsing-Chapter 4 
Listing 4.33. continued ... 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 153 OX( 
OX( else if( Verbose > 1 ) 
OX( Doc file = stderr; 
OX( 
if( Use stdout ) 
{ 
else 
{ Output_fname 
Output "/dev/tty" 
stdout; 
OX( Output_fname 
LL( Output_fname !Make_parser ? ACT FILE 
PARSE_FILE; PARSE FILE 
if ( (Output = fopen ( Output_fname, "w")) == NULL ) 
error( FATAL, "Can't open output file %s: %s\n", 
Output_fname, open_errmsg() ); 
if( (yynerrs = do_file()) 
{ 
if ( Symbols ) 
symbols(); 
statistics( stdout ); 
if( Verbose && Doc file 
{ 0) 
OX( statistics( Doc file 
else 
{ 
if( Output != stdout ) 
{ 
fclose ( Output ) ; 
if( unlink( Output_ fname 
perror( Output_ fname /* Do all the work */ 
/* Print the symbol table *I 
/* And any closing-up statistics. */ 
) ; 
) ---1 ) 
) ; 
/* Exit with the number of hard errors (or, if -W was specified, the sum 
* of the hard errors and warnings) as an exit status. Doc file and Output 
*are closed implicitly by exit(). 
*I 
exit( yynerrs + (Warn_exit? Num_warnings 0) ) ; 
!*----------------------------------------------------------------------*/ 
PRIVATE void onintr() 
{ 
if( Output != stdout 
{ 
fclose( Output); 
unlink( Output_fname ); /* SIGABRT (Ctrl-Break, -c) Handler */ 
/* Destroy parse file so that a */ 
/* subsequent compile will fail */ 
.... 
Section 4.1 0.3-The Rest of LLama 325 
Listing 4.33. continued ... 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 exit( EXIT USR ABRT ); 
/*----------------------------------------------------------------------*/ 
PRIVATE parse_args( argc, argv) 
int 
char argc; 
**argv; 
/* Parse the command line, setting global variables as appropriate */ 
char *p; 
static char name_buf[80]; 
static char *usage_msg[] = 
{ /* Use to assemble default file names */ 
#ifdef LLAMA 
#else 
#endif 
} ; "Usage is: llama [-switch] file", 
"Create an LL(l) parser from the specification in the", 
"input file. Legal command-line switches are:", 
1111 
I 
"-eN 
"-D 
"-f use N as the pairs threshold when (C)ompressing", 
enable (D)ebug mode in yyparse.c (implies -s)", 
(F)ast, uncompressed, tables", 
"Usage is: occs [-switch] file", 
1111 
I 
"\tCreate an LALR(l) parser from the specification in the", 
"\tinput file. Legal command-line switches are:", 
1111 
I 
"-a 
"-D 
"-g 
"-1 
"-m<file> 
"-p 
"-s 
"-S 
"-t 
"-T 
"-v 
"-V 
"-w 
"-W 
NULL Output actions only (see-p)", 
enable (D)ebug mode in yyparse.c (implies -s)", 
make static symbols (G)lobal in yyparse.c", 
suppress #(L)ine directives", 
use <file> for parser te(M)plate", 
output parser only (can be used with -T also)", 
make (s)ymbol table", 
make more-complete (S)ymbol table", 
print all (T)ables (and the parser) to standard output", 
move large tables from yyout.c to yyoutab.c", 
print (V)erbose diagnostics (including symbol table)", 
more verbose than -v. Implies -t, & yyout.doc goes to stderr", 
suppress all warning messages\n", 
warnings (as well as errors) generate nonzero exit status", 
/* Note that all global variables set by command-line switches are declared 
* in parser.h. Space is allocated because a #define ALLOC is present at 
* the top of the current file. 
*I 
for( ++argv,--argc; argc && *(p 
{ 
while( *++p 
{ 
switch( *p 
{ *argv) 
OX( case 'a': Make_parser 0; '-'; ++argv, --argc ) 
326 Top-Down Parsing-Chapter 4 
Listing 4.33. continued ... 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 
230 
231 
232 
233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 out: ; OX( 
OX( 
LL( 
OX( 
LL( 
LL( 
LL( 
LL( case 'D': 
case 'g': 
case If': 
case I 1': 
case 'm': 
case 'p': 
case , s': 
case IS': 
case 't': 
case 'T': 
case 'v': 
case 'V': 
case 'w': 
case 'W': 
case 'c': 
default Template 
break; ACT_TEMPL; 
Debug 
Public 
Uncompressed 
No lines 
Template 
Make actions 
Symbols 
Symbols 
Use stdout 
Make_yyoutab 
Verbose 
Verbose 1; 
1; 
1; 
1; 
p 
0; 
1; 
2; 
1; 
1; 
1; 
2; + 1; break; break; 
break; 
break; 
goto out; 
break; 
break; 
break; 
break; 
break; 
break; 
break; 
1; No_warnings break; 
Warn exit 1; break; 
Threshold atoi( ++p ); 
while( *p && isdigit( p[1] ) ) 
++p; 
break; 
fprintf(stderr, "<-%c>: illegal argument\n", *p); 
printv (stderr, usage msg ); 
exit( EXIT ILLEGAL ARG ); 
if( Verbose > 1 ) 
Use stdout = 1; 
if( argc <= 0 ) 
No_lines = 1; /* Input from standard input 
else if( argc > 1 
{ 
else fprintf( stderr, "Too many arguments.\n" ); 
printv ( stderr, usage msg ); 
exit (EXIT TOO MANY); 
/* argc == 1, input from file 
if( ii_newfile( Input_file_name = *argv) < 0 
{ 
sprintf( name_buf, "%0.70s.%s", *argv, DEF_EXT ); 
if( ii_newfile( Input file_name = name_buf ) < 0 ) 
error( FATAL, "Can't open input file %s or %s: %s\n", *I 
*I 
*argv, name_buf, open_errmsg()); 
/*----------------------------------------------------------------------*/ 
.... 
Section 4.1 0.3-The Rest of LLama 327 
Listing 4.33. continued ... 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 328 
329 
330 PRIVATE int 
{ do_file () 
/* Process the input file. Return the number of errors. */ 
struct timeb start_time, end time 
long time; 
ftime( &start time ) ; 
end time start_time; /* Initialize times now so that the difference */ 
/* between times will be 0 if we don't build the */ 
/* tables. Note that I'm using structure assign- */ 
/* ment here. */ 
init_acts (); 
file_header(); /* Initialize the action code. */ 
/* Output #defines that you might want to change */ 
VERBOSE( "parsing" ); 
nows 
yyparse (); 
(); /*Make lex ignore white space until ws() is called*/ 
/* Parse the entire input file */ 
if( ! ( yynerrs 1 I problems()) ) 
{ 
VERBOSE( "analyzing grammar" ); 
first (); 
LL( follow(); 
LL( select(); 
code_header(); 
OX( patch(); ) 
ftime( &start_time ) ; 
if( Make_parser ) 
{ /* 
/* 
/* 
/* 
/* 
/* 
VERBOSE ( "making tables" ) ; 
tables (); 
ftime &end time ); 
VERBOSE( "copying driver" ) ; 
driver(); /* If no problems in the input file */ 
Find FIRST sets, *I 
FOLLOW sets, *I 
and 11 (1) select sets if this is llama *I 
Print various #defines to output file *I 
Patch up the grammar (if this is aces) *I 
and output the actions. *I 
/* generate the tables, */ 
/* the parser, */ 
if( Make actions 
tail() ; /* and the tail end of the source file. */ 
if( Verbose 
{ 
time end_time.time * 1000) + end_time.millitm ; 
time (start_time.time * 1000) + start time.millitm ; 
printf( "time required to make tables: %ld.%-03ld seconds\n", 
(time/1000), (time%1000)); 
return yynerrs; 
328 Top-Down Parsing-Chapter4 
Listing 4.34. main.c- Error, Output, and Statistics Routines 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 PRIVATE void 
{ symbols ( void ) /* Print the symbol table */ 
FILE *fd; 
if( ! (fd = fopen( SYM_FILE, "w")) ) 
perror( SYM FILE ) ; 
else 
{ 
print_symbols 
fclose fd ) ; 
fd ) ; 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
FILE *fp; 
( statistics( fp) 
/* Print various statistics 
*I 
int conflicts; 
if( Verbose ) 
{ /* Number of parse-table conflicts */ 
USED_TERMS, NUMTERMS ); 
USED_NONTERMS, NUMNONTERMS); 
Num_productions, MAXPROD ); 
LL( 
ox ( fprintf (fp, "\n"); 
fprintf (fp, "%4d/%-4d 
fprintf (fp, "%4d/%-4d 
fprintf (fp, "%4d/%-4d 
fprintf (fp, "%4d 
lr_stats(fp ); terminals\n", 
nonterminals\n", 
productions\n", 
actions\n", (Cur_act- MINACT) +1 );) 
LL( conflicts 
OX ( conflicts 
if( fp == stdout 
fp = stderr; 0; 
lr_conflicts(fp); 
if( Num_warnings -conflicts > 0 ) 
fprintf(fp, "%4d warnings\n", Num_warnings- conflicts); 
if(yynerrs) 
fprintf(fp, "%4d hard errors\n", yynerrs ) ; 
/*----------------------------------------------------------------------*/ 
PUBLIC void output( fmt, ... ) 
char *fmt; 
/* Works like printf(), but writes to the output file. See also: the 
* outc() macro in parser.h 
*I 
va list args; 
va_start( args, fmt ) ; 
vfprintf( Output, fmt, args ); ) 
.... 
Section 4.10.3-The Rest of LLama 
Listing 4.34. continued ... 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 /*----------------------------------------------------------------------*/ 
PUBLIC void document( fmt, ... ) 
char *fmt; 
{ /* Works like printf() but writes to yyout.doc (provided that the file 
* is being created. 
*I 
va list args; 
if( Doc file ) 
( 
va_start( args, fmt ); 
vfprintf( Doc_file, fmt, args ); 
document_to( fp ) 
FILE *fp; 
{ 
/* Change document-file output to the indicated stream, or to previous 
* stream if fp=NULL. 
*I 
static FILE *oldfp; 
if( fp 
{ 
else oldfp 
Doc file 
Doc file Doc_file; 
fp; 
oldfp; 
/*----------------------------------------------------------------------*/ 
PUBLIC void lerror( fatal, fmt, ... ) 
char *fmt; 
{ 
/* This error-processing routine automatically generates a line number for 
* the error. If "fatal" is true, exit() is called. 
*I 
va list 
char 
extern int args; 
*type; 
yylineno; 
if( fatal == WARNING 
{ 
else 
{ ++Num_warnings; 
if( No_warnings 
return; 
type = "WARNING: "; 
type "ERROR: "; 329 
330 Top-Down Parsing-Chapter4 
Listing 4.34. continued ... 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 
508 ++yynerrs; 
va start( args, fmt); 
fprintf ( stdout, "%s %s (%s, line %d): ", PROG_NAME, type, 
vfprintf( stdout, fmt, args ); 
OX( if( Verbose && Doc file 
OX( { Input file_name, yylineno ) ; 
OX( fprintf Doc_file, "%s (line %d) ", type, yylineno ); 
OX( vfprintf( Doc file, fmt, args ); 
OX( 
if( fatal == FATAL ) 
exit( EXIT OTHER); 
PUBLIC void error( fatal, fmt, ... ) 
char *fmt; 
/* This error routine works like lerror() except that no line number is 
* generated. The global error count is still modified, however. 
*I 
va list 
char args; 
*type; 
if( fatal == WARNING 
{ 
else 
{ ++Num_warnings; 
if( No_warnings 
return; 
type = "WARNING: "; 
type = "ERROR: "; 
++yynerrs; 
va start 
fprintf 
vfprintf args, fmt ) ; 
stdout, type); 
stdout, fmt, args ) ; 
OX( if( Verbose && Doc -OX( { 
OX( fprintf Doc -OX( vfprintf Doc -OX( 
if( fatal == FATAL ) 
exit( EXIT OTHER); file 
file, 
file, 
PUBLIC char 
{ *open_errmsg () ) 
type 
fmt, ) ; 
args ) ; 
.... 
Section 4.1 0.3-The Rest of LLama 
Listing 4.34. continued ... 
509 
510 
511 
512 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 /* Return an error message that makes sense for a bad open */ 
extern errno; 
switch( errno 
{ 
case EACCES: 
case EEXIST: 
case EMFILE: 
case ENOENT: 
default: return "File is read only or a directory"; 
return "File already exists"; 
return "Too many open files"; 
return "File not found"; 
return "Reason unknown"; 
} 
/*----------------------------------------------------------------------*/ 
PRIVATE void tail() 
{ 
/* Copy the remainder of input file to standard output. Yyparse will have 
* terminated with the input pointer just past the %%. Attribute mapping 
* ($$ to Yyval, $N to a stack reference, etc.) is done by the do_dollar() 
* call. 
* * On entry, the parser will have read one token too far, so the first 
* thing to do is print the current line number and lexeme. 
*I 
extern int yylineno ; 
extern char *yytext /* LeX generated */ 
/* LeX generated */ 
int 
char c1 i1 sign; 
fname[80] 1 *p; /* field name in $< ... >n */ 
output( "%s" 1 yytext); /* Output newline following %% */ 
if( !No lines 
output( "\n#line %d \"%s\"\n" 1 yylineno 1 Input_file_name ); 
ii_unterm(); /*Lex will have terminated yytext */ 
while( (c = ii_advance()) != 0 ) 
{ 
if ( c == -1 ) 
{ 
ii_flush (1); 
continue; 
else if( c == 1$1 ) 
{ 
ii_mark_start(); 
if( (c = ii_advance()) != 1<1 ) 
*fname = 1\01; 
else /* extract name in $<foo>l */ 
p = fname; 
for(i=sizeof(fname); --i > 0 && (c=ii_advance ()) != 1>1 ;) 
*p++ = c; 
*p++ = I \01; 331 
.... 
332 Top-Down Parsing-Chapter 4 
Listing 4.34. continued ... 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 if ( c == '>' ) /* truncate name if necessary */ 
c = ii_advance(); 
if ( c == '$' ) 
output( do_dollar( DOLLAR_DOLLAR, -1, 0, NULL, fname ) ); 
else 
if ( c != '_, 
sign = 1 
else 
{ 
sign = -1; 
c = ii_advance(); 
for( i = 0; isdigit(c); c = ii_advance() 
i = (i * 10) + (c -'0'); 
ll_pushback(1); 
output( do_dollar(i *sign, -1, ii_lineno(), NULL, fname) ); 
else if( c != '\r' 
outc( c ) ; 
Listing 4.35. lldollar.c- $Attribute Processing (LLama Version). 
I #include <stdio.h> 
2 #include <tools/debug.h> 
3 #include <tools/set.h> 
4 #include <tools/hash.h> 
5 #include "parser.h" 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 PUBLIC char 
int 
int 
int 
PRODUCTION 
char 
{ 
static *do_dollar( 
num; 
rhs size; 
lineno; 
*prod; 
*field; 
char bu f [ 3 2 J ; num, 
16 if( num == DOLLAR DOLLAR rhs 
17 return "Yy_vsp->left"; 
18 else 
19 size, lineno, -prod, 
20 sprintf( buf, "(Yy_vsp[%d].right)", num ); 
21 return buf; 
22 
23 field 
/* the N in $N *I 
/* not used *I 
/* not used *I 
/* not used *I 
/* not used *I 
/* assuming that num */ 
/* has < 16 digits */ 
Section 4.1 0.3-The Rest of LLama 
Listing 4.36. signon.c- Print Sign-on Message 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
#include <tools/set.h> 
#include "parser.h" 
PUBLIC void 
{ signon () 
/* Print the sign-on message. Note that since the console is opened 
* explicitly, the message is printed even if both stdout and stderr are 
* redirected. I'm using the ANSI TIME and DATE macros to get the 
* time and date of compilation. 
*I 
FILE *screen; 
UX( if( ! (screen = fopen("/dev/tty", 
MS( if( ! (screen = fopen("con:", 
screen = stderr; 
LL( fprintf(screen, "LLAMA 1.0 [" 
OX( fprintf(screen, "OCCS 1.0 [" "w")) 
"w")) 
DATE " 
DATE " TIME 
TIME "J \n" ) ; 
"] \n" ) ; 333 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 fprintf( screen,"(C) " 
if( screen != stderr 
fclose(screen); DATE ", Allen I. Holub. All rights reserved.\n"); 
4.11 Exercises 
4.1. A standard, recursive, in-order, binary-tree traversal routine looks like this: 
typedef struct node 
{ 
int key; 
struct node *left, *right; 
NODE; 
traverse( root 
NODE *root; 
{ 
if ( ! root ) 
return; 
traverse( root->left ); 
printf( "%d\n", root->key ); 
traverse( root->right ); 
Write a nonrecursive binary-tree traversal function that uses a local stack to hold 
pointers to the parent of the current subtree rather than using the run-time stack, 
as is implicit in the recursive algorithm. 
4.2. A palindrome is a word or phrase that reads the same backwards as forwards, 
such as the Napoleonic palindrome: "Able was I ere I saw Elba." 
334 Top-Down Parsing-Chapter 4 
a. Write a grammar that recognizes simple palindromes made up of digits. Each 
digit should appear exactly twice, and the center of the palindrome should be 
marked with a I character. For example, the input string 1234/4321 should be 
recognized. 
b. Write a program that uses a push-down automata to recognize palindromes 
such as the foregoing. 
c. Can you modify your grammar to recognize real palindromes, such as "able 
was I ere I saw Elba." If so, implement the grammar; if not, explain why. 
4.3. Write a computer program that translates the right-linear grammars discussed in 
Chapter 3 into the state-machine grammars discussed in the same chapter. 
4.4. Determine the FIRST and FOLLOW sets for all nonterminals in the first 10 pro­
ductions in the grammar for C, presented in Appendix C. Is this grammar LL(l)? 
Why or why not? 
4.5. Modify the following grammar so that it is not ambiguous and is LL(l): 
expr ~ -expr 
I * expr 
expr * expr 
expr I expr 
expr = expr 
expr + expr 
expr-expr 
( expr) 
Operator precedence and associativity should be according to the following table 
(higher lines in the table are higher precedence operators). 
Associativity Operator Description 
left to right ( ) parentheses for grouping (highest precedence) 
left to right - * unary minus and pointer dereference 
left to right * I multiplication, division 
left to right +- addition, subtraction 
right to left = assignment (lowest precedence) 
4.6. Write an LL( 1) grammar for the state-machine-description language presented as 
an exercise in the last chapter, and implement a table-driven, top-down parser for 
that language. 
4. 7. Is the following grammar LL( 1 )? Why or why not? If it isn't, convert it to LL( 1 ). 
s ~ symbol stuff 
I TOKEN TOKEN stuff 
star_list stuff 
star list ~ star list STAR 
I E 
symbol ~ TOKEN 
stuff ~ ANOTHER TOKEN 
4.8. Design and implement a desk-calculator program using LLama and LEX. The 
program should take process an input file that contains various semicolon­
terminated statements. Support C syntax and the following C operators: 
Section 4.11-Exercises 
+ 
+= 
++ I % * 
/= %= *= >> << 
>>= <<= 
The -is both unary and binary minus. The * is a multiply. Your calculator 
should support a reasonable number of variables (say, 128) with arbitrary names. 
A variable is declared implicitly the first time it's used. In addition to the forego­
ing operators, your calculator should support the following pseudo subroutine: 
printf ("'\!{format}"', ... ); 
The printf () pseudo subroutine should work like the normal printf (), 
except that it needs to support only the %d, %x, %o, and %f conversions. It does 
not have to support field widths, left justification, and so forth. 
4.9. Modify the calculator built in the previous exercise so that it generates the assem­
bly language necessary to evaluate the expression, rather than actually evaluating 
the expression at run time. 
4.1 0. Modify LLama so that it automatically makes the following transformations in 
the input grammar. Productions of the form: 
s symbol stuff 
I symbol other stuff 
should be transformed to: 
s : symbol s' 
s': stuff 
other stuff 
The transformations should be applied recursively for as long as the initial sym­
bols on the right-hand side are the same. For example, 
s symbol other 
I symbol other stuff 
should become: 
s : symbol s' 
s': other 
other stuff 
should become: 
s symbol s' 
s' other s'' 
s'' stuff 
/* empty */ 
4.11. Modify the interactive debugging environment in yydebug.c so that you can look 
at the actual code associated with an action. You can do this by storing all action 
code in a file rather than in internal buffers and keeping a pointer to the file posi­
tion for the start of the code in the occs symbol table (rather than a string 
pointer). Normally, this intermediate file would be destroyed by LLama, but the 335 
336 Top-Down Parsing-Chapter 4 
file should remain in place if -D is specified on the command line. To make this 
file available from the debugger, LLama will need to output the source code for 
an array indexed by production number which evaluates to the correct file posi­
tion. Finally, add two commands to yydebug.c: The first prompts for a produc­
tion number and displays the associated code in the stack window. The second 
causes the code to be printed in the comments window every time a reduction 
occurs. 
4.12. Several arrays output by LLama are used only for debugging, and these arrays 
take up unnecessary space in the executable image Modify LLama and 
yydebug.c so that this information is stored in binary in an auxiliary file that is 
read by the debugger at run time. Don't read the entire file into memory-use 
lseek () to find the required strings and transfer them directly to the screen. 
4.13. The action code and the debugging-environment subroutines in yydebug.c could 
be overlays--code in an action doesn't call debugger subroutines and vice versa. 
Arrange for overlays to be used for the debugger to save space in the executable 
image. 
5 
Bottom-Up Parsing 
The first part of this chapter looks at bottom-up parsing in general-at how the 
bottom-up parse process works, how it can be controlled by a state machine, and how the 
state machine itself, and the associated tables, are generated. The second part of the 
chapter looks at a practical implementation of the foregoing: The internals of occs, a 
yacc-like program that builds a bottom-up parser from a grammar, is discussed in depth, 
as is the occs output file that implements the parser. There is no extended example of 
how occs is used because Chapter Six, in which code generation is discussed, provides 
such an example. 
Bottom-up parsers such as the ones created by yacc and occs work with a class of LALR(1) grammars. 
grammars called LALR( 1) grammars, which are special cases of the more inclusive LR( 1) 
class. As with the LL( I) notation, the ( 1) in LR( I) means that one token of lookahead is 
required to resolve conflicts in the parse. Similarly, the first L means that input is read 
left to right. The R means that a rightmost derivation is used to construct the parse 
tree-the rightmost nonterminal is always expanded instead of expanding the leftmost 
nonterminal, as was done in the previous chapter. The LA in LALR(l) stands for "look 
ahead"-information about certain lookahead characters is actually built into LALR(l) 
parse tables. I'll explain the exact characteristics of these grammars when I discuss how 
bottom-up parse tables are created, below. All LL(l) grammars are also LR(l) gram-
mars, but not the other way around. 
Most LR grammars cannot be parsed with recursive-descent parsers, and LR and Advantages and disad­
LALR grammars tend to be more useful than LL grammars because they are easier to vantages 01 LR parsers. 
write-there aren't so many restrictions placed on them. This grammatical flexibility is 
a real advantage when writing a compiler. LR parsers have many disadvantages, how-
ever. It is difficult to write an LR parser unless you have a tool, such as occs or yacc, to 
help you construct the tables used by the parser. Also, the tables are larger than LL parse 
tables and the parser tends to be slower. LR error recovery is difficult to do--error 
recovery in yacc-generated parsers is notoriously bad. 
337 
338 
Goal symbol. 
Bottom-up parsing with a 
PDA, basic algorithm. 
Reduce. 
Shift. 
Accept. 
Shift;tpush, reduce;tpop. Bottom-Up Parsing-Chapter 5 
5.1 How Bottom-Up Parsing Works* 
Bottom-up parsers use push-down automata to build the parse tree from the bottom 
up rather than from the top down. Instead of starting at the root, as is the case with a 
top-down parser, a bottom-up parser starts with the leaves and, when it's collected 
enough leaves, it connects them together with a common root. The process is best illus­
trated with an example. I'll use the following expression grammar: 
0. s ~ e 
1. e ~ e+t 
2. I t 
3. t ~ t * f 
4. I f 
5. f ~ (e) 
6. I NUM 
The non terminals are e (for expression), t (for term), and f (for factor). The terminals are 
+, *, (,),and NUM. (NUM is a number-a collection of ASCII characters in the range 
' 0' to ' 9' ). Multiplication is of higher precedence than addition: since the star is 
further down in the grammar, it will be lower on the parse tree than the plus unless 
parentheses force it to go otherwise. The special symbol s is called the goal symbol. A 
bottom-up grammar must have one unique goal symbol, and only one production can 
have that goal symbol on its left-hand side. Note that this grammar can't be parsed from 
the top down because it's left recursive. 
A bottom-up parser is a push-down automaton; it needs a state machine to drive it 
and a stack to remember the current state. For now, we'll ignore the mechanics of the 
state machine and just watch the stack. The parse process works as follows: 
( 1) If the top few items on the stack form the right-hand side of a production, pop these 
items and replace them with the equivalent left-hand side. This procedure (popping 
the number of elements on a right-hand side and pushing the left-hand side) is 
known as a reduce operation. 
(2) Otherwise, push the current input symbol onto the stack and advance the input. 
This operation is known as a shift. 
(3) If the previous operation was a reduce that resulted in the goal symbol at the top of 
stack, accept the input-the parse is complete. Otherwise, go to 1. 
Don't confuse shifting and reducing with pushing and popping. A shift always 
pushes a token, but it also advances the input. A reduce does zero or more pops fol­
lowed by a push. (There are no pops on E productions.) I'll illustrate the process with a 
parse of 1 * ( 2 + 3) . Initially, the stack (on the left, below) is empty and none of the input 
characters (on the right, below) have been read: 
1*(2+3) 
Since there's no legitimate right-hand side on the stack, apply rule two: shift aNUM and 
advance past it in the input. 
INUM * ( 2 + 3 ) 
Note that the input character 1 has been translated to a NUM token as part of the input 
process. The right-hand side of Production 6 is now at top of stack, so reduce by 
t~ NUM. Pop the NUM and replace it with an f: 
* ( 2 + 3 
f * ( 2 + 3 
Section 5.1-How Bottom-Up Parsing Works* 
The previous operation has put another right-hand side on the stack, this time for Produc­
tion 4 (t~j); reduce by popping the f and pushing at to replace it: 
* ( 2 + 3 
* ( 2 + 3 
The tat top of stack also forms a right-hand side, but there's a problem here. You could 
apply Production 2 (e~t), popping the t and replacing it with an e, but you don't want to 
do this because there's no production that has an e followed by a* (the next input sym­
bol) on its right-hand side. There is, however, a production with at followed by a* (Pro­
duction 3: t~t*J). So, by looking ahead at the next input symbol, the conflict is resolved 
in favor of the shift (rather than a reduction by Production 2) in the hope that another f 
will eventually get onto the stack to complete the right-hand side for Production 3. The 
stack now looks like this: 
l* ( 2 + 3 ) 
There's still no reasonable right-hand side on the stack, so shift the next input symbol to 
the stack: 
t * ( 2 + 3 ) 
and the 2 as well: 
It* (NUM + 3 ) 
Now there is another legitimate right-hand side on the stack: the NUM. The parser can 
apply the same productions it used to process the earlier NUM: 
t * ( + 3 
t * ( 
t * ( t + 3 
+ 3 
+ 3 
The next input symbol is a plus sign. Since the grammar doesn't have any productions in 
which a plus follows a t, it applies Production 2 (e~t) instead of shifting: 
t * ( + 3 
lt*(e + 3 
Again, since there's still input, shift the next input symbol rather than reducing by Pro­
duction 1. 
lt*(e+ 3 ) 
and the next one: 
It* ( e+ NUM 
The number forms a legitimate right-hand side, so the parsers process it as before: 
lt*(e+ 
lt*(e+t 
Another right-hand side has now appeared on the stack-e+t is the right-hand side of 
Production 1-so the parser can apply this production, popping the entire right-hand side 
(three objects) and pushing the corresponding left-hand side: 
lt*(e+ 339 
340 
Relationship between 
stack and parse tree. 
List processing in a 
bottom-up parser. Bottom-Up Parsing-Chapter 5 
It* ( e 
t * ( 
It* ( e 
As before, the parser defers the application of Production 0 because there's still input; it 
shifts the final input symbol onto the stack: 
lt*(e) 
thereby creating another right-hand side-(e) is the right-hand side of Production 5, 
f~(e). Reduce by this production: 
It* ( e 
t * ( 
t* 
t * f 
The three symbols now at top of stack form the right-hand side of Production 3 (t~t*f); 
pop them and push the left-hand side: 
t* 
Reduce by Production 2: 
e 
Finally, since there's no more input, apply Production 0: 
s 
Since the goal symbol is at the top of stack, the machine accepts and the parse is com­
plete. The entire process is summarized in Table 5.1. Figure 5.1 shows the parse tree as 
it's created by this parse. Notice that you can determine the state of the stack for any of 
the partially created trees by reading across the roots of the various subtrees. For exam­
ple, the tops of the subtrees shown in Figure 5.l(m) are (from left to right) t, *, (, e, +, 
and f, and these same symbols comprise the stack at the equivalent time in the parse. So, 
you can look at the stack as a mechanism for keeping track of the roots of the partially­
collected subtrees. 
5.2 Recursion in Bottom-Up Parsing* 
Hitherto, left recursion has been something to avoid in a grammar, primarily because 
top-down parsers can't handle it. The situation is reversed in a bottom-up parser: Left 
recursion should always be used for those lists in which associativity is not an issue. 
Right recursion can be used for right-associative lists, but it should be used only when 
right associativity is required. The reason for this change can be seen by looking at how 
right-and left-recursive lists are parsed by a bottom-up parser. Consider a left-recursive 
grammar, such as the following list of numbers: 
Section 5.2-Recursion in Bottom-Up Parsing* 
Table 5.1. A Bottom-Up Parse of 1*(2+3) 
Stack Input Next action 
1 * ( 2 + 3 ) Shift NUM 
NUM * ( 2 + 3 ) Reduce by f~NUM 
* ( 2 + 3 ) 
f * ( 2 + 3 ) Reduce by f~t 
* ( 2 + 3 ) 
t * ( 2 + 3 ) Shift* 
t * ( 2 + 3 ) Shift ( 
t * ( 2 + 3 ) Shift NUM 
t * ( NUM + 3 ) Reduce by f~NUM 
t * ( + 3 ) 
t * (f + 3 ) Reduce by t~f 
t * ( + 3 ) 
t * ( t + 3 ) Reduce by e~t 
t * ( + 3 ) 
t * ( e + 3 ) Shift+ 
t * ( e + 3 ) Shift NUM 
t * ( e + NUM ) Reduce by f~NUM 
t * ( e + ) 
t*(e+f ) Reduce by t~f 
t * ( e + ) 
t*(e+t ) Reduce by e~e+t 
t * ( ) 
t*(e ) Shift) 
t * (e) Reduce by /~(e) 
t* 
t * f Reduce oy t~t* f 
t Reduce by e~t 
e Reduce by s~e 
s Accept 
I. 
2. list ~ 
I listNUM 
NUM 
The input 1 2 3 generates the following bottom-up parse: 
Stack Input Comments 
- 1 2 3 
NUM 2 3 shift aNUM 
list 2 3 reduce by list~NUM 
listNUM 3 shift aNUM 
list 3 reduce by list~list NUM 
listNUM shift aNUM 
list reduce by list~list NUM See Fig. 
5.1 
a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
I 
m 
n 
0 
p 
q 
r 
s 
t 
The stack never grows by more than two elements because a reduction occurs every time 
that a new NUM is shifted. Note that the nonrecursive production, list~NUM is applied 
first because the parser must get a list onto the stack in order to process the rest of the list 
elements. This is always the case in left-recursive lists such as the foregoing, and is 341 
Nonrecursive list element 
reduced first. 
342 Bottom-Up Parsing-Chapter 5 
Figure 5.1. Evolution of Parse Tree for 1 * ( 2 + 3) 
a. b. c. d. t 
I 
f f 
I I 
NUM NUM NUM 
e. f. g. h. f 
I 
t * t * ( t * ( NUM t * ( NUM 
I I I I 
f f f f 
I I I I 
NUM NUM NUM NUM 
i. j. e k. e + I. e + I I I 
t t t t 
I I I I 
f f f f NUM 
I I I I 
t * ( NUM t * ( NUM t * ( NUM t * ( NUM 
I I I I 
f f f f 
I I I I 
NUM NUM NUM NUM 
m. n. o. e p. e ) 
~~~ ~~~ 
e + e + t e + t e + t 
I I I I I I I 
t f t f t f t f 
I I I I I I I I f NUM f NUM f NUM f NUM 
I I I I 
t * ( NUM t * ( NUM t * ( NUM t * ( NUM 
I I I I 
f f f f 
I I I I 
NUM NUM NUM NUM 
q. r. s. t. s 
I 
e e 
I I 
t t t 
f /--! /--! /--! 
1----------- 1----------- 1----------- 1----------- e ) e ) e ) e ) 
~~~ ~~~ ~~~ ~~~ 
e + t e + t e + t e + t 
I I I I I I I I 
t f t f t f t f 
I I I I I I I I f NUM f NUM f NUM f NUM 
I I I I 
t * ( NUM t * ( NUM t * ( NUM t * ( NUM 
I I I I 
f f f f 
I I I I 
NUM NUM NUM NUM 
Section 5.2-Recursion in Bottom-Up Parsing* 
handy when doing code generation because it provides a hook for initialization actions. 
(More on this in the next chapter.) 
Now consider a right-recursive list, such as the following: 
I. list ~ NUM list 
2. I NUM 
The input 1 2 
3 now generates the following bottom-up parse: 
Stack Input Comments 
- 1 2 3 Shift aNUM 
NUM 2 3 Shift aNUM 
NUMNUM 3 Shift aNUM 
NUMNUMNUM Apply Iist~NUM 
NUMNUMlist Apply list~NUM list 
NUM list Apply list~NUM list 
list Apply list~NUM list 
Here, all of the list elements are pushed onto the stack before any of them are pro­
cessed via a reduction. This behavior is always the case-right-recursive productions 
use a lot of stack because all the list elements must be pushed before a reduction can 
occur, so it's worth avoiding right associativity if at all possible. Of course, you can't do 
this in an expression grammar because certain operators just have to associate in certain 
ways. Lists, however, are another matter. 
5.3 Implementing the Parser as a State Machine* 
I need to introduce a few terms at this point. At the risk of repeating myself, a shift is 
the process of moving a token from the input stream to the stack-push the current token 
and advance the input. A reduce is the process of replacing a right-hand side on the 
stack with the matching left-hand side-pop as many items as there are on the right-hand 
side of a production and push the left-hand side. A viable prefix is a partially parsed 
expression-an incomplete derivation. In a bottom-up parser, the symbols on the parse 
stack from bottom to top, are identical to the viable prefix, read left to right. 
A handle is a right-hand side on the top few items of the stack. The parser scans the 
stack looking for a handle, which when found, triggers a reduce operation. Put another 
way, a reduce can be performed when the rightmost symbols of the viable prefix form a 
right-hand side. Strictly speaking, a handle is a right-hand side which, when found on 
the stack, triggers a reduction. The parser might defer a reduction even though a right­
hand side is at the top of the stack-the associativity and precedence rules built into the 
grammar might require that more input symbols be read before any reductions occur. In 
this situation, a right-hand side does not form a handle because it doesn't trigger a reduc­
tion. In most situations, however, a reduction occurs as soon as the right-hand side 
appears on the stack. 
To automate a bottom-up parser, some mechanism is needed for recognizing handles 
as they appear on the stack. Of course, you could do this by brute force-scanning the 
stack and comparing what you find there to a list of right-hand sides-but this method is 
so inefficient as to be impractical. It's better to build a state machine that keeps track of 
all the push and pop operations. The condition of the stack can then be inferred from a 
knowledge of what items have been pushed or popped. The accepting states in the 
machine trigger a reduce operation. Nonaccepting states represent either a shift or the 
push of a left-hand side that is part of a reduce operation. The state machine in Figure 
5.2. serves to illustrate some of the concepts involved. This machine implements the 343 
Right-recursive lists use 
a lot of stack. 
Shift, reduce, viable 
prefix. 
Handle. 
Not all right-hand sides in 
viable prefix form han­
dles. 
Using a state machine to 
recognize handles. 
344 
Stack remembers state 
transitions. Arrows indi­
cate pushes. 
How terminals and non­
terminals get onto stack. 
States and handles. Bottom-Up Parsing-Chapter 5 
following grammar, a subset of the one used in the previous example. 
0. s ~ e 
I. e ~ e+t 
2. I t 
3. t ~ NUM 
This grammar recognizes expressions composed either of single numbers or of alternat­
ing numbers and plus signs. The expressions associate from left to right. The state 
machine can be viewed as a sort of super syntax diagram that reflects the syntactic struc­
ture of an entire language, not just of the individual productions. It's as if you formed an 
NFA by combining the syntax diagrams for all the productions in the grammar. 
Figure 5.2. A Simple LR State Machine 
(a£upt1nf:) 
The automaton's stack keeps track of state transitions. The current state is the one 
whose number is at top of stack. The direction of the arrows in the state diagram 
represents pushes. (The state number associated with the next state is pushed.) Pops 
cause us to retrace the initial series of pushes. That is, the stack serves as a record of the 
various state transitions that were made to get to the current state. You can retrace those 
transitions backwards by popping the states. For example, starting at State 0, a zero is at 
the top of the stack. Shifting a NUM results in a transition from State 0 to State I, and a 
I is pushed to record this transition. Reducing by t~NUM involves a pop (which causes 
a retrace from State I back to State 0) and a push of a 3 (which causes a transition from 
State 0 to State 3). The parser can retrace the original path through the machine because 
that information is on the stack-the state that you came from is at the top of the stack 
after the pop part of the reduction. 
It's important to notice here that the only way that a terminal symbol can get onto the 
stack is by the push that occurs in a shift operation, and the only way that a nonterminal 
symbol can get onto the stack is by the push that occurs during a reduction. 
The purpose of the state machine is to detect handles. In this machine, States I, 2, 3, 
and 5 represent the recognition of a handle. (A reduce from State 2 also terminates the 
parse successfully.) Entering one of these states usually triggers a reduce operation 
(depending on the next input character). For example, if the machine is in State I, the 
parser must have just shifted a NUM, so it will reduce by t~NUM. If the machine is in 
State 3, the parser must have just reduced by a production that had a t on its left-hand 
side, and it will do another reduce (by e~t). If the machine's in State 2, the parser 
reduces by s~e only if the next input character is the end-of-input marker, otherwise it 
will shift to State 4. State 5 tells the parser that an e, plus, and t must have been pushed 
so the handle e+t is recognized, and it reduces by e~e+t. Since the state stack itself, 
along with a knowledge of what those states represent, is sufficient to see what's going 
on, there's no reason to keep a stack of actual symbols, as I did in the previous section. 
Section 5.3-Implementing the Parser as a State Machine* 345 
The state machine from Figure 5.2. is represented in array form in Table 5.2-LA parse tables: Action 
columns are possible input symbols (in the Action section) or non terminal symbols (in and Goto components. 
the Goto section). The special symbol r in the Action table is an end-of-input marker. 
The rows represent possible states of the machine. The basic parsing algorithm is shown 
in Table 5.3. 
Table 5.2. Array Representation of an LR State Machine 
Action Goto 
r- NUM + e t 
0 - sl - 2 3 
1 r3 - r3 --Top 2 Accept - s4 - -of 
Stack 3 r2 - r2 - -
4 - sl - -5 
5 rl - rl --
I'll demonstrate the parse process by parsing the expression 1 + 2 + 3. (The entire 
parse is summarized in Table 5.4-1'11 do the parse step by step here, however.) The 
algorithm starts off by pushing 0, the state number of the start state. 
o 1+2+3r 
Action[O][NUM] holds an sl, so shift a 1 onto the stack entering State 1. Advance the 
input as part of the shift operation: 
0 1 + 2 + 3 r-
Now, since the new top-of-stack symbol is a 1, the parser looks at Action[l][+] and finds 
an r3 ([educe by production J_). The algorithm in Figure 5.2 tells the parser to execute a 
code-generation action and pop one item off the stack (because there's one item on the 
right-hand side of t~NUM). 
o +2+3r 
The parser now has to figure the Goto transition. The left-hand side of Production 3 is at 
and popping the 1 uncovered the 0, so the parser consults Goto[O][t], finding a 3, which it 
pushes onto the state stack: 
03 + 2 + 3 r-
Spinning back up to the top ofthe while loop, Action[3][+] is an r2, a reduction by Pro­
duction 2 (e~t). The parser pops one item and then pushes the contents of Goto[O][e], 
State 2: 
0 + 2 + 3 r­
+ 2 + 3 r-
Looping again, Action[2][+] is an s4-shift a 4, advancing the input: 
lo24 2 + 3 r-
Action[4][NUMJ is an sl so we shift again: 
lo241 + 3 r-
Action[ 1 ][ +] is an r3. 
lo24 + 3 r-
This time, however, the uncovered top-of-stack item is a 4, not a 0, as it was the first time 
the parser reduced by Production 3. Goto[4][t] is a 5, so the machine goes to State 5 by Table-driven LA parse, 
an example. 
346 
Table 5.3. State-Machine-Driven LR Parser Algorithm 
push( 0) 
while( Action[TOS][input1 ::f:. Accept ) 
{ 
if( Action[TOS][input1 =-) 
error() 
else if ( Action[TOS][input1 = sX) 
push( X) 
advance() 
else if ( Action[TOS][input1 = rX) 
act( X) Bottom-Up Parsing-Chapter 5 
pop( as many items as are in the RHS of Production X ) 
push( Goto[ uncovered TOS 1 [ LHS of Production X 1 ) 
accept(); 
Action 
accept () 
act(X) 
advance () 
error () 
Go to 
input 
Stack 
push(X) 
pop(N) 
TOS Definitions: 
Columns in the Action part of the state-machine array. 
Return success status. An accept is actually a reduction by Production 
0 on end of input. 
Perform the action associated with a reduction of Production X. 
This action usually generates code. 
Discard current input symbol and get the next one. 
Print error message and do some sort of error recovery. 
Columns in the Goto part of the state-machine array. 
Current input symbol. 
State stack. 
Push state X onto the stack. 
Pop N items from the stack. 
State number at the top of the stack. 
pushing a 5 onto the stack: 
lo245 + 3 1-
Looping yet again, Action[5][+1 is an r1, so an e, plus, and t must be on the stack, and-the 
parser reduces by Production 1 (e~e + t). Note that the current state (5) can only be 
reached by making transitions on an e, +,and t. Since each forward-going transition is a 
push, the stack must contain these three symbols. Since there are three items on the 
right-hand side of the production, pop three states: 
0 + 3 l-
and then push Goto[O][e1 to replace them: 
lo2 + 3 !-
Next, since Action[2][+1 is a s4, the parser goes to State 4 with a shift: 
lo24 3 I-
Action[4][NUM1 is an s1 so it shifts to State 1: 
lo241 I-
Action[1][1-1 calls for a reduction by Production 3: 
Section 5.3 -Implementing the Parser as a State Machine* 
lo245 I­
I-
Action[5][1-] is a reduction by Production 1: 
lo24 1-
02 
0 
02 I­
I-
1-
Action[1][1-] is an accept action, so the parse is finished. The tree implied by the previ­
ous parse is shown in Figure 5.3. 
Table 5.4. A Bottom-Up Parse of 1+2+3 Using a State Machine 
State Stack Symbols Input Notes 
0 $ 1+2+31- Push start state 
0 1 $NUM +2+31- Shift NUM 
0 $ +2+31- Reduce by t~NUM 
03 $t +2+31-
0 $ +2+31- Reduce by e~t 
02 $e +2+31-
024 $e+ 2+31- Shift+ 
0241 $e + NUM +31- Shift NUM 
024 $e+ +31- Reduce by t~NUM 
0245 $e+t +31-
024 $e+ +31- Reduce by e~e + t 
02 $e +31-
0 $ +31-
02 $e +31-
024 $e+ 31- Shift+ 
0241 $e+NUM 1- ShiftNUM 
024 $e+ 1- Reduce by t~NUM 
0245 $e+t 1-
024 $e+ 1- Reduce by e~e + t 
02 $e 1-
0 $ 1-
0 1 $e 1- Accept 
There is one difference between a symbol-oriented stack, as was discussed in the pre­
vious section, and a state stack: the latter requires an initial push of the start state that 
wasn't required on the symbol stack. I'm using a $ to hold the place of this extra stack 
item on the symbol stack. Also, note that the term accept is often used in two ways when 
PDA-based parsers are discussed. First of all, there are normal accepting states, in this 
case States 1, 2, 3, and 5. A transition into an accepting state signifies that a handle has 
been recognized. The action associated with these states is a reduce (and the associated 
code-generation actions, which are discussed below). You can also use the word accept 
to signify that a complete program has been parsed, however. If you look at the parser as 
a recognizer program, the machine as a whole accepts or rejects an input sentence. (A 
sentence in this context is a complete program, as represented by the grammar. A valid 
sentence in a grammar forms a complete parse tree.) 347 
Difference between sym­
bol and state stack. 
Accept. 
Reject. 
Sentence. 
348 
Stacklackslookaheadin­
formation for error 
recovery. 
Panic-mode error 
recovery. 
Avoid cascading error 
messages. 
Attributes in recursive 
descent. Bottom-Up Parsing-Chapter 5 
Figure 5.3. A Parse Tree for 1+2+3 
e ~ 
e + t 
/I~ I 
e t NUM 
I I 
t NUM 
I 
NUM 
5.4 Error Recovery in an LR Parser* 
Error recovery in a bottom-up parser is notoriously difficult. The problem is that, 
unlike a top-down parser's stack, the bottom-up parse stack contains no information 
about what symbols are expected in the input. The stack tells you only what's already 
been seen. One effective technique, called panic-mode error recovery, tries to get around 
this difficulty by using the parse tables themselves to find legal input symbols. It works 
as follows: 
(0) Error recovery is triggered when an error transition is read from the parse table 
entry for the current lookahead and top-of-stack symbols (when there's no legal 
outgoing transition from a state on the current input symbol). 
( 1) Remember the current condition of the stack. 
(2) Discard the state at the top of stack. 
(3) Look in the parse table and see if there's a legal transition on the current input sym­
bol and the uncovered stack item. If so, the parser has recovered and the parse is 
allowed to progress, using the modified stack. If there's no legal transition, and the 
stack is not empty, go to (2). 
(4) If all items on the stack are discarded, restore the stack to its original condition, dis-
card an input symbol, and go to (2). 
The algorithm continues either until it can start parsing again or until the complete input 
file is absorbed. Table 5.5 shows what happens when the incorrect input 1++2 is parsed 
using the simple LR state machine in Table 5.2 on page 345. Messages should be 
suppressed if a second error happens right on the tail of the first one in order to avoid 
cascading error messages. Nothing should be printed if an error happens within a limited 
number (four or five is a good choice) of parse cycles (shift or reduce operations) from 
the point of the previous error. 
5.5 The Value Stack and Attribute Processing* 
The next issue is how bottom-up parsers, such as the one generated by occs, handle 
attributes and use them to generate code. In a recursive-descent parser, attributes can be 
computed anywhere in the parse process, but they are only passed in two places: Inher­
ited attributes are passed when a subroutine is called, and synthesized attributes are 
passed when the subroutine returns. Since a table-driven LR parser doesn't use 
Section 5.5-The Value Stack and Attribute Processing* 
Table 5.5. Error Recovery for 1 ++ 2 
Stack Input Comments 
-1 + + 2 1-Shift start state -
0 1 + + 2 1-Shift NUM ( goto 1) $ 
0 I + + 2 1-Reduce by Production 3 (t~NVM) 
$ NUM (Return to 0, goto 3) 
0 3 2 1-Reduce by Production 2 (e~t) 
$ + + (Return to 0, goto 2) t 
0 2 2 1-Shift + ( goto 4) $ + + e 
0 2 4 + 2 1-ERROR (no transition in table) 
$ e + Pop one state from stack 
0 2 + 2 1-There is a transition from 2 on + 
$ e Error recovery is successful 
0 2 + 2 1- Shift + ( goto 4) $ e 
0 2 4 2 1- Shift NUM ( goto 1) $ e + 
0 2 4 I 2 1- Shift NUM ( goto 1) $ e + NUM 
0 2 4 I 1-Reduce by Production 3 (t~NVM) 
$ e + NUM (Return to 4, go to 5) 
0 2 4 5 1-Reduce by Production 1 (e~e+t) 
$ e + t (Return to 0, goto 2) 
0 2 1- Accept $ e 
subroutine calls, another method is required to pass attributes and execute code­
generation actions. To simplify matters, it's rarely necessary to use inherited attributes 
in a bottom-up parser; I'll concentrate on synthesized attributes only. 
Reviewing the relationship between a bottom-up parse and the parse tree itself, a 
production like e~t+e generates the following tree: 
e ~ 
+ e 
In a bottom-up parse, the t is pushed onto the stack by means of a reduction by t~NUM, 
the plus is just shifted, then there is a flurry of activity which terminates by the bottom e 
being pushed as part of a reduction by either e~e+t or e~t. In any event, once the t, 
plus, and e are on the stack, a handle is recognized; all three symbols are popped, and an 
e (the left-hand side) is pushed. Synthesized attributes move up the parse tree-from the 
children to the parent, and they are passed during a reduce operation-when the handle 
is replaced with the left-hand side. The synthesized attribute is attached to the left-hand 
side that is pushed as part of a reduce. Inherited attributes, which go from a parent to a 
child, would be pushed as part of a shift operation. The situation is simplified by ignor­
ing any inherited attributes, so attributes of interest are all passed during the reduce 349 
Bottom-up parser uses 
synthesized attributes. 
350 
Value, attribute stack. 
Bottom-up attribute pass­
ing, an example. 
The names of the tem­
poraries are on the value 
stack. Bottom-Up Parsing-Chapter 5 
operation-when the parser moves up the tree. If you reexamine the LR parse algorithm 
presented in Table 5.3 on page 346, you'll notice that code generation occurs only on a 
reduce operation. 
It turns out that the easiest place to store attributes is on the parse stack itself. In 
practical terms, you can do this in one of two ways, either make the state stack a stack of 
structures, one field of which is the state number and the rest of which is for attributes, or 
implement a second stack that runs parallel to the state stack. This second stack is called 
a value or attribute stack. Every push or pop on the state stack causes a corresponding 
push or pop on the value stack. All code-generation actions in a bottom-up parser are 
executed after the parser decides to reduce, but before the parser pops anything off the 
stack. So, you need to arrange for any attributes that are needed by a code-generation 
action to be on the value stack at the appropriate time. Similarly, the code-generation 
action needs to be able to put attributes onto the value stack for use by subsequent 
actions. I'll demonstrate with an example. 
Figure 5.4 shows a parse of 1+2+3 with both the state and value stacks shown (the 
value stack is on the bottom). Emitted code is printed to the right of the value stack. 
The attributes that appear on the value stack are the names of the temporary variables 
used in expression evaluation. (I'll demonstrate how they get there shortly.) I've used D 
to mark undefined value-stack entries. 
Look, initially, at stack number two in Figure 5.4. Here, a NUM has been shifted 
onto the stack and the corresponding value-stack item is undefined. The next stage in the 
parse is a reduce by t~NUM. Before the parser does the actual reduction, however, it 
executes some code. Two actions are performed: First, the tO=l instruction is gen­
erated. (The I is the lexeme attached to the NUM token that is shifted onto Stack 2 in 
Figure 5.4.) Next, the code that outputs the instruction leaves a note for the parser say­
ing that the attribute t 0 should be placed on top of the value stack after the reduction is 
performed. When the left-hand side is pushed as the last step of a reduction, the parser 
must push at 0 in the corresponding place on the value stack. 
The parser now does the actual reduction, popping the NUM from the state stack and 
replacing it with a t. It modifies the value stack too, popping one item and, instead of 
pushing garbage, it pushes a tO onto the value stack. In other words, the attribute tO on 
the value stack is now attached to the ton the state stack (because it's at the same rela­
tive position). The t has acquired the attribute t 0.1 
The next step in the parse process is application of e~t. No code is generated here. 
There is an associated action, however. The e must acquire the attributes formerly asso­
ciated with the t. So, again, the parser leaves a note for itself saying to push t 0 onto the 
value stack as it pushes the new left-hand side onto the state stack. 
The next transition of interest is the one from stack seven to eight. Here, the handle 
e+t is recognized and the parser applies e~e+t. Two actions are performed. At O+=t 1 
instruction is generated, and the attribute tO is acquired by thee (is passed to the e). The 
important thing to notice here is that the names of the two temporary variables are attri­
butes of e and t. The names of these variables are on the value stack. The code that gen­
erates the add instruction can discover these names by examining the cells at offsets zero 
and two from the top of the value stack. Moreover, the position of these attributes on the 
I. Note that it's a common, but incorrect, usage to say that the left-hand side inherits attributes from the 
right-hand side, probably because that's the way that control flows through the actual code (the child's 
code is executed first). I'd recommend against this usage because of the potential confusion involved. It's 
better to say that a parent acquires an attribute (or is passed an attribute) that's synthesized by the child. 
Section 5.5-The Value Stack and Attribute Processing* 
Figure 5.4. The Value Stack and Code Generation 
l. [~----------------
2. [ ~ --g~~ -----------
3. 
4. 
5. 
6. 
7. 
8. [$_--~-------------D tO 
[~--~0-----------­
[ ~--~0-~------- ---
[ ~ __ ~ O _ ~-__ ~U_M ____ _ 
[ ~ --~ 0 --~---~ 1-- - - - -
[ ~--~0------------
9. [ ~ --~ 0 -~----------
10 [ ~ - -~ 0 -~---6U_M __ - - -
II. [ ~ --~ 0 -~---~ 1------
12. [ ~ --~ 0 ------------
13. [ ~--~0--------- ---tO 1; 
t1 2; 
tO += t1; 
t1 3; 
tO += t1; 
(Accept) 
stack can be determined by examining the grammar. The handle on the stack comprises 
a right-hand side, so the position of the attribute on the stack corresponds to the position 
of the symbol on the right-hand side. The rightmost symbol is at top of stack. The e is 
two symbols away from the rightmost symbol in the production, so it's at offset two from 
the top of stack. 
The synthesized attribute here is the name of the temporary variable that holds the 
result of the addition at run time; the tO that's attached to the e on stack eight is the 
name of the anonymous temporary that holds the result of the entire subexpression 
evaluation. It's just happenstance that the attribute is the same one that was attached to 
the e in in stack seven. The e in stack eight is not the same e as the one in stack seven­
the one in stack eight is the one on the left-hand side of e~e+t, the e in stack seven is on 
the right-hand side of the same production. If the code generator had decided to emit an 
instruction like t3=t0+tl, then the synthesized attribute would have been t3. 
The next step in building a parser is to augment the earlier grammar to incorporate 
code-generation and attribute-passing rules. This augmentation is done in Table 5.6. 351 
Augmented and attribut­
ed grammars for bottom­
up parsing. 
352 
ss represents left-hand 
side. 
Parser maintains value 
stack. 
generate (), 
new_name (), 
free_name (). Bottom-Up Parsing-Chapter 5 
The actions are performed immediately before reducing by the associated production. 
The special symbol $$ is used to leave a note about what attribute to push. The value 
that's assigned to $$ in an action is, in tum, attached to the left-hand side that's pushed 
as part of the reduce operation. ($ $ is pushed onto the value stack when the new left­
hand side is pushed onto the parse stack.) The code assumes that the value stack is 
declared as an array of character pointers: 
char *Value_stack[128] ; 
char **Vsp = Value_stack + sizeof(Value_stack); 
Vsp is the stack pointer. The stack grows towards low memory: *--Vsp=value is a 
push and value=*Vsp++ is a pop.2 Consequently, Vsp [0] is the item at top of stack, 
Vsp [ 1] is the cell immediately below that, and so forth. 
Table 5.6. Expression Grammar with Actions 
Grammar Actions 
0. s ~ e generate( "answer = %s", Vsp[O] ) ; 
I. e ~ e+t generate( "%s += %s", Vsp [2], Vsp[O] ) ; 
free name( Vsp[O] ) ; -
$$ = Vsp[2]; 
2. e ~ t $$ = Vsp[O]; 
3. t ~ NUM name = new name (); 
generate( "%s = %s", name, yytext ) ; 
$$ = name 
The value stack is maintained directly by the parser. A place marker that correspond 
to the terminal that's pushed onto the parse stack is pushed onto the value stack during a 
shift. In a reduce, as many objects as are removed from the parse stack are also popped 
off the value stack, then $$ is pushed to correspond with the push of the left-hand side. 
The actions in Table 5.6 call three subroutines: generate ( ) works like 
print f ( ) , except that it puts a newline at the end of every line, new_ name ( ) returns 
a string that holds the name of a temporary variable, free_ name ( ) puts the name back 
into the name pool so that it can be reused by a subsequent new_ name ( ) call. The 
three routines are implemented in Listing 5.1. (Error detection has been removed for 
clarity.) The Names array is a stack of available temporary-variable names, initialized to 
hold eight names. Namep is the name-stack pointer. The new_ name ( ) subroutine pops 
a name and returns it; free_ name ( ) pushes the name to be freed. 
2. Downward-growing stacks are required by ANSI C unless you want to waste one cell of the array. An ANSI 
pointer is assumed always to point into an array, though it can go one cell past the end of the array. It 
cannot point below the base address of the array, however. The following code demonstrates the problem: 
int x[lO]; 
p = & x[lO]; I* this is valid *I 
p = x; I* this is valid *I 
--p; I* p is now undefined *I 
The problem is a real one in an 8086-family machine. lfx is at address 1000:0000, the--pin a compact­
or large-model program usually evaluates to I 000: fife rather than Oflf:flfe. Consequently p<x is always 
false because I 000: fife is larger than I 000:0000. 
Section 5.5.1-A Notation for Bottom-Up Attributes* 
Listing 5.1. support.c- Support Routines for Actions in Table 5.6 
#include <stdio.h> 
#include <stdarg.h> 353 
I 
2 
3 
4 
5 
6 
7 
8 
9 char *Names[] ={ "tO", "t1", "t2", "t3", "t4", "t5", "t6", "t7" }; 
char **Namep =Names; 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 void 
char 
{ generate( fmt, ... ) 
*fmt; 
va list 
va_start ( 
vfprintf ( 
fputc ( args; 
args, fmt ) ; 
stdout, fmt, args ); 
'\n', stdout ) ; 
char *new_name() 
if( Namep >=&Names[ sizeof(Names)/sizeof(*Names) ] ) 
{ 
printf("Expression too comp1ex\n"); 
exit ( 1 ) ; 
return( *Namep++ ); 
free_name(s) 
char *s; 
{ 
*--Namep s; 
5.5.1 A Notation for Bottom-Up Attributes* 
Though attributes are actually at specific offsets from the top of the value stack, it's 
inconvenient always to refer to them in terms of the stack pointer. Yacc and occs both 
use a notation for describing attributes that is sufficiently useful to merit mention here. 
(This notation is used heavily in the next chapter.) As before,$$ holds the value that is 
pushed as part of a reduction. Other attributes are indicated with the notation $1, $2, 
and so forth, where the number represents the position of the symbol on the right-hand 
side, for example: 
$$ 
s $1 
~ $2 
'13 $3 
c $4 
']) 
In addition, yacc and occs automatically provide a default action of $$ = $1 if no Bottom-up attribute nota­
tion: $$, $1, $2, etc. 
explicit assignment is made to$$. Don't confuse this notation with the similar notation Default action: $$=$1. 
used by LLama, in which the number in $n is the offset of a symbol to the right of an 
action. Here, n is the absolute position of the symbol on the right-hand side, not a rela-
tive position. 
Table 5.7 shows the augmented expression grammar we just looked at modified to 
use these conventions. The actions are all enclosed in curly braces to separate them from 
other symbols in the production. No explicit actions are now required in Production 2 
because the default $$=$1 is used. 
354 
Shift/reduce conflicts 
caused by imbedded ac­
tions. Bottom-Up Parsing-Chapter 5 
Table 5.7. Augmented Expression Grammar with Dollar Notation 
0. 
1. 
2. 
3. s ~ e generate( "answer = %s", $1 ) ; } 
e ~ e+t generate( "%s += %s", $1, $3 ) ; 
free name( $3 ) ; } -
e ~ t 
~ NUM name = new _name(); 
generate( "%s = %s", $$ name, yytext ) ; } 
5.5.2 Imbedded Actions* 
Note that the actions are not really grammatical symbols in a bottom-up parser, as 
they were in the top-down parser-the actions are not part of the viable prefix, they are 
just executed at appropriate times by the parser. In particular, an action is performed 
only when the parser performs a reduction. Hitherto, our actions have all been to the far 
right of the production to signify this fact. It's convenient sometimes to put an action in 
the middle of a production, however, as in the following production: 
function_body~arg_list {args_done ();} compound_stmt { funct_done ();} 
In order to process this sort of production, you must modify the grammar so that the mid­
dle action can be done as part of a reduction. The easiest way to do this is to provide a 
dummy E production as follows: 
function_ body 
dummy ~ arg_list dummy compound_stmt { funct_done ();} 
~ E { args_done ();} 
Both yacc and occs do this transformation for you automatically, but the extra E produc­
tion can often create parsing problems called shift/reduce conflicts, discussed below in 
detail. You can often eliminate the unwanted shift/reduce conflict by inserting an imbed­
ded action immediately to the right of a terminal symbol in the production, but it's gen­
erally better to avoid imbedded actions entirely. You could rearrange the previous gram­
mar as follows without introducing an E production: 
function_ body 
formal_ arg_list ~ formal_ arg_list compound _stmt { funct _done () ; } 
~ arg_list { args _done () ; } 
5.6 Creating LR Parse Tables-Theory* 
This section discusses how LR parse tables are created, and also discusses the LR­
class grammars in depth. 
5.6.1 LR(O) Grammars* 
I'll start discussing LR-class grammars by considering two, more restncttve LR 
grammars and why they're too limited for most practical applications. These are LR(O) 
grammars-LR grammars that require no lookahead tokens-and SLR(l) grammars 
(simple LR(l) grammars). The expression grammar in Table 5.8 is used throughout the 
current section. The nonterminals are +, *, (, ), and NUM (a number). Note that this 
grammar is not LL(l), so it can't be parsed with a top-down parser. The parse table for 
this grammar is represented as a graph in Figure 5.5 and in tabular form in Table 5.9. 
Section 5.6.1-LR(O) Grammars* 
Table 5.8. An Expression Grammar 
0: s ~ e 
1: e ~ e + t 
2: e ~ t 
3: t ~ t * f 
4: t ~ f 
5: f ~ ( e ) 
6: f ~ NUM 
Figure 5.5. LALR(1) State-Machine for Grammar in Listing 5.8 
I o. I 3. 7. 
I s~.e I e + J e~e+.t I? s~e. 
e~e.+t 
/ 
I (.uM f ) t 
It 
10. 
1"'--f I 5. I e~e+t. 
t~f. I t~t.*f 
* 
\[/ 
I~ 4. 8. * e~t. ------t ~ t * .f 
t~t.*f ( 
NUM f 
t f 
\___~ I 11. 
I"-< I 2. f I r~t*f. 
-Jf~(.e) I (u ~ e 6. 
NUM /~(e.) 
e~e.+t 
NUM 
II. I ) 
J f~NUM. L 
9. 
!~(e). 
The table and graph relate to one another as follows: 
• Each box is a state, and the state number is the row index in both the action and goto 
parts of the parse table. 
• Outgoing edges labeled with nonterminal symbols represent the goto part of the 
parse table-a number representing the nonterminal is used as a column index and 355 
I 
I 
+ 
How bottom-up parse 
table relates to state di­
agram. 
Nonterminal edges are 
goto entries. 
356 
Terminal edges are shift 
entries. 
Reduce directives. 
Error transitions. 
LR(O) items: Dots in pro­
ductions. 
Dot movement. Bottom-Up Parsing-Chapter 5 
Table 5.9. State-Transition Table for Grammar in Table 5.8 
Shift/Reduce Table (Yy action) Goto Table (Yy goto) 
r NUM + * ( ) s e t f 
0 - si --s2 - - 3 4 5 
I r6 -r6 r6 -r6 ----
2 - si --s2 --6 4 5 
3 accept -s7 -- - - - - -
4 r2 -r2 s8 -r2 --- -
5 r4 -r4 r4 -r4 - - - -
6 - - s7 - - s9 --- -
7 - si --s2 -- - 10 5 
8 - sl - - s2 -- - - II 
9 r5 -r5 r5 -r5 - - - -
10 ri -ri s8 -ri -- - -
II r3 -r3 r3 -r3 ----
sN=shift to state N. rN=reduce by production N. 
Error transitions are marked with -. 
the table holds the next-state number. Remember that this path represents the push 
part of a reduction. 
• All outgoing edges that are labeled with terminal symbols become shift directives in 
the action part of the parse table. The token value is used as a column index, and the 
parser shifts from the current to the indicated state when it encounters that token. 
• Reduce directives in the parse table are found by looking at the productions in each 
state. A reduction happens from a state when a production has a dot at its far right. 
A reduction by f~NUM can happen from State I because State I has the production 
f~NUM. in it. (Remember, the dot to the right of the NUM signifies that aNUM 
has already been read and shifted onto the stack.) I'll describe how occs decides in 
which column to put the reduce directives in a moment. 
• Everything else in the table is an error transition. 
The productions in the bottom part of each state are LR(O) items; an LR(O) item is 
diffurent from a production in that it is augmented with a dot, which does two things. 
First, it keeps track of what's on the parse stack-in a given state, everything to the left 
of the dot is on the stack. When a dot moves to the far right of a production, the entire 
right-hand side is on the stack and the parser can reduce by that production. Second, the 
dot shows you how much input has been read so far-everything to the right of the dot in 
an item for a given state has not yet been input when the parser is in that state. Conse­
quently, symbols to the right of the dot can be used as lookahead symbols. 
When you move from one state to another, the dot moves from the left of the symbol 
with which the edge is labeled to the right of that symbol. In the case of a terminal sym­
bol, the dot's movement means that the parser has read the token and shifted it onto the 
stack. In the case of a nonterminal, the parser will have read all the input symbols that 
comprise that nonterminal-in terms of parse trees, the parser will have processed the 
entire subtree rooted at that nonterminal, and will have read all the terminal symbols that 
form leaves in the subtree. In other words, the dot movement signifies that the parser has 
pushed a nonterminal onto the stack-something that can happen only as part of a reduc­
tion. When the parser reduces, it will have processed all of the input associated with the 
pushed nonterminal. 
Section 5.6.1-LR(O) Grammars* 
Now, I'll demonstrate how particular items get into particular states. First, notice 
that there are two classes of states: those that have incoming edges labeled with terminal 
symbols, and those with incoming edges labeled with nonterminal symbols. There are 
no states with both kinds of incoming edge-it's either one or the other. I'll look at the 
two classes of states separately. 
Start by considering how the parse works. From State 0, a NUM token causes a shift 
to State I, which in turn causes the dot to move past the NUM. Since the parser just 
shifted the NUM to the stack, it's at the top of the stack, and the dot is to its immediate 
right. Since all transitions into State 5 involve a shift of a NUM, all items in State 5 
must have a NUM immediately preceding the dot. This is the case with all states that 
have incoming edges labeled with terminal symbols. The dot follows that nonterminal in 
every item in the state. 
You must examine the reduce operation to see what's happening with the other 
states. All reductions are done in two steps. First, a previous state is restored by going 
backwards through the machine (against the direction of the arrows) by popping as many 
states as there are symbols on a right-hand side of the production. Next, the parser 
makes a transition to a new state by following an edge labeled with the left-hand side of 
the production by which you're reducing. These next states comprise the goto part of the 
parse table. 
We're interested in the second of these steps, the outgoing edges that are labeled with 
left-hand sides. Looking at an example, since the dot is to the far right of the production 
in State 5, the parser reduces from State I by applying f~NUM. The reduction involves 
a single pop, which uncovers State 0, followed by a push of the f, which moves us to 
State 5. Looking at the items in State 5, you'll notice that the dot follows the f. Since an 
f must be on top of the stack in this state, the dot must be to the immediate right of the f 
in all items in State 5. The next reduction is by t~f and gets us, first back to State 0, and 
then to State 4. Since a t must now be at top of stack, all items in State 4 have a dot to 
the immediate right of t. Let's look at it another way. State 0 contains the item 
[e~. e + t].3 A reduction by some production that has an eon its left-hand side causes us 
to return to State 0 and then go to State 3. When the parser does this reduction, it has 
read past all input symbols that comprise the e, and the following item appears in State 3 
to signify this fact: [e~e. + t]. Given the foregoing, you can create the parse table with 
the following procedure: 
(1) Initialize: State 0 is the start state. Initially, it contains a single LR(O) item con­
sisting of the start production (the one with the goal symbol as its left-hand side), 
and a dot at the far left of the right-hand side. The initial set of items in this state 
(and all other states) is called the kernel or seed items. The set of kernel items for 
the start state looks like this: 
I ~~.e 357 
Adding items to states. 
Procedure for creating 
bottom-up parse tables. 
Initialization. Start pro­
duction. 
Kernel, seed items. 
(2) Close the kernel items: The kernel items for the next states are created with a clo-Closure. 
sure operation, which creates a set of closure items. Closure is performed on those 
kernel items that have a nonterminal symbol to the right of a dot. (I'll call this non-
terminal symbol the closure symbol.) Add to the closure set items for those 
3. Items are usually differentiated from simple productions by surrounding them with brackets, as is done 
here. 
358 
Transition symbols. Bottom-Up Parsing-Chapter 5 
productions which, when reduced, can return us to the current state. 
(a) Initiate the closure process by adding to the closure set all productions that 
have the closure symbol on their left-hand side. Remember, if the dot is to the 
left of a nonterminal, there will be an outgoing transition from the current 
state (labeled with that nonterminal), and that transition represents the push 
part of a reduction. Consequently, productions with that nonterminal on their 
left-hand side could return us to the current state when a reduction by that 
production is performed. 
The new item is formed by placing a dot at the far left of the right-hand side 
of the production. In the current grammar, since an e is to the right of the dot 
in all the kernel items, items containing all productions with an e on their 
left-hand side are added. The closure set looks like this so far: 
0 
s~.e 
e~.e+t 
e~.t 
(b) Repeat the closure process on the newly added items. If a newly added item 
has a nonterminal to the right of the dot, and closure has not yet been per­
formed on that nonterminal, add to the closure set all productions that have 
that nonterminal as their left-hand side. In the current example, the second 
production has a t to the right of the dot, so I'll add all productions with t on 
their left-hand side, yielding the following: 
0 
s~.e 
e~.e+t 
e~.t 
t~.t*f 
t~.f 
(c) Repeat (b) until no more items can be added. A production with an f to the 
right of a dot was added in the previous step, so the closure set is extended to 
include all productions that have f on their left-hand sides, yielding: 
0 
s~.e 
e~.e+t 
e~ .t 
t~.t*f 
t~.f 
f~.(e) 
f~.NUM 
Since none of the new productions have dots to the left of a nonterminal, the 
procedure is complete. 
(3) Form the kernel items for the next states: 
(a) Partition the items: Group together all items in the current state (both kernel 
and closure items) that have the same symbol to the right of the dot. I'll call 
this symbol the transition symbol, and all items that share a transition symbol 
form a partition. The following picture shows the items partitioned by sym­
bol to the right of the dot. 
Section 5.6.1 -LR(O) Grammars* 
0. 
s--+. e 
e-+.e+t 
e--+. t 
t-+.t*f 
t--+ .f 
f-+.(e) 
f-+. NUM 
Partitions that have dots at the far right of the productions do not form new 
states because they represent reductions from the current state. (There will 
be, at most, one of these partitions, and all E productions are part of this parti­
tion.) All other partitions form the kernels of the new states. 
(b) Form the kernel items for the next states: Modify the items in those parti­
tions that form the new states by moving the dot one notch to the right, and: 
(c) Add next-state transitions: If a state already exists that has the same set of 
kernel items as the modified partition, add an edge labeled with the transition 
symbol that goes from the current state to the existing state. Otherwise, create 
a new state, using the group of modified items as the kernel items. Add an 
edge from the current state to the new one on the transition symbol. 
(4) Repeat steps (2) and (3) on the kernel items of any new states until no more states 
can be added to the table. 
Figure 5.6 shows a complete state machine built from our grammar using the forego­
ing procedure. The initial state is State 0, the first pass of the algorithm added States 1 to 
5, and soon. 359 
The issue of E productions deserves further mention. E productions are special only E productions in bottom­
in one way. There are no outgoing edges from any state that are labeled E; rather, if an E up parse tables. 
production is added to a state as part of a closure operation, the machine reduces from 
the current state on that production. In other words, the right-hand side of an E produc-
tion effuctively has the dot at its far right to begin with-the E may as well not be there 
because it represents an empty string. Consider a grammar such as the following frag-
ment: 
s ~ ab 
b ~ E 
I X 
which generates the following states: 
2 
ls~.ab I a 
s~a.b I 
b~.E 
h~.x 
X 
4 It 
b~X. 3 
b _I 
1s~ab. I 
The item [a~a.b] adds the closure items [b~E.] and [b~.X], the latter of which 
appears as [b~X.] in State 4. If b goes toE in State 2, a reduction is performed from that 
state. Since there are no symbols on the right-hand-side, you won't pop anything off the 
state stack, so you won't change states in the first part of the reduce. Nonetheless, since 
b is the left-hand side of the production, you do want to go to State 2 in the goto part of 
360 Bottom-Up Parsing-Chapter 5 
Figure 5.6. An LR(O) State Machine 
0 
s~.e 
e~.e+t 
e ~ .t 
t~.t*f 
t~ .f 
f~.(e) 
f~. NUM 
\.._f 
\.._ t 
I~ ( 
NUM 
Shift/reduce, 
reduce/reduce conflicts. 
Inadequate states. 3 7 
e + e~e+.t ~ s~e. 
e~e.+t 1-?.t*f 
t~ .f 
f~.(e) 
I / f~.NUM 
f ) NUM t 
10 
5 J e~e+t. 
t~f. J t~t.*f 
* 
I; 
4 8 
""7 e ~t. * t ~ t * .f 
t~t.*f ------
f~.(e) 
/ f~.NUM 
t f 
NUM f 
~ 2 I II I 
/~(.e) ~ I r~r*t. I 
e~.e+t 
(c-7 e ~. t + 
t~.t*f 
t~ .f 6 
f~.(e) e f~(e.) 
f~.NUM e~e.+t 
NUM ) 
I 9 
-:7!. f ~ NUM . L /~(e). 
the reduce operation, so there's a transition on h from State I. 
Unfortunately, LR(O) state machines have problems. As I said earlier, a reduction is 
performed from any given state if a dot is at the far right of an item, and a terminal sym­
bol is shifted if the dot is to its immediate left. But consider a state like State 4 in Figure 
5.6, where one of the items has a dot to the far right, and the other has a dot buried in the 
middle of the production. Should the parser shift or reduce? This situation is called a 
shift/reduce conflict. It's also possible for a state to have two items with different pro­
ductions, both of which have dots at the far right. This situation is called a conflict-1'11 
look at one in a moment. States that contain shift/reduce or reduce/reduce conflicts are 
called inadequate states. A grammar is LR(O) if you can use the foregoing procedures to 
Section 5.6.1-LR(O) Grammars* 
create a state machine that has no inadequate states. Obviously, our current grammar is 
not LR(O). 
5.6.2 SLR(1) Grammars* 
There is a simple way to resolve some shift/reduce conflicts. Remember how the 
FOLLOW sets were used to form LL( I) select sets in the previous chapter. If a right­
hand side was nullable, you could apply that production if the lookahead symbol was in 
the FOLLOW set of the left-hand side, because there could be a derivation in which all 
elements of the right-hand side could effectively disappear, and the symbol following the 
left-hand side would be the next input symbol in this case. 
You can use similar reasoning to resolve shift/reduce conflicts. In order to do a 
reduction, the next input symbol must be in the FOLLOW set of the nonterminal on the 
left-hand side of the production by which we're reducing. Looking at State 3 in the 
LR(O) machine in Figure 5.6, you can reduce by s~e if the lookahead symbol is in 
FOLLOW( s ). Similarly, you must shift if the lookahead symbol is a plus sign. As long 
as FOLLOW( s) doesn't contain a plus sign, the shift/reduce conflict in this state can be 
resolved by using the next input symbol. If all inadequate states in the LR(O) machine 
generated from a grammar can be resolved in this way, then you have an SLR(I) gram­
mar. 
The FOLLOW sets for our current grammar are in Table 4.17. Looking at the 
shift/reduce conflict in State 4, FOLLOW(e) doesn't contain a *, so the SLR(I) method 
works in this case. Similarly, in State 3, FOLLOW(s) doesn't contain a +, so 
everything's okay. And finally, in State 10, there is an outgoing edge labeled with a *, 
but FOLLOW(e) doesn't contain a *· Since the FOLLOW sets alone are enough to 
resolve the shift/reduce conflicts in all three states, this is indeed an SLR( I) grammar. 
Table 5.10. FOLLOW Sets for the Expression Grammar 
FOLLOW(s) -{1-1 
FOLLOW(e) - { 1-) +I 
FOLLOW(t) - { 1-) + *I 
FOLLOW(/) - { 1-) + * I 
5.6.3 LR(1) Grammars* 
Many grammars are not as tractable as the current one-it's likely that a FOLLOW 
set will contain symbols that also label an outgoing edge. A closer look at the machine 
yields an interesting fact that can be used to solve this difficulty. A nonterminal's FOL­
LOW set includes all symbols that can follow that nonterminal in every possible context. 
The state machine, however, is more limited. You don't really care which symbols can 
follow a nonterminal in every possible case; you care only about those symbols that can 
be in the input when you reduce by a production that has that nonterminal on its left­
hand side. This set of relevant lookahead symbols is typically a subset of the complete 
FOLLOW set, and is called the lookahead set. 
The lookahead set associated with a nonterminal is created by following a production 
as it moves through the state machine, looking at those terminal symbols that can actu­
ally follow the nonterminal just after~ reduction. In the case of the inadequate State 10, 
there are two paths from State 0 to State 10 (0-3-7-10 and 0-2-6-7-10). For the pur­
poses of collecting lookaheads, the only important terminals are those that follow non­
terminal symbols preceded by dots. (We're looking for the sequence: dot-nonterminal­
terminal.) Remember, here, that we're really figuring out which elements of the 361 
Use FOLLOW sets to 
resolve conflicts. 
Some symbols in FOL­
LOW set are not needed. 
Lookahead set. 
Creating lookahead sets. 
362 
LR(1) items. 
Creating LR(1) state 
machines. Bottom-Up Parsing-Chapter 5 
FOLLOW set tell us whether or not to reduce in a given situation. If a dot precedes a 
nonterminal, then that nonterminal can be pushed onto the parse stack as part of the 
reduction, and when the non terminal is pushed, one of the terminals that follows it in the 
grammar better be in the input. 
Look at State 0 in Figure 5.6. The parser can enter State 0 in the middle of a reduc­
tion by some production that has an e on its left-hand side, and it will exit State 0 by the 
e edge. This edge was created because a dot preceded an e in some item in that state. 
Looking at State 0 again, a plus can be in the input when the parser reduces by a produc­
tion with e on its left-hand side because of the item: 
[e ~ • e + t] 
If the parser enters State 0 in the middle of a reduction by a production with e on its 
left-hand side, then a + could reasonably be the next input symbol. Looked at another 
way, after all the tokens that comprise thee are read,+ could be the next input symbol in 
this context. There's also an implied end-of-input marker in the start production, so 
[s ~ • e 1-] 
tells us to add t-to the lookahead set. The item: 
[f ~ • ( e )] 
doesn't add anything to the lookahead set, even though it has an e in it, because this item 
isn't considered when a reduction is performed (the dot doesn't precede the e). Of the 
other states along the two paths from State 0 to State 10, the only other lookahead is 
added in State 4, because of the item: 
[f ~( • e )] 
If the parser enters State 4 in the middle of a reduction by some production with an e on 
its left-hand side, then a right parenthesis is also a possible input character. When you 
get to State 10, the only elements of FOLLOW(e) that can actually follow an e !!! this 
context are the elements that you've collected by looking at things that can actually fol­
low an e in some state on the path from the start state to State I 0. This set of lookaheads 
has only three elements: +,),and t-. A* is not part of this set, so a* cannot legally fol­
low thee in this context, and the parser doesn't have to consider the* when it's deciding 
whether to reduce from State 10. It can safely reduce if the lookahead symbol is a +, ), 
or t-, and shift on a*· 
Formalizing the foregoing procedure, an LR( 1) item is an LR(O) item augmented with 
a lookahead symbol. It has three parts (a production, a dot, and a lookahead) and is typi­
cally represented like this: [s~a.. ~. D], where D is the lookahead symbol. Note that 
the lookahead is part of the item; two items with the same production and dot position, 
but with different lookaheads, are different items. 
The process of creating an LR(l) state machine differs only from that used to make 
an LR(O) machine only in that LR(l) items are created in the closure operation rather 
than LR(O) items. The initial item consists of the start production with the dot at the far 
left and t-as the lookahead character. In the grammar we've been using, it is: 
[s~. e, 1-] 
An LR(l) item is created from a kernel item as follows: Given an item and a production 
that take the following forms: 
[s ~ a. .x ~. C] 
X ~ •"f 
Section 5.6.3-LR( I) Grammars* 363 
(s and x are nonterminals, a, ~. and yare collections of any number of terminals and non- (s~a: • x ~. CJ. 
terminals ["any number" includes zero], and Cis a terminal symbol) add: 
[x~.y. FIRST(~ C)]. 
to the closure set. FIRST(~ C) is computed like FIRST of a right-hand side. If~ is not [x~.y. FIRST(~ C)]. 
nullable, then FIRST(~ C) is FIRST(~). otherwise it is the union of FIRST(~) and C. 
Looking at a real situation, the start production relates to the previous formula as fol­
lows: 
s ~ a X ~. c 
e, 
Note that both a and ~ match empty strings in this situation. Using the previous for-a: and 13 can be empty. 
mula, there are two productions that have eon the left-hand side: e~e+t and e~t. so add 
the following to the closure set: 
s ~ .y, FIRST(~ C) 
e ~ • e + t, FIRST(£ 1-) 
e ~ • t, FIRST(£ 1-) 
I'm using E here to signify that ~ in the original item matched an empty string. 
FIRST(EI-) is { 1-1. Continue the closure operation by closing both of the newly added 
items: The first one is: 
s ~ a X ~. c 
e ~ e + t, 1-
so add: 
s ~ .y, FIRST(~ C) 
e ~ • e + t, FIRST(+ t 1-) 
e ~ • t, FIRST(+ t 1-) 
Note that these items differ from the previous ones only in the lookahead sets. Since+ is 
not nullable, FIRST(+ t 1-) is+. The second production derived directly from the kernel 
item was: 
s ~ a X ~. c 
e ~ 1-
so add: 
s ~ .y, FIRST(~ C) 
~ • t * f, FIRST(£ 1-) 
~ .f. FIRST(£ 1-) 
The process continues in this manner until no more new LR( l) items can be created. The 
next states are created as before, adding edges for all symbols to the right of the dot and 
moving the dots in the kernel items of the new machine. The entire LR( I) state machine 
for our grammar is shown in Figure 5.7. I've saved space in the Figure by merging 
together all items in a state that differ only in lookaheads. The lookaheads for all such 
items are shown on a single line in the right column of each state. Figure 5.8 shows how 
the other closure items in State 0 are derived. Derivations for items in States 2 and 14 of 
the machine are also shown. 
The LR( I) lookaheads are the relevant parts of the FOLLOW sets that we looked at 
earlier. A reduction from a given state is indicated only if the dot is at the far right of a 
production and the current lookahead symbol is in the LR( l) lookahead set for the item 
364 
E items. Bottom-Up Parsing-Chapter 5 
Figure 5.7. LR(l) State Machine 
0 3 7 
s~.e 1-e 1-+ --" e~e+.t 1-+ A s~e. 
e~.e+t 1-+ e~e.+t 1-+ t~.t*f 1-+* 
e~ .t 1-+ t~.f 1-+* 
t~.t*f 1-+* f~.(e) 1-+* 
t~.f 1-+* / / f~.NUM 1-+* 
f~.(e) 1-+* 
f~.NUM 1-+* f ) NUM t 
10 
1\! 15 I e~e+t. 1-+ 
J t~f. 11-+*I t~t.*f 1-+* 
* 
\I 
1~-7 4 8 
e~t. II-+ * t~t*.f 1-+* 
t~t.*f 1-+* ---
f~.(e) 1-+* IYJ-..NUM 1-+* 
NUM f 
,/~ \ 
I~ 2 I II I 
f~(.e) 1-+* I ~~t*f. 11-+*I 
e~.e+t +) t f NUM ( >® e~. t +) 
t~.t*f +)* + 
t~.f +)* 6 
f~.(e) +)* e f~(e.) II-+* f~.NUM +)* e~e.+t +) 
) 
NUM J J~NUM. l1-+*I"' 9 
f~(e). lr+* 
that contains that production. As before, a shift is indicated when the lookahead symbol 
matches a terminal label on an outgoing edge; outgoing edges marked with nonterminals 
are transitions in the goto part of the parse table. If there's a conflict between the looka­
head sets and one of the outgoing edges, then the input grammar is not LR( 1 ). 
E items are special only in that they're a degraded case of a normal LR(l) item. In 
particular, E items take the form [s~E ., C], where the lookahead C was inherited from 
the item's parent in the derivation tree. An E item is never a kernel item, so will never 
generate transitions to a next state. The action associated with an E item is always a 
reduce on C from the current state. 
Section 5.6.3-LR(l) Grammars* 
Figure 5.7. continued. LR(l) State Machine 
16 
A + e~ e +. 1 +) IE:-
(--';. t * f +)* 
l~ . .r +)* 
.r~. (e) +)* 
/ I f~.num +)* 
f ) NUM t 
17 
112 I e~ e + 1. +) 
f ~~.r. I + > * I ~~I.* f +)* 
* 
\II 
13 18 
~ e~l. I +) * ~~I* .f +)* 
~~I. *f" +)* r------
.r~.(e) +)* 
y .f~. NUM +)* 
t f 
NUM .f 
14 / 1 19 I ( 
/ f~( .e) +)* ~~ I ~~I* t. I + > * I 
e~. e + 1 +) 
B (c e~. 1 +) 
~~ .l*.f +)* 
~~ .f +)* 20 
f~.(e) +)* e .r~< e.) 
.f~. NUM +)* e~ e.+ I 
NUM ) 
NUM 
15 21 
_,{/-~ NUM. I+)* .r~ (e). 
5.6.4 LALR(1) Grammars* 
The main disadvantage of a LR( I) state machine is that it is typically twice the size 
of an equivalent LR(O) machine, which is pretty big to start out with [the C grammar 
used in the next chapter uses 287 LR(O) states]. Fortunately, it's possible to have the 
best of both worlds. Examining the LR( I) machine in Figure 5.7, you are immediately 
struck by the similarity between the two halves of the machine. A glance at the looka­
heads tells you what's happening. A close parenthesis is a valid lookahead character 
only in a parenthesized subexpression-it can't appear in a lookahead set until after the 
open parenthesis has been processed. Similarly, the end-of-input marker is not a valid 
lookahead symbol inside a parenthesized expression because you must go past a close + 
I +) * +) 
I + > * 365 
366 
Figure 5.8. Deriving Closure Items for LR(I) States 0, 2 and 14 
Gil'en:[s ~a. x ~. c] and x~y 
Add: [x ~ .y, FIRST(~ c)] State 0 
s~ .e 
f~.(e) t-
States 2 and 14 
e~(.e) 
f~. (e) + Bottom-Up Parsing-Chapter 5 
f~. NUM 
parenthesis first. The outer part of the machine (all of the left half of Figure 5.7 except 
States 6 and 9) handles unparenthesized expressions, and the inner part (States 6 and 9, 
and all of the right half of Figure 5.7) handles parenthesized subexpressions. The parser 
moves from one part to the other by reading an open parenthesis and entering State 2, 
which acts as a portal between the inner and outer machines. The parser moves back 
into the outer part of the machine by means of a reduction; it pops enough items so that 
the uncovered state number is in the outer machine. 
You can take advantage of the similarity between the machines by merging them 
together. Two LR( I) states can be merged if the production and dot-position 
Section 5.6.4-LALR(l) Grammars* 
components of all kernel items are the same. The states are merged by combining the 
lookahead sets for the items that have the same production and dot position, and then 
modifying the next-state transitions to point at the merged state. For example, States 2 
and 14 are identical in all respects but the lookaheads. You can merge them together, 
forming a new State 2/14, and then go through the machine changing all next-state tran­
sitions to either State 2 or State 14 to point at the new State 2/14. This merging process 
creates the machine pictured in Figure 5.9. 
Figure 5.9. LALR( 1) State Machine for the Expression Grammar 
0 3 7/16 
s-+. e r-e 
I~+ + e-+ e +. t r+) s-+e. 
e-+.e+t r+ e-+ e.+ t t-+. t * f r+) * 
e--+. t r+ t-+ .f r+) * 
t-+. t * f r+* !--+. (e) r+) * 
t-+ .f r+* / / f~.NUM r+) * 
!--+. (e) r+* 
f~.NUM r+* f ) NUM t 
10/17 
I"' t 5/12 I e-+ e + t. r+) 
t-+f. lr+) *I t-+ t. * f r-+) * 
* 
\II 
I"' r 4/13 8/18 
..., e-+ t. lr+) t-+t*.f r+) * * t-+ t. * f r+) * r-----!--+. (e) r-+) * 
IY f-+ .NUM r+) * 
t f 
NUM f 
/ 
2/14 ~ I 11/19 ~ 
I "'-( !--+ (.e) r+) * ~ I t-+ t *f. I r+) *I 
e-+. e + t +) 
e-+. t +) + 
t-+. t * f +)* ( t-+ .f +)* 6/20 
!--+. (e) +)* e !--+ (e.) I r+) * ----;;il f~.NUM +)* e-+ e.+ t +) 
NUM ) 
NUM 
1/15 9/21 
--71j~NUM. lr+) * !--+ (e). I r+) * 367 
The merging process does not affect error detection in the grammar. It usually takes 
a little longer for the merged machine to detect an error, but the merged machine reads 
no more input than the unmerged one. There is one pitfall, however. The merging does, Merging does not affect 
error recovery, might add 
inadequate states. 
368 
Manufacturing the tables. 
More efficient table­
generation methods. 
Positive numbers=shift, 
Negative 
numbers=reduce, O=ac­
cept. 
LALR(1) parse-table size. 
Pair-compression in 
LALR(1) parse tables. Bottom-Up Parsing-Chapter 5 
after all, add elements to the lookahead sets. Consequently, there might be inadequate 
states in the merged machine that are not present in the original LR( 1) machine. (This is 
rare, but it can happen.) If no such conflicts are created by the merging process, the 
input grammar is said to be an LALR(l) grammar. 
If you compare the LALR(l) machine in Figure 5.9 with the LR(O) machine in Fig­
ure 5.6 on page 360 you'll notice that the machines are identical in all respects but the 
lookahead characters. This similarity is no accident, and the similarity of the machines 
can be exploited when making the tables; you can save space when making an LALR(l) 
machine by constructing an LR(O) machine directly and adding lookaheads to it, rather 
than creating the larger LR(l) machine and then merging equivalent states. You can do 
this in several ways-the method used by occs is the simplest. It proceeds as if it were 
making the LR( 1) machine, except that before creating a new state, it checks to see if an 
equivalent LR(O) state (an LR(1) state with the same productions and dot positions in the 
kernel) already exists. If it finds such a state, occs adds lookaheads to the existing state 
rather than creating a new one. I'll look at this procedure in depth, below. 
There are other, more efficient methods for creating LALR(l) machines directly from 
the grammar that I won't discuss here. An alternate method that is essentially the same 
as the foregoing, but which uses different data structures and is somewhat faster as a 
consequence, is suggested in [Aho], pp. 240-244. An LR(O) state machine is created and 
then lookaheads are added to it directly. You can see the basis of the method by looking 
at Figure 5.8 on page 366. Lookaheads appear on the tree in one of two ways, either they 
propagate down the tree from a parent to a child or they appear spontaneously. A looka­
head character propagates from the item [s~a.xj3,c] to its child when FIRST(j3) is null­
able. It appears spontaneously when FIRST(j3) contains only terminal symbols. An even 
more efficient method is described in [DeRemer79] and [DeRemer82]; it is summarized 
in [Tremblay], pp. 375-383. 
5. 7 Representing LR State Tables 
The LALR( 1) state machine is easily represented by a two dimensional array of 
integers, where the value of the number represents the actions. The row index is typi­
cally the state number, and the columns are indexed by numbers representing the tokens 
and non terminals. The LALR( 1) state machine in Figure 5.9 is represented by the two­
dimensional array in Table 5.11. (This is the same table as in Figure 5.9.) Shifts can be 
represented by positive numbers, and reductions can be represented with negative 
numbers. For example, a s6 directive can be represented by the number 6, and an r5 can 
be represented by a -5. A very large integer that's not likely to be a state number can be 
used to signify error transitions. The accept action, which is really a reduction by Pro­
duction 0, can be represented by a zero. 
Though the table can be represented by a two-dimensional array, such a table is 
likely to be very large. Taking the C grammar that's used in the next chapter as charac­
teristic, the grammar has 182 productions, 50 terminal symbols, and 75 nonterminal sym­
bols. It generates 310 LALR(l) states. The resulting LALR(l) transition matrix has as 
many rows as there are states, and as many columns as there are terminal and nontermi­
nal symbols (plus one for the end-of-input marker), so there are (50+ 75+ 1) = 125 
columns and 310 rows, or 38,750 cells. Given a 2-byte int, that's 77,500 bytes. In most 
systems, it's worthwhile to minimize the size of the table. 
Only 3,837 cells (or 10%) of the 38,750 cells in the uncompressed table are nonerror 
transitions. As a consequence, you can get considerable compression by using the pair­
compression method discussed in Chapter Two: Each row in the table is represented by 
an array, the first element of which is a count of the number of pairs in the array, and the 
Section 5.7-Representing LR State Tables 
Table 5.11. Tabular Representation of Transition Diagram in Figure 5.9 
Shift/Reduce Table (Yy action) Goto Table (Yy goto) 
1-NUM + * ( ) s e t f 
0 - sl - - s2 --3 4 5 
I r6 -r6 r6 -r6 - - - -
2 - sl - - s2 - - 6 4 5 
3 accept -s7 -- - - - - -
4 r2 -r2 s8 -r2 -- - -
5 r4 -r4 r4 -r4 -- - -
6 - - s7 - - s9 - - - -
7 - sl --s2 - - - 10 5 
8 - sl - - s2 - - - - II 
9 r5 -r5 r5 -r5 - - - -
10 rl -rl s8 -rl ----
II r3 -r3 r3 -r3 -- - -
Error transitions are marked with -
remainder of which is series of [nonterminal,action] pairs. For example, Row 4 of the 
transition matrix can be represented as follows: 
state_ 4 [ J = { 4, [), r2], [ +, r2], [I-, r2], [ *, s8] } ; 
The initial 4 says that there are four pairs that follow, the first pair says to reduce by Pro­
duction 2 if the input symbol is a close parentheses, and so forth. If the current input 
symbol is not attached to any pair, then an error transition is indicated. 
Another array (call it the index array) is indexed by state number and each cell evalu­
ates to a pointer to one of the pairs arrays. If an element of the index array is NULL, 
then there are no outgoing transitions from the indicated state. If several rows of the 
table are identical (as is the case in the current table), only a single copy of the row 
needs to be kept, and several pointers in the index array can point at the single row. The 
goto portion of the table is organized the same way, except that the row array contains 
[nonterminal, next state] pairs. Figure 5.10 shows how the table in Listing 5.11 is 
represented in an occs output file. The actual code is in Listing 5.2. 
The Yya arrays on lines 20 to 28 of Listing 5.2 represent the rows, and Yy _act ion 
(on lines 30 to 34) is the index array; the pairs consist of tokenized input symbols and 
action descriptions, as described earlier. The values used for tokens are as follows: 
Token Value returned from 
lexical analyzer 
1- 0 
NUM I 
+ 2 
* 3 
( 4 
) 5 
Looking at row four of the table (Yya004 on line 23), the pair [5,-2] is a reduction by 
Production 2 (-2) on a close parenthesis (5). [3,8] is a shift to State 8 (8) on a * (3), and 
so on. The tables can be decompressed using the yy _next () subroutine in Listing 5.3. 369 
YyaN arrays, Yy_action 
Parse-table decompres­
sion. 
370 Bottom-Up Parsing-Chapter 5 
Figure 5.10. Actual Representation of Parse Tables for Grammar in Listing 5.8 
Yy_action 
0 ~2 4,2 1,1 J YyaOOO 
~ / '· 5, 6 3, 6 2, 6 0, 6 I Yya001 
2 ....---
3 // 2 0,0 2, 7 I Yya003 
4 // 4 5, 2 2, 2 0, 2 3, 8 I Yya004 
5 4 5, 4 3, 4 2, 4 0, 4 I Yya005 
6 // 2 5, 9 2, 7 I Yya006 
7 :) / 
8 
9 4' 5, 5 3, 5 2, 5 0, 5 I Yya009 
10 4, 5, 1 2, 1 0, 1 3,8 I Yya010 
II 4, 5, 3 3, 3 2, 3 0, 3 I YyaOll 
Yy_goto 
0 3 3,5 2,4 1, 3 I YygOOO 
NULL 
2 3 3, 5 2,4 1, 6 I Yyg002 
3 NULL 
4 NULL 
5 NULL 
6 NULL 
7 2 3, 5, 2,10 I Yyg007 
8 1 3,11 I Yyg008 
9 NULL 
10 NULL 
II NULL 
Listing 5.2. C Representation of the Parse Tables 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 /*-----------------------------------------------------
* The Yy action table is action part of the LALR(1) transition 
*matrix. It's compressed and can be accessed using the yy_next() 
* subroutine, declared below. 
* 
* 
* 
* * 
* 
* 
* 
* 
* YyaOOO[]={ 3, 5,3 
state number---+ I I I 
number of pairs in list-+ I I 
input symbol (terminal)------+ I 
action-------------------------+ 2,2 1, 1 } ; 
action= yy_next( Yy_action, cur_state, lookahead_symbol ); 
action < 0 --Reduce by production n, n == -action. .... 
Section 5.7 -Representing LR State Tables 
Listing 5.2. continued ... 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 * 
* 
* 
*I 
int 
int 
int 
int 
int 
int 
int 
int 
int 
int action 0 
action > 0 
action YYF 
YyaOOO [] = { 2, 4,2 
Yya001 [] ={ 4' 5,-6 
Yya003 [ ]={ 2, 0,0 
Yya004 [] ={ 4, 5,-2 
Yya005[]={ 4, 5,-4 
Yya006[]={ 2, 5,9 
Yya009[]={ 4' 5,-5 
Yya010[]={ 4, 5,-1 
YyaOll [] ={ 4, 5,-3 
*Yy_action[12] Accept (ie. reduce by production 0) 
Shift to state n, n == action. 
error 
1' 1 } ; 
3,-6 2,-6 0,-6 } ; 
2,7 } ; 
2,-2 0,-2 3,8 } ; 
3,-4 2,-4 0,-4 } ; 
2,7 } ; 
3,-5 2,-5 0,-5 } ; 
2,-1 0,-1 3,8 } ; 
3,-3 2,-3 0,-3 } ; 
YyaOOO, Yya001, YyaOOO, Yya003, Yya004, Yya005, Yya006, YyaOOO, YyaOOO, 
Yya009, Yya010, YyaOll 
} ; 
/*-----------------------------------------------------
* The Yy_goto table is goto part of the LALR(1) transition matrix. It's com­
* pressed and can be accessed using the yy_next() subroutine, declared below. 
* 
* 
* 
* 
* 
* 
* 
* 
* 
*I 
int 
int 
int 
int 
int 
{ 
} ; nonterminal = Yy_lhs[ production number by which we just reduced 
YygOOO[}={ 3, 5,3 2,2 1,1 }; 
uncovered state-+ I I I 
number of pairs in list--+ I I 
nonterminal-------------------+ I 
goto this state-----------------+ 
goto_state yy_next( Yy_goto, cur state, nonterminal ); 
YygOOO [ ]={ 3, 3,5 2,4 1' 3 } ; 
Yyg002 [ ]={ 3, 3,5 2, 4 1' 6 } ; 
Yyg007 [] ={ 2, 3,5 2,10 } ; 
Yyg008[]={ 1, 3,11 } ; 
*Yy_goto[12] 
YygOOO, NULL ' Yyg002, NULL ' NULL ' NULL ' NULL ' Yyg007, 
NULL NULL ' NULL 
/*-----------------------------------------------------Yyg008, 
* The Yy_lhs array is used for reductions. It is indexed by production 
* number and holds the associated left-hand side adjusted so that the 
* number can be used as an index into Yy_goto. 
*I 
YYPRIVATE int Yy_lhs[7] 
{ 
/* 0 *I 0, 
/* 1 *I 1, 
/* 2 *I 1, 371 
372 Bottom-Up Parsing-Chapter 5 
Listing 5.2. continued ••• 
72 
73 
74 
75 
76 
77 } ; I* 
I* 
I* 
I* 3 
4 
5 
6 *I 2, 
*I 2, 
*I 3, 
*I 3 
78 l*-----------------------------------------------------
79 * The Yy reduce[] array is indexed by production number and holds 
80 * the nu~er of symbols on the right-hand side of the production. 
81 *I 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 YYPRIVATE int Yy_reduce[7] 
{ 
I* 0 *I 1, 
I* 1 *I 3, 
I* 2 *I 1, 
I* 3 *I 3, 
I* 4 *I 1, 
I* 5 *I 3, 
I* 6 *I 1 
} ; 
Listing 5.3. yynext.c- Table Decompression 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 int 
int 
int 
int 
{ yy_next( table, cur state, symbol ) 
**table; 
symbol; 
cur_state; I* table to decompress 
I* column index 
I* row index 
I* Given current state and input symbol, return next state. *I 
int *p =table[ cur state ] ; 
int i; 
if( p 
for( i = (int) *p++; --i >= 0 
if( symbol == p[O] 
return p[l]; 
return YYF; p += 2 ) 
I* error indicator *I *I 
*I 
*I 
Goto transitions. Yy _lhs, 
Yy_reduce. The goto transitions are computed using two arrays. Yy _lhs (on line 67 of Listing 
5.2) is indexed by production number and evaluates to an integer representing the sym­
bol on the left-hand side of that production. That integer is, in tum, used to search the 
goto part of the array for the next-state transition. A second array, Yy _reduce on line 
83 of Listing 5.2, is indexed by production number and evaluates to the number of sym­
bols on the right-hand side of that production. A simplified version of the occs parser 
loop, which demonstrates how the tables are used, is shown in Listing 5.4. 
Goto transitions could be 
compressed by column. Since there tend to be fewer nonterminals than states, the Yy _goto array could be 
made somewhat smaller if it were compressed by column rather than by row. The 
Yy _goto array could be indexed by nonterminal symbol and could contain 
[current_state, next_state] pairs. Occs doesn't do this both because two table­
decompression subroutines would be needed and because the parser would run more 
Section 5.7-Representing LR State Tables 
Listing 5.4. Simplified Parser Loop Demonstrating Parse-Table Usage 
push ( 0 ) ; /* Push start state */ I 
2 
3 
4 
5 
6 
7 
8 
9 lookahead = yylex(); /* get first lookahead symbol */ 
while( 1 ) 
{ 
do this= yy next( Yy_action, state_at top_of_stack(), lookahead ); 
if( do this == YYF 
{ 
/* ERROR *I 
else if( do_this > 0 ) 
{ 
else 
{ lookahead = yylex(); 
push( do_this ) ; /* 
/* 
/* 
/* Simple shift action 
advance 
push new state 
reduction *I 
*I 
*/ 
*I 
yy act( -do_this ) ; /* do code-generation action 
if( do this == YYACCEPT 
break 
else 
{ 
production number = -do this; 
rhs length= Yy_reduce[ production number]; 373 
*I 10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 while( --rhs length >= 0 ) 
pop(); /* pop rhs_length items */ 
next state= yy next( Yy goto, state at_top_of_stack(), 
Yy_lhs[production number] ); 
push( next state); 
slowly because the chain lengths would be a bit longer. You can also combine the two 
arrays, putting shift actions, reduce actions, and goto transitions together in a single row 
array; but again, it would take longer to decompress the table because of the extra chain 
lengths. 
5.8 Eliminating Single-Reduction States* 
Reexamining Table 5.11 on page 369, you'll notice that States I, 5, 9, and II all con­
sist of nothing but error transitions and reductions by a single production. For example, 
all the actions in State I are reductions by Production 6. These states, called single-
reduction states, are typically caused by productions that are used only to add pre-Single-reduction states. 
cedence rules to a grammar-they are created by productions with a single symbol on 
the right-hand side, such as the e~t and t~f in the grammar we've been using. 
You can see what these states are actually doing by looking at how one of the states 
is used as the parse progresses. If a NUM is found in State 0, for example, the parser 
shifts to State I, where the only legal action is a reduce by Production 6 if the next input 
374 
Removing single­
reduction states from 
parse table. 
Can't remove single­
reduction state if there is 
an action. Bottom-Up Parsing-Chapter 5 
character is I-, +, * or close parenthesis. This reduction just gets us back to State 0, 
without having advanced the input. All this backing and forthing is really unnecessary 
because the parser could reduce by Production 6 directly from State 0 if the next input 
character is a NUM and the following character is a I-, +, * or close parenthesis. If 
something else is in the input, the error is caught the next time the parser tries to shift, so 
the error information is actually duplicated in the table. 
All single-reduction states can be removed from the table by introducing another 
class of action items. If a row of the table contains a shift to a single-reduction state, 
replace it with a directive of the form dN, where N is the number of the production by 
which the parser would reduce had it gone to the single-reduction state. In the current 
table, for example, all sl directives would be replaced by d6 directives. The parser 
processes ad directive just like a normal reduce directive, except that it pops one fewer 
than the number of symbols on the right-hand side of the indicated production, because it 
didn't push the last of these symbols. 
A similar substitution has to be made in the goto portion of the table-all transitions 
into single-reduction states must be replaced with equivalent d directives. This change 
forces a second modification to the parser because several code-generation actions might 
now have to be executed during a reduction if a d directive is encountered in the goto 
table. The earlier table is modified to eliminate single-reduction states in Table 5.12. A 
parser algorithm for the new table is in Table 5.13. 
Table 5.12. Parse Table with Single-Reduction States Removed 
Shift/Reduce Table (Yy -action) Goto Table (Yy _ goto) 
I-NUM + * ( ) s e t f 
0 - d6 - - s2 - - 3 4 d4 
2 - d6 - - s2 - - 6 4 d4 
3 accept -s7 --- - - --
4 r2 -r2 s8 -r2 - - - -
6 - - s7 - - d5 - - - -
7 - d6 --s2 - - -10 d4 
8 - d6 - - s2 - - - - d3 
10 rl -rl s8 -rl - - - -
Error transitions are marked with -
There's one final caveat. You cannot eliminate a single-reduction state if there is a 
code-generation action attached to the associated production because the stack will have 
one fewer items on it than it should when the action is performed-you won't be able to 
access the attributes correctly. In practice, this limitation is enough of a problem that 
occs doesn't use the technique. In any event, the disambiguating rules discussed in the 
next section eliminate many of the single-reduction states because the productions that 
cause them are no longer necessary. 
There is one thing that's easy to do that does not affect the grammar at all, however, 
and can significantly reduce the table sizes in a pair-compressed array. Since the error 
information associated with single-reduction states is redundant (because the error is 
caught with the next shift), you can replace the entire chain of pairs that represent the 
single-reduction state with a single, default, reduce action that is performed regardless of 
the input symbol. The UNIX yacc utility takes this idea even further by providing a 
default action for every row of the table that represents the most common action in that 
row. The problem here is the error recovery, which is now very difficult to do because it 
is difficult to determine legal lookahead characters while doing the recovery. 
Section 5.8-Eiiminating Single-Reduction States* 
Table 5.13. LR Parser Algorithm for Single-Reduction-Minimized Tables 
push( 0 ); 
while( Action[TOS][input] ::1-Accept) 
I 
if( Action[TOS][input] =-) 
error(); 
else if ( Action[TOS][input] = sX) 
I 
} push( X); 
advance(); 
else if ( Action[TOS][input] = rX) 
I 
act( X); 
pop( as many items as are in the RHS of production X ); 
while( (i = Goto[ uncovered TOS ][ LHS of production X ]) = dX ) 
I 
act( X); 
pop( one fewer than the number of symbols in the RHS of production X ); 
push i; 
else if ( Action[TOS][input] = dX) 
I 
act( X); 
pop( one fewer than the number of symbols in the RHS of production X ) 
while( (i = Goto[ uncovered TOS ][ LHS of production X ]) = dX ) 
I 
act( X); 
pop( one fewer than the number of symbols in the RHS of production X ); 
push i; 
accept(); 
5.9 Using Ambiguous Grammars* 
Even though LR(l) and LALR(l) grammars are more flexible than the SLR(l) and 
LR(O), they still can't be ambiguous, because, as you would expect, an ambiguous gram­
mar yields an ambiguous parse. The ambiguity is reflected in the resulting state machine 
as a shift/reduce conflict. Ambiguous productions are, nonetheless, useful. They tend to 
make a grammar both smaller and easier to read. The two most common ambiguities are 
found in Productions 2, 4, and 5 of the following grammar: 375 
376 
Resolving ambiguities 
when making parse 
tables. 
Shift for right associativi­
ty. Reduce for left asso­
ciativity. Bottom-Up Parsing-Chapter 5 
l. stmt ~ exprSEMI 
2. I IF stmt ELSE stmt 
3. I IF stmt 
4. expr ~ expr PLUS expr 
5. I expr TIMES expr 
6. ID 
ID is an identifier 
This grammar creates the state machine pictured in Figure 5.11, and the ambiguities 
are reflected as shift/reduce conflicts in the States 5, 10, and 11. The LALR(l) looka­
heads are shown in brackets next to those items that trigger reductions. 
Though the foregoing grammar is not LALR(l), it is nonetheless possible to use it to 
create a parser. The basic strategy examines the various shift/reduce conflicts in the 
machine, and makes decisions as to whether a shift or reduce is appropriate in that situa­
tion, basing the decision on the semantic rather than syntactic description of the 
language. In practical terms, you need to know the relative precedence and the associa­
tivity of those tokens that appear in ambiguous productions, and this information can be 
used to disambiguate the tables. 
Precedence and associativity information is used to resolve ambiguities in arithmetic 
expressions as follows: State 10 contains the following items: 
expr 
expr ~ expr • + expr 
~ expr + expr • 
expr ~ expr. * expr 
The parser wants to reduce by 
expr ~ expr + expr [; + *] 
if the lookahead symbol is a semicolon, plus sign, or star; it also wants to shift on a plus 
sign or star. The semicolon poses no problem, but the arithmetic operators do. 
Now, consider the parse caused by the input a+b+c. The stack and input looks like 
this after the a, +, and b are processed: 
I expr + expr + c ; 
The parser now looks ahead and sees the plus, and it has a problem. If the plus operator 
is left associative, it will want to reduce immediately (before processing the next plus 
sign). A left-associative parse would continue as follows: 
lexpr + expr + c 
expr + c 
expr+ c 
expr+ ID 
expr+ expr 
expr 
expr; 
stmt 
This way the left subexpression would be processed before going on with the input. 
Right associativity is handled differently. Here the parser wants to put the whole expres­
sion onto the stack so that it can reduce from right to left, like this: 
Section 5.9-Using Ambiguous Grammars* 377 
Figure 5.11. State Machine for an Ambiguous Grammar 
lo stmt I / 3 ex pr s ~-stmt I s ~stmt. [rll 
IDENTIFIER IF ()IF 
~ stmt 1 5 * 
IDENTIFIER stmt ~ IF. stmt ELSE stmt stmt ~ IF stmt. ELSE stmt 
( stmt ~ IF. stmt stmt ~ IF stmt. [ELSEr] 
expr ELSE 
12 I exvr I expr ~IDENTIFIER. l;+*ll 9 I 1/ I stmt ~ IF stmt ELSE. stmt I 
stmt 
I 12 I 
' 4 I stmt ~ IF stmt ELSE stmt. [ELSE f-) I 
stmt ~ expr. ; 
+ expr ~ expr. + expr ; 
expr ~ expr. * expr "I 6 J I stmt ~ expr ;. [ELSEr] I 
* 
10 * expr ~ expr. + expr * 
expr ~ expr + expr. [;+*] ~ expr ~ expr. * expr 
+ Inadequate states are marked with a * 
expr 
17 I ~~ expr ~ expr +. expr I 
IDENTIFIER \ 
+ 
11 * expr ~ expr. + expr 
expr ~ expr. * expr [;+*] 
expr ~ expr * expr. 
* 
expr 
IDENTIFIER l 8 I' 
expr ~ expr *· expr 
378 
Shift for higher pre­
cedence, reduce for 
lower. 
Dangling else. Bottom-Up Parsing-Chapter 5 
expr + expr + c 
expr + expr + c 
expr + expr + ID 
expr + expr + expr 
expr + expr 
expr 
expr; 
stmt 
So the decision of whether to shift or reduce here is based on the desired associativity of 
the plus operator. In this case, you get left associativity by resolving the conflict in favor 
of the reduce. 
State 10 has one other problem-illustrated by the input a+b*c. Here, the star is 
higher precedence than the plus, so the multiplication must be done first. The conflict is 
active when the following stack condition exists: 
I expr + expr * c ; 
Reducing at this point would effectively ignore the relative precedence of+ and *; the 
addition would be done first. Resolving in favor of the shift, however, correctly gen­
erates the following parse: 
expr + expr * c 
expr + expr * ID 
expr + expr * expr 
expr+ expr 
expr 
expr; 
stmt 
and the multiplication is done before the addition. So, the conflict should be resolved in 
favor of the shift if the lookahead operator is higher in precedence than the token closest 
to the top of the stack. 
Precedence and associativity help only if a production implements an arithmetic 
expression, however. The sensible default for handling a shift/reduce conflict in nonar­
ithmetic productions is to decide in favor of the shift. This decision takes care of the 
conflict in State 5, which contains the following items 
IF stmt • ELSE stmt 
IF stmt. [I-ELSE] 
Here, the machine wants both to shift and reduce when the lookahead token is an ELSE. 
The problem is exemplified by the following input: 
Section 5.9-Using Ambiguous Grammars* 
IF 
ID 
ELSE 
IF 
ID 
ELSE 
ID 
Most programming languages require an ELSE to bind with the closest preceding IF. A 
partial parse of the foregoing generates the following stack: 
I IF stmt ELSE IF ID ; ELSE ID ; 
A shift is required in this situation, because an ELSE is present in the input. Were you 
to reduce IF stmt to stmt, the ELSE would be left dangling in the input. That is, since a 
stmt can't start with an ELSE, a syntax error would be created if the parser reduced. 
Letting the parse continue-shifting on every conflict-you'll eventually get the fol­
lowing on the stack: 
I IF stmt ELSE IF stmt ELSE stmt 
which can then be reduced to: 
I IF stmt ELSE stmt 
and then to: 
lstmt 
Since the rightmost statement is reduced first, the ELSE binds to the closest IF, as 
required. The foregoing rules can be summarized as follows: 
(1) Assign precedence and associativity information to all terminal symbols and pre­
cedence information to productions. 4 If no precedence and associativity is 
assigned, a terminal symbol is assigned a precedence level of zero (very low) and is 
nonassociative. Productions are assigned the same precedence level as the right­
most terminal symbol in the production or zero if there are no terminal symbols on 
the right-hand side.5 
(2) When a LALR(l) shift/reduce conflict is encountered, the precedence of the termi­
nal symbol to be shifted is compared with the precedence of the production by 
which you want to reduce. If either the terminal or the production is of precedence 
zero, then resolve the conflict in favor of the shift. Otherwise, if the precedences 
are equal, resolve using the following table: 
associativity of resolve in favor of lookahead symbol 
left reduce 
right shift 
nonassociati ve shift 
Otherwise, if the precedences are not equal, use the following table: 
4. Yacc and occs do this with the %left, %right and %nonassoc directives. 
5. Yacc and occs let you override this default with a %prec TOKEN directive where TOKEN is a terminal 
symbol that was declared with a previous %left, %right, or %nonassoc. The production is assigned the 
same precedence level as the token in the %prec directive. Note that the %prec directive must be to the 
left of the semicolon or vertical bar that terminates the production. 379 
Rules for resolving ambi­
guities in parse table. 
380 
Resolving reduce/reduce 
conflicts. Bottom-Up Parsing-Chapter 5 
precedence resolve in favor of 
lookahead symbol < production reduce 
lookahead symbol> production shift 
There's another kind of conflict that can appear in your grammar-a reduce/reduce 
conflict. Consider the following grammar that implements one rule of Kernighan and 
Cherry's troffpreprocessor, eqn:6 
I. 
2. 
3. 
4. 
5. expr ~ expr SUB expr SUP expr 
I expr SUB expr 
expr SUP expr 
LBexprRB 
CONST 
Eqn typesets equations. The implemented grammar does the following: 
Input Typeset as follows: 
X sub 1 XI 
X sup 2 X2 
X sub 1 sup 2 X2 I 
The last case has to be handled specially to prevent the subscript and superscript from 
getting out of line, like this: 
Xl2 
The earlier grammar takes care of the special case by adding an extra production (Pro­
duction I) that takes care of a case that would actually be handled by the rest of the 
grammar were it not there-X sub 1 sup 2 would be parsed without difficulty if Pro­
duction 1 wasn't in the grammar. It wouldn't be recognized as a special case, however. 
The grammar as presented yields a state with the following kernel items: 
expr ~ expr SUB expr SUP expr • [I-SUB SUP RB ] 
expr ~ expr SUP expr • [I-SUB SUP RB ] 
expr ~ expr • SUB expr SUP expr 
expr ~ expr • SUB expr 
expr ~ expr • SUP expr 
Here, the parser can't decide which of the two productions that have dots on the far right 
should be reduced. (This situation is a reduce/reduce conflict.) The sensible default is to 
resolve the conflict in favor of the production that is higher in the grammar. 
Note that reduce/reduce conflicts should generally be avoided by modifying the 
grammar. More often than not, this type of conflict is caused by an error in the grammar, 
like this: 
foo TOKEN 
TOKEN 
6. This example is taken from [Aho], pp. 252-254. It's significant that neither I nor any of the other compiler 
programmers that I know could think of a real example of a valid reduce/reduce conflict other than the 
current one. Reduce/reduce conflicts are almost always caused by errors in the grammar. 
Section 5.9-Using Ambiguous Grammars* 
They can also appear when you do seemingly reasonable things like this, however: 
karamazov ~ dmitry I ivan I alyosha 
dmitry ~ NAME do _something 
ivan ~ NAME do _something_ else 
alyosha ~ NAME do _yet_ another _thing 
This second situation is essentially the same as the earlier example. Several of 
karamazov's right-hand sides begin with the same terminal symbol. Here, however, the 
fact has been disguised by an intervening nonterminal. Because of the first-production­
has-higher-precedence rule, ivan and alyosha are never executed. 7 The solution is to res­
tructure the grammar as follows: 
karamazov ~ NAME brother 
brother ~ dmitry I ivan I alyosha 
dmitry ~ do _something 
ivan ~ do _something_ else 
alyosha ~ do _yet_ another_thing 
or to go a step further: 
karamazov ~ NAME brother 
brother ~ do _something 
I do _something_ else 
do _yet_ another _thing 
5.10 Implementing an LALR(1) Parser-The Occs Output File 
The remainder of this chapter discusses both the occs output file and how occs itself 
works; you can skip to the next chapter if you're not interested in this level of detail. In 
any event, you should read Appendix E, which contains a user's manual for occs, before 
continuing, because occs will be used in the next chapter. 
Most of the code that comprises occs is taken directly from LLama, and was dis­
cussed in the last chapter. The two main differences are the parser itself and the parse­
table generation routines. This section discusses the parser, using the output file created 
from the occs input file in Listing 5.5. (The associated lexical analyzer is defined by the 
U::X input file in Listing 5.6.) 
The grammar used here is not a particularly good use of occs, because I've built pre­
cedence and associativity information into the grammar itself, rather than using the 
%left and %right directives as I did with the expression grammar in Appendix E. I've 
done this because occs fudges the tables for ambiguous grammars, using the rules 
described in the previous section. For the purposes of discussion, however, it's better to 
work with a grammar that is a strict LALR(I) grammar. Note that I've extended the 
definition of the NUM token to recognize an identifier as well as a number (and renamed 
it to NUM _OR_ ID as a consequence). 
7. In yacc and occs, be careful of blithely using %prec to solve a problem like the foregoing without 
considering the consequences. The problem may well have been caused by a deficiency in the grammar 
and, though the %prec may eliminate the warning message, the problem will still exist. 381 
382 Bottom-Up Parsing-Chapter 5 
Listing 5.5. expr.y-Occs Input File for an Expression Compiler 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 %term NUM OR ID 
%left PLUS 
%left STAR 
%left LP RP 
%{ 
#include <stdio.h> 
#include <ctype.h> 
#include <malloc.h> 
#include <tools/debug.h> 
#include <tools/stack.h> 
extern char *yytext; /* a number or identifier 
/* + 
/* * 
/* (lowest precedence) 
(highest precedence) *I 
*I 
*I 
*I 
stack del( Namepool, char*, 10 ); 
#define freename(x) push( Namepool, (x) 
#define getname() pop ( Namepool /* Stack of 10 temporary-var names */ 
/* Release a temporary variable */ 
/* Allocate an temporary variable */ 
typedef char 
#define YYSTYPE *stype; 
stype /* Value stack is stack of char pointers */ 
#define YYSHIFTACT(tos) 
%} (*tos="") /* Shift a null string */ 
%% 
/* A small expression grammar that recognizes numbers, names, addition (+), 
*multiplication (*), and parentheses. Expressions associate left to right 
s 
e 
t 
f * unless parentheses force it to go otherwise. * is higher precedence than +. 
*I 
e 
e PLUS t 
t 
t STAR f 
f 
LP e RP 
NUM OR ID { yycode("%s += %s\n", $1, $3); freename($3); } 
/* $$ = $1 */ 
{ yycode("%s *= %s\n", $1, $3); freename($3); } 
/* $$ = $1 */ 
$$ = $2; } 
/* Copy operand to a temporary. Note that I'm adding an 
* underscore to external names so that they can't con­
* flict with the compiler-generated temporary names 
* (tO, t1, etc.). 
*I 
yycode("%s %s%s\n", $$ = getname(), 
isdigit(*yytext) ? 
yytext ) ; II II , 
%% /*----------------------------------------------------------------------*/ 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 
Listing 5.5. continued ... 
char 
char 
char 
{ *yypstk( vptr, dptr ) 
**vptr; 
*dptr; /* Value-stack pointer */ 
/* Symbol-stack pointer (not used) *I 
/* Yypstk is used by the debugging routines. It is passed a pointer to a 383 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 * value-stack item and should return a string representing that item. Since 
* the current value stack is a stack of string pointers, all it has to do 
* is dereference one level of indirection. 
*I 
return *vptr ? *vptr "-" 
/*----------------------------------------------------------------------*/ 
yy_init_occs () 
{ 
/* Called by yyparse just before it starts parsing. Initialize the 
* temporary-variable-name stack and output declarations for the variables. 
*I 
push( Namepool, "t9" ) ; push( Namepool, "t8" ) ; push( Namepool, "t7" ) ; 
push ( Namepool, "t6" ) ; push( Namepool, "t5" ) ; push( Namepool, "t4" ) ; 
push( Namepool, "t3" ) ; push( Namepool, "t2" ) ; push( Namepool, "tl" ) ; 
push( Namepool, "tO" ) ; 
yycode ( "public word tO, tl, t2, t3, t4;\n" ) ; 
yycode ( "public word t5, t6, t7, t8, t9;\n" ) ; 
/*----------------------------------------------------------------------*/ 
100 
101 
102 
103 main( argc, argv 
char **argv; 
{ 
yy_get_args( argc, argv ) ; 
if( argc < 2 
ferr("Need file name\n"); 
else if( ii_newfile(argv[l]) < 0 ) 
ferr( "Can't open %s\n", argv[l] ) ; 
yyparse(); 
exit( 0 ); 
Occs generates several output files for these input files. A symbol-table dump is in 
Listing 5.7 (yyout.sym), and token definitions are in yyout.h, Listing 5.8. The symbol 
table shows the internal values used for other various symbols including the production 
numbers that are assigned by occs to the individual productions. These numbers are use­
ful for deciphering the tables and debugging. The token-definitions file is typically 
#included in the LEX input file so that the analyzer knows which values to return. The 
token names are taken directly from the %term and %left declarations in the occs input 
file. Occs token definitions 
(yyout.h), symbol table 
(yyout.sym). 
384 Bottom-Up Parsing-Chapter 5 
Listing 5.6. exprolex- LeX Input File for an Expression Compiler 
I %{ 
2 #include "yyout.h" 
3 %} 
4 digit [0-9] 
5 alpha [a-zA-Z 
6 alnum [0-9a-zA-Z 
7 %% 
8 
9 "+" return PLUS; 
10 "*" return STAR; 
II II(" return LP; 
12 ")" return RP; 
13 {digit}+ I 
14 {alpha} { alnum} * return NUM OR ID; 
15 
16 %% 
Listing 5.7. yyoutosym- Symbol Table Generated from Input File in Listing 505 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 ---------------- Symbol table ------------------
NONTERMINAL SYMBOLS: 
e (257) <> 
FIRST : NUM OR ID LP 
1: e -> e PLUS t o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o •• o. o o. oPREC 1 
2: e -> t 
f (259) <> 
FIRST : NUM OR ID LP 
5: f -> LP e RP o o . o . o . o . o . o o o .. o o o o o o o o o o o o o o ...... o o o o PREC 3 
6: f -> NUM OR ID 
s (256) (goal symbol) <> 
FIRST : NUM OR ID LP 
0: s -> e 
t (258) <> 
FIRST : NUM OR ID LP 
3: t -> t STAR f ....•••.••.. o o o •••• o o •••••.•••..... o o o • PREC 2 
4: t -> f 
TERMINAL SYMBOLS: 
name value prec as soc field 
LP 4 3 1 <> 
NUM OR ID 1 0 <> 
PLUS 2 1 1 <> 
RP 5 3 1 <> 
STAR 3 2 1 <> 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 
Listing 5.8. yyout.h- Token Definitions Generated from Input File in Listing 5.5 
I #define EOI 0 
2 #define NUM OR ID 1 
3 #define PLUS 2 
4 #define STAR 3 
5 #define LP 4 
6 #define RP 5 
The occs-generated parser starts in Listing 5.9. As before, listings for those parts of 
the output file that are just copied from the template file are labeled occs.par. The occs­
generated parts of the output file (tables, and so forth) are in listings labeled yyout.c. 
Since we are really looking at a single output file, however, line numbers carry from one 
listing to the other, regardless of the name. The output starts with the file header in List­
ing 5.9. Global variables likely to be used by yourself (such as the output streams) are 
defined here. Note that <stdio.h>, <stdarg.h>, and <toolslyystk.h>, are #included on 
lines one to three. <stdarg.h> contains macros that implement the ANSI variable­
argument mechanism and <toolslyystk.h> contains stack-maintenance macros. These 
last two files are both described in Appendix A. The remainder of the header, in Listing 
5.1 0, is copied from the header portion of the input file. 
Listing 5.9. occs.par- File Header 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <stdarg.h> 
#include <tools/yystack.h> 
FILE *yycodeout stdout 
FILE *yybssout stdout 
FILE *yydataout stdout 
int yylookahead ; /* Output stream (code). 
/* Output stream (bss ) . 
/* Output stream (data). 
/* Lookahead token. *I 
*I 
*I 
*I 
extern char *yytext; /* Declared by lex in lexyy.c 
extern int yylineno; 
extern int yyleng; *I 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 extern 
extern char 
int *ii_ptext() 
ii_plength () /* Lookback function used by lex */ 
/* in /src/compiler/lib/input.c. */ 
extern int ii_plineno () 
#ifdef YYDEBUG 
# define YYD(x) X 
#else 
# define YYD(x) /* empty*/ 
#endif /* Define YYD here so that it can be used */ 
/* in the user-supplied header. */ 
/*----------------------------------------------------------------------*/ 
The output file continues in Listing 5.11 with various macro definitions. As was the Macro definitions. 
case in the LEX output file, these macros are not redefined if you defined them in the 
header part of the input file. (That's what all the #ifndefs are for.) Note that 
printf () calls are mapped to yycode () calls on line 44 if debugging is enabled. I've printf 0 mapped to 
done this because the standard printf () circumvents the window-output mechanism yycode 0 · 
and messes up the screen. This way, all printf () calls in the occs input file, at least, 
will behave properly. Direct output to the screen in other files is still a problem, 385 
386 Bottom-Up Parsing-Chapter 5 
Listing 5.10. yyout.c- Code Taken from Input-Specification Header 
#include <stdio.h> 
#include <ctype.h> 
#include <malloc.h> 
#include <toolsldebug.h> 
#include <toolslstack.h> 
extern char *yytext; 25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 stk_dcl( Namepool, char*, 10 ); 
#define freename(x) push( Namepool, 
#define getname() pop ( Namepool I* Stack of 10 temporary-var names *I 
(x) I* Release a temporary variable *I 
I* Allocate a temporary variable *I 
typedef char 
#define YYSTYPE *stype; 
stype I* Value stack is stack of char pointers *I 
#define YYSHIFTACT(tos) (*tos="") I* Shift a null string *I 
Stack-macro customiza­
tion. however. The stack macros, discussed in Appendix A and #included on line three of 
Listing 5.9, are customized on line 87 of Listing 5.11. The redefinition of yystk _ cls 
causes all the stacks declared with subsequent yystk _del () invocations to be 
static. 
Listing S.ll. occs.par- Definitions 
41 #undef YYD 
42 #ifdef YYDEBUG 
43 # define YYD(x) X 
44 # define printf yycode 
45 #else 
46 # define YYD(x) I* empty *I 
47 #endif 
48 
49 #ifndef YYACCEPT 
50 # define YYACCEPT return(O) 
51 #endif 
52 
53 #ifndef YYABORT 
54 # define YYABORT return(1) 
55 #endif 
56 
57 #ifndef YYPRIVATE 
58 # define YYPRIVATE static 
59 #endif 
60 
61 #ifndef YYMAXERR 
62 # define YYMAXERR 25 
63 #endif 
64 
65 #ifndef YYMAXDEPTH 
66 # define YYMAXDEPTH 128 
67 #endif 
68 
69 #ifndef YYCASCADE 
70 # define YYCASCADE 5 
71 #endif 
72 I* Redefine YYD in case YYDEBUG was defined *I 
I* explicitly in the header rather than with *I 
I* a -D on the aces command line. *I 
I* Make printf() calls go to output window *I 
I* Action taken when input is accepted. *I 
I* Action taken when input is rejected. *I 
I* define to a null string to make public *I 
I* Abort after this many errors *I 
I* State and value stack depth *I 
I* Suppress error msgs. for this many cycles *I 
Section 5.10-Implementing an LALR( I) Parser- The Occs Output File 387 
Listing 5.11. continued ... 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 127 128 
129 
130 #ifndef YYSTYPE /* Default value stack type *I 
# define YYSTYPE int 
#endif 
#ifndef YYSHIFTACT 
# define YYSHIFTACT(tos) 
#endif 
#ifdef YYVERBOSE 
# define YYV(x) x 
#else 
# define YYV(x) 
#endif 
#undef yystk_cls 
#define yystk cls YYPRIVATE /* Default shift action: inherit $$ *I 
(tos) [0] = yylval 
/* redefine stack macros for local */ 
/* use. */ 
/* ----------------------------------------------------------------------
* #defines used in the tables. Note that the parsing algorithm assumes that 
* the start state is State 0. Consequently, since the start state is shifted 
* only once when we start up the parser, we can use 0 to signify an accept. 
* This is handy in practice because an accept is, by definition, a reduction 
* into the start state. Consequently, a YYR(O) in the parse table represents an 
* accepting action and the table-generation code doesn't have to treat the 
* accepting action any differently than a normal reduce. 
* 
* Note that if you change YY TTYPE to something other than short, you can no 
* longer use the -T command-line switch. 
*I 
#define YY IS ACCEPT 0 
#define YY IS_SHIFT(s) ((s) > 0) 
YY TTYPE; /* Accepting action (reduce by 0) */ 
/* s is a shift action */ 
typedef short 
#define YYF ( (YY_TTYPE) ( (unsigned short) -o »l ) ) 
/*----------------------------------------------------------------------
* Various global variables used by the parser. They're here because they can 
* be referenced by the user-supplied actions, which follow these definitions. 
* 
* If -p or -a was given to OCCS, make Yy_rhslen and Yy_val (the right-hand 
* side length and the value used for $$) public, regardless of the value of 
* YYPRIVATE (yylval is always public). Note that aces generates extern 
*statements for these in yyacts.c (following the definitions section). 
*I 
#if !defined(YYACTION) I I !defined(YYPARSER) 
# define YYP /* nothing */ 
#else 
# define YYP YYPRIVATE 
#endif 
YYPRIVATE int yynerrs = 0; 
yystk_dcl( Yy_stack, int, YYMAXDEPTH); 
YYSTYPE yylval; 
YYP YYSTYPE Yy_val; /* Number of errors. 
/* State stack. 
/* Attribute for last token. 
/* Used to hold $$. *I 
*I *I 
*I 
.... 
388 Bottom-Up Parsing-Chapter 5 
Listing 5.11. continued ... 
131 yyp 
132 yyp 
133 
134 yyp 
135 
136 
YY IS SHIFT, 
YY TTYPE. YYSTYPE 
YYSTYPE 
int 
Error marker: YYF. 
YYP. 
Action subroutine, 
yy_act (). 
Translated dollar attri­
butes: ss. Sl, etc. Yy vstack[ 
*Yy_vsp; 
Yy rhslen; YYMAXDEPTH l ; /* Value stack. Can't use */ 
/* yystack.h macros because */ 
/* YYSTYPE could be a struct.*/ 
/* Number of nonterminals on */ 
/* right-hand side of the */ 
/* production being reduced. */ 
The definitions on lines I 03 to I 07 of Listing 5.11 are used for the tables. Shift 
actions are represented as positive numbers (the number is the next state), reduce opera­
tions are negative numbers (the absolute value of the number is the production by which 
you're reducing) and zero represents an accept action (the input is complete when you 
reduce by Production 0). YY_IS_SHIFT on line 104 is used to differentiate between 
these. YY _ TTYPE on the next line is the table type. You should probably change it to 
short if your machine uses a 16-bit short and 32-bit int. YY TTYPE must be 
signed, and a char is usually too small because of the number of states in the machine. 
YYF, on line 107 of Listing 5.11, represents failure transitions in the parse tables. 
(YYF is not stored in the compressed table, but is returned by the table-decompression 
subroutine, yy _act_ next (), which I'll discuss in a moment.) It evaluates to the largest 
positive short int (with two's complement numbers). Breaking the macro down: 
(unsigned) -0 is an unsigned int with all its bits set. The unsigned suppresses sign 
extension on the right shift of one bit, which yields a number with all but the high bit set. 
The resulting quantity is cast back to a YY _ TTYPE so that it will agree with other ele­
ments of the table. Note that this macro is not particularly portable, and might have to 
be changed if you change the YY TTYPE definition on the previous line. Just be sure 
that YYF has a value that can't be confused with a normal shift or reduce directive. 
The final part of Listing 5.11 comprises declarations for parser-related variables that 
might be accessed in one of the actions. The state and value stacks are defined here 
(along with the stack pointers), as well as some house-keeping variables. Note that those 
variables of class YYP are made public if -a or -p is specified to occs. (In which case, 
YYACTION and YYPARSER are not both present-the definition is output by occs itself at 
the top of the file, and the test is on line 119). 
Listing 5.12 holds the action subroutine, which executes the code-generation actions 
from the occs input file. Various tables that occs generates from the input grammar are 
also in this listing. The actions imbedded in the input grammar are output as case state­
ments in the switch in yy _act () (on lines 137 to 169 of Listing 5.12). As in LLama, 
the case values are the production numbers. Each production is assigned a unique but 
arbitrary number by occs; these numbers can be found in yyout.sym in Listing 5.7 on 
page 384, which is generated when occs finds a-D, -s, or -5 command-line switch. The 
production numbers precede each production in the symbol-table output file. The start 
production is always Production 0, the next one in the input file is Production I, and so 
forth. 
Note that the dollar attributes have all been translated to references to the value stack 
at this juncture. For example, on line 164, the line: 
t : t STAR f { yycode ("%s *= %s\n", $1, $3); freename ($3); } 
has generated: 
{ yycode("%s *= %s\n", yyvsp[2], yyvsp[O]); freename(yyvsp[O] ); } 
in the action subroutine. yyvsp is the value-stack pointer and a downward-growing 
stack is used. (A push is a *--yyvsp=x; a pop is a *yyvsp++.) The situation is 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 389 
Listing 5.12. yyout.c- The Action Subroutine and Tables 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 yy_act ( 
int 
YYSTYPE 
{ yy_production_number, yyvsp ) 
yy_production_number; 
*yyvsp; 
/* This subroutine holds all the actions in the original input 
* specification. It normally returns 0, but if any of your actions return a 
* non-zero number, then the parser will halt immediately, returning that 
* nonzero number to the calling subroutine. I've violated my usual naming 
* conventions about local variables so that this routine can be put into a 
* separate file by aces. 
*I 
switch( yy_production_number ) 
{ 
case 1: 
{ yycode("%s += %s\n", yyvsp[2], yyvsp[O]); freename(yyvsp[O]); } 
break; 
case 6: 
{ yycode("%s %s%s\n", Yy_val = getname (), 
isdigit(*yytext) ? 
yytext ); 
break; 
case 5: 
{ Yy_val 
break; 
case 3: yyvsp[l]; II II 
I 
{ yycode("%s *= %s\n", yyvsp[2], yyvsp[O]); freename(yyvsp[O]); 
break; 
default: break; /* In case there are no actions */ 
} 
return 0; 
/*-----------------------------------------------------
* Yy stok[] is used for debugging ar.d error messages. It is indexed 
* by the internal value used for a token (as used for a column index in 
* the transition matrix) and evaluates to a string naming that token. 
*I 
char *Yy stok [] = -
/* 0 *I " EO! " I 
/* 1 *I "NUM OR ID" I 
/* 2 *I "PLUS" I 
/* 3 *I "STAR", 
/* 4 *I "LP", 
/* 5 *I "RP" 
} ; 
/*-----------------------------------------------------
* The Yy_action table is action part of the LALR(1) transition matrix. It's 
*compressed and can be accessed using the yy_next() subroutine, below. 
* 
* 
* 
* 
* * YyaOOO[]={ 3, 5,3 
state number---+ I I I 
number of pairs in list-+ I I 
input symbol (terminal)------+ I 
action-------------------------+ 2,2 1, 1 }; 
.... 
390 Bottom-Up Parsing-Chapter 5 
Listing 5.12. continued ... 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 * 
* action= yy_next( Yy_action, cur_state, lookahead_symbol ); 
* 
* 
* 
* action < 0 
action 0 
action > 0 Reduce by production n, n == -action. 
Accept (ie. reduce by production 0) 
Shift to state n, n == action. 
* action YYF error 
*I 
YYPRIVATE YY TTYPE YyaOOO[]={ 2, 4,2 1, 1 } ; 
YYPRIVATE YY TTYPE Yya001[]={ 4, 5,-6 3,-6 2,-6 0,-6 
YYPRIVATE YY TTYPE Yya003[]={ 2, 0,0 2,7 ) ; 
YYPRIVATE YY TTYPE Yya004[]={ 4, 5,-2 2,-2 0,-2 3,8 
YYPRIVATE YY TTYPE Yya005 [ ]={ 4, 5,-4 3,-4 2,-4 0,-4 
YYPRIVATE YY TTYPE Yya006[]={ 2, 5,9 2,7 ) ; 
YYPRIVATE YY TTYPE Yya009[]={ 4, 5,-5 3,-5 2,-5 0,-5 
YYPRIVATE YY TTYPE Yya010[]={ 4, 5,-1 2,-1 0,-1 3,8 
YYPRIVATE YY TTYPE Yya011[]={ 4, 5,-3 3,-3 2,-3 0,-3 
YYPRIVATE YY TTYPE *Yy_action[12] 
{ 
YyaOOO, Yya001, YyaOOO, Yya003, Yya004, Yya005, Yya006, YyaOOO, 
Yya009, Yya010, YyaOll 
) ; 
/*-----------------------------------------------------} ; 
) ; 
) ; 
) ; 
) ; 
) ; 
YyaOOO, 
* The Yy_goto table is goto part of the LALR(1) transition matrix. It's com­
* pressed and can be accessed using the yy_next() subroutine, declared below. 
* 
* 
* 
* nonterminal = Yy_lhs[ production number by which we just reduced 
* 
* 
* 
* YygOOO[]={ 3, 5,3 
uncovered state-+ I I I 
number of pairs in list--+ I I 
nonterminal-------------------+ I 
goto this state-----------------+ 2,2 1,1 }; 
* goto_state yy_next( Yy_goto, cur state, nonterminal ); 
*I 
YYPRIVATE YY TTYPE 
YYPRIVATE YY TTYPE 
YYPRIVATE YY TTYPE 
YYPRIVATE YY TTYPE 
YYPRIVATE YY TTYPE 
{ 
YygOOO, NULL 
NULL , NULL 
) ; YygOOO[]={ 3, 
Yyg002[]={ 3, 
Yyg007[]={ 2, 
Yyg008[]={ 1, 
*Yy _goto [ 12] 
, Yyg002, NULL 
, NULL 3,5 2,4 1,3 
3,5 2,4 1,6 
3,5 2,10 ) ; 
3,11 ) ; 
= 
, NULL , NULL , NULL 
/*-----------------------------------------------------) ; 
) ; 
, Yyg007, Yyg008, 
* The Yy_lhs array is used for reductions. It is indexed by production number 
* and holds the associated left-hand side, adjusted so that the number can be 
* used as an index into Yy_goto. 
*I 
YYPRIVATE int Yy 1hs[7] 
{ 
.... 
Section 5.10-Imp1ementing an LALR(l) Parser-The Occs Output File 
Listing 5.12. continued ... 
254 
255 
256 
257 
258 
259 
260 
261 
262 } ; /* 
/* 
/* 
/* 
/* 
/* 
/* 0 
1 
2 
3 
4 
5 
6 *I 0, 
*I 1, 
*I 1, 
*I 2, 
*I 2, 
*I 3, 
*I 3 
263 /*-----------------------------------------------------
264 * The Yy reduce[} array is indexed by production number and holds 
265 * the number of symbols on the right hand side of the production. 
266 */ 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 YYPRIVATE int Yy _reduce [ 7] 
{ 
/* 0 *I 1, 
/* 1 *I 3, 
/* 2 *I 1, 
/* 3 *I 3, 
/* 4 *I 1, 
/* 5 *I 3, 
/* 6 *I 1 
} ; 
#ifdef YYDEBUG 
280 /*-----------------------------------------------------
281 * Yy_slhs[} is a debugging version of Yy_lhs[}. Indexed by production number, 
282 * it evaluates to a string representing the left-hand side of the production. 
283 */ 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 YYPRIVATE 
{ 
/* 
/* 
/* 
/* 
/* 
/* /* 
} ; char *Yy_ slhs[7] = 
0 *I "s", 
1 *I "e", 
2 *I "e", 
3 *I "t" I 
4 *I "t" I 
5 *I "f" I 
6 *I "f" 
296 /*-----------------------------------------------------
297 * Yy_srhs[} is also used for debugging. It is indexed by production number 391 
298 * and evaluates to a string representing the right-hand side of the production. 
299 */ 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 YYPRIVATE 
{ 
/* 
/* 
/* /* /* /* 
/* 
} ; 
#endif char 
0 
1 
2 
3 
4 
5 
6 *Yy_ srhs[7] = 
*/ "e", 
*I "e PLUS t", 
*I "t", 
*I "t STAR f", 
*I "f"' 
*I "LP e RP", 
*I "NUM OR ID" 
392 Bottom-Up Parsing-Chapter 5 
complicated by the fact that attributes are numbered from left to right, but the rightmost 
(not the leftmost) symbol is at the top of the parse stack. Consequently, the number that 
is part of the dollar attribute can't be used directly as an offset from the top of stack. You 
can use the size of the right-hand side to compute the correct offset, however. When a 
reduction is triggered, the symbols on the parse stack exactly match those on the right­
hand side of the production. Given a production like t~t STAR f,fis at top of stack, 
STAR is just under the f, and tis under that. The situation is illustrated in Figure 5.12. 
yyvsp, the stack pointer, points at f, so $3 translates to yyvsp [ 0) in this case. Simi­
larly, $2 translates to yyvsp [ 1), and $3 translates to yyvsp [ 2). The stack offset for 
an attribute is the number of symbols on the right-hand side of the current production 
less the number that is part of the dollar attribute. $1 would be at yyvsp [ 3) if the 
right-hand side had four symbols in it. 
Figure 5.12. Translating $N to Stack References 
t~ tSTARf 
in rules section in section following second %% 
Yy_vsp ~ f $3 
$2 
$1 Yy_vsp[O] 
Yy_vsp[1) 
Yy_vsp[2) Yy_vsp[ Yy_rhslen-3 
Yy_vsp[ Yy_rhslen-2 
Yy_vsp[ Yy_rhslen-1 
Attributes in code section 
of input file. 
Right-hand-side length: 
Yy_rhslen. 
Token-to-string conver­
sion: Yy _stok [ ). 
Yy_slhs [), Yy_srhs [ ). STAR 
t 
Figure 5.12 also shows how attributes are handled when they are found in the third 
part of the occs input file rather than imbedded in a production. The problem here is that 
the number of symbols on the right-hand side is available only when occs knows which 
production is being reduced (as is the case when an action in a production is being pro­
cessed). Code in the third section of the input file is isolated from the actual production, 
so occs can't determine which production the attribute references. The parser solves the 
problem by setting a global variable, Yy _ rhslen, to the number of symbols on the 
right-hand side of the production being reduced. Yy _ rhs len is modified just before 
each reduction. This variable can then be used at run-time to get the correct value-stack 
item. Note that negative attribute numbers are also handled correctly by occs.8 Figure 
5.13 shows the value stack just before a reduction by b~d e fin the following gram­
mar: 
s ~ abc 
b ~ def{x=$-1;} 
The $-1 in the second production references the a in the partially assembled first pro­
duction. 
Listing 5.12 continues on line 177 with a token-to-string translation table. It is 
indexed by token value (as found in yyout.h) and evaluates to a string naming that token. 
It's useful both for debugging and for printing error messages. The other conversion 
tables are used only for the debugging environment, so are #ifdefed out when YYDE­
BUG is not defined. Yy _ s lhs [ J on line 285 is indexed by production number and holds 
a string representing the left-hand side of that production. Yy _ srhs [) on line 301 is 
8. They aren't accepted by yacc. 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 
Figure 5.13. Translating $ -N to Stack References 
in rules section 
Yy_vsp ----?> f $3 Yy_vsp [0) 
e $2 Yy_vsp[1) 
d $1 Yy_vsp[2) 
a $-1 Yy_vsp[3) in section following second%% 
Yy_vsp[ Yy_rhs1en-3 
Yy_vsp[ Yy_rhslen-2 
Yy_vsp[ Yy_rhslen-1 
Yy_vsp[ Yy rhslen- -1 
Yy_vsp[ Yy_rhslen+1 393 
similar, but it holds strings representing the right-hand sides of the productions. 
Lines 187 to 277 of Listing 5.I2 hold the actual parse tables. The state machine for Using occs' compressed 
our current grammar was presented earlier (in Table 5.II on page 369) and the parse tables. 
compressed tables were discussed in that section as well. Single-reduction states have 
not been eliminated here. I'll demonstrate how the parse tables are used with an exam-
ple parse of ( 1 + 2) . The parser starts up by pushing the number of the start state, 
State 0, onto the state stack. It determines the next action by using the state number at I 0 ( 1 + 2) 
the top of stack and the current input (lookahead) symbol. The input symbol is a left 
parenthesis (an LP token), which is defined in yyout.h to have a numeric value of 4. (It's 
also listed in yyout.sym.) The parser, then, looks in Yy _action [ 0 J [ 4). Row 0 of the 
table is represented in YyaOOO (on Line 205 of Listing 5.I2), and it's interested in the 
first pair: [4,2]. The 4 is the column number, and the 2 is the parser directive. Since 2 is 
positive, this is a shift action: 2 is pushed onto the parse stack and the input is advanced. I 0 2 1 + 2) 
Note that YyaOOO also represents rows 2, 6, and 7 of the table because all four rows have 
the same contents. 
The next token is a number (a NUM_OR_ID token, defined as I in yyout.h). The 
parser now looks at Yy _action [ 2) [ 1) (2 is the current state, I the input token). Row 
2 is also represented by Yy a 0 0 0 on line 205 of Listing 5.I2, and Column I is 
represented by the second pair in the list: [ l, I]. The action here is a shift to State l, so a 
I is pushed and the input is advanced again. I 0 2 I + 2) 
A I is now on the top of the stack, and the input symbol is a PLUS, which has the 
value 2. Yy _action [ 1) [ 2) holds a -6 (it's in the third pair in YyaOOO, on line 205), 
which is a reduce-by-Production-6 directive (reduce by f~NUM_OR_ID). The first 
thing the parser does is perform the associated action, with a yy _act ( 6) call. The 
actual reduction is done next. Yy _reduce [ 6) evaluates to the number of objects on the 
right-hand side of Production 6-in this case, l. So, one object is popped, uncovering 
the previous-state number (2). Next, the goto component of the reduce operation is per-I 0 2 +2) 
formed. The parser does this with two table lookups. First, it finds out which left-hand 
side is associated with Production 6 by looking it up in Yy _lhs [ 6) (it finds a 3 there). 
It then looks up the next state in Yy _goto. The machine is in State 2, so the row array is 
fetched from Yy _goto [ 2), which holds a pointer to Yyg002. The parser then searches 
the pairs in Yyg002 for the left-hand side that it just got from Yy _lhs (the 3), and it 
finds the pair [3,5]-the next state is State 5 (a 5 is pushed). The parse continues in this I 0 2 5 + 2) 
manner until a reduction by Production 0 occurs. 
Listing 5.13 contains the table-decompression routine mentioned earlier Table decompression: 
(yy _next () on line one), and various output subroutines as well. Two versions of the YY-next 0 · 
output routines are presented at the end of the listing, one for debugging and another ver-
sion for production mode. The output routines are mapped to window-output functions 
if debugging mode is enabled, as in LLama. Also of interest is a third, symbol stack 
394 Bottom-Up Parsing-Chapter 5 
Symbol stack: (Yy dstack) defined on line 24. This stack is the one that's displayed in the middle of 
the debugging environment's stack window. It holds strings representing the symbols 
that are on the parse stack. Yy_dstack. 
Listing 5.13. occs.par- Table-Decompression and Output Subroutines 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 YYPRIVATE YY TTYPE yy_next( table, cur_state, inp 
YY TTYPE **table; 
YY TTYPE cur_state; 
int inp; 
/* Next-state routine for the compressed tables. Given current state and 
* input symbol (inp), return next state. 
*I 
YY TTYPE 
int 
if( p ) *p 
i; table[ cur state 
for( i = (int) *p++; --i >= 0 
if( inp == p[O] ) 
return p[l]; 
return YYF; p += 2 ) 
/*----------------------------------------------------------------------*/ 
#ifdef YYDEBUG 
yystk_dcl( Yy_dstack, char*, YYMAXDEPTH ); /* Symbol stack 
yycode( fmt ) 
char *fmt; 
va list args; 
va_start( args, fmt ); 
yy_output( 0, fmt, args ); 
yydata( fmt ) 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
yy_output( 1, fmt, args ); 
yybss( fmt ) 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
yy_output( 2, fmt, args ); 
/* yycomment() and yyerror() are defined in yydebug.c */ 
#else /*-- - - - - - - - - - - - - - - - - - - - - - - - */ *I 
Section 5.10-Implementing an LALR(I) Parser-The Occs Output File 395 
Listing 5.13. continued ... 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 # 
# 
# 
# 
# define yy_nextoken() 
define yy_quit_debug() 
define yy_init_debug() 
define yy_pstack(x,y) 
define yy _ sym () yylex () /* when YYDEBUG isn't defined. *I 
100 
101 
102 
103 
104 
105 
106 107 108 109 
110 /* Use the following routines just like printf() to create output. The only 
* differences are that yycode is sent to the stream called yycodeout, yydata 
* goes to yydataout, and yybss goes to yybssout. All of these are initialized 
* to stdout. It's up to you to close the streams after the parser terminates. 
*I 
yycode( fmt ) 
char *fmt; 
va list args; 
va_start( args, fmt ); 
vfprintf( yycodeout, fmt, args ); 
yydata( fmt ) 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
vfprintf( yydataout, fmt, args ); 
yybss( fmt ) 
char *fmt; 
{ 
void 
char 
void 
char 
{ 
} 
#endif va list args; 
va_start( args, fmt ); 
vfprintf( yybssout, fmt, args ); 
yycomment( fmt ) 
*fmt; 
va_list args; 
va_start( args, fmt ); 
vfprintf( stdout, fmt, args ); 
yyerror( fmt, ... ) 
*fmt; 
extern char *yytext; 
extern int yylineno; 
va list args; 
va_start( args, fmt ) ; 
fprintf ( stderr, "ERROR (line %d near %s): ", yylineno, yytext ); 
vfprintf( stderr, fmt, args ) ; 
fprintf ( stderr, "\n" ) ; 
396 Bottom-Up Parsing-Chapter 5 
Shift subroutine, 
yy _shift () . The parser itself starts in Listing 5.14. The shift and reduce operations have been 
broken out into subroutines (on lines Ill and 128) in order to simplify the code in the 
parser itself. A new state is pushed onto the state stack on line 115. Garbage is pushed 
onto the value stack on line 116, but the user-supplied, default shift action [in the macro 
YYSHIFTACT ()]is performed on the next line. This macro is passed a pointer to the top 
of the value stack (after the push)-the default action (defined on line 78 of Listing 5.11, 
page 387) pushes the contents ofyylval onto the stack, so you can push an attribute for 
a nonterminal by modifying yylval from an accepting action in a IJX input file. (This 
process is discussed in Appendix E.) The debugging stack is kept aligned with the other 
stacks by pushing a string representing the shifted token on line 121. The 
yy _pstack () call on the next line updates the stack window and waits for another 
command if necessary. Breakpoints are also activated there. 
Listing 5.14. occs.par- The Parser 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
!50 
!51 
!52 YYPRIVATE 
int yy_shift( new_state, lookahead ) 
new_state; /* shift */ 
/* push this state */ 
/* Current lookahead */ int lookahead; 
yypush( Yy_stack, new_state ); 
--Yy_vsp; 
YYSHIFTACT( Yy_vsp ); 
#ifdef YYDEBUG /* Push garbage onto value stack */ 
/* Then do default action */ 
yycomment( "Shift %0.16s (%d)\n", Yy_stok[ lookahead ], new_state); 
yypush_( Yy_dstack, Yy_stok[lookahead] ); 
yy_pstack(O, 1); 
#endif 
} 
/*----------------------------------------------------------------------*/ 
YYPRIVATE yy_reduce( prod_num, amount ) 
int prod_num; /* Reduce by this production */ 
int amount; /* # symbols on right-hand side of prod_num */ 
int next_state; 
yypopn( Yy_stack, amount); 
Yy_vsp += amount; 
*--Yy_vsp = Yy_val; /* Pop n items off the state stack */ 
/* and the value stack. */ 
/* Push $$ onto value stack */ 
next state= yy_next( Yy_goto, yystk_item(Yy_stack,O), Yy_lhs[prod_num] ); 
#ifndef YYDEBUG 
yypush_ Yy_stack, next state ) ; 
#else 
yy_break( prod_num ); /* activate production breakpoint */ 
yypopn_ Yy_dstack, amount); 
YYV( yycomment(" pop %d item%s\n", amount, amount==l ? "s"); ) 
yy_pstack( 0, 0 ); 
Section 5.10-Imp1ementing an LALR(l) Parser-The Occs Output File 
Listing 5.14. continued ... 
yypush_ 
yypush Yy_stack, next_state ); 
Yy_dstack, Yy slhs[ prod_num] ); 
YYV( yycomment(" push %0.16s (%d)", Yy_slhs[prod_num], next state); ) 
yy_pstack ( 0, 1 ) ; 
#endif 
} 
/*----------------------------------------------------------------------*/ 
YYPRIVATE 
{ void yy_init stack() /* Initialize the stacks */ 
# 
# 
} yystk_clear( Yy_stack ); 
yypush Yy_stack, 0 ); 
Yy_vsp = Yy_vstack + (YYMAXDEPTH-1); 
ifdef YYDEBUG 
yystk_clear ( Yy_dstack ); 
yypush_ ( Yy_dstack, "$" ) ; 
yycomment ( "Shift start state\n" ) ; 
yy_pstack (0, 1); 
endif /* State stack 0 *I 
I* Value stack garbage */ 
/* refresh stack window */ 
/*----------------------------------------------------------------------*/ 
YYPRIVATE int yy recover( tok, suppress ) 
int 
int tok; 
suppress; /* token that caused the error */ 
/* No error message is printed if true */ 
int 
YYD( char 
YYD( char *old sp 
**old_dsp 
*tos; yystk_p(Yy_stack); 
yystk_p(Yy_dstack); 
if ( ! suppress ) 
{ 
do yyerror( "Unexpected %s\n", Yy_stok[tok] ); 
if( ++yynerrs > YYMAXERR ) 
{ 
yyerror("Too many errors, aborting\n"); 
return 0; 
while( !yystk_empty(Yy_stack) /* State-stack pointer */ 397 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 208 
209 
210 
211 
212 && yy_next( Yy_action, yystk_item(Yy_stack,O), tok) YYF ) 
yypop_( Yy_stack ) ; 
YYD( tos = yypop (Yy_dstack); ) 
YYD( yycomment("Popping %d from state stack\n", tos); ) 
YYD( yy_pstack(O, 1); ) 
.... 
398 Bottom-Up Parsing-Chapter 5 
Listing 5.14. continued ... 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 if( !yystk~empty(Yy~stack) ) 
{ /* Recovered successfully */ 
/* Align the value (and debug) stack to agree with the current 
* state-stack pointer. 
*I 
Yy~vsp = Yy~vstack + (yystk~ele(Yy~stack) -1); 
#ifdef YYDEBUG 
yystk~p(Yy~dstack) = Yy~dstack + (yystk~ele(Yy~stack) -1); 
yycomment("Error recovery successful\n"); 
yy~pstack(O, 1); 
#endif 
return tok; 
yystk~p( Yy~stack ) = old~sp ; 
YYD( yystk~p( Yy~dstack ) =old dsp; 
YYD( yycomment("Restoring state stack."); 
YYD( yy~pstack(1, 1); 
YYD( yycomment("discarding %s\n", Yy stok[tok]); 
while( ii~mark~prev(), tok = yy~nextoken() ) ; 
YYD( yycomment("Error recovery failed\n"); 
return 0; 
/*----------------------------------------------------------------------*/ 
int yyparse() 
/* General-purpose LALR parser. Return 0 normally or -1 if the error 
* recovery fails. Any other value is supplied by the user as a return 
* statement in an action. 
*I 
int act num 
int errcode 
int tchar 
int suppress err 
#ifdef YYDEBUG /* Contents of current parse table entry */ 
/*Error code returned from yy~act() */ 
/* Used to \0-terminate the lexeme */ 
/* Set to YYCASCADE after an error is found */ 
/* and decremented on each parse cycle. Error */ 
/* messages aren't printed if it's true. */ 
if( !yy~init~debug( Yy~stack, &yystk~p(Yy~stack ), 
Yy~dstack, &yystk~p(Yy dstack), 
Yy~vstack, sizeof(YYSTYPE), YYMAXDEPTH) 
YYABORT; 
#endif 
yy~init stack (); 
yy~init~occs ( Yy~vsp ); 
yylookahead yy nextoken(); 
suppress err 0; /* Initialize parse stack *I 
/* Get first input symbol *I 
.... 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 399 
Listing 5.14. continued ... 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 while( 1 
{ 
act num = yy_next( Yy_action, yystk_item(Yy_stack,O), yylookahead ); 
if( suppress_err ) 
--suppress_err; 
if( act num == YYF 
{ 
if( ! (yylookahead 
YYABORT; yy_recover( yylookahead, suppress_err )) ) 
suppress_err = YYCASCADE; 
else if( YY_IS_SHIFT(act_num) 
{ /* Simple shift action */ 
else 
{ /* Note that yytext and yyleng are undefined at this point because 
* they were modified in the else clause, below. You must use 
* ii_text(), etc., to put them into a reasonable condition if 
* you expect to access them in a YY SHIFT action. 
*I 
yy_shift( act_num, yylookahead ); 
ii_mark_prev (); 
yylookahead = yy_nextoken(); 
/* Do a reduction by -act_num. The activity at 1, below, gives YACC 
* compatibility. It's just making the current lexeme available in 
* yytext and '\0' terminating the lexeme. The '\0' is removed at 2. 
* The problem is that you have to read the next lookahead symbol 
* before you can reduce by the production that had the previous 
* symbol at its far right. Note that, since Production 0 has the 
* goal symbol on its left-hand side, a reduce by 0 is an accept 
*action. Also note that ii_ptext() [ii_plength()} is used at (2) 
* rather than yytext[yyleng} because the user might have modified 
* yytext or yyleng in an action. 
* 
* Rather than pushing junk as the $$=$1 action on an epsilon 
* production, the old tos item is duplicated in this situation. 
*I 
act num -act num ; 
Yy_ rhslen Yy_reduce[ act num l ; 
Yy_val Yy_vsp[ Yy_ rhslen ? Yy_rhslen-1 0 l ; I* $$ = $1 
yylineno ii_plineno() /* ( 1) 
yytext ii_ptext () 
tchar yytext [ yyleng i i _plength () l ; 
yytext[yyleng] '\0' ; 
YYD( yycomment("Reduce by (%d) %s->%s\n", act_num, \ 
Yy_slhs[act_num], Yy_srhs[act_num]); 
if( errcode = yy_act( act_num, Yy_vsp ) ) 
return errcode; *I 
*I 
.... 
400 
Listing 5.14. continued ... 
ii_ptext() [ ii_plength() ] = tchar; 
if( act_num 
break ; 
else YY IS ACCEPT 
yy reduce( act_num, Yy rhslen ) ; Bottom-Up Parsing-Chapter 5 
/* (2) *I 331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 YYD( yycomment( "Accept\n" ); 
YYD( yy_quit_debug(); 
YYACCEPT; 
Reduce subroutine, 
yy_reduce (). 
Stack initialization. 
Error recovery: 
yy _recover () . 
The parser itself: 
yyparse (). Reductions are done in yy _reduce(), on line 128 of Listing 5.14. The subroutine 
pops as many stack items as are on the right-hand side of the production by which the 
parser's reducing on lines 134 to 136; the goto state is computed on line 138, and is 
pushed on line 142 (153 if debugging is enabled). Nothing is popped in the case of an E 
production because amount is zero in this situation. Yy val (which holds$$) is initial­
ized to $1 before yy_reduce is called.9 Similarly, the-action code (in which Yy_val 
could be modified via $$) is executed after the initialization but before the 
yy _reduce () call. The code on lines 144 to 158 of Listing 5.14 is activated in debug­
ging mode. The actions that I just described are performed here too, but they're done in 
several steps so that breakpoints and screen updates happen in reasonable places. 
The stacks are all initialized in yy _ init stack() on line 165. This initialization 
must be done at run time because the parser might be called several times within a pro­
gram (if, for example, it's being used to parse expressions in some large program rather 
than for a complete compiler). Initially, 0 is pushed onto the state stack, garbage onto 
the value stack, and the string "$" onto the debugging symbol stack. 
The next issue is error recovery, which is handled by yy _recover () on line 182 of 
Listing 5.15. This routine is passed the token that caused the error. It prints an error 
message if its second argument is false, and tries to recover from the error by manipulat­
ing the stack. The panic-mode error-recovery technique described earlier is used: 
( 1) Pop items off the stack until you enter a state that has a legitimate action on the 
current token (for which there is a nonerror transition on the current token). If you 
find such a state, you have recovered. Return the input token. 
(2) Otherwise, if there are no such states on the stack, advance the input, restore the 
stack to its original condition (that is, to the condition it was in when the error 
occurred) and go to ( 1 ). 
(3) If you get to the end of input, you can't recover from the error. Return 0 in this 
case. 
The algorithm is represented in pseudocode in Table 5.14. 
The actual parser, yyparse (),begins on line 245 of Listing 5.15. It is a straightfor­
ward implementation of the simplified, bottom-up parse algorithm in Listing 5.4 on page 
373. The remainder of the output file is the third portion of the input file from Listing 5.5 
9. Yacc hackers: Don't confuse this variable with yylval, discussed earlier. Yacc uses yyl val both for$$ 
and for the default shift value-occs uses two different variables. 
Section 5.10-Implementing an LALR(l) Parser-The Occs Output File 
Table 5.14. Bottom-Up, Error-Recovery Algorithm 
recover( tok ) 
I 
remember the_real_stack_pointer ; 
do I 
sp = the_real_stack_pointer ; 
while( stack not empty && no_Iegal_transition( sp, tok ) ) 
--sp; 
if( the stack is not empty ) 
I 
the_real_stack_pointer = sp; 
return tok; 
} while( (tok = advance( )) t:. end_of_input ); 
return 0; 
on page 383. It is not reproduced here. 
5.11 Implementing an LALR(1) Parser Generato~­
Occs Internals 
This section discusses the source code for occs, a yacc-like program that translates an 
augmented, attributed grammar into the C source code for a parser. If you still haven't 
done it, you must read Appendix E, which is a user's manual for occs, before continuing. 
(I really mean it this time.) 
5.11.1 Modifying the Symbol Table for LALR(1) Grammars 
Most of the important differences between LLama and occs are in the do_ file() 
subroutine (Listing 4.36, page 327, line 272 ). The OX ( ) macros conditionally compile 
the code that is unique to occs. [LL () is used for LLama-speci fie code.] There are 
other trivial changes scattered throughout the program, but the important ones are in 
do_file (). 401 
The first order of business is modifying the grammar somewhat. LLama's top-down Modifying the grammar 
parser can handle actions imbedded in the middle of a production because it just puts for occs: 'do_patch()' 
them onto the parse stack like any other symbol. The bottom-up parser used by occs has 
to do the actions as part of a reduction, however. Consequently, it has to handle actions 
differently. The patch () subroutine (on line 29 of Listing 5.15) modifies the grammar 
to be suitable for occs, and at the same time removes all actions from the PRODUCTIONs 
themselves. Actions are output as cases in the switch statement in the yy _act () sub-
routine (discussed earlier on page 388). The output case statements reference the pro-
duction number with which the action is associated. The action code itself can safely be 
discarded once it is output because occs no longer needs it. 
402 Bottom-Up Parsing-Chapter 5 
Listing 5.15. yypatch.c- Modify Grammar for Use in Occs 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 #include <stdio.h> 
#include <ctype.h> 
#include <malloc.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/*----------------------------------------------------------------------*/ 
void patch p ( ( void ) ) ; /* public 
void dopatch p ( ( SYMBOL *sym ) ) ; /* local 
void print_one_ case p ( ( int case _val, unsigned char *action, \ 
int rhs size, int lineno, struct _prod_ *prod ) ) ; -
/*----------------------------------------------------------------------*/ *I 
*I 
PRIVATE int Last real nonterm /* This is the number of the last */ 
/* nonterminal to appear in the input */ 
/* grammar [as compared to the ones */ 
/* that patch() creates}. */ 
/*-------------------------------------------------------------------*/ 
PUBLIC void patch() 
{ 
/* This subroutine does several things: 
* 
* It modifies the symbol table as described in the text. * 
* 
* * It prints the action subroutine and deletes the memory associated 
with the actions. 
* * This is not a particularly good subroutine from a structured programming 
* perspective because it does two very different things at the same time. 
* You save a lot of code by combining operations, however. 
*/ 
void dopatch(); 
static char *top[] 
{ 
1111 , 
"yy_act( yypnum, yyvsp )", 
"int yypnum; 
"YYSTYPE 
{", *yyvsp; /* production number */", 
/* value-stack pointer */", 
/* This subroutine holds all the actions in the original input", 
* specification. It normally returns 0, but if any of your", 
II , * actions return a non-zero number, then the parser halts", 
* immediately, returning that nonzero number to the calling", 
* subroutine.", 
*/", 
switch( yypnum )", 
{", .... 
Section 5.11.1-Modifying the Symbol Table for LALR(I) Grammars 403 
Listing 5.15. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 NULL 
} ; 
static char *bot[] 
} ; 1111 
' 
" 
1111 
' 
"}", 
NULL #ifdef YYDEBUG", 
default: yycomment(\"Production %d: no action\\n\", yypnum);", 
#endif", 
}", break;", 
return 0;", 
Last real nonterm = Cur_nonterm; 
if( Make_actions ) 
printv( Output, top ) ; 
ptab( Symtab, dopatch, NULL, 0 ); 
if( Make_actions ) 
printv( Output, bot ) ; 
/*----------------------------------------------------------------------*/ 
PRIVATE void dopatch(sym) 
SYMBOL *sym; 
{ 
PRODUCTION *prod; 
SYMBOL **p2 
SYMBOL **pp 
SYMBOL *cur 
if( !ISNONTERM(sym) 
{ /* Current right-hand side of sym 
/* General-purpose pointer 
/* Pointer to one symbol on rhs 
/* Current element of right-hand side 
I I sym->val > Last_real_nonterm ) *I 
*I 
*I 
*I 
/* If the current symbol isn't a nonterminal, or if it is a nonterminal 
* that used to be an action (one that we just transformed), ignore it. 
*I 
return; 
for( prod = sym->productions; prod 
{ 
if( prod->rhs_len == 0 ) 
continue; prod 
pp prod->rhs + (prod->rhs len-1); 
cur *pp; prod->next ) 
if( ISACT(cur) /* Check rightmost symbol */ 
{ 
print_one_case( prod->num, cur->string, --(prod->rhs len), 
cur->lineno, prod); 
.... 
404 Bottom-Up Parsing-Chapter 5 
Listing 5.15. continued ... 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 delsym 
free 
freesym 
*pp--= (HASH_TAB*) Symtab, (BUCKET*) cur); 
cur->string ); 
cur); 
NULL; 
/* cur is no longer valid because of the --pp above. *I 
/* Count the number of nonactions in the right-hand */ 
/* side. *I 
for(; pp >= prod->rhs; --pp 
{ 
cur = *pp; 
if ( ! ISACT (cur) 
continue; 
if( Cur nonterm >= MAXNONTERM ) 
error(l,"Too many nonterminals & actions (%d max)\n", MAXTERM); 
else 
/* Transform the action into a nonterminal. */ 
Terms[ cur->val = ++Cur_nonterm] =cur ; 
cur->productions = (PRODUCTION*) malloc( sizeof(PRODUCTION) ); 
if( !cur->productions ) 
error(l, "INTERNAL [dopatch]: Out of memory\n"); 
/* Case value to use. *I print_one_case( Num_productions, 
cur->string, 
pp -prod->rhs, 
cur->lineno, 
prod /* Source code. 
/* # symbols to 
I* Input line # *I 
left of act.* I 
of code. */ 
) ; 
/* Once the case is printed, the string argument can be freed.*/ 
free( cur->string ); 
cur->string 
cur->productions->num 
cur->productions->lhs 
cur->productions->rhs len 
cur->productions->rhs[O] 
cur->productions->next 
cur->productions->prec NULL; 
Num_productions++ 
cur ; 
0; 
NULL; 
NULL; 
0; 
/* Since the new production goes to epsilon and nothing else, 
* FIRST(new) == { epsilon }. Don't bother to refigure the 
* follow sets because they won't be used in the LALR(l) state­
* machine routines [If you really want them, call follow() 
* again.] 
*I 
cur->first = newset(); 
ADD( cur->first, EPSILON); 
Section 5.11.1-Modifying the Symbol Table for LALR(I) Grammars 405 
Listing 5.15. continued ... 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 208 
209 
210 
211 
212 213 
214 
215 
216 
217 218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 230 
231 
232 
233 
234 
235 
236 
237 PRIVATE void print_one case( case val, action, rhs size, lineno, prod ) 
-/* Numeric value attached to case itself.*/ 
/* Source Code to execute in case. */ 
/* Number of symbols on right-hand side. */ int case_val; 
unsigned char *action; 
int rhs size; 
int lineno; /*input line number (for #lines). */ 
PRODUCTION *prod; /* Pointer to right-hand side. */ 
{ 
/* Print out one action as a case statement. All $-specifiers are mapped 
* to references to the value stack: $$becomes Yy_vsp[O], $1 becomes 
* Yy_vsp[-1], etc. The rhs_size argument is used for this purpose. 
* [see do_dollar() in yydollar.c for details]. 
*I 
int 
char num, i; 
*do_dollar (); 
extern char *production_str(); 
char fname[40], *fp; 
if( !Make actions 
return; /* source found in yydollar.c */ 
/* source found in acts.c */ 
/* place to assemble $<fname>1 */ 
output("\n case %d: /* %s */\n\n\t", case_val, production_str(prod) ) ; 
if( !No lines 
output("#line %d \"%s\"\n\t", lineno, Input file_name ); 
while( *action ) 
{ 
if( *action != '$' ) 
output( "%c", *action++); 
else 
{ 
/* Skip the attribute reference. The if statement handles $$ the 
* else clause handles the two forms: $N and $-N, where N is a 
*decimal number. When we hit the do dollar call (in the output() 
* call), "num" holds the number associated with N, or DOLLAR DOLLAR 
* in the case of $$. 
*I 
if( *++action != '<' 
*fname = '\0'; 
else 
{ 
++action; 
fp = fname; /* skip the < *I 
for(i=sizeof(fname); --i>O && *action && *action != '>'; ) 
*fp++ = *action++; 
*fp = , \0'; 
if( *action 
++action; , >' ) 
if( *action== '$' ) 
{ 
num = DOLLAR_DOLLAR; 
++action; 
406 Bottom-Up Parsing-Chapter 5 
Listing 5.15. continued ... 
else 
num = atoi( action); 
if( *action == '-' ) 
++action ; 
while( isdigit(*action) 
++action ; 
output( "%s", do_dollar( num, rhs size, lineno, prod, fnru ) ) ; 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 output("\n break;\n" ) ; 
Imbedded actions. 
Dollar-attribute transla­
tion: do_ dollar () . 
%union fields. Those actions that are already at the far right of a production are just output with the 
production number as the case value (by the if statement in do _patch () on lines 114 
to 123 of Listing 5.15). The action is effectively removed from the production with the 
*pp--=NULL on line 122. The for loop that starts on line 128 looks for imbedded 
actions, and, if any are found, modifies the grammar accordingly. Productions of the 
form: 
s symbols {action();} symbols; 
are translated into: 
s symbols 001 symbols 
001 ( action(); } 
The new nonterminal (named 001, above) is created on lines 141 to 145 (and initialized 
on lines 156 to 173) by transforming the existing SYMBOL structure (the one that 
represents the action) into a nonterminal that has an empty right-hand side. The new 
production number is assigned on line 141. Note that the production in which the action 
was imbedded doesn't need to be modified. The SYMBOL pointer that used to reference 
the action now references the nonterminal, but it's the same pointer in both situations. 
The print_ one_ case ( ) routine, which prints the code associated with the action, 
starts on line 179 of Listing 5.15. Dollar attributes($$, $1, $-1, and so forth) are han­
dled on lines 209 to 248. The actual work is done by do_ dollar(), in Listing 5.16. It 
is passed the attribute number (the I in $1), the number of symbols on the right-hand side 
of the current production, the input line number (for error messages) and a pointer to the 
PRODUCTION. It evaluates to a string holding the code necessary to reference the 
desired attribute (using the translations discussed earlier on Page 388). 
Fields that are attached to a %union are also handled here (on lines 25 to 36 and 57 
to 75 of Listing 5.16). The code on lines 25 to 36 handles any fields associated with$$, 
the names of which are found in *prod->lhs->field. The code on lines 57 to 75 
handles other attributes. Since num is theN in $N, (prod->rhs) [num-1]->field 
gets the field associated with the specified element of the right-hand side. Note that 
fields can't be used with negative attribute numbers (because occs has no way of know­
ing what right-hand side corresponds to that field). A warning is printed in this case. 
Section 5.11.1-Modifying the Symbol Table for LALR(l) Grammars 407 
Listing 5.16. yydollar.c- Process $ Attributes 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include "parser.h" 
PUBLIC char *do_dollar( num, rhs size, lineno, prod, fname ) 
int num; /* The N in $N, DOLLAR_DOLLAR for $$ (DOLLAR_DOLLAR) */ 
int rhs_size; /* is defined in parser.h, discussed in Chapter Four. */ 
/* Number of symbols on right-hand side, 0 for tail */ 
int 
PRODUCTION lineno; 
*prod; /* Input line number for error messages */ 
/* Only used if rhs_size is >= 0 */ 
char 
{ *fname; /* name in $<name>N */ 
static char buf[ 128 ]; 
int i, len 
if( num == DOLLAR_DOLLAR ) 
{ 
strcpy( buf, "Yy_val" ); 
if( *fname ) 
sprintf( buf+6, ".%s", fname ) ; 
else if( fields_active() ) 
{ 
if( *prod->lhs->field ) 
sprintf( buf+6, ".%s", prod->lhs->field ); 
else 
{ /* Do $$ */ 
/* $<name>N *I 
error( WARNING, "Line %d: No <field> assigned to$$, " 
else 
{ "using default int field\n", lineno ); 
sprintf( buf+6, ".%s", DEF FIELD); 
if( num < 0 
++num; 
if( rhs size < 0 ) /* $N is in tail */ 
else 
{ sprintf( buf, "Yy_vsp[ Yy_rhslen-%d ]", num ); 
if( (i = rhs_size -num) < 0 
else 
{ error( WARNING, "Line %d: Illegal $%d in production\n", 
lineno, num) ; 
len= sprintf( buf, "yyvsp[%d]", i ) ; 
if( *fname ) 
sprintf( buf +len, ".%s", fname ); 
else if( fields_active() 
{ /* $<name>N */ 
.... 
408 Bottom-Up Parsing-Chapter 5 
Listing 5.16. continued ... 
59 if ( num <= 0 ) 
{ 60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 return buf; error(NONFATAL, "Can't use %%union field with negative" 
"attributes. Use $<field>-N\n" ); 
else if( * (prod->rhs) [num-1]->field ) 
else 
{ sprintf ( buf + len, ". %s", (prod->rhs) [num-1]->field ) ; 
error( WARNING, "Line %d: No <field> assigned to $%d, " 
"using default int field\n", 
lineno, num ); 
sprintf( buf +len, ".%s", DEF FIELD); 
5.12 Parser-File Generation 
The routines in Listing 5.17 and 5.18 handle the occs parser-file generation. They 
are much like the LLama routines with the same names. There are two possible tem­
plate files, however. The one that we've been looking at (occs.par) is used in most situa­
tions. If -a is specified on the command line, however, the file occs-act.par (in Listing 
5.19) is used instead. All that's needed here are external declarations that give us access 
to variables declared in the associated parser file (generated with a -p command-line 
switch). 
Listing 5.17. yycode .c-Controller Routine for Table Generation 
I 
2 
3 
4 
5 
6 void tables () 
make_yy_stok(); 
make_token_file(); 
make_parse_tables(); /* in stok.c */ 
/* in stok.c */ 
/* in yystate.c */ 
5.13 Generating LALR(1) Parse Tables 
The only part of occs we've yet to explore is the table-generation subroutines, all 
concentrated into a single (somewhat large) module called yystate.c. The routines create 
an LR(l) parse table, but before creating a new LR(l) state, the code looks for an exist­
ing state with the same LR(O) kernel items as the new one. If such a state exists, looka­
heads are added to the existing state rather than creating a new one. 
Section 5.13-Generating LALR(l) Parse Tables 
Listing 5.18. yydriver.c- Routines to Create Occs Output File 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/set.h> 
#include <tools/hash.h> 
#include <tools/compiler.h> 
#include <tools/l.h> 
#include "parser.h" 
/*----------------------------------------------------------------------*/ 
void file header 
void code header 
void driver P ( ( void ) ) ; 
P ( ( void ) ) ; 
P ( ( void ) ) ; /* public */ 
/*----------------------------------------------------------------------*/ 
PRIVATE FILE *Driver_file = stderr ; 
/*----------------------------------------------------------------------* Routines in this file are aces specific. There's a different version of all 
* these routines in lldriver.c. They MUST be called in the following order: 
* file_header() 
* code_header () 
* driver() *----------------------------------------------------------------------
*I 
PUBLIC void file_header() 
( 
/* This header is printed at the top of the output file, before the 
* definitions section is processed. Various #defines that you might want 
* to modify are put here. 
*I 
output( "#include \"%s\"\n\n", TOKEN FILE ); 
if( Public ) 
output ( "#define PRIVATE\n" ) ; 
if( Debug ) 
output( "#define YYDEBUG\n" ) ; 
if( Make actions ) -output ( "#define YYACTION\n" ) ; 
if( Make __parser ) 
output ( "#define YYPARSER\n" ) ; 409 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 if( ! ( Driver_file =driver l(Output, !No lines, Template) )) 
error( NONFATAL, "%s not found--output file won't compile\n", Template); 
l*----------------------------------------------------------------------*1 
PUBLIC void 
{ code_ header () 
410 Bottom-Up Parsing-Chapter 5 
Listing 5.18. continued ... 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 /* This stuff is output after the definitions section is processed, but 
* before any tables or the driver is processed. 
*I 
driver_2 ( Output, !No lines ) ; 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ driver() 
/* Print out the actual parser by copying llama.par to the output file. 
*I 
if( Make_parser ) 
driver_2( Output, !No lines ); 
fclose( Driver file); 
Listing 5.19. occs-act.par- File Header for -a Output 
#undef YYD 
#ifdef YYDEBUG 
# define YYD(x) X 
# define printf yycode 
#else 
# define YYD(x) /* empty *I 
#endif 
extern void yycode (); 
extern void yydata (); 
extern void yybss (); 
extern void yycomment (); 
extern YYSTYPE *Yy_vsp; 
extern 
extern 
Representing LR(1) 
items:, ITEM. YYSTYPE Yy_val; 
int Yy_ rhslen; 
Though this process is straightforward, a lot of code and several data structures have 
to work in concert to implement it. These data structures start on line 25 of Listing 5.20 
with an ITEM declaration, which represents an LR( 1) item. There is a certain amount of 
redundancy here in order to speed up the table generation process. For example, the 
right_ of_ dot field points to the symbol to the right of the dot. (Remember, the PRO­
DUCTION itself is stored as an array of SYMBOL pointers. It holds NULL if the dot is at 
Section 5.13-Generating LALR(I) Parse Tables 
the far right of the production.) Occs could extrapolate this information from the PRO­
DUCTION and dot position (the offset to which is in dot _posn) every time it used the 
ITEM, but it's best, for speed reasons, to do the extrapolation only once since the dot 
position does not change within a given ITEM. Similarly, the production number could 
be derived from the PRODUCTION structure, but I've copied it here to avoid an extra 
level of indirection every time the production number is used. The RIGHT_ OF_ DOT 
macro on line 35 of Listing 5.20 gets the numeric, tokenized value of the SYMBOL to the 
right of the dot. It evaluates to zero (which isn't used for any of the input symbols) if the 
dot is at the far right of the production. 
Listing 5.20. yystate.c- Universal Constants and LR(l) Items 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <malloc.h> 
#include <toolsldebug.h> 
#include <toolslset.h> 
#include <toolslhash.h> 
#include <toolslcompiler.h> 
#include <toolsll.h> 
#include "parser.h" 
#include "lltok.h" I* For EOI definition *I 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 1*----------------------------------------------------------------------*l 
PRIVATE int 
PRIVATE int 
PRIVATE int 
PRIVATE int 
PRIVATE int 
#define MAXSTATE 
#define MAXOBUF Nit ems 
Npairs 
Ntab entries 
Shift reduce 
Reduce reduce 0; 
0; 
0; 
0; 
0; I* For statistics only: 
I* number of LR(l) items 
I* # of pairs in output tables 
I* number of transitions in tables 
I* number of shift/reduce conflicts 
I* number of reduce/reduce conflicts 
512 
256 I* Max # of LALR(l) states. *I 
*I I* Buffer size for various output routines 
l*----------------------------------------------------------------------*1 
typedef struct item I* LR (1) item: 
{ 
int prod_num; I* production number 
PRODUCTION *prod; I* the production itself 
SYMBOL *right_of dot; I* -symbol to the right of the dot 
unsigned char dot_posn; I* offset of dot from start of production 
SET *lookaheads; I* set of lookahead symbols for this item 
ITEM; 
#define RIGHT_OF_DOT(p) (p)->right_of_dot ? (p)->right_of_dot->val 0 ) 411 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I *I 
The next data structure of interest represents an LR(l) state. The STATE structure is 
defined, along with a few related constants, in Listing 5.21. Most of the closure items 
don't have to be stored in the STATE because they can be derived from the kernel items 
if necessary. The exceptions are items that contain E productions, because these items 
cause reductions from the current state, not a transition to a new state. The closure items 
with E productions are effuctively part of the kernel, at least from the perspective of the 
parse table. The set of E items are in their own array because the table-creation code 
occasionally compares two STATE structures to see if they're equivalent. This 
equivalence can be determined by comparing the true kernel items only. There's no Representing an LR(1) 
state: STATE. 
412 Bottom-Up Parsing-Chapter 5 
point in also comparing the E items too, because the same kernel items in both states gen­
erate the same closure items-including the E items-in both states. The 
kernel_items [] array is kept sorted to facilitate STATE comparisons. The sort cri­
teria is pretty much arbitrary, but the sorting serves to get the two sets of kernel items to 
appear in the same order in both STATEs. I'll discuss the comparison routine that's used 
for this purpose in a moment. 
Listing 5.21. yystate.c- LR(l) States 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 Ide fine MAX KERNEL 32 
Ide fine MAXCLOSE 128 
I define MAXEPSILON 8 
typedef short STATENUM; 
typedef struct state 
{ I* 
I* 
I* 
I* 
I* Maximum number of kernel items in a state. 
Maximum number of closure items in a state (less 
the epsilon productions) . 
Maximum number of epsilon productions that can be 
in a closure set for any given state. 
I* LR(l) state 
ITEM *kernel items [MAXKERNEL ]; 
ITEM *epsilon_items [MAXEPSILON]; I* Set of kernel items. 
I* Set of epsilon items. 
unsigned nkitems 7 I* # items in kernel items[}. 
unsigned neitems 7 I* # items in epsilon_items [}. 
unsigned closed 1 I* State has had closure performed. 
STATENUM num; I* State number (0 is start state). 
STATE; *I 
*I 
*I 
*I 
*I 
*I 
*I *I 
*I 
*I 
*I 
*I 
Internal representation of 
the parse table: The next listing (Listing 5.22) contains definitions used to build the internal 
representation of the actual parse tables. The mechanism used is essentially the same as 
that used by the output tables, but the transitions are stored as linked lists of structures 
rather than input-symbol/next-state pairs. The Actions [] array (on line 64) is indexed 
by current state. Each cell of Actions [ J points at the head of a linked list of ACT 
structures, one element of which is an input symbol, and the other element of which is 
the action to take when that symbol is encountered from the current state. The Goto [ ] 
table (on line 68) is essentially the same. Actions, ACT, Go to. 
Memory management: 
new(). 
CHUNK. The table-generation code begins in Listing 5.23 with several routines to manage the 
parse table just discussed. The allocation routine, new ( ) on line 73 allocates space for 
an ACT structure. Since the space used by these structures need never be freed, mal­
lac () , which is both slow and expensive in terms of system resources, need not be 
called every time a new structure is required; rather, new () allocates an array of struc­
tures with a single malloc () call on line 84. CHUNK, #defined on line 71, determines 
the number of structures in the array. new () then returns pointers to structures in this 
array until all array elements have been allocated. Only then does it get another array of 
structures from malloc (). The remainder of the routines in the listing either put new 
elements in the table, or return pointers to existing elements. 
Section 5.13 -Generating LALR( I) Parse Tables 413 
Listing 5.22. yystate.c- Internal Representation of the Parse Table 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 typedef struct act_or_goto 
{ 
int sym; 
int do_this; 
struct act or_goto *next; 
} ACT; /* Given this input symbol, */ 
/* do this. >0 == shift, <0 == reduce */ 
/* Pointer to next ACT in the linked list. */ 
typedef ACT GOTO; /* GOTO is an alias tor ACT */ 
PRIVATE ACT *Actions[MAXSTATE]; /*Array of pointers to the head of the action 
* chains. Indexed by state number. 
* I'm counting on initialization to NULL here. 
*I 
PRIVATE GOTO *Gotos[MAXSTATE]; /*Array of pointers to the head of the goto 
* chains. 
*I 
Listing 5.23. yystate .c-Parse-Table Memory Management 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 #define CHUNK 
PRIVATE void 
{ 128 /* New() gets this many structures at once */ 
*new() 
/* Return an area of memory that can be used as either an ACT or GOTO. 
* These objects cannot be freed. 
*I 
static ACT 
static ACT *eheap 
*heap 
if( heap >= eheap 
{ (ACT *) 0; 
(ACT *) 1; 
if( ! (heap= (ACT*) ma1loc( sizeof(ACT) *CHUNK) )) 
error( FATAL, "No memory for action or goto\n" ) ; 
eheap = heap + CHUNK ; 
++Ntab entries 
return heap++ 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE ACT *p_action( state, input sym 
int state, input_sym; 
/* Return a pointer to the existing ACT structure representing the indicated 
* state and input symbol (or NULL if no such symbol exists). 
*I 
ACT *p; 
for( p = Actions[state]; p; p p->next ) 
if( p->sym input sym ) 
return p; 
.... 
414 Bottom-Up Parsing-Chapter 5 
Listing 5.23. continued ... 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
!52 
153 
!54 
155 
156 
!57 
!58 
!59 
160 
161 
162 
163 
164 
165 
166 return NULL; 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE void add_action( state, input sym, do this 
int state, input_sym, do_this; 
/* Add an element to the action part of the parse table. The cell is 
* indexed by the state number and input symbol, and holds do this. 
*I 
ACT *p; 
if( Verbose > 1 ) 
printf("Adding shift or reduce action from state %d: %don %s\n", 
state, do_this, Terms[ input_sym ]->name); 
p 
p->sym 
p->do_this 
p->next 
Actions[state] 
/* - - - - -(ACT *) new () ; 
input_sym ; 
do_this ; 
Actions[state]; 
p; 
- - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE GOTO *p_goto( state, nonterminal ) 
int state, nonterminal; 
/* Return a pointer to the existing GOTO structure representing the 
*indicated state and nonterminal (or NULL if no such symbol exists). The 
* value used for the nonterminal is the one in the symbol table; it is 
* adjusted down (so that the smallest nonterminal has the value 0) 
* before doing the table look up, however. 
*I 
GOTO *p; 
nonterminal = ADJ_VAL( nonterminal ); 
for( p = Gotos[ state ] ; p; p = p->next 
if( p->sym nonterminal ) 
return p; 
return NULL; 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PRIVATE void add_goto( state, nonterminal, go_here 
int state, nonterminal, go_here; 
/* Add an element to the goto part of the parse table, the cell is indexed 
* by current state number and nonterminal value, and holds go_here. Note 
* that the input nonterminal value is the one that appears in the symbol 
* table. It is adjusted downwards (so that the smallest nonterminal will 
* have the value 0) before being inserted into the table, however. 
*I 
Section 5.13-Generating LALR(I) Parse Tables 
Listing 5.23. continued ... 
GOTO 
int *p; 
unadjusted; 
nonterminal; /* Original value of nonterminal 
unadjusted 
nonterminal ADJ_VAL( nonterminal ); 
if( Verbose > 1 
printf( "Adding goto from state %d to %don %s\n", 415 
*I 167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 state, go_here, Terms[unadjusted]->name ); 
p 
p->sym 
p->do_this 
p->next 
Gotos[state] ( GOTO *) new ( ) ; 
nonterminal; 
go_here; 
Gotos[state]; 
p; 
The next listing (Listing 5.24) contains definitions for the data structures used to to State management. 
manage the LR(l) STATEs as the state machine is constructed. Before looking at the 
actual code, consider the logic used to create the machine, summarized in Table 5.15. 
Table 5.15. An Algorithm for Creating an LALR( I) State Machine 
Data structures: 
A state data base. 
A list of unclosed states in the state data base. 
Initially: 
Create the start state and put it into both the state data base and the unclosed-state list. 
Create LALR( I) state machine: 
a. for( each state in the list of unclosed states ) 
{ 
b. Perform LR( 1) closure on state, generating a set of new states and associated lookaheads. 
c. for( each new _state generated by the closure operation ) 
{ 
d. if( an existing_state with the same kernel items as the new _state already exists ) 
{ 
e. Merge appropriate next-state transitions from state with existing_state. 
f. Add lookaheads in new _state to the lookaheads in existing_state. 
g. if( the previous step added new symbols to the lookahead set AND 
the existing state isn't already in the list of unclosed states) 
h. Add the existing state to the list of unclosed states. 
i. 
j. 
k. I 
else 
{ 
Add appropriate next-state transitions from state to new _state. 
Add the new state to the state data base. 
Add the new state to the list of unclosed states. 
Two data structures are used by the algorithm to keep track of the states. The states Finished-states list. 
themselves must be stored in a data base of some sort because every time a new state is 
created, you have to see if a state with the same set of kernel items already exists. (If it 
416 Bottom-Up Parsing-Chapter 5 
Listing 5.24. yystate.c- LR-State Memory Management-Data Structures 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 PRIVATE HASH TAB *States 
PRIVATE int Nstates 
#define MAX UNFINISHED 128 
typedef struct tnode 
{ 
STATE *state; NULL; 
= 0; 
struct tnode *left, *right; 
TNODE; I* LR(l) states 
I* Number of states. *I 
*I 
PRIVATE TNODE 
PRIVATE TNODE Heap[ MAX UNFINISHED]; I* Source of all TNODEs *I 
*I 
PRIVATE TNODE 
PRIVATE TNODE 
PRIVATE ITEM 
PRIVATE int 
PRIVATE int *Next allocate = Heap I* Ptr to next node to allocate 
*Available NULL; 
*Unfinished = NULL; 
**State_items; 
State_nitems; 
Sort_by_number 0; I* Free list of available nodes *I 
I* linked list of TNODES. p->left *I 
I* is used as the link. *I 
I* Tree of unfinished states. *I 
I* Used to pass info to state cmp *I 
I* 
I* *I 
*I 
#define NEW 0 
#define UNCLOSED 1 
#define CLOSED 2 I* Possible return values from 
I* newstate(). *I 
*I 
does exist, the next-state transitions go to the existing state rather than the newly created 
one.) An unsorted array is inappropriate for holding the list of existing states because 
the search time is too long. Fortunately, we already have a quite workable data-base 
manager in the guise of the hash-table functions that we've been using for symbol-table 
management, and I use those routines here to keep track of the existing states. The 
States pointer (declared on line 182 of Listing 5.24) points at a hash table of LR(l) 
states. The maketab () call that initializes the table is done in one of the higher-level 
routines discussed later in this section. 
Unfinished-states list. The next data structure keeps track of those states that are created in a closure opera­
tion, but have not, themselves, been closed. Since each closure operation creates several 
new states, a mechanism is needed to keep track of those states on which closure has not 
yet been performed. Look-up time is an issue here, as well, because step (g) of the algo­
rithm must test to see if the state is already in the list of unclosed states before adding it 
to the list. Though a hash table could also be used here, I've opted for a binary tree 
because it's both easy to implement in this application and somewhat more efficient than 
the general-purpose hash-table functions. It's also easier, in the current application, to 
remove an arbitrary state from a binary tree than from the hash table-the removed state 
is always a leaf, here. So, the unclosed-state list is implemented as a binary tree of 
pointers to STATEs in the hash table. The TNODE structure used for the tree nodes is 
defined on lines 187 to 192 of Listing 5.24. The complete system is pictured in Figure 
5.14. TNODE. 
Unfinished-state manage­
ment: Available. 
Next_allocate,Heap. The Available list at the bottom of Figure 5.14 manages nodes in the tree that 
have been used at least once. Tree nodes are, initially, managed like the STATES. An 
array of several of them (called Heap) is defined on line 194 of Listing 5.24. 
Next_allocate (defined on the next line) is a pointer to the next available node in 
Section 5.13-Generating LALR(l) Parse Tables 
Figure 5.14. The State Data Base and Unclosed-State List 
r------------, 
States Unfinished -----+-7 -
"'' '' ' STATE ' ' ' ' ' ' 
<---------
STATE 
<---------
STATE 
K 
STATE STATE 
-___________ ...J 
Available 
Heap [ ). Initially, nodes are taken from the Heap [ J by incrementing the 
Next _allocate pointer. When a node is removed from the unclosed-state tree, that 
node is added to the linked list pointed to by Available. New nodes are allocated 
from the linked list if it isn't empty, otherwise a new node is fetched from the Heap [ ). 
This strategy is necessary because malloc () and free () are too slow. 417 
New states are created and initialized by newstate, at the top of Listing 5.25. Note STATE allocation: new­
that you don't have to initialize the new node until after you've decided whether or not state 0 · 
to put it into the tree. You can get away with this delay because the comparison function 
used to do the insertion is always called with: cmp (existing, new), where exist-
ing is the node already in the tree and new is the new one. The comparison function 
doesn't have to actually examine the new node to do the comparison, however. The 
ITEM pointer and count that's passed into newstate () can be copied into global vari-
ables, and the comparison function can look at those global variables instead of the 
actual contents of the new node. State_items and State_nitems, which were 
declared on lines 202 and 203 of Listing 5.24, are used for this purpose. The delayed ini-
tialization gives you a little more speed, because you don't have to do a true initializa-
tion unless it's absolutely necessary. 
The add_ unfinished () subroutine on line 267 of Listing 5.25 adds nodes to the Add to unfinished list: 
unfinished list, but only if the node is not already there. As discussed earlier, a binary add-unfinished 0 · 
tree is used for the list. Note that this is not an ideal data structure because nodes are, at 
least initially, inserted in ascending order, yielding a worst-case linked list. Things 
improve once the lookaheads start being added because previously removed states are 
put back onto the list more or less randomly. This situation could be improved by using 
a unique random number as an identifier rather than the state number. But, it will most 
likely take longer to generate this number than it will to chase down the list. Alternately, 
you could keep the list as an array and do a binary-insertion sort to put in the new 
418 Bottom-Up Parsing-Chapter 5 
Listing 5.25. yystate.c- LR-State Memory Management-Subroutines 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 PRIVATE int newstate( items, nitems, statep) 
ITEM 
int 
STATE 
{ **items; 
nitems; 
**statep; 
STATE *state; 
STATE *existing; 
int state_cmp() 
if( nitems > MAXKERNEL 
error( FATAL, "Kernel of new state %d too large\n", Nstates ); 
State items 
State nitems items; 
nitems; /* set up parameters for state_cmp */ 
/* and state hash. */ 
if( existing 
{ findsym( States, NULL ) ) 
/* State exists; by not setting "state" to NULL, we'll recycle */ 
/* the newly allocated state on the next call. */ 
*statep = existing; 
if( Verbose > 1 ) 
{ 
printf("Using existing state (%sclosed): ", 
existing->closed ? "" "un" ); 
else pstate_stdout( existing); 
return existing->closed ? CLOSED UNCLOSED 
if( Nstates >= MAXSTATE ) 
error(FATAL, "Too many LALR(l) states\n"); 
if( ! (state= (STATE*) newsym(sizeof(STATE)) )) 
error( FATAL, "Insufficient memory for states\n" ); 
memcpy( state->kernel items, items, nitems * sizeof(ITEM*) ); 
state->nkitems nitems; 
state->neitems 0; 
state->closed 0; 
state->num Nstates++ 
*statep state; 
addsym( States, state); 
if( Verbose > 1 
{ 
printf("Forming new state:"); 
pstate_stdout( state); 
return NEW; 
/*----------------------------------------------------------------------*/ 
.... 
Section 5.13-Generating LALR(l) Parse Tables 419 
Listing 5.25. continued ... 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 318 
319 
320 
321 
322 
323 
324 
325 
326 PRIVATE void 
STATE 
{ *state; add_unfinished( state ) 
TNODE **parent, *root; 
int cmp; 
parent = &Unfinished; 
root = Unfinished; 
while( root ) I* look for the node in the tree *I 
{ 
if( (cmp = state->num -root->state->num) == 0 ) 
break; 
else 
{ 
parent 
root 
if( !root ) 
{ (cmp < 0) ? &root->left 
(cmp < 0) ? root->left &root->right 
root->right 
I* Node isn't in tree. *I 
if( Available 
{ I* Allocate a new node and *I 
I* put it into the tree. *I 
*parent 
Available Available ; 
Available-> left I* Use node from Available *I 
I* list if possible, otherwise *I 
I* get the node from the Heap. *I 
else 
if( Next_allocate >= &Heap[ MAX_UNFINISHED ] ) 
error(FATAL, "Internal: No memory for unfinished state\n"); 
*parent = Next_allocate++; 
{*parent)->state 
(*parent) ->left state; 
(*parent)->right I* initialize the node *I 
NULL; 
1*----------------------------------------------------------------------*l 
PRIVATE STATE 
{ *get_unfinished() 
I* Returns a pointer to the next unfinished state and deletes that 
* state from the unfinished tree. Returns NULL if the tree is empty. 
*I 
TN ODE 
TN ODE *root; 
**parent; 
if( !Unfinished ) 
return NULL; 
parent = &Unfinished; 
if( root Unfinished 
{ 
while( root->left 
{ 
parent 
root &root-> left 
root->left ; I* find leftmost node *I 
.... 
420 
Listing 5.25. continued ... 
327 
328 
329 
330 
331 
332 *parent 
root->left 
Available root->right 
Available; 
root; Bottom-Up Parsing-Chapter 5 
/* Unlink node from the tree 
/* Put it into the free list *I 
*I 
333 
334 return root->state 
335 
STATE comparison, 
state_cmp(). 
STATE hashing, 
state_hash (). 
ITEM management, 
newitem(), 
free_item (), 
free_recycled_items(). 
movedot (). 
ITEM comparison: 
item_cmp (). elements. Again, the time required to move the tail end of the array is comparable to the 
time required to chase down the list. Another solution uses a SET of unfinished-state 
numbers. The problem here is that, towards the end of creating a big table (when things 
are slower anyway), almost all of the unfinished states will have large state numbers. If 
the smallest state number is 256 (for example) you'll have to look at 16 empty words in 
the bit map before finding one with a set bit. Empirical testing showed that using a SET 
slowed things down by about 5% (which translates to about lO seconds ·on a big gram­
mar, with occs running on my 8MHz IBM-PC/AT). The get_ unfinished () subrou­
tine on line 307 of Listing 5.25 gets a node from the unfinished list. It returns 0 when the 
list is empty. 
The next Listing (Listing 5.26) holds a comparison and a hash function that can be 
used to order the states. The comparison function, state_ cmp ( ) on line 336 of Listing 
5.26, is needed to compare states when searching for a particular state in the array. 
States are equivalent if they have the same set of kernel items, and equivalence can be 
determined from the production numbers and dot positions only. The lookaheads don't 
matter because you're testing for equivalence only to see if the lookaheads for a new 
LR( 1) state can be merged with those of an existing one. Similarly, the actual ordering 
of states is immaterial as long as the ordering is consistent, so you can do easy things for 
sort criteria. The rules are: 
(1) The STATE with the most items is larger. 
(2) If the STATEs have the same number of items, the two lists of items are compared. 
Remember, these lists are sorted, so you can do what amounts to a lexicographic 
comparison, here. The for loop on lines 360 to 367 of Listing 5.26 scans the list of 
items until it finds a mismatched item. If there are no mismatched items, the states 
are equivalent. 
(3) The items are compared using two criteria: The item with the largest production 
number is the largest (this test is on line 362). Otherwise, if both items have the 
same production number, the item with the dot further to the right is the larger (this 
test is on line 365). 
The hash function on line 372 of Listing 5.26 is used to manage the finished-state list. 
It is much easier to implement than the sort-comparison function. It just sums together 
the production numbers and dot positions of the items. 
The next set of subroutines, in Listing 5.27 takes care of ITEM management. 
new item() (on line 394) allocates space for (and initializes) a new item, freei tern() 
(on line 421) puts an item on a recycle heap for later allocation by newitem(). 
free_ recycled_ i terns () (on line 429) cleans up after all processing finishes-it 
frees memory used for the entire set of items. The movedot ( ) function on line 442 
moves the dot over one notch and updates associated fields in the ITEM structure. 
The item_ cmp () function on line 365 is used to sort the items within a STATE 
structure. The primary sort criterion is the numeric value that represents the symbol to 
Section 5.13-Generating LALR(l) Parse Tables 421 
Listing 5.26. yystate.c- State Comparison Functions 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 388 
389 
390 
391 PRIVATE int state cmp ( new, tab_node ) 
/* 
/* 
/* STATE *new Pointer to new node (ignored */ 
if Sort_by_number is false). */ 
Pointer to existing node */ STATE 
{ *tab_node; 
/* Compare two states as described in the text. Return a number representing 
* the relative weight of the states, or 0 of the states are equivalent. 
*I 
ITEM **tab item 
ITEM **item 
int nitem 
int cmp 
if( Sort_by_number /* Array of items for existing state 
/* Array of items for new state 
/* Size of " 
return( new->num- tab_node->num ); *I 
*/ 
*I 
if( cmp = State_nitems -tab node->nkitems 
return cmp; /* s2ate with largest */ 
/* number of items is */ 
/* larger. */ 
nitem 
item 
tab item State nitems ; 
State items 
tab node->kernel items; 
for(; --nitem >= 0 ; ++tab_item, ++item 
{ 
if( cmp = (*item)->prod_num- (*tab_item)->prod_num 
return cmp; 
if( cmp = (*item)->dot_posn- (*tab_item)->dot_posn 
return cmp; 
return 0; /* States are equivalent */ 
PRIVATE int state_hash( sym ) 
STATE *sym; I* ignored *I 
{ 
/* Hash function for STATEs. Sum together production numbers and dot 
* positions of the kernel items. 
*I 
ITEM **items 
int nitems 
int total /* Array of items for new state 
/* Size of " 
items 
nitems 
total State items 
State nitems 
0; 
for(; --nitems >= 0 ; ++items ) 
total += (*items)->prod_num + (*items)->dot_posn; 
return total; *I 
*I 
422 Bottom-Up Parsing-Chapter 5 
the right of the dot. This means that E productions float to the top of the list, followed by 
productions with terminals to the right of the dot, followed by productions with nonter­
minals to the right of the dot. The ordering is handy when you're partitioning the closure 
items to create new state kernels. Items with the same symbol to the right of the dot will 
be adjacent in the sorted list. The second sort criteria (if the same symbol is to the right 
of the dot in both items) is the production number, and the ternary criteria is the dot posi­
tion. 
Listing 5.27. yystate.c- ITEM Management 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 423 
424 
425 
426 
427 428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 ITEM *Recycled_items = NULL; 
PRIVATE ITEM 
PRODUCTION *newitem( production 
*production; 
{ 
ITEM *item; 
if( Recycled_items 
{ 
item = Recycled_items 
Recycled_items = (ITEM *) Recycled_items->prod; 
CLEAR( item->lookaheads ) ; 
else 
{ 
if( ! (item= (ITEM*) malloc( sizeof(ITEM) )) ) 
error( FATAL, "Insufficient memory for all LR(l) items\n" ); 
item->lookaheads = newset() ; 
++Nitems; 
item->prod 
item->prod_num 
item->dot_posn 
item->right_of_dot 
return item; production ; 
production->num 
0; 
production->rhs[O] 
PRIVATE void freeitem( item ) 
ITEM *item; 
{ 
--Nitems; 
item->prod = (PRODUCTION *) Recycled_items 
Recycled_items = item; 
PRIVATE void 
{ free_recycled_items() 
/* empty the recycling heap, freeing all memory used by items there */ 
ITEM *p; 
while( p = Recycled_items ) 
{ 
Recycled_items = (ITEM *) Recycled_items->prod 
free (p); 
.... 
Section 5.13 -Generating LALR( 1) Parse Tables 
Listing 5.27. continued ... 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 458 
459 
460 
461 
462 
463 
464 
465 
466 PRIVATE movedot( item) 
ITEM *item; 
{ 
/* Moves the dot one position to the right and updates the right_of_dot 
* symbol. 
*I 
item->right_of_dot ( i tem->prod->rhs ) [ ++i tem->dot _posn ] 
PRIVATE int item_cmp( itemlp, item2p ) 
ITEM **itemlp, **item2p ; 
{ 
/* Return the relative weight of two items, 0 if they're equivalent. */ 
int rval; 
ITEM *iteml 
ITEM *item2 *itemlp; 
*item2p; 
if( ! (rval = RIGHT_OF_DOT(iteml) -RIGHT_OF_DOT(item2)) 
if( ! (rval = iteml->prod_num -item2->prod_num ) ) 
return iteml->dot_posn -item2->dot_posn 
return rval; 
The next three listings contain subroutines that make the LR(l) parse table using the 423 
logic discussed previously on page 415. The remainder of the chapter is boring stuff that Making the parse tables. 
does things like print out the tables. Rather than discuss the routines here, I have com-
mented them copiously so that you don't have to be flipping back and forth between the 
listing and the text. 
Listing 5.28. yystate.c- High-Level, Table-Generation Function 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 PUBLIC void 
{ make_parse_tables() 
/* Prints an LALR(l) transition matrix for the grammar currently 
* represented in the symbol table. 
*I 
ITEM 
STATE 
PRODUCTION 
void 
int 
FILE *item; 
*state; 
*start_prod; 
mkstates(); 
state_cmp(); 
*fp, *old_output; 
/* Make data structures used to produce the table, and create an initial 
* LR(l) item containing the start production and the end-of-input marker 
* as a lookahead symbol. 
*I 
States= maketab( 257, state_hash, state_cmp ); 
if( !Goal_symbol 
error(FATAL, "No goal symbol.\n" ); 
424 Bottom-Up Parsing-Chapter 5 
Listing 5.28. continued ... 
490 
491 
492 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 
508 
509 
510 
511 
512 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 start_prod = Goal_symbol->productions 
if( start_prod->next ) 
error(FATAL, "Start symbol must have only one right-hand side.\n" ); 
item = newitem( start_prod ) ; 
ADD( item->lookaheads, EOI ); I* Make item for start production *I 
I* FOLLOW ( S) = { $} *I 
newstate( &item, 1, &state); 
if( lr( state ) 
{ I* Add shifts and gatos to the table *I 
if( Verbose 
printf("Adding reductions:\n"); 
reductions(); I* add the reductions *I 
if( Verbose ) 
printf("Creating tables:\n" ); 
if( !Make_yyoutab ) I* Tables go in yyout.c *I 
{ 
else print_tab( Actions, "Yya", "Yy_action", 1); 
print_tab( Gotos , "Yyg", "Yy_goto" , 1); 
if( !(fp = fopen(TAB_FILE, "w")) 
{ 
error( NONFATAL, "Can't open" TAB FILE", ignoring -T\n"); 
else print_tab( Actions, "Yya", "Yy_action", 1); 
print_tab( Gotos , "Yyg", "Yy_goto" , 1); 
output 
output "extern YY TTYPE *Yy_action[]; I* in yyoutab.c *1\n" ) ; 
"extern YY TTYPE *Yy_goto[]; I* in yyoutab.c *1\n" ); 
old_output 
Output Output; 
fp; 
fprintf(fp, "#include <stdio.h>\n" ); 
fprintf (fp, "typedef short YY_TTYPE; \n" ) ; 
fprintf(fp, "#define YYPRIVATE %s\n", 
Public ? "I* empty *I" 
print_tab( Actions, "Yya", "Yy_action", 0 ) ; 
print_tab( Gotos , "Yyg", "Yy_goto" , 0); 
fclose ( fp ) ; 
Output = old_output; "static" ) ; 
print reductions(); 
Section 5.13 -Generating LALR( I) Parse Tables 
Listing 5.29. yystate.c- Table-Generation Functions 
PRIVATE int lr( cur_state 
STATE *cur_state; 
{ 
/* Make LALR(l) state machine. The shifts and gatos are done here, the 
* reductions are done elsewhere. Return the number of states. 
*I 
ITEM **p; 
ITEM **first item; 
ITEM *closure items[ MAXCLOSE ] ; -STATE *next; /* Next state. *I 
*I 
*I int isnew; /* Next state is a new state. 
int nclose; 
int nit ems; 
int val; 
SYMBOL *sym; /* Number of items in closure items. 
/* # items with same symbol to right 
/* Value of symbol to right of dot. 
/* Actual symbol to right of dot. of dot.* I 
*I 
*I 
states. */ int nlr 0; /* Nstates + nlr ==number of LR(l) 
add unfinished( cur_state ); 
while( cur state = get_unfinished() 
{ 
if( Verbose > 1 
printf( "Next pass ... working on state %d\n", cur_state->num ); 
/* closure() 
* kclose () 
* 
* * assort () 
* 
* 
* adds normal closure items to closure_items array. 
adds to that set all items in the kernel that have 
outgoing transitions (ie. whose dots aren't at the far 
right). 
sorts the closure items by the symbol to the right 
of the dot. Epsilon transitions will sort to the head of 
the list, followed by transitions on nonterminals, 
followed by transitions on terminals. 425 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 * move_eps () 
*I moves the epsilon transitions into the closure kernel set. 
nclose =closure (cur_state, closure_items, MAXCLOSE ); 
nclose = kclosure (cur_state, closure_items, MAXCLOSE, nclose ); 
if( nclose ) 
{ 
assort( closure items, nclose, sizeof(ITEM*), item_cmp ); 
nitems move_eps( cur_state, closure_items, nclose ); 
p closure items + nitems; 
nclose nitems ; 
if( Verbose > 1 ) 
pclosure( cur state, p, nclose ) ; 
/* All of the remaining items have at least one symbol to the */ 
/* right of the dot. */ 
while( nclose > 0 ) 
{ 
first item 
sym 
val p ; 
(*first_item)->right_of_dot 
sym->val ; 
.... 
426 Bottom-Up Parsing-Chapter 5 
Listing 5.29. continued ... 
604 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 
616 
617 
618 
619 
620 
621 
622 
623 
624 
625 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 
638 
639 
640 
641 
642 
643 
644 
645 
646 
647 648 
649 
650 
651 
652 
653 
654 
655 
656 
657 
658 
659 
660 
661 
662 
663 I* Collect all items with the same symbol to the right of the dot. 
* On exiting the loop, nitems will hold the number of these items 
* and p will point at the first nonmatching item. Finally nclose is 
* decremented by nitems. items = 0 ; 
*I 
nitems 0 
do 
{ 
movedot( *p++ ) ; 
++nitems; 
while( --nclose > 0 && RIGHT_OF_DOT(*p) ==val); 
I* (1) newstate{) gets the next state. It returns NEW if the state 
didn't exist previously, CLOSED if LR(O) closure has been 
performed on the state, UNCLOSED otherwise. * 
* * (2) 
* ( 3) 
* (4) add a transition from the current state to the next state. 
* If it's a brand-new state, add it to the unfinished list. 
otherwise merge the lookaheads created by the current closure 
operation with the ones already in the state. 
* (5) 
* If the merge operation added lookaheads to the existing set, 
add it to the unfinished list. 
*I 
isnew = newstate( first item, nitems, &next ); 
if( !cur_state->closed ) 
{ 
if ( IS TERM ( sym ) ) 
add action (cur state->num, val, next->num ); 
else 
add_goto cur_state->num, val, next->num ); 
if( isnew == NEW ) 
add_unfinished( next); 
else 
{ I* 1 *I 
I* 2 *I 
I* 3 *I 
I* 4 *I 
if( merge_lookaheads( next->kernel items, first item, nitems)) 
{ 
add_unfinished( next); 
++nlr; 
while( --nitems >= 0 ) 
freeitem( *first item++ ) ; I* 5 *I 
fprintf( stderr, "\rLR:%-3d LALR:%-3d", Nstates + nlr, Nstates ); 
cur state->closed = 1; 
free_recycled_items(); 
if( Verbose ) 
fprintf(stderr, " states, %d items, %d shift and goto transitions\n", 
Nitems, Ntab entries ); 
return Nstates; 
Section 5.13 -Generating LALR(I) Parse Tables 427 
Listing 5.29. continued ... 
664 
665 
666 
667 
668 
669 
670 
671 
672 
673 
674 
675 
676 
677 
678 
679 
680 
681 
682 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 
719 
720 
721 /*----------------------------------------------------------------------*/ 
PRIVATE int merge lookaheads( dst_items, src_items, nitems ) 
ITEM 
ITEM 
int **src items; 
**dst items; 
nitems; 
/* This routine is called if newstate has determined that a state having the 
* specified items already exists. If this is the case, the item list in the 
* STATE and the current item list will be identical in all respects except 
* lookaheads. This routine merges the lookaheads of the input items 
* (src_items) to the items already in the state (dst_items). 0 is returned 
* if nothing was done (all lookaheads in the new state are already in the 
* existing state), 1 otherwise. It's an internal error if the items don't 
* match. 
*I 
int did_something = 0; 
while( --nitems >= 0 ) 
{ 
if( (*dst_items)->prod != (*src_items)->prod 
II (*dst items)->dot_posn != (*src_items)->dot_posn 
error(FATAL, "INTERNAL [merge_lookaheads], item mismatch\n" ) ; 
if( !subset( (*dst items)->lookaheads, (*src_items)->lookaheads ) ) 
{ 
++did_something; 
UNION( (*dst items)->lookaheads, (*src_items)->lookaheads ); 
++dst items; 
++src items; 
return did_something; 
/*----------------------------------------------------------------------*/ 
PRIVATE int move_eps( cur_state, closure_items, nclose ) 
STATE 
ITEM *cur state; 
**closure items; 
{ 
/* Move the epsilon items from the closure items set to the kernel of the 
* current state. If epsilon items already exist in the current state, 
* just merge the lookaheads. Note that, because the closure items were 
* sorted to partition them, the epsilon productions in the closure items 
* set will be in the same order as those already in the kernel. Return 
* the number of items that were moved. 
*I 
ITEM **eps_items, **p 
int nitems, moved ; 
428 Bottom-Up Parsing-Chapter 5 
Listing 5.29. continued ... 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 
733 
734 
735 
736 
737 
738 
739 
740 
741 
742 
743 
744 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 
757 
758 
759 
760 
761 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
779 
780 
781 eps items 
nitems 
moved 
for( p 
{ cur_state->epsilon_items; 
cur state->neitems 
0; 
closure items; (*p)->prod->rhs_len 
if( ++moved > MAXEPSILON ) 0 && --nclose >= 0; ) 
error (FATAL, "Too many epsilon productions in state %d\n", 
cur state->num ) ; 
if( nitems 
UNION ( (*eps items++) ->lookaheads, (*p++) ->lookaheads ) ; 
else 
*eps_items++ = *p++ ; 
if( moved ) 
cur state->neitems moved 
return moved ; 
/*----------------------------------------------------------------------*/ 
PRIVATE int kclosure( kernel, closure items, max items, nclose ) 
STATE *kernel; /* Kernel state to close. *I 
ITEM 
int 
int **closure items; -/* Array into which closure items are put. *I 
maxitems; /* Size of the closure items[} array. *I 
nclose; /* # of items already in set. *I 
/* Adds to the closure set those items from the kernel that will shift to 
*new states (ie. the items with dots somewhere other than the far right). 
*I 
nitems; int 
ITEM *item, **itemp, *citem 
closure items += nclose; 
max items 
itemp 
nitems nclose; 
kernel->kernel items 
kernel->nkitems 
while( --nitems >= 0 
{ 
item = *itemp++; 
if( item->right_of_dot 
{ 
citem 
citem->prod 
citem->dot_posn 
citem->right_of_dot 
citem->lookaheads 
if( --maxitems < 0 /* Correct for existing items */ 
newitem( item->prod ); 
item->prod ; 
item->dot_posn ; 
item->right_of_dot 
dupset( item->lookaheads ); 
error( FATAL, "Too many closure items in state %d\n", 
kernel->num ) ; 
*closure items++ = citem; 
++nclose; 
Section 5.13 -Generating LALR( I) Parse Tables 429 
Listing 5.29. continued ... 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 
796 
797 
798 
799 
800 
801 
802 
803 
804 
805 
806 
807 808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 827 
828 
829 830 
831 
832 
833 
834 
835 
836 
837 
838 
839 
840 
841 return nclose; 
/*----------------------------------------------------------------------*/ 
PRIVATE int closure( kernel, closure_items, maxitems ) 
STATE *kernel; /* Kernel state to close. */ 
ITEM *closure items[]; /*Array into which closure items are put*/ 
int maxitems; /* Size of the closure_items[] array. */ 
{ 
/* Do LR(l) closure on the kernel items array in the input STATE. When 
* finished, closure_items[] will hold the new items. The logic is: 
* 
* (1) for( each kernel item 
* do LR(1) closure on that item. 
* (2) while( items were added in the previous step or are added below) 
* do LR(1) closure on the items that were added. 
*I 
int i 
int nclose 
int did_something 
ITEM **p 0 ; /* Number of closure items */ 
0 ; 
kernel->kernel items 
for( i = kernel->nkitems; --i >= 0 ;) 
{ /* (1) */ 
did_something I= do_close( *p++, closure items, &nclose, &maxitems ) ; 
while( did_something ) 
{ 
did_something = 0; 
p = closure_items; 
for( i = nclose ; --i >= 0 ; ) /* (2) */ 
did_something I= do_close( *p++, closure items, &nclose, &maxitems); 
return nclose; 
/*- - - - - - - - - - - - - - - */ 
PRIVATE int do_close( item, closure items, nitems, maxitems 
ITEM *item; 
ITEM *closure items[]; /* (output) Array of items added by closure process*/ 
int *nitems; /* (input) # of items currently in closure_items[] */ 
/* (output) # of items in closure items after */ 
/* processing */ 
int *maxitems; /* (input) max # of items that can be added */ 
/* (output) input adjusted for newly added items */ 
/*Workhorse function used by closure(). Performs LR(1) closure on the 
*input item ([A->b.Cd, e) add [C->x, FIRST(de)]). The new items are added 
* to the closure_items[] array and *nitems and *maxitems are modified to 
* reflect the number of items in the closure set. Return 1 if do_close() 
* did anything, 0 if no items were added (as will be the case if the dot 
* is at the far right of the production or the symbol to the right of the 
* dot is a terminal) . 
*I .... 
430 Bottom-Up Parsing-Chapter 5 
Listing 5.29. continued ... 
842 
843 
844 
845 
846 
847 
848 
849 
850 
851 
852 
853 
854 
855 
856 
857 
858 
859 
860 
861 
862 
863 
864 
865 
866 
867 
868 
869 
870 
871 
872 
873 
874 
875 
876 
877 
878 
879 
880 
881 
882 
883 
884 
885 
886 
887 
888 
889 
890 
891 
892 
893 
894 
895 
896 897 
898 
899 
900 int 
int 
PRODUCTION 
ITEM 
SET 
SYMBOL did_something = 0; 
rhs_is_nullable; 
*prod; 
*close_item; 
*closure_set; 
**symp; 
if( !item->right_of_dot 
return 0; 
if( !ISNONTERM( item->right_of_dot ) ) 
return 0; 
closure set= newset(); 
/* The symbol to the right of the dot is a nonterminal. Do the following: 
* * ( 1) for ( 
* (2) 
* * ( 3) 
* (4) 
* (5) 
* * (6) 
* 
*I every production attached to that nonterminal ) 
if( the current production is not already in the set of 
closure items) 
add it; 
if( the d in [A->b.Cd, e) doesn't exist ) 
add e to the lookaheads in the closure production. 
else 
The d in [A->b.Cd, e) does exist, compute FIRST(de) and add 
it to the lookaheads for the current item if necessary. 
/* (1) */ 
for( prod item->right_of_dot->productions; prod prod prod->next 
{ 
/* (2) */ 
if( ! (close item= in_closure items(prod, closure_items, *nitems))) 
{ 
if( --(*maxitems) <= 0 ) 
error(FATAL, "LR(l) Closure set too large\n" ); 
/* (3) */ 
closure_items[ (*nitems)++ ] =close item= newitem( prod); 
++did_something; 
if( !*(symp = & ( item->prod->rhs [ item->dot_posn + 1 ] )) ) 
{ /* (4) */ 
else 
{ did_something I= add_lookahead( close_item->lookaheads, /* (5) */ 
item->lookaheads ) ; 
truncate( closure_set ); /* (6) */ 
rhs is nullable first_rhs( closure set, symp, 
item->prod->rhs len-item->dot_posn- 1 ); 
REMOVE( closure set, EPSILON); 
if( rhs is_nullable ) 
UNION( closure set, item->lookaheads ); 
Section 5.13-Generating LALR(I) Parse Tables 431 
Listing 5.29. continued ... 
901 
902 
903 
904 
905 
906 
907 
908 
909 
910 
911 
912 
913 
914 
915 
916 
917 918 
919 
920 
921 
922 
923 
924 
925 
926 
927 
928 
929 
930 
931 
932 
933 
934 
935 
936 
937 
938 
939 
940 
941 
942 
943 did_something 1= add_lookahead(close_item->lookaheads, closure_set); 
1*-delset( closure_set ); 
return did_something; 
- - - - - *I 
PRIVATE ITEM *in closure_items(production, closure_item, nitems) 
ITEM **closure_item; 
PRODUCTION *production; 
{ 
1*-I* If the indicated production is in the closure items already, return a 
* pointer to the existing item, otherwise return NULL. 
*I 
for(; --nitems >= 0 ; ++closure_item ) 
if( (*closure item)->prod == production 
return *closure_item; 
return NULL; 
- - - - - - - - - - - - - - - - - - - - - - - - *I 
PRIVATE int add lookahead( dst, src 
SET *dst, *src; 
{ 
I* Merge the lookaheads in the src and dst sets. If the original src 
* set was empty, or if it was already a subset of the destination set, 
* return 0, otherwise return 1. 
*I 
if( !IS_EMPTY( src) && !subset( dst, src) ) 
{ 
UNION( dst, src ); 
return 1; 
return 0; 
Listing 5.30. yystate.c- Adding Reductions to Tables 
944 
945 
946 
947 948 
949 
950 
951 
952 
953 
954 PRIVATE void 
{ reductions () 
I* Do the reductions. If there's memory, sort the table by state number *I 
I* first so that yyout.doc will look nice. *I 
void addreductions(); 
Sort_by_number = 1; 
if( !ptab( States, addreductions, NULL, 1 ) 
ptab( States, addreductions, NULL, 0 ); I* below *I 
.... 
432 Bottom-Up Parsing-Chapter 5 
Listing 5.30. continued ... 
955 
956 
957 
958 
959 
960 
961 
962 
963 
964 
965 
966 
967 
968 
969 
970 
971 
972 
973 
974 
975 
976 
977 
978 
979 
980 
981 
982 
983 
984 
985 
986 
987 
988 
989 
990 
991 
992 
993 
994 
995 
996 
997 
998 
999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 /*-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void addreductions( state, junk 
STATE 
void *state; 
*junk; 
/* This routine is called for each state. It adds the reductions using the 
* disambiguating rules described in the text, and then prints the state to 
* yyout.doc if Verbose is true. I don't like the idea of doing two things 
* at once, but it makes for nicer output because the error messages will 
* be next to the state that caused the error. 
*I 
int 
ITEM i; 
**item_p; 
for( i state->nkitems, item_p = state->kernel_items; --i>=O; ++item_p 
reduce_one_item( state, *item_p ); 
for( i = state->neitems, item_p = state->epsilon_items; --i>=O; ++item_p 
reduce_one_item( state, *item_p ); 
if( Verbose 
{ 
pstate ( state ) ; 
if( state->num % 10 == 0 ) 
fprintf( stderr, "%d\r", state->num ); 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 
PRIVATE void reduce one item( state, item ) -ITEM *item; /* Reduce on this item *I 
STATE *state; /* from this state *I 
{ 
int token; 
int pprec; 
int tprec; 
int as soc; 
int reduce _by; 
int resolved; 
ACT *ap; 
if( item->right_of_dot 
return; /* Current look ahead *I 
/* Precedence of production *I 
/* Precedence of token *I 
/* Associativity of token *I 
/* True if conflict can be resolved *I 
/* No reduction required */ 
pprec = item->prod->prec /* precedence of entire production */ 
for( next_member(NULL); (token 
{ next_member(item->lookaheads)) >= 0 ;) 
tprec 
as soc Precedence[token] .level 
Precedence[token] .assoc /* precedence of lookahead */ 
/* symbol. */ 
if( ! (ap = p_action( state->num, token)) ) 
{ /* No conflicts */ 
add_action( state->num, token, -(item->prod_num) ); 
.... 
Section 5.13-Generating LALR(l) Parse Tables 
Listing 5.30. continued ... 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 
1028 
1029 
1030 
1031 
1032 
1033 
1034 
1035 
1036 
1037 1038 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 else if( ap->do_this <= 0 ) 
{ 
/* Resolve a reduce/reduce conflict in favor of the production */ 
/* with the smaller number. Print a warning. *I 
else 
{ ++Reduce_reduce; 
reduce_by 
ap->do_this min( -(ap->do_this), item->prod_num ); 
-reduce_by ; 
error( WARNING, "State %2d: reduce/reduce conflict " 
"%d/%d on %s (choose %d) .\n", 
state->num, 
-(ap->do_this), item->prod_num, 
token? Terms[token]->name: "< EOI 
reduce_by 
/* Shift/reduce conflict. */ 
if( resolved = (pprec && tprec) 
if( tprec < pprec II (pprec tprec && assoc != 'r') 
ap->do_this = -( item->prod_num ); 
if( Verbose > 1 I I !resolved 
{ 
++Shift_reduce; >" 
error( WARNING, "State %2d: shift/reduce conflict %s/%d" 
" (choose %s) %s\n", 
state->num, 
Terms[token]->name, 
item->prod_num, 
ap->do_this < 0 
resolved 
) ; ? "reduce" 
? "(resolved)" "shift", I 
) ; 
Listing 5.31. yystate.c- Statistics Functions 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 
1062 
1063 
1064 
1065 
1066 
1067 
1068 PUBLIC void lr_stats( fp) 
FILE *fp; 
{ 
/* Print out various statistics about the table-making process */ 
fprintf(fp, 
fprintf (fp, 
fprintf(fp, 
fprintf(fp, "%4d LALR(l) states\n", 
"%4d items\n", 
"%4d nonerror transitions 
"%4d/%-4d unfinished items\n", Nstates ); 
Nitems ); 
in tables\n", Ntab_entries ); 
Next_allocate -Heap, 
MAX_UNFINISHED); 
fprintf(fp, "%4d bytes required for LALR(l) transition matrix\n", 
) ; 
fprintf(fp, "\n"); (2 * sizeof(char*) * Nstates) /* index arrays */ 
+ Nstates /* count fields */ 
+ (Npairs * sizeof(short)) /*pairs */ 433 
.... 
434 Bottom-Up Parsing-Chapter 5 
Listing 5.31. continued ... 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 1080 
1081 
1082 
1083 /*----------------------------------------------------------------------*/ 
PUBLIC int lr_conflicts( fp) 
FILE *fp; 
{ 
/* Print out statistics for the inadequate states and return the number of 
* conflicts. 
*I 
fprintf(fp, "%4d shift/reduce conflicts\n", Shift reduce ); 
fprintf(fp, "%4d reduce/reduce conflicts\n", Reduce reduce); 
return Shift reduce + Reduce reduce 
Listing 5.32. yystate.c- Print Functions 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 #define MAX TOK PER LINE 10 
PRIVATE int Tokens_printed; /* Controls number of lookaheads printed */ 
/* on a single line of yyout.doc. */ 
PRIVATE void sprint_tok( bp, format, arg ) 
char 
char **bp; 
*format; /*not used here, but supplied by pset() */ 
int arg; 
/* Print one nonterminal symbol to a buffer maintained by the 
* calling routine and update the calling routine's pointer. 
*I 
if ( arg -1 *bp += sprintf( 
else if( arg -2 *bp += sprintf( 
else if( arg EOI *bp += sprintf( 
else if( arg EPSILON) *bp += sprintf( 
else *bp += sprintf( 
if( ++Tokens_printed >= MAX TOK PER LINE 
{ 
*bp += sprintf(*bp, "\n\t\t"); 
Tokens_printed = 0; 
PRIVATE char *stritem( item, lookaheads ) 
ITEM 
int *item; 
lookaheads; *bp, "null " 
*bp, "empty " 
*bp, "$ " 
*bp, 
*bp, "%s " Terms[arg]->name I ) ; 
) ; 
) ; 
) ; 
) ; 
/* Return a pointer to a string that holds a representation of an item. 
* lookaheads are printed too if "lookaheads" is true or Verbose is > 1 
* (-V was specified on the command line). 
*I 
static char buf[ MAXOBUF * 2 ]; 
char *bp; 
int i; The 
.... 
Section 5.13 -Generating LALR(l) Parse Tables 
Listing 5.32. continued ... 
1122 
1123 
1124 
1125 
1126 
1127 
1128 
1129 
1130 
1131 
1132 
1133 
1134 
1135 
1136 
1137 1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150 
1151 
1152 
1153 
1154 
1155 
1156 
1157 
1158 
1159 
1160 
1161 
1162 
1163 
1164 
1165 
1166 
1167 
1168 
1169 
1170 
1171 
1172 
1173 
1174 
1175 
1176 
1177 
1178 
1179 
1180 bp buf; 
bp += sprintf( bp, "%s->", item->prod->lhs->name ); 
if( item->prod->rhs_len <= 0 ) 
bp += sprintf( bp, "<epsilon>. " ); 
else 
{ 
for( i = 0; i < item->prod->rhs_len ++i 
{ 
if( i == item->dot_posn 
*bp++ = I • I ; 
bp += sprintf(bp, "%s", item->prod->rhs[i]->name ); 
if( i == item->dot_posn 
*bp++ I I 
if( lookaheads I I Verbose >1 ) 
{ 
bp += sprintf( bp, " (production %d, precedence %d)\n\t\t[", 
item->prod->num, item->prod->prec ) ; 
Tokens_printed = 0; 
pset( item->lookaheads, sprint_tok, &bp); 
*bp++ = ']' 
if( bp -buf >= (MAXOBUF * 2) ) 
error(FATAL, "Internal [stritem], buffer overflow\n" ); 
*bp='\0'; 
return buf; 
/*----------------------------------------------------------------------*/ 
PRIVATE void pstate( state ) 
STATE 
{ *state; 
/* Print one row of the parse table in human-readable form yyout.doc 
* (stderr if -v is specified) . 
*I 
int 
ITEM 
ACT i; 
**item; 
*p; 
document( "State %d:\n", state->num ); 
/* - - - - - - - - - - - - - - - - - - - - - - -*/ 
/* Print the kernel and epsilon items for the current state. */ 
for( i=state->nkitems, item=state->kernel_items ; --i >= 0 ; ++item 
document(" %s\n", stritem (*item, (*item) ->right_of_dot==O ) ) ; 
for( i=state->neitems, item=state->epsilon_items ; --i >= 0 ; ++item 
document( " %s\n", stritem(*item, 1) ) ; 435 
436 Bottom-Up Parsing-Chapter 5 
Listing 5.32. continued ... 
1181 
ll82 
1183 
ll84 
1185 
ll86 
ll87 
1188 
1189 
1190 
ll91 
ll92 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 
1201 
1202 
1203 
1204 
1205 
1206 
1207 
1208 1209 
1210 
1211 
1212 
1213 
1214 
1215 
1216 
1217 
1218 
1219 
1220 
1221 
1222 
1223 
1224 
1225 
1226 
1227 
1228 
1229 
1230 
1231 
1232 
1233 
1234 
1235 
1236 1237 
1238 document ( "\n" ) ; 
/* - - - - - - - - - - - - - - - - - - - - - - -*/ 
/* Print out the next-state transitions, first the actions, */ 
/* then the gatos. *I 
for( i = 0; i < MINTERM + USED_TERMS; ++i 
{ 
if( p = p_action( state->num, i ) 
{ 
if( p->do_this 0 ) 
{ 
if( p->sym EOI 
document( " Accept on end of input\n" ); 
else 
error( FATAL, "INTERNAL: state %d, Illegal accept", 
state->num) ; 
else if( p->do_this < 0 ) 
document( " Reduce by %don %s\n", -(p->do_this), 
else 
document( " Terms[p->sym]->name ); 
Shift to %d on %s\n", p->do_this, 
Terms[p->sym]->name ); 
for( i = MINNONTERM; i < MINNONTERM + USED_NONTERMS; i++ ) 
if( p = p goto(state->num, i) ) 
document( " Goto %don %s\n", p->do_this, 
Terms[i]->name ); 
document("\n"); 
PRIVATE void pstate_stdout( state) 
STATE 
{ *state; 
document_to( stdout ); 
pstate( state); 
document_to( NULL); 
/*----------------------------------------------------------------------*/ 
PRIVATE pclosure( kernel, closure_items, nitems ) 
STATE *kernel; 
ITEM **closure_items; 
{ 
printf( "\n%d items in Closure of", nitems ); 
pstate_stdout( kernel ); 
if( nitems > 0 
{ 
printf(" -----closure items:----\n" ); 
while( --nitems >= 0 ) 
printf( " %s\n", stritem( *closure_items++, 0) ); 
Section 5.13-Generating LALR(l) Parse Tables 437 
Listing 5.33. yystate.c- Routines That Create Auxiliary Tables 
1239 
1240 
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 
1252 
1253 
1254 
1255 
1256 
1257 
1258 
1259 
1260 
1261 
1262 
1263 
1264 
1265 
1266 
1267 1268 
1269 
1270 
1271 
1272 
1273 
1274 
1275 
1276 
1277 
1278 
1279 
1280 
1281 
1282 
1283 
1284 
1285 
1286 
1287 
1288 
1289 
1290 
1291 
1292 
1293 
1294 
1295 
1296 
1297 PRIVATE void 
PRODUCTION make_yy_lhs( prodtab) 
**prodtab; 
{ 
static char *text[] = 
{ 
"The Yy_lhs array is used for reductions. It is indexed by production", 
"number and holds the associated left-hand side adjusted so that the", 
"number can be used as an index into Yy_goto.", 
NULL 
} ; 
PRODUCTION *prod; 
int i; 
Output, text ); comment 
output "YYPRIVATE int Yy_lhs[%d] =\n{\n", Num_productions ); 
for( i 
{ 0; i < Num_productions; ++i ) 
prod = *prodtab++; 
output("\t/* %3d */\t%d", prod->num, ADJ_VAL( prod->lhs->val ) ); 
if( i != Num_productions-1 
output(","); 
if( i % 3 == 2 I I i 
output( "\n" ); 
output("};\n"); Num_productions-1 /* use three columns */ 
/*----------------------------------------------------------------------*/ 
PRIVATE void 
PRODUCTION make_yy_reduce( prodtab ) 
**prodtab; 
{ 
static char *text[] = 
"The Yy_reduce[] array is indexed by production number and holds", 
"the number of symbols on the right-hand side of the production", 
NULL 
} ; 
PRODUCTION *prod; 
int i; 
Output, text ); comment 
output "YYPRIVATE int Yy_reduce[%d] =\n{\n", Num_productions ); 
for( i 
{ 0; i < Num_productions; ++i ) 
prod = *prodtab++; 
output( "\t/* %3d */\t%d", prod->num, prod->rhs_len ); 
if( i != Num_productions-1 
output(","); 
if( i % 3 == 2 I I i 
output ( "\n" ) ; 
output("}; \n"); Num_productions-1 /* use three columns */ 
438 Bottom-Up Parsing-Chapter 5 
Listing 5.33. continued ... 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 
1306 
1307 
1308 
1309 
1310 
1311 
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 !*----------------------------------------------------------------------*/ 
PRIVATE make_yy_slhs( prodtab 
PRODUCTION **prodtab; 
{ 
static char *text[] 
{ 
) ; "Yy_slhs[] is a debugging version of Yy_lhs[]. It is indexed by", 
"production number and evaluates to a string representing the", 
"left-hand side of the production.", 
NULL 
PRODUCTION *prod; 
int 
comment 
output 
for( i 
{ i; 
Output, text); 
"YYPRIVATE char *Yy_slhs[%d] =\n{\n", Num_productions ); 
Num_productions; ~-i >= 0 ; ) 
prod = *prodtab++; 
output("\t/* %3d */\t\"%s\"", prod->num, prod->lhs->name ); 
output( i != 0? ",\n" : "\n" ); 
output(");\n"); 
PRIVATE make_yy_srhs( prodtab 
PRODUCTION **prodtab; 
{ 
static char *text[] = 
{ 
"Yy_srhs[] is also used for debugging. It is indexed by production", 
"number and evaluates to a string representing the right-hand side of", 
"the production.", 
NULL 
) ; 
PRODUCTION *prod; 
int 
comment 
output 
for( i 
{ i 1 j; 
Output, text ) ; 
"YYPRIVATE char *Yy_srhs[%d] =\n{\n", Num_productions ) ; 
Num_productions; --i >= 0 ; ) 
prod = *prodtab++; 
output("\t/* %3d */\t\"", prod->num ); 
for( j = 0; j < prod->rhs_len ; ++j ) 
{ 
output( "%s", prod->rhs[j]->name ); 
if( j != prod->rhs_len -1 ) 
outc( ' ' ); 
.... 
Section 5.13-Generating LALR(l) Parse Tables 439 
Listing 5.33. continued ••• 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 1393 
1394 1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 output( i != 0? "\",\n" "\"\n" ); 
output("};\n"); 
1*----------------------------------------------------------------------
* The following routines generate compressed parse tables. There's currently 
* no way to do uncompressed tables. The default transition is the error 
* transition. 
*I 
PRIVATE void 
{ print_reductions() 
I* Output the various tables needed to do reductions *I 
PRODUCTION **prodtab; 
if(! (prodtab= (PRODUCTION**) malloc(sizeof(PRODUCTION*) * Num_productions))) 
error(FATAL,"Not enough memory to output LALR(l) reduction tables\n"); 
else 
ptab( Symtab, mkprod, prodtab, 0 ); 
make_yy_lhs 
make_yy_reduce prodtab ) ; 
prodtab ) ; 
output("#ifdef YYDEBUG\n"); 
make_yy_slhs 
make_yy_srhs prodtab ) ; 
prodtab ) ; 
output("#endif\n"); 
free( prodtab ); 
1*----------------------------------------------------------------------*l 
PRIVATE void 
SYMBOL 
PRODUCTION mkprod( sym, prodtab ) 
*sym; 
**prodtab; 
{ 
PRODUCTION *p; 
if( ISNONTERM(sym) 
for( p = sym->productions 
prodtab[ p->num ] = p p p p->next ) 
l*----------------------------------------------------------------------*1 
PRIVATE void print_tab( table, row_name, col_name, make_private 
ACT **table; 
char 
char 
int *row_name; 
*col_name; 
make_private; I* Name to use for the row arrays *I 
I* Name to use for the row-pointers array *I 
I* Make index table private (rows always private) *I 
I* Output the action .or goto table. *I 
int 
ACT 
ACT i, j; 
*ele, **elep; I* table element and pointer to same 
*e, **p; *I 
440 Bottom-Up Parsing-Chapter 5 
Listing 5.33. continued ... 
1417 
1418 
1419 
1420 
1421 
1422 1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 1468 
1469 
1470 
1471 
1472 1473 
1474 
1475 int 
int 
SET count; 
column; 
*redundant /* # of transitions from this state, always >0 */ 
newset(); /* Mark redundant rows */ 
static char *act_text[] = 
{ 
} ; "The Yy_action table is action part of the LALR(l) transition", 
"matrix. It's compressed and can be accessed using the yy_next () ", 
"subroutine, declared below.", 
" ' 
" ' 
" ' YyaOOO[]={ 3, 5,3 
state number---+ I I I ", 
number of pairs in list-+ I I", 
input symbol (terminal)------+ 1", 
action-------------------------+", 2,2 1' 1 } ·" ' ' 
action= yy_next( Yy_action, cur state, lookahead_symbo1 ) ;", 
action < 0 
action 0 
action > 0 
action YYF Reduce by production n, n == -action.", 
Accept. (ie. Reduce by production 0.) ", 
Shift to state n, n == action.", 
error.", 
NULL 
static char *goto_text[] = 
{ 
"The Yy_goto table is goto part of the LALR(1) transition matrix", 
"It's compressed and can be accessed using the yy_next () subroutine,", 
"declared below." 
"" ' "nonterminal = Yy_lhs[ production number by which we just reduced]", .... 
' YygOOO[]={ 3, 5,3 
uncovered state-+ I I I ", 
number of pairs in list--+ I I", 
nonterminal-------------------+ 1", 
goto this state-----------------+", 2,2 1' 1 } . " ' ' 
goto_state 
NULL yy_next( Yy_goto, cur_state, nonterminal );", 
} ; 
comment( Output, table== Actions ? act text goto_text ); 
/* - - - - - - - - - - - - - - - - - - -
* Modify the matrix so that, if a duplicate rows exists, only one 
* copy of it is kept around. The extra rows are marked as such by setting 
* a bit in the "redundant" set. (The memory used for the chains is just 
* discarded.) The redundant table element is made to point at the row 
* that it duplicates. 
*I 
for( e1ep = table, i = 0; i < Nstates 
{ 
if( MEMBER( redundant,i ) ) 
continue; 
for( p=elep+1, j=i 
{ ++j < Nstates ++elep, ++i 
++p ) 
.... 
Section 5.13-Generating LALR(1) Parse Tables 441 
Listing 5.33. continued ••• 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 if( MEMBER( redundant, j) ) 
continue; 
ele 
e *elep; 
*p; I* pointer to template chain 
I* chain to compare against template *I 
*I 
if( !e II !ele 
continue; I* either or both strings have no elements *I 
for( ; ele && e ; ele=ele->next, e=e->next ) 
if( (ele->do_this != e->do_this) II (ele->sym != e->sym) ) 
break; 
if( !e && !ele 
{ 
I* Then the chains are the same. Mark the chain being compared 
* as redundant, and modify table[j] to hold a pointer to the 
* template pointer. 
*I 
ADD( redundant, j ); 
table[j] = (ACT*) elep; 
I* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* Output the row arrays 
*I 
for( elep = table, i = 0 ; i < Nstates 
{ 
if( !*elep II MEMBER(redundant, i) 
continue; ++elep, ++i ) 
I* Count the number of transitions from this state *I 
count = 0; 
for( ele = *elep 
++count; ele '; ele = ele->next ) 
output("YYPRIVATE YY TTYPE %s%03d[]={%2d,",row_name, elep-table, count); 
I*J*I 
column = 0; 
for( ele = *elep 
{ 
++Npairs; ele ele ele->next ) 
output( "%3d,%-4d", ele->sym, ele->do this ) ; 
if( ++column != count 
outc ( ',' ) ; 
if( column % 5 == 0 
output("\n\t\t\t 
output( ");\n" ); ") ; 
I* f *I 
.... 
442 Bottom-Up Parsing-Chapter 5 
Listing 5.33. continued ••• 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 
1553 
1554 
1555 
1556 
1557 
1558 
1559 
1560 
1561 I* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
* Output the index array 
*I 
if( make_private ) 
output( "\nYYPRIVATE YY_TTYPE *%s[%d] =\n", col_name, Nstates ); 
else 
output( "\nYY_TTYPE *%s[%d] =\n", col_name, Nstates ) ; 
output ( " { \nl* 0 *I II ) ; 
for( elep = table, i = 0 ; i < Nstates 
{ 
if( MEMBER(redundant, i) ++i, ++elep ) 
output ( "%s%03d", row_name, (ACT **) (*elep) -table ) ; 
else 
output ( *elep ? "%s%03d" NULL" , row_name, i ) ; 
if( i != Nstates-1 ) 
output ( ", " ) ; 
if( i==O II (i % 8)==0 
output("\nl* %3d *I ", i+l ) ; 
delset( redundant ); I* Mark redundant rows *I 
output( "\n);\n"); 
5.14 Exercises I* } *I 
I* { *I 
5.1. (a) Write an algorithm that creates a physical syntax tree from a postfix represen­
tation of an arithmetic expression. For example, the input ab* cd * + should create 
the following tree: 
(b) Implement your algorithm. 
5.2. (a) Write an augmented, attributed grammar for a bottom-up parser that builds the 
syntax tree required for the previous exercise. 
(b) Rewrite your grammar to support infix expressions as input rather than 
postfix. Parenthesized subexpressions must be supported. 
(c) Implement both of the previous grammars using occs. 
5.3. Using the LR parse table in Table 5.11 on page 369, show the contents of the 
state and symbol stacks as the following input is processed: 
Section 5.14-Exercises 
1+(2*3)*4 
5.4. Create bottom-up, LALR( 1) parse tables for the following grammar: 
1. stmt 
2. 
3. 
4. stmt list 
5. 
6. expr 
7. 
8. 
9. 
10. term 
11. ~ exprSEMI 
I WHILE LP expr RP stmt 
LC stmt list RC 
~ stmt list stmt 
I E 
~ expr PLUS term 
I STAR expr 
term 
E 
~ IDENTIFIER 
I LPexprRP 
This grammar produces one shift/reduce conflict, which should be resolved 
according to the following table: 
Input Token Precedence Associativity symbol 
() LP RP high none 
* STAR medium right to left 
+ PLUS low left to right 
I I LC RC none left to right 
' SEMI none none 
Hand in the tables and graphs showing both the LR and LALR state machines. 
5.5. Modify the grammar in the previous exercise to include an assignment operator 
(x=y;) and an exponentiation operator (x--y) is x to the yth power. Assignment 
should be the lowest precedence operator and exponentiation the highest. Make 
LALR( 1) parse tables for this modified grammar. 
5.6. Implement a parser that uses the parse tables created in Exercises 5.4 or 5.3. 
5.7. Add code-generation actions to the grammar created in Exercises 5.4 or 5.3. You 
may output either assembly language or C. 
5.8. Add the code-generation actions from the previous exercise to the parser imple­
mentation created in Exercise 5.5. 
5.9. Why are fewer shift/reduce conflicts generated when imbedded actions are 
inserted into a production immediately to the right of terminal symbols? 
5.10. Think up a real-world situation where a reduce/reduce conflict is inevitable (other 
than the one presented earlier). 
5.11. A more-efficient method for creating LALR(l) parse tables than the one 
presented in the current chapter is described in [Aho], pp. 240-244. An LR(O) 
state machine is created and then lookaheads are added to it directly. You can 
see the basis of the method by looking at Figure 5.8 on page 366. Lookaheads 
appear on the tree in one of two ways, either they propagate down the tree from a 
parent to a child or they appear spontaneously. A lookahead character pro­
pagates from the item [!s~a.x~,c] to its child when FIRST(~) is nullable. It 
appears spontaneously when FIRST( !b) contains only terminal symbols. Modify 
occs to use this method rather than the one presented in the current chapter. Is 
the method in [Aho] actually more efficient once implementation details are con­
sidered? Why or why not? 443 
444 Bottom-Up Parsing-Chapter 5 
5.12. An even more efficient method for creating LALR( I) parse tables, developed by 
DeRemer and Pennello, is described in [DeRemer79] and [DeRemer82]. It is 
summarized in [Tremblay], pp. 375-383. Modify occs to use this table-creation 
method. 
5.13. LLama and occs currently supports optional and repeating productions, indi­
cated with brackets: 
s a [optional] b 
c [repeating zero or more times]* d 
These are implemented in the start_opt () and end_ opt() subroutine 
presented in Chapter 4 and the transformations involved are discussed in Appen­
dix E. Occs uses left-recursive lists and LLama uses a right-recursive lists for 
these transformations. 
(a) Add a + operator to occs and LLama that can be used in place of the star in a 
repeating production. It causes the enclosed sub-production to repeat one or 
more times. 
(b) Add the operator [ ... ] (a, b)* for a to b repetitions of the sub­
production-a and bare decimal numbers. 
(c) Add the [ ... J *> and [ ... J +> operators to occs. These should work just 
like [ ... ] * and [ ... ] +, but should use right-recursive rather than left­
recursive list productions. 
6 
Code Generation 
Having looked at how parsers are created, it's now time to look at the real heart of 
the compiler: the code generation phase. We've actually been looking at code genera­
tion in a backhanded way. LEX, LLama, and occs are all compilers, after all, and they 
do generate code of sorts-the tables and drivers. This chapter looks at more conven­
tional code generation and at the run-time environment by building a C compiler. I'm 
assuming that you can generalize from a description of a specific implementation once 
you understand the design issues. The grammar used here is summarized in Appendix C 
and is discussed piecemeal in the current chapter as it's used. 
Because a production-quality, full ANSI compiler would both take up too much space 
and actually obscure some code-generation issues, I've implemented a proper subset of 
ANSI C. Most of the hard stuff is implemented, but I've omitted some functionality that 
you can add on your own if you're interested. 1 The modifications are left as exercises at 
the end of the chapter. Note that these limitations exist only at the semantic level. The 
grammar recognizes ANSI C, but the compiler ignores a few ANSI constructs when they 
are encountered. The compiler has the following limitations: 
• Floating point is not supported. 
• The auto, const, volatile, and register keywords are ignored. 
• Structures do not form !values. You can't pass or return them by value or assign to a 
structure. 
• Compile-time initializations work only on nonaggregate global variables like this: 
intx=5; 
Arrays, structures, and local variables of any sort may not be initialized at compile 
time. 
• Strong type checking on enumerated types is not supported. An enumerated type is 
treated just like an int, and any integer value can be assigned to a variable of that 
type, even if the value was declared as part of a different enumerated type. The 
I. Adding some of the missing stuff, like structure !values, floating point, and proper initializations, is a 
nontrivial enterprise. Other omissions, like bit fields, are easy. 
445 ANSI-C subset implement­
ed. 
446 
The virtual machine. Code Generation -Chapter 6 
elements of the enumeration list are treated just like a macro would be treated, it is 
just replaced by a int constant wherever it's found. The following declaration: 
anum tag { Beaver, Wally, June, Ward; } Cleaver; 
is treated like this: 
#define Beaver 0 
#define Wally 1 
#define June 2 
#define Ward 3 
int Cleaver; 
• Bit fields are ignored. The associated structure field is treated as if the bit field 
wasn't present in the input. 
• Function prototypes are treated as simple extern declarations. The argument or 
type list is ignored._ The new C++-style function-definition syntax is supported, how­
ever. 
• One nonstandard escape sequence is supported in character constants: \A C 
(backslash-caret-letter) evaluates to the associated control character. It cannot be 
used in a string constant. 
A simple, one-pass compiler is developed in this chapter: the compiler generates 
assembly language directly rather than creating a true intermediate language that is pro­
cessed by a back end. I've taken this approach because it represents something of a 
worst-case scenario, and so makes a better example. The chapter starts out discussing 
the run-time environment and how a typical machine is used by the generated code. 
Intermediate languages are discussed briefly, and an output assembly language with a 
C-like syntax is developed. Internal data structures such as the symbol table are dis­
cussed, and then the compiler is developed. 
One failing of the current chapter is that the recursive nature of the grammar pre­
cludes a strictly hierarchical discussion of the code-generation actions. As a conse­
quence, there's a certain amount of skipping around in the grammar in the later sections. 
I've tried to minimize this as much as possible, but you may have to read the chapter 
more than once before the overall structure of the compiler becomes apparent. The 
entire grammar is listed hierarchically in Appendix C, and it will be worthwhile for you 
to study the grammar thoroughly before proceeding to the discussion of the code­
generation issues. 
As a final disclaimer, compilers are complicated programs and are notoriously 
difficult to debug. I don't expect the current compiler to be any different in this respect. 
The compiler has been tested as well as I am able, but there's nothing like having several 
thousand people reading your code to show up bugs that you never dreamed existed. 
The electronically distributed version will always be the most up-to-date, and bug fixes 
will be posted to USENET on a regular basis. Please notify me when you find a bug so I 
can tell everyone else about it (either c/o Software Engineering, or electronically; the 
addresses are in the Preface). 
You must be thoroughly familiar with the bottom-up parse process described in the 
last chapter before continuing. 
6.1 Intermediate Languages 
Compilers often generate intermediate languages rather than translate an input file 
directly to binary. You can look at an intermediate language as a model assembly 
language, optimized for a nonexistent, but ideal, computer called a virtual machine. The 
Section 6.1 -Intermediate Languages 
compiler's output can be tested by simulating this virtual machine with a computer pro­
gram. There are several advantages to an intermediate-language approach. First, you 
can design an intermediate language with ease of optimization in mind, and thereby 
improve the resultant binary image because it can be more heavily optimized. Next, the 
intermediate-to-binary translation is usually done by a separate compilation pass called a 
back end, and you can provide several back ends for different target machines, all of 
which use the same parser and code generator (called the front end). By the same token, 
you can provide several front ends for different languages, all of which generate the 
same intermediate language and all of which share the same back end to generate real 
code.2 
Virtual machines typically have many registers, very orthogonal instruction sets (all 
instructions can be performed on all registers, the syntax for register operations is the 
same as the memory-access syntax), and so forth. There are trade-offs, though. The 
ideal machine hardly ever maps to a real machine in an efficient way, so the generated 
code is typically larger and less efficient than it would be if the parser knew about the 
actual target machine. The ability to mix and match front and back ends compensates to 
some extent for the inefficiencies. 
Intermediate languages typically take one of three forms. These are triples, quads 
(short for quadruples), and postfix (reverse-Polish) notation. 
Most real assembly languages are made up of triples which are made of of three 
parts: an operator, a source, and a destination or target. For example, the 68000 
instruction ADD. w DO, D 1 is a triple that adds the contents of the DO and D 1 registers 
and puts the result in D 1. A C representation of a similar triple would be: 
d += s; 
and a typical mathematical representation is: 
(+=, d, s) 
Triples are sometimes called triplets or 3-tuples. They are also sometimes called two­
address instructions because the binary representation of most instructions comprise an 
operator and source and destination addresses. 
Quads, also called quadruples or three-address instructions, have four parts. The fol­
lowing quad has two sources, an operand, and a destination: 
d = sl + s2; 
A more mathematical representation of the same quad would be: 
(+, d, sl, s2) 
Note that, in spite of the name, some quads, such as an assignment quad, have only 
three parts, with an empty fourth field. This empty element is usually marked with a 
dash: 
(=, d, s, -) 
The first field defines the operation. Since it's never empty, a dash there signifies sub­
traction. 
Not all quads and triples involve implicit assignments. The first of the following tri­
ples compares two numbers and remembers the result of the comparison internally. The 
2. For example, the Microsoft Pascal, FORTRAN, and C compilers all share the same back end. Back ends and front 
ends. 447 
Virtual machine charac­
teristics. 
Triples (two-address in­
structions). 
Quads (three-address in­
structions). 
Quads and triples without 
explicit assignments. 
448 
Advantages of quads 
versus triples. 
Postfix, Reverse-Polish 
Notation (RPN). Code Generation -Chapter 6 
second triple, which branches to a specific label, is executed only if the previous com­
parison was true. Neither instruction involves an assignment. 
(LESS_THAN, a, b) 
(GOTO, target, -) 
Arithmetic operations may not involve assignment either. The following two triples exe­
cute A=B+C. The first one does the addition and stores the result in an internal register 
called the accumulator. The second assigns the result of the previous operation-the 
.-1-toA. 
(+, B, C ) 
(=, A, .-1) 
The dot represents the position of the current instruction: . -1 references the previous 
instruction, .-2 the instruction before that, and so on. 
Triples have one advantage over quads: they're very close in structure to many real 
assembly languages, so they can ease code generation for these assemblers. I'm using 
them in the compiler generated in this chapter for this reason. Quads have two advan­
tages over triplets. They tend to be more compact; a quad like (+, d, s1, s2) 
requires two triplets to do the same work: 
(= d, s1 ) ; 
(+= d, s2 ) ; 
Also, certain optimizations are easier to do on quads because triples are more position 
dependent. In the previous example, the two triples must be treated as a single unit by 
any optimizations that move the code around, and the ordering of the two triples is 
important. Since it's self-contained, the quad can be moved more easily. 
The third kind of common intermediate language is postfix or Reverse-Polish Nota­
tion (RPN.) Forth, PostScript, and Hewlett-Packard calculators are examples of postfix 
languages. This representation has several advantages. The first is that expressions can 
be evaluated with less work than usual: no parentheses are needed to represent them, 
and the compiler doesn't need to allocate temporary variables to evaluate postfix 
expressions-it uses a run-time stack instead. All operands are pushed onto the stack 
and all operators affect the top few stack elements. For example, an expression like this: 
(1+2) * (3+4) 
is represented in postfix as follows: 
1 2 + 3 4 + * 
and is evaluated as shown in Table 6.1. 
Postfix languages often have various operators designed specifically for stack opera­
tions, such as a dup operator that duplicates and pushes the top of stack element-X 2 can 
be represented with: 
X dup * 
Another common stack operator is the swap operator, which swaps the two elements at 
the top of stack. 
RPN has one other advantage: It's easy to reconstruct the original syntax tree from a 
postfix representation of the input language. (We'll look at this process further in 
Chapter Seven.) Since some optimizations require the production of a syntax tree, a 
postfix intermediate language is a convenient way to transfer a compiled program to the 
optimizer. 
Section 6.1 -Intermediate Languages 
Table 6.1. Postfix Evaluation of 1 2 + 3 4 + * 
stack input comments 
empty 1 2 + 3 4 + * push 1 
1 2 + 3 4 + * push2 
1 2 + 3 4 + * add the two items at top of stack and replace them 
with the result. 
3 3 4 + * push] 
3 3 4 + * push4 
3 3 4 + * add the two items at top of stack and replace them 
with the result. 
3 7 * multiply the two items at top of stack and replace 
them with the result. 
21 the result is at top of stack. 
6.2 C-code: An Intermediate Language and Virtual Machine 3 
The syntax of an intermediate language is pretty much arbitrary. Ideally it reflects 
the characteristics of the most likely target machines. For purposes of clarity, however, 
I've decided to use a C-like intermediate language in the compiler created later in this 
chapter. I've defined a C subset in which all instructions have direct analogs in most 
assembly languages-all the instructions translate directly into a small number of 
machine instructions (usually one). This way, the assembly-language syntax will be 
familiar to you, regardless of your background. In addition, you can use your C compiler 
and normal debugging tools to exercise the output from the compiler. The code is simple 
enough so that a translation to assembly language is very straightforward. I've dubbed 
this intermediate language C-code. 
C-code is really more of an assembly language than a true intermediate language. 
The main problem is that it is very restrictive about things like word width, alignment, 
and storage classes. It forces the compiler itself to worry about details that are usually 
handled by the back end and, as a consequence, makes a back end harder to write 
because the back end must occasionally undo some of the things that the compiler has 
done (like add padding to local variables to get proper alignment). 
The current section describes C-code in considerable depth. Though the description 
is, by necessity, full of specific implementation details, reading it should give you a good 
idea of the sorts of things that are required in a more general-purpose intermediate 
language. The current section also serves as a review of assembly-language concepts. 
The C-code description is pretty terse in places, and a previous familiarity with a real 
assembly language will help considerably in the following discussion. Finally, I've also 
used the current section as a vehicle for discussing the memory organization and 
subroutine-linkage procedures that are almost universal among C compilers, so you 
should read through it even if you're very familiar with assembler. 
The C-code virtual machine-the hypothetical machine that would run C-code as its 
assembly language-is modeled by a series of macros in a file called <tools!virtual.h>, 
3. For convenience, all the C-code directives described in this section are also summarized in Appendix F. 449 
<tools/virtual. h> 
450 
White space. 
Identifiers. 
byte, word, lword, ptr, ar­
ray, record. 
<toolslc-code.h> Code Generation -Chapter 6 
which should be #included at the top of every C-code file. This file contains 
definitions that allow you to compile and run the generated C-code, using your normal C 
compiler as an assembler. Virtual.h is described piecemeal as the various C-code 
language elements are discussed. Unfortunately, the code in virtual.h is not particularly 
portable. I've made all sorts of assumptions about the sizes of various data types, the 
ordering of bytes within a word, and so forth. You can compensate for these system­
dependent problems by modifying the include file, however. 
A typical development cycle looks like this: 
vi file.c 
c file.c Edit the C source-code file. 
Run the source code through the compiler developed in the 
current chapter. The compiler generates a C-code output file 
called output.c. 
cc output. c "Assemble" the compiler's output, using your normal compiler 
as an assembler. You can debug the compiler's output using 
dbx, CodeView, or whatever debugger you normally use. 
Table 6.2 shows how a C input file is translated into C-code by the compiler in the 
current chapter. The rightmost column demonstrates how the C-code relates to 8086 
assembler. Table 6.2 is intended to demonstrate what's happening in a general way. 
Don't worry about the details-1'11 discuss what's going on in great detail as the chapter 
progresses. For now, notice how similar the C-code is to the true assembly language. 
It's easy to translate from one to another. C-code is really an assembly language, regard­
less of the superficial similarities to C. 
6.2.1 Names and White Space 
As in C, white space is ignored in C-code except as needed to separate tokens. Com­
ments delimited with I* ... *I are treated as white space. Multiple-line comments are 
not permitted-the I* and *I must be on the same line. 
Identifiers can be made up of letters, digits, and underscores only. The first character 
in the name may not be a digit, and names are restricted to 31 characters. Names are 
truncated if they're longer. In addition to the standard C keywords, all of the C-code 
directives discussed below should be treated as keywords and may not be used for 
identi tiers. 
6.2.2 Basic Types 
The primary design considerations in the virtual machine are controlled by the sizes 
of the variables that are manipulated by the machine. Four basic data types are sup­
ported: 8-bit bytes, 16-bit words, 32-bit long words, and generic pointers (nominally 32 
bits). These types are declared with the byte, word, lword, and ptr keywords respec­
tively. The array and record keywords can be used as a synonym for byte in order 
to provide some self-documentation when declaring a structure or array of structures. 
All but pt rs are signed quantities. 
Listing 6.1 shows the type definitions from virtual.h. I'm making nonportable 
assumptions about word widths here; you may have to change these definitions in your 
own system. The pt r type is a character pointer, as compared to a void pointer, so that 
it can be incremented if necessary. 
The <tools!c-code.h> file, which is #included on line one of Listing 6.1, contains 
various definitions that control the widths of basic types. It is shown in Listing 6.2. This 
information has been split into a second header file because it is likely to be used by the 
compiler that is generating C-code, but is not much use in interpreting the C-code. 
Section 6.2.2-Basic Types 
Table 6.2. Translating C to C-code to 8086 Assembly Language 
C Input 
strcpy( dst, src ) 
char *dst, *src; 
char *start; 
start = dst; 
while( *src ) 
{ 
*dst++ = *src++ 
return start; ; C-Code Output 
#include <tools/virtual.h> 
#define T(x) 
SEG(bss) 
#define LO 1 /* strcpy: locals 
#define L1 2 /* strcpy: temps. 
#undef T 
#define T(n) (fp-L0-(n*4)) 
SEG(code) 
PROC(_strcpy,public) 
/* fp+4 = dst [argument] */ 
/* fp+B = src [argument] */ 
link (LO+L1); 
/* fp-4 = start [variable] */ 
BP(fp-4) = BP(fp+4); 
TST1: 
EQ(*BP(fp+8),0) /* src */ 
goto EXIT1; 
BP (T(1)) = BP(fp+4); 
BP(fp+4) += 1; 
BP (T(2)) = BP(fp+B); 
BP (fp+B) += 1; 
*BP (T (1)) = 
goto TST1; 
EXIT1: *BP(T(2)); 
rF.pp = BP(fp-4); 
goto RET1; 
RET1: 
unlink (); 
ret(); 
ENDP(_strcpy) /* t1=dst 
/* dst++ 
/* t2=src 
/* src++ 
/* *t1=t2 *I 
*I 
*I 
*I *I 
*I 
*I 
6.2.3 The Virtual Machine: Registers, Stack, and Memory 8086 Assembler 
BSS SEGMENT WORD PUBLIC 
BSS ENDS 
TEXT SEGMENT WORD PUBLIC 
ASSUME CS: TEXT 
PUBLIC _strcpy 
_strcpy PROC NEAR 
; [bp+2] = dst 
; [bp+4] = src 
push bp 
mov bp,sp 
sub sp,6 
; [bp-2] = start 
mov ax,WORD PTR [bp+2] 
mov WORD PTR [bp-2],ax 
TST1: 
mov 
mov 
or 
jz bx,WORD 
al,BYTE 
al,al 
EXIT1 PTR PTR [bp+4] 
[bx] 
mov si,WORD PTR [bp+2] 
inc WORD PTR [bp+2] 
mov di,WORD PTR [bp+4] 
inc WORD PTR [bp+4] 
mov bx,di 
mov al,BYTE PTR [bx] 
mov bx,si 
mov BYTE PTR [bx],al 
jmp TST1 
EXIT1: 
mov bx,WORD PTR [bp-4] 
jmp RET1 
RETl: 
mov sp,bp 
_strcpy ENDP 
TEXT ENDS -
END 
The C-code virtual machine is pictured in Figure 6.1. The machine has a set of 16 The register set. 
general-purpose registers named rO, rl, r2, and so forth. An entire 32-bit register can be 
accessed from any instruction, as can either of the 16-bit words or any of four 8-bit bytes 
that comprise the same register. These registers are memory locations that are physically 
part of the CPU itself-they don't have addresses. Use the syntax shown in Table 6.3 to 
access a register. The name must always be fully qualified; one of the forms shown in 
Table 6.3 must always be used. The register name by itself (without the dot and type 
reference) is illegal. 451 
452 Code Generation -Chapter 6 
Listing 6.1. virtual.h- Basic Types 
1 #include <tools/c-code.h> 
2 /* Basic types *I 
3 typedef char byte; /* 8 bit *I 
4 typedef short word; /* 16 bit *I 
5 typedef long lword; /* 32 bit *I 
6 typedef char *ptr; /* Nominally 32 bit. *I 
7 
8 typedef byte array; /* Aliases for "byte." *I 
9 typedef byte record; 
Listing 6.2. c-code.h- Various Widths 
I #define 
2 #define 
3 #define 
4 #define 
5 
6 #define 
7 #define 
8 #define 
The stack, fp, sp. BYTE WIDTH 1 /* Widths of the basic types. *I 
WORD WIDTH 2 
LWORD WIDTH 4 
PTR WIDTH 4 
BYTE HIGH BIT "0xff80" /* High-bit mask. *I 
WORD HIGH BIT "0x8000" 
LWORD HIGH BIT "0x80000000L" 
In addition to the register set, there is a I 024-element, 32-bit wide stack, and two 
special-purpose registers that point into the stack: the fp and sp registers--discussed in 
depth, below. 
The instruction pointer, 
ip. Finally, there is the ip or instruction-pointer register. This register holds the address 
(in the code segment) of the next instruction to execute, not of the current instruction. It 
is updated every time an instruction is processed, and is modified indirectly by various 
instructions. A call, for example, pushes the ip and then transfers control to some­
where else. A ret pops the address at top of stack into the ip. A goto modifies the ip 
directly. The instruction pointer is not used directly by the current compiler, and its 
value won't change if you just use your C compiler to assemble the C-code output. 
Access to it is occasionally useful, however, and the register is available in all real 
machines. It's included here for completeness' sake. 
Virtual machine imple­
mentation. The register set and stack are implemented in Listings 6.3 and 6.4. Note that the 
definition for reg on lines 21 to 28 of Listing 6.4 is not portable because I'm assuming 
that an 8086-style byte ordering is used-the least-significant byte is lowest in memory, 
and the most-significant byte is highest. Exactly the opposite holds in 68000-style 
machines. The LSB is highest in memory, so you'd have to redefine the_ words and 
_bytes fields as follows for those machines: 
struct words 
struct _bytes { word high, low; }; 
{ byte b3, b2, bl, bO; }; 
The address of an object is the physical address of the least-significant byte in both the 
8086 and 68000 family. Other machines may require even more shuffling. 
Section 6.2.3-The Virtual Machine: Registers, Stack, and Memory 
Figure 6.1. The C-code Virtual Machine 
high low 
h3 h2 hi hO stack[] 
rO I I I 
rl I I I _3_1_ ll _1_1_!! 
r2 I I I 
r3 I I I I sp 
r4 I I I 
I I I r5 I fp 
L L J r6 
r7 I I I 1,024 -- --
r8 I I I 32-bit -r-- -r--
19 I I I !words 
rA I I I 
rB I I I 
rC I I I 
rD I I I 
rE I I I 
rF I I I r---32 hits -4 
text data bss 
fl_lL'-'-1 _3_1_ll _1_1_!! _J_I_.ll _1_1_!! 
I • I ip 
-L....-initialized -'--__ uninitialized -'--_ _ mstructwns __ -r--data -r----data -r--
Table 6.3. The Virtual-Machine Register Set 
rl contains: 
pointer 
32-bit long word 
two 16-bit words 
four 8-bit bytes (byte 0 is low) access syntax: 
rl.pp 
rl.l 
rl.w.high 
rl.b.b3 rl.b.b2 rl.w.low 
rl.b.bl rl.b.bO 453 
454 Code Generation -Chapter 6 
Listing 6.3. c-code.h- Stack-size Definitions 
9 #define SWIDTH 
10 #define SDEPTH LWORD WIDTH 
1024 /*Stack width (in bytes). 
/* Number of elements in stack. *I 
*I 
Listing 6.4. virtual.h- The Register Set and Stack 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 34 
35 
36 
37 
38 #ifdef ALLOC 
# define I (X) X 
# define CLASS /* empty *I 
#else 
# define I (x) /* empty *I 
# define CLASS extern 
#endif 
struct words word low, high; } ; 
struct _bytes byte bO, bl, b2, b3; } ; /* bO is LSB, b3 is MSB */ 
typedef union reg 
{ 
char *pp; /* pointer *I 
lword 1; /* long word *I 
struct words w; /* two 16-bi t words *I 
struct 
reg; 
CLASS reg 
CLASS reg 
CLASS reg 
CLASS reg 
CLASS reg 
#define fp 
#define sp bytes b; /* four 8-bit bytes *I -
rO, 
rB, rl, r2, r3, r4, r5, 
r9, rA, rB, rC, rD, 
stack[ SDEPTH ]; 
* sp I(= &stack[ 
* fp I(= &stack[ 
((char *) fp) 
((char *) sp) r6, r7 
rE, rF 
SDEPTH 
SDEPTH l ) ; 
l ) ; /* Registers */ 
/* run-time stack */ 
/* Stack pointer */ 
/* Frame pointer */ 
Note that the stack itself is declared as an array of reg unions on line 33 of Listing 
6.4, and the stack and frame pointers are reg pointers. The sp and fp registers are refer­
enced in C-code directives using the macros on lines 37 and 38, however. The cast 
assures that pointer arithmetic is defeated in the based addressing modes discussed 
below. 
The stack is deliberately made as wide as the worst-case basic type-if a 64-bit dou­
ble were supported, I would have made the stack 64 bits wide. This way, all stack 
access can be done with a single instruction. I've done this in order to make the back 
end's life a little easier. It's a simple matter to translate single push and pop instructions 
into multiple instructions (if the target-machines stack is 16 bits wide, for example). It's 
difficult to go in the other direction, however-to translate multiple pushes and pops into 
single instructions. 
Allocating space for the 
virtual-register set, AL­
LOC. You must put the following two lines into only one module of your program to actu­
ally allocate space for the stack and register set: 
#define ALLOC 
#include <tools/virtual.h> 
You can create a two-line file, compile it, and link it to your other code if you like. 
Section 6.2.3-The Virtual Machine: Registers, Stack, and Memory 455 
When ALLOC is defined, the definitions on lines II and I2 are activated. Here, CLASS CLAss. 
evaluates to an empty string, so all invocations of the CLASS macro effectively disappear 
from the file. The I ( ) macro evaluates to its argument, so an invocation like The r ( > macro. 
I(= &stack[SDEPTH]); 
evaluates to 
= &stack[SDEPTH]; 
The macro's argument is the entire string =&stack [SDEPTH]. When ALLOC is not 
defined, the opposite situation holds, CLASS expands to the keyword extern and the 
contents of the I ( ) macro are discarded. 
The run-time stack, stack pointer, and frame pointer registers are defined at the bot­
tom of Listing 6.4. The stack is the same width as a register, and the stack pointer is ini­
tialized to point just above the top stack element. It grows towards low memory with the 
first push. 
6.2.~ Memory Organization: Segments 
The stack represents only a portion of the memory that can be used by the running 
program. This memory is partitioned into several segments, one of which is the stack Segments. 
segment. Figure 6.2 shows how the segments are usually arranged. 
Figure 6.2. Segments 
- -- - - - - - - ---
heap 
~ 
stack initial stack pointer 
bss (uninitialized data) 
i data (initialized data) 
stored on 
disk text (code) 
l prefix 
The rationale behind this partitioning is best understood by looking at how a program 
is loaded by the operating system. Initially, a contiguous region of memory is allocated 
for the program to use. This region can be physical memory, as it is in most microcom­
puters, or can be virtual memory, as on a mainframe. In the later case, the physical 
memory might not form a contiguous block, but it's convenient to look at it that way. 
The prefix segment holds information that is used by the operating system to load the 
program. Typically, the sizes of the various segments are stored there, as are things like 
the initial values of the program counter and stack pointer. Some operating systems (like 
MS-DOS) read the prefix into memory, and it's available for the program to use at run 
time. Other operating systems read the prefix to get the information that it contains, and 
then overwrite the prefix with the other segments. The program-load pro­
cess. 
The program prefix. 
456 
Executable image. 
Text (or code) and (ini­
tialized) data segments. 
Bss segment. 
Stack segment. 
Heap segment. 
Dynamic arrays. 
Combined heap and 
stack. Code Generation -Chapter 6 
Using the information in the prefix, the operating system then allocates a block of 
memory large enough to hold the remainder of the program, called the executable image. 
The text and data segments are then copied directly from the disk into memory. The text 
or code segment holds the executable code; the data segment holds initialized data, only. 
That's why an initialized static local variable comes up with an initial value, but once 
that value is changed it stays changed-the initial value is just read from the disk into 
the proper place in memory. Note that there are two types of initialized data: variables 
that have been given an initial value when declared, and initialized constants (like string 
constants) whose values are not expected to change. The constant data is sometimes 
stored in the text segment, along with the code, in order to make the operating system's 
life a little easier. It knows that the text segment is not modified, so it doesn't have to 
swap this region out to the disk if it needs the memory for another process. 
One of two things can happen once the text and data segments are loaded, depending 
on the operating system. Either control can be transferred directly to the program, which 
must continue the initialization process, or the operating system itself initializes the 
other segments. In any event, the bss4 segment, which holds all uninitialized data, is ini­
tialized to all zeros at load-time. (There's no point in storing masses of zeros on the 
disk.) The stack pointer is then initialized to point at the correct part of the stack seg­
ment, which holds the run-time stack used for subroutine calls, and so forth. Stacks grow 
down in most computers, so the stack pointer is typically initialized to the top of the 
stack segment. Various pointers that manipulate the heap, the region of memory used for 
dynamic storage, are also initialized. The heap is used, in C, by the memory-allocation 
subroutines malloc () and free() .5 In some languages the heap is also used in code 
generated by the compiler itself. The C++ new operator allocates memory for an object; 
and a user-defined class might do memory allocation transparently when an object in that 
class is declared. Similarly, PL/1 supports dynamically allocable arrays-arrays whose 
size is not known until run time, and the PL/1 compiler uses the heap to allocate space 
for that array when the scope of that declaration is entered at run time (when the block 
that holds the declaration is entered). The compiler just translates a compile-time 
declaration into code that allocates space for the array and initializes a pointer to access 
the first element-it effectively calls malloc () when the subroutine is entered and 
free () at exit. The contents of the stack and heap segments are typically uninitialized 
at load time, so the contents of variables allocated from these regions are undefined. The 
heap is typically at the top of the image because it may have to grow larger as the pro­
gram runs, in which case the memory-allocation functions request that the operating sys­
tem enlarge the size of the executable image. The heap and stack segments are often 
combined, however. Since the stack pointer typically grows down, and the memory allo­
cation from the heap can start in low memory and go up, the shared space can be allo­
cated from both ends as needed, like this: 
4. Bss stands for "block staning with symbol," a term dating from the Mesozoic, at least. 
5. The source code for amalloc () and free() implementation is in [K&R] pp. 185-189. 
Section 6.2.4-Memory Organization: Segments 
stack ~ initial stack pointer 
... t .......... :: 
::::: ....... t 
heap 
This way, if a program has an unusually large stack and unusually small heap or vice 
versa, space can be transferred from one area to the other with ease. It's difficult to 
expand the size of the heap after the top of heap runs into the stack, however, and such 
expansion almost always results in a fragmented heap. The virtual-memory manager 
could solve the fragmentation problem, but it might not. 
Many compilers provide a mechanism for the program to determine the positions of 
various segments at run time. For example, the UNIX compiler automatically declares a 
variable at the end of the bss segment called ebss. All memory whose address is greater 
than &ebss must be in the stack or heap segments. Other variables (called etext and 
edata) are provided for the other segment boundaries. Similarly, many compilers gen­
erate code that checks the value of the stack pointer when every subroutine is entered 
and terminates the program if the stack pointer is not in the stack segment. 
C-code lets you change from one segment to another by issuing a SEG ( ) directive, 
which takes one of the following forms: 
SEG( text 
SEG( data ) 
SEG( bss ) 
Note that no semicolon is used here-this is the case for all C-code directives whose 
names are in all caps. Everything that follows a SEG (text) (up to the next SEG () 
directive or end of file) is in the text segment, and so forth. You can use SEG (code) 
instead of SEG (text). There's no direct access to the prefix, stack, and heap segments 
because these exist only at run time, and the compiler uses other mechanisms to access 
them. You may not change segments in the middle of a subroutine. No SEG directives 
can appear between the PROC and ENDP directives, discussed below. The SEG () direc­
tive is defined as an empty macro in virtual.h. It's shown in Listing 6.5. 
Listing 6.5. virtual.h- The SEG ()directive. 
I 39 #define SEG (segment) /* empty * 1 
6.2.5 Variable Declarations: Storage Classes and Alignment 
C-code supports global-level variable declarations only. All variables must be 
declared in the data or bss segments, depending on whether or not they are initialized. 
Four storage classes are available (they are related to C in Table 6.4): 
private Space is allocated for the variable, but the variable cannot be accessed from 
outside the current file. In C, this class is used for all static variables, be 
they local or global. Initialized variables go into the data segment, other 
variables go into the bss segment. 457 
Segment-end markers: 
ebss, etext, edata. 
The SEG () directive. 
No semicolon used with 
upper-case C-code direc­
tives. 
458 Code Generation -Chapter 6 
Location counter. public Space is allocated for the variable, and the variable can be accessed from 
any file in the current program. In C, this class is used for all initialized 
nonstatic global variables. It is illegal for two public variables in the 
same program to have the same name, even if they're declared in different 
files. Since public variables must be initialized when declared, they must 
be in the data segment. 
common Space for this variable is allocated by the linker. If a variable with a given 
name is declared common in one module and public in another, then the 
public definition takes precedence. If there are nothing but common 
definitions for a variable, then the linker allocates space for that variable in 
the bss segment. C uses this storage class for all uninitialized global vari­
ables. 
external Space for this variable is allocated elsewhere. If a label is external, an 
identical label must be declared common or public in some other module 
of the program. This storage class is not used for variables in the current 
application, all of which are common, public, or private. It is used for 
subroutines, though. 
Table 6.4. Converting C Storage Classes to C-code Storage Classes 
not static 
static declaration (extern definition or prototype) 
Subroutine private public external (in text segment). 
Uninitialized variable private (in bss segment). common 
Initialized variable private public (in data segment). 
The following example shows how these classes are used in C: 
int kook! a = 1; 
static int fran; 
int ollie; 
int ollie; 
void ronnie () 
{ /* 
/* /* /* 
/* 
/* Public--it's initialized and not static. *I 
Private--it's static. Initialized to 0. *I 
Common--it's declared without an extern. *I 
Not a redefinition because default class *I 
is extern. Both instances of ollie are *I 
common. *I 
static float george; /* Private--it's declared static. */ 
extern dan; 
int dick = 1; /* 
/* 
/* Common. */ 
No declaration is generated. (The */ 
memory is allocated on the stack). */ 
The four storage classes can be broken into two broad categories--classes that allo­
cate space in the executable image (as stored on the disk) and classes that don't allocate 
space. I'll have to dip into real assembly language (8086 assembler) for a moment to 
show what's actually going on. The assembler actually builds a physical copy of the 
executable image in memory as it works, and it copies this image to the disk when 
assembly is complete. The assembler keeps track of the current position in the execut­
able image that it's building with an internal variable called the location counter. 
A directive like the following allocates space for a variable: 
Section 6.2.5-Variable Declarations: Storage Classes and Alignment 
var : dw 10 
This instruction tells the assembler to do the following: 
• Create a symbol-table entry for_ var and remember the current value of the location 
counter there. 
• Fill the next two bytes with the number 10. Two bytes are allocated because of the 
dw-other codes are used for different sizes; db allocates one byte, for example. The 
I 0 is taken from the dw directive. 
• Increment the location counter by two bytes. 
The allocated space (and the number 10, which is used here to fill that space) end up 
on the disk as part of the executable image. Instructions are processed in much the same 
way. For example, a 
MOV ax,_var 
instruction moves the contents of_ var into the ax register. This instruction tells the 
assembler to do the following: 
• Copy a binary code representing the "move into ax" operation into the place refer-
enced by the current location counter. This binary code is called the op code. op code. 
• Copy the address of_ var into the next two bytes. This address is the location­
counter value that was remembered in the symbol table when space for _ var was 
allocated. 
• Increment the location counter by three. 
From the assembler's perspective, code and data are the same thing. All it knows 
about is the current location counter. There is nothing preventing us from putting a MOV 
instruction into memory as follows: 
db OAOH 
dw var ; OxAO is the 8086 op code for "MOV into AX" 
; address of var 
Applying the foregoing to C-code storage classes, public and private definitions 
are translated into dw directives in 8086 assembler. They cause the location counter to 
be moved, and some value is copied into the allocated space. This value ends up on the 
disk as part of the executable image. The external directive is at the other extreme. 
No space is allocated; the location counter is not modified. The assembler does create a 
symbol-table entry for the associated label, however. If that label is referenced in the 
code, place holders are put into the image instead of the actual addresses, which are not 
known by the compiler. The linker replaces all place holders with the correct addresses 
when it puts together the final program. The external directive must reference a 
region of memory allocated with a dw directive or equivalent somewhere else in the pro­
gram. The unpatched binary image (with the place holders still in it) is usually called a 
relocatable object module.6 
The corrunon storage class is somewhere in between external and public. If the 
name associated with the corrunon is used elsewhere in a public or private declara­
tion, then the corrunon is treated just like an external. Things change when all 
6. One common way to organize a relocatable module puts a symbol table into the object file. The table has 
one element for each unresolved reference---private symbols are not put into the table. The symbol­
table elements hold the symbol's name and the offSet from the start of the file to the first place holder that 
references that symbol. That place holder, in tum, holds the offSet to the next place holder for the same 
symbol, in a manner similar to a linked list. The last element of the list is usually marked with zeros. Most 
8086 relocatable-object-module formats derive from the specification described in [lntelJ and in 
[Armbrust]. Relocatable object 
module. 459 
460 
Allocating variables. Code Generation -Chapter 6 
references to the variable are commons, however. Space is allocated for the variable at 
load time, not at compile time. Remember, the executable image on the disk represents 
only part of the space that is used when the program is running. Space for a common is 
always allocated in the bss segment, which is created when the program is loaded-it 
has no existence at compile time and won't be part of the binary image on the disk. The 
linker replaces the place holders in those instructions that use the common variable with 
references to the place at which the variable is found at run time, but no dw directive is 
generated. Space is allocated implicitly because the linker leaves a note in the execut­
able image's file header that tells the loader the size of the bss region. Instead of incre­
menting the location counter at compile time, the assembler tells the loader to increment 
it at load time, by making the size of the executable image large enough to encompass 
the extra space. 
Returning to C-code, all variables must be declared using a basic type (byte, word, 
lword, or ptr) and one of the foregoing storage classes (private, public, common, 
external). In addition, one-dimensional arrays can be declared using trailing brackets. 
Multi-dimensioned arrays are not permitted. The following declarations (only) are avail­
able; 
class type name; 
class type name [ constant ) ; /* single variable */ 
/* array */ 
A structure must be declared as a byte array, though the keyword record can be 
used as a synonym for byte for documentation purposes. 
Public and private variables in the data segment may be initialized with an 
explicit C-style initializer. Character constants and implicit array sizes are both sup­
ported. For example: 
SEG( data ) 
public byte name 
public byte name[] 
public byte name[] 
private word name 
public word name[3] , z' ; 
'a', 'b', 'c', 'd', '\0' 
"abed"; 
10; 
10, 11, 12 ; 
The double-quote syntax can be used only to initialize byte arrays. A C declaration such 
as the following: 
kings[4] = 
{ 
} ; "henry", 
"kong", 
"e1vis" 
"balthazar" 
must be declared as follows in C-code: 
SEG( data); 
private byte 
private byte 
private byte 
private byte 
public ptr S1 [] 
S2 [] 
S3 [] 
S4 [ l 
kings[4] "henry\0" 
"kong\0" 
"elvis\0" 
"balthazar\0" 
S1, S2, S3, S4 } ; 
These declarations are all in the data segment because they're initialized. The 
anonymous string names must be private because the same labels may be used for 
other anonymous strings in other files. kings is public, because it wasn't declared 
static. The virtual.h definitions for the various storage classes are in Listing 6.6. 
Section 6.2.5-Variable Declarations: Storage Classes and Alignment 
Listing 6.6. virtual.h- Storage Classes 
40 #define public 
41 #define common 
42 #define private 
43 #define external /* empty */ 
/* empty */ 
static 
extern 
The C-code assembler assumes that memory is made up of of 32-bit wide cells, each 
of which occupies four addresses. The various basic types control the way that the four 
bytes can be accessed. In particular, the least significant byte of an object must also be 
at an address that is an even multiple of the object's size-a byte can be anywhere, a 
word must be at an even address, an lword and ptr must be at an address that's an even 
multiple of four. All objects are stored with the least-significant byte at the lowest phy­
sical address and the most-significant byte at the highest address. A pointer to an object 
holds the physical address of the least-significant byte. The system is pictured in Figure 
6.3. 
Figure 6.3. Memory Alignment 
3 12 _[/ 10 
7 16 15 14 
// 110 19 18 
/5 114 113 112 
/9 118 l/7 l/6 
~c.-0 
4 
8 Four, 8-bit bytes. 
12 Two, 16-bit words. 
16 13 msb l2 lsb l1msb IO lsb 
~c.-One, 32-bit long word. f--32 hits ----4 13 msb 12 II 10 Jsb 
A good analogy for these restrictions is a book printed in a typeface that's half a page 
high. The typeface is also so wide that only two digits can fit on a line. The rules are 
that a two-digit number must be on a single line. A four-digit number, which requires 
two lines to print, must be on a single page. An eight-digit number, which requires four 
lines to print, must be on two facing pages. 
These restrictions are called alignment restrictions. (You would say that words must 
be aligned at even addresses, and so forth.) Alignment restrictions are usually imposed 
by the hardware for efficiency's sake. Ifthe data path from memory to the CPU is 32 bits 
wide, the machine would like to fetch all 32 bits at once, 
and this is difficult to do if the 
32-bit word can be split across a multiple-of-four boundary. 461 
Alignment. 
LSB is at the lowest ad­
dress. 
The actual byte ordering is not critical in the present application provided that it's Structure-field allocation 
consistent, but the alignment restrictions are very important when doing something like and alignment. 
allocating space for a structure. For example, the following structure requires 16 bytes 
rather than nine, because the 16-bit int must be aligned on an even boundary; the 32-bit 
long must start at an address that's an even multiple of four, and padding is required at 
the end to assure that the next object in memory is aligned properly, regardless of its 
type. A declaration like the following: 
462 
ALIGN () directive. struct 
{ 
char cl; 
int i; 
char c2; 
long 1; 
char c3; 
fred; 
allocates fields placed in memory like this: 
3 i 12 ~ocl 0 
4 c2 4 
vo 119 18 8 
12cJ 12 Code Generation -Chapter 6 
Though C guarantees that the ordering of structure members will be preserved, a clever 
compiler for another language might shuffle around the ordering of the fields to make the 
structure smaller. If cl were moved next to c2, then four bytes would be saved. The 
three bytes of padding at the end of the structure are required in case you have an array 
of structures. A clever compiler could actually eliminate the padding in the current 
example, but nothing could be done if the first field of the structure was a lonq, which 
needs to be aligned on a multiple-of-four boundary. 
C-code variable declarations automatically force proper alignment for that variable, 
so if you declare a byte-sized variable followed by a 16-bit word, one byte of memory is 
wasted because the word requires even alignment. There are occasional situations where 
alignment must be forced explicitly, and C-code provides the ALIGN (type) directive for 
this purpose. The assembler inserts sufficient padding to assure that the next declared 
variable is aligned as if it were of the indicated type. ALIGN is defined in virtual.h in 
Listing 6.7. The worst-case alignment boundary is declared for use by the compiler in 
c-code.h (Listing 6.8). 
Listing 6.7. virtual.h- The ALIGN Directive 
I 44 #define ALIGN (type) I* empty * 1 
Listing 6.8. c-code.h- Worst-case Alignment Restriction 
11 #define ALIGN WORST LWORD WIDTH I* Long word is worst-case alignment. *I 
Immediate mode. 
Direct mode. 6.2.6 Addressing Modes 
Constants and all variable and register names are referenced in instructions by means 
of various addressing modes, summarized in Table 6.5. 
The immediate addressing mode is used for numbers. C-style hex, octal, decimal, 
and character constants are all recognized (Oxabc 0377 123 'c' ); lword (32-bit) 
constants should be indicated by a trailing L (Oxl2345678L). The immediate address­
ing mode is used in real assemblers to put a physical number into an instruction rather 
than an address. Many real assemblers require a special symbol like # to precede 
immediate data. 
The direct mode is used to fetch the contents of a variable. There is usually no spe­
cial operator here; you just use the variable's name. Note, however, that array and 
Section 6.2.6-Addressing Modes 
function names cannot be accessed in direct mode-their name is always treated as the 
address of the first element or instructions. 
The effective-address mode gets the address of an object. The operand of the & 
operator is usually a label (&x where x is a name in a previous declaration), but it can 
also be used in conjunction with one of the based addressing modes, discussed shortly. 
Note that the & should be omitted from a function or array name. 463 
Indirect modes. The indirect modes work only on objects of pointer type: a variable that was 
declared pt r, a register name followed by the . pp selector, or the sp or fp registers. 
You must do two things to access an object indirectly. You must surround the variable or 
register that holds the address with parentheses to indicate indirection, and you must tell 
the C-code assembler the kind of object that the pointer is referencing. You do the latter 
by preceding the parenthesis with one of the following one-or two-character modifiers: Indirection indicated by 
parentheses. 
Code Points at object 
of this type. 
B byte 
w word 
L lword 
p ptr 
BP pointer to byte 
WP pointer to word 
LP pointer to lp 
pp pointer to pt r 
For example, W ( rO. pp) fetches the word whose address is in rO. pp. You can also w <Pl. w <p+offset) 
access an object at a specified offset from a pointer with the following syntax: 
w (p + offset) 
The offset may be a number, a numeric register reference (as compared to a pointer refer­
ence), or a numeric variable. The following example references the word whose address 
is derived by adding together the contents of the fp register and rO. w .low: 
W(fp + rO.w.low) 
The following instruction references the long word at an offset of -16 (bytes) from the 
frame pointer: 
L (fp-16) 
If the fetched object is of type BP, WP, LP, or PP, a star may be added to fetch the object 
to which the pointer points. For example, WP ( fp+ 6) fetches the word pointer at offset 6 WP <Pl. *WP <Pl 
from the frame pointer; *WP ( fp+ 6) fetches the object pointed to by that word pointer. 
Note that these double indirect modes, though found on most big machines like VAX's, 
are missing from many machines. You would have to use two instructions to access the 
referenced object-like this: 
rO.pp = WP(fp+6); 
rl.w = W(rO.pp); 
The effective-address and indirect modes can be combined in various ways, summar­
ized in Table 6.6. The alternate syntaxes are useful when doing code generation, 
because variables on the stack can be treated the same way as variables at fixed 
addresses. For example, the address of a word pointer that is stored at offset 8 from the 
frame pointer can be fetched with &WP ( fp+6), and the address of a word pointer, _p, at 
a fixed address can be accessed with & WP ( & _p) . The convenience will become evident 
when code-generation for the arithmetic operators is discussed, below. You can look at Combined effective­
address and indirect 
modes. &WP (&p). 
464 Code Generation -Chapter 6 
Table 6.5. Addressing Modes 
Mode Example Notes 
immediate 93 Decimal number. Use leading Ox for hex, 0 for octal. 
direct x, rO.l Contents of variable or register. 
B(p) byte whose address is in p. 
W(p) word whose address is in p. 
L(p) lword whose address is inp. 
indirect P(p) ptr whose address is in p. 
BP(p) byte pointer whose address is in p. 
WP(p) word pointer whose address is in p. 
LP(p) 1 word pointer whose address is in p. 
PP(p) ptr pointer whose address is in p. 
*BP(p) byte pointed to by pointer whose address is in p. 
double *WP(p) word pointed to by word pointer whose address is in p. 
indirect *LP(p) 1 word pointed to by 1 word pointer whose address is in p. 
*PP(p) pt r pointed to by pt r whose address is in p. 
B(p+N) byte at byte offset N from address in p. 
based W(p+N) word at byte offset N from address in p. 
indirect L(pN) lword at byte offset N from address in p. ... 
effective &name Address of variable or first element of array. 
address &W(p+N) Address of word at offset +n from the pointer p (The 
effective-address modes can also be used with other 
indirect modes see below.) 
A generic pointer, p, is a variable declared ptr or a pointer register: rN. pp, fp, sp. 
N is any integer: a number, a numeric register (rO. w .low), or a reference to a 
byte, word, or lword variable. The based indirect modes can take negative offsets 
as inB (p-8). 
these alternate addressing modes as a way to specify an explicit type in the variable 
reference. An & w ( & p) tells you that p points at a word, information that you would not 
have if p were used by itself. 
Note that p may not be preceded by an ampersand if it references a register because 
registers don't have addresses. Also, the ampersand preceding the pin the examples in 
Table 6.6 is optional if p is the name of an array or function. Since some compilers print 
a warning if you use the ampersand in front of an array or function name, you should 
leave the ampersand off unless your compiler requires it. 
Finally, note that C-style pointer arithmetic is used when a double-indirect directive 
tells the assembler the type of the referenced object. 
ptr p; 
p += 1 I* Adds 1 to p because the referenced *I 
I* object's type is unspecified. *I 
BP (&p) += 1 I* Adds 1 (size of a byte) to p. *I 
WP (&p) += 1 I* Adds 2 (size of a word) to p. *I 
LP (&p) += 1 I* Adds 4 (size of a lword) to p. *I 
The macros that implement the various type directives are in Listing 6.9. The 
prefixes themselves are declared, for the benefit of the compiler that's generating the C­
code, in c-code.h and are shown in Listing 6.10. 
Section 6.2.6-Addressing Modes 
Table 6.6. Combined Indirect and Effective-Address Modes 
Syntax: Evaluates to: 
&p 
&W(&p) address of the pointer &WP(&p) 
&WP (fp+n) 
p 
&W(p) contents of the pointer itself WP (&p) 
WP (fp+n) 
W(p) 
*WP(&p) contents of the word whose address is in the pointer 
*WP (fp+n) 
Listing 6.9. virtual.h- Direct-Stack-Access Directives 
45 #define W * (word *) 
46 #define B * (byte *) 
47 #define L * (lword *) 
48 #define P * (ptr *) 
49 #define WP * (word **) 
50 #define BP * (byte **) 
51 #define LP * (lword **) 
52 #define pp * (ptr **) 
Listing 6.10. c-code.h- Indirect-Mode Prefixes 
12 #define BYTE PREFIX "B" /* Indirect-mode prefixes. 
13 #define WORD PREFIX "W" 
14 #define LWORD PREFIX "L" 
15 #define PTR PREFIX "P" 
16 #define BYTEPTR PREFIX "BP" 
17 #define WORDPTR PREFIX "WP" 
18 #define LWORDPTR PREFIX "LP" 
19 #define PTRPTR PREFIX "PP" 
6.2.7 Manipulating the Stack 
Two C-code directives are provided to do explicit stack manipulation. These are: 
push ( something ) 
and 
something =pop ( type ) *I 
The push () macro pushes the indicated object, and the pop () macro pops an object of 
the indicated type. For example, if x were declared as an lword, you could say: 
x = pop (lword). The lword is the declared type of the target (of x). The target can 
also be a register, but the types on the two sides of the equal sign must agree: 465 
Push and pop directives. 
466 
Push junk if pushed ob­
ject is too short. Code Generation -Chapter 6 
rl.w.low =pop( word); 
The stack is 32 bits wide, so part of the stack word is wasted when you push or pop 
small objects. For example: 
rl.w.low =pop( word ) 
pops the bottom word of the current top-of-stack item into the low half of rl. The top 
half of the stack item is discarded, and the top half of rl is not modified. A push 
instruction modifies a 32-bit quantity, and the pushed object is right-adjusted in the 32-
bit word. Ifrl holds Oxl2345678, the following instruction: 
push( rl.b.b3 ) 
pushes the number Ox??????12. The question marks represent undefined values. A 
push( rl.w.low ) 
directive pushes Ox????5678, 
push( rl.w.high ) 
pushes Ox????1234, and 
push( rl.w.l ) 
pushes the entire number Ox 12345678. 
A simple push (rl) is not permitted. The register name must be fully qualified. 
Use push ( r 1 . 1) to push the entire register. 
The two stack directives are defined in virtual.h in Listing 6.11. 
Listing 6.11. virtual.h- Pushing and Popping 
53 #define push(n) 
54 #define pop (t) (--sp) ->1 = (lword) (n) 
(t) ( (sp++) ->1 ) 
Subroutine definitions. 
Passing control: 
call(name) and ret() 6.2.8 Subroutines 
Subroutines must all be defined in the text segment. External-subroutine declarations 
should be output as follows: 
external name(); 
No return value may be specified. 
Subroutine definitions are created by surrounding the code that comprises the sub­
routine with PROC (name, class) and ENDP (name) directives. The name is the func­
tion name and the class is the storage class (either public or private). private 
functions cannot be accessed outside the current file. Invocations of PROC ( ) and 
ENDP ( ) may not be followed by semicolons. 
A subroutine is called using a call (name) directive and control is passed back to 
the calling function with a ret () directive. For example: 
SEG ( text ) 
PROC( _sylvester, public 
call ( _tweety ) ; 
ret(); 
ENDP( sylvester /* Call subroutine tweety. */ 
/* Return to calling function. */ 
The argument to call () can be either a subroutine name or a reference to a variable or 
register [like call (rl.pp), which calls the subroutine whose address is in rl.pp]. 
Section 6.2.8-Subroutines 
Note that the compiler has inserted underscores in front of the variable names so that 
these names won't conflict with internally generated labels. A ret () statement is sup­
plied if one is not already present immediately before the ENDP. 
The virtual.h definitions for these macros are in Listing 6.12. The call ( ) macro 
simulates an assembly-language call instruction which pushes the return address (the 
address of the instruction that follows the call) onto the stack and then transfers control 
to the address that is the call's argument. Here, the return-address push is simulated by 
pushing the "stringized" version of the subroutine name onto the stack, and then the 
subroutine is called.7 An assembly-language return instruction pops the address at the 
top of stack into the instruction pointer. The ret ( ) directive simulates this process by 
popping the name from the stack and returning. 
Listing 6.12. virtual.h- Subroutine Definitions, Calls, and Returns 
55 #define PROC (name, cls) cls name() { Leading underscores 
avoid name conflicts. 467 
Virtual.h implementation 
of call () and ret () . 
56 #define ENDP(name) ret();} /* Name is ignored. *I 
57 
58 #define call(name) (--sp)->pp #name, (*(void (*) ()) (name)) () --59 
60 #define ret() sp++; return 
The subroutine call on line 58 of Listing 6.12 is complicated by the fact that function 
pointers must be handled as well as explicit function names. The argument must first be 
cast into a pointer to a subroutine: 
(void (*) ()) (name) 
and then can be called indirectly through the pointer. This cast does nothing if name is 
already a subroutine name, but it correctly converts register and variable references into 
indirect subroutine calls. 
6.2.9 Stack Frames: Subroutine Arguments and Automatic Variables 
Of the various memory segments, the stack segment is of particular importance to 
subroutines. The run-time stack is used to make subroutine calls in the normal way: The 
return address is pushed as part of the call and the return pops the address at top of stack 
into the instruction pointer. Languages like C, which support recursion, use the stack for 
other purposes as well. In particular, the stack is used to pass arguments to subroutines, 
and certain local variables, called automatic variables, are stored on the stack at run 
time. In C, all local variables that aren't declared static are automatic. The following 
sequence of events occurs when a subroutine is called: 
(1) The arguments are pushed in reverse order. 
(2) The subroutine is called, pushing the return address as part of the call. 
(3) The called subroutine pushes a few housekeeping registers, including the frame 
pointer, discussed below. 
(4) The subroutine advances the stack pointer so that room is freed on the stack for local, 
automatic variables and anonymous temporaries. 
7. The# directive is new to ANSI C. It turns the associated macro argument into a string by surrounding the 
matching text with implicit quotation marks. Subroutine linkage. 
Automatic variables. 
Subroutine linkage: creat­
ing the stack frame. 
468 Code Generation -Chapter 6 
Stack frame (activation 
record). 
Building a stack frame. This entire area of the stack, extending from the first argument pushed to the upper­
most local variable or temporary, is called an activation record or stack frame. The 
compiler uses the stack and stack-manipulation macros described earlier to translate the 
code in Listing 6.13 into the output code in Listing 6.14. The complete stack frame is 
pictured in Figure 6.4. 
Listing 6.13. call (of, the, wild): Compiler Input 
1 int dogl, dog2, dog3; 
2 
3 static call( of, the, wild) 
4 int of, the, wild; 
5 
6 int buck, thornton; 
7 long john_silver; 
8 
9 
10 spitz() 
11 { 
12 call( dogl, dog2, dog3 ); 
13 
Listing 6.14. call (of, the, wild): Compiler Output 
1 SEG ( bss ) 
2 int _dogl; 
3 int _dog2; 
4 int _dog3; 
5 
6 SEG (text ) 
7 PROC(_call, private) 
8 push ( fp ) ; 
9 fp sp; 
10 sp -= 8; 
11 call( chkstk ); 
12 
13 sp = fp; 
14 fp =pop( ptr ); 
15 ret () ; 
16 ENDP (_call) 
17 PROC ( spitz, public) 
18 push( fp ); 
19 fp = sp; 
20 call( chkstk ); 
21 push ( _dog3 ) ; 
22 push ( _dog2 ) ; 
23 push( _dogl ); 
24 call ( call ) ; 
25 sp += 8; 
26 sp = fp; 
27 fp = pop ( ptr ) ; 
28 ret() ; 
29 ENDP( spitz) *I 
*I I* Save old frame pointer. 
I* Set up new frame pointer. 
I* Make room for local vars. 
I* Check for stack overflow. & temporaries. *I 
I* 
I* I* Code goes here. 
Discard local variables and temporaries. 
Restore previous subroutine's fp. *I *I *I *I 
I* No sp-=N because there're no local vars. *I 
I* call( dogl, dog2, dog3 ); *I 
I* Discard the arguments to call(). *I 
I* Return from spitz(): discard local vars. *I 
I* Restore calling routine's frame pointer. *I 
Local variables in the 
stack frame. The sp-=8 on line ten of Listing 6.14 decrements the stack pointer to make room both 
for local variables and for a small scratch space to use for the anonymous temporaries. 
(Note that the stack pointer must be decremented in even multiples of 4 [the stack width] 
Section 6.2.9-Stack Frames: Subroutine Arguments and Automatic Variables 
Figure 6.4. Stack Frame for call (of, the, wild) 
low memory t 
sp 
temporaries 
fp-12 
local variables fp-8 
fp-4 ------------
old frame pointer fp ------------
return address fp+4 ------------
of: dog_ 1 fp+B 
--- - - - - - - - --
the: dog_ 2 fp+l2 ------------
wild: dog_ 3 fp+l6 
old frame pointer r 
------------stack frame of 
return address calling function ------------l 
when you modify it explicitly, as compared to modifying it implicitly with a push or 
pop.) Unlike the arguments, the positions of local variables and temporaries within their 
area are arbitrary. 8 Don't be confused by the fact that part of the stack frame is created 
by the calling function and the other part is created by the called function. The stack 
frame is a single entity. Everybody is responsible for undoing what they did, so the cal­
ling function cleans the arguments off the stack, and the called function gets rid of every­
thing else. Note that this organization of the stack frame, though characteristic, is not 
mandatory. Many compilers put the temporaries in different places or not on the stack at 
all. Sometimes, space on the stack frame is reserved to pass arguments to run-time 
library functions, to push registers used for register variables, and so on. 
Figure 6.5 shows the local-variable and argument portion of the stack frame in 
greater detail. The frame-pointer register (fp) provides a fixed reference into the stack 
frame. It is used to access all the arguments and automatic variables. The argument 
wild-which contains dog_ 3--can be accessed using the indirect addressing mode as 
follows: 
8. The chkstk () subroutine, called on line II, checks that the stack pointer hasn't crossed over into a 
diffi:rent segment, as can happen if you allocate a large automatic array. It aborts the program if an error is 
discovered. This routine can also be used by a profiler subroutine to log the time at which the subroutine 
was entered. There would be a second subroutine call that logs the exit time at the bottom of the function. 469 
The frame pointer: argu­
ments and automatic 
variables. 
Accessing subroutine ar­
guments. 
470 
Accessing local auto­
matic variables. 
Stack frame advantages: 
size, 
recursion. Code Generation -Chapter 6 
W(fp+l6) 
The arguments are put onto the stack with push directives, and since an int is word 
sized, the high half of the 32-bit stack item is undefined. The actual, symbolic names of 
the argument do not appear in the output. All generated code that references wild uses 
W ( fp+ 16) instead of the symbolic name, wild. 
Figure 6.5. The Stack Frame, Magnified 
physical 
address: 
100-103 
104-107 
108-111 
112-115 116-119 
120-123 
124-127 john_ silver 
103 102 101 100 
buck thornton 
107 106 105 104 
old frame pointer 
Ill 110 109 108 
return address 
115 114 113 112 
undefined of 
119 118 117 116 
undefined the 
123 122 121 120 
undefined wild 
127 126 125 124 
3 I 2 1 I 0 
msb lsb <---
t <---
<E----
<---
<---
<---Access syntax: 
hornton: 
buck: L (fp-8) 
W(fp-4) 
W(fp-2) 
fp (jp holds the address 108) 
W (fp+B) 
W(fp+12) 
w (fp+l6) 
The local-variable region differs from the arguments in that the compiler treats a 
block of memory on the stack as a region of normal memory, and packs the local vari­
ables into that space as best it can. Again, the indirect modes are the best way to access 
these variables. For example, buck can be accessed using W ( fp-2). (buck is at physi­
cal addresses 106 and 107, and the frame pointer holds physical address I 08, so the byte 
offset from one to the other is -2.) TheW ( fp-2) directive causes a word-size object to 
be fetched from address I 06. The low byte of buck can be accessed directly with 
B (fp-2) and the high byte with B (fp-1). Similarly, john_silver can be accessed 
with L ( fp-8) . (Remember that the object's address is the physical address of the 
least-significant byte, so the offset is -8 here.) A pointer-to-word variable can be fetched 
with WP ( fp-N) . The object to which it points can be fetched with *WP ( fp-N) . 
This use of the stack has two real advantages. First, the same relatively small area of 
memory (the stack) can be recycled from subroutine to subroutine, so less of the total 
memory area need be allocated for variables. Second, this organization makes recursive 
subroutines possible because each recursive instance of a subroutine has its own stack 
frame with its own set of local variables, and these variables are accessed relative to the 
current frame pointer. A recursive subroutine does not know that it's calling itself; it 
does the same thing for a recursive call that it would do for a nonrecursive call: push the 
arguments and transfer control to the top of the required subroutine. The called routine 
doesn't know that it has been called recursively, it just sets up the stack frame in the nor­
mal way. It doesn't matter if more than one stack frame for a given subroutine exists at 
once--only the top one is active. 
Also note that the address of the leftmost argument is always ( fp+B), regardless of 
the number of arguments or their type. This is one of the things that makes it possible to 
have a variable number of arguments in a C subroutine-you can always find the left­
most one. 
Section 6.2.9-Stack Frames: Subroutine Arguments and Automatic Variables 471 
The stack frame's organization has disadvantages, too. The problem is that the code Stack frame disadvan­
that pushes the arguments is generated by the compiler when it processes the subroutine tages: phase errors. 
call, b~t the offsets are figured when the compiler processes the subroutine declaration. 
Since the call and declaration can be in different files, there's no way that the compiler 
can check for consistency unless you use a function prototype in a common header file. 
If you don't use the prototype, a particularly nasty bug, called a phase error, can appear 
at run time. Figure 6.6 shows the stack frames created, both by the earlier 
call(of,the,wild) and an incorrect call(), with no arguments. When the 
call() subroutine modifies wild, it just modifies the memory location at fp+4, and on 
the incorrect stack, ends up modifying the return address of the calling function. This 
means that call () could work correctly, as could the calling function, but the program 
would blow up when the calling function returned. 
Figure 6.6. A Phase Error 
call(of,the,wild) 
~ sp 
temporary 
variables fp-12 ------------
y: fp-8 ---- - ------ -
x: fp-4 ------------
old frame pointer ~ fp ------------
return address fp+4 y: ------------call() 
temporary 
variables ~sp 
fp-12 
fp-8 
of: fp+8 x: fp-4 
the fp+12 
wild 
r---------------~ 
old frame pointer 
return address fp+16 
r 
stack frame of 
calling function 
l ------------
old frame pointer ~ fp 
return address 
old frame pointer 
return address fp+4 
fp+8 
fp+12 
fp+16 
The sequence of instructions that set up a stack frame are so common that C-code 
provides two instructions for this purpose. The link ( N ) instruction does the follow­
ing: 
push ( fp ) ; 
fp sp; 
sp -= N x stack_ width; /* Decrement by one stack element. */ 
and an unlink ( ) directive does the following: 
sp = fp; 
fp =pop( ptr ); 
The earlier call (of, the, wild) is modified to use link() and unlink() in 
Listing 6.15. Listing 6.16 shows the link and unlink () implementations in virtual.h. link and unlink instruc­
tions. 
472 Code Generation -Chapter 6 
Listing 6.15. call (of, the, wild): Compiler Output with link() and unlink() 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 SEG( bss ) 
int _of; 
int _the; 
int _wild; 
SEG (text ) 
PROC (_call) 
link( 2 ); 
unlink(); 
ret(); 
ENDP (_call) 
PROC (_spitz) 
link ( 0 ) ; 
push ( wild ) ; 
push( the ); 
push ( of ) ; 
call( call); 
unlink(); 
ret(); 
ENDP ( spitz) /* Create stack frame, 2 stack elements for locals. */ 
/* No local variables so argument is zero. 
/*call( of, the, wild); *I 
*I 
Listing 6.16. virtual.h- Subroutine Linkage Directives 
61 #definelink(n) ((--__ sp)->pp= (char*) fp), fp= __ sp), ( __ sp (n)) 
62 
63 #define unlink() sp = (reg *) fp) fp (reg *) ( ( sp++) ->pp)) 
Dynamic, static links. The stack frames can also be viewed as a linked list of data structures, each 
representing an active subroutine. It's possible (in an object-oriented programming 
environment, for example) for these structures to be allocated from discontinuous 
memory rather than from a stack. The frame pointer is sometimes called the dynamic 
link because it links together activation records. 9 
6.2.1 0 Subroutine Return Values 
A function's return values should be placed into a register, according to Table 6.7. 
9. Some languages require a second pointer, called the static link, discussed in Appendix B. 
Section 6.2.10-Subroutine Return Values 
Table 6.7. Return Values: Register Usage 
Type Returned in: 
char rF.w.low (A char is always promoted to int.) 
int rF .w.low 
long rF.l 
pointer rF.pp 
6.2.11 Operators 
A very limited set of operators are supported in C-code. The following arithmetic 
operators (only) are available: Arithmetic operators. 
+= *= /= %= &= I= <<= >>= lrs(x,n) 
The ones that look like C operators work just like the equivalent C operators. >>=is an 
arithmetic right shift (sign extension is assumed). Three special operators are supported. 
The=-operator performs a two's complement operation, as in x =-c. The=-operator 
does a one's complement, as in x =-c. Both of these instructions are perfectly legitimate 
C. I'm assuming that the lexical analyzer breaks the foregoing into: 
x = -c ; 
X = C ; 
Lint might print an "obsolete syntax" error message, though. You need binary operators 
here, because C-code is attempting to mimic real assembly language, and though most 
machines support a unary "negate" operator such as the 8086 NEG AX, which does a 
two's-complement negation of the AX register, you can't implement this operator without 
an equal sign in C. It seemed better to use a syntax consistent with the other operators 
than to bury the operation in an macro. 
One additional operation is supported by means of a macro. A lrs (x, n) directive 
does a logical right shift rather than an arithmetic shift (>>=). It shifts x, n bits to the 
right, with zero fill in the high bits rather than sign extension. This directive is defined in 
virtual.h in Listing 6.17. 
Listing 6.17. virtual.h- The Logical-Right-Shift Directive 
64 #define lrs (x, n) ( (x) = ((unsigned long) (x) » (n))) 
All C-code expressions must contain exactly two operands and one operator. They 
must be semicolon terminated. Only one expression is permitted on a line, and the entire 
expression must be on a single line. 
6.2.12 Type Conversions 
No automatic type conversions are supported in C-code. Both operands in an expres­
sion must be of the same type, but if one of the operands is an explicit (immediate-mode) 
number, it is automatically converted to the type of the other operand. 10 
10. Note that, because of this restriction, most real assembly languages attach the type to the operator rather 
than the operand. You would move a 32-bit long word in 68000 assembler with a MOV. L dl, dO 
instruction. InC-code you'd use rl.l = rO .1 to do the same thing. 473 
474 
Sign extension. Code Generation -Chapter 6 
Cast operators may not be used to do type conversion, but sign extension can be per­
formed using one of the following directives: 
ext _low (reg) 
ext_high(reg) 
ext_word(reg) Duplicate high bit of reg. b. bO in all bits of reg. b. bl 
Duplicate high bit of reg. b. b2 in all bits of reg. b. b3 
Duplicate high bit of reg. w. low in all bits of reg. w. high 
An ext _low (reg) directive fills reg. b. bl with ones if the sign bit in reg. b. bO is 
set, otherwise it's filled with zeros. These directives only work in a register, so given 
input like this: 
int archy; 
long mehitabel; 
mehitabel = archy + 1; 
the compiler should output something like the following: 
public word _archy; 
public lword _mehitabel; 
rO.w.low = archy /* 
rO.w.low += 1 ; /* 
ext_word( rO ) ; /* 
mehitabel = rO.l /* Get archy. 
Add 1 to it. 
Convert to long. 
Do the assignment. *I 
*I 
*I 
*I 
The ext_ word ( ) directive effectively converts the word into an lword. If archy 
were unsigned, a rO.w.high=O would be used instead of ext_word(rO). The 
definitions of the sign-extension directives are in Listing 6.18. 
Listing 6.18. virtual.h- Sign-Extension Directives 
65 #define ext low(reg) 
66 #define ext_high(reg) 
67 #define ext_word(reg) (reg. w .low 
(reg.w.high 
(reg .l (word )reg.b.bO 
(word )reg.b.b2 
(lword)reg.w.low 
Labels and the qoto. 
Test directives. 6.2.13 Labels and Control Flow 
Labels in C-code are like normal C labels. They are defined as a name followed by a 
colon: 
label: 
The only control-flow statement is the goto branch, which is used in the normal way: 
goto label; 
The target of the goto branch must be in the same subroutine as the goto itself. 
Conditional flow of control is performed using one of the test directives summarized 
in Table 6.8. These all compare two operands, and the instruction on the line following 
the test is executed only if the test evaluates true, otherwise the instruction on the next 
line is ignored. The following code executes the goto branch if all is equal to 
things (all things being equal). 
go: EQ ( all, things 
goto jail; 
/* collect $200 */ 
jail: 
All the addressing modes described earlier can be used in a test. The normal 
Section 6.2.13-Labels and Control Flow 
comparisons assume signed numbers, but the u _ LT ( ) , U _ LE ( ) , U _ GT ( ) , and 
U _ GE ( ) directives compare the two numbers as unsigned quantities. The instruction 
following the test may not be another test. The test directives are implemented with the 
macros in Listing 6.19. 
Table 6.8. C-code Test Directives 
Directive: Execute following line if: 
EQ( a, b ) a=b 
NE( a, b ) a:;t:b 
LT( a, b ) a<b 
LE ( a, b ) a$b 
GT( a, b ) a>b 
GE( a, b ) a~b 
U_LT( a, b ) a<b (unsigned comparison) 
U_LE( a, b ) a$b (unsigned comparison) 
U_GT( a, b ) a>b (unsigned comparison) 
U GE ( a, b ) a~b (unsigned comparison) 
BIT( b, ) bit b of s (bit 0 is the low bit). s is set to I 
Listing 6.19. virtual.h- Comparison Directives 
68 #define EQ(a,b) if( (long) (a) --(long) (b) ) 
69 #define NE(a,b) if( (long) (a) != (long) (b) ) 
70 #define LT(a,b) if( (long) (a) < (long) (b) ) 
71 #define LE(a,b) if( (long) (a) <= (long) (b) ) 
72 #define GT(a,b) if( (long) (a) > (long) (b) ) 
73 #define GE(a,b) if( (long) (a) >= (long) (b) ) 
74 
75 #define U_LT(a,b) if( (unsigned long) (a) < (unsigned long) (b) 
76 #define U_GT(a,b) if( (unsigned long) (a) > (unsigned long) (b) 
77 #define U_LE(a,b) if( (unsigned long) (a) <= (unsigned long) (b) 
78 #define U_GE(a,b) if( (unsigned long) (a) >= (unsigned long) (b) 
79 
80 #define BIT(b,s) if( (s) & (1 << (b)) ) 
6.2.14 Macros and Constant Expressions 
Various C-preprocessor macros, summarized in Table 6.9, may be used in a C-code 
file. C-style, parameterized macros are supported, but the ANSI defined( ) pseudo op, the 
concatenation operator(##), and the "stringizing" operator (#name) are not supported. 
Arithmetic expressions that involve nothing but constants and the following operators 
can appear in an #if directive and anywhere that a constant would appear in an 
operand: 
+ * I % & && II != < > <= >= 
The -is both unary and binary minus. The * is multiplication. Multiple-operator 
expressions such as the following are legal: 
#define Ll (-24) 
WP(fp-4) = WP(fp-Ll-6); /* The Ll-6 is a constant expression. */ 475 
) 
) 
) 
) 
476 
Can't issue SEG < l 
between PROC < ) and 
ENDP (). 
Translate _main () to 
main(). 
Print virtual-machine 
state, pm () • Code Generation -Chapter 6 
Table 6.9. C-code Preprocessor Directives 
#line line-number "file" 
#define NAME text 
#define NAME (args) text 
#undef NAME 
#ifdef NAME 
#if constant expression 
#endif 
#else 
#include <file> 
#include "file" 
Note that the constant expression must completely precede or follow a variable or regis­
ter reference in an operand. For example, the following is not permitted because the 
register reference (fp) is imbedded in the middle of the expression: 
WP(fp-4) = WP(6 + fp + 10); 
6.2.15 File Organization 
All variable and macro declarations must precede their use. Forward references are 
permitted with goto branches, however. 
C-code files should, ideally, take the following form: 
#include <tools/virtual.h> 
SEG ( data ) 
initialized data declarations 
SEG ( bss ) 
uninitialized data declarations 
SEG( text ) 
subroutines 
You can switch back and forth between the data and bss segments as much as you like, 
but you can't change segments in the middle of a subroutine definition bounded by a 
PROC () and ENDP () directive. extern declarations should be placed in the bss seg­
ment. Macro definitions can go anywhere in the file. 
6.2.16 Miscellany 
One other handy macro is in virtual.h. Since the point of C-code is to create a 
language that can be assembled with your C compiler rather than a real assembler, it's 
desirable to be able for a main () function in the source to really be main (). Unfor­
tunately, the compiler puts a leading underscore in front of main when it outputs the 
PROC directive. The_ main () macro on line 81 of Listing 6.20 takes care of this prob­
lem. 
The last part of virtual.h (on lines 84 to 118 of Listing 6.20) is an actual function, 
created only if ALLOC is defined. pm ( ) prints the top few stack elements and the con­
tents of the virtual-machine registers to standard output as follows: 
Section 6.2.16- Miscellany 
Listing 6.20. virtual.h- Run-time Trace Support 
#define main main 
#ifdef ALLOC 
pm() 
{ 
reg *p; 
int i; 81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 /* Print the virtual machine (registers and top 16 stack elements). *I 
printf("rO= %08lx rl= %08lx r2= %08lx 
rO.l 1 rl.l 1 r2.1 1 
printf("r4= %08lx r5= %08lx r6= %08lx 
r4.1 1 r5.1 1 r6.1 1 
printf("r8= %08lx r9= %08lx rA= %08lx 
r8.1 1 r9.1 1 rA.l 1 
printf ("rC= %08lx rD= %08lx rE= %08lx 
rC.l 1 rD.l 1 rE.l 1 
if( sp >= &stack[SDEPTH] 
printf("Stack is empty\n"); 
else r3= %08lx\n" 1 
r3.1 
r7= %08lx\n" 1 
r7.1 
rB= %08lx\n" 1 
rB.l 
rF= %08lx\n" 1 
rF.l 
printf("\nitem byte real addr b3 b2 bl bO hi 
for( p = __ sp1 i=l6; p < &stack[SDEPTH] && --i>=O; ++p 
{ ) ; 
) ; 
) ; 
) ; 
lo 477 
1\n"); 100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 printf("%04d %04d %9p 
p-__ spl [ %02x I %02x I %02x I %02x] = [ %04x I %04x] = [ %08lx] "I 
} 
#endif ) ; p->b. b3 & Oxff 1 
p->w.high & Oxffff 1 
p->1 (p-__ sp) *41 (void far *)p 1 
p->b.b2 & Oxff 1 p->b.bl & Oxff 1 p->b.bO & Oxffl 
p->w.low & Oxffff 1 
if( p == __ sp 
if( p == fp 
printf("\n"); printf("<-SP"); 
printf("<-FP"); 
rO= 00000000 rl= 00000000 r2= 00000000 r3= 00000000 
r4= 00000000 r5= 00000000 r6= 00000000 r7= 00000000 
r8= 00000000 r9= 00000000 rA= 00000000 rB= 00000000 
rC= 00000000 rD= 00000000 rE= 00000000 rF= 00000000 
item byte real addr b3 b2 b1 bO hi lo 1 
0000 0000 2C8F:1878 [00100100100] [000010000] [00000000]<-SP 
0001 0004 2C8F:187C [00100100100] [000010000] [00000000] 
0002 0008 2C8F:1880 [0010011818c] [00001188c] [0000188c]<-FP 
0003 0012 2C8F:1884 [001001041f2] [0000104f2] [000004f2] 
0004 0016 2C8F:1888 [ablcdlefl12] [abed I ef12] [abcdef12] 
0005 0020 2C8F:188C [00100118190] [000011890] [00001890] 
The stack is printed three times, broken up as bytes, words, and lwords. The leftmost, 
item, column is the offset in stack elements from the top of stack to the current element; 
the byte column is the byte offset to the least-significant byte of the stack item; and the 
real addr is the physical address of the stack element (it's in 8086 segment:offset form). 
478 
C-code labels are 
different from assembly 
language. 
Jump tables can't be im­
plemented in C-code. 
Subroutine prefix, body, 
and suffix. 
The symbol table. Code Generation -Chapter 6 
The position of the sp and fp register is indicated at the far right. pm ( ) is used in the 
compiler to print a run-time trace as the output code executes. The compiler described 
below can be put in a mode where most instructions are output like this: 
rO.l = rl.l; printf("rO.l = rl.l;\n"); pm(); 
so you can what the virtual machine is doing as the code executes. 
6.2.17 Caveats 
C-code is similar enough to assembly language that it's easy to forget it's really C, 
and make mistakes accordingly. The biggest problem is labels. Most assembly langua­
ges treat all labels the same, regardless of what they are used for: a label always evalu­
ates to an address, and any label can be used in any instruction. C-code is different, how­
ever: Array names evaluate to addresses, most other labels evaluate to the contents of a 
variable, but labels that are followed by colons can only be used as targets of goto 
branches. These restrictions make C-code a little more difficult to write than real assem­
bler. They also make some common assembly-language data structures impossible to 
implement. For example, most assemblers let you code a switch statement as follows: 
SEG( data ) 
switch table: dw Ll /* Array of four labels. */ 
dw L2 
dw L3 
dw L4 
SEG( text ) 
tO = /* evaluated argument to switc~ */ 
goto switch_table[ tO ] 
Ll: code .. . 
L2: code .. . 
L3: code .. . 
L4: code .. . 
This data structure, called a jump table, is not legal C-code-you can't have an array of 
labels and you can't use a variable as an argument to a goto. 
6.3 The Symbol Table 
Like Gaul, most computer languages can be divided into three parts: declarations, 
expressions, and statements. Looking back at Table 6.2 on page 451, the output code is 
divided into three logical sections. Each section is generated from a separate part of the 
input file, and the code generation for each of these parts is controlled by distinct parts of 
the grammar. Every subroutine has a prefix portion that's generated when the declara­
tions and argument list are processed. The body of the subroutine, which contains state­
ments and expressions, comes next. Finally, code to clean up and return from a subrou­
tine is generated at the end of the definition. This last section is called the suffix. I'll 
start by looking at the first of these sections, the subroutine-prefix and declaration pro­
cessing. 
6.3.1 Symbol-Table Requirements 
We need to examine the data structures that are used to process a declaration before 
looking at the actual code-generation actions. A compiler's declaration system centers 
around a set of data structures collectively called the symbol table. Strictly speaking, the 
Section 6.3.1-Symbol-Table Requirements 
symbol table is a database that contains infonnation about subroutines, variables, and so 
forth. The database is indexed by a key field-here a subroutine or variable's name­
and each record (each entry in the database) contains infonnation about that item such as 
the variable's type or subroutine's return value. A record is added to the database by the 
code that processes declarations, and it is deleted from the database when the scoping 
rules of the language detennine that the object can no longer be referenced. C local vari­
abies, for example, are deleted when the compiler finishes the block in which they are 
declared. 
Symbol tables are used for other purposes as well. Type definitions and constant 
declarations may be found in them, for example. The symbol table can also be used to 
communicate with the lexical analyzer. In the current compiler, a typedef creates a 
symbol-table entry for the new type, as if the type name were a variable name. A bit is 
set in the record to indicate that this is a typedef, however. The lexical analyzer then 
uses the symbol table to distinguish identifiers from type names. This approach has its 
drawbacks (discussed below), but can be quite useful. 
Even though a symbol table is a database, it has special needs that must be met in 
specific ways. A symbol-table manager must have the following characteristics: 
• Speed. Because the symbol table must be accessed every time an identifier or type is 
referenced, look-up time must be as fast as possible. Consequently, disk-based data­
management systems are not appropriate here. The entire table should be in 
memory. On the down side, one of the main limitations on input-file size is often the 
maximum memory available for the symbol table. 
• Ease of maintenance. The symbol table is probably the most complex data structure 
in the compiler. Its support functions must be organized so that someone other than 
the compiler writer can maintain them. 
• Flexibility. A language like C does not limit the complexity of a variable declara­
tion, so the symbol table must be able to represent variables of arbitrary type. This 
representation should be optimized for code-generation purposes. Similarly, the 
symbol table should be able to grow as symbols are added to it. 
• Duplicate entries must be supported. Most programming languages allow a variable 
at an inner nesting level to have the same name as a variable at an outer nesting 
level. These are different variables, in spite of having the same name, and the scop­
ing rules of the language detennine which of these variables are active at a given 
moment. The active variable is said to shadow the inactive one. A distinct symbol 
table entry is required for each variable, and the database manager must be able to 
handle this situation. 
• You must be able to quickly delete arbitrary elements and groups of elements from 
the table. For example, you should be able to delete all the local variables associated 
with a particular block level in an efficient manner, without having to look up each 
element separately. 
The symbol table used here is organized in two layers. I'll call the innennost of 
these the database layer. This layer takes care of physical table maintenance: inserting 
new entries in the table, finding them, deleting them, and so forth. I'll call the outer 
layer the maintenance layer-it manages the table at a higher level, creating systems of 
data structures to represent specific symbols and inserting these structures into the table 
using the low-level insert function. Other subroutines at the maintenance level delete 
entire classes of symbols (variables declared at the same block level, for example), 
traverse all variables of a single class, and so forth. 479 
Key, record. 
Desirable symbol-table 
characteristics. 
Shadowing. 
Layers 
Database layer. 
Maintenance layer. 
480 
Stack-based symbol 
tables. 
Stack disadvantages. 
Tree-based symbol 
tables. 
Tree deletions. Code Generation -Chapter 6 
6.3.2 Symbol-Table Data-Base Data Structures 
Several data structures can be used for the database layer of the symbol table, each 
appropriate in specific situations. The simplest possible structure is a linear array organ­
ized as a stack. New symbols are added to the end of the array with a push operation and 
the array is searched from top to bottom of stack. (The most recently added item is 
examined first.) This method, though crude, is quite workable provided that the table is 
small enough. The scope rules are handled by the back-to-front searching. Since vari­
ables declared at an inner nesting level are added to the table after those declared at a 
higher level, they are always found first. The database manager is trivial to implement. 
One real advantage to a stack-based symbol table is that it's very easy to delete a 
block of declarations. Variable declarations are done in waves according to the current 
scoping level. For example, given input like this: 
int laurel, hardy; 
{ 
int larry, curly, moe; 
int house_of_representatives[ 435 ]; 
laurel and hardy are inserted first as a block, then larry, curly, and moe are 
inserted, and then the house_of_representatives is inserted. The symbol-table 
stack looks like this when the innermost block is processed: 
stack pointer house_of_repres~~t~t!v~~. 
moe 
curly 
larry ______ _ 
hardy 
laurel leve13 
t 
leve12 
w 
level I 
All variables associated with a block can be deleted at one time by adding a constant to 
the stack pointer. 
The stack approach does have disadvantages other than the obvious one of the 
inefficient linear search required to find entries close to the beginning of the table. (This 
is not an insignificant problem-the compiler spends more time searching for symbol­
table references than any other symbol-table operation. The time required for a linear 
search will be prohibitive if the table is large enough.) The maximum size of the stack­
based table must be known at compile time, so the symbol table can't scale its size 
dynamically to fit the needs of the current input file. Consequently, the number of vari­
ables that can be handled by the system is limited. You have to allocate a worst-case 
table size to make sure that there is enough room. 
The search-time and limited-size problems can be solved, to some extent, by using a 
binary tree as the basic data structure. Average search times in a balanced binary tree 
are logarithmic, and the tree size can grow dynamically as necessary. 
Deletion of an arbitrary node from a tree is difficult, but fortunately this is not an 
issue with most symbol-tables applications, because nodes for a given level are inserted 
into the tree as a block, and newer levels are deleted before the older ones. The most­
recently inserted nodes tend to form leaves in the tree. If a variable at the most recent 
level is an interior node, then all its children will have been declared either at the same 
Section 6.3.2-Symbol-Table Data-Base Data Structures 
nesting level or in an inner block. The most recently added block of variables is always 
at the end of a branch, and all variables in that block can be removed by breaking the 
links to them without having to rearrange the tree. For example, a tree for the earlier 
code fragment is pictured in Figure 6.7. The dotted lines show the scoping levels. The 
house_of_representatives is deleted first by breaking a single link; larry, 
curly, and moe are deleted next, again by breaking single links; laurel and hardy 
are deleted by breaking the single link that points at laurel. 
Figure 6.7. Symbol-Table Trees: Deletion 
~----------- ------, 
/ 
/ 4.---------
house_of_representatives 
Binary trees do have disadvantages. First, it is a common practice for programmers Tree disadvantages. 
to declare variables in alphabetical order. Since variables are added to the tree in the 
same order as the declarations, a simple binary tree degrades to a linked list in this situa-
tion, and the search times are linear rather than logarithmic. This problem can be solved 
at the cost of greater insert and delete times by using a height-balanced tree system such 
as an A VL tree, 11 but the shuffling around of nodes that's implicit in the rebalancing can 
destroy the ordering that made deletions easy to do. The other disadvantage of a tree-
based symbol table is that collisions, situations where the same name is used for vari- Collisions. 
abies at different scope levels, are difficult to resolve. This problem, too, can be solved at 
the expense of lookup time. For example, you could have two key fields in the data 
structure used to represent a tree node, one for the name and one for the nesting level: 
typedaf struct tree node 
{ 
char name[ 
int level; 32 
struct tree node 
struct tree node 
INFO TYPE *right; 
*left; 
info; 
tree_node; l ; /* Variable name. 
/* Nesting level. 
/* Right-child pointer. 
/* Left-child pointer. 
/* Other Information. 
and then use both fields when comparing two nodes: *I 
*I 
*I 
*I 
*I 
II. See: [Kruse] pp. 357-371 and [Tenenbaum] pp. 461-472 for a general discussion of AVL trees. [Holub I] 
contains a C implementation of an AVL-tree database manager. 481 
482 Code Generation -Chapter 6 
Hashed symbol tables. compare( nodel, node2 ) 
struct tree_node *nodel, *node2; 
{ 
if( nodel->level != node2->level 
return( nodel->level- node2->level ); 
else 
return( strcmp(nodel->name, node2->name) ); 
You could also solve the collision problem by adding an additional field to the tree 
node-a pointer to the head of a linked list of conflicting nodes. Newly added entries 
would be put at the head of the list, and so would be found first when the list was 
searched. The system is pictured in Figure 6.8; it uses the following data structure: 
typedef struct tree node 
{ 
char name[32]; 
struct tree node *right; /* 
struct tree node *left; /* 
struct tree node *conflicts; /* 
INFO TYPE info; /* 
tree_node; Right-child pointer. 
Left-child pointer. 
Conflicting-name-list 
Other information. *I 
*I 
head. *I 
*I 
Figure 6.8. Using a Linked List to Resolve Collisions in a Tree-Based Table 
Degas 
' ' Lautrec • -> 
There is one final problem with a tree-based symbol table. The use of global vari­
ables is discouraged by most proponents of structured-programming because it's difficult 
to determine how global variables change value. As a consequence, a well-structured 
program accesses local variables more often than global ones. The local variables are 
added to the symbol table last, however, and these nodes tend to be farther away from 
the root in a tree-based table, so it takes longer to find them. 
It turns out that the the best data structure for most symbol-table applications is a 
hash table. An ideal hash table is an array that is indexed directly by the key field of the 
object in the table. For example, if the key field is a string made up of letters, digits, and 
underscores, the string could be treated as a base 63 number (26 lower-case letters + 26 
upper-case letters + 10 digits +an underscore = 63 possible characters). Unfortunately, 
an array that could be indexed directly by a 16-character name would require 6316-1 or 
roughly 60,000,000,000,000,000,000,000,000,000 elements, most of which would be 
wasted because an average symbol table has only a few hundred objects in it. 
Section 6.3.2-Symbol-Table Data-Base Data Structures 
The solution to this problem is to compress the array. A hash table is an array, 
indexed by key, that is compressed so that several elements of the uncompressed array 
can be found at a single location in the compressed array. To do this, you convert the 
key field that's used as the index in the uncompressed array into a pseudo-random 
number which is used as an index into the compressed array. This randomization pro­
cess is called hashing and the number so generated is the key's hash value. The same 
key should always hash to the same pseudo-random number, but very similar keys 
should have very diffurent hash values. 
Collisions (situations where two keys hash to the same value) are resolved by making 
each array element the head of a linked list of table elements. 12 This method is appropri­
ate in a symbol-table application because, if you always put the new node at the head of 
a chain rather than the end, local variables automatically preempt global variables with 
the same name-they'll be found first when the list is searched. They are also found 
more quickly than they would be if stored in a binary tree. 
A simple hash table of size three is pictured in Figure 6.9. The table has four 
members, with the keys "a", "b", "c", and "d". The hash values are computed by 
treating the name strings as numbers. An ASCII ' a' has the decimal value 97, ' b' is 
98, and so on. These numbers are truncated down to an array index using a modulus 
division by the table size (3 in this case): 
name numeric value value MOD table size 
"a" 97 1 
"b" 98 2 
"c'' 99 0 
''d" 100 1 
Figure 6.9. A Simple Hash Table 
A simple hash function could just add together the characters in the name as if they 
were numbers, and then truncate the resulting sum to a valid array index with a modulus 
operation. An better function is hashpjw, shown in Listing 6.11.13 Hashpjw uses an 
exclusive-or and shift strategy to randomize the hash value. 
There has probably been more waste paper devoted to the subject of hash algorithms 
than any other topic in Computer Science. In general, the complex algorithms so 
described give very good theoretical results, but are so slow as to be impractical in a real 
application. An ideal hash function generates a minimum number of collisions, and the 
12. The collision-resolution method used here is called "open" hashing. There are other ways of resolving 
collisions that won't be discussed because they are not much use in most practical applications. See 
[Tenenbaum] pp. 521-574 and [Kruse] pp. 112-135. 
13. Hashpjw was developed by P.J. Weinberger and is described in [Aho], p. 436. The version in Listing 6.21 
is optimized somewhat from the one in [Aho] and is tailored to a 16-bit int. There's a more general 
purpose version of the same function in Appendix A. Hash tables. 
Hashing and hash 
values. 
Collision resolution. 483 
Two hash functions: addi­
tion and 
hashpjw. 
An informal complexity 
analysis of addition and 
hashpjw. 
484 Code Generation -Chapter 6 
Listing 6.21. hashpjw.c- A 16-bit hashpjw Implementation 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 unsigned hash_pjw( name 
unsigned char *name; 
{ 
unsigned hash_val 0; 
unsigned i; 
for(; *name ; ++name ) 
{ 
hash_val = (hash_val << 2) + *name ; 
if( i = hash_val & Ox3fff ) 
hash val (hash_val- (i >> 12)) & -ox3fff 
return hash_val; 
average search time (which is proportional to the mean chain length) should be roughly 
the same as an equivalent data structure such as a binary tree-it should be logarithmic. 
The maximum path length in a perfectly balanced tree with N elements is log2 N. A tree 
with 255 elements has a maximum chain length of 8 and an average chain length of 
roughly 7 [(128x8 + 64x7 + 32x6 + ... + 2x1)/255]. You're okay as long as you can get a 
comparable average chain length in a hash table. 
It's difficult to predict chain lengths from a given algorithm because the words found 
in the input control these lengths. An empirical analysis is quite workable, however, 
given a large enough data set. Table 6.10 shows the behavior of the hash_ add ( ) and 
hash_pjw () functions from Appendix A. The former just adds together the characters 
in the name; the latter is in Listing 6.21. 917 unique variable names gleaned from real C 
programs were used for the test input, and the table is 127 elements long. 
The elapsed time is the amount of time used to run the test program. Since the only 
change was the choice of hash function, this number gives us a good indication of 
efficiency. You'll note that hash _pjw () is about 9% slower than hash _add (). The 
mean chain length for both algorithms is identical, and both algorithms use shorter aver­
age chain lengths than a binary tree of an equivalent size. Finally, the distribution of 
chain lengths is actually a little better with hash_add() than with hash_pjw( )­
there are more shorter chains generated by hash_ add ( ) . 
Addition as a hash func­
tion: advantages, disad­
vantages. Weighing the foregoing, it seems as if simple addition is the preferable of the two 
algorithms because it yields somewhat shorter chains, executes marginally faster, and is 
smaller. Addition has two significant disadvantages, the main one being that characters 
are small numbers, so the hash values tend to pile up at one end of a large table. One of 
the reasons that addition performed well in the current example is the relatively small 
table size. hash _P jw ( ) solves the bunching problem with the left shift on line nine of 
Listing 6.21, making it more appropriate for larger tables. Also, addition can't distin­
guish between identi tiers that are permutations of the same name and hashpjw can, so the 
latter is a better choice if this situation comes up. Aho, using names gleaned from Pascal 
programs rather than C programs and a larger table size, got better results from hashpjw 
than I did. 
Hash tables are almost ideal data structures for use in a symbol table. They are as 
efficient (if not more so) than binary trees, and are more appropriate for those applica­
tions in which several elements of the table might have the same key, as is the case when 
local and global variables share the same name. 
Section 6.3.2-Symbol-Table Data-Base Data Structures 
Table 6.10. Performance of Two Hash Functions 
Addition Hashpjw 
Elapsed time 9.06 seconds Elapsed time 9.61 seconds 
Mean chain length: 7.22047 Mean chain length: 7.22047 
Standard deviation: 2.37062 Standard deviation: 2.54901 
Maximum chain length; 14 Maximum chain length: 13 
Minimum chain length: 2 Minimum chain length: I 
0 chains of length 1 I chain of length I 
1 chains of length 2 3 chains of length 2 
8 chains of length 3 9 chains of length 3 
7 chains of length 4 8 chains of length 4 
18 chains of length 5 12 chains of length 5 
13 chains of length 6 15 chains of length 6 
22 chains of length 7 21 chains of length 7 
22 chains of length 8 15 chains of length 8 
16 chains of length 9 15 chains of length 9 
8 chains of length 10 15 chains of length 10 
7 chains of length 11 10 chains of length 11 
2 chains of length 12 0 chains of length 12 
2 chains of length 13 3 chains of length 13 
1 chain of length 14 0 chains of length 14 
6.3.3 Implementing the Symbol Table 
I will use the hash functions described in Appendix A for the database layer of our 
symbol table. To summarize the appendix, the hash-table system described in Appendix 
A uses two data structures: the hash table itself is an array of pointers to "buckets", each 
bucket being a single data-base record. The buckets are organized as a linked list. When 
two keys hash to the same value, the conflicting node is inserted at the beginning of the 
list. This list of buckets is doubly linked-each bucket contains a pointer to both its 
predecessor and successor in the list. Arbitrary nodes can then be deleted from the mid­
dle of a chain without having to traverse the entire chain. You should review these func­
tions now. 
The basic hash functions are fine for simple symbol-table applications. They were 
used to good effect in occs and LLama, for example. Most programming languages 
require a little more complexity, however. First of all, many internal operations require 
the compiler to treat all variables declared at a common nesting level as a single block. 
For example, local variables in C can be declared at the beginning of any curly-brace Block deletions. 
delimited compound statement. A function body is not a special case, it's treated identi-
cally to a compound statement attached to a while statement, for example. The scope 
of any local variable is defined by the limits of the compound statement. For all practi-
cal purposes, a variable ceases to exist when the close curly-brace that ends that block in 
which it is declared is processed. The variable should be removed from the symbol table 
at that time. (Don't confuse compile and run time here. A static local variable con-
tinues to exist at run time, but it can be deleted from the symbol table because it can't be 
accessed at compile time once it is out of scope.) 
The compiler also has to be able to traverse the list of local variables in the order that 
they were declared. For example, when the compiler is setting up the stack frame, it has 
to traverse the list of arguments in the proper order to determine the correct offsets from 
the frame pointer. Both of those situations can be handled by providing a set of cross 485 
486 
Cross links. 
symbol structure. 
symbol. name, 
symbol.rname 
Conflicting local-static 
names. 
symbol.level 
symbol.duplicate Code Generation -Chapter 6 
links that connect all variables at a particular nesting level. For example, there are three 
nesting levels in the following fragment: 
int Godot; 
waiting( vladimir, estragon ) 
{ 
int pozzo ; 
while( condition 
{ 
int pozzo, lucky; 
Godot and waiting are at the outer level, the subroutine arguments and the first pozzo 
comprise the second block, and the third block has the second pozzo in it. Note that the 
arguments are grouped with the outer local variables and that the inner pozzo shadows 
the outer one while the inner block is active-the two pozzos are different variables, 
occupying different parts of the stack frame. Figure 6.10 shows how the symbol table 
looks when the innermost block is being processed. I'm assuming that vladimir 
hashes to the same value as pozzo. Note that the subroutine name [waiting()] is con­
sidered part of the outer block, but the arguments are part of the inner block. The hash 
table itself is at the left-the solid arrows are links used to resolve collisions within the 
table. Here, the array across the top holds the heads of the cross-link chains. This array 
could be eliminated by passing the head-of-chain pointers as attributes on the value 
stack, however. You can visit all symbol-table entries for variables at a given scoping 
level by traversing the cross links (the dashed lines). If the head-of-chain array was a 
stack, you could delete the nodes for a particular level by popping the head-of-list 
pointer and traversing the list, deleting nodes. The current C-compiler's symbol table is 
organized with cross links, as just described. A hash-table element is pictured in Figure 
6.10. 
The top two nodes (next and prev) are maintained by the hash-table functions 
described in depth in Appendix A. They point at the previous and next node in the colli­
sion chain. The double indirection lets you delete an arbitrary element from the table 
without having to traverse the collision chain to find the predecessor. The bottom fields 
are managed by the maintenance-layer, symbol-table functions and are declared as the 
symbol structure in Listing 6.22 along with the symbol table itself. 
The name field in the symbol structure is the name as it appears in the input. The 
rname field is the symbol's name as it appears in the output. In the case of a global vari­
able, rname holds the input name with a leading underscore appended. Local static 
variables are given arbitrary names by the compiler because local statics in two subrou­
tines could have the same name. The names would conflict if both were used in the out­
put, so an arbitrary name is used. Compiler-supplied names don't have leading under­
scores so can't conflict with user-supplied names. The rname field for automatic vari­
ables and subroutine arguments is a string, which when used in an operand, evaluates to 
the contents of the variable in question. For example, if an int variable is at offset -8 
from the frame pointer, the rname will be "fp-8 ". 
The level field holds the declaration level for the symbol (0 for global symbols, 1 if 
they're at the outermost block in a function, and so forth). level is used primarily for 
error checking. It helps detect a duplicate declaration. 
The duplicate bit marks the extra symbols created by duplicate declarations like 
the following: 
Section 6.3.3-Implementing the Symbol Table 
Figure 6.10. A Cross-linked Symbol Table 
Cross links 
I ' , ' 
Hash table -v 
Godot •I 
I v 
waiting I J 
I 
/ 
I 
I 
\j' 
pozzo 'I I 
I 
\j' 
J lucky I I 
Figure 6.11. A Symbol-Table Element 
previous node -<E------~ 
in hash table -7-------, 
maintained by 
hash functions 
r prev 
next 
name 
rname 
symbol structure level 
maintained by type 
symbol-table functions etype 
1 args 
next _I 
I 
J 
"I pozzo L .I vladimir I I 
r-,. 
estragon • --------
(cross link) 
from previous variable 
at current level \ 
I 
I 
v 
•I 
----_J_-----E--- next node 
---+------7---- in hash table 
·------
\j' 
to next variable 
at current level to linked list of symbol 
structures, one per argument 487 
488 Code Generation -Chapter 6 
Listing 6.22. symtab.h- The Symbol Table 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 25 
26 
27 
28 
29 
30 
31 
32 /* SYMTAB.H: Symbol-table definitions. Note that <tools/debug.h> and 
* <tools/hash.h> must be #included (in that order) before the 
* #include for the current file. 
*I 
#ifdef ALLOC /* Allocate variables if ALLOC defined. */ 
# define ALLOC CLS /* empty */ 
#else 
# define ALLOC CLS extern 
#endif 
#define NAME MAX 32 
#define LABEL MAX 32 
typedef struct symbol 
{ 
unsigned char name [NAME_MAX+l]; 
unsigned char rname [NAME_MAX+l]; 
unsigned level 13 
unsigned implicit 1 
unsigned duplicate 1 
struct link *type; 
struct link *etype; 
struct symbol *args; 
struct symbol *next; 
symbol; 
ALLOC CLS HASH TAB *Symbol_tab; 
extern int x; 
int x = 5; I* Maximum identifier length. *I 
/* Maximum output -label length. *I 
/* Symbol-table entry. */ 
/* Input variable name. *I 
/* Actual variable name. *I 
/* Declaration lev., field offset.*/ 
/* Declaration created implicitly.*/ 
/* Duplicate declaration. *I 
I* First link in declarator chain.*/ 
/* Last link in declarator chain.*/ 
/* If a funct decl, the arg list. *I 
/* If a var, the initializer. *I 
/* Cross link to next variable at *I 
/* current nesting level. *I 
/* The actual table. *I 
It's convenient not to discard these symbols as soon as the duplication is found. The 
duplicate symbol is not put into the symbol table, however, and this bit lets you deter­
mine that the symbol has not been inserted into the table so you can delete it at a later 
time. 
symbol. implicit The implicit field is used to distinguish undeclared variables from implicit func­
tion declarations created when a subroutine is used before being defined. An implicit 
declaration of type int is created when an undeclared identifier is encountered by the 
compiler. If that identifier is subsequently used in a function call, its type is modified to 
"function returning int" and the implicit bit is cleared. If a symbol is still marked 
implicit when the compiler is done with the current block, then it is an undeclared vari­
able and an appropriate error message is printed. 
symbol. type, 
symbol. etype, 
symbol. args. 
symbol.next The type and etype fields in the symbol structure point to yet another data struc­
ture (discussed shortly) that describes the object's type. args keeps track of function 
arguments until they are added to the symbol table. It is the head of a linked list of sym­
bol structures, one for each argument. 
Finally, the next pointer is the cross link to the next variable at the same nesting 
level. Note that this field points at the symbol component of the combined structure, 
not at the header maintained by the hash functions. 
Section 6.3.3-Implementing the Symbol Table 
6.3.4 Representing Types-Theory 
The next issue is the representation of a variable's type. If a language is simple 
enough, types can be represented with a simple numeric coding in the symbol structure. 
For example, if a language had only two types, integer and floating point, you could 
define two constants like this: 
#define INTEGER 0 
#define FLOAT 1 
and add a field to the symbol structure that would be set to one or the other of these 
values. Pointers could be represented in a similar way, with a second variable keeping 
track of the levels of indirection For example, given a declaration like int * * *p, this 
second variable would hold 3. This sort of typing system is called a constrained system 
because there are only a limited number of possible types. 
The situation is more complex in a language like C, which has an unconstrained typ­
ing system that permits virtually unlimited complexity in a variable declaration. A C 
variable's type must be represented by a system of data structures working in concert. 
You can see what's required by looking at how a C variable declaration is organized. 
Variable declarations have two parts: a specifier part which is a list of various keywords 
(int, lonq, extern, struct, and so forth) and a declarator part that is made up of the 
variable's name and an arbitrary number of stars, array-size specifiers (like [10]) and 
parentheses (used both for grouping and to indicate a function). 
The specifier is constrained-there are only a limited number of legal combinations 
of keywords that can be used here-so it can be represented by a single structure. The 
declarator is not constrained, however-any number of stars, brackets, or parentheses are 
permitted in any combination. Because of this organization, a type can be represented 
using two kinds of structures, one representing the specifier and another representing the 
declarator. The type definition is a linked list of these structures, and the type field in 
the symbol structure that we looked at earlier points at the head of the list (etype 
points at the end). All type representations have exactly one specifier structure, though 
there can be any number of declarators (including none), and it's convenient for the 
specifier to be at the end of the linked list-I'll explain why in a moment. 
Let's look at some examples. A simple declaration of the form 
short Quasimodo; is represented like this: 
symbol specifier 
ntyampee I Quasimodo I 
1 L . •!--+:--~) short int::r'J 
etype ; 
A pointer type, like lonq *Gringoire; adds a declarator structure, like this: 
name 
type 
etype symbol 
Gringoire declarator specifier 
J pointer to I j lonq int ~ 
You read down the list just like you would parse the declaration in English. Gringoire 
is a pointer to a lonq. The symbol node holds the name, the second holds an indicator 
that the variable is a pointer, and the third node holds the lonq. An array of longs 
declared with lonq Coppenole [ 10] ; is represented as follows: Constrained types, 
numeric coding. 
Unconstrained types. 
Specifier. 
Declarator. 489 
Example type represen­
tations. 
490 
Derived types. name 
type 
etype 
name 
type 
etype 
Implementing declara­
tors. 
Implementing Specifiers. 
Nouns. 
Adjectives. name 
type 
etype symbol 
Coppenole Code Generation-Chapter 6 
declarator 
specifier array 
I long int ~ (10 elements) 
A pointer to an array of longs like long (*Frollo) [10]; has a pointer node inserted 
in between the symbol structure and the array declarator, like this: 
declarator symbol declarator specifier Frollo array of 
.I pointer to I .I long int ~ (10 elements) 
/ 
An array of pointers to longs such as long *Esmerelda [ 10] has the "pointer to" and 
"array of" nodes transposed, like this: 
declarator symbol declarator specifier Esmeralda array of 
.I pointer to I I long int ~ (10 elements) 
This system has an important characteristic that will be quite useful for generating 
code. The array-bracket, indirection, and structure-access operators generate temporary 
variables, just like the simple addition and multiplication operators discussed in earlier 
chapters. The types of these temporaries can be derived from the original type represen­
tation, often just by removing the first element in the chain. For example, in the earlier 
array-of-pointers-to-long example, an expression like Esmerelda [ 1] generates a tem­
porary of type "pointer to long" that holds the referenced array element. The 
temporary's type is just the original chain, less the leading "array of" node. The 
address-of operator(&) is handled in much the same way by adding a "pointer to" node 
to the left of the chain. 
6.3.5 Representing Types-Implementation 
The foregoing system of declarators and specifiers can be implemented with a system 
of several structures. A declarator is represented with the structure in Listing 6.23. 
There are two fields: de 1 _type identities the declarator as a pointer, array, or function, 
using the values defined on lines 33 to 35. If the declarator is an array, num _ ele holds 
the number of elements. You'll need this number to increment a pointer to an array 
correctly, and to figure an array's size. 
Specifiers are represented by the structure and macros in Listing 6.24. The situation 
is simplified here because the current C compiler ignores the const and volatile 
keywords. A C specifier consists of a basic type (call it a noun), and various modifiers 
(call them adjectives). C supports several nouns: char, int, float, double, struct, 
union, and enum. Only four of these are necessary in the current compiler, however: 
char, int, void, and struct. You would add float to this list if floating point were 
supported. A double could be treated as a long float. Enumerated types are treated 
as if they were ints. Unions are treated identically to structures-all the offsets to the 
fields are zero, however. An int is implied if a noun is missing from a declaration, as in 
long x. C also supports one implicit identifier that is declared just by using it: a label. 
The LABEL on line 46 takes care of this sort of identifier. The basic nouns are 
Section 6.3.5-Representing Types-Implementation 
Listing 6.23. symtab.h- A Declarator 
33 #define POINTER 0 
34 #define ARRAY 1 
35 #define FUNCTION 2 
36 
37 typedef struct declarator 
38 { 
39 int dcl_type; 
40 int num_ele; 
41 declarator; /* Values for declarator.type. */ 
/* POINTER, ARRAY, or FUNCTION */ 
/* If class==ARRAY, # of elements */ 
represented by the noun field on line 64 of Listing 6.24, and the possible values for this 
field are defined on lines 42 to 46. 
Next come the adjectives. These fall naturally into several categories that have 
mutually exclusive values. The most complex of these is the storage class represented 
by the sclass field on line 65 of Listing 6.24, which can hold one of the values defined 
on lines 47 to 52. These values are mutually exclusive-you can't have an 
extern reqister, for example. Note that the TYPEDEF class is used only to pass 
information around during the declaration. typedefs are also marked by a bit in the 
first element of the type chain-it's convenient to have this information duplicated while 
the declaration is being processed-we'll see why in a moment. Note that AUTO desig­
nates anything that can be on the run-time stack, and FIXED is anything at a fixed 
address in memory, whether or not it's declared static. The static keyword is used 
by the compiler to decide whether or not to make the variable public when it generates 
the code to allocate space for that variable. 491 
The CONSTANT storage class is used for two purposes. First, when you declare an CONSTANT storage class. 
enumerated type like this: 
anum rabbits 
FLOPSY, MOPSEY, PETER, COTTONTAIL; 
} ; 
the compiler puts int entries for each of the elements of the enumerator list (FLOPSY, 
MOPSEY, PETER, and COTTONTAIL) into the symbol table and sets the CONSTANT attri­
bute in the associated specifier. The canst_ val union on lines 72 to 82 of Listing 
6.25-l holds the value associated with the constant. A definition forFLOPSY is in Figure 
6.12. The v _ int field holds the numeric values of integer constants, but it's also used 
for string constants. When the compiler sees a string constant, it outputs a definition of 
the form 
char Sl[] ="contents of string" ; 
and the numeric component of the label is stored in v _in t-each string label has a 
unique numeric component. v_struct is used only if the current specifier 
describes a structure, in which case the noun field is set to STRUCTURE and v _ st ruct 
points at yet another data structure (discussed momentarily) that describes the structure. 
The oclass field on line 66 of Listing 6.24 remembers the C-code storage class that 
is actually output with the variable definition for a global variable. The contents of this 
field are undefined if the sclass field is not set to FIXED, and the possible values are 
defined on lines 54 to 59. 
The _long field on line 67 selects either of two lengths for an integer variable. In _long and _short. 
the current application, the lonq keyword is ignored if the variable is of type char, and 
the short keyword is always ignored. All of this is summarized in Table 6.11. The 
492 Code Generation -Chapter 6 
Listing 6.24. symtab.h- A Specifier 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 #define 
#define 
#define 
#define 
#define INT 0 
CHAR 1 
VOID 2 
STRUCTURE 3 
LABEL 4 
#define FIXED 0 
#define REGISTER 1 
#define AUTO 2 
#define TYPEDEF 3 
#define CONSTANT 4 
#define #define 
#define 
#define 
#define NO OCLASS 0 
PUB 1 
PRI 2 
EXT 3 
COM 4 
typedef struct specifier 
{ 
unsigned noun :3; 
unsigned sclass :3; 
unsigned oclass :3; 
unsigned long :1; 
unsigned _unsigned :1; 
unsigned _static :1; 
unsigned extern :1; 
union 
int v int; 
unsigned int v uint; 
long v_long; I* specifier.noun. INT has the value 0 so *I 
I* that an uninitialized structure defaults *I 
I* to int, same goes for EXTERN, below. *I 
I* specifier.sclass 
I* At a fixed address. 
I* In a register. 
I* On the run-time stack. 
I* Typedef. 
I* This is a constant. 
I* Output (C-code) storage class 
I* No output class (var is auto). 
I* public 
I* private 
I* extern 
I* common *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I *I 
*I 
*I 
*I 
I* CHAR INT STRUCTURE LABEL *I 
I* REGISTER AUTO FIXED CONSTANT TYPEDEF *I 
I* Output storage class: PUB PRI COM EXT. *I 
I* l=long. O=short. *I 
I* l=unsigned. O=signed. *I 
I* l=static keyword found in declarations. *I 
I* l=extern keyword found in declarations. *I 
I* Value if constant: *I 
I* Int & char values. If a string canst., *I 
I* is numeric component of the label. *I 
I* Unsigned int constant value. *I 
I* Signed long constant value. *I 
unsigned long v_ulong; I* Unsigned long constant value. *I 
struct structdef *v_struct; I* If this is a struct, points at a *I 
I* structure-table element. *I 
const_val; 
specifier; 
_unsigned bit on line 68 is used in much the same way as long. The_ extern and 
_static bits on the next two lines remember when the equivalent keyword is found in 
the input as the specifier list is parsed. They are needed by the compiler to figure the 
output storage class after the entire specifier has been processed. 
Encapsulation. There's one final problem. A declaration list can be made up of two types of struc­
tures: it can have zero or more declarators in it, and it always has exactly one 
specifier. You need some way to determine if a list element is a declarator or a 
specifier when all you have to work with is a pointer to an element. The problem is 
solved by encapsulating the two structures into a third structure that can be either a 
declarator or specifier. This is done with the link structure in Listing 6.25. The class 
field tells us what the following union contains. It's either a DECLARATOR or a The link structure. 
Section 6.3.5-Representing Types-Implementation 
Figure 6.12. An Enumerator-List Element. 
symbol· 1. k 1n : 
name "FLOPSY" class=SPECIFIER 
type 
etype 
" s: 
noun = 
const 
I v INT 
val: 
int=O 
Table 6.ll. Processing long and short. 
input noun long length 
long int INT true 32 bits 
short int INT false 16 bits 
int INT false 16 bits 
long char CHAR true 8 bits 
short char CHAR false 8 bits 
char CHAR false 8 bits / 
I 
notes 
same asint 
same as char 
same as char 
SPECIFIER, as defined on lines 85 and 86. The next field points at the next element in 
the type chain. It's NULL if this is the specifier, which must come last in the chain. 
Finally, the tdef field is used when processing typedefs. It's used to distinguish 
whether a type chain was created by a typedef or by a normal declaration. You could 
treat typedef as a storage class, and mark it as such it in the sclass field of the 
specifier, but it's convenient not to have to chase down the length of the chain to the 
specifier to get this information. 
Listing 6.25. symtab.h- A link in the Declaration Chain 
#define DECLARATOR 0 
#define SPECIFIER 1 
typedef struct link 
{ 493 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 unsigned class 
unsigned tdef 1; 
1; I* DECLARATOR or SPECIFIER *I 
I* For typedefs. If set, current link *I 
I* chain was created by a typedef. *I 
100 
101 
102 103 
104 
105 
106 union 
specifier 
declarator 
select s; 
d; 
struct link *next; 
link; I* If class 
I* If class DECLARATOR 
SPECIFIER 
I* Next element of chain. 
1*----------------------------------------------------------------------
* Use the following p->XXX where p is a pointer to a link structure. 
*I *I 
*I 
*I 
.... 
494 Code Generation -Chapter 6 
Listing 6.25. continued ... 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 #define NOUN select.s.noun 
#define SCLASS select.s.sclass 
#define LONG select.s. _long 
#define UNSIGNED select.s. _unsigned 
#define EXTERN select.s. extern -#define STATIC select.s. static 
#define OCLASS select.s.oclass 
#define DCL TYPE select.d.dcl_type 
#define NUM ELE select.d.num ele 
#define VALUE select.s.const val 
#define V INT VALUE.v int 
#define V UINT VALUE.v uint 
#define V LONG VALUE.v_long 
#define V ULONG VALUE.v_ulong 
#define V STRUCT VALUE.v struct 
/*----------------------------------------------------------------------
* Use the following XXX(p) where p is a pointer to a link structure. 
*I 
#define IS_SPECIFIER(p) (p)->class SPECIFIER ) 
#define IS_DECLARATOR(p) (p)->class DECLARATOR ) 
#define IS_ARRAY(p) (p)->class DECLARATOR && (p)->DCL_TYPE==ARRAY 
#define IS_POINTER(p) (p)->class DECLARATOR && (p)->DCL_TYPE==POINTER 
#define IS_FUNCT(p) (p) ->class DECLARATOR && (p)->DCL_TYPE==FUNCTION) 
#define IS_STRUCT(p) (p) ->class SPECIFIER && (p)->NOUN STRUCTURE ) 
#define IS_LABEL(p) (p)->class SPECIFIER && (p)->NOUN LABEL ) 
#define IS_CHAR(p) (p)->class SPECIFIER && (p)->NOUN CHAR 
#define IS_INT (p) (p)->class SPECIFIER && (p) ->NOUN INT 
#define IS_UINT(p) IS INT(p) && (p)->UNSIGNED 
#define IS_LONG(p) IS_INT(p) && (p) ->LONG 
#define IS_ULONG (p) IS_INT(p) && (p) ->LONG && (p)->UNSIGNED 
#define IS_UNSIGNED(p) (p) ->UNSIGNED 
#define IS_AGGREGATE(p) IS_ARRAY(p) II IS_STRUCT (p) 
#define IS_PTR_TYPE(p) IS_ARRAY(p) II IS_POINTER(p) 
#define IS_CONSTANT(p) (IS_SPECIFIER(p) && (p)->SCLASS CONSTANT 
TYPEDEF 
INT #define IS_TYPEDEF(p) (IS_SPECIFIER(p) && (p)->SCLASS 
#define IS_INT_CONSTANT(p) (IS_CONSTANT(p) && (p)->NOUN 
The macros on lines 107 to 123 of Listing 6.25 clean up the code a little by getting 
rid of some of the dots and field names. For example, ifp is a pointer to a link, you can 
say p->V _ INT rather than 
p->select.d.const_val.v_int 
to access that field. 
Structures. The foregoing system becomes even more complex when you introduce structures 
and unions into the picture. You need two more data structures for this purpose. First of 
all, the structure definitions are organized in an auxiliary symbol table called the struc­
ture table, declared on line 159 of Listing 6.26, below. The v _ struct field of a 
specifier that describes a structure points at the structure-table element for that v struct 
Section 6.3.5-Representing Types-Implementation 495 
structure. The table is indexed by tag name if there is one-untagged structures are 
assigned arbitrary names. It contains structdef structures, defined on lines 151 to 157 
of Listing 6.26. The structdef contains the tag name (tag), the nesting level at the structdef 
point of declaration (level), and a pointer to a linked list of field definitions (fields), 
each of which is a symbol structure--one symbol for each field. The level field is 
here so that an error message can be printed when a duplicate declaration is found; it's 
recycled later to hold the offset to the field from the base address of the structure. These 
offsets are all zero in the case of a union; that's the only difference between a structure 
and a union, in fact. The symbol's next field links together the field definitions. This 
organization means that you must use a linear search to find a field, but it lets you have 
an arbitrary number of fields. 
Listing 6.26. symtab.h- Representing Structures 
typedef struct structdef 
{ 151 
152 
153 
154 
155 
156 
157 
158 
159 char tag[NAME_MAX+l]; 
unsigned char level; /* Tag part of structure definition. *I 
/* Nesting level at which struct declared.*/ 
symbol *fields; /* Linked list of field declarations. */ 
unsigned size; I* Size of the structure in bytes. */ 
structdef; 
ALLOC CLS HASH TAB *Struct_tab; /* The actual table. 
Figure 6.13 gives you an idea of how a reasonably complex declaration appears in 
the complete symbol-table system. I've left out irrelevant fields in the figure. The 
declaration that generated that table is as follows: 
struct argotiers 
{ 
int 
double (* Clopin) (); /* Function pointer *I 
Mathias[S]; 
struct argotiers *Guillaume; 
struct pstruct { int a; } Pierre; 
gipsy; 
Note that isolating the structdef from the field lets you correctly process a 
declaration like the following: 
struct one { struct two *p; }; 
struct two { struct one *p; }; 
because you can create a struct_def for struct two without having to know any­
thing about this second structure's contents. The fields can be added to the structdef 
when you get to the struct two declaration. *I 
The final part of symtab.h, in which various mappings from C types to C-code types C to C-code mappings. 
are defined, is in Listing 6.27. Note that the various WIDTH macros from <tools/c-
code.h> are used here, so you must include c-code.h before including symtab.h in your 
file. 
496 Code Generation -Chapter 6 
Figure 6.13. Representing a Structure in the Symbol Table 
Symbol t b symbol: a ---:l name "gipsy" link: link: 
"_gipsy" I rname class DECLARATOR I class DECLARATOR type next NULL next NULL next ' select: select: 
v noun STRUCT noun INT 
class FIXED class FIXED 
s to next variable at this level lS long 0 is long 0 -_unsigned _unsigned 0 0 truct tab structdef: value ' value 0 ,---tag "argotiers" ) size 52 I~ fields ' link: link: 
symbol l class SPECIFIER I class I SPECIFIER I next next 
name "Clopin" select select 
level 0 class I POINTER 
I class I FUNCTION 
I type num ele num ele - -
next ' 
symbol 1 link: 
class SPECIFIER I link: name "Mathias" 
level 4 next class DECLARATOR 
type select next NULL 
l~y I next ' class select: 
l num ele cooeD symbol class -
is_long 1 
name "Guillaume" link: _unsigned 1 
level 44 l value 0 
type class SPECIFIER 
next ' next 
symbol 1 select I 
I link: class POINTER 
num ele 
name "Pierre" ~ class DECLARATOR 
level 48 link: next NULL -select: type 
next NULL "-7 class DECLARATOR noun STRUCT 
next NULL class -
select: is_long 0 
noun STRUCT _unsigned 0 
structdef: class - value 
is_long 0 
tag "pstruct" _unsigned 0 link: size 2 
~ value f lfields ' ) class DECLARATOR 
1 next NULL 
symbol ,e>ec:;o"D 
name a class -
level 0 is long 0 
type _unsigned 0 
next NULL value 0 
Section 6.3.5-Representing Types-Implementation 
Listing 6.27. symtab.h- Sizes of Various Types 
160 #define CSIZE BYTE WIDTH 
161 #define CTYPE "byte" 
162 
163 #define I SIZE WORD WIDTH 
164 #define I TYPE "word" 
165 
166 #define LSIZE LWORD WIDTH 
167 #define LTYPE "lword" 
168 
169 #define PSIZE PTR WIDTH 
170 #define PTYPE "ptr" 
171 
172 #define STYPE "record" 
173 #define A TYPE "array" I* char *I 
I* int *I 
I* long *I 
I* pointer: 32-bit (8086 large model) *I 
I* structure, size undefined *I 
I* array, size undefined *I 
6.3.6 Implementing the Symbol-Table Maintenance Layer 
Our next task is to build the symbol-table maintenance layer-the functions that 
manipulate the data structures described in the last section. The first set of functions, in 
Listing 6.28, take care of memory management. Three sets of similar routines are 
provided-they maintain the symbol, link, and structdef structure respectively. 
Taking the symbol-maintenance routines on lines 23 to 81 of Listing 6.28 as charac­
teristic, the compiler creates and deletes symbols throughout the compilation process, 
so it's worthwhile to minimize the create-and-delete time for a node. discard_ sym­
bol ( ) creates a linked list of freed nodes on line 63 rather than calling newsym () and 
freesym () [the hash-table-function versions of malloc () and free ()] for every 
create and delete. Symbol_ free points at the head of the free list; it is declared on line 
15. new_ symbol() calls newsym () on line 30 only if the free list is empty, otherwise 
it just unlinks a node from the list on line 33. The routines for the other structures work 
in much the same way. The only difference is that new _link (),since it's calling mal­
loc () directly on line 96, can get nodes ten at a time to speed up the allocation process 
even further. LCHUNK-the number of nodes that are allocated at one time-is defined 
on line 19. 
Listing 6.28. symtab.c- The Maintenance Layer: Memory-Management Functions 
<stdio.h> 
<stdlib.h> 
<toolsldebug.h> 
<toolslhash.h> 
<toolsll.h> 
<toolslcompiler.h> 
<toolslc-code.h> 497 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include #include "symtab.h" 
"value.h" 
"proto.h" 
"label.h" I* Symbol-table definitions. *I 
10 
11 
12 
13 
14 
15 
16 
17 
18 I* Value definitions. *I 
I* Prototypes for all functions in this directory. *I 
I* Labels to use for compiler-generated symbols. *I 
1*----------------------------------------------------------------------*l 
PRIVATE symbol 
PRIVATE link *Symbol_free 
*Link free 
PRIVATE structdef *Struct free NULL; 
NULL; 
NULL; I* Free-list 
I* Free-list 
I* Free-list of recycled symbols. *I 
of recycled links. *I 
of recycled structdefs. *I 
.... 
498 Code Generation -Chapter 6 
Listing 6.28. continued ... 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 ldefine LCHUNK 10 /* new_link() gets this many nodes at one shot.*/ 
/*----------------------------------------------------------------------*/ 
PUBLIC symbol *new_symbol( name, scope ) 
char 
int *name; 
scope; 
symbol *sym_p; 
if( !Symbol_free 
sym_p = (symbol *) newsym( sizeof(symbol) ); 
else 
sym_p = Symbol_free; 
Symbol free = Symbol_free->next 
memset( sym_p, 0, sizeof(symbol) ); 
strncpy( sym_p->name, name, sizeof(sym_p->name) ); 
sym_p->level = scope; 
return sym_p; /* Free list is empty.*/ 
/* Unlink node from */ 
/* the free list. */ 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PUBLIC void 
symbol *sym; 
{ discard_symbol( sym) 
/* Discard a single symbol structure and any attached links and args. Note 
* that the args field is recycled for initializers, the process is 
/* * described later on in the text (see value.c in the code), but you have to 
* test for a different type here. Sorry about the forward reference. 
*I 
if ( sym 
{ 
if( IS_FUNCT( sym->type ) 
discard_symbol_chain( sym->args ); 
else 
discard_value( (value *)sym->args ); 
discard_link_chain( sym->type ); 
sym->next 
Symbol_free Symbol_free 
sym; /* 
/* 
/* 
/* 
/* Function arguments. 
If an initializer. 
Discard type chain. 
Put current symbol 
in the free list. 
- - - - - - - - - - - - -*/ *I 
*I *I 
*I 
*I 
PUBLIC void 
symbol *sym; 
{ discard_symbol_chain(sym) /* Discard an entire cross-linked */ 
/* chain of symbols. */ 
symbol *p = sym; 
while( sym ) 
{ 
p = sym->next; 
discard_symbol( sym); 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 499 
Listing 6.28. continued ... 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 sym = p; 
l*----------------------------------------------------------------------*1 
PUBLIC link 
{ *new_link { ) 
/* Return a new link. It's initialized to zeros, so it's a declarator. 
* LCHUNK nodes are allocated from malloc() at one time. 
*I 
link *p; 
int i; 
if ( ! Link free 
{ 
if( ! (Link_free = (link*) malloc( sizeof(link) * LCHUNK )) ) 
{ 
yyerror("INTERNAL, new link: Out of memory\n"); 
exit ( 1 ) ; 
for( p = Link_free, i 
p->next = p + 1; 
p->next = NULL ; 
p = Link_free; LCHUNK; --i > 0; ++p ) 
Link free = Link_free->next; 
memset( p, 0, sizeof(link) ); 
return p; /* Executes LCHUNK-1 */ 
/* times. *I 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PUBLIC void discard link_chain( p ) 
link *p; 
{ 
/* Discard all links in the chain. Nothing is removed from the structure 
* table, however. There's no point in discarding the nodes one at a time 
*since they're already linked together, so find the first and last nodes 
* in the input chain and link the whole list directly. 
*I 
link *start 
if ( start = p 
{ 
while( p->next 
p = p->next; 
p->next 
Link free Link_free; 
start; /* find last node */ 
500 Code Generation -Chapter 6 
Listing 6.28. continued ... 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 /*-- - - - - - - - - - - - *I 
PUBLIC void discard link( p /* Discard a single link. */ 
link *p; 
{ 
p->next 
Link free Link_free; 
p; 
!*----------------------------------------------------------------------*/ 
PUBLIC structdef *new_structdef( tag ) /* Allocate a new structdef. */ 
char *tag; 
{ 
/* structdef *sdef_p; 
if( !Struct_free ) 
sdef_p = (structdef *) newsym( sizeof(structdef) ); 
else 
{ 
sdef_p = Struct_free; 
Struct free= (structdef *) (Struct free->fields); 
memset( sdef_p, 0, sizeof(structdef) ); 
strncpy( sdef_p->tag, tag, sizeof(sdef_p->tag) ); 
return sdef_p; 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
PUBLIC void 
structdef discard_structdef( sdef_p ) 
*sdef_p; 
/* Discard a structdef and any attached fields, but don't discard linked 
* structure definitions. 
*I 
if( sdef_p ) 
( 
discard_symbol_chain( sdef_p->fields ); 
sdef_p->fields 
Struct free (symbol *)Struct free 
sdef_p; 
Subroutines in Listing 6.29 manipulate declarators: add_ declarator() adds 
declarator nodes to the end of the linked list pointed to by the type and et ype fields in 
a symbol structure. The routine is passed a symbol pointer and the declarator type 
(ARRAY, POINTER, or FUNCTION-declared on line 33 of Listing 6.23, page 491). Sub­
routines in Listing 6.30 manipulate specifiers: they copy, create, and initialize specif­
ier links. 
Listing 6.31 contains routines that manipulate entire types and linked-lists of sym­
bols. clone_type (),on line 226, copies an entire type chain. This routine is used in 
two places. First, when a variable that uses a typedef rather than a standard type is 
declared, the type chain is copied from the symbol representing the typedef to the 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 
Listing 6.29. symtab.c- The Maintenance Layer: Declarator Manipulation 
PUBLIC void add_declarator( sym, type ) 
symbol 
int *sym; 
type; 
/* Add a declarator link to the end of the chain, the head of which is 
* pointed to by sym->type and the tail of which is pointed to by 
* sym->etype. *head must be NULL when the chain is empty. Both pointers 
* are modified as necessary. 
*I 
link *link_p; 
if( type== FUNCTION && IS_ARRAY(sym->etype} ) 
{ 
yyerror("Array of functions is illegal, assuming function pointer\n"); 
add_declarator( sym, POINTER ) ; 501 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 link_p 
link_p->DCL_TYPE new_link(); 
type; /* The default class is DECLARATOR. */ 
if( !sym->type ) 
sym->type = sym->etype 
else link_p; 
sym->etype->next 
sym->etype link_p; 
link_p; 
Listing 6.30. symtab.c- The Maintenance Layer: Specifier Manipulation 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 PUBLIC spec_cpy( dst, src ) 
link *dst, *src; /* Copy all initialized fields in src to dst.*/ 
if( src->NOUN dst->NOUN src->NOUN 
if( src->SCLASS dst->SCLASS src->SCLASS 
if( src->LONG dst->LONG src->LONG 
if( src->UNSIGNED dst->UNSIGNED src->UNSIGNED 
if( src->STATIC dst->STATIC src->STATIC 
if( src->EXTERN dst->EXTERN src->EXTERN 
if( src->tdef dst->tdef src->tdef 
if( src->SCLASS CONSTANT I I src->NOUN == STRUCTURE) 
memcpy( &dst->VALUE, &src->VALUE, sizeof(src->VALUE) ) ; 
symbol for the variable. You could keep around only one type chain in the typedef 
symbol, and make the new symbols type field point there, but this would complicate 
symbol deletion, because you'd have to keep track of the scope level of every link as 
you deleted nodes. Though this later method would be more conservative of memory, it 
complicates things enough so that I didn't want to use it. clone_ type () is also used to 
create type chains for temporary variables, though here the copying is less defensible. 
502 Code Generation -Chapter 6 
I'll discuss this second application when expression processing is discussed, below. 
the_ s arne_ type, on line 258 of Listing 6.31, compares two type chains and returns 
true if they match. The storage class components of the specifier are ignored. When the 
third argument is true, a POINTER declarator is considered identical to a ARRAY declara­
tor when they are found in the first positions of both type chains. This relaxation of strict 
type checking is necessary, again, for expression processing, because arrays are 
represented internally as a pointer to the first element. Strict checking is necessary when 
two declarations are compared for equivalence, however, so the third argument lets us 
disable this feature. 
get_ s i zeo f ( ) , on line 302 of Listing 6.31, returns the size of an object of the type 
represented by its argument. Note that recursion is used on line 313 to process arrays. A 
declaration like this: 
int a[lO] [20] 
should return 400 ( lO x 20 elements x 2 bytes per element). If the current declarator is 
an array, the size of the current dimension is remembered, and the the rest of the type 
chain is passed recursively to get_ sizeof () to get the size of an array element. This 
could, of course, be done with a loop, but the recursion is more compact and arrays with 
more than three or four dimensions are rare. The other subroutines in the listing are 
self-explanatory. 
The remainder of the maintenance layer, in Listing 6.32, is made up of subroutines 
that print symbols and convert fields to printable strings. 
Listing 6.31. symtab.c- The Maintenance Layer: Type Manipulation 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 238 
239 
240 
241 
242 
243 
244 
245 
246 
247 248 
249 
250 
251 
252 
253 
254 
255 PUBLIC 
link 
link 
{ link *clone_type( tchain, endp ) 
*tchain; I* input: Type chain to duplicate. 
**endp; I* output: Pointer to last node in cloned chain. 
I* Manufacture a clone of the type chain in the input symbol. Return a *I 
*I 
* pointer to the cloned chain, NULL if there were no declarators to clone. 
* The tdef bit in the copy is always cleared. 
*I 
link *last, *head = NULL; 
for(; tchain ; tchain = tchain->next 
{ 
if( !head ) 
head = last 
else 
{ 
last->next 
last new_link(); 
new_link(); 
last->next; 
memcpy( last, tchain, sizeof(*last) ); 
last->next NULL; 
last->tdef = 0; 
*endp·= last; 
return head; I* 1st node in chain. *I 
I* Subsequent node. *I 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 503 
Listing 6.31. continued ... 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 1*----------------------------------------------------------------------*l 
PUBLIC int the_same_type( pl, p2, relax ) 
link *pl, *p2; 
int relax; 
I* Return 1 if the types match, 0 if they don't. Ignore the storage class. 
* If "relax" is true and the array declarator is the first link in the 
* chain, then a pointer is considered equivalent to an array. 
*I 
if( relax && IS_PTR_TYPE(pl) && IS_PTR_TYPE(p2) 
{ 
pl pl->next; 
p2 p2->next; 
for(; pl && p2 ; 
{ 
if( pl->class 
return 0; 
if( pl->class 
{ pl = pl->next, p2 p2->next) 
!= p2->class ) 
== DECLARATOR ) 
if( (pl->DCL_TYPE != p2->DCL_TYPE) I I 
(pl->DCL_TYPE==ARRAY && (pl->NUM_ELE != pl->NUM_ELE)) ) 
return 0; 
else 
{ I* this is done last *I 
if ( (pl->NOUN 
(pl->UNSIGNED p2->NOUN 
p2->UNSIGNED && (pl->LONG == p2->LONG ) && 
) 
return ( pl->NOUN==STRUCTURE ) ? pl->V_STRUCT 
1 ; 
return 0; 
yyerror("INTERNAL the_same_type: Unknown link class\n"); 
return 0; p2->V_STRUCT 
1*----------------------------------------------------------------------*l 
PUBLIC int 
link *p; 
{ get_sizeof( p ) 
I* Return the size in bytes of an object of the the type pointed to by p. 
*Functions are considered to be pointer sized because that's how they're 
* represented internally. 
*I 
int size; 
if( p->class == DECLARATOR ) 
size= (p->DCL_TYPE==ARRAY) ? p->NUM_ELE * get_sizeof(p->next) PSIZE; 
504 Code Generation -Chapter 6 
Listing 6.31. continued ••• 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 else 
switch( p->NOUN 
{ 
case CHAR: 
case INT: 
case STRUCTURE: 
case VOID: 
case LABEL: 
return size; size 
size 
size 
size 
size CSIZE; break; 
p->LONG ? LSIZE : ISIZE; break; 
p->V_STRUCT->size; break; 
0; break; 
0; break; 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
~41 
342 
343 
344 
345 
346 1*----------------------------------------------------------------------*l 
PUBLIC symbol *reverse_links( sym) 
symbol *sym; 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 357 { 
I* Go through the cross-linked chain of "symbols", reversing the direction 
* of the cross pointers. Return a pointer to the new head of chain 
* (formerly the end of the chain) or NULL if the chain started out empty. 
*I 
symbol *previous, *current, *next; 
if ( ! sym ) 
return NULL; 
previous 
current sym; 
sym->next; 
while( current 
{ 
next 
current->next 
previous 
current 
sym->next = NULL; 
return previous; current->next; 
previous; 
current; 
next; 
Listing 6.32. symtab.c- The Maintenance Layer: Symbol-Printing Functions 
358 PUBLIC char *sclass_str( class ) 
359 int class; 
360 { 
361 
362 
363 
364 
365 
366 
367 return class==CONSTANT 
class==REGISTER 
class==TYPEDEF 
class==AUTO 
class==FIXED ? "CON" 
? "REG" 
? "TYP" 
? "AUT" 
? "FIX" I* Return a string representing the *I 
I* indicated storage class. *I 
"BAD SCLASS" 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 
Listing 6.32. continued ... 
1*----------------------------------------------------------------------*l 
PUBLIC char *oclass_str( class ) 
int class; 
{ I* Return a string representing the *I 
I* indicated output storage class. *I 
return class==PUB ? "PUB" 
class==PRI ? "PRI" 
class==COM ? "COM" 
class==EXT ? "EXT" "(NO OCLS)" 
1*----------------------------------------------------------------------*l 
PUBLIC char *noun_str( noun ) 
int noun; 
{ 
return noun==INT ? "int" 
noun==CHAR ? "char" 
noun==VOID ? "void" 
noun==LABEL ? "label" 
noun==STRUCTURE ? "struct" I* Return a string representing the *I 
I* indicated noun. *I 
"BAD NOUN" 
1*----------------------------------------------------------------------*l 
PUBLIC char *attr_str( spec_p 
specifier *spec_p; 
{ 
static char str[S]; 
str [0] spec_p->_unsigned 
str [1] spec_p->_ static 
str[2] spec_p->_ extern 
str [3] spec_p->_long 
str[4] I \0'; 
return str; ? 'u' 
? , s' 
? 'e' 
? I l' I* Return a string representing all *I 
I* attributes in a specifier other *I 
I* than the noun and storage class. *I 
I I 
I I 
I I 
I I 
1*----------------------------------------------------------------------*l 
char *type_str ( link_p ) 505 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 PUBLIC 
link 
{ *link_p; I* Return a string representing the *I 
I* type represented by the link chain. *I 
int i; 
static char target [ 80 ]; 
static char buf [ 64 ]; 
int available = sizeof(target) -1; 
*buf 
*target I \0'; 
I \0'; 
if( !link_p ) 
return " (NULL) "; 
if( link_p->tdef ) 
{ 
strcpy( target, "tdef" ); 
available -= 5; 
.... 
506 Code Generation -Chapter 6 
Listing 6.32. continued ••• 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 for(; link_p ; link_p = link_p->next 
{ 
if( IS_DECLARATOR(link_p) ) 
{ 
switch( link_p->DCL_TYPE 
{ 
case POINTER: i sprintf (buf, "*" ) ; break; 
case ARRAY: i sprintf (buf, "[%d] ", link_p->NUM_ELE); break; 
case FUNCTION: i sprintf(buf, "()" ); break; 
default: i sprintf(buf, "BAD DECL" ) ; break; 
} 
else I* it's a specifier *I 
{ 
i = sprintf( buf, "%s %s %s %s", noun str 
sclass_str( 
oclass_str( 
attr str ( link_p->NOUN ), 
link_p->SCLASS ), 
link_p->OCLASS ), 
&link_p->select.s)); 
if( link_p->NOUN==STRUCTURE I I link_p->SCLASS==CONSTANT 
{ 
strncat( target, buf, available ); 
available -= i; 
if( link_p->NOUN != STRUCTURE ) 
continue; 
else 
i = sprintf(buf, " %s", link_p->V_STRUCT->tag ? 
link_p->V_STRUCT->tag "untagged"); 
strncat( target, buf, available); 
available -= i; 
return target; 
1*----------------------------------------------------------------------*l 
PUBLIC char *tconst_str( type ) 
link 
{ *type; 
static char buf[80]; 
buf[O] 
buf[l] , ? , ; 
I \0'; I* Return a string representing the value *I 
I* field at the end of the specified type *I 
I* (which must be char*, char, int, long, *I 
I* unsigned int, or unsigned long). Return *I 
I* "?" if the type isn't any of these. *I 
if( IS_POINTER(type) && IS_CHAR(type->next) ) 
{ 
sprintf( buf, "%s%d", L_STRING, type->next->V_INT ); 
else if( ! (IS_AGGREGATE(type) I I IS_FUNCT(type)) 
{ 
switch( type->NOUN ) 
{ 
.... 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 507 
Listing 6.32. continued ... 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 508 
509 
510 
511 
512 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 case CHAR: 
case INT: 
if( *buf == '?' ) sprintf ( buf, "' %s' (%d)", bin_to_ascii ( 
type->UNSIGNED ? type->V_UINT 
: type->V_INT,l), 
type->UNSIGNED ? type->V_UINT 
type->V_INT,l ); 
break; 
if( type->LONG 
{ 
else if( type->UNSIGNED 
sprintf(buf, "%luL", type->V_ULONG); 
else 
sprintf(buf, "%ldL", type->V_LONG ); 
if( type->UNSIGNED ) 
sprintf( buf, "%u", type->V_UINT); 
else 
sprintf( buf, "%d", type->V_INT ); 
break; 
yyerror("Internal, tconst str: Can't make constant for type %s\n", 
type_str( type )); 
return buf; 
/*----------------------------------------------------------------------*/ 
PUBLIC char 
symbol *chain; 
{ *sym_chain_str( chain ) 
I* Return a string listing the names of all symbols in the input chain (or 
*a constant value if the symbol is a constant). Note that this routine 
* can't call type_str() because the second-order recursion messes up the 
*buffers. Since the routine is used only for occasional diagnostics, it's 
* not worth fixing this problem. 
*I 
int i; 
static char buf[80]; 
char *p buf; 
int avail sizeof( buf ) -1; 
*buf '\0'; 
while( chain && avail > 0 ) 
{ 
if( IS_CONSTANT(chain->etype) 
i sprintf( p, "%0.*s", avail- 2, "canst" ); 
else 
i sprintf( p, "%0.*s", avail 2, chain->name ); 
p += i; 
avail i; 
508 Code Generation -Chapter 6 
Listing 6.32. continued ... 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 588 
589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 if( chain = chain->next 
{ 
-' ' -' *p++ 
i -= 2; 
return buf; 
/*----------------------------------------------------------------------*/ 
PRIVATE void psym( sym_p, fp ) /* Print one symbol to fp. */ 
symbol 
FILE *sym_p; 
*fp; 
{ 
fprintf(fp, "%-18.18s %-18.18s %2d %p %s\n", 
sym_p->name, 
sym_p->type ? sym_p->rname 
sym_p->level, 
(void far *)sym_p->next, 
type_str( sym_p->type) ); "------" ' 
/*----------------------------------------------------------------------*/ 
PRIVATE void pstruct( sdef_p, fp) /* Print a structure definition to fp */ 
/* including all the fields & types. */ structdef *sdef_p; 
FILE *fp; 
{ 
symbol *field_p; 
fprintf(fp, "struct <%s> (level %d, %d bytes) :\n", 
sdef_p->tag,sdef_p->level,sdef p->size); 
for( field_p = sdef_p->fields; field_p; field_p=field_p->next 
{ 
fprintf(fp, " %-20s (offset %d) %s\n", 
field_p->name, field_p->level, type_str(field_p->type)); 
/*----------------------------------------------------------------------*/ 
PUBLIC 
char print_syms( filename ) 
*filename; /* Print the entire symbol table to */ 
/* the named file. Previous contents */ 
/* of the file (if any) are destroyed.*/ { 
FILE *fp; 
if( ! (fp = fopen(filename,"w")) ) 
yyerror("Can't open symbol-table file\n"); 
else 
{ 
fprintf(fp, "Attributes in type field are: upel\n" 
fprintf(fp, " unsigned (. for signed)-----+ I I I \n" 
fprintf(fp, " private (. for public)------+ I I \n" 
fprintf(fp, " extern (. for common)-------+1\n" 
fprintf(fp, " long (. for short )--------+\n\n" ) ; 
) ; 
) ; 
) ; 
) ; 
Section 6.3.6-Implementing the Symbol-Table Maintenance Layer 509 
Listing 6.32. continued ... 
604 
605 
606 
607 
608 
609 
610 
611 
612 fprintf(fp,"name rname lev next type\n"); 
ptab( Symbol_tab, psym, fp, 1 ); 
fprintf(fp, "\nStructure table:\n\n"); 
ptab( Struct_tab, pstruct, fp, 1 ) ; 
fclose ( fp ) ; 
6.4 The Parser: Configuration 
I'll start looking at the compiler proper with the configuration parts of the occs input 
file. Listing 6.33 shows most of the header portion of the occs input file. The %union 
directive on lines 21 to 30 of Listing 6.33 types the value stack as a C union containing 
the indicated fields. Some of these fields are pointers to symbol-table structures, others 
to structures that are discussed below, and the last two fields are simple-variable 
attributes-num is for integer numbers, ascii for ASCII characters. Further down in the 
table, directives like <ascii> tell occs which fields to use for particular symbols. For 
example, an ASSIGNOP has an <ascii> attribute because the <ascii> directive pre­
cedes its definition on line 63. The ascii field of the union is used automatically if $N 
in a production corresponds to an ASSIGNOP. You don't have to say $N. ascii. %union, used for C 
compiler's value stack. 
Listing 6.33. c.y-occs Input File: Definitions Section 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 %{ 
#include <stdio.h> 
#include <stdlib.h> 
#include <signal.h> 
#include <toolsldebug.h> 
#include <toolslhash.h> 
#include <toolslcompiler.h> 
#include <toolsll.h> I* Misc. macros. (see Appendix A) *I 
I* Hash-table support. (see Appendix A) *I 
I* Prototypes for comp.lib functions. *I 
I* Prototypes for l.lib functions. *I 
#define ALLOC 
#include "symtab.h" 
#include "value.h" 
#include "label.h" 
#include "switch.h" 
#include "proto.h" 
%} I* Define ALLOC to create symbol table in symtab.h. *I 
I* Definitions for the symbol-table. *I 
I* Definitions used for expression processing. *I 
I* Prefixes used for compiler-generated labels. *I 
I* Definitions used for switch processing. *I 
I* Function prototypes for all .c files used by the *I 
I* parser. It is not printed anywhere in the book, *I 
I* but is included on the distribution disk. *I 
1*----------------------------------------------------------------------*l 
%union { 
char 
symbol 
link 
structdef 
specifier 
value 
int 
int *p_char; 
*p_sym; 
*p_link; 
*p sdef; 
*p_spec; 
*p_val; 
num; 
ascii; I* Make short if sizeof(int) > sizeof(int*) *I 
510 Code Generation -Chapter 6 
Listing 6.33. continued ... 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 58 59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 1*----------------------------------------------------------------------*l 
%term 
%term 
%term 
%term 
%term 
%term 
%term 
%term 
%term 
%term 
%term %term 
%term 
%term STRING 
ICON 
FCON 
TYPE 
<ascii> STRUCT 
ENUM 
RETURN GOTO 
IF ELSE I* String constant. *I 
I* Integer or long constant including '\t', etc. *I 
I* Floating-point constant. *I 
I* int char long float double signed unsigned short *I 
I* canst volatile void *I 
I* struct union *I 
I* enum *I 
SWITCH CASE DEFAULT 
BREAK CONTINUE 
WHILE DO FOR 
LC RC 
SEMI 
ELLIPSIS I* 
I* 
I* { } 
; *I *I 
*I 
I* The attributes used below tend to be the sensible thing. For example, the 
* ASSIGNOP attribute is the' operator component of the lexeme; most other 
* attributes are the first character of the lexeme. Exceptions are as follows: 
* token attribute 
* RELOP > '>' 
* RELOP < , <' 
* RELOP >= , G' 
* RELOP <= 'L' 
*I 
%left COMMA I* , 
%right EQUAL <ascii> ASSIGNOP I* *= /= %= += <<= >>= &= I= -
%right QUEST COLON I* ? 
%left OROR I* II 
%left AND AND I* && 
%left OR I* I 
%left XOR I* -
%left AND I* & 
%left <ascii> EQUOP I* != 
%left <ascii> RELOP I* <= >= < > 
%left <ascii> SHIFTOP I* >> << 
%left PLUS MINUS I* + -
%left STAR <ascii> DIVOP I* * I % 
I* sizeof ! - ++ -- %right SIZEOF <ascii> UNOP IN COP 
%left LB RB LP RP <ascii> STRUCTOP I* [ 1 ( -> 
I* These attributes are shifted by the scanner. *I 
%term <p_sym> TTYPE I* Name of a type created with a previous typedef.*l 
I* Attribute is a pointer to the symbol table *I 
I* entry for that typedef. *I 
%nonassoc <ascii> CLASS I* extern register auto static typedef. Attribute *I 
I* is the first character of the lexeme. *I 
%nonassoc <p_sym> NAME I* Identifier or typedef name. Attribute is NULL *I 
I* if the symbol doesn't exist, a pointer to the *I *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
.... 
Section 6.4-The Parser: Configuration 
Listing 6.33. continued .•. 
87 I* associated "symbol" structure, otherwise. *I 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 %nonassoc ELSE I* This gives a high precedence to ELSE to suppress 
* the shift/reduce conflict error message in: 
* s -> IF LP expr RP expr I IF LP expr RP s ELSE s 
* The precedence of the first production is the same 
* as RP. Making ELSE higher precedence forces 
* resolution in favor of the shift. 
*I 
%type <num> args const_expr test 
%type <p_sym> 
%type <p_sym> 
%type <p_sym> 
%type <p_val> 
%type <p_val> 
%type <p_link> 
%type <p_sdef> 
%type <p_char> ext decl list ext decl def list def decl list decl 
var decl funct decl local defs new name name enumerator - - - -name list var_list param_declaration abs decl abstract decl 
expr binary non comma_expr unary initializer initializer_list 
or_expr and_expr or_list and list 
type specifiers opt_specifiers type_or_class type_specifier 
opt_tag tag struct_specifier 
string_const target 
1*----------------------------------------------------------------------
* Global and external variables. Initialization to zero for all globals is 
* assumed. Since occs -a and -p is used, these variables may not be private. 
*I 
%{ 
#ifdef YYACTION 
extern char *yytext; 
extern const int yylineno, yyleng; 
%} I* generated by LeX *I 
There are several other variables declared in this part of the 
input file. I'll discuss these variables, below, as they are used. 
180 % { 
181 #endif 
182 %} 511 
Lines 34 to 50 of Listing 6.33 contain definitions for those tokens that aren't used in 
expressions, so don't require precedence or associativity information. Lines 62 to 76 
comprise a precedence chart in which the other tokens are defined. Lowest-precedence 
operators are at the top of the list, and tokens on the same line are at the same pre­
cedence level. Some of these tokens have the <ascii> attribute associated with them. 
These tokens all represent multiple input symbols. The attribute, created by the lexical 
analyzer and passed to the parser using the yylval mechanism described in Appendix 
E, serves to identify which input symbol has been scanned. You can access the attribute 
from within a production by using the normal $ mechanism-if a symbol with an 
<ascii> attribute is at $1 in the production, then that attribute can be referenced by 
using $1 in an action. Most <ascii> attributes are the first character of the lexeme-a 
few exceptions are listed in the comment on line 52 of Listing 6.33. Tokens not in expres· 
sions. Single tokens 
represent multiple sym­
bols. Attributes 
differentiate them. 
TYPE, CLASS, NAME, and ELSE are assigned precedence levels on lines 79 to 95 to 
eliminate various shift/reduce conflicts inherent in the grammar. (See Appendix E for a TYPE, CLASS, NAME, 
and ELSE have pre­
cedence. 
512 
%type Code Generation -Chapter 6 
description of what's going on.) The NAME and TTYPE tokens also have pointer-to­
symbol-table-entry attributes associated with them. (A TTYPE is a type created by a pre­
vious typedef.) The lexical analyzer uses the symbol table to distinguish identifiers 
from user-defined types. It returns a NULL attribute if the input symbol isn't in the table, 
otherwise the attribute is a pointer to the appropriate symbol-table entry. I'll demon­
strate how this is done in a moment. 
The %type directives on lines 96 to 106 of Listing 6.33 attach various attributes to 
nonterminal names. The abbreviations that are used in the names are defined in Table 
6.12. The remainder of the header holds variable definitions, most of which aren't shown 
in Listing 6.33. They're discussed later along with the code that actually uses them. 
Table 6.12. Abbreviations Used in Nonterminal Names 
Abbreviation Meaning Abbreviation Meaning 
abs abstract expr expression 
arg argument ext external 
canst constant opt optional 
decl declarator par am parameter 
def definition struct structure 
SIGINT handling, clean­
up. Skipping past the productions themselves for a moment, the end of the occs input file 
starts in Listing 6.34. This section contains various initialization and debugging routines 
that are used by the parser. The occs parser's initialization function starts on line 1306 
of Listing 6.34. It creates temporary files and installs a signal handler that deletes the 
temporaries if SIGINT. is issued while the compiler is running. (SIGINT is issued 
when a Ctrl-C or Ctrl-Break is encountered under MS-DOS. Some UNIX systems also 
recognize DEL or Rubout.) init_output_streams (), starting on line 1251, 
creates three temporary files to hold output for the code, data, and bss segments. These 
files make it easier to keep the various segments straight as code is generated. The 
cleanup code that starts on line 1323 merges the three temporaries together at the end of 
the compilation process by renaming the data file and then appending the other two files. Create temporary-files for 
code, data, and bss seg­
ments. 
Listing 6.34. c.y-occs Input File: Temporary-File Creation 
1240 
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 
1252 
1253 
1254 
1255 
1256 
1257 
1258 
1259 
1260 %% 
extern char *mktemp(); 
extern FILE *yycodeout, *yydataout, *yybssout; 
extern yyprompt(); I* In aces output file. *I 
I* In debugger. *I 
#define OFILE NAME "output. c" I* Output file name. *I 
char *Bss ; I* Name of BSS temporary file. *I 
char *Code; I* Name of Code temporary file. *I 
char *Data; I* Name of Data temporary file. *I 
l*----------------------------------------------------------------------*1 
PRIVATE void init_output_streams( p_code, p_data, p_bss) 
char **p_code, **p_data, **p_bss; 
I* Initialize the output streams, making temporary files as necessary. 
*Note that the ANSI tmpfile() or the UNIX mkstmp() functions are both 
*better choices than the mktemp()/fopen() used here because another 
* process could, at least in theory, sneak in between the two calls. 
* Since mktemp uses the process id as part of the file name, this 
* is not much of a problem, and the current method is more portable 
*than tmpfile() or mkstmp(). Be careful in a network environment. 
Section 6.4-The Parser: Configuration 513 
Listing 6.34. continued ... 
1261 
1262 
1263 
1264 
1265 
1266 
1267 
1268 
1269 
1270 
1271 
1272 
1273 
1274 
1275 
1276 
1277 1278 
1279 
1280 
1281 
1282 
1283 
1284 
1285 
1286 
1287 
1288 
1289 
1290 
1291 
1292 
1293 
1294 
1295 
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 
1306 
1307 
1308 
1309 
1310 
1311 
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 *I 
if ( ! (*p_code 
! (*p_bss mktemp ( "ccXXXXXX")) I I ! (*p __ data 
mktemp ("cbXXXXXX")) 
yyerror("Can't create temporary-file names"); 
exit( 1 ) ; mktemp("cdXXXXXX")) II 
if( ! (yycodeout=fopen(*p_code, "w")) II ! (yydataout=fopen(*p_data, "w")) II 
! (yybssout =fopen ( *p_bss, "w")) 
perror("Can't open temporary files"); 
exit( 1 ); 
/*----------------------------------------------------------------------*/ 
void (*Osig) (); /*Previous SIGINT handler. Initialized in yy_init_occs().*/ 
PRIVATE sigint_handler() 
{ 
/* Ctrl-C handler. Note that the debugger raises SIGINT on a 'q' command, 
* so this routine is executed when you exit the debugger. Also, the 
* debugger's own SIGINT handler, which cleans up windows and so forth, is 
*installed before yy_init_occs() is called. It's called here to clean up 
* the environment if necessary. If the debugger isn't installed, the call 
* is harmless. 
"'*/ 
signal SIGINT, SIG_IGN ); 
clean_up ) ; 
unlink OFILE NAME ); 
(*Osig) (); 
exit(1); /*Needed only if old signal handler returns. *I 
/*----------------------------------------------------------------------*/ 
sym_cmp (s1, s2) symbol *s1, *s2; {return strcmp (s1->name, s2->name);} 
struct_cmp (s1, s2) structdef *s1, *s2; {return strcmp (s1->tag, s2->tag );} 
sym_hash (sl) symbol *sl; { return hash_add(s1->name ); } 
struct hash (s1) structdef *s1; { return hash_add(s1->tag ); } 
PUBLIC void 
yystype *val; 
{ yy_init_occs( val ) 
yycomment("Initializing\n"); 
Osig =signal( SIGINT, SIG_IGN ); 
init_output_streams( &Code, &Data, &Bss ) ; 
signal( SIGINT, sigint_handler ); 
val->p_char = "---"; /* Provide attribute for the start symbol. */ 
Symbol_tab 
Struct tab maketab( 257, sym_hash, sym_cmp ); 
maketab( 127, struct_hash, struct_cmp ) ; 
514 Code Generation -Chapter 6 
Listing 6.34. continued ... 
1321 1*----------------------------------------------------------------------*l 
1322 
1323 PRIVATE void clean_up() 
1324 { 
1325 I* Cleanup actions. Mark the ends of the various segments, then merge the 
1326 * three temporary files used for the code, data, and bss segments into a 
1327 * single file called output.c. Delete the temporaries. Since some compilers 
1328 *don't delete an existing file with a rename(), it's best to assume the 
1329 *worst. It can't hurt to delete a nonexistent file, you'll just get an 
1330 * error back from the operating system. 
1331 *I 
1332 
1333 extern FILE *yycodeout, *yydataout, *yybssout; 
1334 
1335 
1336 
1337 
1338 
1339 
1340 signal 
fclose 
fclose 
fclose 
unlink SIGINT, SIG 
yycodeout 
yydataout 
yybssout 
OFILE NAME IGN ) ; -
) ; 
) ; 
) ; 
) ; I* delete old output file (ignore EEXIST) *I 
1341 if ( rename ( Data, OFILE NAME ) 
1342 yyerror("Can't rename temporary (%s) to %s\n", Data, OFILE_NAME ); 
1343 else 
1344 { I* Append the other temporary *I 
1345 movefile ( OFILE_NAME, Bss , "a" ) ; I* files to the end of the *I 
1346 move file ( OFILE_NAME, Code, "a" ) ; I* output file and delete the *I 
1347 I* temporary files. movefile() *I 
1348 I* is in appendix A. *I 
Print the value stack, 
yypstk (). 
main (), yyhook _a(), 
yyhook_b () The remainder of the occs input file is in Listing 6.35. yypstk (), starting on line 
1423, is used by the occs interactive debugger to print the value-stack contents. The rou­
tine is passed a pointer to the value stack item and a pointer to the equivalent string on 
the symbolic, debugging stack (the middle column in the stack window). It uses this 
string to identify which of the fields in the union are active, by searching the table on 
lines 1357 to 1415 with the bsearch () call on line 1432. The following switch then 
prints out stack item. 
Listing 6.36 finishes up the start-up code with a main () function. The 
yyhook a () routine is a debugger hook that prints the symbol table when a Ctrl-A is 
issued at the IDE's command prompt. The yyhook _b () lets you enable or disable the 
run-time trace feature discussed along with the gen () subroutine, below, from the 
debugger. 
Section 6.4-The Parser: Configuration 
Listing 6.35. c.y-occs Input File: Initialization and Cleanup 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 enum union_fields { NONE, P_SYM, P_LINK, P_SDEF, P_FIELD, P_SPEC, 
P_CHAR, P_VALUE, SYM_CHAIN, ASCII, NUM 
typedef struct tabtype 
{ 
char *sym; 
anum union fields case_val; 
tabtype; 
tabtype Tab[] 
{ 
/* 
/* non terminal 
name 
"ASSIGNOP", 
"CLASS", 
"DIVOP" I 
"EQUOP", 
"INCOP" I 
"NAME", 
"RELOP", "SHIFTOP", 
"STRUCT" 
I 
"STRUCTOP", "TTYPE" 
I 
"UNOP", 
"abs decl", 
"abstract_ decl", 
"and_expr", 
"and_ list", 
"args", 
"binary", 
"const_expr", 
"decl", 
"decl_list", 
"def", 
"def_list", 
"enumerator", 
"expr", 
"ext_decl", 
"ext decl_list", 
"funct_decl", 
"initializer", 
"initializer_list", 
"local_defs", 
"name", 
"name_list", 
"new_name", 
"non_comma_expr", 
"opt_specifiers", 
"opt_tag", 
"or_expr", 
"or list", 
"param_declaration", 
"specifiers", 
"string_const", 
"struct_specifier", 
"tag", 
"test", 
"type", field 
in %union 
ASCII 
ASCII 
ASCII 
ASCII 
ASCII 
P SYM 
ASCII 
ASCII 
ASCII 
ASCII 
P SYM 
ASCII 
P SYM 
P SYM 
P VALUE 
P VALUE 
NUM 
P VALUE 
NUM 
P SYM 
SYM CHAIN 
SYM CHAIN 
SYM CHAIN 
P SYM 
P VALUE 
P SYM 
SYM CHAIN 
P SYM 
P VALUE 
P VALUE 
SYM CHAIN 
P SYM 
SYM CHAIN 
P SYM 
P VALUE 
P LINK 
P SDEF 
P VALUE 
P VALUE 
SYM CHAIN 
P LINK 
P CHAR 
P SDEF 
P SDEF 
NUM 
P LINK *I 
*I 
}, 
} I 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, }, }, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, }, 
}, 
}, 
}, 
}, 
}, 
}, }, }, 
}, 
}, 
}, 
}, 
}, }, }, 
}, 
}, 
}, 
}, 515 
} ; 
.... 
516 Code Generation -Chapter 6 
Listing 6.35. continued ... 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 } ; "type_or_class", 
"type_specifier", 
"unary", 
"var_decl", 
"var_list", 
"{72}", 
"{73}", 
temp( p1, p2 
tabtype *p1, *p2; 
{ P LINK 
P LINK 
P VALUE 
P SYM 
SYM CHAIN 
NUM 
P VALUE } , 
} , 
} , 
} , 
} , 
} , 
} 
return( strcmp(p1->sym, p2->sym) ) ; 
char 
yystype 
char *yypstk( v, name ) 
*v; 
*name; 
static char buf[128]; 
char 
tabtype *text; 
*tp, template; 
template.sym =name; /* Pointer to value-stack item. */ 
/* Pointer to debug-stack item. */ 
tp = (tabtype *) bsearch( &template, Tab, sizeof(Tab)/sizeof(*Tab), 
sizeof(*Tab), temp); 
sprintf( buf, "%04x ", v->num ); 
text = buf + 5; /* The first four characters in the */ 
/* string are the numeric value of */ 
/* the current stack element. */ 
/* Other text is written at "text". */ 
switch( tp ? tp->case_va1 
{ 
case SYM CHAIN: NONE ) 
sprintf ( text, "sym chain: %s"·, 
v->p_sym? sym_chain_str(v->p_sym) "NULL" ) ; 
case P SYM: 
case P SPEC: break; 
if ( ! v->p sym ) 
sprintf( text, "symbol: NULL" ); 
else if( IS_FUNCT(v->p_sym->type) 
else sprintf ( text, "symbol: %s (%s) =%s %1. 40s", 
v->p_sym->name, 
sym_chain_str( v->p_sym->args ), 
v->p_sym->type && *(v->p_sym->rname) ? 
v->p_sym->rname 
type str(v->p_sym->type) ); 
sprintf ( text, "symbol: %s=%s %1. 40s", 
v->p_sym->name, 
v->p_sym->type && *(v->p_sym->rname) ? 
v->p_sym->rname 
type_str(v->p_sym->type) ) ; 
break; 
if( !v->p_spec ) 
sprintf( text, "specifier: NULL" ); 1111 , 
.... 
Section 6.4-The Parser: Configuration 517 
Listing 6.35. continued ••. 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 case P LINK: 
case P VALUE: 
case P SDEF: 
case P CHAR: 
case NUM: 
case ASCII: 
return buf; else 
sprint£( text, "specifier: %s %s", attr_str( v->p_spec ), 
noun_str( v->p_spec->noun) ); 
break; 
if( !v->p_link ) 
sprint£( text, "specifier: NULL" ); 
else 
sprint£( text, "link: %1.50s", type_str(v->p_link) ); 
break; 
if( !v->p_val ) 
sprint£( text, "value: NULL"); 
else 
{ 
sprint£( text, "%cvalue: %s %c/%u %1.40s", 
v->p_val->lvalue ? '1' 
*(v->p_val->name) ? v->p_val->name 
v->p_val->is_tmp ? 't' 
v->p_val->offset, 
type_str( v->p_val->type) ); 
break; 
if( !v->p_sdef ) 
sprint£( text, "structdef: NULL" ); 
else 'r' ' "--" I 
'v' ' 
sprint£( text, "structdef: %s lev %d, size %d", 
v->p_sdef->tag, 
v->p_sdef->level, 
v->p_sdef->size); 
break; 
if( !v->p_sdef ) 
sprint£( text, "string: NULL" ); 
else 
sprint£( text, "<%s>", v->p_char ); 
break; 
sprint£ ( text, "num: %d", v->num ) ; 
break; 
sprint£( text, "ascii: '%s'", bin_to_ascii(v->ascii, 1) ); 
break; 
518 Code Generation -Chapter 6 
Listing 6.36. main.c-main () and a Symbol-Table-Printing Hook 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 #include <tools/debug.h> 
int main( argc, argv 
char **argv; 
UX( yy_init_occs(); /* Needed for yacc, called automatically by aces. */ 
argc = yy_get_args ( argc, argv ) ; 
if( argc > 2 ) 
enable_trace (); 
yyparse (); /* Generate trace if anything follows file name on */ 
/* command line. */ 
1*----------------------------------------------------------------------*l 
yyhook a() /* Print symbol table from debugger with ctrl-A. */ 
{ - /* Not used in yacc-generated parser. */ 
static int 
char 
sprintf 
yycomment 
print_syms X = 0; 
buf[32]; 
buf, "sym.%d", x++ ); 
"Writing symbol table to %s\n", buf ); 
buf ); 
yyhook_b() /* Enable/disable run-time trace with Ctrl-b. *I 
{ /* Not used in yacc-generated parser. 
/* enable trace() and disable trace() are discussed 
/* below, when the gen () call is discussed. 
char buf[32]; 
if ( yyprompt ( "Enable or disable trace? (e/d) : ", buf, 0 ) ) 
{ 
if( *buf == 'e' ) enable_trace(); 
else disable_trace(); 
6.5 The Lexical Analyzer *I 
*I 
*I 
Now that we've seen the tokens and the value-stack definition, we can look at the 
lexical analyzer specification (in Listing 6.37). This file is essentially the analyzer at the 
end of Appendix D, but it's been customized for the current parser by adding an 
attribute-passing mechanism. The union on lines 18 to 28, which reflects the %union 
definition in the occs input file, is used to pass attributes back to the parser. For example, 
when an ASSIGNOP is recognized on line 115, the first character of the lexeme is 
attached to the token by assigning a value to yy 1 val, which is of the same type as a 
value-stack element. (The union definition on lines 18 to 28 doubles as an extern 
definition ofyylval.) The parser pushes the contents ofyylval onto the value stack 
when it shifts the state representing the token onto the state stack. 
Also note that a newline is now recognized explicitly on line 132. The associated 
action prints a comment containing the input line number to the compiler's output file so 
that you can relate one to the other when you're debugging the output. You could also 
Section 6.5-The Lexical Analyzer 
use this action to pass input-line-number information to a debugger. 
Listing 6.37. c./ex-C Lexical Analyzer 
I 
2 
3 
4 
5 
6 
7 
8 
9 I* Lexical analyzer specification for C. This is a somewhat extended version 
* of the one in Appendix D. The main difference is that it passes attributes 
* for some tokens back to the parser, using the yylval mechanism to push 
* the attribute onto the value stack. 
*I 
%{ 
#include 
#include 
#include 
#include #include 
#include 
#include #include 
#include <stdio.h> 
<search.h> 
<toolsldebug.h> 
<toolslhash.h> 
<toolsll.h> I* Function prototype for bsearch(). 
I* Needed by symtab.h. 
I* Needed by symtab.h. 
<toolslcompiler.h> *I 
*I *I 
"yyout.h" I* Token defs. created by aces. Yacc uses y.tab.h. *I 
"symtab.h" I* Needed to pass attributes to parser. *I 
"value.h" I* ditto *I 
I* This definition must duplicate the %union *I 519 
10 
II 
12 
13 
14 
15 
16 17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 extern union 
char 
symbol 
link 
structdef 
specifier 
value *p_char; 
*p_sym; 
*p_link; 
*p_sdef; 
*p_spec; 
*p_value; 
integer; 
ascii; I* in c.y. *I 
int 
int 
yylval; I* Declared by aces in yyout.c. *I 
extern FILE *yycodeout; I* Declared by aces in yyout.c *I 
l*----------------------------------------------------------------------*1 
#define YYERROR(text) yyerror("%s\n", text); I* Does nothing in UNIX lex. *I 
1*----------------------------------------------------------------------*l 
%} 
let 
alnum 
h 
0 
d 
suffix 
white 
%% 
"/*" [ a-zA-Z] I* Letter *I -
[ a-zA-Z0-9] I* Alphanumeric character *I 
[0-9a-fA-F] I* Hexadecimal digit 
[0-7] I* Octal digit 
[0-9] I* Decimal digit 
[UuLl] I* Suffix in integral 
[\x00-\x09\x0b\s] I* White space: 
int i; 
while ( i 
{ ii_input () 
if( i < 0 ) 
ii_flushbuf (); *I 
*I *I 
numeric constant *I 
all control chars but \n *I 
I* Discard lexeme. *I 
.... 
520 Code Generation -Chapter 6 
Listing 6.37. continued .•• 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 else if( i == '*' && ii_lookahead(l) , I, ) 
ii_input (); 
break; /*Recognized comment.*/ 
if ( i == 0 ) 
yyerror( "End of file in comrnent\n" ); 
\"(\\.I[-\"])*\" return STRING; } 
\"(\\.I [-\"])*\n yyerror("Adding missing\" to string constant\n"); 
yymore(); 
O{o}*{suffix}? 
Ox{h}+{suffix}? 
[1-9] {d}*{suffix}? return ICON ; 
({d)+ I {d)+\. {d)* I {d)*\. {d)+) ( [eE] [-+]?{d)+)? [fF]? return FCON 
"(" 
")" 
" {" 
"}" 
II[" 
"]" 
"->" 
"++" 
"--" 
"*" 
[ /%] 
"+" 
"-" 
<<I>> 
[<>]=? 
[ !=]= return LP; 
return RP; 
return LC; 
return RC; 
return LB; 
return RB; 
yylval.ascii = *yytext; 
return STRUCTOP; 
yylval.ascii *yytext; 
return INCOP; 
yylval.ascii *yytext; 
return UNOP; 
return STAR; 
yylval.ascii *yytext; 
return DIVOP; 
return PLUS; 
return MINUS; 
yylval.ascii = *yytext; 
return SHIFTOP; 
yylval.ascii = yytext[l] ? (yytext[O]=='>' ? 'G' 
(yytext[O] 
return RELOP; 
yylval.ascii = *yytext; 
return EQUOP; 'L') 
) ; 
Section 6.5-The Lexical Analyzer 521 
Listing 6.37. continued ... 
[*/%+\-&1-l= 
(«I»)= 
"=" 
"&" 
"I" 
"&&" 
" I I " 
"?" ..... 
II II , 
";" 
{let} { alnum} * 
\n 
{white}+ 
%% yylval.ascii = *yytext; 
return ASSIGNOP; 
return EQUAL; 
return AND; 
return XOR; 
return OR; 
return ANDAND; 
return OROR; 
return QUEST; 
return COLON; 
return COMMA; 
return SEMI; 
return ELLIPSIS; 
return id_or_keyword( yytext ); 
fprintf(yycodeout, "\t\t\t\t\t\t\t\t\t/*%d*/\n", yylineno); /* ignore other white space */ 114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 1*------------------------------------------------------------------*l 
typedef struct 
{ 
char *name; 
int val; 
KWORD; 
KWORD Ktab[] 
{ 
"auto", 
"break", 
"case", 
"char", 
"continue", 
"default", 
"do", 
"double", 
"else", 
"enum", 
"extern", 
"float", 
"for", 
"goto", 
"if", 
"int", 
"long", 
"register", 
"return", 
"short", 
"sizeof", 
"static", 
"struct", 
"switch", 
"typedef", 
"union", 
"unsigned", CLASS 
BREAK 
CASE 
TYPE 
CONTINUE 
DEFAULT 
DO 
TYPE 
ELSE 
ENUM 
CLASS 
TYPE 
FOR 
GOTO 
IF 
TYPE 
TYPE 
CLASS 
RETURN 
TYPE 
SIZEOF 
CLASS 
STRUCT 
SWITCH 
CLASS 
STRUCT 
TYPE /* Routines to recognize keywords */ 
/* Alphabetic keywords */ 
}, 
}, 
}, 
}, 
}, 
}, 
}, }, 
}, 
}, 
}, }, }, 
}, }, 
}, 
}, 
}, }, 
}, }, 
}, 
}, 
}, 
}, }, }, 
522 Code Generation -Chapter 6 
Listing 6.37. continued ••• 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 } ; "void", 
{ "while", TYPE 
WHILE } , 
} 
static int cmp( a, b ) 
KWORD *a, *b; 
{ 
int 
char 
{ return strcmp( a->name, b->name ); 
id_or_keyword( lex ) /* Do a binary search for a *I 
*lex; /* possible keyword in Ktab *I 
/* Return the token if it's *I 
KWORD *p; /* in the table, NAME *I 
KWORD dummy; /* otherwise. *I 
dummy.name lex; 
p = bsearch( &dummy, Ktab, sizeof(Ktab)/sizeof(KWORD), sizeof(KWORD), cmp); 
if( p ) /* It's a keyword. *I 
{ 
yylval.ascii *yytext; 
return p->val; 
else if( yylval.p_sym = (symbol *) findsym( Symbol_tab, yytext ) ) 
return (yylval.p_sym->type->tdef) ? TTYPE : NAME ; 
else 
return NAME; 
6.6 Declarations 
6.6.1 Simple Variable Declarations 
This section moves from data structures to analyzing the code that manipulates those 
data structures. Declaration processing involves two main tasks: (1) you must assemble 
the linked lists that represent the types, attach them to symbols, and put the resulting 
structures into the symbol table, and (2) you must both generate C-code definitions for 
variables at fixed addresses and figure the frame-pointer-relative offsets for automatic 
variables. Many of the productions in the grammar work in concert to produce a single 
definition. Since these productions are discussed piecemeal, you should take a moment 
and look at the overall structure of the grammar in Appendix C. The declarations are all 
handled first, at the top of the grammar. 
An example variable· 
declaration parse. The best way to understand how the code generation works is to follow along as the 
parser works on an explicit example. (This is also a good approach for adding the code­
generation actions in the first place: run a short sample through the parser observing the 
order in which reductions occur. Since actions at the far right of productions are exe­
cuted in the same sequence as the reductions, you can see where the various actions need 
to be placed.) I'll use the following input to demonstrate simple declarations: 
long int *x, y; 
The parse of that input is shown, in symbolic form, in Table 6.13.14 
Section 6.6.1-Simple Variable Declarations 
Table 6.13. A Parse of long int * x, y; 
Stack Next Action Taken by Parser 
I (empty) Reduce by ext_ def_list ---7E 
2 ext_ def_list Shift TYPE (long) 
3 ext def list TYPE Reduce by type specifier-? TYPE 
4 ext def list type specifier Reduce by type or class -?type specifier 
5 ext_ def_list type _or_ class Reduce by specifiers---7type _or_ class 
6 ext_ def_list specifiers Shift TYPE (int) 
7 ext_def_list specifiers TYPE Reduce by type _specifier-? TYPE 
8 ext def list specifiers type specifier Reduce by type or class -?type specifier 
9 ext def list specifiers type or class Reduce by specifiers---?specifiers type or class 
10 ext def list specifiers Reduce by opt specifiers---?specifiers 
II ext_ def_list opt _specifiers Shift STAR 
12 ext_ def_list opt _specifiers STAR Shift NAME (x) 
13 ext def list opt specifiers STAR NAME Reduce by new name-? NAME 
14 ext def list opt specifiers STAR new name Reduce by var dec/---?new name 
15 ext_ def_list opt _specifiers STAR var _dec/ Reduce by var_dec/---?STAR var_decl 
16 ext_ def_list opt_ specifiers var_ dec/ Reduce by ext_ dec/---?var _dec/ 
17 ext def list opt specifiers ext dec/ Reduce by ext dec/ list -?ext dec/ 
18 ext def list opt specifiers ext dec/ list Shift COMMA 
19 ext def list opt specifiers ext dec! list COMMA Shift NAME (y) 
20 ext_ def_list opt _specifiers ext_ decl_list COMMA NAME Reduce by new_ name-? NAME 
21 ext_def_list opt_specifiers ext_dec/_list COMMA new _name Reduce by var _ dec/---?new _name 
22 ext def list opt specifiers ext dec/ list COMMA var dec/ Reduce by ext dec/ ---?var dec/ 
23 ext def list opt specifiers ext dec/ list COMMA ext dec/ Reduce by ext dec/ list---?ext dec/ list COMMA ext dec/ 
24 ext_ def_list opt _specifiers ext_ decl_list Reduce by { 3 } ---7E 
25 ext_def_list opt_specifiers ext_decl_list { 3} Shift SEMI 
26 ext_ def_list opt _specifiers ext_ decl_list { 3} SEMI Reduce by ext_def---?opt_specifiers ext_dec/_list { 3} SEMI 
27 ext def list ext def Reduce by ext def list -?ext def list ext def 
28 ext def list Reduce by program---?ext def list (accept) 
Since all actions are performed as part of a reduction, the best way to see how the code 
works is to follow the order of reductions during the parse. First, notice how the E pro­
duction in 
ext def list 
ext def list ext def 
I /* epsilon */ 
(on line 189 of Listing 6.38) is done first. This is always the case in left-recursive list 
productions: the nonrecursive component (whether or not it's E) must be reduced first in 
order to put the recursive left-hand side onto the stack. 15 In the current example, the 
14. If you have the distribution disk mentioned in the Preface, you can use the visible parser to see the parse 
process in action. The file c.exe is an executable version of the compiler described in this chapter. Get the 
parse started by creating a file called test.c containing the single line: 
long int *x, y; 
Then invoke the parser with the command: c test. c. Use the space bar to singlestep through the parse. 
15. The nonrecursive element of a ~-recursive list production is always done last. 523 
524 Code Generation -Chapter 6 
parser must get an ext_ def_list onto the stack in order to be able to reduce by 
ext_def_list~ext_def_list ext_def at some later time, and the only way to get that initial 
ext_ def_list onto the stack is to reduce by ext_ def_list~£. 
Listing 6.38. c.y-Initialization and Cleanup Productions 
%% 
program ext def list clean up(); 
ext def list 183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 ext def list ext def 
/* epsilon */ 
{ 
lnitializations done in 
nonrecursive list element. 
Generate SEG directives. 
SpecHier processing. 
Pointer to link used as 
an attribute. yydata( 
yydata( 
yydata ( 
yycode ( 
yybss ( "#include <tools/virtual.h>\n" ) ; 
"#define T(x)\n" ); 
"SEG(data)\n" 
"\nSEG(code)\n" 
"\nSEG(bss)\n" ) ; 
) ; 
) ; 
Syntactically, a program is a list of external definitions because of the productions on 
lines 187 to 189 of Listing 6.38. A reduction by the £ production on line 189 is always 
the first action taken by the parser, regardless of the input. This behavior is exploited in 
the current compiler to do various initializations on lines 189 to 196 of Listing 6.38. The 
appropriate SEG directives are generated at the tops of the various segments, and a 
#include for <tools!virtual.h> is output at the top of the data segment, which is at the 
top of the output file after the three segments are combined at the end of the compilation. 
I'll discuss the empty T ( ) macro on line 192 in a moment. 
The associated cleanup actions are all done in the previous production: 
program: ext def list { clean up(); } 
on line 184. Remember, this is a bottom-up parser, so the reduction to the goal symbol is 
the last action taken by the parser. The clean_ up () action coalesces the output 
streams and deletes temporary files. 
After initializing via the £production, the parser starts processing the specifier com­
ponent of the declaration. All of the specifier productions are shown together in Listing 
6.39. Three types of specifier lists are supported: 
opt specifiers 
specifiers 
type Zero or more types and storage classes mixed together. 
One or more types and storage classes mixed together. 
One or more types. (No storage classes are permitted.) 
Note that the parser is not checking semantics here. It just recognizes collections of pos­
sible types and storage classes without testing for illegal combinations like a short 
long. 
The parser starts by shifting the TYPE token (long in the current input) and then 
reduces type _specifier~ TYPE (on line 229 of Listing 6.39). The associated action 
calls new_ type_ spec (),which gets a new link and initializes it to a specifier of the 
correct type. A pointer to the 1 ink structure is attached to the type _specifier by assign­
ing it to $$. From here on out, that pointer is on the value stack at the position 
corresponding to the type _specifier. If a storage class is encountered instead of a TYPE, 
the action on line 226 of Listing 6.39 is executed instead of the action on line 189. This 
action modifies the storage-class component of the 1 ink rather than the type, but is 
Section 6.6.1 -Simple Variable Declarations 
Listing 6.39. c.y-Specifiers 
opt_specifiers 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 : CLASS TTYPE set_class_bit( 0, $2->etype ); /*Reset class. */ 
set_class_bit( $1, $2->etype ); /*Add new class. */ 
$$ = $2->type ; 
I TTYPE set_class_bit(O, $1->etype); /*Reset class bits.*/ 
$$ = $1->type ; 
specifiers 
/* empty */ 
specifiers 
type_or_class $$ 
$$->class 
$$->NOUN new_link(); 
SPECIFIER; 
INT; 
specifiers type_or_class spec_cpy( $$, $2 ); 
discard_link_chain( $2 ); } 
type 
type_specifier 
type type_specifier 
type_or_class 
type_specifier 
I CLASS 
type specifier 
TYPE 
enum specifier 
struct_specifier spec_cpy( $$, $2 ); 
discard_link chain( $2 ); } 
$$ new_class_spec( $1 ) ; 
$$ new_type_spec( yytext ); 
$$ new_type_spec( "int" ); 
$$ new_link(); 
$$->class SPECIFIER; 
$$->NOUN STRUCTURE; 
$$->V_STRUCT $1; 
otherwise the same as the earlier one. Both new_type_spec () and new_class -
spec ( ) are in Listing 6.40. 
The next reductions are type _or _class~ type _specifier and specifiers~ 
type_or _class, neither of which has an associated action. The pointer-to-link attribute 
is carried along with each reduction because of the default $$=$1 action that is supplied 
by the parser. The pointer to the link created in the initial reduction is still on the value 
stack, but now at the position corresponding to the specifiers nonterminal. 
The parser now processes the int. It performs the same set of reductions that we 
just looked at, but this time it reduces by 
specifiers~ specifiers type_ or_ class 
rather than by 
specifiers~type _or_ class 
as was done earlier. (We're on line nine of Table 6.13. The associated action is on lines %prec COMMA 
type_ or_ class~ 
type_specifier 
specifiers~ 
type_ or_ class 525 
526 Code Generation -Chapter 6 
Listing 6.40. decl.c-Create and Initialize a link 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 #include <stdio.h> 
linclude <stdlib.h> 
linclude <tools/debug.h> 
linclude <tools/hash.h> 
#include <tools/l.h> 
#include <tools/compiler.h> 
#include <tools/c-code.h> 
#include "symtab.h" 
#include "value.h" 
linclude "proto.h" 
/* DECL.C 
* This file contains support subroutines for those actions in c.y 
that deal with declarations. 
*I 
extern void yybss(), yydata(); 
/*----------------------------------------------------------------------*/ 
PUBLIC 
int 
{ link *new_class_spec( first char of lexeme 
first_char_of_lexeme; 
/* Return a new specifier link with the sclass field initialized to hold 
* a storage class, the first character of which is passed in as an argument 
* ('e' for extern, 's' for static, and so forth). 
*I 
link *p = new_link(); 
p->class = SPECIFIER; 
set_class_bit( first char_of_lexeme, p ); 
return p; 
/*----------------------------------------------------------------------*/ 
PUBLIC void set_class_bit( first_char_of_lexeme, p) 
int 
link 
{ first_char_of_lexeme; 
*p; 
/* Change the class of the specifier pointed to by p as indicated by the 
* first character in the lexeme. If it's 0, then the defaults are 
*restored (fixed, nonstatic, nonexternal). Note that the TYPEDEF 
* class is used here only to remember that the input storage class 
* was a typedef, the tdef field in the link is set true (and the storage 
* class is cleared) before the entry is added to the symbol table. 
*I 
switch( first char of lexeme 
{ 
case 0: p->SCLASS 
p->STATIC 
p->EXTERN 
break; 
case 't': p->SCLASS 
case 'r': p->SCLASS FIXED; 
0; 
0; 
TYPEDEF 
REGISTER break; 
break; 
.... 
Section 6.6.1 -Simple Variable Declarations 
Listing 6.40. continued ... 
case 's': p->STATIC 
case 'e': p->EXTERN 1 
1 break; 
break; 527 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 98 
99 default : yyerror("INTERNAL, set class bit: bad storage class '%c'\n", 
first_char_of_lexeme) ; 
exit ( 1 ) ; 
break; 
/*----------------------------------------------------------------------*/ 
PUBLIC 
char 
{ link *new_type_spec( J.exeme ) 
*lexeme; 
/* Create a new specifier and initialize the type according to the indicated 
* lexeme. Input lexemes are: char canst double float int long short 
* signed unsigned void volatile 
*I 
link *p 
p->class new_link (); 
SPECIFIER; 
switch( lexeme[O] ) 
{ 
case , c': if( lexeme[l]=='h' 
p->NOUN = CHAR 
break; 
case 'd': 
case , f': yyerror ("No floating point\n"); 
break; 
case I i'! p->NOUN INT; break; 
case , 1': p->LONG 1; break; 
case 'u': p->UNSIGNED 1; break; 
case 'v': if( lexeme[2] I i' 
p->NOUN VOID; 
break; /* char I canst 
/* (Ignore canst.) 
/* double *I 
/* float *I 
/* int *I 
/* long *I 
/* unsigned *I 
/* void I volatile 
/* ignore volatile *I 
*I 
*I 
*I 
case , s': break; /* short I signed *I 
100 
101 return p; /* ignore both 
216 to 217 of Listing 6.39.) There are currently three attributes of interest: $1 and$$ 
(which is initialized to $1 by the parser before executing the action) hold a pointer to the 
link structure that was assembled when the long was processed; $2 points at the link 
for the new list element-the int. The action code merges the two structures by copy­
ing all relevant fields from $2 to $$. The second link ($2) is then discarded. The 
action is illustrated in Figure 6.14. 
If additional types or storage classes are present in the input, the parser loops some 
more, creating new links for each new list element and merging those new links into 
the existing one, discarding the new link after it's merged. 
Having collected the entire specifier list, the parser now reduces by opt_specifiers 
opt _specifiers~specifiers on line 206 of Listing 6.40. There is no action. If the *I 
528 
TIVPE, processing a 
typeclef. 
Declarator processing. 
Identifier processing in 
declaration, 
new_name-+NAME. Code Generation -Chapter 6 
Figure 6.14. Merging Links 
(Before) 
type_ or_ class 
(After) specifiers 
ext_ de!_ list 
Parse 
Stack 
specifiers 
ext_ def_list 
Parse 
Stack link: 
class=SPECIFIER 
I noun = INT 
"~,...li_nk-'--: __ _ 
~ class=SPECIFIER 
Value 
Stack _long = 1 
r------------------------, 
1 link: 
class=SPECIFIER (This link 
I is deleted.) _long = 1 
I I '--L------------------------' 
"" link: 
Value 
Stack I 'ol class=SPECIFIER 
noun = INT 
_long = 1 
declaration were in terms of a typedef, opt_specifiers~TTYPE (just above the current 
production on line 203 of Listing 6.40) is executed instead of the list-collecting reduc­
tions we just looked at. The scanner attaches an attribute to the TTYPE token: a pointer 
to a symbol structure representing the typedef. The name field in the symbol is the 
type name rather than a variable name. The action on line 204 of Listing 6.40 passes the 
type string for this symbol back up the stack as opt_specifiers' attribute. This type 
chain differs from a normal one only in that the tdef bit is set in the leftmost link in 
the chain. The parser needs this information because a type that comes from a typedef 
could be an entire chain, including the declarators. A non-typedef declaration always 
yields a single specifier. If no specifier at all is present, then the action on lines 207 to 
2I2 of Listing 6.40 is executed. 16 This action just sets up things as if an int had been 
found in the input. 
The parser shelves the specifier on the value stack for a moment to move on to the 
declarator component of the declaration-it stores a pointer to the accumulated specifier 
link on the value stack as an attribute attached to the most recently pushed specifier 
nonterminal. Declarator processing starts with a shift of the STAR and NAME tokens 
on lines II and I2 of Table 6.I3 on page 523. The parser then starts reducing by the pro­
ductions in Listing 6.4I, below. 
The first reduction is new_ name~NAME. The action is on line 282 of Listing 6.4I. 
There are two name productions to take care of two different situations in which names 
16. x;, with no explicit type, is a perfectly legitimate declaration, the default int type and extern storage 
classes are used. 
Section 6.6.1 -Simple Variable Declarations 529 
Listing 6.41. c.y-Variable Declarators 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 288 var decl 
new name %prec COMMA /* This production is done first. */ 
var decl LP RP 
var decl LP var list RP 
var decl LB RB add_declarator( $$, FUNCTION); 
add_declarator( $$, FUNCTION ) ; 
discard_symbol_chain( $3 ); 
/* At the global level, this must be treated as an array of 
* indeterminate size; at the local level this is equivalent to 
* a pointer. The latter case is patched after the declaration 
* is assembled. 
*I 
add_declarator( $$, ARRAY ) ; 
$$->etype->NUM_ELE = 0; 
YYD ( yycomment ("Add POINTER specifier\n"); ) 
var_decl LB const_expr RB 
add_declarator( $$, ARRAY); 
$$->etype->NUM_ELE = $3; 
YYD(yycomment("Add array[%d] spec.\n", $$->etype->NUM_ELE) ;) 
STAR var decl 
{ %prec UNOP 
add_declarator( $$ = $2, POINTER ) ; 
YYD( yycomment("Add POINTER specifier\n"); 
LP var decl RP { $$ $2; ) 
/*----------------------------------------------------------------------
* Name productions. new_name always creates a new symbol, initialized with the 
* current lexeme. Name returns a preexisting symbol with the associated name 
* (if there is one); otherwise, the symbol is allocated. The NAME token itself 
* hds a NULL attribute if the symbol doesn't exist, otherwise it returns a 
*pointer to a "symbol" for the name. 
*I 
new name: NAME $$ new_symbol( yytext, Nest lev); 
name NAME if( !$1 I I $1->level != Nest_lev ) 
$$ = new_symbol( yytext, Nest lev); 
are used. Normally, the scanner looks up all identifiers in the symbol table to see 
whether or not they represent types so that it can return a TTYPE token when appropri­
ate. In order to avoid unnecessary lookups, the scanner attaches a symbol-table pointer 
for an existing identifier to the NAME token if the identifier is in the table, otherwise the Interaction between 
scanner and code gen­
erator via symbol table. 
530 
name~NAME. 
Nest lev. Code Generation -Chapter 6 
attribute is NULL. This way the table lookup doesn't have to be done a second time in 
the code-generation action. The new_ name takes care of newly-created identifiers. It 
ignores this passed-back symbol pointer, and allocates a new symbol structure, passing 
a pointer to the symbol back up the parse tree as an attribute attached to the new _name 
nonterminal. The name~NAME action (on lines 285 to 286, of Listing 6.41) uses the 
existing symbol. The test on line 285 identifies whether the returned symbol is at the 
current scoping level. If it is not, then the parser assumes that this is a new symbol (such 
as a local variable) that just happens to have the same name as an existing one, and allo­
cates a new symbol structure. Nest lev keeps track of the current scope level; it is 
declared in Listing 6.42, which is part of the occs-input- file definitions section. 
Listing 6.42. c.y-Identify Nesting Level (from Occs Definitions Section) 
119 % { 
120 int Nest_lev; /* Current block-nesting level. *I 
121 %} 
var_dcl~ new_name. 
var_decl ~STAR 
var_decl. 
add_declarator(). 
var_decl 
Dummy const_expr pro­
duction used for grammar 
development. The next reduction, on line 15 of Table 6.13 on page 523), is var_dcl~new_name. 
The production is on line 238 of Listing 6.42. The only action is the implicit $$=$1, 
which causes the symbol pointer returned from new _name to be passed further up the 
tree, attached to the var _del. The %prec at the right of the line eliminates a shift/reduce 
conflict by assigning a very low precedence to the current production-the technique is 
discussed in Appendix E. 
The parser reduces by var_decl~STAR var_decl next. (We're moving from line 15 
to line 16 of Table 6.13 on page 523-the action is on line 265 of Listing 6.42.) The 
action calls add_declarator () to add a pointer-declarator link to the type chain in 
the symbol that was created when the name was processed. The process is similar to 
that used to assemble an NFA in Chapter Two. Figure 6.15 shows the parse and value 
stacks both before and after this reduction is performed. 
Note that the synthesized attribute for every right-hand side of this production is the 
same symbol structure that was allocated when the name was processed. The actions 
just add link structures to the symbol's type chain. 
If the declaration had been int * * x, both stars would have been shifted initially, 
and the current reduction would have executed twice in succession, thereby adding a 
second pointer-declarator link to the end of the type chain in the symbol structure. 
The other productions that share the var _dec/ left-hand side do similar things, adding 
declarator links either for arrays or for functions, as appropriate, to the end of the type 
chain in the current symbol structure. Note that the actions on lines 240 to 243 handle 
the "function" component of a function-pointer declaration. I'll look at function 
declarations, including the var _list non terminal, in a moment-briefly, the var _list takes 
care of function prototypes; the associated attribute is a pointer to the head of a linked 
list of symbol structures, one for each function argument. The action here just discards 
all the symbols in the list. Similarly, const_expr (on line 258) handles integer-constant 
expressions. This production is also discussed below, but the associated attribute is an 
integer. I'm using the <num> field in the value-stack union to hold the value. 
As an aside, a minor problem came up when adding the actions to the grammar-you 
can't do the expression-processing actions until the declarations are finished, but you 
need to use a constant expression to process an array declaration. I solved the problem 
by providing a dummy action of the form: 
Section 6.6.1 -Simple Variable Declarations 
Figure 6.15. Adding Declarators to the Type Chain 
symbol: 
var dec/ ...__ 
~ name="x" -
type (Before) 
STAR etype 
opt _specifiers '- link: 
ext_ def_list ~ class=SPECIFIER 
I noun = INT 
I _long = 1 
(After) 
symbol: link: 
name="x" class=DECLARATOR 
l.----'?' type 
dcl_cype='o''"'•l~ var dec/ .--- etype 
~ 
opt _specifiers ' "'--
~link: 
ext_ def_list class=SPECIFIER 
I I noun = INT 
-long = 1 
const_expr : expr { $$ = 10; } 
until the declarations were working. The action was later replaced with something more 
reasonable. 
When the parser finishes with the declarator elements (when the lookahead is a 
COMMA), the type chain in the symbol structure holds a linked list of declarator 
links, and the specifier is still on the value stack at a position corresponding to the 
opt_specifiers nonterminal. The comma is shifted, and the parser goes through the entire 
declarator-processing procedure again for they (on lines 20 to 23 of Table 6.13 on page 
523). 
Now the parser starts to create the cross links for symbol-table entry-the links that 
join declarations for all variables at the current scoping level. It does this using the pro­
ductions in Listing 6.43. The first reduction of interest is ext_decl_list~ext_decl exe­
cuted on line 17 of Table 6.13. The associated action, on line 298 of Listing 6.43, puts a 
NULL pointer onto the value stack. This pointer marks the end of the linked list. The 
parse proceeds as just described, until the declaration for y has been processed, whereu­
pon the parser links the two declarations together. The parse and value stacks, just 
before and just after the reduction by: 
ext dec/ list~ext dec/ list COMMA ext dec/ -- - -
are shown in Figure 6.16. and the code that does the linking is on lines 308 to 313 of 
Listing 6.43. If there were more comma-separated declarators in the input, the process 
would continue in this manner, each successive element being linked to the head of the 
list in tum. 531 
Create cross links. 
ext_decUist ~ ext_decl. 
ext_decUist~ 
ext_ decUist 
COMMA ext_dec/. 
532 Code Generation -Chapter 6 
Listing 6.43. c.y-Function Declarators 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 1*----------------------------------------------------------------------
* Global declarations: take care of the declarator part of the declaration. 
* (The specifiers are handled by specifiers). 
* Assemble the declarators into a chain, using the cross links. 
*I 
ext decl list 
ext decl ext decl 
$$->next = NULL; 
ext decl list COMMA ext decl 
{ I* First link in chain. *I 
I* Initially, $1 and $$ point at the head of the chain. 
* $3 is a pointer to the new declarator. 
*I 
$3->next $1; 
$$ $3; 
var decl 
var decl EQUAL initializer { $$->args 
funct decl (symbol *) $3; } 
lnitializers, symbol.args. The only other issue of interest is the initializer, used on line 313 of Listing 6.43. I'll 
defer discussing the details of initializer processing until expressions are discussed, but 
the attribute associated with the initializer is a pointer to the head of a linked list of 
structures that represent the initial values. The args field of the symbol structure is 
used here to remember this pointer. You must use a cast to get the types to match. 
Function declarators, 
funcLdec/. 
Function-argument de­
clarations. Before proceeding with the sample parse, it's useful to back up a notch and finish 
looking at the various declarator productions. There are two types of declarators not 
used in the current example, function declarators and abstract declarators. The 
function-processing productions start in Listing 6.44. First, notice the funct _dec! pro­
ductions are almost identical to the var _dec/ productions that were examined earlier. 
They both assemble linked lists of declarator links in a symbol structure that is passed 
around as an attribute. The only significant additions are the right-hand sides on lines 
329 to 341, which handle function arguments. 
The same funct _dec/ productions are used both for function declarations (externs 
and prototypes) and function definitions (where a function body is present)-remember, 
these productions are handling only the declarator component of the declaration. The 
situation is simplified because prototypes are ignored. If they were supported, you'd 
have to detect semantic errors such as the following one in which the arguments don't 
have names. The parser accepts the following input without errors: 
foo( int, long 
{ 
I* body *I 
Section 6.6.1-Simple Variable Declarations 
Figure 6.16. A Reduction by ext_decl_list~ext_decl_list COMMA ext dec/ 
symbol· 
narne="y" 
type (NULL) (Before) 
etype (NULL) 
~ next (NULL) 
ext dec/ ...---
symbol: link: 
COMMA name="x" class=DECLARATOR 
type dol_cype~PolNTER~~ 
ext dec/ list ...--~ etype 
(NU:r\ -
next 
opt _specifiers ' 0link: 
ext_ def_list class=SPECIFIER 
I I noun = INT 
Parse Value _long = 1 
Stack Stack 
symbol: 
name="y" 
type (NULL) (After) 
etype (NULL) I/ oe<C f 
symbol: l link: 
name="x" class=DECLARATOR I type dol_cype~POlNTER~~ 
ext dec/ list etype .-r\ -
next (NULL) 
opt_ specifiers ' 0link: 
ext_ def_list class=SPECIFIER 
I I noun = INT 
Parse Value _long = 1 
Stack Stack 
The Nest lev variable is modified in the imbedded actions on lines 329 and 335 
because function arguments are actually at the inner scoping level. 
The function arguments can take two forms. A name _list is a simple list of names, as name_list, 
used for arguments in the older, K&R style, declaration syntax: 
hobbit( frito, bilbo, spam) 
short frito, bilbo; 
A var _list takes care of both the new, C++-style syntax: 
hobbit( short frito, short bilbo, int spam ); 
and function prototypes that use abstract declarators (declarations without names) such 
as the following: 
hobbit( short, short, int ); 
All of these forms are recognized by the parser, but the last one is just ignored in the 533 
534 Code Generation -Chapter 6 
Listing 6.44. c.y-Function Declarators 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 368 
369 
370 funct decl 
name list 
var list STAR funct decl 
funct decl LB RB 
funct decl LB const_expr RB 
LP funct decl RP 
funct decl LP RP 
new name LP RP 
new name LP { ++Nest_lev; add_declarator( $$ = $2 , POINTER); } 
add_declarator( $$,ARRAY); 
$$->etype->NUM_ELE = 0; 
add_declarator( $$, ARRAY ); 
$$->etype->NUM_ELE = $3; 
$$ = $2; 
add_declarator( $$, FUNCTION); 
add_declarator( $$, FUNCTION); 
name list --Nest_lev; } RP 
add_declarator( $$, FUNCTION); 
$4 
$$->args reverse_links( $4 ); 
$4; 
new_name LP ( ++Nest_lev; } var_list { --Nest_lev; } RP 
add_declarator( $$, FUNCTION); 
$$->args = $4; 
new name 
name list COMMA new name 
param_declaration $$->next 
$$->type 
$$->type->class 
$$->type->SCLASS 
$$ 
$$->next 
$$->type 
$$->type->class 
$$->type->SCLASS NULL; 
new _link () ; 
SPECIFIER; 
AUTO; 
$3; 
$1; 
new_link (); 
SPECIFIER; 
AUTO; 
NULL; } 
var list COMMA param_declaration if($1) $$->next 
if($3) 
{ 
$$ $3; 
$3->next $1; 
param_declaration 
type var decl 
abstract decl 
ELLIPSIS add_spec_to_decl($1, $$ 
discard_symbol ($1); $$ 
$$ $2 ); 
NULL 
NULL ; 
Section 6.6.1-Simple Variable Declarations 
present application: The abstract_ dec! production used on line 368 of Listing 6.44 
creates a symbol structure, just like the ones we've been discussing. There's no name, 
however. The action on line 368 just throws it away. Similarly, the ELLIPSIS that's 
used for ANSI variable-argument lists is just ignored on the next line. 
The name _list and var _list productions are found on lines 342 to 365 of Listing 6.44. 
They differ from one another in only one significant way: A name_list creates a linked 
list of symbols, one for each name in the list, and the type chains for all these symbols 
are single specifier links representing ints. A var _list takes the types from the 
declarations rather than supplying an int type. By the time the parser gets back up to 
lines 329 or 336 of Listing 6.45-1 the argument list will have have been processed, and 
the attribute attached to the name _list or var _list will be a pointer to the head of a linked 
list of symbol structures. The $$->args = $4 attaches this list to the args field of 
the symbol that represents the function itself. Figure 6.17 shows the way that 
hobbit( short frito, short bilbo, int spam ); 
is represented once all the processing is finished. 
Figure 6.17. Representing hobbit (short frito, short bilbo, int spam) 
symbol: 1 link: link: 
name="hobbit" class=DECLARATOR class=SPECIFIER 
type ldcl_type=FUNCTION I~ I noun = INT II) etype -'\ next NULL 
args 
symbol: link: 
'-name="frito" class=SPECIFIER I noun = INT II) type 
etype --\ short = 1 
next 
symbol: link: 
name="bilbo" class=SPECIFIER 
type I noun = !NT II) etype --1\ short = 1 
next 
symbol: link: 
name="spam" class=SPECIFIER 
type I noun = !NT I) etype ---1\ 
next NULL 
Note that the list of arguments is assembled in reverse order because, though the list 
is processed from left to right, each new element is added to the head of the list. The 
reverse _links () call on line 333 of Listing 6.44 goes through the linked list of sym­
bols and reverses the direction of the next pointers. It returns a pointer to the new 
head of the chain (formerly the end of the chain). Abstract declarators, 
abstracL dec/. 535 
Argument declarations 
assembled in reverse 
order, 
reverse _links(). 
536 
Merge declarator and 
specifier, 
add_spec_to_decl(). 
Abstract declarators. 
Problems with scanner, 
code-generator interac­
tion Code Generation -Chapter 6 
One other subroutine is of particular interest: add_ spec to decl (), called on 
line 367 of Listing 6.44, merges together the specifier and declarator components of a 
declaration. It's shown in Listing 6.45, below. Passed a pointer to a link that 
represents the specifier, and a pointer symbol that contains a type chain representing the 
declarator, it makes a copy of the specifier link [with the clone_ type() call on line 
132] and tacks the copy onto the end of the type chain. 
The last kind of declarator in the grammar is an abstract declarator, handled in List­
ing 6.46, below. If abstract declarators were used only for declarations, the productions 
on lines 371 to 388 could be devoid of actions. You need abstract declarators for the cast 
operator and sizeof statement, however. The actions here work just like all the other 
declarator productions; the only difference is that the resulting symbol attribute has a 
type but no name. The symbol structure is allocated on line 380-the E production 
takes the place of the identifier in the earlier declarator productions. 
Returning to the parse in Table 6.13 on page 523, the parser has just finished with the 
ext_ decl_list and is about to reduce by { 3 } ~E. This production is supplied by occs to 
process the imbedded action on lines 390 to 401 of Listing 6.47, below. Occs translates: 
ext def opt specifiers ext decl list {action ... } SEMI 
as follows: 
ext def opt_specifiers ext decl list {3} SEMI 
{ 3} /* empty *I {action ... } 
so that it can do the imbedded action as part of a reduction. 
The action does three things: it merges the speci tier and declarator components of 
the declaration, puts the new declarations into the symbol table, and generates the actual 
declarations in the output. The action must precede the SEMI because of a problem 
caused by the way that the parser and lexical analyzer interact with one another. The 
lexical analyzer uses the symbol table to distinguish identifiers from the synthetic types 
created by a typedef, but symbol-table entries are also put into the symbol table by the 
current production. The problem is that the input token is used as a lookahead symbol. 
It can be read well in advance of the time when it is shifted, and several reductions can 
occur between the read and the subsequent shift. In fact, the lookahead is required to 
know which reductions to perform. So the next token is always read immediately after 
shifting the previous token. Consider the following code: 
typedef int itype; 
itype x; 
If the action that adds the new type to the symbol table followed the SEMI in the gram­
mar, the following sequence of actions would occur: 
• Shift the SEMI, and read the lookahead symbol. it ype has not been added to the 
symbol table yet, so the scanner returns a NAME token. 
• Reduce by ext_def~{opt_specifiers ext_decl_list} SEMI, adding the itype to the 
symbol tabl\!. 
The problem is solved by moving the action forward in the production, so that the parser 
correctly acts as follows: 
Section 6.6.1 -Simple Variable Declarations 537 
Listing 6.45. decl.c- Add a Specifier to a Declaration 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 148 
149 
!50 
!51 
!52 
!53 void 
link 
symbol 
{ add_spec_to_decl( p_spec, decl chain 
*p_spec; 
*decl_chain; 
/* p spec is a pointer either to a specifier/declarator chain created 
* by a previous typedef or to a single specifier. It is cloned and then 
* tacked onto the end of every declaration chain in the list pointed to by 
* decl_chain. Note that the memory used for a single specifier, as compared 
* to a typedef, may be freed after making this call because a COPY is put 
* into the symbol's type chain. 
* 
* In theory, you could save space by modifying all declarators to point 
* at a single specifier. This makes deletions much more difficult, because 
*you can no longer just free every node in the chain as it's used. The 
* problem is complicated further by typedefs, which may be declared at an 
* outer level, but can't be deleted when an inner-level symbol is 
* discarded. It's easiest to just make a copy. 
* 
* Typedefs are handled like this: If the incoming storage class is TYPEDEF, 
* then the typedef appeared in the current declaration and the tdef bit is 
* set at the head of the cloned type chain and the storage class in the 
* clone is cleared; otherwise, the clone's tdef bit is cleared (it's just 
*not copied by clone_type()). 
*I 
link *clone_start, *clone end 
link **p; 
for( ; decl_chain ; decl_chain = decl_chain->next 
{ 
if( ! (clone_start = clone_type(p_spec, &clone_end)) 
{ 
else 
{ yyerror("INTERNAL, add_typedef_: Malformed chain (no specifier)\n"); 
exit ( 1 ) ; 
if( !decl_chain->type ) 
decl_chain->type = clone_start ; 
else 
decl_chain->etype->next = clone_start; 
decl_chain->etype = clone_end; 
if( IS_TYPEDEF(clone_end) ) 
{ 
set_class_bit( 0, clone_end ); 
decl_chain->type->tdef = 1; /* No declarators. */ 
538 Code Generation -Chapter 6 
Listing 6.46. c.y-Abstract Declarators 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 abstract decl 
abs decl type abs decl 
I TTYPE abs decl 
I* epsilon *I 
LP abs decl RP LP RP 
STAR abs decl 
abs decl LB add_spec_to_decl ( $1, $$ $2 ) ; } 
$$ = $2; 
add_spec_to_decl( $1->type, $2 ); 
RB $$ = new_symbol ('"', 0); 
add_declarator( $$ = $2, FUNCTION); 
add_declarator( $$ = $2, POINTER ); 
add_declarator( $$, POINTER ); 
abs decl LB const_expr RB add_declarator( $$, ARRAY ); 
$$->etype->NUM_ELE $3; 
LP abs decl RP $$ = $2; } 
• Reduce by { 3 } ~E. adding the it ype to the symbol table. 
• Shift the SEMI, and read the lookahead symbol. it ype is in the symbol table this 
time, so the scanner returns a TTYPE token. 
• Reduce by ext_def~l opt_specifiers ext_decl_list} { 3} SEMI. 
Listing 6.47. c.y-High-Level, External Definitions (Part One) 
389 ext def 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 opt_specifiers ext_decl_list 
{ 
SEMI add_spec_to_decl( $1, $2 ); 
if ( ! $1->tdef ) 
discard link chain( $1 ); 
add_symbols_to_table 
figure_osclass 
generate_defs_and_free_args 
remove_duplicates $2 
$2 
$2 
$2 reverse_links( $2 ) ) ; 
) ; 
) ; 
) ; 
I* There are additional right-hand sides listed in subsequent listings. 
*I 
The action on lines 390 to 401 of Listing 6.47 needs some discussion. The attribute 
associated with the ext_ decl_list at $2 is a pointer to a linked list of symbol structures, 
one for each variable in the declarator list. The attribute associated with opt _specifiers 
at $1 is one of two things: either the specifier component of a declaration, or, if the 
declaration used a synthetic type, the complete type chain as was stored in the symbol­
table entry for the typedef. In both cases, the add_ spec_ to_ decl () call on line 
391 modifies every type chain in the list of symbols by adding a copy of the type chain 
passed in as the first argument to the end of each symbol's type chain. Then, if the 
current specifier didn't come from a typedef, the extra copy is discarded on line 394. 
The symbols are added to symbol table on line 396. The figure_ osclass () call on 
Section 6.6.1 -Simple Variable Declarations 
line 397 determines the output storage class of all symbols in the chain, 
generate_ def s _and_ free_ args () outputs the actual C-code definitions, and 
remove_ duplicates () destroys any duplicate declarations in case a declaration and 
definition of a global variable are both present. All of these subroutines are in Listings 
6.48 and 6.49, below. 
Listing 6.48. decl.c- Symbol-Table Manipulation and C-code Declarations 
void add_symbols_to_table( sym) 
symbol *sym; 
{ 
/* Add declarations to the symbol table. 
* * Serious redefinitions (two publics, for example) generate an error 
* message. Harmless redefinitions are processed silently. Bad code is 539 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 * generated when an error message is ~inted. The symbol table is modified 
* in the case of a harmless duplicate to reflect the higher precedence 
* storage class: (public ==private) > common > extern. 
* * The sym->rname field is modified as if this were a global variable (an 
*underscore is inserted in front of the name). You should add the symbol 
* chains to the table before modifying this field to hold stack offsets 
* in the case of local variables. 
*I 
symbol *exists; /* Existing symbol if there's a conflict. 
int harmless; 
symbol *new; 
for(new = sym; new ; new = new->next ) 
{ 
exists = (symbol *) findsym(Symbol_tab, new->name); 
if( !exists I I exists->level != new->level ) 
{ 
else sprintf 
addsym new->rname, " %l.*s", sizeof(new->rname)-2, new->name); 
Symbol_tab, new); 
harmless 0; 
new->duplicate 1; 
if( the same_type( exists->type, new->type, 0) ) 
{ 
if( exists->etype->OCLASS==EXT I I exists->etype->OCLASS==COM 
{ 
harmless = 1; 
if( new->etype->OCLASS != 
{ 
exists->etype->OCLASS 
exists->etype->SCLASS 
exists->etype->EXTERN 
exists->etype->STATIC EXT ) 
new->etype->OCLASS; 
new->etype->SCLASS; 
new->etype->EXTERN; 
new->etype->STATIC; *I 
540 Code Generation -Chapter 6 
Listing 6.48. continued ... 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 if ( ! harmless ) 
yyerror("Duplicate declaration of %s\n", new->name ); 
/*----------------------------------------------------------------------*/ 
void figure_osclass( sym) 
symbol *sym; 
{ 
/* Go through the list figuring the output storage class of all variables. 
* Note that if something is a variable, then the args, if any, are a list 
* of initializers. I'm assuming that the sym has been initialized to zeros; 
* at least the OSCLASS field remains unchanged for nonautomatic local 
* variables, and a value of zero there indicates a nonexistent output class. 
*I 
for( ; sym ; sym = sym->next 
{ 
if( sym->level 0 ) 
{ 
if( IS_FUNCT( sym->type ) ) 
{ 
if 
else 
else 
else 
{ 
if if 
else if sym->etype->EXTERN 
sym->etype->STATIC 
sym->etype->STATIC 
sym->args 
else if( sym->type->SCLASS == FIXED 
{ 
if IS FUNCT 
else if (! IS LABEL sym->type ) ) 
sym->type ) ) sym->etype->OCLASS sym->etype->OCLASS 
sym->etype->OCLASS 
sym->etype->OCLASS 
sym->etype->OCLASS 
sym->etype->OCLASS 
sym->etype->OCLASS 
sym->etype->OCLASS EXT; 
PRI; 
PUB; 
PRI; 
PUB; 
COM; 
EXT; 
PRI; 
/*----------------------------------------------------------------------*/ 
void generate_defs_and_free_args( sym) 
symbol *sym; 
{ 
/* Generate global-variable definitions, including any necessary 
* initializers. Free the memory used for the initializer (if a variable) 
*or argument list (if a function). 
*I 
for( ; sym ; sym = sym->next ) 
{ 
if( IS_FUNCT(sym->type) ) 
{ 
/* Print a definition for the function and discard arguments 
* (you'd keep them if prototypes were supported). 
*I .... 
Section 6.6.1 -Simple Variable Declarations 541 
Listing 6.48. continued ... 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 yydata( "external\t%s();\n", sym->rname ); 
discard_symbol_chain( sym->args ); 
sym->args = NULL; 
else if( IS CONSTANT(sym->etype) I I sym->type->tdef ) 
{ 
continue; 
else if( !sym->args 
{ I* It's an uninitialized variable. *I 
else print_bss_dcl( sym ); I* Print the declaration. *I 
I* Deal with an initializer. *I 
var_dcl( yydata, sym->etype->OCLASS, sym, "=" ); 
if( IS_AGGREGATE( sym->type ) ) 
yyerror("Initialization of aggregate types not supported\n"); 
else if( !IS_CONSTANT( ((value *)sym->args)->etype) ) 
yyerror("Initializer must be a constant expression\n"); 
else if( !the_same_type(sym->type, ((value*) sym->args)->type, 0) ) 
yyerror("Initializer: type mismatch\n"); 
else 
yydata ( "%s; \n", CONST_STR( (value *) sym->args ) ) ; 
discard_ value ( (value *) ( sym->args) ) ; 
sym->args = NULL; 
1*----------------------------------------------------------------------*l 
symbol *remove_duplicates( sym) 
symbol *sym; 
{ 
I* Remove all nodes marked as duplicates from the linked list and free the * memory. These nodes should not be in the symbol table. Return the new 
* head-of-list pointer (the first symbol may have been deleted). 
*I 
symbol *prev 
symbol *first 
while( sym ) 
{ NULL; 
sym; 
if( !sym->duplicate 
{ 
prev 
sym sym; 
sym->next; I* Not a duplicate, go to the 
I* next list element. *I 
*I 
else if( prev == NULL 
{ I* Node is at start of the list. *I 
first = sym->next; 
discard_symbol( sym ); 
sym = first; .... 
542 Code Generation -Chapter 6 
Listing 6.48. continued ... 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 else 
{ 
prev->next = sym->next; 
discard_symbol( sym ); 
sym = prev->next; 
return first; I* Node is in middle of the list. *I 
Listing 6.49. decl.c- Generate C-Code Definitions 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 void print_bss_dcl( sym) I* Print a declaration to the bss segment. *I 
symbol *sym; 
{ 
if( sym->etype->SCLASS != FIXED ) 
yyerror( "Illegal storage class for %s", sym->name ); 
else 
{ 
if( sym->etype->STATIC && sym->etype->EXTERN ) 
yyerror("%s: Bad storage class\n", sym->name ); 
var_dcl( yybss, sym->etype->OCLASS, sym, ";\n" ); 
1*----------------------------------------------------------------------*l 
PUBLIC void var_dcl( ofunct, c_code_sclass, sym, terminator 
void 
int 
symbol 
char 
{ (* ofunct) (); 
c_code_sclass; 
*sym; 
*terminator; I* Pointer to output function (yybss or yydata). 
I* C-code storage class of symbol. 
I* Symbol itself. 
I* Print this string at end of the declaration. 
I* Kick out a variable declaration for the current symbol. *I 
char suffix[32]; 
char *type 
int size 
link *p 
char *storage_class 1111 ; 
1 *I 
*I 
*I 
*I 
sym->type; 
(c_code_sclass 
(c_code_sclass (c_code_sclass PUB) ? 
PRI) ? 
EXT) ? "public" 
"private" 
"external" "common" 
*suffix= '\0'; 
if( IS_FUNCT(p) 
{ 
yyerror("INTERNAL, var del: object not a variable\n"); 
exit( 1 ); 
if( IS_ARRAY(p) 
{ 
Section 6.6.2-Structure and Union Declarations 
Listing 6.49. continued ... 
for(; IS_ARRAY(p) ; p = p->next 
size *= p->NUM_ELE ; 
sprintf( suffix, "[%d]", size); 
if( IS STRUCT(p) 
{ 
( *ofunct ) ( "\nALIGN (lword) \n" ) ; 
sprintf( suffix, "[%d]", size* p->V_STRUCT->size ) ; 
if( IS_POINTER(p) 
type = PTYPE; 
else 
switch( p->NOUN 
{ 
case CHAR: type 
case INT: type 
case STRUCTURE: type CTYPE; 
p->LONG ? LTYPE 
STYPE; /* Must be a specifier. */ 
break; 
ITYPE; break; 
break; 376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 398 
399 
400 *ofunct ) ( "%s\t%s\t%s%s%s", storage class, type, 
sym->rname, suffix, terminator ) ; 
6.6.2 Structure and Union Declarations 
Now, let's back up for a moment and look at more-complex types: structures and struct_specitier. 
unions. These were handled at a high level on line 231 of Listing 6.39 on page 525, 
where a struct_specifier is recognized in place of a TYPE token. For example, every-
thing from the struct up to the name is a struct_specifier in the following declaration: 
struct tag 
{ 
int tinker; 
long tailor; 
char soldier; 
struct tag *spy; 
name; 543 
A parse for this declaration is shown in Table 6.14. There are several points of interest 
here. First, the STRUCT token is returned by the scanner for both the struct and 
union lexemes. The associated <ascii> attribute is the first character of the lexeme. 
In practice, the only difference between a structure and a union is the way that the offsets 
to each field are computed-in a union the offsets are all zero. Since the two data types 
are syntactically identical, you need only one token with an attribute that allows the 
code-generation action to distinguish the two cases. STRUCT recognized for 
both struct and union. 
<ascii> attribute. 
The structure tag is handled in the parse on lines 4 to 6 of Table 6.14. The associated 
actions are on lines 426 to 444 of Listing 6.50, below. There are two actions of interest, 
opt_tag~£ on line 427 takes care of those situations where an explicit tag is not present. 
An arbitrary name is generated on line 430, and a new struct_def is allocated on the 
next line. Then the definition (with no fields as of yet) is added to the structure table on 
line 433. A pointer to the new structure-table element is passed up as an attribute. Structure tags. 
opt_ tag-?£ 
544 Code Generation -Chapter 6 
Table 6.14. Parsing a Structure Definition 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 Stack Next Action 
(empty) Reduce: ext_def_list--'i£ 
DATA: #include <tools/virtual.h> 
DATA: #define T (x) 
DATA: SEG(data) 
CODE: SEG(code) 
BSS: SEG (bss) 
ext def list Shift: STRUCT 
ext def list STRUCT Shift: NAME 
ext def list STRUCT NAME Reduce: tag--'iNAME 
ext def list STRUCT tag Reduce: opt tag -'>tag 
ext def list STRUCT opt tag Shift: LC 
ext def list STRUCT opt tag LC Reduce: def list-'>£ 
ext def list STRUCT opt tag LC def list Shift: TYPE 
ext def list STRUCT opt tag LC def list TYPE Reduce: type specifier--'iTYPE 
ext def list STRUCT opt tag LC def list type specifier Reduce: type or dass--'>type specifier 
ext def list STRUCT opt tag LC def list type or class Reduce: specifiers--'>type or class 
ext def list STRUCT opt tag LC def list specifiers Shift: NAME 
ext def list STRUCT opt tag LC def list specifiers NAME Reduce: new name--'>NAME 
ext def list STRUCT opt tag LC def list specifiers new name Reduce: var decl--'>new name 
ext def list STRUCT opt tag LC def list specifiers var dec/ Reduce: decl--'>var dec/ 
ext def list STRUCT opt tag LC def list specifiers dec/ Reduce: dec/ list--'>dec/ 
ext_def_list STRUCT opt_tag LC def_list specifiers decl_list Reduce: { 65} --'>£ 
ext _def_/ist STRUCT opt _tag LC def_list specifiers decl_list { 65) Shift: SEMI 
ext_ def_list STRUCT opt _tag LC def_list specifiers dec/ _list { 65) SEMI Reduce: def--'>specifiers decl_list { 65} SEMI 
ext def list STRUCT opt tag LC def list def Reduce: def list--'>def list def 
ext def list STRUCT opt tag LC def list Shift: TYPE 
ext def list STRUCT opt tag LC def list TYPE Reduce: type specifier--'iTYPE 
ext def list STRUCT opt tag LC def list type specifier Reduce: type or class -'>type specifier 
ext def list STRUCT opt tag LC def list type or class Reduce: specifiers--'>type or class 
ext def list STRUCT opt tag LC def list specifiers Shift: NAME 
ext def list STRUCT opt tag LC def list specifiers NAME Reduce: new name--'iNAME 
ext def list STRUCT opt tag LC def list specifiers new name Reduce: var decl--'inew name 
ext def list STRUCT opt tag LC def list specifiers var dec/ Reduce: decl--'>var dec/ 
ext def list STRUCT opt tag LC def list specifiers dec/ Reduce: dec/ /ist--'idec/ 
ext_ def_list STRUCT opt _tag LC def_list specifiers dec/ _list Reduce: { 65) --'>£ 
ext_ def_list STRUCT opt _tag LC def_list specifiers dec/ _list { 65) Shift: SEMI 
ext_def_list STRUCT opt_tag LC def_list specifiers dec/_/ist { 65} SEMI Reduce: def--'>specifiers decl_list { 65) SEMI 
ext def list STRUCT opt tag LC def list def Reduce: def list--'idef list def 
ext def list STRUCT opt tag LC def list Shift: TYPE 
ext def list STRUCT opt tag LC def list TYPE Reduce: type specifier--'iTYPE 
ext def list STRUCT opt tag LC def list type specifier Reduce: type or class--'>type specifier 
ext def list STRUCT opt tag LC def list type or class Reduce: specifiers--'itype or class 
ext def list STRUCT opt tag LC def list specifiers Shift: NAME 
ext_def_list STRVCTopt_tag LC def_list specifiers NAME Reduce: new_name--'iNAME 
ext_ def_list STRUCT opt _tag LC def_list specifiers new_ name Reduce: var decl--'inew name - -
ext_ def_list STRUCT opt _tag LC def_list specifiers var_ dec/ Reduce: decl--'>var_ded 
ext_def_list STRUCT opt_tag LC def_list specifiers dec/ Reduce: dec/ list -'>dec/ 
ext _def_list STRUCT opt_tag LC def_list specifiers dec/ _list Reduce: { 65) --'>£ 
ext_def_list STRUCT opt_tag LC def_list specifiers dec/_list { 65) Shift: SEMI 
continued ... 
The action on lines 437 to 444 is used when a tag is present in the definition, as is the 
case in the current example. The incoming attribute for the NAME token is useless here 
because this attribute is generated by a symbol-table lookup, not a structure-table 
lookup. The action code looks up the name in the structure table and returns a pointer to 
the entry if it's there. Otherwise, a new structure-table element is created and added to 
Section 6.6.2-Structure and Union Declarations 
Table 6.14. Continued. Parsing a Structure Definition 
Stack Next Action 
45 ext_ def_list STRUCT opt _tag LC def_list specifiers dec/ _list Reduce: def--?specifiers decl_list { 65) SEMI 
{65) SEMI 
46 ext def list STRUCT opt tag LC def list def Reduce: def list--?def list def 
47 ext def list STRUCT opt tag LC def list Shift: STRUCT 
48 ext def list STRUCT opt tag LC def list STRUCT Shift: NAME 
49 ext_ def_list STRUCT opt _tag LC def_list STRUCT NAME Reduce: tag--7NAME 
50 ext_ def_list STRUCT opt _tag LC def_list STRUCT tag Reduce: struct_specifier--?STRVCT tag 
51 ext def list STRUCT opt tag LC def list struct specifier Reduce: type specifier--?struct specifier 
52 ext def list STRUCT opt tag LC def list type specifier Reduce: type or class -?type specifier 
53 ext def list STRUCT opt tag LC def list type or class Reduce: specifiers--?type or class 
54 ext def list STRUCT opt tag LC def list specifiers Shift: STAR 
55 ext_def_list STRUCT opt_tag LC def_list specifiers STAR Shift: NAME 
56 ext_def_list STRUCT opt_tag LC def_list specifiers STAR Reduce: new name--?NAME 
NAME 
57 ext_ def_list STRUCT opt _tag LC def_list specifiers STAR Reduce: var dec!--?new name - -
new name 
58 ext_def_list STRUCT opt_tag LC def_list specifiers STAR Reduce: var dec/--?STAR var dec/ - -
var dec/ 
59 ext def list STRUCT opt tag LC def list specifiers var dec/ Reduce: dec/--?var dec/ 
60 ext def list STRUCT opt tag LC def list specifiers dec/ Reduce: dec/ list -?dec/ 
61 ext_def_list STRUCT opt_tag LC def_list specifiers decl_list Reduce: { 65) --7£ 
62 ext_def_list STRUCT opt_tag LC def_list specifiers decl_list Shift: SEMI 
{ 65) 
63 ext_ def_list STRUCT opt _tag LC def_list specifiers Reduce: def--?specifiers decl_list { 65) SEMI 
decl_/ist { 65) SEMI 
64 ext def list STRUCT opt tag LC def list def Reduce: def list--?def list def 
65 ext def list STRUCT opt tag LC def list Shift: RC 
66 ext def list STRUCT opt tag LC def list RC Reduce: struct specifier--?STRVCT opt tag LC def list RC 
67 ext def list struct specifier Reduce: type specifier--?struct specifier 
68 ext def list type specifier Reduce: type or class--?type specifier 
69 ext def list type or class Reduce: specifiers--?type or class 
70 ext def list specifiers Reduce: opt specifiers--?specificrs 
71 ext def list opt specifiers Shift: NAME 
72 ext def list opt specifiers NAME Reduce: new name--?NAME 
73 ext def list opt specifiers new name Reduce: var dec!--?new name 
74 ext def list opt specifiers var dec/ Reduce: ext decl--?var dec/ 
75 ext def list opt specifiers ext dec/ Reduce: ext dec/ list -?ext dec/ 
76 ext_ def_list opt _specifiers ext_ decl_list Reduce: {50 )--7£ 
BSS: ALIGN(lword) 
BSS: common record _name [16]; 
77 ext def list opt specifiers ext dec/ list { 50) Shift: SEMI 
78 ext def list opt specifiers ext dec/ list {50) SEMI Reduce: ext def--?opt specifiers ext dec/ list {50) SEMI 
79 ext def list ext def Reduce: ext def list -?ext def list ext def 
80 ext_ def_list Reduce: program--?ext _ def_list (Accept) 
the table, as before. This time the real tag is used rather than an arbitrary name, how­
ever. 545 
The parser now moves on to process the field definitions, using the productions in Structure-field definitions. 
Listing 6.51, below. These productions are effectively the same as the ext_def_list pro­
ductions that handle global-variable definitions. In fact, most of the actions are identi­
cal. You need two sets of productions because function definitions (with bodies) are per­
mitted only at the global level. As with an ext_ def, the attribute associated with a def is a 
pointer to a cross-linked chain of symbols, one for each comma-separated declarator 
found in a definition, or NULL if no declarators were found. The def_list productions def_list 
process a list of semicolon-terminated definitions, linking the cross-linked symbols 
546 Code Generation -Chapter 6 
Listing 6.50. c.y-Structures 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 struct specifier 
STRUCT opt_tag LC def_list RC 
{ 
if( !$2->fields ) 
{ 
else 
{ $2->fields =reverse links( $4 ) ; 
if( !illegal struct_def( $2, $4 ) 
$2->size =figure struct_offsets( $2->fields, $l=='s' ) ; 
yyerror("Ignoring redefinition of %s", $2->tag ); 
discard_symbol chain( $4 ); 
$$ $2; 
STRUCT tag { $$ $2; } 
opt_tag tag 
/* empty */ 
static unsigned label = 0; 
static char tag[l6]; 
sprintf ( tag, "%03d", label++ ) ; 
$$ = new_structdef( tag); 
addsym( Struct_tab, $$ ) ; 
tag NAME 
struct_specifier --> 
STRUCT opt_tag LC 
def_list RC 
Figuring offsets to fields. if ( ! ($$= (structdef *) findsym (Struct_tab, yytext))) 
{ 
$$ = new_structdef( yytext ) ; 
$$->level = Nest_lev; 
addsym( Struct tab, $$ ) ; 
from each individual definition together into a larger list. The new elements are added to 
the end of the list-the loop on line 450 finds the end. After the entire list is processed 
(on line 65 of the parse), the attribute associated with the def_list is a linked list of sym­
bols, one for each field in the structure. 
The parser now reduces by 
struct_specifier~STRUCT opt_tag LC def_list RC 
The action is on lines 407 to 421 of Listing 6.50, and the subroutines that are used here 
are in Listing 6.52. The illegal struct_def () call checks the field definitions to 
make sure that there's no recursion and that none of the fields are function definitions (as 
compared to function pointers, which are legal). The figure_struct_offsets () 
call on line 427 figures the offsets from the base address of the structure to the individual 
fields. The basic algorithm just traverses the linked list of symbols adding the 
Section 6.6.2-Structure and Union Declarations 
Listing 6.51. c.y-Local Variables and Function Arguments 
def list 
def list def symbol *p; 
if( p = $2 
{ 547 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 for(; p->next; p p->next ) 
p->next $1; 
$$ $2; 
/* epsilon */ $$ NULL; } /* Initialize end-of-list */ 
/* pointer. */ 
def 
decl list 
decl specifiers decl list 
SEMI 
specifiers SEMI 
decl 
decl list COMMA decl 
{ 
$3->next $1; 
$$ $3; 
funct decl 
var decl add_spec_to_decl( $1, $2 ); 
$$ $2; 
$$ NULL; 
{ $$->next NULL;} 
var decl EQUAL initializer yyerror( "Ignoring initializer.\n"); 
discard_value( $3 ); 
var decl COLON const_expr 
COLON const_expr %prec COMMA 
%prec COMMA 
cumulative size of the preceding fields to the current offset. A minor problem is caused 
by alignment restrictions-padding may have to be added in the middle of the structure 
in order to get interior fields aligned properly. The structure is declared as a character 
array on line 76 of the parse (record is an alias for byte), and the individual fields are 
not declared explicitly-they are extracted from the proper location within the array 
when expressions are processed. As a consequence, the compiler has to worry about 
supplying padding that would normally be supplied by the assembler. 
This alignment problem actually arises in the current example. The first field is a 
two-byte int, but the second field requires four-byte alignment, so two spaces of padding 
have to be added to get the second field aligned properly. The situation is simplified, 
somewhat, by assuming that the first field is always aligned on a worst-case boundary. 
Anal ign ( 1 word) directive is generated by the compiler just above the actual variable 
definition for this purpose. Finally, note that the structure size is rounded up to be an 
even multiple of the worst-case alignment restriction on lines 464 and 465 of Listing 
6.52 so that arrays of structures work correctly. Structure-field alignment, 
padding. 
Structure size rounded 
up for arrays. 
548 Code Generation -Chapter 6 
opt_ specifier, The structure definition is now reduced to an opt _specifier, and the parse continues 
just like a simple variable definition. One more right-hand side to ext_ def is needed for 
structures. It is shown in Listing 6.53, and handles structure, union, and enumerated­
type declarations that don't allocate space for a variable (such as a struct definition 
with a tag but no variable name). Note that the discard_link_chain () call on line 
490 does not delete anything from the structure table. 
Listing 6.52. decl.c-Structure-Processing Subroutines 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 int illegal_struct_def( cur_struct, fields 
structdef *cur_struct; 
symbol *fields; 
( 
I* Return true if any of the fields are defined recursively or if a function 
* definition (as compared to a function pointer) is found as a field. 
*I 
for(; fields; fields = fields->next 
{ 
if( IS_FUNCT(fields->type) ) 
{ 
} yyerror("structlunion member may not be a function"); 
return 1; 
if( IS_STRUCT(fields->type) && 
!strcmp( fields->type->V_STRUCT->tag, cur_struct->tag)) 
yyerror("Recursive structlunion definition\n"); 
return 1; 
return 0; 
l*----------------------------------------------------------------------*1 
int figure struct offsets( p, is struct ) 
symbol *p; I* Chain of symbols for fields. *I 
int is struct; I* 0 if a union. *I 
I* Figure the field offsets and return the total structure size. Assume 
* that the first element of the structure is aligned on a worst-case 
* boundary. The returned size is always an even multiple of the worst-case 
* alignment. The offset to each field is put into the "level" field of the 
* associated symbol. 
*I 
int align_size, obj size; 
int offset = 0; 
for( ; p ; p = p->next 
( 
if ( ! is struct 
{ I* It's a union. *I 
offset max( offset, get_sizeof( p->type ) ; 
else 
{ p->level 0; 
obj size 
align_size get_sizeof 
get_alignment p->type ); 
p->type ); .... 
Section 6.6.2-Structure and Union Declarations 549 
Listing 6.52. continued ... 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 468 
469 
470 
471 
472 
473 
474 
475 
476 
477 
478 
479 
480 
481 
482 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 while( offset % align_size 
++offset; 
p->level offset; 
offset += obj_size 
/* Return the structure size: the current offset rounded up to the */ 
/* worst-case alignment boundary. You need to waste space here in case */ 
/* this is an array of structures. */ 
while( offset % ALIGN WORST 
++offset ; 
return offset; 
/*-----------------·----------------------------------------------------*/ 
int 
link 
{ get_alignment( p) 
*p; 
/* Returns the alignment--the number by which the base address of the object 
* must be an even multiple. This number is the same one that is returned by 
* get_sizeof(), except for structures which are worst-case aligned, and 
* arrays, which are aligned according to the type of the first element. 
*I 
int size; 
if( !p ) 
{ 
yyerror("INTERNAL, get_alignment: NULL pointer\n"); 
exit( 1 ) ; 
} 
if( IS_ARRAY( p 
if( IS_STRUCT( p ) 
if( size = get sizeof( p ) return get_alignment( p->next ); 
return ALIGN_WORST; 
return size; 
yyerror("INTERNAL, get_alignment: Object aligned on zero boundary\n"); 
exit ( 1 ) ; 
Listing 6.53. c.y-High-Level, External Definitions (Part Two) 
484 
485 
486 
487 
488 
489 
490 
491 
492 /* ext def : *I 
I opt specifiers 
{ 
SEMI if( ! ($1->class == SPECIFIER && $1->NOUN == STRUCTURE) 
yyerror("Useless definition (no identifier)\n"); 
if( !$1->tdef ) 
discard_link_chain( $1 ); 
550 
Enumerated types are 
handled as integer con­
stants. 
Enum_val,do_enum(). Code Generation -Chapter 6 
6.6.3 Enumerated- Type Declarations 
The final definition recognized by the grammar is an enumerated type, handled at a 
high level on line 230 of Listing 6.39 (on page 525) where an enum _specifier is recog­
nized in place of a TYPE token. An enumerated-type definition like this: 
enum tag { rich_man, poor_man, beggar_man = 5, thief } x; 
is treated as if the following had been used: 
int x; 
#define rich man 
#define poor_man 
#define beggar_man 
#define thief 0 
(rich_man + 1) 
5 
(beggar_man + 1) 
but the compiler recognizes the elements of the enumerated type directly rather than 
using a macro preprocessor. The high-level action in Listing 6.39 on page 525 just 
creates a specifier for an int, ignoring the tag component of the enumerated type. 
The real work happens in the productions in Listing 6.54, which creates symbol-table 
entries for the symbolic constants (rich_ man, and so forth). Internally, the compiler 
doesn't distinguish between an element of an enumerated type and any other integer con­
stant. When an enumerated-type element is referenced, a symbol-table lookup is neces­
sary to get the value; but thereafter, the value is handled just like any other integer con­
stant. The En urn_ val global variable keeps track of the current constant value. It is ini­
tialized to zero on line 507 of Listing 6.54, when the enum keyword is recognized. The 
enumerated-type elements are processed on lines 516 to 518. En urn_ val is modified as 
necessary if an explicit value is given in the definition. In any event, do_ en urn ( ) , in 
Listing 6.56, is called to create the symbol-table element, which is added to the table on 
the next line. 
Listing 6.54. c.y-Enumerated Types 
122 % { 
123 int 
124 %} Enum_val; /* Current enumeration constant value */ 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 508 
509 
510 
511 
512 
513 
514 enum_specifier 
: enum name opt_enum_list 
anum LC enumerator list RC 
opt enum list 
LC enumerator list RC 
/* empty */ 
enum ENUM Enum val 
enumerator list 
enumerator 0; } if( $2->type ) 
yyerror("%s: redefinition",$2->name); 
else 
discard_symbol($2); 
enumerator list COMMA enumerator 
Section 6.6.3-Enumerated- Type Declarations 
Listing 6.54. continued ... 
515 enumerator 
516 name do_enum( $1, Enum_val++ ); 
Enum val = $3; 517 name EQUAL const_expr 
518 do_enum( $1, Enum val++ ); 
519 
Listing 6.55. decl.c-Enumerated- Type Subroutines 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 508 
509 
510 
511 
512 513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 PUBLIC void do_enum( sym, val ) 
symbol 
int *sym; 
val; 
if( conv_sym_to_int_const( sym, val ) ) 
addsym( Symbol_tab, sym ); 
else 
{ 
yyerror( "%s: redefinition", sym->name ); 
discard_symbol( sym); 
/*---------------------------------------------------------------------*/ 
PUBLIC int conv_sym_to_int_const( sym, val ) 
symbol 
int *sym; 
val; 
/* Turn an empty symbol into an integer constant by adding a type chain 
* and initializing the v_int field to val. Any existing type chain is 
* destroyed. If a type chain is already in place, return 0 and do 
*nothing, otherwise return 1. This function processes enum's. 
*I 
link *lp; 
if( sym->type 
return 0; 
lp 
lp->class 
lp->NOUN 
lp->SCLASS 
lp->V_INT 
sym->type 
*sym->rname 
return 1; new link(); 
SPECIFIER; 
INT; 
CONSTANT; 
val ; 
lp; 
I \0'; 551 
552 
Labels for link: gen­
erated after processing 
subroutine, printed above 
subroutine. 
Output streams: code, 
data,bss. 
Subroutine-prefix-and­
suffix generation. 
Prefix. 
Suffix. 
Arguments to link in­
struction. 
Vspace, Tspace, 
Funct name. 
exL def ~opLspecifiers 
funcLdecl {) def_/ist {) 
compound_stmt { ) . Code Generation -Chapter 6 
6.6.4 Function Declarations 
The next sort of declaration is a function declaration, handled, at the high level, by 
the remaining right-hand side to ext_ def 
ext_ def-Mpt _specifiers funct _dec/ { ... } def_list { ... } compound_stmt { ... } ; 
We'lllook at the actual production in a moment. First, look at the parse of the following 
code in Table 6.15: 
pooh(piglet, eeyore) 
long eeyore; 
{ 
} 
This time I've shown the output as well as the parser actions; the three output streams are 
indicated by CODE:, DATA:, and BSS: in the table. The final compiler output (after 
the three streams have been merged) is in Listing 6.56. 
Note that the time at which the parser outputs something is not directly related to the 
position of that something in the output file. For example, the #defines for LO and Ll 
at the !22_ of the output file are not emitted by the parser until after the entire subroutine 
has been processed. This shuffling is accomplished by using two different output 
streams. The definitions are written to the bss stream; code is written to the code stream. 
The streams are merged in the following order: data, bss, and then code. So, all output 
to the bss stream appears above all code-stream output in the final program. 
The code on lines nine to 14 of Listing 6.56 is generated at the top of every subrou­
tine (with the obvious customizations). This block of instructions is called the subrou­
tine prefix. The macro definitions on lines five and six of Listing 6.56 are also part of the 
prefix, even though these definitions end up at the top of the output file rather than 
immediately above the subroutine definition, because they are generated along with the 
rest of the prefix code. The code on lines 18 to 20 of Listing 6.56 is generated at the bot­
tom of every subroutine and is called the subroutine suffix. 
The LO and Ll macros on lines five and six of Listing 6.56 are used as arguments in 
the link instruction at the top of the subroutine. The numeric component of the labels 
is unique-the next subroutine in the input file uses L2 and L3. In the current example, 
LO holds the size, in bytes, of the local-variable region of the subroutine's stack frame; 
Ll holds the size of the temporary-variable region. Unfortunately, for reasons that I'll 
discuss in a moment, neither size is known until after the entire subroutine has been pro­
cessed. The compiler solves the problems by generating the LO and Ll labels at the same 
time that it outputs the link instruction. The label names are stored internally in the 
Vspace and Tspace arrays in Listing 6.57. The compiler puts the function name into 
Funct __ name at the same time. Later on in the parse, after the subroutine has been pro­
cessed and the sizes of the two regions are known, the compiler emits the #defines to 
the data segment, using the previously generated labels. 17 
The code to do all of the foregoing is in the first action of the following prodution: 
ext_def-Mpt_specifiersfunct_decl { ... } def_list { ... } compound_stmt { ... }; 
found on lines 522 to 546 of Listing 6.58. The attribute attached to thefunct_decl at $2 
17. This technique is necessary only if you are generating code for a single-pass assembler. Two-pass 
assemblers let you define a label after it's used-the definition is picked up in the first pass and 
substitutions are made in the second. The two-pass VAX/UNIX assembler just generates the labels at the end 
of the subroutine code. 
Section 6.6.4-Function Declarations 553 
Table 6.15. A Parse of pooh (piglet, eeyore) long eeyore; {} 
Stack Next Action 
I (empty) Reduce: ext_ de!_ list ~E 
DATA: #include <tools/virtual.h> 
DATA: #define T (x) 
DATA: SEG (data) 
CODE: SEG(code) 
BSS: SEG (bss) 
2 ext_ def_list Reduce: opt specifiers~£ 
3 ext def list opt specifiers Shift: NAME 
4 ext def list opt_specifiers NAME Reduce: new name~NAME 
5 ext_ def list opt specifiers new name Shift: LP 
6 ext def list opt specifiers new name LP Reduce: { 2 8) ~E 
7 ext_def list opt_specifiers new_ name LP { 28) Shift: NAME 
8 ext def list opt specifiers new name LP { 28) NAME Reduce: new name~NAME 
9 ext def list opt specifiers new_ name LP { 28) new_name Reduce: name list~new name 
10 ext def list opt specifiers new name LP { 28) name_Iist Shift: COMMA 
II ext_def_list opt_specifiers new _name LP { 28) name_list COMMA Shift: NAME 
12 ext def_list opt specifiers new name LP { 2 8) name_list COMMA NAME Reduce: new name~NAME 
13 ext_ def_list opt _specifiers new_ name LP { 2 8) name_list COMMA new _name Reduce: name list~ 
name list COMMA new name - -
14 ext def list opt specifiers new name LP { 2 8) name_list Reduce: { 2 9) ~E 
15 ext_def_list opt_specifiers new name LP { 28) name_Iist { 29) Shift: RP 
16 ext_def_list opt_specifiers new _name LP { 28) name_Iist { 29) RP Reduce:funct_decl~ 
new _name LP { 28) name_list { 2 9) 
RP 
17 ext_ def_list opt _specifiers funct _dec/ Reduce: {51)~£ CODE: #undef T 
CODE: #define T (n) (fp-LO-(n*4)) 
CODE: PROC(_pooh,public) CODE: 
link (LO+ L1) ; 
18 ext def list opt specifiers funct dec/ { 51 ) Reduce: def list~£ 
19 ext_ def_list opt_ specifiers funct _dec/ { 51 ) def_list Shift: TYPE 
20 ext_def_list opt_specifiersfunct_decl {51) def_list TYPE Reduce: type specifier~TYPE 
21 ext def list opt specifiersfunct dec/ {51) def_list type_specifier Reduce: type or class~type specifier 
22 ext def list opt specifiersfunct dec/ {51) def_list type_or_class Reduce: specifiers~type or class 
23 ext def list opt specifiersfunct dec/ {51) def_list specifiers Shift: NAME 
24 ext_def_list opt_specifiersfunct_decl {51) def_list specifiers NAME Reduce: new name~NAME 
25 ext def list opt specifiersfunct_decl {51) def_list specifiers new_name Reduce: var decl~new name 
26 ext def list opt specifiersfunct dec/ {51) def_Iist specifiers var_decl Reduce: decl~var dec/ 
27 ext def list opt_specifiersfunct dec/ {51) def_list specifiers decl Reduce: dec/ list~decl 
28 ext_def_list opt_specifiersfunct_decl {51) def_list specifiers decl_list Reduce: {65)~E 
29 ext_def list opt specifiersfunct dec/ {51) def_list specifiersdecl_list {65) Shift: SEMI 
30 ext_def_list opt_specifiersfunct_dec/ {51) def_list specifiers decl_list { 65) Reduce: def~specifiers dec/ _list { 65) SEMI 
SEMI 
31 ext def list opt_specifiersfunct dec/ {51) def_list def Reduce: def list~def list def 
32 ext_def_list opt_specifiersfunct_dec/ {51) def_list Reduce: {52) ~E CODE: /* fp+4 = 
piglet [arg] */CODE: /* fp+B = 
eeyore [arg] *I 
33 ext def list opt specifiersfunct dec/ {51) def_Iist {52) Shift: LC 
34 ext_def_list opt_specifiersfunct_dec/ {51) def_list {52) LC Reduce: { 71 ) ~E 
continued ••• 
554 Code Generation -Chapter 6 
Table 6.15. Continued. A Parse of pooh (piglet, eeyore) long eeyore; { } 
Stack Next Action 
35 ext def list opt specifiers june! dec/ {51} def_list {52} LC { 71} Reduce: def list~£ 
36 ext def list opt_specifiersfunct_decl {51} def_list {52} LC { 71} def_list Reduce: local_ defs ~def_list 
37 ext_def_list opt_specifiersfunct_decl {51} def_list {52} LC { 71} local_defs Reduce: stmt list~£ 
38 ext_def_list opt_specifiersfunct_decl {51} def_list {52} LC { 71} local_defs Shift: RC 
stmt_list 
39 ext_def_list opt_specifiers funct_dec/ {51} def_list {52} LC { 71} local_defs Reduce: compound _stmt~ 
stmt_list RC LC {71} local_defs stmt_list 
RC 
40 ext_def_list opt_specifiersfunct_decl {51} def_list {52} compound_stmt Reduce: ext_ def~opt _specifiers June!_ dec/ 
{ 51 } def_list { 52 } compound_stmt 
CODE: unlink (); 
CODE: ret(); 
CODE: ENDP(__pooh) 
BSS: #define LO 0 I* pooh loc. *I 
BSS: #define L1 0 I* pooh tmp. *I 
41 ext def list ext def Reduce: ext_ def_list ~ext_ def_list ext_ def 
42 ext_ de!_list Reduce: program~ext_def_list 
Accept 
Listing 6.56. Compiler Output for Function Definition 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 #include <tools/virtual.h> 
#define T {x) 
SEG(data) 
SEG(bss) 
#define LO 0 
#define Ll 0 
SEG(code) 
#undef T /* pooh: locals */ 
/* pooh: temps. */ 
#define T (n) (fp-LO- {n*4)) 
PROC(_pooh,public) 
link(LO+Ll); 
/* fp+4 
/* fp+B piglet [argument} */ 
eeyore [argument} */ 
/* Code from the body of the subroutine goes here. */ 
unlink(); 
ret(); 
ENDP (_pooh) 
symbol. args, cross 
links. is a pointer to a symbol, and the args field of that structure is itself a pointer to a linked 
list of additional symbol structures, one for each argument. The arguments, along with 
an entry for the function itself, are put into the symbol table on lines 530 to 532 of List­
ing 6.58. Putting the elements in the table does not affect the cross links. The arguments 
still form a linked list after the insertion. The gen () calls on line 540 and 541 actually 
emit the PROC and link directives-1'11 come back to this subroutine later, when I dis­
cuss expression processing. The L prefix in the variable- and temporary-space labels, is 
put into the labels on lines 535 and 536 of Listing 6.58. L _LINK is defined along with 
several other label prefixes in label.h, Listing 6.59. These other label prefixes are used Alphabetic componants 
of output labels, label.h. 
Section 6.6.4-Function Declarations 
Listing 6.57. c.y-Global Variables for Function-Declaration Processing (from Occs Definitions Section) 
125 %{ 
126 char 
127 char 
128 Vspace[16]; 
Tspace[16]; /* The compiler doesn't know the stack-frame size 
*when it creates a link() directive, so it outputs 555 
129 
130 
131 
132 * a link(VSPACE+TSPACE). Later on, it #defines VSPACE 
* to the size of the local-variable space and TSPACE 
* to the size of the temporary-variable space. Vspace 
* holds the actual name of the VSPACE macro, and 
133 
134 * Tspace the TSPACE macro. (There's a different name 
* for each subroutine.) 
135 *I 
136 
137 char 
138 %} Funct_name[ NAME MAX+l ]; /* Name of the current function */ 
for processing if statements, while loops, and so on. I'll discuss them further when the 
flow control statements are presented. 
The parser now handles the K&R-style argument definitions. The new symbol-table 
entries are all of type int, because the funct _dec/ contains a name _list, not a var _list. 
Since no types are specified in the input argument list, int is supplied automatically. 
The parser processes the def_list next. When the def_list-processing is finished, the attri­
bute at $4-the previous action was $3-will be a pointer to a linked list of symbols, 
one for each formal definition. The fix_types_and_discard_syms () call on line 
549 of Listing 6.58 looks up each of the redefined symbols in the symbol table. If the 
symbol is there, the type is modified to reflect the redefinition; if it's not, an error mes­
sage is generated. This subroutine also discards the symbol structures used for the 
redefinitions. The figure_param_offsets () call on line 550 traverses the argu­
ment list again because some elements of the list have just been modified to have new 
types. It patches the symbol structures so that the rname field holds an expression that 
can be used in a C-code instruction to access the variable. All these expressions are rela­
tive to the frame pointer (WP ( fp-8) and so forth). The position in the argument list 
determines the value of the offset. The print_ offset_ comment() on line 551 prints 
the comment in the middle of the output that shows what all of these offsets are. All 
three subroutines are in Listing 6.60. 
Skipping past the function body and local-variable processing for a moment (all 
these are done in the compound_stmt), the end-of-function processing is all done in the 
third action in Listing 6.58, on lines 556 to 575. The remove_ symbols_ from_­
table ( ) call on line 560 deletes all the subroutine arguments from the symbol table. 
The subroutine itself stays in the table, however-it's a global-level symbol. The 
discard_ symbol_ chain () call on the next line frees the memory used for the asso­
ciated symbol structures and associated type chains. The structure-table is not 
modified, so the structure definition persists even though the variable doesn't. Finally, 
the end-of-function code is output with the three gen () calls on the following lines, and 
the link-instruction labels are emitted on lines 568 to 571 of Listing 6.58. K&R-style argument 
definitions. 
End-of-function 
processing. 
link labels emitted. 
556 Code Generation -Chapter 6 
Listing 6.58. c.y-High-Level, External Definitions (Part Three) 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 I* ext def : *I 
I opt_specifiers funct_decl 
{ 
static unsigned link_val = 0; /* Labels used for link args.*/ 
add_spec_to_decl( $1, $2 ); 
if( !$1->tdef ) /* Merge the specifier and */ 
/* declarator. */ 
discard link chain( $1 ) ; /* Discard extra specifier. */ 
figure_osclass 
add_symbols_to_table 
add_symbols_to_table $2 ) ; /* Update symbol table. */ 
/* Add function itself. */ 
/* Add the arguments. */ $2 ) ; 
$2->args ) ; 
strcpy ( Funct_name, $2->name ); 
sprintf( Vspace, "%s%d", L_LINK, link val++ ) ; 
sprintf( Tspace, "%s%d", L_LINK, link val++); 
yycode( "\n#undef T\n" ); 
yycode( "#define T(n) (fp-%s-(n*4))\n\n", Vspace ); 
gen( "PROC", $2->rname, $2->etype->STATIC? "private":"public"); 
gen( "link", Vspace, Tspace ); 
++Nest lev; /* Make nesting level of definition list 
* match nesting level in the funct decl 
*I 
def list 
{ 
fix_types_and_discard_syms 
figure_param_offsets 
print_offset_comment $4 ) ; 
$2->args ); 
$2->args, "argument" ); 
--Nest lev; /* It's incremented again in the compound_stmt */ 
compound_stmt 
{ 
purge_ undecl () ; 
remove_symbols_from_table 
discard_symbol_chain /* Deal with implicit declarations */ 
/* and undeclared symbols. *I 
$2->args ); /*Delete arguments. */ 
$2->args ); 
gen( ":%s%d", L RET, rlabel(l) ) ; /* End-of-function *I 
gen ( 
gen ( 
gen ( 
yybss 
yybss -"unlink" ) ; /* code. *I 
"ret" ) ; 
"ENDP", $2->rname ) ; 
"\n#define %s %d\t/* %s: locals */\n", 
Vspace, loc_var_space(), $2->name ); 
"#define %s %d\t/* %s: temps. */\n", 
Tspace, tmp_var_space(), $2->name ); 
tmp_reset(); /* Reset temporary-variable system.*/ 
/* (This is just insurance.) */ 
Section 6.6.4-Function Declarations 557 
Listing 6.59./abel.h- Output-label Definitions 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 /* This file contains definitions tor the various label prefixes. All labels 
* take the form: <prefix><number>, the <number> supplied by the code-generation 
* action. The prefixes are defined here. 
*I 
#define L BODY 
#define L COND END 
#define L COND FALSE 
#define L DOEXIT 
#define L DOTEST 
#define L DOTOP 
#define L ELSE 
#define L END 
#define L FALSE 
#define L INCREMENT 
#define L LINK 
#define L NEXT 
#define L RET 
#define L STRING 
#define L SWITCH 
#define L TEST 
#define L TRUE 
#define L VAR "BDY" 
"QE" 
"QF" 
"DXIT" 
"DTST" 
"DTOP" 
"EL" 
"E" 
"F" 
"INC" 
"L" 
"EXIT" 
"RET" 
"S" 
"SW" 
"TST" 
"T" 
"V" /* Top of the body of a tor loop. */ 
/* End of conditional. */ 
/*True part of conditional (?:). */ 
/* Just after the end of the do/while. */ 
/* Just above the test in a do/while. */ 
/* Top of do/while loop. */ 
/* Used by else processing. */ 
/* End of relational/logical op. */ 
/* False target of relational/logical op. */ 
/* Just above the increment part of for loop. */ 
/* Offset passed to link instruction. */ 
/* Outside of loop, end of if clause. */ 
/* Above clean-up code at end of subroutine. */ 
/* Strings. */ 
/* Used for switches. */ 
/* Above test in while/for/it. */ 
/* True target of relational/logical operator.*/ 
/* Local-static variables. */ 
Listing 6.60. decl.c-Process Subroutine Arguments 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 void fix_types_and_discard_syms( sym) 
symbol *sym; 
{ 
/* Patch up subroutine arguments to match formal declarations. 
* 
* Look up each symbol in the list. If it's in the table at the correct 
* level, replace the type field with the type for the symbol in the list, 
* then discard the redundant symbol structure. All symbols in the input 
* list are discarded after they're processed. 
* * Type checking and automatic promotions are done here, too, as follows: 
* chars are converted to int. 
* 
* 
* arrays are converted to pointers. 
structures are not permitted. 
* All new objects are converted to autos. 
*I 
symbol *existing, *s; 
while( sym 
{ 
if( ! ( existing (symbol *)findsym( Symbol_tab,sym->name) ) 
I I sym->level != existing->level 
yyerror("%s not in argument list\n", sym->name ); 
exit (1); 
558 Code Generation -Chapter 6 
Listing 6.60. continued ... 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 
571 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 else if( !sym->type I I !sym->etype ) 
yyerror("INTERNAL, fix_types: Missing type specification\n"); 
exit(l); 
else if( IS_STRUCT(sym->type) 
{ 
yyerror("Structure passing not supported, use a pointer\n"); 
exit (1); 
else if( !IS_CHAR(sym->type) ) 
{ 
/* The existing symbol is of the default int type, don't redefine 
* chars because all chars are promoted to int as part of the call, 
* so can be represented as an int inside the subroutine itself. 
*I 
/* Make it a pointer to the */ if( IS_ARRAY(sym->type) 
sym->type->DCL_TYPE POINTER; /* first element. */ 
sym->etype->SCLASS = AUTO; 
discard_link_chain(existing->type); 
existing->type = sym->type; 
existing->etype = sym->etype; 
sym->type = sym->etype = NULL; 
s sym->next; 
discard_symbol( sym ) ; 
sym = s; /* Make it an automatic var. */ 
/* Replace existing type */ 
/* chain with the current one.*/ 
I* Must be NULL for discard -*I 
/*symbol() call, below. */ 
/*----------------------------------------------------------------------*/ 
int figure_param_offsets( sym) 
symbol *sym; 
{ 
/* Traverse the chain of parameters, figuring the offsets and initializing 
* the real name (in sym->rname) accordingly. Note that the name chain is 
* assembled in reverse order, which is what you want here because the 
* first argument will have been pushed first, and so will have the largest 
* offset. The stack is 32 bits wide, so every legal type of object will 
* require only one stack element. This would not be the case were floats 
* or structure-passing supported. This also takes care of any alignment 
* difficulties. 
* * Return the number of 32-bit stack words required for the parameters. 
*I 
int offset 
int i; 4; /*First parameter is always at BP(fp+4). */ 
for(; sym ; sym = sym->next ) 
{ 
if( IS_STRUCT(sym->type) ) 
{ 
yyerror("Structure passing not supported\n"); 
continue; 
Section 6.6.5 -Compound Statements and Local Variables 
Listing 6.60. continued ... 
616 
617 
618 
619 
620 sprintf( sym->rname, "fp+%d", offset ) ; 
offset += SWIDTH ; 
621 
622 
623 
624 
625 I* Return the offset in stack elements, rounded up if necessary. *I 
return( (offset I SWIDTH) + (offset% SWIDTH != 0) ); 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 1*----------------------------------------------------------------------*l 
void 
symbol 
char print_offset_comment( sym, label ) 
*sym; 
*label; 
I* Print a comment listing all the local variables. *I 
for(; sym ; sym = sym->next ) 
yycode( "\tl* %16s = %-16s [%s] *1\n", sym->rname, sym->name, label); 
6.6.5 Compound Statements and Local variables 
The next issue is the function body, which consists of a compound_stmt. As you can 
see from Listing 6.61, below, a compound statement is a list of statements (a stmt_list) 
surrounded by curly braces. Local-variable definitions (local_ defs) can appear at the 
beginning of any compound statement, and since this same production is also used to 
process multiple-statement bodies of loops, and so forth, local variables can be defined at 
any nesting level. 18 The inner variables must shadow the outer ones until the compiler 
leaves its scoping level, however. The local version of the variable is used instead of 
another variable declared at a more outer level with an identical name. Function bodies, 
compound_stmt. 
Nested variable 
definitions. 559 
It's difficult, though certainly possible, to modify the size of the stack frame every 
time that the compiler enters or leaves a scoping level. The main difficulty is 
temporary-variable management, which is much easier to do if the temporary variable 
space doesn't move around or change size during the life of a subroutine. My solution is 
to allocate space for all local variables, regardless of the scoping level, with the single 
link instruction at the top of the subroutine. From a space-allocation perspective, all 
variables are treated as if they were declared in the outermost scoping level at run time. 
At compile time, however, the symbol-table entry for an inner variable is created when 
that variable is declared, and it is deleted when the compiler leaves the scoping level for 
that variable. Even though an inner variable continues to exist at run time, that variable 
cannot be accessed from outside the compound statement because the symbol-table entry 
for the variable won't exist. Handling scoping levels, 
memory allocation. 
The obvious problem with this approach is that memory is wasted. In the following 
fragment, for example, the stack region used to store castor could be recycled for use 
by pollux; it isn't: 
18. This is quite-legal C, though the practice is discouraged because it makes it difficult to find the variable 
definitions when they're buried in a subroutine. 
560 Code Generation -Chapter 6 
Listing 6.61. c.y-Compound Statements 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 compound_stmt 
: LC ++Nest lev; 
loc_reset(); 
local defs stmt list RC --Nest_lev; 
remove_symbols from_table 
discard_symbol_chain 
local defs 
def list add_symbols_to_table 
figure_local_offsets 
create static locals 
print_offset comment 
int castor; 
int pollux; $3 ) ; 
$3 ) ; 
$$=reverse links( $1 )) ; 
$$, Funct name ); 
$$, Funct name ); 
$$, "variable" ) ; 
Local-variable definitions are handled by the productions in Listing 6.61 and the sub­
routines in Listing 6.62. The def_list nonterminal on line 588 of Listing 6.61 is the same 
production that's used for structure fields. Its attribute is a pointer to the head of a linked 
list of symbols, one for each declaration. These symbols are added to the symbol table 
on line 588 in Listing 6.61. 
Listing 6.62. local.c- Local-Variable Management 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
#include <tools/l.h> 
#include <tools/compiler.h> 
#include <tools/c-code.h> 
#include "symtab.h" 
#include "proto.h" 
#include "label.h" 
/* LOCAL.C Subroutines in this file take care of local-variable management. */ 
PRIVATE int Offset = 0 ; /* Offset from the frame pointer (which also */ 
I* marks the base of the automatic-variable */ 
/* region of the stack frame) to the most */ 
/* recently allocated variable. Reset to 0 */ 
/* by loc_reset () at the head of every sub-*I 
/* routine. */ 
Section 6.6.5 -Compound Statements and Local Variables 561 
Listing 6.62. continued ... 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 extern void yycode(), yydata(), yybss(), yycomment(); 
1*----------------------------------------------------------------------*l 
void 
{ loc_reset () 
I* Reset everything back to the virgin state. Call this subroutine just *I 
I* before processing the outermost compound statement in a subroutine. *I 
Offset = 0 ; 
1*----------------------------------------------------------------------*l 
int loc_var_space() 
I* Return the total cumulative size of the temporary-variable region in 
*stack elements (not bytes). This call outputs the value of the macro 
* that specifies the variable-space size in the link instruction. Calling 
* loc_reset() also resets the return value of this subroutine to zero. 
*I 
return( (Offset+ (SWIDTH-1)) I SWIDTH); 
1*----------------------------------------------------------------------*l 
void 
symbol 
char figure_local_offsets( sym, funct name 
*sym; 
*funct_name; 
{ 
I* I* Add offsets for all local automatic variables in the sym list. *I 
for(; sym ; sym = sym->next ) 
if( !IS_FUNCT( sym->type ) && !sym->etype->STATIC ) 
loc_auto_create( sym ); 
- - - - - - - - - - - - - - - - - - - - - -*1 
void loc auto_create( sym 
symbol *sym; 
{ 
I* Create a local automatic variable, modifying the "rname" field of "sym" 
* to hold a string that can be used as an operand to reference that 
* variable. This name is a correctly aligned reference of the form: 
* 
* 
* fp + offset 
* Local variables are packed as well as possible into the stack frame, 
* though, as was the case with structures, some padding may be necessary 
* to get things aligned properly. 
*I 
int align_size = get_alignment( sym->type ); 
Offset+= get_sizeof( sym->type ); 
while( Offset % align_size 
++Offset; I* Offset from frame pointer *I 
I* to variable. *I 
I* Add any necessary padding *I 
I* to guarantee alignment. *I 
562 Code Generation -Chapter 6 
Listing 6.62. continued ... 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 sprintf( sym->rname, "fp-%d", Offset); 
sym->etype->SCLASS = AUTO; /* Create the name. 
/*----------------------------------------------------------------------*/ 
void 
symbol 
char create_static_locals( sym, funct name 
*sym; 
*funct_name; 
/* Generate definitions for local, static variables in the sym list. */ 
for(; sym ; sym = sym->next 
if( !IS FUNCT( sym->type ) && sym->etype->STATIC 
loc_static_create ( sym, funct_name ); 
I* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/ 
void 
symbol 
char 
{ loc static_create( sym, funct name 
*sym; 
*funct_name; *I 
static unsigned val; /* Numeric component of arbitrary name. */ 
sprintf( sym->rname, "%s%d", L_VAR, val++ ) ; 
sym->etype->SCLASS FIXED 
sym->etype->OCLASS = PRI 
var_dcl ( yybss, PRI, sym, ";" ) ; 
yybss ( "\t/* %s [%s (), static local] */\n", sym->name, funct_name ) ; 
/*----------------------------------------------------------------------*/ 
void remove_symbols_from_table( sym) 
symbol *sym; 
{ 
/* Remove all symbols in the list from the table. */ 
symbol *p; 
for( p = sym; p ; p = p->next 
if( !p->duplicate ) 
delsym( Symbol_tab, p ); 
else 
{ 
yyerror("INTERNAL, remove_symbol: duplicate sym. in cross-link\n"); 
exit( 1 ); 
Automatic variables: 
figure_local_ 
offsets(). The figure_local_offsets () call on line 589 of Listing 6.61 handles 
automatic variables. (The subroutine is on line 45 of Listing 6.62.) It goes through the 
list, adjusting the rnames to hold a string which, when used in an operand, references 
the variable. Ultimately, the reference will look something like this: WP (fp+6), but 
only the fp+ 6 is created here-the WP and parentheses are added later by the 
expression-processing code. 
Offset. The current offset from the base of the automatic-variable region is remembered in 
Offset, which is incremented by the size of each variable as space for it is allocated. 
Section 6.6.6-Front-End/Back-End Considerations 563 
The variables are packed as closely as possible into the local-variable space. If align­
ment permits, they are placed in adjacent bytes. As with structures, padding is inserted if 
necessary to guarantee alignment. figure_local_offsets () is called at the top of 
every block, but Offset is reset to zero only at the top of the subroutine, so the size of 
the local-variable region continues to grow over the life of the subroutine as automatic 
variables are allocated. The final size of the region is determined once the entire subrou-
tine has been processed by calling loc _ var _space () on line 33 of Listing 6.62. This loc _ var _space 0 · 
value is used at the end of the subroutine-processing code to define one of the macros 
that's passed to the link instruction. 
The create_ static _locals () call on line 590 of Listing 6.61 handles static Static-local variables: 
locals. The subroutine starts on line 84 of Listing 6.62. It goes through the list a second create_static_locals 0 
time, allocating space for the variable as if it were a static global variable. An arbi-
trary name is assigned instead of using the declared name, as was the case with true glo-
bals. This way, two subroutines can use the same name for a static variable without a 
conflict. All static locals are declared private, so conflicts with variables in other 
modules are not a problem. Symbols are removed from the table when the compiler 
leaves the scoping-level on lines 582 and 583 of Listing 6.61. 
6.6.6 Front-End/Back-End Considerations 
Packing variables onto the stack makes sense in a one-pass compiler, but it's con­
traindicated if the real code is going to be generated by a back end. The front end has no 
way of knowing what alignment restrictions apply to the target machine or the actual 
sizes of the various types. The back end's life can be made easier by assuming that all 
types are the same size and that there are no alignment restrictions. As it is, the back end 
might have to undo some of our work. If an int is 32 bits, it must unpack the variables. 
Similarly, if the worst-case alignment restriction is two rather than four, it must get rid of 
the extra padding. 
If the front end is ignoring size and alignment, some mechanism is needed to pass the 
symbol-table information to the back end. Currently, the compiler's just throwing that 
information away when it leaves the scoping level. A better approach passes the symbol 
table to the back end as part of the intermediate code. For example, you can introduce a 
new, local storage class to C-code and generate definitions for all local symbols at the 
top of a block along with the static-variable definitions. A matching delete (name) 
directive can be generated at the end of the block to tell the back end that the symbol had 
gone out of scope. 
There's no need to worrying about the size at the intermediate-code level if all vari­
ables are the same size, The compiler's been keeping track of the size so that we can use 
W (), L () and so forth to access variables, but it wouldn't have to do so if everything was 
the same size. Consequently, both global and local variables can just be called out by 
name in the intermediate code. You can dispense with all the size-related, C-code 
addressing modes and register-access directives and just use the names: _p, rather than 
WP ( & _P) or WP ( fp-16), rO rather than rO. pp. The back end can compute the offsets 
for local variables and make any necessary adjustments to the generated code, replacing 
the symbolic names with stack-relative access directives as necessary. This one change 
dramatically simplifies both the design of C-code and the complexity of the front end. 
All of the foregoing applies to structures as well as simple variables-the fields 
should all be the same size and not be packed into the structure. Better yet, the front end 
could make no attempt to determine the offset to the field from the base of the structure. 
Structure members could be passed to the back end like this: 
member type structure_ name.field _name; Don't pack variables if 
back end is used. 
Passing symbol table in­
formation to back end. 
No need to keep track of 
sizes. 
564 
Reasons to use gen < > . 
@ as first character in 
format string. 
Add comments to output 
code,gen_comment(). Code Generation -Chapter 6 
and the fields could be called out by name in the intermediate code rather than generat­
ing explicit offsets to them, using something like struct _name. member_ name. 
6. 7 The gen ( ) Subroutine 
The gen ( ) subroutine was used in the last section to print out the few C-code 
instructions in the subroutine prefix and suffix. gen ( ) is a general-purpose code­
generation interface for the parser-all C-code instructions are emitted using gen () 
calls rather than yycode () calls. It seems reasonable to look at it now, before using it 
further. I've concentrated the code emission into a single subroutine for several reasons: 
• Clarity in the source code. Once you've added leading tabs, trailing newlines, field 
widths, and so forth, direct yycode ( ) calls are pretty hard to read. Since gen ( ) 
takes care of all the formatting for you, the subroutine calls are more understandable, 
and the code more maintainable as a consequence. gen ( ) also makes the output 
code more readable because the code is formatted consistently. 
• Fewer C-code syntax errors. There are slight variations in syntax in the C-code 
instruction set. Some instructions must be followed by semicolons, others by colons, 
and still others by no punctuation at all. Some instructions take parenthesized argu­
ments, others do not. gen ( ) takes care of all these details for you, so the odds of a 
syntax error showing up in the output are much smaller. 
• Portability. Since all the output is concentrated in one place, it's much easier to 
make changes to the intermediate language. You need only change a single subrou­
tine instead of several yycode () calls scattered all over the parser. Similarly, it's 
easy to emit binary output rather than ASCII output-just change gen () to emit 
binary directly.19 
• Debugging. The compiler takes a command line switch that causes it to generate a 
run-time trace. Instead of emitting a single C-code directive, the compiler emits the 
C-code directive surrounded by statements that print the directive itself, the contents 
of all the virtual registers, and the top few stack elements. This way, you can watch 
the effect of every output instruction as it's executed. It is much easier to emit these 
extra run-time-trace statements when all output is concentrated in one place. 
The first argument to gen () is a string that specifies the instruction to emit-usually 
the op code. The number and type of any additional arguments are controlled by the first 
one-legal first arguments are summarized in Table 6.16. If an argument is a character­
pointer, the string is printed; if it's an int, the number is converted to a string and 
printed, and so on. In addition, if the first character of an arithmetic instruction is an @, 
the @ is removed and a * is printed to the left of the destination string. This call: 
gen ( "@+=", "dst", "src" ) ; 
generates this code: 
*dst += src; 
The gen ( ) subroutine is implemented in Listing 6.63 along with various support 
routines. gen _comment () (on line 81) puts comments in the output. It works like 
print f (),except that the output is printed to the right of the instruction emitted by the 
19. This argument also holds for the code that creates declarations. I should have funneled all declarations 
through a single subroutine rather than using direct yydata () and yybss () calls. You may want to 
make that change to the earlier code as an exercise. 
Section 6.7-The gen () Subroutine 
Table 6.16. The gen () Interface 
First 
Argument 
"%=" 
"&=" 
"*=" 
"*=%s%d" 
"+=" 
"+=%s%d" 
"-=" 
"-=%s%d" 
"/=" 
"/=%s%d" 
"<<=" 
">>=" 
">L=" 
"=-" 
II I=" 
11""-11 Second 
Argument 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; 
char *dst; Third 
Argument 
char *src; 
char *src; 
char *src; 
int src; 
char *src; 
int src; 
char *src; 
int src; 
char *src; 
int src; 
char *src; 
char *src; 
char *src; 
char *src; 
char *src; 
char *src; 
char *src; Output 
dst %= src; 
dst &= src; 
dst *= src; 
dst *= src; 
dst += src; 
dst += src; 
dst -= src; 
dst -= src; 
dst /= src; 
dst /= src; 
dst <<= src; 
dst >>= src; 
lrs(dst,src); 
dst =-src; 
dst =-src; 
dst I= src; 
dst ·= src; modulus 
bitwise AND 
multiply Description 
multiply dst by constant 
add 
add constant to dst 
subtract 
subtract constant from dst 
divide 
divide dst by constant 
left shift dst by src bits 
right shift dst by src bits 
logical right shift dst by src bits 
two's complement 
one's complement 
bitwise OR 
bitwise XOR 
assign 
load effective address 565 
II=&" 
"=*%s%v" char *dst; 
char *dst; 
char *dst; char *src; 
char *src; 
value *src; dst = src; 
dst = &src; 
dst = *name; 
dst = name; assign indirect. name is taken from src->name. If 
the name is of the form &name, then dst=name is 
output, otherwise dst=*name is output. 
":%s%d" 
"BIT" 
"EQ" 
"EQ%s%d" 
"GE" 
"GT" 
"LE" 
"LT" 
"NE" 
"U GE" 
"U GT" 
"U LE" 
"U LT" 
"PROC" 
"ENDP" 
"call" 
"ext_high" 
"ext low" 
"ext word" 
"goto" 
"goto%s%d" 
"link" 
"pop" 
"push" 
"ret" 
"unlink" char *label; 
char *alpha; 
char *op1; 
char *op1; 
char *op1; 
char *op1; 
char *op1; 
char *op1; 
char *op1; 
char *op1; 
char *opl; 
char *op1; 
char *op1; 
char *op1; 
char *name; 
char *name; 
char *label; 
char *dst; 
char *dst; 
char *dst; 
char *label; 
char *alpha; 
char *loc; 
char *dst; 
char *src; 
(none) 
(none) (none) 
int num; 
char *bit; 
char *op2; 
int op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *op2; 
char *cls; 
(none) 
(none) (none) (none) 
(none) 
(none) 
int num; 
char *tmp; 
char *type; 
(none) 
(none) 
(none) label: 
alphanum: 
BIT(op1,bit) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
EQ(op1,op2) 
PROC(name,cls) 
ENDP(name) 
call(label); 
ext_high(dst); 
ext low(dst); 
ext_word(dst); 
goto label; 
goto alphanum; 
link (loc+tmp); 
dst = pop (type); 
push(src); 
ret (); 
ret (); label 
label, but with the alphabetic and numeric com­
ponents specified separately. gen (": %s%d", "P", 
10) emits P10:. 
test bit 
equality 
equal to constant 
greater than or equal 
greater than 
less than or equal 
less than 
not equal 
greater than or equal, unsigned 
greater than, unsigned 
less than or equal, unsigned 
less than, unsigned 
start procedure 
end procedure 
call procedure 
sign extend 
sign extend 
sign extend 
unconditional jump 
unconditional jump, but the alphabetic and numeric 
components of the target label are speci lied 
separately. gen("goto%s%d", "P", 10) emits 
goto P10;. 
link 
pop push 
return 
unlink 
next gen () call. gen corrunent () stores the comment text in Corrunent buf 
(declared on line 77) so that it can be printed by a subsequent gen () call. 
The enable_trace () and disable_trace () subroutines on lines 100 and 101 
enable and disable the generation of run-time trace statements. Run-time trace, 
enable_trace (), 
disable_trace(). 
566 
Strength reduction. 
Instruction output and 
formatting: 
print_instruction(). 
Run-time trace instruc­
tions: _Po ,_To. Code Generation -Chapter 6 
gen () itself starts on line 113. It uses the lookup table on lines 21 to 74 to translate 
the first argument into one of the tokens defined on lines 13 to 19. The table lookup is 
done by the bsearch () call on line 132. Thereafter, the token determines the number 
and types of the arguments, which are pulled off the stack on lines 138 to 149. The ANSI 
variable-argument mechanism described in Appendix A is used. gen ( ) does not emit 
anything itself-it assembles a string which is passed to a lower-level output routine. 
The switch starting on line 156 takes care of most of the formatting, using sprintf () 
calls to initialize the string. Note that a simple optimization, called strength reduction is 
done on lines 201 to 229 in the case of multiplication or division by a constant. If the 
constant is an even power of two, a shift is emitted instead of a multiply or divide direc­
tive. A multiply or divide by 1 generates no code at all. The comment, if any, is added 
to the right of the output string on line 236. 
The actual output is done in print_instruction () on line 247 of Listing 6.63. 
This subroutine takes care of all the formatting details: labels are not indented, the state­
ment following a test is indented by twice the normal amount, and so forth. 
print_instruction () also emits the run-time trace directives. These directives are 
written directly to yycodeout [with fprintf () calls rather than yycode () calls] so 
that they won't show up in the IDE output window. The trace is done using two macros: 
_P () prints the instruction, and_ T () dumps the stack and registers. Definitions for 
these macros are written to the output file the first time that print_ instruction () is 
called with tracing enabled (on Line 262 of Listing 6.63). The output definitions look 
like this: 
#define _P(s) printf( s ) 
#define _T() pm(),printf(\"-------------------------------\\n\") 
_P () just prints its argument, _ T () prints the stack using a pm () call-pm () is 
declared in 
Most statements are handled as follows: 
a = b; _P ( "a = b;" ) 
_T() 
The trace directives are printed at the right of the page so that the instructions them­
selves will still be readable. The instruction is printed first, then executed, and then the 
stack and registers are printed. Exceptions to this order of events are as follows: 
label: p ( "label:" ) 
PROC ( ••• ) _P( "PROC( •• . ) " ) ; -T (); 
_P( "ret ( .. . ) " ) 
ret ( .. . ) ; 
_P( "ENDP ( ••• )" ) 
ENDP( ••• ) 
The trace for a logical test is tricky because both the test and the following instruction 
must be treated as a unit. They are handled as follows: 
_P ( "NE (a, b)" ) 
NE(a,b) { 
instruction; P ( "goto x" ) ; 
_T (); } 
Section 6. 7-The ge n () Subroutine 
Listing 6.63. gen.c-C-code Generation 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 #include <stdio.h> 
#include <stdarg.h> 
#include <toolsldebug.h> 
#include <toolslhash.h> 
#include <toolsll.h> 
#include <toolslcompiler.h> 
#include "symtab.h" 
#include "value.h" 
#include "proto.h" 
PRIVATE int Trace = 0; I* Generate run-time trace if true. *I 
typedef anum request 
{ 
t_assign_addr, t_assign_ind, t_call, t_endp, t_ext, t_goto, t_goto_int, 
t_label, t_label_int, t_link, t_logical, t_logical_int, t_lrs, t_math, 
t_math_int, t_pop, t_proc, t_push, t_ret, t unlink 
request; 
struct ltab 
{ 
char *lexeme; 
request token; 
} 
Ltab[] 
{ 
{"%=", 
{"&=", 
{"*=", 
{"*=%s%d", 
{"+=", 
{"+=%s%d", 
{"-=", 
{"-=%s%d", 
1"1=", 
l"l=%s%d", 
{II • II . , 
{":%s%d", 
{"<<=", 
{"-" -, 
{"=&", 
{"=*%s%v", 
{"=-", 
{">>=", 
{">L=", 
{"BIT", 
{"ENDP", 
{"EQ", 
{ "EQ%s%d", 
{"GE", 
{"GT", 
{"LE", {"LT", 
{"NE", 
{"PROC", 
{"U_ GE", 
{"U_ GT", 
{"U_ LE", t math 
t math 
t math 
t math int 
t math 
t math int 
t math 
t math int 
t math 
t math int 
t label 
t label int 
t math 
t math 
t _assign_ addr 
t _assign_ ind 
t math 
t math 
t lrs 
t_logical 
t_endp 
t logical 
t_logical_int 
t_logical t_logical 
t_logical 
t_logical 
t_logical 
t _proc 
t_logical 
t_logical 
t_logical }, 
}, }, 
} , 
}, 
} , 
} , 
} , 
}, 
}, 
}, }, }, 
}, 
}, 
}, 
}, 
}, 
}, 
} , 
}, 
}, 
}, 
}, 
}, }, 
}, }, 
}, 
}, 
}, 
}, I* Multiply var by constant. *I 
I* Get effective address. *I 
I* Assign indirect. *I 567 
.... 
568 Code Generation -Chapter 6 
Listing 6.63. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 {"U_ LT", t_logical }, 
{"""=", t math }, 
{"call", t call }, 
{ "ext_high", t ext } I 
{"ext low", t ext } I 
{"ext _word", t ext } I -{"goto", t _goto } I 
{"goto%s%d", t _goto_ int }, 
{"link", t link }, -{"pop", t _pop }, 
{"push", t_push }, 
{"ret", t ret }, 
{"unlink", t unlink }, 
{"1=", t math } 
} ; 
#define NREQ ( sizeof(Ltab)/sizeof(*Ltab) 
char Comment_buf[132]; /* Table size (in elements). *I 
/* Remember comment text here. */ 
/*----------------------------------------------------------------------*/ 
PUBLIC void gen_comment( format, ... ) 
char *format; 
{ 
/* Works like printf(), but the string is appended as a comment to the end 
*of the command generated by the next gen() call. There's no array-size 
* checking---be careful. The maximum generated string length is 132 
* characters. Overwrite any comments already in the buffer. 
*I 
va list 
va start 
vsprintf 
va end args; 
args, format ); 
Comment_buf, format, args ); 
args ); 
/*----------------------------------------------------------------------
* Enable/disable the generation of run-time trace output. 
*I 
PUBLIC enable_trace() 
PUBLIC disable_trace() Trace 
Trace 1; 
0; /* Must call before parsing starts. */ 
/*----------------------------------------------------------------------*/ 
PRIVATE int cmp( a, b ) /* Compare two lexeme fields of an ltab. */ 
struct ltab *a, *b; 
{ 
return strcmp( a->lexeme, b->lexeme ); 
/*----------------------------------------------------------------------*/ 
PUBLIC gen( op, ... ) 
char *op; 
{ 
char 
int 
value 
struct ltab *dst_str, *src str, b[BO]; 
src_int, dst int; 
*src_val; 
*p, dummy; /* emit code */ 
Section 6. 7-The gen ( ) Subroutine 569 
Listing 6.63. continued ... 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 request 
va list 
char 
int 
if( *op 
{ --
++op; 
prefix tok; 
args; 
*prefix 
amt; 
I@' ) 
"*" 
dummy.lexeme = op; 
if( ! (p = (struct ltab *) bsearch(&dummy, Ltab, NREQ, sizeof(*Ltab), cmp))) 
{ 
yyerror("INTERNAL gen: bad request <%s>, no code emitted.\n", op ); 
return; 
va start( args, op ); /* Get the arguments. */ 
dst str = va_arg( args, char*); 
switch( tok = p->token ) 
{ 
case t math int: 
case t_logical int: 
case t_goto_int: 
case t label int: src int 
case t_assign_ind: src val 
default: src str 
} 
va_end( args); va_arg( args, int ); break; 
va_arg( args, value*); break; 
va_arg( args, char* ); break; 
/* The following code just assembles the output string. It is printed with 
*the print_instruction() call under the switch, which also takes care of 
* inserting trace directives, inserting the proper indent, etc. 
*I 
switch( tok ) 
{ 
case t call: 
case t_endp: 
case t ext: 
case t_goto: 
case t_goto_int: 
case t label: 
case t label int: 
case t_logical: sprintf(b," call(%s);", 
sprintf(b," ENDP(%s)", 
sprintf(b," %s(%s) ;", op, 
sprintf(b," goto %s;", 
sprintf(b," goto %s%d;", 
sprintf(b,"%s:", 
sprintf(b,"%s%d:", 
tok = t_label; 
break; 
sprintf(b," %s(%s,%s)", 
break; dst str ) ; break; 
dst str, src str ) ; break; -dst str ) ; break; 
dst str ) ; break; 
dst str, src int ) ; break; -dst str ) ; break; 
dst str, src int ) ; 
op, dst_str, src str ); 
case t_logical_int: sprintf(b," %2.2s(%s,%d)", op, dst_str, src int ); 
tok = t_logical; 
break; 
case t link: 
case t_pop: sprintf(b," link(%s+%s);", dst_str, src str ); break; 
sprintf(b," %-12s = pop(%s);",dst_str, src str ); break; 
.... 
570 Code Generation -Chapter 6 
Listing 6.63. continued ... 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 case t _proc: 
case t push: -case t ret: 
case t unlink: 
case t lrs: sprintf(b," PROC(%s,%s)", 
sprintf(b," push(%s) ;", 
sprintf(b," ret();" 
sprintf(b," unlink();" dst 
dst str, -str src str ) ; break; 
) ; break; 
) ; break; 
) ; break; 
sprintf (b, "%slrs (%s, %s); ", prefix, dst_str, src_str); 
break; 
case t_assign_addr: sprintf(b,"%s%-12s 
break; &%s;", prefix, dst_str, src_str); 
case t assign_ind: 
if( src_val->name[O]=='&' 
sprintf(b,"%s%-12s %s;",prefix, dst_str, src_val->name+1); 
else 
sprintf(b,"%s%-12s *%s;",prefix, dst_str, src_val->name); 
break; 
case t math: sprintf(b,"%s%-12s %s %s;", prefix, dst str, op, src_str); 
break; 
case t math int: 
if( *op != '*' && *op !='/'I 
sprintf(b,"%s%-12s %2.2s %d;", prefix, dst_str, op, src_int); 
else 
switch( src_int ) 
{ 
case 1 amt 
case 2 amt 
case 4 amt 
case 8 amt 
case 16: amt 
case 32: amt 
case 64: amt 
case 128: amt 
case 256: amt 
case 512: amt 
case 1024: amt 
case 2048: amt 
case 4096: amt 
default: amt 
} 
if( !amt ) 0; break; 
1; break; 
2; break; 
3; break; 
4; break; 
5; break; 
6; break; 
7; break; 
8; break; 
9; break; 
10; break; 
11; break; 
12; break; 
-1; break; 
sprintf(b, "/* %s%-12s %s 1; */", prefix, dst_str, op ); 
else if( amt < 0 ) 
sprintf(b, "%s%-12s %s %d; ", prefix, dst str, op, src int); - -else 
sprintf(b, "%s%-12s %s %d;", prefix, dst str, -(*op --, *,) ? "<<=" : ">>=" , amt); 
break; 
default: 
yyerror("INTERNAL, gen: bad token %s, no code emitted.\n", op ); 
break; 
.... 
Section 6.7-The gen () Subroutine 571 
Listing 6.63. continued ... 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 if( *Comment_buf ) /* Add optional comment at end of line. */ 
{ 
concat ( sizeof(b), b, b, (tok == t label ? "\t\t\t\t" : "\t"), 
"!* ", Comment_buf, "*/",NULL); 
*Comment buf = '\0'; 
print instruction( b, tok ); /* Output the instruction. */ 
/*----------------------------------------------------------------------*/ 
PRIVATE void print_instruction( b, t ) 
char *b; /* Buffer containing the instruction. */ 
request t; /* Token representing instruction. */ 
{ 
/* Print the instruction and, if trace is enabled (Trace is true), print 
* code to generate a run-time trace. 
*I 
extern FILE 
static int 
static int *yycodeout, *yybssout; 
printed_defs = 0; 
last_stmt_was_test; 
if( Trace && !printed_defs 
{ 
printed_defs = 1; 
fprintf( yybssout, 
"#define P (s) 
"#define ~) () 
"\n\n" ); printf( s )\n" \ 
pm(),printf(\"-------------------------------\\n\")"\ 
if( !Trace ) 
{ /* just print the instruction */ 
yycode ("%s%s%s\n", (t==t_label I I t==t_endp I I t==t_proc) ? 
last stmt was test 
else if( t == t_logical 
{ ( last stmt was test ) ? " 
b ) ; 
(t==t_logical); "\t", 
"· 
fprintf( yycodeout, "\t\t\t\t\t" "_P(\"%s\\n\") ;\n", b); 
yycode("\t%s\t\t{\n", b); /*}*/ 
else 
{ last stmt was test = 1; 
switch( t ) 
{ 
case t label: yycode("%s", b); 
fprintf( yycodeout, "\t\t\t\t\t" "_P(\"%s\\n\");", b); 
break; 
case t_proc: yycode("%s", b); 
fprintf( yycodeout, "\t\t\t" 
fprintf( yycodeout, 
break; "_P(\"%s\\n\") ;", 
"_T();" b); 
) ; 
572 Code Generation -Chapter 6 
Listing 6.63. continued ••• 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 case t ret: 
case t_endp: fprintf( yycodeout, 11\t\t\t\t\t11 11_P(\11%s\\n\11);11 11\n11,b); 
yycode(11%S11, b); 
break; 
default: fprintf ( yycodeout, 11\t\t\t\t\t11 11_P (\11%s\ \n\11); 11 11\n11 ,b); 
yycode(11\t%s%s11, last stmt was test? 11 1111, b); 
fprintf( yycodeout, 11\t\t\t11 11_T();11 ); 
if( last_stmt_was_test ) 
{ 
putc( '}', yycodeout ) ; 
last stmt was test = 0; 
putc( '\n', yycodeout ) ; 
6.8 Expressions /* { *I 
This section looks at how expressions are processed. Temporary-variable manage­
ment is discussed as are lvalues and rvalues. The code-generation actions that handle 
expression processing are covered as well. We've looked at expression parsing 
sufficiently that there's no point in including extensive sample parses of every possible 
production in the current section-I've included a few sample parses to explain the 
harder-to-understand code-generation issues, but I expect you to be able to do the 
simpler cases yourself. Just remember that order of precedence and evaluation controls 
the order in which the productions that implement particular operators are executed. 
Productions are reduced in the same order as the expression is evaluated. 
The foregoing notwithstanding, if you have the distribution disk, you may want to 
run simple expressions through the compiler (c.exe) as you read this and the following 
sections. As you watch the parse, pay particular attention to the order in which reduc­
tions occur and the way that attributes are passed around as the parse progresses. 
6.8.1 Temporary-Variable Allocation 
All expressions in C are evaluated one operator at a time, with precedence and asso­
ciativity determining the order of evaluation as much as is possible. It is conceptually 
convenient to look at every operation as creating a temporary variable that somehow 
references the result of that operation--our compiler does things somewhat more 
efficiently, but it's best to think in terms of the stupidest possible code. This temporary, 
which represents the evaluated subexpression, is then used as an operand at the next 
expression-evaluation stage. 
Defer temporary-variable 
management to back 
end. Our first task is to provide a mechanism for creating and deleting temporaries. One 
common approach is to defer the temporary-variable management to the back end. The 
compiler itself references the temporaries as if they existed somewhere as global vari­
ables, and the back end takes over the allocation details. The temporary variable's type 
can be encoded in the name, using the same syntax that would be used to access the tem­
porary from a C-code statement: w (tO) is a word, L (tl) is an lword, WP (t2) is a 
word pointer, and so on. The advantage of this approach is that the back end is in a 
Section 6.8.1 -Temporary- Variable Allocation 
much better position than the compiler itself to understand the limitations and strengths 
of the target machine, and armed with this knowledge it can use registers effectively. I 
am not taking this approach here because it's pedagogically useful to look at a worst­
case situation-where the compiler itself has to manage temporaries. 
Temporary variables can be put in one of three places: in registers, in static memory, 
and on the stack. The obvious advantage of using registers is that they can be accessed 
quickly. The registers can be allocated using a stack of register names-essentially the 
method that is used in the examples in previous chapters. If there aren't enough registers 
in the machine, you can use a few run-time variables (called pseudo registers) as 
replacements, declaring them at the top of the output file and using them once the regis­
ters are exhausted. You could use two stacks for this purpose, one of register names and 
another of variable names, using the variable names only when there are no more regis­
ters available. Some sort of priority queue could also be used for allocation. 
One real advantage to deferring temporary-variable allocation to the back end is that 
the register-versus-static-memory problem can be resolved in an efficient way. Many 
optimizers construct a syntax tree for the expression being processed, and analysis of this 
tree can be used to allocate temporaries efficiently (so that the registers are used more 
often than the static memory). This sort of optimization must be done by a postprocessor 
or postprocessing stage in the parser, however-the parser must create a physical syntax 
or parse tree that a second pass can analyze. Though it's easy for a simple one-pass com­
piler to use registers, it's difficult for such a compiler to use the registers effectively. 
Another problem is function calls, which can be imbedded in the middle of expres­
sions. Any registers or pseudo registers that are in use as temporaries must be pushed 
before calling the function and popped after the return. Alternately, code at the top of 
the called function could push only those registers that are used as temporaries in the 
function itself-there's a lot of pushing and popping in either case. This save-and­
restore process adds a certain amount of overhead, at both compile time and run time. 
The solution to the temporary-variable problem that's used here is a compromise 
between speed and efficiency. A region of the stack frame is used for temporaries. 20 This 
way, they don't have to be pushed because they're already on the stack. 
Because the maximum size of the temporary-variable region needed by a subroutine 
varies (it is controlled by the worst-case expression in the subroutine), the size of the 
temporary-variable space changes from subroutine to subroutine. This problem is solved 
with the second macro that's used in the link instruction in the subroutine prefix. (Ll 
in the example in the previous section.) The macro is defined to the size of the 
temporary-variable region once the entire subroutine has been processed. 
This approach-allocating a single, worst-case sized temporary-variable region-is 
generally better than a dynamic approach where the temporary-variable space is gradu­
ally expanded at run time by subtracting constants from the stack pointer as variables are 
needed. The stack is shrunk with matching additions when the variable is no longer 
needed. This last approach can be more efficient of stack space, but it is both more 
difficult to do at compile time and is inefficient at run time because several subtractions 
and additions are needed rather than a single link instruction. Since most languages 
use very few, relatively small, temporaries as they evaluate expressions, this second 
20. In many machines, such as the Intel 8086 family, a stack-relative memory access is actually more efficient 
than a direct-mode memory access. It takes fewer clock cycles. Since none of the 8086-family machines 
have any general purpose registers to speak of, putting the temporaries on the stack is actually one of the 
most efficient solutions to the problem. 573 
Registers as tem­
poraries, pseudo regis­
ters. 
Problems with function 
calls. 
Temporaries on stack. 
Dynamic temporary­
variable creation. 
574 
Temporary variable's 
type. Code Generation -Chapter 6 
method is usually more trouble than its worth. Nonetheless, you may want to consider a 
dynamic approach if the source language has very large data types. For example, a 
special-purpose language that supported a matrix basic type and a matrix­
multiplication operator would need a tremendous amount of temporary-variable space to 
process the following expression: 
rna t r i x a [ 1 0 0] [ 1 0 0] 1 b [ 1 0 0] [ 1 0 0] 1 c [ 10 0] [ 1 0 0] ; 
a = a * b * c; 
It would be worthwhile not to waste this stack space except when the expression was 
actually being evaluated, so a dynamic approach makes sense here. If the stack just isn't 
large enough for temporaries such as the foregoing, the compiler could generate run-time 
calls to malloc () as part of the subroutine prefix, storing a pointer to the memory 
returned from malloc () on the stack. A run-time free () call would have to be gen­
erated as part of the subroutine suffix to delete the memory. Calling malloc () is a 
very-high-overhead operation, however, so it's best to use the stack if you can. 
The next problem is the temporary variable's type, which varies with the operand 
types. The type of the larger operand is used for the temporary. The easiest solution 
(and the one used here) is to use the worst-case size for all temporaries, and align them 
all on a worst-case boundary. All temporaries take up one lword-sized stack element, 
which is guaranteed to be aligned properly because it's a stack word. Again, if the 
worst-case type was very large (if doubles were supported, for example), it would be 
worthwhile to go to the trouble to pack the temporaries into the stack region in a manner 
analogous to the local variables. 
Temporary-variable refer­
ences: T () Figure 6.18 shows a stack frame with eight bytes of local-variable space and enough 
temporary space for two variables. The macro definitions at the top of the figure are gen­
erated at the same time as the subroutine prefix. The LO macro evaluates to the size, in 
stack elements, of the local-variable region. (This is the same LO that's passed to the 
link instruction.) The T () macro simplifies temporary-variable access in instructions. 
It is defined at the top of the file as an empty macro, and is then #undefed and redefined 
to reference the current local-variable-space size at the top of every subroutine. The ini­
tial dummy definition is required because some compilers won't let you undefine a 
nonexistent macro. The following examples demonstrate how the macro is used: 
W ( T ( 0) ) accesses the word in the bottom two bytes of the bottom temporary. 
L ( T ( 1 ) ) accesses the 1 word that takes up the entire top temporary. 
*WP ( T ( 0) ) accesses the word whose address is in the top temporary. 
Figure 6.18. Storing Temporary Variables in the Stack Frame 
#define T (n) (fp-LO- (4*n)) 
#define LO 2 /* size of local-variable space 
#define Ll 2 /* size of temporary-variable space 
(low memory) 
T(1) fp-16 
T(O) fp-12 
fp-5 I fp-6 _l fp-7 I fp-8 
fp-1 I fp-2 I fp-3 I fp-4 Temporary-variable region Ll=2 
* Local-variable region L0=2 
3 2 I 0 oE--fp 
(high memory) *I 
*I 
Section 6.8.1 -Temporary- Variable Allocation 575 
Though temporary variables are not packed into the stack frame, the temporary- Recycling temporaries. 
variable space is used intelligently by the compiler-the same region of the stack is 
recycled as needed for temporaries. The strategy, implemented in Listing 6.64, is 
straightforward. (It's important not to confuse compile and run time, in the following 
discussion. It's easy to do. The temporary-variable allocator is part of the compiler, but 
it is keeping track of a condition of the stack at run time. All of the temporary-variable 
allocation and deallocation is done at compile time. A region of the stack is just used as 
a temporary at run time-the compiler determined that that region was available at com-
pile time.) 
Listing 6.64. temp.c- Temporary- Variable Management 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <stdlib.h> 
#include <toolsldebug.h> 
#include <toolslhash.h> 
#include <toolsll.h> 
#include <toolslcompiler.h> 
#include <toolslc-code.h> 
#include "symtab.h" 
#include "value.h" 
#include "proto.h" 
I* Subroutines in this file take care of temporary-variable management. *I 
#define REGION MAX 128 I* Maximum number of stack elements that can be *I 
I* used for temporaries. *I 
#define MARK -1 I* Marks cells that are in use but are not the *I 
I* first cell of the region. *I 
typedef int CELL; I* In-use (Region) map is an array of these. *I 
PRIVATE CELL Region[REGION_MAX]; 
PRIVATE CELL *High_water_mark = Region; 
1*----------------------------------------------------------------------*l 
PUBLIC int tmp_alloc( size ) 
int size; I* desired number of bytes *I 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 I* Allocate a portion of the temporary-variable region of the required size, 
* expanding the tmp-region size if necessary. Return the offset in bytes 
* from the start of the rvalue region to the first cell of the temporary. 
* 0 is returned if no space is available, and an error message is also 
* printed in this situation. This way the code-generation can go on as if 
* space had been found without having to worry about testing for errors. 
* (Bad code is generated, but so what?) 
*I 
CELL *start, *p 
int i; 
I* size = the number of stack cells required to hold "size" bytes. *I 
size= ((size+ SWIDTH) I SWIDTH) (size% SWIDTH == 0); 
if( !size ) 
yyerror("INTERNAL, tmp_alloc: zero-length region requested\n" ) ; 
.... 
576 Code Generation -Chapter 6 
Listing 6.64. continued ... 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 /* Now look for a large-enough hole in the already-allocated cells. */ 
for ( start 
{ Region; start< High_water_mark ;) 
for( i size, p = start; --i >= 0 && ! *p; ++p ) 
if( i >= 0 
start = p + 1; 
else 
break; 
if( start < High_water_mark 
p = start; 
else 
{ /* Cell not found. */ 
/* Found an area big enough. */ 
/* Found a hole. */ 
if( (High_water_mark + size) > (Region + REGION_MAX) ) 
{ /* No room. *I 
yyerror("Expression too complex, break into smaller pieces\n"); 
return 0; 
p High_water_mark; 
High_water_mark += size; 
for ( *p size; --size > 0; *++p MARK) /* 1st cell=size. Others=MARK */ 
return( start- Region); /* Return offset to start of region */ 
/* converted to bytes. */ 
/*----------------------------------------------------------------------*/ 
PUBLIC void tmp_free( offset ) 
int offset; 
CELL *p 
int size; Region + offset; /* Release a temporary var.; offset should*/ 
/*have been returned from tmp_alloc(). */ 
if( p <Region I I p > High_water_mark I I !*p I I *p ==MARK ) 
yyerror( "INTERNAL, tmp_free: Bad offset (%d)\n", offset ); 
else 
for( size = *p; --size >= 0; *p++ = 0 ) 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ tmp_reset () 
/* Reset everything back to the virgin state, including the high-water mark. 
* This routine should be called just before a subroutine body is processed, 
*when the prefix is output. See also: tmp_freeall(). 
*I 
tmp _free all () ; 
High_water_mark Region 
Section 6.8.1 -Temporary- Variable Allocation 
Listing 6.64. continued ••• 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
{ tmp_freeall () 
/* Free all temporaries currently in use (without modifying the high-water 
*mark). This subroutine should be called after processing arithmetic 
* statements to clean up any temporaries still kicking around (there is 
*usually at least one). 
*I 
memset( Region, 0, sizeof(Region) ); 
/*----------------------------------------------------------------------*/ 
PUBLIC int 
{ tmp_var_space () 
/* Return the total cumulative size of the temporary-variable region in 577 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 * stack elements, not bytes. This number can be used as an argument to the 
* link instruction. 
*I 
return High_water_mark -Region; 
The compiler keeps an internal array called Region-declared on line 20 of Listing 
6.64--that tells it which stack elements in the temporary-variable space are in use at run 
time. The index of the cell in the array corresponds to the offset of the equivalent stack 
element. For example, Region [N] corresponds to the temporary variable at offset N (in 
stack elements) from the base of the temporary-variable region (not from the frame 
pointer). The array elements are zero if the corresponding stack element is available. 
For example, if Region [ 4] is zero, then the stack element at offset 4 from the base of 
the temporary space is available. The size of the array is controlled by REG I ON_ MAX, 
declared on line 14 of Listing 6.64. This size limits the amount of temporary-variable 
space available to a subroutine. This size limits an expression's complexity because it 
limits the number of temporaries that can be used to evaluate the expression. The com­
piler prints an error message if the expression gets too complicated (if there aren't 
enough temporary variables to evaluate all the subexpressions). 
The temporary-variable allocator, tmp _ alloc (), starts on line 24 of Listing 6.64. 
It is passed the number of bytes required for the temporary, figures out how many stack 
elements are required for that temporary, and then allocates that many bytes from the 
temporary-variable region. 21 The allocation logic on lines 49 to 58 of Listing 6.64 
searches the array from bottom to top looking for a free stack element. It allocates the 
first available stack element for the temporary. The High_ water_ mark, used here and 
declared on line 21 of Listing 6.64, keeps track of the size of the temporary-variable 
space. If the first available element is at a higher index than any previously allocated 
element, then High_ water_ mark is modified to point at the new element. 
21. The allocator I'm presenting here is actually more complex than necessary, because all temporary 
variables take up exactly one stack element in the current compiler. It seemed reasonable to demonstrate 
how to handle the more complex situation, where some temporaries can take up more than one stack 
element, however. Compile-time map of 
run-time stack: Re­
gion[]. 
Allocate temporary: 
tmp_alloc(). 
High_ water_ mark. 
578 
Marking a stack cell as 
'in use'. 
Rvalues. 
Lvalues. Code Generation -Chapter 6 
The cell is marked as "in use" on line 73. The Region element corresponding to the 
first cell of the allocated space is set to the number of stack elements that are being allo­
cated. If more than one stack element is required for the temporary, adjacent cells that 
are part of the temporary are filled with a place marker. Other subroutines in Listing 
6.64 de-allocate a temporary variable by reseting the equivalent Region elements to 
zero, de-allocate all temporary variables currently in use, and provide access to the 
high-water mark. You should take a moment and review them now. 
6.8.2 Lvalues and Rvalues 
Expression evaluation, and the way that temporaries are used while doing the evalua­
tion, is actually a more complex proposition than you would think, based on the exam­
ples in earlier chapters. Hitherto, we've used temporaries for one purpose only, to hold 
the value of a subexpression. We could do this because none of the grammars that we've 
seen are capable of modifying variables, only of using them. As soon as modification 
becomes a possibility, things start to get complicated-especially in a language like C 
that provides several ways to modify something(=,++,--, and so forth). 
So far, the parsers that we've looked at always treated identifier references in the 
same way: They copied the contents of the referenced variable into a temporary and 
passed the name of that temporary back up as an attribute. The following grammar is a 
case in point: 
e e PLUS e 
ID yycode("%s += %s\n", $1, $3); free name( $3 ); 
yycode("%s %s\n", $$ = new_name(), yytext ); 
The value stack is a stack of character pointers. The attribute is the name of the tempo­
rary that holds the partially-evaluated subexpression. Input like x+y generates the fol­
lowing code: 
tO = x; 
t1 = y; 
t1 += tO; 
The kind of temporary that's used here-which holds something's value-is called an 
rvalue. In the current grammar, they and z in x=y+z are said to generate rvalues-they 
create temporaries that hold a variable's value. (It's an !_Value because it can go to the 
I_ight of the equals sign.) The + operator also generates an rvalue because the result of 
the operation is a run-time temporary holding the sum-the value of the subexpression. 
What happens when you introduce an assignment operator to the grammar? Our 
first, unsuccessful attempt at a solution treats the assignment operator just like the addi­
tion operator: 
e e PLUS e {yycode("%s += %s\n", $1, $3); free_name( $3 ) ; 
e EQUAL e {yycode ("%s %s\n", $1, $3); free_name ( $3 ) ; 
ID {yycode("%s %s\n", $$ new_name(), yytext );} 
The input x=y+ z yields the following output: 
tO x; 
t1 y; 
t2 z; 
t1 += t2; 
tO t1; 
which doesn't do anything useful. 
Section 6.8.2-Lvalues and Rvalues 
In order to do assignment correctly, you need to know the address of x (the memory 
location to modify), not its contents. To get this information you need to introduce a 
second type of temporary-one that holds an address. This kind of temporary is called 
an /value because it can be generated by subexpressions to the left of an equal sign. The 
grammar and code in Listing 6.65 supports both kinds of temporaries. They are dis­
tinguished from one another by the first character of the name. Rvalues start with R, 
!values with L. As was the case in earlier chapters, a simple stack strategy is used to 
allocate and free names. Error checking has been omitted to simplify things. 
Listing 6.65. Expression Processing with Lvalues and Rvalues 
I 
2 
3 
4 
5 
6 
7 
8 
9 %{ 
%} 
%% 
s 
e #define YYSTYPE char* 
e 
e PLUS e 
char *target; 
/* Convert $1 to an rvalue if necessary so that it can be used 
* as the synthesized attribute. 
*I 
if ( * $1 ! = 'R' ) 
{ 
} yycode( "%s = %s\n", target 
free_value($1); 
$1 = target; 
$$ = $1; new_rvalue(), rvalue($1) ); 
yycode("%s += %s\n", target, rvalue( $3 ); 
free_value( $3 ); 
e EQUAL e 
char *target; 
if ( * $1 ! = ' L' 
yyerror("Lvalue required\n"); 
else 
if ( * $3 ! = 'R' ) 
{ /* Convert $3 to an rvalue. */ 579 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 yycode ( "%s = %s\n", target = new_rvalue (), rvalue ($3)); 
free_value($3); 
%% ID 
{ $3 = target; 
yycode( "*%s = %s", $1, $3 ); 
free_value( $1 ) ; 
$$ = $3; 
yycode("%s & %s\n", $$ new_lvalue(), yytext ); 
.... 
580 Code Generation -Chapter 6 
Listing 6.65. continued ••• 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 char 
char 
char 
char 
char 
char 
void 
char 
{ *Lvalues[4] { "LO", 
*Lp Lvalues; 
*Rvalues[4] { "RO", 
*Rp Rvalues; 
*new lvalue() return 
*new_rvalue () return 
free_value( val ) 
*val; "Ll", "L2", "L3" ) ; 
"Rl", "R2", "R3" ) ; 
*Lp++; I* Allocate a new lvalue. *I 
*Rp++; I* Allocate a new rvalue. *I 
I* Free an lvalue or an rvalue. *I 
if ( *val 
else 'L' ) *--Lp 
*--Rp val; val; 
char *rvalue( value ) 
char *value; I* If the argument is an lvalue, return a string *I 
I* that can be used in an expression to reference *I 
I* the lvalue's contents. (Add a * to the name.) *I { 
static char buf[16]; 
if( *lvalue == 'R' ) 
return value; 
sprintf( buf, "*%s", lvalue ) ; 
return buf; I* it's already an rvalue *I 
Using the new grammar, the input x=y+z yields the following output: 
LO & x; -Ll & _y; 
L2 & z; 
RO *Ll; 
RO += *L2; 
*LO RO; 
which is awkward, but it works. The !values are converted to rvalues by preceding their 
names with a star. Note that the attribute synthesized in the assignment is the rvalue, not 
the !value. The assignment operator requires an !value to the left of the equals sign, but 
it generates an rvalue. That's why code like the following is illegal inC: 
(x=y) = z; 
even though 
x = y = z; 
is okay. ( x=y) generates an rvalue-a temporary that holds the value of y-and expli­
cit assignment to an rvalue is meaningless. In x=y=z, the operand to the right of the 
equal sign is always an rvalue and the operand to the left is always an !value. (Run it 
through the parser by hand if you don't believe me.) 
Logical versus physical 
!values. The code that the compiler just generated is pretty sorry. Fortunately, the compiler 
can do a simple optimization to fix things. Instead of passing around the name of a tem­
porary variable as an attribute, it can pass a string which, when used as an operand in an 
instruction, evaluates correctly. This attribute is sometimes a temporary-variable name, 
but it can also take on other values. That is, instead of generating 
LO = &_x; 
in the earlier example, and then passing around the string "LO" as an attribute, the 
Section 6.8.2-Lvalues and Rvalues 
compiler can dispense with the assignment entirely and pass around " & x" as an attri­
bute. So you now have two types of !values: physicallvalues-temporary variables that 
hold the address of something, and logical !values--expressions that evaluate to the 
address of something when used as an operand. The compiler can distinguish between 
the two by looking at the first character in the name; logical !values start with an amper­
sand. 
Listing 6.66 shows the parser, modified to use logical !values. Changes are marked 
with a *. Very few changes have to be made. First, the code for assignment must be 
modified on line 32 of Listing 6.66 to handle logical !values. The conditional just dis­
cards the leading ampersand if it's present, because the two operators in the expression 
* & _ x just cancel one another, yielding_ x. Next, the ID action on lines 39 to 41 of List­
ing 6.66 must be changed to generate logical, rather than physical, !values. The name is 
assembled into a string, and a copy of the string is passed as an attribute. (The copy is 
freed on line 59.) Finally, the rvalue () subroutine is modified on lines 70 and 71 of 
Listing 6.66 to recognize both kinds of !values. 
Listing 6.66. Expression Processing with Logical Lvalues 
I %{ 
2 
3 %} 
4 %% 
5 s 
6 e 
7 
8 
9 
10 
II #define YYSTYPE char* 
e 
e PLUS e 
char *target; 
if ( * $1 ! = I R I 
{ Physical and logical 
lvalues. 
12 yycode( "%s = %s\n", target 
free_va1ue($1); new_rva1ue(), rva1ue($1) ); 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 27 $1 = target; 
} 
$$ = $1; 
yycode("%s += %s\n", target, rva1ue( $3 ); 
free_va1ue( $3 ); 
e EQUAL e 
if( *$1 != 'L' ) 
yyerror("Lva1ue required\n"); 
else 
if( *$3 != 'R' ) 
{ /* Convert $3 to an rvalue. */ 581 
28 
29 yycode( "%s = %s\n", target= new_rva1ue(), rva1ue($3)); 
free_va1ue($3); 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 ID 
{ $1 = target; 
yycode ("*%s = %s", *$1==' &' ? ($1) +1 
$$ = $3; 
free_va1ue( $1 ) ; 
char buf[16]; 
sprintf( buf, "&%s", yytext ) ; $1, $3); /* * */ 
/* * */ 
/* * */ ... 
582 Code Generation -Chapter 6 
Listing 6.66. continued ... 
41 $$ strdup ( buf ) ; /* * */ 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 %% 
char *Lvalues[4] 
char *Lp 
char *Rvalues[4] 
char *Rp 
char *new !value() 
char *new_rvalue() 
free value ( val { "LO", "Ll", "L2", "L3" }; 
Lvalues; 
{ "RO", "Rl", "R2", "R3" }; 
Rvalues; 
return *Lp++; 
return *Rp++; /* Allocate a new lvalue. 
/* Allocate a new lvalue. 
/* Free an 1 value or an rvalue. *I 
*I 
*I -char *val; 
{ 
if ( *val 'L' *--Lp = val; /* Physical lvalue *I 
else if( *val 'R' *--Rp = val; 
else free ( val ) ; /* Logical lvalue * */ 
char *rvalue( value ) /* If the argument is an lvalue, return a string */ 
/* that can be used in an expression to reference */ char *value; 
/* the lvalue's contents. */ 
static char buf[16]; 
if( *!value == 'R' 
return value; 
if( *!value== '&' 
return value + 1; /* It's already an rvalue. */ 
/* Logical lvalue 
/* *& x cancels. Just use the name. 
sprintf( buf, "*%s", !value); 
return buf; * */ * */ 
The new-and-improved code-generation actions translate the input x=y+z as fol­
lows: 
RO _y ; 
RO += z ; 
X RO; 
Summary: !values and 
rvalues. To summarize all of the foregoing and put it into the context of a real compiler: two 
types of temporaries can be created as an expression is evaluated: an /value which holds 
the address of the object that, in tum, holds the result of the previous operation, and an 
rvalue which holds the result itself. The terms come from an expression like: 
X = y; 
The !_Value, y (on the .!_ight of the equal sign), is treated differently from the lvalue, x (on 
the left). The y must evaluate to its contents, but the x must evaluate to an address-to 
the place where the y is to be stored. 
An expression that is said to "generate an !value", can be seen as creating a tempo­
rary variable that holds an address of some sort, and the operator controls whether an 
!value or rvalue is generated. In the current C compiler, all identifier references generate 
!values-a temporary is created that holds the address of the referenced object. The 
Section 6.8.2-Lvalues and Rvalues 
following operators also generate !values: 
* [] -> 
Note that none of the foregoing operators do arithmetic-they all do a reference of some 
sort. Operators not in the foregoing list generate rvalues-a temporary is created that 
holds the result of the the operation. In addition, the following operators require their 
operands to be !values: 
++ += etc. 
Other operators can handle both !value and rvalue operands, but to use them, they must 
convert the !values to rvalues by removing one level of indirection. 
A quick way to determine whether an expression forms an !value or an rvalue is to 
put the expression to the left of an equals sign and see if it's legal. Given the following 
declarations: 
int x; 
int array[lO]; 
int *p = array; 
struct tag 
{ 
int fl; 
int f2[5]; 
structure; 
the following expressions generate !values: 
X 
array 
p 
structure.fl *array 
*p 
structure.f2[n] array[n] 
* (p + n) 
*(structure.f2) 
structure (only if structure assignment is supported) 
Note that both p and *p form !values, though the associated temporaries are of different 
types. The following are not !values because they can't appear to the left of an equal 
sign: 
&x 
array 
structure.f2 
structure (only if structure assignment is not supported) 
6.8.3 Implementing Values, Higher-Level Temporary-Variable Support 
This section describes the current compiler's implementation of !values and rvalues. 
The value structure, in Listing 6.67, is used for both of them, and all of the expression- The value structure. 
processing productions pass around pointers to value structures as attributes. The vari-
ous fields are used as follows: 
lvalue True if the structure represents an !value, false if it's an rvalue. 
is_ tmp True if the structure represents a real temporary variable (an rvalue or a phy­
sicallvalue), false otherwise. 
offset Position of the temporary variable in the stack frame. This number is the 
absolute value of the offset, in stack elements, from the base address of the 
temporary-variable region to the variable itself [i.e. the number that is 
returned from tmp _alloc () ]. 583 
584 
name 
type 
etype 
sym Code Generation -Chapter 6 
If the current value is an rvalue, this field is a string which, when used as an 
operand, evaluates to the value of the previously computed subexpression. If 
it's an !value, this field is a string that evaluates to the address of the object 
generated from the previous subexpression. 
Points at the start and end of a type chain representing the value's type. If an 
rvalue, the name field references an object of the indicated type; if an !value, 
the name field evaluates to a pointer to an object of the indicated type. When 
an lvalue is created from a symbol (when an identifier is processed), a copy 
of the symbol's type chain is made and the copy is used in the value. 
When the !value is created from a symbol, this field points at that symbol. 
It's used only to print an occasional comment in the output, and is undefined 
if the I value was created by an operator like * or [ ] . 
Listing 6.67. value.h- Lvalues and Rvalues 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 I* VALUE.H: 
* 
*I Various definitions for (11 r) values. "symtab.h" must be 
#included before #including this file. 
#define VALNAME_MAX (NAME_MAX * 2) I* Max. length of string in value.name *I 
typedef struct value 
{ 
char 
link 
link 
symbol 
unsigned 
unsigned 
unsigned name[ VAL NAME 
*type; 
*etype; 
*sym; 
lvalue : 1; 
is_tmp : 1; 
offset : 14; 
value; 
#define LEFT 1 
#define RIGHT 0 MAX -
I* 
I* l ; I* Operand that accesses the value. 
I* Variable's type (start of chain). 
I* Variable's type (end of chain). 
I* Original symbol. 
I* 1 = lvalue, 0 = rvalue. 
I* 1 if a temporary variable. 
I* Absolute value of offset from base of 
I* temporary region on stack to variable. 
Second argument to shift name() in value. c, 
discussed below. 
#define CONST STR(p) tconst_str((p)->type) I* Simplify tconst str () calls 
I* with value arguments by 
I* extracting the type field. *I 
*I 
*I 
*I 
*I 
*I 
*I *I 
*I 
*I 
*I 
*I *I 
Constant value. Note that values are used for constants as well as temporary variables. (There's a 
picture of one in Figure 6.19.) The attribute generated by unop~ICON is a pointer to a 
value structure for an rvalue. The type chain identifies the value as an int constant. 
[IS_CONSTANT (etype) in symtab.h, which examines the storage class of the right­
most link in the chain, evaluates true.] Similarly, the numeric value of the constant is 
stored in the last link in the type chain (in the const _val union of the specifier 
substructure). The value structure's name field holds an ASCII string representing the 
number. The unop~NAME action that we'll look at momentarily creates an identical 
attribute if the identi tier references an element of an enumerated type. 
The advantage of this approach-using values for both constants and variables-is 
that all expression elements, regardless of what they are, synthesize value pointers as 
attributes. 
Section 6.8.3-lmplementing Values, Higher-Level Temporary-Variable Support 
Figure 6.19. A value that Represents an int Constant 
Nu'!'eric value stored as a string 
value· 
/ 
/ 
name "10"- link: 
lvalue 0 class=SPECIFIER 
type s: '\ etype noun = INT 
const val: -
I v int=lO, I 
I 
I / 
Numeric value stored as a number 
Listing 6.68 contains various subroutines that manipulate value structures. The new_ value 0. 
low-level allocation and deletion routines (discard_ value() on line 46 of Listing discard_value() 
6.68 and new_ value() on line 84 of the same listing) work just like the link-
management routines discussed earlier. The values are allocated from malloc (),but 
discarded by placing them on the linked free list pointed to by Value_ free, declared 
on line 14. Several structures are allocated at once-the number of structures is con-
trolled by VCHUNK, defined on line 19. The type chain associated with the value is dis-
carded at the same time as the value itself. 
Listing 6.68. value.c- Low-Level value Maintenance 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
#include <tools/l.h> 
#include <tools/c-code.h> 
#include <tools/compiler.h> 
#include "symtab.h" 
#include "value.h" 
#include "proto.h" 
#include "label.h" 
/* VALUE. C: Routines to manipulate lvalues and rvalues. */ 
PRIVATE value *Value free 
#define VCHUNK 8 NULL; 
/* Allocate this many structure at a time. */ 
!*----------------------------------------------------------------------*! 
value *new_value () 
value *p; 
int i; 
if( !Value free 
{ 
if( ! (Value_free = (value*) malloc( sizeof(value) * VCHUNK )) ) 
{ 
yyerror("INTERNAL, new value: Out of memory\n"); 
exit ( 1 ) ; 585 
.... 
586 Code Generation -Chapter 6 
Listing 6.68. continued ... 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 for( p = Value_free, i = VCHUNK; --i > 0; ++p ) 
p->type = (link*) ( p+l ); I* Executes VCHUNK-1 *I 
I* times. *I 
p->type = NULL ; 
p = Value_free; 
Value free = (value *) Value_free->type; 
memset( p, 0, sizeof(value) ); 
return p; 
1*----------------------------------------------------------------------*l 
void 
value discard_value( p) 
*p; I* Discard a value structure *I 
I* and any associated links. *I 
if( p ) 
{ 
if( p->type ) 
discard link chain( p->type ); 
p->type = (link *)Value_free 
Value free = p; 
1*----------------------------------------------------------------------*l 
char 
value 
int *shift_name( val, left ) 
*val; 
left; 
I* Shift the name one character to the left or right. The string might get 
* truncated on a right shift. Returns pointer to shifted string. 
* Shifts an & into the new slot on a right shift. 
*I 
if( left ) 
memmove( val->name, 
else val->name+1, sizeof(val->name) -1 ); 
{ 
memmove( val->name+1, val->name, 
val->name[ sizeof(val->name) -1 
val->name[O] = '&'; 
return val->name; sizeof(val->name) - 1 ); 
= , \0' ; 
1*----------------------------------------------------------------------*l 
char 
value *rvalue( val ) 
*val; 
I* If val is an rvalue, do nothing and return val->name. If it's an lvalue, 
* convert it to an rvalue and return the string necessary to access the 
* rvalue. If it's an rvalue constant, return a string representing the .... 
Section 6.8.3-Implementing Values, Higher-Level Temporary-Variable Support 
Listing 6.68. continued ..• 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 *number (and also put that string into val->name). 
*I 
static char buf[ NAME MAX + 2 ] "*" 
if( !val->lvalue 
{ /* It's an rvalue already. */ 
else 
char 
value if( IS_CONSTANT(val->etype) 
strcpy( val->name, CONST_STR(val) ); 
return val->name; 
val->lvalue = 0; 
if( * val->name == '&' ) 
{ 
else shift_name(val, LEFT); 
return val->name; /* *& cancels */ 
strncpy( &buf[l], val->name, NAME MAX+l ) ; 
return buf; 
*rvalue_name( val ) 
*val; 
/* Returns a copy of the rvalue name without actually converting val to an 
* rvalue. The copy remains valid only until the next rvalue name call. 
*I 
static char buf[ (NAME_MAX * 2) + 1 ]; 
if( !val->lvalue 
{ /* sizeof(val->name) + 1 */ 
if( IS_CONSTANT(val->etype) 
else strcpy( buf, CONST_STR(val) ); 
strcpy( buf, val->name ); 
else 
{ 
if ( * val->name 
else 
return buf; '&' ) strcpy ( buf, 
sprintf( buf, "*%s", val->name + 1 ); 
val->name ); 
rvalue () 587 
The rvalue () subroutine on line 84 of Listing 6.68 is used heavily in the 
expression-processing code. It is used to fetch the actual value associated with either an 
rvalue or !value. It is passed a value structure. If this value is an rvalue that 
represents a numeric constant, a string representing the constant's numeric value is 
returned. If it's a normal rvalue, the name field is returned. rval ue () and rvalues. 
If the argument is a pointer to an !value, the value is converted to an rvalue and a 
string that can be used to access the rvalue is returned. The conversion to rvalue 
involves modifying two fields. First, the 1 value field is set false. Then, if this is a rvalue () and logical 
!values. 
588 
rvalue () and physical 
lvalues. 
rvalue_name () 
Temporary-variable 
value,tmp_create(). 
get _prefix() Code Generation -Chapter 6 
logical )value, the name field is shifted one character to the left and the resulting string is 
returned. 
If the incoming value represents a physicallvalue, a string containing the name pre­
ceded by a* is returned, but the name field isn't modified. This behavior is actually an 
anomaly because a physical rvalue is not created. That is, to be consistent with the logi­
callvalue case, the rvalue () subroutine should emit code to copy the object pointed to 
by the lvalue into a physical temporary variable. It should then modify the value struc­
ture to represent this new temporary rather than the original one. I haven't done this here 
because I wanted the code-generation actions to be able to control the target. For exam­
ple, the following is taken from the code-generation action for a return statement. $2 is 
a pointer to a value for the object being returned. If the input takes the form 
return x, then $2 points at an I value. If the input takes the form return x+ 1, then 
$2 points at an rvalue: 
gen( "=", IS_INT($2->type)? "rF.w.low": "rF.l", rvalue($2) ); 
The target (the physical rvalue) has to be one of two registers, not a temporary variable. 
Other situations arise where the target is a temporary, so I simplified the interface to 
rvalue () by requiring the caller to generate the physical rvalue if necessary. The 
string that's returned from rvalue () can always be used as the source operand in the 
assignment. The rv al ue _name ( ) subroutine on line 117 returns the same thing as 
rvalue (),but it doesn't modify the value structure at all, it just returns a string that 
you can use as a source operand. 
The value-maintenance functions continue in Listing 6.69 with a second layer of 
higher-level functions. Temporary-variable values are also handled here. Two rou­
tines, starting on line 138, are provided for temporary-variable creation. 
tmp _create () is the lower-level routine. It is passed a type and creates an rvalue for 
that type using the low-level allocation routine discussed earlier [tmp _ alloc ()] to get 
space for the variable on the stack. A copy of the input type string is usually put into the 
value. An int rvalue is created from scratch if the type argument is NULL, however. 
If the second argument is true, a link for a pointer declarator is added to the left of the 
value's type chain. The value's name field is created by tmp_create (). It initial­
ized to a string which is output as the operand of an instruction, and which accesses the 
temporary variable. The name is generated on line 175, and it looks something like this: 
WP ( T ( 0) ) . The type component (WP) changes with the actual type of the temporary. 
It's created by get _prefix() on line 181. The 0 is the offset from the base of the 
temporary-variable region to the current variable. We saw the T () macro earlier. It 
translates the offset to a frame-pointer reference. 
Listing 6.69. value.c- High-Level value Maintenance 
138 value *tmp_create( type, add_pointer ) 
139 link *type; /* Type of temporary, NULL to create an int. */ 
140 int add_pointer; /* If true, add pointer declarator to front of type */ 
141 /* before creating the temporary. */ 
142 
143 /* Create a temporary variable and return a pointer to it. It's an rvalue 
144 * by default. 
145 */ 
146 147 
value *val; 
148 link *lp; 
149 
.... 
Section 6.8.3-Implementing Values, Higher-Level Temporary-Variable Support 589 
Listing 6.69. continued ... 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 193 
194 
195 
196 
197 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 val 
val->is_tmp new_value (); 
1; 
/* Copy existing type. */ if( type ) 
va1->type 
else clone_type( type, &lp ); 
{ 
lp 
lp->class 
lp->NOUN 
val->type new_link(); 
SPECIFIER; 
INT; 
lp; 
val->etype 
lp->SCLASS lp; 
AUTO; 
if( add_pointer 
{ 
lp 
lp->DCL_TYPE 
lp->next 
val->type new_link(); 
POINTER; 
val->type; 
lp; /* Make an integer. */ 
/* It's an auto now, regardless */ 
/* of the previous storage class. */ 
val->offset = tmp_alloc( get_size( val->type ) ); 
sprintf (val->name, "%s ( T (%d) ) ", get_prefix (val->type), (val->offset + 1)); 
return ( val ) ; 
/*----------------------------------------------------------------------*/ 
char 
link 
{ *get_prefix( type ) 
*type; 
/* Return the first character of the LP(), BP(), WP(), etc., directive 
* that accesses a variable of the given type. Note that an array or 
* structure type is assumed to be a pointer to the first cell at run time. 
*I 
int c; 
if( type 
{ 
if( type->class == DECLARATOR 
{ 
switch( type->DCL_TYPE ) 
{ 
case ARRAY: return( get_prefix( type->next) ); 
case FUNCTION: return PTR_PREFIX; 
case POINTER: 
c = *get_prefix( type->next ) ; 
if ( c --*BYTE PREFIX 
else if( c --*WORD PREFIX 
else if( c --*LWORD PREFIX 
break; return BYTEPTR_PREFIX; 
return WORDPTR_PREFIX; 
return LWORDPTR_PREFIX; 
return PTRPTR_PREFIX; 
.... 
590 Code Generation -Chapter 6 
Listing 6.69. continued ... 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 267 268 else 
{ 
switch( type->NOUN ) 
{ 
case INT: 
case CHAR: return (type->LONG) ? LWORD PREFIX 
case STRUCTURE: return BYTEPTR PREFIX 
} WORD_PREFIX; 
yyerror("INTERNAL, get_prefix: Can't process type %s.\n", type_str(type) ); 
exit( 1 ); 
/*----------------------------------------------------------------------*/ 
value 
link 
value *tmp_gen( tmp_type, src ) 
*tmp_type; /* type of temporary taken from here */ 
*src; /* source variable that is copied into temporary */ 
/* Create a temporary variable of the indicated type and then generate 
* code to copy src into it. Return a pointer to a "value" for the temporary 
* variable. Truncation is done silently; you may want to add a lint-style 
* warning message in this situation, however. Src is converted to an 
* rvalue if necessary, and is released after being copied. If tmp_type 
* is NULL, an int is created. 
*I 
value *val; 
char *reg; /* temporary variable 
if( !the same_type( tmp_type, src->type, 1) ) 
{ 
/* convert_type() copies src to a register and does any necessary type 
* conversion. It returns a string that can be used to access the 
else * register. Once the src has been copied, it can be released, and 
* a new temporary (this time of the new type) is created and 
* initialized from the register. 
*I 
reg= convert_type( tmp_type, src ); 
release_value( src ) ; 
val = tmp_create( IS_CHAR(tmp_type) ? NULL 
gen( "=", val->name, reg); 
val= tmp_create( tmp_type, 0 ); 
gen( "=", val->name, rvalue(src) ); 
release_value( src ); tmp_type, 0 ); 
return val; 
/*----------------------------------------------------------------------*/ 
char 
link 
value *convert_type( targ_type, src ) 
*targ_type; 
*src; /* type of target object 
/* source to be converted *I 
*I *I 
.... 
Section 6.8.3-Implementing Values, Higher-Level Temporary-Variable Support 
Listing 6.69. continued ... 
int dsize; 
static char reg[16]; I* src size, dst size *I 
I* place to assemble register name *I 
I* This routine should only be called if the target type (in targ_type) 
* and the source type (in src->type) disagree. It generates code to copy 
* the source into a register and do any type conversion. It returns a 
* string that references the register. This string should be used 
* immediately as the source of an assignment instruction, like this: 
* 
* *I gen ( ,_, -, dst_name, convert_type( dst_type, src ); ) 591 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 sprintf( reg, 
gen ( "=", "r0.%s", 
reg, get_suffix(src->type) ); 
rvalue(src) ); I* copy into *I 
I* register. *I 
if( (dsize = get_size(targ_type)) > get_size(src->type) 
{ 
if( src->etype->UNSIGNED ) 
{ 
if( dsize 2 gen( 
if( dsize 4 gen( 
else 
{ 
if( dsize 2 gen ( 
if( dsize 4 gen ( "=" I "rO.b.bl", "0" 
"=" I "rO.w.high", "0" 
"ext low", "rO" ) ; -"ext word", "rO" ) ; -
sprintf( reg, "r0.%s", get_suffix(targ_type) ); 
return reg; ) ; 
) ; I* zero fill *I 
I* sign extend 
1*----------------------------------------------------------------------*l 
PUBLIC int get_size( type ) 
link *type; 
{ 
I* Return the number of bytes required to hold the thing referenced by 
* get_prefix () . 
*I 
if( type ) 
{ 
if( type->class == DECLARATOR 
return (type->DCL_TYPE ==ARRAY) ? get size(type->next) 
else 
switch( type->NOUN ) 
{ 
case INT: return (type->LONG) ? LSIZE 
case CHAR: 
case STRUCTURE: return CSIZE; 
} ISIZE; PSIZE 
yyerror("INTERNAL, get_size: Can't size type: %s.\n", type_str(type)); 
exit(l); *I 
592 Code Generation -Chapter 6 
Listing 6.69. continued ••• 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 1*----------------------------------------------------------------------*l 
char 
link 
{ *get_suffix( type ) 
*type; 
I* Returns the string for an operand that gets a number of the indicated 
* type out of a register. (It returns the xx in : rO.xx). "pp" is returned 
* for pointers, arrays, and structures--get_suffix() is used only for 
* temporary-variable manipulation, not declarations. If an an array or 
* structure declarator is a component of a temporary-variable's type chain, 
* then that declarator actually represents a pointer at run time. The 
* returned string is, at most, five characters long. 
*I 
if( type ) 
{ 
if( type->class 
return "pp"; 
else DECLARATOR ) 
switch( type->NOUN 
{ 
case INT: return (type->LONG) ? "1" 
case CHAR: 
case STRUCTURE: return "b.bO"; "w.low"; 
yyerror("INTERNAL, get_suffix: Can't process type %s.\n", type_str(type) ); 
exit ( 1 ) ; 
1*----------------------------------------------------------------------*l 
void 
value release_value( val ) 
*val; 
if( val 
{ 
if( val->is_tmp ) I* Discard a value, first freeing any space *I 
I* used for an associated temporary variable. *I 
tmp_free( val->offset ); 
discard_value( val); 
Create and initialize tem­
porary: tmp _gen () . tmp _gen () on line 225 of Listing 6.69 both creates the temporary and emits the 
code necessary to initialize it. (tmp _create() doesn't initialize the temporary.) The 
subroutine is passed three arguments. The first is a pointer to a type chain representing 
the type of the temporary. An int is created if this argument is NULL. The second 
argument is a pointer to a value representing an object to be copied into the temporary. 
Code is generated to do the copying, and the source value is released after the code to 
do the copy is generated. If the source is an )value, it is converted to an rvalue first. 
Type conversions. 
convert_type (). If the source variable and temporary variable's types don't match, code is generated 
to do any necessary type conversions. Type conversions are done in convert_ type () 
on line 265 of Listing 6.69 by copying the original variable into a register; if the new 
variable is larger than the source, code to do sign extension or zero fill is emitted. The 
subroutine returns a string that holds the name of the target register. For example, the 
input code: 
Section 6.8.3-Implementing Values, Higher-Level Temporary-Variable Support 
int i; 
long 1; 
foo () { i=i+1; 
generates the following output: 
rO.w.1ow W(&_i); 
ext_word(rO); 
L( T(l) ) r0.1; 
L( T.(l) 
r0.1 
W(&_i) += L (& 1); 
L ( T (1) ) ; 
rO.w.1ow; 
The first two lines, emitted by convert_ type (),create a lonq temporary variable and 
initialize it from an int. The code copies i into a word register and then sign extends 
the register to form an 1 word. The string "rO . 1" is passed back to tmp _gen () , which 
uses it to emit the assignment on the third line. The last two lines demonstrate how a 
truncation is done. convert_ type emits code to copy T ( 1) into a register. It then 
passes the string "rO. w .low" back up to the calling routine, which uses it to generate 
the assignment. 
The test on line 284 of Listing 6.69 checks to see if sign extension is necessary (by 
comparing the number of bytes used for both variables-get_ size () starts on line 304 
of Listing 6.69). Code to do the type conversion is done on lines 286 to 295 of Listing 
6.69. get_ suffix, used on line 298 to access the register, starts on 331 of listing 6.69. 
The release_ value() subroutine on line 361 of Listing 6.69 is a somewhat release_value(). 
higher-level version of discard_ value () . It's used for temporary variables and both 
discards the value structure and frees any stack space used for the temporary. Note that 
the original source value is discarded on line 250 of Listing 6.69 as soon as the variable 
is copied into a register, so the memory used by the original variable can be recycled for 
the new temporary. 
6.8.4 Unary Operators 
Armed with the foregoing, you can proceed to tackle expression processing, starting 
with the unary operators and working our way up the grammar to complete expressions. 
Because you're starting at the bottom, it is helpful to look at the overall structure of the 
expression productions in Appendix C before continuing. Start with the expr nontermi­
nal and go to the end of the grammar. 
The unary operators are handled by the right-hand sides of the unary nonterminal, 
which you get to like this: 
compound _stmt ~ LC local_ defs stmt list RC 
stmt list ~ stmt 
stmt ~ expr SEMI 
expr ~ binary I unary 
(I've both simplified and left out a few intermediate productions for clarity. See Appen­
dix C for the actual productions.) The simplest of the unary productions are in Listing 
6.70. The top production just handles parenthesized subexpressions, and the second 
right-hand side recognizes, but ignores, floating-point constants. 
The right-hand side on line 597 handles integer constants, creating a value structure 
like the one examined earlier in Figure 6.19. make_ icon ( ) , in Listing 6. 71, does the Integer constants, 
actual work, creating a value for the integer constant, which is then passed back up as make_icon 0 · 
an attribute. This subroutine is used in several other places so it does more than is 593 
594 Code Generation -Chapter 6 
Listing 6.70. c.y-Unary Operators (Part I)-Constants and Identifiers 
594 unary 
595 LP expr RP 
FCON $$ = $2; 
596 
597 
598 ICON 
NAME yyerror("Floating-point not supported\n"); 
$$ make icon ( yytext, 0 ); 
$$=do name ( yytext, $1 ); 
required by the current production. In particular, the incoming parameter can represent 
the number either as an integer or as a string. Numeric input is used here by setting 
yytext to NULL. 
Identifiers, 
unary~NAME. Identifiers are handled by on line 598 of Listing 6.70, above. The attribute attached 
to the NAME at $1 is a pointer to the symbol table entry for the identifier or NULL if the 
identifier isn't in the table. The actual work is done by do_ name (), in Listing 6.72, 
below. do_name (). 
Listing 6.71. value.c- Make Integer and Integer-Constant Rvalues 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 value *make_icon( yytext, numeric val 
char *yytext; 
int numeric_val; 
/* Make an integer-constant rvalue. If yytext is NULL, then numeric val 
* holds the numeric value, otherwise the second argument is not used and 
* the string in yytext represents the constant. 
*I 
value *vp; 
link *lp; 
char *p; 
vp make_int(); 
lp vp->type; 
lp->SCLASS CONSTANT; 
if ( !yytext 
lp->V_INT numeric_val; 
else if( *yytext == '\'' ) 
{ 
else 
{ ++yytext; 
lp->V_INT 
for( p 
{ esc ( &yytext ) ; 
yytext; *p ; ++p ) 
if I *p=='u' I I *p=='U' 
else if( *p=='l' 11 *p=='L' 
) /* Skip the quote. */ 
/* Initialize the canst val field */ 
/*based on the input type. stoul() */ 
/* converts a string to unsigned long.*/ 
lp->UNSIGNED 
lp->LONG 1; 
1; 
if( lp->LONG 
lp->V_ULONG 
else stoul( &yytext ); 
lp->V_UINT (unsigned int) stoul( &yytext ); 
return vp; 
Section 6.8.4-Unary Operators 
Listing 6.71. continued ... 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 1*----------------------------------------------------------------------*l 
value *make_int() 
link *lp; 
value *vp; 
lp 
lp->class 
lp->NOUN 
vp 
vp->type 
return vp; new _link () ; 
SPECIFIER; 
INT; 
new_value (); 
vp->etype = lp; I* Make an unnamed integer rvalue. *I 
I* It's an rvalue by default. *I 
Listing 6.72. op.c-Identifier Processing 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <stdlib.h> 
#include <toolsldebug.h> 
#include <toolslhash.h> 
#include <toolsll.h> 
#include <toolslcompiler.h> 
#include <toolslc-code.h> 
#include "symtab.h" 
#include "value.h" 
#include "proto.h" 
#include "label.h" 
I* OP.C This file contains support subroutines for the arithmetic *I 
I* operations in c.y. *I 
symbol *Undecl NULL; I* When an undeclared symbol is used in an expression, 
* it is added to the symbol table to suppress subse­
* quent error messages. This is a pointer to the head 
* of a linked list of such undeclared symbols. It is 
*purged by purge_undecl() at the end of compound 
* statements, at which time error messages are also 
* generated. 
*I 
l*----------------------------------------------------------------------*1 
value 
char 
symbol 
{ *do_name( yytext, sym ) 
*yytext; I* Lexeme *I 
*sym; I* Symbol-table entry for id, NULL if none. *I 
link 
value 
char *chain end, *lp ; 
*synth; 
buf[ VALNAME_MAX ]; 595 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 I* This routine usually returns a logical lvalue for the referenced symbol. 
* The symbol's type chain is copied into the value and value->name is a 
* string, which when used as an operand, evaluates to the address of the 
* object. Exceptions are aggregate types (arrays and structures), which 
* generate pointer temporary variables, initialize the temporaries to point 
596 Code Generation -Chapter 6 
Listing 6. 72. continued ... 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 * at the first element of the aggregate, and return an rvalue that 
* references that pointer. The type chain is still just copied from the 
* source symbol, so a structure or pointer must be interpreted as a pointer 
* to the first element/field by the other code-generation subroutines. 
* It's also important that the indirection processing (* [] . ->) set up 
* the same sort of object when the referenced object is an aggregate. 
* * Note that !sym must be checked twice, below. The problem is the same one 
* we had earlier with typedefs. A statement like foo() {int x;x=l;} fails 
* because the second x is read when the semicolon is shifted---before 
* putting x into the symbol table. You can't use the trick used earlier 
* because def_list is used all over the place, so the symbol table entries 
* can't be made until local_defs->def_list is processed. The simplest 
* solution is just to call findsym() if NULL was returned from the scanner. 
* * The second if(!sym) is needed when the symbol really isn't there. 
*I 
if( !sym ) 
sym = (symbol*) findsym( Symbol_tab, yytext ); 
if( !sym 
sym make_implicit_declaration( yytext, &Undecl ); 
if( IS_CONSTANT(sym->etype) 
{ I* it's an enum member *I 
else if( IS_INT(sym->type) ) 
synth make_icon( NULL, sym->type->V_INT ); 
else 
yyerror("Unexpected noninteger constant\n"); 
synth = make_icon( NULL, 0 ); 
gen comment("%s", sym->name); I* Next instruction will have symbol *I 
I* name as a comment. *I 
if( ! (lp = clone_type( sym->type, &chain_end)) ) 
{ 
yyerror("INTERNAL do_name: Bad type chain\n" ); 
synth = make_icon( NULL, 0 ); 
else if( IS_AGGREGATE(sym->type) ) 
else I* Manufacture pointer to first element *I 
sprintf(buf, "&%s(%s)", 
IS_ARRAY(sym->type) ? get_prefix(lp) 
sym->rname ); 
synth = tmp_create(sym->type, 0); 
gen( "=", synth->name, buf ); 
synth 
synth->lvalue 
synth->type new_value (); 
1 
lp BYTE_PREFIX, 
Section 6.8.4-Unary Operators 597 
Listing 6.72. continued ... 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 synth->etype 
synth->sym chain_end; 
sym ; 
if( sym->implicit II IS_FUNCT(lp) ) 
strcpy( synth->name, sym->rname ) ; 
else 
sprintf(synth->name, 
(chain_end->SCLASS FIXED) ? "&%s(&%s)" : "&%s(%s)", 
get_prefix(lp), sym->rname); 
return synth; 
1*----------------------------------------------------------------------*l 
symbol 
char 
symbol 
{ *make_implicit_declaration( name, undeclp ) 
*name; 
**undeclp; 
I* Create a symbol for the name, put it into the symbol table, and add it 
* to the linked list pointed to by *undeclp. The symbol is an int. The 
* level field is used for the line number. 
*I 
symbol 
link 
extern int 
extern char 
lp 
lp->class 
lp->NOUN *sym; 
*lp; 
yylineno; 
*yytext; I* created by LeX *I 
name, 0 ); 
lp; sym 
sym->implicit 
sym->type 
sym->level new _link () ; 
SPECIFIER; 
INT; 
new_symbol( 
1; 
sym->etype 
yylineno; I* Use the line number for the declaration *I 
I* level so that you can get at it later *I 
I* if an error message is printed. *I 
sprintf( sym->rname, 
addsym ( Symbol_tab, "_%l.*s", sizeof(sym->rname)-2, yytext ); 
sym ) ; 
sym->next 
*undeclp *undeclp; 
sym; I* Link into undeclared list. *I 
return sym; 
1*----------------------------------------------------------------------*l 
PUBLIC void purge_undecl() 
{ 
I* Go through the undeclared list. If something is a function, leave it in 
* the symbol table as an implicit declaration, otherwise print an error 
* message and remove it from the table. This routine is called at the 
* end of every subroutine. 
*I 
.... 
598 Code Generation -Chapter 6 
Listing 6.72. continued ••• 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 symbol *sym, *cur ; 
for( sym 
{ 
cur Undecl; sym; 
/* remove current symbol from list */ 
sym 
cur->next sym; 
sym->next; 
NULL; 
if( cur->implicit 
{ 
Undecl 
Undeclared identifiers. 
make_implicit_­
declaration () 
purge_undecl () 
Symbolic constants. yyerror("%s (used on line %d) undeclared\n", cur->name, cur->level); 
delsym( Symbol_tab, cur ) ; 
discard_symbol( cur); 
NULL; 
The incoming sym argument is NULL when the scanner can't find the symbol in the 
table. The table lookup on line 58 of Listing 6.72 takes care of the time-delay problem 
discussed earlier when types were discussed. Code like this: 
int x; 
X = 1; 
won't work because the symbol-table entry for x isn't created until after the second x is 
read. Remember, the action is performed after the SEMI is shifted, and the lookahead 
character is read as part of the shift operation. 
Undeclared identifiers pose a particular problem. The difficulty is function calls: an 
implicit declaration for the function must be created the first time the function is used. 
Undeclared variables are hard errors, though. Unfortunately, there's no way for the 
unop~NAME production to know how the name is being used. It doesn't know 
whether the name is part of a function call or not. 
If the symbol really isn't in the table, do_ name () creates an implicit declaration of 
type int for the undeclared identifier (on line 62 of Listing 6.72). The 
make_implicit_declaration () subroutine is found on lines 117 to 148 of Listing 
6.72. The new symbol is put into the symbol table, and the cross links form a linked list 
of undeclared symbols. The head-of-list pointer is Undecl, declared on line 16. The 
implicit symbol is marked as such by setting the implicit bit true on line 137 of List­
ing 6.72. The implicit symbol is modified when a function call is processed. A "func­
tion" declarator is added to the front of the type chain, and the implicit bit is turned 
off. I'll discuss this process in detail in a moment. 
After the entire subroutine is processed and the subroutine suffix is generated, 
purge_ undecl () (on line 152 of Listing 6.72) is called to find and delete the unde­
clared symbols. This subroutine traverses the list of implicitly-generated symbols and 
prints "undeclared symbol" error messages for any of them that aren't functions. It also 
removes the undeclared variables from the symbol table and frees the memory. 
One advantage of this approach is that the "undeclared symbol" error message is 
printed only once, regardless of the number of times that the symbol is used. The disad­
vantage is that the error message isn't printed until the entire subroutine has been pro­
cessed. 
Returning to the normal situation, by the time you get to line 64 of Listing 6.72, sym 
points at a s ymbo 1 for the current identifier. If that symbol represents a constant, then it 
Section 6.8.4-Unary Operators 
was created by a previous enumerated-type declaration. The action in this case (on lines 
66 to 72) creates an rvalue for the constant, just as if the number, rather than the sym­
bolic name, had been found. 
If the current symbol is an identifier, a value is created on lines 74 to 110 of Listing 
6.72. The type chain is cloned. Then, if the symbol represents an aggregate type such as 
an array, a temporary variable is generated and initialized to point at the first element of 
the aggregate. Note that this temporary is an rvalue, not an lvalue. (An array name 
without a star or brackets is illegal to the left of an equal sign.) It's also important to 
note that arrays and pointers can be treated identically by subsequent actions because a 
physical pointer to the first array element is generated-pointers and arrays are physi­
cally the same thing at run time. A POINTER declarator and an ARRAY declarator are 
treated identically by all of the code that follows. I'll explore this issue further, along 
with a few examples, in a moment. 
If the current symbol is not an aggregate, a logical )value is created in the else 
clause on lines 95 to 109 of Listing 6.72. The value's name field is initialized to a 
string that, when used as an operand in a C-code instruction, evaluates either to the 
address of the current object or to the address of the first element if it's an aggregate. 
If the symbol is a function or if it was created with an implicit declaration, the name 
is used as is. (We're on lines 103 of Listing 6.72.) I'm assuming that an implicit symbol 
will eventually reference a function. The compiler generates bad code if the symbol 
doesn't, but so what? It's a hard error to use an undeclared variable. 
All other symbols are handled by the sprintf () call on line 106 of Listing 6.72. 
The strategy is to represent all possible symbols in the same way, so that subsequent 
actions won't have to worry about how the name is specified. In other words, a subse­
quent action shouldn't have to know whether the referenced variable is on the stack, at a 
fixed memory address, or whatever. It should be able to use the name without thinking. 
You can get this consistency with one of the stranger-looking, C-code storage 
classes. The one case that gives us no flexibility is a frame-pointer-relative variable, 
which must be accessed like this: WP ( fp+8) . This string starts with a type indicator 
(WP), the variable reference itself is an address (fp+8), and an indirect addressing mode 
must be used to access the variable. To be consistent, variables at fixed addresses such 
as global variables are represented in a similar way-like this: WP ( & _P). The fp+8 and 
_Pare just taken from the symbol's name field. The type (WP, here) is figured by 
get _prefix() by looking at the variable's actual type. Since we are forming I values, 
the names must evaluate to addresses, so we need one more ampersand in both cases. 
& WP ( fp+ 8) and & WP ( & _P) are actually put into the name array. 
The next unop right-hand side, which handles string constants, is in Listing 6.73. 
The string_const productions in Listing 6.74 collect adjacent string constants and con­
catenate them into the Str_buf array, declared in the occs declarations section at the 
top of listing 6.74. The attribute attached to the string_const is a pointer to the assem­
bled string, which is then turned into an rvalue by the make_ scon () call on line 602 of 
Listing 6.73. The subroutine itself is in Listing 6.75. String constants are of type 
"pointer to char". The string itself is not stored internally by the compiler beyond the 
time necessary to parse it. When a string constant is recognized, a declaration like the 
following one is output to the data segment: 
private char 8156[]= "contents of string"; 
The numeric component of the label (15 6) is remembered in v _in t field of the last 
link in the type chain, and the entire label is also loaded into the value's name array. Creating identifier 
values. 599 
Aggregate types 
represented by physical 
pointers at run time. 
value.name 
All symbols represented 
identically. 
Using &WP (&_p) for 
)values 
String constants. 
The next operator, sizeof, is handled by the productions in Listing 6.76. Three The sizeof operator. 
cases have to be handled separately: 
600 Code Generation -Chapter 6 
Listing 6.73. c.y-Unary Operators (Part 2)-String Constants 
599 
600 
601 
602 
603 
604 I* unop: *I 
I string_const %prec COMMA 
{ 
$$=make scon( $1 ); 
yydata( "~rivate\tchar\t%s[]=\"%s\";\n", $$->name,$1); 
Listing 6.74. c.y-Array in which String Constants are Assembled 
139 
140 
141 
142 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 
616 
617 
618 
619 
620 
621 
622 
623 %{ 
#define STR MAX 512 I* Maximum size of a string constant. 
I* Place to assemble string constants. *I 
*I char Str_buf[STR_MAX]; 
%) 
string_const 
STRING 
{ 
$$ 
*Str buf Str_buf; 
, \0'; 
yytext[ str1en(yytext) - 1 ] = '\0' ; I* Remove trailing " *I 
if( concat(STR_MAX, Str_buf, Str_buf, yytext+1, NULL) < 0 ) 
yyerror("String truncated at %d characters\n", STR MAX); 
string_const STRING 
{ 
yytext[ str1en(yytext) - 1 ] = '\0' ; I* Remove trailing " *I 
if( concat(STR_MAX, Str_buf, Str_buf, yytext+1, NULL) < 0 ) 
yyerror("String truncated at %d characters\n", STR MAX); 
sizeof ("string") evaluates to the number of characters in the string, 
sizeof (expression) evaluates to the size of the temporary variable that holds the 
result of the evaluation. 
sizeof (type) int x; 
long y; 
sizeof( X ) ; I* 2 (size of a word). *I 
sizeof( y ) ; I* 4 (size of an lword). *I 
sizeof( x+y ) ; I* 4 (size of an lword). *I 
evaluates to the number of bytes required by a variable of the 
indicated type. 
The returned attribute for all three cases is an integer-constant rvalue, the 
canst_ val field of which holds the required size. The attribute attached to the expr 
($3 in the second right-hand side in Listing 6.76) is a value for the temporary that holds 
the result of the run-time expression evaluation. Its type field determines the size. 
Similarly, the attribute attached to the abstract_ dec/ ($ 3 in the third right-hand side in 
Listing 6.76) is a nameless symbol that holds a type chain for the indicated type. 
Section 6.8.4-Unary Operators 
Listing 6.75. value.c- Make a String-Constant Rvalue 
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 value 
char *make_scon( str ) 
*str; 
{ 
link *p; 
value *synth; 
static unsigned label = 0; 
synth 
synth->type 
p 
p->DCL_TYPE 
p->next 
p 
p->class 
p->NOUN 
p->SCLASS 
p->V_INT new_value (); 
new_link (); 
synth->type; 
POINTER; 
new_link (); 
p->next; 
SPECIFIER; 
CHAR; 
CONSTANT; 
++label; 
synth->etype = p; 
sprintf( synth->name, "%s%d", 
return synth; L_STRING, label ) ; 
Listing 6.76. c.y-Unary Operators (Part 3)-sizeof 
/* unop: *I 601 
624 
625 
626 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 I SIZEOF LP string_const RP %prec SIZEOF 
{ $$ make icon(NULL,strlen($3) + 1 ); 
I SIZEOF LP expr RP %prec SIZEOF 
$$ = make_icon(NULL,get_sizeof($3->type)); 
release_value( $3 ); 
I SIZEOF LP abstract decl RP %prec SIZEOF 
$$ = make_icon( NULL, 
get_sizeof($3->type)); 
discard_symbol( $3 ); 
So far, none of the operators have generated code. With Listing 6.77, we move 
on to an operator that actually does something. The right-hand side in Listing 6.77 
processes the cast operator. The test on line 641 checks to see if the cast is legal. If it is, 
and the source and destination types are both pointers, it just replaces the type chain in 
the operand with the one from the cast operator on lines 648 to 651. Note that this 
behavior, though common in C compilers, can cause problems because the contents of 
the pointer are not changed, only the type. A run-time alignment error occurs the first 
time you try to use the pointer if the alignment isn't correct. 
The third possibility, on line 655 of Listing 6.77, takes care of all other cases. The 
tmp _gen () call creates a temporary of the required type, copies the contents of the 
operand into the temporary (making any necessary type conversions and translating Type-conversion opera­
tors. 
Casts. 
602 Code Generation -Chapter 6 
Listing 6.77. c.y-Unary Operators (Part 4)-Casts and Address-of 
I* unop: *I 638 
639 
640 
641 
642 
643 
644 
645 
646 647 
648 
649 
650 
651 
652 
653 
654 
655 
656 
657 I LP abstract_decl RP unary 
{ %prec UNOP 
Unary minus, NOT, ones 
complement. 
The -and unary -opera­
tors. 
The ! operator. 
tf_label () if( IS_AGGREGATE($2->type) 
{ 
yyerror( "Illegal cast to aggregate type\n" ); 
$$ = $4; 
else if( IS_POINTER($2->type) && IS_POINTER($4->type) 
{ 
else discard_link_chain( $4->type ); 
$4->type $2->type; 
$4->etype = $2->type; 
$$ = $4; 
$$ tmp_gen( $2->type, $4 ); 
!values to rvalues as necessary), and finally, it deletes the value associated with the 
operand. 
The next issue is the unary arithmetic operators, handled by the right-hand sides in 
Listing 6.78. The first one takes care of unary minus, the second handles the logical 
NOT and one's-complement operators (!, -). The attribute attached to the UNOP is the 
lexeme (passed in an int because it's only one character). Again, the work is done by a 
subroutine: do_ unop (),at the top of Listing 6.79. 
The arithmetic operators are easy. The action (on lines 184 to 188 of Listing 6. 79) 
just modifies the operand, passing the operator through to gen ( ) . If the name field of 
the operand holds the string "W ( fp+B) ",then the following code is generated for unary 
minus and one's complement: 
W(T(O)) =-W(fp+8); 
W(T(O)) =-W(fp+8); I* -name *I 
I* -name *I 
In the first case, the -is supplied in the production, in the second, the attribute is used. 
The logical NOT operator is a little harder to do because it must evaluate either to 1 
or 0, depending on the truth or falsity of the operand. Assuming that xis at w (fp+6), 
the expression ! x generates the following code: 
EQ( W(fp+6), 0 ) I* if the operand if false *I 
goto TO; 
FO: W( T (0) ) 0; I* temp 0 *I 
go to EO; 
TO: W( T (0) 1; I* temp 1 *I 
EO: 
The synthesized attribute is the temporary variable that holds the 1 or 0. All but the first 
two instructions are created by gen _false_ true(), on line 206 of Listing 6.79. The T 
label takes care of the true situation, the F label with false, and the E (for end) lets the 
false case jump over the true one after making the assignment. The numeric component 
of all three labels is the same, and is generated by the t f _label () call on line 192 of 
Listing 6.79. (t f _label () is declared just a few lines down, on line 199.) This label is 
then passed to gen _false_ true as an argument. 
Section 6.8.4-Unary Operators 603 
All but the first two lines of the output are emitted by gen _false_ true(), starting gen_false_true 0 
on line 206 of Listing 6.79. This subroutine is used by the actions for all of the logical 
operators. It is passed the numeric component of the target labels and a pointer to the 
operand's value structure. This second argument is used only to do a simple 
optimization-if the operand is already a temporary variable of type int, then it is recy-
cled to hold the result of the operation, otherwise a new temporary variable is created. 
(The test is made on line 220 and the temporary is created on the next two lines.) 
Remember, both the test and the jump to the true or false label are generated before 
gen_false_true () is called, and once the jump has been created, the associated 
value is no longer needed. The operand's value could be discarded by the calling rou-
tine if you didn't want to bother with the optimization. 
Note that the low-level tmp _create() function, which creates but doesn't initial­
ize the temporary, is used here. Also note that the value is discarded before the 
tmp _create () call so that the same region of memory can be recycled for the result of 
the operation. 
Listing 6.78. c.y-Unary Operators (Part 5)-Unary Arithmetic Operators 
658 I* unop: *I 
659 I MINUS 
660 I UNOP unary 
unary $$ 
$$ do_unop( '-' 
do_unop( $1, $2 ) ; 
$2 ) ; %prec UNOP 
The pre and post, increment and decrement operators are processed by the produc- ++ and --, in cop<)· 
tions in Listing 6.80 and the in cop () subroutine in Listing 6.81. The following input 
file: 
int x; 
foo () { ++x; } 
generates the following code for the ++x: 
W (&_x) += 1; 
W( T(1) ) = W(&_x); I* Increment x itself. *I 
I* Copy incremented value to temporary. *I 
The synthesized attribute is the temporary variable. A postincrement like x++ works in a 
similar manner, but the two instructions are transposed: 
W( T(1) ) = W(&_x); 
W(&_x) += 1; 
Again, the synthesized attribute is the temporary-the value of the temporary is deter­
mined by whether a pre or post increment is used. The++ and --operators require an 
!value operand, but they both generate rvalue temporararies. Pre and postdecrements use 
-= rather than += but are otherwise the same as the increments. 
Listing 6.82 contains various right-hand sides for the address-of operator(&) and the 
dereference operators (*, [], . , and ->). The structure operators are grouped with the 
rest of them because they all do essentially the same thing: add an offset to a pointer and 
load the object at the indicated address into a temporary variable. All of these operators 
generate rvalues. The all require either an !value operand, or an rvalue operand of type 
"array", "structure", or "pointer". Remember that aggregate-type references generate a 
temporary variable (an rvalue) holding the address of the object. 
The first issue is getting an objects address. The address-of operator is processed by 
unop~AND unary on line 665 of Listing 6.82. The addr _of () workhorse function is 
in Listing 6.83, below. Only two kinds of incoming values are legal here: an !value or 
an rvalue for an aggregate type such as a structure. In either case, the incoming value Pointer and array dere­
ferencing. 
Address-of operator(&) 
604 Code Generation -Chapter 6 
Listing 6.79. op.c-Unary Minus and Ones-Complement Operator Processing 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 
230 
231 
232 value *do_unop( op, val ) 
int op; 
value *val; 
char 
int 
if( 
{ 
else 
{ buf *op_ "=?" 
i; 
op != , ! , I* -or unary -*I 
op_buf[l] op; 
gen( op_buf, val->name, val->name ); 
I* ! *I 
gen ( "EQ", rvalue (val), "0" ); I* EQ(x, 0) *I 
gen( "goto%s%d", L_TRUE, i 
val= gen_false_true( i, val); tf_label() ); I* goto TOGO; *I 
I* fall thru to F *I 
return val; 
1*----------------------------------------------------------------------*l 
int tf_label() 
I* Return the numeric component of a label for use as *I 
static int label; 
return ++label; I* a true/false target for one of the statements *I 
I* processed by gen_false_true(). *I 
1*----------------------------------------------------------------------*l 
value 
int 
value *gen_false_true( labelnum, val ) 
labelnum; 
*val; 
I* Generate code to assign true or false to the temporary represented by 
* val. Also, create a temporary to hold the result, using val if it's 
* already the correct type. Return a pointer to the target. The FALSE 
* code is at the top. If val is NULL, create a temporary. Labelnum must 
*have been returned from a previous tf_label() call. 
*I 
if ( !val ) 
val= tmp_create( NULL, 0 ); 
else if( !val->is_tmp I I !IS_INT(val->type) 
{ 
release_value( val); 
val= tmp_create( NULL, 0 ); 
gen( ":%s%d", L FALSE, labelnum ) ; 
gen( "=" I val->name, "0" ) ; 
gen( "goto%s%d", L END, labelnum ) ; 
gen( ":%s%d", L TRUE, labelnum ) ; -gen( "=" I val->name, "1" ) ; 
gen( ":%s%d", L END, labelnum ) ; 
return val; I* FOGO: *I 
I* tO = 0 *I 
I* go to EOOO; *I 
I* TOGO: *I 
I* tO = 1; *I 
I* EOOO: *I 
Section 6.8.4-Unary Operators 
Listing 6.80. c.y-Unary Operators (Part 6)-Pre and Postincrement 
661 I* unop: *I 
662 I unary INCOP 
663 I INCOP unary $$ 
$$ incop ( 0, $2, $1 ) ; 
incop( 1, $1, $2 ); 
Listing 6.81. op.c-Increment and Decrement Operators 
value *incop( is_preincrement, op, val I* ++ or 
int is_preincrement; I* Is pre increment or predecrement. --
int op; I* ,_, for decrement, '+' for increment 
value *val; I* 1 value to modify. 
char buf[ VALNAME MAX l ; 
char *name; 
value *new; 
char *out op (op '+') ? "+=%s%d" "-=%s%d" -int inc amt 
I* You must use rvalue_name() in the following code because rvalue() 605 
*I 
*I 
*I *I 233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 * modifies the val itself--the name field might change. Here, you must use 
* the same name both to create the temporary and do the increment so you 
* can't let the name be modified. 
*I 
if( !val->lvalue ) 
yyerror("%c%c: lvalue required\n", op, op ); 
else 
inc amt (IS_POINTER(val->type)) ? get_sizeof(val->type->next) 
rvalue_name( val); name 
if( is_preincrement ) 
gen( out op, name, inc amt ); 
val tmp_gen( val->type, val); 1 
else I* Postincrement. *I 
val= tmp_gen( val->type, val); 
gen( out_op, name, inc amt ); 
return val; 
Listing 6.82. c.y-Unary Operators (Part ?)-Indirection 
664 I* unop: *I 
665 I AND unary $$ addr of ( 
666 I STAR unary $$ indirect ( 
667 I unary LB expr RB { $$ indirect ( $2 
NULL, 
$3, 
668 I unary STRUCTOP NAME $$ = do_struct($1, $2, ) ; %prec UNOP 
$2 ) ; %prec UNOP 
$1 ) ; %prec UNOP 
yytext); %prec STRUCTOP 
606 Code Generation -Chapter 6 
*and [J already holds the desired address: The lvalue is an address by definition. An rvalue like 
the one created by unop~NAME for an aggregate object is a physical temporary vari­
able that also holds the required address. So, all that the address-of action needs to do is 
modify the value's type chain by adding an explicit pointer declarator at the far left and 
change its value into an rvalue by clearing the lvalue bit. Keep this action in mind 
when you read about the* operator, below. I'll start with the pointer dereference (*)and 
the array dereference ( []),operators, handled by indirect () (in Listing 6.84, below). 
Listing 6.83. op.c-Address-of Operator Processing 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 value *addr_of( val ) 
value *val; 
I* Process the & operator. Since the incoming value already holds the 
* desired address, all you need do is change the type (add an explicit 
* pointer at the far left) and change it into an rvalue. The first argument 
* is returned. 
*I 
link *p; 
if( val->lvalue 
{ 
p 
p->DCL_TYPE 
p->next 
val->type 
val->lvalue new_link(); 
POINTER; 
val->type; 
p; 
0; 
else if( !IS_AGGREGATE(val->type) 
yyerror( "(&) lvalue required\n" ); 
return val; 
Listing 6.84. op.c-Array Access and Pointer Dereferencing 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 308 
309 
310 
311 
312 
313 
314 value *indirect( offset, ptr ) 
value *offset; 
value *ptr; I* Offset factor (NULL if it's a pointer). *I 
I* Pointer that holds base address. *I 
I* Do the indirection, If no offset is given, we're doing a *, otherwise 
*we're doing ptr[offset]. Note that, strictly speaking, you should create 
* the following dumb code: 
* 
* tO = 
* tO += 
* tl = 
* 
* rvalue ( ptr 
offset 
*tO; ) ; (if ptr isn't a temporary) 
(if doing [offset]) 
(creates a rvalue) 
lvalue attribute = &tl 
* but the first instruction is necessary only if ptr is not already a 
* temporary, the second only if we're processing square brackets. 
* 
* The last two operations cancel if the input is a pointer to a pointer. In 
* this case all you need to do is remove one * declarator from the type 
* chain. Otherwise, you have to create a temporary to take care of the type 
* conversion. 
*I .... 
Section 6.8.4-Unary Operators 607 
Listing 6.84. continued ... 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 
352 
353 
354 
355 
356 
357 358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 link *tmp 
value *synth 
int objsize I* Size of object pointed to (in bytes) 
if( !IS_PTR_TYPE(ptr->type) 
yyerror( "Operand for* or [N] Must be pointer type\n" ); *I 
rvalue( ptr ); I* Convert to rvalue internally. The "name" field *I 
I* is modified by removing leading &'s from logical *I 
I* lvalues. *I 
if( offset ) 
{ I* Process an array offset. *I 
if( !IS_INT(offset->type) 1 I !IS_CHAR(offset->type) 
yyerror( "Array index must be an integral type\n" ); 
objsize = get_sizeof( ptr->type->next ); I* Size of 
I* object. 
if( !ptr->is_tmp ) I* Generate 
ptr = tmp_gen( ptr->type, ptr ); I* lvalue. de referenced *I 
*I 
a physical *I 
*I 
if( IS_CONSTANT( offset->type ) ) 
{ I* Offset is a constant.* I 
gen ( "+=%s%d", ptr->name, offset->type->V_INT * objsize ) ; 
else I* Offset is not a con-*I 
{ I* stant. Do the arith- *I 
I* me tic at run time. *I 
if( objsize != 1 ) 
{ I* Multiply offset by *I 
I* size of one object. *I 
if( !offset->is tmp ) 
offset= tmp_gen( offset->type, offset); 
gen( "*=%s%d", offset->name, objsize ); 
gen( "+=", ptr->name, offset->name ); I* Add offset to base. *I 
release_value( offset ); 
I* The temporary just generated (or the input variable if no temporary 
* was generated) now holds the address of the desired cell. This command 
* must generate an lvalue unless the object pointed to is an aggregate, 
* whereupon it's n rvalue. In any event, you can just label the current 
* cell as an lvalue or rvalue as appropriate and continue. The type must 
* be advanced one notch to compensate for the indirection, however. 
*I 
synth ptr; 
tmp ptr->type; I* Advance type one notch. *I 
ptr->type ptr->type->next; 
discard_link(tmp); 
608 Code Generation -Chapter 6 
Listing 6.84. continued ... 
372 
373 
374 
375 
376 if( !IS_AGGREGATE(ptr->type->next) 
synth->lvalue = 1; /* Convert to lvalue. */ 
return synth; 
Operand to * or [ J 
must be array or pointer. 
Attribute synthesized by 
* and [ J operators. 
Rules for forming lvalues 
and rvalues when pro­
cessing * and [ J • The best way to understand the code is to analyze what actually happens as the 
operator is processed. First of all, as was the case with the address-of operator, the 
operand must represent an address. It is one of two things: (1) an array, in which case 
the operand is an rvalue that holds the base address of the array, or (2) a pointer, in 
which case the operand is an I value for something of pointer type-the expression in the 
value's name field evaluates to the address of the pointer. 
The next issue is the synthesized attribute, which is controlled by the type of the 
dereferenced object. The compiler needs to convert the incoming attribute to the syn­
thesized attribute. If the dereferenced object is a nonaggregate, the synthesized attribute 
is an I value that holds the address of the dereferenced object. If the dereferenced object 
is an aggregate, then the attribute is an rvalue that holds the address of the first element 
of the object. In other words, the generated attribute must be the same thing that would 
be created by unop~NAME if it were given an identifier of the same type as the refer­
enced object. Note that both the incoming and outgoing attributes are addresses. 
To summarize (if the following isn't clear, hold on for a second-several examples 
follow): 
(1) The dereferenced object is not an aggregate. The synthesized attribute is an lvalue 
that references that object, and: 
a. if the incoming attribute is an rvalue, then it already contains the necessary 
address. That is, the incoming rvalue holds the address of the dereferenced 
object, and the outgoing lvalue must also hold the address of the dereferenced 
object. Consequently, no code needs to be generated in this case. The com­
piler does have to modify the value internally, however. First, by setting the 
lvalue bit true, and second, by removing the first link in the type chain. 
Remember, the generated I value is for the dereferenced object. If the incoming 
type is "pointer to int ", the outgoing object is an I value that references the 
int. 
If the compiler's doing an array access rather than a pointer access, code must 
also be emitted to add an offset to the base address that's stored in the lvalue. 
b. if the incoming attribute is a logical I value, then all the compiler needs to do is 
remove the leading ampersand and change the type as discussed earlier. The 
pointer variable is now treated as if it were a physical I value. 
If the compiler's processing an array access, it must create a physical lvalue in 
order to add an offset to it. It can't modify the declared variable to compute an 
array access. 
c. if the incoming attribute is a physical lvalue, for a pointer, then you need to 
generate code to get rid of one level of indirection, and change the type as was 
discussed earlier. You can safely add an offset to the physical lvalue to do 
array access. 
(2) The dereferenced object ~ an aggregate. The synthesized attribute is an rvalue that 
points at the first element of the referenced array or structure, and: 
a. if the incoming attribute is an rvalue, use it for the synthesized attribute, chang­
ing the type by removing the first declarator link and adding an offset as neces­
sary. 
Section 6.8.4-Unary Operators 
b. if the incoming attribute is a logical !value, create a physical rvalue, with the 
type adjusted, as above. 
c. if the incoming attribute is a physical !value, convert it to an rvalue by resetting 
the 1 value bit and adjust the type, as above. 
Note that many of the foregoing operations generate no code at all-they just modify 
the way that something is represented internally. Code is generated only when an offset 
needs to be computed or an incoming !value references an aggregate object. Also, notice 
the similarities between processing a & and processing a *. The former adds a pointer 
declarator to the type chain and turns the incoming attribute into an rvalue; the latter 
does the exact opposite, removing a pointer declarator from the front of the type chain 
and turning the incoming attribute into an !value. 
I'll demonstrate how indirection works with some examples. Parses of the following 
code is shown in Tables 6.17 to 6.23. 
int *p, a[lO]; 
foo () 
{ 
*p++; 
a [ 7]; *++p; 
++p [3]; ++*p; 
p++[3]; 
Table 6.17. Generate Code for *p++; 
Parse and Value Stacks 
stmt list 
0 
stmt list STAR 
0 0 (*p) ++; 
Comments 
Shift STAR. 
Shift NAME. The attribute for NAME is a pointer to the symbol forp. 609 
stmt list STAR NAME Reduce by unary-? NAME. The action creates an !value that references the variable. 0 0 p 
stmt list STAR unary Shift INCOP. 0 0 &WP (&_p), 
stmt list STAR unary IN COP Reduce by unary---?unary IN COP. Emit code to increment p: 
0 0 &WP(&_p), '+' CODE: WP (T (1)) = WP (&_p); 
CODE: WP (&_p) += 2; 
The synthesized attribute is an rvalue (of type "pointer to int") for the temporary 
variable. 
stmt list STAR unary Reduce by unary---?STAR unary. $2 (under the unary) already contains the correct 
0 0 WP(T(1))R address and is of the correct type. Convert it to a physical I value that references *p 
(not p itself). 
stmt list unary Subsequent operations cannot access p; they can access *p with *WP ( T ( 1) ) . 
0 WP(T(1)), 
Neither the entire parse nor the entire parse stack is shown in the tables, but there's 
enough shown that you can see what's going on. The following symbols are on the stack 
to the left of the ones that are shown. 
ext_ def_list opt _specifiers funct _dec! { 7 0} def_list { 71 } LC { 6 5} local_ defs 
I've shown the value stacks under the parse stack. Attributes for most of the nontermi­
nals are value structures-the name field is shown in the table. Subscripts indicate 
whether it's an !value (name) or rvalue (name). Logical !values start with an amper­
sand. A box (D) is used when there are no attributes. You should look at all these tables 
now, even though they're scattered over several pages. 
I've used the ++ operators in these expressions because ++ requires an !value, but it 
generates an rvalue. The ++ is used to demonstrate how the indirection is handled with 
both kinds of incoming attributes. Other, more complex expressions [like * (p+ 1)] are 
610 Code Generation -Chapter 6 
Table 6.18. Generate Code for *++p; 
Parse and Value Stacks Comments 
stmt list 
0 Shift STAR 
stmt list STAR Shift IN COP. The attribute for IN COP is the first character of the lexeme. 
0 0 
stmt list STAR IN COP Shift NAME. The attribute for NAME is a pointer to the symbol forp. 
0 0 '+' 
stmt list STAR IN COP NAME Reduce by unary~NAME. Create a logical I value that references p. 0 0 '+' p 
stmt list STAR IN COP unary Reduce by unary~JNCOP unary. Emit code to increment p: 
0 0 '+' &WP(&_p)L CODE: WP (&_p) += 2; 
CODE: WP (T (1)) = WP (&_p); 
The synthesized attribute is an rvalue of type "pointer to int" that holds a copy ofp. 
From this point on, the compiler has forgotten that p ever existed-at least for the 
purposes of processing the current expression. 
stmt list STAR unary Reduce by unary~STAR unary. The current reduction turns the attribute from the 
0 0 WP(T(l)), previous reduction it into a physical !value that references the dereferenced object 
(*p). 
stmt list unary 
0 WP(T(l))L 
Table 6.19. Generate Code for (*p) ++; 
Parse and Value Stacks Comments 
stmt list Shift LP 0 
stmt list LP Shift STAR 0 0 
stmt list LP STAR Shift NAME. The attribute is a pointer to a symbol structure forp. 0 0 0 
stmt list LP STAR NAME Reduce by unary~NAME. The synthesized attribute is a logical !value that 
0 0 0 p references p. 
stmt list LP STAR unary Reduce by unary~STAR unary. Convert the incoming logical !value forp to a 
0 0 0 &WP (&_p)L physical !value that references *p. 
stmt list LP 
0 0 
stmt list LP 
0 0 
stmt list LP 
0 0 
stmt list unary 
0 WP(&_p)L 
stmt list unary 
0 WP(&_p)L 
stmt list unary 
0 W(T(l) )• unary unary is now converted to expr by a series of reductions, not shown here. The 
WP (&_p)L initial attribute is passed through to the expr, however. 
expr Shift RP WP (&_p)L 
expr RP Reduce by unary~LP expr RP. $$ $2; = WP (&_p)L 
Shift INCOP 
IN COP Reduce by unary~unaryJNCOP. Emit code to increment *p: 
• +' CODE:W(T(l)) = *WP (&_p); 
CODE: *WP (&_p) += 1; 
The synthesized attribute is an rvalue for the temporary that holds the incre-
mented value of *p; 
handled in much the same way. (p+ 1, like ++p, generates an rvalue of type pointer.) 
I suggest doing an exercise at this juncture. Parse the following code by hand, start­
ing at the stmt_list, as in the previous examples, showing the generated code and the 
relevant parts of the parse and value stack at each step: 
Section 6.8.4-Unary Operators 
Table 6.20. Generate Code for ++ * p; 
Parse and Value Stacks 
stmt_list 
D 
stmt list IN COP 
D '+' 
stmt list IN COP STAR 
D '+' D 
stmt list IN COP STAR NAME 
D '+' D p 
stmt list IN COP STAR unary 
D '+' D &WP(&_p)L 
stmt list IN COP unary 
D '+' D WP(&_p)L 
stmt_list unary 
D W(T (1) )• 
Table 6.21. Generate Code for a [ 7] ; 
Parse and Value Stacks 
stmt list 
D 
stmt list NAME 
D a 
stmt list unary 
D W(T (1) ), 
stmt list unary 
D W(T (1) )• 
stmt list unary 
D W(T(1) )• 
stmt list unary 
D W(T(1) )• 
stmt list unary 
D W(T(1) )• 
stmt_list unary 
D W(T (1) )• 
stmt list unary 
D W(T (1) )L 
int *x[5]; 
**x; 
*x [3]; 
X [1] [2]; LB 
D 
LB ICON 
D "7" 
LB unary 
7. 
LB expr 
D 7. 
LB expr 
D 7. RB 
D 611 
Comments 
Shift INCOP 
Shift STAR 
Shift NAME. The attribute for NAME is a pointer to the symbol structure forp. 
Reduce by unary~NAME. Create a logical lvalue forp. 
Reduce by unary~STAR unary. This reduction converts the logical lvalue that refer-
ences p into a physical I value that references *p. 
Reduce by unary~JNCOP unary Emit code to increment *p: 
CODE: *WP (&_p) += 1; 
CODE: w (T (1)) = *WP (&_p); 
The generated attribute is an rvalue that holds the contents of *p after the increment-
this is a preincrement. 
Comments 
Shift NAME. The attribute for NAME is a pointer to the symbol structure for a. 
Reduce by unary~NAME. Since this is an array rather than a simple pointer variable, an 
rvalue is generated of type "pointer to first array element" (pointer to int, here): 
CODE:W(T(1)) = &W(_a); 
Shift LB. 
Shift ICON. 
Reduce by unary~JCON. The synthesized attribute is a value representing the constant 
7. 
unary is reduced to expr by a series of reductions, not shown here. The attribute is passed 
through to the expr, however. 
Shift RB. 
Reduce by unary~LBexprRB. The incoming attribute is an rvalue of type "pointer to 
int." The following code is generated to compute the offSet: 
CODE:W(T(1)) += 14; 
The synthesized attribute is an I value holding the address of the eighth array element. 
The final attribute is an )value that references a [ 7] . 
The other pointer-related operators are the structure-access operators: . and ->. Structure access: -> 
and.,do_struct(). These are handled by the do_ st ruct () subroutine in Listing 6.85. The basic logic is 
the same as that used for arrays and pointers. This time the offset is determined by the 
position of the field within the structure, however. 
The final unary operator handles function calls. It's implemented by the unop right­
hand sides in Listing 6.85 and the associated subroutines, call () and ret_ reg () , in 
Listing 6.86. One of the more interesting design issues in C is that the argument list as a Function calls. 
612 Code Generation -Chapter 6 
Table 6.22. Generate Code for p++ [ 3] ; 
Parse and Value Stacks Comments 
stmt_list 
D 
stmt_list NAME 
D 
stmt_list unary 
D &WP (& _p) L 
stmt list unary 
D &WP (&__p)L 
stmt_list unary 
D WP(T(1))• 
stmt list unary 
D WP(T(1))• 
stmt list unary 
D WP(T(1))• 
stmt_list unary 
D WP(T(1))• 
stmt list unary 
D WP(T(1))• 
stmt list unary 
D WP(T(1))L 
stmt list unary 
D WP(T(1))L 
Function-argument pro­
cessing, 
non_comma_expr. Shift NAME 
Reduce by unary~NAME. 
Shift IN COP 
IN COP Reduce by unary~unary IN COP. Emit code to increment the pointer. The syn-
'+' thesized attribute is an rvalue of type pointer to int. 
CODE: WP (T (1)) = WP (&__p); 
CODE: WP (&__p) += 2; 
Shift LB. 
LB Shift ICON. D 
LB ICON Reduce by unary~ICON. The action creates an rvalue for an int constant. The 
D '3' numeric value is stored in $$->etype->V INT. 
LB unary Reduce unary to expr by a series of reductions, not shown. The original attribute 
D 3. is passed through to the expr. 
LB expr Shift RB. D 3. 
LB expr RB Reduce by unary~ICON. Code is generated to compute the address of the 
D 3. D fourth cell: 
CODE: WP (T (1)) += 6; 
Since the incoming attribute is already a temporary variable of the correct type, 
there's no need to generate a second temporary here-the first one is recycled. 
Note that it is translated to an Ivalue that references the fourth cell, however. 
whole can be seen as a function-call operator which can be applied to any function 
pointer; 22 a function name evaluates to a pointer to a function, much like an array name 
evaluates to a pointer to the first array element. The code-generation action does four 
things: push the arguments in reverse order, call the function, copy the return value into 
an rvalue, discard the arguments by adding a constant to the stack pointer. For example, 
a call like the following: 
doctor( lawyer, merchant, chief); 
is translated to: 
push( W(& -chief) ) ; I* push the arguments *I 
push( W (&_merchant) ) ; 
push( W(& lawyer) ) ; 
call ( doctor ) ; I* call the subroutine *I 
W( T (1) ) = rF.w.low; I* copy return value to rvalue *I 
sp += 3; I* discard arguments. *I 
The function arguments are processed by the args productions on lines 674 to 681 of 
Listing 6.86. A non_comma_expr recognizes all C expressions except those that use 
comma operators. You must do something like the following to get a comma operator 
into a function call: 
22. This is actually a C++ism, but it's a handy way to look at it. 
Section 6.8.4-Unary Operators 613 
Table 6.23. Generate Code for ++p [ 3] ; 
Parse and Value Stacks Comments 
stmt list Shift INCOP 0 
stmt list IN COP Shift NAME. The attribute is a symbol representing p. 0 '+' 
stmt list IN COP NAME Reduce by unary--7NAME. Convert symbol to an I value. 0 '+' 
stmt list IN COP unar.v Shift LB 0 '+' &WP(& p), 
stmt list IN COP unary LB Shift ICON 0 '+' &WP(& p), 0 
stmt list IN COP unary LB ICON Reduce by unary-? ICON. The synthesized attribute is a value structure 
0 '+' &WP(& _p), 0 '3' representing an int constant. It's an rvalue. The actual value (3) is stored 
internally in that structure. 
stmt list IN COP unary LB unary Reduce unary to expr by a series of reductions, not shown. The original 
0 '+' &WP(& p), 0 3R attribute is passed through to the npr. 
stmt list IN COP unary LB expr Shift RB. 0 '+' &WP(&_p), 0 3R 
stmt list IN COP unary LB expr RB Reduce by unary--?unaryLB expr RB. Code is generated to compute the 
0 '+' &WP(& _p), 0 3R 0 address of the fourth cell, using the offset in the value at $3 and the base 
address in the value at $1: 
CODE: WP (T (1)) = WP(& _p); 
CODE: WP(T(1)) += 6; 
You have to generate a physical lvalue because p itself may not be incre-
mented. The synthesized attribute is an lvalue that holds the address of 
the fourth element. 
stmt list IN COP unary Reduce by unary--7lNCOP unary. Code is generated to increment the 
0 '+' WP (T (1) )1 array element, the address of which is in the I value generated in the pre vi-
ous reduction. 
CODE: *WP(T(1)) += 1; 
CODE: W(T(2)) = *WP(T(1)); 
The synthesized attribute is an rvalue that duplicates the contents of that 
cell. 
stmt list unary 
0 W(T (2)) R 
tinker( (tailor, cowboy), sailor ) ; 
This function call has two arguments, the first one is the expression 
(tailor, cowboy), which evaluates to cowboy. The second argument is sailor. 
The associated attribute is a value for that expression-an !value is used if the expres­
sion is a simple variable or pointer reference; an rvalue is used for most other expres­
sions. 
The args productions just traverse the list of arguments, printing the push instruc­
tions and keeping track of the number of arguments pushed. The argument count is 
returned back up the tree as the synthesized attribute. Note that the args productions 
form a right-recursive list. Right recursion is generally not a great idea in a bottom-up 
parser because all of the list elements pile up on the stack before any reductions occur. 
On the other hand, the list elements are processed in right to left order, which is con­
venient here because arguments have to be pushed from right to left. The recursion 
shouldn't cause problems unless the subroutine has an abnormally high number of argu­
ments. 
The call () subroutine at the top of Listing 6.87 generates both the call instruction 
and the code that handles return values and stack clean up. It also takes care of implicit 
subroutine declarations on lines 513 to 526. The action in unary~NAME creates a sym­
bol of type int for an undeclared identifier, and this symbol eventually ends up here as args --? ... productions. 
Right recursion gets ar­
guments pushed in 
correct order. 
call() 
unary--?NAME 
614 Code Generation -Chapter 6 
the incoming attribute. The call () subroutine changes the type to "function returning 
int'' by adding another link to the head of the type chain. It also clears the implicit 
bit to indicate that the symbol is a legal implicit declaration rather than an undeclared 
variable. Finally, a C-code extern statement is generated for the function. 
Listing 6.85. op.c-Structure Access 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 value *do struct ( val, op, field name ) -value *val; 
int 
char op; 
*field 
value 
symbol 
link -name; 
*new; 
*field; 
*lp; /* or -(the last is for ->) */ 
/* Structure names generate rvalues of type structure. The associated */ 
/* name evaluates to the structure's address, however. Pointers generate */ 
/* lvalues, but are otherwise the same. */ 
if( IS_POINTER(val->type) 
{ 
if ( op ! = ' -' ) 
{ 
yyerror("Object to left of-> must be a pointer\n"); 
return val; 
} 
lp = val->type; 
val->type = val->type->next; 
discard_link( lp ); 
if( !IS_STRUCT(val->type) ) 
{ 
yyerror("Not a structure.\n"); 
return val; /* Remove POINTER declarator from */ 
/* the type chain and discard it. */ 
/* Look up the field in the structure table: */ 
if( ! (field= find_field(val->type->V_STRUCT, field_name)) 
{ 
if( 
if( 
if( 
lp yyerror("%s not a field\n", field name); 
return val; 
val->lvalue II !val->is _tmp ) /* 
val = tmp_gen( val->type, val ) ; /* 
/* 
field-> level > 0 ) /* 
gen ( "+=%s%d", val->name, field-> level ) ; 
!IS_AGGREGATE(field->type) /* 
val->lvalue = 1; /* 
/* 
/* /* 
val->type; Generate temporary for 
base address if necessary; 
then add the offset to the 
desired field. 
If referenced object isn't 
an aggregate, use lvalue. 
Replace value's type chain 
with type chain for the 
referenced object: *I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
*I 
Section 6.8.4-Unary Operators 615 
Listing 6.85. continued ... 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 438 
439 
440 
441 
442 
443 
444 
445 
446 
447 448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 
466 
467 
468 
469 
470 
471 
472 
473 
474 
475 
476 
477 478 
479 
480 
481 
482 if( ! (val->type = clone_type( field->type, &val->etype)) 
{ 
yyerror("INTERNAL do struct: Bad type chain\n" ); 
exit(l); 
discard link_chain( lp ); 
access_with( val ) ; 
return val; /* Change the value's name */ 
/* field to access an object */ 
/* of the new type. */ 
/*----------------------------------------------------------------------*/ 
PRIVATE symbol *find_field( s, field name 
structdef *s; 
char *field_name; 
{ 
/* Search for "field name" in the linked list of fields for the input 
* structdef. Return a pointer to the associated "symbol" if the field 
* is there, otherwise return NULL. 
*I 
symbol 
for( sym 
{ *sym; 
s->fields; sym; sym = sym->next 
if( !strcmp(field_name, sym->name) ) 
return sym; 
return NULL; 
/*----------------------------------------------------------------------*/ 
PRIVATE char *access_with( val ) 
value *val; 
/* Modifies the name string in val so that it references the current type. 
* Returns a pointer to the modified string. Only the type part of the 
* name is changed. For example, if the input name is "WP (fp+4) ", and the 
*type chain is for an int, the name is be changed to "W(fp+4). If val is 
* an lvalue, prefix an ampersand to the name as well. 
*I 
char *p, buf[ VALNAME_MAX 
strcpy( buf, val->name ); 
for( p = buf; *p && *p != '(' /*)*/ ++p ) /* find name */ 
if( ! *p 
yyerror( "INTERNAL, access with: missing parenthesis\n" ); 
else 
sprintf( val->name, "%s%s%s", val->lvalue ? "&" : "", 
get_prefix(val->type), p); 
return val->name; 
616 Code Generation -Chapter 6 
Listing 6.86. c.y-Unary Operators (Part 8)-Function Calls 
669 
670 
671 
672 
673 
674 
675 
676 
677 
678 
679 
680 
681 
682 I* unop: *I 
I unary LP args RP 
I unary LP RP $$ 
$$ 
args non_comma_expr %prec COMMA 
non_comma_expr COMMA args call $1, $3 ) ; 
call $1, 0 ); 
gen ( "push", rvalue ( $1 ) ) ; 
release_value( $1 ); 
$$ = 1; 
gen ( "push", rvalue ( $1 ) ) ; 
release_value( $1 ); 
$$ = $3 + 1; 
Listing 6.87. op.c-Function-Call Processing 
483 
484 
485 
486 
487 
488 
489 
490 
491 
492 
493 
494 
495 
496 
497 
498 
499 
500 
501 
502 
503 
504 
505 
506 
507 508 
509 
510 
511 
512 
513 
514 
515 
516 
517 
518 
519 
520 
521 
522 PUBLIC value *call( val, nargs 
value *val; 
int nargs; 
link *1p; 
value *synth; I* synthesized attribute 
I* The incoming attribute is an lvalue for a function if 
* funct () 
* or 
* 
* 
* int (*p) () 
(*p) (); funct; *I 
* is processed. It's a pointer to a function if p() is used directly. 
* In the case of a logical lvalue (with a leading&), the name will be a 
* function name, and the rvalue can be generated in the normal way by 
* removing the &. In the case of a physical lvalue the name of a variable 
* that holds the function's address is given. No star may be added. 
* If val is an rvalue, then it will never have a leading &. 
*I 
if( val->sym && val->sym->implicit && !IS_FUNCT(val->type) ) 
{ 
I* Implicit symbols are not declared. This must be an implicit function 
* declaration, so pretend that it's explicit. You have to modify both 
* the value structure and the original symbol because the type in the 
* value structure is a copy of the original. Once the modification is 
* made, the implicit bit can be turned off. 
*I 
lp 
lp->DCL_TYPE 
lp->next 
val->type 
lp 
lp->DCL_TYPE 
lp->next 
val->sym->type new_link(); 
FUNCTION; 
val->type; 
lp; 
new link(); 
FUNCTION; 
val->sym->type; 
lp; 
.... 
Section 6.8.4-Unary Operators 
Listing 6.87. continued ... 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 
533 
534 
535 
536 
537 
538 
539 
540 
541 
542 
543 
544 
545 
546 
547 
548 
549 
550 
551 
552 
553 
554 
555 
556 
557 
558 
559 
560 
561 
562 
563 
564 
565 
566 
567 
568 
569 
570 val->sym->implicit 0; 
val->sym->level 0; 
yydata( "extern\t%s();\n", val->sym->rname ); 
if( !IS_FUNCT(val->type) ) 
{ 
else yyerror( "%s not a function\n", val->name ); 
synth = val; 
lp 
synth val->type->next; 
tmp_create( lp, 0); /* return-value type */ 
gen( 
gen( "call", 
"-" -, 
if( nargs ) *val->name == '&' ? &val->name[l] 
synth->name, ret_reg(lp) ) ; 
gen( "+=%s%d" , "sp", nargs ); 
release_value( val); 
return synth; val->name ); 
/*----------------------------------------------------------------------*! 
char 
link 
{ *ret_reg( p ) 
*p; 
/* Return a string representing the register used for a return value of 
* the given type. 
*I 
if( IS_DECLARATOR( p 
return "rF .pp"; 
else 
switch( p->NOUN 
{ 
case INT: 
case CHAR: 
default: ) ) 
return (p->LONG) ? "rF.l" : "rF.w.low" ; 
return "rF.w.low" ; 
yyerror("INTERNAL ERROR: ret_reg, bad noun\n"); 
return "A.AAAAAAAAAAAAAGH!"; 
6.8.5 Binary Operators 
We can now breathe a collective sigh of relief. The declaration system and the unary 
operators are the hardest parts of the compiler and they're over with. We can now move 
on to the binary operators. Again, it's useful to look at the overall structure of the 
binary-operator productions before proceeding. These are summarized in Table 6.24. 617 
618 Code Generation -Chapter 6 
Table 6.24. Summary of Binary-Operator Productions 
expr : expr COMMA non_ comma _expr 
I non comma expr 
non_ comma_ expr ~ non_ comma_ expr ASSIGNOP non _comma_ expr 
I non_ comma _expr EQUAL non_ comma _expr 
I non_comma _expr QUEST non _comma _expr COLON non_comma_expr 
I or expr 
or_expr ~ or list 
or-list or list ~ OROR and_expr 
I and expr 
and_expr ~ and list 
and list and list ~ AND AND binary 
binary I binary 
~ binary PLUS binary 
I binary MINUS binary 
I binary STAR binary 
I binary DIVOP binary 
I binary SHIFTOP binary 
I binary AND binary 
I binary XOR binary 
I binary OR binary 
I binary RELOP binary 
I binary EQUOP binary 
I unary 
This grouping of the productions is a compromise between the strict grammatical 
approach in which the grammar alone determines precedence and associativity-all 
operators that share a precedence level are isolated into single productions-and the 
more flexible yacc/occs approach in which all binary operators are combined into a sin­
gle production with many right-hand sides, associativity and precedence controlled by 
%left and %right directives. As you can see, the yacc approach has been used for 
most of the operators by putting them under the aegis of a single binary production. The 
%left and %right directives that control the precedence and associativity of these 
operators were discussed back towards the beginning of the current chapter. They're 
also at the top of Appendix C if you want to review them. 
Several of the lower-precedence operators have been isolated from the rest of the 
binary operators for grammatical and code-generation reasons, however. The first issue 
is the non_comma_expr which recognizes all expressions except those that use the 
comma operator at the outermost parenthesis-nesting level. The following statement is 
not recognized by a non_comma_expr: 
a = foo (), bar (); 
but this one is okay: 
(a = foo (), bar()) ; 
Isolating the comma 
operator. Problems with 
comma-delimited lists. because of the parenthesis. (Neither expression is a model of good programming style, 
but the language accepts them.) An expr accepts the comma operator at the outer level; 
both of the foregoing expressions are recognized. This isolation is required for gram­
matical reasons. Comma delimited lists of expressions are used in several places (for 
subroutine-argument lists, initializer lists, and so on). If an unparenthesised comma 
operator were permitted in any of these comma-delimited lists, the parser would not be 
able to distinguish between a comma that separated list elements and the comma opera­
tor. The practical consequence would be reduce/reduce conflicts all over the place. Iso­
lating the comma operator lets you use a non_comma_expr in all of the comma-
Section 6.8.5-Binary Operators 619 
delimited lists and an expr everywhere else. 
The expr production, which handles the comma operator, is at the top of Listing 6.88. The comma operator. 
The imbedded action releases the value structure associated with the left element of the 
expression; the value for the right element is used as the synthesized attribute. The 
imbedded action is necessary to prevent the compiler from wasting a temporary variable. 
If $1 was released at the far right of the production, then both components of the list 
would be evaluated before the left one was discarded. (Run a parse of ++a, ++b by hand 
if you don't believe me.) Consequently, the temporary that holds the evaluated result of 
the expr would continue to exist while the non_comma_expr was being evaluated. Since 
the left term is going to be discarded anyway, there's no point in keeping it around 
longer than necessary. 
Listing 6.88. c.y-Binary Operators: Comma, Conditional, and Assignment 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 expr expr COMMA {release_value($1) ;} non comma_expr { $$=$4; } 
non comma_expr 
non comma_expr 
non comma_expr QUEST 
non comma_expr COLON 
non_comma_expr static int label = 0; 
gen ( "EQ", 
gen( "goto%s%d", rvalue ( $1 ) , "0" ) ; 
L_COND_FALSE, 
$<num>$ =++label); 
release value( $1 ) ; 
$<p_val>$ $4->is_tmp 
? $4 
gen ( "goto%s%d", 
gen( ":%s%d", 
$$ = $<p_val>6; tmp_gen($4->type, $4) 
L_COND_END, $<num>3 ); 
L_COND_FALSE, $<num>3 ); 
if( !the same_type($$->type, $7->type, 1) ) 
yyerror("Types on two sides of colon "\ 
"must agree\n"); 
gen ( "=", $$->name, rvalue ($7) ) ; 
gen( ":%s%d", L_COND_END, $<num>3 ); 
release_value( $7 ); 
non_comma expr ASSIGNOP non_comma_expr {$$ 
non_comma_expr EQUAL non comma_expr {$$ assignment($2, $1, $3);} 
assignment( 0, $1, $3);} 
or_expr 
The non_ comma_ expr production, also in Listing 6.88, handles the conditional and 
assignment operators. A statement like this: 
int mickey, minnie; 
mickey= minnie ? pluto() : goofy() 
generates the code in Listing 6.89. The conditional operator 
(a?b:c). 
620 Code Generation -Chapter 6 
Listing 6.89. Code Generated for the Conditional Operator. 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 QFl: 
QEl: EQ( W(&_minnie), 0 ) 
goto QFl; 
call (_pluto); 
W( T(l) ) = rF.w.low; 
goto QEl; 
call (_goofy); 
W( T(2) ) rF.w.low; 
W( T (1) W( T (2) ) ; 
W(&_mickey) = W( T(l) ); /* if( minnie --0 ) *I 
/* branch around the first clause *I 
/* true part of the conditional: *I 
/* rvalue = subroutine return value *I 
/* false part of the conditional */ 
/* rvalue = subroutine return value */ 
/* final assignment */ 
The conditional is processed by the right-hand side on lines 688 to 712 of Listing 
6.88. The only tricky issue here is the extra assignment just above the QEl label in List­
ing 6.89. The problem, here, is inherent in the way a bottom-up parser works. It's very 
difficult for a bottom-up parser to tell the expression-processing code to put the result in 
a particular place; rather, the expression-processing code decides more or less arbitrarily 
where the final result of an expression evaluation will be found, and it passes that infor­
mation back up the parse tree to the higher-level code. The difficulty with the condi­
tional operator is the two action clauses (one for the true condition and a second for the 
false condition), both of which generate a temporary variable holding the result of the 
expression evaluation. Since the entire conditional must evaluate to only one temporary, 
code must be generated to copy the value returned from the false clause into the same 
temporary that was used for the true clause. 
None of this would be a problem with a top-down parser, which can tell the subrou­
tine that processes the action clause to put the final result in a particular place. For 
example, the high-level subroutine that processes the conditional in a recursive-descent 
parser can pass a value structure to the lower-level subroutines that generate the 
expression-processing code. These lower-level routines could then use that value for 
the final result of the expression-evaluation process. 
Assignment operators. The other two right -hand sides to non_ comma_ expr (on lines 714 and 715 of Listing 
6.89) handle the assignment operators. The assignment () function in Listing 6.90 
does all the work. The subroutine is passed three arguments: an operator (op) and 
values for the destination (dst) and source (src). The operator argument is zero for 
simple assignment, otherwise it's the first character of the lexeme: '+' for+=,'<' for 
<<=, and so on. This operator is, in tum, passed to gen () by adding it to the operator 
string on lines 588 and 589 of Listing 6.90. 
The destination argument must be an )value. If it's a physical )value, assign­
ment () tells gen () to add a star to the right of the destination name by adding an@ to 
the operator string on line 587 of Listing 6.90. The source operand is converted to an 
rvalue on line 593, then the assignment code is generated. 
Implicit type conversion. If the source and destination types don't match, an implicit type conversion must be 
performed as part of the assignment on line 616. The convert_ type () subroutine is 
the same one that was used for temporary-variable initialization. (It's in Listing 6.69 on 
page 590.) convert_ type ( ) generates code to copy the source variable into a register 
and do any necessary sign extension or zero fill. It returns a string that can be used to 
reference the required register. As an example of the type-conversion process, given the 
following declarations: 
Section 6.8.5-Binary Operators 
Listing 6.90. op.c-Assignment Operators 
571 
572 
573 
574 
575 
576 
577 
578 
579 
580 
581 
582 
583 
584 
585 
586 
587 
588 
589 
590 
591 
592 
593 
594 
595 
596 
597 
598 
599 
600 
601 
602 
603 
604 
605 
606 
607 
608 
609 
610 
611 
612 
613 
614 
615 
616 
617 
618 
619 620 
621 
622 623 
624 
625 
626 value *assignment( op1 dst 1 src ) 
int op; 
value *dst 1 *src; 
char 
char *src_name; 
op_str[8] 1 *p op_str 
value *val; 
if( !dst->lvalue yyerror "(=) !value required\n" ); 
gen_comment( "%s" 1 dst->sym->name ); if( !dst->is_tmp && dst->sym 
/*Assemble the operator string for gen(). A leading@ is translated by 
* gen() to a *at the far left of the output string. For example, 
* ("@=",x,y) is output as "*x = y". 
*I 
if( *dst->name != I &I *p++ I @1 
if( op *p++ op 
if( op --1<1 II op 1>1 *p++ op /* <<= or >>= */ 
/* do always *I *p++ '=' 
*p++ I \01 
src_name = rvalue( src ); 
if( IS_POINTER(dst->type) && IS_PTR_TYPE(src->type) 
{ 
else 
{ if( op ) 
yyerror("Illegal operation (%c= on two pointers) ;\n" 1 op); 
else if( !the_same_type( dst->type->next 1 src->type->next 1 0) 
yyerror("Illegal pointer assignment (type mismatch)\n"); 
else 
gen( "-" -I dst->name + (*dst->name==1&1 ? 1 0) 1 src name); 
/* If the destination type is larger than the source type, perform an 
* implicit cast (create a temporary of the correct type, otherwise 
* just copy into the destination. convert_type() releases the source 
* value. 
*I 
if( !the same_type( dst->type 1 src->type 1 1) ) 
{ 
else gen( op_str 1 dst->name + (*dst->name == 1&1 ? 1 : 0)1 
convert_type( dst->type 1 src) ); 
gen( op_str 1 dst->name + (*dst->name 
release_value( src ) ; I &I ? 1 0)1 src name); 
return dst; 621 
622 
int i, j, k 
long l ; 
char *p; 
simple input like i = j = k; generates the following output: 
W(& j) = W(&_k); 
W(&_i) = W(&_j); 
A more complex assignment like *p=l=i generates: 
rO. w.low = W(& i) ; /* convert i to 
ext word(rO); -L(& l) rO.l; /* assign to 1 
rO.l = L(& l) ; /* truncate 1 to 
*BP(& _p) = rO.b.bO; /* assign to *p long 
char Code Generation -Chapter 6 
*I 
*I 
*I 
*I 
The logical OR operator 
(I I). The next level of binary operators handles the logical OR operator-the productions 
and related workhorse functions are in Listings 6. 91, and 6. 92. 
Listing 6.91. c.y-Binary Operators: The Logical OR Operator and Auxiliary Stack 
% { 
#include <tools/stack.h> 
stk_err( o ) 
{ /* Stacks. The stack macros are all in */ 
/* <tools/stack.h>, included earlier */ 
/* Stack macros. (see Appendix A) *I 143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 yyerror( o? "Loop/switch nesting too deep or logical expr. too complex.\n" 
"INTERNAL, label stack underflow.\n" ); 
exit( 1 ); 
#undef stack err 
#define stack_err(o) stk err{o) 
stack del (S_andor, int, 32); /* This stack wouldn't be necessary if I were */ 
/* willing to put a structure onto the value */ 
/* stack--or list and and list must both */ 
/* return 2 attributes; this stack will hold */ 
/* one of them. */ 
%} 
719 or_expr 
720 
721 
722 
723 
724 or list 
725 
726 727 
728 
729 
730 
731 
732 or list 
or list OROR 
and_expr 
and_expr int label; 
if( label = pop( S_andor ) ) 
$$ = gen_false true( label, NULL); 
if ( $1 ) 
or( $1, stack_item(S_andor,O) 
or( $4, stack item(S_andor,O) ); 
$$ = NULL; 
push( Sandor, 0 ); tf_label ()); 
Section 6.8.5-Binary Operators 
Listing 6.92. op.c-The Logical OR operator 
void 
value 
int or( val, label ) 
*val; 
label; 
{ 
val gen_rvalue( val); 
gen "NE", val->name, "0" ) ; 
gen "goto%s%d", L_TRUE, label ); 
release_value( val ); 
1*----------------------------------------------------------------------*l 
value *gen_rvalue( val ) 
value *val; 
I* This function is like rvalue(), except that emits code to generate a 623 
627 
628 
629 
630 
631 
632 
633 
634 
635 
636 
637 
638 
639 
640 
641 
642 
643 
644 
645 
646 
647 648 
649 
650 
651 
652 
653 * physical rvalue from a physical lvalue (instead of just messing with the 
*name). It returns the 'value' structure for the new rvalue rather than a 
* string. 
*I 
if( !val->lvalue I I *(val->name) '&' ) 
rvalue( val); 
else 
val= tmp_gen( val->type, val); 
return val; I* rvalue or logical lvalue *I 
I* just change the name *I 
I* actually do indirection *I 
The only difficulty here is the requirement that run-time evaluation of expressions con­
taining logical OR operators must terminate as soon as truth can be determined. Looking 
at some generated output shows you what's going on. The expression i 1 1 j 1 1 k creates 
the following output: 
Fl: 
Tl: 
El: NE{W(&_i),O) 
goto Tl; 
NE(W(& j),O) 
goto Tl; 
NE (W ( & _ k) , 0) 
goto Tl; 
W( T(l) ) 0; 
goto El; 
W( T(l) ) = 1; 
The productions treat expressions involving 1 1 operators as an OR-operator-delimited 
list of subexpressions. The code that handles the individual list elements is on lines 724 
to 730 of Listing 6.91. It uses the or () subroutine in Listing 6.92 to emit a test/branch 
instruction of the form: 
NE(W(&_i) ,0) 
goto Tl; 
The code following the Fl label is emitted on line 721 of Listing 6.91 after all the list 
elements have been processed. 
624 Code Generation -Chapter 6 
The main implementation-related difficulty is that the or _list productions really want 
to return two attributes: the value that represents the operand and the numeric com­
ponent of the label used as the target of the output goto statement. You could do this, of 
course, by adding a two-element structure to the value-stack union, but I was reluctant to 
make the value stack wider than necessary because the parser would slow down as a 
consequence-it would have to copy twice as much stuff on every parse cycle. I solved 
the problem by introducing an auxiliary stack (S andor), declared in the occs declara­
tion section with the code on lines 146 to 163 of Listing 6. 91. This extra stack holds the 
numeric component of the target label. 
The best way to see what's going on is to follow the parse of i I I j I I k in Table 6.25. 
You should read the comments in that table now, looking at the source code where 
necessary to see what's going on. 
Table 6.25. A Parse of i I I j I I k; 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D 
stmt list 
D Parse Stack 
NAME 
i 
unary 
W(&_i), 
binary 
W(&_i), 
and list 
W(&_i), 
and_expr 
W(&_i), 
or list 
W(&_i), 
or list OROR 
W(&_i)1 D 
or list OROR 
W(&_i), D 
or list OROR 
W(&_i), D 
or list OROR 
W(&_i), D 
or_list OROR 
W(&_i), D S andor 
0 
0 
{128} I D 
{128} NAME I D j 
{128} unary I D W(&_j), 
{128} binary I D W(&_j), Comments 
Shift NAME. The shifted attribute is a pointer to the symbol that 
represents i. 
Reduce by unary-'> NAME. 
Reduce by binary---'>unary. 
Reduce by and _list---'>binary. 
Reduce by and_ expr---'>and _list. 
Reduce by or list---'>and list. This is the first reduction in the list, 
so push 0 onto the s ;ndor stack. Note that, since this is the 
leftmost list element, tiie default $$=$1 is permitted to happen in 
order to tell the next reduction in the series what to do. 
Shift OR OR. 
Reduce by the imbedded production in or list---'>or list { ) 
and_expr. This is the first expression in the liSt-the compiler 
knows that it's first because $1 isn't NULL. Call tf label () to 
get the numeric component of the target label, and then replace 
the 0 at the top of the the s andor stack with the the label 
number. This replacement tells the or_expr---'>or_/ist production 
that an 1 1 has actually been processed-a reduction by 
or_ expr---'>or _list occurs in every expression, even those that don't 
involve logical OR's. You can emit code only when the expres­
sion had an 1 1 operator in it, however. The S andor stack is 
empty if there wasn't one. The compiler emits the following 
code: 
CODE: 
CODE: NE(W(& i),O) 
goto Tl; 
Shift NAME. The shifted attribute is a pointer to the symbol that 
represents j. 
Reduce by unary---'>NAME. The synthesized attribute is an !value 
for j. 
Reduce by binary---'>unary. 
Reduce by and _list---'>binary. 
continued ... 
The logical AND operator 
(&&) The code to handle the logical AND operator ( & & ) is almost identical to that for the 
OR operator. It's shown in Listings 6.93 and 6.94. The expression i & & j & & k generates 
the following output: 
Section 6.8.5-Binary Operators 625 
Table 6.25. Continued. A Parse of i I 1 j I I k; 
Parse Stack s andor Comments 
stmt_list or_list OROR {128} and_list I Reduce by and_expr~and_list. 0 W(&_i)L 0 0 W (& _j) L 
stmt_list or_list' OROR {128} and_expr Reduce by or _list~or _list OROR { 128} and_expr. Emit code 
0 W(&_i)L 0 0 W (&_j) L to handle the second list element: 
CODE: NE(W(&_j),O) 
I CODE: qoto Tl; 
The numeric component of the label is at the top of the S _ andor 
stack, and is examined with a stack item() call. The post-
reduction attribute attached to the or list is NULL. 
stmt list or list I ShiftOROR. 0 NULL 
stmt list or list OROR I Reduce by imbedded production in or_list~or_list {} and_expr. 
0 NULL 0 0 This time, the attribute for $1 is NULL, so no code is generated. 
stmt_list or _list OROR {128} I Shift NAME. The shifted attribute is a pointer to the symbol that 
0 NULL 0 0 represents k. 
stmt_list or list OROR {128} NAME I Reduce by unary~NAME. The synthesized attribute is an !value 
0 NULL 0 0 k fork. 
stmt_list or list OROR {128} unary I Reduce by binary~unary. 0 NULL 0 0 W(&_k)L 
stmt list or_list OROR {128} binary I Reduce by and_list~binary. 0 NULL 0 0 W(&_k)L 
stmt_list or_list OROR {128} and list I Reduce by and_expr~and_list. 0 NULL 0 0 W(&_k)L 
stmt_list or list OROR {128} and_expr Reduce by or list~or list OROR { 128} and expr. Emit code 
0 NULL 0 0 W(&_k)L to process the-third list element. The numeric component of the 
I label is at the top of the s _ andor stack. 
CODE: NE(W(&_k),O) 
CODE: qoto Tl; 
The synthesized attribute is also NULL, there. 
stmt list or_list Reduce by or _expr~or _list. The numeric component of the 
0 NULL label is popped off the S_andor stack. If it's zero, then no II 
operators were processed. It's 1, however, so emit the targets for 
all the goto branches generated by the previous list elements. 
CODE: Fl: 
I CODE: W( T (1) ) = 0; 
CODE: qoto El; 
CODE: Tl: 
CODE: W( T (1) ) = 1; 
CODE: El: 
The synthesized attribute is an rvalue for the temporary that holds 
the result of the OR operation. 
stmt_list or_expr 
0 W(T(l) I. 
EQ(W(& i), 0) I* i && j && k */ 
goto F1; 
EQ(W(&_j),O) 
goto F1; 
EQ(W(&_k),O) 
goto F1; 
goto T1: 
F1: 
W( T(1) ) 0; 
goto E1; 
T1: 
W( T (1) ) 1; 
E1: 
626 Code Generation -Chapter 6 
Since the run-time processing has to terminate as soon as a false expression is found, the 
test instruction is now an EQ rather than an NE, and the target is the false label rather than 
the true one. The same s _ andor stack is used both for the AND and OR operators. The 
goto Tl just above the Fl label is needed to prevent the last list element from falling 
through to the false assignment. Note that the logical AND and OR operators nest 
correctly. The expression 
(i I I j && k I I 1) 
generates the output in Listing 6.95 (&&is higher precedence than I 1 ). A blow-by-blow 
analysis of the parse of the previous expression is left as an exercise. 
Listing 6.93. c.y-Binary Operators: The Logical AND Operator 
733 and_expr: and list 
734 
735 
736 
737 
738 
739 
740 
741 and list: and list ANDAND 
742 
743 
744 binary 
745 
746 
747 binary 
748 
749 
Listing 6.94. op.c-The Logical AND Operator 
654 void and( val, label ) 
655 value *val; 
656 int label; 
657 
658 val gen_ rvalue( val ) ; 
659 
660 gen "EQ", val->name, 
661 gen "goto%s%d", L_FALSE, 
662 release_value( val ) ; 
663 int label; 
if( label = pop( S_andor ) ) 
( 
gen( "goto%s%d", L_TRUE, label); 
$$ = gen_false_true( label, NULL); 
if ( $1 ) 
and($1, stack_item(S_andor,O) 
and( $4, stack_item(S_andor,O) ) ; 
$$ = NULL; 
push( S_andor, 0 ); 
"0" ) ; 
label ) ; tf_label ()); 
Relational operators. The remainder of the binary operators are handled by the binary productions, the first 
two right-hand sides of which are in Listing 6.96. The productions handle the relational 
operators, with the work done by the relop () subroutine in Listing 6.97. The EQUOP 
token matches either== or ! =. A RELOP matches any of the following lexemes: 
<= >= < > 
A single token can't be used for all six Iexemes because the EQUOPs are higher pre­
cedence than the RELOPs. The associated, integer attributes are assigned as follows: 
Section 6.8.5 -Binary Operators 
Listing 6.95. Output for ( i I I j & & k I 11) 
I 
2 
3 
4 
5 
6 
7 F2: 
8 
9 
10 T2: 
II 
12 E2: 
13 
14 
15 
16 
17 F1: 
18 
19 
20 T1: 
21 
22 E1: 
Token 
EQUOP 
EQUOP 
RELOP' 
RELOP 
RELOP RELOP NE(W(&_i),O) 
goto T1; 
EQ (W ( & j) , 0) 
goto F2; 
EQ(W(&_k),O) 
goto F2; 
W( T(1) ) 0; 
goto E2; 
W( T(1) ) = 1; 
NE (W ( T ( 1) ) , 0) 
goto T1; 
NE(W(&_l),O) 
goto T1; 
W( T(1) ) 0; 
goto E1; 
W( T(1) ) 1; 
Lexeme Attribute 
-- I=' 
!= f I f 
> '>' 
< '<' 
>= 'G' 
<= 'L' 
The relop () subroutine at the top of Listing 6.97 does all the work. It's passed the relop 0 
operator's attribute and the two operands; i < j generates the following code: 
LT( W(& i), W(& j) /* compare i and j. */ 
goto T1; I* Jump to true case on success; *I 
F1: /* otherwise, fall through to false.*/ 
W( T (1) 0; 
goto E1; 
T1: 
W( T (1) ) = 1; 
E1: 
The comparison directive on the first line (LT) changes with the incoming operand: LT 
for<, GT for>, EQ for==, and so on. relop () generates the code in several steps. Both 
operands are converted to rvalues by the gen_rvalue () calls on lines 673 and 674 of 627 
Listing 6.96. The make_types_match call on the next line applies the standard C make_types_match() 
type-conversion rules to the two operands, generating code to promote the smaller of the 
two variables to the type of the larger one. The subroutine starts on line 712 of Listing 
6.96. It's passed pointers to the two values, and it might modify those values because 
the conversion might create another, larger temporary. Normally, make_ types_ match 
returns 1. It returns 0 if it can't do the conversion, as is the case when one operand is an 
int and the other a pointer. 
628 Code Generation -Chapter 6 
The switch on line 680 of Listing 6.96 translates the incoming attribute to an argu­
ment passed to the gen () call that generates the test on line 693. The goto is generated 
on the next line, and the numeric component of the target label is fetched from 
t f _ 1 abe 1 ( ) at the same time. The code on lines 696 to 70 I is doing a minor optimiza­
tion. If the value passed into gen_false_true () is already a temporary of type 
int, then a second temporary is not created. If the original vl isn't an int temporary, 
the code on lines 696 to 701 swaps the two values in the hope that v2 is a temporary. 
Listing 6.96. c.y-Binary Operators: Relational Operators 
750 binary 
751 
752 binary RELOP 
binary EQUOP 
Listing 6.97. op.c-Relational Operators 
value *relop ( vl, 
value *vl; 
int op; 
value *v2; 
char *str_op 
value *tmp; 
int label; op, v2 
vl gen_rvalue( vl ); 
v2 gen_rvalue( v2 ); binary 
binary 
if( !make_types_match( &vl, &v2 ) ) $$ 
$$ relop ( $1, $2, 
relop ( $1, $2, 
yyerror( "Illegal comparison of dissimilar types\n" ) ; 
else 
{ 
switch( op ) 
{ 
case '>': /* 
case '<': /* 
case 'G': /* 
case 'L': /* 
case , ! ': /* 
case '=': /* 
default: > 
< 
>= 
<= 
!= *I str _op "GT"; break; 
*I str _op "LT"; break; 
*I str _op "GE"; break; 
*I str _op "LE"; break; 
*I str _op "NE"; break; 
*I str _op "EQ"; break; $3 ) ; 
$3 ) ; 
664 
665 
666 
667 
668 
669 
670 
671 
672 
673 
674 
675 
676 
677 
678 
679 
680 
681 
682 
683 
684 
685 
686 
687 
688 
689 
690 
691 
692 
693 
694 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 yyerror("INTERNAL, relop(): Bad request: %c\n", op ); 
goto abort; 
gen 
gen str_op, 
"goto%s%d", vl->name, v2->name 
L_TRUE, label= tf label() 
if( ! (vl->is_tmp && IS_INT( vl->type )) 
{ ) ; 
) ; 
tmp vl; 
v2; 
tmp; /* try to make vl an int temporary */ 
vl 
v2 
vl gen_false_true( label, vl ); 
Section 6.8.5-Binary Operators 629 
Listing 6.97. continued ... 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 
719 
720 
721 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 
733 
734 
735 
736 
737 738 
739 
740 
741 
742 
743 
744 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 
757 758 
759 
760 
761 abort: 
release_value( v2 ) ; 
return v1; /* discard the other value */ 
/*----------------------------------------------------------------------*/ 
PRIVATE int make_types_match( v1p, v2p ) 
value **v1p, **v2p; 
{ 
I /* Takes care of type conversion. If the types are the same, do nothing; 
* otherwise, apply the standard type-conversion rules to the smaller 
* of the two operands. Return 1 on success or if the objects started out 
* the same type. Return 0 (and don't do any conversions) if either operand 
* is a pointer and the operands aren't the same type. 
*I 
value *v1 *v1p; 
value *v2 *v2p; 
link *t1 v1->type; 
link *t2 v2->type; 
if( the_same_type(t1, t2, 0) && !IS_CHAR(t1) 
return 1; 
if( IS_POINTER(t1) II IS_POINTER(t2) 
return 0; 
if( IS_CHAR(t1) 
if ( IS_CHAR (t2) v1 
v2 tmp_gen(t1, v1); t1 
tmp_gen(t2, v2); t2 
if( IS ULONG(t1) && !IS_ULONG(t2) 
{ 
if( IS_LONG(t2) 
v2->type->UNSIGNED 1; 
else 
v2 = tmp_gen( t1, v2 ); 
else if( !IS_ULONG(t1) && IS_ULONG(t2) 
{ 
if( IS_LONG(t1) ) 
v1->type->UNSIGNED = 1; 
else 
v1 = tmp_gen( v2->type, v1 ); v1->type; 
v2->type; 
else if( 
else if( 
else if( 
else if( IS_LONG(t1) 
! IS_LONG (t1) 
IS_UINT (t1) 
!IS_UINT(t1) && ! IS_LONG (t2) 
&& IS_LONG (t2) 
&& !IS_UINT(t2) 
&t. IS_UINT(t2) v2 = tmp_gen (t1, v2); 
v1 = tmp_gen (t2, v1); 
v2->type->UNSIGNED 1; 
v1->type->UNSIGNED = 1; 
/* else they're both normal ints, do nothing */ 
*v1p = v1; 
*v2p = v2; 
return 1; 
630 Code Generation -Chapter 6 
All other operators, 
binary_ op () Most other binary operators are covered by the productions and code in Listings 6.98 
and 6.99. Everything is covered but addition and subtraction, which require special han­
dling because they can accept pointer operands. All the work is done in binary_ op (), 
at the top of Listing 6.99. The routine is passed values for the two operands and an 
int that represents the operator. It generates the code that does the required operation, 
and returns a value that references the run-time result of the operation. This returned 
value is usually the incoming first argument, but it might not be if neither incoming 
value is a temporary. In addition, one or both of the incoming values is released. 
Listing 6.98. c.y-Binary Operators: Other Arithmetic Operators 
753 /* binary: *I 
754 I binary STAR binary { $$ = binary_op( $1, 
755 I binary DIVOP binary { $$ = binary_op( $1, 
756 I binary SHIFTOP binary { $$ = binary_op( $1, 
757 I binary AND binary { $$ = binary_op( $1, 
758 I binary XOR binary { $$ = binary_op( $1, 
759 I binary OR binary { $$ = binary_op( $1, 
Listing 6.99. op.c-Other Arithmetic Operators 
value *binary_op( vl, op, v2 ) 
value *vl; 
int op; 
value *v2; 
char *str _op ; 
int commutative = 0; /* operator is commutative */ 
if( do_binary_const( &vl, op, &v2 ) ) 
{ 
release_value( v2 ); 
return vl; 
vl gen_rvalue( vl ); 
v2 gen_rvalue( v2 ); 
if( !make types match( &vl, &v2 ) ) 
yyerror("%c%c: Illegal type conversion\n", , *, , $3 ) ; 
$2, $3 ) ; 
$2, $3 ) ; 
, & , , $3 ) ; , -, $3 ) ; , 
, I , , $3 ) ; 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
779 
780 
781 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 (op==' >' I I op ==' <') ? op 
else 
switch( op 
{ 
case I *I ! 
case I & I ! 
case , I,: 
case , ..... , . 
case , I, : 
case I %I ! 
case , <' : 
case I>' : commutative 1; 
dst_opt( &vl, &v2, commutative ); /* << */ 
/* >> */ } 
} 
} 
} 
} 
} 
op); 
.... 
Section 6.8.5-Binary Operators 
Listing 6.99. continued ... 
796 if ( op == 1 <1 ) 
797 
798 
799 
800 
801 
802 
803 
804 
805 
806 
807 
808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 
827 
828 
829 
830 
831 
832 
833 
834 
835 
836 
837 838 
839 
840 
841 
842 
843 
844 
845 
846 
847 
848 
849 
850 
851 
852 
853 
854 
855 str_op = "<<=" 
else if( op == 1>1 
str_op IS_UNSIGNED(vl->type) ? ">L=" 
else 
{ 
str_op = "X="; 
*str_op = op ; 
gen( str op1 vl->name 1 v2->name ); 
break; 
release_value( v2 ); 
return vl; ">>=" 
1*----------------------------------------------------------------------*l 
PRIVATE int do_binary_const( vlp1 op1 v2p ) 
value **vlp; 
int op; 
value **v2p; 
I* If both operands are constants, do the arithmetic. On exit, *vlp 
* is modified to point at the longer of the two incoming types 
* and the result will be in the last link of *vlp's type chain. 
*I 
long 
link 
link 
value x; 
*tl 
*t2 
*tmp; (*vlp) ->type 
(*v2p) ->type 
I* Note that this code assumes that all fields in the union start at the 
* same address. 
*I 
if( IS_CONSTANT(tl) && IS_CONSTANT(t2) 
{ 
if( IS INT(tl) -&& IS_INT (t2) 
{ 
switch( op 
{ 
case , +': tl->V INT += t2->V 
case , _,: tl->V INT t2->V 
case I*'! tl->V INT *= t2->V 
case I &I: tl->V INT &= t2->V 
case I I I: tl->V INT I= t2->V 
case I ""I • tl->V INT A t2->V 
case I II: tl->V INT I= t2->V 
case I %1: tl->V INT %= t2->V 
case '<': tl->V INT <<= t2->V 
case '>': if( IS_UNSIGNED(tl) 
else 
break; 
return 1; INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
tl->V UINT >>= t2->V_INT; 
tl->V INT >>= t2->V_INT; 631 
.... 
632 Code Generation -Chapter 6 
Listing 6.99. continued ... 
856 
857 
858 
859 
860 
861 
862 863 
864 
865 
866 
867 
868 
869 
870 
871 
872 
873 
874 
875 
876 
877 
878 
879 
880 
881 
882 
883 
884 
885 
886 
887 
888 
889 
890 
891 
892 
893 
894 
895 
896 
897 
898 
899 
900 
901 
902 
903 
904 
905 
906 
907 
908 
909 
910 
911 
912 
913 
914 else if( IS LONG (t1) && IS LONG(t2) - -
{ 
switch( op 
{ 
case , +': t1->V LONG += t2->V LONG; break; -case , -' : t1->V LONG -t2->V LONG; break; 
case I *I • t1->V LONG *= t2->V LONG; break; 
case I & I ! t1->V LONG &= t2->V LONG; break; 
case I I I : t1->V LONG I= t2->V LONG; break; 
case I "' I • t1->V LONG ~ t2->V LONG; break; 
case I I I : t1->V LONG I= t2->V LONG; break; 
case , %': t1->V LONG %= t2->V LONG; break; 
case I<' ! t1->V LONG <<= t2->V LONG; break; -
case 1 >1: if( IS UNSIGNED(t1) 
else t1->V ULONG >>= t2->V LONG; 
t1->V LONG >>= t2->V_LONG; 
break; 
return 1; 
else if( IS_LONG(t1) && IS INT(t2) 
{ 
switch( op 
{ 
case , +': 
case , -': 
case , *, : 
case , & , : 
case I I I : 
case , .... , . 
case I I I : 
case , %, : 
case '<': 
case , >': 
return 1; t1->V 
t1->V 
t1->V 
t1->V 
t1->V 
t1->V 
t1->V 
t1->V 
t1->V 
if( IS 
else 
break; LONG += t2->V 
LONG -t2->V 
LONG *= t2->V 
LONG &= t2->V 
LONG I= t2->V 
LONG ~ t2->V 
LONG I= t2->V 
LONG %= t2->V 
LONG <<= t2->V 
UNSIGNED(t1) -
else if( IS_INT(t1) && IS LONG(t2) ) 
{ INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
INT; break; 
t1->V ULONG >>= t2->V INT; 
t1->V LONG >>= t2->V INT; 
I* Avoid commutativity problems by doing the arithmetic first, 
* then swapping the operand values. 
*I 
switch( op 
{ 
case I+' ! X = t1->V INT + t2->V LONG; 
case I _I • X = t1->V INT -t2->V LONG; 
case ' *, : X = t1->V INT * t2->V LONG; 
case , & , : X = t1->V INT & t2->V LONG; 
case I I I : X = t1->V INT I t2->V LONG; 
case ' .... , . X = t1->V INT ~ t2->V LONG; 
case I I I : X = t1->V INT I t2->V LONG; 
case , 9-1. 
0 • X = t1->V INT % t2->V LONG; 
case , <' : X = t1->V INT << t2->V LONG; 
Section 6.8.5-Binary Operators 
Listing 6.99. continued ... 
915 
916 
917 
918 
919 
920 
921 
922 
923 
924 
925 
926 
927 928 
929 
930 
931 
932 
933 
934 
935 
936 
937 
938 939 
940 
941 
942 
943 
944 
945 
946 
947 
948 
949 
950 
951 
952 
953 
954 
955 
956 
957 
958 
959 
960 
961 
962 case '>': if ( IS_UINT (tl) 
else 
break; x = tl->V UINT >> t2->V_LONG; 
x = tl->V INT >> t2->V_LONG; 
t2->V_LONG = x; /* Modify vl to point at the larger */ 
/* operand by swapping *vlp and *v2p. */ tmp *vlp 
*vlp = *v2p 
*v2p = tmp 
return 1; 
return 0; 
/*----------------------------------------------------------------------*/ 
PRIVATE void dst_opt( leftp, rightp, commutative ) 
value 
value **leftp; 
**rightp; 
/* Optimizes various sources and destination as follows: 
* * operation is not commutative: 
* if *left is a temporary: do nothing 
* 
* 
* 
* else: 
* operation is commutative: 
* if *left is a temporary 
* else if *right is a temporary 
* else 
*I create a temporary and 
initialize it to *left, 
freeing *left 
*left = new temporary 
do nothing 
swap *left and *right 
precede as if commutative. 
value *tmp; 
if( (*leftp)->is_tmp 
{ 
if( commutative && (*rightp)->is_tmp 
{ 
tmp 
*leftp 
*rightp 
else 
*leftp *leftp; 
*rightp; 
tmp; 
tmp_gen( (*leftp)->type, *leftp ); 
binary_ op () starts out by trying to perform a type of optimization called constant Constant folding. 
folding. If both of the incoming values represent constants, then the arithmetic is done 
internally at compile time rather than generating code. The result is put into the last 
link of whichever of the two incoming values was larger, and that value is also the 
synthesized attribute. The work is done by do_ binary_ constant () starting on line 
816 of Listing 6.99. An if clause is provided for each of the possible incoming types. 
Note that do_binary_constant () is passed pointers to the value pointers. The 
extra indirection is necessary because, if the left operand is larger than the right operand, 633 
634 Code Generation -Chapter 6 
the two values are swapped (after doing the arithmetic, of course). The code to do the 
swapping starts on line 920. 
If constant folding couldn't be performed, then binary_ op must generate some 
code. It starts out on lines 776 and 777 of Listing 6.99 by converting the incoming 
values to rvalues. It then does any necessary type conversions with the 
make_ types_ match () call on line 779. The switch on line 784 figures out if the 
operation is commutative, and the dst _opt () on line 794 juggles around the operands 
to make the code more efficient. 
dst_opt 0 dst opt () starts on line 931 of Listing 6.99. It is also passed two pointers to 
value pointers, and' it makes sure that the destination value is a temporary variable. If 
it's already a temporary, dst_opt () does nothing; otherwise, if the right operand is a 
temporary and the left one isn't, and if the operation is commutative, it swaps the two 
operands; otherwise, it generates a temporary to hold the result and copies the left 
operand into it. 
Returning to binary_ op (), the arithmetic instruction is finally generated on line 
806 of Listing 6.99. 
Addition and subtraction. The last of the binary operators are the addition and subtraction operators, handled 
by the productions and code in Listings 6.100 and 6.10 I. The only real difference 
between the action here and the action for the operators we just looked at is that pointers 
are legal here. It's legal to subtract two pointers, subtract an integer from a pointer, or 
add an integer to a pointer. The extra code that handles pointers is on lines 1019 to I 057 
of Listing 6.10 I. 
The final group of expression productions are in Listing 6.1 02. They are pretty much 
self -explanatory. 
Listing 6.100. c.y-Binary Operator Productions: Addition and Subtraction 
760 I* binary: *I 
761 I binary PLUS binary 
762 I binary MINUS binary 
763 I unary 
764 
Listing 6.101. op.c-Addition and Subtraction Processing 
963 
964 
965 
966 
967 
968 
969 
970 
971 
972 
973 
974 
975 
976 
977 
978 
979 value 
value 
int 
value *plus_minus( vl, op, v2 ) 
*vl; 
op; 
*v2; 
value *tmp; 
int vl_is_ptr; 
int v2_is_ptr; 
char *scratch; 
char *gen_op; 
gen_op 
vl 
v2 
v2_is_ptr 
vl_is_ptr (op == '+')? "+=" 
gen_rvalue( vl ) ; 
gen rvalue( v2 ); 
IS_POINTER(v2->type); 
IS __ POINTER (vl->type); "-="; $$ plus_minus( $1, '+', $3 ) ; 
$$ plus_minus( $1, I _I $3 ) ; 
.... 
Section 6.8.5-Binary Operators 
Listing 6.101. continued ... 
980 
981 
982 
983 
984 
985 
986 
987 
988 
989 
990 
991 
992 
993 
994 
995 
996 
997 
998 
999 I* First, get all the error checking out of the way and return if 
* an error is detected. 
*I 
if( vl_is_ptr && v2_is_ptr ) 
{ 
if( op == '+' 1 I !the_same_type(vl->type, v2->type, 1) ) 
{ 
yyerror( "Illegal types (%c)\n", op); 
release_value( v2 ) ; 
return vl; 
else if( !vl is_ptr && v2_is_ptr ) 
{ 
yyerror( "%c: left operand must be pointer", op ) ; 
release_value( vl ) ; 
return v2; 
I* Now do the work. At this point one of the following cases exist: 
* 
* vl: op: v2: 
* number [+-1 number 
* ptr [+-1 number 
* ptr ptr (types must match) 
*I 
if( ! (vl_is_ptr II v2_is_ptr) ) 
{ I* normal arithmetic *I 
else if( !do_binary_const( &vl, op, &v2 ) ) 
{ 
make_types_match( &vl, &v2 ) ; 
dst opt ( &vl, &v2, op == '+' ) ; 
gen( gen_op, vl->name, v2->name ); 
release_value( v2 ); 
return vl; 
if( vl is_ptr && v2 is_ptr 
{ 
if( !vl->is_tmp ) 
vl = tmp_gen( vl->type, vl ); 
gen( gen_op, vl->name, v2->name ); 
if( IS_AGGREGATE( vl->type->next ) I* ptr-ptr *I 
gen( "l=%s%d", vl->name, get_sizeof(vl->type->next) ) ; 
else if( !IS_AGGREGATE( vl->type->next ) ) 635 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 
1028 
1029 
1030 
1031 
1032 
1033 
1034 
1035 
1036 
1037 
1038 I* ptr_to_nonaggregate [+-1 number *I 
if( !vl->is_tmp ) 
vl = tmp_gen( vl->type, vl ); 
gen( gen_op, vl->name, v2->name ); 
.... 
636 Code Generation -Chapter 6 
Listing 6.101. continued ••• 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 else 
{ I* ptr_to_aggregate [+-] number *I 
I* do pointer arithmetic *I 
scratch = IS_LONG{v2->type) ? "rO.l" : "rO.w.low" ; 
gen( "=" , "r1.pp", 
gen( "=" , scratch, 
gen( "*=%s%d", scratch, 
gen( gen_op, "r1.pp", 
if( !v1->is_tmp ) 
{ v1->name 
v2->name 
get sizeof(v1->type->next) 
scratch 
tmp = tmp_create ( v1->type·, 0 ) ; 
release_value( v1 ); 
gen( v1 = tmp; 
"-" -, v1->name, "r1.pp" ); 
release_value( v2 ); 
return v1; ) ; 
) ; 
) ; 
) ; 
Listing 6.102. c.y-High-Level Expression Processing 
765 
766 
767 768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
779 
780 
781 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 opt_expr 
expr 
I* epsilon *I 
const_expr 
: expr release_value( $1 ); tmp_freeall(); } 
%prec COMMA 
$$ = -1 
if( !IS_CONSTANT( $1->type ) ) 
yyerror("Constant required."); 
else if( !IS_INT( $1->type ) ) 
yyerror("Constant expression must be int."); 
initializer expr else 
$$ = $1->type->V_INT 
release_value($1); 
tmp_freeall (); 
LC initializer list RC { $$ $2; } 
initializer list 
initializer 
initializer list COMMA initializer %prec COMMA 
.... 
Section 6.8.5-Binary Operators 
Listing 6.102. continued ... 
796 
797 
798 
799 
800 yyerror("Aggregate initializers are not supported\n"); 
release_value( $3 ); 
6.9 Statements and Control Flow 
The only part of the compiler we've yet to examine is the statement productions, dis­
cussed in this section. 
6.9.1 Simple Statements and if/else 
It's best to start by looking at some examples. Table 6.26 shows input and output for 
a few simple control-flow statements. Figure 6.20 shows a more complex example of 
nested if/else statements. (I've shown the complete compiler output in the Figure.) 637 
The productions and subroutines that generate this code are in Listings 6.103 and 
6.1 04. The stmt _list production at the top just assembles a list of zero or more state­
ments. There are no attributes. The simplest statement is defined on line 801 as a single 
semicolon. There is no action. A statement can also comprise a curly-brace-delimited 
compound statement (on line 811). Empty and compound 
statements. 
The next line defines a statement as an expression followed by a semicolon. The 
associated action frees the value holding the result of the expression evaluation and 
releases any temporary variables. Note that many expressions create unnecessary final 
values because there's no way for the parser to know whether or not an expression is part 
of a larger expression. For example, an assignment to a temporary is emitted as part of 
processing the the ++ operator in the statement: 
a++; 
but that temporary is never used. It is an easy matter for an optimizer to remove this 
extra assignment, which is, in any event, harmless. Expression statements. 
The two forms of return statement are handled on lines 814 and 816 of Listing return statements. 
6.103. The first is a simple return, with no value. The second takes care of the value by 
copying it into the required return-value register and then releasing the associated 
value and temporaries. Because returning from a subroutine involves stack-cleanup 
actions, a jump to a label immediately above the end-of-subroutine code is generated 
here rather than an explicit ret () instruction. The numeric part of the label is gen-
erated by r label () , in Listing 6.1 04. The end-of-subroutine code is generated during 
the reduction by 
ext_ def~opt _specifiers funct _dec! de!_ list compound _stmt 
(on line 563 of Listing 6.58, page 556) , which executes an r label ( 1) to increment the 
numeric part of the label for the next subroutine. 
638 Code Generation -Chapter 6 
Table 6.26. Simple Control-How: returngoto andif/else 
Input 
return; 
return i+j; 
foo: ; 
goto foo; 
if ( i < j ) 
++i; 
if( i < j ) 
++i; 
else 
++j; RETO: 
RETO: 
foo: 
TST1: 
F1: 
T1: 
E1: 
EXIT1: 
TST2: 
F2: 
T2: 
E2: 
EXIT2: 
EL2: Output 
goto RETO; /* Generated by return statement *I 
/* Generated by end-of-subroutine *I 
unlink(); 
ret(); /* code. */ 
W( T(l) ) = W(& i); /*compute i + j */ 
W( T(1) ) += W(&_j); 
rF.w.low = W( T(1) ); /*return value in register*/ 
goto RETO: 
/* Generated in end-of-subroutine processing */ 
unlink(); 
ret(); 
goto foo; 
LT(W(& i),W(&_j)) 
goto T1; 
W( T(1) ) = 0; 
goto E1; 
W( T(1) ) = 1; 
EQ(W( T(1) ),0) 
goto EXIT1; 
W(& i) += 1; 
W( T(1) ) = W(&_i); 
LT(W(& i) ,W(& -j)) 
goto T2; 
W( T (1) ) = 0; 
goto E2; 
W( T (1) ) = 1; 
EQ(W( T (1) ) , 0) 
go to EXIT2; 
W(& i) += 1; 
W( T (1) ) = W(& i); -goto EL2; 
W(& -j) += 1; 
W( T (1) ) = W(& -j) ; I* evaluate (i < j) and put */ 
/* the result into T(l) *I 
/* this test does loop control */ 
/* don't execute body if false */ 
I* body of the if statement *I 
/* Evaluate (i < j) and put *I 
I* the result into T ( 1) . *I 
/* This test does loop control. *I 
/* Jump to else clause if false.*/ 
/* Body of the if clause. *I 
/* Jump over the else. *I 
I* Body of the else clause. *I 
Section 6.9.1-Simple Statements and if/else 
Figure 6.20. Nested if/else Statements 
Input 
int i, j; 
fred() 
{ 
int 
if( 
{ 
else 
------wilma; 
i ) 
wilma=O; 
if( j ) 
wilma=l; 
if( j ) 
I wilma=2; 
else 
I wilma=3; 
wilma=4; 
-----------#include <toolslvirtual.h> 
#define T (x) Output 
SEG (data) 
SEG (bss) 
common word _i; 
common word _j; 
#define LO 0 
#define Ll 0 
SEG(code) I* fred: locals *I 
I* fred: temps. *I 
#undef T 
#define T{n) (fp-L0-(n*4)) 
PROC(_fred,public) 
link(LO+Ll); 
I* fp-2 = X [variable] *I 
TSTl: 
EQ(W(& i), 0) I* i *I -
go to EXITl; 
W(fp-2) = 0; I* wilma 
TST2: 
EQ(W(&_j),O) I* j *I 
go to EXIT2; 
W(fp-2) = 1; I* wilma 
EXIT2: 
goto ELl; 
EXITl: 
TST3: 
EQ(W(& -j), 0) I* j *I 
go to EXIT3; 
W(fp-2) = 2; I* wilma 
go to EL3; 
EXIT3: 
W(fp-2) = 3; I* wilma 
EL3: 
W(fp-2) = 4; I* wilma 
ELl: 
unlink(); 
ret(); 
ENDP( fred) -*I 
*I 
*II 
*II 
*I 
---------------------------------639 
640 Code Generation -Chapter 6 
Listing 6.103. c.y-Statement Processing: return,qoto, and if/else 
801 
802 
803 
804 
805 
806 
807 
808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 
827 
828 
829 
830 
831 
832 
833 
834 
835 
836 stmt list 
stmt list statement 
/* epsilon */ 
/*----------------------------------------------------------------------
* Statements 
*I 
statement 
SEMI 
compound_stmt 
expr SEMI 
RETURN SEMI 
RETURN expr SEMI 
GOTO target SEMI 
target COLON 
statement 
I IF LP test RP statement release_value($1); tmp_freeall(); 
gen( "goto%s%d", L_RET, rlabel(O) ); 
gen{"=", IS_INT ($2->type) ? "rF.w.low" 
IS POINTER($2->type) ? "rF.pp" 
"rF.l", 
rvalue ($2) ) ; 
gen( "goto%s%d", L_RET, rlabel(O) ); 
release_value( $2 ) ; 
tmp freeall () ; 
gen("goto",$2); 
gen(":", $1); 
gen( ":%s%d", L NEXT, $3 ) ; 
I IF LP test RP statement ELSE gen( "goto%s%d", L ELSE, $3 ) ; -gen( ":%s%d", L _NEXT, $3 ) ; 
statement gen( ":%s%d", L ELSE, $3 ) ; 
Listing 6.104. op.c-Get Numeric Part of End-of-Subroutine Label 
1062 
1063 
1064 
1065 
1066 rlabel( incr) 
{ 
static int num; 
return incr ? num++ num; /* Return the numeric component of the next */ 
/* return label, postincrementing it by one */ 
/* if incr is true. */ 
qoto statements and la­
bels. The qoto processing on lines 824 and 825 of Listing 6.1 03. is similarly straightfor­
ward. The compiler just generates jump instructions and labels as needed. The target 
nonterminal is at the top of Listing 6.105. It translates the label into a string which is 
returned as an attribute. Note that the action is imbedded in the middle of the label­
processing production on line 825 of Listing 6.103. If the action were at the end, then 
the label would be generated after the associated statement was processed. 
The next two productions, on lines 828 and 831 of Listing 6.103, handle the if and 
if/else statements. The best way to understand these actions is to compare the sample 
input and output in Table 6.26 and Figure 6.20. The code for the test is generated by the 
Section 6.9.1-Simple Statements and if/else 
test nontenninal, on line 843 of Listing 6.105, which outputs a label over the test code, 
generates the test code via expr, and then generates the statement that branches out of 
the test on failure. The first label isn't used here, but the same test production is used by 
the loop-processing productions, below, and these productions need a way to jump back 
up to the test code from the bottom of the loop. The presence of an extra label in an if 
statement is hannless. 
Listing 6.105. c.y-Statement Processing: Tests and qoto Targets 
static char buf[ NAME_MAX ]; 641 
837 target : NAME 
838 
839 sprintf(buf, "%0.*s", NAME_MAX-2, yytext ); 
$$ = buf; 
840 
841 
842 
static int label = 0; 843 test 
844 gen( ":%s%d", L_TEST, $<num>$ ++label ); 
845 
846 expr 
847 $$ = $<num>l; 
848 
849 if( IS_INT_CONSTANT($2->type) 
{ 
850 if( ! $2->type->V_INT ) 
851 yyerror("Test is always false\n"); 
852 
853 else I* not an endless loop *I 
854 
855 gen ( "EQ", rvalue ($2), "0" ) ; 
856 gen( "goto%s%d", L_NEXT, $$ ); 
857 
858 
859 
860 
861 I* empty *I 
862 
863 release_value( $2 ); 
tmp_freeall (); 
$$ = 0; I* no test *I 
The returned attribute is the numeric component of all labels that are associated with 
the current statement. You'll need this infonnation here to generate the target label for 
the exit branch, and the same numeric component is used to process the else. For 
example, the inner if/else at the bottom if Figure 6.20 uses three labels: TST3:, 
EXIT3, and EL3. The outer if/else uses TSTl:, EXITl, and ELl. The numeric com­
ponent is generated in the test production, and the various alphabetic prefixes are defined 
symbolically in label.h. (It's in Listing 6.59 on page 557.) 
Finally, note that if the expr is a constant expression, no test is printed. An error 
message is printed if the expression evaluates to zero because the code in the body of the 
loop or if statement is unreachable; otherwise, the label is generated, but no test code is 
needed because the body is always executed. This way, input like: 
while( 1 
evaluates to: 
label: 
goto label; Numeric component of 
label. 
Constant expressions in 
tests. 
642 
Loops. Code Generation -Chapter 6 
The alternative would be an explicit, run-time comparison of one to zero, but there's lit­
tle point in that. 
6.9.2 Loops, break, and continue 
Loops are handled by the productions in Listing 6.106; there's some sample input and 
output code in Table 6.27. The code generated for loops is very similar to that generated 
for an if statement. The main difference is a jump back up to the test at the bottom of the 
loop. The main difficulty with loops is break and continue statements, which are not 
syntactically attached to the loop-control productions. break and continue are 
treated just like labels by the productions on lines 915 and 923 of Listing 6.106. They 
can appear anywhere in a subroutine-there's nothing in the grammar that requires them 
to be inside a loop or switch. Nonetheless, you do need to know where to branch when 
a break or continue is encountered, and you need to detect a break or continue 
outside of a loop or switch. 
The problem is solved with a few more auxiliary stacks, declared at the top of Listing 
6.106. The top-of-stack item inS_ brk is the numeric component of the target label for a 
break statement.~ The alphabetic component of the label is at the top of S _ brk _label. 
I've used two stacks to save the trouble of calling sprintf () to assemble a physical 
label. The compiler pushes a label onto the stack as part of the initial loop-control pro­
cessing (on line 866 of Listing 6.106, for example). It pops the label when the loop pro­
cessing finishes on line 871 of Listing 6.106. S _con and S _con _label do the same 
thing for continue statements. If the stack is empty when a break or continue is 
encountered, the statement is outside of a loop, and a semantic error message is printed. 
6.9.3 The switch Statement 
The switch statement. The final control-flow statement in the language is the switch. Switches can be 
processed in several different ways. First, bear in mind that a switch is really a vec­
tored goto statement. Code like the following is legal, though it's bad style: 
switch( i ) 
{ 
case 0: if( condition 
donald(); 
else 
case 1: { 
hewey(); 
dewie (); 
louie(); 
break; 
You could do the same thing with goto statements as follows: 
Section 6.9.3-The switch Statement 643 
Table 6.27. Loops: while, for, and do/while 
Input Output 
while( i < 10 ) TST3: 
{ LT(W(& i) '10) !* -Evaluate ( i <1 0) and put *I 
break; qoto T3; !* the result into T (1). *I 
cont.i.nue; F3: 
} W( T (1) ) = 0; 
qoto E3; 
T3: 
W( T (1) ) = 1; 
E3: 
EQ(W( T (1) ) '0) /* Exit the loop if test fails. *I 
qoto EXIT3; 
/* Body of loop: *I 
qoto EXIT3; /* break *I 
qoto TST3; /* continue *I 
qoto TST3; /* jump back up to the test *I 
EXIT3: 
do DTOP1: !* Top-of-loop marker *I 
{ /* Body of loop: *I 
break; qoto DXIT1; !* break *I 
cont.i.nue; qoto DTST1; /* continue *I 
} DTST1: 
while( --i ) ; TST1: 
W(& i) -= 1; -/* Evaluate --i and put *I 
W( T (1) ) = W(& i); !* the result into T(1). *I -
EQ(W( T (1) ) '0) /* Exit loop if test fails. *I 
qoto EXIT1; 
qoto DTOP1; /* Jump back to top of loop */ 
DXIT1: 
EXIT1: 
for( i = 0; i < 10; ++i ) W(& i) = 0; -/* Initialization part of for. *I 
{ TST4: /* Top-of-loop marker *I 
break; LT(W(& i) '10) /* -Evaluate ( i <1 0) and put *I 
cont.i.nue; qoto T4; !* the result into T(l) *I 
} F4: 
W( T (1) ) = 0; 
qoto E4; 
T4: 
W( T(1) ) = 1; 
E4: 
EQ(W( T(1) ) '0) !* Exit the loop if test fails. *I 
qoto EXIT4; 
qoto BDY4; /* Skip over the increment *I 
INC4: !* increment portion of for stmt. *I 
W(& i) += 1; -
W( T (1) ) = W(& i); -qoto TST4; !* Jump up to the test. *I 
BDY4: /* Body of the loop *I 
qoto EXIT4; /* break *I 
qoto INC4; !* continue (jump to increment). *I 
qoto INC4; !* Bottom of loop, jump to increment.*/ 
EXIT4: 
644 Code Generation -Chapter 6 
Listing 6.106. c.y-Statement Processing: Loops, break, and continue 
164 %{ 
165 I* These stacks are necessary because there's no syntactic connection break, 
166 * continue, case, default and the affected loop-control statement. 
167 *I 
168 
169 
170 
171 
172 
173 
174 stack del 
stack del 
stack del 
stack del 
%} (S_brk, 
(S_brk -
(S con, -(S con --
864 I* statement: *I 
865 int, 
label, char 
int, 
label, char 
866 I WHILE LP test RP 
867 
868 
869 statement 
870 
871 
872 
873 
874 
875 I DO 
876 
877 
878 
879 
880 
881 
882 
883 statement WHILE 
884 LP test RP SEMI 
885 
886 
887 
888 
889 
890 
891 
892 * 
* 
893 I FOR LP opt_expr SEMI 
894 test SEMI 
895 
896 
897 
898 
899 
900 
901 
902 
903 opt_ expr RP 
904 
905 
906 statement 
907 
908 32); 
, 32); 
32); 
, 32); I* number part of current break target *I 
I* string part of current break target *I 
I* number part of current continue targ. *I 
I* string part of current continue targ. *I 
push(S_con, $3); push( s con_label, L_TEST); 
push(S_brk, $3); push( S brk -label, L_NEXT); 
gen( "goto%s%d", L_TEST, $3 ) ; 
gen( ":%s%d", L_NEXT, $3 ) ; 
pop( s con ) ; pop( s con label ) ; 
pop( S brk ) ; pop( S brk label ) ; -
static int label; 
gen(":%s%d", L_DOTOP, $<num>$ =++label ); 
push( S_con, 
push( S_con_label, 
push( S_brk, 
push( S_brk_label, label ); 
L DOTEST ) ; 
label); 
L DOEXIT ); 
gen(":%s%d", L_DOTEST, $<num>2 
gen ( "goto%s%d", L_DOTOP, $<num>2 
gen( ":%s%d", L_DOEXIT, $<num>2 
gen( ":%s%d", L_NEXT, $7 
pop( s -con ) ; 
pop( s con label ) ; 
pop( S brk ) ; 
pop( S brk label ) ; 
gen("goto%s%d, L_BODY, $5 ); 
gen(":%s%d", L_INCREMENT, $5 ); 
push(S_con, $5); 
push(S_con_label, 
push(S_brk, $5); 
push(S_brk_label, L INCREMENT ) ; 
L NEXT ) ; 
gen("goto%s%d", L_TEST, 
gen(":%s%d", L_BODY, $5 ) ; 
$5 ) ; 
gen("goto%s%d", L_INCREMENT, $5 ); 
gen( ":%s%d", L_NEXT, $5 ); ) ; 
) ; 
) ; 
) ; 
Section 6.9.3-The switch Statement 
Listing 6.106. continued ... 
909 
910 
911 
912 
913 
914 
915 
916 
917 
918 
919 
920 
921 
922 I BREAK SEMI 
923 
924 
925 I CONTINUE SEMI 
926 
927 
928 
929 
if i 
else if i 
else 
caseO: if( 
else 
easel: 
end:; 0 goto caseO; 
2 goto easel; 
go to end; 
condition 
donald(); 
hewey(); 
dewie(); 
louie(); pop( S con ); 
pop( S con label ); 
pop( S brk ); 
pop( S brk label ); 
if( stack_empty(S_brk) ) 
yyerror("Nothing to break from\n"); 
gen_comment("break"); 
gen("goto%s%d", stack item(S_brk_label,O), 645 
stack_item(S_brk, 0)); 
if( stack_empty(S_brk) ) 
yyerror("Continue not in loop\n"); 
gen_comment("continue"); 
gen ("goto%s%d", stack_item (S_con label, 0), 
stack_item(S_con,O )); 
The simplest, and the least efficient, method of handling switch statements translates Translation to if/else. 
the switch and cases directly into a series of if/else statements. For example, code 
like this: 
switch( i ) 
{ 
case 0: /* code */ 
case 1: /* more code */ 
can be translated into the following C-code: 
646 Code Generation -Chapter 6 
EQ ( i1 0 /* test for case 0: */ 
goto SWl; 
/* code *I 
goto SW2: 
SWl: /* Jump around test *I 
EQ ( i1 1 /* test for case 1: *I 
goto SW3: 
SW2: 
/* more code */ 
The main disadvantage of this method is run-time speed; a lot of unnecessary goto 
branches are needed to find the thing you're looking for. Moreover, you have to test 
every case explicitly to find the default one. In practice, translation to if/else is useful 
only if there are a very limited number of case statements. 
One easy-to-do improvement eliminates the qoto branches around the imbedded 
case-processing statements by moving all the tests to the bottom of the switch. This 
method is used by the current compiler, and is illustrated in Table 6.28. A jump at the 
top of the switch gets you to the test code, which then jumps back up to the correct place 
in the switch. A final qoto branch jumps around the case-selection code if the last 
case doesn't have a break in it. 
Table 6.28. Vectored Goto: switch 
Input 
switch( i ) 
{ 
case 0: 
i = 0; 
/* fall 
case 1: 
i = 1; 
break; 
default: 
i = 2; 
break; 
} 
Dispatch tables. Output 
goto SWl; /* Jump to case-processing code.*/ 
SW3: I* Case 0 *I 
W(& i) = 0; /* Fall through to next case. *I -SW4: /* Case 1 *I 
through *I W(& i) = 1; 
goto SW2; /* break; *I 
SWS: /* default: *I 
W(& i) = 2; 
goto SW2; /* break; */ 
goto SW2; /* Inserted by compiler in case *I 
/* last case has no break in it.* I 
SW1: /* Code to evaluate switch: *I 
EQ(W(& i) 1 0) 
goto SW3; /* Jump to case 0. *I 
EQ(W(& i) 1 1) 
goto SW4; /* Jump to case 1. *I 
go to SWS; /* Jump to default case. *I 
SW2: 
The main reason that I'm using this approach is that limitations in C-code won't let 
me use the more efficient methods. It's worthwhile discussing these other methods, how­
ever. All of the alternate switch strategies use a table to compute the qoto branches. 
The first method uses a data structure called a dispatch table-an array of two-member 
structures. The first member is the argument to the case statement, the second is a qoto 
instruction that branches to the required location in the code. The switch: 
switch( i ) ; 
{ 
case 0: washington(); 
case 1: jefferson(); 
Section 6.9.3-The switch Statement 
case 3: adams(); 
} 
can be implemented with this table: 
0 goto caseO; 
I go to easel; 
3 goto case3; 
and this code: 
caseD: washington(); 
easel: jefferson(); 
case3: adams(); 
The compiler generates code to look up the case value in the table, often using a run­
time subroutine call. If the value is found, the matching goto statement is executed, 
otherwise a branch to the default case is used. The table can be sorted by case value at 
compile time so the compiler can use a binary search at run time to find the proper label. 647 
An even more efficient method uses a data structure called a jump table. A jump Jump tables. 
table is an array of goto vectors, indexed by case value. The compiler can process the 
switch with a single test and an array lookup: 
if( argument to switch is in range ) 
goto jump_ table[ argument_to_switch -value of smallest case]; 
else 
goto default case; 
The table elements are adjusted so that jump_ table [ 0 J corresponds to the smallest 
number used as an argument to a case statement. Holes in the table-elements for 
which there are no corresponding case--are filled with jumps to the default case. Note 
that, if the range of case values is less than or equal to twice the total number of case 
values, the jump table will be no larger than an equivalent dispatch table. 
Though the current compiler can't use tables in the generated code, the method that it 
does use is easily adapted to this approach, because it assembles a compile-time model 
of the dispatch table. Listing 6.107 contains the data structures used for this purpose. 
A dispatch-table element (case_ val) is defined on lines three to seven. It contains 
two fields: on_ this is the argument to the case statement, stored as an int, go_ here is 
the numeric component of the label associated with this case; the alphabetic prefix is sw. 
The stab structure, declared on line nine of Listing 6.107, is used to manage the 
table proper. It contains the following fields: 
table 
cur 
name The dispatch table-an array of case_ val structures. 
Points into table at the next available slot. 
The name field of the value structure to which the expression argu­
ment of the switch statement evaluates. That is, a switch is recognized 
by the following production: 
statement~SWITCH LP expr RP compound _stmt 
The expr recognizes an entire expression-all code for evaluating the 
expression will have been generated when the expr is put onto the stack 
by the parser. This code creates a single value attribute that identifies 
the temporary variable that holds the run-time result of the expression 
evaluation; the name field from this value is copied to the stab's 
name field. Jump table vs. dispatch 
table size. 
648 Code Generation -Chapter 6 
def label The numeric component of the label associated with the default case. 
This number is 5 in the switch in Table 6.28. 
stab label The numeric component of the labels that precede and follow the case­
selection code. The label that follows the case-selection code has the 
value stab label+l. This number is I in the switch in Table 6.28: 
SWl precedes the selection code and SW2 follows it. 
Listing 6.107. switch.h- Type Definitions for switch Processing 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 #define CASE MAX 256 /* Maximum number of cases in a switch */ 
typedef struct case val 
{ /* a single dispatch-table element */ 
int on_this; 
int go_here; 
case_val; /* The N in a "case N:" statement *I 
/* Numeric component of label in output */ 
/* code. */ 
typedef struct stab 
{ /* a switch table */ 
case val *cur; /* pointer to next available slot in table */ 
case val table[ CASE MAX ] ; /* switch table itself. *I 
char name [ VALNAME MAX ] ; /* switch on this rvalue *I 
int def label; /* label associated with default case */ 
int stab_label; /* label at top and bottom of selector */ 
stab; /* code. Bottom label is stab label+l. */ 
The compiler keeps around a stack of pointers to stab structures, declared in Listing 
6.1 08. The size of this stack limits the number of nested switch statements that are per­
mitted in the input. A stab is allocated when the switch is processed, and a pointer to 
the stab is pushed. The pointer is popped after the entire switch has been processed. 
Every instance of a nested switch pushes a new stab pointer onto the stack, and that 
pointer is popped when the compiler is done with the nested switch. 
Every case statement does two things: it emits a label of the form swn, and it adds a 
new dispatch-table element for n to the stab structure at top of stack. (It modifies the 
entry pointed to by the cur field in the structure at top of stack, and then increments the 
cur field.) The numeric components of the label are just allocated sequentially by incre­
menting Case _label, also in Listing 6.108. The code that processes a switch is in 
Listings 6.108 and 6.109. 
The only difficulty in the code is the point at which the value associated with the 
argument to the switch statement is released on line 945 of Listing 6.108. This is 
another compile-versus-run-time issue. The order of operations at run time is: (I) jump 
to the selector code at the bottom of the switch, (2) pick out the target label, (3) jump 
back up to that label. At run time, the value associated with the expr is used in step 
(2) to select the goto vector, and is not used further. Consequently, it can be recycled 
for use in the code that comprises the body of the switch. The selector code is not gen­
erated until after the body is processed, however. If the value was released after the 
selector code was printed, it could not be recycled in the switch body. Consequently, 
it's released at the top of the switch, before the body is processed. The value's name 
field is remembered in the stab structure so that the selector code can be generated 
later. 
Section 6. 9.3-The switch Statement 
Listing 6.108. c.y-Statement Processing: The switch statement. 
175 
176 
177 
178 
179 
930 
931 
932 
933 
934 
935 
936 
937 
938 
939 
940 
941 
942 
943 
944 
945 
946 
947 
948 
949 
950 
951 
952 
953 
954 
955 
956 
957 
958 
959 
960 
961 
962 
963 
964 
965 
966 %{ 
int Case label = 0; /* Label used to process case statements. */ 
stack del (S_switch, stab 
%} *, 32); /* Switch table for current switch. */ 
/* statement: *I 
I SWITCH LP expr RP 
{ 
/* Note that the end-of-switch label is the 2nd argument to 
* new_stab + 1; This label should be used for breaks when in 
* the switch. 
*I 
push( S_switch, new_stab($3, ++Case_label) ); 
gen_comment("Jump to case-processing code" ); 
gen("goto%s%d", L_SWITCH, Case label); 
push( S_brk, ++Case label); 
push( S_brk_label, L SWITCH ); 
release_value( $3 ); 
tmp_freeall (); 
compound_stmt 
{ 
gen stab_and_free_table( pop( S switch) ); 
CASE const_expr COLON 
{ 
add case 
gen_comment 
gen stack_item(S_switch,O), $2, ++Case_label ); 
DEFAULT COLON 
{ "case %d:", $2 
":%s%d" , L_SWITCH, Case label ) ; 
) ; 
add default_case( stack_item(S_switch,O), ++Case label); 
gen_comment("default:"); 
gen(":%s%d", L_SWITCH, Case label); 649 
650 Code Generation -Chapter 6 
Listing 6.109. switch.c- Switch Processing 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 54 55 
56 
57 
58 
59 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
#include <tools/l.h> 
#include <tools/compiler.h> 
#include <tools/c-code.h> 
#include "symtab.h" 
#include "value.h" 
#include "proto.h" 
#include "label.h" 
#include "switch.h" 
/*----------------------------------------------------------------------*1 
PUBLIC stab *new_stab( val, label ) 
value 
int *val; 
label; 
/*Allocate a new switch table and return a pointer to it. Use free() to 
* discard the table. Val is the value to switch on, it is converted to 
* an rvalue, if necessary, and the name is stored. 
*I 
stab *p; 
if( ! (p = (stab*) malloc(sizeof(stab)) )) 
{ 
yyerror("No memory for switch\n"); 
exit ( 1 ) ; 
p->cur p->table 
p->stab_label label; 
p->def_label 0; 
strncpy( p->name, rvalue(val), sizeof(p->name) ); 
return p; 
/*----------------------------------------------------------------------*1 
PUBLIC void add_case( p, on_this, go_here ) 
stab 
int 
int *p; 
on_this; 
go_here; 
/*Add a new case to the stab at top of stack. The 'cur' field identifies 
* the next available slot in the dispatch table. 
*I 
if( p->cur > &(p->table[CASE_MAX-1]) ) 
yyerror("Too many cases in switch\n"); 
else 
p->cur->on_this 
p->cur->go_here 
++( p->cur ); on_this ; 
go_here; 
Section 6.9.3-The switch Statement 
Listing 6.109. continued ... 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 /*----------------------------------------------------------------------*1 
PUBLIC void add_default_case( p, go_here ) 
stab 
int *p; 
go_here; 
/* Add the default case to the current switch by remembering its label */ 
if( p->def_label ) 
yyerror("Only one default case permitted in switch\n"); 
p->def_label go_here; 
/*----------------------------------------------------------------------*/ 
PUBLIC void 
stab *p; 
{ gen_stab_and_free_table( p) 
/* Generate the selector code at the bottom of the switch. This routine is 
* emitting what amounts to a series of if/else statements. It could just 651 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 * as easily emit a dispatch or jump table and the code necessary to process 
* that table at run time, however. 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 99 
100 
101 
102 
103 
104 *I 
case val 
char *cp; 
nbuf[20]; 
gen( "goto%s%d", L_SWITCH, p->stab_label + 1 ); 
gen( ":%s%d", L_SWITCH, p->stab_label ); 
for( cp = p->table 
{ cp < p->cur ; ++cp ) 
gen( "EQ%s%d", p->name, cp->on_this ); 
gen( "goto%s%d", L_SWITCH, cp->go_here ); 
if( p->def_label ) 
gen( "goto%s%d", L_SWITCH, p->def_label ) ; 
gen( ":%s%d", L_SWITCH, p->stab_label + 1 ); 
free ( p ) ; 
6.1 0 Exercises 
6.1. What are the consequences of changing the initial productions in the current C 
grammar to the following: 
program 
ext_ def_list ext_ def_list 
ext_ def ext_ def_list 
Would the parser still work? For how long? This exercise points out the 
differences between theoretical and practical grammars. 
652 Code Generation -Chapter 6 
6.2. Find all the bugs in the compiler presented in the current chapter and fix them. 
6.3. Draw a system of symbol, link, and structdef structures that represents the 
following global-variable definition: 
struct Montague 
{ 
long *(*Romeo[2]) [5]; 
short **Juliet[lO]; 
struct Montague *next; 
* (* (* Capulet) [ 10 ] ) (); 
6.4. Modify the compiler in the current chapter as follows: 
a. Add 4-byte floats to the compiler. 
b. Add 8-byte doubles to the compiler. 
c. Add support for the const, volatile, and reqister storage classes. 
d. Make structures generate !values: Add structure assignment and add the 
ability to pass a structure to a subroutine (and to return it) by value. 
e. Add run-time initialization of automatic variables. 
f. Add compile-time initialization of static-local and global aggregates. 
g. Add support for signed and unsigned bit fields. 
h. Add support for function prototypes. A hard error should occur when the 
types in a definition disagree with a prototype. A warning should be printed 
(and any required type conversions be performed) when the arguments of a 
call differ from those in the prototype. 
You'll have to call run-time subroutines to do the floating-point operations 
because floating point is not supported in C-code. 
6.5. The scope of a structure in the current chapter's compiler is from the point of 
declaration to the end of the input file. This is incorrect--structures should fol­
low the same scoping rules as variables. Fix the problem. 
6.6. Though the compiler in the current chapter behaves reasonably well when it's 
given legal input, it has difficulty when presented with syntactically correct, but 
semantically incorrect input. Semantic errors, such as ++ being applied to a non­
lvalue or an attempt to multiply two pointers, should be handled by printing an 
error message, and then pretending that legal input had been encountered by put­
ting a legitimate attribute onto the value stack instead of garbage. Improve the 
semantic-error recovery in the current compiler. 
6.7. Most code generation has been concentrated into the gen () subroutine to facili­
tate portability to other target languages. Declarations are not handled by gen, 
however. Either modify gen () to handles declarations, or create a new 
decl_gen () subroutine that outputs all declarations. Modify the variable­
declaration actions to use this subroutine. 
6.8. The compiler currently generates the following code for i & & j & & k: 
Section 6.10-Exercises 
Fl: 
Tl: 
El: EQ(W(&_i),O) 
qoto Fl; 
EQ (W(&_j), 0) 
qoto Fl; 
EQ(W(&_k),O) 
qoto Fl; 
qoto Tl; 
W( T(l) ) 0; 
qoto El; 
W(T(l))=l; 
This code has an unreachable goto statement above the F 1 label. Modify the 
compiler to generate the following code for the earlier input: 
Fl: 
Tl: 
El: EQ(W(&_i),O) 
qoto Fl; 
EQ (W (&_j), 0) 
qoto Fl; 
NE (W(&_k), 0) 
qoto Tl; 
W( T(l) ) 0; 
qoto El; 
W( T(l) ) = 1; 
6.9. (a) Redesign C-code so that it is a more appropriate language for communication 
with a back end: the sizes of all objects should all be I, and the stack should be I 
element wide; Space for local variables should not be allocated in the compiler 
(information about them should be passed to the back end to do the allocation), 
and so forth. Modify the compiler to emit your modified code. 
(b) Write a back end that translates that code to a real assembly language. 
6.1 0. The PostScript graphics-description language is a postfix assembly language used 
by many printers. It is described in Adobe System's PostScript Language Refer­
ence Manual (Reading, Mass.: Addison- Wesley, 1985). Write a C-to-PostScript 
Translator. You may define a subset of C for this purpose. All the standard 
PostScript functions should be supported as intrinsic functions (recognized as 
keywords by the compiler and processed directly). 
6.11. The UNIX trotf typesetting program is really an assembler. Its input is an 
assembly-language description of a document made up of interspersed text and 
"dot commands" (assembler directives). Trotftranslates that input into a typeset 
version of that document. Design a C-Iike language that can describe a document, 
and then implement a compiler that translates that language to trotf. At minimum 
you must support ints, one-dimensional arrays, subroutines (which must be able 
to return int values), and if/else, for, and while statements. You should also 
support a basic string type, with operators for concatenation, comparison, and 
so forth. Finally, you should support an aliasing facility that lets you give reason­
able names to built-in registers and special characters. You can use recursion to 
do the loops. For example, the following loop executes ten times: 653 
654 Code Generation -Chapter 6 
.de Lp 
if \\$1 \{\ 
executing iteration \\$1 
nr x \\$1-1 
Lp \\nx \} 
.\" 
.Lp 10 \" This call loops ten times 
6.12. Write compilers that duplicate the UNIX pic and eqn preprocessors, translating 
descriptions of pictures and equations into trotf commands. 
6.13. Write an ANSI-C preprocessor. It must be able to handle the concatenation (##) 
and "stringizing" operator(#). 
6.14. Write a program that reads a C input file and which outputs ANSI function proto­
types for all functions in that file. Your program must be able to handle 
#include statements. Your output must be acceptable to a standard, ANSI com­
piler. 
6.15. Write a program that reads a C file containing old-style function definitions like 
this: 
apostles( mat, mark, luke, john, fred) 
char *mat; 
long mark; 
double luke; 
{ 
} 
and which outputs C++-style definitions like this: 
apostles( char *mat, long mark, double luke, int john, int fred) 
{ 
} 
Note that the default int type must be supplied for john and fred. 
6.16. Modify the solution to the previous exercise so that it goes in the other direction, 
translating C++ definitions to old-style C definitions. 
6.17. Modify the solution to the previous exercise to translate an ANSI-C input file to 
pre-ANSI, K&R C. If several input files are listed on the program's command line, 
they should be translated individually. Output should be written to files with a 
.k&r extension. For example, foo.c should be translated, and the output placed in 
foo.k&r. (Use .knr on UNIX systems so that you don't have to quote the name.) 
At very least, function definitions, string concatenation, and function-name map­
ping [such as remove () to unlink ()], should be handled. If the first eight 
characters of an identifier are not unique, the identifier should be replaced with a 
unique 8-character name. These replacements should carry from one input file to 
another in the case of nonstatic global variables and subroutine names. That is, if 
several C input files are specified on your translator's command line, the files 
should be translated individually (not merged together), but the too-long global 
symbols that are translated in one file should be translated to the same arbitrary 
name in all files. Be careful to check that your arbitrary name is not already being 
used in the input file for some other purpose. 
Structure assignment, passing structures to functions, and the returning of struc­
tures from a function should also be detected and translated into a form that can 
be handled by a compiler that supports none of these (you can use implicit 
memcpy () calls for this purpose). 
Section 6.10-Exercises 
6.18. Write a "beautifier" program that reads a randomly formatted C input file and 
which outputs the file with nice indenting showing the block level, lined up r braces, and so forth. You should do intelligent things with comments, trying to 
line up the '/*'and '*/'tokens in end-of-line comments in neat columns, like this: 
code /* comment */ 
more code /* another comment */ 
yet more code /* yet another comment */ 
If a comment won't fit onto the end of a reformatted line, then it should be moved 
to the previous line. Multiple-line comments should be output as follows: 
/* this is a 
* multiple-line 
* comment 
*I 
with the I* at the same indent level as the surrounding code. 
6.19. One of the more useful features of C++ is "function overloading". You are per­
mitted to declare several instances of the same function, each of which takes argu­
ments of different types, like this: 
overload Sophocles; 
int Sophocles( long Jocasta, short Oedipus){ ... } 
double Sophocles( double Jocasta, char *Oedipus){ ... } 
The overload keyword tells the compiler that multiple definitions of a function 
are permitted. The compiler determines which version of the function to call by 
examining the types of the actual arguments in a given call. If the types in a call 
don't match the definition exactly, the standard type conversions are used to pro­
mote the argument to the correct type (a warning is printed if this is done). Do the 
following: 
·(a) Modify the C compiler in the current chapter to support function overloading. 
(b) Write a preprocessor that translates overloaded functions to a form that can be 
handled by a standard ANSI compiler. 
6.20. The Awk Programming Language is discussed in [Aho2]. Write a compiler that 
converts an awk input file to C. 
6.21. (a) Write aC-to-Pascal converter. 
(b) Write a Pascal-to-e converter. Your program must be able to handle nested 
subroutine declarations. The organization of the Pascal stack frame is discussed 
in Appendix B. This is a much harder problem than (a). 
6.22. (a) Write a FORTRAN-to-e converter. 
(b) Write a C-to-FORTRAN converter. All C data types must be handled prop­
erly, especially translation of C pointers to FORTRAN array indexes. This is a 
much harder problem than (a). 
6.23. Modify virtual.h so that the registers and run-time stack are both 16 bits wide 
rather than 32 bits wide. Eliminate the lword basic type and .1 register selector, 
and redefine the ptr type to be 16 bits wide. Finally, modify the compiler so that 
this new stack and register width is supported. The C word widths must remain 
unchanged-the compiler should still support a 32-bit lonq int, 16-bit int, 
and 8-bit char. How could you modify the compiler to make this translation 
easier? 
6.24. Add an autodecrement and autoincrement addressing mode to C-code indirect 
modes [W (p++), WP ( --p), and so forth], then modify the grammar and associ­
ated code-generation actions so that the following inputs generate a minimum 
number of C-code instructions: 655 
656 Code Generation -Chapter 6 
*p++ *++p *p-- *--p 
6.25. Write a program that translates C-code into your favorite assembly language. 
6.26. Write a C-code interpreter that takes a C-code program as input and executes that 
code directly. The following subroutines should be built into the interpreter (so 
that they can be called directly from a C-code program): 
putb () Print the low byte of the top-of-stack item to standard output (in hex). 
putw ()Print the low word of the top-of-stack item to standard output (in 
hex). 
put 1 () Print the long word at the top of stack to standard output (in hex). 
puti ()Print the long word at the top of stack to standard output (in decimal). 
putc ()Print the low byte of the top-of-stack item to standard output as an 
ASCII character. 
puts() Print the string in the array whose address is at the top of stack to 
standard output. 
getb () Input a hex byte from standard input and return it in rF. 
getw ()Input a hex word from standard input and return it in rF. w .low. 
getl ()Input a hex long word from standard input and return it in rF. 
geti ()Input a decimal long word and put it in rF. 
getc ()Input an ASCII character from standard input and return it in 
rF .b.bO. 
dump ( ) Print the contents of all registers to standard output. 
dumps ( ) Print the top 20 stack items to standard output. 
Execution should begin with a subroutine called main( ), which must be supplied 
in the source file. You may require this function to be the first (or last) one in the 
file if you wish. 
6.27. If you haven't done so already, make the interpreter in the previous exercise into a 
window-based system. One window displays the code as it's being executed, a 
second displays the register and stack contents, a third shows the contents of 
selected static variables (entered by you at a command prompt), and a fourth 
shows the C input line that corresponds to the output being executed. Use line 
numbers that are inserted into the output by the lexical analyzer for this last func­
tion. 
6.28. If you haven't done so already, modify the interpreter to support the following 
breakpoint types: 
• Break when a speci tied source-code line is executed. 
• Break when a speci tied subroutine is called. 
• Break when a specified global variable is modified or takes on a specific 
value. 
• Break when a specified C-code instruction is executed. 
6.29. If you haven't done so already, modify the interpreter to display the contents of 
both global and local variables by specifying their name at a command prompt. A 
local symbol should be displayed only when executing a subroutine that contains 
that symbol. You will need to pass symbol-table information between the com­
piler and interpreter to do this. Use an auxiliary file. 
7 
Optimization Strategies 
This chapter looks at optimization strategies at a high level. It is not intended to be 
an in-depth discussion of the topic-something that would take a book of its own to 
cover adequately. The basic types of optimizations are described, however, and optimi­
zation techniques are discussed in a general way. The way that the choice of intermedi­
ate code affects optimization is also discussed. 
Optimizations are easily divided into three categories: parser optimizations; linear, 
peephole optimizations; and structural optimizations. I'll look at these three categories 
one at a time. 
7.1 Parser Optimizations 
The first category includes all optimizations that can be done by the parser itself. 
The simplest of these really come under the category of generating good code to begin 
with: using logical )values rather than physical ones, minimizing the number of qoto 
branches, and so forth. The other common parser optimization is intrinsic-function gen-Intrinsic functions. 
eration. Intrinsic function calls are translated directly by the compiler into code that 
does the action normally performed by the function. For example, strcpy () is often 
implemented as an intrinsic function. The lexeme strcpy is recognized by the com-
piler as a keyword, and there is a production of the form: 
expr: STRCPY LP expr COMMA expr RP 
in the grammar. The associated action generates code to copy one string to another 
rather than generating code to call the strcpy () function. Intrinsic functions are par­
ticularly useful with small workhorse functions, a call to which can often have a higher 
overhead than the code that does the work. Other common intrinsic functions are the 
math functions like sin (),cos (),and sqrt (). 
Some of the optimizations discussed below can also be done directly by the parser 
(such as using a left shift to implement multiplication by a constant). 
657 
658 Optimization Strategies -Chapter 7 
7.2 Linear (Peephole) Optimizations 
The optimizations that can be done directly by the parser are, by necessity, limited in 
scope to single productions. It's difficult for the parser to optimize any code that takes 
more than one production to process. For example, the following compiler input: 
int i; 
i = 5; 
++i; 
return i + 1; 
generates this output: 
w (& i) 
w (&_i) 
W ( T (1) 
W ( T (1) 
W ( T (1) 
rF.w.1ow 
ret (); 5; 
+= 1; 
w (& i) ; 
w (& i) ; 
+= 1; 
W( T (1) ) ; 
The two identical assignments on the third and fourth lines are unavoidable because they 
are generated by two separate statements-the first by the + + i and the second by the 
i + 1. It's easy for a separate optimizer pass to recognize this situation, however, and 
eliminate the redundant assignment. 
This section looks at various optimizations that cannot be done in the parser, but 
which can be done by an auxiliary optimizer pass that goes through the compiler's out­
put in a linear fashion, from top to bottom. (It may have to go through the output several 
times, however.) This kind of optimizer is called a peephole optimizer-"peephole" 
because it examines small blocks of contiguous instructions, one block at a time, as if the 
code were being scrolled past a window and only the code visible in the window could 
be manipulated. The optimizer scans the code looking for patterns, and then makes sim­
ple replacements. Peephole optimizers are usually small, fast programs, needing little 
memory to operate. 
The kind of optimizations that you intend to do is a major factor in deciding the type 
of intermediate language that the compiler should generate. A peephole optimizer is 
happiest working with triples or quads. I'll use the triples generated by the compiler in 
the last chapter for examples in the following discussion. 
7 .2.1 Strength Reduction 
A strength reduction replaces an operation with a more efficient operation or series 
of operations that yield the same result in fewer machine clock cycles. For example, 
multiplication by a power of two can be replaced by a left shift, which executes faster on 
most machines. (x*8 can be done with x«3.) You can divide a positive number by a 
power of two with a right shift (x/8 is x»3 if xis positive) and do a modulus division by 
a power of two with a bitwise AND (x%8 is x& 7). 
Other strength reductions are less obvious. For example, multiplication by small 
numbers can be replaced by multiple additions: t0*=3 can be replaced with 
t1 tO; 
tO += t1; 
tO += t1; 
Combinations of shifts and additions can be used for multiplication by larger numbers: 
t0*=9 can be replaced by: 
Section 7.2.1-Strength Reduction 
t1 tO; 
t1 <<= 3; 
tO += t1; 
[That is, t0x9 = (t0x8)+t0 = (t0<<3)+t0.] Larger numbers can also be handled this 
way: t0*=27 can be replaced by: 
t1 tO; 
t1 <<= 1; 
tO += t1; 
t1 <<= 2; 
tO += t1; 
t1 <<= 1; 
tO += t1; 
You can see what's going on by looking at how a binary arithmetic is performed. A 
binary multiplication is done just like a decimal multiplication. 2710 is 11011 2, so the 
multiplication is done like this: 
d d d d d d d d 
X00011011 
d d d d d d d d 
d d d d d d d d 
0 0 0 0 0 0 0 0 
d d d d d d d d 
d d d d d d d d 
00000000 
0 0 0 0 0 0 0 0 +oooooooo 
If there's a 1 in the multiplier, then the multiplicand, shifted left by a number of bits 
corresponding to the position of the 1 in the multiplier, is added to the product. At worst, 
you need as many shift/add steps as there are bits in the denominator. It's up to the 
optimizer to determine at what point it takes longer to do the shifts and additions than it 
does to use a multiplication instruction, but on many machines the shift/multiply strategy 
is faster for all but very large numbers. This last optimization is a classic example of a 
code-size-versus-execution-speed trade-off. The faster addition-and-shift code is much 
larger than the equivalent multiplication instruction. 659 
There are also nonarithmetic strength reductions. For example, many machines have Instruction optimization. 
several different forms of jump or goto instruction, and the optimizer can sometimes 
modify the code so that the more efficient instruction can be used. 
7.2.2 Constant Folding and Constant Propagation 
We've already seen constant folding at work in the last chapter, because the parser 
itself can do it in a limited way. Put simply, the compiler itself does any arithmetic that 
involves constants, if it can. An expression like a+ 2 * 3 is treated like (a+ 6) . 
Order of evaluation can prevent the parser from doing constant folding. For exam­
ple, the parser can't optimize the following input because of the left-to-right order of 
evaluation: 
a + 1 + 3 
The parser processes the a+ 1 first and puts the result into a temporary variable. The 
three is then added to the temporary. The following code is generated: 
W( T(1) ) 
W( T (1) ) 
W( T(1) ) = W(&_i); 
+= 1; 
+= 3; 
It's easy for an independent optimizer to see that T ( 1) is modified twice in succession 
660 
Constant Propagation. 
Dead variables. Optimization Strategies -Chapter 7 
without being used between the modifications, however, and replace the foregoing with: 
W ( T (1) ) 
W ( T (1) ) = W(& i); 
+= 4; 
Multiplication by one, addition and subtraction of zero, and shift by zero can be 
eliminated entirely. 
Constant folding is actually a simple case of a more general optimization called con­
stant propagation. Many variables retain constant values over a large portion of their 
lifetimes. The compiler can note when a constant is assigned to a variable and use that 
constant rather than the variable when the variable is referenced in the code. The con­
stant propagates until the variable is modified. For example, code like this: 
_y = 5; 
X = _y; 
can be replaced with 
_y = 5; 
X = 5; 
(Assignment of a constant to a variable is a more efficient operation than a memory-to­
memory copy on most machines.) At a higher level, the loop in the following code: 
int i, j; 
for ( i = 5 , j = 0 ; j < i ; + + j ) 
foo ( i ) ; 
can be treated as if the compiler had seen the following: 
for ( i = 5 , j = 0 ; j < 5 ; ++ j ) 
foo ( 5 ) ; 
The optimizer is, in effect, keeping track of the contents of all variables that contain 
constants. It keeps a local symbol table with an entry for each active variable, and that 
internal entry is modified to track modifications in the code. The internal value is 
modified every time the variable is modified. For example, this code: 
tO 1; 
tO += 5; 
t1 = tO; 
is translated to this: 
tO = 1; 
tl = 6; 
The compiler initializes an internal copy oft 0 when the first line is encountered. It then 
modifies that internal copy by adding five to it when the t0+=5 is encountered and dis­
cards the t0+=5 instruction. Finally, the modified value is used when the substitution is 
made on the third input line. 
7 .2.3 Dead Variables and Dead Code 
One type of optimization often leads to another. In the previous example, tO can be 
discarded after the constant propagation because it is not used anywhere. t 0 is a dead 
variable-a variable that is initialized (and perhaps modified), but never referenced in a 
function call or to the right of an equals sign. The variable is considered dead from the 
last time it is used until it is reinitialized-like this: 
Section 7.2.3-Dead Variables and Dead Code 661 
tO a; 
tO += 5; 
X = tO; 
tO += 1; /* tO is now dead */ 
/* This instruction can be eliminated. */ 
tO = _b; /* tO is now resurrected. */ 
At a higher level, the i in the following code is a dead variable-all references to it can 
be eliminated: 
foo(x) 
{ 
int i; 
i = x; 
++i; 
A dead assignment is an extreme case of a dead variable. A dead assignment is an Dead assignment. 
assignment to a variable that is never used or modified. The initial assignment of tO= _a 
in the earlier example is not a dead assignment because t 0 is used later on in the code. 
Nonetheless, dead assignments are very common in the output from the compiler in the 
previous chapter because of the way that expressions are processed. All expressions 
evaluate to something, and there is often a copy into an rvalue as the last step of the 
expression evaluation. Code like this: 
int x; 
++x; 
generates the following output: 
W(fp-2) 
W( T (1) ) += 1; 
= W(fp-2); /* X */ 
The final assignment to T ( 1 ) is a dead assignment because T ( 1 ) is never used. At a 
higher level, the earlier constant propagation example translated this code: 
for ( i = 5, j = 0; j < i ; ++ j ) 
into this: 
for ( i = 5, j = 0; j < 5 ; ++ j ) 
The i=S is now a dead assignment and can be eliminated. 
Dead code is code that can't be reached or does nothing useful. For example, code Dead code. 
generated by the following input can be removed entirely: 
if( 0 ) 
do_something(); 
This input is translated to the following C-code: 
NE ( 0, 0 ) 
goto label; 
call( _do_something ); 
W(T(l)) = rF.w.low; 
label: 
It is optimized in two steps. First, the dead assignment on the fourth line can be elim­
inated, yielding: 
662 
NE ( 0, 0 ) 
goto label; 
call( _do_something ); 
label: Optimization Strategies -Chapter 7 
Since the NE always evaluates true, all code between the following qoto and the label 
Eliminating useless code. can be eliminated because it's unreachable. Similar optimizations involve the elimina­
tion of useless code (like the 
goto Fl; 
F1: 
which is generated at the end of a list of && operators). The following, more complex 
example takes two passes to optimize: 
tO = 0; 
NE(t0,0) 
goto label; 
label: 
The first pass folds the constant 0 into tO, yielding this: 
NE (0, 0) 
goto label; 
label: 
The test now always fails, so it and the following qoto instruction can both be elim­
inated. 
Had we started with the following code: 
tO = 1; 
NE (tO, 0) 
goto label; 
label: 
the constant would fold to: 
NE (1, 0) 
goto label; 
label: 
which always tests true. Consequently the NE, the qoto, and all code up to the label are 
dead and can be discarded. Note that the dead-code elimination is affected if there is a 
second entry point into the block. Input like the following: 
switch( hitter ) 
{ 
case eddie_murray: x = 1; 
while( x 
{ 
case tony_phillips: 
Section 7.2.3-Dead Variables and Dead Code 
(it's sick, 1 but it's legal) could generate output like this: 
_x = 1; t NE (W (&_x), 0) 
goto label Remove only this code. 
label2: 
label: 
The constant 1 propagates into the test, resulting in dead code, but only the code up to 
label2 can be eliminated because the switch could branch to the interior label. A 
region of code that has a single entry point and a single exit point (everything from a 
label or PROC directive up to the next goto or ret () instruction) is called a basic block, 
and some optimizations, such as the current one, can be performed only within the 
confines of a basic block. 
As we just saw, dead variable and code elimination can interact with constant propa­
gation in interesting ways. The i in the following code isn't a dead variable-at least 
initially: 
foo () 
{ 
int i, j, array[lO]; 
i = 5; 
++i; 
j = array[i]; 
The compiler can propagate the constant 5 through to the array access, however: 
foo () 
{ 
inti, j, array[lO]; 
i = 5; 
++i; 
j = array[6]; 
Having done that, the i is now dead and can be eliminated: 
foo () 
{ 
int j, array[lO]; 
j = array[6]; 663 
Basic block. 
Interaction between op­
timizations. 
A form of dead-assignment elimination also applies to nonconstants. Code like the Nonconstant dead as-
following, which is very common compiler output: signments. 
I. That's a technical tenn. 
664 Optimization Strategies -Chapter 7 
Hardware problems, 
volatile. tO = _x; 
_y = tO; 
can be replaced by: 
_y = _x; 
unless x is modified before t 0 is used. For example, this code: 
tO _x; 
_y = tO; 
tO = z; 
can be optimized to: 
_y = _x; 
tO = z; 
but the following cannot be optimized because_ x is modified before t 0 is used: 
tO _x; 
_x += 1; 
_y = tO; 
All the foregoing optimizations can be a real headache when you're interfacing to 
hardware. For example, an 8-bit, memory-mapped 1/0 port at physical address Ox 10 can 
be modeled as follows on many machines:2 
char *port; 
port= (char *)OxlO; 
Thereafter, you can access the port with *port. The following code, for example, is 
intended to pulse the low bit of the output port at periodic intervals: 
*port = 0; 
while( *port ) 
{ /* initialize output port to all zeros */ 
/* read input port, terminate if data available */ 
*port = 1; /* pulse the low bit of the output port 
*port = 0; 
delay(); *I 
Unfortunately, many optimizers eliminate all of the previous code. The *port=l is a 
dead assignment because *port is modified again before the value 1 is used, so the first 
optimization results in the following code: 
*port = 0; 
while( *port ) 
{ 
*port = 0; 
delay(); 
Next, since the value of *port never changes (the same constant is always assigned to 
it), constant propagation takes over and the following code is produced: 
2. or, better yet, with: 
char *const port = OxlO; 
The const says that port itself won't change value. You can also use a macro: 
#define port ((char *) (OxlO)) 
Section 7.2.3-Dead Variables and Dead Code 
*port = 0; 
while( 0 ) 
delay(); 
The initial assignment to *port can now be eliminated because *port isn't used any­
where, and the loop can be discarded because its body is unreachable. 
The ANSI volatile keyword is used to suppress these optimizations. No assump­
tions are made as to the value of any variable that's declared volatile-the compiler 
assumes that the value can change at any time, even if no explicit code modifies it. You 
can suppress all optimizations in the previous example by declaring port as follows: 
volatile char *port; 
or better yet: 
volatile char *const port = OxlO; 
This declaration says that the object at which port points is liable to change without 
notice, but that port itself is a constant whose value never changes. 3 
7.2.4 Peephole Optimization: An Example 
I'll demonstrate the mechanics of peephole optimization with a simple example. The 
input: 
i = 5; 
++i; 
return i + 1; 
generates this output: 
W(&_i) 
W(&_i) 
W( T (1) 
W( T (1) 
W( T (1) 
rF.w.low 
ret(); 5; 
+= 1; 
=W(&i); 
= w (& i); 
+= 1; 
= W( T(1) ); 
This output has several inefficiencies built into it, all of which can be eliminated by a 
peephole optimizer. The optimizer must operate on a basic block: The current code has 
no labels into it, and a single exit point at the bottom, so it comprises a basic block. 
The first optimizations to apply are constant folding and propagation. The approach 
is straightforward: Go through the compiler output performing those operations that you 
can. You'll need a symbol table, accessed by variable name, that holds the contents of 
that variable insofar as it can be determined. 
The optimizer's first pass evaluates expressions, if possible, modifying the table's 
contents to reflect the computed value. It also substitutes any reference to a variable that 
holds a constant value with that constant. Here, the optimizer reads the first line, creates 
a symbol table entry for_ i and initializes it to 5. It now reads the second line. There's 
already an entry for i in the table, and _ i is being modified by a constant. Conse­
quently, it increments the symbol-table entry from five to six, and modifies the code as 
follows: 
3. The cast can be done like this: 
#define port ((volatile char *)OxlO) 665 
Suppress optimization 
with the volatile key­
word. 
666 Optimization Strategies -Chapter 7 
W(& i) 5; -... W(& i) 6; 
W( T (1) W(& i) ; 
W( T (1) W(& i) ; 
W( T (1) += 1; 
rF.w.low = W( T (1) ) ; 
Now it reads the third and fourth lines. Seeing that _ i holds a constant, it replaces the 
reference to i with that constant as follows: 
W(& i) 5; -
W(& i) 6; -... W( T (1) 6; ... W( T (1) 6; 
W( T (1) += 1; 
rF.w.low = W( T (1) ) ; 
It also makes a symbol-table entry forT ( 1) , initializing it to 6. Reading the fifth line, it 
sees a variable that holds a constant (T ( 1) ) being modified by a constant, so adjusts the 
internal symbol table and the output as before, yielding: 
W(& i) 5; -
W(& i) 6; -
W( T (1) 6; 
W( T (1) 6; ... W( T (1) 7; 
rF.w.low W( T (1) ) ; 
Reading the final line, since T ( 1 ) holds a constant, it can be replaced with its value: 
W(& i) 5; -
W(& i) 6; 
W( T (1) 6; 
W( T (1) 6; 
W( T (1) 7; ... rF.w.low 7; 
Though there are still the same number of operations as before, they've all been 
translated to simple assignments. 
The output from the first pass is now simplified further by going through it a second 
time, eliminating all dead variables-variables that aren't used in the current block. The 
strategy is, again, straightforward: Clear the symbol table, then go through the code, 
creating entries for all variables that appear as a source operand. Make a second pass 
eliminating all variables whose destination operand is not in the table. Since T ( 1) is not 
used in the source fields of any of the triples, all assignments to it are eliminated, yield­
ing: 
W(&_i) 5; 
W(& i) 6; 
rF.w.low 7; 
The assignments to_ i cannot be eliminated because the _ i could be used later on in the 
code. 
The final optimization eliminates dead assignments, starting with an empty symbol 
table and proceeding as follows: 
(1) If a variable in the symbol table is modified by some instruction other than assign­
ment, remove it from the table. 
(2) When a variable appears as the destination in an assignment: 
a. If it's not in the table, add it, remembering the line number of the assignment 
Section 7.2.4-Peephole Optimization: An Example 
instruction. 
b. If the variable is in the table, discard the line referenced in the symbol-table 
entry, and then replace that symbol-table reference with one for the current 
line. 
In the current example, the first assignment to_ i is a dead assignment because _ i is 
reinitialized before being used, so it is eliminated: 
W(& i) 6; 
rF.w.low = 7; 
7.3 Structural Optimizations 
So far, all the optimizations that we've looked at can be performed by analyzing the 
linear output stream of the compiler. Some optimizations must analyze the overall struc­
ture of the code, however, and more sophisticated techniques must be used. All of these 
optimizations need to know something about the structure of the code being optimized. 
Consequently, they must work on a parse or syntax tree that represents the code, not on a 
series of instructions. One solution to this problem is for the parser to build a physical 
parse tree with structures and pointers rather than generating code; the parse tree can 
then be optimized, and finally traversed depth first to do the code generation. There are 
two difficulties with this approach. First, the optimizer can get pretty big, and there is 
often insufficient room in memory for it to be combined with the parser-two indepen­
dent programs are needed. Similarly, the more code that you can get into memory at 
once, the more of the program's structure can be seen. There's no point in wasting 
memory for a parser. Finally, the entire parse tree isn't needed for optimization-a syn­
tax tree representing the various statements and expressions is sufficient. The usual solu­
tion to the problem is for the parser to generate an intermediate language from which the 
syntax tree can be reconstructed, and that intermediate code is processed by the optim­
izer. 
7 .3.1 Postfix and Syntax Trees 
The intermediate language most appropriate for this purpose is postfix or Reverse­
Polish Notation (RPN). User's of Hewlett-Packard calculators and UNIX's de desk­
calculator program will already be familiar with this representation. In postfix notation, 
operands are pushed onto a stack without modification. Operators access the top few 
items on the stack, replacing them with the result of the operation. For example, the fol­
lowing C fragment 
A * B + C * D 
can be evaluated using the following postfix operations: 
push A 
pushB 
pop two items, multiply them, push the result 
pushC push D 
pop two items, multiply them, push the result 
pop two items, add them, push the result 
The result 
is on the top of the stack when the evaluation finishes. The two multiplica­
tions have to be done before the addition because * has higher precedence than +. 
A postfix intermediate language is easy to generate because the compiler doesn't 
have to worry about assigning temporary variables-it just uses the run-time stack as its 667 
Postfix, Reverse-Polish 
Notation (RPN). 
668 
Generating postfix inter­
mediate code. Optimization Strategies -Chapter 7 
scratch space. Postfix is useful in interpreter implementations because postfix virtual 
machines are easy to implement. The interpreter can translate the source code into a 
postfix form, which is then executed in software on the virtual machine. 
The main advantage of postfix, here, is that the optimizer can reconstruct the entire 
parse tree--or to be more exact, a compacted form of the parse tree called a syntax 
tree-from the list of instructions. 
A common postfix representation uses one instruction per line. If that instruction is 
an rvalue reference, the contents of the variable are pushed onto the stack. If it's an 
lvalue reference, the address is pushed. If it's an arithmetic instruction, the top one or 
two stack elements are manipulated, and they are replaced by the result, which is either 
an lvalue or rvalue depending on the operator. The expression A*B+A*B is represented 
as: 
AL 
BL 
* 
AL 
BL 
* 
+ 
There's no need for an explicit "push" operator as long as the operators can be dis­
tinguished from variable names. Similarly, explicit parentheses are never necessary 
because the order of evaluation is determined by the sequence of operations, and all 
incoming variables are treated as )values because there's no need for explicit temporaries 
in the intermediate code. (Consequently, the subscripts in the earlier example are redun­
dant and can be omitted.) 
The first order of business is making a parser that generates postfix intermediate code 
for expressions. I've done this in Listings 7.1 and 7.2. The code is simplified because no 
temporary variables are necessary. 
Listing 7.1. postfix.y- Parser with Postfix Code Generation 
1 %term ICON NAME 
2 %left PLUS MINUS 
3 %left TIMES DIVIDE 
4 %% 
5 s expr 
6 
7 
8 expr NAME yycode ("%s\n", yytext ) ; 
9 ICON yycode("%s\n", yytext ) ; 
10 expr DIVIDE expr yycode("/\n" ) ; 
11 expr TIMES expr yycode("*\n" ) ; 
12 expr PLUS expr yycode("+\n" ) ; 
13 expr MINUS expr yycode("-\n" ) ; 
14 
15 %% 
16 main() { yyparse(); 
Converting the postfix in­
termediate code to a syn­
tax tree. The next task is converting the intermediate code generated by our compiler back to 
a syntax tree. You can look at the generated intermediate code as a convenient way for 
the parser to pass the tree to the optimizer. The following syntax tree can be created 
when you run A* B+ A* B through the parser we just looked at: 
Section 7.3.1-Postfix and Syntax Trees 
Listing 7.2. postfix.lex- Lexical Analyzer for Postfix Code Generation 
I %{ 
2 #include "yyout.h" 
3 %} 
4 %% 
5 [a-zA-Z ] [a-zA-Z 0-9]* return NAME; - -6 [0-9]+ return ICON; 
7 "/" return DIVIDE; 
8 "*" return TIMES; 
9 "+" return PLUS; 
10 "-" return MINUS; 
II ; /* empty *I 
12 %% 
All internal nodes represent operators and all the leaves reference !values. Also, the 
grouping of operators and operands is as you would expect, given the operator pre­
cedence built into the grammar. 
Before demonstrating how to do this reconstruction, we'll need a data structure to 
represent the nodes in the tree. Listing 7.3 shows this data structure (a node) and a con­
structor subroutine that makes new nodes [new () ]. The node structure is a normal 
binary-tree node, having left and right children. In addition, the name field holds vari­
able names (A and Bin this case) or the operator if the node is an internal node. The con­
tents of this field will be modified by the optimizer, however. The op field usually holds 
the operator ( * or+), but it is set to 0 in leaf nodes. 
Listing 7.3. optimize.c- The node Data Structure, Used to Construct Syntax Trees 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 #include <stdlib.h> 
typedef struct node 
{ 
char 
int 
struct node 
struct node 
node; 
node *new() 
{ 
node *p; name [ 16]; 
op; 
*left; 
*right; /* <malloc.h> for UNIX */ 
if( ! (p = (node *) calloc( 1, sizeof(node) ) ) ) 
exit(l); 
return p; Data structures to 
represent the syntax 
tree: node. 669 
670 Optimization Strategies -Chapter 7 
Reconstructing the syn­
tax tree. The build () subroutine in Listing 7.4 creates a syntax tree from a postfix input file. 
The input file must have one operand or operator per line and it must be perfect. That is, 
in order to simplify the code, I've dispensed with error detection. Input lines are read 
from standard input and the subroutine returns a pointer to the root node of the tree. The 
tree is built in a bottom-up fashion, using a local stack defined on line 22 to keep track of 
the partially-constructed tree. Figure 7.1 shows the syntax tree for the input discussed 
earlier as it is built-you'll notice the similarity between this process and the bottom-up 
parse process. 
The default case on Line 30 is executed for variable names. 4 It allocates and ini­
tializes a new node, and then pushes a pointer to the new node onto the stack. The child 
pointers are initialized to NULL by new ( ) . 
Operators are handled differently because they're internal nodes. A new node is allo­
cated and initialized, then pointers to two existing nodes are popped and the child 
pointers of the new internal node are made to point at these. Finally, a pointer to the new 
node is pushed. 
Listing 7.4. optimize.c- A Postfix to Syntax Tree Constructor 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 node *build() 
char bu f [ 8 0 J ; 
node *stack[ 10 ]; 
node **sp = stack -1; 
node *p; 
while( gets(buf) 
{ 
switch ( *buf 
{ 
default: p =new(); 
strcpy( p->name, buf ) ; 
*++sp = p; 
case '*': 
case '+': 
return *sp--; break; 
p 
p->right 
p->1eft 
p->op 
p->name[O] 
*++sp 
break; new() 
*sp-­
*sp-­
*buf 
*buf 
p 
Generating code from the 
syntax tree. Code can be generated from this tree by doing a depth-first traversal (visit the chil­
dren then the parent). At every !value (ie. variable reference), generate an instruction of 
the form temporary = variable. At every internal node, generate the code 
4. The default case can go anywhere in the switch. It doesn't have to be at the end. 
Section 7.3.1-Postfix and Syntax Trees 
Figure 7.1. Building a Syntax Tree 
AI Bl &AI 
*I /\.. 
AI Bl I &*I 
*I /\.. 
AI Bl A2 &*I 
*I /\.. 
AI * Bl A2 B2 &*I 
*I *2 /\.. /\.. 
AI Bl A2 B2 &*I 
/+~ 
*I *2 /\.. /\.. &+ 
AI Bl A2 B2 &B1 
&A2 
&A2 &B2 
&*2 Read A1 
Make a node for A1 
Push the address of A1 
Read B1 
Make a node for B 1 
Push the address of B 1 
Read *1 
Make a node for * 1 
Pop two stack items 
Make them the children of the new node 
Push the address of the new node 
Read A2 
Make a node for A2 
Push the address of A2 
Read B2 
Make a node for B2 
Push the address of B2 
Read *2 
Make a node for *2 
Pop two stack items 
Make them the children of the new node 
Push the address of the new node 
Read+ 
Make a node for + 
Pop two stack items 
Make them the children of the new node 
Push the address of the new node 
necessary to perform the operation on the temporaries that resulted from traversing the 
previous level, putting the result into a new temporary. The previously constructed tree 
generates the following output: 
tO A 
tl B 
tl *= tO 
t2 A 
t3 B 
t3 *= t2 
t3 += tl 
The trav () subroutine in Listing 7.5 does the traversal. It takes the pointer 
returned from the previous build () call as its initial argument. If root->op is zero, 
then the current node is a leaf and you generate the code to move it to a temporary vari­
able. The sprintf () call overwrites the name field with the name of the temporary 
variable. If the op field is nonnull, an interior node is being processed. In this case, 
trav () does an in-order traversal. The if statement is always true (for now-things 671 
672 Optimization Strategies -Chapter 7 
will change momentarily). The following printf () call prints the instruction, using 
the name fields of the two children to find out what temporaries to use. The strcpy () 
call then overwrites the name field of the current node to reflect the temporary that got 
the result of the last operation. 
Listing 7.5. optimize.c- A Syntax-Tree Traversing, Code-Generation Pass 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 trav( root ) 
struct node *root; 
{ 
static int tnum 0; 
if( 
if( 
{ 
else !root ) 
return; 
!root->op 
printf ( 
sprintf( 
++tnum; /* leaf */ 
"t%d %s\n", tnum, 
root->name , "t%d", 
trav( root->left ); 
if( root->left != root->right 
trav( root->right ); root->name ); 
tnum ) ; 
/* Always true */ 
/* unless optimized */ 
printf("%s %c= %s\n", root->right->name, 
root->op, root->left->name ) ; 
strcpy( root->name, root->right->name ) ; 
7.3.2 Common-Subexpression Elimination 
The code that trav () outputs isn't too great, because the subexpression A*B is 
evaluated twice. It would be better to perform the multiplication only once and use the 
generated rvalue twice. You'd like the following output: 
tO A 
t1 B 
tl *= tO 
tl += tl 
This transformation is called common subexpression elimination, and is a good example 
of the type of optimization that you can do by analyzing, and then modifying, the syntax 
tree. Since both subtrees of the + node are identical, the optimizer can eliminate one 
subtree and make both pointers in the + node point at the remaining subtree. The new 
syntax tree looks like this: 
() 
* 1\ 
A B 
Section 7 .3.2 -Common-Subexpression Elimination 
Both pointers in the + node point at the * node. This modified data structure is called a 
Directed Acyclic Graph or DAG. The DAG is created from the syntax tree by the opt i­
mize ( ) function in Listing 7.6. This routine traverses the interior nodes of the tree, 
comparing the two subtrees. If the subtrees are identical, the left and right pointers of 
the parent node are made to point at the same child, effectively removing the other child 
from the tree. The comparison is done using the makesig () function, which traverses 
an entire subtree, assembling a string that shows the pre-order traversal (visit the root, 
the left subtree, then the right subtree) of the subtree by concatenating all the name 
fields. For example, the original syntax tree, when traversed from the root, creates the 
following signature string: 
+**<A><B><A><B> 
If two subtrees generate the same signature, they're equivalent. 
Brackets are placed around the identifiers because the left and right subtrees in the 
following expression would incorrectly generate the same signatures if they weren't 
there: 
(A * ABB) + (AA * BB) 
Finally, you traverse the DAG using the trav ( ) function that was developed ear­
lier. That if statement now comes into play, preventing us from traversing the common 
subtree twice. 
7.3.3 Register Allocation 
Syntax trees and DAG's are useful for other optimizations as well. The simplest of 
these is efficient register allocation. In general, it's better to use registers than memory 
for temporary variables. It's difficult for the front end to do register allocation efficiently, 
however, because it doesn't know how many registers the target machine has. There are 
two problems with translating temporary-variable references to register references. 
First, you might need more temporary variables than there are registers, and the register 
allocation should be done in such a way that the registers are used as efficiently as possi­
ble: The temporaries that are used most frequently should be put into registers. The 
second issue is subroutine calls imbedded in expressions. If registers are used as tem­
poraries, then they have to be pushed before calling the function and restored afterwards. 
Both of these problems are easily solved by analyzing the parse or syntax tree for an 
expression before generating code for that expression. For example, an expression like 
this: 
carl I philip + emanuel(a+b) *bach 
generates the syntax tree in Figure 7.2 Each interior node in the tree represents the gen­
eration or modification of a temporary variable, and the temporary can appear at several 
interior nodes. The register-versus-nonregister problem is solved by assigning registers 
to those temporaries generated along the longest paths in the tree. Similarly, the optim­
izer can examine that tree and, noticing the function call, can decide to use registers only 
for those temporaries generated after the function returns or, as is the case with the 
function's argument, are pushed as part of the call. 
7.3.4 Lifetime Analysis 
The next structure-related register optimization is lifetime analysis. This optimiza­
tion takes care of a situation like the following: 673 
Directed acyclic graph 
(DAG). 
674 Optimization Strategies -Chapter 7 
Listing 7.6. optimize.c- A Subroutine for Common-Subexpression Elimination 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill optimize( root 
node *root; /* Simplified optimizer--eliminates common subexpressions. */ 
{ 
char sig1[ 32 ]; 
char sig2[ 32 ]; 
if( root->right && root->1eft 
{ 
optimize( root->right ); 
optimize( root->1eft ); 
*sig1 = *sig2 = '\0'; 
makesig( root->right, sig1 ); 
makesig( root->1eft, sig2 ); 
if( strcmp( sig1, sig2 ) == 0 
root->right = root->1eft ; /* subtrees match */ 
makesig( root, str ) 
node 
char 
{ *root; 
*str; 
if( !root 
return; 
if( isdigit( *root->name ) 
strcat( str, root->name ); 
else 
strcat( "<", root->name ); 
strcat( str, root->name ); 
strcat( ">", root->name ) ; 
makesig( root->1eft, str ); 
makesig( root->right, str ) ; 
int i, j; 
for( i 10000; --i >= 0 
for( j = 10000; --j >= 0 ; ) 
If the target machine has only a limited number of registers available for variables (say, 
one), then the register keyword can't be used effectively to improve the foregoing 
code. Ideally, because i is used only in the first loop and j only in the second, i should 
be placed in a register while the first loop is being executed, and j should be in a register 
while the second loop is executed. This determination can be made by analyzing the 
parse tree. In the simplest case, if a variable is found in only one subtree, then its life­
time is restricted to the code represented by that subtree. More sophisticated analysis 
can handle the more complex cases. For example, variables used for loop control can be 
given precedence over the variables in the loop body, unless the ones in the body are 
Section 7.3.4-Lifetime Analysis 
Figure 7.2. Using the Syntax Tree for Register Allocation 
_ , You can use registers here because these 
+ ..::._-- 1 I nodes are visited after the function is called. ~/: ~ ~ 
* ~~ I ~ 
~~;:.---,, bach carl ,' philip 
I 
emanual ( + ) 
Don't use a register here because this 
evaluation precedes the function call. ~ 
b a 
used more frequently than the control variables. 
7.3.5 Loop Unwinding \ 
You can use a register here because the 
intermediate value is pushed onto the 
stack as part of the function call. 
Loop unwinding is a method of optimizing loop execution speed, usually at the cost 
of code size. Put simply, the optimizer replaces the entire loop with the code that 
comprises the loop body, duplicated the number of times that the loop would execute at 
run time. This optimization, clearly, can be done only when the loop-control criteria can 
be computed at compile time. A loop like this: 
for( i = 3; --i > 0 ; ) 
foo(i); 
can be replaced with the following code: 
foo(3); 
foo(2); 
foo(l); 
i = 0; 
Something like this: 
int array [10]; 
for( p = array; p <= array + 2; ++p ) 
foo( p ) ; 
can be translated as follows: 
rO.pp = array; 
foo( rO.pp ) 
rO.pp += sizeof(int); 
foo( rO.pp ) 
rO.pp += sizeof(int); 
foo( rO.pp ) 
rO.pp += sizeof(int); 
_p = WP( rO.pp ); 
7.3.6 Replacing Indexes with Pointers 
If the values of an array index can be computed at compile time, not only can the 
loop be unwound, but the inefficient array indexes can be replaced by direct pointer 
operations. For example, this loop: 675 
676 
Hoisting variables. 
Code-motion problems. for( i = 0; i <= 2 ; ++i 
array[i] = Oxff 
can be translated as follows: 
rO.pp = array; 
W(rO.pp) = Oxff; 
rO.pp += sizeof(int); 
W(rO.pp) = Oxff; 
rO.pp += sizeof(int); 
W(rO.pp) = Oxff; 
i = 3; Optimization Strategies -Chapter 7 
Note that the final assignment to i is required in case _ i is used further down in the 
code. Also, i would have to be modified along with rO .pp if it were used in the loop 
body for something other than the array index. 
7 .3. 7 Loop-Invariant Code Motion 
Loop-invariant optimizations analyze the body of a loop and hoist (move above the 
test portion of the loop) all of the code that doesn't change as the loop executes. For 
example, the division in the following loop is invariant: 
for( i = 0; i < 10 ; ++i ) 
array[i] += (numerldenom); 
so you can modify the loop as follows: 
rO.l numer I denom 
for( i = 0; i <= 2 ; ++i ) 
array[i] += rO.l 
The optimizations that we looked at earlier can also be applied here. Applying both 
array-index replacement and loop unwinding, you end up with the following C-code: 
rO.l numer ; 
rO.l I= den om; 
rl.pp array; 
W(rl.pp) rO.l ; 
rl.pp += sizeof (int); 
W (rl.pp) rO.l ; 
rl.pp += sizeof (int); 
W(rl.pp) rO.l ; 
rl.pp += sizeof (int); 
i = 3; 
Note that hoisting division can cause problems if you're not careful. The following 
example bug is lifted from the Microsoft C (ver. 5.1) documentation. This loop: 
for( i = 0; i <= 2 ; ++i ) 
if( denom != 0 ) 
array[i] += (numerldenom); 
is optimized as follows: 
rO.l numer I denom 
for( i = 0; i <= 2 ; ++i 
if ( denom ! = 0 ) 
array[i] += rO.l 
The division is moved outside the loop because it's invariant, but the preceding test is 
not moved with it. You'll now get a run-time divide-by-zero error if denom happens to 
Section 7.3.7-Loop-Invariant Code Motion 
be zero. 
You, as a compiler writer, must decide if it's worth the risk of doing this kind of 
optimization. It's difficult for the compiler to distinguish between the safe and 
dangerous cases, here. For example, many C compilers perform risky optimizations 
because the compiler writer has assumed that a C programmer can understand the prob­
lems and take steps to remedy them at the source code level. It's better to provide the 
maximum optimization, even if it's dangerous, than to be conservative at the cost of less 
efficient code. A Pascal programmer may not have the same level of sophistication as a 
C programmer, however, so the better choice in this situation might be to avoid the risky 
optimization entirely or to require a special command-line switch to enable the optimiza­
tion. 
7.3.8 Loop Induction 
Loop induction is a sort of strength reduction applied to loop-control statements. 
The optimizer tries to eliminate the multiplication implicit in array indexing by replac­
ing it with the addition of a constant to a pointer. For example, a loop induction on a 1 
modifies this code 
int a1 [10] [10], a2 [10] [10]; 
for( i = 0; i < 10; ++i ) 
for ( j = 0 ; j < 1 0 ; ++ j ) 
a1 [i] [j] = a2 [i] [j]; 
as follows: 
t1 = array + 10; 
for( tO = a1; tO < t1; tO += 20 ) 
{ 
t3 = tO + 20; /* 20 
/* 20 
for( t2 
*t2 tO; t2 < t3; t2 += sizeof(int) ) 
a2 [ i J [ j l ; 
j 10; 
i 10; 
7.4 Aliasing Problems 10 * sizeof(int) */ 
10 * sizeof(int) */ 
Many of the loop optimizations have problems with pointer aliasing-code in which 
a memory location can be accessed in more than one way (both by a pointer and directly, 
or by two pointers that contain the same address). For example, the following code 
creates an alias because both x and *prefer to the same memory location: 
prometheus () 
{ 
int x, *p = &x; 
Similarly, the following code creates less obvious aliases : 677 
678 
pyramus () 
{ 
int array [ 93] ; 
thisbe( array, array); 
thisbe( pl, p2 
int *pl, *p2 Optimization Strategies -Chapter 7 
/* *pl and *p2 alias one another, here */ 
int x; 
pandora() 
{ 
int *p &x; 
/* *p is an alias for x, here */ 
The problem here is that the loop optimizations might modify one of the aliased vari­
ables without modifying the other one-the compiler has no way to know that the two 
variables reference the same object. 
7.5 Exercises 
7.1. Write a subroutine that multiplies two arbitrary ints using nothing but shift and 
multiply operations. The result should be returned in a long. 
7.2. (a) Modify the compiler in the last chapter to replace all multiplication by con­
stants with shift/add sequences and to replace all division by constants with 
shift/subtract sequences. 
(b) Do the foregoing with a separate optimizer pass instead of modifying the com­
piler proper. 
7.3. Write a peephole optimizer that works on the code generated by the compiler in the 
last chapter. At very least, it should do constant folding, dead-variable elimination, 
and dead assignment elimination. 
7.4. Add an assignment operator (=) to the postfix tree constructor and optimizer 
presented earlier in this chapter. The input: 
a 
b 
+ 
a 
b 
+ 
* 
c 
should generate the following: 
tO a 
tl b 
t1 *= tO 
tl += tl 
c tl 
Your program must be able to handle expressions like: 
Section 7.5-Exercises 
a = b = c 
which should be translated to the following: 
c 
b 
a 
7.5. Modify your solution to the previous exercise to support the following C operators: 
+ * I % & 
< > <= >= 
++ && ( 
II 
Standard associativity and precedence should be used. 
7.6. (a) Modify the compiler in the previous chapter to generate a postfix intermediate 
language instead of C-code. 
(b) Write an optimizer pass that does common-subexpression elimination on that 
postfix intermediate code. 
(c) Write a back end that traverses the syntax tree created by the common­
subexpression optimizer and generates C-code. 679 
Directories used. A 
Support Functions 
This appendix contains a myriad small subroutines that are used throughout the rest 
of the book. Collectively, they comprise a library called comp.lib. A few of the routines 
in this library are described elsewhere (the input and table-printing functions in Chapter 
Two, for example), but I've concentrated the other routines in one place so that the rest 
of the book won't be cluttered with distracting references to small subroutines whose 
function is not directly applicable to the matter at hand. It's important that you are fam­
iliar with the routines in this appendix, however-at least with the calling conventions, if 
not with the code itself. 
Since straight code descriptions can be pretty deadly reading, I've organized each 
section to start with a description of subroutine-calling conventions and a discussion of 
how to use the routines in that section. This way, you can skip the blow-by-blow code 
descriptions if you're not interested. Most of the code is commented enough so that 
additional descriptive text isn't necessary. There's no point in making an overly long 
appendix even longer with descriptions of things that are obvious by reading the code. 
Of the subroutines in this appendix, you should be particularly familiar with the 
<toolsldebug.h> file described in the next section and with the set and hash-table func­
tions described in the sections after that. It's worthwhile to thoroughly understand this 
code. You need to be familiar only with the calling conventions for the remainder of the 
functions in this appendix, however. The sources are presented, but they're not manda­
tory reading. 
The auxiliary files and subroutines described here are organized into several direc­
tories. Sources for subroutines of general utility are all in /src/tools, those that are more 
directly compiler related are in /src/compilerllib. Most of the #include files used by 
the routines in this chapter are in /include/tools, and they are included with a 
#include <tools/whatever. h> (I've set up /include as my default library direc­
tory). The one exception is curses.h, which is in /include itself, so that you can use a 
UNIX-compatible #include <curses. h>. 
680 
Section A.l-Miscellaneous Include Files 
A.1 Miscellaneous Include Files 
Many .h files are included at the tops of the various .c files presented in this book. 
With the exception of the files discussed in this chapter, all files included with angle 
brackets ( <stdio.h>, <signal.h>, and so forth) are ANSI-compatible, standard-library files 
and should be supplied by your compiler vendor (in this case, Microsoft). If they aren't, 
then your compiler doesn't conform to ANSI and you'll have to work a little harder to port 
the code presented here. Most of these standard .h files are also supported by UNIX­
those that aren't are supplied on the distribution disk so that you can port the code to 
UNIX without difficulty. 
A.1.1 dehug.h-Miscellaneous Macros 
The dehug.h file is #incl.uded in virtually every .c file in this book. It contains 
several macro definitions that are of general utility, and sets up various definitions that 
are useful in debugging. It also contains several macros that take care of various 8086 
portability issues. (It's useful, by the way, to look at the 8086-related macros even if 
you're not using an 8086-not only will you get a good idea of the things that you have 
to consider in order to make your code portable in general, but, since the 8086 is such a 
pervasive architecture, a specific knowledge of the machine lets you write your code so 
that it can be as portable as possible in any environment. It's a mistake to assume that 
your code will never have to move to the 8086 environment.) 
Listing A.l. debug .h-Miscellaneous Macros of General Utility 
I 
2 
3 
4 
5 
6 
7 
8 
9 #ifdef 
# 
# 
#else 
# 
# 
#endif 
#define 
#ifdef 
# 
# # # 
#else 
# 
# 
# 
#endif DEBUG 
define PRIVATE 
define D (x) X 
define PRIVATE 
define D (X) 
PUBLIC 
MSDOS 
define MS(x) X 
define UX(x) 
define ANSI 
define 8086 
define MS(x) 
define UX(x) x static 
define O_BINARY 0 /*no binary input mode in UNIX open() */ 
typedef long time t; /* for the VAX, may have to change this */ 
typedef unsigned size_t; /* for the VAX, may have to change this */ 
extern char *strdup(); /* You need to supply one. */ 
ANSI 
P (X) X 
VA LIST /* If ANSI is defined, put arg lists into 
/* function prototypes. 
/* and use ellipsis if a variable number of args *I 
*I 
*I 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 #ifdef 
#define 
#define 
#else 
#define 
#define 
#define 
#endif P(x) () /*Otherwise, discard argument lists and translate*/ 
void char /* void keyword to int. */ 
VA LIST _a_r_g_s /* don't use ellipsis */ 681 
682 Support Functions-Appendix A 
Listing A.l. continued ... 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
DEBUG /* SEG (p) 
* OFF (p) 
* PHYS (p) 
*I Evaluates to the segment portion of an 8086 address. 
Evaluates to the offset portion of an 8086 address. 
Evaluates to a long holding a physical address 
#ifdef 8086 
#define SEG(p) ( ((unsigned *)&(p)) [1] ) 
#define OFF(p) ( ((unsigned *)&(p)) [OJ ) 
#define PHYS(p) (((unsigned long)OFF(p)) + ((unsigned long)SEG(p) << 4)) 
#else 
#define PHYS(p) (p) 
#endif 
/* NUMELE (array) 
* LASTELE(array) 
* INBOUNDS(array,p) 
* RANGE(a,b,c) 
* max(a,b) 
* min (a, b) 
* 
* NBITS (type) 
* 
* MAXINT 
*I 
#define NUMELE(a) 
#define LASTELE(a) 
#define TOOHIGH(a,p) 
#define TOOLOW(a,p) 
#define INBOUNDS(a,p) Evaluates to the array size in elements 
Evaluates to a pointer to the last element 
Evaluates to true if p points into the array. 
Evaluates to true if a <= b <= c 
Evaluates to a or b, whichever is larger 
Evaluates to a or b, whichever is smaller 
Returns number of bits in a variable of the indicated 
type; 
Evaluates to the value of the largest signed integer 
(sizeof(a)/sizeof(*(a))) 
((a) + (NUMELE(a)-1)) 
((p) -(a) > (NUMELE(a) -1)) 
( (p) -(a) < 0 ) 
( ! (TOOHIGH(a,p) II TOOLOW(a,p)) 
#define IS (t, x) ( ( (t) 1 << (x))! =0) /* Evaluate true if the width of a *I 
/* variable of type of t is < x. The !=0 */ 
/* assures that the answer is 1 or 0 */ 
#define NBITS (t) (4 * (1 + 
+ IS(t, 4) + 
IS(t,20) + 
#define MAXINT (((unsigned)-0) >> 1) 
#ifndef max IS(t, 8) + 
IS(t,24) + 
# define max (a, b) ( ((a) > (b)) ? (a) (b)) 
#endif 
#ifndef min 
# define min (a,b) ((a) < (b)) ? (a) : (b)) 
#endif 
#define RANGE(a,b,c) ( (a) <= (b) && (b) <= (c) IS(t,12) + 
IS(t,28) + IS (t, 16) \ 
IS(t,32) ) 
local objects: PRIVATE. The debugging versions of several macros are activated when DEBUG is #defined 
(either with an explicit #define or, more commonly, with a -DDEBUG on the 
compiler's command line) before <tools!debug.h> is included. The PRIVATE definition 
on line two expands to an empty string in this case-it effectively disappears from the 
input. When DEBUG is not defined, the alternative definition on line five is activated, so 
all PRIVATE variables become static variables when you're not debugging. This 
mechanism lets you put normally invisible variables and subroutines into the link 
map--so that you know where they are when you're debugging-and then limit their 
scope to the current file when debugging is completed. The complement to PRIVATE is 
Section A.I.I-debug .h-Miscellaneous Macros 
PUBLIC, defined on line eight. It is provided for documentation purposes only­
PUBLIC variables and subroutines are those whose scope is not limited. 
The D (x) macro on lines three and six is used for printing debugging diagnostics. 
When DEBUG is defined, the macro expands to its argument, so 
D( printf("a diagnostic\n"); ) 
expands to 
printf("a diagnostic\n"); 
Note that the semicolon is inside the parentheses. When DEBUG is not defined, the macro 
expands to an empty string and the argument is discarded. The earlier "printf( )" state­
ment goes away. This method is preferable to the more usual 
#ifdef DEBUG 
printf("a diagnostic\n"); 
#endif 
for several reasons: it's more readable; it requires only one line, rather than three; it 
doesn't mess up your indentation (many compilers require the # to be in the leftmost 
column). A multiple-line argument to D (x) must be done with backslashes, like this: 
D(printf("%s in de %s wit' dinah, strumn' on de ol' %s",\ 
someone, "kitchen", "banjo" ) ; ) 683 
Global objects: PUBLIC. 
Debugging diagnostics, 
D (). 
There's a potential problem here in that commas that are part of the argument to D () can Commas in the o <I 
be confused with the comma that separates macro arguments. ANSI says that commas macro argument. 
enclosed by parentheses are not to be treated as argument separators (which is why the 
previous definition worked). Your compiler may not handle this case correctly, however. 
In any event, you'll have to parenthesize expressions that use the comma operator to pass 
them toD (): 
D( (statementl,statement2); ) 
It's better style to use two D () invocations, however: 
D( statementl; ) 
D( statement2; ) 
The macros on lines ten to 22 help you write portable code. The arguments to MS ( ) 
are incorporated into the program only ifMSDOS is #defined (it's defined automatically 
by the Microsoft compiler). Arguments to ux () (for UNIX) are active only if MSDOS is 
missing. I've also defined ANSI and 8086 macros that are active only ifMSDOS is also 
active. Move the ANSI definition outside of the #ifdef if you've an ANSI-compatible 
UNIX compiler. 
The P macro on lines 25 and 28 handles another ANSI-related portability problem. 1 
Many compilers (including many UNIX compilers) can't handle function prototypes. 
This macro uses a mechanism similar to the D () macro discussed earlier to translate pro­
totypes into simple extern declarations if ANSI is not defined. For example, given the 
following input: 
int dimitri P(( int x, long y )); 
if ANSI is defined, the P (x) macro evaluates to its argument and the following 
I. This macro is taken from [Jaeschke], p. 142, and is used in the Whitesmiths compiler. UNIX-and MS·DOS-Specific 
code: MS () , ux () . 
ANSI,_8086. 
Transforming function 
prototypes to simple ex­
terns,P (). 
684 
Getting rid of the ellipsis 
in the UNIX environment, 
VA LIST. 
8086-related macros, 
SEG (),OFF(), PHYS (). 
Representing an address 
in the 8086 architecture, 
segment, offset. 
Problems with 
segment:offset address­
ing. 
Near and far pointers. Support Functions-Appendix A 
translation results: 
int dimitri ( int x, long y ); 
otherwise, the macro discards its argument and evaluates to () , so the following will be 
created: 
int dimitri (); 
The ARGS macro on lines 26 and 30 takes care of yet another problem with non-ANSI 
compilers. An ANSI subroutine with a variable number of arguments is defined as fol­
lows: 
printf( format, ... ) 
char *format; 
The trailing ellipsis means "followed by any number of arguments of an arbitrary type." 
Earlier compilers don't support this mechanism. Consequently, you'd like to replace the 
ellipsis with a dummy argument name. You can do this with debug.h using the ARGS 
macro as follows: 
printf( format, VA_LIST 
char *format; 
VA_ LIsT expands to an ellipsis when ANSI is defined, otherwise it expands to the 
dummy argument name _a_ r _g_ s. 
The macros on lines 39 to 41 of Listing A.1 handle portability problems inherent in 
the 8086 architecture. The SEG ( ) and OFF ( ) definition are ignored in other systems, 
and the PHYS () macro just evaluates to its argument in non-8086 environments. Before 
looking at the definitions for these macros, a short discussion of the 8086 internal archi­
tecture is necessary. The 8086 is really a 16-bit machine in that all internal registers are 
16 bits wide. The machine has a 20-bit address space, however. The discrepancy is 
made up by using two registers to create a physical address. An address is formed from 
two 16-bit components representing the contents of the two registers: the segment and 
the offset. These are usually represented as two 4-digit hex numbers separated by a 
colon: 1234:5678. The segment portion is on the left, the offset on the right. A physi­
cal address is formed in the machine using the following formula: 
physical_address == ( segment << 4 ) + offset; 
Three special registers called CS, DS, SS hold the segment components of the addresses 
of objects in the code, data, and stack regions of your program. (A fourth segment regis­
ter, called ES, is used if you need to access an object not in one of these segments). 
This architecture has several ramifications. First, there are two pointer sizes. If the 
segment component doesn't change over the life of the program, only the offset needs to 
be stored; pointers are 16 bits wide in this situation. For example, the DS register 
doesn't have to change if there's less then 64K of data and if the DS register is initialized 
to the base address of that 64K region. All cells within that region can be accessed using 
the fixed DS register by loading a 16-bit offset into the appropriate offset register-the 
segment portion of the address can be loaded once when the program loads. If the data 
area is larger than 64K, then 32-bit pointers composed of a 16-bit segment and a 16-bit 
offset componant must be used. You must load both the segment and offset componants 
into their respective registers to access the target variable. Typically, the segment is 
stored in the top 16 bits of the pointer and the offset is stored in the bottom 16 bits. The 
physical address is not stored. A 32-bit pointer that has both a segment and offset com­
ponent is called a far pointer; a 16-bit pointer containing the offset component only is 
called a near pointer. Note that a program can have 16-bit data pointers and 32-bit func­
tion pointers and vice versa, depending on how much code or data there is. 
Section A.l.l-debug.h-Miscellaneous Macros 
One of the other problems with the segmented architecture is that there are 4,096 
ways to address every physical cell in memory. For example, the following all address 
physical address OxlOOOO: 1000:0000, OFFF:OOIO, OFFE:0020, OFFD:0030, and so 
forth. 
ThePHYS (p) macro on line 41 of Listing A.1 evaluates to the physical address asso­
ciated with an 8086 32-bit, far pointer-a pointer in which both the segment and offset 
components of the address are stored. It computes this address using the same procedure 
used by the 8086 itself, shifting the segment component left by four bits and adding it to 
the offset. The segment and offset portions are extracted by the SEG and OFF macros on 
the previous two lines, reproduced here: 
#define SEG(p) ( ((unsigned *)&(p)) [1] ) 
#define OFF(p) ( ((unsigned *)&(p)) [0] ) 
Taking SEG () as characteristic, & (p) creates a temporary variable of type pointer-to­
pointer which holds the address of that pointer in memory. & (p) can be treated as if it 
were the base address of an array of pointers-* ( & p) and ( & p) [ 0] both evaluate to p 
itself. The cast of (unsigned *) changes things, however. Now instead of being 
treated as an array of pointers, &p is treated as a two-element array of 16-bit 
unsigned ints, which are half the size of a pointer. The [ 1] picks up 16 bits of the 
32-bit pointer, in this case the segment half. The [ 0] gets the offset half. These two 
macros are not at all portable, but they're more efficient than shift-and-mask operations, 
which are. 
The NBITS (type) macro on line 68 of Listing A.l evaluates to the number of bits 
in a variable of a particular integral type on the current machine. (NBITS (int) evalu­
ates to the number of bits in an int.) It assumes that this number is 8, 16, 32, or 64, but 
the macro is easily modified to accept other values. The_ Is macro on the previous line 
tests for one of these possibilities: 
#define IS(t,n) (((t)l« (n))!=O) 
It is passed the type (t) and the current guess (n). It casts the number 1 into the correct 
type, and then shifts that number to the left by the required number of bits. The resulting 
binary number for several shift values and a 16-bit-wide type are shown below: 
n 1 <<n 
0 0000000000000001 
4 0000000000010000 
8 0000000100000000 
12 0001000000000000 
16 0000000000000000 
32 0000000000000000 
The expression evaluates to 0 if a variable of type t contains fewer than n bits. The 
NBITS macro, adds together several terms, one for each group of four bits in the number. 
For example, when an int is 16 bits wide, IS (int, 4), IS (int, 8), and 
_IS (int, 12) all evaluate to 1. The other terms evaluate to 0. Multiplying by four 
adjust the result to an actual bit count. I should point out that this macro, though huge, 
usually evaluates to a single constant at compile time. Since all the arguments are con­
stants, none of the arithmetic needs to be done at run time. It's size might cause prob­
lems with your compiler's running out of macro-expansion space, however. Also, note 
that some compilers use greater precision for compile-time calculations than is available 
at run time--NBITS () won't work on these compilers. 
MAXINT, on line 71, evaluates to the largest positive, two's-complement integer. 
(unsigned) 0 evaluates to an unsigned int with all bits set to 1. The left shift 685 
Finding a physical ad­
dress on an 8086, 
PHYS (). 
Isolating segment and 
offset components, 
SEG () , OFF () . 
Number of bits required 
for a type, NBITS (). 
Finding the largest in­
teger, MAXI NT. 
686 
Array-manipulation mac­
ros: NUMELE () , 
LASTELE(),TOOHIGH(), 
TOOLOW(),INBOUNDS(). 
Maximum and minimum 
values, max () , min (), 
RANGE(). 
Create a stack. Support Functions-Appendix A 
puts a zero into the high bit-the cast to (unsigned) defeats any potential sign exten­
sion on the right shift. 
The definitions on lines 58 to 62 of Listing A. I are for array manipulations. NUMELE 
is passed an array name and evaluates to the number of elements in the array. LASTELE 
evaluates to the address of the last element in the array. TOOHIGH (array, p) evaluates 
to true only if the pointer pis above the array. TOOLOW(array,p) is true ifp is 
beneath the start of the array.2 INBOUNDS (array, p) is true ifp is in bounds. 
The macros on lines 73 to 79 of debug.h test for various ranges of integer values. 
max (a, b) evaluates to a orb, whichever is larger; min (a, b) evaluates to a orb, 
whichever is smaller; and RANGE (a, b, c) evaluates to true if a:::;; b:::;; c. 
A.1.2 stack.h and yystack.h-Generic Stack Maintenance 
Compilers tend to use stacks a lot. To simplify stack maintenance, a series of macros 
that declare and manipulate stacks of an arbitrary, nonaggregate type, are declared in 
stack.h. The macros are used as follows: 
stack_dcl(stack, type, size) 
This macro creates a stack consisting of size objects of the given type. The 
type can be a simple type (like int and lonq) or a pointer (like char*, 
lonq* *, and struct f oo * ). Stacks of aggregate objects like structures and 
arrays are not supported, however. Note that very complex types (like pointers to 
arrays) are best defined with a previous typedef, like this: 
typedef int (*ptr_to_10_element_array) [10]; 
stack_dcl( stack, ptr_to_10_element_array, 128 ) ; 
otherwise they might not compile. 
The stack_ del macro declares three objects, the names of which are all derived 
from the stack argument as follows: 
stack 
p_stack 
t stack 
If you put a definition of the form 
#undaf stack cls 
#define stack_cls static 
somewhere after the #include <tools/stack .h>, then the stack and stack 
pointer will have the indicated storage class (static here). 
2. Though ANSI requires that a pointer be able to point just past the end of an array, it does not allow a pointer 
to go past the start of the array. This behavior has serious practical ramifications in the 8086 compact and 
large models, and you won't be able to use TOOLOW with these memory models. Most 8086 compilers 
assume that no data object in the compact or large model is larger than 64K. Consequently, once the 
initial segment-register load is performed, only the offset portion of the address needs to be checked or 
modified when a pointer is modified. This practice causes problems when the base address of the array is 
close to the bottom of a segment. If, for example, an integer array is based at 2000:0000, a pointer 
increment correctly yields the address 2000:0002, but a decrement will yield 2000:FFFE rather than 
IOOO:FFFE because the segment portion of the address won't be modified. This incorrect pointer is treated 
as very large, rather than very small. 
Section A.l.2-stack. h and yystack.h -Generic Stack Maintenance 
stack_p(stack) 
This macro evaluates to the name used internally for the stack pointer. (See also: 
stack_ ele (),below.) 
push(stack, x) 
Push x onto the stack. The stack argument must have appeared in a previous 
stack_ del () invocation. This macro checks for stack overflow and invokes 
the stack_ err() macro, discussed below, if the stack is full. (The default 
action prints an error message and terminates the program.) The 
push_ (stack, x) does no overflow checking, so it is faster. 
pop(stack) 
Pop an item off the stack (like this: x = pop (stack);). The stack argument 
must have appeared in a previous stack_ del () invocation. This macro checks 
for stack underflow and invokes the stack_err macro, discussed below, if the 
stack is empty. (The default action prints an error message and terminates the 
program.) The pop_ (stack) macro does no underflow checking, so it is faster. 
popn(stack,amt) 
This macro pops amt elements from the indicated stack, and evaluates to the ele­
ment that was at the top of stack before anything was popped. There's also a 
popn _ (stack, amt) macro, which does no underflow checking, but is other­
wise the same as popn ( ) . 
stack_clear(stack) 
This macro sets the stack back to its initial, empty condition, discarding all stack 
elements. 
stack_ele(stack) 
This macro evaluates to the number of elements currently on the indicated stack. 
stack_empty(stack) 
This macro evaluates to true if the stack is empty. 
stack_full(stack) 
This macro evaluates to true if the stack is full. 
stack_item(stack,offset) 
Evaluates to the item at the indicated offset from the top of the stack. Note that 
no range checking is done to see if offset is valid. Use stack_ ele () to do 
this checking if you need it. 
stack_err(overflow) 
This macro is invoked to handle stack errors. The overflow argument is 1 if a 
stack overflow occurred (you tried to push an item onto a stack that was full). It's 
zero on an underflow (you tried to pop an item off an empty stack). The default 
action prints an error message and terminates the program, but you can #undef 
this macro and redefine it to do something more appropriate if you like. If this 
macro evaluates to something, that value will, in turn, come back from the push 
or pop macros when an error occurs. For example: Access stack pointer 
directly. 
Push an element. 
Pop an element. 687 
Pop multiple elements. 
Reinitialize stack. 
Get number of elements. 
Test for stack empty. 
Test for stack full. 
Access arbitrary element. 
Stack error handler. 
688 Support Functions-Appendix A 
Stack-macro implementa­
tion. 
The ANSI concatenation 
operator, i#. 
Downward-growing 
stacks are used for ANSI 
compatibility. 
Pushing and popping, 
push() ,push_(), 
pop () , pop_ () , popn () , 
popn_ (). 
Stack-macro error pro­
cessing, stack_ err () . 
Double cast needed to 
convert int to pointer. 
Stack macros for occs, 
<yystack.h>. #undef stack err 
#define stack_err(overflow) 0 
will cause both push and pop to evaluate to 0 if an overflow or underflow occurs. 
The stack macros are implemented in stack.h, Listing A.2. These macros make 
heavy use of the ANSI concatenation operator, ##. This operator is removed from a 
macro definition by the preprocessor, effectively concatenating the strings on either side 
of it. For example, given the invocation 
stack_dcl(plates,int,128); 
the typedef on line seven of Listing A.2 evaluates, first to 
typedaf int t_##plates; 
(the int replaces type in the definition, the plates replaces stack) and then the## is 
removed, yielding: 
typedef int t_plates; 
Lines eight and nine will evaluate as follows: 
t_plates plates[128]; 
t_plates *(p_plates) =plates+ (128); 
given the earlier stack_ del() invocation. A downward-growing stack is created, so 
the stack pointer (p _plates) is initialized to just past the end of the stack. This initiali­
zation works correctly in ANSI C, which says that pointer can point one cell beyond the 
end of an array and still be valid, but a pointer is not permitted to go to the left of the 
array. 
Since a downward-growing stack is implemented, a push is a predecrement (on line 
23) and a pop is a postincrement (on line 31). This way the stack pointer always points 
at the top-of-stack item. The actual push and pop operations have been isolated into the 
push_ () and pop_ () macros because it's occasionally useful to do a push or pop 
without checking for stack overflow or underflow. Note that the popn _ ( ) macro on line 
34 must evaluate to the top-of-stack element before anything is popped. A postincre­
ment is simulated here by modifying the stack pointer by amt elements, and then reach­
ing backwards with a [ -amt] to get the previous top-of-stack element. 
The stack_ err () macro on lines 39 and 40 use ferr to print an error message and 
then exits the program. (ferr () works like print f () except that it sends characters 
to stderr and calls exit ( 1) when it's done. It is discussed in depth below). In 
theory, the entire expression evaluates to ferr () 's return value, but since ferr () 
doesn't return, it's not really an issue here. 
You need two casts on lines 27 and 31 where stack_err () is invoked because 
there's no telling what sort of value to which the macro will evaluate. The default 
ferr () call evaluates to an int, but since stack_ err () can be redefined, you can't 
count on that. The stack type is also uncertain because it can be redefined. You can't 
just cast stack_err () to the same type as the stack because the stack might be an 
array of pointers-many compilers complain if you try to convert an int to a pointer. 
So you have to cast twice-first to long and then to the stack type-to suppress this 
error message. Though casting to long as an intermediate step fixes this problem, 
though it might introduce an unnecessary conversion if the stack type is an int, short, 
or char. These multiple type conversions will also cause portability problems if the 
stack_ err () macro evaluates to something that won't fit into a long (like a double). 
A second set of stack macros are in the file <yystack. h>, Listing A.3. These mac­
ros differ from the ones just described in three ways only: all the macro names are pre­
ceded by the characters yy, the generated names are prefaced by yyt _and yyp _rather 
Section A.1.2-stack.h and yystack.h--Generic Stack Maintenance 
Listing A.2. stack.h- Stack-Maintenance Macros 
1 
2 
3 
4 
5 
6 
7 
8 
9 /* Stack.h 
* Stack-maintenance macros. Creates downward-growing stacks 
(which should work in all six memory models). 
*I 
#define stack cls /* empty */ 
#define stack_dcl(stack,type,size) typedef type t_##stack; \ 
#define stack_clear(stack) 
#define stack_full(stack) 
#define stack_empty(stack) stack cls t ##stack stack[size]; \ 
stack=cls t=##stack (*p_l#stack) \ 
(p_Ustack) = stack + (size) 
(stack + \ 
sizeof(stack)/sizeof(*stack)) 
(p l#stack) <= stack ) 
(p=llstack) >= (stack + \ 
sizeof(stack)/sizeof(*stack)) 689 
lO 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 #define stack_ele(stack) ((sizeof(stack)/sizeof(*stack)) -(p_##stack-stack)) 
#define stack_item(stack,offset) ( *(p ##stack+ (offset)) 
#define stack_p(stack) p_##stack 
#define push_(stack,x) 
#define pop_(stack) 
#define push(stack,x) 
#define pop(stack) 
#define popn_(stack,amt) 
#define popn( stack,amt) 
#define stack_err(o) *--p_##stack = (x) 
*p_##stack++ 
stack full(stack) 
? ((t_llstack) (long) (stack_err(l))) 
: push_(stack,x) 
stack_empty(stack) 
? ((t_llstack) (long) (stack_err(O))) 
: pop_(stack) 
(p_##stack += amt) [-amt] 
(stack_ele(stack) < amt) 
? ( (t_##stack) (long) (stack_err (0))) 
: popn_(stack,amt) 
((o) ? ferr("Stack overflow\n" \ 
ferr("Stack underflow\n") ) 
than t _and p _,and I've abbreviated yystack to yystk. The second set of macros are 
used only within the LLama-and occs-generated parsers. The extra yy avoids potential 
name conflicts with user-supplied names. 
A.1.3 l.h and compiler.h 
Two other include files are of interest: l.h contains prototypes for the routines in 
l.lib, (which contains run-time subroutines for I.FX and occs-generated programs); 
compiler.h contains prototypes for the routines in comp.lib (which contains subroutines 
used by IJ'X and occs themselves). These files are not listed here because they are 
created automatically from within the makefile that creates the library. The Microsoft 
compiler's !Zg switch-which outputs prototypes for all functions in the input file rather 
than compiling the file-is used. Copies of the prototype files are included on the distri­
bution disk, however,-and they are #included by most of the source files in this book. \ 
\ 
) 
\ \ 
) 
\ 
\ 
) 
690 Support Functions-Appendix A 
Listing A.3. yystack.h- Stack-Maintenance Macros: LLama/Occs Version 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 I* yystack.h 
*I Stack-maintenance macros ---yacc and llama version. 
#define yystk_cls I* empty *I 
idefine yystk_dcl(stack,type,size) typedef type yyt #istack; \ 
yystk cls yyt ##;tack stack[size]; \ 
yystk=cls yyt=##stack (*yyp_##stack) \ 
= stack + (size) 
idefine yystk_clear(stack) ( (yyp_iistack) (stack + \ 
sizeof(stack)lsizeof(*stack)) 
#define yystk_full(stack) 
#define yystk_empty(stack) 
idefine yystk_ele(stack) (yyp ##stack) <= stack ) 
(yyp=##stack) >= (stack + \ 
sizeof(stack)lsizeof(*stack)) 
((sizeof(stack)lsizeof(*stack)) - \ 
(yyp_##stack-stack)) 
#define yystk_item(stack,offset) 
#define yystk_p(stack) ( *(yyp_##stack + (offset)) ) 
yyp_##stack 
#define yypush_(stack,x) 
#define yypop_(stack) 
#define yypush(stack,x) 
#define yypop(stack) 
#define yypopn_(stack,amt) 
#define yypopn( stack,amt) 
#define yystk_err(o) *--yyp i#stack = (x) 
*yyp_#istack++ 
yystk full(stack) 
? ((yyt_##stack) (long) (yystk_err(l))) 
: yypush_(stack,x) 
yystk empty(stack) 
? ((yyt_#istack) (long) (yystk_err(O))) 
: yypop_ (stack) 
(yyp_##stack += amt) [-amt] 
(yystk_ele(stack) < amt) 
? ( (yyt_##stack) (long) (yystk_err (0))) 
yypopn_(stack,amt) 
((o) ? ferr("Stack overflow\n" \ 
ferr("Stack underflow\n") ) 
A.2 Set Manipulation \ 
\ 
) 
\ 
\ 
) 
\ 
\ 
) 
Bit maps. Many of the operations involved in compiler writing-like creating state-machine 
tables from regular expressions and creating bottom-up parse tables from a grammar­
involve operations on sets, and C, unlike Pascal, doesn't have a built-in set capability. 
Fortunately, it's not too hard to implement sets in C by means of bit maps--one­
dimensional arrays of one-bit numbers. This section presents a package of bit-map­
based, set-manipulation routines. 
<tools/set.h>, SET. A.2.1 Using the Set Functions and Macros 
To use the set routines, you must put a #include <tools I set. h> at the top of 
your file. The definitions for a SET are found there, and many of the set functions are 
actually macros defined in <tools!set.h>. The set routines are described in the following 
paragraphs. I'll give a few examples after the calling-conventions are described. If a 
Section A.2.1-Using the Set Functions and Macros 
name is in all caps in the following list, it's implemented as a macro, and most of these 
macros have side effects. Be careful. 
SET *newset(void) 
Create a new set and return a pointer to it. Print an error message and raise 
SIGABRT if there's insufficient memory. Normally this signal terminates the pro­
gram but you can use signal() to change the default action (the process is 
described in a moment). NULL is returned if raise () returns. 
void delset(SET *set) 
Delete a set created with a previous newset call and free the associated memory. 
The argument must have been returned from a previous new set () call. 
SET *dupset(SET *set) 
Create a new set that has the same members as the input set. This routine is 
more efficient than using newset ( ) to create the set and then copying the 
members one at a time, but otherwise has the same effect. 
int _addset(SET *set, int bit) 
This is an internal function used by the ADD macro, and shouldn't be called by 
you. 
int num_ele(SET *set) 
Return the number of elements in the input set. NULL sets (described below) 
are considered to be empty. 
int _set_test(SET *setl, SET *set2) 
This is another workhorse function used internally by the macros. Don't call it 
directly. 
int setcmp(SET *setl, SET *set2) 
Compare two sets in a manner similar to strcmp () returning 0 if the sets are 
equivalent, <0 if setl<set2 and >0 if setl>set2. This routine lets you sort an array 
of SET's so that equivalent ones are adjacent. The determination of less than and 
greater than is pretty much arbitrary. (The routine just compares the bit maps as 
if you were doing a lexicographic ordering of an array of ints.) 
unsigned sethash(SET *setl) 
This function is even more obscure than setcmp (). It is provided for those 
situations where a SET is used as the key in a hash table. It returns the sum of the 
individual words in the bit map. 
int subset(SET *set, SET *sub) 
Return 1 if sub is a subset of set, 0 otherwise. Empty and null sets are subsets 
of everything, and 1 is returned if both sets are empty or null. 
void _set_op(int op, SET *dest, SET *src) 
Another workhorse function used internally by the macros. 
void invert(SET *set) 
Physically invert the bits in the set, setting 1 's to 0 and vice versa. In effect, this 
operation removes all existing members from a set and adds all possible members 691 
Create a set. 
Delete a set. 
Duplicate a set. 
Internal set function: en­
large set. 
Find number of elements 
in set. 
Internal set 
function: test bits. 
Compare two sets. 
Compute hash value for 
set. 
Sub is subset of set. 
Internal set function: 
binary operations. 
Complement set by in­
verting bits. 
692 
Clear set and make 
smaller. 
Find next set element. 
Print set elements. 
dest = dest u src. 
dest = dest n src. 
dest = symmetric 
difference. 
dest = src. 
Clear set. 
Add all elements to set. 
Complement set. Support Functions-Appendix A 
that weren't there before. Note that the set must be expanded to the maximum 
possible size before calling invert ()-ADD the largest element and then delete 
it. See also, COMPLEMENT () . 
void truncate(SET *set) 
Clears the set and shrinks it back to the original, default size. Compare this rou­
tine to the CLEAR () macro, described below, which clears all the bits in the map 
but doesn't modify the size. This routine is really a more efficient replacement for 
del set ( s) ; s=newset () ; . If the original set isn't very big, you're better off 
using CLEAR ( ) . 
int next_member(SET *set) 
When called several successive times with the same argument, returns the next 
element of the set each time it's called or -1 if there are no more elements. Every 
time the set argument changes, the search for elements starts back at the begin­
ning of the set. A NULL argument also resets the search to the beginning of the 
set (and does nothing else). Strange things happen if you add members to the set 
between successive calls. If calls to next_ member () are interspersed with calls 
to pset () (discussed below), next_ member () won't work properly. Calls to 
next_ member () on different sets cannot be interspersed. 
void pset(SET *set, int (*out)(), void *param) 
Print the set. The output routine pointed to by out is called for each element of 
the set with the following arguments: 
(*out)(param, "null", -1); Nullset 
(*out) (param, "empty", -2); Empty set 
(*out) (param, "%d ", N); SetelementN 
This way you can use fprint f () as a default output routine. 
UNION(SET *dest, SET *src) 
Modify the dest set to hold the union of the src and dest sets. 
INTERSECT(SET *dest, SET *src) 
Modify the dest set to hold the intersection ofthe src and dest sets. 
DIFFERENCE(SET *dest, SET *src) 
Modify the dest set to hold the symmetric difference of the src and dest 
sets. (An element is put into the target set if it is a member of dest but not of 
src, or vice versa.) 
ASSIGN(SET *dest, SET *src) 
Overwrite the dest with src. 
CLEAR(SET *s) 
Clear all bits in s, creating an empty set. 
FILL (SET *s) 
Set all bits in s to 1, creating a set that holds every element in the input alphabet. 
COMPLEMENT(SET *s) 
Complement a set efficiently by modifying the set's complement bit. Sets 
Section A.2.1-Using the Set Functions and Macros 
complemented in this way can not be manipulated by UNION (), etc. See also, 
invert () and INVERT () . 
INVERT(SET *s) 
Complement a set by physically changing the bit map (see text). 
IS_DISJOINT(SET *sl, SET *s2) 
Evaluate to true only if the two sets are disjoint (have no elements in common). 
IS INTERSECTING (SET * s 1, SET * s2) Test for intersection. 
Evaluate to true only if the two sets intersect (have at least one element in com­
mon). 
IS_EMPTY(SET *s) 
Evaluate to true only if set is empty (having no elements) or null (s is NULL) 
IS_EQUIVALENT(SET *sl, SET *s2) 
Evaluate to true only if the two sets are equivalent (have the same elements). 
ADD(SET *s, int x) 
Add the element c to set s. It is not an error to add an element to a set more 
than once. 
REMOVE(SET *s, int x) 
Remove the element c from set s. It is not an error to remove an element that is 
not in the set. 
TEST(SET *s, int x) 
Evaluates to true if x is an element of set s. 
MEMBER(SET *s, int x) 
Evaluates to true if xis an element of set s. This macro doesn't work on COM­
PLEMENTed sets, but it's both faster and smaller than TEST, which does. The dis­
tinction is described below. 
The elements of sets must be numbers, though in many instances any arbitrary 
number will do. Enumerated types are almost ideal for this purpose, though #defines 
can be used too. For example: 
typedef anum 
{ 
JAN, FEB, MAR, 
APR, MAY, JUN, 
JUL, AUG, SEP, 
OCT, NOV, DEC 
MONTHS; 
creates 12 potential set elements. You can create two sets called winter and spring 
by using the following set operations: 693 
Invert all bits in bit map. 
Test for disjoint. 
Test for empty set. 
Text for equivalence. 
Add member to set. 
Remove member from 
set. 
Test for membership (all 
sets). 
Test for membership (no 
complemented sets). 
Sets, an example. Set 
elements are numbers. 
694 
Set implementation 
difficulties. Null and emp­
ty sets. 
Problems with comple­
mented sets. 
Complement by physical­
ly inverting bits. Support Functions-Appendix A 
#include <set.h> 
SET *winter, *spring; 
winter newset(); 
spring newset(); 
ADD ( JAN, winter ) ; 
ADD ( FEB, winter ) ; 
ADD ( MAR, winter ) ; 
ADD ( APR, spring ) ; 
ADD ( MAY, spring ) ; 
ADD ( JUN, spring ) ; 
Set operations can now be performed using the other macros in <toolslset.h>. For exam­
ple: IS _DISJOINT (winter, spring) evaluates to true because the sets have no ele­
ments in common; IS_EQUIVALENT(winter,spring) evaluates to false for the 
same reason. A third set that contains the union of spring and winter can be created 
with: 
half_year = dupset( winter); 
UNION( half_year, spring); 
Something like: 
half_year = dupset( winter); 
INTERSECT(half_year, spring); 
creates an empty set because there are no common elements. 
There are two implementation difficulties with the set routines. The first is the 
difference between a null set and an empty set. (I'll bet that you thought that the 
difference was just one more obscure mathematical conundrum designed for no other 
purpose than to make undergraduates' heads swim). An empty set is a set that has no 
elements. In the case of the routines presented here, new set () and dupset () both 
create empty sets. They have allocated an internal data structure for representing the set, 
but that set doesn't have anything in it yet. A null set, however, is a SET pointer with 
nothing in it. For example: 
SET *p = NULL; 
p = newset(); /* p represents the null set */ 
/* p now represents an empty set */ 
In practice, this difference means that the routines have to be a bit more careful with 
pointers than they would be otherwise, and are a little slower as a consequence. 
Complimented sets present another problem. You'll notice that the eventual size of 
the set doesn't have to be known when the set is created by new set (). The set size is 
just expanded as elements are added to it. This can cause problems when you comple­
ment a set, because the complemented set should contain all possible elements of input 
alphabet except the ones that are in the equivalent, uncomplemented, set. For example, 
if you're working with a language that's comprised of the set of symbols I A, B, C, D, E, 
F, G I and you create a second set I A,C,E,G I from elements of the language, the comple­
ment of this second set should be I B,D,F I. 
This ideal situation is difficult to do, however. Sets are represented internally as bit 
maps, and these maps are of finite size. Moreover, the actual size of the map grows as 
elements are added to the set. You can complement a set by inverting the sense of all the 
bits in the map, but then you can't expand the set's size dynamically-at least not 
without a lot of work. To guarantee that a complemented set contains all the potential 
elements, you first must expand the set size by adding an element that is one larger than 
any possible legitimate element, and then complement the expanded set. A second 
Section A.2.1-Using the Set Functions and Macros 
problem has to do with extra elements. The bit-map size is usually a little larger than the 
number of potential elements in the set, so you will effectively add members to the set if 
you just stupidly complement bits. On the plus side, set operations (union, intersection, 
etc.) are much easier to do on physically complemented sets. 
An alternate method of complementing the set uses negative-true sets and positive­
true sets. Here, you mark a set as negative or positive by setting a bit in the SET struc­
ture. You don't have to modify the bit map at all. If a set is marked negative-true when 
you test for membership, you can just reverse the sense of the test (evaluate to true if the 
requested bit is not false). Though this method solves the size problem, operations on 
negative-true sets are much harder to perform. 
Since the two representations are both useful, but in different applications, I've 
implemented both methods. The INVERT () macro performs a ones-complement on all 
bits currently in the bit map. Note that if new elements are added, the new bits won't be 
complemented. You should always expand a set out to the maximum number of ele­
ments (by adding and then removing the largest element) before inverting it. The COM­
PLEMENT () macro implements the second method. It doesn't modify the bit map at all; 
rather, it sets a flag in the SET structure to mark a set as negative true. 
Because there are two different classes of sets (those that are complemented and 
those that are inverted), there are also two different macros for testing membership. 
MEMBER () evaluates to true only if the bit corresponding to the requested element is 
actually set to one. MEMBER ( ) can't be used reliably on complemented sets, The 
TEST () macro can be used with complemented sets, but it's both larger and slower than 
MEMBER ( ) . If a set is complemented, the sense of the individual bits is reversed as part 
of the testing process. If the set isn't complemented TEST () works just like MEMBER (). 
The various set operations (UNION, INTERSECT, and so forth) are only valid on 
inverted sets. Use INVERT () if you're going to perform subsequent operations on the 
inverted set. I leave it as an exercise to the reader to make _set_ op () work on com­
plemented sets. The complement bit can represent all bits not in the bit map--if the 
complement bit is set, all bits not in the map are zero and vice versa. I've found these 
routines quite workable in their existing state-it seemed pointless to make the code 
both larger and slower to correct what has turned out not to be a problem. 
A.2.2 Set Implementation 
The set routines are implemented in two places, the first of which is the macro file 695 
Complement by marking 
set as negative true. 
Physical complement, 
INVERT() 
Logical complement, coM­
PLEMENT() 
Testing for membership 
on complemented sets, 
MEMBER () VS. TEST (). 
Set operations work only 
on physically comple­
mented sets. 
<tools! set.h>, in Listing A.4. The file starts with various system-dependent definitions, <tools/set.h>. _ SETTYPE. 
concentrated in one place to make it easier to port the code. _ SETTYPE (on line three) is 
used as the basic unit in a bit map. As I mentioned earlier, a bit map is a !-dimensional 
array of 1-bit objects. In terms of set operations, a number is in the set if the array ele-
ment at that position in the map is true (if bitmap [ 5] is true than 5 is in the set). The 
map is implemented using an array of_ SETTYPEs as follows: Implementing bit maps. 
4 3 2 I 0 
bit number 7 6 5 4 3 2 I 0 9 8 7 6 5 4 3 2 I 0 9 8 7 6 5 4 3 2 I 0 9 8 7 6 5 4 3 2 I 0 9 8 7 6 5 4 3 2 I 0 
••• I, I I I I I I II I I I I I I I, I I I I I I II I I I I I I I, I I I I I I II I I I I I I I 
array index 2 0 ---~ 
Bit 0 is at position 0 in array[O], bit 1 is at position 1 in array[O], bit 20 is at position 4 in 
array[!], and so forth. In order to make the array manipulation as efficient as possible, 
_ SETTYPE should be the largest integral type that can be manipulated with a single 
instruction on the target machine. In an 8086, for example, the largest such type is a 16-
bit word-larger numbers require several instructions to manipulate them-so I've used 
the 16-bit short as the SETTYPE. 
696 Support Functions-Appendix A 
Listing A.4. set.h-Macro Definitions and Prototypes for Set Functions 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 I* SET.H: Macros and function prototypes for the set functions *I 
typedef unsigned short SETTYPE I* one cell in bit map 
#define BITS IN WORD 16 
#define -BYTES_IN_ARRAY(x) (X << 1) I* # of bytes in bit map 
#define DIV_WSIZE(x) ( (unsigned) (x) >> 4) -#define _MOD_WSIZE(x) ( (x) & OxOf 
#define DEFWORDS 
#define DEFBITS 
#define ROUND(bit) -
typedef struct set 
{ 8 
( DEFWORDS * BITS 
(((_DIV_WSIZE(bit) ) 
IN _WORD) 
+ 8) >>3 I* elements in default set 
I* bits in default set 
) <<3 ) 
*I unsigned 
unsigned 
unsigned 
SETTYPE 
SETTYPE char nwords 
char comp1 
nbits 
*map 
defmap[ DEFWORDS ]; I* Number of words in map 
I* is a negative true set 
I* Number of bits in map 
I* Pointer to the map 
I* The map itself if true *I 
*I 
*I 
*I 
SET; 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
#define 
#define 
#define 
#define addset 
de1set 
*dupset 
invert int 
void 
SET 
void 
SET 
int 
int 
void 
void *new set 
next member 
num e1e 
pset 
_set_op 
int set test 
int setcmp 
unsigned sethash 
int subset 
void truncate 
UNION 
INTERSECT 
DIFFERENCE 
ASSIGN 0 
1 
2 
4 P ( ( SET* , int 
P ( ( SET* 
P ( 
( SET* 
P ( 
( SET* 
P ( ( void 
P ( ( SET * 
P ( 
( SET* 
P(( SET*, int (*)(),void* 
P(( int, SET*, SET* 
p ( 
( SET* I SET* 
P ( 
( SET*, SET* 
P ( 
( SET* 
p ( ( SET* I SET* 
P ( 
( SET* 
I* Op argument passed to 
I* x is in sl or s2 
I* x is in sl and s2 
I* (x in sl) and (x not in 
I* sl = s2 
#define UNION(d,s) 
#define INTERSECT(d,s) 
#define DIFFERENCE(d,s) 
#define ASSIGN(d,s) set_op( 
set_op( 
_set_op ( 
set_op ( d, s ) 
s ) 
s ) 
s ) _UNION, 
INTERSECT, d, 
_DIFFERENCE, d, 
_ASSIGN, d, ) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
) ) ; 
set op *I 
*I 
*I 
s2) *I 
*I *I 
*I 
*I 
*I 
#define CLEAR(s) 
#define FILL (s) 
#define COMPLEMENT(s) 
#define INVERT(s) memset( (s)->map, 0, (s)->nwords * sizeof(_SETTYPE)) 
memset( (s)->map, -o, (s)->nwords * sizeof(_SETTYPE)) 
( (s)->comp1 = -(s)->compl ) 
invert(s) 
#define 
#define 
#define SET_EQUIV 
SET DISJ 
SET INTER 0 
1 
2 I* Value returned from 
I* 
I* set test, equivalent *I 
disjoint *I 
intersecting *I 
#define IS_DISJOINT(s1,s2) 
#define IS_INTERSECTING(s1,s2) 
#define IS_EQUIVALENT(a,b) _set_test(s1,s2) 
_set_test(sl,s2) 
setcmp ((a), (b)) SET DISJ 
SET INTER 
0 .... 
Section A.2.2-Set Implementation 
Listing A.4. continued ••. 
#define IS_EMPTY(s) ( num_ele(s) == 0 
/* All of the following have heavy-duty side-effects. Be careful. */ 
#define _GBIT(s,x,op) ( ( (s) ->map) [_ DIV_WSIZE (x)] op (1 « _MOD_WSIZE (x)) 60 
61 
62 
63 
64 
65 
66 
67 
68 
69 #define REMOVE(s,x) ( ( (x) >= (s) ->nbits) ? 0 GBIT(s,x,&= -) -#define ADD(s,x) ( ( (x) >= (s) ->nbits) ? addset(s,x) GBIT(s,x, I= ) -#define MEMBER(s,x) ( ( (x) >= (s) ->nbits) ? 0 GBIT(s,x,& ) 
#define TEST(s,x) ( ( MEMBER (s, x) ) ? ! (s)->compl (s)->compl 
The macros on lines four to seven all reflect the size of the SETTYPE and will have 
to be changed if _SETTYPE is changed. _BITS_IN_WORD is just that, the number of 
bits in a variable of type _ SETTYPE. _BYTES_ IN_ ARRAY is passed a count, and it _BITS_IN_WORD, 
BYTES IN ARRAY. ---
returns the number of bytes in an array of that many_ SETTYPE-sized variables. In this 
case, I multiply the count by two using a left shift rather than doing something like 
s*sizeof (_ SETTYPE), which uses a multiply on my compiler- the shift is a more 
efficient operation than the multiply. 697 
The_ D IV_ ws I ZE ( x) and_ MOD_ WS I ZE ( x) macros help determine the position of 
a particular bit in the map. The argument to both macros is the bit for which you want 
the position. The _ D IV_ WS I ZE ( x) macro evaluate to the array element that holds the 
bit. A_DIV_WSIZE (20) evaluates to 1 because bit 20 is in array[l]. It's just doing an Computing bit positions, 
_DIV _ WSIZE (x), 
integer divide by 16, though I'm using a left shift here for efficiency's sake. The 
_MOD_ WS I ZE ( x) macro evaluate to the position of the bit within the word-the offset 
in bits from the least-significant bit in the word. A_ MOD_ WSIZE (20) evaluates to 4 
because bit 20 is at offset 4 of array[l]. I'm doing an efficient modulus-16 operation by 
using a bitwise AND rather than a %. 
_DEFWORDS, on line eight of Listing A.4, determines the array size for a default bit 
map. Initially, all bit maps have this many elements. The size is expanded (in 
_DEFWORDS-sized chunks) if needed. _DEFWORDS is set to 8 here, so the default map 
can have 128 elements before it needs to be expanded. _DEFBITS, on the next line, is 
just the number of bits required for that many words. 
The _ROUND macro is used to expand the size of the array. The array grows in 
_DEFWORDS-sized chunks. Say, for example, that the array starts out at the default size 
of 8 words, and you want to add the number 200 to the set. The array must be expanded 
to do so, and after the expansion, the array should have 16 elements in it (2 x _DEF­
WORDS). In this situation the macro expands to: 
(((_DIV_WSIZE(200) + 8) >>3 ) <<3 ) 
and one more level to: 
(((((unsigned) (200) >> 4) + 8) >>3 ) <<3 ) 
The 200»4 evaluates to 12, so bit 200 is in array[l2]. 12 plus 8 is 20, and 20»3 
yields 2. (The »3 is an integer divide by 8.) The final multiply by 8 (the «3} yields 
16, so the map array is expanded to 16 elements. _MOD_WSIZE (x). 
_DEFWORDS,_DEFBITS, 
ROUND. 
The SET itself is represented with the following structure, defined on lines 12 to 20 Representing a set, SET. 
of Listing A.4. 
698 Support Functions-Appendix A 
Set macros. 
CLEAR, FILL. 
Adding and removing set 
members, ADD () , RE­
MOVE () . Testing for 
membership, MEMBER ( ) . 
GBIT. 
Testing complemented 
sets for membership, 
TEST(). typedef struct set 
{ 
unsigned 
unsigned 
unsigned 
SETTYPE 
SETTYPE 
SET; char nwords 
char compl 
nbits 
*map 
defmap[_DEFWORDS]; I* Number of words in map *I 
I* negative true if set *I 
I* Number of bits in map *I 
I* Pointer to the map *I 
I* The default map *I 
The number of bits in the map (nbits) could be computed from the number of words 
(nwords), but it's more efficient--of computation time, not space-to keep both 
numbers in the structure. The compl field is set to true if this is a negative-true set. The 
defmap [] array is the default bit map. Initially, map just points to it. When the map 
grows, however, a new array is allocated with malloc () and map is modified to point at 
the new array. This strategy is used rather than a realloc () call for run-time 
efficiency, at the cost of wasted memory-realloc () will generally have to copy the 
entire structure, but only the map needs to be copied if you do it yourself. 
<set.h> continues on line 22 of Listing A.4 with function prototypes for the actual 
functions. The macros on lines 43 to 60 handle operations that actually modify a set 
(union, intersection, symmetric difference, and so forth). Most of them map to 
set_ op () calls, passing in a constant to tell the subroutine which function is required. 
CLEAR and FILL modify the bit map directly, however, calling memset () to fill the bits 
with zeros or ones as appropriate. 
The real heart of <set.h> are the set-manipulation macros at the end of the file, 
reproduced here: 
#define _GBIT(s,x,op) (((s)->map) [_DIV_WSIZE(x)] op (1 << _MOD_WSIZE(x))) 
#define REMOVE(s,x) ( ( (x) >= (s) ->nbits) ? 0 _GBIT(s,x,&= -) ) 
#define ADD(s,x) ( ( (x) >= (s) ->nbits) ? _addset(s,x): GBIT(s,x, I= )) -#define MEMBER(s,x) ( ( (x) >= (s)->nbits) ? 0 _GBIT(s,x,& )) 
#define TEST(s,x) ( ( MEMBER(s,x) ) ? ! (s)->compl : (s)->compl 
The REMOVE, ADD, and MEMBER macros all evaluate to _GBIT invocations. The only 
difference is the operator (op) passed into the macro. The first part of _GBIT uses the 
following to select the array element in which the required bit is found: 
( (s)->map ) [ _DIV_WSIZE(x) ] 
The second half of the macro shifts the number l to the left so that it will fall in the same 
position as the required bit, using 
(1 << _MOD_WSIZE(x)) ) 
If you're accessing bit 5, the number I is shifted left 5 bits, yielding the following binary 
mask in a I6-bit word: 
0000000000100000 
The same shift happens when you access bit 20, but in this case the first half of the macro 
chooses ( s) ->map [ 1) rather than ( s) ->map [ 0 ). The op argument now comes into 
play. The shifted mask is ORed with the existing array element to add it to the set. 
Similarly, the inverse of the mask is ANDed to the array element to clear a bit. OR is 
also used to test for membership, but since there's no = in MEMBER, the map is not 
modified. 
The TEST macro, which can handle complemented sets, works by first determining 
whether x is in the set, and then evaluating to the complement flag or its inverse, as 
appropriate. For example, the complemented flag will be I if x is in a negative true set, 
Section A.2.2-Set Implementation 
and MEMBER tests true if the bit is in the map. The inverse of the complement flag (0) is 
returned, however. I've used this somewhat convoluted approach because of the sheer 
size of the macro. TEST ( s, x) expands to this monster: 
( ( ( ( (x) >= (s) ->nbits) ? 0 : 
(((s)->map) [((unsigned) (x)»4)] & (1«({x) & OxOf))))) ? 
! (s)->comp1 : (s)->comp1); 
but the more obvious solution: 
(s)->compl ? !MEMBER(s,x) 
turns into this: 
(s)->compl MEMBER(s,x) 
? ! (((x) >= (s)->nbits) ? 0 : 
( ( (s) ->map) [ ((unsigned) (x) »4)] & (1« ( (x) & OxOf)))) 
(((x) >= (s)->nbits) ? 0 : 
( ( (s) ->map) [ ((unsigned) (x) »4)] & (1« ( (x) & OxOf)))) 
which is even worse. 
The functions needed for set manipulation are all in set.c, the first part of which is 699 
Listing A.S. The new set () function, which actually creates the new set, starts on line Creating sets, newset ( l. 
nine. Normally, a pointer to the newly allocated SET is returned. If insufficient memory 
is available, an error message is printed and the program is terminated by the 
raise(SIGABRT) call on line 21. raise() is an ANSI function which, in this case, raise(). 
causes the program to terminate. I've chosen to abort the program rather than return 
NULL (like malloc () does) because most applications will terminate the program any-
way if memory isn't available. If you want NULL to be returned on an error rather than 
aborting the program, just disable the SIGABRT signal as follows: 
#include <signal.h> 
main() 
{ 
signal( SIGABRT, SIG IGN ); 
Listing A.S. set.c-SET Creation and Destruction 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 #include 
#include 
#include 
#include 
#include #include 
#include 
PUBLIC SET 
{ <stdio.h> 
<ctype.h> 
<signal.h> 
<stdlib.h> 
<string.h> 
<tools/debug.h> 
<tools/set.h> 
*newset () 
/* Create a new set and return a pointer to it. Print an error message 
*and raise SIGABRT if there's insufficient memory. NULL is returned 
* if raise() returns. 
*I 
SET *p; 
if( ! (p = (SET*) malloc( sizeof(SET) )) ) 
{ 
fprintf(stderr,"Can't get memory to create set\n"); 
raise( SIGABRT ); 
return NULL; /* Usually won't get here */ .... 
700 Support Functions-Appendix A 
Listing A.S. continued ... 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 memset( p, 
p->map 
p->nwords 
p->nbits 
return p; 0, sizeof(SET) ); 
p->defmap; 
_DEFWORDS; 
_DEFBITS; 
l*----------------------------------------------------------------------*1 
PUBLIC void delset( set ) 
SET *set; 
{ 
I* Delete a set created with a previous newset() call. *I 
if( set->map != set->defmap 
free( set->map ); 
free( set ); 
1*----------------------------------------------------------------------*l 
PUBLIC SET *dupset( set ) 
SET *set; 
{ 
I* Create a new set that has the same members as the input set *I 
SET *new; 
if( ! (new= (SET*) malloc( sizeof(SET) )) ) 
{ 
fprintf(stderr,"Can't get memory to duplicate set\n"); 
exit(l); 
memset( new, 0, sizeof(SET) ); 
new->compl set->compl; 
new->nwords set->nwords; 
new->nbits set->nbits; 
if( set->map == set->defmap 
{ 
new->map = new->defmap; I* default bit map in use *I 
memcpy( new->defmap, set->defmap, _DEFWORDS * sizeof(_SETTYPE) ); 
else 
{ I* bit map has been enlarged *I 
new->map = (_SETTYPE *) malloc( set->nwords * sizeof(_SETTYPE) ); 
if( !new->map ) 
{ 
fprintf(stderr,"Can't get memory to duplicate set bit map\n"); 
exit(l); 
memcpy( new->map, set->map, set->nwords * sizeof(_SETTYPE) ); 
return new; 
Section A.2.2-Set Implementation 
The del_ set () function starting on line 33 is the SET destructor subroutine. It 
frees any memory used for an expanded bit map on line 38, and then frees the memory 
used for the SET itself. 
dupset () (starting on line 45 of Listing A.5) duplicates an existing set. It's much 
more efficient than calling new_ set () and then adding members to the new set one at a 
time. 
The functions in Listing A.6 handle set enlargement: _ addset () is called from the 
ADD macro when the bit map is not large enough to hold the requested bit. All it does is 
call enlarge () (which starts on line 95) to make the map larger, and then invokes 
GBIT to set the bit. _enlarge () is passed the required number of words in the bit 
map (need). The test on line 106 causes the routine to return if no expansion is required. 
Note that exit() is called on line 114 if enlarge() can't get memory. I've done this 
rather than call raise () because I'm assuming that the value returned from ADD will 
not be tested. It would be risky to call raise () in this situation because the signal 
handler might have been reassigned to an empty function, as was discussed earlier. 
The next part of set.c (in Listing A.7) consists of various testing functions. The 
num _ ele () function, starting on line 126, determines the number of elements in the set. 
It does this by looking at the map array one byte at a time, using a table lookup to do the 
counting. The table in question is nbi ts [),declared on lines 134 to 152. The table is 
indexed with a number in the range 0-255, and it evaluates to the number of bits set to 1 
in that number. For example, the decimal number 93 is 01011101 in binary. This 
number has five ones in it, so nbits [ 93) holds 5. The loop on lines 162 and 163 just 
goes through the map array byte by byte, looking up each byte in nbi t s [ ] and accumu­
lating the count in count. 
The _set_test () function starting on line 170 of Listing A.7 compares two sets, 
returning _SET_ EQUIV if the sets are equivalent (have the same elements), 
_SET_ INTER if the sets intersect (have at least one element in common) but aren't 
equivalent, and _SET_ D I SJ if the sets are disjoint (have no elements in common). A 
bitwise AND is used to test for intersection on line 203-the test for equivalence was 
done on line 195 of Listing A. 7. If the AND tests true, there must be at least one bit at 
the same relative position in both bit-map elements. 
Note that the sets are made the same size with the enlarge () calls on lines 187 and 
188 before they are compared, and this expansion can waste time if the sets are likely to 
be different sizes. For this reason, a second comparison function, setcmp (), is pro­
vided on line 215. This routine works like strcmp (), returning zero if the sets are 
equivalent, a negative number if setl<set2, and a positive number if setl>set2. 
Since setcmp () does not modify the set sizes, using it can be less time consuming than 
using _set_test (). The main purpose of this second comparison function is to let 
you sort an array of SET pointers so that the equivalent sets are adjacent. The determina­
tion of less than and greater than is pretty much arbitrary-the routine just compares the 
maps as if they were arrays of ints. setcmp () first compares the map elements that 
exist in both of the sets on lines 228 to 230. If there's a mismatch, the two bytes are sub­
tracted to get a relative ordering. The code on lines 236 to 247 is executed only if the 
two sets are identical up to this point. The tail end of the larger set is then scanned to 
make sure that it's all zeros. If so, the two sets are equivalent. If not, the larger set is the 
greater. 
The final comparison function is subset(), starting on line 275 of Listing A.7. 
common and tail, initialized on lines 289 to 298, are the number of words that exist in 
both sets, and the number of extra bytes that have to be tested in the potential subset. For 
example, if set A has 10 bytes and set B has 20, and if you're determining whether set A 
is a subset of set B, you need to look only at the first 10 bytes of both sets. It doesn't 
matter whether the last 10 bytes of set B have anything in them. If, however, you want Deleting sets, 
del_set () 
Duplicating sets, 
dupset (). 
Enlarging sets, 
_addset (). 701 
Finding the number of 
elements in a sets, 
num_ele (). 
Comparing sets for 
equivalent, intersecting, 
disjoint, _set_test (). 
Comparing sets for sort­
ing, setcmp () . 
Testing for subset, 
subset(). 
702 Support Functions-Appendix A 
Listing A.6. set.c-Adding Members to and Enlarging aSET 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108· 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 PUBLIC int _addset{ set, bit ) 
SET *set; 
{ 
I* Addset is called by the ADD() macro when the set isn't big enough. It 
* expands the set to the necessary size and sets the indicated bit. 
*I 
void enlarge( int, SET*); 
enlarge( _ROUND(bit), set); 
return _GBIT( set, bit, 1= ); I* immediately following *I 
I* ------------------------------------------------------------------- *I 
PRIVATE void enlarge( need, set ) 
SET *set; 
{ 
I* Enlarge the set to "need" words, filling in the extra words with zeros. 
*Print an error message and abort by raising SIGABRT if there's not enough 
*memory. NULL is returned if raise() returns. Since this routine calls 
* malloc, it's rather slow and should be avoided if possible. 
*I 
SETTYPE *new; 
if( !set I I need <= set->nwords ) 
return; 
D( printf("enlarging %d word map to %d words\n", set->nwords, need); ) 
if( ! (new= (_SETTYPE *) malloc( need* sizeof(_SETTYPE))) 
{ 
fprintf(stderr, "Can't get memory to expand set\n"); 
exit( 1 ); 
memcpy( new, set->map, 
memset( new+ set->nwords, 0, 
if( set->map != set->defmap 
free( set->map ); 
new set->nwords * sizeof(_SETTYPE) ); 
(need- set->nwords) * sizeof(_SETTYPE) ); 
set->map 
set->nwords 
set->nbits (unsigned char) need 
need * BITS IN WORD 
to know whether the longer set (B) is a subset of the shorter one (A), all bytes that are 
not in set A (the extra 10 bytes in B) must be scanned to make sure they're all zeros. The 
common parts of the sets are scanned by the loop on line 303, and the tail of the larger 
set is scanned, if necessary, by the loop on line 307. 
Set operations (union, in­
tersection, symetric 
difference, assignment). 
_set_op(). The next three functions, in Listing A.8, all modify a set one way or another. The 
_set_ op () function on line 313 performs the union, intersection, symmetric difference, 
and assignment functions. 
I've used the same strategy here as I used earlier when the sets were different sizes. The 
common words are manipulated first, and the tail of the longer set is modified if 
Section A.2.2-Set Implementation 703 
Listing A.7. set.c-Set-Testing Functions 
126 PUBLIC int num_e1e( set 
127 SET *set; 
128 { 
129 I* Return the number of elements (nonzero bits) in the set. NULL sets are 
130 * considered empty. The table-lookup approach used here was suggested to 
131 *me by Doug Merrit. Nbits[] is indexed by any number in the range 0-255, 
132 * and it evaluates to the number of bits in the number. 
133 *I 
134 static unsigned char nbits[] 
135 { 
136 I* 0-15 *I 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
137 I* 16-31 *I 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
138 I* 32-47 *I 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
139 I* 48-63 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
140 I* 64-79 *I 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
141 I* 80-95 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
142 I* 96-111 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
143 I* 112-127 *I 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
144 I* 128-143 *I 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
145 I* 144-159 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
146 I* 160-175 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
147 I* 176-191 *I 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
148 I* 192-207 *I 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
149 I* 208-223 *I 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
150 I* 224-239 *I 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
151 I* 240-255 *I 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 
152 } ; 
153 int i; 
154 unsigned int count 0; 
155 unsigned char *p; 
156 
157 if( !set 
158 return 0; 
159 
160 p = (unsigned char *)set->map ; 
161 
162 for( i = BYTES IN _ARRAY(set->nwords) --i >= 0 
163 count += nbits[ *p++ l ; 
164 
165 return count; 
166 
167 
168 I* ------------------------------------------------------------------- *I 
169 
170 PUBLIC int set_test( set1, set2 ) -171 SET *set1, *set2; 
172 { 
173 I* Compares two sets. Returns as follows: 
174 * 
175 * SET_EQUIV Sets are equivalent 
176 * SET INTER Sets intersect but aren't equivalent 
177 * SET DISJ Sets are disjoint 
178 * 
179 * The smaller set is made larger if the two sets are different sizes. 
180 *I 
181 
182 int i, rva1 = SET_EQUIV -183 SETTYPE *p1, *p2; 
184 .... 
704 Support Functions-Appendix A 
Listing A.7. continued ... 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 218 
219 
220 
221 
222 
223 
224 
225 
226 
227 228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 i =max( setl->nwords, set2->nwords); 
enlarge( i, setl ); 
enlarge( i, set2 ); I* Make the sets the same size *I 
pl setl->map; 
p2 set2->map; 
for ( ; --i >= 0 
( pl++, p2++ ) 
if( *pl != *p2 
( 
I* You get here if the sets aren't equivalent. You can return 
* immediately if the sets intersect but have to keep going in the 
* case of disjoint sets (because the sets might actually intersect 
*at some byte, as yet unseen). 
*I 
if( *pl & *p2 ) 
return SET INTER ; 
else 
rval = SET DISJ 
return rval; I* They're equivalent *I 
I* ------------------------------------------------------------------- *I 
PUBLIC setcmp( setl, set2 ) 
SET *setl, *set2; 
{ 
I* Yet another comparison function. This one works like strcmp(), 
* returning 0 if the sets are equivalent, <0 if setl<set2 and >0 if 
* setl>set2. 
*I 
int i, 
SETTYPE j; 
*pl, *p2; 
i = j =min( setl->nwords, set2->nwords ); 
for( pl = setl->map, p2 = set2->map ; --j >= 0 
if( *pl != *p2 ) 
return *pl -*p2; pl++, p2++ 
I* You get here only if all words that exist in both sets are the same. 
* Check the tail end of the larger array for all zeros. 
*I 
if( (j = setl->nwords -i) > 0 ) 
{ 
while( --j >= 0 ) 
if ( *pl++ ) 
return 1; I* Set 1 is the larger *I 
Section A.2.2-Set Implementation 
Listing A.7. continued ... 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 
265 
266 
267 
268 
269 
270 
271 
272 
273 
274 
275 
276 
277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 288 
289 
290 
291 
292 
293 
294 
295 
296 
297 298 
299 else if( (j = set2->nwords -i) > 0) 
{ 
while( --j >= 0 ) 
if ( *p2++ ) 
return -1; 
return 0; I* Set 2 is the larger *I 
I* They're equivalent *I 
I* ------------------------------------------------------------------- *I 
PUBLIC unsigned sethash( setl ) 
SET *setl; 
{ 
I* hash the set by summing together the words in the bit map *I 
SETTYPE 
unsigned 
int 
total 
j 
p *p; 
total; 
j; 
0; 
setl->nwords 
setl->map 
while( --j >= 0 ) 
total += *p++ 
return total; 
I* ------------------------------------------------------------------- *I 
PUBLIC int subset( set, possible_subset 
*possible_subset; SET *set, 
{ 
I* Return 1 if "possible_subset" is a subset of "set". One is returned if 
* it's a subset, zero otherwise. Empty sets are subsets of everything. 
* The routine silently malfunctions if given a NULL set, however. If the 
* "possible_subset" is larger than the "set", then the extra bytes must 
* be all zeros. 
*I 
SETTYPE *subsetp, *setp; 
int 
int common; 
tail; I* This many bytes in potential subset *I 
I* This many implied 0 bytes in b *I 
if( possible_subset->nwords > set->nwords ) 
{ 
else common 
tail 
common 
tail set->nwords ; 
possible_subset->nwords -common 
possible_subset->nwords; 
0; 705 
.... 
706 Support Functions-Appendix A 
Listing A.7. continued ... 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 subsetp 
setp possible_subset->map; 
set->map; 
for(; --common >= 0; subsetp++, setp++ 
if( (*subsetp & *setp) != *subsetp 
return 0; 
while( --tail >= 0 
if ( *subsetp++ 
return 0; 
return 1; 
Listing A.S. set.c-Set Manipulation Functions 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 
346 
347 
348 
349 
350 
351 PUBLIC void _set_op( op, dest, src ) 
int op; 
SET *src, *dest; 
{ 
I* Performs binary operations depending on op: 
* 
* UNION: union of src and dest 
* INTERSECT: 
* DIFFERENCE: 
* ASSIGN: dest 
dest 
dest 
dest intersection of src and dest 
symmetric difference of src and dest 
src; 
* * The sizes of the destination set is adjusted so that it's the same size 
* as the source set. 
*I 
SETTYPE *d; I* Pointer to destination map *I 
SETTYPE *s; I* Pointer to map in setl *I 
int ssize; I* Number of words in src set *I 
int tail; I* dest set is this much bigger *I 
ssize src->nwords 
if( (unsigned)dest->nwords < ssize 
enlarge( ssize, dest ); I* Make sure dest set is at least *I 
I* as big as the src set. *I 
tail 
d dest->nwords -ssize 
dest->map 
s src ->map 
switch( op ) 
{ 
case UNION: while( --ssize >= 0 ) 
*d++ I= *s++ ; 
break; 
case INTERSECT: while( --ssize >= 0 ) 
*d++ &= *s++ 
while( --tail >= 0 ) 
*d++ = 0; 
break; 
.... 
Section A.2.2-Set Implementation 
Listing A.8. continued •.. 
352 
353 
354 
355 
356 
357 
358 
359 
360 
361 
362 
363 
364 
365 
366 
367 
368 
369 
370 
371 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 
385 
386 
387 
388 
389 
390 
391 
392 
393 
394 
395 
396 case DIFFERENCE: while( --ssize >= 0 ) 
*d++ A= *s++ ; 
break; 
case ASSIGN: while( --ssize >= 0 ) 
*d++ = *s++ 
while( --tail >= 0 ) 
*d++ = 0; 
break; 
I* ------------------------------------------------------------------- *I 
PUBLIC void invert( set ) 
SET *set; 
{ 
I* Physically invert the bits in the set. Compare with the COMPLEMENT() 
*macro, which just modifies the complement bit. 
*I 
SETTYPE *p, *end ; 
for( p 
*p set->map, end 
-*p; p + set->nwords p < end p++ ) 
I* ------------------------------------------------------------------- *I 
PUBLIC void truncate( set ) 
SET *set; 
{ 
I* Clears the set but also set's it back to the original, default size. 
* Compare this routine to the CLEAR() macro which clears all the bits in 
* the map but doesn't modify the size. 
*I 
if( set->map != set->defmap 
{ 
free( set->map ); 
set->map = set->defmap; 
set->nwords = _DEFWORDS; 
set->nbits _DEFBITS; 
memset( set->defmap, 0, sizeof(set->defmap) ); 
necessary. The work is all done by the while loops in the switch on lines 342 to 360. 
It's probably better style to put one while statement outside the switch than to put 
several identical ones in the cases, but the latter is more efficient because the switch 
won't have to be re-evaluated on every iteration of the loop. The first while loop in 
every case takes care of all destination elements that correspond to source elements. The 
maps are processed one word at a time, ORing the words together for union, ANDing 
them for intersection, XORing them for symmetric difference, and just copying them for 
assignment. Note that the source set can not be larger than the destination set because of 
the earlier enlarge () call on line 336. 707 
708 Support Functions-Appendix A 
The second while loop in each case won't execute if the two sets are the same size, 
because the tail size will be zero. Otherwise, the destination set is larger and you must 
do different things to the tail, depending on the operation. Since the missing elements of 
the smaller set are all implied zeros, the following operations are performed: 
union: Do nothing else to the destination because there are no more bits in the 
source set to add. 
intersection: Clear all the bits in the tail of the destination because no bits are set in the 
source so there's no possibility of intersection. 
difference: Do nothing because every bit that's set in the source set will not be set in 
the destination. 
assignment: Set all bits in the tail of the destination to 0 (because the implied bits in the 
source are all 0). 
The invert () subroutine starting on line 365 of Listing A.8 just goes through the 
map, reversing the sense of the bits. The truncate () function on line 380 restores a 
set to its initial, empty, condition. This last routine is really a more efficient replacement 
for: 
delset ( s ) ; 
s = newset(); 
You may be better off-in terms of speed-to clear the existing set with CLEAR rather 
than calling t:r;:uncate (),because free () is pretty slow. 
Accessing an entire set, 
next_ member ( ) . The final two set routines, which access and print entire sets, are in Listing A.9. The 
next_ member ( ) function on line 397 lets you access all elements of a set sequentially. 
When the function is called several successive times with the same argument, it returns 
the next element of the set with each call, or -1 if there are no more elements. Every 
time the set argument changes, the search for elements starts back at the beginning of 
the set. Similarly, next_ member (NULL) resets the search to the beginning of the set 
(and does nothing else). You should not put any new elements in the set between a 
next_member (NULL) call and a subsequent next_member (set) call. Elements 
should not be added to the set between successive next_ member () calls. 
Listing A.9. set.c-Getting Elements and Printing the Set 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410 
411 
412 
413 
414 
415 
416 PUBLIC int next_member( set ) 
SET *set; 
{ 
I* set == NULL 
* set changed from last call: 
* otherwise 
*I 
static SET *oset NULL; 
static int current member 0; 
SETTYPE *map; 
if( !set 
return( (int) ( oset NULL ) ) ; 
if( oset != set ) 
{ 
oset set; 
current member 0 ; Reset 
Reset and return first element 
return next element or -1 if none. 
I* "set" arg in last call 
I* last-accessed member of cur. set *I *I 
Section A.2.2-Set Implementation 
Listing A.9. continued ... 
for(map = set->map; *map== 0 && current member < set->nbits; ++map) 
current member += BITS IN_WORD; 709 
417 
418 
419 
420 
421 
422 
423 
424 
425 
426 
427 428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 
439 
440 
441 
442 
443 
444 
445 
446 
447 
448 
449 
450 
451 
452 
453 
454 
455 
456 
457 
458 
459 
460 
461 
462 
463 
464 
465 I* The increment must be put into the test because, if the TEST() invocation 
*evaluates true, then an increment on the right of a for() statement 
* would never be executed. 
*I 
while( current member++ < set->nbits ) 
if( TEST(set, current_member-1) 
return( current member-1 ); 
return( -1 ); 
I* ------------------------------------------------------------------- *I 
PUBLIC void pset( set, output_routine, param) 
SET 
int 
void 
{ *set; 
(*output_routine) (); 
*par am; 
I* Print the contents of the set bit map in human-readable form. The 
* output routine is called for each element of the set with the following 
* arguments: 
* 
* (*out) ( param, "null", 
* (*out) ( param, "empty", 
* (*out) ( param, "%d ", 
*I 
int i, did_something 0; 
if( ! set ) -1); 
-2); 
N); Null set ("set" arg ==NULL) 
Empty set (no elements) 
N is an element of the set 
(*output_routine) ( param, "null", -1 ); 
else 
next_member( NULL); 
while( (i = next_member(set)) >= 0) 
{ 
did_something++; 
( *output_routine) ( param, "%d ", i ); 
next_member( NULL); 
if( !did_something ) 
( *output_routine ) (param, "empty", -2 ) ; 
A major limitation to next_ member () is that calls to next_member on different sets 
cannot be interspersed. This problem could be solved by putting the current_ member 
counter (declared on line 406) into the SET structure rather than keeping it as a local 
static variable. Since I've never needed this functionality, I didn't want to add the 
extra overhead needed to support it. The loop on line 417 is skipping initial words in the 
bit map that are all zeros. 
710 Support Functions-Appendix A 
Printing a set, pset () . The pset () function on line 434 prints all the elements in a set. The standard call: 
pset( set, fprintf, stdout ); 
prints the elements of the set, separated by space characters, and without a newline at the 
end of the list. The second argument can actually be a pointer to any function, however. 
The third argument is just passed to that function, along with a format string. The func­
tion is called indirectly through a pointer as follows: 
(*out) ( param, "null", -1); 
(*out) ( param, "empty", -2); 
(*out) ( param, "%d ", N); For null sets (set is NULL) 
For empty set (set has no elements) 
Normally, N is an element of the set 
Calls to pset () and next_ member () should not be interspersed. 
A.3 Database Maintenance-Hashing: 
Compilers all need some sort of simple data-base management system. Typically the 
databases are small enough to fit into memory, so an elaborate file-based system is not 
only not required, but is contraindicated (because of the excessive access time). Of the 
various techniques that are available for data management, the most appropriate is the 
hash table. 
The eight functions in this section implement a general-purpose, data-base manager 
that uses a hash strategy, but you can use these functions without any knowledge of the 
mechanics of manipulating a hash table. The hash functions are used in Chapter Two, 
but hashing isn't discussed until Chapter Six. You may want to read that discussion 
before proceeding. You can also just skim over the the function overviews that follow, 
skipping over the implementation details until you've read Chapter Six. 
Listing A.1 0 shows a very simple application that creates a database that holds the 
argv entries, and then prints the entries. The details of all the function calls will be dis­
cussed in a moment, but to summarize: A single database record is defined with the 
typedef on line nine. An empty database is created on line 55 with a maketab () call, 
which is passed pointers to two auxiliary functions that control database manipulation: 
The hash function on line 17 translates the key field to a pseudo-random number, here 
using a shift and exclusive-OR strategy. The comparison function on line 31 does a lexi­
cographic comparison of the key fields of two database records. The newsym () call on 
line 58 allocates space for a new database record, which is put into the database with the 
addsym () call on line 60. 
Listing A.lO. Program to Demonstrate Hash Functions 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/hash.h> 
/* A application that demonstrates how to use the basic hash functions. Creates 
* a database holding the argv strings and then prints the database. 
*I 
typedef struct 
{ 
char *key; 
int other stuff; 
ENTRY; /* A database record */ 
.... 
Section A.3-Database Maintenance-Hashing: 
Listing A.lO. continued ... 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 /*----------------------------------------------------------------------*/ 
unsigned hash( sym ) 
ENTRY *sym; 
{ 
char *p; 
int hash_value = 0; 
for( p = sym->key; *p 
return hash_value; hash value /* Hash function. Convert the key */ 
/* to a number. */ 
(hash_value << 1) -*p++ ) 
/*----------------------------------------------------------------------*/ 
int cmp( sym1, sym2 ) 
ENTRY *sym1, *sym2; 
{ /* Compare two database records. */ 
/*Works like strcmp(). */ 
return strcmp( sym1->key, sym2->key ); 
/*----------------------------------------------------------------------*/ 
void print( sym, stream) 
ENTRY *sym; 
FILE 
{ *stream; /* print a database record to the stream */ 
fprintf( stream, "%s\n", sym->key ); 
/*----------------------------------------------------------------------*/ 
main( argc, argv 
int argc; 
char **argv; 
{ 
HASH TAB *tab; 
ENTRY *p; 
tab= maketab(31, hash, cmp); 
for( ++argv, --argc; --argc>=O; ++argv) 
{ /* make hash table */ 
/* For each element of argv */ 
p = (ENTRY*) newsym(sizeof(ENTRY)); 
p->key = *argv; /* put it into the table 
addsym( tab, p ); 
ptab( tab, print, stdout, 1 ) ; /* print the table. stdout is 
/*passed through to print(). *I 
*I 
*I 711 
712 
Create hash table. 
Allocate memory for 
symbol. 
Free memory used by 
symbol. #include <tools/hash.h> 
HASH TAB *maketab Support Functions-Appendix A 
(unsigned maxsym, unsigned (*hash)(), 
unsigned (*cmp) ()) 
Make a hash table of the size specified in maxsym. The hash table is a data struc­
ture that the manager uses to organize the database entries. It contains a "hash 
table" array along with various other housekeeping variables. The maxsym argu­
ment controls the size of the array component of the data structure, but any 
number of entries can be put into the table, regardless of the table size. Different 
table sizes will affect the speed with which a record can be accessed, however. If 
the table is too small, the search time will be unnecessarily long. Ideally the table 
should be about the same size as the expected number of table entries. There is 
no benefit in making the table too large? It's a good idea to make maxsym a 
prime number 4 Some useful sizes are: 47, 61, 89, 113, 127, 157, 193, 211, 257, 
293,337,367,401. Ifmaxsym is zero, 127 is used. 
The functions referenced by the two pointer arguments (hash and cmp) are used 
to manipulate the database. The hash function is called indirectly, like this: 
(*hash) ( sym ) ; 
where sym is a pointer to a region of memory allocated by newsym ( ) , which is 
used like malloc ( ) to allocate a new table element. The assumption is that 
newsym ( ) is getting space for a structure, one field of which is the key. The 
hash function should return a pseudo-random number, the value of which is con­
trolled by the key; the same key should always generate the same number, but 
different keys should generate different numbers. The simplest, but by no means 
the best, hash strategy just adds together the characters in the name. Better 
methods are discussed in Chapter Six. Two default hash functions are discussed 
below. 
The comparison function (cmp) is passed two pointers to database records. It 
should compare the key fields and return a value representing the ordering of the 
keys in a manner analogous to strcmp (). A call to (*cmp) (pl, p2) should 
return a negative number if the key field in the structure pointed to by pl is less 
than the one in *p2. It should return 0 if the two keys are identical, and it should 
return a positive number if the key in *p2 is greater. 
maketab () prints an error message and raises SIGABRT if there's not enough 
memory. (It works the same way as newset ( ) in this regard.) 
void *newsym(int size) 
This routine is used like malloc ( ) to get space for a database record. The 
returned memory is initialized to zeros. Typically, you use newsym ( ) to allo­
cate a structure, one field of which is the key. The routine prints an error message 
and raises SIGABRT if there's not enough memory. The pointer returned from 
newsym () may not be passed to free (); use freesym (),below. 
void freesym(void *sym) 
This routine frees the memory for a symbol created by a previous newsym ( ) 
3. You tend to get no fewer collisions in a too-long table. You just get holes. 
4. The distribution of elements in the table tends to be better if the table size is prime. 
Section A.3-Database Maintenance-Hashing: 
call. You may not use free () for this purpose. Do not free symbols that are still 
in the table-remove them with a delsym () call first. 
void *addsym(HASH_TAB *tabp, void *sym) 
Add a symbol to the hash table pointed to by tabp-a pointer returned from a 
previous maketab ( ) call. The sym argument points at a database record, a 
pointer to which was returned from a previous newsym ( ) call. You must initial­
ize the key field of that record prior to the addsym ( ) call. 
void *findsym(HASH_TAB *tabp, void *sym) 
Return either a pointer to a previously-inserted database record or NULL if the 
record isn't in the database. If more than one entry for a given key is in the data­
base, the most recently added one is found. The sym argument is used to identify 
the record for which you're searching. It is not used directly by findsym (),but 
is passed to the hash and comparison functions. The comparison function is 
called as follows: 
(*cmp) (sym, item_in_table); 
Here, item_in_table is a pointer to an arbitrary database element, and sym is 
just the second argument to findsym ( ) . 
Strictly speaking, sym should be a pointer to an initialized database record 
returned from newsym ( ) . It's inconvenient, though, to allocate and initialize a 
structure just to pass it to findsym ( ) . You can get around the problem in one 
common situation. If the key field is a character array, and that array is the first 
field in the structure, you can pass a character-string name to findsym ( ) as the 
key. This is a hack, but is nonetheless useful. The technique is illustrated in 
Listing A. II. This technique works only if the key is a character array-the 
string must be physically present as the first few bytes of the structure. Character 
pointers won't work. Note that strcmp () is used as the comparison function. 
This works only because the array is at the top of the structure, so the structure 
pointer passed to s t rcmp is also the address of the key array. 
void delsym(HASH_TAB *tabp, void *sym) 
Remove a symbol from the hash table, a pointer to which was returned by a previ­
ous findsym () call. sym is the pointer returned from findsym ( ) and tabp is 
a pointer returned from maketab ( ) . The record is removed from the table, but 
the associated memory is not freed, so you can recycle it-you can reinitialize the 
record and reinsert it into the table at a later time. Use freesym () to free the 
memory used by sym-you may not use free () for this purpose. It's a serious 
error to delete a symbol that isn't actually in the table-addsym () must have 
been called for a node before delsym () can be called. 
void *nextsym(HASH_TAB *tabp, void *last) 
This function finds all references to objects in a table that have the same name. 
The first such object is found by find_ s ym ( ) . The second object is found by 
passing the pointer returned from find_ sym ( ) to nextsym (), which returns 
either a pointer to the next object or NULL if there are no such objects. Use it like 
this: 713 
Add symbol to table. 
Find symbol in table. 
Simplifying findsym () 
calls by subterfuge. 
Remove symbol from 
table. 
Get next symbol. 
714 Support Functions-Appendix A 
Listing A.ll. Fooling findsym () 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 typedef struct 
{ 
char name[ SIZE]; 
int other_stuff; 
ENTRY; I* must be first, and must be an array *I 
hash( key 
char *key; 
{ 
int i = 0; 
while( *key I* Add together characters in the name *I 
I* use a left shift to randomize the number *I 
i += *key++ << 1 
ignaz () 
{ 
HASH TAB 
extern *tab; 
hash_ add() ; 
extern strcmp(); 
ENTRY *p; I* hash function *I 
tab maketab( 61, hash, strcmp ); 
p = findsym( Tab, "krazy" ); 
p = findsym( Tab, "krazy" ); 
if( ! (p = nextsym(Tab, p)) ) 
I* no more symbols *I I* Get the first one. *I 
I* Get the next one. *I 
Third and subsequent objects are found by passing nextsym ( ) the value 
returned from the previous nextsym ( ) call. 
Print entire database. int ptab(HASH_TAB *tabp, void (*print)(), void *param, 
int sort) 
Print all records in the database represented by the hash table pointed to by t abp. 
The function pointed to by print is called for every element of the table as fol­
lows: 
{*print) ( sym, param ) 
If sort is false, the table elements are printed in random order and 1 is always 
returned. If sort is true, the table is printed only if the routine can get memory 
to sort the table. Zero is returned (and nothing is printed) if memory isn't avail­
able, otherwise 1 is returned and the table is printed in order controlled by the 
comparison function passed to maketab () . If this comparison function works as 
described earlier, the table is printed in ascending order. Reverse the sense of the 
return value to print in descending order. In the current example, you can change 
the comparison function as follows, reversing the arguments to strcmp (): 
Section A.3-Database Maintenance-Hashing: 
cmp( a, b 
ENTRY *a, *b; 
{ /* Print in descending order */ 
return strcmp( b->key, a->key ); 715 
unsigned hash_add(char *name); 
unsigned hash_pjw(char *name); Default hash functions. 
These two functions are hash functions that you can pass to maketab ( ) . They 
are passed character strings and return a pseudo-random integer generated from 
that string. hash_ add ( ) just adds the character in the name-it's fast but 
doesn't work well ifthe table size is larger than 128 or if keys are likely to be per­
mutations of each other. The hash _pjw ( ) function uses a shift-and-exclusive­
OR algorithm that yields better results at the cost of execution speed. As with 
findsym ( ) , if the table entries have a character-array key at the top of the 
structure, these functions can be used directly by maketab ( ) , 
typedef struct 
{ 
char key[ 80 ]; 
int stuff; 
ENTRY; 
maketab ( ... , hash_pjw, ... ) ; 
Otherwise, you'll have to encapsulate the hash function inside a second function 
like this: 
typedef struct 
{ 
int stuff; 
char *key; 
ENTRY; 
hash_funct( sym) 
ENTRY *sym; 
{ 
return hash_add( sym->key ); 
maketab( ... , hash_funct, ... ); 
A.3.1 Hashing-Implementation 
I've used data abstraction extensively in the package presented here. That is, the Data abstraction. 
mechanics of manipulating the database is hidden from the user of the routines. For 
example, the user calls one function to allocate a data-base block of an arbitrary size in a 
manner similar to malloc (). The block is then modified as necessary, and it's inserted 
into the database with a second function call. The mechanics of allocating space, of 
doing the insertion, and so forth, are hidden in the functions. Similarly, the internal data 
structures used for database maintenance are also hidden. This abstraction makes these 
routines quite flexible. Not only can you use them in disparate applications, but you can 
change the way that the database is maintained. As long as the subroutine-call interface 
is the same, you don't have to change anything in the application program. 
The hash functions work with two data structures. I'll look at the C definitions and 
allocation functions first, and then describe how they work. 
716 Support Functions-Appendix A 
A hash-table element, 
BUCKET, newsym (). The first structure is the BUCKET, declared in hash.h, (the start of which is in Listing 
A.12). The newsym() function, (in Listing A.l2) allocates a BUCKET along with the 
memory requested by the user. newsym ( ) simultaneously allocates enough memory for 
both the BUCKET header, and for a user space, the size of which is passed in as a parame­
ter. It returns a pointer to the area just below the header, which can be used in any way 
by the application program: 
pointer returned next from malloc () prev 
pointer returned ~ 
from newsym () user 
T area J 
Listing A.l2. hash.h- The BUCKET 
1 
2 
3 
4 
5 
6 typedef struct BUCKET 
{ 
struct BUCKET 
struct BUCKET 
BUCKET; *next; 
**prev; 
Listing A.13. hash.c- BUCKET Allocation 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 PUBLIC void *newsym( size ) 
int size; 
{ /* Allocate space for a new symbol; return a pointer to the user space. */ 
BUCKET *sym; 
if( ! (sym 
{ (BUCKET*) calloc( size+ sizeof(BUCKET), 1)) 
fprintf( stderr, "Can't get memory for BUCKET\n" ); 
raise( SIGABRT ); 
return NULL; 
return (void*) ( sym + 1 ); /* return pointer to user space */ 
1*----------------------------------------------------------------------*l 
PUBLIC void freesym( sym ) 
void *sym; 
{ 
free( (BUCKET *)sym- 1 ); 
Freeing BUCKETS, 
freesym(). The freesym ( ) function, also in Listing A.l3, frees the memory allocated by a pre­
vious newsym ( ) . It just backs up the sym pointer to its original position and then calls 
free ( ). 
The hash table itself, 
HASH TAB. The second data structure of interest is the HASH TAB which holds the actual hash 
table itself. (It's declared in Listing A.l4.) Like a BUCKET, it's a structure of variable 
length. The header contains the table size in elements (size), the number of entries 
Section A.3.1-Hashing-Implementation 
currently in the table (numsyms), pointers to the hash and comparison functions (hash 
and cmp), and the table itself (table is the first element of the table). The numsyms 
field is used only for statistical purposes-it's not needed by any of the hash-table func­
tions. 
The maketab ( ) function (in Listing A.15) allocates a single chunk of memory big 
enough to hold both the header and an additional area that will be used as the array. The 
table is declared as a one-element array, but the array can actually be any size, pro­
vided that there's enough available memory following the header. I'm taking advantage 
of the fact that C doesn't do array-boundary checking when the array is accessed. Making a hash table, 
maketab (). 
Listing A.l4. hash.h- HASH TAB Definition 
7 
8 
9 
10 
11 
12 
13 
14 
15 typedef struct hash tab 
{ 
int 
int 
unsigned 
int 
BUCKET 
HASH_TAB; size 
numsyms 
(*hash) (); 
(*cmp) () ; 
*table[l]; I* Max number of elements in table *I 
number of elements currently in table *I 
hash function *I I* 
I* 
I* 
I* comparison funct, cmp(name,bucket_p); 
First element of actual hash table *I *I 
Listing A.lS. hash.c- HASH TAB Allocation 
PUBLIC HASH TAB *maketab( maxsym, hash_function, cmp_function ) 
unsigned 
unsigned 
int maxsym; 
(*hash_function) (); 
(*cmp_function) (); 
I* Make a hash table of the indicated size. *I 
HASH TAB *p; 
if( !maxsym ) 
maxsym = 127; 717 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 I* 1<---space for table ---->1<- and header -->1 *I 
if( p=(HASH_TAB*) calloc(l, (maxsym * sizeof(BUCKET*)) + sizeof(HASH_TAB)) ) 
{ 
else p->size 
p->numsyms 
p->hash 
p->cmp maxsym 
0 
hash function 
cmp_function 
fprintf(stderr, "Insufficient memory for symbol table\n"); 
raise( SIGABRT ); 
return NULL; 
return p; 
These two structures interact as shown in Figure A.l. The actual table is an array of BUCKETs in a HASH_ TAB. 
BUCKET pointers. Empty table elements are set to NULL, and new BUCKETs are tacked 
onto the head of the list. 
718 Support Functions-Appendix A 
Figure A.l. A Hash Table with Two Elements in It 
HASH TAB 
size 
numsyms 
hash 
cmp 
_t~b]e_[Q]_ 
- - - -_,;:. -\ ~-\ BUCKET 
------pr~v I next • I NULL prev next u user user 
1 area J 1 area J 
Adding symbols to the 
table, addsym () . The addsym () function, which puts items into the table, is in Listing A.l6. A 
pointer to the current hash-table element, p, is initialized on line 68 by calling the hash 
function indirectly through the hash pointer in the HASH_ TAB header. Note that the 
BUCKET pointer (sym) comes into the routine pointing at the user area. It is decremented 
to point at the BUCKET header on line 68 after the hash function is called. The code on 
lines 70 to 73 link the new node to the head of a chain found at the previously computed 
array element. 
Listing A.16. hash.c- Adding a Symbol to the Table 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 PUBLIC void *addsym( tabp, isym ) 
HASH TAB *tabp; 
void *isym; 
/* Add a symbol to the hash table. */ 
BUCKET 
BUCKET **p, *tmp 
*sym = (BUCKET *)isym; 
p = & (tabp->table) [ (*tabp->hash) ( sym--) % tabp->size ] ; 
tmp *p 
*p sym 
sym->prev p 
sym->next tmp 
if( tmp ) 
tmp->prev = &sym->next 
tabp->numsyms++; 
return (void*) (sym + 1); 
BUCKETs form a doubly 
linked list, backwards 
pointers. Note that the chain of BUCKETs is a doubly-linked list. You need the backwards 
pointers to delete an arbitrary element in the table without having to search for that ele­
ment. The only obscure point is the two stars in the definition of the backwards 
Section A.3.1-Hashing-Imp1ementation 
pointer-the forward pointer (next) is a pointer to a BUCKET, but the backwards pointer 
(prev) is a pointer to a BUCKET pointer. You need this extra level of indirection 
because the head of the chain is a simple pointer, not an entire BUCKET structure. The 
backwards pointer for the leftmost node in the chain points at the head-of-chain pointer. 
All other backwards pointers hold the address of the next field from the previous node. 719 
You can see the utility of this system by looking at the code necessary to delete an 
arbitrary node. Say that you want to delete the node pointed to by p in the following pic­
ture: Deleting a BUCKET from 
the table, delsym (). 
1 user 
area 1 1 p 
user 
area 1 
The removal can be accomplished with the following statement: 
if( *(p->prev) = p->next 
p->next->prev = p->prev ; 1 user 
area 1 
The pointer from the previous node (the one that points at the node to delete) is modified 
first so that it points around the deleted node. Then the backwards pointer from the next 
node is adjusted. The if is required because the next pointer is NULL on the last node 
in the chain. The double indirection on the backwards pointer makes this code work 
regardless of the position of the node in the chain-the first and last nodes are not spe­
cial cases. The delsym ( ) function, which removes an arbitrary node from the table, is 
shown in Listing A.l7. 
Listing A.l7. hash.c- Removing A Node From The Table 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 PUBLIC void delsym( tabp, isym ) 
HASH TAB *tabp; 
void *isym; 
/* 
* 
* 
*I Remove a symbol from the hash table. "sym" is a pointer returned from 
a previous findsym() call. It points initially at the user space, but 
is decremented to get at the BUCKET header. 
BUCKET *sym = (BUCKET *)isym; 
if( tabp && sym 
{ 
--tabp->numsyms; 
--sym; 
if( *(sym->prev) sym->next 
sym->next->prev = sym->prev ; 
720 Support Functions-Appendix A 
Finding symbols, The two symbol-finding functions, findsym ( ) and nextsym ( ) , are in Listing 
findsym(l • nextsym() · A.18. findsym ( ) just hashes to the correct place in the table and then chases down the 
chain, looking for the required node. It returns a pointer to the user area of the BUCKET 
(thus the +1 on line 119), or NULL if it can't find the required node. nextsym ( ) just 
continues chasing down the same chain, starting where the last search left off. 
Listing A.18. hash.c- Finding a Symbol 
101 
102 
103 
104 
105 
106 
107 
108 109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 PUBLIC void 
HASH TAB 
void 
{ *findsym( tabp, sym ) 
*tabp; 
*sym; 
I* Return a pointer to the hash table element having a particular name 
* or NULL if the name isn't in the table. 
*I 
BUCKET *p 
if( !tabp 
return NULL; I* Table empty *I 
p = (tabp->table) [ (*tabp->hash) (sym) % tabp->size ]; 
while( p && (*tabp->cmp) ( sym, p+1 
p = p->next; 
return (void*) ( p? p + 1 :NULL); 
1*----------------------------------------------------------------------*l 
PUBLIC void *nextsym( tabp, i last 
HASH TAB *tabp; 
void *i_last; 
{ 
I* Return a pointer the next node in the current chain that has the same 
*key as the last node found (or NULL if there is no such node). "last" 
* is a pointer returned from a previous findsym() of nextsym() call. 
*I 
BUCKET *last= (BUCKET *)i_last; 
for(--last; last->next ; last = last->next ) 
if( (tabp->cmp) (last+1, last->next +1) == 0 
return (char*) ( last->next + 1 ); 
return NULL; I* keys match *I 
Printing the entire data­
base: ptab < l. The last of the support functions is ptab ( ) , which prints the table. It starts on line 
142 of Listing A.19. The loop on lines 166 to 173 prints the table in the most straightfor­
ward manner. The outer loop goes through the table from top to bottom looking for 
chains. The inner loop traverses the chain, calling the print function indirectly at each 
node. 
The else clause on lines 177 to 214 handles sorted arrays. It allocates an array of 
BUCKET pointers on line 184 and initializes the array to point at every BUCKET in the 
table with the loop starting on line 189. (This is essentially the same loop that printed 
the unsorted array). The new array is sorted on line 208 using assort ( ) , a variant of 
Section A.3.1-Hashing-Implementation 721 
Listing A.19. hash.c- Printing the Table 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 PRIVATE int (*User_cmp) (); 
PUBLIC int ptab( tabp, print, param, sort ) 
HASH TAB *tabp; I* Pointer to the table *I 
void ( * print) (); I* Print function used for output *I 
void *par am; 
sort; I* Parameter passed to print function *I 
I* Sort the table if true. *I int 
{ 
I* Return 0 if a sorted table can't be printed because of insufficient 
* memory, else return 1 if the table was printed. The print function 
* is called with two arguments: 
* (*print) ( sym, param ) 
* 
* Sym is a pointer to a BUCKET user area and param is the third 
* argument to ptab. 
*I 
BUCKET 
int 
int **outtab, **outp, *sym, **symtab 
internal_ cmp () ; 
i; 
if ( ! tabp I I tabp->size 
return 1; 0 ) I* Table is empty *I 
if( !sort ) 
{ 
for( symtab = tabp->tab1e, i = tabp->size ; --i >= 0 
{ symtab++ ) 
I* Print all symbols in the current chain. The +1 in the print call 
* increments the pointer to the applications area of the bucket. 
*I 
else 
{ 
I* 
* 
* 
* 
* *I for( sym = *symtab ; sym ; sym 
(*print) ( sym+1, param )·; sym->next ) 
Allocate memory for the outtab, an array of pointers to 
BUCKETs, and initialize it. The outtab is different from 
the actual hash table in that every outtab element points 
to a single BUCKET structure, rather than to a linked list 
of them. 
if ( ! ( out tab 
return 0; (BUCKET**) malloc(tabp->numsyms * sizeof(BUCKET*)) )) 
outp = outtab; 
for( symtab = tabp->table, i 
for( sym = *symtab ; sym 
{ tabp->size ; --i >= 0 
sym = sym->next 
if( outp > outtab + tabp->numsyms ) 
{ symtab++ ) 
fprintf(stderr,"Internal error [ptab], table overflow\n"); 
exit (1); 
.... 
722 Support Functions-Appendix A 
Listing A.l9. continued ••. 
198 *outp++ sym; 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 I* 
* 
* 
* 
*I Sort the outtab and then print it. The (*outp)+l in the 
print call increments the pointer past the header part 
of the BUCKET structure. During sorting, the increment 
is done in internal_cmp. 
User_cmp = tabp->cmp; 
assort( outtab, tabp->numsyms, sizeof( BUCKET* ), internal_cmp ); 
for( outp = outtab, i = tabp->numsyms; --i >= 0 ; outp++ ) 
(*print) ( (*outp) +1, param ) ; 
free( outtab ); 
return 1; 
PRIVATE int internal_cmp( p1, p2 ) 
BUCKET **p1, **p2; 
{ 
(*User_cmp) ( *p1 + 1, *p2 + 1 ) ; 
the UNIX qsort ( ) function that uses a Shell sort rather than a quicksort. (It's discussed 
later on in this appendix.) The sorted array is printed by the loop on line 210. 
The sorting is complicated because, though the comparison function must be passed 
two pointers to the user areas of buckets, assort ( ) passes the sort function two 
pointers to array elements. That is, assort ( ) passes two pointers to BUCKET pointers 
to the comparison function. The problem is solved by putting a layer around the user­
supplied comparison function. assort ( ) calls internal_ cmp ( ) , declared on line 
218, which strips off one level of indirection and adjusts the BUCKET pointer to point at 
the user space before calling the user-supplied function. The user's comparison func­
tions must be passed by a global variable (User_ cmp, declared on line 140). 
Finishing up with the hash-table functions themselves, remainder of hash.h contains 
various function prototypes-it's shown in Listing A.20. Similarly, there are a bunch of 
#includes at the top of hash.c, shown in Listing A.21. 
Listing A.20. hash.h- HASH TAB Function Prototypes 
16 extern HASH TAB *maketab p ( ( unsigned maxsym, unsigned (*hash) (), int (*cmp) ())); 
17 extern void *newsym p ( ( int size ) ) ; 
18 extern void freesym p ( ( void *sym ) ) ; 
19 extern void *addsym p ( ( HASH TAB *tabp, void *sym ) ) ; 
20 extern void *findsym p ( ( HASH TAB *tabp, void *sym ) ) ; 
21 extern void *nextsym p ( ( HASH TAB *tabp, void *last ) ) ; 
22 extern void delsym p ( ( HASH TAB *tabp, void *sym ) ) ; 
23 extern int ptab p ( ( HASH TAB *tabp, void(*prnt) (), void *par, int srt)); 
24 unsigned hash add p ( ( unsigned char *name ) ) ; I* in hashadd.c *I 
25 unsigned hash_pjw P(( unsigned char *name ) ) ; I* in hashpjw.c *I 
Section A.3.1-Hashing-Implementation 
Listing A.21. hash.c-#includes 
1 #include <stdio.h> 
2 #include <ctype.h> 
3 #include <signal.h> 
4 #include <stdlib.h> 
5 #include <string.h> 
6 #include <tools/debug.h> 
7 #include <tools/hash.h> 
A.3.2 Two Hash Functions 
Implementations of the two default hash functions discussed in Chapter Six are 
shown in Listings A.22 and A.23. 
Listing A.22. hashadd.c- An Addition-Based Hash Function 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 #include <tools/debug.h> 
#include <tools/hash.h> !*----------------------------------------------------------------------
* Hash function for use with the functions in hash.c. Just adds together 
* characters in the name. 
*I 
unsigned hash_add( name 
unsigned char *name; 
{ 
unsigned h 
for( h = 0; *name 
return h; h += *name++ ) 
I've modified Aho's version of hashyjw considerably in order to make it portable- Implementing 
the original version assumed that the target machine had a 32-bit unsigned int. All hash _pjw 0 · 
the macros on lines four to seven of Listing A.23 are for this purpose. 
NBITS _IN_ UNSIGNED evaluates to the number of bits in an unsigned int, using the 
NBITS macro from <toolsldebug.h>. You could also use the ANSI CHAR_BIT macro 
(defined in limits.h) and multiply it by eight, but that's risky because a char might not 
be eight bits wide. SEVENTY _FIVE _PERCENT evaluates to the number of bits required 
to isolate the bottom :X of the number. Given a 16-bit int, it will evaluate to 12. 
TWELVE_PERCENT works the same way, but it gets Ys of the number-2, given a 16-bit 
int. HIGH_ BITS is a mask that isolates the bits in the top Ys of the number-it's Ox3flf 
for a 16-bit int. 
Note that most of the computation in the macros is folded out of existence by the 
optimizer (because everything's a constant, so the arithmetic can be performed at com­
pile time). For example: 
h ·= g >> (int) ((sizeof(unsigned) * CHAR_BIT) * .75 ); 
generates the following code with Microsoft C, version 5.0: 723 
724 Support Functions-Appendix A 
Listing A.23. hashpjw.c- The hashpjw Function 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 lincluda <tools/debug.h> 
linclude <tools/hash.h> /* for prototypes only */ 
#define NBITS IN UNSIGNED 
ldefine SEVENTY FIVE PERCENT 
fdefine TWELVE PERCENT 
ldafine HIGH BITS ( NBITS(unsigned int) ) 
((int) ( NBITS_IN_UNSIGNED * .75 )) 
((int) ( NBITS_IN_UNSIGNED * .125 )) 
( -( (unsigned) (-0) >> TWELVE_PERCENT) 
unsigned hash_pjw( name 
unsigned char *name; 
{ 
unsigned h 0; /* Hash value */ 
unsigned g; 
for(; *name ++name ) 
{ 
h (h << TWELVE_PERCENT) + *name ; 
if( g h & HIGH_BITS ) 
h = (h A (g >> SEVENTY_FIVE_PERCENT)) & -HIGH BITS 
return h; 
mov cl,12 
shr ax,cl 
xor dx,ax 
Similarly: 
g = h & -( (unsigned) ( -o) » ( (int) (NBITS_IN_UNSIGNED * .125))) 
becomes: 
mov dx,ax 
and ax,-16384 
If you modify these constants, don't convert the floating-point numbers to fractions, 
or else they'll end up as zero. For example, (NBITS_IN_UNSIGNED * (l/8)) won't 
work because the 1/8 will evaluate to 0 (integer arithmetic is used). 
The algorithm uses a shift-and-XOR strategy to randomize the input key. The main 
iteration of the loop shifts the accumulated hash value to the left by a few bits and adds 
in the current character. When the number gets too large, it is randomized by XORing it 
with a shifted version of itself. 
A.4 The ANSI Variable-Argument Mechanism 
Using the <stdarg.h> 
macros. This book uses the ANSI-approved method of supporting subroutines with a variable 
number of arguments, which uses various macros declared in <stdarg.h>, for this pur­
pose. Since not all C environments support <stdarg.h>, this section presents a version 
of the macros in this file. Before looking at <stdarg.h> itself, however, the following 
subroutine demonstrates how the macros are used. The print_ int subroutine is passed 
an argument count followed by an arbitrary number of int-sized arguments, and it prints 
those arguments. 5 
Section A.4-The ANSI Variable-Argument Mechanism 
print int( arg count, .•• ) 
int -arg_count; 
{ 
va_list args; 
va_start( args, arg_count ); 
while( --arg_count >= 0 ) 
printf ( "%d ", va_arg (args, int) ) ; 
va_end( args ); 
The args variable is a pointer to the argument list. It is initialized to point at the second 
argument in the list with the va _start ( ) call, which is passed the argument pointer 
(args) and the name of the first argument (arg_count). This first argument can be 
accessed directly in the normal way-the va _ arg ( ) macro is used to get the others. 
This macro is passed the argument pointer, and the expected type of the argument. It 
evaluates to the current argument, and advances the argument pointer to the next one. In 
this case, the arguments are all ints, but they would be different types in an application 
like print f ( ) . The va _end ( ) macro tells the system that there are no more argu­
ments to get (that the argument pointer has advanced to the end of the list). 
The foregoing is implemented in <stdarg.h>, shown in Listing A.24. The 
argument-pointer ·type, va_list, is a pointer to char. It's declared as such because 
pointer arithmetic on a character pointer is just plain arithmetic. When you add 1 to a 
character pointer, you actually add 1 to the physical pointer (because the size of a char­
acter is 1). The best way to understand the other two macros is to watch them work. A 
typical C compiler passes arguments to subroutines by pushing them onto the run-time 
stack in reverse order. A call like 
int me, 
long Ishmael; 
call( me, Ishmael ); 
looks like this on the stack (assuming a 16-bit int and a 32-bit lonq): 
100 
102 
104 
106 -other stuff 
return address 
me 
Ishmael -725 
Start up variable­
argument processing, 
va_start (). 
Get arguments, 
va_arg(). 
End variable-argument 
processing, va _end ( ) . 
va_list, implemented 
as char*. 
Theva_start (me, arg_ptr); macro initializes arg_ptr to point at the second Implementing 
argument as follows: & first evaluates to the address of me-to 1{)()-and va-start 0 · 
100+sizeof (first) yields 102, the base address of the next argument on the stack. 
5. Note that the ellipsis in the print int () argument list is not supported by UNIX C. The VA_LIST macro 
in <debug.h>, discussed on page 684, can be used to correct this deficiency. VA LIST is used in various 
subroutines in subsequent sections. -
726 Support Functions-Appendix A 
Listing A.24. stdarg.h- Support for Variable-Argument Lists 
1 
2 
3 
4 typedef char *va_list; 
#define va_start(arg_ptr,first) 
#define va_arg(arg_ptr,type) 
#define va_end(arg_ptr) arg ptr = (va list)&first + sizeof(first) 
((type *) (arg_ptr += sizeof(type))) [-1] 
/* empty */ 
The cast is required in front of &first in order to defeat pointer arithmetic; otherwise 
lmplementingva_arg(). you'd get 104, because &first evaluates to an int pointer by default. A subsequent 
va_arg(arg_ptr,long) call will fetch Ishmael and advance the pointer. It 
expands to: 
Convert string to long. 
Translate escape se­
quences to binary. ((long *) (arg_ptr += sizeof(long))) [-1] 
The arg ptr += sizeof (long) yields 106 in this example. That is, it yields a 
pointer to just past the variable that you want. The (long *) ( 1 0 6) is treated as if it 
were a pointer to an array of longs that had been initialized to point at cell 106, and the 
[ -1] gets the long-sized number in front of the pointer. You could think of the whole 
thing like this: 
long *p; 
p = (long *)arg_ptr; 
++p; 
target = p[-1]; 
arg_ptr += sizeof(long); /* pointer to current argument */ 
/* skip past it */ 
/* fetch it by backing up. */ 
I* skip to next argument */ 
Note that some non-ANSI compilers can do the foregoing with: 
* ((long *)arg_ptr) ++ 
but this statement isn't acceptable to many compilers (because the cast forms an rvalue, 
and++ must be applied to an !value). 
A.S Conversion Functions 
This section contains descriptions of several small data-conversion subroutines: 
long stol (char **str) 
unsigned long stoul(char **str) 
These routines are somewhat more powerful versions of the standard atoi (). 
stol () is passed the address of a character pointer (note the double indirection). 
It returns, in a long, the value of the number represented by the string, and 
updates the pointer to point past the number. If the string begins with a Ox, the 
number is assumed to be hex; otherwise, if it begins with a 0, the number is 
assumed to be octal; otherwise it is decimal. Conversion stops on encountering 
the first character that is not a digit in the indicated radix. Leading white space is 
ignored, and a leading minus sign is recognized. stoul () works much the same, 
except that it returns an unsigned long, and doesn't recognize a leading minus 
sign. 
int esc(char **s) 
Returns the character associated with the "escape sequence" pointed to by * s 
and modifies * s to point past the sequence. The recognized strings are summar­
ized in Table A. I. 
Section A.5 -Conversion Functions 727 
Table A.l. Escape Sequences Recognized by esc () 
Input Returned Notes string value 
\b Ox08 Backspace. 
\f OxOc Form feed. 
\n OxOa Newline. 
\r OxOd Carriage return. 
\s Ox20 Space. 
\t Ox09 Horizontal tab. 
\e Ox1b ASCII ESC character. 
\DDD Ox?? Number formed of 1-3 octal digits. 
\xDD Ox?? Number formed of 1-3 hex digits. 
\AC Ox?? C is any letter. The equivalent control code is returned. 
\c c a backslash followed by anything else returns the character following the 
backslash (and *sis advanced two characters). 
c c Characters not preceded by a backslash are just returned (and * s is advanced 1 
character). 
char *bin_to_ascii(int c, int use_hex) Convert binary to printing 
ASCII. 
Return a pointer to a string that represents c in human-readable form. This string 
contains only the character itself for normal characters; it holds an escape 
sequence (\n, \ t, \xOO, and so forth) for others. A single quote(') is returned as 
the two-character string "\' ". The returned string is destroyed the next time 
bin_to_ascii () is called, so don't call it twice in a single printf () state-
ment. If use_ hex is true then escape sequences of the form \xDD are used for 
nonstandard control characters (D is a hex digit); otherwise, sequences of the 
form \DOD are used (D is an octal digit). 
stoul () and stol () are implemented in Listing A.25. The esc ( ) subroutine is Implementing esc 0. 
in Listing A.26, and bin_to_ascii () is in Listing A.26 All are commented 
sufficiently that no additional description is needed here. 
Listing A.25. stol.c-Convert String-to-Long 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 #include <ctype.h> 
unsigned long stoul(instr) 
char **instr; 
{ 
/* Convert string to long. If string starts with Ox it is interpreted as 
* a hex number, else if it starts with a 0 it is octal, else it is 
* decimal. Conversion stops on encountering the first character which is 
* not a digit in the indicated radix. *instr is updated to point past the 
* end of the number. 
*I 
unsigned long num 
char *str 
while( isspace(*str) 
++*str ; 0 ; 
*instr; 
728 Support Functions-Appendix A 
Listing A.25. continued ••• 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 if(*str != '0') 
{ 
while( isdigit(*str) 
elae 
{ num = (num * 10) + (*str++- '0'); 
if (*++str == 'x' I I *str == 'X') 
{ 
for( ++str; isxdigit(*str); ++str I* hex *I 
num = (num * 16) + ( isdigit(*str) ? *str-'0' 
elae 
{ 
while( '0' <= *str && *str <= '7' ) 
{ 
num *= 8; 
num += *str++ -'0' 
*instr = str; 
return ( num ) ; toupper(*str) -'A' + 10 ); 
I* octal *I 
1*----------------------------------------------------------------------*l 
long stol(instr) 
char **instr; 
{ 
I* Like stoul(), but recognizes a leading minus sign and returns a signed 
* long. 
*I 
while( isspace(**instr) 
++*instr ; 
if( **instr != '-' 
return (long) ( stoul(instr) ); 
alae 
{ 
++*instr; 
return -(long) ( stoul(instr) ); I* Skip the minus sign. *I 
Listing A.26. esc.c-Map Escape Sequences to Binary 
1 
2 
3 
4 
5 
6 #include <stdio.h> 
#include <ctype.h> 
#include <toolsldebug.h> 
I* ESC.C Map escape sequences to single characters *I 
Section A.5-Conversion Functions 729 
Listing A.26. continued ... 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 39 
40 
41 
42 43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 PRIVATE int hex2bin P(( int c)); 
PRIVATE int oct2bin P(( int c)); 
/*------------------------------------------------------------*/ 
#define ISHEXDIGIT(x) (isdigit(x) II (1a1<=(x)&&(x)<=1f1) II (1A1<=(x)&&(x)<=1F1)) 
#define ISOCTDIGIT (x) ( 101 <= (x) && (x) <=1 71) 
PRIVATE int hex2bin(c) 
int c; 
/* Convert the hex digit represented by 1C1 to an int. 1c' must be one of 
* the following characters: 0123456789abcdefABCDEF 
*I 
return (isdigit(c) ? (c)-101: ((toupper(c))-1A1)+10) & Oxf; 
PRIVATE int oct2bin(c) 
int c; 
/* Convert the hex digit represented by 'c' to an int. 'c' must be a 
*digit in the range '0'-'7'. 
*I 
return ( ((c)-101) & Ox7 ); 
/*------------------------------------------------------------*/ 
PUBLIC int esc(s) 
char **s; 
{ 
/* Map escape sequences into their equivalent symbols. Return the equivalent 
* ASCII character. *s is advanced past the escape sequence. If no escape 
* sequence is present, the current character is returned and the string 
* is advanced by one. The following are recognized: 
* 
* \b 
* \f 
* \n 
* \r 
* \s 
* \t 
* \e 
* \DDD 
* \xDDD 
* \-c 
*I backspace 
formfeed 
newline 
carriage return 
space 
tab 
ASCII ESC character ('\033') 
number formed of 1-3 octal digits 
number formed of 1-3 hex digits (two required) 
C = any letter. Control code 
register int rval; 
if( **s != 1\\1 
rval *( (*s)++ ); 
else 
{ 
++ (*s); 
switch( toupper(**s) ) 
{ 
case 1\01: rval 
case 1B1: rval I\\ I; 
I \bl ; /* Skip the \ */ 
break; 
break; 
730 
Listing A.26. continued ... 
65 case 'F': 
66 case 'N': 
67 case 'R': 
68 case , S': 
69 case 'T': 
70 case 'E': 
71 
72 case , .... , . 
73 
74 
75 
76 case 'X': 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 default: 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
111 
112 
113 
114 
115 ++(*s); 
116 
117 return rval; 
118 rval 
rval 
rval 
rval 
rval 
rval 
rval 
rval 
break; , \f' 
, \n' 
, \r' , , 
, \t' 
, \033'; 
*++(*s) 
toupper (rval) 
rval = 0; 
++ (*s); 
if( ISHEXDIGIT(**s) 
{ - , @' break; 
break; 
break; 
break; 
break; 
break; 
rval = hex2bin( *(*s)++ ); 
} 
if( ISHEXDIGIT(**s) 
{ 
rval <<= 4; 
rval I= hex2bin( *(*s)++ ); 
if( ISHEXDIGIT(**s) 
{ 
rval <<= 4; 
rval I= hex2bin( *(*s)++ ); 
--(*s); 
break; 
if( !ISOCTDIGIT(**s) 
rval = **s; 
else 
{ 
++ (*s); 
rval = oct2bin( *(*s)++ ); 
if( ISOCTDIGIT(**s) 
{ 
rval <<= 3; 
rval I= oct2bin( *(*s)++ ); 
} 
if( ISOCTDIGIT(**s) 
{ 
rval <<= 3; 
rval I= oct2bin( *(*s)++ ); 
--(*s); 
break; Support Functions-Appendix A 
Section A.5 -Conversion Functions 
Listing A.27. bintoasc.c- Convert Binary to Human-Readable String 
1 
2 
3 
4 
5 
6 
7 
8 
9 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/compiler.h> /* for prototypes only */ 
char 
{ *bin_to_ascii( c, use_hex ) 
/* Return a pointer to a string that represents c. This will be the 
* character itself for normal characters and an escape sequence (\n, \t, 
* \xOO, etc., for most others). A' is represented as \'. The string will 731 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 * be destroyed the next time bin to ascii () is called. If "use hex" is true 
*then \xDD escape sequences are-used. Otherwise, octal sequences (\DDD) 
*are used. (see also: pchar.c) 
*I 
static unsigned char buf[8]; 
c &= Oxff ; 
if ( ' ' <= c & & c < Ox7 f & & c ! = '\" & & c ! = '\ \' ) 
{ 
else 
{ c; buf[O] 
buf[l] , \01; 
buf[O] 1\\1 
buf[2] 1\01 
switch(c) 
{ 
case I\\ I: buf[l] 
case I\' I: buf[l] 
case '\bl: buf [1] 
case , \fl: buf[l] 
case , \tl: buf [1] 
case I \r': buf[l] 
case I \nl: buf[l] I\\ I i break; I\ I I i break; 
'bl break; 
, f1 break; It I break; 
lr' break; 
'n' break; 
default sprintf( &buf[1] 1 use hex ? "x%03x" "%03o" 1 c ) ; 
break; 
return buf; 
A.6 Print Functions 
This section describes several output functions, many of which use the ANSI 
variable-argument mechanism and the conversion functions described in the last two 
sections. They are organized functionally. 
void ferr(char *fmt, ... ) 
This routine is a version of print f ( ) for fatal error messages. It sends output 
to stderr rather than stdout, and it doesn't return; rather, it terminates the pro­
gram with the following call: Print error message and 
exit. 
732 Support Functions-Appendix A 
exit( on_ferr() ); 
(on_ ferr () is described below). Normally, the routine works like printf ( ) 
in other respects. If, however, it is called with ferr (NULL, string), it works 
like perror (string) in that it prints an error message associated with the most 
recent I/O-system error. The program still terminates as described earlier, how­
ever. The source code for ferr ( ) is in Listing A.28. The prnt ( ) call on line 
19 will be described in a moment. 
Listing A.28.ferr.c- Fatal-Error Processing 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 #include <stdio.h> 
#include <stdlib.h> /* errno is declared here *I 
#include <stdarg.h> 
#include <tools/debug.h> I* VA LIST definition is here *I 
#include <tools/ l. h> I* Needed only for prototype *I 
/* Note that ferr() is typed as int, even though it usually doesn't return, 
* because it's occasionally useful to use it inside a conditional expression 
*where a type will be required. VA_LIST expands to ... if ANSI is #defined, 
* otherwise it expands to _a_r_g_s_. 
*I 
int ferr( fmt, VA LIST 
char *fmt; 
{ 
va list args; 
va_start( args, fmt ); 
if( fmt 
else prnt 
perror 
va_end( args ); 
exit( on_ferr() ); fputc, stderr, fmt, args ); 
va_arg(args, char*) ); 
Error handler for ferr 0. int on_ ferr (void) 
Print human-readable 
string. 
Print human-readable 
character. This routine is the default error handler called by ferr ( ) just before exiting. It 
returns the current contents of the system errno variable, which is, in tum, 
passed back up to the operating system as the process' exit status. You can pro­
vide your own on_ferr () to preempt the library version. The source code is in 
Listing A.29. 
void fputstr(char *str, int maxlen, FILE *stream) 
This function writes a string (str) having at mostmaxlen characters to the indi­
cated stream in human-readable form. All control characters, and so forth, are 
mapped to printable strings using the bin_ to _ascii ( ) conversion function 
described earlier (on page 727). The source code is in Listing A.30. 
void pchar(FILE *stream, int c) 
This function works like putc ( ) , except that control characters are mapped to 
human-readable strings using bin_ to_ ascii ( ) . The source code is in Listing 
A.31. 
Section A.6-Print Functions 733 
Listing A.29. onferr.c- Action Function for ferr () 
1 linclude <stdlib.h> 
2 linclude <toolsldebug.h> 
3 lincluda <toolsll.h> I* Needed only for prototypes *I 
4 
5 I* This is the default routine called by ferr when it exits. It should return 
6 * the exit status. You can supply your own version of this routine if you like. 
7 *I 
8 int on_ferr () 
9 { 
10 extern int errno; 
11 return errno; 
12 
Listing A.30.fputstr.c- Fatal-Error Processing-Service Routine 
linclude <stdio.h> 
linclude <toolsldebug.h> 
linclude <toolslcompiler.h> 1 
2 
3 
4 
5 
6 
7 
8 
9 I* FPUTSTR.C: Print a string with control characters mapped to readable strings. 
*I 
10 
11 
12 
l3 
14 
15 
16 
17 
18 
19 
20 void 
char 
FILE 
{ fputstr( str, maxlen, stream ) 
*str; 
*stream; 
char *s; 
while( *str && maxlen >= 0 ) 
{ 
s = bin_to_ascii( *str++, 1 ) ; 
while( *s && --maxlen >= 0 ) 
putc( *s++, stream); 
Listing A.31. pchar.c- Print Character in Human-Readable Form 
1 
2 
3 
4 
5 
6 
7 
8 
9 linclude <stdio.h> 
linclude <toolsldebug.h> 
linclude <toolslcompiler.h> 
void 
FILE 
{ pchar(c, stream) 
*stream; 
fputs( bin_to_ascii( c, 1 ), stream); 
void printv(FILE *stream, char **argv) 
This function prints an argv-like array of pointers to strings to the indicated 
stream, one string per line (the 1 \n 1 is inserted automatically at the end of 
every string). The source code is in Listing A.32. Print vector array. 
734 Support Functions-Appendix A 
Listing A.32. printv.c- Print argv-like Vector Array 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 #include <stdio.h> 
void 
FILE 
char 
{ printv( fp, argv ) 
*fp; 
**argv; 
/* Print an argv-like array of pointers to strings, one string per line. 
* The array must be NULL terminated. 
*I 
while( *argv 
void 
FILE 
char 
{ fprintf( fp, "%s\n", *argv++ ) ; 
comment( fp, argv) 
*fp; 
**argv; 
/* Works like printv except that the array is printed as a C comment. */ 
fprintf(fp, "\n/*-----------------------------------------------------\n"); 
while ( *argv ) 
fprintf(fp, "* %s\n", *argv++ ); 
fprintf (fp, " */\n\n"); 
Print multiple-line com· 
ment. void comment(FILE *stream, char **argv) 
A printf o workhorse 
function. This function also prints an argv-like array of pointers to strings to the indicated 
stream, one string per line. The output text is put into a C comment, however. 
Output takes the following form: 
/*---------------------------------
* s.tring in argv[O] 
* string in argv[l] 
* * string in argv[N] 
*I 
The source code is also in Listing A.32. 
void prnt(int (*ofunct) (),void *ofunct_arg, char *format, 
va_list args) 
prnt () is a variant on the UNIX doprnt () and ANSI vfprintf () functions 
that lets you write printf ( ) -like output routines in a portable way. It is passed 
a pointer to a single-character output function (ofunct), a parameter that is 
relayed to this output function (ofunct _arg), a pointer to a format string, and a 
pointer to the location on the run-time stack where the other arguments are found. 
This last parameter is usually derived using the va _start () macro in 
<stdlib.h>, described earlier. 
To see how prnt () is used, fpr int f ( ) can be implemented as follows: 
Section A.6-Print Functions 
#include <stdio.h> 
#include <stdarg.h> 
fprintf( stream, format, ... ) ; 
FILE *stream; 
char *format; 
{ 
extern int fputc(); 
args; 735 
va list 
va start 
prnt (args, format); /* Get address of arguments. */ 
va end (fputc, stream, format, args ); 
(args); 
sprintf () can be implemented as follows: 
putstr(c, p) 
int c; 
char **p; 
{ 
*(*p)++ = c; 
sprintf(str, format, ... ) 
char *str, *format; 
{ 
args; va list 
va start 
prnt (args, format 
(putstr, &str, 
I \0' ; *str = 
va end (args); ) ; 
format, args ) ; 
The prnt () subroutine is required by the curses implementation discussed 
below, which must be able to change the output subroutine at will. Neither the 
ANSI nor the UNIX function gives you this capability. The source code for 
prnt () is described in depth below. 
void stop_prnt(void) 
This routine must be called by all programs that use prnt ( ) just before termina-
tion [after the last prnt ( ) call]. 
The prnt ( ) , subroutine is in Listing A.33. Two versions are presented, one for the 
ANSI environment and another for UNIX. The first version (on lines 19 to 31) produces an Clean up after prnt(). 
ANSI-compatible function. It uses vsprintf () to do the conversion into a buffer, and ANSI version ofprnt 0. 
then prints the buffer. Though this version is desirable in that it supports all the 
printf ( ) conversions, it has a drawback. The buffer requires a modicum of stack 
space, and the Microsoft implementation of vsprintf () also uses a lot of run-time 
stack. The second, UNIX compatible version of prnt () is on lines 37 to 65 of Listing UNIX version of prnt ( >. 
A.33. There are two problems here: First, the UNIX variable-argument mechanism is 
different from the ANSI one, so slightly different procedures must be used to get argu-
ments off the stack. Second, there is no UNIX equivalent to vsprintf ( ) . The only 
available printf driver is _doprnt (),which works like the ANSI vprintf () func-
tion except that the arguments are in different positions. In order to use an arbitrary out-
put function, you must format to a FILE, rewind the file, and then transfer characters one 
at a time to the desired output function. Ugh,6 you may well say. This approach is 
6. That's a technical term. 
736 Support Functions-Appendix A 
actually not as much of a kludge as it seems because the number of characters written 
and read is so small. More often than not, there's no disk activity at all because the reads 
and writes won't get past the 1/0 system's internal buffering. 
Listing A.33. prnt.c-General-Purpose print f () Driver 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 #include <stdio.h> 
#include <tools/debug.h> 
#include <tools/l.h> 
/*------------------------------------------------------------------
* Glue formatting workhorse functions to various environments. One of three 
* versions of the workhorse function is used, depending on various #defines: 
* 
* if ANSI is defined 
* if ANSI is not defined 
* vsprintf() Standard ANSI function 
doprnt() Standard UNIX function 
* The default with Microsoft C is MSDOS defined and ANSI not defined, 
*so idoprnt() will be used unless you change things with explicit macro 
* definitions. 
*I 
fifdef ANSI /*---------------------------------------------------------------*/ 
#include <stdarg.h> 
PUBLIC void prnt( ofunct, funct_arg, format, args ) 
int (*ofunct) (); 
void *funct_arg; 
char *format; 
va list args; 
{ 
buf [256], *p ; char 
int vsprintf( char* buf, char* fmt, va list args ); 
vsprintf(buf, format, args); 
for( p = buf; *p ; p++ ) 
(*ofunct) ( *p, funct_arg ) ; 
PUBLIC void stop_prnt() {} 
#else /* UNIX ---------------------------------------------------------------*/ 
#include <varargs.h> 
static FILE 
static char *Tmp_file 
*Tmp_name NULL 
PUBLIC void prnt( ofunct, funct_arg, fmt, argp ) 
int (*ofunct) (); 
void 
char 
int 
int 
char *funct_arg; 
*fmt; 
*argp; 
c; 
*mktemp(); 
if ( ! Tmp_file ) 
if( ! (Tmp_file = fopen ( Tmp_name = mktemp ("yyXXXXXX"), "w+") ) ) 
{ 
fprintf(stderr,"Can't open temporary file %s\n", Tmp_name ); 
exit ( 1 ) ; 
Section A.6-Print Functions 
Listing A.33. continued •.. 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 _doprnt( fmt, argp, Tmp_file ); 
putc ( 0, Tmp_file ); 
rewind ( Tmp_file ); 
while( (c getc(Tmp_file)) != EOF && c) 
(*ofunct) ( c, funct_arg ); 
rewind( Tmp_file ); 
PUBLIC void stop_prnt() 
{ 
fclose( Tmp_file ); 
unlink( Tmp name ); 
Tmp_file = NULL; /* Remove prnt temporary file *I 
/*----------------------------------------------------------------------*/ 
PUBLIC void vfprintf( stream, fmt, argp ) 
FILE *stream; 
char *fmt, *argp; 
{ 
_doprnt( fmt, argp, stream); 
PUBLIC void vprintf( fmt, argp ) 
char *fmt, *argp; 
{ 
_doprnt( fmt, argp, stdout ); 
PRIVATE void putstr(c, p) 
int c; 
char **p; 
{ 
*(*p)++ = c 
PUBLIC void vsprintf( str, fmt, argp ) 
char *str, *fmt, *argp; 
{ 
prnt( putstr, &str, fmt, argp ); 
*str = '\0'; 
#endif 
The temporary file is created automatically on lines 51 to 56 of Listing A.34 the first 
time prnt ( ) is called. You must call stop _prnt ( ) (on lines 67 to 72) to delete the 
file. You can do so after every prnt () call, but it's much more efficient to do it only 
once, just before the program terminates. You'll loose a FILE pointer in this case, but it 
saves a lot of time. 
The final part of Listing A.33 (lines 76 to 101) contains UNIX versions of the ANSI 
vprintf (), vfprintf (),and vsprintf () functions. 737 
738 
ssort () is like 
qsort (). 
Sorting argv with 
ssort (). 
Sorting an array of struc­
tures with ssort () . 
Sort array. Support Functions-Appendix A 
A.7 Sorting 
This sections describes two functions for sorting in-memory arrays: ssort () and 
assort (). Both are modeled after the UNIX qsort () function. I've provided alternate 
sorting functions because most qsort () implementations use a "quick sort", which 
does not behave particularly well with small arrays or arrays that might already be 
sorted. A Shell sort, which does not have these problems, is used here. Both sort func­
tions are general-purpose functions that can be used on arrays of any type of object-the 
same sorting function can sort arrays of ints, arrays of character pointers, arrays of 
structures, and so forth. Taking ssort ( ) as characteristic, argv is sorted as follows: 
cmp( p1, p2 ) 
char **p1, **p2; 
{ 
return strcmp( *pl, *p2 ); 
main( argc, argv 
int argc; 
char **argv; 
{ 
ssort( argv, argc, sizeof(*argv), cmp ); 
The sort function is passed the base address of the array to be sorted, the number of ele­
ments in the array, the size of one element, and a pointer to a comparison function. This 
comparison function is passed pointers to two array elements, and it should otherwise 
work like strcmp ( ) , returning a negative number if the key associated with the first 
argument is less than the key associated with the second, zero if the two keys are equal, 
and a positive number if the second key is larger. You can use ssort () to sort an array 
of structures as follows: 
typedef struct 
{ 
char *key; 
int other_stuff; 
record; 
sort cmp( p1, p2 
record *p1, *p2; 
( 
return( strcmp(p1->key, p2->key) ); 
plato() 
{ 
record field[ 10 ]; 
ssort( field, 10, sizeof(record), sort_cmp ); 
Of course, it's usually better to sort arrays of pointers to structures rather than arrays of 
structures-there's a lot less to move when two array elements are swapped. The calling 
conventions for the two sort routines are as follows: 
void ssort(void *base, int nel, int elesize, int (*cmp) ()) 
Sort an array at base address base, having nel elements, each of elesize 
bytes. The comparison function, cmp, is passed pointers to two array elements 
and should return as follows: 
Section A.7-Sorting 
cmp( pl, p2 ) ; 
*pl < *p2 return a negative number 
*pl = *p2 return zero 
*pl > *p2 return a positive number 
The ssort ( ) function is identical in calling syntax to the standard qsort ( ) 
function. A Shell sort is used by ssort ( ) , however, rather than a quicksort. 
The Shell sort is more appropriate for use on arrays with a small number of ele­
ments and arrays that might already be sorted. Also, since Shell sort is nonrecur­
sive, it is a safer function to use than quicksort, which can cause stack overflows 
at run time. 739 
void assort(void **base, int nel, int elesize, int (*cmp) ()) 
This routine is a version of ssort () optimized to sort arrays of pointers. It takes 
the same arguments as ssort ( ) so that the routines can be used interchangeably 
on arrays of pointers. The base argument to assort ( ) must reference an array 
of pointers, however, and the elesize argument is ignored. Sort array of pointers. 
A.7.1 Shell Sort-Theory 
The sorting method used by ssort ( ) is a Shell sort, named after its inventor, 
Donald Shell. It is essentially an improved bubble sort, so I'll digress for a moment and 
describe bubble sort. A bubble-sort that arranges an array of ints into ascending order Bubble sort. 
looks like this: 
int array[ ASIZE ]; 
int i, j, temp ; 
for( i = 1; i < ASIZE; ++i ) 
for( j = i-1; j >= 0; --j 
if( array[j] > array[j+1] 
swap( array+i, array+j ); /*swap array[i] and array[j] *I 
The outer loop controls the effective array size. It starts out sorting a two-element array, 
then it sorts a three-element array, and so forth. The inner loop moves the new element 
(the one added when the effective array size was increased) to its correct place in the 
previously-sorted array. Consider a worst case sort (where the array is already sorted, 
but in reverse order): 
5 4 3 2 I 
In the first pass, the outer loop starts out with a two-element array: 
5 4 3 2 I 
And the inner loop swaps these two elements because they're out of place: 
4 5 3 2 I 
The next pass increases the effective array size to three elements: 
4 5 3 2 I 
And the 3 is moved into its proper place like this: 
4 5 3 
4 3 5 
3 4 5 2 I 
2 I 
2 I 
740 
Shell sort. The rest of the sort looks like this: 
3 4 5 2 
3 4 2 5 3 2 4 5 
2 3 4 5 
2 3 4 5 
1 
2 3 4 1 5 
2 3 1 4 5 
2 1 3 4 5 
1 2 3 4 5 1 
I 
1 Support Functions-Appendix A 
As you can see, this worst-case sort is very inefficient. In anN-element array, roughly N2 
swaps (and as many comparisons) are required to get the array sorted. Even the average 
case requires N2 comparisons, even though it will use fewer swaps. This behavior is 
quite measurable in most computer programs, and slows down the program unneces­
sarily. 
The Shell sort improves the bubble sort by trying to move the most out-of-place ele­
ments into the proper place as quickly as possible, instead of letting the out-of-place ele­
ment percolate through the array one place at a time. Other sort strategies (such as the 
quicksort used for most qsort ( ) implementations) are theoretically more efficient, but 
the overhead required by these other methods is often great enough that the theoretically 
less-efficient Shell sort is faster (at least with small arrays-less than a hundred elements 
or so). 
The basic strategy of Shell sort .is to partition the array into several smaller subarrays 
whose elements are spread out over the original array. The subarrays are sorted using a 
bubble sort, and then the array is repartitioned into a smaller number of subarrays, each 
having more elements. The process is continued until there's only one subarray compris­
ing the entire array. For example, ifthe initial array looks like this: 
6 5 4 3 2 
You can partition it into three, two-element arrays like this: 
6 5 4 3 2 I ~ 
The first array is [6,3], the second is [5,2] and the third holds [4,I]. The distance 
between any two elements in the subarray is called the gap size. Here, the gap size is 3. 
The three subarrays are now sorted. The 6 and 3 will be swapped, as will the 5 and 2, 
and the 4 and 1, yielding the following: 
3 2 6 5 4 ~ 
The array is repartitioned, this time with a gap size of two: 
3 2 6 5 4 ~ 
Section A.7.1-Shell Sort-Theory 
There are now two, three-element arrays having the members [3, 1, 5] and [2, 6, 4]. 
These are sorted, swapping the 1 and 3, and the 4 and 6, yielding. 
1 2 3 4 5 6 ~ 
The gap size is now reduced to 1, yielding: 
1 2 3 4 5 6 ~ 
but, since this array is already sorted, nothing more needs to be done. Note that only 5 
swaps were used here rather than the 15 swaps that would be required by the bubble sort. 
In the average case, roughly NL2 swaps are required to sort an array of size N.7 
A.7.2 Shell Sort-Implementation 
The ssort ( ) function in Listing A.34 is a general-purpose Shell-sort function. The 
initial gap size is selected on line 16 from a number in the series: 1, 4, 13, 40, 
121, ... (3N+1). The largest number in this series that is less than or equal to the array 
size is used. (This is the series recommended by Knuth in The Art of Computer Pro­
gramming as an optimal choice. Note that an even power of two, as is used in many 
Shell-sort implementations is among the worst choice of gap sizes.) The for statement 
on line 19 controls the size of the subarrays. The gap is divided by three on each pass, 
yielding the previous element in the foregoing series ( 4 0 I 3=13, 13 I 3=4, 4 I 3=1-I'm 
using integer division). The two loops on lines 20 to 33 are doing a bubble-sort pass on 
the partitioned subarray. 
Since the compiler doesn't know the size of an array element at compile time, it can't 
do the pointer arithmetic; we have to do the pointer arithmetic ourselves by declaring the 
array to be a character array on line eight and then explicitly multiplying by the size of 
an array element every time a pointer is advanced (on lines 23 and 24). The array ele­
ments also have to be swapped one byte at a time. The swap time could be improved by 
passing a pointer to a swap function as well as a comparison function to ssort, but I 
wanted to maintain compatibility with the standard qsort ( ) , and so didn't change any 
of the parameters. 
One change that I did make is shown in Listing A.35. asort ( ) is a version of 
ssort ( ) that sorts only arrays of pointer-sized objects-the vast majority of cases. 
The routine takes the same arguments as ssort ( ) , but it ignores elsize. 
A.8 Miscellaneous Functions 
This section discusses six routines that don't fit nicely into any of the other 
categories: 
int copyfile(char *dst, char *src, char *mode) 
int movefile(char *dst, char *src, char *mode) 
copy file () copies the contents of the file named in src to the file named in 
7. See [Knuth], vol. 3, pp. 84f. 741 
Choosing the gap size. 
Doing explicit pointer 
arithmetic. 
Implementing assort () . 
Copy entire file. 
Move entire file. 
742 Support Functions-Appendix A 
Listing A.34. ssort.c- General-Purpose Shell Sort 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 /* SSORT.C Works just like qsort() except that a shell sort, rather 
than a quick sort, is used. This is more efficient than 
for small numbers of elements, and it's not recursive (so will use 
stack space). * * quicksort 
* much less 
*I 
void ssort( base, nel, elsize, cmp) 
char *base; 
int nel, elsize; 
int ( * cmp) ( ) ; 
int i, j; 
int gap, k, tmp 
char *pl, *p2; 
for( gap=l; gap <= nel; gap 3*gap + 1 ) 
for( gap /= 3; gap > 0 ; gap /= 3 ) 
for( i = gap; i < nel; i++ ) 
for( j i-gap; j >= 0 j -gap ) 
( 
pl 
p2 base + j 
base + ( ( j+gap) * elsize); 
* elsize); 
if( (*cmp) ( pl, p2 ) <= 0 ) 
break; /* Compare two elements *I 
for( k = elsize; --k >= 0 ;) 
( 
tmp *pl; 
*pl++ *p2; 
*p2++ tmp; /* Swap two elements, 
/* byte at a time. one */ 
*I 
dst. If the mode argument is "w", the destination is overwritten when it already 
exists; otherwise, the contents of the source file are appended to the end of the 
destination. The return values are as follows: 
0 Copy was successful. 
-I Destination file couldn't be opened. 
-2 Source file couldn't be opened. 
-3 Read error while copying. 
-4 Write error while copying. 
move file () works like copy file (), except that the source file is deleted if 
the copy is successful. move file () differs from the standard rename () func­
tion in that it allows a move across devices (from one disk to another), and it sup­
ports an append mode-rename () is faster if you're moving a file somewhere 
else on the same device, and rename ( ) can be used on directory names, how­
ever. The sources for copyfile () and movefile () are in Listings A.36 and 
A.37. 
Section A.8-Miscellaneous Functions 743 
Listing A.35. assort.c- ssort () Optimized for Arrays of Pointers 
I 
2 
3 
4 
5 
6 
7 
8 
9 /* ASSORT.C A version of ssort optimized for arrays of pointers. */ 
void 
void 
int 
int 
int 
int 
void assort( base, nel, elsize, cmp) 
**base; 
nel; 
elsize; 
(*cmp) (); 
i, j, gap; /* ignored */ 
*tmp, **pl, **p2; 10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 for( gap=1; gap <= nel; gap 3*gap + 1 ) 
for( gap /= 3; gap > 0 ; gap /= 3 ) 
for( i = gap; i < nel; i++ ) 
for( j i-gap; j >= 0 j -= gap ) 
{ 
p1 base + ( j 
p2 base + ((j+gap) 
if( (*cmp) ( p1, p2 ) 
break; 
tmp *p1; 
*p1 *p2; 
*p2 tmp; 
Listing A.36. copyfile.c- Copy Contents of File 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 #include 
#include 
#include 
#include 
#include 
#include 
#define 
#define #define #define #define <stdio.h> 
<stdlib.h> 
<errno.h> 
<sys/types.h> 
<sys/stat.h> 
<io.h> 
ERR NONE 0 
ERR DST OPEN -1 
ERR SRC OPEN -2 
ERR READ -3 
ERR WRITE -4 
15 copyfile( dst, src, mode ) 
16 char *dst, *src; ) ; 
) ; 
<= 
17 char *mode; /* "w" or "a" */ 
18 { 0 ) 
19 /* Copy the src to the destination file, opening the destination in the 
20 * indicated mode. Note that the buffer size used on the first call is 
21 * used on subsequent calls as well. Return values are defined, above. 
22 * errno will hold the appropriate error code if the return value is <0. 
23 *I 
24 
744 Support Functions-Appendix A 
Listing A.36. continued .•. 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 int fd_dst, fd_src; 
char *buf; 
int got; 
int werror; 
int ret val ERR NONE 
static unsigned size 31 * 1024 
while( size> 0 && ! (buf = malloc(size)) 
size -= 1024; 
if( !size ) /* couldn't get a buffer, do it one byte at a time */ 
{ 
size 
buf 1; 
"xx"; /* allocate a buffer implicitly */ 
fd src 
fd dst open(src, 0 RDONLY 
open(dst, 0 WRONLY O_BINARY ) ; 
O_BINARY I O_CREAT I 
(*mode=='w' ? O_TRUNC 
S_IREADIS_IWRITE); 
if ( fd src 
else if( fd dst 
else 
{ -1 ) { ret val 
-1 ) { ret val ERR_SRC_OPEN; 
ERR_DST_OPEN; 
while( (got= read(fd src, buf, size)) > 0) 
if( (werror write(fd_dst, buf, got)) == -1 
{ 
if( got ret val 
break; 
---1 ERR_WRITE; 
ret val ERR READ; -
if( fd dst != -1 close fd dst 
if( fd src != -1 close fd src 
if( size > 1 free buf 
return ret _val; ) ; 
) ; 
) ; O_APPEND) I 
Listing A.37. movefile.c- Move File to Different Device 
1 
2 
3 
4 
5 
6 
7 
8 
9 movefile( dst, src, mode ) 
char *dst, *src; 
char *mode; 
int rval; /* Works like copyfile() (see copyfile.c) */ 
/* but deletes src if the copy is successful */ 
if( (rval = copyfile(dst, src, mode)) 0 ) 
unlink( src ); 
return rval; 
Section AS-Miscellaneous Functions 
int *memiset(int *dst, int with_what, int count) 
This function is a version of the standard memset ( ) function but it works on 
integer-sized objects rather than bytes. It fills count ints, based at dst, with 
the pattern in with_ what and returns dst. The source code is in Listing A.38. 
Listing A.38. memiset.c- Initialize Array of int to Arbitrary Value 745 
Fill memory with integer 
values. 
I 
2 
3 
4 
5 
6 
7 
8 
9 /* Works like memset but fills integer arrays with an integer value 
/*The count is the number of ints (not the number of bytes). *I 
*I 
10 
II int *memiset( dst, with_what, count 
int *dst, with_what, count; 
int *targ; 
for( targ = dst; --count >= 0 *targ++ 
return dst; with what 
int concat(int size, char *dst, ... ) 
The concat () function concatenates an arbitrary number of strings into a 
single destination array (dst) of the indicated size. At most size-1 characters 
are copied. All arguments following the dst argument are the source strings to 
be concatenated, and the list should end with a NULL. For example, the following 
code loads the english array with the string angles, saxons, jutes: 
#include <stdio.h> /* For NULL definition *I 
char target[ SIZE ]; Concatenate strings. 
concat ( SIZE, target, "angles, ", "saxons, ", " jutes", NULL ) ; 
The second and third arguments can be the same, but the target-string pointer 
cannot appear in any of the other arguments. The following concatenates 
new_ string to the end of target. This usage is easier to use than the stan­
dard strncat () function in many situations because it doesn't require you to 
keep a tally of the unused space in the target array. 
concat( SIZE, target, target, new_string ) ; 
The source code is in Listing A.39. The amount of available space is returned, or 
-1 if the string was truncated. 
void searchenv(char *filename, char *env_name, char *pathname) 
This function searches for a specific file (filename), first in the current direc­
tory, and then along a path specified in the environment variable whose name is 
in env _name. The variable should hold a semicolon or space-delimited list of 
directory names. If the file is found, the full path name (including the file-name 
component) is put into pathname; otherwise, pathname will contain an empty, 
null-terminated string. The source code is in Listing A.40. 
FILE *driver_1(FILE *output, int lines, char *fname) 
int driver_2(FILE *output, lines) 
These routines work together to transfer a template file to a U:X or occs output 
file. driver _1 ( ) must be called first. It searches for the file named in fname Search for file along 
directory path listed in an 
environment string. 
Copy driver-template file. 
746 Support Functions-Appendix A 
Listing A.39. concat.c- Concatenate Strings 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 #include <stdio.h> 
#include <stdarg.h> 
#include <debug.h> /* VA LIST definition */ 
int concat( size, dst, VA LIST 
int size; 
char *dst; 
{ 
/* This subroutine concatenates an 
* destination array (dst) of size 
* copied. Use it like this: arbitrary number of strings into a single 
"size." At most size-1 characters are 
* char target[SIZE]; 
* concat( SIZE, target, 
*I 
char *src; 
va list args; 
va_start( args, dst ); "first ", "second 
while( (src = va_arg(args,char *)) && size> 1) 
while( *src && size-- > 1 ) 
*dst++ = *src++ ; 
*dst++ = '\0'; 
va_end( args ); 
return (size <= 1 && src && *src) ? -1 size " , ... , "last", NULL); 
by looking first in the current directory and then in any directory on the path 
specified by the LIB environment. This environment can list several, semicolon­
delimited directory names. 
Ctri-L delimits parts of 
driver-template file. The file should contain one or more Ctrl-L-delimited parts. The first part is 
copied by driver_l() to the stream indicated by output. If lines is true, then a 
#line directive that references the template file's current line number is output 
just before the block is output. NULL is returned if the template file can't be 
opened, otherwise the FILE pointer for the template file is returned. You can use 
this pointer to close the file after it has been copied. 
Use @ to mark com­
ments in driver-template 
file. All other Ctrl-L-delimited parts of the template file are printed by successive 
calls to driver_ 2 ( ) . One part is printed every time it's called. 1 is returned 
normally, 0 at end of file (if there are no more parts to print). 
Lines that begin with an @ sign are ignored by both subroutines. It's a fatal 
error to call driver_ 2 ( ) without a previously successful driver _1 ( ) call. 
The source code for both routines is in Listing A.41. 
A.9 Low-Level Video 1/0 Functions for the IBM PC 
This section presents a set of very low-level terminal 1/0 functions for the IBM PC. 
They are used by the curses implementation presented in the next section. The routines 
in this section are the only ones in the curses package that are system dependent. As a 
consequence, I've not bothered to make them portable, because they'll always have to be 
rewritten if you port the code to another compiler. 
Section A.9-Low-Level Video 1/0 Functions for the IBM PC 
Listing A.40. searchen.c- Search for File Along Path Specified in Environment 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 #include <stdio.h> 
#define PBUF SIZE 129 I* Maximum length of a path name -1 *I 
void 
char 
char 
char 
{ searchenv( 
*filename; 
*envname; 
*pathname; filename, envname, pathname 
I* file name to search for 
I* environment name to use as PATH 
I* Place to put full path name when found *I 
*I *I 
I* Search for file by looking in the directories listed in the envname 
* environment. Put the full path name (if you find it) into pathname. 
* Otherwise set *pathname to 0. Unlike the DOS PATH command (and the 
*microsoft searchenv), you can use either a space or semicolon 
* to separate directory names. The pathname array must be at least 
* 128 characters. 
*I 
char pbuf[PBUF_SIZE]; 
char *p ; 
char *strpbrk(), *strtok(), *getenv(); 
strcpy( pathname, filename ) ; 
if( access( pathname, 0 ) != -1 
return; I* check current directory *I 
I* ... it's there. *I 
I* The file doesn't exist in the current directory. If a specific path was 
* requested (ie. file contains I or /) or if the environment isn't set, 
* return a NULL, else search for the file on the path. 
*I 
if( strpbrk(filename,"\\1") 
{ 
*pathname = '\0'; 
return; II ! (p 
strncpy( pbuf, p, PBUF_SIZE ); 
if( p = strtok( pbuf, "; " ) ) 
{ 
do 
{ getenv(envname)) ) 
sprint£( pathname, "%0.90s\\%0.20s", p, filename); 
if( access( pathname, 0 ) >= 0 ) 
return; I* found it *I 
while( p = strtok( NULL, "; ") ); 
*pathname = '\0' ; 
Two sets of complementary routines are presented here: a set of direct-video func­
tions that write directly into the IBM's display memory (they are MGA and CGA com­
patible), and a set of similar routines that use the video functions built into the IBM-PC 
ROM-BIOS to do the l/0. The direct-video routines are faster, the BIOS routines are, at 
least in theory, more portable. (The direct-video functions work better than the BIOS 
ones in clones that have nonstandard BIOS implementations.) 747 
748 Support Functions-Appendix A 
Listing A.41. driver.c- Copy Driver Template to Output File 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 47 
48 
49 
50 
51 
52 53 
54 
55 
56 
57 #include <stdio.h> 
#include <ctype.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/compiler.h> /* for prototypes *I 
l*------------------------------------------------------------*1 
PUBLIC FILE *driver 1 p ( ( FILE *output, int line, char *file name 
PUBLIC int driver 2 p ( ( FILE *output, int line 
PRIVATE FILE *Input_ file = NULL ) ) ; 
) ) ; 
PRIVATE int Input_ line; /* line number of most-recently read line 
PRIVATE char File_name [80]; /* template-file name 
/*--------------------------------------------------=---------*1 
PUBLIC FILE *driver_1( output, lines, file name 
FILE *output; 
char *file_name; 
{ 
char path[80]; 
if( !(Input_file = fopen( file_name, "r" )) ) 
{ 
searchenv( file_name, "LIB", path); 
if( !*path I I ! (Input_file fopen( path, "r")) ) 
return NULL; 
strncpy( File_name, file_name, sizeof(File_name) ); 
Input_line = 0; 
driver_2( output, lines ); 
return Input_file; 
/*--------------------------------------------------------------*1 
PUBLIC int driver_2( output, lines ) 
FILE *output; 
{ 
static char buf[ 256 ]; 
char *p; 
int processing_comment 0; 
if( !Input_file ) 
ferr( "INTERNAL ERROR [driver_2], Template file not open.\n"); 
if( lines 
fprintf( output, "\n#line %d \"%s\"\n", Input_line + 1, File name); 
while( fgets(buf, sizeof(buf), Input_file) 
{ 
++Input line; 
if( *buf == '\f' 
break; *I 
*I 
.... 
Section A.9-Low-Level Video 1/0 Functions for the IBM PC 
Listing A.41. continued .•• 
for( p = buf; isspace(*p); ++p) 
if( *p == '@' 
{ 
processing_comment 1; 
continue; 749 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 else if( processing_comrnent 
{ /* Previous line was a comment, *I 
/* but current line is not. */ 
processing_comrnent = 0; 
if( lines ) 
fprintf( output, "\n#line %d \"%s\"\n", Input_line, File name ) ; 
fputs( buf, output ); 
return( feof(Input_file) ); 
A.9.1 IBM VIdeo I/O-Overview 
You need to know a little about low-level l/0 to understand the function descriptions 
that follow. The IBM PC uses several different hardware adapters for video output. The 
most common are the Color Graphics Adapter (CGA) and Monochrome Graphics 
Adapter (MGA). Most other interface cards can emulate one or the other of these. Both 
the MGA and CGA use a block of memory to represent the screen-a two-dimensional 
array in high memory holds the characters that are currently being displayed. The posi­
tion of the character in the array determines the position of the character on the screen. 
Several such arrays, called video display pages, are available, but only one page can be 
displayed at a time. Both systems use a 25x80 array, but the MGA bases the default 
video page at absolute memory location OxbOOOO (BOOO:OOOO), and the CGA puts it at 
Oxb8000. The other pages are at proportionally higher addresses. 
Both cards use a 16-bit word to represent each character. The low byte is an 
extended ASCII code for the character. (All 255 codes are used, the extra ones are for 
funny characters like smiley faces and hearts.) The high byte is used for attributes. This 
attribute byte is pictured in Figure A.2. The high bit of the attribute byte controls char­
acter blinking (it's blinking if the bit is set). The next three bits determiQ~ the back­
ground color. The next bit controls the intensity of the foreground color-of the charac­
ter itself. If it's set, the character is displayed in high intensity. The bottom three bits 
determine the foreground color (the color of the character itself). The only difference 
between the color and monochrome adapters is the way that the colors are interpreted. 
The monochrome adapter recognizes only black and white; the code for blue, when used 
as a foreground color, causes the MGA to print the character underlined. 
Note that the foregoing applies only to the CGA and MGA, other adapters do things 
slightly differently, and the situation is actually more complex for the CGA. If you have 
a CGA and want more details, video interfacing is covered in depth in ~hapter 4 of Peter 
Norton's book: The Peter Norton Programmer's Guide to the IBM PC (Be~levue, Wash.: 
Microsoft Press, 1985). 
The following functions use direct-video access to address the screen: 
int dv_init(void) 
Initialize the direct-video functions. At present this routine just checks to see if a 
color card is installed and changes the internal base address of the video memory. Memory-mapped 
screens, MGA, CGA. 
Video display pages. 
Characters and attri­
butes. 
Blinking, intensity, color. 
Direct-video functions. 
Initialize direct-video 
functions. 
750 
Clear region of screen. 
Clear screen. Figure A.2. Attribute Bits 
1 =blinking O=steady 
background color 
0 0 0 
0 0 
0 0 
0 1 1 
0 0 
0 1 
0 intensity (1=high, O=low) 
foreground color 
MGA 
=black =black Support Functions-Appendix A 
(dark grey at high intensity) 
=blue = underlined 
=green n/a 
=cyan n/a 
=red n/a 
=magenta n/a 
=brown n/a 
=white =white (light grey at low intensity) 
(The monochrome and color cards map video memory to different base 
addresses.) It returns zero if an 80-column text mode is not available (the direct­
video functions will not work in this case), or 1 if everything's okay. 
void dv_clr_region(int left, int right, int top, 
int bottom, int attrib) 
Clear the region of screen defined by a box with the upper-left corner at 
(left, top) and the lower-right corner at (right, bottom). The region is 
cleared by filling the area with space characters having the indicated attribute. 
Symbolic defines for the attributes are in <tools/termlib.h>, discussed 
below. The cursor position is not modified. 
void dv_clrs(attrib) 
Clear the entire screen by filling it with space characters having the indicated 
attribute. The cursor position is not modified. 
Direct-video printf(). void dv_printf(int attrib, char *fmt, ... ) 
A printf () that uses direct-video writes. Output characters all have the indi­
cated attribute. The prn:t ( ) function described earlier does the actual printing. 
Display character and at-void dv _put c ( int c, int at t rib) 
tribute. 
Write a single character to the screen at the current cursor position, and with the 
indicated attribute. The following characters are special: 
\0 ignored 
\ f clear screen and home cursor 
\n send cursor to left edge of next line 
\ r send cursor to left edge of current line 
\b back up cursor one character (non-destructive backspace) 
The screen scrolls up if you go past the bottom line. Characters that go beyond 
the end of the current line wrap around to the next line. 
Section A.9.1-IBM Video I/O-Overview 
void dv_ctoyx(int y, int x) 
Position the cursor at the indicated row (y) and column (x). The top-left comer of 
the screen is (0,0), the bottom-right comer is (24,79). 
void dv_getyx(int *rowp, int *colp) 
Modify * rowp and* colp to hold the current cursor position. The top-left comer 
of the screen is (0,0), the bottom-right comer is (24,79). 
dv _inch a (void) 
Return the character and attribute at current cursor position. The character is in 
the low byte of the returned value and the attribute is in the high byte. 
void dv_outcha(int c) 
Write character and attribute to screen without moving the cursor. The character 
is in the low byte of c and the attribute is in the high byte. Note that the special 
characters supported by dv _putc ( ) are not supported here. They will print as 
funny-looking IBM graphics characters. 
void dv_replace(int c) 
Like dv _out cha ( ) , this function writes the character to the screen without 
moving the cursor, but the attribute is not modified by dv _replace ( ) . 
void dv_putchar(int c) 
Write a character to the screen with normal attributes (black background, white 
foreground, not blinking, normal-intensity, not underlined). This function uses 
dv _putc ( ) for its output, so it supports the same special characters, scrolling, 
line wrap, and so forth. 
dv_puts(char *str, int move) 
Write a string to screen. If move is true, the cursor is positioned at the end of the 
string, otherwise the cursor is not moved. Normal attributes, as described in ear­
lier dv _put char ( ) , are used. This function uses dv _putc ( ) for its output. 
void dv_putsa(char *str, int attrib) 
Write string to screen, giving characters the indicated attributes. The cursor is 
positioned just after the rightmost character. This function uses dv _putc ( ) for 
its output. 
#include <tools/termlib.h> 
SBUF *dv save (int left,int right,int top,int bottom) 
SBUF *dv restore (SBUF *sbuf) 
SBUF *dv_freesbuf(SBUF *sbuf) 
These three functions work together to save and restore the characters in a 
specified region of the screen. dv _save saves all characters in the box with 
comers at (top, left) and (bottom, right). It returns a pointer that can be 
passed to a subsequent dv _restore ( ) call to restore that region to its original 
condition. dv _save terminates the program with an error message if it can't get 
memory. The cursor is not modified by either function. The SBUF structure, used 
for this purpose, is defined in <tools!termlib.h> Note that the memory used for 
this structure is not freed, you must do that yourself with a 
df_freesbuf (sbuf) call after the dv_restore () call. For convenience, 751 
Change cursor position. 
Get cursor position. 
Input character from 
screen. 
Display character and at­
tribute without moving 
cursor. 
Display character without 
moving cursor. 
Display normal character. 
Display string. 
Display string with attri­
butes. 
Save and restore region 
of screen. Discard save 
buffer. 
752 
Scroll region arbitrary 
direction. Support Functions-Appendix A 
dv _restore ( ) returns its own argument, so you can say: 
dv_freesbuf( dv_restore( sbuf) ); 
if you like. 
void dv scroll_line(int left, int right, int top, int bottom, 
int dir, int attrib) 
Scroll the indicated region of the screen by one line or column. The dir argu­
ment must be one of the characters: ' u' , ' d' , ' 1' , or ' r' for up, down, left, or 
right. The cursor is not moved. The opened line or column is filled with space 
characters having the indicated attribute. 
Scrollregionupordown. void dv_scroll(int left, int right, int top, int bottom, int amt, 
int attrib) 
Video-BIOS functions 
that mimic direct-video 
functions. Scroll the indicated region of the screen up or down by the indicated number of 
lines (amt), filling the new lines with space characters having the indicated attri­
bute. Negative amounts scroll down, positive amounts scroll up. 
There are two sets of 1/0 routines that use the video-BIOS rather than direct-video 
reads and writes. The routines in Table A.2 behave exactly like the dv _ routines that 
were discussed earlier. For example, vb _get yx ( ) works exactly like dv _get yx ( ) , 
but it uses the video BIOS. Names that are in all caps are implemented as macros. 
Table A.2. Video-BIOS Macros and Functions That Work Like Direct-Video Functions 
Function or macro. t Has side 
effects? 
void VB CLRS (attrib) no -void VB CLR REGION (left, --right, top, bottom, attrib) yes 
void VB CTOYX ( -y, X ) no 
void vb freesbuf ( sbuf ) --void vb_getyx ( yp, xp ) -
int VB INCHA ( ) no -void VB OUTCHA ( c ) yes -void VB PUTCHAR ( c ) no -void vb_putc ( c, attrib ) -
void vb_puts ( str, move cur ) --void VB REPLACE ( -c ) yes 
SBUF *vb restore ( sbuf ) --SBUF *vb save ( left, right, top, bottom ) -
void VB SCROLL ( left, right, top, bottom, amt, attrib) yes 
t Names in all caps are macros. 
Other video-BIOS func­
tions. The second set of BIOS routines gives you access to features that are not easy to 
implement directly. Of these, the cursor-movement functions are used by the direct­
video routines to move the physical cursor. As with the earlier group, names in all caps 
represent macros, but none of these macros have side effects. 
Create block cursor. void VB_BLOCKCUR(void) 
Make the cursor a block cursor rather than the normal underline. 
Create underline cursor. void VB_ NORMALCUR (void) 
Make the cursor a normal, underline, cursor. 
Section A.9.1-IBM Video I/O-Overview 
void VB_CURSIZE(int top, int bottom) 
Change the cursor size by making it extend from the indicated top scan line to 
the bottom one. The line numbers refer to the box in which the character is 
drawn. A character on the CGA is 8 scan lines (dots) high, and the line numbers 
go from 0 to 7. They go from 0 to 12 on the MGA. A normal, underline cursor 
can be created with VB_ CURS I ZE ( 6, 7) on the CGA, and 
VB_CURSIZE (11, 12) on the MGA. VB_CURSIZE (0, 7) creates a block cur­
sor on the CGA, filling the entire area occupied by a character. 
VB_ CURS I ZE ( 0, 1) puts a line over the character rather than under it. 
VB_ CURS I ZE ( 13, 13) makes the cursor disappear entirely. If the top line is 
larger than the bottom, you'll get a two-part cursor, so VB_CURSIZE (11, 1) 
creates a cursor with lines both above and below the character on the MGA. 
int vb_getchar(void) 
Get a character directly from the keyboard. The typed character is returned in the 
low byte of the returned integer, the high byte holds the auxiliary byte that marks 
ALT keys and such. See the IBM Technical Reference for more information. You 
can use this function to read key codes that can't be accessed by some compilers' 
standard l/0 system. Similarly, vb_getchar ( ) gets characters from the key­
board, even if input is redirected, though it's more portable to open the console 
directly for this purpose. 
int VB_GETCUR(void) 
Return the current cursor position. The top byte of the return value holds the row, 
the bottom byte the column. 
int VB_GETPAGE(void) 
Return a unique number identifying the currently active video-display page. 
int vb_iscolor(void) 
Returns one of the following values: 
CGA is installed an it's in an 80-column text mode 
0 MGA is installed 
-1 CGA is installed and it's not in an 80-column text mode 
The return value is controlled by the current video mode as follows: 
Mode Return value 
2or3 1 
7 0 
anything else -l 
void VB_SETCUR(posn) 
Modify current cursor position. The top byte ofposn holds the row (y), the bot­
tom byte, the column (x). The top-left corner of the screen is (0,0). 
A.9.2 Video I/O-Implementation 
This section presents the code that implements the foregoing functions. Most of the 
actual code is pretty boring, and it's presented with no additional comment in the text. A 
high-level discussion of the data structures and techniques used is discussed however. 753 
Change cursor size. 
Get character from key­
board. 
Get cursor position. 
Get video page number. 
Determine display 
adapter. 
Move physical cursor. 
754 Support Functions-Appendix A 
The int86 () function. I'm assuming, in this section, that you're familiar to some extent with the IBM 
ROM-BIOS interface. If you need this information, read Peter Norton's book: The Peter 
Norton Programmer's Guide to the IBM PC (Bellevue, Wash.: Microsoft Press, 1985), 
which covers all this material. I'm also assuming that your compiler has a mechanism 
for generating a software interrupt-most do. I'm using the Microsoft int86 () 
because it's portable-newer versions of the compiler have more efficient BIOS-access 
functions in the library, and you may want to modify the code to use these functions. 
Attribute definitions, 
SBUF, WORD, IMALLOC, 
IFREE: <toolsltermlib.h> The <toolsltermlib.h> file is used both by application programs and by the I/0 func­
tions themselves. It's shown in Listing A.42. The macros on lines five to 12 are the 
codes for the basic colors described earlier. The FGND ( ) and BGND ( ) macros on lines 
14 and 15 put the color code into the foreground or background position within the attri­
bute byte. (FGND is just for documentation, it doesn't do anything. BGND shifts the color 
four bits to the left.) The NORMAL, UNDERLINED, and REVERSE definitions on lines 17 
to 19 of Listing A.42 define all legal color combinations for the monochrome card: a nor­
mal character, an underlined character, and a reverse-video character. Finally, BLINK­
ING and BOLD (on lines 21 and 22 of Listing A.42) can be ORed with the colors to make 
the character blink or be displayed at high intensity. 
Listing A.42. termlib.h- Video-I/O Definitions 
1 /* Various definitions for the termlib. Note that if your program includes both 
2 * termlib.h and vbios.h, termlib.h must be included FIRST. 
3 */ 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 #define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define BLACK 
BLUE 
GREEN 
CYAN 
RED 
MAGENTA 
BROWN 
WHITE 
FGND(color) 
BGND(color) 
NORMAL 
UNDERLINED 
REVERSE 
BLINKING 
BOLD OxOO I* Color Card. *I 
OxOl 
Ox02 
Ox03 
Ox04 
Ox05 
Ox06 
Ox07 
(color) 
((color) <<4) 
(FGND(WHITE) BGND (BLACK)) /* Monochrome card */ 
(FGND(BLUE) BGND (BLACK)) 
(FGND (BLACK) BGND (WHITE)) 
Ox80 /* May be ORed with the above *I 
Ox08 /* and with each other *I 
24 /*----------------------------------------------------------------------
25 * If USE_FAR_HEAP is true then use the far heap to save screen images in the 
26 * small model. You must recompile the termlib if you change this #define. 
27 */ 
28 
29 typedef unsigned int WORD; 
30 
31 
32 
33 
34 
35 
36 
37 
38 #if( 
#else USE_FAR_HEAP ) 
typedef WORD far 
#define IMALLOC 
#define !FREE 
typedef WORD 
#define IMALLOC 
#define !FREE *IMAGEP; 
fmalloc 
ffree 
*IMAGEP; 
malloc 
free .... 
Section A.9.2-Video I/O-Implementation 755 
Listing A.42. continued ... 
#endif 39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 typedef struct SBUF /* used by vb save, vb restore, dv save, and dv restore */ 
{ 
unsigned int top, bottom, left, right; 
IMAGEP image; 
} SBUF; 
/*----------------------------------------------------------------------
* 
*I 
extern 
extern 
extern 
extern extern 
extern 
extern 
extern Prototypes for the video-BIOS access routines. 
int vb iscolor 
void vb_getyx 
void vb_putc 
void vb_puts 
int vb_getchar 
SBUF *vb save 
SBUF *vb restore 
void vb freesbuf void 
int *yp,int *xp 
int c, int attrib 
char *str,int move_cur 
void 
int l,int r,int t,int b 
SBUF *sbuf 
SBUF *sbuf ) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
/*----------------------------------------------------------------------
* Prototypes for the equivalent direct video functions. 
*I 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern 
extern extern int dv init 
void dv scroll line 
void dv scroll 
void dv clrs 
void dv clr_region 
void dv_ctoyx 
void dv_getyx 
void dv_putc 
void dv_putchar 
int dv_puts 
void dv_putsa 
int dv incha 
void dv outcha 
extern void dv_replace 
extern void dv_printf 
extern SBUF *dv save 
extern SBUF *dv restore 
extern void dv freesbuf void 
int x left,int x_right,int y_top, 
int y_bottom, int dir,int 
int x_left,int x_right,int y_top, 
int y_bottom, int amt,int 
int attrib 
int l,int r,int t,int b,int attrib 
int y,int x 
int *rowp,int *colp 
int c,int attrib 
int c 
char *str,int move cur 
char *str,int attrib 
void 
int c 
int c 
int attribute,char *fmt, ... 
int l,int r,int t,int b 
SBUF *sbuf 
SBUF *sbuf ) ; 
\ 
attrib ); 
\ 
attrib ) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
) ; 
The WORD typedef on line 29 of Listing A.42 is an attempt to get a portable 
definition for a 16-bit unsigned quantity. It's used later to access a single 16-bit, 
character/attribute pair from the video page. Portable 16-bit data type, 
WORD. 
The definitions on lines 31 to 39 of Listing A.42 are compiler dependent. They con­
trol from where, in real memory, the buffers used for an SBUF will be allocated. In an 
average window application, where you need to save the area under a new window 
before creating it, a considerable amount of memory can be used to store these old 
images (25x80x!2=4,000 bytes for the whole screen), and that much memory may not be 
available in an 8086 small-model program. You don't want to convert the entire pro­
gram to the medium or compact model because this conversion will slow down all the Screen-save buffer, 
SBUF. 
756 
The 'far heap; 
USE_FAR_HEAP, 
_fmalloc (), 
_ffree (). 
The far keyword. 
Video-BIOS definitions, 
vbios.h. Support Functions-Appendix A 
pointer accesses. It's possible, however, for a small-model program to allocate and use a 
region of memory outside of the normal 64K data area (called the far heap). The Micro­
soft fmalloc ( ) function gets memory from the far heap, and returns a 32-bit far 
pointer. The _ f free ( ) function puts memory back into the far heap. The far heap is 
used for window images ifUSE_FAR_HEAP is defined above line 3I of Listing A.42 (or 
with a -DUSE_FAR_HEAP command-line switch). The far keyword on line 32 tells the 
Microsoft compiler to use a 32-bit pointer that holds both the segment and offset com­
ponents ofthe address when_ fmalloc ( ) is used to allocate memory. 
The next .h file of interest is vbios.h, which is used locally by the video-BIOS func­
tions. It's in Listing A.43. Two interrupts are of interest here: the video interrupt, 
whose number is defined on line five, and the keyboard interrupt defined on the next line. 
The definitions on lines seven to IS let you select a specific function-each interrupt can 
do several things, and the function-number determines which of these functions are per­
formed. All of the foregoing is described in great depth in Peter Norton's book if you 
need more background information. 
Listing A.43. vbios.h- Video-BIOS Service Definitions 
1 #ifndef NORMAL 
2 #include <toolsltermlib.h> 
3 #endif 
4 
5 #define VIDEO INT OxlO I* Video interrupt *I 
6 #define KB INT Oxl6 I* Keyboard interrupt *I 
7 #define CUR SIZE Oxl I* Set cursor size *I 
8 #define SET POSN Ox2 I* Modify cursor posn *I 
9 #define READ POSN Ox3 I* Read current cursor posn *I 
10 #define SCROLL UP Ox6 I* scroll region of screen up *I 
11 #define SCROLL DOWN Ox7 I* " down *I 
12 #define READ CHAR Ox8 I* Read character from screen *I 
13 #define WRITE Ox9 I* Write character *I 
14 #define WRITE TTY Oxe I* Write char & move cursor *I 
15 #define GET VMODE Oxf I* Get video mode & disp pg *I 
Accessing the video 
BIOS, _ Vbios <) • 
Most video-BIOS func­
tions implemented as 
macros. 
Direct-video definitions, 
video.h. Video-memory 
base addresses, MON­
BASE, COLBASE. 
Screen dimensions, NOM­
ROWS, NUMCOLS. 
Accessing characters 
and attributes, CHARAC­
TER. Representing entire 
screen, DISPLAY. The video BIOS is accessed by_ Vbios () in Listing A.44. The Microsoft int86() func­
tion, a prototype for which is in <dos.h>, communicates with the BIOS using the normal 
interrupt mechanism. It is passed an interrupt number and pointers to two REGS struc­
tures that represent the 8086 register set. The first of these holds the desired contents of 
the registers before the interrupt is executed, the second holds the values of the registers 
after the interrupt returns. Most of the video-BIOS functions are actually macros that 
evaluate to_ Vbios () calls. These are also defined in <toolslvbios.h> and are shown in 
Listing A.45. 
The third .h file, video.h in Listing A.46, is used locally by the direct-video functions. 
MONBASE and COLBASE (defined on lines one and two of Listing A.46) are the base 
addresses of page 0 of the monochrome and color adapters. The addresses are in the 
canonical segment/offset form used by most 8086 compilers, the high I6 bits are the seg­
ment and the low I6 bits are the offset. The dimensions of the screen (in characters) are 
controlled by NUMROWS and NUMCOLS on the lines three and four of Listing A.46. 
The CHARACTER structure defined on lines six to II of Listing A.46 describes a sin­
gle character/attribute pair. Using a structure to access the high byte is a better strategy 
than a shift because it's more efficient in most compilers. A DISPLAY, defined on the 
next line, is a 25x80 array of these character/attribute pairs. 
Section A.9.2-Video I/O-Implementation 
Listing A.44. vbios.c- Video-BIOS Interface Function 
#include <dos.h> 
#include <toolslvbios.h> 
#include "video.h" 757 
1 
2 
3 
4 
5 
6 
7 
8 
9 I* This file contains a workhorse function used by the other video I/0 *I 
I* functions to talk to the BIOS. It executes the video interrupt. *I 
_Vbios( service, 
service; al, bx, ex, dx, return_this ) 
I* Service code, put into ah. 
I* Other input registers. 10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 int 
int 
int 
char 
{ al, bx, ex, dx; 
*return_this; I* Register to return, "ax", "bh", *I 
*I 
"dx" only. *I 
union REGS 
regs.h.ah 
regs.h.al 
regs.x.bx regs; 
service; 
al; 
bx; 
regs.x.cx ex; 
regs.x.dx dx; 
int86( VIDEO_INT, &regs, &regs); 
return ( *return this 'a' ) ? regs.x.ax 
( *return this 'b' ) ? regs.h.bh regs.x.dx 
The dv _Screen pointer declared on line 16 of Listing A.46 points at the base 
address of the video memory for the current adapter (it's initialized for the monochrome 
card but it can be changed at run time). The SCREEN macro on line 21 of Listing A.46 
uses dv _Screen to randomly access a specific character or attribute on the screen. For 
example, the following puts a high-intensity X in the lower-right comer of the screen: 
#include <termlib.h> 
#include <video.h> 
SCREEN[ 25 ] [ 79 ] .character = 'X' ; 
SCREEN[ 25 ] [ 79 ] .attribute = NORMAL I BOLD ; 
The elaborate casts are needed because you can't cast a pointer into an array, but you can 
cast it to an array pointer. Since dv _Screen is a pointer to an entire two-dimensional 
array as compared to a pointer to the first element, the star in SCREEN gets you the array 
itself. Looked at another way, a pointer to an entire array is special in two ways. First, if 
you increment it, you'll skip past the entire array, not just one element. Second, the 
pointer is treated internally as if it were a pointer to a pointer. That is, the array pointer 
is treated internally as if it points at an array of pointers to rows, similar to argv. An 
extra star is needed to select the correct row. This star doesn't change the value of the 
pointer, only its type---d.v_Screen and *dv_Screen both evaluate to the same 
number, but the types are different. dv _Screen (without the star) is of type pointer to 
two-dimensional array, the first element of which is one-dimensional array of CHARAC­
TERs. *dv _Screen (with the star) is of type pointer to one-dimensional array (pointer 
to row), the first element of which is a single CHARACTER. All this is discussed in 
greater depth in Chapter 6. 
The definitions on lines 23 to 25 of Listing A.46 work just like the foregoing, except 
that the screen is treated as an array of 16-bit numbers rather than as an array of CHAR­
ACTERs. The dv _functions are in Listings A.47 to A.67. Accessing video memory 
directly, dv_Screen, 
SCREEN 
758 Support Functions-Appendix A 
Listing A.45. vbios.h- Macros That Implement Video-BIOS Functions 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 55 
56 
57 
58 
59 
60 
61 
62 
63 /* These video-BIOS functions are implemented as macros. 
* 
* VB INCHA 
* Returns the character and attribute ORed together. Character in 
the low byte and attribute in the high byte. 
Return the currently active display page number * VB GETPAGE 
* VB GETCUR 
* 
* 
* Get current cursor position. The top byte of the return value 
holds the row, the bottom by the column. Pagenum is the video 
page number. Note that VB_GETPAGE() will mess up the fields in 
the Regs structure so it must be called first. 
* VB CURSIZE 
* Change the cursor shape to go from the top to the bottom scan 
line. 
* VB OUTCHA 
* * VB REPLACE 
* VB SETCUR Write a character and attribute without moving the cursor. The 
attribute is in c's high byte, the character is the low byte. 
Same as VB_OUTCHA but uses the existing attribute byte. 
* 
* Modify current cursor position. The top byte of "posn" value 
holds the row (y), the bottom byte, the column (x). The top-left 
corner of the screen is (0,0). Pagenum is the video-display-page 
* number. 
* VB_CTOYX(y,x) Like VB SETCUR but y and x coordinates are used. 
* VB SCROLL Scroll the indicated region on the screen. If amt is <0, 
* scroll down; otherwise, scroll up. 
* VB CLRS Clear the entire screen 
* VB CLR REGION Clear a region of the screen 
* VB BLOCKCUR Change to a block cursor. 
* VB NORMALCUR Change to an underline cursor. 
* VB PUTCHAR like vb_putc, but uses white on black tor the attribute. 
*I 
VB_GETPAGE() 
VB_INCHA() _Vbios( GET_VMODE, 0, 0, 0, 0, 
_Vbios( READ_CHAR, 0, VB_GETPAGE(), 0, 0, 
_Vbios( READ_POSN, 0, VB_GETPAGE(), 0, 0, 
_Vbios ( CUR_SIZE, 0, 0, ( (t) <<8) I (b), 0, "bh") 
"ax") 
"dx") 
"ax") #define 
#define 
#define 
#define 
#define #define 
#define 
#define 
#define VB_ GET CUR () 
VB_CURSIZE(t,b) 
VB_OUTCHA(c) 
VB_REPLACE(c) 
VB_SETCUR(posn) 
VB_CTOYX(y,x) 
VB_SCROLL(x1, Vbios( WRITE, (c)&Oxff, ((c)>>8)&0xff, 1, 0, "ax") 
VB_OUTCHA ( (c & Oxff) I (VB_INCHA () & -oxff) ) 
_Vbios ( SET_POSN, 0, VB_GETPAGE () << 8, 0, (posn), "ax") 
VB_SETCUR ( ( (y) « 8) I ( (x) & Oxff) ) 
xr, yt, yb, amt, attr) _Vbios( \ 
((amt) < 0) ? SCROLL DOWN : SCROLL_UP, \ 
abs (amt), (attr) << 8, ( (yt) << 8) I (x1), \ 
( (yb) << 8) I (xr), "ax"\ 
#define VB_CLRS(at) VB_SCROLL( 0, 79, 0, 24, 25, (at)) 
#define VB_CLR_REGION (1, r, t,b, at) VB_SCROLL ( (1), (r), (t), (b), ((b)-(t)) +1, (at)) 
#define VB_BLOCKCUR() 
#define VB_NORMALCUR() 
#define VB_PUTCHAR(c) VB_CURSIZE( 0, vb_isco1or() ? 7 : 12 ) 
( vb_isco1or() ? VB_CURSIZE(6,7) VB_CURSIZE(11,12) 
vb_putc( (c), NORMAL) 
Section A.9.2-Video I/O-Implementation 
Listing A.46. video.h- Definitions for Direct-Video Functions 
1 #define MONBASE (DISPLAY far *) OxbOOOOOOO 
2 #define COLBASE (DISPLAY far *) Oxb8000000 
3 #define NUMROWS 25 
4 #define NUMCOLS 80 
5 
6 typedef struct 
7 { 
8 unsigned char letter; 
9 unsigned char attribute; 
10 
II CHARACTER; 
12 
13 typedef CHARACTER DISPLAY[ NUMROWS ] [ NUMCOLS l ; 
14 
15 #ifdef ALLOC 
16 DISPLAY far *dv Screen = (DISPLAY far *) MONBASE 
17 #else 
18 extern DISPLAY far *dv_Screen; 
19 #endif 
20 
21 #define SCREEN (* dv_Screen) 
22 
23 typedef short CHAR_ATTRIB; 
24 typedef CHAR ATTRIB VDISPLAY[ NUMROWS ] [ NUMCOLS 
25 #define VSCREEN (* (VDISPLAY far *)dv_Screen 
Listing A.47. dv clr r.c-Clear Region of Screen (Direct Video) 
#include "video.h" 
void 
{ dv_clr region( 1, r, 
int ysize, xsize, x, y t, b, attrib ) l ; 
) 
I 
2 
3 
4 
5 
6 
7 
8 
9 xsize 
ysize (r -
(b -1) + 
t) + 1; 
1; /* horizontal size of region */ 
/* vertical size of region */ 
10 
11 
12 
13 
14 
15 
16 for( y = 
for( 
{ ysize; --y >= 0 
X = xsize; --x 
SCREEN [ y + t ] [ 
SCREEN [ y + t ] [ ; ) 
>= 0 
x + 
1 ] .letter 
x + 1 ] .attribute 
Listing A.48. dv clrs.c-Clear Entire Screen (Direct Video) 
1 #include "video.h" 
2 
3 void dv_clrs( attrib 
4 ' ' ; 
attrib 
5 /* Clear the screen. The cursor is not moved. */ 
6 759 
.... 
760 Support Functions-Appendix A 
Listing A.48. continued .•• 
7 
8 
9 
10 
II 
I2 
I3 
I4 
I5 CHARACTER far 
register int *p 
i (CHARACTER far*) ( dv Screen); 
for( i 
{ NUMROWS * NUMCOLS; --i >= 0 
(p ) ->letter 
(p++)->attribute , ' ; 
attrib 
Listing A.49. dv Jrees.c- Free an SBUF (Direct Video) 
I #include <stdlib.h> 
2 #include <tools/termlib.h> 
3 #include "video.h" 
4 /*Free an SBUF as is allocated by vb_save(). */ 
5 void dv freesbuf( p ) 
6 SBUF *p; 
7 { 
8 IFREE ( p->image ) ; 
9 free ( p ) ; 
10 
Listing A.50. dv init.c-Initialize Direct-Video Functions 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include "video.h" 
int dv_init() 
int i; 
if( (i = vb_iscolor()) >= 0 
dv Screen = i ? COLBASE 
return( i != -1 ); MONBASE 
Listing A.51. dv yrint.c- A Direct-Video printf () 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
I2 
I3 #include <stdio.h> 
#include <stdarg.h> 
#include <tools/debug.h> 
#include "video.h" /* For VA LIST definition */ 
void 
int 
char dv_printf( attrib, fmt, VA LIST 
attrib; 
*fmt; 
/* Direct-video printf, characters will have the indicated attributes. */ 
/* prnt() is in curses.lib, which must be linked to your program if you*/ 
/* use the current function. */ 
... 
Section A.9.2-Video I/O-Implementation 
Listing A.Sl. continued ••• 
14 extern dv _putc (); 
15 va_list args; 
16 
17 va_start( args, fmt ); 
18 prnt ( dv_putc, attrib, fmt, args ); 
19 va end ( args ); 
20 
Listing A.52. dv _yutc.c- Write Character to Screen with Attribute (Direct Video) 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include "video.h" 
#include <toolslvbios.h> 
static int 
static int Row 
Col 0; 
0; I* Cursor Row *I 
I* Cursor Column *I 
1*----------------------------------------------------------------------*l I* Move cursor to (Row, Col) *I 
#define fix_cur () Vbios ( SET_POSN, 0, 0, 0, (Row << 8) I Col , "ax" ) 
1*----------------------------------------------------------------------*l 
void 
{ dv_putc( c, attrib ) 
I* Write a single character to the screen with the indicated attribute. 
* The following are special: 
* 
* 10 ignored 
* If clear screen and home cursor 
* In to left edge of next line 
* lr to left edge of current line 
* lb one character to left (non-destructive) 
* * The screen will scroll up if you go past the bottom line. Characters 761 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 * that go beyond the end of the current line wrap around to the next line. 
*I 
switch( c ) 
{ 
case 0: break; 
case '\f': dv clrs( attrib ); 
Row = Col 0; 
break; 
case '\n': if( ++Row>= NUMROWS ) 
{ I* Ignore ASCII NULL's *I 
dv_scroll_line(0,79,0,24, 'u', NORMAL); 
Row = NUMROWS-1 ; 
case '\r': Col= 0; 
break; I* Fall through to 'lr' *I 
762 Support Functions-Appendix A 
Listing A.52. continued ... 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 case '\b': if( --Col < 0 
Col 0; 
break; 
default SCREEN[ Row ] [ Col ] .letter 
SCREEN[ Row ] [ Col ] .attribute 
if( ++Col >= NUMCOLS ) 
{ 
Col 0; 
if( ++Row >= NUMROWS ) 
{ c 
attrib 
dv_scroll_line(0,79,0,24, 'u', NORMAL ) ; 
Row = NUMROWS-1 ; 
break; 
fix_cur (); 
1*----------------------------------------------------------------------*l 
void dv_ctoyx( y, x ) 
{ I* Position the cursor at the indicated row and column *I 
Row = y; 
Col = x; 
fix_cur (); 
1*----------------------------------------------------------------------*l 
void 
int dv_getyx( rowp, colp ) 
*rowp, *colp; 
{ I* Modify *rowp and *colp to hold the cursor position. *I 
*rowp Row; 
*colp Col; 
1*----------------------------------------------------------------------*l 
int dv_incha () I* Get character & attribute from screen. *I 
return (int) VSCREEN[ Row] [ Col ]; 
void dv_outcha(c) I* Write char. & attrib. w/o moving cursor. *I 
VSCREEN[ Row ] [ Col ] = c 
void dv_replace(c) 
{ I* Write char. only w/o moving cursor *I 
SCREEN[ Row ] [ Col ] .letter = c 
Section A.9.2-Video I/O-Implementation 
Listing A.53. dv _yutch.c- Write Character to Screen, Normal Attribute (Direct Video) 
I 
2 
3 
4 
5 
6 
7 #include "video.h" 
#include <tools/termlib.h> 
void dv_putchar( c ) 
dv_putc( c & Oxff, NORMAL); 
Listing A.54. dv _yuts.c- Write String to Screen, Normal Attribute (Direct Video) 
I #include "video.h" 
2 #include <tools/termlib.h> 
3 
4 dv_puts ( str, move ) 
5 char *str; 
6 { 
7 /* Write string to screen, moving cursor to end of string only if move is 
8 * true. Use normal attributes. 
9 */ 
10 
11 int orow, ocol; 
12 
13 dv_getyx( &orow, &ocol ); 
14 
15 while ( *str ) 
16 dv_putc( *str++, NORMAL); 
17 
18 if( !move ) 
19 dv_ctoyx( orow, ocol ); 
20 
Listing A.55. dv _yutsa.c- Write String to Screen, with Attribute (Direct Video) 
I #include "video.h" 
2 
3 void dv_putsa( str, attrib 
4 register char *str; 
5 register int attrib; 
6 { 
7 /* Write string to screen, giving characters the indicated attributes. *I 
8 
9 while( *str ) 
10 dv_putc( *str++, attrib ); 
11 763 
764 Support Functions-Appendix A 
Listing A.56. dv ~esto.c- Restore Saved Region (Direct Video) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 #include <stdio.h> 
#include <tools/termlib.h> 
#include "video.h" 
SBUF 
SBUF 
{ *dv_restore( sbuf ) 
*sbuf; 
/* Restore a region saved with a previous dv_save() call. The cursor is 
* not modified. Note that the memory used by sbuf is not freed, you must 
* do that yourself with a dv_freesbuf(sbuf) call. 
*I 
int ysize, xsize, x, y 
IMAGEP p; 
xsize ( sbuf->right sbuf->left 
ysize ( sbuf->bottom sbuf->top 
p sbuf->image; 
for( y = 0; y < ysize ; ++y ) 
for( x = 0; x < xsize ; ++x + 1 
+ 1 
VSCREEN[ y + sbuf->top ] [ x + sbuf->left ] 
return sbuf; *p++; 
Listing A.57. dv save.c- Save Region (Direct Video) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 #include <stdio.h> 
#include <stdlib.h> 
#include "video.h" 
#include <tools/termlib.h> 
SBUF *dv save( 1, r, t, b) 
{ 
/* Save all characters and attributes in indicated region. Return a 
* pointer to a save buffer. The cursor is not modified. Note that the 
* save buffer can be allocated from the far heap, but the SBUF itself is 
*not. See also, dv_restore() and dv_freesbuf(); 
*I 
int 
IMAGEP 
SBUF 
xsize (r 
ysize (b 
if ( ! (sbuf 
{ -ysize, xsize, x, y 
p; 
*sbuf; 
1) + 1; 
t) + 1; 
(SBUF *) malloc(sizeof(SBUF)) ) ) 
fprintf(stderr, "Internal error (dv_save): No memory for SBUF."); 
exit ( 1 ) ; 
} 
if( ! (p = (IMAGEP) IMALLOC(xsize * ysize * sizeof(WORD)))) 
{ 
fprintf(stderr, "Internal error (dv_save): No memory for image"); 
exit ( 2 ) ; 
Section A.9.2-Video I/O-Implementation 
Listing A.57. continued ••• 
30 
31 
32 
33 
34 
35 
36 
37 sbuf->left 
sbuf->right 
sbuf->top 
sbuf->bottom 
sbuf->image 1; 
r; 
t; 
b; 
p; 
38 for( y = 0; y < ysize ; ++y 
39 for( x = 0; x < xsize ++x 
40 *p++ = VSCREEN[ y + t] [ x + 1 ]; 
41 
42 return sbuf; 
43 
Listing A.58. dv scree.c- Direct-Video Variable Allocation 
I #define ALLOC 
2 #include "video.h" 
3 
4 /* This file has no code in it. It just allocates space for the variables 
5 * defined in video. h 
6 */ 
Listing A.59. dv scrol.c- Scroll Region of Screen (Direct Video) 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 #include "video.h" 
static void cpy_row( dest_row, src_row, left_col, right_col ) 
/* Copy all characters between left_col and right_col (inclusive) 
* from src row to the equivalent position in dest row. 
*I 
CHARACTER far *s 
CHARACTER far *d 
d & SCREEN[ dest row] [ left col ]; 
s = & SCREEN[ src row ] [left col]; 
while( left_col++ <= right_col 
*d++ = *s++; 
/*----------------------------------------------------------------------*/ 
static void cpy_col( dest_col, src_col, top_row, bot_row) 
( 
/* Copy all characters between top_row and bot_row (inclusive) 
* from src col to the equivalent position in dest col. 
*I 
CHARACTER far *s 
CHARACTER far *d & SCREEN[ top_row] [ src col ]; 
& SCREEN[ top_row] [ dest col ]; 765 
.... 
766 Support Functions-Appendix A 
Listing A.59. continued ... 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 while( top_row++ <=bot row 
{ 
*d *s; 
d += NUMCOLS; 
s += NUMCOLS; 
/*----------------------------------------------------------------------*/ 
static void clr_row( row, attrib, left_col, right col ) 
/* Clear all characters in the indicated row that are between left col and 
* right_col (inclusive). 
*I 
CHARACTER far *p = & SCREEN[ row] [left col]; 
while( left col++ <= right_col 
{ 
(p ) ->letter 
(p++)->attribute I I • 
I 
attrib 
/*----------------------------------------------------------------------*/ 
static void clr_col( col, attrib, top_row, bot row 
/* Clear all characters in the indicated column that are between top_row 
*and bot row (inclusive). 
*I 
CHARACTER far *p = & SCREEN[ top_row] [col]; 
while( top_row++ <=bot row 
{ 
p->letter 
p->attribute 
p += NUMCOLS , , ; 
attrib 
/*======================================================================* 
* Externally accessible functions: * 
*======================================================================* 
*I 
void dv_scroll_line ( x_left, x_right, y_top, y_bottom, dir, attrib ) 
/* Scroll the window located at: 
* * (y_top, X left) 
* +---------+ 
* 
* 
* +---------+ 
* 
* (y_bottom, x_right) 
* Dir is one of: 'u', 'd', '1 ', or 'r' for up, down, lett, or right. .... 
Section A.9.2-Video I/O-Implementation 767 
Listing A .59. continued ... 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 * The cursor is not moved. The opened line is filled with space characters 
* having the indicated attribute. 
*I 
int i; 
CHARACTER far *p; 
if( dir == 'u' 
{ 
for( i = y_top; i < y_bottom ; i++ ) 
cpy row( i, i+l, x_left, x_right ) ; 
clr_row( y_bottom, attrib, x_left, x_right ); 
else if( dir == 'd' ) 
{ 
for( i = y_bottom; --i >= y_top ; ) 
cpy_row( i+l, i, x_left, x_right ); 
clr_row( y_top, attrib, x_left, x_right ); 
else if( dir == '1' 
{ 
for( i = x_left; i < x_right; i++ ) 
cpy_col( i, i+l, y_top, y_bottom ); 
clr_col( x_right, attrib, y_top, y_bottom ); 
else /* dir == 'r' */ 
{ 
for( i = x right; --i >= x_left ; ) 
cpy_col( i+l, i, y_top, y_bottom ); 
clr_col( x_left, attrib, y_top, y_bottom ); 
/*----------------------------------------------------------------------*/ 
void dv_scroll( x_left, x_right, y_top, y_bottom, amt, attrib ) 
{ 
/* Scroll the screen up or down by the indicated amount. Negative 
* amounts scroll down. 
*I 
intdir 'u'; 
if ( amt < 0 ) 
{ 
amt -amt; 
dir 'd' ; 
while( --amt >= 0 ) 
dv_scroll_line( x_left, x_right, y_top, y_bottom, dir, attrib ); 
768 
Listing A.60. vb Jrees.c- Free Save Buffer (Video BIOS) 
#include "video.h" 
#include <toolsltermlib.h> 
#include <stdlib.h> 
vb_freesbuf ( p ) 
*p; Support Functions-Appendix A 
1 
2 
3 
4 
5 
6 
7 
8 
9 void 
SBUF 
{ I* Free an SBUF as is allocated by vb_save(). *I 
10 IFREE( p->image ); 
free ( p ) ; 
Listing A.61. vb getch.c- Get Character from Keyboard (Keyboard! BIOS) 
#include <dos.h> 
#include <toolslvbios.h> 
int vb_getchar() 1 
2 
3 
4 
5 
6 
7 
8 
9 I* Get a character directly from the keyboard *I 
10 
11 
12 union REGS regs; 
regs.h.ah = 0 ; 
int86( KB_INT, &regs, &regs); 
return( (int)regs.x.ax ); 
Listing A.62. vb getyx.c- Get Cursor Position (Video BIOS) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 #include <toolslvbios.h> 
void 
int 
{ vb_getyx( yp, xp 
*yp, *xp; 
register int 
posn VB_GETCUR(); posn; 
*xp posn & Oxff 
*yp (posn >> 8) & Oxff 
Listing A.63. vb iscol.c- Test for Color Card (Video BIOS) 
1 #include <toolslvbios.h> 
2 
3 int vb_iscolor () 
4 
5 int mode= _Vbios( 
6 return ( (mode 7 
7 (mode == 2 
8 GET 
II I* 
_VMODE, 
mode --Returns 
0, 0, 0, 
) ? 0 
3) ? 1 true if a 
0, "ax" 
-1 ) ; color card is active *I 
& Oxff ; 
Section A.9.2-Video I/O-Implementation 
Listing A.64. vb _yutc.c- Write Character in ITY Mode (Video BIOS) 
I 
2 
3 
4 
5 
6 
7 
8 
9 #include <tools/termlib.h> 
#include <tools/vbios.h> 
void vb_putc( c, attrib ) 
{ 
/* Write a character to the screen in TTY mode. Only normal printing 
* characters, BS, BEL, CR and LF are recognized. The cursor is automatic­
* ally advanced and lines will wrap. The WRITE TTY BIOS service doesn't 
* handle attributes correctly, so printing characters have to be output 
* twice---once by VB_OUTCHA to set the attribute bit, and atain using 769 
10 
II 
12 
13 
14 
15 
16 
17 
18 * WRITE TTY to move the cursor. WRITE_TTY picks up the existing attribute. 
*I 
if( c != '\b' && c != '\007' 
VB_OUTCHA( (c & Oxff) I && c != '\r' && c 
(attrib << 8) ); != '\n' 
_Vbios( WRITE_TTY, c, attrib & Oxff, 0, 0, "ax" ); 
Listing A.65. vb _yuts.c- Write String in TTY Mode (Video BIOS) 
I #include <tools/vbios.h> 
2 
3 void vb_puts( str, move cur 
4 register char *str; 
5 { 
6 /* Write a string to the screen in TTY mode. If move cur is true the cursor 
7 * is left at the end of string. If not the cursor will be restored to its 
8 *original position (before the write). 
9 */ 
10 
II int posn; 
12 
13 if( !move_cur ) 
14 posn = VB_GETCUR(); 
15 
16 while ( *str ) 
17 VB_PUTCHAR( *str++ ) ; 
18 
19 if ( !move_cur ) 
20 VB_SETCUR( posn ); 
21 
Listing A.66. vb resto.c- Restore Saved Region (Video BIOS) 
I #include "video.h" 
2 #include <tools/vbios.h> 
3 #include <stdlib.h> 
4 
5 SBUF *vb restore ( sbuf ) -6 SBUF *sbuf; 
7 { 
770 Support Functions-Appendix A 
Listing A.66. continued ... 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 /* Restore a region saved with a previous vb_save() call. The cursor is 
* not modified. Note that the memory used by sbuf is not freed, you must 
* do that yourself with a vb_freesbuf(sbuf) call. 
*I 
int ysize, xsize, x, y 
IMAGEP p; 
xsize 
ysize 
p ( sbuf->right -sbuf->left 
( sbuf->bottom sbuf->top 
sbuf->image; 
for( y = 0; y < ysize ; ++y 
for( x = 0; x < xsize ; ++x 
{ + 1 
+ 1 
VB_CTOYX( y + sbuf->top, x + sbuf->left ); 
VB_OUTCHA ( *p ) ; 
++p; I* VB OUTCHA has side effects so can't use *p++ */ 
return sbuf; 
Listing A.67. vb save.c- Save Region (Video BIOS) 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/termlib.h> /* must be included first */ 
#include <tools/vbios.h> 
SBUF *vb save( 1, r, t, b 
{ 
/* Save all characters and attributes in indicated region. Return a pointer 
* to a save buffer. The cursor is not modified. Note that the save buffer 
* is allocated from the far heap but the sbuf itself is not. See also, 
* dv_restore() and dv_freesbuf(); 
*I 
int 
IMAGEP 
SBUF ysize, xsize, x, y 
p; 
*sbuf; 
xsize 
ysize (r -1) + 1; 
(b -t) + 1; 
if ( ! (sbuf 
{ (SBUF *) malloc(sizeof(SBUF)) )) 
fprintf(stderr, "Internal error (vb_save): No memory for SBUF."); 
exit ( 1 ) ; 
if( ! (p = (IMAGEP) IMALLOC(xsize * ysize * sizeof(WORD)))) 
{ 
fprintf(stderr, "Internal error (vb_save): No memory for image."); 
exit ( 2 ) ; 
Section A.9.2-Video I/O-Implementation 
Listing A.67. continued ••• 
33 sbuf->1eft 1; 
34 sbuf->right r; 
35 sbuf->top t; 
36 sbuf->bottom b; 
37 sbuf->image p; 
38 
39 for( y = 0; y < ysize ; ++y 
40 for( X = 0; x < xsize ++x 
41 { 
42 VB_CTOYX( y + t , X + 1 ) ; 
43 *p++ = VB INCHA(); 
44 
45 
46 return sbuf; 
47 
A.1 0 Low-level-I/O, Glue Functions 
"Glue" functions are intermediate-level functions that allow your program to access 
low-level functions in a portable way. In the current context, the glue functions let you 
access either the direct-video or video-BIOS low-level-I/O functions without having to 
change the function calls in the program itself. If your program uses these glue functions 
instead of the actual l/0 subroutines, you can choose which set of functions to use by 
linking either direct-video or BIOS libraries to your final program, without having to 
change the program itself. The glue-to-I/O-function mapping is summarized in Table 
A.3. 
Table A.3. Mapping Glue Routines to I/0 Functions 
Glue Functiont Mapped to This Function 
Direct-video mode BIOS mode 771 
void clr _region(l,r,t,b,attrib) dv_clr_region VB CLR REGION - -void cmove (y,x) dv_ctoyx VB CTOYX -void curpos (int *yp,int *xp); dv_getyx vb_getyx 
void doscroll (l,r,t,b,a,at) dv scroll VB SCROLL - -void freescr (SBUF *p) i dv freesbuf vb freesbuf - -int incha () dv incha VB INCHA - -int in char () dv incha VB INCHA -void outc (c, attrib) dv_putc vb_putc 
void replace (c); dv_replace VB REPLACE -
SBUF *restore (SBUF *b) i dv restore vb restore - -
SBUF *savescr (l,r,t,b) dv save vb save 
t Unspecified argument types are int. 
The glue functions are declared in glue.c, Listing A.68. One of three sets of func­
tions are compiled depending on the existence of various macros as follows: One of three sets of glue 
functions can be com· 
piled, R, V, A. 
772 Support Functions-Appendix A 
If this macro Use this interface is#defined 
R Video-BIOS. 
v Direct-video. 
A Select automatically at run time (autoselect). 
You can compile glue.c three times, once with R defined, once with V defined, and once 
with neither defined. The version of glue.obj that you link then determines which set of 
1/0 functions are called into the final program. 
Select between direct 
video and video BIOS at 
run time, autoselect 
mode. In "autoselect" mode, the glue functions select one or the other of the sets of 1/0 
functions at run time. The ini t () function is used for this purpose. Normally, when R 
or V are #defined at compile time, ini t () just initializes for the required mode, 
returning zero if the BIOS is used (if R is defined) or 1 if direct-video functions are used. 
Initializing the low-level 
1/0 functions, ini t () . If A is #defined at compile time, the ini t () function selects either the BIOS or 
direct-video routines at run time. An ini t ( 0) call forces use of the BIOS, in it ( 1) 
forces use of direct-video functions, init (-1) causes init () to examine the VIDEO 
environment variable and chose according to its contents-if VIDEO is set to "DIRECT" 
or "direct", the direct-video functions are used, otherwise the video-BIOS is used. 
ini t () returns 0 if the BIOS is selected, 1 if the direct-video functions are selected. 
The one disadvantage to autoselect mode is that both libraries must be in memory at run 
time, even though you're using only one of them. The VIDEO environment. 
Listing A.68. glue.c-Glue Functions for Low-Level 1/0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 #include <stdio.h> 
#include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/termlib.h> 
#include <tools/vbios.h> 
I* GLUE.C This file glues the curses package to either the video-
* BIOS functions or to the direct-video functions. 
*I 
#if (!defined(R) && !defined(V)) 
# define AUTOSELECT 
#endif 
/*----------------------------------------------------------------------*/ 
#ifdef R 
init(how) 
cmove(y,x) 
curpos(yp,xp) int *yp,*xp; 
replace(c) 
doscroll(l,r,t,b,a,at) 
inchar () 
incha () 
outc(c, attrib) 
SBUF *savescr(l,r,t,b) 
SBUF *restore(b) SBUF *b; 
freescr (p) SBUF *p; 
clr_region(l,r,t,b,attrib) 
int is_direct() { return 0; }; 
#endif return 0; 
return VB CTOYX (y,x); 
return vb_getyx (yp,xp); 
return VB REPLACE (c); 
return VB SCROLL (l,r,t,b,a, at); 
return VB INCHA ( ) & Oxff 
return VB INCHA ( ); 
return vb_putc (c, attrib); 
return vb save (l,r,t,b); 
return vb restore (b); 
return vb_freesbuf(p); 
return VB_CLR_REGION(l,r,t,b,attrib); 
Section A.IO-Low-level-1/0, Glue Functions 773 
Listing A.68. continued ... 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 /*----------------------------------------------------------------------*/ 
#ifdef v 
cmove(y,x) 
curpos{yp,xp) int *yp,*xp; 
replace(c) 
doscroll(l,r,t,b,a,at) 
inchar () 
incha () 
outc(c,attrib) 
SBUF *savescr(l,r,t,b) 
SBUF *restore(b) SBUF *b; 
freescr(p) SBUF *p; 
clr_region(l,r,t,b,attrib) 
init( how) 
{ 
if ( ! dv ini t () ) 
{ return dv_ctoyx (y,x); 
return dv_getyx (yp,xp); 
return dv_replace (c); 
return dv scroll (l,r,t,b,a,at); 
return dv incha ( ) & Oxff; 
return dv incha ( ); 
return dv_putc (c, attrib); 
return dv save (l,r,t,b); 
return dv restore (b); 
return dv_freesbuf(p); 
return dv_clr_region(l,r,t,b,attrib); 
/* Initialize */ 
fprintf(stderr, "MGA or CGA in 80-column text mode required\n"); 
exit ( 1 ) ; 
return 1; 
intis direct() { return 1; }; 
#endif-
/*----------------------------------------------------------------------*/ 
#ifdef A 
static int Dv 0 
init( how 
int how; /* O=BIOS, l=direct video, -l=autoselect */ 
char 
if( 
{ *p; 
Dv = how ) 
if( how < 0 
{ 
p getenv( "VIDEO"); 
Dv p && ((strcmp(p,"DIRECT")==O 11 strcmp(p,"direct")==O)); 
if( Dv && !dv_init() ) 
{ 
fprintf(stderr, "MGA or CGA in 80-column text mode required\n"); 
exit( 1 ); 
return Dv; 
/* The following statements all depend on the fact that a subroutine name 
* (without the trailing argument list and parentheses) evaluates to a temporary 
* variable of type pointer-to-function. Therefore, function names can be treated 
*as a pointer to a function in the conditionals, below. For example, curpos() .... 
774 Support Functions-Appendix A 
Listing A.68. continued ••• 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 110 
Ill 
112 
113 
114 
115 
116 
117 118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
Curses. * calls dv getyx if Dv is true, otherwise vb_getyx is called. ANSI actually 
* says that the star isn't necessary. The following should be legal: 
* 
* 
* return (Dv ? dv_ctyx : VB_CTOYX) ( y, x ); 
* but many compilers (including Microsoft) don't accept it. Macros, clearly, 
* must be treated in a more standard fashion. 
*I 
curpos(yp,xp) int *yp,*xp;{return(Dv? *dv_getyx :*vb_getyx ) (yp,xp); 
SBUF *savescr(l,r,t,b) {return(Dv? *dv save :*vb save ) (l,r,t,b); 
SBUF *restore(b) SBUF *b; {return(Dv? *dv_restore :*vb_restore ) (b); 
freescr(p) SBUF *p; {return(Dv? *dv_freesbuf:*vb_freesbuf) (p); 
outc(c, attrib) {return(Dv? *dv_putc :*vb_putc ) (c, attrib); 
replace(c) 
cmove(y,x) 
inchar () 
incha () if(Dv) dv_replace(c); else VB_REPLACE(c); 
if(Dv) dv_ctoyx(y,x); else VB_CTOYX(y,x); 
return( Dv? dv_incha() VB_INCHA() & Oxff; 
return ( Dv? dv _ incha () VB_ INCHA () ) ; 
doscroll(l,r,t,b,a,at) 
{ 
if( Dv 
else dv_scroll(l,r,t,b,a,at); 
VB_SCROLL(l,r,t,b,a,at); 
clr region(l,r,t,b,attrib) 
if( Dv 
else dv_clr_region(l,r,t,b,attrib); 
VB_CLR_REGION(l,r,t,b,attrib); 
intis direct() { return Dv; }; 
#endif-
A.11 Window Management: Curses 
The low-level 1/0 functions are really too low level to be useful-higher-level func­
tions are needed. Since I write a lot of code that has to work in both the MS-DOS and 
UNIX environments, it seemed sensible to mimic a set of UNIX functions under MS-DOS. 
Among other things, this approach solves various incompatibility problems between the 
two systems. For example, the Microsoft, MS-DOS C compiler doesn't have UNIX­
compatible fcntl ( ) or ioctl ( ) functions, it doesn't support the ldevltty device for 
the console (you have to use ldevlcon or CON), and it doesn't provide any sort of 
termcap or curses-compatible function library. Consequently, it's difficult to port code 
that does low-level 1/0 from the Microsoft compiler to UNIX. 
Termcap database. The most serious omission in the earlier list is the lack of a curses library. For the 
uninitiated, curses is a collection of terminal-independent, low-level 1/0 functions. The 
package was written by Ken Arnold, then at U.C. Berkeley. These routines let you do 
things like move the cursor around on the screen, create and delete windows, write text 
and seek to specific window-relative cursor positions and so forth. The windows can be 
overlapping and they support individual wrap-around, scrolling, and so forth. The curses 
functions can talk to virtually any terminal. They accomplish this feat by using the 
Section A.ll -Window Management: Curses 
termcap terminal database and interface library developed by Bill Joy. The database is 
an ASCII file that contains definitions for the various escape sequences needed to get 
around on specific terminals, and the interface library lets you access these machine­
specific escape sequences in a portable and transparent way. 
The real curses routines talk to the terminals efficiently over a serial line. They 
always send the minimum number of characters necessary to modify the current screen. 
Curses keeps two internal images of the screen. One of these reflects what's actually on 
the screen, and the other is a scratch space that you modify using the various curses func­
tions. When you tell curses to do a refresh, it compares the scratch buffer with the actual 
screen image and then sends out the minimum number of characters necessary to get 
these images to match. This behavior is especially important when you're running a pro­
gram via a modem and characters are coming at 1200 baud. Redrawing the entire screen 
every time you scroll a four-line by 10-character window is just unacceptable behavior. 
It takes too long. Curses solves the problem by redrawing only those parts of the screen 
that have actually changed. 
The UNIX curses functions are described in depth in [Arnold] and also in [Haviland]. 
Since the implementation details can vary somewhat from installation to installation, I 
strongly recommend that you read your own system documentation as well. 
The current section describes the behavior of my own curses implementation, which 
occs uses for window management in interactive debugging environment. My system 
models Berkeley curses-there are a few minor differences between it and System V ver­
sions. I've written several quite complex programs using these functions, programs that 
maintain several windows on the screen simultaneously, all of which are being updated 
at different rates. Moreover, the finished programs have ported to UNIX (BSD 4.3) with 
literally no modification. I have not implemented the entire curses library, however, and 
I've added a few features to my own package that are not supported by the real curses. 
You can write a UNIX-compatible program using my functions, but there are minor (but 
documented) differences that can cause problems if you're not careful. For example, 
support for overlapping windows is limited (you can't write reliably to a window that has 
a second window on top of it). Subwindows aren't supported. This last problem means 
that you can't move a window along with the associated subwindows. Similarly, you 
have to delete or update the subwindows explicitly, one at a time. Pseudo-subwindows 
can be used, but only if you don't move them. My package does implement a few handy 
features not found in the UNIX version, however. You can hide a window without delet­
ing it, and there is a provision for making boxed windows. 
This section just describes my own functions. Though I point out the important 
differences from UNIX, you'll have to read the UNIX documentation too if you intend to 
write portable code. The two systems do behave differently in many ways. Note that, 
since these routines are not intended to port to UNIX, I haven't done things like use the 
UX ( ) and VA_ LIsT macros in <debug .h> to make them portable. 
A.11.1 Configuration and Compiling 
The curses functions talk to the screen using the low-level l/0 functions described in 
the previous section. Curses automatically selects between the CGA and MGA adapters 
by using the autoselect version of the glue functions. (The CGA must be running in an 
80-column mode, though.) Curses normally uses the ROM-BIOS routines, which are 
slow but portable. If, however, a VIDEO environment variable exists, and that variable is 
set to the string DIRECT, the direct-video functions will be used. (Do this with a 
set VIDEO=DIRECT from the DOS prompt.) The BIOS functions are noticeably 
slower than the direct-video functions. The speed problem is most evident when you are 
saving and restoring the area under a window. Moving a visible window in an 775 
Curses is designed for 
effk::ient serial communi­
cation. 
Curses portability issues. 
776 
curses.lib, termlib.lib. 
<Curses.h> 
Initialize, 
terminate curses. 
Set unbuffered, 
buffered input. Support Functions-Appendix A 
incremental fashion (one space or line at a time) is a particularly painful process when 
you're using the BIOS. It's better, in this instance, to hide the window, move it where 
you want it, and then redisplay it. 
The curses functions are all in a library called curses.lib, and the l/0 routines are in 
termlib.lib. Both of these must be linked to the final program. 
A.11.2 Using Curses 
Curses itself is part macro and part subroutines. The file <curses.h> should be 
#included at the top of every file that uses the curses functions. Supported functions 
are described in this section, grouped functionally. 
A.11.2.1 Initialization Functions. 
void initscr(void); 
void endwin (void); 
initscr ( ) initializes the curses package. It should be called at the head of 
your main ( ) subroutine, before any other curses functions are called. 
endwin ( ) cleans up. It should always be called before your program exits. 
In UNIX programs, the terminal can be left in an unknown state if you abort 
your program with a BREAK. If you exit abnormally from a program that uses 
curses, only to find your terminal acting funny (not echoing, not handling tabs or 
newlines properly, and so forth), you can usually correct the problem by typing 
tset with no arguments. If that doesn't work, try <NL>reset<NL> where <NL> is 
a newline or Ctrl-J. If that doesn't work try stty cooked echo nl, and if that 
doesn't work, hang up and log on again. To avoid this sort of flailing around, it's 
much better for your program to trap SIGINT and call endwin ( ) from within 
the service routine. Use the following: 
iinclude <signal.h> 
iinclude <curses.h> 
onintr () 
{ 
endwin(); 
exit( STATUS); 
main() 
{ 
signal SIGINT, onintr ); 
initscr void); 
A.11.2.2 Configuration Functions. Once the curses package is initialized, you 
should determine how your terminal is going to respond to typed characters. Six rou­
tines are provided for this purpose: 
int crmode (void); 
int nocrmode(void); 
These routines control input buffering; crmode ( ) disables buffering--characters 
will be available as soon as they're typed. A nocrmode ( ) call cancels a previ­
ous crmode ( ) . In nocr mode, an entire line is read before the first character is 
returned. The only editing character available in nocrmode( ) is a backspace, 
which deletes the character to the left of the cursor. Many curses programs use 
crmode ( ) , but some implementations won't work properly unless nocr­
mode ( ) is active. 
Section A.11.2-Using Curses 
int echo (void) ; 
int noecho(void); 
If echo ( ) is called, characters are echoed as they're typed; noecho ( ) 
suppresses the echoing-you'll have to echo the character yourself every time 
you read a character. The real curses gets very confused when echo ( ) is 
enabled. The problem here is that curses doesn't know about any character that it 
has not itself written to the screen. Since characters are echoed by the operating 
system rather than curses, the package doesn't know that they're there. As a 
consequence, when curses does a screen refresh, it won't delete the characters 
that it doesn't know about and the screen rapidly fills with unwanted and uneras­
able characters. It's best always to call noecho ( ) at the top of your program. 
Another echo-related problem found in the MS-DOS versions of curses. Character 
echo cannot be suppressed with the MS-DOS buffered-input function. So echo ( ) 
and noecho () have no effect on a program if nocrmode ( ) is active. 
int nl (void) ; 
int nonl (void) ; 
A nl ( ) call causes a new lines (' \n') to be converted to a carriage-return, line­
feed sequence on output; an input carriage return (' \r') is also mapped to a 
newline. Ifnonl () is called, no mapping is done. It's usually convenient to call 
nl ( ) at the top of your program, but again, many UNIX curses packages fail to 
work properly unless nonl ( ) is specified. You have to do all the '\n' to \r\n 
mapping yourself in non/ mode, of course. 
A.11.2.3 Creating and Deleting Windows. This section describes the functions 
that create and delete windows. There are two kinds of windows. A normal window and 
a subwindow. In UNIX curses, a subwindow is affected by all commands that also affect 
the parent. When a parent window is refreshed by curses, all subwindows are refreshed 
too. Similarly, when you delete or move a parent window, all the subwindows are 
deleted or moved. This feature is not supported in the current implementation, though 
you can pretend that subwindows exist if you don't move them. The mechanics of this 
process are discussed below. 
A default window, called stdscr, which occupies the entire screen, is created 
automatically by initscr (), and several functions are provided to modify this win­
dow. A stdscr variable is defined in <curses. h>, and it can be passed as a WINDOW 
pointer to any of the curses functions in a manner analogous to stdout. You shouldn't 
declare stdscr explicitly in your program, just use it. For convenience, most functions 
have a version that uses stdscr, rather than an explicit window, in a manner analogous 
to put char ( ) . If you are using curses only for cursor movement and are not creating 
additional windows, you can use stdscr directly and don't need to use any of the 
functions described in this section. 
In UNIX applications, it's often convenient to declare all windows as subwindows to 
stdscr. For example, the save-screen mechanism used in yydebug.c won't work unless 
all the windows are subwindows of stdscr because it reads characters from stdscr 
itself. 
WINDOW *newwin(int lines, int cols, int begin_y, int begin_x); 
WINDOW *subwin(WINDOW *win, int lines, int cols, int begin_y, 
int begin_x); 
This function creates a new window, lines rows high and cols columns wide 
with the upper-left comer at (begin _y, begin_ x). [All coordinates here are 
(y.x), where y is the row number and x is the column number. The upper-left Echo characters. 
Do not echo. 
Map newlines. 777 
Do not map newlines. 
Subwindows. 
The stdscr window. 
The stdscr variable in 
<Curses.h>. 
Create window, subwin­
dow. 
Coordinates are (y,x), 
y=row, x=column. Upper 
left corner is (0,0). 
778 
Enable or disable scrol­
ling. 
Nonstandard: enable or 
disable line wrap. 
Nonstandard: 
Box windows. 
No boxes. 
Nonstandard: change 
colors. Support Functions-Appendix A 
comer of the screen is (0,0).] A pointer to a WINDOW structure, declared in 
<curses.h>, is returned in a manner analogous to fopen () returning a FILE. 
Windows are created as visible, unboxed, with scrolling disabled, and with 
line wrap enabled. Characters that go past the end of line show up at the left edge 
of the next line, but the window won't scroll when you get to the bottom. The 
text under the window is saved by default and is restored when the window is 
moved or deleted. The window is automatically cleared as part of the creation 
process and there's no way to disable this clearing. All of these defaults can be 
changed with subroutine calls discussed below. 
The subwin ( ) call is provided for UNIX compatibility. It is mapped to a 
newwin ( ) call (the first argument is ignored). 
scrollok(WINDOW *win, int flag); 
This macro is passed a WINDOW pointer and a flag. If flag is true, the indi­
cated window is allowed to scroll. Otherwise the window does not scroll and 
characters that go off the bottom of the window are discarded. Scrolling is always 
enabled on the stdscr window. 
wrapok(WINDOW *win, int flag); 
This macro enables or disables line wrap if flag is false, enables it otherwise. 
Line wrap is enabled by default. When wrapping is disabled, characters written 
past the edge of the window are discarded rather than appearing on the next line. 
void boxed (void); 
void unboxed(void); 
The lack of support for subwindows complicates management of windows with 
boxes around them considerably. A UNIX-compatible method for creating boxed 
windows is described below in the discussion of the box ( ) function. It's not 
practical to use this function if windows will be moved, however. I've solved the 
problem to some extent by adding a mechanism for creating boxed windows in 
which the box is an integral part of the window and cannot be overwritten by the 
text. All windows created with newwin ( ) after boxed ( ) has been called will 
have an integral box as part of the window. You can go back to normal, unboxed 
windows by calling unboxed ( ) . IBM box-drawing characters are used for the 
border. 
void ground (WINDOW *win, int fore, int back); 
void def_ground(int fore, int back); 
ground () lets you change foreground (fore) and background (back} colors on 
the IBM/PC. The color codes are defined symbolically in <toolsltermlib.h>. 
def _ground () changes the default foreground and background colors. All 
windows created after a def _ground () call have the indicated colors. Use 
ground () to selectively change the attribute associated with specific characters 
written to a window; only those characters written to the window after the 
ground () call are affected. If you want to change an existing window's color 
without modifying the window's contents, you must change the color with 
ground () and then read each character individually and write it back using 
winch () and addch () . 
BUGS: del win () doesn't know about color changes, you must set the ground 
back to NORMAL and call wclear () before deleting the window. 
Section A.ll.2- Using Curses 
void save (void); 
void nosave(void); 
Normally, when you create a window, the text under that window is saved so that 
it can be replaced when the window is moved or deleted. This is a needless waste 
of memory if you're not going to delete or move the window. Once nosave ( ) 
has been called, the underlying text is not saved by subsequent newwin ( ) calls. 
Saving can be reenabled by calling save ( ) . Text under stdscr is never saved. 
delwin(WINDOW *win); 
This function removes a window from the screen, usually restoring the text that 
was underneath the window. If nosave ( ) was active when the window was 
created, however, an empty box is left on the screen when the window is deleted. 
Overlapping windows must be deleted in the opposite order from which they 
were created. Similarly, if you move one window on top of a second one, you 
must delete the top window first. I'd suggest keeping a stack of active windows 
so that you know the order in which they are created. 
A.11.2.4 Subroutines That Affect Entire Windows. 
WINDOW *hidewin(WINDOW *win); 
WINDOW *showwin(WINDOW *win); 
The only way to get rid of a UNIX-curses window is to delete it. This is incon­
venient when you really just want to make it invisible for a while and then 
redisplay it later. The nonstandard hidewin ( ) function hides the window 
(makes it disappear but does not delete it). It returns NULL if the window can't 
be hidden for some reason (usually not enough memory is available to save the 
image), or the win pointer on success. The window can be resurrected sometime 
later with a showwin ( ) call. showwin ( ) returns NULL (and does nothing) if 
the window wasn't hidden, otherwise the win argument is returned. hidewin ( ) 
always returns its argument-it terminates the program with an error message if it 
can't get memory to hide the window. 
It's okay to move a hidden window, it will just reappear at the new location when 
you call showwin ( ) . You cannot, however, write to a hidden window or the 
written characters will be lost. Similarly, the restrictions of deleting windows in 
the opposite order from which they were created also applies to hiding and 
redisplaying them. When windows can overlap, you must always hide the most­
recently displayed window first. 
int mvwin(WINDOW *win, int y, int x); 
This function moves a window to an absolute location on the screen. The area 
under the window is restored, the window is moved to the indicated location, and 
it is then redisplayed, saving the text that is now under the window first. You 
should move only the topmost of several overlapping windows. The normal UNIX 
mvwin ( ) returns ERR and does nothing if the new coordinates would have 
moved any part of the window off the screen. I've changed this behavior some­
what by always moving the window as far as I can. The window still won't move 
off the screen, but it may move a little if it wasn't already at the screen's edge. If 
you prefer UNIX compatibility, change the 0 in #define LIKE UNIX 0 in 
mvwin.c (below) to 1 and recompile. 
mvwinr(WINDOW *win, int y, int x); 
This nonstandard macro lets you move a window relative to the current window 779 
Nonstandard: control 
whether area under win­
dow is saved. 
Delete a window. 
Nonstandard: hide and 
redisplay window. 
Move window, absolute. 
Nonstandard: move win­
dow, relative. 
780 
Refresh stdscr. 
Refresh window. 
Draw box in window. 
Creating a boxed window 
with box(). Support Functions-Appendix A 
position. Positive values of y move down, negative values move up. Similarly, 
positive values of x move right and negative values go left. For example, 
mvwinr( win, -5, 10 ); 
moves the window pointed to by win five spaces up from, and lO spaces to the 
right of its current position. Like mvwin ( ) , you can't move the window off the 
screen. 
void refresh (void); 
void wrefresh(WINDOW *win); 
These macros are used by the real curses to do a screen refresh. They force the 
screen to coincide with the internal representation of the screen. No characters 
are actually written out to the terminal until a refresh occurs. My own curses 
writes to the screen immediately, so both of these macros expand to null 
strings-they are ignored. You'll need them to be able to port code to UNIX, how­
ever. refresh ( ) refreshes the whole screen (the stdscr window and all 
subwindows of stdscr); wrefresh (win) is passed a WINDOW pointer and 
refreshes only the indicated window. 
int box(WINDOW *win, int vert, int horiz); 
This subroutine draws a box in the outermost characters of the window using 
vert for the vertical characters and horiz for the horizontal ones. I've 
extended this function to support the IBM box-drawing characters. If IBM box­
drawing characters are specified for vert and horiz, box() will use the correct 
box-drawing characters for the comers. The box-drawing characters are defined 
in <toolslbox.h> as follows: 
symbolic I numeric 
I description value value 
HORIZ Oxc4 Single horizontal line. 
D HORIZ Oxcd Double horizontal line. 
VERT Oxb3 Single vertical line. 
D VERT Oxba Double vertical line. 
Boxes may have double horizontal lines and single vertical ones, or vice versa. 
The UNIX box ( ) function uses the vertical character for the comers. 
Note that box ( ) doesn't draw a box around the window; rather, it draws the 
box in the outermost characters of the window itself. This means that you can 
overwrite the border if your output lines are too wide. When you scroll the win­
dow, the box scrolls too. Normally, this problem is avoided by using the subwin­
dow mechanism. A large outer window is created and boxed, a smaller subwin­
dow is then created for the text region. 
A function that creates a bordered window in this way is shown in Listing 
A.69. The outer window is created on line 14, the inner, nested one on line 22. 
The outer window just holds the box and the inner window is used for characters. 
This way, you can overflow the inner window and not affect the outer one (that 
holds the border). The function returns a pointer to the text window. If you plan 
to move or delete the window, you'll need the pointer to the outer window too, 
and will have to modify the subroutine accordingly. 
Section A.11.2-Using Curses 
Listing A.69. Creating a Boxed Window 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 WINDOW 
char *boxwin( lines, cols, y_start, x_start, title ) 
*title; 
{ 
/* This routine works much like the newwin() except that the window has a 
* box around it that won't be destroyed by writes to the window. It 
* accomplishes this feat by creating two windows, one inside the other, 
* with a box drawn in the outer one. It prints the title centered on the 
* top line of the box. Note that I'm making all windows subwindows of the 
* stdscr to facilitate the print-screen command. 
*I 
WINDOW *outer, *inner; 
outer= subwin(stdscr, lines, cols, y_start, x_start); 
box( outer, '1', '-' ) ; 
wmove outer, 0, (cols -strlen (title)) /2 ) ; 
wprintw( outer, "%s", title ); 
wrefresh( outer); 
return subwin( stdscr, lines-2, cols-2, y_start+l, x start+l ); 
A.11.2.5 Cursor Movement and Character 1/0. 
int 
int 
void move (y, x); 
wmove(WINDOW 
getyx(WINDOW *win, y, x); 
*win, y, x); 
These functions support cursor movement. move ( ) moves the cursor to the indi­
cated absolute position on the screen. The upper-left comer of the screen is (0,0). 
wmove ( ) moves the cursor to the relative position within a specific window 
(pointed to by win). The upper-left comer of the window is (0,0). If you try to 
move past the edge of the window, the cursor will be positioned at the closest 
edge. The getyx ( ) macro loads the current cursor position for a specific win­
dow into y and x. Note that this is a macro, not a subroutine, so you should not 
precede y or x with an address-of operator(&). A getyx (stdscr,y,x) call 
loads the current absolute cursor position into y and x. Move cursor. 
Get cursor position 
(MACRO). 781 
int getch (void); 
int wgetch(WINDOW *win); Get character and echo 
to window 
These functions are used for direct keyboard input. getch ( ) gets a character 
from the keyboard and echoes it to stdscr, wgetch ( ) echoes the character to 
the indicated window (if echo ( ) is enabled, that is). Note that crmode ( ) has 
to be enabled to get the character as soon as it's typed. Otherwise the entire line 
will be buffered. It's unfortunate that many compiler manufactures, Microsoft 
included, have chosen to use get ch ( ) as the name of their standard direct 
keyboard-input function. You'll need to specify a /NOE switch to Microsoft 
link to prevent the linker from attempting to call in both versions of the sub­
routine. Use Microsoft Link's 
/NOE switch to avoid 
name conflicts. 
782 
Read functions. 
printf () to stdscr. 
printf () to window. 
Character-output func­
tions. inch (void) ; 
winch (WINDOW *win); 
mvinch (int y, int x); 
mvwinch(WINDOW *win, int y, int x); Support Functions-Appendix A 
These functions let you read back characters that are displayed on the screen. 
inch ( ) returns the character at the current cursor position (that is, from 
stdscr). mvinch (y, x) moves the cursor to the indicated position and then 
returns the character at that position; the winch ( ) and mvwinch (win, y, x) 
versions do the same, but the cursor position is relative to the origin of the 
specified window. Note that they and x coordinates are relative to the origin of 
the indicated window, not to the entire screen. (0,0) is the top left corner of the 
window. Some older versions of curses don't support the mv versions of this com­
mand. Note that all four functions work as if all windows were declared as 
subwindows to stdscr. This is not the case in UNIX systems, in which a read 
from stdscr can get a character from the standard screen that is currently 
obscured by an overlapping window. 
void printw(char *fmt, ... ); 
int wprintw(WINDOW *win, char *fmt, ... ); 
These functions are used for formatted output. printw ( ) works just like 
printf (); wprintw ( ) is the same but it prints to the indicated window, mov­
ing the cursor to the correct position in the new window if necessary. (The cursor 
is moved to the position immediately following the character most recently writ­
ten to the indicated window.) printw ( ) pays no attention to window boun­
daries, but wprintw ( ) wraps when you get to the right edge of the window and 
the window scrolls when you go past the bottom line (provided that scrol­
lok ( ) has been called for the current window). 
void addch (int c); 
int waddch (WINDOW *win, int c); 
void addstr (char *str); 
int waddstr(WINDOW *win, char *str); 
These functions are the curses equivalents of putc ( ) , put char ( ) , puts ( ) , 
and fputs (): addch () works like put char (); waddch () writes a charac­
ter to the indicated window (and advances the cursor); addstr ( ) and 
waddstr ( ) work like fputs ( ) , writing a string to stdscr or the indicated 
window. Neither addstr () nor waddstr () add a newline at the end of the 
string. addch ( ) and waddch ( ) treat several characters specially: 
' \n' Clear the line from the current cursor position to the right edge of the win­
dow. If n 1 ( ) is active go to the left edge of the next line, otherwise go to 
the current column on the next line. In addition, if scrolling is enabled, the 
window scrolls if you're on the bottom line. 
' \ t' is expanded into an 8-space field. If the tab goes past the right edge of the 
window, the cursor wraps to the next line. 
' \ r' gets you to the left edge of the window, on the current line. 
'\b' backs up one space but may not back up past the left edge of the window. 
A nondestructive backspace is used (the character on which the initial cur­
sor sits is not erased). The curses documentation doesn't say that ' \b' is 
handled specially but it does indeed work. 
ESC The ESC character is not handled specially by UNIX but my waddch ( ) 
does do so. Don't use explicit escape sequences if portability is a 
Section A.l1.2- Using Curses 
consideration. All characters between an ASCII ESC and an alphabetic 
character (inclusive) are sent to the output but are otherwise ignored. This 
behavior let's you send escape sequences directly to the terminal to 
change character attributes and so forth. I'm assuming here that you won't 
change windows in the middle of an escape sequence. 
waddch ( ) returns ERR (defined in <curses. h>) if the character had caused 
the window to scroll illegally or if you attempt to write to a hidden window. 
void werase (WINDOW *win); 
void erase (void); 
void wclear (WINDOW *win); 
void 
void void clear (void); 
wclrtoeol(WINDOW *win); 
clrtoeol (void); 
These functions all erase one or more characters. clear ( ) and erase ( ) both 
clear the entire screen, wclear ( ) and we rase ( ) both clear only the indicated 
window, wclrtoeol ( ) clears the line from the current cursor position in the 
indicated window to the right edge of the indicated window, and clrtoeol ( ) 
clears from the current cursor position to the right edge of the screen. 
int scroll (WINDOW *win); 
int wscroll(WINDOW *win, int amt); 
These two functions scroll the window: scroll ( ) scrolls the indicated window 
up one line, wscroll ( ) scrolls by the indicated amount-up if amt is positive, 
down if it's negative. wscroll () is not supported by the UNIX curses. Both 
functions return I if the window scrolled, 0 if not. 
There's one caveat about scrolling. The UNIX functions have a bug in them: 
when a window scrolls, the bottom line is not cleared, leaving a mess on the 
screen. This problem is not restricted to the scroll ( ) subroutine but occurs 
any time that the window scrolls (as when you write a newline on the bottom line 
of the window or when a character wraps, causing a scroll. As a consequence, if 
you're porting to UNIX, you should always do a clrtoeol () immediately after 
either scrolling or printing a newline. Unfortunately, there's no easy way to tell if 
a window has scrolled because of a character wrap. My curses package doesn't 
have this problem-the bottom line of the window is always cleared on a scroll. 
A.11.3 Curses-Implementation 
This section discusses my curses implementation. Note that I haven't bothered to 
make this code UNIX compatible-I'm assuming that you're going to use the native UNIX 
curses in that environment. For the most part, the code is straightforward and needs little 783 
Erase window, entire 
screen, to end of line. 
Scroll window. 
comment. The WINDOW structure is declared on lines one to 17 of <toolslcurses.h> The WINDOW structure. 
(Listing A.70). The macros for bool, reg, TRUE, FALSE, ERR, and OK are defined in the 
UNIX <curses.h> file so I've put them here too, though they're not particularly useful. 
Be careful of: Problems with 
if( foo() == TRUE ) 
TRUE is #defined to 1 but, in fact, any nonzero value is true. As a consequence, 
foo ( ) could return a perfectly legitimate true value that didn't happen to be 1, and the 
test would fail. The test: if (foe() ==TRUE). 
784 Support Functions-Appendix A 
if( foo() != FALSE ) 
ERR returned by curses 
output functions. is safer. Most of the output functions return ERR if a write would normally have caused 
a scroll but scrolling is disabled. 
Listing A.70. curses.h- WINDOW Definitions and Macros 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 typedef struct window 
{ 
int x_org; 
int y_org; 
int X size; 
int y_ size; 
int row; 
int col; 
void *image; 
unsigned wrap_ok 
unsigned scroll ok 
unsigned hidden 
unsigned boxed 
unsigned attrib 
WINDOW; :1 
:1 
:1 
:1 
:8 I* X coordinate of upper-left corner *I 
I* Y coordinate of upper-left corner *I 
I* Horizontal size of text area. *I 
I* Vertical size of text area. *I 
I* Current cursor row (0 to y_size-1) *I 
I* Current cursor column (0 to x_size-1) *I 
I* Image buffer. Holds what used to be *I 
I* under the window. *I 
I* Line wrap is enabled in this win. *I 
I* Scrolling permitted in this window *I 
I* Window is hidden (nonstandard) *I 
I* Window is boxed (nonstandard) *I 
I* attribute used for character writes *I 
#define bool unsigned int 
#define reg register 
#define TRUE (1) 
#define FALSE (0) 
#define ERR (0) 
#define OK (1) 
1*------------------------------------------------------------
* The following macros implement many of the curses functions. 
*I 
#define getyx( win, y, x 
((X) 
#define refresh() 
#define scrollok(win,flag) 
#define wrapok(win,flag) 
#define wrefresh(win) \ 
((WINDOW*) (win)) ->col, (y) 
((win)->scroll_ok 
((win) ->wrap_ok 
I* empty *I (flag)) 
(flag)) ((WINDOW*) (win))->row) 
1*----------------------------------------------------------
* Nonstandard Macros: movewin() moves the window relative to the current 
* position. Negative is left or up, positive is right or 
* down. ground() changes the fore and background colors for subsequent writes 
* to the window. 
*I 
#define mvwinr(w,dy,dx) mvwin((w), ((w)->y_org- (w)->boxed) + (dy), \ 
((w)->x_org- (w)->boxed) + (dx) ) 
#define ground(win,f,b) win->attrib = ((f) & Ox7f) ((b) & Ox7f) « 4) 
1*---------------------------------------------------------
* Externs for the window functions and #defines to map the standard screen 
* functions to the stdscr versions. There are a few idiosyncrasies here. 
* In particular, mvcur() just ignores it's first two arguments and maps to a 
*move() call. Similarly, subwin() just maps to a newwin() call, and clearok() ... 
Section A.11.3 -Curses-Implementation 
Listing A.70. continued ... 
55 * isn't supported. You must clear the window explicitly before writing to it. 
56 */ 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 extern 
extern 
extern 
extern 
#define 
extern 
#define 
extern 
#define 
extern 
#define 
#define 
#define 
extern 
#define 
extern 
#define 
#define 
extern 
extern 
extern 
#define 
extern 
#define 
#define 
#define WINDOW 
void endwin 
void initscr 
int waddch 
addch(c) 
int waddstr 
addstr(s) 
int wclrtoeol 
clrtoeol () 
int werase 
erase 
wclear(w) 
clear() 
int wgetch 
getch () 
int wmove 
move(y,x) 
mvcur(oy,ox,y,x) 
int wprintw 
int printw 
int wscroll 
scroll (win) 
int winch 
inch() 
mvinch(y,x) 
mvwinch(w,y,x) *stdscr; 
(void); (void); 
(WINDOW * int); I 
waddch ( stdscr, c) 
(WINDOW *I char *); 
waddstr(stdscr,s) 
(WINDOW * ) ; 
wclrtoeol(stdscr) 
(WINDOW * ) ; 
werase(stdscr) 
we rase (w) 
werase(stdscr) 
(WINDOW *); 
wgetch( stdscr 
(WINDOW *I int, int ) ; 
wmove( stdscr, (y), (x) 
move ( (y), (x)) 
(WINDOW * char * ) ; I I 
( char * ) ; I 
(WINDOW * I int ) ; 
wscroll(win,l) 
(WINDOW *); 
winch(stdscr) 
( wmove(stdscr,y,x), winch (stdscr) 
( wmove(w, y,x), winch(w) 
95 extern WINDOW *newwin (int ,int ,int ,int ); 
96 #define subwin(w,a,b,c,d) newwin(a,b,c,d) 
97 
98 /*----------------------------------------------------------
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 109 
110 
Ill 
112 
113 
114 * Externs 
*I 
extern int 
extern int 
extern int 
extern int 
extern int 
extern int 
extern int 
extern int 
extern int 
extern void 
extern void 
extern void 
extern void for functions 
box 
crmode 
del win 
echo 
mvwin 
nl 
nocrmode 
noecho 
nonl 
boxed 
unboxed 
save 
nos ave that don't have stdscr versions 
(WINDOW * ,int ,int ) ; /* UNIX functions 
(void); 
(WINDOW *) ; 
(void); 
(WINDOW *win, int y, int x); 
(void); 
(void); (void); (void); 
( void ) ; /* Nonstandard functions 
( void ) ; 
( void ) ; 
( void ) ; *I 
*I 785 
.... 
786 Support Functions-Appendix A 
Listing A.70. continued ••• 
115 extern void def_ground ( int, int ); 
The comma operator in 
mvinch () and 
mvwinch () . Writing 
multiple-statement mac­
ros. The mvinch ( ) and mvwinch ( ) macros on lines 92 and 93 of Listing A.70 use the 
comma, or sequence, operator. The comma operator evaluates from left to right, and the 
entire expression evaluates to the rightmost object in the list. For example, the 
mvinch ( ) looks like: 
#define mvinch(y,x) (move(y,x), inch()) 
An equivalent subroutine is: 
mvinch(y,x) 
( 
move(y,x); 
return inch(); 
The comma operator is used because there are two statements that have to be executed, 
the move ( ) call and the inch ( ) call. Were you to define the macro as: 
#define mvinch(y,x) move(y,x); inch() 
the following code wouldn't work: 
if( condition ) 
mvinch(y,x); 
because it would expand to: 
if( condition ) 
move (y,x); 
inch() ; 
Putting curly braces around the statements doesn't help. For example: 
#define mvinch(y,x) {move(y,x); inch();} 
if( condition ) 
mvinch(y, x); 
else 
something(); 
expands to 
if( condition 
( 
else move(y,x); 
inch(); 
something(); 
Here the else will try to bind with the semicolon, which is a perfectly legitimate state­
ment inC, causing a No matching if for else error message. Though the comma operator 
solves both of these problems, it isn't very readable. I don't recommend using it unless 
you must. Never use it if curly braces will work in a particular application. The 
remainder of curses is in Listings A. 71 to A.87. 
Section A.l1.3 -Curses-Implementation 787 
Listing A.71. box.h-IBM/PC Box-Drawing Characters 
* The names are: 
* 
* UL Upper left corner 
* UR Upper right corner 
* LL lower left corner 
* LR lower right corner 
* CEN Center (intersection of two lines) 
* TOP Tee with the flat piece on top 
* BOT Bottom tee 
* LEFT Left tee 
* RIGHT Right tee 
* HORIZ Horizontal line 
* VERT Vertical line. 
* 
* UL -TOP- UR HORIZ 
* I 
* L R v 
* E I E 
* F---CEN- --G R 
* T I H T 
* I T 
* 
* LL -BOT- LR 
* 
* The D XXX defines have double horizontal and vertical lines. 
* The HD XXX defines have double horizontal lines and single vertical 
* The VD XXX defines have double vertical lines and single horizontal 
* 
#ifdef NOT_ IBM PC 
# define IBM_BOX(x) 
# define OTHER_BOX(x) X 
#else 
# define IBM_BOX(x) X 
# define OTHER_BOX(x) 
#endif 
#define VERT IBM_BOX( 179 OTHER_BOX( I I I 
#define RIGHT IBM_BOX( 180 OTHER_BOX( I +I 
#define UR IBM_BOX( 191 OTHER_BOX( I +I 
#define LL IBM_BOX( 192 OTHER_BOX( I +I 
#define BOT IBM_BOX( 193 OTHER_BOX( 1+1 
#define TOP IBM_BOX( 194 OTHER_BOX( I +I 
#define LEFT IBM_BOX( 195 OTHER_BOX( 1+1 
#define HORIZ IBM_BOX( 196 OTHER_BOX( I _I 
#define CEN IBM_BOX( 197 OTHER_BOX( I +I 
#define LR IBM_BOX( 217 OTHER_BOX( I +I 
#define UL IBM_BOX( 218 OTHER_BOX( I +I 
#define D VERT IBM_BOX( 186 OTHER_BOX( I I I 
#define D RIGHT IBM_BOX( 185 OTHER_BOX( I +I 
#define D UR IBM_BOX( 187 OTHER_BOX( 1+1 
#define D LL IBM_BOX( 200 OTHER_BOX( 1+1 
.... 
788 Support Functions-Appendix A 
Listing A. 71. continued ... 
60 #define D BOT IBM_BOX( 202 ) OTHER_BOX( I+' ) 
61 #define D TOP IBM_BOX( 203 ) OTHER_BOX( '+' ) -62 #define D LEFT IBM_BOX( 204 ) OTHER_BOX( I+' ) -63 #define D HORIZ IBM_BOX( 205 ) OTHER_BOX( I _I ) -64 #define D CEN IBM_BOX( 206 ) OTHER_BOX( I+' ) -65 #define D LR IBM_BOX( 188 ) OTHER_BOX( I+' ) -66 #define D UL IBM_BOX( 201 ) OTHER_BOX( I+' ) -67 #define HD VERT IBM_BOX( 179 ) OTHER_BOX( I I I ) -68 #define HD RIGHT IBM_BOX( 181 ) OTHER_BOX( I+' ) -69 #define HD UR IBM_BOX( 184 ) OTHER_BOX( '+' ) -70 #define HD LL IBM_BOX( 212 ) OTHER_BOX( '+' ) -71 #define HD BOT IBM_BOX( 207 ) OTHER_BOX( '+' ) -72 #define HD TOP IBM_BOX( 209 ) OTHER_BOX( I+' ) -73 #define HD LEFT IBM_BOX( 198 ) OTHER_BOX( I+' ) -74 #define HD HORIZ IBM_BOX( 205 ) OTHER_BOX( I _I ) -75 #define HD CEN IBM_BOX( 216 ) OTHER_BOX( I+' ) -76 #define HD LR IBM_BOX( 190 ) OTHER_BOX( I+' ) -77 #define HD UL IBM_BOX( 213 ) OTHER_BOX( I+' ) -78 #define VD VERT IBM_BOX( 186 ) OTHER_BOX( I I I ) -79 #define VD RIGHT IBM_BOX( 182 ) OTHER_BOX( I+' ) -80 #define VD UR IBM_BOX( 183 ) OTHER_BOX( I+' ) -81 #define VD LL IBM_BOX( 211 ) OTHER_BOX( I+' ) -82 #define VD BOT IBM_BOX( 208 ) OTHER_BOX( I+' ) -83 #define VD TOP IBM_BOX( 210 ) OTHER_BOX( I+' ) -84 #define VD LEFT IBM_BOX( 199 ) OTHER_BOX( I+' ) -85 #define VD HORIZ IBM_BOX( 196 ) OTHER_BOX( I _I ) -86 #define VD CEN IBM_BOX( 215 ) OTHER_BOX( '+' ) -87 #define VD LR IBM_BOX( 189 ) OTHER_BOX( '+' ) 
88 #define VD UL IBM_BOX( 214 ) OTHER_BOX( '+' ) -
Listing A.72. cur.h-Curses Fuctions #includes 
1 #include <stdio.h> 
2 #include <stdlib.h> 
3 #include <ctype.h> 
4 #include <curses.h> I* routines in the library. *I 
5 #include <stdarg.h> /* va list and va start (ANSI) *I 
6 #include <too1s/debug.h> 
7 #include <too1s/termlib.h> 
8 #include <tools/box.h> /* of IBM box-drawing characters 
9 #include "proto.h" /* function prototypes for curses functions 
10 /* (distributed on disk but not printed here 
Listing A.73. box.c-Draw Box in Window 
1 #include "cur.h" 
2 
3 box( win, vert, horiz 
4 WINDOW *win; 
5 { *I 
*I *I 
6 /* Draws a box in the outermost characters of the window using vert for 
7 * the vertical characters and horiz for the horizontal ones. I've 
8 * extended this function to support the IBM box-drawing characters. That 
9 * is, if IBM box-drawing characters are specified for vert and horiz, 
10 *box() will use the correct box-drawing characters in the corners. These ... 
Section A.11.3 -Curses-Implementation 789 
Listing A.73. continued ... 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 * are defined in * box.h as: 
* 
* HORIZ (0xc4) single horizontal line 
* D HORIZ (Oxcd) double horizontal line. 
* VERT (0xb3) single vertical line 
* D VERT (Oxba) double vertical line. 
*I 
int i, nrows; 
int u1, ur, 11, 1r; 
int oscro11, owrap, oy, ox; 
getyx( win, oy, ox); 
oscro11 win->scro11_ok; I* Disable scrolling and line wrap *I 
I* in case window uses the whole screen *I ow rap 
win->scro11 ok win->wrap_ok; 
0; 
win->wrap_ok 0; 
if( ! ((horiz==HORIZ 11 horiz==D_HORIZ) && (vert ==VERT I I vert ==D_VERT)) 
u1 = ur = 11 = 1r = vert ; 
else 
{ 
if( vert == VERT ) 
{ 
if(horiz==HORIZ) 
u1=UL, 
else ur=UR, ll=LL, 1r=LR; 
u1=HD_UL, ur=HD_UR, 11=HD_LL, 1r=HD_LR; 
else 
{ 
if( horiz == HORIZ ) 
u1=VD_UL, ur=VD_UR, 11=VD_LL, 1r=VD_LR; 
else 
u1=D_UL, ur=D_UR, 11=D_LL, 1r=D_LR; 
wmove win, 0, 0 ); 
waddch( win, u1 ); 
for( i = win->x_size-2; --i >= 0 
waddch( win, horiz ); 
waddch( win, ur ); 
nrows win->y_size - 2 
i = 1 
while( --nrows >= 0 
{ 
wmove ( win, 
waddch( win, 
wmove ( win, 
waddch( win, 
wmove win, i, 0 ); 
waddch( win, 11 ); ) 
i, 0 
vert 
i++, 
vert ) ; 
) ; 
win->x 
) ; I* Draw the top line *I 
I* Draw the two sides *I 
size -1 ) ; 
I* Draw the bottom line *I 
790 
Listing A.73. continued .•• 
70 
71 
72 
73 
74 
75 
76 
77 for( i win->x_size-2; --i >= 0 
waddch( win, horiz ); 
waddch( win, lr ); 
wrnove ( win, oy, 
win->scroll ok 
win->wrap_ok OX); 
oscroll 
owrap ; 
Listing A.74. delwin.c- Delete Window 
#include "cur.h" 
delwin( win ) 
WINDOW *win; 
{ Support Functions-Appendix A 
I 
2 
3 
4 
5 
6 
7 
8 
9 I* Copy the saved image back onto the screen and free the memory used for 
* the buffer. 
*I 
10 
II 
12 
13 
14 
15 
16 if( win->image ) 
{ 
restore 
freescr 
free( win); (SBUF *) win->image ); 
(SBUF *} win->image ); 
Listing A.75. hidewin.c- Hide a Window 
I #include "cur .h" 
2 
3 WINDOW *hidewin( win 
4 WINDOW *win; 
5 { 
6 I* Hide a window. Return NULL and do nothing if the image wasn't saved 
7 * originally or if it's already hidden, otherwise hide the window and 
8 * return the win argument. You may not write to a hidden window. 
9 *I 
10 
II SBUF *image; 
12 
13 if ( ! win->image 1 1 win->hidden ) 
14 return NULL; 
15 
16 image = savescr ( ( (SBUF*) (win->image)) ->left, ( (SBUF*} (win->image)) ->right, 
17 ((SBUF*) (win->image))->top, ((SBUF*) (win->image))->bottom ); 
18 
19 restore ( (SBUF *) win->image ) ; 
20 freescr ( (SBUF *} win->image ) ; 
21 win->image = image; 
22 win->hidden = 1; 
23 return ( win ) ; 
24 
Section A.ll.3 -Curses-Implementation 
Listing A.76. initscr.c- Initialize Curses 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 #include "cur.h" 
WINDOW *stdscr; 
void 
{ 
void 
{ endwin() I* Clean up as required *I 
cmove( 24,0 ); 
initscr () 
I* Creates stdscr. If you want a boxed screen, call boxed() before this 
* routine. The underlying text is NOT saved. Note that the atexit call 
*insures a clean up on normal exit, but not with a Ctrl-Break, you'll 
*have to call signal() to do that. 
*I 
nosave(); 
init(-1); 
stdscr = newwin( 25, 80, 0, 0 ); 
save(); 
atexit( endwin ); 
Listing A.77. mvwin.c- Move a Window 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 #include "cur.h" 
I* Move a window to new absolute position. This routine will behave in one of 
*two ways, depending on.the value of LIKE_UNIX when the file was compiled. 
* If the #define has a true value, then mvwin() returns ERR and does nothing 
* if the new coordinates would move the window past the edge of the screen. 
* If LIKE_UNIX is false, ERR is still returned but the window is moved flush 
* with the right edge if it's not already there. ERR says that the window is 
* now flush with the edge of the screen. In both instances, negative 
* coordinates are silently set to 0. 
*I 
#define LIKE UNIX 0 
#if 
# 
# 
#else 
# 
# 
#endif LIKE_UNIX ) 
define UNIX(x) x 
define DOS(x) 
define UNIX(x) 
define DOS(x) x 
mvwin( win, y, x ) 
WINDOW *win; 
{ 
int old_x, old_y, xsize, ysize, delta_x, delta_y, visible; 
SBUF *image; 
if( win == stdscr 
return ERR; I* Can't move stdscr without it going 
I* off the screen. *I 
*I 791 
792 Support Functions-Appendix A 
Listing A.77. continued .•• 
32 /* Get the actual dimensions of the window: compensate for a border if the 
33 * window is boxed. 
34 */ 
35 
36 
37 
38 
39 
40 old X 
old_y 
xsize 
ysize win->x_org 
win->y_org 
win->x size -win->y_size win->boxed win->boxed 
+ (win->boxed * 2); 
+ (win->boxed * 2); 
41 /* Constrain x and y so that the window can't go off the screen */ 
42 
43 x =max( 0, x ); 
44 y = max ( 0, y ) ; 
45 if ( x + xsize > 80 
46 { 
47 UNIX( return ERR; 
48 DOS ( x = 80 -xsize; 
49 } 
50 if ( y + ysize > 25 
51 { 
52 UNIX( return ERR; 
53 DOS ( y = 25 -ysize; 
54 
55 
56 /* Adjust coordinates. */ 
57 
58 
59 
60 
61 
62 if( visible = !win->hidden 
63 hidewin( win); 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 win->y_org 
win->x_org 
image 
image->top 
image->bottom 
image->left 
image->right 
if( visible ) 
showwin( 
return( OK ) ; += delta _y; 
+= delta _x; 
(SBUF *) 
+= delta _y; 
+= delta _y; 
+= delta x; -+= delta x; -
win ) ; win->image; 
Listing A.78. showwin.c- Display a Previously Hidden Window 
1 #include "cur.h" 
2 
3 WINDOW *showwin( win 
4 WINDOW *win; 
5 { 
6 /* Make a previously hidden window visible again. Return NULL and do 
7 * nothing if the window wasn't hidden, otherwise return the win argument. 
8 *I 
9 
Section A.ll.3 -Curses-Implementation 
Listing A. 78. continued ••• 
SBUF *image; 
if( !win->hidden 
return ( NULL ) ; 793 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 image= savescr(((SBUF*) (win->image))->left, 
((SBUF*) (win->image))->top, ( (SBUF*) (win->image)) ->right, 
((SBUF*) (win->image))->bottom); 
restore( (SBUF *) win->image ); 
freescr( (SBUF *) win->image ); 
win->image image; 
win->hidden = 0; 
/* Move the cursor to compensate for windows that were moved while they 
* were hidden. 
*I 
cmove( win->y_org + win->row, win->x_org + win->col ); 
return ( win ) ; 
Listing A.79. waddstr.c- Write String to Window 
1 #include "cur. h" 
2 
3 waddstr( win, str 
4 WINDOW *win; 
5 char *str; 
6 { 
7 while( *str 
8 waddch( win, *str++ ); 
9 
Listing A.80. wclrtoeo.c- Clear from Cursor to Edge of Window 
#include "cur.h" 
wclrtoeol( win 
WINDOW *win; 
{ 1 
2 
3 
4 
5 
6 
7 
8 
9 I* Clear from cursor to end of line, the cursor isn't moved. The main 
10 
11 
12 
13 
14 
15 
16 * reason that this is included here is because you have to call it after 
* printing every newline in order to compensate for a bug in the real 
* curses. This bug has been corrected in my curses, so you don't have to 
* use this routine if you're not interested in portability. 
*I 
clr_region( win->x_org + 
win->y_org + 
win->attrib win->col win->x_org + (win->x_size- 1), 
win->row , win->y_org + win->row, 
) ; 
794 
Listing A.Sl. werase.c- Erase Entire Window 
1 #include "cur.h" 
2 
3 werase ( win ) 
4 WINDOW *win; 
5 { Support Functions-Appendix A 
6 clr_region( win->x_org, win->x_org + (win->x_size- 1), 
7 win->y_org, win->y_org + (win->y_size- 1), 
8 win->attrib ) ; 
9 
10 cmove( win->y_org, win->x_org ); 
11 win->row 0; 
12 win->col = 0; 
13 
Listing A.82. winch.c- Move Window-Relative Cursor and Read Character 
1 #include "cur.h" 
2 
3 
4 
5 
6 
7 int 
WINDOW 
{ 
int winch ( win 
*win; 
y, x, c; 
8 curpos ( &y, &x ) ; 
9 cmove( win->y_org + win->row, win->x_org + win->co1 ); 
10 c = inchar () ; 
11 cmove( y, x ); 
12 return c; 
13 
Listing A.83. wincreat.c- Create a Window 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 linclude "cur.h" 
linclude <tools/box.h> 
/*--------------------------------------------------------
* Window creation functions. 
* Standard Functions: 
* 
* 
* 
* WINDOW *newwin( lines, cols, begin_y, begin_x 
creates a window 
* Nonstandard Functions: 
* * save() 
* nosave () 
* 
* boxed() 
* unboxed() Area under all new windows is saved (default) 
Area under all new windows is not saved 
Window is boxed automatically. 
Window is not boxed (default) 
* def_ground(f,b) Set default foreground color to f, and background color 
to b. * *--------------------------------------------------------
*I 
Section A.11.3 -Curses-Implementation 
Listing A.83. continued ... 
PRIVATE int Save 
PRIVATE int Box 1; 
0; 
NORMAL; I* Save image when window created 
I* Windows are boxed 
PRIVATE int Attrib I* Default character attribute byte 
void save 
void no save 
void boxed 
void unboxed () 
() 
() 
() Save 1; 
Save 0; 
Box 1; 
Box 0; 
void def_ground( f, b ) Attrib = (f & Ox7f) I ( (b & Ox7f) « 4); ) 
1*--------------------------------------------------------*l 
WINDOW *newwin( lines, cols, begin_y, begin_x ) 
int 
int 
int 
int co1s; 
lines; 
begin_y; 
begin_x; 
WINDOW 
if( !(win 
{ I* Horizontal size (including border) 
I* Vertical size (including border) 
I* X coordinate of upper-left corner 
I* Y coordinate of upper-left corner 
*win; 
(WINDOW*) malloc( sizeof(WINDOW) )) *I 
*I 
*I 
*I 
fprintf(stderr,"Internal error (newwin): Out of memory\n"); 
exit(1); 
if( cols > 80 
{ 
cols 80; 
begin_ X = 0; 
else if( begin_x + cols > 80 ) 
begin_x = 80 -cols; 
if( lines > 25 ) 
{ 
lines 25; 
begin_y 0; 
else if( begin_y + lines > 25 ) 
begin_x 25 -cols; 
begin_x 
begin_y 
cols 
lines 
0 
0 
0 
1 
0 
0 
Attrib *I 
*I 
*I 795 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 win->x_org 
win->y_org 
win->x size 
win->y_size 
win->row 
win->col 
win->scroll ok 
win->wrap_ok 
win->boxed 
win->hidden 
win->attrib 
win->image !Save ? NULL savescr( begin_x, begin_x + (cols -1) 
begin_y, begin_y + (lines- 1) ); 
werase(win); 
.... 
796 Support Functions-Appendix A 
Listing A.83. continued ... 
82 
83 
84 
85 
86 
87 
88 
89 
90 if( 
{ Box ) 
box( win, VERT, 
win->boxed 
win->x size -win->y_size 
win->x _org += 
win->y_org += I* 
HORIZ ) ; I* 
1; 
2; I* 
2; I* 
1; I* 
1; Must be done last *I 
Box it first *I 
Then reduce window size *I 
so that the box won't *I 
be overwritten. *I 
91 cmove( win->y_org, win->x_org ); 
92 
93 return win; 
94 
Listing A.84. winio.c- Miscellaneous Window 1/0 Functions 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 #include "cur.h" 
1*--------------------------------------------------------
* WINIO.C Lowest level I/0 routines: 
* waddch (win, c) wgetch (win) 
* echo () noecho () 
* nl () nonl () 
* crmode() nocrmode() *--------------------------------------------------------
*I 
I* Echo enabled *I PRIVATE int Echo 
PRIVATE int Crmode 
PRIVATE int N1 1; 
0; 
1; I* 
I* 
I* If 1, use buffered input *I 
echo () 
noecho () 
n1 () 
non1 () 
crmode () 
{ Echo 
Echo 
N1 
N1 
Crmode 1; 
nocrmode () 
{ 
Crmode 0; 1; 
0; 
1; 
0; If 1, map \r to \n on input *I 
and map both to \n\r on output *I 
1*--------------------------------------------------------*l 
static 
WINDOW 
char 
{ char 
*win; 
*buf; *getbuf(win, buf) 
I* Get a buffer interactively. ·H is a destructive backspace. This routine 
*is mildly recursive (it's called from wgetch() when Crmode is false. 
* The newline is put into the buffer. Returns it's second argument. 
*I 
.... 
Section A.11.3 -Curses-Implementation 
Listing A.84. continued ... 
register int c; 
char *sbuf buf; 
Crmode = 1; 
while( (c = wgetch(win)) != '\n' && c != '\r') 
{ 
switch( c ) 
{ 
case '\b': if( --buf >= sbuf 
default: 
*buf++ = c 
*buf '\0'; 
Crmode 0 
return sbuf wprintw( win, "\b" ); 
else 
{ 
wprintw ( win, ) ; 
putchar('\007'); 
buf = sbuf; 
break; 
*buf++ 
break; c; 
/* Add line terminator (\n or \r) */ 
/*--------------------------------------------------------*/ 
int wgetch( win ) 
WINDOW *win; 
{ 
/* Get a character from DOS without echoing. We need to do this in order 
*to support (echo/noecho). We'll also do noncrmode input buffering here. 
* Maximum input line length is 132 columns. 
* * In nocrmode(), DOS functions are used to get a line and all the normal 
* command-line editing functions are available. Since there's no way to 
* turn off echo in this case, characters are echoed to the screen 
*regardless of the status of echo(). In order to retain control of the 
*window, input fetched for wgetch() is always done in crmode, even if 797 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 * Crmode isn't set. If nl() mode is enabled, carriage return (Enter, -M) 
*and linefeed (-J) are both mapped to '\n', otherwise they are not mapped. 
* * Characters are returned in an int. The high byte is 0 for normal 
* characters. Extended characters (like the function keys) are returned 
* with the high byte set to Oxff and the character code in the low byte. 
* Extended characters are not echoed. 
*I 
static unsigned char buf[ 133 
static unsigned char *p 
static 
register 
if ( !Crmode 
{ int 
int numchars 
c; { 0 } ; 
buf; 
-1; 
.... 
798 Support Functions-Appendix A 
Listing A.84. continued ... 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 else if( ! *p 
p = getbuf( win, buf ); 
return( Nl && *p == '\r' ) ? '\n' *p++ 
if( (c = bdos(8,0,0) & Oxff) 
return EOF ; 
else if( !c ) 
else 
{ c = -oxff 1 bdos(8,0,0) 
if( c == '\r' && Nl ) 
c = '\n' 
if( Echo ) 
waddch( win, c); 
return c; (' Z' -' @') ) /* Ctrl-Z */ 
/* Extended char */ 
!*--------------------------------------------------------*/ 
int 
WINDOW waddch( win, c ) 
*win; 
int 
{ 
I /* 
* 
* 
* 
* 
* 
* 
* 
* * * 
* 
* 
* * 
* * 
* 
* 
* 
* 
* 
* 
* c; 
Print a character to an active (not hidden) window: 
The following are handled specially: 
\n Clear the line from the current cursor position to the right edge 
of the window. Then: 
if nl () is active: 
go to the left edge of the next line 
else 
go to the current column on the next line 
In addition, if scrolling is enabled, the window scrolls if you're 
on the bottom line. 
\t is expanded into an 8-space field. If the tab goes past the right 
edge of the window, the cursor wraps to the next line. 
\r gets you to the beginning of the current line. 
\b backs up one space but may not back up past the left edge of the 
window. Nondestructive. The curses documentation doesn't say that 
\b is handled explicitly but it does indeed work. 
ESC This is not standard curses but is useful. It is valid only if 
DOESC was true during the compile. All characters between an ASCII 
ESC and an alphabetic character are sent to the output but are other 
wise ignored. This let's you send escape sequences directly to the 
terminal if you like. I'm assuming here that you won't change 
windows in the middle of an escape sequence. 
* Return ERR if the character would have caused the window to scroll 
* illegally, or if you attempt to write to a hidden window. 
*I 
static int 
int saw esc 
rval 0; 
OK; 
.... 
Section A.ll.3 -Curses-Implementation 
Listing A.84. continued ... 
!59 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 if( win->hidden 
return ERR; 
cmove(win->y_org + win->row, win->x_org + win->col); 
#ifdef DOESC 
if( saw esc 
{ 
else 
#endif 
( if( isalpha( c ) ) 
saw_esc = 0; 
outc(c, win->attrib ) ; 
switch( c ) 
{ 
#ifdef DOESC 
#endif case '\033': if( saw_esc ) 
saw esc = 0; 
else 
{ 
saw_esc = 1; 
outc('\033', win->attrib ); 
break; 
case '\b': if( win->col > 0 ) 
{ 
outc( '\b', win->attrib ) ; 
--( win->col ); 
break; 
case '\t': do { 
waddch( win, ' ' ); 
} while( win->col% 8 ); 
break; 
case '\r': win->col = 0; 
default: cmove(win->y_org + win->row, win->x_org); 
break; 
if( (win->col + 1) < win->x size 
{ 
/* If you're not at the right edge of the window, */ 
/* print the character and advance. */ 
++win->col; 
outc(c, win->attrib ) ; 
break; 
replace (c); 
if( !win->wrap_ok 
break; /* At right edge, don't advance */ 
/* otherwise wrap around by falling through to newline */ 799 
... 
800 Support Functions-Appendix A 
Listing A.84. continued ••• 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 233 case '\n': 
return rva1; if ( c == '\n' ) 
wc1rtoeo1( win); 
if( N1 ) 
win->co1 = 0; /* Don't erase character at far */ 
/* right of the screen. */ 
if( ++(win->row) >= win->y_size 
{ 
rva1 = wscro11( win, 1 ); 
--( win->row ); 
cmove( win->y_org + win->row, win->x_org + win->co1); 
break; 
Listing A.85. wmove.c- Move Window-Relative Cursor 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 #include "cur.h" 
wmove( win, y, x ) 
WINDOW *win; 
{ 
/* Go to window-relative position. You can't go outside the window. */ 
cmove( win->y_org + (win->row 
win->x_org + (win->co1 min(y,win->y_size-1)) 
min(x,win->x_size-1)) ); 
Listing A.86. wprintw.c- Formated Print to Window 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 #include "cur.h" 
PRIVATE int Errcode OK; 
PRIVATE wputc(c, win) 
int c; 
WINDOW *win; 
{ 
Errcode I= waddch( win, c); 
wprintw( win, 
WINDOW *win; 
char *fmt; fmt, ... ) 
{ 
va_1ist args; 
va_start( args, fmt ); 
Errcode = OK; 
prnt( wputc, win, fmt, args ); 
va_end( args ); 
return Errcode; 
Section A.11.3 -Curses-Implementation 
Listing A.86. continued ... 
23 
24 
25 printw ( fmt, ... 
26 char *fmt; 
27 { 
28 va_1ist args; 
29 va_start( args, fmt ); 
30 
31 Errcode = OK; 
32 prnt( wputc, stdscr, fmt, args ); 
33 va_end( args ); 
34 return Errcode; 
35 
Listing A.87. wscroll.c- Scroll Window 
1 #include "cur.h" 
2 
3 /*----------------------------------------------------------
4 * Scroll the window if scrolling is enabled. Return 1 if we scrolled. (I'm 
5 * not sure if the UNIX function returns 1 on a scroll but it's convenient to 
6 * do it here. Don't assume anything about the return value if you're porting 
7 *to UNIX. Wscroll() is not a curses function. It lets you specify a scroll 
8 *amount and direction (scroll down by -amt if amt is negative); scroll() 
9 *is a macro that evaluates to a wscroll call with an amt of 1. Note that the 
10 *UNIX curses gets very confused when you scroll explicitly (using scroll()). 801 
11 * In particular, it doesn't clear the bottom line after a scroll but it thinks 
12 * that it has. Therefore, when you try to clear the bottom line, it thinks that 
13 *there's nothing there to clear and ignores your wclrtoeol() commands. Same 
14 * thing happens when you try to print spaces to the bottom line; it thinks 
15 * that spaces are already there and does nothing. You have to fill the bottom 
16 * line with non-space characters of some sort, and then erase it. 
17 */ 
18 
19 wscro11(win, amt) 
20 WINDOW *win; 
21 { 
22 if( win->scro11_ok ) 
23 doscro11( win->x org, win->x_org + (win->x_size-1), 
24 win->y_org, win->y_org + (win->y_size-1), amt, win->attrib ); 
25 
26 return win->scro11 ok 
27 
Passing by value. 
Passing by reference. B 
Notes on Pascal 
Compilers 
Though the material covered in Chapter Six applies to most compilers, languages 
such as Pascal, which support nested subroutine declarations, arguments passed by refer­
ence, and so forth, have their own set of problems. 
8.1 Subroutine Arguments 
The first issue is differentiating between arguments passed by value and arguments 
passed by reference. With the exception of arrays, all arguments in C are passed by 
value-the argument's value (the contents of a variable, for example) is passed to the 
subroutine rather than the argument itself. Pascal doesn't differentiate between arrays 
and other types, however. Unless you tell the compiler to do otherwise, everything is 
passed by value, so the entire array must be copied onto the stack as part of the subrou­
tine call. Similarly, records must be copied to the stack to pass them to a subroutine (as 
must structures in ANSI C). 
In a call by reference, the called subroutine can modify the contents of a variable 
local to the calling subroutine. A reference to the variable is passed, not its contents. In 
C, you'd do this by passing a pointer to the variable, and this approach works in Pascal as 
well, except that the compiler takes care of the details. If a subroutine argument is 
declared using the var keyword, then the address of the object is passed to the subrou­
tine. The subroutine itself must access that object indirectly through the pointer. 
An alternative approach is not practical in most languages, but should be mentioned 
primarily so that you don't use it. You can pass all arguments to the subroutine by value, 
just as if they were arguments to a C subroutine. Rather than discarding the arguments 
after the subroutine returns, however, you can pop their modified values from the stack 
back into the original variables. This approach has the advantage of simplifying the 
called subroutine's life considerably because it doesn't have to keep track of the extra 
level of indirection. The obvious disadvantage is that large objects, such as arrays, 
require a lot of stack space if passed by value. A less obvious, but more serious, disad­
vantage is illustrated by the following subroutine: 
802 
Section 8.1-Subroutine Arguments 
function tweedle( var dum: integer; var dee: integer ) : integer; 
begin 
dum = 1; 
return dum + dee; 
end 
tweedle () 's return value is undefined when a copy-in/copy-out strategy is used and 
the arguments are identical, as follows: 
var 
arg: integer; 
result: integer; 
begin 
arg := 100; 
result := tweedle( arg, arg ); 
end 
The assignment dum=1 should modify both dum and dee and the function should return 
2. If the arguments are copied onto the stack, however, dum alone is modified, so 101 is 
returned. The other problem is the undefined order of evaluation in the arguments. 
There~s no way to tell which of the two arguments will be popped first when the subrou­
tine returns. If the left argument, which corresponds to dum, is popped first, then arg is 
set to I 00; otherwise, arg is set to I. 
8.2 Return Values 
The next issue is a function's return value. Aggregate objects, such as arrays and 
records, can't be returned in registers because they're too big. The usual approach is to 
allocate an area of static memory using malloc () or some similar memory allocator, 
copy the aggregate object into this memory, and return a pointer to the region in a regis­
ter. You can also reserve a fixed region of static memory for this purpose-all functions 
copy the aggregate object to the same fixed region of memory. A pointer doesn't have to 
be returned in this case because everybody knows where the returned object can be 
found. On the other hand, the size of the fixed region will limit the size of the returned 
object. 
8.3 Stack Frames 
The next issue is the stack frame. Pascal supports nested subroutine definitions. A 
child subroutine (declared inside the parent subroutine) must be able to access all vari­
ables that are local to the parent in addition to its own local variables. In general, all 
variables declared at more outer scoping levels must be accessible to the inner subrou­
tine. The subroutines in Figure B. I illustrate the problems. clio can be accessed from 
inside all three subroutines. Other local variables can be accessed only from within the 
subroutines where they are declared, however. Similarly, calliope can't access terp­
sichore or melpomene. The situation is complicated, somewhat, by erato contain­
ing a recursive call to itself. 
The stack, when the recursive call to erato is active, is shown in Figure B.2. There 
is one major difference between these stack frames and C stack frames: the introduction 803 
Returning aggregate ob­
jects. 
of a second pointer called the static link. The dynamic link is the old frame pointer, just Static and dynamic links. 
as in C. The static link points, not at the previously active subroutine, but at the parent 
subroutine in the nesting sequence-in the declaration. Since erato and thalia are 
both nested inside calliope, their static links point at calliope's stack frame. You 
can chase down the static links to access the local variables in the outer routine's 
804 Notes on Pascal Compilers-Appendix B 
Figure B.l. Pascal Nested Subroutines 
procedure calliope( polyhymnia: integer); 
var 
clio: integer; 
begin 
procedure erato( 
var 
terpsichore: 
begin ... 
erato(3); 
end 
procedure thalia ( 
var urania: integer ) ; 
integer; 
euterpe: integer 
melpomene: integer; 
begin ... 
erato(2); 
end 
thalia(l); 
end ) ; 
Figure B.2. Pascal Stack Frames 
terpsichore 
( ~ dynamic link ~fp 
return address 
static link 
> 3 urania 
terpsichore 
~ dynamic link 
return address 
static link / > 2 urania 
melpomene 
~ dynamic link 
return address 
static link / 
~ 1 euterpe 
clio 
dynamic link 
return address 
static link 
polyhymnia r 
erato 
erato 
thalia 
callio l pe 
Section 8.3-Stack Frames 
stack frame. For example, clio can be accessed from erato with the following C-code: 
rO.pp = WP(fp + 4); 
x = W(rO.pp- 8); /* rO = static link */ 
/* x = clio */ 
You can access polyhymnia from erato with: 
rO.pp = WP(fp + 4); /* rO = static link */ 
x = W(rO.pp + 8); /* x = clio *I 
Though it's not shown this way in the current example, it's convenient for the frame 
pointer to point at the static, rather than the dynamic link to make the foregoing indirec­
tion a little easier to do. The static links can be set up as follows: Assign to each sub­
routine a declaration level, equivalent to the nesting level at which the subroutine is 
declared. Here, calliope is a level 0 subroutine, erato is a level I subroutine, and so 
forth. Then: 
• If a subroutine calls a subroutine at the same level, the static link of the called 
subroutine is identical to the static link of the calling subroutine. 
• If a subroutine at level N calls a subroutine at level N+l, the static link of the 
called subroutine points at the static link of the calling subroutine. 
• If a subroutine calls a subroutine at a lower (more outer) level, use the following 
algorithm: 
i = the diffurence in levels between the two subroutines; 
p =the static link in the calling subroutine's stack frame; 
while( --i >= 0 ) 
p = *p; 
the static link of the called subroutine = p; 
Note that the difference in levels (i) can be figured at compile time, but you must chase 
down the static links at run time. Since the static link must be initialized by the calling 
subroutine (the called subroutine doesn't know who called it), it is placed beneath the 
return address in the stack frame. 
This organization can cause problems with qoto statements. It's possible for a qoto 
statement in erato to reference a label in calliope, for example. You can't just jump 
to the label in this case because the stack will be left with inactive stack frames on it, so 
you must treat the qoto something like a return, adjusting the frame and stack 
pointers before making the jump-you must simulate return statements until the stack 
frame for the subroutine that contains the target label is active. 
In order to make this simulation easier, Pascal delegates the responsibility of clean­
ing up the stack somewhat differently than C: it's the responsibility of the called func­
tion to delete the entire stack frame-both local variables and arguments-before return­
ing. As an added advantage, the Pascal calling conventions tend to make somewhat 
smaller programs because the compiler doesn't have to generate an add-constant-to­
stack-pointer directive after every subroutine call-programs usually have more subrou­
tine calls than definitions. Finally, as a matter of convention rather than necessity, argu­
ments to Pascal subroutines are pushed by the calling function in forward rather than 
reverse order. The leftmost argument is pushed first. This convention makes it difficult 
to write a Pascal function that takes a variable number of arguments unless the compiler 
provides some run-time mechanism for finding and identifying the type of the leftmost 
argument. 805 
The Pascal goto. 
Called subroutine cleans 
up stack. Less code is 
generated. 
Arguments pushed in for­
ward order. 
c 
A Grammar for C 
This appendix summarizes the grammar used in Chapter Six. The organization here 
is diffurent from that in Chapter Six in that it's more hierarchical. Line numbers in the 
following listing don't match the ones in Chapter 6. End-of-production actions are not 
shown, though imbedded actions are indicated with a { } . I've replaced the semicolon 
required at the end of a yacc or occs production with a blank line. The following abbre­
viations are used in the nonterminal names: 
abs abstract 
arg(s) argument(s) 
const constant 
decl declarator 
def definition 
expr expression 
ext external 
opt optional 
par am parameter 
struct structure 
Listing C.l. A Summary of the C Grammar in Chapter Six. 
I %union { I* The value stack. *I 
2 char *p_ char; 
3 symbol *p_sym; 
4 link *p_ link; 
5 structdef *p_ sdef; 
6 specifier *p_spec; 
7 value *p_val; 
8 int num; I* Make short if sizeof(int) > sizeof(int*). *I 
9 int ascii; 
10 
II 
12 %term STRING I* String constant. *I 
13 %term ICON I* Integer or long constant including '\t', etc. *I 
14 %term FCON I* Floating-point constant. *I 
806 
A Grammar for C -Appendix C 
Listing C.l. continued ... 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 %term TYPE I* int char long float double signed unsigned short *I 
I* canst volatile void *I 
%term 
%term <ascii> STRUCT 
ENUM I* struct union *I 
I* enum *I 
%term <p_sym> TTYPE 
%nonassoc <ascii> CLASS 
%nonassoc <p_sym> NAME 
%nonassoc ELSE 
%term RETURN GOTO 
%term IF ELSE 
%term SWITCH CASE DEFAULT 
%term BREAK CONTINUE 
%term WHILE DO FOR 
%term LC RC 
%term SEMI 
%term ELLIPSIS 
%left COMMA 
%right EQUAL <ascii> ASSIGNOP 
%right QUEST COLON 
%left OROR 
%left AND AND 
%left OR 
%left XOR 
%left AND 
%left <ascii> EQUOP 
%left <ascii> RELOP 
%left <ascii> SHIFTOP 
%left PLUS MINUS 
%left STAR <ascii> DIVOP 
%right SIZEOF <ascii> UNOP IN COP 
%left LB RB LP RP <ascii> STRUCTOP I* type created with typedef *I 
I* auto extern register static typedef *I 
I* { } *I 
I* ; *I 
I* ... *I 
I* , *I 
I* = *= /= %= += -= <<= >>= &= I= . = *I 
I* ? : *I 
I* II *I 
I* && *I 
I* I *I 
I* . *I 
I* & *I 
I* --!= *I 
I* <= >= < > *I 
I* >> << *I 
I* + - *I 
I* * I % *I 
I* sizeof ! - ++ --*I 
I* [ 1 ( ) -> *I 807 
High-Level Definitions 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 program: ext_def_list { clean_up(); } 
ext def li'st 
ext def : ext def list ext def - - -I I* epsilon *I 
: opt_specifiers ext decl_list {} SEMI 
I opt_specifiers {} SEMI 
I opt_specifiers funct_decl {} def_list {} compound_stmt 
ext decl list 
: ext decl -I ext decl list COMMA ext decl 
ext decl: var decl - -I var decl EQUAL initializer 
I funct decl 
66 opt_specifiers 
67 : CLASS TTYPE 
68 I TTYPE 
69 I specifiers 
70 I I* empty *I Specifiers 
.... 
808 
Listing C. I. continued ... 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 specifiers 
: type_or_class 
I specifiers type_or_class 
type : type_specifier 
I type type_specifier 
type_or_class 
: type_specifier 
I CLASS 
type_specifier 
: TYPE 
I enum_specifier 
I struct_specifier 
enum_specifier 
: enum name opt_enum list 
I enum LC enumerator list RC 
opt_enum_list 
: LC enumerator list RC -I /* empty */ 
enum : ENUM 
enumerator list 
: enumerator 
I enumerator_list COMMA enumerator 
enumerator 
: name 
1 name EQUAL const_expr 
var decl: new name -I 
I 
I 
I 
I 
I var decl LP RP 
var decl LP var list RP 
var decl LB RB 
var decl LB const_expr RB 
STAR var decl -LP var decl RP 
new name: NAME 
name : NAME 
funct decl -: STAR funct decl -I funct_decl LB RB 
I funct_decl LB const_expr RB 
I LP funct decl RP 
I 
I 
I 
I funct decl LP RP -new name LP RP -new_name LP {} name_list {} RP 
new name LP {} var list {} RP %prec COMMA 
%prec UNOP A Grammar for C-Appendix C 
Enumerated Constants 
Variable Declarators 
Function Declarators 
A Grammar for C-Appendix C 
Listing C.l. continued ... 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 name list 
: new name 
I name list COMMA new name 
var_list: param_declaration 
1 var_list COMMA param_declaration 
param_declaration 
: type var_decl 
I abstract_decl 
I ELLIPSIS 
abstract decl -: type abs_decl 
I TTYPE abs decl 
abs decl: -I* epsilon *I 
I LP abs decl RP -I STAR abs decl -I abs decl LB -LP 
I abs decl LB canst -I LP abs decl RP RP 
RB 
_expr RB 
146 struct_specifier 
147 : STRUCT opt_tag LC def_list RC 
148 I STRUCT tag 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 opt _tag : tag 
I I* empty *I 
tag : NAME 
def list: def list def - -
I I* epsilon *I 
def : specifiers decl_list {} SEMI 
I specifiers SEMI 
decl list 
: decl 
I decl list COMMA decl 
decl : funct decl -I var decl 
I var decl EQUAL initializer 
I var decl COLON canst _expr 
I COLON canst expr -
initializer 
: expr 
1 LC initializer_list RC 
initializer list 
: initializer 
1 initializer list COMMA initializer 809 
Abstract Declarators 
Structures 
Local Variables and Function Arguments 
%prec COMMA 
%prec COMMA 
%prec COMMA 
810 
Listing C.l. continued ... 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 198 
199 
200 
201 
202 
203 
204 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 223 
224 
225 
226 
227 228 
229 compound_stmt 
: LC {} local defs stmt list RC {} 
local defs -: def list 
stmt list 
: stmt list statement 
I I* epsilon *I 
statement 
expr SEMI 
compound_stmt 
RETURN SEMI 
RETURN expr SEMI 
SEMI 
GOTO target SEMI 
target COLON {} statement 
SWITCH LP expr RP {} compound_stmt 
CASE const_expr COLON 
DEFAULT COLON 
IF LP test RP statement 
IF LP test RP statement ELSE {} statement 
WHILE LP test RP {} statement 
FOR LP opt_expr SEMI test SEMI {} opt_expr 
DO {} statement WHILE {} LP test RP SEMI 
BREAK SEMI 
CONTINUE SEMI 
test : {} expr 
I I* empty *I 
target : NAME 
opt_expr: expr 
I I* epsilon *I 
const _expr 
: expr %prec COMMA 
expr : expr COMMA {} non comma _expr -I non_comma_expr 
non comma _expr -: non comma _expr QUEST {} non comma _expr COLON - -
I non_comma_expr ASSIGNOP non -comma _expr 
I non -comma expr EQUAL non comma _expr -
I or_expr 
or_expr : or list 
or list : or list OROR {} and_expr - -I and_expr 
230 and_expr: and_list 
231 and_list: and_list ANDAND {}binary 
232 I binary 
233 A Grammar for C-Appendix C 
Statements 
RP { } statement 
Expressions 
{} non_comma_expr 
.... 
A Grammar for C-Appendix C 
Listing C. I. continued ... 
234 binary binary RELOP binary 
235 binary EQUOP binary 
236 binary STAR binary 
237 binary DIVOP binary 
238 binary SHIFTOP binary 
239 binary AND binary 
240 binary XOR binary 
241 binary OR binary 
242 binary PLUS binary 
243 binary MINUS binary 
244 unary 
245 
246 unary LP expr RP 
247 FCON 
248 ICON 
249 NAME 
250 string_ canst %prec COMMA 
251 SIZEOF LP string_const RP 
252 SIZEOF LP expr RP 
253 SIZEOF LP abstract decl RP 
254 LP abstract decl RP unary 
255 MINUS unary 
256 UNOP unary 
257 unary IN COP 
258 IN COP unary 
259 AND unary 
260 STAR unary 
261 unary LB expr RB 
262 unary STRUCTOP NAME 
263 unary LP args RP 
264 unary LP RP 
265 
266 string_const 
267 STRING 
268 string_const STRING 
269 
270 args non_comma_expr 
271 non comma_expr COMMA args %prec SIZEOF 
%prec SIZEOF 
%prec SIZEOF 
%prec UNOP 
%prec UNOP 
%prec UNOP 
%prec UNOP 
%prec UNOP 
%prec STRUCTOP 
%prec COMMA 811 
D 
This appendix is a user's manual for LEX, 1 a program that translates an input file 
made up of intermixed regular expressions and C source code into a lexical analyzer. 
Appendix E contains a user's manual for occs, a compiler-compiler modeled after the 
UNIX yacc utility that translates an augmented, attributed grammar into a bottom-up 
parser. 
This (and the next) appendix describe IJ'X and occs in depth. IJ'X and occs are both 
very similar to the equivalent UNIX utilities, and you can use the UNIX lex and yacc rather 
than IJ'X and occs to implement the compiler in Chapter Six, though you should read the 
UNIX documentation for these programs rather than this (and the next) appendix if you 
do. Footnotes are used to point out differences between IJ'X and occs and their UNIX 
counterparts-you can ignore them if you're not interested in using the UNIX programs. 
In general, you should have little difficulty going from one system to the other. 
0.1 Using LEX and Occs Together 
IJ'X and occs work together in an integrated fashion, though LEX can be used without 
occs for many noncompiler applications. Both utilities can be viewed as C preproces­
sors. IJ'X takes as input files made up of interspersed IJ'X directives and C source code 
and outputs a table-driven lexical analyzer. Occs outputs a parser. The interaction 
between IJ'X and occs is pictured in Figure D.l. 
The IJ'X output file is called lexyy.c, and this file contains a tokenizer function called 
yylex ( ) .2 This function reads characters from the input stream, returning a token (and 
the associated lexeme) on every call. It is called by the occs-generated parser every time 
a token is required. Similarly, occs creates a file called yyout.c, which includes a parser 
subroutine called yyparse () .3 Somewhere in your program, there must be a call to 
I. I'm calling it EX to differentiate it from the UNIX program of the same name, which will be called lex 
throughout this manual. You can pronounce it as "leek" if you want to, but I wouldn't advise it. 
2. UNIX lex creates a file called lex.yy.c; the lexical analyzer function is still called yylex () , however. 
3. The yacc equivalent to yyout.c is y.tab.c; yyparse () is used by both programs. 
812 
Section D.l-Using I.!'X and Occs Together 
Figure D.l. Creating a Compiler with LEX and occs 
language.Iex 
(scanner 
description) 
(lex. y.c) 
lexyy.c 
yylex () 
(scanner) 
~-~th~r-- ~ 
: libraries ~ - - - - -
~ ~ _o~j~~t~ ~ ,.----"--'.L.e"t"'iab.h) 
yyout.h 
(token 
definitions) 
(cc) 
yyparse ( ) to start up the parser. language.y 
(parser 
description) (y.output) ,..------, 
1 yyout.doc 1 
I I 
r ~ (State-machine 1 
,--...L.---, -v : 1 description) 
(yacc) 1 1 ---" 
-4 
,..------, 
-s : 1 yyout.sym 1 
I I 
( .tab.c) L ~ (symb~l ~a~lc:_) ~ ,.----"-.uc!::; 
yyout.c 
yyparse () 
(parser) 
(UN/Xfile names 
are in italics.) 
~ - - - - - - ~ (lib/.lib, libl.a) 
l.lib 
The /.lib library contains various subroutines that are used by the lexical analyzer 
and should be linked into the final program. 4 Note that /.lib includes a main ( ) subrou­
tine which loops, calling yylex ( ) repetitively until yylex ( ) returns zero. You can, 
of course, provide your own main ( ) , and the one in the library will not be linked. [You 
must do this in the final compiler or else the parser will never be called. It's a common 
mistake to forget to provide amain () .] 
There are several steps in creating a workable compiler using LEX and occs. The first 
step is to write a lexical-analyzer specification as a IJX input file, and to define a gram­
mar in a way acceptable to occs (all this is discussed below and in Appendix E). You 
then run the input files through the appropriate programs, generating several .c and .h 
files. 
I.!'X creates lexyy.c, as was discussed earlier. Occs actually creates two source files: 
yyout.c contains source code for the parser and tables; yyout.h contains #defines for all 
the tokens. 5 
4. The UNIX programs use lusrllibllibl.lib (alternately named /usr!libllibl.a in some systems). Incorporate this 
library into your program with a cc files ... -11 directive when you link. 
5. yacc calls the file y.tab.h and generates the file only if you specify-don the command line. Occs always 
generates yyout.h, however. 813 
814 WX-Appendix D 
One of these token values (and only these values) must be returned by your lexical 
analyzer for each input symbol. 6 The special symbol_ EOI _,always #defined as zero 
in yyout.h, is returned by the I.!'X-generated analyzer at end of input. You should not 
return this value yourself as a token value, or occs (and yacc) will get confused.7 A typi­
cal development cycle with Microsoft C looks something like this:8 
vi compiler.lex 
vi compiler.y 
lex compiler.lex 
occs -vD compiler.y 
cl -c lexyy.c 
cl -c yyout.c Create I§X input specification. 
Create occs input specification. 
Create lexyy.c from I§X input specification. 
Create yyout.c and yyout.h from occs input specification. 
Compile everything and link. 
cl lexyy.obj yyout.obj -link l.lib 
The various files generated by I.!'X and occs are summarized in Table D.l. The 
yyout.h file is generally #included in the LEX input specification, so you shouldn''t 
compile lexyy.c until you've run occs. 
0.2 The LEX Input File: Organization 
The remainder of this appendix describes the lexical-analyzer generator, LEX. My 
implementation of LEX is a proper subset of the similarly named UNIX utility.9 The input 
file is divided into three parts, separated from one another by %% directives: 
definitions 
%% 
rules 
%% 
code 
The %% must be the leftmost two characters on the line. The definitions section con­
tains two things: macro definitions and user-supplied code. All code must be delimited 
6. yacc also lets you use literal characters as tokens. If you put a %tez:m '+'. into the yacc input file, you 
can return an ASCII '+' from the lexical analyzer. Occs doesn't support this mechanism. You'd have to 
put a %tez:m PLUS in the occs input file and a return PLUS; statement in the lexical analyzer. 
7. yacc doesn't define_ EOI _for you-it nonetheless treats 0 as an end-of-input marker. 
8. The UNIX development cycle looks like this: 
vi compiler.lex 
vi compiler.y 
lex compiler.lex 
yacc -vd compiler.y 
cc -c lex.yy.c 
cc -c y .tab.c 
cc -o compiler y.tab.o lex.yy.o -II 
9. For those of you who are familiar with the UNIX program, the following features are not supported by llX: 
• The I lookahead operator is not supported. 
• The %START directive and the <name> context mechanism are not supported. 
• The {N,M) operator (repeat the previous regular expression Nto M times) is not supported. 
• The REJECT mechanism is not supported (but yymore ( ) is). 
• The %8, %T, %C, and %R directives are not supported. Similarly, the internal-array-size modification 
directives %p, %n, %e, %a, %k, and %o) aren't supported. 
• The internal workings of the output lexical analyzer (especially the input mechanism) bear virtually no 
relation to the UNIX program. You won't be able to hack the llX output in the same ways that you're 
used to. 
Section 0.2-The IJ'X Input File: Organization 815 
Table D.l. LEX and Occs Output Files 
Generated OccsfLEX UNIX Command-line Description by name name Switches 
IJX/Iex lexyy.c lex.yy.c none needed C source code for lexical analyzer function, 
yylex (). 
yyout.c y.tab.c none needed c Source code for parser subroutine, 
yyparse () 
yyout.h y.tab.h occs: none needed #defines for the tokens. yacc: -d 
yyout.sym not available -s -S -D Symbol-table showing various internal 
values used by the parser, including produc-
tion numbers, TOKEN values, and so forth. 
This table is useful primarily for debugging. 
occs/yacc yyout.doc y.output occs: -v -V A human-readable description of the LALR 
yacc: -v state machine used by the parser. The file 
also contains copies of all the error and 
warning messages that are sent to the screen 
as the input is processed. It's useful for 
debugging the grammar. The -V version of 
the table holds LALR(l) lookaheads for all 
the items, and FIRST sets for all the nonter-
minals. The -v version contains lookaheads 
only for those items that trigger reductions, 
and does not contain FIRST sets. 
with % { and % } directives like this: 
%{ 
#include <stdio.h> 
extern int something; /* This code is passed to the output */ 
%} 
%% 
The percent sign must be the leftmost character on the line. 10 Code blocks in the 
definitions section should contain #includes, external definitions, global-variable 
definitions, and so forth. In general, everything that would go at the top of a C program 
should also go at the top of the LEX input file. 
Anything outside of a % { % } block is taken to be a macro definition. These consist of 
a name followed by white space (blanks or tabs), followed in tum by the macro's con­
tents. For example: 
I 0. UNIX lex supports directives like this: 
%{ #include <stdio.h> %) 
!!X requires you to use the following, however: 
%{ #include <stdio.h> %) 
816 
Comments. 
Whitespace. 
Metacharacters. ~.!'X-Appendix D 
digit 
hexdigit 
alpha [0-9] 
[0-9a-fA-f] 
[a-zA-Z] /* decimal digit */ 
/* hexadecimal digit */ 
/* alphabetic character */ 
Macro expansion is discussed further, below. C-style comments are permitted anywhere 
in the definitions section-they are ignored along with any preceding white space. C 
comments in a % { • • • % } block are passed to the output, however. 
Skipping the middle, rules, section for a moment, the third, code section is just 
passed to the output file verbatim. Generally, the initial definitions section should con­
tain only code that is used in the rules section; moreover, it should contain only variable 
definitions, extern statements, and the like. All other code, including the subroutines 
that are called from the rules section, should be defined in the last, code section. 
0.3 The LEX Rules Section 
The rules in the middle part of the LEX input specification have two components: a 
regular expression like the ones described both in Chapter Two and below, and C­
source-code fragments that are executed when input that matches the regular expression 
is found. The regular expressions must start in the leftmost column, and they are 
separated from the code by white space (spaces or tabs). This means that you can't put a 
literal space character or tab into a regular expression. Use the \ s or \ t escape 
sequence for this purpose. You can also use double quotes-a" "matches a space-but 
the escape sequences are preferable because you can see them. The code part of the rule 
may take up several lines, provided that the lines begin with white space. That is, all 
lines that start with white space are assumed to be part of the code associated with the 
previous regular expression. A possible rule section looks like this: 
%% 
lama printf("Priest\n"); 
llama printf("Beast \n"); 
lll+ama printf("Fire! \n"); 
%% 
which, when given the input: 
lama 
llama 
lllama 
recognizes the various kinds of lamas. 11 
0.3.1 LEX Regular Expressions /* A one-ell lama */ 
/* A two-ell llama */ 
/* A three-ell lllama, four */ 
/* alarmer, and so forth. */ 
The LEX regular-expression syntax is essentially the one described in Chapter Two. 
It is summarized below, along with discussions of LEX's peculiarities. Regular expres­
sions are formed of a combination of normal characters and "metacharacters", which 
have special meanings. The following characters are used as metacharacters-they are 
described in depth below: 
* + ? $ \ 
II. See [Nash]. 
Section 0.3.1-IJlX Regular Expressions 
Note that the term "newline" is used in a nonstandard way in the following 
definitions. A newline here, is either an ASCII carriage return or a linefeed character 
(' \r' or '\n' ). This usage is consistent with most MS-DOS applications because the 
input characters are read in binary, not translated mode, so all input lines are terminated 
with a \r\n pair. By recognizing either '\n' or '\r' as a newline, LEX-generated 
code work can work in the UNIX environment, in MS-DOS translated, and in MS-DOS binary 
modes as well. If you want strict UNIX compatibility, you can use the -u command line 
switch discussed below to redefine newline to be a single linefeed character. 
c A single character that is not used as a metacharacter forms a regular expres­
sion. The multiple-character sequences shown in Table D.2 also match single 
characters. These are known as escape sequences. Note that in MS-DOS, 
binary-mode input is used by LEX. This means that all lines are terminated 
with the two-character sequence \r\n. A \n matches the linefeed, but not the 
carriage return. It can be risky to test for an explicit \r or \n in the MS-DOS 
environment (but see ~ and$, below). Double quotes can also be used to take 
away the meaning of metacharacters: "*?" matches an asterisk followed by a 
question mark. 
Table 0.2. 1.9X Escape Sequences 
Escape Matches sequence 
\b backspace 
\f form feed 
\n linefeed (end of line character) 
\r carriage return 
\s space 
\t tab 
\e ASCII ESC character(' \033') 
\ddd number formed of three the octal digits ddd 817 
Newline, nonstandard 
definition. 
Matching normal charac­
ters, escape sequences. 
Recognized 
by UNIX 
yes 
yes yes yes 
yes 
yes 
no 
yes 
\xdd A number formed of the two hex digits dd. Two digits must be present-use no 
\ ~c 
cc 
ele 
(e) 
$ \c \x02 for small numbers. 
(backslash, followed by an up arrow, followed by a letter) matches a control char- no 
acter. This example matches Ctri-C. 
\ followed by anything else matches that character; so, \ . matches a dot, 
\ * matches an asterisk, and so forth. 
Two regular expressions concatenated form a regular expression. 
Two regular expressions separated by a vertical bar recognize either the 
expression to the left of the bar or the expression to the right of the bar. 
Parentheses are used for grouping. 
An up arrow anchors the pattern to beginning of line. If the first character in 
the expression is a ~, then the expression is recognized only if it is at the far 
left of a line. 
A dollar sign anchors the pattern to end of line. If the last character in the 
expression is a $, then the expression is recognized only if it is at the far right 
of a line. 
A period (pronounced dot) matches any character except the newline (' \r' or 
'\n' normally,' \n' if -u is specified). yes 
Concatenation. 
OR operator. 
Grouping. 
Beginning-of-line anchor. 
End-of-line anchor. 
Match any character. 
818 
Character classes. [. 0 .] ~.!'X-Appendix D 
Brackets match any of the characters enclosed in the brackets. If the first char­
acter following the bracket is an up arrow n. any character except the ones 
specified is matched. Only six characters have special meaning inside a char­
acter class: 
I Start of macro name 
I End of macro name 
] End of character class 
Range of characters 
Indicates negative character class 
Takes away special meaning of characters up to next quote mark 
\ Takes away special meaning of next character 
Use\],\-,\\, and so forth, to put these into a class. Since other metacharac­
ters such as *, ?, and + are not special here, the expression [ * ?+ J matches a 
star, question mark, or plus sign. Also, a negative character class doesn't 
match a newline character- [ A a-z J actually matches anything except a 
lower-case character or a newline. Use ( [ A a-z] 1 [ \ r \ n]) to match the new­
line, too. Note that a negative character class must match a character­
A [ A a-z] $ does not match an empty line. The line must have at least one 
character on it, but that character may not be a lower-case letter. 
Empty character classes. IJX supports two special character classes not supported by the UNIX lex. 
An empty character class ( [ J) matches all white space, with white space 
defined liberally as any character whose ASCII value is less than or equal to a 
space (all control characters and a space). An empty negative character class 
( [ A ] ) matches anything but white space. 
Closure operators. * + ? A regular expression followed by a * (pronounced star) matches that expres-
sion repeated zero or more times; a + matches one or more repetitions; a ? 
matches zero or one repetitions. 
Greedy algorithm. Note that LEX uses a greedy algorithm to match a pattern. It matches the long­
est possible string that can satisfy the regular expression. Consequently, 
something like . * is dangerous (it absorbs all the characters on the line). The 
expression (. 1 \n) * tries to absorb an entire input file, but will probably 
cause an input-buffer overflow. 
Macro expansion. 1 name 1 Braces are used to expand a macro name. (The 1 m,n I notation described in 
Chapter 2 is not supported by IJX.) The name must be part of a macro 
definition in the first of the input file. 
You can use the macros as an element of a regular expression by surround­
ing the name with curly braces. Given the earlier macro definitions: 
digit 
hexdigit 
alpha 
%% [0-9] 
[0-9a-fA-f] 
[a-zA-Z] /* decimal digit */ 
/* hexadecimal digit */ 
/* alphabetic character */ 
a hex number in C can be recognized with Ox{hexdigit}+. An 
alphanumeric character can be recognized with the following expression: 
({alpha} I {digit}) 
Macros nest, so you could do the following. 
digit [0-9] 
alpha [a-zA-Z] 
alnum ({alpha}l{digit}) 
You could do the same with: 
Section 0.3.1-U'X Regular Expressions 
digit 0-9 
alpha a-zA-Z 
alnum [{digit}{alpha}] 819 
The A and $ metacharacters work properly in all MS-DOS input modes, regardless of The A and $ metachar­
whether lines end with \r\n or a single \n. Note that the newline is not part of the lex-acters. 
erne, even though it must be present for the associated expression to be recognized. Use 
and\r\n to put the end of line characters into the lexeme. (The \r is not required in 
UNIX applications, in fact it's an error under UNIX.) Note that, unlike the vi editor A$ 
does not match a blank line. You'll have to use an explicit search such as \r\n\r\n to 
find empty lines. 
The operator precedence is summarized in the Table 0.3. All operators associate left Operator Precedence. 
to right. 
Table D.3. Regular-Expression Operator Precedence 
operator description level 
() parentheses for grouping I (highest) 
[ l character classes 2 
* + ? closure: 0 or more, I or more, 0 or I 3 
cc concatenation 4 
I OR 5 -$ anchors to beginning and end of line 6 (lowest) 
By default, input that doesn't match a regular expression is silently absorbed. You 
can cause an error message to be printed when bad input is encountered by putting the 
following into the definitions section: 12 
% { 
#define YYBADINP 
%} 
In general, it's a good idea to put one rule of the form 
at the very end of the rules section. This default rule matches all characters not recog­
nized by a previous expression, and does nothing as its action. Input that doesn't match 
a regular expression. 
When two conflicting regular expressions are found in the input file, the one that Conflicting regular ex­
comes first is recognized. The expression that matches the longest input string always pressions. 
takes precedence, however, regardless of the ordering of expressions in the file. Con-
sider the following input file: 
a. return DOO; 
aa+ return WHA; 
Given the input aa, 000 will be returned because a. comes first in the file. Given the 
input aaa, the second expression is active because the longer string is matched. 
12. UNIX lex behaves differently. It prints the unrecognized string to standard output and doesn't support 
YYBADINP. 
820 
Using local variables in 
actions. 
Subroutines for use in 
actions. 
Default main () . 
Current lexeme. 
Lexeme length. 
Input line number. 
Input a character to the 
current lexeme. I.PX-Appendix D 
0.3.2 The Code Part of the Rule 
The code portion of the rule can be any legal C-code. It ends up in the output as part 
of a switch statement, so be careful with breaks. yylex () does not return unless an 
explicit return statement is included in one of the actions associated with a regular 
expression. On the other hand, a legal C statement must be attached to every regular 
expression, even if that statement is only a single semicolon. 
The action code does not have to be surrounded with curly braces, but if you do so, 
you can use local variables in the code, as in: 
expression 
int i; 
The scope of the local variable is limited by the curly braces, as in normal C. Global 
variables must be defined in a % { ... %I block in the definitions section. 
If a vertical bar is used in place of an action, the action associated with the next rule 
is used. For example: 
Ox[0-9a-fA-F]+ 
0[0-7]+ 
[1-9] [0-9]* return( NUMERIC_CONSTANT ); 
causes the return statement to be executed if any of the three expressions are matched. 
Several subroutines, variables, and macros are available for use inside any of your 
actions (in either the rules or code section, but not in a % { ... %I block in the definitions 
section). The subroutines are all in /.lib, which must be linked to your program. You can 
provide your own versions of all of them, however, in which case the ones in the library 
are not linked. The macros definitions are all imbedded in the I.FX output file itself, and 
their definitions are discussed in depth in Chapter Two. I.FX supports the following sub­
routines and macros: 
void main() 
The short main ( ) subroutine shown in Listing D.l is provided in /.lib as a con­
venience in testing lex-generated recognizers. It just loops, calling yylex () 
until yylex () returns zero. It's linked automatically if you don't provide a 
main ( ) of your own. This default main ( ) can cause problems if you forget to 
put a main ( ) in an occs-generated compiler. In this case, main ( ) is fetched 
from the library, and the parser is never activated. 
char *yytext 
This variable points at the lexeme that matches the current regular expression. 
The string is ' \ 0' terminated. 
int yyleng 
The number of characters in yytext, excluding the final ' \0'. 
int yylineno 
The current input line number. If the lexeme spans multiple lines, it is the 
number of the last line of the lexeme. 
int input() 
Read (and return) the next input character-the one following the last character 
in the lexeme. The new character is added to the end of the lexeme (yytext) by 
Section 0.3.2-The Code Part of the Rule 
Listing D.l. yymain.c- The main ( ) Subroutine in /.lib 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 #include <stdlib.h> 
#include <tools/debug.h> 
#include <tools/l.h> 
void 
char 
int 
{ main( argc, argv 
**argv; 
argc; 
/* A default main module to test the lexical analyzer. 
*I 
if( argc == 2 ) 
ii_newfile( argv[l] ); 
while( yylex() ) 
exit( 0 ) ; 821 
LEX and yyleng is adjusted accordingly. Zero is returned at end of file, -I if the lexeme 
is too long. 13 
ECHO 
Print the current lexeme to a stream named yyout, which is initialized to 
stdout. This is just an alias for fprintf (yyout, "%s", yytext). Do not 
use this macro if you intend to use the occs interactive debugging environment 
described in Appendix E-it messes up the windows. 
void output(int c) 
Print c to the output stream. The FILE pointer used for this stream is called 
yyout and is initialized to stdout. You can change the file with fopen ( ) if 
you like. Do not use this function if you intend to use the occs interactive­
debugging environment described in Appendix E-it messes up the windows. 
void unput(int c) 
Pushes the indicated character back into the input stream. Note that c effectively 
overwrites yytext [yyleng-1) and then makes the Iexeme one character 
smaller. Both yyleng and yytext are modified; c will be read as the next input 
character. 14 
YYERROR(char *s) 
This macro is not supported by the UNIX lex. It is used to print internal error mes­
sages generated by the lexical analyzer itself. The default macro prints the string, 
s, to stderr. You will probably want to redefine this macro for occs-put the 
following into the IJX input file's definition section: 
13. UNIX lex doesn't return -1 and it doesn't modify the yytext or yyleng; it just returns the next input 
character. 
14. UNIX lex does not modify yytext oryyleng. It just pushes back the character. Echo current lexeme to 
the screen. 
Output a character. 
Push back one character. 
Print internal error mes­
sage. 
822 LEX-Appendix D 
%{ 
#define YYERROR(str) yyerror("%s\n", str); 
%} 
Push back multiple input void yyless (int n) 
characters. 
Initialize l!'X parser. Push n characters back into the input stream. Again, yytext and yyleng are 
adjusted to reflect the pushed back characters.15 You cannot push back more than 
yyleng characters. 
void yy_init_lex() 
This subroutine is called by yylex ( ) before it reads any input. You can use it to 
do any run-time initializations that are required before the lexical analyzer starts 
up. It's particularly handy if you want to initialize variables that are declared 
static in the definitions part of the IJX input file. You can define a 
yy _ ini t _lex () that does the initializations at the bottom of the input file, and 
this function is called automatically. The default routine, in /.lib, does nothing. 
It's in Listing D.2.16 
Listing 0.2. yyinitlx.c- Initialize LEX 
void yy_init_lex( ) {} /*Default initialization routine--does nothing. */ 
Keep processing after ex-void yymore () 
pression is recognized. 
Invoking this macro causes yylex ( ) to continue as if the regular expression had 
not been recognized. Consider the following regular expression and action 
(which recognizes a subset of the legitimate string constants in C): 
\"[A\"]*\" if( yytext[yyleng-2] == '\\' ) 
yymore(); 
else 
return STRING; 
The regular expression recognizes a double quote (") followed by anything except 
a second double quote repeated zero or more times. The quotes have to be 
escaped with a backslash because they're special characters to IJX. The problem 
here is escaped double quotes within strings, as in 
"string with a \" in it" 
The regular expression is satisfied when the first double quote is encountered. 
The action code looks at the character preceding the ending quote mark 
(yytext [yyleng-2]). If that character is a backslash, yymore () is called, 
and more input will be processed as if the offending double quote had not been 
seen. The same code is executed a second time when the third double quote is 
found; but here, there's no preceding backslash so the return STRING is exe­
cuted. 
15. UNIX lex does not modify yytext oryyleng; it just pushes back the characters. 
16. UNIX lex does not support this mechanism. You're on your own when it comes to initializations. 
Section 0.3.2-The Code Part of the Rule 823 
int yywrap () End-of-input processing. 
This subroutine is called by the lexical analyzer at end of file. The name stands 
for "go ahead and wrap up the processing", so yywrap () returns true if process­
ing should terminate [in which case yylex () returns zero.] The default routine, 
in /.lib, just returns I. It's in Listing D.3. You can provide your own yywrap () 
however, and yours will be linked instead of the library routine. Typically, you'd 
use yywrap ( ) to handle a series of input files. It would open the next input file 
in the series with each call, returning zero until there were no more files to open, 
whereupon it would return one. There's an example in Listing D.4. 
Listing 0.3. yywrap.c- Library Version 
I int yywrap () I* yylex() halts if 1 is returned *I 
2 
3 return( 1 ); 
4 
Listing 0.4. A User-Defined yywrap () 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 int Argc; 
char **Argv; 
yywrap () 
{ 
if( --Argc >= 0 ) 
{ 
if( ii_newfile( *Argv) != -1 ) 
{ 
++Argv; I* Copy of argc as passed to main(). *I 
I* Copy of argv as passed to main(). *I 
return 0; I* New file opened successfully. *I 
fprintf(stderr, "Can't open %s\n", *Argv ); 
return 1; 
main( argc, argv 
int argc; 
char **argv; 
{ 
Argc = argc -1; 
Argv = argv + 1; 
ii_newfile( *argv 
while( yylex() ) 
I* Discard all input tokens. *I 
YYBADINP Control error message for 
unrecognized input char­
If this macro is #defined in a % { ... %} block in the definitions section, an error acter. 
message is printed when an input sequence that's not recognized by any regular 
expression is encountered at run time. Otherwise, the unrecognized input is 
silently ignored at run time.17 
824 LEX-Appendix D 
The longest permissible lexeme is 1024 bytes.18 An error message is printed if you 
try to read more characters. If a lexeme is likely to exceed this length, you'll have to 
work with one of the low-level input functions that I.FX itself uses, synopsized below, 
Low-level input functions. and described in depth in Chapter Two. None of these functions are supported by UNIX 
lex. 
Low-level input routine. int ii _input() 
Low-levellookahead. 
Open new input file. 
Flush low-level input 
buffers. 
Change system-level in­
put functions. This is a somewhat more flexible input function than input ( ) . Normally, it 
returns the next input character (and stretches the lexeme one character). It 
returns zero on end of file and -1 if it can't read a character because the input 
buffer is full [see ii flushbuf () ]. Note that yyleng is not modified by 
ii_input (). 
int ii lookahead(int n) 
You can use this routine to look ahead in the input without actually reading a 
character. ii _lookahead ( 0) returns the last character in the lexeme. 
ii _lookahead ( 1) returns the next character that will be read. 
ii _lookahead ( -1) returns the penultimate character in the lexeme. The max­
imum forward lookahead is 32 characters, and you can look back only as far as 
the beginning of the current lexeme. 
int ii_newfile(char *name) 
Use this routine to open a new input file. The name is the file name. The routine 
returns a file descriptor for the open file or -1 if it can't open the file. As is the 
case with normal input functions, the global variable yyerror will hold an error 
code identifying the problem. This routine automatically closes the current input 
file before opening the new one, so it's actually an error if you close the current 
input file explicitly before calling ii _new file ( ) .19 
int ii flushbuf () 
This routine flushes the input buffer, discarding all characters currently in it and 
destroying the current lexeme. It can be used to continue reading when 
ii _input ( ) returns -1. Note that yylex, yyleng, and yylineno are all 
invalid after this routine is called. It's usually used only when you're doing 
something like absorbing a long comment-when the contents of the lexeme are 
immaterial. It returns I if everything's okay, 0 at end of file. 
int ii_io(int (*open)(), int (*close)(), int (*read)()) 
You can use this routine to change the low-level, unbuffered 1/0 functions used 
by the input routines. It takes three function pointers as arguments, the first is a 
pointer to an open function, the second to a close function, and the third to a read 
function. These should work just like the standard UNIX 1/0 functions with the 
same name, at least in terms of the external interface. The open function is called 
17. UNIX lex does not support this mechanism. It just writes the unrecognized characters to standard output. 
18. 128 bytes is typical in UNIX lex. 
19. UNIX lex does not use this input mechanism; rather, it uses the buffi:red l/0 system for its input and gets 
input from a stream called yyin. This stream is initialized to stdin, but you can modify it using 
fopen ( ) . You must use ii _input () to change the ITX input stream, however. 
Section 0.3.2-The Code Part of the Rule 
as follows: 
#include <fcntl.h> 
#ifdef MSDOS 
# define 0 MODE (O_RDONLYIO_BINARY) 
#else 
# define 0 MODE (O_RDONLY) 
#endif 
int fd; 
if( (fd = (*open) (name, O_MODE)) != -1 ) 
{ 
/* file open was successful */ 
return fd; 
It should return an int-sized number that can't be confused with standard input 
(anything but zero), and that same number will be passed to the read and close 
functions as follows: 
int got; 
char *load characters here; - -int read this _many_bytes; 
int got; 
int fd; I* 
I* 
I* 
I* base address of the buffer *I 
number of characters requested *I 
number of characters actually read *I 
value returned from previous open *I 
if((got=(*read) (fd, load_characters_here, read_this_many_bytes))==-1) 
process_end_of_file(); 
(*close) ( fd ) ; 
All variables and subroutines used both by LEX and its input functions start with one 
of the following character sequences: 20 
yy Yy YY ii 
Don't start any of your own symbols with these characters. 
0.4 LEX Command-Line Switches 
U::X takes various command-line switches that modify its behavior. These are sum­
marized in Table D.421 
LEX automatically compresses the tables that it generates so that they'll take up less 
room in the output. A ten-to-one compression rate is typical. The default compression 
method eliminates equivalent rows and columns from the tables and is best for most 
practical applications. The -c and -! switches can be used to control the table­
compression, however. The -/(for fast) switch eliminates compression entirely, yielding 
much larger tables, but also giving a faster lexical analyzer. The -c switch changes the 
compression algorithm to one in which each character/next-state pair is stored as a two­
byte object. This method typically (though not always) gives you smaller tables and a 
20. You have to worry only about the yy prefix with lex. 
21. Of these, only -t and -!are supported by UNIX lex. The lex -v switch prints a one-line summary of internal 
statistics only-the J!!X -v is more verbose. The lex -n switch suppress the verbose-mode output, and is 
not supported by EX. 825 
Names start with yy Yy 
yy ii . 
Controlling table 
compression, -c, -1. 
826 
Header comment, -h, 
-H. 
Suppressing #line 
directives, -1. 
Choose an alternate 
driver file, -m. 
The LIB environment. 
Use standard output, -t. 
UNIX-compatible newline, 
-u. 
Verbose-mode output, 
-v, -V. 
Table-size limits. LEX-Appendix D 
Table D.4. LEX Command-Line Switches 
Switch Description 
-eN Use pair compression, N is the threshold. The default N is 4. 
-f For fast. Don't compress tables. 
-h Suppress header comment that describes state machine. 
-H Print the header only. 
-I Suppress #line directives in the output. 
-mname Use name as template-file name rather than lex.par. 
-t Send output to standard output instead of lexyy.c 
-u UNIX mode(. is everything but \n) 
-v Verbose mode, print various statistics. 
-V More verbose, print internal diagnostics as lex runs. 
slower lexical analyzer than the default method. The -c switch takes an optional 
numeric argument ( -c5) that speci ties the threshold above which the pair compression 
kicks in for a given row of the table. If the row has more than the indicated number of 
nonerror transitions, it is not compressed. The default threshold, if no number is 
specified, is four. In any event, the -v switch can be used to see the actual table size, so 
you can decide which method is most appropriate in a particular situation. 
The -h and -H switches are used to control the presence of a larger header comment 
that is output at the top of lexyy.c. This comment describes the state machine that IJiX 
uses to recognize the regular expressions. A lower-case h suppresses this comment. An 
upper-case H suppresses all output except the comment. 
IJX automatically generates #line directives in the output file. These cause the 
compiler to print error messages that reference lines in the the original LEX input file 
rather than the output file. They are quite useful when you're trying to track down syn­
tax errors. The #line can confuse source-level debuggers, however, so -1 (that's an ell) 
is provided to eliminate them. 
IJX itself creates only a small part of the output file. The majority is stored in a tem­
plate file called lex.par, discussed in depth in Chapter 2. IJX searches for this file, first 
in the current directory and then along a path specified by semicolon-delimited directory 
names in the LIB environment. The -mname switch can be used to specify an explicit 
file name to use as the template. There's no space between the m and the name. 
The -t switch causes LEX to send output to standard output rather than lexyy.c. 
The -u switch changes the definition of a "newline" to be consistent with UNIX 
rather than MS-DOS. Normally a newline is either a carriage return or linefeed (' \r' or 
' \n' ). In UNIX mode, however, a newline is a single linefeed. This definition affects the 
• operator, which matches anything except a newline, and a negative character class, 
which matches anything except a newline or one of the specified characters. 
The -v switch causes IJX to print various statistics, such as the output table sizes, to 
standard output. -V forces more-verbose output, which describes the internal workings 
of the program as it runs. This last switch is useful primarily for debugging LEX itself; 
it's also handy if you want to see a running commentary of the subset construction used 
to create a DFA from an NFA, described in Chapter Two. 
0.5 Limits and Bugs 
Several limits are imposed on the LEX input file. In addition, several internal limits 
will affect the workings of LEX. These are summarized in Table D.S. There are two 
Section 0.5-Limits and Bugs 
limits on the action components to the rules. No single rule (including the action) can be 
longer than 2,048 bytes, and the space used by all the actions combined cannot exceed 
20,480 bytes. If either of these limits are exceeded, fix the problem by moving some of 
the imbedded code into subroutines declared in the third part of the LEX input 
specification. 
Table 0.5. LEX Limits 
Maximum space available for all actions combined 
Maximum characters in a single rule (including the action) 
Maximum number of NFA states 
Maximum number of DFA states 20,480 
2,048 
512 
254 bytes 
bytes 
states states 
The limits on NFA and DFA states refer to the maximum size 
of internal tables used 
by LEX (see Chapter Two). There are always fewer DFA than NFA states. If you exceed 
either of these limits, you'll either have to reduce the number of regular expressions in 
the input file or simplify the expressions. Two simplification techniques can be used 
with little difficulty: 
(l) Character classes take up less room than the I operator so they should be used when­
ever possible; [ 0 12] is preferable to ( 0 1 1 1 2) . The character class uses two 
states; the expression with I operator uses ten. 
(2) Use multiple rules with shared actions rather than the OR operator if possible. This 
rule: 
abc 
def printf("abc or def"); 
requires one fewer NFA state than this one: 
abcldef printf("abc or def"); 
(3) One of the least efficient ways to use I.!'X is to recognize long strings that do not 
contain metacharacters. A simple string uses roughly as many NFA states as it has 
characters-" 012 3 4 56 7 8 9" requires II states, but a closure operator or character 
class uses only a few states. These sorts of strings can cause problems when you try 
to do something like this: 
<Ctr1-A> 
<Ctr1-B> 
<Ctrl-C> 
<Ctrl-D> 
<Ctrl-E> 
<Ctrl-F> 
<Ctrl-G> 
<Ctrl-H> 
<Ctrl-I> 
<Ctrl-J> 
<Ctrl-K> 
<Ctrl-L> printf("<Ctrl-A>\n"); 
printf("<Ctrl-B>\n"); 
printf("<Ctrl-C>\n"); 
printf("<Ctrl-D>\n"); 
printf("<Ctrl-E>\n"); 
printf("<Ctrl-F>\n"); 
printf("<Ctrl-G>\n"); 
printf("<Ctrl-H>\n"); 
printf("<Ctrl-I>\n"); 
printf("<Ctrl-J>\n"); 
printf("<Ctrl-K>\n"); 
printf("<Ctrl-L>\n"); 
Though the final state machine uses only 31 DFA states, 121 NFA states are 
required to produce this machine. A better solution is: 827 
Simplifying expressions 
to get smaller internal 
table size. 
Use character classes, 
not 1. 
Use shared actions, 
not 1-
Don't use long literal 
matches. 
828 
Use lookup tables to 
disambiguate lexemes. 
Problems with anchors. IFX-Appendix D 
%% 
<Ctrl-[A-L]> switch( yytext[6] ) 
{ 
case 'A': printf("<Ctrl-A>\n"); break; 
case 'B': printf("<Ctrl-B>\n"); break; 
case 'C': printf("<Ctrl-C>\n"); break; 
case 'D': printf("<Ctrl-D>\n"); break; 
case 'E': printf("<Ctrl-E>\n"); break; 
case 'F': printf("<Ctrl-F>\n"); break; 
case 'G': printf("<Ctrl-G>\n"); break; 
case 'H': printf("<Ctrl-H>\n"); break; 
case I I': printf("<Ctrl-I>\n"); break; 
case 'J': printf("<Ctrl-J>\n"); break; 
case 'K': printf("<Ctrl-K>\n"); break; 
case 'L': printf("<Ctrl-L>\n"); break; 
%% 
which requires only 11 NFA states. 
Keyword recognition presents a similar problem that can be solved in much ·the 
same way. A single expression can be used to recognize several similar lexemes, 
which can then be differentiated with a table lookup or calls to strcmp (). For 
example, all keywords in most languages can be recognized by the single expres­
sion [ a-zA-z _] +. Thereafter, the keywords can be differentiated from one 
another with a table look up. There's an example of this process below. 
A bug in U:X affects the way that the default . action is handled if the beginning-of­
line anchor C) is also used in the same input specification. The problem is that an expli­
cit match of \n is added to the beginning of all patterns that are anchored to the start of 
line (in order to differentiate ~ x from x$ from ~ x$ from x-it should be possible to have 
all four patterns in the input file, each with a different accepting action). The difficulty 
here is that an input file like this: 
%% 
~ab return AB; 
return NOT_AB; 
%% 
generates a machine like this: 
'------3>10 return NOT_AB; 
The problem lies in the way that the U:X-generated state machine works. When it fails 
out of a nonaccepting state, the machine backs up to the most-recently-seen accepting 
state. If there is no such state, the input lexeme is discarded. Looking at the previous 
machine, if you are in State 4, the machine fails if a character other than b is in the input. 
Not having seen an accepting state, the machine discards the newline and the a rather 
than performing the default return NOT_ AB action. You can correct the problem by 
making State 3 an accepting state that also executes the return NOT_ AB action. Do 
this by modifying the input file as follows: 
Section 0.5-Limits and Bugs 
%% 
'ab return AB; 
\n I 
return NOT _AB; 
%% 
0.6 Example: A Lexical Analyzer for C 
Listing D.S. shows a sample IJ'X input file for a C lexical analyzer. Listing D.6, 
yyout.h, contains the token definitions. Various macros are defined on lines 11 to 17 of 
Listing D.S. The suffix macro is for recognizing characters that can be appended to 
the end of a numeric constant, such as Ox1234L. Note that all characters from an ASCII 
NUL up to a space (that is, all control characters) are recognized as white space. 
Listing 0.5. c.lex-l!'X Input File for a C Lexical Analyzer 
1 
2 
3 
4 
5 
6 
7 
8 
9 %{ 
/* Lexical analyzer specification for C. Note that CONSTANTS are 
* all positive in order to avoid confusions (to prevent a-1 from 
*being interpreted as NAME CONSTANT rather than NAME MINUS CONSTANT). 
*I 
#include "yyout.h" 
#include <search.h> 
%} 
let [_a-zA-Z] 
alnum [_a-zA-Z0-9] 
h [0-9a-fA-F] 
0 [0-7] 
d [0-9] 
suffix [UuLl] 
white [\xOO-\s] 
%% 
"/*" /* Function prototype for bsearch() */ 
/* Letter 
/* Alphanumeric character 
/* Hexadecimal digit 
/* Octal digit 
/* Decimal digit 
/* Suffix in integral numeric constant 
/* White space 
int i; 
while( i 
{ ii_input () 
if ( i < 0 ) 
ii flushbuf () ; /* Discard Lexeme *I *I 
*I 
*I 
*I 
*I 
*I 
*I 10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 else if( i == '*' && ii lookahead(l) I/' ) 
\"(\\.1 ['\"])*\" 
\"(\\.1 ['\"])*[\r\n] ii_input (); 
break; 
if ( i == 0 ) /* Recognized comment */ 
yyerror( "End of file in comment\n" ); 
return STRING; 
yyerror("Adding missing\" to string constant\n"); 
return STRING; 829 
.... 
830 
Listing D.S. continued ... 
I I 
I\\ • I 
'\\{o} {{o}{o}?)?' '\ \x{h} ( {h} {h} ?) ?' 
O{o}*{suffix}? 
Ox{h}+{suffix}? 
[1-9] {d}*{suffix}? return ICON; I* 'a', 'b', etc. 
I* '\t', '\f', etc. 
I* , \123', , \12', , \1' 
I* '\x123', '\x12', '\xl' 
I* 0, 01, 012, 012L, etc. 
I* Oxl, Ox12, Ox12L, etc. 
I* 123, 123L, etc. 
( { d} + I { d} + \. { d} * I { d} * \. { d} +) ( [ eE] [ -+] ? { d} +) ? [ fF l ? return FCON 
.. (" return LP; 
")II return RP; 
"{" return LC; 
"}" return RC; 
II[" return LB; 
"]II return RB; 
"->" 
II II return STRUCTOP; 
"++" I 
"--" return INCOP; 
[-! l return UNOP; 
"*" return STAR; 
[I%] return DIVOP; 
"+" return PLUS; 
"-" return MINUS; 
<<I>> return SHIFTOP; I* << >> *I 
[<>]=? return RELOP; I* > < >= <= *I 
[!=]= return EQUOP; I* != *I 
[*I%+-& I-]= I* += -= *= , etc *I 
(«I>>)= return ASSIGNOP; I* >>= <<= *I 
"=" return EQUAL; 
"&" return AND; ........ return XOR; 
"I" return OR; 
"&&" return ANDAND; 
II I I II return OROR; 
"?" return QUEST; ..... return COLON; 
II II return COMMA; I ..... return SEMI; I 
{let} {alnum} * return id_or_keyword( yytext ) ; 
{white}+ I* ignore white space *I 
yyerror( "Illegal character <%s>\n", yytext 
%% LEX-Appendix D 
) ; *I 
*I 
*I 
*I 
*I 
*I 
*I 43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 1*------------------------------------------------------------------*l 
100 
101 
102 typedef struct 
{ 
char *name; 
int val; 
KWORD; 
KWORD Ktab [] 
{ 
"auto", 
"break", CLASS 
BREAK I* Routines to recognize keywords *I 
I* Alphabetic keywords *I 
}, 
}, .... 
Section 0.6-Example: A Lexical Analyzer for C 
Listing D.S. continued .•. 
103 
104 
105 
106 
107 
108 
109 
110 
Ill 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 
139 
140 
141 
142 "case", CASE 
"char", TYPE 
"continue", CONTINUE 
"default", DEFAULT 
"do", DO 
"double", TYPE 
"else", ELSE 
"extern", CLASS 
"float", TYPE 
"for", FOR 
"goto", GOTO 
"if", IF 
"int", TYPE 
"long", TYPE 
"register", CLASS 
"return", RETURN 
"short", TYPE 
"sizeof", SIZEOF 
"static", CLASS 
"struct", STRUCT 
"switch", SWITCH 
"typedef", CLASS 
"union", STRUCT 
"unsigned", TYPE 
"void", TYPE 
"while", WHILE 
} ; 
int cmp( a, b ) 
KWORD *a, *b; 
{ 
return strcmp( a->name, 
int id or _keyword( lex 
char *lex; 
{ 
KWORD *p; 
KWORD dummy; 
143 dummy.name lex; }, 
}, 
}, 
}, 
}, 
}, }, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
}, 
} 
b->name 
) /* 
/* 
/* 
/* 
/* ) ; 
Do a binary search for a 
possible keyword in Ktab 
Return the token if it's 
in the table, NAME 
otherwise. 
144 p = bsearch( &dummy, Ktab, sizeof(Ktab)/sizeof(KWORD), *I 
*I 
*I 
*I 
*I 
145 sizeof(KWORD), cmp); 
146 return( p? p->val :NAME); 
147 
The rule on lines 20 to 37 of Listing D.5 handles a comment. The main problem here Comments. 
is the potential comment length. A single regular expression can't be used to recognize a 
comment because various internal limits on lexeme length will be exceeded by long 
comments. So, the code looks for the beginning-of-comment symbol, and then sits in a 
while loop sucking up characters until an end-of-comment is encountered. The 
ii_jlushbuf() call on line 26 forces an internal buffer flush (discarding the partially-
collected lexeme) if the input buffer overflows. Note that this comment processing isn't 
portable to UNIX lex. An alternate strategy is shown in Listing D.7. This second method 
works fine under UNIX, but disallows comments longer than I 024 bytes if used with my 
IJX. 831 
832 I.!'X-Appendix D 
Listing D.6. yyout.h- C Token Definitions 
1 I* 
2 
3 #define 
4 #define 
5 #define 
6 #define 
7 #define 
8 #define 
9 #define 
10 #define 
11 #define 
12 #define 
13 #define 
14 #define 
15 #define 
16 #define 
17 #define 
18 #define 
19 #define 
20 #define 
21 #define 
22 #define 
23 #define 
24 #define 
25 #define 
26 #define 
27 #define 
28 #define 
29 #define 
30 #define 
31 #define 
32 #define 
33 #define 
34 #define 
35 #define 
36 #define 
37 #define 
38 #define 
39 #define 
40 #define 
41 #define 
42 #define 
43 #define 
44 #define 
45 #define 
46 #define 
47 #define 
48 #define 
49 #define 
50 #define 
String constants. token value lexeme *I 
EOI 0 I* -end-of- input symbol *I 
NAME 1 I* identifier *I 
STRING 2 I* "string constant" *I 
ICON 3 I* integer constant or character constant *I 
FCON 4 I* floating-point constant *I 
PLUS 5 I* + *I 
MINUS 6 I* - *I 
STAR 7 I* * *I 
AND 8 I* & *I 
QUEST 9 I* ? *I 
COLON 10 I* : *I 
AND AND 11 I* && *I 
OROR 12 I* II *I 
RELOP 13 I* > >= < <= *I 
EQUOP 14 I* --!= *I 
DIVOP 15 I* I % *I 
OR 16 I* I *I 
XOR 17 I* . *I 
SHIFTOP 18 I* >> << *I 
INCOP 19 I* ++ -- *I 
UNOP 20 I* ! - *I 
STRUCTOP 21 I* -> *I 
TYPE 22 I* int, long, etc. *I 
CLASS 23 I* extern, static, typedef, etc. *I 
STRUCT 24 I* struct union *I 
RETURN 25 I* return *I 
GOTO 26 I* go to *I 
IF 27 I* if *I 
ELSE 28 I* else *I 
SWITCH 29 I* switch *I 
BREAK 30 I* break *I 
CONTINUE 31 I* continue *I 
WHILE 32 I* while *I 
DO 33 I* do *I 
FOR 34 I* for *I 
DEFAULT 35 I* default *I 
CASE 36 I* case *I 
SIZEOF 37 I* sizeof *I 
LP 38 I* ( (left parenthesis) *I 
RP 39 I* ) *I 
LC 40 I* { (left curly) *I 
RC 41 I* } *I 
LB 42 I* [ (left bracket) *I 
RB 43 I* 1 *I 
COMMA 44 I* , *I 
SEMI 45 I* ; *I 
EQUAL 46 I* = *I 
ASSIGNOP 47 I* += -= , etc. *I 
The next two rules, on lines 39 to 41 handle string constants. The rules assume that a 
string constant cannot span a line, so the first rule handles legal constants, the second 
rule handles illegal constants that contain a newline rather than a terminating close 
quote. (ANSI is unclear about whether newlines are permitted in string constants. I'm 
assuming that they are not permitted because string concatenation makes them unneces­
sary. Consequently, a hard error is printed here rather than a warning.) 
Section 0.6-Example: A Lexical Analyzer for C 
Listing 0.7. A UNIX Comment-Processing Mechanism 
I %% 
2 "/*" 
3 int i, lasti = 0; 
4 
5 while ( (i = input ()) && i != EOF 
6 { 
7 if( i -- I I' && last i I* I ) ; 
8 break; 
9 
10 
II if( i --0 II i --EOF ) 
12 yyerror( "End of file in comment\n" ) ; 
13 
14 %% 
Most of the complexity comes from handling backslashes in the string correctly. The 
strategy that I used earlier: 
\"["\"]*\" if( yytext[yyleng-2] 
yymore(); 
else 
return STRING; I\\ I ) 
doesn't work in a real situation because this expression can't handle strings in which the 
last character is a literal backslash, like 11\\11• It also can't handle new lines in string 
constants, for which an error should be printed. The situation is rectified on line 39 of 
Listing D.5 by replacing the character class in the middle of \11 [ • \11] * \11 with the fol­
lowing subexpression (I've added some spaces for clarity): 
( \\. [ "\" l ) * 
This subexpression recognizes two things: two-character sequences where the first char­
acter is a backslash, and single characters other than double quotes. The expression on 
line 40 handles the situation where the closing quote is missing. It prints an error mes­
sage and returns a STRING, as if the close quote had been found. 
All the rules on lines 43 to 49 recognize integer constants of some sort. The first five 
are for the various character constants and the last four are for numeric constants. 
Floating-point constants are recognized on line 51. 
The rule on line 85 recognizes both identifiers and keywords. I've done this to 
minimize the table sizes used by the LEX-generated analyzer. The id _or_ keyword () 
subroutine is used to distinguish the two. It does a binary search in the table declared on 
lines 99 to 129, returning the appropriate token if the current lexeme is in the table, oth­
erwise it returns NAME. The bsearch ( ) function on line 144 does the actual search. It 
is a standard ANSI function that's passed a key, a pointer to a table, the number of ele­
ments hi the table, the size of one element (in bytes), and a pointer to a comparison func­
tion. This last function is called from bsearch ( ) , being passed the original key and a 
pointer to one array element. It must compare these, but otherwise work like 
st rcmp ( ) . The comparison function used here is declared on lines 131 to 135. The 
remainder of the rules are straightforward. 833 
Using lookup table to 
differentiate identifiers 
from keywords. 
834 LEX-Appendix D 
D. 7 Exercises 
D. I. Newlines in string constants are not handled particularly well by the LEX input file 
presented in the previous section. The current file assumes that newlines are not 
permitted in constants, so it inserts a close quote when a newline is encountered. 
Rewrite the regular expressions for string constants so that they will do the follow­
ing: 
• Print a warning if a newline is found in a constant, and then take the next line 
as a continuation of the previous line. That is, the close quote should not be 
inserted by the lexical analyzer; rather, it should recognize multiple-line 
strings. 
• If the newline in the string constant is preceded by a backslash, however, the 
warning message is suppressed. 
D.2. The UNIX vi editor supports a tags feature. When the cursor is positioned on a sub­
routine name, typing a Ctrl-] causes the current file to be saved, the file that con­
tains the indicated subroutine is then read into the editor, and the cursor is posi­
tioned at the first line of the subroutine. Vi accomplishes this feat with the aid of 
supplemental file called tags, which is created by a utility called ctags. The tags 
file consists of several lines, each having the following fields: 
subroutine_name file_name search_pattern 
The three fields are separated by tabs, and the search pattern consists of the actual 
first line of the subroutine, surrounded by t and $/. For example: 
main main.c ;·main( argc, argv )$/ 
Using LEX, write a version of ctags that recognizes all subroutine declarations 
and all subroutine-like macro definitions in a C program. It should not recognize 
external declarations. That is, none of the following should generate an entry in 
the output file: 
extern 
char 
PRIVATE double larry (); 
*curly( int x ); 
moe ( void ) ; 
You can assume that subroutine declarations will follow a standard formatting con­
vention. Hand in both the program and documentation describing what the input 
must look like for a declaration to be recognized. 
D.3. Write a version of ctags for Pascal programs. 
D.4. Using LEX, write a version of the UNIX calendar utility. Your program should 
read in a file called calendar and print all lines from that file that contain today's 
date somewhere on the line. All the following forms of dates should be recog­
nized: 
7/4/1776 
714n6 
7/4 
7-4-1776 
7-4-76 
7-4 
1776-7-4 
July 4, 1776 Assume 20th century, so this entry is for 1976. 
Assume the current year. 
Since 1776 can't be a month, assume European ordering. 
Section 0.7-Exercises 
July 4 1776 
July 4 
Jul4 
Jul. 4 
4July 
4 July, 1776 
4 July, 76 
4 July, '76 
4 Jul. '76 Three-character abbreviations for all month names are supported. 
The abbreviation can be followed by an optional period. 835 
E 
Llama and Occs 
LLama and occs are compiler-generation tools that translate an augmented, attri­
buted grammar into a parser. They are essentially C preprocessors, taking as input a file 
containing intermixed C source code, grammatical rules, and compiler directives, and 
outputting the C source code for a parser subroutine. 
This appendix is a user's manual for both LLama and occs, the two compiler com­
pilers developed in Chapters Four and Five. (Occs stands for "the Other Compiler­
Compiler System". It's pronounced "ox.") An understanding of the theoretical parts of 
these chapters (sections marked with asterisks in the table of contents) will be helpful in 
reading the current Appendix. Similarly, a discussion of how to use occs and LLama in 
conjunction with 1.9X is found at the beginning of Appendix D, which you should read 
before continuing. 
Both LLama and occs are modeled after the UNIX yacc utility, though LLama builds 
a top-down, LL(l) parser while occs builds a bottom-up, LALR(I) parser. The compiler 
in Chapter Six can be constructed both with occs or with yacc. If you intend to use the 
UNIX utility, your time will be better spent reading the UNIX documentation than the 
current appendix. 
LLama and occs are both discussed in one appendix because they are very similar at 
the user level. I will discuss the common parts of both systems first, and then describe the 
individual characteristics of occs and LLama in separate sections. Both programs are 
compiler compilers, because they are themselves compilers which translate a very-high­
level-language description of a compiler to a high-level-language source code for a com­
piler. I will use the term compiler compiler when I'm talking about characteristics 
shared by both systems. 
E.1 Using The Compiler Compiler 
Like LEX, occs and LLama are C preprocessors. They take as input a file that con­
tains an augmented, attributed grammar that describes a programming language, and 
they create the C source code for a parser for that language. C source-code fragments 
that specify code-generation actions in the input are passed to the output with various 
translations made in that source code to give you access to the parser's value stack. 
Occs outputs the source for a bottom-up parser (both the tables and the parser itself); 
836 
Section E. I-Using The Compiler Compiler 
LLama outputs a top-down parser. The generated parser subroutine is called 
yyparse ()-just call this subroutine to get the parsing started. The subroutine returns 
zero if it parses the input successfully, -1 if an unrecoverable error in the input is 
encountered. A mechanism is provided for you to return other values as well. 
yyparse () expects to get input tokens from a scanner subroutine generated by LEX, the 
interaction was discussed at the beginning of Appendix D. 
Occs, despite superficial similarities, is not yacc-I've made no attempt to perpetu­
ate existing deficiencies in the UNIX program in order to get compatibility with UNIX. 
Occs has a better error-recovery mechanism than yacc (though it's still not ideal), the 
output code is more maintainable, and it provides you with a considerably improved 
debugging environment. This last change, activated when you compile with YYDEBUG 
defined, gives you a window-oriented debugging system that lets you actually watch the 
parse process in action. You can watch the parse stack change, see attributes as they're 
inherited, set breakpoints on various stack conditions and on reading specified symbols, 
and so forth. I've documented diffurences between occs and yacc in footnotes; these are 
of interest only if you're already familiar with yacc. LLama, of course, is radically 
diffurent from yacc in that it uses a completely different parsing technique. Don't be 
misled by the superficial similarities in the input formats. 
Unfortunately, it's difficult to present either compiler compiler in a hierarchical 
fashion-you may have to read this Appendix twice. Similarly, the description of the 
attribute-passing mechanism will make more sense after you've seen it used to build the 
C compiler in Chapter Six. 
E.2 The Input File 837 
The parser subroutine, 
yyparse (). 
The LLama and occs input files, like LEX input files, are split up into three sections, Input-file organization. 
separated from one another with %% directives: 
definitions 
%% 
rules 
%% 
code 
Both the definitions and code sections can be empty. 
E.3 The Definitions Section 
The first part of the input file contains both directives to the compiler compiler itself 
and C source code that is used later on in the rules section. As with the LEX input format, 
the code must be surrounded by % { and %} directives. 1 All the directives start with a per­
cent sign, which must be in the leftmost column. Those directives that are unique to one 
or the other of the programs are discussed later, but those directives that are shared by 
both LLama and occs are summarized in Table E. I. 
The %token and %term directives are used to declare nonterminal symbols in the 
grammar. The directive is followed by the name of the symbol, which can then be used 
I. Yacc passes lines that start with white space through to the output without modification, as if they were 
part of a% { ... %) delimited code block. Occs does not suppon this mechanism. Code in the definitions 
section. 
Defining tokens: 
%token, %term. 
838 LLama and Occs-Appendix E 
Table E.l. Occs and LLama % Directives 
Directive 
%% 
%{ 
%} 
%token 
%term 
/* */ Description 
Separates the three sections of the input file. 
Starts a code block in the definitions section. All lines that follow, up to a line that starts with a 
%} directive, are written to the output file unmodified. 
Ends a code block. 
Defines a token. 
A synonym for %token. 
C-like comments are recognized-and ignored-by occs, when found outside of a % { ••• %} -
delimited code block. They are passed to the output if found inside a code block. 
later in a production in the rules section. For example: 
%term LP RP I* ( and ) *I 
%term ID I* an identifier *I 
%term NUM I* a number *I 
%token PLUS STAR I* + * *I 
yyout.h: Token definitions Several names can be listed on a single line. Occs creates an output file called yyout.h 
which holds symbolic values for all these tokens, and these values must be returned from 
the lexical analyzer when the equivalent string is recognized.2 For example, the previous 
declarations produce the following yyout.h file: 
#define EOI 0 
#define LP 1 
#define RP 2 
#define ID 3 
#define NUM 4 
#define PLUS 5 
#define STAR 6 
Token names. The arguments to %term are used verbatim for the macro names in yyout.h. Conse­
quently, they must obey the normal C naming conventions: The token names must be 
made up of letters, numbers, and underscores, and the first symbol in the name cannot be 
a number. 3 The definitions in yyout.h can then be used from within a LEX input file to 
build a lexical analyzer. A sample LEX file is in Listing E. I. 
Code Blocks%{ ... %} Code blocks, delimited by % { and %} directives, are also found in the definitions 
section. These blocks should contain the normal things that would be found at the top of 
a C file: macro definitions, typedefs, global-variable declarations, function prototypes, 
and so forth. Certain macro names are reserved for use by the compiler compiler, how­
ever, and these are summarized in Table E.2.4 You can modify the parser's behavior by 
defining these macros yourself in a code block in the definitions section (there's no need 
to #undef them first). 
2. Yacc creates a file called y.tab.h, and the file is created only if-dis specified on the command line. 
3. Yacc doesn't impose these restrictions. Also, yacc (but not occs) accepts a definition of the form 
%token NAME number, in which case it uses the indicated number for the token value rather than 
assigning an arbitrary value. 
4. Of these, YYABORT, YYACCEPT, YYDEBUG YYMAXDEPTH, and YYSTYPE are supported by yacc. The 
YYDEBUG flag just activates a running log of shift and reduce actions to the screen-there is no interactive 
debugging environment. 
Section E.3-The Definitions Section 
Listing E. I. expr.lex- LEX Input Specification for Simple Expressions 
I %{ 
2 #include "yyout.h" 
3 %} 
4 %% 
5 "+" return PLUS; 
6 "*" return STAR; 
7 "(" return LP; 
8 ") .. return RP; 
9 [0-9]+ return NUM; 
10 [a-z]+ return ID; 
II %% 
In addition to the foregoing, the file <stdio.h> is automatically #included at the 
top of the parser file before any code that you specify in the definitions section is output. 
It's harmless, though unnecessary, for you to #include it explicitly. Similarly, 
"yyout.h" and the ANSI variable-argument-list-definitions file, <stdarg.h>, is also 
#included automatically. 5 Finally, the yacc version of the stack macros are included 
( <toolslyystack.h> ). These are described in Appendix A. 
Note that all the symbols that occs uses start with YY, yy, or Yy. You should not start 
any of your own names with these characters to avoid possible name conflicts. 
E.4 The Rules Section 
The rules section of the input file comprises all lines between an initial %% directive 
and a second %% directive or end of file. Rules are made up of augmented, attributed pro­
ductions: grammatical rules and code to be executed. A rules section for an occs input 
file is shown in Listing E.2 along with the necessary definitions section. (I'll discuss this 
file in greater depth in a moment; it's presented here only so that you can see the struc­
ture of an input file.) 839 
Internal names: yy, Yy, 
yy 
Productions take the form: Occs' modified BNF: 
left-hand_side: right-hand_side I rhs_21 ... 1 rhs_N; 
A colon is used to separate the left-from the right-hand side instead of the~ that we've 
used hitherto. A vertical bar (I) is used to separate right-hand-sides that share a single 
left-hand side. A semicolon terminates the whole collection of right-hand sides. Termi­
nal symbols in the grammar must have been declared with a previous %term or %token, 
and their names must obey the C naming conventions. representing productions. 
Nonterminal names can be made up of any collection of printing nonwhite characters Nonterminal names. 
except for the following: 
%{}[]()<>*:!;, 
There can't be any imbedded spaces or tabs. Imbedded underscores are permitted. 
Imbedded dots can be used as well, but I don't suggest doing so because dots make the 
yyout.doc file somewhat confusing. 6 I'd suggest using lower-case letters and underscores 
5. Yacc actually puts the token definitions in the output file. Occs puts the definitions in yyout.h and 
#includes it in the output file. 
6. Exactly the opposite situation applies to yacc. An imbedded underscore should be avoided because an 
underscore is used to mark the current input position in yyout.doc. 
840 LLama and Occs-Appendix E 
Table E.2. Macros that Modify the Parser 
YYABORT This macro determines the action taken by the parser when an unrecoverable error is 
encountered or when too many errors are found in the input. The default macro is: 
YYACCEPT 
YYCASCADE 
YYD(x) 
YYDEBUG 
YYMAXDEPTH 
YYMAXERR 
YYPRIVATE #define YYABORT return(l) 
but you can redefine it to something else in a code block at the top of the occs input 
file if you prefer. Note that there are no parentheses attached to the macro-name 
component of the definition. 
This macro is like YYABORT, except that it determines the accepting action of the 
parser. The standard action is return 0, but you can redefine it to something else 
if you prefer. 
(Occs only.) This constant controls the number of parser operations that have to fol­
low an error before another error message is printed. It prevents cascading error 
messages. It's initialized to five. #define it to a larger number if too many error 
messages are printed, a smaller number if too many legitimate error messages 
suppressed. 
If the -D switch is specified, then all text in a YYD macro is expanded, otherwise 
it's ignored. For example, the following printf () statement is executed only if -D 
is present on the occs command line. 
YYD( printf("hi there"); ) 
Set automatically by the -D command-line switch to enable the interactive debug­
ging environment, but you can define it explicitly if you like. The contents are 
unimportant. 
This macro determines the size of the state and value stacks. It's 128 by default, but 
you may have to enlarge it if you get a "Parse stack overflow" error message at run 
time. You can also make it smaller for some grammars. 
(Occs only.) Initially defined to 25, the value of this macro determines when the 
parser will quit because of too many syntax errors in the input. 
Defining this macro as an empty macro makes various global-variable declarations 
public so that you can see them in a link map. Use the following: 
#define YYPRIVATE /*nothing*/ 
YYSHIFTACT(tos) (Occs only.) This macro determines the default shift action taken by the parser. 
YYSTYPE 
YYVERBOSE That is, it controls what gets put onto the value stack when an input symbol is 
shifted onto the stack. It is passed a pointer to the top of the value stack after the 
push (tos). The default definition looks like this: 
#define YYSHIFTACT (tos) ( (tos) [0) =yylval) 
(yylval is used by the lexical analyzer to shift an attribute associated with the 
current token. It is discussed below.) You can redefine YYSHIFTACT as an empty 
macro if none of the tokens have attributes. 
This macro determines the typing of the value stack. It's discussed at length in the 
text. 
If this macro exists, the parser uses more verbose diagnostic messages when YYDE­
BUG is also defined. 
Section E.4-The Rules Section 
Listing E.2. expr.y- Occs Rules Section for the Expression Compiler 
1 
2 
3 
4 
5 %term 
%term 
%left 
%left 
%left 
6 %% ID 
NUM 
PLUS 
STAR 
LP RP /* an identifier *I 
/* a number *I 
/* + *I 
/* * *I 
/* and ) *I 
7 /* A small expression grammar that recognizes numbers, names, addition (+), 
8 *multiplication (*), and parentheses. Expressions associate left to right 
9 * unless parentheses force it to go otherwise. * is higher precedence than +. 
10 * Note that an underscore is appended to identifiers so that they won't be 
11 * confused with rvalues. 
12 *I 
13 
s e 
e e PLUS e yycode("%s += %s\n", $1, $3); free name( $3 -e STAR e yycode("%s *= %s\n", $1, $3); free name( $3 -LP e RP $$ = $2; 14 
15 
16 
17 
18 
19 
20 
21 
22 NUM yycode("%s %s\n", $$ new name(), yytext -ID yycode("%s %s\n", $$ new_name(), yytext 
%% 
for nonterminal names and upper-case letters for tokens, as in Listing E.2. This way you 
can tell what something is by looking at its name. It's a hard error to use a nonterminal 
that is not found somewhere to the left of a colon. ) ; ) 
) ; ) 
) 
) ; ) 
) ; ) 841 
Text surrounded by curly braces is code that is executed as a parse progress. In a Augmentations: putting 
top-down LLama parser, the code is executed when it appears at the top of the parse code in a production. 
stack. In the bottom-up occs parser, the code is executed when a reduction by the associ-
ated production is performed. 
E productions are represented with an empty right-hand side (and an optional action). £productions. 
It's best to comment the fact that the production has been left empty on purpose. All the 
following are legitimate E productions: 
a /* empty */ 
b 
c /* epsilon */ 
normal rhs 
/* epsilon */ an_action (); 
an_action (); 
another_action(); 
I'd suggest using the formatting style shown in Listing E.2. The colons, bars, and Formatting. 
semicolons should all line up. The nonterminal name should start at the left column and 
the body of a production should be indented. The curly braces for the actions all line up 
in a nice column. If a name is too long, use the following: 
very_long_left_hand_side_name 
right_hand_side 
I another action(!); 
action(2); 
Any valid C statement that's permitted inside a C subroutine is allowed in an action, 
with the following caveats: return and break 
statements in actions. 
842 LLama and Occs-Appendix E 
Local variables in ac­
tions. 
The start production. (I) A break statement at the outennost level tenninates processing of the current 
action but not the parser itself. 
(2) All return statements must have an associated value. A simple return is not 
pennitted. 
(3) A return statement causes the parser to return only if it takes a nonzero argument. 
That is, return 0 causes processing of the current action to stop, but the parsing 
continues; return 1 forces the parser to return to the calling routine, because the 
argument is nonzero. The argument to return is returned from yyparse () . 
(4) The YYACCEPT and YYABORT macros detennine what happens when the parser ter­
minates successfully (accepts the input sentence) or fails (rejects the input sen­
tence). The default actions return 0 and I respectively, so you should not return 
either of these values from within an action. 
You can't declare subroutines in an action because the actions themselves are inside a 
subroutine. You can, however, declare local variables after any open brace, and you can 
use an action that's several lines long. The following is okay: 
left hand side right_hand_side 
{ 
int i, monster; 
for( i = 10; --i >= 0 ;) 
bug( i, monster); 
Of course, you can't declare a local variable in one action and access that variable from 
another. True global variables that are declared in a % { ••• % } block in the definitions 
sections can be accessed everywhere. 
The first production in the rules section is taken as the start production and is treated 
specially: Its left-hand side is the goal symbol and it can have only one right-hand side.7 
E.5 The Code Section 
The third part of the input file, the code section, comprises all text after the second 
%%directive. This entire section is written to the output file verbatim. It is used the same 
way as the LEX code section-it should contain subroutines that are called from the 
actions. Note that the occs code section differs from both the IJX and LLama sections 
in that dollar attributes (discussed below) can be used in the code found there.8 
E.6 Output Files 
LLama and occs create several output files-their interaction with LEX is discussed 
at the beginning of Appendix D. The two programs use different names for these files, 
however, and these are summarized in Table E.3. 
7. Some versions of yacc suppon a %start directive that lets you define an arbitrary production as the stan 
production. This mechanism isn't supponed by occs. 
8. Yacc doesn't permit this: dollar attributes may be used only in the rules sections. 
Section E.7-Command-Line Switches 843 
Table E.3. Files Generated by Occs and LLama 
Occs LLama Command-line Contains Name Name Switches 
yyout.c llout.c none,-p Normally contains parser and action code taken from original 
grammar. If -p is specified to occs, this file contains the parser 
only. (LLama doesn't support a -p switch.) 
yyact.c -a If -a is specified to occs, this file contains code for the action 
components of the productions and all of the code portion of 
input file (but not the parser). LLama doesn't support -a. 
yyout.h llout.h none Contains #defines for the tokens. 
yyout.sym llout.sym -s,-S,-D The symbol table. The -S version contains more information than 
the -s version. Specifying -D implies -s-you can get more-
verbose tables with -DS. 
yyout.doc -v,-V Used only by occs, contains the LALR(l) state-machine descrip-
tion along with any warning messages that are sent to the screen. 
E. 7 Command-Line Switches 
The basic command-line usage for both programs is the same: 
occs [-switches] file 
llama [-switches] file 
where the file is an input specification file, as just discussed. The programs take the fol­
lowing command-line switches: 9 
-a 
-c[N] 
-D 
-f (occs only.) Rather than creating a combined parser-and-action file, the action 
subroutine only is output to the file yyact.c. The parser component of the output 
file can be created using the -p switch, described below. 
(LLama only.) This switch controls the parse-table compression method; it 
works just like the U::X switche with the same name. It changes the compression 
algorithm to one in which each character/next-state pair is stored as a two-byte 
object. This method typically (though not always) gives you smaller tables and 
a slower parser than the default method. The -c switch takes an optional 
numeric argument (-c5, for example) that specifies the threshold above which 
the pair compression kicks in for a given row of the table. If the row has more 
than the indicated number of nonerror transitions, it is not compressed. The 
default threshold, if no number is specified, is four. 
Enables the interactive debugging environment in the generated parser. All that 
this switch really does is insert a #define YYDEBUG into the output file. You 
can do the same thing yourself by putting an explicit #define in the input 
specification. Specifying -D also causes -s to be set. 
(LLama only.) This switch causes the output tables to be uncompressed, 
thereby speeding up the parser a little at the cost of program size. 
9. Of these, only -v is supported by yacc, though yacc is considerably less verbose than occs. occs' -D 
switch is nothing like yacc's --d switch. Generate Action Subrou­
tine. 
Pair compress LLama 
parse tables. 
Activating the interactive 
debugging environment. 
Uncompressed tables. 
844 
Making private variables -g 
public. 
Suppress #line direc­
tives. 
Alternative parser tem­
plates. 
The LIB environment 
vafiable. 
Create parser only. 
Symbol Tables. 
Use stdout. 
Send large tables to 
yyoutab.c. -1 
-m 
-p 
-s 
-s 
-t 
-T LLama and Occs-Appendix E 
Several global variables and subroutines are used in the output parser. These 
are declared static by default, so their scope is limited to yyout.c (or llout.c). 
The -g switch causes the compiler compiler to make these variables global to 
the entire program. You can achieve the same effect by putting the following in 
the first section of the input specification: 
%{ #define YYPRIVATE %} 
(I is an ell.) Occs and LLama usually generate #line directives that cause the 
C compiler's error messages to reflect line numbers in the original input file 
rather than the output file. (A preprocessor directive of the form 
#line N "file" tells the compiler to pretend that it's on lineN of the indi­
cated file.) These directives can cause problems with source-level debuggers, 
however, and the -/ switch gives you a way to tum them off. Generally you 
should not use-/ until you've eliminated all the syntax errors from the input file. 
Resist the temptation to modify the output file in order to fix a syntax error. It's 
too easy to forget to modify the input too, and the output file is destroyed the 
next time you use the compiler compiler. 
Occs and LLama both generate only part of the parser. They create the parse 
tables and a few macros and typedefs needed to compile those tables. The 
remainder of the parser is read from a template file, called occs.par (in the case 
of occs) and 1/ama.par (in the case of LLama). The programs look for these 
files, first in the current directory, and then along all directories specified in the 
LIB environment variable. LIB should contain a semicolon-delimited list of 
directories. The -m command-line switch is used to specify an alternate tem­
plate file. For example: 
occs -m/usr/allen/template/template.par 
tells occs to read a file called template.par from the /usr/allen/template directory 
rather than using the default template. The template files are discussed in depth 
in Chapters Four and Five. Note that there's no space between the m and the 
first character of the path name. 
(occs only.) Rather than creating a combined parser-and-action file, the parser 
component of the file is output to the file yyout.c. No actions are put into 
yyout.c-the action component of the output file can be created using the -a 
switch, described earlier. 
These switches causes the symbol-table file (yyout.sym for occs and 1/out.sym 
for LLama) to be generated. A capital S causes the symbol-table file to contain 
more information-the FIRST( ) sets for each nonterminal are printed in the 
occs table, and both FIRST and FOLLOW sets are printed in LLama's. 
Causes occs to output the parser to standard output rather than to the yyout.c file. 
The table-compression method used by occs can create several hundred small 
arrays, and some compilers can't handle that many declarations in a single file. 
The -T switch splits the parser file up into two portions, one containing the 
parser and most of the tables, the other containing the two biggest tables-the 
ones most likely to give the compiler problems. These parser is put into yyout.c 
as usual. The two parse tables are put into yyoutab.c. The two files can then be 
compiled independently and linked together. You can use this switch in con­
junction to the -a and -p switches to split the parser into three parts. Use: 
Section E.7-Command-Line Switches 
-V 
-v 
-w aces -pT input.y 
aces -a input.y Create yyout.c and yyparse.c 
Create actions file 
The -v switch puts occs and LLama into verbose mode. Occs generates a file 
called yyout.doc which contains a human-readable description of the LALR(l) 
state machine. There is no equivalent file from LLama. Both programs send 
progress reports to the screen as they work and they print various statistics 
describing table sizes, and so forth, when done. -V works like -v except that 
more information about the internal workings of occs and LLama than you're 
interested in seeing is printed on the screen. It's used primarily for debugging 
occs itself or for seeing how the LALR(l) state machine is put together. -V. 
also puts the LALR(l) lookaheads for every kernel item (rather than just for the 
items that cause reductions) into yyout.doc. 
Suppress all warning messages. These warnings announce the presence of 
shift/reduce and reduce/reduce conflicts found when the state machine is con­
structed. Once you've ascertained that these warnings are harmless, you can use 
-w to clean up the screen. Warnings are printed to yyout.doc, even if -w is 
specified, and the number of warnings is always printed at the end of an occs 
run, even if the warnings themselves aren't printed. 
-W Normally, the number of hard errors is returned to the operating system as the 
exit status. If -W is specified, the exit status is the sum of the number of hard 
errors and warning messages. This switch is handy if you want the UNIX make 
utility (or equivalent) to terminate on warnings as well as errors. 
E.8 The Visible Parser10 
An occs-and LLama-generated parser can function in one of two ways. In produc­
tion mode, it just parses the input and generates code, as you would expect. In debug 
mode, however, a multiple-window interactive debugging environment (or IDE) is made 
available to you. Debug mode is enabled in one of two ways, either specify -D on the 
occs command-line, or put the following in the rules section of your input file: 
%{ #define YYDEBUG %} 
The resulting file should be compiled and linked to three libraries: /.lib, curses.lib, and 
termlib.lib.11 Only the first of these libraries is necessary if you're not compiling for 845 
Verbose-mode. LALR(1) 
state-machine descrip­
tion. 
Suppress warning mes­
sages. 
Production and debug 
mode. 
IDE (interactive debug­
ging environment). 
debugging. The occs source file for a small expression compiler is on the software- Compiling for Debugging. 
distribution disk mentioned in the preface, along with the curses and termlib libraries. 
You may need to recompile the libraries to get them to work properly if you're not using 
Microsoft C (or QuickC). An executable version of the compiler (expr.exe) is also on 
the disk, however, so you don't have to recompile right now. Make the expression com-
piler with Microsoft C as follows: 
10. This section describes how to use the interactive debugging environment. If at all possible, you should 
have an occs output file, compiled for interactive debugging, running in front of you as you read. An 
executable version of the expression compiler described below is provided on the software distribution 
disk in the file expr.exe. 
II. Usecc files ... -11 -lcurses -ltermlibinUNIX. 
846 
Direct-video output. 
The VIDEO environment 
variable. 
Window names. 
Changing stack-window 
size from the command 
line. occs -vD expr.y 
lex -v expr.lex LLama and Occs-Appendix E 
cl -o expr.exe yyout.c lexyy.c -link l.lib curses.lib termlib.lib 
Then run it with: 
expr test 
where test is an input file containing a simple expression composed of numbers, variable 
names, plus signs, asterisks, and parentheses. The expression must be the first and only 
line in the file. 
In the MS-DOS environment, the debugger uses the ROM-BIOS for its output. It can 
also use direct-video writes, however, and on some clones this approach is more reliable 
than using the BIOS. To activate the direct-video routines, set the VIDEO environment 
to DIRECT with the following command to COMMAND.COM: 
set VIDEO=DIRECT 
The direct-video routines assume that either an MGA, or a CGA running in high resolu­
tion, 25x80 text mode is present (it automatically selects between these two display 
adapters). Most other video adapters can simulate one or the other of these modes. The 
program will not work with a CGA running in one of the other text modes (25x20 or 
25x40), however. Issue a MODE BW8 0 request at the DOS prompt to get the CGA into 
high-resolution, text mode. 
The program comes up with several empty windows, as shown in Figure E. I. The 
stack window is used to show the state and value-stack contents; the comments window 
holds a running description of the parse process; generated code is displayed in the out­
put window, the lookahead window displays the most-recently read token and lexeme­
the current lookahead symbol, and the prompts window is used to communicate with the 
debugger. The size of the stack window can be changed by specifying an optional -sN 
command-line switch when you invoke the program, as in expr -sl 5 test. In this case the 
stack window occupies 15 lines. The other windows scale themselves to take up what's 
left of the screen. 
Several commands are supported by the debugger; you can see a list by typing a 
question mark, which prints the list shown in Figure E.2. The easiest command to use is 
the g command (for go) which just starts up the parsing. Figure E.3 shows the various 
windows several stages into parsing the expression a* (b+c). The parsing can be 
stopped at any time by pressing any key. 
In Figure E.3, the parser has just read the c (but it has not yet been shifted onto the 
parse stack). The ID c in the lookahead window is the most recently read token and 
lexeme. The output window shows code that has been output so far, and the current 
parse stack is shown in the stack window. 
The output window shows output sent to all three segment streams. The leftmost 
column identifies the segment-it holds a C for code, D for data, orB for bss. Because 
the window is so narrow, sequences of white-space characters (tabs, spaces, and so forth) 
are all replaced with a single space character in this window. 
The stack window always displays the topmost stack elements. If the stack grows 
larger than the window, the stack window scrolls so that the top few stack elements are 
displayed. The three columns in the stack window are (from left to right): the parse 
stack, the parse stack represented in symbolic form rather than numbers, and the value 
stack. Several commands other than g are recognized at the "Enter command" prompt in 
the prompts window: 
Section E.8-The Visible Parser 
Figure E.l. The Initial Debug Screen 
+----------------------------[stack]-------------------------------+ 
I I 
+------------[comments]----------+-----------[output]--------------+ 
I I I 
I I 
+----------------------[prompts]-------------------+--[lookahead]--+ 
I Enter command (space to continue, ? for list) : I I 
+--------------------------------------------------+---------------+ 
Figure E.2. Debug-Mode Commands 
a (A)bort parser by reading EOI 
b modify or examine (B)reakpoint 
d set (D)elay time for go mode 
f read (F)ile 1 
n/N 
q 
r (L)og output to file 
(N)oninteractive mode 
(Q)uit (exit to dos) 
(R)efresh stack window 
g (G)o (any key stops parse) 
i change (I)nput file w (W) rite screen to file or device 
space, 
enter 
Ctrl-A, 
Ctrl-8 X Show current and prev. le(X)eme 
Space or Enter to single step 
You can single step through the parse by repetitively pressing the space bar or 
the Enter key. In practice, this is usually more useful than g which can go by 
faster than you can see. 
These two commands are deliberately not printed on the help screen. They are 
debugger hooks. Ctri-A causes the debugger to call the subroutine 
yyhook_a (),and Ctrl-B calls yyhook_b (). The default versions of these 
routines do nothing. You can use these commands for two things. First, its 
often useful to run the IDE under a compiler debugger like sdb or CodeView, 
and you can use a hook as an entry point to the debugger: Set a breakpoint at 
yyhook _a () and then start the parser running; issuing a Ctri-A then returns 
you to the debugger. Single step. 
Debugger hooks. 847 
848 LLama and Occs-Appendix E 
Figure E.3. The Windows Several Steps into a Parse 
Breakpoints. +---------------------------------[stack]----------------------------------+ 
I I 
61 PLUS tl 
51 e I tl 
31 LP tO 
71 STAR tO 
41 e I tO 
01 s <empty> 
+-------------[comments]-------------+--------------[output]---------------+ 
!Shift <LP> (goto 3) IBI public word _t0,_tl,_t2,_t3; I 
!Advance past ID <b> IBI public word _t4,_t5,_t6,_t7; 
!Shift <ID> (goto 1) ICI tO = a 
!Advance past PLUS <+> 
!Reduce by (5) e->ID ICI t1 = b 
I 
I (goto 5) 
!Shift <PLUS> (goto 6) 
!Advance past <PLUS> 
IRead ID <c> 
+---------------------------[prompts]--------------------+---[lookahead]---+ 
I Enter command (space to continue, ? for list): liD c I 
+--------------------------------------------------------+-----------------+ 
The two hook subroutines are in modules by themselves, so you can use 
them to add capabilities to the IDE by linking your own versions rather than 
the library versions. For example, its occasionally useful to print the symbol 
table when you are debugging the parts of the compiler that are processing 
declarations. This capability can't be built into the IDE because there's no 
way of knowing what the data structures will look like. The problem is solved 
by supplying a subroutine called yyhook _a () which prints the symbol table. 
Your version is linked rather than the default library version, so a Ctrl-A com­
mand now prints the symbol table. 
a This command aborts the parse process by forcing the lexical analyzer to 
return the end-of-input marker on all subsequent calls. Compare it with the q 
command, which exits immediately to the operating system without returning 
to the parser itself. 
b The b command is used to set, clear, or examine breakpoints. Four types of 
breakpoints are supported: 
input 
input line (i) breaks when a specified symbol is input. 
(I) breaks when the input sweeps past the specified input line. 
This breakpoint is activated only when the lexical analyzer 
returns a token, and it's possible to specify an input line that 
doesn't have any tokens on it. (In this case, the break occurs 
when the first token on a line following the indicated one is read.) 
Section E.8-The Visible Parser 
d Note that this breakpoint, unlike any of the others, is automati­
cally cleared as soon as it is triggered. 
stack (s) breaks as soon as a specified symbol appears at the top of the 
parse stack. In a LLama parser, parsing stops before any action 
code is executed. 
production (p) breaks just before the parser applies a specific production. In 
occs, it breaks just before the reduction. In LLama, it breaks just 
before replacing a nonterminal with its right-hand side. 
When you enter b, you are prompted for one of these types (enter ani, I, s, or p 
for "input,", "line", "stack," or "production"). You are then prompted for a 
symbol. The different kinds of breakpoints can take different inputs in response 
to this prompt: 
input (I) A decimal number is assumed to be a token value, as defined 
in yyout.h or yyout.sym (llout.h or llout.sym if LLama). Parsing 
stops when that token is read. (2) A string that matches a token 
name (as it appears in a %term or %token directive) behaves 
like a number-parsing stops when that token is read. (3) Any 
other string causes a break when the current Iexeme matches the 
indicated string. For example, if you have a %term NAME in the 
input file and the compiler compiler puts a #define NAME 1 in 
yyout.h or llout.h, then entering either the string 1 or the string 
NAME causes a break the next time a NAME token is read. You 
can also enter the string Illiavitch, whereupon a break 
occurs the next time llliavitch shows up as a lexeme, regardless 
of the token value. 
input line 
stack 
production Enter the input line number. 
(I) If you enter a number, parsing stops the next time that number 
appears at the top of the real parse stack (the leftmost column in 
the stack window). (2) Any other string is treated as a symbolic 
name, and parsing stops the next time that name appears at the 
top of the symbol stack (the middle column in the window). 
You must enter a number for this kind of breakpoint. Parsing 
stops just before the particular production is applied (when it's 
replaced in a LLama parser and when a reduction by that pro­
duction occurs in an occs parser). Production numbers can be 
found in the yyout.sym or llout.sym file, generated with a -s or -S 
command-line switch. 
There's no error checking to see if the string entered for a stack breakpoint 
actually matches a real symbol. The breakpoint-processing routines just check 
the input string against the symbol displayed in the symbolic portion of the 
stack window. If the two strings match, the parsing stops. The same technique 
is used for input breakpoints. If the symbol isn't a digit, then the breakpoint 
string is compared, first against the input lexeme, and then by looking up the 
name of the current lexeme. If either string matches, then parsing stops. 
Three other breakpoint commands are provided: c clears all existing 
breakpoints, d displays all existing breakpoints, and ? prints the help screen 
shown in Figure E.4. 
The d command is used to slow down the parse. The parsing process, when 
started with a g command, nips along at a pretty good clip, often too fast for 
you to see what's going on. The d command is used to insert a delay between Adding a delay in go 
mode. 849 
850 
Examine file. 
Go! 
Specify input file. 
Log all output to file. 
Specifying horizontal 
stacks. 
Noninteractive mode: 
Create log without win­
dow updates 
Run parser without log­
ging or window updates. LLama and Occs-Appendix E 
Figure E.4. Breakpoint Help Screen 
f 
g 
n, 
N Select a breakpoint type (i,p,or s) or command (c or 1) 
Type: Description: Enter breakpoint as follows: 
i input ..................... number for token value 
or string for lexeme or token name 
1 input line ................ input line number 
p reduce by production ...... number for production number 
s top-of-stack symbol ....... number for state-stack item 
s = clear all breakpoints 
1 list all breakpoints or string for symbol-stack item 
every parse step. Setting the delay to 0 puts it back to its original blinding 
speed. Delay times are entered in seconds, and you can use decimal fractions 
( 1, 2.5, .5, and so forth) if you like. 
Thefcommand lets you examine a file without leaving the debugger. You are 
prompted for a file name, and the file is then displayed in the stack window, 
one screenfull at a time. 
The g command starts the parse going. 
The i command lets you change the input file from the one specified on the 
command line. It prompts you for a file name. 
This command causes the entire parse to be logged to a specified file, so that 
you can look at it later. If you're running under MS-DOS, you can log to the 
printer by specifying prn: instead of a file name. Some sample output is 
shown in Figures E.5 and E.6. Output to the CODE window is all preceded by 
CODE->. Most other text was COMMENT-window output. The parse stack is 
drawn after every modification in one of two ways (you'll be prompted for a 
method when you open the log file). Listing E.3 shows vertical stacks and 
Listing E.4 shows horizontal stacks. The latter is useful if you have relatively 
small stacks or relatively wide paper-it generates more-compact log files in 
these situations. The horizontal stacks are printed so that items at equivalent 
positions on the different stacks (parse/state, symbol, and value) are printed 
one atop the other, so the column width is controlled by the stack that requires 
the widest string to print its contents-usually the value stack. If you specify 
horizontal stacks at the prompt, you will be asked which of the three stacks to 
print. You can use this mechanism to leave out one or more of the three 
stacks. 
These commands put the parser into noninteractive mode. The n command 
generates a log file quickly, without having to watch the whole parse happen 
before your eyes. All screen updating is suppressed and the parse goes on at 
much higher speed than normal. A log file must be active when you use this 
command. If one isn't, you'll be prompted for a file name. You can't get back 
into normal mode once this process is started. The N command runs in nonin­
teractive mode without logging anything. It's handy if you just want to run the 
parser to get an output file and aren't interested in looking at the parse process. 
Section E.8-The Visible Parser 
Listing E.3. Logged Output- Vertical Stacks 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 CODE->public word _tO,_t1,_t2, t3; 
CODE->public word _t4,_t5,_t6,_t7; 
Shift start state 
+---+------------------+ 
0 I 0 I S I -
+---+------------------+ 
Advance past NUM <1> 
Shift <NUM> (goto 2) 
+---+------------------+ 
01 21 NUM I -
11 0 I s I -
+---+------------------+ 
Advance past PLUS <+> 
CODE-> tO = 1 
Reduce by (4) e->NUM 
+---+------------------+ 
0 I 0 I s I -
+---+------------------+ 
(goto 4) 
+---+------------------+ 
0 I 41 
11 0 I e I tO 
S I -
+---+------------------+ 
Shift <PLUS> (goto 6) 
+---+------------------+ 
0 I 61 
11 41 
21 0 I PLUS tO 
e I tO 
s I -
+---+------------------+ 
Advance past NUM <2> 
Shift <NUM> (goto 2) 
+---+------------------+ 
01 21 NUM I 
11 61 PLUS I 
21 41 e I 
31 01 s I 
+---+------------------+ 
Advance past STAR <*> 
CODE-> t1 = 2 tO 
tO tO 
-
q returns you to the operating system. Quit. 851 
r An r forces a STACK-window refresh. The screen-update logic normally Redraw stack window. 
changes only those parts of the STACK window that it thinks should be 
modified. For example, when you do a push, the parser writes a new line into 
the stack window, but it doesn't redraw the already existing lines that 
represent items already on the stack. Occasionally, your value stack can 
become corrupted by a bug in your own code, however, and the default update 
strategy won't show you this problem because it might not update the 
incorrectly modified value stack item. The r command forces a redraw so that 
you can see what's really on the stack. 
w (for write) dumps the screen to an indicated file or device, in a manner analo- Save screen to file. 
gous to the Shift-PrtSc key on an IBM PC. This way you can save a snapshot 
852 LLama and Occs-Appendix E 
Listing E.4. Logged Output-Horizontal Stacks 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 CODE->public word _t0,_t1,_t2,_t3; 
CODE->pub1ic word _t4,_t5,_t6,_t7; 
Shift start state 
PARSE 0 
SYMBOL S 
ATTRIB -
Advance past NUM <1> 
Shift <NUM> (goto 2) 
PARSE 0 2 
SYMBOL S NUM 
ATTRIB -
Advance past PLUS <+> 
CODE-> tO = 1 
Reduce by (4) e->NUM 
PARSE 0 
SYMBOL s 
ATTRIB -
(goto 4) 
PARSE 0 4 
SYMBOL s e 
ATTRIB -tO (e) 
Shift <PLUS> (goto 6) 
PARSE 0 4 6 
SYMBOL S e PLUS 
ATTRIB -tO (e) tO (PLUS) 
Advance past NUM <2> 
Shift <NUM> (goto 2) 
PARSE 0 4 
SYMBOL S e 
ATTRIB -tO 
Advance past STAR 
CODE-> t1 = 2 6 2 
PLUS NUM 
tO tO 
<*> 
of the current screen without having to enable logging. Any IBM box-drawing 
characters used for the window borders are mapped to dashes and vertical 
bars. I used the w command to output the earlier figures. Note that the output 
screen is truncated to 79 characters because some printers automatically print 
a linefeed after the 80th character. This means that the right edge of the box 
will be missing (I put it back in with my editor when I made the figures). 
Display lexeme. X Display both the current and previous lexeme in the comments window. The 
token associated with the current lexeme is always displayed in the tokens 
window. 
E.9 Useful Subroutines and Variables 
There are several useful subroutines and variables available in an occs-or LLama­
generated parser. These are summarized in Table E.4 and are discussed in this section. 
Section E.9-Useful Subroutines and Variables 
void yyparse () 
This subroutine is the parser generated by both occs and LLama. Just call it to 
get the parse started. 
char *yypstk(YYSTYPE *val, char *sym) 
This subroutine is called from the debugging environment and is used to print the 
value stack. It's passed two pointers. The first is a pointer to a stack item. So, if 
your value stack is a stack of character pointers, the first argument will be a 
pointer to a character pointer. The second argument is always a pointer to a 
string holding the symbol name. That is, it contains the symbol stack item that 
corresponds to the value stack item. The returned string is truncated to 50 charac­
ters, and it should not contain any newline characters. The default routine in /.lib 
assumes that the value stack is the default int type. It's shown in Listing E.S. 
This subroutine is used in slightly different ways by occs and LLama, so is dis­
cussed further, below. 
int yy_get_args(int argc, char **argv) 
This routine can be used to modify the size of the stack window and to open an 
input file for debugging. The other windows automatically scale as appropriate, 
and the stack window is not allowed to get so large that the other windows disap­
pear. Typically, yy_get_args () is called at the top of your main () routine, 
before yyparse ( ) is called. The subroutine is passed argv and argc and it 
scans through the former looking for an argument of the form -sN, where N is the 
desired stack-window size. The first argument that doesn't begin with a minus 
sign is taken to be the input file name. That name is not removed from argv. All 
other arguments are ignored and are not removed from argv, so you can process 
them in your own program. The routine prints an error message and terminates 
the program if it can't open the specified input file. Command-line processing 
stops immediately after the input file name is processed. So, given the line: 
program -x -s15 -y foo -sl bar 
argv is modified to: 
program -x -y foo -sl bar 
the file foo is opened for input, and the stack window will be 15 lines high. A 
new value of argc that reflects the removed argument is returned. 
This routine can also be used directly, rather than as a command-line proces­
sor. For example, the following sets up a 17-line stack window and opens testfile 
as the input file: 
char *vects[] = {"", "-s17", "testfile"}; 
yy_get_args( 3, vects ); 
void yy_init_occs (YYSTYPE *tos) 
These routines are called by yyparse ( ) after it has initialized the various 
stacks, but before it has read the first input token. That is, the initial start symbol 
has been pushed onto the state stack, and garbage has been pushed onto the 
corresponding entry on the value stack, but no tokens have been read. The sub­
routine is passed a pointer to the (only) item on the value stack. You can use 
yy _ ini t _aces () to provide a valid attribute for this first value-stack element. 
A user-supplied version of both functions is also useful when main () isn't in the 
occs input file, because it can be used to initialize static global variables in the 853 
The parser subroutine. 
Print value-stack item. 
Change stack-window 
size and specify input file 
to debugger. 
Command-line process­
ing. 
Using yy_get_args() 
directly. 
Initialization functions. 
854 
Table E.4. Useful Subroutines and Variables 
int 
int 
char 
void 
void 
void void yyparse 
yylex 
*yypstk 
yycomment 
yycode 
yydata 
yybss void ) ; 
void ) ; 
void *value 
char *fmt, 
char *fmt, 
char *fmt, 
char *fmt, stack item, char - -
) ; 
) ; 
) ; 
) ; 
int yy_get_args int argc, char **argv ); 
void void void yy_init_occs 
yy_init_llama 
yy_init_lex 
void yyerror 
FILE *yyout 
FILE *yybssout 
FILE *yydataout void ) ; 
void ) ; 
void ) ; 
char *fmt, 
stdout; /* 
stdout; /* 
stdout; /* ... ) ; 
output stream for 
output stream for 
output stream for LLama and Occs-Appendix E 
*symbol stack item ) ; - -
code *I 
bss *I 
data *I 
Listing E.S. yypstk.c- Print Default Value Stack 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 /* Default routine to print user-supplied portion of the value stack. *I 
char 
void 
char 
{ *yypstk(val,sym) 
*val; 
*sym; 
static char buf[32]; 
sprintf( buf, "%d", *(int *)val); 
return buf; 
parser file. It's easy to forget to call an initialization routine if it has to be called 
from a second file. The default subroutines, in /.lib, do nothing. (They are shown 
in Listings E.6 and E.7.) 
Listing E.6. yyinitox.c- Occs User-Initialization Subroutine 
I void yy_init_ox( tos ) void *tos; { } 
Print parser error mes­
sages. void yyerror(char *fmt, ... ) 
This routine is called from yyparse() when it encounters an error, and you should 
use it yourself for error messages. It works like printf (),but it sends output to 
stderr and it adds the current input line number and token name to the front of 
the message, like this: 
Section E.9-Useful Subroutines and Variables 
Listing E.7. yyinitll.c- Default LLama Initialization Function 
I void yy_init_llama( tos ) void *tos; { } 
void 
void void void ERROR (line 00 near TOK) : your message goes here. 
The 00 is replaced by the current line number and TOK is replaced by the sym­
bolic name of the current token (as defined in the occs input file). The routine 
adds a newline at the end of the line for you. 
yycomment(char *fmt, ... ) 
yycode (char *fmt, ... ) 
yydata (char *fmt, ... ) 
yybss (char * fmt, ... ) 
These four subroutines should be used for all your output. They work like 
printf (),but write to appropriate windows when the debugging environment 
is enabled. When the IDE is not active, yycomment writes to standard output 
and is used for comments to the user, yycode ( ) writes to a stream called 
yycodeout and should be used for all code, yydata ( ) writes to a stream called 
yydataout and should be used for all initialized data, yybss ( ) writes to a 
stream called yybssout and should be used for uninitialized data. 
All of these streams are initialized to stdout, but you may change them at any 
time with an fopen ( ) call. Don't use freopen ( ) for this purpose, or you'll 
close stdout. If any of these streams are changed to reference a file the 
debugger sends output both to the file and to the appropriate window. If you for­
get and use one of the normal output routines like puts ( ) or printf (), the 
windows will get messed up, but nothing serious will happen. printf ( ) is 
automatically mapped to yycode if debugging is enabled, so you can use 
print f ( ) calls in the occs input file without difficulty. Using it elsewhere in 
your program causes problems, however. 
void yyprompt(char *prompt, char *buf, int get_str) 
This subroutine is actually part of the debugger itself, but is occasionally useful 
when implementing a debugger hook, described earlier. It prints the prompt 
string in the IDE's prompts window, and then reads a string from the keyboard 
into buf. (there's no boundary checking so be careful about the array size). If 
get_str is true, an entire string is read in a manner similar to gets(), other­
wise only one character is read. If an ESC is encountered, the routine returns 0 
immediately, otherwise 1 is returned. 
E.1 0 Using Your Own Lexical Analyzer 
Occs and LLama are designed to work with a U::X-generated lexical analyzer. You 
can build a lexical analyzer by hand, however, provided that it duplicates U::X's interface 
to the parser. 
You must provide the following subroutines and variables to use the interactive 
debugging environment without a lex-generated lexical analyzer: 855 
Output functions. 
Print a message to the 
prompt window. 
856 
Specifying precedence 
and associativity, %term, 
%left, %right, 
%nonassoc. char *yytext; 
int yylineno; 
int yyleng; 
int yylex(void); 
char *ii_ptext(void); 
int ii_plength(void); 
int ii_mark_prev(void); 
int ii_newfile(char *name); LLama and Occs-Appendix E 
current lexeme 
current input line number 
number of characters in yytext [ ] 
return next token and advance input 
return pointer to previous lexeme 
return length of previous lexeme 
copy current lexeme to previous lexeme 
open new input file 
The scanner must be called yylex ( ) . It must return either a token defined in yyout.h or 
zero at end of file. You'll also need to provide a pointer to the current lexeme called 
yytext and the current input line number in an int called yylineno. The 
ii_ptext () subroutine must return a pointer to the lexeme that was read immediately 
before the current one-the current one is in yytext so no special routine is needed to 
get at it. The string returned from i i _ptext ( ) does not have to be ' \0' terminated. 
Like yyleng, ii _plength ( ) should evaluate the the number of valid characters in 
the string returned from ii _ptext ( ) . ii _mark _prev ( ) should copy the current 
lexeme into the previous one. ii _ newfile ( ) is called when the program starts to 
open the input file. It is passed the file name. The real ii _ newfile ( ) returns a file 
handle that is used by yylex ( ) in turn. Your version of ii _new file ( ) need only do 
whatever is necessary to open a new input file. It should return a number other than -1 
on success, -1 on error. Note that input must come from a file. The debugging routines 
will get very confused if you try to use stdin. 
E.11 Occs 
This section describes occs-speci fie parts of the compiler compiler. A discussion of 
the LLama-speci fie functions starts in Section E.12 
E.11.1 Using Ambiguous Grammars 
The occs input file supports several % directives in addition to the ones discussed ear­
lier. (All occs directives are summarized in Table E.S. They will be described in this 
and subsequent sections.) 
A definitions section for a small expression compiler is shown in Listing. E.8. The 
analyzer will recognize expressions made up of numbers, identifiers, parentheses, and 
addition and multiplication operators (+and *). Addition is lower precedence than mul­
tiplication and both operators associate left to right. The compiler outputs code that 
evaluates the expression. The entire file, from which the definitions section was 
extracted, appears at the end of the occs part of this appendix. 
Terminal symbols are defined on lines one to six. Here, the %term is used for those 
terminal symbols that aren't used in expressions. %left is used to define left­
associative operators, and %right is used for right-associative operators. (A %nonas­
soc directive is also supplied for declaring nonassociative operators.) The higher a 
%left, %right, or %nonassoc is in the input file, the lower its precedence. So, PLUS 
is lower precedence than STAR, and both are lower precedence than parentheses. A 
%term or %token is not needed if a symbol is used in a %left, %right, or %nonas­
soc. The precedence and associativity information is used by occs to patch the parse 
tables created by an ambiguous input grammar so that the input grammar will be parsed 
correctly. 
Section E.11.1 -Using Ambiguous Grammars 857 
Table E.5. Occs % Directives and Comments 
Directive Description 
%% Delimits the three sections of the input file. 
%{ Starts a code block. All lines that follow, up to a % } are written to the output file unchanged. 
%} Ends a code block. 
%token Defines a token. 
%term A synonym for %token. 
/* *I C-like comments are recognized-and ignored-by occs, even if they're outside of a % { %} 
delimited code block. 
%left Specifies a left-associative operator. 
%right Specifies a right-associative operator. 
%nonassoc Specifies a nonassociative operator. 
%prec Use in rules section only. Modifies the precedence of an entire production to resolve a 
shift/reduce conflict caused by an ambiguous grammar. 
%union Used for typing the value stack. 
%type Attaches %union fields to nonterminals. 
Listing E.S. expr.y-occs Definitions Section for a Small Expression Compiler 
1 %term ID I* a string of lower-case characters *I 
2 %term NUM I* a number *I 
3 
4 %left PLUS I* + *I 
5 %left STAR I* * *I 
6 %left LP RP I* *I 
7 
8 %{ 
9 #include <stdio.h> 
10 #include <ctype.h> 
11 #include <stdlib.h> 
12 
13 extern char *yytext; I* In yylex (), holds lexeme *I 
14 extern char *new_name(); I* declared at bottom of this file 
15 
16 typedef char *stype; I* Value stack *I 
17 #define YYSTYPE stype 
18 
19 #define YYMAXDEPTH 64 
20 #define YYMAXERR 10 
21 #define YYVERBOSE 
22 %} 
Most of the grammars in this book use recursion and the ordering of productions to 
get proper associativity and precedence. Operators handled by productions that occur 
earlier in the grammar are of lower precedence; left recursion gives left associativity; 
right recursion gives right associativity. This approach has its drawbacks, the main one 
being a proliferation of productions and a correspondingly larger (and slower) state 
machine. Also, in a grammar like the following one, productions like 2 and 4 have no 
purpose other than establishing precedence-these productions generate single­
reduction states, described in Chapter Five. *I 
858 
Accessing bottom-up at­
tributes, $$, $1, etc. 
Default action: $$=$1. 
Attributes and E produc­
tions. 
Typing the value stack. 0. s ~ e 
1. e ~ e+t 
2. I t 
3. ~ t*f 
4. I f 
5. f ~ (e) 
6. 
7. I NUM 
I ID 
Occs lets you redefine the foregoing grammar as follows: 
%term NUM ID 
%left PLUS 
%left STAR 
%left LP RP 
%% 
s 
e 
%% I* + *I 
I* * *I 
I* *I 
e 
e PLUS e 
e STAR e 
LP e RP 
NUM 
ID LLama and Occs-Appendix E 
The ambiguous grammar is both easier to read and smaller. It also generates smaller 
parse tables and a somewhat faster parser. Though the grammar is not LALR(l), parse 
tables can be built for it by using the disambiguation rules discussed in Chapter Five and 
below. If there are no ambiguities in a grammar, %left and %right need not be 
used-you can use %term or %token to declare all the terminals. 
E.11.2 Attributes and the Occs Value Stack 
The occs parser automatically maintains a value stack for you as it parses. More­
over, it keeps track of the various offsets from the top of stack and provides a simple 
mechanism for accessing attributes. The mechanism is best illustrated with an example. 
In S~A B C, the attributes can be accessed as follows: 
S A B C 
$$ $1 $2 $3 
That is, $$ is the value that is inherited by the left-hand side after the reduce is per­
formed. Attributes on the right-hand side are numbered from left to right, starting with 
the leftmost symbol on the right-hand side. The attributes can be used anywhere in a 
curly-brace-delimited code block. The parser provides a default action of $$=$1 which 
can be overridden by an explicit assignment in an action. (Put a $$ to the left of an 
equals sign [just like a variable name] anywhere in the code part of a rule.) 
The one exception to the $$=$1 rule is an E production (one with an empty right­
hand side)-there's no $1 inanE production. A reduce by an E production pops nothing 
(because there's nothing on the right-hand side) and pushes the left-hand side. Rather 
than push garbage in this situation, occs duplicates the previous top-of-stack item in the 
push. Yacc pushes garbage. 
By default, the value stack is of type int. Fortunately, it's easy to change this type. 
Just redefine YYSTYPE in the definitions section of the input file. For example, the 
expression compiler makes the value stack a stack of character pointers instead of ints 
Section E.11.2- Attributes and the Occs Value Stack 
with the following definitions: 
%{ 
typedef char *stype; 
#define YYSTYPE stype 
%} 
The typedef isn't needed if the stack is redefined to a simple type (int, lonq, float, 
double, and so forth). Given this definition, you could use $1 to modify the pointer 
itself and * $1 to modify the object pointed to. (In this case, * $1 modifies the first char­
acter of the string.) A stack of structures could be defined the same way: 
%{ 
typedef struct 
{ 
int harpo; 
long groucho; 
double chico; 
char zeppo [ 10]; 
stype; 
#define YYSTYPE stype 
%} 
You can use $1.harpo, $2.zeppo[3], and so forth, to access a field. You can also 
use the following syntax: $<harpo>$, $<chico>1, and so forth-$<chico>1 is 
identical to $1 . chi co. following statements: 
Input Expanded to 
$$ Yy_val 
$N in the rules section yysp [ constant ] 
$N in the code section yysp[ (Yy rhslen -constant) ] 
yysp is the value-stack pointer. Yy _ rhslen is the number of symbols on the right­
hand side of the production being reduced. The constant is derived from N, by adjusting 
for the size of the right-hand side of the current production. For example, in a produc­
tion like 
S : A B C ; 
$1, $2, and $3 evaluate to the following: 
Yy_vsp[ -2 ] /* $1 */ 
Yy_vsp[ -1 ] /* $2 */ 
Yy_vsp[ -0 ] /* $3 */ 
Be careful of saying something like $$=$2 if you've defined YYSTYPE as a structure. Copying Structures. 
The whole structure is copied in this situation. (Of course, if you want the whole struc-
ture to be copied ... ) Note that the default action ($$=$1) is always performed before 
any of the actions are executed, and it affects the entire structure. Any specific action 
modifies the default action. This means that you can let some fields of a structure be 
inherited in the normal way and modify others explicitly. For example, using our earlier 
structure, the following: 
{ $$.harpo = 5; } 
modifies the harpo field, but not the groucho, chico, or zeppo fields, which are 
inherited from $1 in the normal way. 859 
860 LLama and Occs-Appendix E 
The entire 24-byte structure is copied at every shift or reduce. Consequently, it's 
worth your effort to minimize the size of the value-stack elements. Note that the parser 
is built assuming that your compiler supports structure assignment. If this isn't the case, 
you'll have to modify the parser to use memcpy ( ) to do assignments. 
Occs' attribute support is extended from that of yacc in that dollar attributes can be 
used in both the rules and code sections of the input specification (yacc permits them 
only in the rules section). Occs treats $ 0 as a synonym for $$. Finally, occs permits 
negative attributes. Consider the following: 
s : X A B C 
b : E { $$ = $-1 + S-2 }; 
Negative attributes ($-1). The$ -1 evaluates to the attributes for the symbol immediately below the Eon the value 
stack. To see what the negative attributes are doing, consider the condition of the stack 
just before the reduce by b~E: 
%union-Automatic 
field-name generation. $1 references the attributes associated with E in the normal way; $-1 references A's 
attributes, and $-2 references X's attributes. Occs normally prints an error message if 
you try to reference an attribute that's outside the production (if you tried to use $3 on a 
right-hand side that had only two elements, for example). It's possible to reference off 
the end of the stack if the numbers get too negative, however-no error message is 
printed in this case. For example, a $-3 in the earlier example just silently evaluates to 
garbage (the start symbol doesn't have any attributes). 
Now, look closely at the attribute-passing mechanism for the expression compiler, 
reproduced below: 
e e PLUS e gen("%s += %s;", $1' $3) ; free name( $3 ) ; 
-
e STAR e gen("%s *= %s; "' $1, $3) ; free name( $3 ) ; -
LP e RP S$ = $2; 
NUM gen("%s %3; II I $$ new name(), yytext ) ; -ID gen("%s = %s;", $$ new name(), yytext ) ; 
The e~NUM and e~ID actions on lines four and five are identical. They output a 
move instruction and then put the target of the move (the name of the rvalue) onto the 
value stack as an attribute. The $$=$2 in the e~LP e RP action on the third line just 
moves the attribute from the e that's buried in the parentheses to the one on the left-hand 
side of the production. The top two productions are doing the real work. To see how 
they function, consider the sample parse of A+2 in Figure E.5. The transition of interest 
is from stack picture six to seven. t 0 and t 1 were put onto the stack when the rvalues 
were created (and they're still there). So, we can find the temporaries used for the 
rvalues by looking at $1 and $2. The inherited attribute is the name of the temporary 
that holds the result of the addition. 
Because the value stack is more often then not typed as a union, a mechanism is 
provided to keep track of the various fields and the way that they attach to individual 
symbols. This mechanism assumes a common practice, that specific fields within a union 
are used only by specific symbols. For example, in a production like this: 
e : e divop e 
where di vop could be either a I or% (as in C), you would need to store one of two attri­
butes on the value stack. The attribute attached to the e would be a pointer to a string 
holding the name of a temporary variable; the attribute attached to the di vop would be 
'I' for divide and '%'for a modulus operation. To do the foregoing, the value stack must 
be typed to be a union of two fields, one a character pointer and the other an int. You 
could do this using an explicit redefinition of YYSTYPE, as discussed earlier: 
Section E.ll.2-Attributes and the Occs Value Stack 
Figure E.5. A Parse of A*2 
I. ~~ ............................. ~ ........................ . 
2. 1~·-· ......... w-..................................... .. 
3. 1~-........... ~ii:i ..................................... . 
4. l~··· ......... ~ii:i ..... ~~~ ..................... .. 
5. ~~ ............ ~ii:i ..... ~~~ ..... ~w. ....... . 
6. ~~ ............ ~.ii:i ..... ~~~ ......... k ........ .. 
7. ~~ ............ ~ii:i ..................................... . 
8. ~~-.. ·~··· .. ·~~=~==== 
typedef union 
{ 
char *var name 
int op_type 
yystype; 
#define YYSTYPE yystype tO -A; 
tl -2; 
tO *-_tl; 
(Accept) 
but the %union directive is a better choice. Do it as follows: 
%union { 
char *var name 
int op type ; 
A %union activates an automatic field-name generation feature that is not available if 
you just redefine YYSTYPE. Given the earlier production (e : e DIVOP e), we'd like 
to be able to say $$, $1, and so forth, without having to remember the names of the 
fields. That is, you want to say 
$1 =new name(); 
rather than 
$1.var name= new_name(); 
Do this, first by using the %union, and then attaching the field names to the individual 
terminal and nonterminal symbols with a <name> operator in token-definition directive <name> and %type 
(%term, %left, etc.) or a %type directive. The name can be any field name in the 
%union. For example: 
%term <op_type> DIVOP 
%type <var name> e 
attaches the op type field to all DIVOPs and the var _name field to all e's. That is, if a 
<name> is found in a %term, %token, %left, %right, or %nonassoc directive, the 
indicated field name is automatically attached to the specified token. The angle brackets 
are part of the directive. They must be present, and there may not be any white space 
between them and the actual field name. The %type directive is used to attach a field 
name to a nonterminal. 861 
862 
$<field>N LLama and Occs-Appendix E 
Listing E.9. union.y- Using %union: An Example 
%union ( 
int. op_type; 
3 char *var_name; 
4 I 
5 
6 \term DIVOP /* I or i */ 
7 %type <var name> e statement 
8 \type <op_type> divop 
9 
10 %% 
II goal statement 
12 
13 
14 statement e divop e 
15 I 
16 if($2=='/'1 
17 gen( "%s I= %s;", Sl, S3 ) 
18 •h• 
19 gen( "%s •= \s;", $1, 53 I 
20 
21 free name ( $3 I; 
22 $$ =-Sl 
23 
24 
25 dlVOp DJVOP I SS = •yyte:<t; I 
26 
27 H 
A real example of all the foregoing is in Listing E.9. The grammar recognizes a sin­
gle statement made up of two numbers separated by a DIVOP, which can be a I or %. 
The $ $ in the di vop rule on line 25 references the op _type field of the union because 
divop is attached to that field on line eight. Similarly, the $2 on line 16 references the 
op _type field because $2 corresponds to a di vop in this production, and di vop was 
attached to op _type on line eight. The $1 and $ 3 on lines 17, 19, 21, and 22 reference 
the var _name field because they correspond to an e in the production and were attached 
to e on line seven. Similarly the $$ on line 22 references var _name because it 
corresponds to a statement, which was also attached to a var _name on line seven. 
The field stays active from the point where it's declared to the end of the current 
directive. For example, in 
%token ONE <field!> TWO THREE <field2> FOUR 
<fieldl> is attached to TWO and THREE, and <field2> is attached to FOUR. ONE has 
no field attached to it. If a $$ or $N corresponds to a symbol that has no explicit 
%union field attached to it, a default int-sized field is used and a warning message is 
printed. 12 Also, note that the nonterrninal name on the left-hand side of a production 
must be found in a previous %type in order to use $$ in the corresponding right-hand 
side. The %type directive can have more than one nonterrninal symbol listed in it, but it 
may have only one <name> and the name must be the first thing in the list. Similarly, 
the <name> in a %left and so forth applies only to those terminals that follow it in the 
list. 13 
The $<.field>N syntax described earlier can also be used to access a field of a 
%union. This syntax takes precedence over the default mechanism, so you can use it 
12. Yacc doesn't print the warning. 
13. Yacc is very picky about type matching when you use this mechanism. Since this pickyness is now 
supported by most compilers, I've not put any type checking into occs. It just stupidly makes the 
substitutions discussed earlier. 
Section E.II.2-Attributes and the Occs Value Stack 
when you want to override the default field for a particular symbol. It's also useful in 
imbedded actions where there's no mechanism for supplying a field name to $$. For 
example, in: 
%union { integer } 
%% 
x a { $<integer>$= 1; } b { foo( $<integer>2 ); 
The $<integer>$ is used to put 1 into the integer field of the synthesized attribute. 
That number is later referenced using the $<integer>2 in the second action. Since the 
field type is an integer, you could also use the default field as follows: 
x a { $$ = 1: } b { foo ($2); 
but occs prints a warning message when no field is specified, as is the case here. (Yacc 
doesn't print the warning). 863 
Occs translates all %unions into a typedef and redefinition of YYSTYPE. The typedef for %union: 
foregoing example is output as follows: yystype. 
typedef union 
{ 
int yy_def; 
char *var name 
int op_type 
yystype; 
#define YYSTYPE yystype 
The YYSTYPE definition is generated automatically. Both it and the yystype type name 
will be useful later on. The yy _de f field is used for the default situation, where the 
symbol specified in a dollar attribute has not been attached to an explicit symbol. For 
example, if the following production is found without a preceding %type <field> e 
t: 
t : e PLUS e { $$ = $1 + $3; } ; 
the yy _ def field will be used for both$$ (because there's no field attached to the t) and 
for $1 and $2 (because there's no field attached to thee either). 
E.11.3 Printing the Value Stack 
If you're using the default stack type of int you don't have to do anything special to 
print the value stack in the debugging environment because the default stack-printing 
routine, yypstk( ), will be called in from the library. The library version of this routine 
assumes a stack of integers. 
If you've changed the stack type, either by redefining the YYSTYPE or macro or by 
using a %union, you'll need to provide a version of the yypstk () function for the 
debugger to use. The function is passed a pointer to a value-stack element and a second 
pointer to the equivalent symbol-stack element. It must return a pointer to a string that 
represents the value-stack element. 
If the value stack is a simple type, such as a stack of character pointers, then printing 
the stack contents is easy: Printing an int value 
stack. 
Printing a non-int value 
stack. 
864 
typedef char *stack_type ; 
#define YYSTYPE stack_type 
%% 
%% 
char *yypstk( value, symbol ) 
YYSTYPE *value; 
char *symbol; 
{ 
return *value; LLama and Occs-Appendix E 
/* productions go here */ 
/* pointer to a character pointer */ 
When the value stack is typed with a %union, things are a little more complicated. 
Listing E. I 0 shows how the value stack for the earlier example would be printed. The 
%union forces the value stack to be an array of yystypes, and a pointer to one element 
of this array is passed to yypstk (). The second, symbol argument to yypstk () is 
used to select the correct field of the union. 
Listing E.lO. yypstk2.c- Printing Attributes for a %union 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 %union { 
int op_type; 
char *var_name; 
%term DIVOP 
%type <var name> e statement 
%type <op_type> divop 
%% 
%% 
yypstk ( 
yystype 
char 
{ value, symbol 
*value; 
*symbol; 
static char buf[80]; /* I or % */ 
if( !strcmp(symbol,"e") II !strcmp(symbol,"statement") 
return value->var name 
if( !strcmp(symbol,"divop") ) 
{ 
else sprintf( buf, "%c", value->op_type ); 
return buf; 
return "---"; /* other symbols don't have attributes in this 
/* application. *I 
*I 
If you were using the default, int attribute field in the union, the return 11 
statement on line 27 would be replaced with the following: 
sprintf( buf, "%d", value->yy_def ); 
return buf; II 
Section E.11.4 -Grammatical Transformations 865 
E.11.4 Grammatical Transformations 
Imbedded actions (ones that are in the middle of a production) can be used in an occs Imbedded actions. 
grammar, but you have to be careful with them. The problem is that actions can be exe-
cuted only during a reduction. Consequently, if you put one in the middle of a produc-
tion, occs has to shuffle the grammar by adding an E production. For example: 
s a { action(1);} b c { action(2);} 
is modified by occs as follows: 
s a 0001 b c { action(2); } ; 
0001 : { action (1); } 
Unfortunately, that extra E production can introduce shift/reduce conflicts into the state 
machine. It's best, if possible, to rewrite your grammar so that the imbedded production 
isn't necessary: 
s :prefix b c { action(2); }; 
prefix: a { action(1); }; 
Using the attribute mechanism is also a little tricky if you imbed an action in a pro­
duction. Even though imbedded actions are put in their own production, the $1, $2, and 
so forth reference the parent production. That is, in: 
s : a b { $$ = $1 + $2 } c {$$ = $1 + $2 + $3 + $4} ; 
the $1 and $2 in both actions access the attributes associated with a and b. $$ in the left 
action is accessed by $3 in the right action. (That is, this$$ is actually referencing the 
0001 left-hand side inserted by occs.) The$$ in the right action is attached to s in the 
normal way. $4 accesses c. Note that $3 and $4 are illegal in the left action because 
they won't be on the parse stack when the action is performed. An error message is gen­
erated in this case, but only if the reference is in the actual grammar section of the yacc 
specification. Illegal stack references are silently accepted in the final code section of 
the input file. 
Occs supports the two non-yacc transformations. Brackets are used to designate 
optional parts of a production. The following input: 
s:a[b]c; 
is translated internally to: 
s a 001 c 
001 b 
/* epsilon */ 
Note that attributes in optional productions can be handled in unexpected ways (which 
actually make sense if you consider the translation involved). For example, in: 
s->a [bc{$$=$1+$2;}] d {$$=$1+$2+$3;} 
The$ $=$1 +$2 in the optional production adds the attributes associated with band c and 
attaches the result to the entire optional production. The action on the right adds 
together the attributes associated with a, the entire optional production be and d. That is, 
$2 in the right production is picking up the $$ from the optional production. Note that 
the $2 used in the right action is garbage if the E production was taken in the optional 
part of the production. As a consequence, optional productions are typically not used 
when attributes need to be passed. Optional subexpressions, 
[ ... ]. 
866 
Repeating subexpres­
sions. [ ... 1 *. Optional productions nest. The following is legal: 
s -> a [ b [c] [d [e]] J f LLama and Occs-Appendix E 
though almost incomprehensible-1 wouldn't recommend using it. The maximum nest­
ing level is 8. Note that optional subexpressions can introduce duplicate productions. 
That is: 
s b [c] d 
I e [c] 
creates: 
s b 001 d 
e 002 
001 c 
/* epsilon */ 
002 c 
/* epsilon */ 
It's better to use the following in the original grammar: 
s 
opt_c b opt_c d 
e opt_c 
c 
/* empty */ 
Also note that 
s : [x] ; 
is acceptable but needlessly introduces an extra production: 
s : 001 ; 
001 : x I /* empty */ ; 
It's better to use: 
s : x I /* empty */ ; 
Adding a star after the right bracket causes the enclosed expression to repeat zero or 
more times. A left-associative list is used by occs; a right-associative list is used by 
LLama. The internal mappings for all kinds of brackets are shown in the Table E.6. 
You can't use this mechanism if you need to pass attributes from b back up to the parent, 
primarily because you can't attach an action to the added E production. The extra E pro­
duction may also add shift/reduce or reduce/reduce conflicts to the grammar. Be careful. 
Some examples-a comma-separated list that has at least one element is: 
s : a [ COMMA a ] * ; 
A dot-separated list with either one or two elements is: 
s : a [DOT a] ; 
One or more repetitions of b is: 
s : a b [b] * c ; 
Section E.11.4-Grammatical Transformations 
Table E.6. Occs Grammatical Transformations 
Input Output 
s : a [b] c i s : a 001 c 
001 : b I I* epsilon *I ; 
s : a [b] * c i s : a 001 c (occs version) 
001 : 001 b I I* epsilon *I i 
s : a [b] * c i s : a 001 c (llama version) 
001 : b 001 I I* epsilon *I ; 
E.11.5 The yyout.sym File 
You can see the transformations made to the grammar, both by adding imbedded 
actions and by using the bracket notation for optional and repeating sub-productions, by 
looking in the symbol-table file, yyout.sym, which will show the transformed grammar, 
not the input grammar. The symbol-table file is generated if -D, -S, or-sis specified on 
the command line. A yyout.sym for the grammar in Listing E.2 on page 841 is in Listing 
E. II. (It was generated with occs -s expr. y .) 
Listing E.ll. yyout.sym- Occs Symbol-Table Output 
---------------- Symbol table ------------------
NONTERMINAL SYMBOLS: 
e (257) <> 
FIRST : ID NUM LP 
5: e -> ID 
4: e -> NUM 867 
Generating the symbol 
table, yyout.sym, -0, 
-S, -s. 
I 
2 
3 
4 
5 
6 
7 
8 
9 3: e -> LP e RP ............................................ PREC 3 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 2: e -> e STAR e ........................................... PREC 2 
1: e -> e PLUS e ........................................... PREC 1 
s (256) (goal symbol) <> 
FIRST : ID NUM LP 
0: s -> e 
TERMINAL SYMBOLS: 
name value prec as soc field 
STAR 4 2 1 <> 
RP 6 3 1 <> 
PLUS 3 1 1 <> 
NUM 2 0 <> 
ID 1 0 <> 
LP 5 3 1 <> 
Taking a few lines as a representative sample: 
e (257) <> 
FIRST : ID NUM LP 
5: e -> ID 
4: e -> NUM 
3: e -> LP e RP .................................... PREC 3 
868 
A %union <field> in 
yyout.sym. 
The FIRST set in 
yyout.sym. 
Right-hand sides in 
yyout.sym, production 
numbers. 
Precedence, associativity 
in yyout.sym. 
Modified productions are 
shown. 
LALR(1) states in 
yyout.doc LLama and Occs-Appendix E 
the top line is the name and internal, tokenized value for the left-hand side. The <> on 
the right contains the field name assigned with a %type directive. Since there was none 
in this example, the field is empty. Had the following appeared in the input: 
%type <field> e 
the <field> would be on the corresponding line in the symbol table. The next line is 
the symbol's FIRST set. (The list of terminal symbols that can appear at the far left of a 
parse tree derived from the nonterminal.) That is, it's the set of tokens which can legiti­
mately be next in the input when we're looking for a given symbol in the grammar. 
Here, we're looking for an e, and an ID, NUM, or LP. can all start an e. The FIRST sets 
are output only if the symbol table is created with -S. 
The next few lines are the right-hand sides for all productions that share the single 
left-hand side. The number to the left of the colon is the production number. These are 
assigned in the order that the productions were declared in the source file. The first pro­
duction is 0, the second is I, and so forth. Note that the production that has the goal 
symbol on its left-hand side is always Production 0. Production numbers are useful for 
setting breakpoints in the interactive debugging environment. (You can set a breakpoint 
on reduction by a specific production, provided that you know its number.) The PREC 
field gives the relative precedence of the entire production. This level is used for resolv­
ing shift/reduce conflicts, also discussed below. Note that the productions shown in this 
table are the ones actually used by occs-any transformations caused by imbedded 
actions or the [ ] operator are reflected in the table. Productions are sorted alphabeti­
cally by left-hand side. 
The second part of the table gives information about the terminal symbols. For 
example: 
name 
PLUS 
NUM value prec assoc 
3 1 1 
2 0 field 
<> 
<> 
Here, 3 is the internal value used to represent the PLUS token. It is also the value 
assigned to a PLUS in yyout.h. The prec field gives the relative precedence of this sym­
bol, as assigned with a %left, %right, or %nonassoc directive. The higher the 
number, the higher the precedence. Similarly, the assoc is the associativity. It will 
have one of the following values: 
1 left associative 
r right associative 
n nonassociative 
Associativity is not specified. The token was declared with a %term or 
%token rather than a %left, %right, or %nonassoc directive. 
Finally, the field column lists any %union fields assigned with a <name> in the 
%left, %right, and %nonassoc directives. A<> is printed if there is no such assign­
ment. 
E.11.6 The yyout.doc File 
The yyout.doc file holds a description of the LALR( I) state machine used by the 
occs-generated parser. It is created if -v or -Vis present on the command line. The 
yyout.doc file for the grammar in Listing E.2 on page 84I is shown in Table E.7. Figure 
E.6 shows the state machine in graphic form. 
This machine has ten states, each with a unique number (running from 0 to 9). The 
top few lines in each state represent the LALR(l) kernel items. You can use them to see 
Section E.11.6-The yyout.doc File 
the condition of parse stack when the current state is reached. For example, the header 
from State 9 looks like this: 
State 9: 
e->e .PLUS e 
e->e PLUS e . [$ PLUS STAR RP] 
e->e .STAR e 
The dot is used to mark the current top of stack, so everything to the left of the dot will 
be on the stack. The top-of-stack item in State 9 is an e because there's an e immediately 
to the left of the dot. The middle line is telling us that there may also be a PLUS and 
another e under the e at top of stack. 
If the dot is at the far right (as it is on the middle line), then a handle is on the stack 
and the parser will want to reduce. The symbols in brackets to the right of the pr(l)duc­
tion are a list of those symbols that (at least potentially) cause a reduction if they'r~ the 
next input symbol and we are in State 9. (This list is the LALR(l) lookahead set for the 
indicated LR item, as discussed in Chapter Five.) The lookahead set is printed for every 
kernel item (as compared to only those items with the dot at the far right) if -V is used 
rather than -v. Note that these are just potential reductions, we won't necessarily do the 
reduction on every symbol in the list if there's a conflict between the reduction and a 
potential shift. A $ is used in the lookahead list to represent the end-of-input marker. 
The next lines show the possible transitions that can be made from the current state. 
There are four possibilities, which will look something like the following: 
Reduce by 3 on PLUS 
says that a reduction by Production 3 occurs if the next input symbol is a PLUS. 
Shift to 7 on STAR 
says that a 7 is shifted onto the stack (and the input advanced) if the next input symbol is 
a STAR. 
Goto 4 on e 
takes care of the push part of a reduction. For example, starting in State 0, a NUM in the 
input causes a shift to State 2, so a 2 is pushed onto the stack. In State 2, a PLUS in the 
input causes a reduce by Production 4 (e~NUM), which does two things. First, the 2 is 
popped, returning us to State 0. Next, the parser looks for a goto transition (in State 0) 
that is associated with the left-hand side of the production by which we just reduced. In 
this case, the left-hand side is an E, and the parser finds a Goto 4 on e in State 0, so a 
4 is pushed onto the stack as the push part of the reduction. The final possibility, 
Accept on end of input 
says that if the end-of-input marker is found in this state, the parse is successfully ter­
minated. 869 
Symbols that cause 
reductions in yyout.doc 
state. 
Transitions in yyout.doc, 
shift, reduce, accept. 
870 LLama and Occs-Appendix E 
Table E.7. yyout.doc (Generated from Listing E.2) 
State 0: 
s->.e 
Shift to 1 on ID 
Shift to 2 on NUM 
Shift to 3 on LP 
Goto 4 on e 
State 1: 
e->ID [$ PLUS STAR RP ] 
Reduce by 5 on End of Input 
Reduce by 5 on PLUS 
Reduce by 5 on STAR 
Reduce by 5 on RP 
State 2: 
e->NUM [$ PLUS STAR RP ] 
Reduce by 4 on End of Input 
Reduce by 4 on PLUS 
Reduce by 4 on STAR 
Reduce by 4 on RP 
State 3: 
e->LP .e RP 
Shift to 1 on ID 
Shift to 2 on NUM 
Shift to 3 on LP 
Goto 5 on e 
State 4: 
s->e [$ l 
e->e .PLUS e 
e->e .STAR e 
Accept on end of input 
Shift to 6 on PLUS 
Shift to 7 on STAR 
State 5: 
e->e .PLUS e 
e->e .STAR e 
e->LP e .RP 
Shift to 6 on PLUS 
Shift to 7 on STAR 
Shift to 8 on RP State 6: 
e->e PLUS .e 
Shift to 1 on ID 
Shift to 2 on NUM 
Shift to 3 on LP 
Goto 9 on e 
State 7: 
e->e STAR .e 
Shift to 1 on ID 
Shift to 2 on NUM 
Shift to 3 on LP 
Goto 10 on e 
State 8: 
e->LP e RP [$ PLUS STAR RP 
Reduce by 3 on End of Input 
Reduce by 3 on PLUS 
Reduce by 3 on STAR 
Reduce by 3 on RP 
State 9: 
e->e .PLUS e 
e->e PLUS e [$ PLUS STAR RP] 
e->e .STAR e 
Reduce by 1 on End of Input 
Reduce by 1 on PLUS 
Shift to 7 on STAR 
Reduce by 1 on RP 
State 10: 
e->e .PLUS e 
e->e .STAR e 
e->e STAR e [$ PLUS STAR RP] 
Reduce by 2 on End of Input 
Reduce by 2 on PLUS 
Reduce by 2 on STAR 
Reduce by 2 on RP 
6/254 
2/256 
6/512 
11 terminals 
nonterminals 
productions 
states 
Section E.ll.6-The yyout.doc File 
Figure E.6. State Machine Represented by the yyout.doc File in Listing E. II 
e NUM 
ID 
LP 
ID 
ID ID 
NUM NUM 
E.11.7 Shift/Reduce and Reduce/Reduce Conflicts 
One of the main uses of the yyout.doc file is to see how shift/reduce and 
reduce/reduce conflicts are solved by occs. You should never let a WARNING about an 
inadequate state go by without looking in yyout.doc to see what's really going on. 
Occs uses the disambiguating rules discussed in Chapter Five to resolve conflicts. 
Reduce/reduce conflicts are always resolved in favor of the production that occurred ear­
lier in the grammar. Shift/reduce conflicts are resolved as follows: 
(l) Precedence and associativity information is assigned to all terminal symbols using 
%left, %right, and %nonassoc directives in the definitions part of the input file. 
The directives might look like this: 871 
Resolving shift/reduce 
and reduce/reduce 
conflicts. 
872 
Using %prec. %left PLUS MINUS 
%left TIMES DIVIDE 
%right ASSIGN LLama and Occs-Appendix E 
The higher a directive is in the list, the lower the precedence. If no precedence or 
associativity is assigned, a terminal symbol will have a precedence level of zero 
(very low) and be nonassociative. 
Productions are assigned the same precedence level as the rightmost terminal sym­
bol in the production. You can override this default with a %prec TOKEN direc­
tive to the right of the production. (It must be between the rightmost symbol in the 
production and the semicolon or vertical bar that terminates the production). 
TOKEN is a terminal symbol that was declared with a previous %left, %right, or 
%nonassoc, and the production is assigned the same precedence level as the indi­
cated token. Occs, but not yacc, also allows statements of the form 
%prec number 
where the number is the desired precedence level (the higher the number, the 
higher the precedence). The number should be greater than zero. 
(2) When a shift/reduce conflict is encountered, the precedence of the terminal symbol 
to be shifted is compared with the precedence of the production by which you want 
to reduce. If the terminal or production is of precedence zero, then resolve in favor 
of the shift. 
(3) Otherwise, if the precedences are equal, resolve using the following table: 
associativity of resolve in favor of lookahead symbol 
left reduce 
right shift 
nonassociati ve shift 
( 4) Otherwise, if the precedences are not equal, use the following table: 
precedence resolve in favor of 
lookahead symbol < production reduce 
lookahead symbol > production shift 
The %prec directive can be used both to assign a precedence level to productions 
that don't contain any terminals, and to modify the precedences of productions in which 
the rightmost non terminal isn't what we want. A good example is the unary minus 
operator, used in the following grammar: 
%term 
%left 
%left NUM 
MINUS PLUS 
TIMES 
%nonassoc VERY HIGH 
%% 
s e 
e e PLUS e 
e MINUS e 
e TIMES e 
%% MINUS e %prec VERY HIGH 
NUM 
Here, the %precis used to force unary minus to be higher precedence than both binary 
Section E. II. 7 -Shift/Reduce and Reduce/Reduce Con flicts 
minus and multiplication. VERY _HIGH is declared only to get another precedence 
level for this purpose. Occs also lets you assign a precedence level directly. For exam­
ple, 
I MINUS e %prec 4 
could have been used in the previous example. 14 C's sizeof operator provides another 
example of how to use %pre c. The precedence of sizeof must be defined as follows: 
expression : SIZEOF LP type_name RP %prec SIZEOF 
in order to avoid incorrectly assigning a sizeof the same precedence level as a right 
parenthesis. 
The precedence level and %prec operator can also be used to resolve shift/reduce 
conflicts in a grammar. The first technique puts tokens other than operators into the pre­
cedence table. Consider the following state (taken from yyout.doc). 
WARNING: State 5: shift/reduce conflict ELSE/40 (choose shift) 
State 5: 
stmt-> IF LP expr RP stmt. 
IF LP expr RP stmt. ELSE stmt 
The default resolution (in favor of the shift) is correct, but it's a good idea to eliminate 
the warning message (because you don't want to clutter up the screen with harmless 
warning messages that will obscure the presence of real ones). You can resolve the 
shift/reduce conflict as follows. The conflict exists because ELSE, not being an opera­
tor, is probably declared with a %term rather than a %left or %right. Consequently, it 
has no precedence level. The precedence of the first production is taken from the RP 
(the rightmost terminal in the production), so to resolve in favor of the shift, all you need 
do is assign a precedence level to ELSE, making it higher than RP. Do it like this: 
%left LP RP /* existing precedence of LP */ 
%nonassoc ELSE /* higher precedence because it follows LP */ 
Though you don't want to do it in the current situation, you could resolve in favor of the 
reduce by reversing the two precedence levels. (Make ELSE lower precedence than 
LP). 
The second common situation is illustrated by the following simplification of the C 
grammar used in Chapter Six. (I've left out some of the operators, but you get the idea.) 
function_argument 
expr 873 
Using %prec to resolve 
shift/reduce conflicts. 
function_argument COMMA expr /* comma separates arguments */ 
expr 
expr STAR 
expr COMMA 
expr DIVOP 
term expr 
expr 
expr /* comma operator */ 
A shift/reduce conflict is created here because of the COMMA operator (the parser 
14. Yacc doesn't permit this. You have to use a bogus token. 
874 LLama and Occs-Appendix E 
doesn't know if a comma is an operator or a list-element separator), and this conflict is 
displayed in yyout.doc as follows: 
WARNING: State 170: shift/reduce conflict COMMA/102 (choose shift) 
State 170: 
function_argument-> expr. (prod. 102, prec. 0) 
[COMMA RP ] 
expr-> expr. STAR expr 
expr-> expr. COMMA expr 
expr-> expr. DIVOP expr 
The problem can be solved by assigning a precedence level to production 102: 
function_argument~expr. (It doesn't have one because there are no terminal symbols in 
it). You can resolve in favor of the reduce (the correct decision, here) by giving the pro­
duction a precedence level greater than or equal to that of the comma. Do this in the 
input file as follows: 
expr_list 
expr 
I expr_list COMMA expr %prec COMMA 
Similarly, you could resolve in favor of the shift by making the production lower pre­
cedence than the COMMA (by replacing the COMMA in the %prec with the name of a 
lower-precedence operator). Since the comma is the lowest-precedence operator in C, 
you'd have to do it here by creating a bogus token that has an even lower precedence, 
like this: 
%nonassoc VERY LOW /* bogus token (not used in the grammar) */ 
%left COMMA 
%% 
expr_list 
expr 
I expr_list COMMA expr %prec VERY LOW 
Shift/reduce and reduce/reduce conflicts are often caused by the implicit E produc­
tions that are created by actions imbedded in the middle of a production (rather than at 
the far right), and the previous techniques can not be used to resolve these conflicts 
because there is no explicit production to which a precedence level can be assigned. For 
this reason, it's best to use explicit E productions rather than imbedded actions. Translate: 
x : a {action();} b; 
to this: 
x a action b 
action /*empty*/ {action();} 
or to this: 
x : a' b 
a' :a {action();} 
These translations probably won't eliminate the conflict, but you can now use %prec to 
resolve the conflict explicitly. 
It's not always possible to do a translation like the foregoing, because the action may 
have to access the attributes of symbols to its left in the parent production. You can 
sometimes eliminate the conflict just by changing the position of the action in the pro­
duction, however. For example, actions that follow tokens are less likely to introduce 
Section E.II.7-Shift/Reduce and Reduce/Reduce Con fticts 
conflicts than actions that precede them. Taking an example from the C grammar used in 
Chapter Six, the following production generated 40-odd conflicts: 
and list 
and list {and($1);} ANDAND binary { and($4); $$=NULL; } 
I binary 
but this variant generated no conflicts and does the same thing: 
and list 
and list ANDAND {and($1);} binary 
binary 
E.11.8 Error Recovery and($4); $$=NULL; } 
One of the ways that occs differs considerably from yacc is the error-recovery 
mechanism.15 Occs parsers do error recovery automatically, without you having to do 875 
anything special. The panic-mode recovery technique that was discussed in Chapter 5 is Panic-mode error 
used. It works as follows: recovery. 
(0) An error is triggered when an error transition is read from the parse table entry for 
the current input and top-of-stack symbols (that is, when there's no legal outgoing 
transition from a state on the current input symbol). 
( I) Discard the state at the top of stack. 
(2) Look in the parse table and see if there's a legal transition on the current input sym­
bol and the uncovered stack item. If so, we've recovered and the parse is allowed 
to progress, using the modified stack. If there's no legal transition, and the stack is 
not empty, go to I. 
(3) If all items on the stack are discarded, restore the stack to its original condition, dis­
card an input symbol, and go to I. 
The algorithm continues either until it can start parsing again or the entire input file 
is absorbed. In order to avoid cascading error messages, messages are suppressed if a 
second error happens right on the tail of the first one. To be more exact, no messages are 
printed if an error happens within five parse cycles (five shift or reduce operations) of the 
previous error. The number of parse cycles can be changed with a 
% { #define YYCASCADE desired _value %} 
in the specifications section. Note that errors that are ignored because they happen too 
soon aren't counted against the total defined by YYMAXERR. 
E.11.9 Putting the Parser and Actions in Different Files 
Unfortunately, occs can take a long time to generate the parse tables required for a 
largish grammar. (Though it usually takes less time for occs to generate yyout.c than it 
does for Microsoft C to compile it.) To make program development a little easier, a 
mechanism is provided to separate the table-making functions from the code-generation 
15. Yacc uses a special error token, which the parser shifts onto the stack when an error occurs. You must 
provide special error-recovery productions that have error tokens on the right-hand sides. The 
mechanism is notoriously inadequate, but it's the only one available if you're using yacc. See [Schreiner] 
pp. 65-82 for more information. Avoiding cascading error 
messages, YYCASCADE. 
876 LLama and Occs-Appendix E 
Using the -p and -a 
command-line switches. functions. The -p command-line switch causes occs to output the tables and parser only 
(in a file called yyout.c). Actions that are part of a rule are not output, and the third part 
of the occs input file is ignored. When -a is specified, only the actions are processed, and 
tables are not generated. A file called yyact.c is created in this case. 
Once the grammar is stable you can run occs once with -p to create the tables. 
Thereafter, you can run the same file through occs with -a to get the actions. You now 
have two files, yyout.c and yyact.c. Compile these separately, and then link them 
together. If you change the actions (but not the grammar), you can recreate yyact.c using 
occs -a without having to remake the tables. Remember that actions that are imbedded 
in the middle of a production will effectively modify the grammar. If you modify the 
position of an action in the grammar, you'll have to remake the tables (but not if you 
modify only the action code). On the other hand, actions added to or removed from the 
far right of a production will not affect the tables at all, so can be modified, removed, or 
added without needing to remake the tables. 
YYACTION, YYPARSER. The first, definitions part of the occs input file is always output, regardless of the 
presence of -a or -p. The special macro YYPARSER is generated if a parser is present in 
the current file, YYACTION is generated if the actions are present. (Both are defined 
when neither switch is specified.) You can use these in conjunction with #ifdefs in the 
definitions section to control the declaration of variables, and so forth (to avoid duplicate 
declarations). It's particularly important to define YYSTYPE, or put a %union, in both 
files-if you're not using the default int type, that is--otherwise, attributes won't be 
accessed correctly. Also note that three global variables whose scope is normally lim­
ited to yyout.c-Yy _val, Yy _ vsp, and Yy _ rhslen- are made public if either switch 
is present. They hold the value of$$, the value-stack pointer, and the right-hand side 
length. Yy_val, Yy_vsp, and 
Yy_rhslen made public 
by -p or-a. 
Listing E.12 shows the definitions section of an input file that's designed to be split 
up in this way. 
Listing E.12. Definitions Section for -a/-p 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 % { 
#ifdef YYPARSER 
# define CLASS 
# define (x) x 
#else 
# define CLASS extern 
# define (x) 
#endif 
CLASS int x 5 ); 
%) 
%union 
%term 
%left 
%% I* If parser is present, declare variables. *I 
I* If parser is not present, make them externs. *I 
I* Evaluates to "int x = 5;" in yyparse.c and to *I 
I* "extern int x;" in yyacts.c. *I 
I* Either a %union or a redefinition of YYSTYPE *I 
I* should go here. *I 
I* Token definitions go here. *I 
Section E.11.1 0-Shifting a Token's Attributes 
E.11.1 0 Shifting a Token's Attributes 
It is sometimes necessary to attach an attribute to a token that has been shifted onto 
the value stack. For example, when the lexical analyzer reads a NUMBER token, it 
would be nice to shift the numeric value of that number onto the value stack. One way 
to do this is demonstrated by the small desk-calculator program shown in the the occs 
input file in Listing E.l3. The I.!'X lexical analyzer is in Listing E.I4. This program 
sums together a series of numbers separated by plus signs and prints the result. The 
input numbers are converted from strings to binary by the atoi () call on line 12 and 
the numeric value is also pushed onto the stack here. The numeric values are summed on 
line eight, and the result is printed on line four. The difficulty, here, is that you need to 
introduce an extra production on line 12 so that you can shift the value associated with 
the input number, making the parser both larger and slower as a consequence. 
Listing E.l3. Putting Token Attributes onto the Value Stack-Using A Reduction 
1 %term NUMBER /* a collection of one or more digits *I 
2 %term PLUS /* a + sign *I 
3 %% 
4 statement expr statement { printf ("The sum is %d\n", $1); 
5 /* empty */ 
6 
7 
8 expr expr PLUS number { $$ $1 + $3; 
9 /* empty */ 
10 
11 
12 number NUMBER { $$ atoi (yytext); 
13 
14 %% 
Listing E.14. Lexical Analyzer for Listing E.l3 
1 #include "yyout.h" /* token definitions *I 
2 %% 
3 [0-9]+ return NUMBER; 
4 \+ return PLUS; 
5 /* ignore everything else *I 
6 %% 
An alternate solution to the problem is possible by making the lexical analyzer and 
parser work together in a more integrated fashion. The default action in a shift (as con­
trolled by the YYSHIFTACT macro described earlier) is to push the contents of a variable 
called yyl val onto the value stack. The lexical analyzer can use this variable to cause 
a token's attribute to be pushed as part of the shift action (provided that you haven't 
modified YYSHIFTACT anywhere). 16 The procedure is demonstrated in Listings E.l5 and 
E.l6, which show an alternate version of the desk calculator. Here, the lexical analyzer 
assigns the numeric value (the attribute of the NUMBER token) to yyl val before 
16. Note that yacc (but not occs) also uses yylval to hold $$, so it should never be modified in a yacc 
application, except as described below (or you'll mess up the value stack). 877 
Using an extra production 
to shift attribute for a 
token. 
} 
Using yylval to pass 
attributes from scanner 
to parser. 
878 LLama and Occs-Appendix E 
returning the token. That value is shifted onto the value stack when the token is shifted, 
and is available to the parser on line eight. 
Listing E.l5. Passing Attributes from the Lexical Analyzer to the Parser 
1 %term NUMBER 
2 %term PLUS 
3 %% 
4 statement 
5 
6 
7 
8 expr 
9 
10 
11 %% /* a collection 
/* a + sign 
expr statement 
/* empty */ 
expr PLUS NUMBER 
/* empty *I of one or more digits */ 
*I 
{ printf("The sum is %d\n", $1); } 
{ $$ $1 + $3; } 
Listing E.l6. Lexical Analyzer for Listing E.l5 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 %{ 
#include "yyout.h" 
extern int yy1va1; 
%} /* token definitions */ 
/* declared by parser in aces output file */ 
%% 
[0-9]+ yy1va1 = atoi(yytext); 
return NUMBER; /* numeric value is synthesized in shift */ 
\+ return PLUS; 
%% /* ignore everything else */ 
yylval is of type YYSTYPE-int by default, but you can change YYSTYPE expli­
citly by redefining it or implicitly by using the %union mechanism described earlier. If 
you do change the type, be careful to also change any matching extern statement in the 
LEX input file as well. 
Note that this mechanism is risky if the lexical analyzer is depending on the parser to 
have taken some action before a symbol is read. The problem is that the lookahead sym­
bol can be read well in advance of the time that it's shifted-several reductions can 
occur after reading the symbol but before shifting it. The problem is best illustrated with 
an example. Say that a grammar for C has two tokens, a NAME token that's used for 
identifiers, and a TYPE token that is used for types. A typedef statement can cause a 
string that was formerly treated as a NAME to be treated as a TYPE. That is, the 
typedef effectively adds a new keyword to the language, because subsequent refer­
ences to the associated identi tier must be treated as if they were TYPE tokens. 
It is tempting to try to use the symbol table to resolve the problem. When a 
typedef is encountered, the parser creates a symbol-table entry for the new type. The 
lexical analyzer could then use the symbol table to distinguish NAMEs from TYPEs. 
The difficulty here lies in input such as the following: 
typedef int itype; 
itype x; 
In a bottom-up parser such as the current one, the symbol-table entry for the typedef 
will, typically, not be created until the entire declaration is encountered-and the parser 
can't know that it's at the end of the declaration until it finds the trailing semicolon. So, 
Section E.11.10-Shifting a Token's Attributes 
the semicolon is read and shifted on the stack, and the next lookahead (the second 
itype) is read, before doing the reduction that puts the first itype into the symbol 
table-the reduction that adds the table entry happens after the second it ype is read 
because the lookahead character must be read to decide to do the reduction. When the 
scanner looks up the second itype, it won't be there yet, so it will assume incorrectly 
that the second it ype is a NAME token. The moral is that attributes are best put onto 
the stack during a reduction, rather than trying to put them onto the stack from the lexi­
cal analyzer. 
E.11.11 Sample Occs Input File 
For convenience, the occs input file for the expression compiler we've been discuss­
ing is shown in Listing E.l7. 
Listing E.17. expr.y- An Expression Compiler (Occs Version) 
1 
2 
3 
4 
5 
6 
7 
8 
9 %term ID /* 
%term NUM /* 
%left PLUS /* 
%left STAR /* 
%left LP RP /* 
%{ 
#include <stdio.h> 
#include <ctype.h> 
#include <malloc.h> a string of lower-case characters 
a number 
+ 
* *I 
*I 
*I 
*I 
*I 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 extern char 
extern char *yytext; 
*new_name(); /* In yylex(), holds lexeme */ 
/* declared at bottom of this file *I 
typedef char 
#define YYSTYPE *stype; 
stype 
#define YYMAXDEPTH 64 
#define YYMAXERR 10 
#define YYVERBOSE 
%} 
%% /* Value stack */ 
/* A small expression grammar that recognizes numbers, names, addition (+), 
*multiplication (*), and parentheses. Expressions associate left to right 
s 
e * unless parentheses force it to go otherwise. * is higher precedence than +. 
* Note that an underscore is appended to identifiers so that they won't be 
* confused with rvalues. 
*I 
e 
e PLUS e yycode("%s 
e STAR e yycode("%s 
LP e RP $$ = $2; 
NUM yycode("%s 
ID yycode("%s += 
*= %s\n", $1, $3); free_name( $3 ) ; } 
%s\n", $1, $3) ; free_name( $3 ) ; } 
} 
%s\n", $$ new -name(), yytext ) ; 
%s\n", $$ new_name(), yytext ) ; 
%% 879 
.... 
880 LLama and Occs-Appendix E 
Listing E.17. continued ... 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 /*----------------------------------------------------------------------*/ 
char *yypstk( ptr ) 
char 
{ **ptr; 
/* Yypstk is used by the debugging routines. It is passed a pointer to a 
* value-stack item and should return a string representing that item. In 
* this case, all it has to do is dereference one level of indirection. 
*I 
return *ptr ? *ptr "<empty>" 
/*----------------------------------------------------------------------*/ 
char *Names [] 
char **Namep { "tO", "tl", "t2", "t3", "t4", "t5", "t6", "t7" }; 
Names; 
char *new_ name () 
/* Return a temporary-variable name by popping one off the name stack. */ 
if( Namep >=&Names[ sizeof(Names)/sizeof(*Names) ] ) 
{ 
yyerror("Expression too complex\n"); 
exit( 1 ); 
return( *Namep++ ); 
free_name(s) 
char *s; 
/* Free up a previously allocated name */ 
*--Namep s; 
/*----------------------------------------------------------------------*/ 
yy_init_occs () 
{ 
/* Generate declarations for the rvalues */ 
yycode("public word tO, tl, t2, t3;\n"); 
yycode("public word t4, t5, t6, t7;\n"); 
main( argc, argv 
char **argv; 
{ 
/* Open the input file, using yy_get_args() if we're debugging or 
* ii_newfile() if not. 
*I 
#ifdef YYDEBUG 
yy_get args( argc, argv ); 
#else 
if( argc < 2 
{ 
fprintf( stderr, "Need file name\n"); 
exit (1); 
Section E.ll.ll -Sample Occs Input File 
Listing E.17. continued ... 
102 
103 else if( ii_newfile(argv[l]) < 0 
104 
105 fprintf( stderr, "Can't open %s\n", argv[l] ) ; 
106 exit (2); 
107 } 
108 #endif 
109 yyparse () ; 
110 exit( 0 ); 
111 
Listing E.18. expr.lex- I.!'X Input File for Expression Compiler 
1 %{ 
2 #include "yyout.h" 
3 %} 
4 %% 
5 "+" return PLUS; 
6 "*" return STAR; 
7 II(" return LP; 
8 ")" return RP; 
9 [0-9]+ return NUM; 
10 [a-z]+ return ID; 
11 %% 
E.11.12 Hints and Warnings 
• Though input defaults to standard input in production mode (as compared to debug 
mode), the input routines really expect to be working with a file. The default, 
standard-input mode is intended for use in pipes, not for interactive input with a 
human being. This expectation can produce unexpected consequences in an interac­
tive situation. Since the input is always one token ahead of the parser, the parser's 
actions can appear to be delayed by one token. This delay is most noticeable at end 
of file, because the last token in the input stream isn't processed until an explicit 
end-of-file marker is read. If you're typing the input at the keyboard, you'll have to 
supply this marker yourself. (Use Ctrl-D with UNIX; the two-character sequence 
Ctrl-Z Enter under MS-DOS). 
• Though you can redefine YYPRIVATE to make various global static variables pub­
lic for the purpose of debugging, you should never modify any of these global vari­
ables directly. 
• Once the grammar is working properly, make changes very carefully. Very small 
changes in a grammar can introduce masses of shift/reduce and reduce/reduce 
conflicts. You should always change only one production at a time and then remake 
the tables. Always back up the current input file before modifying it so that you can 
return to a working grammar if you mess up (or use a version-control system like 
SCCS). 
• A void E productions and imbedded actions-they tend to introduce shift/reduce 
conflicts into a grammar. If you must introduce an imbedded production, try to put it 
immediately to the right of a terminal symbol. 
• Avoid global variables in the code-generation actions. The attribute mechanism 
should be used to pass all information between productions if at all possible 881 
882 LLama and Occs-Appendix E 
(sometimes it's not). Grammars are almost always recursive. Consequently, you'll 
find that global variables tend to be modified at unexpected times, often destroying 
information that you need for some subsequent action. A voiding global variables 
can seem difficult. You have to work harder to figure out how to do things-it's like 
writing a program that uses subroutine return values only, without global variables or 
subroutine arguments. Nonetheless, it's worth the effort in terms of reduced develop­
ment time. All of the global-variable-use issues that apply to recursive subroutines 
apply to the action code in a production. 
• The assignment in the default action ($$=$1) is made before the action code is exe­
cuted. Modifying $1 inside one of your own actions will have no effect on the value 
of$$. You should modify$$ itself. 
• If you are using the -a and -p switches to split the parser into two files, remember that 
actions imbedded in a production actually modify the grammar. If you add or move 
such an action, you must remake the tables. You can add or remove actions at the far 
right of a production without affecting the tables, however. 
Occs is not yacc, and as a consequence, many hacks found in various books that discuss 
the UNIX utilities must be avoided when using occs: 
• Because of the way that the input is processed, it's not safe to modify the lexeme 
from the parser or to do any direct input from the parser. All tokens should be 
returned from LEX in an orderly fashion. You must use yytext, yylineno, and 
yyleng to examine the lexeme. It's risky for code in the parser to modify these 
variables or to call any of the i i _ input routines used by IJX. The problem here is 
that occs and LLama both read one token ahead-a second, lookahead token will 
already have been read before any action code is processed. The token in yytext is 
the current token, not the lookahead token. 
• By the same token (so to speak) you should never modify the occs or LLama value 
stack directly, always use the dollar-attribute mechanism-$$, $1, and so on-to do 
so. The contents of the yy 1 val, which has the same type as a stack element, is 
shifted onto the value stack when a state representing a token is shifted onto the state 
stack, and you can use this variable to shift an attribute for a token. (Just assign a 
value to yylval before returning the token). It is not possible for code in a IJX­
generated lexical analyzer to modify the value stack directly, as is done in some pub­
lished examples of how to use the UNIX utilities. Use yyl val. 
• The occs error-recovery mechanism is completely automatic. Neither the yacc 
error token, nor the yyerrok action is supported by occs. The error token can 
be removed from all yacc grammars. Similarly, all yyerrok actions can be deleted. 
If a yacc production contains nothing but an error token and optional action on it's 
right-hand side, the entire production should be removed (don't just delete the right­
hand side, because you'll introduce a hitherto nonexistent E production into the 
grammar). 
• The occs start production may have only one right-hand side. If a yacc grammar 
starts like this: 
baggins frodo 
bilbo 
add an extra production at the very top of the occs grammar (just after the %% ): 
start : baggins ; 
Section E.ll.12- Hints and Warnings 
E.12 Llama 
The remainder of this appendix describes the LLama-specific parts of the compiler 
compiler. The main restriction in using LLama is that the input grammar must be LL(l). 
LLama grammars are, as a consequence, harder to write than occs grammars. On the 
other hand, a LLama-generated parser will be both smaller and faster than an occs 
parser for an equivalent grammar. 
E.12.1 Percent Directives and Error Recovery 
The % directives supported by LLama are summarized in Table E.8. LLama sup­
ports one % directive over and above the standard directives. The %synch is placed in 
the definitions section of the input file-use it to specify a set of synchronization tokens 
for error recovery. A syntax error is detected when the top-of-stack symbol is a terminal 
symbol, and that symbol is not also the current lookahead symbol. The error-recovery 
code does two things: it pops items off the stack until the top-of-stack symbol is a token 
in the synchronization set, and it reads tokens from input until it finds the same token 
that it just found on the stack, at which point it has recovered from the error. If the 
parser can't find the desired token, or if no token in the synchronization set is also on the 
stack, then the error is unrecoverable and the parse is terminated with an error flag. 
yyparse () usually returns 1 in this case, but this action can be changed by redefining 
YYABORT. (See table E.2 on page 840). 
Table E.8. LLama % Directives and Comments 
Directive Description 
%% Delimits the three sections of the input file. 
%{ Starts a code block. All lines that follow, up to a % } are written to 
the output file unchanged. 
%} Ends a code block. 
%token Defines a token. 
%term A synonym for %token. 
/* *I C-like comments are recognized-and ignored-by occs, even if 
they're outside of a % { % I delimited code block. 
%synch Define set of synchronization tokens. 
Several tokens can be listed in the %synch directive. Good choices for synchroniza­
tion symbols are tokens that end something. In C, for example, semicolons, close 
parentheses, and close braces are reasonable selections. You'd do this with: 
%term SEMI CLOSE PAREN CLOSE CURLY 
%synch SEMI CLOSE PAREN CLOSE CURLY 
E.12.2 Top-Down Attributes 
The LLama value stack and the $ attribute mechanism are considerably different 
from the one used by occs. LLama uses the top-down attribute-processing described in 
Chapter Four. Attributes are referenced from within an action using the notation $$, $1, 
$2, and so forth. $$is used in an action to reference the attribute that was attached to the 
nonterminal on the left-hand side before it was replaced. The numbers can be used to 
reference attributes attached to symbols to the right of the current action in the grammar. 
The number indicates the distance from the action to the desired symbol. ($0 references 883 
The %synch directive, 
synchronization tokens. 
Changing the action tak­
en by the parser on an 
error. 
Llama attributes, $$, 
$1, etc. 
884 
Typing Llamas value 
stack. 
Initializing the value stack 
with yy_init_llama (). LLama and Occs-Appendix E 
the current action's own attributes.) For example, in 
stmt : {$1=$2=new_name();} expr {free_name($0);} SEMI stmt 
the $1 in the left action modifies the attribute attached to expr, the $2 references the 
attribute attached to the second action, which uses $0 to get that attribute. $$ references 
the attribute attached to the left-hand side in the normal way. Attributes flow across the 
grammar from left to right. 
E.12.3 The LLama Value Stack 
The LLama value stack is a stack of structures, as was described in Chapter Four. 
The structure has two fields, defined in the LLama-generated parser as follows: 
typedef struct 
{ /* Typedef for value-stack elements. *I 
YYSTYPE left; /* Holds value of left-hand side attribute. */ 
YYSTYPE right; /* Holds value of current-symbol's attribute.*/ 
yyvstype; 
The YYSTYPE structure is defined as an int by default, but you can redefine it in the 
definitions section of the input file as follows: 
% { 
typedef char *stack_type; /* Use stack of character pointers. */ 
#define YYSTYPE stack_type 
%} 
%% 
In this case, the dollar attribute will be of the same type as YYSTYPE. That is $$, $1, 
and so forth, reference the character pointer. You can use * $1 or $1 [ 2] to access indi­
vidual characters in the string. If the stack is a stack of structures or unions, as in: 
%{ 
typedef union 
{ 
int integer; 
char *string; 
stack_type; /* Use stack of character pointers */ 
#define YYSTYPE stack_type 
%} 
%% 
You can access individual fields like this:$$. integer or $1. string. 
The initialization subroutine for the LLama-generated parser, yy _in it llama() , 
is called after the stack is initialized but before the first lexeme is input-the start sym­
bol will have been pushed onto the parse stack, and garbage onto the value stack. The 
initialization routine is passed a pointer to the garbage entry for the pushed start symbol. 
The default routine in /.lib does nothing, but you can use your own 
yy_init_llama (p) to provide an attribute for the goal symbol so that subsequent 
replacements won't inherit garbage. Your replacement should be put at the bottom of the 
LLama input file and should look something like this: 
yy_init llama( p ) 
yyvstype *p; 
{ 
p->left = p->right =initial attribute value for goal symbol; 
Section E.l2.3-The LLama Value Stack 
The yyvstype type is a two-part structure used for the value-stack items described ear­
lier. 
The yypstk () routine used to print value-stack items in the debugging environment 
is passed a pointer to a value-stack item of type (a pointer to a yyvstype structure) and 
a string representing the symbol. You could print character-pointer attributes like this: 
%{ 
typedaf char *stack_type; /* Use stack of character pointers.*/ 
#define YYSTYPE stack_type 
%} 
%% 
%% 
char *yypstk(tovs, tods) 
yyvstype *tovs; 
char *symbol; 
{ 
static char buf[64]; /* Print attribute stack contents.*/ 
sprintf(buf,"[%0.30s,%0.30s]", tovs->left, tovs->right); 
return buf; 
E.12.4 The 1/out.sym File 
LLama produces a symbol table file if the -s or -S switch is specified on the com­
mand line. Listing E.19 shows the symbol table produced by the input file at the end of 
this appendix. 
The first part of the file is the non terminal symbols. Taking expr as characteristic, the 
entry looks like this: 
expr (257) 
FIRST : NUM OR ID LP 
FOLLOW: RP SEMI 
2: expr ->term expr' ................... SELECT: NUM_OR_ID LP 
The 257 is the symbol used to represent an expr on the parse stack, the next two lines are 
the FIRST and FOLLOW sets for expr. (These are present only if -S was used to gen­
erate the table.) The next lines are all productions that have an expr on their left-hand 
side. The number (2, here) is the production number, and the list to the right is the LL(l) 
selection set for this production. The production number is useful for setting breakpoint 
on application of that production in the debugging environment. 
If the production contains an action, a marker of the form { N } is put into the pro­
duction in place of the action. All these action symbols are defined at the bottom of 
llout.sym (on lines 51 to 57 ofthe current file). Taking { 0} as characteristic: 
{0} 512, line 42 : {$1=$2=newname ();} 
The 512 is the number used to represent the action on the parse stack, the action was 
found on line 42 of the input file, and the remainder of the line is the first few characters 
of the action itself. 
The middle part of the symbol table just defines tokens. The numbers here are the 
same numbers that are in llout.h, and these same values will be used to represent a token 
on the parse stack. 
E.12.5 Sample LLama Input File 
Listing E.20 is a small expression compiler in LLama format. 885 
Printing the value-stack, 
yypstk(),yyvstype. 
Generating the symbol­
table file, -s -S. 
886 LLama and Occs-Appendix E 
Listing E.l9. A LLama Symbol Table 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 ---------------- Symbol table 
NONTERMINAL SYMBOLS: 
expr (257) 
FIRST : NUM OR ID LP 
FOLLOW: RP SEMI 
2: expr ->term expr' ................... SELECT: NUM OR ID LP 
expr' (259) 
FIRST : PLUS <epsilon> 
FOLLOW: RP SEMI 
3: expr' ->PLUS {2} term {3} expr' ..... SELECT: PLUS 
4: expr' -> ............................. SELECT: RP SEMI 
factor (260) 
FIRST : NUM OR ID LP 
FOLLOW: PLUS TIMES RP SEMI 
8: factor-> NUM OR ID {6} .............. SELECT: NUM OR ID 
9: factor-> LP expr RP ................. SELECT: LP 
stmt (256) (goal symbol) 
FIRST : NUM OR ID LP <epsilon> 
FOLLOW: $ 
0: stmt -> .............................. SELECT: $ 
1: stmt -> {0} expr {1} SEMI stmt ....... SELECT: NUM OR ID LP 
term (258) 
FIRST : NUM OR ID LP 
FOLLOW: PLUS RP SEMI 
5: term-> factor term' ................. SELECT: NUM OR ID LP 
term' (261) 
FIRST : TIMES <epsilon> 
FOLLOW: PLUS RP SEMI 
6: term' ->TIMES {4} factor {5} term' .. SELECT: TIMES 
7: term' -> ............................. SELECT: PLUS RP SEMI 
TERMINAL SYMBOLS: 
name value 
LP 4 
NUM OR ID 3 
PLUS 1 
RP 5 
SEMI 6 
TIMES 2 
ACTION SYMBOLS: 
{ 0} 512, line 42 {$1=$2=newname();} 
{ 1} 513, line 42 {freename($0);} 
{2} 514, line 48 {$1=$2=newname();} 
{ 3} 515, line 49 { yycode("%s+=%s\\n",$$,$0); freename($0); } 
{ 4} 516, line 56 {$1=$2=newname();} 
{ 5} 517, line 57 { yycode("%s*=%s\\n",$$,$0); freename($0) ;} 
{ 6} 518, line 61 { yycode("%s=%0.*s\\n",$$,yyleng,yytext); } 
Section E.l2.5 -Sample LLama Input File 887 
Listing E.20. expr.lma- An Expression Compiler (Llama Version) 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
II 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 %term PLUS /* + *I 
TIMES /* * *I 
%term NOM OR ID /* a number or identifier *I 
%term LP /* ( *I 
%term RP /* ) *I 
%term SEMI /* ; *I 
%{ 
/*------------------------------------------------------------
* Rvalue names are stored on a stack. name() pops a name off the stack and 
* freename(x) puts it back. A real compiler would do some checking for 
* stack overflow here but there's no point in cluttering the code for now. 
*I 
%} char *Namepool[] = 
{ 
"tO" I "tl", "t2", "t3", "t4", "t5", "t6", "t7"' "t8", "t9" 
} ; 
char **Namep = Namepool 
char *newname () 
char *freename( char *x) 
extern char *yytext; 
extern int yyleng; 
#define YYSTYPE char* return(*Namep++); 
return(*--Namep = x); 
%synch SEMI RP 
%% 
/*A small expression grammar that recognizes numbers, names, addition (+), 
*multiplication (*), and parentheses. Expressions associate left to right 
* unless parentheses force it to go otherwise. * is higher precedence than + 
*I 
stmt 
expr 
expr' 
term 
term' /* eps */ 
{$1=$2=newname();} expr {freename($0);} SEMI stmt 
term expr' 
PLUS {$1=$2=newname();} term 
{ yycode("%s+=%s\n",$$,$0); freename($0); } expr' 
/* epsilon */ 
factor term' 
TIMES {$1=$2=newname();} factor 
{ yycode ("%s*=%s\n", $$, $0); freename ($0); } term' 
/* epsilon */ 
.... 
888 LLama and Occs-Appendix E 
Listing E.lct. continued ... 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 factor NUM_OR_ID { yycode{"%s=%0.*s\n", $$, yyleng, yytext); } 
LP expr RP 
%% 
/*------------------------------------------------------------*1 
yy_init_llama( p ) 
yyvstype *p; 
{ 
p->left = p->right 
char *yypstk(tovs, tods) 
yyvstype *tovs; 
char *tods; 
{ 
static char buf[l28]; "-" 
sprintf(buf,"[%s,%s]", tovs->left, tovs->right); 
return buf; 
main( argc, argv 
char **argv; 
yy_get_args( argc, argv ); 
yyparse(); 
exit( 0 ); 
F 
A C-code Summary 
This appendix summarizes all the C-code directives described in depth in Chapter 
Six. Many of the tables in that chapter are also found here. 
Figure F.l. The C-code Virtual Machine 
high low 
b3 b2 bl bO stack[] 
rO J I I 
rl I I I _3_1_ll_ 1_1_ ~ 
r2 I I I 
r3 I I I I sp 
r4 I I I 
I I I r5 I fp 
I I I r6 
r7 I I I 2,048, -c... -c.... 
r8 I I I 32-bit -, -, 
r9 I I I /words 
rA I I I 
rB I I I 
rC I I I 
rD I I I 
rE I I I 
rF I I I f--32bits 4 
text data bss 
_l_l_ll_l_l_ ~ _l_l_ll _1_1_ ~ _l_l_ll_l_l_ ~ 
/ I ip 
=~ instructions :': -initialized --uninitialized _ -, data -, --data -, 
889 
890 A C-code Summary-Appendix F 
Table F.l. Registers 
rN General-purpose register (rO, r1, ... , r9, rA, ... , rF). 
sp Stack pointer. 
fp Frame pointer. 
ip Instruction pointer. 
rN.pp Access 32-bit register as pointer to something. Must use an addressing mode to specify type 
of object pointed to. 
rN.w.high Access word in high 16-bits of register. 
rN.w.low Access word in low 16-bits of register. 
rN.b.b3 Access most significant byte of register (MSB). 
rN.b.b2 Access low byte of high word. 
rN.b.bl Access high byte of low word. 
rN.b.bO Access least significant byte of register (LSB). 
Table F.2. Types, Storage Classes, and Declarations 
Types 
byte 8-bit 
array (alias for byte-used to declare pointers to arrays) 
record (alias for byte-used to declare structures) 
word 16-bit 
lword 32-bit 
ptr generic pointer 
Storage classes 
private Space is allocated for the variable, but the variable can not be accessed from 
outside the current file. 
public Space is allocated for the variable, and the variable can be accessed from any 
file in the current program. It is illegal for two public variables to have the 
same name, even if they are declared in separate files. 
external Space for this variable is allocated elsewhere. There must be a public or 
common definition for the variable in some other file. 
common Space for this variable is allocated by the linker. If a variable with a given 
name is declared common in one module and public in another, then the 
public definition takes precedence. If there are nothing but common 
definitions for a variable, then the linker allocates space for that variable in the 
bss segment. 
Declarations 
class type name; Variable of indicated type and storage class. 
class type name [ size ] ; Array of indicated type and storage class; size is optional if initialized with C-
style initializer. 
All declarations in the data segment must be initialized using a C-style initializer. Nonetheless, pointers 
may not be initialized with string constants, only with the address of a previously-declared variable. 
Declarations in the bss segment may not be initialized. 
A C-code Summary-Appendix F 891 
Table F.3. Converting C Storage Classes to C-code Storage Classes 
not static 
static declaration (extern definition or prototype) 
Subroutine private public external (in text segment). 
Uninitialized variable private (in bss segment). corrunon 
Initialized variable private public (in data segment). 
Table F.4. Addressing Modes 
Mode Example Notes 
immediate 10 Decimal number. Use leading Ox for hex, 0 for octal. 
direct x, rO.l Contents of variable or register. 
B(p) byte whose address is in p. 
W(p) word whose address is in p. 
L(p) lword whose address is inp. 
indirect P(p) ptr whose address is inp. 
BP(p) byte pointer whose address is in p. 
WP(p) word pointer whose address is in p. 
LP(p) lword pointer whose address is in p. 
PP(p) pt r pointer whose address is in p. 
*BP(p) byte pointed to by pointer whose address is in p. 
double *WP(p) word pointed to by pointer whose address is in p. 
indirect *LP(p) lword pointed to by pointer whose address is in p. 
*PP(p) word pointed to by pointer whose address is in p. 
P(p+N) pt r at byte offset N from address in p. 
B(p+N) word at byte offset N from address in p. 
based W(p+N) lword at byte offset N from address in p. 
indirect L(p+N) lword at byte offset N from address in p. 
LP(p+n) lword pointer at byte offset N from address in p. 
*LP(p+n) 1 word pointed by pointer at byte offset N from address in p. 
0 0 0 
effective &name Address of variable or first element of array. 
address &W(p+N) Address of word at offset +n from the pointer p. 
The effective-address modes can also be used with other indirect modes. (See 
Table F.5). 
A generic pointer, p, is a variable declared pt r or a pointer register (rN. pp, fp, sp ). 
N is any integer: a number, a numeric register (rO.w.low), or a reference to a byte, word, or lword vari-
able. 
892 A C-code Summary-Appendix F 
Table F.5. Combined Indirect and Effective-Address Modes 
Syntax: Evaluates to: 
&p 
&W(&p) address of the pointer 
&WP (&p) 
p 
&W(p) contents of the pointer itself 
WP (&p) 
W(p) contents of the word whose address is in the pointer *WP(&p) 
Table F.6. Arithmetic Operators 
d 
d += 
d -
d *= 
d /= 
d %= 
d ~ 
d &= 
d I= 
d <<= 
d >>= 
d d d 
=& s 
s 
s 
s 
s 
s s s 
s 
s s s s s assignment 
addition 
subtraction 
multiplication 
division 
modulus division 
bitwise XOR 
bitwise AND 
bitwise OR 
Shift d to left by s bits 
Shift d to right by s bits (arithmetic) 
d = twos complement of s 
d = ones complement of s 
d =effective address of s 
lrs(d,n) logical right shift of d by n bits. Zero fill in left bits. 
Table F.7. Test Directives 
Directive: Execute following line if: 
EQ( a, b ) a=b 
NE( a, b ) a:;eb 
LT( a, b ) a<b 
LE( a, b ) a~b 
GT( a, b ) a>b 
GE( a, b ) a~b 
U_LT( a, b ) a<b (unsigned comparison) 
U_LE( a, b ) a~b (unsigned comparison) 
U_GT( a, b ) a>b (unsigned comparison) 
U GE( a, b ) a~b (unsigned comparison) 
BIT( b, s ) bit b of s is set to 1 (bit 0 is the low bit). 
A C-code Summary-Appendix F 893 
Table F.S. Other Directives 
SEG( text ) Change to code segment. 
SEG( data ) Change to initialized-data segment. 
SEG( bss ) Change to uninitialized-data segment. 
PROC (name) Begin code for subroutine name. 
ENDP (name) End code for subroutine name. 
ALIGN (type) Next declared variable is alligned as if it were the indicated type. 
ext_low (reg); Duplicate high bit of reg. b. bO in all bits of reg. b. bl. 
ext_high(reg); Duplicate high bit of reg. b. b2 in all bits of reg. b. b3. 
ext word (reg) ; Duplicate high bit of reg. w .low in all bits of reg. w. high. 
push (x); Push x onto the stack. 
x = pop (type) ; Pop an object of the indicated type into x. 
call (ref); Call subroutine. ref can be a subroutine name or a pointer. 
ret (); Return from current subroutine. 
link (N); Set up stack frame: push ( fp) , fp=sp; sp-=N. 
unlink (); Discard stack frame: sp=fp, fp=pop (ptr). 
pm() (subroutine) Print all registers and top few stack items. 
main is mapped to main. 
Directives whose names are in all upper case must not be followed by a semicolon when used. All other 
directives must be found inside a subroutine delimited with PROC () and ENDP () directives. SEG () may 
not be used in a subroutine. 
Table F.9. Supported Preprocessor Directives 
#line line-number "file" 
#define NAME text 
#define NAME (x) text 
#undef NAME 
#ifdef NAME 
#if constant-expression 
#endif 
#else 
#include <file> 
#include "file" Generate error messages as if we were on line line-number of the indicated file. 
Define macro. 
Define macro with arguments. 
Delete macro defintion. 
If macro is defined, compile everything up to next #else or #endif. 
If constant-expression is true, compile everything up to next #else or #endif. 
End conditional compilation. 
If previous #ifdef or #if is false, compile everything up the next #endif. 
Replace line with contents of file (search system directory first, then current 
directory). 
Replace line with contents of file (search current directory). 
Table F.lO. Return Values: Register Usage 
Type Returned in: 
char rF.w.low (A char is always promoted to int.) 
int rF .w.low 
long rF.l 
pointer rF.pp 
(Aho) 
[Aho2] 
[Angermeyer] 
[Armbrust] 
[Arnold] 
(Bickel) 
(DeRemer79) 
[DeRemer82) 
[Haviland] 
[Holub1) 
[Howell] 
[Intel) 
[Jaeschke] 
[K&R) 
[Knuth] 
[Kruse] 
[Lewis] Bibliography 
Books Referenced in the Text 
Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. Compilers: Principles, Techniques, 
and Tools. Reading, Massachusetts: Addison-Wesley, 1986. 
Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger. The AWK Programming 
Language. Reading, Massachusetts: Addison-Wesley, 1988. 
John Angermeyer ·and Kevin Jaeger. MS-DOS Developer's Guide. Indianapolis, Indi­
ana: Howard W. Sams & Co., 1986. 
Steven Armbrust and Ted Forgeron. ".OBJ Lessons" P.C. Tech Journal 3:10, October, 
1985, pp. 63-81. 
Kenneth Arnold. ''Screen Updating and Cursor Movement Optimization: A Library 
Package.'' 
''Automatic Correction to Misspelled Names: A Fourth-Generation Language 
Approach.'' Communications of the ACM (CACM) 30, March 1987, pp. 224-228. 
F. L. DeRemer and T. J. Pennello. "Efficient Computation of LALR(l) Look-Ahead 
Sets." Proceedings of the SIGPLAN Symposium on Compiler Construction. Denver, 
Colorado, August 6-10, 1979, pp. 176-187. 
F. L. DeRemer and T. J. Pennello. "Efficient Computation of LALR(l) Look-Ahead 
Sets." ACM Transactions on Programming Lanugages and Systems. 4:4, October, 
1982, pp. 615-649. 
Keith Haviland and Ben Salama. UNIX System Programming. Reading, Massachusetts: 
Addison-Wesley, 1987, pp. 285-307. 
Allen I. Holub. "C Chest: An AVL Tree Database Package." Dr. Dobb's Journal of 
Software Tools, 11:8 (August, 1986), pp. 2Q--29, 86-102, reprinted in Allen I. Holub. C 
Chest and Other C Treasures. Redwood City, California: M&T Books, 1987, pp. 
193-215. 
Jim Howell. "An Alternative to Soundex." Dr. Dobb' s Journal of Software Tools, 
12:11 (November, 1987), pp. 62-65,98-99. 
8086 Intel Relocatable Object Module Formats. Santa Clara, California: Intel Corpora­
tion, 1981. (Order number 121748-001). See also: [Armbrust]. 
Rex Jaeschke. Portability and the C Language. Indianapolis, Indiana: Hayden Books, 
1989. 
Brian Kernighan and Dennis Ritchie. The C Programming Language, 2nd ed. Engle­
wood Cliffs (N.J.), Prentice Hall, 1988. 
Donald E. Knuth. The Art of Computer Programming. Vol. 1-3. Reading, Mas­
sachl,lsetts: Addison-Wesley, 1973. 
Rogert L. Kruse. Data Structures and Program Design. Englewood Cliffs, New Jersey: 
Prentice Hall, 1984. 
P.M. Lewis II, D. J. RosenKrantz, and R. E. Steams. Compiler Design Theory. Reading, 
894 
Bibliography 895 
Massachusetts: Addison- Wesley, 1976. 
Robert McNaughton and H. Yamada. "Regular Expressions and State Graphs for Auto- [McNaughton] 
mata". IRE Transactions on Electronic Computers, vol. EC-9, no. I (March, 1960), pp. 
39-47. (Reprinted in E. F. Moor, editor. Sequential Machines: Selected Papers. Read-
ing: Addison Wesley, 1964.) 
Ogden Nash. "The Lama." Verses from 1929 On. Boston: Little, Brown, and Company: [Nash] 
1931, 1985. 
John W. Ratcliff and David E. Metzener. "Pattern Matching by Gestalt." Dr. Dobb' s [Ratcliff] 
Journal of Software Tools 13:7 [July, 1988], pp. 46-51. 
Axel Schreiner and H. George Friedman, Jr. Introduction to Compiler Construction with [Schreiner] 
UNIX. Englewood Cliffs, New Jersey: Prentice Hall, 1985. 
Aaron M. Tenenbaum and Moshe J. Augenstein. Data Structures Using Pascal, 2nd ed. [Tenenbaum] 
Englewood Cliffs, New Jersey: Prentice Hall, 1986. 
Jean-Paul Tremblay and Paul G. Sorenson The Theory and Practice of Compiler Writing. [Tremblay] 
New York: McGraw-Hill: 1985. 
Other Compiler Books 
This, and following sections, list books and magazine articles of interest that are not 
referenced in the text. 
Patricia Anklam, eta!. Engineering a Compiler: Vax-11 Code Generation and Optimiza- [Anklam] 
tion. Bedford, Massachusetts: Digital Press, 1977. 
William A. Barret, et a!. Compiler Construction: Theory and Practice. 2nd ed. Chi-[Barret] 
cago: Science Research Associates, 1986. 
Charles N. Fischer and Richard J. LeBlanc, Jr. Crafting a Compiler. Menlo Park, Cali-[Fischer] 
fomia: Benjamin/Cummings, 1988. 
David Gries Compiler Construction for Digital Computers. New York: John Wiley & [Gries] 
Sons, 1971. 
Per Brinch Hansen Brinch Hansen on Pascal Compilers. Englewood Cliffs, New Jersey: [Brinch Hansen] 
Prentice Hall, 1985. 
Robin Hunter. The Design and Construction of Compilers. New York: John Wiley & [Hunter1] 
Sons, 1971. 
Robin Hunter. Compilers: Their Design and Construction Using Pascal. New York: [Hunter2] 
John Wiley & Sons, 1985. [Sarff] Gary Sarff. "Optimization Strategies" Computer 
Language, 2:12 (December, 1985), pp. 27-32. 
P.D. Terry. Programming Language Translation. Reading, Massachusetts: Addison [Terry] 
Wesley, 1986. 
Jean-Paul Tremblay and Paul G. Sorenson An Implementation Guide to Compiler Writ-[Tremblay2] 
ing. New York: McGraw-Hill: 1982. 
Interpreters 
Timothy Budd. A Little Smalltalk. Reading, Massachusetts: Addison Wesley, 1986. 
Adele Goldberg and David Robson. Smalltalk-80: The Language and Its Implementa­
tion. Reading, Massachusetts: Addison Wesley, 1983. 
William Payne and Patricia Payne. Implementing BASICs: How BASICs Work. Reston, 
Virginia: Reston (a Prentice Hall Company), 1982. 
c [Budd] 
[Goldberg] 
[Payne] 
Samuel P. Harbison and Guy L. Steele, Jr. C: A Reference Manual. 2nd ed. Englewood [Harbison] 
Cliffs, New Jersey: Prentice Hall, 1987. 
Allen I. Holub. The C Companion. Englewood Cliffs, New Jersey: Prentice Hall, 1987. [Holub2] 

Index 
(S-Hl. X ~.C) 363 
[x~.y.FIRST(!bC)] 363 
in regular expression 817 
C operator 611 
a. 192 
E 8, 12,52 
in FIRST set 214 
is terminal, not token 12 
identity element in strings 53 
recognized in recursive-descent parser. 19 
E edges, etrectively merge states 113 
in Thompson NFA 85 
£closure 117 
£items 364 
add to current state by closure 359 
E productions 173 
executed first in list grammar 178 
in bottom-up parse tables 359 
occs 858 
occs/LLama 841 
reductions by 359 
E transitions 58 
u (see union) 
@,as first character in gen () format string 564 
mark comments in driver-template file 746 
() , in a n:x regular expression 55, 817 
indicate indirection in C-code 463 
1-II (see also end-of-input marker) 
~166 
::= 166 
$ attribute processing, LLama version 332 
in n:x regular expression 54, 817, 819 
$$, $1, etc. in LLama 332,883 
in occs 858 
$$,attribute of left-hand side 205, 352 
translation in occs-generated parser 388 
$$=$1, default action in bottom-up parser 
353,858 
$N388 392 
$-N393, 860 
% directives 857 
LLama 883 
shared occs and LLama 838 % { % ) , occs/LLama 857, 838 
%%, occs (in Table E.5) 857 
I I operator, in C compiler 622 
I , in a production 7 
in regular expression 55 
in Thompson's construction 81,82 
n:x 817 
", in regular expression 54, 817--819 
? , in regular expression 818 
in Thompson's construction 82 
*,in regular expression 818 
in Thompson's construction 82 
C dereference operator 606f. 
C multiplication operator (see C compiler, 
binary operators) 
+, in regular expression 818 
C operator, in compiler 634 
++ operator 603 
--operator 603 
::=(see~) 
~operator 7 
=> symbol 168 
-> C operator 611 
-C operator, in compiler 602 
! C operator, in compiler 602 
- C operator, in compiler 602 
& C operator in compiler 603f. 
, C operator, in compiler 618 
? : C operator, in compiler 619 
= C operator, in compiler 620 
& & C operator in compiler 624 
- C operator in compiler 634 
[ 1 , in regular expression 54, 818 
C operator, in compiler 606f. 
occs operator 865 
[ 1 *, occs operator 867 
<, >,<=,etc. C operator 626 
{ n, m}, operator in regular expression 55 
## 688 
8086 683 
\"C 817 
\0-terminated-string, support for 47 
\n in !.!'X input, 817 added to to negative character class by !.!'X 55 
\f 817 
\b 817 
\s 817 
\t 817 
\e 817 
\r 817 
16-bit data type, WORD 755 
8086 assembly language, translated to C code 451 
8086 macros 684 
8086, representing an address 684 
8086, segment not modified in 8086 far-pointer 
decrement 686(fn) 
A 
Jt 2!, c, 'V, etc. 192 
-a, occs/LLama command-line switch 410, 
843,876 
A 771 
a [7];, generate code for 611 
abbreviations, C-compiler nonterminals 512 
abstract dec/ 535 
abstract declarator 535 
accept 338, 347 
accept 85 
accept, field in DFA STATE 126 
accept action, represented in yyout.doc 869 
accepting actions, yylex () 81 
accepting state 56, 57 
accepting-state array, Yyaccept [ ] 72 
ACCEPT structure 126 
access arbitrary stack element (macro, high-level 
description) 687 
access function 42 
input system 43 
structure-member 611 
ACT 412 
actions 
default ($$=$1) 353 
executed as parse tree traversed 203 
executed in top-down parse 208 
imbedded (see imbedded actions) 
imbedded (translation by occs) 406 
initialization (see initialization) 
!.!'X multiple line 95 
occs imbedded 864 
put occs parser and actions in ditrerent files 
875 
897 
898 
subroutine, generated by aces/LLama (-a) 
843 
subroutine, in aces-generated parser 388 
subroutine, sample in aces-generated parser 
389 
Action (LR parse tables) 412 
activation record (see stack frame) 
Actual lineno 95 
ADD() 698 
addch () 782 
add declarator() 530 
ADD (function description) 693 
addition 
and subtraction processing (listings) 634 
as hash function 723 
hash function 483 
hash function, analysis 484 
address 
finding physical on an 8086 685 
LSB at lowest in C-code virtual machine 461 
representing in 8086 architecture 684 
address-of operator(&), inC compiler 601,603 
_addset () 691,701 
add spec to decl() 536 
addstr () -782 
addsym () 713,718 
add_ synch () 289 
add to dstates() 129 
add-to-rhs () 289 
add-unfinished() 417 
adjectives 490 
advance() 100 
advance(). 17 
advance 44 
advance, input pointer: ii advance () 42 
aggregate types, represented by physical pointers at 
run time 599 
algorithm, greedy (see greedy algorithm) 
algorithm, nongreedy (see nongreedy algorithm) 
ALIGN () , C-code directive 462 
alignment 
forcing in C-code 462 
inC-code 457,461 
in structure field 547 
problems caused by leading line number in l.J'X 
string 89 
worst-case restriction inC-code [c-code.h] 462 
ALLOC 86 
allocate 
temporary variables, tmp alloc () 577 
normal variables, in C-code 460 
memory 559 
allocation unit (disk) 37 
alphabet 52, 166 
alphabetic componants of output labels (label.h) 
554 
alternative parser templates, aces/LLama (-m) 
844 
ambiguity 
resolving when making LALR parse tables 
379 
rules for resolving ambiguities in parse table 
379 
eliminating from grammar 223 
in if I else, binding problems 219 
ambiguous accepting actions, handled by l.J'X 117 
ambiguous grammars 182 
in aces 856 
using in LALR parse tables 375 
analysis, lifetime 673 
analyzer, lexical (see lexical analyzer) 
anchor 86 
field in DFA STATE 126 
anchor 54 
end-of-line 54 
l.J'X 817 
processing by l.J'X 10 I 
problems 828 
AND operator(&&) 624 anonymous temporaries 6, 184 
ANSI 683 
ANSIC 
ANSI grammar 806 
subset implemented in Chapter Six 445 
concatenation operator, Ill 688 
requires downward-growing stacks 688 
variable-argument mechanism 724 
arbitrary stack element (macro, high-level 
description) 687 
architecture, 8086 segmented 684 
args 613 
field in symbol structure 488 
argument 
declaration 532 
assembled in reverse order 535 
K&R-style 555 
functions with a variable number 724 
function (see function arguments) 
in recursive-descent parser 26 
Pascal subroutine 802 
togen () 565 
to link instruction 552 
argv 
printing 733 
sorting with ssort () 738 
arithmetic operators 
handled by C compiler 630 
in C-code 4 73 
Arnold, Ken (curses author) 774 
array 450 
array 
accepting-state (Yyaccept [)) 72 
dereferencing 603 
manipulation, macros 686 
problems with decrement past start of in 8086 
686(fn) 
represents LR State machine 345 
dynamic 456 
printing two-dimensional 140 
used to model state machine 57 
using to access high byte of number without 
shift 685 
<ascii> attribute 543 
ASSIGN (function description) 692 
assignment 
dead 661 
operator, inC compiler 619-621 
associativity 
controlling when eliminating ambiguity from 
grammar 224 
specifying under aces 856 
specifying gramatically 175 
used to resolve conflicts in LALR tables 376 
assort() 739,741 
attribute 34, 186 
<ascii> 543 
bits 750 
bottom-up parsing 349 
definitions 754 
difterentiate tokens with 511 
link pointer used inC compiler 524 
nonterminal 187 
notation, for bottom-up parser ($N) 205 
notation, for top-down parser ($N) 205 
processing, bottom-up parser 348 
and aces E productions 858 
for token (shifting onto aces value stack) 877 
in code section of aces input file 392 
inherited 187 
inherited (in top-down parser) 203 
in recursive descent 348 
LLama 883 
negative ($-1) 860 
notation in bottom-up parser 353 
aces 858 
passing bottom-up between symbols (an exam­
ple) 350 Index 
stored on stack in recursive-descent parser 199 
synthesized 187, 349 
stack (see value stack) 
synthesized by* and [) operators 608 
attributed grammars 186-187, 191" 
for bottom-up parsing 351 
implementing with a PDA 203 
ATYPE 141 
augmentations 183 
in aces/LLama grammar 841 
augmented grammars 183 
and attributed grammars 191 
and table-driven parsers 202 
for bottom-up parsing 351 
automata 
deterministic finite (see DFA) 
finite (see state machine) 
nondeterministic finite (see NFA) 
push-down (see push-down automata) 
automatic variables 
figuring offi;et in stack frame 562 
handling at run time 467 
autoselect mode 772 
Available 416 
B 
back end 2, 5,447,563 
Backus, J.W. 7 
Backus-Naur Form (BNF) 7, 166 
modified for aces/LLama 839 
Backus-Normal Form (See Backus-Naur Form) 
base address, video memory 756 
basic block 663 
basic types, in C-code 450, 452 
beginning-of-line anchor, l.J'X 817 
Bilbo 535 
Binary-mode, untranslated input (see also escape 
sequences, l.J'X) 40, 817 
binary op () 630 
binary operator productions, summary 617, 618 
binary, convert to printing ASCII 727 
bin to ascii () 727 
BIOS, video (see video BIOS) 
bit maps 690 
bit implementing 695 
bit positions, computing in set (bit map) 697 
number of bits required for a type 685 
test bit in set 691 
bitset 85 
BITS IN WORD 697 
blinking characters 749 
block 
basic 663 
deletions from symbol table 485 
disk 37 
starting with symbol (see bss) 
BNF (See Backus-Naur Form) 
body 478 
bootstrapping, a compiler using language subsets 
271 
bottom-up attributes, accessing under aces 858 
bottom-up attributes, notation 353 
bottom-up parsing/parser 169, 337f. 
attribute notation ($N) 205 
attribute processing 348 
error recovery 348 
passing attributes between symbols (an exam­
ple) 350 
uses synthesized attributes 349 
value stack 348 
stack, relation to parse tree 340 
table driven (an example) 345 
tables, creating 357 
$$ 352 
attributed grammars 351 
augmented grammars 351 
description of parse process 338 
Index 
implementing with state machine 343 
of lists 340 
recursion 340 
with a PDA (basic algorithm) 338 
boundaries, lexeme (ii mark start (), ii mark end()) 42- -
box o 180 
box, drawing under curses 780, 788 
box-drawing characters, box.h 787 
boxed() 778 
break 642 
breakpoints, IDE 848 
IDE production 264 
IDE stack 255 
braalt statements, in occs/LLama actions 841 
bss, output stream 552 
bss segment 456 
C compiler (temporary file) 512 
output from occs/LLama 855 
bubble sort 739 
BUCKET 716,718 
buffur 
flush 37 
input system 15 
input system 37, 38 
ring 50 
BUFSIZE 37 
byte 450 
BYTES IN ARRAY 697 - - -c 
C to C-code mappings 495 
C-code, 6, 449 
addressing modes 462 
ALIGN() directive 462 
alignment 457 
alignment 461 
allocating variables 460 
Arithmetic operators 4 73 
automatic variables 467 
basic types 450 
basic types (implementation) 452 
basic types (widths) 452 
caveats 478 
c-code.h 450 
CLASS 455 
combined effuctive-address and indirect modes 
&WP ( &p) 463, 465 
common 458 
comparison directives [virtual.h1 475 
constant expressions 475 
control flow 474 
converting C storage classes to C-code storage 
classes 458 
declarations 478 
direct-stack-access directives [ virtual.h1 465 
ENDP, and SEG () 457 
executable image 456 
external 458 
file organization 476 
got:o 474 
identifiers 450 
indirect-mode prefixes [c-code.h1 465 
instruction pointer register, ip 452 
jump tables can't be implemented 478 
labels 474 
labels diffurent from assembly language 478 
leading underscores avoid name conflicts 467 
LSB (at the lowest address) 461 
macros 475 
memory alignment, forcing 462 
memory organization 455 
miscellany 476 
preprocessor directives 476 
Print virtual-machine state, pm () 476 
private 457 
PROC, and SEG () 457 
program-load process 455 
program prefix 455 public 458 
Push and pop directives 465 
register set 451 
register set 454 
run-time trace support [virtual.h1 477 
segment-change directive [SEG () 1 457 
segments 455 
segments 456 
semicolon 457 
Sign extension 474 
stack 454 
stack manipulation 465 
stack-size definitions 454 
storage classes 457 
storage classes [in virtual.h1 461 
storage classes, &WP (&_p) used for lvalues 
599 
subroutines 466 
subroutine arguments 467 
subroutine linkage 467 
subroutine return values 472 
test directives 474 
translating C to C-code to 8086 assembly 
language 451 
translating to 8086 assembly language 451 
Type Conversions 473 
types 450 
variable allocation 460 
variable declarations 457 
variable names 450 
virtual machine 451 
virtual-machine register set 453 
virtual-machine stack registers, fp, sp 452 
virtual-register-set allocation, ALLOC 454 
white space 450 
worst-case alignment restriction [c-code.h] 
462 
c-code.h 450 
Ccompiler 
abbreviations in nonterminal names 512 
abstract declarators 535 
all other operators, binary op () 630 
binary operators 617 -
cast and address-of operators 60 I 
cleanup 512 
code generation [gen () ] 564 
comma, conditional, and assignment operator 
619 
compound statements (see compound state­
ments) 
constants 598 
control flow 637 
declarator processing 528 
expressions 572 
function-argument declarations 532 
function calls 611 
function declarations 552 
function declarators 532 
identifiers 
initialization (listings) 515 
initialization productions (listings) 524 
initialize link (decl.c) 526 
integer constants 593 
interaction between scanner and code generator 
(problems) 536 
lexical analyzer 518 
link, pointer to (used as an attribute) 524 
local variables 559 
local variables 562 
logical AND and OR operators 622 
lvalues and rvalues 578 
merge declarator and specifier 536 
merge links (decl.c) 526 
parser configuration 509 
pointer and array dereferencing 603 
print value stack [yypstk () 1 514 
relational operators 626 
SEG directives 524 
ai.zeof 599 specifier processing 524 
statements 
string constants 599 899 
structure and uni.on declarations 543 
structure and uni.on declarations 543 
structure-member access 611 
temporary files for code, data, and bss segments 
512 
temporary-variable allocation 572 
token definitions 511 
type conversions 592 
typedaf processing 528 
unary minus, NOT, one's complement 602 
unary operators 593 
%union to type value stack 
variable declarations, simple 522 
variable declarators (listings) 529 
C, grammar 806 
calling sequence, mirrors parse tree 21 
call (name), inC-code 466,477 
call, of the wild 468 
Camptown ladies 107 
cascading error messages 348 
cast avoiding with YYCASCADE 875 
implemented inC compiler 601 
two needed to convert .int to pointer 688 
used to access high byte of number without 
shift 685 
cat expr () 104 
CCL-85 
CGA 749 
CHARACTER 756 
character 
print in human-readable form 732 
and attributes 7 49 
box-drawing box.h 787 
attribute bits 750 
display with direct video 751" 
character class 54 
add \n to negative 55 
dodash () 107 
empty 818 
in Thompson's construction 85 
n:x 818 
character 1/0 
curses 781 
video-BIOS 752 
character pointer, used for variable-argument-list 
pointer 725 
Chomsky, Noam 7 
choose an alternate driver file, -rn (n'X) 826 
CHUNK 412 
CLASS 86 
class, character (see character class) 
CLASS, has precedence 511 
in C-code 455 
clean up, afterprnt () 735 
cleanup productions, C compiler (listings) 524 
CLEAR 692,698 
clear() 783 
clear 
entire window, werase.c 794 
from cursor to edge of window, wclrtoeo.c 793 
region of screen. (high-level description) 750 
set (function description) 692 
closure 
in creating LR parse tables 357 
in regular expression 55 
in Thompson's construction 82 
Kleene (*) 53 
operators, n'X 818 
positive (+) 53 
processing, n'X I 07 
clrtoeol () 783 
cluster (disk) 37 
code block, %( ... %I 838 
code, dead 660, 661 
code generation 29, 445 
900 
expression evaluation 184 
gen () subroutine 564 
using the value stack 351 
with inherited attributes 189 
with synthesized attributes 189 
with top-down parser and augmented grammar 
203 
code generator, communicate with scanner through 
symbol table 529 
problems 536 
code, output stream 552 
code 
in an occs/LLama production 841 
in ll'X rule 820 
in occs/LLama definitions section 837 
op 459 
section, occs/LLama input file 842 
segment 456 
Ccompiler (temporary file) 512 
output from occs/LLama 855 
code, useless 662 
COLBASE 756 
collision, in symbol table 481 
resolution (hashing) 483 
color, changing on screen 7 49 
curses changing foreground/background 778 
combined effective-address and indirect modes 
&WP ( &p) 463, 465 
comma-delimited lists, problems 618 
COMMA, ext dec/ list-text dec/ list COMMA 
ext dec/ 531 - - - -
comma, in D () macro argument 683 
comma operator 
inmvinch () andmvwinch () 786 
isolating 618 
code to handle in C compiler 619 
command-line 
processing, IDE 853 
switches (ll'X) 825 
occs/LLama 843 
commands, IDE 847 
comment () 734 
comment 
print multiple-line 734 
add to C-compiler output, gen _comment () 
564 
in ll'X input file 816 
output from occs/LLama 855, 857 
common 458 
common-subexpression elimination 672 
compare 
two sets. (function description) 691 
sets 701 
directives, inC-code [virtual.h] 475 
function, used by ssort () 738 
two ITEMs 420 
two STATEs [state cmp ()] 420 
compiler.h 689 -
compiler, passes I 
compiler, Pascal 802 
COMPLEMENT () 695 
COMPLEMENT (function description) 692 
complemented set 
logical COMPLEMENT () 695 
physical INVERT () 695 
by inverting bits 691 
by marking set as negative true 695 
by physically inverting bits 694 
problems with 694 
compound statements 559, 637 
compound stmt 559 
compound= stmt, ext_ def --topt _specifiers funct _dec/ 
def_list compound _stmt 552 
compress 
parse tables, occs 393 
transition matrix (ll'X) 65 
ll'X state-machine tables 140 
pair 68 
ratio, pair compression 72 redundant row and column elimination 146 
redundant row and column elimination 65 
using default transition 71 
concat () 745 
concatenation 
of strings (function description) 745 
in Thompson's construction 81 
n:x 817 
operator, Itt 688 
operator, ll'X 106 
processing, ll'X I 04 
regular expression 54 
string 53 
conditional operator (a?b:c) 619 
conditional-compilation macros: LL( ), OX() 275 
conflicts II 
local-static names 486 
resolving reduce/reduce 380 
resolving shift/reduce 379 
rules for resolving conflicts in parse table 379 
shift/reduce and reduce/reduce 360 
CONSTANT, storage class 491 
constant 
expressions, in C-code 475 
expressions, in tests 641 
folding 633, 659 
propagation 660 
symbolic 598 
value. 584 
const_expr dummy used for grammar development 
530 
constrained types, numeric coding 489 
construction, subset 122 
context-free grammar 166, 167 
continua 642 
control characters, matching in a regular expression 
(\ -) 817 
control flow 637 
in C-code 474 
in yylex () 74 
conversion functions 726 
conversion, implicit type 620 
conversion, type (see type conversion) 
convert type() 592 
coordinates, curses 777 
COPY() 39 
copy amt 
copy file, copyfile () 741 
copying, structures 859 
comer 221 
comer substitution 221 
translate indirect recursion to self recursion 
228 
configuration, C parser 509 
counter, location 458 
create_static_locals() 563 
create 
stack, stack macro (high-level description) 686 
parser only, occs/LLama (-p) 844 
set (function description) 691 
window, wincreat.c 794 
crmode (),Set unbuffered, (high-level description) 
776 
cross links 486 
creating in C compiler ext_decl_list--text_decl 
531 
set up in C compiler 554 
Ctrl-L, delimits parts of driver-template file 746 
cur.h 788 
current 15 
Current tok 100 
<curses.h> 776 
curses.lib 
curses 
boxed windows 778 
character 1/0 781 
configuration 775 
configuration functions 776 
coordinates (y=row, x=column). Upper left Index 
comer is (0, 0) 777 
creating aod Deleting Windows 777 
cursor movement aod position functions 781 
cursor position, change 751 
delete/hide window 779 
designed for efficient serial communication 
775 
disable on abort in IDE 246 
curses, erase window 783 
foreground/background color 778 
glue functions to video 1/0 771 
implementation 783 
initialization functions 776 
line wrap 778 
move window 779 
portability issues 775 
save region under screen 779 
scrolling 778 
scroll window 
source code 
box, draw in curses window, box.c 788 
clear, entire window, werase.c 794 
clear, from cursor to edge of window, 
wclrtoeo.c 793 
create window, wincreat.c 794 
delete window, delwin.c 790 
display window, showwin.c 792 
erase, entire window, werase.c 794 
erase, from cursor to edge of window, 
wclrtoeo.c 793 
formated print to window, wprintw.c 800 
hide window, hidewin.c 790 
initialize, curses (initscr.c) 791 
move window, mvwin.c 791 
move window-relative cursor and read 
character, winch.c 794 
move window-relative cursor, wmove.c 
800 
scroll window, wscroll.c 80 I 
string, write to window, waddstr.c 793 
winio.c 796 
write, string to window, waddstr.c 793 
standard box-window function 780 
stdscr window 777 
subwindows 777 
using 776 
window management 774 
modify and move (video-BIOS) 752 
c.y 806 
D 
D () 683 
DAG, see (directed acyclic graph) 
DANGER 37 
dangling else 378 
data abstraction 715 
database, management with hash table (see hash­
ing) 
database, occsSTATEdatabase 417 
database, termcap 77 4 
database layer, in symbol table 479 
data, output stream 552 
data segment 456 
C compiler (temporary file) 512 
output from occs/LLama 855 
\xDD 817 
\ODD 817 
dead assignment 661 
nonconstant 663 
dead code 660 
dead states 140 
dead variables 660 
DEBUG 682 
debugging 
hooks, for Ctri-A, Ctri-B. 263, 514,518,847 
diagnostics, D () 683 
environment, occs interactive (see IDE) 
print value stack in C compiler debugging 
Index 
mode 514 
debug.h 681 
debug mode, occs/LLama 845 
commands, IDE 847 
declaration 
function (see function declaration) 
identi tier processing 528 
C-<:ode 478 
enumerated-type 550 
function argument (see argument declaration) 
implicit (in C compiler) 598 
structure and union 543 
variable, simple 522 
declarator 489 
abstract 535, 536 
adding to the type chain 531 
function 532 
implementation 490 
manipulation functions [symtab.c) 501 
merge with specifier [add_ spec_ to_ decl ()I 
536 
processing, C compiler 528 
in symtab.h 491 
variable (listings) 529 
decompression, of LALR parse table 369 
default transition, used in compression 71 
DEFBITS 697 
def ground() 778 
"defined as" operator (see 
definition, regular 56 
definitions 
high-level external (listings) 549 
nested variable 559 
section, occs/LLama 837 
def_ list 545 
de{ list, ext _def-topt_specifiersfunct _dec/ de!_ list 
compound_stmt 552 
def_list, struct _specifier-tSTRUCT opt _tag LC 
def_list RC 546 
defnext () 140 
DEFWORDS 697 
delay() 255 
delay 
adding to IDE go mode 849 
of first read until after advance 40 
label generation for link until after subroutine 
processed 552 
delete 
set (function description) 691 
window, curses 779 
window, delwin.c 790 
block (from symbol table) 485 
delimiters, in list grammars 179 
delset () 691 
del set () 701 
delsyrn o 713 
delsym() 719 
del win () 779 
depth-first traversal 180 
dereferencing, pointer and array 603 
derivation, leftmost 168 
rightmost 169 
derived types 490 
deterministic finite automata (see DFA) 
dfa () 126 
DF A structure 125 
DFA 57 
creating from NFA (see subset construction) 
finding equivalent states 132 
formal definition 59 
minimization, theory 132 
algorithm 134 
implementation 135 
removing redundant states 136 
represented by right-linear grammar 174 
DFA STATE 
diagram, syntax 4 
transition 56 
DIFFERENCE (function description) 692 direct access to video memory, dv _Screen, 
SCREEN 757 
direct addressing mode 462 
directed acyclic graph (DAG) 673 
directives, comparison in C-<:ode [virtual.h) 475 
preprocessor, in C-<:ode 476 
directories, used for support functions 680 
direct-video 
definitions (video.h) 756 
functions, initialization 749 
1/0 functions 7 49 
output, in IDE 846 
printf () 750 
select mode at run time 772 
disable scrolling, curses 778 
disable trace () 565 
disambiguate lexemes, with lookup tables 828 
discard () 88 
discard link chain() 548 
discard-value() 585 
disk access, sectors 37 
disk organization 37 
dispatch table 646 
DISPLAY 756 
display, character (direct video) 751 
lexeme, IDE 852 
pages, video 749 
string (direct video) 751 
window, showwin.c 792 
distinguished 132 
DIV WSIZE(x) 697 
do dollar< l 406 
do-en urn () 550 
doifar attributes, subroutine that translates them to 
stack references 406 
translation in occs/LLama-generated parser 
(see$) 
do name () 594 
doo dab, doo dab 107 
do_patch() 401 
do struct () 611 
doi;" in LR items 356 
operator in regular expression 54, 817 
doubly linked list 718 
do/while 643 
driver 1 () 745 
driver -2 () 745 
driver, subroutine to copy template from file to 
standard output 745, 748 
state machine driver 59 
driver subroutine, output by occs/LLama 319 
dst opt () 634 
Dtran 126 
dummy const expr production, used for grammar 
development -530 
duplicate (field in symbol structure) 486 
duplicate set (function description) 691 
duplicate symbols (hashing) 483 
in tree-based symbol table 481 
dupset () 691, 701 
dv clr region () 750 
dv-clrs o 750 
dv-ctoyx () 751 
dv-freesbuf() 751 
dv ::::get yx () 751 
dv incha () 751 
dv-init() 749 
dv::::outcha () 751 
dv _printf () 750 
dv _putc () 750 
dv _put char() 751 
dv_putsa() 751 
dv_puts() 751 
dv replace() 751 
dv-restore () 751 
dv-save() 751 
dv-Screen 757 
dv-scroll line() 752 
dv::::scroll() 752 dynamtc 
E array 456 
link 472,803 
temporary-variable creation 573 
ebss 457 
ECHO 73 901 
echo () , Echo characters. (high-level description) 
777 
ECHO (ll'X printlexeme) 821 
e closure() 117 
edata 457 
edge, in graph 57 
edge, field in NFA 84 
edge 89 
edge, E, see (E edge) 
eeyore 553 
effective-address and indirect modes combined 
&WP ( &p) 463, 465 
egrep, implementing with NFA interpreter 113, 
119 
elements, specifying number of in a list 178 
elimination, common-subexpression 672 
redunant row and column 65 
ellipsis, removing in the UNIX environment 684 
ELSE, has precedence 511 
else, dangling 378 
trailing (in multiple-statement macro) 64 
eMark 37 
emit, labels to link 555 
EMPTY 85 
empty, character classes 818 
sets 694 
statements 637 
stack, test for 687 
string 52, (see also E) 
enable scrolling, curses 778 
enable trace() 565 
encapsuiiition 492 
END 37 
end, back 2 
End buf 37 
end of file, detecting in input system: 
NO MORE CHARS () 43 
-processing by I.!'X, yywrap () 80 
end-of-function processing 555 
end of input 44 
marker 173 
end-of-line anchor 54, 817 
problems with I 04 
end opt () 289 
ENDP, and SEG () 457 
endwin () , terminate curses. (high-level descrip­
tion) 776 
enlarge set (function description) 691 
ENTER 87 
enumerated-type declarations 550 
enumerator-list element 493 
Enum val 550 
environment, search for file along path in environ­
ment string 745 
VIDEO 772, 846 
Eof read 43 
EOF-(see: end of file) 
EOS 95 
EPSILON 85, 89 
epsilon, see E 
equivalent states, in DFA 132 
erase() 783 
erase, entire window, werase.c 794 
from cursor to edge of window, wclrtoeo.c 793 
window, curses 783 
ERR 784 
Errmsgs 88 
error handler, stack macros. (macro, high-level 
description) 687 
error marker, in occs-generated parse table (YYF) 
388 
902 
error message, print and exit 731 
processing by I.!'X 88 
cascading 348 
error recognition, FIRST sets 23 
error recovery, in a bottom-up parser 348 
in bottom-up parser 348 
algorithm used by occs 40 I 
in lexical analysis 34 
inLLama 883 
in occs-generated parser (yy recover ()] 
400 -
in occs parser 875 
in recursive descent, legal lookahead () 
23 -
in top-down parser 20 I 
detection not affected by merging LR( I) into 
LALR(I) 367 
panic mode 348 
error transitions, in LR parse table 356 
esc() 726 
escape character (\) 55 
escape sequence, recognized by esc () 727 
n:x 817 
translate to binary 726 
etext 457 
etype (field in symbol structure) 488 
evaluation, order of, as controlled by grammar 181 
executable image 456 
executed first, list-element production 178 
expand macro() 93 
exponentiation, string 53 
expr () 101, 104 
expression, constant (in test) 641 
grammars 180 
processing, high level 636 
with rvalues and logical lvalues 581 
with rvalues and physical lvalues 579 
by C compiler 572 
in a C statement 637 
regular (see regular expressions) 
ext dec/, ext dec/ list -+ext dec/ 531 
ext-dec/, ext-dec(list-+ext- dec/ list COMMA 
ext-dec/ 53I - - -
ext-dec/ list -+ext dec/ 531 
ext-decl-list -+ext-dec/ list COMMA ext dec/ 53! - - - -
ext_ def-+opt _specifiers funct _dec/ def_list 
compound _stmt 552 
external 458 
external definitions, high-level (listings) 549 
F 
F 124 
factor () 107 
factoring, left 219 
failure transisitions, I.!' X F 124 
in yylex (), yylastaccept 80 
far heap 756 
far keyword 756 
pointer 684 
fatal error message handling 731 
ferr () 731 
ffree () 756 
field definitions, structure 545 
<field>, in yyout.sym 867 
field-name generation, occs 860 
$<field>N, occs 863 
figure local offsets() 562 
file, copy or move 741 
examine from IDE 850 
organization, in C-code 476 
search for file along path in environment string 
745 
FILL 692, 698 
find next set element. (function description) 692 
findsym () 713,720 
trick to simplify calling interface 714 
finished-states list 415 
finite automata, (see state machine) deterministic (see DFA) 
nondeterministic (see NFA) 
first in cat() 106 
FIRST set 23,213 
code to compute 305 
in yyout.sym 867 
of a right-hand side 215 
first sym () 289 
fix dtran () 136 
flies:-fruit 
floating-point, state machine that recognizes con­
stants 61 
floccinaucinihilipili fication 247 
flush, input buffer 37, 44 
fmalloc () 756 
folding, constant 633, 659 
FOLLOW set 215 
code to compute 307 
used to resolve conflicts in LR state machine 
361 
for 643 
force 44 
foreground/background color, curses 778 
formated print to window, wprintw.c 800 
formatting, occs/LLama input-file 841 
four-pass compiler, structure I 
four armed, Shiva 79 
fp, in C-code virtual machine 452 
fputstr () 732 
fragmentation, heap 457 
frame pointer 469 
frame, stack (see stack frame) 
free item() 420 
free-name () 352 
f reename () 26 
free_nfa () 116 
free recycled items() 420 
free-sets() 1:fu 
freesym () 712 
freesym () 716 
frito 535 
front end 44 7 
front-end considerations 563 
fruit flies 171 
full, test for stack (macro, high-level description) 
687 
funct dec/ 532 
funct= dec/, ext_ def-+opt _specifiersfunct_dec/ 
def list compound stmt 552 
function, access 42 
function-argument, declarations 532 
definitions, K&R-style 555 
processing, non_comma_expr 612 
processing, listings 547 
function body, compound stmt 559 
function-call processing 611, 616 
function calls, and temporary-variable allocation 
573 
function declaration 552 
function declarators 532 
function definition, compiler output 554 
function, end-of (processing) 555 
function prototypes, create with Microsoft C, {Zg 
switch 689 
translating to extern with P () macro 683 
functions, conversion (in library) 726 
intrinsic 657 
print (in library) 731 
video 1/0 746 
Funct name 552 
G 
-g, occs/LLama command-line switch 844 
gap size, in Shell sort 741 
Gaul 478 
GBIT 698 
generate () 352 
generate code, from the syntax tree 670 
generic grammars 192 gen false true() 603 
gen () 564, 565 
getch () 781 
get expr () 95 
get~refix() 588 
get unmarked() 130 
getyx () 781 
globals.h 86 Index 
global variables, putting declaration and definition 
into same file 86 
used by I.!'X 86 
glue functions, from curses to video 1/0 771 
goal symbol 168, 338 
go command, IDE 850 
"goes to" operator (see 
Goto (LR parse tables) 412 
goto, processing by compiler 638, 640 
inC-code 474 
C style note 23 
vectored (see switch) 
goto entries, in LR parse table 355 
goto transitions, in LALR parse table 372 
grammar 52 
associativity in 175 
attributed 187 
augmented and attributed 191 
C806 
context-free 166 
controlling order of evaluation 181 
development, dummy const_expr 530 
for regular expressions 87 
LALR(I) 365 
I.!'X 88 
list 175 
LL( I) grammars cannot be left recursive 226 
LR(O) 354 
modified by occs for LALR(I) grammars 401 
modifying 218 
modifying imbedded actions for bottom-up 
parser 354 
Q 222 
recursion in 175 
recursive 180 
right-linear 174 s 173 
ambiguous 182 
ambiguous (see ambiguous grammars) 
attributed 186 
augmented 183 
expression 180 
LALR(I) 337 
LL(O) 211 
LL(I) 211 
LR(I) 361 
occs ambiguous 856 
precedence built into 180 
SLR(I) 361 
translating to syntax diagram 13 
using to recognize sentence 8 
transformations, occs 864, 867 
graph, syntax (see syntax diagram) 
greedy algorithm (matches longest string) 60 
disadvantages 62 
NFA interpreter 114 
as used by I.!'X 818 
grep, implementing with NFA interpreter 113 
ground() 778 
group, field in DFA STATE 126 
grouping, in regular -expression 55, 817 
Groups [] 135 
H 
handle 169 
detecting with state machine 343, 344 
hard-coded scanners 50 
hardware problems, volatile 664 
hash add() 715 
hashing 710f, 723 
addition and hashpjw 483 
Index 
adding symbols 718 
addition 723 
delete 719 
demonstration program 710 
finding symbols 720 
hash _pjw () 723, 724 
hash-table elements 716 
hash table 482 
high-level descriptions 712 
implementation 715 
occs STATE [state_ hash () 1 420 
printing 
functions (see also hashpjw and addition) 
hash.h 712 
hashpjw, 16-bit implementation 483,484 
portable implementation hash_pjw() 715, 
723 
HASH TAB 716,717,722 
hash iiible, picture 718 
hash value 483 
find for set (function description) 691 
header comment, -h, -H (~X) 826 
Heap 416 
heap, combined with stack 456 
fragmentation 457 
segment 456 
hidewin () 779 
hide window, curses 779, 790 
high byte, accessing without shift 685 
High water mark 577 
hobbit 535 -
horizontal stacks, spedifying in IDE log file 850 
I() 455 
IBM/PC, box-drawing characters box.h 787 
IBM/PC, video 746 
character attribute bits 750 
video 1/0 functions (see video 1/0) 
IDE 845 
breakpoints 848 
change stack-window size and specify input 
file to debugger. 853 
command-line processing 853 
debugger hooks 84 7 
debugger hooks for Ctri-A, Ctrl-B. 263 
debugger hooks, sources 514,518 
debug-mode commands 847 
display lexeme 852 
enable (occs/LLama -D) 843 
error output function: yyerror () 250 
examine-file command 850 
go command 850 
go mode, adding delay 849 
initial debug screen 847 
initialization 247 
initialize debugging 246 
(Interactive Debugging Environment) 242 
(Interactive Debugging Environment) 845 
log all output to file 850 
log file, create without window updates 850 
log file, specify horizontal or vertical stacks 
850 
main control loop [delay () 1 255 
noninteractive mode 850 
parsing command-line arguments 246 
printing oa:s value stack 864 
print message to prompt window 855 
print value stack in C compiler debugging 
mode 514 
print value-stack item under IDE 853 
production breakpoints 264 
quit command 851 
redraw stack window 851 
save screen to file 851 
single step command 847 
specify input file 850 
stack breakpoint 255 stack-window size, changing from the com· 
mand line 846 
update stack window, yy_pstack () 255 
window names 846 
identi tier processing, in declaration 528 
creating values for 599 
in C-code 450 
undeclared 598 
identity element, (*e 53 
i.f/else 638 
ambiguity in 219 
processing 637 
statements, nested 639 
!file 95 
!FREE 754 
Ifunct 100 
ii advance () 42 
ii-fillbuf () 47 
ii-flush() 44 
iC flushbuf (needed by ~X) 824 
ii input (needed by ~X) 824 
ii io () 40 
ii-io (needed by ~X) 824 
ii -look() 47 
ii-lookahead() 50 
ii -lookahead (needed by ~X) 824 
ii-mark end() 42 
ii-rnark-start() 42 
ii-rnove-start() 42 
ii-newfile () 40 
ii-newfile (needed by ~X) 824 
ii:::: prefix 825 
ii_pushback(n) 47 
ii term() 48 
iCunput () 50 
iC unterrn () 48 
IMALLOC 754 
imbedded actions 354 
cause shift/reduce conflicts 354 
in oa:s 864 
translated by occs, example 536 
translation by occs 406 
immediate, addressing mode 462 
irnplici t (field in symbol structure) 488 
implicit declarations 598 
type conversion 620 
inadequate states 360 
might be added in LALR( I) machine 367 
INBOUNDS () 686 
inch() 782 
include files, used by support functions 681 
incop () 603 
indirect addressing modes 463 
combined with eftective address &WP ( &p) 463, 
465 
prefixes, inC-code [c-code.h1 465 
in dstates() 129 
Ingroup[) 135 
inherited attributes 187 
in top-down parser 203 
init () 772 
init groups() 135 
initiaifzation, 
actions--done in nonrecursive list element 
524 
C compiler (listings) 515 
input system 41 
list-element production that is executed first 
178 
LLama user supplied 855 
LLama value stack 884 
occs/LLama user supplied 853 
productions, C compiler (listings) 524 
curses (initscr.c) 791 
direct-video functions 749 
link (decl.c) 526 
initializers, symbol. args 532 
initscr (),Initialize, (high-level description) 
776 Input 100 
input 32 
input() 73 
input buffer 15 
Input-buffer 95 
input butrer (figure) 38 
flush: i i flush () 44 
loadii fillbuf () 47 
~X 95-
input.c 39 903 
input () (~X character-input function) 820 
input file, ~X 814 
open new: ii newfile () 40 
specify in IDE 850 
input, that doesn't match a ~X regular expression 
819 
input, untranslated (binary) 40 
input functions, ~X low-level 96 
input pointer, advancing: ii_advance () 42 
input routines, changing low-level ii _ io () 40 
input system, 35 
access routines 43 
design criteria 36 
example 36 
initialization 41 
macros and data structures 39 
marker movement 43 
organization: butrers and pointers 37 
systems 35 
simple butrered 15 
\ 0-terminated-strings 47 
instruction, optimization 659 
output and formatting 566 
two-address, three-address 447 
int86 () 754 
i.nt, convert to pointer with double cast 688 
integer, computing largest positive with macro 
115 
constants, C compiler 593 
constants, used for enumerated types 550 
largest (MAXINT) 685 
intensity, changing on screen 749 
interaction, between optimizations 663 
between scanner and code generator via sym­
bol table 529 
between scanner and code generator via sym­
bol table (problems) 536 
interactive debugging environment (see IDE) 
interface, lexical analyzer to parser 33 
intermediate languages 5, 446 
advantages, disadvantages 6 
converting postfix to a syntax tree 668 
postfix used by optimizer 667 
interpreters 6 
interpreting an NFA, theory 113 
implementation 115 
INTERSECT (function description) 692 
intrinsic functions 657 
invert() 691 
INVERT () 693, 695 
ip, inC-code virtual machine 452 
"is defined as" operator (see 
IS DISJOINT (function description) 693 
IS-EMPTY (function description) 693 
IS-EQUIVALENT (function description) 693 
IS-INTERSECTING (function description) 693 
ITEM 410, 420 
comparison, i tern_ crnp () 420 
management, occs 420 
item crnp() 420 
item,£ 364 
LR(O) 356 
LR(I) 362 
adding to LR states 357 
I (X) 86 
J 
jump table 478, 647 
904 
K 
kernel 357 
key 479 
detect key pressed under UNIX 246 
keyboard status, getting under UNIX (SIGIO) 246 
Kleene closure (*) 53 
K&R-style function-argument definitions 555 
L 
-1, switch to oc:c:s/LLama 844 
L token (!!'X) 95 
label, argument to link 552 
/abel.h 554 
labels 640 
for true/false targets 602 
numeric componant ofqoto 641 
alphabetic componants of 554 
inC-code 474 
to link, emitted 555 
ladies, Camptown I 07 
LALR(l) grammar 337, 365 
LALR(l) parse table, size 368 
manufacturing 368 
subroutines to generate 408 
sample in oc:c:s-generated parser 389 
LALR parser, simplified parser loop 373 
LALR( I) state-machine description, output by 
occs/LLama -v 845, 869 
language 52, 166 
intermediate 446 
intermediate (see intermediate languages) 
LARGEST INT 115 
largest integer, MAXINT 685 
largest positive integer, LARGEST_INT 115 
LASTELE () 686 
layers, symbol table 479 
LC, struct_specijier~STRUCT opt_tag LC 
def list RC 546 
LEAVE 87 
%left 856 
left associativity, fudging with a right-recursive 
grammar 176 
left factoring 219 
left-hand side, 166 
as subroutine 18 
%left (in Table E.5) 857 
leftmost derivation 168 
left recursion 10, 175 
eliminating from grammar 226 
problems with II 
legal lookahed () 23 
!error () 289 
level (field in symbol structure) 486 
level, nesting 530 
!!'X 812 
algorithm used by output state-machine driver 
62 
anchor processing 10 I 
anchors 817 
change bad-input error message (YYBADINP) 
823 
character classes 8 I 8 
choose an alternate driver file, -m 826 
closure 107, 818 
code part rule 820 
command-line switches 825 
compressed transition matrix 65 
compressing tables 140 
concatenation I 04, 817 
conflicting regular expressions 819 
copy template file from file to standard output 
745 
debugging output routines 74 
DFA transition matrix. Dtran, Nstates 126 
end-of-file processing, yywrap () 80 
error-message processing 88, 90 
escape sequences 817 global variables 86 
grammar 88 
grouping 817 
header comment, -h, -H 826 
initialize (yy _ ini t _lex) 822 
input butrers 95 
input character (input () ) 820 
input file organization 8 14 
input line number (yylineno) 820 
input specification used by LLama and occs 
271 
input that doesn't match a regular expression 
819 
keep processing (yyrnore) 822 
lexeme (yytext) 820 
lexeme length (yyleng) 820 
lexical analyzer 95 
LIB environment 826 
limits and bugs 826 
literal characters 95 
local variables in actions 820 
low-level input functions 96, 824 
macro support 93, 10 I, 8 18 
main () 820, 821 
matching normal characters, escape sequences 
817 
memory management 88 
metacharacters 8 16 
multiple-line actions 95 
open new input file (yywrap) 823 
operator precedence 819 
OR operator I 04, 8 17 
output character (output) 821 
output, files 815 
output, state-machine description. 
parenthesized subexpressions 107 
parser 101 
printing tables 140 
print lexeme (ECHO) 821 
problems with implicit concatenation operator 
106 
push back character (unput) 821 
push back several characgters (yyless) 822 
regular expressions 8 16 
rules section 816 
single-character matches 108 
single characters 107 
source code 81 
stack used for state allocation 88 
state-machine driver 73, 75 
string management 89 
subroutines and variables for use in actions 
820 
suppressing line directives, -1 826 
table compression, ~. -f 825 
template file, organization 63 
unary operators (closure) 108 
uncompressed transition matrix 65 
UNIX-compatible newline, -u 826 
use standard output, -t 826 
using with oc:c:s 812 
verbose-mode output, -v, -V 826 
YYERROR 821 
Lexeme 100 
Lexeme 3, 33 
boundaries: ii mark start (), 
ii mark end() 42 
display uDder IDE 852 
markers, pMark, sMark, eMark 37 
termination: ii term() and ii unterm () 
48 - -
lexical analyzer 3, 32 
C compiler 51 8 
error recovery 34 
lexical-analyzer generator (see !!'X) 
interaction with code generator via symbol 
table 529 
interaction with code generator via symbol 
table (problems) 536 interface to parser 33 
l!'X'sown 95 Index 
advantages of independent phase 33 
state-machine driven 60 
using your own under oc:c:s/LLama 855 
lex io.c 74 
lexpar 63 
lexyy.c 63f. 
l.h 689 
LHS (see left-hand side) 
LIB, environment variable (occs/LLama) 844, 
l!'X826 
lifetime analysis 673 
limits and bugs, !!'X 826 
limit scope, PRIVATE 42 
linear optimizations 658 
lline directives, suppress under OCCs/LLama (-1) 
844 
Lineno 95 
line wrap, curses 778 
linkage, subroutine 467 
link, dynamic and static 472 
linked list, used to resolve colision, in symbol table 
481 
link instruction in C-code 471 
instruction, argument (label) generation 552 
link structure 492 
in declaration chain 493 
initialize (decl.c) 526 
labels, emitted 555 
merge (decl.c) 526 
pointer to (used as an attribute) 524 
links, cross (see cross links) 
list, doubly linked 718 
enumerator 493 
finished-states list (oc:c:s) 415 
grammars that describe lists 175 
nonrecursive element of list reduced first 341 
in a bottom-up parser 340 
right recursive use a lot of stack 343 
with delimiters 179 
unfinished-state (oc:c:s) 416 
literal characters, !!'X 95 
LL grammar 170 
LL(O) grammars 211 
LL(I) grammars 211,275 
cannot be left recursive 226 
parser, implementing 229 
SELECTset 217 
LLama 883 (see also occs/LLama) 
$$, $1, etc. 883 
$ attribute processing 332 
changing action taken by the parser on an error 
883 
command-line processing 322 
compilation directives and exit stati 276 
computing FIRST,FOLLOW,SELECTsets 
304-311 
copy template file from file to standard output 
745 
creating parse tables 304 
% directives and error recovery 883 
error functions 328 
implementation 270 
input file 282 
interactive debugging environment sources­
yydebug .c (see IDE) 
internal lexical analyzer 271 
internal parser 270 
internal symbol table 275 
internal token set 271 
!!'X input specification 271 
LLama input file describing its own parser 
main() 322 
numeric limits for token values 277 
output driver subroutine 319 
output file discussed 229 
output functions, 278 
output functions 328 
Index 
output the token definitions 321 
parser action: add s ynch () 289 
parser action: add-to rhs () 289 
parser action: end-opt ( ) 289 
parser action: first sym () 289 
parser action: lerro~ () 289 
parser action: make term () 289 
parser action: new field() 289 
parser action: new -lev () 289 
parser action: new nonterm () 290 
parser action: new-rhs () 290 
parser action: output () 290 
parser action: prec ( ) 290 
parser action: prec list () 290 
parser action: start opt () 290 
parser action: union def () 290 
parse-table creation :ftl 
parse tables 21 0 
parse tables, pair compress 843 
printing the value-stack 885 
recursive-descent grammar 282 
recursive-descent parser 282 
sample input file 885 
sign-on message 333 
Statistics functions 328 
symbol table (data structures) 278 
%synch directive 883 
token definitions 276 
top-down attributes 883 
typing LLama's value stack 884 
uncompressed parse tables 843 
user supplied initialization 855 
value stack 884 
value stack, yyvstype 205 
LLama-generated parser 
debugging functions and macros 235 
numerical limits of tokenized input symbols 
229 
output streams 235 
parse-and value-stack declarations 229 
parse-table declarations 229 
symbol stack 235 
symbol-to-string conversion arrays. 235 
YYDEBUG 235 
yyparse () 242 
l.lib, subroutines for ll'X actions to use 820 
1/out.sym 885 
load, input buffer: ii fillbuf () 47 
local static name conflicts 486 
local variables 547, 559 
automatic variables, handling at run times 467 
in I.l'X actions 820 
in occs/LLama actions 842 
code that processes 54 7 f 
static 563 
location counter 458 
lee var space () 563 
log file, create without window updates 850 
logical AND operator(&&) 624,626 
logical complement of set COMPLEMENT () 695 
logical !value 580 
logical OR, at the top level in Thompson's con­
struction 81 
and auxiliary stack (listings) 622 
in C compiler 622 
logical right-shift directive, inC-code 473 
log output to file, IDE 850 
long 491 
long 493 
longest, string (see greedy algorithm) 
word in English, see (floccinaucinihilipili -
fication) 
Lookahead 17 
lookahead II, 15-17, 35 
function, ii look () 47 
set, LR(I) 361 
used to compute next state in finite automata 
57 
lookup tables, disambiguate lexemes 828, 833 in hard-coded lexical analyzer 50 
loops 642 
low-level input functions, ll'X 96 
changing: ii io () 40 
LR(O), grammar 354 
item 356 
LR(I ), grammars 361 
item 362 
lookahead set, (see lookahead set) 
LR grammar 170 
LR item, management by occs 420 
internal occs representation 410 
LR parsers, advantages and disadvantages 337 
LR parse tables 
decompression 369 
goto entries 355 
nonterminal edges 355 
Action and Goto components 345 
adding E productions to 359 
creating 357 
creating (theory) 354 
shift entries 356 
representing 368 
subroutines to create 423f. 
use FOLLOW set to resolve conflicts 361 
terminal edges 356 
LR state, internal occs representation 411 
LR state tables (and LALR), representing 368 
LSB at lowest address in C-code virtual machine 
461 
!value 578 
use &WP (&_p) to access 599 
logical vs. physical 580 
implementation 583 
logical and physical [how handled by 
rvalue ()I 588 
summary 582 
lword 450 
M 
-m, switch to occs/LLama 844 
machine () 101 
machine, state (see state machine) 
machine, virtual (see virtual machine) 
macro 
computes largest.positive integer 115 
expansion, I.l'X 10 I 
expansion, ll'X 818 
8086 684 
conditional-compilation for LLama and occs 
275 
in C-code 4 75 
I.l'X support 93 
made by -a and -p switch 876 
multiple-statement 786 
set 697 
set-manipulation (see set macros) 
stack maintenance 686 
stack ( customization for occs output file) 386 
that modify the occs/LLama parser 840 
video-BIOS 756 
main (),translate to main () 476 
main(),Ccompiler 514 
ll'X 155, 820, 821 
maintenance layer, in symbol table 479 
make dtran () 130 
make::) con () 593 
make implicit declaration() 598 
maketab () 712,717 
make_ term() 289 
make types match() 627 
map, bit 690-
map, of temporary variables on run-time stack: 
Region [] 577 
marker movement 43 
mark lexeme boundaries: i i _rna r k _start () , 
ii mark end () 42 
match() -;-17 match, any character 817 
matches, multiple 55 
MATCH(t) 100 
matrix, transition 60 
max() 686 
maximum values 686 
MAXINT 685 
MAXLEX 37 
MAXLOOK 37 
MEMBER () 693, 698 
vs. TEST() 695 
membership, test on complemented sets, 
MEMBER() vs. TEST() 695 
memiset () 745 
memory alignment (see alignment) 
memory 
allocation 559 
fill with integer value 745 
management, I.l'X 88 
occs 412 905 
symbol-table functions [symtab.cl 497 
organization, in C-code virtual machine 455 
memory-mapped screens 749 
merge, declarator and specifier 
[add spec to decl ()I 536 
link (dec I.e) 526 
multiple productions into single subroutine. 
21 
metacharacter, in regular expression 54 
escaping (quotes marks) 55 
in ll'X 816 
MGA 749 
Microsoft C, (Z.g switch creates function prototypes 
689 
Microsoft link, /NOE switch avoids name conflicts 
781 
min() 686 
MINACT 276 
min dfa () 135 
minimize() 135 
minimization, DFA 132 
minimum values 686 
MINNONTERM, 276 
model state machine with arrays 57 
modes, addressing (see C-code, addressing modes) 
462 
modify the behaviour of the occsJLLama parser 
840 
module, relocatable object 459 
MOD WSIZE(x) 697 
MONBASE 756 
move() 117,781 
movedot ( ) 420 
movefile() 741 
move, file 741 
input marker 43 
set 117 
start marker: ii move start () 42 
window, curses 779 
window, mvwin.c 791 
window-relative cursor and read character, 
winch.c 794 
window-relative Cursor, wmove.c 800 
MS () 683 
MS-DOS, end-of-line problems in anchors I 04 
MS-oos-specific code 683 
multiple accepting actions, handled by I.l'X 117 
multiple-line actions, I.l'X 95 
multiple right-hand sides, a. 192 
multiple-statement macros 786 
trailing else in 64 
multiple tokens, T" 192 
mvinch () 782 
mvwin () 779 
mvwinch () 782 
mvwinr () 779 
N 
name, conflicts of local-static names 486 
906 
name (field in s ymbo 1 structure) 486 
NAME, has precedence 511 
{name} in I.!' X regular expression 818 
name--.NAME 530 
NAME, new name--.NAME 528 
<name>, occs 861 
names, I.!' X (start with yy Yy YY ii ) 825 
NAME, unary--.NAME 594, 613-
$N, attribute notation for top-down grammar 205 
NBITS (} 685 
NCOLS 141 
NCOLS 141 
near pointer 684 
need 47 
negative, attribute ($-1) 860 
character class, add \n to 55 
nested, parentheses (recognize with state machine) 
196 
subroutines, Pascal 804 
variable definitions 559 
Nest lev 530 
NEVER 63 
new(} ss-:-412 
new field(} 289 
newitem(} 420 
new lev (} 289 
newline, nonstandard definition in I.!'X 817 
new macro ( ) 93 
new-name () 352 
new :=-name--.NAME 528 
newname () 26 
new name, var del -.new name 530 
new-nonterm() 290 
new-rhs () 290 
newset (}' 691,699 
newstate (} 417 
newsym(} 712,716 
new value(} 585 
newwin (),Create window, subwindow. (high­
level description) 777 
next2, field in NFA 84 
Next allocate 416 
next field, in NFA structure 84 
in symbol structure 488 
next member ( ) 692, 708 
next(N,c)=M 57 
next set element. (function description) 692 
next state, finding 80 
nextsym (} 713,720 
Nfa 116 
nfa (} 116 
NFA structure 84, 88 
NFA 58 
conversion to DFA (see subset construction) 
converting regular expression to (see 
Thompson's construction) 
formal definition 59 
interpretation, implementation 115 
print to standard output 110 
using directly to recognize strings 113 
NFA MAX 86 
Nfa-states [] 88, 116 
nl (),Map newlines. (high-level description) 777 
nocrmode (), buffi:red input. (high-level descrip­
tion) 776 
node 669 
node, terminal (see terminal nodes) 
noecho () , Do not echo. (high-level description) 
777 
/NOE switch, avoids name conflicts 781 
NO MORE CHARS (} 43 
%nonassoc 856, 857 
nonconstant dead assignments 663 
nondeterministic finite automaton (see NFA) 
nongreedy algorithm (matches first string) 62, 114 
noninteractive mode, IDE 850 
nonl (),Do not map new lines. (high-level descrip­
tion) 777 
nonterminal 7, 167 edges, in LR parse table 355 
names, occs/LLama 839 
how they get onto bottom-up parse stack 344 
nullable 214 
attributes for 187 
form interior nodes in parse tree 9 
unreachable 219 
no save (), (high-level description) 779 
NOT operator (! ), in C compiler 602 
nouns 490 
Nstates 126 
nullable, nonterminals 214 
productions 218 
null, set 694 
string 52 
number of elements, in set 691 
on stack 687 
number, production (in yyout.sym) 868 
NUMCOLS 756 
NUMELE () 686 
num ele (} 691,701 
numeric, component oflabel 641 
values for symbols 208 
Numgroups 135 
NUM OR ID 14 
NUMROWS '756 
0 
object module, relocatable 459 
occs/LLarna 836 
actions, local variables 842 
alternative parser templates (-m) 844 
code section 842 
compiling for debugging 845 
create parser only (-p) 844 
debug mode (see IDE) 
definitions section 837 
£ productions 841 
generate action subrouine only (-a) 843 
input file 837 
input-file formatting conventions 841 
internal names 839 
ltline directives (-1) 844 
making private variables public (-g) 844 
modified BNF 839 
nonterminal names 839 
output files 842 
output functions, bss-segment 855 
output functions, code-segment 855 
output functions, comments 855 
output functions, data-segment 855 
parser, modifying behaviour of 840 
parser subroutine 853 
parser subroutine (see yyparse ()) 
parser template placed on path in LIB environ­
ment 844 
production vs. debug mode 845 
representing productions 839 
return and break statements in action 841 
rules section 839 
rules section for expression compiler (expr.y) 
841 
send large tables to yyouttab.c (-T) 844 
send large tables to yyouttab.c (-T) 844 
send output to stdout (-t) 844 
supply your own lexical analyzer 855 
suppress warning messages (-w) 845 
symbol-table dump (-s) 844 
token names 838 
useful subroutines and variables 852 
useful subroutines and variables 854 
user supplied initialization 853 
verbose-mode (-v, -V) 845 
occs, output file 381 
occs .par 385 
occs 856 
$$=$1 default action 858 
$$, $1, etc. 858 
adding reductions to tables, yystate.c 431 Index 
algorithm used by occs to create LALR state 
machine 415 
ambiguous grammars 856 
-a output (file header) 410 
attributes 858 
avoiding cascadin_g error messages YYCAS­
CADE 875 
change type of the value stack 858 
copy template file from file to standard output 
745 
% directives and comments 857 
error recovery 348 
error recovery 875 
$<field>N 863 
finished-states list 415 
grammatical transformations 864,867 
high-level table-generation subroutines, 
yystate.c 423 
hints and warnings 881 
imbedded actions 864 
imbedded actions translated (example) 536 
interactive debugging environment (see IDE) 
interactive debugging environment sources­
yydebug.c (see IDE) 
internals 401 
ITEM management 420 
lexical analyzer (see LLama, internal lexical 
analyzer) 
low-level table-generation subroutines, 
yystate.c 425 
memory management 412 
<name> 861 
negative attributes ($-1) 860 
optional subexpressions [ ... J 865 
output files 815 
output file (see occs-generated parser) 
parser action (see LLama, action) 
%prec 872 
print subroutines, yystate.c 434 
putting parser and actions in diffi:rent files 875 
repeating subexpressions [ .•. J * 867 
representation of LR items 410 
representation of LR parse tables 412 
representation of LR states 411 
resolving shift/reduce and reduce/reduce 
conflicts 871 
sample input file 879 
specifying precedence and associativity 856 
stack macros in yystack.h 688 
STATE comparison [state cmp ()I 420 
state data base 417 -
STATE hashing [state hash(} I 420 
state management 415-
statistics subroutines, yystate.c 433 
subroutines that create auxiliary tables, 
yystate.c 437 
subroutines to create LR parse tables 423f. 
subroutines to generate LALR( I ) parse tables 
408 
symbol-table dump 867 
symbol-table (see LLama, symbol table) 
%%, %{%),%token, %term, comments (in 
Table E.5) 857 
translating dollar attributes 406 
translating imbedded actions 406 
%type 861 
unclosed-state list 417 
unfinished-states list 416 
%union 860 
%union fields 406 
using with I.!'X 812 
value stack 858 
occs-generated parser 
action subroutine 388 
$ attributes (see$) 
compressed parse tables 393 
error marker in tables 388 
error recovery 400 
reduce subroutine [yy _reduce(} I 400 
Index 
shift subroutine [yy shift () 1 396 
stack initialization 400 
symbol stack: [Yy dstack1 394 
table decompression [yy next () 1 393 
the oa:s output file 381 -
the parser itself 400 
OFF () 684, 686 
Offset 562 
oftSet 684 
isolating from 8086 address 685 
to structure fields 546 
to local variable in stack frame 562 
one's complement operator C). inC compiler 602 
on ferr () 732 
opcode 459 
open, new input file: ii newfile () 40 
operation, internal set function for binary opera­
tions 691 
operator 
assignment 620 
conditional 619 
precedence, !..!'X 819 
precedence, in regular expression 56 
arithmetic in C-code 473 
unary in grammar 181 
unary (see unary operators) 
optimization 657 
common-subexpression elimination 672 
constant folding and propagation 659 
dead code and variables 660 
example of peephole 665 
instruction 659 
interaction between 663 
linear 658 
parser 657 
peephole 658 
register allocation and lifetime analysis 673 
structural 667 
strength reduction 658 
productions, (see production, optional) 
subexpressions, oa:s [ ... 1 865 
opt_specifiers 524 
opt_specifiers, ext_def--wpt_specifiers funct_decl 
def_ list compound stmt 552 
opt-tag-+£ 543 -
op(tag, struct_specifier--+STRVCT opt_tag LC 
def_ list RC 546 
order of evaluation, as controlled by grammar 181 
OR (see also I) 
in Thompson's construction 81 
operator ( 1 I ), in C compiler 622 
operator, !..!'X 817 
processing, I..!' X I 04 
output () 73, 290 
output files,l..!'X and occs 815, 842 
output function, error 250 
output 
IDE direct video 846 
!..!'X, output-character function 821 
log to file from IDE 850 
streams, LLama 235 
streams, oa:s (code, data,bss) 552 
ox() 275 
p 
-p !..!'X, command-line switch 876 
-p, occs/LLama command-line switch 844 
*p++;, generate code for 609 
( *p) ++;, generate code for 610 
*++p;, generate code for 610 
++*p;, generate code for 611 
p++[3] ;,generate code for 612 
++p [ 3] ; , generate code for 613 
p () 566 
pack variables, doni if back end is used 563 
padding, in structure field 547 
pages, video display 749 
pair compression, compression ratio 72 compressed tables 141 
in LALR(l ) parse tables 368 
selling threshold 72 
transition matrix 68 
LLama parse tables 843 
pairs() 141 
panic-mode error recovery 348 (see also error 
recovery) 
in oa:s parser 875 
parentheses, in regular expression 55 
in subexpression, handled by !..!'X 107 
parse err () 88 
parse and parsing, 3 (see also occs, LLama) 
bouom-up 169, 337 
top-down 169, 195 
generate trace from IDE 850 
parser 
configure parser for C-compiler 509 
create only (-p) 844 
generation 408 
generator, top down (see LLama) 
generator, bouom up (see oa:s) 
how a parser decides which productions to 
apply 212 
implementing LL(l) 229 
interface to lexical analyzer 33 
!..!'X 101 
LLama's internal 270 
oa:s-generated (see occs-generated parser) 
oa:s/LLama-generated (see occs/LLama 
parser) 840 
optimizations 657 
predictive 20 I 
put occs parser and actions in ditrerent files 
875 
LR (see LR parsers and bouom-up parsing) 
recursive descent 198 
table driven with augmented grammars 202 
subroutine, occs/LLama 853 
template, placed on path in LIB environment 
844 
visible (see IDE) 
parse table 
code to make top-down 311 
creating LR(l ) 362 
created by LLama 304 
generated by LLama 210 
how bottom-up parse table relates to state 
diagram 355 
internal occs representation 412 
LLama uncompressed 843 
LR (See LR parse tables) 
making 213 
oa:s compressed 393 
sample in oa:s-generated parser 389 
top down 208 
parse tree 4 
and ambiguous grammars 182 
evolution during bottom-up parse 342 
execute actions while traversing 203 
implicit in recursive-descent subroutine calling 
sequence 21 
path to current node rememembered on 
recursive-descent stack 199 
relation to bottom-up parse stack 340 
semantic difficulties 170 
Pascal compilers 802 
passes, compiler I 
path, search for file along path in environment 
string 745 
pattern matching, greedy algorithm 60 
nongreedy algorithm 62 
pchar () 732 
PDA (see push-down automata) 
peephole optimizations 658 
example 665 
pgroups () 137 
phase, parser 3,4 
phase problems, with yytext 242 phrase 166, 167 
PHYS () 684, 685 
physical address, finding on an 8086 685 
physical complement of set INVERT () 695 
physical !value 580 
piglet 553 
pMark 37 
pointer 
and array dereferencing 603 
create from int with double cast 688 
frame pointer 469 
near and far 907 
problems with decrement in 8086 686(fn) 
pooh, winnie der 553 
pop 687 
in C-code 465 
pop() 688 
pop () 688 
popn 687 
popn () 688 
popn () 688 
pop stack elements (macro, high-level description) 
687 
Positive closure ( +) 53 
postdecrement operator, in C compiler 603 
postfix 448 
converting intermediate code to a syntax tree 
668 
intermediate code (generating) 668 
intermediate language, used by optimizer 667 
postincrement operator, in C compiler 603 
prec() 290 
%prec 872 
precedence 
and associativity in yyout.sym 868 
controlling when eliminating ambiguity from 
grammar 225 
!..!'X operator 819 
regular-expression operator 56 
specifying in grammar 180 
specifying under oa:s 856 
stored by oa:s 281 
used to disambiguate non-arithmetic tokens 
511 
used to resolve conflicts in LALR tables 378 
%prec (in Table E.5) 857 
prec list () 290 
%prec, stored in precedence table 281 
PREC TAB 281 
predeerement operator, in C compiler 603 
predictive parser 20 I 
prefix 52, 478 
C-code, indirect-mode [c-code.h1 465 
subroutine 552 
viable 169 
preincrement operator, in C compiler 603 
preprocessor directives, inC-code 476 
print, argv-like vector array 733 
C-code virtual-machine pm () 476 
DFA state groups 137 
functions (in library) 731 
human-readable string or character form 732 
LLama value-stack 885 
oa:s value stack from IDE 864 
set 708 
message to IDE prompt window 855 
multiple-line comment 734 
printf () workhorse function 734 
set elements (function description) 692 
print_array() 140 
printf (),direct-video version 750 
mapped to yycode () in occs debugging mode 
385 
workhorse function 734 
print instruction() 566 
printiiiacs () 93 
printv () 733 
printw () 782 
print value-stack item under IDE 853 
908 
PRIVATE 42, 682 
private 457 
private variables, making public under 
oc:cs/LLama (-g) 844 
prnt () 734, 735 
PROC, and SEG () 457 
PRODUCTION 279 
production 1, 166 
as subroutine I 8 
breakpoint, IDE 264 
mode, oc:cs/LLama 845 
nullable 218 
numbers, in yyout.sym 868 
oc:cs/LLama (inserting code) 841 
optional 8 
E 173 
executed first or last 178 
merging into single subroutine. 21 
represented in otts/LLama 839 
start 357, 842 
start 842 
unreachable 219 
program-load process, 455 
program prefix 455 
prompt window, print message to IDE 855 
proper prefix 52 
suffix 52 
substring 52 
prototypes, function (see function prototype) 
pset () 692 
pseudo registers 
ptab () 714, 720 
ptr 450 
public 458 
PUBLIC 683 
public variables created by occs -p or -a 876 
purge undecl() 598 
push () 687, 688 
push () 688 
pushback 15, 35, 48 
push-down automata (PDA) 196 
and recursive descent 198 
used in bottom-up parsing 338 
used for a top-down parsing 20 I , 208 
used to implement attributed grammars 203 
push, in C<ode 
push stack element (macro, high-level description) 
687 
Q 
Q grammar 222 
quads 447 
without explicit assignments 447 
compared to triples 448 
quit command, IDE 851 
quote marks, escape metacharacters in regular 
expression 55 
quotes marks, in regular expressions 101 
R 
R 771 
racetrack, Camptown I 07 
raise() 699 
RANGE() 686 
RC, struct_specijier~STRUCT opt_tag LC 
def_list RC 546 
read, delayed until after first advance 40 
recognition, sentence 8 
recognizer 25, 56, 167 
record 450 
record 479 
activation (see stack frame) 
recursion, and the stack frame 470 
comer substitution 228 
in bottom-up parsing 340 
in grammar 175 
in grammar I 80 
in grammar 9 in recursive-descent parser 20 
left (see left recursion) 
replace with control loop and explicit stack 
200 
right (see right recursion) 
recursive descent I 8 
attributes compared to bottom-up parsing 348 
parser 
arguments 26 
as push-down automata 198 
for LLama 282 
return values 26 
use the stack 198 
used by LLama 270 
recycling temporary variables 575 
redraw stack window, IDE 851 
reduce 338, 343 
reduce directives, in LR parse table 356 
represented in yyout.doc 869 
subroutine, yy reduce () 400 
used to resolve-conflicts in LALR tables 376 
by E productions 359 
reduce/reduce conflicts 360 
resolving 380, 871 
reduction, in yyout.doc state 869 
strength (see strength reduction) 
redundant row and column elimination 65, 146 
redundant states, removing from DFA 136 
references, to temporary-variable in emitted code, 
T () 574 
referencing, pointer and array via * or [] operator 
603 
refresh () 780 
Region [] 577 
register allocation, optimization 673 
register set, in C-eode virtual machine 451, 453, 
454 
registers, as temporaries 573 
pseudo 
regular definition 56 
regular 
expressions 54 
( ) operator 55 
anchors C$) 
[I (character clases) 54 
closure (*+?) 55 
concatenation 54 
converting to NFA 8 I 
grammar 87 
grouping 55 
limitations 55 
{n,m} operator 55 
I operator 55 
operator precedence 56 
conflicting (in ll'X input file) 819 
n:x 816 
recognizing with NFA interpreter 113 
simplifying to get smaller internal table size 
827 
reinitialize stack (macro, high-level description) 
687 
reject 347 
relational operators, processing by C compiler 626, 
628 
release value() 593 
relocatable object module 459 
relop () 627 
REMOVE () 693, 698 
repeating subexpressions, occs [ ... l * 867 
representing productions, occs/LLama 839 
restore region of screen, direct-video version 751 
ret () , in C-eode 466,477 
return 637, 638 
in occs/LLama actions 841 
return values, from yyparse () 837 
in recursive-descent parser 26 
Pascal 803 
subroutine 472-473 
reverse links() 535 
reverse-POiish notation (see postfix) RHS (see right-hand side) 
%right 856 
right-hand side (RHS) 7, 167 
length, Yy rhslen 392 
in yyout.sym 868 
multiple a, 192 
%right (in Table E.5) 857 
right-linear grammars 174 
rightmost derivation 169 
right recursion 175 
eliminating. 21 Index 
gets arguments pushed in correct order 613 
right-recursive lists use a lot of stack 343 
right-shift directive, in C<ode 473 
ring buffi:r 50 
rname (field in symbol structure) 486 
ROUND 697 
ROW 124 
row and column, eliminating redundant 65, 146 
RPN, reverse-Polish notation (see postfix) 
rule() 101 
rules, for forming lvalues and rvalues when pro­
cessing * and [ ] 608 
rules section, ll'X 8 16 
occs/LLama 839 
run-time, trace 477 
instructions 565 
rval ue () 587 
rvalue name() 588 
rvalue 578 
s implementation 583 
integer and integer constant (value.c) 594 
summary 582 
-s -s, LLama 885 
save(), 89, 779 
save region of screen, direct-video version 751 
save screen to file, IDE 851 
SBUF 754, 155 
scanner (see lexical analyzer) 
scope, limiting: PRIVATE 42 
levels 559 
SCREEN 757 
screen, characters and attributes 749 
dimensions 756 
representing DISPLAY 756 
save buffi:r, SBUF 755 
memory-mapped 749 
scroll () 783 
scrollok (),Enable or disable scrolling. (high­
level description) 778 
scroll, screen (direct-video version) 752 
window, wscroll.c 801 
searchenv () 745 
search, for file along path in environment string 
745 
sector (disk) 37 
seed items 357 
SEG () 457, 684, 685 
can't issue between PROC () and ENDP () 476 
generated by C compiler 524 
segment 684 
bss 456 
change [SEG () I 457 
code 456 
data 456 
heap 456 
isolating from 8086 address 685 
not modified in 8086 far-pointer decrement 
686(fn) 
in C<ode virtual machine 455 
stack 456 
segment-end markers: ebss, etext, edata 457 
segmented architecture (8086) 684 
select, between direct video and video BIOS 712 
SELECT set, code to compute 310 
LL(I) 217 
Index 
translating into an LL(l) parse !able 218 
semantic difficulties 170 
semantics vs. synrax 167 
semicolon, in C-code 457 
sentence, 166, 347, 52 
definition 4 
recognizing with grammar 8 
senlential fonn 168, 169 
sequence, sub 52 
SET 690,697 
setcrnp () 691, 701 
set, field in DFA STATE 126 
set, synchronizatiOn 20 I 
set functions and macros 690 
comparing 70 I 
complement by marking set as negative 1rue 
695 
complemenl by physically inverting bits 694 
creation and deslruction 699 
deletion del set() 701 
duplication 701 
enlarging addset () 70 I 
enlarging 702 
example 693 
FIRST (see FIRST set) 
FOLWW (see FOLWW set) 
FOLWW (see FOLLOW set) 
internal represenration 697 
implemenlation 695 
implementation difficulties 694 
LL(l)SELECT(seeSELECTset) 217 
LR(l) lookahead (see lookahead set) 
manipulation functions 706 
null and empty sets 694 
number of elements num ele () 701 
operations 702 -
operations, on languages 53 
prim set 708 
problems with complemenled sets 694 
test functions 703 
traversal 708 
set.h 690, 695 
sethash () 691 
set op () 691 
-set -op () 702 
-set-test() 691 
-set-test() 701 
-SETTYPE 695 
S grammars 173 
shadowing 479 
Shell sort, implemenration 741 
theory 739 
shift 338, 343 
shift amt 45 
shift erilries, LR parse rabies 356 
shift, attributes for token 8n 
represented in yyout.doc 869 
getting high byte of number without a shift 
685 
used to resolve conflicts in LALR rabies 376 
shift/reduce conflicts 360 
caused by imbedded actions 354 
resolving 379, 871 
Shiva 79 
short 491 
ahort 493 
shortest string (see nongreedy algorithm) 
showwin () n9 
SIGINT 512 
raised by IDEqcommand 246 
SIGIO 246 
sign extension, inC-code 474 
simple expressions in Thompson's construction 81 
single-reduction slates, eliminating 373 
algorithm for parsing minimized tables 375 
can't remove if there is an action 374 
single step, IDE 847 
singleton substitution 223 
S_input 100 si.zeof 599 
SLR(l) grammars 361 
sMark 37 
-s, occs/LLama command-line switch 844 
sorting 738 
source code, in occs/LLama definitions section 
837 
Spam 535 
specifier 489 
implementation 490 
manipulation functions [symrab.c] 501 
merge with declarator 
[add spec to decl ()I 536 
processing. c compiler 524 
symtab.h 492 
specifiers 524 
specifiers-+type _or_ class 525 
sp, in C-code virtual machine 452 
Spot 4 
ssort () 738 
implementation 741 
stack, attribute (in top-down parser) 203 
auxiliary (used to process AND and OR opera­
tors) 622 
boltom-up parse lacks lookahead infonnation 
for error recovery 348 
breakpoint, IDE 255 
C-code, virtual machine 454 
stack-manipulation directives 465 
combined with heap 456 
downward-growing slacks ANSI compatible 
688 
-element macro 687 
LLama value 884 
implemenl recursion with 200 
initializing occs-generated parser's 400 
in recursive-descent parsers 198 
-manipulation macros 686 
implemenration 688 
customization for occs output file 386 
PDA, to implement 197 
poinler, slack macros to access (high-level 
description) 687 
pushback 35 
references, $N translated to 392 
relationship between bouom-up parse stack 
and parse tree 340 
remember slate transitions in bouom-up parse 
344 
segmenl 456 
slate allocation in I.J'X 88 
symbol vs. slate in bollom-up parse 347 
synchronization-set 20 I 
temporary variable 573 
value (see value slack) 
window, IDE 255 
size, changing from the command line 846 
slack-access directives, in C-code [virtual.h] 
465 
stack-based symbol tables 480 
stack clear 687 
stack-del 686 
stack:::: ele 687 
stack empty 687 
slack empty, test for (macro, high-level description) 
687 
stack err 687 
stack frame 198, 468 
advantages 4 70 
figuring oftSet to local variable 562 
Pascal 803 
phase errors 4 71 
used for temporary variables 574 
stack full 687 
stack filii, test for (macro, high-level description) 
687 
stack.h 686 
stack item 687 
stacky 687 909 
standard input, reassigning 40 
standard output, (I.!'X) use instead of lexyy.c -t 826 
Start buf 37 
slart marker, moving: ii-move-start () 42 
slart-of-line anchor n 54 
start opt () 290 
srart prOduction 357. 842 
Slart Slate 56 
start symbol 168 
STATE 411 
allocation 417 
comparison, state crnp () 420 
srate 56 -
accepting (see accepting state) 
state, 
data base 417 
diagram, how bouom-up parse !able relates to 
state diagram 355 
inadequate 360 
management by occs 415 
dead 140 
inadequate (might be added in LALR( I) 
machine) 367 
single-reduction (see single-reduction states) 
slack, in bouom-up parse 34 7 
start 56 
unreachable 140 
tables, representing LR (LALR) 368 
state crnp () 420 
state-hash() 420 
state machine (finite automata) 56, 195 
in boltom-up parsing 343 
can't count 196 
creating LR(I ) 362 
description, in lexyy.c 64 
description, output by occs/LLama -v 845 
description, yyout.doc 869 
detenninistic (see DFA) 
driver 59 
algorithm, examples 61 
algorithm used by I.J'X 62 
I.J'X 73,75 
and grammars 174 
lexical analyzer that uses 60, 63 
LR 344 
modeled with array 57 
nondetenninistic (see NFA) 
parser, used for 195 
recognize handles with 343 
recognize nested paremheses 196 
representing 58 
!able compression 140 
statemenl 637 
break 642 
continue 642 
loops 642 
compound (see compound slatements) 
control-flow 637 
do/whi.le 643 
empty 637 
expression 637 
for 643 
goto 640 
labels 640 
nested i.f/else 639 
return 637 
simple 637 
swi.tch 642, 646 
tests 641 
whi.le 643 
statements (). 18 
static link 4 72 
stati.c local variables 563 
status. keyboard (gelling under UNIX) 246 
stdarg.h 124 
stdout, send occs/LLama output to (-t) 844 
stdscr, variable in <curses.h> n7 
stol () 726 
stop _prnt () 735 
910 
storage classes 
inC-eode 457 
C-eode indirect used for I values (&WP ( & _p) ) 
599 
converting C to C-eode 458 
[in virtual.h) 461 
stoul () 726 
strength reduction 566, 658 
string 52, 166 
accessing line number 91 
concatenation 53, 745 
constants, in C compiler 599 
I.!'X example 832 
convert to lonq 726 
created from token in oc:cs output file 392 
display with direct video 751 
empty (see E) 
environment (see environment) 
exponentiation 53 
management, I.!'X [save () I 89 
null 52 
prefixing with int to hold line number 89 
print in human-readable form 732 
recognition, using NFA directly 113 
write to window, waddstr.c 793 
STR MAX 86 
structdef 495 
STRUCT, recognized for both struct and union 
543 
struct _specifier 543 
struct specifier--.STRVCT opt tag LC def_ list 
RC 546 - -
STRUCT, struct _specifier--.STRVCT opt _tag LC 
de[_ list RC 546 
structure 
representing in symbol table 496 
access (op.c) 614 
copying 859 
declarations 543 
field, alignment and padding 547 
allocation and alignment 461 
definitions 545 
figuring of!Sets 546 
-member access 611 
representing in symbol table 494-497 
sorting with ssort () 738 
variable-length 716 
tags 543 
structural optimizations 667 
subexpressions, oc:cs optional 865 
oc:cs repeating 867 
subroutine 
arguments 469 
attributes work like 189 
handling at run time 467 
Pascal 802 
C-cOde 466 
calling sequence mirrors parse tree 21 
in I.!'X actions 820 
models LHS, implement RHS. 18 
numeric part of end-of-subroutine (listing) 640 
oc:cs/LLama support subroutines 852 
prefix and suffix generation 552 
prefix, body, and suffix 478 
return values 4 72 
Pascal nested 804 
sub-sequence 52 
subset () 691, 701 
subset construction 122 
algorithm 124 
convert NFA to DFA with make dtran () tm -
subset, find (function description) 691 
substitution, comer 221 
singleton 223 
can create ambiguity 223 
substring 52 
subtraction processing 634 
subwin () , (high-level description) 777 suffix, 52 478 
subroutine 552 
suppress line directives, -1 (I.!'X) 826 
warning messages, occs/LLama (-w) 845 
-itch 646 
switch, coded with jump table 478 
statement 642 
used to execute actions 209 
SYMBOL 278 
symbol 486 
.args 488 
function arguments 554 
initializers 532 
. duplicate 486 
.etype 488 
. implicit 488 
.level 486 
.name 486 
.next 488 
.rname 486 
.type 488 
printing functions [symtab.c) 504 
symbol 
goal 338 
nonterminal (see nonterminal symbol) 
stack, in bottom-up parse 347 
terminal (see terminal symbol) 
symbolic constants 598 
symbol table 4 78 
block deletions 485 
characteristics 4 79 
code generator uses to communicate with 
scanner 529 
problems 536 
cross links 486 
database layer 4 79 
declarator manipulation functions [symtab.c] 
501 
dump, LLama 885 
oc:cs/LLama ( -s) 844 
handling duplicate symbols 481,483 
hashing 482 
implementation 485 
LLama 275 
data structures 278 
maintenance layer 4 79 
implementation 497 
memory-management functions [symtab.c] 
497 
modified by oc:cs for LALR(I) grammars 401 
dump oc:cs 867 
passing information to back end 563 
picture of an element 487 
shared between parser and lexical analyzer 33 
specifier manipulation functions [symtab.c) 
501 
stack based 480 
structures in 494 
print functions [symtab.c) 504 
tree-based 480 
type-manipulation functions [symtab.c) 502 
% synch directive, LLama 883 
synchronization, set 20 I 
tokens (LLama) 883 
syntax 166 
diagram 4, 13 
-directed translation 168, 183 
tree 4 
constructed by optimizer 667 
creating from postfix intermediate code 
668 
data structures to represent in optimizer 
669 
generating code from physical syntax tree 
670 
temporaries on 25 
vs. semantics 167 
synthesized attributes 187, 349 Index 
T 
-T, send large tables to yyouttab.c, oc:cs 844 
-t, send output to stdout, occs/LLama 844 
T () 566 
"To 574 
T token 166 
Tn 192 
table 
bottom-up parse, creating 357 
compression 140 
-<:, -f (I.!'X) 825 
decompression, oc:cs 393 
dispatch 646 
-driven parsers, and augmented grammars 202 
jump 647 
lookup, used to find the number of elements in 
a set 701 
size, limits, I.!'X 826 
minimizing I.!'X 827 
pair compressed 141 
parse (as generated by LLama) 210 
split up into two occs/LLama output files (-T) 
844 
top-down parse 208 
symbol 478 
tag, generated for %union union 863 
structure 543 
target, for true/false test 602 
template file, organization (I.!'X). 63 
temporary, anonymous (see temporary variable) 
temporary files for C-compiler code, data, and bss 
segments 512 
temporary variable 6, 184 
at run time 25 
on syntax tree 25 
simple management strategy 26 
allocation 577 
in C compiler 572 
create and initialize tmp gen ( ) 592 
creation, dynamic 573 -
management, defer to back end 572 
references: T ( ) 57 4 
represeted by value 588 
names are on value stack 350 
recycling 575 
stored in stack frame 574 
type 574 
term() 107 
%term 837, 856 
%term, definitiOilli generated by 229 
termcap database 774 
terminal 
edges, LR parse tables 356 
nodes 62 
symbols 7, 167 
how they get onto bottom-up parse stack 
344 
are leaf notes on parse tree 9 
terminate current lexeme: i i term() and ii unterm () 48 -
termlib.h 751,754 
termlib.lib 776 
%term, LLama 883 
TEST () 693, 698 
vs. MEMBER() 695 
test, bits in set 691 
constant expressions in 641 
directives, in C<ode 474 
text segment (see code segment) 
tf label() 602 
thompson o 1 10 
Thompson's construction 81 
NFA characteristics 83 
character classes in 85 
data structures 83 
implementation 83 
three-address instructions (see quads) 
Index 
threshold, argument to pairs() 142 
threshold, setting pair-compression 72 
time flies 171 
tmp alloc () 577 
tmp-create () 588 
tmp-gen () 592 
TNODE 416 
%token 837 
LLama 883 
occs 857 
token 3, 33 
function to output token definitions 321 
IDE, input a token 264 
names, legal occs/LLama 838 
C compiler 511 
defining under occs/LLama 837 
definitions generated by %tenn 229 
set, choosing 3 
multiple T" 192 
synchronization 201, 883 
-to-string conversion, Yy stok [] 392 
tokenization 17 -
tokenizer (see lexical analyzer) 
TOOHIGH () 686 
TOO LOW () 686 
top-down parsing 169, 195 
actions in 208 
attributes, LLama 883 
attribute notation ($N} 205 
attribute processing 203 
algorithm 205, 211 
code generation, using augmented grammar 
203 
error recovery 20 I 
generating parser for 208 
with PDA 201 
trace, of parse (log to file from IDE) 850 
trace, run-time (see run-time trace) 
transfonnations, occs grammatical 864, 867 
transition, diagram 56 
E 58 
transition matrix 60 
representations 65 
pair-compressed 68 
transitions 56 
in yyout.doc 869 
translation, syntax-directed (see syntax-directed 
translation) 
translation, switch to if/else 645 
traversal, depth-first 180 
traversal, set 708 
tree-based symbol tables 480 
tree, parse 4 
symbol-table deletions 480 
syntax (see syntax tree) 
triples 447 
compared to quads 448 
without explicit assignments 447 
TRUE, problems with 783 
truncate () 692 
Tspace 552 
TTYPE 124, 528 
two-address instructions (see tripples) 
two-dimensional arrays, printing 140 
%type 512 
type 524 
type chain, adding declarators 531 
type conversions 592 
implicit 620 
operators, C compiler 60 I 
in C-<:ode 473 
typedef, for %union 863 
processing in C compiler 528 
TYPE, has precedence 511 
type (field in symbol structure) 488 
%type 857, 861 
type 
manipulation, functions [symtab.c1 502 
enumerated 550 of temporary variable 574 
representations, example 489 
aggregate (represented by physical pointers at 
run time) 599 
derived 490 
in C-<:ode 450 
numeric coding of constrained 489 
representing, theory 489 
implementation 490 
unconstrained 489 
changing type of occs value stack 858 
type specifier 524 
type= or_ class ~type _specifier 525 
u 
unary operators 593 
minus (-), in C compiler 602 
pointer dereference operator, 606 
in grammar 181 
unary~NAME 594,613 
unboxed () 778 
unclosed-state list 417 
uncompressed tables, ITX 140 
uncompressed transition matrix (ITX) 65 
unconstrained types 489 
undeclared identi tiers 598 
underscores, used to avoid name conflicts in C-code 
467 
unfinished-states list 416 
ungetc (),inappropriate 
uninitialized data segment (see data segment) 
union (set operation), applied to languages 53 
UNION (set function) 692 
%union 860, 857 
example 862 
<field>, in yyout.sym 867 
handled by occs 406 
used for C compiler's value stack 509 
uni.on declarations 543 
union def () 290 
UNIX-<:ompatible newline, -u (ITX) 826 
UNIX, getting keyboard status (SIGIO) 246 
UNIX -speci fie code 683 
unlink, inC-code 471 
unput () 73, 821 
unreachable productions 219 
elimination 220 
unreachable states 140 
untenninate current Iexeme: ii _term() and 
ii unterm () 48 
untranslated input 40 
USE FAR HEAP 756 
useless cOde 662 
ux () 683 v 
-v, -V occs/LLama command-line switch 845 
v 771 
va arg () 725, 726 
va-end () 725 
VA-LIST 684 
va-list 725 
value: !value and rvalue 578 
implementation 583 
value structure 583 
.sym 584 
. type 584 
.etype 584 
. is tmp 583 
.lvalue 583 
. name 584, 599 
.offset 583 
for identi tier 599 
for temporary variable 588 
value stack 
top-down parser 203 
sample parse with 207 
sample top-down parse with 207 bottom-up parser 348 
change type of (occs) 858 
LLama 884 
maintained by bottom-up parser 352 
occs 858 
print under IDE 85 3 
print C compiler [yypstk () 1 514 
top-down parser 203 
%union used for C compiler's 509 
var dc/~new name 530 
var-dec/ 530-
variable allocation, in C-code 460 
variable 
declarations, in C-code 457 
C (simple) 522 
declarators (listings) 529 
definitions, nested 559 
names, in C-code 450 911 
annonymous temporary (see temporary vari­
able) 
dead 660 
handling automatic at run times 467 
local (see local variable) 
useful to occs/LLama 852 
temporary (see temporary variable) 
variable-argument mechanism, ANSI 724 
variable-length structures 716 
va start () 725 
va-start () 725 
VAX, assembly language forward references 552 
VB BLOCKCUR () 752 
VB-CURS I ZE ( ) , Change cursor size. (high-level 
description) 753 
vb get char(), Get character from keyboard. 
(high-level description) 753 
VB GETCUR ( ) , Get cursor position. (high-level 
description) 753 
VB GETPAGE (),Get video page number. (high­
level description) 753 
Vbios () 756 
vbios.h 756, 758 
vb is color (), Detennine display adapter. 
(high-level description) 753 
VB NORMALCUR () 752 
VB-SETCUR () , Move physical cursor. (high-level 
description) 753 
vector array, printing 733 
verbose mode, occs/LLama (-v, -V) 845, 826 
viable prefix 169, 343 
video-BIOS functions 752 
access function Vbios () 756 
definitions, vbios.h 756 
interface function (_vbios.c) 757 
macros 756 
that mimic direct-video functions 752 
select mode at run time 772 
video display pages 749 
VIDEO environment 772, 846 
video.h 756, 759 
video 1/0 
characters and attributes 749 
clear entire screen (direct video) dv_clrs.c 759 
clear region of screen (direct video) dv_clr_r.c 
759 
clear region of screen. (high-level description) 
750 
direct-video functions 749 
definitions (video.h) 759 
printf () dv_print.c 760 
variable allocation dv_scree.c 765 
free an SBUF (direct video) dv_frees.c 760 
free save buffi:r (video BIOS) vb_frees.c 768 
IBM/PC 746 
initializing [ini t () 1 772 
get character from keyboard (keyboard BIOS) 
vb_getch.c 768 
get Cursor Position (video BIOS) vb_getyx.c 
768 
implementation 753 
911 
initialize direct-video functions dv _init.c 760 
overview 749 
restore saved region (Direct Video) dv_resto.c 
764,769 
save region 764, 770 
scroll region of screen (Direct Video) 
dv _scrol.c 765 
test for color card (video BIOS) vb_iscol.c 768 
video-BIOS functions, macros (vbios.h) 758 
write character 769, 763 
with arbitrary attribute (Direct Video) 
dv_putc.c 761 
write string in 1TY mode (Video BIOS) 
vb_puts.c 769, 763 
video memory, base addresses, MONBASE, COLBASE 
756 
direct access to [dv Screen, SCREEN] 757 
virtual.h 449 -
virtual machine 446, 449, 451 
characteristics 44 7 
printing pm () 476 
virtual register set 454 
visible parser (see IDE) 
volatile, in optimization 664 
Vspace 552 
v struct 494 w 
-w, command-line switch to aces/LLama 845 
waddch () 782 
waddstr () 782 
wclear () 783 
wclrtoeol () 783 
we rase () 783 
wge1;ch () 781 
while 643 
whitespace, in C-code 450 
in ~X input file 816 
wild, call of the 468, 472 
wildcard 54 
winch() 782 
WINDOW 783 
window management, curses 774 
erase 783 
move 779 
balled 778 
window names under IDE 846 
winio.c 796 
wmove () 781 
word 450 
WORD 754, 755 
word 52, 166 
word size, computing 685 
worst-case alignment restriction [c-code.h] 462 
W(p) 463 
W(p+offset) 463 
*WP (p) 463 
WP (p) 463 
&WP (&Jl), used for )values 599 
wprintw () 782 
wrapok () 778 
wrefresh () 780 
write, string to window, waddstr.c 793 
wscroll () 783 
X 
x, curses column coordinate 777 
[x~. y, FIRST{!b C)] 363 
y 
y, curses row coordinate 777 
yy 839 
Yy 839 
yy 839 
YYABORT (in table E.2) 840 
Yyaccept [ 1 72 
YYACCEPT (in table E.2) 840 yy act() 388 
Yy-act ion 369 
YYACTION 876 
YyaN 369 
YYBADINP 80,823 
yybss () 855 
YYCASCADE 840,875 
Yy cmap[1 68 
yycode o 385, 855 
yycomment () 855 
Yy d[1 210 
YY-D, 63 
yydata () 855 
YYDEBUG 63,235,840 
yydebug, 63 
yydebug.c (see IDE) 
Yy dstack 235,394 
YYD (x) (in table E.2) 840 
yyerror () 250 
YYERROR () 73, 821 
yyerror (),Print parser error messages. (high­
level description) 854 
YYF 65,388 
yy get args () 246, 853 
-use directly 853 
yyhook a() 263, 514 
yyhook-b() 263,514 
yyin 824 (footnote) 
yy init debug() 246 
yy -init -lex() (~X. initialize) 822 
yy-init-llama() 855,884 
yy -init -aces() 853 
yy-Is SHIFT 388 
yylastaccept 80 
yyleng 15, 820 
yyless () 73, 822 
yylex () 74 
actions, 81 
called fromyy_nextoken () in IDE 264 
control-flow 7 4 
failure transitions 80 
Yy lhs 372 
yylineno (I!'X input line number) 820 
yylval 877 
YYMAXDEPTH (in table E.2) 840 
YYMAXERR 840, 875 
yymore () 73, 822 
problems with 79 
yymoreflg 78 
yy next () 140, 393 
yy-nextoken (),calls yylex () 264 
Yy-nxt[1 68 
yyout 73 
yyout.h, example 385, 838 
yyout.sym 867 
example 384 
yyp 388 
yyparse() 242,400,837,853 
YYPARSER 876 
yyprev 79 
YYPRIVATE 63, 840 
yyprompt () 855 
yypstk () 853 
example in C compiler 514 
LLama 885 
Yyyushtab 210 
yy recover () 400 
Yy-reduce 372,400 
Yy-rhslen 392, 876 
Yy-rmap[1 68 
Yy-sact 235 
yy-shift () 396 
YYSHIFTACT 840,877 
Yy slhs [ 1 392 
Yy::::snonterm, 235 
Yy srhs [ 1 392 
yyiiack.h 686, 690 
yystate 74 
Yy_stok, 235 Yy stok [ 1 392 
YYSTYPE (in table E.2) 840 
yystype 863 
yytext 15, 820 
phase problems 242 
YY TTYPE 278,388 
YY::::TYPE 65 
Yy val 876 In dell 
YERBOSE (in table E.2) 840 
Yy vsp 876 
yy~stype 205, 885 (see also, yystype) 
yywrap () 80, 823 
Cross Reference by Symbol 
All entries take the following form: 
symbol_name listing (line) file, page 
The page number is the page on which the listing starts, not the one on which the specified line is found. 
8086 A.l(l4) debug.h, 681 ALLOC CLS 6.22(7,9) symtab.h, 488 
Abort 4.8(102) yydebug.c, 243 alnum 0.5(12) c./ex, 829 
ACCEPT 2.39(31) dfa.h, 125 alnum 6.37(40) c./ex, 519 
access_ with() 6.85(460) op.c, 614 alnum 5.6(6) expr.lex, 384 
ACT 5.22(62) yystate.c, 413 alpha 5.6(5) expr.lex, 384 
ACT FILE 4.20( 100) parser.h, 277 AND 0.6( II) yyout.h, 832 
ACTION 4.18(2) 1/out.h, 276 and() 6.94(654) op.c, 626 
Actions 5.22(64) yystate.c, 413 AND AND 0.6(14) yyout.h, 832 
ACT TEMPL 4.20( 106) parser.h, 277 ANSI A.1(13) debug.h, 681 
Actual lineno 2.22(16) globals.h, 87 ARRAY 6.23(34) symtab.h, 491 
ADD() A.4(67) set.h, 696 ASSIGN A.4(41) set.h, 696 
add_ action () 5.23(113) yystate.c, 413 ASSIGN() A.4(46) set.h, 696 
add_case () 6.109(43) switch.c, 650 assignment () 6.90(571) op.c, 621 
addch () A.70(63) curses.h, 784 ASSIGNOP 0.6(50) yyout.h, 832 
add_declarator() 6.29(182) symtab.c, 501 Associativity 4.26(49) acts.c, 290 
add_default_case() 6.109(64) switch.c, 650 assort() A.35(3) assort.c, 743 
add_goto() 5.23(157) yystate.c, 413 Attrib A.83(25) wincreat.c, 794 
add _lookahead ( ) 5.29(928) yystate.c, 425 Attr_pix 4.8(138) yydebug.c, 243 
addreductions () 5.30(958) yystate.c, 431 attr_str () 6.32(393) symtab.c, 504 
addr_of () 6.83(270) op.c, 606 A TYPE 6.27(173) symtab.h, 497 
_addset () A.6(80) set.c, 702 A TYPE 2.48(21) pairs.c, 143 
add_spec_to_decl() 6.45(102) decl.c, 537 A TYPE 2.47(8) print_ar.c, 142 
addstr () A.70(66) curses.h, 784 AUTO 6.24(50) symtab.h, 492 
addsym() A.l6(59) hash.c, 718 AUTOSELECT A.68(12) glue.c, 772 
add_symbols_to_table() 6.48(154) decl.c, 539 Available 5.24(197) yystate.c, 416 
add_synch () 4.26(628) acts.c, 290 B 6.9(46) virtual.h, 465 
add_ synch () 4.26(690) acts.c, 290 BGND () A.42(15) termlib.h, 754 
add_to_dstates() 2.41(119) dfa.c, 129 binary_ op ( ) 6.99(762) op.c, 630 
add to rhs () 4.26(488) acts.c, 290 bin_to_ascii () A.27(5) bintoasc.c, 731 
add=unfinished() 5.25(267) yystate.c, 418 BIT() 6.19(80) virtual.h, 475 
ADJ_VAL() 4.20(74) parser.h, 277 BITS IN WORD - --A.4( 4) set.h, 696 
advance() 1.3(87) lex.c, 17 BLACK A.42(5) termlib.h, 754 
advance() 4.25(38) 1/par.c, 285 BLINKING A.42(21) termlib.h, 754 
advance() 2.28(392) nfa.c, 97 BLUE A.42(6) termlib.h, 754 
ALIGN() 6. 7( 44) virtual.h, 462 body() 4.25(124) 1/par.c, 285 
ALIGN WORST 6.8(11) c-code.h, 462 BOLD A.42(22) termlib.h, 754 
ALLOC 6.33( 10) c.y, 509 bool A.70(19) curses.h, 784 
ALLOC A.58(1) dv_scree.c, 765 BOT A.71(49) box.h, 787 
ALLOCATE 2.52( 10) lex.c, 155 BOTH 2.20(27) nfa.h, 85 
ALLOCATE 2.38(147) terp.c, 120 box() A.73(3) box.c, 788 
913 
914 
Box 
boxwin () 
BP 
BREAK 
breakpoint () 
BRKLEN 
BROWN 
BSIZE 
Bss 
BUCKET 
Buf 
BUFSIZE 
BYTE HIGH BIT 
BYTE PREFIX 
BYTEPTR PREFIX 
_bytes 
_BYTES_IN_ARRAY() 
BYTE WIDTH 
call() 
CASE 
Case label 
CASE MAX 
case val 
cat_expr () 
CCL 
CELL 
CEN 
CHAR 
CHARACTER 
CHAR ATTRIB 
Char avail 
CHUNK 
c_identifier() 
CLASS 
CLASS 
CLASS 
CLASS 
CLASS 
clean up() 
clear() 
CLEAR() 
CLEAR_ STACK () 
clone_ type() 
CLOSED 
Closep 
closure() 
clr_col () 
clr reglon () 
clr_row() 
clrtoeol () 
cmd_line_error () 
cmd_list () 
cmp () 
cmp () 
c name 
cnext () 
Code 
CODE BLOCK 
code_ header() 
code_ header () 
Code window 
Col 
COLBASE 
col_cpy () 
col_equiv () 
Col_map 
COLON 
COLON 
Column_compress 
COM A.83(24) wincreat.c, 794 
4.9(287) yydebug.c, 247 
6.9(50) virtual.h, 465 
0.6(33) yyout.h, 832 
4.15(1187) yydebug .c, 264 
4.8(86) yydebug.c, 243 
A.42( II) termlib.h, 754 
2.38(150) terp.c, 120 
6.34(1246) c.y, 512 
A.12(6)hash.h, 716 
2.38(152) terp.c, 120 
2.2(28) input.c, 39 
6.2(6) c-code.h, 452 
6.10(12) c-code.h, 465 
6.10(16) c-code.h, 465 
6.4( 19) virtua/.h, 454 
A.4(5) set.h, 696 
6.2(1) c-code.h, 452 
6.87(483) op.c, 616 
0.6(39) yyout.h, 832 
6.108(176) c.y, 649 
6.1 07( I) switch.h, 648 
6.1 07(7) switch.h, 648 
2.30(643) nfa.c, 104 
2.20(20) nfa.h, 85 
6.64( 18) temp.c, 575 
A.71(53) box.h, 787 
6.24(43) symtab.h, 492 
A.46( II) video.h, 759 
A.46(23) video.h, 759 
4.8(149) yydebug.c, 243 
5.23(71) yystate.c, 413 
4.26(365) acts.c, 290 
2.22(3) globals.h, 87 
4.23( 170) parser.h, 281 
4.23(173) parser.h, 281 
6.4(12,15) virtual.h, 454 
0.6(26) yyout.h, 832 
6.34(1323) c.y, 512 
A.70(75) curses.h, 784 
A.4( 48) set.h, 696 
2.25(94) nfa.c, 91 
6.31(226) symtab.c, 502 
5.24(208) yystate.c, 416 
2.2(63) input.c, 39 
5.29(788) yystate.c, 425 
A.59(57) dv _scro/.c, 765 
A.68(120) g/ue.c, 772 
A.59(40) dv _scrol.c, 765 
A.70(69) curses.h, 784 
2.52(43) /ex.c, 155 
4.12(1084) yydebug.c, 260 
0.5(131) c./ex, 829 
6.37(178) c./ex, 519 
4.17(40) parser./ex, 271 
2.49(298) squash.c, 147 
6.34(1247) c.y, 512 
4.18(3) /lout.h, 276 
4.31( 49) 1/driver.c, 319 
5.18(57) yydriver.c, 409 
4.8(118) yydebug.c, 243 
A.52(5) dv yutc.c, 761 
A.46(2) video.h, 759 
2.49(94) squash.c, 147 
2.49(78) squash.c, 147 
2.49(23) squash.c, 147 
4.18(4) 1/out.h, 276 
0.6(13) yyout.h, 832 
2.52(30) /ex.c, 155 
6.24(59) symtab.h, 492 COMMA 
comment() 
Comment buf 
Comment window 
common 
COMPLEMENT () 
concat () 
CONSTANT 
CONST_STR() 
const val 
CONTINUE 
conv() 
convert_ type () 
conv_sym_to_lnt_const() 
COPY() 
copyfile () 
cpy_col () 
cpy_row () 
create_static locals() 
CREATING LLAMA PARSER 
CREATING LLAMA PARSER 
Crmode 
CSIZE 
CTYPE 
Cur act 
Cur nonterm 
Current tok 
CUR SIZE 
CUR SYM 
Cur term 
CYAN 
D() 
d 
d 
DANGER 
Data 
D BOT 
D CEN 
DCL TYPE 
Debug 
DECLARATOR 
declarator 
DEFAULT 
DEFBITS 
DEF EXT 
DEF EXT 
DEF FIELD 
definitions() 
defnext () 
DEFSTACK 
DEFWORDS 
delay() 
Delay 
delset () 
delsym () 
delwin () 
Depth 
dfa () 
dfa 
DFA MAX 
DFA STATE 
D HORIZ 
Did_something 
Did_something 
die a horrible_death() 
DIFFERENCE 
DIFFERENCE () 
digit 
discard() 
discard_link () Cross Reference by Symbol 
0.6(47) yyout.h, 832 
A.32(14) printv.c, 734 
6.63(77) gen.c, 567 
4.8(119) yydebug.c, 243 
6.6(41) virtual.h, 461 
A.4(50) set.h, 696 
A.39(5) concat.c, 746 
6.24(52) symtab.h, 492 
6.67(22) va/ue.h, 584 
6.24(83) symtab.h, 492 
0.6(34) yyout.h, 832 
4.8(175) yydebug.c, 243 
6.69(265) value.c, 588 
6.55(506) decl.c, 551 
2.2(16,18) input.c, 39 
A.36(15) copyfile.c, 743 
A.59(21) dv scro/.c, 765 
A.59(3) dv scro[.c, 765 
6.62(84) local.c, 560 
4.17(8) parser.lex, 271 
4.24(7) parser.lma, 283 
A.84(13) winio.c, 796 
6.27(160) symtab.h, 497 
6.27(161) symtab.h, 497 
4.23(220) parser.h, 281 
4.23(219) parser. h. 281 
2.28(374) nfa.c, 97 
A.43(7) vbios.h, 756 
4.26(77) acts.c, 290 
4.23(218) parser.h, 281 
A.42(8) termlib.h, 754 
A.l(3,6) debug.h, 681 
0.5(15) c./ex, 829 
6.37(43) c./ex, 519 
2.2(30) input.c, 39 
6.34(1248) c.y, 512 
A.71 (60) box.h, 787 
A.71(64) box.h, 787 
6.25( 115) symtab.h, 493 
4.23( 178) parser. h. 281 
6.25(85) symtab.h, 493 
6.23(41) symtab.h, 491 
0.6(38) yyout.h, 832 
A.4(9) set.h, 696 
4.20( 104) parser.h, 277 
4.20(94) parser.h, 277 
4.23( 166) parser.h, 281 
4.25(85) 1/par.c, 285 
2.46(5) defnext.c, 141 
4.8(60) yydebug.c, 243 
A.4(8) set.h, 696 
4.12(910) yydebug.c, 260 
4.8(126) yydebug.c, 243 
A.5(33) set.c, 699 
A.l7(81) hash.c, 719 
A.74(3) delwin.c, 790 
4.8(110) yydebug.c, 243 
2.40(53) dfa.c, 127 
2.40(50) dfa.c, 127 
2.39(7) dfa.h, 125 
2.40(31) dfa.c, 127 
A.71(63) box.h, 787 
4.27(17) first.c, 305 
4.28(22) fo/low.c, 307 
4.9(263) yydebug.c, 247 
A.4(40) set.h, 696 
A.4(45) set.h, 696 
5.6(4) expr.lex, 384 
2.25(131) nfa.c, 91 
6.28( 139) symtab.c, 497 
Cross Reference by Symbol 915 
discard_link_chain() 6.28(116) symtab.c, 497 dv _ scroll_line () A.S9(78) dv _scrol.c, 76S 
discard_structdef() 6.28(167) symtab.c, 497 E() 2.S2(28) lex.c, ISS 
discard_syrnbol() 6.28(4S) symtab.c, 497 e() S.7(4) yyout.sym, 384 
discard_syrnbol_chain() 6.28(70) symtab.c, 497 e() E. II (S) yyout.sym, 868 
discard_ value () 6.68(46) value.c, S8S ECHO 2.19(148) lex.par, 7S 
DISPLAY A.46(13) video.h, 7S9 echo() A.84(16) winio.c, 796 
display_ file () 4.10(SS8) yydebug.c, 2Sl Echo A.84(12) winio.c, 796 
DIVOP 0.6(18) yyout.h, 832 e_closure () 2.36(47) terp.c, 118 
_DIV_WSIZE() A.4(6) set.h, 696 ELSE 0.6(31) yyout.h, 832 
D LEFT A.71(62) box.h, 787 eMark 2.2(43) input.c, 39 
D LL A.7l(S9) box.h, 787 EMPTY 2.20(21) nfa.h, 8S 
D LR A.71(6S) box.h, 787 enable_trace () 6.63(100) gen.c, S67 
DO 0.6(36) yyout.h, 832 END 2.2(33) input.c, 39 
do_binary_const() 6.99(816) op.c, 630 END 2.20(26) nfa.h, 8S 
DOC FILE 4.20( 103) parser.h, 277 End buf 2.2(40) input.c, 39 
DOC FILE 4.20(93) parser.h, 277 END OPT 4.18(S) l/out.h, 276 
Doc file 4.33(33) main.c, 322 end_opt () 4.26(S96) acts.c, 290 
do_close () S.29(82S) yystate.c, 42S ENDP() 6.12(S6) virtual.h, 467 
document() 4.34(393) main.c, 328 endwin () A.76(S) initscr.c, 791 
document_ to () 4.34(409) main.c, 328 enlarge() A.6(9S) set.c, 702 
dodash () 2.32(811) nfa.c, 108 ENTER() 2.23(22) nfa.c, 89 
do_ dollar () 4.3S(7) lldollar.c, 332 ENTER() 2.23(27) nfa.c, 89 
do_ dollar () S.l6(7) yydollar.c, 407 ENTRY A.l0(13) nul, 710 
do_enum() 6.SS(493) decl.c, SSI ENTRY A.ll(S) nul, 714 
do_ file() 2.S2(177) lex.c, ISS Enum val 6.S4(123) c.y, sso 
do_file() 4.33(272) main.c, 322 Eof read 2.2(SS) input.c, 39 
DOLLAR DOLLAR 4.20(83) parser. h. 277 EOI 1.1 (I) lex.h, IS 
do_name() 6.72(27) op.c, S9S EOI 4.18(1) l/out.h, 276 
dopatch () S.IS(90) yypatch.c, 402 EOI 4.2(1) l/out.h, 229 
DOS() A.77(17,20) mvwin.c, 791 EOI 0.6(3) yyout.h, 832 
do_struct() 6.8S(377) op.c, 614 EPSILON 2.20( 19) nfa.h, 8S 
do_unop () 6.79(177) op.c, 604 EPSILON 4.20(6S) parser. h. 277 
D RIGHT A.7l(S7) box.h, 787 EQ() 6.19(68) virtual.h, 47S 
driver() 4.31(71) lldriver.c, 319 EQUAL 0.6(49) yyout.h, 832 
driver() S .18( 68) yydriver.c, 409 EQUOP 0.6( 17) yyout.h, 832 
driver_l () A.41(18) driver.c, 748 erase A.70(72) curses.h, 784 
driver_2 () A.41(39) driver.c, 748 ERR A.70(23) curses.h, 784 
Driver file 4.31(19) 1/driver.c, 319 Err code A.86(3) wprintw.c, 800 
Driver file S.l8(19) yydriver.c, 409 ERR DST OPEN A.36( 10) copyfile.c, 743 
D SCLASS 2.48(26) pairs.c, 143 Errmsgs 2.24(S3) nfa.c, 90 
Dstack 4.8(106) yydebug.c, 243 ERR NONE A.36(9) copyfile.c, 743 
Dstates 2.40(33) dfa.c, 127 ERR NUM 2.24(SI) nfa.c, 90 
dst_opt () 6.99(931) op.c, 630 error() 4.34(470) main.c, 328 
D TOP A.71(61) box.h, 787 ERR READ A.36(12) copyfile.c, 743 
DTRAN 4.30(42) 1/code.c, 311 ERR SRC OPEN A.36(11) copyfile .c, 7 43 
Dtran 2.40(36) dfa.c, 127 ERR WRITE A.36(13) copyfile.c, 743 
Dtran 4.30(61) 1/code.c, 311 ESC 4.8(73) yydebug.c, 243 
DTRAN NAME 2.S2(24) lex.c, ISS esc() A.26(34) esc.c, 728 
D UL A.71(66) box.h, 787 EXIT ILLEGAL ARG 4.19(20) parser.h, 276 
dupset () A.S(4S) set.c, 699 EXIT NO DRIVER 4.19(22) parser.h, 276 
D UR A.7l(S8) box.h, 787 EXIT OTHER 4.19(23) parser.h, 276 
Dv A.68(6S) glue.c, 772 EXIT TOO MANY 4.19(21) parser.h, 276 
dv _ clr _region () A.47(3) dv _clr _r.c, 7S9 EXIT USR ABRT 4.19(24) parser.h, 276 
dv_clrs () A.48(3) dv _clrs.c, 7S9 expand_ macro () 2.26(264) nfa.c, 93 
dv_ctoyx () A.S2(68) dvyutc.c, 761 expr() 3.4(19) naive.c, 188 
D VERT A.7l(S6) box.h, 787 expr() 2.30(S92) nfa.c, 104 
dv _ freesbuf () A.49(S) dv Jrees.c, 760 Expr 2.38(1S4) terp.c, 120 
dv_getyx() A.S2(77) dv _yutc.c, 761 expression () 1.10(29) args.c, 29 
dv_incha () A.S2(86) dv _yutc.c, 761 expression () 1.6(2S) improved.c, 21 
dv_init () A.S0(3) dv _init.c, 760 expression () l.S(23) plain.c, 18 
dv _ outcha () A.S2(91)dv_yutc.c, 761 expression () 1.9(30) retval.c, 27 
dv _print f () A.Sl(6) dv _yrint.c, 760 expr_prime () 3.4(26) naive.c, 188 
dv_putc () A.S2(14) dv_yutc.c, 761 expr_prime () l.S(31) plain.c, 18 
dv _put char () A.S3(4) dv _yutch.c, 763 EXT 6.24(S8) symtab.h, 492 
dv_puts () A.S4(4) dv _yuts.c, 763 EXTERN 6.2S( Ill) symtab.h, 493 
dv_putsa () A.SS(3) dv _yutsa.c, 763 external 6.6(43) virtual.h, 461 
dv _replace () A.S2(96) dv _yutc.c, 761 ext_high () 6.18(66) virtual.h, 474 
dv _restore () A.S6(S) dv _resto.c, 764 ext_low () 6.18(6S) virtual.h, 474 
dv_save () A.S7(6) dv _save.c, 764 ext_word () 6.18(67) virtual.h, 474 
dv_scroll() A.S9(12S) dv _scrol.c, 76S F 2.39(18) dfa.h, 12S 
916 Cross Reference by Symbol 
factor() 1.10(67) args.c, 29 getline () 2.38(177) terp.c, 120 
factor() 1.6(55) improved.c, 21 getnarne () 5.5(18) expr.y, 382 
factor() 3.4(69) naive.c, 188 get _prefix() 6.69(181) value .c, 588 
factor() 2.31(701) nfa.c, 108 get size() 6.69(304) value .c. 588 
factor() 1.5(67) plain.c, 18 get::::sizeof () 6.31(302) symtab.c, 502 
factor() 1.9(66) retval.c, 27 get_suffix () 6.69(331) value.c, 588 
FALSE A.70(22) curses.h, 784 get_unfinished() 5.25(307) yystate.c, 418 
FATAL 4.20(80) parser.h, 277 get_ unmarked () 2.41(157) dfa.c, 129 
FCON 2.12(1) /exyy.c, 64 GET VMODE A.43(15) vbios.h, 756 
FCON 2.11 (2) numbers.lex, 63 getyx () A.70(30) curses.h, 784 
FCON 0.6(7) yyout.h, 832 Goal_symbol 4.23(214) parser.h, 281 
ferr() A.28(13)ferr.c, 732 Goal_symbol_ is next 4.26(58) acts.c, 290 -FGND () A.42(14) termlib.h, 754 GOTO 0.6(29) yyout.h, 832 
FIELD 4.18(6) 1/out.h, 276 GOTO 5.22(63) yystate.c, 413 
Field name 4.26(53) acts.c, 290 Gotos 5.22(68) yystate.c, 413 
fields active() 4.26(786) acts.c, 290 GREEN A.42(7) termlib.h, 754 
fields-active 4.26(43) acts.c, 290 ground() A.70(48) curses.h, 784 
Fields active 4.26(54) acts.c, 290 Groups 2.43(16) minimize.c, 136 
figure::::local_offsets() 6.62(45) /oca/.c, 560 GT () 6.19(72) virtua/.h, 475 
figure_osclass() 6.48(212) dec/.c, 539 h 0.5(13) c./ex, 829 
figure_pararn_offsets() 6.60(591) dec/.c, 557 h 6.37(41) c./ex, 519 
figure_struct_offsets() 6.52(427) dec/.c, 548 hash_add() A.22(8) hashadd.c, 723 
file_header () 4.31(27) 1/driver.c, 319 hash_ funct () 4.26(303) acts .c, 290 
file_header () 5.18(30) yydriver.c, 409 hash_pjw() 6.21(1) hashpjw.c, 484 
File name A.41(14) driver.c, 748 hash_pjw() A.23(9) hashpjw.c, 724 
FILL() A.4(49) set.h, 696 HASH TAB A.14(15) hash.h, 717 
fill row() 4.30(1 0 I) I/ code .c, 311 HD BOT A.71(71) box.h, 787 
find::::field() 6.85(440) op.c, 614 HD CEN A.71(75) box.h, 787 
find _problems() 4.26(278) acts.c, 290 HD HORIZ A.71(74) box.h, 787 
find_select_set() 4.29(23) 1/se/ect.c, 310 HD LEFT A.71(73) box.h, 787 
findsym() A.l8(101) hash.c, 720 HD LL A.71(70) box.h, 787 
first() 4.27(21) first.c, 305 HD LR A.71(76) box.h, 787 
first closure () 4.27(37) first.c, 305 HD RIGHT A.71(68) box.h, 787 
first-in cat() 2.30(681) nfa.c, 104 HD TOP A.71(72) box.h, 787 
first::::rh; () 4.27(97) first.c, 305 HD UL A.71(77) box.h, 787 
first_sym() 4.26(380) acts .c, 290 HD UR A.71(69) box.h, 787 
fix_cur () A.52(10) dvyutc.c, 761 HD VERT A.71(67) box.h, 787 
fix _dtran () 2.44(177) minimize.c, 137 head() 2.52(269) /ex.c, !55 
FIXED 6.24(48) symtab.h, 492 Header_only 2.52(34) /ex.c, !55 
fix_types_and_discard_ syms () 6.60(528) dec/.c, 557 Heap 5.24(194) yystate.c, 416 
follow() 4.28(26)/ol/ow.c, 307 hex2bin () A.26(14) esc.c, 728 
follow_closure() 4.28( 127) follow.c, 307 hidewin () A.75(3) hidewin.c, 790 
FOR 0.6(37) yyout.h, 832 HIGH BITS A.23(7) hashpjw.c, 724 
fp 6.4(37) virtual.h, 454 High_water_mark 6.64(21) temp.c, 575 
fputstr () A.30(8)fputstr.c, 733 HORIZ A.71(52) box.h, 787 
freeitem () 5.27(421) yystate.c, 422 Horiz_stack_pix 4.8(134) yydebug.c, 243 
freename () 5.5(17) expr.y, 382 I() 2.22(4) globals.h, 87 
free_name () E.l7(72) expr.y, 879 I() 2.22(7) g/obals.h, 87 
freename () 1.8(15) name.c, 26 I() 4.23( 171) parser.h, 281 
free_name () 5.1(27) support.c, 353 I() 4.23(174) parser.h, 281 
free nfa () 2.35(43) terp.c, 116 I() 6.4(11) virtua/.h, 454 
free::::recycled_items() 5.27(429) yystate.c, 422 I() 6.4(14) virtua/.h, 454 
free_sets () 2.41(188) dfa.c, 129 IBM_BOX() A.71(38) box.h, 787 
freesym () A.13(27) hash.c, 716 IBM_BOX() A.71(41) box.h, 787 
FUNCTION 6.23(35) symtab.h, 491 !_breakpoint 4.8(9l)yydebug.c, 243 
Funct name 6.57(137) c.y, 555 ICON 2.12(2) lexyy.c, 64 
GBIT() A.4(64) set.h, 696 ICON 2.11 (3) numbers./ex, 63 
GE () 6.19(73) virtua/.h, 475 ICON 0.6(6) yyout.h, 832 
gen () 6.63(113) gen.c, 567 id _or_ keyword () 0.5(137) c./ex, 829 
gen _comment () 6.63(81) gen.c, 567 id _or_ keyword () 6.37(184) c./ex, 519 
generate() 5.1(7) support.c, 353 IF 0.6(30) yyout.h, 832 
_ args () 6.48(249) dec/.c, 539 generate_defs_and free !file 2.22(21) globals.h, 87 
gen_false_true() 6.79(206) op.c, 604 I FREE A.42(34) termlib.h, 754 
gen_rvalue() 6.92(638) op.c, 623 I FREE A.42(38) termlib.h, 754 
gen_stab_and_free_table() 6.109(78) switch.c, 650 Ifunct 2.28(371) nfa.c, 97 
get_ alignment () 6.52(470) decl.c, 548 Ignore 4.17(27) parser.lex, 271 
getbuf () A.84(33) winio.c, 796 ii _advance () 2.5(168) input.c, 44 
getch () A.70(78) curses.h, 784 ii_fillbuf() 2.6(278) input.c, 45 
get_expr () 2.27(8) input.c, 96 ii_flush() 2.6(204) input.c, 45 
getline () 2.27(59) input.c, 96 ii_flushbuf () 2.9(425) input.c, 48 
Cross Reference by Symbol 
ii_input () 
ii_io () 
ii_look () 
ii _lookahead () 
ii_mark_end() 
ii mark prev () 
i(::move::::start () 
ii _ newfile () 
ii _pushback () 
ii _term() 
ii_text () 
ii to mark() 
ii:::: unput () 
ii _ unterm () 
illegal_struct_def() 
IMALLOC 
IMALLOC 
INBOUNDS () 
inch() 
in closure items() 
INCOP 
incop() 
indirect() 
in_ dstates () 
In group 
init () 
init () 
ini t () 
init_acts() 
init_groups () 
init_output_streams() 
initscr () 
Inp_file 
Inp fm file 
input<) 
Input 
Input_buf 
input_char() 
Input_file 
Input_file_name 
Input_file_name 
Input_line 
INT 
Interactive 
internal_ cmp () 
INTERSECT 
INTERSECT () 
INVERT() 
invert() 
IO TOP 
IO WINSIZE 
IS() 
ISACT () 
IS_AGGREGATE () 
IS_ARRAY() 
IS_CHAR() 
IS_CONSTANT () 
IS_ DECLARATOR () 
IS_DISJOINT () 
IS_EMPTY() 
IS_EQUIVALENT () 
IS_FUNCT () 
ISHEXDIGIT () 
IS_INT() 
IS_INT_CONSTANT() 
IS_INTERSECTING() 
I SIZE 
IS_LABEL() 
IS_LONG() 
I SNONTERM () 2.9(377) input.c, 48 
2.3(65) input.c, 41 
2.7(322) input.c, 47 
2.9(418) input.c, 48 
2.4(134) input.c, 43 
2.4(154) input.c, 43 
2.4(140) input.c, 43 
2.3(81) input.c, 41 
2.8(337) input.c, 48 
2.9(358) input.c, 48 
2.4(120) input.c, 43 
2.4(148) input.c, 43 
2.9(400) input.c, 48 
2.9(366) input.c, 48 
6.52(401) decl.c, 548 
A.42(33) termlib.h, 754 
A.42(37) termlib.h, 754 
A.l(62) debug.h, 681 
A.70(91) curses.h, 784 
5.29(911) yystate.c, 425 
0.6(22) yyout.h, 832 
6.81 (233) op.c, 605 
6.84(294) op.c, 606 
2.41(139) dfa.c, 129 
2.43(18) minimize.c, 136 
4.28(61 )fol/ow.c, 307 
A.68(18) glue.c, 772 
A.68(67) g/ue.c, 772 
4.26(312) acts.c, 290 
2.44(52) minimize.c, 137 
6.34(1251) c.y, 512 
A.76(10) initscr.c, 791 
2.2(48) input.c, 39 
4.8(129) yydebug.c, 243 
2.19(162) /ex.par, 75 
2.28(372) nfa.c, 97 
2.22(19) globals.h, 87 
4.16(1368) yydebug.c, 267 
A.41(12) driver.c, 748 
2.22(20) globals.h, 87 
4.23(179) parser.h, 281 
A.41(13) driver.c, 748 
6.24(42) symtab.h, 492 
4.8(124) yydebug.c, 243 
A.19(218) hash.c, 721 
A.4(39) set.h, 696 
A.4(44) set.h, 696 
A.4(51) set.h, 696 
A.8(365) set.c, 706 
4.8(64) yydebug.c, 243 
4.8(65) yydebug.c, 243 
A.l (64) debug.h, 681 
4.20(57) parser.h, 277 
6.25(145) symtab.h, 493 
6.25(131) symtab.h, 493 
6.25(137) symtab.h, 493 
6.25(148) symtab.h, 493 
6.25(130) symtab.h, 493 
A.4(57) set.h, 696 
A.4(60) set.h, 696 
A.4(59) set.h, 696 
6.25(133) symtab.h, 493 
A.26(11) esc.c, 728 
6.25(138) symtab.h, 493 
6.25(150) symtab.h, 493 
A.4(58) set.h, 696 
6.27(163) symtab.h, 497 
6.25(135) symtab.h, 493 
6.25(140) symtab.h, 493 
4.20(56) parser.h, 277 ISOCTDIGIT () 
IS _POINTER() 
IS_PTR_TYPE () 
IS_ SPECIFIER () 
IS_ STRUCT () 
IS TERM() 
IS_TYPEDEF () 
IS _UINT () 
IS_ULONG() 
IS_UNSIGNED () 
ITEM 
item_cmp () 
I TYPE 
kbhit () 
KB INT 
kbready () 
kclosure() 
KWORD 
KWORD 
L 
LABEL 
LABEL MAX 
LARGEST INT 
LASTELE () 
Last marked 
Last real nonterm 
LB 
L BODY 
L_breakpoint 
LC 
LCHUNK 
L COND END 
L COND FALSE 
L DOEXIT 
L DOTEST 
L DOTOP 
LE () 
LEAVE() 
LEAVE() 
LEFT 
LEFT 
LEFT 
legal_lookahead() 
L ELSE 
L END 
lerror () 
lerror () 
lex() 
Lex erne 
L FALSE 
LIKE UNIX 
L INCREMENT 
Lineno 
Lineno 
link() 
link 
Link free 
LL 
LL () 
LL () 
LL () 
L LINK 
L NEXT 
loc_auto create() 
loc_reset () 
loc_static_create() 
loc _ var _space () 
Log 
LONG 
Lookahead 917 
A.26(12) esc.c, 728 
6.25(132) symtab.h, 493 
6.25(146) symtab.h, 493 
6.25(129) symtab.h, 493 
6.25(134) symtab.h, 493 
4.20(55) parser.h, 277 
6.25(149) symtab.h, 493 
6.25(139) symtab.h, 493 
6.25(141) symtab.h, 493 
6.25(142) symtab.h, 493 
5.20(33) yystate.c, 411 
5.27(452) yystate.c, 422 
6.27(164) symtab.h, 497 
4.8(150) yydebug.c, 243 
A.43(6) vbios.h, 756 
4.9(257) yydebug.c, 247 
5.29(745) yystate.c, 425 
6.37(143) c./ex, 519 
0.5(97) c./ex, 829 
6.9(47) virtual.h, 465 
6.24(46) symtab.h, 492 
6.22(13) symtab.h, 488 
2.35(19) terp.c, 116 
A.l(59) debug.h, 681 
2.40(38) dfa.c, 127 
5.15(22) yypatch.c, 402 
0.6(45) yyout.h, 832 
6.59(6) label.h, 557 
4.8(89) yydebug.c, 243 
0.6(43) yyout.h, 832 
6.28(19) symtab.c, 497 
6.59(7) label.h, 557 
6.59(8) /abe/.h, 557 
6.59(9) label.h, 557 
6.59(10) label.h, 557 
6.59(11) /abe/.h, 557 
6.19(71) virtua/.h, 475 
2.23(24) nfa.c, 89 
2.23(28) nfa.c, 89 
A.71(51) box.h, 787 
4.18(7) 1/out.h, 276 
6.67(19) value.h, 584 
1.7(80) improved.c, 23 
6.59(12) /abel.h, 557 
6.59(13) label.h, 557 
2.52(89) /ex.c, 155 
4.34(429) main.c, 328 
1.2(9) /ex.c, 15 
2.28(375) nfa.c, 97 
6.59(14) labe/.h, 557 
A.77(13) mvwin.c, 791 
6.59(15) label.h, 557 
2.22( 17) globals.h, 87 
2.2(49) input.c, 39 
6.16(61) virtual.h, 472 
6.25(101) symtab.h, 493 
6.28(16) symtab.c, 497 
A.71(48) box.h, 787 
4.19( I 0) parser.h, 276 
4.19(7) parser.h, 276 
4.26(441) acts.c, 290 
6.59(16) /abe/.h, 557 
6.59(17) /abe/.h, 557 
6.62(57) /ocal.c, 560 
6.62(24) /oca/.c, 560 
6.62(96) /oca/.c, 560 
6.62(33) /oca/.c, 560 
4.8(130) yydebug.c, 243 
6.25(109) symtab.h, 493 
1.3(74) lex.c, 17 
918 Cross Reference by Symbol 
Lookahead 4.25(30) 1/par.c, 285 MARK 6.64(16) temp.c, 575 
lookfor () 4.25(47) 1/par.c, 285 match() 4.25(36) 1/par.c, 285 
LP 1.1(5) lex.h, 15 MATCH() 2.28(377) nfa.c, 97 
LP 4.2(5) 1/out.h, 229 match() 1.3(76) lex.c, 17 
LP 6.9(51) virtual.h, 465 max() A.l(74) debug.h, 681 
LP 0.6(41) yyout.h, 832 MAX CHARS 2.39(19) dfa.h, 125 
LR A.71(54) box.h, 787 MAX CLOSE 5.21(37) yystate.c, 412 
lr () 5.29(547) yystate.c, 425 MAXEPSILON 5.21(39) yystate.c, 412 
lr_conflicts () 5.31(1073) yystate.c, 433 MAXFIRST 1.7(77) improved.c, 23 
L RET 6.59(18) label.h, 551 MAXINP 2.22(9) globals.h, 87 
lrs () 6.17(64) virtual.h, 473 MAXI NT A.1(71) debug.h, 681 
lr_stats () 5.31(1053) yystate.c, 433 MAXKERNEL 5.21(36) yystate.c, 412 
LSIZE 6.27(166) symtab.h, 497 MAX LEX 2.2(26) input.c, 39 
L STRING 6.59(19) label.h, 551 MAX LOOK 2.2(25) input.c, 39 
L SWITCH 6.59(20) label.h, 551 MAXNAME 4.20(25) parser.h, 277 
LT() 6.19(70) virtual.h, 475 MAXNONTERM 4.20(42) parser.h, 277 
Ltab 6.63(26) gen.c, 567 MAXOBUF 5.20(21) yystate.c, 411 
L TEST 6.59(21) label.h, 551 MAXPROD 4.20(26) parser.h, 277 
L TRUE 6.59(22) label.h, 551 MAXRHS 4.22(141) parser.h, 279 
LTYPE 6.27(167) symtab.h, 497 MAXSTATE 5.20(20) yystate.c, 411 
L VAR 6.59(23) label.h, 551 MAX TERM 4.20( 41) parser.h, 277 
LWORD HIGH BIT 6.2(8) c-code.h, 452 MAX TOK PER LINE 5.32(1084) yystate.c, 434 
LWORD PREFIX 6.10(14) c-code.h, 465 MAX UNFINISHED 5.24(185) yystate.c, 416 
LWORDPTR PREFIX 6.10(18) c-code.h, 465 MEMBER() A.4(68) set.h, 696 
LWORD WIDTH 6.2(3) c-code.h, 452 memiset () A.38(4) memiset.c, 745 
machine() 2.29(508) nfa.c, 102 merge lookaheads() 5.29(667) yystate.c, 425 
MAC NAME MAX 2.26(188) nfa.c, 93 min()- A.l(77) debug.h, 681 
MACRO 2.26(196) nfa.c, 93 MINACT 4.20(30) parser.h, 277 
Macros 2.26(198) nfa.c, 93 min_dfa() 2.43(32) minimize.c, 136 
MAC TEXT MAX 2.26(189) nfa.c, 93 minimize() 2.44(104) minimize.c, 137 
MAGENTA A.42( 10) termlib.h, 754 MINNONTERM 4.20(29) parser.h, 277 
main() E.20(79) expr.lma, 887 MINTERM 4.20(28) parser.h, 277 
main() E.l7(88) expr.y, 879 MINUS 0.6(9) yyout.h, 832 
main() 5.5(90) expr.y, 382 mkprod() 5.33(1393) yystate.c, 437 
main() 2.52( 109) lex.c, !55 Mline 2.2(50) input.c, 39 
main() 1.4(1) main.c, 18 _MOD_WSIZE () A.4(7) set.h, 696 
main() 6.36(3) main.c, 518 MONBASE A.46(1) video.h, 759 
main() 4.33(76) main.c, 322 MONTHS A.3(8) p, 690 
main() 7.1 (16) postfix.y, 668 move() A.70(81) curses.h, 784 
main() 2.38(190) terp.c, 120 move() 2.37(116) terp.c, 119 
main() 0.1(5)yymain.c, 821 movedot () 5.27(442) yystate.c, 422 
Make actions 4.23(180) parser.h, 281 move_eps () 5.29(707) yystate.c, 425 
make_acts () 4.30(366) 1/code.c, 311 movefile () A.37(1) movefile.c, 744 
make dtran () 2.42(197) dfa.c, 131 MS () A. I(! I) debug.h, 681 
make-icon() 6.71(371) value.c, 594 MS () A.l(l6) debug.h, 681 
make::::implicit _declaration () 6.72(117) op.c, 595 mvcur() A.70(82) curses.h, 784 
make_int () 6.71(414) value.c, 594 mvinch() A.70(92) curses.h, 784 
make_ nonterm () 4.26(682) acts.c, 290 mvwin() A.77(23) mvwin.c, 791 
Make _parser 4.23(181) parser.h, 281 mvwinch() A.70(93) curses.h, 784 
make_parse_tables() 5.28(467) yystate.c, 423 mvwinr() A.70(45) curses.h, 784 
make _push tab () 4.30(132) I/ code .c, 311 NAME 4.18(8) 1/out.h, 276 
make_ scon () 6.75(426) value.c, 601 NAME 0.6(4) yyout.h, 832 
makesig() 7.6(94) optimize.c, 674 NAME MAX 4.22(121) parser.h, 279 
maketab() A.l5(32) hash.c, 717 NAME MAX 6.22(12) symtab.h, 488 
make term() 4.26(335) acts.c, 290 Namep E.l7(57) expr.y, 879 
make::::token_file() 4.32(56) stok.c, 321 Namep 3.3(7) expr.y, 185 
make_types_match() 6.97(712) op.c, 628 Namep 1.8(2) name.c, 26 
make _yy _act () 4.30(444) llcode.c, 311 Namep 5.1(5) support.c, 353 
make_yy_dtran () 4.30(194) llcode.c, 311 Names E.l7(56) expr.y, 879 
make _yy _lhs () 5.33(1239) yystate.c, 437 Names 3.3(6) expr.y, 185 
Make_yyoutab 4.23(182) parser.h, 281 Names 1.8(1) name.c, 26 
make_yy_pushtab() 4.30( 163) llcode.c, 311 Names 5.1(4) support.c, 353 
make_yy_reduce() 5.33(1271) yystate.c, 437 NBITS () A. I (68) debug.h, 681 
make_yy_sact () 4.30(335) llcode.c, 311 NBITS IN UNSIGNED A.23(4) hashpjw.c, 724 
make _yy _ slhs () 5.33(1302) yystate.c, 437 NCOLS 2.48(23) pairs.c, 143 
make_yy_snonterm() 4.30(303) llcode.c, 311 NCOLS 2.47(9) print_ar.c, 142 
make_yy_srhs () 5.33(1328) yystate.c, 437 NCOLS 2.49(26) squash.c, 147 
make _yy _ stok () 4.32(17) stok.c, 321 NE() 6.19(69) virtual.h, 475 
make _yy _ synch () 4.30(270) II code .c, 311 Nest lev 6.42(120) c.y, 530 
Map 4.8(168) yydebug.c, 243 NEW 5.24(206) yystate.c, 416 
Cross Reference by Symbol 919 
new() 2.25(105) nfa.c, 91 num_ele() A.7(126) set.c, 703 
new() 5.23(73) yystate.c, 413 Numgroups 2.43(17) minimize.c, 136 
new_class_spec() 6.40(21) dec/.c, 526 NUMNONTERMS 4.20(45) parser.h, 277 
new field() 4.26(675) acts.c, 290 NUM OR ID 1.1 (7) lex.h, 15 
new:::: field() 4.26(793) acts.c, 290 NUM OR ID 4.2(4) 1/out.h, 229 
new_input_file() 4.16(1291) yydebug.c, 267 Num_productions 4.23(221) parser.h, 281 
newitem() 5.27(394) yystate.c, 422 NUMROWS A.46(3) video.h, 159 
new_lev() 4.26(648) acts.c, 290 NUMTERMS 4.20(44) parser.h, 277 
new_lev() 4.26(698) acts.c, 290 Num_warnings 4.33(31) main.c, 322 
NEWLINE() 4.8(40) yydebug.c, 243 0 0.5(14) c./ex, 829 
NEWLINE() 4.8(46) yydebug.c, 243 0 6.37(42) c./ex, 519 
new_link () 6.28(85) symtab.c, 497 0 BINARY A.l(l8) debug.h, 681 
new_ macro () 2.26(202) nfa.c, 93 OCLASS 6.25(113) symtab.h, 493 
new_name () E.l7(59) expr.y, 879 oclass str () 6.32(370) symtab.c, 504 
newname() 3.3(9) expr.y, 185 oct2bin () A.26(23) esc.c, 728 
newname () 1.8(4) name.c, 26 OFF() A. I (40) debug.h, 681 
new_name () 5.1(16) support.c, 353 Offset 6.62(14) /oca/.c, 560 
new_ nonterm () 4.26(391) acts.c, 290 Ofile 2.22(22) globals.h, 87 
new_rhs () 4.26(460) acts.c, 290 OFILE NAME 6.34(1245) c .y. 512 
newset () A.5(9) set.c, 699 OK A.70(24) curses.h, 784 
new_stab() 6.1 09( 17) switch.c, 650 on_ferr () A.29(8) onferr.c, 733 
newstate () 5.25(209) yystate.c, 418 onintr () 4.33(146) main.c, 322 
new_structdef () 6.28(148) symtab.c, 497 Onumele 4.8(123) yydebug.c, 243 
newsym() A.l3(9) hash.c, 716 op () 3.3(22) expr.y, 185 
new_symbol () 6.28(23) symtab.c, 497 open_ errmsg () 4.34(507) main.c, 328 
new_type_spec () 6.40(70) dec/.c, 526 Openp 2.2(62) input.c, 39 
new_ value() 6.68(19) value.c, 585 optimize() 7.6(74) optimize.c, 674 
Next 2.2(41) input.c, 39 OR 4.18(10) 1/out.h, 276 
Next alloc 2.25(84) nfa.c, 91 OR 0.6(19) yyout.h, 832 
Next allocate 5.24(195) yystate.c, 416 or() 6.92(627) op.c, 623 
nextchar() 2.38(156) terp.c, 120 OROR 0.6(15) yyout.h, 832 
next_ member ( ) A.9(397) set.c, 708 Osig 6.34(1281) c.y, 512 
nextsym() A.l8(124) hash.c, 720 OTHER 4.18(11) 1/out.h, 276 
nfa() 2.35(26) terp.c, 116 OTHER_BOX() A.71(39) box.h, 787 
NFA 2.20(17) nfa.h, 85 OTHER_BOX() A.71(42) box.h, 787 
Nfa 2.35(21) terp.c, 116 out 4.33(241) main.c, 322 
NFA MAX 2.21(28) nfa.h, 86 output() 2.19(147) /ex.par, 75 
Nfa states 2.25(82) nfa.c, 91 output() 4.34(379) main.c, 328 
Nfa states 2.35(22) terp.c, 116 Output 4.23(185) parser.h, 281 
Nit ems 5.20(14) yystate.c, 411 Output_fname 4.33(32) main.c, 322 
Nl A.84(14) winio.c, 796 OX() 4.19( II) parser.h, 276 
No_comment_pix 4.8(131) yydebug.c, 243 OX() 4.19(8) parser.h, 276 
No_compression 2.52(31) /ex.c, 155 ox 4.23(200) parser.h, 281 
nocrmode () A.84(26) winio.c, 796 P() A.l(25,28) debug.h, 681 
node 7.3(10) optimize.c, 669 p 6.9(48) virtua/.h, 465 
No header 2.52(33) lex.c, 155 pact() 4.26(128) acts.c, 290 
No-lines 2.22(12) globa/s.h, 87 p_action() 5.23(95) yystate.c, 413 
No-lines 4.23(183) parser.h, 281 pairs() 2.48(29) pairs.c, 143 
NO_ MORE_ CHARS () 2.2(35) input.c, 39 parse_ args () 4.33(159) main.c, 322 
NONASSOC 4.18(9) 1/out.h, 276 parse_ err () 2.24(70) nfa.c, 90 
NONE 2.20(24) nfa.h, 85 PARSE FILE 4.20(91) parser.h, 277 
NONFATAL 4.20(79) parser.h, 277 PARSE FILE 4.20(99) parser.h, 277 
NO OCLASS 6.24(55) symtab.h, 492 Parse _pix 4.8(136) yydebug.c, 243 
NORMAL A.42(17) termlib.h, 754 PAR TEMPL 4.20(105) parser.h, 277 
No_stack_pix 4.8(132) yydebug.c, 243 PAR TEMPL 4.20(95) parser.h, 277 
NOT IBM PC 4.8(42) yydebug.c, 243 patch() 5.15(29) yypatch.c, 402 
NOUN 6.25(107) symtab.h, 493 P _breakpoint 4.8(88) yydebug.c, 243 
noun_str () 6.32(381) symtab.c, 504 Pbuf 2.38(153) terp.c, 120 
No_warnings 4.23(184) parser.h, 281 PBUF SIZE A.40(3) searchen.c, 747 
nows () 4.17(215) parser.lex, 271 pchar () A.31(5)pchar.c, 733 
Npairs 5.20(15) yystate.c, 411 pclosure () 5.32(1225) yystate.c, 434 
NREQ 6.63(76) gen.c, 567 pdriver () 2.51 (83) print.c, 153 
Nstates 2.40(37) dfa.c, 127 P_dsp 4.8(107) yydebug.c, 243 
Nstates 2.25(83) nfa.c, 91 PERCENT UNION 4.18(21) 1/out.h, 276 
Nstates 5.24(183) yystate.c, 416 p_goto() 5.23(134) yystate.c, 413 
Ntab entries 5.20(16) yystate.c, 411 pgroups() 2.45(223) minimize.c, 140 
NULLABLE() 4.22(137) parser.h, 279 pheader () 2.51(18) print.c, 153 
NUMCOLS A.46(4) video.h, 159 PHYS () A.l(41) debug.h, 681 
NUMELE() A.l(58) debug.h, 681 PHYS () A.l(43) debug.h, 681 
NUM ELE 6.25(116) symtab.h, 493 plab() 2.33(38) printnfa.c, 110 
920 Cross Reference by Symbol 
pLength 2.2(46) input.c, 39 pterm() 4.26( 108) acts.c, 290 
pLineno 2.2(45) input.c, 39 PTR PREFIX 6.10(15) c-code.h, 465 
PLUS 1.1(3) lex.h, 15 PTRPTR PREFIX 6.10(19) c-code .h, 465 
PLUS 4.2(2) /lout.h, 229 PTR WIDTH 6.2(4) c-code.h, 452 
PLUS 0.6(8) yyout.h, 832 PTYPE 6.27(170) symtab.h, 497 
plus_minus () 6.101(963) op.c, 634 PUB 6.24(56) symtab.h, 492 
pm() 6.20(84) virtual.h, 477 PUBLIC A.1 (8) debug .h. 681 
pmap () 2.49(276) squash.c, 147 public 6.6(40) virtua/.h, 461 
pMark 2.2(44) input.c, 39 Public 2.22(14) globa/s.h, 87 
pnext () 2.48(135) pairs.c, 143 Public 4.23( 186) parser.h, 281 
pnonterm() 4.26(171) acts.c, 290 purge_ undecl () 6.72(152) op.c, 595 
POINTER 6.23(33) symtab.h, 491 PUSH() 2.25(95) nfa.c, 91 
POP() 2.25(96) nfa.c, 91 push_() A.2(23) stack.h, 689 
pop_ () A.2(24) stack.h, 689 push() A.2(26) stack.h, 689 
pop() A.2(30) stack.h, 689 push() 6.11 (53) virtual.h, 466 
pop() 6.11 (54) virtua/.h, 466 putstr () A.33(89) Driver, 736 
popn_ () A.2(34) stack.h, 689 QUEST 0.6(12) yyout.h, 832 
popn() A.2(35) stack.h, 689 rl 6.4(30) virtual.h, 454 
PP 6.9(52) virtual.h, 465 r2 6.4(30) virtual.h, 454 
PREC 4.18(12) /lout.h, 276 r3 6.4(30) virtual.h, 454 
prec() 4.26( 659) acts .c, 290 r4 6.4(30) virtual.h, 454 
prec() 4.26(735) acts.c, 290 r5 6.4(30) virtual.h, 454 
Prec lev 4.26(50) acts.c, 290 r6 6.4(30) virtual.h, 454 
prec::::list () 4.26(710) acts.c, 290 r7 6.4(30) virtual.h, 454 
PRECTAB 4.23(164) parser.h, 281 r9 6.4(31) virtual.h, 454 
presskey () 4.16(1444) yydebug.c, 267 rA 6.4(31) virtual.h, 454 
PRI 6.24(57) symtab.h, 492 RANGE() A.1(79) debug.h, 681 
print_a_macro () 2.26(294) nfa.c, 93 RB 0.6(46) yyout.h, 832 
print_ array() 2.47(12) print_ar.c, 142 rB 6.4(31) virtual.h, 454 
print_bss_dcl () 6.49(334) decl.c, 542 RC 0.6(44) yyout.h, 832 
printbuf () 2.38(169) terp.c, 120 rC 6.4(31) virtual.h, 454 
printccl () 2.33(16) printnfa.c, 110 rD 6.4(31) virtual.h, 454 
print_col_map () 2.49(240) squash.c, 147 rE 6.4(31) virtua/.h, 454 
printf 5.19(14) occs-act.par, 410 READ CHAR A.43( 12) vbios.h, 756 
print_instruction() 6.63(247) gen.c, 567 Readp 2.2(64) input.c, 39 
printmacs () 2.26(300) nfa.c, 93 READ POSN A.43(9) vbios.h, 756 
print_nfa () 2.33(57) printnfa.c, 110 Recycled_items 5.27(392) yystate.c, 422 
print_offset_comment() 6.60(628) decl.c, 557 RED A.42(9) termlib.h, 754 
print_one_case() 5.15(179) yypatch.c, 402 reduce() 2.49(116) squash.c, 147 
print_reductions() 5.33(1368) yystate.c, 437 reduce_one_item() 5.30(989) yystate.c, 431 
print_ row_ map () 2.49(268) squash.c, 147 Reduce reduce 5.20(18) yystate.c, 411 
print symbols () 4.26(243) acts .c, 290 reductions () 5.30(944) yystate.c, 431 
print::::syms () 6.32(589) symtab.c, 504 refresh() A.70(33) curses.h, 784 
print tab() 5.33(1406) yystate.c, 437 refresh_ win () 4.10(417) yydebug.c, 251 
print -tok () 4.26(87) acts.c, 290 reg A.70(20) curses.h, 784 
printv o A.32(3) printv.c, 734 reg 6.4(28) virtual.h, 454 
printw() A.86(25) wprintw.c, 800 Region 6.64(20) temp.c, 575 
PRINTWIDTH 4.8(68) yydebug.c, 243 REGION MAX 6.64(14) temp.c, 575 
PRIVATE A.1(2) debug.h, 681 REGISTER 6.24(49) symtab.h, 492 
PRIVATE A.1(5) debug.h, 681 release_ value () 6.69(361) value.c, 588 
private 6.6(42) virtua/.h, 461 RELOP 0.6(16) yyout.h, 832 
prnt() A.33(19) Driver, 736 relop() 6.97(664) op.c, 628 
prnt _putc () 4.10(386) yydebug.c, 251 REMOVE() A.4(66) set.h, 696 
problems() 4.26(290) acts.c, 290 remove_duplicates() 6.48(301) decl.c, 539 
PROC () 6.12(55) virtual.h, 467 remove_epsilon() 4.28(171)follow.c, 307 
PRODUCTION 4.22(156) parser.h, 279 remove_symbols_from_table() 6.62(111) /ocal.c, 560 
production_str () 4.26(143) acts.c, 290 request 6.63(19) gen.c, 567 
PROG NAME 4.20( I 07) parser.h, 277 ret() 6.12(60) virtual.h, 467 
PROG NAME 4.20(96) parser.h, 277 ret_reg() 6.87(553) op.c, 616 
PROMPT TOP 4.8(62) yydebug.c, 243 RETURN 0.6(28) yyout.h, 832 
Prompt_window 4.8(117) yydebug.c, 243 return() A.68(103) glue.c, 772 
PROMPT WINSIZE 4.8(63) yydebug.c, 243 REVERSE A.42(19) termlib.h, 754 
pset () A.9(434) set.c, 708 reverse _links () 6.31(331) symtab.c, 502 
PSIZE 6.27(169) symtab.h, 497 rF 6.4(31) virtual.h, 454 
P_sp 4.8(109) yydebug.c, 243 rhs () 4.25(188) 1/par.c, 285 
pstate () 5.32(1159) yystate.c, 434 RHSBITS 4.22(142) parser.h, 279 
pstate_stdout () 5.32(1215) yystate.c, 434 RIGHT A.71(46) box.h, 787 
pstruct () 6.32(571) symtab.c, 504 RIGHT 4.18(13) /lout.h, 276 
psym() 6.32(557) symtab.c, 504 RIGHT 6.67(20) value.h, 584 
ptab() A.19(142) hash.c, 721 RIGHT _OF_DOT() 5.20(35) yystate.c, 411 
Cross Reference by Symbol 
right sldes () 
rlabel () 
_ROUND() 
ROW 
Row 
ROW_CPY () 
ROW _EQUIV () 
Row_map 
RP 
RP 
RP 
rule() 
rvalue () 
rvalue _name () 
s 
s 
s2 
s2 
save() save() 
Save 
Savep 
S_breakpoint 
SBUF 
SCLASS 
SCLASS 
SCLASS 
sclass _ str () 
SCREEN 
SCRNSIZE SCRNSIZE 
scroll() 
SCROLL DOWN 
scrollok () 
SCROLL UP 
SDEPTH 
searchenv () 
SEG() 
SEG() 
select() 
SEMI 
SEMI 
SEMI 
SEMI 
SEPARATOR 
SET 
set_class_bit () 
setcmp () 
SET DISJ 
_SET_EQUIV 
sethash () 
SET INTER 
_set_op () 
SET POSN 
set_test() 
SETTYPE 
SEVENTY FIVE PERCENT 
shift_name () 
SHIFTOP 
Shift reduce 
showwin() 
sigint_handler() 
signon () 
signon () 
Singlestep 
S_input 
SIZEOF 
sMark 
snames 
Sort_ by_ number 4.25(164) 1/par.c, 285 
6.104(1062) op.c, 640 
A.4(1 0) set.h, 696 
2.39(21) dfa.h, 125 
A.52(4) dv _yutc.c, 761 
2.49(46) squash.c, 147 
2.49(45) squash.c, 147 
2.49(24) squash.c, 147 
1.1(6)/ex.h, 15 
4.2(6) 1/out.h, 229 
0.6(42) yyout.h, 832 
2.29(531) nfa.c, 102 
6.68(84) value.c, 585 
6.68(117) value.c, 585 
E.2(14) expr.y, 841 
5.5(32) expr.y, 382 
6.34(1301) c.y, 512 
6.34(1302) c.y, 512 
2.25(146) nfa.c, 91 
A.83(27) wincreat.c, 794 
A.83(23) wincreat.c, 794 
2.25(101) nfa.c, 91 
4.8(90) yydebug.c, 243 
A.42(45) termlib.h, 754 
2.48(25) pairs.c, 143 
2.49(28) squash.c, 147 
6.25(108) symtab.h, 493 
6.32(358) symtab.c, 504 
A.46(21) video.h, 759 
4.8(39) yydebug.c, 243 
4.8(45) yydebug.c, 243 
A.70(88) curses.h, 784 
A.43(11) vbios.h, 756 
A.70(34) curses.h, 784 
A.43(10) vbios.h, 756 
6.3(10) c-code.h, 454 
A.40(5) searchen.c, 747 
A.l(39) debug.h, 681 
6.5(39) virtual.h, 457 
4.29(46) 1/se/ect.c, 310 
1.1 (2) /ex.h, 15 
4.18(14) 1/out.h, 276 
4.2(7) /lout.h, 229 
0.6(48) yyout.h, 832 
4.18(15) /lout.h, 276 
A.4(20) set.h, 696 
6.40(37) decl.c, 526 
A.7(215) set.c, 703 
A.4(54) set.h, 696 
A.4(53) set.h, 696 
A.7(254) set.c, 703 
A.4(55) set.h, 696 
A.8(313) set.c, 706 
A.43(8) vbios.h, 756 
A.7(170) set.c, 703 
A.4(3) set.h, 696 
A.23(5) hashpjw.c, 724 
6.68(61) value.c, 585 
0.6(21) yyout.h, 832 
5.20(17) yystate.c, 411 
A.78(3) showwin.c, 792 
6.34(1283) c.y,512 
2.50(5) signon.c, 152 
4.36(7) signon.c, 333 
4.8(125) yydebug.c, 243 
2.28(373) nfa.c, 97 
0.6(40) yyout.h, 832 
2.2(42) input.c, 39 
4.24(88) parser.lma, 283 
5.24(204) yystate.c, 416 sp 
Sp 
spec cpy () 
SPECIFIER 
specifier 
sprint_tok () 
squash() 
SSIZE SSIZE 
ssort () 
Sstack 
Sstack 
stab 
Stack 
stack_ clear () 
stack cls 
stack cls 
stack_ del() 
stack_ele() 
stack_empty () 
stack_ err() 
stack_ err () 
stack_ full() 
stack_ item() 
STACK_OK() 
stack _p () 
Stacksize 
STACK TOP 
STACK_ USED () 
Stack window 
STACK WINSIZE 
STAR 
START 
START 
Start buf 
Start line 
START OPT 
start_opt () 
STATE 
state_ cmp () 
state_hash () 
State items 
statements () 
statements() 
statements() 
statements () 
State nitems 
STATENUM 
States 
STATIC 
statistics() 
STDIN 
stdscr 
stk_err () 
stmt () 
stol () 
stop _prnt () 
stop _prnt () 
stoul () 
Str buf 
STRING 
Strings 
strip_comments() 
striper() 
stritem () 
STR MAX 
STR MAX 
STRUCT 
structdef 
Struct free 921 
6.4(38) virtual.h, 454 
2.25(89) nfa.c, 91 
6.30(211) symtab.c, 501 
6.25(86) symtab.h, 493 
6.24(84) symtab.h, 492 
5.32(1087) yystate.c, 434 
2.49(50) squash.c, 147 
4.26(69) acts.c, 290 
2.25(86) nfa.c, 91 
A.34(7) ssort.c, 742 
2.25(88) nfa.c, 91 
4.8(108) yydebug.c, 243 
6.107(17) switch.h, 648 
4.26(79) acts.c, 290 
A.2( 11) stack.h, 689 
4.26(13) acts.c, 290 
A.2(5) stack.h, 689 
A.2(7) stack.h, 689 
A.2( 18) stack.h, 689 
A.2(15) stack.h, 689 
6.91(156) c.y, 622 
A.2(39) stack.h, 689 
A.2( 14) stack.h, 689 
A.2(20) stack.h, 689 
2.25(91) nfa.c, 91 
A.2(21) stack.h, 689 
4.8(121) yydebug.c, 243 
4.8(59) yydebug.c, 243 
2.25(93) nfa.c, 91 
4.8(116) yydebug.c, 243 
4.8(61) yydebug.c, 243 
0.6( 10) yyout.h, 832 
4.18(16) 1/out.h, 276 
2.20(25) nfa.h, 85 
2.2(39) input.c, 39 
4.17(28) parser.lex, 271 
4.18(17) 1/out.h, 276 
4.26(581) acts.c, 290 
5.21(55) yystate.c, 412 
5.26(336) yystate.c, 421 
5.26(372) yystate.c, 421 
5.24(202) yystate.c, 416 
1.10(11) args.c, 29 
1.6(10) improved.c, 21 
1.5(6) plain.c, 18 
1.9(11) retval.c, 27 
5.24(203) yystate.c, 416 
5.21(42) yystate.c, 412 
5.24(182) yystate.c, 416 
6.25(112) symtab.h, 493 
4.34(346) main.c, 328 
2.2(21) input.c, 39 
A.76(3) initscr.c, 791 
6.91(148) c.y, 622 
3.4(5) naive.c, 188 
A.25(47) sto/.c, 727 
A.33(34) Driver, 736 
A.33(67) Driver, 736 
A.25(3) sto/.c, 727 
6.74(141) c.y, 600 
0.6(5) yyout.h, 832 
2.25(100) nfa.c, 91 
2.52(332) /ex.c, !55 
4.17(224) parser./ex, 271 
5.32(11 09) yystate.c, 434 
6.74(140) c.y, 600 
2.21 (31) nfa.h, 86 
0.6(27) yyout.h, 832 
6.26( 157) symtab.h, 495 
6.28( 17) symtab.c, 497 
922 
STRUCTOP 
Struct tab 
STRUCTURE 
STYPE 
stype 
stype 
subset() 
subwin () 
suffix 
suffix 
SWIDTH 
SWITCH 
SYMBOL 
symbol 
Symbol free 
symbols() 
Symbols 
Syrnbol_tab 
sym_chain_str () 
SYM FILE 
SYM FILE 
Sym_pix 
Symtab 
SYNCH 
SYNCH 
Tab 
TAB FILE 
tables() tables() 
tabtype 
tail() 
tail() 
temp() 
tconst _str () 
Template 
Template 
term() 
term() 
term() 
term() 
term() 
term() 
Termchar 
term _prime () 
term _prime () 
Terms 
TERM SPEC 
TEST() 
tf_label () 
the_same_type () 
thompson() 
Threshold 
Threshold 
TIMES 
TIMES 
tmp _ alloc () 
tmp _create() 
tmp_free() 
tmp_freeall () 
tmp_gen () 
tmp_reset () 
tmp _ var _space () 
TN ODE 
TOKEN 
TOKEN FILE 
TOKEN FILE 
Tokens _printed 
TOKEN WIDTH 
Token window 
Tokmap 0.6(24) yyout.h, 832 
6.26(1S9) symtab.h, 49S 
6.24(4S) symtab.h, 492 
6.27(172) symtab.h, 497 
S.S(20) expr.y, 382 
S.l0(37) yyout.c, 386 
A.7(27S) set.c, 703 
A.70(96) curses.h, 784 
O.S(16) c./ex, 829 
6.37(44) c./ex, Sl9 
6.3(9) c-code.h, 4S4 
0.6(32) yyout.h, 832 
4.22( 13S) parser.h, 279 
6.22(30) symtab.h, 488 
6.28(1S) symtab.c, 497 
4.34(331) main.c, 328 
4.23(187) parser.h, 281 
6.22(32) symtab.h, 488 
6.32(SI9) symtab.c, S04 
4.20( 102) parser.h, 277 
4.20(92) parser.h, 277 
4.8(137) yydebug.c, 243 
4.23(212) parser.h, 281 
1.7(78) improved.c, 23 
4.18( 18) 1/out.h, 276 
6.3S(13S7) c.y, SIS 
4.20(1 0 I) parser.h, 277 
4.30(66) 1/code.c, 311 
S.l7(1) yycode.c, 408 
6.3S(I3SS) c.y, SIS 
2.S2(368) /ex.c, ISS 
4.34(S24) main.c, 328 
6.3S(1417) c.y, SIS 
6.32(470) symtab.c, S04 
2.22(1S) g/obals.h, 87 
4.23(210) parser. h. 281 
l.IO(SO) args.c, 29 
1.6(42) improved.c, 21 
3.4(44) naive.c, 188 
2.32(733) nfa.c, 108 
l.S(4S) plain.c, 18 
1.9(SO) retva/.c, 27 
2.2(SI) input.c, 39 
3.4(Sl) naive.c, 188 
l.S(S3) p/ain.c, 18 
4.23(194) parser.h, 281 
4.18(19) 1/out.h, 276 
A.4(69) set.h, 696 
6.79(199) op.c, 604 
6.31 (2S8) symtab.c, S02 
2.34(831) nfa.c, 112 
2.S2(32) lex.c, ISS 
4.23(188) parser.h, 281 
1.1(4) /ex.h, IS 
4.2(3) 1/out.h, 229 
6.64(24) temp.c, S7S 
6.69(138) value.c, S88 
6.64(82) temp.c, S7S 
6.64(109) temp.c, S7S 
6.69(22S) value.c, S88 
6.64(97) temp.c, S7S 
6.64(121) temp.c, S7S 
S.24(192) yystate.c, 416 
2.28(330) nfa.c, 97 
4.20(90) parser.h, 277 
4.20(98) parser. h. 277 
S.32(108S) yystate.c, 434 
4.8(67) yydebug.c, 243 
4.8(120) yydebug.c, 243 
2.28(332) nfa.c, 97 to_log() 
TOOHIGH () 
TOOLOW() 
TOP 
Trace 
trav () 
TRUE 
truncate() 
Tspace 
TTYPE 
TWELVE PERCENT 
TYPE 
TYPE 
TYPE TYPE 
TYPEDEF 
type_str () 
uchar 
U_GE () 
U_GT () 
UL 
U_LE () 
U_LT () 
UNADJ _VAL () 
UNCLOSED 
Uncompressed 
Undecl 
UNDERLINED 
Unfinished 
UNION 
UNION() 
union_def () 
union_def () 
UNIX() 
UNIX() 
Unix 
unlink() 
UNOP 
unput () 
UNSIGNED 
UR 
USED NONTERMS 
USED TERMS 
User_cmp 
Use stdout 
UX() 
ux () 
va_arg() 
va_end() 
VA LIST 
VA LIST 
va list 
VALNAME MAX 
VALUE 
value 
Value free 
var_dcl () 
va_start () 
VB_ BLOCK CUR ( ) 
VB_ CLR _REGION () 
VB_CLRS () 
VB_CTOYX() 
VB_ CURSIZE () 
vb _ freesbuf () 
vb_getchar () 
VB_ GETCUR () 
VB_GETPAGE () 
vb_getyx() 
VB_INCHA() 
_Vbios () Cross Reference by Symbol 
4.16(1316) yydebug.c, 267 
A.l(60) debug.h, 681 
A.l(61) debug.h, 681 
A.71(S0) box.h, 787 
6.63( II) gen.c, S67 
7.S(48) optimize.c, 672 
A.70(21) curses.h, 784 
A.8(380) set.c, 706 
6.S7(127) c.y, SSS 
2.39(12) dfa.h, 12S 
A.23(6) hashpjw.c, 724 
4.18(20) 1/out.h, 276 
2.48(24) pairs.c, 143 
2.49(27) squash.c, 147 
0.6(2S) yyout.h, 832 
6.24(SI) symtab.h, 492 
6.32(409) symtab.c, S04 
2.2(37) input.c, 39 
6.19(78) virtua/.h, 47S 
6.19(76) virtua/.h, 47S 
A.71(SS) box.h, 787 
6.19(77) virtua/.h, 47S 
6.19(7S) virtua/.h, 47S 
4.20(7S) parser.h, 277 
S.24(207) yystate.c, 416 
4.23( 189) parser.h, 281 
6.72(16) op.c, S9S 
A.42(18) termlib.h, 7S4 
S.24(200) yystate.c, 416 
A.4(38) set.h, 696 
A.4(43) set.h, 696 
4.26(66S) acts.c, 290 
4.26(762) acts.c, 290 
A.77(16) mvwin.c, 791 
A.77(19) mvwin.c, 791 
2.22(13) globals.h, 87 
6.16(63) virtua/.h, 472 
0.6(23) yyout.h, 832 
2.19(1S6) lex.par, 7S 
6.2S( II 0) symtab.h, 493 
A.71(47) box.h, 787 
4.20( 48) parser. h. 277 
4.20( 47) parser.h, 277 
A.l9(140) hash.c, 721 
4.23( 190) parser.h, 281 
A.l(l2) debug.h, 681 
A.l(l7) debug.h, 681 
A.24(3) stdarg.h, 726 
A.24(4) stdarg.h, 726 
A.l(26) debug.h, 681 
A.l(30) debug.h, 681 
A.24( I) stdarg .h, 726 
6.67(S) value.h, S84 
6.2S(ll8) symtab.h, 493 
6.67(17) value.h, S84 
6.68(14) value.c, S8S 
6.49(3SO) dec/.c, S42 
A.24(2) stdarg.h, 726 
A.4S(61) vbios.h, 7S8 
A.4S(S9) vbios.h, 7S8 
A.4S(S8) vbios.h, 7S8 
A.4S(Sl) vbios.h, 7S8 
A.4S(47) vbios.h, 7S8 
A.60(S) vb Jrees.c, 768 
A.61(4) vb getch.c, 768 
A.4S(46) vbios.h, 7S8 
A.4S(44) vbios.h, 7S8 
A.62(3) vb _getyx.c, 768 
A.4S(4S) vbios.h, 7S8 
A.44(8) _vbios.c, 7S7 
Cross Reference by Symbol 923 
vb_iscolor () A.63(3) vb isco/.c, 768 WRITE A.43(13) vbios.h, 756 
VB_ NORMALCUR ( ) A.45(62) vbios.h, 758 write screen() 4.10(607)yydebug.c, 251 
VB_ OUTCHA ( ) A.45( 48) vbios.h, 758 WRITE TTY A.43(14) vbios.h, 756 
vb_putc () A.64(4) vbyutc.c, 769 WS 4.17(37) parser.lex, 271 
VB _PUTCHAR () A.45(63) vbios.h, 758 wscroll () A.87(19) wscrol/.c, 801 
vb_puts () A.65(3) vb _yuts.c, 769 XOR 0.6(20) yyout.h, 832 
VB_ REPLACE () A.45(49) vbios.h, 758 xp A.68(103) g/ue.c, 772 
vb _restore () A.66(5) vb _resto.c, 769 YyaOOO 5.12(205) yyout.c, 389 
vb_save() A.67(6) vb _save.c, 770 YyaOOl 5.12(206) yyout.c, 389 
VB_ SCROLL ( ) A.45(52) vbios.h, 758 Yya003 5.12(207) yyout.c, 389 
VB_ SETCUR () A.45(50) vbios.h, 758 Yya004 5.12(208) yyout.c, 389 
VCHUNK 6.68(15) value.c, 585 YyaOOS 5.12(209) yyout.c, 389 
VD BOT A.71 (82) box.h, 787 Yya006 5.12(21 0) yyout.c, 389 
VD CEN A.71(86) box.h, 787 Yya009 5.12(211) yyout.c, 389 
VD HORIZ A.71(85) box.h, 787 Yya010 5.12(212) yyout.c, 389 
VDISPLAY A.46(24) video.h, 759 YyaOll 5.12(213) yyout.c, 389 
VD LEFT A.71(84) box.h, 787 YYABORT 4.4(54) l/ama.par, 230 
VD LL A.71(81) box.h, 787 YYACCEPT 4.4(50) llama.par, 230 
VD LR A.71(87) box.h, 787 Yyaccept 2.17(125) /exyy.c, 73 
VD RIGHT A.71(79) box.h, 787 yy _act() 4.5( 199) l/out.c, 232 
VD TOP A.71(83) box.h, 787 Yy_action 5.12(215) yyout.c, 389 
VD UL A.71 (88) box.h, 787 yy_break () 4.15(1167) yydebug.c, 264 
VD UR A.71 (80) box.h, 787 yybss () 4.6(414) llama.par, 236 
VD VERT A.71(78) box.h, 787 yybss () 4.6(469) llama.par, 236 
VERBOSE() 4.33(35) main.c, 322 yybss () 5.13(42) occs.par, 394 
Verbose 2.22(11) globals.h, 87 yybss () 5.13(82) occs.par, 394 
Verbose 4.23(191) parser.h, 281 yybssout 4.6(30 I) l/ama.par, 236 
VERT A.71(45) box.h, 787 Yy_cmap 2.15(71) /exyy.c, 69 
vfprintf () A.33(76) Driver, 736 yycode () 4.6(398) llama.par, 236 
VIDEO INT A.43(5) vbios.h, 756 yycode () 4.6(453) llama.par, 236 
V INT 6.25( 119) symtab.h, 493 yycode () 5.13(26) occs.par, 394 
V LONG 6.25(121) symtab.h, 493 yycode () 5.13(66) occs.par, 394 
void A.l(29) debug.h, 681 yycodeout 4.6(300) l/ama.par, 236 
VOID 6.24(44) symtab.h, 492 yycomment () 2.18(11) lex _io.c, 74 
vprintf () A.33(83) Driver, 736 yycomment () 4.6(477) llama.par, 236 
VSCREEN A.46(25) video.h, 759 yycomment () 5.13(90) occs.par, 394 
Vsize 4.8(1 05) yydebug.c, 243 yycomment() 4.10(488) yydebug.c, 251 
Vspace 6.57(126) c.y, 555 YY_D () 2.13( 45) /ex.par, 65 
vsprintf () A.33(96) Driver, 736 YY_D () 2.13(47) lex.par, 65 
Vstack 4.8(1 03) yydebug.c, 243 YYD () 5.19(13) occs-act.par, 410 
V STRUCT 6.25(123) symtab.h, 493 YYD() 5.19(16) occs-act.par, 410 
V UINT 6.25(120) symtab.h, 493 YYD () 5.19(2) occs-act.par, 410 
V ULONG 6.25(122) symtab.h, 493 YYD () 5.19(4) occs-act.par, 410 
w 6.9(45) virtua/.h, 465 Yyd 4.5(177) l/out.c, 232 
waddch () A.84(124) winio.c, 796 yydata () 4.6(406) l/ama.par, 236 
waddstr () A.79(3) waddstr.c, 793 yydata () 4.6(461) llama .par, 236 
Warn exit 4.33(30) main.c, 322 yydata () 5.13(34) occs.par, 394 
WARNING 4.20(81) parser.h, 277 yydata () 5.13(74) occs.par, 394 
wclear () A.70(74) curses.h, 784 yydataout 4.6(302) llama .par, 236 
wclrtoeol () A.80(3) wclrtoeo.c, 793 YYDEBUG 4.3(2) l/out.c, 230 
werase () A.81(3) werase.c, 794 YYERROR() 6.37(34) c./ex, 519 
wgetch () A.84(72) winio.c, 796 YYERROR() 2.19(151) lex.par, 75 
WHILE 0.6(35) yyout.h, 832 yyerror () 2.18(22) lex _io.c, 74 
WHITE A.42(12) termlib.h, 754 yyerror () 4.6( 485) llama.par, 236 
white 0.5( 17) c./ex, 829 yyerror () 5.13(98) occs.par, 394 
white 6.37(45) c./ex, 519 yyerror () 4.10(510) yydehug.c, 251 
WHITESPACE 4.18(22) l/out.h, 276 YYF 2.13(51) lex .par, 65 
winch() A.82(3) winch.c, 794 YYF 4.4(35) llama .par, 230 
WINDOW A.70(17) curses.h, 784 YygOOO 5.12(235) yyout.c, 389 
wmove() A.85(3) wmove.c, 800 Yyg002 5.12(236) yyout.c, 389 
WORD HIGH BIT 6.2(7) c-code.h, 452 Yyg007 5.12(237) yyout.c, 389 
WORD PREFIX 6.1 0(13) c-code .h, 465 Yyg008 5.12(238) yyout.c, 389 
WORDPTR PREFIX 6.10(17) c-code.h, 465 yy get_ args () 4.9(320) yydehug.c, 247 
words 6.4(18) virtua/.h, 454 Yy_goto 5.12(240) yyout.c, 389 
WORD WIDTH 6.2(2) c-code.h, 452 yyhook_a () 6.36(17) main.c, 518 
WP 6.9(49) virtual.h, 465 yyhook_a () 4.13(1) yyhook a.c, 264 
wprintw() A.86(12) wprintw.c, 800 yyhook_b () 6.36(27) main.c, 518 
wputc () A.86(5) wprintw.c, 800 yy_init_debug() 5.13(56) occs.par, 394 
wrapok () A.70(35) curses.h, 784 yy _ ini t _debug() 4.9(180) yydebug.c, 247 
wrefresh () A.70(36) curses.h, 784 YY_lnlt lex() 0.2(1) yyinitlx.c, 822 
924 Cross Reference by Symbol 
yy_init_llama () E.20(64) expr./ma, 887 yyprompt () 4.16(1385) yydebug.c, 267 
yy_init_llama () 4.24(1 10) parser./ma, 283 yy _pstack () 5.13(57) occs.par, 394 
yy init occs () 6.34(1306) c.y, 512 yy_pstack () 4.11(664) yydebug.c, 256 
yy::: ini t::: occs () 5.5(73) expr.y, 382 yypstk () 6.35(1423) c.y, 515 
yy_init_occs () E.l7(80) expr.y, 879 yypstk () E.20(70) expr.lma, 887 
yy init stack() 5.14(165) occs.par, 396 yypstk () 5.5(58) expr.y, 382 
yy-input () 4.10(542) yydebug.c, 251 yypstk () 4.24( 116) parser.lma, 283 
yy::: in_ synch () 4.7(502) 1/ama.par, 239 yypstk () E.IO(I2) yypstk2.c, 865 
YY_ISACT () 4.4(47) 1/ama.par, 230 yypstk () E.5(3) yypstk.c, 854 
YY _I SNONTERM () 4.4(46) 1/ama.par, 230 yypush_ () A.3(23) yystack.h, 690 
YY_ISTERM () 4.4( 45) 1/ama.par, 230 yypush () A.3(26) yystack.h, 690 
yyleng 1.2(6) /ex.c, 15 yy_push () 4.6(331) 1/ama.par, 236 
yyleng 2.19(139) lex.par, 75 Yy_pushtab 4.5(135) 1/out.c, 232 
yyless () 2.19(157) /ex.par, 75 yy_quit_debug() 5.13(55) occs.par, 394 
yylex () 2.19(177) /ex.par, 75 yy _quit_ debug () 4.9(270) yydebug.c, 247 
Yy_lhs 5.12(252) yyout.c, 389 yy _recover () 5.14(182) occs.par, 396 
yylineno 1.2(7) lex.c, 15 yy_redraw_stack() 4.11(881) yydebug.c, 256 
yylineno 2.19(140) /ex.par, 75 yy _reduce () 5.14(128) occs.par, 396 
yylval 6.37(28) c./ex, 519 Yy_reduce 5.12(268) yyout.c, 389 
YYMAXDEPTH E.8(19) expr.y, 857 Yy_rmap 2.15(83) lexyy.c, 69 
YYMAXDEPTH 4.4(66) 1/ama.par, 230 Yy_sact 4.5(292) 1/out.c, 232 
YYMAXERR E.8(20) expr.y, 857 yy_say_whats _happening () 4.6(356) 1/ama.par, 236 
YYMAXERR 4.4(62) 1/ama.par, 230 yy_shift () 5.14(111) occs.par, 396 
YY MAXNONTERM 4.3(31) 1/out.c, 230 YYSHIFTACT () 5.5(23) expr.y, 382 
YY MAXTERM 4.3(29) 1/out.c, 230 Yy_slhs 5.12(285) yyout.c, 389 
YY MINACT 4.3(33) 1/out.c, 230 Yy_snonterm 4.5(276) 1/out.c, 232 
YY MINNONTERM 4.3(30) 1/out.c, 230 Yy_srhs 5.12(301) yyout.c, 389 
YY MINTERM 4.3(28) 1/out.c, 230 YY START STATE 4.3(32) 1/out.c, 230 
yymore () 2.19(154) lex.par, 75 yystk clear () A.3( I 0) yystack.h, 690 
yynerrs 4.6(303) 1/ama.par, 236 yystk:::cls A.3(4) yystack.h, 690 
yynerrs 4.25(29) 1/par.c, 285 yystk_dcl () A.3(6) yystack.h, 690 
yy_next () 2.15(102) lexyy.c, 69 yystk _ ele () A.3( 17) yystack.h, 690 
yy_next () 2.14(147) /exyy.c, 66 yystk _empty () A.3(14) yystack.h, 690 
yy_next () 4.5(192) 1/out.c, 232 yystk _err () A.3(39) yystack.h, 690 
yy_next () 2.16(96) lexyy.c, 70 yystk full () A.3(13) yystack.h, 690 
yy_next () 5.13(1) occs.par, 394 yystk::)tem() A.3(20) yystack.h, 690 
yy_next () 5.3(1) yynext.c, 372 yystk_p() A.3(21) yystack.h, 690 
yy _ nextoken () 5.13(54) occs.par, 394 Yy_stok 4.5(256) 1/out.c, 232 
Yy_nxt 2.14(54) lexyy.c, 66 Yy_stok 5.12(177) yyout.c, 389 
Yy_nxt 2.15(88) lexyy.c, 69 YYSTYPE E.20(27) expr.lma, 887 
Yy_nxt 2.16(89) lexyy.c, 70 YYSTYPE E.8(17) expr.y, 857 
Yy_nxtO 2.16(54) lexyy.c, 70 YYSTYPE 5.5(21) expr.y, 382 
Yy_nxtl 2.16(58) lexyy.c, 70 YYSTYPE 4.4(70) 1/ama.par, 230 
Yy_nxt2 2.16(72) lexyy.c, 70 YYSTYPE 4.3(23) 1/out.c, 230 
Yy_nxt3 2.16(76) /exyy.c, 70 YYSTYPE 5.19(8) occs-act.par, 410 
Yy_nxt4 2.16(80) lexyy.c, 70 YYSTYPE 4.24(23) parser./ma, 283 
Yy_nxt5 2.16(84) lexyy.c, 70 yy_sym() 5.13(58) occs.par, 394 
yyout 2.19(141) lex.par, 75 yy_sym() 4.6(31 0) 1/ama.par, 236 
yy_output () 4.1 0( 430) yydebug .c, 251 yy_synch () 4.7(514) 1/ama.par, 239 
YypOO 4.5(133) 1/out.c, 232 yytext 1.2(5) lex.c, 15 
YypOl 4.5(132) 1/out.c, 232 yytext 2.19(138) lex.par, 75 . 
Yyp02 4.5(131) 1/out.c, 232 yytos () 4.4(96) 1/ama.par, 230 
Yyp03 4.5( 129) 1/out.c, 232 YY TTYPE 2.13(50) /ex.par, 65 
Yyp04 4.5(128) 1/out.c, 232 YY TTYPE 4.4(34) 1/ama.par, 230 
Yyp05 4.5(130) 1/out.c, 232 YY TTYPE 4.21(116) parser.h, 279 
Yyp06 4.5(125) 1/out.c, 232 YY TYPE 5.11(106) occs.par, 386 
Yyp07 4.5(124) 1/out.c, 232 YYVERBOSE E.8(21) expr.y, 857 
Yyp08 4.5(127) 1/out.c, 232 Yy_vsp 4.4(1 08) llama .par, 230 
Yyp09 4.5(126) 1/out.c, 232 Yy_vstack 4.4(107) 1/ama.par, 230 
yyparse () 4.7(552) 1/ama.par, 239 yyvstype 4.4(105) 1/ama.par, 230 
yyparse () 4.25(74) 1/par.c, 285 
yyparse () 5.14(245) occs.par, 396 
yyparse 4.25(23) 1/par.c, 285 
yypop () A.3(24) yystack.h, 690 
yypop() A.3(30) yystack.h, 690 
yy_pop () 4.6(345) 1/ama.par, 236 
yypopn_ () A.3(34) yystack.h, 690 
yypopn () A.3(35) yystack.h, 690 
YYPRIVATE 2.13(36) lex.par, 65 
YYPRIVATE 4.4(58) llama .par, 230 
1,2{1.02) 
September 11, 1997 Errata: Compiler Design in C 
This document is a list of typos and corrections that need to be made to Compiler 
Design in C, Allen Holub, 1990 (as of September 11, 1997). The corrections marked 
"Disk only" represent changes made to the files on the distribution disk that either 
don't affect the code in any significant way or are too big to insert into the book. All 
these will eventually be incorporated into the second edition, if there is one, but they 
won't be put into subsequent printings of the first edition. There are also a many 
trivial changes that have been made to the code on the disk to make it more robust: 
Function prototypes have been added here and there, as have includes for .h files 
that contain prototypes, all .h files have been bracketed with statements like: 
#ifndef 
#define 
#end if FILE EXT /* file name with 
FILE EXT for dot */ 
to make multiple inclusions harmless, and so forth. These changes allow the code to 
compile under Borland C++ as well as Microsoft C and BSD UNIX. None of these 
trivial changes are documented here. 
The printings in which the error occurs and the software version in which the 
change was made are identified in the margin at the head of each entry. For exam­
ple, the numbers next to the current paragraph indicate that the typo is found in 
both the first and second printings, and that the bug was fixed in software version 
1.02. Determine your printing by looking at the back of the flyleaf, where you'll 
find a list of numbers that looks something like this: 10 9 8 7 6 5 4 3. The 
smallest number in the list is the printing. 
Page xvi -Seventh line from the bottom. Change "No credit cards" to "No purchase 
orders or credit cards." The last two lines of the paragraph should read: 
must add local sales tax. No purchase orders or credit cards (sorry). A Macintosh 
version will be available eventually. Binary site licenses are available for educational 
institutions. 
Page xvi -Last line. Internet can now be accessed from CompuServe. Add the 
Compuserve/internet address >INTERNET:holub@violet.berkeley.edu to the 
parenthesized list at the end of the paragraph. A replacement paragraph follows: 
The code in this book is bound to have a few bugs in it, though I've done my best to test 
it as thoroughly as possible. The version distributed on disk will always be the most 
recent. If you fmd a bug, please report it to me, either at the above address or electroni­
cally. My internet address is holub@violet.berkeley.edu CompuServe users can access 
internet from the email system by prefixing this address with >INTERNET: -type help 
internet for information. My UUCP address is ... !ucbvax!violet!holub. 
-10- Errata: Compiler Design in C 
Page xvi -15 lines from the bottom. Change the phone number to: 
(510) 540-7954 
Page xviii -Line 7, change "that" to "than". The replacement line follows: 
primitives. It is much more useful than pic in that you have both a WYSIWYG capability ' 
Page 8-The line that starts "JANE verb object" in the display at the bottom of the page 
is repeated Delete the first one. A replacement display follows: 
sentence 
subject predicate 
noun predicate 
JANE predicate 
JANE verb object 
JANE SEES object 
JANE SEES noun opt_yarticiple 
JANE SEES SPOT opt_yarticiple 
JANE SEES SPOT participle 
JANE SEES SPOT RUN apply sentence~subject predicate to get: 
apply subject~noun to get: 
apply noun~JANE to get: 
apply predicate~verb object to get: 
apply verb~SEES to get: 
apply object~noun op_participle to get: 
apply noun~SPOT to get: 
apply opt_yarticiple~participle to get: 
apply participle~RVN to get: 
done-there are no more nonterminals to replace 
Page 11-Table 1.1, line 1 should read: statements~EOF. A replacement table follows: 
Table 1.1. A Simple Expression Grammar 
1. statements ~ EOF 
2. expression ; statements 
3. expression ~ expression + term 
4. term 
5. term ~ term *factor 
6. factor 
7. factor ~ number 
8. ( expression ) 
September 11, 1997 -11- Errata: Compiler Design in C 
110 *P++ 
September 11, 1997 Page 12-Figure 1.6. Replace the .figure with the following one: 
Figure 1.6. A Parse ofl+2 
statements 
------------ I --------- expression statements ~~ 
term expression' /1 /1~ l 
factor term' + term expression' 
I I I I 
1 factor 
I 
2 
Page 16-Listing 1.2, delete line 46. (Replace it with a blank line.) 
Page 18 -Replace the untitled table just under Listing 1.4 with the following (only the 
first line has been changed): 
1. statements ~ expression ; eoi 
2. expression ; statement 
3. expression ~ term expression' 
4. expression' ~ + term expression' 
5. £ 
6. term ~ factor term' 
7. term' ~ *factor term' 
8. £ 
9. factor ~ nom or id 
10. (expression) 
Page 24-Line 110 of Listing 1. 7 should read *P++ tok; 
tok; 
Page 26-Change the caption to Figure 1.11 as follows: 
Figure 1.11. A Subroutine Trace ofl+2*3+4 (Improved Parser) 
-12- Errata: Compiler Design in C 
Page 27-Change Line 42 of Listing 27 to tempvar2 term(); 
tempvar2 term(); 
Page 27-Replace the word temporary in the code part oflines 19, 26, and 42 of Listing 
1.9 with the word tempvar. These three lines should now read: 
19 tempvar = expression() 
26 freename( tempvar ) ; 
Page 36 -Replace Lines 16 and 17 of Listing 2.1 with the following (I've added a few 
parentheses): 
16 
17 #define get(stream) 
#define unget(c) (Pbackp < &Pbackbuf[SIZE] ? *Pbackp++ 
(Pbackp <= Pbackbuf ? -1 
Page 44-Replace line 186 of Listing 2.5 with the following line: 
1186 Next sMark eMark END -1; paMark NULL; getc(stream) 
(*--Pbackp= (c)) 
Page 55 -Eleven lines from bottom. The display that says ( [A a-z J I \en) should read as 
follows: 
( [Aa-z] I \n) 
Page 41-ModifY line 113 of Listing 2.3 to the following: 
1113 eMark END; pMark NULL; 
Page 46 -Replace lines 299 and 300 of Listing 2. 6 with the following lines: 
September 11, 1997 -13-Errata: Compiler Design in C 
299 
300 int need, 
got; 
September 11, 1997 /* Number of bytes required from input. */ 
/* Number of bytes actually read. */ 
Page 57-Line six should read as follows: 
causes a transition to State 1; from State 1, an e gets the machine to State 2, and an i ' 
Page 57 -Eleventh line from the bottom should read as follows: 
next state Transition_table[ current state J [ input_character J; 
Page 57 -Last line of second paragraph should read as follows (delete the ''s'r 
r, or e from State 0) are all implied transitions to a special implicit error state. ' 
Page 63-Listing 2.11, lines 2 and 3: remove the semicolons. 
Page 68 -The first line beneath the Figure should read as follows (the Figure and List­
ing numbers are wrong): 
table is shown in Figure 2.6 and in Listing 2.15. The Yy_cmap [J array is indexed by' 
Page 72 -The first display (second and third lines) should read as follows: 
[' 0', 2] 
[' 5', 2] [' 1', 2] 
[' 6', 2] [' 2', 2] 
[' 7', 2] [' 3 ', 2] 
[' 8', 2] [' 4', 2] 
[' 9', 2] [' e', 5] 
Page 73 -The first line of the third paragraph calls out the wrong line number. It should 
read as follows: 
The YYERROR() macro on line 151 of Listing 2.19 prints internal error messages. ' 
Page 73-First paragraph, lines two and four. Both references to Listing 2.18 should be 
to Listing 2.19. A replacement first paragraph follows: 
The remainder of lexyy.c file is the actual state-machine driver, shown in Listing 2.19 
The first and last part of this listing are the second and third parts of the Ctrl-L-delimited 
template file discussed earlier. The case statements in the middle (on lines 287 to 295 of 
Listing 2.19) correspond to the original code attached to the regular expressions in the 
input file and are generated by LeX itself. 
Page 76 -Listing 2.19, line 166. Some code is missing. Replace line 166 with the follow­
ing line: 
-14- Errata: Compiler Design in C 
1166 if( (c ii_input()) && (c != -1) ) 
Page 78-Listing 2.19, lines 292 and 294. Align the Fin FCON under the I in ICON (on 
line 288). 
Page 84 -Figure 2.13(e). The arrows should point from states 5 and 11 to state 13. Here 
is a replacement figure: 
Figure 2.13. Constructing an NF A for (D*\ .DID\ .D*) 
(a) 
(b) 2 
(c) 
(d) 
September 11, 1997 -15- Errata: Compiler Design in C 
Page 85 -Third line from the bottom (which starts "For example'') should read: 
For example, in a machine with a 16-bit int, the first two bytes of the string are the ' 
Page 86-Listing 2.21. Change the number 512 on line 28 to 768. 
768 
Page 91 -Change the definition of STACK_USED on line 93 of Listing 2.25 to 
( (int) (Sp-Sstack) +1). A replacement line follows: 
93 #define STACK_USED() ( (int) (Sp-Sstack) + 1 /* slots used *I 
Page 92-Change line 167 of Listing 2.25 to the following: 
167 if( textp >= (char *)strings + (STR_MAX-1) 
Page 95-Listing 2.26. Replace lines 280 to 283 with the following lines: 
280 *p = '\0'; /* Overwrite close brace. { */ 
281 if( ! (mac= (MACRO*) findsym( Macros, *namep )) ) 
282 parse err( E NOMAC ) ; 
283 *P++ = 7}'; /* Put the brace back. */ 
September 11, 1997 Page 104 -Second paragraph, first four lines (above the first picture) should read: 
Subroutines expr () and cat_expr () are in Listing 2.30. These routines handle the 
binary operations: I (OR) and concatenation. I'll show how expr ( ) works by watching 
it process the expression AlB. The cat_expr () call on line 621 creates a machine that 
recognizes the A: 
Page 121-Listing 2.38. Replace lines 218 to 255 with the following: 
-16- Errata: Compiler Design in C 
start_dfastate = newset(); /* 2 */ 
ADD( start_dfastate, sstate ) ; 
if( !e closure( start dfastate, &accept, &anchor) { - -
fprintf(stderr, "Internal error: State machine is empty\n"); 
exit (1); 
} 
current newset(); /* 3 */ 
ASSIGN( current, start_dfastate ) ; 
/* Now interpret the NFA: The next state is the set of all NFA states that 
* can be reached after we've made a transition on the current input 
* character from any of the NFA states in the current state. The current 
* input line is printed every time an accept state is encountered. 
* The machine is reset to the initial state when a failure transition is 
* encountered. 
*I 
while( c = nextchar() ) 
{ 
next= e_closure( move(current, c), &accept, &anchor); 
if( accept ) 
{ 
printbuf () ; 
if ( next ) ; 
del set ( next ) ; 
ASSIGN( current, /* accept 
/* reset 
start dfastate ) ; 
else 
{ /* keep looking */ 
delset( current ) ; 
current = next; *I 
*I 
delset( current ) ; /*Not required for main, but you'll */ 
delset( start dfastate ) ; /*need it when adapting main() to a*/ 
/* subroutine. */ 
#end if 
Page 122-First display, which starts with '£-closure({12}) ",should read as follows: 
£-closure({O}) = {0, 1, 3, 4, 5, 12} (new DF A State 0) 
Page 123 -Display on lines 6-9. Second line of display, which now reads '£­
closure({7,11}) = {9, 11, 13, 14}, "is wrong. The entire display should read as follows: 
DFriState 7 = {11} 
£-closure({11}) 
move({9, 11, 13, 14}, .) 
move({9, 11, 13, 14}, D) = {9, 11, 13, 14} 
=0 
= {11} (existing DFrt State 7) 
Page 124 -First line of second paragraph should read: 
The maximum number of DFA states is defined on line seven of Listing 39 to be ' 
September 11, 1997 -17- Errata: Compiler Design in C 
Page 129 -First line should say "Listing 2.41 ", not "Listing 2.40" Second line should 
say "line 119", not "line 23". The forth line should say "line 129", not "line 31". A 
replacement paragraph follows: 
Several support functions are needed to do the work, all in Listing 2.41 The 
add_to_dstates () function on line 119 adds a new DFA state to the Dstates array 
and increments the number-of-states counter, Nstates. It returns the state number (the 
index inDstates) ofthe newly added state. in_dstates () on line 139 ofListing 2.41 
is passed a set of NF A states and returns the state number of an existing state that uses 
the same set, or -1 if there is no such state. 
Page 129-Replace lines 147 and 148 of Listing 2.41 with the following: 
147 DFA STATE *end= &Dstates[Nstates]; 
148 for( p = Dstates ; p < end ; ++P ) 
Page 130-Replace lines 193 and 194 of Listing 2.41 with the following 
193 DFA_STATE *end= &Dstates[Nstates]; 
194 for( p = Dstates; p < end ; ++P ) 
Page 139 -Replace line 198 of Listing 2.44 with the following: 
1198 SET **end &Groups[Numgroups]; 
Replace Line 204 of Listing 139 with the following: 
204 for( current Groups; current < end; ++Current ) 
Page 140-Replace lines 229 and 230 of Listing 2.45 with the following 
229 SET **end= &Groups[Numgroups]; 
230 for( current = Groups; current < end; ++current ) 
September 11, 1997 -18- Errata: Compiler Design in C 
Page 152-Remove the #include "date. h" on line 3. 
Page 157 -Replace line 117 with the following (I've added the --argc on the left): 
117 for( ++argv, --argc; argc && *(p *argv) '-'; ++argv, --argc ) 
Page 167 -13th line from the bottom, "returns" should be "return." 
Page 167-Third line from the bottom. Change the second comma to a semicolon. 
Page 171 -Replace the first display (which now reads noun~timelbanana) with the fol­
lowing: 
noun ~ fruit I banana 
Page 173 -Second display, text to the right of the =L> is missing. It should read as fol­
lows: 
compound_stmt =L> LEFT CURLY stmt RIGHT CURLY - -=L> LEFT CURLY RIGHT CURLY - -
Page 173 -First line after second display, change expr~£ to stmt~£: The line should 
read: 
The application of stmt~£ effectively removes the nonterminal from the derivation by ' 
Page 173 -11th and 16th line from the bottom. Change CLOSE CURLY to 
RIGHT CURLY 
RIGHT CURLY RIGHT CURLY 
Page 175-Figure 3.2. The line that reads '4~DIGIT error" should read '4~DIGIT 
5. " 
5 
Page 177 -Listing 3.2, Line 12, should read: 
12 process_stmt( remember ) ; 
Page 178 -Third line below the one that starts with "Since" (next to the marginal note), 
replace "the the" with "the": All three lines should read: 
Since a decl_list can go to£, the list could be empty. Parse trees for left and right recur- Productions executed 
sive lists of this type are shown in Figure 3.5. Notice here, that the dec! list~£ first or last. 
September 11, 1997 -19- Errata: Compiler Design in C 
production is the first list-element that's processed in the left-recursive list, and it's the 
last' 
Page 179 -fourth line of second display, "declarator" should be "declarator _list". Line 
should read: 
declarator list TYPE declarator list 
Page 180 -Table 3.2. Grammatical rules for "Separator Between List Elements, Zero 
elements okay" row are wrong. Replace the table with the following one: 
Table 3.2. List Grammars 
No Separator 
Right associative Left associative 
At least one list ~ MEMBER list I MEMBER list ~ list MEMBER I MEMBER element 
Zero elements list ~ MEMBER list I £ list ~ list MEMBER I £ okay 
Separator Between List Elements 
Right associative Left associative 
At least one list ~ MEMBER delim list I MEMBER list ~ list delim MEMBER I MEMBER element 
Zero elements opt _list ~ list I £ opt _list ~ list I £ 
okay list ~ MEMBER delim list I MEMBER list ~ list delim MEMBER I MEMBER 
A MEMBER is a list element; it can be a terminal, a nonterminal, or a collection of terminals and nontermi-
nals. If you want the list to be a list of terminated objects such as semicolon-terminated declarations, 
MEMBER should take the form: MEMBER~ a TERMINATOR, where a is a collection of one or more termi-
nal or nonterminal symbols. 
September 11, 1997 Page 181 -Figure 3. 6. Change all "statements" to "stmt "for consistency. Also change 
"expression" to "expr ". A new figure follows: 
-20- Errata: Compiler Design in C 
Figure 3.6. A Parse Tree for 1+2* (3+4) +5; 
stmt 30 ~~ 
expr 28 ' 29 ~~~ 
expr 23 term 27 
~~~ I 
expr 4 + 5 term 22 factor 26 
I ~~~ I 
term 3 
I term 8 
I * 9 factor 21 5 25 
~~~ 
factor 2 
I factor 7 
I ( 10 expr 19 ) 20 
~~~ 
11 26 expr 14 
I term 18 
I 
factor 17 
I term13 
I 
factor 12 
I 
311 
Page 183 -Display at bottom of page. Remove the exclamation point. The expression 
should read: 
expr' ~ + term { op ( 1 + 1 ) ; } expr' 
Page 186 -Figure 3.8. Change caption to "Augmented parse tree for 1+2+3;" and 
change "statements" to "stmt ". A new figure follows: 
September 11, 1997 -21- Errata: Compiler Design in C 
Figure 3.8. Augmented Parse Tree for 1+2+3; 
~~ ~ 
factor3 term'5 +7 term13 {op("+") ;}14 ~~~ ~ 
num1 {create_tmp(yytext) ~ factor 10 term'12 
(!) ~I +15 term21 {op("+") ;}22 expr'24 ~I 
num8 {create_tmp(yytext) ;f}l'l factor 18 term'20 
(2) ~I 
num16 {create_ tmp (yytext) ; }ty9 
(3) 
Page 188 -The caption for Listing 3.4 should say "Inherited" (not "Synthesized'') 
"Attributes." A replacement caption follows: 
Listing 3.4. naive. c-Code Generation with Inherited Attributes 
September 11, 1997 Page 190 -First three lines beneath the figure (which start "right-hand side'') should 
read: 
right-hand side of the production, as if they were used in the subroutine. For example, 
say that an attribute, t, represents a temporary variable name, and it is attached to an 
expr; it is represented like this in the subroutine representing the expr: 
Page 196-Figure 4.1. both instances of the word "number" should be in boldface. 
number number 
Page 208 -Third and eighth lines change "automata" to "automaton". Replacement 
lines: 
solution is a push-down automaton in which a state machine controls the activity on the ' 
The tables for the push-down automaton used by the parser are relatively straightfor-
-22- Errata: Compiler Design in C 
Page 210-Figure 4.6, Yy _d [factor] [LP] should be "9," not "8." 
9 
Page 213 -First Paragraph, add SEMICOLON to the list on the third line. A replace­
ment paragraph follows. 
Production 1 is applied if a statement is on top of the stack and the input symbol is an 
OPEN_CURLY. Similarly, Production 2 is applied when a statement is on top of the 
stack and the input symbol is an OPEN_PAREN, NUMBER, SEMICOLON, or IDEN­
TIFIER (an OPEN_PAREN because an expression can start with an OPEN_PAREN 
by Production 3, a NUMBER or IDENTIFIER because an expression can start with a 
term, which can, in turn, start with a NUMBER or IDENTIFIER. The situation is com­
plicated when an expression is on top of the stack, however. You can use the same rules 
as before to figure out whether to apply Productions 3 or 4, but what about the £ produc­
tion (Production 5)? The situation is resolved by looking at the symbols that can follow 
an expression in the grammar. If expression goes to £, it effectively disappears from the 
current derivation (from the parse tree)-it becomes transparent. So, if an expression is 
on top of the stack, apply Production 5 if the current lookahead symbol can follow an 
expression (if it is a CLOSE_ CURLY, CLOSE_PAREN, or SEMICOLON). In this 
last situation, there would be serious problems if CLOSE_CURLY could also start an 
expression. The grammar would not be LL(l) were this the case. 
Page 213 -Last six lines should be replaced with the following seven lines. 
ones. Initially, add those terminals that are at the far left of a right-hand side: 
FIRST(stmt) 
FIRST(expr) FIRST( expr') 
FIRST( term) 
FIRST( term') 
FIRST( factor) { } 
{£} 
{PLUS, c} 
{ } 
{TIMES, c} 
{LEFT_PAREN, NUMBER} 
Page 214-Remove the .first line beneath Table 4.14 [which starts 'FIRST(factor) '1-
Page 214-Table 4.13, item (3), third line. Replace 'is are" with 'are." A replacement 
table follows: 
September 11, 1997 -23- Errata: Compiler Design in C 
Table 3.3. Finding FIRST Sets 
(1) FIRST(A), where A is a terminal symbol, is {A}. If A is £,then £is put into the FIRST set. 
(2) Given a production of the form 
s~Aa 
where sis a nonterminal symbol, A is a terminal symbol, and a is a collection of zero or more ter­
minals and nonterminals, A is a member ofFIRST(s). 
(3) Given a production of the form 
s~ba 
where sand b are single nonterminal symbols, and a is a collection of terminals and nontermi­
nals, everything in FIRST(b) is also in FIRST(s). 
This rule can be generalized. Given a production of the form: 
s~aB~ 
where s is a nonterminal symbol, a is a collection of zero or more nullable nonterminals, t B is a 
single terminal or nonterminal symbol, and ~ is a collection of terminals and nonterminals, then 
FIRST(s) includes the union ofFIRST(B) and FIRST( a). For example, if a consists of the three 
nullable nonterminals x, y, and z, then FIRST(s) includes all the members ofFIRST(x), FIRST(y), 
and FIRST(z), along with everything in FIRST( B). 
t A nonterminal is nullable if it can go to £ by some derivation. £ is always a member of a nullable 
nonterminal's FIRST set. 
September 11, 1997 Page 214-This is a change that comes under the "should be explained better" category 
and probably won't make it into the book until the second edition. It confuses the issue a 
bit to put£ into the FIRST set, as per rule (1) in Table 4.13. (In fact, you could argue that 
it shouldn't be there at all.) I've put £ into the FIRST sets because its presence makes it 
easier to see if a production is null able (it is if£ is in the FIRST set). On the other hand, 
you don't have to transfer the £ to the FOLLOW set when you apply the rules in Table 
4.15 because £ serves no useful purpose in the FOLLOW set. Consequently, £ doesn't 
appear in any of the FOLLOW sets that are derived on pages 215 and 216. 
Page 214-Bottom line and top of next page. Add£ to FIRST(expr), FIRST(expr'), and 
FIRST(term'). A replacement display, which replaces the bottom two lines ofpage 214 
and the top four lines of page 215, follows: 
FIRST(stmt) 
FIRST(expr) FIRST( expr') 
FIRST( term) 
FIRST( term') 
FIRST( factor) {LEFT_PAREN, NUMBER, SEMI} 
{LEFT_PAREN, NUMBER, c} 
{PLUS, c} 
{LEFT_PAREN, NUMBER} 
{TIMES, c} 
{LEFT_PAREN, NUMBER} 
Page 216-Add the following sentence to the end of item (2): 
Note that, since £serves no useful purpose in a FOLLOW set, it does not have to be 
transfered from the FIRST to the FOLLOW set when the current rule is applied A 
replacement table follows: 
-24- Errata: Compiler Design in C 
Table 3.4. Finding FOLLOW Sets 
(1) If sis the goal symbol, eoi (the end-of-input marker) is in FOLLOW(s); 
(2) Given a production of the form: 
s~ ... aB ... 
where a is a nonterminal and B is either a terminal or nonterminal, FIRST(B) is in FOLLOW( a); 
To generalize further, given a production of the form: 
s~ ... aaB ... 
where sand a are nonterminals, a is a collection of zero or more nullable nonterminals and B is 
either a terminal or nonterminal. FOLLOW( a) includes the union of FIRST( a) and FIRST(B). 
Note that, since £serves no useful purpose in a FOLLOW set, it does not have to be transfered 
from the FIRST to the FOLLOW set when the current rule is applied. 
(3) Given a production of the form: 
s~ ... a 
where a is the rightmost nonterminal on the right-hand side of a production, everything in 
FOLLOW(s) is also in FOLLOW(a). (I'll describe how this works in a moment.) To generalize 
further, given a production of the form: 
s~ ... aa 
where s and a are nonterminals, and a is a collection of zero or more nullable nonterminals, 
everything in FOLLOW(s) is also in FOLLOW( a). 
Page 217-Grammar in the middle of the page. Delete the pk and adm at the right edges 
of Productions 1 and 2. 
Page 218-Move the last line of page 217 to the top of the current page to eliminate the 
orphan. 
Page 218-Table 4.16, Replace the table with the following one (I've made several small 
changes). You may also want to move the widow at the top of the page to beneath the 
table while you're at it. 
September 11, 1997 -25- Errata: Compiler Design in C 
Table 4.16. Finding LL(l) Selection Sets 
(1) A production is nul/able if the entire right-hand side can go to c. This is the case, both when the 
right-hand side consists only of c, and when all symbols on the right-hand side can go to c by 
some derivation. 
(2) For nonnullable productions: Given a production of the form 
s~aB ... 
where s is a nonterminal, a is a collection of one or more nullable nonterminals, and B is either a 
terminal or a nonnullable nonterminal (one that can't go to c) followed by any number of addi­
tional symbols: the LL(l) select set for that production is the union of FIRST( a) and FIRST( B). 
That is, it's the union of the FIRST sets for every nonterminal in a plus FIRST( B). If a doesn't 
exist (there are no nullable nonterminals to the left of B), then SELECT(s)=FIRST(B). 
(3) For nullable productions: Given a production of the form 
s~a 
where sis a nonterminal and a is a collection of zero or more nullable nonterminals (it can be c): 
the LL(l) select set for that production is the union of FIRST( a) and FOLLOW(s). In plain 
words: if a production is nullable, it can be transparent-it can disappear entirely in some deriva­
tion (be replaced by an empty string). Consequently, if the production is transparent, you have to 
look through it to the symbols that can follow it to determine whether it can be applied in a given 
situation. 
September 11, 1997 Page 223-Replace the last two lines on the page as follows: 
Ambiguous productions, such as those that have more than one occurrence of a given 
nonterminal on their right-hand side, cause problems in a grammar because a unique 
parse tree is not generated for a given input. As we've seen, left factoring can be used to 
Page 224 -The sentence on lines 13 and 14 (which starts with "If an ambiguous'') 
should read as follows: 
If an ambiguous right-hand side is one of several, then all of these right-hand sides 
must move as part of the substitution. For example, given: 
Page 228-8th line from the bottom, the "Y" in "You" should be in lower case. 
you can use a corner substitution to make the grammar self-recursive, replacing the ' 
Page 222-First line of text should read "Figures 4.5 and 4.6" rather than "Figure 4.6" 
A replacement paragraph follows: 
4.5 are identical in content to the ones pictured in Figures 4.5 and 4.6 on page 210. Note 
that the Yyd table on lines 179 to 184 is not compressed because this output file was gen­
erated with the -f switch active. Were -f not specified, the tables would be pair 
compressed, as is described in Chapter Two. The yy _act () subroutine on lines 199 to 
234 contains the switch that holds the action code. Note that$ references have been 
translated to explicit value-stack references (Yy _ vsp is the value-stack pointer). The 
Yy _ synch array on lines 243 to 248 is a -!-terminated array of the synchronization 
tokens specified in the %synch directive. 
-26- Errata: Compiler Design in C 
Page 237-The loop control on line 377 of Listing 4.6 won't work reliably in the 8086 
medium or compact models. Replace lines 372-384 with the following: 
372 
373 
374 
375 
376 
377 
378 
379 
380 
381 
382 
383 
384 int nterms; /* # of terms in the production */ 
start = Yy_pushtab[ production ] ; 
for( end = start; *end; ++end ) /* After loop, end is positioned*/ 
/* to right of last valid symbol */ 
count = sizeof(buf); 
*buf = '\0'; 
for(nterms = end -start; --nterms >= 0 && 
/* string. 
yy_sym(*--end), count); 
strlen( yy_sym(*end) + 1 )) < { 
strncat( buf, 
if ( (count -= 
break; 
strncat( buf, " ", --count ) ; 
} count > 0 
*I 
1 ) 
Page 242-Pieces of the section heading for Section 4.9.2 are in the wrong font, and the 
last two lines are messed up. Replace with the following: 
4.9.2 Occs and Llama Debugging Support-Y.Ydebug.c 
This section discusses the debug-mode support routines used by the llama-generated 
parser in the previous section. The same routines are used by the occs-generated parser 
discussed in the next chapter. You should be familiar with the interface to the curses, 
window-management functions described in Appendix A before continuing. 
Page 255 -Fourth line beneath the listing (starting with "teractive mode''), replace 
comma following the close parenthesis with a period The line should read: 
teractive mode (initiated with ann command). In this case, a speedometer readout that ' 
Page 271-303 -Odd numbered pages. Remove all tildes from the running heads. 
Page 274 -Add the statement looking_for_brace = 0; between lines 179 and 180. 
Do it by replacing lines 180-190 with the following: 
180 
181 
182 
183 
184 
185 
186 187 
188 
189 
190 } else 
{ looking_for_brace 0; 
if( c 
else '%' ) looking_for_brace 
output( "%c", c ) ; 
return CODE_BLOCK; 1· ' /* Assemble */ 
September 11, 1997 -27- Errata: Compiler Design in C 
Page 278-Fifth line from bottom. Replace { create_tmp (yytext);} with the follow­
ing (to get the example to agree with Figure 4.9): 
{rvalue(yytext) ;} 
Page 282 -The last paragraph should read as follows (the Listing and Table numbers 
are wrong): 
The recursive-descent parser for LLama is in Listing 4.25. It is a straightforward 
representation ofthe grammar in Table 4.19. 
Page 312 -Listing 4.30. Replace lines 60 to 63 with the following: 
60 PRIVATE int *Dtran; /* Internal representation of the parse table. 
61 * Initialization in make_yy_dtran() assumes 
62 * that it is an int [it calls memiset () 1. 
63 */ 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 nterms 
nnonterms Page 315-Listing 4.30. Replace lines 231 to 240 with the following: 
USED_TERMS + 1; 
USED_NONTERMS; /* +1 for EOI */ 
i = nterms * nnonterms; /* Number of cells in array */ 
if( ! (Dtran = (int *) malloc(i * sizeof(*Dtran)) )) /*number of bytes*/ 
ferr("Out of memory\n"); 
memiset( Dtran, -1, i ) ; 
ptab( Symtab, fill_row, NULL, 0 ) ; /* Initialize Dtran to all failures */ 
/* and fill nonfailure transitions. */ 
Page 330-Listing 4.34, line 464. Delete everything except the line number. 
Page 330 -Last two lines of second paragraph should read as follows: 
bottom-up parse tables are created, below. Most practical LL(l) grammars are also 
LR(l) grammars, but not the other way around. 
Page 330-Add the right-hand side "I NUMBER" to the grammar in exercise 4.5. Also, 
align the table in Exercise 4.5 under the text so that it no longer extends into the gutter. 
September 11, 1997 -28- Errata: Compiler Design in C 
expr ~ -expr 
* expr 
expr * expr 
expr I expr 
expr= expr 
expr+ expr 
expr-expr 
( expr) 
NUMBER 
Page 349-Replace Table 5.5 with the following table: 
Table 5.5. Error Recovery for 1++2 
Stack Input 
state: -
1- 1 + + 2 parse: -
state: 0 1-$ 1 + + 2 parse: 
state: 0 1 1-$ NUM + + 2 parse: 
state: 0 3 1-$ !T + + 2 parse: 
state: 0 2 1-$ !E + + 2 parse: 
state: 0 2 4 1-$ !E !+ + 2 parse: 
state: 0 2 1-$ !E + 2 parse: 
state: 0 2 1-$ !E + 2 parse: 
state: 0 2 4 1-$ !E !+ 2 parse: 
state: 0 2 4 1 1-$ !E !+ NUM 2 parse: 
state: 0 2 4 1 1-parse: $ !E !+ NUM 
state: 0 2 4 5 1-parse: $ !E !+ !T 
state: 0 2 1-parse: $ !E Comments 
Shift start state 
Shift NUM (goto 1) 
Reduce by Production 3 (IT ~NUM) 
(Return to 0, goto 3) 
Reduce by Production 2 (IE~ II) 
(Return to 0, goto 2) 
Shift I+ (goto 4) 
ERROR (no transition in table) 
Pop one state from stack 
There is a transition from 2 on I+ 
Error recovery is successful 
Shift I+ (goto 4) 
Shift NUM (goto 1) 
Shift NUM (goto 1) 
Reduce by Production 3 (IT ~NUM) 
(Return to 4, goto 5) 
Reduce by Production 1 (IE~IEI+II) 
(Return to 0, goto 2) 
Accept 
Page 360 -Figure 5. 6. The item immediately below the line in State 7 (ie. the first clo­
sure item) should be changedfrom IE~.IEI*IFto IT~.ITI*IF 
!T--+. !T ! • !F 
September 11, 1997 -29- Errata: Compiler Design in C 
Some symbols in 
FOLLOW set are not 
needed. 
Lookahead set. 
[!S--+a !. x [3, C]. 
September 11, 1997 Page 361 -Third paragraph of section 5.6.2 (which starts "The FOLLOW''). Replace 
the paragraph with the following one: 
The FOLLOW sets for our current grammar are in Table 5.6. Looking at the 
shift/reduce conflict in State 4, FOLLOW(! E) doesn't contain a ! *, so the SLR(l) method 
works in this case. Similarly, in State 3, FOLLOW(s) doesn't contain a !+, so 
everything's okay. And finally, in State 10, there is an outgoing edge labeled with a!*, 
but FOLLOW(!E) doesn't contain a !*. Since the FOLLOW sets alone are enough to 
resolve the shift/reduce conflicts in all three states, this is indeed an SLR(l) grammar. 
Page 361 -First paragraph in section 5.6.3 (which starts "Continuing our quest''). 
Replace the paragraph with the following one: 
Many grammars are not as tractable as the current one-it's likely that a FOLLOW 
set will contain symbols that also label an outgoing edge. A closer look at the machine 
yields an interesting fact that can be used to solve this difficulty. A nonterminal's FOL­
LOW set includes all symbols that can follow that nonterminal in every possible context. 
The state machine, however, is more limited. You don't really care which symbols can 
follow a nonterminal in every possible case; you care only about those symbols that can 
be in the input when you reduce by a production that has that nonterminal on its left­
hand side. This set of relevant lookahead symbols is typically a subset of the complete 
FOLLOW set, and is called the lookahead set. 
Page 362 -Ninth line from bottom. Delete 'only. "A replacement for this, and the follow­
ingfour lines follows: 
The process of creating an LR(l) state machine differs from that used to make an 
LR(O) machine only in that LR(l) items are created in the closure operation rather than 
LR(O) items. The initial item consists of the start production with the dot at the far left 
and 1-as the lookahead character. In the grammar we've been using, it is: 
Page 362 -Last line. Delete the period The line should read: x~y 
Page 363-The Cis in the wrongfont in both the first marginal note and the first display 
(on the third line). It should be in Roman. 
[x~!.y, FIRST(~ C)]. 
Page 363 -Ninth line from bottom. Replace 'new machine" with 'new states. "A replace­
ment paragraph follows: 
The process continues in this manner until no more new LR(l) items can be created. 
The next states are created as before, adding edges for all symbols to the right of the dot 
and moving the dots in the kernel items of the new states. The entire LR(l) state 
machine for our grammar is shown in Figure 5.7. I've saved space in the Figure by 
merging together all items in a state that differ only in lookaheads. The lookaheads for 
all such items are shown on a single line in the right column of each state. Figure 5.8 
-30- Errata: Compiler Design in C 
shows how the other closure items in State 0 are derived. Derivations for items in States 
2 and 14 ofthe machine are also shown. 
Page 364 -Figure 5. 7. About 3 inches from the left of the figure and 1"14 inches from the 
bottom, a line going from the box marked 2 to a circle with a B in it is currently labeled 
"t e fNVM (. "Delete the e. 
Page 365 -The fourth line below Figure 5. 7 should read: 
best ofboth worlds. Examining the LR(l) machine in Figure 5.7, you are inunediately ' 
Page 365 -Figure 5. 7 (continued). The upper-case F in the second item of State 16 
should be lower case. 
!T---+. !T !* !F 
Page 366 -First and third line under the Figure. The figure numbers are called out 
incorrectly in the text. The first three lines beneath the figure should read: 
parenthesis first. The outer part of the machine (all of the left half of Figure 5. 7 except 
States 6 and 9) handles unparenthesized expressions, and the inner part (States 6 and 9, 
and all of the right half of Figure 5.7) handles parenthesized subexpressions. The parser 
Page 370-Listing 5.2, line 14. Change the sentence "Reduce by production n" 
to read as follows (leave the left part of the line intact): 
Reduce by production n, n == -action. 
Page 371 -Listing 5.2, line 16. Change the sentence "Shift to state n" to read as 
follows (leave the left part of the line intact): 
Shift to state n, n == action. 
Page 373-Listing 5.4, line 6. Remove the yy in yylookahead The corrected line looks 
like this: 
6 do this yy_next( Yy_action, state_at_top_of_stack(), lookahead); 
Page 373 -Listing 5.4, line 29. Change rhs_len to rhs_length. The corrected line 
looks like this: 
September 11, 1997 -31- Errata: Compiler Design in C 
29 while( --rhs_length >= 0 ) /* pop rhs_length items */ 
Page 373-Last line. Change to read as follows (the state number is wrong): 
shifts to State 1, where the only legal action is a reduce by Production 6 if the next input 
Page 374-Paragraph beneath table, replace "you you" on third line with "you". Entire 
replacement paragraph follows: 
There's one final caveat. You cannot eliminate a single-reduction state if there is a 
code-generation action attached to the associated production because the stack will have 
one fewer items on it than it should when the action is performed-you won't be able to 
access the attributes correctly. In practice, this limitation is enough of a problem that 
occs doesn't use the technique. In any event, the disambiguating rules discussed in the 
next section eliminate many of the single-reduction states because the productions that 
cause them are no longer necessary. 
Page 387 -Listing 5.11, line 107. Add the word short. The repaired line looks like this: 
107 #define YYF ( (YY_TTYPE) ( (unsigned short) -o »1 ) ) 
September 11, 1997 Page 388 -Second paragraph, third and fourth lines. Change "the largest positive 
integer" to "to the largest positive short int." and remove the following "I'm." The 
repaired lines read as follows: 
subroutine, yy_act_next (),which I'll discuss in a moment.) It evaluates to the largest 
positive short int (with two's complement numbers). Breaking the macro down: ' 
Page 390-Listing 5.12, line 199. Change the sentence "Reduce by production 
n" to read as follows (leave the left part of the line intact): 
Reduce by production n, n == -action. 
Page 390 -Listing 5.2, line 201. Change the sentence "Shift to state n" to read 
as follows (leave the left part of the line intact): 
Shift to state n, n == action. 
Page 397-Replace line 209 of Listing 5.14 with the following: 
-32- Errata: Compiler Design in C 
209 YYD ( yycomment ("Popping %s from state stack\n", tos); ) 
Page 398 -Listing 5.14, lines 219-222. Replace with the following code: 
219 
220 # 
221 
222 Yy_vsp = Yy_vstack + (YYMAXDEPTH- yystk_ele(Yy_stack)) 
ifdef YYDEBUG 
yystk_p(Yy_dstack) = Yy_dstack + 
(YYMAXDEPTH- yystk_ele(Yy_stack)); 
Page 403 -The loop control on Line 128 of Listing 5.15 doesn't work reliably in the 
8086 compact or large model. To fix it, replace Line 97 of Listing 5.15 (p. 403) with the 
following (and also see change for next page): 
97 int i 
Page 404 -Replace line 128 of Listing 5.15 with the following: 
1128 for(i (pp -prod->rhs) + 1; --i >= 0; --pp ) 
Page 425-Lines 585-594. Replace with the following code: 
if( nclose ) 
{ 585 
586 
587 
588 
589 
590 
591 
592 
593 
594 assort( closure items, nclose, sizeof(ITEM*), item_cmp ) ; 
nitems move_eps( cur_state, closure_items, nclose ) ; 
p closure items + nitems; 
nclose nitems ; 
if( Verbose > 1 ) 
pclosure( cur_state, p, nclose ) ; 
Page 440 -Listing 5.33, replace the code on lines 1435 to 1438 with the following (be 
sure that the quote marks on the left remain aligned with previous lines): 
September 11, 1997 -33- Errata: Compiler Design in C 
1435 
1436 
1437 
1438 action < 0 Reduce by production n, n ---action.", 
action 0 Accept. (ie. Reduce by production 0 •) II I 
action > 0 Shift to state n, n --action.", 
action YYF error. II 
' 
Page 447 -Line 14. Change "hardly every maps" to "hardly ever maps'~ The line should 
read: 
ideal machine hardly ever maps to a real machine in an efficient way, so the generated ' 
Page 452-First line below Listing 6.2. Change "2048" to "1024". Line should read: 
In addition to the register set, there is a 1024-element, 32-bit wide stack, and two ' 
Page 453 -Figure 6.1. Around the middle of the figure. Change "2048" to "1024 ". 
Line should read: 
1,024 
32-bit 
!words 
Page 466-Listing 6.11, lines 53 and 54, change sp to __ sp (two underscores). 
53 #define push(n) 
54 #define pop ( t) (--__ sp)->1 = (lword)(n) 
(t) ( ( __ BP++) ->1 ) 
Page 471 -Ninth line. Replace with fp+4 with fp+l6. Replace the last four lines of the 
paragraph with the following lines: 
call ( l subroutine modifies wild, it just modifies the memory location at fp+l6, and on 
the incorrect stack, ends up modifying the return address of the calling function. This 
means that call() could work correctly, as could the calling function, but the program 
would blow up when the calling function returned. 
Page 475 -Listing 6.19, Line 80. Replace the first (b l with a ( s l . The line should now 
read: 
80 #define BIT(b,s) if ( (s) & (1 « (b)) ) 
September 11, 1997 Page 486 -Replace last line of first paragraph (which now reads '6.1 0 '') with the follow­
ing: 
6.11. 
-34- Errata: Compiler Design in C 
Page 494-Listing 6.25, replace lines 129-142 with the following: 
129 #define IS_SPECIFIER(p) ( (p) && (p)->class==SPECIFIER) 
130 #define IS_DECLARATOR(p) ( (p) && (p)->class==DECLARATOR) 
131 #define IS_ARRAY(p) ( (p) && (p)->class==DECLARATOR && (p)->DCL_TYPE==ARRAY 
132 #define IS_POINTER(p) ( (p) && (p)->class==DECLARATOR && (p)->DCL_TYPE==POINTER 
133 #define IS_FUNCT(p) ( (p) && (p)->class==DECLARATOR && (p)->DCL_TYPE==FUNCTION) 
134 #define IS_STRUCT(p) ( (p) && (p)->class==SPECIFIER && (p) ->NOUN 
135 #define IS_LABEL(p) ( (p) && (p)->class==SPECIFIER && (p)->NOUN == 
136 
137 #define IS_CHAR(p) ( (p) && (p)->class ==SPECIFIER && (p) ->NOUN 
138 #define IS_INT(p) ( (p) && (p)->class ==SPECIFIER && (p) ->NOUN 
139 #define IS_UINT(p) IS_INT(p) && (p) ->UNSIGNED ) 
140 #define IS_LONG(p) ( IS_INT(p) && (p) ->LONG 
141 #define IS_ULONG(p) IS_INT(p) && (p) ->LONG && (p)->UNSIGNED 
142 #define IS_UNSIGNED(p) ( (p) && (p) ->UNSIGNED ) 
Page 496-Figure 6.13. All of the link structures that are labeled SPECIFIER should be 
labeled DECLARATOR and vice versa. The corrected figure follows: STRUCTURE ) 
LABEL ) 
CHAR 
INT 
September 11, 1997 -35- Errata: Compiler Design in C 
Figure 6.13. Representing a Structure in the Symbol Table 
Symbol tab symbol: -
~ name "gipsy" link: link: 
rna me "_gipsy" 
I I class SPECIFIER class SPECIFIER type next NULL next NULL next ' select: select: 
v noun STRUCT noun !NT 
class FIXED class FIXED 
to next variable at this level is_long 0 is_long 0 
s _unsigned 0 _unsigned 0 
truct tab structdef: value f value 0 --tag 11argotiers11 ) size 52 / ' ields f link: link: 
symbol ~ class DECLARATOR I class I DECLARATOR I 
next next 
name "Clopin" select select 
level 0 class I POINTER 
I class I FUNCTION 
I type num ele num ele - -
next f 
symbol ~ link: 
class DECLARATOR I link: name "Mathias" 
level 4 next class SPECIFIER 
type select next NULL 
~~RAY I next f class select: 
~ num ele ==c symbol class -
is_long 1 
name ••Guillaume•• link: _unsigned 1 
level 44 
DECLARATOR I value 0 
type class 
next next f 
symbol ~ select I 
I link: class POINTER 
num ele 
name 11Pierre11 ~ class SPECIFIER 
level 48 link: next NULL 
--select: type 
-------:?> next NULL class SPECIFIER noun STRUCT 
next NULL class -
select: is_long 0 
noun STRUCT _unsigned 0 
structdef: class - value 
is_long 0 
tag "pstruct" _unsigned 0 link: size 2 
~ value f -Fields f ) class SPECIFIER 
~ next NULL 
symbol eelee~=c 
name a class -
level 0 is long o 
type ' _unsigned 0 
next NULL value 0 
September 11, 1997 -36- Errata: Compiler Design in C 
Page 500 -First sentence below figure should start "The subroutine" 
The subroutine in Listing 6.29 manipulates declarators: add_declarator () adds 
Page 503-Listing 6.31, line 281, should read as follows: 
281 (pl->DCL_TYPE==ARRAY && (pl->NUM_ELE != p2->NUM_ELE)) ) 
Page 520-Replace line 71 of Listing 6.37 with the following line: 
71 ('.')I('\\.') I ('\\{o} ({o}{o}?l?') I ('\\x{h} ({h}{h}?l?') 
Replace line 76 of Listing 6.37 with the following line: 
76 ({d}+l{d}+\.{d}*l{d}*\.{d}+l ([eE] [\-+J?{d}+)?[fF]? return FCON 
Page 521-Listing 6.37, Lines 138-143. Replace as follows: 
138 typedef struct /* Routines to recognize keywords. A table */ 
139 { /* lookup is used for this purpose in order to */ 
140 char *name; /* m~n~m~ze the number of states in the FSM. A */ 
141 int val; /* KWORD is a single table entry. */ 
142 
143 KWORD; 
Page 524 -Second line of last paragraph, remove period after TYPE and change "List­
ing 6.38" to Listing 6.39. The repaired line should read as follows: 
reduces type_specifier~TYPE (on line 229 of Listing 6.39). The associated action ' 
Page 527 -First line below Listing 6.40. Change "Listing 6.40" to Listing 6.39. The 
repaired line should read as follows: 
216 to 217 ofListing 6.39.) There are currently three attributes of interest: $1 and$$' 
September 11, 1997 -37- Errata: Compiler Design in C 
Page 553-Listing 6.56, line 10. Change LO to (L0*4). 
10 #define T (n) (fp-(L0*4)- (n*4)) 
539 
578 
579 
580 
581 
582 Page 556-Listing 6.58, line 539. Change %s to (%s*4) 
yycode( "#define T(n) (fp-(%s*4)-(n*4))\n\n", Vspace); 
Page 558-Listing 6.60, lines 578-582. Replace with the following: 
discard_link_chain(existing->type); /* Replace existing type */ 
existing->type = sym->type; /* chain with the current one.*/ 
existing->etype = sym->etype; 
sym->type = sym->etype = NULL; /* Must be NULL for discard -*/ 
/*symbol() call, below. */ 
Page 558-Listing 6.60, lines 606 and 607. i is not used and the initial offset should be 8. 
Replace lines 606 and 607 with the following: 
606 
607 int offset= 8; /*First parameter is always at BP(fp+B): *I 
578 
579 
580 LC 
September 11, 1997 /* 4 for the old fp, 4 for the return address. */ 
Page 560-Page 560, Listing 6.61. Replace lines 578-580 with the following: 
if( ++Nest_lev 
loc_reset (); 1 ) 
Page 573 -Fifth line from the bottom. Insert a period after "needed". The line should 
read: 
needed. The stack is shrunk with matching additions when the variable is no longer ' 
Page 574-Figure 6.18, the LOin the #define T (n) should be (L0*4). 
#define T (n) (fp-(L0*4)- (n*4)) 
-38- Errata: Compiler Design in C 
Page 578 -First paragraph. There's an incomplete sentence on the first line. Replace 
with the following paragraph and add the marginal note: 
The cell is marked as "in use" on line 73. The Region element corresponding to the 
first cell of the allocated space is set to the number of stack elements that are being allo­
cated. If more than one stack element is required for the temporary, adjacent cells that 
are part of the temporary are filled with a place marker. Other subroutines in Listing 
6.64 de-allocate a temporary variable by resetting the equivalent Region elements to 
zero, de-allocate all temporary variables currently in use, and provide access to the 
high-water mark. You should take a moment and review them now. 
Page 590 -Listing 6. 69, line 214. Replace with the following: 
I 214 case CHAR: return BYTE_PREFIX; 
Page 598-Third paragraph, second line (which starts "type int for"), replace line with 
the following one: 
type int for the undeclared identifier (on line 62 of Listing 6.72). The ' 
Page 601 -First line beneath Listing 6. 76. Replace "generate" with "generated": 
So far, none of the operators have generated code. With Listing 6.77, we move ' 
Page 607-Listing 6.84, line 328: Change the II to an&&. 
328 if( !IS_INT(offset->type) && !IS_CHAR(offset->type) ) 
Page 608 -Fonts are wrong in all three marginal notes. Replace them with the ones 
given here. 
Page 613 -First line of last paragraph is garbled Since the fix affects the entire para­
graph, an entire replacement paragraph follows. Everything that doesn't fit on page 613 
should be put at the top of the next page. Marking a stack cell as 
'in use". 
Operand to • or [J must 
be array or pointer. 
Attribute synthesized by • 
and [J operators. 
Rules for forming lvalues 
and rvalues when 
processing • and [J. 
September 11, 1997 -39- Errata: Compiler Design in C 
call() 
unaty---+NAME 
543 
I 690 
I 709 
September 11, 1997 The call () subroutine at the top of Listing 6.87 generates both the call instruction 
and the code that handles return values and stack clean up. It also takes care of implicit 
subroutine declarations on lines 513 to 526. The action in unary~ NAME creates a sym­
bol of type int for an undeclared identifier, and this symbol eventually ends up here as 
the incoming attribute. The call() subroutine changes the type to "function returning 
int" by adding another link to the head of the type chain. It also clears the implicit 
bit to indicate that the symbol is a legal implicit declaration rather than an undeclared 
variable. Finally, a C-code extern statement is generated for the function. 
Page 617-Listing 6.87, line 543. Replace nargs with nargs * SWIDTH. 
gen( "+=%s%d" , "sp", nargs * SWIDTH ) ; /* sp is a byte pointer, */ 
Page 619-Listing 6.88, line 690. Delete the->name. The repaired line should look like 
this: 
gen( "EQ", rvalue( $1 ) , "0" ) ; 
Disk only. Page 619, Listing 6.88. Added semantic-error checking to first (test) clause 
in?: operator. Tests to see if its an integral type. Insert the following between lines 689 
and 690: 
if( !IS_INT($1->type) ) 
yyerror("Test in ?: must be integral\n"); 
Page 619-Listing 6.88. Replace line 709 with the following line: 
gen( n_n 
-' $$->name, rvalue($7) ) ; 
Page 644 -Lines 895 and 896. There is a missing double-quote mark on line 895, inser­
tion of which also affects the formatting on line 896. Replace lines 895 and 896 with the 
following: 
-40- Errata: Compiler Design in C 
895 
896 gen ( "goto%s%d", L_BODY, $5 ) ; 
gen(":%s%d", L_INCREMENT, $5 ) ; 
Page 648-Listing 6.107, line 1, change the 128 to 256. 
#define CASE MAX 256 /* Maximum number of cases in a switch */ 
Page 649-Listing 6.108. Add the following two lines between lines 950 and 951: (These 
lines will not have numbers on them, align the first p in pop with the g in gen _stab ... on 
the previous line.) 
pop ( S_brk ) ; 
pop( S brk label ) ; 
Page 658 -First paragraph of section 7.2.1 should be replaced with the following one: 
A strength reduction replaces an operation with a more efficient operation or series 
of operations that yield the same result in fewer machine clock cycles. For example, 
multiplication by a power of two can be replaced by a left shift, which executes faster on 
most machines. (x*8 can be done with x«3.) You can divide a positive number by a 
power of two with a right shift (x/8 is x»3 ifx is positive) and do a modulus division by 
a power of two with a bitwise AND (x% 8 is x& 7 ). 
Page 671 -Figure 7.1, third subfigure from the bottom. In initial printings, the asterisk 
that should be at the apex of the tree had dropped down about ~ inch. Move it up in 
these printings. In later printings, there are two asterisks. Delete the bottom one. 
Page 681 -Listing A.1, lines 19 and 20 are missing semicolons. Change them to the fol­
lowing: 
19 typedef long time_t; /* for the VAX, may have to change this */ 
20 typedef unsigned size_t; /* for the VAX, may have to change this */ 
Page 682 -Listing A. I, line 52. Delete all the text on the line, but leave the asterisk at 
the far left. 
Page 688-6th line from the bottom. Remove "though" at start of line. 
it might introduce an unnecessary conversion if the stack type is an int, short, or char. 
These multiple type conversions will also cause portability problems if the 
September 11, 1997 -41- Errata: Compiler Design in C 
stack_ err () macro evaluates to something that won't fit into a long (like a double). 
Page 690 -Last line, "calling conventions" should not be hyphenated 
Page 696-Listing A.4, line 40. The comment is wrong. The line should read as follows: 
40 #define DIFFERENCE 2 /* (x in sl) and (x not in s2) */ 
Page 702 -Listing A. 6. Change lines 98-102 to the following: 
98 /* Enlarge the set to "need" words, filling in the extra words with zeros. 
99 * Print an error message and exit if there's not enough memory. 
100 * Since this routine calls malloc, it's rather slow and should be 
101 * avoided if possible. 
102 */ 
330 int Page 706-Listing A.8, line 330. Change unsigned to int: 
ssize; /* Number of words in src set *I 
Page 713 -Third line from the bottom. "nextsym() " should be in the Courier font. 
Replace the last three lines on the page with the following: 
passing the pointer returned from find_ sym () to next sym () , which returns either a 
pointer to the next object or NULL ifthere are no such objects. Use it like this: 
Page 719-Second line above Listing A.l7, change "tree" to "table": 
cial cases. The delsym ( ) function, which removes an arbitrary node from the table, is 
shown in Listing A.17. 
Page 722 -Listing A.l9, line 221. Replace with: 
221 return (*User_cmp) ( (void*) (*p1 + 1), (void*) (*p2 + 1) ) ; 
Page 729-Listing A.26, line 50. Delete the (two required) at the end of the line. 
September 11, 1997 -42- Errata: Compiler Design in C 
Page 736 -Listing A. 33, line 34. Change to the following: 
I 34 PUBLIC void stop_prnt () {} 
Page 737 -Listing A. 33, line 97. Change to the following: 
I 97 char *str, *fmt, *argp; 
Page 739-The swap statement in the code in the middle of the page is incorrect. 
Here is a replacement display: 
int array[ ASIZE l; 
int i, j, temp ; 
for( i = 1; i < ASIZE; ++i ) 
for( j = i-1; j >= 0; --j 
if( array[j] > array[j+1] 
swap( array[j], array[j+1] ) ; 
Page 743 -Listing A.36. Delete the text (but not the line number) on line 4 (which now 
says #include <fcntl.h>). 
Page 745-Change caption of Listing A.38 to the following: 
Listing A.38. memiset.c- Initialize Array of int to Arbitrary Value 
Page 755 -Third line from the bottom. Delete the exclamation point. The line should 
read: 
images (25x80x2=4,000 bytes for the whole screen), and that much memory may not be 
Page 758 -Listing A. 45, line 49. Remove the semicolon at the far right of the line. 
Page 768-Listing A. 61. Remove the exclamation point from the caption. 
Page 776-Line above heading for section A.11.2.2. Delete the void. 
Page 797-Replace Lines 50-59 of Listing A.84 with the following: 
September 11, 1997 -43- Errata: Compiler Design in C 
50 case 
51 
52 
53 
54 
55 
56 
57 
58 
59 
September 11, 1997 '\b': if( buf > sbuf ) 
{ 
--buf; wprintw( win, II \b" ) ; 
} 
else 
{ 
wprintw( win, ) ; 
putchar('\007'); 
} 
break; 
Page 803-Just above heading for section B.2. The line should read: 
set to 100; otherwise, arg is set to 1. 
Page 803 -Replace the last paragraph on the page with the following one: 
The stack, when the recursive call to erato is active, is shown in Figure B.2. There 
is one major difference between these stack frames and C stack frames: the introduction 
of a second pointer called the static link. The dynamic link is the old frame pointer, just 
as in C. The static link points, not at the previously active subroutine, but at the parent 
subroutine in the nesting sequence-in the declaration. Since erato and thalia are 
both nested inside calliope, their static links point at calliope's stack frame. You 
can chase down the static links to access the local variables in the outer routine's ' 
-44- Errata: Compiler Design in C 
Page 804-Replace Figure B.2 with the following figure. 
Figure B.2. Pascal Stack Frames 
terpsichore r ( f-e dynam1c lmk fE-fp 
return address erato 
stat1c lmk 
~ 3 urania 
terpsichore 
1--dynam1c lmk 
return address erato 
stat1c lmk 1/ 
~ 2 urania 
melpomene 
f-e dynam1c lmk 
return address thalia 
stat1c lmk 1/ 
~ 1 euterpe 
clio 
dynamic link 
return address callio 
static link l polyhymnia pe 
September 11, 1997 -45- Errata: Compiler Design in C 
Page 805-Top of the page. Replace the top seven lines (everything up to the paragraph 
that begins "This organization'') with the following (you 'II have to move the rest of the 
text on page 805 down to make room): 
stack frame. For example, clio can be accessed from erato with the following C-code: 
rO.pp = WP(fp + 4); 
X = W(rO.pp -8); /* rO = static link */ 
/* x = clio */ 
You can access polyhymnia from erato with: 
rO.pp = WP(fp + 4); 
X = W(rO.pp + 8); /* rO = static link */ 
/* x = clio */ 
Though it's not shown this way in the current example, it's convenient for the frame 
pointer to point at the static, rather than the dynamic link to make the foregoing indirec­
tion a little easier to do. The static links can be set up as follows: Assign to each sub­
routine a declaration level, equivalent to the nesting level at which the subroutine is 
declared. Here, calliope is a level 0 subroutine, erato is a level 1 subroutine, and so 
forth. Then: 
• If a subroutine calls a subroutine at the same level, the static link of the called 
subroutine is identical to the static link of the calling subroutine. 
• If a subroutine at level N calls a subroutine at level N+ 1, the static link of the 
called subroutine points at the static link of the calling subroutine. 
• If a subroutine calls a subroutine at a lower (more outer) level, use the following 
algorithm: 
i = the difference in levels between the two subroutines; 
p =the static link in the calling subroutine's stack frame; 
while( --i >= 0 ) 
p = *p; 
the static link of the called subroutine= p; 
Note that the difference in levels (i) can be figured at compile time, but you must chase 
down the static links at run time. Since the static link must be initialized by the calling 
subroutine (the called subroutine doesn't know who called it), it is placed beneath the 
return address in the stack frame. 
Page 806 -Change caption and title of Listing C. I as follows: 
Listing C.l. A Summary of the C Grammar in Chapter Six. 
The' and$ 
metacharacters. 
September 11, 1997 Page 819 -First full paragraph. Replace the "the the" on the fourth line with a single 
"the." 
A replacement paragraph follows: 
The A and $ metacharacters work properly in all MS-DOS input modes, regardless of 
whether lines end with \r\n or a single \n. Note that the newline is not part of the lex­
erne, even though it must be present for the associated expression to be recognized. Use 
and\r\n to put the end of line characters into the lexeme. (The \r is not required in 
UNIX applications, in fact it's an error under UNIX.) Note that, unlike the vi editor A$ 
does not match a blank line. You'll have to use an explicit search such as \r\n\r\n to 
fmd empty lines. 
-46- Errata: Compiler Design in C 
Page 821 -Listing D.1, replace lines 14 and 15 with the following: 
14 while ( yylex () ) 
15 
Page 821 -First two lines beneath the listing. Delete both lines and replace with the fol­
lowing text: 
LeX and yyleng is adjusted accordingly. Zero is returned at end offile, -1 if the lexeme 
is too long. 13 
Page 821 -Replace Footnote 13 at the bottom of the page with the one at the bottom of 
the page you are now reading. 
Page 828-Listing D.5.; in order to support the ul suffix, replace line 16 with the follow­
ing: 
16 suffix ( [UuLl] I [uU] [lL]) /* Suffix in integral numeric constant *I 
Page 841 -Replace the code on the first five lines of Listing E.2 with the following five 
lines: 
1 %term ID /* an identifier *I 
2 %term NUM /* a number *I 
3 %left PLUS /* + *I 
4 %left STAR /* * *I 
5 %left LP RP /* and J *I 
Page 843-Paragraph starting -c[N],, 2nd line. Delete "e" in "switche." 
Page 860 -15 lines from the bottom. Remove the underscores. The line should read: 
is from stack picture six to seven. to and t1 were put onto the stack when the rvalues ' 
13 UNIX lex doesn't return -1 and it doesn't modify the yytext or yyleng; it just returns the next input 
character. 
September 11, 1997 -47- Errata: Compiler Design in C 
Page 861 -Figure E. 5. Remove all underscores. The figure should be replaced with the 
following one: 
Figure E.S. A Parse of A *2 
Page 862-Move caption for Listing E.9 to the left. (It should be .flush with the left edge 
of the box.) 
Page 871 -Figure E. 6. Label the line between States 5 and 7 with STAR 
STAR 
Page 880 -Listing E.l7, Lines 84 and 85, replace with the following: 
84 yycode("public word tO, t1, t2, t3;\n"); 
85 yycode("public word t4, t5, t6, t7;\n"); 
51 
52 
53 
54 
55 
56 
57 
46 
54 {o} 512, 
{ 1} 513, 
{2} 514, 
{ 3} 515, 
{4} 516, 
{5} 517, 
{6} 518, 
September 11, 1997 Page 886 -Listing E.l9. Replace lines 51 to 57 with the following: 
line 42 {$1=$2=newname() ;} 
line 42 {freename($0) ;} 
line 48 {$1=$2=newname() ;} 
line 49 { yycode("%S+=%s\\n",$$,$0); freename($0); } 
line 56 {$1=$2=newname() ;} 
line 57 { yycode("%s*=%s\\n",$$,$0); freename($0) ;} 
line 61 { yycode("%s=%0.*s\\n",$$,yyleng,yytext); } 
Page 887 -Listing E.l9. Replace lines 46 and 54 with the following: 
yycode("%S+=%s\n",$$,$0); freename($0); 
yycode("%s*=%s\n",$$,$0); freename($0); expr' 
term' 
Page 888 -Listing E.l9. Replace line 58 with the following: 
-48- Errata: Compiler Design in C 
58 factor NUM OR ID { yycode("%s=%0.*s\n", $$, yyleng, yytext); } 
Disk only. I made several changes to searchen.c (p. 747) to make the returned path 
names more consistent (everything's now mapped to a UNIX-style name). Also added a 
disk identifier when running under DOS. 
Disk only. Insert the following into the brace-processing code, between lines 115 and 
116 of parser. lex on page 273: 
if( i == '\n' && in_string ) 
{ 
lerror( WARNING, 
"Newline in string, inserting \"\n"); 
in string = 0; } -
Disk only. The do_ unop subroutine on page 604 (Line 177 of Listing 6. 79) wasn't han­
dling incoming constant values correctly and it wasn't doing any semantic-error check­
ing at all. It's been replaced by the following code. (Instructions are now generated 
only if the incoming value isn't a constant, otherwise the constant value at the end of 
the link chain is just modified by performing the indicated operation at compile time.) 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 value *do_unop( op, val ) 
int op; 
value *val; 
{ 
char *op_buf 11=?11 
int i; 
if( op != '!' ) /* -or unary-*/ 
{ 
if( !IS_CHAR(val->type) && !IS_INT(val->type) 
yyerror( "Unary operator requires integral argument\n" ) ; 
else if( IS_UNSIGNED(val->type) && op '-' ) 
yyerror( "Minus has no meaning on an unsigned operand\n" ) ; 
else if( IS_CONSTANT( val->type ) ) 
do_unary_const( op, val ) ; 
else 
{ 
op_buf[l] = op; 
gen( op_buf, val->name, val->name ) ; 
else /* ! */ 
{ 
if( IS_AGGREGATE( val->type ) ) 
yyerror("May not apply ! operator to aggregate type\n"); 
September 11, 1997 -49- Errata: Compiler Design in C 
Listing 5.10. continued ... 
205 
206 
207 
208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 } else if( IS_INT_CONSTANT( val->type ) ) 
do_unary_const( '!', val ) ; 
else 
{ 
gen( "EQ", rvalue(val), "0" 
gen ( "goto%s%d", L_TRUE, i 
val = gen_false_true( i, val ) ; 
return val; ) ; /* EQ(x, 0) 
tf label() ) ; /* goto TODD; 
/* fall thru to F */ *I 
*I 
/*----------------------------------------------------------------------*/ 
do_unary_const( op, val ) 
int op; 
value *val; 
{ 
/* Handle unary constants by modifying the constant's value. */ 
link *t = val->type; 
if ( IS INT (t) { -
switch( op 
{ 
case 
case case 
} 
} ,--,. 
' -I : 
I! I: t->V INT 
t->V INT 
t->V INT 
else if( IS_LONG(t) 
{ 
switch( op 
{ 
case ,--,. 
case ' -I : 
case I! I: 
} } 
else t->V LONG 
t->V LONG 
t->V LONG -t->V INT; break; 
-t->V INT; break; 
!t->V INT; break; 
-t->V_LONG; break; 
-t->V_LONG; break; 
!t->V_LONG; break; 
yyerror("INTERNAL do_unary_const: unexpected type\n"); 
Disk only. Page 506, Listing 6.32, lines 453-457: Modified subroutine type_str () in 
file symtab.c to print the value of an integer constant. Replaced the following code: 
with this: if( link_p->NOUN != STRUCTURE ) 
else continue; 
i = sprintf(buf, " %s", link_p->V_STRUCT->tag? 
link_p->V_STRUCT->tag : "untagged"); 
September 11, 1997 -50- Errata: Compiler Design in C 
if( link_p->NOUN == STRUCTURE ) 
else 
else 
else 
else 
else i = sprintf(buf, " %s", link_p->V_STRUCT->tag? 
link_p->V_STRUCT->tag : "untagged"); 
if(IS_INT(link_p) sprintf(buf, ll=%dll, link_p->V_INT 
if(IS_UINT(link_p) sprintf(buf, u=%uu, link_p->V_UINT 
if(IS_LONG(link_p) sprintf(buf, "=%ld", link_p- >V_LONG ) ; 
) ; 
) ; 
if(IS_ULONG(link_p) sprintf(buf, "=%lu",link_p->V_ULONG); 
continue; 
Disk only. Page 241, Listing 4.7, lines 586-589 and line 596, and page 399 Listing 
5.14, lines 320-323 and line 331. The code in llama.par was not testing correctly for a 
NULL return value from i i _ptext () . The problem has been fixed on the disk, but won't 
be fixed in the book until the second edition. The fix looks like this: 
if( yytext = (char *) ii_ptext() ) /* replaces llama.par lines 586-589 */ 
{ 
yylineno 
tchar 
yytext[yyleng] /* and occs.par, lines 320-323 */ 
ii_plineno () ; 
yytext[ yyleng = ii_plength() ] ; 
'\0' 
else /* no previous token */ 
{ 
yytext 
yyleng 1111 i 
yylineno 0; 
if ( yylineno ) 
ii_ptext () /* replaces llama.par, line 596 */ 
ii_plength() ] = tchar; /* and occs.par, line 331 *I 
Disk only. The ii _look() routine (in Listing 2. 7 on page 47) doesn't work in the 8086 
large or compact models. The following is ugly, but it works everywhere: 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 int ii_look ( n ) 
{ 
/* Return the nth character of lookahead, EOF if you try to look past 
* end of file, or 0 if you try to look past either end of the buffer. 
* We have to jump through hoops here to satisfy the ANSI restriction 
* that a pointer can not go to the left of an array or more than one 
* cell past the right of an array. If we don't satisfy this restriction, 
* then the code won't work in the 8086 large or compact models. In 
* the small model---or in any machine without a segmented address 
* space, you could do a simple comparison to test for overflow: 
* uchar *p = Next + n; 
* if ( ! (Start_buf <= p && p < End buf 
* overflow 
*I 
if( n > (End_buf-Next) ) /* (End_buf-Next) is the# of unread*/ 
return Eof read ? EOF : 0 ; /* chars in the buffer (including */ 
/*the one pointed to by Next). */ 
/*The current lookahead character is at Next[O]. The last character*/ 
/*read is at Next[-1]. The--n in the following if statement adjusts*/ 
/* n so that Next[n] will reference the correct character. */ 
September 11, 1997 -51- Errata: Compiler Design in C 
Listing 5.11. continued ... 
24 if( --n < -(Next-Start_buf) /* (Next-Start) is the# of buffered*/ 
25 return 0; /* characters that have been read. */ 
26 
27 return Next[n]; 
28 
September 11, 1997 -52- Errata: Compiler Design in C 


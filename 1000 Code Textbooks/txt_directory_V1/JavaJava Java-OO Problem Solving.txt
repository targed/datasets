Java, Java, Java
Object-Oriented Problem Solving
Third Edition
R. Morelli and R. Walde
Trinity College
Hartford, CT
February 5, 2012
This work is licensed under a
Creative Commons Attribution-NoDerivs 3.0 Unported Licen se.
This book was previously published by
Pearson Education, Inc.
Preface to the Open Source
Edition
Java, Java, Java, 3e was previously published by Pearson Education, Inc.
The ﬁrst edition (2000) and the second edition (2003) were pu blished by
Prentice-Hall. In 2010 Pearson Education, Inc. reassigned the copyright to
the authors, and we are happy now to be able to make the book ava ilable
under an open source license.
This PDF edition of the book is available under a Creative Com -
mons Attribution-NoDerivs 3.0 Unported License, which all ows the
book to be used and shared (with attribution), but not change d (
http://creativecommons.org/licenses/by-nd/3.0/).
As time permits we hope to be able to provide an extensible ver sion of
the book and its contents in the not too distant future.
– Ralph Morelli and Ralph Walde – Hartford, CT – February 6, 201 2
i
ii
Preface to the Third Edition
We have designed this third edition of Java, Java, Java to be suitable for
a typical Introduction to Computer Science (CS1) course or fo r a slightly
more advanced Java as a Second Language course. This edition retains the
“objects ﬁrst” approach to programming and problem solving t hat was
characteristic of the ﬁrst two editions. Throughout the tex t we emphasize
careful coverage of Java language features, introductory p rogramming
concepts, and object-oriented design principles.
The third edition retains many of the features of the ﬁrst two editions,
including:
•Early Introduction of Objects
•Emphasis on Object Oriented Design (OOD)
•Uniﬁed Modeling Language (UML) Diagrams
•Self-study Exercises with Answers
•Programming, Debugging, and Design Tips.
•From the Java Library Sections
•Object-Oriented Design Sections
•End-of-Chapter Exercises
•Companion Web Site, with Power Points and other Resources
The In the Laboratory sections from the ﬁrst two editions have been moved
onto the book’s Companion Web Site. Table 1 shows the Table of Contents
for the third edition.
What’s New in the Third Edition
The third edition has the following substantive changes:
•Although the book retains its emphasis on a “running example ”
that is revisited in several chapters, the CyberPet example s have
been replaced with a collection of games and puzzle examples . The
CyberPet examples from earlier editions will be available o n the
Companion Web Site.
iii
iv
Table 1: Table of Contents for the Third Edition.
Chapter Topic
Chapter 0 Computers, Objects, and Java ( revised )
Chapter 1 Java Program Design and Development
Chapter 2 Objects: Deﬁning, Creating, and Using
Chapter 3 Methods: Communicating with Objects ( revised )
Chapter 4 Input/Output: Designing the User Interface ( new )
Chapter 5 Java Data and Operators
Chapter 6 Control Structures
Chapter 7 Strings and String Processing
Chapter 8 Inheritance and Polymorphism ( new )
Chapter 9 Arrays and Array Processing
Chapter 10 Exceptions: When Things Go Wrong
Chapter 11 Files and Streams
Chapter 12 Recursive Problem Solving
Chapter 13 Graphical User Interfaces
Chapter 14 Threads and Concurrent Programming
Chapter 15 Sockets and Networking ( expanded )
Chapter 16 Data Structures: Lists, Stacks, and
Queues ( revised and expanded )
•Chapters 0 (Computers, Objects, and Java) and 1 (Java Program De-
sign and Development) have been substantially reorganized and
rewritten. The new presentation is designed to reduce the pa ce
with which new concepts are introduced. The treatment of obje ct-
oriented (OO) and UML concepts has also been simpliﬁed, and s ome
of the more challenging OO topics, such as polymorphism, hav e
been moved to a new Chapter 8.
•The new Java 1.5 Scanner class is introduced in Chapter 2 and is
used to perform simple input operations.
•Chapter 4 (Input/Output: Designing the User Interface) has be en
completely written. Rather than relying primarily on apple t inter-
faces, as in the second edition, this new chapter provides in depen-
dent introductions to both a command-line interface and a gr aphi-
cal user interface (GUI). Instructors can choose the type of in terface
that best suits their teaching style. The command-line inte rface is
based on the BufferedReader class and is used throughout the
rest of the text. The GUI is designed to work with either graph i-
cal applications or applets. Both approaches are carefully presented
to highlight the fundamentals of user-interface design. Th e chapter
concludes with an optional section that introduces ﬁle I/O us ing the
newScanner class.
•Much of the discussion of inheritance and polymorphism, whi ch
was previously woven through the ﬁrst ﬁve chapters in the sec ond
edition, has been integrated into a new Chapter 8.
•An optional graphics track is woven throughout the text. Beginning
with simple examples in Chapters 1 and 2, this track also incl udes
v
some of the examples that were previously presented in Chapt er 10
of the second edition.
•Chapter 15, on Sockets and Networking, is expanded to cover s ome
of the more advanced Java technologies that have emerged, in clud-
ing servlets and Java Server Pages.
•Chapter 16, on Data Structures, has been refocused on how to u se
data structures. It makes greater use of Java’s Collection Fr amework,
including the LinkedList andStack classes and the List inter-
face. It has been expanded to cover some advanced data structu res,
such as sets, maps, and binary search trees.
The Essentials Edition
AnEssentials Edition of the third edition, which will include Chapters 0-
12, will be published as a separate title. The Essentials Edi tion will cover
those topics (Chapters 0-9) that are covered in almost all in troductory
(CS1) courses, but it will also include topics (Exceptions, File I/O, and
Recursion) that many CS1 instructors have requested.
Why Start with Objects?
The Third Edition still takes an objects-early approach to teaching Java,
with the assumption that teaching beginners the “big pictur e” early gives
them more time to master the principles of object-oriented pr ogramming.
This approach seems now to have gained in popularity as more a nd more
instructors have begun to appreciate the advantages of the o bject-oriented
perspective.
Object Orientation (OO) is a fundamental problem solving and design
concept, not just another language detail that should be rele gated to the
middle or the end of the book (or course). If OO concepts are int roduced
late, it is much too easy to skip over them when push comes to sh ove in
the course.
The ﬁrst time I taught Java in our CS1 course I followed the sam e ap-
proach I had been taking in teaching C and C++ — namely, start w ith the
basic language features and structured programming concep ts and then,
somewhere around midterm, introduce object orientation. Th is approach
was familiar, for it was one taken in most of the textbooks the n available
in both Java and C++.
One problem with this approach was that many students failed to get
the big picture. They could understand loops, if-else const ructs, and arith-
metic expressions, but they had difﬁculty decomposing a pro gramming
problem into a well-organized Java program. Also, it seemed that this
procedural approach failed to take advantage of the strengt hs of Java’s
object orientation. Why teach an object-oriented language if y ou’re going
to treat it like C or Pascal?
I was reminded of a similar situation that existed when Pasca l was the
predominant CS1 language. Back then the main hurdle for begi nners was
procedural abstraction — learning the basic mechanisms of procedure call
vi
and parameter passing and learning how to design programs as a collec-
tion of procedures. Oh! Pascal! , my favorite introductory text, was typical
of a “procedures early” approach. It covered procedures and p arameters
in Chapter 2, right after covering the assignment and I/O cons tructs in
Chapter 1. It then covered program design and organization in Chap-
ter 3. It didn’t get into loops, if-else, and other structured programming
concepts until Chapter 4 and beyond.
Today, the main hurdle for beginners is the concept of object abstraction .
Beginning programmers must be able to see a program as a colle ction of
interacting objects and must learn how to decompose programm ing prob-
lems into well-designed objects. Object orientation subsume s both proce-
dural abstraction and structured programming concepts fro m the Pascal
days. Teaching objects-early takes a top-down approach to th ese three im-
portant concepts. The sooner you begin to introduce objects a nd classes,
the better the chances that students will master the importa nt principles
of object orientation.
Java is a good language for introducing object orientation. It s object
model is better organized than C++. In C++ it is easy to “work ar ound”
or completely ignore OO features and treat the language like C. In Java
there are good opportunities for motivating the discussion of object orien-
tation. For example, it’s almost impossible to discuss GUI-b ased Java ap-
plications without discussing inheritance and polymorphi sm. Thus rather
than using contrived examples of OO concepts, instructors c an use some
of Java’s basic features — the class library, Swing and GUI co mponents —
to motivate these discussions in a natural way.
Organization of the Text
The book is still organized into three main parts. Part I (Cha pters 0-4) in-
troduces the basic concepts of object orientation and the bas ic features of
the Java language. Part II (Chapters 5-9) focuses on remainin g language el-
ements, including data types, control structures, string a nd array process-
ing, and inheritance and polymorphism. Part III (Chapters 10- 16) covers
advanced topics, including exceptions, ﬁle I/O, recursion, GUIs, threads
and concurrent programming, sockets and networking, data s tructures,
servlets, and Java Server Pages.
The ﬁrst two parts make up the topics that are typically cover ed in an
introductory CS1 course. The chapters in Part III are self-con tained and
can be selectively added to the end of a CS1 course if time perm its.
The ﬁrst part (Chapters 0 through 4) introduces the basic con cepts of
object orientation, including objects, classes, methods, pa rameter passing,
information hiding, and a little taste of inheritance, and p olymorphism.
The primary focus in these chapters is on introducing the bas ic idea that
an object-oriented program is a collection of objects that com municate and
cooperate with each other to solve problems. Java language e lements are
introduced as needed to reinforce this idea. Students are gi ven the basic
building blocks for constructing Java programs from scratc h.
Although the programs in the ﬁrst few chapters have limited f unction-
ality in terms of control structures and data types, the prio rity is placed
vii
Table 2: A one-semester course.
Weeks Topics Chapters
1 Object Orientation, UML Chapter 0
Program Design and Development Chapter 1
2-3 Objects and Class Deﬁnitions Chapter 2
Methods and Parameters Chapter 3
Selection structure (if-else)
4 User Interfaces and I/O Chapter 4
5 Data Types and Operators Chapter 5
6–7 Control Structures (Loops) Chapter 6
Structured Programming
8 String Processing (loops) Chapter 7
9 Inheritance and Polymorphism Chapter 8
10 Array Processing Chapter 9
11 Recursion Chapter 12
12 Advanced Topic (Exceptions) Chapter 10
13 Advanced Topic (GUIs) Chapter 11
Advanced Topic (Threads) Chapter 15
on how objects are constructed and how they interact with each other
through method calls and parameter passing.
The second part (Chapters 5 through 9) focuses on the remaini ng lan-
guage elements, including data types and operators (Chapte r 5), control
structures (Chapter 6), strings (Chapter 7), and arrays (Ch apter 9). It
also provides thorough coverage of inheritance and polymor phism, the
primary mechanisms of object orientation: (Chapter 8).
Part three (Chapters 10 through 16) covers a variety of advan ced topics
(Table 1). Topics from these chapters can be used selectivel y depending
on instructor and student interest.
Throughout the book, key concepts are introduced through si mple,
easy-to-grasp examples. Many of the concepts are used to cre ate a set
of games, which are used as a running example throughout the t ext. Our
pedagogical approach focuses on design. Rather than starti ng of with lan-
guage details, programming examples are carefully develop ed with an
emphasis on the principles of object-oriented design.
Table2 provides an example syllabus from our one-semester C S1
course. Our semester is 13 weeks (plus one reading week durin g which
classes do not meet). We pick and choose from among the advanc ed topics
during the last two weeks of the course, depending on the inte rests and
skill levels of the students.
Ralph Morelli
February 5, 2012
viii
Contents
0 Computers, Objects, and Java 1
0.1 Welcome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.2 What Is a Computer? . . . . . . . . . . . . . . . . . . . . . . . 2
0.3 Networks, the Internet and the World Wide Web . . . . . . . 4
0.4 Why Study Programming? . . . . . . . . . . . . . . . . . . . . 6
0.5 Programming Languages . . . . . . . . . . . . . . . . . . . . 7
0.6 Why Java? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
0.7 What Is Object-Oriented Programming? . . . . . . . . . . . . 11
1 Java Program Design and Development 23
1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.2 Designing Good Programs . . . . . . . . . . . . . . . . . . . . 24
1.3 Designing a Riddle Program . . . . . . . . . . . . . . . . . . . 26
1.4 Java Language Elements . . . . . . . . . . . . . . . . . . . . . 34
1.5 Editing, Compiling, and Running a Java Program . . . . . . 49
1.6 From the Java Library: System and
PrintStream . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
2 Objects: Using, Creating, and Deﬁning 63
2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
2.2 Using String Objects . . . . . . . . . . . . . . . . . . . . . . 64
2.3 Drawing Shapes with a Graphics Object (Optional) . . . . 68
2.4 Class Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . 72
2.5 CASE STUDY: Simulating a Two-Person Game . . . . . . . . 77
2.6 From the Java Library: java.util.Scanner . . . . . . . . . 91
3 Methods: Communicating with Objects 101
3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
3.2 Passing Information to an Object . . . . . . . . . . . . . . . . 102
3.3 Constructor Methods . . . . . . . . . . . . . . . . . . . . . . . 110
3.4 Retrieving Information from an Object . . . . . . . . . . . . . 115
3.5 Passing a Value and Passing a Reference . . . . . . . . . . . . 118
3.6 Flow of Control: Control Structures . . . . . . . . . . . . . . . 12 1
3.7 Testing an Improved OneRowNim . . . . . . . . . . . . . . . . 130
3.8 From the Java Library java.lang.Object . . . . . . . . . 135
3.9 Object-Oriented Design: Inheritance and Polymorphism . . 136
3.10 Drawing Lines and Deﬁning Graphical Methods (Optional ) 138
4 Input/Output: Designing the User Interface 149
4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
ix
x CONTENTS
4.2 The User Interface . . . . . . . . . . . . . . . . . . . . . . . . . 150
4.3 A Command-Line Interface . . . . . . . . . . . . . . . . . . . 151
4.4 A Graphical User Interface (GUI) . . . . . . . . . . . . . . . . 160
4.5 Case Study: The One Row Nim Game . . . . . . . . . . . . . 178
4.6 From the Java Library: java.io.File
and File Input (Optional) . . . . . . . . . . . . . . . . . . . . . 185
5 Java Data and Operators 199
5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
5.2 Boolean Data and Operators . . . . . . . . . . . . . . . . . . . 201
5.3 Numeric Data and Operators . . . . . . . . . . . . . . . . . . 207
5.4 From the Java Library java.lang.Math . . . . . . . . . . . 219
5.5 Numeric Processing Examples . . . . . . . . . . . . . . . . . 221
5.6 From the Java Library
java.text.NumberFormat . . . . . . . . . . . . . . . . . . 233
5.7 Character Data and Operators . . . . . . . . . . . . . . . . . . 235
5.8 Example: Character Conversions . . . . . . . . . . . . . . . . 239
5.9 Problem Solving = Representation + Action . . . . . . . . . . 24 1
6 Control Structures 253
6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
6.2 Flow of Control: Repetition Structures . . . . . . . . . . . . . 2 54
6.3 Counting Loops . . . . . . . . . . . . . . . . . . . . . . . . . . 255
6.4 Example: Car Loan . . . . . . . . . . . . . . . . . . . . . . . . 264
6.5 Graphics Example: Drawing a Checkerboard . . . . . . . . . 267
6.6 Conditional Loops . . . . . . . . . . . . . . . . . . . . . . . . 271
6.7 Example: Computing Averages . . . . . . . . . . . . . . . . . 278
6.8 Example: Data Validation . . . . . . . . . . . . . . . . . . . . 282
6.9 Principles of Loop Design . . . . . . . . . . . . . . . . . . . . 282
6.10 The switch Multiway Selection Structure . . . . . . . . . . . 285
6.11 OBJECT-ORIENTED DESIGN:
Structured Programming . . . . . . . . . . . . . . . . . . . . . 289
7 Strings and String Processing 309
7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
7.2 String Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
7.3 Finding Things Within a String . . . . . . . . . . . . . . . . . 316
7.4 Example: Keyword Search . . . . . . . . . . . . . . . . . . . . 318
7.5 From the Java Library: java.lang.StringBuffer . . . . . . . . . 320
7.6 Retrieving Parts of Strings . . . . . . . . . . . . . . . . . . . . 322
7.7 Example: Processing Names and Passwords . . . . . . . . . 325
7.8 Processing Each Character in a String . . . . . . . . . . . . 326
7.9 Comparing Strings . . . . . . . . . . . . . . . . . . . . . . . . 330
7.10 From the Java Library:
java.util.StringTokenizer . . . . . . . . . . . . . . . . . . . . . 336
7.11 Handling Text in a Graphics Context
(Optional) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
8 Inheritance and Polymorphism 349
8.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
8.2 Java’s Inheritance Mechanism . . . . . . . . . . . . . . . . . . 350
CONTENTS xi
8.3 Abstract Classes, Interfaces,
and Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . 359
8.4 Example: A Toggle Button . . . . . . . . . . . . . . . . . . . . 365
8.5 Example: The Cipher Class Hierarchy . . . . . . . . . . . . . 369
8.6 Case Study: A Two Player Game Hierarchy . . . . . . . . . . 375
8.7 Principles Of Object-Oriented Design . . . . . . . . . . . . . 396
9 Arrays and Array Processing 405
9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
9.2 One-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 406
9.3 Simple Array Examples . . . . . . . . . . . . . . . . . . . . . 413
9.4 Example: Counting Frequencies of Letters . . . . . . . . . . . 4 16
9.5 Array Algorithms: Sorting . . . . . . . . . . . . . . . . . . . . 420
9.6 Array Algorithms: Searching . . . . . . . . . . . . . . . . . . 427
9.7 Two-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 431
9.8 Multidimensional Arrays (Optional) . . . . . . . . . . . . . . 43 9
9.9 OBJECT-ORIENTED DESIGN:
Polymorphic Sorting (Optional) . . . . . . . . . . . . . . . . . 441
9.10 From the Java Library: java.util.Vector . . . . . . . . . . . . . 444
9.11 Case Study: An N-Player Computer Game . . . . . . . . . . 446
9.12 A GUI-Based Game (Optional Graphics) . . . . . . . . . . . . 453
10 Exceptions: When Things Go Wrong 471
10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
10.2 Handling Exceptional Conditions . . . . . . . . . . . . . . . . 472
10.3 Java’s Exception Hierarchy . . . . . . . . . . . . . . . . . . . 474
10.4 Handling Exceptions Within a Program . . . . . . . . . . . . 478
10.5 Error Handling and Robust
Program Design . . . . . . . . . . . . . . . . . . . . . . . . . . 489
10.6 Creating and Throwing Your Own
Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
10.7 From the Java Library: JOptionPane . . . . . . . . . . . . . 501
11 Files and Streams: Input/Output Techniques 513
11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514
11.2 Streams and Files . . . . . . . . . . . . . . . . . . . . . . . . . 514
11.3 CASE STUDY: Reading and Writing Text Files . . . . . . . . 519
11.4 The File Class . . . . . . . . . . . . . . . . . . . . . . . . . . 532
11.5 Example: Reading and Writing Binary Files . . . . . . . . . . 5 35
11.6 Object Serialization: Reading and Writing Objects . . . . . . 544
11.7 From the Java Library
javax.swing.JFileChooser . . . . . . . . . . . . . . . . 549
11.8 Using File Data in Programs . . . . . . . . . . . . . . . . . . . 550
12 Recursive Problem Solving 559
12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 560
12.2 Recursive Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . 563
12.3 Recursive String Methods . . . . . . . . . . . . . . . . . . . . 565
12.4 Recursive Array Processing . . . . . . . . . . . . . . . . . . . 577
12.5 Example: Drawing (Recursive) Fractals . . . . . . . . . . . . 5 83
xii CONTENTS
12.6 OBJECT-ORIENTED DESIGN:
Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
12.7 OBJECT-ORIENTED DESIGN:
Recursion or Iteration? . . . . . . . . . . . . . . . . . . . . . . 588
12.8 From the Java Library:
javax.swing.JComboBox . . . . . . . . . . . . . . . . . . . . . 591
13 Graphical User Interfaces 603
13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
13.2 Java GUIs: From AWT to Swing . . . . . . . . . . . . . . . . . 604
13.3 The Swing Component Set . . . . . . . . . . . . . . . . . . . . 607
13.4 OBJECT-ORIENTED DESIGN:
Model-View-Controller Architecture . . . . . . . . . . . . . . 608
13.5 The Java Event Model . . . . . . . . . . . . . . . . . . . . . . 610
13.6 CASE STUDY: Designing a Basic GUI . . . . . . . . . . . . . 614
13.7 Containers and Layout Managers . . . . . . . . . . . . . . . . 626
13.8 Checkboxes, Radio Buttons, and Borders . . . . . . . . . . . 63 2
13.9 Menus and Scroll Panes . . . . . . . . . . . . . . . . . . . . . 641
14 Threads and Concurrent Programming 655
14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 656
14.2 What Is a Thread? . . . . . . . . . . . . . . . . . . . . . . . . . 656
14.3 From the Java Library: java.lang.Thread . . . . . . . . . 660
14.4 Thread States and Life Cycle . . . . . . . . . . . . . . . . . . . 666
14.5 Using Threads to Improve
Interface Responsiveness . . . . . . . . . . . . . . . . 668
14.6 CASE STUDY: Cooperating Threads . . . . . . . . . . . . . . 676
14.7 CASE STUDY: The Game of Pong . . . . . . . . . . . . . . . . 693
15 Sockets and Networking 707
15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 708
15.2 An Overview of Networks . . . . . . . . . . . . . . . . . . . . 708
15.3 Using Network Resources from an Applet . . . . . . . . . . . 714
15.4 From the Java Library: java.net.URL . . . . . . . . . . . . 715
15.5 The Slide Show Applet . . . . . . . . . . . . . . . . . . . . . . 717
15.6 Using Network Resources from an
Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . 722
15.7 Client/Server Communication via Socket s . . . . . . . . . . 732
15.8 CASE STUDY: Generic Client/Server Classes . . . . . . . . . 7 37
15.9 Playing One Row Nim Over the Network . . . . . . . . . . . 747
15.10Java Network Security Restrictions . . . . . . . . . . . . . . . 754
15.11Java Servlets and Java Server Pages . . . . . . . . . . . . . . . 7 55
16 Data Structures: Lists, Stacks, and Queues 769
16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 770
16.2 The Linked List Data Structure . . . . . . . . . . . . . . . . . 770
16.3 OBJECT-ORIENTED DESIGN:
The List Abstract Data Type (ADT) . . . . . . . . . . . . . . . 782
16.4 The Stack ADT . . . . . . . . . . . . . . . . . . . . . . . . . . . 788
16.5 The Queue ADT . . . . . . . . . . . . . . . . . . . . . . . . . . 790
CONTENTS xiii
16.6 From the Java Library: The Java Collections Framework
and Generic Types . . . . . . . . . . . . . . . . . . . . . . . . 794
16.7 Using the Set andMap Interfaces . . . . . . . . . . . . . . . 797
16.8 The Binary Search Tree Data Structure . . . . . . . . . . . . . 80 1
A Coding Conventions 813
B The Java Development Kit 821
C The ASCII and Unicode Character Sets 831
D Java Keywords 833
E Operator Precedence Hierarchy 835
F Java Inner Classes 837
G Java Autoboxing and Enumeration 843
H Java and UML Resources 849
xiv CONTENTS
OBJECTIVES
After studying this chapter, you will
•Understand basic computer terminology that will be used thr oughout the book.
•Become familiar with the notion of programming.
•Understand why Java is a good introductory programming lang uage.
•Become familiar with Java objects and classes.
•Know some of the principles of the object-oriented programmi ng approach.
OUTLINE
0.1 Welcome
0.2 What Is a Computer?
Special Topic: Processors Then and Now
0.3 Networks, the Internet and the World Wide Web
0.4 Why Study Programming?
0.5 Programming Languages
0.6 Why Java?
0.7 What Is Object-Oriented Programming?
Chapter Summary
ExercisesChapter 0
Computers, Objects, and
Java
1
2 CHAPTER 0 •Computers, Objects, and Java
0.1 Welcome
Welcome to Java, Java, Java , a book that introduces you to object-oriented
programming using the Java language. When considering the pu rpose
of this text, three important questions might come to mind: Wh y study
programming? Why study Java? What is object-oriented programm ing?
This chapter will address these questions. First, we provid e a brief in-
troduction to computers and the Internet and World Wide Web (WWW) .
Then, we address why someone would study programming and we e x-
amine types of programming languages. We introduce the Java program-
ming language and conclude the chapter by exploring object-o riented pro-
gramming principles and how Java is an object-oriented progr amming
language.
0.2 What Is a Computer?
Acomputer is a machine that performs calculations and processes infor -
mation. A computer works under the control of a computer prog ram, a
set of instructions that tell a computer what to do. Hardware refers to the
electronic and mechanical components of a computer. Software refers to
the programs that control the hardware.
Ageneral-purpose computer of the sort that we will be programming can
store many different programs in its memory. That is what giv es it the
ability to perform a wide variety of functions, from word pro cessing to
browsing the Internet. This is in contrast to a special-purpose computer , such
as the one that resides in your microwave oven or the one that c ontrols
your digital watch or calculator. These types of computers c ontain control
programs that are ﬁxed and cannot be changed.
A computer’s hardware is organized into several main subsys tems or
components (Fig. 1).
Figure 1: A diagram of the main
functional components in a com-
puter system. The arrows indicate
the ﬂow of information between
various components.
Secondary
StorageMain Memory
Input Devices
Keyboard
Mouse
Optical
ScannerOutput Devices
Printer
Monitor
Audio
SpeakersCentral
Processing
Unit
(CPU)
Disk Drive
CD-ROM
DVD
•Output devices provide a means by which information held in the com-
puter can be displayed in some understandable or usable form . Com-
mon output devices include printers, monitors, and audio sp eakers.
SECTION 0.2 •What Is a Computer? 3
•Input devices bring data and information into the computer. Some of
the more common input devices are the keyboard, mouse, micro phone,
and scanner.
•Primary memory ormain memory of a computer is used to store both
data and programs. This type of memory, which is often called RAM ,
short for Random Access Memory , is built entirely out of electronic
components—integrated circuit chips—which makes it extreme ly fast.
A computer’s main memory is volatile , which means that any informa-
tion stored in it is lost when the computer’s power is turned o ff. In a
sense, main memory acts as the computer’s scratch pad, stori ng both
programs and data temporarily while a program is running.
•Secondary storage devices are used for long-term or permanent stor-
age of relatively large amounts of information. These devic es include
hard drives or magnetic disks, compact disks (CDs), digital video disks
(DVDs), and magnetic tapes. All of these devices are non-volatile , mean-
ing that they retain information when the computer’s power i s turned
off. Compared to a computer’s primary memory, these devices are
relatively slow.
•The central processing unit (CPU) is the computer’s main engine. The
CPU is the computer’s microprocessor , such as the Intel Pentium pro-
cessor, which serves as the foundation for most Windows PCs, or the
Power-PC processor, which serves as the foundation for Maci ntosh
computers. The CPU is designed to perform the fetch-execute cycle ,Fetch-execute cycle
whereby it repeatedly gets the next machine instruction fro m memory
and executes it. Under the direction of computer programs (s oftware),
the CPU issues signals that control the other components tha t make up
the computer system. One portion of the CPU, known as the arithmetic-
logic unit (ALU) , performs all calculations, such as addition and sub-
traction, and all logical comparisons, such as when one piec e of data is
compared to another to determine if they are equal.
There are two main types of software:
•Application software refers to programs designed to provide a particular
task or service, such as word processors, computer games, sp readsheet
programs, and Web browsers.
•System software includes programs that perform the basic operations
that make a computer usable. For example, an important piece of
system software is the operating system , which contains programs that
manage the data stored on the computer’s disks.
An operating system assists application software in perfor ming tasks
that are considered primitive or low-level, such as managing the com-
puter’s memory and its input and output devices.
Another important thing that the operating system does is to serve as
an interface between the user and the hardware. The operatin g system
determines how the user will interact with the system, or con versely, how
the system will look and feel to the user. For example, in command-line
systems, such as Unix and DOS (short for Disk Operating Syste m), a pro-
gram is run by typing its name on the command line. By contrast , in
4 CHAPTER 0 •Computers, Objects, and Java
graphically based systems, such as Windows and Macintosh, a program
is run by clicking on its icon with the mouse. Thus, this “poin t-and-click”
interface has a totally different “look and feel” but does th e same thing.
Special Topic: Processors Then and Now
To give you some idea of how rapidly computer hardware technology
has advanced, let’s compare the ﬁrst digital processor with one of today’s
models.
The ENIAC (which stood for Electronic Numerical Integrator and Cal-
culator) was developed in 1946 at the University of Pennsylv ania primar-
ily for calculating ballistic trajectories for the U.S. Army . ENIAC occupied
more than 640 square feet of ﬂoor space and weighed nearly 30 to ns. In-
stead of the integrated circuits or chip technology used in today’s comput-
ers, ENIAC’s digital technology was based on over 17,000 vacu um tubes.
ENIAC, which could perform around 300 multiplications per se cond, ran
more than 500 times faster than other computing machines of t hat day and
age. To program the ENIAC, you would have to manipulate hundre ds of
cables and switches. It took two or three days for a team of seve ral pro-
grammers, most of whom were young women, to set up a single pro gram
that would then run for a few seconds.
One of today’s most advanced and powerful processors for des ktop
computers is Intel’s Pentium IV processor. This chip contains 42 million
transistors and runs at speeds over 3 GHz (3 gigahertz or 3 bill ion cycles
per second). The Pentium processor is small enough to ﬁt in a s pace the
size of your pinky ﬁnger’s ﬁngernail. Despite its size, it ex ecutes millions
of instructions per second, thereby enabling it to support a huge range of
multimedia applications, including three-dimensional gr aphics, stream-
ing audio and video, and speech recognition applications. T o write pro-
grams for the Pentium, you can choose from a wide range of high -level
programming languages, including the Java language.
0.3 Networks, the Internet and the World Wide
Web
Most personal computers contain software that enables them to be con-
nected to various-sized networks of computers. Networks allow many in-
dividual users to share costly computer resources, such as a high-speed
printer or a large disk drive or application server that is used to store and
distribute both data and programs to the computers on the net work. Net-
works can range in size from local area networks (LANs) , which connect
computers and peripherals over a relatively small area, suc h as within a
lab or a building, through wide area networks (WANs) , which can span large
geographic areas, such as cities and nations.
Client/server computing Application servers are just one example of client/server computing , a
computing approach made possible by networks. According to this ap-
proach, certain computers on the network are set up as servers , which pro-
vide certain well-deﬁned services to client computers. For example, one
computer in a network may be set up as the email server , with the responsi-
SECTION 0.3 •Networks, the Internet and the World Wide Web 5
bility of sending, receiving, and storing mail for all users on the network.
To access their email on the email server, individual users e mploy client
application software that resides on their desktop computers, such as Out-
look Express or Eudora or Pine. Similarly, another server ma y be set up as
aWeb server , with the responsibility of storing and serving up Web pages
for all the users on the network. Users can run Web browsers, a nother type
of client software, to access Web pages on the server. Java is particularly
well suited for these types of networked ordistributed applications, where
part of the application software resides on a server and part resides on the
client computer.
The Internet (with a capital I) is a network of networks whose geo-
graphical area covers the entire globe. The World Wide Web (WWW) is
another example of distributed, client/server computing. The WWW is
not a separate physical network. Rather it is a subset of the In ternet that
uses the HyperText Transfer Protocol (HTTP) . A protocol is a set of rules
and conventions that govern how communication takes place b etween
two computers. HTTP is a multimedia protocol, which means tha t it
supports the transmission of text, graphics, sound, and oth er forms of
information. Certain computers within a network run specia l software
that enables them to play the role of HTTP (or Web) servers. The y store
Web documents and are capable of handling requests for docum ents
from client browser applications. The servers and clients c an be located
anywhere on the Internet.
The documents stored on Web servers are encoded in a special t ext-
based language known as HyperText Markup Language , or HTML . Web
browsers, such as Netscape’s Navigator and Microsoft’s Inte rnet Explorer,
are designed to interpret documents coded in this language. The language
itself is very simple. Its basic elements are known as tags, which consist
of certain keywords or other text contained within angle bra ckets,<and
>. For example, if you wanted to italicize text on a Web page, yo u would
enclose it between the <I>and</I>tags. Thus, the following HTML
code
☛ ✟
$<I>$ I t a l i c font$ </I>$ can be used for $<I>$emphasis$ </I>$ .
✡ ✠
would be displayed by the Web browser as
Italic font can be used for emphasis .
When you use a Web browser to surf the Internet, you repeatedly i nstruct
your browser to go to a certain location and retrieve a page th at is encoded
in HTML. For example, if you typed the following URL (Uniform Resource
Locator)
☛ ✟
http : // w w w. prenhall . com/ m o r e l l i/index . html
✡ ✠
into your browser, the browser would send a message to the Web server
www located in the prenhall.com domain—the prenhall portion of
this address speciﬁes Prentice Hall and the com portion speciﬁes the com-
mercial domain of the Internet—requesting that the document n amed
index.html in themorelli directory be retrieved and sent back to your
6 CHAPTER 0 •Computers, Objects, and Java
Figure 2: WWW: The client’s
browser requests a page from a
Web server. When the HTML doc-
ument is returned, it is interpreted
and displayed by the browser.Display
InternetSend a document
Request a documentHTML
document
Server
ClientHTTP
softwareText/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr/BnZr
yyyyyyyyyyyyyyyy
/BnZr/BnZr/BnZr/BnZr
yyyy
Browser
software
computer (Fig. 2). The beauty of the Web is that it is possible to embed
text, sound, video, and graphics within an HTML document, mak ing it
possible to download a wide range of multimedia resources th rough this
(relatively) simple mechanism.
The Web has begun to change business, entertainment, commer ce, and
education. The fact that it is possible to download computer games and
other application software from the Web is changing the way s oftware and
other digital products are purchased and distributed. Simi larly, as noted
earlier, many businesses have begun to organize their infor mation systems
into intranets —private networks that implement the HTTP protocol. Cur-
rently, one of the biggest areas of development on the Web is c ommerce.
As consumers become more comfortable that credit-card info rmation can
be securely transmitted over the Web (as it can over a telepho ne), the Web
will explode as a marketing medium as powerful, perhaps, as t elevision
is today. Because Java has been designed to support secure, d istributed,
networked applications, it is ideally suited to be used as th e language for
these types of applications.
0.4 Why Study Programming?
Acomputer program is a set of instructions that directs the computer’s
behavior. Computer programming is the art and science of designing and
writing programs. Years ago it was widely believed that entr ance into
the computer age would require practically everyone to lear n how to pro-
gram. But this did not prove to be true. Today’s computers com e with so
much easy-to-use software that knowing how to use a computer no longer
requires programming skills.
Another reason to study programming might be to enter into a c areer
as a computer scientist. However, although programming is on e of its
primary tools, computer science is a broad and varied discip line, which
ranges from engineering subjects, such as processor design, to mathemat-
ical subjects, such as performance analysis. There are many c omputer sci-
entists who do little or no programming as part of their every day work.
If you plan to major or minor in computer science, you will certa inly
learn to program, but good careers in the computing ﬁeld are a vailable
to programmers and nonprogrammers alike.
SECTION 0.5 •Programming Languages 7
One of the best reasons to study programming is because it is a cre-
ative and enjoyable problem-solving activity. This book wil l teach you to
develop well-designed solutions to a range of interesting p roblems. One
of the best things about programming is that you can actually see and
experience your solutions as running programs. As many stud ents have
indicated, there’s really nothing like the kick you get from seeing your
program solving a problem you’ve been struggling with. Desi gning and
building well-written programs provides a powerful sense o f accomplish-
ment and satisfaction. What’s more, Java is a language that ma kes pro-
gramming even more fun, because once they’re ﬁnished, many J ava pro-
grams can be posted on the World Wide Web (WWW) for all the world to
see!
0.5 Programming Languages
Most computer programs today are written in a high-level language , such
as Java, C, C++, or FORTRAN. A programming language is consid ered
high level if its statements resemble English-language sta tements. For
example, all of the languages just mentioned have some form of an “if”
statement, which says, “if some condition holds, then take s ome action.”
Computer scientists have invented hundreds of high-level p rogram-
ming languages, although relatively few of these have been p ut to prac-
tical use. Some of the widely used languages have special fea tures that
make them suitable for one type of programming application o r another.
COBOL (COmmon Business-Oriented Language), for example, i s still
widely used in commercial applications. FORTRAN (FORmula T RANsla-
tor) is still preferred by some engineers and scientists. C a nd C++ are still
the primary languages used by operating system programmers .
In addition to having features that make them suitable for cer tain types
of applications, high-level languages use symbols and nota tion that make
them easily readable by humans. For example, arithmetic ope rations in
Java make use of familiar operators such as “ +” and “−” and “/”, so that
arithmetic expressions look more or less the way they do in al gebra. So,
to take the average of two numbers, you might use the expressi on
☛ ✟
( a + b ) / 2
✡ ✠
The problem is that computers cannot directly understand su ch expres-
sions. In order for a computer to run a program, the program mus t ﬁrst
be translated into the computer’s machine language , which is the language
understood by its CPU or microprocessor. Each type of microp rocessor
has its own particular machine language. That’s why when you buy soft-
ware it runs either on a Macintosh, which uses the Power-PC ch ip, or on a
Windows machine, which uses the Pentium chip, but not on both . When a Platform independence
program can run on just one type of chip, it is known as platform dependent .
In general, machine languages are based on the binary code , a two-
valued system that is well suited for electronic devices. In a binary repre-
sentation scheme, everything is represented as a sequence o f 1’s and 0’s,
which corresponds closely to the computer’s electronic “on ” and “off”
states. For example, in binary code, the number 13 would be re pre-
8 CHAPTER 0 •Computers, Objects, and Java
sented as 1101. Similarly, a particular address in the compu ter’s memory
might be represented as 01100011, and an instruction in the c omputer’s
instruction set might be represented as 001100.
The instructions that make up a computer’s machine language are very
simple and basic. For example, a typical machine language mi ght in-
clude instructions for ADD, SUBTRACT, DIVIDE, and MULTIPLY, bu t it
wouldn’t contain an instruction for AVERAGE. In most cases, a single in-
struction, called an opcode , carries out a single machine operation on one
or more pieces of data, called its operands . Therefore, the process of av-
eraging two numbers would have to be broken down into two or mo re
steps. A machine language instruction itself might have som ething sim-
ilar to the following format, in which an opcode is followed b y several
operands, which refer to the locations in the computer’s pri mary memory
where the data are stored. The following instruction says AD D the num-
ber in LOCATION1 to the number in LOCATION2 and store the result in
LOCATION3:
Opcode Operand 1 Operand 2 Operand 3
011110 110110 111100 111101
(ADD) (LOCATION 1) (LOCATION 2) (LOCATION 3)
Given the primitive nature of machine language, an expressi on like
(a+b)/2would have to be translated into a sequence of several machin e
language instructions that, in binary code, might look as fo llows:
☛ ✟
011110110110111100111101
000101000100010001001101
001000010001010101111011
✡ ✠
In the early days of computing, before high-level languages w ere de-
veloped, computers had to be programmed directly in their ma chine
languages, an extremely tedious and error-prone process. Im agine how
difﬁcult it would be to detect an error that consisted of putt ing a 0 in the
preceding program where a 1 should occur!
Fortunately, we no longer have to worry about machine langua ges, be-
cause special programs can be used to translate a high-level orsource
code program into machine language code or object code , which is the
only code that can be executed or run by the computer. In general, a pro-
gram that translates source code to object code is known as a translator
(Fig. 3). Thus, with suitable translation software for Java or C++ we can
write programs as if the computer could understand Java or C+ + directly.
Source code translators come in two varieties. An interpreter trans-
lates a single line of source code directly into machine lang uage and ex-
ecutes the code before going on to the next line of source code . A com-
piler translates the entire source code program into executable object code,
which means that the object code can then be run directly witho ut further
translation.
There are advantages and disadvantages to both approaches. Inter-
preted programs generally run less efﬁciently than compile d programs,
SECTION 0.6 •Why Java? 9
High-level
language
Translator
softwareMachine
language
Source
codeObject
code(a+b)/2000110101
101000110
101000110Figure 3: Translator software
translates high-level source code to
machine language object code .
because they must translate and execute each line of the prog ram before
proceeding to the next line. If a line of code is repeated, an in terpreter
would have to translate the line each time it is encountered. By contrast,
once compiled, an object program is just executed without any n eed for
further translation. It is also much easier to reﬁne compiled code to make
it run more efﬁciently. But interpreters are generally quic ker and easier
to develop and provide somewhat better error messages when t hings go
wrong. Some languages that you may have heard of, such as BASIC , LISP ,
and Perl, are mostly used in interpreted form, although comp ilers are also
available for these languages. Programs written in COBOL, F ORTRAN,
C, C++, and Pascal are compiled. As we will see in the next sect ion,
Java programs use both compilation and interpretation in th eir translation
process.
0.6 Why Java?
Originally named “Oak” after a tree outside the ofﬁce of its d eveloper,
James Goslin, Java is a relatively young programming langua ge. It was
initially designed by Sun Microsystems in 1991 as a language for em-
bedding programs into electronic consumer devices, such as microwave
ovens and home security systems. However, the tremendous pop ularity
of the Internet and the World Wide Web (WWW) led Sun to recast Java a s
a language for embedding programs into Web-based applicati ons. As you
recall, the Internet is a global computer network, and the WWW is that
portion of the network that provides multimedia access to a v ast range of
information. Java has become one of the most important langu ages for
Web and Internet applications.
Java has also generated signiﬁcant interest in the business community,
where it is has proved to have tremendous commercial potenti al. In addi-
tion to being a useful tool for helping businesses to promote their products
and services over the Internet, Java is also a good language fo r distribut-
ing software and providing services to employees and client s on private
corporate networks or intranets.
Because of its original intended role as a language for progr amming mi-
croprocessors embedded in consumer appliances, Java has be en designed
with a number of interesting features:
•Java is object oriented . Object-oriented languages divide programs
into separate modules, called objects, that encapsulate the program’s
data and operations. Thus, object-oriented programming (OOP) and
object-oriented design (OOD) refer to a particular way of organizing
10 CHAPTER 0 •Computers, Objects, and Java
programs, one which is rapidly emerging as the preferred app roach Object-oriented Languages
for building complex software systems. Unlike the C++ langu age, in
which object-oriented features were grafted onto the C langu age, Java
was designed from scratch as an object-oriented language.
•Java is robust , meaning that errors in Java programs don’t cause system
crashes as often as errors in other programming languages. C ertain
features of the language enable many potential errors to be d etected
before a program is run.
•Java is platform independent . Aplatform , in this context, is just a particu- Platform independence
lar kind of computer system, such as a Macintosh or Windows sy stem.
Java’s trademark is “Write once, run anywhere.” This means t hat a Java
program can be run without changes on different kinds of comp uters.
This is not true for other high-level programming languages . This porta-
bility – the ability to run on virtually any platform – is one reason t hat
Java is well suited for WWW applications.
•Java is a distributed language, which means that its programs can be
designed to run on computer networks. In addition to the langu age it-
self, Java comes with an extensive collection of code libraries —software
that has been designed to be used directly for particular typ es of
applications—that make it particularly easy to build softwa re systems
for the Internet and the WWW. This is one of the reasons why Java is so
well suited for supporting applications on corporate netwo rks.
•Java is a secure language. Designed to be used on networks, Java con-
tains features that protect against untrusted code —code that might in-
troduce a virus or corrupt your system in some way. For exampl e,
once they are downloaded into your browser, Web-based Java p ro-
grams are prevented from reading and writing information fr om and
to your desktop computer.
Despite this list of attractive features, perhaps the best r eason for choosing
Java as an introductory programming language is its potenti al for bring-
ing fun and excitement into learning how to program. There ar e few other
languages in which a beginning programmer can write a comput er game
or a graphically based application that can be distributed o n a Web page to
just about any computer in the world. The simplicity of Java’s design and
its easily accessible libraries bring such accomplishment s within reach of
the most novice programmers.
For example, we will work on projects throughout the text that involve
games and puzzles. We start out in Chapter 2 by designing very simple
games that involve storing and retrieving data. As we learn m ore sophisti-
cated programming techniques, we gradually build more comp lexity into
the games and puzzles. For example, we learn how to create int eractive,
two-person games in Chapter 4. In Chapter 8, we develop some ga mes
and puzzles that are played on virtual game boards. Finally, in Chapter 14
we learn how to introduce games with multiple players on diff erent com-
puters. To get a look at where we are headed you might want to vi sit the
authors’ companion Web site:
☛ ✟
http : // w w w. cs . t r i n c o l l . edu/˜ram/ j j j /
✡ ✠
SECTION 0.7 •What Is Object-Oriented Programming? 11
0.7 What Is Object-Oriented Programming?
Java is an object-oriented (OO) language, and this book takes an object-
oriented approach to programming. So before beginning our d iscussion
of Java, it is important that we introduce some of the underly ing con-
cepts involved in object-oriented programming. We need to ta lk about
what an object is, how objects are grouped into classes, how cla sses are
related to each other, and how objects use messages to interac t with and
communicate with each other.
0.7.1 Basic Object-Oriented Programming Metaphor:
Interacting Objects
A Java program, and any object-oriented program, is a collect ion of in-
teracting objects that models a collection of real-world obje cts. Think of
FIGURE 4 A model of a kitchen.the model that a kitchen designer might use to layout your new kitchen
(Fig. 4). It will contain objects that represent the various ki tchen appli-
ances and cabinets. Each object in the model is a simpliﬁed ver sion of
the corresponding real object. For example, a rectangle migh t be used to
represent the refrigerator.
A kitchen model is mostly static . It doesn’t change. Once put into place,
its various objects just stand there in a certain relation to ea ch other. By
contrast, a computer program is dynamic . It changes. It does things and
performs certain actions. The objects in a computer program c ommuni-
cate with each other and they change over time. In this respect , the objects
that make up our computer programs are very anthropomorphic , a big word
that means “like people.” If we are eating together and I want y ou to pass
me the salt, I say, “Please pass me the salt,” and you invariab ly comply.
Similarly, when you (Student X) put your ATM card into an ATM m achine,
the ATM object asks the bank’s database object “Give me Student X’s bank
account object” and the database invariably complies. If you t ell the ATM
you want to withdraw $100 dollars it tells your bank account o bject to
deduct $100 from your current balance. And so it goes. Both yo u and
your bank account are changed objects as a result of the transa ction.
0.7.2 What is an Object?
So what is an object? Just as in the real world, an object is any thing
whatsoever. An object can be a physical thing, such as a Car, or a mental
thing, such as an Idea . It can be a natural thing, such as an Animal , or
an artiﬁcial, human-made thing, such as a ATM. A program that manages
an ATM would involve BankAccount s andCustomer objects. A chess
program would involve a Board object and ChessPiece objects.
Throughout this text, we will use the notation shown in Figur e 5 to
depict objects and to illustrate object-oriented concepts. T he notation is
known as the Uniﬁed Modeling Language , orUML for short, and it is a
standard in the object-oriented programming community. As t he diagram
shows, an object is represented by a rectangle whose label con sists of the
object’s (optional) id and its type. An object’s idis the name by which
it is referred to in the computer program. In this case we show a ATM
12 CHAPTER 0 •Computers, Objects, and Java
Figure 5: In UML, objects are rep-
resented by rectangles that are la-
beled with a two-part label of the
form id:Type . The object’s label is
always underlined.
object, who’s id is not given, and a ChessPiece object, named pawn1 .
An object’s label is always underlined.
0.7.3 Attributes and Values
Just as with real objects, the objects in our programs have cert ain char-
acteristic attributes . For example, an ATM object would have a current
amount of cash that it could dispense. A ChessPiece object might
have a pair of row andcolumn attributes that specify its position on the
chess board. Notice that an object’s attributes are themselv es objects. The
ATM’s cash attribute and the chess piece’s row andcolumn attributes
areNumber s.
Figure 6 shows two ATM objects and their respective attributes. As you
can see, an object’s attributes are listed in a second partiti on of the UML
diagram. Notice that each attribute has a value. So the lobby:ATM has a
$8650.0 in cash , while the drivethru:ATM has only $150.0 in cash .
Figure 6: A second partition of an
object diagram is used to display
the object’s attributes and their
values.
We sometimes refer to the collection of an object’s attribute s and values
as its state . For example, the current state of the lobby:ATM is $8650.0 in
cash. Of course, this is a gross simpliﬁcation of an ATM’s sta te, which
would also include many other attributes. But, hopefully, y ou see the
point.
0.7.4 Actions and Messages
In addition to their attributes, objects also have characteri sticactions or
behaviors. As we have already said, objects in programs are dy namic.
They do things or have things done to them. In fact, programmin g in
Java is largely a matter of getting objects to perform certain actions for
us. For example, in a chess program the ChessPiece s have the ability to
moveTo() a new position on the chess board. Similarly, when a customer
pushes the “Current Balance” button on an ATM machine, this i s telling
SECTION 0.7 •What Is Object-Oriented Programming? 13
Figure 7: Messages in UML are
represented by labeled arrows. In
this example, we are telling a
pawn to move from its current po-
sition to row 3 column 4.
the ATM to report() the customer’s current bank balance. (Note how
we use parentheses to distinguish actions from objects and at tributes.)
The actions that are associated with an object can be used to se nd mes-
sages to the objects and to retrieve information from objects. Amessage
is the passing of information or data from one object to anothe r. Figure 7
illustrates how this works. In UML, messages are represented by arrows.
In this example, we are telling pawn1:ChessPiece tomoveTo(3,4) .
The numbers 3 and 4 in this case are arguments that tell the paw n what
square to move to. (A chess board has 8 rows and 8 columns and ea ch
square is identiﬁed by its row and column coordinates.) In gen eral, an
argument is a data value that specializes the content of a message in so me
way. In this example we are telling the pawn to move forward by 1 row.
If we wanted the pawn to move forward by 2 rows, we would send the
message moveTo(4,4) .
The diagram in Figure 8 depicts a sequence of messages repres enting
an idealized ATM transaction. First, an ATM customer asks th e ATM ma-
chine to report his current balance. The ATM machine in turn a sks the
customer’s bank account to report the customer’s balance. T he ATM re-
ceives the value $528.52 from the bank account and passes it a long to the
customer. In this case, the message does not involve an argume nt. But it
does involve a result. A result is information or data that is returned to
the object that sent the message.
Figure 8: This UML diagram
illustrates an ATM transaction
in which a customer asks the
ATM machine for his current bal-
ance. The ATM gets this informa-
tion from an object representing
the customer’s bank account and
passes it to the customer.
Obviously, in order to respond to a message, an object has to kn ow
how to perform the action that is requested. The pawn has to kn ow how
to move to a designated square. The ATM has to know how to ﬁnd ou t
the customer’s current balance. Indeed, an object can only res pond to
messages that are associated with its characteristic actio ns and behaviors.
You can’t tell an ATM to move forward 2 squares. And you can’t a sk a
chess piece to tell you your current bank balance.
Responding to a message or performing an action sometimes ca uses
a change in an object’s state. For example, after performing moveTo(3,
4), the pawn will be on a different square. Its position will have changed.
On the other hand, some messages (or actions) leave the object ’s state un-
changed. Reporting the customer’s bank account balance doe sn’t change
the balance.
14 CHAPTER 0 •Computers, Objects, and Java
Figure 9: A UML diagram of the
Rectangle class.
0.7.5 What is a Class?
Aclass is a template for an object. A class encapsulates the attribut es and
actions that characterize a certain type of object. In an object -oriented pro-
gram, classes serve as blueprints or templates for the object s that the pro-
gram uses. We say that an object is an instance of a class. A good analogy
here is to think of a class as a cookie cutter and its objects, or instances, as
individual cookies. Just as we use the cookie cutter to stamp out cookies
of a certain type, in an object-oriented program, we use a deﬁn ition of a
class to create objects of a certain type.
Writing an object-oriented program is largely a matter of des igning
classes and writing deﬁnitions for those classes in Java. De signing a
class is a matter of specifying all of the attributes and beha viors that are
characteristic of that type of object.
For example, suppose we are writing a drawing program. One ty pe
of object we would need for our program is a rectangle. A Rectangle
object has two fundamental attributes, a length and awidth . Given
these attributes, we can deﬁne characteristic rectangle ac tions, such as the
ability to calculate its area and the ability to draw itself. Identifying an
object’s attributes and actions is the kind of design activit y that goes into
developing an object-oriented program.
Figure 9 shows a UML diagram of our Rectangle class. Like the sym-
bol for an object, a UML class symbol has up to three partitions . Unlike the
UML object symbol, the label for a UML class gives just the class ’s name
and it is not underlined. The second partition lists the clas s’s attributes
and the third partition lists the classes actions. Our recta ngle has four
attributes. The ﬁrst two, xandy, determine a rectangles position on a
two-dimensional graph. The second two, length andwidth , determine
a rectangle’s dimensions. Note that the attributes have no v alues. This is
because the class represents a general type of rectangle. It speciﬁes what
all rectangles have in common, without representing any par ticular rect-
angle. Like a cookie cutter for a cookie, a class gives the gen eral shape of
an object. The content is not included.
0.7.6 Variables and Methods
Up to this point we have been using the terms attribute and action to de-
scribe an object’s features. We will continue to use this term inology when
talking in general about objects or when talking about an objec t or class
represented by a UML diagram.
SECTION 0.7 •What Is Object-Oriented Programming? 15
However, when talking about a programming language, the more com-
mon way to describe an object’s features are to talk about its v ariables
and methods. A variable , which corresponds to an attribute, is a named
memory location that can store a certain type of value. You ca n think of a
variable as a special container that can only hold objects of a certain type.
For example, as Figure 9 shows, Rectangle ’slength andwidth are
variables that can store a certain type of numeric value know n as an int.
Anint value is a whole number, such as 76 or -5.
Amethod , which corresponds to an action or a behavior, is a named
chunk of code that can be called upon or invoked to perform a certain
pre-deﬁned set of actions. For example, in our Rectangle object, the
calculateArea() method can be called upon to calculate the rectan-
gle’s area. It would do this, of course, by multiplying the rec tangle’s
length by its width. Similarly, the draw() method can be invoked to draw
a picture of the rectangle. It would take the actions necessar y to draw a
rectangle on the console.
0.7.7 Instance versus Class Variables and Methods
Variables and methods can be associated either with objects o r their
classes. An instance variable (orinstance method ) is a variable (or
method) that belongs to an object. By contrast, a class variable (orclass
method ) is a variable (or method) that is associated with the class i tself.
An example will help make this distinction clear.
An instance variable will have different values for differe nt instances.
For example, individual Rectangle s will have different values for their
length ,width ,x, andyvariables. So these are examples of instance
variables. The calculateArea() method is an example of an instance
method because it uses the instance’s current length and wid th values
in its calculation. Similarly, the draw() method is an instance method,
because it uses the object’s length and width to draw the object ’s shape.
An example of a class variable would be a variable in the Rectangle
class that is used to keep track of how many individual Rectangle s
have been created. (Our drawing program might need this info rmation
to help manage its memory resources.) Suppose we name this va riable
nRectangles and suppose we add 1 to it each time a new Rectangle
instance is created.
An example of a method that is associated with the class is a sp ecial
method known as a constructor . This is a method used to create an object.
It is used to create an instance of a class. Calling a construct or to create an
object is like pressing the cookie cutter into the cookie doug h: the result is
an individual cookie (object).
Figure 10 illustrates these concepts. Note that class varia bles are un-
derlined in the UML diagram. We have modiﬁed the Rectangle class
to include its constructor method, which is named Rectangle() . Note
that it takes four arguments, representing the values that w e want to give
as the rectangle’s x,y, length and width respectively. Note also how the
Rectangle class’s nRectangles variable has a value of 2, representing
that two Rectangle instances have been created. These are shown as
members of the Rectangle class.
16 CHAPTER 0 •Computers, Objects, and Java
Figure 10: The Rectangle class
and two of its instances. Note that
the class variable, nRectangles ,
is underlined to distinguish it
fromlength andwidth , the in-
stance variables.
It won’t be obvious to you at this point, but nRectangles is a value
that has to be associated with the Rectangle class, not with its instances.
To see this let’s imagine what happens when a new Rectangle instance
is created. Figure 11 illustrates the process. When the Rectangle()
constructor is invoked, its arguments (100, 50, 25, 10) are u sed by the
Rectangle class to create a Rectangle object located at x=100 ,y=50 and
with a length of 25 and width of 10. The constructor method als o increases
the value of nRectangles by 1 as a way of keeping count of how many
objects it has created.
Figure 11: Constructing a
Rectangle instance.
0.7.8 Class Hierarchy and Inheritance
How are classes related to each other? In Java, and in any other o bject-
oriented language, classes are organized in a class hierarc hy. A class hier-
archy is like an upside-down tree. At the very top of the hierarchy i s the
most general class. In Java, the most general class is the Object class. The
classes below Object in the hierarchy are known as its subclasses . Since
all of the objects we use in our programs belong to some class or other,
this is like saying that all objects are Object s.
Figure 12 illustrates the concept of a class hierarchy using the classes
that we have described in this section. Notice that the Object class oc-
curs at the top of the hierarchy. It is the most general class. It has fea-
tures that are common to all Java objects. As you move down the h ierar-
SECTION 0.7 •What Is Object-Oriented Programming? 17
Figure 12: A hierarchy of Java
classes.
chy, the classes become more and more specialized. A Rectangle is an
Object but it contains attributes – length and width – that are commo n
to all rectangles but not to other objects in the hierarchy. Fo r example, an
ATM object does not necessarily have a length and a width. Notice t hat we
have added a Square class to the hierarchy. A Square is a special type
ofRectangle , namely one who’s length equals its width.
To introduce some important terminology associated with th is kind of
hierarchy, we say that the Rectangle class is a subclass of the Object Superclass and subclass
class. The Square class is a subclass of both Rectangle andObject .
Classes that occur above a given class in the hierarchy are sa id to be its
superclasses . Thus Rectangle class is superclass of the Square class.
TheObject class is also a superclass of Square . In general, we say that
a subclass extends a superclass, meaning that it adds additional elements
(attributes and/or methods) to those contained in its super classes. We saw
this in the case of the Square class. It adds the feature that its length and
width are always equal.
Another important concept associated with a class hierarch y is the
notion of class inheritance , whereby a subclass inherits elements (at- Class inheritance
tributes and/or methods) from its superclasses. To take an e xample from
the natural world, think of the sort of inheritance that occu rs between a
horse and a mammal. A horse is a mammal. So horses inherit the c har-
acteristic of being warm blooded by virtue of also being mamm als. (This
is different from the kind of individual inheritance whereb y you inherit
your mother’s blue eyes and your father’s black hair.)
To illustrate how inheritance works, lets go back to our ches s program.
There are several different types of ChessPiece s. There are Pawn s, and
Knight s, and Queen s andKing s. Figure 13 illustrates the chess piece
hierarchy. A pair of attributes that all chess pieces have in common is
theirrow andcolumn position on the chess board. Because all chess
pieces have these attributes in common, they are located at t he top of the
ChessPiece hierarchy and inherited by all ChessPiece subclasses. Of
course, the row andcolumn attributes are given different values in each
ChessPiece object.
One of the actions that all chess pieces have in common is that they can
moveTo() a given square on the chess board. But different types of ches s
pieces have different ways of moving. For example, a Bishop can only
move along diagonals on the chess board, whereas a Rook can only move
along a row or column on the chess board. So, clearly, we can’t describe
18 CHAPTER 0 •Computers, Objects, and Java
Figure 13: The ChessPiece hier-
archy.
amoveTo() method that will work for all ChessPiece s. This is why
we put the moveTo() method in all of the ChessPiece subclasses. The
ChessPiece class also has a moveTo() method, but note that its name is
italicized. This indicates that it cannot be completely deﬁ ned at that level.
Finally, note that in chess, the king has certain special att ributes and
actions. Thus only the king can be put in check . This means that the king is
under attack and in danger of being captured, thereby ending the game.
Similarly, only the king has the ability to castle. This is sp ecial move that
a king can make together with one of its rooks under certain co nditions.
Thus, the reason we show the inCheck attribute and castle() action in
theKing class is because these are characteristics that particular toKing s.
In this way, a class hierarchy represents a specialization of classes as you
move from top to bottom. The most general class, ChessPiece , is at the
top of the hierarchy. Its attributes and methods are passed on to (inher-
ited by) its subclasses. However, in addition to the attribut es and methods
they inherit from their superclasses, the subclasses deﬁne their own spe-
cial attributes and methods. Each of the subclasses, Pawn ,Bishop , and
so on, represents some kind of specialization of the supercl ass. In this ex-
ample, each of the subclasses have their own distinctive way s of moving.
And the King subclass has unique attributes and actions ( inCheck and
castle() .
0.7.9 Principles of Object-Oriented Design
As we have discussed, an object-oriented program is composed of many
objects communicating with each other. The process of design ing an
SECTION 0.7 •What Is Object-Oriented Programming? 19
object-oriented program to solve some problem or other invol ves several
important principles:
•Divide-and-Conquer Principle. Generally, the ﬁrst step in designing
a program is to divide the overall problem into a number of obje cts
that will interact with each other to solve the problem. Thus , an object-
oriented program employs a division of labor much as we do in organiz-
ing many of our real-world tasks. This divide-and-conquer approach is
an important problem-solving strategy.
•Encapsulation Principle. Once the objects are identiﬁed, the next step
involves deciding, for each object, what attributes it has an d what ac-
tions it will take. The goal here is to encapsulate within eac h object
the expertise needed to carry out its role in the program. Eac h object
is a self-contained module with a clear responsibility and t he tools (at-
tributes and actions) necessary to carry out its role. Just a s a dentist
encapsulates the expertise needed to diagnose and treat a to oth ache, a
well-designed object contains the information and methods n eeded to
perform its role.
•Interface Principle. In order for objects to work cooperatively and efﬁ-
ciently, we have to clarify exactly how they should interact , orinterface ,
with one another. An object’s interface should be designed to limit the
way the object can be used by other objects. Think of how the diff erent
interfaces presented by a digital and analog watch determin e how the
watches are used. In a digital watch, time is displayed in disc rete units,
and buttons are used to set the time in hours, minutes and seco nds. In
an analog watch, the time is displayed by hands on a clock face , and
time is set, less precisely, by turning a small wheel.
•Information Hiding Principle. In order to enable objects to work to-
gether cooperatively, certain details of their individual design and per-
formance should be hidden from other objects. To use the watch anal-
ogy again, in order to use a watch we needn’t know how its time k eep-
ing mechanism works. That level of detail is hidden from us. Hi ding
such implementation details protects the watch’s mechanis m, while not
limiting its usefulness.
•Generality Principle. To make objects as generally useful as possible,
we design them not for a particular task but rather for a parti cular kind
of task. This principle underlies the use of software librar ies. As we will
see, Java comes with an extensive library of classes that spe cialize in
performing certain kinds of input and output operations. Fo r example,
rather than having to write our own method to print a message o n the
console, we can use a library object to handle our printing tas ks.
•Extensibility Principle. One of the strengths of the object-oriented ap-
proach is the ability to extend an object’s behavior to handle new tasks.
This also has its analogue in the everyday world. If a company n eeds
sales agents to specialize in hardware orders, it would be mo re eco-
nomical to extend the skills of its current sales agents inst ead of train-
ing a novice from scratch. In the same way, in the object-orient ed ap-
proach, an object whose role is to input data might be speciali zed to
input numeric data.
•Abstraction Principle. Abstraction is the ability to focus on the impor-
tant features of an object when trying to work with large amoun ts of
20 CHAPTER 0 •Computers, Objects, and Java
information. For example, if we are trying to design a ﬂoor pla n for a
kitchen, we can focus on the shapes and relative sizes of the a ppliances
and ignore attributes such as color, style, and manufacture r. The ob-
jects we design in our Java programs will be abstractions in th is sense
because they ignore many of the attributes that characteriz e the real
objects and focus only on those attributes that are essential for solving
a particular problem.
These, then, are the principles that will guide our discussi on as we learn
how to design and write object-oriented Java programs.
CHAPTER SUMMARY Technical Terms
action (behavior)
argument
attribute
class
class inheritance
class hierarchy
class method
class variable
compiler
computer programconstructor
high-level language
instance
instance method
instance variable
interpreter
method
message
object
object codeobject oriented
result
source code
subclass
superclass
Uniﬁed Modeling
Language (UML)
variable
Summary of Important Points
•A computer system generally consists of input/output devic es, pri-
mary and secondary memory, and a central processing unit. A c om-
puter can only run programs in its own machine language , which is
based on the binary code . Special programs known as compilers and in-
terpreters translate source code programs written in a high-level language ,
such as Java, into machine language object code programs.
•Application software refers to programs designed to provide a particu-
lar task or service; systems software assists the user in using application
software.
•The client/server model is a form of distributed computing in which part
of the software for a task is stored on a server and part on client comput-
ers.
•HyperText Markup Language (HTML) is the language used to encod e
WWW documents.
•A Java program is a set of interacting objects. This is the basi c
metaphor of object-oriented programming .
•Anobject in a Java program encapsulates the program’s attributes (or
variables ) and actions (ormethods ). A variable is a named memory lo-
cation where data of appropriate type can be stored. A method is a
named section of code that can be called (or invoked) when nee ded.
•An object’s methods are used to pass messages to it.
•Aclass is an abstract template that deﬁnes the characteristics and be-
haviors of all objects of a certain type.
CHAPTER 0 •Exercises 21
•An object is an instance of a class. An object has instance methods and in-
stance variables . Aclass method (orclass variable ) is a method (or variable)
that is associated with the class itself, not with its instan ces.
•Aconstructor is a special method that is used to construct objects.
•Java classes are organized into a class hierarchy , with the Object class
at the top of the hierarchy. For a given class, classes that oc cur below it
in the hierarchy are called its subclasses , while classes that occur above
it are called its superclasses .
•Classes inherit attributes and methods from their superclasses. This is
known as class inheritance .
•The main principles of the object-oriented programming appr oach are
as follows:
•Divide and Conquer: Successful problem solving involves br eaking
a complex problem into objects.
•Encapsulation and Modularity: Each object should be assigne d a
clear role.
•Public Interface: Each object should present a clear public in terface
that determines how other objects will use it.
•Information Hiding: Each object should shield its users from un nec-
essary details of how it performs its role.
•Generality: Objects should be designed to be as general as pos sible.
•Extensibility: Objects should be designed so that their func tionality
can be extended to carry out more specialized tasks.
•Abstraction is the ability to group a large quantity of information into
a single chunk so it can be managed as a single entity.
EXERCISES EXERCISE 0.1 Fill in the blanks in each of the following statements.
a. Dividing a problem or a task into parts is an example of the
principle.
b. Designing a class so that it shields certain parts of an objec t from other objects
is an example of the principle.
c. Java programs that can run without change on a wide variety of com puters is
an example of .
d. The fact that social security numbers are divided into thre e parts is an example
of the principle.
e. To say that a program is robust means that .
f. An is a separate module that encapsulates a Java program’s
attributes and actions.
EXERCISE 0.2 Explain the difference between each of the following pairs of
concepts.
a.hardware and software
b.systems and application software
c.compiler and interpreter
d.machine language and high-level language
e.general-purpose and special-purpose computer
f.primary and secondary memory
22 CHAPTER 0 •Computers, Objects, and Java
g. the CPU and the ALU
h. the Internet and the WWW
i. a client and a server
j.HTTP and HTML
k.source and object code
EXERCISE 0.3 Fill in the blanks in each of the following statements.
a. A is a set of instructions that directs a computer’s behavior.
b. A disk drive would be an example of a device.
c. A mouse is an example of an device.
d. A monitor is an example of an device.
e. The computer’s functions like a scratch pad.
f. Java is an example of a programming language.
g. The Internet is a network of .
h. The protocol used by the World Wide Web is the protocol.
i. Web documents are written in code.
j. A is a networked computer that is used to store data for other
computers on the network.
EXERCISE 0.4 Identify the component of computer hardware that is responsi-
ble for the following functions.
a. executing the fetch-execute cycle
b. arithmetic operations
c. executing instructions
d. storing programs while they are executing
e. storing programs and data when the computer is off
EXERCISE 0.5 Explain why a typical piece of software, such as a word proces-
sor, cannot run on both a Macintosh and a Windows machine.
EXERCISE 0.6 What advantages do you see in platform independence? What
are the disadvantages?
EXERCISE 0.7 In what sense is a person’s name an abstraction? In what sense
is any word of the English language an abstraction?
EXERCISE 0.8 Analyze the process of writing a research paper in terms of the
divide-and-conquer and encapsulation principles.
EXERCISE 0.9 Analyze your car by using object-oriented design principles. I n
other words, pick one of your car’s systems, such as the braking syst em, and ana-
lyze it in terms of the divide-and-conquer, encapsulation, inf ormation-hiding, and
interface principles.
EXERCISE 0.10 Make an object oriented analysis of the interaction between, a
student, librarian, and a library database when a student ch ecks a book out of a
college library.
OBJECTIVES
After studying this chapter, you will
•Know the basic steps involved in program development.
•Understand some of the basic elements of the Java language.
•Know how to use simple output operations in a Java program.
•Be able to distinguish between different types of errors in a
program.
•Understand how a Java program is translated into machine lan guage.
•Understand the difference between a Java application and a J ava
applet.
•Know how to edit, compile, and run Java programs.
OUTLINE
1.1 Introduction
1.2 Designing Good Programs
1.3 Designing a Riddle Program
Special Topic: Grace Hopper and the First Computer Bug
1.4 Java Language Elements
1.5 Editing, Compiling, and Running a Java Program
1.6 From the Java Library: System and PrintStream
1.7 From the Java Library: System and PrintStream
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 1
Java Program Design and
Development
23
24 CHAPTER 1 •Java Program Design and Development
1.1 Introduction
This chapter introduces some of the basic concepts and techn iques in-
volved in Java program design and development. We begin by id enti-
fying the main steps in designing an object-oriented program . The steps
are illustrated by designing a program that “asks” and “answ ers” riddles.
As an example of a riddle, consider the question “What is black and white
and read all over?” The answer, of course, is a newspaper. Fol lowing the
design phase, we then focus on the steps involved in coding a J ava pro-
gram, including the process of editing, compiling, and runn ing a program.
Because Java programs come in two varieties, applications a nd applets,
we describe how the coding process differs for these two vari eties.
Next we begin to familiarize ourselves with Java’s extensiv e class li-
brary by studying its PrintStream andSystem classes. These classes
contain objects and methods that enable us to print output fro m a pro-
gram. By the end of the chapter you will be able to design and wr ite a
Java application that “sings” your favorite song.
1.2 Designing Good Programs
Programming is not simply a question of typing Java code. Rat her, it in-
volves a considerable amount of planning and careful design ing. Badly
designed programs rarely work correctly. Even though it is t empting for
novice programmers to start entering code almost immediate ly, one of the
ﬁrst rules of programming is
JAVA PROGRAMMING TIP The sooner you begin to type code,
the longer the program will take to ﬁnish, because careful de sign of
the program must precede coding. This is particularly true o f
object-oriented programs.
In other words, the more thought and care you put into designin g a pro-
gram, the more likely you are to end up with one that works corr ectly. The
following subsections provide a brief overview of the progr am develop-
ment process.
1.2.1 The Software Engineering Life Cycle
Software engineering is the process of designing and writin g software.
The software life cycle refers to the different phases involved in the design
and development of a computer program. Our presentation of e xamples
in the book will focus on four phases of the overall life cycle . In the spec-
iﬁcation phase we provide a statement of the problem and a detailed de-
scription of what the program will do. In the design phase we describe
the details of the various classes, methods, and data that wi ll be used in
the program. The implementation phase refers to the actual coding of the
program into Java. In the testing phase we test the program’s performance
to make sure it is correct, recoding it or redesigning it as ne cessary.
Figure 1.1 gives a more detailed overview of the program deve lopment
process, focusing most of the attention on the design phase o f the software
SECTION 1.2 •Designing Good Programs 25
life cycle. It shows that designing an object-oriented progra m is a matter
of asking the right questions about the classes, data, and me thods that
make up the program.
Overall, the program development process can be viewed as on e that
repeatedly applies the divide-and-conquer principle. Tha t is, most pro-
gramming problems can be repeatedly divided until you have a collection
of relatively easy-to-solve subproblems, each of which can be handled by
an object. In this way the program is divided into a collection o f interact- Divide and conquer
ing objects. For each object we design a class. During class des ign, each
object is divided further into its variables and methods.
Problem Specification
What exactly is the problem?
How will the program be used?
How will the program behave?
Data Design
What types of instance variables
	 are needed?
Should they be public or private?
Algorithm Design
What information is needed?
What control structures are needed?Problem Decomposition
What objects will be used and how
	will they interact with each other?The problem is divided into
objects. For each object we
design a class.Program Development
Process
The object's role
decomposes into
tasks. Each task
can be assigned to
a method.
Method design involves
designing an algorithm.
Errors may require
recoding or
redesigning.Coding into Java
Stepwise refinement
Fixing syntax errors
Testing, Debugging, Revising
Designing test data and test cases
Fixing semantic errorsClass Design
What role or roles will the object perform?
What variables (attributes) will it need?
What methods (behaviors) will it use?
What interface will it present?
What information will it hide?
Method Design
What task will the method perform?
What information will it need?
What algorithm will it use?
What result will it produce?Figure 1.1: An overview of the
program development process.
When should we stop subdividing? How much of a task should be
assigned to a single object or a single method? The answers to t hese and
similar questions are not easy. Good answers require the kin d of judg-
ment that comes through experience, and frequently there is more than
one good way to design a solution. Here again, as we learn more a bout
26 CHAPTER 1 •Java Program Design and Development
object-oriented programming, we’ll learn more about how to m ake these
design decisions.
1.3 Designing a Riddle Program
The ﬁrst step in the program-development process is making s ure you un-
derstand the problem (Fig. 1.1). Thus, we begin by developin g a detailed
speciﬁcation, which should address three basic questions:
•What exactly is the problem to be solved?
•How will the program be used?
•How should the program behave?
In the real world, the problem speciﬁcation is often arrived a t through
an extensive discussion between the customer and the develo per. In an
introductory programming course, the speciﬁcation is usua lly assigned
by the instructor.
To help make these ideas a little clearer, let’s design an obje ct-oriented
solution to a simple problem.
Problem Speciﬁcation. Design a class that will represent a riddle with
a given question and answer. The deﬁnition of this class shou ld make
it possible to store different riddles and to retrieve a ridd le’s question
and answer independently.
1.3.1 Problem Decomposition
Most problems are too big and too complex to be tackled all at o nce. So
the next step in the design process is to divide the problem in to parts that Divide and conquer
make the solution more manageable. In the object-oriented app roach, a
problem is divided into objects, where each object will handle one speciﬁc
aspect of the program’s overall job. In effect, each object will become an
expert or specialist in some aspect of the program’s overall behavior.
Note that there is some ambiguity here about how far we should go
in decomposing a given program. This ambiguity is part of the design
process. How much we should decompose the program before its p arts
become “simple to solve” depends on the problem we’re trying to solve
and on the problem solver.
One useful design guideline for trying to decide what objects are
needed is the following:
JAVA EFFECTIVE DESIGN Looking for Nouns. Choosing a
program’s objects is often a matter of looking for nouns in the problem
speciﬁcation.
Again, there’s some ambiguity involved in this guideline. F or example,
the key noun in our current problem is riddle , so our solution will involve
an object that serves as a model for a riddle. The main task of th is Java
SECTION 1.3 •Designing a Riddle Program 27
object will be simply to represent a riddle. Two other nouns in the spec-
iﬁcation are question and answer . Fortunately, Java has built-in String
objects that represent strings of characters such as words or sentences. We
can use two String objects for the riddle’s question and answer. Thus,
for this simple problem, we need only design one new type of ob ject—a
riddle—whose primary role will be to represent a riddle’s que stion and
answer.
Don’t worry too much if our design decisions seem somewhat my ste-
rious at this stage. A good understanding of object-oriented design can
come only after much design experience, but this is a good pla ce to start.
1.3.2 Object Design
Once we have divided a problem into a set of cooperating object s, de-
signing a Java program is primarily a matter of designing and creating
the objects themselves. In our example, this means we must now d esign
the features of our riddle object. For each object, we must answ er the
following basic design questions:
•What role will the object perform in the program?
•What data or information will it need?
•What actions will it take?
•What interface will it present to other objects?
•What information will it hide from other objects?
For our riddle object, the answers to these questions are show n in Fig-
ure 1.2. Note that although we talk about “designing an object ,” we are
really talking about designing the object’s class. A class de ﬁnes the col-
lection of objects that belong to it. The class can be consider ed the ob-
ject’s type. This is the same as for real-world objects. Thus, Seabiscuit is a
horse—that is, Seabiscuit is an object of type horse. Similarl y, an individ-
ual riddle, such as the newspaper riddle, is a riddle. That is , it is an object
of type Riddle.
The following discussion shows how we arrived at the decisio ns for the
design speciﬁcations for the Riddle class, illustrated in Figure 1.2.
•Class Name: Riddle
•Role: To store and retrieve a question and answer
•Attributes (Information)
•question: A variable to store a riddle’s question (private)
•answer: A variable to store a riddle’s answer (private)
•Behaviors
•Riddle(): A method to set a riddle’s question and answer
•getQuestion(): A method to return a riddle’s question
•getAnswer(): A method to return a riddle’s answerFigure 1.2: Design speciﬁcation
for the Riddle class.
The role of the Riddle object is to model an ordinary riddle. Because What is the object’s role?
a riddle is deﬁned in terms of its question and answer, our Riddle ob-
ject will need some way to store these two pieces of informatio n. As we
learned in Chapter 0, an instance variable is a named memory l ocation that
belongs to an object. The fact that the memory location is name d, makes
28 CHAPTER 1 •Java Program Design and Development
it easy to retrieve the data stored there by invoking the vari able’s name.
For example, to print a riddle’s question we would say someth ing like
“print question,” and whatever is stored in question would be retrieved
and printed.
In general, instance variables are used to store the informat ion that an
object needs to perform its role. They correspond to what we ha ve been What information will the object
need? calling the object’s attributes. Deciding on these variable s provides the
answer to the question, “What information does the object need ?”
Next we decide what actions a Riddle object will take. A useful design
guideline for actions of objects is the following:
JAVA EFFECTIVE DESIGN Looking for Verbs. Choosing the
behavior of an object is often a matter of looking for verbs in t he
problem speciﬁcation.
What actions will the object take?
For this problem, the key verbs are setand retrieve . As speciﬁed in Fig-
ure 1.2, each Riddle object should provide some means of setting the
values of its question and answer variables and a means of ret rieving each
value separately.
Each of the actions we have identiﬁed will be encapsulated in a Java
method. As you recall from Chapter 0, a method is a named secti on of
code that can be invoked , or called upon, to perform a particular action.
In the object-oriented approach, calling a method (method inv ocation) is
the means by which interaction occurs among objects. Calling a method
is like sending a message between objects. For example, when w e want to
get a riddle’s answer, we would invoke the getAnswer() method. This
is like sending the message “Give me your answer.” One specia l method,
known as a constructor, is invoked when an object is ﬁrst creat ed. We will
use the Riddle() constructor to give speciﬁc values to riddle’s question
and answer variables.
In designing an object, we must decide which methods should be m ade
available to other objects. This determines what interface t he object should What interface will it present, and
what information will it hide? present and what information it should hide from other object s. In gen-
eral, those methods that will be used to communicate with an o bject are
designated as part of the object’s interface. Except for its i nterface, all
other information maintained by each riddle should be kept “ hidden”
from other objects. For example, it is not necessary for other objects to
know where a riddle object stores its question and answer. The fact that
they are stored in variables named question andanswer , rather than
variables named ques andans, is irrelevant to other objects.
JAVA EFFECTIVE DESIGN Object Interface. An object’s interface
should consist of just those methods needed to communicate wi th or
to use the object.
JAVA EFFECTIVE DESIGN Information Hiding. An object should
hide most of the details of its implementation.
SECTION 1.3 •Designing a Riddle Program 29
Taken together, these various design decisions lead to the s peciﬁcation
FIGURE 1.3 A UML class diagram
representing the Riddle class.shown in Figure 1.3. As our discussion has illustrated, we ar rived at the
decisions by asking and answering the right questions. In mos t classes the
attributes (variables) are private. This is represented by a minus sign ( −).
In this example, the operations (methods) are public, which i s represented
by the plus sign ( +). The ﬁgure shows that the Riddle class has two
hidden (or private) variables for storing data and three vis ible (or public)
methods that represent the operations that it can perform.
1.3.3 Data, Methods, and Algorithms
Among the details that must be worked out in designing a riddl e object is
deciding what type of data, methods, and algorithms we need. There are
two basic questions involved:
•What type of data will be used to represent the information nee ded by
the riddle?
•How will each method carry out its task?
Like other programming languages, Java supports a wide rang e of differ-
ent types of data, some simple and some complex. Obviously a r iddle’s What type of data will be used?
question and answer should be represented by text. As we note d earlier,
Java has a String type, which is designed to store text, which can be
considered a string of characters.
In designing a method, you have to decide what the method will d o. In How will each method carry out its
task? order to carry out its task, a method will need certain inform ation, which
it may store in variables. Plus, it will have to carry out a seq uence of
individual actions to perform the task. This is called its algorithm , which
is a step-by-step description of the solution to a problem. A nd, ﬁnally, you
must decide what result the method will produce. Thus, as in d esigning
objects, it is important to ask the right questions:
•What speciﬁc task will the method perform?
•What information will it need to perform its task?
•What algorithm will the method use?
•What result will the method produce?
Methods can be thought of as using an algorithm to complete a r equired
action. The algorithm required for the Riddle() constructor is very sim-
ple but also typical of constructors for many classes. It take s two strings
and assigns the ﬁrst to the question instance variable and then assigns
the second to the answer instance variable. The algorithms for the other
two methods for the Riddle class are even simpler. They are re ferred to
asgetmethods that merely return or produce the value that is currently
stored in an instance variable.
Not all methods are so simple to design, and not all algorithm s are so
simple. Even when programming a simple arithmetic problem, the steps Algorithm design
involved in the algorithm will not always be as obvious as the y are when
doing the calculation by hand. For example, suppose the prob lem were
to calculate the sum of a list of numbers. If we were telling our classmate
how to do this problem, we might just say, “add up all the number s and
report their total.” But this description is far too vague to be used in a
program. By contrast, here’s an algorithm that a program cou ld use:
30 CHAPTER 1 •Java Program Design and Development
1. Set the initial value of the sum to 0.
2. If there are no more numbers to total, go to step 5.
3. Add the next number to the sum.
4. Go to step 2.
5. Report the sum.
Note that each step in this algorithm is simple and easy to fol low. It would
be relatively easy to translate it into Java. Because Englis h is somewhat
imprecise as an algorithmic language, programmers frequen tly write al-
gorithms in the programming language itself or in pseudocode , a hy- Pseudocode
brid language that combines English and programming langua ge struc-
tures without being too fussy about programming language sy ntax. For
example, the preceding algorithm might be expressed in pseu docode as
follows:
☛ ✟
sum = 0
while ( more numbers remain )
add next number to sum
p r i n t the sum
✡ ✠
Of course, it is unlikely that an experienced programmer wou ld take
the trouble to write out pseudocode for such a simple algorit hm. But
many programming problems are quite complex and require car eful de-
sign to minimize the number of errors that the program contai ns. In such
situations, pseudocode could be useful.
Another important part of designing an algorithm is to trace it—that is,
to step through it line by line—on some sample data. For exampl e, we
might test the list-summing algorithm by tracing it on the li st of numbers
shown in the margin.Sum List of Numbers
0 54 30 20
54 30 20
84 20
104 -Initially, the sum starts out at 0 and the list of numbers conta ins 54,
30, and 20. On each iteration through the algorithm, the sum i ncreases
by the amount of the next number, and the list diminishes in si ze. The
algorithm stops with the correct total left under the sum col umn. While
this trace didn’t turn up any errors, it is frequently possib le to ﬁnd ﬂaws
in an algorithm by tracing it in this way.
1.3.4 Coding into Java
Once a sufﬁciently detailed design has been developed, it is time to start
generating Java code. The wrong way to do this would be to type the en-
tire program and then compile and run it. This generally lead s to dozens
of errors that can be both demoralizing and difﬁcult to ﬁx.
The right way to code is to use the principle of stepwise reﬁnement .
The program is coded in small stages, and after each stage the code is Stepwise reﬁnement
compiled and tested. For example, you could write the code fo r a single
method and test that method before moving on to another part o f the pro-
gram. In this way, small errors are caught before moving on to t he next
stage.
The code for the Riddle class is shown in Figure 1.4. Even though
we have not yet begun learning the details of the Java languag e, you
can easily pick out the key parts in this program: the instanc e variables
SECTION 1.3 •Designing a Riddle Program 31
☛ ✟
/∗
∗F i l e : R i d d l e . j a v a
∗A u t h o r : J a v a , J a v a , J a v a
∗D e s c r i p t i o n : D e f i n e s a s i m p l e r i d d l e .
∗/
public c l a s s Riddle extends Object // C l a s s h e a d e r
{ // B e g i n c l a s s b o d y
private S t r i n g question ; // I n s t a n c e v a r i a b l e s
private S t r i n g answer ;
public Riddle ( S t r i n g q , S t r i n g a ) // C o n s t r u c t o r m e t h o d
{
question = q ;
answer = a ;
}// R i d d l e ( )
public S t r i n g getQuestion ( ) // I n s t a n c e m e t h o d
{
return question ;
}// g e t Q u e s t i o n ( )
public S t r i n g getAnswer ( ) // I n s t a n c e m e t h o d
{
return answer ;
}// g e t A n s w e r ( )
}// R i d d l e c l a s s // E n d c l a s s b o d y
✡ ✠
Figure 1.4: The Riddle class deﬁnition.
question andanswer of type String , which are used to store the
riddle’s data; the Riddle() constructor and the getQuestion() and
getAnswer() methods make up the interface. The speciﬁc language de-
tails needed to understand each of these elements will be cov ered in this
and the following chapter.
1.3.5 Syntax and Semantics
Writing Java code requires that you know its syntax and seman tics. A
language’s syntax is the set of rules that determines whether a partic- Syntax
ular statement is correctly formulated. As an example of a sy ntax rule,
consider the following two English statements:
☛ ✟
The r a i n in Spain f a l l s mainly on the plain . // V a l i d
Spain r a i n the mainly in on the f a l l s plain . // I n v a l i d
✡ ✠
The ﬁrst sentence follows the rules of English syntax (gramm ar), and it
means that it rains a lot on the Spanish plain. The second sent ence does
not follow English syntax, and, as a result, it is rendered me aningless. An
example of a Java syntax rule is that a Java statement must end with a
semicolon.
32 CHAPTER 1 •Java Program Design and Development
However, unlike in English, where one can still be understood even
when one breaks a syntax rule, in a programming language the s yntax
rules are very strict. If you break even the slightest syntax r ule—for ex-
ample, if you forget just a single semicolon—the program won’t work at
all.
Similarly, the programmer must know the semantics of the language— Semantics
that is, the meaning of each statement. In a programming langu age, a
statement’s meaning is determined by what effect it will hav e on the pro-
gram. For example, to set the sum to 0 in the preceding algorithm, an as-
signment statement is used to store the value 0 into the memor y location
named sum. Thus, we say that the statement
☛ ✟
sum = 0 ;
✡ ✠
assigns 0 to the memory location sum, where it will be stored until some
other part of the program needs it.
Learning Java’s syntax and semantics is a major part of learni ng to
program. This aspect of learning to program is a lot like lear ning a for-
eign language. The more quickly you become ﬂuent in the new lan guage
(Java), the better you will be at expressing solutions to int eresting pro-
gramming problems. The longer you struggle with Java’s rule s and con-
ventions, the more difﬁcult it will be to talk about problems in a common
language. Also, computers are a lot fussier about correct la nguage than
humans, and even the smallest syntax or semantic error can ca use tremen-
dous frustration. So, try to be very precise in learning Java ’s syntax and
semantics.
1.3.6 Testing, Debugging, and Revising
Coding, testing, and revising a program is an repetitive pro cess, one
that may require you to repeat the different program-develo pment stages
shown in (Fig. 1.1). According to the stepwise-reﬁnement pr inciple, the
process of developing a program should proceed in small, inc remental
steps, where the solution becomes more reﬁned at each step. Ho wever,
no matter how much care you take, things can still go wrong dur ing the
coding process.
Asyntax error is an error that breaks one of Java’s syntax rules. Such er-
rors will be detected by the Java compiler. Syntax errors are relatively easy Syntax errors
to ﬁx once you understand the error messages provided by the c ompiler.
As long as a program contains syntax errors, the programmer m ust correct
them and recompile the program. Once all the syntax errors ar e corrected,
the compiler will produce an executable version of the progr am, which
can then be run.
When a program is run, the computer carries out the steps speci ﬁed
in the program and produces results. However, just because a pr ogram
runs does not mean that its actions and results are correct. A running
program can contain semantic errors , also called logic errors . A semantic Semantic errors
error is caused by an error in the logical design of the progra m causing it
to behave incorrectly, producing incorrect results.
SECTION 1.3 •Designing a Riddle Program 33
Unlike syntax errors, semantic errors cannot be detected au tomatically.
For example, suppose that a program contains the following s tatement for
calculating the area of a rectangle:
☛ ✟
return length + width ;
✡ ✠
Because we are adding length and width instead of multiplyin g them,
the area calculation will be incorrect. Because there is not hing syntacti-
cally wrong with the expression length + width , the compiler won’t
detect an error in this statement. Thus, the computer will st ill execute this
statement and compute the incorrect area.
Semantic errors can only be discovered by testing the progra m and they
are sometimes very hard to detect. Just because a program app ears to run
correctly on one test doesn’t guarantee that it contains no s emantic errors.
It might just mean that it has not been adequately tested.
Fixing semantic errors is known as debugging a program, and when sub-
tle errors occur it can be the most frustrating part of the who le program
development process. The various examples presented will o ccasionally
provide hints and suggestions on how to track down bugs , or errors, in
your code. One point to remember when you are trying to ﬁnd a ve ry sub-
tle bug is that no matter how convinced you are that your code i s correct
and that the bug must be caused by some kind of error in the comp uter,
the error is almost certainly caused by your code!
1.3.7 Writing Readable Programs
Becoming a proﬁcient programmer goes beyond simply writing a pro-
gram that produces correct output. It also involves developi ng good pro- Programming style
gramming style , which includes how readable and understandable your
code is. Our goal is to help you develop a programming style th at satisﬁes
the following principles:
•Readability. Programs should be easy to read and understand. Com-
ments should be used to document and explain the program’s co de.
•Clarity. Programs should employ well-known constructs and standard
conventions and should avoid programming tricks and unnece ssarily
obscure or complex code.
•Flexibility. Programs should be designed and written so that they are
easy to modify.
Special Topic: Grace Hopper and
the First Computer Bug
Rear Admiral Grace Murray Hopper (1906–1992) was a pioneer computer
programmer and one of the original developers of the COBOL pr ogram-
ming language, which stands for COmmon Business- Oriented Language.
Among her many achievements and distinctions, Admiral Hoppe r also
had a role in coining the term computer bug .
In August 1945, she and a group of other programmers were worki ng
on the Mark I, an electro-mechanical computer developed at Har vard that
34 CHAPTER 1 •Java Program Design and Development
was one of the ancestors of today’s electronic computers. Af ter several
hours of trying to ﬁgure out why the machine was malfunctioni ng, some-
one located and removed a two-inch moth from one of the comput er’s
circuits. From then on whenever anything went wrong with a co mputer,
Admiral Hopper and others would say “it had bugs in it.” The ﬁrs t bug
itself is still taped to Admiral Hopper’s 1945 log book, which is now in the
collection of the Naval Surface Weapons Center.
In 1991, Admiral Hopper was awarded the National Medal of Tech-
nology by President George Bush. To commemorate and honor Ad miral
Hopper’s many contributions, the U.S. Navy recently named a w arship
after her. For more information on Admiral Hopper, see the Web site at
☛ ✟
http : // w w w. chips . navy . mil/
✡ ✠
1.4 Java Language Elements
In this section we will introduce some of the key elements of th e Java
language by describing the details of a small program. We wil l look at how
a program is organized and what the various parts do. Our inte nt is to
introduce important language elements, many of which will b e explained
in greater detail in later sections.
The program we will study is a Java version of the traditional Hel-
loWorld program—”traditional” because practically every i ntroductory
programming text begins with it. When it is run, the HelloWorld program
(Fig. 1.5) just displays the greeting “Hello World!” on the con sole.
☛ ✟
1 /∗
2 ∗F i l e : H e l l o W o r l d . j a v a
3 ∗A u t h o r : J a v a J a v a J a v a
4 ∗D e s c r i p t i o n : P r i n t s H e l l o W o r l d g r e e t i n g .
5 ∗/
6 public c l a s s HelloWorld extends Object // C l a s s h e a d e r
7{ // S t a r t c l a s s b o d y
8 private S t r i n g g r e e t i n g = ” Hello World ! ” ;
9 public void g r e e t ( ) // M e t h o d d e f i n i t i o n
10 { // S t a r t m e t h o d b o d y
11 System . out . p r i n t l n ( g r e e t i n g ) ; // O u t p u t s t a t e m e n t
12 }// g r e e t ( ) // E n d m e t h o d b o d y
13 public s t a t i c void main ( S t r i n g args [ ] ) // M e t h o d h e a d e r
14{
15 HelloWorld helloworld ; // d e c l a r e
16 helloworld = new HelloWorld ( ) ; // c r e a t e
17 helloworld . g r e e t ( ) ; // M e t h o d c a l l
18 } // m a i n ( )
19} // H e l l o W o r l d // E n d c l a s s b o d y
✡ ✠
Figure 1.5: The HelloWorld application program.
SECTION 1.4 •Java Language Elements 35
1.4.1 Comments
The ﬁrst thing to notice about the HelloWorld program is the use of com-
ments. A comment is a non-executable portion of a program that is used
to document the program. Because comments are not executabl e instruc-
tions they are just ignored by the compiler. Their sole purpos e is to make
the program easier for the programmer to read and understand .
TheHelloWorld program contains examples of two types of Java
comments. Any text contained within /* and */ is considered a comment.
As you can see in HelloWorld , this kind of comment can extend over
several lines and is sometimes called a multiline comment. A second type
of comment is any text that follows double slashes (//) on a li ne. This is
known as a single-line comment because it cannot extend beyond a single
line.
When the compiler encounters the beginning marker (/*) of a mu ltiline
comment, it skips over everything until it ﬁnds a matching en d marker
(*/). One implication of this is that it is not possible to put one multiline
comment inside of another. That is, one comment cannot be nested , or con-
tained, within another comment. The following code segment illustrates
the rules that govern the use of /* and */:
☛ ✟
/∗T h i s f i r s t c o m m e n t b e g i n s a n d e n d s o n t h e s a m e l i n e . ∗/
/∗A s e c o n d c o m m e n t s t a r t s o n t h i s l i n e . . .
a n d g o e s o n . . .
a n d t h i s i s t h e l a s t l i n e o f t h e s e c o n d c o m m e n t .
∗/
/∗A t h i r d c o m m e n t s t a r t s o n t h i s l i n e . . .
/∗T h i s i s NOT a f o u r t h c o m m e n t . I t i s j u s t
p a r t o f t h e t h i r d c o m m e n t .
And t h i s i s t h e l a s t l i n e o f t h e t h i r d c o m m e n t .
∗/
∗/ This i s an e r r o r because i t i s an unmatched end marker .
✡ ✠
As you can see from this example, it is impossible to begin a ne w com-
ment inside an already-started comment because all text ins ide the ﬁrst
comment, including /*, is ignored by the compiler.
JAVA LANGUAGE RULE Comments. Any text contained within
/* and */, which may span several lines, is considered a comme nt and
is ignored by the compiler. Inserting double slashes (//) int o a line
turns the rest of the line into a comment.
Multiline comments are often used to create a comment block that pro-
vides useful documentation for the program. In HelloWorld , the pro-
gram begins with a comment block that identiﬁes the name of ﬁl e that
contains the program and its author and provides a brief desc ription of
what the program does.
For single-line comments, double slashes (//) can be insert ed any-
where on a line of code. The result is that the rest of the line i s ignored by Single-line comment
36 CHAPTER 1 •Java Program Design and Development
the compiler. We use single-line comments throughout the HelloWorld
program to provide a running commentary of its language elem ents.
JAVA PROGRAMMING TIP Use of Comments. A well-written
program should begin with a comment block that provides the n ame
of the program, its author, and a description of what the prog ram does.
1.4.2 Program Layout
Another thing to notice about the program is how neatly it is a rranged
on the page. This is done deliberately so that the program is e asy to read
and understand. In Java, program expressions and statements may be ar-
ranged any way the programmer likes. They may occur one per li ne, sev-
eral per line, or one per several lines. But the fact that the r ules governing
the layout of the program are so lax makes it all the more impor tant that
we adopt a good programming style, one that will help make pro grams
easy to read.
So look at how things are presented in HelloWorld . Notice how
beginning and ending braces, and , are aligned, and note how w e use
single-line comments to annotate ending braces. Braces are used to mark
the beginning and end of different blocks of code in a Java pro gram and
it can sometimes be difﬁcult to know which beginning and end b races
are matched up. Proper indentation and the use of single-lin e comments
make it easier to determine how the braces are matched up.
Similarly, notice how indentation is used to show when one el ement
of the program is contained within another element. Thus, th e elements
of theHelloWorld class are indented inside of the braces that mark the
beginning and end of the class. And the statements in the main() method
are indented to indicate that they belong to that method. Use of indenta-
tion in this way, to identify the program’s structure, makes the program
easier to read and understand.
JAVA PROGRAMMING TIP Use of Indentation. Indent the code
within a block and align the block’s opening and closing brac es. Use a
comment to mark the end of a block of code.
1.4.3 Keywords and Identiﬁers
The Java language contains 48 predeﬁned keywords (Table 1.1). These
are words that have special meaning in the language and whose use is
reserved for special purposes. For example, the keywords us ed in the
HelloWorld program (Fig. 1.5) are: class ,extends ,private ,public ,
static , andvoid .
Because their use is restricted, keywords cannot be used as t he names
of methods, variables, or classes. However, the programmer c an make up
his or her own names for the classes, methods, and variables t hat occur in
the program, provided that certain rules and conventions ar e followed.
SECTION 1.4 •Java Language Elements 37
TABLE 1.1 Java keywords.
abstract default goto package this
boolean do if private throw
break double implements protected throws
byte enum import public transient
case elses instanceof return try
catch extend int short void
char final interface static volatile
class finally long super while
const float native switch
continue for new synchronized
The names for classes, methods, and variables are called ide ntiﬁers,
which follow certain syntax rules: syntax
JAVA LANGUAGE RULE Identiﬁer. Anidentiﬁer must begin with
a capital or lowercase letter and may be followed by any numbe r of
letters, digits, underscores ( ), or dollar signs ($). An identiﬁer may not
be identical to a Java keyword.
Names in Java are case sensitive , which means that two different identiﬁers
may contain the same letters in the same order. For example, thisVar
andThisVar are two different identiﬁers.
In addition to the syntax rule that governs identiﬁers, Java p rogrammers Identiﬁer style
follow certain style conventions in making up names for clas ses, vari-
ables, and methods. By convention, class names in Java begin with a
capital letter and use capital letters to distinguish the in dividual words
in the name—for example, HelloWorld andTextField . Variable and Java naming conventions
method names begin with a lowercase letter but also use capit al letters
to distinguish the words in the name—for example, main() ,greeting ,
greet() ,getQuestion() , andgetAnswer() . The advantage of this
convention is that it is easy to distinguish the different el ements in a
program—classes, methods, variables—just by how they are writ ten. (For
more on Java style conventions, see Appendix A.).
Another important style convention followed by Java progra mmers
is to choose descriptive identiﬁers when naming classes, va riables, and
methods. This helps to make the program more readable.
JAVA PROGRAMMING TIP Choice of Identiﬁers. To make your
program more readable, choose names that describe the purpo se of the
class, variable, or method.
1.4.4 Data Types and Variables
A computer program wouldn’t be very useful if it couldn’t man ipulate
different kinds of data, such as numbers and strings. The ope rations that
one can do on a piece of data depend on the data’s type. For exam ple, you
can divide and multiply numbers, but you cannot do this with s trings.
38 CHAPTER 1 •Java Program Design and Development
Thus, every piece of data in a Java program is classiﬁed accor ding to its
data type .
Broadly speaking, there are two categories of data in Java: v arious
types of objects and eight different types of built-in primitive data types .
In addition to new types of objects that are created by programm ers, Java
has many different types of built-in objects. Two types that w e will en-
counter in this chapter are the String andPrintStream objects. Java’s
primitive types include three integer types, three real num ber types, a Primitive types
character type, and a boolean type with values true and false . The names
of the primitive types are keywords like int for one integer type, double
for one real number type, and boolean .
As we noted in Chapter 0, a variable is a named storage locatio n that
can store a value of a particular type. Practically speaking , you can think
of a variable as a special container into which you can place v alues, but
only values of a certain type (Fig. 1.6). For example, an int variable
can store values like 5 or -100. A String variable can store values like
“Hello”. (Actually, this is not the full story, which is a litt le more compli-
cated, but we will get to that in Chapter 2.)
In the HelloWorld class, the instance variable greeting (line 8)
FIGURE 1.6 Variables are like typed
containers.stores a value of type String . In the main() method, the variable
helloworld is assigned a HelloWorld object (line 16).
Aliteral value is an actual value of some type that occurs in a program.
For example, a string enclosed in double quotes, such as ”Hell o World!”, is
known as a String literal. A number such as 45.2 would be an example
of a literal of type double , and -72 would be an example of a literal of
typeint. Our HelloWorld program contains just a single literal value,
the ”HelloWorld!” String .
1.4.5 Statements
A Java program is a collection of statements. A statement is a segment of Executing a program
code that takes some action in the program. As a program runs, we say
itexecutes statements, meaning it carries out the actions speciﬁed by t hose
statements. In our HelloWorld program, statements of various types
occur on lines 8, 11, 15, 16, and 17. Notice that all of these li nes end with a
semicolon. The rule in Java is that statements must end with a semicolon.
Forgetting to do so would cause a syntax error.
Adeclaration statement is a statement that declares a variable of a par-
ticular type. In Java, a variable must be declared before it ca n be used in a
program. Failure to do so would cause a syntax error. In its sim plest form,
a declaration statement begins with the variable’s type, wh ich is followed Declaration statement
by the variable’s name, and ends with a semicolon:
Type VariableName ;
A variable’s type is either one of the primitive types we ment ioned, such
asint,double , orboolean , or for objects, it is the name of the object’s
class, such as String orHelloWorld . A variable’s name may be any
legal identiﬁer, as deﬁned earlier, although the conventio n in Java is to be-
SECTION 1.4 •Java Language Elements 39
gin variable names with a lowercase letter. In our HelloWorld program,
an example a simple declaration statement occurs on line 15:
☛ ✟
HelloWorld helloworld ;
✡ ✠
This example declares a variable for an object. The variable’ s name is
helloworld and its type is HelloWorld , the name of the class that is
being deﬁned in our example. To take another example the foll owing
statements declare two int variables, named int1 andint2 :
☛ ✟
i n t i n t 1 ;
i n t i n t 2 ;
✡ ✠
As we noted, an int is one of Java’s primitive types and the word intis a
Java keyword.
Without going into too much detail at this point, declaring a variable
causes the program to set aside enough memory for the type of d ata that
will be stored in that variable. So in this example, Java woul d reserve
enough space to store an int.
Anassignment statement is a statement that stores (assigns) a value
in a variable. An assignment statement uses the equal sign ( =) as an as-
signment operator. In its simplest form, an assignment state ment has a
variable on the left hand side of the equals sign and some type of value on
the right hand side. Like other statements, an assignment st atement ends
with a semicolon:
VariableName =Value ;
When it executes an assignment statement, Java will ﬁrst dete rmine what
value is given on the right hand side and then assign (store) t hat value to
(in) the variable on the left hand side. Here are some simple ex amples:
FIGURE 1.7 This illustrates how
the state of the variables num1 and
num2 changes over the course of the
three assignments, (a), (b), (c), given
in the text.☛ ✟
g r e e t i n g = ” Hello World” ;
num1 = 5 0 ; // ( a ) A s s i g n 5 0 t o num1
num2 = 10 + 1 5 ; // ( b ) A s s i g n 2 5 t o num2
num1 = num2 ; // ( c ) C o p y num2 ’ s v a l u e ( 2 5 ) i n t o num1
✡ ✠
In the ﬁrst case, the value on the right hand side is the string l iteral ”Hello
World!”, which gets stored in greeting . Of course, greeting has to be
the right type of container–in this case, a String variable. In the next
case, the value on the right hand side is 50. So that is the valu e that gets
stored in num1 , assuming that num1 is anint variable. The situation
after this assignment is shown in the top drawing in Figure 1. 7. In the
third case, the value on the right hand side is 25, which is det ermined
by adding 10 and 15. So the value that gets assigned to num2 is 25. After
this assignment we have the situation shown in the middle dra wing in the
ﬁgure. Of course, this assumes that num2 is anint variable. In the last
case, the value on the right hand side is 25, the value that we ju st stored in
the variable num2 . So, 25 gets stored in num1 . This is the bottom drawing
in the accompanying ﬁgure.
40 CHAPTER 1 •Java Program Design and Development
The last of these examples
☛ ✟
num1 = num2 ; // C o p y num2 ’ s v a l u e i n t o num1
✡ ✠
can be confusing to beginning programmers, so it is worth som e addi-
tional comment. In this case, there are variables on both the l eft and right
of the assignment operator. But they have very different mea ning. The
variable on the right is treated as a value. If that variable is storing 25,
then that is its value. In fact, whatever occurs on the right ha nd side of an
assignment operator is treated as a value. The variable on th e left hand
side is treated as a memory location. It is where the value 25 wi ll be stored
as a result of executing this statement. The effect of this st atement is to
copy the value stored in num2 into num1 , as illustrated in Figure 1.8.
FIGURE 1.8 In the assignment
num1 = num2; ,num2 ’s value is copied
into num1 .Java has many other kinds of statements and we will be learnin g
about these in subsequent examples. The following examples from the
HelloWorld program are examples of statements in which a method is
called:
☛ ✟
System . out . p r i n t l n ( g r e e t i n g ) ; // C a l l p r i n t l n ( ) m e t h o d
helloworld . g r e e t ( ) ; // C a l l g r e e t ( ) m e t h o d
✡ ✠
We will discuss these kinds of statements in greater detail a s we go along.
One ﬁnal type of statement that should be mentioned at this po int is the
compound statement (orblock ), which is a sequence of statements con-
tained within braces (). We see three examples of this in the HelloWorld
program. The body of a class deﬁnition extends from lines 7 th rough 19.
The body of the greet() method is a block that extends from lines 10
through 12. The body of the main() method is a block that extends from
lines 14 to 19.
1.4.6 Expressions and Operators
The manipulation of data in a program is done by using some kin d of ex-
pression that speciﬁes the action. An expression is Java code that speciﬁes
or produces a value in the program. For example, if you want to add two
numbers, you would use an arithmetic expression, such as num1+num2. If
you want to compare two numbers, you would use a relation expr ession
such asnum1<num2. As you can see, these and many other expressions
in Java involve the use of special symbols called operators . Here we see
the addition operator ( +) and the less-than operator ( <). We have already
talked about the assignment operator ( =).
Java expressions and operators have a type that depends on th e type
of data that is being manipulated. For example, when adding t woint
values, such as 5+10, the expression itself produces an int result. When
comparing two numbers with the less than operator, num1<num2, the
expression itself produces a boolean type, either true or false.
SECTION 1.4 •Java Language Elements 41
It is important to note that expressions cannot occur on their own.
Rather they occur as part of the program’s statements. Here ar e some
additional examples of expressions:
☛ ✟
num = 7 // An a s s i g n m e n t e x p r e s s i o n o f t y p e i n t
num = square ( 7 ) // An m e t h o d c a l l e x p r e s s i o n o f t y p e i n t
num == 7 // An e q u a l i t y e x p r e s s i o n o f t y p e b o o l e a n
✡ ✠
The ﬁrst of these is an assignment expression. It has a value of 7, because
it is assigning 7tonum. The second example is also an assignment expres-
sion, but this one has a method call, square(7) , on its right hand side.
(We can assume that a method named square() has been appropriately
deﬁned in the program.) A method call is just another kind of ex pression.
In this case, it has the value 49. Note that an assignment expre ssion can
be turned into a stand-alone assignment statement by placin g a semicolon
after it.
The third expression is an equality expression, which has th e value
true , assuming that the variable on its left is storing the value 7 . It is
important to note the difference between the assignment ope rator (=) and
the equality operator ( ==).
JAVA LANGUAGE RULE Equality and Assignment. Be careful not
to confuse =and==. The symbol =is the assignment operator. It
assigns the value on its right-hand side to the variable on it s left-hand
side. The symbol ==is the equality operator. It evaluates whether the
expressions on its left- and right-hand sides have the same v alue and
returns either true orfalse .
SELF-STUDY EXERCISES
EXERCISE 1.1 What is stored in the variable num after the following
two statements are executed?
int num = 11;
num = 23 - num;
EXERCISE 1.2 Write a statement that will declare a variable of type int
callednum2 , and store in it the sum of 711 and 712.
1.4.7 Class Deﬁnition
A Java program consists of one or more class deﬁnitions. In the
HelloWorld example, we are deﬁning the HelloWorld class, but there
are also three predeﬁned classes involved in the program. Th ese are the
Object ,String , andSystem classes all of which are deﬁned in the
Java class library. Predeﬁned classes, such as these, can be used in any
program.
As the HelloWorld program’s comments indicate, a class deﬁnition
has two parts: a class header and a class body . In general, a class header Class header
takes the following form, some parts of which are optional ( opt):
ClassModiﬁersoptclass ClassName Pedigreeopt
42 CHAPTER 1 •Java Program Design and Development
The class header for the HelloWorld class is:
☛ ✟
public c l a s s HelloWorld extends Object
✡ ✠
The purpose of the header is to give the class its name ( HelloWorld ),
identify its accessibility ( public as opposed to private ), and describe
where it ﬁts into the Java class hierarchy (as an extension of theObject
class). In this case, the header begins with the optional acce ss modi-
ﬁer,public , which declares that this class can be accessed by any other
classes. The next part of the declaration identiﬁes the name of the class,
HelloWorld . And the last part declares that HelloWorld is a subclass
of theObject class. We call this part of the deﬁnition the class’s pedigre e.
As you recall from Chapter 0, the Object class is the top class of the
entire Java hierarchy. By declaring that HelloWorld extends Object ,
we are saying that HelloWorld is a direct subclass ofObject . In fact, it
is not necessary to declare explicitly that HelloWorld extends Object
because that is Java’s default assumption. That is, if you om it the extends
clause in the class header, Java will automatically assume t hat the class is
a subclass of Object .
The class’s body, which is enclosed within curly brackets () , contains Class body
the declaration and deﬁnition of the elements that make up th e objects of
the class. This is where the object’s attributes and actions a re deﬁned.
1.4.8 Declaring an Instance Variable
There are generally two kinds of elements declared and deﬁne d in the
class body: variables and methods. As we described in Chapte r 0, an
instance variable is a variable that belongs to each object, o r instance, of
the class. That is, each instance of a class has its own copies of the class’s
instance variables. The HelloWorld class has a single instance variable,
(greeting ), which is declared as follows:
☛ ✟
private S t r i n g g r e e t i n g = ” Hello World ! ” ;
✡ ✠
In general, an instance variable declaration has the followi ng syntax, some
parts of which are optional:
ModiﬁersoptType VariableName InitializerExpressionopt
Thus, a variable declaration begins with optional modiﬁers . In declaring
thegreeting variable, we use the access modiﬁer, private , to declare
thatgreeting , which belongs to the HelloWorld class, cannot be di-
rectly accessed by other objects. The next part of the declara tion is the
variable’s type. In this case, the greeting variable is a String , which Information hiding
means that it can store a string object. The type is followed by the name
of the variable, in this case ( greeting ). This is the name that is used to
refer to this memory location throughout the class. For exam ple, notice
that the variable is referred to on line 11 where it is used in a println()
statement.
SECTION 1.4 •Java Language Elements 43
The last part of the declaration is an optional initializer e xpression. In
this example, we use it to assign an initial value, “Hello Worl d!,” to the
greeting variable.
1.4.9 Deﬁning an Instance Method
Recall that a method is a named section of code that can be call ed or in-
voked to carry out an action or operation. In a Java class, the m ethods
correspond to the object’s behaviors or actions. The HelloWorld pro-
gram has two method deﬁnitions: the greet() method and the main()
method.
A method deﬁnition consists of two parts: the method header a nd the
method body. In general, a method header takes the following f orm,
including some parts which are optional:
ModiﬁersoptReturnType MethodName (ParameterList opt)
As with a variable declaration, a method deﬁnition begins wi th optional
modiﬁers. For example, the deﬁnition of the greet() method on line
9 uses the access modiﬁer, public , to declare that this method can be
accessed or referred to by other classes. The main() method, whose def-
inition begins on line 13, is a special method, and is explain ed in the next
section.
The next part of the method header is the method’s return type . This
is the type of value, if any, that the method returns. Both of t he methods
inHelloWorld have a return type of void . This means that they don’t
return any kind of value. Void methods just execute the sequen ce of state-
ments given in their bodies. For an example of a method that do es return a
value, take a look again at the declaration of the getQuestion() method
in theRiddle class, which returns a String (Fig. 1.4).
The method’s name follows the method’s return type. This is t he name
that is used when the method is called. For example, the greet() method
is called on line 17.
Following the method’s name is the method’s parameter list. Aparam-
eter is a variable that temporarily stores data values that are be ing passed
to the method when the method is called. Some methods, such as the
greet() method, do not have parameters, because they are not passed
any information. For an example of a method that does have par ameters,
see the Riddle() constructor, which contains parameters for the riddle’s
question and answer (Fig. 1.4).
The last part of method deﬁnition is its body, which contains a sequence
of executable statements. An executable statement is a Java statement
that takes some kind of action when the program is run. For exa mple, the
statement in the greet() method,
☛ ✟
System . out . p r i n t l n ( g r e e t i n g ) ; // O u t p u t s t a t e m e n t
✡ ✠
prints a greeting on the console.
44 CHAPTER 1 •Java Program Design and Development
1.4.10 Java Application Programs
The HelloWorld program is an example of a Java application program ,
or a Java application, for short. An application program is a stand-alone
program, “stand-alone” in the sense that it does not depend o n any other
program, like a Web browser, for its execution. Every Java ap plication pro-
gram must contain a main() method, which is where the program begins
execution when it is run. For a program that contains several classes, it is
up to the programmer to decide which class should contain the main()
method. We don’t have to worry about that decision for the Hell oWorld,
because it contains just a single class.
Because of its unique role as the starting point for every Jav a applica-
tion program, it is very important that the header for the mai n method be
declared exactly as shown in the HelloWorld class:
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] )
✡ ✠
It must be declared public so it can be accessed from outside the class
that contains it. The static modiﬁer is used to designate main() as Class method
a class method. As you might recall from Chapter 0, a class met hod is
a method that is associated directly with the class that cont ains it rather
than with the objects of the class. A class method is not part of the class’s
objects. Unlike instance methods, which are invoked through a class’s ob-
jects, a class method is called through the class itself. Thus , a class method
can be called even before the program has created objects of th at class.
Because of main() ’s special role as the program’s starting point, it is nec-
essary for main() to be a class method because it is called, by the Java
runtime system, before the program has created any objects.
Themain() method has a void return type, which means it does not
return any kind of value. Finally, notice that main() ’s parameter list con-
tains a declaration of some kind of String parameter named args. This is
actually an array that can be used to pass string arguments to the program
when it is started up. We won’t worry about this feature until our chapter
on arrays.
1.4.11 Creating and Using Objects
The body of the main() method is where the HelloWorld program cre-
ates its one and only object. Recall that when it is run the HelloWorld
program just prints the “Hello World!” greeting. As we noted ea rlier,
this action happens in the greet() method. So in order to make this ac-
tion happen, we need to call the greet() method. However, because the
greet() method is an instance method that belongs to a HelloWorld
object, we ﬁrst need to create a HelloWorld instance. This is what
happens in the body of the main() method (Fig. 1.5).
Themain() method contains three statements:
☛ ✟
HelloWorld helloworld ; // V a r i a b l e d e c l a r a t i o n
helloworld = new HelloWorld ( ) ; // O b j e c t i n s t a n t i a t i o n
helloworld . g r e e t ( ) ; // M e t h o d i n v o c a t i o n
✡ ✠
SECTION 1.4 •Java Language Elements 45
The ﬁrst statement declares a variable of type HelloWorld , which is
then assigned a HelloWorld object. The second statement creates a
HelloWorld object. This is done by invoking the HelloWorld() con-
structor method. Creating an object is called object instantiation because
you are creating an instance of the object. Once a HelloWorld instance
is created, we can use one of its instance methods to perform s ome task
or operation. Thus, in the third statement, we call the greet() method,
which will print “Hello World!” on the console.
If you look back at the HelloWorld program in Figure 1.5 you won’t
ﬁnd a deﬁnition of a constructor method. This is not an error b ecause Java Default constructor
will provide a default constructor if a class does not contai n a constructor
deﬁnition. The default constructor is a trivial constructor method, “triv-
ial” because its body contains no statements. Here is what the default
HelloWorld() constructor would look like:
☛ ✟
public HelloWorld ( ) { } // D e f a u l t c o n s t r u c t o r
✡ ✠
For most of the classes we design, we will design our own const ructors,
just as we did in the Riddle class (Fig. 1.4). We will use constructors to
assign initial values to an object’s instance variables or to perform other
kinds of tasks that are needed when an object is created. Becau se the
HelloWorld object doesn’t require any startup tasks, we can make do
with the default constructor.
TheHelloWorld program illustrates the idea that an object-oriented Interacting objects
program is a collection of interacting objects. Although we c reate just a
singleHelloWorld object in the main() method, there are two other ob-
jects used in the program. One is the greeting , which is a String ob-
ject consisting of the string “Hello World!”. The other is the System.out
object, which is a special Java system object used for printing .
1.4.12 Java Applets
A Java applet is a program that is executed by a Web browser and whose
output is embedded within a Web page. Figure 1.9 shows a Java a pplet
named HelloWorldApplet . This program does more or less the same
thing as the HelloWorld application—it displays the “Hello World!”
☛ ✟
/∗∗ H e l l o W o r l d A p p l e t p r o g r a m ∗/
import java . applet . Applet ; // I m p o r t c l a s s n a m e s
import java . awt . Graphics ;
public c l a s s HelloWorldApplet extends Applet // C l a s s h e a d e r
{ // S t a r t o f b o d y
public void paint ( Graphics g ) // T h e p a i n t m e t h o d
{
g . drawString ( ” Hello World ! ” , 1 0 , 1 0 ) ;
} // E n d o f p a i n t
} // E n d o f H e l l o W o r l d
✡ ✠
Figure 1.9: HelloWorldApplet program.
46 CHAPTER 1 •Java Program Design and Development
greeting. The difference is that it displays the greeting wi thin a Web page
rather than directly on the console.
As in the case of the HelloWorld application program, HelloWorld-
Applet consists of a class deﬁnition. It contains a single method deﬁ ni-
tion, the paint() method, which contains a single executable statement:
☛ ✟
g . drawString ( ” Hello World ! ” , 1 0 , 1 0 ) ;
✡ ✠
This statement displays the “Hello World!” message directly on a Web
page. The drawString() method is one of the many drawing and paint-
ing methods deﬁned in the Graphics class. Every Java applet comes with
its own Graphics object, which is referred to here simply as g. Thus, we
are using that object’s drawString() method to draw on the applet win-
dow. Don’t worry if this seems a bit mysterious now. We’ll exp lain it more
fully when we take up graphics examples again.
TheHelloWorldApplet also contains some elements, such as the
import statements, that we did not ﬁnd in the HelloWorld application.
We will now discuss those features.
1.4.13 Java Library Packages
Recall that the HelloWorld application program used two pre-deﬁned
classes, the String and the System classes. Both of these classes are
basic language classes in Java. The HelloWorldApplet program also
uses pre-deﬁned classes, such as Applet andGraphics . However, these
two classes are not part of Java’s basic language classes. To understand the
difference between these classes, it will be necessary to ta lk brieﬂy about
how the Java class library is organized.
Apackage is a collection a inter-related classes in the Java class lib rary.
For example, the java.lang package contains classes, such as Object ,
String , andSystem , that are central to the Java language. Just about
all Java programs use classes in this package. The java.awt package
provides classes, such as Button ,TextField , andGraphics , that are
used in graphical user interfaces (GUIs). The java.net package provides
classes used for networking tasks, and the java.io package provides
classes used for input and output operations.
All Java classes belong to some package, including those tha t are pro-
grammer deﬁned. To assign a class to a package, you would prov ide a
package statement as the ﬁrst statement in the ﬁle that contains the c lass
deﬁnition. For example, the ﬁles containing the deﬁnitions of the classes
in thejava.lang package all begin with the following statement.
☛ ✟
package java . lang ;
✡ ✠
If you omit package statement, as we do for the programs in this book,
Java places such classes into an unnamed default package.
Thus, for any Java class, its full name includes the name of th e
package that contains it. For example, the full name for the System
class is java.lang.System and the full name for the String class is
java.lang.String . Similarly, the full name for the Graphics class is
SECTION 1.4 •Java Language Elements 47
java.awt.Graphics . In short, the full name for a Java class takes the
following form:
package.class
In other words, the full name of any class provides its package name as a
preﬁx.
Of all the packages in the Java library, the java.lang package is the
only one whose classes are available by their shorthand name s to all
Java programs. This means that when a program uses a class fro m the
java.lang package, it can refer to it simply by its class name. For exam-
ple, in the HelloWorld program we referred directly to the String class
rather than to java.lang.String .
1.4.14 The import Statement
Theimport statement makes Java classes available to programs under
their abbreviated names. Any public class in the Java class l ibrary is avail-
able to a program by its fully qualiﬁed name. Thus, if a progra m was using
theGraphics class, it could always refer to it as java.awt.Graphics .
However, being able to refer to Graphics by its shorthand name, makes
the program a bit shorter and more readable.
Theimport statement doesn’t actually load classes into the program.
It just makes their abbreviated names available. For example, the import
statements in HelloWorldApplet allow us to refer to the Applet and
Graphics classes by their abbreviated names (Fig. 1.9).
Theimport statement takes two possible forms:
import package.class
import package.*
The ﬁrst form allows a speciﬁc class to be known by its abbrevi ated name.
The second form, which uses the asterisk as a wildcard charac ters (’*’),
allows all the classes in the speciﬁed package to be known by t heir short
names. The import statements in HelloWorldApplet are examples of
the ﬁrst form. The following example,
☛ ✟
import java . lang . ∗;
✡ ✠
allows all classes in the java.lang package to be referred to by their class
names alone. In fact, this particular import statement is implicit in every
Java program.
1.4.15 Qualiﬁed Names in Java
In the previous subsections we have seen several examples of n ames in
Java programs that used dot notation . Aqualiﬁed name is a name that is
separated into parts using Java’s dot notation. Examples in clude package
names, such as java.awt , class names, such as java.applet.Applet ,
and even method names, such as helloworld.greet() .
48 CHAPTER 1 •Java Program Design and Development
Just as in our natural language, the meaning of a name within a
Java program depends on the context. For example, the expres sion
helloworld.greet() refers to the greet() method, which belongs to
theHelloWorld class. If we were using this expression from within that
class, you wouldn’t need to qualify the name in this way. You c ould just
refer to greet() and it would be clear from the context which method
you meant.
This is no different than using someone’s ﬁrst name (“Kim”) w hen
there’s only one Kim around, but using a full name (“Kim Smith ”) when
the ﬁrst name alone would be too vague or ambiguous.
One thing that complicates the use of qualiﬁed names is that t hey are
used to refer to different kinds of things within a Java progr am. But
this is no different, really, than in our natural language, w here names
(“George Washington”) can refer to people, bridges, univer sities, and so
on. Here again, just as in our natural language, Java uses the co ntext
to understand the meaning of the name. For example, the expre ssion
java.lang.System refers to the System class in the java.lang pack-
age, whereas the expression System.out.print() refers to a method
in theSystem.out object.
How can you tell these apart? Java can tell them apart because t he
ﬁrst one occurs as part of an import statement, so it must be referring
to something that belongs to a package. The second expressio n would
only be valid in a context where a method invocation is allowe d. You
will have to learn a bit more about the Java language before yo u’ll be able
to completely understand these names, but the following pro vide some
naming rules to get you started.
JAVA LANGUAGE RULE Library Class Names. By convention,
class names in Java begin with an uppercase letter. When refer enced as
part of a package, the class name is the last part of the name. F or
example, java.lang.System refers to the System class in the
java.lang package.
JAVA LANGUAGE RULE Dot Notation. Names expressed in Java’s
dot notation depend for their meaning on the context in which they are
used. In qualiﬁed names—that is, names of the form X.Y.Z—the las t
item in the name (Z) is the referent —that is, the element being referred
to. The items that precede it (X.Y.) are used to qualify or cla rify the
referent.
The fact that names are context dependent in this way certain ly compli-
cates the task of learning what’s what in a Java program. Part of learn-
ing to use Java’s built-in classes is learning where a partic ular object or
method is deﬁned. It is a syntax error if the Java compiler can’ t ﬁnd the
object or method that you are referencing.
JAVA DEBUGGING TIP Not Found Error. If Java cannot ﬁnd the
item you are referring to, it will report an “X not found” erro r, where X
is the class, method, variable, or package being referred to .
SECTION 1.5 •Editing, Compiling, and Running a Java Program 49
1.5 Editing, Compiling, and Running a Java Pro-
gram
In this section we discuss the nuts and bolts of how to compile a nd run
a Java program. Because Java programs come in two different v arieties,
applications and applets, the process differs slightly for each variety. We
have already discussed some of the main language features of Java appli-
cations and applets, so in this section we focus more on featu res of the
programming environment itself. Because we do not assume an y particu-
lar programming environment in this book, our discussion wi ll be some-
what generic. However, we do begin with a brief overview of the types of
programming environments one might encounter.
1.5.1 Java Development Environments
A Java programming environment typically consists of sever al programs
that perform different tasks required to edit, compile, and run a Java pro-
gram. The following description will be based on the softwar e develop-
ment environment provided by Sun Microsystems, the company that de-
veloped Java. It is currently known as the Java2 Platform, Standard Edi-
tion 5.0 (J2SE 5.0) . Versions of J2SE are available for various platforms,
including Unix, Windows, and Macintosh computers. Free dow nloads
are available at Sun’s Web site at http://java.sun.com/j2se/ . (For
more details about the J2SE, see Appendix B.)
In some cases, the individual programs that make up the J2SE ar e
available in a single program development environment, kno wn as an
integrated development environment (IDE) . Some examples include Metrow-
erk’s Codewarrior, Borland’s JBuilder, and Sun’s own NetBe ans IDE. Each
of these provides a complete development package for editin g, compil-
ing, and running Java applications and applets on a variety o f platforms,
including Linux and Windows.
Figure 1.10 illustrates the process involved in creating an d running a
Java program. The discussion that follows here assumes that you are us-
ing the J2SE as your development environment to edit, compil e and run
the example program. If you are using some other environment, you will
need to read the documentation provided with the software to determine
exactly how to edit, compile, and run Java programs in that en vironment.
1.5.2 Editing a Program
Any text editor may be used to edit the program by merely typin g the
program and making corrections as needed. Popular Unix and L inux
editors include viandemacs . Macintosh editors include SimpleText
andBBEdit , and an editor like WinEdit orNotePad are available for
Windows.
As we have seen, a Java program consists of one or more class de f-
initions. We will follow the convention of placing each clas s deﬁnition
in its own ﬁle. (The rule in Java is that a source ﬁle may contai n only
onepublic class deﬁnition.) The ﬁles containing these classes’ deﬁni -
50 CHAPTER 1 •Java Program Design and Development
Figure 1.10: Editing, compiling,
and running HelloWorld.java .
text editor
javacjavac  generates
a list of error
messagessyntax
errors
?Editor creates the source
program  in a disk file.
javac  creates the  bytecode
in a disk file.
appletviewer
or Web
browser
javajavac
HelloWorld.class
Hello.html
Applet ProgrammingApplets require
an HTML file.HelloWorld.java
The Java Virtual Machine
loads the class file into
memory and interprets and
runs the bytecode.User types program into a file
using a standard text editor.
Correct the syntax errors
NY
tions must be named ClassName.java where ClassName is the name of the
public Java class contained in the ﬁle.
JAVA LANGUAGE RULE File Names. A ﬁle that deﬁnes a public
Java class named ClassName must be saved in a text ﬁle named
ClassName.java . Otherwise an error will result.
For example, in the case of our HelloWorld application program, the
ﬁle must be named HelloWorld.java , and for HelloWorldApplet ,
it must be named HelloWorldApplet.java . Because Java is case
sensitive , which means that Java pays attention to whether a letter
is typed uppercase or lowercase, it would be an error if the ﬁl e
containing the HelloWorld class were named helloworld.java or
Helloworld.java . The error in this case would be a semantic error.
Java would not be able to ﬁnd the HelloWorld class because it will be
looking for a ﬁle named HelloWorld.java .
JAVA LANGUAGE RULE Case Sensitivity. Java is case sensitive,
which means that it treats helloWorld andHelloworld as different
names.
SECTION 1.5 •Editing, Compiling, and Running a Java Program 51
1.5.3 Compiling a Program
Recall that before you can run a Java source program you have t o com-
pile it into the Java bytecode, the intermediate code unders tood by the
Java Virtual Machine (JVM). Source code for both applets and applica-
tions must be compiled. To run a Java program, whether an appl et or an
application, the JVM is then used to interpret and execute th e bytecode.
The J2SE comes in two parts, a runtime program, called the Java Run-
time Environment (JRE) and a development package, called the Software
Development Kit (SDK) . If you are just going to run Java programs, you
need only install the JRE on your computer. In order to run Java applets,
browsers, such as Internet Explorer and Netscape Navigator, must con-
tain a plugin version of the JRE. On the other hand, if you are g oing to be
developing Java programs, you will need to install the SDK as well.
The Java SDK compiler is named javac . In some environments—
such as within Linux or at the Windows command prompt —
HelloWorld.java would be compiled by typing the following com-
mand at the system prompt:
☛ ✟
j a v a c HelloWorld . java
✡ ✠
As Figure 1.10 illustrates, if the HelloWorld.java program does not
contain errors, the result of this command is the creation of a Java bytecode
ﬁle named HelloWorld.class —a ﬁle that has the same preﬁx as the
source ﬁle but with the sufﬁx .class rather than .java . By default,
the bytecode ﬁle will be placed in the same directory as the so urce ﬁle.
Ifjavac detects errors in the Java code, a list of error messages will be
printed.
1.5.4 Running a Java Application Program
In order to run (or execute) a program on any computer, the prog ram’s
executable code must be loaded into the computer’s main memory. For
Java environments, this means that the program’s .class ﬁle must be
loaded into the computer’s memory, where it is then interpre ted by the
Java Virtual Machine. To run a Java program on Linux systems o r at the
Windows command prompt, type
☛ ✟
java HelloWorld
✡ ✠
on the command line. This command loads the JVM, which will th en
load and interpret the application’s bytecode ( HelloWorld.class ). The
“HelloWorld” string will be displayed on the command line.
On Macintosh systems, or within an IDE, which do not typically have a
command line interface, you would select the compile and run commands
from a menu. Once the code is compiled, the run command will ca use the
JVM to be loaded and the bytecode to be interpreted. The “Hello World!”
output would appear in a text-based window that automatical ly pops
up on your computer screen. In any case, regardless of the syst em you
use, running the HelloWorld application program will cause the “Hel-
52 CHAPTER 1 •Java Program Design and Development
loWorld” message to be displayed on some kind of standard out put device
(Fig. 1.11). Hello Worldstdout
FIGURE 1.11 Running the
HelloWorld.java application
program.1.5.5 Running a Java Applet
To run a Java applet, you need to use either a Web browser or the SDK’s
appletviewer , a stripped-down Web browser for running applets. The
Web browser (or appletviewer) uses an HTML (HyperText Markup L an-
guage) document to locate the applet’s bytecode ﬁles on the W eb (or di-
rectly on your computer’s hard drive). The HTML ﬁle must conta in an
<applet> tag, as shown in Figure 1.12, which tells the browser where to
locate the applet’s bytecode. (See Appendix B for more detai ls about the
appletviewer and the <applet> tag).
☛ ✟
<html>
. . .
<applet code= ”HelloWorldApplet . c l a s s ” width= 200 height=200 >
</applet >
. . .
</html>
✡ ✠
Figure 1.12: An example of an HTML ﬁle containing an <applet>
tag. This speciﬁcation will run the Java program named
HelloWorldApplet.class .
If the applet tag is correctly speciﬁed, the Web browser (or ap -
pletviewer) will locate the Java bytecode ﬁle on the Web (or o n your sys-
tem’s hard drive). It will then load the JVM, which will load th e applet’s
code into memory and interpret and execute it.
The code in Figure 1.12 would be placed in a ﬁle named with an .html
sufﬁx to indicate that it is an HTML ﬁle. The name of the ﬁle in th is case is
not important, but let’s suppose we give it the name Hello.html . What
is important is that the <applet> tag be speciﬁed correctly, designat-
ing the name of the Java bytecode that should be executed, for example,
HelloWorldApplet.class . It is also necessary that the HTML ﬁle be
stored in the same directory or folder as the class ﬁle. (Ther e are ways to
get around this, but we’ll deal with those later.)
Given the correctly coded HTML ﬁle, Hello.html , theappletviewer
can be used to load and run the applet by typing the following c ommand
on the command line:
☛ ✟
appletviewer Hello . html
✡ ✠
If you are using a Web browser to run the applet, you would use th e
browser’s menu to load Hello.html into the browser, either across the
Internet by supplying its URL (Uniform Resource Locator) or from your lo-
cal disk by supplying the HTML ﬁle’s full path name. (You can us e the
browser’s Open File command to located the HTML ﬁle.) In any case,
the appletviewer or the browser will load the program’s byte code into
the computer’s main memory and then verify, interpret, and e xecute the
SECTION 1.6 •From the Java Library: System and PrintStream 53
program. The result, as shown in Figure 1.13, is that the “Hell o world!”
message will be displayed within the browser or appletviewe r window.
1.6 From the Java Library: System and
PrintStream
java.sun.com/j2se/1.5.0/docs/api/ Java comes with a library of classes that can be used to perfor m common
tasks. The Java class library is organized into a set of packa ges, where each
package contains a collection of related classes. Througho ut the book we
will identify library classes and explain how to use them. In t his section
we introduce the System andPrintStream classes, which are used for
printing a program’s output.
Java programs need to be able to accept input and to display ou tput.
Deciding how a program will handle input and output (I/O) is pa rt of
designing its user interface , a topic we take up in detail in Chapter 4. The
simplest type of user interface is a command-line interface , in which input
is taken from the command line through the keyboard, and outp ut is dis-
played on the console. Some Java applications use this type o f interface.
Another type of user interface is a Graphical User Interface (GUI) , which
uses buttons, text ﬁelds, and other graphical components fo r input and
output. Java applets use GUIs as do many Java applications. Be cause
we want to be able to write programs that generate output, thi s section
FIGURE 1.13 Running
HelloWorldApplet.java applet.describes how Java handles simple console output.
In Java, any source or destination for I/O is considered a stream of bytes
or characters. To perform output, we insert bytes or charact ers into the
stream. To perform input, we extract bytes or characters fro m the stream.
Even characters entered at a keyboard, if considered as a seq uence of
keystrokes, can be represented as a stream.
There are no I/O statements in the Java language. Instead, I/O is han-
dled through methods that belong to classes contained in the java.io
package. We have already seen how the output method println()
is used to output a string to the console. For example, the fol lowing
println() statement
☛ ✟
System . out . p r i n t l n ( ” Hello World” ) ;
✡ ✠
prints the message “Hello World” on the Java console. Let’s no w exam-
ine this statement more carefully to see how it makes use of th e Java I/O
classes.
Thejava.io.PrintStream class is Java’s printing expert, so to
speak. It contains a variety of print() andprintln() methods that
can be used to print all of the various types of data we ﬁnd in a J ava pro-
gram. A partial deﬁnition of PrintStream is shown in Figure 1.14. Note
that in this case the PrintStream class has no attributes, just operations+print(in data : String)
+print(in data : boolean)
+print(in data : int)
+println(in data : String)
+println(in data : boolean)
+println(in data : int)PrintStream
FIGURE 1.14 A UML class diagram
of thePrintStream class.or methods.
Because the various print() andprintln() methods are instance
methods of a PrintStream object, we can only use them by ﬁnding a
54 CHAPTER 1 •Java Program Design and Development
PrintStream object and “telling” it to print data for us. As shown in
Figure 1.15, Java’s java.lang.System class contains three predeﬁned
streams, including two PrintStream objects. This class has public ( +)
attributes. None of its public methods are shown here.
Both the System.out andSystem.err objects can be used to write
output to the console. As its name suggests, the err stream is used
primarily for error messages, whereas the out stream is used for other
printed output. Similarly, as its name suggests, the System.in object can
be used to handle input, which will be covered in Chapter 2.
The only difference between the print() andprintln() methods
is that println() will also print a carriage return and line feed after
printing its data, thereby allowing subsequent output to be printed on a
new line. For example, the following statements
☛ ✟
System . out . p r i n t ( ” h e l l o ” ) ;
System . out . p r i n t l n ( ” h e l l o again ” ) ;
System . out . p r i n t l n ( ”goodbye” ) ;
✡ ✠
would produce the following output:
☛ ✟
h e l l o h e l l o again
goodbye
✡ ✠+out : PrintStream
+err : PrintStream
+in : InputStreamSystem
FIGURE 1.15 TheSystem class.
Now that we know how to use Java’s printing expert, let’s use i t to “sing”
a version of “Old MacDonald Had a Farm.” As you might guess, thi s
program will simply consist of a sequence of System.out.println()
statements each of which prints a line of the verse. The compl ete Java
application program is shown in Figure 1.16.
☛ ✟
public c l a s s OldMacDonald
{
public s t a t i c void main ( S t r i n g args [ ] )
// M a i n m e t h o d
{
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”And on h i s farm he had a duck . ” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”With a quack quack here . ” ) ;
System . out . p r i n t l n ( ”And a quack quack there . ” ) ;
System . out . p r i n t l n ( ”Here a quack , there a quack , ” ) ;
System . out . p r i n t l n ( ”Everywhere a quack quack . ” ) ;
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
} // E n d o f m a i n
} // E n d o f O l d M a c D o n a l d
✡ ✠
Figure 1.16: The OldMacDonald.java class.
This example illustrates the importance of using the Java cl ass library.
If there’s a particular task we want to perform, one of the ﬁrst things we
CHAPTER 1 •Chapter Summary 55
should ask is whether there is already an “expert” in Java’s c lass library
that performs that task. If so, we can use methods provided by t he expert
to perform that particular task.
JAVA EFFECTIVE DESIGN Using the Java Library. Learning how to
use classes and objects from the Java class library is an impor tant part
of object-oriented programming in Java.
SELF-STUDY EXERCISES **********
* ** ** *
* ** *
* * * *
* **** *
**********EXERCISE 1.3 One good way to learn how to write programs is to
modify existing programs. Modify the OldMacDonald class to “sing”
one more verse of the song.
EXERCISE 1.4 Write a Java class that prints the design shown on the
left.
CHAPTER SUMMARY Technical Terms
algorithm
applet
application program
assignment
statement
comment
compound statement
(block)
data typedeclaration statement
default constructor
executable statement
expression
identiﬁer
literal value
object instantiation
operator
packageparameter
primitive data type
pseudocode
qualiﬁed name
semantics
statement
stepwise reﬁnement
syntax
Summary of Important Points
•Good program design requires that each object and method have a
well-deﬁned role and clear deﬁnition of what information is needed
for the task and what results will be produced.
•Good program design is important; the sooner you start codin g, the
longer the program will take to ﬁnish. Good program design st rives
for readability, clarity, and ﬂexibility.
•Testing a program is very important and must be done with care , but it
can only reveal the presence of bugs, not their absence.
•An algorithm is a step-by-step process that solves some prob lem. Al-
gorithms are often described in pseudocode, a hybrid langua ge that
combines English and programming language constructs.
•A syntax error occurs when a statement breaks a Java syntax ru les. Syn-
tax errors are detected by the compiler. A semantic error is a n error in
the program’s design and cannot be detected by the compiler.
•Writing Java code should follow the stepwise reﬁnement proc ess.
56 CHAPTER 1 •Java Program Design and Development
•Double slashes (//) are used to make a single-line comment. C om-
ments that extend over several lines must begin with /* and en d with
*/.
•Anidentiﬁer must begin with a letter of the alphabet and may consist
of any number of letters, digits, and the special characters and $. An
identiﬁer cannot be identical to a Java keyword. Identiﬁers a re case
sensitive.
•Akeyword is a term that has special meaning in the Java language
(Table 1.1).
•Examples of Java’s primitive data types include the int,boolean , and
double types.
•A variable is a named storage location. In Java, a variable mus t be
declared before it can be used.
•A literal value is an actual value of some type, such as a String
(”Hello”) or an int (5).
•A declaration statement has the form: Type VariableName ;
•An assignment statement has the form: VariableName =Expression ;
When it is executed it determines the value of the Expression on the
right of the assignment operator ( =) and stores the value in the variable
named on the left.
•Java’s operators are type dependent, where the type is depen dent on
the data being manipulated. When adding two int values (7+8), the
+operation produces an int result.
•A class deﬁnition has two parts: a class header and a class bod y. A
class header takes the form of optional modiﬁers followed by the word
class followed by an identiﬁer naming the class followed, optiona lly,
by the keyword extends and the name of the class’s superclass.
•There are generally two kinds of elements declared and deﬁne d in the
class body: variables and methods.
•Object instantiation is the process of creating an instance o f a class using
thenew operator in conjunction with one of the class’s constructors .
•Dot notation takes the form qualiﬁers.elementName . The expression
System.out.print("hello") uses Java dot notation to invoke the
print() method of the System.out object.
•A Java application program runs in stand-alone mode. A Java a pplet is
a program that runs within the context of a Java-enabled brow ser. Java
applets are identiﬁed in HTML documents by using the <applet> tag.
•A Java source program must be stored in a ﬁle that has a .java exten-
sion. A Java bytecode ﬁle has the same name as the source ﬁle bu t a
.class extension. It is an error in Java if the name of the source ﬁle is
not identical to the name of the public Java class deﬁned with in the ﬁle.
•Java programs are ﬁrst compiled into bytecode and then inter preted by
the Java Virtual Machine (JVM).
CHAPTER 1 •Solutions to Self-Study Exercises 57
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 1.1 The value 12 is stored in num.
SOLUTION 1.2 int num2 = 711 + 712;
SOLUTION 1.3 The deﬁnition of the OldMacDonald class is:
☛ ✟
public c l a s s OldMacDonald
{
public s t a t i c void main ( S t r i n g args [ ] )
// M a i n m e t h o d
{
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”And on h i s farm he had a duck . ” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”With a quack quack here . ” ) ;
System . out . p r i n t l n ( ”And a quack quack there . ” ) ;
System . out . p r i n t l n ( ”Here a quack , there a quack , ” ) ;
System . out . p r i n t l n ( ”Everywhere a quack quack . ” ) ;
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”And on h i s farm he had a pig . ” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
System . out . p r i n t l n ( ”With an oink oink here . ” ) ;
System . out . p r i n t l n ( ”And an oink oink there . ” ) ;
System . out . p r i n t l n ( ”Here an oink , there an oink , ” ) ;
System . out . p r i n t l n ( ”Everywhere an oink oink . ” ) ;
System . out . p r i n t l n ( ”Old MacDonald had a farm” ) ;
System . out . p r i n t l n ( ”E I E I O. ” ) ;
} // E n d o f m a i n
} // E n d o f O l d M a c D o n a l d
✡ ✠
SOLUTION 1.4 The deﬁnition of the Pattern class is:
☛ ✟
public c l a s s Pattern
{
public s t a t i c void main ( S t r i n g args [ ] ) // M a i n m e t h o d
{
System . out . p r i n t l n ( ”∗∗∗∗∗∗∗∗∗∗ ”) ;
System . out . p r i n t l n ( ”∗ ∗∗ ∗∗ ∗ ”) ;
System . out . p r i n t l n ( ”∗ ∗∗ ∗ ”) ;
System . out . p r i n t l n ( ”∗ ∗ ∗ ∗ ”) ;
System . out . p r i n t l n ( ”∗ ∗∗∗∗ ∗ ”) ;
System . out . p r i n t l n ( ”∗∗∗∗∗∗∗∗∗∗ ”) ;
} // E n d o f m a i n
} // E n d o f P a t t e r n
✡ ✠
58 CHAPTER 1 •Java Program Design and Development
EXERCISES EXERCISE 1.1 Fill in the blanks in each of the following statements.
a. A Java class deﬁnition contains an object’s and .
b. A method deﬁnition contains two parts, a and a .
EXERCISE 1.2 Explain the difference between each of the following pairs of
concepts.
a.Application and applet .
b.Single-line and multiline comment.
c.Compiling and running a program.
d.Source code ﬁle and bytecode ﬁle.
e.Syntax and semantics .
f.Syntax error and semantic error .
g.Data and methods .
h.Variable and method .
i.Algorithm and method .
j.Pseudocode and Java code .
k.Method deﬁnition and method invocation .
EXERCISE 1.3 For each of the following, identify it as either a syntax error or a
semantic error. Justify your answers.
a. Write a class header as public Class MyClass .
b. Deﬁne the init() header as public vid init() .
c. Print a string of ﬁve asterisks by System.out.println(" ***");.
d. Forget the semicolon at the end of a println() statement.
e. Calculate the sum of two numbers as N−M.
EXERCISE 1.4 Suppose you have a Java program stored in a ﬁle named
Test.java . Describe the compilation and execution process for this program,
naming any other ﬁles that would be created.
EXERCISE 1.5 Suppose Nis 15. What numbers would be output by the fol-
lowing pseudocode algorithm? Suppose Nis 6. What would be output by the
algorithm in that case?
☛ ✟
0 . P r i n t N.
1 . I f N equals 1 , stop .
2 . I f N i s even , divide i t by 2 .
3 . I f N i s odd , t r i p l e i t and add 1 .
4 . Go to step 0 .
✡ ✠
EXERCISE 1.6 Suppose Nis 5 and Mis 3. What value would be reported by the
following pseudocode algorithm? In general, what quantity does th is algorithm
calculate?
☛ ✟
0 . Write 0 on a piece of paper .
1 . I f M equals 0 , report what ’ s on the paper and stop .
2 . Add N to the quantity written on the paper .
3 . S u b t r a c t 1 from M.
4 . Go to step 1 .
✡ ✠
CHAPTER 1 •Exercises 59
EXERCISE 1.7 Puzzle Problem : You are given two different length ropes that
have the characteristic that they both take exactly one hour to b urn. However,
neither rope burns at a constant rate. Some sections of the ropes burn very fast;
other sections burn very slowly. All you have to work with is a box of ma tches
and the two ropes. Describe an algorithm that uses the ropes and t he matches to
calculate when exactly 45 minutes have elapsed.
EXERCISE 1.8 Puzzle Problem : A polar bear that lives right at the North Pole
can walk due south for one hour, due east for one hour, and due north for one
hour, and end up right back where it started. Is it possible to do this anywhere
else on earth? Explain.
EXERCISE 1.9 Puzzle Problem : Lewis Carroll, the author of Alice in Wonder-
land, used the following puzzle to entertain his guests: A captive q ueen weighing
195 pounds, her son weighing 90 pounds, and her daughter weighin g 165 pounds,
were trapped in a very high tower. Outside their window was a pul ley and rope
with a basket fastened on each end. They managed to escape by us ing the baskets
and a 75-pound weight they found in the tower. How did they do it? Th e problem
is that anytime the difference in weight between the two bask ets is more than 15
pounds, someone might get hurt. Describe an algorithm that gets t hem down
safely.
EXERCISE 1.10 Puzzle Problem : Here’s another Carroll favorite: A farmer
needs to cross a river with his fox, goose, and a bag of corn. There’s a r owboat
that will hold the farmer and one other passenger. The problem is t hat the fox will
eat the goose if they are left alone on the river bank, and the goose wi ll eat the corn
if they are left alone on the river bank. Write an algorithm that d escribes how he
got across without losing any of his possessions.
EXERCISE 1.11 Puzzle Problem : Have you heard this one? A farmer lent the
mechanic next door a 40-pound weight. Unfortunately, the mechan ic dropped
the weight and it broke into four pieces. The good news is that, acc ording to the
mechanic, it is still possible to use the four pieces to weigh an y quantity between
one and 40 pounds on a balance scale. How much did each of the four piec es
weigh? ( Hint : You can weigh a 4-pound object on a balance by putting a 5-pound
weight on one side and a 1-pound weight on the other.)
EXERCISE 1.12 Suppose your little sister asks you to show her how to use a
pocket calculator so that she can calculate her homework average in her science
course. Describe an algorithm that she can use to ﬁnd the averag e of 10 homework
grades.
EXERCISE 1.13 A Caesar cipher is a secret code in which each letter of the al-
phabet is shifted by Nletters to the right, with the letters at the end of the alphabe t
wrapping around to the beginning. For example, if Nis 1, when we shift each
letter to the right, the word daze would be written as ebaf. Note that the zhas
wrapped around to the beginning of the alphabet. Describe an al gorithm that can
be used to create a Caesar encoded message with a shift of 5.
EXERCISE 1.14 Suppose you received the message, “sxccohv duh ixq,” which
you know to be a Caesar cipher. Figure out what it says and then des cribe an
algorithm that will always ﬁnd what the message said regardle ss of the size of the
shift that was used.
EXERCISE 1.15 Suppose you’re talking to your little brother on the phone and
he wants you to calculate his homework average. All you have to work with is
a piece of chalk and a very small chalkboard—big enough to write on e four-digit
number. What’s more, although your little brother knows how to read n umbers,
he doesn’t know how to count very well so he can’t tell you how many grade s
there are. All he can do is read the numbers to you. Describe an a lgorithm that
will calculate the correct average under these conditions.
60 CHAPTER 1 •Java Program Design and Development
EXERCISE 1.16 Write a header for a public applet named SampleApplet .
EXERCISE 1.17 Write a header for a public method named getName .
EXERCISE 1.18 Design a class to represent a geometric rectangle with a given
length and width, such that it is capable of calculating the ar ea and the perimeter
of the rectangle.
EXERCISE 1.19 Modify the OldMacDonald class to “sing” either “Mary Had a
Little Lamb” or your favorite nursery rhyme.
EXERCISE 1.20 Deﬁne a Java class, called Patterns , modeled after OldMac-
Donald , that will print the following patterns of asterisks, one after t he other
heading down the page:
☛ ✟
∗∗∗∗∗ ∗∗∗∗∗ ∗∗∗∗∗
∗∗∗∗ ∗ ∗ ∗ ∗ ∗
∗∗∗ ∗ ∗ ∗ ∗
∗∗ ∗ ∗ ∗ ∗ ∗
∗ ∗∗∗∗∗ ∗∗∗∗∗
✡ ✠
EXERCISE 1.21 Write a Java class that prints your initials as block letters, a s
shown in the example in the margin. ****** * *
* * ** **
* * * * * *
****** * * * *
** * * *
* * * *
* * * *
* * * *EXERCISE 1.22 Challenge: Deﬁne a class that represents a Temperature ob-
ject. It should store the current temperature in an instance va riable of type
double , and it should have two public methods, setTemp(double t) , which
assigns tto the instance variable, and getTemp() , which return s the value of
the instance variable. Use the Riddle class as a model.
EXERCISE 1.23 Challenge: Deﬁne a class named TaxWhiz that computes the
sales tax for a purchase. It should store the current tax rate as a n instance
variable. Following the model of the Riddle class, you can initialize the rate
using a TaxWhiz() method. This class should have one public method,
calcTax(double purchase) , which return s adouble , whose value is
purchases times the tax rate. For example, if the tax rate is 4 percent, 0. 04, and
the purchase is $100, then calcTax() should return 4.0.
EXERCISE 1.24 What is stored in the variables num1 andnum2 after the follow-
ing statements are executed?
int num1 = 5;
int num2 = 8;
num1 = num1 + num2;
num2 = nmm1 + num2;
EXERCISE 1.25 Write a series of statements that will declare a variable
of type int callednum and store in it the difference between 61 and 51.
UML EXERCISES
EXERCISE 1.26 Modify the UML diagram of the Riddle class to con-
tain a method named getRiddle() that would return both the riddle’s
question and answer.
EXERCISE 1.27 Draw a UML class diagram representing the follow-
ing class: The name of the class is Circle . It has one attribute, a
radius that is represented by a double value. It has one operation,
calculateArea() , which returns a double . Its attributes should be
designated as private and its method as public.
CHAPTER 1 •Exercises 61
EXERCISE 1.28 To represent a triangle we need attributes for each of
its three sides and operations to create a triangle, calcula te its area, and
calculate its perimeter. Draw a UML diagram to represent thi s triangle.
EXERCISE 1.29 Try to give the Java class deﬁnition for the class de-
scribed in the UML diagram shown in Figure 1.17.+printName()
+printPhone()-name : String
-phone : StringPerson
FIGURE 1.17 ThePerson class.
62 CHAPTER 1 •Java Program Design and Development
OBJECTIVES
After studying this chapter, you will
•Be familiar with using variables to store and manipulate sim ple data.
•Be familiar with creating and using objects.
•Understand the relationship between classes and objects.
•Understand the difference between objects and data of primit ive type.
•Understand the difference between static and and instance e lements of a class.
•Be able to understand and design a simple class in Java.
•Understand some of the basic principles of object-oriented p rogramming.
OUTLINE
2.1 Introduction
2.2 Using String Objects
2.3 Drawing Shapes with the Graphics Object (Optional)
2.4 Class Deﬁnition
2.5 Case Study: Simulating a Two-Person Game
2.6 From the Java Library: java.util.Scanner
Special Topic: Alan Kay and the Smalltalk Language
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 2
Objects: Using, Creating,
and Deﬁning
63
64 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
2.1 Introduction
This chapter introduces some more of the basic principles of object-
oriented programming. We begin by looking at some examples o f creat-
ing and using objects of type String andGraphics . Then, we examine
how user deﬁned classes are used by doing a detailed walk-thr ough of the
Riddle class we saw in Chapter 1. We focus on the basic Java language
elements involved. By the end of these sections, you should k now how to
identify the key elements that make up a Java program.
We then present a detailed example of the programming develo pment
process by designing a class that models a certain two person game and
implements the class. The design is represented using UML no tation.
2.2 Using String Objects
As we know, a Java program is a collection of interacting objec ts, where
each object is a module that encapsulates a portion of the prog ram’s at-
tributes and actions. Objects belong to classes, which serve as templates
or blueprints for creating objects. Think again of the cookie cutter analogy.
A class is like a cookie cutter. Just as a cookie cutter is used to shape and
create individual cookies, a class deﬁnition is used to shap e and create
individual objects.
Programming in Java is primarily a matter of designing and de ﬁning
class deﬁnitions, which are then used to construct objects. T he objects
perform the program’s desired actions. To push the cookie cu tter analogy
a little further, designing and deﬁning a class is like build ing the cookie
cutter. Obviously, very few of us would bake cookies if we ﬁrs t had to
design and build the cookie cutters. We’d be better off using a pre-built
cookie cutter. By the same token, rather than designing our o wn classes,
it will be easier to get into “baking” programs if we begin by u sing some
predeﬁned Java classes.
The Java library contains many pre-deﬁned classes that we wi ll use in
our programs. So let’s begin our study of programming by usin g two of
these classes, the String andGraphics classes.
2.2.1 Creating and Combining Strings
Strings are very useful objects in Java and in all computer pro grams. They
FIGURE 2.1 A partial
representation of the String class.are used for inputting and outputting all types of data. Ther efore, it
essential that we learn how to create and use String objects.
Figure 2.1 provides an overview of a very small part of Java’s String
class. In addition to the two String() constructor methods, which are
used to create strings, it lists several useful instance met hods that can
be used to manipulate strings. The String class also has two instance
variables. One stores the String ’svalue , which is a string of characters
such as “Hello98”, and the other stores the String ’scount , which is the
number of characters in its string value.
Recall from Chapter 0 that in order to get things done in a prog ram we
send messages to objects. The messages must correspond to the object’s
instance methods. Sending a message to an object is a matter of calling
SECTION 2.2 •UsingString Objects 65
one of its instance methods. In effect, we use an object’s metho ds to get the
object to perform certain actions for us. For example, if we ha ve aString ,
named str and we want to ﬁnd out how many characters it contains, we
can call its length() method, using the expression str.length() . If
we want to print str’s length, we can embed this expression in a print
statement:
☛ ✟
System . out . p r i n t l n ( s t r . length ( ) ) ; // P r i n t s t r ’ s l e n g t h
✡ ✠
In general, to use an object’s instance method, we refer to the m ethod in Dot notation
dot notation by ﬁrst naming the object and then the method:
objectName.methodName() ;
The objectName refers to a particular object, and the methodName() refers
to one of its instance methods.
As this example makes clear, instance methods belong to objec ts, and in
order to use a method, you must ﬁrst have an object that has that method.
So, to use one of the String methods in a program, we must ﬁrst create
aString object.
To create a String object in a program, we ﬁrst declare a String
variable.
☛ ✟
S t r i n g s t r ; // D e c l a r e a S t r i n g v a r i a b l e n a m e d s t r
✡ ✠
We then create a String object by using the new keyword in conjunction
FIGURE 2.2 AString object
stores a sequence of characters and a
count giving the number of
characters.with one of the String() constructors. We assign the new object to the
variable we declared:
☛ ✟
s t r = new S t r i n g ( ” Hello ” ) ;// C r e a t e a S t r i n g o b j e c t
✡ ✠
This example will create a String that contains, as its value, the word
”Hello” that is passed in by the constructor. The String object that this
creates is shown in Figure 2.2.
We can also use a constructor with an empty parameter list. No te that
in this case we combine the variable declaration and the object creation into
one statement:
☛ ✟
S t r i n g s t r 2 = new S t r i n g ( ) ; // C r e a t e a S t r i n g
✡ ✠
This example will create a String object that contains the empty string
as its value. The empty string has the literal value ”” – that is, a pair of
double quotes that contain no characters. Because the empty string has no
characters, the count variable stores a zero (Fig. 2.3).
FIGURE 2.3 The empty string has a
value of ”” and a its length is 0.Note that we use a constructor to assign an initial value to a v ariable of
typeString (or of a type equal to any other class). This differs from how
we assign an initial value to variables of primitive type, fo r which we use
a simple assignment operator. This difference is related to an important
difference in the way Java treats these two types of variable s. Variables
of primitive type are names for memory locations where value s of prim-
itive type are stored. As soon as they are declared they are as signed a
66 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
default value of that primitive type. The default value for int is0and
the default value for boolean isfalse . On the other hand, variables
that are declared to be of a type equal to a class name are desig ned to store
areference to an object of that type. (A reference is also called a pointer
because it points to the memory address where the object itsel f is stored.)
A constructor creates an object somewhere in memory and suppl ies a ref-
erence to it that is stored in the variable. For that reason, v ariables that
are declared as a type equal to a class name are said to be varia bles of
reference type or reference variables . Reference variables have a special
default value called null after they are declared and before they are as-
signed a reference. It is possible to check whether or not a ref erence vari-
able contains a reference to an actual object by checking whet her or not it
contains this null pointer .
Once you have constructed a String object, you can use any of the
methods shown in Figure 2.1 on it. As we already saw, we use dot no-
tation to call one of the methods. Thus, we ﬁrst mention the na me of the
object followed by a period (dot), followed by the name of the m ethod. For
example, the following statements print the lengths of our t wo strings:
☛ ✟
System . out . p r i n t l n ( s t r . length ( ) ) ;
System . out . p r i n t l n ( s t r 2 . length ( ) ) ;
✡ ✠
Another useful String method is the concat(String) method,
which can be used to concatenate two strings. This method takes a String
argument. It returns a String that combines the String argument to the
String that the method is called on. Consider this example:
☛ ✟
S t r i n g s1 = new S t r i n g ( ”George ” ) ;
S t r i n g s2 = new S t r i n g ( ”Washington” ) ;
System . out . p r i n t l n ( s1 . concat ( s2 ) ) ;
✡ ✠
In this case, the concat() method adds the String s2to the end of the
String s1. The result, which gets printed, will be the String ”George
Washington”.
Because strings are so important, Java allows a number of sho rtcuts
to be used when creating and concatenating strings. For exam ple, you
don’t have to use new String() when creating a new string object. The
following code will also work:
☛ ✟
S t r i n g s1 = ”George ” ;
S t r i n g s2 = ”Washington” ;
✡ ✠
Similarly, an easier way to concatenate two String objects is to use the
plus sign (+), which serves as a concatenation operator in Java:
☛ ✟
System . out . p r i n t l n ( s1 + s2 ) ;
✡ ✠
Another useful String method is the equals() method. This is
aboolean method, which is used to compare two String s. If both
String s have the same characters, in the same order, it will return t rue.
SECTION 2.2 •UsingString Objects 67
Otherwise it will return false. For example, consider the fo llowing code
segment:
☛ ✟
S t r i n g s1 = ” Hello ” ;
S t r i n g s2 = ” Hello ” ;
S t r i n g s3 = ” h e l l o ” ;
✡ ✠
In this case, the expression s1.equals(s2) will be true, but s1.equals(s3)
will be false.
It is important to note that the empty string is not the same as a String
variable that contains null . Executing the statements:
☛ ✟
S t r i n g s1 ;
S t r i n g s2 = ””;
System . out . p r i n t l n ( s1 . equals ( s2 ) ) ;
✡ ✠
will not only not print out true ; it will cause the the program to terminate
abnormally. It is an error to use the method of a String variable, or any
other variable whose type is a class, before it has been assig ned an object.
When the above code is executed, it will report a null pointer exception ,
one of the most common runtime errors. When you see that error m es-
sage, it means that some method was executed on a variable tha t does not
refer to an object. On the other hand, the empty string is a perf ectly good
String object which just happens to contain zero characters.
Figure 2.4 shows a program that uses string concatenation to create
☛ ✟
public c l a s s StringPuns
{
public s t a t i c void main ( S t r i n g args [ ] )
{S t r i n g s = new S t r i n g ( ” s t r i n g ” ) ;
S t r i n g s1 = s . concat ( ” puns . ” ) ;
System . out . p r i n t l n ( ”Here are the top 5 ” + s1 ) ;
S t r i n g s2 = ” 5 . Hey baby , wanna ” ;
S t r i n g s3 = s + ” along with me. ” ;
System . out . p r i n t l n ( s2 + s3 ) ;
System . out . p r i n t l n ( ” 4 . I ’ ve got the world on a ” +
s + ” . ” ) ;
S t r i n g s4 = new S t r i n g ( ”two” ) ;
S t r i n g s5 = ” . You have more c l a s s than a ” ;
System . out . p r i n t ( s4 . length ( ) ) ;
System . out . p r i n t l n ( s5 + s + ” of p e a r l s . ” ) ;
System . out . p r i n t ( ” 2 . I t i s ” ) ;
System . out . p r i n t ( s . equals ( ” s t r i n g ” ) ) ;
System . out . p r i n t l n ( ” t h a t I am no ” + s + ” bean . ” ) ;
S t r i n g s6 = ” q u i n t e t . ” ;
System . out . p r i n t l n ( ” 1 . These puns form a ” + s + s6 ) ;
}// m a i n ( )
}// S t r i n g P u n s c l a s s
✡ ✠
Figure 2.4: A program that prints silly string puns.
some silly sentences. The programs declares a number of stri ng variables,
68 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
named s,s1, and so on, and it instantiates a String object for each vari-
able to refer to. It then prints out a top-ﬁve list using the con catenation
operator to combine strings. Can you ﬁgure out what it prints without
running it?
SELF-STUDY EXERCISES
EXERCISE 2.1 What is the output to the console window when the
following Java code fragment is executed:
☛ ✟
S t r i n g s = ” ing ” ;
System . out . p r i n t l n ( ”The s ” + s + s + ” k” + s + ” . ” ) ;
✡ ✠
2.3 Drawing Shapes with a Graphics Object
(Optional)
All of the instance methods of the String class that we examined return
values. The length() method return an int value, and the concat()
method returned a String . It is also very common for classes to deﬁne
instance methods that perform actions but do not return a val ue. The
Graphics object, g, that appears in Chapter 1’s HelloWorldApplet is
one example. The program is reproduced in Figure 2.5
☛ ✟
/∗
∗H e l l o W o r l d A p p l e t p r o g r a m
∗/
import java . applet . Applet ; // I m p o r t t h e A p p l e t c l a s s
import java . awt . Graphics ; // a n d t h e G r a p h i c s c l a s s
public c l a s s HelloWorldApplet extends Applet // C l a s s h e a d e r
{ // S t a r t o f b o d y
public void paint ( Graphics g ) // T h e p a i n t m e t h o d
{
g . drawString ( ” Hello World” , 1 0 , 1 0 ) ;
} // E n d o f p a i n t
} // E n d o f H e l l o W o r l d
✡ ✠
Figure 2.5: HelloWorldApplet program.
At this point we will not worry about the language features th at enable
thepaint() method to draw on the applet window when the applet is
executed by a Web browser. We will focus instead on the inform ation
needed to make good use of the g.drawString() method. The ﬁrst
thing you should know is that, when the paint() method is executed,
its parameter, g, refers to an instance of the Graphics class. Unlike our
other examples involving variables that refer to objects, in this case there
is no need to use a constructor to create an object of type Graphics . We
can assume galready refers to such an object.
SECTION 2.3 •Drawing Shapes with a Graphics Object (Optional) 69
We already know that the statement
☛ ✟
g . drawString ( ” Hello World” , 1 0 , 1 0 ) ;
✡ ✠
displays the String “Hello World” in the applet window. More gener-
ally, ifstr is a literal String value or a reference to a String object and
xandyare literal int values or int variables then
☛ ✟
g . drawString ( s t r , x , y )
✡ ✠
displays the String str from left to right in the applet window begin-
ning at a point which is xpixels from the left edge of the window and y
pixels down from the top edge of the window. In an applet window , the
point with coordinates (0,0) is at the top-left corner. The h orizontal axis
grows positively from left to right. The vertical axis grows positively from
top to bottom (Fig. 2.6). (A pixel is a dot on the console window that can
FIGURE 2.6 Coordinate system of a
Java window.be set to a certain color.) Notice that increasing the value o fywill cause
str to be displayed lower. This is the opposite of the usual xandycoordi-
nate system used in mathematics where increasing the yvalue designates
a higher point.
With this information about g.drawString() , we can calculate
where to display any message in the applet window. For exampl e, if we
wish to display the message “Welcome to Java” 25 pixels below where
“Hello World” is displayed we could use the statements
☛ ✟
g . drawString ( ” Hello World” , 1 0 , 1 0 ) ;
g . drawString ( ”Welcome to Java ” , 1 0 , 3 5 ) ;
✡ ✠
in the body of HelloWorldApplet ’spaint() method. The result of
these statements would appear as shown in Figure 2.7.
Figure 2.7: “Hello World” is
drawn at coordinate (10, 10) and
“Welcome to Java” at (10, 35) on
the applet window.
2.3.1 Graphics Drawing Methods
TheGraphics class discussed in the previous section also has methods
that can be used to draw geometric shapes in different colors . These meth-
ods can be used to create graphical user interfaces that are m ore interest-
70 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
ing or to give a visual representation of data, such as a pie ch art or a bar
graph.
There are two Graphics methods for drawing rectangles, fillRect()
anddrawRect() (Fig. 2.8). The ﬁrst draws a rectangle and ﬁlls it with the
current drawing color and the second just draws the outline of the rectan-
gle. Using the Graphics object, g, each of these is called in the same way
as thedrawString() method from the previous example. Each of these
methods takes four int arguments, which specify the rectangle’s location
FIGURE 2.8 Some of the drawing
methods in the Graphics class.and size. Thus, a call to fillRect() would take the form
☛ ✟
g . f i l l R e c t ( x , y , width , height ) ;
✡ ✠
where xandyarguments specify the location of the upper left corner of
the rectangle as being xpixels from the left edge of the window and y
pixels down from the top edge of the window. The width andheight
arguments specify the width and height of the rectangle in pi xels. The
drawRect() method also takes the same four arguments.
AGraphics object stores a single color for use in drawing shapes or
displaying strings with drawString() . If we wish to draw an interesting
scene in the applet window, we need to understand how to use co lors.
For a given Graphics object, such as g, thesetColor() method will
set its color for all subsequent drawing commands. The setColor()
method takes, as an argument, an object of type Color . All we need
to know about the Color class is that it is contained in the java.awt
package and that it contains 13 constant Color objects corresponding to
13 common colors. Table 2.1 lists the 13 Color constants. Each name
corresponds to the color it will represent in the program.
Color.black Color.green Color.red
Color.blue Color.lightGreen Color.white
Color.cyan Color.magenta Color.yellow
Color.darkGray Color.orange
Color.gray Color.pink
Table 2.1: Predeﬁned color constants in the Color class.
To demonstrate how the new Graphics methods can be used for cre-
ating more interesting applets, let’s develop a plan for dis playing the two
messages, “Hello World” and “Welcome to Java”, on an applet, b ut this
time we will draw the ﬁrst inside a colored rectangle and the s econd in-
side a colored oval. For the rectangle, let’s use the drawRect() method to
create its border. We can choose some arbitrary colors, say, cyan for ﬁlling
the rectangle, blue for its border, and black for the string i tself. In order
to have the message visible we should ﬁll a rectangle with the color cyan
ﬁrst, then draw the border of the rectangle in blue and, ﬁnall y, display the
message in black.
Drawing and ﬁlling a Graphics oval is very similar to drawing
and ﬁlling a rectangle. Notice in Figure 2.8 that the fillOval() and
SECTION 2.3 •Drawing Shapes with a Graphics Object (Optional) 71
drawOval() methods take the same four arguments as the correspond-
ing rectangle methods. An oval is inscribed within an enclos ing rectangle.
Thexandyarguments give the coordinates of the enclosing rectangle’ s
top left point. And the width andheight arguments give the enclosing
rectangles dimensions.
All that remains is to choose the location and dimensions of t he rect-
angles. We could specify one rectangle as having its upper le ft corner 25
pixels to the right of the left edge of the applet window and 25 pixels down
from the top edge. A medium sized rectangle could have a width of 140
pixels and a height of 40 pixels. The statement
☛ ✟
g . f i l l R e c t ( 2 5 , 25 , 140 , 4 0 ) ;
✡ ✠
will ﬁll this rectangle with whatever color happens to be g’s current color.
A location 25 pixels to the right of the left edge of the rectan gle and 25
pixels down from the top edge of the rectangle would have coor dinates
x = 50 andy = 50 . Thus, the statement
☛ ✟
g . drawString ( ” Hello World” , 50 , 5 0 ) ;
✡ ✠
will display “Hello World” inside the rectangle. We can use si milar plan-
ning to locate the oval and its enclosed message.
Thus, we now have sufﬁcient information to ﬁnish the paint()
method for accomplishing our plan. The completed program is displayed
in Figure 2.9. Note how we repeatedly use the g.setColor() method to
☛ ✟
import java . awt . ∗;
import java . applet . ∗;
public c l a s s HelloWorldGraphic extends Applet
{public void paint ( Graphics g )
{g . setColor ( Color . cyan ) ; // S e t c o l o r
g . f i l l R e c t ( 2 5 , 25 , 140 , 4 0 ) ; // F i l l r e c t a n g l e
g . setColor ( Color . blue ) ; // S e t c o l o r
g . drawRect ( 2 5 , 25 , 140 , 4 0 ) ; // O u t l i n e r e c t a n g l e
g . setColor ( Color . black ) ; // S e t c o l o r
g . drawString ( ” Hello World” , 50 , 5 0 ) ; // D i s p l a y s t r i n g
g . setColor ( Color . yellow ) ;
g . f i l l O v a l ( 2 5 , 75 , 140 , 4 0 ) ; // F i l l o v a l
g . setColor ( Color . red ) ;
g . drawOval ( 2 5 , 75 , 140 , 4 0 ) ; // O u t l i n e o v a l
g . setColor ( Color . black ) ;
g . drawString ( ”Welcome to Java ” , 50 , 1 0 0 ) ;
}// p a i n t ( )
}// H e l l o W o r l d G r a p h i c
✡ ✠
Figure 2.9: The HelloWorldGraphic class is an applet that shows how
to use color and drawing methods.
change g’s current color before drawing each element of our picture.
72 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
Figure 2.10 shows what this applet looks like when run in a bro wser. To
experiment with this applet, download its sourcecode and it s correspond-
ing HTML ﬁle from the book’s Web site and compile and run it on yo ur
computer. If you’ve forgotten how to run an applet, review Sec tion 1.5.5.
Additional drawing capabilities will be explored througho ut the text in
sections that can either be covered or skipped.
Figure 2.10: This is how the
HelloWorldGraphic applet
will look when run in a browser.
2.4 Class Deﬁnition
To program in Java the main thing you do is write class deﬁniti ons for the The class as template
various objects that will make up the program. A class deﬁniti onencapsu-
lates its objects’ data and behavior. Once a class has been deﬁned, i t serves
as atemplate , or blueprint, for creating individual objects or instances of the
class.
A class deﬁnition contains two types of elements: variables and meth-
ods. Variables are used to store the object’s information. Methods are used Variables and methods
to process the information. To design an object you need to ans wer ﬁve
basic questions:
1. What role will the object perform in the program?
2. What data or information will it need?
3. What actions will it take?
4. What interface will it present to other objects?
5. What information will it hide from other objects?
FIGURE 2.11 TheRiddle class.2.4.1 The Riddle Class
Recall our deﬁnition of the Riddle class from Chapter 1, which is sum-
marized in the UML diagram in Figure 2.11. A Riddle has two attributes,
question andanswer . Each of these variables stores a string of charac-
ters, which Java treats as data of type String . TheRiddle class contains
SECTION 2.4 •Class Deﬁnition 73
three methods. The Riddle() constructor method assigns initial values
(qanda) to its question andanswer variables. The getQuestion()
andgetAnswer() methods return the data stored in question ands
answer respectively.
The instance variables question andanswer are designated as
private (−), but the Riddle() ,getQuestion() andgetAnswer()
methods are designated as public (+). These designations follow two
important object-oriented design conventions, whose justiﬁ cation will be-
come apparent as we discuss the Riddle class:
JAVA EFFECTIVE DESIGN Private Variables. Instance variables are
usually declared private so that they cannot be directly accessed by
other objects.
JAVA EFFECTIVE DESIGN Public Methods. An object’s public
methods can be used by other objects to interact with the object . The
public methods and variables of an object make up its interface .
Figure 2.12 shows the Java class deﬁnition that corresponds to the de-
sign given in the UML diagram. It contains the two private instance
☛ ✟
public c l a s s Riddle
{private S t r i n g question ; // I n s t a n c e v a r i a b l e s
private S t r i n g answer ;
public Riddle ( S t r i n g q , S t r i n g a ) // C o n s t r u c t o r
{question = q ;
answer = a ;
}// R i d d l e c o n s t r u c t o r
public S t r i n g getQuestion ( ) // I n s t a n c e m e t h o d
{return question ;
}// g e t Q u e s t i o n ( )
public S t r i n g getAnswer ( ) // I n s t a n c e m e t h o d
{return answer ;
}// g e t A n s w e r ( )
}// R i d d l e c l a s s
✡ ✠
Figure 2.12: Deﬁnition of the Riddle class.
variables and deﬁnes the three public methods listed in the UML dia-
gram. In a Java class deﬁnition, access to a class element, suc h as a vari-
able or a method, is controlled by labeling it with either the private , or
public access modiﬁer. An access modiﬁer is a declaration that controls Access modiﬁer
access to a class or one of its elements. Note also that the Riddle class
itself is declared public . This lets other classes have access to the class
and to its public variables and methods.
74 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
Recall that a class is like a blueprint or a cookie cutter. The Riddle class
deﬁnes the type of information (attributes) that each indiv idualRiddle
has, but it doesn’t contain any actual values. It deﬁnes the me thods (op-
erations) that each Riddle can perform, but it doesn’t actually perform
the methods. In short, a class serves as a template, providing a detailed
blueprint of the objects (or instances) of that class. Class as blueprint
2.4.2 The RiddleUser Class
Now that we have deﬁned the Riddle class, we can test that it works
correctly by creating Riddle objects and “asking” them to tell us their
riddles. To do this we need to deﬁne a main() method, which can be
deﬁned either within the Riddle class itself or in a second class named
something like RiddleUser .
One advantage of using a second class is that it gets us in the h abit of User interface
thinking about the need for a separate class to serve as a user interface,
with a separate set of tasks from the Riddle class. A user interface is an
object or class that handles the interaction between a progra m’s user and
the rest of the program’s computational tasks. This concept is illustrated
in Figure 2.13. Note that we use the general term computational object to
distinguish the rest of the program’s computations from the user interface.
Obviously, the exact nature of the computation will vary fro m program to
program, just as will the details of the user interface. The co mputation
done by our Riddle class is just the storing and displaying of a riddle’s
question and answer.
FIGURE 2.13 The user interfaces
handles interaction between the user
and the rest of the program.By separating user interface tasks from riddle tasks this de sign em-
ploys the divide-and-conquer principle: the RiddleUser class will cre-
ateRiddle objects and handle interactions with the user, and the Riddle
class will handle the storing and transmission of riddle inf ormation. Thus,
as shown in Figure 2.14, this particular Java program will in volve inter-
action between two types of objects: a RiddleUser and one or more
Figure 2.14: This UML class di-
agram represents an association
between the RiddleUser and
Riddle classes. The Riddle-
User class will useone or more
objects of the Riddle class.
Riddles . Note that we characterize the relationship between Riddle
andRiddleUser with a one-way arrow labeled “Uses.” This is because
SECTION 2.4 •Class Deﬁnition 75
theRiddleUser will create an instance of Riddle and use its methods
to display (for the user) a riddle.
Because almost all of our programs will involve some form of a user in-
terface, we can generalize this design approach and follow i t throughout
the book. One way to think about this approach is as a division of labor
between a user interface class and a second computational class, which per-
forms whatever computations are needed by the particular pr ogram. In
this case the computations are the simple Riddle methods that we have
deﬁned. In subsequent programs the computations will become more
complex, which will make all the more clear that they should b e separated
from the user interface.
2.4.3 Object Instantiation: Creating Riddle Instances
Figure 2.15 shows the complete deﬁnition of the RiddleUser class,
which serves as a very simple user interface. It creates two Riddle ob-
jects, named riddle1 andriddle2 . It then asks each object to request
each riddle’s question and answer and displays them on the co nsole.
☛ ✟
public c l a s s RiddleUser
{
public s t a t i c void main ( S t r i n g argv [ ] )
{Riddle r i d d l e 1 = new Riddle (
”What i s black and white and red a l l over ? ” ,
”An embarrassed zebra . ” ) ;
Riddle r i d d l e 2 = new Riddle (
”What i s black and white and read a l l over ? ” ,
”A newspaper . ” ) ;
System . out . p r i n t l n ( ”Here are two r i d d l e s : ” ) ;
System . out . p r i n t l n ( r i d d l e 1 . getQuestion ( ) ) ;
System . out . p r i n t l n ( r i d d l e 2 . getQuestion ( ) ) ;
System . out . p r i n t l n ( ”The answer to the f i r s t r i d d l e i s : ” ) ;
System . out . p r i n t l n ( r i d d l e 1 . getAnswer ( ) ) ;
System . out . p r i n t l n ( ”The answer to the second i s : ” ) ;
System . out . p r i n t l n ( r i d d l e 2 . getAnswer ( ) ) ;
}// m a i n ( )
}// R i d d l e U s e r
✡ ✠
Figure 2.15: The RiddleUser class.
Let’s now discuss the statements that make up RiddleUser ’smain()
method. The following statements use the Riddle() constructor to cre-
ate, or instantiate , two instances of the Riddle class:
☛ ✟
Riddle r i d d l e 1 = new Riddle (
”What i s black and white and red a l l over ? ” ,
”An embarrassed zebra . ” ) ;
Riddle r i d d l e 2 = new Riddle (
”What i s black and white and read a l l over ? ” ,
”A newspaper . ” ) ;
✡ ✠
76 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
Note how the constructor gives each object a pair of String s that serve
as the values of their two instance variables. Each object has its own
question and its own answer , and each object has its own unique name,
riddle1 andriddle2 .
2.4.4 Interacting with Riddle s
Once we have created Riddle instances with values assigned to their
question andanswer instance variables, we can ask each riddle to tell
us either of its values. The following expression is an examp le of a method
call:
☛ ✟
r i d d l e 1 . getQuestion ( )
✡ ✠
Calling (or invoking) a method is a means of executing its cod e. The above Method call
method call just gets the String value that is stored in the question
instance variable of riddle1 .
JAVA PROGRAMMING TIP Method Call versus Method
Deﬁnition. Don’t confuse method calls with method deﬁnitions. The
deﬁnition speciﬁes the method’s actions. The method call ta kes those
actions.
If we want to display the value of riddle1 ’squestion , we can embed
this method call within a println() statement
☛ ✟
System . out . p r i n t l n ( r i d d l e 1 . getQuestion ( ) ) ;
✡ ✠
This tells the System.out object to execute its println() method,
which displays the string given to it by riddle1 on the console. Thus,
the output produced by this statement will be
☛ ✟
What i s black and white and red a l l over ?
✡ ✠
2.4.5 Deﬁne, Create, Use
As our Riddle example illustrates, writing a Java program is a matter of
three basic steps:
•Deﬁne one or more classes (class deﬁnition).
•Create objects as instances of the classes (object instantiat ion).
•Use the objects to do tasks (object use).
The Java class deﬁnition determines what information will b e stored in
each object and what methods each object can perform. Instantia tion cre-
ates an instance and associates a name with it in the program. The ob-
ject’s methods can then be called as a way of getting the object t o perform
certain tasks.
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 77
SELF-STUDY EXERCISES
EXERCISE 2.2 Identify the following elements in the Riddle class
(Fig. 2.12):
•The name of the class.
•The names of two instance variables.
•The names of three methods.
EXERCISE 2.3 Identify the following elements in the RiddleUser
class (Fig. 2.15):
•The names of two Riddle instances.
•All six method calls of the Riddle objects in the program.
•Two examples of qualiﬁed names.
2.5 CASE STUDY: Simulating a Two-Person
Game
In this section, we will design and write the deﬁnition for a cl ass that keeps
track of the details of a well known, two-person game. We will focus on
details of designing the deﬁnition of a class in the Java lang uage. Our
objective is to understand what the program is doing and how it works
without necessarily understanding why it works the way it do es. We will
get to “why” later in the book.
The game we will consider is played by two persons with a row of
sticks or coins or other objects. The players alternate turns . A player must
remove one, two, or three sticks from the row on his or her turn . The
player who removes the last stick from the row loses. The game can be
played with any number of sticks but starting with twenty one sticks is
quite common. This game is sometimes referred to as the game o f ”Nim”,
but there is a similar game involving multiple rows of sticks that is more
frequently given that name. Thus we will refer to this game as ”One Row
Nim”.
2.5.1 Designing a OneRowNim class
Problem Speciﬁcation
Let’s design a class named OneRowNim that simulates the game of One
Row Nim with a row of sticks. An object constructed with this cl ass
should manage data that corresponds to having some speciﬁed number
of sticks when the game begins. It should keep track of whose tu rn it is
and it should allow a player to diminish the number of sticks r emaining by
one, two, or three. Finally, a OneRowNim object should be able to decide
when the game is over and which player has won.
Problem Decomposition
Let’s design OneRowNim so that it can be used in with different kinds of
user interfaces. One user interface could manage a game play ed by two
persons who alternately designate their moves to the comput er. Another
78 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
user interface could let a human player play against moves ma de by the
computer. In either of these cases we could have a human player desig-
nate a move by typing from the keyboard after being prompted i n a con-
sole window or, alternatively, by inputting a number into a t ext ﬁeld or se-
lecting a radio button on a window. In this chapter, we will be c oncerned
only with designing an object for managing the game. We will de sign user
interfaces for the game in subsequent chapters.
Class Design: OneRowNim
As we saw in the Riddle example, class deﬁnitions can usually be broken
down into two parts: (1) the information or attributes that t he object needs
which must be stored in variables, and (2) the behavior or act ions the ob-
ject can take which are deﬁned in methods. In this chapter, we wi ll focus
on choosing appropriate instance variables and on designin g methods as
blocks of reusable code. Recall that a parameter is a variabl e that tem-
porarily stores data values that are being passed to a method when that
method is called. In this chapter, we will restrict our design to methods
that do not have parameters and do not return values. We will r eturn to
the problem of designing changes to this class in the next cha pter after an
in-depth discussion of method parameters and return values .
TheOneRowNim object should manage two pieces of information that What data do we need?
vary as the game is played. One is the number of sticks remaini ng in the
row and the other is which player has the next turn. Clearly, t he number
of sticks remaining corresponds to a positive integer that c an be stored in
a variable of type int. One suitable name for such a variable is nSticks .
For this chapter, let us assume that the game starts with 7 sti cks, rather
than 21, to simplify discussion of the program.
Data designating which player takes the next turn could be st ored in
different ways. One way to do this is to think of the players as player one
and player two and store a 1 or 2 in an int variable. Let’s use player as
the name for such a variable and assume that player one has the ﬁrst turn.
The values of these two variable for a particular OneRowNim object at a
particular time describes the object’s state. An object’s sta te at the begin-
ning of a game is a 7 stored in nSticks and 1 stored in player . After
player one removes, say, two sticks on the ﬁrst turn, the valu es 5 and 2
will be stored in the two variables.
Method Decomposition
Now that we have decided what information the OneRowNim object
should manage, we need to decide what actions it should be abl e to per-
form. We should think of methods that would be needed to commu nicate
with a user interface that is both prompting some human playe rs as well
as receiving moves from them. Clearly, methods are needed fo r taking a What methods do we need?
turn in the game. If a message to a OneRowNim object has no argument
to indicate the number of sticks taken, there will need to be t hree meth-
ods corresponding to taking one, two, or three sticks. The me thod names
takeOne() ,takeTwo() , andtakeThree() are descriptive of this ac-
tion. Each of these methods will be responsible for reducing the value of
nSticks as well as changing the value of player .
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 79
We should also have a method that gives the information that a user
needs when considering a move. Reporting the number of stick s remain-
ing and whose turn it is to the console window would be an appro priate
action. We can use report() as a name for this action.
Figure 2.16 is a UML class diagram that summarizes this desig n of the
FIGURE 2.16 A UML class diagram
forOneRowNim .OneRowNim class. Note that the methods are declared public ( +) and
will thereby form the interface for a OneRowNim object. These will be the
methods that other objects will use to interact with it. Simil arly, we have
followed the convention of designating an object’s instance variables—the
OneRowNim ’s instance variables—be kept hidden from other objects, and
so we have designated them as private( −).
2.5.2 Deﬁning the OneRowNim Class
Given our design of the OneRowNim class as described in Figure 2.16,
the next step in building our simulation is to begin writing t he Java class
deﬁnition.
The Class Header
We need a class header , which will give the class a name and will spec-
ify its relationship to other classes. Like all classes that are designed to
create objects that could be used by other objects or classes, t he class
OneRowNim should be preceded by the public modiﬁer. Because the
classOneRowNim has not been described as having any relationship to
any other Java class, its header can omit the extends clause so it will
be a direct subclass of Object (Figure 2.17). Thus, the class header for
FIGURE 2.17 By default,
OneRowNim is a subclass of Object .OneRowNim will look like:
☛ ✟
public c l a s s OneRowNim // C l a s s h e a d e r
{ // B e g i n n i n g o f c l a s s b o d y
} // E n d o f c l a s s b o d y
✡ ✠
The Class’s Instance Variables
The body of a class deﬁnition consists of two parts: the class -level vari- Variables and methods
ables and the method deﬁnitions. A class-level variable is a variable
whose deﬁnition applies to the entire class in which it is deﬁ ned. Instance
variables, which were introduced in Chapter 1, are one kind o f class-level
variable.
In general, a class deﬁnition will take the form shown in Figur e 2.18.
Although Java does not impose any particular order on variab le and
method declarations, in this book we’ll deﬁne the class’s cl ass-level vari-
ables at the beginning of the class deﬁnition, followed by me thod deﬁni-
tions. Class-level variables are distinguished from local variables. A local Class-level vs. local variables
variable is a variable that is deﬁned within a method. Examples would
be the variables qandathat were deﬁned in the Riddle(String q,
String a) constructor (Fig. 2.12). As we will see better in Chapter 3,
Java handles each type of variable differently.
80 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
☛ ✟
public c l a s s ClassName
{ // I n s t a n c e a n d c l a s s v a r i a b l e s
V a r i a b l e D e c l a r a t i o n 1
V a r i a b l e D e c l a r a t i o n 2
. . .
// I n s t a n c e a n d c l a s s m e t h o d s
MethodDefinition1
MethodDefinition2
. . .
}// E n d o f c l a s s
✡ ✠
Figure 2.18: A template for constructing a Java class deﬁnit ion.
A declaration for a variable at class level must follow the ru les for
declaring variables that were described in Section 1.4.8 wi th the added
restriction that they should be modiﬁed by one of the access m odiﬁers
public ,private , orprotected . The rules associated with these access
modiﬁers are:
•Aprivate class-level variable cannot be accessed outside the class
in which it is declared.
•Apublic class-level variable can be referenced and, hence, modi-
ﬁed by any other class.
•Aprotected class-level variable can only be accessed by sub-
classes of the class in which it is declared or by other classe s that
belong to the same package.
When a class, instance variable, or method is deﬁned, you can d eclare it
public ,protected , orprivate . Or you can leave its access unspeci-
ﬁed, in which case Java’s default accessibility will apply.
Java determines accessibility in a top-down manner. Instanc e vari-
ables and methods are contained in classes, which are contai ned in pack-
ages. To determine whether a instance variable or method is a ccessible,
Java starts by determining whether its containing package i s accessible,
and then whether its containing class is accessible. Access to classes, in-
stance variables, and methods is deﬁned according to the rul es shown in
Table 2.2.
TABLE 2.2 Java’s accessibility rules.
Element Modiﬁer Rule
Class public Accessible if its package is accessible.
by default Accessible only within its package.
Instance variable public Accessible to all other objects.
or protected Accessible to its subclasses and to
instance method other classes in its package.
private Accessible only within the class.
by default Accessible only within the package.
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 81
Recall the distinction we made in Chapter 0 between class var iables
and instance variables. A class variable is associated with the class it-
self, whereas an instance variable is associated with each o f the class’s in-
stances. In other words, each object contains its own copy of th e class’s in-
stance variables, but only the class itself contains the sin gle copy of a class
variable. To designate a variable as a class variable it must be declared
static .
TheRiddle class that we considered earlier has the following two
examples of valid declarations of instance variables:
☛ ✟
private S t r i n g question ;
private S t r i n g answer ;
✡ ✠
Class Level Variables for OneRowNim
Let’s now consider how to declare the class level variables f or the
OneRowNim class. The UML class diagram for OneRowNim in Figure 2.16
contains all the information we need. The variables nSticks andplayer
will store data for playing one game of One Row Nim, so they sho uld
clearly be private instance variables. They both will store integer values,
so they should be declared as variables of type int. Because we wish
to start a game of One Row Nim using 7 sticks with player one mak ing
the ﬁrst move, we will assign 7 as the initial value for nSticks and 1 as
the initial value for player . If we add the declarations for our instance
variable declarations to the class header for the OneRowNim class, we get
the following:
☛ ✟
public c l a s s OneRowNim
{
private i n t n S t i c k s = 7 ;
private i n t player = 1 ;
// M e t h o d d e f i n i t i o n s g o h e r e
}// OneRowNim
✡ ✠
To summarize, despite its apparent simplicity, a class leve l variable
declaration actually accomplishes ﬁve tasks:
1. Sets aside a portion of the object’s memory that can be used t o store a
certain type of data.
2. Speciﬁes the type of data that can be stored in that locatio n.
3. Associates an identiﬁer (or name) with that location.
4. Determines which objects have access to the variable’s nam e.
5. Assigns an initial value to the location.
OneRowNim’s Methods
Designing and deﬁning methods is a form of abstraction. By de ﬁning a
certain sequence of actions as a method, you encapsulate tho se actions
under a single name that can be invoked whenever needed. Inste ad of
having to list the entire sequence again each time you want it performed,
82 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
you simply call it by name. As you recall from Chapter 1, a meth od def-
inition consists of two parts, the method header and the meth od body.
The method header declares the name of the method and other ge neral
information about the method. The method body contains the e xecutable
statements that the method performs.
☛ ✟
public void methodName ( ) // M e t h o d h e a d e r
{ // B e g i n n i n g o f m e t h o d b o d y
} // E n d o f m e t h o d b o d y
✡ ✠
The Method Header
The method header follows a general format that consists of o ne or
more MethodModiﬁers , the method’s ResultType , the MethodName , and the
method’s FormalParameterList , which is enclosed in parentheses. The fol-
lowing table illustrates the method header form, and includ es several ex-
amples of method headers that we have already encountered. T he method
body follows the method header.
MethodModiﬁers opt ResultType MethodName (FormalParameterList)
public static void main (String argv[])
public void paint (Graphics g)
public Riddle (String q, String a)
public String getQuestion ()
public String getAnswer ()
The rules on method access are the same as the rules on instanc e vari-
able access: private methods are accessible only within the class it-
self,protected methods are accessible only to subclasses of the class
in which the method is deﬁned and to other classes in the same p ackage,
andpublic methods are accessible to all other classes.
JAVA EFFECTIVE DESIGN Public versus Private Methods. If a
method is used to communicate with an object, or if it passes
information to or from an object, it should be declared public . If a
method is intended to be used solely for internal operations within the
object, it should be declared private . These methods are sometimes
called utility methods orhelper methods .
Recall the distinction from Chapter 0 between instance meth ods and
class methods. Methods declared at the class level are assum ed to be in-
stance methods unless they are also declared static . The static modiﬁer
is used to declare that a class method or variable is associat ed with the
class itself, rather than with its instances. Just as for static variables,
methods that are declared static are associated with the class and are
therefore called class methods . As its name implies, an instance method can
only be used in association with an object (or instance) of a cl ass. Most
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 83
of the class-level methods we declare will be instance metho ds. Class
methods are used only rarely in Java and mainly in situations where it
is necessary to perform some kind calculation before objects of the class
are created. We will see examples of class methods when we dis cuss the
Math class, which has such methods as sqrt(N) to calculate the square
root of N.
JAVA PROGRAMMING TIP Class versus Instance Methods. If a
method is designed to be used by an object, it is referred to as a n
instance method. No modiﬁer is needed to designate an instan ce
method. Class methods, which are used infrequently compare d to
instance methods, must be declared static .
All four of the methods in the OneRowNim class are instance methods
(Fig. 2.19). They all perform actions associated with a part icular instance
☛ ✟
public c l a s s OneRowNim
{private i n t n S t i c k s = 7 ; // S t a r t w i t h 7 s t i c k s .
private i n t player = 1 ; // P l a y e r 1 p l a y s f i r s t .
public void takeOne ( ) { } // M e t h o d b o d i e s n e e d
public void takeTwo ( ) { } // t o b e d e f i n e d .
public void takeThree ( ) { }
public void report ( ) { }
}// OneRowNim c l a s s
✡ ✠
Figure 2.19: The Instance variables and method headers for th e
OneRowNim class.
ofOneRowNim . That is, they are all used to manage a particular One Row
Nim game. Moreover, all four methods should be declared public , be-
cause they are designed for communicating with other objects rather than
for performing internal calculations. Three of the methods are described
as changing the values of the instance variables nSticks andplayer
and the fourth, report() , writes information to the console. All four
methods will receive no data when being called and will not re turn any
values. Thus they should all have void as a return type and should all
have empty parameter lists.
Given these design decisions, we now can add method headers t o our
class deﬁnition of OneRowNim , in Figure 2.19. The ﬁgure displays the class
header, instance variable declarations, and method header s.
The Method Body
The body of a method deﬁnition is a block of Java statements en closed Designing a method is an application
of the encapsulation principle. by braces, , which are executed in sequence when the method is called.
The description of the action required of the takeOne() method is typ-
ical of many methods that change the state of an object. The bod y of
thetakeOne() method should use a series of assignment statements
to reduce the value stored in nSticks by one and change the value in
84 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
player from 2 to 1 or from 1 to 2. The ﬁrst change is accomplished in a
straightforward way by the assignment:
☛ ✟
n S t i c k s = n S t i c k s −1 ;
✡ ✠
This statement says subtract 1 from the value stored in nSticks and
assign the new value back to nSticks .
Deciding how to change the value in player is more difﬁcult because
we do not know whether its current value is 1 or 2. If its current value is 1,
its new value should be 2; if its current value is 2, its new val ue should be
1. Notice, however, that in both cases the current value plus the desired
new value are equal to 3. Therefore, the new value of player is equal to
3 minus its current value. Writing this as an assignment we ha ve:
☛ ✟
player = 3 −player ;
✡ ✠
One can easily verify that this clever assignment assigns 2 t oplayer if its
current value is 1 and assigns 1 to it if its current value is 2. In effect, this
assignment will toggle the value off player between 1 and 2 each time
it is executed. In the next chapter we will introduce the if-else control
structure that would allow us to accomplish this same toggli ng action in
a more straightforward manner. The complete deﬁnition of takeOne()
method becomes:
☛ ✟
public void takeOne ( )
{
n S t i c k s = n S t i c k s −1 ; // T a k e o n e s t i c k
player = 3 −player ; // C h a n g e t o o t h e r p l a y e r
}
✡ ✠
ThetakeTwo() andtakeThree() methods are completely analogous
to the takeOne() method with the only difference being the amount
subtracted from nSticks .
The body of the report() method must merely print the cur-
rent values of the instance variables to the console window w ith
System.out.println() . To be understandable to someone using a
OneRowNim object, the values should be clearly labeled. Thus the body
ofreport() could contain:
☛ ✟
System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ” + n S t i c k s ) ;
System . out . p r i n t l n ( ”Next turn by player ” + player ) ;
✡ ✠
This completes the method bodies of the OneRowNim class. The com-
pleted class deﬁnition is shown in Figure 2.20. We will discu ss alterna-
tive methods for this class in the next chapter. In Chapter 4, w e will de-
velop several One Row Nim user interface classes that will fa cilitate a user
indicating certain moves to make.
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 85
☛ ✟
public c l a s s OneRowNim
{private i n t n S t i c k s = 7 ; // S t a r t w i t h 7 s t i c k s .
private i n t player = 1 ; // P l a y e r 1 p l a y s f i r s t .
public void takeOne ( )
{n S t i c k s = n S t i c k s −1 ;
player = 3 −player ;
}// t a k e O n e ( )
public void takeTwo ( )
{n S t i c k s = n S t i c k s −2 ;
player = 3 −player ;
}// t a k e T w o ( )
public void takeThree ( )
{n S t i c k s = n S t i c k s −3 ;
player = 3 −player ;
} // t a k e T h r e e ( )
public void report ( )
{System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ” + n S t i c k s ) ;
System . out . p r i n t l n ( ”Next turn by player ” + player ) ;
} // r e p o r t ( )
}// OneRowNim1 c l a s s
✡ ✠
Figure 2.20: The OneRowNim class deﬁnition.
2.5.3 Testing the OneRowNim Class
Recall our deﬁne, create, and use mantra from Section 2.4.5. Now that we
have deﬁned the OneRowNim class, we can test whether it works correctly
by creating OneRowNim objects and using them to perform the actions as-
sociated with the game. At this point, we can test OneRowNim by deﬁning
amain() method. Following the design we used in the riddle example,
we will locate the main() method in separate, user interface class, named
OneRowNimTester .
The body of main() should declare a variable of type OneRowNim and
create an object for it to refer to. The variable can have any na me, but a
name like game would be consistent with it recording moves in a single
game. To test the OneRowNim class, we should make a typical series of
moves. For example, three moves taking 3, 3, and 1 sticks resp ectively
would be one way that the 7 sticks could be removed. Also, exec uting
thereport() method before the ﬁrst move and after each move should
display the current state of the game in the console window so that we can
determine whether it is working correctly.
The following pseudocode outlines an appropriate sequence of state-
ments in a main() method:
86 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
1. Declare a variable of type OneRowNim named game .
2. Instantiate a OneRowNim object to which game refers.
3. Command game to report.
4. Command game to remove three sticks.
5. Command game to report.
6. Command game to remove three sticks.
7. Command game to report.
8. Command game to remove one stick.
9. Command game to report.
It is now an easy task to convert the steps in the pseudocode out line
into Java statements. The resulting main() method is shown with the
complete deﬁnition of the OneRowNimTester class:
☛ ✟
public c l a s s OneRowNimTester
{public s t a t i c void main ( S t r i n g args [ ] )
{ OneRowNim1 game = new OneRowNim ( ) ;
game . report ( ) ;
game . takeThree ( ) ;
game . report ( ) ;
game . takeThree ( ) ;
game . report ( ) ;
game . takeOne ( ) ;
game . report ( ) ;
}// m a i n ( )
}
✡ ✠
When it is run, OneRowNimTester produces the following output:
☛ ✟
Number of s t i c k s l e f t : 7
Next turn by player 1
Number of s t i c k s l e f t : 4
Next turn by player 2
Number of s t i c k s l e f t : 1
Next turn by player 1
Number of s t i c k s l e f t : 0
Next turn by player 2
✡ ✠
This output indicates that player 1 removed the ﬁnal stick an d so player 2
is the winner of this game.
SELF-STUDY EXERCISES
EXERCISE 2.4 Add a new declaration to the Riddle class for a
private String instance variable named hint . Assign the variable
an initial value of "This riddle is too easy for a hint" .
EXERCISE 2.5 Write a header for a new method deﬁnition for Riddle
named getHint() . Assume that this method requires no parameters
and that it simply returns the String value stored in the hint instance
variable. Should this method be declared public orprivate ?
EXERCISE 2.6 Write a header for the deﬁnition of a new public
method for Riddle named setHint() which sets the value of the hint
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 87
instance variable to whatever String value it receives as a parameter.
What should the result type be for this method?
EXERCISE 2.7 Create a partial deﬁnition of a Student class. Create
instance variables for the ﬁrst name, last name, and an integ er student
identiﬁcation number. Write the headers for three methods. One method
uses three parameters to set values for the three instance va riables. One
method returns the student identiﬁcation number. The last m ethod re-
turns a String containing the student’s ﬁrst name and last name. Write
only the headers for these methods.
2.5.4 Flow of Control: Method Call and Return
A program’s ﬂow of control is the order in which its statements are ex-
ecuted. In an object-oriented program, control passes from on e object to
another during the program’s execution. It’s important to ha ve a clear
understanding of this process.
In order to understand a Java program, it is necessary to under stand the
method call and return mechanism. We will encounter it repeatedly. A
method call causes a program to transfer control to a stateme nt located in
another method. Figure 2.21 shows the method call and return structure.
method1()
method2();
nextstatement1;method2()
statement1;
return;Figure 2.21: The method call and
return control structure. It’s im-
portant to realize that method1()
andmethod2() may be con-
tained in different classes.
In this example, we have two methods. We make no assumptions ab out
where these methods are in relation to each other. They could be deﬁned
in the same class or in different classes. The method1() method executes
sequentially until it calls method2() . This transfers control to the ﬁrst
statement in method2() . Execution continues sequentially through the
statements in method2() until the return statement is executed.
JAVA LANGUAGE RULE Return Statement. Thereturn
statement causes a method to return control to the calling
statement —that is, to the statement that called the method in the ﬁrst
place.
Recall that if a void method does not contain a return statement, then
control will automatically return to the calling statement after the invoked Default returns
method executes its last statement.
2.5.5 Tracing the OneRowNim Program
To help us understand the ﬂow of control in OneRowNim , we will perform
a trace of its execution. Figure 2.22 shows all of the Java cod e involved in
the program. In order to simplify our trace, we have moved the main()
method from OneRowNimTester to theOneRowNim class. This does not
88 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
☛ ✟
public c l a s s OneRowNim
2{ private i n t n S t i c k s = 7 ; // S t a r t w i t h 7 s t i c k s .
3 private i n t player = 1 ; // P l a y e r 1 p l a y s f i r s t .
public void takeOne ( )
20{ n S t i c k s = n S t i c k s −1 ;
21 player = 3 −player ;
}// t a k e O n e ( )
public void takeTwo ( )
{ n S t i c k s = n S t i c k s −2 ;
player = 3 −player ;
}// t a k e T w o ( )
public void takeThree ( )
8 ,14{ n S t i c k s = n S t i c k s −3 ;
9 ,15 player = 3 −player ;
} // t a k e T h r e e ( )
public void report ( )
5 , 1 1 , 1 7 , 2 3 {System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ” + n S t i c k s ) ;
6 , 1 2 , 1 8 , 2 4 System . out . p r i n t l n ( ”Next turn by player ” + player ) ;
} // r e p o r t ( )
public s t a t i c void main ( S t r i n g args [ ] )
1{OneRowNim1 game = new OneRowNim1 ( ) ;
4 game . report ( ) ;
7 game . takeThree ( ) ;
10 game . report ( ) ;
13 game . takeThree ( ) ;
16 game . report ( ) ;
19 game . takeOne ( ) ;
22 game . report ( ) ;
23 }// m a i n ( )
}// OneRowNim1 c l a s s
✡ ✠
Figure 2.22: A trace of the OneRowNim program.
affect the program’s order of execution in any way. But keep i n mind that
the code in the main() method could just as well appear
in theOneRowNimTester class. The listing in Figure 2.22 also adds
line numbers to the program to show the order in which its stat ements are
executed.
Execution of the OneRowNim program begins with the ﬁrst statement
in themain() method, labeled with line number 1. This statement de-
clares a variable of type OneRowNim named game and calls a constructor
OneRowNim() to create and initialize it. The constructor, which in this
case is a default constructor, causes control to shift to the declaration ofnSticks : int =7
player : int =1game : OneRowNim
FIGURE 2.23 The initial state of
game , aOneRowNim object.the instance variables nSticks andplayer in statements 2 and 3, and as-
signs them initial values of 7 and 1 respectively. Control th en shifts back to
the second statement in main() , which has the label 4. At this point, game
refers to an instance of the OneRowNim class with an initial state shown in
Figure 2.23. Executing statement 4 causes control to shift t o thereport()
SECTION 2.5 •CASE STUDY: Simulating a Two-Person Game 89
method where statements 5 and 6 use System.out.println() to write
the following statements to the console.
☛ ✟
Number of s t i c k s l e f t : 7
Next turn by player 1
✡ ✠
Control shifts back to statement 7 in the main() method, which calls
thetakeThree() method, sending control to the ﬁrst statement of that
method. Executing statement 8 causes 3to be subtracted from the int
value stored in the instance variable nSticks ofgame , leaving the value
of4. Executing statement 9 subtracts the value stored in the player vari-
able, which is 1, from3and assigns the result (the value 2) back to player .
The state of the object game , at this point, is shown in Figure 2.24. TracingnSticks : int =4
player : int =2game : OneRowNim
FIGURE 2.24 The state of game
after line 9 is executed.the remainder of the program follows in a similar manner. Not ice that
themain() method calls game.report() four different times so that
the two statements in the report() method are both executed on four
different occasions. Note also that there is no call of game.takeTwo()
inmain() . As a result, the two statements in that method are never
executed.
2.5.6 Object-Oriented Design: Basic Principles
We complete our discussion of the design and this ﬁrst implem entation
of theOneRowNim class with a brief review of some of the object-oriented
design principles that were employed in this example.
•Encapsulation. TheOneRowNim class was designed to encapsulate a
certain state and a certain set of actions. It was designed to s imulate
playing the One Row Nim game. In addition, OneRowNim ’s methods
were designed to encapsulate the actions that make up their p articular
tasks.
•Information Hiding. OneRowNim ’s instance variables, nSticks and
player are declared private so other objects can only change the
values of these variables with the public methods of a OneRowNim in-
stance. The bodies of the public methods are also hidden from users
ofOneRowNim instances. An instance and its methods can be used
without any knowledge of method deﬁnitions.
•Clearly Designed Interface. OneRowNim ’s interface is deﬁned in terms
of the public methods. These methods constrain the way users can in-
teract with OneRowNim objects and ensures that OneRowNim instances
remain in a valid state. Those are the main purposes of a good i nterface.
•Generality and Extensibility. There is little in our design of
OneRowNim that limits its use and its extensibility. Moreover, as we
will see later, we can create several different kinds of user interfaces
which interact with OneRowNim objects.
TheOneRowNim class has some obvious shortcomings that are a result
of our decision to limit methods to those without parameters or return
values. These shortcomings include:
•AOneRowNim object cannot communicate to another object the number
of remaining sticks, which player makes the next turn, or whe ther the
90 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
game is over. It can only communicate by writing a report to the console
window.
•ThetakeOne() ,takeTwo() andtakeThree() methods all have
similar deﬁnitions. It would be a better design if a single met hod could
take away a speciﬁed number of sticks.
•There is no way to play a OneRowNim game starting with a different
number of sticks than 7. It would be nice to have a way of playing a
game that starts with any number of sticks.
•In order to for a user to play a OneRowNim game, a user interface
class would need to be developed that would allow the user to r eceive
information about the state of the game and to input moves to m ake.
As we study other features of Java in the next two chapters, we will
modify the OneRowNim class to address these identiﬁed shortcomings.
Special Topic: Alan Kay and
the Smalltalk Language
Although Simula was the ﬁrst programming language to use the con-
cept of an object, the ﬁrst pure object-oriented language was Smalltalk .
Smalltalk was ﬁrst started by Alan Kay in the late 1960s. Kay i s an
innovative thinker who has had a hand in the development of se veral
advances, including windowing interfaces, laser printing , and the clien-
t/server model, all of which are now commonplace today.
One of the abiding themes throughout Kay’s career has been th e idea
that computers should be easy enough for kids to use. In the lat e 1960s,
while still in graduate school, Kay designed a computer mode l that con-
sisted of a notebook-sized portable computer with a keyboar d, screen,
mouse, and high-quality graphics interface. He had become co nvinced
that graphics and icons were a far better way to communicate w ith a
computer than the command-line interfaces that were preval ent at the
time.
In the early 1970s Kay went to work at the Xerox Palo Alto Resear ch
Center (PARC), where he developed a prototype of his system k nown as
theDynabook . Smalltalk was the computer language Kay developed for
this project. Smalltalk was designed along a biological mode l, in which
individual entities or “objects” communicate with each othe r by passing
messages back and forth. Another goal of Smalltalk was to ena ble children
to invent their own concepts and build programs with them—hen ce, the
name Smalltalk .
Xerox’s management was unable to see the potential in Kay’s i nnova-
tions. However, during a visit to Xerox in 1979, Steve Jobs, th e founder
of Apple Computer, was so impressed by Kay’s work that he made it the
inspiration of the Macintosh computer, which was ﬁrst relea sed in 1984.
Kay left Xerox in 1983 and became an Apple Fellow in 1984. In ad-
dition to working for Apple, Kay spent considerable time tea ching kids
how to use computers at his Open School in West Hollywood. In 199 6
Kay became a Fellow (an “Imagineer”) at the Walt Disney Imagine ering’s
Research and Development Organization, where he continues to explore
SECTION 2.6 •From the Java Library: java.util.Scanner . 91
innovative ways to enhance the educational and entertainme nt value of
computers.
2.6 From the Java Library: java.util.Scanner .
If we wish to write useful interactive programs, we must be abl e to re-
ceive information from the user as well as send information t o him or
her. We saw, in the previous chapter, that output from a progr am can be
sent to the console window by simply using the System.out.print()
andSystem.out.println() statements. In this section we describe
two simple ways that Java can handle keyboard input. Receivi ng input
from the keyboard, together with sending output to the conso le window,
creates one of the standard user interfaces for programs.
Recall, that in Java, any source or destination for I/O is cons idered a
stream of bytes or characters. To perform keyboard input, we will extract
characters from System.in , the input stream connected to the keyboard.
Getting keyboard input from System.in involves two complications that
are not present in dealing with System.out.println() . First, normal
keyboard input data requested of a user consists of a sequenc e of char-
acters or digits which represent a word, phrase, integer, or real number.
Normally, an entire sequence of characters typed by the user will repre-
sent data to be stored in a single variable with the user hitti ng the return
or enter key to signal the end of a piece of requested data. Jav a has a spe-
cial class, BufferedReader , that uses an input stream and has a method
that collects characters until it reads the character or cha racters that corre-
spond to hitting the return or enter key. A second complicati on for reading
FIGURE 2.25 TheScanner class,
with a partial list of its public
methods.input involves the problem of how to handle receiving data th at is not in
the same format as expected. The BufferedReader class handles this
problem by using certain exceptions , a special kind of error message, that
must be handled by the programmer. Chapter 11 is devoted to ex ceptions
and we will avoid their use, as far as possible, until that tim e.
There is an alternate way to handle keyboard input in the Java 2 Plat-
form Standard Edition 5.0 (J2SE 5.0). A Scanner class has been added to
thejava.util package which permits keyboard input without forcing
the programmer to handle exceptions. We introduce the Scanner class
in the next subsection and then describe how a user deﬁned cla ss intro-
duced in Chapter 4 can function in an equivalent fashion to pe rmit simple
keyboard input.
2.6.1 Keyboard Input with the Scanner Class
A partial deﬁnition of Scanner is shown in Figure 2.25. Note that the
Scanner methods listed are but a small subset of the public methods of
this class. The Scanner class is in the java.util package so classes that
use it should import it with the following statement:
☛ ✟
import java . u t i l . Scanner ;
✡ ✠
TheScanner class is designed to be a very ﬂexible way to recognize
chunks of data that ﬁt speciﬁed patterns from any input strea m. To use
92 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
theScanner class for keyboard input, we must create a Scanner in-
stance and associate it with System.in . The class has a constructor for
this purpose, so the statement
☛ ✟
Scanner sc = new Scanner ( System . in ) ;
✡ ✠
declares and instantiates an object that can be used for keybo ard input.
After we create a Scanner object, we can make a call to nextInt() ,
nextDouble() , ornext() to read, respectively, an integer, real number,
or string from the keyboard. The program in Figure 2.26 demon strates
how an integer would be read and used. When the nextInt() method
☛ ✟
import java . u t i l . Scanner ;
public c l a s s TestScanner
{
public s t a t i c void main ( S t r i n g [ ] args )
{ // C r e a t e S c a n n e r o b j e c t
Scanner sc = new Scanner ( System . in ) ;
System . out . p r i n t ( ” Input an i n t e g e r : ” ) ; // P r o m p t
i n t num = sc . n e x t I n t ( ) ; // R e a d a n i n t e g e r
System . out . p r i n t l n (num + ” squared = ” + num∗num ) ;
}// m a i n ( )
}// T e s t S c a n n e r c l a s s
✡ ✠
Figure 2.26: A very brief program with a Scanner object used fo r keyboard
input
is executed, no further statements are executed until an int value is re-
turned by the method. Normally this does not happen until the user has
typed in the digits of an integer and hit the return or enter ke y. Thus ex-
ecuting the main() method of the TestScanner class will result in the
output
☛ ✟
Input an i n t e g e r :
✡ ✠
to the console window and the program will wait for the user to type in
an integer and hit the return or enter key. After this has been done the
output will look something like:
☛ ✟
Input an i n t e g e r : 1 2 3
123 squared = 15129
✡ ✠
Keyboard input of real numbers and strings are handled in a si milar
manner.
SECTION 2.6 •From the Java Library: java.util.Scanner . 93
Keyboard input will allow us to create examples of command li ne
interfaces for interactive programs. For example, the code
☛ ✟
Scanner sc = new Scanner ( System . in ) ;
Riddle r i d d l e = new Riddle (
”What i s black and white and red a l l over ? ” ,
”An embarrassed zebra . ” ) ;
System . out . p r i n t l n ( ”Here i s a r i d d l e : ” ) ;
System . out . p r i n t l n ( r i d d l e . getQuestion ( ) ) ;
System . out . p r i n t ( ”To see the answer , ” ) ; // P r o m p t
System . out . p r i n t l n ( ” type a l e t t e r and enter . ” ) ;
S t r i n g s t r = sc . next ( ) ; // W a i t f o r i n p u t
System . out . p r i n t l n ( r i d d l e . getAnswer ( ) ) ;
✡ ✠
will display a riddle question and prompt the user to type a le tter and to
hit the enter key to see the answer. In the next chapter, we will develop
new methods for the OneRowNim class that will be able to use int values
input from the keyboard for the next move.
We must mention that, since the Scanner class is designed as a ﬂexi-
ble tool for recognizing chunks of data from any input stream , it has some
properties that may be unexpected and not totally compatibl e with sim-
ple keyboard input. A Scanner object has a set of character strings that
separate or delimit the chunks of data that it is looking for. By default,
this set of delimiters consists of any non-empty sequence of white space
characters, that is, the space, tab, return, and newline cha racters. This will
allow a user to input several integers separated by spaces be fore hitting
the enter key. This might be handled by code like:
☛ ✟
System . out . p r i n t ( ” Input two i n t e g e r s and an enter : ” ) ;
i n t num1 = sc . n e x t I n t ( ) ;
i n t num2 = sc . n e x t I n t ( ) ;
✡ ✠
White space as delimiters also means that the next() method cannot re-
turn an empty string nor can it return a string that contains a ny spaces.
For example, consider the code:
☛ ✟
System . out . p r i n t ( ” Input the f i r s t president of the USA: ” ) ;
S t r i n g s t r = sc . next ( ) ;
✡ ✠
If one types ”George Washington” and hits the enter key, the st ringstr
will store only ”George”. In order to get a Scanner object to read strings
that contain spaces, we must use the useDelimiter() method to de-
ﬁne the set of delimiters as just that character string genera ted by hitting
the enter key. For example, for some Windows operating syste ms, the
statement
☛ ✟
sc = sc . useDelimiter ( ”\r\n”) ;
✡ ✠
94 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
will result in the next() method returning the entire string of charac-
ters input from the keyboard up to but not including those gen erated by
hitting the enter key.
You should also be aware that just because we can use a Scanner object
to write Java code that ignores exceptions does not mean that exceptions
will not be generated by keyboard input. If the user enters let ters rather
than digits for the nextInt() method to process, the program will be
terminated with an error message.
It must be stressed that the strategy for handling keyboard in put out-
lined above is a temporary strategy until the topic of except ions is cov-
ered in Chapter 11. Real software applications that use keyb oard input
should carefully handle the possibility that a user will ent er something
unexpected. In Java, this can only be done by handling excepti ons.
2.6.2 Keyboard Input with the KeyboardReader Class
FIGURE 2.27 A UML class diagram
of theKeyboardReader class.If you are using an older version of Java that does not have the Scanner
class, a user-deﬁned class can be used instead. A KeyboardReader
class that uses the BufferedReader class will be developed in Chap-
ter 4. It has methods that read data from the keyboard in a manne r very
similar to those of the Scanner class. A partial list of its public meth-
ods is given in the UML class diagram shown in Figure 2.27. To u se
theKeyboardReader class for keyboard input, copy the source code
KeyboardReader.java from Chapter 4 into the same directory as the
source code of your current Java class (and add it to your curr ent project
if you are using a integrated development environment).
To use a KeyboardReader object, we need to create an instance of
the class with a constructor. Then calling one of the three me thods will
return an int,double , orString when data is input from the keyboard.
Any of the three methods of a KeyboardReader object will attempt to
process the entire string input from the keyboard up to the po int that the
enter key is hit. That is, the character or characters genera ted by hitting
the return or enter key is the delimiter used by KeyboardReader . The
TestKeyboardReader class deﬁnition in Figure 2.28 reads an integer
☛ ✟
public c l a s s TestKeyboardReader
{
public s t a t i c void main ( S t r i n g [ ] args )
{ // C r e a t e K e y b o a r d R e a d e r o b j e c t
KeyboardReader kb = new KeyboardReader ( ) ;
System . out . p r i n t ( ” Input an i n t e g e r : ” ) ; // P r o m p t
i n t num = kb . getKeyboardInteger ( ) ; // R e a d a n i n t e g e r
System . out . p r i n t l n (num + ” squared = ” + num∗num ) ;
}// m a i n ( )
}// T e s t K e y b o a r d R e a d e r c l a s s
✡ ✠
Figure 2.28: A very brief program with a KeyboardReader objec t used for
keyboard input.
from the keyboard and squares it just like the TestScanner class. In the
remainder of the text, any time the Scanner class is used for keyboard
CHAPTER 2 •Chapter Summary 95
input, the same program can be run using the KeyboardReader class
after making the obvious substitutions.
SELF-STUDY EXERCISES
EXERCISE 2.8 Modify the main() method of the TestScanner class
so that it reads a real number from the keyboard rather than an integer.
CHAPTER SUMMARY Technical Terms
access modiﬁer
class-level variable
default value
delimiter
empty string
ﬂow of control
interfacelocal variable
method call and
return
null pointer
null pointer
exception
pointerreference
reference variable
static modiﬁer
user interface
Summary of Important Points
•Dot notation is used to refer to an object’s public elements.
•Designing a class is a matter of deciding what role it will pla y and what
information and actions it will have.
•Writing a Java program is a matter of deﬁning one or more class es. A
class deﬁnition serves as a template for creating instance o f the class.
•Classes typically contain two kinds of elements, variables and meth-
ods. An object’s state is deﬁned by its instance variables.
•Class elements that are declared public can be accessed by other
objects. Elements that are declared private are hidden from other
objects.
•A class’s instance variables are usually declared private so they can-
not be accessed directly by other objects.
•An object’s public instance methods can be called by other obje cts.
Thus, they make up the object’s interface with other objects.
•Object instantiation is the process of creating an object, usi ng the new
operator in conjunction with a constructor method.
•A class deﬁnition consists of a header and a body. The header g ives
the class a name, speciﬁes its accessibility ( public ), and its place in
the Java class hierarchy ( extends Object ). The class body contains
declarations of the class’s variables and deﬁnitions of its methods.
•By default, a newly deﬁned class is consider a subclass of Object .
•Class elements that are declared static , such as the main() method,
are associated with the class (not with its instances).
•A Java application program must contain a main() method, which is
where it begins execution.
•Methods that are used solely for the internal operations of t he class
should be declared private .
•An instance variable declaration reserves memory for the in stance
variable within the object, associates a name and a type with t he lo-
cation, and speciﬁes its accessibility.
96 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
•A method deﬁnition consists of two parts: a header, which nam es the
method and provides other general information about it, and a body,
which contains its executable statements.
•Declaring a variable creates a name for an object but does not c reate
the object itself. An object is created by using the new operator and a
constructor method.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 2.1 The Java code fragment prints out the following:
☛ ✟
The singing king .
✡ ✠
SOLUTION 2.2 For the Riddle class (Fig. 2.12),
•The name of the class: Riddle
•The names of two instance variables: question ,answer
•The names of three methods: Riddle() ,getQuestion() ,getAnswer()
SOLUTION 2.3 ForRiddleUser class (Fig. 2.15),
•The names of two Riddle instances: riddle1 ,riddle2
•All six method calls of the Riddle objects in the program:
☛ ✟
Riddle ( ”What i s black and white and red a l l over ? ” ,
”An embarrassed zebra . ” )
Riddle ( ”What i s black and white and read a l l over ? ” ,
”A newspaper . ” )
r i d d l e 1 . getQuestion ( )
r i d d l e 1 . getAnswer ( )
r i d d l e 2 . getQuestion ( )
r i d d l e 2 . getAnswer ( )
✡ ✠
•Qualiﬁed names: riddle1.getQuestion() andriddle1.getAnswer()
SOLUTION 2.4 Deﬁnition of new instance variable in the Riddle class:
☛ ✟
private S t r i n g hint = ” This r i d d l e i s to easy f o r a hint ” ;
✡ ✠
SOLUTION 2.5 The header for a getHint() method of the Riddle class,
which should be a public method, is:
☛ ✟
public S t r i n g getHint ( ) ;
✡ ✠
SOLUTION 2.6 The header for a setHint() method of the Riddle class is:
☛ ✟
public void setHint ( S t r i n g aHint ) ;
✡ ✠
The result type is void . Although the identiﬁer used for the parameter is arbitrary,
it is a good practice to make it descriptive, by referring in some way to the hint
instance variable.
CHAPTER 2 •Exercises 97
SOLUTION 2.7 The partial deﬁnition of the Student class is given below.
☛ ✟
public c l a s s Student
{ private S t r i n g firstName ;
private S t r i n g lastName ;
private i n t studentID ;
public void setStudent ( S t r i n g fName , S t r i n g lName ,
i n t anID ) ;
public i n t getStudentID ( ) ;
public S t r i n g getStudentName ( ) ;
}
✡ ✠
SOLUTION 2.8 A main method that reads and squares a real number is given
below.
☛ ✟
public s t a t i c void main ( S t r i n g [ ] args )
{ // C r e a t e S c a n n e r o b j e c t
Scanner sc = Scanner . c r e a t e ( System . in ) ;
System . out . p r i n t ( ” Input a r e a l number : ” ) ; // P r o m p t
double realNum= sc . nextDouble ( ) ; // R e a d a d o u b l e
System . out . p r i n t l n (num + ” squared = ” + realNum ∗realNum ) ;
}// m a i n ( )
✡ ✠
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 2.1 Consider the transaction of asking your professor for your grade
in your computer science course. Identify the objects in this tra nsaction and the
types of messages that would be passed among them.
EXERCISE 2.2 Now suppose the professor in the previous exercise decides to
automate the transaction of looking up a student’s grade and has ask ed you to
design a program to perform this task. The program should let a stu dent type in
his or her name and ID number and the program then should display h is or her
grades for the semester, with a ﬁnal average. Suppose there are ﬁ ve quiz grades,
three exams, and two programming exercise grades. Identify t he objects in this
program and the type of messages that would be passed among them. ( Hint : The
grades themselves are just data values, not objects.)
EXERCISE 2.3 In theRiddleUser class (Fig. 2.15), give two examples of object
instantiation and explain what is being done.
EXERCISE 2.4 Explain the difference between a method deﬁnition and a
method call. Give an example of each from the Riddle andRiddleUser ex-
amples discussed in this chapter.
EXERCISE 2.5 In theRiddleUser class (Fig. 2.15), identify three examples of
method calls and explain what is being done.
EXERCISE 2.6 Describe how the slogan “deﬁne, create, manipulate” applies t o
theRiddle example.
EXERCISE 2.7 An identiﬁer is the name for a , , or a .
98 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
EXERCISE 2.8 Which of the following would be valid identiﬁers?
☛ ✟
i n t 74 ElmStreet Big N L$&%# boolean Boolean
number
I n t public P r i v a t e Joe j 1 2 ∗K
big numb
✡ ✠
EXERCISE 2.9 Explain the difference between a class variable and an
instance variable .
EXERCISE 2.10 Identify the syntax error (if any) in each declaration. Rememb er
that some parts of an instance variable declaration are optional.
a.public boolean isEven ;
b.Private boolean isEven ;
c.private boolean isOdd
d.public boolean is Odd ;
e.string S ;
f.public String boolean ;
g.private boolean even = 0;
h.private String s = helloWorld ;
EXERCISE 2.11 Write declarations for each of the following instance variables.
a. Aprivate boolean variable named bool that has an initial value of true .
b. Apublic String variable named str that has an initial value of ”hello”.
c. Aprivate int variable named nEmployees that is not assigned an initial
value.
EXERCISE 2.12 Identify the syntax error (if any) in each method header:
a.public String boolean()
b.private void String ()
c.private void myMethod
d.private myMethod()
e.public static void Main (String argv[])
EXERCISE 2.13 Identify the syntax error (if any) in each assignment stateme nt.
Assume that the following variables have been declared:
☛ ✟
public i n t m;
public boolean b ;
public S t r i n g s ;
✡ ✠
a.m = "86" ;
b.m = 86 ;
c.m = true ;
d.s = 1295 ;e.s = "1295" ;
f.b = "true" ;
g.b = false
EXERCISE 2.14 Given the following deﬁnition of the NumberAdder class, add
statements to its main() method to create two instances of this class, named
adder1 andadder2 . Then add statements to set adder1 ’s numbers to 10 and
CHAPTER 2 •Exercises 99
15, and adder2 ’s numbers to 100 and 200. Then add statements to print their
respective sums.
☛ ✟
public c l a s s NumberAdder
{
private i n t num1 ;
private i n t num2 ;
public void setNums ( i n t n1 , i n t n2 )
{
num1 = n1 ;
num2 = n2 ;
}
public i n t getSum ( )
{
return num1 + num2 ;
}
public s t a t i c void main ( S t r i n g args [ ] )
{
}
}
✡ ✠
EXERCISE 2.15 For the NumberAdder class in the previous exercise, what are
the names of its instance variables and instance methods? Iden tify three expres-
sions that occur in the program and explain what they do. Identify two assignment
statements and explain what they do.
EXERCISE 2.16 Explain the difference between each of the following pairs of
concepts.
a. A method deﬁnition and a method call.
b. Declaring a variable of reference type and creating an inst ance.
c. A variable of reference type and a variable of primitive type .
EXERCISE 2.17 Deﬁne a Java class named NumberCruncher that has a single
int variable as its only instance variable. Then deﬁne methods tha t perform the
following operations on its number: get, double, triple, square, a nd cube. Set
the initial value of the number with a constructor as was done with the instance
variables in the Riddle class.
EXERCISE 2.18 Write a main() method and add it to the NumberCruncher
class deﬁned in the previous problem. Use it to create a NumberCruncher in-
stance, with a certain initial value, and then get it to report its double, triple,
square, and cube.
EXERCISE 2.19 Write a Java class deﬁnition for a Cube object, that has an inte-
ger attribute for the length of its side. The object should be capa ble of reporting
its surface area and volume. The surface area of a cube is six tim es the area of any
side. The volume is calculated by cubing the side.
EXERCISE 2.20 Write a Java class deﬁnition for a CubeUser object that will use
theCube object deﬁned in the previous exercise. This class should creat e three
Cube instances, each with a different side, and then report their r espective surface
areas and volumes.
EXERCISE 2.21 Challenge: Modify your solution to the previous exercise so
that it lets the user input the side of the cube. Follow the exampl e shown in this
chapter’s “From the Java Library” section.
100 CHAPTER 2 •Objects: Using, Creating, and Deﬁning
EXERCISE 2.22 Challenge: Deﬁne a Java class that represents an address book
entry,Entry , which consists of a name, address, and phone number, all repre-
sented as String s. For the class’s interface, deﬁne methods to set and get the
values of each of its instance variables. Thus, for the name variable, it should have
asetName() and agetName() method.
UML EXERCISES
EXERCISE 2.23 Draw a UML class diagram to represent the following class hi-
erarchy: There are two types of languages, natural languages and programming
languages. The natural languages include Chinese, English , French, and German.
The programming languages include Java, Smalltalk and C++, wh ich are object-
oriented languages, FORTRAN, COBOL, Pascal, and C, which are imperative lan-
guages, Lisp and ML, which are functional languages, and Prolog , which is a logic
language.
EXERCISE 2.24 Draw a UML class diagram to represent different kinds of au-
tomobiles, including trucks, sedans, wagons, SUVs, and the name s and manufac-
turers of some popular models in each category.
EXERCISE 2.25 Draw a UML object diagram of a triangle with attributes for
three sides, containing the values 3, 4, and 5.
EXERCISE 2.26 Suppose you are writing a Java program to implement an elec-
tronic address book. Your design is to have two classes, one to repr esent the user
interface and one to represent the address book. Draw a UML diagr am to depict
this relationship. See Figure 2.14.
EXERCISE 2.27 Draw an UML object diagram to depict the relationship be-
tween an applet, which serves as a user interface, and three Triangle s, named
t1,t2, andt3.
OBJECTIVES
After studying this chapter, you will
•Understand the role that methods play in an object-oriented p rogram.
•Know how to use parameters and arguments to pass data to an obje ct.
•Understand how constructor methods are used to instantiate objects.
•Know the difference between passing a value and passing a ref erence to an object.
•Be able to design your own methods.
•Know how to use the if-else andwhile control structures.
OUTLINE
3.1 Introduction
3.2 Passing Information to an Object
3.3 Constructor Methods
3.4 Retrieving Information from an Object
3.5 Passing a Value and Passing a Reference
3.6 Flow of Control: Control Structures
3.7 Testing an Improved OneRowNim
Special Topic: Intelligent Agents
3.8 From the Java Library: java.lang.Object
3.9 Object-Oriented Design: Inheritance and Polymorphism
3.10 Drawing Lines and Deﬁning Graphical Methods (Optional )
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 3
Methods: Communicating
with Objects
101
102 CHAPTER 3 •Methods: Communicating with Objects
3.1 Introduction
In this chapter, we take a look at Java methods and parameters. Methods
and parameters are the primary mechanisms for passing infor mation into
and out of an object. We will once again focus on the OneRowNim simula-
tion that we designed in the previous chapter. That version w as sufﬁcient
to introduce us to Java objects and classes, but it was limited in its ability
to communicate with other objects.
In this chapter, we want to expand OneRowNim to make our simulation
more realistic. We begin by learning how to pass information to an ob-
ject. That will enable us to specify the number of sticks to rem ove using
a single method. We then consider special methods called con structors,
which are used to initialize an object’s state when it is creat ed. We also
learn how to retrieve information from an object. That will en able us to
request a OneRowNim object for several different bits of information. Then
we consider the if-else andwhile control structures which allow us to
deﬁne more useful methods and write more realistic test prog rams.
3.2 Passing Information to an Object
One convention of object-oriented programming is to provide public
methods to setand getthe values of some of its private instance vari-
ables. Methods that set or modify an object’s instance variab les are called
mutator methods . Methods that get or retrieve the value of an instance
variable are called accessor methods .
JAVA EFFECTIVE DESIGN Accessor and Mutator Methods. An
accessor method is a public method used to getthe value of an object’s
instance variable. Such methods are often named getVarName() where
VarName is the name of the variable that’s being accessed. A mutator
method is a public method used to modify the value of one or more
instance variables. The special type of mutator method that setsor
assigns a variable a speciﬁed value is often called setVarName() .
It is up to the designer of the class to determine which private vari-
ables require accessor and mutator methods. If you were desig ning a
BankAccount class, you might want a public getAccountNumber()
method, so that clients could retrieve information about th eir bank ac-
counts, but you would probably not want a public getAccountPassword()
method or a public setAccountBalance() method.
In the remainder of this section, we will be concerned with mut a-
tor methods. We deﬁned three mutator methods named takeOne() ,
takeTwo() , andtakeThree as part of the OneRowNim class in the pre-
vious chapter. All three of these method change the values of the instance
SECTION 3.2 •Passing Information to an Object 103
variables nSticks andplayer . All three methods have very similar
bodies. The deﬁnition of the takeOne() is:
☛ ✟
public void takeOne ( )
{ n S t i c k s = n S t i c k s −1 ;
player = 3 −player ;
}
✡ ✠
The only difference in the bodies of the other two methods is t hat they
subtract 2 and 3 from nSticks instead of 1. Instead of having three, vir-
tually identical methods, It would be a more efﬁcient design t o deﬁne a
single method where the number to be subtracted from nSticks would
be supplied as an argument when the method is called. In order t o be able
to handle such an argument, we must design a new method that us es a
parameter to handle the argument.
Aformal parameter , or more simply, parameter , is a variable used to
pass information into a method when the method is invoked. Th etype and Formal parameter
variable name of the formal parameter must appear in the formal parameter
listthat follows the method’s name in the method header. The form al
parameter is used to hold a value that it is passed while the me thod is
executing.
JAVA LANGUAGE RULE Formal Parameter. Aformal parameter
is a variable that serves as a storage location for informati on that is
passed to a method. To specify a formal parameter, you must pr ovide
a type identiﬁer followed by variable identiﬁer, and you mus t place
this declaration inside the parentheses that follow the met hod’s name.
Consider the following deﬁnition for a takeSticks() method:
☛ ✟
public void t a k e S t i c k s ( i n t num)
{ n S t i c k s = n S t i c k s −num;
player = 3 −player ;
}
✡ ✠
Notice that executing the body of takeSticks() when the parameter
num stores the value 1 accomplishes precisely the same task as ex ecuting
takeOne() . If, instead, a value of 2 or 3 is stored in num, then calling the
method acts like takeTwo() ortakeThree() respectively. Thus, using
parameters enables us to design methods that are more genera l in what
they do, which is an important principle of good program desi gn.
Another example of a mutator method is one in which deﬁne a set
method to allow the starting number of sticks to be set for an instanc e of
OneRowNim . For this, we could deﬁne:
☛ ✟
public void s e t S t i c k s ( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
}// s e t S t i c k s ( )
✡ ✠
As we will see in Section 3.3, we can also deﬁne a constructor m ethod that
can be used, when the game is created, to set the initial value ofnSticks .
104 CHAPTER 3 •Methods: Communicating with Objects
It is often desirable to have more than one method that sets the values of
an objects’ instance variables.
If a method uses more than one parameter, use a comma to separat e the
individual parameter declarations in the method header. Fo r example, if
we wanted a method for OneRowNim that speciﬁed both the number of
sticks for the start of a game and which player takes a turn ﬁrs t, it could
be deﬁned:
☛ ✟
public void setGame ( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ;
player = s t a r t e r ;
}// s e t G a m e ( )
✡ ✠
The Scope of Parameters, Variables, and Methods
The bodies of the mutator methods in the previous section mak e use of
both instance variables and parameters. It is important to no te that there
is a difference in where these two types of variables can be us ed. The
scope of a variable or method refers to where it can be used in a progr am. Scope
A parameter’s scope is limited to the body of the method in whi ch it is
declared. Variables that are declared in the body of a method have scope
which extends from the point where they are declared to the en d of the
block of code in which they are declared. Parameters are loca l variables
which are declared in the parameter list of a method’s header and which
have initial values speciﬁed by the arguments in a method cal l. The scope
of a parameter is the same as the scope of a variable declared a t the very
beginning of the body of a method. Once the ﬂow of execution lea ves a Local scope
method, its parameters and other local variables cease to ex ist. The scope
of local variables is referred to as local scope .
JAVA LANGUAGE RULE Scope. Local variables, that is,
parameters and variables declared in the body of a method, ha velocal
scope which extends from the point at which they are deﬁned to the
end of the block of code in which they are deﬁned. In particular , the
scope of a parameter is the entire body of the method in which i t is
declared.
By contrast, instance variables, class variables, and all m ethods have
scope that extends throughout the entire class, that is, class scope . They
can be used in the body of any method and in the expressions tha t as-
sign initial values to class level variables. There are two r estrictions to
remember. First, instance variables and instance methods c annot be used
in the body of a class method, one modiﬁed with static , unless an in-
stance of the class is created there and then the dot notation of qualiﬁed
names must be used to refer to the variable or method. This is b ecause Class scope
class methods are called without reference to a particular i nstance of the
class. The main() method of the OneRowNim class that we deﬁned in the
previous chapter is an example of such a class method. In that c ase, to
SECTION 3.2 •Passing Information to an Object 105
test the instance methods of OneRowNim we ﬁrst created an instance of
OneRowNim and used it to call its instance methods:
☛ ✟
OneRowNim game = new OneRowNim ( ) ; // C r e a t e i n s t a n c e
game . report ( ) ; // C a l l a n i n s t a n c e m e t h o d
✡ ✠
The second restriction involved in class scope is that one cl ass level vari-
able can be used in the expression that initializes a second c lass level vari-
able only if the ﬁrst is declared before the second. There is n o similar
restriction on methods.
JAVA LANGUAGE RULE Scope. Class level variables, that is,
instance variables and class variables have class scope , which extends
throughout the class. Methods also have class scope.
Except for the restrictions noted above, methods and class l evel vari-
ables can be referred to within the same class by their simple names,
with just the method (or variable) name itself, rather than by their quali- Simple vs. qualiﬁed names
ﬁed names, with the dot operator. Thus, in OneRowNim , we can refer to
nSticks andreport() in the bodies of other instance methods. In a
class method, such as main() , we would have to create an instance of
OneRowNim with a name like game and refer to game.report() .
JAVA LANGUAGE RULE Qualiﬁed Names. Within the same class,
references to class methods or class variables can be made in terms of
simple names. Within the bodies of instance methods, refere nces to
instance variables and references to other instance method s can also be
made in terms of simple names. However, within the bodies of cl ass
methods, qualiﬁed names, or dot notation, must be used to ref er to
instance methods or instance variables just like how they are referred
to in other classes.
JAVA DEBUGGING TIP Scope Error. It would be a syntax error to
refer to a method’s parameters or other local variables from outside
the method.
3.2.1 Arguments and Parameters
The new class deﬁnition for OneRowNim is given in Figure 3.1. Note that
now that we have a single method, takeSticks() , that can be used
to take away a variable number of sticks, we have removed the t hree
methods we wrote in the previous chapter, takeOne() ,takeTwo() , and
takeThree() , fromOneRowNim . Using a single method, with a parame-
ter, is clearly a better design. To see this, just imagine what we would have
to do if we didn’t use a parameter and we wanted to be able to tak e away
four sticks, or ﬁve, or more. If we didn’t have parameters, we’ d have to
write a separate method for each case, which is clearly a bad i dea. Using
106 CHAPTER 3 •Methods: Communicating with Objects
☛ ✟
public c l a s s OneRowNim
{private i n t n S t i c k s = 7 ; // S t a r t w i t h 7 s t i c k s
private i n t player = 1 ; // P l a y e r 1 p l a y s f i r s t
public void t a k e S t i c k s ( i n t num)
{n S t i c k s = n S t i c k s −num;
player = 3 −player ;
} // t a k e S t i c k s ( )
public void report ( )
{System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ” + n S t i c k s ) ;
System . out . p r i n t l n ( ”Next turn by player ” + player ) ;
} // r e p o r t ( )
}// OneRowNim1 c l a s s
✡ ✠
Figure 3.1: The OneRowNim class deﬁnition with takeSticks() method.
parameters in this way leads to a more general useful method a nd thus is
an example of the generality principle.
Now let’s consider how we would create a OneRowNim instance and
use the new method in the main() method or in a different class. If we
want to have an instance of OneRowNim object to remove 3 sticks on the
ﬁrst move by using the takeSticks() method, we need to pass the int
value 3 to the method. In order to effect this action, we would u se the
following statements:
☛ ✟
OneRowNim game = new OneRowNim ( ) ;
game . t a k e S t i c k s ( 3 ) ;
✡ ✠
Because the deﬁnition of takeSticks() includes a single int parame-
ter, we must supply a single int value (such as 3), when we invoke it.
When the method is invoked, its formal parameter ( num) will be set to the
value we supply (3). The value we supply does not have to be a li teral
int value. We can supply any expression or variable that evaluat es to an
int value. For example:
☛ ✟
i n t val = 7 −5 ;
game . t a k e S t i c k s ( val ) ;
✡ ✠
In this case, the value being passed to takeSticks() is 2, the value that
val has at the time the method call is made.
It would be an error to try to pass a value that was not a int to
takeSticks() . For example, each of the following invocations of
takeSticks() results in a syntax error:
☛ ✟
game . t a k e S t i c k s ( ) ; // n o a r g u m e n t i s s u p p l i e d
game . t a k e S t i c k s ( ”3” ) ; // ” 3 ” i s a S t r i n g , n o t a n i n t
game . t a k e S t i c k s ( i n t ) ; // i n t n o t i s a n i n t v a l u e
✡ ✠
SECTION 3.2 •Passing Information to an Object 107
As you recall from Chapter 0, the value that is passed to a meth od when
it is invoked is called an argument. Even though the terms arg ument and Parameter vs. argument
parameter are sometimes used interchangeably, it will be us eful to ob-
serve a distinction. We will use the term parameter to refer to the formal
parameter—the variable used to pass data to a method—that occu rs in the
method deﬁnition. We use the term argument to refer to the actual value
that is supplied when the method is invoked.
JAVA DEBUGGING TIP Type Error. It would be a syntax error to
use an argument whose type doesn’t match the type of its
corresponding parameter.
The distinction between parameter and argument is related t o the differ- Deﬁning vs. calling a method
ence between deﬁning a method and invoking a method. Deﬁning a method
is a matter of writing a method deﬁnition, such as
☛ ✟
public void p r i n t S t r ( S t r i n g s )
{ System . out . p r i n t l n ( s ) ;
}
✡ ✠
This deﬁnition deﬁnes a method that takes a single String parameter, s,
and simply prints the value of its parameter. On the other han d, invoking
a method is a matter of writing a method call statement, such a s Invoking a method
☛ ✟
p r i n t S t r ( ”HelloWorld” ) ;
✡ ✠
This statement calls the printStr() method and passes it the string
“HelloWorld”. This notation assumes that the call to the inst ance method
printStr() is made within the body of another instance method of the
same class.
3.2.2 Passing an int value to a OneRowNim method.
To get a clearer picture of the interaction that takes place w hen we invoke
takeSticks() and pass it an int value, let’s write a main() method to
test our new version of OneRowNim .
Our ﬁrst version of main() is shown in Figure 3.2. We will use it to
trace how the parameter of takeSticks() interacts with the instance
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] )
{OneRowNim game ; // D e c l a r e a OneRowNim o b j e c t
game = new OneRowNim ( ) ; // I n s t a n t i a t e t h e r e f e r e n c e s
game . t a k e S t i c k s ( 3 ) ; // r e m o v e 3 s t i c k s
}// m a i n ( )
✡ ✠
Figure 3.2: A main() method to test the takeSticks() method.
variables nSticks andplayer . The statements in the main() program
simply create an instance of OneRowNim that is referenced by game and
invoke the setSticks() method with an argument of 3.
108 CHAPTER 3 •Methods: Communicating with Objects
Figure 3.3: Tracing the state
ofgame (a) Just before calling
takeSticks(3) . (b) Just
before executing the body of
takeSticks(3) . (c) Just
after executing the body of
takeSticks(3) . (d) After ﬂow
of control leaves takeSticks() .
To get a clearer understanding of how a parameter works, it wi ll be
instructive to trace through the code in main() . Figure 3.3 displays
how the states of the instance variables of game and the parameter of
takeSticks() interact.
Executing the ﬁrst two statements of main() creates the instance game
ofOneRowNim . Figure 3.3(a) shows the initial state of game . When the
takeSticks(3) method call is made, a parameter (which is a local vari-
able) named num is created and the value 3 is stored in it. The state of
the instance variables and the parameter are shown in (b). Th en the body
oftakeSticks() is executed. The new state of game is shown in (c).
After the ﬂow of control leaves the body of takeSticks() and returns
tomain() , the memory location which stored the value of the parameter
num is released for other uses. The state of game at this point is shown in
(d). Notice that the value of nSticks has been reduced to 4.
3.2.3 Passing keyboard input to takeSticks()
To complete this section, let’s modify our main() method in Figure 3.2
so that it prompts the user to input an integer from the keyboa rd and
then uses a Scanner object, introduced in the previous chapte r, to read
the integer. That integer will then be used as the argument in a call to
takeSticks() . These modiﬁcations have been incorporated into the
revised version of the main() method shown in Figure 3.4. If we now
run this program the following output will be generated in th e console
SECTION 3.2 •Passing Information to an Object 109
☛ ✟
import java . u t i l . Scanner ;
public s t a t i c void main ( S t r i n g argv [ ] )
{Scanner sc ; // D e c l a r e a S c a n n e r v a r i a b l e
sc = Scanner . c r e a t e ( System . in ) ; // I n s t a n t i a t e i t
OneRowNim game ; // D e c l a r e a OneRowNim v a r i a b l e
game = new OneRowNim ( ) ; // I n s t a n t i a t e i t
game . report ( ) ; // R e p o r t s t a t e o f g a m e
System . out . p r i n t l n ( ” Input 1 , 2 , or 3 and h i t enter : ” ) ;
i n t num = sc . n e x t I n t ( ) ; // R e a d a n i n t f r o m k e y b o a r d
game . t a k e S t i c k s (num ) ; // U s e t h e v a l u e r e a d
game . report ( ) ; // R e p o r t s t a t e o f g a m e
}// m a i n ( )
✡ ✠
Figure 3.4: A main() method with keyboard input for OneRowNim .
window before waiting for keyboard input:
☛ ✟
Number of s t i c k s l e f t : 7
Next turn by player 1
Input 1 , 2 , or 3 and h i t enter :
✡ ✠
If the user then inputs a 2 from the keyboard, that input will be read
and the takeSticks() method will remove 2 sticks. The output in the
console window will now look like:
☛ ✟
Number of s t i c k s l e f t : 7
Next turn by player 1
Input 1 , 2 , or 3 and h i t enter : 2
Number of s t i c k s l e f t : 5
Next turn by player 2
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 3.1 Explain the difference between a method declaration and
amethod invocation .
EXERCISE 3.2 Explain the difference between a formal parameter and an
argument .
EXERCISE 3.3 Modify the OneRowNim class of Figure 3.4 by adding
two instance variables of type String to store names of the two play-
ers. Choose names for the instance variables that would be ap propri-
ate for storing names for player one and player two. Write a me thod
named setNames() with two string parameters which assigns the ﬁrst
parameter to the instance variable that you created for the n ame of player
one. The second parameter should be assigned to the other new instance
variable.
EXERCISE 3.4 Write a statement that calls the setName() method of
the previous exercise and sets the name of player one of game to “Xena”
and sets the name of player two to “Yogi”.
110 CHAPTER 3 •Methods: Communicating with Objects
3.3 Constructor Methods
In the previous section, we looked at several examples of muta tor meth-
ods that change the values of private instance variables of a n object. It
is possible to deﬁne mutator methods to set the initial value s of instance
variables after an object is created, but initial values can a lso be set by
constructors.
As you recall from Chapter 0, a constructor method is used to create
an instance (or object) of a class and to assign initial values to instance Constructor names
variables. A constructor declaration looks just like a metho d deﬁnition
except it must have the same name as the class, and it cannot de clare a
result type. Unlike the class level variables and methods of a class, con-
structors are not considered members of the class. Therefor e, they are not
inherited by a class’s subclasses. Access to constructors i s governed by the
access modiﬁers public andprivate . Here is a simple constructor for
ourOneRowNim class:
☛ ✟
public OneRowNim ( )
{ n S t i c k s = 7 ;
player = 1 ;
}
✡ ✠
This constructor merely sets the initial values of the insta nce variables, Constructing an object
nSticks andplayer . In our current version of OneRowNim these vari-
ables are given initial values by using initializer stateme nts when they are
ﬁrst declared:
☛ ✟
private i n t n S t i c k s = 7 ;
private i n t player = 1 ;
✡ ✠
So we now have two ways to initialize a class’s instance varia bles. In the Initializing variables
OneRowNim class it doesn’t really matter which way we do it. However,
the constructor provides more ﬂexibility because it allows t he state of the
object to be initialized at runtime. Of course, it would be som ewhat redun-
dant (though permissible) to initialize the same variable t wice, once when
it is declared and again in the constructor, so we should choo se one or
the other way to do this. For now, let’s stick with initializi ng the instance
variables when they are declared.
JAVA EFFECTIVE DESIGN Constructors. Constructors provide a
ﬂexible way to initialize an object’s instance variables when the object
is created.
A constructor cannot return a value and, therefore, its decl aration cannot Constructors can’t return a value
include a return type. Because they cannot return values, co nstructors
cannot be invoked by a regular method invocation. Instead, co nstructors
are invoked as part of an instance creation expression when instance objects
SECTION 3.3 •Constructor Methods 111
are created. An instance creation expression involves the k eyword new
followed by the constructor invocation:
☛ ✟
OneRowNim game // D e c l a r e
=new OneRowNim ( ) ; // a n d i n s t a n t i a t e g a m e 1
OneRowNim game2 // D e c l a r e
=new OneRowNim ( ) ; // a n d i n s t a n t i a t e g a m e 2
✡ ✠
Note here that we have combined variable declaration and ins tantiation
into a single statement, whereas in some previous examples w e used sep-
arate declaration and instantiation statements. Either wa y is acceptable.
JAVA LANGUAGE RULE Constructors. Constructors cannot
return a value. Therefore, no return type should be declared when the
constructor is deﬁned.
JAVA DEBUGGING TIP When to Use Return. All method
deﬁnitions except constructors must declare a return type.
Constructors should be used to perform the necessary initia lization op-
erations during object creation. In the case of a OneRowNim object, what
initializations could be performed? One initialization th at would seem State initialization
appropriate is to initialize the initial number of sticks to a number speci-
ﬁed. In order to do this, we would need a constructor with a sing leint
parameter:
☛ ✟
public OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
}
✡ ✠
Now that we have this constructor we can use it when we create i nstances
ofOneRowNim :
☛ ✟
OneRowNim game1 = new OneRowNim ( 2 1 ) ;
OneRowNim game2 = new OneRowNim ( 1 3 ) ;
✡ ✠
The effect of these statements is the same as if we had used the
setSticks() method that was discussed brieﬂy on page 103. The dif-
ference is that we can now set the number of sticks when we crea te the
object.
Should we keep the preceding constructor, or keep the setSticks()
method or keep both in our class deﬁnition? The constructor c an only
be invoked as part of a new statement when the object is created but the
setSticks() method could be called anytime we want. In many cases,
having redundant methods for doing the same task in differen t ways
would be an asset, because it allows for more ﬂexibility in how the class
could be used. However, for a game like One Row Nim, a major conce rn
is that the two instance variables get changed only in a manne r consistent
112 CHAPTER 3 •Methods: Communicating with Objects
with the rules for One Row Nim. The best way to guarantee this i s to have
takeSticks() as the only method that changes the instance variables
nSticks andplayer . The only time that it should be possible to set the
number of sticks for a game is when a constructor is used to cre ate a new
instance of OneRowNim .
SELF-STUDY EXERCISES
EXERCISE 3.5 What’s wrong with the following constructor deﬁni-
tion?
☛ ✟
public void OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
}
✡ ✠
EXERCISE 3.6 Change the OneRowNim(int sticks) constructor so
that it sets the number of sticks and also have it also set play er two as the
player who takes the ﬁrst turn.
3.3.1 Default Constructors
As we noted in Chapter 2, Java automatically provides a default constructor
when a class does not contain a constructor.
JAVA LANGUAGE RULE Default Constructor. If a class contains
no constructor declarations, Java will automatically supp ly a default
constructor. The default constructor takes no parameters. If the class is
public , the default constructor will also be public and, hence,
accessible to other objects.
The default constructor’s role is simply to create an instan ce (an object) of
that class. It takes no parameters. In terms of what it does, the default
constructor for OneRowNim would be equivalent to a public constructor
method with an empty body:
☛ ✟
public OneRowNim ( ) { }
✡ ✠
This explains why the following statement was valid when a cl ass deﬁni-
tion of OneRowNim contained no explicit deﬁnition of a constructor:
☛ ✟
OneRowNim game = new OneRowNim ( ) ;
✡ ✠
3.3.2 Constructor Overloading and Method Signatures
It is often quite useful to have more than one constructor for a given class. Flexible design
SECTION 3.3 •Constructor Methods 113
For example, consider the following two OneRowNim constructors:
☛ ✟
public OneRowNim ( ) {} // C o n s t r u c t o r # 1
public OneRowNim( i n t s t i c k s ) // C o n s t r u c t o r # 2
{ n S t i c k s = s t i c k s ;
}
✡ ✠
The ﬁrst is an explicit representation of the default constr uctor. The sec-
ond is the constructor we deﬁned earlier to initialize the nu mber of sticks
in aOneRowNim object. Having multiple constructors lends ﬂexibility to
the design of a class. In this case, the ﬁrst constructor merel y accepts
OneRowNim ’s default initial state. The second enables the user to init ialize
the number of sticks to something other than the default valu e.
In Java, as in some other programming languages, when two diff erent
methods have the same name, it is known as method overloading . In Method overloading
this case, OneRowNim is used as the name for two distinct constructor
methods. What distinguishes one constructor from another is itssigna-
ture, which consists of its name together with the number and type s of
formal parameters it takes. Thus, our OneRowNim constructors have the
following distinct signatures:
☛ ✟
OneRowNim ( )
OneRowNim( i n t)
✡ ✠
Both have the same name, but the ﬁrst takes no parameters, whe reas the
second takes a single int parameter.
The same point applies to methods in general. Two methods can have Methods are known by their
signatures the same name as long as they have distinct signatures. A method signa-
ture consists of its name, and the number, types, and order of its f ormal
parameters. A class may not contain two methods with the same signa-
ture, but it may contain several methods with the same name, p rovided
each has a distinct signature.
JAVA LANGUAGE RULE Method Signature. Amethod signature
consists of the method’s name, plus the number, types, and or der of its
formal parameters. A class may not contain two methods with t he
same signature.
There is no limit to the amount of overloading that can be done in design-
ing constructors and methods. The only restriction is that e ach method
have a distinct signature. For example, suppose in addition to the two
constructors we have already deﬁned, we want a constructor t hat would
let us set both the number of sticks and the player who starts ﬁ rst. The
following constructor will do what we want:
☛ ✟
public OneRowNim( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ; // S e t t h e n u m b e r o f s t i c k s
player = s t a r t e r ; // S e t who s t a r t s
}
✡ ✠
114 CHAPTER 3 •Methods: Communicating with Objects
When calling this constructor, we would have to take care to pa ss the num-
ber of sticks as the value of the ﬁrst argument and either 1 or 2 as the value
of the second argument:
☛ ✟
OneRowNim game3 = new OneRowNim( 1 4 , 2 ) ;
OneRowNim game4 = new OneRowNim( 3 1 , 1 ) ;
✡ ✠
If we mistakenly reversed 14 and 2 in the ﬁrst of these statemen ts, we
would end up with a OneRowNim game that starts with 2 sticks and has
player 14 as the player with the ﬁrst move.
We have now deﬁned three constructor methods for the OneRowNim
class. Each constructor has the name OneRowNim , but each has a distinct
signature:
☛ ✟
OneRowNim ( )
OneRowNim( i n t)
OneRowNim( int,i n t)
✡ ✠
3.3.3 Constructor Invocation
A constructor method is invoked only as part of a new expression when
an instance object is ﬁrst created. Each of these is a valid inv ocation of a A constructor is invoked once to cre-
ate an object OneRowNim constructor:
☛ ✟
// D e f a u l t c o n s t r u c t o r
OneRowNim game1 = new OneRowNim ( ) ;
// S e t s n u m b e r o f s t i c k s
OneRowNim game2 = new OneRowNim ( 2 1 ) ;
// S e t s b o t h i n s t a n c e v a r i a b l e s
OneRowNim game3 = new OneRowNim( 1 9 , 2 ) ;
✡ ✠
The following constructor invocations are invalid because there are no
matching constructor deﬁnitions:
☛ ✟
// No m a t c h i n g c o n s t r u c t o r s
OneRowNim game4 = new OneRowNim( ”21” ) ;
OneRowNim game5 = new OneRowNim( 1 2 , 2 , 5 ) ;
✡ ✠
In the ﬁrst case, there is no constructor method that takes a String pa-
rameter, so there’s no matching constructor. In the second ca se, there is no
constructor that takes three int arguments. In both cases, the Java com-
piler would complain that there is no constructor method tha t matches the
invocation.
JAVA DEBUGGING TIP Method Call. The signature of the method
call—its name and the number, types, and order of its
arguments—must exactly match the signature of the method
deﬁnition.
SECTION 3.4 •Retrieving Information from an Object 115
3.4 Retrieving Information from an Object
The modiﬁcations we’ve made to the OneRowNim class allow us to set the
instance variables of a OneRowNim object with a constructor, but there is
no way for us to retrieve their values other than to use the report()
method to write a message to the console. We will want to be abl e to
ask aOneRowNim object to provide us with the number of sticks remain-
ing and who plays next when we develop a graphical user interf ace for
OneRowNim in the next chapter. We declared nSticks andplayer as
private variables, so we cannot access them directly. Therefore, we will
need accessor methods to getthe values of each of the instance variables.
Consider the following method deﬁnitions:
☛ ✟
public i n t g e t S t i c k s ( )
{ return n S t i c k s ;
}
public i n t getPlayer ( )
{ return player ;
}
✡ ✠
Recall that a method’s ResultType is speciﬁed just in front of the Method-
Name . We want the two methods to return int values that represent
OneRowNim ’s instance variables. Therefore, their result types are bo th
declared int.
Before we discuss how the value that is returned by a method is used
when the method is called, let’s consider one more method deﬁ nition.
Many methods that return a value do a computation rather than simply
returning the value of an instance variable. For example, su ppose we wish
to deﬁne a method for the OneRowNim class that will notify the user of an
instance of the class whether the game is over. Thus we want a m ethod
that, when called, returns a true orfalse depending on whether or
not all the sticks have been taken. gameOver() is a descriptive name
of such a method and the method should have a boolean result type.
This method should return true when the instance variable nSticks no
longer contains a positive int value. Thus we can deﬁne:
☛ ✟
public boolean gameOver ( )
{ return ( n S t i c k s <= 0 ) ;
}
✡ ✠
The expression (nSticks <= 0) evaluates to a false value if nSticks
stores a positive value and it evaluates to true otherwise. Thus the value
returned is precisely what is required.
3.4.1 Invoking a Method That Returns a Value
When we invoke a method that returns a value, the invocation ex pression Retrieving information
116 CHAPTER 3 •Methods: Communicating with Objects
takes on, or is replaced by, the value that is returned. For ex ample, if we
execute the statements
☛ ✟
OneRowNim game1 = new OneRowNim ( 1 1 ) ;
i n t s t i c k s L e f t = game1 . g e t S t i c k s ( ) ;
✡ ✠
the expression game1.getSticks() will take on the value 11 after the
getSticks() method is ﬁnished executing. At that point, the second
statement above can be treated as if expression game1.getSticks() is
replaced with the value 11, which is assigned to sticksLeft . In effect,
the second statement is equivalent to the following stateme nt:
☛ ✟
i n t s t i c k s L e f t = 1 1 ;
✡ ✠
JAVA LANGUAGE RULE Evaluating Method Calls. A nonvoid
method call is an expression that has a value of a particular t ype. After
the method is executed, the method call expression becomes t he value
returned.
We can use a value returned by a method call the same way we use a
literal value of the same type. It can be assigned to variables , be part of
a numerical expression, or be an argument of another method. All of the
following statements involve valid calls of methods that re turn values:
☛ ✟
i n t f e w e r S t i c k s = game1 . g e t S t i c k s ( ) −1 ;
boolean done = game1 . gameOver ( ) ;
System . out . p r i n t l n ( game1 . getPlayer ( ) ) ;
game1 . g e t S t i c k s ( ) ;
✡ ✠
In each statement, the method call can be replaced with the val ue it re-
turns. Notice that the last statement is valid but does nothi ng useful. In
Java and some other languages like C and C++, methods that ret urn a
value can simply be called without making use of the value ret urned. This
may be useful to do if the method changes the state of instance variables
or sends a message to another object or an output device. The me thod
getSticks() does nothing but return the value of nSticks , so simply
calling the method accomplishes nothing.
3.4.2 An Expanded OneRowNim Class
Let’s add the new methods that return values to our OneRowNim class. We
might note that the report() method from the previous chapter displays
the values of nSticks andplayer in the console window which now
could be done by using the methods getSticks() andgetPlayer()
withSystem.out.println() . However, calling report() is an easy
way to display the values of both instance variables but it ca nnot provide
access to either variable as an int value. So let’s keep all three methods Redundancy and ﬂexibility
in our class deﬁnition. The inconvenience of a small amount o f redun-
SECTION 3.4 •Retrieving Information from an Object 117
dancy is outweighed by the added ﬂexibility of being able to ca ll all three
methods.
JAVA EFFECTIVE DESIGN Using Redundancy. Incorporating some
redundancy into a class, such as providing more than one way t o
access the value of an instance variable, makes the class mor e widely
usable.
Figure 3.5 provides a UML class diagram of the expanded OneRowNim
class.
OneRowNim
−nSticks: int
−player: int
+OneRowNim()
+OneRowNim(in sticks:int)
+OneRowNim(in sticks:int,in starter:int)
+takeSticks(in num:int)
+getSticks():int
+getPlayer():int
+gameOver():boolean
+report()
Figure 3.5: A UML class diagram for the expanded OneRowNim .
Let’s also consider a new main() method to test the new methods of
the class. A very short list of statements that call each of th e three new
methods returning values is given in the main() method in Figure 3.6
☛ ✟
public s t a t i c void main ( S t r i n g [ ] args )
{OneRowNim game = new OneRowNim( 1 3 , 2 ) ;
game . t a k e S t i c k s ( 2 ) ;
System . out . p r i n t ( ”The game i s over i s : ” ) ;
System . out . p r i n t l n ( game . gameOver ( ) ) ;
System . out . p r i n t ( ”The next turn i s by player : ” ) ;
System . out . p r i n t l n ( game . getPlayer ( ) ) ;
System . out . p r i n t ( ” S t i c k s remaining : ” ) ;
System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;
}// m a i n ( )
✡ ✠
Figure 3.6: A main() method that tests the new methods for OneRowNim
The output to the console when this program is run will be:
☛ ✟
The game i s over i s : f a l s e
The next turn i s by player : 1
S t i c k s remaining : 11
✡ ✠
118 CHAPTER 3 •Methods: Communicating with Objects
Note that the constructor sets player to 2, so player stores the value 1
after one turn.
SELF-STUDY EXERCISES
EXERCISE 3.7 What would these segments of Java code display on the
screen?
☛ ✟
OneRowNim myGame = new OneRowNim( 1 0 , 2 ) ;
System . out . p r i n t l n (myGame. getPlayer ( ) ) ;
System . out . p r i n t l n (2 ∗myGame. g e t S t i c k s ( ) ) ;
System . out . p r i n t l n (myGame. gameOver ( ) ) ;
✡ ✠
EXERCISE 3.8 Suppose that an int instance variable named nMoves
is added to the OneRowNim class that counts the number of moves taken
in a One Row Nim game. Write a Java method for the OneRowNim class
togetthe value stored in nMoves .
EXERCISE 3.9 Write a method for the OneRowNim class called
playerOneGoesNext() that returns a boolean value. The value re-
turned should be true if and only if player one has the next tur n.
3.5 Passing a Value and Passing a Reference
The effect of passing arguments to a method differs dependin g on whether
you are passing a value of primitive type (such as 5 or true ) or a value of
reference type (such as “Hello” or game1 ). When an argument of primi-
tive type is passed to a method, a copy of the argument is passe d to the for- Passing a primitive value
mal parameter. For example, consider the PrimitiveCall class shown
☛ ✟
public c l a s s P r i m i t i v e C a l l
{
public s t a t i c void myMethod( i n t n )
{ System . out . p r i n t l n ( ”myMethod : n= ” + n ) ;
n = 1 0 0 ;
System . out . p r i n t l n ( ”myMethod : n= ” + n ) ;
}// m y M e t h o d ( )
public s t a t i c void main ( S t r i n g argv [ ] )
{ i n t k = 5 ;
System . out . p r i n t l n ( ”main : k= ” + k ) ;
myMethod( k ) ;
System . out . p r i n t l n ( ”main : k= ” + k ) ;
}// m a i n ( )
}// P r i m i t i v e C a l l
✡ ✠
Figure 3.7: Passing a primitive value to a method.
in Figure 3.7. Note that we have an int variable k, which initially stores
the value 5, and a method myMethod() , which takes an int parameter n.
SECTION 3.5 •Passing a Value and Passing a Reference 119
In this case, when we invoke myMethod(k) ,k’s value (5) is copied into n
and stored there during the method.
One implication of passing a copy of a primitive value to a met hod is
that the original value of kinmain() cannot be altered from inside the
method. Thus, the output generated by PrimitiveCall would be
☛ ✟
main : k= 5
myMethod : n= 5
myMethod : n= 100
main : k= 5
✡ ✠
Note that in main() ,k’s value is printed both before and after
myMethod() is called, but that its value remains unaffected even though
n’s value is changed within the method. This is because myMethod()
contains just a copy ofk’s value, not kitself. Any changes to the copy
within myMethod() leavekunaltered (See Fig. 3.8).
JAVA LANGUAGE RULE Passing a Primitive Value. When a value
of a primitive type, like boolean orint, is passed to a method, a
copy of the value is passed. That’s why its original value rem ains
unchanged outside the method, even if the copy is changed ins ide the
method.
In contrast to this, when an argument of a reference type is pas sed to a
method, a copy of the reference to the object itself is assigne d to the pa-
rameter. For example, in the case of a String parameter or a OneRowNim
parameter, the method would be given a reference to the object –that is,
the address of the object. The object itself is notpassed, because it would
be too inefﬁcient to copy the entire object with all its data an d methods.
However, because the object’s reference gives the object’s loc ation in mem-
Figure 3.8: Tracing the state
of variables k and n in
PrimitiveCall (a) Just be-
fore calling myMethod(k) in
main . (b) Just before executing
the body of myMethod() . (c)
Just after executing the body of
myMethod() . (d) After ﬂow of
control returns to main() .
120 CHAPTER 3 •Methods: Communicating with Objects
ory, the method will have access to the object and can make chan ges to the
original object from within the method.
For example, consider the ReferenceCall class (Fig. 3.9). In this
case,myMethod() takes a parameter gof type OneRowNim . Because
☛ ✟
public c l a s s ReferenceCall
{
public s t a t i c void myMethod(OneRowNim g )
{ System . out . p r i n t ( ”myMethod : Number of s t i c k s : ” ) ;
System . out . p r i n t l n ( g . g e t S t i c k s ( ) ) ;
g . t a k e S t i c k s ( 3 ) ;
System . out . p r i n t ( ”myMethod : Number of s t i c k s : ” ) ;
System . out . p r i n t l n ( g . g e t S t i c k s ( ) ) ;
}// m y M e t h o d ( )
public s t a t i c void main ( S t r i n g argv [ ] )
{ OneRowNim game = new OneRowNim ( 1 0 ) ;
System . out . p r i n t ( ”main : Number of s t i c k s : ” ) ;
System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;
myMethod( game ) ;
System . out . p r i n t ( ”main : Number of s t i c k s : ” ) ;
System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;
}// m a i n ( )
}// R e f e r e n c e C a l l
✡ ✠
Figure 3.9: Passing a reference value to a method.
aOneRowNim instance is an object, gis a reference variable. So when
myMethod(game) is invoked in main() , a reference to game is passed
tomyMethod() . Note that in myMethod() , we use takeSticks(3) to
change the number of sticks of gfrom 10 to 7 and that this change persists
even after the method returns control to main() . The reason is that dur-
ing the method’s execution, both game andgrefer to the exact same object
(see Fig. 3.10). The output generated by ReferenceCall would be
☛ ✟
main : Number of s t i c k s : 10
myMethod : Number of s t i c k s : 10
myMethod : Number of s t i c k s : 7
main : Number of s t i c k s : 7
✡ ✠
This illustrates that when passing a reference variable to a method, it is
possible for the method to change the state of the object assoc iated with
SECTION 3.6 •Flow of Control: Control Structures 121
Figure 3.10: Tracing the
state of OneRowNim object in
ReferenceCall (a) Just before
calling myMethod(game) . (b)
Just before executing the body of
myMethod() . (c) Just after exe-
cuting the body of myMethod() .
(d) After ﬂow of control returns
tomain() .
the reference variable. In subsequent chapters we will see wa ys to make
use of this feature of reference parameters.
JAVA LANGUAGE RULE Passing a Reference. When a reference to
an object is passed to a method, any changes made to the object fr om
within the method will persist when the method is ﬁnished exe cuting.
JAVA DEBUGGING TIP Side Effects. An unintended change to an
object is called a side effect . Care should be taken in designing
methods that the method does not produce unwanted side effec ts in
objects passed as reference parameters.
3.6 Flow of Control: Control Structures
We have been ignoring a couple of problems with the deﬁnition of the
OneRowNim class. One problem is that we would describe a One Row
Nim game as two players taking turns until there are no more st icks. An
object using OneRowNim would need a way to repeatedly execute a group
of statements. One command in Java that controls the repetit ion of a block
of statements is called a while loop . We will consider it later in this section.
A second problem is with the deﬁnition of takeSticks() :
☛ ✟
public void t a k e S t i c k s ( i n t num)
{ n S t i c k s −num;
player = 3 −player ;
}
✡ ✠
122 CHAPTER 3 •Methods: Communicating with Objects
It is possible to call this method with an argument greater tha n 3 or less
than 1. The call game.takeSticks(5) will remove 5 sticks even though
the rules of One Row Nim say that you must remove 1, 2, or 3. While one
might assume that the user interface should prevent the user from break-
ing this rule, it is a far better design if it was dealt with in OneRowNim .
To do this we need a Java structure that executes different st atements de-
pending on whether the parameter is greater than 3, less than 1, or be-
tween 1 and 3. The Java if-else statement has this capability. A fuller treat-
ment of control structures appears in Chapter 6, but in this s ection, we will
brieﬂy introduce a couple of simple control structures. This will enable us
to write programs that take more interesting actions.
3.6.1 The Simple If Statement
Aselection control structure, allows a program to select between two or
more alternative paths of execution. The if statement is the most basic
selection control structure in Java. Most programming lang uages have its
equivalent. Simple ifstatement
JAVA LANGUAGE RULE If Statement. The if statement has the
following syntax:
if(booleanexpression )
containedstatement ;
The statement contained in the if statement can be any valid J ava state-
ment, including a compound statement. (Recall from Chapter 1 that
a compound statement is a set of statements contained within curly
braces.) The boolean expression is an expression that is either true
orfalse . We have seen examples of boolean expressions that involve
int variables, int values, and the inequality or equality operators. A
method call to a method with a boolean result type is another example
of aboolean expression. Given this description of if statement syntax,
the following are examples of valid if statements:
☛ ✟
i f(true ) System . out . p r i n t l n ( ” Hello ” ) ;
i f( n S t i c k s <= 0) System . out . p r i n t l n ( ”game i s over ” ) ;
✡ ✠
For readability, we usually write an if statement with its co ntained state-
ment indented on the next line:
☛ ✟
i f(true )
System . out . p r i n t l n ( ” Hello ” ) ;
i f( n S t i c k s <= 0)
System . out . p r i n t l n ( ”game i s over ” ) ;
✡ ✠
SECTION 3.6 •Flow of Control: Control Structures 123
The following are all examples of syntax errors involving th e if statement:
☛ ✟
i f true // P a r e n t h e s e s a r e m i s s i n g
System . out . p r i n t l n ( ” Hello ” ) ;
i f( n S t i c k s <= 0) return // S e m i c o l o n m i s s i n g
i f(” true ” )return ; // ” t r u e ” i s n o t a b o o l e a n
i f(true )” Hello ” ; // ” H e l l o ” i s n o t a s t a t e m e n t
✡ ✠
Semantically, the if statement has the following interpret ation: First, the
boolean condition is evaluated. If it is true, then the contai ned statement is
executed; if it is false, then the contained statement is not executed. This is
shown in Figure 3.11. The ﬂowchart clearly shows that program ﬂow will
take one or the other of the alternative paths coming out of th e diamond-boolean
condition
statementTrue
False
FIGURE 3.11 Flowchart of the if
statement. Diamond-shaped symbols
at the branch points contain
boolean expressions. Rectangular
symbols can only contain executable
statements. Circles act simply as
connectors, to connect two or more
paths.shaped boolean condition box. The branch through the rectan gular state-
ment box will be taken when the boolean condition is true; oth erwise the
statement will be skipped.
As another example, consider the deﬁnition of a getPlayerString()
method for the OneRowNim class:
☛ ✟
public S t r i n g g e t P l a y e r S t r i n g ( )
{
i f( player == 1)
return ” Player One” ;// E x i t t h e m e t h o d
i f( player == 2)
return ” Player Two” ;// E x i t t h e m e t h o d
return ” Player e r r o r ” ; // E x i t t h e m e t h o d
}
✡ ✠
The ﬂowchart in Figure 3.12 shows the program ﬂow of the entire
getPlayerString() method. It is important to note that when a
player == 1True
False
player == 2
return "Player error"
exit methodexit methodexit method
return "Player Two"return "Player One"
True
FalseFigure 3.12: Flowchart of the
getPlayerString() method.
return statement is executed in a method, control is returned im-
124 CHAPTER 3 •Methods: Communicating with Objects
mediately to the calling method. Thus, if player == 1 is true,
the string “Player One” is returned to the calling method and the
getPlayerString() method exits at this point. If it is false, then
player == 2 should be true (if we have a consistent state) and the string
“Player Two” should be returned and the method exited. Thus, if we have
a consistent state —that is, if player has value 1 or 2—then the third
return statement should never be reached.
The following example shows the more common case where the st ate-
ment contained in an if statement can be a compound statement : Compound statement
☛ ✟
i f( player == 1)
{ S t r i n g s = ” Player One” ;
System . out . p r i n t ( s ) ;
System . out . p r i n t l n ( ” plays next ” ) ;
System . out . p r i n t l n ( ” The game i s not over ” ) ;
}
✡ ✠
Ifplayer == 1 is true, then all four statements in the contained com-
pound statement will be executed. Note here that we are decla ring the Local scope
local variable, s, in this block. Its scope would extend only to the end of
the block. Note also that when we use a compound statement, th e com-
pound statement itself is not followed by a semicolon becaus e it is already
enclosed in braces.
A common programming error is to forget the braces around the com-
pound statement. Merely indenting the statements followin g the if clause
doesn’t alter the logic of the if statement. For example, the following if
statement still has only one statement in its if clause:
☛ ✟
i f( condition1 )
System . out . p r i n t l n ( ”One” ) ;
System . out . p r i n t l n ( ”Two” ) ; // N o t p a r t o f i f s t a t e m e n t
✡ ✠
This segment will always print “Two” because the second println() is
not part of the if statement. To include it in the if statement , you must
enclose both println() statements within braces:
☛ ✟
i f( condition1 )
{System . out . p r i n t l n ( ”One” ) ;
System . out . p r i n t l n ( ”Two” ) ;
}
✡ ✠
JAVA DEBUGGING TIP Indentation. Indentation can improve the
readability of a program but doesn’t affect its logic. Brace s must be
used to group statements in the if clause.
SECTION 3.6 •Flow of Control: Control Structures 125
3.6.2 The if-else Statement
A second version of the if statement incorporates an else clause into the
structure. This allows us to execute either of two separate s tatements (sim-
ple or compound) as the result of one boolean expression. For example,
the statement
☛ ✟
i f( player == 1)
System . out . p r i n t l n ( ” Player One” ) ;
else
System . out . p r i n t l n ( ” Player Two” ) ;
✡ ✠
will print “Player One” if player == 1 is true. Otherwise, it will print
“Player Two”.
JAVA LANGUAGE RULE If-else Statement. The if-else statement has
the following syntax:
if(booleanexpression )
statement1 ;
else
statement2 ;
As in the case of the simple if statement, the keyword ifis followed by If-else syntax
a parenthesized boolean expression , which is followed by statement1 , which
may be either simple or compound. If statement1 is a simple statement,
then it is followed by a semicolon. The else clause follows immediately
after statement1 . It begins with the keyword else , which is followed by
statement2 , which can also be either a simple or compound statement.
Note that there is no boolean expression following the else keyword.
In an if-else statement, the boolean expression following th e keyword if
goes with both the if and else clauses.
Semantically, the if-else statement has the following inte rpretation: If
theboolean expression is true, execute statement1 ; otherwise execute state-
ment2 . This interpretation is shown in Figure 3.13.boolean
condition
statement1True
statement2False
FIGURE 3.13 Flowchart of the
if-else statement. 3.6.3 The Nested if/else Multiway Selection Structure
The statements that one inserts in place of statement1 and statement2 in
the if-else statement can be any executable statement, incl uding another
if statement or if-else statement. In other words, it is possi ble to embed
one or more if-else statements inside another if-else state ment, thereby
creating a nested control structure. As with most things, making a control
structure too complex isn’t a good idea, but there is a standa rd nested if-
else control structure that is very useful. It is known as multiway selec-
tion. As shown in Figure 3.14, the multiway structure is used when you
want to select one and only one option from several alternati ves.
Suppose we have an int variable num that will contain one of the val-
ues1,2, or3unless there has been an error assigning a value to it. Sup-
pose that we want to write code that will write out the English word for
126 CHAPTER 3 •Methods: Communicating with Objects
Figure 3.14: Flowchart of a nested
if-else statement.
num == 3
Error:
Unknown valueTrue Falsenum == 2True Falsenum == 1True False
ThreeTwoOne
the value in num. In the example shown in Figure 3.14 there are three
alternatives plus an error state. Here is the Java code for thi s example:
☛ ✟
i f(num == 1)
System . out . p r i n t l n ( ”One” ) ;
else i f (num == 2)
System . out . p r i n t l n ( ”Two” ) ;
else i f (num == 3)
System . out . p r i n t l n ( ”Three ” ) ;
else
System . out . p r i n t l n ( ” Error : Unknown value ” ) ;
✡ ✠
Note that the multiway structure has a single entry point and that only one
of the four possible alternatives is executed. The code will print exactly Multiple alternatives
one of the strings.
We will have many occasions to use the if-else structure. Al-
though it does not represent a signiﬁcant change, we could re write our
takeStick() method to make use of the if-else instead of the somewhat
obscure statement :
☛ ✟
player = 3 −player ;
✡ ✠
SECTION 3.6 •Flow of Control: Control Structures 127
to change the value of player from 1to2or vice versa:
☛ ✟
public S t r i n g t a k e S t i c k s ( i n t num)
{ n S t i c k s = n S t i c k s −num;
i f( player == 1)
player = 2 ; // F r o m 1 t o 2
else
player = 1 ; // F r o m 2 t o 1
}
✡ ✠
In some respects this version of takeSticks() involves four lines of
code instead of one but is simpler to understand. The if-statement tests
whether the value of player is1. If it is, the value is changed to 2. If
the value of player is not1, then the value must be 2and so the value is
changed to 1. Both versions of the code will give precisely the same resul t,
a programmer could choose to write the code either way.
SELF-STUDY EXERCISES
EXERCISE 3.10 Consider the following method with boolean param-
eter.
☛ ✟
public S t r i n g g e t S t a t u s ( boolean isDone )
{ i f( isDone )
return ”Done” ;
else
return ”Not Done” ;
}
✡ ✠
Draw a ﬂowchart for the if-else version of the getStatus() method, us- Flowchart symbols
ing the ﬁgures in this section as a guide. The if-else structu re should be
drawn exactly as shown in Figure 3.11. It should have a single e ntry point
that leads directly to the top of a diamond-shaped box that co ntains a
boolean condition. There should be two branches coming out o f the con-
dition box. The one going to the right is the true case, and the one going
to the left is the false case. Each of these branches should co ntain one
rectangular box, which contains the statements that would b e executed in
that case. The left and right branches should be connected by a circular
symbol that is aligned directly under the diamond box whose c onditions
it connects. There should be a single exit arrow pointing dir ectly down.
EXERCISE 3.11 Identify the error in the following statements:
☛ ✟
i f( isHeavy == true )
System . out . p r i n t l n ( ”Heavy” ) ;
else ;
System . out . p r i n t l n ( ” Light ” ) ;
i f( isLong == true )
System . out . p r i n t l n ( ”Long” )
else
System . out . p r i n t l n ( ” Short ” ) ;
✡ ✠
128 CHAPTER 3 •Methods: Communicating with Objects
EXERCISE 3.12 Suppose we have an int instance variable named
player in some class describing a three person game. Write a method
named getPlayerName() that returns a String . It should return
“Ann”, “Bill”, “Cal”, or “Error” when the value of player is respectively
1, 2, 3, or any other value.
EXERCISE 3.13 How does a parameter for a primitive type differ from
a parameter for a reference type?
3.6.4 The While Structure
Arepetition structure is a control structure that repeats a statement or
sequence of statements in a controlled way. Repetition stru ctures are also
referred to as loop structures . Many types of programming tasks require
a repetition structure. Consider some examples.
•You want to add up the squares of the numbers from 1 to 100.
•You want to compute compound interest on an amount of money in
a savings account with a ﬁxed interest rate if it is kept there for30
years.
•A computer security employee wants to try every possible pas sword
in order to break into an account of a suspected spy.
•You want to have players input moves for a turn in a game until t he
game is over. Our OneRowNim is such an example.
We will study several different repetition structures of Ja va in depth in
Chapter 6. We will brieﬂy consider the while statement here so as to be
able to deﬁne methods that are more powerful and more interes ting. Let
us write a method that solves a slight generalization of the ﬁ rst problem
above. We will use the while statement to sum the squares of in tegers from
1to a number speciﬁed as a parameter of the method. Thus, the me thod
callsumSquares(3) should return the value 14since1∗1+2∗2+3∗3=
1+4+9=14.
☛ ✟
public i n t sumSquares ( i n t max)
{i n t num = 1 ;
i n t sum = 0 ;
while (num<= max) {// W h i l e num <= max
sum = sum + num ∗num; // Add s q u a r e t o sum
num = num + 1 ; // Add 1 t o num
}// w h i l e
return sum ; // R e t u r n t h e sum
}
✡ ✠
Note that in this example, the variable num gets assigned an initial value
of1before the while statement. Note also that the boolean expression
num < max in parentheses after while states the condition for which we
wish to continue summing squares. Finally note that the last statement
in the block following the boolean expression adds 1tonum–that is, this
variable is updated at the end of the block.
SECTION 3.6 •Flow of Control: Control Structures 129
The while statement is a loop statement in which the loop entry condi-
tion occurs before the loop body. It has the following general form:
JAVA LANGUAGE RULE While Statement. The while statement has
the following syntax:
while(loopentrycondition )
loopbody ;
When the while statement is executed, the loop entry condition is evalu-
ated and if this evaluates to false , execution continues at the statement
immediately after the loop body. If the loop entry condition e valuates to
true , the loop body is executed and then the entry condition is eva lu-
ated again. The loop body continues to be executed until the l oop entry
condition evaluates to false .
To have a while statement accomplish a task, the variable or variables
in the loop entry condition must be initialized correctly be fore the while
statement and these variables must be correctly updated at t he end of the
loop body. We can refer to the initializer statement followe d by a while
statement as a while structure . We can restate the above guidelines as a
design principle:
JAVA EFFECTIVE DESIGN Loop Structure. A properly designed
while structure must include an initializer, a loop entry co ndition, and
an updater. The updater should guarantee that the loop entry
condition eventually fails, thereby allowing the loop to te rminate.
In pseudocode, the while structure would take the following form:
☛ ✟
I n i t i a l i z e r S t a t e m e n t s ; // I n i t i a l i z e r
while ( loop entry condition ) {// B o u n d t e s t
Statements ; // L o o p b o d y
UpdaterStatements ; // U p d a t e r
}
✡ ✠
As its form suggests, the while structure is designed so that on some con-
ditions the loop body will never be executed. Because it test s for the loop
entry condition before the loop body, it is possible that the loop body is
never executed. We might say that it is designed to perform 0 o r more
iterations.
For example, if the method call sumSquares(-3) is executed, the loop
body will be skipped, because the loop entry condition num <= max is
false to begin with. No iterations will be performed, and the algorithm
will simply return the value 0.
Note also that in the while statement the bound test is preced ed by
initializer statements, and the loop body contains updater statements. The
semantics of the while structure are shown in Figure 3.15.
130 CHAPTER 3 •Methods: Communicating with Objects
Figure 3.15: Flowchart of the
while statement and while struc-
ture.While Statement While Structure
StatementTrue
FalseConditionUpdater
Statement
(loop body)True
FalseLoop
entry
conditionInitializer
SELF-STUDY EXERCISE
EXERCISE 3.14 Modify the deﬁnition of the sumSquares() method
to deﬁne a method named sumCubes() that sums the cubes of integers
from a minimum value up to a maximum value and returns that sum .
sumCubes() should have two parameters that will store the minimum
and maximum values. Thus the method call sumCubes(2,3) should
return35since2∗2∗2+3∗3∗3=8+27=35.
3.7 Testing an Improved OneRowNim
Let’s use the control structures that we have discussed to im prove the
deﬁnition of the takeSticks() method of OneRowNim . We noted ear-
lier that our current deﬁnition allows 4or more sticks to be removed
fromnSticks even though the rules of One Row Nim indicate that a
player must take one, two, or three sticks on a turn. We can use if-else
statements to make certain that no more than 3sticks get removed.
What should happen if the method takeSticks() is called with an
argument that does not represent a legal number of sticks to r emove? In
this case, it would probably make sense to remove no sticks at all and to
keep the value of player the same so that the player whose turn it is does
not change. In addition, it would be nice if the method could si gnal that an
illegal move has been attempted. This can be accomplished if we redeﬁne
takeSticks() to return a boolean value. Let’s have a return value of
true represent the case that a valid number of sticks have been rem oved
and the player to play next has been changed. A return of false will
indicate that an illegal move has been attempted. Making the se changes
SECTION 3.7 •Testing an Improved OneRowNim 131
to thetakeSticks() method will yield a method deﬁnition that looks
like:
☛ ✟
public boolean t a k e S t i c k s ( i n t num)
{ i f(num<1){
return f a l s e ;// E r r o r
}else i f ( num>3){
return f a l s e ;// E r r o r
}else{
n S t i c k s = n S t i c k s −num;
player = 3 −player ;
return true ;
}// e l s e
}// t a k e S t i c k s
✡ ✠
Notice that the new deﬁnition of the takeSticks() method has a
boolean return type. Also notice that the if/else multiway structure
is used to handle the three cases of the parameter num being less than one,
more than three, or a valid number.
Let us add one more method to the OneRowNim class. Let’s deﬁne a
method called getWinner() that will return the number of the winning
player if the game is over. Recall that the player who takes th e last stick
loses, so after that last play, the player whose turn it is to p lay next is the
winner. However, we should be concerned about what value to re turn if
the game is not over when the method is called. A common strate gy is
to have a method return a special value to indicate that it is i n a state in
which it cannot return the value requested. Returning a 0value is a good
way to indicate that the game is not over so a winner cannot be i dentiﬁed.
With this information, the if/else statement can be used in t he deﬁnition
ofgetWinner() .
☛ ✟
public i n t getWinner ( )
{ i f( n S t i c k s <1)
return player ;
else
return 0 ;
}// g e t W i n n e r ( )
✡ ✠
We now have the ﬁnal version (for this chapter) of the OneRowNim
class whose implementation is given in Figure 3.16. We have t urned a
very simple class into one that contains quite a few elements . Compared
to our ﬁrst version (in Chapter 1), this Chapter’s version of OneRowNim
presents an interface (to other objects) that is easy and conv enient to
use. The constructor methods with parameters provide an eas y way
to create a OneRowNim instance with any number of sticks. The use
ofprivate instance variables and a single, carefully designed mutato r
method, takeSticks() , prevents other objects from tampering with
the state of a OneRowNim object’s state. The other methods provide a
ﬂexible way to ﬁnd out the state of a OneRowNim object. The complete
implementation of this OneRowNim is shown in Figure 3.16.
132 CHAPTER 3 •Methods: Communicating with Objects
☛ ✟
public c l a s s OneRowNim
{ private i n t n S t i c k s = 7 ;
private i n t player = 1 ;
public OneRowNim ( )
{
}// OneRowNim ( ) c o n s t r u c t o r
public OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
} // OneRowNim ( ) c o n s t r u c t o r 2
public OneRowNim( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ;
player = s t a r t e r ;
} // OneRowNim ( ) c o n s t r u c t o r 3
public boolean t a k e S t i c k s ( i n t num)
{ i f(num<1)return f a l s e ; // E r r o r
else i f ( num>3)return f a l s e ;// E r r o r
else // t h i s i s a v a l i d move
{ n S t i c k s = n S t i c k s −num;
player = 3 −player ;
return true ;
}// e l s e
}// t a k e S t i c k s ( )
public i n t g e t S t i c k s ( )
{ return n S t i c k s ;
}// g e t S t i c k s ( )
public i n t getPlayer ( )
{ return player ;
}// g e t P l a y e r ( )
public boolean gameOver ( )
{ return ( n S t i c k s <= 0 ) ;
}// g a m e O v e r ( )
public i n t getWinner ( )
{ i f( n S t i c k s <1)return getPlayer ( ) ;
else return 0 ; // g a m e i s n o t o v e r
}// g e t W i n n e r ( )
public void report ( )
{ System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ” +
g e t S t i c k s ( ) ) ;
System . out . p r i n t l n ( ”Next turn by player ” +
getPlayer ( ) ) ;
} // r e p o r t ( )
}// OneRowNim c l a s s
✡ ✠
Figure 3.16: The OneRowNim class with improved methods.
SECTION 3.7 •Testing an Improved OneRowNim 133
Let’s use a while statement to test the new methods of the clas s. A
pseudocode description of how a game is played might look lik e:
☛ ✟
Choose the i n i t i a l number of s t i c k s for the game
while the game i s not over
{ Report the s t a t e of the game
Process the next move
}
Report the s t a t e of the game
Report who the winner i s
✡ ✠
Translating this pseudocode into Java code in a main() method in a sepa-
rate class gives us the class shown in Figure 3.17. We will use theScanner
class introduced in the previous chapter to get moves from th e keyboard
☛ ✟
import java . u t i l . Scanner ;
public c l a s s TestOneRowNim
{
public s t a t i c void main ( S t r i n g argv [ ] )
{Scanner sc = Scanner . c r e a t e ( System . in ) ;
OneRowNim game = new OneRowNim ( 1 1 ) ;
while ( game . gameOver ( ) == f a l s e )
{ game . report ( ) ; // P r o m p t t h e u s e r
System . out . p r i n t ( ” Input 1 , 2 , or 3 : ” ) ;
i n t s t i c k s = sc . n e x t I n t ( ) ; // G e t move
game . t a k e S t i c k s ( s t i c k s ) ; // Do move
System . out . p r i n t l n ( ) ;
}// w h i l e
game . report ( ) ; // T h e g a m e i s now o v e r
System . out . p r i n t ( ”Game won by player ” ) ;
System . out . p r i n t l n ( game . getWinner ( ) ) ;
}// m a i n ( )
}// T e s t O n e R o w N i m
✡ ✠
Figure 3.17: The TestOneRowNim class with a while loop.
for both players. Before each move game.report() describes the state
of the game before the user is prompted to input a move for one o f the
players. A reader interested in seeing the lengthy output to the console
when the TestOneRowNim class is run is encouraged to actuall y run the
program.
Note that the return value of the takeSticks() method is ignored
in this test program. We will make use of the return value in te st pro-
grams in the next chapter when better user interfaces are dev eloped for
OneRowNim . Note, however, that taken together, the public methods for
134 CHAPTER 3 •Methods: Communicating with Objects
OneRowNim provide other objects with an interface that they can use to
communicate with individual OneRowNim objects.
JAVA EFFECTIVE DESIGN Interfaces. Well-designed objects
provide a useful public interface and protect the object’s pr ivate
elements from other objects.
To reiterate a point made at the outset, object-oriented prog ramming is a Object-oriented design
process of constructing objects that will interact with each other. Object-
oriented programs must ensure that the objects themselves ar e well de-
signed in terms of their ability to carry out their designate d functions.
Good design in this sense requires careful selection of inst ance variables
and careful design of methods to ensure that the object can car ry out its
assigned tasks. However, equal care must be taken to ensure th at the
interactions that take place among objects are constrained i n ways that
make sense for that particular program. This aspect of desig ning ob-
jects comes into play in designing the methods—constructor, a ccessor, and
mutator—that make up the object’s interface.
Special Topic: Intelligent Agents
Wouldn’t it be nice if we had a computer program that could schedule
appointments for us, remind us of meetings and commitments, ﬁnd in-
formation for us on the WWW, and manage our e-mail messages for u s?
Wouldn’t it be nice to have a computerized personal assistan t?
Actually, such programs are called intelligent agents , which are pro-
grams that are capable of acting autonomously to carry out ce rtain tasks.
Intelligent agent technology is becoming an important resea rch area in
computer science. Most agent programs incorporate some kin d of ma-
chine learning capability, so that their performance impro ves over time.
As a typical agent activity, suppose I was able to tell my inte lligent
agent to buy me a copy of a certain book that I just heard about. G iven a
command like “buy me a copy of X,” the agent would perform a sea rch
of online book sellers and come up with the best deal. Once it h ad found
the best buy, the agent would communicate with a computer-ba sed agent
representing the book seller. My agent would make the order a nd pay
for it (assuming I gave it authority to do so), and the book sel ler’s agent
would process the order.
As far-fetched as the capability may now seem, this is the dir ection
that research in this area is headed. Researchers are develo ping agent
languages and describing protocols that agents can use to ex change in-
formation in a reliable and trustworthy environment. Obvio usly, you
wouldn’t want your agent to give your money to a fraudulent bo ok seller,
so there are signiﬁcant problems to solve in this area that go well beyond
the problem of simply exchanging information between two ag ents.
The best way to learn more about this research area is to do a We b
search using the search string “Intelligent Agent.” There ar e numerous re-
search groups and companies that provide online descriptio ns and demos
of their products.
SECTION 3.8 •From the Java Library java.lang.Object 135
3.8 From the Java Library java.lang.Object
java.sun.com/j2se/1.5.0/docs/api/The most general class in Java’s class hierarchy is the java.lang.Object
class. It is the superclass of all classes that occur in Java pr ograms. By de-
fault, it is the direct superclass of any class that does not e xplicitly specify
a pedigree in its class deﬁnition.
All subclasses of Object inherit thepublic andprotected methods
contained in Object , so all such methods can be thought of as belonging
to the subclasses. This means that all classes inherit the me thods of the
Object class, because every class is a subclass of it. In this section , let’s
look brieﬂy at how we can use an inherited method and also at how we
canoverride it–that is, redeﬁne the method–if it doesn’t exactly suit ou r
purposes.
One of the most useful methods in the Object class is the
toString() method:
☛ ✟
public c l a s s Object
{
public S t r i n g t o S t r i n g ( ) ;
}
✡ ✠
ThetoString() method returns a String representation of its object.
For example, o1.toString() will return a String that in some sense
describes o1.
Because OneRowNim is a subclass of Object , it inherits the
toString() method. To illustrate the default behavior of toString() ,
let’s use it with a OneRowNim instance:
☛ ✟
OneRowNim g1 = new OneRowNim ( 1 1 ) ;
OneRowNim g2 = new OneRowNim ( 1 3 ) ;
System . out . p r i n t l n ( g1 . t o S t r i n g ( ) ) ;
System . out . p r i n t l n ( g2 . t o S t r i n g ( ) ) ;
✡ ✠
This code segment creates two OneRowNim instances, one named g1and
the other named g2. The inherited toString() method is then invoked
on each OneRowNim instance, which produces the following output:
☛ ✟
OneRowNim@1dc6077b
OneRowNim@1dc60776
✡ ✠
What this experiment shows is that the default deﬁnition of toString()
returns some kind of internal representation of its object. It looks as if it
returns the name of the object’s class concatenated with its m emory ad-
dress. This may be useful for some applications. But for most objects
we will want to override the default deﬁnition to make the toString()
method return a string that is more appropriate for OneRowNim .
WhatString should the g1.toString() method return? Let’s have
it return a String that reports the OneRowNim instances’s current state,
which are the values stored in the two instance variables. To override
a method, you simply deﬁne a method with the same signature in the
136 CHAPTER 3 •Methods: Communicating with Objects
subclass. If you call toString() with an instance of the subclass, its
version of the method will be used. In this way, the subclass me thod over-
rides the superclass version. Thus, OneRowNim.toString() will have
the following signature:
☛ ✟
public S t r i n g t o S t r i n g ( ) ;
✡ ✠
Let us describe the state of a oneRowNim instance very brieﬂy in the string
returned by the toString() method:
☛ ✟
public S t r i n g t o S t r i n g ( )
{return ” n S t i c k s = ” + n S t i c k s + ” , player = ” + player ;
}
✡ ✠
If we add the toString() method to the OneRowNim class and then run
the program shown in Figure 3.18, we get the following output :
☛ ✟
n S t i c k s = 9 , player = 2
n S t i c k s = 13 , player = 1
✡ ✠
☛ ✟
public c l a s s TestToString
{
public s t a t i c void main ( S t r i n g argv [ ] )
{OneRowNim g1 = new OneRowNim ( 1 1 ) ;
OneRowNim g2 = new OneRowNim ( 1 3 ) ;
g1 . t a k e S t i c k s ( 2 ) ;
System . out . p r i n t l n ( g1 . t o S t r i n g ( ) ) ;
System . out . p r i n t l n ( g2 . t o S t r i n g ( ) ) ;
}// m a i n
}// T e s t T o S t r i n g
✡ ✠
Figure 3.18: An application to test the overridden toString() method.
While this new method may not play an important role in the OneRowNim
class, it does provide a very brief, understandable descrip tion of the state
of the object. This is the reason that the toString() method was in-
cluded in the Object class.
3.9 Object-Oriented Design: Inheritance and
Polymorphism
This use of Object ’stoString() method provides our ﬁrst look at Inheritance
Java’s inheritance mechanism and how it promotes the genera lity and
extensibility of the object-oriented approach. As a subclas s ofObject ,
ourOneRowNim class automatically inherits toString() and any other
public orprotected methods deﬁned in Object . We can simply use
these methods as is, insofar as they are useful to us. As we saw in this
case, the default version of toString() wasn’t very useful. In that case,
SECTION 9 •OOD: Inheritance and Polymorphism 137
we can override the method by deﬁning a method in our class wit h the
exact same method signature. The new version of toString() can be
customized to do exactly what is most appropriate for the sub class.
One of the great beneﬁts of the object-oriented approach is th e ability
to deﬁne a task, such as toString() , at a very high level in the class
hierarchy and let the inheritance mechanism spread that tas k through-
out the rest of the hierarchy. Because toString() is deﬁned in Object ,
you can invoke this method for any Java object. Moreover, if yo u over-
ridetoString() in the classes you deﬁne, you will be contributing to its
usefulness. Two important lessons from this example are
JAVA EFFECTIVE DESIGN Inheritance. The higher up in the class
hierarchy that a method is deﬁned, the more widespread its us e can be.
JAVA EFFECTIVE DESIGN Overriding toString() .The
toString() method can be overridden in any user deﬁned Java
class. It is a useful thing to do in any class where the state of a n object
can be deﬁned brieﬂy.
Obviously there is much more that needs to be explained about Java’s
inheritance mechanism. Therefore, we will be revisiting th is topic on
numerous occasions in subsequent chapters.
Another important concept of object-oriented design is poly morphism.
ThetoString() method is an example of a polymorphic method. The
term polymorphism is from the Greek terms poly, which means “many,”
and morph , which means “form.” The toString() method is polymor-
phic because it has different behavior when invoked on diffe rent objects.
For example, suppose we design a class, Student , as a subclass of
Object and deﬁne its toString() method to return the student ID
number. Given this design, then obj.toString() will return a student
ID ifobj is an instance of Student , but if it is an instance of OneRowNim ,
it will return a the description of its state that we deﬁned ab ove. The
following code segment illustrates this point:
☛ ✟
Object obj ; // o b j c a n r e f e r t o a n y O b j e c t
obj = new Student ( ” 12345 ” ) ;// o b j r e f e r s t o a S t u d e n t
System . out . p r i n t l n ( obj . t o S t r i n g ( ) ) ; // P r i n t s ” 1 2 3 4 5 ”
obj = new OneRowNim ( 1 1 ) ; // o b j r e f e r s t o a OneRowNim
System . out . p r i n t l n ( obj . t o S t r i n g ( ) ) ;
// P r i n t s : n S t i c k s = 1 1 , p l a y e r = 1
✡ ✠
In this case, the variable obj is used to refer to a Student and then to a
OneRowNim instance. This is okay because both classes are subclasses o f
Object . When toString() is invoked on obj, Java will ﬁgure out what
subclass of Object the instance belongs to and invoke the appropriate
toString() method.
138 CHAPTER 3 •Methods: Communicating with Objects
3.10 Drawing Lines and Deﬁning Graphical
Methods (Optional)
We used a Graphics object in the previous chapter to draw rectangles
and ovals in an applet window. The Graphics class also possesses a
method for drawing a line segment. Problems involving drawi ng pic-
tures in an applet window using a series of line segments can b e a source
of examples of deﬁning useful methods and also of making good use of
loops.
TheGraphics class has a public instance method with the header:
☛ ✟
public void drawLine ( i n t x1 , i n t y1 , i n t x2 , i n t y2 )
✡ ✠
The method call g.drawLine(x1, y1, x2, y2) draws a line from the
point(x1,y1)to(x2,y2)where(x,y)refers to a point that is xpixels from
the left edge of the area that gis drawing in and ypixels from the top edge.
Thusg.drawLine(10, 10, 10, 60) draws a vertical line segment
that is 50 pixels long and is 10 pixels from the left edge of the drawing
area, that is, a line segment from the point (10,10)to the point (10,60).
Consider the problem of creating an applet program with a met hod
calleddrawSticks() to draw any speciﬁed number of vertical line seg-
ments. This method might be useful for an applet user interfa ce to the
OneRowNim game to draw the number of sticks at a given point in a
game. Suppose that this method must have an int parameter to spec-
ify the number of vertical lines to draw and two int parameters to spec-
ify the location of the top endpoint of the left most line segm ent. The
drawSticks() method will need to use a Graphics object connected
to the applet window for drawing the line segment. The only su ch
Graphics object available is the parameter in the paint() method of
an applet. Thus the method must have a Graphics parameter and it will
be called in the paint() method using the Graphics object there as an
argument. Thus the header of the method should look like:
☛ ✟
public void drawSticks ( Graphics g , i n t x ,i n t y ,i n t num)
✡ ✠
The length of the line segments and and the distance between t hem
are not speciﬁed by parameters so we need to choose some ﬁxed v alues
for these quantities. Let us assume that the line segments ar e 10 pixels
apart and 50 pixels long. We now have enough information to co mplete
the deﬁnition of an applet to solve this problem. Such a class deﬁnition is
reproduced in Figure 3.19.
Note that the body of drawSticks() uses a while-loop to draw the
lines and declares and initializes a local variable to zero t o use for counting
the number of lines drawn. The statement g.drawLine(x, y, x, y +
50); draws a vertical line which is 50pixels long. Increasing the value
ofxby10each time through the loop moves the next line 10pixels to the
right.
The ﬁrst call to drawSticks() in the paint() method draws 12
lines with (25,25)the top point of the left-most line. The second call to
drawSticks() will draw 7cyan sticks 100pixels lower. Note that chang-
SECTION 10 •Drawing and Graphical Methods 139
☛ ✟
/∗∗ D r a w L i n e A p p l e t d e m o n s t r a t e s s o m e g r a p h i c s c o m m a n d s .
∗I t d r a w s a s e t o f 1 2 v e r t i c a l l i n e s a n d a s e t o f 7 l i n e s .
∗/
import java . awt . ∗;
import java . applet . ∗;
public c l a s s DrawSticksApplet extends Applet
/∗∗ d r a w S t i c k s ( g , x , y , num ) w i l l d r a w num v e r t i c a l l i n e
∗s e g m e n t s . T h e l i n e s e g m e n t s a r e 1 0 p i x e l s a p a r t a n d
∗5 0 p i x e l s l o n g . T h e t o p e n d p o i n t o f t h e l e f t m o s t
∗l i n e s e g m e n t i s a t t h e p o i n t ( x , y ) .
∗/
public void drawSticks ( Graphics g , i n t x , i n t y , i n t num)
{i n t k = 0 ;
while ( k<num)
{ g . drawLine ( x , y , x , y + 5 0 ) ;
x = x + 1 0 ;
k = k + 1 ;
}// w h i l e
}// d r a w S t i c k s ( )
public void paint ( Graphics g )
{ drawSticks ( g , 25 , 25 , 1 2 ) ;
g . setColor ( Color . cyan ) ;
drawSticks ( g , 25 , 125 , 7 ) ;
}// p a i n t ( )
}// D r a w S t i c k s A p p l e t
✡ ✠
Figure 3.19: An applet program with a method for drawing a set of sticks.
ing the color of gbefore passing it as an argument to drawSticks()
changes the drawing color.
To run this applet, one needs the following HTML document, whi ch
speciﬁes the applet code as DrawSticksApplet.class :
☛ ✟
<HTML>
<HEAD>
<TITLE>Draw S t i c k s Web Page </TITLE>
</ HEAD>
<BODY>
<H2>DrawSticksApplet w i l l appear below. </H2>
<APPLET CODE = ” DrawSticksApplet . c l a s s ”
WIDTH = 400 HEIGHT = 200 >
</APPLET >
</BODY>
</ HTML>
✡ ✠
An image of the DrawSticksApplet as it appears in a browser window
is shown in Figure 3.20.
As we have seen in this example, deﬁning methods with paramet ers to
draw an object makes the code reusable and makes it possible to draw a
140 CHAPTER 3 •Methods: Communicating with Objects
Figure 3.20: The DrawSticksAp-
plet as displayed in a browser
window.
complex scene by calling a collection of simpler methods. It i s a typical
use of the divide-and-conquer principle. The while-loop ca n be useful in
drawing almost any geometrically symmetric object.
CHAPTER SUMMARY Technical Terms
accessor method
class scope
formal parameter
if statement
if/else statement
inherit
local scopeloop structure
method overloading
method signature
mutator method
multiway selection
override
polymorphismrepetition structure
scope
selection
side effect
while statement
while structure
Summary of Important Points
•Aformal parameter is a variable in a method declaration. It always con-
sists of a type followed by a variable identiﬁer. An argument is a value
that is passed to a method via a formal parameter when the meth od is
invoked. A method’s parameters constrain the type of information that
can be passed to a method.
•When an argument of primitive type is passed to a method, it can not
be modiﬁed within the method. When an argument of reference ty pe
CHAPTER 3 •Solutions to Self-Study Exercises 141
is passed to a method, the object it refers to can be modiﬁed wit hin the
method.
•Except for void methods, a method invocation ormethod call is an
expression which has a value of a certain type. For example,
nim.getSticks() returns a int value.
•The signature of a method consists of its name, and the number, types,
and order of its formal parameters. A class may not contain mo re than
one method with the same signature.
•Aconstructor is a method that is invoked when an object is created. If a
class does not contain a constructor method, the Java compil er supplies
adefault constructor .
•Restricting access to certain portions of a class is a form of informa-
tion hiding . Generally, instance variables are hidden by declaring the m
private . The class’s public methods make up its interface.
•The if statement executes a statement only if its boolean condition is
true. The if-else statement executes one or the other of its statements
depending on the value of its boolean condition. Multiway selection al-
lows one and only one of several choices to be selected depend ing on
the value of its boolean condition.
•Thewhile statement is used for coding loop structures that repeatedl y
execute a block of code while a boolean condition is satisﬁed .
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 3.1 Amethod declaration deﬁnes the method by specifying its name,
qualiﬁers, return type, formal parameters, and its algorithm , thereby associating
a name with a segment of executable code. A method invocation calls or uses a
deﬁned method.
SOLUTION 3.2 Aformal parameter is a variable in the method declaration, whose
purpose is to store a value while the method is running. An argument is a value
that is passed to a method in place of a formal parameter.
SOLUTION 3.3 The following code declares two instance variables for names of
players and deﬁnes a setName() method:
☛ ✟
private S t r i n g nameOne = ” Player One” ;
private S t r i n g nameTwo = ” Player Two” ;
public void setNames ( S t r i n g name1 , S t r i n g name2 )
{ nameOne = name1 ;
nameTwo = name2 ;
}
✡ ✠
Of course, there are many other appropriate names for the variabl es and parame-
ters and other initial assignments.
SOLUTION 3.4 A method call that sets the names of the players of game1 is:
☛ ✟
game1 . setNames ( ”Xena” ,”Yogi” ) ;
✡ ✠
SOLUTION 3.5 A constructor cannot have a return type, such as void.
142 CHAPTER 3 •Methods: Communicating with Objects
SOLUTION 3.6 One deﬁnition for the method is:
☛ ✟
public OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
player = 2 ;
}
✡ ✠
SOLUTION 3.7 The following would be displayed on the screen:
☛ ✟
1
20
f a l s e
✡ ✠
SOLUTION 3.8 One deﬁnition for the method is:
☛ ✟
public i n t getMoves ( )
{ return nMoves ;
}
✡ ✠
SOLUTION 3.9 One deﬁnition for the method is:
☛ ✟
public boolean playerOneIsNext ( )
{ return ( player == 1 ) ;
}
✡ ✠
SOLUTION 3.10 See Figure 3.21.isDone

return
"Not Done"return
"Done"True False
exit method exit method
FIGURE 3.21 Flowchart of the
if-else version of the getStatus()
method. SOLUTION 3.11
☛ ✟
i f( isHeavy == true )
System . out . p r i n t l n ( ”Heavy” ) ;
else ; // E r r o r ( r e m o v e t h i s s e m i c o l o n )
System . out . p r i n t l n ( ” Light ” ) ;
i f( isLong == true )
System . out . p r i n t l n ( ”Long” )
else // E r r o r ( e n d l i n e a b o v e w i t h s e m i c o l o n )
System . out . p r i n t l n ( ” Short ” ) ;
✡ ✠
CHAPTER 3 •Exercises 143
SOLUTION 3.12
☛ ✟
public S t r i n g getPlayerName ( )
{ i f( player == 1)
return ”Ann” ;
else i f ( player == 2)
return ” B i l l ” ;
else i f ( player == 3)
return ” Cal” ;
else
return ” Error ” ;
}
✡ ✠
SOLUTION 3.13 When passing an argument for a primitive type, a copy of the
argument’s value is passed. The actual argument cannot be chan ged inside the
method. When passing a reference to an object, the object can be c hanged within
the method.
SOLUTION 3.14
☛ ✟
public i n t sumCubes ( i n t min , i n t max)
{
i n t num = min ;
i n t sum = 0 ;
while (num<= max) {// W h i l e num <= max
sum = sum + num ∗num∗num; // Add c u b e o f num t o sum
num = num + 1 ; // Add 1 t o num
}// w h i l e
return sum ; // R e t u r n t h e sum
}
✡ ✠
EXERCISES EXERCISE 3.1 Fill in the blanks in each of the following sentences:
a. When two different methods have the same name, this is an exa mple of
.
b. Methods with the same name are distinguished by their .
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.c. A method that is invoked when an object is created is known as a
method.
d. A method whose purpose is to provide access to an object’s instanc e variables
is known as an method.
e. Aboolean value is an example of a type.
f. AOneRowNim variable is an example of a type.
g. A method’s parameters have scope.
h. A class’s instance variables have scope.
i. Generally, a class’s instance variables should have access.
j. The methods that make up an object’s interface should have access.
k. A method that returns no value should be declared .
144 CHAPTER 3 •Methods: Communicating with Objects
l. Java’s if statement and if-else statement are both examples of control
structures.
m. An expression that evaluates to either true orfalse is known as a .
n. In an if-else statement, an else clause matches .
o. The ability to use a superclass method in a subclass is due to J ava’s
mechanism.
p. The process of redeﬁning a superclass method in a subclass is k nown as
the method.
EXERCISE 3.2 Explain the difference between the following pairs of concepts:
a.Parameter and argument .
b.Method deﬁnition and method invocation .
c.Local scope and class scope .
d.Primitive type and reference type .
e.Access method and constructor method .
EXERCISE 3.3 Translate each of the following into Java code:
a. If b1 is true, then print “one”; otherwise, print “two”.
b. If b1 is false and if b2 is true, then print “one”; otherwise, p rint “two”.
c. If b1 is false and if b2 is true, then print “one”; otherwise, p rint “two”, or print
“three”.
EXERCISE 3.4 Identify and ﬁx the syntax errors in each of the following:
a.
☛ ✟
i f( isWalking == true ) ;
System . out . p r i n t l n ( ”Walking” ) ;
else
System . out . p r i n t l n ( ”Not walking ” ) ;
✡ ✠
b.
☛ ✟
i f( isWalking )
System . out . p r i n t l n ( ”Walking” )
else
System . out . p r i n t l n ( ”Not walking ” ) ;
✡ ✠
c.
☛ ✟
i f( isWalking )
System . out . p r i n t l n ( ”Walking” ) ;
else
System . out . p r i n t l n ( ”Not walking ” )
✡ ✠
d.
☛ ✟
i f( isWalking = f a l s e )
System . out . p r i n t l n ( ”Walking” ) ;
else
System . out . p r i n t l n ( ”Not walking ” ) ;
✡ ✠
CHAPTER 3 •Exercises 145
EXERCISE 3.5 For each of the following, suppose that isWalking istrue
andisTalking isfalse (ﬁrst draw a ﬂowchart for each statement and then
determine what would be printed by each statement):
a.
☛ ✟
i f( isWalking == f a l s e )
System . out . p r i n t l n ( ”One” ) ;
System . out . p r i n t l n ( ”Two” ) ;
✡ ✠
b.
☛ ✟
i f( isWalking == true )
System . out . p r i n t l n ( ”One” ) ;
System . out . p r i n t l n ( ”Two” ) ;
✡ ✠
c.
☛ ✟
i f( isWalking == f a l s e )
{
System . out . p r i n t l n ( ”One” ) ;
System . out . p r i n t l n ( ”Two” ) ;
}
✡ ✠
d.
☛ ✟
i f( isWalking == f a l s e )
i f( i s T a l k i n g == true )
System . out . p r i n t l n ( ”One” ) ;
else
System . out . p r i n t l n ( ”Two” ) ;
else
System . out . p r i n t l n ( ” Three ” ) ;
✡ ✠
EXERCISE 3.6 Show what the output would be if the following version of
main() were executed:
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] )
{
System . out . p r i n t l n ( ”main ( ) i s s t a r t i n g ” ) ;
OneRowNim game1 ;
game1 = new OneRowNim ( 2 1 ) ;
OneRowNim game2 ;
game2 = new OneRowNim ( 8 ) ;
game1 . t a k e S t i c k s ( 3 ) ;
game2 . t a k e S t i c k s ( 2 ) ;
game1 . t a k e S t i c k s ( 1 ) ;
game1 . report ( ) ;
game2 . report ( ) ;
System . out . p r i n t l n ( ”main ( ) i s f i n i s h e d ” ) ;
}
✡ ✠
146 CHAPTER 3 •Methods: Communicating with Objects
EXERCISE 3.7 Determine the output of the following program:
☛ ✟
public c l a s s Mystery
{
public S t r i n g myMethod( S t r i n g s )
{
return (” Hello ” + s ) ;
}
public s t a t i c void main ( S t r i n g argv [ ] )
{
Mystery mystery = new Mystery ( ) ;
System . out . p r i n t l n ( mystery . myMethod( ” dolly ” ) ;
}
}
✡ ✠
EXERCISE 3.8 Write a boolean method—a method that returns a boolean —
that takes an int parameter and converts the integers 0 and 1 into false and
true , respectively.
EXERCISE 3.9 Deﬁne an int method that takes a boolean parameter. If the
parameter’s value is false , the method should return 0; otherwise, it should
return 1.
EXERCISE 3.10 Deﬁne a void method named hello that takes a single
boolean parameter. The method should print “Hello” if its parameter is t rue;
otherwise, it should print “Goodbye”.
EXERCISE 3.11 Deﬁne a method named hello that takes a single boolean
parameter. The method should return “Hello” if its parameter is true; otherwise it
should return “Goodbye”. Note the difference between this method and the one
in the previous exercise. This one returns a String . That one was a void method.
EXERCISE 3.12 Write a method named hello that takes a single String pa-
rameter. The method should return a String that consists of the word “Hello”
concatenated with the value of its parameter. For example, if you call this method
with the expression hello("dolly") , it should return “hello dolly”. If you call
it with hello("young lovers wherever you are") , it should return “hello
young lovers wherever you are”.
EXERCISE 3.13 Deﬁne a void method named day1 that prints “a partridge in a
pear tree”.
EXERCISE 3.14 Write a Java application program called TwelveDays that
prints the Christmas carol “Twelve Days of Christmas.” For this version, write a
void method named intro() that takes a single String parameter that gives the
day of the verse and prints the intro to the song. For example, intro("first")
should print, “On the ﬁrst day of Christmas my true love gave to me ”. Then write
methods day1() ,day2() , and so on, each of which prints its version of the verse.
Then write a main() method that calls the other methods to print the whole song.
EXERCISE 3.15 Deﬁne a void method named verse that takes two String
parameters and returns a verse of the Christmas carol “Twelve D ays of Christ-
mas.” For example, if you call this method with verse("first", "a
partridge in a pear tree") , it should return, “On the ﬁrst day of Christ-
mas my true love gave to me, a partridge in a pear tree”.
CHAPTER 3 •Exercises 147
EXERCISE 3.16 Deﬁne a void method named permute , which takes three
String parameters and prints out all possible arrangements of the thre e strings.
For example, if you called permute("a", "b", "c") , it would produce the
following output: abc, acb, bac, bca, cab, cba, with each permut ation on a separate
line.
EXERCISE 3.17 Design a method that can produce limericks given a bunch of
rhyming words. That is, create a limerick template that will t ake any ﬁve words
or phrases and produce a limerick. For example, if you call
☛ ✟
l i m e r i c k ( ” Jones ” ,” stones ” ,” rained ” ,” pained ” ,”bones” ) ;
✡ ✠
your method might print (something better than)
☛ ✟
There once a person named Jones
Who had a great l i k i n g for stones ,
But whenever i t rained ,
Jones ’ expression was pained ,
Because stones weren ’ t good for the bones .
✡ ✠
For each of the following exercises, write a complete Java applica tion program:
EXERCISE 3.18 Deﬁne a class named Donor that has two instance variables,
the donor’s name and rating, both of which are String s. The name can
be any string, but the rating should be one of the following values: “high,”
“medium,” or “none.” Write the following methods for this class: a c onstruc-
tor,Donor(String,String) , that allows you to set both the donor’s name and
rating; and access methods to set and get both the name and ratin g of a donor.
EXERCISE 3.19 Challenge. Deﬁne a CopyMonitor class that solves the fol-
lowing problem. A company needs a monitor program to keep track of whe n a
particular copy machine needs service. The device has two imp ortant (boolean)
variables: its toner level (too low or not) and whether it has print ed more than
100,000 pages since its last servicing (it either has or has not ). The servicing rule
that the company uses is that service is needed when either 100 ,000 pages have
been printed or the toner is too low. Your program should contain a meth od that
reports either “service needed” or “service not needed” based on the machine’s
state. (Pretend that the machine has other methods that keep tr ack of toner level
and page count.)
EXERCISE 3.20 Challenge. Design and write an OldMacdonald class that
sings several verses of “Old MacDonald Had a Farm.” Use methods t o generalize
the verses. For example, write a method named eieio() to “sing” the “E I E I O”
part of the verse. Write another method with the signature hadAnX(String s) ,
which sings the “had a duck” part of the verse, and a method withA(String
sound) to sing the “with a quack quack here” part of the verse. Test your class by
writing a main() method.
ADDITIONAL EXERCISES
EXERCISE 3.21 Suppose you have an Object A , with public methods a(),
b(), and private method c(). And suppose you have a subclass of Anamed B
with methods named b(),c() andd(). Draw a UML diagram showing the rela-
tionship between these two classes. Explain the inheritance relationships between
them and identify those methods that would be considered polymorph ic.
148 CHAPTER 3 •Methods: Communicating with Objects
EXERCISE 3.22 Consider the deﬁnition of the class C. Deﬁne a subclass of C
named Bthat overrides method m1() so that it returns the difference between m
andninstead of their sum.
☛ ✟
public c l a s s C{
private i n t m;
private i n t n ;
public C(i n t mIn , i n t nIn ){
m = mIn ;
n = nIn ;
}
public i n t m1( ){
return m +n ;
}
}
✡ ✠
OBJECTIVES
After studying this chapter, you will
•Understand the importance of the user interface.
•Know how to use a simple command-line interface.
•Be able to program and use a simple Graphical User Interface (G UI).
•Understand the concept of event-driven programming.
•Know how to program and use a Java applet.
OUTLINE
4.1 Introduction
4.2 The User Interface
4.3 A Command-line Interface
4.4 A Graphical User Interface (GUI)
4.5 Case Study: The One Row Nim Game
4.6 From the Java Library: java.io.File and ﬁle input (Option al)
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 4
Input/Output: Designing
the User Interface
149
150 CHAPTER 4 •Input/Output: Designing the User Interface
4.1 Introduction
One of the most important parts of learning a programming lan guage is
learning how to program an application to accept input and pr oduce out-
puts (I/O). Computers wouldn’t be very useful if we could not g ive them
data to manipulate and compute, and if we were not able to read or un-
derstand the results that they produce. In general, a compute r program’s
input and output capabilities are known collectively as its user interface.
Aninput operation is any action that transfers data from the user to
the computer’s main memory via one of the computer’s input de vices.
Anoutput operation is any action that transfers data from the computer’s
main memory to one of the computer’s output devices.
In this chapter, we will introduce three simple user interfac es: a
command-line interface and two graphical user interfaces (GUIs). These
interfaces can be used interchangeably with the material in most of the
subsequent chapters. Indeed, one of the most important desig n princi-
ples that we emphasize in this chapter is that the user interf ace should be
designed to function independently of the computational ta sk. In other
words, it should be possible to take an application, such as a computer
game, and design it so that it can be used with a variety of diff erent user
interfaces.
4.2 The User Interface
The user interface is that part of the program that handles th e input and User interface
output interactions between the user and the program. As an i nterface,
it limits or constrains the manner in which the user can inter act with the
program.
Computer programs are just one of the many things that require a user
interface. Virtually every device we use has one. For exampl e, consider
again the difference between the user interface of a digital versus an ana-
log watch. On a digital watch, you have a display that tells yo u the time
to the exact hour, minute, and second. On an analog watch, one with a
sweep second hand, the time can never be displayed to the exac t second.
Similarly, on a digital watch there are buttons that let you s et the time to
the exact hour, minute, and second. On an analog watch, there is a small
wheel that allows you to set the time only approximately. Thu s, the user
interface constrains the kinds of interactions that are pos sible between the
user and the device.
With regard to our Java programs, one way to divide up the labo r is to
distinguish between the user interface and the computation al functions. Division of labor
The role of the user interface is to transmit data back and for th between the
user and the program. The role of the computational part of th e program
is to perform some kind of computation, in the broad sense of t hat term.
The computation might be to play a game, or calculate a square root, or
monitor a hospital patient. Figure 4.1 provides a generic pi cture of the
relationship between the user interface and the computatio nal object.
In this chapter we focus our attention on the user interface si de of the
relationship shown in Figure 4.1. In subsequent chapters we w ill focus
more on the computational side of the relationship. What we de sire is an
SECTION 4.3 •A Command-Line Interface 151
Figure 4.1: The user interface
transmits data back and forth be-
tween the user and the program’s
computational objects.
approach that lets us combine a computational object with any one of the
three different kinds of user interfaces.
JAVA EFFECTIVE DESIGN The User Interface Module Separating
the user interface from the computational object is a good way to
divide up the labor in programs that perform I/O.
4.3 A Command-Line Interface
A command-line interface is perhaps the simplest, and most o ld-
fashioned, way to design the interaction between a user and a program.
According to this approach, user input is taken from the keyb oard, and
the program’s output is displayed on some kind of console (Fi g. 4.2).
Figure 4.2: A command-line user
interface.
The command-line approach might also be called console interface . In
the early days of computers, before we had graphics-based co mputer
monitors capable of displaying multiple windows, the conso le was the
entire computer display. For today’s computers the console might be a
window provided by your programming environment, as in Figu re 4.3.
In Chapter 3 we described how to use the System.out.print()
andSystem.out.println() methods to output strings to the console.
That takes care of the output side of command-line interface . The more
challenging task is managing the input-side of the interfac e.
152 CHAPTER 4 •Input/Output: Designing the User Interface
Figure 4.3: The Java console win-
dow.
In Java, input and output is handled by objects that are called streams .
You can think of a stream as a kind of pipe through which data ﬂow
(Fig. 4.4). An input stream carries data from some kind of input device, Streams
such as a keyboard or network connection or a ﬁle, to the progr am’s main
memory. An output stream carries data from the program’s memory to
some kind of output device, such as a printer or a ﬁle.
Figure 4.4: Input and output
streams.
Each Java program has three standard streams available to it at startup:
System.in ,System.out , andSystem.err .System.in is a prede-
ﬁned input stream that is typically associated with the keyb oard (Fig. 4.4).
That is, it carries data from the keyboard to the program. System.out
andSystem.err are both output streams typically associated with the
console. They both carry data from the program to the console . The dif-
ference is simply that System.out is used for normal program output
andSystem.err is used to output error messages.
4.3.1 Using a BufferedReader to Input Strings from the
Keyboard
We will use a BufferedReader object to handle data input from the
keyboard. As its name implies, the BufferedReader class performs
buffered input. A buffer is a portion of main memory where input is held
until it is needed by the program. Using a buffer between the k eyboard Buffered input
and the program allows you to use the Backspace key to delete a char-
acter. When you hit the Enter key, any characters that you dele ted will
be ignored when the program retrieves characters from the in put buffer.
If the user’s input were not buffered in this way, it would cont ain ev-
SECTION 4.3 •A Command-Line Interface 153
ery keystroke, including the Backspaces, and then it would b e up to the
program to eliminate the characters that were supposed to be deleted.
Figure 4.5: The BufferedRead-
erclass.
Figure 4.5 provides a UML diagram of the BufferedReader class and
shows its relationship to other the classes that will be used for keyboard
input . Note that along with InputStreamReader ,BufferedReader
is one of several subclasses of the Reader class. As the diagram
shows, BufferedReader has two important methods. Its constructor
method takes a Reader parameter, which means that when we create a
BufferedReader we must provide it with a reference to some kind of
Reader object. To perform keyboard input, we want to provide a refer-
ence to an object that can read System.in , the standard input stream.
As the ﬁgure shows, InputStreamReader has a constructor that allows
it to read an InputStream . Therefore, to construct a BufferedReader
that will read System.in we use the following statement:
☛ ✟
BufferedReader input = new BufferedReader
(new InputStreamReader ( System . in ) ) ;
✡ ✠
In this statement we are actually creating two objects. We ﬁrst create an
InputStreamReader , giving it a reference to System.in . We then pass
that object to a BufferedReader . The result is a cooperation between
two objects that enables us to do buffered reading of the keybo ard.
By creating a BufferedReader in this way, whenever we use its
readLine() method, it will read a line of characters from the keyboard.
For example, having created a BufferedReader named input , the fol-
lowing code segment will read one line of input and assign it t o the
String variable named inputString .
☛ ✟
S t r i n g i n p u t S t r i n g = input . readLine ( ) ;
✡ ✠
When the program encounters the readLine() expression, it will wait Keyboard input
for the user to hit the Enter key. It will then input whatever th e user
154 CHAPTER 4 •Input/Output: Designing the User Interface
typed, minus any characters that were Backspaced over, into theString
variable.
JAVA LANGUAGE RULE Keyboard Input. The
BufferedReader.readLine() method allows the user to
backspace over errors during keyboard input.
4.3.2 Inputting Numbers from the Keyboard
As the previous section showed, we can use a BufferedReader object
to input String s from the keyboard. In Java, all keyboard input is repre-
sented as String s. However, what if we want to input numbers? The an-
swer is that we have to extract numbers from the input strings . To do this,
Java provides us two special classes, known as wrapper class es:Integer
andDouble .
Awrapper class contains methods for converting primitive data into Wrapper classes
objects and for converting data from one type to another. The Integer
class contains the parseInt() method, which extracts an int from its
String argument. For example, in the following usage, the string ”5 5” is
converted into the number 55:
☛ ✟
i n t m = I n t e g e r . p a r s e I n t ( ”55” ) ;
✡ ✠
Similarly, the Double class contains the parseDouble() method, which
extracts a double value from its parameter. In this example, the number
55.2 is extracted from the string ”55.2”:
☛ ✟
double num = Double . parseDouble ( ” 5 5 . 2 ” ) ;
✡ ✠
If we are writing a program that requires us to input numbers fr om
the keyboard, then assuming we have created a BufferedReader ob-
ject named input , we can use these methods in combination with the
readLine() method, to input and process numbers. For example, this
code segment calculates a runner’s race pace:
☛ ✟
S t r i n g i n p u t S t r i n g = new S t r i n g ( ) ;
System . out . p r i n t l n ( ”How many t o t a l miles did you run ? ” ) ;
i n p u t S t r i n g = input . readLine ( ) ; // I n p u t a S t r i n g }
double miles = Double . parseDouble ( i n p u t S t r i n g ) ; // C o n v e r t
System . out . p r i n t l n ( ”How many minutes did i t take you? ” ) ;
i n p u t S t r i n g = input . readLine ( ) ; // I n p u t a n o t h e r S t r i n g
double minutes = Double . parseDouble ( i n S t r i n g ) ;
// C o n v e r t
System . out . p r i n t l n ( ”Your average pace was ” +
minutes/miles + ” minutes per mile ” ) ;
✡ ✠
SECTION 4.3 •A Command-Line Interface 155
Notice how we included prompts in this example so that the use r knows
what type of input is expected. Designing appropriate promp ts is an
important aspect of designing a good user interface.
JAVA EFFECTIVE DESIGN Prompting. In a well-designed user
interface, prompts should be used to guide the user through t he input
process.
4.3.3 Designing a Keyboard Reader Class
Now that we have introduced the library classes and methods t hat we
will use for command-line input, lets design a class to encap sulate these
functions. We want a class that will use a BufferedReader to read any
kind of data—strings, integers, or real numbers—from keyboar d. We also
want this class to hide some of the messy details involved in p erforming
keyboard input.
Figure 4.6: Design of the
KeyboardReader class.
Figure 4.6 presents the design of KeyboardReader class. Note that
instances of this class will use a BufferedReader object to perform
the actual keyboard input. That’s why we need a private insta nce vari-
able of type BufferedReader . The constructor method will create a
BufferedReader , which will then be used whenever a read operation
is requested. Note that the KeyboardReader() has ﬁve public meth-
ods. The getKeyboardInput() method returns a String . This is the
method we will call when we just want to get the string that the u ser typed
from the keyboard. The getKeyboardInteger() method returns an
int value. This is the method we will call when we want an integer f rom
the keyboard. Similarly, the getKeyboardDouble() method returns a
double . This is the method we will call when we want to input a ﬂoating
point value from the keyboard. Finally, the prompt() anddisplay()
methods will be used to perform two other important tasks of a user in-
terface: that of prompting the user and that of displaying th e program’s
output.
156 CHAPTER 4 •Input/Output: Designing the User Interface
The following code segment illustrates how we will use a Keyboard-
Reader object to input an integer:
☛ ✟
KeyboardReader cmdline = new KeyboardReader ( ) ;
i n t m = cmdline . getKeyboardInteger ( ) ;
✡ ✠
All we need to do is create an instance of the KeyboardReader and ask
it to get an integer for us. This greatly simpliﬁes the work we would have
to do when we want to perform keyboard input.
Note that Figure 4.6 lists a private method named readKeyboard()
in theKeyboardReader class. This is the method that does the actual
work of reading data from the keyboard. Because it is private , it can only
be called by the other methods in KeyboardReader . It cannot be called
by other classes. The reason we make it private is to hide it, a nd the messy Private helper method
details of performing keyboard input, from other classes.
One of those messy details is the fact that whenever I/O is perf ormed,
it is possible for things to go wrong. The possibility of erro rs occurring
applies to all forms of I/O, not just keyboard I/O. For example, w hen a
program is trying to read a ﬁle, the ﬁle might be missing. Or wh en trying
to download a web page, the Internet connection might malfunc tion.
Because these types of external errors are possible, Java re quires that
whenever a program performs certain types of I/O, it must watc h out
for certain kinds of error conditions, known as exceptions . Exceptions are
covered in Chapter 11, so we will not attempt to cover them her e. Instead, I/O exceptions
we will design the readKeyboard() method to take care of this detail
for us.
JAVA LANGUAGE RULE Exceptions. Java I/O methods require
that programs check for certain error conditions during inp ut.
Figure 4.7 gives the full implementation (for now) of the Keyboard-
Reader class. Lets go through it line by line. The ﬁrst thing to no-
tice is the use of the import statement. Recall that importing a Java
package enables us to refer to elements in the package by thei r short
names ( BufferedReader ), rather than by their fully qualiﬁed names
(java.io.BufferedReader ).
Next notice how we create a BufferedReader object in the
KeyboardReader() constructor:
☛ ✟
reader = new BufferedReader
(new InputStreamReader ( System . in ) ) ;
✡ ✠
The resulting reader object will persist as long as our KeyboardReader
object exists and can be used for all subsequent input operati ons.
Next notice the deﬁnition of the readKeyboard() method. It calls
the inherited readLine() method to input a line from the keyboard and
then it returns the line. Note, however, how the call to the readLine()
method is embedded in a try...catch block. This is one way to handle
the possibility that an exception might occur during the inp ut operation.
Java requires that our program do something to address the po ssibility
SECTION 4.3 •A Command-Line Interface 157
☛ ✟
import java . io . ∗;
public c l a s s KeyboardReader
{ private BufferedReader reader ;
public KeyboardReader ( ) {
reader = new BufferedReader
(new InputStreamReader ( System . in ) ) ;
}
public S t r i n g getKeyboardInput ( )
{ return readKeyboard ( ) ;
}
public i n t getKeyboardInteger ( )
{ return I n t e g e r . p a r s e I n t ( readKeyboard ( ) ) ;
}
public double getKeyboardDouble ( )
{ return Double . parseDouble ( readKeyboard ( ) ) ;
}
public void prompt ( S t r i n g s )
{ System . out . p r i n t ( s ) ;
}
public void display ( S t r i n g s )
{ System . out . p r i n t ( s ) ;
}
private S t r i n g readKeyboard ( )
{ S t r i n g l i n e = ””;
t r y
{ l i n e = reader . readLine ( ) ;
}catch ( IOException e )
{e . p r i n t S t a c k T r a c e ( ) ;
}
return l i n e ;
}
}
✡ ✠
Figure 4.7: Deﬁnition of the KeyboardReader class.
of an I/O exception, and as we will learn in Chapter 11, there ar e other
designs that we might have used here. The primary advantage o f doing
it this way is that we can hide this language detail from the re st of the
program. The rest of the program—and any other programs that u se the
KeyboardReader class—will not have to worry about this exception is-
sue. They can just ask the KeyboardReader to get them a string or an
integer and it will deliver the goods.
Next, notice how the public input methods are deﬁned. The
getKeyboardInput() method just returns the line that it gets by call-
ingreadKeyboard() . ThegetKeyboardInteger() method also calls
readKeyboard() , but instead of just returning the line, it extracts an
integer from it and returns the integer. The getKeyboardDouble()
method works the same way.
Finally, notice how the public output methods are deﬁned. Bo th the
prompt() anddisplay() methods take a single String parameter
158 CHAPTER 4 •Input/Output: Designing the User Interface
and do exactly the same thing–they merely print their string . So why do
we have two methods when one will sufﬁce? The answer is that th ese
methods encapsulate important and distinct user-interfac e functions—
prompting the user and displaying output—that just happen to b e imple-
mented in exactly the same way in this case. As we will see when we de-
sign our GUI interface, we will use completely different obje cts to prompt
the user and display output. So, despite their similarities , it is important
that we distinguish the task of prompting the user from the mo re general
task of displaying output.
4.3.4 Designing a Command-Line Interface
Now that we have deﬁned a special class for performing keyboa rd input,
we now show how it can be used as a user interface in cooperatio n with
the other objects that make up a program. As described in Figur e 4.1,
the user interface will serve as an intermediary between the user and
some type of computational object. Although our command-lin e interface
should work with any application, no matter how complex, we b egin with
a very simple computational problem. This will allow us to fo cus on the
user interface.
Let’s design a program that prompts the user for his or her nam e and
then says hello. Thus, the program’s I/O should look like this :
☛ ✟
Hi , please input your name here >Kim
Hi Kim , nice to meet you .
✡ ✠
In the design we use there will be two primary objects involved. One
will serve as the user interface. This will be our KeyboardReader . A
second object will serve as the computational object. In this ca se it will
“compute” an appropriate greeting. It will serve contain the main()
method and will encapsulate the algorithm for this applicat ion. It will
use aKeyboardReader to handle its I/O needs.
The main advantage of this division of labor is that it enable s us to use
theKeyboardReader , as is, with virtually any Java application. More-
over, despite its simplicity, our computational object in th is example can
serve as a template for future programs.
JAVA EFFECTIVE DESIGN Modularity. By designing the user
interface as a self-contained module, we can use it with just a bout any
application.
Figure 4.8 provides the details the design we wish to impleme nt. Note
thatGreeterApp contains an instance variable for a KeyboardReader .
This will enable it to use the KeyboardReader whenever it needs to per-
form keyboard input. By giving GreeterApp amain() method, we al-
low it to be the main class for our application. Its run() method will con-
tain the algorithm that controls the application, and its greet() method
will handle the task of greeting the user.
The full implementation of the GreeterApp class is shown in
Figure 4.9. It begins by declaring an instance variable for th e
SECTION 4.3 •A Command-Line Interface 159
Figure 4.8: Using Keyboard-
Reader as the user interface.
☛ ✟
public c l a s s GreeterApp
{ private KeyboardReader reader ;
public GreeterApp ( )
{ reader = new KeyboardReader ( ) ;
}// G r e e t e r A p p ( )
public void run ( )
{ S t r i n g name = ””;
reader . prompt ( ” Please input your name here >”) ;
name = reader . getKeyboardInput ( ) ;
reader . display ( g r e e t (name ) + ”\n”) ;
}// r u n ( )
public S t r i n g g r e e t ( S t r i n g name )
{ return ”Hi ” + name + ” nice to meet you . ” ;
}// g r e e t ( )
public s t a t i c void main ( S t r i n g args [ ] )
{ GreeterApp app = new GreeterApp ( ) ;
app . run ( ) ;
}
}// G r e a t e r A p p
✡ ✠
Figure 4.9: Deﬁnition of the GreeterApp class.
KeyboardReader , which is instantiated in the constructor method. This
givesGreeterApp a way to refer directly to the user interface whenever it
needs keyboard input. The run() method encapsulates the application’s
algorithm. Notice how it uses the KeyboardReader to prompt the user,
to input the user’s name, and then to display the greeting. Fi nally, the
main() method serves to create an instance of the computational obje ct
and calls its run() method.
To re-cap, we have designed a simple command-line interface that can
be used, with minor changes, for virtually any programming t ask in sub-
sequent chapters. Before moving on, it may be helpful to touc h on some
of the important object-oriented principles that went into o ur design.
•Divide-and-conquer: We see the usefulness of dividing a pro gram
into separate objects, one to handle the computations requir ed by
the application, and one to handle the user interface.
160 CHAPTER 4 •Input/Output: Designing the User Interface
•Encapsulation: The classes we designed encapsulate just the in-
formation and behavior that is necessary to perform their sp eciﬁc
roles.
•Information hiding: We use a private method to hide certain me ssy
implementation details from other parts of the program.
•Generality and Extensibility: We have developed a design th at is
general enough that it can be extended to other applications .
SELF-STUDY EXERCISES
EXERCISE 4.1 Java’sMath class has a static method that will gener-
ate a random number between 0 and 0.99999999—that is, between 0 and
1, not including 1. By using simple arithmetic, we can genera te random
numbers between any two values. For example, the following s tatement
assigns a random integer between 1 and 100 to the variable:
☛ ✟
secretNumber = 1 + ( i n t) ( Math . random ( ) ∗1 0 0 ) ;
✡ ✠
Given this statement, design and implement an application t hat will play
the following guessing game with the user. The computer gene rates a ran-
dom number between 1 and 100 and then lets the user guess the nu mber,
telling the user when the guess is too high or too low. Note tha t for this
problem, the user will have to input integers at the keyboard .
4.4 A Graphical User Interface (GUI)
While command-line interfaces are useful, one of the great ad vantages of
the Java language is that its extensive class library makes i t relatively easy
to develop applications that employ Graphical User Interfac es (GUIs).
GUIs have been around now for many years, since the production of the
Macintosh in the early 1980s. Today nearly all the personal c omputing
applications are GUI-based. Therefore, it is important that beginning pro-
grammers be able design and write programs that resemble, al beit on a
simpler scale, those programs that they use every day. Among other ben-
eﬁts, developing the ability to write GUI programs, like the ones everyone
uses today, will make it easier for you to show off your work to others,
which might help motivate further interest in learning to pr ogram.
In this and subsequent sections, we will develop an extensibl e GUI
model that can be used with either a Java application or apple t. By ex-
tensible we mean a model that can be easily adapted and used in a wide
variety of programs. GUI programming involves a computatio nal model
known as event-driven programming , which means that GUI programs
react to events that are generated mostly by the user’s inter actions with Event-driven programming
elements in the GUI. Therefore, we will have to learn how to use Java’s
event model to handle simple events.
Given that this is our ﬁrst look at some complex topics, we wil l keep
the discussion as simple as possible. This means we will dela y discussion
of certain issues, which we take up in more depth in Chapter 13 .
SECTION 4.4 •A Graphical User Interface (GUI) 161
Figure 4.10: Various GUI com-
ponents from the javax.swing
package. [Artwork: We need to
label the components.]
4.4.1 Java’s GUI Components
The Java library comes with two separate but interrelated pa ckages of GUI
components, the older java.awt package and the newer javax.swing
package. For the most part, the Swing classes supersede the AWT
classes. For example, the java.awt.Button class is superseded by the
javax.swing.JButton class, and the java.awt.TextField class is
superseded by the javax.swing.JTextField class. As these examples
show, the newer Swing components add an initial ’J’ to the nam es of their
corresponding AWT counterparts.
Figure 4.10 illustrates how some of the main components appe ar in a
GUI interface. As shown there, a JLabel is simply a string of text dis-
played on the GUI, used here as a prompt. A JTextField is an input
element that can hold a single line of text. In this case, the us er has in-
put his name. A JTextArea is an output component that can display
multiple lines of text. In this example, it displays a simple g reeting. A
JButton is a labeled control element , which is an element that allows
the user to control the interaction with the program. In this e xample, the
user will be greeted by the name input into the JTextField , whenever
theJButton is clicked. As we will learn, clicking on the JButton causes
an event to occur, which leads the program to take the action o f displaying
the greeting. Finally, all of these components are containe d in aJFrame ,
which is a top-level container. A container is a GUI component that can
contain other GUI components.
The Swing classes are generally considered to be superior to their AWT
counterparts. For one thing, Swing components use a sophist icated object- Model-view-controller (MVC) archi-
tecture oriented design known as the model-view-controller (MVC) architecture,
which gives them much greater functionality than their AWT co unter-
parts. For example, whereas an AWT Button can only have a string as its
label, a Swing JButton can use an image as a label. (See Chapter 13 for a
detailed discussion of the MVC architecture.)
Second, Swing components are written entirely in Java which makes
them more portable and enables them to behave the same way reg ardless
162 CHAPTER 4 •Input/Output: Designing the User Interface
of the operating system on which they are run. Because of thei r portability,
Swing components are considered lightweight . By contrast, AWT classes
use routines that are implemented in the underlying operati ng system and Swing portability
are therefore not easily portable. Hence, they are considere dheavyweight
components. Whereas a Swing JButton should look and act the same
way regardless of platform, an AWT Button would have a different im-
plementation, and hence a different look and feel, on a Macin tosh and on
a Windows system. In this book, we will use the new Swing classe s in our
programs.
4.4.2 Class Inheritance: Extending a Superclass
As you recall from Chapter 0, class inheritance is the mechan ism by which
a class of objects can acquire ( inherit ) the methods and variables of its su- Inheritance
perclasses. Just as a horse, by membership in the class of hor ses, inherits
those attributes and behaviors of a mammal, and, more genera lly, those of
an animal, a Java subclass inherits the variables and method s of its super-
classes. We sometimes lump together an object’s attributes a nd behaviors Functionality
and refer to them collectively as its functionality . So we say that an object
of a subclass inherits the functionality of all of its superc lasses.
By the same token, just as a horse and a cow extend their mammali an
attributes and behaviors in their own special ways, a Java su bclass ex-
tends the functionality of its superclasses in its own speci al way. Thus, a
subclass specializes its superclass.
In Chapter 3, we showed how all classes in the Java hierarchy in herit
thetoString() method from the Object class. The lesson there was
that an object in a subclass can either use or override any public method
deﬁned in any of its superclasses. In order to implement GUI pr ograms,
we need to look at another way to employ inheritance. In partic ular, we
need to learn how to deﬁne a new class by extending an existing class.
We noted in Chapter 2 that unless a class is explicitly deﬁned as a sub-
class of some other class it is considered implicitly to be a d irect subclass
ofObject . Thus, the GreeterApp class that we deﬁned earlier in this
chapter is a subclass of Object . We can make the relationship between
GreeterApp andObject explicit by using the extends keyword when
we deﬁne the GreeterApp class:
☛ ✟
public c l a s s GreeterApp extends Object {. . .}
✡ ✠
Thus, the extends keyword is used to specify the subclass/superclass The isa relationship
relationships that hold in the Java class hierarchy. We some times refer to
the subclass/superclass relationship as the isarelationship, in the sense
that a horse isamammal, and a mammal isaanimal. Thus, the extends
keyword is used to deﬁne the isarelationship among the objects in the
Java class hierarchy.
Atop-level container is a GUI container that cannot be added to
another container; it can only have components added to it. F ig- Top-level container
ure 13.1 is a class hierarchy that shows the relationships am ong
some of the top-level Swing and AWT classes. For example, the
javax.swing.JFrame class, which represents a top-level window, is
SECTION 4.4 •A Graphical User Interface (GUI) 163
java.appletjava.awtjava.lang
Object
Component
Container
WindowDialog
PanelJComponentJFrame
JDialog
JAppletjavax.swing
AppletFrameFigure 4.11: Top-level Swing and
AWT classes. [NOTE: REDRAW
JWindow is a subclass of Win-
dow.]
a subclass of java.awt.Frame , and the javax.swing.JApplet is a
subclass of java.applet.Applet . We can see from this ﬁgure that
aJApplet isaApplet and an Applet isaPanel and a Panel isa
Container . These subclass/superclass relationships are created in t heir
respective class deﬁnitions by using the extends keyword as follows:
☛ ✟
public c l a s s JApplet extends Applet {. . .}
public c l a s s Applet extends Panel{. . .}
public c l a s s Panel extends Container {. . .}
✡ ✠
As we will see in the next section, extending a class in this wa y enables us Specialization
to create a new class by specializing an existing class.
4.4.3 Top-level Windows
Referring again to Figure 13.1, notice that all of the Swing c omponents are
subclasses of the AWT Container class. This means that Swing compo-
nents are Container s. They inherit the functionality of the Container
class. So Swing components can contain other GUI components . That is
why aJButton can contain an image.
All GUI programs must be contained inside some kind of top-le vel
container. Swing provides three top-level container class es:JFrame ,
JApplet andJDialog . For our basic GUI, we will use a JFrame as the
top-level window for stand alone applications. We will use a JApplet as
the top-level window for Java applets.
AJFrame encapsulates the basic functionality of a top-level window .Content pane
It has what is called a content pane , to which other Swing components,
such as buttons and text ﬁelds, can be added. Also, it comes wi th enough
164 CHAPTER 4 •Input/Output: Designing the User Interface
Figure 4.12: A simple window.
built-in functionality to respond to certain basic command s, such as when
the user adjusts its size or closes it.
Figure 4.12 shows a simple top-level window as it would be dis played
on the console. This window has a title (”My GUI”). It is 200 pixe ls wide,
150 pixels high, and its top-left corner is located at coordi nates (100,150)
on the console screen. Like in other graphical systems, poin ts on the Java
console always given as an ordered pair, (X, Y) , with the horizontal coordi-
nate, X, listed ﬁrst, followed by the vertical coordinate, Y. The horizontal
x-axis extends positively from left to right, and the vertic al y-axis extends
positively from top to bottom.
The class that created and displayed this window is shown in F ig-
ure 4.13. Note the use of the extends keyword to deﬁne SimpleGUI
☛ ✟
import javax . swing . ∗;
public c l a s s SimpleGUI extends JFrame
{
public SimpleGUI ( S t r i n g t i t l e )
{ s e t S i z e ( 2 0 0 , 1 5 0 ) ;
s e t L o c a t i o n ( 1 0 0 , 1 5 0 ) ;
s e t T i t l e ( t i t l e ) ;
s e t V i s i b l e ( true ) ; // D i s p l a y s t h e J F r a m e
}// S i m p l e G U I ( )
public s t a t i c void main ( S t r i n g args [ ] )
{ new SimpleGUI ( ”My GUI” ) ;
}// m a i n ( )
}// S i m p l e G U I c l a s s
✡ ✠
Figure 4.13: A top-level window with a title.
as a subclass of JFrame . As a subclass, SimpleGUI inherits all of the
functionality of a JFrame (Fig. 4.14) . That is, it can contain other GUI
components. It knows how to resize and close itself, and so on. The rea-
son we want to deﬁne a subclass of JFrame , rather than just use a JFrame
SECTION 4.4 •A Graphical User Interface (GUI) 165
instance, is because we want eventually to give our subclass additional
functionality that is specialized for our application.
JAVA EFFECTIVE DESIGN Specialization. By creating a subclass of
JFrame we can specialize its functionality for our application.
Note how SimpleGUI ’smain() program creates an instance of
SimpleGUI by invoking its constructor. There is no need to use a vari-
able here because there are no further references to this obje ct in this class.
However, simply constructing a SimpleGUI will not cause it to appear on
the Java console. For that to happen, it is necessary to give i t a size and to
call its setVisible() method. This is done in the constructor method.
Figure 4.14: SimpleGUI is a sub-
class of JFrame .
The constructor method illustrates how to use some of the met h-
ods inherited from JFrame . Figure 4.14 shows some of the methods
thatSimpleGUI inherits from JFrame . We use the setSize() and
setLocation() methods to set SimpleGUI ’s size and location. We use
thesetTitle() method to set its title. And we use the setVisible()
method to cause it to appear on the console.
4.4.4 GUI Components for Input, Output, and Control
To enable our top-level window to serve as a user interface, i t will be nec-
essary to give it some components. Figure 13.2 provides an ov erview of
some of the main Swing components. Generally, there are thre e types of
components, which correspond to the three main functions of a user in-
terface: input ,output , and control . AJTextField would be an example
of an input component. The user can type text into the text ﬁel d, which
can then be transmitted into the program. A JTextArea is an example
of an output component. The program can display text in the te xt area.
Control components enable the user to control the actions of the program.
166 CHAPTER 4 •Input/Output: Designing the User Interface
Figure 4.15: Swing components.
Object
Component
Container
JLabel
JPanelJScrollPaneJToggleButton
JButton
JMenuItem JMenuJCheckbox
JRadioButton
JTextArea
JTextField JPasswordFieldjava.awtjava.lang
javax.swing
JComponent
JMenuBarJList
JOptionPane
JPopupMenu
JTextComponentAbstractButton
AJButton would be an example of a control component. It can be asso-
ciated with an action that can be initiated whenever the user clicks it. We
might also consider a JLabel to be an output component, because we can
use it to prompt the user as to what type of actions to take.
Let’s begin by creating a simple user interface, one that ena bles us to
perform basic input, output, and control operations with a m inimum of
Swing components. This will allow us to demonstrate the basi c principles
and techniques of user-interface design and will result in a GUI that can
be extended for more sophisticated applications. For this e xample, we
will limit our application to that of simply greeting the use r, just as we
did in designing our command-line interface. That means tha t the user
will be prompted to input his or her name and the program will r espond
by displaying a greeting (Fig. 4.10). We will call our GUI GreeterGUI , to
suggest its interdependence with the same Greeter computational object
that we used with the command-line interface.
For this simple application, our GUI will make use of the foll owing
components:
•AJTextField will be used to accept user input.
•AJTextArea will serve to display the program’s output.
•AJButton will allow the user to request the greeting.
•AJLabel will serve as a prompt for the JTextField .
SECTION 4.4 •A Graphical User Interface (GUI) 167
Figure 4.16: Public methods and
constructors for basic Swing com-
ponents.
Figure 4.16 shows some of the constructors and public method s for the
JTextArea ,JTextField ,JButton , andJLabel components. The fol-
lowing code segments illustrate how to use these constructo rs to create
instances of these components:
☛ ✟
// D e c l a r e i n s t a n c e v a r i a b l e s f o r t h e c o m p o n e n t s
private JLabel prompt ;
private J T e x t F i e l d i n F i e l d ;
private JTextArea display ;
private JButton goButton ;
// I n s t a n t i a t e t h e c o m p o n e n t s
prompt = new JLabel ( ” Please type your name here : ” ) ;
i n F i e l d = new J T e x t F i e l d ( 1 0 ) ; // 1 0 c h a r s w i d e
display = new JTextArea ( 1 0 , 3 0 ) ; // 1 0 r o w s x 3 0 c o l u m n s
goButton = new JButton ( ” Click here f o r a g r e e t i n g ! ” ) ;
✡ ✠
For this example, we use some of the simpler constructors. Th us, we create
aJTextField with a size of 10. That means it can display 10 characters
of input. We create a JTextArea with 10 rows of text, each 30 characters
wide. We create a JButton with a simple text prompt meant to inform
the user of how to use the button.
4.4.5 Adding GUI Components to a Top-Level Window
Now that we know how to create GUI components, the next task is to
add them to the top-level window. A JFrame is a top-level Container
168 CHAPTER 4 •Input/Output: Designing the User Interface
(Fig. 13.1), but instead of adding the components directly t o theJFrame
we have to add them to the JFrame ’s content pane, which is also a
Container .
JAVA LANGUAGE RULE Content Pane. GUI Components cannot
be added directly to a JFrame . They must be added to its content
pane.
Java’sContainer class has several add() methods that can be used to
insert components into the container:
☛ ✟
add ( Component comp) // a d d comp t o e n d o f c o n t a i n e r
add ( Component comp , i n t index ) // a d d comp a t i n d e x
add ( S t r i n g region , Component comp) add comp at region
✡ ✠
The particular add() method to use depends on how we want to arrange
the components in the container. The layout of a container is controlled
by its default layout manager , an object associated with the container that Layout manager
determines the sizing and the arrangement of its contained c omponents.
For a content pane, the default layout manager is a BorderLayout . This
is an arrangement whereby components may be placed in the cen ter of the
pane and along its north, south, east, and west borders (Fig. 13.7.4).
Figure 4.17: Arrangement of com-
ponents in a border layout.
WestNorth
SouthEast Center
Components are added to a border layout by using the add(String
region, Component comp) method, where the String parameter
speciﬁes either ”North,” ”South,” ”East,” ”West,” or ”Cent er.” For exam-
ple, to add the JTextArea to the center of the JFrame we ﬁrst create a
reference to its content pane and we then add the component at its center:
☛ ✟
Container contentPane = getContentPane ( ) ; // G e t p a n e
contentPane . add ( ” Center ” , display ) ; // Add J T e x t A r e a
✡ ✠
One limitation of the border layout is that only one componen t can be
added to each area. This is a problem for our example because w e want
our prompt JLabel to be located right before the JTextField . To get
around this problem, we will create another container, a JPanel , and add
the prompt, the text ﬁeld, and the goButton to it. That way, all of the
components involved in getting the user’s input will be orga nized into
SECTION 4.4 •A Graphical User Interface (GUI) 169
Java Applet
Handlers: actionPerformed() method
Java Enabled Browser: Netscape, JVM
Handlers: menu_event, scrollbar
Operating System: MacOS, Windows, Unix
Handlers: select_window, close_window
Computer Hardware
Generate Events: mouse_clicks, diskette events,
mouse_moves, keyboard_eventsFigure 4.18: Java’s event model.
one panel. We then add the entire panel to one of the areas on th e content
pane.
☛ ✟
JPanel inputPanel = new JPanel ( ) ;
inputPanel . add ( prompt ) ; // Add J L a b e l t o p a n e l
inputPanel . add ( i n F i e l d ) ; // Add J T e x t F i e l d t o p a n e l
inputPanel . add ( goButton ) ; // Add J B u t t o n t o p a n e l
contentPane . add ( ”South” , inputPanel ) ; // Add t o J F r a m e
✡ ✠
The default layout for a JPanel isFlowLayout , which means that com-
ponents are added left to right with the last addition going a t the end of
the sequence. This is an appropriate layout for this JPanel b ecause it will
place the prompt just to the left of the input JTextField .
JAVA EFFECTIVE DESIGN Encapsulation. JPanel s can be used to
group related components in a GUI.
4.4.6 Controlling the GUI’s Action
Now that we know how to place all the components on the GUI, we ne ed
to design the GUI’s controls. As mentioned earlier, GUIs use a f orm of
event-driven programming. Anything that happens when you a re using
a computer—every keystroke and mouse movement—is classiﬁed a s an
event. As Figure 4.18 illustrates, events are generated by t he computer’s
hardware and ﬁltered up through the operating system and the applica-
tion programs. Events are handled by special objects called l isteners. A
listener is a specialist that monitors constantly for a certain type o f event. Event listener
Some events, such as inserting a CD in the CD-ROM drive, are ha ndled
by listeners in the operating system. Others, such as typing input into
a Web page or a Word document, are handled by listeners in a pie ce of
application software, such as a browser or a word processor.
In an event-driven programming model, the program is control led by
anevent loop . That is, the program repeatedly listens for events, taking
170 CHAPTER 4 •Input/Output: Designing the User Interface
Figure 4.19: Java’s event hierar-
chy.
EventObject
AWTEventjava.awt
java.awt.eventjava.lang
java.utilObject
EventObject
AWTEvent
InputEvent
KeyEventActionEvent
AdjustmentEvent
ComponentEvent
ItemEvent
TextEventContainerEvent
FocusEvent
PaintEvent
WindowEvent MouseEvent
some kind of action whenever an event is generated. In effect, we might
portray this event loop as follows:
☛ ✟
Repeat f o r e v e r or u n t i l the program i s stopped
L i s t e n for events
I f event −A occurs , handle i t with event −A−handler
I f event −B occurs , handle i t with event −B−handler
. . .
✡ ✠
The event loop listens constantly for the occurrence of even ts and then
calls the appropriate object to handle each event.
Figure 4.19 shows some of the main types of events in the
java.awt.event package. In most cases, the names of the event classes
are suggestive of their roles. Thus, a MouseEvent occurs when the mouse
is moved. A KeyEvent occurs when the keyboard is used. The only event
that our program needs to listen for is an ActionEvent , the type of event
that occurs when the user clicks the JButton .
When the user clicks the JButton , Java will create an ActionEvent
object. This object contains important information about the event, such
as the time that the event occurred and the object, such as a JButton ,
that was the locus of the event. For our application, when the user
clicks the JButton , the program should input the user’s name from the
JTextField and display a greeting, such as “Hi John nice to meet you”
SECTION 4.4 •A Graphical User Interface (GUI) 171
in theJTextArea . That is, we want the program to execute the following
code segment:
☛ ✟
S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name ) + ”\n”) ;
✡ ✠
The ﬁrst line uses the JTextField.getText() method to get the text
that the user typed into the JTextField and stores it in a local vari-
able,name . The second line passes the name to thegreeter.greet()
method and passes the result it gets back to the JTextArea.append()
method. This will have the effect of displaying the text at th e end of the
JTextArea .
In this example, we have used a couple of the standard public me thods
of the JTextField andJTextArea classes. For our simple GUI, the
methods described in Figure 4.16 will be sufﬁcient for our ne eds. How-
java.sun.com/j2se/1.5.0/docs/api/ ever, if you would like to see the other methods available for these and
other Swing components, you should check Java’s online API d ocumen-
tation.
4.4.7 The ActionListener Interface
Given that the code segment just described will do the task of g reeting
the user, where should we put that code segment in our program ? We
want that code segment to be invoked whenever the user clicks on the
goButton . You know enough Java to understand that we should put that
code in a Java method. However, we need a special method in this case,
one that will be called automatically by Java whenever the us er clicks that
button. In other words, we need a special method that the butto n’s listener
knows how to call whenever the button is clicked.
Java solves this problem by letting us deﬁne a pre-selected m ethod
that can be associated with the goButton . The name of the method is Java interface
actionPerformed() and it is part of the ActionListener interface.
In this case, an interface is a special Java class that contains only methods
and constants (ﬁnal variables). It cannot contain instance v ariables. (Be
careful to distinguish this kind of interface, a particular type of Java class,
form the more general kind of interface, whereby we say that a class’s pub-
lic methods make up its interface to other objects.) Here’s the deﬁnition of
theActionListener interface:
☛ ✟
public a b s t r a c t i n t e r f a c e ActionListener
extends EventListener
{ public a b s t r a c t void actionPerformed ( ActionEvent e ) ;
}
✡ ✠
This resembles a class deﬁnition, but the keyword interface replaces
the keyword class in the deﬁnition. Note also that we are declaring this
interface to be abstract . An abstract interface orabstract class is one
that contains one or more abstract methods. An abstract method is one
that consists entirely of its signature; it lacks an impleme ntation—that is,
it does not have a method body. Note that the actionPerformed()
172 CHAPTER 4 •Input/Output: Designing the User Interface
method in ActionListener places a semicolon where its body is sup-
posed to be.
JAVA LANGUAGE RULE Java Interface. A Java interface is like a
Java class except that it cannot contain instance variables .
JAVA LANGUAGE RULE Abstract Methods and Classes. An
abstract method is a method that lacks an implementation. It h as no
method body.
Declaring a method abstract means that we are leaving its
implementation up to the class that implements it. This way, its imple- Abstract method
mentation can be tailored to a particular context, with its s ignature speci-
fying generally what the method should do. Thus, actionPerformed()
should take an ActionEvent object as a parameter and perform some
kind of action.
What this means, in effect, is that any class that implements t he
actionPerformed() method can serve as a listener for ActionEvent s.
Thus, to create a listener for our JButton , all we need to do is give an
implementation of the actionPerformed() method. For our program,
the action we want to take when the goButton is clicked, is to greet
the user by name. Thus, we want to set things up so that the foll ow-
ingactionPerformed() method is called whenever the goButton is
clicked:
☛ ✟
public void actionPerformed ( ActionEvent e )
{ i f( e . getSource ( ) == goButton )
{ S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name ) + ”\n”) ;
}
}
✡ ✠
In other words, we place the code that we want executed when the button
is clicked in the body of the actionPerformed() method. Note that in
the if-statement we get the source of the action from the ActionEvent
object and check that it was the goButton .
That explains what gets done when the button is clicked—namel y,
the code in actionPerformed() will get executed. But it doesn’t
explain how Java knows that it should call this method in the ﬁ rst
place. To set that up we must do two further things. We must pla ce
theactionPerformed() method in our GreeterGUI class, and we
must tell Java that GreeterGUI will be the ActionListener for the
goButton .
SECTION 4.4 •A Graphical User Interface (GUI) 173
The following stripped-down version of the GreeterGUI clas s illus-
trates how we put it all together:
☛ ✟
public c l a s s GreeterGUI extends Frame
implements ActionListener
{. . .
public void buildGUI ( )
{ . . .
goButton = new JButton ( ” Click here f o r a g r e e t i n g ! ” ) ;
goButton . addActionListener ( t h i s ) ;
. . .
}
. . .
public void actionPerformed ( ActionEvent e )
{ i f( e . getSource ( ) == goButton )
{ S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name ) + ”\n”) ;
}
}
. . .
}
✡ ✠
First, we declare that GreeterGUI implements the ActionListener
interface in the class header. This means that the class must provide a
deﬁnition of the actionPerformed() method, which it does. It also
means that GreeterGUI isaActionListener . SoSimpleGUI is both a
JFrame and an ActionListener .
Second, note how we use the addActionListener() method to as-
sociate the listener with the goButton :
☛ ✟
goButton . addActionListener ( t h i s )
✡ ✠
Thethis keyword is a self-reference—that is, it always refers to the
object in which it is used. It’s like a person referring to himse lf by saying
“I”. When used here, the this keyword refers to this GreeterGUI . In
other words, we are setting things up so that the GreeterGUI will serve
as the listener for action events on the goButton .
JAVA LANGUAGE RULE This Object. Thethis keyword always
refers to the object that uses it. It is like saying “I” or “me.”
174 CHAPTER 4 •Input/Output: Designing the User Interface
4.4.8 Connecting the GUI to the Computational Object
Figure 4.20 gives the complete source code for our GreeterGUI interface.
Because there is a lot going on here, it might be helpful to go t hrough the
program carefully even though we have introduced most of its elements
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s GreeterGUI extends JFrame
implements ActionListener
{private JTextArea display ;
private J T e x t F i e l d i n F i e l d ;
private JButton goButton ;
private Greeter g r e e t e r ;
public GreeterGUI ( S t r i n g t i t l e )
{g r e e t e r = new Greeter ( ) ;
buildGUI ( ) ;
s e t T i t l e ( t i t l e ) ;
pack ( ) ;
s e t V i s i b l e ( true ) ;
}// G r e e t e r G U I ( )
private void buildGUI ( )
{Container contentPane = getContentPane ( ) ;
contentPane . setLayout ( new BorderLayout ( ) ) ;
display = new JTextArea ( 1 0 , 3 0 ) ;
i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
goButton = new JButton ( ” Click here f o r a g r e e t i n g ! ” ) ;
goButton . addActionListener ( t h i s ) ;
JPanel inputPanel = new JPanel ( ) ;
inputPanel . add ( new JLabel ( ” Input your name here : ” ) ) ;
inputPanel . add ( i n F i e l d ) ;
inputPanel . add ( goButton ) ;
contentPane . add ( ” Center ” , display ) ;
contentPane . add ( ”South” , inputPanel ) ;
}// b u i l d G U I ( )
public void actionPerformed ( ActionEvent e )
{i f( e . getSource ( ) == goButton )
{S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name ) + ”\n”) ;
}
}// a c t i o n P e r f o r m e d ( )
}
✡ ✠
Figure 4.20: Deﬁnition of the GreeterGUI class.
already. That will help us put together all of the various con cepts that we
have introduced.
To begin with, note the several Java packages that must be inc luded
in this program. The javax.swing package includes deﬁnitions for
all of the Swing components. The java.awt.event package includes
SECTION 4.4 •A Graphical User Interface (GUI) 175
theActionEvent class and the ActionListener interface, and the
java.awt packages contain the Container class.
Next note how the GreeterGUI class is deﬁned as a subclass
ofJFrame and as implementing the ActionListener interface. Extending a class
GreeterGUI thereby inherits all of the functionality of a JFrame . Plus,
we are giving it additional functionality. One of its functi ons is to serve as
anActionListener for itsgoButton . TheActionListener interface
consists entirely of the actionPerformed() method, which is deﬁned Implementing an interface
in the program. This method encapsulates the actions that wi ll be taken
whenever the user clicks the goButton .
The next elements of the program are its four instance variab les, the
most important of which is the Greeter variable. This is the variable that
sets up the relationship between the GUI and the computation al object. In The computational object
this case, because the variable is declared in the GUI, we say t hat the GUI
uses the computation object, as illustrated in Figure 4.8. Th is is slightly
different from the relationship we set up in the command-lin e interface,
in which the computational object uses the interface (Fig. 4. 2).
The other instance variables are for those GUI components th at must
be referred to throughout the class. For example, note that t hegoButton ,
inField , anddisplay are instantiated in the buildGUI() method and
referenced again in the actionPerformed() method.
The next element in the program is its constructor. It begins b y creating
an instance of the Greeter computational object. It is important to do this
ﬁrst in case we need information from the computational objec t in order
to build the GUI. In this case we don’t need anything from Greeter , but
we will need such information in other programs.
We’ve already discussed the fact that the constructor’s rol e is to coor-
dinate the initialization of the GreeterGUI object. Thus, it invokes the
buildGUI() method, which takes care of the details of laying out the
GUI components. And, ﬁnally, it displays itself by calling t hepack() and
setVisible() methods, which are inherited from JFrame . Thepack()
method sizes the frame according to the sizes and layout of th e compo-
nents it contains. The setVisible() method is what actually causes the
GUI to appear on the Java console.
Finally, note the details of the buildGUI() method. We have dis-
cussed each of the individual statements already. Here we see the order
in which they are combined. Note that we can declare the contentPane
andinputPanel variables locally, because they are not used elsewhere
in the class.
SELF-STUDY EXERCISES
EXERCISE 4.2 There is a simple modiﬁcation that we can make to
GreeterGUI . TheJTextField can serve both as an input element and
as a control element for action events. An ActionEvent is generated
whenever the user presses the Return or Enter key in a JTextField so
that the JButton can be removed. Of course, it will be necessary to des-
ignate the inField as anActionListener in order to take advantage
of this feature. Make the appropriate changes to the buildGUI() and
actionPerformed() methods so that the inField can function as both
a control and input element. Call the new class GreeterGUI2 .
176 CHAPTER 4 •Input/Output: Designing the User Interface
4.4.9 Using the GUI in a Java Application
As you know, a Java application is a stand alone program, one t hat can
be run on its own. We have designed our GUI so that it can easily be
used with a Java application. We saw in the previous section t hat the GUI
has a reference to the Greeter object, which is the computational object.
Therefore, all we need to get the program to run as an applicat ion is a
main() method.
One way to use the GUI in an application is simply to create an i n-
stance in a main() method. The main() method can be placed in the
GreeterGUI class itself or in a separate class. Here’s an example with
the main in a separate class:
☛ ✟
public c l a s s GreeterApplication
{public s t a t i c void main ( S t r i n g args [ ] )
{
new GreeterGUI ( ” Greeter ” ) ;
}
}
✡ ✠
Themain() method creates an instance of GreeterGUI , passing it a
string to use as its title. If you prefer, this same main() method can be
incorporated directly into the GreeterGUI class.
4.4.10 Using the GUI in a Java Applet
Using our GUI with a Java applet is just as easy as using it with a n ap-
plication. The only difference is that we instantiate GreeterGUI in the
applet’s init() method rather than in a main() method:
☛ ✟
import javax . swing . ∗;
public c l a s s GreeterApplet extends JApplet
{
public void i n i t ( )
{
new GreeterGUI ( ” Greeter ” ) ;
}
}
✡ ✠
When this applet is run from a browser, it will open a separate t op-level
window that is identical to the window opened by the applicat ion. Un-
like the other applets we’ve seen, the GUI will not be embedde d directly
in the Web page, because it is not possible to add a JFrame , which our
GreeterGUI is, to a JApplet . The rule is you cannot add one top-level
window to another top-level window.
JAVA LANGUAGE RULE Top-level Windows. Top-level Java
windows cannot contain other top-level windows as componen ts.
It is a relatively simple matter to modify GreeterGUI so that it can
be embedded directly in the applet window. The main change we have to
SECTION 4.4 •A Graphical User Interface (GUI) 177
make is to deﬁne the GUI as a subclass of JPanel rather than as a subclass
ofJFrame . Figure 4.21 presents a full implementation of the revised c lass,
which we name GreeterGUIPanel .
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s GreeterGUIPanel extends JPanel
implements ActionListener
{private JTextArea display ;
private J T e x t F i e l d i n F i e l d ;
private JButton goButton ;
private Greeter g r e e t e r ;
public GreeterGUIPanel ( )
{ g r e e t e r = new Greeter ( ) ;
buildGUI ( ) ;
}// G U I P a n e l ( )
private void buildGUI ( )
{display = new JTextArea ( 1 0 , 3 0 ) ;
i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
goButton = new JButton ( ” Click here f o r a g r e e t i n g ! ” ) ;
goButton . addActionListener ( t h i s ) ;
JPanel inputPanel = new JPanel ( ) ;
inputPanel . add ( new JLabel ( ” Input your name here : ” ) ) ;
inputPanel . add ( i n F i e l d ) ;
inputPanel . add ( goButton ) ;
add ( ” Center ” , display ) ;
add ( ”South” , inputPanel ) ;
}// b u i l d G U I ( )
public void actionPerformed ( ActionEvent e )
{ i f( e . getSource ( ) == goButton )
{ S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name) + ”\n”) ;
}// i f
}// a c t i o n P e f o r m e d ( )
}// G r e e t e r G U I P a n e l
✡ ✠
Figure 4.21: Deﬁnition of the GreeterGUIPanel class.
The revised GreeterGUIPanel class requires the following two
changes:
•Unlike JFrame s,JPanel s do not have titles and does not have a
pack() method. Therefore we modify the constructor method to
the simpler form shown here.
•Unlike JFrame s,JPanel s do not use a content pane. Swing com-
ponents are added directly to the JPanel . This simpliﬁes the
buildGUI() method.
178 CHAPTER 4 •Input/Output: Designing the User Interface
Figure 4.22: The Greeter applet.
This version is embedded directly
in the Web page.
Given these changes, we would then change the applet’s init()
method to the following:
☛ ✟
import javax . swing . ∗;
public c l a s s GreeterPanelApplet extends JApplet
{ public void i n i t ( )
{ getContentPane ( ) . add ( new GreeterGUIPanel ( ) ) ;
}
}
✡ ✠
Note that because a JApplet has a content pane, we add the
GreeterGUIPanel to the content pane rather than to the applet itself.
The result would be the applet shown in Figure 4.22.
4.5 Case Study: The One Row Nim Game
In this section, we show how to develop alternative interface s for our case
study game of One Row Nim that was developed in the two previou s
chapters. As you recall, the One Row Nim game starts with, say , 21 sticks
on a table. Players take turns picking up 1, 2 or 3 sticks, and t he player to
pick up the last stick loses. We wish to develop an applicatio n program so
that the user of the program can play this game against the com puter, that
is, against the program.
As in our other examples in this chapter, our design will divi de this
problem into two primary objects: a computational object, in t his case
OneRowNim , and a user interface object, for which we will use either a
KeyboardReader or aOneRowNimGUI . One goal of our design was to
develop the OneRowNim class so that it can be used, without changes,
with either a command-line interface or a GUI.
FIGURE 4.23 A UML diagram of
theOneRowNim class.
SECTION 4.5 •Case Study: The One Row Nim Game 179
Recall that we designed the OneRowNim class to maintain the state of
the game and to provide methods that enforce the rules of the g ame. Thus,
we know that after each legal move, the number of sticks will d ecline, until
it is 0 or less, which indicates that the game is over. Also, an instance of
OneRowNim keeps track of whose turn it is and can determine if the game
is over and who the winner is when the game is over. Finally, th e game
ensures that players cannot cheat, either by taking too few o r too many
sticks on one turn. Figure 4.23 shows the UML diagram of the OneRowNim
class as described at the end of the previous chapter.
4.5.1 A Command-line Interface to OneRowNim
Let’s now focus on connecting a OneRowNim instance with a Keyboard-
Reader instance, the command-line interface we developed at the be gin-
ning of this chapter. To do so requires no changes to KeyboardReader
(Fig. 4.6). Unlike in the greeter example, we will use a third object to
serve as the main program. As shown in Figure 4.24, the OneRowNimApp
class will contain the run() method that controls the game’s progress.
OneRowNimApp will use the KeyboardReader object to prompt the user,
to display the program’s output, and to perform input from th e keyboard.
It will use the OneRowNim object to keep track of the game.
In fact, the main challenge for this part of our problem is desi gning the Loop algorithm
run() method, which will use a loop algorithm to play the game. The
user and the computer will repeatedly take turns picking up s ticks until
the game is over. The game is over when there are no more sticks to pick
up. Thus, we can use the game’s state—the number of sticks left —as our
loop’s entry condition. We will repeat the loop while there a re more than
0 sticks remaining.
The following pseudocode describes the remaining details o f our al-
gorithm. We refer to the OneRowNim instance as the game object, and
we refer to the KeyboardReader instance as the reader object. We
use the notation game:get the number of sticks left to indicate
that we are sending a message to the game object.
☛ ✟
Create a game o b j e c t with 21 s t i c k s
Create a reader o b j e c t
s t i c k s L e f t = game : get the number of s t i c k s l e f t
reader : display the r u l e s of the game
while ( game : the game i s not over )
whoseMove = game : find out whose turn i t i s
i f( whoseMove == user )
game : user chooses number of s t i c k s to take
else
game : computer chooses number of s t i c k s to take
s t i c k s L e f t = game : get the number of s t i c k s l e f t
reader : report the number of s t i c k s l e f t
// A t t h i s p o i n t t h e g a m e i s o v e r .
i fgame : the user i s the winner
reader : report t h a t the user wins
else
reader : report t h a t the computer wins
✡ ✠
180 CHAPTER 4 •Input/Output: Designing the User Interface
In this algorithm, the initializations we perform consist of creating the
game and reader objects and initializing sticksLeft . We use a while
loop structure to control the game. The loop’s entry conditi on is that the
’the game is not over’. This is a piece of information that com es directly
from the game object. As long as the game is not over, the body of the
loop will be executed. Note that in the loop’s body, either th e player or the
computer makes a move. Again, it is up to the game object to dete rmine
whose move it is. Following the move we ask the game how many st icks
are left and we use the reader object to report this.
Note that the loop structure has the three necessary element s. The
initializer in this case is the creation of a OneRowNim object. We know that Loop structure: Initializer, entry con-
dition, updater this will cause the game to have 21 sticks and it will be the use r’s move.
The loop-entry condition is that the game is not over, which i s based on
the fact that there are still sticks remaining to be picked up . But again, this
knowledge is kept by the game object. Finally, we have an updat er that
consists of either the computer or the user picking up some st icks. This in
turn changes the value of sticksLeft on each iteration, moving us ever
closer to the condition that there are no sticks left, at whic h point the game
will be over.
Note that we have left out of this algorithm the details of the user’s
moves and computer’s moves. These are the kinds of actions th at are
good to put into separate methods, where we can worry about ch ecking
whether the user made a legal move and other such details.
Figure 4.24 provides the implementation of the OneRowNimApp appli-
cation. It uses a KeyboardReader as a command-line interface and a
OneRowNim instance as it computational object. Thus, it has private in-
stance variables for each of these objects, which are instant iated in the
constructor method. The algorithm we just described has been placed in
therun() method, which is called from main() after the application is
instantiated. The use of the boolean method gameOver() to control the
loop makes this code segment easier to understand. Also, it l eaves it up
to the game object to determine when the game is over. From an ob ject-
oriented design perspective, this is an appropriate divisi on of responsibil- Division of labor
ity. If you doubt this, imagine what could go wrong if this dete rmination
was left up to the user interface. A user-interface programm er might end
up, mistakenly, implementing the wrong rule for the game bei ng over. A
similar point applies to the getWinner() method. This determination
rests with the game, not the user interface. If left up to the us er interface,
it is possible that a programming mistake could lead to the lo ss of the
game’s integrity.
Therun() method calls userMove() andcomputerMove() to per-
form the speciﬁc set of actions associated with each type of m ove.
TheuserMove() method uses the KeyboardReader() to prompt the
user and input his or her move. It then passes the user’s choice to
game.takeSticks() . Note how it checks the return value to determine
whether the move was legal or not and provides an appropriate response
through the interface.
Finally, note how we use private methods to implement the act ions as-
sociated with the user’s and computer’s moves. Because thes e private
methods are not part of the object’s interface and because the y can only
be used within the object themselves, they are in a sense secon dary to the
SECTION 4.5 •Case Study: The One Row Nim Game 181
☛ ✟
public c l a s s OneRowNimApp
{private KeyboardReader reader ;
private OneRowNim game ;
public OneRowNimApp( )
{reader = new KeyboardReader ( ) ;
game = new OneRowNim ( 2 1 ) ;
}// OneRowNim ( )
public void run ( )
{i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
reader . display ( ” Let ’ s play One Row Nim. You go f i r s t . \n”) ;
reader . display ( ” There are ” + s t i c k s L e f t +
” s t i c k s l e f t . \n”) ;
reader . display ( ”You can pick up 1 , 2 , or 3 at a time \n . ” ) ;
while ( game . gameOver ( ) == f a l s e )
{i f( game . getPlayer ( ) == 1) userMove ( ) ;
else computerMove ( ) ;
s t i c k s L e f t = game . g e t S t i c k s ( ) ;
reader . display ( ”There are ” + s t i c k s L e f t +
” s t i c k s l e f t . \n”) ;
}// w h i l e
i f( game . getWinner ( ) == 1)
reader . display ( ”Game over . You win . Nice game . \n”) ;
else reader . display ( ”Game over . I win . Nice game . \n”) ;
}// r u n ( )
private void userMove ( )
{reader . prompt ( ”Do you take 1 , 2 , or 3 s t i c k s ? : ” ) ;
i n t userTakes = reader . getKeyboardInteger ( ) ;
i f( game . t a k e S t i c k s ( userTakes ) )
{reader . display ( ”You take ” + userTakes + ” .\n”) ;
}else
{reader . display ( ”You can ’ t take ” + userTakes +
” . Try again \n”) ;
}// e l s e
}// u s e r M o v e ( )
private void computerMove ( )
{game . takeAway ( 1 ) ; // T e m p o r a r y s t r a t e g y .
reader . display ( ” I take 1 s t i c k . ” ) ;
}// c o m p u t e r M o v e ( )
public s t a t i c void main ( S t r i n g args [ ] )
{OneRowNimApp app = new OneRowNimApp ( ) ;
app . run ( ) ;
}// m a i n ( )
}// OneRowNimApp
✡ ✠
Figure 4.24: Deﬁnition of OneRowNimApp , a command-line interface to
theOneRowNim .
182 CHAPTER 4 •Input/Output: Designing the User Interface
object’s public instance methods. We sometimes refer to them ashelper
methods . This division of labor allows us to organize all of the detai ls
associated with the moves into a single module. The computerMove()
method uses a temporary strategy of taking a single stick and passes
the number 1togame.takeSticks() . Finally, computerMove() re-
ports its choice through the interface. After we have covere d operators of
theint data type in the next chapter, we will be able to describe bett er
strategies for the computer to make a move.
This example shows how simple and straightforward it is to us e our
KeyboardReader user interface. In fact, for this problem, our interface
didn’t require any changes. Although there might be occasio ns where we
will want to extend the functionality of KeyboardReader , it can be used
without changes for a wide variety of problems in subsequent chapters.
JAVA EFFECTIVE DESIGN Code Reuse. A well-designed user
interface can be used with many computational objects.
4.5.2 A GUI for OneRowNim
The ﬁrst task is designing a GUI for the OneRowNim is to decide how to
use input, output, and control components to interact with t he user. Fol-
lowing the design we used in the GUI for our greeter applicati on, we can
use aJTextField for the user’s input and a JTextArea for the game’s
output. Thus, we will use the JTextArea to report on the progress of the
game and to display any error messages that arise. As in the gr eeter exam-
ple, we can use both the JTextField andJButton as control elements
and aJLabel as a prompt for the input text ﬁeld. For the most part then,
the use of GUI components will remain the same as in our previo us exam-
ple. This is as we would expect. The relationship between the user and
the interface are pretty similar in both this and the previou s application.
In contrast, the relationship between the interface and the g ame are
quite different from what we saw in the greeter application. As in the
previous application, the GUI will still need a reference to its associated
computational object, in this case the game:
☛ ✟
private OneRowNim game ;
. . .
game = new OneRowNim ( ) ;
✡ ✠
The biggest difference between this GUI and the one we used wi th
the greeter application occurs in the details of the interac tion between
the GUI and the game. These details are the responsibility of the
actionPerformed() method, whose actions depend on the actual
progress of the individual game.
Unlike in the command-line version, there is no need to use a l oop con-
struct in the actionPerformed() method. Instead, because we are us- Java’s event loop
ing event-driven programming here, we will rely on Java’s ev ent loop to
move the game from one turn to another.
SECTION 4.5 •Case Study: The One Row Nim Game 183
As in the greeter example, the actionPerformed() method will be
called automatically whenever the JButton is clicked. It is the responsi-
bility of the GUI to ensure that it is the user’s turn whenever this action
occurs. Therefore, we design actionPerformed() so that each time it
is called, it ﬁrst performs the user’s move and then, assumin g the game
is not over and an error did not occur on the user’s move, it per forms the
computer’s move. Thus, the basic algorithm is as follows:
☛ ✟
Let the user move .
I f game : game i s not over and computer turn
l e t the computer move .
Game : how many s t i c k s are l e f t .
display : report how many s t i c k s are l e f t
I f game : game i s over
Stop accepting moves .
Report the winner .
✡ ✠
After the user’s move, it is possible that the user picked up t he last stick,
which means that the game would be over. In that case, the compu ter
would not get a move. Or, the user could have made an error. In th at case
it would still be the user’s move. These possibilities have t o be considered
in the algorithm before the computer gets to move. As the pseu docode
shows, it is the OneRowNim object’s responsibility to keep track of whether
the game is over and whose turn it is.
Figure 4.25 shows the complete implementation of the OneRowNimGUI
class. In terms of its instance variables, constructor, and i tsbuildGUI()
method, there are only a few minor differences between this G UI and
theGreeterGUI (Fig. 4.20). This GUI has instance variables for its
JTextField ,JTextArea , andJButton , as well as one for OneRowNim
instance, its computational object. It needs to be able to refe r to these
objects throughout the class. Hence we give them class scope.
The constructor method plays the same role here as in the prev ious
GUI: It creates an instance of the computational object, builds the GUI’s
layout, and then displays the interface on the console.
All of the changes in the buildGUI() method have to do with
application-speciﬁc details, such as the text we use as the p rompt and
thegoButton ’s label. One new method we use here is the setText()
method. Unlike the append() method, which is used to add text to the
existing text in a JTextArea , thesetText() method replaces the text in
aJTextArea or aJTextField .
Next let’s consider the private userMove() andcomputerMove()
methods. Their roles are very similar to the corresponding m ethods in
the command-line interface: They encapsulate the details i nvolved in per-
forming the players’ moves. The primary difference here is t hat for the
user move we input the user’s choice from a JTextField rather than
from the keyboard. We use getText() to retrieve the user’s input from
theJTextField and we use Integer.parseInt() to convert to an
int value:
☛ ✟
i n t userTakes = I n t e g e r . p a r s e I n t ( i n F i e l d . getText ( ) ) ;
✡ ✠
184 CHAPTER 4 •Input/Output: Designing the User Interface
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s OneRowNimGUI extends JFrame implements ActionListener
{private JTextArea display ;
private J T e x t F i e l d i n F i e l d ;
private JButton goButton ;
private OneRowNim game ;
public OneRowNimGUI( S t r i n g t i t l e )
{game = new OneRowNim ( 2 1 ) ;
buildGUI ( ) ;
s e t T i t l e ( t i t l e ) ;
pack ( ) ;
s e t V i s i b l e ( true ) ;
}// OneRowNimGUI ( )
private void buildGUI ( )
{Container contentPane = getContentPane ( ) ;
contentPane . setLayout ( new BorderLayout ( ) ) ;
display = new JTextArea ( 2 0 , 3 0 ) ;
display . s e t T e x t ( ” Let ’ s play Take Away. There are ” + game . g e t S t i c k s ( ) +
” s t i c k s . \n”+” Pick up 1 , 2 , or 3 at a time . \n”+”You go f i r s t . \n”) ;
i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
goButton = new JButton ( ”Take S t i c k s ” ) ;
goButton . addActionListener ( t h i s ) ;
JPanel inputPanel = new JPanel ( ) ;
inputPanel . add ( new JLabel ( ”How many s t i c k s do you take : ” ) ) ;
inputPanel . add ( i n F i e l d ) ;
inputPanel . add ( goButton ) ;
contentPane . add ( ” Center ” , display ) ;
contentPane . add ( ”South” , inputPanel ) ;
}// buildGUI
private void userMove ( )
{i n t userTakes = I n t e g e r . p a r s e I n t ( i n F i e l d . getText ( ) ) ;
i f( game . t a k e S t i c k s ( userTakes ) )
display . append ( ”You take ” + userTakes + ” .\n”) ;
el s e display . append ( ”You can ’ t take ” + userTakes + ” . Try again \n”) ;
}// userMove ( )
private void computerMove ( )
{i f( game . gameOver ( ) ) return ;
i f( game . getPlayer ( ) == 2)
{ game . t a k e S t i c k s ( 1 ) ; // Temporary s t r a t e g y
display . append ( ” I take one s t i c k . ” ) ;
}// i f
}// computerMove ( )
private void endGame ( )
{goButton . setEnabled ( f a l s e ) ; // Disable button and t e x t f i e l d
i n F i e l d . setEnabled ( f a l s e ) ;
i f( game . getWinner ( ) == 1)
display . append ( ”Game over . You win . Nice game. \n”) ;
el s e display . append ( ”Game over . I win . Nice game. \n”) ;
}// endGame ( )
public void actionPerformed ( ActionEvent e )
{i f( e . getSource ( ) == goButton )
{userMove ( ) ;
computerMove ( ) ;
i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
display . append ( ”There are ” + s t i c k s L e f t + ” s t i c k s l e f t . \n”) ;
i f( game . gameOver ( ) ) endGame ( ) ;
}// i f
}// actionPerformed ( )
}// OneRowNimGUI
✡ ✠
Figure 4.25: The OneRowNimGUI class.
SECTION 5 •File Input 185
Another difference is that we use a JTextField to display the program’s
messages to the user.
As we have noted, the main differences between this and the
GreeterGUI occur in the actionPerformed() method. Note
there how we use OneRowNim ’s public methods, getPlayer(),
gameOver() andgetWinner() to control the interaction with the user.
One issue that differs substantially from the command-line interface is:
How do we handle the end of the game? Because we are using Java’s built-
in event loop, the GUI will continue to respond to user’s even ts, unless we
stop it from doing so. One way to do this is to disable the JButton and
theJTextField . By disabling a control element, we render it unable to
respond to events. To do this we use the setEnabled() method, passing
it the value false to, in effect, “turn off” that component:
☛ ✟
i f( game . gameOver ( ) )
{goButton . setEnabled ( f a l s e ) ; // E n d t h e g a m e
i n F i e l d . setEnabled ( f a l s e ) ;
. . .
}
✡ ✠
Although it doesn’t apply in this situation, the setEnabled() method
can be used repeatedly in a GUI to turn components on and off as the
context of the interaction dictates.
This example shows how simple and straightforward it can be t o build
a GUI for just about any application. One main design issue is d eciding GUI input, output, and control
what kinds of input, output, and control elements to use. For most ap-
plications, we can use JTextField ,JTextArea ,JLabel , andJButton
as the GUI’s basic elements. A second design issue concerns th e develop-
ment of the actionPerformed() method, which must be designed in
an application-speciﬁc way. Here we apply what we’ve learned regard-
ing Java’s event-programming model: We designate one or mor e of our
elements to serve as an ActionListener and we design algorithms to
handle the action events that occur on that element.
Of course, for some applications we may need two JTextField s to
handle input. At some point, we also might want to introduce JMenu s and
other advanced GUI elements. Some of these options will be in troduced in
upcoming chapters. Others will be covered in Chapter 13, whi ch provides
a more comprehensive view of Java’s GUI capabilities.
JAVA EFFECTIVE DESIGN GUI Design A well-designed GUI
makes appropriate use of input, output, and control element s.
4.6 From the Java Library: java.io.File
and File Input (Optional)
In addition to command-line and GUI user interfaces, there is one more
standard user interface, ﬁles. In this section we show how the Scanner
class, that was used in Chapter 2 for keyboard input, can also read input
186 CHAPTER 4 •Input/Output: Designing the User Interface
from ﬁles. Reading input from a ﬁle is relevant to only certai n types of
programming problems. It is hard to imagine how a ﬁle would be u sed
in playing the One Row Nim game but a ﬁle might very well be usef ul
to store a collection of riddles that could be read and displa yed by a Java
program. We will develop such a program later in this section .
Java has two types of ﬁles, text ﬁles and binary ﬁles . Atext ﬁle stores a
sequence of characters and is the type of ﬁle created by stand ard text edi-
tors like NotePad and WordPad on a Windows computer or SimpleText on a
Macintosh. A binary ﬁle has a more general format that can store numbers
and other data the way they are stored in the computer. In this s ection we
FIGURE 4.26 A UML class diagram
of theFile class with a partial list of
public methodswill consider only text ﬁles. Binary ﬁles are considered in C hapter 11.
4.6.1 File Input with the File andScanner Classes
An instance of the java.io.File class stores information that a
Scanner object needs to create an input stream that is connected to the
sequence of characters in a text ﬁle. A partial list of the pub lic methods
of theFile class is given in the UML class diagram in Figure 4.26. We
will need to use only the File() constructor in this section. The File
instance created with the statement
☛ ✟
F i l e t h e F i l e = new F i l e ( ” r i d d l e s . t x t ” ) ;
✡ ✠
FIGURE 4.27 A UML class diagram
of theScanner class with an
expanded list of public methodswill obtain and store information about the ”riddles.txt” ﬁ le in the same
directory as the java code being executed, if such a ﬁle exists . If no such
ﬁle exists, the File object stores information needed to create such a ﬁle
but does not create it. In Chapter 11, we will describe how othe r objects
can use a ﬁle object to create a ﬁle in which to write data. If we wi sh to
create a File object that describes a ﬁle in a directory other than the one
containing the Java program, we must call the constructor wi th a string ar-
gument that speciﬁes the ﬁle’s complete path name—that is, on e that lists
the sequence of directories containing the ﬁle. In any case, w hile we will
not use it at this time, the exists() method of a File instance can be
used to determine whether or not a ﬁle has been found with the s peciﬁed
name.
In order to read data from a ﬁle with a Scanner object we will need
to use methods that were not discussed in Chapter 2. An expand ed list
of methods of the Scanner class is given in Figure 4.27. Note the there
is aScanner() constructor with a File object as an argument. Unlike
the other create() method that was used in Chapter 2, this create()
throws an exception that must be handled. The following code will create
SECTION 6 •File Input 187
aScanner object that will be connected to an input stream that can read
from a ﬁle:
☛ ✟
t r y
{ F i l e t h e F i l e = new F i l e ( ” r i d d l e s . t x t ” ) ;
f i l e S c a n = new Scanner ( t h e F i l e ) ;
f i l e S c a n = f i l e S c a n . useDelimiter ( ”\r\n”) ;
}catch ( IOException e )
{ e . p r i n t S t a c k T r a c e ( ) ;
}// c a t c h ( )
✡ ✠
We will discuss the try-catch commands when exceptions are covered
in Chapter 10. Until then, the try-catch structures can be copied exactly
as above, if you wish to use a Scanner object for ﬁle input. In the code
above, the useDelimiter() method has been used to set the Scanner
object so that spaces can occur in strings that are read by the Scanner
object. For the deﬁnition of a class to read riddles from a ﬁle, the above
code belongs in a constructor method.
After we create a Scanner object connected to a ﬁle, we can make a
call tonextInt() ,nextDouble() , ornext() method to read, respec-
tively, an integer, real number, or string from the ﬁle. Unli ke the strategy
for using a Scanner object to get keyboard input, it is suggested that
you test to see if there is more data in a ﬁle before reading it. This can
be done with the hasNext() ,hasNextInt() , andhasNextDouble()
methods. These methods return the value true if there are more data in
the ﬁle.
The program in Figure 4.28 is the complete listing of a class t hat reads
riddles from a ﬁle and displays them. Note that, in the body of the method
readRiddles() , the statements:
☛ ✟
S t r i n g ques = null ;
S t r i n g ans = null ;
Riddle theRiddle = null ;
✡ ✠
make explicit the fact that variables that refer to objects ar e assigned null
as a value when they are declared. The statements:
☛ ✟
i f( f i l e S c a n . hasNext ( ) )
ques = f i l e S c a n . next ( ) ;
i f( f i l e S c a n . hasNext ( ) )
{ ans = f i l e S c a n . next ( ) ;
theRiddle = new Riddle ( ques , ans ) ;
}
✡ ✠
will read String s into the variables ques andans only if the ﬁle contains
lines of data for them. Otherwise the readRiddle() method will return
anull value. The main() method uses this fact to terminate a while
loop when it runs out of string data to assign to Riddle questions and
answers. There is a separate method, displayRiddle() using a sepa-
rate instance of Scanner attached to the keyboard to display the question
of a riddle before the answer.
188 CHAPTER 4 •Input/Output: Designing the User Interface
☛ ✟
import java . io . ∗;
import java . u t i l . Scanner ;
public c l a s s RiddleFileReader
{ private Scanner f i l e S c a n ; // F o r f i l e i n p u t
private Scanner kbScan ; // F o r k e y b o a r d i n p u t
public RiddleFileReader ( S t r i n g fName )
{ kbScan = new Scanner ( System . in ) ;
t r y
{ F i l e t h e F i l e = new F i l e ( fName ) ;
f i l e S c a n = new Scanner ( t h e F i l e ) ;
f i l e S c a n = f i l e S c a n . useDelimiter ( ”\r\n”) ;
}catch ( IOException e )
{ e . p r i n t S t a c k T r a c e ( ) ;
}// c a t c h ( )
}// R i d d l e F i l e R e a d e r ( ) c o n s t r u c t o r
public Riddle readRiddle ( )
{ S t r i n g ques = null ;
S t r i n g ans = null ;
Riddle theRiddle = null ;
i f( f i l e S c a n . hasNext ( ) )
ques = f i l e S c a n . next ( ) ;
i f( f i l e S c a n . hasNext ( ) )
{ ans = f i l e S c a n . next ( ) ;
theRiddle = new Riddle ( ques , ans ) ;
}// i f
return theRiddle ;
}// r e a d R i d d l e ( )
public void displayRiddle ( Riddle aRiddle )
{ System . out . p r i n t l n ( aRiddle . getQuestion ( ) ) ;
System . out . p r i n t ( ” Input any l e t t e r to see answer : ” ) ;
S t r i n g s t r = kbScan . next ( ) ; // I g n o r e KB i n p u t
System . out . p r i n t l n ( aRiddle . getAnswer ( ) ) ;
System . out . p r i n t l n ( ) ;
}// d i s p l a y R i d d l e ( )
public s t a t i c void main ( S t r i n g [ ] args )
{ RiddleFileReader r f r =
new RiddleFileReader ( ” r i d d l e s . t x t ” ) ;
Riddle r i d d l e = r f r . readRiddle ( ) ;
while ( r i d d l e != null )
{ r f r . displayRiddle ( r i d d l e ) ;
r i d d l e = r f r . readRiddle ( ) ;
}// w h i l e
}// m a i n ( )
} // R i d d l e F i l e R e a d e r c l a s s
✡ ✠
Figure 4.28: A program which reads riddles from a ﬁle and disp lays them.
The contents of the ”riddles.txt” ﬁle should be a list of ridd les with
each question and answer on a separate line. For example The f ollowing
CHAPTER 4 •Chapter Summary 189
three riddles saved in a text ﬁle would form a good example to t est the
RiddleFileReader class.
☛ ✟
What i s black and white and red a l l over ?
An embarrassed zebra
What i s black and white and read a l l over ?
A newspaper
What other word can be made with the l e t t e r s of ALGORITHM?
LOGARITHM
✡ ✠
When the main() method is executed, the user will see output in the
console window that looks like:
☛ ✟
What i s black and white and red a l l over ?
Input any l e t t e r to see answer : X
An embarrassed zebra
What i s black and white and read a l l over ?
Input any l e t t e r to see answer :
✡ ✠
Files are covered in depth in Chapter 11. Information on writi ng data
to a ﬁle and reading data from a ﬁle without using the Scanner class can
be found in that chapter.
SELF-STUDY EXERCISES
EXERCISE 4.3 Modify the RiddleFileReader class to create a pro-
gramNumberFileReader that opens a ﬁle named ”numbers.txt” and re-
ports the sum of the squares of the integers in the ﬁle. Assume that the
ﬁle ”numbers.txt” contains a list of integers in which each i nteger is on
a separate line. The program should print the sum of the squar es in the
System.out console window. In this case, there is no need to have a
method to display the data being read or a Scanner object connected to
the keyboard. You will want a constructor method and a method that
reads the numbers and computes the sum of squares.
CHAPTER SUMMARY Technical Terms
abstract class
abstract interface
abstract method
AWT
binary ﬁle
buffer
command-line
interface
container
control element
event-driven
programmingevent loop
graphical user
interface (GUI)
helper method
inheritance
input operation
input stream
interface
layout manager
listenermodel-view-
controller (MVC)
architecture
output operation
output stream
stream
Swing
text ﬁle
top-level container
user interface
wrapper class
190 CHAPTER 4 •Input/Output: Designing the User Interface
Summary of Important Points
•An input operation is any action that transfers data from the user to the
computer’s main memory via one of the computer’s input devic es. An
output operation is any action that transfers data from the c omputer’s
main memory to one of the computer’s output devices.
•The user interface is that part of the program that handles th e input
and output interactions between the user and the program. As an in-
terface, it limits or constrains the manner in which the user can interact
with the program.
•In a command-line interface, user input is taken from the keyb oard,
and the program’s output is displayed on some kind of console .
•A buffer is a portion of main memory where input is held until i t is
needed by the program. Using a buffer between the keyboard an d the
program allows you to use the Backspace key to delete a charac ter.
•A wrapper class contains methods for converting primitive d ata into
objects and for converting data from one type to another.
•Designing appropriate prompts is an important aspect of des igning a
good user interface.
•I/O operations must watch out for certain types of I/O exceptio ns.
•GUI programming involves a computational model known as eve nt-
driven programming, which means that GUI programs react to e vents
that are generated mostly by the user’s interactions with el ements in
the GUI.
•Java has two packages of GUIs, the older java.awt and the newer
javax.swing .
•Swing components are based on the object-oriented model-vie w-
controller (MVC) architecture.
•Theextends keyword is used to specify subclass/superclass relation-
ships in the Java class hierarchy.
•A top-level container is a GUI container that cannot be added to an-
other container; it can only have components added to it. All GUI
programs must be contained in a top-level container.
•There are generally three kinds of GUI components, correspo nding to
the three main functions of a user interface: input, output, and control.
•Events are handled by special objects called listeners. A lis tener is a
specialist that listens constantly for a certain type of eve nt.
•An interface is a special Java class that contains only metho ds and
constants (ﬁnal variables).
CHAPTER 4 •Solutions to Self-Study Exercises 191
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 4.1 The following modiﬁcation of the GreeterApp class is an im-
plementation of the High Low Game:
☛ ✟
{private KeyboardReader reader ;
private i n t secretNumber ;
public HighLowApp ( )
{reader = new KeyboardReader ( ) ;
secretNumber = 1 + ( i n t) ( Math . random ( ) ∗1 0 0 ) ;
}// H i g h L o w A p p ( ) c o n s t r u c t o r
public void run ( )
{i n t userGuess = −1;
reader . display ( ”Guess my s e c r e t number between 1 and 1 0 0 . ” ) ;
while ( userGuess != secretNumber )
{ reader . prompt ( ” Please input your guess here >”) ;
userGuess = reader . getKeyboardInteger ( ) ;
i f( userGuess >secretNumber )
reader . display ( ”Your guess was too high . ” ) ;
i f( userGuess <secretNumber )
reader . display ( ”Your guess was too low . ” ) ;
}// w h i l e
reader . display ( ” Congratulations . Your guess was c o r r e c t . ” ) ;
}// r u n ( )
public s t a t i c void main ( S t r i n g args [ ] )
{HighLowApp app = new HighLowApp ( ) ;
app . run ( ) ;
}// m a i n ( )
}// H i g h L o w A p p
✡ ✠
192 CHAPTER 4 •Input/Output: Designing the User Interface
SOLUTION 4.2 The following modiﬁcation of GreeterGUI eliminates the
JButton .
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s GreeterGUI2 extends JFrame
implements ActionListener
{private JTextArea display ;
private J T e x t F i e l d i n F i e l d ;
private Greeter g r e e t e r ;
public GreeterGUI2 ( S t r i n g t i t l e )
{ g r e e t e r = new Greeter ( ) ;
buildGUI ( ) ;
s e t T i t l e ( t i t l e ) ;
pack ( ) ;
s e t V i s i b l e ( true ) ;
}// G r e e t e r G U I 2 ( )
private void buildGUI ( )
{ Container contentPane = getContentPane ( ) ;
contentPane . setLayout ( new BorderLayout ( ) ) ;
display = new JTextArea ( 1 0 , 3 0 ) ;
i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
i n F i e l d . addActionListener ( t h i s ) ;
JPanel inputPanel = new JPanel ( ) ;
inputPanel . add ( new
JLabel ( ” Input your name and type enter : ” ) ) ;
inputPanel . add ( i n F i e l d ) ;
contentPane . add ( ” Center ” , display ) ;
contentPane . add ( ”South” , inputPanel ) ;
}// b u i l d G U I ( )
public void actionPerformed ( ActionEvent e )
{ i f( e . getSource ( ) == i n F i e l d )
{ S t r i n g name = i n F i e l d . getText ( ) ;
display . append ( g r e e t e r . g r e e t (name ) + ”\n”) ;
}
}// a c t i o n P e r f o r m e d ( )
}// G r e e t e r G U I 2
✡ ✠
CHAPTER 4 •Exercises 193
SOLUTION 4.3 Java code that prints out the sum of the squares of a set of
integers read from a ﬁle named ”numbers.txt”:
☛ ✟
import java . u t i l . Scanner ;
public c l a s s NumberFileReader
{ private Scanner f i l e S c a n ; // F o r f i l e i n p u t
public NumberFileReader ( S t r i n g fName )
{ t r y
{ F i l e t h e F i l e = new F i l e ( fName ) ;
f i l e S c a n = new Scanner ( t h e F i l e ) ;
}catch ( IOException e )
{ e . p r i n t S t a c k T r a c e ( ) ;
}// c a t c h ( )
}// N u m b e r F i l e R e a d e r ( )
public void readNumbers ( )
{ i n t num = 0 ; // T o s t o r e i n t e g e r s r e a d
i n t sum = 0 : // T o s t o r e sum o f s q u a r e s
while ( f i l e S c a n . hasNextInt ( ) )
{ num = f i l e S c a n . n e x t I n t ( ) ;
sum = sum + num ∗num;
}// w h i l e
System . out . p r i n t l n ( ”The sum of squares = ” + sum ) ;
}// r e a d N u m b e r s ( )
public s t a t i c void main ( S t r i n g [ ] args )
{ NumberFileReader nfr =
new NumberFileReader ( ”numbers . t x t ” ) ;
nfr . readNumbers ( )
}// m a i n ( )
} // N u m b e r F i l e R e a d e r
✡ ✠
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 4.1 Fill in the blanks in each of the following sentences:
a. An is a Java program that can be embedded in a Web page.
b. A method that lacks a body is an method.
c. An is like a class except that it contains only instance methods, no
instance variables.
d. In a Java class deﬁnition a class can a class and an inter-
face.
e. Classes and methods not deﬁned in a program must be from the Java
class library.
f. A subclass of a class inherits that class’s instance variables and in-
stance methods.
g. An object can refer to itself by using the keyword.
h. The JButton ,JTextField , and JComponent classes are deﬁned in the
package.
i. Java applets utilize a form of control known as programming.
194 CHAPTER 4 •Input/Output: Designing the User Interface
j. When the user clicks on an applet’s JButton , an will automatically
be generated.
k. Two kinds of objects that generate ActionEvent s are and
.
l.JButton s,JTextField s, andJLabel s are all subclasses of .
m. The JApplet class is a subclass of .
n. If an applet intends to handle ActionEvent s, it must implement the
interface.
o. When an applet is started, its method is called automatically.
EXERCISE 4.2 Explain the difference between the following pairs of concepts:
a.Class and interface .
b.Extending a class and instantiating an object .
c.Deﬁning a method and implementing a method .
d. Aprotected method and a public method.
e. Aprotected method and a private method.
f. AnActionEvent and an ActionListener() method.
EXERCISE 4.3 Draw a hierarchy chart to represent the following situation.
There are lots of languages in the world. English, French, Chine se, and Korean
are examples of natural languages. Java, C, and C++ are exampl es of formal lan-
guages. French and Italian are considered romance languages, while Greek and
Latin are considered classical languages.
EXERCISE 4.4 Arrange the Java library classes mentioned in the Chapter Sum-
mary into their proper hierarchy, using the Object class as the root of the hierar-
chy.
EXERCISE 4.5 Look up the documentation for the JButton class on Sun’s Web
site:
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
List the signatures of all its constructors.
EXERCISE 4.6 Suppose we want to set the text in our applet’s JTextField .
What method should we use and where is this method deﬁned? ( Hint : Look up
the documentation for JTextField . If no appropriate method is deﬁned there,
see if it is inherited from a superclass.)
EXERCISE 4.7 Does a JApplet have an init() method? Explain.
EXERCISE 4.8 Does a JApplet have an add() method? Explain.
EXERCISE 4.9 Does a JButton have an init() method? Explain.
EXERCISE 4.10 Does a JButton have an add() method? Explain.
EXERCISE 4.11 Suppose you type the URL for a “Hello World” applet into your
browser. Describe what happens—that is, describe the process ing that takes place
in order for the applet to display “Hello World” in your browser.
EXERCISE 4.12 Suppose you have an applet containing a JButton named
button . Describe what happens, in terms of Java’s event handling model , when
the user clicks the button.
EXERCISE 4.13 Java’sObject class contains a public method, toString() ,
which returns a string that represents this object. Because e very class is a subclass
ofObject , thetoString() method can be used by any object. Show how you
would invoke this method for a JButton object named button .
CHAPTER 4 •Exercises 195
EXERCISE 4.14 The applet that follows contains a semantic error in its init()
method. The error will cause the actionPerformed() method never to display
“Clicked” even though the user clicks the button in the applet. Why? ( Hint : Think
scope!)
☛ ✟
public c l a s s SomeApplet extends JApplet
implements ActionListener
{
// D e c l a r e i n s t a n c e v a r i a b l e s
private JButton button ;
public void i n i t ( )
{
// I n s t a n t i a t e t h e i n s t a n c e v a r i a b l e
JButton button = new JButton ( ” Click me” ) ;
add ( button ) ;
button . addActionListener ( t h i s ) ;
}// i n i t ( )
public void actionPerformed ( ActionEvent e )
{
i f( e . getSource ( ) == button )
System . out . p r i n t l n ( ” Clicked ” ) ;
}// a c t i o n P e r f o r m e d ( )
}// S o m e A p p l e t
✡ ✠
EXERCISE 4.15 What would be output by the following applet?
☛ ✟
public c l a s s SomeApplet extends JApplet
{
// D e c l a r e i n s t a n c e v a r i a b l e s
private JButton button ;
private J T e x t F i e l d f i e l d ;
public void i n i t ( )
{
// I n s t a n t i a t e i n s t a n c e v a r i a b l e s
button = new JButton ( ” Click me” ) ;
add ( button ) ;
f i e l d = new J T e x t F i e l d ( ” F i e l d me” ) ;
add ( f i e l d ) ;
System . out . p r i n t l n ( f i e l d . getText ( ) + button . getText ( ) ) ;
}// i n i t ( )
}// S o m e A p p l e t
}
✡ ✠
EXERCISE 4.16 Design and implement a GUI that has a JButton , a
JTextField , and a JLabel and then uses the toString() method to display
each object’s string representation.
EXERCISE 4.17 TheJButton class inherits a setText(String s) from its
AbstractButton() superclass. Using that method, design and implement a
GUI that has a single button labeled initially, “The Doctor is out .” Each time the
button is clicked, it should toggle its label to, “The Doctor is in” a nd vice versa.
196 CHAPTER 4 •Input/Output: Designing the User Interface
EXERCISE 4.18 Design and implement a GUI that contains two JButton s, ini-
tially labeled, “Me ﬁrst!” and “Me next!” Each time the user cli cks either button,
the labels on both buttons should be exchanged. ( Hint : You don’t need an if-else
statement for this problem.)
EXERCISE 4.19 Modify the GUI in the previous exercise so that it contains three
JButton s, initially labeled “First,” “Second,” and “Third.” Each tim e the user
clicks one of the buttons, the labels on the buttons should be rotated . Second
should get ﬁrst’s label, third should get second’s, and ﬁrst should get third’s label.
EXERCISE 4.20 Design and implement a GUI that contains a JTextField and
twoJButton s, initially labeled “Left” and “Right.” Each time the user c licks a
button, display its label in the JTextField . AJButton() ’s label can be gotten
with the getText() method.
EXERCISE 4.21 You can change the size of a JFrame by using the setSize(int
h, int v) method, where hand vgive its horizontal and vertical dimensions
pixels. Write a GUI application that contains two JButton s, labeled “Big” and
“Small.” Whenever the user clicks on small, set the JFrame’s dimensions to 200
×100, and whenever the user clicks on big, set the dimensions to 3 00×200.
EXERCISE 4.22 Rewrite your solution to the previous exercise so that it uses a
single button whose label is toggled appropriately each time it i s clicked. Obvi-
ously, when the JButton is labeled “Big,” clicking it should give the JFrame its
big dimensions.
EXERCISE 4.23 Challenge: Design and write a Java GUI application that allows
the user to change the JFrame ’s background color to one of three choices, indi-
cated by buttons. Like all other Java Component s,JFrame ’s have an associated
background color, which can be set by the following commands:
☛ ✟
setBackground ( Color . red ) ;
setBackground ( Color . yellow ) ;
✡ ✠
ThesetBackground() method is deﬁned in the Component class, and 13
primary colors— black ,blue ,cyan ,darkGray ,gray ,green ,lightGray ,
magenta ,orange ,pink ,red,white ,yellow —are deﬁned in the java.awt.Color
class.
ADDITIONAL EXERCISES
EXERCISE 4.24 Given the classes with the following headers
☛ ✟
public c l a s s Animal . . .
public c l a s s DomesticAnimal extends Animal . . .
public c l a s s FarmAnimal extends DomesticAnimal . . .
public c l a s s HousePet extends DomesticAnimal . . .
public c l a s s Cow extends FarmAnimal . . .
public c l a s s Goat extends FarmAnimal . . .
public c l a s s DairyCow extends Cow . . .
✡ ✠
draw a UML class diagram representing the hierarchy created by these
declarations.
CHAPTER 4 •Exercises 197
EXERCISE 4.25 Given the preceding hierarchy of classes, which of the following
are legal assignment statements?
☛ ✟
DairyCow dc = new FarmAnimal ( ) ;
FarmAnimal fa = new Goat ( ) ;
Cow c1 = new DomesticAnimal ( ) ;
Cow c2 = new DairyCow ( ) ;
DomesticAnimal dom = new HousePet ( ) ;
✡ ✠
198 CHAPTER 4 •Input/Output: Designing the User Interface
OBJECTIVES
After studying this chapter, you will
•Understand the role that data play in effective program desi gn.
•Be able to use all of Java’s primitive types and their operato rs.
•Appreciate the importance of information hiding.
•Be able to use class constants and class methods.
•Know how to use Java’s Math andNumberFormat classes.
•Be able to perform various kinds of data conversions.
OUTLINE
5.1 Introduction
5.2 Boolean Data and Operators
Special Topic: Are We Computers?
5.3 Numeric Data and Operators
5.4 From the Java Library: java.lang.Math
5.5 Numeric Processing Examples
5.6 From the Java Library: java.text.NumberFormat
5.7 Character Data and Operators
5.8 Example: Character Conversions
5.9 Problem Solving = Representation + Action
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 5
Java Data and Operators
199
200 CHAPTER 5 •Java Data and Operators
Figure 5.1: Can the chess board be
tiled with dominoes?
5.1 Introduction
This chapter has two primary goals. One is to elaborate on Jav a’sprim-
itive data types , which were ﬁrst introduced in Chapter 1. We will cover
boolean, integer, character, and real number data types, in cluding the var-
ious operations that you can perform on these types. We will p rovide ex-
amples, including several modiﬁcations of the OneRowNim class, to show
typical uses of the various data types.
Our second goal is to illustrate the idea that programming is a matter of
choosing an appropriate way to represent a problem as well as choosing
an appropriate sequence of actions to solve the problem. Pro gramming
is a form of problem solving that can be viewed as a two-part pr ocess:
representation and action .
Representation means ﬁnding a way to look at the problem. This might
involve seeing the problem as closely related to a known prob lem or see-
ing that parts of the problem can be broken up into smaller pro blems
that you already know how to solve. In terms of programming pro b-
lems, representation often means choosing the right kinds o f objects and
structures.
Action is the process of taking well-deﬁned steps to solve a problem .
Given a particular way of representing the problem, what ste ps must we
take to arrive at its solution?
Choosing an appropriate representation is often the key to s olving a
problem. For example, consider this problem: Can a chess boa rd, with
its top-left and bottom-right squares removed, be complete ly tiled by
dominoes that cover two squares at a time?
One way to solve this problem might be to represent the chess b oard
and dominoes as shown in Figure 5.1. If we represent the board i n this
way, then the actions needed to arrive at a solution involve s earching for
a tiling that completely covers the board. In other words, we c an try one
way of placing the dominoes on the board. If that doesn’t work, we try an-
other way. And so on. This process will be very time consuming , because
there are millions of different ways of trying to tile the boa rd.
An alternative way to represent this problem comes from seei ng that
the top-left and bottom-right squares of the board are both w hite. If you
remove them, you’ll have a board with 62 squares, 32 black and 30 white.
Because each domino must cover one white and one black square , it is
SECTION 5.2 •Boolean Data and Operators 201
impossible to tile a board with an unequal number of black and white
squares.
Thus, by representing the problem as the total number of blac k and
white squares, the actions required to solve it involve a ver y simple rea-
soning process. This representation makes it almost trivia l to ﬁnd the so-
lution. On the other hand, the brute force representation presented ﬁrst—
trying all possible combinations—made it almost impossible to solve the
problem.
5.2 Boolean Data and Operators
As we learned in Chapter 1, the boolean type is one of Java’s primitive
types. For this type, there are only two possible values, true andfalse .
Theboolean type is derived from the work of British mathematician
George Boole, who in the 1850s, developed an algebra to proce ss logical George Boole
expressions such as p and q . Such boolean expressions produce a value that is
either true orfalse. Every modern programming language provides some
means of representing boolean expressions.
Theboolean type has several important uses. As we saw in Chap-
ter 1, expressions of the form num == 7 and5 < 7 haveboolean val-
ues. Similarly, as we saw in Chapter 3, the boolean type is also used to Conditional statement
represent the condition in the if statement:
if(boolean expression )
statement ;
For this reason, boolean expressions are also called conditions . Along these
same lines, a boolean variable can be used as a ﬂagor asignal to “remem-
ber” whether or not a certain condition holds. For example, i n the follow- Boolean ﬂag
ing code fragment, we use isDone to mark when a particular process is
completed:
☛ ✟
boolean isDone = f a l s e ;// I n i t i a l i z e t h e f l a g
. . . // Do s o m e p r o c e s s i n g t a s k
isDone = true ; // S e t f l a g when t h e t a s k d o n e
. . . // Do s o m e o t h e r s t u f f
i f( isDone ) // C h e c k i f f i n i s h e d t h e t a s k
. . . // I f s o , d o s o m e t h i n g
else
. . . // Or , d o s o m e t h i n g e l s e
✡ ✠
5.2.1 Boolean (or Logical) Operations
Like all the other simple data types, the boolean type consists of certain Data and operations
data—the values true andfalse —and certain actions or operations that
can be performed on those data. For the boolean type there are four basic
operations: AND (signiﬁed by &&), OR (signiﬁed by ||), EXCLUSIVE-OR
(signiﬁed by ∧), and NOT (signiﬁed by !). These are deﬁned in the truth
table shown in Table 5.1. A truth tables deﬁnes boolean operators b y giving
their values in all possible situations. The ﬁrst two column s of the table
202 CHAPTER 5 •Java Data and Operators
give possible boolean values for two operands ,o1ando2. An operand is
a value used in an operation. Note that each row gives a differ ent value
assignment to the two operands, so that all possible assignm ents are repre-
sented. The remaining columns give the values that result fo r the various
operators given the assignment of values to o1ando2.
TABLE 5.1 Truth-table deﬁnitions of the boolean operators:
AND (&&), OR ( ||), EXCLUSIVE-OR ( ∧), and NOT (!)
o1 o2 o1 && o2 o1 ||o2 o1∧o2 !o1
true true true true false false
true false false true true false
false true false true true true
false false false false false true
To see how to read this table, let’s look at the AND operation, which is
deﬁned in column 3. The AND operator is a binary operator —that is, it
requires two operands, o1and o2. If both o1and o2are true, then ( o1&& Binary operator
o2) is true (row1). If either o1oro2or both o1and o2are false, then the
expression ( o1&&o2) is false (rows 2 and 3). The only case in which ( o1
&&o2) is true is when both o1and o2are true (row 4).
The boolean OR operation (column 4 of Table 5.1) is also a bina ry oper-
ation. If both o1and o2are false, then (o1||o2)is false (row 4). If either o1
oro2or both o1and o2are true, then the expression (o1||o2)is true (rows
1-3). Thus, the only case in which (o1||o2)is false is when both o1and o2
are false.
The boolean EXCLUSIVE-OR operation (column 5 of Table 5.1) is a bi-
nary operation, which differs from the OR operator in that it is true when
either o1oro2is true (rows 2 and 3), but it is false when both o1and o2are
true (row 1).
The NOT operation (the last column of Table 5.1) is a unary operator — Unary operator
it takes only one operand—and it simply reverses the truth val ue of its
operand. Thus, if o1is true, ! o1is false, and vice versa.
5.2.2 Precedence and Associativity
In order to evaluate complex boolean expressions, it is neces sary to un-
derstand the order in which boolean operations are carried o ut by the
computer. For example, what is the value of the following exp ression?
☛ ✟
true||true && f a l s e
✡ ✠
The value of this expression depends on whether we evaluate t he||ﬁrst
or the && ﬁrst. If we evaluate the ||ﬁrst, the expression’s value will be
false; if we evaluate the && ﬁrst, the expression’s value wil l be true. In
SECTION 5.2 •Boolean Data and Operators 203
the following example, we use parentheses to force one opera tion to be
done before the other:
☛ ✟
EXPRESSION EVALUATION
−−−−−−−−−− −−−−−−−−−−
(true||true ) && f a l s e ==>true && f a l s e ==>f a l s e
true||(true && f a l s e ) ==>true||f a l s e ==>true
✡ ✠
As these evaluations show, we can use parentheses to force on e operator
or the other to be evaluated ﬁrst. However, in Java, the && oper ator has Parentheses supersede
higher precedence than the ||operator. Therefore, the second alternative
corresponds to the default interpretation that Java would a pply to the ex-
pression that has no parentheses. In other words, given the ex pression
true||true&&false , the AND operation would be evaluated before the
OR operation even though the OR operator occurs ﬁrst (i.e., t o the left) in
the unparenthesized expression.
TABLE 5.2 Precedence order of the boolean operators
Precedence Order Operator Operation
1 ( ) Parentheses
2 ! NOT
3 ∧ EXCLUSIVE-OR
4 && AND
5 || OR
As this example illustrates, the boolean operators have a bu ilt-in prece-
dence order which is used to determine how boolean expressions are to be
evaluated (Table 5.2). A simple method for evaluating an exp ression is to
parenthesize the expression and then evaluate it. For examp le, to evaluate
the complex expression
☛ ✟
true||!f a l s e ˆf a l s e && true
✡ ✠
we would ﬁrst parenthesize it according to the precedence ru les set out in
Table 5.2, which gives the following expression:
☛ ✟
true||( ( ( ! f a l s e ) ˆ f a l s e ) && true )
✡ ✠
204 CHAPTER 5 •Java Data and Operators
We can then evaluate this fully parenthesized expression, s tep by step,
starting at the innermost parentheses:
☛ ✟
Step 1 . true||( (true ˆf a l s e ) && true )
Step 2 . true||(true && true )
Step 3 . true||true
Step 4 . true
✡ ✠
JAVA PROGRAMMING TIP Parentheses. Parentheses can (and
should) be used to clarify any expression that appears ambig uous or
to override Java’s default precedence rules.
In addition to operator precedence, it is necessary to know ab out an
operator’s associativity in order to evaluate boolean expressions of
the form (op1||op2||op3). Should this expression be evaluated as
((op1||op2)||op3)or as(op1||(op2||op3))? The binary boolean opera-
tors all associate from left to right. Thus, the expressions
☛ ✟
true ˆtrue ˆtrue // S a m e a s : ( t r u e ˆ t r u e ) ˆ t r u e
true && true && true // S a m e a s : ( t r u e && t r u e ) && t r u e
true||true||true // S a m e a s : ( t r u e | | t r u e ) | | t r u e
✡ ✠
would be evaluated as follows:
☛ ✟
EXPRESSION EVALUATION
−−−−−−−−−−−−−−−− −−−−−−−−−−−−−−−−−
(true ˆtrue ) ˆ true ==>f a l s e ˆtrue ==>true
(true && true ) && true ==>true && true ==>true
(true||true )||true ==>true||true ==>true
✡ ✠
5.2.3 Short-Circuit Evaluation
Another important feature of the boolean operators is that t hey utilize a
form of evaluation known as short-circuit evaluation . Inshort-circuit eval-
uation , a boolean expression is evaluated from left to right, and th e evalu-
ation is discontinued as soon as the expression’s value can b e determined,
regardless of whether it contains additional operators and operands. For
example, in the expression
☛ ✟
expr1 && expr2
✡ ✠
ifexpr1 is false, then the AND expression must be false, so expr2 need
not evaluated. Similarly, in the expression
☛ ✟
expr1||expr2
✡ ✠
ifexpr1 is true, then the OR expression must be true, so expr2 need not
evaluated.
SECTION 5.2 •Boolean Data and Operators 205
In addition to being a more efﬁcient form of evaluating boolea n ex-
pressions, short-circuit evaluation has some practical us es. For example,
we can use short-circuit evaluation to guard against null po inter excep-
tions. Recall from Chapter 2 that a null pointer exception re sults when
you try to use an uninstantiated reference variable—that is, a reference
variable that has not been assigned an object. For example, if we declare a
OneRowNim variable without instantiating it and then try to use it, a nu ll
pointer exception will result:
☛ ✟
OneRowNim game ; // U n i n s t a n t i a t e d R e f e r e n c e
i f( ! game . gameOver ( ) ) // N u l l p o i n t e r e x c e p t i o n
game . t a k e S t i c k s (num ) ;
✡ ✠
In this code, a null pointer exception results when we use game in the
method call game.gameOver() . We can use short-circuit evaluation to
prevent the exception from occurring:
☛ ✟
i f( ( game != null ) && ( ! game . gameOver ( ) )
game . t a k e S t i c k s (num ) ;
✡ ✠
In this case, because game != null is false, neither method call involv-
inggame is made, thus avoiding the exception.
SELF-STUDY EXERCISE
EXERCISE 5.1 Suppose the following variable declarations are made:
☛ ✟
boolean A = true , B = true , C = true ;
boolean X = false , Y = false , Z = f a l s e ;
✡ ✠
Given these declarations, evaluate each of the following ex pressions
(don’t forget to take operator precedence and associativit y into account):
a.A || B && Z
b.A ˆ X && Z
c.A ˆ X || Cd.!A && !B
e.A && B && X && Y
f.(!X ˆ A) && (B ˆ !Y)
Special Topic: Are We Computers?
George Boole published his seminal work, An Investigation of the Laws
of Thought , in 1854. His achievement was in developing an algebra for
logic—that is, a purely abstract and symbolic system for repr esenting the
laws of logic. Boole’s was not the ﬁrst attempt to explore the relationship
between the human mind and an abstract system of computation . Back in
1655, Thomas Hobbes had already claimed that all thought was c omputa-
tion.
It is estimated that the human brain contains ( 1012=10,000,000,000,000)
neurons , and each neuron contains something like 10,000 dendrites , the
ﬁbers that connect one neuron to another. Together, the neur ons and den-
drites make up a web of enormous complexity. Since the 1840s i t has been
known that the brain is primarily electrical, and by the 1940 s scientists
206 CHAPTER 5 •Java Data and Operators
had developed a pretty good model of the electrical interact ions among
neurons. According to this model, neurons emit short bursts of electricity
along their axons , which function like output wires. The bursts leap over
the gap separating axons and dendrites, which function like the neurons’
input wires.
In 1943, just before the ﬁrst digital computers were developed , War-
ren McCulloch, a neurophysiologist, and Walter Pitts, a mat hematician,
published a paper titled, “A Logical Calculus of the Ideas Immi nent in
Nervous Activity.” In this paper, they showed that all of the b oolean
operators—AND, OR, NOT, and EXCLUSIVE-OR—could be represente d
by the behavior of small sets of neurons. For example, they sh owed that
three neurons could be connected together in such a way that t he third
neuron ﬁred if and only if both of the other two neurons ﬁred. T his is
exactly analogous to the deﬁnition of the boolean AND operat or.
A few years later, when the ﬁrst computers were built, many sc ientists
and philosophers were struck by the similarity between the l ogic elements
that made up the computer’s circuits and the neuronal models that Mc-
Culloch and Pitts had developed.
The area of neural networks is a branch of artiﬁcial intellig ence (one
of the applied areas of computer science) and is based on this insight by
McCulloch and Pitts. Researchers in this exciting and rapid ly advancing
ﬁeld develop neural network models of various kinds of human thinking
and perception.
5.2.4 Using Booleans in OneRowNim
Now that we have introduced the boolean data type, let’s use it to im-
prove the OneRowNim class, the latest version of which, from Chapter 3,
is given in Figure 3.16. Previously we used an int variable, player ,
to represent who’s turn it is. For a two-person game, such as O ne Row
Nim, a boolean variable is well suited for this purpose, because it can
toggle between true and false. For example, let’s declare a v ariable,
onePlaysNext , and initialize it to true, to represent the fact that player
one will play ﬁrst:
☛ ✟
private boolean onePlaysNext = true ;
✡ ✠
When onePlaysNext is true, it will be player one’s turn. When it is
false, it will be player two’s turn. Note that we are delibera tely remaining
uncommitted as to whether one or the other player is the compu ter.
Given this new variable, it is necessary to redeﬁne the metho ds that
had previously used the player variable. The ﬁrst method that needs
revision is the constructor:
☛ ✟
public OneRowNim( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ;
onePlaysNext = ( s t a r t e r == 1 ) ;
} // OneRowNim ( ) c o n s t r u c t o r 3
✡ ✠
SECTION 5.3 •Numeric Data and Operators 207
In the constructor, the starter parameter is used with a value of 1 or 2 to
set which player goes ﬁrst. Note how we use an assignment stat ement to
setonePlaysNext to true if starter equals 1; otherwise it is set to false.
The assignment statement ﬁrst evaluates the expression on i ts right hand
side (starter == 1 ). Because this is a boolean expression, it will have
a value of true or false, which will be assigned to onePlaysNext . Thus,
the assignment statement is equivalent to the following if/ else statement:
☛ ✟
i f( player == 1)
onePlaysNext = true ;
else
onePlaysNext = f a l s e ;
,
✡ ✠
The remaining changes are shown in Figure 5.2. There are only two in-
stance methods that need revision to accommodate the use of boolean
variables. The takeSticks() method contains two revisions. The ﬁrst
uses the boolean OR operator to test whether a move is valid:
☛ ✟
public boolean t a k e S t i c k s ( i n t num)
{ i f(num<1||num>3||num>n S t i c k s )
return f a l s e ; // E r r o r
else // V a l i d move
{ n S t i c k s = n S t i c k s −num;
onePlaysNext = ! onePlaysNext ;
return true ;
}// e l s e
}// t a k e S t i c k s ( )
✡ ✠
It also uses the boolean NOT operator to toggle the value of
onePlaysNext , to switch to the other player’s turn:
☛ ✟
onePlaysNext = ! onePlaysNext ;
✡ ✠
Finally, the getPlayer() method now uses a if/else statement to return
either 1 or 2 depending on who’s turn it is:
☛ ✟
public i n t getPlayer ( )
{ i f( onePlaysNext )
return 1 ;
else return 2 ;
}// g e t P l a y e r ( )
✡ ✠
5.3 Numeric Data and Operators
Java has two kinds of numeric data: integers, which have no fr actional
part, and real numbers or ﬂoating-point numbers , which contain a frac-
tional component. Java recognizes four different kinds of i ntegers: byte ,
short ,int, andlong , which are distinguished by the number of bits
208 CHAPTER 5 •Java Data and Operators
☛ ✟
public c l a s s OneRowNim
{ private i n t n S t i c k s = 7 ;
private boolean onePlaysNext = true ;
public OneRowNim ( )
{
}// OneRowNim ( ) c o n s t r u c t o r 1
public OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
} // OneRowNim ( ) c o n s t r u c t o r 2
public OneRowNim( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ;
onePlaysNext = ( s t a r t e r == 1 ) ;
} // OneRowNim ( ) c o n s t r u c t o r 3
public boolean t a k e S t i c k s ( i n t num)
{ i f(num<1||num>3||num>n S t i c k s )
return f a l s e ; // E r r o r
else // V a l i d move
{ n S t i c k s = n S t i c k s −num;
onePlaysNext = ! onePlaysNext ;
return true ;
}// e l s e
}// t a k e S t i c k s ( )
public i n t g e t S t i c k s ( )
{ return n S t i c k s ;
} {\ c o l o r{cyan}// g e t S t i c k s ( ) }
public i n t getPlayer ( )
{ i f( onePlaysNext ) return 1 ;
else return 2 ;
}// g e t P l a y e r ( )
public boolean gameOver ( )
{ return ( n S t i c k s <= 0 ) ;
}// g a m e O v e r ( )
public i n t getWinner ( )
{ i f( n S t i c k s <1)return getPlayer ( ) ;
else return 0 ; // g a m e i s n o t o v e r
}// g e t W i n n e r ( )
public void report ( )
{ System . out . p r i n t l n ( ”Number of s t i c k s l e f t : ”
+ g e t S t i c k s ( ) ) ;
System . out . p r i n t l n ( ”Next turn by player ”
+ getPlayer ( ) ) ;
} // r e p o r t ( )
}// OneRowNim c l a s s
✡ ✠
Figure 5.2: The revised OneRowNim uses aboolean variable to keep track
of who’s turn it is.
used to represent them. A binary digit , orbit, is a 0 or a 1. (Recall that
computers read instructions as series of 0s and 1s.) Java has two different
kinds of real numbers, float anddouble , which are also distinguished
by the number of bits used to represent them. See Table 5.3.
SECTION 5.3 •Numeric Data and Operators 209
TABLE 5.3 Java’s numeric types
Type Bits Range of Values
byte 8 −128to+127
short 16 −32768 to32767
int 32 −2147483648 to2147483647
long 64 −263to263−1
ﬂoat 32 −3.40292347 E+38to+3.40292347 E+38
double 64−1.79769313486231570 E+308to+1.79769313486231570 E+308
The more bits a data type has, the more values it can represent . One bit
can represent two possible values, 1 and 0, which can be used t o stand for
true and false, respectively. Two bits can represent four po ssible values:
00, 01, 10, and 11; three bits can represent eight possible va lues: 000, 001,
010, 100, 101, 110, 011, 111. And, in general, an n-bit quantity can represent
2ndifferent values.
As illustrated in Table 5.3, the various integer types repre sent posi-
tive or negative whole numbers. Perhaps the most commonly us ed in-
teger type in Java is the int type, which is represented in 32 bits. This
means that Java can represent 232different int values, which range from
−2,147,483,648to2,147,483,647, that is, from −231to(231−1). Similarly,
an 8-bit integer, a byte , can represent 28or 256 different values, ranging Integer data types
from−128to+127. A 16-bit integer, a short , can represent 216different
values, which range from −32768 to32767 . And a 64-bit integer, a long ,
can represent whole number values ranging from −263to263−1.
For ﬂoating-point numbers, a 32-bit float type can represent 232dif-
ferent real numbers and a 64-bit double value can represent 264different
real numbers.
JAVA EFFECTIVE DESIGN Platform Independence. In Java, a data
type’s size (number of bits) is part of its deﬁnition and, the refore,
remains consistent across all platforms. In C and C++, the siz e of a
data type is dependent on the compiler.
It is worth noting that just as model airplanes are representat ions of
real airplanes, Java’s numeric types are representations o r models of the Data types are abstractions
numbers we deal with in mathematics. In designing Java’s data types,
various trade-offs have been made in order to come up with pra ctical
implementations.
One trade-off is that the set of integers is inﬁnite, but Java ’sint type
can only represent a ﬁnite number of values. Similarly, Java cannot Representation trade-offs
represent the inﬁnite number of values that occur between, s ay, 1.111 and
1.112. So, certain real numbers cannot be represented at all . For exam-
ple, because Java uses binary numbers to represent its numer ic types, one
number that cannot be represented exactly is1
10. This inability to exactly
represent a value is known as round-off error . Being unable to represent
certain values can cause problems in a program. For example, it might be
difﬁcult to represent dollars and cents accurately in a prog ram. Round-off error
210 CHAPTER 5 •Java Data and Operators
Another source of problems in dealing with numeric data is du e to lim-
its in their precision. For example, a decimal number repres ented as a
double value can have a maximum of 17 signiﬁcant digits , and a float
can have a maximum 8. A signiﬁcant digit is one that contribut es to
the number’s value. If you tried to store values such as 12345. 6789 or
0.123456789 in a float variable, they would be rounded off to 12345.679
and 0.12345679, respectively, causing a possible error.
JAVA DEBUGGING TIP Signiﬁcant Digits. In using numeric data,
be sure the data type you choose has enough precision to repre sent the
values your program needs.
SELF-STUDY EXERCISES
EXERCISE 5.2 List all of the binary values that can be represented in 4
bits—that is, all values in the range 0000 to 1111.
EXERCISE 5.3 If a 6-bit representation were used for an integer type,
how many different integers could be represented?
EXERCISE 5.4 If you were writing a program to process scientiﬁc data
that had to be accurate to at least 12 signiﬁcant (decimal) di gits, what type
of data would you use?
5.3.1 Numeric Operations
The operations that can be done on numeric data include the st andard
algebraic operations: addition (+),subtraction (−),multiplication (*),division
(/), as well as the modulus (%) operator. Note that in Java, the multiplica-
tion symbol is *and not the ×. The arithmetic operators are binary op-
erators, meaning that they each take two operands. Table 5.4 compares Numeric operators
TABLE 5.4 The standard arithmetic operators in Java
Operation Operator Java Algebra
Addition + x+2x+2
Subtraction − m−2m−2
Multiplication *m*2 2mor2×m
Division /x/y x÷yorx
y
Modulus % x%y x moduloy(for integers xandy)
expressions involving the Java operators with their standa rd algebraic
counterparts.
Although these operations should seem familiar, there are s ome im-
portant differences between their use in algebra and their u se in a Java
program. Consider the following list of expressions:
☛ ✟
3 / 2 == > value 1 An i n t e g e r r e s u l t
3 . 0 / 2 . 0 == > value 1 . 5 A f l o a t i n g −point r e s u l t
3 / 2 . 0 == > value 1 . 5 A f l o a t i n g −point r e s u l t
3 . 0 / 2 == > value 1 . 5 A f l o a t i n g −point r e s u l t
✡ ✠
SECTION 5.3 •Numeric Data and Operators 211
In each of these cases we are dividing the quantity 3 by the quan tity 2.
However, different results are obtained depending on the type of the
operands involved. When both operands are integers, as in (3/ 2), the
result must also be an integer. Hence, (3/2) has the value 1, an integer.
Because integers cannot have a fractional part, the 0.5 is si mply discarded.
Integer division (/) always gives an integer result. Thus, th e value of (6/2) Integer division gives an integer
result is 3 and the value of (7/2) is also 3. Because 3.5 is not an integ er, the result
of dividing 7 by 2 cannot be 3.5.
JAVA DEBUGGING TIP Integer Division. A common source of
error among beginning programmers is forgetting that integ er
division always gives an integer result.
On the other hand, when either operand is a real number, as in t he last
three cases, the result is a real number. Thus, while the same symbol (/)
is used for dividing integers and real numbers, there are rea lly two dif-
ferent operations involved here: integer division and ﬂoating-point division .
Using the same symbol (/) for different operations (integer division and
real division) is known as operator overloading . It is similar to method
overloading, which was discussed in Chapter 3.
What if you want to keep the remainder of an integer division? J ava
provides the modulus operator (%), which takes two operands . The ex- Modular arithmetic
pression (7 % 5) gives the remainder after dividing 7 by 5—2 in t his case.
In general, the expression (m%n)(read mmod n) gives the remainder
after mis divided by n. Here are several examples:
☛ ✟
7 % 5 == >7 mod 5 equals 2
5 % 7 == >5 mod 7 equals 5
−7 % 5 == >−7 mod 5 equals −2
7 %−5 ==>7 mod−5 equals 2
✡ ✠
The best way to interpret these examples is to perform long di vision on
the operands keeping both the quotient and the remainder. Fo r example,
when you do long division on −7÷5, you get a quotient of -1 and a re-
mainder of -2. The quotient is the value of −7/5and the remainder is the
value of −7%5. When you do long division on 7÷−5, you get a quotient
of -1 and a remainder of 2. The quotient is the value of 7/−5and the
remainder is the value of 7%−5.
We will encounter many practical uses for the modulus operat or in our
programs. For a simple example, we use it when we want to deter mine
whether an integer is even or odd. Numbers that leave a 0 remai nder
when divided by 2 are even:
☛ ✟
i f(N % 2 == 0)
System . out . p r i n t l n (N + ” i s even” ) ;
✡ ✠
More generally, we could use the mod operator to deﬁne divisi bility by 3,
4, 10, or by any number.
212 CHAPTER 5 •Java Data and Operators
Numeric Promotion Rules
Java is considered a strongly typed language because all expressions in
Java, such as (3/2), have a type associated with them. In cases where Expressions have a type
one arithmetic operand is an integer and one is a ﬂoating-poin t num-
ber, Java promotes the integer into a ﬂoating-point value and performs a
ﬂoating-point operation.
Promotion is a matter of converting one type to another type. For ex-
ample, in the expression (5 + 4.0), the value 5 must be promote d to 5.0
before ﬂoating-point addition can be performed on (5.0 + 4.0) . Generally
speaking, automatic promotions such as these are allowed in Java when-
ever it is possible to perform the promotion without loss of information . Be-
cause an integer (5) does not have a fractional component, no information
will be lost in promoting it to a real number (5.0). On the othe r hand, you
cannot automatically convert a real number (5.4) to an integ er (5) because
that might lead to loss of information. This leads to the foll owing rule:
JAVA LANGUAGE RULE Integer Promotion. In an operation that
contains an integer and a ﬂoating-point operand, the integer is
promoted to a ﬂoating-point value before the operation is performed.
This rule is actually an instance of a more general rule, for w henever an
expression involves operands of different types, some oper ands must be
converted before the expression can be evaluated. Consider the following
example:
☛ ✟
byte n = 1 2 5 ;
short m = 32000;
n∗m;
✡ ✠
In this case, (n * m) involves two different integer types, byte andshort .
Before evaluating this expression Java must ﬁrst promote th ebyte to a
short and carry out the operation as the multiplication of two short s.
Conversion of short tobyte would not be possible because there’s no
way to represent the value 32000 as a byte .
It is important to note that this conversion rule applies rega rdless of
the actual values of the operands. In applying the rule, Java l ooks at the
operand’s type, not its value. So even if mwere assigned a value that
could be represented as a byte (for example, 100), the promot ion would Promotion is automatic
still go from smaller to larger type. This leads to following the general
rule:
JAVA LANGUAGE RULE Type Promotion. In general, when two
different types are involved in an operation, the smaller ty pe—the one
with fewer bits—is converted to the larger type before the ope ration is
performed. To do otherwise would risk losing information.
Table 5.5 summarizes the actual promotion rules used by Java in evaluat-
ing expressions involving mixed operands. Note that the las t rule implies
that integer expressions involving byte orshort orint are performed
SECTION 5.3 •Numeric Data and Operators 213
asint. This explains why integer literals—such as 56or−108—are rep-
resented as int types in Java.
TABLE 5.5 Java promotion rules for mixed arithmetic operators.
If two rules apply, choose the one that occurs ﬁrst in this table.
If either operand is The other is promoted to
double double
float float
long long
byte orshort int
SELF-STUDY EXERCISES
EXERCISE 5.5 Evaluate each of the following integer expressions:
a.8 / 2
b.9 / 2
c.6 / 8d.9 % 2
e.8 % 6
f.6 % 8g.8 % 4
h.4 % 8
EXERCISE 5.6 Evaluate each of the following expressions, paying spe-
cial attention to the type of the result in each case:
a.8 / 2.0
b.9 / 2.0c.6 / 8
d.0.0 / 2e.8.0 / 6.0
EXERCISE 5.7 Suppose that the following variable declarations are
made:
☛ ✟
byte m = 3 ; short n = 4 ; i n t p = 5 ;
long q = 6 ; double r = 7 . 0 ;
✡ ✠
Use type promotion rules to determine the type of expression and then
evaluate each of the following expressions:
a.m + n
b.p*qc.m + n + r
d.p*q*me.r - m
5.3.2 Operator Precedence
The built-in precedence order for arithmetic operators is s hown in Ta-
ble 5.6. Parenthesized expressions have highest precedenc e and are evalu-
TABLE 5.6 Precedence order of the arithmetic operators
Precedence
Order Operator Operation
1 () Parentheses
2 ∗/% Multiplication, Division, Modulus
3 +− Addition, Subtraction
ated ﬁrst. Next come the multiplication, division, and modu lus operators,
followed by addition and subtraction. When we have an unparen thesized
214 CHAPTER 5 •Java Data and Operators
expression that involves both multiplication and addition , the multiplica-
tion would be done ﬁrst, even if it occurs to the right of the pl us sign. Op-
erators at the same level in the precedence hierarchy are eva luated from
left to right. For example, consider the following expressi on:
☛ ✟
9 + 6−3∗6 / 2
✡ ✠
In this case, the ﬁrst operation to be applied will be the multi plication (*),
followed by division (/), followed by addition (+), and then ﬁnally the
subtraction ( −). We can use parentheses to clarify the order of evaluation.
A parenthesized expression is evaluated outward from the in nermost set
of parentheses:
☛ ✟
Step 1 . ( (9 + 6) −( ( 3∗6) / 2 ) )
Step 2 . ( (9 + 6) −(18 / 2 ) )
Step 3 . ( (9 + 6) −9 )
Step 4 . ( 15 −9 )
Step 5 . 6
✡ ✠
Parentheses can (and should) always be used to clarify the or der of oper-
ations in an expression. For example, addition will be perfo rmed before
multiplication in the following expression:
☛ ✟
( a + b ) ∗c
✡ ✠
Another reason to use parentheses is that Java’s precedence and promo-
tion rules will sometimes lead to expressions that look ﬁne b ut contain
subtle errors. For example, consider the following express ions:
☛ ✟
System . out . p r i n t l n ( 5 / 3 / 2 . 0 ) ; // 0 . 5
System . out . p r i n t l n ( 5 / ( 3 / 2 . 0 ) ) ; // 3 . 3 3
✡ ✠
The ﬁrst gives a result of 0.5, but the use of parentheses in th e second
gives a result of 3.33. If the second is the expected interpret ation, then the
parentheses here helped avoid a subtle semantic error.
JAVA PROGRAMMING TIP Parenthesize! To avoid subtle bugs
caused by Java’s precedence and promotion rules, use parent heses to
specify the order of evaluation in an expression.
SELF-STUDY EXERCISE
EXERCISE 5.8 Parenthesize and then evaluate each of the expressions
that follow, taking care to observe operator precedence rul es. Watch for
subtle syntax errors.
a.4 + 5.0 *6
b.(4 + 5) *6
c.4 + 5 / 6d.(4 + 5) / 6
e.4 + 5 % 3
f.(4 + 5) % 3g.9 % 2 *7 / 3
h.5.0 / 2 *3
SECTION 5.3 •Numeric Data and Operators 215
5.3.3 Increment and Decrement Operators
Java provides a number of unary operators that are used to inc rement or
decrement an integer variable. For example, the expression k++ uses the
increment operator ++ to increment the value of the integer variable k. The
expression k++ is equivalent to the following Java statements:
☛ ✟
i n t k ;
k = k + 1 ; // Add 1 t o k a n d a s s i g n t h e r e s u l t b a c k t o k
✡ ✠
The unary ++operator applies to a single integer operand, in this case to
the variable k. It increments k’s value by 1 and assigns the result back to k.
It may be used either as a preincrement or a postincrement operator. In the Preincrement and postincrement
expression k++, the operator follows the operand, indicating that it is being
used as a postincrement operator. This means that the increment operation
is done after the operand’s value is used.
Contrast that with the expression ++k in which the ++operator precedes
its operand. In this case, it is used as a preincrement operator, which means
that the increment operation is done before the operand’s value is used.
When used in isolation, there is no practical difference betw een k++
and ++k. Both are equivalent to k = k + 1 . However, when used in con-
junction with other operators, there is a signiﬁcant differe nce between
preincrement and postincrement. For example, in the follow ing code
segment,
☛ ✟
i n t j = 0 , k = 0 ; // I n i t i a l l y b o t h j a n d k a r e 0
j = ++k ; // F i n a l v a l u e s o f b o t h j a n d k a r e 1
✡ ✠
the variable kis incremented before its value is assigned to j. After execu- Precedence order
tion of the assignment statement, jwill equal 1 and kwill equal 1. The
sequence is equivalent to
☛ ✟
i n t j = 0 , k = 0 ; // I n i t i a l l y b o t h j a n d k a r e 0
k = k + 1 ;
j = k ; // F i n a l v a l u e s o f b o t h j a n d k a r e 1
✡ ✠
However, in the following example,
☛ ✟
i n t i = 0 , k = 0 ; // I n i t i a l l y b o t h i a n d k a r e 0
i = k++; // F i n a l v a l u e o f i i s 0 a n d k i s 1
✡ ✠
the variable kis incremented after its value is assigned to i. After execution
of the assignment statement, iwill have the value 0 and kwill have the
value 1. The preceding sequence is equivalent to
☛ ✟
i n t i = 0 , k = 0 ; // I n i t i a l l y b o t h i a n d k a r e 0
i = k ;
k = k + 1 ; // F i n a l v a l u e o f i i s 0 a n d k i s 1
✡ ✠
In addition to the increment operator, Java also supplies the decrement op- Predecrement and postdecrement
216 CHAPTER 5 •Java Data and Operators
erator−−, which can also be used in the predecrement and postdecremen t
forms. The expression −−kwill ﬁrst decrement k’s value by 1 and then
usekin any expression in which it is embedded. The expression k−−will
use the current value of kin the expression in which kis contained and
then it will decrement k’s value by 1. Table 5.7 summarizes the increment
and decrement operators. The unary increment and decrement operators
have higher precedence than any of the binary arithmetic ope rators.
TABLE 5.7 Java’s increment and decrement operators
Expression Operation Interpretation
j=++k Preincrement k=k+1;j=k;
j=k++ Postincrement j=k;k=k+1;
j=−−k Predecrement k=k−1;j=k;
j=k−− Postdecrement j=k;k=k−1;
JAVA LANGUAGE RULE Pre- and Postincrement/Decrement. If
an expression like ++k or−−koccurs in an expression, kis
incremented or decremented before its value is used in the rest of the
expression. If an expression like k++ ork−−occurs in an expression, k
is incremented or decremented after its value is used in the rest of the
expression.
JAVA PROGRAMMING TIP Increment and Decrement
Operators. Because of their subtle behavior, be careful in how you use
the unary increment and decrement operators. They are most
appropriate and useful for incrementing and decrementing l oop
variables, as we’ll see later.
SELF-STUDY EXERCISE
EXERCISE 5.9 What value will jand khave after each of the calcula-
tions that follow? Assume that khas the value 0 and jhas the value 5
before each operation is performed.
a.k = j;
b.k = j++;c.k = ++j;
d.k = j--;e.k = --j;
5.3.4 Assignment Operators
In addition to the simple assignment operator (=), Java suppl ies a num-
ber of shortcut assignment operators that allow you to combi ne an arith-
metic operation and an assignment in one operation. These op erations
can be used with either integer or ﬂoating-point operands. Fo r example,
the+=operator allows you to combine addition and assignment into one
expression. The statement
☛ ✟
k += 3 ;
✡ ✠
SECTION 5.3 •Numeric Data and Operators 217
is equivalent to the statement
☛ ✟
k = k + 3 ;
✡ ✠
Similarly, the statement
☛ ✟
r += 3 . 5 + 2 . 0 ∗9 . 3 ;
✡ ✠
is equivalent to
☛ ✟
r = r + ( 3 . 5 + 2 . 0 ∗9 . 3 ) ; // i . e . , r = r + 2 2 . 1 ;
✡ ✠
As these examples illustrate, when using the +=operator, the expression
on its right-hand side is ﬁrst evaluated and then added to the current value
of the variable on its left-hand side.
Table 5.8 lists the other assignment operators that can be us ed in com-
bination with the arithmetic operators. For each of these op erations, the
interpretation is the same: Evaluate the expression on the r ight-hand side
TABLE 5.8 Java’s assignment operators
Operator Operation Example Interpretation
= Simple assignment m=n;m=n;
+= Addition then assignment m+=3;m=m+3;
−= Subtraction then assignment m−=3;m=m−3;
∗= Multiplication then assignment m∗=3;m=m∗3;
/= Division then assignment m/=3;m=m/3;
%= Remainder then assignment m%=3;m=m%3;
of the operator and then perform the arithmetic operation (s uch as addi-
tion or multiplication) to the current value of the variable on the left of the
operator.
SELF-STUDY EXERCISES
EXERCISE 5.10 What value will jand khave after each of the calcula-
tions that follow? Assume that khas the value 10 and that jhas the value
5 before each operation is performed.
a.k += j;
b.k -= j++;c.k*= ++j *2;
d.k /= 25 *j--;e.k %= j - 3;
EXERCISE 5.11 Write four different statements that add 1 to the int k.
5.3.5 Relational Operators
There are several relational operations that can be performed on integers:
<,>,<=,>=,==, and!=. These correspond to the algebraic operators
<,>,≤,≥,=, and/\e}atio\slash=. Each of these operators takes two operands (integer
or real) and returns a boolean result. They are deﬁned in Tabl e 5.9.
Note that several of these relational operators require two symbols in
Java. Thus, the familiar equals sign (=) is replaced in Java b y ==. This is so Equals vs. assigns
218 CHAPTER 5 •Java Data and Operators
TABLE 5.9 Relational operators
Operator Operation Java Expression
< Less than 5<10
> Greater than 10>5
<= Less than or equal to 5<=10
>= Greater than or equal to 10>=5
== Equal to 5==5
!= Not equal to 5!=4
the equality operator can be distinguished from the assignm ent operator.
Also, less than or equal to ( <=), greater than or equal to ( >=), and not
equal to (!=) require two symbols, instead of the familiar ≤,≥, and/\e}atio\slash=from
algebra. In each case, the two symbols should be consecutive. It is an error
in Java for a space to appear between the <and = in <=.
JAVA DEBUGGING TIP Equality and Assignment. A common
semantic error among beginning programmers is to use the
assignment operator (=) when the equality operator (==) is i ntended.
Among the relational operators, the inequalities ( <,>,<=, and>=)
have higher precedence than the equality operators ( == and!=). In an
expression that involves both kinds of operators, the inequ alities would be
evaluated ﬁrst. Otherwise, the expression is evaluated fro m left to right.
Taken as a group the relational operators have lower precede nce than
the arithmetic operators. Therefore, in evaluating an expr ession that in-
volves both arithmetic and relational operators, the arith metic operations
are done ﬁrst. Table 5.10 includes all of the numeric operato rs introduced
so far.
TABLE 5.10 Numeric operator precedence including relations
Precedence
Order Operator Operation
1 () Parentheses
2 ++−− Increment, decrement
3 ∗/% Multiplication, division, modulus
4 +− Addition, subtraction
5 < > <=>= Relational operators
6 ==!= Equality operators
To take an example, let us evaluate the following complex exp ression:
☛ ✟
9 + 6<= 25∗4 + 2
✡ ✠
To clarify the implicit operator precedence, we ﬁrst parent hesize the
expression
☛ ✟
( 9 + 6 ) <= ( (25 ∗4 ) + 2 )
✡ ✠
SECTION 5.4 •From the Java Library java.lang.Math 219
and then evaluate it step by step:
☛ ✟
Step 1 . ( 9 + 6 ) <= ( (25 ∗4 ) + 2 )
Step 2 . ( 9 + 6 ) <= ( 100 + 2 )
Step 3 . 15 <= 102
Step 4 . true
✡ ✠
The following expression is an example of an ill-formed expr ession:
☛ ✟
9 + 6<= 25∗4 == 2
✡ ✠
That the expression is ill formed becomes obvious if we paren thesize it
and then attempt to evaluate it:
☛ ✟
Step 1 . ( ( 9 + 6 ) <= ( 25 ∗4 ) ) == 2
Step 2 . ( 15 <= 100 ) == 2
Step 3 . true == 2 // S y n t a x e r r o r r e s u l t s h e r e
✡ ✠
The problem here is that the expression true == 2 is an attempt to com-
pare an int and aboolean value, which can’t be done. As with any other
binary operator, the == operator requires that both of its op erands be of Strong typing
the same type. This is another example of Java’s strong type c hecking.
SELF-STUDY EXERCISES
EXERCISE 5.12 For each of these questions, what is the value of m?
Assume that kequals 2, jequals 3, and mequals 10, before each question.
Don’t forget about precedence.
a.m = j++ + k ;
b.m = ++j + k;c.m += j + k;
d.m*= j++ + k++;e.m*= ++j + ++k;
EXERCISE 5.13 Evaluate each of the following expressions, taking care
to observe operator precedence rules. If an expression is ill egal, mark it
illegal and explain why.
a.4 + 5 == 6 *2
b.(4 + 5) <=6 / 3
c.4 + 5 / 6 >=10 % 2
d.(4 = 5) / 6e.4 + 5 % 3 != 7 - 2
f.(4 + 5) % 3 = 10 -4
g.9 % 2 *7 / 3 > 17
5.4 From the Java Library java.lang.Math
THEjava.lang.Math class provides many common mathematical
java.sun.com/j2se/1.5.0/docs/api/ functions that will prove useful in performing numerical co mputations.
As an element of the java.lang package, it is included implicitly in all
Java programs. Table 5.11 lists some of the most commonly use dMath
class methods.
AllMath methods are static class methods and are, therefore, in-
voked through the class name. For example, we would calculat e24
asMath.pow(2,4) , which evaluates to 16. Similarly, we compute the
square root of 225.0 as Math.sqrt(225.0) , which evaluates to 15.0.
220 CHAPTER 5 •Java Data and Operators
TABLE 5.11 A selection of Math class methods
Method Description Examples
int abs(int x) Absolute value of x if x >= 0 abs(x) is x
long abs(long x) if x<0 abs(x) is −x
ﬂoat abs(ﬂoat x)
int ceil(double x) Rounds x to the smallest ceil(8.3) is 9
integer not less than x ceil( −8.3) is−8
int ﬂoor(double x) Rounds x to the largest ﬂoor (8.9) is 8
integer not greater than x ﬂoor( −8.9) is−9
double log(double x) Natural logarithm of x log (2.718282) is 1.0
double pow(double x, double y) x raised to the y power ( xy) pow(3, 4 ) is 81.0
pow(16.0, 0.5) is 4.0
double random() Generates a random random() is 0.5551
number in the interval [0,1) random() is 0.8712
long round(double x) Rounds x to an integer round(26.51) is 27
round (26.499) is 26
double sqrt(double x) Square root of x sqrt(4.0) is 2.0
Indeed, Java’s Math class cannot be instantiated and cannot be sub-
classed. Its basic deﬁnition is
☛ ✟
public f i n a l c l a s s Math // F i n a l , c a n ’ t s u b c l a s s
{ private Math ( ) {} // P r i v a t e , c a n ’ t i n v o k e
. . .
public s t a t i c native double s q r t ( double a )
throws ArithmeticException ;
}
✡ ✠
By declaring the Math classpublic final , we indicate that it can be
accessed ( public ) but it cannot be extended or subclassed ( final ). By
declaring its default constructor to be private , we prevent this class from
being instantiated. The idea of a class that cannot be subcla ssed and can-
not be instantiated may seem a little strange at ﬁrst. The just iﬁcation for it
here is that it provides a convenient and efﬁcient way to intr oduce helpful
math functions into the Java language.
Deﬁning the Math class in this way makes it easy to use its methods,
because you don’t have to create an instance of it. It is also a v ery efﬁcient
design because its methods are static elements of the java.lang pack-
age. This means they are loaded into memory at the beginning o f your
program’s execution, and they persist in memory throughout your pro-
gram’s lifetime. Because Math class methods do not have to be loaded into
SECTION 5.5 •Numeric Processing Examples 221
memory each time they are invoked, their execution time will improve
dramatically.
JAVA EFFECTIVE DESIGN Static Methods. A method should be
declared static if it is intended to be used whether or not there is an
instance of its class.
5.5 Numeric Processing Examples
In this section we consider several numeric programming exam ples. They
are carefully chosen to illustrate different issues and con cepts associated
with processing numeric data.
5.5.1 Example: Rounding to Two Decimal Places
As an example of how to use Math class methods, let’s consider the prob-
lem of rounding numbers. When dealing with applications that involve
monetary values—dollars and cents—it is often necessary to ro und a cal-
culated result to two decimal places. For example, suppose a program
computes the value of a certiﬁcate of deposit (CD) to be 75.19 999. Be-
fore we output this result, we would want to round it to two dec imal
places—to 75.20. The following algorithm can be used to accom plish this: Algorithm design
☛ ✟
1 . Multiply the number by 100 , giving 7 5 1 9 . 9 9 9 9 .
2 . Add 0 . 5 to the number giving 7 5 2 0 . 4 9 9 9 .
3 . Drop the f r a c t i o n a l part giving 7520
4 . Divide the r e s u l t by 100 , giving 7 5 . 2 0
✡ ✠
Step 3 of this algorithm can be done using the Math.floor(R) method,
which rounds its real argument, R, to the largest integer not less than R
(from Table 5.11). If the number to be rounded is stored in the double
variable R, then the following expression will round Rto two decimal
places:
☛ ✟
R = Math . f l o o r (R ∗1 0 0 . 0 + 0 . 5 ) / 1 0 0 . 0 ;
✡ ✠
Alternatively, we could use the Math.round() method (Table 5.11). This
method rounds a ﬂoating-point value to the nearest integer. F or exam-
ple,Math.round(65.3333) rounds to 65 and Math.round(65.6666)
rounds to 66. The following expression uses it to round to two decimal
places:
☛ ✟
R = Math . round ( 1 0 0 . 0 ∗R) / 1 0 0 . 0 ;
✡ ✠
222 CHAPTER 5 •Java Data and Operators
Note that it is important here to divide by 100.0and not by 100. Other-
wise, the division will give an integer result and we’ll lose the two decimal
places.
JAVA DEBUGGING TIP Division. Using the correct type of literal in
division operations is necessary to ensure that you get the c orrect type
of result.
5.5.2 Example: Converting Fahrenheit to Celsius
To illustrate some of the issues that arise in using numeric d ata, let’s de-
sign a program that performs temperature conversions from F ahrenheit to
Celsius and vice versa.
Problem Decomposition
This problem requires two classes, a Temperature class and a
TemperatureUI class. The Temperature class will perform the temper- What objects do we need?
ature conversions, and TemperatureUI will serve as the user interface
(Fig. 5.3).
Figure 5.3: Interacting ob-
jects: The user interacts with
the user interface ( Tempera-
tureUI ), which interacts with the
Temperature object.:  TemperatureUI :  Temperature User2: result =celsToFahr(100)1: Convert 100C to F
3: result =212
Class Design: Temperature
The purpose of the Temperature class is to perform the temperature con-
versions. To convert a Celsius temperature to Fahrenheit or vice versa, it is What data do we need?
not necessary to store the temperature value. Rather, a conv ersion method
could take the Celsius (or Fahrenheit) temperature as a para meter, per-
form the conversion, and return the result. Therefore, the Temperature
class does not need any instance variables. Note that in this respect the
Temperature class resembles the Math class. Unlike OneRowNim , which
stores the game’s state—the number of sticks remaining and wh ose turn
it is—the Math andTemperature classes are stateless.
Thus, following the design of the Math class, the Temperature class What methods do we need?
will have two public static methods: one to convert from Fahr enheit to
Celsius and one to convert from Celsius to Fahrenheit. Recal l that static
methods are associated with the class rather than with its in stances. There-
fore, we needn’t instantiate a Temperature object to use these methods.
Instead, we can invoke the methods through the class itself.
The methods will use the standard conversion formulas: F=9
5C+32
andC=5
9(F−32). Each of these methods should have a single parameter
to store the temperature value that is being converted.
Because we want to be able to handle temperatures such as 98.6 , we
should use real-number data for the methods’ parameters. Ge nerally
SECTION 5.5 •Numeric Processing Examples 223
speaking, because Java represents real literals such as 98. 6 asdouble s,
thedouble type is more widely used than float . Because double s are
more widely used in Java, using double wherever a ﬂoating point value
is needed will cut down on the number of implicit data convers ions that a
program would have to perform. Therefore, each of our conver sion meth-
ods should take a double parameter and return a double result. These
considerations lead
JAVA PROGRAMMING TIP Numeric Types. Java uses the int type
for integer literals and double for real-number literals. When
possible, using int anddouble for numeric variables and parameters
reduces the number of implicit conversions a program would h ave to
perform.
Implementation: Temperature
The implementation of the Temperature class is shown in Figure 5.5.
Note that because celsToFahr() uses the double valuetemp in its cal-
culation, it uses ﬂoating-point literals (9.0, 5.0, and 32.0 ) in its conversion
expression. This helps to reduce the reliance on Java’s buil t-in promotion
rules, which can lead to subtle errors. For example, to the de sign shown+Temperature()
+fahrToCels(in fahr : double) : double
+celsToFahr(in cels : double) : doubleTemperatureF=C * 9/5+32
C=(F-32) * 5/9
FIGURE 5.4 TheTemperature
class. Note that static elements are
underlined in UML. (NEEDS
REVISION)in Figure 5.4. suppose we had written what looks like an equiv alent
expression using integer literals:
☛ ✟
return (9 / 5 ∗temp + 3 2 ) ; // E r r o r : e q u a l s ( t e m p + 3 2 )
✡ ✠
Because 9 divided by 5 gives the integer result 1, this expres sion is always
equivalent to temp + 32 , which is not the correct conversion formula.
This kind of subtle semantic error can be avoided if you avoid mixing Semantic error
☛ ✟
public c l a s s Temperature
{
public Temperature ( ) {}
public s t a t i c double fahrToCels ( double temp )
{
return ( 5 . 0∗( temp−3 2 . 0 ) / 9 . 0 ) ;
}
public s t a t i c double celsToFahr ( double temp )
{
return ( 9 . 0∗temp / 5 . 0 + 3 2 . 0 ) ;
}
}// T e m p e r a t u r e
✡ ✠
Figure 5.5: The Temperature class.
224 CHAPTER 5 •Java Data and Operators
types wherever possible.
JAVA PROGRAMMING TIP Don’t Mix Types. You can reduce the
incidence of semantic errors caused by implicit type conver sions if,
whenever possible, you explicitly change all the literals i n an
expression to the same type.
Testing and Debugging
The next question to be addressed is how should this program b e tested?
As always, you should test the program in a stepwise fashion. As each Testing strategy
method is coded, you should test it both in isolation and in co mbination
with the other methods, if possible.
Also, you should develop appropriate test data . It is not enough to just Designing test data
plug in any values. The values you use should test for certain potential
problems. For this program, the following tests are appropr iate:
•Test converting 0 degrees C to 32 degrees F.
•Test converting 100 degrees C to 212 degrees F.
•Test converting 212 degrees F to 100 degrees C.
•Test converting 32 degrees F to 0 degrees C.
The ﬁrst two tests use the celsToFahr() method to test the freezing
point and boiling point temperatures, two boundary values f or this prob-
lem. A boundary value is a value at the beginning or end of the range of
values that a variable or calculation is meant to represent. The second pair
of tests performs similar checks with the fahrToCels() method. One
advantage of using these particular values is that we know wh at results
the methods should return.
JAVA EFFECTIVE DESIGN Test Data. Developing appropriate test
data is an important part of program design. One type of test d ata
should check the boundaries of the particular calculations you are
making.
JAVA DEBUGGING TIP Test, Test, Test! The fact that your program
runs correctly on some data is no guarantee of its correctnes s. The
more testing, and the more careful the testing you do, the bet ter.
TheTemperatureUI Class
The purpose of the TemperatureUI class is to serve as a user interface—
that is, as an interface between the user and a Temperature object. It
will accept a Fahrenheit or Celsius temperature from the use r, pass it to
one of the public methods of the Temperature object for conversion, and
display the result that is returned.
SECTION 5.5 •Numeric Processing Examples 225
As we discussed in Chapter 4, the user interface can take vari ous forms,
ranging from a command-line interface to a graphical interf ace. Figure 5.6
shows a design for the user interface based on the command-li ne interface
developed in Chapter 4. The TemperatureUI uses aKeyboardReader
to handle interaction with the user and uses static methods in the
Temperature class to perform the temperature conversions.
Figure 5.6: A command-line user
interface.
SELF-STUDY EXERCISES
EXERCISE 5.14 Following the design in Figure 5.6, implement the
TemperatureUI class and use it to test the methods in Temperature
class. The run() method should use an input-process-output algorithm:
Prompt the user for input, perform the necessary processing , and output
the result. Note that because Temperature ’s conversion methods are
class methods, you do not need to instantiate a Temperature object in
this project. You can invoke the conversion methods directly through the
Temperature class:
☛ ✟
double fahr = Temperature . celsToFahr ( 9 8 . 6 ) ;
✡ ✠
EXERCISE 5.15 Following the design for the GUI developed in Chap-
ter 4, implement a GUI to use for testing the Temperature class. The
Input Temperature >>
Conversion Result:
45 C =113.0 FLabelsApplet Buttons
TextFields45
C to F F to C
FIGURE 5.7 Layout design of a
GUI that performs temperature
conversions.GUI should have the layout shown in Figure 5.7.
5.5.3 Example: Using Class Constants
As we noted in Chapter 0, in addition to instance variables, w hich are
associated with instances (objects) of a class, Java also all ows class vari-
ables, which are associated with the class itself. One of the most common
uses of such variables is to deﬁne named constants to replace literal val-
ues. A named constant is a variable that cannot be changed once it has
been given an initial value. In this section, we use our runnin g example,
OneRowNim , to illustrate using class constants.
226 CHAPTER 5 •Java Data and Operators
Recall that methods and variables that are associated with a class must
be declared with the static modiﬁer. If a variable is declared static ,
there is exactly one copy of that variable created no matter h ow many
times its class is instantiated. To turn a variable into a con stant, it must be
declared with the final modiﬁer. Thus, the following would be exam-
ples of a class constants , constant values that are associated with the class
rather than with its instances:
☛ ✟
public s t a t i c f i n a l i n t PLAYER ONE = 1 ;
public s t a t i c f i n a l i n t PLAYER TWO = 2 ;
public s t a t i c f i n a l i n t MAX PICKUP = 3 ;
public s t a t i c f i n a l i n t MAX STICKS = 7 ;
✡ ✠
Thefinal modiﬁer indicates that the value of a variable cannot be
changed. When final is used in a variable declaration, the variable must
be assigned an initial value. After a final variable is properly declared,
it is a syntax error to attempt to try to change its value. For e xample, given
the preceding declarations, the following assignment stat ement would
cause a compiler error:
☛ ✟
PLAYER ONE = 5 ; // S y n t a x e r r o r ; PLAYER ONE i s a c o n s t a n t
✡ ✠
Note how we use uppercase letters and underscore characters () in the
names of constants. This is a convention that professional J ava program-
mers follow, and its purpose is to make it easy to distinguish the constants
from the variables in a program. This makes the program easie r to read
and understand.
JAVA PROGRAMMING TIP Readability. To make your programs
more readable, use uppercase font for constant identiﬁers.
Another way that named constants improve the readability of a pro-
gram is by replacing the reliance on literal values. For exam ple, for the
OneRowNim class, compare the following two ifconditions:
☛ ✟
i f(num<1||num>3||num>n S t i c k s ) . . .
i f(num<1||num>MAX PICKUP ||num>n S t i c k s ) . . .
✡ ✠
Clearly, the second condition is easier to read and understa nd. In the ﬁrst
condition, we have no good idea what the literal value 3 repre sents. In the
second, we know that MAX PICKUP represents the most sticks a player
can pick up.
Thus, to make OneRowNim more readable, we should replace all occur-
rences of the literal value 3 with the constant MAX PICKUP . This same
principle would apply to some of the other literal values in t he program.
Thus, instead of using 1 and 2 to represent the two players, we could use Readability
SECTION 5.5 •Numeric Processing Examples 227
PLAYER ONE and PLAYER TWO to make methods such as the following
easier to read and understand:
☛ ✟
public i n t getPlayer ( )
{ i f( onePlaysNext )
return PLAYER ONE ;
else return PLAYER TWO;
}// g e t P l a y e r ( )
✡ ✠
JAVA PROGRAMMING TIP Readability. To make your programs
more readable, use named constants instead of literal value s.
Another advantage of named constants (over literals) is tha t their use
makes the program easier to modify and maintain. For example , suppose
that we decide to change OneRowNim so that the maximum number of Maintainability
sticks that can be picked up is 4 instead of 3. If we used literal values, we
would have to change all occurrences of 4 that were used to rep resent the
maximum pick up. If we used a named constant, we need only chang e its
declaration to:
☛ ✟
public s t a t i c f i n a l i n t MAX PICKUP = 4 ;
✡ ✠
JAVA EFFECTIVE DESIGN Maintainability. Constants should be
used instead of literal values in a program. This will make th e
program easier to modify and maintain.
So far, all of the examples we have presented show why named co n-
stants (but not necessarily class constants) are useful. No t all constants
are class constants. That is, not all constants are declared static . How-
ever, the idea of associating constants with a class makes go od sense. In
addition to saving memory resources, by creating just a singl e copy of
the constant, constants such as MAX STICKS and PLAYER ONE make
more conceptual sense to associate with the class itself rat her than with
any particular OneRowNim instance.
Class constants are used extensively in the Java class libra ry. For ex-
ample, as we saw in Chapter 2, Java’s various built-in colors are rep-
resented as constants of the java.awt.Color class— Color.blue and
Color.red . Similarly, java.awt.Label usesint constants to specify
how a label’s text should be aligned: Label.CENTER .
Another advantage of class constants is that they can be used before
instances of the class exist. For example, a class constant ( as opposed to
an instance constant) may be used during object instantiatio n:
☛ ✟
OneRowNim game = new OneRowNim(OneRowNim . MAX STICKS ) ;
✡ ✠
Note how we use the name of the class to refer to the class const ant. Of
course, MAX STICKS has to be a public variable in order to be accessible
228 CHAPTER 5 •Java Data and Operators
outside the class. To use MAX STICKS as a constructor argument it has
to be a class constant because at this point in the program the re are no
instances of OneRowNim . A new version of OneRowNim that uses class
constants is shown in Figure 5.8.
It is important to note that Java also allows class constants t o
be referenced through an instance of the class. Thus, once we
have instantiated game , we can refer to MAX STICKS with either
OneRowNim.MAX STICKS orgame.MAX STICKS .
SELF-STUDY EXERCISE
EXERCISE 5.16 Implement a command-line interface class named
KBTestOneRowNim , that uses our new version of OneRowNim . Make use
of theMAXSTICKS andMAXPICKUP in the user interface.
5.5.4 OBJECT-ORIENTED DESIGN:
Information Hiding
The fact that our new versions of OneRowNim —we’ve developed two new
versions in this chapter—are backward compatible with the previous version
is due in large part to the way we have divided up its public and private Preserving the public interface
elements. Because the new versions still present the same pu blic interface,
programs that use the OneRowNim class, such as the OneRowNimApp from
Chapter 4 (Fig. 4.24), can continue to use the class without c hanging a
single line of their own code. To conﬁrm this, see the Self-St udy Exercise
at the end of this section.
Although we have made signiﬁcant changes to the underlying
representation of OneRowNim , the implementation details—its data and Information hiding
algorithms—are hidden from other objects. As long as OneRowNim ’s pub-
lic interface remains compatible with the old version, chan ges to its pri-
vate elements won’t cause any inconvenience to those objects that were
dependent on the old version. This ability to change the unde rlying im-
plementation without affecting the outward functionality of a class is one
of the great beneﬁts of the information hiding principle.
JAVA EFFECTIVE DESIGN Information Hiding. In designing a
class, other objects should be given access just to the informa tion they
need and nothing more.
The lesson to be learned here is that the public parts of a clas s should
be restricted to just those parts that must be accessible to ot her objects.
Everything else should be private. Things work better, in Ja va program-
ming and in the real world, when objects are designed with the p rinciple
of information hiding in mind.
SELF-STUDY EXERCISE
EXERCISE 5.17 To conﬁrm that our new version of OneRowNim still
works correctly with the user interfaces we developed in Cha pter 4, com-
pile and run it with OneRowNimApp (Fig. 4.24).
SECTION 5.5 •Numeric Processing Examples 229
☛ ✟
public c l a s s OneRowNim
{ public s t a t i c f i n a l i n t PLAYER ONE = 1 ;
public s t a t i c f i n a l i n t PLAYER TWO = 2 ;
public s t a t i c f i n a l i n t MAX PICKUP = 3 ;
public s t a t i c f i n a l i n t MAX STICKS = 1 1 ;
public s t a t i c f i n a l boolean GAME OVER = f a l s e ;
private i n t n S t i c k s = MAX STICKS ;
private boolean onePlaysNext = true ;
public OneRowNim ( )
{
}// OneRowNim ( ) c o n s t r u c t o r 1
public OneRowNim( i n t s t i c k s )
{ n S t i c k s = s t i c k s ;
} // OneRowNim ( ) c o n s t r u c t o r 2
public OneRowNim( i n t s t i c k s , i n t s t a r t e r )
{ n S t i c k s = s t i c k s ;
onePlaysNext = ( s t a r t e r == PLAYER ONE ) ;
} // OneRowNim ( ) c o n s t r u c t o r 3
public boolean t a k e S t i c k s ( i n t num)
{ i f(num<1||num>MAX PICKUP ||num>n S t i c k s )
return f a l s e ; // E r r o r
else // V a l i d move
{ n S t i c k s = n S t i c k s −num;
onePlaysNext = ! onePlaysNext ;
return true ;
}// e l s e
}// t a k e S t i c k s ( )
public i n t g e t S t i c k s ( )
{ return n S t i c k s ;
}// g e t S t i c k s ( )
public i n t getPlayer ( )
{ i f( onePlaysNext )
return PLAYER ONE ;
else return PLAYER TWO;
}// g e t P l a y e r ( )
public boolean gameOver ( )
{ return ( n S t i c k s <= 0 ) ;
}// g a m e O v e r ( )
public i n t getWinner ( )
{ i f( n S t i c k s <1)
return getPlayer ( ) ;
else return 0 ; // Game i s n o t o v e r
}// g e t W i n n e r ( )
public S t r i n g report ( )
{ return (”Number of s t i c k s l e f t : ” + g e t S t i c k s ( )
+”\nNext turn by player ” + getPlayer ( ) + ”\n”) ;
} // r e p o r t ( )
}// OneRowNim c l a s s
✡ ✠
Figure 5.8: This version of OneRowNim uses named constants.
230 CHAPTER 5 •Java Data and Operators
5.5.5 Example: A Winning Algorithm for One Row Nim
Now that we have access to numeric data types and operators, l ets de-
velop an algorithm that can win the One Row Nim game. Recall th at
in Chapter 4 we left things such that when the computer moves, it al-
ways takes 1 stick. Let’s replace that strategy with a more so phisticated
approach.
If you have played One Row Nim, you have probably noticed that i n
a game with 21 sticks, you can always win the game if you leave y our
opponent with 1, 5, 9, 13, 17, or 21 sticks. This is obvious for the case of 1
stick. For the case where you leave your opponent 5 sticks, no matter what
the opponent does, you can make a move that leaves the other pl ayer with
1 stick. For example, if your opponent takes 1 stick, you can t ake 3; if your
opponent takes 2, you can take 2; and, if your opponent takes 3 , you can
take 1. In any case, you can win the game by making the right move , if
you have left your opponent with 5 sticks. The same arguments apply for
the other values: 9, 13, 17, and 21.
What relationship is common to the numbers in this set? Notice that
if you take the remainder after dividing each of these number s by 4 you
always get 1:
☛ ✟
1 % 4 == 1
5 % 4 == 1
9 % 4 == 1
13 % 4 == 1
17 % 4 == 1
21 % 4 == 1
✡ ✠
Thus, we can base our winning strategy on the goal of leaving t he oppo-
nent with a number of sticks, N, such that N % 4 equals 1.
To determine how many sticks to take in order to leave the oppo nent
with N, we need to use a little algebra. Let’s suppose that sticksLeft
represents the number of sticks left before our turn. The ﬁrs t thing we
have to acknowledge is that if sticksLeft % 4 == 1 , then we have been left
with 1, 5, 9, 13, and so on, sticks, so we cannot force a win. In th at case,
it doesn’t matter how many sticks we pick up. Our opponent sho uld win
the game.
So, let’s suppose that sticksLeft % 4 != 1 , and let Mbe the number of
sticks to pickup in order to leave our opponent with N, such that N % 4 ==
1. Then we have the following two equations:
☛ ✟
s t i c k s L e f t −M == N
N % 4 == 1
✡ ✠
We can combine these into a single equation, which can be simp liﬁed as
follows:
☛ ✟
( s t i c k s L e f t −M) % 4 == 1
✡ ✠
SECTION 5.5 •Numeric Processing Examples 231
IfsticksLeft - M leaves a remainder of 1 when divided by 4, that means that
sticksLeft - M is equal some integer quotient, Qtimes 4 plus 1:
☛ ✟
( s t i c k s L e f t −M) == (Q ∗4) + 1
✡ ✠
By adding Mto both sides and subtracting 1 from both sides of this equa-
tion, we get:
☛ ✟
( s t i c k s L e f t −1) == (Q ∗4) + M
✡ ✠
This equation is saying that (sticksLeft - 1) % 4 == M . That is, that when
you divide sticksLeft-1 by 4, you will get a remainder of M, which is the
number of sticks you should pick up. Thus, to decide how many s ticks to
take, we want to compute:
☛ ✟
M == ( s t i c k s L e f t −1) % 4
✡ ✠
To verify this, let’s look at some examples:
☛ ✟
s t i c k s L e f t ( s t i c k s L e f t −1) % 4 s t i c k s L e f t
Before After
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− −
9 (9 −1) % 4 == 0 I l l e g a l Move
8 (8 −1) % 4 == 3 5
7 (7 −1) % 4 == 2 5
6 (6 −1) % 4 == 1 5
5 (5 −1) % 4 == 0 I l l e g a l Move
✡ ✠
The examples in this table show that when we use (sticksLeft-1 % 4) to
calculate our move, we always leave our opponent with a losin g situation.
Note that when sticksLeft equals 9 or 5, we can’t apply this strategy
because it would lead to an illegal move.
Let’s now convert this algorithm into Java code. In addition t o incor-
porating our winning strategy, this move() method makes use of two
important Math class methods:
☛ ✟
public i n t move ( )
{i n t s t i c k s L e f t = nim . g e t S t i c k s ( ) ; // G e t n u m b e r o f s t i c k s
i f( s t i c k s L e f t % ( nim . MAX PICKUP + 1) != 1) // I f w i n n a b l e
return ( s t i c k s L e f t −1) % ( nim . MAX PICKUP + 1 ) ;
else{ // E l s e p i c k r a n d o m
i n t maxPickup = Math . min ( nim . MAX PICKUP, s t i c k s L e f t ) ;
return 1 + ( i n t) ( Math . random ( ) ∗maxPickup ) ;
}
}
✡ ✠
Themove() method will return an int representing the best move pos-
sible. It begins by getting the number of sticks left from the OneRowNim
object, which is referred to as nim in this case. It then checks whether it
can win by computing (sticksLeft-1) % 4 . However, note that rather than
232 CHAPTER 5 •Java Data and Operators
use the literal value 4, we use the named constant MAXPICKUP , which is
accessible through the nim object. This is an especially good use for the
class constant because it makes our algorithm completely ge neral – that is,
our winning strategy will continue to work even if the game is changed
so that the maximum pickup is 5 or 6. The then clause computes and re-
turns (sticksLeft-1) % nim.MAX PICKUP+1 , but here again it uses the class
constant.
The else clause would be used when it is not possible to make a w inning
move. In this case we want to choose a random number of sticks be tween
1 and some maximum number. The maximum number depends on how
many sticks are left. If there are more than 3 sticks left, then the most we
can pick up is 3, so we want a random number between 1 and 3. Howev er,
if there are 2 sticks left, then the most we can pick up is 2 and w e want a
random number between 1 and 2. Note how we use the Math.min()
method to decide the maximum number of sticks that can be pick ed up:
☛ ✟
i n t maxPickup = Math . min ( nim . MAX PICKUP, s t i c k s L e f t ) ;
✡ ✠
Themin() method returns the minimum value between its two argu-
ments.
Finally, note how we use the Math.random() method to calculate a
random number between 1 and the maximum:
☛ ✟
1 + ( i n t) ( Math . random ( ) ∗maxPickup ) ;
✡ ✠
Therandom() method returns a real number between 0 and 0.999999 –
that is, a real number between 0 and 1 but not including 1:
☛ ✟
0<= Math . random ( ) <1 . 0
✡ ✠
If we multiply Math.random() times 2, the result would be a value be-
tween 0 and 1.9999999. Similarly, if we multiplied it by 3, th e result would
be a value between 0 and 2.9999999. In order to use the random va lue, we
have to convert it into an integer, which is done by using the (int) cast
operator:
☛ ✟
(i n t) ( Math . random ( ) ∗maxPickup ) ;
✡ ✠
Recall that when a double is cast into an int, Java just throws away the
fractional part. Therefore, this expression will give us a v alue between 0
andmaxPickup-1 . IfmaxPickup is 3, this will give a value between 0
and 2, whereas we want a random value between 1 and 3. To achiev e this
desired value, we merely add 1 to the result. Thus, using the e xpression
☛ ✟
1 + ( i n t) ( Math . random ( ) ∗maxPickup )
✡ ✠
gives us a random number between 1 and maxPickup , where
maxPickup is either 1, 2, or 3, depending on the situation of the game
at that point.
SECTION 5.6 •From the Java Library java.text.NumberFormat 233
SELF-STUDY EXERCISE
FIGURE 5.9 TheNimPlayer class.EXERCISE 5.18 Implement a class named NimPlayer that incorpo-
rates the move() method designed in this section. The class should imple-
ment the design shown in Figure 5.9. That is, in addition to th emove()
method, it should have an instance variable, nim, which will serve as a
reference to the OneRowNim game. Its constructor method should take a
OneRowNim parameter, allowing the NimPlayer to be given a reference
when it is instantiated.
EXERCISE 5.19 Modify OneRowNim ’s command-line interface to play
One Row Nim between the user and the computer, where the NimPlayer
implemented in the previous exercise represents the comput er.
java.sun.com/j2se/1.5.0/docs/api/
5.6 From the Java Library
java.text.NumberFormat
ALTHOUGH theMath.round() method is useful for rounding
numbers, it is not suitable for business applications. Even for rounded
+getInstance() : NumberFormat
+getCurrencyInstance() : NumberFormat
+getPercentInstance() : NumberFormat
+format(in n : double) : String
+format(in n : long) : String
+getMaximumFractionDigits() : int
+getMaximumIntegerDigits() : int
+setMaximumFractionDigits(in n : int)
+setMaximumIntegerDigits(in n : int)NumberFormat
FIGURE 5.10 The
java.text.NumberFormat class.values, Java will drop trailing zeroes. So a value such as $10 ,000.00 would
be output as $10000.0. This wouldn’t be acceptable for a busi ness report.
Fortunately, Java supplies the java.text.NumberFormat class pre-
cisely for the task of representing numbers as dollar amount s, percentages,
and other formats (Fig. 5.10).
TheNumberFormat class is an abstract class, which means that
it cannot be directly instantiated. Instead, you would use it s static
getInstance() methods to create an instance that can then be used for
the desired formatting tasks.
Once a NumberFormat instance has been created, its format()
method can be used to put a number into a particular format. Th e
setMaximumFractionDigits() andsetMaximumIntegerDigits()
methods can be used to control the number of digits before and after the
decimal point.
For example, the following statements can be used to format a decimal
number as a currency string in dollars and cents:
☛ ✟
NumberFormat d o l l a r s = NumberFormat . getCurrencyInstanc e ( ) ;
System . out . p r i n t l n ( d o l l a r s . format ( 1 0 9 6 2 . 5 5 5 ) ) ;
✡ ✠
These statements would cause the value 10962.555 to be shown as
$10,962.56. Similarly, the statements,
☛ ✟
NumberFormat percent = NumberFormat . g e t P e r c e n t I n s t a n c e ( ) ;
percent . setMaximumFractionDigits ( 2 ) ;
System . out . p r i n t l n ( percent . format ( 6 . 5 5 ) ) ;
✡ ✠
234 CHAPTER 5 •Java Data and Operators
would display the value 6.55 as 6.55%. The utility of the Math and
NumberFormat classes illustrates the following principle:
JAVA EFFECTIVE DESIGN Code Reuse. Often the best way to solve
a programming task is to ﬁnd the appropriate methods in the Ja va
class library.
SELF-STUDY EXERCISE
EXERCISE 5.20 A Certiﬁcate of Deposit (CD) is an investment instru-
ment that accumulates interest at a given rate for an initial principal over a
FIGURE 5.11 TheBankCD class.ﬁxed number of years. The formula for compounding interest i s shown in
Table 5.12. It assumes that interest is compounded annually. For daily
compounding, the annual rate must be divided by 365, and the c om-
pounding period must be multiplied by 365, giving: a=p(1+r/365)365n.
Implement a BankCD class that calculates the maturity value of a CD. Fig-
ure 5.11 gives the design of the class. It should have three ins tance vari-
ables for the CD’s principal, rate, and years. Its constructo r method sets
the initial values of these variables when a BankCD is instantiated. Its
two public methods calculate the maturity value using yearl y and daily
compounding interest, respectively. Use the Math.pow() method to cal-
culate maturity values. For example, the following express ion calculates
maturity value with annual compounding:
☛ ✟
p r i n c i p a l ∗Math . pow(1 + rate , years )
✡ ✠
TABLE 5.12 Formula for calculating compound interest
a=p(1+r)nwhere
•ais the CD’s value at the end of the nth year
•pis the principal or original investment amount
•ris the annual interest rate
•nis the number of years or the compounding period
EXERCISE 5.21 Design a command-line user interface to the BankCD
class that lets the user input principal, interest rate, and years, and reports
the CD’s maturity value with both yearly and daily compoundi ng. Use
NumberFormat objects to display percentages and dollar ﬁgures in an
appropriate format. The program’s output should look somet hing like
the following (user’s inputs are in cyan ):
************************ OUTPUT ********************
Compare daily and annual compounding for a Bank CD.
Input CD initial principal, e.g. 1000.55 > 2500
Input CD interest rate, e.g. 6.5 > 7.8
Input the number of years to maturity, e.g., 10.5 > 5
For Principal = $2,500.00 Rate= 7.8% Years= 5.0
The maturity value compounded yearly is $3,639.43
The maturity value compounded daily is: $3,692.30
************************ OUTPUT ********************
SECTION 5.7 •Character Data and Operators 235
5.7 Character Data and Operators
Another primitive data type in Java is the character type, char . A char-
acter in Java is represented by a 16-bit unsigned integer. This means that
a total of 216or 65536 different Unicode characters can be represented, Unicode
corresponding to the integer values 0 to 65535. The Unicode character set
is an international standard that has been developed to enab le computer
languages to represent characters in a wide variety of langu ages, not just
English. Detailed information about this encoding can be ob tained at
☛ ✟
http : // w w w. unicode . org/
✡ ✠
It is customary in programming languages to use unsigned inte gers to
represent characters. This means that all the digits ( 0,...,9), alphabetic let-
ters (a,...,z,A,...,Z), punctuation symbols (such as . ; , “ ‘’ ! -), and non-
printing control characters (LINE FEED, ESCAPE, CARRIAGE RETURN,
...) that make up the computer’s character set are represented i n the com-
puter’s memory by integers. A more traditional set of charac ters is the
ASCII (American Standard Code for Information Interchange )character set. ASCII code
ASCII is based on a 7-bit code and, therefore, deﬁnes 27or 128 different
characters, corresponding to the integer values 0 to 127. In o rder to make
Unicode backward compatible with ASCII systems, the ﬁrst 128 Unicode
characters are identical to the ASCII characters. Thus, in bo th the ASCII
and Unicode encoding, the printable characters have the int eger values
shown in Table 5.13.
5.7.1 Character to Integer Conversions
Is ‘A’ a character or an integer? The fact that character data a re stored
as integers in the computer’s memory can cause some confusio n about
whether a given piece of data is a character or an integer. In ot her words,
when is a character, for example ‘A’, treated as the integer ( 65) instead of
as the character ‘A’? The rule in Java is that a character lite ral—‘a’ or ‘A’
or ‘0’ or ‘?’—is always treated as a character, unless we expli citly tell Java
to treat it as an integer. So if we display a literal’s value
☛ ✟
System . out . p r i n t l n ( ’ a ’) ;
✡ ✠
the letter ‘a’ will be displayed. Similarly, if we assign ‘a’ to achar variable
and then display the variable’s value,
☛ ✟
char ch = ’ a ’;
System . out . p r i n t l n ( ch ) ; // D i s p l a y s ’ a ’
✡ ✠
the letter ‘a’ will be shown. If, on the other hand, we wish to ou tput a
character’s integer value, we must use an explicit cast oper ator as follows:
☛ ✟
System . out . p r i n t l n ( ( i n t)’ a ’) ; // D i s p l a y s 9 7
✡ ✠
236 CHAPTER 5 •Java Data and Operators
TABLE 5.13 ASCII codes for selected characters
☛ ✟
Code 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
Char SP ! ” # $ % & ’ ( ) ∗+ ,− . /
Code 48 49 50 51 52 53 54 55 56 57
Char 0 1 2 3 4 5 6 7 8 9
Code 58 59 60 61 62 63 64
Char : ; < => ? @
Code 65 66 67 68 69 70 71 72 73 74 75 76 77
Char A B C D E F G H I J K L M
Code 78 79 80 81 82 83 84 85 86 87 88 89 90
Char N O P Q R S T U V W X Y Z
Code 91 92 93 94 95 96
Char [ \ ] ˆ ‘
Code 97 98 99 100 101 102 103 104 105 106 107 108 109
Char a b c d e f g h i j k l m
Code 110 111 112 113 114 115 116 117 118 119 120 121 122
Char n o p q r s t u v w x y z
Code 123 124 125 126
Char { | } ˜
✡ ✠
Acast operation , such as (int) , converts one type of data (’a’) into an-
other (97). This is known as a type conversion . Similarly, if we wish to
store a character’s integer value in a variable, we can castthechar into an
int as follows:
☛ ✟
i n t k = ( i n t)’ a ’; // C o n v e r t s ’ a ’ t o 9 7
System . out . p r i n t l n ( k ) ; // D i s p l a y s 9 7
✡ ✠
As these examples show, a cast is a type conversion operator. Java al- The cast operator
lows a wide variety of both explicit and implicit type conver sions. Cer-
tain conversions (for example, promotions) take place when methods are
invoked, when assignment statements are executed, when exp ressions are
evaluated, and so on.
Type conversion in Java is governed by several rules and exce ptions. In
some cases Java allows the programmer to make implicit cast c onversions.
SECTION 5.7 •Character Data and Operators 237
For example, in the following assignment a char is converted to an int
even though no explicit cast operator is used:
☛ ✟
char ch ;
i n t k ;
k = ch ; // c o n v e r t a c h a r i n t o a n i n t
✡ ✠
Java permits this conversion because no information will be lost. A
character char is represented in 16 bits whereas an int is represented in Implicit type conversion
32 bits. This is like trying to put a small object into a large bo x. Space will
be left over, but the object will ﬁt inside without being damag ed. Similarly,
storing a 16-bit char in a 32-bit int will leave the extra 16 bits unused.
This widening primitive conversion changes one primitive type ( char ) into
a wider one ( int), where a type’s width is the number of bits used in its Widening conversion
representation.
On the other hand, trying to assign an int value to a char variable
leads to a syntax error:
☛ ✟
char ch ;
i n t k ;
ch = k ; // S y n t a x e r r o r : c a n ’ t a s s i g n i n t t o c h a r
✡ ✠
Trying to assign a 32-bit int to 16-bit char is like trying to ﬁt a big object
into an undersized box. The object won’t ﬁt unless we shrink it in some
way. Java will allow us to assign an int value to a char variable, but only
if we perform an explicit cast on it:
☛ ✟
ch = ( char ) k ; // E x p l i c i t c a s t o f i n t k i n t o c h a r c h
✡ ✠
The(char) cast operation performs a careful “shrinking” of the int by
lopping off the last 16 bits of the int. This can be done without loss of
information provided that k’s value is in the range 0 to 65535—that is, in
the range of values that ﬁt into a char variable. This narrowing primitive Narrowing conversion
conversion changes a wider type (32-bit int) to a narrower type (16-bit
char ). Because of the potential here for information loss, it is u p to the
programmer to determine that the cast can be performed safel y.
JAVA LANGUAGE RULE Type Conversion. Java permits implicit
type conversions from a narrower type to a wider type. A castoperator
must be used when converting a wider type into a narrower type .
The cast operator can be used with any primitive type. It appli es to the
variable or expression that immediately follows it. Thus, p arentheses
must be used to cast the expression m + n into achar :
☛ ✟
char ch = ( char ) (m + n ) ;
✡ ✠
238 CHAPTER 5 •Java Data and Operators
The following statement would cause a syntax error because t he cast
operator would only be applied to m:
☛ ✟
char ch = ( char )m + n ; // E r r o r : r i g h t s i d e i s a n i n t
✡ ✠
In the expression on the right-hand side, the character produ ced by
(char)m will be promoted to an int because it is part of an integer oper-
ation whose result will still be an int. Therefore, it cannot be assigned to
achar without an explicit cast.
SELF-STUDY EXERCISE
EXERCISE 5.22 Suppose that mand nare integer variables of type int
and that ch1and ch2are character variables of type char . Determine in
each of the cases that follow whether the assignment stateme nts are valid.
If not, modify the statement to make it valid.
a.m = n;
b.m = ch1;c.ch2 = n;
d.ch1 = ch2;e.ch1 = m - n;
5.7.2 Lexical Ordering
The order in which the characters of a character set are arran ged, their
lexical order , is an important feature of the character set. It especially
comes into play for such tasks as arranging strings in alphab etical order.
Although the actual integer values assigned to the individu al char-
acters by ASCII and UNICODE encoding seem somewhat arbitrary, the
characters are, in fact, arranged in a particular order. For example, note
that various sequences of digits, ’0’...’9’, and letters, ’a’...’z’ and
’A’...’Z’, are represented by sequences of integers (Table 5.11). Thi s
makes it possible to represent the lexical order of the chara cters in terms of
theless than relationship among integers. The fact that ‘a’ comes before ‘f’
in alphabetical order is represented by the fact that 97 (the integer code for
‘a’) is less than 102 (the integer code for ‘f’). Similarly, t he digit ‘5’ comes
before the digit ‘9’ in an alphabetical sequence because 53 ( the integer code
for ‘5’) is less than 57 (the integer code for ‘9’).
This ordering relationship extends throughout the charact er set. Thus,
it is also the case that ‘A’ comes before ‘a’ in the lexical ord ering because 65
(the integer code for ‘A’) is less than 97 (the integer code fo r ‘a’). Similarly,
the character ‘[’ comes before ‘ }’ because its integer code (91) is less than
125, the integer code for ‘ }’.
5.7.3 Relational Operators
Given the lexical ordering of the char type, the following relational oper-
ators can be deﬁned: <,>,<=,>=, ==, !=. Given any two characters, ch1
and ch2, the expression ch1<ch2is true if and only if the integer value
ofch1is less than the integer value of ch2. In this case we say that ch1 char relations
precedes ch2 in lexical order. Similarly, the expression ch1>ch2is true if
and only if the integer value of ch1is greater than the integer value of ch2.
In this case we say that ch1 follows ch2 . And so on for the other relational
operators. This means that we can perform comparison operat ions on any
two character operands (Table 5.14).
SECTION 5.8 •Example: Character Conversions 239
TABLE 5.14 Relational operations on characters
Operation Operator Java True Expression
Precedes < ch1<ch2′a′<′b′
Follows > ch1>ch2′c′>′a′
Precedes or equals <= ch1<=ch2′a′<=′a′
Follows or equals >= ch2>=ch1′a′>=′a′
Equal to == ch1==ch2′a′==′a′
Not equal to != ch1!=ch2′a′!=′b′
5.8 Example: Character Conversions
Another interesting implication of representing the chara cters as integers
is that we can represent various character operations in ter ms of inte-
ger operations. For example, suppose we want to capitalize a lower-
case letter. Table 5.13 shows that the entire sequence of low ercase let- Lowercase to uppercase
ters(’a’ ... ’z’) is displaced by 32 from the sequence of uppercase
letters (’A’ ... ’Z’) , so we can convert any lowercase letter into its
corresponding uppercase letter by subtracting 32 from its i nteger value,
provided we perform an explicit cast on the result. When we per form the
cast(char) (’a’ - 32 ) , the resulting value is ’A’, as the following
example shows:
☛ ✟
(char ) (’ a ’−32) == > ’A ’
✡ ✠
Recall that in evaluating ’a’ - 32 Java will promote ‘a’ to an int and
then perform the subtraction. Thus, a step-by-step evaluat ion of the ex-
pression would go as follows:
☛ ✟
Step 1 . ( char ) ( (i n t)’ a ’−32) // P r o m o t e ’ a ’ t o i n t
Step 2 . ( char ) ( 9 7−32) // S u b t r a c t
Step 3 . ( char ) ( 6 5 ) // C a s t r e s u l t t o a c h a r
Step 4 . ’A ’ // R e s u l t s i n ’ A ’
✡ ✠
Similarly, we can convert an uppercase letter into the corre sponding
lowercase letter by simply adding 32 to its integer code and c asting the Uppercase to lowercase
result back to a char:
☛ ✟
(char ) (’ J ’ + 32) == > ’ j ’
✡ ✠
We can group these ideas into a method that performs conversi on from
lowercase to uppercase:
☛ ✟
char toUpperCase ( char ch ){
i f( ( ch>=’ a ’) && ( ch <=’ z ’) )
return ch−32 ; // E r r o r : c a n ’ t r e t u r n a n i n t
return ch ;
}
✡ ✠
240 CHAPTER 5 •Java Data and Operators
This method takes a single char parameter and returns a char value. It
begins by checking if chis a lowercase letter—that is, if chfalls between
‘a’ and ‘z’ inclusive. If so, it returns the result of subtract ing 32 from ch. If
not, it returns chunchanged. However, the method contains a syntax error
that becomes apparent if we trace through its steps. If we invo ke it with Type error
the expression toUpperCase(’b’) , then since ‘b’is between ‘a’and ‘z’,
the method will return ‘b’−32. Because the integer value of ‘b’is 98, it
will return 98−32or 66, which is the integer code for the character ‘B’.
However, the method is supposed to return a char , so this last statement
will generate the following syntax error:
☛ ✟
Incompatible type for return . An e x p l i c i t c a s t needed
to convert i n t tochar .
>> return ch−32 ;
>> ˆ
✡ ✠
In order to avoid this error, the result must be converted back tochar
before it can be returned:
☛ ✟
char toUpperCase ( char ch ){
i f( ( ch>=’ a ’) && ( ch <=’ z ’) )
return (char ) ( ch−3 2 ) ; // E x p l i c i t c a s t
return ch ;
}
✡ ✠
Another common type of conversion is to convert a digit to its correspond-
ing integer value. For example, we convert the character ‘9’ to the integer
9 by making use of the fact that the digit ‘9’ is 9 characters be yond the digit Digit to integer
‘0’ in the lexical order. Therefore, subtracting ‘0’ from ‘9 ’ gives integer 9 as
a result:
☛ ✟
(’ 9 ’−’ 0 ’) ==>(57−48) ==> 9
✡ ✠
More generally, the expression ch−‘0’will convert any digit, ch, to its
integer value. We can encapsulate these ideas into a method t hat converts
any digit into its corresponding integer value:
☛ ✟
i n t d i g i t T o I n t e g e r ( char ch ){
i f( ( ch>=’ 0 ’) && ( ch <=’ 9 ’) )
return ch−’ 0 ’;
return −1 ;
}
✡ ✠
This method takes a single char parameter and returns an int. It ﬁrst
checks that chis a valid digit, and if so, it subtracts the character ‘0’ fro m
it. If not, the method just returns −1, which indicates that the method
received an invalid input parameter. Obviously, when an obje ct invokes
this method, it should ﬁrst make sure that the value it passes is in fact a
digit.
SECTION 5.9 •Problem Solving = Representation + Action 241
The Java application program shown in Figure 5.12 illustrat es sev-
eral of the ideas discussed in this section. Note that both th e
digitToInteger() andtoUpperCase() are declared static. This al-
lows us to call them directly from the (static) main() method, as useful
and justiﬁable shortcut if, as in this case, we are just testing the methods.
☛ ✟
public c l a s s Test{
public s t a t i c void main ( S t r i n g argv [ ] ) {
char ch = ’ a ’; // L o c a l v a r i a b l e s
i n t k = ( i n t)’ b ’;
System . out . p r i n t l n ( ch ) ;
System . out . p r i n t l n ( k ) ;
ch = ( char ) k ; // C a s t n e e d e d h e r e
System . out . p r i n t l n ( ch ) ;
System . out . p r i n t l n ( toUpperCase ( ’ a ’) ) ;
System . out . p r i n t l n ( toUpperCase ( ch ) ) ;
System . out . p r i n t l n ( d i g i t T o I n t e g e r ( ’ 7 ’) ) ;
}
public s t a t i c char toUpperCase ( char ch ){
i f( ( ch>=’ a ’) && ( ch <=’ z ’) )
return (char ) ( ch−3 2 ) ;
return ch ;
}
public s t a t i c i n t d i g i t T o I n t e g e r ( char ch ){
i f( ( ch>=’ 0 ’) && ( ch <=’ 9 ’) )
return ch−’ 0 ’;
return −1 ;
}
}// T e s t
✡ ✠
Figure 5.12: A Java program illustrating character convers ions. When run,
the program will generate the following outputs, one per lin e: a, 98, b, A,
B, 7.
5.9 Problem Solving = Representation + Action
As you have seen in this chapter, designing classes involves a careful in-
terplay between representation (data) and action (methods ). Our several
modiﬁcations to the OneRowNim class illustrate that the data used to rep-
resent an object’s state can either complicate or simplify th e design of the
methods needed to solve a problem.
We hope that it is becoming clear to you that in writing object- oriented
programs, choosing an appropriate data representation is ju st as impor-
tant as choosing the correct algorithm. The concept of an obje ct allows us
to encapsulate representation and action into a single enti ty. It is a very
natural way to approach problem solving.
If you look closely enough at any problem, you will ﬁnd this clo se re-
lationship between representation and action. For example , compare the
task of performing multiplication using Arabic numerals—65 * 12 = 380—
and the same task using Roman numerals—LXV * XII = DCCLXXX. It’s
242 CHAPTER 5 •Java Data and Operators
doubtful that our science and technology would be where they are today
if our civilization had to rely forever on the Roman way of rep resenting
numbers!
JAVA EFFECTIVE DESIGN Representation and
Action. Representation (data) and action (methods) are equally
important parts of the problem-solving process.
CHAPTER SUMMARY Technical Terms
action
binary operator
binary digit (bit)
boundary value
cast operation
class constant
input-process-outputnamed constant
operand
operator overloading
precedence order
promotion
round off errorshort-circuit
evaluation
type conversion
unary operator
Unicode
representation
Summary of Important Points
•The way we approach a problem can often help or hinder us in our
ability to solve it. Choosing an appropriate representation for a problem
is often the key to solving it.
•In order to evaluate complex expressions, it is necessary to u nderstand
theprecedence order and associativity of the operators involved. Paren-
theses can always be used to override an operator’s built-in precedence.
•Java provides several types of integer data, including the 8 -bitbyte ,
16-bitshort , 32-bit int, and 64-bit long types. Unless otherwise
speciﬁed, integer literals are represented as int data in a Java program.
•Java provides two types of ﬂoating-point data, the 32-bit float type
and the 64-bit double type. Unless otherwise speciﬁed, ﬂoating-point
literals are represented as double data.
•In general, if a data type uses nbits in its representation, then it can
represent 2ndifferent values.
•The fact that Java’s primitive types are deﬁned in terms of a s peciﬁc
number of bits is one way that Java promotes platform independence .
•It is necessary to distinguish integer operations from ﬂoatin g-point op-
erations even though the same symbols are used. For example, (7/2) is
3, while (7.0/2) is 3.0.
•In revising a class that is used by other classes it is importan t to pre-
serve as much of the class’s interface as possible.
•In Java, character data are based on the Unicode character set , which
provides 216= 65,536 different character codes. To provide backward
compatibility with the ASCII code, the ﬁrst 128 characters ar e the ASCII
coded characters.
CHAPTER 5 •Solutions to Self-Study Exercises 243
•Java operators are evaluated according to the precedence hi erarchy
shown in Table 5.15. The lower the precedence number, the ear lier an
operator is evaluated. So the operators at the top of the tabl e are evalu-
ated before operators that occur below them in the table. Ope rators at
the same precedence level are evaluated according to their association ,
either left to right (L to R) or right to left (R to L).
TABLE 5.15 Java operator precedence and associativity table
Order Operator Operation Association
0( ) Parentheses
1++ -- . Postincrement, postdecrement,
dotOperator L to R
2++ -- + - ! Preincrement, predecrement R to L
Unary plus, unary minus,
boolean NOT
3(type)new Type cast, object instantiation R to L
4*/ % Multiplication, division, modulus L to R
5+ - + Addition, subtraction, string
concatenation L to R
6< > <= >= Relational operators L to R
7== != Equality operators L to R
8∧ Boolean XOR L to R
9&& Boolean AND L to R
10|| Boolean OR L to R
11 = += -= *= /= %= Assignment operators R to L
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 5.1 a. true
b. falsec. true
d. falsee. false
f. false
SOLUTION 5.2
☛ ✟
0000 , 0001 , 0010 , 0011 , 0100 , 0101 , 0110 , 0111 ,
1000 , 1001 , 1010 , 1011 , 1100 , 1101 , 1110 , 1111
✡ ✠
SOLUTION 5.3 In 6 bits, you can represent 26=64different values.
SOLUTION 5.4 If you have to represent up to 12 signiﬁcant digits, you should
usedouble , which goes up to 17 digits.
SOLUTION 5.5 a. 4
b. 4
c. 0d. 1
e. 2
f. 6g. 0
h. 4
SOLUTION 5.6 a. 4.0
b. 4.5c. 0
d. 0.0e. 1.33
SOLUTION 5.7 a. 7int
b. 30 longc. 14.0
doubled. 90 long
e. 4.0 double
244 CHAPTER 5 •Java Data and Operators
SOLUTION 5.8 a. 34.0
b. 54
c. 4d. 1
e. 6
f. 0g. 2
h. 7.5
SOLUTION 5.9 a. k==5, j==5
b. k==5, j==6c. k==6, j==6
d. k==5, j==4e. k==4, j==4
SOLUTION 5.10 a. k==15,
j==5
b. k==5, j==6c. k==120,
j==6
d. k==0, j==4e. k==0, j==5
SOLUTION 5.11 k = k + 1; k += 1; k++; ++k;
SOLUTION 5.12 a. m = 5
b. m = 6c. m = 15
d. m = 50e. m = 70
SOLUTION 5.13 a. false
b. false
c. trued. illegal
e. true
f. illegalg. false
SOLUTION 5.14
☛ ✟
public c l a s s TemperatureUI
{private KeyboardReader reader ; // H a n d l e s command l i n e I /O
public TemperatureUI ( )
{reader = new KeyboardReader ( ) ; // C r e a t e r e a d e r o b j e c t
}
// I n p u t −p r o c e s s −o u t p u t a l g o r i t h m t o c o n v e r t t e m p e r a t u r e s .
public void run ( )
{reader . prompt ( ” Converts Fahrenheit and Celsius . \n”) ;
reader . prompt ( ” Input a temperature in Fahrenheit >”) ;
double tempIn = reader . getKeyboardDouble ( ) ;
double tempResult = Temperature . fahrToCels ( tempIn ) ;
reader . display ( tempIn + ” F = ” + tempResult + ” C\n”) ;
reader . prompt ( ” Input a temperature in Celsius >”) ;
tempIn = reader . getKeyboardDouble ( ) ;
tempResult = Temperature . celsToFahr ( tempIn ) ;
reader . display ( tempIn + ” C = ” + tempResult + ” F\n ” ) ;
}// r u n ( )
public s t a t i c void main ( S t r i n g args [ ] )
{TemperatureUI ui = new TemperatureUI ( ) ; // C r e a t e a n d
ui . run ( ) ; // r u n t h e u s e r i n t e r f a c e .
}// m a i n ( )
}// T e m p e r a t u r e U I
✡ ✠
CHAPTER 5 •Solutions to Self-Study Exercises 245
SOLUTION 5.15
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
// U s e t h i s p a n e l w i t h a J A p p l e t t o p −l e v e l w i n d o w ( a s p e r C h a p t e r 4 )
public c l a s s TemperatureJPanel extends JPanel implements ActionListener
{private J T e x t F i e l d i n F i e l d = new J T e x t F i e l d ( 1 5 ) ; // GUI c o m p o n e n t s
private J T e x t F i e l d r e s u l t F i e l d = new J T e x t F i e l d ( 1 5 ) ;
private JLabel prompt1 = new JLabel ( ” Input Temperature >>”) ;
private JLabel prompt2 = new JLabel ( ” Conversion Result : ” ) ;
private JButton celsToFahr = new JButton ( ”C to F” ) ;
private JButton fahrToCels = new JButton ( ”F to C” ) ;
private JPanel panelN = new JPanel ( ) ; // P a n e l s
private JPanel panelC = new JPanel ( ) ;
private JPanel panelS = new JPanel ( ) ;
private Temperature temperature = new Temperature ( ) ; // T e m p e r a t u r e o b j e c t
public TemperatureJPanel ( ) // S e t up u s e r i n t e r f a c e
{setLayout ( new BorderLayout ( ) ) ; // U s e B o r d e r L a y o u t
panelN . setLayout ( new BorderLayout ( ) ) ;
panelC . setLayout ( new BorderLayout ( ) ) ;
panelS . setLayout ( new BorderLayout ( ) ) ;
panelN . add ( ”North” , prompt1 ) ; // I n p u t e l e m e n t s
panelN . add ( ”South” , i n F i e l d ) ;
panelC . add ( ”West” , celsToFahr ) ; // C o n t r o l b u t t o n s
panelC . add ( ” East ” , fahrToCels ) ;
panelS . add ( ”North” , prompt2 ) ; // O u t p u t e l e m e n t s
panelS . add ( ”South” , r e s u l t F i e l d ) ;
add ( ”North” , panelN ) ; // I n p u t a t t h e t o p
add ( ” Center ” , panelC ) ; // B u t t o n s i n t h e c e n t e r
add ( ”South” , panelS ) ; // R e s u l t a t t h e b o t t o m
celsToFahr . addActionListener ( t h i s ) ; // R e g i s t e r w i t h l i s t e n e r s
fahrToCels . addActionListener ( t h i s ) ;
s e t S i z e ( 1 7 5 , 2 0 0 ) ;
}// T e m p e r a t u r e J P a n e l ( )
public void actionPerformed ( ActionEvent e )
{S t r i n g i n p u t S t r = i n F i e l d . getText ( ) ; // U s e r ’ s i n p u t
double userInput = Double . parseDouble ( i n p u t S t r ) ; // C o n v e r t t o d o u b l e
double r e s u l t = 0 ;
i f( e . getSource ( ) == celsToFahr ) { // P r o c e s s a n d r e p o r t
r e s u l t = temperature . celsToFahr ( userInput ) ;
r e s u l t F i e l d . s e t T e x t ( i n p u t S t r + ” C = ” + r e s u l t + ” F” ) ;
}else{
r e s u l t = temperature . fahrToCels ( userInput ) ;
r e s u l t F i e l d . s e t T e x t ( i n p u t S t r + ” F = ” + r e s u l t + ” C” ) ;
}
}// a c t i o n P e r f o r m e d
}// T e m p e r a t u r e J P a n e l
✡ ✠
246 CHAPTER 5 •Java Data and Operators
SOLUTION 5.16
☛ ✟
public c l a s s KBTestOneRowNim
{public s t a t i c void main ( S t r i n g argv [ ] )
{KeyboardReader kb = new KeyboardReader ( ) ;
OneRowNim game = new OneRowNim ( 1 1 ) ;
while ( game . gameOver ( ) == f a l s e )
{ game . report ( ) ; // P r o m p t t h e u s e r
System . out . p r i n t ( ” Input 1 , 2 , or 3 : ” ) ;
i n t s t i c k s = kb . getKeyboardInteger ( ) ; // G e t move
game . t a k e S t i c k s ( s t i c k s ) ; {\c o l o r{cyan}// Do move }
System . out . p r i n t l n ( ) ;
}// w h i l e
game . report ( ) ; // T h e g a m e i s now o v e r
System . out . p r i n t ( ”Game won by player ” ) ;
System . out . p r i n t l n ( game . getWinner ( ) ) ;
}// m a i n ( )
}// T e s t O n e R o w N i m
✡ ✠
SOLUTION 5.17 The new version of OneRowNim should run properly with the
user interface from Chapter 4. This shows that our new deﬁnition f orOneRowNim
is backwards compatible with the old user interface. This is a g ood thing.
SOLUTION 5.18
☛ ✟
public c l a s s NimPlayer
{private OneRowNim nim ;
public NimPlayer (OneRowNim game )
{nim = game ;
}// N i m P l a y e r ( )
public i n t move ( )
{i n t s t i c k s L e f t = nim . g e t S t i c k s ( ) ;
i f( s t i c k s L e f t % ( nim . MAX PICKUP + 1) != 1)
return ( s t i c k s L e f t −1) % ( nim . MAX PICKUP + 1 ) ;
else
{i n t maxPickup = Math . min ( nim . MAX PICKUP, s t i c k s L e f t ) ;
return 1 + ( i n t) ( Math . random ( ) ∗maxPickup ) ;
}// e l s e
}// move ( )
}// N i m P l a y e r
✡ ✠
CHAPTER 5 •Solutions to Self-Study Exercises 247
SOLUTION 5.19
☛ ✟
public c l a s s KBComputerNim
{public s t a t i c void main ( S t r i n g argv [ ] )
{ KeyboardReader kb = new KeyboardReader ( ) ;
OneRowNim game = new OneRowNim(OneRowNim . MAX STICKS ) ;
NimPlayer computer = new NimPlayer ( game ) ;
System . out . p r i n t l n ( ” Let ’ s play One Row Nim” ) ;
while ( game . gameOver ( ) == f a l s e ){
i f( game . getPlayer ( ) == game . PLAYER ONE)
{kb . prompt ( ” S t i c k s l e f t = ” + game . g e t S t i c k s ( ) +
” Your move . ” ) ; // P r o m p t
kb . prompt ( ”You can pick up between 1 and ” +
Math . min ( game . MAX PICKUP, game . g e t S t i c k s ( ) ) + ” : ” ) ;
i n t s t i c k s = kb . getKeyboardInteger ( ) ; // G e t move
game . t a k e S t i c k s ( s t i c k s ) ; // Do move
}else
{kb . prompt ( ” S t i c k s l e f t = ” + game . g e t S t i c k s ( ) +
” My move . ” ) ;
i n t s t i c k s = computer . move ( ) ;
game . t a k e S t i c k s ( s t i c k s ) ;
System . out . p r i n t l n ( ” I take ” + s t i c k s ) ;
}// e l s e
}// w h i l e
// T h e g a m e i s now o v e r
kb . display ( ” S t i c k s l e f t = ” + game . g e t S t i c k s ( ) ) ;
i f( game . getWinner ( ) == game . PLAYER ONE)
System . out . p r i n t l n ( ” You win . Nice game ! ” ) ;
else
System . out . p r i n t l n ( ” I win . Nice game ! ” ) ;
}// m a i n ( )
}// K B C o m p u t e r N i m
✡ ✠
SOLUTION 5.20
☛ ✟
public c l a s s BankCD
{private double p r i n c i p a l ; // T h e CD ’ s i n i t i a l p r i n c i p a l
private double r a t e ; // CD ’ s i n t e r e s t r a t e
private double years ; // N u m b e r o f y e a r s t o m a t u r i t y
public BankCD( double p ,double r ,double y )
{ p r i n c i p a l = p ;
r a t e = r ;
years = y ;
}// BandCD ( )
public double c a l c Y e a r l y ( )
{ return p r i n c i p a l ∗Math . pow(1 + rate , years ) ;
}// c a l c Y e a r l y ( )
public double c a l c D a i l y ( )
{ return p r i n c i p a l ∗Math . pow(1 + r a t e /365 , years ∗3 6 5 ) ;
}// c a l c D a i l y ( )
}// B a n k C D
✡ ✠
248 CHAPTER 5 •Java Data and Operators
SOLUTION 5.21
☛ ✟
import java . t e x t . NumberFormat ; // F o r f o r m a t t i n g \$ n n . dd o r n \%
public c l a s s TestBankCD
{private KeyboardReader reader = new KeyboardReader ( ) ;
private NumberFormat d o l l a r s = NumberFormat . getCurrencyInstanc e ( ) ;
private NumberFormat percent = NumberFormat . g e t P e r c e n t I n s t a n c e ( ) ;
private BankCD cd ;
public void run ( )
{reader . display ( ”Compares d a i l y and annual compounding f o r a CD. \n”) ;
reader . prompt ( ” Input the CD’ s i n i t i a l p r i n c i p a l , e . g . 1000.55 >”) ;
double p r i n c i p a l = reader . getKeyboardDouble ( ) ;
reader . prompt ( ” Input the CD’ s i n t e r e s t rate , e . g . 6 . 5 >”) ;
double r a t e = reader . getKeyboardDouble ( ) / 1 0 0 . 0 ;
reader . prompt ( ” Input the number of years to maturity , e . g . , 1 0 . 5 >”) ;
double years = reader . getKeyboardDouble ( ) ;
cd = new BankCD( p r i n c i p a l , rate , years ) ;
percent . setMaximumFractionDigits ( 2 ) ;
System . out . p r i n t l n ( ” For P r i n c i p a l = ” + d o l l a r s . format ( p r i n c i p a l ) +
” Rate= ” + percent . format ( r a t e ) +
” Years= ” + years ) ;
double cdAnnual = cd . c a l c Y e a r l y ( ) ; // C o m p o u n d e d y e a r l y
double cdDaily = cd . c a l c D a i l y ( ) ; // C o m p o u n d e d a n n u a l l y
System . out . p r i n t l n ( ” The maturity value compounded yearly i s ” +
d o l l a r s . format ( cdAnnual ) ) ;
System . out . p r i n t l n ( ” The maturity value compounded d a i l y i s : ” +
d o l l a r s . format ( cdDaily ) ) ;
}// r u n ( )
public s t a t i c void main ( S t r i n g args [ ] )
{TestBankCD cd = new TestBankCD ( ) ;
cd . run ( ) ;
}// m a i n ( )
}// T e s t B a n k C D
✡ ✠
SOLUTION 5.22
a. validb. valid
c. ch2 = (char)n;d. valid
e. ch1 = (char)(m-n);
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 5.1 Explain the difference between the following pairs of terms:
a.Representation and action .
b.Binary operator and unary operation .
c.Class constant and class variable .
d.Helper method and class method .
e.Operator overloading and method overloading .
f.Method call and method composition .
g.Type conversion and type promotion .
EXERCISE 5.2 For each of the following data types, list how many bits are used
in its representation and how many values can be represented:
CHAPTER 5 •Exercises 249
a.int b.char c.byte d.long e.double
EXERCISE 5.3 Fill in the blanks.
a. Methods and variables that are associated with a class rathe r than with its
instances must be declared .
b. When an operation involves values of two different types, one va lue must be
before the expression can be evaluated.
c. Constants should be declared .
d. Variables that take true andfalse as their possible values are known as
.
EXERCISE 5.4 Arrange the following data types into a promotion hierarchy:
double ,float ,int,short ,long .
EXERCISE 5.5 Assuming that o1is true, o2is false, and o3is false, evaluate each
of the following expressions:
a.o1 || o2 && o3 b.o1 ˆ o2 c.!o1 && !o2
EXERCISE 5.6 Arrange the following operators in precedence order:
☛ ✟
+−( )∗/ %<==
✡ ✠
EXERCISE 5.7 Arrange the following operators into a precedence hierarchy:
☛ ✟
∗,++ , %, ==
✡ ✠
EXERCISE 5.8 Parenthesize and evaluate each of the following expressions (if
an expression is invalid, mark it as such):
a.11 / 3 % 2 == 1
b.11 / 2 % 2 > 0c.15 % 3 >= 21 %
d.12.0 / 4.0 >= 12 / 3e.15 / 3 == true
EXERCISE 5.9 What value would mhave after each of the statements that fol-
low is executed? Assume that m, k, j are reinitialized before each statement.
☛ ✟
i n t m = 5 , k = 0 , j = 1 ;
✡ ✠
a.m = ++k + j;
b.m += ++k *j;c.m %= ++k + ++j;
d.m = m - k - j;e.m = ++m;
EXERCISE 5.10 What value would bhave after each of the statements that fol-
low is executed? Assume that m, k, j are reinitialized before each statement. It may
help to parenthesize the right-hand side of the statements be fore evaluating them.
☛ ✟
boolean b ;
i n t m = 5 , k = 0 , j = 1 ;
✡ ✠
a.b = m > k + j;
b.b = m *m != m *j;
c.b = m <= 5 && m % 2 == 1;d.b = m < k || k < j;
e.b = --m == 2 *++j;
EXERCISE 5.11 For each of the following expressions, if it is valid, deter-
mine the value of the variable on the left-hand side (if not, chan ge it to a valid
expression):
☛ ✟
char c = ’ a ’ ;
i n t m = 9 5 ;
✡ ✠
250 CHAPTER 5 •Java Data and Operators
a.c = c + 5;
b.c = ’A’ + ’B’;c.m = c + 5;
d.c = (char) m + 1;e.m = ’a’ - 32;
EXERCISE 5.12 Translate each of the following expressions into Java:
a. Area equals pitimes the radius squared.
b. Area is assigned pitimes the radius squared.
c. Volume is assigned pitimes radius cubed divide by h.
d. If mand nare equal, then mis incremented by one; otherwise nis incremented.
e. If mis greater than ntimes 5, then square mand double n; otherwise square n
and double m.
EXERCISE 5.13 What would be output by the following code segment?
☛ ✟
i n t m = 0 , n = 0 , j = 0 , k = 0 ;
m = 2 ∗n++;
System . out . p r i n t l n ( ”m = ” + m + ” n= ” + n ) ;
j += ( −−k∗2 ) ;
System . out . p r i n t l n ( ” j = ” + j + ” k= ” + k ) ;
✡ ✠
Each of the problems that follow asks you to write a method. Of course, as you are
developing the method in a stepwise fashion, you should test it. He re’s a simple
application program that you can use for this purpose:
☛ ✟
public c l a s s MethodTester {
public s t a t i c i n t square ( i n t n ){
return n∗n ;
}
public s t a t i c void main ( S t r i n g args [ ] ) {
System . out . p r i n t l n ( ”5 squared = ” + square ( 5 ) ) ;
}
}
✡ ✠
Just replace the square() method with your method. Note that you must declare
your method static if you want to call it directly from main() as we do here.
EXERCISE 5.14 Write a method to calculate the sales tax for a sale item. The
method should take two double parameters, one for the sales price and the other
for the tax rate. It should return a double . For example, calcTax(20.0, 0.05)
should return 1.0.
EXERCISE 5.15 Challenge: Suppose you’re writing a program that tells what
day of the week someone’s birthday falls on this year. Write a method that takes
anint parameter, representing what day of the year it is, and return s aString
like “Monday.” For example, for 2004, a leap year, the ﬁrst day of t he year was on
Thursday. The thirty-second day of the year (February 1, 2004) was a Sunday, so
getDayOfWeek(1) should return “Thursday” and getDayOfWeek(32) should
return “Sunday.” ( Hint : If you divide the day of the year by 7, the remainder will
always be a number between 0 and 6, which can be made to correspon d to days of
the week.)
EXERCISE 5.16 Challenge: As part of the birthday program, you’ll want a
method that takes the month and the day as parameters and return s what day of
the year it is. For example, getDay(1,1) should return 1; getDay(2,1) should
return 32; and getDay(12,31) should return 365. ( Hint : If the month is 3, and
the day is 5, you have to add the number of days in January plus the number of
days in February to 5 to get the result: 31 + 28 + 5 = 64.)
CHAPTER 5 •Exercises 251
EXERCISE 5.17 Write a Java method that converts a char to lowercase. For
example, toLowerCase(’A’) should return ‘a’. Make sure you guard against
method calls like toLowerCase(’a’) .
EXERCISE 5.18 Challenge: Write a Java method that shifts a char bynplaces
in the alphabet, wrapping around to the start of the alphabet, i f necessary. For ex-
ample, shift(’a’,2) should return ‘c’; shift(’y’,2) should return ‘a’. This
method can be used to create a Caesar cipher, in which every let ter in a message is
shifted by nplaces—hfu ju? (Refer to Chapter 1 exercises for a refresher on Caesar
cipher.)
EXERCISE 5.19 Write a method that converts its boolean parameter to a
String . For example, boolToString(true) should return “true.”
EXERCISE 5.20 Write a Java application that ﬁrst prompts the user for three
numbers, which represent the sides of a rectangular cube, and then computes and
outputs the volume and the surface area of the cube.
EXERCISE 5.21 Write a Java application that prompts the user for three num-
bers and then outputs the three numbers in increasing order.
EXERCISE 5.22 Write a Java application that inputs two integers and then de-
termines whether the ﬁrst is divisible by the second. ( Hint : Use the modulus
operator.)
EXERCISE 5.23 Write a Java application that prints the following table:
☛ ✟
N SQUARE CUBE
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
✡ ✠
EXERCISE 5.24 Design and write a Java GUI that converts kilometers to miles
and vice versa. Use a JTextField for I/O and JButton s for the various conver-
sion actions.
EXERCISE 5.25 Design and write a GUI that allows a user to calculate the ma-
turity value of a CD. The user should enter the principal, inter est rate, and years,
and the applet should then display the maturity value. Make us e of the BankCD
class covered in this chapter. Use separate JTextField s for the user’s inputs and
a separate JTextField for the result.
EXERCISE 5.26 Design and write a GUI that lets the user input a birth date
(month and day) and reports what day of the week it falls on. Use the
getDayOfWeek() andgetDay() methods that you developed in previous ex-
ercises.
EXERCISE 5.27 Design and write a GUI that allows the users to input their
exam grades for a course and computes their average and probable l etter grade.
The applet should contain a single JTextField for inputting a grade and a single
JTextField for displaying the average and letter grade. The program should
keep track internally of how many grades the student has entere d. Each time a
new grade is entered, it should display the current average an d probable letter
grade.
252 CHAPTER 5 •Java Data and Operators
EXERCISE 5.28 One of the reviewers of this text has suggested an alterna-
tive design for the Temperature class (Fig. 5.5). According to this design, the
class would contain an instance variable, say, temperature , and access methods
that operate on it. The access methods would be: setFahrenheit(double) ,
getFahrenheit():double ,setCelsius(double) , and getCelsius():
double . One way to implement this design is to store the temperature i n the
Kelvin scale and then convert from and to Kelvin in the access me thods. The
formula for converting Kelvin to Celsius is
☛ ✟
K = C + 273.15
✡ ✠
Draw a UML class diagram representing this design of the Temperature class.
Which design is more object oriented, this one or the one used in Figu re 5.5?
EXERCISE 5.29 Write an implementation of the Temperature class using the
design described in the previous exercise.
OBJECTIVES
After studying this chapter, you will
•Be able to solve problems involving repetition.
•Understand the differences among various loop structures.
•Know the principles used to design effective loops.
•Improve your algorithm design skills.
•Understand the goals and principles of structured programm ing.
OUTLINE
6.1 Introduction
6.2 Flow of Control: Repetition Structures
6.3 Counting Loops
6.4 Example: Car Loan
6.5 Graphics Example: Drawing a Checkerboard
6.6 Conditional Loops
6.7 Example: Computing Averages
6.8 Example: Data Validation
6.9 Principles of Loop Design
6.10 The switch Multiway Selection Structure
6.11 Object-Oriented Design: Structured Programming
Special Topic: What Can Be Computed?
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 6
Control Structures
253
254 CHAPTER 6 •Control Structures
6.1 Introduction
As we learned in Chapter 3, a control structure is a language e lement that
changes the ﬂow of control of a program. Thus far, we have used t heif
andif/else statements to select between two or more alternate paths in
a program. We have used the while -loop structure to repeat statements.
And we have used method-call-and-return to invoke methods t hat carry
out certain well-deﬁned tasks in a program.
In this chapter we will extend our repertoire of control struc tures. We
will introduce the forand do-while statements, both of which are used in
programs that require calculations to be repeated. We will a lso introduce
theswitch statement, which will give us another way, in addition to
if/else , to select from among several alternate paths in a program.
We begin by introducing the idea of a counting loop , which is used for
repetitive tasks when you know beforehand exactly how many r epetitions
are necessary. This type of loop is most often implemented us ing afor
statement.
We then distinguish two kinds of conditional loops , which are used for
performing repetitive tasks where the number of repetition s depends on
some kind of non-counting condition. These kinds of loops ar e usually
implemented using Java’s while anddo-while statements. We give ex-
amples of several kinds of loop bounds and use them to identify several
useful principles of loop design. Finally, we introduce som e of the key
principles of the structured programming approach, a disciplined design
approach that preceded the object-oriented approach.
6.2 Flow of Control: Repetition Structures
As we saw in Chapter 3, a repetition structure is a control structure that
repeats a statement or sequence of statements. Many program ming tasks
require a repetition structure. Consider some examples.
•You’re working for the National Security Agency trying to de cipher se-
cret messages intercepted from foreign spies, and you want t o count the
number of times a certain letter, “a,” occurs in a document co ntaining
Ncharacters. In this case, you would want to employ something l ike
the following (pseudocode) algorithm:
☛ ✟
i n i t i a l i z e t o t a l A s to 0
for each c h a r a c t e r in the document
i fthe c h a r a c t e r i s an ’ a ’
add 1 to t o t a l A s
return t o t a l A s as the r e s u l t
✡ ✠
•You’re working for a caterer who wants to number the invitati ons to a
client’s wedding, so you need to print the numbers between 1 a nd 5000
SECTION 6.3 •Counting Loops 255
on the invitation cards (it’s a big wedding)! In this case, you want to go
through each number, 1 to 5000, and simply print it out:
☛ ✟
for each number , N, from 1 to 5000
p r i n t N on the i n v i t a t i o n card
✡ ✠
•You are helping the forest service in Alaska to track the numb er of black
bear sightings, and you want to compute the average number of sight-
ings per month. Suppose the user enters each month’s count at the
keyboard, and uses a special number, say, 9999, to signify th e end of
the sequence. However, 9999 should not be ﬁgured into the aver age.
This example differs a bit from the preceding ones, because h ere you
don’t know exactly how many numbers the user will input:
☛ ✟
i n i t i a l i z e sumOfBears to 0
i n i t i a l i z e numOfMonths to 0
repeat the following steps
read a number from the keyboard
i fthe number i s NOT 9999
add i t to the sumOfBears
add 1 to numOfMonths
u n t i l the number read i s 9999
divide sumOfBears by numOfMonths giving average
return average as the r e s u l t
✡ ✠
We repeat the process of reading numbers and adding them to a r un-
ning total “until the number read is 9999.”
•Student records are stored in a ﬁle and you want to calculate E rika
Wilson’s current GPA. Here we need to perform a repetitive pro cess—
searching through the ﬁle for Erika Wilson’s record—but agai n we
don’t know exactly how many times to repeat the process:
☛ ✟
repeat the following steps
read a record from the f i l e
u n t i l Erika Wilson ’ s record i s read
compute Erika Wilson ’ s GPA
return gpa as the r e s u l t
✡ ✠
As these examples suggest, two types of loops are used: count ing loops
and non-counting loops. Counting loops are used whenever yo u know
in advance exactly how many times an action must be performed . Non-
counting loops are used when the number of repetitions depen ds on
some condition—for example, the number of data items input fr om the
keyboard or the input of a particular record from a ﬁle.
6.3 Counting Loops
Acounting loop , orcounter-controlled loop , is a loop in which you know
beforehand how many times it will be repeated. Among the prec eding
examples, the ﬁrst two are counting loops.
256 CHAPTER 6 •Control Structures
Because you know the exact number of times the loop repeats be fore-
hand, a counting loop can be made dependent on the value of a co unter.
For example, if you want to print the word “Hello” 100 times, yo u can use
the following while structure:
☛ ✟
i n t k = 0 ;
while ( k<100){
System . out . p r i n t l n ( ” Hello ” ) ;
k++;
}
✡ ✠
In this case, the counter is the variable k, which counts from 0 through
99—that is, it counts 100 times. Note that we start counting fr om 0 instead
of 1. Counting from 0 is known as zero indexing and it is a common
programming convention for counting loops. Although it doe sn’t really
make any practical difference in this case, later on we will u se loops to
process structures, such as strings and arrays, which use ze ro indexing. It Zero indexing
will be easier to process these structures if our loop counte r also starts at 0.
The variable kin this example is called a counter variable orloop counter . Loop counter
Although it is certainly possible to name the counter variab le anything we
like, it is customary to use single letters like i, j, and kas loop counters. The
fundamental feature of a counting loop is that we must know be forehand
exactly how many iterations the loop will take.
JAVA EFFECTIVE DESIGN Loop Design. Acounting loop can be
used whenever you know exactly how many times a process must b e
repeated.
Although we can use a while -structure to code a counting loop, Java’s
for statement is ideally suited for this purpose. For example, t he follow-
ingfor statement will also print the word “Hello” 100 times:
☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k++)
System . out . p r i n t l n ( ” Hello ” ) ;
✡ ✠
In fact, this for statement is equivalent to the preceding while structure.
Thefor statement has the following syntax:
JAVA LANGUAGE RULE For Statement. The for statement has the
following syntax:
for(initializer ;loopentrycondition ;updater)
forloopbody ;
The for statement begins with the keyword for, which is followed by a
parenthesized list of three expressions separated by semic olons: an ini-
tializer , aloop entry condition , and an updater . Following the paren-
thesized list is the for loop body , which is either a single statement or a
sequence of statements contained in curly brackets, {. . .}.
SECTION 6.3 •Counting Loops 257
True
println("Hello")Initializer
Updater
Statement
(loop body)True
Falsek+ +
FalseLoop
entry
conditionk<100k=0Figure 6.1: Flowchart of the for
statement.
6.3.1 The For Structure
Figure 6.1 shows how the for statement works. It might be useful to
compare this ﬂowchart with the ﬂowchart for the the while structure
(Fig. 6.2), which was introduced in Chapter 3. You see that it has exactly
the same structure. First, the initializer is evaluated. Th us, the initializer
sets the integer variable kto 0. Then the loop entry condition, which must
be a boolean expression, is evaluated. If it is true, the body o f the loop is
executed; if it is false, the body of the loop is skipped and co ntrol passes to
the next statement following the for statement. The updater is evaluated
after the loop body is executed. After completion of the upda ter, the loop
entry condition is reevaluated and the loop body is either ex ecuted again
or not, depending on the truth value of the loop entry conditi on. This
process is repeated until the loop entry condition becomes f alse.
While Statement While Structure
StatementTrue
FalseConditionUpdater
Statement
(loop body)True
FalseLoop
entry
conditionInitializerFigure 6.2: Flowchart of the
while statement and while
structure.
258 CHAPTER 6 •Control Structures
Tracing the order in which the for loop components are evaluated
gives this sequence:
☛ ✟
evaluate i n i t i a l i z e r
evaluate loop entry condition == >True
execute for loop body ;
evaluate updater
evaluate loop entry condition == >True
execute for loop body ;
evaluate updater
evaluate loop entry condition == >True
execute for loop body ;
evaluate updater
.
.
.
evaluate loop entry condition == >F a l s e
✡ ✠
As this trace shows, the loop entry condition controls entry to the body
of the loop and will, therefore, be the last thing done before the loop
terminates.
We have followed the standard convention of declaring the co unter
variable in the header of the for statement. This restricts the variable’s Loop variable scope
scope to thefor statement itself. It would be a syntax error to use koutside
the scope of the for loop, as in this example:
☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k++)
System . out . p r i n t l n ( ” Hello ” ) ;
// S y n t a x e r r o r , k u n d e c l a r e d
System . out . p r i n t l n ( ”k = ” + k ) ;
✡ ✠
For some problems, it might be necessary to use the loop varia ble out-
side the scope of the for statement, in which case the variable should be
declared before the for statement. For example, if we want to print the
value of the loop variable, k, after the loop completes, we have to declare
it before the loop:
☛ ✟
i n t k = 0 ; // D e c l a r e t h e l o o p v a r i a b l e h e r e
for ( k = 0 ; k <1 0 0 ; k++)
System . out . p r i n t l n ( ” Hello ” ) ;
System . out . p r i n t l n ( ”k = ” + k ) ; // T o u s e i t h e r e
✡ ✠
In this example, the loop will exit when kbecomes 100, so “k = 100” will
be printed.
6.3.2 Loop Bounds
A counting loop starts at some initial value and counts 0 or mo re itera-
tions. A loop bound is a value that controls how many times a loop is
repeated. A loop will repeat until its loop bound is reached. In a count- Loop bound
ing loop, the loop entry condition should be a boolean expression that tests
SECTION 6.3 •Counting Loops 259
whether the loop’s bound has been reached. Similarly, in a co unting loop,
theupdater should modify the loop counter so that it makes progress to-
ward reaching its bound. Counting loops often increment or d ecrement
their counter by 1, depending on whether the loop is counting forward
or backward. The following method contains a countdown loop , which
prints 10 9 8 7 6 5 4 3 2 1 BLASTOFF . In this case, progress to-
ward the loop bound is made by decrementing the loop counter:
☛ ✟
public void countdown ( ) {
for (i n t k = 1 0 ; k >0 ; k−−)
System . out . p r i n t ( k + ” ” ) ;
System . out . p r i n t l n ( ”BLASTOFF” ) ;
}// c o u n t d o w n ( )
✡ ✠
Note in this case that we are using unit indexing instead of zero indexing, Unit indexing
because countdowns repeat, or iterate , from 10 down to 1, not from 10
down to 0.
6.3.3 Inﬁnite Loops
If the loop bound is never reached, the loop entry condition wi ll never
become false and the loop will repeat forever. This is known a s an inﬁnite
loop . Can you see why each of the following for statements will result in Inﬁnite loop
an inﬁnite loop?
☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k−−) // I n f i n i t e l o o p
System . out . p r i n t l n ( ” Hello ” ) ;
for (i n t k = 1 ; k != 1 0 0 ; k+=2) // I n f i n i t e l o o p
System . out . p r i n t l n ( ” Hello ” ) ;
for (i n t k = 9 8 ; k <1 0 0 ; k = k / 2) // I n f i n i t e l o o p
System . out . p r i n t l n ( ” Hello ” ) ;
✡ ✠
In the ﬁrst example, kstarts out at 0 and is decremented on each itera-
tion, taking on values −1,−2,−3, and so on, so kwill never reach its loop
bound.
In the second example, kstarts out at 1 and is incremented by 2 on each
iteration, taking on the values 3, 5, 7, and so on. Because all these values
are odd, kwill never equal 100. A much safer loop bound in this case
would be k<= 100 .
In the third example, kstarts out at 98 and is halved on each iteration,
taking on the values 49, 24, 12, 6, 3, 1, 0, 0, and so on, forever . Thus, it too
will be stuck in an inﬁnite loop.
Encountering an unintended inﬁnite loop when developing a p rogram
can be very frustrating. If the program is stuck in a loop that g ener- Stuck in a loop
ates output, it will be obvious that it is looping, but if no ou tput is be-
ing generated, the computer will appear to “freeze,” no long er respond-
ing to your keyboard or mouse commands. Some programming env i-
ronments allow you to break out of a looping program by typing a spe-
cial keyboard command such as CONTROL-C orCTRL-ALT-DELETE or
260 CHAPTER 6 •Control Structures
CONTROL-APPLE-ESCAPE , but if that doesn’t work you will have to re-
boot the computer, possibly causing a loss of data. The best w ay to avoid
inﬁnite loops is to determine that the loop’s updater expres sion will cause
the loop to eventually reach its bound.
JAVA EFFECTIVE DESIGN Loop Design. To guard against inﬁnite
loops, make sure that the loop bound will eventually be reach ed.
6.3.4 Loop Indentation
Note how indentation is used to distinguish the loop body fro m both the
heading and from the statement that follows the loop:
☛ ✟
for (i n t k = 1 0 ; k >0 ; k−−) // L o o p h e a d i n g
System . out . p r i n t ( k + ” ” ) ; // I n d e n t t h e b o d y
System . out . p r i n t l n ( ”BLASTOFF” )// A f t e r t h e l o o p
✡ ✠
Indenting the loop body is a stylistic convention intended to make the
code more readable. However, the indentation itself has no ef fect on how
the code is interpreted by Java. Each of the following code se gments
would still produce the same countdown:
☛ ✟
for (i n t k = 1 0 ; k >0 ; k−−)
System . out . p r i n t ( k + ” ” ) ;
System . out . p r i n t l n ( ”BLASTOFF” ) ;
for (i n t k = 1 0 ; k >0 ; k−−) System . out . p r i n t ( k + ” ” ) ;
System . out . p r i n t l n ( ”BLASTOFF” ) ;
for
(i n t k = 1 0 ; k >0 ; k−−)
System . out . p r i n t ( k + ” ” ) ;
System . out . p r i n t l n ( ”BLASTOFF” ) ;
✡ ✠
In each case the statement, System.out.println("BLASTOFF") , is
not part of the for loop body and is executed only once when the loop
terminates.
JAVA PROGRAMMING TIP Loop Indentation. To make loops more
readable, indent the loop body to set it off from the heading a nd to
highlight which statement(s) will be repeated.
JAVA DEBUGGING TIP Loop Indentation. Loop indentation has no
effect on how Java interprets the loop. The loop body is deter mined
entirely by the syntax of the for statement.
Note that up to this point the loop body has consisted of a sing le state-
ment, such as a println() statement. But the loop body may con-
sist of any Java statement, including an iforif-else statement or a
SECTION 6.3 •Counting Loops 261
compound statement, which contains a sequence of statement s enclosed
within braces. Consider the following examples. The ﬁrst ex ample prints
the sequence 0, 5, 10, 15, ...95. Its loop body consists of a single if
statement:
☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k++) // P r i n t 0 5 1 0 . . . 9 5
i f( k % 5 == 0) // L o o p b o d y : s i n g l e i f s t a t e m e n t
System . out . p r i n t l n ( ”k= ” + k ) ;
✡ ✠
The next example prints the lowercase letters of the alphabe t. In this case,
the loop counter is of type char , and it counts the letters of the alphabet.
The loop body consists of a single print() statement:
☛ ✟
for (char k = ’ a ’; k<=’ z ’; k++) // P r i n t ’ a ’ ’ b ’ . . . ’ z ’
System . out . p r i n t ( k + ” ” ) ; // L o o p b o d y : s i n g l e p r i n t ( )
✡ ✠
The next example prints the sequence 5, 10, 15, ...50, but it uses several
statements within the loop body:
☛ ✟
for (i n t k = 1 ; k <= 1 0 ; k++) {// P r i n t 5 1 0 1 5 . . . 5 0
i n t m = k ∗5 ; // B e g i n b o d y
System . out . p r i n t (m + ” ” ) ;
} // E n d b o d y
✡ ✠
In this example, the scope of the local variable m, declared within the loop
body, is limited to the loop body and cannot be used outside of that scope.
JAVA LANGUAGE RULE Loop Body. The body of a for statement
consists of the statement that immediately follows the for loop
heading. This statement can be either a simple statement or a
compound statement—a sequence of statements enclosed withi n
braces,{. . .}.
Although braces are not required when the body of a for loop consists
of a single statement, some coding styles recommend that bra ces should
always be used for the body of a loop statement. For example, i t is always
correct to code the for loop as
☛ ✟
for (i n t k = 1 ; k <= 1 0 ; k++) {// P r i n t 1 2 . . . 1 0
System . out . p r i n t ( k + ” ” ) ; // B e g i n b o d y
} // E n d b o d y
✡ ✠
262 CHAPTER 6 •Control Structures
Another advantage of this coding style is that you can easily place addi-
tional statements in the loop body by placing them within the braces.
JAVA DEBUGGING TIP Missing Braces. A common programming
error for novices is to forget to use braces to group the state ments they
intend to put in the loop body. When braces are not used only the ﬁrst
statement after the loop heading will be iterated.
SELF-STUDY EXERCISES
EXERCISE 6.1 Identify the syntax error in the following for loop
statements.
a.☛ ✟
for (i n t k = 5 , k <100 , k++)
System . out . p r i n t l n ( k ) ;
✡ ✠
b.☛ ✟
for (i n t k = 0 ; k <12 ; k−−;)
System . out . p r i n t l n ( k ) ;
✡ ✠
EXERCISE 6.2 Identify those statements that result in inﬁnite loops.
a.☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k = k )
System . out . p r i n t l n ( k ) ;
✡ ✠
b.☛ ✟
for (i n t k = 1 ; k == 1 0 0 ; k = k + 2 )
System . out . p r i n t l n ( k ) ;
✡ ✠
c.☛ ✟
for (i n t k = 1 ; k >= 1 0 0 ; k = k −2 )
System . out . p r i n t l n ( k ) ;
✡ ✠
EXERCISE 6.3 Suppose you’re helping your little sister learn to count
by fours. Write a for loop that prints the following sequence of numbers:
1, 5, 9, 13, 17, 21, 25.
EXERCISE 6.4 What value will jhave when the following loop
terminates?
☛ ✟
for (i n t i = 0 ; i <1 0 ; i ++) {
i n t j ;
j = j + 1 ;
}
✡ ✠
SECTION 6.3 •Counting Loops 263
6.3.5 Nested Loops
Anested loop is a structure in which one loop is contained inside the body
of another loop, such as when a for loop body contains a for loop. For
example, suppose you are working for Giant Auto Industries, a nd your
boss wants you to print a table for buyers to ﬁgure the cost of b uying mul-
tiple quantities of a certain part. The cost of individual pa rts ranges from
$1 to $9. The cost of Nitems is simply the unit price times the quantity.
Thus, you’ll want to print something like the following tabl e of numbers,
where the prices per unit are listed in the top row, and the pri ces for 2, 3
and 4 units are listed in subsequent rows:
☛ ✟
1 2 3 4 5 6 7 8 9
2 4 6 8 10 12 14 16 18
3 6 9 12 15 18 21 24 27
4 8 12 16 20 24 28 32 36
✡ ✠
To produce this multiplication table, we could use the follo wing nested
for loops:
☛ ✟
1for (i n t row = 1 ; row <= 4 ; row++) {// F o r e a c h o f 4 r o w s
2 for (i n t c o l = 1 ; c o l <= 9 ; c o l ++) // F o r e a c h o f 9 c o l u m n s
3 System . out . p r i n t ( c o l ∗row + ”\t ”) ; // P r i n t n u m b e r
4 System . out . p r i n t l n ( ) ; // S t a r t a new r o w
5}// f o r r o w
✡ ✠
Note how indenting is used here to distinguish the levels of n esting and to
make the code more readable. In this example, the outer loop controls the Inner and outer loop
number of rows in the table, hence, our choice of row as its loop counter.
Theprintln() statement is executed after the inner loop is done iterating,
which allows us to print a new row on each iteration of the oute r loop. The
inner loop prints the nine values in each row by printing the e xpression
col*row. Obviously, the value of this expression depends on both loo p
variables.
Let’s dissect this example a bit. How many times is the for statement
in line 2 executed? The inner loop is executed once for each it eration of
the outer loop. Thus, it is executed four times, which is the s ame number
of times that line 4 is executed. How many times is the statemen t on line
3 executed? The body of the inner loop is executed 36 times—9 ti mes for
each execution of line 2.
Sometimes it is useful to use the loop variable of the outer lo op as the Algorithm design
bound for the inner loop. For example, consider the followin g pattern:
☛ ✟
# # # # #
# # # #
# # #
# #
#
✡ ✠
264 CHAPTER 6 •Control Structures
Note that the number of # symbols in each row varies inversely with the
row number. In row 1, we have ﬁve symbols; in row 2 we have four; a nd
so on down to row 5, where we have one #.
To produce this kind of two-dimensional pattern, we need two coun-
ters: one to count the row number, and one to count the number o f #
symbols in each row. Because we have to print each row’s symbo ls before
moving on to the next row, the outer loop will count row number s, and
the inner loop will count the symbols in each row. But note tha t the inner
loop’s bound will depend on the row number. Thus, in row 1 we wa nt
ﬁve symbols; in row 2 we want four symbols; and so on. If we let row be
the row number, then in each row we want to print 6 −rowsymbols. The
following table shows the relationship we want:
Row Bound (6-row) Number of Symbols
1 6-1 5
2 6-2 4
3 6-3 3
4 6-4 2
5 6-5 1
If we let jbe the counter for the inner loop, then jwill be bound by the
expression 6 −row. This leads to the following nested loop structure:
☛ ✟
for (i n t row = 1 ; row <= 5 ; row++) {// F o r e a c h r o w
for (i n t j = 1 ; j <= 6−row ; j ++) // P r i n t t h e r o w
System . out . p r i n t ( ’ # ’) ;
System . out . p r i n t l n ( ) ; // S t a r t a new l i n e
}// f o r r o w
✡ ✠
Note that the bound of the inner loop varies according to the v alue of row,
the loop counter for the outer loop.
SELF-STUDY EXERCISE
EXERCISE 6.5 As the engineer hired to design ski jumps, write a nested
for loop to print the following pattern:
☛ ✟
#
# #
# # #
# # # #
# # # # #
✡ ✠
6.4 Example: Car Loan
Recall the self-study exercise from Chapter 5 that calculat ed the value of a
bank CD ( a) given its initial principle ( p), interest rate ( r), and number of
years ( n), using the formula a=p(1+r)n. This section explains how to use
SECTION 6.4 •Example: Car Loan 265
the same formula to calculate the cost of a car loan for differ ent interest
rates over various time periods.
Problem Description
For example, suppose you are planning on buying a car that cos ts $20,000.
You ﬁnd that you can get a car loan ranging anywhere from 8 to 11 percent,
and you can have the loan for periods as short as two years and a s long as
eight years. Let’s use our loop constructs to create a table t o show what the
car will actually cost you, including ﬁnancing. In this case, awill represent
the total cost of the car, including the ﬁnancing, and pwill represent the
price tag on the car ($20,000):
☛ ✟
8% 9% 10% 11%
Year 2 $23 , 4 6 9 . 8 1 $23 , 9 4 3 . 8 2 $24 , 4 2 7 . 3 9 $24 , 9 2 0 . 7 1
Year 3 $25 , 4 2 4 . 3 1 $26 , 1 9 8 . 4 2 $26 , 9 9 6 . 0 7 $27 , 8 1 7 . 9 8
Year 4 $27 , 5 4 1 . 5 9 $28 , 6 6 5 . 3 2 $29 , 8 3 4 . 8 6 $31 , 0 5 2 . 0 9
Year 5 $29 , 8 3 5 . 1 9 $31 , 3 6 4 . 5 0 $32 , 9 7 2 . 1 7 $34 , 6 6 2 . 1 9
Year 6 $32 , 3 1 9 . 7 9 $34 , 3 1 7 . 8 5 $36 , 4 3 9 . 3 8 $38 , 6 9 2 . 0 0
Year 7 $35 , 0 1 1 . 3 0 $37 , 5 4 9 . 3 0 $40 , 2 7 1 . 1 9 $43 , 1 9 0 . 3 1
Year 8 $37 , 9 2 6 . 9 6 $41 , 0 8 5 . 0 2 $44 , 5 0 5 . 9 4 $48 , 2 1 1 . 6 0
✡ ✠
Algorithm Design
The key element in this program is the nested for loop that generates the
table. Because the table contains seven rows, the outer loop should iterate Nested loop design
seven times, through the values 2,3,...8:
☛ ✟
for (i n t years = 2 ; years <= 8 ; years ++)
✡ ✠
The inner loop should iterate through each of the interest ra tes, 8 through
11:
☛ ✟
for (i n t years = 2 ; years <= 8 ; years ++) {
for (i n t r a t e = 8 ; r a t e <= 1 1 ; r a t e ++) {
}// f o r r a t e
}// f o r y e a r s
✡ ✠
The ﬁnancing calculation should be placed in the body of the i nner loop
together with a statement to print one cell (not row) of the ta ble. Suppose
the variable we use for ain the formula is carPriceWithLoan , and the
variable we use for the actual price of the car is carPrice . Then our inner
loop body is
☛ ✟
carPriceWithLoan = c a r P r i c e ∗
Math . pow(1 + r a t e /100.0/365.0 , years ∗3 6 5 . 0 ) ;
System . out . p r i n t ( d o l l a r s . format ( carPriceWithLoan ) + ”\t ”) ;
✡ ✠
Note that the rate is divided by both 100.0 (to make it a percen tage) and by
365.0 (for daily compounding), and the year is multiplied by 365.0 before
266 CHAPTER 6 •Control Structures
these values are passed to the Math.pow() method. It is important here
to use 100.0 and not 100 so that the resulting value is a double and not
theint 0.
Implementation
The program must also contain statements to print the row and column
headings. Printing the row headings should be done within th e outer
loop, because it must be done for each row. Printing the colum n head-
ings should be done before the outer loop is entered. Finally , our program Formatting output
should contain code to format the dollar and cents values pro perly. For
this we use the java.text.NumberFormat class that was described in
Chapter 5. The complete program is shown in Figure 6.3.
☛ ✟
import java . t e x t . NumberFormat ; // F o r f o r m a t t i n g $ n n . dd o r n%
public c l a s s CarLoan {
public s t a t i c void main ( S t r i n g args [ ] ) {
double c a r P r i c e = 20000; // C a r ’ s a c t u a l p r i c e
double carPriceWithLoan ; // T o t a l c o s t o f t h e c a r p l u s f i n a n c i n g
// N u m b e r f o r m a t t i n g c o d e
NumberFormat d o l l a r s = NumberFormat . getCurrencyInstanc e ( ) ;
NumberFormat percent = NumberFormat . g e t P e r c e n t I n s t a n c e ( ) ;
percent . setMaximumFractionDigits ( 2 ) ;
// P r i n t t h e t a b l e
for (i n t r a t e = 8 ; r a t e <= 1 1 ; r a t e ++) // P r i n t t h e c o l u m n h e a d i n g
System . out . p r i n t ( ”\t ”+ percent . format ( r a t e / 1 0 0 . 0 ) + ”\t ”) ;
System . out . p r i n t l n ( ) ;
for (i n t years = 2 ; years <= 8 ; years ++) { // F o r y e a r s 2 t h r o u g h 8
System . out . p r i n t ( ”Year ” + years + ”\t ”) ; // P r i n t r o w h e a d i n g
for (i n t r a t e = 8 ; r a t e <= 1 1 ; r a t e ++) { // C a l c a n d p r i n t CD v a l u e
carPriceWithLoan = c a r P r i c e ∗
Math . pow(1 + r a t e / 1 0 0 . 0 / 3 6 5 . 0 , years ∗3 6 5 . 0 ) ;
System . out . p r i n t ( d o l l a r s . format ( carPriceWithLoan ) + ”\t ”) ;
}// f o r r a t e
System . out . p r i n t l n ( ) ; // S t a r t a new r o w
}// f o r y e a r s
}// m a i n ( )
}// C a r L o a n
✡ ✠
Figure 6.3: The CarLoan application.
SECTION 6.5 •Graphics Example: Drawing a Checkerboard 267
6.5 Graphics Example: Drawing a Checkerboard
In this section we will combine some of the graphics methods we have
learned with the nested for-loop structure to draw a checker board with
checkers on it (Fig. 6.4). For this example, we will just conce ntrate on
drawing the checkerboard. We will not worry about providing a full
checkerboard representation, of the sort we would need if we were writing
a program to play the game of checkers. So, our design will not involve in-
stance variables for whose turn it is, how many checkers each player has,
FIGURE 6.4 A checkerboard with
checkers.where the checkers are located on the board, and other elemen ts of the
game’s state. Still, our visible representation of the boar d should be de-
signed so that it will eventually be useful when we do develop a checkers
game in Chapter 8.
Problem Description and Speciﬁcation
The speciﬁcation for this problem is to develop a program tha t will draw a
checkerboard and place upon it the checkers in their appropr iate starting
positions. As with many of our programs, our design will invo lve two
classes, one which deﬁnes the user interface and the other wh ich repre-
sents the computational object. For this problem, the comput ational object
will be deﬁned in the CheckerBoard class. The details of its design are
described in the next section.
Because the purpose of this example is to focus on how we use lo ops
and drawing methods, we will employ a very simple applet inte rface,
whose implementation is given in Figure 6.5. As shown there, the ap-
☛ ✟
import java . awt . ∗;
import java . applet . ∗;
import javax . swing . ∗;
public c l a s s CheckerBoardApplet extends JApplet {
private CheckerBoard theBoard ;
public void i n i t ( ) {
theBoard = new CheckerBoard ( ) ;
}
public void paint ( Graphics g ) {
theBoard . draw ( g ) ;
}// p a i n t ( )
}// C h e c k e r B o a r d A p p l e t
✡ ✠
Figure 6.5: The ChekerBoardApplet class.
plet simply creates a CheckerBoard instance in its init() method, and
then invokes the CheckerBoard ’sdraw method in its paint() method.
The reason we invoke the draw() method in paint() is because we
need to have access to the applet’s Graphics context, which is passed
as an argument to the draw() method. Recall that the init() and then
thepaint() methods are invoked automatically by the browser or ap-
268 CHAPTER 6 •Control Structures
pletviewer when an applet is started. Thus, the action taken by this applet
is simply to draw a visual representation of the checkerboar d.
Class Design: CheckerBoard
FIGURE 6.6 Design of the
CheckerBoard class.Because the applet will invoke its draw() method, this method must
be part of the CheckerBoard ’s interface. Hence, it must be declared
public . The task of drawing a checkerboard involves two distinct su b-
tasks: (1) drawing the board itself, which will involve draw ing a square
with smaller squares of alternating colors; and, (2) drawin g the check-
ers on the checkerboard. A good design for the draw() method would
be simply to invoke helper methods that encapsulate these tw o subtasks.
This is good method design because it results in relatively s mall methods,
each of which performs a very well-deﬁned task. Let’s call th ese methods
drawBoard() anddrawCheckers() , respectively. Their signatures are
shown in Figure 6.6, which summarizes the design of the CheckerBoard
class.
Before gettinginto the details of the drawBoard anddrawCheckers()
methods, we must ﬁrst discuss CheckerBoard ’s several instance vari-
ables. The ﬁrst two variables LEFTXandUPPER Y, give the absolute po-
sition of the upper left corner of the checkerboard on the app let’s drawing
panel. The SQSIDE variable gives the size of the checkerboard’s individ-
ual squares. NROWS andNCOLS give the number of rows and columns
in the checkerboard (typically, 8 by 8). All of these variabl es are integers.
The ﬁnal four variables, SQCOLOR1 ,SQCOLOR2 ,CHECKER COLOR1 , and
CHECKER COLOR2 , specify the colors of the checkerboard and the check-
ers.
Note that the names of all the instance variables are written in upper-
case letters. This is to identify them as symbolic constants —that is, as ﬁ-
nal variables whose values do not chage once they are initial ized. Because
their actual values are not important, we do not show them in t he UML
diagram and we won’t discuss them here. Recall that the advan tage of
deﬁning class constants, rather than sprinkling literal va lues throughout
the program, is that they make it easy to modify the program if we decide
to change the size, location, or color of the checkerboard.
Method Design
Returning now to the design of CheckerBoard ’s instance methods, the
complete deﬁnition of the CheckerBoard class is given in Figure 6.7.
Note how simple its draw() method is. As we noted earlier, in order
to using Java’s drawing commands, it is necessary to have a re ference to a
Graphics object. This is passed to the draw() method when the draw()
method is invoked in the applet. Because the draw() method delegates
the details of the drawing algorithm to its helper methods, drawBoard()
anddrawCheckers() , it has to pass them a reference to the Graphics
object.
ThedrawBoard() method uses a nested for loop to draw an 8×8
array of rectangles of alternating colors. The loop variabl es,row andcol,
both range from 0 to 7. The expression used to determine alter nating
colors tests whether the sum of the row and column subscripts is even:
SECTION 6.5 •Graphics Example: Drawing a Checkerboard 269
☛ ✟
import java . awt . ∗;
public c l a s s CheckerBoard {
// D e f a u l t v a l u e s f o r a s t a n d a r d c h e c k e r b o a r d
private f i n a l i n t LEFT X = 1 0 ; // P o s i t i o n o f l e f t
private f i n a l i n t UPPER Y = 1 0 ; // u p p e r c o r n e r
private f i n a l i n t SQSIDE = 4 0 ; // S i z e o f e a c h s q u a r e
private f i n a l i n t NROWS = 8 ; // C h e c k e r b o a r d r o w s
private f i n a l i n t NCOLS = 8 ; // C h e c k e r b o a r d c o l u m n s
private f i n a l Color SQ COLOR1 = Color . lightGray ; // C o l o r s
private f i n a l Color SQ COLOR2 = Color . gray ; // o f s q u a r e s
private f i n a l Color CHECKER COLOR1 = Color . white ; // a n d
private f i n a l Color CHECKER COLOR2 = Color . black ; // c h e c k e r s
private void drawBoard ( Graphics g ) {
for(i n t row = 0 ; row <NROWS; row++)
// F o r e a c h r o w
for(i n t c o l = 0 ; c o l <NCOLS ; c o l ++) {// F o r e a c h s q u a r e
i f( ( row + c o l ) % 2 == 0)
// A l t e r n a t e c o l o r s
g . setColor (SQ COLOR1 ) ;
// L i g h t
else
g . setColor (SQ COLOR2 ) ;
// o r d a r k
g . f i l l R e c t ( LEFT X+ c o l∗SQSIDE ,
UPPER Y+row∗SQSIDE , SQ SIDE , SQ SIDE ) ;
}// f o r
}// d r a w B o a r d ( )
private void drawCheckers ( Graphics g ) { // P l a c e c h e c k e r s
for(i n t row = 0 ; row <NROWS; row++) // F o r e a c h r o w
for(i n t c o l = 0 ; c o l <NCOLS ; c o l ++) // F o r e a c h s q u a r e
i f( ( row + c o l )%2 == 1) {// One p l a y e r h a s t o p 3 r o w s
i f( row<3){
g . setColor (CHECKER COLOR1 ) ;
g . f i l l O v a l ( LEFT X+ c o l∗SQSIDE ,
UPPER Y+row∗SQSIDE , SQ SIDE−2,SQ SIDE−2);
}// i f
i f( row>= N ROWS−3){// O t h e r h a s b o t t o m 3 r o w s
g . setColor (CHECKER COLOR2 ) ;
g . f i l l O v a l ( LEFT X+ c o l∗SQSIDE ,
UPPER Y+row∗SQSIDE , SQ SIDE−2,SQ SIDE−2);
}// i f
}// i f
}// d r a w C h e c k e r s ( )
public void draw ( Graphics g ) {// Draw b o a r d a n d c h e c k e r s
drawBoard ( g ) ;
drawCheckers ( g ) ;
}// d r a w ( )
}// C h e c k e r B o a r d
✡ ✠
Figure 6.7: The CheckerBoard class.
270 CHAPTER 6 •Control Structures
((row+col)%2==0). If their sum is even, we use one color; if odd, we
use the other color.
As the table in the margin shows for a 4×4board, the sum of a board’s
row and column subscripts alternates between even and odd va lues.
Thus, in row 2 column 3, the sum of the subscripts is 5. | 0 1 2 3
-----------------
0 | 0 1 2 3
1 | 1 2 3 4
2 | 2 3 4 5
3 | 3 4 5 6To switch from one color to the other, we use the Graphics
setColor() method to alternate between the two colors designated for
the checkerboard, SQCOLOR1 andSQCOLOR2 . We then use the following
method call to draw the colored squares:
☛ ✟
g . f i l l R e c t ( LEFT X+ c o l∗SQSIDE , UPPER Y+row∗SQSIDE ,
SQSIDE , SQ SIDE ) ;
✡ ✠
Note how we use the loop variables, row col , together with the constants
specifying the top left corner of the board ( UPPER YandLEFTX) and the
size of the squares ( SQSIDE ) to calculate the location and size of each
square. The calculation here is illustrated in Figure 6.8. T he ﬁrst two pa-
rameters in fillRect(left,top,width,height) specify the coordi-
nates for the rectangle’s top-left corner. These are calcul ated as a func-
tion of the rectangle’s row and column position within the ch eckerboard
and the rectangle’s width and height, which are equal for the squares of a
checkerboard.
Figure 6.8: Calculating the loca-
tions of the checkerboard squares.
ThedrawCheckers() method also uses a nested for loop to trace
through the checkerboard’s rows and columns. In this case, ho wever, we
draw checkers on just the dark-colored squares—that is, those that sat-
isfy the expression (row+col)%2==1)—on the ﬁrst three rows of each
SECTION 6.6 •Conditional Loops 271
player’s side of the board. So, each player’s checkers initi ally are located
in the ﬁrst three rows and last three rows of the checker board :
☛ ✟
i f( ( row + c o l )%2 == 1) {// One p l a y e r h a s t o p 3 r o w s
i f( row<3){
g . setColor (CHECKER COLOR1 ) ;
g . f i l l O v a l ( LEFT X+ c o l∗SQSIDE ,
UPPER Y+row∗SQSIDE , SQ SIDE−2,SQ SIDE−2);
}// i f
i f( row>= N ROWS−3){// O t h e r h a s b o t t o m 3 r o w s
g . setColor (CHECKER COLOR2 ) ;
g . f i l l O v a l ( LEFT X+ c o l∗SQSIDE ,
UPPER Y+row∗SQSIDE , SQ SIDE−2,SQ SIDE−2);
}// i f
}// i f
✡ ✠
Because the checkers are circles, we use the fillOval() method to draw
them. Note that the parameters for fillOval(left, top, width,
height) are identical to those for fillRect() . The parameters spec-
ify an enclosing rectangle in which the oval is inscribed. In t his case, of
course, the enclosing rectangle is a square, which causes fillOval() to
draw a circle.
Our design of the CheckerBoard class illustrates an important princi-
ple of method design. First, rather than placing all of the co mmands for
drawing the checkerboard and the checkers into one method, w e broke
up this larger task into distinct subtasks. This resulted in small methods,
each of which has a well deﬁned purpose.
JAVA EFFECTIVE DESIGN Method Decomposition. Methods
should be designed to have a clear focus. If you ﬁnd a method
becoming too long, you should break its algorithm into subta sks and
deﬁne a separate method for each subtask.
6.6 Conditional Loops
Unlike the problems in the previous sections, not all loops c an be coded as
counting loops. Here’s a problem that can’t be solved by a coun ting loop.
Mathematicians, especially number theorists, have found t hat certain
operations on numbers lead to interesting sequences. For ex ample, the
3N+1 problem is a conjecture in number theory, which says that if Nis any
positive integer, then the sequence generated by the follow ing rules will
always terminate at 1.
☛ ✟
Case Operation
−−−− −−−−−−−−−
N i s odd N = 3 ∗N + 1
N i s even N = N / 2
✡ ✠
In other words, start with any positive integer, N. IfNis odd, multiply
it by 3 and add 1. If Nis even, divide it by 2. In either case, assign the
272 CHAPTER 6 •Control Structures
result back to N. The conjecture states that Nwill eventually equal 1. For
example, if Nis initially 26, then the sequence generated is 26, 13, 40, 20 ,
10, 5, 16, 8, 4, 2, 1.
The 3 N+1 problem is an example of a noncounting loop. Because for
any given Nwe don’t know how long the 3 N+1 sequence will be, we Sentinel bound
need a loop that terminates when the loop variable reaches a c ertain value,
called a sentinel value—when Nequals 1. This is an example of a loop that
is terminated by a sentinel bound . With the exception of inﬁnite loops, all
loops are bounded by some condition, which is why they are som etimes
referred to as conditional loop structures. The count and sentinel bounds
are just special cases of the conditional loop structure.
6.6.1 The While Structure, Revisited
Consider the following pseudocode algorithm for the 3 N+1 problem:
☛ ✟
Algorithm for computing the 3N+1 sequence
While N i s not equal to 1 , do:{
P r i n t N.
I f N i s even , divide i t by 2 .
I f N i s odd , multiply N by 3 and add 1 .
}
P r i n t N
✡ ✠
In this structure, the body of the loop prints Nand then updates N’s value,
using the 3 N+1 rules. Suppose Nequals 5 when this code segment begins.
It will print the following sequence: 5, 16, 8, 4, 2, 1. Note tha t the loop
body is entered as long as Nis not equal to 1. So the loop entry condition
in this case is N != 1 . Conversely, the loop will terminate when Nequals
1. Also note that in this code segment the loop bound is tested before the
body of the loop is executed.
We can implement this algorithm using Java’s while statement , whose
ﬂowchart is shown in Figure 6.2:
☛ ✟
while (N != 1) { // W h i l e N n o t e q u a l t o 1
System . out . p r i n t (N + ” ” ) ;// P r i n t N
i f(N % 2 == 0) // I f N i s e v e n
N = N / 2 ; // d i v i d e i t b y 2
else // I f N i s o d d
N = 3 ∗N + 1 ; // m u l t i p l y b y 3 a n d a d d 1
}
System . out . p r i n t l n (N) ; // P r i n t N
✡ ✠
Recall that unlike the for statement, the while statement does not con-
tain syntax for the initializer and the updater. These must b e coded sepa-
rately. As we pointed out in Chapter 3, the while structure (as opposed to
SECTION 6.6 •Conditional Loops 273
thewhile statement) is a segment of code built by the programmer that
satisﬁes the following design principle:
JAVA EFFECTIVE DESIGN Loop Structure. A properly designed
loop structure must include an initializer , aloop-entry condition , and an
updater . The updater should guarantee that the loop-entry conditio n
will eventually become false, thereby causing the loop to te rminate.
Thewhile structure has the following form:
☛ ✟
I n i t i a l i z e r S t a t e m e n t s ; // I n i t i a l i z e r
while ( loop entry condition ) {// B o u n d t e s t
Statements ; // L o o p b o d y
UpdaterStatements ; // U p d a t e r
}
✡ ✠
As its form suggests, the while structure is designed so that on some
conditions the loop body will never be executed. Because it t ests for the
loop bound before the loop body, it is possible that the loop body is never
executed. We might say that it is designed to perform 0 or more iterations.
For example, going back to the 3 N+1 problem, what if Nequals 1 ini-
tially? In that case, the loop body will be skipped, because th e loop entry
condition is false to begin with. No iterations will be perfo rmed, and the
algorithm will simply print the value 1.
Thewhile structure would be an appropriate control structure for the
following type of problem:
☛ ✟
write the problems on the assignment sheet // I n i t i a l i z e r
while there are problems on the sheet // B o u n d t e s t
doa problem // L o o p b o d y
c r o s s i t o f f the assignment sheet // U p d a t e r
✡ ✠
It is possible that the assignment sheet contains no homework problems
to begin with. In that case, there’s no work for the body of the l oop to do
and it should be skipped.
SELF-STUDY EXERCISES
EXERCISE 6.6 Identify the syntax error in the following while struc-
tures:
a.☛ ✟
i n t k = 5 ;
while ( k<100){
System . out . p r i n t l n ( k ) ;
k++
}
✡ ✠
274 CHAPTER 6 •Control Structures
b.☛ ✟
i n t k = 0 ;
while ( k<12 ; ){
System . out . p r i n t l n ( k ) ;
k++;
}
✡ ✠
EXERCISE 6.7 Determine the output and/or identify the error in each
of the following while structures:
a.☛ ✟
i n t k = 0 ;
while ( k<100)
System . out . p r i n t l n ( k ) ;
✡ ✠
b.☛ ✟
while ( k<100){
System . out . p r i n t l n ( k ) ;
k++;
}
✡ ✠
EXERCISE 6.8 Your younger sister is now learning how to count by
sixes. Write a while loop that prints the following sequence of numbers:
0, 6, 12, 18, 24, 30, 36.
EXERCISE 6.9 Here’s another number theory problem. Start with any
positive integer, N. IfNis even, divide it by 2. If Nis odd, subtract 1 and
then divide it by 2. This will generate a sequence that is guar anteed to
terminate at 0. For example, if Nis initially 15, then you get the sequence:
15, 7, 3, 1, 0. Write a method that implements this sequence us ing a while
statement.
6.6.2 The Do-While Structure
Here’s another problem that can’t be solved with a counting lo op. Your
father has been fretting about the bare spots on the front law n and is con- Problem description
sidering hiring the ChemSure Lawn Service to fertilize. Howe ver, your
scientiﬁcally minded younger sister wants to reassure him t hat at the rate
the grass is dying, there will be enough to last through the su mmer. Using
techniques she learned in biology, your sister estimates th at the grass is
dying at the rate of 2 percent per day. How many weeks will it tak e for
half the lawn to disappear?
One way to solve this problem would be to keep subtracting 2 pe rcent
from the current amount of grass until the amount dipped belo w 50 per- Algorithm design
SECTION 6.6 •Conditional Loops 275
cent, all the while counting the number of iterations requir ed. Consider
the following pseudocode algorithm:
☛ ✟
Algorithm for c a l c u l a t i n g grass l o s s
I n i t i a l i z e amtGrass to 1 0 0 . 0
I n i t i a l i z e nDays to 0
Repeat the following statements
amtGrass −= amtGrass ∗0 . 0 2 ;
++nDays ;
Aslong as amtGrass >5 0 . 0
P r i n t nDays / 7
✡ ✠
We begin by initializing amtGrass to 100.0, representing 100 percent.
And we initialize our counter, nDays to 0. Then we repeatedly subtract 2
percent of the amount and increment the counter until the amo unt drops
below 50 percent. In other words, in this case, we repeat the lo op body
as long as the amount of grass remains above 50 percent of the o riginal.
When the loop ﬁnishes, we report the number of weeks it took by d ividing
the number of days by 7.
The loop bound in this case is known as a limit bound . The loop will Limit bound
terminate when a certain limit has been reached—in this case, when the
amount of grass dips below 50 percent of the original amount. Note that
in this case the loop bound is tested after the loop body. This is appropri-
ate for this problem, because we know in advance that the loop will iter-
ate at least once. We can implement this algorithm using Java ’sdo-while
statement :
☛ ✟
public i n t losingGrass ( double perCentGrass ) {
double amtGrass = 1 0 0 . 0 ; // I n i t i a l i z e a m o u n t g r a s s
i n t nDays = 0 ; // I n i t i a l i z e d a y c o u n t e r
do{ // R e p e a t
amtGrass −= amtGrass ∗LOSSRATE ; // U p d a t e a m o u n t
++nDays ; // I n c r e m e n t t h e c o u n t e r
}while ( amtGrass >perCentGrass ) ;
// As l o n g a s e n o u g h g r a s s r e m a i n s
return nDays / 7 ; // R e t u r n t h e n u m b e r o f w e e k s
}// l o s i n g G r a s s ( )
✡ ✠
The do-while statement is a loop statement in which the loop entry con-
dition occurs after the loop body. It has the following genera l form:
JAVA LANGUAGE RULE Do-while Statement. The do-while
statement has the following syntax:
do
loopbody
while(loopentrycondition );
Note, again, that unlike the for statement, the do-while statement does
not contain syntax for the initializer and the updater. Thes e must be coded
separately.
276 CHAPTER 6 •Control Structures
Figure 6.9: Flowchart of the
do-while statement and
do-while structure.Do-While Statement Do-While Structure
Initializer1
Initializer2
Statement
Updater
True
FalseLoop
entry
conditionStatement
True
FalseCondition
To further highlight the difference between a loop statemen t and a loop
structure, the do-while structure takes the following form:
☛ ✟
I n i t i a l i z e r S t a t e m e n t s 1 ; // I n i t i a l i z e r
do{ // B e g i n n i n g o f l o o p b o d y
I n i t i a l i z e r S t a t e m e n t s 2 ; // A n o t h e r i n i t i a l i z e r
Statements ; // L o o p b o d y
UpdaterStatements // U p d a t e r
}while ( loop entry condition ) ; // B o u n d t e s t
✡ ✠
Note that initializer statements may be placed before the lo op body, at the
beginning of the loop body, or in both places, depending on th e particular
problem. Like the other loop structures, updater statement s occur within
the body of the loop. A ﬂowchart of the do-while structure is shown in
Figure 6.9.
Thedo-while structure would be an appropriate control structure for
the following type of problem:
☛ ✟
do
d i a l the desired telephone number // I n i t i a l i z e r
i fyou get a busy s i g n a l
hang up // U p d a t e r
while there i s a busy s i g n a l // B o u n d t e s t
✡ ✠
SECTION 6.6 •Conditional Loops 277
In this case, you want to perform the actions in the body of the l oop at
least once and possibly more than once (if you continue to rec eive a busy
signal).
JAVA EFFECTIVE DESIGN Do-While Loops. Thedo-while loop is
designed for solving problems in which at least one iteratio n must
occur.
JAVA EFFECTIVE DESIGN While versus Do-While Structures. For
problems where a noncounting loop is required, the while loop
structure is more general and, therefore, preferable to the do-while
structure. Use do-while only when at least one iteration must occur.
SELF-STUDY EXERCISES
EXERCISE 6.10 Identify the syntax error in the following do-while
structures:
a.☛ ✟
i n t k = 0 ;
do while ( k<100)
{ System . out . p r i n t l n ( k ) ;
k++
}
✡ ✠
b.☛ ✟
i n t k = 0 ;
do{
System . out . p r i n t l n ( k ) ;
k++;
}while ( k<12)
✡ ✠
EXERCISE 6.11 Your sister has moved on to counting by sevens. Write
ado-while loop that prints the following sequence of numbers: 1, 8, 15,
22, 29, 36, 43.
EXERCISE 6.12 As the owner of Pizza Heaven, every night at the close
of business you quickly enter the price of every pizza ordere d that day.
You take the data from the servers’ receipts. Pizzas cost $8, $10, or (the
Heavenly Special) $15. You enter the data without dollar sign s, and use
99 to indicate you’re ﬁnished for the day. Write a Java method to input
and validate a single pizza data item. If an incorrect price is entered, the
program should print an error message and prompt for correct ed input.
Correct input is used to compute a daily total.
EXERCISE 6.13 Because the pizza prices in the previous exercise are
ﬁxed, change the method so you can save time on keyboarding. In stead of
entering the price, you’ll enter codes of 1, 2, or 3 (correspo nding to the $8,
$10, and $15 pizzas), and 0 to indicate that you’re ﬁnished. V alidate that
the data value entered is correct and then convert it to the co rresponding
price before returning it.
278 CHAPTER 6 •Control Structures
6.7 Example: Computing Averages
Suppose you want to compute the average of your exam grades in a
course. Grades, represented as real numbers, will be input f rom the key- Algorithm design: what kind of loop?
board using our KeyboardReader class. To signify the end of the list,
we will use a sentinel value—9999 or −1or some other value that won’t
be confused with a legitimate grade. Because we do not know ex actly
how many grades will be entered, we will use a noncounting loo p in this
algorithm. Because there could be no grades to average, we wi ll use a
while structure so it is possible to skip the loop entirely in the ca se that
there are no grades to average.
The algorithm should add each grade to a running total, keepi ng track
of the number of grades entered. Thus, this algorithm requir es two vari- Algorithm design
ables: one to keep track of the running total and the other to k eep track
of the count. Both should be initialized to 0. After the last g rade has been
entered, the total should be divided by the count to give the a verage. In
pseudocode, the algorithm for this problem is as follows:
☛ ✟
i n i t i a l i z e runningTotal to 0 // I n i t i a l i z e
i n i t i a l i z e count to 0
prompt and read the f i r s t grade // P r i m i n g r e a d
while the grade entered i s not 9999 {// S e n t i n e l t e s t
add i t to the runningTotal
add 1 to the count
prompt and read the next grade // U p d a t e
}
i f( count >0) // G u a r d a g a i n s t d i v i d e b y 0
divide runningTotal by count
output the average as the r e s u l t
✡ ✠
Note that in this problem our loop variable, grade , is read before the Priming read
loop test is made. This is known as a priming read . It is necessary in this
case, because the loop test depends on the value that is read. Within the
loop’s body, the updater reads the next value for grade. This is a standard
convention for coding while structures that involve input, as this prob-
lem does. Note also that we must make sure that count is not 0 before
we attempt to compute the average because dividing by 0 would cause a
divide-by-zero error.
Translating the pseudocode algorithm into Java raises seve ral issues.
Suppose we store each grade that is input in a double variable named
grade . The loop will terminate when grade equals 9999, so its entry con-
dition will be (grade != 9999) . Because this condition uses grade , it
is crucial that the grade variable be initialized before the bound test is
made. This requires a priming read. By reading the ﬁrst value ofgrade
before the loop entry condition is tested, ensures that the l oop will be
skipped if the user happens to enter the sentinel (9999) on th e very ﬁrst
prompt. In addition to reading the ﬁrst exam score, we must ini tialize
the variables used for the running total and the counter. Thu s, for our
initialization step, we get the following code: Initialization step
SECTION 6.7 •Example: Computing Averages 279
☛ ✟
double runningTotal = 0 ;
i n t count = 0 ;
reader . prompt ( ” Input a grade ( e . g . , 8 5 . 3 ) ” +
” or 9999 to i n d i c a t e the end of the l i s t >> ”) ;
double grade =
reader . getKeyboardDouble ( ) ; // P r i m i n g i n p u t
✡ ✠
Within the body of the loop we must add the grade to the running total
and increment the counter. Since these variables are not tes ted in the loop
entry condition, they will not affect the loop control. Our l oop updater
in this case must read the next grade. Placing the updater sta tement at
the end of the loop body will ensure that the loop terminates i mmediately Updater step
after the user enters the sentinel value:
☛ ✟
while ( grade != 9999) { // L o o p t e s t : s e n t i n e l
runningTotal += grade ;
count ++;
reader . prompt ( ” Input a grade ( e . g . , 8 5 . 3 ) ” +
” or 9999 to i n d i c a t e the end of the l i s t >> ”) ;
grade = reader . getKeyboardDouble ( ) ; // U p d a t e : i n p u t
}// w h i l e
✡ ✠
You can see that it is somewhat redundant to repeat the same st atements
needed to do the initializating and the updating of the grade variable. A
better design would be to encapsulate these into a method and then call Modularity
the method both before and within the loop. The method should take care
of prompting the user, reading the input, converting it to double , and
returning the input value. The method doesn’t require a para meter:
☛ ✟
private double promptAndRead ( ) {
reader . prompt ( ” Input a grade ( e . g . , 8 5 . 3 ) ” +
” or 9999 to i n d i c a t e the end of the l i s t >> ”) ;
double grade = reader . getKeyboardDouble ( ) ;
// C o n f i r m i n p u t
System . out . p r i n t l n ( ”You input ” + grade + ”\n”) ;
return grade ;
}
✡ ✠
Note that we have declared this as a private method. It will be used
to help us perform our task but won’t be available to other obje cts. Such
private methods are frequently called helper methods .
This is a much more modular design. In addition to cutting down on
redundancy in our code, it makes the program easier to mainta in. For
example, there is only one statement to change if we decide to change the
280 CHAPTER 6 •Control Structures
prompt message. It also makes the program easier to debug. Inpu t errors
are now localized to the promptAndRead() method.
JAVA EFFECTIVE DESIGN Modularity. Encapsulating code in a
method is a good way to avoid redundancy in a program.
JAVA DEBUGGING TIP Localization. Encapsulating code in a
method removes the need to have the same code at several locat ions in
a program. By localizing the code in this way, you make it easi er to
modify and debug.
Another advantage of encapsulating the input task in a separ ate method
is that it simpliﬁes the task of calculating the average. Thi s task should
also be organized into a separate method:
☛ ✟
public double inputAndAverageGrades ( ) {
double runningTotal = 0 ;
i n t count = 0 ;
double grade = promptAndRead ( ) ; // P r i m i n g i n i t i a l i z e r
while ( grade != 9999) { // L o o p t e s t : s e n t i n e l
runningTotal += grade ;
count ++;
grade = promptAndRead ( ) ; // U p d a t e : g e t n e x t g r a d e
}// w h i l e
i f( count >0) // G u a r d a g a i n s t d i v i d e −by−z e r o
return runningTotal / count ; // R e t u r n t h e a v e r a g e
else
return 0 ; // S p e c i a l ( e r r o r ) r e t u r n v a l u e
}
✡ ✠
Note that we have declared this as a public method. This will be the
method you call to calculate your course average.
Because we have decomposed the problem into its subtasks, ea ch sub-
task is short and simple, making it easier to read and underst and. As Method decomposition
we saw in the checkerboard example, the use of small, clearly -focused
methods is a desireable aspect of designing a program.
The complete Average.java application is shown in Figure 6.10. Its
overall design is similar to application programs we design ed in previous
chapters. The only instance variable it uses is the KeyboardReader vari-
able. The other variables are declared locally, within the m ethods. In this
case, declaring them locally makes the algorithms easier to read.
One ﬁnal point about this program is to note the care taken in t he design
of the user interface to explain the program to the user, to pr ompt the user
SECTION 6.7 •Example: Computing Averages 281
☛ ✟
import java . io . ∗;
public c l a s s Average { // C o n s o l e I /O
private KeyboardReader reader = new KeyboardReader ( ) ;
private double promptAndRead ( ) {
reader . prompt ( ” Input a grade ( e . g . , 8 5 . 3 ) ” +
” or 9999 to i n d i c a t e the end of the l i s t >> ”) ;
double grade = reader . getKeyboardDouble ( ) ;
System . out . p r i n t l n ( ”You input ” + grade + ”\n”) ;// C o n f i r m i n p u t
return grade ;
}
public double inputAndAverageGrades ( ) {
double runningTotal = 0 ;
i n t count = 0 ;
double grade = promptAndRead ( ) ; // I n i t i a l i z e : p r i m i n g i n p u t
while ( grade != 9999) { // L o o p t e s t : s e n t i n e l
runningTotal += grade ;
count ++;
grade = promptAndRead ( ) ; // U p d a t e : g e t n e x t g r a d e
}// w h i l e
i f( count >0) // G u a r d a g a i n s t d i v i d e −by−z e r o
return runningTotal / count ; // R e t u r n t h e a v e r a g e
else
return 0 ; // S p e c i a l ( e r r o r ) r e t u r n v a l u e
}
public s t a t i c void main ( S t r i n g argv [ ] ) {
System . out . p r i n t l n ( ” This program c a l c u l a t e s average grade . ” ) ;
Average avg = new Average ( ) ;
double average = avg . inputAndAverageGrades ( ) ;
i f( average == 0) // E r r o r c h e c k
System . out . p r i n t l n ( ”You didn ’ t enter any grades . ” ) ;
else
System . out . p r i n t l n ( ”Your average i s ” + average ) ;
}// m a i n ( )
}// A v e r a g e
✡ ✠
Figure 6.10: A program to compute average grade using a while struc-
ture.
before a value is input, and to conﬁrm the user’s input after t he program
has read it.
JAVA EFFECTIVE DESIGN User Interface. Whenever you ask a
user for input, the user should know why you are asking and what you
are asking for. Prompts should be used for this purpose. It is a lso a
good idea to conﬁrm that the program has received the correct input.
282 CHAPTER 6 •Control Structures
6.8 Example: Data Validation
One frequent programming task is data validation . This task can take dif-
ferent forms depending on the nature of the program. One use f or data
validation occurs when accepting input from the user.
In the program in the preceding section, suppose the user type s−10by
mistake when asked to input an exam grade. Obviously this is n ot a valid
exam grade and should not be added to the running total. How sho uld a
program handle this task?
Because it is possible that the user may take one or more attem pts to Algorithm design
correct an input problem, we should use a do-while structure for this
problem. The program should ﬁrst input a number from the user . The
number should then be checked for validity. If it is valid, the loop should
exit and the program should continue computing the before ge tting the
input average grade. If it is not valid, the program should pri nt an error
message and input the number again. A ﬂowchart for this algori thm is
shown in Figure 6.11.
For example, suppose only numbers between 0 and 100 are consi dered
valid. The data validation algorithm would be as follows:
☛ ✟
do
Get the next grade // I n i t i a l i z e : p r i m i n g i n p u t
i fthe grade <0 or grade >100 and grade != 9999
p r i n t an e r r o r message // E r r o r c a s e
// S e n t i n e l t e s t
while the grade <0 or grade >100 and grade != 9999
✡ ✠
Note here that initialization and updating of the loop varia ble are per-User inputs
data
Process
dataOutput error
message
No
YesIs it
correct?
FIGURE 6.11 Do-while is a good
structure for the data validation
algorithm.formed by the same statement. This is acceptable because we m ust up-
date the value of grade on each iteration before checking its validity. Note
also that for this problem the loop-entry condition is also u sed in the if
statement to check for an error. This allows us to print an app ropriate
error message if the user makes an input error.
Let’s incorporate this data validation algorithm into the promptAnd-
Read() method that we designed in the previous section (Fig. 6.10). The
revised method will handle and validate all input and return a number
between 0 and 100 to the calling method. To reﬂect its expanded pur-
pose, we will change the method’s name to getAndValidateGrade() ,
and incorporate it into a revised application, which we name Validate
(Fig. 6.12).
6.9 Principles of Loop Design
Before moving on, it will be useful to summarize the main prin ciples
involved in correctly constructing a loop.
•Acounting loop can be used whenever you know in advance exactly
how many iterations are needed. Java’s for statement is an appropriate
structure for coding a counting loop.
SECTION 6.9 •Principles of Loop Design 283
☛ ✟
import java . io . ∗;
public c l a s s Validate { // C o n s o l e i n p u t
private KeyboardReader reader = new KeyboardReader ( ) ;
private double getAndValidateGrade ( ) {
double grade = 0 ;
do{
reader . prompt ( ” Input a grade ( e . g . , 8 5 . 3 ) ” +
” or 9999 to i n d i c a t e the end of the l i s t >> ”) ;
grade = reader . getKeyboardDouble ( ) ;
i f( ( grade != 9999) && ( ( grade <0)||( grade >1 0 0 ) ) ) // I f e r r o r
System . out . p r i n t l n ( ” Error : grade must be between 0 and 100 \n”) ;
else
System . out . p r i n t l n ( ”You input ” + grade + ”\n”) ;
// C o n f i r m i n p u t
}while ( ( grade != 9999) && ( ( grade <0)||( grade >1 0 0 ) ) ) ;
return grade ;
}
public double inputAndAverageGrades ( ) {
double runningTotal = 0 ;
i n t count = 0 ;
double grade = getAndValidateGrade ( ) ; // I n i t i a l i z e : p r i m i n g i n p u t
while ( grade != 9999) { // L o o p t e s t : s e n t i n e l
runningTotal += grade ;
count ++;
grade = getAndValidateGrade ( ) ; // U p d a t e : g e t n e x t g r a d e
}// w h i l e
i f( count >0) // G u a r d a g a i n s t d i v i d e −by−z e r o
return runningTotal / count ; // R e t u r n t h e a v e r a g e
else
return 0 ; // S p e c i a l ( e r r o r ) r e t u r n v a l u e
}
public s t a t i c void main ( S t r i n g argv [ ] ) {
System . out . p r i n t l n ( ” This program c a l c u l a t e s average grade . ” ) ; // E x p l a i n
Average avg = new Average ( ) ;
double average = avg . inputAndAverageGrades ( ) ;
i f( average == 0) // E r r o r c h e c k
System . out . p r i n t l n ( ”You didn ’ t enter any grades . ” ) ;
else
System . out . p r i n t l n ( ”Your average i s ” + average ) ;
}// m a i n ( )
}// V a l i d a t e
✡ ✠
Figure 6.12: A program to compute average grade using a while struc-
ture. This version validates the user’s input.
284 CHAPTER 6 •Control Structures
•Awhile structure should be used when the problem suggests that the
loop body may be skipped entirely. Java’s while statement is specially
designed for the while structure.
•Ado-while structure should be used only when a loop requires one or
more iterations. Java’s do-while statement is specially designed for the
do-while structure.
•The loop variable is used to specify the loop-entry condition . It must be
initialized to an appropriate initial value, and it must be u pdated on
each iteration of the loop.
•A loop’s bound may be a count , asentinel , or, more generally, a conditional
bound . It must be correctly speciﬁed in the loop-entry expression, and
progress toward the bound must be made in the updater .
•Aninﬁnite loop may result if the initializer, loop-entry expression, or
updater expression is not correctly speciﬁed.
The loop types are also summarized in Table 6.1.
TABLE 6.1 A summary of the design decisions required when coding a loop
Use If Java Statement
Counting loop Number of iterations known in advance for
While structure Number of iterations not known while
Loop may not be entered at all
Do-while structure Number of iterations not known do-while
Loop must be entered at least once
SELF-STUDY EXERCISE
EXERCISE 6.14 For each of the following problems, decide whether
a counting loop structure, a while structure, or a do-while structure
should be used, and write a pseudocode algorithm.
•Print the names of all visitors to your Web site.
•Validate that a number input by the user is positive.
•Change all the backslashes ( \) in a Windows Web page address to the
slashes (/) used in a Unix Web page address.
•Find the car with the best miles-per-gallon ratio among the c ars in
theConsumer Reports database.
SECTION 6.10 •Theswitch Multiway Selection Structure 285
6.10 The switch Multiway Selection Structure
Another selection structure to add to our repertoire is the switch/break
structure . It is meant to provide a shorthand way of coding the following
type of multiway selection structure:
☛ ✟
i f( i n t e g r a l V a r == i n t e g r a l V a l u e 1 )
// s o m e s t a t e m e n t s
else i f ( i n t e g r a l V a r == i n t e g r a l V a l u e 2 )
// s o m e s t a t e m e n t s
else i f ( i n t e g r a l V a r == i n t e g r a l V a l u e 3 )
// s o m e s t a t e m e n t s
else // s o m e s t a t e m e n t s
✡ ✠
Note that each of the conditions in this case involves the equ ality of an
integral variable and an integral value. This type of struct ure occurs so
frequently in programs that most languages contain stateme nts specially
designed to handle it. In Java, we use a combination of the switch and
break statements to implement multiway selection.
Theswitch is designed to select one of several actions depending on
the value of some integral expression:
☛ ✟
switch ( i n t e g r a l E x p r e s s i o n )
{case i n t e g r a l V a l u e 1 :
// s o m e s t a t e m e n t s
case i n t e g r a l V a l u e 2 :
// s o m e s t a t e m e n t s
case i n t e g r a l V a l u e 3 :
// s o m e s t a t e m e n t s
default :
some statements
}
✡ ✠
The integralExpression must evaluate to a primitive integral value of type
byte ,short ,int,char , orboolean . It may not be a long ,float ,Integral expression
double , or a class type. The integralValues must be literals or final vari-
ables. They serve as labels in the one or more case clauses tha t make up
theswitch statement body. The default clause is optional, but it is a
good idea to include it.
Aswitch statement is executed according to the following rules:
Rule 1. The integralExpression is evaluated.
Rule 2. Control passes to the statements following the case label whose
value equals the integralExpression or, if no cases apply, to the default
clause.
Rule 3. Beginning at the selected label or at the default, all of the state-
ments up to the end of the switch are executed.
286 CHAPTER 6 •Control Structures
Consider the following example:
☛ ✟
i n t m = 2 ;
switch (m)
{case 1 :
System . out . p r i n t ( ” m = 1” ) ;
case 2 :
System . out . p r i n t ( ” m = 2” ) ;
case 3 :
System . out . p r i n t ( ” m = 3” ) ;
default :
System . out . p r i n t ( ” d e f a u l t case ” ) ;
}
✡ ✠
In this case, because mequals 2, the following output would be produced:
☛ ✟
m = 2 m = 3 default case
✡ ✠
Obviously, this output does not match the following if-else multiway
selection structure, which would output, simply, m = 2 :
☛ ✟
i n t m = 2 ;
i f(m == 1)
System . out . p r i n t ( ” m = 1” ) ;
else i f (m == 2)
System . out . p r i n t ( ” m = 2” ) ;
else i f (m == 3)
System . out . p r i n t ( ” m = 3” ) ;
else
System . out . p r i n t ( ” d e f a u l t case ” ) ;
✡ ✠
The reason for this disparity is that the switch executes allstatements
following the label that matches the value of the integralExpression (see
again Rule 3 on the previous page).
In order to use the switch as a multiway selection, you must for ce it to
break out of the case clause after executing that clause’s stateme nts:
☛ ✟
i n t m = 2 ;
switch (m)
{case 1 :
System . out . p r i n t ( ” m = 1” ) ;
break ;
case 2 :
System . out . p r i n t ( ” m = 2” ) ;
break ;
case 3 :
System . out . p r i n t ( ” m = 3” ) ;
break ;
default :
System . out . p r i n t ( ” d e f a u l t case ” ) ;
}
✡ ✠
SECTION 6.10 •Theswitch Multiway Selection Structure 287
In this example, the break statement causes control to pass to the end
of theswitch , with the effect being that one and only one case will be
executed within the switch . Thus, the output of this code segment will
be simply m = 2 , matching exactly the behavior of the multiway if-else
selection structure (Fig. 6.13).
case1 case2
statement1 statement2
breakcase n
statement n
breakF F F
T T T
breakFigure 6.13: Flowchart of the mul-
tiway switch structure. Note that
because of the break statement,
one and only one case is executed.
JAVA PROGRAMMING TIP Multiway Selection. A typical use for
theswitch statement is to use it together with break to code a
multiway selection structure.
JAVA LANGUAGE RULE break .Thebreak statement transfers
control out of its enclosing block , where a block is any sequence of
statements contained within curly brackets {and}.
JAVA DEBUGGING TIP Switch without break .A common error in
coding the switch-based multiway selection is forgetting t o put a
break statement at the end of each clause. This may cause more than
one case to be executed.
288 CHAPTER 6 •Control Structures
SELF-STUDY EXERCISES
EXERCISE 6.15 Identify any errors in the following switch structures
(if there is no error, specify the output):
☛ ✟
( a ) i n t k = 0 ;
switch ( k )
case 0 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 1 :
System . out . p r i n t l n ( ”one” ) ;
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
✡ ✠
☛ ✟
( b ) i n t k = 0 ;
switch ( k + 1)
{ case 0 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 1 :
System . out . p r i n t l n ( ”one” ) ;
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
}
✡ ✠
☛ ✟
( c ) i n t k = 6 ;
switch ( k / 3 . 0 )
{ case 2 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 3 :
System . out . p r i n t l n ( ”one” ) ;
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
}
✡ ✠
EXERCISE 6.16 Flavors of ice cream are represented as integers where
0 is vanilla, 1 is chocolate, and 2 is strawberry. Write a switch statement
that checks an integer variable flavor and prints out the name of the ice
cream ﬂavor or prints “Error” in the default case.
EXERCISE 6.17 Modify your solution to the previous exercise to use
constants (ﬁnal variables) to represent the ice cream ﬂavors .
SECTION 6.11 •OBJECT-ORIENTED DESIGN:Structured Programming 289
6.11 OBJECT-ORIENTED DESIGN:
Structured Programming
Structured programming is the practice of writing programs that are built up
from a small set of predeﬁned control structures. As an overa ll approach
to programming, structured programming has largely been su perseded
by the object-oriented approach. Nevertheless, its design p rinciples are
still relevant to the design of the algorithms and methods th at make up a
program’s objects.
The principles of structured programming seem so obvious to day that
it may be difﬁcult to appreciate their importance. In the 1960 s and 1970s,
one of the main controls used in programs was the infamous go to state-
ment, which could be used to transfer control of a program to a ny arbi-
trary location within it, and from there to any other arbitra ry location,
and so on. This led to incredibly complex and ill-formed prog rams—so
called “spaghetti code”—that were almost impossible to unde rstand and Spaghetti code
modify.
Structured programming evolved in reaction to the unstruct ured soft-
ware development practices of the 1960s, which were fraught with budget
overruns, costly delays, and failed products. One of the cla ssic research
results of that era was a 1966 paper by Boehm and Jacopini that showed
that any program using go to’s could be represented by an equi valent pro-
gram that used a sequence of two types of controls: if/else an d while
structures. Another inﬂuential paper by Edgar Dikjstra (“GoT o Statement
Considered Harmful”) pointed out the various ways in which th e go to
statement could lead to impossibly complex programs.
The Pascal language, introduced by Nicklaus Wirth in 1971, w as de-
signed to promote structured programming techniques and be came the
language of choice within academic institutions because of its suitability
as a teaching language. In Pascal, the go to was replaced with t he four
structures that control the ﬂow of execution in a program (Fig . 6.14):
method2 method1Sequence
Repetition while loop Method call and return
TrueTrue
FalseFalseSelection if/else Figure 6.14: Flowcharts of the four
types of control structures. Each
small rectangle represents a single
executable statement.
•Sequence —The statements in a program are executed in sequential or-
der unless their ﬂow is interrupted by one of the following con trol
structures.
290 CHAPTER 6 •Control Structures
•Selection —The if,if/else , andswitch statements are branching
statements that allow choice through the forking of the cont rol path
into two or more alternatives.
•Repetition —The for,while , anddo-while statements are looping
statements that allow the program to repeat a sequence of sta tements.
•Method Call —Invoking a method transfers control temporarily to a
named method. Control returns to the point of invocation whe n the
method is completed.
No matter how large or small a program you write, its ﬂow of cont rol can
be constructed as a combination of these four basic types of s tructures.
Preconditions and Postconditions
The Java language supplies us with a good collection of contr ol structures,
and Java’s syntax constrains the way we can use them. One of th e fea-
tures of the four control structures is that each has a single entry point
and exit (Fig. 6.14). This is an extremely important propert y. To grasp its
importance, consider the following debugging problem:
☛ ✟
k = 0 ; // 1 . U n s t r u c t u r e d c o d e
System . out . p r i n t l n ( ”k= ” + k ) ; // 2 . k s h o u l d e q u a l 0 h e r e
goto l a b e l 1 ; // 3 .
l a b e l 2 :
System . out . p r i n t l n ( ”k= ” + k ) ; // 4 . k s h o u l d e q u a l 1 h e r e
✡ ✠
In this example a goto statement is used to jump to label1 , a label that
marks a section of code somewhere else in the program. Suppos e we’re
trying to determine how khas acquired an erroneous value and that its
value is correct in line 2 of this sequence. Given the go to sta tement on
line 3, there’s no guarantee that control will ever return to theprintln()
statement on line 4. Thus, in unstructured code it is very dif ﬁcult to nar-
row the scope of an error to a ﬁxed segment of code. Because the go to
statement can transfer control anywhere in the program, wit h no guar-
antee of return, any segment of code can have multiple entry p oints and
multiple exits.
Now contrast the unstructured code with the following well- structured
code:
☛ ✟
k = 0 ; // 1 . S t r u c t u r e d c o d e
System . out . p r i n t l n ( ”k= ” + k ) ; // 2 . k s h o u l d e q u a l 0 h e r e
someMethod ( ) ; // 3 .
System . out . p r i n t l n ( ”k= ” + k ) ; // 4 . k s h o u l d e q u a l 1 h e r e
✡ ✠
In this case, we can be certain that control will eventually re turn to line 4.
Ifk’s value is erroneous on line 4, we can trace through someMethod() to Debugging with println()
ﬁnd the error. Because any segment of a structured program ha s a single
entry and exit, we can use a pair of println() statements in this way to
converge on the location of the program bug.
An important implication of the single-entry/single-exit property is
that we can use preconditions and postconditions to help us design and
SECTION 11 •OOD: Structured Programming 291
debug our code. The previous example provided a simple examp le: The
precondition is that kshould equal 0 on line 2, and the postcondition is that
kshould equal 1 on line 4. Figure 6.15 shows some additional ex amples.
•☛ ✟
i n t k = 0 ; // P r e c o n d i t i o n : k == 0
k = 5 ; // A s s i g n m e n t t o k
// P o s t c o n d i t i o n : k == 5
✡ ✠
•☛ ✟
i n t k = 0 ; // P r e c o n d i t i o n : k == 0
while ( k<100){ // W h i l e l o o p
k = 2∗k + 2 ;
}
// P o s t c o n d i t i o n : k >= 1 0 0
✡ ✠
•☛ ✟
/∗
∗f a c t o r i a l ( n ) :
∗ f a c t o r i a l ( n ) i s 1 i f n i s 0
∗ f a c t o r i a l ( n ) i s n ∗n−1∗n−2∗. . .∗1 i f n >0
∗P r e c o n d i t i o n : n >= 0
∗P o s t c o n d i t i o n :
∗ f a c t o r i a l ( n ) = 1 i f n = 0
∗ = n∗n−1∗n−2∗. . .∗1 i f n >0
∗/
public i n t f a c t o r i a l ( i n t n ){
i f( n == 0)
return 1 ;
else{
i n t f = 1 ; // I n i t a t e m p o r a r y v a r i a b l e
for (i n t k = n ; k >= 1 ; k−−)// F o r n down t o 1
f = f∗k ; // A c c u m u l a t e t h e p r o d u c t
return f ; // R e t u r n t h e f a c t o r i a l
}// e l s e
}// f a c t o r i a l ( )
✡ ✠
Figure 6.15: Using pre- and postconditions to document code .
In the ﬁrst example, we use pre- and postconditions to deﬁne th e se-
mantics of an assignment statement. No matter what value khas before
the assignment, the execution of the assignment ( k = 5 ) will make the
postcondition ( k == 5 ) true.
In the second example, the postcondition follows from the sem antics of
the while loop. Because the loop-entry condition is k < 100 , when the
loop exits the postcondition ( k >= 100 ) must be true.
The third example shows how pre- and postconditions can be us ed to
design and document methods. The factorial(n) is deﬁned for n≥0as
follows:
☛ ✟
f a c t o r i a l ( n ) i s 1 , i fn == 0
f a c t o r i a l ( n ) i s n ∗n−1∗n−2∗. . .∗1 ,i fn>0
✡ ✠
292 CHAPTER 6 •Control Structures
In other words, the factorial of Nis deﬁned as the cumulative product of
multiplying 1 times 2, times 3, and so on up to N. For example, if Nis 5,
thenfactorial(5) is 1 * 2 * 3 * 4 * 5 = 120.
Note how the factorial computation is done in the method. The variable
f, which is used to accumulate the product, is initialized to 1 . Then on each
iteration of the for loop, fis multiplied by kand the product is assigned
back to f. This is similar to the way we accumulate a sum, except in this
case we are accumulating a product.
The precondition on the factorial() method represents the condi-
tion that must be true in order for the method to work correctl y. Factorial
is undeﬁned for n<0, so it is important that nbe greater than or equal
to 0 whenever this method is called. Given that the precondit ion holds,
the postcondition gives a precise speciﬁcation of what must be true when
the method is ﬁnished.
Design: Defensive Programming
The pre- and postconditions for a method can be used to design de-
fensive code—that is, code that guards against errors. For ex am-
ple, what action should factorial() take if its precondition fails to
hold? In Java, the best way to handle this situation is to throw an
IllegalArgumentException , as the following example illustrates:
☛ ✟
public i n t f a c t o r i a l ( i n t n ){
i f( n<0) // P r e c o n d i t i o n f a i l u r e
throw new IllegalArgumentException ( ” F a c t o r i a l : ” + n ) ;
i f( n == 0)
return 1 ;
else{
i n t f = 1 ; // I n i t a t e m p o r a r y v a r i a b l e
for (i n t k = n ; k >= 1 ; k−−) // F o r n down t o 1
f = f∗k ; // A c c u m u l a t e t h e p r o d u c t
return f ; // R e t u r n t h e f a c t o r i a l
}
}// f a c t o r i a l ( )
✡ ✠
Anexception is an erroneous condition (an error) that arises during
the running of a program. An Exception is an object that encap-
sulates information about the erroneous condition. A progr am can
throw anException , thereby stopping the program, when an er-
roneous condition is detected. In this example, we create a ne w
IllegalArgumentException that would report the illegal value of n
with something like the following error message:
☛ ✟
Exception in thread ”main” java . lang . IllegalArgumentException :
F a c t o r i a l : −1
at Test . f a c t o r i a l ( Param . java : 5 )
at Test . main ( Param . java : 1 8 )
✡ ✠
You have undoubtedly already encountered thrown exception s during
program development. Java has an extensive hierarchy of Exception s,
SECTION 11 •OOD: Structured Programming 293
which we will cover in some depth in Chapter 11. For now, howev er, we
just note how to use the IllegalArgumentException . As its name
implies, an IllegalArgumentException is used when an argument in
a method call is not legal.
Rather than continuing the program with an erroreous data va lue,
throwing an exception causes the program to stop and print an error mes-
sage. Determining whether an argument is legal or illegal is an impor-
tant use of the method’s preconditions. The failure of the pr econdition
infactorial() points to a problem elsewhere in the program, because
it is doubtful that the program deliberately passed a negati ve value to
factorial() . The discovery of this error should lead to modiﬁcations
in that part of the program where factorial() was invoked—perhaps
to some validation of the user’s input:
☛ ✟
i n t num = I n t e g e r . p a r s e I n t ( t e x t I n . getText ( ) ) ;
i f(num>= 0) // I f f a c t o r i a l ( ) p r e c o n d i t i o n v a l i d
factNum = f a c t o r i a l (num ) ; // C o m p u t e f a c t o r i a l
else
System . out . p r i n t l n ( ” Error ” ) ;// R e p o r t i n p u t e r r o r }
✡ ✠
This would be the traditional way to handle this kind of error .
Using Pre- and Postconditions
The use of preconditions and postconditions in the ways we’v e described
can help improve a program’s design at several distinct stag es of its
development:
•Design stage: Using pre- and postconditions in design helps to clarify
the design and provides a precise measure of correctness.
•Implementation and testing stage: Test data can be designed t o demon-
strate that the preconditions and postconditions hold for a ny method
or code segment.
•Documentation stage: Using pre- and postconditions to docu ment the
program makes the program more readable and easier to modify and
maintain.
•Debugging stage: Using the pre- and postconditions provide s precise
criteria that can be used to isolate and locate bugs. A method is incor-
rect if its precondition is true and its postcondition is fal se. A method
is improperly invoked if its precondition is false.
Like other programming skills and techniques, learning how to use pre-
and postconditions effectively requires practice. One way to develop these
skills is to incorporate pre- and postconditions into the do cumentation of
the methods you write for laboratories and programming exer cises. Ap-
pendix A provides guidelines on how to incorporate pre- and p ostcondi-
tions into your program’s documentation. However, it would b e a mistake
to get in the habit of leaving the identiﬁcation of pre- and po stconditions
to the documentation stage. The method’s documentation, in cluding its
pre- and postconditions, should be developed during the des ign stage and
should play a role in all aspects of program development.
294 CHAPTER 6 •Control Structures
Effective Program Design
What we’re really saying here is that using pre- and postcondi tions forces
you to analyze your program’s logic. It is not enough to know th at a single
isolated statement within a program works correctly at the p resent time.
You have to ask yourself: Will it continue to work if you chang e some
other part of the program? Will other parts of the program con tinue to
work if you revise it? No matter how clever you are, it is not po ssible to
keep an entire model of a good-sized program in your head at on e time.
It is always necessary to focus on a few essential details and l eave aside
certain others. Ideally, what you hope is that the details you ’ve left aside
for the moment aren’t the cause of the current bug you’re tryi ng to ﬁx.
Using pre- and postconditions can help you determine the cor rectness of
the details you choose to set aside.
JAVA EFFECTIVE DESIGN Pre- and Postconditions. Pre- and
postconditions are an effective way of analyzing the logic o f your
program’s loops and methods. They should be identiﬁed at the
earliest stages of design and development. They should play a role in
the testing and debugging of the program. Finally, they shou ld be
included, in a systematic way, in the program’s documentati on.
JAVA PROGRAMMING TIP Develop your program’s
documentation at the same time that you develop its code and i nclude
the pre- and postconditions in the documentation.
As the programs you write become longer and more complex, the chances
that they contain serious errors increase dramatically. Th ere’s no real way
to avoid this complexity. The only hope is to try to manage it. In addi-
tion to analyzing your program’s structure, another import ant aspect of
program design is the attempt to reduce its complexity.
JAVA EFFECTIVE DESIGN Reducing Complexity. Design your
programs with an aim toward reducing their complexity.
Perhaps the best way to reduce complexity is to build your pro grams us-
ing a small collection of standard structures and technique s. The basic
control structures (Fig. 6.14) help reduce the potential co mplexity of a pro-
gram by constraining the kinds of branching and looping stru ctures that
can be built. The control structures help to manage the compl exity of your
SECTION 11 •OOD: Structured Programming 295
program’s algorithms. In the same way, the following practic es can help
reduce and manage the complexity in a program.
JAVA PROGRAMMING TIP Standard Techniques. Acquire and use
standard programming techniques for standard programming
problems. For example, using a temporary variable to swap th e values
of two variables is a standard technique.
JAVA PROGRAMMING TIP Encapsulation. Use methods wherever
appropriate in your own code to encapsulate important secti ons of
code and thereby reduce complexity.
JAVA PROGRAMMING TIP Code Reuse. Instead of reinventing the
wheel, use library classes and methods whenever possible. T hese have
been carefully designed by experienced programmers. Libra ry code
has been subjected to extensive testing.
SELF-STUDY EXERCISES
EXERCISE 6.18 Identify the pre- and postconditions on jand kwhere
indicated in the following code segment:
☛ ✟
i n t j = 0 ; k = 5 ;
do{
i f( k % 5 == 0) {
// P r e c o n d i t i o n
j += k ;
k−−;
}
else k∗= k ;
}while ( j<= k ) ;
// P o s t c o n d i t i o n
✡ ✠
EXERCISE 6.19 Identify the pre- and postconditions for the following
method, which computes xnforn≥0:
☛ ✟
public double power ( double x , i n t n ){
double pow = 1 ;
for (i n t k = 1 ; k <= n ; k++)
pow = pow ∗x ;
return pow ;
}// p o w e r ( )
✡ ✠
296 CHAPTER 6 •Control Structures
Special Topic: What Can Be Computed?
Did you ever wonder whether there are problems that cannot be solved by
a computer, no matter what kind of control structures are use d? Well, back
in 1939, in his seminal paper titled “On Computable Numbers, ” Alan Tur-
ing proved that indeed there are an inﬁnite number of unsolva ble prob-
lems. Prior to this, mathematicians and logicians thought a ll problems
could be solved. So Turing’s proof was quite a blow!
To help him prove this point, Turing deﬁned an abstract compu ter,
which has come to be known as a Turing machine. A Turing machin e
has an alphabet of symbols; a read/write head; an inﬁnitely l ong tape
on which the read/write head can write symbols, and from whic h it can
also read symbols; and a control unit, which controls the mov ement and
action of the read/write head. Note that the Turing machine e lements
correspond to key components of a real computer—although Tur ing in-
vented this concept a decade before the ﬁrst computers were d eveloped.
The read/write head corresponds to a computer’s central pro cessing unit
(CPU). The tape corresponds to the computer’s memory. And th e control
unit corresponds to the computer program.
A Turing machine represents a purely abstract concept of com puta-
tion. It represents the pure idea of an algorithmic solution t o a problem.
Equipped with this concept, Turing was able to prove that the re are un-
solvable problems—that is, problems for which no algorithm c an arrive at
a solution.
One such problem is the halting problem . This problem asks whether an
algorithm can be devised to determine whether an arbitrary p rogram will
eventually halt. If there were such an algorithm, it could be u sed to detect
programs that contain inﬁnite loops, a service that might be really helpful
in an introductory computing lab, among other places! But, a las, there can
be no such algorithm.
Here’s an outline of a proof that shows that the halting proble m is un-
solvable. (This particular version of the proof was suggest ed by J. Glenn
Brookshear in Computer Science: An Overview , Benjamin-Cummings, 1985.)
Suppose you had a program, P, that solves the halting problem. That is,
whenever Pis given a self-halting program, it sets a variable isTerminating
to true, and otherwise it sets isTerminating to false. Now let’s create a new
version of P, namedP′, which is identical to Pexcept that right after where
Psets isTerminating to true or false, P′contains the following loop:
☛ ✟
while ( isTerminating == true ) ; // I n f i n i t e i f i s T e r m i n a t i n g t r u e
✡ ✠
In other words, if the input to P′is a self-terminating program, then P′
will enter an inﬁnite loop and it won’t terminate. Otherwise , if a non-
self-terminating program is input to P′,P′will skip the loop and will
terminate.
Now what if we give a representation of P′to itself. Will it halt? The
answer generates a contradiction: If P′is a self-terminating program, then
when it is input to itself, it will not terminate. And if P′is not self-
terminating, when it is input to itself, it will terminate. B ecause our as-
sumption that Psolves the halting problem has led to a contradiction, we
CHAPTER 6 •Chapter Summary 297
have to conclude that it wasn’t a very good assumption in the ﬁ rst place.
Therefore, there is no program that can solve the halting pro blem.
The topic of computability is a fundamental part of the compu ter sci-
ence curriculum, usually taught in a sophomore- or junior-le vel theory of
computation course.
CHAPTER SUMMARY Technical Terms
conditional loop
counting loop
do-while statement
inﬁnite loop
initializer
limit bound
loop bodyloop bound
loop entry condition
nested loop
postcondition
precondition
priming read
repetition structuresentinel bound
unit indexing
updater
while statement
zero indexing
Summary of Important Points
•Arepetition structure is a control structure that allows a statement or
sequence of statements to be repeated.
•All loop structures involve three elements—an initializer , aloop entry
condition or a loop boundary condition , and an updater .
•When designing a loop, it is important to analyze the loop stru cture to
make sure that the loop bound will eventually be satisﬁed.
•Thefor statement has the following syntax:
for ( initializer ;loop entry condition ;updater )
for loop body ;TABLE 6.2 A summary
of various loop bounds
Bound Example
Counting k <100
Sentinel input != 9999
Flag done !=true
Limit amount <0.5•Thewhile statement takes the following form:
while ( loop entry condition )
loop body ;
•Thedo-while statement has the following general form:
do
loop body ;
while ( loop entry condition ) ;
•When designing a loop, it is important to analyze the loop stru cture to
make sure that the loop bound will eventually be satisiﬁed. T able 6.2
summarizes the types of loop bounds that we have identiﬁed.
•Structured programming is the practice of writing programs that are
built up from a small set of predeﬁned control structures—the sequence ,
selection ,repetition , and method-call structures. An important feature of
these structures is that each has a single entry and exit.
•Aprecondition is a condition that must be true before a certain code
segment executes. A postcondition is a condition that must be true when
a certain code segment is ﬁnished. Preconditions and postco nditions
should be used in the design, coding, documentation, and deb ugging
of algorithms and methods.
298 CHAPTER 6 •Control Structures
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 6.1 Identify the syntax error in the following for loop statements:
a. Commas are used instead of semicolons in the header.
☛ ✟
for (i n t k = 5 ; k <1 0 0 ; k++)
System . out . p r i n t l n ( k ) ;
✡ ✠
b. There shouldn’t be 3 semicolons in the header
☛ ✟
for (i n t k = 0 ; k <12 ; k−−)
System . out . p r i n t l n ( k ) ;
✡ ✠
SOLUTION 6.2 Identify those statements that result in inﬁnite loops:
a. Inﬁnite loop because k is never incremented.
b. Inﬁnite loop because k is always odd and thus never equal to 100 .
SOLUTION 6.3 Your sister is learning to count by fours. Write a for loop that
prints the following sequence of numbers: 1, 5, 9, 13, 17, 21, 25.
☛ ✟
for (i n t k = 1 ; k <= 2 5 ; k = k+4)
System . out . p r i n t ( k + ” ” ) ;
✡ ✠
SOLUTION 6.4 What value will jhave when the following loop terminates? An-
swer :jwill be undeﬁned when the loop terminates. It is a local variable whose
scope is limited to the loop body.
☛ ✟
for (i n t i = 0 ; i <1 0 ; i ++)
{
i n t j ;
j = j + 1 ;
}
✡ ✠
SOLUTION 6.5 Write a nested for loop to print the following geometric pat-
tern:
☛ ✟
#
# #
# # #
# # # #
# # # # #
for (i n t row = 1 ; row <= 5 ; row++) { // For each row
for (i n t c o l = 1 ; c o l <= row ; c o l ++) // Columns per row
System . out . p r i n t ( ’ # ’) ;
System . out . p r i n t l n ( ) ; // New l i n e
}// row
✡ ✠
SOLUTION 6.6 Identify the syntax error in the following while structures:
CHAPTER 6 •Solutions to Self-Study Exercises 299
a.☛ ✟
i n t k = 5 ;
while ( k<100){
System . out . p r i n t l n ( k ) ;
k++ << Missing semicolon
}
✡ ✠
b.☛ ✟
i n t k = 0 ;
while ( k<1 2 ; ){ << Extra semicolon
System . out . p r i n t l n ( k ) ;
k++;
}
✡ ✠
SOLUTION 6.7 Determine the output and/or identify the error in each of the
following while structures.
a.☛ ✟
i n t k = 0 ;
while ( k<100)
System . out . p r i n t l n ( k ) ; << Missing updater in loop body
✡ ✠
Output: inﬁnite loop prints 0 0 0 0 0...
b.☛ ✟
while ( k<100){ << Missing i n i t i a l i z e r
System . out . p r i n t l n ( k ) ;
k++;
}
✡ ✠
Output: unpredictable since k’s initial value is not known
SOLUTION 6.8 Your younger sister is now learning how to count by sixes. Write
awhile loop that prints the following sequence of numbers: 0, 6, 12, 18, 24 , 30, 36.
☛ ✟
i n t k = 0 ; // I n i t i a l i z e r
while ( k<= 36){ // Loop −entry condition
System . out . p r i n t l n ( k ) ;
k += 6 ; // Updater
}
✡ ✠
SOLUTION 6.9 IfNis even, divide it by 2. If Nis odd, subtract 1 and then
divide it by 2. This will generate a sequence that is guarante ed to terminate at 0.
For example, if Nis initially 15, then you get the sequence 15, 7, 3, 1, 0. Write a
method that implements this sequence using a while statement.
☛ ✟
public s t a t i c void sub1Div2 ( i n t N){
while (N != 0) {
System . out . p r i n t (N + ” ” ) ;
i f(N % 2 == 0)
N = N / 2 ;
el s e
N = (N −1) / 2 ;
}
System . out . p r i n t l n ( N ) ;
}// sub1Div2 ( )
✡ ✠
SOLUTION 6.10 Identify the syntax error in the following do-while structures:
300 CHAPTER 6 •Control Structures
a.☛ ✟
i n t k = 0 ;
do while ( k<100)<< Misplaced condition
{
System . out . p r i n t l n ( k ) ;
k++;
} << Belongs here
✡ ✠
b.☛ ✟
i n t k = 0 ;
do{
System . out . p r i n t l n ( k ) ;
k++;
}while ( k<12)<< Missing semicolon
✡ ✠
SOLUTION 6.11 Your sister has moved on to counting by sevens. Write a
do-while loop that prints the following sequence of numbers: 1, 8, 15, 22, 29 ,
36, 43.
☛ ✟
n = 1 ; // I n i t i a l i z e r
do{
System . out . p r i n t ( n + ” ” ) ;
n += 7 ; // Updater
}while ( n<= 4 3 ) ; // Loop entry condition
✡ ✠
SOLUTION 6.12 Write a method to input and validate pizza sales.
☛ ✟
public i n t getAndValidatePizzaPrice ( ) {// Uses KeyboardReader
i n t pizza = 0 ;
do{
reader . prompt ( ” Input a pizza p r i c e ( 8 , 10 , or 15) ” ) ;
reader . prompt ( ” or 99 to end the l i s t >> ”) ;
pizza = reader . getKeyboardInteger ( ) ;
i f( ( pizza != 99) && ( pizza != 8) && ( pizza != 10) &&
( pizza != 1 5 ) )
System . out . p r i n t l n ( ” Error : you ’ ve entered an ”
+” i n v a l i d pizza p r i c e \n”) ; // Error input
el s e // OK input
System . out . p r i n t l n ( ”You input ” + pizza + ”\n”) ;
}while ( ( pizza != 99) && ( pizza != 8) &&
( pizza != 10) && ( pizza != 1 5 ) ) ;
return pizza ;
}// getAndValidatePizzaPrice ( )
✡ ✠
CHAPTER 6 •Solutions to Self-Study Exercises 301
SOLUTION 6.13 Write a method to input and validate pizza sales using the
numbers 1, 2, and 3 to represent pizzas at different price lev els.
☛ ✟
public i n t getAndValidatePizzaPrice ( ) {// Uses KeyboardReader
i n t pizza = 0 ;
do{
reader . prompt ( ” Input a 1 ,2 or 3 to i n d i c a t e pizza ”
+” p r i c e ( 1( $8 ) , 2( $10 ) , or 3( $15 ) ) ” ) ;
reader . prompt ( ” or 0 to end the l i s t >> ”) ;
pizza = reader . getKeyboardInteger ( ) ;
i f( ( pizza <0)||( pizza >3 ) ) // Error check
System . out . p r i n t l n ( ” Error : you ’ ve entered an ”
+” i n v a l i d value \n”) ;
el s e // OK input
System . out . p r i n t l n ( ”You input ” + pizza + ”\n”) ;
}while ( ( pizza <0)||( pizza >3) ) ;
i f( pizza == 1)
return 8 ;
el s e i f ( pizza == 2)
return 1 0 ;
el s e i f ( pizza == 3)
return 1 5 ;
el s e
return 0 ;
}// getAndValidatePizzaPrice ( )
✡ ✠
SOLUTION 6.14 For each of the following problems, decide whether a counting
loop structure, a while structure, or a do-while structure should be used, and
write a pseudocode algorithm.
•Printing the names of all the visitors to a Web site could use a coun ting loop
because the exact number of visitors is known.
☛ ✟
for each name in the v i s i t o r ’ s log
p r i n t the name
✡ ✠
•Validating that a user has entered a positive number requires ado-while
structure in which you repeatedly read a number and validate i t.
☛ ✟
do
read a number
i fnumber i s invalid , p r i n t e r r o r message
while number i s i n v a l i d
✡ ✠
•Changing all the backslashes ( \) in a Windows Web page address, to the slashes
(/) used in a Unix Web page address.
☛ ✟
for each c h a r a c t e r in the Web page address
i fi t i s a backslash r e p l a c e i t with s l a s h
✡ ✠
•Finding the largest in a list of numbers requires a while loop to guard against
an empty list.
☛ ✟
i n i t i a l i z e maxMPG to s m a l l e s t p o s s i b l e number
while there are more c a r s in the database
i fcurrent car ’ s M P G i s g r e a t e r than maxMPG
r e p l a c e maxMPG with i t
✡ ✠
SOLUTION 6.15 Identify any errors in the following switch structures (if ther e
is no error, specify the output):
302 CHAPTER 6 •Control Structures
a.☛ ✟
i n t k = 0 ;
switch ( k ) // Syntax e r r o r : missing braces
case 0 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 1 :
System . out . p r i n t l n ( ”one” ) ;
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
✡ ✠
b.☛ ✟
i n t k = 0 ;
switch ( k + 1)
{
case 0 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 1 :
System . out . p r i n t l n ( ”one” ) ;// Output ”one”
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
}
✡ ✠
c.☛ ✟
i n t k = 6 ;
switch ( k / 3 . 0 ) // Syntax e r r o r : not an i n t e g r a l value
{
case 2 :
System . out . p r i n t l n ( ” zero ” ) ;
break ;
case 3 :
System . out . p r i n t l n ( ”one” ) ;
break ;
default :
System . out . p r i n t l n ( ” d e f a u l t ” ) ;
break ;
}
✡ ✠
SOLUTION 6.16 Aswitch statement to print ice cream ﬂavors:
☛ ✟
switch ( f l a v o r )
{
case 1 :
System . out . p r i n t l n ( ” V a n i l l a ” ) ;
break ;
case 2 :
System . out . p r i n t l n ( ” Chocolate ” ) ;
break ;
case 3 :
System . out . p r i n t l n ( ” Strawberry ” ) ;
break ;
default :
System . out . p r i n t l n ( ” Error ” ) ;
}
✡ ✠
CHAPTER 6 •Exercises 303
SOLUTION 6.17
☛ ✟
public f i n a l i n t VANILLA = 0 ,
CHOCOLATE = 1 ,
STRAWBERRY = 2 ;
switch ( f l a v o r )
{
case VANILLA:
System . out . p r i n t l n ( ” V a n i l l a ” ) ;
break ;
case CHOCOLATE:
System . out . p r i n t l n ( ” Chocolate ” ) ;
break ;
case STRAWBERRY:
System . out . p r i n t l n ( ” Strawberry ” ) ;
break ;
default :
System . out . p r i n t l n ( ” Error ” ) ;
}
✡ ✠
SOLUTION 6.18 Identify the pre- and postconditions on jand kwhere indicated
in the following code segment:
☛ ✟
i n t j = 0 ; k = 5 ;
do{
i f( k % 5 == 0) {
// Precondition : j <= k
j += k ;
k−−;
}
el s e k∗= k ;
}while ( j<= k ) ;
// Postcondition : j >k
✡ ✠
SOLUTION 6.19 Identify the pre- and postconditions for the following method,
which computes xnforn>=0.
☛ ✟
// Precondition : N >= 0
// Postcondition : power ( x , n ) == x to the n
public double power ( double x , i n t n ){
double pow = 1 ;
for (i n t k = 1 ; k <= n ; k++)
pow = pow ∗x ;
return pow ;
}// power ( )
✡ ✠
EXERCISES EXERCISE 6.1 Explain the difference between the following pairs of terms:
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.a.Counting loop and conditional loop .
b.For statement and while statement .
c.While statement and do-while statement .
d.Zero indexing and unit indexing .
e.Sentinel bound and limit bound .
f.Counting bound and ﬂag bound .
g.Loop initializer and updater .
h.Named constant and literal .
i.Compound statement and null statement .
304 CHAPTER 6 •Control Structures
EXERCISE 6.2 Fill in the blank.
a. The process of reading a data item before entering a loop is known a s a .
b. A loop that does nothing except iterate is an example of .
c. A loop that contains no body is an example of a statement.
d. A loop whose entry condition is stated as (k<100||k>=0)would be an
example of an loop.
e. A loop that should iterate until the user types in a special val ue should use a
bound.
f. A loop that should iterate until its variable goes from 5 to 100 sh ould use a
bound.
g. A loop that should iterate until the difference between two va lues is less than
0.005 is an example of a bound.
EXERCISE 6.3 Identify the syntax errors in each of the following:
a. for (int k = 0; k ¡ 100; k++) System.out.println(k)
b. for (int k = 0; k ¡ 100; k++); System.out.println(k);
c. int k = 0 while k ¡ 100 System.out.println(k); k++;
d. int k = 0; do System.out.println(k); k++; while k ¡ 100 ;
EXERCISE 6.4 Determine the output and/or identify the error in each of the
following code segments:
a. for (int k = 1; k == 100; k += 2) System.out.println(k);
b. int k = 0; while (k ¡ 100) System.out.println(k); k++;
c. for (int k = 0; k ¡ 100; k++) ; System.out.println(k);
EXERCISE 6.5 Write pseudocode algorithms for the following activities, paying
particular attention to the initializer ,updater , and boundary condition in each case.
a.a softball game
b.a five-question quiz
c.looking up a name in the phone book
EXERCISE 6.6 Identify the pre- and postconditions for each of the statements
that follow. Assume that all variables are int and have been properly declared.
a. int result = x / y;
b. int result = x
c. int x = 95; do x /= 2; while(x ¿= 0);
EXERCISE 6.7 Write three different loops—a for loop, a while loop, and a
do-while loop—to print all the multiples of 10, including 0, up to and incl uding
1,000.
EXERCISE 6.8 Write three different loops—a for loop, a while loop, and a
do-while loop—to print the following sequence of numbers: 45, 36, 27, 18, 9, 0,
−9,−18,−27,−36,−45.
EXERCISE 6.9 Write three different loops—a for loop, a while loop , and a
do-while loop—to print the following ski-jump design:
☛ ✟
#
# #
# # #
# # # #
# # # # #
# # # # # #
# # # # # # #
✡ ✠
CHAPTER 6 •Exercises 305
EXERCISE 6.10 The Straight Downhill Ski Lodge in Gravel Crest, Vermont, gets
lots of college students on breaks. The lodge likes to keep track of r epeat visitors.
Straight Downhill’s database includes an integer variable, visit, which gives the
number of times a guest has stayed at the lodge (1 or more). Write th e pseudocode
to catch those visitors who have stayed at the lodge at least twic e and to send them
a special promotional package (pseudocode = send promo). ( Note: The largest
number of stays recorded is eight. The number nine is used as an e nd-of-data
ﬂag.)
EXERCISE 6.11 Modify your pseudocode in the previous exercise. In addition
to every guest who has stayed at least twice at the lodge receiv ing a promotional
package, any guest with three or more stays should also get a $40 c oupon good for
lodging, lifts, or food.
EXERCISE 6.12 Write a method that is passed a single parameter, N, and dis-
plays all the even numbers from 1 to N.
EXERCISE 6.13 Write a method that is passed a single parameter, N, that prints
all the odd numbers from 1 to N.
EXERCISE 6.14 Write a method that is passed a single parameter, N, that prints
all the numbers divisible by 10 from Ndown to 1.
EXERCISE 6.15 Write a method that is passed two parameters—a char Chand
anint N—and prints a string of N Chs .
EXERCISE 6.16 Write a method that uses a nested for loop to print the follow-
ing multiplication table:
☛ ✟
1 2 3 4 5 6 7 8 9
1 1
2 2 4
3 3 6 9
4 4 8 12 16
5 5 10 15 20 25
6 6 12 18 24 30 36
7 7 14 21 28 35 42 48
8 8 16 24 32 40 48 56 64
9 9 18 27 36 45 54 63 72 81
✡ ✠
EXERCISE 6.17 Write a method that uses nested for loops to print the patterns
that follow. Your method should use the following statement to print the patterns:
System.out.print(’#’) .
☛ ✟
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # #
# # # # # # #
# # # # # # # # # # # # # # # # # #
✡ ✠
EXERCISE 6.18 Write a program that asks the user for the number of rows and
the number of columns in a box of asterisks. Then use nested loops to g enerate the
box.
306 CHAPTER 6 •Control Structures
EXERCISE 6.19 Write a Java application that lets the user input a sequence of
consecutive numbers. In other words, the program should let the us er keep en-
tering numbers as long as the current number is one greater than the previous
number.
EXERCISE 6.20 Write a Java application that lets the user input a sequence of
integers terminated by any negative value. The program should then report the
largest and smallest values that were entered.
EXERCISE 6.21 How many guesses does it take to guess a secret number be-
tween 1 and N? For example, I’m thinking of a number between 1 and 100. I’ll
tell you whether your guess is too high or too low. Obviously, an intel ligent ﬁrst
guess would be 50. If that’s too low, an intelligent second guess wou ld be 75. And
so on. If we continue to divide the range in half, we’ll eventuall y get down to one
number. Because you can divide 100 seven times (50, 25, 12, 6, 3 , 1, 0), it will take
at most seven guesses to guess a number between 1 and 100. Write a Java applet
that lets the user input a positive integer, N, and then reports how many guesses
it would take to guess a number between 1 and N.
EXERCISE 6.22 Suppose you determine that the ﬁre extinguisher in your
kitchen loses Xpercent of its foam every day. How long before it drops below
a certain threshold ( Ypercent), at which point it is no longer serviceable? Write a
Java applet that lets the user input the values Xand Yand then reports how many
weeks the ﬁre extinguisher will last.
EXERCISE 6.23 Leibnitz’s method for computing πis based on the following
convergent series:
π
4=1−1
3+1
5−1
7+···
How many iterations does it take to compute πto a value between 3.141 and 3.142
using this series? Write a Java program to ﬁnd out.
EXERCISE 6.24 Newton’s method for calculating the square root of Nstarts by
making a (nonzero) guess at the square root. It then uses the origin al guess to
calculate a new guess, according to the following formula:
☛ ✟
guess = ( ( N / guess ) + guess ) / 2 ;
✡ ✠
No matter how wild the original guess is, if we repeat this calcu lation, the algo-
rithm will eventually ﬁnd the square root. Write a square root met hod based on
this algorithm. Then write a program to determine how many guess es are required
to ﬁnd the square roots of different numbers. Uses Math.sqrt() to determine
when to terminate the guessing.
EXERCISE 6.25 Your employer is developing encryption software and wants
you to develop a Java applet that will display all of the primes le ss than N, where
Nis a number to be entered by the user. In addition to displaying the primes
themselves, provide a count of how many there are.
EXERCISE 6.26 Your little sister asks you to help her with her multiplication
and you decide to write a Java application that tests her skills . The program will
let her input a starting number, such as 5. It will generate mu ltiplication problems
ranging from from 5×1to5×12. For each problem she will be prompted to enter
the correct answer. The program should check her answer and shoul d not let
her advance to the next question until the correct answer is giv en to the current
question.
CHAPTER 6 •Exercises 307
EXERCISE 6.27 Write an application that prompts the user for four values and
draws corresponding bar graphs using an ASCII character. For exa mple, if the
user entered 15, 12, 9, and 4, the program would draw
☛ ✟
∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗
∗∗∗∗∗∗∗∗∗∗∗∗
∗∗∗∗∗∗∗∗∗
∗∗∗∗
✡ ✠
EXERCISE 6.28 Revise the application in the previous problem so that the bar
charts are displayed vertically. For example, if the user inp uts 5, 2, 3, and 4, the
program should display
☛ ✟
∗∗
∗∗ ∗∗
∗∗ ∗∗ ∗∗
∗∗ ∗∗ ∗∗ ∗∗
∗∗ ∗∗ ∗∗ ∗∗
−−−−−−−−−−−−−
✡ ✠
EXERCISE 6.29 The Fibonacci sequence (named after the Italian mathematici an
Leonardo of Pisa, ca. 1200) consists of the numbers 0,1,1,2,3,5,8,13,...in which
each number (except for the ﬁrst two) is the sum of the two precedi ng numbers.
Write a method fibonacci(N) that prints the ﬁrst NFibonacci numbers.
EXERCISE 6.30 The Nuclear Regulatory Agency wants you to write a program
that will help determine how long certain radioactive substanc es will take to de-
cay. The program should let the user input two values: a string g iving the sub-
stance’s name and its half-life in years. (A substance’s half- life is the number of
years required for the disintegration of half of its atoms.) The pr ogram should re-
port how many years it will take before there is less than 2 percen t of the original
number of atoms remaining.
EXERCISE 6.31 Modify the CarLoan program so that it calculates a user’s car
payments for loans of different interest rates and different loa n periods. Let the
user input the amount of the loan. Have the program output a table of m onthly
payment schedules.
The next chapter also contains a number of loop exercises.
308 CHAPTER 6 •Control Structures
OBJECTIVES
After studying this chapter, you will
•Be more familiar with Java String s.
•Know how to solve problems that involve manipulating string s.
•Be able to use loops in designing string-processing algorit hms.
OUTLINE
7.1 Introduction
7.2String Basics
7.3 Finding Things Within a String
7.4 Example: Keyword Search
7.5 From the Java Library: StringBuffer
7.6 Retrieving Parts of Strings
7.7 Example: Processing Names and Passwords
7.8 Processing Each Character in a String
7.9 Comparing String s
7.10 From the Java Library: StringTokenizer
7.11 Handling Text in a Graphics Context (Optional)
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 7
Strings and String
Processing
309
310 CHAPTER 7 •Strings and String Processing
7.1 Introduction
You have already had an introduction to String s in the early chapters
of this text. In Chapter 2, we introduced the String data type and
showed how to create String objects and use String methods, such
aslength() ,concat() , andequals() .
We have seen String s used for GUI I/O operations when used
String s as the contents of JTextField s and other text components, as
the values of JLabel s, as the labels for JButton s, and so on. String s
are also used extensively in command-line interfaces.
Another important task that String s are used for are as a standard
way of presenting or displaying information about objects. A s we saw
in Chapter 2, one of the key conventions of the Java class hier archy is
that every class inherits the Object.toString() method, which can
be used to provide a string representation of any object. For e xample,
Integer.toString() converts an int to aString , so that it can be
used in JTextField s orJLabel s.
Programmers often have to work with strings. Think of some of the
tasks performed by a typical word processor, such as cut, pas te, copy, and
insert. When you cut and paste text from one part of the documen t to
another, the program has to move one string of text, the cut, f rom one
location in the document and insert it in another.
Strings are also important because they are our ﬁrst look at a data struc-
ture. Adata structure is a collection of data that is organized (structured)
in some way. A string is a collection of character ( char ) data. Strings are
important data structures in a programming language, and th ey are used
to represent a wide variety of data.
The main purpose of this chapter is to provide a detailed disc ussion of
Java’s string-related classes, including the String ,StringBuffer , and
StringTokenizer classes. These are the important classes for writing
string-processing applications. Our goal is to introduce t he important+String()
+String(in s : String)
+length() :int
+valueOf(in n : int) : String
+concat(in s : String) : String
+valueOf(in d : double) : String
+charAt(in n : int) : char
+equals(in o : Object) : boolean
+indexOf(in ch : int) : int
+indexOf(in ch : int, in start : int) : int
+indexOf(in s : String) : int
+indexOf(in s : String, in start : int) : int
+substring(in strt : int) : String
+substring(in strt : int, in end : int) : String-value
-countStringObject
FIGURE 7.1 The
java.lang.String class.String methods and illustrate common string-processing algorith ms.
We will review how to create strings from scratch and from oth er data
types. We will learn how to ﬁnd characters and substrings ins ide bigger
strings. We will learn how to take strings apart and how to rea rrange their
parts. Finally, we will learn how to apply these string-proc essing skills in
a program that plays the game of Hang Man.
7.2 String Basics
Before we cover the new material on String s, let’s ﬁrst review what
we know about this topic. In Java, String s are considered full-ﬂedged
objects. A String object is a sequence of the characters that make up
the string, plus the methods that are used to manipulate the s tring. The
java.lang.String class (Fig. 7.1) is a direct subclass of Object , and it Are strings objects?
contains many public methods that can be used to perform usef ul opera-
tions on strings (such as concatenation). We will discuss a s election of the
SECTION 7.2 •String Basics 311
more commonly used methods, but for a full listing and descri ption of the
String methods see
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
Like other object variables, String variables serve as references to their
respective objects. However, unlike other Java objects, String s have cer-
tain characteristics in common with the primitive data type s. For example,
as we have already seen, Java allows for literal strings. A string literal is
a sequence of zero or more characters contained in double quo tes, such as
“Socrates” and “” (the empty string ). Java allows us to perform operations
on literal strings, such as concatenation. As we have alread y seen, the
expression "Hello" + "world" results in the string "Helloworld" .
Java also allows us to use string literals to initialize String variables
with an assignment statement. These exceptional features g reatly simplify
the use of String s in our programs. Given how much we use String s,
incorporating these features into Java seems like a good des ign decision.
7.2.1 Constructing Strings
To create String objects, the String class provides many constructors,
including the following:
☛ ✟
public S t r i n g ( ) ; // C r e a t e s a n e m p t y s t r i n g
// C o p y c o n s t r u c t o r : C r e a t e s a c o p y o f a s t r i n g
public S t r i n g ( S t r i n g i n i t i a l v a l u e ) ;
✡ ✠
When we create an object using the ﬁrst constructor, as in
☛ ✟
S t r i n g name = new S t r i n g ( ) ;
✡ ✠
Java will create a String object and make name the reference to it. Fig-value =""
count =0name : String
FIGURE 7.2 An empty string is a
String object with value “” and
count 0.ure 7.2 shows a hypothetical representation of a String object. In addi-
tion to storing the sequence of characters that make up the st ring, Java
also stores an integer value representing the number of char acters in the
string. We have chosen to represent these two elements as the private in-
stance variables, value , for the sequence of characters, and count for the
number of characters. In fact, we don’t know exactly how Java s tores the
sequence of characters. That information is hidden. As Figu re 7.2 illus-
trates, when we use the default constructor, the value of the is the empty
string and its count is 0.
The second constructor is the copy constructor for the String class. A
copy constructor is a constructor that makes a duplicate, sometimes called
a clone, of an object. Many Java classes have copy constructor s. Consider
the following statements:
☛ ✟
S t r i n g s1 = new S t r i n g ( ” Hello ” ) ; ) ;
S t r i n g s2 = new S t r i n g ( s1 ) ;
✡ ✠
312 CHAPTER 7 •Strings and String Processing
These two statements would result in two distinct String objects, both
storing the word “Hello”.
Note that in the ﬁrst of the preceding statements, we used the literal
string “Hello” in the constructor. When Java encounters a new l iteralvalue ="Socrates"
count =8"Socrates" : String
FIGURE 7.3 The literal String
“Socrates.”string in a program, it constructs an object for it. For exampl e, if your
program contained the literal “Socrates,” Java would creat e an object for
it and treat the literal itself as a reference to the object (Fi g. 7.3).
We often use a string literal to assign a value to a String variable:
☛ ✟
S t r i n g s ; // T h e v a l u e o f s i s i n i t i a l l y n u l l
s = ” S o c r a t e s ” ;// s now r e f e r s t o ” S o c r a t e s ” o b j e c t
✡ ✠
In this case, the reference variable sis initially null —that is, it has no
referent, no object, to refer to. However, after the assignmen t statement, s
would refer to the literal object “Socrates,” which is depict ed in Figure 7.3.
Given these two statements, we still have only one object, the String
object containing the word “Socrates.”. But now we have two re ferences
to it: the literal string “Socrates,” and the reference vari able s.
Assignment statements can also be used as initializers when declaring
aString variable:value =""
count =0 name1""value ="Socrates"
count =8: String
: Stringname3name2"Socrates"
FIGURE 7.4 The variables name1 ,
name2 , andname3 serve as
references to the literal String
objects “Socrates” and “”.☛ ✟
S t r i n g name1 = ””; // R e f e r e n c e t o t h e e m p t y s t r i n g
S t r i n g name2 = ” S o c r a t e s ” ;// R e f e r e n c e s t o ” S o c r a t e s ”
S t r i n g name3 = ” S o c r a t e s ” ;
✡ ✠
In this example, Java does not construct new String objects. Instead, as
Figure 7.4 shows, it simply makes the variables name1 ,name2 , andname3
serve as references to the same objects that are referred to by the literal
strings “” and “Socrates.” This is a direct consequence of Ja va’s policy of
creating only one object to serve as the referent of a literal s tring, no mat-
ter how many occurrences there are of that literal in the prog ram. Thus,
these declarations result in no new objects, just new referenc es to existing
objects. The justiﬁcation for this policy is that it saves lots of memory in
our programs. Instead of creating a String object for each occurrence
of the literal “Socrates,” Java creates one object and lets al l occurrences of
“Socrates” refer to that object.
Finally, consider the following declarations, which do inv oke the
String constructors:value ="Socrates"
count =8name5name6name4
: Stringvalue =""
count =0: String
FIGURE 7.5 Together with the
objects in Figure 7.4, there are now
four different String objects with
eight different references to them,
including the literals “Socrates”
and “”.☛ ✟
S t r i n g name4 = new S t r i n g ( ) ; // C r e a t e s a n o b j e c t
S t r i n g name5 = new S t r i n g ( ” S o c r a t e s ” ) ;
S t r i n g name6 = name4 ;
✡ ✠
In this case, as shown in Figure 7.5, Java creates two new object s and
setsname4 to refer to the ﬁrst and name5 to refer to the second. It gives
name4 the empty string as its value, and it gives name5 “Socrates” as its
value. But these two objects must be distinguished from the ob jects corre-
SECTION 7.2 •String Basics 313
sponding to the literals (“” and “Socrates”) themselves. Th e declaration of
name6 just creates a second reference to the object referred to by name4 .
JAVA LANGUAGE RULE Strings. JavaString s are full-ﬂedged
objects, but they have some properties in common with primiti ve
types. They can have literal values and they can be used in ass ignment
statements.
JAVA LANGUAGE RULE String Declaration and
Instantiation. Unless a String() constructor is called explicitly, no
newString object is created when declaring a String variable and
assigning it an initial value.
7.2.2 Concatenating Strings
Another way to build a String object is to concatenate two other strings.
Recall from Chapter 2 that there are two ways to perform strin g concate-
nation in Java: We can use the concat() method or the concatenation
operator, +.
☛ ✟
S t r i n g lastName = ” Onassis ” ;
S t r i n g j a c k i e =
new S t r i n g ( ” J a c q u e l i n e ” +”Kennedy ” + lastName ) ;
System . out . p r i n t l n ( ” J a c q u e l i n e ” . concat ( lastName ) ) ;
✡ ✠
The second of these statements uses the concatenation operator ,+, to create String concatenation
theString “Jacqueline Kennedy Onassis.” The third statement uses the
String method, concat() , to print “JacquelineOnassis.”
Using the + symbol as the string concatenation operator is an other ex- Operator overloading
ample of operator overloading —using the same operator for two or more
different operations—which we encountered in Chapter 5.
JAVA LANGUAGE RULE String Concatenation. When surrounded
on either side by a String , the + symbol is used as a binary
concatenation operator. It has the effect of joining two strings together
to form a single string.
Note that primitive types are automatically promoted to String s when
they are mixed with concatenation operators. Thus, the stat ement
☛ ✟
System . out . p r i n t l n ( ”The sum of 5 and 5 = ” + (5 + 5 ) ) ;
✡ ✠
will print the string “The sum of 5 and 5 = 10.” Note that the int eger
addition—(5 + 5)—is performed ﬁrst, before the integer result is converted
314 CHAPTER 7 •Strings and String Processing
into a String. If we had left off the parentheses around the add ition oper-
ation, the second plus sign would also be interpreted as a con catenation
operator. Thus,
☛ ✟
System . out . p r i n t l n ( ”The concatenation of 5 and 5 = ” + 5 + 5 ) ;
✡ ✠
would print “The concatenation of 5 and 5 = 55.”
SELF-STUDY EXERCISES
EXERCISE 7.1 What will be printed by each of the following segments
of code?
a.String s1 = "silly"; System.out.println(s1);
b.String s2 = s1; System.out.println(s2);
c.String s3 = new String (s1 + " stuff");
System.out.println(s3);
EXERCISE 7.2 Write a String declaration that satisﬁes each of the
following descriptions:
a. Initialize a String variable, str1, to the empty string.
b. Instantiate a String object, str2, and initialize it to the word stop.
c. Initialize a String variable, str, to the concatenation of str1and str2.
EXERCISE 7.3 Evaluate the following expressions:
☛ ✟
i n t M = 5 , N = 1 0 ;
S t r i n g s1 = ”51” , s2 = ”75” ;
✡ ✠
a.M + N b.M + s1 c.s1 + s2
EXERCISE 7.4 Draw a picture, similar to Figure 7.5, showing the ob-
jects and references that are created by the following declar ations:
☛ ✟
S t r i n g s1 , s2 = ” Hello ” , s3 = ” Hello ” ;
S t r i n g s4 = ” h e l l o ” ;
S t r i n g s5 = new S t r i n g ( ” Hello ” ) ;
S t r i n g s6 = s5 ;
S t r i n g s7 = s3 ;
✡ ✠
7.2.3 Indexing String s
Programmers often need to take strings apart or put them toge ther or re-
arrange them. Just think of the many word-processing tasks, such as cut
and paste, that involve such operations. To help simplify su ch operations,
it is useful to know how many characters a string contains and to number,
orindex , the characters that make up the string.
The number of characters in a string is called its length . TheString String length
instance method, length() , returns an integer that gives the String ’s
SECTION 7.2 •String Basics 315
length. For example, consider the following String declarations and the
corresponding values of the length() method for each case:
☛ ✟
S t r i n g s t r i n g 1 = ””; s t r i n g 1 . length ( ) == >0
S t r i n g s t r i n g 2 = ” Hello ” ; s t r i n g 2 . length ( ) == >5
S t r i n g s t r i n g 3 = ”World” ; s t r i n g 3 . length ( ) == >5
S t r i n g s t r i n g 4 = s t r i n g 2 + ” ”
+ s t r i n g 3 ; s t r i n g 4 . length ( ) == >11
✡ ✠
The position of a particular character in a string is called i tsstring in-01234567Indexes
S o c r a t e s
FIGURE 7.6 The string “Socrates”
has eight characters, indexed from 0
to 7. This is an example of zero
indexing .dex. AllString s in Java are zero indexed —that is, the index of the ﬁrst
character is zero. (Remember, zero indexing is contrasted w ithunit index-
ing, in which we start counting at 1.) For example, in “Socrates, ” the letter
Soccurs at index 0, the letter ooccurs at index 1, roccurs at index 3, and so
on. Thus, the String “Socrates” contains eight characters indexed from
0 to 7 (Fig. 7.6). Zero indexing is customary in programming l anguages.
We will see other examples of this when we talk about arrays an d vectors.
JAVA LANGUAGE RULE String Indexing. Strings are indexed
starting at 0. The ﬁrst character in a string is at position 0.
JAVA DEBUGGING TIP Zero Versus Unit Indexing. Syntax and
semantic errors will result if you forget that strings are ze ro indexed.
In a string of Ncharacters, the ﬁrst character occurs at index 0 and the
last at index N−1. This is different from the String.length()
method, which gives the number of characters in the string, c ounting
from 1.
7.2.4 Converting Data to Strings
TheString.valueOf() method is a class method that is used to con-
vert a value of some primitive type into a String object. For example,
the expression, String.valueOf(128) converts its int argument to
theString “128.”
There are different versions of valueOf() , each of which has the fol-
lowing type of signature:
☛ ✟
s t a t i c public S t r i n g valueOf ( Type ) ;
✡ ✠
where Type stands for any primitive data type, including boolean ,
char ,int,double , and so on.
316 CHAPTER 7 •Strings and String Processing
ThevalueOf() method is most useful for initializing String s. Be-
causevalueOf() is a class method, it can be used as follows to instantiate
newString objects:
☛ ✟
S t r i n g number = S t r i n g . valueOf ( 1 2 8 ) ; // C r e a t e s ” 1 2 8 ”
S t r i n g t r u t h = S t r i n g . valueOf ( true ) ; // C r e a t e s ” t r u e ”
S t r i n g bee = S t r i n g . valueOf ( ’B ’) ; // C r e a t e s ” B ”
S t r i n g pi = S t r i n g . valueOf ( Math . PI ) ;
// C r e a t e s ” 3 . 1 4 1 5 9 ”
✡ ✠
We have already seen that Java automatically promotes primi tive type
values to String where necessary, so why do we need the valueOf()
methods? For example, we can initialize a String to “3.14159” as follows:
☛ ✟
S t r i n g pi = new S t r i n g ( ””+Math . PI ) ; // C r e a t e s ” 3 . 1 4 ”
✡ ✠
In this case, because it is part of a concatenation expression , the value of
Math.PI will automatically be promoted to a String value. The point
of thevalueOf() method is twofold. First, it may be the method that the
Java compiler relies on to perform string promotions such as this one. Sec-
ond, using it in a program—even when it is not completely neces sary—
makes the promotion operation explicit rather than leaving it implicit.
This helps to make the code more readable. (Also, see Exercis e 7.9.) Readability
SELF-STUDY EXERCISES
EXERCISE 7.5 Evaluate each of the following expressions:
a.String.valueOf (45)
b.String.valueOf (128 - 7)c.String.valueOf (’X’)
EXERCISE 7.6 Write an expression to satisfy each of the following
descriptions:
a. Convert the integer value 100 to the string ”100”.
b. Convert the character ’V’ to the string ”V”.
c. Initialize a new String object to X times Y.
7.3 Finding Things Within a String
Programmers often have to ﬁnd the location of a particular ch aracter
or substring in a string. For example, user names and passwor ds are
sometimes stored in a single string in which the name and pass word
are separated from each other by a special character, such as a colon
(username:password ). In order to get the name or password from such
a string, it is convenient to have methods that will search th e string and
report the index of the colon character.
SECTION 7.3 •Finding Things Within a String 317
TheindexOf() andlastIndexOf() methods are instance methods
that can be used to ﬁnd the index position of a character or a su bstring
within a String . There are several versions of each:
☛ ✟
public i n t indexOf ( i n t c h a r a c t e r ) ;
public i n t indexOf ( i n t character , i n t s t a r t i n g I n d e x ) ;
public i n t indexOf ( S t r i n g s t r i n g ) ;
public i n t indexOf ( S t r i n g s t r i n g , i n t s t a r t i n g I n d e x ) ;
public i n t lastIndexOf ( i n t c h a r a c t e r ) ;
public i n t lastIndexOf ( i n t character , i n t s t a r t i n g I n d e x ) ;
public i n t lastIndexOf ( S t r i n g s t r i n g ) ;
public i n t lastIndexOf ( S t r i n g s t r i n g , i n t s t a r t i n g I n d e x ) ;
✡ ✠
TheindexOf() method searches from left to right within a String for
either a character or a substring. The lastIndexOf() method searches
from right to left for a character or substring. To illustrat e, suppose we
have declared the following String s:
☛ ✟
S t r i n g s t r i n g 1 = ””;
S t r i n g s t r i n g 2 = ” Hello ” ;
S t r i n g s t r i n g 3 = ”World” ;
S t r i n g s t r i n g 4 = s t r i n g 2 + ” ” + s t r i n g 3 ;
✡ ✠
Recalling that String s are indexed starting at 0, searching for oin the
various strings gives the following results:
☛ ✟
s t r i n g 1 . indexOf ( ’ o ’) ==>−1 s t r i n g 1 . lastIndexOf ( ’ o ’) ==>−1
s t r i n g 2 . indexOf ( ’ o ’) ==> 4 s t r i n g 2 . lastIndexOf ( ’ o ’) ==>
4
s t r i n g 3 . indexOf ( ’ o ’) ==> 1 s t r i n g 3 . lastIndexOf ( ’ o ’) ==>
1
s t r i n g 4 . indexOf ( ’ o ’) ==> 4 s t r i n g 4 . lastIndexOf ( ’ o ’) ==>
7
✡ ✠
Because string1 is the empty string, “”, it does not contain the let- Sentinel return value
tero. Therefore, indexOf() returns−1, a value that cannot be a valid
index for a String . This convention is followed in indexOf() and
lastIndexOf() . Because string2 andstring3 each contain only one
occurrence of the letter o, bothindexOf() andlastIndexOf() return
the same value when used on these String s. Because string4 contains
two occurrences of o,indexOf() andlastIndexOf() return different
values in this case. As Figure 7.7 shows, the ﬁrst oin “Hello World” oc-012345678910Indexes
H e l l o Wo r l d
FIGURE 7.7 The indexing of the
“Hello World” string.curs at index 4, the value returned by indexOf() . The second ooccurs at
index 7, which is the value returned by lastIndexOf() .
By default, the single-parameter versions of indexOf() andlast-
IndexOf() start their searches at their respective (left or right) end s of
the string. The two-parameter versions of these methods all ow you to
318 CHAPTER 7 •Strings and String Processing
specify both the direction and starting point of the search. The second
parameter speciﬁes the starting index. Consider these exam ples:
☛ ✟
s t r i n g 4 . indexOf ( ’ o ’, 5) == >7
s t r i n g 4 . lastIndexOf ( ’ o ’, 5) == >4
✡ ✠
If we start searching in both cases at index 5, then indexOf() will miss
theothat occurs at index 4. The ﬁrst oit ﬁnds will be the one at index 7.
Similarly, lastIndexOf() will miss the othat occurs at index 7 and will
ﬁnd the othat occurs at index 4.
TheindexOf() andlastIndexOf() methods can also be used to
ﬁnd substrings:
☛ ✟
s t r i n g 1 . indexOf ( ” or ” ) ==>−1 s t r i n g 1 . lastIndexOf ( ” or ” ) ==>−1
s t r i n g 2 . indexOf ( ” or ” ) ==>−1 s t r i n g 2 . lastIndexOf ( ” or ” ) ==>−1
s t r i n g 3 . indexOf ( ” or ” ) ==> 1 s t r i n g 3 . lastIndexOf ( ” or ” ) ==> 1
s t r i n g 4 . indexOf ( ” or ” ) ==> 7 s t r i n g 4 . lastIndexOf ( ” or ” ) ==> 7
✡ ✠
The substring “or” does not occur in either string1 orstring2 . It does
occur beginning at location 1 in string3 and beginning at location 7 in
string4 . For this collection of examples, it doesn’t matter whether we
search from left to right or right to left.
SELF-STUDY EXERCISES
EXERCISE 7.7 Suppose the String variable shas been initialized to
“mom.” Evaluate each of the following expressions:
a.s.indexOf("m"); b.s.indexOf("o"); c.s.indexOf("M");
EXERCISE 7.8 Evaluate the expressions given the String declaration
String s1 = "Java, Java, Java";
a.s1.length()
b.String.valueOf(s1.length())
c.s1.indexOf(’a’)
d.s1.lastIndexOf(’a’)
e.s1.indexOf("av")
f.s1.lastIndexOf("av")g.s1.indexOf(’a’, 5)
h.s1.lastIndexOf(’a’, 5)
i.s1.indexOf("av", s1.length() - 10)
j.s1.lastIndexOf("av",
s1.length() - 4)
k.s1.indexOf("a", s1.indexOf("va"))
EXERCISE 7.9 Evaluate the following expression:
☛ ✟
S t r i n g t r i c k y = ” abcdefg01234567 ” ;
t r i c k y . indexOf ( S t r i n g . valueOf ( t r i c k y . indexOf ( ” c ” ) ) ) ;
✡ ✠
7.4 Example: Keyword Search
One of the most widely used Web browser functions is the searc h utility.
You probably know how it works. You type in a keyword and click on a
button, and it returns with a list of Web pages that contain th e keyword.
Suppose you were writing a browser in Java. How would you imple -
ment this function? Of course, we don’t know yet how to read ﬁl es or
Web pages, and we won’t cover that until Chapter 11. But, for n ow, we
can write a method that will search a string for all occurrenc es of a given
SECTION 7.4 •Example: Keyword Search 319
keyword. That’s at least part of the task that the browser’s s earch engine
would have to do.
So we want a method, keywordSearch() , that takes two String pa- Method design
rameters, one for the string that’s being searched, and the o ther repre-
senting the keyword. Let’s have the method return a String that lists
the number of keyword occurrences, followed by the index of e ach occur-
rence. For example, if we asked this method to ﬁnd all occurre nces of isin
“This is a test,” it should return the string “2: 2 5” because t here are two
occurrences of is, one starting at index 2 and the other at index 5 in the
string.
The algorithm for this method will require a loop, because we want
to know the location of every occurrence of the keyword in the string.
One way to do this would be to use the indexOf() method to search for
the location of substrings in the string. If it ﬁnds the keywor d at indexAlgorithm design
N, it should record that location and then continue searching for more
occurrences starting at index N+1in the string. It should continue in this
way until there are no more occurrences.
☛ ✟
Suppose S i s our s t r i n g and K i s the keyword .
I n i t i a l i z e a counter v a r i a b l e and r e s u l t s t r i n g .
Set Ptr to the indexOf ( ) the f i r s t occurrence of K in S .
While ( Ptr != −1)
Increment the counter
I n s e r t Ptr i n t o the r e s u l t s t r i n g
Set Ptr to the next l o c a t i o n of the keyword in S
I n s e r t the count i n t o the r e s u l t s t r i n g
Return the r e s u l t s t r i n g as a S t r i n g
✡ ✠
As this pseudocode shows, the algorithm uses a while loop wit h asentinel Implementation
bound . The algorithm terminates when the indexOf() method returns a
−1, indicating that there are no more occurrences of the keywor d in the
string.
Translating the pseudocode into Java gives us the method sho wn in Fig-
ure 7.8. Note how string concatenation is used to build the resultStr .
Each time an occurrence is found, its location ( ptr) is concatenated to
the right-hand side of the resultStr . When the loop terminates, the
number of occurrences ( count ) is concatenated to the left-hand side of
theresultStr .
Testing and Debugging
What test data should we use for the keywordSearch() method? One What test data do we need?
important consideration in this case is to test that the meth od works for
all possible locations of the keyword within the string. Thu s, the method
should be tested on strings that contain keyword occurrence s at the begin-
ning, middle, and end of the string. We should also test the me thod with
a string that doesn’t contain the keyword. Such tests will he lp verify that
the loop will terminate properly in all cases. Given these co nsiderations,
Table 7.1 shows the tests that were made. As you can see from th ese re-
sults, the method did produce the expected outcomes. While th ese tests
320 CHAPTER 7 •Strings and String Processing
☛ ✟
/∗∗
∗P r e : s a n d k e y w o r d a r e a n y S t r i n g s
∗P o s t : k e y w o r d S e a r c h ( ) r e t u r n s a S t r i n g c o n t a i n i n g t h e
∗ n u m b e r o f o c c u r r e n c e s o f k e y w o r d i n s , f o l l o w e d
∗ b y t h e s t a r t i n g l o c a t i o n o f e a c h o c c u r r e n c e
∗/
public S t r i n g keywordSearch ( S t r i n g s , S t r i n g keyword ) {
S t r i n g r e s u l t S t r = ””;
i n t count = 0 ;
i n t ptr = s . indexOf ( keyword ) ;
while ( ptr != −1){
++count ;
r e s u l t S t r = r e s u l t S t r + ptr + ” ” ;
ptr = s . indexOf ( keyword , ptr + 1 ) ; // N e x t o c c u r r e n c e
}
r e s u l t S t r = count + ” : ” + r e s u l t S t r ; // I n s e r t t h e c o u n t
return r e s u l t S t r ;
// R e t u r n a s a S t r i n g
}// k e y w o r d S e a r c h ( )
✡ ✠
Figure 7.8: The keywordSearch() method.
do not guarantee its correctness, they provide considerabl e evidence that
the algorithm works correctly.
TABLE 7.1 Testing the keywordSearch() method.
Test Performed Expected Result
keywordSearch("this is a test","is") 2: 2 5
keywordSearch("able was i ere i saw elba","a") 4: 0 6 18 24
keywordSearch("this is a test","taste") 0:
JAVA EFFECTIVE DESIGN Test Data. In designing test data to
check the correctness of a string searching algorithm, it’s important to
use data that test all possible outcomes.
7.5 From the Java Library: java.lang.StringBuffer
java.sun.com/j2se/1.5.0/docs/api/ONE PROBLEM with the keywordSearch() method is that it is not
very efﬁcient because a String in Java is a read-only object. This means
that once it has been instantiated, a String cannot be changed. You
cannot insert new characters or delete existing characters from it.
JAVA LANGUAGE RULE Strings Are Immutable. Once
instantiated, a Java String cannot be altered in any way.
Given this fact, how is it possible that the resultStr in thekeyword-
Search() ends up with the correct value? he answer is that every time
SECTION 7.5 •From the Java Library: java.lang.StringBuffer 321
we assign a new value to resultStr , Java has to create a new String
object. Figure 7.9 illustrates the process. Thus, given the s tatement
☛ ✟
r e s u l t S t r = r e s u l t S t r + ptr + ” ” ;
✡ ✠
Java will evaluate the right-hand side, which creates a new String object
whose value would be the concatenation of the right-hand-si de elements,
resultStr + ptr + " " (Fig. 7.9a). It would then assign the new ob-
ject as the new referent of resultStr (Fig. 7.9b). This turns the previous
referent of resultStr into an orphan object —that is, into an object that
no longer has any references to it. Java will eventually disp ose of these
orphaned objects, removing them from memory in a process know n as
garbage collection . However, creating and disposing of objects is a task
that consumes the computer’s time.
The fact that this assignment statement occurs within a loop means
that several new objects are created and later garbage collec ted. Because
object creation is a relatively time-consuming and memory-c onsuming
operation, this algorithm is somewhat wasteful of Java’s re sources.value =" "
count =0: String
: String : String: String
value ="4 "
count =2
value =""
count =0value ="4 "
count =2resultStr =resultStr +ptr+" "
(b) After assignment(Orphan object)(a) Before assignment
resultStr
FIGURE 7.9 Evaluating
resultStr = resultStr + ptr
+ " " creates an orphan object that
must be garbage collected.Of course, except for the inefﬁciency of doing it this way, no real harm
is done by this algorithm used in the keywordSearch() method. Java’s
garbage collector will automatically reclaim the memory us ed by the or-
phaned object. However, this algorithm does consume more of Ja va’s
resources than other algorithms we might use.
JAVA LANGUAGE RULE Automatic Garbage Collection. An
object that has no reference to it can no longer be used in a prog ram.
Therefore, Java will automatically get rid of it. This is kno wn as
garbage collection .
A more efﬁcient way to write the keywordSearch() method would
make use of a StringBuffer to store and construct the resultStr .
Like the String class, the java.lang.StringBuffer class also rep-
resents a string of characters. However, unlike the String class, a
StringBuffer can be modiﬁed, and it can grow and shrink in length
as necessary. As Figure 7.10 shows, the StringBuffer class contains
Choosing the appropriate data
structureseveral of the same kind of methods as the String class, for exam-
ple,charAt() andlength() . But it also contains methods that allow
characters and other types of data to be inserted into a strin g, such as
append() ,insert() , andsetCharAt() . Most string-processing algo-
rithms use StringBuffer s instead of String s as their preferred data
structure.
JAVA PROGRAMMING TIP StringBuffer. AStringBuffer
should be used instead of a String for any task that involves
modifying a string.
TheStringBuffer class provides several methods that are useful for
string processing. The constructor method, StringBuffer(String) ,
makes it easy to convert a String into aStringBuffer . Similarly, once
322 CHAPTER 7 •Strings and String Processing
you are done processing the buffer, the toString() method makes it
easy to convert a StringBuffer back into a String .
The typical way to use a StringBuffer is shown in the following
revised version of the keywordSearch() method:
☛ ✟
public S t r i n g keywordSearch ( S t r i n g s , S t r i n g keyword ) {
// C r e a t e S t r i n g B u f f e r
S t r i n g B u f f e r r e s u l t S t r = new S t r i n g B u f f e r ( ) ;
i n t count = 0 ;
i n t ptr = s . indexOf ( keyword ) ;
while ( ptr != −1){
++count ;
r e s u l t S t r . append ( ptr + ” ” ) ; // A p p e n d t o b u f f e r
ptr = s . indexOf ( keyword , ptr + 1 ) ;
}
r e s u l t S t r . i n s e r t ( 0 , count + ” : ” ) ;
return r e s u l t S t r . t o S t r i n g ( ) ; // C o n v e r t b u f f e r t o S t r i n g
}// k e y w o r d S e a r c h ( )
✡ ✠
We declare resultStr as aStringBuffer instead of a String . Then,+toString() : StringObject
+StringBuffer()
+StringBuffer(in s : String)
+append(in data : <type>)
+charAt(in n : int) : char
+insert(in n : int, in data : <type>)
+length() : int
+setCharAt(in n : int, in ch : char)
+toString() : StringStringBuffer
FIGURE 7.10 The
java.lang.StringBuffer class.instead of concatenating the ptr and reassigning the resultStr , we
append() theptr to theresultStr for each occurrence of a keyword.
Similarly, after the loop exits, we insert() thecount at the front (index
0) of the resultStr . Finally, we convert resultStr into aString by
using the toString() method before returning the method’s result.
One advantage of the StringBuffer class is that there are several
versions of its insert() andappend() methods. These make it pos-
sible to insert any type of data— int,double ,Object , and so on—into a
StringBuffer . The method itself takes care of converting the data into
a string for us.
To summarize, String objects in Java are immutable . So when a Strings are immutable
String is “modiﬁed,” this really means that a new String object is cre-
ated and the old String object must be garbage collected. This is some-
what inefﬁcient, especially if done repeatedly within a loo p. To avoid
these inefﬁciencies, use a StringBuffer instead of a String in such
contexts.
7.6 Retrieving Parts of Strings
Programmers often need to retrieve an individual character or a part of a
string from a string, as, for example, in a word processing pr ogram when
a part of a string is copied or deleted. In this section we look a t methods
that help us with these kinds of tasks.
ThecharAt(int index) method is a String instance method that
can be used to retrieve the character stored at a certain inde x. The several
SECTION 7.6 •Retrieving Parts of Strings 323
varieties of the substring() method can be used to retrieve a substring
of characters from a String . These methods are deﬁned as follows:
☛ ✟
public char charAt ( i n t index )
public S t r i n g substring ( i n t s t a r t I n d e x )
public S t r i n g substring ( i n t s t a r t I n d e x , i n t endIndex )
✡ ✠
ThecharAt() method returns the character located at the index supplied
as its parameter. Thus, str.charAt(0) retrieves the ﬁrst character in
str, while str.charAt(str.length()-1) retrieves the last character.
Thesubstring() methods work in a similar way, except that you
need to specify both the starting and the ending index of the s ub-
string you wish to retrieve. The ﬁrst version of substring(int
startIndex) takes a single parameter and returns a String consisting
of all the characters beginning with startIndex and continuing up to
the end of the String . For example, if the str is “HelloWorld”, then
str.substring(5) would return “World” and str.substring(3)
would return “loWorld”:
☛ ✟
S t r i n g s t r = ”HelloWorld” ;
s t r . substring ( 5 ) == >”World”
s t r . substring ( 3 ) == >”loWorld”
✡ ✠
Thesubstring(int, int) version requires that you specify both the
starting and ending index of the substring. The second index always
points to the character that is one beyond the last character in theString
you want to retrieve. For example,
☛ ✟
// INDEX : 0123456789
S t r i n g s t r = ”HelloWorld” ;
s t r . substring ( 5 , 7 ) == >”Wo”
s t r . substring ( 0 , 5 ) == >” Hello ”
s t r . substring ( 5 , s t r . length ( ) ) == >”World”
✡ ✠
Note here that when we want to retrieve “Wo” from str, we specify its
substring as indexes 5 and 7; the 7 points to the character just beyond
“Wo.” Similarly, substring(0,5) , picks out the ﬁrst ﬁve characters
(“Hello”). In the third example, the length() method speciﬁes the sub-
string beginning at index 5 and extending to the end of the str ing. This is
equivalent to str.substring(5) :
☛ ✟
// INDEX : 0123456789
S t r i n g s t r = ”HelloWorld” ;
s t r . substring ( 5 , s t r . length ( ) ) == >”World”
s t r . substring ( 5 ) == >”World”
✡ ✠
The fact that the second parameter in substring() refers to the char-
acter one beyond the desired substring may seem a bit confusi ng at ﬁrst,
but it is actually a very useful way to designate a substring. For example,
many string-processing problems have to do with retrieving substrings
324 CHAPTER 7 •Strings and String Processing
from a delimited string , which is a string that contains special characters
that separate the string into certain substrings. For examp le, consider the Delimited strings
string “substring1:substring2,” in which the delimiter is the colon, ’:’.
The following code retrieves the substring preceding the de limiter:
☛ ✟
S t r i n g s t r = ” substring1 : substring2 ” ;
i n t n = s t r . indexOf ( ’ : ’) ;
s t r . substring ( 0 , n ) == >” substring1 ”
✡ ✠
Thus, by making the second index of substring() refer to the char-
acter one beyond the last character in the desired substring , we can use
indexOf() andsubstring() together to process delimited strings.
Note that it is not necessary to use a temporary variable nto store the
index of the delimiter, because the two method calls can be ne sted:
☛ ✟
S t r i n g s t r = ” substring1 : substring2 ” ;
s t r . substring ( 0 , s t r . indexOf ( ’ : ’) ) ==>” substring1 ”
✡ ✠
JAVA DEBUGGING TIP substring(int p1, int p2) .Don’t
forget that the second parameter in the substring() methods refers
to the character just past the last character in the substring .
SELF-STUDY EXERCISES
EXERCISE 7.10 Given the String declaration
☛ ✟
S t r i n g s = ” abcdefghijklmnopqrstuvwxyz ” ;
✡ ✠
evaluate each of the following expressions:
a.s.substring(20)
b.s.substring(1, 5)
c.s.substring(23)d.s.substring(23, 25)
e.s.substring(s.indexOf(’x’))
EXERCISE 7.11 Given the preceding declaration of s, evaluate each of
the following expressions:
a.s.substring(20, s.length())
b.s.substring(s.indexOf(’b’), s.indexOf(’f’))
c.s.substring(s.indexOf("xy"))
d.s.substring(s.indexOf(s.charAt(23)))
e.s.substring(s.length() - 3)
SECTION 7.7 •Example: Processing Names and Passwords 325
7.7 Example: Processing Names and Passwords
Many computer systems store user names and passwords as deli mited
strings, such as
☛ ✟
smith : bg1s5xxx
mccarthy : 2 f f o 9 0 0 s s i
cho : biff4534ddee4w
✡ ✠
Obviously, if the system is going to process passwords, it ne eds some way
to take apart these name-password pairs.
Let’s write methods to help perform this task. The ﬁrst metho d will
be passed a name-password pair and will return the name. The s econd
method will be passed a name-password pair and will return th e pass-
word. In both cases, the method takes a single String parameter and
returns a String result:Algorithm design
☛ ✟
S t r i n g getName ( S t r i n g s t r ) ;
S t r i n g getPassword ( S t r i n g s t r ) ;
✡ ✠
To solve this problem we can make use of two String methods. We use
theindexOf() method to ﬁnd the location of the delimiter —which is the
colon, “ :”—in the name-password pair and then we use substring() to
take the substring occurring before or after the delimiter. It may be easier
to see this if we take a particular example:
☛ ✟
INDEX : 1 2
INDEX : 012345678901234567890
jones : b34rdffg12 // ( 1 )
cho : r t f 5 4 6 // ( 2 )
✡ ✠
In the ﬁrst case, the delimiter occurs at index position 5 in th e string.
Therefore, to take the name substring, we would use substring(0,5) .
To take the password substring, we would use substring(6) . Of
course, in the general case, we would use variables to indica te the position
of the delimiter, as in the following methods:
☛ ✟
public s t a t i c S t r i n g getName ( S t r i n g s t r ) {
i n t posColon = s t r . indexOf ( ’ : ’) ; // F i n d t h e d e l i m i t e r
S t r i n g r e s u l t = s t r . substring ( 0 , posColon ) ; // G e t n a m e
return r e s u l t ;
}
public s t a t i c S t r i n g getPassword ( S t r i n g s t r ) {
i n t posColon = s t r . indexOf ( ’ : ’) ; // F i n d t h e d e l i m i t e r
S t r i n g r e s u l t = s t r . substring ( posColon + 1 ) ; // G e t p a s s w d
return r e s u l t ;
}
✡ ✠
326 CHAPTER 7 •Strings and String Processing
Note in both of these cases we have used local variables, posColon and
result , to store the intermediate results of the computation—that i s, the
index of the “ :” and the name or password substring.
An alternative way to code these operations would be to use ne sted
method calls to reduce the code to a single line:
☛ ✟
return s t r . substring ( 0 , s t r . indexOf ( ’ : ’) ) ;
✡ ✠
In this line, the result of str.indexOf(’:’) is passed immediately as
the second argument to str.substring() . This version dispenses with
the need for additional variables. And the result in this cas e is not unrea-
sonably complicated. But whenever you are faced with a trade -off of this
sort—nesting versus additional variables—you should opt for the style
that will be easier to read and understand.
JAVA EFFECTIVE DESIGN Nested Method Calls. Nested method
calls are ﬁne as long as there are not too many levels of nestin g. The
goal should be to produce code that is easy to read and underst and.
7.8 Processing Each Character in a String
Many string-processing applications require you to proces s each character
in a string. For example, to encrypt the string “hello” into “ jgnnq”, we
have to go through each letter of the string and change each ch aracter to
its substitute.
These types of algorithms usually involve a counting loop bo unded by
the length of the string. Recall that the length() method determines Counting loop algorithm
the number of characters in a String and that strings are zero indexed.
This means that the ﬁrst character is at index 0, and the last c haracter is
at index length()-1 . For example, to print each character in a string on
a separate line, we would step through the string from its ﬁrs t to its last
character and print each character::
☛ ✟
// P r e c o n d i t i o n : s t r i s n o t n u l l
// P o s t c o n d i t i o n : t h e l e t t e r s i n s t r w i l l h a v e b e e n p r i n t e d
public void p r i n t L e t t e r s ( S t r i n g s t r ) {
for (i n t k = 0 ; k <s t r . length ( ) ; k++) // F o r e a c h c h a r
System . out . p r i n t l n ( s t r . charAt ( k ) ) ; // P r i n t i t
}
✡ ✠
Note that our loop bound is k < str.length() , since the index of Counting bound
the last character of any String islength()-1 . Note also the use of
str.charAt(k) to retrieve the kth character in str on each iteration of
the loop.
Note the use of pre- and postconditions in the method’s comme nt
block. The precondition states that str has been properly initialized—
that is, it is not null . The postcondition merely states the expected
behavior of the method.
SECTION 7.8 •Processing Each Character in a String 327
7.8.1 Off-by-One Error
A frequent error in coding counter-controlled loops is know n as the off-
by-one error , which can occur in many different ways. For example, if
we had coded the loop boundary condition as k <= str.length() ,
this would cause an off-by-one error, because the last chara cter Off-by-one error
instr is at location length()-1 . This would lead to a Java
IndexOutOfBoundsException , which would be reported as soon as
the program executed this statement.
The only way to avoid off-by-one errors is to check your loop b ounds
whenever you code a loop. Always make sure you have the loop co unter’s
initial and ﬁnal values correct.
JAVA DEBUGGING TIP Off-by-One Errors. Loops should be
carefully checked to make sure they don’t commit an off-by-o ne error.
During program testing, develop data that tests the loop var iable’s
initial and ﬁnal values.
7.8.2 Example: Counting Characters
As another example of an algorithm that processes each chara cter in a
string, consider the problem of computing the frequency of t he letters in
a given document. Certain text analysis programs, such as pr ograms that
analyze encrypted data and spam ﬁlters, perform this type of function.
ThecountChar() method will count the number of occurrences of
any particular character in a String (Fig. 7.11). This method takes two Method design
parameters: a String parameter that stores the string being searched and
achar parameter that stores the character being counted.
☛ ✟
// P r e c o n d i t i o n : N e i t h e r s t r n o r c h a r e n u l l
// P o s t c o n d i t i o n : c o u n t c h a r ( ) == t h e n u m b e r o f c h i n s t r
public i n t countChar ( S t r i n g s t r , char ch ){
i n t counter = 0 ; // I n i t i a l i z e a c o u n t e r
for (i n t k = 0 ; k <s t r . length ( ) ; k++) // F o r e a c h c h a r
i f( s t r . charAt ( k ) == ch ) // I f i t ’ s a c h
counter ++; // c o u n t i t
return counter ; // R e t u r n t h e r e s u l t
}
✡ ✠
Figure 7.11: A method to count the occurrence of a particular character in
a string.
Begin by initializing the local variable, counter , to 0. As in the pre- Algorithm design
vious example, the for loop here will iterate through each character of
theString —from 0 to length()-1 . On each iteration a check is made
to see if the character in the kth position ( str.charAt(k) ) is the char-
acter being counted. If so, counter is incremented. The method ends
by returning counter , which, when the method completes, will store an
integer representing the number of ch’s instr.
328 CHAPTER 7 •Strings and String Processing
7.8.3 Example: Reversing a String
Another interesting method that processes each character i n a string is the
reverse() method. This is a method that reverses the letters in a string .
For example, the reverse of "java" is"avaj" .
The algorithm for the reverse() method should use a simple
counting loop to reverse the letters in its String parameter. In this case, Algorithm design
however, we can process the string from right to left, beginn ing at its last
character and ending with its ﬁrst character. That way we can just append
each character, left to right, in the result string:
☛ ✟
/∗
∗P r e : s i s a n y n o n n u l l s t r i n g
∗P o s t : s i s r e t u r n e d i n r e v e r s e o r d e r
∗/
public S t r i n g reverse ( S t r i n g s ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;
for (i n t k = s . length () −1; k>= 0 ; k−−){
r e s u l t . append ( s . charAt ( k ) ) ;
}// f o r
return r e s u l t . t o S t r i n g ( ) ;
}// r e v e r s e ( )
✡ ✠
Note that as in the other string-manipulation algorithms—fo r exam-
ple,keywordSearch() —we should us a StringBuffer to store the
method’s result. Thus we declare the result StringBuffer at the be-
ginning of the method and convert it back into a String at the end of the
method.
JAVA PROGRAMMING TIP Changing Each Character in a
String. Algorithms that require you to alter a string should use a
StringBuffer to store the result.
7.8.4 Example: Capitalizing the First Letter
Another string manipulation method is the capitalize() method,
which returns a String whose initial letter is capitalized but whose Algorithm design
other letters are lowercase – for example, “Hello”. We use the static
toUpperCase() andtoLowerCase() methods from the Character
class to convert individual letters. We could also have used the methods
of the same name that we wrote in Section 5.8. The algorithm co nverts
SECTION 7.8 •Processing Each Character in a String 329
the ﬁrst letter to upper case and then loops through the remai ning letters
converting each to lowercase:
☛ ✟
/∗
∗P r e : s i s a n y n o n n u l l s t r i n g
∗P o s t : s i s r e t u r n e d w i t h o n l y i t s f i r s t l e t t e r c a p i t a l i z e d
∗/
public S t r i n g c a p i t a l i z e ( S t r i n g s ) {
i f( s . length ( ) == 0) // S p e c i a l c a s e : e m p t y s t r i n g
return s ;
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;
r e s u l t . append ( Character . toUpperCase ( s . charAt ( 0 ) ) ) ;
// C o n v e r t t h e f i r s t l e t t e r
for (i n t k = 1 ; k <s . length ( ) ; k++) {// And t h e r e s t
r e s u l t . append ( Character . toLowerCase ( s . charAt ( k ) ) ) ;
}// f o r
return r e s u l t . t o S t r i n g ( ) ;
}// c a p i t a l i z e ( )
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 7.12 Write a Java program to test the methods described in
this section. Organize the methods themselves into a single class, named
StringProcessor , and design a second class to serve as the user inter-
face. Because these methods are similar to the utility metho ds of the Math
class, it would be useful to declare them static. The user int erface should
prompt the user to input a string and should then print out the result of
passing that string to each of the methods we developed.
EXERCISE 7.13 Add a method to the StringProcessor class that
will remove all blanks from a string. It should take a String parameter
and should return a String result.
7.8.5 Miscellaneous String Methods
In addition to the several String class methods we have discussed—
valueOf() ,equals() ,indexOf() ,lastIndexOf() ,charAt() ,
substring() —Table 7.2 shows some of the other useful methods in the
String class. Note that because of what we said about the read-only n a-
ture of String s, methods such as toUpperCase() ,toLowerCase() ,
andtrim() do not change their string. Instead they produce a new
string. If you want to use one of these methods to convert a stri ng, you
must reassign its result back to the original string:
☛ ✟
S t r i n g s = new S t r i n g ( ” h e l l o world” ) ;
s = s . toUpperCase ( ) ; // s now e q u a l s ” HELLO WORLD ”
✡ ✠
330 CHAPTER 7 •Strings and String Processing
TABLE 7.2 Some useful String methods applied to the literal string ”Perfection.”
Method Signature Example
boolean endsWith(String suffix) "Perfection".endsWith( "tion") ⇒true
boolean startsWith(String prefix) "Perfection".startsW ith("Per") ⇒true
boolean startsWith(String prefix, int offset) "Perfectio n".startsWith("fect",3) ⇒true
String toUpperCase() "Perfection".toUpperCase() ⇒"PERFECTION"
String toLowerCase() "Perfection".toLowerCase() ⇒"perfection"
String trim() "Perfection".trim() ⇒"Perfection"
7.9 Comparing Strings
Comparing strings is another important task. For example, w hen a word
processor performs a search and replace operation, it needs to identify
strings in the text that match the target string.
Strings are compared according to their lexicographic order —that is, the
order of their characters. For the letters of the alphabet, l exicographic or-
der just means alphabetical order. Thus, acomes before band dcomes
after c. The string “hello” comes before “jello” because hcomes before jin
the alphabet.
For Java and other programming languages, the deﬁnition of l exico-
graphic order is extended to cover all the characters that ma ke up the
character set. We know, for example, that in Java’s Unicode c haracter set
the uppercase letters come before the lowercase letters (Ta ble 5.13). So, the
letter Hcomes before the letter hand the letter Zcomes before the letter a.
Lexicographic order can be extended to include strings of ch aracters. H precedes h
Thus, “Hello” precedes “hello” in lexicographic order becau se its ﬁrst let-
ter,H, precedes the ﬁrst letter, h, in “hello.” Similarly, the string “Zero”
comes before “aardvark,” because Zcomes before a. To determine lexico-
graphic order for strings, we must perform a character-by-c haracter com-
parison, starting at the ﬁrst character and proceeding left to right. As an
example, the following strings are arranged in lexicograph ic order:
☛ ✟
”” ” ! ” ”0” ”A” ”Andy” ”Z” ”Zero” ”a” ”an” ”and” ”andy” ”candy” ” zero ”
✡ ✠
SECTION 7.9 •Comparing Strings 331
We can deﬁne lexicographic order for strings as follows:
JAVA LANGUAGE RULE Lexicographic Order. For strings s1and
s2,s1precedes s2in lexicographic order if its ﬁrst character precedes
the ﬁrst character of s2. If their ﬁrst characters are equal, then s1
precedes s2if its second character precedes the second character of s2;
and so on. An empty string is handled as a special case, preced ing all
other strings.
Perhaps a more precise way to deﬁne lexicographic order is to deﬁne a
Java method:
☛ ✟
public boolean precedes ( S t r i n g s1 , S t r i n g s2 ) {
// P i c k s h o r t e r l e n g t h
i n t minlen = Math . min ( s1 . length ( ) , s2 . length ( ) ) ;
// F o r e a c h c h a r i n s h o r t e r s t r i n g }
for (i n t k =0; k <minlen ; k++) {
i f( s1 . charAt ( k ) != s2 . charAt ( k ) ) // I f c h a r s u n e q u a l
// r e t u r n t r u e i f s 1 ’ s c h a r p r e c e d e s s 2 ’ s
return s1 . charAt ( k ) <s2 . charAt ( k ) ;
}
// I f a l l c h a r a c t e r s s o f a r a r e e q u a l
// t h e n s 1 <s 2 i f i t i s s h o r t e r t h a n s 2
return s1 . length ( ) <s2 . length ( ) ;
}// p r e c e d e s ( ) }
✡ ✠
This method does a character-by-character comparison of th e two strings, Algorithm: Loop bound
proceeding left to right, starting at the ﬁrst character in b oth strings.
Itsfor loop uses a counting bound, which starts at kequal to zero
and counts up to the length of the shorter string. This is an im por-
tant point in designing this algorithm. If you don’t stop iter ating when
you get past the last character in a string, your program will generate a
StringIndexOutOfBounds exception. To prevent this error, we need to
use the shorter length as the loop bound.
Note that the loop will terminate early if it ﬁnds that the res pective
characters from s1and s2are unequal. In that case, s1precedes s2ifs1’skth
character precedes s2’s. If the loop terminates normally, that means that
all the characters compared were equal. In that case, the shor ter string
precedes the longer. For example, if the two strings were “al pha” and
“alphabet,” then the method would return true, because “alp ha” is shorter
than “alphabet.”
SELF-STUDY EXERCISES
EXERCISE 7.14 Arrange the following strings in lexicographic order:
☛ ✟
zero bath bin alpha Alpha Zero Zeroes a A z Z
✡ ✠
EXERCISE 7.15 Modify the precedes() method so that it will also
return true when s1and s2are equal—for example, when s1and s2are
both “hello”.
332 CHAPTER 7 •Strings and String Processing
7.9.1 Object Identity Versus Object Equality
Java provides several methods for comparing String s:
☛ ✟
public boolean equals ( Object anObject ) ; // O v e r r i d e s O b j e c t . e q u a l s ( )
public boolean equalsIgnoreCase ( S t r i n g anotherString ) ;
public i n t compareTo ( S t r i n g anotherString ) ;
✡ ✠
The ﬁrst comparison method, equals() , overrides the Object.equals()
method. Two String s are equal if they have the exact same letters in the
exact same order. Thus, for the following declarations, Equality vs. identity
☛ ✟
S t r i n g s1 = ” h e l l o ” ;
S t r i n g s2 = ” Hello ” ;
✡ ✠
s1.equals(s2) isfalse , buts1.equals("hello") istrue .
You have to be careful when using Java’s equals() method. Accord-
ing to the default deﬁnition of equals() , deﬁned in the Object class,
“equals” means “identical.” Two Object s are equal only if their names
are references to the same object.Venus The morning star
FIGURE 7.12 Venus is the morning
star, so “Venus” and “the morning
star” are two references to the same
object.This is like the old story of the morning star and the evening s tar,
which were thought to be different objects before it was disco vered that
both were just the planet Venus. After the discovery, it was cl ear that
“the morning star” and “the evening star” and “Venus” were jus t three
different references to one and the same object (Fig. 7.12).
We can create an analogous situation in Java by using the foll owing
JButton deﬁnitions:
☛ ✟
JButton b1 = new Button ( ”a” ) ;
JButton b2 = new Button ( ”a” ) ;
JButton b3 = b2 ;
✡ ✠
Given these three declarations, b1.equals(b2) andb1.equals(b3)
would be false , butb2.equals(b3) would be true because b2and b3
are just two names for the same object (Fig. 7.13). So, in this ca se, “equals”a
JButton b1 =new JButton("a");
JButton b2 =new JButton("a");
JButton b3 =b2;ab3b2 b1 (References)
(Labeled buttons)
FIGURE 7.13 For most objects,
equality means identity. JButtons b2
andb3are identical (and, hence,
equal), but JButtons b1andb2are
not identical (and, hence, unequal).really means “identical.”
Moreover, in Java, when it is used to compare two objects, the
equality operator (==) is interpreted in the same way as the d efault
Object.equals() method. So, it really means object identity. Thus,
b1 == b2 would be false , because b1andb2are different objects, but
b2 == b3 would be true because b2andb3refer to the same object.
These points are illustrated in the program shown in Figure 7 .14. This
program uses methods isEquals() andisIdentical() to perform
SECTION 7.9 •Comparing Strings 333
☛ ✟
import java . awt . ∗;
public c l a s s TestEquals {
s t a t i c Button b1 = new Button ( ”a” ) ;
s t a t i c Button b2 = new Button ( ”b” ) ;
s t a t i c Button b3 = b2 ;
private s t a t i c void isEqual ( Object o1 , Object o2 ) {
i f( o1 . equals ( o2 ) )
System . out . p r i n t l n ( o1 . t o S t r i n g ( ) + ” equals ” + o2 . t o S t r i n g ( ) ) ;
else
System . out . p r i n t l n ( o1 . t o S t r i n g ( ) + ” does NOT equal ” +
o2 . t o S t r i n g ( ) ) ;
}// i s E q u a l ( )
private s t a t i c void i s I d e n t i c a l ( Object o1 , Object o2 ) {
i f( o1 == o2 )
System . out . p r i n t l n ( o1 . t o S t r i n g ( ) + ” i s i d e n t i c a l to ” +
o2 . t o S t r i n g ( ) ) ;
else
System . out . p r i n t l n ( o1 . t o S t r i n g ( ) + ” i s NOT i d e n t i c a l to ” +
o2 . t o S t r i n g ( ) ) ;
}// i s I d e n t i c a l ( )
public s t a t i c void main ( S t r i n g argv [ ] ) {
isEqual ( b1 , b2 ) ; // n o t e q u a l
isEqual ( b1 , b3 ) ; // n o t e q u a l
isEqual ( b2 , b3 ) ; // e q u a l
i s I d e n t i c a l ( b1 , b2 ) ; // n o t i d e n t i c a l
i s I d e n t i c a l ( b1 , b3 ) ; // n o t i d e n t i c a l
i s I d e n t i c a l ( b2 , b3 ) ; // i d e n t i c a l
}// m a i n ( )
}// T e s t E q u a l s
✡ ✠
Figure 7.14: The TestEquals program tests Java’s default equals()
method, which is deﬁned in the Object class.
the comparisons and print the results. This program will pro duce the
following output:
☛ ✟
java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label =a ]
does NOT equal java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid ,label =b ]
java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label =a ]
does NOT equal java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid ,label =b ]
java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , label =b ]
equals java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , label =b ]
java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label =a ]
i s NOT i d e n t i c a l to java . awt . Button [ button1 , 0 , 0 , 0 x0 , inv alid , label =b ]
java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label =a ]
i s NOT i d e n t i c a l to java . awt . Button [ button1 , 0 , 0 , 0 x0 , inv alid , label =b ]
java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , label =b ]
i s i d e n t i c a l to java . awt . Button [ button1 , 0 , 0 , 0 x0 , invali d ,label =b ]
✡ ✠
334 CHAPTER 7 •Strings and String Processing
7.9.2 String Identity Versus String Equality
In comparing Java String s, we must be careful to distinguish between
object identity and string equality. Thus, consider the foll owing declara-
tions, which create the situation shown in Figure 7.15.
Figure 7.15: For String objects,
equality and identity are differ-
ent. Two distinct (nonidentical)
String objects are equal if they
store the same string value. So
s1, s2, s4, s5, ands6are
equal. Strings s1ands4are iden-
tical, and so are strings s5ands6.String s1 =new String ("hello");
String s2 =new String ("hello");
String s3 =new String ("Hello");
String s4 =s1;
String s5 ="hello";
String s6 ="hello";value ="hello"
count =5: String
value ="hello"
count =5: String
value ="hello"
count =5: String
value ="Hello"
count =5: String
value ="Hello"
count =5: String"Hello" "hello" s5 s6 s1 s4 s2
s3
☛ ✟
S t r i n g s1 = new S t r i n g ( ” h e l l o ” ) ;
S t r i n g s2 = new S t r i n g ( ” h e l l o ” ) ;
S t r i n g s3 = new S t r i n g ( ” Hello ” ) ;
S t r i n g s4 = s1 ; // s 1 a n d s 4 a r e now i d e n t i c a l
S t r i n g s5 = ” h e l l o ” ;
S t r i n g s6 = ” h e l l o ” ;
✡ ✠
Given these declarations, we would get the following result s if we com-Equality vs. identity
pare the equality of the String s:
☛ ✟
s1 . equals ( s2 ) == >true s1 . equalsIgnoreCase ( s3 ) == >true
s1 . equals ( s3 ) == >f a l s e s1 . equals ( s5 ) == >true
s1 . equals ( s4 ) == >true s1 . equals ( s6 ) == >true
✡ ✠
and the following results if we compare their identity:
☛ ✟
s1 == s2 == >f a l s e s1 == s3 == >f a l s e
s1 == s4 == >true s1 == s5 == >f a l s e
s5 == s6 == >true
✡ ✠
The only true identities among these String s are s1and s4, and s5and s6.
In the case of s5and s6, both are just references to the literal string, “hello”,
as we described in Section 7.2. The program in Figure 7.16 ill ustrates these
points.
SELF-STUDY EXERCISES
EXERCISE 7.16 Given the String declarations,
☛ ✟
S t r i n g s1 = ” java ” , s2 = ” java ” , s3 = ” Java ” ;
S t r i n g s4 = new S t r i n g ( s2 ) ;
S t r i n g s5 = new S t r i n g ( ” java ” ) ;
✡ ✠
evaluate the following expressions:
SECTION 7.9 •Comparing Strings 335
☛ ✟
import java . awt . ∗;
public c l a s s TestStringEquals {
s t a t i c S t r i n g s1 = new S t r i n g ( ” h e l l o ” ) ; // s 1 a n d s 2 a r e e q u a l , n o t i d e n t i c a l
s t a t i c S t r i n g s2 = new S t r i n g ( ” h e l l o ” ) ;
s t a t i c S t r i n g s3 = new S t r i n g ( ” Hello ” ) ; // s 1 a n d s 3 a r e n o t e q u a l
s t a t i c S t r i n g s4 = s1 ; // s 1 a n d s 4 a r e i d e n t i c a l
s t a t i c S t r i n g s5 = ” h e l l o ” ; // s 1 a n d s 5 a r e n o t i d e n t i c a l
s t a t i c S t r i n g s6 = ” h e l l o ” ; // s 5 a n d s 6 a r e i d e n t i c a l
private s t a t i c void t e s t E q u a l ( S t r i n g s t r 1 , S t r i n g s t r 2 ) {
i f( s t r 1 . equals ( s t r 2 ) )
System . out . p r i n t l n ( s t r 1 + ” equals ” + s t r 2 ) ;
else
System . out . p r i n t l n ( s t r 1 + ” does not equal ” + s t r 2 ) ;
}// t e s t E q u a l ( )
private s t a t i c void t e s t I d e n t i c a l ( S t r i n g s t r 1 , S t r i n g s t r 2 ) {
i f( s t r 1 == s t r 2 )
System . out . p r i n t l n ( s t r 1 + ” i s i d e n t i c a l to ” + s t r 2 ) ;
else
System . out . p r i n t l n ( s t r 1 + ” i s not i d e n t i c a l to ” + s t r 2 ) ;
}// t e s t I d e n t i c a l ( )
public s t a t i c void main ( S t r i n g argv [ ] ) {
t e s t E q u a l ( s1 , s2 ) ; // e q u a l
t e s t E q u a l ( s1 , s3 ) ; // n o t e q u a l
t e s t E q u a l ( s1 , s4 ) ; // e q u a l
t e s t E q u a l ( s1 , s5 ) ; // e q u a l
t e s t E q u a l ( s5 , s6 ) ; // e q u a l
t e s t I d e n t i c a l ( s1 , s2 ) ; // n o t i d e n t i c a l
t e s t I d e n t i c a l ( s1 , s3 ) ; // n o t i d e n t i c a l
t e s t I d e n t i c a l ( s1 , s4 ) ; // i d e n t i c a l
t e s t I d e n t i c a l ( s1 , s5 ) ; // n o t i d e n t i c a l
t e s t I d e n t i c a l ( s5 , s6 ) ; // i d e n t i c a l
}// m a i n ( )
}// T e s t S t r i n g E q u a l s
−−−−−− Program Output −−−−−
h e l l o equals h e l l o
h e l l o does not equal Hello
h e l l o equals h e l l o
h e l l o equals h e l l o
h e l l o equals h e l l o
h e l l o i s not i d e n t i c a l to h e l l o
h e l l o i s not i d e n t i c a l to Hello
h e l l o i s i d e n t i c a l to h e l l o
h e l l o i s not i d e n t i c a l to h e l l o
h e l l o i s i d e n t i c a l to h e l l o
✡ ✠
Figure 7.16: Program illustrating the difference between s tring equality
and identity.
336 CHAPTER 7 •Strings and String Processing
a.s1 == s2
b.s1.equals(s2)
c.s1 == s3d.s1.equals(s3)
e.s2 == s3
f.s2.equals(s4)g.s2 == s4
h.s1 == s5
i.s4 == s5
EXERCISE 7.17 Why are the variables in TestStringEquals de-
claredstatic ?
EXERCISE 7.18 Given the following declarations,
☛ ✟
S t r i n g s1 = ” abcdefghijklmnopqrstuvwxyz ” ;
S t r i n g s2 = ” h e l l o world” ;
✡ ✠
write Java expressions to carry out each of the following ope rations:
a. Swap the front and back half of s1giving a new string.
b. Swap ”world” and ”hello” in s2giving a new string.
c. Combine parts of s1ands2to create a new string ”hello abc”.
7.10 From the Java Library:
java.util.StringTokenizer
ONE OF THE most widespread string-processing tasks is that of breakin g
up a string into its components, or tokens . For example, when processing
java.sun.com/j2se/1.5.0/docs/api/ a sentence, you may need to break the sentence into its consti tuent words,
which are considered the sentence tokens. When processing a n ame-
password string, such as “boyd:14irXp”, you may need to brea k it into
a name and a password. Tokens are separated from each other by one or
more characters which is known as delimiters . Thus, for a sentence, white
space , including blank spaces, tabs, and line feeds, serve as the d elimiters.
For the password example, the colon character serves as a del imiter.
Java’sjava.util.StringTokenizer class is specially designed for
Object
+StringTokenizer(in s : String)
+StringTokenizer(in s : String, in d : String)
+countTokens() : int
+hasMoreTokens() : boolean
+nextToken() : String
+nextToken(in delim : String) : String
+hasMoreElements() : boolean
+nextElement() : StringStringTokenizer+hasMoreElements() : boolean
+nextElement() : String«interface»
Enumeration
FIGURE 7.17 The
java.util.StringTokenizer
class.breaking strings into their tokens (Fig. 7.17). When instant iated with
aString parameter, a StringTokenizer breaks the string into to-
kens, using white space as delimiters. For example, if we ins tantiated a
StringTokenizer as in the code
☛ ✟
StringTokenizer sTokenizer
=new StringTokenizer ( ” This i s an English sentence . ” ) ;
✡ ✠
it would break the string into the following tokens, which wo uld be stored
internally in the StringTokenizer in the order shown:
☛ ✟
This
i s
an
English
sentence .
✡ ✠
Note that the period is part of the last token (“sentence.”). This is because
punctuation marks are not considered delimiters by default .
SECTION 10 •Handling Text in a Graphics Context 337
If you wanted to include punctuation symbols as delimiters, y ou could
use the second StringTokenizer() constructor, which takes a second
String parameter (Fig. 7.17). The second parameter speciﬁes a stri ng of
those characters that should be used as delimiters. For exam ple, in the
instantiation,
☛ ✟
StringTokenizer sTokenizer
=new StringTokenizer ( ” This i s an English sentence . ” ,
”\b\t\n , ; . ! ” ) ;
✡ ✠
various punctuation symbols (periods, commas, and so on) ar e included
among the delimiters. Note that escape sequences ( \b\t\n ) are used to
specify blanks, tabs, and newlines.
ThehasMoreTokens() andnextToken() methods can be used to
process a delimited string, one token at a time. The ﬁrst meth od returns
true as long as more tokens remain; the second gets the next token i n the
list. For example, here’s a code segment that will break a sta ndard URL
string into its constituent parts:
☛ ✟
S t r i n g u r l = ” http :// java . t r i n c o l l . edu/˜ j j j /index . html” ;
StringTokenizer sTokenizer = new StringTokenizer ( url , ” :/ ” ) ;
while ( sTokenizer . hasMoreTokens ( ) ) {
System . out . p r i n t l n ( sTokenizer . nextToken ( ) ) ;
}
✡ ✠
This code segment will produce the following output:
☛ ✟
http
java . t r i n c o l l . edu
˜ j j j
index . html
✡ ✠
The only delimiters used in this case were the “ :” and “ /” symbols. And
note that nextToken() does not return the empty string between “ :”
and “/” as a token.
7.11 Handling Text in a Graphics Context
(Optional)
In order to create attractive GUIs, it is often necessary to be a ble to select
and control the font that is used. Even a simple drawing task, such as
being able to center a message in a panel, requires that we kno w the font’s
dimensions and be able to manipulate them. In this section, we learn how+getFont() : Font
+getFontMetrics() : FontMetrics
+setFont(in f : Font)
+setFontMetrics(in f : FontMetrics)Graphics
FIGURE 7.18 Methods to access the
Font andFontMetrics objects
associated with each Graphics
context.to work with Java’s fonts and font control methods.
Each graphics context has an associated Font andFontMetrics ob-
ject, and the Graphics class (Fig. 7.18) provides several methods to ac-
cess them. A FontMetrics is an object that encapsulates important
data about a font, such as its height and width. Java assigns a default
font to each Graphics object. For example, this is the font used by the
338 CHAPTER 7 •Strings and String Processing
drawString() method, which we used in our very ﬁrst Java programs
back in Chapter 1. The particular font used is system depende nt, but to
override the default one can simply invoke the setFont() method:
☛ ✟
g . setFont ( new Font ( ”TimesRoman” , Font . ITALIC , 1 2 ) ) ;
✡ ✠
In this case, the Font() constructor is used to specify a 12-point, itali-
cized, TimesRoman font. Once the font is set, it will be used in all subse-
quent drawings.
7.11.1 The Font andFontMetrics Classes
TheFont class (Fig. 7.19) provides a platform-independent represe nta-
tion of an individual font. A font is distinguished by its nam e, size,
and style, and the Font class includes protected instance variables for
these properties, as well as a constructor method that allow s these three
characteristics to be speciﬁed.+Font(in s : String, in sty : int, in sz : int)+BOLD : int
+ITALIC : int
+PLAIN : int
 # name : String
 # size : int
 # style : intFont
FIGURE 7.19 TheFont class.In order to understand how fonts work, it is necessary to disti nguish
between a character , which is a symbol that represents a certain letter or
digit, and a glyph , which is a shape used to display the character. When
you display a string, such as “Hello”, Java maps each individu al charac-
ter into a corresponding shape, as deﬁned by the particular f ont that is
selected.
Java distinguishes between physical and logical fonts. A physical font is
an actual font library that contains the data and tables need ed to associate
the correct glyph with a given character. Generally speakin g, a given plat-
form (host computer plus operating system) will have a colle ction of such
fonts available on it.
Alogical font is one of ﬁve font families that are supported by the Java
runtime environment. These include Serif, SansSerif, Mono spaced, Dia-
log, and DialogInput. Java also supports the following font s tyles:PLAIN ,
BOLD ,ITALIC , andBOLD+ITALIC . Whereas the physical fonts are plat-
form dependent, the logical fonts and styles are platform in dependent.
When used in a program, they are mapped to real fonts available on the
host system. If the host system does not have an exact match for the speci-
ﬁed font, it will supply a substitute. For example, if you spe cify a 48-point,
italic, Monospaced font,
☛ ✟
Font myFont = new Font ( ”Monospaced” , Font . ITALIC , 4 8 ) ;
✡ ✠
the system may map this to a 24-point, italic Courier font, if that is the
largest ﬁxed-spaced font available.
TheFont() constructor is designed to work with any set of arguments.
Thus, if you supply the name of a font that is not available, th e system
will supply a default font as a substitute. For example, on my system,
specifying a nonexistent font named Random,
☛ ✟
g . setFont ( new Font ( ”Random” , Font . ITALIC , 12) ) ;
g . drawString ( ” Hello World ! ( random , i t a l i c , 12) ” , 30 , 4 5 ) ;
✡ ✠
SECTION 11 •Handling Text in a Graphics Context 339
produces the same font used as the mapping for a font named Dialog .
JAVA EFFECTIVE DESIGN Font Portability. The fact that Font()
will produce a font for virtually any set of arguments is impo rtant in
ensuring that a Java program will run on any platform. This is another
example of how Java has been designed for portability.
TheComponent.setFont() method can be used to assign a speciﬁc
font to a button or window or other graphics component. All AWT and
JFC components have an associated font, which can be accesse d using the
Component.setFont() andComponent.getFont() methods. For
example, the following code could be used to override a Button ’s font:
☛ ✟
Button b = new Button ( ” Label ” ) ;
b . setFont ( new Font ( ”Times” , Font . ITALIC , 1 4 ) ) ;
✡ ✠
If 14-point, italic, Times font is not available on the host sy stem, a substi-
tute will be supplied.
7.11.2 Font Metrics
To illustrate how to use the FontMetrics class, let’s write a “Hello Problem statement
World” application that centers its message both horizonta lly and verti-
cally in its window. The message should be centered regardle ss of the
size of the application window. Thus, we will have to positio n the text
relative to the window size, which is something we learned in positioning
geometric shapes. The message should also be centered no mat ter what
font is used. This will require us to know certain characteri stics of the font
itself, such as the height and width of its characters, wheth er the charac-
ters have a ﬁxed or variable width, and so on. In order to get acc ess to
these properties, we will use the FontMetrics class.~
HeightAdvance
Leading
Baseline
Descentfontspecs
FIGURE 7.20 An illustration of the
various font measurements.Figure 7.20 illustrates the various properties that are ass ociated with
a font. The baseline of a font refers to the line on which the bottom of
most characters occurs. When drawing a string, the x-and y-coordinates
determine the baseline of the string’s ﬁrst character. Thus , in
☛ ✟
g . drawString ( ” Hello World” , 10 , 4 0 ) ;
✡ ✠
the bottom left of the Hin “Hello World” would be located at (10, 40).
All characters ascend some distance above the baseline. Thi s is known
as the character’s ascent . Some characters, such as y, may extend below
the baseline, into what’s known as the descent . Each font has a maximum
descent . Similarly, some characters, such as accent characters, ma y extend
above the maximum ascent into a space known as the leading .
The height of a font is deﬁned as the sum (in pixels) of the ascent, de-
scent, and leading values. The height is a property of the fon t itself rather
than of any individual character. Except for ﬁxed-width fon ts, in which
the width of all characters is the same, the characters that m ake up a font
have varying widths. The width of an individual character is known as its
advance .
340 CHAPTER 7 •Strings and String Processing
TheFontMetrics class (Fig. 7.21) provides methods for accessing a
 #  FontMetrics(in font : Font)
+charWidth(in ch : int) : int
+charWidth(in ch : char) : int
+getAscent() : int
+getDescent() : int
+getFont() : Font
+getHeight() : int
+getLeading() : int
+getMaxAdvance() : int
+getMaxDescent() : int
+stringWidth() : int #  font : FontFontMetrics
FIGURE 7.21 TheFontMetrics
class.font’s properties. These can be useful to control the layout of text on a
GUI. For example, when drawing multiple lines of text, the getHeight()
method is useful for determining how much space should be lef t between
lines. When drawing character by character, the charWidth() method
can be used to determine how much space must be left between ch arac-
ters. Alternatively, the stringWidth() method can be used to determine
the number of pixels required to draw the entire string.
7.11.3 Example: Centering a Line of Text
Given this background, let’s take on the task of centering a m essage in an
application window. In order for this application to work for any font, we
must take care not to base its design on characteristics of th e particular Algorithm design: Generality
font that we happen to be using. To underscore this point, let ’s design
it to work for a font named Random, which, as we noted earlier, will
be mapped to some font by the system on which the application i s run.
In other words, we will let the system pick a font for this appli cation’s
message. An interesting experiment would be to run the appli cation on
different platforms to see what fonts are chosen.
The only method we need for this application is the paint() method.
Let’s begin by setting the font used by the graphics context t o a random
font. To get the characteristics of this font, we create a FontMetrics
object and get the font metrics for the font we just created:
☛ ✟
g . setFont ( new Font ( ”Random” , Font .BOLD, 2 4 ) ) ;
FontMetrics metrics = g . getFontMetrics ( ) ;
✡ ✠
The next step is to determine the JFrame ’s dimensions using the
getSize() method. This method returns an object of type Dimension .
Thejava.awt.Dimension class (Fig. 7.22) represents the size (width
and height) of a GUI component. A Dimension makes it possible to ma-
nipulate an object’s width and height as a single entity. Note that the
height andwidth variables are deﬁned as public , which is an excep-
tion from the usual convention of deﬁning instances variabl es asprivate
orprotected . The justiﬁcation for this exception is probably to simplify
the syntax of referring to an object’s width and height. For ex ample, the
following syntax can be used to refer to a component’s dimens ions:
☛ ✟
Dimension d = new Dimension ( 1 0 0 , 5 0 ) ;
System . out . p r i n t l n ( ”width = ” + d . width +
” height = ” + d . height ) ;
✡ ✠
Note the redundancy built into the Dimension class. For example, in
addition to being able to set a Dimension ’s instance variables directly,+Dimension()
+Dimension(in d : Dimension)
+Dimension(in width : int, in height : int)
+equals(in o : Object) : boolean
+getSize() : Dimension
+setSize(in d : Dimension)
+setSize(in width : int, in height : int)
+toString() : String+height : int
+width : intDimension
FIGURE 7.22 TheDimension
class.public access methods are provided. Also, by deﬁning more th an one ver-
sion of some access methods, the class achieves a higher leve l of ﬂexibility.
The same can be said for providing several different constru ctors, includ-
ing a copy constructor. Finally, note how it overrides the equals() and
CHAPTER 7 •Chapter Summary 341
toString() methods. These are all examples of good object-oriented
design.
JAVA EFFECTIVE DESIGN Redundancy. Redundancy is often a
desirable characteristic of object design. It makes the object easier to
use and more widely applicable.
TheDimension object is used to calculate the x-and y-coordinates for
the string. In order to center the string horizontally, we nee d to know
its width, which is supplied by the metrics object. If the JFrame is
d.width pixels wide, then the following expression subtracts the wi dth Centering text
of the string from the width of the JFrame and then divides the leftover
space in half:
☛ ✟
// C a l c u l a t e c o o r d i n a t e s
i n t x = ( d . width −metrics . stringWidth ( s t r ) ) / 2 ;
✡ ✠
Similarly, the following expression adds the height of the s tring to the
height of the JFrame and divides the leftover space in half:
☛ ✟
i n t y = ( d . height + metrics . getHeight ( ) ) / 2 ;
✡ ✠
Taken together, these calculations give the coordinates fo r the lower left
pixel of the ﬁrst character in “Hello World!” The only remaini ng task is to
draw the string (Fig. 7.23). Because the paint() method is called auto-
matically whenever the JFrame is resized, this application, whose output
is shown in Figure 7.24, will re-center its message whenever it is resized
by the user.
JAVA PROGRAMMING TIP Generality. By using a component’s
size and font as the determining factors, you can center text on
virtually any component. These values are available via the
component’s getFont() andgetSize() methods.
CHAPTER SUMMARY Technical Terms
ascent
baseline
concatenation
copy constructor
data structure
delimited string
delimiter
empty stringgarbage collection
glyph
lexicographic order
logical font
off-by-one error
orphan object
physical font
read onlystring
string index
string literal
token
unit indexed
zero indexed
342 CHAPTER 7 •Strings and String Processing
☛ ✟
import java . awt . ∗;
import javax . swing . ∗;
public c l a s s CenterText extends JFrame {
// P r i n t h e l l o w o r l d ! i n c e n t e r o f f r a m e
public void paint ( Graphics g ) {
S t r i n g s t r = ” Hello World ! ” ;
g . setFont ( new Font ( ”Random” , Font . PLAIN , 2 4 ) ) ; // Random f o n t
FontMetrics metrics = g . getFontMetrics ( ) ; //
And i t s m e t r i c s
Dimension d = g e t S i z e ( ) ; // G e t t h e f r a m e ’ s s i z e
// C l e a r t h e f r a m e
g . setColor ( getBackground ( ) ) ;
g . f i l l R e c t ( 0 , 0 , d . width , d . height ) ;
g . setColor ( Color . black ) ;
// C a l c u l a t e c o o r d i n a t e s
i n t x = ( d . width −metrics . stringWidth ( s t r ) ) / 2 ;
i n t y = ( d . height + metrics . getHeight ( ) ) / 2 ;
g . drawString ( s t r , x , y ) ; // Draw t h e s t r i n g
}// p a i n t ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
CenterText c t = new CenterText ( ) ;
c t . s e t S i z e ( 4 0 0 , 4 0 0 ) ;
c t . s e t V i s i b l e ( true ) ;
}
}// C e n t e r T e x t
✡ ✠
Figure 7.23: The CenterText application.
Summary of Important Points
•AString literal is a sequence of 0 or more characters enclosed within
double quotation marks. A String object is a sequence of 0 or more
characters, plus a variety of class and instance methods and variables.
•AString object is created automatically by Java the ﬁrst time it en-
counters a literal string , such as “Socrates,” in a program. Subsequent
occurrences of the literal do not cause additional objects to be instan-
tiated. Instead, every occurrence of the literal “Socrates” refers to the
initial object.
Figure 7.24: The CenterText ap-
plication keeps its message cen-
tered no matter how its window is
resized.

CHAPTER 7 •Solutions to Self-Study Exercises 343
•AString object is created whenever the new operator is used
in conjunction with a String() constructor—for example, new
String("hello") .
•TheString concatenation operator is the overloaded +symbol; it is
used to combine two String s into a single String : “hello” + “world”
==> “helloworld”.
•String s are indexed starting at 0. The indexOf() andlastIndex-
Of() methods are used for ﬁnding the ﬁrst or last occurrence of a ch ar-
acter or substring within a String . The valueOf() methods con-
vert a nonstring into a String . Thelength() method determines
the number of characters in a String . The charAt() method re-
turns the single character at a particular index position. T he vari-
oussubstring() methods return the substring at particular index
positions in a String .
•The overloaded equals() method returns true if twoString s con-
tain the same exact sequence of characters. The ==operator, when used
onString s, returns true if two references designate the same String
object.
•String objects are immutable . They cannot be modiﬁed.
•AStringBuffer is a string object that can be modiﬁed using meth-
ods such as insert() andappend() .
•AStringTokenizer is an object that can be used to break a String
into a collection of tokens separated by delimiters . The whitespace
characters—tabs, blanks, and newlines—are the default delim iters.
•TheFontMetrics class is used to obtain the speciﬁc dimensions of
the the various Font s. It is useful when you wish to center text. Font s
are inherently platform dependent. For maximum portabilit y, it is best
to use default fonts.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 7.1 a. silly b. silly c. silly stuff
SOLUTION 7.2
a.String str1 = "";
b.String str2 = new String("stop");
c.String str3 = str1 + str2;
SOLUTION 7.3 a. 15 b. "551" c."5175"
SOLUTION 7.4 See Figure 7.25.
SOLUTION 7.5 a."45" b."121" c."X"
SOLUTION 7.6
a.String.valueOf(100)
b.String.valueOf(’V’);
c.String s = new String(String.valueOf(X *Y));
SOLUTION 7.7 a. 0 b. 1 c. −1
344 CHAPTER 7 •Strings and String Processing
String s1, s2 ="Hello", s3 ="Hello";
String s4 ="hello";
String s5 =new String ("Hello");
String s6 =s5;
String s7 =s3;value ="Hello"
count =5: String
value ="hello"
count =5: String
value ="Hello"
count =5: String null"Hello" "hello" s5 s6 s1 s4s2
s3s7Figure 7.25:
7.4. Note that
has not been
not been assigned
SOLUTION 7.8
a. 16b."16"
c. 1
d. 15
e. 1f. 13
g. 7
h. 3
i. 7j. 7
k. 3
SOLUTION 7.9 Evaluate the following expression:
☛ ✟
S t r i n g t r i c k y = ” abcdefg01234567 ” ;
t r i c k y . indexOf ( S t r i n g . valueOf ( t r i c k y . indexOf ( ” c ” ) ) ) ;
t r i c k y . indexOf ( S t r i n g . valueOf ( 2 ) ) ;
t r i c k y . indexOf ( ”2” ) ;
Answer : 9
✡ ✠
SOLUTION 7.10 a."uvwxyz"
b."bcde"c."xyz"
d."xy"e."xyz"
SOLUTION 7.11 a."uvwxyz"
b."bcde"c."xyz"
d."xyz"e."xyz"
SOLUTION 7.12 A class to test the string methods.
☛ ✟
public c l a s s S t r i n g P r o c e s s o r T e s t {
public s t a t i c void main ( S t r i n g [ ] args ) {
KeyboardReader kb = new KeyboardReader ( ) ;
kb . prompt ( ” Input a S t r i n g or −stop−to quit : ” ) ;
S t r i n g s t r = kb . getKeyboardInput ( ) ;
while ( ! s t r . equals ( ” stop ” ) ){
kb . display ( ” Testing p r i n t L e t t e r s ( ) \n”) ;
S t r i n g P r o c e s s o r . p r i n t L e t t e r s ( s t r ) ;
kb . display ( ” t e s t i n g countChars ( ) \n”) ;
kb . display ( ” Total occurences of e = ” ) ;
kb . display ( S t r i n g P r o c e s s o r . countChar ( s t r , ’ e ’) + ”\n”) ;
kb . display ( ” Testing reverse ( ) \n”) ;
kb . display ( S t r i n g P r o c e s s o r . reverse ( s t r )+ ”\n”) ;
kb . display ( ” Testing c a p i t a l i z e ( ) \n”) ;
kb . display ( S t r i n g P r o c e s s o r . c a p i t a l i z e ( s t r ) + ”\n\n”) ;
kb . prompt ( ” Input a S t r i n g or −stop−to quit : ” ) ;
s t r = kb . getKeyboardInput ( ) ;
}// w h i l e
}// m a i n ( )
}// S t r i n g P r o c e s s o r T e s t c l a s s
✡ ✠
CHAPTER 7 •Exercises 345
SOLUTION 7.13 Method to remove all blanks from a string:
☛ ✟
// P r e : s i s a n o n n u l l s t r i n g
// P o s t : s i s r e t u r n e d w i t h a l l i t s b l a n k s r e m o v e d
public S t r i n g removeBlanks ( S t r i n g s ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;
for (i n t k = 0 ; k <s . length ( ) ; k++)
i f( s . charAt ( k ) != ’ ’) // I f t h i s i s n o t a b l a n k
r e s u l t . append ( s . charAt ( k ) ) ; //
a p p e n d i t t o r e s u l t
return r e s u l t . t o S t r i n g ( ) ;
}
✡ ✠
SOLUTION 7.14 A Alpha Z Zero Zeroes a alpha bath bin z zero
SOLUTION 7.15 To modify precedes so that it also returns true when its two
string arguments are equal, just change the operator in the ﬁna l return statement
to<=:
☛ ✟
i f( s1 . charAt ( k ) <= s2 . charAt ( k ) )
return true ;
✡ ✠
SOLUTION 7.16 a. true
b. true
c. falsed. false
e. false
f. trueg. false
h. false
i. false
SOLUTION 7.17 The variables in TestStringEquals are declared static
because they are used in static methods. Whenever you call a method di-
rectly from main() , it must be static because main() is static. Remember
thatstatic elements are associated with the class, not with its instances . So
main() can only use static elements because they don’t depend on the exis tence
of instances.
SOLUTION 7.18
a.String s3 = s1.substring(s1.indexOf(’n’))
+ s1.substring(0,s1.indexOf(’n’));
b.String s4 = s2.substring(6) + " " + s2.substring(0,5);
c.String s5 = s2.substring(0,6) + s1.substring(0,3);
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 7.1 Explain the difference between the following pairs of terms:
a.Unit indexing and zero indexing .
b.Data structure and data type .
c.StringBuffer andString .
d.String andStringTokenizer .
e.Declaring a variable and instantiating a String .
f. AFont and aFontMetrics object.
EXERCISE 7.2 Fill in the blanks.
a. When the ﬁrst character in a string has index 0, this is known as .
b. A sequence of characters enclosed within quotes is known as a .
346 CHAPTER 7 •Strings and String Processing
EXERCISE 7.3 Given the String strwith the value “to be or not to be that is the
question,” write Java expressions to extract each of the substr ings shown below.
For each substring, provide two sets of answers. One that uses th e actual index
numbers of the substrings—for example, the ﬁrst “to” goes from 0 to 2—and a sec-
ond more general solution that will also retrieve the substring f rom the following
string “it is easy to become what you want to become.” ( Hint : In the second case,
uselength() andindexOf() along with substring() in your expressions. If
necessary, you may use local variables to store intermediate re sults. The answer
to (a) is provided as an example.)
a. the ﬁrst “to” in the string
☛ ✟
s t r . substring ( 0 , 2)
// A n s w e r 1
s t r . substring (
s t r . indexOf ( ” to ” ) , s t r . indexOf ( ” to ” ) + 2) // A n s w e r 2
✡ ✠
b. the last “to” in the string
c. the ﬁrst “be” in the string
d. the last “be” in the stringe. the ﬁrst four characters in the string
f. the last four characters in the string
EXERCISE 7.4 Identify the syntax errors in each of the following, assuming tha t
sis the literal string “exercise”:
a.s.charAt("hello")
b.s.indexOf(10)
c.s.substring("er")d.s.lastIndexOf(er)
e.s.length
EXERCISE 7.5 Evaluate each of the following expressions, assuming that sis
the literal string “exercise”:
a.s.charAt(5)
b.s.indexOf("er")
c.s.substring(5)d.s.lastIndexOf(’e’)
e.s.length()
EXERCISE 7.6 Write your own equalsIgnoreCase() method using only
otherString methods.
EXERCISE 7.7 Write your own String equality method without using
String. equals() . (Hint : Modify the precedes() method.)
EXERCISE 7.8 Even though Java’s String class has a built-in toLowerCase()
method, write your own implementation of this method. It should take aString
parameter and return a String with all its letters written in lowercase.
EXERCISE 7.9 Write a method that converts its String parameter so that let-
ters are written in blocks ﬁve characters long. For example, cons ider the following
two versions of the same sentence:
☛ ✟
Plain : This i s how we would o r d i n a r i l y write a sentence .
Blocked : T h i s i showw ewoul dordi n a r i l ywrit easen tence .
✡ ✠
EXERCISE 7.10 Design and implement an applet that lets the user type a doc-
ument into a TextArea and then provides the following analysis of the docu-
ment: the number of words in the document, the number of character s in the
document, and the percentage of words that have more than six lett ers.
EXERCISE 7.11 Design and write an applet that searches for single-digit num -
bers in a text and changes them to their corresponding words. For e xample, the
string “4 score and 7 years ago” would be converted into “four score a nd seven
years ago”.
CHAPTER 7 •Exercises 347
EXERCISE 7.12 A palindrome is a string that is spelled the same way backward
and forward. For example, mom, dad, radar, 727 and able was i ere i saw elba are all
examples of palindromes. Write a Java applet that lets the user type in a word or
phrase and then determines whether the string is a palindrome .
EXERCISE 7.13 Write a maze program that uses a string to store a representa-
tion of the maze. Write a method that accepts a String parameter and prints a
two-dimensional representation of a maze. For example, the maze s hown here,
where Omarks the entrance and exit can be generated from the following s tring:
☛ ✟
S t r i n g : XX XXXXXXXX XXX XXXX XX XXX XXXXXXX X XXXXXXXX X
O
XX XXXXXXX
X XXX XXX
X XX XX
X XX XX XX
X X O
XXXXXXXX X
✡ ✠
EXERCISE 7.14 Write a method that takes a delimited string to store a name
and address, from which you can print a mailing label. For exampl e, if the string
contains “Sam Penn:14 Bridge St.:Hoboken, NJ 01881,” the method sh ould print
the label shown in the margin.Sam Penn
14 Bridge St.
Hoboken, NJ 01881
EXERCISE 7.15 Design and implement an applet that plays Time Bomb with
the user. Here’s how the game works. The computer picks a secret wor d and then
prints one asterisk for each letter in the word: * * * * *. The user g uesses at the
letters in the word. For every correct guess, an asterisk is repl aced by a letter:
* e * * *. For every incorrect guess, the time bomb’s fuse grows shorte r. When
the fuse disappears, after say, six incorrect guesses, the bom b explodes. Store the
secret words in a delimited string and invent your own represent ation for the time
bomb.
EXERCISE 7.16 Challenge: The global replace function is a string-processing
algorithm found in every word processor. Write a method that takes t hreeString
arguments: a document, a target string, and a replacement str ing. The method
should replace every occurrence of the target string in the docum ent with the re-
placement string. For example, if the document is “To be or not to b e, that is the
question,” and the target string is “be,”, and the replacemen t string is “see,” the
result should be, “To see or not to see, that is the question.”
EXERCISE 7.17 Challenge: Design and implement an applet that plays the
following game with the user. Let the user pick a letter between Aand Z. Then
let the computer guess, the secret letter. For every guess the p layer has to tell the
computer whether it’s too high or too low. The computer should be able t o guess
the letter within ﬁve guesses. Do you see why?
348 CHAPTER 7 •Strings and String Processing
EXERCISE 7.18 Challenge: Alistis a sequential data structure. Design a List
class that uses a comma-delimited String —such as, “a,b,c,d,12,dog”—to imple-
ment a list. Implement the following methods for this class:
☛ ✟
void addItem ( Object o ) ; // U s e O b j e c t . t o S t r i n g ( )
S t r i n g getItem ( i n t p o s i t i o n ) ;
S t r i n g t o S t r i n g ( ) ;
void deleteItem ( i n t p o s i t i o n ) ;
void deleteItem ( S t r i n g item ) ;
i n t g e t P o s i t i o n ( S t r i n g item ) ;
S t r i n g getHead ( ) ; // F i r s t e l e m e n t
L i s t g e t T a i l ( ) ; // A l l b u t t h e f i r s t e l e m e n t
i n t length ( ) ; // N u m b e r o f i t e m s
✡ ✠
EXERCISE 7.19 Challenge: Use a delimited string to create a PhoneList class
with an instance method to insert names and phone numbers, and a method to
look up a phone number when a user provides a person’s name. Since your c lass
will take care of looking things up, you don’t have to worry about keepi ng the list
in alphabetical order. For example, the following string could be used as such a
directory:
☛ ✟
m o m:860 −192−9876:: b i l l g:654 −0987−1234::mary l a n c e l o t :123 −842−1100
✡ ✠
EXERCISE 7.20 Design and implement an applet or application that displays a
multi-line message in various fonts and sizes input by the user . Let the user choose
from among a ﬁxed selection of fonts, sizes, and styles.
OBJECTIVES
After studying this chapter, you will
•Understand the concepts of inheritance and polymorphism.
•Know how Java’s dynamic binding mechanism works.
•Be able to design and use abstract methods and classes.
•Be able to design and use polymorphic methods.
•Gain a better understanding of object-oriented design.
OUTLINE
8.1 Introduction
8.2 Java’s Inheritance Mechanism
8.3 Abstract Classes, Interfaces, and Polymorphism
8.4 Example: A Toggle Button
Special Topic: Historical Cryptography
8.5 Example: The Cipher Class Hierarchy
8.6 Case Study: A Two Player Game Hierarchy
8.7 Principles of Object-Oriented Design
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 8
Inheritance and
Polymorphism
349
350 CHAPTER 8 •Inheritance and Polymorphism
8.1 Introduction
Among the most important concepts in object oriented program ming are
the concepts of inheritance and polymorphism. We ﬁrst intro duced the
idea of inheritance in Chapter 0. There we compared inherita nce to the
natural form of inheritance, in which horses and cows share c ertain inher-
ited characteristics, such as being warm-blooded, by virtu e of their being
mammals. We also gave the example of a hierarchy of chess piec es and
showed how different kinds of chess pieces, such as Pawn andBishop , in-
herited certain shared characteristics from their ChessPiece superclass.
We took a more technical look at inheritance in Chapter 3, whe re we
talked about the toString() method and how it is inherited from the
Object class. We illustrated there how subclasses of Object could
override the inherited toString() method in order to customize it for
their purposes. We also introduced the idea of polymorphism , in which
a method call, such as obj.toString() , can have different behaviors
depending on the type of object, obj, on which it is called.
In Chapter 4, we continued introducing inheritance and polym or-
phism, when we learned about Java’s Abstract Windowing Tool kit (AWT)
and Swing hierarchies, the class hierarchies that are used t o create Graph-
ical User Interfaces (GUIs). We also learned how to extend a cla ss to create
our own subclass, and we made limited use of inheritance in th e design
of theSimpleGUI class. We were also introduced to the concept of a Java
interface, and we learned how to use the ActionListener interface to
enable a SimpleGUI to handle action events while the GUI is running.
In this chapter we will take a much closer look at these importa nt
object-oriented concepts. We will learn how Java’s dynamic binding mecha-
nism works and how it makes polymorphism possible. Most impo rtantly,
we will see why inheritance and polymorphism are important e lements of
object-oriented design, and we will learn how to use these imp ortant tools
to design several different programs. In keeping with our run ning games
example, we will develop a TwoPlayerGame hierarchy and show how
it can simplify the implementation of OneRowNim and other two-player
games.
8.2 Java’s Inheritance Mechanism
As we described in Chapter 0, class inheritance is the mechanism
whereby a class acquires ( inherits ) the methods and variables of its super-
classes. To remind you of the basic concept, let’s repeat an e arlier example:
Just as horses inherit the attributes and behaviors associa ted with mam-
mals and vertebrates, a Java subclass inherits the attribut es and behaviors
of its superclasses.
FIGURE 8.1 A class hierarchy for
horses.Figure 8.1 uses a UML diagram to illustrate the relationship s among
horses, mammals, vertebrates, and animals. As the root of th e hierarchy,
which is always shown at the top, the Animal class contains th e most gen-
eral attributes, such as being alive and being able to move. A ll animals
share these attributes. The class of vertebrates is a somewh at more spe-
cialized type of animal, in that vertebrates have backbones . Similarly, the
class of mammals is a further specialization over the verteb rates in that
SECTION 8.2 •Java’s Inheritance Mechanism 351
mammals are warm-blooded and nurse their young. Finally, th e class of
horses is a further specialization over the class of mammals , in that all
horses have four legs. Some mammals, such as humans and pengu ins, do
not have four legs. Thus, by virtue of its class’s position in this hierarchy,
we can infer that a horse is a living, moving, four-legged ver tebrate, which
is warm blooded and nurses its young.
We have deliberately used an example from the natural world t o show
that the concept of inheritance in Java is inspired by its cou nterpart in the
natural world. But how exactly does the concept of inheritan ce apply to
Java (and to other object-oriented languages)? And, more imp ortantly,
how do we use the inheritance mechanism in object-oriented de sign?
8.2.1 Using an Inherited Method
In Java, the public and protected instance methods and instan ce variables
of a superclass are inherited by all of its subclasses. This m eans that objects
belonging to the subclasses can use the inherited variables and methods
as their own.
We have already seen some examples of this in earlier chapter s. For ex-
ample, recall that by default all Java classes are subclasse s of the Object
class, which is the most general class in Java’s class hierar chy. One public
method that is deﬁned in the Object class is the toString() method.
Because every class in the Java hierarchy is a subclass of Object , every
class inherits the toString() method. Therefore, toString() can be
used with any Java object.
To illustrate this, suppose we deﬁne a Student class as follows:
☛ ✟
public c l a s s Student {
protected S t r i n g name ;
public Student ( S t r i n g s ) {
name = s ;
}
public S t r i n g getName ( ) {
return name ;
}
}
✡ ✠
Figure 8.2 shows the relationship between this class and the Object class.
FIGURE 8.2 TheStudent class
hierarchy.As a subclass of Object , theStudent class inherits the toString()
method. Therefore, for a given Student object, we can call its
toString() as follows:
☛ ✟
Student stu = new Student ( ” Stu ” ) ;
System . out . p r i n t l n ( stu . t o S t r i n g ( ) ) ;
✡ ✠
How does this work? That is, how does Java know where to ﬁnd the
toString() method, which, after all, is not deﬁned in the Student
class? The answer to this question is crucial to understandi ng how Java’s
inheritance mechanism works.
Note in this example that the variable stu is declared to be of type
Student and is assigned an instance of the Student class. When
352 CHAPTER 8 •Inheritance and Polymorphism
the expression stu.toString() is executed, Java will ﬁrst look in the
Student class for a deﬁnition of the toString() method. Not ﬁnding
one there, it will then search up the Student class hierarchy (Fig. 8.2)
until it ﬁnds a public or protected deﬁnition of the toString() method.
In this case, it ﬁnds a toString() method in the Object class and it ex-
ecutes that implementation of toString() . As you know from Chap-
ter 3, this would result in the expression stu.toString() returning
something like:
☛ ✟
Student@cde100
✡ ✠
The default implementation of toString() returns the name of the ob-
ject’s class and the address ( cde100 ) where the object is stored in mem-
ory. However, this type of result is much too general and not pa rticularly
useful.
8.2.2 Overriding an Inherited Method
In Chapter 3 we pointed out that the toString() method is designed to
beoverridden —that is, to be redeﬁned in subclasses of Object . Overriding
toString() in a subclass provides a customized string representation o f
the objects in that subclass. We showed that by redeﬁning toString() in
ourOneRowNim class, we customized its actions so that it returned useful
information about the current state of a OneRowNim game.
To override toString() for the Student class, let’s add the following
method deﬁnition to the Student class:
☛ ✟
public S t r i n g t o S t r i n g ( ) {
return ”My name i s ” + name + ” and I am a Student . ” ;
}
✡ ✠
FIGURE 8.3 The revised Student
class hierarchy.
Given this change, the revised Student class hierarchy is shown in Fig-
ure 8.3. Note that both Object andStudent contain implementations of
toString() . Now when the expression stu.toString() is invoked,
the following, more informative, output is generated:
☛ ✟
My name i s Stu and I am a Student .
✡ ✠
In this case, when Java encounters the method call stu.toString() ,
it invokes the toString() method that it ﬁnds in the Student class
(Fig. 8.3).
SECTION 8.2 •Java’s Inheritance Mechanism 353
These examples illustrate two important object-oriented co ncepts: in-
heritance and method overriding.
JAVA EFFECTIVE DESIGN Inheritance. The public and protected
instance methods (and variables) in a class can be used by obje cts that
belong to the class’s subclasses.
JAVA EFFECTIVE DESIGN Overriding a Method. Overriding an
inherited method is an effective way to customize that metho d for a
particular subclass.
8.2.3 Static Binding, Dynamic Binding
and Polymorphism
The mechanism that Java uses in these examples is known as dynamic
binding , in which the association between a method call and the cor-
rect method implementation is made at run time. In dynamic bin ding
a method call is bound to the correct implementation of the me thod at run
time by the Java Virtual Machine (JVM).
Dynamic binding is contrasted with static binding , the mechanism by
which the Java compiler resolves the association between a method call
and the correct method implementation when the program is co mpiled.
In order for dynamic binding to work, the JVM needs to maintain some
kind of representation of the Java class hierarchy, includi ng classes deﬁned
by the programmer. When the JVM encounters a method call, it us es in-
formation about the class hierarchy to bind the method call to the correct
implementation of that method.
In Java, all method calls use dynamic binding except methods t hat are
declared final orprivate . Final methods cannot be overridden, so Dynamic binding
declaring a method as final means that the Java compiler can bind it
to the correct implementation. Similarly, private methods are not inher-
ited and therefore cannot be overridden in a subclass. In effe ct, private
methods are ﬁnal methods and the compiler can perform the bin ding at
compile time.
Java’s dynamic-binding mechanism, which is also called latebinding or Polymorphism
run-time binding, leads to what is know as polymorphism .Polymorphism
is a feature of object-oriented languages whereby the same me thod call
can lead to different behaviors depending on the type of objec t on which
the method call is made. The term polymorphism means, literally, having
many (poly) shapes (morphs). Here’s a simple example:
☛ ✟
Object obj ; // S t a t i c t y p e : O b j e c t
obj = new Student ( ” Stu ” ) ; // A c t u a l t y p e : S t u d e n t
System . out . p r i n t l n ( obj . t o S t r i n g ( ) ) ; // P r i n t s ” My n a m e i s S t u . . . ”
obj = new OneRowNim ( 1 1 ) ; // A c t u a l t y p e : OneRowNim
System . out . p r i n t l n ( obj . t o S t r i n g ( ) ) ; // P r i n t s ” n S t i c k s = 1 1 , p l a y e r = 1 ”
✡ ✠
354 CHAPTER 8 •Inheritance and Polymorphism
The variable obj is declared to be of type Object . This is its static or
declared type. A variable’s static type never changes. However, a vari able
also has an actual ordynamic type. This is the actual type of the object that
has been assigned to the variable. As you know, an Object variable can
be assigned objects from any Object subclass. In the second statement,
obj is assigned a Student object. Thus, at this point in the program,
the actual type of the variable obj isStudent . When obj.toString()
is invoked in the third line, Java begins its search for the toString()
method at the Student class, because that is the variable’s actual type.
In the fourth line, we assign a OneRowNim object to obj, thereby chang-
ing its actual type to OneRowNim . Thus, when obj.toString() is in-
voked in the last line, the toString() method is bound to the imple-
mentation found in the OneRowNim class.
Thus, we see that the same expression, obj.toString() , is bound al-
ternatively to two different toString() implementations, based on the
actual type of the object, obj, on which it is invoked. This is polymor-
phism and we will sometimes say that the toString() method is a poly- Polymorphic method
morphic method. A polymorphic method is a method signature that be-
haves differently when it is invoked on different objects. An overridden
method, such as the toString() method, is an example of a polymor-
phic method, because its use can lead to different behaviors depending
upon the object on which it is invoked.
The previous example is admittedly somewhat contrived. In so me
object-oriented languages, a code segment such as that above would use
static binding rather than dynamic binding. In other words, t he com-
piler would be able to ﬁgure out the bindings. So let’s take an example
where static binding, also called early binding, is not possible. Consider
the following method deﬁnition:
☛ ✟
public void polyMethod ( Object obj ) {
System . out . p r i n t l n ( obj . t o S t r i n g ( ) ) ; // P o l y m o r p h i c
}
✡ ✠
The method call in this method, obj.toString() , can’t be bound to
the correct implementation of toString() until the method is actually
invoked—that is, at run time. For example, suppose we make the follow-
ing method calls in a program:
☛ ✟
Student stu = new Student ( ” Stu ” ) ;
polyMethod ( stu ) ;
OneRowNim nim = new OneRowNim ( ) ;
polyMethod ( nim ) ;
✡ ✠
The ﬁrst time polyMethod() is called, the obj.toString() is invoked
on aStudent object. Java will use its dynamic binding mechanism
to associate this method call with the toString() implementation in
Student and output “My name is Stu and I am a Student.” The sec-
ond time polyMethod() is called, the obj.toString() expression is
invoked on a OneRowNim object. In this case, Java will bind the method
SECTION 8.2 •Java’s Inheritance Mechanism 355
call to the implementation in the OneRowNim class. The output generated
in this case will report how many sticks are left in the game.
The important point here is that polymorphism occurs when an over-
ridden method is called on a superclass variable, obj. In such a case, the
actual method implementation that is invoked is determined at run time.
The determination depends on the type of object that was assig ned to the
variable. Thus, we say that the method call obj.toString() is poly-
morphic because it is bound to different implementations of toString()
depending on the actual type of the object that is bound to obj.
8.2.4 Polymorphism and Object-Oriented Design
Now that we understand how inheritance and polymorphism wor k
in Java, it will be useful to consider an example that illustr ates
how these mechanisms can be useful in designing classes and m eth-
ods. We have been using the various System.out.print() and
System.out.println() methods since Chapter 1. The print()
andprintln() methods are examples of overloaded methods—that is,
methods that have the same name but different parameter list s. Remem- Overloaded methods
ber that a method’s signature involves its name, plus the typ e, num-
ber, and order of its parameters. Methods that have the same n ame but
different parameters are said to be overloaded.
Here are the signatures of some of the different print() and
println() methods:
☛ ✟
p r i n t ( char c ) ; p r i n t l n ( char c ) ;
p r i n t ( i n t i ) ; p r i n t l n ( i n t i ) ;
p r i n t ( double d ) ; p r i n t l n ( double d ) ;
p r i n t ( f l o a t f ) ; p r i n t l n ( f l o a t f ) ;
p r i n t ( S t r i n g s ) ; p r i n t l n ( S t r i n g s ) ;
p r i n t ( Object o ) ; p r i n t l n ( Object o ) ;
✡ ✠
Basically, there is a print() andprintln() method for every type of
primitive data, plus methods for printing any type of object. When Java
encounters an expression involving print() orprintln() it chooses
which particular print() orprintln() method to call. To determine
the correct method, Java relies on the differences in the sig natures of the
various print() methods. For example, because its argument is an int,
the expression print(5) is associated with the method whose signature
isprint(int i) be cause its parameter is an int.
Note that there is only one set of print() andprintln() meth-
ods for printing Object s. The reason is that polymorphism is used by
theprint(Object o) andprintln(Object o) methods to print any
type of object. While we do not have access to the source code for these
356 CHAPTER 8 •Inheritance and Polymorphism
methods, we can make an educated guess that their implementa tions
utilize the polymorphic toString() method, as follows:
☛ ✟
public void p r i n t ( Object o ) {
System . out . p r i n t ( o . t o S t r i n g ( ) ) ;
}
public void p r i n t l n ( Object o ) {
System . out . p r i n t l n ( o . t o S t r i n g ( ) ) ;
}
✡ ✠
Here again we have a case where an expression, o.toString() ,
is bound dynamically to the correct implementation of toString()
based on the type of Object that the variable ois bound to. If we
callSystem.out.print(stu) , where stu is aStudent , then the
Student.toString() method is invoked. On the other hand, if we
callSystem.out.print(game) , where game is aOneRowNim , then the
OneRowNim.toString() method is invoked.
The beauty of using polymorphism in this way is the ﬂexibility and
extensibility that it allows. The print() andprintln() methods can Extensibility
print any type of object, even new types of objects that did not e xist when
these library methods were written.
SELF-STUDY EXERCISES
EXERCISE 8.1 To conﬁrm that the print() andprintln() methods
are implemented along the lines that we suggest here, compil e and run the
TestPrint program shown here. Describe how it conﬁrms our claim.
☛ ✟
public c l a s s T e s t P r i n t {
public s t a t i c void main ( S t r i n g args [ ] ) {
System . out . p r i n t l n ( new Double ( 5 6 ) ) ;
System . out . p r i n t l n ( new T e s t P r i n t ( ) ) ;
}
}
✡ ✠
EXERCISE 8.2 Override the toString() method in the TestPrint
class and rerun the experiment. Describe how this adds furth er conﬁrma-
tion to our claim.
8.2.5 Using super to Refer to the Superclass
One question that might occur to you is: Once you override the default
toString() method, is it then impossible to invoke the default method
on aStudent object? The default toString() method (and any method
from an object’s superclass) can be invoked using the super keyword. For
example, suppose that within the Student class, you wanted to concate-
nate the result of both the default and the new toString() methods.
The following expression would accomplish that:
☛ ✟
super . t o S t r i n g ( ) + t o S t r i n g ( )
✡ ✠
SECTION 8.2 •Java’s Inheritance Mechanism 357
Thesuper keyword speciﬁes that the ﬁrst toString() is the one imple-
mented in the superclass. The second toString() refers simply to the
version implemented within the Student class. We will see additional Keyword super
examples of using the super keyword in the following sections.
SELF-STUDY EXERCISES
EXERCISE 8.3 Consider the following class deﬁnitions and determine
the output that would be generated by the code segment.
☛ ✟
public c l a s s A{
public void method ( ) {System . out . p r i n t l n ( ”A” ) ;}
}
public c l a s s Bextends A{
public void method ( ) {System . out . p r i n t l n ( ”B” ) ;}
}
// D e t e r m i n e t h e o u t p u t f r o m t h i s c o d e s e g m e n t
A a = new A ( ) ;
a . method ( ) ;
a = new B ( ) ;
a . method ( ) ;
B b = new B ( ) ;
b . method ( ) ;
✡ ✠
EXERCISE 8.4 For the class Bdeﬁned in the previous exercise, modify
itsmethod() so that it invokes A’s version of method() before printing
outB.
EXERCISE 8.5 Given the deﬁnitions of the classes AandB, which of the
following statements are valid? Explain.
☛ ✟
A a = new B ( ) ;
a = new A ( ) ;
B b = new A ( ) ;
b = new B ( ) ;
✡ ✠
8.2.6 Inheritance and Constructors
Java’s inheritance mechanism applies to a class’s public an d protected in-
stance variables and methods. It does not apply to a class’s co nstructors.
358 CHAPTER 8 •Inheritance and Polymorphism
To illustrate some of the implications of this language feat ure, let’s deﬁne
a subclass of Student calledCollegeStudent :
☛ ✟
public c l a s s CollegeStudent extends Student {
public CollegeStudent ( ) { }
public CollegeStudent ( S t r i n g s ) {
super ( s ) ;
}
public S t r i n g t o S t r i n g ( ) {
return ”My name i s ” + name +
” and I am a CollegeStudent . ” ;
}
}
✡ ✠
Because CollegeStudent is a subclass of Student , it inherits the pub-
lic and protected instance methods and variables from Student . So, a
CollegeStudent has an instance variable for name and it has a public
getName() method. Recall that a protected element, such as the name
FIGURE 8.4 The class hierarchy for
CollegeStudent .variable in the Student class, is accessible only within the class and its
subclasses. Unlike public elements, it is not accessible to other classes.
Note that CollegeStudent overrides the toString() method, giv-
ing it a more customized implementation. The hierarchical r elationship
between CollegeStudent andStudent is shown in Figure 8.4. A
CollegeStudent is aStudent and both are Object s.
Note how we have implemented the CollegeStudent(String s)
constructor. Because the superclass’s constructors are no t inherited, we
have to implement this constructor in the subclass if we want to be able
to assign a CollegeStudent ’s name during object construction. The
method call, super(s) , is used to invoke the superclass constructor and
pass it s, the student’s name. The superclass constructor will then a ssign s
to thename variable.
As we have noted, a subclass does not inherit constructors fr om its
superclasses. However, if the subclass constructor does not explicitly in- Constructor chaining
voke a superclass constructor, Java will automatically inv oke the default
superclass constructor—in this case, super() . By “default superclass
constructor” we mean the constructor that has no parameters . For a sub-
class that is several layers down in the hierarchy, this auto matic invoking
of thesuper() constructor will be repeated upwards through the entire
class hierarchy. Thus when a CollegeStudent is constructed, Java will
automatically call Student() andObject() . Note that if one of the
superclasses does not contain a default constructor, this w ill result in a
syntax error.
If you think about this, it makes good sense. How else will the in -
herited elements of the object be created? For example, in ord er for a
CollegeStudent to have a name variable, a Student object, where
name is declared, must be created. The CollegeStudent constructor
then extends the deﬁnition of the Student class. Similarly, in order for a
Student object to have the attributes common to all objects, an Object
instance must be created and then extended into a Student .
Thus, unless a constructor explicitly calls a superclass co nstructor, Java
will automatically invoke the default superclass construc tors. It does this
SECTION 8.3 •Abstract Classes, Interfaces, and Polymorphism 359
before executing the code in its own constructor. For example, if yo u had
two classes, AandB, where Bis a subclass of A, then whenever you create
an instance of B, Java will ﬁrst invoke A’s constructor before executing the
code in B’s constructor. Thus, Java’s default behavior during const ruction
ofBis equivalent to the following implementation of B’s constructor:
☛ ✟
public B ( ){
A ( ) ; // C a l l t h e s u p e r c o n s t r u c t o r
// Now c o n t i n u e w i t h t h i s c o n s t r u c t o r ’ s c o d e
}
✡ ✠
Calls to the default constructors are made all the way up the c lass hierar-
chy, and the superclass constructor is always called before the code in the
class’s constructor is executed.
SELF-STUDY EXERCISES
EXERCISE 8.6 Consider the following class deﬁnitions and describe
what would be output by the code segment.
☛ ✟
public c l a s s A{
public A( ){System . out . p r i n t l n ( ”A” ) ;}
}
public c l a s s Bextends A{
public B ( ){System . out . p r i n t l n ( ”B” ) ;}
}
public c l a s s Cextends B{
public C( ){System . out . p r i n t l n ( ”C” ) ;}
}
// D e t e r m i n e t h e o u t p u t .
A a = new A ( ) ;
B b = new B ( ) ;
C c = new C ( ) ;
✡ ✠
8.3 Abstract Classes, Interfaces,
and Polymorphism
In Java, there are three kinds of polymorphism:
•Overriding an inherited method.
•Implementing an abstract method.
•Implementing a Java interface.
In the previous section we saw examples of the ﬁrst type of poly mor-
phism. All forms of polymorphism are based on Java’s dynamic binding
mechanism. In this section we will develop an example that ill ustrates
the other two types of polymorphism and discuss some of the de sign
implications involved in choosing one or the other approach .
360 CHAPTER 8 •Inheritance and Polymorphism
8.3.1 Implementing an Abstract Method
An important feature of polymorphism is the ability to invok e a polymor-
phic method that has been deﬁned only abstractly in the super class. To
illustrate this feature, we will develop a hierarchy of simu lated animals
that make characteristic animal sounds, an example that is w idely used to
illustrate polymorphism.
As we all know from our childhood, animals have distinctive w ays of
speaking. A cow goes “moo”; a pig goes “oink”; and so on. Let’s design Extensibility
a hierarchy of animals that simulates this characteristic b y printing the
characteristic sounds that these animals make. We want to de sign our
classes so that any given animal will return something like “ I am a cow
and I go moo,” when we invoke the toString() method. Moreover, we
want to design this collection of classes so that it is extens ible—that is, so
that we can continue to add new animals to our menagerie witho ut having
to change any of the code in the other classes.
Figure 8.5 provides a summary of the design we will implement . The
Animal class is an abstract class. That’s why its name is italicized in
the UML diagram. The reason that this class is abstract is bec ause its
speak() method is an abstract method , which is a method deﬁnition
that does not contain an implementation. That is, the method deﬁnition
contains just the method’s signature, not its body. Any class that contains
an abstract method, must itself be declared abstract. Here is the deﬁnition
FIGURE 8.5 TheAnimal class
hierarchy.of theAnimal class:
☛ ✟
public a b s t r a c t c l a s s Animal {
protected S t r i n g kind ; // Cow , p i g , c a t , e t c .
public Animal ( ) { }
public S t r i n g t o S t r i n g ( ) {
return ” I am a ” + kind + ” and I go ” + speak ( ) ;
}
public a b s t r a c t S t r i n g speak ( ) ; // A b s t r a c t m e t h o d
}
✡ ✠
Note how we declare the abstract method ( speak() ) and the abstract
class. Because one or more of its methods is not implemented, an abstract
class cannot be instantiated. That is, you cannot say:
☛ ✟
Animal animal = new Animal ( ) ; // E r r o r : A n i m a l i s a b s t r a c t
✡ ✠
Even though it is not necessary, we give the Animal class a constructor. If
we had left this off, Java would have supplied a default const ructor that
would be invoked when Animal subclasses are created.
Java has the following rules on using abstract methods and cl asses. Rules for abstract classes
•Any class containing an abstract method must be declared an
abstract class.
•Anabstract class cannot be instantiated. It must be subclassed.
•A subclass of an abstract class may be instantiated only if it im-
plements allof the superclass’s abstract methods. A subclass
SECTION 8.3 •Abstract Classes, Interfaces, and Polymorphism 361
that implements only some of the abstract methods must itself
be declared abstract .
•A class may be declared abstract even it contains no abstract
methods. It could, for example, contain instance variables t hat are
common to all its subclasses.
Even though an abstract method is not implemented in the supe rclass,
it can be called in the superclass. Indeed, note how the toString()
method calls the abstract speak() method. The reason that this works
in Java is due to the dynamic binding mechanism. The polymorp hic
speak() method will be deﬁned in the various Animal subclasses. When
theAnimal.toString() method is called, Java will decide which actual
speak() method to call based on what subclass of Animal is involved.
Deﬁnitions for two such subclasses are shown in Figure 8.6. In each
☛ ✟
public c l a s s Cat extends Animal {
public Cat ( ){
kind = ” c a t ” ;
}
public S t r i n g speak ( ) {
return ”meow” ;
}
}
public c l a s s Cow extends Animal {
public Cow( ){
kind = ”cow” ;
}
public S t r i n g speak ( ) {
return ”moo” ;
}
}
✡ ✠
Figure 8.6: Two Animal subclasses.
case the subclass extends the Animal class and provides its own con-
structor and its own implementation of the speak() method. Note that
in their respective constructors, we can refer to the kind instance vari-
able, which is inherited from the Animal class. By declaring kind as
aprotected variable, it is inherited by all Animal subclasses but hid-
den from all other classes. On the other hand, if kind had been declared
public , it would be inherited by Animal subclasses, but it would also
be accessible to every other class, which would violate the i nformation
hiding principle.
362 CHAPTER 8 •Inheritance and Polymorphism
Given these deﬁnitions, we can now demonstrate the power and ﬂex-
ibility of inheritance and polymorphism. Consider the foll owing code
segment:
☛ ✟
Animal animal = new Cow ( ) ;
System . out . p r i n t l n ( animal . t o S t r i n g ( ) ) ; // A cow g o e s moo
animal = new Cat ( ) ;
System . out . p r i n t l n ( animal . t o S t r i n g ( ) ) ; // A c a t g o e s meow
✡ ✠
We ﬁrst create a Cow object and then invoke its (inherited) toString()
method. It returns, “I am a cow and I go moo.” We then create a Cat
object and invoke its (inherited) toString() method, which returns, “I
am a cat and I go meow.” In other words, Java is able to determine the
appropriate implementation of speak() at run time in each case. The
invocation of the abstract speak() method in the Animal.toString()
method is a second form of polymorphism.
What is the advantage of polymorphism here? The main advantag e is
the extensibility that it affords our Animal hierarchy. We can deﬁne and Advantage of polymorphism
use completely new Animal subclasses without redeﬁning or recompiling
the rest of the classes in the hierarchy. Note that the toString() method
in the Animal class does not need to know what type of Animal sub-
class will be executing its speak() method. The toString() method
will work correctly for any subclass of Animal because every non-abstract
subclass of Animal must implement the speak() method.
To get a better appreciation of the ﬂexibility and extensibil ity of this
design, it might be helpful to consider an alternative desig n that does
not use polymorphism. One such alternative would be to deﬁne each
Animal subclass with its own speaking method. A Cow would have a
moo() method; a Cat would have a meow() method; and so forth. Given
this design, we could use a switch statement to select the appropriate
method call. For example, consider the following method deﬁ nition:
☛ ✟
public S t r i n g t a l k ( Animal a ) {
i f( ainstanceof Cow)
return ” I am a ” + kind + ” and I go ” + a . moo ( ) ;
else i f ( ainstanceof Cat )
return ” I am a ” + kind + ” and I go ” + a .meow ( ) ;
else
return ” I don ’ t know what I am” ;
}
✡ ✠
In this example, we introduce the instanceof operator, which is a built-
in boolean operator. It returns true if the object on its left-h and side is an
instance of the class on its right-hand side.
Thetalk() method would produce more or less the same result. If
you call talk(new Cow()) , it will return “I am a cow and I go moo.”
However, with this design, it is not possible to extend the Animal hierar-
chy without rewriting and recompiling the talk() method.
Thus, one of the chief advantages of using polymorphism is th e great
ﬂexibility and extensibility it affords. We can deﬁne new Animal sub- Extensibility
classes and deﬁne their speak() methods. These will all work with the
SECTION 8.3 •Abstract Classes, Interfaces, and Polymorphism 363
toString() method in the Animal class, without any need to revise that
method.
Another advantage of using abstract methods is the control t hat it gives
the designer of the Animal hierarchy. By making it an abstract class with
an abstract speak() method, any non-abstract Animal subclass must im-
plement the speak() method. This lends a great degree of predictabil-
ity to the subclasses in the hierarchy, making it easier to us e them in
applications.
SELF-STUDY EXERCISES
EXERCISE 8.7 Following the examples in this section, deﬁne an
Animal subclass named Pig, which goes “oink.”
EXERCISE 8.8 Show how you would have to modify the talk()
method deﬁned above to incorporate the Pig class.
8.3.2 Implementing a Java Interface
A third form of polymorphism results through the implementa tion of Java
interfaces , which are like classes but contain only abstract method def -
initions and constants ( final ) variables. An interface cannot contain Java interface
instance variables. We have already seen interfaces, such a s when we
encountered the ActionListener interface in Chapter 4.
The designer of an interface speciﬁes what methods will be im ple-
mented by classes that implement the interface. This is similar to what we
did when we implemented the abstract speak() method in the animal
example. The difference between implementing a method from an inter-
face and from an abstract superclass is that a subclass extends an abstract
superclass but it implements an interface.
Java’s interface mechanism gives us another way to design po lymor-
phic methods. To see how this works, we will provide an altern ative
design for our animal hierarchy. Rather than deﬁning speak() as an
abstract method within the Animal superclass, we will deﬁne it as an
abstract method in the Speakable interface (Fig. 8.7).
☛ ✟
public i n t e r f a c e Speakable {
public S t r i n g speak ( ) ;
}
public c l a s s Animal {
protected S t r i n g kind ; // Cow , p i g , c a t , e t c .
public Animal ( ) { }
public S t r i n g t o S t r i n g ( ) {
return ” I am a ” + kind + ” and I go ” +
( ( Speakable ) t h i s ) . speak ( ) ;
}
}
✡ ✠
Figure 8.7: Deﬁning and using the Speakable interface.
Note the differences between this deﬁnition of Animal and the pre-
vious deﬁnition. This version no longer contains the abstra ctspeak()
364 CHAPTER 8 •Inheritance and Polymorphism
method. Therefore, the class itself is not an abstract class . However, be-
cause the speak() method is not declared in this class, we cannot call the
speak() method in the toString() method, unless we cast this object
into aSpeakable object.
We encountered the cast operation in Chapter 5, where we used it with
primitive types such as (int) and(char) . Here, we use it to specify Cast operation
the actual type of some object. In this toString() example, this ob-
ject is some type of Animal subclass, such as a Cat. The cast operation,
(Speakable) , changes the object’s actual type to Speakable , which
syntactically allows its speak() method to be called.
Given these deﬁnitions, Animal subclasses will now extend the
Animal class and implement theSpeakable interface:
☛ ✟
public c l a s s Cat extends Animal implements Speakable {
public Cat ( ){kind = ” c a t ” ;}
public S t r i n g speak ( ) {return ”meow” ;}
}
public c l a s s Cow extends Animal implements Speakable {
public Cow( ){kind = ”cow” ;}
public S t r i n g speak ( ) {return ”moo” ;}
}
✡ ✠
To implement a Java interface, one must provide a method impl ementa-
tion for each of the abstract methods in the interface. In this case there is
only one abstract method, the speak() method.
Note, again, the expression from the Animal.toString() class
☛ ✟
( ( Speakable ) t h i s ) . speak ( ) ;
✡ ✠
which casts this object into a Speakable object. The reason that this cast
is required is because an Animal does not necessarily have a speak()
method. A speak() method is not deﬁned in the Animal class. How-
ever, the Cat subclass of Animal does implement a sleep() method as
part of its Speakable interface. Therefore, in order to invoke speak()
on an object from one of the Animal subclasses, the object must actually
be aSpeakable and we must perform the cast as shown here.
This illustrates, by the way, that a Cat, by virtue of extending the Interface inheritance
Animal class and implementing the Speakable interface, is both an
Animal and aSpeakable . In general, a class that implements an in-
terface, has that interface as one of its types. Interface imp lementation is
itself a form of inheritance. A Java class can be a direct subc lass of only
one superclass. But it can implement any number of interface s.
Given these deﬁnitions of the Cow andCat subclasses, the following
code segment will produce the same results as in the previous section.
☛ ✟
Animal animal = new Cow ( ) ;
System . out . p r i n t l n ( animal . t o S t r i n g ( ) ) ; // A cow g o e s moo
animal = new Cat ( ) ;
System . out . p r i n t l n ( animal . t o S t r i n g ( ) ) ; // A c a t g o e s meow
✡ ✠
SECTION 8.4 •Example: A Toggle Button 365
Although the design is different, both approaches produce t he same re-
sult. We will put off, for now, the question of how one decides whether
to use an abstract method or a Java interface. We will get to th is question
when we design the TwoPlayerGame class hierarchy later in this chapter.
8.4 Example: A Toggle Button
The ability to extend an existing class is one of the most powe rful fea- Reusing code
tures of object-oriented programming. It allows objects to reu se code
deﬁned in the superclasses without having to redeﬁne or reco mpile the
code. As we saw in Chapter 4, a programmer-deﬁned applet, suc h
asGreeterApplet , uses the public methods deﬁned for JApplet s,
JPanel s,Container s,Component s, andObject s simply because it is
a subclass of JApplet (Fig. 4.11). By the same token, it can use all of
thepublic andprotected instance variables and constants deﬁned in
these classes by simply referring to them in its own code.
In this section, we present an example of how inheritance can b e used
to extend and customize the functionality of a Java library c lass. As we
saw in Chapter 4, a JButton is a GUI component that can be associated
with a particular action by implementing the ActionListener interface.
For example, we used a JButton in theGreeterApplet to generate a
greeting to the user.
In this section, we will design a more sophisticated button. W e will
call it a ToggleButton and deﬁne it as a JButton subclass that toggles Problem decomposition
its label whenever it is clicked, in addition to carrying out some kind of
associated action.
A light switch behaves similarly to a ToggleButton in this sense.
Whenever you ﬂick a light switch, it changes its label from “on” to “off,”
but it also turns the lights on or off. Although different swi tches are asso-
ciated with different lights, every light switch toggles it s label each time
it is clicked. So let’s design a ToggleButton that behaves like a light
switch.
The main idea in our design is that a ToggleButton is aJButton
that has two labels. By default, a JButton has just a single label. Thus,
because of the type of behavior we want to elicit, we need to de ﬁne
ToggleButton as a subclass of JButton with two String variables that
will serve as its alternate labels (Fig. 8.8). Note that we gi ve it a construc-
tor method that will allow us to provide the initial value of i ts two label+JButton(in str : String)
+setText(in str : String)JButton
+ToggleButton(in l1 : String, in l2 : String) 
+actionPerformed()-label1 : String
-label2 : StringToggleButton+actionPerformed()«interface»
ActionListener
FIGURE 8.8 AToggleButton isa
JButton with two labels.strings. Another important feature of a ToggleButton is that it should
act as its own ActionListener so that it can toggle its label whenever
it is clicked. Therefore, it must also implement the ActionListener
interface.
The complete deﬁnition of ToggleButton is given in Figure 8.9. Note
how we have deﬁned its constructor. Recall that the JButton class has a
constructor method with the signature JButton(String) , which allows
us to set a JButton ’s label during instantiation. We need to do the same
thing with one of ToggleButton ’s two labels. That is, when we create a
ToggleButton , we want to initialize its label to one of its two alternative
labels (here, “On” or “Off”).
366 CHAPTER 8 •Inheritance and Polymorphism
Because constructor methods are notinherited by the subclass, we want
to invoke the superclass’s constructor in the ToggleButton() construc-
tor using the super keyword. This must be done as the ﬁrst statement in
theToggleButton() constructor. By passing l1to the super construc-
tor we are making the ﬁrst string that the user gives us the def ault label
for our ToggleButton . This will be the label that appears on the button
when it is ﬁrst displayed in the applet.
Notice also in the ToggleButton() constructor that the ToggleButton
is designated as its own ActionListener , so whenever it is clicked, its
actionPerformed() method will be invoked. The actionPerformed() Swapping algorithm
method exchanges the button’s current label for its other la bel. Swapping
two values in memory is a standard programming practice used in lots
of different algorithms. In order to do it properly, you must u se a third
variable to temporarily store one of the two values you are sw apping. The
comments in actionPerformed() provide a step-by-step trace of the
values of the three variables involved.
JAVA PROGRAMMING TIP Swapping Values. It is necessary to use
a temporary variable whenever you are swapping two values, o f any
type, in memory. The temporary variable holds the ﬁrst value while
you overwrite it with the second value.
The ﬁrst statement in actionPerformed() creates a temporary String Swapping values requires a tempo-
rary variable variable named tempS and assigns it the value of label1 . Recall that
label1 was the button’s initial label. To make this example easier t o fol-
low, let’s suppose that initially label1 is “off” and that label2 is “on.”
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import javax . swing . ∗;
public c l a s s ToggleButton extends JButton
implements ActionListener {
private S t r i n g l a b e l 1 ; // T o g g l e b e t w e e n t w o l a b e l s
private S t r i n g l a b e l 2 ;
public ToggleButton ( S t r i n g l1 , S t r i n g l 2 ) {// C o n s t r u c t o r
super ( l 1 ) ; // U s e l 1 a s t h e d e f a u l t l a b e l
l a b e l 1 = l 1 ;
l a b e l 2 = l 2 ;
addActionListener ( t h i s ) ;
}
public void actionPerformed ( ActionEvent e ) {
S t r i n g tempS = l a b e l 1 ; // S wap t h e l a b e l s
l a b e l 1 = l a b e l 2 ;
l a b e l 2 = tempS ;
s e t T e x t ( l a b e l 1 ) ;
}// a c t i o n P e r f o r m e d ( )
}// T o g g l e B u t t o n
✡ ✠
Figure 8.9: Deﬁnition of the ToggleButton class.
SECTION 8.4 •Example: A Toggle Button 367
After line 1 is executed, both tempS andlabel1 contain “off” as their
value. Line 2 then assigns label2 ’s value to label1 . Now both label1
andlabel2 store “on” as their values. In line 3 we assign tempS ’s value
tolabel2 . Now label2 stores “off” and label1 stores “on,” and we
have effectively swapped their original values.
The next time we invoke actionPerformed() ,label1 andlabel2
will have their opposite values initially. Swapping them a s econd time
will assign them their initial values again. We can continue toggling their
values in this way indeﬁnitely. To complete the method, the l ast state-
ment in actionPerformed() assigns label1 ’s current value as the
newToggleButton ’s label.
Now that we have seen that a ToggleButton toggles its label be-
tween two values, what about performing an associated actio n? To do Multiple event handlers
this, we need a design involving multiple event handlers, on e to han-
dle the toggling of the button’s label and the other to handle its associ-
ated action (Fig 8.10). In this design, lightSwitch has two listeners
: ToggleApplet1: generateClickEvent()
2: actionPerformed()
2: actionPerformed()ListensListens
: JavaVirtualMachine lightSwitch : ToggleButtonFigure 8.10: The ToggleButton
has two ActionListener s.
When the button is clicked, the
JVM will call each listener’s
actionPerformed() method,
and each listener will take its own
independent action.
that respond to its events: the lightSwitch itself, as a result of the
actionPerformed() method in its class, and the ToggleApplet , as
a result of actionPerformed() method in this class.
The implementation of this design is given by ToggleApplet , an ap-
plet that uses a ToggleButton (Fig. 8.11). Like the applet we designed
in Chapter 4, this applet extends the JApplet class and implements the
ActionListener interface. In this example we use a ToggleButton
to simulate a light switch. Note that we assign the applet its elf as an
ActionListener for the lightSwitch , so that
WhenlightSwitch is clicked, the applet displays the message, “The
light is on,” or “The light is off,” in the applet’s status bar (Fig. 8.12). This
is a somewhat trivial action but it illustrates that a ToggleButton both
toggles its own label andcarries out some associated action.
TheToggleButton design satisﬁes several key design principles
of object-oriented programming. First and foremost, it uses inheri-
tance to extend the functionality of the predeﬁned JButton class—the
extensibility principle. Secondly, it encapsulates a ToggleButton ’s es- Object oriented design principles
sential behavior within the ToggleButton class itself—the modularity
368 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
import java . applet . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
import javax . swing . ∗;
public c l a s s ToggleApplet extends JApplet
implements ActionListener {
private ToggleButton l i g h t S w i t c h ;
public void i n i t ( ) {
l i g h t S w i t c h = new ToggleButton ( ” o f f ” ,”on” ) ;
getContentPane ( ) . add ( l i g h t S w i t c h ) ;
l i g h t S w i t c h . addActionListener ( t h i s ) ;
}// i n i t ( )
public void actionPerformed ( ActionEvent e ) {
showStatus ( ”The l i g h t i s ” + l i g h t S w i t c h . getText ( ) ) ;
}// a c t i o n P e r f o r m e d ( )
}// T o g g l e A p p l e t
✡ ✠
Figure 8.11: Deﬁnition of the ToggleApplet class.
Figure 8.12: When clicked,
ToggleApplet button causes
“The light is on” or “The light
is off” to appear in the applet’s
status bar.
principle. Finally, it hides the mechanism by which a ToggleButton
manages its labels—the information-hiding principle.
JAVA EFFECTIVE DESIGN Inheritance. Inheritance enables you to
specialize an object’s behavior. A ToggleButton does everything
that aJButton does, plus it can toggle its own label.
SELF-STUDY EXERCISES
EXERCISE 8.9 Write a code segment (not a whole method) to swap two
boolean variables, b1andb2.
EXERCISE 8.10 Suppose you are designing an applet that plays a card
game, and you want a single button that can be used both to deal the
cards and to collect the cards. Write a code segment that crea tes this
type of button, adds it to the applet, and designates the appl et as its
ActionListener .
SECTION 8.5 •Example: The Cipher Class Hierarchy 369
Special Topic: Historical Cryptography
Cryptography , the study of secret writing, has had a long and interest-
ing history. Modern-day cryptographic techniques employ s ophisticated
mathematics to encrypt and decrypt messages. Today’s most secure encryp-
tion schemes are safe from attack by even the most powerful co mputers.
Given our widespread dependence on computers and the Interne t, secure
encryption has become an important application area within computer
science. While the cryptographic techniques used up through World War
II are too simple to serve as the basis for modern-day encrypti on schemes,
they can provide an interesting and accessible introductio n to this impor-
tant area of computer science.
One of the earliest and simplest ciphers is the Caesar cipher, used by
Julius Caesar during the Gallic wars. According to this sche me, letters of
the alphabet are shifted by three letters, wrapping around at the end of the
alphabet:
☛ ✟
PlainText : abcdefghijklmnopqrstuvwxyz
CaesarShifted : defghijklmnopqrstuvwxyzabc
✡ ✠
When encrypting a message, you take each letter of the message and re-
place it with its corresponding letter from the shifted alph abet. To decrypt
a secret message, you perform the operation in reverse—that i s, you take
the letter from the shifted alphabet and replace it with the c orrespond-
ing letter from the plaintext alphabet. Thus, “hello” would be Caesar en-
crypted as “khoor.”
The Caesar cipher is a substitution cipher , because each letter in the
plaintext message is replaced with a substitute letter from theciphertext
alphabet. A more general form of a substitution cipher uses a keyword to
create a ciphertext alphabet:
☛ ✟
PlainText : abcdefghijklmnopqrstuvwxyz
Ciphertext : xylophneabcdfgijkmqrstuvwz
✡ ✠
In this example, the keyword “xylophone,” (with the second oremoved) is
used to set up a substitution alphabet. According to this cip her, the word
“hello” would be encrypted as “epddi.” Substitution cipher s of this form
are found frequently in cryptogram puzzles in the newspaper s.
Another type of cipher is known as a transposition cipher . In this type
of cipher, the letters in the original message are rearrange d in some me-
thodical way. A simple example would be if we reversed the let ters in
each word so that “hello” became “olleh.”
8.5 Example: The Cipher Class Hierarchy
Suppose we wish to design a collection of cipher classes, inc luding a
Caesar cipher and a transposition cipher. Because the basic operations
used in all forms of encryption are the same, both the Caesar class and Problem decomposition
theTranspose class will have methods to encrypt() anddecrypt()
messages, where each message is assumed to be a string of word s sepa-
370 CHAPTER 8 •Inheritance and Polymorphism
rated by spaces. These methods will take a String of words and trans-
late each word using the encoding method that is appropriate for that ci-
pher. Therefore, in addition to encrypt() anddecrypt() , each cipher
class will need polymorphic encode() anddecode() methods, which
take a single word and encode or decode it according to the rul es of that
particular cipher.
From a design perspective the encrypt() anddecrypt() meth-
ods will be the same for every class: They simply break the mes sage
into words and encode or decode each word. However, the encode()
anddecode() methods will be different for each different cipher. The
Caesar.encode() method should replace each letter of a word with its
substitute, whereas the Transpose.encode() method should rearrange
the letters of the word. Given these considerations, how sho uld we design
this set of classes?
Because all of the various ciphers will have the same methods , it will
be helpful to deﬁne a common Cipher superclass (Fig. 8.13). CipherObject
+encrypt(in s : String) : String
+decrypt(in s : String) : String
+encode(in s : String) : String
+decode(in s : String) : StringCipher
+encode(in s : String) : String
+decode(in s : String) : StringCaesar
+encode(in s : String) : String
+decode(in s : String) : StringTranspose
FIGURE 8.13 A hierarchy of cipher
classes. The Cipher class
implements operations common to
all ciphers. The Caesar and
Transpose classes implement
functions unique to those kinds of
ciphers.will encapsulate those features that the individual cipher classes have
in common—the encrypt() ,decrypt() ,encode() , anddecode()
methods.
Some of these methods can be implemented in the Cipher class itself.
For example, the encrypt() method should take a message in a String
parameter, encode each word in the message, and return a String result.
The following method deﬁnition will work for any cipher:
☛ ✟
public S t r i n g encrypt ( S t r i n g s ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ””) ;
StringTokenizer words = new StringTokenizer ( s ) ; // T o k e n i z e
while ( words . hasMoreTokens ( ) ) {
// E n c o d e e a c h w o r d
r e s u l t . append ( encode ( words . nextToken ( ) ) + ” ” ) ;
}
return r e s u l t . t o S t r i n g ( ) ; // R e t u r n r e s u l t
}// e n c r y p t ( )
✡ ✠
This method creates a local StringBuffer variable, result , and uses
StringTokenizer to break the original String into its component
words. It uses the encode() method to encode the word, appending
the result into result . The result is converted back into a String and
returned as the encrypted translation of s, the original message.
If we deﬁne encrypt() in the superclass, it will be inherited by all of Inheritance
Cipher ’s subclasses. Thus, if we deﬁne Caesar andTranspose as
☛ ✟
public c l a s s Caesar extends Cipher {. . .}
public c l a s s Transpose extends Cipher {. . .}
✡ ✠
instances of these classes will be able to use the encrypt() method.
On the other hand, the polymorphic encode() method cannot be
implemented within Cipher . This is because unlike the encrypt()
method, which is the same for every Cipher subclass, the encode()
method will be different for every subclass. However, by decl aring the
encode() method as abstract , we can leave its implementation up to
SECTION 8.5 •Example: The Cipher Class Hierarchy 371
theCipher subclasses. Thus, within the Cipher class, we would deﬁne
encode() anddecode() as follows:
☛ ✟
// A b s t r a c t m e t h o d s
public a b s t r a c t S t r i n g encode ( S t r i n g word ) ;
public a b s t r a c t S t r i n g decode ( S t r i n g word ) ;
✡ ✠
These declarations within the Cipher class tell the compiler that these
methods will be implemented in Cipher ’s subclasses. By deﬁning it as
abstract ,encode() can be used in the Cipher class, as it is within the
encrypt() method.
8.5.1 Class Design: Caesar
Figure 8.14 provides the full deﬁnition of the Cipher class. The
encode() anddecode() methods are declared abstract. They are in-
tended to be implemented by Cipher ’s subclasses.
☛ ✟
import java . u t i l . ∗;
public a b s t r a c t c l a s s Cipher {
public S t r i n g encrypt ( S t r i n g s ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ””) ; // U s e a S t r i n g B u f f e r
StringTokenizer words = new StringTokenizer ( s ) ; // B r e a k s i n t o i t s w o r d s
while ( words . hasMoreTokens ( ) ) { // F o r e a c h w o r d i n s
r e s u l t . append ( encode ( words . nextToken ( ) ) + ” ” ) ; // E n c o d e i t
}
return r e s u l t . t o S t r i n g ( ) ; // R e t u r n t h e r e s u l t
}// e n c r y p t ( )
public S t r i n g decrypt ( S t r i n g s ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ””) ; // U s e a S t r i n g B u f f e r
StringTokenizer words = new StringTokenizer ( s ) ; // B r e a k s i n t o w o r d s
while ( words . hasMoreTokens ( ) ) { // F o r e a c h w o r d i n s
r e s u l t . append ( decode ( words . nextToken ( ) ) + ” ” ) ; // D e c o d e i t
}
return r e s u l t . t o S t r i n g ( ) ; // R e t u r n t h e d e c r y p t i o n
}// d e c r y p t ( )
public a b s t r a c t S t r i n g encode ( S t r i n g word ) ; // A b s t r a c t m e t h o d s
public a b s t r a c t S t r i n g decode ( S t r i n g word ) ;
}// C i p h e r
✡ ✠
Figure 8.14: The abstract Cipher class.
Note again that encrypt() anddecrypt() , which are implemented
inCipher , invoke encode() anddecode() , respectively, which are de- encode() and decode() are
polymorphic clared in Cipher but implemented in Cipher ’s subclasses. Java’s dy-
namic binding mechanism will take care of invoking the appro priate im-
plementation of encode() ordecode() , depending on what type of ob-
ject is involved. For example, if caesar andtranspose areCaesar and
372 CHAPTER 8 •Inheritance and Polymorphism
Transpose objects, respectively, then the following calls to encrypt()
will cause their respective encode() methods to be invoked:
☛ ✟
// I n v o k e s c a e s a r . e n c o d e ( )
caesar . encrypt ( ” h e l l o world” ) ;
// I n v o k e s t r a n s p o s e . e n c o d e ( )
transpose . encrypt ( ” h e l l o world” ) ;
✡ ✠
Whencaesar.encrypt() is called, it will in turn invoke caesar.en-
code() —that is, it will call the encode() method implemented in the
Caesar class. When transpose.encrypt() is invoked, it will in turn
invoke transpose.encode() . In this way, each object can perform the
encoding algorithm appropriate for its type of cipher. Method polymorphism
8.5.2 Algorithm Design: Shifting Characters
TheCaesar class is deﬁned as an extension of Cipher (Fig. 8.15). The
only methods implemented in Caesar areencode() anddecode() .
Theencode() method takes a String parameter and returns a String
result. It takes each character of its parameter ( word.charAt(k) ) and
performs a Caesar shift on the character. Note how the shift i s done:
☛ ✟
ch = ( char ) (’ a ’ + ( ch−’ a ’+ 3) % 2 6 ) ; // C a e s a r s h i f t
✡ ✠
Recall from Chapter 5 that char data in Java are represented as 16-bit
integers. This enables us to manipulate characters as numbe rs. Thus, to
shift a character by 3, we simply add 3 to its integer represen tation.
☛
public c l a s s Caesar extends Cipher {
public S t r i n g encode ( S t r i n g word ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ; // I n i t i a l i z e a s t r i n g b
for (i n t k = 0 ; k <word . length ( ) ; k++) {// F o r e a c h c h a r a c t e r i n
char ch = word . charAt ( k ) ; // G e t t h e c h a r a c t e r
ch = ( char ) (’ a ’ + ( ch−’ a ’+ 3) % 2 6 ) ; // P e r f o r m c a e s a r s h i f t
r e s u l t . append ( ch ) ; // A p p e n d i t t o new s t r i n g
}
return r e s u l t . t o S t r i n g ( ) ; // R e t u r n t h e r e s u l t a s a s
}// e n c o d e ( )
public S t r i n g decode ( S t r i n g word ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ; // I n i t i a l i z e a s t r i n g b
for (i n t k = 0 ; k <word . length ( ) ; k++) {// F o r e a c h c h a r a c t e r i n
char ch = word . charAt ( k ) ; // G e t t h e c h a r a c t e r
ch = ( char ) (’ a ’ + ( ch−’ a ’ + 23) % 2 6 ) ; // P e r f o r m r e v e r s e s h
r e s u l t . append ( ch ) ; // A p p e n d i t t o new s t r i
}
return r e s u l t . t o S t r i n g ( ) ; // R e t u r n t h e r e s u l t a s a s t r i
}// d e c o d e ( )
}// C a e s a r
✡
Figure 8.15: The Caesar class.
SECTION 8.5 •Example: The Cipher Class Hierarchy 373
For example, suppose that the character ( ch) ish, which has an ASCII Character conversions
code of 104 (see Table 5.13). We want to shift it by 3, giving k, which has
a code of 107. In this case, we could simply add 3 to 104 to get the de-
sired result. However, suppose that chwas the character y, which has an
ASCII code of 121. If we simply add 3 in this case, we get 124, a cod e that
corresponds to the symbol “—,” which is not our desired result . Instead,
we want the shift in this case to “wrap around” to the beginnin g of the
alphabet, so that ygets shifted into b. In order to accomplish this we need
to do some modular arithmetic.
Let’s suppose the 26 characters atozwere numbered 0 through 25, so
that acorresponds to 0, bto 1, and so on up to zas 25. If we take any
number Nand divide it (modulo 26), we would get a number between 0
and 25. Suppose, for example, ywere numbered 24. Shifting it by 3 would
give us 27, and 27 % 26 would give us 1, which corresponds to b. So, if
theatozwere numbered 0 through 25, then we can shift any character
within that range by using the following formula:
☛ ✟
( ch + 3) % 26 // S h i f t b y 3 w i t h w r a p a r o u n d
✡ ✠
To map a character in the range atozonto the integers 0 to 25, we can
simply subtract afrom it:
☛ ✟
’ a ’−’ a ’ = 0
’ b ’−’ a ’ = 1
’ c ’−’ a ’ = 2
. . .
’ z ’−’ a ’ = 25
✡ ✠
Finally, we simply map the numbers 0 through 25 back to the cha racters a
tozto complete the shift operation:
☛ ✟
(char ) (’ a ’ + 0) = ’ a ’
(char ) (’ a ’ + 1) = ’ b ’
(char ) (’ a ’ + 2) = ’ c ’
. . .
(char ) (’ a ’ + 25) = ’ z ’
✡ ✠
Note the use here of the cast operator (char) to covert an integer into a
char .
To summarize, we can shift any character by 3 if we map it into t he
range 0 to 25, then add 3 to it mod 26, then map that result back i nto
the range atoz. Thus, shifting ywould go as follows: Modular arithmetic
374 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
(char ) (’ a ’ + ( ch−’ a ’+ 3) % 26) //
P e r f o r m C a e s a r s h i f t
(char ) (’ a ’ + ( ’ y ’−’ a ’ +3) % 26) // o n ’ y ’
(char ) ( 9 7 + (121 −97 + 3) % 26) //
Map ’ y ’ t o 0 . . 2 5
(char ) ( 9 7 + (27 % 2 6 ) ) // S h i f t b y 3 , w r a p p i n g a r o u n d
(char ) ( 9 7 + 1) // Map r e s u l t b a c k t o ’ a ’ t o ’ z ’
(char ) ( 9 8 ) //
C o n v e r t f r o m i n t t o c h a r
’ b ’
✡ ✠
Note that in decode() a reverse Caesar shift is done by shifting by 23,
which is 26−3. If the original shift is 3, we can reverse that by shifting an
additional 23. Together this gives a shift of 26, which will g ive us back our
original string.
8.5.3 Class Design: Transpose
TheTranspose class (Fig. 8.16) is structured the same as the Caesar
class. It implements both the encode() anddecode() methods. The
key element here is the transpose operation, which in this ca se is a simple
reversal of the letters in the word. Thus, “hello” becomes “o lleh”. This
is very easy to do when using the StringBuffer.reverse() method.
Thedecode() method is even simpler, because all you need to do in this
case is call encode() . Reversing the reverse of a string gives you back
the original string.
☛ ✟
public c l a s s Transpose extends Cipher {
// e n c o d e ( ) r e v e r s e s a n d r e t u r n s a w o r d
public S t r i n g encode ( S t r i n g word ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( word ) ;
return r e s u l t . reverse ( ) . t o S t r i n g ( ) ;
}// e n c o d e ( )
public S t r i n g decode ( S t r i n g word ) {
return encode ( word ) ; // J u s t c a l l e n c o d e
}// d e c o d e
}// T r a n s p o s e
✡ ✠
Figure 8.16: The Transpose class.
8.5.4 Testing and Debugging
Figure 8.17 provides a simple test program for testing Cipher and its sub-
classes. It creates a Caesar cipher and a Transpose cipher and then en-
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 375
☛ ✟
public c l a s s TestEncrypt {
public s t a t i c void main ( S t r i n g argv [ ] ) {
Caesar caesar = new Caesar ( ) ;
S t r i n g plain = ” t h i s i s the s e c r e t message” ; // H e r e ’ s t h e m e s s a g e
S t r i n g s e c r e t = caesar . encrypt ( plain ) ; // E n c r y p t t h e m e s s a g e
System . out . p r i n t l n ( ”∗∗∗∗∗∗∗∗∗ Caesar Cipher Encryption ∗∗∗∗∗∗∗∗∗ ”) ;
System . out . p r i n t l n ( ” PlainText : ” + plain ) ; // D i s p l a y t h e r e s u l t s
System . out . p r i n t l n ( ” Encrypted : ” + s e c r e t ) ;
System . out . p r i n t l n ( ”Decrypted : ” + caesar . decrypt ( s e c r e t ) ) ; // D e c r y p t
Transpose transpose = new Transpose ( ) ;
s e c r e t = transpose . encrypt ( plain ) ;
System . out . p r i n t l n ( ”\n∗∗∗∗∗∗∗∗∗ Transpose Cipher Encryption ∗∗∗∗∗∗∗∗∗ ”) ;
System . out . p r i n t l n ( ” PlainText : ” + plain ) ; // D i s p l a y t h e r e s u l t s
System . out . p r i n t l n ( ” Encrypted : ” + s e c r e t ) ;
System . out . p r i n t l n ( ”Decrypted : ” + transpose . decrypt ( s e c r e t ) ) ; // D e c r y p t
}// m a i n ( )
}// e n d T e s t E n c r y p t
✡ ✠
Figure 8.17: The TestEncrypt class.
crypts and decrypts the same sentence using each cipher. If yo u run this
program, it will produce the following output:
☛ ✟
∗∗∗∗∗∗∗∗∗ Caesar Cipher Encryption ∗∗∗∗∗∗∗∗∗
PlainText : t h i s i s the s e c r e t message
Encrypted : wklv lv wkh vhfuhw phvvdjh
Decrypted : t h i s i s the s e c r e t message
∗∗∗∗∗∗∗∗∗ Transpose Cipher Encryption ∗∗∗∗∗∗∗∗∗
PlainText : t h i s i s the s e c r e t message
Encrypted : s i h t s i eht t e r c e s egassem
Decrypted : t h i s i s the s e c r e t message
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 8.11 Modify the Caesar class so that it will allow various
sized shifts to be used. ( Hint : Use an instance variable to represent the
shift.)
EXERCISE 8.12 Modify Transpose.encode() so that it uses a rota-
tion instead of a reversal. That is, a word like “hello” shoul d be encoded
as “ohell” with a rotation of one character.
8.6 Case Study: A Two Player Game Hierarchy
In this section we will redesign our OneRowNim game to ﬁt within a hi-
erarchy of classes of two-player games, which are games that involve two
players. Many games that this characteristic: checkers, ch ess, tic-tac-toe,
guessing games, and so forth. However, there are also many gam es that
involve just 1 player: blackjack, solitaire, and others. Ther e are also games
376 CHAPTER 8 •Inheritance and Polymorphism
that involve two or more players, such as many card games. Thu s, our
redesign of OneRowNim as part of a two-player game hierarchy will not
be our last effort to design a hierarchy of game-playing clas ses. We will
certainly re-design things as we learn new Java language con structs and
as we try to extend our game library to other kinds of games.
This case study will illustrate how we can apply inheritance and poly-
morphism, as well as other object-oriented design principle s. The justiﬁca-
tion for revising OneRowNim at this point is to make it easier to design and
develop other two-player games. As we have seen, one charact eristic of
class hierarchies is that more general attributes and metho ds are deﬁned
in top-level classes. As one proceeds down the hierarchy, th e methods
and attributes become more specialized. Creating a subclas s is a matter of
specializing a given class.
8.6.1 Design Goals
One of our design goals is to revise the OneRowNim game so that it ﬁts
into a hierarchy of two-player games. One way to do this is to g ener-
alize the OneRowNim game by creating a superclass that contains those
attributes and methods that are common to all two-player gam es. The su-
perclass will deﬁne the most general and generic elements of two-player Generic superclass
games. All two-player games, including OneRowNim , will be deﬁned as
subclasses of this top-level superclass and will inherit an d possibly over-
ride its public and protected variables and methods. Also, o ur top-level
class will contain certain abstract methods, whose impleme ntations will
be given in OneRowNim and other subclasses.
A second goal is to design a class hierarchy that makes it poss ible for
computers to play the game, as well as human users. Thus, for a given
two-player game, it should be possible for two humans to play each other,
or for two computers to play each other, or for a human to play a gainst a
computer. This design goal will require that our design exhi bit a certain
amount of ﬂexibility. As we shall see, this is a situation in wh ich Java
interfaces will come in handy.
Another important goal is to design a two-player game hierar chy that
can easily be used with a variety of different user interface s, including
command-line interfaces and GUIs. To handle this feature, we will de-
velop Java interfaces to serve as interfaces between our two -player games
and various user interfaces.
8.6.2 Designing the TwoPlayerGame Class
To begin revising the design of the OneRowNim game, we ﬁrst need to
design a top-level class, which we will call the TwoPlayerGame class.
What variables and methods belong in this class? One way to ans wer
this question is to generalize our current version of OneRowNim by mov-
ing any variables and methods that apply to all two-player ga mes up to
theTwoPlayerGame class. All subclasses of TwoPlayerGame —which
includes the OneRowNim class—would inherit these elements. Figure 8.18
shows the current design of OneRowNim .
FIGURE 8.18 The current
OneRowNim class.What variables and methods should we move up to the TwoPlayer-
Game class? Clearly, the class constants, PLAYER ONE andPLAYER TWO,
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 377
apply to all two-player games. These should be moved up. On th e
other hand, the MAXPICKUP andMAXSTICKS constants apply just to the
OneRowNim game. They should remain in the OneRowNim class.
ThenSticks instance variable is a variable that only applies to the
OneRowNim game, but not to other two-player games. It should stay
in the OneRowNim class. On the other hand, the onePlaysNext vari-
able applies to all two-player games, so we will move it up to t he
TwoPlayerGame class.
Because constructors are not inherited, all of the construc tor meth-
ods will remain in the OneRowNim class. The instance methods, Constructors are not inherited
takeSticks() andgetSticks() , are particular to OneRowNim , so
they should remain there. However, the other methods, getPlayer() ,
gameOver() ,getWinner() , andreportGameState() , are methods
that would be useful to all two-player games. Therefore thes e methods
should be moved up to the superclass. Of course, while these m ethods
can be deﬁned in the superclass, some of the methods can only b e imple-
mented in subclasses. For example, the reportGameState() method
reports the current state of the game, so it has to be implemen ted in
OneRowNim . Similarly, the getWinner() method deﬁnes how the win-
ner of the game is determined, a deﬁnition that can only occur in the sub-
class. Every two-player game needs methods such as these. Th erefore,
we will deﬁne these methods as abstract methods in the superc lass. The
intention is that TwoPlayerGame subclasses will provide game-speciﬁc
implementations for these methods.
Given these considerations, we come up with the design shown in Fig-
ure 8.19. The design shown in this ﬁgure is much more complex t han
designs we have used in earlier chapters. However, the comple xity comes
from combining ideas already discussed in previous section s of this chap-
ter, so don’t be put off by it.
To begin with, notice that we have introduced two Java interf aces into
our design in addition to the TwoPlayerGame superclass. As we will
show, these interfaces lead to a more ﬂexible design and one th at can eas-
ily be extended to incorporate new two-player games. Let’s t ake each
element of this design separately.
8.6.3 The TwoPlayerGame Superclass
As we have stated, the purpose of the TwoPlayerGame class is to serve as
the superclass for all two-player games. Therefore, it shou ld deﬁne those
variables and methods that are shared by two-player games.
ThePLAYER ONE,PLAYER TWO, andonePlaysNext variables and
thegetPlayer() ,setPlayer() , and changePlayer() methods
have been moved up from the OneRowNim class. Clearly, these
variables and methods apply to all two-player games. Note th at
we have also added three new variables: nComputers ,computer1 ,
computer2 and their corresponding methods, getNComputers() and
addComputerPlayer() . We will use these elements to give our games
the ability to be played by computer programs. Because we wan t all of
our two-player games to have this capability, we deﬁne these variables
and methods in the superclass rather than in OneRowNim and subclasses
ofTwoPlayerGame .
378 CHAPTER 8 •Inheritance and Polymorphism
Figure 8.19: TwoPlayerGame is
the superclass for OneRowNim
and other two player games.
Note that the computer1 andcomputer2 variables are declared to
be of type IPlayer .IPlayer is an interface, which contains a single
method declaration, the makeAMove() method:
☛ ✟
public i n t e r f a c e I P l a y e r {
public S t r i n g makeAMove( S t r i n g prompt ) ;
}
✡ ✠
Why do we use an interface here rather than some type of game-pl aying
object? This is a good design question. Using an interface her e makes
our design more ﬂexible and extensible because it frees us fro m having to
know the names of the classes that implement the makeAMove() method.
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 379
The variables computer1 andcomputer2 will be assigned objects that
implement IPlayer via the addComputerPlayer() method.
The algorithms used in the various implementations of makeAMove() Game-dependent algorithms
aregame-dependent —they depend on the particular game being played.
It would be impossible to deﬁne a game-playing object that woul d suf-
ﬁce for all two-player games. Instead, if we want an object that plays
OneRowNim , we would deﬁne a OneRowNimPlayer and have it imple-
ment the IPlayer interface. Similarly, if we want an object that plays
checkers, we would deﬁne a CheckersPlayer and have it implement
theIPlayer interface. By using an interface here, our TwoPlayerGame
hierarchy can deal with a wide range of differently named obje cts that TheIPlayer interface
play games, as long as they implement the IPlayer interface. So, using
theIPlayer interface adds ﬂexibility to our game hierarchy and makes
it easier to extend it to new, yet undeﬁned, classes. We will d iscuss the
details of how to design a game player in one of the following s ections.
Turning now to the methods deﬁned in TwoPlayerGame , we have
already seen implementations of getPlayer() ,setPlayer() , and
changePlayer() in theOneRowNim class. We will just move those im-
plementations up to the superclass. The getNComputers() method is
the accessor method for the nComputers variable, and its implementa-
tion is routine. The addComputerPlayer() method adds a computer
player to the game. Its implementation is as follows:
☛ ✟
public void addComputerPlayer ( I P l a y e r player ) {
i f( nComputers == 0)
computer2 = player ;
else i f ( nComputers == 1)
computer1 = player ;
else
return ;// No m o r e t h a n 2 p l a y e r s
++nComputers ;
}
✡ ✠
As we noted earlier, the classes that play the various TwoPlayerGame s
must implement the IPlayer interface. The parameter for this method
is of type IPlayer . The algorithm we use checks the current value of
nComputers . If it is 0, which means that this is the ﬁrst IPlayer added
to the game, the player is assigned to computer2 . This allows the hu-
man user to be associated with PLAYERONE , if this is a game between a
computer and a human user.
IfnComputers equals 1, which means that we are adding a second
IPlayer to the game, we assign that player tocomputer1 . In ei-
ther of these cases, we increment nComputers . Note what happens
ifnComputers is neither 1 nor 2. In that case, we simply return
without adding the IPlayer to the game and without incrementing
nComputers . This, in effect, limits the number of IPlayer s to two. (A
more sophisticated design would throw an exception to repor t an error.
but we will leave that for a subsequent chapter.)
TheaddComputerPlayer() method is used to initialize a game after
it is ﬁrst created. If this method is not called, the default as sumption is
380 CHAPTER 8 •Inheritance and Polymorphism
thatnComputers equals zero and that computer1 andcomputer2 are
bothnull . Here’s an example of how it could be used:
☛ ✟
OneRowNim nim = new OneRowNim ( 1 1 ) ; // 1 1 s t i c k s
nim . add ( new NimPlayer ( nim ) ) ; // 2 c o m p u t e r p l a y e r s
nim . add ( new NimPlayerBad ( nim ) ) ;
✡ ✠
Note that the NimPlayer() constructor takes a reference to the game
as its argument. Clearly, our design should not assume that t he names of
theIPlayer objects would be known to the TwoPlayerGame superclass.
This method allows the objects to be passed in at run time. We wi ll discuss
the details of NimPlayerBad in a subsequent section.
ThegetRules() method is a new method whose purpose is to return
a string that describes the rules of the particular game. Thi s method is Overriding a method
implemented in the TwoPlayerGame class with the intention that it will
be overridden in the various subclasses. For example, its im plementation
inTwoPlayerGame is:
☛ ✟
public S t r i n g getRules ( ) {
return ”The r u l e s of t h i s game are : ” ;
}
✡ ✠
and its redeﬁnition in OneRowNim is:
☛ ✟
public S t r i n g getRules ( ) {
return ”\n∗∗∗ The Rules of One Row Nim ∗∗∗\ n”+
” ( 1 ) A number of s t i c k s between 7 and ” + MAX STICKS +
” i s chosen . \n”+
” ( 2 ) Two players a l t e r n a t e making moves . \n”+
” ( 3 ) A move c o n s i s t s of s u b t r a c t i n g between 1 and \n\t ”+
MAX PICKUP +
” s t i c k s from the current number of s t i c k s . \n”+
” ( 4 ) A player who cannot leave a p o s i t i v e \n\t ”+
” number of s t i c k s f o r the other player l o s e s . \n”;
}
✡ ✠
The idea is that each TwoPlayerGame subclass will take responsibility for
specifying its own set of rules in a form that can be displayed to the user.
You might recognize that deﬁning getRules() in the superclass and
allowing it to be overridden in the subclasses is a form of pol ymorphism. Polymorphism
It follows the design of the toString() method, which we discussed
earlier. This design will allow us to use code that takes the f ollowing form:
☛ ✟
TwoPlayerGame game = new OneRowNim ( ) ;
System . out . p r i n t l n ( game . getRules ( ) ) ;
✡ ✠
In this example the call to getRules() is polymorphic. The dynamic
binding mechanism is used to invoke the getRules() method that is
deﬁned in the OneRowNim class.
The remaining methods in TwoPlayerGame are deﬁned abstractly.
ThegameOver() andgetWinner() methods are both methods that are
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 381
game dependent . That is, the details of their implementations depend on
the particular TwoPlayerGame subclass in which they are implemented.
This is good example of how abstract methods should be used in de-
signing a class hierarchy. We give abstract deﬁnitions in th e superclass
and leave the detailed implementations up to the individual subclasses.
This allows the different subclasses to tailor the implemen tations to their
particular needs, while allowing all subclasses to share a c ommon signa-
ture for these tasks. This allows us to use polymorphism to cr eate ﬂexible,
extensible class hierarchies.
Figure 8.20 shows the complete implementation of the abstra ct
TwoPlayerGame class. We have already discussed the most important
details of its implementation.
JAVA EFFECTIVE DESIGN Abstract Methods. Abstract methods
allow you to give general deﬁnitions in the superclass and to leave the
implementation details to the different subclasses.
8.6.4 The CLUIPlayableGame Interface
Let’s turn now to the two interfaces shown in Figure 8.19. Tak en to-
gether, the purpose of these interfaces is to create a connec tion between
any two-player game and a command-line user interface (CLUI) . The
interfaces provide method signatures for the methods that w ill imple-
ment the details of the interaction between a TwoPlayerGame and a
UserInterface . Because the details of this interaction vary from game
to game, it is best to leave the implementation of these metho ds to the
games themselves.
Note that CLUIPlayableGame extends the IGame interface. The Extending an interface
IGame interface contains two methods that are used to deﬁne a stan-
dard form of communication between the CLUI and the game. The
getGamePrompt() method deﬁnes the prompt that is used to signal the
user for some kind of move—for example, “How many sticks do you
take (1, 2, or 3)?” And the reportGameState() method deﬁnes how
that particular game will report its current state—for examp le, “There
are 11 sticks remaining.” CLUIPlayableGame adds the play() method
to these two methods. As we will see shortly, the play() method will
contain the code that will control the playing of the game.
The source code for these interfaces is very simple:
☛ ✟
public i n t e r f a c e CLUIPlayableGame extends IGame{
public a b s t r a c t void play ( U s e r I n t e r f a c e ui ) ;
}
public i n t e r f a c e IGame{
public S t r i n g getGamePrompt ( ) ;
public S t r i n g reportGameState ( ) ;
}// I G a m e
✡ ✠
Notice that the CLUIPlayableGame interface extends the IGame inter-
face. A CLUIPlayableGame is a game that can be played through a
382 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
public a b s t r a c t c l a s s TwoPlayerGame {
public s t a t i c f i n a l i n t PLAYER ONE = 1 ;
public s t a t i c f i n a l i n t PLAYER TWO = 2 ;
protected boolean onePlaysNext = true ;
protected i n t nComputers = 0 ; // How many c o m p u t e r s
// C o m p u t e r s a r e I P l a y e r s
protected I P l a y e r computer1 , computer2 ;
public void s e t P l a y e r ( i n t s t a r t e r ) {
i f( s t a r t e r == PLAYER TWO)
onePlaysNext = f a l s e ;
else onePlaysNext = true ;
}// s e t P l a y e r ( )
public i n t getPlayer ( ) {
i f( onePlaysNext )
return PLAYER ONE ;
else return PLAYER TWO;
}// g e t P l a y e r ( )
public void changePlayer ( ) {
onePlaysNext = ! onePlaysNext ;
}// c h a n g e P l a y e r ( )
public i n t getNComputers ( ) {
return nComputers ;
}
public S t r i n g getRules ( ) {
return ”The r u l e s of t h i s game are : ” ;
}
public void addComputerPlayer ( I P l a y e r player ) {
i f( nComputers == 0)
computer2 = player ;
else i f ( nComputers == 1)
computer1 = player ;
else
return ; // No m o r e t h a n 2 p l a y e r s
++nComputers ;
}
public a b s t r a c t boolean gameOver ( ) ; // A b s t r a c t M e t h o d s
public a b s t r a c t S t r i n g getWinner ( ) ;
}// T w o P l a y e r G a m e
✡ ✠
Figure 8.20: The TwoPlayerGame class
CLUI. The purpose of its play() method is to contain the game depen-
dent control loop that determines how the game is played via some k ind
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 383
of user interface (UI). In pseudocode, a typical control loop f or a game
would look something like the following:
☛ ✟
I n i t i a l i z e the game .
While the game i s not over
Report the current s t a t e of the game via the UI .
Prompt the user ( or the computer ) to make a move via the UI .
Get the user ’ s move via the UI .
Make the move .
Change to the other player .
✡ ✠
The play loop sets up an interaction between the game and the U I. The
UserInterface parameter allows the game to connect directly to a par-
ticular UI. To allow us to play our games through a variety of UIs , we
deﬁne UserInterface as the following Java interface:
☛ ✟
public i n t e r f a c e U s e r I n t e r f a c e {
public S t r i n g getUserInput ( ) ;
public void report ( S t r i n g s ) ;
public void prompt ( S t r i n g s ) ;
}
✡ ✠
Any object that implements these three methods can serve as a U I for
one of our TwoPlayerGame s. This is another example of the ﬂexibility
of using interfaces in object-oriented design.
To illustrate how we use UserInterface , let’s attach it to our
KeyboardReader class, thereby letting a KeyboardReader serve as a
CLUI for TwoPlayerGame s. We do this simply by implementing this
interface in the KeyboardReader class, as follows:
☛ ✟
public c l a s s KeyboardReader implements U s e r I n t e r f a c e
✡ ✠
As it turns out, the three methods listed in UserInterface match three
of the methods in the current version of KeyboardReader . This is no
accident. The design of UserInterface was arrived at by identifying
the minimal number of methods in KeyboardReader that were needed
to interact with a TwoPlayerGame .
JAVA EFFECTIVE DESIGN Flexibility of Java Interfaces. A Java
interface provides a means of associating useful methods wi th a
variety of different types of objects, leading to a more ﬂexibl e
object-oriented design.
The beneﬁt of deﬁning the parameter more generally as a User- Generality principle
Interface , instead of as a KeyboardReader , is that we will eventu-
ally want to allow our games to be played via other kinds of com mand-
line interfaces. For example, we might later deﬁne an Interne t-based
CLUI that could be used to play OneRowNim among users on the Inter-
net. This kind of extensibility—the ability to create new kin ds of UIs and
384 CHAPTER 8 •Inheritance and Polymorphism
use them with TwoPlayerGame s— is another important design feature
of Java interfaces.
JAVA EFFECTIVE DESIGN Extensibility and Java Interfaces. Using
interfaces to deﬁne useful method signatures increases the
extensibility of a class hierarchy.
As Figure 8.19 shows, OneRowNim implements the CLUIPlayable-
Game interface, which means it must supply implementations of al l three
abstract methods: play() ,getGamePrompt() , and reportGame-
State() .
8.6.5 Object Oriented Design: Interfaces or Abstract
Classes
Why are these methods deﬁned in interfaces? Couldn’t we just as easily
deﬁne them in the TwoPlayerGame class and use inheritance to extend
them to the various game subclasses? After all, isn’t the net result the
same, namely, that OneRowNim must implement all three methods.
These are very good design questions, exactly the kinds of qu estions
one should ask when designing a class hierarchy of any sort. A s we Interfaces vs. abstract methods
pointed out in the Animal example earlier in the chapter, you can get the
same functionality from a abstract interface and from an abs tract super-
class method. When should we put the abstract method in the sup erclass
and when does it belong in an interface? A very good discussio n of these
and related object-oriented design issues is available in Java Design, 2nd
Edition , by Peter Coad and Mark Mayﬁeld (Yourdan Press, 1999). Our di s-
cussion of these issues follows many of the guidelines sugge sted by Coad
and Mayﬁeld.
We have already seen that using Java interfaces increases th e ﬂexibility
and extensibility of a design. Methods deﬁned in an interfac e exist inde-
pendently of a particular class hierarchy. By their very nat ure, interfaces
can be attached to any class, which makes them very ﬂexible to u se. Flexibility of interfaces
Another useful guideline for answering this question is tha t the super-
class should contain the basic common attributes and method s that deﬁne
a certain type of object. It should not necessarily contain met hods that
deﬁne certain roles that the object plays. For example, the gameOver()
andgetWinner() methods are fundamental parts of the deﬁnition of
aTwoPlayerGame . One cannot deﬁne a game without deﬁning these
methods. By contrast, methods such as play() ,getGamePrompt() , and
reportGameState() are important for playing the game but they do not
contribute in the same way to the game’s deﬁnition. Thus thes e methods
are best put into an interface. So, one important design guid eline is:
JAVA EFFECTIVE DESIGN Abstract Methods. Methods deﬁned
abstractly in a superclass should contribute in a fundament al way
toward the basic deﬁnition of that type of object, not merely t oward
one of its roles or its functionality.
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 385
8.6.6 The Revised OneRowNim Class
Figure 8.21 provides a listing of the revised OneRowNim class, one that ﬁts
into the TwoPlayerGame class hierarchy. Our discussion in this section
will focus on just those features of the game that are new or rev ised.
☛ ✟
public c l a s s OneRowNim extends TwoPlayerGame
implements CLUIPlayableGame {
public s t a t i c f i n a l i n t MAX PICKUP = 3 ;
public s t a t i c f i n a l i n t MAX STICKS = 1 1 ;
private i n t n S t i c k s = MAX STICKS ;
public OneRowNim ( ) { } // C o n s t r u c t o r s
public OneRowNim( i n t s t i c k s ) {
n S t i c k s = s t i c k s ;
} // OneRowNim ( )
public OneRowNim( i n t s t i c k s , i n t s t a r t e r ) {
n S t i c k s = s t i c k s ;
s e t P l a y e r ( s t a r t e r ) ;
}// OneRowNim ( )
public boolean t a k e S t i c k s ( i n t num){
i f(num<1||num>MAX PICKUP ||num>n S t i c k s )
return f a l s e ; // E r r o r
else // V a l i d move
{ n S t i c k s = n S t i c k s −num;
return true ;
}// e l s e
}// t a k e S t i c k s ( )
public i n t g e t S t i c k s ( ) {
return n S t i c k s ;
}// g e t S t i c k s ( )
public S t r i n g getRules ( ) {
return ”\n∗∗∗ The Rules of One Row Nim ∗∗∗\ n”+
” ( 1 ) A number of s t i c k s between 7 and ” + MAX STICKS +
” i s chosen . \n”+
” ( 2 ) Two players a l t e r n a t e making moves . \n”+
” ( 3 ) A move c o n s i s t s of s u b t r a c t i n g between 1 and \n\t ”+
MAX PICKUP + ” s t i c k s from the current number of s t i c k s . \n”+
” ( 4 ) A player who cannot leave a p o s i t i v e \n\t ”+
” number of s t i c k s f o r the other player l o s e s . \n”;
}// g e t R u l e s ( )
public boolean gameOver ( ) { /∗∗ F r o m T w o P l a y e r G a m e ∗/
return ( n S t i c k s <= 0 ) ;
} // g a m e O v e r ( )
public S t r i n g getWinner ( ) { /∗∗ F r o m T w o P l a y e r G a m e ∗/
i f( gameOver ( ) ) //{
return ””+ getPlayer ( ) + ” Nice game . ” ;
return ”The game i s not over yet . ” ; // Game i s n o t o v e r
}// g e t W i n n e r ( )
✡ ✠
Figure 8.21: The revised OneRowNim class, Part I.
ThegameOver() andgetWinner() methods, which are now inher-
ited from the TwoPlayerGame superclass, are virtually the same as in the
386 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
/∗∗ F r o m C L U I P l a y a b l e G a m e ∗/
public S t r i n g getGamePrompt ( ) {
return ”\nYou can pick up between 1 and ” +
Math . min (MAX PICKUP, n S t i c k s ) + ” : ” ;
}// g e t G a m e P r o m p t ( )
public S t r i n g reportGameState ( ) {
i f( ! gameOver ( ) )
return (”\n S t i c k s l e f t : ” + g e t S t i c k s ( ) +
” Who ’ s turn : Player ” + getPlayer ( ) ) ;
else
return (”\n S t i c k s l e f t : ” + g e t S t i c k s ( ) +
” Game over ! Winner i s Player ” + getWinner ( ) + ”\n”) ;
} // r e p o r t G a m e S t a t e ( )
public void play ( U s e r I n t e r f a c e ui ) {// F r o m C L U I P l a y a b l e G a m e i n t e r f a c e
i n t s t i c k s = 0 ;
ui . report ( getRules ( ) ) ;
i f( computer1 != null )
ui . report ( ”\nPlayer 1 i s a ” + computer1 . t o S t r i n g ( ) ) ;
i f( computer2 != null )
ui . report ( ”\nPlayer 2 i s a ” + computer2 . t o S t r i n g ( ) ) ;
while ( ! gameOver ( ) ) {
I P l a y e r computer = null ; // A s s u m e n o c o m p u t e r s
ui . report ( reportGameState ( ) ) ;
switch ( getPlayer ( ) ) {
case PLAYER ONE : // P l a y e r 1 ’ s t u r n
computer = computer1 ;
break ;
case PLAYER TWO: // P l a y e r 2 ’ s t u r n
computer = computer2 ;
break ;
}// c a s e s
i f( computer != null ){ // I f c o m p u t e r ’ s t u r n
s t i c k s = I n t e g e r . p a r s e I n t ( computer . makeAMove( ””) ) ;
ui . report ( computer . t o S t r i n g ( ) + ” takes ” +
s t i c k s + ” s t i c k s . \n”) ;
}else{ // o t h e r w i s e , u s e r ’ s t u r n
ui . prompt ( getGamePrompt ( ) ) ;
s t i c k s =
I n t e g e r . p a r s e I n t ( ui . getUserInput ( ) ) ; // G e t u s e r ’ s move
}
i f( t a k e S t i c k s ( s t i c k s ) ) // I f a l e g a l move
changePlayer ( ) ;
}// w h i l e
ui . report ( reportGameState ( ) ) ; // T h e g a m e i s now o v e r
}// p l a y ( )
}// OneRowNim c l a s s
✡ ✠
Figure 8.22: The revised OneRowNim class, continued from previous page.
previous version. One small change is that getWinner() now returns a
String instead of an int. This makes that method more generally useful
as a way of identifying the winner for all TwoPlayerGame s.
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 387
Similarly, the getGamePrompt() andreportGameState() meth-
ods merely encapsulate functionality that was present in th e earlier ver-
sion of the game. In our earlier version the prompts to the user were
generated directly by the main program. By encapsulating th is infor- Inheritance and generality
mation in an inherited method, we make it more generally usef ul to all
TwoPlayerGame s.
The major change to OneRowNim comes in the play() method, which
controls the playing of the OneRowNim (Fig. 8.22). Because this version
of the game incorporates computer players, the play loop is a bit more
complex than in earlier versions of the game. The basic idea i s still the
same: The method loops until the game is over. On each iterati on of the
loop, one or the other of the two players, PLAYER ONE orPLAYER TWO,
takes a turn making a move—that is, deciding how many sticks to pick
up. If the move is a legal move, then it becomes the other player ’s turn.
Let’s look now at how the code distinguishes between whether it is
a computer’s turn to move or a human player’s turn. Note that a t the
beginning of the while loop, it sets the computer variable to null. It
then assigns computer a value of either computer1 orcomputer2 , de-
pending on whose turn it is. But recall that one or both of thes e vari-
ables may be null , depending on how many computers are playing the
game. If there are no computers playing the game, then both var iables
will be null. If only one computer is playing, then computer1 will
be null. This is determined during initialization of the gam e, when the
addComputerPlayer() is called. (See above.)
In the code following the switch statement, if computer is notnull ,
then we call computer.makeAMove() . As we know, the makeAMove()
method is part of the IPlayer interface. The makeAMove() method
takes a String parameter that is meant to serve as a prompt, and returns
aString that is meant to represent the IPlayer ’s move:
☛ ✟
public i n t e r f a c e I P l a y e r {
public S t r i n g makeAMove( S t r i n g prompt ) ;
}
✡ ✠
InOneRowNim the “move” is an integer, representing the number of sticks
the player picks. Therefore, in play() OneRowNim has to convert the
String into an int, which represents the number of sticks the IPlayer
picks up.
On the other hand, if computer isnull , this means that it is a human
user’s turn to play. In this case, play() callsui.getUserInput() , em-
ploying the user interface to input a value from the keyboard . The user’s
input must also be converted from String toint. Once the value of
sticks is set, either from the user or from the IPlayer , theplay()
method calls takeSticks() . If the move is legal, then it changes whose
turn it is, and the loop repeats.
There are a couple of important points to notice about the des ign of
theplay() method. First, the play() method has to know what to do Encapsulation of game-dependent
knowledge with the input it receives from the user or the IPlayer . This is game-
dependent knowledge. The user is inputting the number of sti cks to
take in OneRowNim . For a tic-tac-toe game, the “move” might repre-
sent a square on the tic-tac-toe board. This suggests that play() is a
388 CHAPTER 8 •Inheritance and Polymorphism
method that should be implemented in OneRowNim , as it is here, because
OneRowNim encapsulates the knowledge of how to play the One Row
Nim game.
A second point is to notice that the method call computer.make-
AMove() is another example of polymorphism at work. The play() Polymorphism
method does not know what type of object the computer is, other than
that it is an IPlayer —that is, an object that implements the IPlayer
interface. As we will show in the next section, the OneRowNim game can
be played by two different IPlayer s: one named NimPlayer and an-
other named NimPlayerBad . Each has its own game-playing strategy, as
implemented by their own versions of the makeAMove() method. Java
uses dynamic binding to decide which version of makeAMove() to in-
voke depending on the type of IPlayer whose turn it is. Thus, by deﬁn-
ing different IPlayer s with different makeAMove() methods, this use of
polymorphism makes it possible to test different game-play ing strategies
against each other.
8.6.7 The IPlayer Interface
The last element of our design is the IPlayer interface, which, as we
just saw, consists of the makeAMove() method. To see how we use this
interface, let’s design a class to play the game of OneRowNim . We will call
the class NimPlayerBad and give it a very weak playing strategy. For
each move it will pick a random number between 1 and 3, or betwe en 1
and the total number of sticks left, if there are fewer than 3 s ticks. (We will
leave the task of deﬁning NimPlayer , a good player, as an exercise.)
FIGURE 8.23 Design of the
NimPlayerBad class.As an implementer of the IPlayer interface, NimPlayerBad will
implement the makeAMove() method. This method will contain
NimPlayerBad ’s strategy (algorithm) for playing the game. The result
of this strategy will be the number of sticks that the player w ill pick up.
What other elements (variables and methods) will a NimPlayerBad
need? Clearly, in order to play OneRowNim , the player must know the
rules and the current state of the game. The best way to achiev e this is to
give the Nim player a reference to the OneRowNim game. Then it can call
getSticks() to determine how many sticks are left, and it can use other
public elements of the OneRowNim game. Thus, we will have a variable of
typeOneRowNim , and we will assign it a value in a constructor method.
Figure 8.23 shows the design of NimPlayerBad . Note that we have
added an implementation of the toString() method. This will be used
to give a string representation of the NimPlayerBad . Also, note that we
have added a private helper method named randomMove() , which will
simply generate an appropriate random number of sticks as th e player’s
move.
The implementation of NimPlayerBad is shown in Figure 8.24. The
makeAMove() method converts the randomMove() to aString and
returns it, leaving it up to OneRowNim , the calling object, to convert
that move back into an int. Recall the statement in OneRowNim where
makeAMove() is invoked:
☛ ✟
s t i c k s = I n t e g e r . p a r s e I n t ( computer . makeAMove( ””) ) ;
✡ ✠
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 389
☛ ✟
public c l a s s NimPlayerBad implements I P l a y e r {
private OneRowNim game ;
public NimPlayerBad (OneRowNim game ) {
t h i s . game = game ;
}// N i m P l a y e r B a d ( )
public S t r i n g makeAMove( S t r i n g prompt ) {
return ””+ randomMove ( ) ;
}// makeAMove ( )
private i n t randomMove ( ) {
i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
return 1 + ( i n t) ( Math . random ( ) ∗
Math . min ( s t i c k s L e f t , game . MAX PICKUP ) ) ;
}// r a n d o m M o v e ( )
public S t r i n g t o S t r i n g ( ) {
S t r i n g className =
t h i s . getClass ( ) . t o S t r i n g ( ) ; // G e t s ’ c l a s s N i m P l a y e r B a d ’
return className . substring ( 5 ) ; // C u t o f f t h e w o r d ’ c l a s s ’
}// t o S t r i n g ( )
}// N i m P l a y e r B a d
✡ ✠
Figure 8.24: The NimPlayerBad class.
In this context, the computer variable, which is of type IPlayer , is
bound to a NimPlayerBad object. In order for this interaction between
the game and a player to work, the OneRowNim object must know what
type of data is being returned by NimPlayerBad . This is a perfect use for
a Java interface, which speciﬁes the signature of makeAMove() without
committing to any particular implementation of the method. Thus, the
association between OneRowNim andIPlayer provides a ﬂexible and
effective model for this type of interaction.
JAVA EFFECTIVE DESIGN Interface Associations. Java interfaces
provide a ﬂexible way to set up associations between two diffe rent
types of objects.
Finally, note the details of the randomMove() andtoString() meth-
ods. The only new thing here is the use of the getClass() method in
toString() . This is a method that is deﬁned in the Object class and
inherited by all Java objects. It returns a String of the form “class X”
where Xis the name of that object’s class. Note here that we are removi ng
the word “class” from this string before returning the class name. This
allows our IPlayer objects to report what type of players they are, as in
the following statement from OneRowNim :
☛ ✟
ui . report ( ”\nPlayer 1 i s a ” + computer1 . t o S t r i n g ( ) ) ;
✡ ✠
Ifcomputer1 is aNimPlayerBad , it would report “Player1 is a Nim-
PlayerBad.”
390 CHAPTER 8 •Inheritance and Polymorphism
SELF-STUDY EXERCISES
EXERCISE 8.13 Deﬁne a class NimPlayer that plays the optimal strat-
egy for OneRowNim . This strategy was described in Chapter 5.
8.6.8 Playing OneRowNim
Let’s now write a main() method to play OneRowNim :
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
KeyboardReader kb = new KeyboardReader ( ) ;
OneRowNim game = new OneRowNim ( ) ;
kb . prompt ( ”How many computers are playing , 0 , 1 , or 2? ” ) ;
i n t m = kb . getKeyboardInteger ( ) ;
for (i n t k = 0 ; k <m; k++) {
kb . prompt ( ”What type of player , ” +
”NimPlayerBad = 1 , or NimPlayer = 2 ? ” ) ;
i n t choice = kb . getKeyboardInteger ( ) ;
i f( choice == 1) {
I P l a y e r computer = new NimPlayerBad ( game ) ;
game . addComputerPlayer ( computer ) ;
}else{
I P l a y e r computer = new NimPlayer ( game ) ;
game . addComputerPlayer ( computer ) ;
}
}
game . play ( kb ) ;
}// m a i n ( )
✡ ✠
After creating a KeyboardReader and then creating an instance of
OneRowNim , we prompt the user to determine how many computers are
playing. We then repeatedly prompt the user to identify the n ames of the
IPlayer and use the addComputerPlayer() method to initialize the
game. Finally, we get the game started by invoking the play() method,
passing it a reference to the KeyboardReader , ourUserInterface .
Note that in this example we have declared a OneRowNim variable to
represent the game. This is not the only way to do things. For e xample,
suppose we wanted to write a main() method that could be used to play
a variety of different TwoPlayerGame s. Can we make this code more Generality
general? That is, can we rewrite it to work with any TwoPlayerGame ?
AOneRowNim object is also a TwoPlayerGame , by virtue of inheri-
tance, and it is also a CLUIPlayableGame , by virtue of implementing
that interface. Therefore, we can use either of these types t o represent the
game. Thus, one alternative way of coding this is as follows:
☛ ✟
TwoPlayerGame game = new OneRowNim ( ) ;
. . .
I P l a y e r computer = new NimPlayer ( ( OneRowNim) game ) ;
. . .
( ( CLUIPlayableGame ) game ) . play ( kb ) ;
✡ ✠
Here we use a TwoPlayerGame variable to represent the game. However,
note that we now have to use a cast expression, (CLUIPlayableGame) ,
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 391
in order to call the play() method. If we don’t cast game in this way,
Java will generate the following syntax error:
☛ ✟
OneRowNim . java : 1 2 6 : cannot r e s o l v e symbol
symbol : method play ( KeyboardReader )
l o c a t i o n : c l a s s TwoPlayerGame
game . play ( kb ) ;
ˆ
✡ ✠
The reason for this error is that play() is not a method in the
TwoPlayerGame class, so the compiler cannot ﬁnd the play() method.
By using the cast expression, we are telling the compiler to c onsider
game to be a CLUIPlayableGame . That way it will ﬁnd the play()
method. Of course, the object assigned to nim must actually implement
theCLUIPlayableGame interface in order for this to work at run time.
We also need a cast operation in the NimPlayer() constructor in or-
der to make the argument ( computer ) compatible with that method’s
parameter.
Another alternative for the main() method would be the following:
☛ ✟
CLUIPlayableGame game = new OneRowNim ( ) ;
. . .
I P l a y e r computer = new NimPlayer ( ( OneRowNim) game ) ;
( ( TwoPlayerGame ) game ) . addComputerPlayer ( computer ) ;
. . .
game . play ( kb ) ;
nim . play ( kb ) ;
✡ ✠
By representing the game as a CLUIPlayableGame variable, we don’t
need the cast expression to call play() , but we do need a different cast
expression, (TwoPlayerGame) , to invoke addComputerPlayer() .
Again, the reason is that the compiler cannot ﬁnd the addComputer-
Player() method in the CLUIPlayableGame interface, so we must tell
it to consider game as aTwoPlayerGame , which of course it is. We still
need the cast operation for the call to the NimPlayer() constructor.
All three of the code options that we have considered will gen erate
something like the interactive session shown in Figure 8.25 for a game
in which two IPlayer s play each other.
Given our object-oriented design for the TwoPlayerGame hierarchy,
we can now write generalized code that can play any TwoPlayerGame
that implements the CLUIPlayableGame interface. We will give a spe-
ciﬁc example of this in the next section.
8.6.9 Extending the TwoPlayerGame Hierarchy
Now that we have described the design and the details of the
TwoPlayerGame class hierarchy, let’s use it to develop a new game. If
we’ve gotten the design right, developing new two-player ga mes and
adding them to the hierarchy should be much simpler than deve loping
them from scratch.
392 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
How many computers are playing , 0 , 1 , or 2? {\c o l o r{cyan}2}
∗∗∗ The Rules of One Row Nim ∗∗∗
( 1 ) A number of s t i c k s between 7 and 11 i s chosen .
( 2 ) Two players a l t e r n a t e making moves .
( 3 ) A move c o n s i s t s of s u b t r a c t i n g between 1 and
3 s t i c k s from the current number of s t i c k s .
( 4 ) A player who cannot leave a p o s i t i v e
number of s t i c k s for the other player l o s e s .
Player 1 i s a NimPlayerBad
Player 2 i s a NimPlayer
S t i c k s l e f t : 11 Who ’ s turn : Player 1 NimPlayerBad takes 2 s t i c k s .
S t i c k s l e f t : 9 Who ’ s turn : Player 2 NimPlayer takes 1 s t i c k s .
S t i c k s l e f t : 8 Who ’ s turn : Player 1 NimPlayerBad takes 2 s t i c k s .
S t i c k s l e f t : 6 Who ’ s turn : Player 2 NimPlayer takes 1 s t i c k s .
S t i c k s l e f t : 5 Who ’ s turn : Player 1 NimPlayerBad takes 3 s t i c k s .
S t i c k s l e f t : 2 Who ’ s turn : Player 2 NimPlayer takes 1 s t i c k s .
S t i c k s l e f t : 1 Who ’ s turn : Player 1 NimPlayerBad takes 1 s t i c k s .
S t i c k s l e f t : 0 Game over ! Winner i s Player 2 Nice game .
✡ ✠
Figure 8.25: A typical run of the OneRowNim using a command-line user
interface.
The new game is a guessing game in which the two players take tu rns
guessing a secret word. The secret word will be generated ran domly from
a collection of words maintained by the game object. The lette rs of the
word will be hidden with question marks, as in “????????.” On each turn
a player guesses a letter. If the letter is in the secret word, i t replaces one
or more question marks, as in “??????E?.” A player continues to guess
until an incorrect guess is made and then it becomes the other player’s
turn. Of course, we want to develop a version of this game that can be
played either by two humans, or by one human against a compute r—that
is, against an IPlayer —or by two different IPlayer s.
Let’s call the game class WordGuess . Following the design
ofOneRowNim , we get the design shown in Figure 8.26. The
WordGuess class extends the TwoPlayerGame class and implements the
CLUIPlayableGame interface. We don’t show the details of the inter-
faces and the TwoPlayerGame class, as these have not changed. Also,
following the design of NimPlayerBad , theWordGuesser class imple-
ments the IPlayer interface. Note how we show the association between
WordGuess and zero or more IPlayer s. AWordGuess uses between
zero and two instances of IPlayer s, which in this game are implemented
asWordGuesser s.
Let’s turn now to the details of the WordGuess class, whose source
code is shown in Figures 9.11.2 and 8.28. The game needs to hav e a supply
of words from which it can choose a secret word to present to th e players.
ThegetSecretWord() method will take care of this task. It calculates
a random number and then uses that number, together with a switch
statement, to select from among several words that are coded right into
theswitch statement. The secret word is stored in the secretWord vari-
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 393
Figure 8.26: Design of the
WordGuess class as part of
TwoPlayerGame hierarchy.
able. The currentWord variable stores the partially guessed word. Ini-
tially,currentWord consists entirely of question marks. As the players
make correct guesses, currentWord is updated to show the locations of
the guessed letters. Because currentWord will change as the game pro-
gresses, it is stored in a StringBuffer , rather than in a String . Recall
thatString s are immutable in Java, whereas a StringBuffer contains
methods to insert letters and remove letters.
TheunguessedLetters variable stores the number of letters remain-
ing to be guessed. When unguessedLetters equals 0, the game is over.
This condition deﬁnes the gameOver() method, which is inherited from
TwoPlayerGame . The winner of the game is the player who guessed the
last letter in the secret word. This condition deﬁnes the getWinner()
method, which is also inherited from TwoPlayerGame . The other meth-
ods that are inherited from TwoPlayerGame or implemented from the
CLUIPlayableGame are also implemented in a straightforward manner.
A move in the WordGuess game consists of trying to guess a let-
ter that occurs in the secret word. The move() method processes the
player’s guesses. It passes the guessed letter to the guessLetter()
method, which checks whether the letter is a new, secret lett er. If so,
guessLetter() takes care of the various housekeeping tasks. It adds the
letter to previousGuesses , which keeps track of all the players’ guesses.
It decrements the number of unguessedLetters , which will become 0
394 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
public c l a s s WordGuess extends TwoPlayerGame implements CLUIPlayableGame {
private S t r i n g secretWord ;
private S t r i n g B u f f e r currentWord ;
private S t r i n g B u f f e r previousGuesses ;
private i n t unguessedLetters ;
public WordGuess ( ) {
secretWord = getSecretWord ( ) ;
currentWord = new S t r i n g B u f f e r ( secretWord ) ;
previousGuesses = new S t r i n g B u f f e r ( ) ;
for (i n t k = 0 ; k <secretWord . length ( ) ; k++)
currentWord . setCharAt ( k , ’ ? ’) ;
unguessedLetters = secretWord . length ( ) ;
}// WordGuess ( )
public S t r i n g getPreviousGuesses ( ) {
return previousGuesses . t o S t r i n g ( ) ;
}// getPreviousGuesses ( )
public S t r i n g getCurrentWord ( ) {
return currentWord . t o S t r i n g ( ) ;
}// getCurrentWord ( )
private S t r i n g getSecretWord ( ) {
i n t num = ( i n t) ( Math . random ( ) ∗1 0 ) ;
switch (num)
{ case 0 :return ”SOFTWARE” ;
case 1 :return ”SOLUTION” ;
case 2 :return ”CONSTANT” ;
case 3 :return ”COMPILER” ;
case 4 :return ”ABSTRACT” ;
case 5 :return ”A B N O R M A L” ;
case 6 :return ”A R G U M E N T” ;
case 7 :return ”QUESTION” ;
case 8 :return ”UTILIZES” ;
case 9 :return ”VARIABLE” ;
default :return ”MISTAKES” ;
}//switch
}// getSecretWord ( )
private boolean g ues s Let t er ( char l e t t e r ) {
previousGuesses . append ( l e t t e r ) ;
i f( secretWord . indexOf ( l e t t e r ) == −1)
return f a l s e ;// l e t t e r i s not in secretWord
el s e // find p o s i t i o n s of l e t t e r in secretWord
{ for (i n t k = 0 ; k <secretWord . length ( ) ; k++)
{ i f( secretWord . charAt ( k ) == l e t t e r )
{ i f( currentWord . charAt ( k ) == l e t t e r )
return f a l s e ;////already guessed
currentWord . setCharAt ( k , l e t t e r ) ;
unguessedLetters −−;//one l e s s to find
}// i f
}// f o r
return true ;
}// e l s e
}//g ues s Let t er ( )
public S t r i n g getRules ( ) { // Overridden from TwoPlayerGame
return ”\n∗∗∗ The Rules of Word Guess ∗∗∗\ n”+
” ( 1 ) The game generates a s e c r e t word . \n”+
” ( 2 ) Two players a l t e r n a t e taking moves . \n”+
” ( 3 ) A move c o n s i s t s of guessing a l e t t e r in the word . \n”+
” ( 4 ) A player continues guessing u n t i l a l e t t e r i s wrong . \n”+
” ( 5 ) The game i s over when a l l l e t t e r s of the word are guessed \n”+
” ( 6 ) The player guessing the l a s t l e t t e r of the word wins . \n”;
}//getRules ( )
✡ ✠
Figure 8.27: The WordGuess class, Part I.
when all the letters have been guessed. And it updates currentWord
to show where all occurrences of the secret letter are locate d. Note how
guessLetter() uses a for-loop to cycle through the letters in the secret
word. As it does so, it replaces the question marks in currentWord with
SECTION 8.6 •Case Study: A Two Player Game Hierarchy 395
☛ ✟
public boolean gameOver ( ) { // From TwoPlayerGame
return ( unguessedLetters <= 0 ) ;
}// gameOver ( )
public S t r i n g getWinner ( ) {// From TwoPlayerGame
i f( gameOver ( ) )
return ” Player ” + getPlayer ( ) ;
el s e return ”The game i s not over . ” ;
}// getWinner ( )
public S t r i n g reportGameState ( ) {
i f( ! gameOver ( ) )
return ”\nCurrent word ” + currentWord . t o S t r i n g ( ) + ” Previous guesses ”
+ previousGuesses + ”\nPlayer ” + getPlayer ( ) + ” guesses next . ” ;
el s e
return ”\nThe game i s now over ! The s e c r e t word i s ” + secretWord
+”\n”+ getWinner ( ) + ” has won! \n”;
}// reportGameState ( )
public S t r i n g getGamePrompt ( ) { // From CLUIPlayableGame
return ”\nGuess a l e t t e r t h a t you think i s in the s e c r e t word : ” ;
}// getGamePrompt ( )
public S t r i n g move( S t r i n g s ) {
char l e t t e r = s . toUpperCase ( ) . charAt ( 0 ) ;
i f( g ues s Let t er ( l e t t e r ) ) { // i f c o r r e c t
return ”Yes , the l e t t e r ” + l e t t e r +
” IS in the s e c r e t word \n”;
}el s e{
changePlayer ( ) ;
return ” Sorry , ” + l e t t e r + ” i s NOT a ” +
”new l e t t e r in the s e c r e t word \n”;
}
}// move ( )
public void play ( U s e r I n t e r f a c e ui ) {// From CLUIPlayableGame
ui . report ( getRules ( ) ) ;
i f( computer1 != null )
ui . report ( ”\nPlayer 1 i s a ” + computer1 . t o S t r i n g ( ) ) ;
i f( computer2 != null )
ui . report ( ”\nPlayer 2 i s a ” + computer2 . t o S t r i n g ( ) ) ;
while ( ! gameOver ( ) ) {
I P l a y e r computer = null ; // Assume no computers playing
ui . report ( reportGameState ( ) ) ;
switch ( getPlayer ( ) ) {
case PLAYER ONE : // Player 1 ’ s turn
computer = computer1 ;
break ;
case PLAYER TWO: // Player 2 ’ s turn
computer = computer2 ;
break ;
}// cases
i f( computer != null ){ // I f computer ’ s turn
ui . report (move( computer . makeAMove( ””) ) ) ;
}el s e{ // otherwise , user ’ s turn
ui . prompt ( getGamePrompt ( ) ) ;
ui . report (move( ui . getUserInput ( ) ) ) ;
}
}// while
ui . report ( reportGameState ( ) ) ; // The game i s now over
}//play ( )
}//WordGuess c l a s s
✡ ✠
Figure 8.28: The WordGuess class, continued.
the correctly guessed secret letter. The guessLetter() method returns
false if the guess is incorrect. In that case, the move() method changes the
player’s turn. When correct guesses are made, the current pla yer keeps
the turn.
TheWordGuess game is a good example of a string-processing
problem. It makes use of several of the String andStringBuffer Reusing code
396 CHAPTER 8 •Inheritance and Polymorphism
☛ ✟
public c l a s s WordGuesser implements I P l a y e r {
private WordGuess game ;
public WordGuesser ( WordGuess game ) {
t h i s . game = game ;
}
public S t r i n g makeAMove( S t r i n g prompt ) {
S t r i n g usedLetters = game . getPreviousGuesses ( ) ;
char l e t t e r ;
do{ // P i c k o n e o f 2 6 l e t t e r s
l e t t e r = ( char ) (’A ’ + ( i n t) ( Math . random ( ) ∗2 6 ) ) ;
}while ( usedLetters . indexOf ( l e t t e r ) != −1);
return ””+ l e t t e r ;
}
public S t r i n g t o S t r i n g ( ) {// r e t u r n s ’ N i m P l a y e r B a d ’
S t r i n g className = t h i s . getClass ( ) . t o S t r i n g ( ) ;
return className . substring ( 5 ) ;
}
}// W o r d G u e s s e r
✡ ✠
Figure 8.29: The WordGuesser class.
methods that we learned in Chapter 7. The implementation of
WordGuess , as an extension of TwoPlayerGame , is quite straight for-
ward. One advantage of the TwoPlayerGame class hierarchy is that it
decides many of the important design issues in advance. Deve loping a
new game is largely a matter of implementing methods whose de ﬁnitions
have already been determined in the superclass or in the inte rfaces. This
greatly simpliﬁes the development process.
Let’s now discuss the details of WordGuesser class (Fig. 9.11.3).
Note that the constructor takes a WordGuess parameter. This allows
WordGuesser to be passed a reference to the game, which accesses
the game’s public methods, such as getPreviousGuesses() . The
toString() method is identical to the toString() method in the
NimPlayerBad example. The makeAMove() method, which is part of
theIPlayer interface, is responsible for specifying the algorithm tha t the
player uses to make a move. The strategy in this case is to repe atedly pick
a random letter from AtoZuntil a letter is found that is not contained in
previousGuesses . That way, the player will not guess letters that have
already been guessed.
8.7 Principles Of Object-Oriented Design
To conclude this chapter, it will be helpful to focus brieﬂy on how the
examples we’ve seen address the various object-oriented des ign (OOD)
principles we set out at the beginning of the book.
•Divide-and-Conquer Principle. Notice how all of the problems
tackled in this chapter have been solved by dividing them int o sev-
eral classes, with each of the classes divided into separate methods.
The very idea of a class hierarchy is an application of this pr inciple.
SECTION 8.7 •Principles Of Object-Oriented Design 397
•Encapsulation Principle. The superclasses in our designs, Cipher
andTwoPlayerGame , encapsulate those features of the class hier-
archy that are shared by all objects in the hierarchy. The subc lasses,
CaesarCipher andOneRowNim , encapsulate features that make
them distinctive with the class hierarchy.
•Interface Principle. The several Java interfaces we’ve designed,
IPlayer ,CLUIPlayableGame andUserInterface , specify
clearly how various types of related objects will interact wi th each
other through the methods contained in the interfaces. Clea n inter-
faces make for clear communication among objects.
•Information Hiding Principle. We have continued to make con-
sistent use of the private andpublic qualiﬁers, and have now
introduced the protected qualiﬁer to extend this concept. The in-
heritance mechanism gives subclasses access to protected a nd public
elements of their superclasses.
•Generality Principle. As you move down a well-designed class hi-
erarchy, you go from the more general to the more speciﬁc feat ures of
the objects involved. The abstract encode() method speciﬁes the gen-
eral form that encoding will take while the various implemen tations
of this method in the subclasses provide the specialization s neces-
sary to distinguish, say, Caesar encoding from Transpose en coding.
Similarly, the abstract makeAMove() method in the IPlayer inter-
face provides a general format for a move in a two-player game ,
while its various implementations provide the specializat ions that
distinguish one game from another.
•Extensibility Principle. Overriding inherited methods and imple-
menting abstract methods from either an abstract superclas s or a
Java interface provide several well-designed ways to exten d the
functionality in an existing class hierarchy. Extending a c lass is a
form of specialization of the features inherited from the su perclass.
•Abstraction Principle. Designing a class hierarchy is an exercise in
abstraction, as the more general features of the objects invo lved are
moved into the superclasses. Similarly, designing a Java in terface or
an abstract superclass method is a form of abstraction, wher eby the
signature of the method is distinguished from its various im plemen-
tations.
These, then, are some of the ways that the several examples we have
considered and this chapter’s discussion have contributed to a deepening
of our understanding of object-oriented design.
398 CHAPTER 8 •Inheritance and Polymorphism
CHAPTER SUMMARY Technical Terms
abstract method
actual type (dynamic
type)
ciphertext
class inheritance
cryptographydynamic binding
(late binding)
interface
overloaded method
plaintext
polymorphic method
polymorphismstatic binding (early
binding)
static type (declared
type)
substitution cipher
transposition cipher
Summary of Important Points
•Inheritance is an object-oriented mechanism whereby subclas ses in-
herit the public and protected instance variables and metho ds from
their superclasses.
•Dynamic binding (or late binding) is the mechanism by which a
method call is bound to (associated with) the correct implem entation
of the method at run time. In Java, all method calls, except for final
orprivate methods, are resolved using dynamic binding.
•Static binding (or early binding) is the association of a met hod call with
its corresponding implementation at compile time.
•Polymorphism is an object-oriented language feature in whic h a
method call can lead to different actions depending on the ob ject on
which it is invoked. A polymorphic method is a method signatu re
that is given different implementation by different classe s in a class
hierarchy.
•A static type is a variable’s declared type. A dynamic type, o r actual
type, is the type of object assigned to that variable at a given point in a
running program.
•Anabstract method is a method deﬁnition that lacks an implemen-
tation. An abstract class is one that contains one or more abstract
methods. An abstract class can be subclassed but not instantiated.
•A Java interface is a class that contains only method signatu res and
(possibly) constant declarations, but no variables. An int erface can
be implemented by a class by providing implementations for a ll of its
abstract methods.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 8.1 Running the TestPrint program will produce the output
shown here. It is clear that the inherited toString() method is used by
println() when printing a TestPrint object.
☛ ✟
5 6 . 0
TestPrint@be2d65
✡ ✠
SOLUTION 8.2 If you override the toString() method in TestPrint , you
should get something like the output shown here, depending on how you code
CHAPTER 8 •Solutions to Self-Study Exercises 399
toString() . It is clear that the toString() method is used polymorphously
byprintln() .
☛ ✟
5 6 . 0
Hello from T e s t P r i n t
✡ ✠
SOLUTION 8.3 The output produced when constructing objects of type AandB
in the order shown in the exercise would be as follows, with each let ter occurring
on a separate line:
☛ ✟
A B B
✡ ✠
SOLUTION 8.4 The new implementation of B’smethod() will invoke A’s ver-
sion of the method before printing B. This will print “A A B A B”.
☛ ✟
void method ( ) {
super . method ( ) ;
System . out . p r i n t l n ( ”B” ) ;
}
✡ ✠
SOLUTION 8.5 Give the deﬁnitions of classes AandBin the exercise, the
marked statements would be invalid:
☛ ✟
A a = new B ( ) ; // V a l i d a B i s a n A
a = new A ( ) ; // Ok
B b = new A ( ) ; // I n v a l i d . An A i s n o t n e c e s s a r i l y a B
b = new B ( ) ; // OK
✡ ✠
SOLUTION 8.6 Given the class deﬁnitions and code segment in this exercise, t he
output would be, A A B A B C , with each letter printing on a separate line.
SOLUTION 8.7 Deﬁnition of an Pig subclass of Animal :
☛ ✟
public c l a s s Pig extends Animal {
public Pig ( ){
kind = ” pig ” ;
}
public S t r i n g speak ( ) {
return ” oink ” ;
}
}
✡ ✠
400 CHAPTER 8 •Inheritance and Polymorphism
SOLUTION 8.8 If polymorphism was not used in our design, the talk()
method would have to be modiﬁed to the following in order to accommodat e a
Pig subclass:
☛ ✟
public S t r i n g t a l k ( Animal a ) {
i f( ainstanceof Cow)
return ” I am a ” + kind + ” and I go ” + a . moo ( ) ;
else i f ( ainstanceof Cat )
return ” I am a ” + kind + ” and I go ” + a .meow ( ) ;
else i f ( ainstanceof Pig )
return ” I am a ” + kind + ” and I go ” + a . oink ( ) ;
else
return ” I don ’ t know what I am” ;
}
✡ ✠
SOLUTION 8.9 Code to swap two boolean variables:
☛ ✟
boolean temp = b1 ; // S a v e b 1 ’ s v a l u e
b1 = b2 ; // C h a n g e b 1 t o b 2
b2 = temp ; // C h a n g e b 2 t o b 1 ’ s o r i g i n a l v a l u e
✡ ✠
SOLUTION 8.10 Creating a ToggleButton that can be used to deal or collect
cards:
☛ ✟
private ToggleButton dealer =
new ToggleButton ( ” deal ” ,” c o l l e c t ” ) ;
add ( dealer ) ;
dealer . addActionListener ( t h i s ) ;
✡ ✠
SOLUTION 8.11 Modify the Caesar class so that it will allow various-sized
shifts to be used.
☛ ✟
private i n t s h i f t ;
public void s e t S h i f t ( i n t n ){s h i f t = n ; }
public i n t g e t S h i f t ( ) {return s h i f t ; }
// M o d i f i c a t i o n t o e n c o d e ( ) :
ch = ( char ) (’ a ’ + ( ch−’ a ’+ s h i f t ) % 2 6 ) ; // S h i f t
// M o d i f i c a t i o n t o d e c o d e ( ) :
ch = ( char ) (’ a ’ + ( ch−’ a ’+ (26−s h i f t ) ) % 2 6 ) ; // S h i f t
✡ ✠
SOLUTION 8.12 Modify Transpose.encode() so that it uses a rotation in-
stead of a reversal. The operation here is very similar to the shi ft operation in
the Caesar cipher. It uses modular arithmetic to rearrange th e letters in the word.
For example, suppose the word is “hello”. Its letters are indexed from 0 to 4. The
CHAPTER 8 •Exercises 401
following table shows how the expression ((k+2) % 5) will rearrange the letters
askvaries from 0 to 4:
☛ ✟
k charAt ( k ) ( k+2) % 5 charAt ( ( k+2) % 5)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
0 ’h ’ 2 ’ l ’
1 ’ e ’ 3 ’ l ’
2 ’ l ’ 4 ’ o ’
3 ’ l ’ 0 ’h ’
4 ’ o ’ 1 ’ e ’
// M o d i f i c a t i o n t o e n c o d e ( ) :
public S t r i n g encode ( S t r i n g word ) {
S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;
for (i n t k =0; k <word . length ( ) ; k++)
r e s u l t . append ( word . charAt ( ( k+2) % word . length ( ) ) ) ;
return r e s u l t . t o S t r i n g ( ) ;
}
✡ ✠
SOLUTION 8.13 ANimPlayer class that plays the optimal OneRowNim game
would be identical to the NimPlayerBad class except the move():int method
would be replaced with the following implementation:
☛ ✟
public i n t move ( ) {
i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
i f( s t i c k s L e f t % ( game . MAX PICKUP + 1) != 1)
return ( s t i c k s L e f t −1) % ( game . MAX PICKUP + 1 ) ;
else{
i n t maxPickup = Math . min ( game . MAX PICKUP, s t i c k s L e f t ) ;
return 1 + ( i n t) ( Math . random ( ) ∗maxPickup ) ;
}
}
✡ ✠
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 8.1 Fill in the blanks in each of the following sentences:
a. A method that lacks a body is an method.
b. An is like a class except that it contains only instance methods, no
instance variables.
c. Two ways for a class to inherit something in Java is to a class and
an interface.
d. Instance variables and instance methods that are declared or
are inherited by the subclasses.
e. An object can refer to itself by using the keyword.
f. If an applet intends to handle ActionEvent s, it must implement the
interface.
g. A method is one that does different things depending upon the
object that invokes it.
EXERCISE 8.2 Explain the difference between the following pairs of concepts:
402 CHAPTER 8 •Inheritance and Polymorphism
a.Class and interface .
b.Stub method and abstract method .
c.Extending a class and instantiating an object .
d.Deﬁning a method and implementing a method .
e. Aprotected method and a public method.
f. Aprotected method and a private method.
EXERCISE 8.3 Draw a hierarchy to represent the following situation. There ar e
lots of languages in the world. English, French, Chinese, and Kor ean are exam-
ples of natural languages. Java, C, and C++ are examples of forma l languages.
French and Italian are considered romance languages, while Gr eek and Latin are
considered classical languages.
EXERCISE 8.4 Look up the documentation for the JButton class on Sun’s Web
site:
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
List the names of all the methods that would be inherited by the ToggleButton
subclass that we deﬁned in this chapter.
EXERCISE 8.5 Design and write a toString() method for the ToggleButton
class deﬁned in this chapter. The toString() method should return the
ToggleButton ’s current label.
EXERCISE 8.6 Design a class hierarchy rooted in the class Employee that in-
cludes subclasses for HourlyEmployee andSalaryEmployee . The attributes
shared in common by these classes include the name, and job title of the employee,
plus the accessor and mutator methods needed by those attributes . The salaried
employees need an attribute for weekly salary, and the correspon ding methods for
accessing and changing this variable. The hourly employees sh ould have a pay
rate and an hours worked variable. There should be an abstract me thod called
calculateWeeklyPay() , deﬁned abstractly in the superclass and implemented
in the subclasses. The salaried worker’s pay is just the weekly salary. Pay for an
hourly employee is simply hours worked times pay rate.
EXERCISE 8.7 Design and write a subclass of JTextField calledInteger-
Field that is used for inputting integers but behaves in all other res pects like a
JTextField . Give the subclass a public method called getInteger() .
EXERCISE 8.8 Implement a method that uses the following variation of the Cae-
sar cipher. The method should take two parameters, a String and an int N. The
result should be a String in which the ﬁrst letter is shifted by N, the second by
N+1, the third by N+2, and so on. For example, given the string “Hello,” and an
initial shift of 1, your method should return “Igopt.”
Write a method that converts its String parameter so that letters are written in
blocks ﬁve characters long.
EXERCISE 8.9 Design and implement an applet that lets the user type a doc-
ument into a TextArea and then provides the following analysis of the docu-
ment: the number of words in the document, the number of character s in the
document, and the percentage of words that have more than six lett ers.
EXERCISE 8.10 Design and implement a Cipher subclass to implement the fol-
lowing substitution cipher: Each letter in the alphabet is rep laced with a letter from
the opposite end of the alphabet: ais replaced with z,bwith y, and so forth.
CHAPTER 8 •Exercises 403
EXERCISE 8.11 One way to design a substitution alphabet for a cipher is to use a
keyword to construct the alphabet. For example, suppose the keyw ord is “zebra.”
You place the keyword at the beginning of the alphabet, and then ﬁ ll out the other
21 slots with remaining letters, giving the following alphabet :
☛ ✟
Cipher alphabet : zebracdfghijklmnopqstuvwxy
Plain alphabet : abcdefghijklmnopqrstuvwxyz
✡ ✠
Design and implement an Alphabet class for constructing these kinds of sub-
stitution alphabets. It should have a single public method that takes a keyword
String as an argument and returns an alphabet string. Note that an alp habet
cannot contain duplicate letters, so repeated letters in a key word like “xylophone”
would have to be removed.
EXERCISE 8.12 Design and write a Cipher subclass for a substitution cipher
that uses an alphabet from the Alphabet class created in the previous exercise.
EXERCISE 8.13 Challenge: Find a partner and concoct your own encryption
scheme. Then work separately with one partner writing encode() and the other
writing decode() . Test to see that a message can be encoded and then decoded
to yield the original message.
EXERCISE 8.14 Design a TwoPlayerGame subclass called Multiplication-
Game . The rules of this game are that the game generates a random mult iplication
problem using numbers between 1 and 10, and the players, takin g turns, try to
provide the answer to the problem. The game ends when a wrong answ er is given.
The winner is the player who did not give a wrong answer.
EXERCISE 8.15 Design a class called MultiplicationPlayer that plays the
multiplication game described in the previous exercise. This class should imple-
ment the IPlayer interface.
EXERCISE 8.16 Design a TwoPlayerGame subclass called RockPaperScis-
sors . The rules of this game are that each player, at the same time, p icks either a
rock, a paper, or a scissors. For each round, the rock beats the sciss ors, the scissors
beats the paper, and the paper beats the rock. Ties are allowed. The game is won
in a best out of three fashion when one of the players wins two rounds.
EXERCISE 8.17 Design a class called RockPaperScissorsPlayer that plays
the the game described in the previous exercise. This class sh ould implement the
IPlayer interface.
404 CHAPTER 8 •Inheritance and Polymorphism
OBJECTIVES
After studying this chapter, you will
•Know how to use array data structures.
•Be able to solve problems that require collections of data.
•Know how to sort an array of data.
•Be familiar with sequential and binary search algorithms.
•Gain a better understanding of inheritance and polymorphis m.
OUTLINE
9.1 Introduction
9.2 One-Dimensional Arrays
9.3 Simple Array Examples
9.4 Example: Counting Frequencies of Letters
9.5 Array Algorithms: Sorting
9.6 Array Algorithms: Searching
9.7 Two-Dimensional Arrays
9.8 Multidimensional Arrays (Optional)
9.9 Object-Oriented Design: Polymorphic Sorting (Optional )
9.10 From the Java Library: java.util.Vector
9.11 Case Study: An N-Player Computer Game
9.12 A GUI-Based Game (Optional Graphics)
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 9
Arrays and Array Processing
405
406 CHAPTER 9 •Arrays and Array Processing
9.1 Introduction
In this chapter we will learn about arrays. An array is a named collection
of contiguous storage locations—storage locations that are next to each
other—that contain data items of the same type.
Arrays offer a more streamlined way to store data than using i ndividual
data items for each variable. Arrays also allow you to work wi th their data
more efﬁciently than with data stored in individual variabl es.
Let’s see why. Suppose you want to create a GUI that has 26 butt ons
on it, one for each letter of the alphabet. Given our present k nowledge
of Java, our only alternative would be to declare a separate JButton
variable for each letter of the alphabet:
☛ ✟
JButton button1 ;
JButton button2 ;
. . .
JButton button26 ;
✡ ✠
Obviously, requiring 26 separate variables for this proble m is tedious and
inconvenient. Similarly, to instantiate and assign a label to each button
would require 26 statements:
☛ ✟
button1 = new JButton ( ”A” ) ;
button2 = new JButton ( ”B” ) ;
. . .
button26 = new JButton ( ”Z” ) ;
✡ ✠
This approach is also tedious. What we need is some way to use a l oop
to process each button, using a loop counter, k, to refer to the kth button
on each iteration of the loop. An array lets us do that. For exa mple, the
following code will declare an array for storing 26 JButton s and then
instantiate and label each button:
☛ ✟
JButton l e t t e r [ ] = new JButton [ 2 6 ] ;
for (i n t k = 0 ; k <2 6 ; k++)
l e t t e r [ k ] = new JButton ( ”A” + k ) ;
✡ ✠
You don’t yet understand the code in this segment, but you can see how
economical it is. It uses just three lines of code to do what woul d have
required 50 or 60 lines of code without arrays.
Our discussion of arrays will show how to store and retrieve d ata from
one-, two-, and three-dimensional arrays. We also study sor ting and
searching algorithms to process arrays. Finally, we illust rate how arrays
can be used in a variety of applications, including an animat ion problem,
a sorting class, and a card-playing program.
9.2 One-Dimensional Arrays
An array is considered a data structure . Adata structure is an organized
collection of data. In an array, data are arranged in a linear o r sequen- The array data structure
SECTION 9.2 •One-Dimensional Arrays 407
tial structure, with one element following another. When ref erencing ele-
ments in an array, we refer to the position of the particular e lement within
the array. For example, if the array is named arr, then the elements are
named arr[0], arr[1], arr[2], ... arr[n-1] , where ngives
the number of elements in the array. This naming also reﬂects t he fact that
the array’s data are contained in storage locations that are next to each
other. In Java, as in C, C++, and some other programming langua ges, the
ﬁrst element of an array has index 0. (This is the same convent ion we used Zero indexing
forString s.)
-2 arr 8 -1-3 16 20 25 16 16 8 18 19 45 21 -20 1 2 3 4 5 6 7 8 9 10 11 12 13 14Array nameSubscripts
ContentsFigure 9.1: An array of 15 integers
named arr.
Figure 9.1 shows an array named arr that contains 15 int elements.
The syntax for referring to elements of an array is
arrayname [subscript ]
where arrayname is the name of the array—any valid identiﬁer will do—
and subscript is the position of the element within the array. As Fig-
ure 9.1 shows, the ﬁrst element in the array has subscript 0, t he second
has subscript 1, and so on.
Asubscript is an integer quantity contained in square brackets that is
used to identify an array element. An subscript must be eithe r an integer
value or an integer expression. Using Figure 9.1 to illustra te an example, Subscript expressions
suppose that jand kare integer variables equaling 5 and 7, respectively.
Each of the following then would be valid references to eleme nts of the
array arr:
☛ ✟
a r r [ 4 ] // R e f e r s t o 1 6
a r r [ j ] // I s a r r [ 5 ] w h i c h r e f e r s t o 2 0
a r r [ j + k ] // I s a r r [ 5 + 7 ] w h i c h i s a r r [ 1 2 ] w h i c h r e f e r s t o 4 5
a r r [ k % j ] // I s a r r [ 7 % 5 ] w h i c h i s a r r [ 2 ] w h i c h r e f e r s t o −1
✡ ✠
These examples show that when an expression, such as j + k , is used as
a subscript, it is evaluated (to 12 in this case) before the re ference is made.
It is a syntax error to use a noninteger type as an array subscri pt. Each
of the following expressions would be invalid:
☛ ✟
a r r [ 5 . 0 ] // 5 . 0 i s a f l o a t a n d c a n ’ t b e a n a r r a y s u b s c r i p t
a r r [ ”5” ] // ” 5 ” i s a s t r i n g n o t a n i n t e g e r
✡ ✠
For a given array, a valid array subscript must be in the range 0 ... N-1 ,
where Nis the number of elements in the array or it is considered out- of-
bounds. An out-of-bounds subscript creates a run-time erro r—that is, an
error that occurs when the program is running—rather than a sy ntax error,
408 CHAPTER 9 •Arrays and Array Processing
which can be detected when the program is compiled. For the ar rayarr,
each of the following expressions contain out-of-bounds su bscripts:
☛ ✟
a r r [−1] // A r r a y s c a n n o t h a v e n e g a t i v e s u b s c r i p t s
a r r [ ’ 5 ’]// C h a r ’ 5 ’ p r o m o t e d t o i t s U n i c o d e v a l u e , 5 3
a r r [ 1 5 ] // T h e l a s t e l e m e n t o f a r r h a s s u b s c r i p t 1 4
a r r [ j∗k ] // S i n c e j ∗k e q u a l s 3 5
✡ ✠
Each of these references would lead to an IndexOutOfBoundsException .
(Exceptions are covered in detail in Chapter 10.)
JAVA LANGUAGE RULE Array Subscripts. Array subscripts must
be integer values in the range 0...(N-1) , where Nis the number of
elements in the array.
JAVA DEBUGGING TIP Array Subscripts. In developing array
algorithms, it’s important to design test data that show tha t array
subscripts do not cause run-time errors.
9.2.1 Declaring and Creating Arrays
For the most part, arrays in Java are treated as objects. Like o bjects, they
are instantiated with the new operator and they have instance variables Are arrays objects?
(for example, length ). Like variables for objects, array variables are con-
sidered reference variables. When arrays are used as parameters, a refer-
ence to the array is passed rather than a copy of the entire arr ay. The
primary difference between arrays and full-ﬂedged objects is that arrays
aren’t deﬁned in terms of an Array class. Thus, arrays don’t ﬁt into Java’s
Object hierarchy. They don’t inherit any properties from Object and
they cannot be subclassed.
You can think of an array as a container that contains a number of vari-
ables. As we’ve seen, the variables contained in an array obje ct are not
referenced by name but by their relative position in the arra y. The vari-
ables are called components . If an array object has Ncomponents, then we
say that the array length isN. Each of the components of the array has the
same type, which is called the array’s component type . An empty array is
one that contains zero variables.
Aone-dimensional array has components that are called the array’s Components and elements
elements . Their type is the array’s element type . An array’s elements
may be of any type, including primitive and reference types. This means
you can have arrays of int, char, boolean, String, Object,
Image, TextField, TwoPlayerGame , and so on.
When declaring a one-dimensional array, you have to indicate both the
array’s element type and its length. Just as in declaring and creating other
kinds of objects, creating an array object requires that we cre ate both a
SECTION 9.2 •One-Dimensional Arrays 409
name for the array and then the array itself. The following st atements
create the array shown in Figure 9.1:
☛ ✟
i n t a r r [ ] ; // D e c l a r e a n a m e f o r t h e a r r a y
a r r = new i n t [ 1 5 ] ; // C r e a t e t h e a r r a y i t s e l f
✡ ✠
These two steps can be combined into a single statement as fol lows:
☛ ✟
i n t a r r [ ] = new i n t [ 1 5 ] ;
✡ ✠
In this example, the array’s element type is int and its length is 15,
which is ﬁxed and cannot be changed. This means that the array contains
15 variables of type int, which will be referred to as arr[0], arr[1],
...arr[14] .
9.2.2 Array Allocation
Creating the array in Figure 9.1 means allocating 15 storage locations that Allocating memory
can store integers. Note that one difference between declar ing an array
and declaring some other kind of object is that square bracket s ([]) are
used to declare an array type. The brackets can be attached ei ther to the
array’s name or to its type, as in the following examples:
☛ ✟
i n t a r r [ ] ; // T h e b r a c k e t s may f o l l o w t h e a r r a y ’ s n a m e
i n t[ ] a r r ; // T h e b r a c k e t s may f o l l o w t h e a r r a y ’ s t y p e
✡ ✠
The following example creates an array of ﬁve String s and then uses
a for loop to assign the strings "hello1" ,"hello2" ,"hello3" ,
"hello4" , and"hello5" to the ﬁve array locations:
☛ ✟
S t r i n g s t r a r r [ ] ; // D e c l a r e a n a m e f o r t h e a r r a y
s t r a r r = new S t r i n g [ 5 ] ; // C r e a t e t h e a r r a y i t s e l f
// A s s i g n s t r i n g s t o t h e a r r a y
for (i n t k = 0 ; k <s t r a r r . length ; k++)
// F o r e a c h e l e m e n t
s t r a r r [ k ] = new S t r i n g ( ” h e l l o ” + ( k + 1 ) ) ; // A s s i g n a s t r i n g
✡ ✠
Note that the expression k < strarr.length speciﬁes the loop bound.
Every array has a length instance variable, which refers to the number of
elements contained in the array. As we mentioned, arrays, li keString s,
are zero indexed, so the last element of the array is always gi ven by its length vs.length()
length-1 . However, length is an instance variable for arrays, whereas
410 CHAPTER 9 •Arrays and Array Processing
Figure 9.2: Creating an array of
ﬁveString s involves six objects,
because the array itself is a sepa-
rate object. In (a), the array vari-
able is declared. In (b), the ar-
ray is instantiated, creating an ar-
ray of ﬁve null references. In (c),
the ﬁve Strings are created and
assigned to the array.strarr
(a)
(b)
(c)
valu
lengvalu
lengvalu
lengvalu
lengvalue =""
length : int =0: StringstrarrstrarrString strarr[]; // Null array variable
// Creates an array of null String
// references.

strarr =new String [5];
// Creates 5 Strings and
/  assigns them to the array

for (int k =0; k 6 strarr.length; k + + )
	 strarr[k] =new String();
length() is an instance method for String s. Therefore, it would be a
syntax error in this example to refer to strarr.length() .
JAVA DEBUGGING TIP Array Length. A common syntax error
involves forgetting that for arrays length is an instance variable, not
an instance method, as it is for String s.
In the example, we ﬁrst use the new operator to create strarr , an array
of type String of length ﬁve. We then use a String constructor to create
the ﬁve String s that are stored in the array. It is important to realize that
creating an array to store ﬁve Object s (as opposed to ﬁve primitive data
elements) does not also create the Object s themselves that will be stored
in the array.
When an array of objects is created, the array’s elements are references Arrays of objects
to those objects (Fig. 9.2). Their initial values, like all re ference variables,
arenull . So to create and initialize the array strarr , we need to create
sixobjects—the array itself, which will contain ﬁve String s, and then the
ﬁveString s that are stored in strarr .
One more example will help underscore this point. The follow ing state-
ments create four newObject s, an array to store three Student s plus the
threeStudent s themselves:
☛ ✟
Student school [ ] = new Student [ 3 ] ; // A 3 S t u d e n t a r r a y
school [ 0 ] = new Student ( ” S o c r a t e s ” ) ; // T h e f i r s t S t u d e n t
school [ 1 ] = new Student ( ” Plato ” ) ;
// T h e s e c o n d S t u d e n t
school [ 2 ] = new Student ( ” A r i s t o t l e ” ) ;// T h e t h i r d S t u d e n t
✡ ✠
The ﬁrst statement creates an array named school to store three
Student s, and the next three statements create the individual Student s
SECTION 9.2 •One-Dimensional Arrays 411
and assign them to the array (Fig. 9.3). Thus, creating the ar ray and
initializing its elements require four new statements.
name : String ="Aristotle": Student
name : String ="Plato": Student 
name : String ="Socrates": Student school
FIGURE 9.3 An array of
Student s.The following sequence of statements would lead to a null poi nter
exception because the array’s elements have not been instan tiated:
☛ ✟
Student students [ ] = new Student [ 3 ] ; // A 3 S t u d e n t a r r a y
System . out . p r i n t l n ( students [ 0 ] . getName ( ) ) ;
✡ ✠
In this case, students[0] is a null reference, thus causing the exception.
JAVA DEBUGGING TIP Array Instantiation. Creating a new array
does not also create the objects that are stored in the array. T hey must
be instantiated separately. It is a semantic error to refer to an
uninstantiated ( null ) array element.
Now that we’ve assigned the three Student s to the array, we can refer
to them by means of subscripted references. A reference to th eStudent
named “Socrates” is now school[0] , and a reference to the Student
named “Plato” is school[1] . In other words, to refer to the three indi-
vidual students we must refer to their locations within school . Of course,
we can also use variables, such as loop counters, to refer to a Student ’s
location within school . The following for loop invokes each Student ’s
getState() method to print out its current state:
☛ ✟
for (i n t k = 0 ; k <school . length ; k++)
System . out . p r i n t l n ( school [ k ] . g e t S t a t e ( ) ) ;
✡ ✠
What if the three Student s already existed before the array was cre-
ated? In that case, we could just assign their references to the array
elements, as in the following example:
☛ ✟
Student student1 = new Student ( ” S o c r a t e s ” ) ;
Student student2 = new Student ( ” Plato ” ) ;
Student student3 = new Student ( ” A r i s t o t l e ” ) ;
Student school = new Student [ 3 ] ; // A 3 S t u d e n t a r r a y
school [ 0 ] = student1 ;
school [ 1 ] = student2 ;
school [ 2 ] = student3 ;
✡ ✠name : String ="Aristotle": Student
name : String ="Plato": Student 
name : String ="Socrates": Studentschool
student1student3
student2
FIGURE 9.4 Arrays of objects store
references to the objects, not the
objects themselves.In this case, each of the three Student objects can be referenced by two
different references—its variable identiﬁer (such as student1 ) and its ar-
ray location (such as school[0] ). For arrays of objects, Java stores just
the reference to the object in the array itself, rather than th e entire object.
This conserves memory, since references require only 4 byte s each whereas
each object may require hundreds of bytes (Fig. 9.4).
When an array of Nelements is created, the compiler allocates storage
forNvariables of the element’s type. In the case of arr that we discussed
earlier, the compiler would allocate storage for 15 ints—60 contiguous
412 CHAPTER 9 •Arrays and Array Processing
bytes of storage, because each int requires 4 bytes (32 bits) of storage. If
we declare an array of 20 double s,
☛ ✟
double a r r [ ] = new double [ 2 0 ] ;
✡ ✠
the compiler will allocate 160 bytes of storage—20 variables of 8 bytes
(64 bits) each. In the case of the Student examples and String exam- How much memory?
ples, because these are objects (not primitive types), the co mpiler will al-
locate space for Naddresses, where Nis the length of the array and where
each address requires 4 bytes.
SELF-STUDY EXERCISE
EXERCISE 9.1 How much space (in bytes) would be allocated for each
of the following?
a.int a[] = new int[5];
b.double b[] = new double[10];
c.char c[] = new char[30];
d.String s[] = new String[10];
e.Student p[] = new Student[5];
9.2.3 Initializing Arrays
Array elements are automatically initialized to default va lues that depend
on the element type: Boolean elements are initialized to false , and inte-
ger and real types are initialized to 0. Reference types—that is, arrays of
objects—are initialized to null . Default initialization
Arrays can also be assigned initial values when they are crea ted, al-
though this is feasible only for relatively small arrays. An array initializer
is written as a list of expressions separated by commas and en closed by
braces. For example, we can declare and initialize the array shown in Array initializer
Figure 9.1 with the following statement:
☛ ✟
i n t a r r [ ] = {−2 ,8 ,−1 ,−3 ,16 ,20 ,25 ,16 ,16 ,8 ,18 ,19 ,45 ,21 , −2};
✡ ✠
Similarly, to create and initialize an array of String s, we can use the
following statement:
☛ ✟
S t r i n g s t r i n g s [ ] = {” h e l l o ” ,”world” ,”goodbye” ,” love ”};
✡ ✠
This example creates and stores four String s in the array. Subsequently,
to refer to “hello”, we would use the reference strings[0] , and to refer
to “love”, we would use the reference strings[3] . Note in these exam-
ples that when an array declaration contains an initializer , it is not neces-
sary to use new and it is not necessary to specify the number of elements
in the array. The number of elements is determined from the nu mber of
values in the initializer list.
9.2.4 Assigning and Using Array Values
Array elements can be used in the same way as other variables. The only Array assignment
SECTION 9.3 •Simple Array Examples 413
difference, of course, is that references to the elements ar e subscripted.
For example, the following assignment statements assign va lues to the
elements of two arrays, named arr andstrings :
☛ ✟
a r r [ 0 ] = 5 ;
a r r [ 5 ] = 1 0 ;
a r r [ 2 ] = 3 ;
s t r i n g s [ 0 ] = ”who” ;
s t r i n g s [ 1 ] = ”what” ;
s t r i n g s [ 2 ] = s t r i n g s [ 3 ] = ”where” ;
✡ ✠
The following loop assigns the ﬁrst 15 squares— 1, 4, 9 ... —to the
arrayarr:
☛ ✟
for (i n t k = 0 ; k <a r r . length ; k++)
a r r [ k ] = ( k+1) ∗( k + 1 ) ;
✡ ✠
The following loop prints the values of the array arr:
☛ ✟
for (i n t k = 0 ; k <a r r . length ; k++)
System . out . p r i n t l n ( a r r [ k ] ) ;
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 9.2 Declare an array named farr that contains ten float s
initialized to the values 1.0, 2.0, ..., 10.0 .
EXERCISE 9.3 Write an expression that prints the ﬁrst element of farr .
EXERCISE 9.4 Write an assignment statement that assigns 100.0 to the
last element in farr .
EXERCISE 9.5 Write a loop to print all of the elements of farr .
9.3 Simple Array Examples
The program in Figure 9.5 creates two arrays of ten elements e ach and
displays their values on the Java console. In this
example, the elements of intArr have not been given initial valuesInts Reals
0 1.1
0 2.2
0 3.3
0 4.4
0 5.5
0 6.6
0 7.7
0 8.8
0 9.9
0 10.1
FIGURE 9.6 Output of the
PrintArrays program.whereas the elements of realArr have been initialized. Note the use
of the integer constant ARRSIZE to store the arrays’ size. By using the
constant in this way, we do not have to use the literal value 10anywhere
in the program, thereby making it easier to read and to modify the pro-
gram. If we want to change the size of the array that the program han-
dles, we can just change the value of ARRSIZE . This is an example of the Maintainability principle
414 CHAPTER 9 •Arrays and Array Processing
☛ ✟
public c l a s s PrintArrays {
s t a t i c f i n a l i n t ARRSIZE = 1 0 ;
// T h e a r r a y ’ s s i z e
s t a t i c i n t intArr [ ] = new i n t [ ARRSIZE ] ; // C r e a t e i n t a r r a y
s t a t i c double realArr [ ] = {1 . 1 , 2 . 2 , 3 . 3 , 4 . 4 ,
5 . 5 , 6 . 6 , 7 . 7 , 8 . 8 , 9 . 9 , 1 0 . 1 0 };// And a d o u b l e a r r a y
public s t a t i c void main ( S t r i n g args [ ] ) {
System . out . p r i n t l n ( ” I n t s\t Reals ” ) ;
// P r i n t a h e a d i n g
// F o r e a c h i n t a n d d o u b l e e l e m e n t
for (i n t k = 0 ; k <intArr . length ; k++)
System . out . p r i n t l n ( intArr [ k ] + ”\t ” +
realArr [ k ] ) ;
// P r i n t t h e m
}// m a i n ( )
}// P r i n t A r r a y s
✡ ✠
Figure 9.5: A program that displays two arrays. Its output is s hown in
Figure 9.6.
maintainability principle.
JAVA EFFECTIVE DESIGN Symbolic Constants. Using symbolic
constants (ﬁnal variables) instead of literal values makes the program
easier to read and to maintain.
Note the use of the static qualiﬁer throughout the PrintArrays
class. This enables us to refer to the array and the other vari ables from
within the main() method. If intArr were not declared static , we
would get the compiler error attempt to make static use of a
non-static variable. This use of static is justiﬁed mainly as a
coding convenience rather than a principle of object-orient ed design. The
only examples we’ve seen so far in which static elements were a neces-
sary design element were the use of static elements in the Math class—
Math.PI andMath.sqrt() —and the use of static ﬁnal variables in
TwoPlayerGame —TwoPlayerGame.PLAYER ONE.
For large arrays, it is not always feasible to initialize the m in an ini-
tializer statement. Consider the problem of initializing a n array with the
squares of the ﬁrst 100 integers. Not only would it be tedious to set these
values in an initializer statement, it would also be error pr one, since it is
relatively easy to type in the wrong value for one or more of th e squares.
JAVA DEBUGGING TIP Array Initialization. Initializer statements
should be used only for relatively small arrays.
The example in Figure 9.7 creates an array of 50 integers and t hen ﬁlls the
elements with the values 1, 4, 9, 16, and so on. It then prints th e entire
array.1 4 9 16 25
36 49 64 81 100
121 144 169 196 225
256 289 324 361 400
441 484 529 576 625
676 729 784 841 900
961 1024 1089 1156 1225
1296 1369 1444 1521 1600
1681 1764 1849 1936 2025
2116 2209 2304 2401 2500
FIGURE 9.8 Output of the
Squares program.
SECTION 9.3 •Simple Array Examples 415
☛ ✟
public c l a s s Squares {
s t a t i c f i n a l i n t ARRSIZE = 5 0 ; // T h e a r r a y ’ s s i z e
s t a t i c i n t intArr [ ] = new i n t [ ARRSIZE ] ; // I n s t a n t i a t e
public s t a t i c void main ( S t r i n g args [ ] ) {
for (i n t k = 0 ; k <intArr . length ; k++) // I n i t i a l i z e
intArr [ k ] = ( k+1) ∗( k + 1 ) ;
System . out . p r i n t ( ”The f i r s t 50 squares are ” ) ;
for (i n t k = 0 ; k <intArr . length ; k++) {// P r i n t
i f( k % 5 == 0) // F o r e a c h 5 t h s q u a r e
System . out . p r i n t l n ( ” ” ) ;// p r i n t a new l i n e
System . out . p r i n t ( intArr [ k ] + ” ” ) ;
}// f o r
}// m a i n ( )
}// S q u a r e s
✡ ✠
Figure 9.7: A program with an array that stores the squares of the ﬁrst 50
integers. Its output is shown in Figure 9.8.
This example illustrates some important points about the us e of array
variables. The array’s elements are individual storage loc ations. In this
example, intArr has 50 storage locations. Storing a value in one of these
variables is done by an assignment statement:
☛ ✟
intArr [ k ] = ( k+1) ∗( k + 1 ) ;
✡ ✠
The use of the variable kin this assignment statement allows us to vary
the location that is assigned on each iteration of the for loo p. Note that
in this example, koccurs as the array index on the left-hand side of this
expression, while k+1 occurs on the right-hand side as the value to be
squared. The reason for this is that arrays are indexed start ing at 0 but we
want our table of squares to begin with the square of 1. So the s quare of
some number n+1 will always be stored in the array whose index is one
less than the number itself—that is, n. Zero vs. unit indexing
An array’s length variable can always be used as a loop bound when
iterating through all elements of the array:
☛ ✟
for (i n t k = 0 ; k <intArr . length ; k++)
intArr [ k ] = ( k+1) ∗( k + 1 ) ;
✡ ✠
However, it is important to note that the last element in the ar ray is always
at location length-1 . Attempting to refer to intArr[length] would Off-by-one error
cause an IndexOutOfBoundsException because no such element ex-
ists.
JAVA DEBUGGING TIP Off-by-One Error. Because of zero
indexing, the last element in an array is always length−1. Forgetting
this fact can cause an off-by-one error.
SELF-STUDY EXERCISE
416 CHAPTER 9 •Arrays and Array Processing
EXERCISE 9.6 Declare an array of 100 double s and write a loop to as-
sign the ﬁrst 100 square roots to its elements. [Use Math.sqrt(double) .]
9.4 Example: Counting Frequencies of Letters
Suppose you wish to write a program to help break a text messag e that has
been encrypted with one of the historical ciphers that we hav e discussed
in the two previous chapters. It is well known that historical ciphers of-
ten can be broken, that is, the plaintext can be found from the ciphertext,
by examining the frequencies of letters and comparing them t o the aver-
age frequencies of typical samples of plaintext. For exampl e,EandTare
the two most frequently used letters in the English language . So, in a ci-
phertext encrypted with a Caesar cipher, EandTare good guesses as the
plaintext letter corresponding to the most frequent letter in a ciphertext
message.
Let’s write a program that will count how many times each of th e26
letters of the English language appears in a given string. Th ere are a num-
ber of ways to design such a program depending on how ﬂexible yo u wish
the program to be. Let us keep this example simple by assuming that we
will only be interested in counting occurrences of the lette rsAthrough Z
and not of occurrences of spaces or punctuation marks. Assum e further
that we will change lowercase letters in our string sample to uppercase
before counting letters and that we will want to print out the frequencies
of letters to the console window. Finally, assume that, late r in the chapter
after we discuss sorting arrays, we will want to enhance our p rogram so
that it can print out the letter frequencies in order of incre asing frequency.
9.4.1 A Class to Store the Frequency of One Letter
It is clear that an array should be used for storing the frequen cies, but a
decision must also be made as to what to store as the array elem ents. If
we store letter frequencies as int values, with the frequency of Astored
at index 0, and the frequency of Bat index 1, and so forth, we will not
be able to rearrange the frequencies into increasing order w ithout losing
track of which letter corresponds to which frequency. One wa y of solving
this problem is to create an array of objects, where each object stores both
a letter and its frequency.
So let us design a LetterFreq class that stores a letter in an instance
variable of type char and its frequency in an instance variable of type
int. These instance variables can be declared as:
☛ ✟
private char l e t t e r ; //A c h a r a c t e r b e i n g c o u n t e d
private i n t f r e q ; // T h e f r e q u e n c y o f l e t t e r
✡ ✠
We will want a constructor that can initialize these two valu es and two
accessor methods to return these values. We are familiar eno ugh with
these kinds of methods that it will not be necessary to discus s them any
SECTION 9.4 •Example: Counting Frequencies of Letters 417
☛ ✟
public c l a s s L e t t e r F r e q {
private char l e t t e r ; //A c h a r a c t e r b e i n g c o u n t e d
private i n t f r e q ; // T h e f r e q u e n c y o f l e t t e r
public L e t t e r F r e q ( char ch , i n t f r e ){
l e t t e r = ch ;
f r e q = f r e ;
}
public char g e t L e t t e r ( ) {
return l e t t e r ;
}
public i n t getFreq ( ) {
return f r e q ;
}
public void incrFreq ( ) {
f r e q ++;
}
}// L e t t e r F r e q
✡ ✠
Figure 9.10: The LetterFreq class deﬁnition.
further. We need one additional method to increment freq whenever we
encounter the letter while processing the string:
☛ ✟
public void incrFreq ( ) {
f r e q ++;
}// s e t F r e q ( )
✡ ✠
A UML diagram for the LetterFreq class is given in Figure 9.9 and
the class deﬁnition is given in Figure 9.10. Note that we will have to make
FIGURE 9.9 UML for
LetterFreq .a minor modiﬁcation to this class later in this chapter to ena ble us to sort
an array of objects from this class.
9.4.2 A Class to Count Letter Frequencies
Now let us turn to designing a class named AnalyzeFreq that will use
an array of objects of type LetterFreq to count the frequencies of the
lettersAthrough Zin a given string. The array, let’s call it freqArr , will
be the only instance variable of the class. The class needs a c onstructor
to instantiate the array and to create the 26array elements, each with a
different letter and an initial frequency of 0. This class should also have
two methods: a method to count the frequencies of the 26letters in a given
string and a method that prints out the frequency of each lett er to the
FIGURE 9.11 UML for
AnalyzeFreq .console window. The UML diagram for the class is given in Figu re 9.11.
The array instance variable can be declared by:
☛ ✟
private L e t t e r F r e q [ ] freqArr ; // An a r r a y o f f r e q u e n c i e s
✡ ✠
418 CHAPTER 9 •Arrays and Array Processing
The constructor creates an array of 26elements to store references to
LetterFreq objects with the statement
☛ ✟
freqArr = new L e t t e r F r e q [ 2 6 ] ;
✡ ✠
The indices of the array range from 0to25and the elements at these
locations should store the letters AtoZ. Recall that in Java, char data
are a form of int data and can be used in arithmetic. If we let kbe an
integer that ranges between 0and25, then the expression (char)(’A’
+ k) will correspond to the letters AtoZ. . Thus, the following loop will
initialize the array correctly.
☛ ✟
for (i n t k = 0 ; k <2 6 ; k++) {
freqArr [ k ] = new L e t t e r F r e q ( ( char ) (’A ’ + k ) , 0 ) ;
}// f o r
✡ ✠
ThecountLetters() method must identify the array index for
LetterFreq object that stores a letter between AandZ. Iflet is achar
variable that stores such a letter, then the expression (let - ’A’) will
give the index of the array element corresponding to let. Thus the fol-
lowing code will calculate the frequencies the letters in th e string param-
eter,str:
☛ ✟
public void c o u n t L e t t e r s ( S t r i n g s t r ) {
char l e t ; // F o r u s e i n t h e l o o p .
s t r = s t r . toUpperCase ( ) ;
for (i n t k = 0 ; k <s t r . length ( ) ; k++) {
l e t = s t r . charAt ( k ) ;
i f( ( l e t>=’A ’) && ( l e t <=’Z ’) ){
freqArr [ l e t −’A ’] . incrFreq ( ) ;
}// i f
}// f o r
}// c o u n t L e t t e r s ( )
✡ ✠
The deﬁnition of the printArray() method is completely straight for-
ward:
☛ ✟
public void printArray ( ) {
for (i n t k = 0 ; k <2 6 ; k++) {
System . out . p r i n t ( ” l e t t e r : ” + freqArr [ k ] . g e t L e t t e r ( ) ) ;
System . out . p r i n t l n ( ” f r e q : ” + freqArr [ k ] . getFreq ( ) ) ;
}// f o r
}// p r i n t A r r a y ( )
✡ ✠
The entire deﬁnition of AnalyzeFreq is given in Figure 9.12. We will
modify this class later in the chapter to be able to sort the ar ray after count-
SECTION 9.4 •Example: Counting Frequencies of Letters 419
☛ ✟
public c l a s s AnalyzeFreq {
private L e t t e r F r e q [ ] freqArr ; // An a r r a y o f f r e q u e n c i e s
public AnalyzeFreq ( ) {
freqArr = new L e t t e r F r e q [ 2 6 ] ;
for (i n t k = 0 ; k <2 6 ; k++) {
freqArr [ k ] = new L e t t e r F r e q ( ( char ) (’A ’ + k ) , 0 ) ;
}// f o r
}
public void c o u n t L e t t e r s ( S t r i n g s t r ) {
char l e t ; // F o r u s e i n t h e l o o p .
s t r = s t r . toUpperCase ( ) ;
for (i n t k = 0 ; k <s t r . length ( ) ; k++) {
l e t = s t r . charAt ( k ) ;
i f( ( l e t>=’A ’) && ( l e t <=’Z ’) ){
freqArr [ l e t −’A ’] . incrFreq ( ) ;
}// i f
}// f o r
}
public void printArray ( ) {
for (i n t k = 0 ; k <2 6 ; k++) {
System . out . p r i n t ( ” l e t t e r : ” + freqArr [ k ] . g e t L e t t e r ( ) ) ;
System . out . p r i n t l n ( ” f r e q : ” + freqArr [ k ] . getFreq ( ) ) ;
}// f o r
}
}// A n a l y z e F r e q
✡ ✠
Figure 9.12: The AnalyzeFreq class deﬁnition.
ing. The following main() method, either in this class or in its own class
will demonstrate how the class methods are used.
☛ ✟
public s t a t i c void main ( S t r i n g [ ] argv ) {
AnalyzeFreq af = new AnalyzeFreq ( ) ;
af . c o u n t L e t t e r s ( ”Now i s the time f o r a l l good students ” +
” to study computer r e l a t e d t o p i c s . ” ) ;
af . printArray ( ) ;
}// m a i n ( )
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 9.7 Rewrite the main() of theAnalyzeFreq class so that
it opens a ﬁle named freqtest.txt and counts the frequencies of the
letters of the text stored in the ﬁle. You will need to use the Scanner
class to read from the ﬁle as was done in Chapter 4. Create a ﬁle named
freqtest.txt that contains several hundred characters of typical En-
glish text to test the new main() method
420 CHAPTER 9 •Arrays and Array Processing
9.5 Array Algorithms: Sorting
Sorting an array is the process of arranging its elements in ascendin g or
descending order. Sorting algorithms are among the most wid ely used
algorithms. Any time large amounts of data are maintained, t here is some
need to arrange them in a particular order. For example, the t elephone
company needs to arrange its accounts by the last name of the a ccount
holder as well as by phone number.
9.5.1 Insertion Sort
The ﬁrst sorting algorithm we’ll look at is known as insertion sort , so
named because as it traverses through the array from the ﬁrst to the last
element, it inserts each element into its correct position i n the partially
sorted array.
For an array of Nelements, let’s think of the array as divided into two
parts. The sorted part will be the left hand side of the array. And the
unsorted part will be the right hand side of the array. Initially, the so rted
part consists of the ﬁrst element in the array—the element at i ndex 0.
Insertion sort moves through the unsorted portion of the arra y—that is
its loop variable, k, ranges from 1 through N-1. On each iteration it inserts
thekth element into its correct position in the sorted part of the array. To
insert an element into the sorted part of the array, it may be n ecessary to
move elements greater than the one being inserted out of the w ay.
In pseudocode, insertion sort can be represented as follows:
☛ ✟
I n s e r t i o n Sort of an array , arr , of N elements i n t o ascending order
1 . For k assigned 1 through N −1
2 . Remove the element a r r [ k ] and s t o r e i t in x .
3 . For i s t a r t i n g at k −1 and for a l l preceding elements g r e a t e r than x
4 . Move a r r [ i ] one p o s i t i o n to the r i g h t in the array .
5 . I n s e r t x at i t s c o r r e c t l o c a t i o n .
✡ ✠
As is apparent from the pseudocode, we have a nested for loops . The outer
(k) loop, iterates through the array from 1 to N-1. The inner loop iterates
as many times as necessary, starting with the element just to t he left of the
kth element in order to insert the kth element into its correct position in
the sorted portion. Note that the kth element is always removed from the
array (and stored in the variable x), to make room for elements that have
to be moved to the right.
To see how this works, consider an integer array containing t he ages of
ﬁve friends:
☛ ✟
21|20 27 24 19 x = 20
k
✡ ✠
For this ﬁve-element array, insertion sort initially will a ssume that the el-
ement at index 0 is in the correct position. The vertical line marks the
boundary between the sorted and unsorted portions of the arr ay. The
outer loop will look at each of the remaining elements, one at a time, in-
serting it into its proper position in the sorted portion of t he array. To
SECTION 9.5 •Array Algorithms: Sorting 421
insert 20, the number at index 1, the inner loop will move 21 to the right
by one position. To do this, the algorithm will remove 20 from its location
and store it in x. It will then move 21 one space to the right. Fin ally, it
will insert 20, which is stored in x, at index 0, where it belon gs relative to
the other elements in the sorted part of the array. At this poi nt, the sorted
portion of the array consists of the ﬁrst two elements, which are in the
correct order, relative to each other.
☛ ✟
20 21 |27 24 19 x = 27
k
✡ ✠
For the next element, 27, none of elements in the sorted porti on need to be
moved, so the inner for loop will iterate zero times. This giv es us:
☛ ✟
20 21 27 |24 19 x = 24
k
✡ ✠
For the fourth element, 24, only the previous element, 27, ne eds to be
moved to the right, giving:
☛ ✟
20 21 24 27 |19 x = 19
k
✡ ✠
At this point, the sorted part of the array consists of the ﬁrs t four elements,
which are in the correct order relative to each other. Finall y, for the last
element, 19, all of the elements in the sorted part of the arra y need to be
moved one space to the right. This will require four iteratio ns of the inner
loop. We show the state of the array after each iteration of th e inner for
loop:
☛ ✟
k
20 21 24 27 |19 Remove 19 and s t o r e i t x = 19
20 21 24 27 |27 Move 27 to the r i g h t
20 21 24 24 |27 Move 24 to the r i g h t
20 21 21 24 |27 Move 21 to the r i g h t
20 20 21 24 |27 Move 20 to the r i g h t
19 20 21 24 27 | I n s e r t x=19 at index 0
✡ ✠
Clearly, the fact that so many elements may have to moved on ea ch it-
eration of the outer loop shows that insertion sort is not a ve ry efﬁcient
algorithm.
TheSort class (Fig 9.13) provides an implementation of the
insertionSort() method. There are several points worth noting about
this code. First, because it takes an int array as a parameter, the
insertionSort() method will sort any array of integers, regardless of
the array’s length.
Second, note how empty brackets ( []) are used to declare an array pa- Array parameters
rameter. If the brackets were omitted, then arr would be indistinguish-
422 CHAPTER 9 •Arrays and Array Processing
☛ ✟
public c l a s s Sort{
public void i n s e r t i o n S o r t ( i n t a r r [ ] ) {
i n t temp ; // T e m p o r a r y v a r i a b l e f o r i n s e r t i o n
for (i n t k = 1 ; k <a r r . length ; k++) {
temp = a r r [ k ] ; // R e m o v e e l e m e n t f r o m a r r a y
i n t i ; // F o r l a r g e r p r e c e d i n g e l e m e n t s
for ( i = k−1; i>= 0 && a r r [ i ] >temp ; i −−)
a r r [ i +1] = a r r [ i ] ; // Move i t r i g h t b y o n e
a r r [ i +1] = temp ; // I n s e r t t h e e l e m e n t
}
}// i n s e r t i o n S o r t ( )
public void p r i n t ( i n t a r r [ ] ) {
for (i n t k = 0 ; k <a r r . length ; k++) // F o r e a c h i n t e g e r
System . out . p r i n t ( a r r [ k ] + ”\t ”) ; // P r i n t i t
System . out . p r i n t l n ( ) ;
}// p r i n t ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
i n t intArr [ ] = {21 , 20 , 27 , 24 , 19 };
Sort s o r t e r = new Sort ( ) ;
s o r t e r . p r i n t ( intArr ) ;
s o r t e r . i n s e r t i o n S o r t ( intArr ) ; // P a s s i n g a n a r r a y
s o r t e r . p r i n t ( intArr ) ;
}// m a i n ( )
}// S o r t
✡ ✠
Figure 9.13: Source code for the insertionSort() method. Note in
main() how an integer array is passed to the method.
able from an ordinary int parameter. Using the brackets indicates that
this method takes an array of integers as its parameter.
JAVA DEBUGGING TIP Array Parameter. When declaring an array
parameter, empty brackets must be used either after the arra y name or
after the type name to distinguish it from a non-array parame ter.
Third, note how an array of integers is passed to the insertionSort()
method in the main() method:
☛ ✟
s o r t e r . i n s e r t i o n S o r t ( intArr ) ; // P a s s i n t A r r t o t h e m e t h o d
✡ ✠
That is, when passing an array to a method, you use just the name of the
array, without brackets. Both of the following statements w ould cause
syntax errors:
☛ ✟
s o r t e r . i n s e r t i o n S o r t ( intArr [ ] ) ; // E r r : C a n ’ t h a v e b r a c k e t s
s o r t e r . i n s e r t i o n S o r t ( intArr [ 5 ] ) ; // E r r : p a s s i n g a n i n t e g e r
✡ ✠
In the ﬁrst case, empty brackets are only used when you declare an array
variable, not when you are passing the array to a method. In the second
SECTION 9.5 •Array Algorithms: Sorting 423
case,intArr[5] is anint, not an array, and cannot legally be passed to
insertionSort() .
JAVA DEBUGGING TIP Passing an Array Argument. It is a syntax
error to use empty brackets when passing an array argument to a
method, where the only the array’s name should be used. Empty
rackets are only used when declaring an array variable.
Finally, within the insertionSort() method itself, note that we declare
the index for the inner for loop outside of the for statement. This is so
it can be used outside the scope of the for loop to insert temp at location
arr[i+1] , its correct location. Note also that the index of its correc t loca-
tion isi+1, rather than just i. This is because the inner loop might iterate
past location 0, which would give ia value of -1 at that point.
9.5.2 Selection Sort
There are a large variety of array sorting algorithms. Selec tion sort is dif-
ferent from, but comparable to, insertion sort in its overal l performance.
To illustrate the selection sort algorithm, suppose you want to sort a deck
of 25 index cards, numbered from 1 to 25. Lay the 25 cards out on a table,
one card next to the other. Starting with the ﬁrst card, look t hrough the Selection sort algorithm
deck and ﬁnd the smallest card, the number 1 card, and exchang e it with
the card in the ﬁrst location. Then, go through the deck again starting
at the second card, ﬁnd the next smallest card, the number 2 ca rd, and
exchange it with the card in the second location. Repeat this process 24
times.
Translating this strategy into pseudocode gives the follow ing algorithm:
☛ ✟
S e l e c t i o n s o r t of a 25 −card deck from small to l a r g e
1 . For count assigned 1 to 24 // O u t e r l o o p
2 . smallestCard = count
3 . For currentCard assigned count+1 to 25 // I n n e r l o o p
4 . I f deck [ currentCard ] <deck [ smallestCard ]
5 . smallestCard = currentCard
6 . I f smallestCard != count // Y o u n e e d t o s w a p
7 Swap deck [ count ] and deck [ smallestCard ]
✡ ✠
For a deck of 25 cards, you need to repeat the outer loop 24 time s. In other
words, you must select the smallest card and insert it in its p roper location
24 times. The inner loop takes care of ﬁnding the smallest rem aining card.
On each iteration of this outer loop, the algorithm assumes t hat the card
speciﬁed by the outer loop variable, count , is the smallest card (line 2). It
usually won’t be, of course, but we have to start somewhere.
The inner loop then iterates through the remaining cards (fr om
count+1 to 25) and compares each one with the card that is currently
the smallest (lines 4 and 5). Whenever it ﬁnds a card that is sma ller than
the smallest card, it designates it as the smallest card (lin e 5). At the end of
the loop, the smallestCard variable will remember where the smallest
card is in the deck.
424 CHAPTER 9 •Arrays and Array Processing
Finally, when the inner loop is ﬁnished, the algorithm swaps the small-
est card with the card in the location designated by count .
9.5.3 Algorithm: Swapping Memory Elements
An important feature of the selection sort algorithm is its n eed to swap
two array elements, or cards, to continue our example. Swapp ing two
memory elements, whether they are array elements or not, req uires the
use of a temporary variable. For example, to swap the jth and kth elements
in anint array named arr, you would use the following algorithm: Swapping algorithm
☛ ✟
i n t temp = a r r [ j ] ; // S t o r e t h e j t h e l e m e n t i n t e m p
a r r [ j ] = a r r [ k ] ; // Move t h e k t h e l e m e n t i n t o j
a r r [ k ] = temp ; // Move t h e j t h e l e m e n t i n t o k
✡ ✠
Thetemp variable temporarily stores the jth element so its value is not
lost when its location is overwritten by the kth element. The need for
this variable is a subtlety that beginning programmers freq uently over-
look. But consider what would happen if we used the following erroneous
algorithm: Swapping blunder
☛ ✟
a r r [ j ] = a r r [ k ] ; // E r r o n e o u s s w a p c o d e
a r r [ k ] = a r r [ j ] ;
✡ ✠
Ifarr[j] refers to 4 and arr[k] refers to 2 in the array 1 4 2 8 , then
the erroneous algorithm would produce 1 2 2 8 , the wrong result.
JAVA PROGRAMMING TIP Swapping Variables. When swapping
two memory elements, a temporary variable must be used to sto re one
of the elements while its memory location is being overwritt en.
The following method implements the swap algorithm for two e lements,
el1and el2of anint array:
☛ ✟
void swap ( i n t a r r [ ] , i n t el1 , i n t e l 2 ){
i n t temp = a r r [ e l 1 ] ; // A s s i g n f i r s t e l e m e n t t o t e m p
a r r [ e l 1 ] = a r r [ e l 2 ] ; // O v e r w r i t e f i r s t w i t h s e c o n d
a r r [ e l 2 ] = temp ; // O v e r w r i t e s e c o n d w i t h f i r s t
}// s w a p ( )
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 9.8 Sort the array, 24 18 90 1 0 85 34 18, using the insertion
sort algorithm. Show the order of the elements after each ite ration of the
outer loop.
EXERCISE 9.9 Sort the array, 24 18 90 1 0 85 34 18, using the selection
sort algorithm. Show the order of the elements after each ite ration of the
outer loop.
SECTION 9.5 •Array Algorithms: Sorting 425
EXERCISE 9.10 Write a Java code segment to swap two Student ob-
jects,student1 andstudent2 .
EXERCISE 9.11 Write a Java implementation of the selectionSort()
method to sort an array of int.
9.5.4 Passing a Value and Passing a Reference
Recall from Chapter 3 that when an Object is passed to a method, a copy
of the reference to the Object is passed. Because an array is an object,
a reference to the array is passed to insertionSort() , rather than the
whole array itself. This is in contrast to how a value of a prim itive type is
passed. In that case, a copy of the actual value is passed.
426 CHAPTER 9 •Arrays and Array Processing
JAVA LANGUAGE RULE Primitive vs. Object Parameters. When a
value of a primitive data type— int, double, char, boolean —
is passed as an argument to a method, a copy of the value is pass ed;
when a reference to an Object is passed, a copy of the reference is
passed.
One implication of this distinction is that for arguments of primitive type,
the original argument cannot be changed from within the meth od be-
cause the method has only a copy of its value. For example, the follow-
ing method takes an int parameter n, which is incremented within the
method:
☛ ✟
public void add1 ( i n t n ){
System . out . p r i n t ( ”n = ” + n ) ;
n = n + 1 ;
System . out . p r i n t l n ( ” , n = ” + n ) ;
}
✡ ✠
But because nis a parameter of primitive type, incrementing it within the
method has no effect on its associated argument. Thus, in the following
segment, the value of Num —n’s associated argument—will not be affected
by what goes on inside the add() method. The output produced by the Passing a primitive value
code segment is shown in the comments:
☛ ✟
i n t N u m = 5 ;
System . out . p r i n t l n ( ”N u m = ” + N u m) ; // P r i n t s Num = 5
add1 (N u m) ; // P r i n t s n = 5 , n = 6
System . out . p r i n t l n ( ”N u m = ” + N u m) ; // P r i n t s Num = 5
✡ ✠
Note that while n’s value has changed inside the method, Num ’s value
remains unaffected.
The case is much different when we pass a reference to an object . In
that case, the object itself can be manipulated from within th e method.
TheinsertionSort() method is a good illustration. In the following
code segment, the array anArr is printed, then sorted, and then printed Passing an object
again:
☛ ✟
Sort s o r t e r = new S o r t e r ( ) ;
i n t anArr [ ] = {5 , 10 , 16 , −2, 4 , 6 , 1 };
s o r t e r . p r i n t ( anArr ) ; // P r i n t s 5 1 0 1 6 −2 4 6 1
s o r t e r . i n s e r t i o n S o r t ( anArr ) ; // S o r t s a n A r r
s o r t e r . p r i n t ( anArr ) ; // P r i n t s −2 1 4 5 6 1 0 1 6
✡ ✠
As you can see, the object itself (the array) has been changed f rom within
the method. This shows that changes within insertionSort to the ar-
ray referenced by arr are actually being made to anArr itself. If fact,
because insertionSort() is passed a copy of the reference variable
anArr , botharr andanArr are references to the very same object—that
is, to the same array (Fig. 9.14).
SECTION 9.6 •Array Algorithms: Searching 427
When an array is
method, both the pa-
the corresponding ar-
to the same object.public void insertionSort (int arr [ ])
{
...
}insertionSort (anArr)
5 10 16 -2 4 6 1Method Definition (parameter) Method Call (argument)
The justiﬁcation for passing a reference to an object rather th an the
entire object itself is a matter of efﬁciency. A reference use s just 4 bytes Method call overhead
of data, whereas an object may use thousands of bytes. It would ju st be
too inefﬁcient to copy hundreds of bytes each time an object is passed to
a method. Instead, the method is passed a reference to the objec t, thereby
giving it access to the object without incurring the expense o f copying
large amounts of data. Indeed, Java provides no way to pass a co py of an
object to a method.
SELF-STUDY EXERCISE
EXERCISE 9.12 Give the values that will be stored in myArr andkafter
you invoke mystery(myArr, k) , where myArr ,kandmystery() are
declared as follows:
☛ ✟
i n t myArr [ ] = {1 , 2 , 3 , 4 , 5 }; i n t k = 3 ;
void mystery ( i n t a [ ] , i n t m){
++a [m] ;
−−m;
}
✡ ✠
9.6 Array Algorithms: Searching
Suppose we have a large array and we need to ﬁnd one of its eleme nts. We
need an algorithm to search the array for a particular value, usually called
thekey. If the elements of the array are not arranged in any particula r
order, the only way we can be sure to ﬁnd the key, assuming it is in the
array, is to search every element, beginning at the ﬁrst elem ent, until we
ﬁnd it.
9.6.1 Sequential Search
This approach is known as a sequential search , because each element of
the array will be examined in sequence until the key is found ( or the end
428 CHAPTER 9 •Arrays and Array Processing
of the array is reached). A pseudocode description of this al gorithm is as
follows:
☛ ✟
1 . For each element of the array
2 . I f the element equals the key
3 . Return i t s index
4 . I f the key i s not found in the array
5 . Return −1 ( to i n d i c a t e f a i l u r e )
✡ ✠
This algorithm can easily be implemented in a method that sea rches
an integer array, which is passed as the method’s parameter. If the key is
found in the array, its location is returned. If it is not found , then−1is
returned to indicate failure.+sequentialSearch(in arr : int[], in key : int)
+binarySearch(in arr : int[], in key : int)Search
FIGURE 9.15 TheSearch class.TheSearch class (Figs. 9.15 and 9.16) provides the Java implementa-
tion of the sequentialSearch() method. The method takes two pa-
rameters: the array to be searched and the key to be searched f or. It uses
a for statement to examine each element of the array, checkin g whether
it equals the key or not. If an element that equals the key is fou nd, the
method immediately returns that element’s index. Note that the last state-
ment in the method will only be reached if no element matching the key
is found.
☛ ✟
public c l a s s Search {
public i n t s e q u e n t i a l S e a r c h ( i n t a r r [ ] , i n t key ){
for (i n t k = 0 ; k <a r r . length ; k++)
i f( a r r [ k ] == key )
return k ;
return −1; // F a i l u r e i f t h i s i s r e a c h e d
}// s e q u e n t i a l S e a r c h ( )
public i n t binarySearch ( i n t a r r [ ] , i n t key ){
i n t low = 0 ; // I n i t i a l i z e b o u n d s
i n t high = a r r . length −1 ;
while ( low<= high ) { // W h i l e n o t d o n e
i n t mid = ( low + high ) / 2 ;
i f( a r r [ mid ] == key )
return mid ; // S u c c e s s
else i f ( a r r [ mid ] <key )
low = mid + 1 ; // S e a r c h t o p h a l f
else
high = mid −1 ; // S e a r c h b o t t o m h a l f
} // w h i l e
return −1; // P o s t : i f l o w >h i g h s e a r c h f a i l e d
}// b i n a r y S e a r c h ( )
}// S e a r c h
✡ ✠
Figure 9.16: The Search class contains both a sequentialSearch()
and abinarySearch() .
SECTION 9.6 •Array Algorithms: Searching 429
JAVA EFFECTIVE DESIGN Sentinel Return Value. Like Java’s
indexOf() method, the sequentialSearch() returns a sentinel
value (−1) to indicate that the key was not found. This is a common
design for search methods.
9.6.2 Binary Search
If the elements of an array have been sorted into ascending or d escending
order, it is not necessary to search sequentially through ea ch element of
the array in order to ﬁnd the key. Instead, the search algorith m can make
use of the knowledge that the array is ordered and perform wha t’s known
as a binary search , which is a divide-and-conquer algorithm that divides
the array in half on each iteration and limits its search to jus t that half that
could contain the key.
To illustrate the binary search, recall the familiar guessi ng game in
which you try to guess a secret number between 1 and 100, being told
“too high” or “too low” or “just right” on each guess. A good ﬁrs t guess
should be 50. If this is too high, the next guess should be 25, be cause if
50 is too high the number must be between 1 and 49. If 50 was too lo w,
the next guess should be 75, and so on. After each wrong guess, a good
guesser should pick the midpoint of the sublist that would co ntain the
secret number.
Proceeding in this way, the correct number can be guessed in a t most
log2Nguesses, because the base-2 logarithm of Nis the number of times How many guesses?
you can divide Nin half. For a list of 100 items, the search should take
no more than seven guesses ( 27=128>100). For a list of 1,000items, a
binary search would take at most ten guesses (210=1,024>1,000).
So a binary search is a much more efﬁcient way to search, provi ded the
array’s elements are in order. Note that “order” here needn’ t be numeric
order. We could use binary search to look up a word in a diction ary or a
name in a phone book.
A pseudocode representation of the binary search is given as follows:
☛ ✟
TO SEARCH A N ARRAY OF N ELEMENTS IN ASCENDING ORDER
1 . Assign 0 low and assign N −1 to high i n i t i a l l y
2 . As long as low i s not g r e a t e r than high
3 . Assign ( low + high ) / 2 to mid
4 . I f the element at mid equals the key
5 . then return i t s index
6 . Else i fthe element at mid i s l e s s than the key
7 . then assign mid + 1 to low
8 . Else assign mid −1 to high
9 . I f t h i s i s reached return −1 to i n d i c a t e f a i l u r e
✡ ✠
Just as with the sequential search algorithm, this algorith m can easily be
implemented in a method that searches an integer array that i s passed
as the method’s parameter (Fig. 9.16). If the key is found in th e array,
its location is returned. If it is not found, then −1is returned to indicate
430 CHAPTER 9 •Arrays and Array Processing
failure. The binarySearch() method takes the same type of parameters
assequentialSearch() . Its local variables, low andhigh , are used
as pointers, or references, to the current low and high ends o f the array,
respectively. Note the loop-entry condition: low <= high . Iflow ever
becomes greater than high , this indicates that key is not contained in the
array. In that case, the algorithm returns −1.
As a binary search progresses, the array is repeatedly cut in half and
low andhigh will be used to point to the low and high index values in
that portion of the array that is still being searched. The lo cal variable mid
is used to point to the approximate midpoint of the unsearche d portion
of the array. If the key is determined to be past the midpoint, t henlow
is adjusted to mid+1 ; if the key occurs before the midpoint, then high is
set tomid-1 . The updated values of low andhigh limit the search to the
unsearched portion of the original array.
Unlike sequential search, binary search does not have to exa mine ev-
ery location in the array to determine that the key is not in th e array.
It searches only that part of the array that could contain the k ey. For
example, suppose we are searching for −5in the following array:
☛ ✟
i n t sortArr [ ] =
{1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 , 1 1 , 1 2 , 1 3 , 1 4 , 1 5 , 1 6 , 1 7 , 1 8 , 1 9 , 2 0 };
✡ ✠
The−5is smaller than the smallest array element. Therefore, the a lgo-
rithm will repeatedly divide the low end of the array in half u ntil the con-
ditionlow > high becomes true. We can see this by tracing the values
that low, mid, and high will take during the search:
☛ ✟
Key I t e r a t i o n Low High Mid
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
−5 0 0 19 9
−5 1 0 8 4
−5 2 0 3 1
−5 3 0 0 0
−5 4 0 −1 F a i l u r e
✡ ✠
As this trace shows, the algorithm examines only four locati ons to
determine that −5is not in the array. After checking location 0,
the new value for high will become −1, which makes the condition
low <= high false. So the search will terminate.+getInput() : int
+main()TestSearch
FIGURE 9.17 TheTestSearch
class.TheTestSearch class (Figs. 9.17 and 9.18) provides a program that
can be used to test two search methods. It creates an integer ar ray,
whose values are in ascending order. It then uses the getInput()
method to input an integer from the keyboard and then perform s both
asequentialSearch() and abinarySearch() for the number.
SELF-STUDY EXERCISE
EXERCISE 9.13 For the array containing the elements 2, 4, 6, and so on
up to 28 in that order, draw a trace showing which elements are examined
if you search for 21 using a binary search.
SECTION 9.7 •Two-Dimensional Arrays 431
☛ ✟
import java . io . ∗;
public c l a s s TestSearch {
public s t a t i c i n t getInput ( ) {
KeyboardReader kb = new KeyboardReader ( ) ;
kb . prompt ( ” This program searches f o r values in an array . ” ) ;
kb . prompt (
” Input any p o s i t i v e i n t e g e r ( or any negative to quit ) : ” ) ;
return kb . getKeyboardInteger ( ) ;
}// g e t I n p u t ( )
public s t a t i c void main ( S t r i n g args [ ] ) throws IOException {
i n t intArr [ ] = {2 , 4 , 6 , 8 , 1 0 , 1 2 , 1 4 , 1 6 , 1 8 , 2 0 , 2 2 , 2 4 , 2 6 , 2 8 };
Search searcher = new Search ( ) ;
i n t key = 0 , keyAt = 0 ;
key = getInput ( ) ;
while ( key>= 0){
keyAt = searcher . s e q u e n t i a l S e a r c h ( intArr , key ) ;
i f( keyAt != −1)
System . out . p r i n t l n ( ” Sequential : ” + key +
” i s at intArr [ ” + keyAt + ” ] ” ) ;
else
System . out . p r i n t l n ( ” Sequential : ” + key
+” i s not contained in intArr [ ] ” ) ;
keyAt = searcher . binarySearch ( intArr , key ) ;
i f( keyAt != −1)
System . out . p r i n t l n ( ” Binary : ” + key +
” i s at intArr [ ” + keyAt + ” ] ” ) ;
else
System . out . p r i n t l n ( ” Binary : ” + key +
” i s not contained in intArr [ ] ” ) ;
key = getInput ( ) ;
}// w h i l e
}// m a i n ( )
}// T e s t S e a r c h
✡ ✠
Figure 9.18: The TestSearch class.
9.7 Two-Dimensional Arrays
Atwo-dimensional array , an array whose components are themselves ar-
rays, is necessary or useful for certain kinds of problems. F or example,
you would use this type of array if you are doing a scientiﬁc st udy in
which you have to track the amount of precipitation for every day of the
year.
One way to organize these data would be to create a one-dimens ional
array, consisting of 365 elements:
☛ ✟
double r a i n f a l l [ ] = new double [ 3 6 5 ] ;
✡ ✠
However, with this representation, it would make it very difﬁ cult to cal-
culate the average rainfall within a given month, which migh t be an im-
portant part of your study.
432 CHAPTER 9 •Arrays and Array Processing
A better representation for this problem would be to use a two - What data do we need?
dimensional array, one dimension for the months and one for t he days.
The following statement declares the array variable rainfall and cre-
ates a 12 by 31 array object as its reference:
☛ ✟
double r a i n f a l l [ ] [ ] = new double [ 1 2 ] [ 3 1 ] ;
✡ ✠
Thus,rainfall is an array of arrays . You can think of the ﬁrst array as
the 12 months required for the problem. And you can think of ea ch month
as an array of 31 days. The months will be indexed from 0 to 11, a nd the
days will be indexed from 0 to 30.
The problem with this representation is that when we want to r efer to
the rainfall for January 5, we would have to use rainfall[0][4] . This Choosing an appropriate
representation is awkward and misleading. The problem is that dates—1/5/199 9—are
unit indexed, while arrays are zero indexed. Because it will be difﬁcult to
remember this fact, our representation of the rainfall data may cause us to
make errors when we start writing our algorithms.
We can easily remedy this problem by just deﬁning our array to h ave
an extra month and an extra day each month:
☛ ✟
double r a i n f a l l [ ] [ ] = new double [ 1 3 ] [ 3 2 ] ;
✡ ✠
This representation creates an array with 13 months, indexe d from 0 to 12,
with 32 days per month, indexed from 0 to 31. However, we can sim ply
ignore the 0 month and 0 day by using unit indexing in all of the algo-
rithms that process the array. In other words, if we view this a rray as
a two-dimensional table, consisting of 13 rows and 32 column s, we can
leave row 0 and column 0 unused (Fig. 9.19).
Figure 9.19: A two-dimensional
array with 13 rows and 32
columns. To represent 12 months
of the year, we can simply ignore
row 0 and column 0. 0,0Ignore this
columnUse the elements
within this rectangleIgnore
this row
0,1 0,2 0,3 0,29 0,30 0,31 . . .
1,0 1,1 1,2 1,3 1,29 1,30 1,31 . . . January
2,0
.
.
.2,1 2,2 2,3 2,29 2,30 2,31 . . . February
11,0 11,1 11,2 11,3 11,29 11,30 11,31 . . . November
12,0 12,1 12,2 12,3 12,29 12,30 12,31 . . . December
As Figure 9.19 shows, the very ﬁrst element of this 416-eleme nt array
has subscripts (0,0) while the last location has subscripts (12,31). The main
SECTION 9.7 •Two-Dimensional Arrays 433
advantages of this representation is that the program as a wh ole will be
much easier to read and understand and much less prone to erro r.
JAVA EFFECTIVE DESIGN Readability. To improve a program’s
robustness and readability, it may be preferable to use unit array
indexing by declaring extra array elements and ignoring tho se with
index 0.
In order to refer to an element in a two-dimensional array, you need to
use two subscripts. For the rainfall array, the ﬁrst subscript will specify
themonth and the second will specify the daywithin the month. Thus, the
following statements assign 1.15 to the rainfall element representing
January 5, and then print its value: Referencing two-dimensional arrays
☛ ✟
r a i n f a l l [ 1 ] [ 5 ] = 1 . 1 5 ; // R a i n f a l l f o r J a n u a r y 5
System . out . p r i n t l n ( r a i n f a l l [ 1 ] [ 5 ] ) ;
✡ ✠
Just as in the case of one-dimensional arrays, it is an error t o attempt
to reference an element that is not in the array. Each of the fo llowing
examples would cause Java to raise an IndexOutOfBoundsException :
☛ ✟
r a i n f a l l [ 1 3 ] [ 3 2 ] = 0 . 1 5 ; // No s u c h e l e m e n t
r a i n f a l l [ 1 1 ] [ 3 3 ] = 1 . 3 ; // No s u c h c o l u m n
r a i n f a l l [ 1 4 ] [ 3 0 ] = 0 . 7 4 ; // No s u c h r o w
✡ ✠
If the initial values of an array’s elements are supposed to be zero,
there is no need to initialize the elements. Java will do it au tomatically
when you create the array with new. However, for many array problems Initializing two-dimensional arrays
it is necessary to initialize the array elements to some othe r value. For
a two-dimensional array, this would require a nested loop. T o illustrate
this algorithm, let’s use a nested for loop to initialize eac h element of the
rainfall array to 0:
☛ ✟
// N o t e t h a t b o t h l o o p s a r e u n i t i n d e x e d .
for (i n t month = 1 ; month <r a i n f a l l . length ; month++)
for (i n t day = 1 ; day <r a i n f a l l [ month ] . length ; day++)
r a i n f a l l [ month ] [ day ] = 0 . 0 ;
✡ ✠
Note that both for loops use unit indexing. This is in keeping with our
decision to leave month 0 and day 0 unused.
Remember that when you have a nested for loop, the inner loop i terates
faster than the outer loop. Thus, for each month, the inner lo op will iterate Nested for loops
over 31 days. This is equivalent to processing the array as if you were
going across each row and then down to the next row in the repre sentation
shown in Figure 9.19.
Note that for a two-dimensional array, both dimensions have an asso-
ciatedlength variable, which is used in this example to specify the up-
per bound of each for loop. For the rainfall array, the ﬁrst dimension
(months) has a length of 13 and the second dimension (days) ha s a length
of 32.
434 CHAPTER 9 •Arrays and Array Processing
Another way to view the rainfall array is to remember that it is an
array of arrays. The length of the ﬁrst array, which correspo nds to the Array of arrays
number (13) of months, is given by rainfall.length . The length of
each month’s array, which corresponds to the number of days ( 32) in a
month, is given by rainfall[month].length .
The outer loop of the nested for loop iterates through months 1 through
12, and the inner for loop iterates through days 1 through 31. In this way,
372=12×31elements of the array are set to 0.0. In Table 9.1, the boldface
numbers along the top represent the day subscripts, while th e boldface
numbers along the left represent the month subscripts.
TABLE 9.1 The initialized rainfall array. The unused array
elements are shown as dashes.
0 1 2 3 ··· 30 31
0 – – – – ··· – –
1 – 0.0 0.0 0.0 ··· 0.0 0.0
2 – 0.0 0.0 0.0 ··· 0.0 0.0
........................
10 – 0.0 0.0 0.0 ··· 0.0 0.0
11 – 0.0 0.0 0.0 ··· 0.0 0.0
12 – 0.0 0.0 0.0 ··· 0.0 0.0
SELF-STUDY EXERCISES
EXERCISE 9.14 Declare a two-dimensional array of int, named
int2d , that contains ﬁve rows, each of which contains ten integers .
EXERCISE 9.15 Write a statement that prints the last integer in the third
row of the array that you created in the previous exercise. Th en write an
assignment statement that assigns 100 to the last element in theint2d
array.
EXERCISE 9.16 Write a loop to print all of the elements of int2d ,
which you declared in the previous exercise. Print one row pe r line with
a space between each element on a line.
9.7.1 Two-Dimensional Array Methods
Now that we have ﬁgured out how to represent the data for our sc ien-
tiﬁc experiment, let’s develop methods to calculate some re sults. First, we
want a method to initialize the array. This method will simpl y incorporate
the nested loop algorithm we developed previously:
☛ ✟
public void i n i t R a i n ( double r a i n [ ] [ ] ) {
for (i n t month = 1 ; month <r a i n . length ; month++)
for (i n t day = 1 ; day <r a i n [ month ] . length ; day++)
r a i n [ month ] [ day ] = 0 . 0 ;
}// i n i t R a i n ( )
✡ ✠
SECTION 9.7 •Two-Dimensional Arrays 435
Note how we declare the parameter for a multidimensional arr ay. In addi-
tion to the element type ( double ), and the name of the parameter ( rain ),Array parameters
we must also include a set of brackets for each dimension of the array.
Note also that we use the parameter name within the method to r efer
to the array. As with one-dimensional arrays, the parameter is a refer-
ence to the array, which means that any changes made to the arr ay within
the method will persist when the method is exited.
TheavgDailyRain() Method
One result that we need from our experiment is the average dai ly rainfall. Algorithm design
To calculate this result, we would add up all of the rainfalls stored in the
12×31array and divide by 365. Of course, the array itself contains more
than 365 elements. It contains 416 elements, but we’re not usi ng the ﬁrst
month of the array, and within some months—those with fewer th an 31
days—we’re not using some of the day elements. For example, th ere’s
no such day as rainfall[2][30] , which would represent February 30.
However, because we initialized all of the array’s elements t o 0, the rain-
fall recorded for the non-days will be 0, which won’t affect o ur overall
average.
The method for calculating average daily rainfall should ta ke our two- Method design
dimensional array of double as a parameter, and it should return a
double . Its algorithm will use a nested for loop to iterate through th e
elements of the array, adding each element to a running total . When the
loops exits, the total will be divided by 365 and returned:
☛ ✟
public double avgDailyRain ( double r a i n [ ] [ ] ) {
double t o t a l = 0 ;
for (i n t month = 1 ; month <r a i n . length ; month++)
for (i n t day = 1 ; day <r a i n [ month ] . length ; day++)
t o t a l += r a i n [ month ] [ day ] ;
return t o t a l /365;
}// a v g D a i l y R a i n ( )
✡ ✠
TheavgRainForMonth() Method
One reason we used a two-dimensional array for this problem i s so we
could calculate the average daily rainfall for a given month . Let’s write
a method to solve this problem. The algorithm for this method will not Algorithm design
require a nested for loop. We will just iterate through the 31 e lements of a
given month, so the month subscript will not vary. For exampl e, suppose
we are calculating the average for January, which is represe nted in our
array as month 1:
☛ ✟
double t o t a l = 0 ;
for (i n t day = 1 ; day <r a i n f a l l [ 1 ] . length ; day++)
t o t a l = t o t a l + r a i n f a l l [ 1 ] [ day ] ;
✡ ✠
Thus, the month subscript is held constant (at 1) while the da y subscript
iterates from 1 to 31. Of course, in our method we would use a pa rameter
436 CHAPTER 9 •Arrays and Array Processing
to represent the month, thereby allowing us to calculate the average daily Method design
rainfall for any given month.
Another problem that our method has to deal with is that month s don’t
all have 31 days, so we can’t always divide by 31 to compute the monthly
average. There are various ways to solve this problem, but pe rhaps the Method design: What data do we
need? easiest is to let the number of days for that month be speciﬁed as a third
parameter. That way, the month itself and the number of days f or the
month are supplied by the user of the method:
☛ ✟
public double avgRainForMonth ( double r a i n [ ] [ ] ,
i n t month , i n t nDays ) {
double t o t a l = 0 ;
for (i n t day = 1 ; day <r a i n [ month ] . length ; day++)
t o t a l = t o t a l + r a i n [ month ] [ day ] ;
return t o t a l /nDays ;
}// a v g R a i n F o r M o n t h ( )
✡ ✠
Given this deﬁnition, we can call this method to calculate an d print the
average daily rainfall for March as in the following stateme nt:
☛ ✟
System . out . p r i n t l n ( ”March : ” +
avgRainForMonth ( r a i n f a l l , 3 , 3 1 ) ) ;
✡ ✠
Note that when passing the entire two-dimensional array to t he method,
we just use the name of the array. We do not have to follow the nam e with
subscripts.
9.7.2 Passing Part of an Array to a Method
Instead of passing the entire rainfall array to the avgRainForMonth()
method, we could redesign this method so that it is only passe d the par-
ticular month that’s being averaged. Remember that a two-di mensional
array is an array of arrays, so if we pass the month of January, we are
passing an array of 32 days. If we use this approach, we need onl y two Method design: What data?
parameters: the month, which is array of days, and the number of days in
that month:
☛ ✟
public double avgRainForMonth ( double monthRain [ ] ,
i n t nDays ) {
double t o t a l = 0 ;
for (i n t day = 1 ; day <monthRain . length ; day++)
t o t a l = t o t a l + monthRain [ day ] ;
return t o t a l /nDays ;
}// a v g R a i n F o r M o n t h ( )
✡ ✠
Given this deﬁnition, we can call it to calculate and print th e average daily
rainfall for March as in the following statement:
☛ ✟
System . out . p r i n t l n ( ”March : ” +
avgRainForMonth ( r a i n f a l l [ 3 ] , 3 1 ) ) ;
✡ ✠
SECTION 9.7 •Two-Dimensional Arrays 437
In this case, we’re passing an array of double to the method, but in
order to reference it, we have to pull it out of the two-dimens ional ar-
ray by giving its row subscript as well. Thus, rainfall[3] refers to
one month of data in the two-dimensional array, the month of M arch.
Butrainfall[3] is itself a one-dimensional array. Figure 9.20 helps to
clarify this point.
2 F
A0 1 2 . . .rainfall –– refers to the whole 2–d array
rainfall[3] –– refers to the 1–d array
that represents March's data
rainfall[1][14] refers to the double value
that represents rainfall amt on Jan 14
.
.
.
11
12
131.131
J
M
J
J
A
S
O
N
DM0
1Figure 9.20: Referencing individ-
ual elements and array elements
in a two-dimensional array.
It’s important to note that deciding whether to use brackets w hen
passing data to a method is not just a matter of whether you are p assing Specifying an argument
an array. It is a matter of what type of data the method paramete r speci-
ﬁes. So, whenever you call a method that involves a parameter , you have
to look at the method deﬁnition to see what kind of data that pa rameter
speciﬁes. Then you must supply an argument that refers to tha t type of
data.
For our two-dimensional rainfall array, we can refer to the entire
array as rainfall . We can refer to one of its months as rainfall[j] ,
where jis any integer between 1 and 12. And we can refer to any of its
elements as rainfall[j][k] , where jis any integer between 1 and 12,
and kis any integer between 1 and 31.
JAVA LANGUAGE RULE Arguments and Parameters. The
argument in a method call must match the data type in the metho d
deﬁnition. This applies to all parameters, including array parameters.
TheRainfall class (Figs. 9.21 and 9.22) shows how we can test our
+initRain(in rain : double[][])
+avgDailyRain(in rain : double[][]) : double
+avgDailyRainForMonth(in monthRain : double[], in nDays : int) : double
+main()Rainfall Figure 9.21: The Rainfall class.
438 CHAPTER 9 •Arrays and Array Processing
☛ ✟
public c l a s s R a i n f a l l {
/∗∗
∗I n i t i a l i z e s t h e r a i n f a l l a r r a y
∗@ p a r a m r a i n i s a 2 D −a r r a y o f r a i n f a l l s
∗P r e : r a i n i s n o n n u l l
∗P o s t : r a i n [ x ] [ y ] == 0 f o r a l l x , y i n t h e a r r a y
∗N o t e t h a t t h e l o o p s u s e u n i t i n d e x i n g .
∗/
public void i n i t R a i n ( double r a i n [ ] [ ] ) {
for (i n t month = 1 ; month <r a i n . length ; month++)
for (i n t day = 1 ; day <r a i n [ month ] . length ; day++)
r a i n [ month ] [ day ] = Math . random ( ) ∗2 . 0 ; // Random r a i n f a l l
}// i n i t R a i n ( )
/∗∗
∗C o m p u t e s a v e r a g e d a i l y r a i n f a l l f o r a y e a r o f r a i n f a l l d a t a
∗@ p a r a m r a i n i s a 2 D −a r r a y o f r a i n f a l l s
∗@ r e t u r n T h e sum o f r a i n [ x ] [ y ] / 3 5 6
∗P r e : r a i n i s n o n n u l l
∗P o s t : T h e sum o f r a i n / 3 6 5 i s c a l c u l a t e d
∗N o t e t h a t t h e l o o p s a r e u n i t i n d e x e d
∗/
public double avgDailyRain ( double r a i n [ ] [ ] ) {
double t o t a l = 0 ;
for (i n t month = 1 ; month <r a i n . length ; month++)
for (i n t day = 1 ; day <r a i n [ month ] . length ; day++)
t o t a l += r a i n [ month ] [ day ] ;
return t o t a l /365;
}// a v g D a i l y R a i n ( )
/∗∗
∗C o m p u t e s a v e r a g e d a i l y r a i n f a l l f o r a g i v e n m o n t h c o n t a i n i n g n D a y
∗@ p a r a m m o n t h R a i n i s a 1 D −a r r a y o f r a i n f a l l s
∗@ p a r a m n D a y s i s t h e n u m b e r o f d a y s i n m o n t h R a i n
∗@ r e t u r n T h e sum o f m o n t h R a i n / n D a y s
∗P r e : 1 <= n D a y s <= 3 1
∗P o s t : T h e sum o f m o n t h R a i n / n D a y s i s c a l c u l a t e d
∗/
public double avgRainForMonth ( double monthRain [ ] , i n t nDays ) {
double t o t a l = 0 ;
for (i n t day = 1 ; day <monthRain . length ; day++)
t o t a l = t o t a l + monthRain [ day ] ;
return t o t a l /nDays ;
}// a v g R a i n F o r M o n t h ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
double r a i n f a l l [ ] [ ] = new double [ 1 3 ] [ 3 2 ] ;
R a i n f a l l data = new R a i n f a l l ( ) ;
data . i n i t R a i n ( r a i n f a l l ) ;
System . out . p r i n t l n ( ”The average d a i l y r a i n f a l l = ”
+ data . avgDailyRain ( r a i n f a l l ) ) ;
System . out . p r i n t l n ( ”The average d a i l y r a i n f a l l f o r March = ”
+ data . avgRainForMonth ( r a i n f a l l [ 3 ] , 3 1 ) ) ;
}// m a i n ( )
}// R a i n f a l l
✡ ✠
Figure 9.22: Deﬁnition of the Rainfall class.
SECTION 7 •Multidimensional Arrays 439
array algorithms. It creates the rainfall array in the main() method. It
then initializes the array and prints out average daily rain fall and average
daily rainfall for the month of March. However, note that we ha ve made a
slight modiﬁcation to the initRain() method. Instead of just assigning
0 to each element, we assign a random value between 0 and 2.0:
☛ ✟
r a i n [ month ] [ day ] = Math . random ( ) ∗2 . 0 ;
✡ ✠
Using the Math.random() method in this way enables us to generate
some realistic test data. In this case, we have scaled the data so that the Generating test data
daily rainfall is between 0 and 2 inches. (Rainfall like this would probably
be appropriate for an Amazonian rain forest!) Testing our al gorithms with
these data provides some indication that our methods are in f act working
properly.
JAVA EFFECTIVE DESIGN Generating Test Data. The
Math.random() method can be used to generate numeric test data,
when large amounts of data are required. The data can be scale d to ﬁt
within the range that the actual data are expected to have.
SELF-STUDY EXERCISES
EXERCISE 9.17 Suppose you’re going to keep track of the daily news-
paper sales at the local kiosk. Declare a 52×7two-dimensional array of
int and initialize each of its elements to 0.
EXERCISE 9.18 Write a method to calculate the average number of
newspapers sold per week, using the array you declared in the previous
exercise.
EXERCISE 9.19 Write a method to calculate the average number of
newspapers sold on Sundays, using the array you declared in t he previous
exercise. Assume that Sunday is the last day of the week.
9.8 Multidimensional Arrays (Optional)
Java doesn’t limit arrays to just two dimensions. For example , suppose
we decide to extend our rainfall survey to cover a ten-year pe riod. For
each year we now need a two-dimensional array. This results i n a three-
dimensional array consisting of an array of years, each of wh ich contains
an array of months, each of which contains an array of days:
☛ ✟
f i n a l i n t NYEARS = 1 0 ;
f i n a l i n t N M O N T H S = 1 3 ;
f i n a l i n t NDAYS = 3 2 ;
double r a i n f a l l [ ] [ ] = new double [NYEARS] [N M O N T H S] [NDAYS] ;
✡ ✠
Following the design convention of not using the 0 month and 0 days, we
end up with a 10×13×32array. Note the use of final variables to
440 CHAPTER 9 •Arrays and Array Processing
represent the size of each dimension of the array. This helps to make the
program more readable.
In Figure 9.23, each year of the rainfall data is represented a s a separate
page. On each page, there is a two-dimensional table that con sists of 12
rows (1 per month) and 31 columns (1 per day).
0
1
2
.
.
.
11
12
130 1 2 year 0 . . . 31
00 1 2 year 2 . . . 31
1 J
2 F
.
. A
. M
J
J
A
S
11 O
12 N
13 DM00 1 2 year 1 . . . 31
1
2
.
.
.
11
12
13Figure 9.23:
data might
tion of pages,
tains a two-dimensional
You might imagine that our study could be extended to cover ra in-
fall data from a number of different cities. That would resul t in a four-
dimensional array, with the ﬁrst dimension now being the cit y. Of course,
for this to work, cities would have to be represented by integ ers, because
array subscripts must be integers.
As you might expect, algorithms for processing each element in a three-
dimensional table would require a three-level nested loop. For example,
the following algorithm would be used to initialize all elem ents of our
three-dimensional rainfall array:
☛ ✟
for (i n t year = 0 ; year <r a i n f a l l . length ; year ++)
for (i n t month = 0 ; month <r a i n f a l l [ year ] . length ; month++)
for (i n t day = 0 ; day <r a i n f a l l [ year ] [ month ] . length ; day++)
r a i n f a l l [ year ] [ month ] [ day ] = 0 . 0 ;
✡ ✠
Note again the proper use of the length attribute for each of the
three dimensions of the array. In the outer loop, rainfall.length ,
we’re referring to the number of years. In the middle loop,
rainfall[year].length , we’re referring to number of months within
a given year. In the inner loop, rainfall[year][month].length ,
we’re referring to the number of days within a month.
If we added a fourth dimension to our array and wanted to extend
this algorithm to initialize it, we would simply embed the th ree-level loop
within another for loop that would iterate over each city.
SECTION 8 •OOD: Polymorphic Sorting 441
9.8.1 Array Initializers
It is possible to use an initializer with a multidimensional array . For in-
stance, the following examples create several small arrays and initialize
their elements:
☛ ✟
i n t a [ ] [ ] = {{1 ,2 ,3},{4 , 5 , 6}};
char c [ ] [ ] = {{’ a ’,’ b ’},{’ c ’,’d ’}};
double d [ ] [ ] [ ] =
{{1 . 0 , 2 . 0 , 3 . 0 },{4 . 0 , 5 . 0 },{6 . 0 , 7 . 0 , 8 . 0 , 9 . 0 }};
✡ ✠
The ﬁrst of these declarations creates a 2×3array of integers. The second
example creates a 2×2array of characters, and the third example creates
an array of double consisting of three rows, each of which has a different
number of elements. The ﬁrst row contains three elements, th e second
contains two elements, and the last row contains four elemen ts. As this
last example shows, the rows in a multidimensional array don ’t all have
to have the same length.
Using initializers, as in these examples, is feasible only f or relatively
small arrays. To see why, just imagine what the initializer ex pression
would be for our three-dimensional rainfall array. It would require
4,160=10×13×32zeroes, separated by commas!
JAVA PROGRAMMING TIP Array Initializers. Initializer
(assignment) expressions can be used to assign initial valu es to
relatively small arrays. For larger arrays, an initializer method should
be designed.
9.9 OBJECT-ORIENTED DESIGN:
Polymorphic Sorting (Optional)
One limitation of the sort routines developed so far is that t hey only
work on one particular type of data. If you’ve written an inser tion
sort to sort ints, you can’t use it to sort double s. What would be
far more desirable is a polymorphic sort method —that is, one method
that could sort any kind of data. This is easily done by making use of
Java wrapper classes, such as Integer andDouble , together with the
java.lang.Comparable interface, which is specially designed for this
purpose.
Thejava.lang.Comparable interface consists of the compareTo()
method:
☛ ✟
public a b s t r a c t i n t e r f a c e Comparable {
public i n t compareTo ( Object o ) ; // A b s t r a c t m e t h o d
}
✡ ✠
By implementing compareTo() , a class can impose an order on its ob-+toString() : StringObject
«interface»
Comparable
+Integer(in i : int)
+parseInt(in s : String) : int
+toString() : String
+compareTo(in o : Object) : intInteger
+Float(in f : Float)
+parseFloat(in s : String) : float
+toString() : String
+compareTo(in o : Object) : intFloat+compareTo(in o : Object) : int
FIGURE 9.24 Java wrapper classes,
such as Integer andDouble ,
implement the Comparable
interface.
442 CHAPTER 9 •Arrays and Array Processing
jects. The Comparable interface is implemented by all of Java’s wrapper
classes—that is, by Integer ,Double ,Float ,Long , and so on (Fig. 9.24).
As we saw in Chapter 8, Java interfaces allow us to create a for m of mul-
tiple inheritance . For example, as Figure 9.24 shows, an Integer is both an
Object and aComparable . One implication of this is that an Integer
can be used in any method that takes either an Object parameter or a
Comparable parameter.
ThecompareTo() method takes an Object parameter and returns an
int. It is meant to be invoked as o1.compareTo(o2) , where o1and o2
are objects of the same type. Classes that implement compareTo() must
abide by the following rules for its return value:
☛ ✟
i f( o1<o2 ) then o1 . compareTo ( o2 ) <0
i f( o1 . equals ( o2 ) ) then o1 . compareTo ( o2 ) == 0
i f( o1>o2 ) then o1 . compareTo ( o2 ) >0
✡ ✠
In other words, if o1 < o2 , theno1.compareTo(o2) will return a neg-
ative integer. If o1 > o2 , theno1.compareTo(o2) will return a posi-
tive integer. And if o1ando2are equal, then o1.compareTo(o2) will
return 0.
For a class that implements Comparable , we can use the compareTo()
method to help sort its elements. For example, the following revised
version of insertionSort() method can be used to sort any array of
Comparable objects—that is, any array of objects whose class imple-
mentsComparable :
☛ ✟
public void s o r t ( Comparable [ ] a r r ) {
Comparable temp ; // T e m p o r a r y v a r i a b l e f o r i n s e r t i o n
for (i n t k = 1 ; k <a r r . length ; k++) {
temp = a r r [ k ] ; // R e m o v e i t f r o m a r r a y
i n t i ;
for ( i = k−1; i>= 0 && a r r [ i ] . compareTo ( temp ) >0 ; i−−)
a r r [ i +1] = a r r [ i ] ; // Move i t r i g h t b y o n e
a r r [ i +1] = temp ; // I n s e r t t h e e l e m e n t
}
}// s o r t ( )
✡ ✠
In this version, the parameter is an array of Comparable . Thus, we can
pass it any array whose elements implement Comparable , including an
array of Integer orFloat , and so on. Then, to compare elements of a
Comparable array, we use the compareTo() method:
☛ ✟
for ( i = k−1; i>= 0 && a r r [ i ] . compareTo ( temp ) >0 ; i−−)
✡ ✠
Note that our algorithm no longer refers to ints, as in the original in-
sertion sort. Indeed, it doesn’t mention the speciﬁc type— Integer ,
Float , or whatever—of the objects that it is sorting. It refers only to
Comparable s. Therefore, we can use this method to sort any type
of object, as long as the object’s class implements the Comparable
interface. Thus, by using Comparable , we have a more general
SECTION 9 •OOD: Polymorphic Sorting 443
insertionSort() method, one that can sort any one-dimensional array
ofComparable s.
TheTestSort class (Figs. 9.25 and 9.26) provides an example of how
to use the polymorphic sort() method.+sort(in arr : Comparable[])
+print(in arr : Comparable[])
+main()TestSort
+MAXSIZE : int
FIGURE 9.25 TheTestSort()
class.It contains three methods: The sort() method that we just described;
a polymorphic print() method, which can be used to print the val-
ues of any array of Comparable ; and a main() method. The main()
method creates arrays of Integer andFloat and then uses the poly-
morphic sort() method to sort them. Note how the print() method
uses the polymorphic toString() method to print the elements of a
Comparable array.
☛ ✟
public c l a s s T e s t S o r t {
public s t a t i c i n t MAXSIZE = 2 5 ;
public void s o r t ( Comparable [ ] a r r ) {
Comparable temp ; // T e m p o r a r y v a r i a b l e f o r i n s e r t i o n
for (i n t k = 1 ; k <a r r . length ; k++) {// F o r e a c h e l e m e n t
temp = a r r [ k ] ; // R e m o v e i t
i n t i ;
for ( i = k−1; i>= 0 && a r r [ i ] . compareTo ( temp ) >0 ; i−−)
a r r [ i +1] = a r r [ i ] ; // Move l a r g e r t o t h e r i g h t
a r r [ i +1] = temp ; // I n s e r t t h e e l e m e n t
}
}// s o r t ( )
public void p r i n t ( Comparable a r r [ ] ) {
for (i n t k = 0 ; k <a r r . length ; k++) {
i f( k % 5 == 0) System . out . p r i n t l n ( ) ; // New r o w
System . out . p r i n t ( a r r [ k ] . t o S t r i n g ( ) + ”\t ”) ;
}
System . out . p r i n t l n ( ) ;
}
// S o r t s t w o d i f f e r e n t t y p e s o f a r r a y w i t h t h e s a m e m e t h o d .
public s t a t i c void main ( S t r i n g args [ ] ) {
I n t e g e r iArr [ ] = new I n t e g e r [ T e s t S o r t . MAXSIZE ] ;
F l o a t fArr [ ] = new F l o a t [ T e s t S o r t . MAXSIZE ] ;
for (i n t k = 0 ; k <T e s t S o r t . MAXSIZE ; k++) {// C r e a t e d a t a
iArr [ k ] = new I n t e g e r ( ( i n t) ( Math . random ( ) ∗1 0 0 0 0 ) ) ;
fArr [ k ] = new F l o a t ( Math . random ( ) ∗1 0 0 0 0 ) ;
}
T e s t S o r t t e s t = new T e s t S o r t ( ) ;
t e s t . s o r t ( iArr ) ; // S o r t a n d p r i n t I n t e g e r s
t e s t . p r i n t ( iArr ) ;
t e s t . s o r t ( fArr ) ; // S o r t a n d p r i n t F l o a t s
t e s t . p r i n t ( fArr ) ;
}// m a i n ( )
}
✡ ✠
Figure 9.26: TestSort uses the polymorphic sort() method to sort
eitherInteger s orFloat s.
This example of polymorphic sorting illustrates once again the great
power of inheritance and polymorphism in object-oriented pr ogramming.
444 CHAPTER 9 •Arrays and Array Processing
TheInteger andFloat classes use class inheritance to inherit features
from the Object class, and they use interface implementation to inherit
thecompareTo() method from the Comparable class. By implement-
ing versions of the toString() andcompareTo() methods that are ap-
propriate for these wrapper classes, Java makes it easier to useInteger
andFloat objects in a variety of contexts. Taken together, inheritanc e
and polymorphism enable us to design very general and extens ible algo-
rithms. In this example, we deﬁned a sort() method that can sort an
array containing any kind of object as long as the object implem ents the
Comparable interface.
9.9.1 The java.util.Arrays.sort() Method
While sorting algorithms provide a good way to introduce the c oncepts
of array processing, real-world programmers never write th eir own sort
algorithms. Instead they use library methods, which have bee n writ-
ten and optimized by programming experts. Moreover, librar y sort rou-
tines use sort algorithms that are much more efﬁcient than th e ones we’ve
discussed.
Thejava.util.Arrays class contains a polymorphic sort method
that is very simple to use. For example, here’s how we would us e it to sort
the two arrays declared in the TestSort program:
☛ ✟
java . u t i l . Arrays . s o r t ( iArr ) ;
java . u t i l . Arrays . s o r t ( fArr ) ;
✡ ✠
That’s all there is to it! Obviously, learning how to use Java ’s class and
method library, saves real-word programmers lots of effort .
+Vector()
+Vector(in size : int)
+addElement(in o : Object)
+elementAt(in index : int) : Object
+insertElementAt(in o : Object, in x : int)
+indexOf(in o : Object) : int
+lastIndexOf(in o : Object) : int
+removeElementAt(in index : int)
+size() : intVector
FIGURE 9.27 The
java.util.Vector class.SELF-STUDY EXERCISES
EXERCISE 9.20 Add a deﬁnition of a compareTo() method to the
LetterFreq class so that it implements the Comparable interface. The
method should deﬁne one object to be less than another object if itsfreq
instance variable is less.
EXERCISE 9.21 Add a deﬁnition of a sort() method that can be
added to the deﬁnition of the AnalyzeFreq class. Make it so the
array in the class can be sorted into ascending order using th e or-
dering of LetterFreq deﬁned in the previous exercise. Use the
java.util.Arrays.sort() method.
EXERCISE 9.22 Rewrite the main() of the AnalyzeFreq class to
make use of the sort() method of the previous exercise.
9.10 From the Java Library: java.util.Vector
java.sun.com/j2se/1.5.0/docs/api/Thejava.util.Vector class implements an array of objects that can
grow in size as needed. One limitation of regular arrays is th at their
lengths remain ﬁxed. Once the array is full—once every elemen t is used—
you can’t allocate additional elements.
SECTION 9.10 •From the Java Library: java.util.Vector 445
TheVector class contains methods for storing and retrieving ob-
jects, and for accessing objects by their index position withi n theVector
(Fig. 9.27).
One use for a Vector would be when a program needs to store input
from the user or a ﬁle without knowing in advance how many item s there
are. Using a Vector is less efﬁcient than an array in terms of processing
speed, but it gives you the ﬂexibility of growing the data stru cture to meet
the storage requirements.
As an illustration of this idea, the program in Figure 9.28 cr eates a ran-
dom number of integers and then stores them in a Vector . TheVector ,
which is declared and instantiated in main() , is initially empty. Integers
from 0 to the random bound are then inserted into the Vector . In this
case, insertions are done with the addElement() method, which causes
theVector object to insert the element at the next available location,
increasing its size, if necessary.
☛ ✟
import java . u t i l . Vector ;
public c l a s s VectorDemo {
public s t a t i c void printVector ( Vector v ) {
for (i n t k =0; k <v . s i z e ( ) ; k++)
System . out . p r i n t l n ( v . elementAt ( k ) . t o S t r i n g ( ) ) ;
}// p r i n t V e c t o r ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
Vector vector = new Vector ( ) ; // An e m p t y v e c t o r
i n t bound = ( i n t) ( Math . random ( ) ∗2 0 ) ;
for (i n t k = 0 ; k <bound ; k++ ) // I n s e r t a r a n d o m
vector . addElement ( new I n t e g e r ( k ) ) ; // n u m b e r o f I n t e g e r s
printVector ( vector ) ; // P r i n t t h e e l e m e n t s
}// m a i n ( )
}// V e c t o r D e m o
✡ ✠
Figure 9.28: Demonstration of the Vector class.
Once all the integers have been inserted, the printVector() method
is called. Note that it uses the size() method to determine how many
elements the Vector contains. This is similar to using the length()
method to determine the number of characters in a String .
Finally, note that a Vector stores objects. It cannot be used to store
primitive data values. You cannot store an int in aVector . Therefore,
we need to use the Integer wrapper class to convert ints intoInteger s
before they can be inserted into the Vector . Because you can’t just print
anInteger , or any other Object , thetoString() method is used to
print the string representation of the object.
By deﬁning Vector to store Object s, Java’s designers have made it as Vectors store objects
446 CHAPTER 9 •Arrays and Array Processing
Figure 9.29:
ComputerGame
general as possible and, therefore, as widely useful as poss ible.
JAVA EFFECTIVE DESIGN Generality. Deﬁning a data collection,
such as an array or a Vector , in terms of the Object class makes it
capable of storing and processing any type of value, includi ng values
of primitive data types. This is because the Object class is the root
of the Java class hierarchy.
9.11 Case Study: An N-Player Computer Game
In this section we will make use of arrays to extend our game-pl aying
library by developing a design that can support games that in volve more
than two players. We will use an array to store a variable numb er of play-
ers. Following the object-oriented design principles descr ibed in Chap-
ter 8, we will make use of inheritance and polymorphism to dev elop a
design that is ﬂexible and extensible, one that can be used to i mplement
a wide variety of computer games. As in our TwoPlayer game example
from Chapter 8, our design will allow both humans and compute rs to play
the games. To help simplify the example, we will modify the WordGuess
game that we developed in the Chapter 8. As you will see, it req uires rela-
tively few modiﬁcations to convert it from a subclass of TwoPlayerGame
to a subclass of ComputerGame , the superclass for our N-Player game
hierarchy.
9.11.1 The ComputerGame Hierarchy
Figure 9.29 provides a summary overview of the ComputerGame hierar-
chy. This ﬁgure shows the relationships among the many class es and in-
terfaces involved. The two classes whose symbols are bold, WordGuess
andWordGuesser , are the classes that deﬁne the speciﬁc game we will
SECTION 9.11 •Case Study: An N-Player Computer Game 447
be playing. The rest of the classes and interfaces are design ed to be used
with any N-player game.
At the root of this hierarchy is the abstract ComputerGame class. Note
that it uses from 1 to NPlayer s. These objects will be stored in a one-
dimensional array in ComputerGame . Recall from Chapter 8 that an
IPlayer was any class that implements the makeAMove() method. In this
design, we have put the abstract makeAMove() method into the Player
class, a class that deﬁnes a generic player of computer games . For the
WordGuess game, the WordGuesser class extends Player . In order to
play Word Guess, we will create a WordGuess instance, plus one or more
instances of WordGuesser s. This is similar to the OneRowNim example
from the previous chapter,
Note where the TwoPlayerGame andOneRowNim classes occur in the
hierarchy. TwoPlayerGame will now be an extension of ComputerGame .
This is in keeping with the fact that a two-player game is a spe cial kind
of N-player computer game. As we will see when we look at the de -
tails of these classes, TwoPlayerGame will override some of the methods
inherited from ComputerGame .
Because it contains the abstract makeAMove() method, the Player
class is an abstract class. Its purpose is to deﬁne and store ce rtain data
and methods that can be used by any computer games. For exampl e, one
important piece of information deﬁned in Player is whether the player
is a computer or a person. Player ’s data and methods will be inherited
byWordGuesser and by other classes that extend Player . Given its
position in the hierarchy, we will be able to deﬁne polymorph ic methods
forWordGuesser s that treat them as Player s. As we will see, this will
give our design great ﬂexibility and extensibility.
9.11.2 The ComputerGame Class
Figure 9.30 shows the design details of the ComputerGame class. One
of the key tasks of the ComputerGame class is to manage the one or
more computer game players. Because this is a task that is com mon to
all computer games, it makes sense to manage it here in the sup erclass.
Toward this end, ComputerGame declares four instance variables and
several methods. Three int variables deﬁne the total number of play-
ers (nPlayers ), the number of players that have been added to the game
(addedPlayers ), and the player whose turn it is ( whoseTurn ). An ar-
ray named player stores the Player s. In keeping with the zero indexing
convention of arrays, we number the players from 0 to nPlayers-1 . These
variables are all declared protected , so that they can be referenced di-
rectly by ComputerGame subclasses, but as protected variables, they
remain hidden from all other classes.
FIGURE 9.30 TheComputerGame
class.TheComputerGame(int) constructor allows the number of players
to be set when the game is constructed. The default construct or sets the
448 CHAPTER 9 •Arrays and Array Processing
number of players to one. The constructors create an array of length
nPlayers :
☛ ✟
public ComputerGame ( i n t n ){
nPlayers = n ;
player = new Player [ n ] ; // C r e a t e t h e a r r a y
}
✡ ✠
ThesetPlayer() andgetPlayer() methods are the mutator and ac-
cessor methods for the whoseTurn variable. This variable allows a user
to determine and set whose turn it is, a useful feature for ini tializing a
game. The changePlayer() method uses the default expression,
☛ ✟
whoseTurn = ( whoseTurn + 1) % nPlayers
✡ ✠
for changing whose turn it is. Assuming that players are numb ered from 0
tonPlayers-1 , this code gives the turn to the next player, wrapping around
to player 0, if necessary. Of course, a subclass of ComputerGame can
override this method if the game requires some other order of play.
TheaddPlayer(Player) method is used to add a new Player to
the game, including any subclass of Player . The method assumes that
addedPlayers is initialized to 0. It increments this variable by 1 each
time a new player is added to the array. For the game WordGuess , we
would be adding Player s of type WordGuesser to the game.
The complete source code for ComputerGame is shown in Figure 9.31.
There are several points worth noting about this implementa tion. First,
note that just as in the case of the abstract TwoPlayerGame class from
Chapter 8, the methods gameOver() andgetWinner() are deﬁned as
abstract and the getRules() method is given a generic implementa-
tion. The intent here is that the subclass will override getRules() and
will provide game-speciﬁc implementations for the abstrac t methods.
Second, note how the addPlayer() method is coded. It uses the
addedPlayers variable as the index into the player array, which al-
ways has length nPlayers . An attempt to call this method when the
array is already full will lead to the following exception be ing thrown by
Java:
☛ ✟
Exception in thread ‘ ‘ main ’ ’
java . lang . ArrayIndexOutOfBoundsException : 2
at ComputerGame . addPlayer ( ComputerGame . java : 2 2 )
at TwentyOne . main ( TwentyOne . java : 1 2 1 )
✡ ✠
In other words, it is an error to try to add more players than wil l ﬁt in
theplayer array. In Chapter 11, we will learn how to design our code to
guard against such problems.
Finally, note the implementation of the listPlayers() method
(Fig. 9.31). Here is a good example of polymorphism at work.
The elements of the player array have a declared type of Player .
Their dynamic type is WordGuesser . So when the expression
player[k].toString() is invoked, dynamic binding is used to bind
SECTION 9.11 •Case Study: An N-Player Computer Game 449
☛ ✟
public a b s t r a c t c l a s s ComputerGame {
protected i n t nPlayers ;
protected i n t addedPlayers = 0 ;
protected i n t whoseTurn ;
protected Player player [ ] ; // An a r r a y o f p l a y e r s
public ComputerGame ( ) {
nPlayers = 1 ; // D e f a u l t : 1 p l a y e r g a m e
player = new Player [ 1 ] ;
}
public ComputerGame ( i n t n ){
nPlayers = n ;
player = new Player [ n ] ; // N−P l a y e r g a m e
}
public void s e t P l a y e r ( i n t s t a r t e r ) {
whoseTurn = s t a r t e r ;
}
public i n t getPlayer ( ) {
return whoseTurn ;
}
public void addPlayer ( Player p ) {
player [ addedPlayers ] = p ;
++addedPlayers ;
}
public void changePlayer ( ) {
whoseTurn = ( whoseTurn + 1) % nPlayers ;
}
public S t r i n g getRules ( ) {
return ”The r u l e s of t h i s game are : ” ;
}
public S t r i n g l i s t P l a y e r s ( ) {
S t r i n g B u f f e r r e s u l t =
new S t r i n g B u f f e r ( ”\nThe players are : \n”) ;
for (i n t k = 0 ; k <nPlayers ; k++)
r e s u l t . append ( ” Player ” + k + ” ” +
player [ k ] . t o S t r i n g ( ) + ”\n”) ;
r e s u l t . append ( ”\n”) ;
return r e s u l t . t o S t r i n g ( ) ;
}
public a b s t r a c t boolean gameOver ( ) ; // A b s t r a c t
public a b s t r a c t S t r i n g getWinner ( ) ; // m e t h o d s
}// C o m p u t e r G a m e
✡ ✠
Figure 9.31: Implementation of the ComputerGame class.
this method call to the implementation of toString() deﬁned in the
WordGuesser class. Thus, by allowing toString() to be bound at run
time, we are able to deﬁne a method here that doesn’t know the e xact
types of the objects it will be listing.
The power of polymorphism is the ﬂexibility and extensibilit y it lends polymorphism
to our class hierarchy. Without this feature, we would not be able to deﬁne
450 CHAPTER 9 •Arrays and Array Processing
listPlayers() here in the superclass, and would instead have to deﬁne
it in each subclass.
JAVA EFFECTIVE DESIGN Extensibility. Polymorphic methods
allow us to implement methods that can be applied to
yet-to-be-deﬁned subclasses.
FIGURE 9.32 TheWordGuess
class.9.11.3 The WordGuess andWordGuesser Classes
We will assume here that you are familiar with the WordGuess example
from Chapter 8. If not, you will need to review that section bef ore proceed-
ing. Word Guess is a game in which players take turns trying to guess a
secret word by guessing its letters. Players keep guessing a s long as they
correctly guess a letter in the word. If they guess wrong, it be comes the
next player’s turn. The winner of the game is the person who gu esses the
last letter secret letter, thereby completely identifying the word.
Figure 9.32 provides an overview of the WordGuess class. If you com-
pare it with the design we used in Chapter 8, the only change in the in-
stance methods and instance variables is the addition of a ne w constructor,
WordGuess(int) , and an init() method. This constructor takes an in-
teger parameter representing the number of players. The def ault construc-
tor assumes that there is one player. Of course, this version ofWordGuess
extends the ComputerGame class, rather than the TwoPlayerGame class.
Both constructors call the init() method to initialize the game:
☛ ✟
public WordGuess ( ) {super ( 1 ) ; i n i t ( ) ; }
public WordGuess ( i n t m){super (m) ; i n i t ( ) ; }
public void i n i t ( ) {
secretWord = getSecretWord ( ) ;
currentWord = new S t r i n g B u f f e r ( secretWord ) ;
previousGuesses = new S t r i n g B u f f e r ( ) ;
for (i n t k = 0 ; k <secretWord . length ( ) ; k++)
currentWord . setCharAt ( k , ’ ? ’) ;
unguessedLetters = secretWord . length ( ) ;
}
✡ ✠
The only other change required to convert WordGuess to an N-player
game, is to rewrite its play() method. Because the new play() method
makes use of functionality inherited from the ComputerGame() class,
SECTION 9.11 •Case Study: An N-Player Computer Game 451
it is actually much simpler than the play() method in the Chapter 8
version:
☛ ✟
public void play ( U s e r I n t e r f a c e ui ) {
ui . report ( getRules ( ) ) ;
ui . report ( l i s t P l a y e r s ( ) ) ;
ui . report ( reportGameState ( ) ) ;
while ( ! gameOver ( ) ) {
WordGuesser p = ( WordGuesser ) player [ whoseTurn ] ;
i f( p . isComputer ( ) )
ui . report ( submitUserMove ( p . makeAMove( getGamePrompt ( ) ) ) ) ;
else{
ui . prompt ( getGamePrompt ( ) ) ;
ui . report ( submitUserMove ( ui . getUserInput ( ) ) ) ;
}
ui . report ( reportGameState ( ) ) ;
}// w h i l e
}
✡ ✠
The method begins by displaying the game’s rules and listing its players.
ThelistPlayers() method is inherited from the ComputerGame class.
After displaying the game’s current state, the method enter s the play loop.
On each iteration of the loop, a player is selected from the ar ray:
☛ ✟
WordGuesser p = ( WordGuesser ) player [ whoseTurn ] ;
✡ ✠
The use of the WordGuesser variable, p, just makes the code some-
what more readable. Note that we have to use a cast operator,
(WordGuesser) , to convert the array element, a Player , into a
WordGuesser . Because pis aWordGuesser , we can refer directly to
itsisComputer() method.
If the player is a computer, we prompt it to make a move, submit t he
move to the submitUserMove() method, and then report the result.
This is all done in a single statement:
☛ ✟
ui . report ( submitUserMove ( p . makeAMove( getGamePrompt ( ) ) ) ) ;
✡ ✠
If the player is a human, we prompt the player and use the
KeyboardReader ’sgetUserInput() method to read the user’s move.
We then submit the move to the submitUserMove() method and report
the result. At the end of the loop, we report the game’s update d state.
452 CHAPTER 9 •Arrays and Array Processing
The following code segment illustrates a small portion of th e interaction
generated by this play() method:
☛ ✟
Current word ? ? ? ? ? ? ? ? Previous guesses GLE
Player 0 guesses next . Sorry , Y i s NOT a new l e t t e r
in the s e c r e t word
Current word ? ? ? ? ? ? ? ? Previous guesses GLEY
Player 1 guesses next . Sorry , H i s NOT a new l e t t e r
in the s e c r e t word
Current word ? ? ? ? ? ? ? ? Previous guesses GLEYH
Player 2 guesses next .
Guess a l e t t e r t h a t you think i s in the s e c r e t word : a
Yes , the l e t t e r A i s in the s e c r e t word
✡ ✠
In this example, players 0 and 1 are computers and player 2 is a h uman.
FIGURE 9.33 TheWordGuesser
class extends Player .In our new design, the WordGuesser class is a subclass of Player
(Figure 9.33). The WordGuesser class itself requires no changes other
than its declaration:
☛ ✟
public c l a s s WordGuesser extends Player
✡ ✠
As we saw when we were discussing the WordGuess class, the play()
method invokes WordGuesser ’sisComputer() method. But this
method is inherited from the Player class. The only other method used
byplay() is themakeAMove() method. This method is coded exactly
the same as it was in the previous version of WordGuesser .
Figure 9.34 shows the implementation of the Player class. Most of
its code is very simple. Note that the default value for the kind vari-
able is HUMAN and the default idis -1, indicating the lack of an assigned
identiﬁcation.
☛ ✟
public a b s t r a c t c l a s s Player {
public s t a t i c f i n a l i n t COMPUTER=0;
public s t a t i c f i n a l i n t H U M A N=1;
protected i n t id =−1; // I d b e t w e e n 0 a n d n P l a y e r s −1
protected i n t kind = H U M A N; // D e f a u l t i s HUMAN
public Player ( ) { }
public Player ( i n t id , i n t kind ){
t h i s . id = id ;
t h i s . kind = kind ;
}
public void setID ( i n t k ){id = k ; }
public i n t getID ( ) {return id ;}
public void setKind ( i n t k ){kind = k ; }
public i n t getKind ( ) {return kind ;}
public boolean isComputer ( ) {return kind == COMPUTER; }
public a b s t r a c t S t r i n g makeAMove( S t r i n g prompt ) ;
}// P l a y e r
✡ ✠
Figure 9.34: Implementation of the Player class.
SECTION 11 •A GUI-Based Game 453
What gives Player its utility is the fact that it encapsulates those at-
tributes and actions that are common to all computer game pla yers. Deﬁn-
ing these elements, in the superclass, allows them to be used throughout
thePlayer hierarchy. It also makes it possible to establish an associat ion
between a Player and aComputerGame .
Given the ComputerGame andPlayer hierarchies and the many in-
terfaces they contain, the task of designing and implementi ng a new N-
player game is made much simpler. This too is due to the power o f object-
oriented programming. By learning to use a library of classe s, such as
these, even inexperienced programmers can create relative ly sophisticated
and complex computer games.
JAVA EFFECTIVE DESIGN Code Reuse. Re-using library code by
extending classes and implementing interfaces makes it muc h simpler
to create sophisticated applications.
Finally, the following main() method instantiates and runs an instance
of theWordGuess game in a command-line user interface (CLUI):
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] )
{KeyboardReader kb = new KeyboardReader ( ) ;
ComputerGame game = new WordGuess ( 3 ) ;
game . addPlayer ( new WordGuesser ( ( WordGuess ) game , 0 ,
Player .H U M A N) ) ;
game . addPlayer ( new WordGuesser ( ( WordGuess ) game , 1 ,
Player .COMPUTER) ;
game . addPlayer ( new WordGuesser ( ( WordGuess ) game , 2 ,
Player .COMPUTER) ;
( ( CLUIPlayableGame ) game ) . play ( kb ) ;
}// m a i n ( )
✡ ✠
In this example, we create a three player game in which two of th e players
are computers. Note how we create a new WordGuesser , passing it a
reference to the game itself, as well as its individual ident iﬁcation num-
ber, and its type (HUMAN or COMPUTER). To run the game, we simpl y
invoke its play() method. You know enough now about object-oriented
design principles to recognize that the use of play() in this context is an
example of polymorphism.
9.12 A GUI-Based Game (Optional Graphics)
Most modern computer games do not use a command-line interfa ce. This
section addresses this shortcoming by expanding our ComputerGame hi-
erarchy so that it works with Graphical User Interfaces (GUIs) as well as
Command-Line User Interfaces (CLUIs).
The Sliding Tile Puzzle is a puzzle game. It is played by one pla yer,
a human. The puzzle consists of six tiles arranged on a board c ontain-
ing seven spaces. Three of the tiles are labeled Land three are labeled R.
Initially the tiles are arranged as RRR LLL. In other words, the Rtiles are
arranged to the left of the Ltiles, with the blank space in the middle. The
454 CHAPTER 9 •Arrays and Array Processing
object of the puzzle is to rearrange the tiles into LLL RRR . The rules are
that tiles labeled Rcan only move right. Tiles labeled Lcan only move
left. Tiles may move directly into the blank space or they can jump over
one tile into the blank space.
Our purpose in this section is to develop a GUI that plays this game.
An appropriate GUI is shown Figure 9.35. Here the tiles and the blank
space are represented by an array of buttons. To make a move th e user
clicks on the ’tile’ he or she wishes to move. The GUI will assu me that the
user wants to move that tile into the blank space. If the propos ed move
is legal, the GUI will carry out the move. Otherwise, it will ju st ignore it.
For example, if the user were to click on the third Rbutton from the left,
a legal move, the GUI would rearrange the labels on the button s so that
their new conﬁguration would be RRRLLL . On the other hand, if the user
were to click on the rightmost Lbutton, the GUI would ignore that move,
because it is illegal.
Figure 9.35:
zle.
9.12.1 The GUIPlayableGame Interface
How should we extend our game-playing hierarchy to accommoda te
GUI-based games? As we learned in Chapter 4, one difference be tween
GUI-based applications and CLUI-based applications, is the l ocus of con-
trol. In a CLUI-based application, control resides in the comp utational ob-
ject which, for games, is the game object. That’s why the play() method
in our CLUI-based games contains the game’s control loop. By c ontrast,
control resides in the GUI’s event loop in GUI-based applicati ons. That’s
why, we learned how to manage Java’s event hierarchy in Chapt er 4.
Thus, in the GUI shown in Figure 9.35, the GUI will listen and take action
when the user clicks one of its buttons.
However, given that control will reside in the GUI, there is sti ll a need
for communication between the GUI and the game object. In the CL UI-
based games, we have used the CLUIPlayableGame interface to man-
age the communication between the game and the user interfac e. We
will follow the same design strategy in this case. Thus, we wi ll design a
GUIPlayableGame interface that can be implemented by any game that
wishes to use a GUI (Fig. 9.36).
What method(s) should this interface contain? One way to answ er this
question is to think about the type of interaction that must t ake place when
the user clicks one of the tiles. If the user clicks the third Rbutton, the
GUI should pass this information to the game. The game should then
decide whether or not that is a legal move and communicate thi s back to
the GUI. Assuming it is a legal move, the game should also updat e its
representation of the game’s state to reﬂect that the tile arr ay has changed.
And it should somehow make communicate the game’s state to th e GUI.
FIGURE 9.36 The
GUIPlayableGame interface
extends the IGame interface.Because it is impossible to know in advance just what form of da ta
a game’s moves might take, we will use Java String s to communicate
between the user interface and the game object. Thus, a method with the
SECTION 12 •A GUI-Based Game 455
following signature will enable us to submit a String representing the
user’s move to the game and receive in return a String representing the
game object’s response to the move:
☛ ✟
submitUserMove ( S t r i n g move ) : S t r i n g ;
✡ ✠
In addition to this method, a GUI interface could use the reportGame-
State() andgetGamePrompt() methods that are part of the IGame
interface. Th design shown in Figure 9.36 leads to the follow ing deﬁnition
for the GUIPlayableGame interface:
☛ ✟
public i n t e r f a c e GUIPlayableGame extends IGame{
public S t r i n g submitUserMove ( S t r i n g theMove ) ;
}
✡ ✠
Because it extends IGame , this interface inherits the getGamePrompt()
andreportGameState() from the IGame interface. The GUI should be
able to communicate with any game that implements this inter face.
9.12.2 The SlidingTilePuzzle
Let’s now discuss the design and details of the SlidingTilePuzzle it-
self. Its design is summarized in Figure 9.37. Most of the meth ods should
be familiar to you, because the design closely follows the de sign we em-
ployed in the WordGuess example. It has implementations of inher-
ited methods from the ComputerGame class and the GUIPlayableGame
interface.
We will represent the sliding tile puzzle in a one-dimension al array of
char . We will store the puzzle’s solution in a Java String and we will
use an int variable to keep track of where the blank space is in the array .
This leads to the following class-level declarations:
☛ ✟
private char puzzle [ ] = {’R ’,’R ’,’R ’,’ ’,’L ’,’L ’,’L ’};
private S t r i n g s o l u t i o n = ”LLL RRR” ;
private i n t blankAt = 3 ;
✡ ✠
FIGURE 9.37 The
SlidingTilePuzzle is a
ComputerGame that implements the
GUIPlayableGame interface.Note how we initialize the puzzle array with the initial conﬁguration of
seven characters. Taken together, these statements initia lize the puzzle’s
state.
Because a puzzle is a one-person game and our sliding tile puz zle will
be played by a human, this leads to a very simple constructor d eﬁnition:
☛ ✟
public S l i d i n g T i l e P u z z l e ( ) {
super ( 1 ) ;
}
✡ ✠
We call the super() constructor ( ComputerGame() ) to create a one-
person game.
456 CHAPTER 9 •Arrays and Array Processing
The puzzle’s state needs to be communicated to the GUI as a String .
This is the purpose of the reportGameState() method:
☛ ✟
public S t r i n g reportGameState ( ) {
S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
sb . append ( puzzle ) ;
return sb . t o S t r i n g ( ) ;
}
✡ ✠
We use a StringBuffer() to convert the puzzle, a char array, into a
String .
The most important method for communicating with the GUI is t he
submitUserMove() method:
☛ ✟
public S t r i n g submitUserMove ( S t r i n g usermove ) {
i n t t i l e = I n t e g e r . p a r s e I n t ( usermove ) ;
char ch = puzzle [ t i l e ] ;
i f( ch == ’L ’ &&
( blankAt == t i l e −1||blankAt == t i l e −2))
swapTiles ( t i l e , blankAt ) ;
else i f ( ch == ’R ’ &&
( blankAt == t i l e +1 ||blankAt == t i l e + 2 ) )
swapTiles ( t i l e , blankAt ) ;
else
return ” That ’ s an i l l e g a l move . \n”;
return ” That move i s l e g a l . \n”;
}
✡ ✠
This is the method that processes the user’s move, which is co mmuni-
cated through the GUI. As we saw, the puzzle’s ’tiles’ are repr esented by
an array of buttons in the GUI. The buttons are indexed 0 throug h 6 in the
array. When the user clicks a button, the GUI should pass its in dex, repre-
sented as a String to thesubmitUserMove() method. Given the index
number of the tile that was selected by the user, this method d etermines if
the move is legal.
TheInteger.parseInt() method is used to extract the tile’s index
from the method’s parameter. This index is used to get a ’tile ’ from the
puzzle array. The logic in this method reﬂects the rules of the game. If
the tile is an L, then it can only move into a blank space that is either 1 or 2
spaces to its left. Similarly, an Rtile can only move into a blank space that
is 1 or 2 spaces to its right. All other moves are illegal. For l egal moves, we
simply swap the tile and the blank space in the array, a task ha ndled by
theswap() method. In either case, the method returns a string reporting
whether the move was legal or illegal.
Figure 9.38 shows the full implementation for the SlidingTilePuzzle ,
the remaining details of which are straight forward.
SECTION 12 •A GUI-Based Game 457
☛ ✟
public c l a s s S l i d i n g T i l e P u z z l e extends ComputerGame
implements GUIPlayableGame {
private char puzzle [ ] = {’R ’,’R ’,’R ’,’ ’,’L ’,’L ’,’L ’};
private S t r i n g s o l u t i o n = ”LLL RRR” ;
private i n t blankAt = 3 ;
public S l i d i n g T i l e P u z z l e ( ) {super ( 1 ) ;}
public boolean gameOver ( ) {// T r u e i f p u z z l e s o l v e d
S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
sb . append ( puzzle ) ;
return sb . t o S t r i n g ( ) . equals ( s o l u t i o n ) ;
}
public S t r i n g getWinner ( ) {
i f( gameOver ( ) )
return ”\nYou did i t ! Very Nice ! \n”;
else return ”\nGood t r y . Try again ! \n”;
}
public S t r i n g reportGameState ( ) {
S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
sb . append ( puzzle ) ;
return sb . t o S t r i n g ( ) ;
}
public S t r i n g getGamePrompt ( ) {
return ”To move a t i l e , c l i c k on i t . ” ;
}// p r o m p t ( )
public S t r i n g submitUserMove ( S t r i n g usermove ) {
i n t t i l e = I n t e g e r . p a r s e I n t ( usermove ) ;
char ch = puzzle [ t i l e ] ;
i f( ch== ’L ’ && ( blankAt== t i l e −1||blankAt== t i l e −2))
swapTiles ( t i l e , blankAt ) ;
else i f ( ch== ’R ’ &&
( blankAt== t i l e +1 ||blankAt== t i l e + 2 ) )
swapTiles ( t i l e , blankAt ) ;
else
return ” That ’ s an i l l e g a l move . \n”;
return ” That move i s l e g a l . \n”;
}
private void swapTiles ( i n t t i , i n t bl ){
char ch = puzzle [ t i ] ;
puzzle [ t i ] = puzzle [ bl ] ;
puzzle [ bl ] = ch ;
blankAt = t i ; // R e s e t t h e b l a n k
}
}// S l i d i n g T i l e P u z z l e
✡ ✠
Figure 9.38: Implementation of the SlidingTilePuzzle class.
9.12.3 The SlidingGUI Class
Let’s now implement a GUI that can be used to play the sliding t ile puzzle.
We will model the GUI itself after those we designed in Chapte r 4.
458 CHAPTER 9 •Arrays and Array Processing
Figure 9.39 provides a summary of the design. As an implemen-
tor of the ActionListener interface, SlidingGUI implements the
FIGURE 9.39 TheSlidingGUI
class.actionPerformed() method, which is where the code that controls the
puzzle is located. The main data structure is an array of seve nJButton s,
representing the seven tiles in the puzzles. The buttons’ la bels will reﬂect
the state of the puzzle. They will be rearranged after every l egal move by
the user. The reset button is used to reinitialize the game. This allows
users to play again or to start over if they get stuck.
ThepuzzleState is aString variable that stores the puzzle’s current
state, which is updated repeatedly from the SlidingTilePuzzle by
calling its reportGameState() method. The private labelButtons()
method will read the puzzleState and use its letters to set the labels of
the GUI’s buttons.
The implementation of SlidingGUI is shown in Figure 9.40. Its con-
structor and buildGUI() methods are responsible for setting up the GUI.
We use of a for loop in buildGUI() to create the JButton s, asso-
ciate an ActionListener with them, and add them to the GUI. Except
for the fact that we have an array of buttons, this is very simi lar to the
GUI created in Chapter 4. Recall that associating an ActionListener
with the buttons allows the program to respond to button clic ks in its
actionPerformed() method.
Note how an instance of the SlidingTilePuzzle is created in the
constructor, and how its state is retrieved and stored in the puzzleState
variable:
☛ ✟
puzzleState = s l i d i n g . reportGameState ( ) ;
✡ ✠
ThelabelButtons() method transfers the letters in puzzleState
onto the buttons.
The most important method in the GUI is the actionPerformed()
method. This method controls the GUI’s actions and is called a utomat-
ically whenever one of the GUI’s buttons is clicked. First, we check
whether the reset button has been clicked. If so, we reset the puzzle
by creating a new instance of SlidingTilePuzzle and re-initializing
the prompt label.
Next we use a for loop to check whether one of the tile buttons h as
been clicked. If so, we use the loop index, k, as the tile’s identiﬁcation and
submit this to the puzzle as the user’s move:
☛ ✟
i f( e . getSource ( ) == t i l e [ k ] )
r e s u l t = ( ( GUIPlayableGame ) s l i d i n g ) . submitUserMove ( ””+ k ) ;
✡ ✠
The cast operation is necessary here because we declared sliding as
aSlidingTilePuzzle rather than as a GUIPlayableGame . Note
also that we have to convert kto aString when passing it to
submitUserMove() .
SECTION 12 •A GUI-Based Game 459
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s SlidingGUI extends JFrame implements ActionListener {
private JButton t i l e [ ] = new JButton [ 7 ] ;
private JButton r e s e t = new JButton ( ” Reset ” ) ;
private S l i d i n g T i l e P u z z l e s l i d i n g ;
private S t r i n g puzzleState ;
private Label label ;
private S t r i n g prompt = ”Goal : [ LLL RRR ] . ” +
” Click on the t i l e you want to move . ” +
” I l l e g a l moves are ignored . ” ;
public SlidingGUI ( S t r i n g t i t l e ) {
s l i d i n g = new S l i d i n g T i l e P u z z l e ( ) ;
buildGUI ( ) ;
s e t T i t l e ( t i t l e ) ;
pack ( ) ;
s e t V i s i b l e ( true ) ;
}// SlidingGUI ( )
private void buildGUI ( ) {
Container contentPane = getContentPane ( ) ;
contentPane . setLayout ( new BorderLayout ( ) ) ;
JPanel buttons = new JPanel ( ) ;
puzzleState = s l i d i n g . reportGameState ( ) ;
for (i n t k = 0 ; k <t i l e . length ; k++) {
t i l e [ k ] = new JButton ( ””+puzzleState . charAt ( k ) ) ;
t i l e [ k ] . addActionListener ( t h i s ) ;
buttons . add ( t i l e [ k ] ) ;
}
r e s e t . addActionListener ( t h i s ) ;
label =new Label ( prompt ) ;
buttons . add ( r e s e t ) ;
contentPane . add ( ” Center ” , buttons ) ;
contentPane . add ( ”South” ,label ) ;
}// buildGUI ( )
private void l a b e l B u t t o n s ( S t r i n g s ) {
for (i n t k = 0 ; k <t i l e . length ; k++)
t i l e [ k ] . s e t T e x t ( ””+ s . charAt ( k ) ) ;
}// l a b e l B u t t o n s ( )
public void actionPerformed ( ActionEvent e ) {
S t r i n g r e s u l t = ””;
i f( e . getSource ( ) == r e s e t ) {// Reset c l i c k e d ?
s l i d i n g = new S l i d i n g T i l e P u z z l e ( ) ;
label . s e t T e x t ( prompt ) ;
}
for (i n t k = 0 ; k <t i l e . length ; k++) // T i l e c l i c k e d ?
i f( e . getSource ( ) == t i l e [ k ] )
r e s u l t = ( ( GUIPlayableGame ) s l i d i n g ) . submitUserMove ( ””+ k ) ;
i f( r e s u l t . indexOf ( ” i l l e g a l ” ) !=−1)
java . awt . T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . beep ( ) ;
puzzleState = s l i d i n g . reportGameState ( ) ;
l a b e l B u t t o n s ( puzzleState ) ;
i f( s l i d i n g . gameOver ( ) )
label . s e t T e x t ( ”You did i t ! Very nice ! ” ) ;
}// actionPerformed ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
new SlidingGUI ( ” S l i d i n g T i l e Puzzle ” ) ;
}// main ( )
}// SlidingGUI
✡ ✠
Figure 9.40: Implementation of the SlidingGUI class.
460 CHAPTER 9 •Arrays and Array Processing
As a result of this method call, the puzzle returns a result , which is
checked to see if the user’s move was illegal. If result contains the word
“illegal”, the computer beeps to signal an error:
☛ ✟
i f( r e s u l t . indexOf ( ” i l l e g a l ” ) !=−1)
java . awt . T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . beep ( ) ;
✡ ✠
Thejava.awt.Toolkit is a class that contains lots of useful meth-
ods, including the beep() method. Note that no matter what action
is performed, a reset or a tile click, we update puzzleState by call-
ingreportGameState() and use it to relabel the tile buttons. The
last task in the actionPerformed() method is to invoke the puzzle’s
gameOver() method to check if the user has successfully completed the
puzzle. If so, we display a congratulatory message in the GUI’s window.
Finally, the main() for a GUI is very simple, consisting of a single line
of code:
☛ ✟
new SlidingGUI ( ” S l i d i n g T i l e Puzzle ” ) ;
✡ ✠
Once a SlidingGUI is created, with the title of “Sliding Tile Puzzle,” it
will open a window and manage the control of the puzzle.
CHAPTER SUMMARY Technical Terms
array
array
initializer
array length
binary search
data structure
element
element typeinsertion sort
multidimensional
array
one-dimensional
array
polymorphic sort
method
selection sortsequential search
sorting
subscript
two-dimensional
array
Summary of Important Points
•Anarray is a named collection of contiguous storage locations, each
of which stores a data item of the same data type. Each element of an
array is referred to by a subscript —that is, by its position in the array. If
the array contains Nelements, then its length is Nand its indexes are
0, 1, ...N-1 .
•Array elements are referred to using the following subscrip t notation
arrayname[subscript] , where arrayname is any valid identiﬁer, and sub-
script is an integer value in the range 0 to arrayname.length - 1 .
The array’s length instance variable can be used as a bound for loops
that process the array.
CHAPTER 9 •Solutions to Self-Study Exercises 461
•Anarray declaration provides the name and type of the array. An array
instantiation uses the keyword new and causes the compiler to allocate
memory for the array’s elements:
☛ ✟
i n t a r r [ ] ; // D e c l a r e a o n e −d i m e n s i o n a l a r r a y v a r i a b l e
a r r = new i n t [ 1 5 ] ; // A l l o c a t e 1 5 i n t l o c a t i o n s f o r i t
✡ ✠
•Multidimensional arrays have arrays as their components:
☛ ✟
i n t twoDarr [ ] [ ] ; // D e c l a r e a two −d i m e n s i o n a l a r r a y v a r i a b l e
twoDarr = new i n t [ 1 0 ] [ 1 5 ] ; // A l l o c a t e 1 5 0 i n t l o c a t i o n s
✡ ✠
•An array’s values must be initialized by assigning values to each array
location. An initializer expression may be included as part of the array
declaration.
•Insertion sort and selection sort are examples of array sorti ng algo-
rithms. Both algorithms require several passes over the arr ay.
•When an array is passed as a argument to a method, a reference to the
array is passed rather than the entire array itself.
•Swapping two elements of an array, or any two locations in mem ory,
requires the use of a temporary variable.
•Sequential search and binary search are examples of array se arching
algorithms. Binary search requires that the array be sorted .
•For multidimensional arrays, each dimension of the array ha s its own
length variable.
•Inheritance and polymorphism are useful design features for develop-
ing a hierarchy of computer games.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 9.1 Space (in bytes) allocated for each of the following?
a.int a[] = new int[5]; // 5 *4 = 20 bytes
b.double b[] = new double[10]; // 10 *8 = 80 bytes
c.char c[] = new char[30]; // 30 *2 = 60 bytes
d.String s[] = new String[10]; // 10 *4 (reference) = 40 bytes
e.Student s[] = new Student[5]; // 5 *4 (reference) = 20 bytes
SOLUTION 9.2 An array containing 10 float s, 1.0 to 10.0.
☛ ✟
f l o a t f a r r [ ] = {1 . 0 , 2 . 0 , 3 . 0 , 4 . 0 , 5 . 0 , 6 . 0 , 7 . 0 , 8 . 0 , 9 . 0 , 1 0 . 0 };
✡ ✠
SOLUTION 9.3 Prints the ﬁrst element of farr .
☛ ✟
System . out . p r i n t l n ( f a r r [ 0 ] ) ;
✡ ✠
SOLUTION 9.4 Assigns 100.0 to the last element in farr .
☛ ✟
f a r r [ f a r r . length −1] = 1 0 0 . 0 ;
✡ ✠
462 CHAPTER 9 •Arrays and Array Processing
SOLUTION 9.5 A loop to print all of the elements of farr .
☛ ✟
for (i n t j = 0 ; j <f a r r . length ; j ++)
System . out . p r i n t l n ( f a r r [ j ] ) ;
✡ ✠
SOLUTION 9.6 An array containing the ﬁrst 100 square roots.
☛ ✟
double doubarr [ ] = new double [ 1 0 0 ] ;
for (i n t k = 0 ; k <doubarr . length ; k++)
doubarr [ k ] = Math . s q r t ( k + 1 ) ;
✡ ✠
SOLUTION 9.7 Analyzing the letter frequencies in a ﬁle.
☛ ✟
import java . io . ∗;
import java . u t i l . Scanner ;
public s t a t i c void main ( S t r i n g [ ] argv ) {
Scanner f i l e S c a n ; // T o r e a d l i n e s o f t e x t f r o m t h e f i l e
S t r i n g s t r ; // T o s t o r e t h e l i n e o f t e x t
AnalyzeFreq af = new AnalyzeFreq ( ) ;
t r y{ // C r e a t e a S c a n n e r
F i l e t h e F i l e = new F i l e ( ” f r e q t e s t . t x t ” ) ;
f i l e S c a n = Scanner . c r e a t e ( t h e F i l e ) ;
f i l e S c a n = f i l e S c a n . useDelimiter ( ”\r\n”) ; // F o r W i n d o w s
while ( f i l e S c a n . hasNext ( ) ) {// R e a d a n d c o u n t
s t r = f i l e S c a n . next ( ) ;
af . c o u n t L e t t e r s ( s t r ) ;
}// w h i l e
af . printArray ( ) ; // P r i n t f r e q u e n c i e s
}catch ( Exception e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// c a t c h ( )
}// m a i n ( )
✡ ✠
SOLUTION 9.8 Sort 24 18 90 1 0 85 34 18 with insertion sort.
☛ ✟
24 18 90 1 0 85 34 18 // I n i t i a l
18 24 90 1 0 85 34 18 // P a s s 1
18 24 90 1 0 85 34 18 // P a s s 2
1 18 24 90 0 85 34 18 // P a s s 3
0 1 18 24 90 85 34 18 // P a s s 4
0 1 18 24 85 90 34 18 // P a s s 5
0 1 18 24 34 85 90 18 // P a s s 6
0 1 18 18 24 34 85 90 // P a s s 7
✡ ✠
CHAPTER 9 •Solutions to Self-Study Exercises 463
SOLUTION 9.9 Sort 24 18 90 1 0 85 34 18 with selection sort.
☛ ✟
24 18 90 1 0 85 34 18 // I n i t i a l
0 18 90 1 24 85 34 18 // P a s s 1
0 1 90 18 24 85 34 18 // P a s s 2
0 1 18 90 24 85 34 18 // P a s s 3
0 1 18 18 24 85 34 90 // P a s s 4
0 1 18 18 24 85 34 90 // P a s s 5
0 1 18 18 24 34 85 90 // P a s s 6
0 1 18 18 24 34 85 90 // P a s s 7
✡ ✠
SOLUTION 9.10 Code to swap two Student s.
☛ ✟
Student tempStud = student1 ;
student1 = student2 ;
student2 = tempStud ;
✡ ✠
SOLUTION 9.11 Implementation of the selectionSort() .
☛ ✟
public void s e l e c t i o n S o r t ( i n t a r r [ ] ) {
i n t s m a l l e s t ; // L o c a t i o n o f s m a l l e s t e l e m e n t
for (i n t k = 0 ; k <a r r . length −1; k++) {
s m a l l e s t = k ;
for (i n t j = k +1; j <a r r . length ; j ++)
i f( a r r [ j ] <a r r [ s m a l l e s t ] )
s m a l l e s t = j ;
i f( s m a l l e s t != k ) { // S wap s m a l l e s t a n d k t h
i n t temp = a r r [ s m a l l e s t ] ;
a r r [ s m a l l e s t ] = a r r [ k ] ;
a r r [ k ] = temp ;
}// i f
}// o u t e r f o r
}// s e l e c t i o n S o r t ( )
✡ ✠
SOLUTION 9.12 Aftermystery(myArr,k) ,myArr will store 1,2,3,5,5 and k
will store 3.
SOLUTION 9.13 Binary search trace for 21 in 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22 ,
24, 26, 28:
☛ ✟
key i t e r a t i o n low high mid
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
21 0 0 13 6
21 1 7 13 10
21 2 7 9 8
21 3 9 9 9
21 4 10 9 f a i l u r e
✡ ✠
SOLUTION 9.14 A two-dimensional array with 5 rows of 10 integers.
☛ ✟
i n t int2d [ ] [ ] = new i n t [ 5 ] [ 1 0 ] ;
✡ ✠
464 CHAPTER 9 •Arrays and Array Processing
SOLUTION 9.15 Prints the last integer in the third row int2d and assigns 100
to its last element.
☛ ✟
System . out . p r i n t l n ( int2d [ 2 ] [ 9 ] ) ;
int2d [ 4 ] [ 9 ] = 1 0 0 ;
✡ ✠
SOLUTION 9.16 Prints all of the elements of int2d .
☛ ✟
for (i n t k = 0 ; k <int2d . length ; k++) {
for (i n t j = 0 ; j <int2d [ k ] . length ; j ++)
System . out . p r i n t ( int2d [ k ] [ j ] + ” ” ) ;
System . out . p r i n t l n ( ) ; // new l i n e
}
✡ ✠
SOLUTION 9.17 A52×7two-dimensional array of int.
☛ ✟
i n t s a l e s [ ] [ ] = new i n t [ 5 2 ] [ 7 ] ;
for (i n t k = 0 ; k <s a l e s . length ; k++)
for (i n t j = 0 ; j <s a l e s [ k ] . length ; j ++)
s a l e s [ k ] [ j ] = 0 ;
✡ ✠
SOLUTION 9.18 A method to calculate average number of newspapers per
week.
☛ ✟
double avgWeeklySales ( i n t a r r [ ] [ ] ) {
double t o t a l = 0 ;
for (i n t k = 0 ; k <a r r . length ; k++)
for (i n t j = 0 ; j <a r r [ k ] . length ; j ++)
t o t a l += a r r [ k ] [ j ] ;
return t o t a l /52;
}
✡ ✠
SOLUTION 9.19 A method to calculate average Sunday newspapers.
☛ ✟
double avgSundaySales ( i n t a r r [ ] [ ] ) {
double t o t a l = 0 ;
for (i n t k = 0 ; k <a r r . length ; k++)
t o t a l += a r r [ k ] [ 6 ] ;
return t o t a l /52;
}
✡ ✠
CHAPTER 9 •Exercises 465
SOLUTION 9.20 AcompareTo() forLetterFreq .
☛ ✟
public i n t compareTo ( Object l f ) {
L e t t e r F r e q l e t F r e q = ( L e t t e r F r e q ) l f ;
i f( f r e q<l e t F r e q . getFreq ( ) )
return −1;
else i f ( f r e q>l e t F r e q . getFreq ( ) )
return +1;
else return 0 ; // T h e f r e q u e n c i e s m u s t b e e q u a l .
}// c o m p a r e T o ( )
✡ ✠
SOLUTION 9.21 Asort() forAnalyzeFreq .
☛ ✟
public void s o r t ( ) {
java . u t i l . Arrays . s o r t ( freqArr ) ;
}// s o r t ( )
✡ ✠
SOLUTION 9.22 A new AnalyzeFreq.main() that uses sort() .
☛ ✟
public s t a t i c void main ( S t r i n g [ ] argv ) {
AnalyzeFreq af = new AnalyzeFreq ( ) ;
af . c o u n t L e t t e r s ( ”Now i s the time f o r a l l good students ” +
” to study computer −r e l a t e d t o p i c s . ” ) ;
af . s o r t ( ) ;
af . printArray ( ) ;
}// m a i n ( )
✡ ✠
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 9.1 Explain the difference between the following pairs of terms:
a. An element and an element type.
b. A subscript and an array element .
c. A one-dimensional array and two-dimensional array.
d. An array and a vector .
e. A insertion sort and a selection sort .
f. A binary search and a sequential search .
EXERCISE 9.2 Fill in the blanks.
a. The process of arranging an array’s elements into a particula r order is known
as .
b. One of the preconditions of the binary search method is that the a rray has to be
.
c. An is an object that can store a collection of elements of the same
type.
d. An is like an array except that it can grow.
e. For an array, its is represented by an instance variable.
f. An expression that can be used during array instantiation to assign values to
the array is known as an .
466 CHAPTER 9 •Arrays and Array Processing
g. A is an array of arrays.
h. A sort method that can be used to sort different types of data is k nown as a
method.
i. To instantiate an array you have to use the operator.
j. An array of objects stores to the objects.
EXERCISE 9.3 Make each of the following array declarations:
a. A4×4array of double s.
b. A20×5array of String s.
c. A3×4array of char initialized to ‘*’;
d. A2×3×2array of boolean initialized to true.
e. A3×3array of Student s.
f. A2×3array of String s initialized to “one,” “two,” and so on.
EXERCISE 9.4 Identify and correct the syntax error in each of the following
expressions:
a.int arr = new int[15];
b.int arr[] = new int(15);
c.float arr[] = new [3];
d.float arr[] = new float {1.0,2.0,3.0};
e.int arr[] = {1.1,2.2,3.3};
f.int arr[][] = new double[5][4];
g.int arr[][] = { {1.1,2.2}, {3.3, 1} };
EXERCISE 9.5 Evaluate each of the following expressions, some of which may
be erroneous:
☛ ✟
i n t a r r [ ] = {2 , 4 , 6 , 8 , 1 0 };
✡ ✠
a.arr[4]
b.arr[ arr.length ]
c.arr[ arr[0] ]
d.arr[ arr.length / 2 ]
e.arr[ arr[1] ]f.arr[ 5 % 2 ]
g.arr[ arr[ arr[0] ] ]
h.arr[ 5 / 2.0 ]
i.arr[ 1 + (int) Math.random() ]
j.arr[ arr[3] / 2 ]
EXERCISE 9.6 What would be printed by the following code segment?
☛ ✟
i n t a r r [ ] = {24 , 0 , 19 , 21 , 6 , −5, 10 , 1 6 };
for (i n t k = 0 ; k <a r r . length ; k += 2)
System . out . p r i n t l n ( a r r [ k ] ) ;
✡ ✠
EXERCISE 9.7 What would be printed by the following code segment?
☛ ✟
i n t a r r [ ] [ ] = { { 24 , 0 , 19 },{21 , 6 , −5},{10 , 16 , 3 },
{1 ,−1, 0} } ;
for (i n t j = 0 ; j <a r r . length ; j ++)
for (i n t k = 0 ; k <a r r [ j ] . length ; k++)
System . out . p r i n t l n ( a r r [ j ] [ k ] ) ;
✡ ✠
CHAPTER 9 •Exercises 467
EXERCISE 9.8 What would be printed by the following code segment?
☛ ✟
i n t a r r [ ] [ ] = { { 24 , 0 , 19 },{21 , 6 , −5},{10 , 16 , 3 },
{1 ,−1, 0} } ;
for (i n t j = 0 ; j <a r r [ 0 ] . length ; j ++)
for (i n t k = 0 ; k <a r r . length ; k++)
System . out . p r i n t l n ( a r r [ k ] [ j ] ) ;
✡ ✠
EXERCISE 9.9 What’s wrong with the following code segment, which is sup-
posed to swap the values of the int variables, n1and n2?
☛ ✟
i n t temp = n1 ;
n2 = n1 ;
n1 = temp ;
✡ ✠
EXERCISE 9.10 Explain why the following method does not successfully swap
the values of its two parameters? Hint: Think about the differe nce between value
and reference parameters.
☛ ✟
public void swapEm( i n t n1 , i n t n2 ){
i n t temp = n1 ;
n1 = n2 ;
n2 = temp ;
}
✡ ✠
EXERCISE 9.11 Declare and initialize an array to store the following two-
dimensional table of values:
☛ ✟
1 2 3 4
5 6 7 8
9 10 11 12
✡ ✠
EXERCISE 9.12 For the two-dimensional array you created in the previous ex-
ercise, write a nested for loop to print the values in the following order: 1 5 9 2 6
10 3 7 11 4 8 12. That is, print the values going down the columns ins tead of going
across the rows.
EXERCISE 9.13 Deﬁne an array that would be suitable for storing the following
values:
a. The GPAs of 2,000 students.
b. The lengths and widths of 100 rectangles.
c. A week’s worth of hourly temperature measurements, stored so th at it is easy
to calculate the average daily temperature.
d. A board for a tic-tac-toe game.
e. The names and capitals of the 50 states.
EXERCISE 9.14 Write a code segment that will compute the sum of all the ele-
ments of an array of int.
EXERCISE 9.15 Write a code segment that will compute the sum of the elements
in a two-dimensional array of int.
468 CHAPTER 9 •Arrays and Array Processing
EXERCISE 9.16 Write a method that will compute the average of all the ele-
ments of a two-dimensional array of float .
EXERCISE 9.17 Write a method that takes two parameters, an int array and an
integer, and returns the location of the last element of the array that is greater than
or equal to the second parameter.
EXERCISE 9.18 Write a program that tests whether a 3×3array, input by the
user, is a magic square . A magic square is an N×Nmatrix of numbers in which
every number from 1 to N2must appear just once, and every row, column, and
diagonal must add up to the same total—for example,
☛ ✟
6 7 2
1 5 9
8 3 4
✡ ✠
EXERCISE 9.19 Revise the program in the previous exercise so that it allows the
user to input the dimensions of the array, up to 4×4.
EXERCISE 9.20 Modify the AnalyzeFreq program so that it can display the
relative frequencies of the 10 most frequent and 10 least frequ ent letters.
EXERCISE 9.21 The merge sort algorithm takes two collections of data that have
been sorted and merges them together. Write a program that takes two 25-element
int arrays, sorts them, and then merges them, in order, into one 50-e lement array.
EXERCISE 9.22 Challenge: Design and implement a BigInteger class that
can add and subtract integers with up to 25 digits. Your class s hould also include
methods for input and output of the numbers. If you’re really ambiti ous, include
methods for multiplication and division.
EXERCISE 9.23 Challenge: Design a data structure for this problem: As man-
ager of Computer Warehouse, you want to track the dollar amount of pur chases
made by those clients that have regular accounts. The accounts a re numbered
from0, 1, ..., N . The problem is that you don’t know in advance how many
purchases each account will have. Some may have one or two purchase s. Others
may have 50 purchases.
EXERCISE 9.24 Ananagram is a word made by rearranging the letters of another
word. For example, actis an anagram of cat, and aegllry is an anagram of allergy .
Write a Java program that accepts two words as input and determi nes if they are
anagrams.
EXERCISE 9.25 Challenge: Ananagram dictionary is a dictionary that organizes
words together with their anagrams. Write a program that lets th e user enter up
to 100 words (in a TextField , say). After each word is entered, the program
should display (in a TextArea perhaps) the complete anagram dictionary for
the words entered. Use the following sample format for the dictiona ry. Here the
words entered by the user were: felt, left, cat, act, opt, pot, top.
☛ ✟
a c t : a c t c a t
e f l t : f e l t l e f t
opt : opt pot top
✡ ✠
CHAPTER 9 •Exercises 469
EXERCISE 9.26 Acme Trucking Company has hired you to write software to
help dispatch its trucks. One important element of this softwar e is knowing
the distance between any two cities that it services. Design and implement a
Distance class that stores the distances between cities in a two-dimens ional ar-
ray. This class will need some way to map a city name, Boise , into an integer that
can be used as an array subscript. The class should also contain methods that
would make it useful for looking up the distance between two citie s. Another
useful method would tell the user the closest city to a given city .
EXERCISE 9.27 Rewrite the main() method for the WordGuess example so
that it allows the user to input the number of players and whethe r each players is
a computer or a human. Use a KeyboardReader .
EXERCISE 9.28 Write a smarter version of the WordGuesser class that
“knows” which letters of the English language are most frequent . HINT: Rather
than using random guesses, store the player’s guesses in a strin g in order of
decreasing frequency: ”ETAONRISHLGCMFBDGPUKJVWQXYZ”.
EXERCISE 9.29 Write a CLUI version of the SlidingTilePuzzle . You will
need to make modiﬁcations to the SlidingTilePuzzle class.
470 CHAPTER 9 •Arrays and Array Processing
OBJECTIVES
After studying this chapter, you will
•Understand Java’s exception-handling mechanisms.
•Be able to use the Java try/catch statement.
•Know how to design effective exception handlers.
•Appreciate the importance of exception handling in program design.
•Be able to design your own Exception subclasses.
OUTLINE
10.1 Introduction
10.2 Handling Exceptional Conditions
10.3 Java’s Exception Hierarchy
10.4 Handling Exceptions Within a Program
10.5 Error Handling and Robust Program Design
10.6 Creating and Throwing Your Own Exceptions
10.7 From the Java Library: javax.swing.JOptionPane
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 10
Exceptions: When Things
Go Wrong
471
472 CHAPTER 10 •Exceptions: When Things Go Wrong
10.1 Introduction
Mistakes happen. Making mistakes is the norm rather than the exception.
This is not to say that we make mistakes more often than we get i t right.
It is to say that (almost) nothing we do or build is ever perfect ly correct,
least of all computer software. No matter how well-designed a program
is, there is always the chance that some kind of error will ari se during its
execution.
Anexception is an erroneous or anomalous condition that arises while Exception
a program is running. Examples of such conditions that we hav e dis-
cussed in this text include attempting to divide by 0 (arithm etic excep-
tion), reading a decimal value when an integer is expected (n umber format
exception), attempting to write to a ﬁle that doesn’t exist ( I/O exception),
or referring to a nonexistent character in a string (index ou t of bounds
exception). The list of potential errors and anomalies is en dless.
A well-designed program should include code to guard agains t errors
and other exceptional conditions when they arise. This code should be in-
corporated into the program from the very ﬁrst stages of its d evelopment.
That way it can help identify problems during development. In Java, the
preferred way of handling such conditions is to use exception handling ,
a divide-and-conquer approach that separates a program’s n ormal code Exception handling
from its error-handling code.
This chapter describes Java’s exception handling features . We begin by
contrasting the traditional way of handling errors within a program with
Java’s default exception-handling mechanism. We show how e xceptions
are raised (thrown) and handled (caught) within a program an d iden-
tify the rules that apply to different kinds of exceptions. W e then focus
on some of the key design issues that govern when, where, and h ow to
use exceptions in your programs. Finally, we show how to desi gn and
implement one’s own Exception subclass.
10.2 Handling Exceptional Conditions
To introduce you to handling exceptional conditions, Figur e 10.1 shows
a method that computes the average of the ﬁrst Nintegers, an admit-
☛ ✟
/∗∗
∗P r e c o n d i t i o n : N >0
∗P o s t c o n d i t i o n : a v g F i r s t N ( ) = ( 1 + 2 + . . . + N ) / N
∗/
public double avgFirstN ( i n t N){
i n t sum = 0 ;
for (i n t k = 1 ; k <= N; k++)
sum += k ;
return sum/N; // W h a t i f N i s 0 ?
}// a v g F i r s t N ( )
✡ ✠
Figure 10.1: Poor design. No attempt is made to guard against a divide-
by-zero error.
SECTION 10.2 •Handling Exceptional Conditions 473
☛ ✟
/∗∗
∗P r e c o n d i t i o n : N >0
∗P o s t c o n d i t i o n : a v g F i r s t N ( ) e q u a l s ( 1 + 2 + . . . + N ) d i v i d e d b y N
∗/
public double avgFirstN ( i n t N){
i n t sum = 0 ;
i f(N<= 0){
System . out . p r i n t l n (
”ERROR avgFirstN : N <= 0 . Program terminating . ” ) ;
System . e x i t ( 0 ) ;
}
for (i n t k = 1 ; k <= N; k++)
sum += k ;
return sum/N; // W h a t i f N i s 0 ?
}// a v g F i r s t N ( )
✡ ✠
Figure 10.2: One way to handle a divide-by-zero error might b e to ter-
minate the program, if there is an attempt to divide by 0, assu ming it’s
the kind of program that can be safely aborted. This version d oes not use
exception handling.
tedly contrived example. We use it mainly to illustrate the b asic con-
cepts involved in exception handling. As its precondition s uggests, the
avgFirstN() method expects that Nwill be greater than 0. If Nhappens
to be 0, an error will occur in the expression sum/N , because you cannot
divide an integer by 0.
10.2.1 Traditional Error Handling
Obviously, the method in Figure 10.1 should not simply ignor e the possi-
bility that Nmight be 0. Figure 10.2 shows a revised version of the method, Divide-by-zero error
which includes code that takes action if the method’s precon dition fails.
Because there is no way to compute an average of 0 elements, th e revised
method decides to abort the program. Aborting the program ap pears to
be a better alternative than returning 0 or some other defaul t value (like
−1) as the method’s result and thereby allowing an erroneous va lue to
spread throughout the program. That would just compound the e rror.
JAVA EFFECTIVE DESIGN Unﬁxable Error. If an unﬁxable error is
detected, it is far better to terminate the program abnormal ly than to
allow the error to propagate throughout the program.
The revised avgFirstN() method takes the traditional approach to er-
ror handling: Error-handling code is built right into the al gorithm. If N
happens to be 0 when avgFirstN() is called, the following output will
be generated:
☛ ✟
ERROR avgFirstN : N <= 0 . Program terminating .
✡ ✠
474 CHAPTER 10 •Exceptions: When Things Go Wrong
☛ ✟
public c l a s s CalcAverage {
public double avgFirstN ( i n t N){
i n t sum = 0 ;
for (i n t k = 1 ; k <= N; k++)
sum += k ;
return sum/N; // W h a t i f N i s 0 ?
}// a v g F i r s t N ( )
}// C a l c A v e r a g e
public c l a s s CalcAvgTest {
public s t a t i c void main ( S t r i n g args [ ] ) {
CalcAverage ca = new CalcAverage ( ) ;
System . out . p r i n t l n ( ”AVG + ” + ca . avgFirstN ( 0 ) ) ;
}// m a i n
}// C a l c A v g T e s t
✡ ✠
Figure 10.3: Note that there are two public classes deﬁned in this ﬁgure,
which would be saved in separate Java ﬁles.
10.2.2 Java’s Default Exception Handling
To help detect and handle common runtime errors, Java’s crea tors incor-
porated an exception-handling model into the language itse lf. In the case
of our divide-by-zero error, the Java Virtual Machine (JVM) would detect
the error and abort the program. To see this, consider the pro gram in Fig-
ure 10.3. Note that the avgFirstN() method is passed an argument of
0 in the CalcAvgTest.main() . When the JVM detects the error, it will
abort the program and print the following message:
☛ ✟
Exception in thread ”main”
java . lang . ArithmeticException : / by zero
at CalcAverage . avgFirstN ( Compiled Code )
at CalcAvgTest . main ( CalcAvgTest . java : 5 )
✡ ✠
The error message describes the error and provides a trace of the method
calls, from last to ﬁrst, that led to the error. This trace sho ws that the error
occurred in the CalcAverage.avgFirstN() method, which was called
by theCalcAvgTest.main() method.
As this example suggests, Java’s default exception handlin g is able to
detect and handle certain kinds of errors and exceptional co nditions. In
the next section, we will identify what kinds of conditions a re handled by
the JVM.
10.3 Java’s Exception Hierarchy
The Java class library contains a number of predeﬁned except ions, some
of which are shown in Figure 10.4. The most general type of exc eption,
java.lang.Exception , is located in the java.lang package, but most
of its subclasses are contained in other packages. Some of th e various
SECTION 10.3 •Java’s Exception Hierarchy 475
Object
Throwable
Exception
RuntimeExceptionIndexOutOfBoundsException
SecurityExceptionArrayIndexOutOfBoundsException
StringIndexOutOfBoundsException
NullPointerExceptionNegativeArrayExceptionIllegalMonitorExceptionClassCastExceptionArrayStoreExceptionArithmeticExceptionjava.lang
NumberFormatException IllegalArgumentExceptionFigure 10.4: Part of Java’s excep-
tion hierarchy. All subclasses of
RuntimeException are known
asunchecked exceptions. Java pro-
grams are not required to catch
these exceptions.
IOException classes are contained in the java.io package, while oth-
ers are contained in the java.net package. In general, exception classes Exception hierarchy
are placed in the package that contains the methods that thro w those
exceptions.
Each of the classes in Figure 10.4 identiﬁes a particular typ e of
exception, and each is a subclass of the Exception class. Ob-
viously a subclass deﬁnes a more speciﬁc exception than its s u-
perclass. Thus, both ArrayIndexOutOfBoundsException and
StringIndexOutOfBoundsException are more speciﬁc than Index-
OutOfBoundsException .
TABLE 10.1 Some of Java’s important exceptions.
Class Description
ArithmeticException Division by zero or some other kind of arithmetic problem
ArrayIndexOutOfBoundsException An array index is less than zero or greater
than or equal to the array’s length
FileNotFoundException Reference to a ﬁle that cannot be found
IllegalArgumentException Calling a method with an improper argument
IndexOutOfBoundsException An array or string index is out of bounds
NullPointerException Reference to an object that has not been instantiated
NumberFormatException Use of an illegal number format, such as when calling a method
StringIndexOutOfBoundsException AString index is less than zero or greater than
or equal to the String ’s length
Table 10.1 gives a brief summary of some of the most important excep-
tions. You’ve undoubtedly encountered some of these except ions, because
they are thrown by methods we have used repeatedly in program ming
examples. Table 10.2 summarizes the exceptions raised by so me of the
methods we’ve used most frequently.
476 CHAPTER 10 •Exceptions: When Things Go Wrong
TABLE 10.2 Some of Java’s important exceptions by method.
Class Method Exception Raised Description
Double valueOf(String) NumberFormatException TheString is not a double
Integer parseInt(String) NumberFormatException TheString is not a int
String String(String) NullPointerException TheString isnull
indexOf(String) NullPointerException TheString isnull
lastIndexOf(String) NullPointerException TheString isnull
charAt(int) StringIndexOutOfBoundsException Theint is not a valid index
substring(int) StringIndexOutOfBoundsException Theint is not a valid index
substring(int,int) StringIndexOutOfBoundsException Anint is not a valid index
SELF-STUDY EXERCISE
EXERCISE 10.1 What type of exception would be thrown for the fol-
lowing statements?
a.Integer.parseInt("26.2");
b.String s; s.indexOf(’a’);
c.String s = "hello"; s.charAt(5);
10.3.1 Checked and Unchecked Exceptions
Java’s exception hierarchy is divided into two types of exce ptions. A
checked exception is one that can be analyzed by the Java compiler. Checked exceptions
Checked exceptions are thrown by methods such as the Buffered-
Reader.readLine() method, in which there is a substantial likelihood
that something might go wrong. When the compiler encounters o ne
of these method calls, it checks whether the program either h andles or
declares the exception. Compile-time checking for these ex ceptions is
designed to reduce the number of exceptions that are not prop erly han-
dled within a program. This improves the security of Java pro grams.
JAVA LANGUAGE RULE Checked Exceptions. A checked
exception, such as an IOException , must either be handled or
declared within the program.
Thethrows Clause
TheIOException , which we encountered in Chapter 4 , is a checked
exception. The Java compiler knows that readLine() is a method that
can throw an IOException . A method that contains an expression that
might throw a checked exception must either handle the excep tion or de-
clare it. Otherwise, the compiler would generate a syntax er ror. The sim-
plest way to avoid such a syntax error is to declare the exception , in our case Declaring an exception
that means qualifying the method header with the expression throws
IOException .
In general, any method that contains an expression that might throw a
checked expression must declare the exception. However, bec ause one
method can call another method, declaring exceptions can ge t a little
SECTION 10.3 •Java’s Exception Hierarchy 477
tricky. If a method calls another method that contains an expr ession that
might throw an unchecked exception, then both methods must h ave a
throws clause. For example, consider the following program:
☛ ✟
import java . io . ∗;
public c l a s s Example {
BufferedReader input = new BufferedReader
(new InputStreamReader ( System . in ) ) ;
public void doRead ( ) throws IOException {
// May t h r o w I O E x c e p t i o n
S t r i n g i n p u t S t r i n g = input . readLine ( ) ;
}
public s t a t i c void main ( S t r i n g argv [ ] )
throws IOException {
Example ex = new Example ( ) ;
ex . doRead ( ) ;
}
}
✡ ✠
In this case, the doRead() method contains a readLine() expres-
sion, which might throw an IOException . Therefore, the doRead()
method must declare that it throws IOException . However, because
doRead() is called by main() , themain() method must also declare the
IOException .
JAVA LANGUAGE RULE Where to Use throws .Unless a checked
exception, such as an IOException , is caught and handled by a
method, it must be declared with a throws clause within the method
and within any method that calls that method.
The alternative approach would be to catch theIOException within
the body of the method. We will discuss this approach in the ne xt section.
Unchecked Exceptions
Anunchecked exception is any exception belonging to a subclass of
RuntimeException (Fig. 10.4). Unchecked exceptions are not checked
by the compiler. The possibility that some statement or expr ession will
lead to an ArithmeticException orNullPointerException is ex-
tremely difﬁcult to detect at compile time. The designers of Java decided
that forcing programmers to declare such exceptions would n ot signiﬁ-
cantly improve the correctness of Java programs.
Therefore, unchecked exceptions do not have to be handled wi thin
a program. And they do not have to be declared in a throws clause. Runtime (unchecked) exceptions
As shown in the chapter’s early divide-by-zero exception ex ample,
unchecked exceptions are handled by Java’s default excepti on handlers,
unless your program takes speciﬁc steps to handle them direc tly. In many
478 CHAPTER 10 •Exceptions: When Things Go Wrong
cases leaving the handling of such exceptions up to Java may b e the best
course of action, as we will see Section 10.5.
JAVA LANGUAGE RULE Unchecked Exceptions. An unchecked
exception—one belonging to some subclass of
RunTimeException —does not have to be caught within your
program.
10.3.2 The Exception Class
Thejava.lang.Exception class itself is very simple, consisting of
just two constructor methods (Fig. 10.5). The Throwable class, from
which Exception is derived, is the root class of Java’s exception and
error hierarchy. It contains deﬁnitions for the getMessage() and
printStackTrace() methods, which are two methods that we will use
frequently in our error-handling routines.
SELF-STUDY EXERCISE+getMessage()
+printStackTrace()Throwable
+Exception()
+Exception(in message : String)Exception
FIGURE 10.5 The
java.lang.Exception class.EXERCISE 10.2 Which of the following are examples of unchecked
exceptions?
a. IOException
b. IndexOutOfBoundsException
c. NullPointerException
d. ClassNotFoundException
e. NumberFormatException
10.4 Handling Exceptions Within a Program
This section will describe how to handle exceptions within t he program
rather than leaving them to be handled by the JVM.
10.4.1 Trying, Throwing, and Catching an Exception
In Java, errors and other abnormal conditions are handled by t hrowing
and catching exceptions. When an error or an exceptional cond ition is Pulling the program’s ﬁre alarm
detected, you can throw an exception as a way of signaling the abnormal
condition. This is like pulling the ﬁre alarm. When an excepti on is thrown,
an exception handler will catch the exception and deal with i t (Fig. 10.6).
We will discuss try blocks, which typically are associated w ith catching
ObjectException
Object«uses»
throws«uses»
catchesThrower Catcher
FIGURE 10.6 Exception handling.
When an exception occurs, an object
will throw an Exception . The
exception handler, possibly the same
object, will catch it.exceptions, later in the section.
If we go back to our avgFirstN() example, the typical way of
handling this error in Java would be to throw an exception in t he
avgFirstN() method and catch it in the calling method. Of course, the
calling method could be in the same object or it could belong to some
other object. In the latter case, the detection of the error is s eparated from
its handling. This division of labor opens up a wide range of p ossibilities.
For example, a program could dedicate a single object to serve as the han-
dler for all its exceptions. The object would be sort of like th e program’s
ﬁre department.
SECTION 10.4 •Handling Exceptions Within a Program 479
☛ ✟
public c l a s s CalcAverage {
/∗∗
∗P r e c o n d i t i o n : N >0
∗P o s t c o n d i t i o n : a v g F i r s t N ( ) e q u a l s t h e a v e r a g e o f ( 1 + 2 + . . . + N )
∗/
public double avgFirstN ( i n t N){
i n t sum = 0 ;
i f(N<= 0)
throw new IllegalArgumentException ( ”ERROR: I l l e g a l argument” ) ;
for (i n t k = 1 ; k <= N; k++)
sum += k ;
return sum/N; // W h a t i f N i s 0 ?
}// a v g F i r s t N ( )
}// C a l c A v e r a g e
public c l a s s CalcAvgTest {
public s t a t i c void main ( S t r i n g args [ ] ) {
t r y{
CalcAverage ca = new CalcAverage ( ) ;
System . out . p r i n t l n ( ”AVG + ” + ca . avgFirstN ( 0 ) ) ;
}
catch ( IllegalArgumentException e ) {// E x c e p t i o n H a n d l e r
System . out . p r i n t l n ( e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 0 ) ;
}
}// m a i n
}// C a l c A v g T e s t
✡ ✠
Figure 10.7: In this version of the calcAvgTest program, an Illegal-
ArgumentException thrown in CalcAverage.avgFirstN() , would
be handled by the catch clause in CalcAvgTest.main() .
To illustrate Java’s try/throw/catch mechanism, let’s revisit the
CalcAvgTest program. The version shown in Figure 10.7 mimics
the way Java’s default exception handler works. If the avgFirstN()
method is called with an argument that is zero or negative, an
IllegalArgumentException is thrown. The exception is caught by
thecatch clause in the CalcAvgTest.main() method.
Let’s go through this example step by step. The ﬁrst thing to n otice is
that if the CalcAverage.avgFirstN() method has a zero or negative
argument, it will throw an exception:
☛ ✟
i f(N<= 0)
throw new IllegalArgumentException ( ”ERROR: I l l e g a l argument” ) ;
✡ ✠
Note the syntax of the throw statement. It creates a new Illegal-
ArgumentException object and passes it a message that describes the
error. This message becomes part of the exception object. It ca n be re-
trieved using the getMessage() method, which is inherited from the
Throwable class (Fig. 10.4).
480 CHAPTER 10 •Exceptions: When Things Go Wrong
When a throw statement is executed, the JVM interrupts the normal ex-
ecution of the program and searches for an exception handler . We will de-
scribe the details of this search shortly. In this case, the ex ception handler
is thecatch clause contained in the CalcAvgTest.main() method:
☛ ✟
catch ( IllegalArgumentException e ) {// E x c e p t i o n H a n d l e r
System . out . p r i n t l n ( e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 0 ) ;
}
✡ ✠
When an IllegalArgumentException is thrown, the statements
within this catch clause are executed. The ﬁrst statement uses the
getMessage() method to print a copy of the error message. The sec-
ond statement uses the printStackTrace() method, which is deﬁned
inThrowable and inherited by all Exception s, to print a trace of the
method calls leading up to the exception. The last statement causes the
program to terminate.
When we run this program, the following output will be generat ed as
a result of the illegal argument error:
☛ ✟
ERROR: Can ’ t average 0 elements
java . lang . IllegalArgumentException : ERROR: I l l e g a l arg ument
at java . lang . Throwable . f i l l I n S t a c k T r a c e ( Native Method )
at java . lang . Throwable. <i n i t>(Throwable . java : 9 4 )
at java . lang . Exception . <i n i t>(Exception . java : 4 2 )
at java . lang . RuntimeException. <i n i t>
( RuntimeException . java : 4 7 )
at java . lang . IllegalArgumentException . <i n i t>
( IllegalArgumentException . java : 4 3 )
at CalcAverage . avgFirstN ( Compiled Code )
at CalcAvgTest . main ( CalcAvgTest . java : 5 )
✡ ✠
Thus, as in the previous example of Java’s default exception handler, our
exception handler also prints out a description of the error and a trace of
the method calls that led up to the error. However, in this exam ple, we are
directly handling the exception rather than leaving it up to Java’s default
exception handler. Of course, this example is intended main ly for illus-
trative purposes. It would make little sense to write our own e xception
handler if it does nothing more than mimic Java’s default han dler.
JAVA EFFECTIVE DESIGN Using an Exception. Unless your
program’s handling of an exception is signiﬁcantly differe nt from
Java’s default handling of it, the program should just rely on the
default.
Finally, note that the catch clause is associated with a try block. The
handling of exceptions in Java takes place in two parts: Firs t, we tryto
SECTION 10.4 •Handling Exceptions Within a Program 481
execute some statements, which may or may not lead to an excep tion.
These are the statements contained within the try clause:
☛ ✟
t r y{
CalcAverage ca = new CalcAverage ( ) ;
System . out . p r i n t l n ( ”AVG + ” + ca . avgFirstN ( 0 ) ) ;
}
✡ ✠
Second, we provide one or more catch clauses to handle par-
ticular types of exceptions. In this case, we are only handlin g
IllegalArgumentException s.
As we said earlier, throwing an exception is like pulling a ﬁr e alarm.
The throw occurs somewhere within the scope of the try block. The “ﬁre
department” in this case is the code contained in the catch clause that
immediately follows the try block. This is the exception han dler for this Responding to the ﬁre alarm
particular exception. There’s something like a game of catc h going on
here: Some method within the try block throws an Exception object,
which is caught and handled by the catch block located in some other
object (Fig. 10.8).
+avgFirstN(in N : int) : doubleCalcAverageException
+main()CalcAvgTest«uses»
throws«uses»
catchesIllegalArgumentExceptionFigure 10.8: Playing catch: In
this design, the Illegal-
ArgumentException is thrown
by the CalcAverage.avg-
FirstN() method and caught
by the catch clause within
CalcAvgTest.main() method.
10.4.2 Separating Error Checking from Error Handling
As we see in the CalcAvgTest example, an important difference be-
tween Java’s exception handling and more traditional appro aches is that Divide and conquer
error handling can be separated from the normal ﬂow of executi on within
a program. The CalcAverage.avgFirstN() method still checks for
the error and it still throws IllegalArgumentException ifNdoes
not satisfy the method’s precondition. But it does not conta in code for
handling the exception. The exception-handling code is loc ated in the
CalcAvgTest class.
Thus, the CalcAvgTest program creates a clear separation between
the normal algorithm and the exception-handling code. One a dvantage of
this design is that the normal algorithm is uncluttered by er ror-handling
code and, therefore, easier to read.
Another advantage is that the program’s response to errors h as been
organized into one central location. By locating the except ion handler
inCalcAvgTest.main() , one exception handler can be used to han-
dle other errors of that type. For example, this catch clause could handle
allIllegalArgumentException s that get thrown in the program. Its
use of printStackTrace() will identify exactly where the exception
482 CHAPTER 10 •Exceptions: When Things Go Wrong
occurred. In fact, because a Java application starts in the main() method,
encapsulating all of a program’s executable statements wit hin a single try
block in the main() method will effectively handle all the exceptions that
occur within a program.
JAVA EFFECTIVE DESIGN Normal Versus Exceptional Code. A key
element of Java’s exception-handling mechanism is that the exception
handler—the catch block—is distinct from the code that throws the
exception—the try block. The try block contains the normal al gorithm.
The catch block contains code for handling exceptional cond itions.
10.4.3 Syntax and Semantics of Try/Throw/Catch
Atry block begins with the keyword try followed by a block of code The try block
enclosed within curly braces. A catch clause orcatch block consists of the
keyword catch , followed by a parameter declaration that identiﬁes the
type of Exception being caught, followed by a collection of statements
enclosed within curly braces. These are the statements that handle the The catch block
exception by taking appropriate action.
Once an exception is thrown, control is transferred out of th e try block
to an appropriate catch block. Control does not return to the try block.
JAVA LANGUAGE RULE Try Block Control. If an exception is
thrown, the try block is exited and control does not return to it.
The complete syntax of the try/catch statement is summarized in Fig-
ure 10.9. The try block is meant to include a statement or stat ements that
☛ ✟
t r y{
// B l o c k o f s t a t e m e n t s
// A t l e a s t o n e o f w h i c h may t h r o w a n e x c e p t i o n
i f(/∗S o m e c o n d i t i o n o b t a i n s ∗/)
throw new ExceptionName ( ) ;
}catch ( ExceptionName ParameterName ) {
// B l o c k o f s t a t e m e n t s t o b e e x e c u t e d
// I f t h e E x c e p t i o n N a m e e x c e p t i o n i s t h r o w n i n t r y
}catch ( ExceptionName2 ParameterName ) {
// B l o c k o f s t a t e m e n t s t o b e e x e c u t e d
// I f t h e E x c e p t i o n N a m e 2 e x c e p t i o n i s t h r o w n i n t r y
. . . // P o s s i b l y o t h e r c a t c h c l a u s e s
}f i n a l l y {
// O p t i o n a l b l o c k o f s t a t e m e n t s t h a t i s e x e c u t e d
// W h e t h e r a n e x c e p t i o n i s t h r o w n o r n o t
}
✡ ✠
Figure 10.9: Java’s try/catch statement.
might throw an exception. The catch blocks—there can be one or more—
are meant to handle exceptions that are thrown in the try bloc k. A catch
SECTION 10.4 •Handling Exceptions Within a Program 483
block will handle any exception that matches its parameter c lass, includ-
ing subclasses of that class. The ﬁnally block clause is an optional clause
that is always executed, whether an exception is thrown or no t.
The statements in the try block are part of the program’s norm al ﬂow
of execution. By encapsulating a group of statements within a try block, Normal ﬂow of execution
you thereby indicate that one or more exceptions may be throw n by those
statements, and that you intend to catch them. In effect, you a retrying a
block of code with the possibility that something might go wr ong.
If an exception is thrown within a try block, Java exits the blo ck and
transfers control to the ﬁrst catch block that matches the particular kind Exceptional ﬂow of execution
of exception that was thrown. Exceptions are thrown by using thethrow
statement, which takes the following general form:
☛ ✟
throw new ExceptionClassName ( OptionalMessageString ) ;
✡ ✠
The keyword throw is followed by the instantiation of an object of the
ExceptionClassName class. This is done the same way we instanti-
ate any object in Java: by using the new operator and invoking one of
the exception’s constructor methods. Some of the construct ors take an
OptionalMessageString , which is the message that gets returned by
the exception’s getMessage() method.
Acatch block has the following general form:
☛ ✟
catch ( ExceptionClassName ParameterName ) {
// E x c e p t i o n h a n d l i n g s t a t e m e n t s
}
✡ ✠
Acatch block is very much like a method deﬁnition. It contains a param -
eter, which speciﬁes the class of exception that is handled b y that block.
The ParameterName can be any valid identiﬁer, but it is customary to use
eas thecatch block parameter. The parameter’s scope is limited to the
catch block, and it is used to refer to the caught exception.
The ExceptionClassName must be one of the classes in Java’s exception Exceptions are objects
hierarchy (see Fig. 10.4). A thrown exception will match any parameter of
its own class or any of its superclasses. Thus, if an ArithmeticExcep-
tion is thrown, it will match both an ArithmeticException parame-
ter and an Exception parameter, because ArithmeticException is a
subclass of Exception .
Note that there can be multiple catch clauses associated with a given
try block, and the order with which they are arranged is importan t. A
thrown exception will be caught by the ﬁrst catch clause it matches.
Therefore, catch clauses should be arranged in order from most speciﬁc Arranging catch clauses
to most general (See the exception hierarchy in Figure 10.4) . If a more
general catch clause precedes a more speciﬁc one, it will pre vent the more
speciﬁc one from executing. In effect, the more speciﬁc claus e will be hid-
den by the more general one. You might as well just not have the m ore
speciﬁc clause at all.
484 CHAPTER 10 •Exceptions: When Things Go Wrong
To illustrate how to arrange catch clauses, suppose an Arithmetic-
Exception is thrown in the following try/catch statement:
☛ ✟
t r y{
// S u p p o s e a n A r i t h m e t i c E x c e p t i o n i s t h r o w n h e r e
}catch ( ArithmeticException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 1 ) ;
}catch ( Exception e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
✡ ✠
In this case, the exception would be handled by the more speciﬁ c
ArithmeticException block. On the other hand, if some other kind
of exception is raised, it will be caught by the second catch c lause. The Which handler to use?
Exception class will match any exception that is thrown. Therefore, it
should always occur last in a sequence of catch clauses.
JAVA PROGRAMMING TIP Arranging Catch Clauses. Catch
clauses should be arranged from most speciﬁc to most general . The
Exception clause should always be the last in the sequence.
10.4.4 Restrictions on the try/catch/finally
Statement
There are several important restrictions that apply to Java ’s exception-
handling mechanism. We’ll describe these in more detail lat er in this
chapter.
•A try block must be immediately followed by one or more catch c lauses
and a catch clause may only follow a try block.
•Athrow statement is used to throw both checked exceptions and
unchecked exceptions, where unchecked exceptions are thos e belong-
ing to RuntimeException or its subclasses. Unchecked exceptions
need not be caught by the program.
•Athrow statement must be contained within the dynamic scope of
a try block, and the type of Exception thrown must match at least
one of the try block’s catch clauses. Or the throw statement must be
contained within a method or constructor that has a throws clause for
the type of thrown Exception .
JAVA LANGUAGE RULE Try/Catch Syntax. A try block must be
followed immediately—with no intervening code—by one or more
catch blocks. A catch block can only be preceded by a try block or by
another catch block. You may not place intervening code betw een
catch blocks.
SECTION 10.4 •Handling Exceptions Within a Program 485
10.4.5 Dynamic Versus Static Scoping
How does Java know that it should execute the catch clause in
CalcAvgTest.main() when an exception is thrown in avgFirstN() ?
Also, doesn’t the latest version of avgFirstN() (Fig. 10.7) violate the
restriction that a throw statement must occur within a try block?
An exception can only be thrown within a dynamically enclosing try
block. This means that the throw statement must fall within the dynamic
scope of an enclosing try block. Let’s see what this means. Dynamic scope
Dynamic scoping refers to the way a program is executed. For e x-
ample, in CalcAverage (Fig. 10.7), the avgFirstN() method is called
from within the try block located in CalcAvgTest.main() . Thus, it falls
within the dynamic scope of that try block.
Contrast dynamic with what you have learned about static scope ,
which we’ve used previously to deﬁne the scope of parameters and lo- Static scope
cal variables (Fig. 10.10). Static scoping refers to the way a program is
written. A statement or variable occurs within the scope of a block if its
text is actually written within that block. For example, con sider the def-
inition of MyClass (Fig. 10.11). The variable Xoccurs within the (static)
scope of method1() , and the variable Yoccurs within the (static) scope
ofmethod2() .
method1 () method2 ()
method2()main()X Ymain ()class MyClass{

	 public void method1 () {
 		 int X =1;
 		 System.out.println("Hello" + X);
	 }

	 public void method2 () {
		 int Y =2;
		 System.out.println("Hello" + Y);
	 }

	 public static void main(String argv[]) {
 		 MyClass myclass =new MyClass();
 		 if(Math.random() >0.5)
  			 myclass.method2 () ;
 		 else
  			 myclass.method1 () ;
	 }

}Dynamic Scope: Follow the execution.
If Math.random() >0.5, method2()
is in the dynamic scope of main().Static Scope: Follow the definitions.
Neither method1() nor method2() is
in the static scope of main().
MyClassFigure 10.10: Dynamic versus
static scoping. Static scoping
refers to how the program is writ-
ten. Look at its deﬁnitions. Dy-
namic scoping refers to how the
program executes. Look at what
it actually does.
A method’s parameters and local variables occur within its s tatic scope.
Also, in the MyClass deﬁnition, the System.out.println() state-
ments occur within the static scope of method1() andmethod2() , re-
spectively. In general, static scoping refers to where a vari able is de-
clared or where a statement is located. Static scoping can be completely
determined by just reading the program.
Dynamic scoping can only be determined by running the progra m. For
example, in MyClass the order in which its statements are executed de-
pends on the result of Math.random() . Suppose that when random()
is executed it returns the value 0.99. In that case, main() will call
method2() , which will call System.out.println() , which will print
486 CHAPTER 10 •Exceptions: When Things Go Wrong
☛ ✟
public c l a s s MyClass {
public void method1 ( ) {
i n t X = 1 ;
System . out . p r i n t l n ( ” Hello ” + X ) ;
}
public void method2 ( ) {
i n t Y = 2 ;
System . out . p r i n t l n ( ” Hello ” + Y ) ;
}
public s t a t i c void main ( S t r i n g argv [ ] ) {
MyClass myclass = new MyClass ( ) ;
i f( Math . random ( ) >0 . 5 )
myclass . method2 ( ) ;
else
myclass . method1 ( ) ;
}
}// M y C l a s s
✡ ✠
Figure 10.11: An example of dynamic versus static scoping.
“Hello2.” In that case, the statement System.out.println("Hello"
+ Y) has the following dynamic scope:
☛ ✟
main ( )
method2 ( )
System . out . p r i n t l n ( ” Hello ” + Y ) ;
✡ ✠
It occurs within the (dynamic) scope of method2() , which is within the
(dynamic) scope of main() . On the other hand, if the result of random()
had been 0.10, that particular println() statement wouldn’t have been
executed at all. Thus, to determine the dynamic scope of a par ticular
statement, you must trace the program’s execution. In fact, t his is what
theprintStackTrace() method does. It prints a trace of a statement’s
dynamic scope.
10.4.6 Exception Propagation: Searching for a Catch Block
When an exception is thrown, Java uses both static and dynamic scop-
ing to ﬁnd a catch clause to handle it. Java knows how the progr am is
deﬁned—after all, it compiled it. Thus, the static scope of a p rogram’s
methods is determined by the compiler. Java also places a rec ord of every
method call the program makes on a method call stack. A method call
stack is a data structure that behaves like a stack of dishes in the c afeteria. Method call stack
For each method call, a method call block is placed on top of the stack (like
a dish), and when a particular method call returns, its block is removed
from the top of the stack (Fig. 10.12).
An important feature of the method call stack is that the curr ent ex-
ecuting method is always represented by the top block on the m ethod
call stack. If an exception happens during that method call, y ou can trace
backward through the method calls, if necessary, to ﬁnd an ex ception han-
SECTION 10.4 •Handling Exceptions Within a Program 487
public class Propagate{
 	 public void method1 (int n) {
  		 method2(n);
 	 }
 	 public void method2 (int n) {
  		 method3(n);
 	 }
 	 public void method3 (int n) {
  		 for(int k =0; k<5; k+ + ) {	//Block1
   		 if(k % 2 = = 0) {	 //Block2
    			 System.out.println(k/n) ;
   		 }
  		 }
 	 }
 	 public static void main(String args[]) {
  		 Propagate p =new propagate() ;
  		 p.method1(0) ;
 	 }
}The state of the stack on
the first iteration of the
for loop in method3().Method Call Stack
method3 ()
n=0 k=0
method2 ()
n=0
method1 ()
n=0
main()Figure 10.12: The method call
stack for the Propagate pro-
gram. The curved arrows give a
trace of the method calls leading
to the program’s present state.
dler for that exception. In Figure 10.12, you can visualize th is back trace
as a matter of reversing the direction of the curved arrows.
In order to ﬁnd a matching catch block for an exception, Java us es
its knowledge of the program’s static and dynamic scope to pe rform a
method stack trace . The basic idea is that Java traces backward through Method stack trace
the program until it ﬁnds an appropriate catch clause. The tr ace begins
within the block that threw the exception. Of course, one blo ck can be
nested (statically) within another block. If the exception i s not caught by
the block in which it is thrown, Java searches the enclosing b lock. This is
static scoping. If it is not caught within the enclosing block , Java searches
the next higher enclosing block, and so on. This is still stat ic scoping.
If the exception is not caught at all within the method in which it was
thrown, Java uses the method call stack (Fig. 10.12) to searc h backward
through the method calls that were made leading up to the exce ption.
This is dynamic scoping. In the case of our CalcAvgTest() example
(Fig. 10.7), Java would search backward to the CalcAvgTest.main()
method, which is where avgFirstN() was called, and it would ﬁnd
thecatch clause there for handling IllegalArgumentException s. It
would, therefore, execute that catch clause.
SELF-STUDY EXERCISES
EXERCISE 10.3 Suppose a program throws an ArrayIndexOutOf-
BoundsException . Using the exception hierarchy in Figure 10.4, de-
termine which of the following catch clauses could handle th at exception.
a.catch (RunTimeException e)
b.catch (StringIndexOutOfBoundsException e)
c.catch (IndexOutOfBoundsException e)
d.catch (Exception e)
e.catch (ArrayStoreException e)
488 CHAPTER 10 •Exceptions: When Things Go Wrong
EXERCISE 10.4 In the program that follows suppose that the ﬁrst time
random() is called it returns 0.98, and the second time it is called it
returns 0.44. What output would be printed by the program?
☛ ✟
c l a s s MyClass2 {
public void method1 ( double X){
i f(X>0 . 9 5 )
throw new ArithmeticException (X
+” i s out of range ” ) ;
System . out . p r i n t l n ( ” Hello ” + X ) ;
}
public void method2 ( double Y){
i f(Y>0 . 5 )
throw new ArithmeticException (Y
+” i s out of range ” ) ;
System . out . p r i n t l n ( ” Hello ” + Y ) ;
}
public s t a t i c void main ( S t r i n g argv [ ] ) {
MyClass2 myclass = new MyClass2 ( ) ;
t r y{
myclass . method1 ( Math . random ( ) ) ;
myclass . method2 ( Math . random ( ) ) ;
}catch ( ArithmeticException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
}// m a i n ( )
}// M y C l a s s 2
✡ ✠
EXERCISE 10.5 For the values returned by random() in the previ-
ous exercise, show what would be output if printStackTrace() were
called in addition to printing an error message.
EXERCISE 10.6 In theMyClass2 program, suppose that the ﬁrst time
random() is called it returns 0.44, and the second time it is called it
returns 0.98. What output would be printed by the program?
EXERCISE 10.7 For the values returned by random() in the previ-
ous exercise, show what would be output if printStackTrace() were
called instead of printing an error message.
SECTION 10.5 •Error Handling and Robust Program Design 489
EXERCISE 10.8 Find the divide-by-zero error in the following pro-
gram, and then show what stack trace would be printed by the pr ogram:
☛ ✟
public c l a s s BadDivide {
public void method1 ( i n t n ){
method2 ( 1 0 0 , n ) ;
}
public void method2 ( i n t n , i n t d ){
System . out . p r i n t l n ( n / d ) ;
}
public s t a t i c void main ( S t r i n g args [ ] ) {
BadDivide bd = new BadDivide ( ) ;
for (i n t k = 0 ; k <5 ; k++)
bd . method1 ( k ) ;
}
}
✡ ✠
EXERCISE 10.9 Modify method2() so that it handles the divide-by-
zero exception itself, instead of letting Java handle it. Hav e it print an
error message and a stack trace.
EXERCISE 10.10 What would be printed by the following code seg-
ment if someValue equals 1000?
☛ ✟
i n t M = someValue ;
t r y{
System . out . p r i n t l n ( ” Entering t r y block ” ) ;
i f(M>100)
throw new Exception (M + ” i s too l a r g e ” ) ;
System . out . p r i n t l n ( ” E x i t i n g t r y block ” ) ;
}catch ( Exception e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
✡ ✠
EXERCISE 10.11 What would be printed by the code segment in the
preceding question if someValue equals 50?
EXERCISE 10.12 Write a try/catch block that throws an Exception
if the value of variable Xis less than zero. The exception should be an
instance of Exception and, when it is caught, the message returned by
getMessage() should be “ERROR: Negative value in X coordinate.”
10.5 Error Handling and Robust
Program Design
An important element of program design is to develop appropr iate ways
of handling erroneous and exceptional conditions. As we hav e seen, the
JVM will catch any unchecked exceptions that are not caught b y the pro-
gram itself. For your own (practice) programs, the best desi gn may simply Let Java do it?
490 CHAPTER 10 •Exceptions: When Things Go Wrong
be to use Java’s default exception handling. The program wil l termi-
nate when an exception is thrown, and then you can debug the er ror and
recompile the program.
On the other hand, this strategy would be inappropriate for c ommercial
software, which cannot be ﬁxed by its users. A well-designed commercial
program should contain exception handlers for those truly e xceptional
conditions that may arise.
In general there are three ways to handle an exceptional condi tion that
isn’t already handled by Java (Table 10.3). If the exceptiona l condition
TABLE 10.3 Exception-handling strategies.
Kind of Exception Kind of Program Action to Be Taken
Caught by Java Let Java handle it
Fixable condition Fix the error and resume execution
Unﬁxable condition Stoppable Report the error and terminate
the program
Unﬁxable condition Not stoppable Report the error and resume
processing
cannot be ﬁxed, the program should be terminated, with an app ropriate
error message. Second, if the exceptional condition can be ﬁ xed without What action should we take?
invalidating the program, then it should be remedied and the program’s
normal execution should be resumed. Third, if the exception cannot be
ﬁxed, but the program cannot be terminated, the exceptional condition
should be reported or logged in some way, and the program shou ld be
resumed.
JAVA EFFECTIVE DESIGN Handling Exceptions. There are three
general ways to handle exceptions: (1) Report the exception and
terminate the program; (2) ﬁx the exceptional condition and resume
normal execution; and (3) report the exception to a log and re sume
execution.
10.5.1 Print a Message and Terminate
Our illegal argument example is a clear case in which the exce ption is best
handled by terminating the program. In this case, this partic ular error
is best left to Java’s default exception handling, which wil l terminate the
program when the exception is thrown. There is simply no way t o satisfy
the postcondition of the avgFirstN() method when Nis less than or
equal to 0. This type of error often calls attention to a desig n ﬂaw in the Program development
SECTION 10.5 •Error Handling and Robust Program Design 491
program’s logic that should be caught during program develo pment. The
throwing of the exception helps identify the design ﬂaw.
JAVA EFFECTIVE DESIGN Exceptions and Program
Development. Java’s built-in exception handling helps identify
design ﬂaws during program development. Your own use of
exceptions should follow this approach.
Similar problems can (and often do) arise in connection with errors that
are not caught by Java. For example, suppose that your progra m receives
an erroneous input value, whose use would invalidate the cal culation it
is making. This won’t be caught by Java. But it should be caugh t by Don’t spread bad data!
your program, and an appropriate alternative here is to repo rt the error
and terminate the program. Fixing this type of error may invo lve adding
routines to validate the input data before they are used in th e calculation.
In short, rather than allowing an erroneous result to propaga te through-
out the program, it is best to terminate the program.
JAVA EFFECTIVE DESIGN Report and Terminate. If an unﬁxable
exception arises in a program that can be terminated, it is be tter to
report the error and terminate the program. That would be bet ter than
allowing it to run with an erroneous value.
10.5.2 Log the Error and Resume
Of course, the advice to stop the program assumes that the pro gram can be
terminated reasonably. Some programs—such as programs that monitor
the space shuttle or programs that control a nuclear magneti c resonance
(NMR) machine—cannot (and should not) be terminated because of such
an error.
Such programs are called failsafe because they are designed to run with-Failsafe programs
out termination. For these programs, the exception should b e reported in
whatever manner is most appropriate, but the program should continue
running. If the exceptional condition invalidates the progr am’s computa-
tions, then the exception handler should make it clear that t he results are
tainted.
Other programs—such as programs that analyze a large transac tion
database—should be designed to continue processing after ca tching such Programs that can’t be stopped
errors. For example, suppose the program a large airline run s a program
once a day to analyze the ticketing transactions that took pl ace. This
kind of program might use exceptions to identify erroneous t ransactions
or transactions that involve invalid data of some sort. Beca use there are
bound to be many errors of this kind in the database, it is not r eason-
able to stop the program. This kind of program shouldn’t stop until it
has ﬁnished processing all of the transactions. An appropri ate action for
this kind of program is to log the exceptions into some kind of ﬁle and
continue processing the transactions.
Suppose a divide-by-zero error happened in one of these prog rams. In
that case, you would override Java’s default exception hand ling to ensure
492 CHAPTER 10 •Exceptions: When Things Go Wrong
that the program is notterminated. More generally, it’s important that
these types of programs be designed to catch and report such e xceptions.
This type of exception handling should be built right into th e program’s
design.
JAVA EFFECTIVE DESIGN Report and Resume. If an unﬁxable
exception arises in a program that cannot be terminated reas onably,
the exception should be reported and the program should cont inue
executing.
10.5.3 Fix the Error and Resume
As an example of a problem that can be addressed as the program runs, Problem statement
consider the task of inputting an integer into a text ﬁeld. As you have
probably experienced, if a program is expecting an integer a nd you at-
tempt to input something beside an integer, a NumberFormatException
is generated and the program will terminate. For example, if you enter
“$55” when prompted to input an integer dollar amount, this w ill gen-
erate an exception when the Integer.parseInt() method is invoked.
The input string cannot be parsed into a valid int. However, this is the
kind of error that can be addressed as the program is running.
Let’s design a special IntField that functions like a normal text ﬁeld
but accepts only integers. If the user enters a value that gene rates a
NumberFormatException , an error message should be printed and the
user should be invited to try again. As Figure 10.13 shows, we wantJTextField
+IntField()
+IntField(in size : int)
+getInt() : intIntField
FIGURE 10.13 AnIntField is a
JTextField that accepts only
integers.this special ﬁeld to be a subclass of JTextField and to inherit the basic
JTextField functionality. It should have the same kind of constructors
that a normal JTextField has. This leads to the deﬁnition shown in
Figure 10.14.
☛ ✟
import javax . swing . ∗;
public c l a s s I n t F i e l d extends J T e x t F i e l d {
public I n t F i e l d ( ) {
super ( ) ;
}
public I n t F i e l d ( i n t s i z e ){
super ( s i z e ) ;
}
public i n t g e t I n t ( ) throws NumberFormatException {
return I n t e g e r . p a r s e I n t ( getText ( ) ) ;
}// g e t I n t ( )
}// I n t F i e l d
✡ ✠
Figure 10.14: A NumberFormatException might be thrown by the
Integer.parseInt() method in IntField.getInt() .
Note that the constructor methods use super to call the JTextField
constructor. For now, these two constructors should sufﬁce . However, What constructors do we need?
SECTION 10.5 •Error Handling and Robust Program Design 493
later we will introduce a third constructor that allows us to associate a
bound with the IntField later in this chapter.
OurIntField class needs a method that can return its contents. This
method should work like JTextField.getText() , but it should re- What methods do we need?
turn a valid integer. The getInt() method takes no parameters and
will return an int, assuming that a valid integer is typed into the
IntField . If the user enters “$55,” a NumberFormatException will
be thrown by the Integer.parseInt() method. Note that getInt()
declares that it throws this exception. This is not necessar y because a
NumberFormatException is not a checked exception, but it makes the
code clearer.
Where and how should this exception be handled? The exception can-
not easily be handled within the getInt() method. This method has to
return an integer value. If the user types in a non-integer, th ere’s no way
to return a valid value. Therefore, it’s better just to throw t he exception to
the calling method, where it can be handled more easily.
In a GUI application or applet, the calling method is likely to be an
actionPerformed() method, such as the following:
☛ ✟
public void actionPerformed ( ActionEvent e ) {
t r y{
u s e r I n t = i n t F i e l d . g e t I n t ( ) ;
message = ”You input ” + u s e r I n t + ” Thank you . ” ;
}catch ( NumberFormatException ex ) {
JOptionPane . showMessageDialog ( this ,
”The input must be an i n t e g e r . Please re −enter . ” ) ;
}f i n a l l y {
r e p a i n t ( ) ;
}
}// a c t i o n P e r f o r m e d ( )
✡ ✠
The call to getInt() is embedded in a try/catch block. This leads to
the design summarized in Figure 10.15. The IntField throws an excep-
tion that is caught by the applet, which then displays an erro r message.
showMessageDialog(): IntField : AppletSubclass: NumberFormatException : JOptionPane
throw()
catch()Figure 10.15: If the user
types a non-integer into an
IntField , it will throw a
NumberFormatException .
The applet will display an error
message in a JOptionPane (a
dialog window).
If the user inputs a valid integer, the program will just report a mes-
sage that displays the value. A more real-world example woul d make a
more signiﬁcant use of the value. On the other hand, if the use r types
an erroneous value, the program will pop up the dialog box sho wn in
Figure 10.16. (See the “From the Library” section of this cha pter for more
on dialog boxes.) When the user clicks the OK button, the progr am will
494 CHAPTER 10 •Exceptions: When Things Go Wrong
Figure 10.16: This exception han-
dler opens a dialog box to display
an error message.
resume normal execution, so that when an exception is raised , the enter
value is not used, and no harm is done by an erroneous value. Th e user
can try again to input a valid integer. Note that the ﬁnally cl ause repaints
the GUI. In this case, repainting would display the appropriat e message
on the applet or the application.
This is an example of what we might call defensive design. Defensive de-
sign is when we anticipate a possible input error and take ste ps to ensure Defensive design: Anticipating an
exception that a bad value is not propagated throughout the program.
JAVA EFFECTIVE DESIGN Defensive Design. Well-designed code
should anticipate potential problems, especially potenti al input
problems. Effective use of exceptions can help with this tas k.
Admittedly, the sense in which the error here is “ﬁxed” is sim ply that
the user’s original input is ignored and reentered. This is a legitimate
and simple course of action for this particular situation. It is far prefer-
able to ignoring the exception. If the program does not handle this excep-
tion itself, Java will catch it and will print a stack trace an d terminate the
program. That would not be a very user-friendly interface!
Clearly, this is the type of exceptional condition that shou ld be
anticipated during program design. If this happens to be a pro gram de- Anticipating exceptions
signed exclusively for your own use, then this type of except ion handling
might be unnecessary. But if the program is meant to be used by others,
SECTION 10.5 •Error Handling and Robust Program Design 495
it is important that the program be able to handle erroneous u ser input
without crashing.
JAVA EFFECTIVE DESIGN Fixing an Exception. If a method can
handle an exception effectively, it should handle it locall y. This is both
clearer and more efﬁcient.
JAVA EFFECTIVE DESIGN Library Exception Handling. Many of
Java’s library classes do not handle their own exceptions. T he thinking
behind this design is that the user of the class is in a better p osition to
handle the exception in a way that’s appropriate for the appl ication.
10.5.4 To Fix or Not to Fix
Let’s now consider a problem where it is less clear whether an excep-
tion can be successfully ﬁxed “on the ﬂy.” Suppose you have a pr ogram
that contains an array of String s, which is initially created with just two
elements.
☛ ✟
S t r i n g l i s t [ ] = new S t r i n g [ 2 ] ;
✡ ✠
If an attempt is made to add more than two elements to the array, an
ArrayIndexOutOfBoundsException will be raised. This exception
can be handled by extending the size of the array and insertin g the ele-
ment. Then the program’s normal execution can be resumed.
To begin creating such a program, let’s ﬁrst design a method t hat will
insert a string into the array. Suppose that this is intended to be aprivate Problem statement
method that will only be used within the program. Also, let’s suppose that
the program maintains a variable, count , that tracks how many values
have been stored in the array. Therefore, it will not be neces sary to pass
the array as a parameter. So, we are creating a void method with one
parameter, the String to be inserted:
☛ ✟
private void i n s e r t S t r i n g ( S t r i n g s t r ) {
// M i g h t t h r o w A r r a y I n d e x O u t O f B o u n d s E x c e p t i o n
l i s t [ count ] = s t r ;
++count ;
}
✡ ✠
The comment notes where an exception might be thrown.
Can we handle this exception? When this exception is raised, w e could
create a new array with one more element than the current arra y. We
could copy the old array into the new array and then insert the String in Algorithm design
the new location. Finally, we could set the variable list , the array refer-
496 CHAPTER 10 •Exceptions: When Things Go Wrong
ence, so that it points to the new array. Thus, we could use the following
try/catch block to handle this exception:
☛ ✟
private void i n s e r t S t r i n g ( S t r i n g s t r ) {
t r y{
l i s t [ count ] = s t r ;
}catch ( ArrayIndexOutOfBoundsException e ) {
// C r e a t e a new a r r a y
S t r i n g newList [ ] = new S t r i n g [ l i s t . length + 1 ] ;
for (i n t k = 0 ; k <l i s t . length ; k++) // C o p y a r r a y
newList [ k ] = l i s t [ k ] ;
newList [ count ] = s t r ; // I n s e r t i n t o new a r r a y
l i s t = newList ; // Make o l d p o i n t t o new
}f i n a l l y { // S i n c e t h e e x c e p t i o n i s now f i x e d
count ++; // I n c r e a s e t h e c o u n t
}
}// i n s e r t S t r i n g ( )
✡ ✠
The effect of the catch clause is to create a new array, still referred to as
list , but that contains one more element than the original array.+FixArrayBound()
+paintComponent(in g : Graphics)
-insertString(in s : String)
+actionPerformed()
+main()-list[] : String
-inField : JTextField
-prompt : JLabel
-count : intFixArrayBoundJPanel
FIGURE 10.17 The
FixArrayBound class uses
exception handling to extend the size
of an array each time a new element
is inserted.Note the use of the finally clause here. For this problem it’s impor-
tant that we increment count in the finally clause. This is the only
way to guarantee that count is incremented exactly once whenever an
element is assigned to the array.
The design of the FixArrayBound class is shown in Figure 10.17.
It provides a simple GUI interface that enables you to test the
insertString() method. This program has a standard Swing interface,
using a JFrame as the top-level window. The program’s components are
contained within a JPanel that’s added to the JFrame in themain()
method.
Each time the user types a string into the text ﬁeld, the action-
Performed() method calls the insertString() method to add the
string to the array. On each user action, the JPanel is repainted. The
paintComponent() method simply clears the panel and then displays
the array’s elements (Fig. 10.18).
JAVA DEBUGGING TIP Clearing the JPanel. Swing components,
such as JPanel , do not automatically clear their backgrounds. This
must be done explicitly in the paintComponent() method.
The complete implementation of FixArrayBound is given in Fig-
ure 10–19. This example illustrates how an exception canbe handled suc-
cessfully and the program’s normal ﬂow of control resumed. How ever,
the question is whether such an exception should be handled this way.
Figure 10.18: The strings dis-
played are stored in an array that
is extended each time a new string
is entered.

SECTION 10.5 •Error Handling and Robust Program Design 497
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import javax . swing . ∗;
public c l a s s FixArrayBound extends JPanel
implements ActionListener {
public s t a t i c f i n a l i n t WIDTH = 350 , HEIGHT = 1 0 0 ;
private J T e x t F i e l d i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
private JLabel prompt = new JLabel (
” Input a word and type <ENTER>: ”) ;
// I n i t i a l l y l i s t h a s 2 e l e m e n t s
private S t r i n g l i s t [ ] = new S t r i n g [ 2 ] ;
private i n t count = 0 ;
public FixArrayBound ( ) {
i n F i e l d . addActionListener ( t h i s ) ;
add ( prompt ) ;
add ( i n F i e l d ) ;
s e t S i z e (WIDTH, HEIGHT ) ;
}// F i x A r r a y B o u n d ( )
public void paintComponent ( Graphics g ) {
g . setColor ( getBackground ( ) ) ; // C l e a r t h e b a c k g r o u n d
g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;
g . setColor ( getForeground ( ) ) ;
S t r i n g tempS = ””;
for (i n t k = 0 ; k <l i s t . length ; k++)
tempS = tempS + l i s t [ k ] + ” ” ;
g . drawString ( tempS , 10 , 5 0 ) ;
}// p a i n t C o m p o n e n t
private void i n s e r t S t r i n g ( S t r i n g s t r ) {
t r y{
l i s t [ count ] = s t r ;
}catch ( ArrayIndexOutOfBoundsException e ) {
S t r i n g newList [ ] = new S t r i n g [ l i s t . length + 1 ] ; // New a r r a y
for (i n t k = 0 ; k <l i s t . length ; k++) // C o p y o l d t o new
newList [ k ] = l i s t [ k ] ;
newList [ count ] = s t r ; // I n s e r t i t e m i n t o new
l i s t = newList ; // Make o l d p o i n t t o new
}f i n a l l y { // T h e e x c e p t i o n i s now f i x e d
count ++; // s o i n c r e a s e t h e c o u n t
}
}// i n s e r t S t r i n g ( )
public void actionPerformed ( ActionEvent evt ) {
i n s e r t S t r i n g ( i n F i e l d . getText ( ) ) ;
i n F i e l d . s e t T e x t ( ””) ;
r e p a i n t ( ) ;
}// a c t i o n P e r f o r m e d ( )
✡ ✠
Figure 10.19: FixArrayBound increases the size of the array when a
ArrayIndexOutOfBoundsException is raised.
498 CHAPTER 10 •Exceptions: When Things Go Wrong
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
JFrame f = new JFrame ( ”Array F i x e r ” ) ;
FixArrayBound panel = new FixArrayBound ( ) ;
f . getContentPane ( ) . add ( panel ) ;
f . s e t S i z e ( panel .WIDTH, panel .HEIGHT ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// F i x A r r a y B o u n d
✡ ✠
Figure 10.19: (continued) FixArrayBound increases the size of the array
whenArrayIndexOutOfBoundsException is raised.
Unfortunately, this is not a well-designed program. The arr ay’s initial Poor program design
size is much too small for the program’s intended use. Theref ore, the fact
that these exceptions arise at all is the result of poor desig n. In general,
exceptions should notbe used as a remedy for poor design.
JAVA EFFECTIVE DESIGN Truly Exceptional Conditions. A
well-designed program should use exception handling to dea l with
truly exceptional conditions, not to process conditions th at arise under
normal or expected circumstances.
For a program that uses an array, the size of the array should b e chosen so
that it can store all the objects required by the program. If the program is Proper array usage
some kind of failsafe program, which cannot afford to crash, then some-
thing like the previous approach might be justiﬁed, provided this type
of exception occurs very rarely. Even in that case it would be better to
generate a message that alerts the program’s user that this c ondition has
occurred. The alert will indicate a need to modify the progra m’s memory
requirements and restart the program.
If it is not known in advance how many objects will be stored in an
array, a better design would be to make use of the java.util.Vector
class (see “From the Java Library” in Chapter 9). Vectors are designed to Choosing the correct data structure
grow as new objects are inserted. In some ways the exception-ha ndling
code in our example mimics the behavior of a vector. However, t he
Vector class makes use of efﬁcient algorithms for extending its siz e. By
contrast, exception-handling code is very inefﬁcient. Bec ause exceptions
force the system into an abnormal mode of execution, it takes considerably
SECTION 10.6 •Creating and Throwing Your Own Exceptions 499
longer to handle an exception than it would to use a Vector for this type
of application.
JAVA EFFECTIVE DESIGN Appropriate Data Structure. A major
component of problem solving is choosing the best way to repr esent
the data. A vector should be used as an array structure whenev er the
size of the array will grow and shrink dynamically during the
program’s execution.
SELF-STUDY EXERCISE
EXERCISE 10.13 For each of the following exceptions, determine
whether it can be handled in such a way that the program can be r esumed
or whether the program should be terminated:
a. A computer game program detects a problem with one of its GU I ele-
ments and throws a NullPointerException .
b. A factory assembly-line control program determines that an important
control value has become negative and generates an Arithmetic-
Exception .
c. A company’s Web-based order form detects that its user has entered an
invalid String and throws a SecurityException .
+getMessage()Exception
+IntOutOfRangeException(in b : int)IntOutOfRangeException
FIGURE 10.20 The
IntOutOfRange exception.10.6 Creating and Throwing Your Own
Exceptions
Like other Java classes, the Exception class can be extended to handle
cases that are not already covered by Java’s built-in except ions. Exceptions
that you deﬁne will be handled the same way by the Java interpr eter, but
you will have to throw them yourself.
For example, Figure 10.20 shows the design of an exception th at can
be used for validating that an integer is less than or equal to a certain
maximum value. It would be coded as follows:
☛ ✟
/∗∗
∗ I n t O u t O f R a n g e E x c e p t i o n r e p o r t s a n e x c e p t i o n when
∗ a n i n t e g e r e x c e e d s i t s b o u n d .
∗/
public c l a s s IntOutOfRangeException extends Exception {
public IntOutOfRangeException ( i n t Bound ) {
super (”The input value exceeds the bound ” + Bound ) ;
}
}
✡ ✠
The class extends Exception and consists entirely of a constructor
method that calls the superclass constructor. The argument passed
to the superclass constructor is the message that will be ret urned by
getMessage() when an instance of this exception is created.
500 CHAPTER 10 •Exceptions: When Things Go Wrong
Now let’s consider an example where this new exception will b e
thrown. Suppose we wish to constrain the IntField class that we de-
veloped previously (Fig. 10.14) so that it will only accept n umbers that are
less than a certain bound. First, let’s modify IntField so that its bound
can be set when an instance is created. We want its bound to be a n instance
variable with some initial value, and we want to provide a con structor that
can be used to override the default (Fig. 10.21).JTextField
+IntField()
+IntField(in size : int)
+IntField(in size : int, in max : int)
+getInt() : int-bound : intIntField
FIGURE 10.21 The revised
IntField class contains a bound on
the size of the numbers that should
be entered.This leads to the following revision of IntField :
☛ ✟
public c l a s s I n t F i e l d extends J T e x t F i e l d {
private i n t bound = I n t e g e r .MAX VALUE;
public I n t F i e l d ( i n t size , i n t max){
super ( s i z e ) ;
bound = max ;
}
// T h e r e s t o f t h e c l a s s i s u n c h a n g e d f o r now
}// I n t F i e l d
✡ ✠
Our new constructor has the signature IntField(int,int) , which
doesn’t duplicate any of JTextField ’s constructors. This is good design,
because in extending a class, we want to be careful about the e ffect that
our deﬁnitions have on the original methods in the superclas s. Superclass
methods should be overridden by design, not by accident. If a m ethod is
redeﬁned inadvertently, it might not function as expected b y users of the
subclass.
JAVA EFFECTIVE DESIGN Extending a Class. When extending a
class, care must taken to ensure that the superclass’s metho ds are not
inadvertently overridden. A superclass method should only be
overridden by design, not by accident.
Note how we have handled the problem of setting the default va lue
of the bound .Integer.MAX VALUE is a class constant that sets the
maximum value for the int type. It’s an appropriate value to use, be-
cause any valid int that the user types should be less than or equal to
MAXVALUE . Given these changes to IntField , let’s now incorporate our
new exception into its getInt() method (Fig. 10.22).
This new version of getInt() throws an exception if the integer en-
tered by the user is greater than the IntField ’sbound . Here again, it
is difﬁcult to handle this exception appropriately in this m ethod. The
method would either have to return an erroneous value—becaus e it must
return something—or it must terminate. Neither is an accepta ble alterna-
tive. It is far better to throw the exception to the calling met hod.
TheIntFieldTester class (Fig. 10.23) has the design and function-
ality shown in Figure 10.15. It provides a simple GUI interfac e to test
theIntField class. It prompts the user to type an integer that is less
than 100, and then it echoes the user’s input. Note how the exc eption is
handled in the actionPerformed() method. If an exception is thrown
inIntField.getInt() , theactionPerformed() method pops up an
SECTION 10.7 •From the Java Library: JOptionPane 501
☛ ✟
import javax . swing . ∗;
public c l a s s I n t F i e l d extends J T e x t F i e l d {
private i n t bound = I n t e g e r .MAX VALUE;
public I n t F i e l d ( i n t s i z e ){
super ( s i z e ) ;
}
public I n t F i e l d ( i n t size , i n t max){
super ( s i z e ) ;
bound = max ;
}
public i n t g e t I n t ( ) throws NumberFormatException ,
IntOutOfRangeException {
i n t num = I n t e g e r . p a r s e I n t ( getText ( ) ) ;
i f(num>bound )
throw new IntOutOfRangeException ( bound ) ;
return num;
}// g e t I n t ( )
}// I n t F i e l d
✡ ✠
Figure 10.22: The revised IntField class containing the revised
getInt() method.
error dialog, and the erroneous input is not used. Instead, th e user is given
another chance to enter a valid integer.
SELF-STUDY EXERCISES
EXERCISE 10.14 Deﬁne a new Exception named FieldIsEmpty-
Exception , which is meant to be thrown if the user forgets to enter a
value into a IntField .
EXERCISE 10.15 Modify the IntField.getInt() method so that it
throws and catches the FieldIsEmptyException .
10.7 From the Java Library: JOptionPane
Adialog box is a window that can be opened by a program to communi-
cate in some way with the user. Dialog boxes come in many varie ties and
have many uses in a GUI environment. You’ve undoubtedly enco untered
them when using your own computer.
For example, a ﬁle dialog is opened whenever you want to open or save
a ﬁle. It provides an interface that lets you name the ﬁle and he lps you
java.sun.com/j2se/1.5.0/docs/api/ search through the computer’s directory structure to ﬁnd a ﬁ le.
Awarning dialog orerror dialog is opened whenever a program needs
to notify or warn you that some kind of error occurred. It usual ly presents
an error message and an OK button that you click to dismiss the dialog.
502 CHAPTER 10 •Exceptions: When Things Go Wrong
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import javax . swing . ∗;
public c l a s s I n t F i e l d T e s t e r extends JPanel
implements ActionListener {
public s t a t i c f i n a l i n t WIDTH = 300 , HEIGHT = 3 0 0 ;
private JLabel prompt = new JLabel ( ” Input an i n t e g e r <= 1 0 0 : ” ) ;
private I n t F i e l d i n t F i e l d = new I n t F i e l d ( 1 2 , 1 0 0 ) ;
private i n t u s e r I n t ;
private S t r i n g message = ” Hello ” ;
public I n t F i e l d T e s t e r ( ) {
add ( prompt ) ;
i n t F i e l d . addActionListener ( t h i s ) ;
add ( i n t F i e l d ) ;
s e t S i z e (WIDTH, HEIGHT ) ;
}// I n t F i e l d T e s t e r ( )
public void paintComponent ( Graphics g ) {
g . setColor ( getBackground ( ) ) ; // C l e a r t h e p a n e l
g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;
g . setColor ( getForeground ( ) ) ;
g . drawString ( message , 10 , 7 0 ) ;
}// p a i n t C o m p o n e n t ( )
public void actionPerformed ( ActionEvent evt ) {
t r y{
u s e r I n t = i n t F i e l d . g e t I n t ( ) ;
message = ”You input ” + u s e r I n t + ” Thank you . ” ;
}catch ( NumberFormatException e ) {
JOptionPane . showMessageDialog ( this ,
”The input must be an i n t e g e r . Please r e e n t e r . ” ) ;
}catch ( IntOutOfRangeException e ) {
JOptionPane . showMessageDialog ( this , e . getMessage ( ) ) ;
}f i n a l l y {
r e p a i n t ( ) ;
}
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
JFrame f = new JFrame ( ” I n t F i e l d T e s t e r ” ) ;
I n t F i e l d T e s t e r panel = new I n t F i e l d T e s t e r ( ) ;
f . getContentPane ( ) . add ( panel ) ;
f . s e t S i z e ( panel .WIDTH, panel .HEIGHT ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// I n t F i e l d T e s t e r
✡ ✠
Figure 10.23: An application that uses an IntField object to process
integers.
SECTION 10.7 •From the Java Library: JOptionPane 503
Dialogs are easy to create and use in Java. The Swing componen t
set provides several different kinds of basic dialogs that c an be incorpo-
rated into your program with one or two lines of code. For exam ple, the
IntFieldTester class makes use of a simple message dialog to report
an input error to the user. This dialog was created by the foll owing code
segment in the program (see Figure 10.23):
☛ ✟
catch ( NumberFormatException e ) {
JOptionPane . showMessageDialog ( this ,
”The input must be an i n t e g e r . Please r e e n t e r . ” ) ;
}
✡ ✠
This method call displays the window shown in Figure 10.16. It con-
tains the error message and an OK button that is used to close t he win-
dow. The showMessageDialog() method is a static method of the
javax.swing.JOptionPane class. This class provides a collection of
similar methods for creating and displaying basic dialog bo xes.TopLevelWindow
DialogWindowCreates
FIGURE 10.24 A dialog window
cannot stand alone. It must be
created by a top-level window.A dialog differs from other kinds of top-level windows—such
asJApplet andJFrame —in that it is associated with another
window (Fig. 10–24). The ﬁrst parameter in this version of th e
showMessageDialog() method is a reference to the dialog’s parent
window. The second parameter is a String representing the message.
The basic message dialog used in this example is known as a modal
dialog . This means that once it’s been displayed, you can’t do anyth ing
else until you click the OK button and dismiss the dialog. It’s also possible
to create nonmodal dialogs. These can stay around on the screen while you
move on to other tasks. Modal and nonmodal dialogs
Note that the dialog box also contains an icon that symbolizes the pur-
pose of the message (Fig. 10.25). The icon is representative of the dialog’s
Figure 10.25: An error dialog.
message type. Among the basic types available in JOptionPane are the
following:
☛ ✟
JOptionPane . PLAIN MESSAGE
JOptionPane .INFORMATIONAL MESSAGE // D e f a u l t
JOptionPane .WARNING MESSAGE
JOptionPane . QUESTION MESSAGE
JOptionPane .ERROR MESSAGE
✡ ✠
504 CHAPTER 10 •Exceptions: When Things Go Wrong
To set the dialog to anything other than the default (informa tional) type,
you can use the following version of showMessageDialog() :
☛ ✟
showMessageDialog ( Component comp , Object message ,
S t r i n g t i t l e , i n t msgType ) ;
✡ ✠
The ﬁrst parameter is a reference to the parent window. The se cond is the
message string. The third is a string used as the dialog windo w’s title, and
the fourth is one of the ﬁve dialog types. For example, we can c hange our
dialog to an error dialog with the following statement:
☛ ✟
catch ( IntOutOfRangeException e ) {
JOptionPane . showMessageDialog ( this ,
e . getMessage ( ) ,
” Error dialog ” ,
JOptionPane .ERROR MESSAGE ) ;
}
✡ ✠
This would produce the dialog shown in Figure 10.25.
The other kinds of basic dialogs provided by the JOptionPane class
are listed in Table 10.4. All of the dialogs listed there can b e created with a
line or two of code. In addition to these, it’s also possible to create sophis- Basic Swing dialogs
ticated dialogs that can be as customized as any other GUI int erface you
can build in Java.
TABLE 10.4 Basic dialogs provided by JOptionPane .
Dialog Description
Message Dialog Presents a simple error or informational message
Conﬁrm Dialog Prompts the user to conﬁrm a particular action
Option Dialog Lets the user choose from some options
Input Dialog Prompts and inputs a string
In this chapter, you have learned how to handle exceptional co nditions
that occur in programs. You now know that Java has a default ex cep-
tion handler that can take of many situations, and you also un derstand
that proper program design using Java excpetion-handling e lements helps
deal with many other situations. This chapter continues the emphasis on
good program design for creating useful, stable programs.
CHAPTER SUMMARY Technical Terms
catch block
catch an exception
checked exception
dialog box
dynamic scope
error dialogexception
exception handling
ﬁnally block
method call stack
method stack trace
modal dialogstatic scope
throw an exception
try block
unchecked exception
CHAPTER 10 •Chapter Summary 505
The Try/Catch Statement
Thetry/catch/finally statement has the following syntax:
☛ ✟
t r y{
// B l o c k o f s t a t e m e n t s
// A t l e a s t o n e o f w h i c h may t h r o w a n e x c e p t i o n
i f(∗Some condition obtains ∗/ )
throw new ExceptionName ( ) ;
}catch ( ExceptionName ParameterName ) {
// B l o c k o f s t a t e m e n t s t o b e e x e c u t e d
// I f t h e E x c e p t i o n N a m e e x c e p t i o n i s t h r o w n i n t r y
}
. .
}catch ( ExceptionName2 ParameterName ) {
// B l o c k o f s t a t e m e n t s t o b e e x e c u t e d
// I f t h e E x c e p t i o n N a m e 2 e x c e p t i o n i s t h r o w n i n t r y
}f i n a l l y {
// O p t i o n a l b l o c k o f s t a t e m e n t s t h a t i s e x e c u t e d
// W h e t h e r a n e x c e p t i o n i s t h r o w n o r n o t
}
✡ ✠
The try block is meant to include a statement or statements th at might
throw an exception. The catch blocks—there can be one or more—a re
meant to handle exceptions that are thrown in the try block. A catch block
will handle any exception that matches its parameter class, including sub-
classes of that class. The ﬁnally block is optional. It will be executed
whether an exception is thrown or not. If an exception is throw n in the
try block, the try block is exited permanently.
Thethrow statement inside the try block is there to illustrate how
throw can be used. You will usually not see a throw statement in a try
block, because most throws are done from within Java library methods,
which are called from a try block.
Summary of Important Points
•In Java, when an error or exceptional condition occurs, you throw an
Exception , which is caught by special code known as an exception
handler . Athrow statement— throw new Exception() —is used to
throw an exception.
•Atry block is a block of statements containing one or more statements
that may throw an exception. Embedding a statement in a try bl ock
indicates your awareness that it might throw an exception an d your
intention to handle the exception.
•Java distinguishes between checked and unchecked exceptions. Checked
exceptions must either be caught by the method in which they o ccur
or you must declare that the method containing that statemen tthrows
the exception.
•Unchecked exceptions are those that belong to subclasses of Runtime-
Exception . If they are left uncaught, they will be handled by Java’s
default exception handlers.
506 CHAPTER 10 •Exceptions: When Things Go Wrong
•Acatch block is a block of statements that handles the exceptions that
match its parameter. A catch block can only follow a try block , and
there may be more than one catch block for each try block.
•Thetry/catch syntax allows you to separate the normal parts of an
algorithm from special code meant to handle errors and excep tional
conditions.
•Amethod stack trace is a trace of the method calls that have led
to the execution of a particular statement in the program. Th e
Exception.printStackTrace() method can be called by excep-
tion handlers to print a trace of exactly how the program reac hed the
statement that threw the exception.
•Static scoping refers to how the text of the program is arranged. If a vari-
able is declared within a method or a block, its static scope i s conﬁned
to that method or block.
•Dynamic scoping refers to how the program is executed. A statement is
within the dynamic scope of a method or block if it is called fr om that
method or block, or if it is called by some other method that wa s called
from that method or block.
•When searching for a catch block to handle an exception thrown by a
statement, Java searches upward through the statement’s st atic scope
and backward through its dynamic scope until it ﬁnds a matchi ng
catch block. If none is found, the Java Virtual Machine will ha ndle the
exception itself by printing an error message and a method st ack trace.
•Many Java library methods throw exceptions when an error occ urs.
Thesethrow statements do not appear in the program. For example,
Java’s integer division operator will throw an ArithmeticException
if an attempt is made to divide by zero.
•Generally, there are four ways to handle an exception: (1) Le t Java han-
dle it; (2) ﬁx the problem that led to the exception and resume the pro-
gram; (3) report the problem and resume the program; and (4) p rint an
error message and terminate the program. Most erroneous con ditions
reported by exceptions are difﬁcult or impossible to ﬁx.
•Afinally statement is an optional part of a try/catch block. State-
ments contained in a ﬁnally block will be executed whether an excep-
tion is raised or not.
•A well-designed program should use exception handling to de al with
truly exceptional conditions, not as a means of normal progr am control.
•User-deﬁned exceptions can be deﬁned by extending the Exception
class or one of its subclasses.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 10.1
a.Integer.parseInt("26.2"); ==> NumberFormatException
b.String s; s.indexOf(’a’); ==> NullPointerException
c.String s = "hello"; s.charAt(5); ==> StringIndexOutOfBoun dsException
SOLUTION 10.2 The unchecked exceptions are IndexOutOfBoundsException ,
NumberFormatException , andNullPointerException , because these are
subclasses of RuntimeException . The others are checked exceptions.
CHAPTER 10 •Solutions to Self-Study Exercises 507
SOLUTION 10.3 AnArrayIndexOutOfBoundsException could be handled
by the handlers in a, c, or d, because their classes are all supe rclasses of Array-
IndexOutOfBoundsException .
SOLUTION 10.4 IfMath.random() inMyClass2 returns 0.98 and then 0.44,
the program will generate the following output:
☛ ✟
0 . 9 8 i s out of range
✡ ✠
Note that because the out-of-range error occurs in method1() ,method2() is not
called at all.
SOLUTION 10.5 IfMath.random() inMyClass2 returns 0.98 and then 0.44,
the following stack trace would be printed:
☛ ✟
java . lang . ArithmeticException : 0 . 9 8 i s out of range
at MyClass2 . method1 ( MyClass2 . java : 3 )
at MyClass2 . main ( MyClass2 . java : 1 5 )
✡ ✠
SOLUTION 10.6 IfMath.random() inMyClass2 returns 0.44 and then 0.98,
the program will generate the following output:
☛ ✟
Hello 0 . 4 4
0 . 9 8 i s out of range
✡ ✠
SOLUTION 10.7 IfMath.random() inMyClass2 returns 0.44 and then 0.98,
the following stack trace would be printed:
☛ ✟
java . lang . ArithmeticException : 0 . 9 8 i s out of range
at MyClass2 . method2 ( MyClass2 . java : 8 )
at MyClass2 . main ( MyClass2 . java : 1 6 )
✡ ✠
SOLUTION 10.8 The divide-by-zero error in BadDivide occurs in the expres-
sionn/d inMethod2() . It would generate the following stack trace:
☛ ✟
java . lang . ArithmeticException : divide by zero
at BadDivide . method2 ( BadDivide . java : 7 )
at BadDivide . method1 ( BadDivide . java : 3 )
at BadDivide . main ( BadDivide . java : 1 3 )
✡ ✠
508 CHAPTER 10 •Exceptions: When Things Go Wrong
SOLUTION 10.9 The following version of BadDivide.method2() will handle
the divide-by-zero error itself:
☛ ✟
public void method2 ( i n t n , i n t d ){
t r y{
System . out . p r i n t l n ( n / d ) ;
}catch ( ArithmeticException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 0 ) ;
}
}
✡ ✠
SOLUTION 10.10 IfsomeValue equals 1000, the code segment will print
☛ ✟
Entering t r y block
ERROR: 1000 i s too l a r g e
✡ ✠
SOLUTION 10.11 IfsomeValue equals 50, the code segment will print
☛ ✟
Entering t r y block
E x i t i n g t r y block
✡ ✠
SOLUTION 10.12
☛ ✟
t r y{
i f(X<0)
throw new Exception (
”ERROR: Negative value in X coordinate ” ) ;
}catch ( Exception e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
✡ ✠
SOLUTION 10.13
a. It depends. This is a computer game, so one way to handle this p roblem
would be to generate a message into a log ﬁle and resume the game. If
the GUI element is crucial to the game, it’s hard to see how it coul d be
successfully handled.
b. It depends. You would have to decide whether it would be more har mful or
dangerous to continue production than not.
c. The program could report the security violation to the user and t o the system
manager and then keep accepting user input.
SOLUTION 10.14
☛ ✟
public c l a s s FieldIsEmptyException extends Exception {
public FieldIsEmptyException ( ) {
super (”The input f i e l d i s empty ” ) ;
}
}
✡ ✠
CHAPTER 10 •Exercises 509
SOLUTION 10.15
☛ ✟
public i n t g e t I n t ( ) {
i n t num = 0 ;
t r y{
S t r i n g data = getText ( ) ;
i f( data . equals ( ””) )
throw new FieldIsEmptyException ( ) ;
num = I n t e g e r . p a r s e I n t ( getText ( ) ) ;
i f(num>bound )
throw new IntOutOfRangeException ( bound ) ;
}catch ( FieldIsEmptyException e ) {
System . out . p r i n t l n ( ” Error : ” + e . getMessage ( ) ) ;
}catch ( NumberFormatException e ) {
System . out . p r i n t l n ( ” Error : You must input an i n t e g e r .
Please t r y again . ” ) ;
}catch ( IntOutOfRangeException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
return 0 ;
}
return num;
}
✡ ✠
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 10.1 Explain the difference between the following pairs of terms:
a.Throwing an exception and catching an exception .
b.Try block and catch block .
c.Catch block and ﬁnally block .
d.Try block and ﬁnally block .
e.Dynamic scope and static scope .
f.Dialog box and top-level window .
g.Checked and unchecked exception.
h.Method stack and method call .
EXERCISE 10.2 Fill in the blanks.
a. an exception is Java’s way of signaling that some kind of abnormal
situation has occurred.
b. The only place that an exception can be thrown in a Java program i s within a
.
c. The block of statements placed within a catch block is general ly known as an
.
d. To determine a statement’s scope, you have to trace the program’s
execution.
e. To determine a statement’s scope, you can just read its deﬁnition.
f. When a method is called, a representation of the method call is p laced on the
.
g. The root of Java’s exception hierarchy is the class.
h. A exception must be either caught or declared within the method in
which it might be thrown.
510 CHAPTER 10 •Exceptions: When Things Go Wrong
i. An exception can be left up to Java to handle.
EXERCISE 10.3 Compare and contrast the four different ways of handling ex-
ceptions within a program.
EXERCISE 10.4 Suppose you have a program that asks the user to input a string
of no more than ﬁve letters. Describe the steps you’d need to take i n order to
design a StringTooLongException to handle cases where the user types in too
many characters.
EXERCISE 10.5 Exceptions require more computational overhead than normal
processing. Explain.
EXERCISE 10.6 Suppose the following ExerciseExample program is cur-
rently executing the if statement in method2() :
☛ ✟
public c l a s s ExerciseExample {
public void method1 ( i n t M){
t r y{
System . out . p r i n t l n ( ” Entering t r y block ” ) ;
method2 ( M ) ;
System . out . p r i n t l n ( ” E x i t i n g t r y block ” ) ;
}catch ( Exception e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
}// m e t h o d 1 ( )
public void method2 ( i n t M){
i f(M>100)
throw new ArithmeticException (M + ” i s too l a r g e ” ) ;
}
public s t a t i c void main ( S t r i n g argv [ ] ) {
ExerciseExample ex = new ExerciseExample ( ) ;
ex . method1 ( 5 0 0 ) ;
}
}// E x e r c i s e E x a m p l e
✡ ✠
Draw a picture of the method call stack that represents this sit uation.
EXERCISE 10.7 Repeat the previous exercise for the situation where the pro-
gram is currently executing the second println() statement in method1() .
EXERCISE 10.8 Draw a hierarchy chart that represents the static scoping rel a-
tionships among the elements of the ExerciseExample program.
EXERCISE 10.9 What would be printed by the ExerciseExample program
when it is run?
EXERCISE 10.10 What would be printed by the ExerciseExample program,
if the statement in its main method were changed to ex.method1(5) ?
EXERCISE 10.11 Consider again the ExerciseExample program. If the ex-
ception thrown were Exception rather than ArithmeticException , explain
why we would get the following error message: java.lang.Exception must
be caught, or it must be declared... .
EXERCISE 10.12 Write a try/catch block that throws an Exception if the
value of variable Xis less than zero. The exception should be an instance of
Exception and, when it is caught, the message returned by getMessage()
should be “ERROR: Negative value in X coordinate.”
CHAPTER 10 •Exercises 511
EXERCISE 10.13 Look at the IntFieldTester program (Fig. 10.23) and the
IntField class deﬁnition (Fig. 10.22). Suppose the user inputs a value th at’s
greater than 100. Show what the method call stack would look like whe n the
IntField.getInt() method is executing the num > bound expression.
EXERCISE 10.14 As a continuation of the previous exercise, show what the
program’s output would be if the user input a value greater than 10 0.
EXERCISE 10.15 As a continuation of the previous exercise, modify the
IntOutOfRangeException handler so that it prints the message call stack. Then
show what it would print.
EXERCISE 10.16 Deﬁne a subclass of RuntimeException named Invalid-
PasswordException , which contains two constructors. The ﬁrst constructor
takes no parameters and an exception thrown with this construct or should re-
turn “ERROR: invalid password” when its getMessage() is invoked. The sec-
ond constructor takes a single String parameter. Exceptions thrown with this
constructor should return the constructor’s argument when getMessage() is
invoked.
EXERCISE 10.17 Extend the IntField class so that it will constrain the integer
JTextField to anint between both a lower and upper bound. In other words, it
should throw an exception if the user types in a value lower than th e lower bound
or greater than the upper bound.
EXERCISE 10.18 Design Issue: One of the preconditions for the Insertion-
Sort() method (Fig. 9.13) is that its array parameter not be null. Of cou rse, this
precondition would fail if the array were passed a null array ref erence. In that
case, Java would throw a NullPointerException and terminate the program.
Is this an appropriate way to handle that exception?
EXERCISE 10.19 With respect to the previous exercise, suppose you decide that
it is more appropriate to handle the NullPointerException by presenting an
error dialog. Modify the method to accommodate this behavior.
EXERCISE 10.20 Design Issue: Another possible way to design the sequential-
Search() method (Fig. 9.16) would be to have it throw an exception when its k ey
is not found in the array. Is this a good design? Explain.
512 CHAPTER 10 •Exceptions: When Things Go Wrong
OBJECTIVES
After studying this chapter, you will
•Be able to read and write text ﬁles.
•Know how to read and write binary ﬁles.
•Understand the use of InputStream s andOutputStream s.
•Be able to design methods for performing input and output.
•Know how to use the File class.
•Be able to use the JFileChooser class.
OUTLINE
11.1 Introduction
11.2 Streams and Files
11.3 Case Study: Reading and Writing Text Files
11.4 The File Class
11.5 Example: Reading and Writing Binary Files
11.6 Object Serialization: Reading and Writing Objects
11.7 From the Java Library: javax.swing.JFileChooser
11.8 Using File Data in Programs
Special Topic: Databases and Personal Privacy
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 11
Files and Streams:
Input/Output Techniques
513
514 CHAPTER 11 •Files and Streams: Input/Output Techniques
11.1 Introduction
We have been using input and output in our programs since the v ery ﬁrst
chapters of the book. In this chapter we will take a closer look at Java’s
input and output elements.
Input refers to information or data read from some external source into
a running program. We introduced you to working with input in Chap-
ter 4, when we developed the KeyboardReader class with metho ds for
reading data from the keyboard into the console window. We al so dis-
cussed reading data from the keyboard into a JTextField in a GUI inter-
face, as well as reading data from a text ﬁle using methods in t heScanner input and output
class during that chapter.
Output refers to information or data written from the running progr am
to some external destination. Up to this point, whenever our programs
have produced output, it has been sent to either the Java cons ole, to a text
area, or to some other GUI component. These destinations are transitory,
in the sense that they reside in the computer’s primary memor y and exist
only so long as the program is running.
Aﬁleis a collection of data that’s stored on a disk or on some other
relatively permanent storage medium. A ﬁle’s existence doe s not depend
on a running program. In this chapter, we will learn how to crea te ﬁles
and how to perform input and output operations on their data u sing the
Java classes designed speciﬁcally for this purpose. Method s from these
classes allow us to write data to ﬁles and provide greater ﬂexi bility in the
way we read data from ﬁles than the Scanner class offers.
11.2 Streams and Files
As was noted in Chapter 4, all input and output (I/O) in Java is a ccom-
plished through the use of input streams and output streams. You are
already familiar with input and output streams because we ha ve rou- I/O streams
tinely used the System.out output stream and and the System.in in-
put stream (Fig. 11.1) in this text’s examples. Recall that System.out
usually connects your program (source) to the screen (desti nation) and
System.in usually connects the keyboard (source) to the running pro-
gram (destination). What you have learned about streams will also be a
key for connecting ﬁles to a program.
Figure 11.1: The System.out
output stream connects your
program to the screen and
theSystem.in input stream
connects it to the keyboard.Screen
KeyboardMemory
System.in
Input streamSystem.out
Output streamProgram
SECTION 11.2 •Streams and Files 515
11.2.1 The Data Hierarchy
Data, or information, are the contents that ﬂow through Java s treams or
stored in ﬁles. All data are comprised of binary digits or bits. A bit is
simply a 0 or a 1, the electronic states that correspond to the se values. As
we learned in Chapter 5, a bit is the smallest unit of data.
However, it would be tedious if a program had to work with data i n
units as small as bits. Therefore, most operations involve v arious-sized
aggregates of data such as an 8-bit byte , a 16-bit short , a 16-bit char , a
32-bitint, a 64-bit long , a 32-bit float , or a 64-bit double . As we know,
these are Java’s primitive numeric types. In addition to thes e aggregates,
we can group together a sequence of char to form a String .
It is also possible to group data of different types into object s. A record ,
which corresponds closely to a Java object, can have ﬁelds that contain
different types of data. For example, a student record might contain ﬁelds
for the student’s name and address represented by ( String s), expected
year of graduation ( int), and current grade point average represented
by (double ). Collections of these records are typically grouped into ﬁles.
For example, your registrar’s ofﬁce may have a separate ﬁle f or each of
its graduating classes. These are typically organized into a collection of
related ﬁles, which is called a database .Database
File
Recordchris martine
deborah mars 2000 9.15
Byte
Bita
00110001
0william smith 2001 8.75
Field
deborah marsdeborah mars 2000 9.151999 10.1
FIGURE 11.2 The data hierarchy.Taken together, the different kinds of data that are process ed by a com-
puter or stored in a ﬁle can be organized into a data hierarchy (Fig. 11.2).
It’s important to recognize that while we, the programmers, m ay
group data into various types of abstract entities, the info rmation ﬂowing
through an input or output stream is just a sequence of bits. Th ere are no
natural boundaries that mark where one byte (or one int or one record)
ends and the next one begins. Therefore, it will be up to us to p rovide the
boundaries as we process the data.
11.2.2 Binary Files and Text Files
As we noted in chapter 4, there are two types of ﬁles in Java: bi nary ﬁles
and text ﬁles. Both kinds store data as a sequence of bits—that is, a se-
quence of 0’s and 1’s. Thus, the difference between the two ty pes of ﬁles
lies in the way they are interpreted by the programs that read and write
them. A binary ﬁle is processed as a sequence of bytes, whereas a text ﬁle is
processed as a sequence of characters.
Text editors and other programs that process text ﬁles inter pret the
ﬁle’s sequence of bits as a sequence of characters—that is, as a string.
Your Java source programs ( *.java ) are text ﬁles, and so are the HTML
ﬁles that populate the World Wide Web. The big advantage of te xt ﬁles
is their portability. Because their data are represented in the ASCII code Text ﬁles are portable
(Table 5.13), they can be read and written by just about any tex t-processing
program. Thus, a text ﬁle created by a program on a Windows/Int el
computer can be read by a Macintosh program.
In non-Java environments, data in binary ﬁles are stored as by tes, and
the representation used varies from computer to computer. T he manner
in which a computer’s memory stores binary data determines h ow it is
represented in a ﬁle. Thus, binary data are not very portable . For exam-
516 CHAPTER 11 •Files and Streams: Input/Output Techniques
ple, a binary ﬁle of integers created on a Macintosh cannot be read by a
Windows/Intel program.
One reason for the lack of portability is that each type of com puter uses
its own deﬁnition for how an integer is deﬁned. On some system s an Binary ﬁles are platform dependent
integer might be 16 bits, and on others it might be 32 bits, so e ven if you
know that a Macintosh binary ﬁle contains integers, that sti ll won’t make
it readable by Windows/Intel programs. Another problem is th at even
if two computers use the same number of bits to represent an in teger,
they might use different representation schemes. For examp le, some com-
puters might use 10000101 as the 8-bit representation of the number 133,
whereas other computers might use the reverse, 10100001, to represent
133.
The good news for us is that Java’s designers have made its bin ary ﬁles
platform independent by carefully deﬁning the exact size and representation
that must be used for integers and all other primitive types. Thus, binary
ﬁles created by Java programs can be interpreted by Java prog rams on any
platform.
JAVA LANGUAGE RULE Platform Independence. Java binary ﬁles
are platform independent. They can be interpreted by any com puter
that supports Java.
11.2.3 Input and Output Streams
Java has a wide variety of streams for performing I/O. They are de-
ﬁned in the java.io package, which must be imported by any program
that does I/O. They are generally organized into the hierarch y illustrated
in Figure 11.3. We will cover only a small portion of the hiera rchy in
this text. Generally speaking, binary ﬁles are processed by subclasses
ofInputStream andOutputStream . Text ﬁles are processed by sub- I/O streams
classes of Reader andWriter , both of which are streams, despite their
names.
InputStream andOutputStream are abstract classes that serve as
the root classes for reading and writing binary data. Their m ost commonly
used subclasses are DataInputStream andDataOutputStream ,
which are used for processing String data and data of any of Java’s prim-
itive types— char ,boolean ,int,double , and so on. The analogues of
these classes for processing text data are the Reader andWriter classes,
which serve as the root classes for all text I/O.
JAVA PROGRAMMING TIP Choosing a Stream. In choosing an
appropriate stream for an I/O operation, DataInputStream s and
DataOutputStream s normally are used for binary I/O. Reader and
Writer streams normally are used for text I/O.
The various subclasses of these root classes perform variou s specialized
I/O operations. For example, FileInputStream andFileOutput-
Stream are used for performing binary input and output on ﬁles. The
PrintStream class contains methods for outputting various primitive
SECTION 11.2 •Streams and Files 517
Object
InputStream
FileReader
OutputStream
WriterByteArrayInputStream
FileInputStream
FilterInputStream
ObjectInputStream
PipedInputStreamBufferedInputStream
DataInputStream
BufferedReader
CharArrayReader
InputStreamReader
PipedReader
StringReaderLineNumberReader
FileReader
ByteArrayOutputStream
FileOutputStream
FilterOutputStream
ObjectOutputStream
PipedOutputStreamBufferedOutputStreamDataOutputStream
BufferedWriter
CharArrayWriter
PipedWriter
PrintWriter
StringWriterOutputStreamWriter FileWriterjava.io
FilterWriterFigure 11.3: Java’s stream hierar-
chy.
data—integers, ﬂoats, and so forth—as text. The System.out stream,
one of the most widely used output streams, is an object of this type. The
PrintWriter class, which was introduced in JDK 1.1 contains the same
methods as PrintStream but the methods are designed to support plat-
form independence and internationalized I/O—that is, I/O that works in
different languages and alphabets.
518 CHAPTER 11 •Files and Streams: Input/Output Techniques
The various methods deﬁned in PrintWriter are designed to output
+PrintWriter(in out : OutputStream)
+PrintWriter(in out : Writer)
+print(in i : int)
+print(in l : long)
+print(in f : float)
+print(in d : double)
+print(in s : String)
+print(in o : Object)
+println(in i : int)
+println(in l : long)
+println(in f : float)
+println(in d : double)
+println(in s : String)
+println(in o : Object)PrintWriterWriter
FIGURE 11.4 PrintWriter
methods print data of various types.a particular type of primitive data (Fig. 11.4). As you would expect, there
is both a print() andprintln() method for each kind of data that the
programmer wants to output.
Table 11.1 brieﬂy describes Java’s most commonly used input a nd out-
put streams. In addition to the ones we’ve already mentioned, you are
already familiar with methods from the BufferedReader andFile
classes, which were used in Chapter 4.
Filtering refers to performing operations on data while the data are
being input or output. Methods in the FilterInputStream and
FilterReader classes can be used to ﬁlter binary and text data dur-
ing input. Methods in the FilterOutputStream andFilterWriter
can be used to ﬁlter output data. These classes serve as the ro ot classes
for various ﬁltering subclasses. They can also be subclasse d to perform
customized data ﬁltering.
One type of ﬁltering is buffering , which is provided by several buffered
streams, including BufferedInputStream andBufferedReader , for
performing binary and text input, and BufferedOutputStream and
BufferedWriter , for buffered output operations. As was discussed in
TABLE 11.1 Description of some of Java’s important stream classes.
Class Description
InputStream Abstract root class of all binary input streams
FileInputStream Provides methods for reading bytes from a binary ﬁle
FilterInputStream Provides methods required to ﬁlter data
BufferedInputStream Provides input data buffering for reading large ﬁles
ByteArrayInputStream Provides methods for reading an array as if it were a stream
DataInputStream Provides methods for reading Java’s primitive data types
PipedInputStream Provides methods for reading piped data from another thread
OutputStream Abstract root class of all binary output streams
FileOutputStream Provides methods for writing bytes to a binary ﬁle
FilterOutputStream Provides methods required to ﬁlter data
BufferedOutputStream Provides output data buffering for writing large ﬁles
ByteArrayOutputStream Provides methods for writing an array as if it were a stream
DataOutputStream Provides methods for writing Java’s primitive data types
PipedOutputStream Provides methods for writing piped data to another thread
PrintStream Provides methods for writing primitive data as text
Reader Abstract root class for all text input streams
BufferedReader Provides buffering for character input streams
CharArrayReader Provides input operations on char arrays
FileReader Provides methods for character input on ﬁles
FilterReader Provides methods to ﬁlter character input
StringReader Provides input operations on String s
Writer Abstract root class for all text output streams
BufferedWriter Provides buffering for character output streams
CharArrayWriter Provides output operations to char arrays
FileWriter Provides methods for output to text ﬁles
FilterWriter Provides methods to ﬁlter character output
PrintWriter Provides methods for printing binary data as characters
StringWriter Provides output operations to String s
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 519
chapter 4, a buffer is a relatively large region of memory used to temporar-
ily store data while they are being input or output. When buffe ring is
used, a program will transfer a large number of bytes into the buffer from
the relatively slow input device and then transfer these to t he program
as each read operation is performed. The transfer from the bu ffer to the
program’s memory is very fast.
Similarly, when buffering is used during output, data are tr ansferred
directly to the buffer and then written to the disk when the bu ffer ﬁlls up
or when the flush() method is called.
JAVA PROGRAMMING TIP Buffering. Buffered streams can
improve a program’s overall efﬁciency by reducing the amoun t of time
it spends accessing relatively slow input or output devices .
You can also deﬁne your own data ﬁltering subclasses to perfo rm
customized ﬁltering. For example, suppose you want to add li ne numbers Buffering
to a text editor’s printed output. To perform this task, you c ould deﬁne a
FilterWriter subclass and override its write() methods to perform Filtering data
the desired ﬁltering operation. Similarly, to remove the li ne numbers from
such a ﬁle during input, you could deﬁne a FilterReader subclass. In
that case, you would override its read() methods to suit your goals for
the program.
There are several classes that provide I/O-like operations o n various
internal memory structures. ByteArrayInputStream ,ByteArray-
OutputStream ,CharArrayReader , andCharArrayWriter are four
classes that take input from or send output to arrays in the pr ogram’s
memory. Methods in these classes can be useful for performin g vari-
ous operations on data during input or output. For example, s uppose
a program reads an entire line of integer data from a binary ﬁl e into a
ByteArray . It might then transform the data by, say, computing the
remainder modulo Nof each value. The program now can read these
transformed data by treating the byte array as an input strea m. A similar
example would apply for some kind of output transformation.
TheStringReader andStringWriter classes provide methods for
treating String s andStringBuffer s as I/O streams. These methods
can be useful for performing certain data conversions.
JAVA PROGRAMMING TIP Integer/String Conversion. An integer
can be converted to a String by writing it to a StringBuffer ,
which can then be output as an entire line of text. StringReader
methods can be used to read integer data from an ordinary String
object.
11.3 CASE STUDY: Reading and Writing Text
Files
Let’s write a GUI application that will be able to read and wri te data to
and from a text ﬁle. To do this, we will need to develop a set of m ethods
to perform I/O on text ﬁles.
520 CHAPTER 11 •Files and Streams: Input/Output Techniques
The GUI for this application will contain a JTextArea , where text ﬁle GUI design
data can be input and displayed, and a JTextField , where the user can
enter the ﬁle’s name. It will also contain two JButton s, one for read-
ing a ﬁle into the JTextArea , and the other for writing the data in the
JTextArea into a ﬁle (Fig. 11.5). Note that even this simple interface w ill
let the user create new ﬁles and rename existing ﬁles.
Figure 11.5: The GUI design for
a program that reads and writes
text ﬁles.
JTextArea for displaying file
BorderLayout CenterJFrame JTextField JButtonsBorderLayout
north
JFrame
	 Controls JPanel
		 Prompt JLabel
		 Input JTextField
		 ReadFile JButton
		 WriteFile JButton
	 Display JTextArea
WriteFile ReadFile prompt:JLabel
Component Hierarchy
11.3.1 Text File Format
A text ﬁle consists of a sequence of characters divided into z ero or more
lines and ending with a special end-of-ﬁle character . When you open a The end-of-ﬁle character
new ﬁle in a text editor, it contains zero lines and zero chara cters. After
typing a single character, it would contain one character an d one line. The
following would be an example of a ﬁle with four lines of text:
☛ ✟
one\ntwo\nthree\nfour\n\eof
✡ ✠
Note the use of the end-of-line character, \n, to mark the end of each line,
and the use of the end-of-ﬁle character, \eof , to mark the end of the ﬁle.
As we’ll see, the I/O methods for text ﬁles use these special ch aracters to
control reading and writing loops. Thus, when the ﬁle is read by appro-
priate Java methods, such as the BufferedReader.readLine() and
BufferedReader.read() methods, one or more characters will be read
until either an end-of-line or end-of-ﬁle character is enco untered. When a
line of characters is written using println() , the end-of-line character is
appended to the characters themselves.
11.3.2 Writing to a Text File
Let’s see how to write to a text ﬁle. In this program we write the entire
contents of the JTextArea() to the text ﬁle. In general, writing data to a
ﬁle requires three steps:
1. Connect an output stream to the ﬁle.
2. Write text data into the stream, possibly using a loop.
3. Close the stream.
As Figure 11.1 shows, connecting a stream to a ﬁle looks like d oing a bit
of plumbing. The ﬁrst step is to connect an output stream to th e ﬁle. The
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 521
output stream serves as a conduit between the program and a na med ﬁle. Output stream
The output stream opens the ﬁle and gets it ready to accept dat a from the
program. If the ﬁle already exists, then opening the ﬁle will d estroy any
data it previously contained. If the ﬁle doesn’t yet exist, th en it will be
created from scratch.
Once the ﬁle is open, the next step is to write the text to the st ream,
which passes the text on to the ﬁle. This step might require a l oop that
outputs one line of data on each iteration. Finally, once all the data have
been written to the ﬁle, the stream should be closed. This als o has the
effect of closing the ﬁle itself.
JAVA EFFECTIVE DESIGN Writing a File. Writing data to a ﬁle
requires a three-step algorithm: (1) Connect an output stre am to the
ﬁle, (2) write the data, and (3) close the ﬁle.
Code Reuse: Designing an Output Method
Now let’s see how these three steps are done in Java. Suppose t he text we
want to write is contained in a JTextArea . Thus, we want a method that
will write the contents of a JTextArea to a named ﬁle.
What output stream should we use for the task of writing a String to Choosing an output stream
a named ﬁle? To decide this, we need to use the information in F igure 11.3
and Table 11.1. As we pointed out earlier, because we’re writ ing a text ﬁle,
we would use a Writer subclass. But which subclass should we use? The
only way to decide this is to consult the Java API documentati on, using
links at
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
to see what methods are available in the various subclasses. For I/O op-
erations you want to consult the classes in the java.io package. Ideally,
we would like to be able to create an output stream to a named ﬁl e, and
we would like to be able to write a String to the ﬁle.
One likely candidate is the FileWriter class (Fig. 11.6). Its name and
description (Table 11.1) suggest that it’s designed for wri ting text ﬁles.
And indeed it contains the kind of constructor we need—that is , one that
takes the ﬁle name as a parameter. Note that by taking a boolean param-
eter, the second constructor allows us to append data to a ﬁle rather than
rewrite the entire ﬁle, which is the default case.
However, FileWriter doesn’t deﬁne a write() method. This
doesn’t necessarily mean that it doesn’t contain such a meth od. It might
have inherited one from its superclasses, OutputStreamWriter and Inheritance
Writer . Indeed, the Writer class contains a method, write() , whose
signature suggests that it is ideally suited for our task (Fi g. 11.6).
522 CHAPTER 11 •Files and Streams: Input/Output Techniques
Figure 11.6: To ﬁnd the right I/O
method, it is sometimes necessary
to search the Java class hierarchy.
This is easy to do with the online
documentation.+write(in s : String)Writer
OutputStreamWriter
+FileWriter(in fileName : String)
+FileWriter(in fileName : String, in append :boolean)FileWriter
Having decided on a FileWriter stream, the rest of the task of de-
signing our method is simply a matter of using FileWriter methods in
an appropriate way:
☛ ✟
private void w r i t e T e x t F i l e ( JTextArea display ,
S t r i n g fileName ) {
// C r e a t e s t r e a m & o p e n f i l e
F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;
// W r i t e t h e e n t i r e d i s p l a y t e x t a n d c l o s e t h e s t r e a m
outStream . write ( display . getText ( ) ) ;
outStream . c l o s e ( ) ; // C l o s e t h e o u t p u t s t r e a m
}
✡ ✠
We use the FileWriter() constructor to create an output stream to the
ﬁle whose name is stored in fileName . In this case, the task of writing
data to the ﬁle is handled by a single write() statement, which writes
the entire contents of the JTextArea in one operation.
Finally, once we have ﬁnished writing the data, we close() the output
stream. This also has the effect of closing the ﬁle. The overa ll effect of this
method is that the text contained in display has been output to a ﬁle,
named fileName , which is stored on the disk.
JAVA PROGRAMMING TIP Closing a File. Even though Java will
close any apen ﬁles and streams when a program terminates nor mally,
it is good programming practice to close the ﬁle yourself wit h a
close() statement. It also reduces the chances of damaging the ﬁle if
the program terminates abnormally.
Because so many different things can go wrong during an I/O ope ration,
most I/O operations generate some kind of checked exception . Therefore, it
is necessary to embed the I/O operations within a try/catch statement.
In this example, the FileWriter() constructor, the write() method,
and the close() method may each throw an IOException . Therefore,
the entire body of this method should be embedded within a try/catch
block that catches the IOException (Fig. 11.7).
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 523
☛ ✟
private void w r i t e T e x t F i l e ( JTextArea display ,
S t r i n g fileName ) {
t r y{
F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;
outStream . write ( display . getText ( ) ) ;
outStream . c l o s e ( ) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}
}// w r i t e T e x t F i l e ( )
✡ ✠
Figure 11.7: A method to write a text ﬁle.
11.3.3 Code Reuse: Designing Text File Output
ThewriteTextFile() method provides a simple example of how to
write data to a text ﬁle. More importantly, its development i llustrates
the kinds of choices necessary to design effective I/O method s. Two
important design questions we asked and answered were
•What methods do we need to perform the desired task?
•What streams contain the desired methods?
As in so many other examples we’ve considered, designing a me thod to Method design
perform a task is often a matter of ﬁnding the appropriate met hods in the
Java class hierarchy.
JAVA EFFECTIVE DESIGN Code Reuse. Developing effective I/O
routines is primarily a matter of choosing the right library methods.
Start by asking yourself, “What methods do I need?” and then ﬁn d a
stream class that contains the appropriate methods.
As you might expect, there is more than one way to write data to a text
ﬁle. Suppose we decided that writing text to a ﬁle is like prin ting data to
System.out . And suppose we chose to use a PrintWriter object as
our ﬁrst candidate for an output stream (Fig. 11.3 and Table 1 1.1). This
class (Fig. 11.4) contains a wide range of print() methods for writing
different types of data as text. So it has exactly the kind of m ethod we
need:print(String) . However, this stream does not contain a con-
structor method that allows us to create a stream from the nam e of a
ﬁle. Its constructors require either a Writer object or an OutputStream
object.
This means that we can use a PrintWriter to print to a ﬁle, but only
if we can ﬁrst construct either an OutputStream or aWriter object
to the ﬁle. So we must go back to searching Figure 11.3 and Tabl e 11.1
for an appropriate candidate. Fortunately, the FileOutputStream class
(Fig. 11.8) has just the constructors we want. We now have an al terna-
tive way of coding the writeTextFile() method, this time using a
combination of PrintWriter andFileOutputStream :
524 CHAPTER 11 •Files and Streams: Input/Output Techniques
Figure 11.8: The FileOutput-
Stream class.OutputStream
+FileOutputStream(in filename : String)
+FileOutputStream(in filename : String, in append : boolean)FileOutputStream
☛ ✟
// C r e a t e a n o u t p u t s t r e a m a n d o p e n t h e f i l e
P r i n t W r i t e r outStream =
new P r i n t W r i t e r ( new FileOutputStream ( fileName ) ) ;
// W r i t e t h e d i s p l a y ’ s t e x t a n d c l o s e t h e s t r e a m
outStream . p r i n t ( display . getText ( ) ) ;
outStream . c l o s e ( ) ;
✡ ✠
Note how the output stream is created in this case. First, we c reate a
FileOutputStream using the ﬁle name as its argument. Then we cre-
ate aPrintWriter using the FileOutputStream as its argument. The
reason we can do this is because the PrintWriter() constructor takes Parameter agreement
aFileOutputStream parameter. This is what makes the connection
possible.
To use the plumbing analogy again, this is like connecting tw o sections
of pipe between the program and the ﬁle. The data will ﬂow from t he
program through PrintWriter , through the OutputStream , to the ﬁle.
Of course, you can’t just arbitrarily connect one stream to an other. They
have to “ﬁt together,” which means that their parameters hav e to match.
JAVA EFFECTIVE DESIGN Stream/Stream Connections. Two
different kinds of streams can be connected if a constructor for one
stream takes the second kind of stream as a parameter. This is often an
effective way to create the kind of object you need to perform a n I/O
task.
java.sun.com/j2se/1.5.0/docs/api/The important lesson here is that we found what we wanted by se arching
through the java.io. *hierarchy. This same approach can be used to
help you to design I/O methods for other tasks.
SELF-STUDY EXERCISE
EXERCISE 11.1 Is it possible to perform output to a text ﬁle using a
PrintWriter and aFileWriter stream in combination? If so, write
the Java code.
11.3.4 Reading from a Text File
Let’s now look at the problem of inputting data from an existi ng text ﬁle,
a common operation that occurs whenever your email program o pens an
email message or your word processor opens a document. In gene ral,
there are three steps to reading data from a ﬁle:
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 525
1. Connect an input stream to the ﬁle.
2. Read the text data using a loop.
3. Close the stream.
As Figure 11.9 shows, the input stream serves as a kind of pipe between
the ﬁle and the program. The ﬁrst step is to connect an input st ream to the
Memory
Output streamInput streamText file 0100010
0100101
1111111
1111100
1100101
0111110
1111110Figure 11.9: A stream serves as a
pipe through which data ﬂow.
ﬁle. Of course, in order to read a ﬁle, the ﬁle must exist. The i nput stream
serves as a conduit between the program and the named ﬁle. It op ens the
ﬁle and gets it ready for reading. Once the ﬁle is open, the nex t step is to
read the ﬁle’s data. This will usually require a loop that rea ds data until
the end of the ﬁle is reached. Finally, once all the data are re ad, the stream
should be closed.
JAVA EFFECTIVE DESIGN Reading Data Reading data from a ﬁle
requires a three-step algorithm: (1) Connect an input strea m to the ﬁle,
(2) read the data, and (3) close the ﬁle.
Now let’s see how these three steps are done in Java. Suppose t hat we
want to put the ﬁle’s data into a JTextArea . Thus, we want a method
that will be given the name of a ﬁle and a reference to a JTextArea , and
it will read the data from the ﬁle into the JTextArea .
What input stream should we use for this task? Here again we need to Choosing an input stream
use the information in Figure 11.3 and Table 11.1. Because we ’re reading
a text ﬁle, we should use a Reader subclass. A good candidate is the
FileReader , whose name and description suggest that it might contain
useful methods.
What methods do we need? As in the previous example, we need a
constructor method that connects an input stream to a ﬁle whe n the con-
structor is given the name of the ﬁle. And, ideally, we’d like to have a What methods should we use?
method that will read one line at a time from the text ﬁle.
TheFileReader class (Fig. 11.10) has the right kind of constructor.
However, it contains no readLine() methods itself, which would be
necessary for our purposes. Searching upward through its su perclasses,
we ﬁnd that InputStreamReader , its immediate parent class, has a
method that reads ints:
☛ ✟
public i n t read ( ) throws IOException ( ) ;
✡ ✠
As shown in Figure 11.10, this read() method is an override of the
read() method deﬁned in the Reader class, the root class for text ﬁle
input streams. Thus, there are no readLine() methods in the Reader
526 CHAPTER 11 •Files and Streams: Input/Output Techniques
Figure 11.10: FileReader ’s su-
perclasses contain read() meth-
ods but no readLine() meth-
ods.+read() : intReader
+read() : intInputStreamReader
+FileReader(in fileName : String)FileReader+BufferedReader(in instream : Reader)
+readLine() : StringBufferedReader
branch of the hierarchy. We have to look elsewhere for an appr opriate
class.
One class that does contain a readLine() method is BufferedReader
(Fig. 11.10). Can we somehow use it? Fortunately, the answer is yes.
BufferedReader ’s constructor takes a Reader object as a parameter.
But aFileReader isaReader —that is, it is a descendant of the Reader
class. So, to use our plumbing analogy again, to build an inpu t stream to
the ﬁle, we can join a BufferedReader and aFileReader
☛ ✟
BufferedReader inStream
=new BufferedReader ( new FileReader ( fileName ) ) ;
✡ ✠
Given this sort of connection to the ﬁle, the program can use Buffered-
Reader.readLine() to read one line at a time from the ﬁle.
So, we have found a method that reads one line at a time. Now we n eed
an algorithm that will read the entire ﬁle. Of course, this wi ll involve
a loop, and the key will be to make sure we get the loop’s termin ation
condition correct.
An important fact about readLine() is that it will return null as its Using the end-of-ﬁle character
value when it reaches the end of the ﬁle. Recall that text ﬁles have a special
end-of-ﬁle character. When readLine() encounters this character, it will
return null . Therefore, we can specify the following while loop:
☛ ✟
S t r i n g l i n e = inStream . readLine ( ) ;
while ( l i n e != null ){
display . append ( l i n e + ”\n”) ;
l i n e = inStream . readLine ( ) ;
}
✡ ✠
We begin outside the loop by attempting to read a line from the ﬁle. If
the ﬁle happens to be empty (which it might be), then line will be set to
null ; otherwise it will contain the String that was read. In this case, we
append the line to a JTextArea . Note that readLine() does not return
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 527
the end-of-line character with its return value. That’s why we add a \n
before we append the line to the JTextArea .
JAVA PROGRAMMING TIP End of Line. Remember that
readLine() does not return the end-of-line character as part of the
text it returns. If you want to print the text on separate lines , you must
append\n.
The last statement in the body of the loop attempts to read the next line
from the input stream. If the end of ﬁle has been reached, this a ttempt
will return null and the loop will terminate. Otherwise, the loop will
continue reading and displaying lines until the end of ﬁle is reached.
Taken together, these various design decisions lead to the d eﬁnition for
readTextFile() shown in Figure 11.11.
☛ ✟
private void r e a d T e x t F i l e ( JTextArea display ,
S t r i n g fileName ) {
t r y{
BufferedReader inStream // C r e a t e a n d o p e n t h e s t r e a m
=new BufferedReader ( new FileReader ( fileName ) ) ;
S t r i n g l i n e = inStream . readLine ( ) ; // R e a d o n e l i n e
while ( l i n e != null ){ // W h i l e m o r e t e x t
display . append ( l i n e + ”\n”) ; // D i s p l a y a l i n e
l i n e = inStream . readLine ( ) ; // R e a d n e x t l i n e
}
inStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( FileNotFoundException e ) {
display . s e t T e x t ( ”IOERROR : ” + fileName + ” NOT found \n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}
}// r e a d T e x t F i l e ( )
✡ ✠
Figure 11.11: A method for reading a text ﬁle.
Note that we must catch both the IOException , thrown by
readLine() andclose() , and the FileNotFoundException , thrown IOException
by theFileReader() constructor. It’s important to see that the read loop
has the following form:
☛ ✟
t r y to read one l i n e of data
and s t o r e i t in l i n e // L o o p i n i t i a l i z e r
while ( l i n e i s not null ){// L o o p e n t r y c o n d i t i o n
process the data
t r y to read one l i n e of data
and s t o r e i t in l i n e // L o o p u p d a t e r
}
✡ ✠
528 CHAPTER 11 •Files and Streams: Input/Output Techniques
When it attempts to read the end-of-ﬁle character, readLine() will return
null .
JAVA EFFECTIVE DESIGN Reading Text. In reading text ﬁles, the
readLine() method will return null when it tries to read the
end-of-ﬁle character. This provides a convenient way of tes ting for the
end of ﬁle.
JAVA EFFECTIVE DESIGN Reading an Empty File. Loops for
reading text ﬁles are designed to work even if the ﬁle is empty .
Therefore, the loop should attempt to read a line before testing the
loop-entry condition. If the initial read returns null , that means the
ﬁle is empty and the loop body will be skipped.
SELF-STUDY EXERCISE
EXERCISE 11.2 What’s wrong with the following loop for reading a
text ﬁle and printing its output on the screen?
☛ ✟
S t r i n g l i n e = null ;
do{
l i n e = inStream . readLine ( ) ;
System . out . p r i n t l n ( l i n e ) ;
}while ( l i n e != null ) ;
✡ ✠
11.3.5 Code Reuse: Designing Text File Input
Our last example used BufferedReader.readLine() to read an entire
line from the ﬁle in one operation. But this isn’t the only way to do things.
For example, we could use the FileReader stream directly if we were
willing to do without the readLine() method. Let’s design an algorithm
that works in this case.
As we saw earlier, if you use a FileReader stream, then you must use
theInputStreamReader.read() method. This method reads bytes
from an input stream and translates them into Java Unicode ch aracters.
Theread() method, for example, returns a single Unicode character as
anint:
☛ ✟
public i n t read ( ) throws IOException ( ) ;
✡ ✠
Of course, we can always convert this to a char and concatenate it to a
JTextArea , as the following algorithm illustrates:
☛ ✟
i n t ch = inStream . read ( ) ; // I n i t : T r y t o r e a d a c h a r a c t e r
while ( ch != −1){// E n t r y −c o n d i t i o n : w h i l e m o r e c h a r s
display . append ( ( char ) ch + ””) ; // A p p e n d t h e c h a r a c t e r
ch = inStream . read ( ) ; // U p d a t e r : t r y t o r e a d
}
✡ ✠
SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 529
Although the details are different, the structure of this lo op is the same as
if we were reading one line at a time.
The loop variable in this case is an int because InputStreamReader.-
read() returns the next character as an int, or it returns −1if it encoun-
ters the end-of-file character. Because chis anint, we must convert Data conversion
it to achar and then to a String in order to append() it to the display.
A loop to read data from a ﬁle has the following basic form:
☛ ✟
t r y to read data i n t o a v a r i a b l e // I n i t i a l i z e r
while ( read was s u c c e s s f u l ) { // E n t r y c o n d i t i o n
process the data
t r y to read data i n t o a v a r i a b l e // U p d a t e r
}
✡ ✠
JAVA EFFECTIVE DESIGN Read Loop Structure. Theread() and
readLine() methods have different ways to indicate when a read
attempt fails. These differences affect how the loop-entry condition is
speciﬁed, but the structure of the read loop is the same.
JAVA PROGRAMMING TIP Read Versus Readline. Unless it is
necessary to manipulate each character in the text ﬁle, read ing a line at
a time is more efﬁcient and, therefore, preferable.
It is worth noting again the point we made earlier: Designing e ffective
I/O routines is largely a matter of searching the java.io package for ap-
propriate classes and methods. The methods we’ve developed can serve
as suitable models for a wide variety of text I/O tasks, but if y ou ﬁnd
that they aren’t suitable for a particular task, you can desi gn your own
method. Just think about what it is you want the program to acc omplish,
then ﬁnd the stream classes that contain methods you can use t o perform
the desired task. Basic reading and writing algorithms will be pretty much Reusing existing code
the same no matter which particular read or write method you u se.
SELF-STUDY EXERCISE
EXERCISE 11.3 What’s wrong with the following loop for reading a
text ﬁle and printing its output on the screen?
☛ ✟
i n t ch ;
do{
ch = inStream . read ( ) ;
System . out . p r i n t ( ( char ) ch ) ;
}while ( ch != −1)
✡ ✠
530 CHAPTER 11 •Files and Streams: Input/Output Techniques
11.3.6 The TextIO Application
Given the text I/O methods we wrote in the previous sections, w e can
now specify the overall design of our TextIO class (Fig. 11.12). In order
to complete this application, we need only set up its GUI and w rite its
actionPerformed() method.
Figure 11.12: The TextIO class.
+TextIO()
-readTextFile(in display : JTextArea, in fileName : String)
-writeTextFile(in display : JTextArea, in fileName : String)
+actionPerformed(in evt : ActionEvent)
+main(in args[] : String)-display : JTextArea
-read : JButton
-nameField : JTextField
-prompt : JLabel
-commands : JPanelTextIO+actionPerformed()«interface»
ActionListenerJFrame
Setting up the GUI for this application is straightforward. Figure 11.13
shows how the ﬁnished product will look. The code is given in F ig-
ure 11.14. Pay particular attention to the actionPerformed() method,
which uses the methods we deﬁned in the previous section.
Figure 11.13: An application that
performs simple text I/O.

SECTION 11.3 •CASE STUDY: Reading and Writing Text Files 531
☛ ✟
import javax . swing . ∗; // S w i n g c o m p o n e n t s
import java . awt . ∗;
import java . io . ∗;
import java . awt . event . ∗;
public c l a s s TextIO extends JFrame implements ActionListener {
private JTextArea display = new JTextArea ( ) ;
private JButton read = new JButton ( ”Read From F i l e ” ) ,
write = new JButton ( ” Write to F i l e ” ) ;
private J T e x t F i e l d nameField = new J T e x t F i e l d ( 2 0 ) ;
private JLabel prompt = new JLabel ( ” Filename : ” , JLabel . RIGHT ) ;
private JPanel commands = new JPanel ( ) ;
public TextIO ( ) { // C o n s t r u c t o r
super (” TextIO Demo” ) ; // S e t w i n d o w t i t l e
read . addActionListener ( t h i s ) ;
write . addActionListener ( t h i s ) ;
commands . setLayout ( new GridLayout ( 2 , 2 , 1 , 1 ) ) ; // C o n t r o l p a n e l
commands . add ( prompt ) ;
commands . add ( nameField ) ;
commands . add ( read ) ;
commands . add ( write ) ;
display . setLineWrap ( true ) ;
t h i s . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
t h i s . getContentPane ( ) . add ( ”North” , commands ) ;
t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( display ) ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , display ) ;
}// T e x t I O
private void w r i t e T e x t F i l e ( JTextArea display , S t r i n g fileName ) {
t r y{
F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;
outStream . write ( display . getText ( ) ) ;
outStream . c l o s e ( ) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}
}// w r i t e T e x t F i l e ( )
private void r e a d T e x t F i l e ( JTextArea display , S t r i n g fileName ) {
t r y{
BufferedReader inStream // C r e a t e a n d o p e n t h e s t r e a m
=new BufferedReader ( new FileReader ( fileName ) ) ;
S t r i n g l i n e = inStream . readLine ( ) ; // R e a d o n e l i n e
while ( l i n e != null ){ // W h i l e m o r e t e x t
display . append ( l i n e + ”\n”) ; // D i s p l a y a l i n e
l i n e = inStream . readLine ( ) ; // R e a d n e x t l i n e
}
inStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( FileNotFoundException e ) {
display . s e t T e x t ( ”IOERROR : ” + fileName + ” NOT found \n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
e . p r i n t S t a c k T r a c e ( ) ;
}
}// r e a d T e x t F i l e
✡ ✠
Figure 11.14: Part I of the TextIO class.
532 CHAPTER 11 •Files and Streams: Input/Output Techniques
☛ ✟
public void actionPerformed ( ActionEvent evt ) {
S t r i n g fileName = nameField . getText ( ) ;
i f( evt . getSource ( ) == read ) {
display . s e t T e x t ( ””) ;
r e a d T e x t F i l e ( display , fileName ) ;
}
else w r i t e T e x t F i l e ( display , fileName ) ;
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
TextIO t i o = new TextIO ( ) ;
t i o . s e t S i z e ( 4 0 0 , 2 0 0 ) ;
t i o . s e t V i s i b l e ( true ) ;
t i o . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// T e x t I O
✡ ✠
Figure 11.14: ( continued ) TheTextIO class, Part II.
11.4 The File Class
As we’ve seen, an attempt to create a FileReader stream may throw a
FileNotFoundException . The way this happens is if the user provides
a name for a ﬁle that either doesn’t exist or isn’t located whe re its name
says it should be located. The question that needs to be consi dered: Is
there any way we can detect these kinds of errors before attem pting to
read the ﬁle?
Thejava.io.File class provides methods that we can use for this
task. The File class provides a representation of the computer’s ﬁle androot
index.htmlhome
examplesjava
datafiles
data.txtMyClass.java MyClass.class
FIGURE 11.15 A simple hierarchy
of directories and ﬁles.directory information in a platform-independent manner. A s you know, a
ﬁle is a collection of data, whereas a directory is a collection of ﬁles. (To be
exact, a directory is a ﬁle that stores its ﬁles’ names and att ributes, not the
ﬁles themselves.) In this section, we will provide details ab out the File
class and how to use the methods available in the class.
11.4.1 Names and Paths
In order to correctly specify a ﬁle’s location, it is necessar y to know a little
about how ﬁles are stored on your computer’s disk drive. File systems
are organized into a hierarchy. A path is a description of a ﬁle’s loca-
tion in the hierarchy. For example, consider the hierarchy o f ﬁles in Fig-
ure 11.15. Assume that your Java program is named MyClass.class .
When a program is running, the program’s directory is conside red the
current directory . Any ﬁles located in the current directory can be referred
to by name alone—for example, MyClass.java . To refer to a ﬁle located
in a subdirectory of the current directory, you need to provi de the name The ﬁle hierarchy
of the subdirectory and the ﬁle: datafiles/data.txt . In this case, we
SECTION 11.4 •TheFile Class 533
are assuming a Unix ﬁle system, so we are using the /as the separator
between the name of the directory ( datafiles ) and the name of the ﬁle
(data.txt ). This is an example of a relative path name , because we are
specifying a ﬁle in relation to the current directory.
Alternatively, a ﬁle can be speciﬁed by its absolute path name . This
would be a name whose path starts at the root directory of the ﬁ le system.
For example,
☛ ✟
/root/java/examples/ d a t a f i l e s /data . t x t
✡ ✠
would be the absolute path name for the ﬁle named data.txt on a Unix
system. When you supply the name of a ﬁle to one of the stream con struc-
tors, you are actually providing a path name. If the path consists of just a
name, such as data.txt , Java assumes that the ﬁle is located in the same
directory as the program itself.
11.4.2 Validating File Names
Before reading a ﬁle it is often necessary to determine that t he ﬁle’s name
is a valid one and that the ﬁle can be read. The File class (Fig. 11.16)
provides platform-independent methods for dealing with ﬁl es and di-
rectories. It contains methods that list the contents of dire ctories, de-
termine a ﬁle’s attributes, and rename and delete ﬁles. Note the sev-+canRead() : boolean
+canWrite() : boolean
+delete() : boolean
+exists() : boolean
+getName() : String
+getParent() : String
+getPath() : String
+isDirectory() : boolean
+isFile() : boolean
+lastModified() : long
+length() : long
+list() : String[]
+renameToFile(in f : File) : File+pathSeparator : String
+pathSeparatorChar : char
+separator : String
+separatorChar : charFileObject «interface»
Serializable
FIGURE 11.16 Thejava.io.File
class.eralstatic constants provided. These allow path names to be speci-
ﬁed in a platform-independent way. For example, on a Unix sys tem, the
File.separator character will be the /and on a Windows system it
will be the \,backslash .File.separator will be initialized to the
appropriate separator for the particular system being used .
JAVA PROGRAMMING TIP File Separators. To help make your
programs platform independent, use the File.separator constant
instead of a literal value whenever you are specifying a path name.
As an example of how you might use some of File ’s methods, let’s write
a method that tests whether the ﬁle name entered by the user is the name
of a valid, readable ﬁle.
A ﬁle might be unreadable for a number of reasons. It might be ow ned
by another user and readable only by that user. Or it might be d esignated Method design
as not readable by its owner. We’ll pass the method the name of the ﬁle
(aString ), and the method will return true if a readable ﬁle with that
534 CHAPTER 11 •Files and Streams: Input/Output Techniques
name exists. Otherwise, the method will throw an exception a nd return
false :
☛ ✟
private boolean i s R e a d a b l e F i l e ( S t r i n g fileName ) {
t r y{
F i l e f i l e = new F i l e ( fileName ) ;
i f( ! f i l e . e x i s t s ( ) )
throw (new FileNotFoundException ( ”No such F i l e : ”
+ fileName ) ) ;
i f( ! f i l e . canRead ( ) )
throw (new IOException ( ” F i l e not readable : ”
+ fileName ) ) ;
return true ;
}catch ( FileNotFoundException e ) {
System . out . p r i n t l n ( ”IOERROR : F i l e NOT Found : ”
+ fileName + ”\n”) ;
return f a l s e ;
}catch ( IOException e ) {
System . out . p r i n t l n ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
return f a l s e ;
}
}// i s R e a d a b l e F i l e
✡ ✠
The method simply creates a File instance and uses its exists() and
canRead() methods to check whether its name is valid. If either condi-
tion fails, an exception is thrown. The method handles its ow n exceptions,
printing an error message and returning false in each case.
Before attempting to write data to a ﬁle, we might want to chec k that
the ﬁle has been given an appropriate name. For example, if th e user
leaves the ﬁle name blank, we should not write data to the ﬁle. Also, a ﬁle
might be designated as unwriteable in order to protect it fro m being in-
advertently overwritten. We should check that the ﬁle is wri teable before
attempting to write to it:
☛ ✟
private boolean i s W r i t e a b l e F i l e ( S t r i n g fileName ) {
t r y{
F i l e f i l e = new F i l e ( fileName ) ;
i f( fileName . length ( ) == 0)
throw (new IOException ( ” I n v a l i d f i l e name : ”
+ fileName ) ) ;
i f( f i l e . e x i s t s ( ) && ! f i l e . canWrite ( ) )
throw (new IOException (
”IOERROR : F i l e not w r i t e a b l e : ” + fileName ) ) ;
return true ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
return f a l s e ;
}
}// i s W r i t e a b l e F i l e ( )
✡ ✠
The ﬁrst check in this code tests that the user has not forgott en to pro-
vide a name for the output ﬁle. It is unlikely that the user want s to name
the ﬁle with the empty string. We use the exists() method to test
SECTION 11.5 •Example: Reading and Writing Binary Files 535
whether the user is attempting to write to an existing ﬁle. If s o, we use
thecanWrite() method to test whether the ﬁle is writeable. Both kinds
of errors result in IOException s.
SELF-STUDY EXERCISE
EXERCISE 11.4 The other methods of the File class are just as easy to
use as the ones we have illustrated in this section. Write a me thod that
takes the name of a ﬁle as its single parameter and prints the f ollowing
information about the ﬁle: its absolute path, its length, an d whether it is a
directory or a ﬁle.
11.5 Example: Reading and Writing Binary Files
Although text ﬁles are extremely useful and often employed, they can’t
and shouldn’t be used for every data-processing applicatio n. For exam-
ple, your college’s administrative data system undoubtedl y uses ﬁles to
store student records. Because your student record contain s a variety of
different types of data— String s,ints,double s—it cannot be processed
as text. Similarly, a company’s inventory ﬁles, which also i nclude data of
a wide variety of types, cannot be processed as text. Files su ch as these
must be processed as binary data.
Suppose you are asked to write an application that involves t he use
of a company’s employee records. Recall that a record is a str ucture that
combines different types of data into a single entity. It’s li ke an object with
no methods, just instance variables.
A binary ﬁle is a sequence of bytes. Unlike a text ﬁle, which is termi-
nated by a special end-of-ﬁle marker, a binary ﬁle consists o f nothing but
data. A binary ﬁle doesn’t have an end-of-ﬁle character beca use any such
character would be indistinguishable from a binary datum.
JAVA DEBUGGING TIP End of Binary File. Because a binary ﬁle
does not have an end-of-ﬁle character, it would be an error to use the
same loop-entry conditions we used in the loops we designed f or
reading text ﬁles.
Generally speaking, the steps involved in reading and writi ng binary ﬁles
are the same as for text ﬁles:
1. Connect a stream to the ﬁle.
2. Read or write the data, possibly using a loop.
3. Close the stream.
The difference between text and binary ﬁle I/O resides in the J ava streams
that we use.
11.5.1 Writing Binary Data
Let’s begin by designing a method that will output employee d ata to a
binary ﬁle. As the developer of this program, one thing you’l l have to Generating binary data
536 CHAPTER 11 •Files and Streams: Input/Output Techniques
do is build some sample data ﬁles. These can’t easily be built by hand—
remember you can’t use a text editor to create them—so you’ll w ant to
develop a method that can generate some random data of the sor t your
application will have to process.
JAVA EFFECTIVE DESIGN I/O Design. When designing ﬁle I/O
applications, it is good to design the input and the output me thods
together. This is especially important for binary I/O.
The ﬁrst thing we need to know is exactly what the data look lik e. Let’s
assume that each record contains three individual pieces of data—the em-
ployee’s name, age, and pay rate. For example, the data in a ﬁl e containing
four records might look like this, once the data are interpre ted:
☛ ✟
Name0 24 1 5 . 0 6
Name1 25 5 . 0 9
Name2 40 1 1 . 4 5
Name3 52 9 . 2 5
✡ ✠
As you can see, these data look as if they were randomly genera ted, but
they resemble the real data in the important respects: They a re of the
right type— String ,int,double —and have the right kind of values. Of
course, when these data are stored in the ﬁle, or in the progra m’s memory,
they just look like one long string of 0’s and 1’s.
Our approach to designing this output method will be the same as the
approach we used in designing methods for text I/O. That is, we start
with two questions:
•What stream classes should I use?
•What methods can I use?
And we ﬁnd the answers to these by searching through the java.io
package (Fig. 11.3 and Table 11.1).
Because we are performing binary output, we need to use some s ub-
class of OutputStream . Because we’re outputting to a ﬁle, one likely
candidate is FileOutputStream (Fig. 11.17). This class has the right
kind of constructors, but it only contains write() methods for writing
ints andbyte s, and we need to be able to write String s anddouble s
as well as ints.
Figure 11.17: The FileOutput-
Stream class.
+FileOutputStream(in filename : String)
+FileOutputStream(in filename : String, in append : boolean)FileOutputStreamOutputStream
SECTION 11.5 •Example: Reading and Writing Binary Files 537
These kinds of methods are found in DataOutputStream (Fig. 11.18),
+DataOutputStream(in s : OutputStream)
+flush()
+writeBoolean(in b : Boolean)
+writeByte(in i : int)
+writeBytes(in s : String)
+writeChar(in c : int)
+writeChars(in s : String)
+writeDouble(in d : double)
+writeFloat(in f : float)
+writeInt(in i : int)
+writeLong(in l : long)
+writeShort(in s : short)
+writeUTF(in s : String)DataOutputStreamFilterOutputStream
FIGURE 11.18 The
java.io.DataOutputStream
class contains methods for writing all
types of data.which contains a write() method for each different type of data. As
you can see, there’s one method for each primitive type. Howev er, note
that the writeChar() takes an int parameter, which indicates that the
character is written in binary format rather than as a ASCII or Unicode
character. Although you can’t tell by just reading its method signature,
thewriteChars(String) method also writes its data in binary for-
mat rather than as a sequence of characters. This is the main d ifference
between these write() methods and the ones deﬁned in the Writer
branch of Java’s I/O hierarchy.
Now that we’ve found the appropriate classes and methods, we need
to create a pipeline to write data to the ﬁle and develop an out put al-
gorithm. To construct a stream to use in writing employee rec ords, we
want to join together a DataOutputStream and aFileOutputStream .
TheDataOutputStream gives us the output methods we need, and the
FileOutputStream lets us use the ﬁle’s name to create the stream:
☛ ✟
DataOutputStream outStream
=new DataOutputStream ( new FileOutputStream ( fileName ) ) ;
✡ ✠
This enables the program to write data to the DataOutputStream , which
will pass them through the FileOutputStream to the ﬁle itself. That
settles the ﬁrst question.
To develop the output algorithm, we need some kind of loop tha t in-
volves calls to the appropriate methods. In this case, becaus e we are gen-
erating random data, we can use a simple for loop to generate, say, ﬁve
records of employee data. We need one write() statement for each of
the elements in the employee record: The name ( String ), age (int), and
pay rate ( double ):
☛ ✟
for (i n t k = 0 ; k <5 ; k++) { // O u t p u t 5 d a t a r e c o r d s
outStream . writeUTF ( ”Name” + k ) ; // Name
outStream . w r i t e I n t ( ( i n t) ( 2 0 + Math . random ( ) ∗2 5 ) ) ; // A g e
outStream . writeDouble ( Math . random ( ) ∗5 0 0 ) ; // P a y r a t e
}
✡ ✠
Within the loop body we have one output statement for each dat a element
in the record. The names of the methods reﬂect the type of data t hey write.
Thus, we use writeInt() to write an int andwriteDouble() to write
adouble . But why do we use writeUTF to write the employee’s name,
aString ?
The Unicode Text Format (UTF)
There is no DataOutputStream.writeString() method. Instead,
String s are written using the writeUTF() method. UTF stands for
Unicode Text Format , a coding scheme for Java’s Unicode character set.
Recall that Java uses the Unicode character set instead of th e ASCII set.
As a 16-bit code, Unicode can represent 8-bit ASCII character s plus a wide ASCII vs. Unicode
variety of Asian and other international characters. Howeve r, Unicode is
not a very efﬁcient coding scheme if you aren’t writing an int ernational
538 CHAPTER 11 •Files and Streams: Input/Output Techniques
program. If your program just uses the standard ASCII character s, which
can be stored in 1 byte, you would be wasting 1 byte per charact er if you
stored them as straight Unicode characters. Therefore, for efﬁciency pur-
poses, Java uses the UTF format. UTF encoding can still repre sent all of the
Unicode characters, but it provides a more efﬁcient way of re presenting
the ASCII subset.
It’s now time to combine these separate elements into a single method
(Fig. 11.19). The writeRecords() method takes a single String pa-
rameter that speciﬁes the name of the ﬁle. This is a void method. It
will output data to a ﬁle, but it will not return anything to th e calling
method. The method follows the standard output algorithm: C reate an
output stream, write the data, close the stream. Note also th at the method
includes a try/catch block to handle any IOException s that might be
thrown.
☛ ✟
private void writeRecords ( S t r i n g fileName ) {
t r y{
DataOutputStream outStream // O p e n s t r e a m
=new DataOutputStream ( new FileOutputStream ( fileName ) ) ;
for (i n t k = 0 ; k <5 ; k++) {// O u t p u t 5 d a t a r e c o r d s
S t r i n g name = ”Name” + k ; // o f name , a g e , p a y r a t e
outStream . writeUTF ( ”Name” + k ) ;
outStream . w r i t e I n t ( ( i n t) ( 2 0 + Math . random ( ) ∗2 5 ) ) ;
outStream . writeDouble ( 5 . 0 0 + Math . random ( ) ∗1 0 ) ;
}// f o r
outStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}
}// w r i t e R e c o r d s ( )
✡ ✠
Figure 11.19: A method to write a binary ﬁle consisting of ﬁve randomly
constructed records.
11.5.2 Reading Binary Data
The steps involved in reading data from a binary ﬁle are the sa me as for
reading data from a text ﬁle: Create an input stream and open t he ﬁle,
read the data, close the ﬁle. The main difference lies in the w ay you check
for the end-of-ﬁle marker in a binary ﬁle.
Let’s design a method to read the binary data that were output by the
writeRecords() method. We’ll call this method readRecords() . It,
too, will consist of a single String parameter that provides the name ofInputStream
+FileInputStream(in filename : String)FileInputStream
FIGURE 11.20 The
java.io.FileInputStream class.the ﬁle to be read, and it will be a void method. It will just displ ay the
data on System.out .
The next questions we need to address are: What stream classes should
we use, and what methods should we use? For binary input, we ne ed
anInputStream subclass (Fig. 11.3 and Table 11.1). As you’ve prob-
ably come to expect, the FileInputStream class contains construc-
tors that let us create a stream from a ﬁle name (Fig. 11.20). Ho w-
ever, it does not contain useful read() methods. Fortunately, the
SECTION 11.5 •Example: Reading and Writing Binary Files 539
DataInputStream class contains the input counterparts of the meth-
ods we found in DataOutputStream (Fig. 11.21). Therefore, our input
stream for this method will be a combination of DataInputStream and
FileInputStream :
☛ ✟
DataInputStream inStream
=new DataInputStream ( new FileInputStream ( f i l e ) ) ;
✡ ✠
Now that we have identiﬁed the classes and methods we’ll use t o read the
data, the most important remaining issue is designing a read loop that will
terminate correctly. Unlike text ﬁles, binary ﬁles do not co ntain a special
end-of-ﬁle marker. Therefore, the read methods can’t see an ything in the
ﬁle that tells them they’re at the end of the ﬁle. Instead, when a binary read
method attempts to read past the end of the ﬁle, an end-of-ﬁle exception
EOFException is thrown. Thus, the binary loop is coded as an inﬁnite
loop that’s exited when the EOFException is raised:+readBoolean() : boolean
+readByte() : byte
+readChar() : char
+readDouble() : double
+readFloat() : float
+readInt() : int
+readLong() : long
+readShort() : short
+readUTF() : StringDataInputStreamFilterInputStream
FIGURE 11.21 The
java.io.DataInputStream class
contains methods for reading all
types of data.☛ ✟
t r y{
while (true ){ // I n f i n i t e l o o p
S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d
i n t age = inStream . readInt ( ) ;
double pay = inStream . readDouble ( ) ;
display . append (name + ” ” + age + ” ” + pay + ”\n”) ;
}// w h i l e
}catch ( EOFException e ) {} // U n t i l EOF e x c e p t i o n
✡ ✠
The read loop is embedded within a try/catch statement. Note that the
catch clause for the EOFException does nothing. Recall that when an
exception is thrown in a try block, the block is exited for good, which is
precisely the action we want to take. That’s why we needn’t do anything
when we catch the EOFException . We have to catch the exception or
else Java will catch it and terminate the program. This is an e xample of an An expected exception
expected exception.
JAVA EFFECTIVE DESIGN EOFException .An attempt to read
past the end of a binary ﬁle will cause an EOFException to be
thrown. Catching this exception is the standard way of termi nating a
binary input loop.
Note also the read() statements within the loop are mirror opposites of
thewrite() statements in the method that created the data. This will
generally be true for binary I/O routines: The statements tha t read data
from a ﬁle should “match” those that wrote the data in the ﬁrst place.
JAVA EFFECTIVE DESIGN Matching Input to Output. The
statements used to read binary data should match those that w rote the
data. If a writeX() method were used to write the data, a readX()
should be used to read it.
To complete the method, the only remaining task is to close() the stream
after the data are read. The complete deﬁnition is shown in Fi gure 11.22.
540 CHAPTER 11 •Files and Streams: Input/Output Techniques
☛ ✟
private void readRecords ( S t r i n g fileName ) {
t r y{
DataInputStream inStream // O p e n s t r e a m
=new DataInputStream ( new FileInputStream ( fileName ) ) ;
display . s e t T e x t ( ”Name Age Pay \n”) ;
t r y{
while (true ){ // I n f i n i t e l o o p
S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d
i n t age = inStream . readInt ( ) ;
double pay = inStream . readDouble ( ) ;
display . append (name + ” ” + age + ” ” + pay + ”\n”) ;
}// w h i l e
}catch ( EOFException e ) {// U n t i l EOF e x c e p t i o n
}f i n a l l y {
inStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}
}catch ( FileNotFoundException e ) {
display . s e t T e x t ( ”IOERROR : ” + fileName + ” NOT Found : \n”) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}
}// r e a d R e c o r d s ( )
✡ ✠
Figure 11.22: A method for reading binary data.
It’s important that a close() statement be placed after the catch
EOFException clause. If it were placed in the try block, it would
never get executed. Note also that the entire method is embed ded in an
outertry block that catches the IOException , thrown by the various
read() methods, and the FileNotFoundException , thrown by the
FileInputStream() constructor. These make the method a bit longer,
but conceptually they belong in this method.
JAVA PROGRAMMING TIP Thefinally Block. In coding a
binary read loop, the try block is exited as soon as the EOFException
is raised. Therefore, the close() statement must be placed in the
finally clause, which is executed after the catch clause.
JAVA EFFECTIVE DESIGN Nested Try/Catch. Nested try blocks
must be used to perform binary I/O correctly. The outer block
encapsulates statements that throw IOException s. The inner block
encapsulates the read loop and catches the EOFException . No
particular action need be taken when the EOFException is caught.
SECTION 11.5 •Example: Reading and Writing Binary Files 541
SELF-STUDY EXERCISE
EXERCISE 11.5 Identify the error in the following method, which is
supposed to read a binary ﬁle of ints from a DataInputStream :
☛ ✟
public void r e a d I n t e g e r s ( DataInputStream inStream ) {
t r y{
while (true ){
i n t num = inStream . readInt ( ) ;
System . out . p r i n t l n (num ) ;
}
inStream . c l o s e ( ) ;
}catch ( EOFException e ) {
}catch ( IOException e ) {
}
}// r e a d I n t e g e r s
✡ ✠
11.5.3 The BinaryIO Application
Given the methods we wrote in the previous section, we can now specify
the overall design of the BinaryIO class (Fig. 11.23). The program sets
up the same interface we used in the text ﬁle example (Fig. 11. 24). It al-
lows the user to specify the name of a data ﬁle to read or write. One button
allows the user to write random employee records to a binary ﬁ le, and the
other allows the user to display the contents of a ﬁle in a JTextArea . The
BinaryIO program in Figure 11.25 incorporates both readRecords()+BinaryIO()
-readRecords()
-writeRecords()
+actionPerformed()
+main()-display : JTextArea
-read : JButton
-write : JButton
-prompt : JLabelBinaryIO+actionPerformed()«interface»
ActionListenerJFrame
FIGURE 11.23 Design of the
BinaryIO class.andwriteRecords() into a complete Java program.
FIGURE 11.24 A program to read
and write binary ﬁles.11.5.4 Abstracting Data from Files
It’s important to recognize that the method to read a binary ﬁl e must ex-
actly match the order of the write and read statements of the m ethod that
wrote the binary ﬁle. For example, if the ﬁle contains record s that consist
of aString followed by an int followed by a double , then they must
be written by a sequence consisting of
☛ ✟
writeUTF ( ) ;
w r i t e I n t ( ) :
writeDouble ( ) ;
✡ ✠
And they must thereafter be read by the sequence of
☛ ✟
readUTF ( ) ;
readInt ( ) :
readDouble ( ) ;
✡ ✠
Attempting to do otherwise would make it impossible to inter pret the data
in the ﬁle.
This point should make it evident why (non-Java) binary ﬁles are not
portable whereas text ﬁles are. With text ﬁles, each charact er consists of Portability
8 bits, and each 8-bit chunk can be interpreted as an ASCII char acter. So
542 CHAPTER 11 •Files and Streams: Input/Output Techniques
☛ ✟
import javax . swing . ∗; // S w i n g c o m p o n e n t s
import java . awt . ∗;
import java . io . ∗;
import java . awt . event . ∗;
public c l a s s BinaryIO extends JFrame implements ActionListener {
private JTextArea display = new JTextArea ( ) ;
private JButton read = new JButton ( ”Read Records From F i l e ” ) ,
write = new JButton ( ” Generate Random Records ” ) ;
private J T e x t F i e l d nameField = new J T e x t F i e l d ( 1 0 ) ;
private JLabel prompt = new JLabel ( ” Filename : ” , JLabel . RIGHT ) ;
private JPanel commands = new JPanel ( ) ;
public BinaryIO ( ) {
super (” BinaryIO Demo” ) ; // S e t w i n d o w t i t l e
read . addActionListener ( t h i s ) ;
write . addActionListener ( t h i s ) ;
commands . setLayout ( new GridLayout ( 2 , 2 , 1 , 1 ) ) ; // C o n t r o l p a n e l
commands . add ( prompt ) ;
commands . add ( nameField ) ;
commands . add ( read ) ;
commands . add ( write ) ;
display . setLineWrap ( true ) ;
t h i s . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
t h i s . getContentPane ( ) . add ( ”North” , commands ) ;
t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( display ) ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , display ) ;
}// B i n a r y I O ( )
private void readRecords ( S t r i n g fileName ) {
t r y{
DataInputStream inStream // O p e n s t r e a m
=new DataInputStream ( new FileInputStream ( fileName ) ) ;
display . s e t T e x t ( ”Name Age Pay \n”) ;
t r y{
while (true ){ // I n f i n i t e l o o p
S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d
i n t age = inStream . readInt ( ) ;
double pay = inStream . readDouble ( ) ;
display . append (name + ” ” + age + ” ” + pay + ”\n”) ;
}// w h i l e
}catch ( EOFException e ) { // U n t i l EOF e x c e p t i o n
}f i n a l l y {
inStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}
}catch ( FileNotFoundException e ) {
display . s e t T e x t ( ”IOERROR : F i l e NOT Found : ” + fileName + ”\n”) ;
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}
}// r e a d R e c o r d s ( )
✡ ✠
Figure 11.25: Part I of the BinaryIO class, which illustrates simple input
and output from a binary ﬁle.
SECTION 11.5 •Example: Reading and Writing Binary Files 543
☛ ✟
private void writeRecords ( S t r i n g fileName ) {
t r y{
DataOutputStream outStream // O p e n s t r e a m
=new DataOutputStream ( new FileOutputStream ( fileName ) ) ;
for (i n t k = 0 ; k <5 ; k++) {// O u t p u t 5 d a t a r e c o r d s
S t r i n g name = ”Name” + k ; // o f name , a g e , p a y r a t e
outStream . writeUTF ( ”Name” + k ) ;
outStream . w r i t e I n t ( ( i n t) ( 2 0 + Math . random ( ) ∗2 5 ) ) ;
outStream . writeDouble ( 5 . 0 0 + Math . random ( ) ∗1 0 ) ;
}// f o r
outStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( IOException e ) {
display . s e t T e x t ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}
}// w r i t e R e c o r d s ( )
public void actionPerformed ( ActionEvent evt ) {
S t r i n g fileName = nameField . getText ( ) ;
i f( evt . getSource ( ) == read )
readRecords ( fileName ) ;
else
writeRecords ( fileName ) ;
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
BinaryIO bio = new BinaryIO ( ) ;
bio . s e t S i z e ( 4 0 0 , 2 0 0 ) ;
bio . s e t V i s i b l e ( true ) ;
bio . addWindowListener ( new WindowAdapter ( ) {// Q u i t
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ;
}
}) ;
}// m a i n ( )
}// B i n a r y I O
✡ ✠
Figure 11.25: ( continued ) TheBinaryIO class, Part II.
even though a text ﬁle consists of a long sequence of 0’s and 1’ s, we know
how to ﬁnd the boundaries between each character. That’s why any text
editor can read a text ﬁle, no matter what program created it.
On the other hand, binary ﬁles are also just a long sequence of 0 ’s and
1’s, but we can’t tell where one data element begins and anoth er one ends.
For example, the 64-bit sequence
☛ ✟
010100110011001001010100110011000
010100110011001011010100110011000
✡ ✠
could represent two 32-bit ints or two 32-bit float s or one 64-bit
double or four 16-bit char s or a single String of 8 ASCII characters.
544 CHAPTER 11 •Files and Streams: Input/Output Techniques
We can’t tell what data we have unless we know exactly how the d ata
were written.
JAVA DEBUGGING TIP Interpreting Binary Data. The fact that you
can read the data in a binary ﬁle is no guarantee that you are
interpreting it correctly. To interpret it correctly, you m ust read it the
same way it was written.
JAVA EFFECTIVE DESIGN Data Abstraction. Binary data are
“raw.” They have no inherent structure. It is only the program s that
read and write the data that provide them with structure. A st ring of
64 0’s and 1’s can be interpreted as two ints or one long or even as
some kind of object, so an int,long or an object is an abstraction
imposed upon the data by the program.
11.6 Object Serialization: Reading and Writing
Objects
The examples in the previous sections showed how to perform I/ O op-
erations on simple binary data or text. The java.io package also pro-
vides methods for reading and writing objects, a process know n as ob-
ject serialization . Objects can be converted into a sequence of bytes, or
serialized , by using the ObjectOutputStream class, and they can be de-
serialized , or converted from bytes into a structured object, by using th e
ObjectInputStream class (Fig. 11.26). Despite the complexity of the
serialization/deserialization processes, the methods in these classes make
the task just as easy as reading and writing primitive data.+writeObject(in o : Object)ObjectOutputStream
+readObject() : ObjectObjectInputStreamOutputStream
InputStream
FIGURE 11.26 Classes used for
performing I/O on objects.To illustrate object serialization, let’s begin by deﬁning a Student class
(Fig. 11.27). In order to serialize an object, it must be a membe r of a class
that implements the Serializable interface. The Serializable inter-
face is a marker interface , an interface that doesn’t deﬁne any methods or
constants but just serves to designate whether an object can be serialized
or not.
TheStudent class contains its own I/O methods, readFromFile()
andwriteToFile() . This is an appropriate object-oriented design. The
Student class encapsulates all the relevant information needed to r ead
and write its data.
JAVA EFFECTIVE DESIGN I/O Design. If an object is going to be
input and output to and from ﬁles, it should deﬁne its own I/O
methods. An object contains all the relevant information nee ded to
perform I/O correctly.
Note the deﬁnition of the writeToFile() method, which performs
the output task. This method’s FileOutputStream parameter is used
to create an ObjectOutputStream , whose writeObject() method
Object serialization
SECTION 6 •Object Serialization 545
☛ ✟
import java . io . ∗;
public c l a s s Student implements S e r i a l i z a b l e {
private S t r i n g name ;
private i n t year ;
private double gpa ;
public Student ( ) {}
public Student ( S t r i n g nameIn , i n t yr , double gpaIn ) {
name = nameIn ;
year = yr ;
gpa = gpaIn ;
}
public void writeToFile ( FileOutputStream outStream )
throws IOException {
ObjectOutputStream ooStream = new ObjectOutputStream ( outStream ) ;
ooStream . writeObject ( t h i s ) ;
ooStream . f l u s h ( ) ;
}// w r i t e T o F i l e ( )
public void readFromFile ( FileInputStream inStream )
throws IOException , ClassNotFoundException {
ObjectInputStream oiStream = new ObjectInputStream ( inStream ) ;
Student s = ( Student ) oiStream . readObject ( ) ;
t h i s . name = s . name ;
t h i s . year = s . year ;
t h i s . gpa = s . gpa ;
}// r e a d F r o m F i l e ( )
public S t r i n g t o S t r i n g ( ) {
return name + ”\t ”+ year + ”\t ”+ gpa ;
}
}// S t u d e n t
✡ ✠
Figure 11.27: The serializable Student class.
writes the object into the ﬁle. To output a Student object, we merely
invoke the writeObject() method. This method writes out the current
values of all the object’s public and private ﬁelds. In this cas e, the method
would write a String for the object’s name , anint for the object’s year ,
and adouble for the object’s gpa.
Although our example doesn’t require it, the writeObject() method
can also handle ﬁelds that refer to other objects. For example , suppose our
Student object provided a ﬁeld for courses that contained a reference
to an array of objects, each of which described a course the stu dent has
taken. In that case, the writeObject() method would serialize the array
and all its objects (assuming they are serializable). Thus, w hen a complex
object is serialized, the result would be a complex structure that contains
all the data linked to that root object.
546 CHAPTER 11 •Files and Streams: Input/Output Techniques
Object deserialization, as shown in the readFromFile() method,
is simply the reverse of the serialization process. The readObject()Object deserialization
method reads one serialized object from the ObjectInputStream . Its
result type is Object , so it is necessary to cast the result into the proper
type. In our example we use a local Student variable to store the object
as it is input. We then copy each ﬁeld of the local object to this object.
Note that the readFromFile() method throws both the IOException
andClassNotFoundException . AnIOException will be generated if
the ﬁle you are attempting to read does not contain serialize d objects of the
correct type. Objects that can be input by readObject() are those that
were output by writeObject() . Thus, just as in the case of binary I/O,
it is best to design an object’s input and output routines toge ther so that
they are compatible. The ClassNotFoundException will be thrown if
theStudent class cannot be found. This is needed to determine how to
deserialize the object.
JAVA PROGRAMMING TIP Object Serialization. Java’s
serialization classes, ObjectOutputStream and
ObjectInputStream , should be used whenever an object needs to
be input or output from a stream.
11.6.1 The ObjectIO Class
Given the Student class, let’s now write a user interface that can read
and write Student objects. We can use the same interface we used in the
BinaryIO program. The only things we need to change are the write-
Records() andreadRecords() methods. Everything else about this
program will be exactly the same as in BinaryIO .
Figure 11.28 provides the full implementation of the ObjectIO class.
Note that the writeRecords() method will still write ﬁve random
records to the data ﬁle. The difference in this case is that we will call the
Student.writeToFile() method to take care of the actual output op-
erations. The revised algorithm will create a new Student object, using
randomly generated data for its name, year, and GPA and then i nvoke its
writeToFile() to output its data. Note how a FileOutputStream is
created and passed to the Student.writeToFile() method.
ThereadRecords() method (Fig. 11.28, Part II) will read data from
a ﬁle containing serialized Student objects. To do so, it ﬁrst cre-
ates aStudent object and then invokes its readFromFile() method,
passing it a FileInputStream . Note how the FileInputStream is
created and, unlike in BinaryIO , the inner try block is exited by an
IOException rather than an EOFException .
SECTION 6 •Java Library : JFileChooser 547
☛ ✟
import javax . swing . ∗; // S w i n g c o m p o n e n t s
import java . awt . ∗;
import java . io . ∗;
import java . awt . event . ∗;
public c l a s s ObjectIO extends JFrame implements ActionListener {
private JTextArea display = new JTextArea ( ) ;
private JButton read = new JButton ( ”Read From F i l e ” ) ,
write = new JButton ( ” Write to F i l e ” ) ;
private J T e x t F i e l d nameField = new J T e x t F i e l d ( 1 0 ) ;
private JLabel prompt = new JLabel ( ” Filename : ” , JLabel . RIGHT ) ;
private JPanel commands = new JPanel ( ) ;
public ObjectIO ( ) {
super (” ObjectIO Demo” ) ; // S e t w i n d o w t i t l e
read . addActionListener ( t h i s ) ;
write . addActionListener ( t h i s ) ;
commands . setLayout ( new GridLayout ( 2 , 2 , 1 , 1 ) ) ;
commands . add ( prompt ) ; // C o n t r o l p a n e l
commands . add ( nameField ) ;
commands . add ( read ) ;
commands . add ( write ) ;
display . setLineWrap ( true ) ;
t h i s . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
t h i s . getContentPane ( ) . add ( ”North” ,commands ) ;
t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( display ) ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , display ) ;
}// O b j e c t I O
public void actionPerformed ( ActionEvent evt ) {
S t r i n g fileName = nameField . getText ( ) ;
i f( evt . getSource ( ) == read )
readRecords ( fileName ) ;
else
writeRecords ( fileName ) ;
}// a c t i o n P e r f o r m e d ( )
✡ ✠
Figure 11.28: Part I of the ObjectIO class, which provides an interface to
reading and writing ﬁles of Student s.
SELF-STUDY EXERCISE
EXERCISE 11.6 Given the following deﬁnition, would a binary ﬁle con-
sisting of several SomeObject s be readable by either the BinaryIO or
theObjectIO programs? Explain.
☛ ✟
public c l a s s SomeObject {
private S t r i n g s t r ;
private short n1 ;
private short n2 ;
private long n3 ;
}
✡ ✠
548 CHAPTER 11 •Files and Streams: Input/Output Techniques
☛ ✟
private void readRecords ( S t r i n g fileName ) {
t r y{
FileInputStream inStream = new FileInputStream ( fileName ) ; // O p e n a s t r e a m
display . s e t T e x t ( ”Name\tYear\tGPA\n”) ;
t r y{
while (true ){ // I n f i n i t e l o o p
Student student = new Student ( ) ; // C r e a t e a s t u d e n t i n s t a n c e
student . readFromFile ( inStream ) ; // a n d h a v e i t r e a d a n o b j e c t
display . append ( student . t o S t r i n g ( ) + ”\n”) ; // a n d d i s p l a y i t
}
}catch ( IOException e ) { // U n t i l I O E x c e p t i o n
}
inStream . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( FileNotFoundException e ) {
display . append ( ”IOERROR : F i l e NOT Found : ” + fileName + ”\n”) ;
}catch ( IOException e ) {
display . append ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}catch ( ClassNotFoundException e ) {
display . append ( ”ERROR: Class NOT found ” + e . getMessage ( ) + ”\n”) ;
}
}// r e a d R e c o r d s ( )
private void writeRecords ( S t r i n g fileName ) {
t r y{
FileOutputStream outStream = new FileOutputStream ( fileName ) ; // O p e n s t r e a m
for (i n t k = 0 ; k <5 ; k++) { // G e n e r a t e 5 r a n d o m o b j e c t s
S t r i n g name = ”name” + k ; // Name
i n t year = ( i n t) ( 2 0 0 0 + Math . random ( ) ∗4 ) ; // C l a s s y e a r
double gpa = Math . random ( ) ∗1 2 ; // GPA
Student student = new Student ( name , year , gpa ) ; // C r e a t e t h e o b j e c t
display . append ( ”Output : ” + student . t o S t r i n g ( ) + ”\n”) ; // a n d d i s p l a y i t
student . writeToFile ( outStream ) ; // a n d t e l l i t t o w r i t e d a t a
}// f o r
outStream . c l o s e ( ) ;
}catch ( IOException e ) {
display . append ( ”IOERROR : ” + e . getMessage ( ) + ”\n”) ;
}
}// w r i t e R e c o r d s ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
ObjectIO io = new ObjectIO ( ) ;
io . s e t S i z e ( 4 0 0 , 2 0 0 ) ;
io . s e t V i s i b l e ( true ) ;
io . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// O b j e c t I O
✡ ✠
Figure 11.28: ( continued ) TheObjectIO class, Part II.
SECTION 11.7 •From the Java Library javax.swing.JFileChooser 549
11.7 From the Java Library
javax.swing.JFileChooser
java.sun.com/j2se/1.5.0/docs/api/THEjavax.swing.JFileChooser class is useful for dealing with ﬁles
and directories in a GUI environment. You are probably alrea dy familiar
withJFileChooser s, although you may not have known them by that
name. A JFileChooser provides a dialog box that enables the user to
select a ﬁle and a directory when opening or saving a ﬁle. Figu re 11.30
shows an example.
AJFileChooser is designed primarily to be used in conjunction with
menu-based programs. The JFileChooser class (Fig. 11.29) contains
methods that support the Open File and Save As options which often ap-
pear in GUI applications either in a menu or attached to butto ns. In this
section we provide the basics for using a JFileChooser . Options for
JComponent
+JFileChooser()
+JFileChooser(in currentDirectory : File) 
+JFileChooser(in path : String)
+getCurrentDirectory() : File
+getSelectedFile() : File
+getSelectedFiles() : File[]
+showOpenDialog(in c : Component) : int
+showSaveDialog(in c : Component) : int
+setCurrentDirectory(in dir : File)+APPROVE_OPTION : int
+CANCEL_OPTION : intJFileChooser
FIGURE 11.29 The
javax.swing.JFileChooser
class.opening a ﬁle or saving a ﬁle can be added to the kind of GUI appl ications
that we encountered earlier in the text by using buttons. In Ch apter 13, we
will discuss the use of JMenu s which will provide a more natural means
of using the JFileChooser dialogs.
AJFileChooser is not itself the dialog window, but rather the object
that manages the dialog. After creating a JFileChooser instance, its
showOpenDialog() orshowSaveDialog() methods are used to open
a dialog window. Note that these methods require a Component parame-
ter, usually a JFrame or aJApplet . Thus, JFileChooser s can be used
only in GUI applications and applets.
To illustrate how to use a JFileChooser , let’s consider the case where
the user has selected an Open File menu item or clicked a button labeled
Open File . In this case, executing the following code will cause an “Ope n
File” dialog to appear:
☛ ✟
JFileChooser chooser = new JFileChooser ( ) ;
i n t r e s u l t = chooser . showOpenDialog ( t h i s ) ;
i f( r e s u l t == JFileChooser . APPROVE OPTION) {
F i l e f i l e = chooser . g e t S e l e c t e d F i l e ( ) ;
// I n s e r t c o d e h e r e t o r e a d d a t a f r o m f i l e
S t r i n g fileName = f i l e . getName ( ) ;
display . s e t T e x t ( ”You s e l e c t e d ” + fileName ) ;
}else
display . s e t T e x t ( ”You c a n c e l l e d the f i l e dialog ” ) ;
✡ ✠
We begin by creating a JFileChooser and then telling it to showOpen- Opening a ﬁle
Dialog() . If we were saving a ﬁle rather than opening one, we would
tell it to showSaveDialog() . In either case, a dialog window will pop
up on the screen. The dialog assists the user in navigating th rough the ﬁle
system and selecting a ﬁle (Fig. 11.30).
The dialog contains two buttons, one labeled Open and the oth er la-
beled Cancel. If the user selects a ﬁle, that choice will corre spond to
APPROVE OPTION . If the user cancels the dialog, that will correspond to
CANCEL OPTION . After opening a dialog, the code should check which
option resulted. In this case, if the user opened a ﬁle, the cod e gets a
reference to the ﬁle and then simply uses that to print the ﬁle ’s path name
550 CHAPTER 11 •Files and Streams: Input/Output Techniques
Figure 11.30: The Open File dialog
window.
to a text area named display . In an actual application, code would be
inserted at that spot which uses the ﬁle reference to read dat a from the
ﬁle.
11.8 Using File Data in Programs
This chapter’s examples have provided explicit details for several ways
of writing data to ﬁles and reading data from ﬁles. In actual pr ograms,
deciding if and how ﬁles might be useful in the program are wor ked out
as part of the design process. Choosing between text ﬁles, bi nary ﬁles, and
reading and writing objects is part of this process.
To illustrate how we can apply what we’ve learned about ﬁle I/O , let’s
modify the WordGuess class (which is listed in Fig. 8.27) so that it reads
a list of possible words for players to guess from a ﬁle. The Ch apter 8
version of the class contains a method, getSecretWord() , which uses modifying WordGuess
aswitch statement to randomly choose and return a word from a ﬁxed
list of ten words. Reading the words from a text ﬁle would allo w a user
to modify the list of possible words by adding or changing wor ds without
needing to recompile the program.
Let’s modify the WordGuess class in three ways:
1. adding two new instance variables, an array of type String and a
variable to store the size of the array;
2. adding code at the beginning of the class’s constructor to read words
from the ﬁle and store them in the array;
3. rewrite the getSecretWord() method so that it randomly chooses
a word from the array.
Let us ﬁrst choose descriptive names for declaring the two ne w instance New instance variables
variables:
☛ ✟
private S t r i n g [ ] wordArray ;
private i n t a r r a y S i z e ;
✡ ✠
Note that it will be useful to store the number of words in the ﬁ le
in its ﬁrst line so that this information can be used to alloca te mem-
ory for the array. For example, let us assume the text ﬁle will be
SECTION 11.8 •Using File Data in Programs 551
named secretwords.txt , it will be located in the same directory as the
WordGuess class, it will have the number of words in the ﬁle as its ﬁrst
line, and it will have a single word per line after that. Thus, a small ﬁle Format for the text ﬁle
might look like:
☛ ✟
3
STREAMS
CONDUIT
DIALOGS
✡ ✠
We can use the body of the readTextFile() method of the TextIO
class as a model for the Java code that needs to be added to the
WordGuess constructor. Pseudocode for this code will look like: Code to add to constructor
☛ ✟
Use f i l e name to open a BufferedReader stream
Read f i r s t l i n e and convert to an i n t e g e r
Store the i n t e g e r as the s i z e of the array
A l l o c a t e memory for the array
Read second l i n e of f i l e
While a word i s read
Store the word in the next array element
Read next l i n e of f i l e
Close the BufferedReader stream
✡ ✠
When this pseudocode is translated into Java and inserted int o a
try-catch statement we get the code fragment in Figure 11.31.
☛ ✟
t r y{
FileReader f r = new FileReader ( ” secretwords . t x t ” ) ;
BufferedReader inStream
=new BufferedReader ( f r ) ;
S t r i n g l i n e = inStream . readLine ( ) ;
a r r a y S i z e = I n t e g e r . p a r s e I n t ( l i n e ) ;
wordArray = new S t r i n g [ a r r a y S i z e ] ;
l i n e = inStream . readLine ( ) ;
i n t k = 0 ;
while ( ( l i n e != null ) && ( k <a r r a y S i z e ) ) {
wordArray [ k ] = l i n e ;
l i n e = inStream . readLine ( ) ;
k++;
}// w h i l e
inStream . c l o s e ( ) ;
}catch ( FileNotFoundException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// c a t c h
✡ ✠
Figure 11.31: Code added at beginning of the WordGuess constructor.
The new getSecretWord() method merely needs to generate a
random array index and return the corresponding array eleme nt: New code for getSecretWord
552 CHAPTER 11 •Files and Streams: Input/Output Techniques
☛ ✟
private S t r i n g getSecretWord ( ) {
i n t num = ( i n t) ( Math . random ( ) ∗a r r a y S i z e ) ;
return wordArray [num ] ;
}// g e t S e c r e t W o r d ( )
✡ ✠
The only other modiﬁcation that is needed for to complete new
WordGuess class is to add an initial import java.io. *;statement so
that the ﬁle IO classes can be accessed.
The earlier examples in this chapter can be used as models to e nhance
numerous practical applications. GUI applications that in volve a user’s
choice to load data from a ﬁle or save data in a ﬁle should make u se of the
JFileChooser dialogs to initiate the ﬁle operations.
Special Topic: Databases and Personal Privacy
During a typical day we all come in contact with lots of electr onic
databases that store information about us. If you use a superm arket dis-
count card, every purchase you make is logged against your na me in the
supermarket’s database. When you use your bank card at the ATM ma-
chine, your ﬁnancial transaction is logged against your acc ount. When
you charge gasoline or buy dinner, those transactions are lo gged against
your credit card account. If you visit the doctor or dentist, a detailed
record of your visit is transmitted to your medical insuranc e company’s
database. If you receive a college loan, detailed ﬁnancial in formation
about you is entered into several different credit service b ureaus. And
so on.
Should we be worried about how this information is used? Many pri-
vacy advocates say yes. With the computerization of medical records,
phone records, ﬁnancial transactions, driving records, an d many other
records, there is an enormous amount of personal informatio n held in
databases. At the same time, there are pressures from a numbe r of sources
for access to this information. Law-enforcement agencies w ant to use this
information to monitor individuals. Corporations want to u se it to help
them market their products. Political organizations want t o use it to help
them market their candidates.
Recently there has been pressure from government and indust ry in the
United States to use the social security number (SSN) as a uni que identi-
ﬁer. Such an identiﬁer would make it easy to match personal in formation
across different databases. Right now, the only thing your b ank records,
medical records, and supermarket records may have in common is your
name, which is not a unique identiﬁer. If all online databases were based
on your SSN, it would be much simpler to create a complete proﬁ le. While
this might improve services and reduce fraud and crime, it mi ght also
pose a signiﬁcant threat to our privacy.
The development of online databases serve many useful purpo ses.
They help ﬁght crime and reduce the cost of doing business. Th ey help
improve government and commercial services on which we have come
to depend. On the other hand, databases can be and have been mi sused.
They can be used by unauthorized individuals or agencies or i n unautho-
CHAPTER 11 •Chapter Summary 553
rized ways. When they contain inaccurate information, they c an cause
personal inconvenience or even harm.
There are a number of organizations that have sprung up to add ress
the privacy issues raised by online databases. If you’re inte rested in learn-
ing more about this issue, a good place to start would be the We b site
maintained by the Electronic Privacy Information Center (EP IC) at
☛ ✟
http : // w w w. epic . org/
✡ ✠
CHAPTER SUMMARY Technical Terms
absolute path name
binary ﬁle
buffering
database
data hierarchy
directoryend-of-ﬁle character
ﬁeld
ﬁle
ﬁltering
input
object serializationoutput
path
record
relative path name
Unicode Text Format
(UTF)
Summary of Important Points
•Aﬁleis a collection of data stored on a disk. A stream is an object that
delivers data to and from other objects.
•AnInputStream is a stream that delivers data to a program from an
external source—such as the keyboard or a ﬁle. System.in is an exam-
ple of an InputStream . AnOutputStream is a stream that delivers
data from a program to an external destination—such as the scr een or
a ﬁle.System.out is an example of an OutputStream .
•Data can be viewed as a hierarchy. From highest to lowest, a database
is a collection of ﬁles. A ﬁleis a collection of records. A record is a
collection of ﬁelds. A ﬁeld is a collection of bytes. A byte is a collection
of 8 bits. A bitis one binary digit, either 0 or 1.
•Abinary ﬁle is a sequence of 0s and 1s that is interpreted as a sequence
of bytes. A text ﬁle is a sequence of 0s and 1s that is interpreted as a
sequence of characters. A text ﬁle can be read by any text edit or, but
a binary ﬁle cannot. InputStream andOutputStream are abstract
classes that serve as the root classes for reading and writin g binary data.
Reader andWriter serve as root classes for text I/O.
•Buffering is a technique in which a buffer , a temporary region of mem-
ory, is used to store data while they are being input or output .
•A text ﬁle contains a sequence of characters divided into lin es by the
\ncharacter and ending with a special end-of-ﬁle character.
•The standard algorithm for performing I/O on a ﬁle consists of three
steps: (1) Open a stream to the ﬁle, (2) perform the I/O, and (3) close
the stream.
554 CHAPTER 11 •Files and Streams: Input/Output Techniques
•Designing effective I/O routines answers two questions: (1) What
streams should I use to perform the I/O? (2) What methods should I
use to do the reading or writing?
•To prevent damage to ﬁles when a program terminates abnormal ly,
streams should be closed when they are no longer needed.
•Most I/O operations generate an IOException that should be caught
in the I/O methods.
•Text input uses a different technique to determine when the e nd of a
ﬁle has been reached. Text input methods return null or-1when
they attempt to read the special end-of-ﬁle character. Bina ry ﬁles
don’t contain an end-of-ﬁle character, so binary read metho ds throw
anEOFException when they attempt to read past the end of the ﬁle.
•Thejava.io.File class provides methods that enable a program to
interact with a ﬁle system. Its methods can be used to check a ﬁl e’s
attributes, including its name, directory, and path.
•Streams can be joined together to perform I/O. For example, a
DataOutputStream and aFileOutputStream can be joined to per-
form output to a binary ﬁle.
•A binary ﬁle is “raw” in the sense that it contains no markers w ithin it
that allow you to tell where one data element ends and another begins.
The interpretation of binary data is up to the program that re ads or
writes the ﬁle.
•Object serialization is the process of writing an object to an o utput
stream. Object deserialization is the reverse process of rea ding a serial-
ized object from an input stream. These processes use the java.io.-
ObjectOutputStream andjava.io.ObjectInputStream classes.
•TheJFileChooser class provides a dialog box that enables the user
to select a ﬁle and directory when opening or saving a ﬁle.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 11.1 Because FileWriter contains a constructor that takes a ﬁle
name argument, FileWriter(String) , it can be used with PrintWriter to
perform output to a text ﬁle:
☛ ✟
P r i n t W r i t e r outStream = // C r e a t e o u t p u t s t r e a m
new P r i n t W r i t e r ( new F i l e W r i t e r ( fileName ) ) ; // O p e n f i l e
outStream . p r i n t ( display . getText ( ) ) ; // D i s p l a y t e x t
outStream . c l o s e ( ) ; // C l o s e o u t p u t s t r e a m
✡ ✠
SOLUTION 11.2 An empty ﬁle doesn’t affect this loop. If the ﬁle is empty, it
will print a null line. The test line != null , should come right after the
readLine() , as it does in the while loop.
SOLUTION 11.3 This loop won’t work on an empty text ﬁle. In that case, ch
would be set to −1, and the attempt to cast it into a char would cause an error.
CHAPTER 11 •Exercises 555
SOLUTION 11.4
☛ ✟
public void g e t F i l e A t t r i b u t e s ( S t r i n g fileName ) {
F i l e f i l e = new F i l e ( fileName ) ;
System . out . p r i n t l n ( filename ) ;
System . out . p r i n t l n ( ” absolute path : ”
+ f i l e . getAbsolutePath ( ) ) ;
System . out . p r i n t l n ( ” length : ” + f i l e . length ( ) ) ;
i f( f i l e . i s D i r e c t o r y ( ) )
System . out . p r i n t l n ( ” Directory ” ) ;
else
System . out . p r i n t l n ( ”Not a Directory ” ) ;
}// g e t F i l e A t t r i b u t e s ( )
✡ ✠
SOLUTION 11.5 TheinStream.close() statement is misplaced in read-
Integers() . By placing it inside the same try/catch block as the read loop, it
will get skipped and the stream will not be closed. The EOFException should be
caught in a separate try/catch block from other exceptions, and it should just
cause the read loop to exit.
SOLUTION 11.6 Yes, a binary ﬁle containing several SomeObjects would be
“readable” by the BinaryIO program because the program will read a String
followed by 64 bytes. However, BinaryIO would misinterpret the data, be-
cause it will assume that n1andn2together comprise a single int, andn3
(64 bits) will be interpreted as a double . A ﬁle of SomeObject s could not be
read by the ObjectIO program, because SomeObject does not implement the
Serializable interface.
EXERCISES
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 11.1 Explain the difference between each of the following pairs of
terms:
a.System.in andSystem.out .
b.Fileand directory .
c.Buffering and ﬁltering .
d.Absolute and relative path name .
e.Input stream and output stream .f.Fileand database .
g.Record and ﬁeld.
h.Binary ﬁle and text ﬁle .
i.Directory and database .
EXERCISE 11.2 Fill in the blanks.
a. Unlike text ﬁles, binary ﬁles do not have a special character.
b. In Java, the String array parameter in the main() method is used for
.
c. ﬁles are portable and platform independent.
d. A ﬁle created on one computer can’t be read by another
computer.
EXERCISE 11.3 Arrange the following kinds of data into their correct hierar-
chical relationships: bit,field ,byte ,record ,database ,file ,String ,
char .
556 CHAPTER 11 •Files and Streams: Input/Output Techniques
EXERCISE 11.4 In what different ways can the following string of 32 bits be
interpreted?
☛ ✟
00010101111000110100000110011110
✡ ✠
EXERCISE 11.5 When reading a binary ﬁle, why is it necessary to use an inﬁnit e
loop that’s exited only when an exception occurs?
EXERCISE 11.6 Is it possible to have a text ﬁle with 10 characters and 0 lines?
Explain.
EXERCISE 11.7 In reading a ﬁle, why is it necessary to attempt to read from the
ﬁle before entering the read loop?
EXERCISE 11.8 When designing binary I/O, why is it especially important to
design the input and output routines together?
EXERCISE 11.9 What’s the difference between ASCII code and UTF code?
EXERCISE 11.10 Could the following string of bits possibly be a Java object?
Explain.
☛ ✟
00010111000111101010101010000111001000100
11010010010101010010101001000001000000111
✡ ✠
EXERCISE 11.11 Write a method that could be added to the TextIO program to
read a text ﬁle and print all lines containing a certain word. Th is should be a void
method that takes two parameters: The name of the ﬁle and the word to search
for. Lines not containing the word should not be printed.
EXERCISE 11.12 Write a program that reads a text ﬁle and reports the number
of characters and lines contained in the ﬁle.
EXERCISE 11.13 Modify the program in the previous exercise so that it also
counts the number of words in the ﬁle. ( Hint : TheStringTokenizer class might
be useful for this task.)
EXERCISE 11.14 Modify the ObjectIO program so that it allows the user to
designate a ﬁle and then input Student data with the help of a GUI. As the user
inputs data, each record should be written to the ﬁle.
EXERCISE 11.15 Write a program that will read a ﬁle of ints into memory, sort
them in ascending order, and output the sorted data to a second ﬁle .
EXERCISE 11.16 Write a program that will read two ﬁles of ints, which are
already sorted into ascending order, and merge their data. For e xample, if one ﬁle
contains 1, 3, 5, 7, 9, and the other contains 2, 4, 6, 8, 10, then th e merged ﬁle should
contain 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.
EXERCISE 11.17 Suppose you have a ﬁle of data for a geological survey. Each
record consists of a longitude, a latitude, and an amount of rainfal l, all represented
bydouble s. Write a method to read this ﬁle’s data and print them on the scre en,
one record per line. The method should be void and it should take the name of
the ﬁle as its only parameter.
EXERCISE 11.18 Suppose you have the same data as in the previous exercise.
Write a method that will generate 1,000 records of random data and write them to
a ﬁle. The method should be void and should take the ﬁle’s name as its parameter.
Assume that longitudes have values in the range +/−0 to 180 degrees, latitudes
have values in the range +/−0 to 90 degrees, and rainfalls have values in the
range 0 to 20 inches.
CHAPTER 11 •Exercises 557
EXERCISE 11.19 Design and write a ﬁle copy program that will work for either
text ﬁles or binary ﬁles. The program should prompt the user for the names of
each ﬁle and copy the data from the source ﬁle into the destination ﬁle. It should
not overwrite an existing ﬁle, however. ( Hint : Read and write the ﬁle as a ﬁle of
byte .)
EXERCISE 11.20 Design a class, similar to Student , to represent an Address .
It should consist of street, city, state, and zip code and should con tain its own
readFromFile() andwriteToFile() methods.
EXERCISE 11.21 Using the class designed in the previous exercise, modify the
Student class so that it contains an Address ﬁeld. Modify the ObjectIO pro-
gram to accommodate this new deﬁnition of Student and test your program.
EXERCISE 11.22 Write a program called Directory , which provides a listing
of any directory contained in the current directory. This program should prompt
the user for the name of the directory. It should then print a listi ng of that directory.
The listing should contain the following information: The full pat h name of the
directory, and then include the ﬁle name, length, and last modi ﬁed date, and a
read/write code for each ﬁle. The read/write code should be an rif the ﬁle is
readable and a wif the ﬁle is writeable, in that order. Use a “-” to indicate not
readable or not writeable. For example, a ﬁle that is readable bu t not writable will
have the code r-. Here’s an example listing:
☛ ✟
L i s t i n g for d i r e c t o r y : myfiles
name length modified code
index . html 548 129098 rw
index . g i f 78 129190 rw
me. html 682 128001 r −
private . t x t 1001 129000 −−
✡ ✠
Note that the File.lastModified() returns a long , which gives the modiﬁ-
cation time of the ﬁle. This number can’t easily be converted into a date, so just
report its value.
EXERCISE 11.23 Challenge: Modify the OneRowNimGUI class that is listed in
Chapter 4’s Figure 4-25 so that the user can save the position of th e game to a ﬁle
or open and read a game position from a ﬁle. You should add two new JButton s
to the GUI interface. Use the object serialization example as a model for your input
and output streams.
EXERCISE 11.24 Challenge: In Unix systems, there’s a program named grep
that can list the lines in a text ﬁle containing a certain strin g. Write a Java version
of this program that prompts the user for the name of the ﬁle and the s tring to
search for.
EXERCISE 11.25 Challenge: Write a program in Java named Copy to copy
one ﬁle into another. The program should prompt the user for two ﬁle n ames,
filename1 andfilename2 . Both filename1 andfilename2 must exist or
the program should throw a FileNotFoundException . Although filename1
must be the name of a ﬁle (not a directory), filename2 may be either a ﬁle or a
directory. If filename2 is a ﬁle, then the program should copy filename1 to
filename2 . Iffilename2 is a directory, then the program should simply copy
filename1 intofilename2 . That is, it should create a new ﬁle with the name
filename1 inside the filename2 directory, copy the old ﬁle to the new ﬁle, and
then delete the old ﬁle.
558 CHAPTER 11 •Files and Streams: Input/Output Techniques
OBJECTIVES
After studying this chapter, you will
•Understand the concept of recursion.
•Know how to use recursive programming techniques.
•Have a better understanding of recursion as a problem-solvin g technique.
OUTLINE
Outline
12.1 Introduction
12.2 Recursive Deﬁnition
12.3 Recursive String Methods
12.4 Recursive Array Processing
12.5 Example: Drawing (Recursive) Fractals
12.6 Object-Oriented Design: Tail Recursion
12.7 Object-Oriented Design: Recursion or Iteration?
Special Topic: Exploring the Mandelbrot Set
12.8 From the Java Library: javax.swing.JComboBox
Java Language Summary
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 12
Recursive Problem Solving
559
560 CHAPTER 12 •Recursive Problem Solving
12.1 Introduction
The pattern in Figure 12.1 is known as the Sierpinski gasket. Its overall
shape is that of an equilateral triangle. But notice how insi de the outer
triangle there are three smaller triangles that are similar to the overall pat-
tern. And inside each of those are three even smaller triangl es, and so
on. The Sierpinski gasket is known as a fractal because when you divide it
up, you end up with a smaller version of the overall pattern. T he overall
gasket pattern is repeated over and over, at smaller and smal ler scales,
throughout the ﬁgure.
FIGURE 12.1 The Sierpinski
gasket.How would you draw this pattern? If you try to use some kind of
nested loop structure, you’ll ﬁnd that it is very challengin g. It can be done
using loops, but it isn’t easy. On the other hand, if you use an approach
known as recursion , this problem is much easier to solve. It’s a little bit like
the representation issue we discussed in Chapter 5. Your abi lity to solve
a problem often depends on how you represent the problem. Rec ursion
gives you another way to approach problems that involve repe tition, such
as the problem of drawing the Sierpinski gasket.
The main goal of this chapter is to introduce recursion as bot h a
problem-solving technique and as alternative to loops (whi ch we dis-
cussed in Chapter 6) for implementing repetition. We begin w ith the no-
tion of a recursive deﬁnition , a concept used widely in mathematics and
computer science. We then introduce the idea of a recursive method , which
is the way recursion is implemented in a program.
Recursion is a topic that is taken up in considerable detail i n upper-
level computer science courses, so our goal here is mainly to introduce
the concept and give you some idea of its power as a problem-so lving
approach. To illustrate recursion, we use a number of simple examples
throughout the chapter. One risk in using simple examples, t hough, is
that you might be tempted to think that recursion is only good for “toy
problems.” Nothing could be further from the truth. Recursi on is often
used for some of the most difﬁcult algorithms. Some of the exe rcises at
the end of the chapter are examples of more challenging probl ems.
12.1.1 Recursion as Repetition
Arecursive method is a method that calls itself. An iterative method is
a method that uses a loop to repeat an action. In one sense, recursion is
an alternative to the iterative (looping) control structur es we studied in
Chapter 6. In this sense, recursion is just another way to repea t an action.
For example, consider the following iterative method for sa ying Iterative method
“Hello” Ntimes:
☛ ✟
public void h e l l o ( i n t N){
for (i n t k = 0 ; k <N; k++)
System . out . p r i n t l n ( ” Hello ” ) ;
}// h e l l o ( )
✡ ✠
A recursive version of this method would be deﬁned as follows : Recursive method
SECTION 12.1 •Introduction 561
☛ ✟
public void h e l l o ( i n t N){
i f(N>0)\verb !{!
System . out . p r i n t l n ( ” Hello ” ) ;
h e l l o (N −1 ) ; // R e c u r s i v e c a l l
}// h e l l o ( )
✡ ✠
This method is recursive because it calls itself when Nis greater than 0.
However, note that when it calls itself, it passes N−1as the value for its
parameter. If this method is initially called with Nequal to 5, the follow-
ing is a trace of what happens. The indentations indicate eac h time the
method calls itself:
☛ ✟
h e l l o ( 5 )
P r i n t ” Hello ”
h e l l o ( 4 )
P r i n t ” Hello ”
h e l l o ( 3 )
P r i n t ” Hello ”
h e l l o ( 2 )
P r i n t ” Hello ”
h e l l o ( 1 )
P r i n t ” Hello ”
h e l l o ( 0 )
✡ ✠
Thus, “Hello” will be printed ﬁve times, just as it would be in th e iterative
version of this method.
So, in one sense, recursion is just an alternative to iteratio n. In fact,
there are some programming languages, such as the original v ersions of
LISP and PROLOG, that do not have loop structures. In these lang uages,
allrepetition is done by recursion. In contrast, if a language co ntains
loop structures, it can do without recursion. Anything that can be done
iteratively can be done recursively, and vice versa.
Moreover, it is much less efﬁcient to call a method ﬁve times t han to re-
peat a for loop ﬁve times. Method calls take up more memory tha n loops
and involve more computational overhead —for such tasks as passing pa- Computational overhead
rameters, allocating storage for the method’s local variab les, and return-
ing the method’s results. Therefore, because of its relianc e on repeated
method calls, recursion is often less efﬁcient than iterati on as a way to
code a particular algorithm.
JAVA EFFECTIVE DESIGN Efﬁciency. Iterative algorithms and
methods are generally more efﬁcient than recursive algorit hms that do
the same thing.
562 CHAPTER 12 •Recursive Problem Solving
SELF-STUDY EXERCISES
EXERCISE 12.1 What would be printed if we call the following method
with the expression mystery(0) ?
☛ ✟
public void mystery ( i n t N){
System . out . p r i n t (N + ” ” ) ;
i f(N<= 5)
mystery (N + 1 ) ;
}// m y s t e r y ( )
✡ ✠
What about mystery(100) ?
EXERCISE 12.2 What would be printed if we call the following method
with the expression mystery(5) ?
☛ ✟
public void mystery ( i n t N){
System . out . p r i n t (N + ” ” ) ;
i f(N<= 5)
mystery (N −1 ) ;
}// m y s t e r y ( )
✡ ✠
12.1.2 Recursion as a Problem-Solving Approach
Given that recursion is not really necessary—if a programmin g language
has loops—and is not more efﬁcient than loops, why is it so impo rtant?
The answer is that, in a broader sense, recursion is an effect ive approach
to problem solving. It is a way of viewing a problem. It is mostly in this
sense that we want to study recursion.
Recursion is based on two key problem-solving concepts: divide and
conquer and self-similarity . In recursive problem solving we use the
divide-and-conquer strategy repeatedly to break a big prob lem into a se-
quence of smaller and smaller problems until we arrive at a pr oblem that
is practically trivial to solve.
What allows us to create this series of subproblems is that eac h sub- Subproblems
problem is similar to the original problem—that is, each subp roblem is
just a smaller version of the original problem. Look again at t he task of
saying “Hello” Ntimes. Solving this task involves solving the similar task
of saying “Hello” N−1times, which can be divided into the similar task of
saying “Hello” N−2times. And so on.
The ability to see a problem as being composed of smaller, sel f-similar
problems is at the heart of the recursive approach. And altho ugh you Self-similarity
might not have thought about this before, a surprising numbe r of pro-
gramming problems have this self-similarity characterist ic. Let’s illustrate
these ideas with some simple examples.
JAVA PROGRAMMING TIP Divide and Conquer. Many
programming problems can be solved by dividing them into sma ller,
simpler problems. For recursive solutions, ﬁnding the key t o the
subproblem often holds the solution to the original problem .
SECTION 12.2 •Recursive Deﬁnition 563
12.2 Recursive Deﬁnition
One place you might have already seen recursion is in mathema tics. A
recursive deﬁnition consists of two parts: a recursive part in which the
nth value is deﬁned in terms of the (n−1)st value, and a nonrecursive,
boundary orbase case , which deﬁnes a limiting condition.
12.2.1 Factorial: N!
For example, consider the problem of calculating the factor ial of n—that
is,n! forn≥0. As you may recall, n! is calculated as follows:
☛ ✟
n ! = n ∗( n−1)∗( n−2)∗. . .∗1 ,for n>0
✡ ✠
In addition, 0! is deﬁned as 1. Let’s now look at some examples f or
different values of n:
☛ ✟
4 ! = 4 ∗3∗2∗1 = 24
3 ! = 3 ∗2∗1 = 6
2 ! = 2 ∗1 = 2
1 ! = 1
0 ! = 1
✡ ✠
As these examples suggest, n! can always be calculated in terms of (n−1)!
This relationship might be clearer if we rewrite the previou s calculations
as follows:
☛ ✟
4 ! = 4 ∗3∗2∗1 = 4∗3 ! = 24
3 ! = 3 ∗2∗1 = 3 ∗2 ! = 6
2 ! = 2 ∗1 = 2 ∗1 ! = 2
1 ! = 1 ∗0 ! = 1
0 ! = 1
✡ ✠
The only case in which we can’t calculate n! in terms of (n−1)! is when n
is 0. Otherwise, in each case we see that
☛ ✟
n ! = n ∗( n−1)!
✡ ✠
This leads to the following recursive deﬁnition:
☛ ✟
n ! = 1 i fn = 0 // B o u n d a r y ( o r b a s e ) c a s e
n ! = n ∗( n−1)! i fn>0 // R e c u r s i v e c a s e
✡ ✠
564 CHAPTER 12 •Recursive Problem Solving
Note that if we had omitted the base case, the recursion would have
continued to (−1)! and(−2)! and so on.
JAVA DEBUGGING TIP Bounding the Repetition. An inﬁnite
repetition will result if a recursive deﬁnition is not prope rly bounded.
The recursive case uses divide and conquer to break the probl em into a
smaller problem, but the smaller problem is just a smaller ver sion of the
original problem. This combination of self-similarity and divide and con-
quer is what characterizes recursion. The base case is used t o stop or limit
the recursion.
JAVA EFFECTIVE DESIGN Recursive Deﬁnition. For recursive
algorithms and deﬁnitions, the base case serves as the bound for the
algorithm. The recursive case deﬁnes the nth case in terms of the
(n−1)st case.
12.2.2 Drawing a Nested Pattern
As another example, consider the problem of drawing the nest ed boxes
pattern in Figure 12.2. The self-similarity occurs in the fa ct that for this
pattern, its parts resemble the whole. The basic shape invol ved is a square,
which is repeated over and over at an ever-smaller scale. A re cursive
deﬁnition for this pattern would be
FIGURE 12.2 The nested squares
pattern.☛ ✟
Base case : i fside<5do nothing
Recursive case :i fside>= 5
draw a square
decrease the side and draw a smaller
pattern i n s i d e the square
✡ ✠
This deﬁnition uses the length of the square’s side to help de ﬁne the pat-
tern. If the length of the side is greater than or equal to 5, dra w a square
with dimensions side×side. Then decrease the length of the side and draw
a smaller version of the pattern inside that square. In this ca se, the side
variable will decrease at each level of the drawing. When the l ength of the
side becomes less than 5, the recursion stops. Thus, the leng th of the side
serves as the limit or bound for this algorithm.
You should note that the length of the side functions here lik e a param-
eter in a method deﬁnition: It provides essential informatio n for the deﬁ-
nition, just as a method parameter provides essential data to the method.
Indeed, this is exactly the role that parameters play in recur sive meth-
ods. They provide essential information that determines th e method’s
behavior.
SECTION 12.3 •Recursive String Methods 565
Figure 12.3 illustrates how we would apply the deﬁnition. Su ppose the
nestedBoxes(5)5
5nestedBoxes(10)10
10nestedBoxes(15)15
15nestedBoxes(20)20
20
FIGURE 12.3 A trace of the nested
boxes deﬁnition starting with a side
of 20 and decreasing the side by 5
each time.side starts out at 20 and decreases by 5 at each level of recurs ion. Note that
as you move from top to bottom across the four patterns, each p attern
contains the one below it. A nestedBoxes(20) can be drawn by ﬁrst
drawing a 20×20square and then drawing a nestedBoxes(15) pattern
inside it. Similarly, a nestedBoxes(15) can be drawn by ﬁrst drawing a
15×15square and then drawing a nestedBoxes(10) pattern inside it.
And so on.
These examples illustrate the power of recursion as a proble m-solving
technique for situations that involve repetition. Like the iterative (looping)
control structures we studied in Chapter 6, recursion is use d to implement
repetition within a bound. For recursive algorithms, the bo und is deﬁned
by the base case, whereas for loops, the bound is deﬁned by the loop’s
entry condition. In either case, repetition stops when the bo und is reached.
SELF-STUDY EXERCISES
EXERCISE 12.3 You can calculate 2nby multiplying 2 by itself ntimes.
For example, 23is2×2×2. Note also that 20=1. Given these facts, write
a recursive deﬁnition for 2n, forn≥0.
EXERCISE 12.4 Generalize your solution to the previous exercise by
giving a recursive deﬁnition for xn, wherexandnare both integers ≥0.
EXERCISE 12.5 Is the recursive deﬁnition given earlier for the nested
boxes equivalent to the following recursive deﬁnition? Exp lain.
☛ ✟
Draw a square . // i n e v e r y c a s e
I f side >5
draw a smaller nested boxes i n s i d e the square
✡ ✠
In this case, the base case (side<=5)is implicit.
EXERCISE 12.6 Write a recursive deﬁnition for the recursive pattern
shown in Figure 12.4.
JAVA DEBUGGING TIP Inﬁnite Recursion. An unbounded or
incorrectly bounded recursive algorithm will lead to inﬁni te
repetition. Care must be taken to get the bound right.
12.3 Recursive String Methods
Remember that a recursive method is a method that calls itself. Like re-
cursive deﬁnitions, recursive methods are designed around the divide-
and-conquer and self-similarity principles. Deﬁning a rec ursive method
involves a similar analysis to the one we used in designing re cursive deﬁ-
nitions. We identify a self-similar subproblem of the origi nal problem plus
one or more limiting cases.
The idea of a method calling itself seems a bit strange at ﬁrst . It’s
perhaps best understood in terms of a clone or a copy. When a met hod
FIGURE 12.4 Write a recursive
deﬁnition for this pattern.calls itself, it really calls a copy of itself, one that has a s lightly different
566 CHAPTER 12 •Recursive Problem Solving
internal state. Usually the difference in state is the resul t of a difference in
the invoked method’s parameters. How can a method call itself?
12.3.1 Printing a String
To illustrate the concept of a recursive method, let’s deﬁne a recursive
method for printing a string. This is not intended to be a prac tical
method—we already have the println() method for printing strings.
But pretend for a moment that you only have a version of println()
that works for characters, and your task is to write a version that can be
used to print an entire string of characters.
A little terminology will help us describe the algorithm. Le t’s call the
ﬁrst letter of a string the head of the string, and let’s refer to all the remain-
ing letters in the string as the tailof the string. Then the problem of print-
ing a string can be solved using a head-and-tail algorithm , which consists Head-and-tail algorithm
of two parts: printing the head of the string and recursively printing its
tail. The limiting case here is when a string has no character s in it. It’s
trivial to print the empty string—there is nothing to print! T his leads to
the method deﬁnition shown in Figure 12.5.
☛ ✟
/∗∗
∗p r i n t S t r i n g ( ) p r i n t s e a c h c h a r a c t e r o f t h e s t r i n g s
∗P r e : s i s i n i t i a l i z e d ( non −n u l l )
∗P o s t : n o n e
∗/
public void p r i n t S t r i n g ( S t r i n g s ) {
i f( s . length ( ) == 0)
return ; // B a s e c a s e : d o n o t h i n g
else{ // R e c u r s i v e c a s e :
System . out . p r i n t ( s . charAt ( 0 ) ) ; // P r i n t h e a d
p r i n t S t r i n g ( s . substring ( 1 ) ) ; // P r i n t t a i l
}
}// p r i n t S t r i n g ( )
✡ ✠
Figure 12.5: The recursive printString() method.
The base case here provides a limit and bounds the recursion w hen the
length of sis 0—that is, when the string is empty. The recursive case solv es
the problem of printing sby solving the smaller, self-similar problem of
printing a substring of s. Note that the recursive case makes progress to-
ward the limit. On each recursion, the tail will get smaller a nd smaller
until it becomes the empty string.
JAVA EFFECTIVE DESIGN Recursive Progress. In a recursive
algorithm, each recursive call must make progress toward th e bound,
or base case.
Let’s now revisit the notion of a method calling itself. Obvi ously this is Recursive call
what happens in the recursive case, but what does it mean—what actions
does this lead to in the program? Each recursive call to a meth od is really a
call to a copy of that method, and each copy has a slightly different intern al
SECTION 12.3 •Recursive String Methods 567
state. We can deﬁne printString() ’s internal state completely in terms
of its recursion parameter, s, which is the string that’s being printed. A
recursion parameter is a parameter whose value is used to control the
progress of the recursion. In this case, if sdiffers in each copy, then so will
s.substring(1) ands.charAt(0) .
JAVA EFFECTIVE DESIGN Recursion and Parameters. Recursive
methods use a recursion parameter to distinguish between se lf-similar
instances of the method call. The parameter controls the pro gress of
the recursion toward its bound.
Figure 12.6 illustrates the sequence of recursive method ca lls and the
output that results when printString("hello") is invoked. Each box
printString("hello")
System.out.print('h');
printString("ello");
printString("ello")
System.out.print('e');
printString("llo");
printString("llo")
System.out.print('l');
printString("lo");
printString("lo")
System.out.print('l');
printString("o");
printString("o")
System.out.print('o');
printString("");
printString("")
Base
caseOutput Produced
return;printString("hello")
h e l l oFigure 12.6: A recursive method
call invokes a copy of the method,
each with a slightly different in-
ternal state. As this is done re-
peatedly, a stack of method calls
is created.
represents a separate instance of the printString() method, with its
own internal state. In this illustration, its state is repres ented by its pa- Self-similar instances
rameter, s. Because each instance has a different parameter, behavior s
differ slightly. Each box shows the character that will be pr inted by that
568 CHAPTER 12 •Recursive Problem Solving
instance ( s.charAt(0) ), and the string that will be passed on to the next
instance ( s.substring(1) ).
JAVA DEBUGGING TIP Off-by-One Error. The expressions
s.charAt(0) ands.substring(1) will generate exceptions if sis
the empty string.
The arrows represent the method calls and returns. Note that the ﬁrst
return executed is the one in the base case. Each instance of the meth od
must wait for the instance it called to return before it can re turn. That’s
why the instances “pile up” in a cascade-like structure. The arrowless
lines trace the order in which the output is produced.
Each instance of printString() is similar to the next in that each
will print one character and then pass on a substring, but eac h performs
its duties on a different string. Note how the string, the rec ursion param-
eter in this case, gets smaller in each instance of printString() . This Progress toward the bound
represents progress toward the method’s base case s.length() == 0 .
When the empty string is passed as an argument, the recursion w ill stop.
If the method does not make progress toward its bound in this wa y, the
result will be an inﬁnite recursion.
JAVA EFFECTIVE DESIGN Bounding the Recursion. For recursive
algorithms, the recursion parameter is used to express the a lgorithm’s
bound or base case. In order for the algorithm to terminate, ea ch
recursive call should make progress toward the bound.
Note also the order in which things are done in this method. Fi rst
s.charAt(0) is printed, and then s.substring(1) is passed to Self-similarity
printString() in the recursion. This is a typical structure for a head-
and-tail algorithm. What makes this work is that the tail is a s maller,
self-similar version of the original structure.
JAVA EFFECTIVE DESIGN Head-and-Tail Algorithm. Many
recursive solutions involve breaking a sequential structu re, such as a
string or an array, into its head and tail. An operation is per formed on
the head, and the algorithm recurses on the tail.
SECTION 12.3 •Recursive String Methods 569
SELF-STUDY EXERCISE
EXERCISE 12.7 What would be printed by the following version of the
printString2() method, if it is called with printString2("hello") ?
☛ ✟
public void p r i n t S t r i n g 2 ( S t r i n g s ) {
i f( s . length ( ) == 1)
System . out . p r i n t ( s . charAt ( 0 ) ) ; // B a s e c a s e :
else{
// P r i n t l a s t c h a r
System . out . p r i n t ( s . charAt ( s . length ( ) −1 ) ) ;
// P r i n t r e s t o f s t r i n g
p r i n t S t r i n g 2 ( s . substring ( 0 , s . length ( ) −1 ) ) ;
}
}// p r i n t S t r i n g 2 ( )
✡ ✠
12.3.2 Printing the String Backward
What do you suppose would happen if we reversed the order of the state-
ments in the printString() method? That is, what if the recursive call
came before s.charAt(0) is printed, as in the following method:
☛ ✟
/∗∗
∗p r i n t R e v e r s e ( ) p r i n t s e a c h c h a r a c t e r s i n r e v e r s e o r d e r
∗P r e : s i s i n i t i a l i z e d ( non −n u l l )
∗P o s t : n o n e
∗/
public void printReverse ( S t r i n g s ) {
i f( s . length ( ) >0){ // R e c u r s i v e c a s e :
printReverse ( s . substring ( 1 ) ) ; // P r i n t t a i l
System . out . p r i n t ( s . charAt ( 0 ) ) ; // P r i n t f i r s t c h a r
}
}// p r i n t R e v e r s e ( )
✡ ✠
As its name suggests, this method will print the string in rev erse
order. The trace in Figure 12.7 shows how this works. Before
printReverse("hello") can print h, it calls printReverse("ello")
and must wait for that call to complete its execution and retu rn. But
printReverse("ello") callsprintReverse("llo") and so must
wait for that call to complete its execution and return.
This process continues until printReverse("") is called. While the
base case is executing, the other ﬁve instances of printReverse() must
each wait for the instance that they called to complete its ex ecution. It
is only after the base case returns, that printReverse("o") can print
its ﬁrst character and return. So the letter owill be printed ﬁrst. After
printReverse("o") has returned, then printReverse("lo") can
print its ﬁrst character. So the letter lwill be printed next, and so on, until
the original call to printReverse("hello") is completed and returns.
Thus, the string will be printed in reverse order.
Note that the method call and return structure in this exampl e follows a
last-in–ﬁrst-out (LIFO) protocol . That is, the last method called is always Last-in–ﬁrst-out protocol
570 CHAPTER 12 •Recursive Problem Solving
Figure 12.7: A trace of print-
Reverse(s) , which prints its
string argument in reverse order.
printReverse("hello")
printReverse("ello");
System.out.print('h');
printReverse("ello")
printString("llo");
System.out.print('e');
printReverse("llo")
printReverse("lo");
System.out.print('l');
printReverse("lo")
printReverse("o");
System.out.print('l');
printReverse("o")
printReverse("");
System.out.print('o');
printReverse("")
Base
caseOutput produced return;printReverse("hello")
o l l e h
the ﬁrst method to return. This is the protocol used by all met hod calls,
recursive or otherwise.
JAVA LANGUAGE RULE LIFO. All programming languages,
including Java, use a last-in-ﬁrst-out protocol for proced ure call and
return.
For example, compare the order in which things happen in Figu re 12.7
with the method stack trace in Figure 10.12. The only real dif ference
between the two ﬁgures is that here the method stack is repres ented as
growing downward, whereas in Figure 10.12 it grows upward. A s each
method call is made, a representation of the method call is pl aced on the
method call stack . When a method returns, its block is removed from the Method call stack
top of the stack. The only difference between recursive and n onrecursive
method calls is that recursive methods call instances of the same method
deﬁnition. Of course, as we’ve seen, the instances are all sl ightly different
from each other.
SECTION 12.3 •Recursive String Methods 571
SELF-STUDY EXERCISES
EXERCISE 12.8 Write a recursive method called countDown() that
takes a single int parameter, N≥0, and prints a countdown, such as
“5, 4, 3, 2, 1, blastoff.” In this case, the method would be call ed with
countDown(5) .
EXERCISE 12.9 Revise the method in the previous exercise so that
when it’s called with countDown(10) , it will print “10 8 6 4 2 blastoff”;
if it’s called with countDown(9) , it prints “9 7 5 3 1 blastoff.”
12.3.3 Counting Characters in a String
Suppose you’re writing an encryption program and you need to count the
frequencies of the letters of the alphabet. Let’s write a rec ursive method Problem statement
for this task.
This method will have two parameters: a String to store the string
that will be processed and a char to store the target character—the one
we want to count. The method should return an int, representing the
number of occurrences of the target character in the string:
☛ ✟
// G o a l : c o u n t t h e o c c u r r e n c e s o f c h i n s
public i n t countChar ( S t r i n g s , char ch ){
. . .
}
✡ ✠
Here again our analysis must identify a recursive step that br eaks the
problem into smaller, self-similar versions of itself, plu s a base case or
limiting case that deﬁnes the end of the recursive process. B ecause the
empty string will contain no target characters, we can use it as our base Base case
case. So, if it is passed the empty string, countChar() should just return
0 as its result.
For the recursive case, we can divide the string into its head and tail. Recursive case
If the head is the target character, then the number of occurre nces in the
string is (1 + the number of occurrences in its tail). If the hea d of the
string is not the target character, then the number of occurr ences is (0 +
the number of occurrences in its tail). Of course, we’ll use r ecursion to
calculate the number of occurrences in the tail.
This analysis leads to the recursive method shown in Figure 1 2.8. Note
that for both recursive cases the same recursive call is used . In both cases
we pass the tail of the original string, plus the target chara cter. Note also
how the return statement is evaluated:
☛ ✟
return 1 + countChar ( s . substring ( 1 ) , ch ) ; // H e a d = c h
✡ ✠
Before the method can return a value, it must receive the resu lt of call-
ingcountChar(s.substring(1),ch) and add it to 1. Only then can Evaluation order is crucial
572 CHAPTER 12 •Recursive Problem Solving
☛ ✟
/∗∗
∗P r e : s i s a non −n u l l S t r i n g , c h i s a n y c h a r a c t e r
∗P o s t : c o u n t C h a r ( ) == t h e n u m b e r o f o c c u r r e n c e s o f c h i n s t r
∗/
public i n t countChar ( S t r i n g s , char ch ){
i f( s . length ( ) == 0) // B a s e c a s e : e m p t y s t r i n g
return 0 ;
else i f ( s . charAt ( 0 ) == ch ) // R e c u r s i v e c a s e 1
return 1 + countChar ( s . substring ( 1 ) , ch ) ; // H e a d = c h
else // R e c u r s i v e c a s e 2
return 0 + countChar ( s . substring ( 1 ) , ch ) ; // H e a d ! = c h
}// c o u n t C h a r ( )
✡ ✠
Figure 12.8: The recursive countChar() method.
a result be returned to the calling method. This leads to the f ollowing
evaluation sequence for countChar("dad",’d’) :
☛ ✟
countChar ( ”dad” ,’d ’) ;
1 + countChar ( ”ad” ,’d ’) ;
1 + 0 + countChar ( ”d” ,’d ’) ;
1 + 0 + 1 + countChar ( ””,’d ’) ;
1 + 0 + 1 + 0 = 2 // F i n a l r e s u l t
✡ ✠
In this way, the ﬁnal result of calling countChar("dad",’d’) is built
up recursively by adding together the partial results from e ach separate
instance of countChar() . The evaluation process is shown graphically
in Figure 12.9.
Figure 12.9: A trace of
countChar("dad",’d’) ,
which returns the value 2.
countChar("dad",'d');
return 1 + countChar("ad",'d');
countChar("ad",'d');
return 0 + countChar("d",'d');
countChar("d",'d');
return 1 + countChar("",'d');
countChar("",'d');
return 0;Base
case1+ 0 + 1 + 0 = 2
0 + 1 + 0
1 + 0
0countChar("dad",'d');Result

SECTION 12.3 •Recursive String Methods 573
JAVA DEBUGGING TIP Return Type. A common error with
nonvoid recursive algorithms is forgetting to make sure tha t those
return statements that contain a recursive call yield the co rrect data
type.
SELF-STUDY EXERCISE
EXERCISE 12.10 Here’s a numerical problem. Write a recursive
method to compute the sum of 1 to N, given Nas a parameter.
12.3.4 Translating a String
A widely used string-processing task is to convert one strin g into another
string by replacing one character with a substitute through out the string.
For example, suppose we want to convert a Unix path name, whic h uses
the forward slash “/” to separate one part of the path from ano ther, into a
Windows path name, which uses the backslash character “ \” as a separa- Problem statement
tor. For example, we want a method that can translate the foll owing two
strings into one another:
☛ ✟
/unix system/myfolder/java
\Windows system\myfolder \java
✡ ✠
Thus, we want a method that takes three parameters: a String , on
which the conversion will be performed, and two char variables, the ﬁrst Method design
being the original character in the string and the second bei ng its substi-
tute. The precondition for this method is simply that each of these three
parameters has been properly initialized with a value. The p ostcondi-
tion is that all occurrences of the ﬁrst character have been r eplaced by the
second character.
As in our previous string-processing methods, the limiting case in this Head-and-tail algorithm
problem is the empty string, and the recursive case will divi de the string
into its head and its tail. If the head is the character we want t o replace,
we concatenate its substitute with the result we obtain by re cursively
converting its tail.
This analysis leads to the deﬁnition shown in Figure 12.10. T his method
has more or less the same head and tail structure as the preced ing exam-
ple. The difference is that here the operation we perform on t he head of
the string is concatenation rather than addition.
The base case is still the case in which str is the empty string. The
ﬁrst recursive case occurs when the character being replace d is the head
ofstr. In that case, its substitute ( ch2) is concatenated with the result
of converting the rest of the string and returned as the resul t. The second
recursive case occurs when the head of the string is notthe character be-
ing replaced. In this case, the head of the string is simply con catenated
with the result of converting the rest of the string. Figure 1 2.11 shows an
example of its execution.
574 CHAPTER 12 •Recursive Problem Solving
☛ ✟
/∗∗
∗P r e : s t r , c h 1 , c h 2 h a v e b e e n i n i t i a l i z e d
∗P o s t : t h e r e s u l t c o n t a i n s a c h 2 e v e r y w h e r e t h a t c h 1
∗ h a d o c c u r r e d i n s t r
∗/
public s t a t i c S t r i n g convert ( S t r i n g s t r , char ch1 , char ch2 ){
i f( s t r . length ( ) == 0) // B a s e c a s e : e m p t y s t r i n g
return s t r ;
else i f ( s t r . charAt ( 0 ) == ch1 ) // R e c u r s i v e 1 : c h 1 a t h e a d
// R e p l a c e c h 1 w i t h c h 2
return ch2 + convert ( s t r . substring ( 1 ) , ch1 , ch2 ) ;
else // R e c u r s i v e 2 : c h 1 n o t a t h e a d
return s t r . charAt ( 0 ) + convert ( s t r . substring ( 1 ) , ch1 , ch2 ) ;
}// c o n v e r t ( )
✡ ✠
Figure 12.10: The convert() method replaces one character with another
in a string.
Figure 12.11: A trace of
convert("bad",’d’,’m’) ,
which returns “bam.”
convert("bad",'d','m');
return 'b' + convert("ad",'d','m');
convert("ad",'d','m');
return 'a' + convert("d",'d','m');
convert("d",'d','m');
return 'm' + convert("",'d','m');
convert("",'d','m');
return "";Base
caseResult
'b' + 'a' + 'm' + "" = "bam"
'a' + 'm' + ""
'm' + ""
""convert("bad",'d','m');
SELF-STUDY EXERCISE
EXERCISE 12.11 Write a recursive method that changes each blank
in a string into two consecutive blanks, leaving the rest of t he string
unchanged.
12.3.5 Printing all Possible Outcomes when Tossing N
Coins
Suppose that a student who is studying probability wishes to have a Java
program that, for any positive integer N, will print out a list of all possible
outcomes when Ncoins are tossed. For purposes of analyzing the prob-
lem, it is assumed that the coins are numbered 1through Nand that they
SECTION 12.3 •Recursive String Methods 575
are tossed one at a time. An outcome will be represented by a st ring of
Hs andTs corresponding to heads and tails. Thus, if N=2, the string HT
represents a head on the ﬁrst coin and a tail on the second coin . What we
need is a method which, when given the number of coins, will pr int out A coin tossing experiment
all strings of this type. In case of two coins the output should be:
☛ ✟
H H
HT
TH
TT
✡ ✠
Let’s devise a strategy, given any positive integer N, for printing the
strings that correspond to all possible outcomes when tossi ngNcoins. Designing a recursive algorithm
Clearly, for N=1, the method needs to print an Hon one line and a Ton
the next line. For an arbitrary number of coins N, one way to generate all
outcomes is to think of two kinds of strings—those that start w ith anHand
those that start with a T. The strings that start with Hcan be generated by
inserting an Hin front of each of the outcomes that occur when N−1coins
are tossed. The strings beginning with Tcan be generated in a similar
manner. Thus, using the outcomes for two coins above, we know that the
outcomes for three coins for which the ﬁrst coin is Hare:
☛ ✟
H H H
HHT
HTH
HTT
✡ ✠
Using an argument similar to the one above, we can generalize this to a
description of the recursive case for an algorithm. We want a n algorithm
that generates all those outcomes for Ncoins where we are given a string
STR representing one particular outcome for all but the last Kcoins where
0<K<=N. To print out all such outcomes, just print all outcomes with a
ﬁxed outcome corresponding to STR + "H" for all but the last K−1coins
and then print all outcomes with the ﬁxed outcome STR + "T" for all but
the lastK−1coins. The base case is the special case K=1when you just
needSTR + "H" on one line and STR + "T" on the next. If you start the
algorithm with STR = "" andK=N, this algorithm will print out all the
outcomes for tossing Ncoins.
To translate this into Java code we can create a class called C oin-
Toss which has a single static method called printOutcomes(String
str,int N) . The above recursive description easily translates into co de
for the method in Figure 12.12.
576 CHAPTER 12 •Recursive Problem Solving
☛ ✟
/∗∗
∗p r i n t O u t c o m e s ( s t r , N ) p r i n t s o u t a l l p o s s i b l e o u t c o m e s
∗b e g i n n i n g w i t h s t r when N m o r e c o i n s a r e t o s s e d .
∗P r e : s t r i s a s t r i n g o f Hs a n d T s .
∗P r e : N i s a p o s i t i v e i n t e g e r .
∗P o s t : n o n e
∗/
public s t a t i c void printOutcomes ( S t r i n g s t r , i n t N){
i f(N == 1) {// T h e b a s e c a s e
System . out . p r i n t l n ( s t r + ”H” ) ;
System . out . p r i n t l n ( s t r + ”T” ) ;
}else{ // T h e r e c u r s i v e c a s e
printOutcomes ( s t r + ”H” , N−1 ) ;
printOutcomes ( s t r + ”T” , N−1 ) ;
}// e l s e
}// p r i n t O u t c o m e s ( )
✡ ✠
Figure 12.12: The method printOutcomes() prints all outcomes given
the results on some initial coins.
To print out all outcomes when tossing, say, seven coins, just make the
method call CoinToss.printOutcomes("",7) . This particular call
would generate the desired output:
☛ ✟
H H H H H H H
H H H H H H T
. . . . . . .
TTTTTTH
TTTTTTT
✡ ✠
To better understand how the recursive method deﬁnition gen erates its
output, it might be helpful to trace the order of recursive ca lls and output
toSystem.out that occurs when executing printOutcomes("",3) as
shown in Figure 12.13.
Notice that the recursive case in the method implementation makes two
calls to itself and as a result it is not so clear how this metho d would be
FIGURE 12.13 The order in which
the recursive calls and output occur
whenprintOutcomes("",3) is
executed.written using a loop instead of recursion. This example is mo re typical of
the type of problem for which a recursive method is shorter an d clearer
than a method that solves the same problem without using recu rsion.
SELF-STUDY EXERCISE
EXERCISE 12.12 Modify the above printOutcomes() method so
that it will print out all possible outcomes when a chess play er plays a
series of Ngames. The outcome of each game is to be represented by a W,
L, orDcorresponding to the player winning, losing, or drawing the game.
SECTION 12.4 •Recursive Array Processing 577
12.4 Recursive Array Processing
Like strings, arrays also have a recursive structure. Just a s each substring
of a string is similar to the string as a whole, each portion of an array is
similar to the array as a whole. Similarly, just as a string can be divided
into a head and a tail, an array can be divided into its head, the ﬁrst ele-
ment, and its tail, the rest of its elements (Fig. 12.14). Because the tail of an6 8 1 0 10 15 2 32 7 71
HeadTail
FIGURE 12.14 An array of int is a
recursive structure whose tail is
similar to the array as a whole.array is itself an array, it satisﬁes the self-similarity pr inciple. Therefore,
arrays have all the appropriate characteristics that make t hem excellent
candidates for recursive processing.
12.4.1 Recursive Sequential Search
Let’s start by developing a recursive version of the sequent ial search al-
gorithm that we discussed in Chapter 9. Recall that the seque ntial search
method takes two parameters: the array being searched and th ekey, or Method design
target value, being searched for. If the key is found in the arr ay, the
method returns its index. If the key is not found, the method re turns
−1, thereby indicating that the key was not contained in the arr ay. The
iterative version of this method has the following general f orm:
☛ ✟
/∗∗
∗P e r f o r m s a s e q u e n t i a l s e a r c h o f a n i n t e g e r a r r a y
∗@ p a r a m a r r i s t h e a r r a y o f i n t e g e r s
∗@ p a r a m k e y i s t h e e l e m e n t b e i n g s e a r c h e d f o r
∗@ r e t u r n t h e k e y ’ s i n d e x i s r e t u r n e d i f t h e k e y i s
∗ f o u n d o t h e r w i s e −1 i s r e t u r n e d
∗P r e : a r r i s n o t n u l l
∗P o s t : e i t h e r −1 o r t h e k e y ’ s i n d e x i s r e t u r n e d
∗/
public i n t s e q u e n t i a l S e a r c h ( i n t a r r [ ] , i n t key ){
return −1; // f a i l u r e i f t h i s i s r e a c h e d
}
✡ ✠
If we divide the array into its head and tail, then one way to des cribe a
recursive search algorithm is as follows:
☛ ✟
I f the array i s empty , return −1
I f the array ’ s head matches the key , return i t s index
I f the array ’ s head doesn ’ t match the key ,
return the r e s u l t of searching the t a i l of the array
✡ ✠
This algorithm clearly resembles the approach we used in rec ursive string
processing: Perform some operation on the head of the array a nd recurse
on the tail of the array.
The challenge in developing this algorithm is not so much kno wing
what to do but knowing how to represent concepts like the head and the How do we represent head and tail?
tail of the array. For strings, we had methods such as s.charAt(0) to
represent the head of the string and s.substring(1) to represent the
string’s tail. For an array named arr, the expression arr[0] represents
the head of the array. Unfortunately, we have no method compa rable to
578 CHAPTER 12 •Recursive Problem Solving
thesubstring() method for strings that lets us represent the tail of the
array.
To help us out of this dilemma, we can use an integer parameter to rep-
resent the head of the array. Let’s have the int parameter, head, represent
the current head of the array (Fig. 12.15). Then head+1represents the start
of the tail, and arr.length-1 represents the end of the tail. Our method
will always be passed a reference to the whole array, but it wi ll restrict the
search to the portion of the array starting at head. If we let head vary from
0 toarr.length on each recursive call, the method will recurse through
the array in head/tail fashion, searching for the key. The me thod will stop
whenhead = arr.length .
Figure 12.15: A parameter, head,
can represent the head of some
portion of the array.6 8 1 0 10 15 2 32 7 710 N -1
HeadTailFirst call
6 8 1 0 10 15 2 32 7 71
HeadTailSecond call
6 8 1 0 10 15 2 32 7 71
HeadTailThird call
6 8 1 0 10 15 2 32 7 710 N -1
HeadLast call
JAVA PROGRAMMING TIP Subarray Parameter. For methods that
take an array argument, an int parameter can be used to designate
the portion of the array that should be processed in the metho d.
This leads to the deﬁnition for recursive search shown in Fig ure 12.16.
Note that the recursive search method takes three parameter s: the array
to be searched, arr, thekey being sought, and an integer head that gives
the starting location for the search. The algorithm is bound ed when head
= arr.length . In effect, this is like saying the recursion should stop
when we have reached a tail that contains 0 elements. This und erscores
the point we made earlier about the importance of parameters in design-
ing recursive methods. Here the head parameter serves as the recursion
parameter . It controls the progress of the recursion. Recursion parameter
Note also that for the search algorithm we need two base cases . One
represents the successful case, where the key is found in the array. The
other represents the unsuccessful case, which comes about a fter we have
looked at every possible head in the array and not found the ke y. This
SECTION 12.4 •Recursive Array Processing 579
☛ ✟
/∗∗
∗s e a r c h ( a r r , h e a d , k e y ) −−− R e c u r s i v e l y s e a r c h a r r f o r k e y
∗ s t a r t i n g a t h e a d
∗P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h
∗P o s t : i f a r r [ k ] == k e y f o r k , 0 <= k< a r r . l e n g t h ,
∗ r e t u r n k e l s e r e t u r n −1
∗/
private i n t search ( i n t a r r [ ] , i n t head , i n t key ){
i f( head == a r r . length ) // B a s e : e m p t y l i s t −f a i l u r e
return −1;
else i f ( a r r [ head ] == key ) // B a s e : k e y f o u n d −−− s u c c e s s
return head ;
else // R e c u r s i v e : s e a r c h t h e t a i l
return search ( arr , head + 1 , key ) ;
}
✡ ✠
Figure 12.16: The recursive search method takes three param eters. The
head parameter points to the beginning of that portion of the arra y that is
being searched.
case will arise through exhaustion—that is, when we have exha usted all
possible locations for the key.
JAVA DEBUGGING TIP Recursive Search. For the recursive search
method to work properly, it must be called with the correct va lue for
thehead parameter.
12.4.2 Information Hiding
Note that in order to use the search() method, you would have to know
that you must supply a value of 0 as the argument for the head parameter.
This is not only awkward but also impractical. After all, if w e want to
search an array, we just want to pass two arguments, the array a nd the
key we’re searching for. It’s unreasonable to expect users of a method to Design issue
know that they also have to pass 0 as the head in order to get the recursion
started. This design is also prone to error, because it’s qui te easy for a
mistake to be made when the method is called.
For this reason, it is customary to provide a nonrecursive in terface to
the recursive method. The interface hides the fact that a rec ursive algo-
rithm is being used, but this is exactly the kind of implement ation detail
that should be hidden from the user. This is an example of the p rinciple of
information hiding that we introduced in Chapter 0. A more ap propriate Hide implementation details
design would make the recursive method a private method that’s called
by the public method, as shown Figure 12.17 and implemented i n the
Searcher class (Fig. 12.18).
580 CHAPTER 12 •Recursive Problem Solving
Figure 12.17: The public
search() method serves as
an interface to the private recur-
sive method, search() . Note
that the methods have different
signatures.+search(in arr[] : int, in key : int) : int
-search(in arr[] : int, in head : int, in key : int) : intSearcher
☛ ✟
public c l a s s Searcher {
/∗∗
∗s e a r c h ( a r r , k e y ) −− s e a r c h e s a r r f o r k e y .
∗P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h
∗P o s t : i f a r r [ k ] == k e y f o r k , 0 <= k< a r r . l e n g t h ,
∗ r e t u r n k , e l s e r e t u r n −1
∗/
public i n t search ( i n t a r r [ ] , i n t key ){
return search ( arr , 0 , key ) ; // C a l l r e c u r s i v e s e a r c h
}
/∗∗
∗s e a r c h ( a r r , h e a d , k e y ) −− R e c u r s i v e l y s e a r c h a r r f o r k e y
∗ s t a r t i n g a t h e a d
∗P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h
∗P o s t : i f a r r [ k ] == k e y f o r k , 0 <= k< a r r . l e n g t h , r e t u r n k
∗ e l s e r e t u r n −1
∗/
private i n t search ( i n t a r r [ ] , i n t head , i n t key ){
i f( head == a r r . length ) // B a s e c a s e : e m p t y l i s t −f a i l u r e
return −1;
else i f ( a r r [ head ] == key ) // B a s e c a s e : k e y f o u n d −− s u c c e s s
return head ;
else // R e c u r s i v e c a s e : s e a r c h t h e t a i l
return search ( arr , head + 1 , key ) ;
}// s e a r c h ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
i n t numbers [ ] = {0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 1 8 };
Searcher searcher = new Searcher ( ) ;
for (i n t k = 0 ; k <= 2 0 ; k++) {
i n t r e s u l t = searcher . search ( numbers , k ) ;
i f( r e s u l t != −1)
System . out . p r i n t l n ( k + ” found at ” + r e s u l t ) ;
else
System . out . p r i n t l n ( k + ” i s not in the array ” ) ;
}// f o r
}// m a i n ( )
}// S e a r c h e r
✡ ✠
Figure 12.18: Information hiding principle: The public search()
method calls the private , recursive search() , thereby hiding the fact
that a recursive algorithm is used.
JAVA EFFECTIVE DESIGN Information Hiding. Unnecessary
implementation details, such as whether a method uses a recu rsive or
iterative algorithm, should be hidden within the class. Use rs of a class
or method should be shown only those details that they need to know.
SECTION 12.4 •Recursive Array Processing 581
SELF-STUDY EXERCISE
EXERCISE 12.13 Write a main() method for the Searcher class to
conduct the following test of search() . Create an int array of ten el-
ements, initialize its elements to the even numbers from 0 to 18, and then
use a for loop to search the array for each of the numbers from 0 to 20.
12.4.3 Recursive Selection Sort
Next we want you to think back to Chapter 9, where we introduce d the
selection sort algorithm. To review the concept, suppose yo u have a deck
of 52 cards. Lay them out on a table, face up, one card next to th e other.
Starting at the last card, look through the deck, from last to ﬁrst, ﬁnd the Sorting a deck of cards
largest card and exchange it with the last card. Then go throu gh the deck
again starting at the next to the last card, ﬁnd the next large st card, and
exchange it with the next to the last card. Go to the next card, and so on.
If you repeat this process 51 times, the deck will be completel y sorted.
JAVA DEBUGGING TIP Off-by-One Error. Sorting algorithms are
particularly susceptible to an off-by-one error. To sort an array with N
elements, you generally need to make N−1passes.
Let’s design a recursive version of this algorithm. The algo rithm we
just described is like a head-and-tail algorithm in reverse, where the last
card in the deck is like the head, and the cards before it are li ke the tail.
After each pass or recursion, the last card will be in its prop er location,
and the cards before it will represent the unsorted portion o f the deck. If
we use parameter to represent last, then it will be moved one card to the
left at each level of the recursion.
Figure 12.19 illustrates this process for an array of intege rs. The base
case is reached when the lastparameter is pointing to the ﬁrst element in
the array. An array with one element in it is already sorted. It needs no re-
arranging. The recursive case involves searching an ever-s maller portion
6 8 1 0 10 15 2 32 7 71
LastUnsortedAfter one
pass
6 8 1 0 10 15 2 7 32 71
LastUnsortedAfter two
passes
6 8 1 0 10 7 2 15 32 71
LastUnsortedAfter three
passes
0 1 2 6 7 8 10 15 32 71
LastAfter last
passFigure 12.19: Selection sort: Us-
ing a head-and-tail algorithm in
reverse to sort an integer array.
582 CHAPTER 12 •Recursive Problem Solving
☛ ✟
/∗∗
∗s e l e c t i o n S o r t ( a r r , l a s t ) −− R e c u r s i v e l y s o r t a r r s t a r t i n g
∗ a t l a s t e l e m e n t
∗P r e : a r r ! = n u l l a n d 0 <= l a s t < a r r . l e n g t h
∗P o s t : a r r w i l l b e a r r a n g e d s o t h a t a r r [ j ] <= a r r [ k ] ,
∗ f o r a n y j <k
∗/
private void s e l e c t i o n S o r t ( i n t a r r [ ] , i n t l a s t ){
i f( l a s t>0){
i n t maxLoc = findMax ( arr , l a s t ) ; // F i n d t h e l a r g e s t
swap ( arr , l a s t , maxLoc ) ; // S wap i t w i t h l a s t
s e l e c t i o n S o r t ( arr , l a s t −1 ) ;
// Move down t h e a r r a y
}
}// s e l e c t i o n S o r t ( )
✡ ✠
Figure 12.20: The selection- Sort() method uses the findMax() and
swap() methods to help it sort an array.
of the array. This is represented in our design by moving lastdown one
element to the left.
Figure 12.20 provides a partial implementation of selectio n sort for an
array of int. In this deﬁnition, the array is one parameter. The second
parameter, int last , deﬁnes that portion of the array, from right to
left, that is yet to be sorted. On the ﬁrst call to this method, lastwill be
arr.length −1. On the second, it will be arr.length −2, and so
on. When lastgets to be 0, the array will be sorted. Thus, in terms of the
card deck analogy, lastrepresents the last card in the unsorted portion of
the deck.
Note how simply the selectionSort() method can be coded. Of
course, this is because we have used separate methods to hand le the tasks Task decomposition
of ﬁnding the largest element and swapping the last element a nd the
largest. This not only makes sense in terms of the divide-and -conquer
principle, but we also already deﬁned a swap() method in Chapter 9. So
here is a good example of reusing code:
☛ ✟
/∗∗
∗s w a p ( a r r , e l 1 e l 2 ) s w a p s e l 1 a n d e l 2 i n t h e a r r a y , a r r
∗P r e : a r r i s n o n n u l l , 0 <= e l 1 < a r r . l e n g t h ,
0<= e l 2 < a r r . l e n g t h
∗P o s t : t h e l o c a t i o n s o f e l 1 a n d e l 2 a r e s w a p p e d i n a r r
∗/
private void swap ( i n t a r r [ ] , i n t el1 , i n t e l 2 ){
i n t temp = a r r [ e l 1 ] ; // A s s i g n t h e f i r s t e l e m e n t t o t e m p
a r r [ e l 1 ] = a r r [ e l 2 ] ; // O v e r w r i t e f i r s t w i t h s e c o n d
a r r [ e l 2 ] = temp ; // O v e r w r i t e s e c o n d w i t h f i r s t ( t e m p )
}// s w a p ( )
✡ ✠
SECTION 12.5 •Example: Drawing (Recursive) Fractals 583
The deﬁnition of the findMax() method is left as a self-study exercise.
JAVA PROGRAMMING TIP Method Decomposition. A task can be
simpliﬁed by breaking it up into simpler subtasks, especial ly if you
already have methods for solving one or more of the subtasks.
SELF-STUDY EXERCISES
EXERCISE 12.14 As in the case of the search() method, we need to
provide a public interface to the recursive selectionSort() method.
We want to enable the user to sort an array just by calling sort(arr) ,
where arr is the name of the array to be sorted. Deﬁne the sort()
method.
EXERCISE 12.15 Deﬁne an iterative version of the findMax(arr,N)
method that is used in selectionSort() . Its goal is to return the
location (index) of the largest integer between arr[0] andarr[N] .
12.5 Example: Drawing (Recursive) Fractals
Afractal is a geometric shape that exhibits a recursive structure. Whe n it
is divided into parts, each part is a smaller version of the wh ole. Fractal Fractal patterns
patterns occur in many situations and places. For example, i f you look
at a graph of the Dow Jones Industrial Average (DJIA) over the pa st year,
the graph for each day is similar to the graph of each month, wh ich is
similar to the graph of each year, and so on. Each part is a redu ced-scale
version of the whole. Fractals also occur throughout nature . If you look
at a coastline from an airplane, the shape of each part of the c oastline, no
matter how small the scale, resembles the shape of the whole c oastline. If
you look at a tree, each branch of the tree is similar in shape t o the whole
tree.
So, fractal patterns are all around us. Because of their self -similarity and
divisibility, fractals are well-suited for recursive prog ramming. Drawing
recursive patterns is also an excellent way to illustrate ho w to use parame-
ters to create generality in method design. In this section, w e will develop
two simple patterns and incorporate them into an applet.
12.5.1 Nested Squares
Earlier in this chapter, we developed a recursive deﬁnition for drawing a
nested squares pattern (Fig. 12.2). Now let’s develop a recu rsive method
that actually draws the pattern. For this pattern, the base c ase is the draw-
ing of the square. The recursive case, if more divisions are d esired, is the
drawing of smaller patterns within the square:
☛ ✟
Draw a square .
I f more d i v i s i o n s are desired
draw a smaller version of pattern within square .
✡ ✠
584 CHAPTER 12 •Recursive Problem Solving
An important consideration for this algorithm is to specify precisely
what we mean by “if more divisions are desired.” In other words , how
exactly do we control the recursion? In our earlier deﬁnition of the pattern, How should we represent the
problem? we used the length of the side to control the algorithm. When side≥5, we
recursed.
Another more general way to do this is to describe the fractal structure
in terms of its levels . For nested squares, the level-zero pattern would be Levels of recursion
just the basic square shape (Fig. 12.21). A level-one pattern would be the
basic square shape plus an inner square, and so on. The higher the level,
Level 4Level 1Level 0
FIGURE 12.21 Levels 0, 1, and 4 of
the nested squares pattern.the more subdividing we do. Therefore, one way to control the recursion
is to use a level parameter as the recursion parameter —as the parameter that
controls the recursion:
☛ ✟
Draw a square .
I f the l e v e l i s g r e a t e r than 0 ,
draw a smaller version of pattern within square .
✡ ✠
What other parameters will we need for this method? If we’re goi ng to
draw a rectangle, we’ll need parameters for its x-and y-coordinates. We’ll
also need a parameter for the length of sides of the square. An other issue
we need to decide is how much the length of the sides should cha nge at
each level. Should length change by a ﬁxed amount, by a ﬁxed ra tio, or
by some other factor? In order to allow this kind of ﬂexibility, let’s use
another parameter for this value.
These design considerations suggest the method shown in Fig ure 12.22.
Note that we must also provide a Graphics parameter so the method
can use the drawRect() method to draw the square. As we decided, the
level parameter controls the recursion. Note that its value is dec reased
by 1 in the recursive call. This will ensure that level will eventually reach
0, and recursion will stop.
☛ ✟
/∗∗
∗d r a w B o x e s () −−− r e c u r s i v e l y d r a w s p a t t e r n o f n e s t e d
∗ s q u a r e s w i t h t o p l e f t c o r n e r o f o u t e r s q u a r e a t
∗ ( l o c X , l o c Y ) a n d d i m e n s i o n s o f l e n g t h s i d e .
∗l e v e l ( >= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e : = 0 )
∗d e l t a i s u s e d t o a d j u s t t h e l e n g t h o f t h e s i d e .
∗/
private void drawBoxes ( Graphics g , i n t l e v e l ,
i n t locX , i n t locY , i n t side , i n t d e l t a ) {
g . drawRect ( locX , locY , side , side ) ;
i f( l e v e l >0){
i n t newLocX = locX + d e l t a ; i n t newLocY = locY + d e l t a ;
drawBoxes ( g , l e v e l −1 , newLocX , newLocY ,
side−2∗delta , d e l t a ) ;
}// i f
}// d r a w B o x e s ( )
✡ ✠
Figure 12.22: The drawBoxes() method.
SECTION 12.5 •Example: Drawing (Recursive) Fractals 585
Finally, note the use of the delta parameter, which is used to change
the length of the sides by a ﬁxed amount, 2*delta , at each level. It
is also used to calculate the x-and y-coordinates for the location of the
next level of boxes (locX + delta, locY + delta) . Butdelta ’s value remains
constant through all the levels. This will lead to a pattern w here the “gap”
between nested squares is constant.
JAVA EFFECTIVE DESIGN Levels of Recursion. Many recursive
algorithms use a level parameter as the recursion parameter.
SELF-STUDY EXERCISES
EXERCISE 12.16 Trace through the drawBoxes() method and draw
the level-four and level-ﬁve versions of the nested boxes pa ttern. Assume
that the initial values for side anddelta are 100 and 5, respectively, and
the initial coordinates for (locX,locY) are (20,20).
EXERCISE 12.17 The pattern shown in Figure 12.23 can be drawn by
usingdelta as a ﬁxed ratio of the length of the side, for example, 10
percent. Modify the drawBoxes() method to use delta in this way.
EXERCISE 12.18 Write an iterative version of the drawBoxes()
method. ( Hint : On each iteration, you must change the x-and y-
coordinates of the square’s location and the length of its si de.)
FIGURE 12.23 This version of
nested boxes can be drawn by using
delta as a ﬁxed percentage of the
length of the side.12.5.2 The Sierpinski Gasket
Let’s return now to the Sierpinski gasket pattern that we introduced at
the start of this chapter. This is a much more interesting fra ctal pattern
(Fig. 12.24). The overall shape of the pattern is that of a tri angle, but notice
how the outer triangle is divided into three smaller triangl es. Then each
of those triangles are divided into three smaller triangles . If you continue
this process of dividing and shrinking, you get the level-se ven pattern
shown here.
Figure 12.24: Levels 0, 1, and 7 of
the Sierpinski gasket fractal pat-
tern.
Let’s develop a recursive method to draw this pattern. If we fo llow
the same strategy we used in the nested squares example, we ge t the
following algorithm:
☛ ✟
Base case : Draw a t r i a n g l e .
Recursive Case : I f more d i v i s i o n s are desired ,
draw three smaller gaskets within the t r i a n g l e .
✡ ✠
For this pattern the base case is the drawing of the basic tria ngle. The
recursive cases, if more divisions are desired, are the draw ing of smaller
586 CHAPTER 12 •Recursive Problem Solving
☛ ✟
/∗∗
∗d r a w G a s k e t () −−− r e c u r s i v e l y d r a w s t h e S i e r p i n s k i g a s k e t
∗ p a t t e r n , w i t h p o i n t s ( p1X , p 1 Y ) , ( p2X , p 2 Y ) , ( p3X , p 3 Y )
∗ r e p r e s e n t i n g t h e v e r t i c e s o f i t s e n c l o s i n g t r i a n g l e .
∗l e v e l ( >= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e : = 0 )
∗/
private void drawGasket ( Graphics g , i n t lev , i n t p1X , i n t p1Y ,
i n t p2X , i n t p2Y , i n t p3X , i n t p3Y ){
g . drawLine ( p1X , p1Y , p2X , p2Y ) ; // Draw a t r i a n g l e
g . drawLine ( p2X , p2Y , p3X , p3Y ) ;
g . drawLine ( p3X , p3Y , p1X , p1Y ) ;
i f( lev>0){// I f m o r e l e v e l s , d r a w 3 s m a l l e r g a s k e t s
i n t q1X = ( p1X + p2X ) / 2 ; i n t q1Y = ( p1Y + p2Y ) / 2 ;
i n t q2X = ( p1X + p3X ) / 2 ; i n t q2Y = ( p1Y + p3Y ) / 2 ;
i n t q3X = ( p2X + p3X ) / 2 ; i n t q3Y = ( p2Y + p3Y ) / 2 ;
drawGasket ( g , lev −1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;
drawGasket ( g , lev −1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;
drawGasket ( g , lev −1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;
}// i f
}// d r a w G a s k e t ( )
✡ ✠
Figure 12.25: The drawGasket() method.
gaskets within the triangle. Again we will use a level parameter to con-
trol the depth of the recursion. The higher the level, the mor e divisions
will be drawn.
If we’re going to draw a triangle shape, we need the coordinate s of its What other parameters do we need?
three vertices—that is, an x-and y-coordinate for each vertex. Taken to-
gether, these design considerations suggest the method deﬁ nition shown
in Figure 12.25.
As we described earlier, we use the level parameter as the recursion
parameter for this method, which controls the recursion. No te that each Levels of recursion
of the three recursive calls decreases the level by 1. This will ensure that
eventually level will equal 0, and recursion will stop.
Note also how the three pairs of coordinates are used. Drawin g a tri-
angle is simple. Just draw three lines from (p1X,p1Y) to(p2X,p2Y) ,
from(p2X,p2Y) to(p3X,p3Y) , and from (p3X,p3Y) back to (p1X,
p1Y) . The most complicated part of the method is calculating the v ertices
for the three inner gaskets. If you look at Figure 12.24 again, you’ll no-
tice that each of the inner triangles uses one of the vertices of the main
triangle, plus the midpoints of the two adjacent sides. Thus, the triangle
on the “left” uses the left vertex (p1X,p1Y) , and the midpoints of the
other two lines from (p1X,p1Y) to(p2X,p2Y) and from (p1X,p1Y) to
(p3X,p3Y) . As you might remember from high school math, the formula
for computing the midpoint of the line segment (x1,y1)to(x2,y2)is Midpoint of a line
☛ ✟
( ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 )
✡ ✠
This formula is used repeatedly to calculate the vertices of the three
smaller gaskets.
SECTION 12.6 •OBJECT-ORIENTED DESIGN: Tail Recursion 587
12.6 OBJECT-ORIENTED DESIGN:
Tail Recursion
Although the drawBoxes() method is relatively simple to convert into
an iterative version (see Self-Study Exercise 12.18), the s ame cannot be said
for the drawGasket() method. It is clearly a case where the recursive
approach makes the problem easier to solve.
One difference between drawBoxes() anddrawGasket() is that
drawBoxes() is an example of a tail-recursive method. A method is tail
recursive if all of its recursive calls occur as the last action perform ed in Tail recursion
the method. You have to be a bit careful about this deﬁnition. The recur-
sive call in a tail-recursive method has to be the last executed statement. It
needn’t be the last statement appearing in the method’s deﬁn ition.
For example, the following method will print “Hello” Ntimes. This
method is tail recursive even though its last statement is no t a recursive
call:
☛ ✟
public void printHello ( i n t N){
i f(N>1){
System . out . p r i n t l n ( ” Hello ” ) ;
printHello (N −1 ) ; // T h e l a s t e x e c u t e d s t a t e m e n t
}else
System . out . p r i n t l n ( ” Hello ” ) ;
}// p r i n t H e l l o ( )
✡ ✠
This method is tail recursive because the last statement tha t will be exe-
cuted, in its recursive cases, is the recursive call.
A tail-recursive method is relatively easy to convert into a n iterative
method. The basic idea is to make the recursion parameter int o a loop
variable, taking care to make sure the bounds are equivalent . Thus, the
following iterative method will print “Hello” Ntimes:
☛ ✟
public void p r i n t H e l l o I t e r a t i v e ( i n t N){
for (i n t k = N; k >0 ; k−−)
System . out . p r i n t l n ( ” Hello ” ) ;
}
✡ ✠
In this case, we use the parameter Nto set the initial value of the loop vari-
able, k, and we decrement kon each iteration. This is equivalent to what
happens when we decrement the recursion parameter in the rec ursive call.
JAVA EFFECTIVE DESIGN Tail Recursion. Tail-recursive
algorithms are relatively simple to convert into iterative algorithms
that do the same thing.
As you can see, recursive methods that are not tail recursive are much
more complex. Just compare the drawGasket() anddrawBoxes()
methods. Yet it is precisely for these nontail-recursive al gorithms that re-
cursion turns out to be most useful. As you might expect, if yo u can’t
588 CHAPTER 12 •Recursive Problem Solving
give a simple tail-recursive solution to a problem, the prob lem proba-
bly doesn’t have a simple iterative solution either. Thus, t he problems
where we most need recursion are those where we can’t give a si mple
tail-recursive or a simple iterative solution. And there ar e a lot of such
problems, especially when you get into nonlinear data struc tures such as
trees and graphs.
To gain some appreciation for this complexity, consider how difﬁcult it
would be to draw the Sierpinski gasket using an iterative app roach. We
could start by developing an outer for loop to account for the different
levels in the pattern:
☛ ✟
for (i n t k = lev ; k >0 ; k−−){
drawGasket ( g , lev −1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;
drawGasket ( g , lev −1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;
drawGasket ( g , lev −1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;
}
✡ ✠
But now each of the method calls within the body of this loop wo uld have
to be replaced by very complex loops. That would be a daunting task.
So the lesson to be drawn from this observation is that recurs ion is most
useful as a problem-solving technique for problems that don ’t yield to a
simple iterative solution.
JAVA EFFECTIVE DESIGN Recursion or Iteration. If you have
difﬁculty designing an iterative solution to a problem, try developing
a recursive solution to it.
SELF-STUDY EXERCISES
EXERCISE 12.19 Trace the drawGasket() method for levels two and
three. Pick your own values for the three vertices.
EXERCISE 12.20 Is theprintReverse() method, discussed earlier,
tail recursive? Explain.
EXERCISE 12.21 Is thecountChar() method, discussed earlier, tail
recursive? Explain.
12.7 OBJECT-ORIENTED DESIGN:
Recursion or Iteration?
As we mentioned at the outset of this chapter, recursive algo rithms require
more computational overhead than iterative algorithms. We ’re now in a
good position to appreciate why this is so.
A recursive algorithm incurs two kinds of overhead that are n ot in-
curred by an iterative algorithm: memory and CPU time. Both o f these
are direct results of the fact that recursive algorithms do a lot of method
calling.
As we saw in our various traces, each time a method is called, a rep- Method call overhead
resentation of the method call is placed on the method call stack . These
SECTION 7 •OOD: Recursion or Iteration 589
representations often take the form of a block of memory locations, which
can be quite large. The block must contain space for the metho d’s local
variables, including its parameters. Also, unless the meth od isvoid , the
block must contain space for the method’s return value. In add ition it
must contain a reference to the calling method, so it will kno w where to
go when it is done. Figure 12.26 shows what the method call blo ck would Memory overhead
look like for the search() method.
6search()
arr
key
head
calling
method
arr
key
head
calling
method132
8 1 0 10 15 2 32 7 71
search()
032
Figure 12.26: A more detailed
picture of the method call stack,
showing two method blocks for
search() after two levels of re-
cursion.
In addition to the memory required, a method call also require s extra
CPU time. Each time a method is called, Java must create a meth od call CPU overhead
block, copy the method call arguments to the parameters in th e block,
create initial values for any local variables that are used b y the method,
and ﬁll in the return address of the calling method. All of thi s takes time,
and in the case of a recursive method, these steps are repeate d at each
level of the recursion.
Compare these memory and CPU requirements with what normall y
transpires for an iterative algorithm—an algorithm involvi ng a loop. The
loop structure usually occurs entirely within a method, so i t doesn’t incur
either the memory or CPU overhead involved in recursion. The refore,
iterative algorithms are generally more efﬁcient than recu rsive algorithms.
One useful guideline, then, is when runtime performance and efﬁciency
are of prime importance, you should use iteration instead of recursion.
JAVA EFFECTIVE DESIGN Iteration or Recursion. Use an iterative
algorithm instead of a recursive algorithm whenever efﬁcie ncy and
memory usage are important design factors.
On the other hand, recursive algorithms are much easier to de sign than
the corresponding iterative algorithms for many problems. We tried to
illustrate this point in our development of the Sierpinski g asket algorithm,
but there are many other examples that we could have used. Giv en that
programmer and designer time is the most expensive resource involved in Efﬁciency of development
software development, a recursive solution may be easier to develop and
maintain than a corresponding iterative solution. And give n the great cost
of software development, a less efﬁcient solution that is ea sier to develop,
easier to understand, and easier to maintain may be preferab le to a highly
590 CHAPTER 12 •Recursive Problem Solving
efﬁcient algorithm that’s difﬁcult to understand. For some problems then,
such as the Sierpinski gasket, a recursive algorithm may pro vide the best
solution.
JAVA EFFECTIVE DESIGN Keep It Simple. When all other factors
are equal, choose the algorithm (recursive or iterative) th at is easiest to
understand, develop, and maintain.
One ﬁnal point that’s worth making is that some optimizing compilers
are able to convert recursive methods into iterative method s when they
compile the program. The algorithms for doing this are well k nown. They
are often subjects for study in a data structures course, so we won’t go Optimizing compiler
into them here. The resulting runtime programs will be just as efﬁcient, in
CPU time and memory, as if you had written iterative methods. The point
is that if you have such a compiler, you really get the best of b oth worlds.
You get the advantage of using recursion as a problem-solvin g and soft-
ware development approach, and the compiler takes care of pr oducing an
efﬁcient object program.
Special Topic: Exploring the Mandelbrot Set
The Mandelbrot set is one of the most fascinating fractals. It is named after
its discover, IBM mathematician Benoit Mandelbrot. The Mand elbrot set
itself is the black, heart-shaped image shown in Figure 12.2 7. What makes
the Mandelbrot set so interesting is that with the help of a Ja va applet
you can explore the set as if you were taking a trip through out er space.
The most interesting regions to explore are those just along t he boundary
of the set. For example, notice that the boundary contains nu merous cir-
cular shapes, each of which is itself studded with circular s hapes. This
is an example of the scaled self-similarity that we found to b e so preva-
lent in recursive structures. By continually expanding the regions around
the boundary, you’ll ﬁnd an inﬁnite recursion of fascinatin g images and
shapes. In some regions of the set you’ll even ﬁnd miniature re plications
of the set itself.
FIGURE 12.27 The Mandelbrot set.The Mandelbrot set is generated by an iterated function system . The
mathematics underlying this fascinating object is quite acc essible, and
there are a number of online tutorials that explain how the se t is generated
and how the pictures are produced. Many of the Mandelbrot and fractal
Web sites contain excellent Java applets that let you explor e the Mandel-
brot set as well as related sets. An excellent place to start y our exploration
would be David Joyce’s award-winning Web site,
☛ ✟
http : //aleph0 . clarku . edu/˜ djoyce/ j u l i a /
✡ ✠
which contains references to a number of other good sites. Fo r a tutorial
on how the various Mandelbrot set-generating Java programs work, see
☛ ✟
http : //storm . shodor . org/mteach/
✡ ✠
SECTION 12.8 •From the Java Library: javax.swing.JComboBox 591
12.8 From the Java Library:
javax.swing.JComboBox
AJComboBox is a Swing component that combines a text ﬁeld and
a drop-down list (Fig. 12.28). It lets the user either type in a selec-
tion or choose a selection from a list that appears when the us er re-
quests it—a JComboBox ’s drop-down behavior is somewhat similar to a
java.awt.Choice box.
JComponent
+JComboBox()
+JComboBox(in items[] : Object)
+JComboBox(in items : Vector)
+addActionListener(in l : ActionListener)
+addItem(in item : Object)
+addItemListener(in l : ItemListener)
+getItemAt(in index : int) : Object
+getSelectedItem() : Object
+setSelectedIndex(in index : int)
+setSelectedItem(in item : Object)JComboBox«interface»
ActionListener«interface»
ItemListener«interface»
ItemSelectable
FIGURE 12.28 AJComboBox
responds to action events and item
events.AJComboBox can be used to represent a drop-down menu . When the
user clicks on a JComboBox , a list of options drops down, and the user
can select a particular option that is stored in the box’s int ernal state
(Fig. 12.29). The list of options associated with a JComboBox can be built
beforehand and inserted into the component in a constructor , or items can
be inserted one at a time by repeatedly using its addItem() method.
As Figure 12.28 shows, either an array or a vector of items can be passed
to a constructor method to initialize the box’s menu. The ite ms stored in a
JComboBox box are references to Object s, most commonly String s that
represent the name of the menu item. They are stored in the (ze ro indexed)
order in which they are added. The addItem() method is used to add an
individual Object to aJComboBox . By default, the ﬁrst item added to a
JComboBox will be the selected item until the user selects another item.
When the user makes a selection in a JComboBox , the item selected
can be gotten either by its reference ( getSelectedItem() ) or by its po-
sition within the menu ( getSelectedIndex() ). There are also meth-
ods to setSelectedItem() andsetSelectedIndex() that let you
select an individual item either by its reference or its posi tion. The
addItemListener() method is used to designate some object as the
listener for the ItemEvent s that are generated whenever the user selects
a menu option. Alternatively, the addActionListener() method lets
you handle action events, such as when the user types a value i nto the
box.
12.8.1 A JComboBox Example
As a simple example, let’s design an applet interface that ca n be used
to display the fractal patterns we developed earlier. We wan t an inter-
face that lets the user select from among the available patte rns—we’ll use
the Sierpinski gasket and nested boxes for starters. In addit ion, the user
should also be able to select different levels for the drawin gs, from 0 to 9.
We want to present these options in two menus, with one JComboBox for
each menu.
The ﬁrst step is to declare and instantiate the JComboBox es as instance
variables:
☛ ✟
private S t r i n g items [ ] =
{” S i e r p i n s k i Gasket ” ,”Nested Boxes” };
private JComboBox p a t t e r n s = new JComboBox ( items ) ;
private JComboBox l e v e l s = new JComboBox ( ) ;
✡ ✠
Note that in this case we pass the constructor for the patterns menu
FIGURE 12.29 Using a JComboBox
box.
592 CHAPTER 12 •Recursive Problem Solving
an entire array of items. If we hadn’t done it this way, we would add
individual items to the combo box in the applet’s init() method. In
fact, that’s how we’ll initialize the levels menu:
☛ ✟
for (i n t k =0; k <1 0 ; k++) // Add 1 0 l e v e l s
l e v e l s . addItem ( k + ”” ) ;
l e v e l s . s e t S e l e c t e d I t e m ( ”4” ) ; // S e l e c t d e f a u l t l e v e l
✡ ✠
This loop would be placed in the applet’s init() method. It adds strings
representing levels 0 to 9 to the menu and initializes the box so that level
four is showing as the default option.
Our next step is to designate the applet as the ItemListener for both
menus—that is, the applet is named as the object that will handl e the
events that occur in the JComboBox es. Then we add the JComboBox
component to the applet’s window:
☛ ✟
c o n t r o l s . add ( l e v e l s ) ; // C o n t r o l p a n e l f o r m e n u s
c o n t r o l s . add ( p a t t e r n s ) ;
// Add t h e c o n t r o l s
getContentPane ( ) . add ( controls , ”North” ) ;
// And t h e d r a w i n g p a n e l
getContentPane ( ) . add ( canvas , ” Center ” ) ;
// R e g i s t e r t h e m e n u s w i t h a l i s t e n e r
l e v e l s . addItemListener ( t h i s ) ;
p a t t e r n s . addItemListener ( t h i s ) ;
✡ ✠
Note that we use a separate controls panel (a JPanel ) for the two
menus and a canvas panel (another JPanel ) for the drawings.
The next step is to implement the itemStateChanged() method to
handle the user’s selections. Whenever the user selects an it em from a
JComboBox menu, an ItemEvent is generated. In order to handle these
events, the applet must implement the ItemListener interface, which
consists of the single method itemStateChanged() . This method is
invoked automatically whenever the user selects an item fro m one of the
JComboBox es:
☛ ✟
public void itemStateChanged ( ItemEvent e ) {
canvas . s e t P a t t e r n ( p a t t e r n s . getSelectedIndex ( ) ,
l e v e l s . getSelectedIndex ( ) ) ;
r e p a i n t ( ) ;
}
✡ ✠
TheitemStateChanged() method has the same general form as
theactionPerformed() method, except that its parameter is an
ItemEvent . For this example, the program uses the getSelected-
Index() method to get the selected pattern and the selected level by
their respective item numbers within the menus. It then passe s these
values along to the canvas object, which takes care of the drawing. Fi-
nally, the method invokes the repaint() method. Because the applet is
a container, this will cause all of its components to be repai nted as well.
SECTION 12.8 •From the Java Library: javax.swing.JComboBox 593
Userapplet : ItemListener
: Canvas
selectJVM
SelectEvent
itemStateChanged(e:ItemEvent)
setPattern(): JComboBoxFigure 12.30: This UML sequence
diagram shows the interaction
between the various objects in-
cluded in the action of selecting an
item from a JComboBox .
Figure 12.30 illustrates the sequence of events that occurs when an
item is selected from a JComboBox . The complete implementation for
the applet is given in Figure 12.31.
☛ ✟
import java . awt . ∗;
import javax . swing . ∗;
import java . awt . event . ∗;
public c l a s s RecursivePatterns extends JApplet implements ItemListener {
private S t r i n g choices [ ] = {” S i e r p i n s k i Gasket ” ,”Nested Boxes” };
private JComboBox p a t t e r n s = new JComboBox ( choices ) ; // P a t t e r n c h o i c e s
private JComboBox l e v e l s = new JComboBox ( ) ; // L e v e l c h o i c e s
private Canvas canvas = new Canvas ( ) ; // D r a w i n g p a n e l
private JPanel c o n t r o l s = new JPanel ( ) ;
public void i n i t ( ) {
for (i n t k =0; k <1 0 ; k++) // Add 1 0 l e v e l s
l e v e l s . addItem ( k + ”” ) ;
p a t t e r n s . s e t S e l e c t e d I t e m ( choices [ 0 ] ) ; // I n i t i a l i z e m e n u s
l e v e l s . s e t S e l e c t e d I t e m ( ”4” ) ;
canvas . setBorder ( BorderFactory . c r e a t e T i t l e d B o r d e r ( ”Drawing Canvas” ) ) ;
c o n t r o l s . add ( l e v e l s ) ; // C o n t r o l p a n e l f o r m e n u s
c o n t r o l s . add ( p a t t e r n s ) ;
getContentPane ( ) . add ( controls , ”North” ) ; // Add c o n t r o l s
getContentPane ( ) . add ( canvas , ” Center ” ) ; // Add d r a w i n g p a n e l
l e v e l s . addItemListener ( t h i s ) ; // R e g i s t e r m e n u s w i t h l i s t e n e r
p a t t e r n s . addItemListener ( t h i s ) ;
s e t S i z e ( canvas .WIDTH, canvas .HEIGHT+ c o n t r o l s . g e t S i z e ( ) . width ) ;
}// i n i t ( )
public void itemStateChanged ( ItemEvent e ) {
canvas . s e t P a t t e r n ( p a t t e r n s . getSelectedIndex ( ) ,
l e v e l s . getSelectedIndex ( ) ) ;
r e p a i n t ( ) ; // R e p a i n t t h e a p p l e t
}// i t e m S t a t e C h a n g e d ( )
}// R e c u r s i v e P a t t e r n s
✡ ✠
Figure 12.31: The RecursivePatterns applet.
594 CHAPTER 12 •Recursive Problem Solving
Figure 12.32: Design of a drawing
Canvas class.
The actual drawing of the fractal patterns is handled by the canvas
JPanel component, whose design is shown in Figure 12.32 and whose
implementation is given in Figure 12.33. All of the drawing i s done
in the paintComponent() method. Because the canvas is contained
within the applet, the paintComponent() method is called automati-
cally whenever the applet repaints itself. Notice how the switch state-
ment uses the pattern that the user chose to call the correspo nding draw- Zero indexing
ing method. You can see from this switch statement that a JComboBox ’s
items are zero indexed .
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
public c l a s s Canvas extends JPanel {
private s t a t i c f i n a l i n t GASKET = 0 , BOXES = 1 ;
public s t a t i c f i n a l i n t WIDTH=400 , HEIGHT=400;
private f i n a l i n t HBOX=10 , VBOX=50 , BOXSIDE=200 , BOXDELTA=10;
private f i n a l i n t gP1X = 1 0 ; private f i n a l i n t gP1Y = 2 8 0 ; // I n i t i a l
private f i n a l i n t gP2X = 2 9 0 ; private f i n a l i n t gP2Y = 2 8 0 ; // g a s k e t
private f i n a l i n t gP3X = 1 5 0 ; private f i n a l i n t gP3Y = 1 1 0 ; // p o i n t s
private i n t pattern = 0 ; // C u r r e n t p a t t e r n
private i n t l e v e l = 4 ; // C u r r e n t l e v e l
public Canvas ( ) {
s e t S i z e (WIDTH, HEIGHT ) ;
}
public void s e t P a t t e r n ( i n t pat , i n t lev ){
pattern = pat ;
l e v e l = lev ;
}
✡ ✠
Figure 12.33: The Canvas class is a drawing panel, Part I.
SECTION 12.8 •From the Java Library: javax.swing.JComboBox 595
☛ ✟
public void paintComponent ( Graphics g ) {
g . setColor ( getBackground ( ) ) ; // R e d r a w t h e p a n e l ’ s b a c k g r o u n d
g . drawRect ( 0 , 0 , WIDTH, HEIGHT ) ;
g . setColor ( getForeground ( ) ) ;
switch ( pattern ) {
case GASKET:
drawGasket ( g , l e v e l , gP1X , gP1Y , gP2X , gP2Y , gP3X , gP3Y ) ;
break ;
case BOXES :
drawBoxes ( g , l e v e l , HBOX, VBOX, BOXSIDE , BOXDELTA ) ;
break ;
}// s w i t c h
}// p a i n t C o m p o n e n t ( )
/∗∗ d r a w G a s k e t () −−− r e c u r s i v e l y d r a w s t h e S i e r p i n s k i
∗ g a s k e t p a t t e r n , w i t h p o i n t s ( p1X , p 1 Y ) , ( p2X , p 2 Y ) , ( p3X , p 3 Y )
∗ r e p r e s e n t i n g t h e v e r t i c e s o f i t s e n c l o s i n g t r i a n g l e .
∗l e v e l ( >= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e c a s e : l e v e l 0 )
∗/
private void drawGasket ( Graphics g , i n t lev , i n t p1X , i n t p1Y ,
i n t p2X , i n t p2Y , i n t p3X , i n t p3Y ){
g . drawLine ( p1X , p1Y , p2X , p2Y ) ; // Draw a t r i a n g l e
g . drawLine ( p2X , p2Y , p3X , p3Y ) ;
g . drawLine ( p3X , p3Y , p1X , p1Y ) ;
i f( lev>0){// I f m o r e l e v e l s , d r a w 3 s m a l l e r g a s k e t s
i n t q1X = ( p1X + p2X ) / 2 ; i n t q1Y = ( p1Y + p2Y ) / 2 ;
i n t q2X = ( p1X + p3X ) / 2 ; i n t q2Y = ( p1Y + p3Y ) / 2 ;
i n t q3X = ( p2X + p3X ) / 2 ; i n t q3Y = ( p2Y + p3Y ) / 2 ;
drawGasket ( g , lev −1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;
drawGasket ( g , lev −1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;
drawGasket ( g , lev −1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;
}
}// d r a w G a s k e t ( )
/∗∗ d r a w B o x e s () −−− r e c u r s i v e l y d r a w s p a t t e r n o f n e s t e d s q u a r e s
∗ w i t h ( l o c X , l o c Y ) t h e t o p l e f t c o r n e r o f o u t e r t h e s q u a r e a n d
∗ s i d e b e i n g t h e l e n g t h s q u a r e ’ s s i d e .
∗l e v e l ( >= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e c a s e : l e v e l 0 )
∗d e l t a i s u s e d t o a d j u s t t h e l e n g t h o f t h e s i d e .
∗/
private void drawBoxes ( Graphics g , i n t l e v e l ,
i n t locX , i n t locY , i n t side , i n t d e l t a ) {
g . drawRect ( locX , locY , side , side ) ;
i f( l e v e l >0){
i n t newLocX = locX + d e l t a ; i n t newLocY = locY + d e l t a ;
drawBoxes ( g , l e v e l −1 , newLocX , newLocY ,
side−2∗delta , d e l t a ) ;
}
}// d r a w B o x e s ( )
}// C a n v a s
✡ ✠
Figure 12.33: The Canvas class, Part II.
596 CHAPTER 12 •Recursive Problem Solving
CHAPTER SUMMARY Technical Terms
base case
computational
overhead
head-and-tail
algorithmiterative method
last-in-ﬁrst-out
(LIFO)
method call stack
recursion parameterrecursive case
recursive deﬁnition
recursive method
self-similarity
tail recursive
Summary of Important Points
•Arecursive deﬁnition is one that deﬁnes the nth case of a concept in
terms of the (n−1)st case plus a limiting condition. It is based on the
idea of breaking a problem up into smaller, self-similar pro blems.
•Arecursive method is one that calls itself. It is usually deﬁned in terms of
abase case or limiting case, which stops the recursive process, and a re -
cursive case, which breaks the method into a smaller, self-s imilar copy
of itself. A recursion parameter is generally used to control the recursion.
•An iterative algorithm is one that uses some kind of loop as it s control
structure. Any algorithm that can be done iteratively can al so be done
recursively, and vice versa.
•Because method calling is relatively costly both in terms of memory
used and CPU time involved, a recursive algorithm is general ly less
efﬁcient than an iterative one that does the same thing.
•In designing recursive algorithms, the base case deﬁnes a limit. Each
level of recursion should make progress toward the limit, an d the algo-
rithm should eventually reach the limit. The limit is usuall y expressed
in terms of the recursion parameter .
•A recursive method is tail recursive if and only if each of its recursive
calls is the last action executed by the method.
•A Swing JComboBox component is used to represent a GUI drop-
down menu.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 12.1 The output produced by mystery(0) would be 0 1 2 3 4 5 6.
The output produced by mystery(100) would be 100.
SOLUTION 12.2 The output produced by mystery(5) would be: 5 4 3, and so
on. In other words, this is an inﬁnite recursion.
SOLUTION 12.3
☛ ✟
D e f i n i t i o n : twoToN(N) , N >= 0
1 ,i fN == 0 // B a s e c a s e
2∗twoToN(N −1 ) , N >0 // R e c u r s i v e c a s e
✡ ✠
CHAPTER 12 •Solutions to Self-Study Exercises 597
SOLUTION 12.4 The function xnis known as the power function:
☛ ✟
D e f i n i t i o n : power (X ,N) , N >= 0
1 ,i fN == 0 // B a s e c a s e
X∗power (X , N −1 ) , N >0 // R e c u r s i v e c a s e
✡ ✠
SOLUTION 12.5 Yes, the two deﬁnitions for nested boxes are equivalent. Sup-
pose the square starts out with a side of 20. The deﬁnition given in the exercise
will also draw squares with sides of 20, 15, 10, 5.
SOLUTION 12.6 A recursive deﬁnition for the pattern in Figure 12.4:
☛ ✟
Draw a square with side , s .
I n s c r i b e a c i r c l e with diameter , s .
I f s>5 ,
Draw a smaller version of same pattern . // R e c u r s i v e c a s e
✡ ✠
SOLUTION 12.7 TheprintString2("hello") method will print: “olleh.”
SOLUTION 12.8 A deﬁnition for countDown() :
☛ ✟
/∗∗ c o u n t D o w n ( N ) r e c u r s i v e l y p r i n t s a c o u n t d o w n
∗ b e g i n n i n g a t N a n d e n d i n g a t 1
∗@ p a r a m N >= 1
∗B a s e c a s e : N == 0
∗/
void countDown ( i n t N){
i f(N == 0) // B a s e c a s e
System . out . p r i n t l n ( ” b l a s t o f f ” ) ;
else{
System . out . p r i n t (N + ” , ” ) ; // R e c u r s i v e c a s e
countDown (N −1 ) ;
}
}// c o u n t D o w n ( )
✡ ✠
SOLUTION 12.9 A revised deﬁnition for countDown() :
☛ ✟
/∗∗ c o u n t D o w n ( N ) r e c u r s i v e l y p r i n t s a c o u n t d o w n
∗ b e g i n n i n g a t N , c o u n t i n g e v e r y o t h e r n u m b e r , 1 0 8 6 . . .
∗ a n d e n d i n g a t ” b l a s t o f f ”
∗@ p a r a m N >= 1
∗B a s e c a s e : N <= 0
∗/
void countDown ( i n t N){
i f(N<= 0) // B a s e c a s e
System . out . p r i n t l n ( ” b l a s t o f f ” ) ;
else{
System . out . p r i n t (N + ” , ” ) ; // R e c u r s i v e c a s e
countDown (N −2 ) ;
}
}// c o u n t D o w n ( )
✡ ✠
598 CHAPTER 12 •Recursive Problem Solving
SOLUTION 12.10 A method to sum the numbers from 1 to N.
☛ ✟
i n t sum( i n t N){
i f(N == 0)
return 0 ;
else
return N + sum(N −1);
}
✡ ✠
SOLUTION 12.11 A method to change each blank within a string to two blanks.
☛ ✟
S t r i n g addBlanks ( S t r i n g s ) {
i f( s . length ( ) == 0)
return ””;
else i f ( s . charAt ( 0 ) == ’ ’)
return ’ ’ + s . charAt ( 0 ) + addBlanks ( s . substring ( 1 ) ) ;
else
return s . charAt ( 0 ) + addBlanks ( s . substring ( 1 ) ) ;
}
✡ ✠
SOLUTION 12.12 A method to print out all possible outcomes for a chess player
playing Ngames. printOutcomes(str, N) will print all outcomes for the next
Ngames given that results for previous games are stored in the str ing named str.
☛ ✟
public s t a t i c void printOutcomes ( S t r i n g s t r , i n t N){
i f(N = 1) {// B a s e c a s e : win , l o s e , o r d r a w o n e g a m e
System . out . p r i n t l n ( s t r + ” W ” ) ;
System . out . p r i n t l n ( s t r + ”L” ) ;
System . out . p r i n t l n ( s t r + ”D” ) ;
}else{ // R e c u r s i v e c a s e
printOutcomes ( s t r + ” W ” , N−1 ) ;
printOutcomes ( s t r + ”L” , N−1 ) ;
printOutcomes ( s t r + ”D” , N−1 ) ;
}// e l s e
}// p r i n t O u t c o m e s ( )
✡ ✠
SOLUTION 12.13
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
i n t numbers [ ] = {0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 1 8 };
Searcher searcher = new Searcher ( ) ;
for (i n t k = 0 ; k <= 2 0 ; k++) {
i n t r e s u l t = searcher . search ( numbers , k ) ;
i f( r e s u l t != −1)
System . out . p r i n t l n ( k + ” found at ” + r e s u l t ) ;
else
System . out . p r i n t l n ( k + ” i s not in the array ” ) ;
}// f o r
}// m a i n ( )
✡ ✠
CHAPTER 12 •Solutions to Self-Study Exercises 599
SOLUTION 12.14 Thesort() method is used as a public interface to the recur-
siveselectionSort() method:
☛ ✟
/∗∗ s o r t ( a r r ) s o r t s t h e i n t a r r a y , a r r
∗ P r e : a r r i s n o t n u l l
∗ P o s t : a r r w i l l b e a r r a n g e d s o t h a t a r r [ j ] <= a r r [ k ]
∗ f o r a n y j <k
∗/
public void s o r t ( i n t a r r [ ] ) {
s e l e c t i o n S o r t ( arr , a r r . length −1 ) ;
// J u s t c a l l t h e r e c u r s i v e m e t h o d
}
✡ ✠
SOLUTION 12.15 An iterative version of findMax() :
☛ ✟
/∗∗ f i n d M a x ( a r r , N ) r e t u r n s t h e i n d e x o f t h e l a r g e s t
∗ v a l u e b e t w e e n a r r [ 0 ] a n d a r r [ N ] , N >= 0 .
∗ P r e : 0 <= N<= a r r . l e n g t h −1
∗ P o s t : a r r [ f i n d M a x ( ) ] >= a r r [ k ] f o r k b e t w e e n 0 a n d N .
∗/
private i n t findMax ( i n t a r r [ ] , i n t N){
i n t maxSoFar = 0 ;
for (i n t k = 0 ; k <= N; k++)
i f( a r r [ k ] >a r r [ maxSoFar ] )
maxSoFar = k ;
return maxSoFar ;
}// f i n d M a x ( )
✡ ✠Level  4
Level  5
FIGURE 12.34 Levels four and ﬁve
of the nested boxes pattern.
SOLUTION 12.16 Levels four and ﬁve of the nested boxes pattern are shown in
Figure 12.34.
SOLUTION 12.17 The following method will reduce the length of the side by
delta percent at each level of recursion. The spacing between the boxe s will vary
by a constantly decreasing amount.
☛ ✟
private void drawBoxes ( Graphics g , i n t l e v e l , i n t locX ,
i n t locY , i n t side , i n t d e l t a ) {
g . drawRect ( locX , locY , side , side ) ;
i f( l e v e l >0){
i n t dside = side ∗d e l t a / 1 0 0 ; // P e r c e n t d e l t a
i n t newLocX = locX + dside ;
i n t newLocY = locY + dside ;
drawBoxes ( g , l e v e l −1 , newLocX , newLocY ,
side−2∗dside , d e l t a ) ;
}
}// d r a w B o x e s ( )
✡ ✠
600 CHAPTER 12 •Recursive Problem Solving
Figure 12.35: Levels two and three
of the Sierpinski gasket.
SOLUTION 12.18
☛ ✟
private void drawBoxesIterative ( Graphics g , i n t l e v e l ,
i n t locX , i n t locY , i n t side , i n t d e l t a ) {
for (i n t k = l e v e l ; k >= 0 ; k−−){
g . drawRect ( locX , locY , side , side ) ; // Draw a s q u a r e
locX += d e l t a ; // C a l c u l a t e new l o c a t i o n
locY += d e l t a ;
side−= 2∗d e l t a ; // C a l c u l a t e new s i d e l e n g t h
}
}// d r a w B o x e s ( )
✡ ✠
SOLUTION 12.19 The level two and three gaskets are shown in Figure 12.35.
SOLUTION 12.20 TheprintReverse() method is not tail recursive because
in that method the recursive call is not the last statement exec uted.
SOLUTION 12.21 ThecountChar() method is tail recursive. The recursive
calls are not the last statements in the method deﬁnition. Howeve r, each of the
recursive calls would be the last statement executed by the me thod.
EXERCISES EXERCISE 12.1 Explain the difference between the following pairs of terms:
a.Iteration and recursion .
b.Recursive method and recursive deﬁnition .
c.Base case and recursive case .
d.Head and tail.
e.Tailand nontail recursive.
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 12.2 Describe how the method call stack is used during a method call
and return.
EXERCISE 12.3 Why is a recursive algorithm generally less efﬁcient than an
iterative algorithm?
EXERCISE 12.4 A tree, such as a maple tree or pine tree, has a recursive struc-
ture. Describe how a tree’s structure displays self-similarity and divisibility .
EXERCISE 12.5 Write a recursive method to print each element of an array of
double .
EXERCISE 12.6 Write a recursive method to print each element of an array of
double from the last to the ﬁrst element.
EXERCISE 12.7 Write a recursive method that will concatenate the elements of
an array of String into a single String delimited by blanks.
CHAPTER 12 •Exercises 601
EXERCISE 12.8 Write a recursive method that is passed a single int parameter,
N≥0, and prints all the odd numbers between 1 and N.
EXERCISE 12.9 Write a recursive method that takes a single int parameter
N≥0and prints the sequence of even numbers between Ndown to 0.
EXERCISE 12.10 Write a recursive method that takes a single int parameter
N≥0and prints the multiples of 10 between 0 and N.
EXERCISE 12.11 Write a recursive method to print the following geometric
pattern:
☛ ✟
#
# #
# # #
# # # #
# # # # #
✡ ✠
EXERCISE 12.12 Write recursive methods to print each of the following
patterns.
☛ ✟
# # # # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # #
# # # # # # # #
# # # # # #
# # # #
# #
✡ ✠
EXERCISE 12.13 Write a recursive method to print all multiples of Mup to
M*N.
EXERCISE 12.14 Write a recursive method to compute the sum of grades stored
in an array.
EXERCISE 12.15 Write a recursive method to count the occurrences of a sub-
string within a string.
EXERCISE 12.16 Write a recursive method to remove the HTML tags from a
string.
EXERCISE 12.17 Implement a recursive version of the Caesar.decode()
method from Chapter 8.
EXERCISE 12.18 The Fibonacci sequence (named after the Italian mathemati-
cian Leonardo of Pisa, ca. 1200) consists of the numbers 0,1,1,2,3,5,8,13,...
in which each number (except for the ﬁrst two) is the sum of the two preced-
ing numbers. Write a recursive method fibonacci(N) that prints the ﬁrst N
Fibonacci numbers.
EXERCISE 12.19 Write a recursive method to rotate a String byNcharacters
to the right. For example, rotateR("hello", 3) should return “llohe.”
EXERCISE 12.20 Write a recursive method to rotate a String byNcharacters
to the left. For example, rotateL("hello", 3) should return “lohel.”
602 CHAPTER 12 •Recursive Problem Solving
EXERCISE 12.21 Write a recursive method to convert a String representing a
binary number to its decimal equivalent. For example, binTodecimal("101011")
should return the int value 43.
EXERCISE 12.22 A palindrome is a string that is equal to its reverse—“mom,”
“i,” “radar” and “able was i ere i saw elba.” Write a recursive boolean method
that determines whether its String parameter is a palindrome.
FIGURE 12.36 A level-four binary
tree pattern.EXERCISE 12.23 Challenge: Incorporate a drawBinaryTree() method into
theRecursivePatterns program. A level-one binary tree has two branches.
At each subsequent level, two smaller branches are grown from t he endpoints of
every existing branch. The geometry is easier if you use 45-deg ree angles for the
branches. Figure 12.36 shows a level-four binary tree drawn up side down.
EXERCISE 12.24 Challenge: Towers of Hanoi. According to legend, some Bud-
dhist monks were given the task of moving 64 golden disks from one dia mond
needle to another needle, using a third needle as a backup. To b egin with, the
disks were stacked one on top of the other from largest to smallest (F ig. 12.37).
The rules were that only one disk can be moved at a time and that a la rger disk
can never go on top of a smaller one. The end of the world was supposed to occur
when the monks ﬁnished the task!
Write a recursive method, move(int N, char A, char B, char C) , that
will print out directions the monks can use to solve the towers of Han oi problem.
For example, here’s what it should output for the three-disk case, move(3, "A",
"B", "C") :A B C
FIGURE 12.37 The towers of Hanoi
problem. Move all the disks from
needle A to needle B. Only one disk
can be moved at a time, and a larger
disk can never go on top of a smaller
one.☛ ✟
Move 1 disk from A to B .
Move 1 disk from A to C.
Move 1 disk from B to C.
Move 1 disk from A to B .
Move 1 disk from C to A.
Move 1 disk from C to B .
Move 1 disk from A to B .
✡ ✠
OBJECTIVES
After studying this chapter, you will
•Gain more experience with the Swing component set.
•Understand the relationship between the AWT and Swing.
•Learn more about Java’s event model.
•Be able to design and build useful Graphical User Interfaces ( GUIs).
•Appreciate how object-oriented design principles were used to extend Java’s GUI capabilities.
OUTLINE
13.1 Introduction
13.2 Java GUIs: From AWT to Swing
13.3 The Swing Component Set
13.4 Object-Oriented Design: Model-View-Controller Archi tecture
13.5 The Java Event Model
13.6 Case Study: Designing a Basic GUI
13.7 Containers and Layout Managers
13.8 Checkboxes, Radio Buttons, and Borders
13.9 Menus and Scroll Panes
Special Topic: Are Computers Intelligent?
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 13
Graphical User Interfaces
603
604 CHAPTER 13 •Graphical User Interfaces
13.1 Introduction
As we have seen, a Graphical User Interface (GUI) creates a certain way of
interacting with a program. It is what gives a program its look and feel .
In preceding chapters, we have already used the basic compone nts from
which GUIs are created, including buttons, text ﬁelds, label s, and text
areas. Throughout this chapter, we will focus on designing a nd build-
ing GUIs that are easy for users to navigate. However, Java’s GU I li-
braries are so large that we will concentrate on only a handfu l of addi-
tional components, including containers, check boxes, rad io buttons, and
menus.
We will try to identify design principles that can be applied to the de-
sign of more advanced interfaces. Also, because Java’s GUI c lasses pro-
vide an excellent example of object-oriented design, we will highlight
some of the important design decisions and principles that h ave inﬂu-
enced the development of Java’s GUI classes in both the AWT and Swing.
Let’s begin with a brief history Java’s GUI libraries.
13.2 Java GUIs: From AWT to Swing
java.sun.com/j2se/1.5.0/docs/api/EVER SINCE THE RELEASE of version 1.2 of the Java Development Kit
(JDK) in 2000, Java has contained two distinct libraries of G UI compo-
nents. The Abstract Windowing Toolkit (AWT) has been part of Java since
the original 1.0 version of the JDK 1.0. The more advanced Swing compo-
nent set was ﬁrst introduced in JDK 1.1 and was extensively revised in JDK
1.2.
Although the original version of the AWT was suitable for deve loping
Java applets, it wasn’t powerful enough to support full-ﬂedg ed applica-
tions. Commonly used programs, such as word processors and s pread-
sheets, have GUI requirements that were just too much for the o riginal
AWT. The main problem was that the AWT was dependent on the under -
lying operating system. That meant that Java GUI programs we re forced
to rely on GUI elements that were part of the underlying opera ting system.
A Java GUI program running on a Windows platform had to depend on
Windows code for implementations of its buttons and text ﬁel ds. A Java
program running on Unix depended upon underlying Unix code f or its
GUI components. Such dependence on the underlying operatin g system
made the AWT less portable and less efﬁcient.
In contrast, the Swing GUI components are part of the Java Foundation
Classes (JFC) , a collection of classes that do not depend as much on the
underlying platform. The Swing library makes it possible to write GUI
programs entirely in Java. Because they are rendered entire ly by Java
code, Swing components make it possible to design GUIs that ar e truly
platform independent. Such programs are much more portable than those
which rely on AWT components and the underlying platform. A pr ogram
that uses Swing components will have the same look and feel on a Mac,
Windows, or Unix platform.
SECTION 13.2 •Java GUIs: From AWT to Swing 605
java.appletjava.awtjava.lang
Object
Component
Container
WindowDialog
PanelJWindowJFrame
JDialog
JAppletjavax.swing
AppletFrameFigure 13.1: Swing classes, part
1: Relationship between the AWT
and the top-level Swing win-
dows. REVISION: JWindow ex-
tendsWindow .
13.2.1 Heavyweight Versus Lightweight Components
AWT components are based on the peer model , a design in which every
AWT component has a corresponding class (a peer) written in the underly-
ing system’s code. For example, the java.awt.Button class has a peer The AWT peer model
named java.awt.peer.Button . The peer class serves as the interface
between the Java code and the computer’s underlying windowi ng system.
The methods in the peer class are written in so-called native code–that is,
the non-Java code of the underlying operating system. There fore, AWT
components are inherently platform dependent.
AWT components are called heavyweight because they depend on the
native (peer) system for their drawing and rendering. Since every AWT
component has an associated peer component, a Java AWT compon ent
would look just like the peer component. This is why an AWT butto n on
a Windows platform looks just like a Windows button. In effect, the AWT
button, via its peer, creates and uses a Windows button. When y ou change
the Java button’s label, it must call a method in the peer clas s that changes
the label of the peer button. This interaction between Java a nd the native
windowing system requires a good deal of overhead, thereby a ffecting the
overall efﬁciency of the system.
By contrast, a lightweight component is one that is written entirely
in Java. Instead of depending on a native component for its ren dering, Lightweight components
a lightweight component is drawn and rendered entirely by Ja va code.
Because they do not depend on underlying system code, Swing c om-
ponents are more efﬁcient and more portable than correspond ing AWT
components.
Figures 13.1 and 13.2 show the relationship between AWT and Sw ing
classes. The top-level Swing classes—the JApplet ,JDialog ,JFrame ,
andJWindow —are direct subclasses of their corresponding AWT coun-
606 CHAPTER 13 •Graphical User Interfaces
Figure 13.2: Swing classes, part
2: Swing GUI components are de-
rived from the JComponent class. Object
Component
Container
JLabel
JPanelJScrollPaneJToggleButton
JButton
JMenuItem JMenuJCheckbox
JRadioButton
JTextArea
JTextField JPasswordFieldjava.awtjava.lang
javax.swing
JComponent
JMenuBarJList
JOptionPane
JPopupMenu
JTextComponentAbstractButton
terparts. These are the top-level GUI windows. The remainin g Swing
components (Fig. 13.2) are subclasses of java.awt.Component and
java.awt.Container . As you can see, the names of Swing and AWT
components are very similar. Swing components that have cor responding
AWT components have names that begin with “J.”
One might think that because Swing components are superior t o their
AWT counterparts, the AWT package will eventually be dropped. How-
ever, this is not likely. Even if a Java program uses Swing com ponents
exclusively, that will still not break the dependence on the AWT.
There are several reasons for this dependence. First, Swing ’s top-level
window classes— JApplet ,JDialog ,JFrame , andJWindow —are de-
ﬁned as extensions to their AWT counterparts. This means that Swing-
based GUIs are still dependent on the AWT. Java programs need to have
some way to map their windows to the windowing system used on t he
native (Windows, Unix, or Macintosh) platform. The AWT’s top -level
windows— Window ,Frame ,Dialog , andPanel —provide that map-
ping.
Second, the JComponent class, which is the basis for all Swing com-
ponents, is derived from java.awt.Container . There are many more
such dependencies. Fundamentally, Swing components are ba sed on the
AWT.
Finally, all GUI applications and applets use layout manage rs (java.-
awt.FlowLayout ), fonts ( java.awt.Font ), colors ( java.awt.Color ),
and other non-component classes that are deﬁned in the AWT. Th ere is
SECTION 13.3 •The Swing Component Set 607
just no way to design a GUI without using AWT classes. Therefore , the
programs presented in this and subsequent chapters will use Swing com-
ponents instead of corresponding AWT components, but they al so will
use layouts and other elements from the AWT.
JAVA PROGRAMMING TIP Swing Documentation. Complete
documentation of the Swing classes is available for downloa ding or
browsing on Sun’s Web site at
http://java.sun.com/reference/api/index.html
13.3 The Swing Component Set
Java’s Swing components are deﬁned in a collection of packag es named
javax.swing. *, which is imported by the code shown in this and sub-
sequent chapters. Swing packages include the following:
☛ ✟
javax . swing . event . ∗
javax . swing . t e x t . ∗
javax . swing . p l a f . ∗
✡ ✠
Thejavax.swing.event package deﬁnes the various Swing events and
their listeners, such as the MenuEvent and the MenuListener . (In the
AWT, the AWT events and listeners were deﬁned in java.awt.event .)
Thejavax.swing.text package contains the classes for JTextField
andJTextComponent . The Swing text components are more complex
than their AWT counterparts. For example, one of their import ant features
is the ability to undo changes made to the text they contain. T his feature
is crucial for building sophisticated word-processing app lications.
Thejavax.swing.plaf package contains Swing’s look-and-feel
classes. The term plafis an acronym for pluggable look and feel . It refers Look and feel
to the fact that changing an application’s look and feel is a s imple matter
of “plugging in” a different plaf model. Changing how a progr am looks
does not change what it does.
Swing’s platform-independent look and feel is achieved by p lacing all
the code responsible for drawing a component in a class that i s separate
from the component itself. For example, in addition to JButton , the class
that deﬁnes the button control, there will be a separate clas s responsible
for drawing the button on the screen. The drawing class will c ontrol the
button’s color, shape, and other characteristics of its app earance.
There are several look-and-feel packages built into Swing. For exam-
ple, the javax.swing.plaf.motif package contains the classes that
implement the Motif interface, a common Unix-based interfa ce. The
javax.swing.plaf.windows packages contains classes that support a
Windows look and feel, and the javax.swing.plaf.metal package
provides classes that support the Metal interface, a Java lo ok and feel.
These classes know how to draw each component and how to react to
mouse, keyboard, and other events associated with these com ponents.
608 CHAPTER 13 •Graphical User Interfaces
Figure 13.3: The model-view- con-
troller architecture.
Mouse
Keyboard
Events
Java
Method
CallsControllerUser Interface (UI)
Behavior
monitor
Change
stateView
Outward
appearanceLook
and
feel
Model
Internal
stateState
changed
event
13.4 OBJECT-ORIENTED DESIGN:
Model-View-Controller Architecture
Java’s Swing components have been implemented using an objec t-
oriented design known as the model-view-controller (MVC) model. Any
Swing component can be considered in terms of three independ ent as-
pects: what state it’s in (its model), how it looks (its view) , and what it
does (its controller).
For example, a button’s role is to appear on the interface wai ting to
be clicked. When it is clicked, the button’s appearance chang es. It looks
pushed in or it changes color brieﬂy, and then it changes back t o its orig-
inal (unclicked) appearance. In the MVC model, this aspect of the button
is its view . If you were designing an interface for a button, you would View
need visual representations for both the clicked and the unc licked button
(as well as other possible states).
When you click a button, its internal state changes from press ed to un-
pressed. You’ve also probably seen buttons that were disabl ed—that is,
in a state where they just ignore your clicks. Whether a button i s enabled
or disabled and whether it is pressed or not are properties of its internal Model
state. Taken together, such properties constitute the butt on’s model . Of
course, a button’s view—how it looks—depends on its model. When a
button is pressed, it has one appearance, and when it is disab led, it has
another.
Because a button’s state will change when it is clicked or whe n it is
enabled by the program, some object needs to keep track of thes e changes.
That part of the component is its controller . Controller
Figure 13.3 shows how the button’s model, view, and controll er inter-
act with each other. Suppose the user clicks the button. This action is
detected by the controller. Whenever the mouse button is pres sed, the
controller tells the model to change into the pressed state. The model, in
turn, generates an event that is passed to the view. The event tells the view
that the button needs to be redrawn to reﬂect its change in stat e.
When the mouse button is released, a similar sequence of event s occurs.
The model is told to change to the unpressed state. It in turn ge nerates an
event, handled by the view, which changes the button’s appea rance.
SECTION 13.4 •OBJECT-ORIENTED DESIGN:Model-View-Controller Architectu re609
A change in the button’s appearance does not necessarily dep end on di-
rect action by the user. For example, the program itself coul d call a method
that disables the button. In this case, the program issues a co mmand
directly to the model, which in turn generates an event that c auses the
view to change the object’s appearance.
For some Swing components, such as the text components, this three-
part model is implemented almost exactly as we just described . For others,
such as JButton , one class is used to implement both the view and the
controller. The JButton model is deﬁned in the DefaultButtonModel
class, and its view and controller are deﬁned in the BasicButtonUI class
(TheUIacronym stands for User Interface). The point is that for some
components, Swing has organized the view and control—the loo k and the
feel—into a single class.
13.4.1 Pluggable Look and Feel
The MVC model uses a clear division of labor to implement a GUI com-
ponent. The main advantage of this design is the independenc e between
the model, the view, and the controller. If you want to give a bu tton a
different look and feel, you can redeﬁne its view and its cont roller.
By combining the view and controller into a single class, Swi ng makes
it even easier to change a component’s look and feel. For exam ple, to
design your own look and feel for a JButton , you would deﬁne a class
that implemented all of the methods in the BasicButtonUI . Of course,
this is a job for an experienced software developer.
However, if you just want to set your program to use one of the pre -
deﬁned look and feel models, you can simply use the UIManager.set-
LookAndFeel() method:
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
t r y{
UIManager . setLookAndFeel (
” javax . swing . p l a f . metal . MetalLookAndFeel” ) ;
}catch ( Exception e ) {
System . out . e r r ( ” Exception : ” + e . getMessage ( ) ) ;
}
}// m a i n ( )
✡ ✠
Java’s default, the Metal look and feel, has been designed speciﬁcally for
Java applications. For a Windows look, you can use the follow ing argu-
ment:com.sun.java.swing.plaf.windows.WindowsLookAndFeel .
Figure 13.4 shows how the simple application would appear un der the
FIGURE 13.4 The same Java
application using the Motif,
Windows, and Metal look and feel.three different look-and-feel styles.
SELF-STUDY EXERCISE
EXERCISE 13.1 The MVC architecture is a model of object-oriented de-
sign. But if a JButton is really composed of three separate parts, how can
we still call it a component? Isn’t it really three things?
610 CHAPTER 13 •Graphical User Interfaces
13.5 The Java Event Model
As we saw in Chapter 4, whatever happens while the computer is running
is classiﬁed as an event. Every keystroke and mouse click, ev ery time a
disk is inserted into a disk drive, an event is generated. The handling of
events are an important element of GUI programming. Therefo re, before
we begin discussing how to design GUIs, it will be useful to rev iew the
main concepts of Java’s event model .
When a Java program is running, events generated by the hardwa re
are passed up through the operating system (and through the b rowser, for
applets) to the program. Those events that belong to the prog ram must
be handled by the program (refer to Fig. 4.18 in Chapter 4). Fo r example,
if you click your browser’s menu bar, that event will be handl ed by the
browser itself. If you click a button contained in the Java pro gram, that
event should be handled by the program.
In Java, whenever something happens within a GUI component, a n
event object is generated and passed to the event listener that has been
registered to handle that component’s events. You’ve seen n umerous ex-
amples of this process in earlier chapters, but we’ve includ ed a simple
example to serve as a reminder.
Suppose you create a JButton in a GUI as follows:
☛ ✟
private JButton clickme = new JButton ( ”ClickMe” ) ;
✡ ✠
Whenever the user clicks the JButton , anActionEvent is generated.
In order to handle these events, the GUI must register the JButton with
a listener object that listens for action events. This can be d one in an ap-
plet’sinit() method or in an application’s constructor method, as in this
example:
☛ ✟
public MyGUI( ) {
// Add c l i c k m e t o t h e GUI a n d a s s i g n i t a l i s t e n e r
add ( clickme ) ;
clickme . addActionListener ( t h i s ) ;
}
✡ ✠
In this case, we have designated the GUI itself ( this ) as anActionListener
forclickme (Fig. 13.5). A listener is any object that implements a listenerclickme : JButton
: MyApplet>Listener
FIGURE 13.5 The GUI listens for
action events on the JButton .interface , which is one of the interfaces derived from java.util.Event-
Listener . AnActionListener is an object that listens for and receives
ActionEvent s.
SECTION 13.5 •The Java Event Model 611
In order to complete the event-handling code, the GUI must imp le-
ment the ActionListener interface. As Figure 13.6 shows, implement-
ing an interface is a matter of declaring the interface in the class heading
and implementing the methods contained in the interface, in this case the
actionPerformed() method.
☛ ✟
import javax . swing . ∗;
import java . awt . event . ∗;
public c l a s s MyGUI extends JFrame
implements ActionListener {
private JButton clickme = new JButton ( ”ClickMe” ) ;
public MyGUI( ) {
// Add c l i c k m e t o t h e GUI a n d a s s i g n i t a l i s t e n e r
getContentPane ( ) . add ( clickme ) ;
clickme . addActionListener ( t h i s ) ;
s e t S i z e ( 2 0 0 , 2 0 0 ) ;
s e t V i s i b l e ( true ) ;
}// i n i t ( )
public void actionPerformed ( ActionEvent e ) {
i f( e . getSource ( ) == clickme ) {
clickme . s e t T e x t ( clickme . getText ( ) + ”∗”) ;
}
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
MyGUI gui = new MyGUI ( ) ;
}
}// MyGUI
✡ ✠
Figure 13.6: A simple GUI application that handles action ev ents on a
JButton .
Now that we have implemented the code in Figure 13.6, wheneve r the
user clicks clickme , that action is encapsulated within an ActionEvent
object and passed to the actionPerformed() method. This method
contains Java code that will handle the user’s action in an ap propriate
way. For this example, it modiﬁes the button’s label by appen ding an
asterisk to it each time it is clicked. Figure 13.7 depicts th e sequence of
actions and events that occur when the the user clicks a butto n.
612 CHAPTER 13 •Graphical User Interfaces
Figure 13.7: A UML depiction of
the sequence of actions and events
that take place when a button is
clicked. The vertical lines repre-
sent time lines, with time running
from top to bottom. The arrows
between lines represent messages
passing between objects.
actionPerformed(e:ActionEvent)UserclickMe : JButton
Clickjvm : JVM
ClickEvent: ActionEvent
create()Object1 : MyApplet
showStatus(s:String)
The methods used to handle the ActionEvent are derived from the
java.util.EventObject class, the root class for all events (Fig. 13.8).
+EventObject(in src : Object)
+getSource() : Object
+toString() : StringEventObject
FIGURE 13.8 AnEventObject .
ThegetSource() method is used to
get the object that caused the event.Our example (Fig. 13.6) uses the getSource() method to get a reference
to the object that generated the event. To see what informatio n is con-
tained in an event object, we can use the toString() method to print
a string representation of the event that was generated. Here ’s what it
displays:
☛ ✟
java . awt . event . ActionEvent [ACTION PERFORMED, cmd=ClickMe ]
on javax . swing . JButton [ , 5 8 , 5 , 8 3 x27 ,
layout=javax . swing . OverlayLayout ]
✡ ✠
As you can see, the event generated was an ACTION PERFORMED event,
in response to the ClickMe command. The source of the event was the
JButton .
13.5.1 Event Classes
Although the event model is the same for both AWT and Swing clas ses,
the Swing package introduces many additional events. Table 13.1 lists
the events that are generated by both AWT and Swing components . You
already have worked with some of these. We have written GUIs th at
handled ActionEvent s forJButton s andJTextField s in preceding
chapters.
In viewing Table 13.1, it’s important to remember that the cla sses listed
there are arranged in a hierarchy. This will affect the event s that a par-
ticular object can generate. For example, a JButton is aJComponent
(Fig. 13.2), so in addition to generating ActionEvent s when the user
clicks on it, it can also generate MouseEvent s when the user moves the
mouse over it. Similarly, because a JTextField is also a JComponent , it
can generate KeyEvent s as well as ActionEvent s.
Note that the more generic events, such as those that involve moving,
focusing, or resizing a component, are associated with the m ore generic
components. For example, the JComponent class contains methods that
SECTION 13.5 •The Java Event Model 613
TABLE 13.1 Java’sAWTEvent s for each Component type (Original source: David Flanagan,
Java in a Nutshell , 2d ed., O’Reilly Associates, 1997. Modiﬁed for Swing components.)
Components Events Description
Button, JButton ActionEvent User clicked button
CheckBox, JCheckBox ItemEvent User toggled a checkbox
CheckboxMenuItem, JCheckboxMenuItem ItemEvent User toggled a checkbox
Choice, JPopupMenu ItemEvent User selected a choice
Component, JComponent ComponentEvent Component was moved or resized
FocusEvent Component acquired or lost focus
KeyEvent User typed a key
MouseEvent User manipulated the mouse
Container, JContainer ContainerEvent Component added/removed from container
List, JList ActionEvent User double-clicked a list item
ItemEvent User clicked a list item
Menu, JMenu ActionEvent User selected menu item
Scrollbar, JScrollbar AdjustmentEvent User moved scrollbar
TextComponent, JTextComponent TextEvent User edited text
TextField, JTextField ActionEvent User typed Enter key
Window, JWindow WindowEvent User manipulated window
are used to manage ComponentEvent s. Because they are subclasses
ofJComponent ,JButton s andJTextField s can also use these meth-
ods. Deﬁning the more generic methods in the JComponent superclass is
another example of the effective use of inheritance.
JAVA EFFECTIVE DESIGN Inheritance. The higher a method is
deﬁned in the inheritance hierarchy, the broader is its use.
Table 13.2 lists events that are new with the Swing classes. S ome of
the events apply to new components. For example, JTable andJTree
do not have AWT counterparts. Other events provide Swing comp onents
with capabilities that are not available in their AWT counter parts. For ex-
ample, a CaretEvent allows the programmer to have control over mouse
clicks that occur within a text component.
Tables 13.1 and 13.2 provide only a brief summary of these cla sses and
Swing components. For further details you should consult th e JDK online
documentation at
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
SELF-STUDY EXERCISES
EXERCISE 13.2 Is it possible to register a component with more than
one listener?
EXERCISE 13.3 Is it possible for a component to have two different
kinds of listeners?
614 CHAPTER 13 •Graphical User Interfaces
TABLE 13.2 Some of the events that are deﬁned in the Swing library.
Component Events Description
JPopupMenu PopupMenuEvent User selected a choice
JComponent AncestorEvent An event occurred in an ancestor
JList ListSelectionEvent User double-clicked a list item
ListDataEvent List’s contents were changed
JMenu MenuEvent User selected menu item
JTextComponent CaretEvent Mouse clicked in text
UndoableEditEvent An undoable edit has occurred
JTable TableModelEvent Items added/removed from table
TableColumnModelEvent A table column was moved
JTree TreeModelEvent Items added/removed from tree
TreeSelectionEvent User selected a tree node
TreeExpansionEvent User expanded or collapsed a tree node
JWindow WindowEvent User manipulated window
13.6 CASE STUDY: Designing a Basic GUI
What elements make up a basic user interface? If you think about all of
the various interfaces you’ve encountered—and don’t just lim it yourself
to computers—they all have the following elements:
•Some way to provide help/guidance to the user.
•Some way to allow input of information.
•Some way to allow output of information.
•Some way to control the interaction between the user and the d evice.
Think about the interface on a beverage machine. Printed tex t on the ma-
chine will tell you what choices you have, where to put your mo ney, and
what to do if something goes wrong. The coin slot is used to inp ut money.
There’s often some kind of display to tell you how much money y ou’ve
inserted. And there’s usually a bunch of buttons and levers t hat let you
control the interaction with the machine.
These same kinds of elements make up the basic computer inter face.
Designing a Graphical User Interface is primarily a process o f choos-
ing components that can effectively perform the tasks of inp ut, output,
control, and guidance.
JAVA EFFECTIVE DESIGN User Interface. A user interface must
effectively perform the tasks of input, output, control, an d guidance.
In the programs we designed in the earlier chapters, we used tw o dif-
ferent kinds of interfaces. In the command-line interface, we used printed
prompts to inform the user, typed commands for data entry and user
control, and printed output to report results. Our GUI inter faces used
JLabel s to guide and prompt the user, JTextField s andJTextArea s
as basic input and output devices, and either JButton s orJTextField s
for user control.
Let’s begin by building a basic GUI in the form of a Java applic a-
tion. To keep the example as close as possible to the GUIs we’ve already
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 615
used, we will build it out of the following Swing components: JLabel ,
JTextField ,JTextArea , andJButton .
13.6.1 The Metric Converter Application
Suppose the coach of the cross-country team asks you to write a Java ap-
plication that can be used to convert miles to kilometers. Th e program
should let the user input a distance in miles, and the program should
report the equivalent distance in kilometers.+milesToKm(in mi : double) : doubleMetricConverter
FIGURE 13.9 The
MetricConverter class has a
single method to convert miles to
kilometers.Before we design the interface for this, let’s ﬁrst deﬁne a Metric-
Converter class that can be used to perform the conversions (Fig. 13.9) .
For now at least, this class’s only task will be to convert mil es to kilo-
meters, for which it will use the formula that 1 kilometer equ als 0.62
miles:
☛ ✟
public c l a s s MetricConverter {
public s t a t i c double milesToKm ( double miles ) {
return miles / 0 . 6 2 ;
}
}
✡ ✠
Note that the method takes a double as input and returns a double .
Also, by declaring the method static , we make it a class method, so it
can be invoked simply by
☛ ✟
MetricConverter . milesToKm ( 1 0 ) ;
✡ ✠
Choosing the Components
Let’s now design a GUI to handle the interaction with the user . First, let’s
choose Swing components for each of the four interface tasks of input, Which components do we need?
output, control, and guidance. For each component, it might be useful to
refer back to Figure 13.2 to note its location in the Swing hie rarchy.
•AJLabel is a display area for a short string of text, an image, or both.
Its AWT counterpart, the Label , cannot display images. A JLabel
does not react to input. Therefore, it is used primarily to di splay a
graphic or small amounts of static text. It is perfectly suite d to serve
as a prompt, which is what we will use it for in this interface.
•AJTextField is a component that allows the user to edit a single line
of text. It is identical to its AWT counterpart, the TextField . By using
itsgetText() andsetText() methods, a JTextField can be used
for either input or output, or both. For this problem, we’ll u se it to
perform the interface’s input task.
•AJTextArea is a multiline text area that can be used for either input or
output. It is almost identical to the AWT TextArea component. One
difference, however, is that a JTextArea does not contain scrollbars
by default. For this program, we’ll use the JTextArea for displaying
the results of conversions. Because it is used solely for out put in this
program, we’ll make it uneditable to prevent the user from typing in it.
616 CHAPTER 13 •Graphical User Interfaces
•Let’s use a JButton as our main control for this interface. By im-
plementing the ActionListener interface we will handle the user’s
action events.
Choosing the Top-Level Window
The next issue we must decide is what kind of top-level window to use for What top-level window to use?
this interface. For applet interfaces, the top-level compo nent would be a
JApplet . For Java applications, you would typically use a JFrame as the
top-level window. Both of these classes are subclasses of Container , so
they are suitable for holding the components that make up the interface
(Fig. 13.1).
Also, as noted earlier, JApplet s andJFrame s are both examples of
heavyweight components, so they both have windows associat ed with
them. To display a JFrame we just have to give it a size and make it visi-
ble. Because a frame runs as a stand-alone window, not within a browser
context, it should also be able to exit the application when t he user closes
the frame.
Designing a Layout
The next step in designing the interface is deciding how to ar range the
components so that they will be visually appealing and compr ehensible, How should the components be
arranged? as well as easy to use.
Figure 13.10 shows a design for the layout. The largest compo nent is the
output text area, which occupies the center of the JFrame . The prompt,
input text ﬁeld, and control button are arranged in a row abov e the text
area. This is a simple and straightforward layout.
Figure 13.10 also provides a containment hierarchy , also called a wid-
get hierarchy , which shows the containment relationships among the var-
ious components. Although it might not seem so for this simpl e layout,
the containment hierarchy plays an important role in showin g how the
various components are grouped in the interface. For this de sign, we have
a relatively simple hierarchy, with only one level of contai nment. All of
the components are contained directly in the JFrame .
Figure 13.10: A design and layout
for the Metric Converter GUI. The
containment hierarchy (also called
awidget hierarchy ) shows the con-
tainment relationships among the
components.JFrame JLabel JTextField JButton
prompt:
JTextArea for displaying fileJFrame
Prompt JLabel
Input JTextField
Display JTextArea
Convert JButtonContainment Hierarchy
Convert
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 617
Figure 13.11 shows the design of the Converter class, which extends
theJFrame class and implements the ActionListener interface. As a
JFrame subclass, a Converter can contain GUI components. As an im-
plementor of the ActionListener interface, it also will be able to handle
action events through the actionPerformed() method.JFrame
+actionPerformed()«interface»
ActionListener
+Converter()
+actionPerformed()
+main()-prompt : JLabel
-input : JTextField
-display : JTextArea
-convert : JButtonConverter
FIGURE 13.11 TheConverter
class is a subclass of JFrame and
implements the ActionListener
interface.Figure 13.12 gives the implementation of the Converter class. Note
the three packages that are imported. The ﬁrst contains deﬁn itions of the
Swing classes, and the other two contain deﬁnitions of AWT eve nts and
layout managers that are used in the program.
☛ ✟
import javax . swing . ∗; // P a c k a g e s u s e d
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s Converter extends JFrame
implements ActionListener {
private JLabel prompt =
new JLabel ( ” Distance in miles : ” ) ;
private J T e x t F i e l d input = new J T e x t F i e l d ( 6 ) ;
private JTextArea display = new JTextArea ( 1 0 , 2 0 ) ;
private JButton convert = new JButton ( ”Convert ! ” ) ;
public Converter ( ) {
getContentPane ( ) . setLayout ( new FlowLayout ( ) ) ;
getContentPane ( ) . add ( prompt ) ;
getContentPane ( ) . add ( input ) ;
getContentPane ( ) . add ( convert ) ;
getContentPane ( ) . add ( display ) ;
display . setLineWrap ( true ) ;
display . s e t E d i t a b l e ( f a l s e ) ;
convert . addActionListener ( t h i s ) ;
}// C o n v e r t e r ( )
public void actionPerformed ( ActionEvent e ) {
double miles =
Double . valueOf ( input . getText ( ) ) . doubleValue ( ) ;
double km = MetricConverter . milesToKm ( miles ) ;
display . append ( miles + ” miles equals ” +
km + ” kilometers \n”) ;
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
Converter f = new Converter ( ) ;
f . s e t S i z e ( 4 0 0 , 3 0 0 ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// C o n v e r t e r
✡ ✠
Figure 13.12: The Converter class implements a simple GUI interface.
618 CHAPTER 13 •Graphical User Interfaces
We have to do all initializing tasks in the constructor. Firs t, we have to
set the JFrame ’s layout to FlowLayout . Alayout manager is the object
that is responsible for sizing and arranging the components in a container
so that the elements are organized in the best possible manne r. A ﬂow
layout is the simplest arrangement: The components are arra nged left to
right in the window, wrapping around to the next “row” if nece ssary.
Second, note the statements used to set the layout and to add c ompo-
nents directly to the JFrame . Instead of adding components directly to
theJFrame , we must add them to its content pane:
☛ ✟
getContentPane ( ) . add ( input ) ;
✡ ✠
Acontent pane is aJPanel that serves as the working area of the
JFrame . It contains all of the frame’s components. Java will raise an
exception if you attempt to add a component directly to a JFrame .
JAVA DEBUGGING TIP Content Pane AJFrame cannot directly
contain GUI elements. Instead, they must be added to its conte nt pane,
which can be retrieved using the getContentPane() method.
TheJFrame and all the other top-level Swing windows have an inter-
nal structure made up of several distinct objects that can be m anipulated
by the program. Because of this structure, GUI elements can b e orga-
nized into different layers within the window to create many types of
sophisticated layouts. Also, one layer of the structure mak es it possible
to associate a menu with the frame.
Finally, note how the Converter frame is instantiated, made visible,
and eventually exited in the application’s main() method:
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
Converter f = new Converter ( ) ;
f . s e t S i z e ( 4 0 0 , 3 0 0 ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
// Q u i t t h e a p p l i c a t i o n
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ;
}
}) ;
}// m a i n ( )
✡ ✠
It is necessary to set both the size and visibility of the frame , since these
are not set by default. Because we are using a FlowLayout , it is especially
important to give the frame an appropriate size. Failure to d o so can cause
the components to be arranged in a confusing way and might eve n cause
some components to not appear in the window. These are limita tions we
will ﬁx when we learn how to use some of the other layout manage rs.
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 619
13.6.2 Inner Classes and Adapter Classes
In this section we introduce two new language features, inner classes and
adapter classes , which are used in the main() method shown above to
handle the closing of the Converter application’s window when the
program is exited:
☛ ✟
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ;
}
}) ;
✡ ✠
This code segment provides a listener that listens for windo w closing Inner classes
events. When such an event occurs, it exits the application by calling
System.exit() .
The syntax used here is an example of an anonymous inner class . An
inner class is a class deﬁned within another class. The syntax is some-
what ugly, because it places the class deﬁnition right where a reference
to a window listener object would go. In effect what the code is d oing is
deﬁning a subclass of WindowAdapter and creating an instance of it to
serve as a listener for window closing events.
Anonymous inner classes provide a useful way of creating cla sses and
objects on the ﬂy to handle just this kind of listener task. The sy ntax used
actually enables us to write one expression that both deﬁnes a class and
creates an instance of it to listen for window closing events . The new
subclass has local scope limited here to the main() method. It is anony-
mous, meaning we aren’t even giving it a name, so you can’t cre ate other
instances of it in the program. Note that the body of the class deﬁnition is
placed right after the new keyword, which takes the place of the argument
to theaddWindowListener() method. For more details on the inner
and anonymous classes, see Appendix F.
JAVA LANGUAGE RULE Inner Class. An inner class is a class de-
ﬁned within another class. Inner classes are mostly used to ha ndle a
task that supports the work of the containing class.
Anadapter class is a wrapper class that implements trivial versions of Adapter class
the abstract methods that make up a particular interface. (R emember from
Chapter 4 that a wrapper class contains methods for converti ng primitive
data into objects and for converting data from one type to anot her.)
TheWindowAdapter class implements the methods of the Window-
Listener interface. When you implement an interface, such as
ActionListener , you must implement all the abstract methods de-
ﬁned in the interface. For ActionListener there’s just one method, the
actionPerformed() method, so we can implement it as part of our ap-
plet or frame class. However, we want to use only one of the seve n meth-
620 CHAPTER 13 •Graphical User Interfaces
ods available in the WindowListener interface, the windowClosing()
method, which is the method implemented in the anonymous inn er class:
☛ ✟
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ;
}
✡ ✠
TheWindowAdapter is deﬁned simply as
☛ ✟
public a b s t r a c t c l a s s WindowAdapter
implements WindowListener {
public void windowActivated ( WindowEvent e ) {}
public void windowClosed ( WindowEvent e ) {}
. . .
// F i v e o t h e r w i n d o w l i s t e n e r m e t h o d s
}
✡ ✠
Note that each method is given a trivial implementation (). T o create a
subclass of WindowAdapter , you must override at least one of its trivially
implemented methods.
Another way to manage the application’s window closing even t is to
deﬁne a subclass of WindowAdapter :
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s WindowCloser extends WindowAdapter {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ;
}
}
✡ ✠
Given this class, we can then place the following statement i n
Converter ’smain() method:
☛ ✟
f . addWindowListener ( new WindowCloser ( ) ) ;
✡ ✠
This is somewhat more familiar looking than the inner class c onstruct. If
you prefer this way of handling things, you can use this metho d in place
of the inner classes here and in other examples.
JAVA EFFECTIVE DESIGN Anonymous Adapter
Classes. Anonymous adapter classes provide a useful way of creating
an object to handle one particular kind of event within a progr am.
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 621
13.6.3 GUI Design Critique
Figure 13.13 shows the converter interface. Although our ba sic GUI de-
FIGURE 13.13 The ﬁrst version of
the metric converter GUI.sign satisﬁes the demands of input, output, control, and gui dance, it has a
few signiﬁcant design ﬂaws.
First, it forces the user to manually clear the input ﬁeld aft er each con-
version. Unless it is important that the user’s input value r emain dis-
played until another value is entered, this is just an inconve nience to the
user. In this case, the user’s input value is displayed along w ith the result
in theJTextArea , so there’s no reason not to clear the input text ﬁeld:
☛ ✟
input . s e t T e x t ( ””) ; // C l e a r t h e i n p u t f i e l d
✡ ✠
JAVA EFFECTIVE DESIGN Reduce the User’s Burden. A GUI
should aim to minimize the responsibility placed on the user . In
general, the program should perform any task that it can perf orm,
unless, of course, there is a compelling reason that the user should do
the task.
A second problem with our design is that it forces the user to s witch be-
tween the keyboard (for input) and the mouse (for control). E xperienced
users will ﬁnd this annoying. An easy way to ﬁx this problem is to make
both the JTextField and the JButton serve as controls. That way, to
get the program to do the conversion, the user can just press th e Enter key
after typing a number into the text ﬁeld.
To give the interface this type of control, we only need to add an
ActionListener to theJTextField during the initialization step:
☛ ✟
input . addActionListener ( t h i s ) ;
✡ ✠
AJTextField generates an ActionEvent whenever the Enter key
is pressed. We don’t even need to modify the actionPerformed()
method, since both controls will generate the same action ev ent. This will
allow users who prefer the keyboard to use just the keyboard.
JAVA EFFECTIVE DESIGN User Interface. A GUI should aim to
minimize the number of different input devices (mouse, keyb oard)
that the user has to manipulate to perform a particular task.
Given that the user can now interact with the interface with ju st the key-
board, a question arises over whether we should keep the butt on at all.
In this case, it seems justiﬁable to keep both the button and the text ﬁeld
controls. Some users dislike typing and prefer to use the mou se. Also,
having two independent sets of controls is a desirable form o f redundancy.
622 CHAPTER 13 •Graphical User Interfaces
You see it frequently in menu-based systems that allow menu i tems to be
selected either by mouse or by special control keys.
JAVA EFFECTIVE DESIGN Desirable Redundancy. Certain forms of
redundancy in an interface, such as two sets of independent c ontrols
(mouse and keyboard), make it a more ﬂexible or more widely usa ble
program.
SELF-STUDY EXERCISES
EXERCISE 13.4 Another deﬁciency in the converter interface is that it
doesn’t round off its result, leading sometimes to numbers w ith 20 or so
digits. Develop Java code to ﬁx this problem.
EXERCISE 13.5 Give an example of desirable redundancy in automo-
bile design.
13.6.4 Extending the Basic GUI: Button Array
Suppose the coach likes our program but complains that some o f the folks
in the ofﬁce are terrible typists and would prefer not to have to use the
keyboard at all. Is there some way we could modify the interfac e to
accommodate these users?
This gets back to the point we were just making about incorpora ting
redundancy into the interface. One way to satisfy this requi rement would What components do we need?
be to implement a numeric keypad for input, similar to a calcu lator key-
pad. Regular JButton s can be used as the keypad’s keys. As a user clicks
keypad buttons, their face values—0 through 9—are inserted in to the text
ﬁeld. The keypad will also need a button to clear the text ﬁeld and one to
serve as a decimal point.
This new feature will add 12 new JButton components to our
interface. Instead of inserting them into the JFrame individually, it will How should the components be
organized? be better to organize them into a separate panel and to insert the entire
panel into the frame as a single unit. This will help reduce th e complexity
of the display, especially if the keypad buttons can be group ed together
visually. Instead of having to deal with 16 separate componen ts, the user
will see the keypad as a single unit with a uniﬁed function. Th is is an
example of the abstraction principle, similar to the way we b reak long
strings of numbers (1-888-889-1999) into subgroups to make them easier
to remember.
JAVA EFFECTIVE DESIGN Reducing Complexity. Organizing
elements into distinct groups by function helps to reduce th e GUI’s
complexity.
Figure 13.14 shows the revised converter interface design. The contain-
ment hierarchy shows that the 12 keypad JButton s are contained within
aJPanel . In the frame’s layout, the entire panel is inserted just after the
text area.
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 623
JFrame JLabel JTextField
1 2 3
4 5 6
7 8 9
C 0 .JButton
prompt:
JTextArea for
displaying fileJFrame
12 JButtonsPrompt JLabel
Input JTextField
Display JTextArea
Convert JButton
KeyPad JPanel
KeyPad JPanel
Containment Hierarchy
ConvertFigure 13.14: A widget hierarchy
showing the containment rela-
tionships among the components.
Incorporating the keypad into the interface requires severa l changes
in the program’s design. Because the keypad has such a clearl y de-
ﬁned role, let’s make it into a separate object by deﬁning a KeyPad class
(Fig. 13.15). The KeyPad will be a subclass of JPanel and will han-
dle its own ActionEvent s. As we saw in Chapter 4, a JPanel is a
generic container. It is a subclass of Container via the JComponent
class (Fig. 13.2). Its main purpose is to contain and organize componentsJPanel
+KeyPad()
+actionPerformed()-NBUTTONS : int
-buttons[] : JButton
-labels[] : String
-kpc : KeyPadClientKeyPad+actionPerformed()«interface»
ActionListener
FIGURE 13.15 AKeyPad is a
JPanel ofJButton s that handles its
own action events.that appear together on an interface.
In this case, we will use a JPanel to hold the keypad buttons. As you
might recall from Chapter 4, to add elements to a JPanel , you use the
add() method, which is inherited from Container . (AJApplet is also
a subclass of Container via the Panel class.)
As a subclass of JPanel , theKeyPad will take care of holding and
organizing the JButton s in the visual display. We also need some way to
organize and manage the 12 keypad buttons within the program ’s mem-
ory. Clearly, this is a good job for an array. Actually, two arr ays would be
even better, one for the buttons and one for their labels:
☛ ✟
private JButton buttons [ ] ;
private S t r i n g l a b e l s [ ] = // An a r r a y o f b u t t o n l a b e l s
{”1” ,”2” ,”3” ,
”4” ,”5” ,”6” ,
”7” ,”8” ,”9” ,
”C” ,”0” ,” . ”};
✡ ✠
Thelabel array stores the strings that we will use as the buttons’ labe ls.
The main advantage of the array is that we can use a loop to inst antiate
the buttons:
☛ ✟
buttons = new JButton [NBUTTONS] ; // C r e a t e t h e a r r a y
// F o r e a c h l a b e l e d b u t t o n
for(i n t k = 0 ; k <buttons . length ; k++) {
buttons [ k ] = new JButton ( l a b e l s [ k ] ) ; // C r e a t e b u t t o n
buttons [ k ] . addActionListener ( t h i s ) ; // a n d a l i s t e n e r
add ( buttons [ k ] ) ; // a n d a d d i t t o t h e p a n e l
}// f o r
✡ ✠
This code should be placed in the KeyPad() constructor. It begins by Algorithm design
instantiating the array itself. It then uses a for loop, bound ed by the size
624 CHAPTER 13 •Graphical User Interfaces
of the array, to instantiate each individual button and inse rt it into the
array. Note how the loop variable here, k, plays a dual role. It serves as
the index into both the button array ( buttons ) and the array of strings
that serves as the buttons’ labels ( labels ). In that way the labels are as-
signed to the appropriate buttons. Note also how each button is assigned
anActionListener and added to the panel:
☛ ✟
buttons [ k ] . addActionListener ( t h i s ) ; // Add l i s t e n e r
add ( buttons [ k ] ) ; // Add b u t t o n t o p a n e l
✡ ✠
An important design issue for our KeyPad object concerns how it will in-
teract with the Converter that contains it. When the user clicks a keypad
button, the key’s label has to be displayed in the Converter ’s text area.
But because the text area is private to the converter, the KeyPad does not
have direct access to it. To address this problem, we will use a Java inter-
face to implement a callback design . In this design, whenever a KeyPad Callback design
button is pressed, the KeyPad object calls a method in the Converter
that displays the key’s label in the text area.
Figure 13.16 provides a summary of the callback design. Note that
the association between the Converter and the KeyPad is bi-directional.
This means that each object has a reference to the other and can invoke the
other’s public methods. This will be effected by having the Converter
pass a reference to itself when it constructs the KeyPad :
☛ ✟
private KeyPad keypad = new KeyPad ( t h i s ) ;
✡ ✠
Figure 13.16: In a callback design,
theConverter implements the
KeyPadClient interface. It
passes a reference to itself when
it creates the KeyPad object. The
KeyPad object can then invoke
the keypressCallback()
method whenever a keypad
button is pressed, and the
Converter can display the result
of the keypress.+keypressCallback(in s : String)«interface»
KeyPadClient
+Converter()
+actionPerformed()
+keypressCallback(in s : String)
+main()-prompt : JLabel
-input : JTextField
-display : JTextArea
-convert : JButtonConverter
-kpc : KeyPadClientKeyPadCreates NJFrame
+actionPerformed()«interface»
ActionListener
SECTION 13.6 •CASE STUDY: Designing a Basic GUI 625
Another important design issue is that the KeyPad needs to know the
name of the callback method and the Converter needs to have an imple-
mentation of that method. This is a perfect job for an abstract interface:
☛ ✟
public a b s t r a c t i n t e r f a c e KeyPadClient {
public void keypressCallback ( S t r i n g s ) ;
}
✡ ✠
TheKeyPad can interact with any class that implements the Key-
PadClient interface. Note that the KeyPad has a reference to the
KeyPadClient , which it will use to invoke the keypressCallback()
method.
The implementation of KeyPad is shown in Figure 13.17. Note that
its constructor takes a reference to a KeyPadClient and saves it in an
instance variable. Its actionPerformed() method then passes the key’s
label to the KeyPadClient ’s callback method.
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import javax . swing . ∗;
public c l a s s KeyPad extends JPanel implements ActionListener {
private f i n a l s t a t i c i n t NBUTTONS = 1 2 ;
private KeyPadClient kpc ; // O w n e r o f t h e K e y P a d
private JButton buttons [ ] ;
private S t r i n g l a b e l s [ ] = // An a r r a y o f b u t t o n l a b e l s
{”1” ,”2” ,”3” ,
”4” ,”5” ,”6” ,
”7” ,”8” ,”9” ,
”C” ,”0” ,” . ”};
public KeyPad ( KeyPadClient kpc ) {
t h i s . kpc = kpc ;
buttons = new JButton [NBUTTONS] ; // C r e a t e t h e a r r a y
for(i n t k = 0 ; k <buttons . length ; k++) {// F o r e a c h b u t t o n
buttons [ k ] = new JButton ( l a b e l s [ k ] ) ; // C r e a t e a b u t t o n
buttons [ k ] . addActionListener ( t h i s ) ; // a n d a l i s t e n e r
add ( buttons [ k ] ) ; // a n d a d d i t t o p a n e l
}// f o r
}// K e y P a d ( )
public void actionPerformed ( ActionEvent e ) {
S t r i n g keylabel = ( ( JButton ) e . getSource ( ) ) . getText ( ) ;
kpc . keypressCallback ( keylabel ) ;
}// a c t i o n P e r f o r m e d ( )
}// K e y P a d
✡ ✠
Figure 13.17: The KeyPad object implements a 12-key keypad in a
JPanel . It has a reference to the KeyPadClient that contains the key-
pad.
626 CHAPTER 13 •Graphical User Interfaces
Given the KeyPad design, we need to revise our design of the
Converter class (Fig. 13.16). The Converter will now implement the
KeyPadClient interface, which means it must provide an implementa-
tion of the keypressCallback() method:
☛ ✟
public void keypressCallback ( S t r i n g s ) {
i f( s . equals ( ”C” ) )
input . s e t T e x t ( ””) ;
else
input . s e t T e x t ( input . getText ( ) + s ) ;
}
✡ ✠
Recall that whenever the KeyPad object calls the keypressCallback()
method, it passes the label of the button that was pressed. Th e
Converter object simply appends the key’s label to the input text ﬁeld,
just as if the user typed the key in the text ﬁeld.
The complete implementation of this revised version of the i nterface is
shown in Figure 13.18 on the next page. The appearance of the i nterface
itself is shown in Figure 3.19.
13.6.5 GUI Design Critique
Figure 3.19 shows that despite our efforts to group the keypa d into a rect-
FIGURE 13.19 The second version
of the metric converter GUI uses a set
of keypad buttons for input, but they
are not properly arranged.angular array, it doesn’t appear as a single entity in the int erface itself,
which indicates a layout problem. The default layout for our KeyPad
(which is a JPanel ) isFlowLayout , which is not appropriate for a nu-
meric keypad that needs to be arranged into a two-dimensiona l grid pat-
tern, which is the kind of layout our design called for (Fig. 1 3.14).
Fortunately, this ﬂaw can easily be ﬁxed by using an appropria te layout
manager from the AWT. In the next version of the program, we empl oy the
java.awt.GridLayout , which is perfectly suited for a two-dimensional
keypad layout (Section 13.7.2).
The lesson to be learned from this example is that screen layo ut is an
important element of an effective GUI. If not done well, it can u ndermine
the GUI’s effort to guide the user toward the appointed tasks. If done
poorly enough, it can even keep the user from doing the task at all.
JAVA EFFECTIVE DESIGN Layout Design. The appropriate layout
and management of GUI elements is an important part of interf ace
design. It contributes to the interface’s ability to guide th e user’s
action toward the interface’s goals.
13.7 Containers and Layout Managers
AContainer is a component that can contain other components. Be-
cause containers can contain other containers, it is possib le to create a
hierarchical arrangement of components, as we did in the sec ond ver-
sion of our Converter interface. In its present form, the hierarchy for
Converter consists of a JFrame as the top-level container (Fig. 13.14).
SECTION 13.7 •Containers and Layout Managers 627
☛ ✟
import javax . swing . ∗; // P a c k a g e s u s e d
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s Converter extends JFrame // V e r s i o n 2
implements ActionListener , KeyPadClient {
private JLabel prompt = new JLabel ( ” Distance in miles : ” ) ;
private J T e x t F i e l d input = new J T e x t F i e l d ( 6 ) ;
private JTextArea display = new JTextArea ( 1 0 , 2 0 ) ;
private JButton convert = new JButton ( ”Convert ! ” ) ;
private KeyPad keypad = new KeyPad ( t h i s ) ;
public Converter ( ) {
getContentPane ( ) . setLayout ( new FlowLayout ( ) ) ;
getContentPane ( ) . add ( prompt ) ;
getContentPane ( ) . add ( input ) ;
getContentPane ( ) . add ( convert ) ;
getContentPane ( ) . add ( display ) ;
getContentPane ( ) . add ( keypad ) ;
display . setLineWrap ( true ) ;
display . s e t E d i t a b l e ( f a l s e ) ;
convert . addActionListener ( t h i s ) ;
input . addActionListener ( t h i s ) ;
}// C o n v e r t e r ( )
public void actionPerformed ( ActionEvent e ) {
double miles =
Double . valueOf ( input . getText ( ) ) . doubleValue ( ) ;
double km = MetricConverter . milesToKm ( miles ) ;
display . append ( miles + ” miles equals ” +
km + ” kilometers \n”) ;
input . s e t T e x t ( ””) ;
}// a c t i o n P e r f o r m e d ( )
public void keypressCallback ( S t r i n g s ) {
i f( s . equals ( ”C” ) )
input . s e t T e x t ( ””) ;
else
input . s e t T e x t ( input . getText ( ) + s ) ;
}
public s t a t i c void main ( S t r i n g args [ ] ) {
Converter f = new Converter ( ) ;
f . s e t S i z e ( 4 0 0 , 3 0 0 ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// C o n v e r t e r
✡ ✠
Figure 13.18: The second version of the Converter class, which imple-
ments the GUI shown in Figure 13.19.
628 CHAPTER 13 •Graphical User Interfaces
Contained within the frame is a KeyPad (subclass of JPanel ), which con-
tains 12 JButton s. Most GUIs will have a similar kind of containment
hierarchy. +add(in c : Component) : Component
+remove(in index : int)
+remove(in c : Component)
+removeAll()Container
FIGURE 13.20 AContainer
contains Component s.AContainer is a relatively simple object whose main task is primarily
to hold its components in a particular order. It has methods to add and
remove components (Fig. 13.20). As you can see from these met hods, a
container keeps track of the order of its elements, and it is p ossible to refer
to a component by its index order.
13.7.1 Layout Managers
The hard work of organizing and managing the elements within a con-
tainer is the task of the layout manager. Among other tasks, t he layout
manager determines
•The overall size of the container.
•The size of each element in the container.
•The spacing between elements.
•The positioning of the elements.
Although it is possible to manage your own layouts, it is not e asy to do.
For most applications you are much better off by learning to u se one
of the AWT’s built-in layouts. Table 13.3 gives a brief summar y of the
available layouts. We will show examples of FlowLayout ,GridLayout ,
andBorderLayout . Some of the widely used Swing containers have a
default layout manager assigned to them (Table 13.4).
To override the default layout for any of the JApplet ,JDialog ,
JFrame , and JWindow containers, you must remember to use the
getContentPane() . The correct statement is
☛ ✟
getContentPane ( ) . setLayout ( new FlowLayout ( ) ) ;
✡ ✠
JAVA DEBUGGING TIP Content Pane. Attempting to add a
component directly to a JApplet or aJFrame will cause an
exception. For these top-level containers, components mus t be added
to their content panes.
TABLE 13.3 Some of Java’s AWT and Swing layout managers.
Manager Description
java.awt.BorderLayout Arranges elements along the north, south, east, west,
and in the center of the container.
java.swing.BoxLayout Arranges elements in a single row or single column.
java.awt.CardLayout Arranges elements like a stack of cards, with one visible at a ti me.
java.awt.FlowLayout Arranges elements left to right across the container.
java.awt.GridBagLayout Arranges elements in a grid of variably sized cells (complicat ed).
java.awt.GridLayout Arranges elements into a two-dimensional grid of equally sized cells.
java.swing.OverlayLayout Arranges elements on top of each other.
SECTION 13.7 •Containers and Layout Managers 629
TABLE 13.4 Default layouts for some of the common
Swing containers.
Container Layout Manager
JApplet BorderLayout (on its content pane)
JBox BoxLayout
JDialog BorderLayout (on its content pane)
JFrame BorderLayout (on its content pane)
JPanel FlowLayout
JWindow BorderLayout (on its content pane)
13.7.2 The GridLayout Manager
It is simple to remedy the layout problem that affected the key pad
in the most recent version of the Converter program. The problem
was caused by the fact that as a subclass of JPanel , theKeyPad uses
a default FlowLayout , which causes its buttons to be arranged in a
row. A more appropriate layout for a numeric keypad would be a two-
dimensional grid, which is exactly the kind of layout suppli ed by the
java.awt.GridLayout . Therefore, to ﬁx this problem, we need only
set the keypad’s layout to a GridLayout . This takes a single statement,
which should be added to the beginning of the KeyPad() constructor:
☛ ✟
setLayout ( new GridLayout ( 4 , 3 , 1 , 1 ) ) ;
✡ ✠
This statement creates a GridLayout object and assigns it as the layout
manager for the keypad. It will ensure that the keypad will hav e four rows
and three columns of buttons (Fig. 13.21). The last two argum ents in the
constructor affect the relative spacing between the rows an d the columns.
The higher the number, the larger the spacing. As components are added
to the keypad, they will automatically be arranged by the man ager into a
4×3grid.
FIGURE 13.21 This version of the
metric converter GUI uses a keypad
for mouse-based input. It has an
attractive overall layout.Note that for a JPanel , thesetLayout() method applies to the panel
itself. Unlike the top-level containers, such as JFrame , other containers
don’t have content panes. The same point would apply when add ing
components to a JPanel : They are added directly to the panel, not to
a content pane. Confusion over this point could be the source of bugs in
your programs.
JAVA DEBUGGING TIP Content Pane. Top-level containers, such as
JFrame , are the only ones that use a content pane. For other
containers, such as JPanel , components are added directly to the
container itself.
As its name suggests, the GridLayout layout manager arranges com-
ponents in a two-dimensional grid. When components are added to the
container, the layout manager starts inserting elements in to the grid at the
ﬁrst cell in the ﬁrst row and continues left to right across ro w 1, then row
2, and so on. If there are not enough components to ﬁll all cells of the grid,
the remaining cells are left blank. If an attempt is made to add too many
630 CHAPTER 13 •Graphical User Interfaces
components to the grid, the layout manager will try to extend the grid in
some reasonable way in order to accommodate the components. How-
ever, despite its effort in such cases, it usually fails to ac hieve a completely
appropriate layout.
JAVA PROGRAMMING TIP Grid Layouts. Make sure the number
of components added to a GridLayout is equal to the number of
rows times the number of columns.
13.7.3 GUI Design Critique
Although the layout in Figure 13.21 is much improved, there a re still some
deﬁciencies. One problem is that the convert button seems to be mis-
placed. It would seem to make more sense if it were grouped with the
keypad rather than with the input text ﬁeld.
A more serious problem results from the fact that we are still using a
FlowLayout for the program’s main window, the JFrame . Among all of
Java’s layouts, FlowLayout gives you the least amount of control over
the arrangement of the components. Also, FlowLayout is most sensitive
to changes in the size and shape of its container.
13.7.4 The BorderLayout Manager
One way to ﬁx these problems is to use a BorderLayout to divide the
frame into ﬁve areas: north, south, east, west, and center, a s shown in
Figure 13.22. The BorderLayout class contains two constructors:WestNorth
SouthEast Center
FIGURE 13.22 Arrangement of
components in a border layout. The
relative size of the areas will vary.☛ ✟
public BorderLayout ( ) ;
public BorderLayout ( i n t hgap , i n t vgap ) ;
✡ ✠
The two parameters in the second version of the constructor a llow you to
insert spacing between the areas.
Components are added to a BorderLayout by using the add(Compo-
nent, String) method found in the Container class. For example, to
set the application window to a border layout and to add the ke ypad to
its east area, we would use the following statements:
☛ ✟
getContentPane ( ) . setLayout ( new BorderLayout ( 2 , 2 ) ) ;
getContentPane ( ) . add ( keypad , ” East ” ) ;
✡ ✠
In this version of the add() method, the second parameter must be a cap-
italized String with one of the names, “North,” “South,” “East,” “West,”
or “Center.” The order in which components are added does not matter.
One limitation of the BorderLayout is that only one component can Containment hierarchy
be added to each area. That means that if you want to add severa l compo-
nents to an area, you must ﬁrst enclose them within a JPanel and then
SECTION 13.7 •Containers and Layout Managers 631
add the entire panel to the area. For example, let’s create a p anel to contain
the prompt and the text ﬁeld and place it at the north edge of th e frame:
☛ ✟
JPanel inputPanel = new JPanel ( ) ; // C r e a t e p a n e l
inputPanel . add ( prompt ) ; // Add l a b e l
inputPanel . add ( input ) ; // Add t e x t f i e l d
// Add t h e p a n e l t o t h e f r a m e
getContentPane ( ) . add ( inputPanel , ”North” ) ;
✡ ✠
The same point would apply if we want to group the keypad with t he
convert button and place them at the east edge. There are seve ral ways
these elements could be grouped. In this example, we give the p anel a
border layout and put the keypad in the center and the convert button at
the south edge:
☛ ✟
JPanel controlPanel= new JPanel ( new BorderLayout ( 0 , 0 ) ) ;
controlPanel . add ( keypad , ” Center ” ) ;
controlPanel . add ( convert , ”South” ) ;
// Add t h e p a n e l t o t h e f r a m e
getContentPane . add ( controlPanel , ” East ” ) ;
✡ ✠
Given these details about the BorderLayout , a more appropriate de-
sign for the converter application is shown in Figure 13.23. Notice that the
border layout for the top-level JFrame uses only the center, north, and
east areas. Similarly, the border layout for the control pan el uses just the
center and south areas.
JFrameJLabel Input
JPanelJTextField
123
456
789
C0.
JButtons Control panelprompt:N
E
CJTextArea for
displaying file at
center of border
layoutJFrame(Border)Containment Hierarchy
Input JPanel(Flow)
       Prompt JLabel
       Input JTextField
Control JPanel(Border)
       KeyPad JPanel(Grid)
              12 Button
       Convert JButton
Display JTextAreaKeyPad JPanel
ConvertFigure 13.23: A border layout de-
sign for the metric converter pro-
gram. The dotted lines show the
panels.
In aBorderLayout , when one (or more) border area is not used, then
one or more of the other areas will be extended to ﬁll the unuse d area.
For example, if West is not used, then North ,South , andCenter will
extend to the left edge of the Container . IfNorth is not used, then West ,
East, andCenter will extend to the top edge. This is true for all areas
except Center . IfCenter is unused, it is left blank.
632 CHAPTER 13 •Graphical User Interfaces
Figure 13.24 shows the results we get when we incorporate the se
changes into the program. The only changes to the program its elf occur in
FIGURE 13.24 The metric
converter, showing its appearance
when a border design is used.the constructor method, which in its revised form is deﬁned a s follows:
☛ ✟
public Converter ( ) {
getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
keypad = new KeyPad ( t h i s ) ;
JPanel inputPanel = new JPanel ( ) ; // I n p u t p a n e l
inputPanel . add ( prompt ) ;
inputPanel . add ( input ) ;
getContentPane ( ) . add ( inputPanel , ”North” ) ;
JPanel controlPanel= new JPanel ( new BorderLayout ( 0 , 0 ) ) ;
// C o n t r o l p a n e l
controlPanel . add ( keypad , ” Center ” ) ;
controlPanel . add ( convert , ”South” ) ;
getContentPane ( ) . add ( controlPanel , ” East ” ) ;
// O u t p u t d i s p l a y
getContentPane ( ) . add ( display , ” Center ” ) ;
display . setLineWrap ( true ) ;
display . s e t E d i t a b l e ( f a l s e ) ;
convert . addActionListener ( t h i s ) ;
input . addActionListener ( t h i s ) ;
}// C o n v e r t e r ( )
✡ ✠
This layout divides the interface into three main panels, an input panel,
display panel, and control panel, and gives each panel its ow n layout. In
addition, the control panel contains the keypad panel. Thus , the contain-
ment hierarchy for this design is much more complex than in ou r original
design.
SELF-STUDY EXERCISES
EXERCISE 13.6 The border layout for the top window uses the north,
center, and east regions. What other combinations of areas mi ght be used
for these three components?
EXERCISE 13.7 Why wouldn’t a ﬂow layout be appropriate for the
control panel?
13.8 Checkboxes, Radio Buttons, and Borders
Suppose you are the software developer for your own software business
specializing in computer games. You want to develop an apple t-based Problem statement
order form that customers can use to order software over the W eb. At the
moment you have three software titles—a chess game, a checker s game,
and a crossword puzzle game. The assumption is that the user w ill choose
one or more of these titles from some kind of menu. The user mus t also
indicate a payment option—either E-cash, credit card, or deb it card. These
options are mutually exclusive—the user can choose one and on ly one.
SECTION 13.8 •Checkboxes, Radio Buttons, and Borders 633
Let’s design an applet interface for this program. Unlike th e previous
problem where the input was a numeric value, in this problem t he input
will be the user’s selection from some kind of menu. The resul t will be the
creation of an order. Let’s suppose that this part of the task happens be- Interface design
hind the scenes—that is, we don’t have to worry about creating an actual
order. The output the user sees will simply be an acknowledgm ent that
the order was successfully submitted.
There are several kinds of controls needed for this interfac e. First, a What components do we need?
conventional way to have users indicate their purchase deci sions is to
have them click a Submit button. They should also have the opt ion to
cancel the transaction at any time.
In addition to these button controls, a couple of menus must be pre-
sented, one for the software titles, and one for the payment c hoices. Swing
and AWT libraries provide many options for building menus.
One key requirement for this interface is the mutually exclu sive pay-
ment options. A conventional way to handle this kind of selec tion is with
aJRadioButton —a button that belongs to a group of mutually exclu-
sive alternatives. Only one button from the group may be sele cted at one
time. The selection of software titles could be handled by a c ollection of
checkboxes. A JCheckbox is a button that can be selected and deselected
and that always displays its current state to the user. Using a checkbox
will make it obvious to the user exactly what software has bee n selected.
To complete the design, let’s use a JTextArea again to serve as some-
thing of a printed order form. It will conﬁrm the user’s order a nd display
other messages needed during the transaction.
Given these decisions, we arrive at the design shown in Figur e 13.25.
In this case, our design uses a JPanel as the main container, instead of
using the top window itself. The reason for this decision is t hat we want to
use Swing Borders around the various JPanel s to enhance the overall
visual appeal of the design. The borders will have titles tha t help explain
the purpose of the various panels.
Note that the top-level window in this case is a JApplet . By default
it will have a border layout. For the main JPanel we are using a 3×1What top-level windows do we use?
GridLayout . The components in the main panel are the JTextArea
JApplet
Checkboxes Options panel Button panel
Choice panel RadioButtonsJTextArea for displaying the
user's orderJApplet(Border)
Main JPanel(Grid)
	 Display JTextArea
	 Center JPanel(Flow)
		 Choice JPanel(Box)
			 3 Checkboxes
		 Options JPanel(Box)
			 3 RadioButtons
	 Button JPanel(Flow)
		 Submit JButton
		 Cancel JButtonMain Panel
Containment Hierarchy
Submit CancelE-cash
DebitCreditChess
CrosswordCheckersFigure 13.25: A design for an on-
line order form interface.
634 CHAPTER 13 •Graphical User Interfaces
and two other JPanel s. The GridLayout will take care of sizing these
so they are all of equal size.
The center panel, which uses a ﬂow layout, contains panels for the
checkboxes and the radio buttons. These elements are groupe d within Component layout
their own panels. Again, we can put a border around them in the ﬁnal
implementation (Fig. 13.26). The button panels use a BoxLayout , which
we will discuss later. This design leads to the most complex c ontainment Containment hierarchy
hierarchy thus far.
13.8.1 Checkbox and Radio Button Arrays
Because we will need three checkboxes, one for each title, an d three radio What data structures do we need?
buttons, one for each payment option, it will be useful again to use arrays
to store both the buttons and their titles:
☛ ✟
private ButtonGroup optGroup = new ButtonGroup ( ) ;
private JCheckBox t i t l e s [ ] = new JCheckBox [ NTITLES ] ;
private JRadioButton options [ ] = new JRadioButton [NOPTIONS ] ;
private S t r i n g t i t l e L a b e l s [ ] =
{”Chess Master −$59 . 9 5 ” ,” Checkers Pro −$39 . 9 5 ” ,
”Crossword Maker −$19 . 9 5 ” };
private S t r i n g optionLabels [ ] = {” Credit Card” ,
” Debit Card” ,”E−cash ”};
✡ ✠
Again, the advantage of this design is that it simpliﬁes the i nstantiation
and initialization of the buttons:
FIGURE 13.26 Borders around
containers help make them stand out
more.☛ ✟
for(i n t k = 0 ; k <t i t l e s . length ; k++) {
t i t l e s [ k ] = new JCheckBox ( t i t l e L a b e l s [ k ] ) ;
t i t l e s [ k ] . addItemListener ( t h i s ) ;
choicePanel . add ( t i t l e s [ k ] ) ;
}
✡ ✠
The only difference between this array of checkboxes and the keypad ar-
ray of buttons that we used in the Converter program is that checkboxes
generate ItemEvent s instead ActionEvent s. Therefore, each checkbox
must be registered with an ItemListener (and, of course, the applet
itself must implement the ItemListener interface). We’ll show how
ItemEvent s are handled later.
The code for instantiating and initializing the radio butto ns is almost
the same:
☛ ✟
for(i n t k = 0 ; k <options . length ; k++) {
options [ k ] = new JRadioButton ( optionLabels [ k ] ) ;
options [ k ] . addItemListener ( t h i s ) ;
optionPanel . add ( options [ k ] ) ;
optGroup . add ( options [ k ] ) ;
}
options [ 0 ] . s e t S e l e c t e d ( true ) ; // S e t f i r s t b u t t o n ’ o n ’
✡ ✠
SECTION 13.8 •Checkboxes, Radio Buttons, and Borders 635
Radio buttons also generate ItemEvent s, so they too must be registered
with an ItemListener . Note that the ﬁrst button is set on, which repre-
sents a default payment option for the user.
The difference between checkboxes and radio buttons is that radio but-
tons must be added to a ButtonGroup —here named optGroup —in or-
der to enforce mutual exclusion among them. A ButtonGroup is an ob-
ject whose sole task is to enforce mutual exclusion among its m embers.
Whenever you click one radio button, the ButtonGroup will automati-
cally be notiﬁed of this event and will turn off whatever othe r button was
turned on. As Figure 13.27 illustrates, radio buttons are mo nitored by
two different objects, a ButtonGroup , which manages the radio buttons’
states, and an ItemListener , which listens for clicks on the buttons and
takes appropriate actions.
: ButtonGroup : ItemListener
1 1..* 1..* 1>Listens
: JRadioButtonContains N Figure 13.27: The ButtonGroup
object tracks each radio button’s
state, ensuring that only one
is selected at a time. The
ItemListener listens for events
on each button.
Note the effective division of labor in the design of the vari ous objects Divide and conquer
to which a radio button belongs. The optionPanel is a GUI compo-
nent (a JPanel ) that contains the button within the visual interface. Its
role is to help manage the graphical aspects of the button’s b ehavior. The
ButtonGroup is just an Object , not a GUI component. Its task is to
monitor the button’s relationship to the other buttons in th e group. Each
object has a clearly delineated task.
This division of labor is a key feature of object-oriented des ign. It is
clearly preferable to giving one object broad responsibilit ies. For example,
a less effective design might have given the task of managing a group of
buttons to the JPanel that contains them. However, this would lead to all
kinds of problems, not least of which is the fact that not ever ything in the
container belongs to the same button group. So a clear divisi on of labor is
a much preferable design.
JAVA EFFECTIVE DESIGN Division of Labor. In good
object-oriented design, objects are specialists (experts) f or very narrow,
clearly deﬁned tasks. If there’s a new task that needs doing, d esign a
new object to do it.
13.8.2 Swing Borders
The Swing Border andBorderFactory classes can place borders
around virtually any GUI element. Using borders is an effect ive way to
make the grouping of components more apparent. Borders can h ave titles,
which enhance the GUI’s ability to guide and inform the user. T hey can
also have a wide range of styles and colors, thereby helping t o improve
the GUI’s overall appearance.
636 CHAPTER 13 •Graphical User Interfaces
A border occupies some space around the edge of a JComponent . For
the Acme Software Titles interface, we place titled borders around four of
the panels (Fig. 13.26). The border on the main panel serves t o identify
the company again. The one around the button panel serves to g roup the
two control buttons. The borders around both the checkbox an d the radio
button menus help to set them apart from other elements of the display
and help identify the purpose of the buttons.
Attaching a titled border to a component—in this case to a JPanel —is
very simple. It takes one statement:
☛ ✟
choicePanel . setBorder (
BorderFactory . c r e a t e T i t l e d B o r d e r ( ” T i t l e s ” ) ) ;
✡ ✠
ThesetBorder() method is deﬁned in JComponent , is inherited by all
Swing components, and takes a Border argument. In this case, we use
theBorderFactory class to create a border and assign it a title. There
are several versions of the static createTitledBorder() method. This
version lets us specify the border’s title. It uses default va lues for type
of border (etched), the title’s position (sitting on the top line), justiﬁcation
(left), and for font’s type and color.
As you would expect, the Border andBorderFactory classes con-
tain methods that let you exert signiﬁcant control over the b order’s look
and feel. You can even design and create your own custom borde rs.
13.8.3 The BoxLayout Manager
Another type of layout to use is the BoxLayout . This can be associated
with any container, and it comes as the default with the Swing Box con-
tainer. We use it in this example to arrange the checkboxes an d radio
buttons (Fig. 13.25).
ABoxLayout is like a one-dimensional grid layout. It allows multi-
ple components to be arranged either vertically or horizont ally in a row.
The layout will not wrap around, as does the FlowLayout . Unlike the
GridLayout , theBoxLayout does not force all its components to be
the same size. Instead, it tries to use each component’s prefe rred width
(or height) in arranging them horizontally (or vertically) . (Every Swing
component has a preferred size that is used by the various lay out man-
agers in determining the component’s actual size in the inte rface.) The
BoxLayout manager also tries to align its components’ heights (for hor i-
zontal layouts) or widths (for vertical layouts).
Once again, to set the layout manager for a container you use t he
setLayout() method:
☛ ✟
choicePanel . setLayout ( new
BoxLayout ( choicePanel , BoxLayout . Y AXIS ) ) ;
✡ ✠
TheBoxLayout() constructor has two parameters. The ﬁrst is a refer-
ence to the container that’s being managed, and the second is a constant
that determines whether horizontal ( x-axis) or vertical ( y-axis) alignment
is used.
SECTION 13.8 •Checkboxes, Radio Buttons, and Borders 637
One nice feature of the BoxLayout is that it can be used in combina-
tions to imitate the look of the very complicated GridBoxLayout . For
example, Figure 13.28 shows an example with two panels (Pane l1 and
Panel2) arranged horizontally within an outer box (Panel0) , each con-
taining four components arranged vertically. The three pan els all use thePanel0
Panel1
C1
C2
C3
C4Panel2
C5
C6
C7
C8
FIGURE 13.28 Complex layouts
can be achieved by nesting containers
that use the BoxLayout .BoxLayout .
13.8.4 The ItemListener Interface
In this section, we will describe how to handle menu selection s. When-
ever the user makes a menu selection, or clicks a check box or r adio
button, an ItemEvent is generated. ItemEvent s are associated with
items that make up menus, including JPopupMenu s,JCheckboxes ,
JRadioButton s, and other types of menus. Item events are handled
by the ItemListener interface, which consists of a single method, the
itemStateChanged() method:
☛ ✟
public void itemStateChanged ( ItemEvent e ) {
display . s e t T e x t ( ”Your order so f a r ( Payment by : ” ) ;
for (i n t k = 0 ; k <options . length ; k++ )
i f( options [ k ] . i s S e l e c t e d ( ) )
display . append ( options [ k ] . getText ( ) + ” )\n”) ;
for (i n t k = 0 ; k <t i t l e s . length ; k++ )
i f( t i t l e s [ k ] . i s S e l e c t e d ( ) )
display . append ( ”\t ”+ t i t l e s [ k ] . getText ( ) + ”\n”) ;
}// i t e m S t a t e C h a n g e d ( )
✡ ✠
This version of the method handles item changes for both the c heckbox
menu and the radio buttons menu. The code uses two consecutiv e for
loops. The ﬁrst iterates through the options menu (radio buttons) to
determine what payment option the user has selected. Since o nly one
option can be selected, only one title will be appended to the display. The
second loop iterates through the titles menu (checkboxes) a nd appends
each title the user selected to the display. This way the comp lete status
of the user’s order is displayed after every selection. The isSelected()
method is used to determine if a checkbox or radio button is se lected or
not.
In this example, we have no real need to identify the item that c aused
the event. No matter what item the user selected, we want to di splay
the entire state of the order. However, like the ActionEvent class, the
ItemEvent class contains methods that can retrieve the item that cause d
the event:
☛ ✟
getItem ( ) ; // R e t u r n s a menu i t e m w i t h i n a menu
✡ ✠
ThegetItem() method is the ItemListener ’s analogue to the
ActionEvent ’sgetSource() method. It enables you to obtain the ob-
ject that generated the event but returns a representation of the item that
was selected or deselected.
638 CHAPTER 13 •Graphical User Interfaces
13.8.5 The OrderApplet
The design of the OrderApplet is summarized in Figure 13.29 and its
complete implementation is given in Figure 13.30. There are several im-
portant points to make about this program. First, ﬁve JPanel s are used to
organize the components into logical and visual groupings. This conforms
to the design shown in Figure 13.25.JApplet«interface»
ItemListener
+actionPerformed()«interface»
ActionListener
+init()
-initChoices()
-initOptions()
+actionPerformed(in e : ActionEvent)
+itemStateChanged(in e : ItemEvent)-NTITLES : int
-NOPTIONS : int
-mainPanel : JPanel
-centerPanel : JPanel
-choicePanel : JPanel
-optionPanel : JPanel
-buttonPanel : JPanel
-optGroup : ButtonGroup
-titles[] : JCheckBox
-options[] : JRadioButton
-titleLabels[] : String
-optionLabels[] : String
-display : JTextArea
-submit : JButton
-cancel : JButtonOrderApplet+itemStateChanged()
FIGURE 13.29 TheOrderApplet
makes extensive use of GUI
components.Second, note the use of titled borders around the four intern al panels.
These help reinforce that the components within the border a re related by
function.
The applet init() method is used to initialize the interface. This in-
volves setting the layouts for the various containers and ﬁl ling the con-
tainers with their components. Because their initializati ons are relatively
long, the checkboxes and radio buttons are initialized in se parate meth-
ods, the initChoices() andinitOptions() methods, respectively.
Finally, note how the actionPerformed() method creates a mock
order form in the display area. This allows the user to review the order
before it is submitted. Also note that the algorithm used for submittal
requires the user to conﬁrm an order before it is actually sub mitted. The
ﬁrst time the user clicks the Submit button, the button’s lab el is changed
to, “Conﬁrm Order,” and the user is prompted in the display ar ea to click
the Conﬁrm button to submit the order. This design allows the interface
to catch inadvertent button clicks.
A user interface should anticipate errors by the user. When a p rogram
involves an action that can’t be undone—such as placing an ord er—the
program should make sure the user really wants to take the act ion before
carrying it out.
JAVA EFFECTIVE DESIGN Anticipate the User. A well-designed
interface should make it difﬁcult for the user to make errors and
should make it easy to recover from mistakes when they do happ en.
SELF-STUDY EXERCISE
EXERCISE 13.8 What’s your favorite interface horror story? How
would you have remedied the problem? The interface needn’t b e a com-
puter interface.
SECTION 13.8 •Checkboxes, Radio Buttons, and Borders 639
☛ ✟
import javax . swing . ∗;
import javax . swing . border . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s OrderApplet extends JApplet
implements ItemListener , ActionListener {
private f i n a l i n t NTITLES = 3 , NOPTIONS = 3 ;
private JPanel mainPanel = new JPanel ( ) ,
centerPanel = new JPanel ( ) ,
choicePanel = new JPanel ( ) ,
optionPanel = new JPanel ( ) ,
buttonPanel = new JPanel ( ) ;
private ButtonGroup optGroup = new ButtonGroup ( ) ;
private JCheckBox t i t l e s [ ] = new JCheckBox [ NTITLES ] ;
private JRadioButton options [ ] = new JRadioButton [NOPTIONS ] ;
private S t r i n g t i t l e L a b e l s [ ] =
{”Chess Master −$59 . 9 5 ” ,” Checkers Pro −$39 . 9 5 ” ,
”Crossword Maker −$19 . 9 5 ” };
private S t r i n g optionLabels [ ] = {” Credit Card” ,
” Debit Card” ,”E−cash ”};
private JTextArea display = new JTextArea ( 7 , 2 5 ) ;
private JButton submit = new JButton ( ”Submit Order” ) ,
cancel = new JButton ( ” Cancel ” ) ;
public void i n i t ( ) {
mainPanel . setBorder ( BorderFactory . c r e a t e T i t l e d B o r d e r (
”Acme Software T i t l e s ” ) ) ;
mainPanel . setLayout ( new GridLayout ( 3 , 1 , 1 , 1 ) ) ;
cancel . addActionListener ( t h i s ) ;
submit . addActionListener ( t h i s ) ;
i n i t C h o i c e s ( ) ;
i n i t O p t i o n s ( ) ;
buttonPanel . setBorder ( BorderFactory . c r e a t e T i t l e d B o r d e r (
”Order Today” ) ) ;
buttonPanel . add ( cancel ) ;
buttonPanel . add ( submit ) ;
centerPanel . add ( choicePanel ) ;
centerPanel . add ( optionPanel ) ;
mainPanel . add ( display ) ;
mainPanel . add ( centerPanel ) ;
mainPanel . add ( buttonPanel ) ;
getContentPane ( ) . add ( mainPanel ) ;
s e t S i z e ( 4 0 0 , 4 0 0 ) ;
}// i n i t ( )
✡ ✠
Figure 13.30: The OrderApplet class, Part I.
640 CHAPTER 13 •Graphical User Interfaces
☛ ✟
private void i n i t C h o i c e s ( ) {
choicePanel . setBorder (
BorderFactory . c r e a t e T i t l e d B o r d e r ( ” T i t l e s ” ) ) ;
choicePanel . setLayout (
new BoxLayout ( choicePanel , BoxLayout . Y AXIS ) ) ;
for (i n t k = 0 ; k <t i t l e s . length ; k++) {
t i t l e s [ k ] = new JCheckBox ( t i t l e L a b e l s [ k ] ) ;
t i t l e s [ k ] . addItemListener ( t h i s ) ;
choicePanel . add ( t i t l e s [ k ] ) ;
}
}// i n i t C h o i c e s ( )
private void i n i t O p t i o n s ( ) {
optionPanel . setBorder (
BorderFactory . c r e a t e T i t l e d B o r d e r ( ”Payment By” ) ) ;
optionPanel . setLayout (
new BoxLayout ( optionPanel , BoxLayout . Y AXIS ) ) ;
for (i n t k = 0 ; k <options . length ; k++) {
options [ k ] = new JRadioButton ( optionLabels [ k ] ) ;
options [ k ] . addItemListener ( t h i s ) ;
optionPanel . add ( options [ k ] ) ;
optGroup . add ( options [ k ] ) ;
}
options [ 0 ] . s e t S e l e c t e d ( true ) ;
}// i n i t O p t i o n s ( )
public void itemStateChanged ( ItemEvent e ) {
display . s e t T e x t ( ”Your order so f a r ( Payment by : ” ) ;
for (i n t k = 0 ; k <options . length ; k++ )
i f( options [ k ] . i s S e l e c t e d ( ) )
display . append ( options [ k ] . getText ( ) + ” )\n”) ;
for (i n t k = 0 ; k <t i t l e s . length ; k++ )
i f( t i t l e s [ k ] . i s S e l e c t e d ( ) )
display . append ( ”\t ”+ t i t l e s [ k ] . getText ( ) + ”\n”) ;
}// i t e m S t a t e C h a n g e d ( )
public void actionPerformed ( ActionEvent e ) {
S t r i n g label = submit . getText ( ) ;
i f( e . getSource ( ) == submit ) {
i f(label . equals ( ”Submit Order” ) ){
display . append (
”Thank you . Press ’ Confirm ’ to submit your order ! \n”) ;
submit . s e t T e x t ( ”Confirm Order” ) ;
}else{
display . append (
”Thank you . You w i l l r e c e i v e your order tomorrow ! \n”) ;
submit . s e t T e x t ( ”Submit Order” ) ;
}
}else
display . s e t T e x t (
”Thank you . Maybe we can serve you next time ! \n”) ;
}// a c t i o n P e r f o r m e d ( )
}// O r d e r A p p l e t
✡ ✠
Figure 13.30: (continued) TheOrderApplet class, Part II.
SECTION 13.9 •Menus and Scroll Panes 641
13.9 Menus and Scroll Panes
Pop-up and pull-down menus allow an application or applet to grow in
complexity and functionality without cluttering its inter face. Menus are
hierarchical in nature. A particular menu is divided into a n umber of
menu items, which can themselves be further subdivided. Jav a makes
it simple to implement menus.
AJMenuBar is an implementation of a menu bar—a horizontal list of
names that appears at the top of a window (Fig. 13.31).
This is a simple text editor writtin in Swing.
All it d                            te.cut and paste.cut ar
d paste Simple Text Editor
Menubar
MenuItemMenu
SeparatorCut
Copy
Paste
Select All
Recent CutsFile Edit
simple text editor
cut and paste SubmenuFigure 13.31: An application with
a menu bar that is showing its edit
menu. The edit menu contains a
cascading drop-down menu that
can show recent cuts.
Almost all applications have a menu bar. To construct a menu, you add
JMenu objects to a JMenuBar . AJMenu is essentially a clickable area on
a menu bar that is associated with a JPopupMenu , a small window that
pops up and displays the menu’s JMenuItem s. A menu can also contain
JSeparator s, which are dividers that can be placed between menu items
to organize them into logical groupings.
13.9.1 Adding a Menu Bar to an Application
It is easy to create menus in Swing. The process involves three steps,
although you needn’t perform them in this order:
1. Create the individual JMenuItem s.
2. Create a JMenu and add the JMenuItem s to it.
3. Create a JMenuBar and add the JMenu s to it.
For example, suppose you’re building the interface for a tex t editor. A
text editor typically contains at least two standard menus. The ﬁle menu is
used to create new documents, open and close ﬁles, save your d ocument,
and so on. The edit menu is used to cut and paste selected text f rom the
document.
Here’s how you would create the ﬁle menu for this program. Firs t, you
create a menu bar and make it the menu bar for the application’ sJFrame
or for the JApplet . This is usually done in the application’s constructor
or in the applet’s init() method:
☛ ✟
JMenuBar mBar = new JMenuBar ( ) ; // C r e a t e menu b a r
t h i s . setMenuBar ( mBar ) ; // Add i t t o t h i s w i n d o w
✡ ✠
642 CHAPTER 13 •Graphical User Interfaces
The next step involves creating and adding menus and menu ite ms to
the menu bar. This is also usually done in the constructor or t heinit()
method. If the menu is large, you should break this task into su btasks and
deﬁne a method for each subtask.
JAVA EFFECTIVE DESIGN Method Size. A method that gets longer
than 20 to 25 lines is probably trying to do too much and should be
divided into separate methods, each with a clearly deﬁned ta sk.
Here’s the deﬁnition of the ﬁle menu for our simple text editor :
☛ ✟
private void initFileMenu ( ) {
fileMenu = new JMenu ( ” F i l e ” ) ; // C r e a t e menu
mBar . add ( fileMenu ) ; // Add i t t o menu b a r
openItem = new JMenuItem ( ”Open” ) ; // O p e n i t e m
openItem . addActionListener ( t h i s ) ;
openItem . setEnabled ( f a l s e ) ;
fileMenu . add ( openItem ) ;
saveItem = new JMenuItem ( ”Save” ) ; // S a v e i t e m
saveItem . addActionListener ( t h i s ) ;
saveItem . setEnabled ( f a l s e ) ;
fileMenu . add ( saveItem ) ;
fileMenu . addSeparator ( ) ; // L o g i c a l s e p a r a t o r
quitItem = new JMenuItem ( ” Quit ” ) ; // Q u i t i t e m
quitItem . addActionListener ( t h i s ) ;
fileMenu . add ( quitItem ) ;
}// i n i t F i l e M e n u ( )
✡ ✠
The ﬁrst two statements in the method create the ﬁle menu and a dd it
to the menu bar. The rest of the statements create the individ ual menu
items that make up the ﬁle menu. Note the use of a separator item after the
save item. This has the effect of grouping the ﬁle-handling i tems (open
and save) into one logical category and distinguishing them from the quit
item. A separator is represented as a line in the menu (Fig. 13 .31).
JAVA EFFECTIVE DESIGN Logical Design. In designing interfaces,
an effort should be made to use visual cues, such as menu item
separators and borders, to group items that are logically re lated. This
will help to orient the user.
Note that each menu item is given an ActionListener . As we’ll see
shortly, action events for menu items are handled the same wa y as action
events for buttons. Finally, note how the setEnabled() method is used
to disable both the open and save menu items. Implementation o f these
actions is left as an exercise.
SECTION 13.9 •Menus and Scroll Panes 643
13.9.2 Menu Hierarchies
Menus can be added to other menus to create a hierarchy. For ex ample,
the edit menu will include the standard cut, copy, and paste m enu items.
Some edit menus also contain an “Undo” item, which can be used to undo
the last editing operation that was performed. In other words , if you cut
a piece of text, you can undo that operation and get that cut ba ck. Many
editors seem to allow just a single undo. If you cut two pieces of text, the
ﬁrst piece is lost to the user to undo. This can be an issue, esp ecially if you
didn’t mean to do the ﬁrst cut.
To help remedy this type of situation, let’s add a feature to o ur editor
that will keep track of cuts by storing them in a Vector . This function
will be like an “Unlimited Undo” operation for cuts. For this example,
we won’t place any limit on the size of the vector. Every cut th e user
makes will be inserted at the beginning of the vector. To go al ong with this
feature we need a menu that can grow dynamically during the pr ogram.
Each time the user makes a cut, the string that was cut will be a dded to
the menu.
This kind of menu should occur within the edit menu, but it wil l have
its own items. This is a menu within a menu (Fig. 13.31), an exa mple of
acascading drop-down menu. The edit menu itself drops down from the
menu bar, and the recent cuts menu drops down and to the right o f where
its arrow points. The following method was used to create the edit menu:
☛ ✟
private void initEditMenu ( ) {
editMenu = new JMenu ( ” Edit ” ) ; // C r e a t e e d i t menu
mBar . add ( editMenu ) ; // Add t o menu b a r
cutItem = new JMenuItem ( ”Cut” ) ; // C u t i t e m
cutItem . addActionListener ( t h i s ) ;
editMenu . add ( cutItem ) ;
copyItem = new JMenuItem ( ”Copy” ) ; // C o p y i t e m
copyItem . addActionListener ( t h i s ) ;
editMenu . add ( copyItem ) ;
pasteItem = new JMenuItem ( ” Paste ” ) ; // P a s t e i t e m
pasteItem . addActionListener ( t h i s ) ;
editMenu . add ( pasteItem ) ;
editMenu . addSeparator ( ) ;
s e l e c t I t e m = new JMenuItem ( ” S e l e c t All ” ) ;// S e l e c t
s e l e c t I t e m . addActionListener ( t h i s ) ;
editMenu . add ( s e l e c t I t e m ) ;
editMenu . addSeparator ( ) ;
cutsMenu = new JMenu ( ” Recent Cuts” ) ;// C u t s s u b m e n u
editMenu . add ( cutsMenu ) ;
}// i n i t E d i t M e n u ( )
✡ ✠
The main difference between this method and the one used to cr eate the
ﬁle menu is that here we insert an entire submenu as one of the i tems in
the edit menu. The cutsMenu will be used to hold the strings that are cut
from the document. Initially, it will be empty.
644 CHAPTER 13 •Graphical User Interfaces
13.9.3 Handling Menu Actions
Handling JMenuItem actions is no different from handling JButton
actions. Whenever a user makes a menu selection, an ActionEvent
is generated. Programs that use menus must implement the action-
Performed() method of the ActionListener interface. In the text ed-
itor example, there are a total of six enabled menu items, inc luding the
recent cuts menu. This translates into a large if-else struc ture, with each
clause handling a single menu item.
The following actionPerformed() method is used to handle the
menu selections for the text editor:
☛ ✟
public void actionPerformed ( ActionEvent e ) {
JMenuItem m = ( JMenuItem ) e . getSource ( ) ; // G e t s e l e c t e d menu i t e m
i f( m == quitItem ) { // Q u i t
dispose ( ) ; }
}else i f (m == cutItem ) { // C u t t h e s e l e c t e d t e x t
scratchPad = display . g e t S e l e c t e d T e x t ( ) ; // C o p y t e x t t o s c r a t c h p a d
display . replaceRange ( ””, // a n d d e l e t e
display . g e t S e l e c t i o n S t a r t ( ) , // f r o m t h e s t a r t o f s e l e c t i o n
display . getSelectionEnd ( ) ) ; // t o t h e e n d
addRecentCut ( scratchPad ) ; // Add t e x t t o t h e c u t s menu
}else i f (m == copyItem ) // C o p y t e x t t o s c r a t c h p a d
scratchPad = display . g e t S e l e c t e d T e x t ( ) ;
}else i f (m == pasteItem ) {// P a s t e s c r a t c h p a d t o d o c u m e n t a t c a r e t
display . i n s e r t ( scratchPad , display . g e t C a r e t P o s i t i o n ( ) ) ; // p o s i t i o n
}else i f ( m == s e l e c t I t e m ) {
display . s e l e c t A l l ( ) ; // S e l e c t t h e e n t i r e d o c u m e n t
}else{
JMenuItem item = ( JMenuItem ) e . getSource ( ) ; // D e f a u l t i s c u t s M e n u
scratchPad = item . getActionCommand ( ) ; // P u t c u t b a c k i n s c r a t c h p a d
}
}// a c t i o n P e r f o r m e d ( )
✡ ✠
The method begins by getting the source of the ActionEvent and cast-
ing it into a JMenuItem . It then checks each case of the if-else structure.
Because the actions taken by this program are fairly short, t hey are mostly
coded within the actionPerformed() method itself. However, for most
programs it will be necessary to write a separate method corr esponding to
each menu item and then call the methods from actionPerformed() .
Our text editor’s main task is to implement the cut/copy/pas te func-
tions, which are simple to do in Java. The text that’s being ed ited is stored
in aJTextArea , which contains instance methods that make it very easy
to select, insert, and replace text. To copy a piece of text, t he program
need only get the text from the JTextArea (getSelectedText() ) and
assign it to the scratchpad , which is represented as a String . To paste
a piece of text, the program inserts the contents of the scratchpad into
theJTextArea at the location marked by the caret , a cursor-like character
in the document that marks the next insertion point.
The structure of this if-else statement is signiﬁcant. Note how the de-
fault case of the if-else is designed. We are using the last el se clause as a
“catch all” condition to catch and handle selections from th ecutsMenu .
SECTION 13.9 •Menus and Scroll Panes 645
All of the other menu items can be referred to by name. However, the
menu items in the cutsMenu are just snippets of a string that the user has
previously cut from the text, so they can’t be referenced by n ame. Luckily, Default logic
we don’t really need to. For any JMenuItem , thegetActionCommand()
method returns its text, which in this case is the previously cut text. So we
just assign the cut text from the menu to the scratchpad .
JAVA PROGRAMMING TIP Default Cases. Although the order of
the clauses in an if-else structure is usually not important , the default
clause can sometimes be used to handle cases that can’t be ref erenced
by name.
Handling Previously Cut Text
The most difﬁcult function in our program is the cut operatio n. Not only
must the selected text be removed from the document and store d in the
scratchpad , but it must also be inserted into the vector that is storing
all the previous cuts. The addRecentCut() method takes care of this
last task. The basic idea here is to take the cut string and ins ert it at the Algorithm design
beginning of the vector, so that cuts will be maintained in a l ast-in–ﬁrst-
out order. Then the cutsMenu must be completely rebuilt by reading its
entries out of the vector, from ﬁrst to last. That way the most recent cut
will appear ﬁrst in the menu:
☛ ✟
private void addRecentCut ( S t r i n g cut ) {
recentCuts . insertElementAt ( cut , 0 ) ;
cutsMenu . removeAll ( ) ;
for (i n t k = 0 ; k <recentCuts . s i z e ( ) ; k++) {
JMenuItem item =
new JMenuItem ( ( S t r i n g ) recentCuts . elementAt ( k ) ) ;
cutsMenu . add ( item ) ;
item . addActionListener ( t h i s ) ;
}
}// a d d R e c e n t C u t ( )
✡ ✠
TherecentCuts Vector stores the cut strings. Note the use of the
insertElementAt() method to insert strings into the vector and the
elementAt() method to get strings from the vector. (You may ﬁnd it
helpful to review the section on vectors in Chapter 9.)
Note also how menu items are removed and inserted in menus. Th e
cutsMenu is reinitialized, using the removeAll() method. Then the for
loop iterates through the strings stored in the vector, maki ng new menu
items from them, which are then inserted into the cutsMenu . In this way,JFrame
+SimpleTextEditor()
-initEditMenu()
-initFileMenu()
-addRecentCut(in s : String)
+actionPerformed(in e : ActionEvent)
+main()-mBar : JMenuBar
-fileMenu : JMenu
-editMenu : JMenu
-cutsMenu : JMenu
-cutItem : JMenuItem
-copyItem : JMenuItem
-pasteItem : JMenuItem
-selectItem : JMenuItem
-recentCutItem : JMenuItem
-quitItem : JMenuItem
-openItem : JMenuItem
-saveItem : JMenuItem
-display : JTextArea
-scratchPad : String
-recentCuts : VectorSimpleTextEditor+actionPerformed(in e : ActionEvent)«interface»
ActionListener
FIGURE 13.32 Design of the
SimpleTextEditor .thecutsMenu is changed dynamically each time the user cuts a piece of
text from the document.
13.9.4 Adding Scrollbars to a Text Area
The design of the SimpleTextEditor class is summarized in Fig-
ure 13.32 and its complete implementation is shown in Figure 13.33.
646 CHAPTER 13 •Graphical User Interfaces
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
import java . u t i l . Vector ;
public c l a s s SimpleTextEditor extends JFrame implements ActionListener {
private JMenuBar mBar = new JMenuBar ( ) ; // C r e a t e t h e menu b a r
private JMenu fileMenu , editMenu , cutsMenu ; // Menu r e f e r e n c e s a n d i t e m s
private JMenuItem cutItem , copyItem , pasteItem , s e l e c t I t e m , rece ntcutItem ;
private JMenuItem quitItem , openItem , saveItem ; // F i l e i t e m s
private JTextArea display = new JTextArea ( ) ; // H e r e ’ s w h e r e t h e e d i t i n g o c c u r s
private S t r i n g scratchPad = ””; // S c r a t c h p a d f o r c u t / p a s t e
private Vector recentCuts = new Vector ( ) ;
public SimpleTextEditor ( ) {
super (” Simple Text Editor ” ) ; // S e t t h e w i n d o w t i t l e
t h i s . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , display ) ;
t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( display ) ) ;
display . setLineWrap ( true ) ;
t h i s . setJMenuBar ( mBar ) ; // S e t t h i s p r o g r a m ’ s menu b a r
initFileMenu ( ) ; // C r e a t e t h e m e n u s
initEditMenu ( ) ;
}// S i m p l e T e x t E d i t e r ( )
private void initEditMenu ( ) {
editMenu = new JMenu ( ” Edit ” ) ; // C r e a t e t h e e d i t menu
mBar . add ( editMenu ) ; // a n d a d d i t t o menu b a r
cutItem = new JMenuItem ( ”Cut” ) ; // C u t i t e m
cutItem . addActionListener ( t h i s ) ;
editMenu . add ( cutItem ) ;
copyItem = new JMenuItem ( ”Copy” ) ; // C o p y i t e m
copyItem . addActionListener ( t h i s ) ;
editMenu . add ( copyItem ) ;
pasteItem = new JMenuItem ( ” Paste ” ) ; // P a s t e i t e m
pasteItem . addActionListener ( t h i s ) ;
editMenu . add ( pasteItem ) ;
editMenu . addSeparator ( ) ;
s e l e c t I t e m = new JMenuItem ( ” S e l e c t All ” ) ; // S e l e c t i t e m
s e l e c t I t e m . addActionListener ( t h i s ) ;
editMenu . add ( s e l e c t I t e m ) ;
editMenu . addSeparator ( ) ;
cutsMenu = new JMenu ( ” Recent Cuts” ) ; // R e c e n t c u t s s u b m e n u
editMenu . add ( cutsMenu ) ;
}// i n i t E d i t M e n u ( )
private void initFileMenu ( ) {
fileMenu = new JMenu ( ” F i l e ” ) ; // C r e a t e t h e f i l e menu
mBar . add ( fileMenu ) ; // a n d a d d i t t o t h e menu b a r
openItem = new JMenuItem ( ”Open” ) ; // O p e n i t e m
openItem . addActionListener ( t h i s ) ;
openItem . setEnabled ( f a l s e ) ;
fileMenu . add ( openItem ) ;
saveItem = new JMenuItem ( ”Save” ) ; // S a v e i t e m
✡ ✠
Figure 13.33: A menu-based SimpleTextEditor application, Part I.
SECTION 13.9 •Menus and Scroll Panes 647
☛ ✟
saveItem . addActionListener ( t h i s ) ;
saveItem . setEnabled ( f a l s e ) ;
fileMenu . add ( saveItem ) ;
fileMenu . addSeparator ( ) ; // L o g i c a l s e p a r a t o r
quitItem = new JMenuItem ( ” Quit ” ) ; // Q u i t i t e m
quitItem . addActionListener ( t h i s ) ;
fileMenu . add ( quitItem ) ;
}// i n i t F i l e M e n u ( )
public void actionPerformed ( ActionEvent e ) {
JMenuItem m = ( JMenuItem ) e . getSource ( ) ; // G e t s e l e c t e d menu i t e m
i f( m == quitItem ) { // Q u i t
dispose ( ) ;
}else i f (m == cutItem ) { // C u t t h e s e l e c t e d t e x t
scratchPad = display . g e t S e l e c t e d T e x t ( ) ; // C o p y t e x t t o s c r a t c h p a d
display . replaceRange ( ””, // a n d d e l e t e
display . g e t S e l e c t i o n S t a r t ( ) , // f r o m t h e s t a r t o f t h e s e l e c t i o n
display . getSelectionEnd ( ) ) ; // t o t h e e n d
addRecentCut ( scratchPad ) ; // Add t h e c u t t e x t t o t h e c u t s menu
}else i f (m == copyItem ) { // C o p y t h e s e l e c t e d t e x t t o t h e s c r a t c h p a d
scratchPad = display . g e t S e l e c t e d T e x t ( ) ;
}else i f (m == pasteItem ) {// P a s t e t h e s c r a t c h p a d t o t h e d o c u m e n t a t c a r e t
display . i n s e r t ( scratchPad , display . g e t C a r e t P o s i t i o n ( ) ) ; // p o s i t i o n
}else i f ( m == s e l e c t I t e m ) {
display . s e l e c t A l l ( ) ; // S e l e c t t h e e n t i r e d o c u m e n t
}else{
JMenuItem item = ( JMenuItem ) e . getSource ( ) ; // D e f a u l t i s c u t s M e n u
scratchPad = item . getActionCommand ( ) ; // P u t c u t b a c k i n t h e s c r a t c h p a d
}
}// a c t i o n P e r f o r m e d ( )
private void addRecentCut ( S t r i n g cut ) {
recentCuts . insertElementAt ( cut , 0 ) ;
cutsMenu . removeAll ( ) ;
for (i n t k = 0 ; k <recentCuts . s i z e ( ) ; k++) {
JMenuItem item =
new JMenuItem ( ( S t r i n g ) recentCuts . elementAt ( k ) ) ;
cutsMenu . add ( item ) ;
item . addActionListener ( t h i s ) ;
}
}// a d d R e c e n t C u t ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
SimpleTextEditor f = new SimpleTextEditor ( ) ;
f . s e t S i z e ( 3 0 0 , 2 0 0 ) ;
f . s e t V i s i b l e ( true ) ;
f . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// S i m p l e T e x t E d i t o r
✡ ✠
Figure 13.33: (continued) TheSimpleTextEditor , Part II.
648 CHAPTER 13 •Graphical User Interfaces
It uses a BorderLayout , with the JTextArea placed at the center. Note
how simple it is to add scrollbars to the text area: Scrollbars
☛ ✟
t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( display ) ) ;
✡ ✠
This statement creates a JScrollPane and adds it to the application’s
container. A JScrollPane is one of Swing’s scrollbar classes. Its function
is to manage the viewing and scrolling of a scrollable compon ent, such as
aJTextArea . AJScrollPane is actually a container, which is why it
takes the display as an argument. The display is being added to the
JScrollPane .
Just about any Component can be added to a JScrollPane . Once a
component is added, the scroll pane will manage the scrollin g functions
for the component. The default constructor used in this exam ple takes a
singleComponent parameter. This refers to the scrollable component, in
this case to the JTextArea . Another constructor that you might use takes
the following form:
☛ ✟
public J S c r o l l P a n e ( Component comp , i n t vsbPolicy ,
i n t hsbPolicy ) ;
✡ ✠
The two integers refer to the vertical and horizontal scroll ing policies.
These cover properties such as whether the scrollbars are al ways present
or just as needed. The default policy is to attach scrollbars t o the compo-
nent only when needed. Thus, to see the scrollbars in the SimpleText
Editor , you would have to shrink the window to the point where all of
the text cannot be viewed (Fig. 13.34). Because the text area in this example
is wrapping the text, the horizontal scrollbar will never be needed.
FIGURE 13.34 The scrollbars
appear on the text area only when
they are needed. In this case, only a
vertical scrollbar is necessary.SELF-STUDY EXERCISES
EXERCISE 13.9 Modify the addRecentCut() method so it limits the
cuts stored in the vector to the last ten cuts.
EXERCISE 13.10 Modify the addRecentCut() method so that it
doesn’t duplicate cuts already stored in the vector. ( Hint : Use the
indexOf(String) method in the Vector class.)
Special Topic: Are Computers Intelligent?
Contemporary computer interfaces are largely visual and gr aphical, and
many things we use a computer for, such as word processing, st ill require
us to type. Will there come a day when instead of typing a lette r or e-
mail message, we’ll be able to dictate it to our computer? Wil l comput-
ers eventually have the same kind of interface we have—that is , will we
someday be able to carry on conversations with our computers ? Clearly,
a “conversational interface” would require substantial in telligence on the
part of the computer. Do computers have any chance of acquiri ng such
intelligence?
The question of machine intelligence or artiﬁcial intelligence (AI) has
SECTION 13.9 •Menus and Scroll Panes 649
been the subject of controversy since the very ﬁrst computers were de-
veloped. In 1950, in an article in the journal Mind , Alan Turing proposed
the following test to settle the question of whether compute rs could be in-
telligent. Suppose you put a person and a computer in another room, and
you let a human interrogate both with any kind of question wha tsoever.
The interrogator could ask them to parse a Shakespearian son net, or solve
an arithmetic problem, or tell a joke. The computer’s task wou ld be to
try to fool the interrogator into thinking that it was the hum an. And the
(hidden) human’s task would be to try to help the interrogato r see that he
or she was the human.
Turing argued that someday computers would be able to play th is
game so well that interrogators would have no better than a 50 /50 chance
of telling which was which. When that day came, he argued, we wo uld
have to conclude that computers were intelligent.
This so-called Turing test has been the subject of controversy ever since.
Many of the founders of AI and many of its current practitione rs believe
that computation and human thinking are basically the same k ind of pro-
cess and that eventually computers will develop enough capa bility that
we’ll have to call them intelligent. Skeptics argue that eve n if computers
could mimic our intelligence, there’s no way they will be sel f-conscious
and, therefore, they can never be truly intelligent. Accord ing to the skep-
tics, merely executing programs, no matter how clever the pr ograms are,
will never add up to intelligence.
Computers have made some dramatic strides lately. In 1997, an IBM
computer named Deep Blue beat world chess champion Gary Kasp arov
in a seven-game chess match. In 1998, a computer at Los Alamos N ational
Laboratory proved a mathematical theorem that some of the be st mathe-
maticians were unable to prove for the past 40 years.
However, despite these achievements, most observers would a gree that
computers are not yet capable of passing the Turing test. One area where
computers fall short is in natural language understanding. Although com-
puters are good at understanding Java and other computer lan guages,
human languages are still too complex and require too much co mmon
sense knowledge for computers to understand them perfectly . Another
area where computers still fall somewhat short is in speech r ecognition.
However, an American company recently demonstrated a teleph one that
could translate between English and German (as well as some o ther lan-
guages) in real time. The device’s only limitation was that i ts discourse
was limited to the travel domain. As computer processing spe eds im-
prove, this limitation is expected to be only temporary. Thu s, we may be
closer than we think to having our “conversational user inte rface.”
Natural language understanding, speech recognition, lear ning, percep-
tion, chess playing, and problem solving are the kinds of pro blems ad-
dressed in AI, one of the major applied areas of computer scienc e. Almost
every major research group in AI has a Web site that describes i ts work.
To ﬁnd some of these, just do a search for “artiﬁcial intellige nce” and then
browse through the links that are returned.
650 CHAPTER 13 •Graphical User Interfaces
CHAPTER SUMMARY Technical Terms
adapter class
callback design
content pane
containment
hierarchy
controller
event model
inner classlayout manager
lightweight
component
listener
model
model-view-
controller
(MVC)peer model
pluggable look and
feel
view
widget hierarchy
Summary of Important Points
•Java provides two sets of Graphical User Interface (GUI) compo nents,
the Abstract Windowing Toolkit (AWT), which was part of Java 1 .0 and
the Swing component set, the GUI part of the Java Foundation C lasses
(JFC), introduced in JDK 1.1.
•Unlike their AWT counterparts, Swing components are written en-
tirely in Java. This allows programs written in Swing to have a
platform-independent look and feel. There are three built- in look-and-
feel packages in Swing: a Windows style, a Unix-like Motif st yle, and a
purely Java Metal style.
•Swing components are based on the model-view-controller (MVC) archi-
tecture, in which the component is divided into three separa te objects:
how it looks ( view ), what state it’s in ( model ), and what it does ( con-
troller ). The view and controller parts are sometimes combined into a
single user interface class, which can be changed to create a customized
look and feel.
•AWT components are based on the peer model , in which every AWT
component has a peer in the native windowing system. This mod el is
less efﬁcient and more platform dependent than the MVC model .
•Java’s event model is based on event listeners . When a GUI component is
created, it is registered with an appropriate event listene r, which takes
responsibility for handling the component’s events.
•A user interface combines four functions: guidance/inform ation for
the user, input, output, and control.
•Components in a GUI are organized into a containment hierarchy that
is rooted at the top-level window. JPanel s and other Container s
can be used to organize the components into a hierarchy accor ding to
function or some other criterion.
•The top-level Swing classes— JApplet ,JDialog ,JFrame , and
JWindow —use a content pane as their component container.
•A GUI should minimize the number of input devices the user nee ds
to manipulate, as well as the complexity the user needs to dea l with.
Certain forms of redundancy—such as two independent but comp lete
sets of controls—are desirable because they make the interfa ce more
ﬂexible and more widely applicable.
CHAPTER 13 •Solutions to Self-Study Exercises 651
Model Controller ViewSetsState NDeterminesLook Nhasahasa hasa
EventHandlesEvents N
JavaMethodCallResponds NJButtonFigure 13.35: A JButton has
internal model-view-controller
components that interact with
each other to produce the button’s
overall behavior.
•Alayout manager is an object that manages the size and arrangement of
the components in a container. The AWT and Swing provide a numb er
of built-in layouts, including ﬂow, border, grid, and box lay outs.
•Aradio button is a toggle button that belongs to a group in which only
one button from the group may be selected at the same time. A checkbox
is a toggle button that always displays its state.
•A well-designed interface should reduce the chance of user e rror and
should make it as easy as possible to recover from errors when they do
occur.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 13.1 How can a button still be considered a component under the
MVC model? This is a good question. The JButton class acts as a wrapper class
and hides the model-view-controller details (Fig. 13.35). Whe n you instantiate a
JButton , you still get a single instance. Think of it this way: Your body con sists of
several systems that interact (internally) among themselve s, but it’s still one body
that other bodies interact with as a single object.
SOLUTION 13.2 A component can indeed be registered with more than one lis-
tener. For example, the ToggleButton that we deﬁned in Chapter 4 has two
listeners. The ﬁrst is the button itself, which takes care of tog gling the button’s
label. The second is the applet in which the button is used, whic h takes care of
handling whatever action the button is associated with.
SOLUTION 13.3 Some components can have two different kinds of listeners.
For example, imagine a “sticky button” that works like this. Whe n you click and
release the button, it causes some action to take place, just lik e a normal button.
When you click and hold the mouse button down, the button “sticks” to the cursor
and you can then move it to a new location. This button would need list eners for
ActionEvent s,MouseEvent s, andMouseMotionEvent s.
SOLUTION 13.4 To round a double you could use the Math.round() method.
For example, suppose the number you want to round is d. Then the expression
Math.round(100 *d)/100.0 will round to two decimal places. Alternatively,
you could use the java.text.NumberFormat class. Both of these approaches
were covered in Chapter 5.
SOLUTION 13.5 Many cars today have cruise control as a alternative way to
control the accelerator. Push buttons, usually located on the stee ring wheel, are
used to speed up and slow down, so you can drive with your foot or your han d.
652 CHAPTER 13 •Graphical User Interfaces
SOLUTION 13.6 As an alternative, a north-west-center border layout for the
top-level window in the Converter might work. So might center-south-east and
center-south-west. What makes these possible is the fact that the layout manager
will use up space in any edge area that is not assigned a component .
SOLUTION 13.7 A ﬂow layout would not be appropriate for the control panel
because you would have little control of where the convert button would be
placed relative to the keypad.
SOLUTION 13.8 Interface design disaster: My car uses the same kind of on/off
switch for the headlights and the windshield wipers. One is a s tem on the left side
of the steering wheel, and the other is on a stem on the right side of t he steering
wheel. On more than one occasion, I’ve managed to turn off the headli ghts when
I intended to turn on the wipers.
SOLUTION 13.9 Modify the addRecentCut() method so it limits the cuts
stored in the vector to the last ten cuts. Solution: Check the size of the vector
after inserting the cut. If it exceeds ten, remove the last ele ment in the vector.
☛ ✟
private void addRecentCut ( S t r i n g cut ) {
recentCuts . insertElementAt ( cut , 0 ) ;
i f( recentCuts . s i z e ( ) >10){// I f m o r e t h a n 1 0 c u t s
recentCuts . removeElementAt ( 1 0 ) ; // r e m o v e o l d e s t c u t
}
cutsMenu . removeAll ( ) ;
for (i n t k = 0 ; k <recentCuts . s i z e ( ) ; k++) {
JMenuItem item =
new JMenuItem ( ( S t r i n g ) recentCuts . elementAt ( k ) ) ;
cutsMenu . add ( item ) ;
item . addActionListener ( t h i s ) ;
}
}// a d d R e c e n t C u t ( )
✡ ✠
SOLUTION 13.10 Modify the addRecentCut() method so that it doesn’t du-
plicate cuts stored in the vector. Solution: Use the indexOf() method to search
for the cut in the vector. If it’s already there, don’t insert the cu t.
☛ ✟
private void addRecentCut ( S t r i n g cut ) {
i f( recentCuts . indexOf ( cut ) == −1){// I f n o t a l r e a d y c u t
recentCuts . insertElementAt ( cut , 0 ) ;
i f( recentCuts . s i z e ( ) >10){// I f m o r e t h a n 1 0 c u t s
recentCuts . removeElementAt ( 1 0 ) ; // r e m o v e o l d e s t
}
cutsMenu . removeAll ( ) ;
for (i n t k = 0 ; k <recentCuts . s i z e ( ) ; k++) {
JMenuItem item =
new JMenuItem ( ( S t r i n g ) recentCuts . elementAt ( k ) ) ;
cutsMenu . add ( item ) ;
item . addActionListener ( t h i s ) ;
}
}// i f n o t a l r e a d y c u t
}// a d d R e c e n t C u t ( )
✡ ✠
CHAPTER 13 •Exercises 653
EXERCISES EXERCISE 13.1 Explain the difference between the following pairs of terms:
a. A model and a view .
b. A view and a controller .
c. A lightweight and heavyweight component.
d. AJButton and aButton .
e. A layout manager and a container .
f. A containment hierarchy and an inheritance hierarchy .
g. A content pane and aJFrame .Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 13.2 Fill in the blanks.
a. A GUI component that is written entirely in Java is known as a
component.
b. The AWT is not platform independent because it uses the model to
implement its GUI components.
c. The visual elements of a GUI are arranged in a .
d. A is an object that takes responsibility for arranging the componen ts
in a container.
e. The default layout manager for a JPanel is .
f. The default layout manager for a JApplet is .
EXERCISE 13.3 Describe in general terms what you would have to do to change
the standard look and feel of a Swing JButton .
EXERCISE 13.4 Explain the differences between the model-view-controller de -
sign of a JButton and the design of an AWT Button . Why is MVC superior?
EXERCISE 13.5 Suppose you have an applet that contains a JButton and a
JLabel . Each time the button is clicked, the applet rearranges the le tters in the
label. Using Java’s event model as a basis, explain the sequenc e of events that
happens in order for this action to take place.
EXERCISE 13.6 Draw a containment hierarchy for the most recent GUI version
of theOneRowNim program.
EXERCISE 13.7 Create a GUI design, similar to the one shown in Figure 13.25,
for a program that would be used to buy tickets online for a rock concer t.
EXERCISE 13.8 Create a GUI design, similar to the one shown in Figure 13.25,
for an online program that would be used to play musical recordings .
EXERCISE 13.9 Design and implement a GUI for the CDInterest program
(Fig. 5.18). This program should let the user input the interes t rate, principal, and
period and should accumulate the value of the investment.
EXERCISE 13.10 Design and implement a GUI for the Temperature class
(Fig. 5.5). One challenge of this design is to ﬁnd a good way for the user to indicate
whether a Fahrenheit or Celsius value is being input. This shou ld also determine
the order of the conversion: F to C or C to F.
EXERCISE 13.11 Design an interface for a 16-button integer calculator that sup -
ports addition, subtraction, multiplication, and division. Imp lement the interface
so that the label of the button is displayed in the calculator’s di splay—that is, it
doesn’t actually do the math.
654 CHAPTER 13 •Graphical User Interfaces
EXERCISE 13.12 Challenge: Design and implement a Calculator class to go
along with the interface you developed in the previous exercise. It should function
the same way as a hand calculator except it only handles integer s.
EXERCISE 13.13 Modify the Converter application so that it can convert in
either direction: from miles to kilometers or from kilometers to mi les. Use radio
buttons in your design to let the user select one or the other altern ative.
EXERCISE 13.14 Here’s a design problem for you. A biologist needs an inter-
active program that calculates the average of some ﬁeld data rep resented as real
numbers. Any real number could be a data value, so you can’t use a s entinel
value, such as 9999, to indicate the end of the input. Design an d implement a
suitable interface for this problem.
EXERCISE 13.15 Challenge: A dialog box is a window associated with an ap-
plication that appears only when needed. Dialog boxes have many u ses. An error
dialog is used to report an error message. A ﬁle dialog is used to he lp the user
search for and open a ﬁle. Creating a basic error dialog is very sim ple in Swing.
TheJOptionPane class has class methods that can be used to create the kind
of dialog shown in Figure 13.36. Such a dialog box can be created with a single
statement:
FIGURE 13.36 A basic
JOptionPane error dialog.☛ ✟
JOptionPane . showMessageDialog ( this ,
” Sorry , your number i s out of range . ” ) ;
✡ ✠
Convert the Validate program (Fig. 6.12 from Chapter 6) to a GUI interface and
use the JOptionPane dialog to report errors.
EXERCISE 13.16 Challenge: Design and implement a version of the game Mem-
ory. In this game you are given a two-dimensional grid of boxes that cont ains pairs
of matching images or strings. The object is to ﬁnd the matching p airs. When you
click a box, its contents are revealed. You then click another box. If its contents
match the ﬁrst one, their contents are left visible. If not, the b oxes are closed up
again. The user should be able to play multiple games without ge tting the same
arrangement every time.
EXERCISE 13.17 Challenge: Extend the SimpleTextEditor program by
adding methods to handle the opening, closing and saving of text ﬁ les.
OBJECTIVES
After studying this chapter, you will
•Understand the concept of a thread.
•Know how to design and write multithreaded programs.
•Be able to use the Thread class and the Runnable interface.
•Understand the life cycle of a thread.
•Know how to synchronize threads.
OUTLINE
14.1 Introduction
14.2 What Is a Thread?
14.3 From the Java Library: java.lang.Thread
14.4 Thread States and Life Cycle
14.5 Using Threads to Improve Interface Responsiveness
14.6 Case Study: Cooperating Threads
14.7 Case Study: The Game of Pong
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 14
Threads and Concurrent
Programming
655
656 CHAPTER 14 •Threads and Concurrent Programming
14.1 Introduction
This chapter is about doing more than one thing at a time. Doin g more
than one thing at once is commonplace in our everyday lives. F or exam-
ple, let’s say your breakfast today consists of cereal, toas t, and a cup of
java. You have to do three things at once to have breakfast: eat cereal, eat
toast, and drink coffee.
Actually, you do these things “at the same time” by alternati ng among
them: You take a spoonful of cereal, then a bite of toast, and t hen sip some
coffee. Then you have another bite of toast, or another spoon ful of cereal,
more coffee, and so on, until breakfast is ﬁnished. If the phon e rings while
you’re having breakfast, you will probably answer it—and con tinue to
have breakfast, or at least to sip the coffee. This means you’ re doing even
more “at the same time.” Everyday life is full of examples whe re we do
more than one task at the same time.
The computer programs we have written so far have performed o ne
task at a time. But there are plenty of applications where a pr ogram needs
to do several things at once, or concurrently . For example, if you wrote
an Internet chat program, it would let several users take part in a dis-
cussion group. The program would have to read messages from s everal
users at the same time and broadcast them to the other partici pants in
the group. The reading and broadcasting tasks would have to t ake place
concurrently. In Java, concurrent programming is handled by threads , the
topic of this chapter.
14.2 What Is a Thread?
Athread (or a thread of execution or athread of control ) is a single sequence of
executable statements within a program. For Java applicati ons, the ﬂow of
control begins at the ﬁrst statement in main() and continues sequentially
through the program statements. For Java applets, the ﬂow of c ontrol
begins with the ﬁrst statement in init() . Loops within a program cause
a certain block of statements to be repeated. If-else structu res cause certain
statements to be selected and others to be skipped. Method ca lls cause the
ﬂow of execution to jump to another part of the program, from whi ch it
returns after the method’s statements are executed. Thus, w ithin a single
thread, you can trace the sequential ﬂow of execution from one statement
to the next.
One way to visualize a thread is to imagine that you could make a list Visualizing a thread
of the program’s statements as they are executed by the compu ter’s cen-
tral processing unit (CPU). Thus, for a particular executio n of a program
with loops, method calls, and selection statements, you cou ld list each
instruction that was executed, beginning at the ﬁrst, and co ntinuing until
the program stopped, as a single sequence of executed statem ents. That’s
a thread!
Now imagine that we break a program up into two or more indepen -
dent threads. Each thread will have its own sequence of instr uctions.
Within a single thread, the statements are executed one afte r the other, as
usual. However, by alternately executing the statements fro m one thread
and another, the computer can run several threads concurrently . Even
SECTION 14.2 •What Is a Thread? 657
though the CPU executes one instruction at at time, it can run multiple
threads concurrently by rapidly alternating among them. Th e main ad-
vantage of concurrency is that it allows the computer to do mo re than
one task at a time. For example, the CPU could alternate betwe en down-
loading an image from the Internet and running a spreadsheet c alcula-
tion. This is the same way you ate toast and cereal and drank co ffee in
our earlier breakfast example. From our perspective, it mig ht look as if
the computer had several CPUs working in parallel, but that’ s just the
illusion created by an effectively scheduling threads.
JAVA LANGUAGE RULE JVM Threads. The Java Virtual Machine
(JVM) is itself an example of a multithreaded program. JVM th reads
perform tasks that are essential to the successful executio n of Java
programs.
JAVA LANGUAGE RULE Garbage Collector Thread. One of the
JVM threads, the garbage collector thread , automatically reclaims mem-
ory taken up by objects that are not used in your programs. This
happens at the same time that the JVM is interpreting your pro gram.
14.2.1 Concurrent Execution of Threads
The technique of concurrently executing several tasks with in a program is Multitasking
known as multitasking . Atask in this sense is a computer operation of
some sort, such as reading or saving a ﬁle, compiling a progra m, or dis-
playing an image on the screen. Multitasking requires the us e of a separate
thread for each of the tasks. The methods available in the Jav aThread
class make it possible (and quite simple) to implement multithreaded
programs.
Most computers, including personal computers, are sequential machines
that consist of a single CPU, which is capable of executing on e machine in-
struction at a time. In contrast, parallel computers , used primarily for large
scale scientiﬁc and engineering applications, are made up o f multiple
CPUs working in tandem.
Today’s personal computers, running at clock speeds over 1 g igahertz—
1gigahertz equals 1 billion cycles per second—are capable of executing
millions of machine instructions per second. Despite its gr eat speed,
however, a single CPU can process only one instruction at a ti me.
Each CPU uses a fetch-execute cycle to retrieve the next instruction
from memory and execute it. Since CPUs can execute only one in struc-
tion at a time, multithreaded programs are made possible by d ividing
the CPU’s time and sharing it among the threads. The CPU’s sch edule
is managed by a scheduling algorithm , which is an algorithm that sched-
ules threads for execution on the CPU. The choice of a schedul ing algo-
rithm depends on the platform on which the program is running . Thus,
thread scheduling might be handled differently on Unix, Win dows, and
Macintosh systems.
One common scheduling technique is known as time slicing , in which CPUs are sequential
658 CHAPTER 14 •Threads and Concurrent Programming
Figure 14.1: Each thread gets a
slice of the CPU’s time.
CPU time
QuantumThread 1
Thread 2
each thread alternatively gets a slice of the CPU’s time. For example, sup-
pose we have a program that consists of two threads. Using thi s tech-
nique, the system would give each thread a small quantum of CPU time—
say, one thousandth of a second (one millisecond )—to execute its instruc-
tions. When its quantum expires, the thread would be preempted and the
other thread would be given a chance to run. The algorithm wou ld then
alternate in this round-robin fashion between one thread and the other
(Fig. 14.1). During each millisecond on a 300-megahertz CPU , a thread Time slicing
can execute 300,000 machine instructions. One megahertz equals 1 mil-
lion cycles per second. Thus, within each second of real time , each thread
will receive 500 time slices and will be able to execute somet hing like 150
million machine instructions.
Under priority scheduling , threads of higher priority are allowed to Priority scheduling
run to completion before lower-priority threads are given a chance. An
example of a high-priority thread would be one that is proces sing key-
board input or any other kind of interactive input from the us er. If such
tasks were given low priority, users would experience notic eable delays
in their interaction, which would be quite unacceptable.
The only way a high-priority thread can be preempted is if a th read
of still higher priority becomes available to run. In many cas es, higher-
priority threads are those that can complete their task with in a few mil-
liseconds, so they can be allowed to run to completion withou t starving
the lower-priority threads. An example would be processing a user’s
keystroke, a task that can begin as soon as the key is struck an d can be
completed very quickly. Starvation occurs when one thread i s repeatedly
preempted by other threads.
JAVA LANGUAGE RULE Thread Support. Depending on the hard-
ware platform, Java threads can be supported by assigning di fferent
threads to different processors, by time slicing a single pr ocessor, or by
time slicing many hardware processors.
14.2.2 Multithreaded Numbers
Let’s consider a simple example of a threaded program. Suppo se we give
every individual thread a unique ID number, and each time it ru ns, it
prints its ID ten times. For example, when the thread with ID 1 ru ns the
output produced would just be a sequence of ten 1’s: 111111111 1.
As shown in Figure 14.2, the NumberThread class is deﬁned as a sub-+NumberThread(in n : int)
+run()NumberThread+run()Thread
FIGURE 14.2 TheNumberThread
class overrides the inherited run()
method.class of Thread and overrides the run() method. To set the thread’s ID
SECTION 14.2 •What Is a Thread? 659
Creates
Creates: Numbersthread1 : NumberThread
thread2 : NumberThread
thread3 : NumberThreadstart()
start()
start()CreatesFigure 14.3: The Numbers ob-
ject creates several instances of
NumberThread and tells each
one tostart() .
number, the constructor takes a single parameter that is use d to set the
thread’s ID number. In the run() method, the thread simply executes a
loop that prints its own number ten times:
☛ ✟
public c l a s s NumberThread extends Thread {
i n t num;
public NumberThread ( i n t n ){
num = n ;
}
public void run ( ){
for (i n t k =0; k <1 0 ; k++) {
System . out . p r i n t (num ) ;
}// f o r
}// r u n ( )
}// N u m b e r T h r e a d
✡ ✠Thread subclass
Now let’s deﬁne another class whose task will be to create man y
NumberThread s and get them all running at the same time (Fig. 14.3). For
eachNumberThread , we want to call its constructor and then start()
it:
☛ ✟
public c l a s s Numbers {
public s t a t i c void main ( S t r i n g args [ ] ) {
// 5 t h r e a d s
NumberThread number1 , number2 , number3 , number4 , number5 ;
// C r e a t e a n d s t a r t e a c h t h r e a d
number1 = new NumberThread ( 1 ) ; number1 . s t a r t ( ) ;
number2 = new NumberThread ( 2 ) ; number2 . s t a r t ( ) ;
number3 = new NumberThread ( 3 ) ; number3 . s t a r t ( ) ;
number4 = new NumberThread ( 4 ) ; number4 . s t a r t ( ) ;
number5 = new NumberThread ( 5 ) ; number5 . s t a r t ( ) ;
}// m a i n ( )
}// N u m b e r s
✡ ✠
When a thread is started by calling its start() method, it automati-
cally calls its run() method. The output generated by this version of Starting a thread
660 CHAPTER 14 •Threads and Concurrent Programming
theNumbers application is as follows:
☛ ✟
11111111112222222222333333333344444444445555555555
✡ ✠
From this output, it appears that the individual threads wer e run in the
order in which they were created. In this case, each thread was able to run
to completion before the next thread started running.
What if we increase the number of iterations that each thread p er-
forms? Will each thread still run to completion? The followi ng output
was generated for 200 iterations per thread:
☛ ✟
111111111111111111111111111111111111111111111111111 111111111111111111
111111111111111111111111111111111111111111111111111 111111111111111111
111111111111111111111111111111111111111111111111111 111111111112222222
222222222222222222222222222222222222222222222222222 222222222222222222
222222222222222222222222222222222222222222222222222 222222222222222222
222222222222222222222222222222222222222222223333333 333333333333333333
333333333333333333333333333333333333333333333333333 333333333333333333
333333333333333333333333333444444444444444444444444 444444444444444444
444444444444444444444444444444444444444444444444444 444444444444444444
444444444455555555555555555555555555555555555555555 555555555555555555
555555555555555555555555555555555555555555555555555 555555555552222222
222233333333333333333333333333333333333333333333333 333333333333333333
333333333333334444444444444444444444444444445555555 555555555555555555
555555555555555555555555555555555555555555555555555 555444444444444444
4444444444444444444444444444444444
✡ ✠
In this case, only thread 1 managed to run to completion. Threa ds 2, 3,
4, and 5 did not. As this example illustrates, the order and ti ming of a
thread’s execution are highly unpredictable. This example also serves to
illustrate one way of creating a multithreaded program:+Thread()
+Thread(in target : Runnable)
+Thread(in name : String)
+getName() : String
+getPriority() : int
+run()
+setName(in s : String)
+setPriority(in priority : int)
+start()
+stop()Thread+run()«interface»
Runnable
FIGURE 14.4 The
java.lang.Thread class. NOTE:
NEEDS REVISION TO ADD
PRIORITY, YIELD() and SLEEP().•Create a subclass of the Thread class.
•Within the subclass, implement a method with the signature void
run() that contains the statements to be executed by that thread.
•Create several instances of the subclass and start each thre ad by invok-
ing the start() method on each instance.
JAVA LANGUAGE RULE Thread Creation. One way to create a
thread in Java is to deﬁne a subclass of Thread and override the default
run() method.
14.3 From the Java Library: java.lang.Thread
Thejava.lang.Thread class contains the public methods shown in Fig-
ure 14.4 (the ﬁgure contains only a partial list). Note that Thread im-
plements the Runnable interface, which consists simply of the run()
method. As we will now see, another way to create a thread is to instan-
tiate a Thread object and pass it a Runnable object that will become its
body. This approach allows you to turn an existing class into a separate
thread.
ARunnable object is any object that implements the Runnable
interface—that is, any object that implements the run() method
SECTION 14.3 •From the Java Library: java.lang.Thread 661
(Fig. 14.5). The following example provides an alternative way to imple-
ment the NumberThread program:
+NumberPrinter(in n : int)
+run()-num : intNumberPrinter+run()«interface»
Runnable
FIGURE 14.5 Any object that
implements the Runnable interface
can be run as a separate thread.☛ ✟
public c l a s s NumberPrinter implements Runnable {
i n t num;
public NumberPrinter ( i n t n ){
num = n ;
}
public void run ( ){
for (i n t k =0; k <1 0 ; k++)
System . out . p r i n t (num ) ;
}// r u n ( )
}// N u m b e r P r i n t e r
✡ ✠
Given this deﬁnition, we would then pass instances of this cl ass to the
individual threads as we create them:
☛ ✟
public c l a s s Numbers {
public s t a t i c void main ( S t r i n g args [ ] ) {
Thread number1 , number2 , number3 , number4 , number5 ;
// C r e a t e a n d s t a r t e a c h t h r e a d
number1 = new Thread ( new NumberPrinter ( 1 ) ) ; number1 . s t a r t ( ) ;
number2 = new Thread ( new NumberPrinter ( 2 ) ) ; number2 . s t a r t ( ) ;
number3 = new Thread ( new NumberPrinter ( 3 ) ) ; number3 . s t a r t ( ) ;
number4 = new Thread ( new NumberPrinter ( 4 ) ) ; number4 . s t a r t ( ) ;
number5 = new Thread ( new NumberPrinter ( 5 ) ) ; number5 . s t a r t ( ) ;
}// m a i n ( )
}// N u m b e r s
✡ ✠
TheNumberPrinter class implements Runnable by deﬁning exactly
the same run() that was used previously in the NumberThread class.
We then pass instances of NumberPrinter when we create the individ-
ual threads. Doing things this way gives exactly the same out put as earlier.
This example serves to illustrate another way of creating a m ultithreaded
program:
•Implement the Runnable interface for an existing class by implement-
ing the void run() method, which contains the statements to be exe-
cuted by that thread.
•Create several Thread instances by ﬁrst creating instances of the
Runnable class and passing each instance as an argument to the
Thread() constructor.
•For each thread instance, start it by invoking the start() method on
it.
JAVA LANGUAGE RULE Thread Creation. A thread can be created
by passing a Runnable object to a new Thread instance. The object’s
run() method will be invoked automatically as soon as the thread’s
start() method is called.
662 CHAPTER 14 •Threads and Concurrent Programming
JAVA EFFECTIVE DESIGN Converting a Class to a Thread. Using
theRunnable interface to create threads enables you to turn an
existing class into a thread. For most applications, using t he
Runnable interface is preferable to redeﬁning the class as a Thread
subclass.
SELF-STUDY EXERCISE
EXERCISE 14.1 Use the Runnable interface to convert the following
class into a thread. You want the thread to print all the odd nu mbers up
to its bound:
☛ ✟
public c l a s s PrintOdds {
private i n t bound ;
public PrintOdds ( i n t b ){
bound = b ;
}
public void p r i n t ( ) {
i f(i n t k = 1 ; k <bound ; k+=2)
System . out . p r i n t l n ( k ) ;
}
}// P r i n t O d d s
✡ ✠
14.3.1 Thread Control
The various methods in the Thread class (Fig. 14.4) can be used to ex-
ert some control over a thread’s execution. The start() andstop() Controlling threads
methods play the obvious roles of starting and stopping a thr ead. These
methods will sometimes be called automatically. For exampl e, an applet
is treated as a thread by the browser, or appletviewer, which is responsible
for starting and stopping it.
As we saw in the NumberThread example, the run() method encap-
sulates the thread’s basic algorithm. It is usually not calle d directly. In-
stead, it is called by the thread’s start() method, which handles any
system-dependent initialization tasks before calling run() .
14.3.2 Thread Priority
ThesetPriority(int) method lets you set a thread’s priority to an in-
teger value between Thread.MIN PRIORITY andThread.MAX PRIOR-
ITY, the bounds deﬁned as constants in the Thread class. Using set-
Priority() gives you some control over a thread’s execution. In gen-
SECTION 14.3 •From the Java Library: java.lang.Thread 663
eral, higher-priority threads get to run before, and longer than, lower-
priority threads.
JAVA LANGUAGE RULE Preemption. A higher-priority thread
that wants to run will preempt any threads of lower priority.
To see how setPriority() works, suppose we change NumberThread ’s
constructor to the following:
☛ ✟
public NumberThread ( i n t n ){
num = n ;
s e t P r i o r i t y ( n ) ;
}
✡ ✠
In this case, each thread sets its priority to its ID number. So, thread ﬁve
will have priority ﬁve, a higher priority than all the other t hreads. Sup- Thread priority
pose we now run 2 million iterations of each of these threads. Because 2
million iterations will take a long time if we print the threa d’s ID on each
iteration, let’s modify the run() method, so that the ID is printed every 1
million iterations:
☛ ✟
for (i n t k = 0 ; k <1 0 ; k++)
i f( k % 1000000 == 0)
System . out . p r i n t (num ) ;
✡ ✠
Given this modiﬁcation, we get the following output when we r un
Numbers :
☛ ✟
5544332211
✡ ✠
It appears from this output that the threads ran to completion in priority
order. Thus, thread ﬁve completed 2 million iterations befo re thread four
started to run, and so on. This shows that, on my system at leas t, the Java
Virtual Machine (JVM) supports priority scheduling.
JAVA PROGRAMMING TIP Platform Dependence. Thread
implementation in Java is platform dependent. Adequate tes ting is
necessary to ensure that a program will perform correctly on a given
platform.
JAVA EFFECTIVE DESIGN Thread Coordination. One way to
coordinate the behavior of two threads is to give one thread h igher
priority than another.
JAVA DEBUGGING TIP Starvation. A high-priority thread that
never gives up the CPU can starve lower-priority threads by
preventing them from accessing the CPU.
664 CHAPTER 14 •Threads and Concurrent Programming
14.3.3 Forcing Threads to Sleep
TheThread.sleep() andThread.yield() methods also provide
some control over a thread’s behavior. When executed by a thre ad, the
yield() method causes the thread to yield the CPU, allowing the threa d
scheduler to choose another thread. The sleep() method causes the Sleep versus yield
thread to yield and not to be scheduled until a certain amount of real time
has passed.
JAVA LANGUAGE RULE Sleep Versus Yield. Both the yield()
andsleep() methods yield the CPU, but the sleep() method keeps
the thread from being rescheduled for a ﬁxed amount of real ti me.
Thesleep() method can halt a running thread for a given number of mil-
liseconds, allowing other waiting threads to run. The sleep() method
throws an InterruptedException , which is a checked exception. This
means that the sleep() call must be embedded within a try/catch
block or the method it’s in must throw an InterruptedException .
Try/catch blocks were covered in Chapter 10.
☛ ✟
t r y{
sleep ( 1 0 0 ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
✡ ✠
For example, consider the following version of the NumberPrinter.run() :
☛ ✟
public void run ( ){
for (i n t k =0; k <1 0 ; k++) {
t r y{
Thread . sleep ( ( long ) ( Math . random ( ) ∗1 0 0 0 ) ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
System . out . p r i n t (num ) ;
}// f o r
}// r u n ( )
✡ ✠
In this example, each thread is forced to sleep for a random num ber of
milliseconds between 0 and 1,000. When a thread sleeps, it giv es up the
CPU, which allows one of the other waiting threads to run. As y ou would
expect, the output we get from this example will reﬂect the ran domness
in the amount of time that each thread sleeps:
☛ ✟
14522314532143154232152423541243235415523113435451
✡ ✠
As we will see, the sleep() method provides a rudimentary form of
thread synchronization, in which one thread yields control to another.
SECTION 14.3 •From the Java Library: java.lang.Thread 665
SELF-STUDY EXERCISES
EXERCISE 14.2 What happens if you run ﬁve NumberThread s of
equal priority through 2 million iterations each? Run this e xperiment and
note the output. Don’t print after every iteration! What sort of scheduling
algorithm (round-robin, priority scheduling, or somethin g else) was used
to schedule threads of equal priority on your system?
EXERCISE 14.3 Try the following experiment and note the output. Let
each thread sleep for 50 milliseconds (rather than a random n umber of
milliseconds). How does this affect the scheduling of the thr eads? To
make things easier to see, print each thread’s ID after every 1 00,000 itera-
tions.
EXERCISE 14.4 The purpose of the Java garbage collector is to recap-
ture memory that was used by objects that are no longer being us ed by
your program. Should its thread have higher or lower priorit y than your
program?
14.3.4 The Asynchronous Nature of Threaded Programs
Threads are asynchronous . This means that the order of execution and
the timing of a set of threads are unpredictable, at least fro m the pro-
grammer’s point of view. Threads are executed under the cont rol of the
scheduling algorithm used by the operating system and the Ja va Virtual
Machine. In general, unless threads are explicitly synchron ized, it is im-
possible for the programmer to predict when and for how long a n indi-
vidual thread will run. In some systems, under some circumsta nces, a Thread preemptions are unpredictable
thread might run to completion before any other thread can ru n. In other
systems, or under different circumstances, a thread might r un for a short
time and then be suspended while another thread runs. Of cour se, when
a thread is preempted by the system, its state is saved so that its execution
can be resumed without losing any information.
One implication of a thread’s asynchronicity is that it is no t generally
possible to determine where in its source code an individual thread might
be preempted. You can’t even assume that a thread will be able to com-
plete a simple Java arithmetic operation once it has started it. For example,
suppose a thread had to execute the following operation:
☛ ✟
i n t N = 5 + 3 ;
✡ ✠
This operation computes the sum of 5 and 3 and assigns the resu lt toN. It
would be tempting to think that once the thread started this o peration, it An arithmetic operation can be
interrupted would be able to complete it, but that is not necessarily so. Y ou have to
remember that Java code is compiled into a rudimentary bytec ode, which
is translated still further into the computer’s machine lan guage. In ma-
chine language, this operation would break down into someth ing like the
following three steps:
☛ ✟
Fetch 5 from memory and s t o r e i t in r e g i s t e r A.
Add 3 to r e g i s t e r A.
Assign the value in r e g i s t e r A to N.
✡ ✠
666 CHAPTER 14 •Threads and Concurrent Programming
Although none of the individual machine instructions can be preempted,
the thread could be interrupted between any two machine inst ructions.
The point here is that not even a single Java language instruc tion can be
assumed to be indivisible or unpreemptible. Therefore, it i s impossible to
make any assumptions about when a particular thread will run and when
it will give up the CPU. This suggests the following importan t principle
of multithreaded programs: Threads are asynchronous
JAVA LANGUAGE RULE Asynchronous Thread Principle. Unless
they are explicitly prioritized or synchronized, threads b ehave in a
completely asynchronous fashion.
JAVA PROGRAMMING TIP Thread Timing. Unless they are
explicitly synchronized, you cannot make any assumptions a bout
when, or in what order, individual threads will execute, or w here a
thread might be interrupted or preempted during its executi on.
As we will see, this principle plays a large role in the design of multi-
threaded programs.
14.4 Thread States and Life Cycle
Each thread has a life cycle that consists of several different states, which
are summarized in Figure 14.6 and Table 14.1. Thread states a re rep-
resented by labeled ovals, and the transitions between stat es are repre-
sented by labeled arrows. Much of a thread’s life cycle is und er the Ready, running, and sleeping
control of the operating system and the Java Virtual Machine . Those
transitions represented by method names—such as start() ,stop() , Controlling a thread
wait() ,sleep() ,notify() —can be controlled by the program. Of
these methods, the stop() method has been deprecated in JDK 1.2 be-
cause it is inherently unsafe to stop a thread in the middle of its execution.
Other transitions—such as dispatch, I/O request, I/O done, time expired, done
sleeping —are under the control of the CPU scheduler. When ﬁrst created
a thread is in the ready state, which means that it is ready to r un. In the
Figure 14.6: A depiction of a
thread’s life cycle.
WaitingSleeping Running
DeadBlockedDispatchDone
    sleepingReadyI/O done
I/O requestedTime
Expires
stop()sleep()notify()
notifyAll()start()
wait()
SECTION 14.4 •Thread States and Life Cycle 667
TABLE 14.1 A summary of the different thread states.
State Description
Ready The thread is ready to run and waiting for the CPU.
Running The thread is executing on the CPU.
Waiting The thread is waiting for some event to happen.
Sleeping The thread has been told to sleep for a time.
Blocked The thread is waiting for I/O to ﬁnish.
Dead The thread is terminated.
ready state, a thread is waiting, perhaps with other threads , in the ready
queue , for its turn on the CPU. A queue is like a waiting line. When
the CPU becomes available, the ﬁrst thread in the ready queue will be
dispatched —that is, it will be given the CPU. It will then be in the running
state. The ready queue
Transitions between the ready and running states happen und er the
control of the CPU scheduler, a fundamental part of the Java r untime
system. The job of scheduling many threads in a fair and efﬁcie nt manner CPU scheduler
is a little like sharing a single bicycle among several child ren. Children
who are ready to ride the bike wait in line for their turn. The g rown up
(scheduler) lets the ﬁrst child (thread) ride for a period of time before the
bike is taken away and given to the next child in line. In round- robin
scheduling, each child (thread) gets an equal amount of time on the bike
(CPU).
When a thread calls the sleep() method, it voluntarily gives up the
CPU, and when the sleep period is over, it goes back into the re ady queue.
This would be like one of the children deciding to rest for a mo ment dur-
ing his or her turn. When the rest was over, the child would get b ack in
line.
When a thread calls the wait() method, it voluntarily gives up the
CPU, but this time it won’t be ready to run again until it is not iﬁed by Threads can give up the CPU
some other thread.
This would be like one child giving his or her turn to another c hild.
When the second child’s turn is up, it would notify the ﬁrst chi ld, who
would then get back in line.
The system also manages transitions between the blocked and ready
states. A thread is put into a blocked state when it does some k ind of I/O
operation. I/O devices, such as disk drives, modems, and keyb oards, are Threads block on I/O operations
very slow compared to the CPU. Therefore, I/O operations are h andled
by separate processors known as controllers . For example, when a thread
wants to read data from a disk drive, the system will give this task to the
disk controller, telling it where to place the data. Because the thread can’t
do anything until the data are read, it is blocked, and anothe r thread is
allowed to run. When the disk controller completes the I/O oper ation,
the blocked thread is unblocked and placed back in the ready q ueue.
In terms of the bicycle analogy, blocking a thread would be lik e giving
the bicycle to another child when the rider has to stop to tie h is or her
shoe. Instead of letting the bicycle just sit there, we let anot her child ride
it. When the shoe is tied, the child is ready to ride again and go es back
668 CHAPTER 14 •Threads and Concurrent Programming
into the ready line. Letting other threads run while one thre ad is waiting
for an I/O operation to complete improves the overall utiliza tion of the
CPU.
SELF-STUDY EXERCISE
EXERCISE 14.5 Round-robin scheduling isn’t always the best idea.
Sometimes priority scheduling leads to a better system. Can you think
of ways that priority scheduling—higher-priority threads g o to the head
of the line—can be used to improve the responsiveness of an int eractive
program?
14.5 Using Threads to Improve
Interface Responsiveness
One good use for a multithreaded program is to help make a more respon-
sive user interface. In a single-threaded program, a program that is ex-
ecuting statements in a long (perhaps even inﬁnite) loop rem ains unre-
sponsive to the user’s actions until the loop is exited. Thus , the user will
experience a noticeable and sometimes frustrating delay be tween the time
an action is initiated and the time it is actually handled by t he program.
14.5.1 Single-Threaded Design
It’s always a good idea that the interface be responsive to use r input, but
sometimes it is crucial to an application. For example, supp ose a psy-
chology experiment is trying to measure how quickly a user re sponds to
a certain stimulus presented by a program. Obviously, for th is kind of
application, the program should take action as soon as the us er clicks a
button to indicate a response to the stimulus. Let’s work thr ough an ap-
propriate program design for the experiment. First, we will formally state
the situation and describe what the program should do. Then, we will
examine the components that would make up an effective progr am.
FIGURE 14.7 Random dots are
drawn until the user clicks the Clear
button.Problem Statement
A psychologist is conducting a psychometric experiment to m easure user
response to a visual cue and asks you to create the following p rogram.
The program should have two buttons. When the Draw button is cl icked,
the program begins drawing thousands of black dots at random locations Problem speciﬁcation
within a rectangular region of the screen (Fig. 14.7). After a random time
interval, the program begins drawing red dots. This change c orresponds
to the presentation of the stimulus. As soon as the stimulus i s presented
the user is supposed to click on a Clear button, which clears t he drawing
area. To provide a measure of the user’s reaction time, the pr ogram should
report how many red dots were drawn before the user clicked th e Clear
button.
SECTION 13.4 •Using Threads to Improve Interface Responsiveness 669
Drawing
JPanelJFrame JButtons
Controls
JPanel
BorderLayout
northJFrame
          Controls JPanel
                 Draw JButton
                 Clear JButton
          Drawing JPanel
BorderLayout
centerClear DrawComponent HierarchyFigure 14.8: GUI design for the
dot-drawing program.
Figure 14.8 shows a design for this program’s GUI. It contains a con-
trolJPanel that contains the two JButton s. The dots are drawn on a
JPanel , which is positioned in the center of a BorderLayout design. GUI design
Problem Decomposition
This program should be decomposed into two classes, a GUI to h andle
the user interface and a drawing class to manage the drawing. The main Interface class and drawing class
features of its classes are as follows:
•RandomDotGUI Class: This class manages the user interface, respond-
ing to user actions by calling methods of the Dotty class (Fig. 14.9).
•Dotty Class: This class contains draw() andclear() methods for
drawing on the GUI’s drawing panel (Fig. 14.10).
TheRandomDotGUI Class+init()
+actionPerformed(in e : ActionEvent)+NDOTS : int =10000
-dotty : Dotty
-controls : JPanel
-canvas : JPanel
-draw : JButton
-clear : JButtonRandomDotGUI
FIGURE 14.9 TheRandomDotGUI .The implementation of RandomDotGUI is shown in Figure 14.11. The GUI
arranges the control and drawing panels in a BorderLayout and listens
for action events on its JButton s. When the user clicks the Draw but-
ton, the GUI’s actionPerformed() method will create a new Dotty
instance and call its draw() method:
☛ ✟
dotty = new Dotty ( canvas , NDOTS) ;
dotty . draw ( ) ;
✡ ✠
Note that Dotty is passed a reference to the drawing canvas as well as
the number of dots to be drawn. When the user clicks the Clear bu tton, the
GUI should call the dotty.clear() method. Of course, the important
question is, how responsive will the GUI be to the user’s acti on?+Dotty(in canv : JPanel, in n : int)
+draw()
+clear()+HREF : int final =20
+VREF : int final =20
+LEN : int final =200
-canvas : JPanel
-nDots : int
-nDrawn : int
-firstRed : int =0Dotty
FIGURE 14.10 TheDotty class
manages the drawing actions. TheDotty Class
The purpose of the Dotty class will be to draw the dots and to report
how many red dots were drawn before the canvas was cleared. Be cause
it will be passed a reference to the drawing panel and the numb er of dots
to draw, the Dotty class will need instance variables to store these two
values. It will also need a variable to keep track of how many do ts were
drawn. Finally, since it will be drawing within a ﬁxed rectan gle on the
670 CHAPTER 14 •Threads and Concurrent Programming
☛ ✟
import java . awt . ∗;
import javax . swing . ∗;
import java . awt . event . ∗;
public c l a s s RandomDotGUI extends JFrame
implements ActionListener {
public f i n a l i n t NDOTS = 10000;
private Dotty dotty ; // T h e d r a w i n g c l a s s
private JPanel c o n t r o l s = new JPanel ( ) ;
private JPanel canvas = new JPanel ( ) ;
private JButton draw = new JButton ( ”Draw” ) ;
private JButton c l e a r = new JButton ( ” Clear ” ) ;
public RandomDotGUI ( ) {
getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ;
draw . addActionListener ( t h i s ) ;
c l e a r . addActionListener ( t h i s ) ;
c o n t r o l s . add ( draw ) ;
c o n t r o l s . add ( c l e a r ) ;
canvas . setBorder (
BorderFactory . c r e a t e T i t l e d B o r d e r ( ”Drawing Canvas” ) ) ;
getContentPane ( ) . add ( ”North” , c o n t r o l s ) ;
getContentPane ( ) . add ( ” Center ” , canvas ) ;
getContentPane ( ) . s e t S i z e ( 4 0 0 , 4 0 0 ) ;
}
public void actionPerformed ( ActionEvent e ) {
i f( e . getSource ( ) == draw ) {
dotty = new Dotty ( canvas , NDOTS) ;
dotty . draw ( ) ;
}else{
dotty . c l e a r ( ) ;
}
}// a c t i o n P e r f o r m e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
RandomDotGUI gui = new RandomDotGUI ( ) ;
gui . s e t S i z e ( 4 0 0 , 4 0 0 ) ;
gui . s e t V i s i b l e ( true ) ;
}
}// R a n d o m D o t G U I
✡ ✠
Figure 14.11: The RandomDotGUI class.
panel, the reference coordinates and dimensions of the draw ing area are
declared as class constants.
TheDotty() constructor method will be passed a reference to a draw-
ing panel as well as the number of dots to be drawn and will mere ly assign
these parameters to its instance variables. In addition to it s constructor
method, the Dotty class will have public draw() andclear() meth-
ods, which will be called from the GUI. The draw() method will use a
loop to draw random dots. The clear() will clear the canvas and report
the number of dots drawn.
SECTION 13.4 •Using Threads to Improve Interface Responsiveness 671
☛ ✟
import java . awt . ∗;
import javax . swing . ∗; // I m p o r t S w i n g c l a s s e s
public c l a s s Dotty{
// C o o r d i n a t e s
private s t a t i c f i n a l i n t HREF = 20 , VREF = 20 , LEN = 2 0 0 ;
private JPanel canvas ;
private i n t nDots ; // N u m b e r o f d o t s t o d r a w
private i n t nDrawn ; // N u m b e r o f d o t s d r a w n
private i n t f i r s t R e d = 0 ; // N u m b e r o f t h e f i r s t r e d d o t
public Dotty ( JPanel canv , i n t dots ){
canvas = canv ;
nDots = dots ;
}
public void draw ( ) {
Graphics g = canvas . getGraphics ( ) ;
for (nDrawn = 0 ; nDrawn <nDots ; nDrawn++) {
i n t x = HREF + ( i n t) ( Math . random ( ) ∗LEN ) ;
i n t y = VREF + ( i n t) ( Math . random ( ) ∗LEN ) ;
g . f i l l O v a l ( x , y , 3 , 3 ) ; // Draw a d o t
i f( ( Math . random ( ) <0 . 0 0 1 ) && ( f i r s t R e d == 0 ) ) {
g . setColor ( Color . red ) ; // C h a n g e c o l o r t o r e d
f i r s t R e d = nDrawn ;
}
}// f o r
}// d r a w ( )
public void c l e a r ( ) { // C l e a r s c r e e n a n d r e p o r t r e s u l t
Graphics g = canvas . getGraphics ( ) ;
g . setColor ( canvas . getBackground ( ) ) ;
g . f i l l R e c t (HREF, VREF, LEN + 3 , LEN + 3 ) ;
System . out . p r i n t l n (
”Number of dots drawn s i n c e f i r s t red = ” + (nDrawn −f i r s t R e d ) ) ;
}// c l e a r ( )
}// D o t t y
✡ ✠
Figure 14.12: The Dotty class, single-threaded version.
The complete implementation of Dotty is shown in Figure 14.12. Note
how its draw() method is designed. The drawing loop is bounded by
the number of dots to be drawn. On each iteration, the draw() method
picks a random location within the rectangle deﬁned by the co ordinates
(HREF,VREF) and (HREF+LEN, VREF+LEN), and draws a dot there. O n
each iteration it also generates a random number. If the rando m number
is less than 0.001, it changes the drawing color to red and kee ps track of
the number of dots drawn up to that point.
The problem with this design is that as long as the draw() method
is executing, the program will be unable to respond to the GUI’ s Clear
button. In a single-threaded design, both the GUI and dotty are com-
bined into a single thread of execution (Fig. 14.13). When the user clicks
the Draw button, the GUI’s actionPerformed() method is invoked.
672 CHAPTER 14 •Threads and Concurrent Programming
Figure 14.13: A single-threaded
execution of random dot drawing.Draw button Clear button 10,000 dots
dotty.clear()
applet.init() dotty.draw() actionPerformed()
It then invokes Dotty ’sdraw() method, which must run to completion
before anything else can be done. If the user clicks the Clear b utton while
the dots are being drawn, the GUI won’t be able to get to this un til all the
dots are drawn.
If you run this program with nDots set to 10,000, the program will not
clear the drawing panel until all 10,000 dots are drawn, no ma tter when
the Clear button is pressed. Therefore, the values reported for the user’s
reaction time will be wrong. Obviously, since it is so unresp onsive to user
input, this design completely fails to satisfy the program’ s speciﬁcations.
JAVA LANGUAGE RULE Single-Threaded Loop. In a
single-threaded design, a loop that requires lots of iterat ions will
completely dominate the CPU during its execution, which for ces other
tasks, including user I/O tasks, to wait.
SELF-STUDY EXERCISE
EXERCISE 14.6 Suppose the Java Virtual Machine (JVM) was single
threaded and your program got stuck in an inﬁnite loop. Would you be
able to break out of the loop by typing some special command (s uch as
Control-C) from the keyboard?+run()«interface»
Runnable
+run()Dotty
FIGURE 14.14 In a multithreaded
design, the Dotty class implements
Runnable .14.5.2 Multithreaded Drawing: The Dotty Thread
One way to remedy this problem is to create a second thread (in addition
to the GUI itself) to do the drawing. The drawing thread will b e responsi-
ble just for drawing, while the GUI thread will be responsible for handling
user actions in the interface. The trick to making the user in terface more
responsive will be to interrupt the drawing thread periodic ally so that the
GUI thread has a chance to handle any events that have occurre d. Multithreaded design: Interrupt the
drawing loop As Figure 14.14 illustrates, the easiest way to convert Dotty into a
thread is to have it implement the Runnable interface:
☛ ✟
public c l a s s Dotty implements Runnable {
// E v e r y t h i n g e l s e r e m a i n s t h e s a m e
public void run ( ){
draw ( ) ;
}
}
✡ ✠
SECTION 13.4 •Using Threads to Improve Interface Responsiveness 673
This version of Dotty will perform the same task as before except that
it will now run as a separate thread of execution. Note that it srun()
method just calls the draw() method that we deﬁned in the previous ver-
sion. When the Dotty thread is started by the RandomDotGUI , we will
have a multithreaded program.
However, just because this program has two threads doesn’t nec essarily
mean that it will be any more responsive to the user. There’s n o guarantee
that the drawing thread will stop as soon as the Clear button i s clicked. On
most systems, if both threads have equal priority, the GUI th read won’t Thread control
run until the drawing thread ﬁnishes drawing all Ndots.
JAVA DEBUGGING TIP Thread Control. Just breaking a program
into two separate threads won’t necessarily give you the des ired
performance. It might be necessary to coordinate the threads.
Therefore, we have to modify our design in order to guarantee that the
GUI thread will get a chance to handle the user’s actions. One good way
to do this is to have Dotty sleep for a short instance after it draws each
dot. When a thread sleeps, any other threads that are waiting t heir turn Usingsleep() to interrupt the
drawing will get a chance to run. If the GUI thread is waiting to handle t he user’s
click on Clear, it will now be able to call Dotty ’sclear() method.
The new version of draw() is shown in Figure 14.15. In this version of
draw() , the thread sleeps for 1 millisecond on each iteration of the loop.
This will make it possible for the GUI to run on every iteratio n, so it will
handle user actions immediately.
Another necessary change is that once the clear() method is called,
theDotty thread should stop running (drawing). The correct way to sto p
a thread is to use some variable whose value will cause the run loop (or
in this case the drawing loop) to exit, so the new version of Dotty uses
theboolean variable isCleared to control when drawing is stopped.
Note that the variable is initialized to false and then set to true in the
clear() method. The for loop in draw() will exit when isCleared
becomes true . This causes the draw() method to return, which causes
therun() method to return, which causes the thread to stop in an orderl y
fashion.
JAVA EFFECTIVE DESIGN Threaded GUIs. Designing a
multithreaded GUI involves creating a secondary thread tha t will run
concurrently with the main GUI thread. The GUI thread handle s the
user interface, while the secondary thread performs CPU-in tensive
calculations.
JAVA PROGRAMMING TIP Threading an GUI. Creating a second
thread within a GUI requires three steps: (1) Deﬁne the secon dary
thread to implement the Runnable interface, (2) override its run()
method, and (3) incorporate some mechanism, such as a sleep()
state, into the thread’s run algorithm so that the GUI thread will have
a chance to run periodically.
674 CHAPTER 14 •Threads and Concurrent Programming
☛ ✟
import java . awt . ∗;
import javax . swing . ∗; // I m p o r t S w i n g c l a s s e s
public c l a s s Dotty implements Runnable {
// C o o r d i n a t e s
private s t a t i c f i n a l i n t HREF = 20 , VREF = 20 , LEN = 2 0 0 ;
private JPanel canvas ;
private i n t nDots ; // N u m b e r o f d o t s t o d r a w
private i n t nDrawn ; // N u m b e r o f d o t s d r a w n
private i n t f i r s t R e d = 0 ; // N u m b e r o f t h e f i r s t r e d d o t
private boolean isCleared = f a l s e ;// P a n e l i s c l e a r e d
public void run ( ){
draw ( ) ;
}
public Dotty ( JPanel canv , i n t dots ){
canvas = canv ;
nDots = dots ;
}
public void draw ( ) {
Graphics g = canvas . getGraphics ( ) ;
for (nDrawn = 0 ; ! isCleared && nDrawn <nDots ; nDrawn++) {
i n t x = HREF + ( i n t) ( Math . random ( ) ∗LEN ) ;
i n t y = VREF + ( i n t) ( Math . random ( ) ∗LEN ) ;
g . f i l l O v a l ( x , y , 3 , 3 ) ; // Draw a d o t
i f( Math . random ( ) <0 . 0 0 1 && f i r s t R e d == 0) {
g . setColor ( Color . red ) ; // C h a n g e c o l o r t o r e d
f i r s t R e d = nDrawn ;
}
t r y{
Thread . sleep ( 1 ) ; // S l e e p f o r a n i n s t a n t
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
}// f o r
}// d r a w ( )
public void c l e a r ( ) {
isCleared = true ;
Graphics g = canvas . getGraphics ( ) ;
g . setColor ( canvas . getBackground ( ) ) ;
g . f i l l R e c t (HREF, VREF,LEN+3 ,LEN+ 3 ) ;
System . out . p r i n t l n ( ”Number of dots drawn s i n c e f i r s t red = ”
+ (nDrawn −f i r s t R e d ) ) ;
}// c l e a r ( )
}// D o t t y
✡ ✠
Figure 14.15: By implementing the Runnable interface, this version of
Dotty can run as a separate thread.
SECTION 13.4 •Using Threads to Improve Interface Responsiveness 675
Modiﬁcations to RandomDotGUI
We don’t need to make many changes in RandomDotGUI to get it to
work with the new version of Dotty . The primary change comes in the
actionPerformed() method. Each time the Draw button was clicked
in the original version of this method, we created a dotty instance and
then called its draw() method. In the revised version we must create a
newThread and pass it an instance of Dotty , which will then run as a Starting the drawing thread
separate thread:
☛ ✟
public void actionPerformed ( ActionEvent e ) {
i f( e . getSource ( ) == draw ) {
dotty = new Dotty ( canvas , NDOTS) ;
dottyThread = new Thread ( dotty ) ;
dottyThread . s t a r t ( ) ;
}else{
dotty . c l e a r ( ) ;
}
}// a c t i o n P e r f o r m e d ( )
✡ ✠
Note that in addition to a reference to dotty we also have a reference to a
Thread named dottyThread . This additional variable must be declared
within the GUI.
Remember that when you call the start() method, it automatically
calls the thread’s run() method. When dottyThread starts to run, it
will immediately call the draw() method and start drawing dots. After
each dot is drawn, dottyThread will sleep for an instant.
Notice how the GUI stops the drawing thread. In the new version ,
Dotty.clear() will set the isCleared variable, which will cause the
drawing loop to terminate. Once again, this is the proper way to stop a
thread. Thus, as soon as the user clicks the Clear button, the Dotty thread
will stop drawing and report its result.
JAVA DEBUGGING TIP Stopping a Thread. The best way to stop a
thread is to use a boolean control variable whose value can be set to
true or false to exit the run() loop.
14.5.3 Advantages of Multithreaded Design
By creating a separate thread for Dotty , we have turned a single-threaded
program into a multithreaded program. One thread, the GUI, ha ndles the
user interface. The second thread handles the drawing task. By forcing
the drawing to sleep on each iteration, we guarantee that the GUI thread
will remain responsive to the user’s actions. Figure 14.16 i llustrates the
difference between the single- and multithreaded designs. Note that the Divide and conquer!
GUI thread starts and stops the drawing thread, and the GUI th read exe-
cutesdotty.clear() . The drawing thread simply executes its draw()
method. In the single-threaded version, all of these actions are done by
one thread.
676 CHAPTER 14 •Threads and Concurrent Programming
Figure 14.16: Two independent
threads: one for drawing, the
other for the GUI.Draw button Clear button
Applet thread
Dotty thread
draw() clear()init() actionPerformed()
The trade-off involved in this design is that it will take lon ger to draw
Nrandom dots, since dottyThread.draw() will sleep for an instant on Trade-off: speed vs. responsiveness
each iteration. However, the extra time is hardly noticeable . By breaking
the program into two separate threads of control, one to hand le the draw-
ing task and one to handle the user interface, the result is a m uch more
responsive program.
JAVA EFFECTIVE DESIGN Responsive Interfaces. In order to give a
program a more responsive user interface, divide it into sep arate
threads of control. Let one thread handle interactive tasks , such as user
input, and let the second thread handle CPU-intensive compu tations.
SELF-STUDY EXERCISES
EXERCISE 14.7 Someone might argue that because the Java Virtual Ma-
chine uses a round-robin scheduling algorithm, it’s redund ant to use the
sleep() method, since the GUI thread will get its chance to run. What’s
wrong with this argument for interface responsiveness?
EXERCISE 14.8 Instead of sleeping on each iteration, another way to
make the interface more responsive would be to set the thread edDotty ’s
priority to a low number, such as 1. Make this change, and expe riment
with its effect on the program’s responsiveness. Is it more or less respon-
sive than sleeping on each iteration? Why?
14.6 CASE STUDY: Cooperating Threads
For some applications it is necessary to synchronize and coo rdinate the
behavior of threads to enable them to carry out a cooperative task. Many
cooperative applications are based on the producer/consumer model . Ac-
cording to this model, two threads cooperate at producing an d consuming
a particular resource or piece of data. The producer thread c reates some
message or result, and the consumer thread reads or uses the r esult. The
consumer has to wait for a result to be produced, and the produ cer has to
take care not to overwrite a result that hasn’t yet been consu med. Many
types of coordination problems ﬁt the producer/consumer mo del.
One example of an application for this model would be to contr ol the
display of data that is read by your browser. As information a rrives from
the Internet, it is written to a buffer by the producer thread. A sepa- Producer and consumer threads
rate consumer thread reads information from the buffer and d isplays it
SECTION 14.6 •CASE STUDY: Cooperating Threads 677
in your browser window. Obviously, the two threads must be ca refully
synchronized.
14.6.1 Problem Statement
To illustrate how to address the sorts of problems that can ar ise when you
try to synchronize threads, let’s consider a simple applica tion in which
several threads use a shared resource. You’re familiar with those take- Simulating a waiting line
a-number devices that are used in bakeries to manage a waitin g line.
Customers take a number when they arrive, and the clerk annou nces
who’s next by looking at the device. As customers are called, the clerk
increments the “next customer” counter by one.
There are some obvious potential coordination problems her e. The de-
vice must keep proper count and can’t skip customers. Nor can it give
the same number to two different customers. Nor can it allow t he clerk to
serve nonexistent customers.
Our task is to build a multithreaded simulation that uses a mo del of a
take-a-number device to coordinate the behavior of custome rs and a (sin-
gle) clerk in a bakery waiting line. To help illustrate the va rious issues
involved in trying to coordinate threads, we will develop mo re than one
version of the program.
Problem Decomposition
This simulation will use four classes of objects. Figure 14.1 7 pro- What classes do we need?
vides a UML representation of the interactions among the obje cts. The
: Bakeryjoe : Customer
mary : Customer
pete : Customer: TakeANumber
alicia : Clerk
create()
create()
create()
create()
create()
nextNumber()
nextNumber()
nextNumber()
nextCustomer()Each customer gets
a different number.
The clerk serves the
next customer in line.Figure 14.17: The Bakery creates
theCustomer andClerk threads
and the TakeANumber gadget.
ThenCustomer s request and re-
ceive waiting numbers and the
Clerk requests and receives the
number of the next customer to
serve.
TakeANumber object will serve as a model of a take-a-number device.
This is the resource that will be shared by the threads, but it is not a
thread itself. The Customer class, a subclass of Thread , will model the
behavior of a customer who arrives on line and takes a number f rom the
678 CHAPTER 14 •Threads and Concurrent Programming
TakeANumber device. There will be several Customer threads created
that then compete for a space in line. The Clerk thread, which simulates
the behavior of the store clerk, should use the TakeANumber device to
determine who the next customer is and should serve that cust omer. Fi-
nally, there will be a main program that will have the task of c reating and
starting the various threads. Let’s call this the Bakery class, which gives
us the following list of classes:
•Bakery —creates the threads and starts the simulation.
•TakeANumber —represents the gadget that keeps track of the next cus-
tomer to be served.
•Clerk —uses the TakeANumber to determine the next customer and
will serve the customer.
•Customer —represents the customers who will use the TakeANumber
to take their place in line.
14.6.2 Design: The TakeANumber Class
TheTakeANumber class must track two things: Which customer will
be served next, and which waiting number the next customer wi ll be
given. This suggests that it should have at least two public m ethods:
nextNumber() , which will be used by customers to get their waiting
numbers, and nextCustomer() , which will be used by the clerk to de-
termine who should be served (Fig. 14.18). Each of these meth ods will
simply retrieve the values of the instance variables, next andserving ,+nextNumber() : int
+nextCustomer() : int-next : int
-serving : intTakeANumber
FIGURE 14.18 TheTakeANumber
object keeps track of numbers and
customers.which keep track of these two values. As part of the object’s st ate, these
variables should be private .
How should we make this TakeANumber object accessible to all of
the other objects—that is, to all of the customers and to the cle rk? The
easiest way to do that is to have the main program pass a refere nce to
theTakeANumber when it constructs the Customer s and the Clerk .
They can each store the reference as an instance variable. In t his way,
all the objects in the simulation can share a TakeANumber object as a
common resource. Our design considerations lead to the deﬁn ition of the Passing a reference to a shared object
TakeANumber class shown in Figure 14.19.
Note that the nextNumber() method is declared synchronized . As
we will discuss in more detail, this ensures that only one cus tomer at a
time can take a number. Once a thread begins executing a synchronized
method, no other thread can execute that method until the ﬁrs t thread
ﬁnishes. This is important because, otherwise, several Customer s could Synchronized methods
call the nextNumber method at the same time. It’s important that the
customer threads have access only one at a time, also called mutually ex-
clusive access to theTakeANumber object. This form of mutual exclusion
is important for the correctness of the simulation.
SELF-STUDY EXERCISE
EXERCISE 14.9 What is the analogue to mutual exclusion in the real-
world bakery situation?
SECTION 14.6 •CASE STUDY: Cooperating Threads 679
☛ ✟
c l a s s TakeANumber {
private i n t next = 0 ; // N e x t p l a c e i n l i n e
private i n t serving = 0 ; // N e x t c u s t o m e r t o s e r v e
public synchronized i n t nextNumber ( ) {
next = next + 1 ;
return next ;
}// n e x t N u m b e r ( )
public i n t nextCustomer ( ) {
++serving ;
return serving ;
}// n e x t C u s t o m e r ( )
}// T a k e A N u m b e r
✡ ✠
Figure 14.19: Deﬁnition of the TakeANumber class, Version 1.
14.6.3 Java Monitors and Mutual Exclusion
An object that contains synchronized methods has a monitor associated
with it. A monitor is a widely used synchronization mechanis m that en- The monitor concept
sures that only one thread at a time can execute a synchronized method.
When a synchronized method is called, a lock is acquired on that object.
For example, if one of the Customer threads calls nextNumber() , a lock
will be placed on that TakeANumber object. While an object is locked , no
othersynchronized method can run in that object. Other threads must
wait for the lock to be released before they can execute a synchronized
method.
While one Customer is executing nextNumber() , all other Customer sMutually exclusive access to a shared
object will be forced to wait until the ﬁrst Customer is ﬁnished. When the
synchronized method is exited, the lock on the object is released, al-
lowing other Customer threads to access their synchronized meth-
ods. In effect, a synchronized method can be used to guarantee mu-
tually exclusive access to the TakeANumber object among the competing
customers.
JAVA LANGUAGE RULE synchronized .Once a thread begins
to execute a synchronized method in an object, the object is locked so
that no other thread can gain access to that object’s synchron ized
methods.
JAVA EFFECTIVE DESIGN Synchronization. In order to restrict
access of a method or set of methods to one object at a time (mutu al
exclusion), declare the methods synchronized .
One cautionary note here is that although a synchronized met hod blocks
access to other synchronized methods, it does not block acce ss to nonsyn-
chronized methods. This could cause problems. We will retur n to this
680 CHAPTER 14 •Threads and Concurrent Programming
issue in the next part of our case study when we discuss the tes ting of our
program.
14.6.4 The Customer Class
ACustomer thread should model the behavior of taking a number from
theTakeANumber gadget. For the sake of this simulation, let’s suppose
that after taking a number, the Customer object just prints it out. This will
serve as a simple model of “waiting on line.” What about the Customer ’s
state? To help distinguish one customer from another, let’s give each cus- +Customer(in gadget : TakeANumber)
+run()-number : int =10000
-id : int
-takeANumber : TakeANumberCustomer+run()Thread
FIGURE 14.20 TheCustomer
thread.tomer a unique ID number starting at 10001, which will be set in the con-
structor method. Also, as we noted earlier, each Customer needs a ref-
erence to the TakeANumber object, which is passed as a constructor pa-
rameter (Fig. 14.20). This leads to the deﬁnition of Customer shown in
Figure 14.21. Note that before taking a number the customer s leeps for a
random interval of up to 1,000 milliseconds. This will intro duce a bit of
randomness into the simulation.
☛ ✟
public c l a s s Customer extends Thread {
private s t a t i c i n t number = 10000; // I n i t i a l I D n u m b e r
private i n t id ;
private TakeANumber takeANumber ;
public Customer ( TakeANumber gadget ) {
id = ++number ;
takeANumber = gadget ;
}
public void run ( ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗1000 ) ) ;
System . out . p r i n t l n ( ”Customer ” + id +
” takes t i c k e t ” + takeANumber . nextNumber ( ) ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception ” + e . getMessage ( ) ) ;
}
}// r u n ( )
}// C u s t o m e r
✡ ✠
Figure 14.21: Deﬁnition of the Customer class, Version 1.
Another important feature of this deﬁnition is the use of the static
variable number to assign each customer a unique ID number. Remem-
ber that a static variable belongs to the class itself, not to its instances. Static (class) variables
Therefore, each Customer that is created can share this variable. By
SECTION 14.6 •CASE STUDY: Cooperating Threads 681
incrementing it and assigning its new value as the Customer ’s ID, we
guarantee that each customer has a unique ID number.
JAVA LANGUAGE RULE Static (Class) Variables. Static variables
are associated with the class itself and not with its instanc es.
JAVA EFFECTIVE DESIGN Unique IDs. Static variables are often
used to assign a unique ID number or a unique initial value to ea ch
instance of a class.
14.6.5 The Clerk Class
TheClerk thread should simulate the behavior of serving the
next customer in line, so the Clerk thread will repeatedly access
TakeANumber.nextCustomer() and then serve that customer. For
the sake of this simulation, we’ll just print a message to indi cate which
customer is being served. Because there’s only one clerk in t his simu-
lation, the only variable in its internal state will be a refe rence to the
TakeANumber object (Fig. 14.22). In addition to the constructor, all we
really need to deﬁne for this class is the run() method. This leads to+Clerk(in gadget : TakeANumber)
+run()Clerk
-takeANumber : TakeANumber+run()Thread
FIGURE 14.22 TheClerk thread.the deﬁnition of Clerk shown in Figure 14.23. In this case, the sleep()
method is necessary to allow the Customer threads to run. The Clerk
will sit in an inﬁnite loop serving the next customer on each i teration.
☛ ✟
public c l a s s Clerk extends Thread {
private TakeANumber takeANumber ;
public Clerk ( TakeANumber gadget ) {
takeANumber = gadget ;
}
public void run ( ){
while (true ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗5 0 ) ) ;
System . out . p r i n t l n ( ” Clerk serving t i c k e t ” +
takeANumber . nextCustomer ( ) ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception ” + e . getMessage ( ) ) ;
}
}// w h i l e
}// r u n ( )
}// C l e r k
✡ ✠
Figure 14.23: Deﬁnition of Clerk , Version 1.
682 CHAPTER 14 •Threads and Concurrent Programming
14.6.6 The Bakery Class
Finally, Bakery is the simplest class to design. It contains the main()
method, which gets the whole simulation started. As we said, its role will
be to create one Clerk thread and several Customer threads, and get The main program
them all started (Fig. 14.24). Notice that the Customer s and the Clerk
are each passed a reference to the shared TakeANumber gadget.
☛ ✟
public c l a s s Bakery {
public s t a t i c void main ( S t r i n g args [ ] ) {
System . out . p r i n t l n ( ” S t a r t i n g c l e r k and customer threads ” ) ;
TakeANumber numberGadget = new TakeANumber ( ) ;
Clerk c l e r k = new Clerk ( numberGadget ) ;
c l e r k . s t a r t ( ) ;
for (i n t k = 0 ; k <5 ; k++) {
Customer customer = new Customer ( numberGadget ) ;
customer . s t a r t ( ) ;
}
}// m a i n ( )
}// B a k e r y
✡ ✠
Figure 14.24: Deﬁnition of the Bakery class.
Problem: Nonexistent Customers
Now that we have designed and implemented the classes, let’s run sev-
eral experiments to test that everything works as intended. Except for
thesynchronized nextNumber() method, we’ve made little attempt
to make sure that the Customer andClerk threads will work together
cooperatively, without violating the real-world constrai nts that should be
satisﬁed by the simulation. If we run the simulation as it is pr esently
coded, it will generate ﬁve customers and the clerk will serv e all of them.
But we get something like the following output: Testing and debugging
☛ ✟
S t a r t i n g c l e r k and customer threads
Clerk serving t i c k e t 1
Clerk serving t i c k e t 2
Clerk serving t i c k e t 3
Clerk serving t i c k e t 4
Clerk serving t i c k e t 5
Customer 10004 takes t i c k e t 1
Customer 10002 takes t i c k e t 2
Clerk serving t i c k e t 6
Customer 10005 takes t i c k e t 3
Clerk serving t i c k e t 7
Clerk serving t i c k e t 8
Clerk serving t i c k e t 9
Clerk serving t i c k e t 10
Customer 10001 takes t i c k e t 4
Customer 10003 takes t i c k e t 5
✡ ✠
SECTION 14.6 •CASE STUDY: Cooperating Threads 683
Our current solution violates an important real-world cons traint: You
can’t serve customers before they enter the line! How can we en sure Problem: The clerk thread doesn’t
wait for customer threads that the clerk doesn’t serve a customer unless there’s actua lly a customer
waiting?
The wrong way to address this issue would be to increase the am ount
of sleeping that the Clerk does between serving customers. Indeed, this
would allow more customer threads to run, so it might appear t o have
the desired effect, but it doesn’t truly address the main pro blem: A clerk
cannot serve a customer if no customer is waiting.
The correct way to solve this problem is to have the clerk chec k that
there are customers waiting before taking the next customer . One way
to model this would be to add a customerWaiting() method to our
TakeANumber object. This method would return true whenever next
is greater than serving . That will correspond to the real-world situation
in which the clerk can see customers waiting in line. We can ma ke the The clerk checks the line
following modiﬁcation to Clerk.run() :
☛ ✟
public void run ( ){
while (true ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗5 0 ) ) ;
i f( takeANumber . customerWaiting ( ) )
System . out . p r i n t l n ( ” Clerk serving t i c k e t ”
+ takeANumber . nextCustomer ( ) ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception ” + e . getMessage ( ) ) ;
}
}// w h i l e
}// r u n ( )
✡ ✠
And we add the following method to TakeANumber (Fig. 14.25):
☛ ✟
public boolean customerWaiting ( ) {
return next>serving ;
}
✡ ✠+nextNumber() : int
+nextCustomer() : int
+customerWaiting() : boolean-next : int
-serving : intTakeANumber
FIGURE 14.25 The revised
TakeANumber class.In other words, the Clerk won’t serve a customer unless there are cus-
tomers waiting—that is, unless next is greater than serving . Given
684 CHAPTER 14 •Threads and Concurrent Programming
these changes, we get the following type of output when we run the
simulation:
☛ ✟
S t a r t i n g c l e r k and customer threads
Customer 10003 takes t i c k e t 1
Clerk serving t i c k e t 1
Customer 10005 takes t i c k e t 2
Clerk serving t i c k e t 2
Customer 10001 takes t i c k e t 3
Clerk serving t i c k e t 3
Customer 10004 takes t i c k e t 4
Clerk serving t i c k e t 4
Customer 10002 takes t i c k e t 5
Clerk serving t i c k e t 5
✡ ✠
This example illustrates that when application design invo lves cooperat-
ing threads, the algorithm used must ensure the proper coope ration and
coordination among the threads.
JAVA EFFECTIVE DESIGN Thread Coordination. When two or
more threads must behave cooperatively, their interaction must be
carefully coordinated by the algorithm.
14.6.7 Problem: Critical Sections
It is easy to forget that thread behavior is asynchronous. You can’t pre-
dict when a thread might be interrupted or might have to give u p the Thread interruptions are
unpredictable CPU to another thread. In designing applications that involv e cooperat-
ing threads, it’s important that the design incorporates fe atures to guard
against problems caused by asynchronicity. To illustrate t his problem,
consider the following statement from the Customer.run() method:
☛ ✟
System . out . p r i n t l n ( ”Customer ” + id +
” takes t i c k e t ” + takeANumber . nextNumber ( ) ) ;
✡ ✠
Even though this is a single Java statement, it breaks up into several Java
bytecode statements. A Customer thread could certainly be interrupted
between getting the next number back from TakeANumber and printing it
SECTION 14.6 •CASE STUDY: Cooperating Threads 685
out. We can simulate this by breaking the println() into two statements
and putting a sleep() in their midst:
☛ ✟
public void run ( ){
t r y{
i n t myturn = takeANumber . nextNumber ( ) ;
sleep ( ( i n t) ( Math . random ( ) ∗1000 ) ) ;
System . out . p r i n t l n ( ”Customer ” + id +
” takes t i c k e t ” + myturn ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception ” + e . getMessage ( ) ) ;
}
}// r u n ( )
✡ ✠
If this change is made in the simulation, you might get the foll owing
output:
☛ ✟
S t a r t i n g c l e r k and customer threads
Clerk serving t i c k e t 1
Clerk serving t i c k e t 2
Clerk serving t i c k e t 3
Customer 10004 takes t i c k e t 4
Clerk serving t i c k e t 4
Clerk serving t i c k e t 5
Customer 10001 takes t i c k e t 1
Customer 10002 takes t i c k e t 2
Customer 10003 takes t i c k e t 3
Customer 10005 takes t i c k e t 5
✡ ✠
Because the Customer threads are now interrupted in between taking a
number and reporting their number, it looks as if they are bei ng served in
the wrong order. Actually, they are being served in the corre ct order. It’s
their reporting of their numbers that is wrong!
The problem here is that the Customer.run() method is being in-
terrupted in such a way that it invalidates the simulation’s output. A Problem: An interrupt in a critical
section method that displays the simulation’s state should be desig ned so that
once a thread begins reporting its state, that thread will be allowed to ﬁn-
ish reporting before another thread can start reporting its state. Accurate
reporting of a thread’s state is a critical element of the sim ulation’s overall
integrity.
Acritical section is any section of a thread that should not be inter-
rupted during its execution. In the bakery simulation, all of the statements
that report the simulation’s progress are critical section s. Even though
the chances are small that a thread will be interrupted in the midst of
aprintln() statement, the faithful reporting of the simulation’s stat e
should not be left to chance. Therefore, we must design an alg orithm that
prevents the interruption of critical sections.
Creating a Critical Section
The correct way to address this problem is to treat the report ing of the cus-
tomer’s state as a critical section. As we saw earlier when we discussed
686 CHAPTER 14 •Threads and Concurrent Programming
the concept of a monitor, a synchronized method within a shared ob-
ject ensures that once a thread starts the method, it will be al lowed to
ﬁnish it before any other thread can start it. Therefore, one way out of Making a critical section
uninterruptible this dilemma is to redesign the nextNumber() andnextCustomer()
methods in the TakeANumber class so that they report which customer
receives a ticket and which customer is being served (Fig. 14 .26). In this
version all of the methods are synchronized , so all the actions of the
TakeANumber object are treated as critical sections.
☛ ✟
public c l a s s TakeANumber {
private i n t next = 0 ; // N e x t p l a c e i n l i n e
private i n t serving = 0 ; // N e x t c u s t o m e r t o s e r v e
public synchronized i n t nextNumber ( i n t custId ) {
next = next + 1 ;
System . out . p r i n t l n ( ”Customer ” + custId + ”
takes t i c k e t ” + next ) ;
return next ;
}// n e x t N u m b e r ( )
public synchronized i n t nextCustomer ( ) {
++serving ;
System . out . p r i n t l n ( ” Clerk serving t i c k e t ”
+ serving ) ;
return serving ;
}// n e x t C u s t o m e r ( )
public synchronized boolean customerWaiting ( ) {
return next>serving ;
}// c u s t o m e r W a i t i n g ( )
}// T a k e A N u m b e r
✡ ✠
Figure 14.26: Deﬁnition of the TakeANumber class, Version 2.
Note that the reporting of both the next number and the next cu stomer
to be served are now handled by TakeANumber in Figure 14.26 . Because
the methods that handle these actions are synchronized , they cannot be
interrupted by any threads involved in the simulation. This guarantees
that the simulation’s output will faithfully report the sim ulation’s state.
SECTION 14.6 •CASE STUDY: Cooperating Threads 687
Given these changes to TakeANumber , we must remove the println()
statements from the run() methods in Customer :
☛ ✟
public void run ( ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗2 0 0 0 ) ) ;
takeANumber . nextNumber ( id ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception : ” + e . getMessage ( ) ) ;
}
}// r u n ( )
✡ ✠
and from the run() method in Clerk :
☛ ✟
public void run ( ){
while (true ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗1 0 0 0 ) ) ;
i f( takeANumber . customerWaiting ( ) )
takeANumber . nextCustomer ( ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception : ” +e . getMessage ( ) ) ;
}
}// w h i l e
}// r u n ( )
✡ ✠
Rather than printing their numbers, these methods now just ca ll the ap-
propriate methods in TakeANumber . Given these design changes, our
simulation now produces the following correct output:
☛ ✟
S t a r t i n g c l e r k and customer threads
Customer 10001 takes t i c k e t 1
Clerk serving t i c k e t 1
Customer 10003 takes t i c k e t 2
Customer 10002 takes t i c k e t 3
Clerk serving t i c k e t 2
Customer 10005 takes t i c k e t 4
Customer 10004 takes t i c k e t 5
Clerk serving t i c k e t 3
Clerk serving t i c k e t 4
Clerk serving t i c k e t 5
✡ ✠
The lesson to be learned from this is that in designing multit hreaded pro-
grams, it is important to assume that if a thread can be interr upted at a
certain point, it will be interrupted at that point. The fact that an interrupt Preventing undesirable interrupts
688 CHAPTER 14 •Threads and Concurrent Programming
is unlikely to occur is no substitute for the use of a critical section. This is
something like “Murphy’s Law of Thread Coordination.”
JAVA EFFECTIVE DESIGN The Thread Coordination Principle. Use
critical sections to coordinate the behavior of cooperatin g threads. By
designating certain methods as synchronized, you can ensur e their
mutually exclusive access. Once a thread starts a synchroni zed
method, no other thread will be able to execute the method unt il the
ﬁrst thread is ﬁnished.
In a multithreaded application, the classes and methods shou ld be de-
signed so that undesirable interrupts will not affect the co rrectness of the
algorithm.
JAVA PROGRAMMING TIP Critical Sections. Java’s monitor
mechanism will ensure that while one thread is executing a
synchronized method, no other thread can gain access to it. E ven if the
ﬁrst thread is interrupted, when it resumes execution again it will be
allowed to ﬁnish the synchronized method before other threa ds can
access synchronized methods in that object.
SELF-STUDY EXERCISE
EXERCISE 14.10 Given the changes we’ve described, the bakery sim-
ulation should now run correctly regardless of how slow or fa st the
Customer andClerk threads run. Verify this by placing different-sized
sleep intervals in their run() methods. ( Note : You don’t want to put a
sleep() in the synchronized methods because that would undermine
the whole purpose of making them synchronized in the ﬁrst place.)
14.6.8 Using wait/notify to Coordinate Threads
The examples in the previous sections were designed to illus trate the is-
sue of thread asynchronicity and the principles of mutual ex clusion and
critical sections. Through the careful design of the algori thm and the ap-
propriate use of the synchronized qualiﬁer, we have managed to design
a program that correctly coordinates the behavior of the Customer s and
Clerk in this bakery simulation.
The Busy-Waiting Problem
One problem with our current design of the Bakery algorithm i s that it
uses busy waiting on the part of the Clerk thread. Busy waiting occurs Busy waiting
when a thread, while waiting for some condition to change, ex ecutes a
loop instead of giving up the CPU. Because busy waiting is was teful of
CPU time, we should modify the algorithm.
SECTION 14.6 •CASE STUDY: Cooperating Threads 689
As it is presently designed, the Clerk thread sits in a loop that repeat-
edly checks whether there’s a customer to serve:
☛ ✟
public void run ( ){
while (true ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗1 0 0 0 ) ) ;
i f( takeANumber . customerWaiting ( ) )
takeANumber . nextCustomer ( ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception : ” + e . getMessage ( ) ) ;
}
}// w h i l e
}// r u n ( )
✡ ✠
A far better solution would be to force the Clerk thread to wait un-
til a customer arrives without using the CPU. Under such a des ign, the
Clerk thread can be notiﬁed and enabled to run as soon as a Customer
becomes available. Note that this description views the cus tomer/clerk
relationship as one-half of the producer/consumer relatio nship. When a Producer/consumer
customer takes a number, it produces a customer in line that must be served
(that is, consumed ) by the clerk.
This is only half the producer/consumer relationship becau se we
haven’t placed any constraint on the size of the waiting line . There’s no
real limit to how many customers can be produced. If we did limi t the
line size, customers might be forced to wait before taking a n umber if, say,
the tickets ran out, or the bakery ﬁlled up. In that case, custo mers would
have to wait until the line resource became available and we w ould have
a full-ﬂedged producer/consumer relationship.
Thewait/notify Mechanism
So, let’s use Java’s wait/notify mechanism to eliminate busy waiting
from our simulation. As noted in Figure 14.6, the wait() method puts
a thread into a waiting state, and notify() takes a thread out of wait-
ing and places it back in the ready queue. To use these methods in this
program we need to modify the nextNumber() andnextCustomer()
690 CHAPTER 14 •Threads and Concurrent Programming
methods. If there is no customer in line when the Clerk calls the
nextCustomer() method, the Clerk should be made to wait() :
☛ ✟
public synchronized i n t nextCustomer ( ) {
t r y{
while ( next<= serving )
wait ( ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception : ” + e . getMessage ( ) ) ;
}f i n a l l y {
++serving ;
System . out . p r i n t l n ( ” Clerk serving t i c k e t ” + serving ) ;
return serving ;
}
}
✡ ✠
Note that the Clerk still checks whether there are customers waiting. If
there are none, the Clerk calls the wait() method. This removes the
Clerk from the CPU until some other thread notiﬁes it, at which poin t A waiting thread gives up the CPU
it will be ready to run again. When it runs again, it should chec k that
there is in fact a customer waiting before proceeding. That’ s why we use a
while loop here. In effect, the Clerk will wait until there’s a customer to
serve. This is not busy waiting because the Clerk thread loses the CPU
and must be notiﬁed each time a customer becomes available.
When and how will the Clerk be notiﬁed? Clearly, the Clerk should
be notiﬁed as soon as a customer takes a number. Therefore, we put a
notify() in thenextNumber() method, which is the method called by
eachCustomer as it gets in line:
☛ ✟
public synchronized i n t nextNumber ( i n t custId ) {
next = next + 1 ;
System . out . p r i n t l n ( ”Customer ” + custId +
” takes t i c k e t ” + next ) ;
n o t i f y ( ) ;
return next ;
}
✡ ✠
Thus, as soon as a Customer thread executes the nextNumber()
method, the Clerk will be notiﬁed and allowed to proceed.
What happens if more than one Customer has executed a wait() ? In
that case, the JVM will maintain a queue of waiting Customer threads.
Then, each time a notify() is executed, the JVM will take the ﬁrst
Customer out of the queue and allow it to proceed.
If we use this model of thread coordination, we no longer need t o test
customerWaiting() in theClerk.run() method. It is to be tested in
SECTION 14.6 •CASE STUDY: Cooperating Threads 691
theTakeANumber.nextCustomer() . Thus, the Clerk.run() can be
simpliﬁed to
☛ ✟
public void run ( ){
while (true ){
t r y{
sleep ( ( i n t) ( Math . random ( ) ∗1 0 0 0 ) ) ;
takeANumber . nextCustomer ( ) ;
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception : ” + e . getMessage ( ) ) ;
}
}// w h i l e
}// r u n ( )
✡ ✠
TheClerk thread may be forced to wait when it calls the nextCustomer
method.
Because we no longer need the customerWaiting() method, we
end up with the new deﬁnition of TakeANumber shown in Figures 14.27
+nextNumber() : int<<synchronized>>
+nextCustomer() : int<<synchronized>>-next : int
-serving : intTakeANumber
FIGURE 14.27 In the ﬁnal design of
TakeANumber , its methods are
synchronized.and 14.28.
☛ ✟
public c l a s s TakeANumber {
private i n t next = 0 ;
private i n t serving = 0 ;
public synchronized i n t nextNumber ( i n t custId ) {
next = next + 1 ;
System . out . p r i n t l n ( ”Customer ” + custId +
” takes t i c k e t ” + next ) ;
n o t i f y ( ) ;
return next ;
}// n e x t N u m b e r ( )
public synchronized i n t nextCustomer ( ) {
t r y{
while ( next<= serving ) {
System . out . p r i n t l n ( ” Clerk waiting ” ) ;
wait ( ) ;
}
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( ” Exception ” + e . getMessage ( ) ) ;
}f i n a l l y {
++serving ;
System . out . p r i n t l n ( ” Clerk serving t i c k e t ”
+ serving ) ;
return serving ;
}
}// n e x t C u s t o m e r ( )
}// T a k e A N u m b e r
✡ ✠
Figure 14.28: The TakeANumber class, Version 3.
692 CHAPTER 14 •Threads and Concurrent Programming
Given this version of the program, the following kind of outp ut will be
generated:
☛ ✟
S t a r t i n g c l e r k and customer threads
Customer 10004 takes t i c k e t 1
Customer 10002 takes t i c k e t 2
Clerk serving t i c k e t 1
Clerk serving t i c k e t 2
Customer 10005 takes t i c k e t 3
Customer 10003 takes t i c k e t 4
Clerk serving t i c k e t 3
Customer 10001 takes t i c k e t 5
Clerk serving t i c k e t 4
Clerk serving t i c k e t 5
Clerk waiting
✡ ✠
JAVA PROGRAMMING TIP Busy Waiting. Java’swait/notify
mechanism can be used effectively to eliminate busy waiting from a
multithreaded application.
JAVA EFFECTIVE DESIGN Producer/Consumer. The
producer/consumer model is a useful design for coordinatin g the
wait/notify interaction.
SELF-STUDY EXERCISE
EXERCISE 14.11 An interesting experiment to try is to make the Clerk
a little slower by making it sleep for up to 2,000 millisecond s. Take a
guess at what would happen if you ran this experiment. Then ru n the
experiment and observe the results.
Thewait/notify Mechanism
There are a number of important restrictions that must be obs erved when Wait/notify go into synchronized
methods using the wait/notify mechanism:
•Bothwait() andnotify() are methods of the Object class, not the
Thread class. This enables them to lock objects, which is the essenti al
feature of Java’s monitor mechanism.
•Await() method can be used within a synchronized method. The
method doesn’t have to be part of a Thread .
•You can only use wait() andnotify() within synchronized
methods. If you use them in other methods, you will cause
anIllegalMonitorStateException with the message “current
thread not owner.”
•When a wait() —or a sleep() —is used within a synchronized
method, the lock on that object is released so that other metho ds can
access the object’s synchronized methods.
SECTION 14.7 •CASE STUDY: The Game of Pong 693
JAVA DEBUGGING TIP Wait/Notify. It’s easy to forget that the
wait() andnotify() methods can only be used within
synchronized methods.
14.7 CASE STUDY: The Game of Pong
The game of Pong was one of the ﬁrst computer video games and wa s all
the rage in the 1970s. The game consists of a ball that moves ho rizontally
and vertically within a rectangular region, and a single pad dle, which is
located at the right edge of the region that can be moved up and down by
the user. When the ball hits the top, left, or bottom walls or th e paddle,
it bounces off in the opposite direction. If the ball misses th e paddle, it
passes through the right wall and re-emerges at the left wall . Each time
the ball bounces off a wall or paddle, it emits a pong sound.
14.7.1 A Multithreaded Design
Let’s develop a multithreaded applet to play the game of Pong .
Figure 14.29 shows how the game’s GUI should appear. There ar e three
FIGURE 14.29 The UI for Pong.objects involved in this program: the applet, which serves as the GUI, the
ball, which is represented as a blue circle in the applet, and the paddle,
which is represented by a red rectangle along the right edge o f the applet.
What cannot be seen in this ﬁgure is that the ball moves autonom ously,
bouncing off the walls and paddle. The paddle’s motion is con trolled by
the user by pressing the up- and down-arrow keys on the keyboa rd.
We will develop class deﬁnitions for the ball, paddle, and th e applet.
Following the example of our dot-drawing program earlier in the Chapter,
we will employ two independent threads, one for the GUI and on e for
the ball. Because the user will control the movements of the p addle, the
applet will employ a listener object to listen for and respond to the user’s
key presses.
Figure 14.30 provides an overview of the object-oriented des ign of the
Pong program. The PongApplet class is the main class. It uses in-
stances of the Ball andPaddle classes. PongApplet is a subclass of
JApplet and implements the KeyListener interface. This is another of
the several event handlers provided in the java.awt library. This one
handles KeyEvent s and the KeyListener interface consists of three ab-
stract methods: keyPressed() ,keyTyped() , andkeyReleased() , all
of which are associated with the act of pressing a key on the ke yboard.
All three of these methods are implemented in the PongApplet class. A
key-typed event occurs when a key is pressed down. A key-rele ase event
occurs when a key that has been pressed down is released. A key -press
event is a combination of both of these events.
TheBall class is a Thread subclass. Its data and methods are de-
signed mainly to keep track of its motion within the applet’s drawing
panel. The design strategy employed here leaves the drawing of the ball
up to the applet. The Ball thread itself just handles the movement within
the applet’s drawing panel. Note that the Ball() constructor takes a ref-
erence to the PongApplet . As we will see, the Ball uses this reference
694 CHAPTER 14 •Threads and Concurrent Programming
Figure 14.30: Design of the Pong
program.
to set the dimensions of the applet’s drawing panel. Also, as theBall
moves, it will repeatedly call the applet’s repaint() method to draw
the ball.
ThePaddle class is responsible for moving the paddle up and down
along the drawing panel’s right edge. Its public methods, moveUP() and
moveDown() , will be called by the applet in response to the user pressing
the up and down arrows on the keyboard. Because the applet nee ds to
know where to draw the applet, the paddle class contains seve ral public
methods, getX() ,getY() , andresetLocation() , whose tasks are to
report the paddle’s location or to adjust its location in case the applet is
resized.
ThePongApplet controls the overall activity of the program. Note
in particular its ballHitsPaddle() method. This method has the task
of determining when the ball and paddle come in contact as the ball
continuously moves around in the applet’s drawing panel. As in the
ThreadedDotty example earlier in the chapter, it is necessary for the
Ball and the the applet to be implemented as separated threads so t hat
the applet can be responsive to the user’s key presses.
14.7.2 Implementation of the Pong Program
We begin our discussion of the program’s implementation wit h the
Paddle class implementation (Fig. 14.31).
SECTION 14.7 •CASE STUDY: The Game of Pong 695
☛ ✟
public c l a s s Paddle {
public s t a t i c f i n a l i n t HEIGHT = 5 0 ; // P a d d l e s i z e
public s t a t i c f i n a l i n t WIDTH = 1 0 ;
private s t a t i c f i n a l i n t DELTA = HEIGHT/2; // Move s i z e
private s t a t i c f i n a l i n t BORDER = 0 ;
private i n t gameAreaHeight ;
private i n t locationX , locationY ;
private PongApplet applet ;
public Paddle ( PongApplet a ) {
applet = a ;
gameAreaHeight = a . getHeight ( ) ;
locationX = a . getWidth () −WIDTH;
locationY = gameAreaHeight /2;
}// P a d d l e ( )
public void r e s e t L o c a t i o n ( ) {
gameAreaHeight = applet . getHeight ( ) ;
locationX = applet . getWidth () −WIDTH;
}
public i n t getX ( ) {
return locationX ;
}
public i n t getY ( ) {
return locationY ;
}
public void moveUp ( ) {
i f( locationY >BORDER )
locationY −= DELTA;
}// moveUp ( )
public void moveDown ( ) {
i f( locationY + HEIGHT <gameAreaHeight −BORDER)
locationY += DELTA;
}// moveDown ( )
}// P a d d l e
✡ ✠
Figure 14.31: Deﬁnition of the Paddle class.
Class constants, HEIGHT andWIDTH are used to deﬁne the size of the
Paddle , which is represented on the applet as a simple rectangle. Th e
applet will use the Graphics.fillRect() method to draw the paddle:
☛ ✟
g . f i l l R e c t ( pad . getX ( ) , pad . getY ( ) , Paddle .WIDTH, Paddl e .HEIGHT ) ;
✡ ✠
Note how the applet uses the paddle’s getX() andgetY() methods to
get the paddle’s current location.
The class constants DELTA andBORDER are used to control the paddle’s
movement. DELTA represents the number of pixels that the paddle moves
on each move up or down, and BORDER is used with gameAreaHeight
to keep the paddle within the drawing area. The moveUp() and
moveDown() methods are called by the applet each time the user presses
an up- or down-arrow key. They simply change the paddle’s loc ation by
DELTA pixels up or down.
696 CHAPTER 14 •Threads and Concurrent Programming
TheBall class (Fig. 14.32) uses the class constant SIZE to determine
the size of the oval that represents the ball, drawn by the app let as follows:
☛ ✟
g . f i l l O v a l ( b a l l . getX ( ) , b a l l . getY ( ) , b a l l . SIZE , b a l l . S IZE ) ;
✡ ✠
As with the paddle, the applet uses the ball’s getX() andgetY()
method to determine the ball’s current location.
Unlike the paddle, however, the ball moves autonomously. Its run()
method, which is inherited from its Thread superclass, repeatedly moves
the ball, draws the ball, and then sleeps for a brief interval (to slow down
the speed of the ball’s apparent motion). The run() method itself is quite
simple because it consists of a short loop. We will deal with t he details of
how the ball is painted on the applet when we discuss the apple t itself.
The most complex method in the Ball class is the move() method.
This is the method that controls the ball’s movement within t he bound-
aries of the applet’s drawing area. This method begins by mov ing the
ball by one pixel left, right, up, or down by adjusting the valu es of its
locationX andlocationY coordinates:
☛ ✟
locationX = locationX + directionX ; // C a l c u l a t e l o c a t i o n
locationY = locationY + directionY ;
✡ ✠
ThedirectionX anddirectionY variables are set to either +1or−1,
depending on whether the ball is moving left or right, up or do wn. After
the ball is moved, the method uses a sequence of ifstatements to check
whether the ball is touching one of the walls or the paddle. If t he ball is
in contact with the top, left, or bottom walls or the paddle, i ts direction
is changed by reversing the value of the directionX ordirectionY
variable. The direction changes depend on whether the ball h as touched
a horizontal or vertical wall. When the ball touches the right wall, having
missed the paddle, it passes through the right wall and re-em erges from
the left wall going in the same direction.
Note how the applet method, ballHitsPaddle() is used to deter-
mine whether the ball has hit the paddle. This is necessary be cause only
the applet knows the locations of both the ball and the paddle .
14.7.3 The KeyListener Interface
The implementation of the PongApplet class is shown in ﬁgure 14.33.
The applet’s main task is to manage the drawing of the ball and paddle
and to handle the user’s key presses. Handling keyboard event s is a sim-
ple matter of implementing the KeyListener interface. This works in
much the same way as the ActionListener interface, which is used
to handle button clicks and other ActionEvent s. Whenever a key is
pressed, it generates KeyEvent s, which are passed to the appropriate
methods of the KeyListener interface.
There’s a bit of redundancy in the KeyListener interface in the sense
that a single key press and release generates three KeyEvent s: A key-
typed event, when the key is pressed, a key-released event, w hen the key
is released, and a key-pressed event, when the key is pressed and released.
SECTION 14.7 •CASE STUDY: The Game of Pong 697
☛ ✟
import javax . swing . ∗;
import java . awt . T o o l k i t ;
public c l a s s B a l l extends Thread {
public s t a t i c f i n a l i n t SIZE = 1 0 ; // D i a m e t e r o f t h e b a l l
private PongApplet applet ; // R e f e r e n c e t o t h e a p p l e t
private i n t topWall , bottomWall , l e f t W a l l , rightWall ; // B o u n d a r i e s
private i n t locationX , locationY ; // C u r r e n t l o c a t i o n o f t h e b a l l
private i n t directionX = 1 , directionY = 1 ; // x−a n d y−d i r e c t i o n ( 1 o r −1 )
private T o o l k i t k i t = T o o l k i t . g e t D e f a u l t T o o l k i t ( ) ; // F o r b e e p ( ) m e t h o d
public B a l l ( PongApplet app ) {
applet = app ;
locationX = l e f t W a l l + 1 ; // S e t i n i t i a l l o c a t i o n
locationY = bottomWall /2;
}// B a l l ( )
public i n t getX ( ) {
return locationX ;
}// g e t X ( )
public i n t getY ( ) {
return locationY ;
}// g e t Y ( )
public void move ( ) {
rightWall = applet . getWidth ( ) −SIZE ; // D e f i n e b o u n c i n g r e g i o n
l e f t W a l l = topWall = 0 ; // And l o c a t i o n o f w a l l s
bottomWall = applet . getHeight ( ) −SIZE ;
locationX = locationX + directionX ; // C a l c u l a t e a new l o c a t i o n
locationY = locationY + directionY ;
i f( applet . ballHitsPaddle ( ) ) {
directionX = −1; // move t o w a r d l e f t w a l l
k i t . beep ( ) ;
}// i f b a l l h i t s p a d d l e
i f( locationX <= l e f t W a l l ) {
directionX = + 1 ; // move t o w a r d r i g h t w a l l
k i t . beep ( ) ;
}// i f b a l l h i t s l e f t w a l l
i f( locationY + SIZE >= bottomWall ||locationY <= topWall ) {
directionY = −directionY ; // r e v e r s e d i r e c t i o n
k i t . beep ( ) ;
}// i f b a l l h i t s t o p o r b o t t o m w a l l s
i f( locationX >= rightWall + SIZE ) {
locationX = l e f t W a l l + 1 ; // j u m p b a c k t o l e f t w a l l
}// i f b a l l g o e s t h r o u g h r i g h t w a l l
}// move ( )
public void run ( ){
while (true ){
move ( ) ; // Move
applet . r e p a i n t ( ) ;
t r y{ sleep ( 1 5 ) ;
}catch ( InterruptedException e ) {}
}// w h i l e
}// r u n ( )
}// B a l l
✡ ✠
Figure 14.32: Deﬁnition of the Ball class.
698 CHAPTER 14 •Threads and Concurrent Programming
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s PongApplet extends JApplet implements KeyListener {
private B a l l b a l l ;
private Paddle pad ;
public void i n i t ( ) {
setBackground ( Color . white ) ;
addKeyListener ( t h i s ) ;
pad = new Paddle ( t h i s ) ; // C r e a t e t h e p a d d l e
b a l l = new B a l l ( t h i s ) ; // C r e a t e t h e b a l l
b a l l . s t a r t ( ) ;
requestFocus ( ) ; // R e q u i r e d t o r e c e i v e k e y e v e n t s
}// i n i t ( )
public void paint ( Graphics g ) {
g . setColor ( getBackground ( ) ) ; // E r a s e t h e d r a w i n g a r e a
g . f i l l R e c t ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ;
g . setColor ( Color . blue ) ; // P a i n t t h e b a l l
g . f i l l O v a l ( b a l l . getX ( ) , b a l l . getY ( ) , b a l l . SIZE , b a l l . S IZE ) ;
pad . r e s e t L o c a t i o n ( ) ; // P a i n t t h e p a d d l e
g . setColor ( Color . red ) ;
g . f i l l R e c t ( pad . getX ( ) , pad . getY ( ) , Paddle .WIDTH, Paddl e .HEIGHT ) ;
}// p a i n t ( )
public boolean ballHitsPaddle ( ) {
return b a l l . getX ( ) + B a l l . SIZE >= pad . getX ( )
&& b a l l . getY ( ) >= pad . getY ( )
&& b a l l . getY ( ) <= pad . getY ( ) + Paddle .HEIGHT;
}// b a l l H i t s P a d d l e ( )
public void keyPressed ( KeyEvent e ) {// C h e c k f o r a r r o w k e y s
i n t keyCode = e . getKeyCode ( ) ;
i f( keyCode == e . VK UP) // Up a r r o w
pad . moveUp ( ) ;
else i f ( keyCode == e .VK DOWN) // Down a r r o w
pad . moveDown ( ) ;
}// k e y R e l e a s e d ( )
public void keyTyped ( KeyEvent e ) {} // U n u s e d
public void keyReleased ( KeyEvent e ) {} // U n u s e d
}// P o n g A p p l e t
✡ ✠
Figure 14.33: Deﬁnition of the PongApplet class.
SECTION 14.7 •CASE STUDY: The Game of Pong 699
While it is important for some programs to be able to distingui sh be-
tween a key-typed and key-released event, for this program, we will take
action whenever one of the arrow keys is pressed (typed and re leased).
Therefore, we implement the keyPressed() method as follows:
☛ ✟
public void keyPressed ( KeyEvent e ) {// C h e c k a r r o w k e y s
i n t keyCode = e . getKeyCode ( ) ;
i f( keyCode == e . VK UP) // Up a r r o w
pad . moveUp ( ) ;
else i f ( keyCode == e .VK DOWN) // Down a r r o w
pad . moveDown ( ) ;
}// k e y R e l e a s e d ( )
✡ ✠
Each key on the keyboard has a unique code that identiﬁes the k ey.
The key’s code is gotten from the KeyEvent object by means of the
getKeyCode() method. Then it is compared with the codes for the up-
arrow and down-arrow keys, which are implemented as class co nstants,
VKUPandVKDOWN , in the KeyEvent class. If either of those keys were
typed, the appropriate paddle method, moveUP() ormoveDown() , is
called.
Note that even though we are not using the keyPressed() and
keyReleased() methods in this program, it is still necessary to provide
implementations for these methods in the applet. In order to i mplement
an interface, such as the KeyListener interface, you must implement
allthe abstract methods in the interface. That is why we provide triv-
ial implementations of both the keyPressed() andkeyReleased()
methods.
14.7.4 Animating the Bouncing Ball
Computer animation is accomplished by repeatedly drawing, erasing, and
re-drawing an object at different locations on the drawing pa nel. The
applet’s paint() method is used for drawing the ball and the paddle
at their current locations. The paint() method is never called directly.
Rather, it is called automatically after the init() method, when the ap-
plet is started. It is then invoked indirectly by the program b y calling the
repaint() method, which is called in the run() method of the Ball
class. The reason that paint() is called indirectly is because Java needs
to pass it the applet’s current Graphics object. Recall that in Java all
drawing is done using a Graphics object.
In order to animate the bouncing ball, we ﬁrst erase the curren t image
of the ball, then we draw the ball in its new location. We also d raw the
paddle in its current location. These steps are carried out i n the applet’s
paint() method. First, the drawing area is cleared by painting its re ct-
angle in the background color. Then the ball and paddle are pa inted at
their current locations. Note that before painting the padd le, we ﬁrst call
itsresetLocation() method. This causes the paddle to be relocated in
case the user has resized the applet’s drawing area. There is no need to
do this for the ball because the ball’s drawing area is update d within the
Ball.move() method every time the ball is moved.
700 CHAPTER 14 •Threads and Concurrent Programming
One problem with computer animations of this sort is that the repeated
drawing and erasing of the drawing area can cause the screen t o ﬂicker. Double buffering
In some drawing environments a technique known as double buffering
is used to reduce the ﬂicker. In double buffering, an invisible , off-screen,
buffer is used for the actual drawing operations and it is the n used to
replace the visible image all at once when the drawing is done . Fortu-
nately, Java’s Swing components, including JApplet andJFrame , per-
form an automatic form of double buffering, so we needn’t wor ry about
it. Some graphics environments, including Java’s AWT enviro nment, do
not perform double buffering automatically, in which case t he program
itself must carry it out.
Like the other examples in this chapter, the game of Pong prov ides a
simple illustration of how threads are used to coordinate co ncurrent ac-
tions in a computer program. As most computer game fans will r ealize,
most modern interactive computer games utilize a multithre aded design.
The use of threads allows our interactive programs to achiev e a respon-
siveness and sophistication that is not possible in single- threaded pro-
grams. One of the great advantages of Java is that it simpliﬁe s the use of
threads, thereby making thread programming accessible to p rogrammers.
However, one of the lessons that should be drawn from this chap ter is
that multithreaded programs must be carefully designed in o rder to work
effectively.
SELF-STUDY EXERCISE
EXERCISE 14.12 Modify the PongApplet program so that it contains
a second ball that starts at a different location from the ﬁrs t ball.
CHAPTER SUMMARY Technical Terms
asynchronous
blocked
busy waiting
concurrent
critical section
dispatched
fetch-execute cycle
lock
monitormultitasking
multithreaded
mutual exclusion
priority scheduling
producer/consumer
model
quantum
queue
ready queueround-robin
scheduling
scheduling algorithm
task
thread
thread life cycle
time slicing
Summary of Important Points
•Multitasking is the technique of executing several tasks at the same time
within a single program. In Java we give each task a separate thread of
execution , thus resulting in a multithreaded program.
•Asequential computer with a single central processing unit (CPU) can
execute only one machine instruction at a time. A parallel computer
uses multiple CPUs operating simultaneously to execute mor e than one
instruction at a time.
CHAPTER 14 •Chapter Summary 701
•Each CPU uses a fetch-execute cycle to retrieve the next machine in-
struction from memory and execute it. The cycle is under the c ontrol
of the CPU’s internal clock, which typically runs at several hundred
megahertz —where 1 megahertz (MHz) is 1 million cycles per second.
•Time slicing is the technique whereby several threads can share a single
CPU over a given time period. Each thread is given a small slic e of the
CPU’s time under the control of some kind of scheduling algor ithm.
•Inround-robin scheduling , each thread is given an equal slice of time,
in a ﬁrst-come–ﬁrst-served order. In priority scheduling , higher-priority
threads are allowed to run before lower-priority threads ar e run.
•There are generally two ways of creating threads in a program . One is
to create a subclass of Thread and implement a run() method. The
other is to create a Thread instance and pass it a Runnable object—
that is, an object that implements run() .
•Thesleep() method removes a thread from the CPU for a determi-
nate length of time, giving other threads a chance to run.
•ThesetPriority() method sets a thread’s priority. Higher-priority
threads have more and longer access to the CPU.
•Threads are asynchronous . Their timing and duration on the CPU are
highly sporadic and unpredictable. In designing threaded pr ograms,
you must be careful not to base your algorithm on any assumpti ons
about the threads’ timing.
•To improve the responsiveness of interactive programs, you could
give compute-intensive tasks, such as drawing lots of dots, to a lower-
priority thread or to a thread that sleeps periodically.
•A thread’s life cycle consists of ready, running, waiting, s leeping, and
blocked states. Threads start in the ready state and are disp atched to
the CPU by the scheduler, an operating system program. If a thr ead
performs an I/O operation, it blocks until the I/O is completed . If it
voluntarily sleeps, it gives up the CPU.
•According to the producer/consumer model, two threads share a re-
source, one serving to produce the resource and the other to c onsume
the resource. Their cooperation must be carefully synchron ized.
•An object that contains synchronized methods is known as a mon-
itor. Such objects ensure that only one thread at a time can execute a
synchronized method. The object is locked until the thread completes
the method or voluntarily sleeps. This is one way to ensure mu tually
exclusive access to a resource by a collection of cooperatin g threads.
•Thesynchronized qualiﬁer can also be used to designate a method
as a critical section , whose execution should not be preempted by one of
the other cooperating threads.
•In designing multithreaded programs, it is useful to assume t hat if a
thread canbe interrupted at a certain point, it willbe interrupted there.
Thread coordination should never be left to chance.
•One way of coordinating two or more cooperating threads is to use
thewait/notify combination. One thread waits for a resource to
be available, and the other thread notiﬁes when a resource be comes
available.
702 CHAPTER 14 •Threads and Concurrent Programming
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 14.1
☛ ✟
public c l a s s PrintOdds implements Runnable {
private i n t bound ;
public PrintOdds ( i n t b ){
bound = b ;
}
public void p r i n t ( ) {
i f(i n t k = 1 ; k <bound ; k+=2)
System . out . p r i n t l n ( k ) ;
}
public void run ( ){
p r i n t ( ) ;
}
}
✡ ✠
SOLUTION 14.2 On my system, the experiment yielded the following output, if
each thread printed its number after every 100,000 iteration s:
☛ ✟
1111112222222211111111333333322222221111113333333
222224444444433333344444445555555544444555555555555
✡ ✠
This suggests that round-robin scheduling is being used.
SOLUTION 14.3 If each thread is given 50 milliseconds of sleep on each itera-
tion, they tend to run in the order in which they were created:
☛ ✟
1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 . . .
✡ ✠
SOLUTION 14.4 The garbage collector runs whenever the available memory
drops below a certain threshold. It must have higher priority tha n the application,
since the application won’t be able to run if it runs out of memory.
SOLUTION 14.5 To improve the responsiveness of an interactive program, the
system could give a high priority to the threads that interact w ith the user and a
low priority to those that perform noninteractive computations, su ch as number
crunching.
SOLUTION 14.6 If the JVM were single threaded, it wouldn’t be possible to
break out of an inﬁnite loop, because the program’s loop would completel y con-
sume the CPU’s attention.
SOLUTION 14.7 If round-robin scheduling is used, each thread will be get a por-
tion of the CPU’s time, so the GUI thread will eventually get its t urn. But you don’t
know how long it will be before the GUI gets its turn, so there might still be an
unacceptably long wait before the user’s actions are handled. Th us, to guarantee
responsiveness, it is better to have the drawing thread sleep on every iteration.
SOLUTION 14.8 IfDotty ’s priority is set to 1, a low value, this does improve
the responsiveness of the interface, but it is signiﬁcantly le ss responsive than using
asleep() on each iteration.
CHAPTER 14 •Exercises 703
SOLUTION 14.9 In a real bakery only one customer at a time can take a number.
The take-a-number gadget “enforces” mutual exclusion by virt ue of its design:
There’s room for only one hand to grab the ticket and there’s only one tic ket per
number. If two customers got “bakery rage” and managed to grab t he same ticket,
it would rip in half and neither would beneﬁt.
SOLUTION 14.10 One experiment to run would be to make the clerk’s perfor-
mance very slow by using large sleep intervals. If the algorith m is correct, this
should not affect the order in which customers are served. Another experiment
would be to force the clerk to work fast but the customers to work slow ly. This
should still not affect the order in which the customers are serve d.
SOLUTION 14.11 You should observe that the waiting line builds up as cus-
tomers enter the bakery, but the clerk should still serve the cu stomers in the correct
order.
SOLUTION 14.12 A two-ball version of Pong would require the following
changes to the original version:
1. A new Ball() constructor that has parameters to set the initial location and
direction of the ball.
2. The PongApplet should create a new Ball instance, start it, and draw it.
EXERCISES EXERCISE 14.1 Explain the difference between the following pairs of terms:
a.Blocked and ready .
b.Priority and round-robin scheduling.
c.Producer and consumer .
d.Monitor and lock.e.Concurrent and time slicing .
f.Mutual exclusion and critical section .
g.Busy and nonbusy waiting.
Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 14.2 Fill in the blanks.
a. happens when a CPU’s time is divided among several different
threads.
b. A method that should not be interrupted during its execution is known as a
.
c. The scheduling algorithm in which each thread gets an equal portion of the
CPU’s time is known as .
d. The scheduling algorithm in which some threads can preempt ot her threads is
known as .
e. A is a mechanism that enforces mutually exclusive access to a sy n-
chronized method.
f. A thread that performs an I/O operation may be forced into the state
until the operation is completed.
EXERCISE 14.3 Describe the concept of time slicing as it applies to CPU
scheduling.
EXERCISE 14.4 What’s the difference in the way concurrent threads would be
implemented on a computer with several processors and on a computer with a
single processor?
EXERCISE 14.5 Why are threads put into the blocked state when they perform
an I/O operation?
EXERCISE 14.6 What’s the difference between a thread in the sleep state and a
thread in the ready state?
704 CHAPTER 14 •Threads and Concurrent Programming
EXERCISE 14.7 Deadlock is a situation that occurs when one thread is holding
a resource that another thread is waiting for, while the other thr ead is holding
a resource that the ﬁrst thread is waiting for. Describe how dead lock can occur
at a four-way intersection with cars entering from each branch. How can it be
avoided?
EXERCISE 14.8 Starvation can occur if one thread is repeatedly preempted by
other threads. Describe how starvation can occur at a four-way int ersection and
how it can be avoided.
EXERCISE 14.9 Use the Runnable interface to deﬁne a thread that repeatedly
generates random numbers in the interval 2 through 12.
EXERCISE 14.10 Create a version of the Bakery program that uses two clerks
to serve customers.
EXERCISE 14.11 Modify the Numbers program so that the user can in-
teractively create NumberThread s and assign them a priority. Modify the
NumberThread s so that they print their numbers indeﬁnitely (rather than f or a
ﬁxed number of iterations). Then experiment with the system by observing the
effect of introducing threads with the same, lower, or higher pri ority. How do
the threads behave when they all have the same priority? What h appens when
you introduce a higher-priority thread into the mix? What happe ns when you
introduce a lower-priority thread into the mix?
EXERCISE 14.12 Create a bouncing ball simulation in which a single ball
(thread) bounces up and down in a vertical line. The ball should b ounce off the
bottom and top of the enclosing frame.
EXERCISE 14.13 Modify the simulation in the previous exercise so that more
than one ball can be introduced. Allow the user to introduce new ba lls into the
simulation by pressing the space bar or clicking the mouse.
EXERCISE 14.14 Modify your solution to the previous problem by having the
balls bounce off the wall at a random angle.
EXERCISE 14.15 Challenge: One type of producer/consumer problem is the
reader/writer problem. Create a subclass of JTextField that can be shared by
threads, one of which writes a random number to the text ﬁeld, and the other of
which reads the value in the text ﬁeld. Coordinate the two threa ds so that the
overall effect of the program will be to print the values from 0 to 1 00 in the proper
order. In other words, the reader thread shouldn’t read a value from the text ﬁeld
until there’s a value to be read. The writer thread shouldn’t wri te a value to the
text ﬁeld until the reader has read the previous value.
EXERCISE 14.16 Challenge: Create a streaming banner thread that moves a
simple message across a panel. The message should repeatedly e nter at the left
edge of the panel and exit from the right edge. Design the banner as a subclass of
JPanel and have it implement the Runnable interface. That way it can be added
to any user interface. One of its constructors should take a String argument that
lets the user set the banner’s message.
EXERCISE 14.17 Challenge: Create a slide show applet, which repeatedly cy-
cles through an array of images. The action of displaying the imag es should be a
separate thread. The applet thread should handle the user int erface. Give the user
some controls that let it pause, stop, start, speed up, and slow down the images.
EXERCISE 14.18 Challenge: Create a horse race simulation, using separate
threads for each of the horses. The horses should race horizontally a cross the
screen, with each horse having a different vertical coordinate . If you don’t have
good horse images to use, just make each horse a colored polygon or some oth er
shape. Have the horses implement the Drawable interface, which we introduced
in Chapter 8.
CHAPTER 14 •Exercises 705
EXERCISE 14.19 Challenge: Create a multithreaded digital clock application.
One thread should keep time in an endless while loop. The other thr ead should
be responsible for updating the screen each second.
706 CHAPTER 14 •Threads and Concurrent Programming
OBJECTIVES
After studying this chapter, you will
•Understand some basics about networks.
•Know how to use Java’s URL class to download network resources from an applet or applic ation.
•Be able to design networking applications, using the client /server model.
•Understand how to use Java’s Socket andServerSocket classes.
OUTLINE
15.1 Introduction
15.2 An Overview of Networks
15.3 Using Network Resources from an Applet
15.4 From the Java Library: java.net.URL
15.5 The Slide Show Applet
15.6 Using Network Resources from an Application
15.7 Client/Server Communication via Socket s
15.8 Case Study: Generic Client/Server Classes
15.9 Playing One Row Nim Over the Network
15.10 Java Network Security Restrictions
Special Topic: Privacy and the Internet
15.11 Java Servlets and Server Pages
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 15
Sockets and Networking
707
708 CHAPTER 15 •Sockets and Networking
15.1 Introduction
One of the key strengths of Java is the support it provides for the Internet
and client/server programming. In the previous chapter, we s aw how to
make Java programs transfer information to and from externa l ﬁles. Al-
though ﬁles are external to the programs that process them, t hey are still
located on the same computer. In this chapter, we learn how to t ransfer
information to and from ﬁles that reside on a network. This en ables pro-
grams to communicate with programs running on other compute rs. With
networking, we can communicate with computers anywhere in t he world.
15.2 An Overview of Networks
Networking is a broad and complex topic. In a typical computer science
curriculum, it is covered in one or more upper-level courses . Neverthe-
less, in this chapter you can learn enough about networking t o be able to
use network resources and to design simple Java networking a pplications.
15.2.1 Network Size and Topology
Computer networks come in a variety of sizes and shapes. A local area
network (LAN) is usually a privately owned network located within a sin-
gle ofﬁce or a single organization. Your campus network woul d be an
example of a LAN. A wide area network (WAN) spans a wide geographical
distance like a country or a continent. It may use a combinatio n of public,
private, and leased communication devices. Some of the larg e commercial
networks, such as MCI and Sprint, are examples of WANs.
The computers that make up a network can be arranged in a varie ty of
topologies , or shapes, some of the most common of which are shown in Fig-
ures 15.1 and 15.2. As you would expect, different topologie s use different
techniques for transmitting information from computer to c omputer. Network topology
Figure 15.1: Star, bus, and ring
topologies.
Hub
Star topology Bus topology
Ring topology
SECTION 15.2 •An Overview of Networks 709
Hub
Tree topology Fully connected
mesh topologyHub HubFigure 15.2: Tree and fully con-
nected mesh topologies.
In a star network (Fig. 15.1), a central computer functions as a hub,
with every other computer in the network connected to the hub . Each
computer can communicate with the others but only through th e hub. The
bus topology doesn’t have a hub computer. Instead, each node l ooks at
each message sent on the bus to ﬁnd those that are addressed to it. In
sending a message, a node waits until the bus is free and then t ransmits
the message.
A ring network (Fig. 15.1) also has no host, and the computers are con-
nected in a loop, through which they exchange information. T he tree
topology (Fig. 15.2) is organized into a hierarchy, with eac h level (trunk
of the tree, major branch of the tree) controlled by a hub. The f ully con-
nected mesh network directly connects all points to all poin ts, eliminat-
ing the “middleman.” Here there is no need to go through one or m ore
other computers in order to communicate with a particular co mputer in
the network.
Network topologies differ quite a bit in the expense of the wi ring they
require, their efﬁciency, their susceptibility to failure , and the types of
protocols they use. These differences are beyond the scope o f this chapter.
15.2.2 Internets
Aninternet (lowercase i) is a collection of two or more distinct networks,
joined by devices called routers (Fig. 15.3). An internet is like a meeting of
the United Nations. Each country sends a delegation, all of w hose mem- An internet vs. the Internet
bers speak that country’s language. A national delegation i s like a single
computer network. Language interpreters take on the task of translating
one language to another so that any two delegations, say, the United States
and China, can communicate. The routers play a similar trans lation role
within an internet. The UN conference, composed of communic ating del-
egations from all the different countries of the world, is li ke a worldwide
internet.
The United Nations is an apt analogy for the Internet (uppercase I),
which is an example of a particular worldwide internet. Inter nets, in the
generic sense, shouldn’t be confused with the Internet. It’s q uite likely
that your campus LAN is itself composed of several, smaller n etworks,
each of which uses its own “language.”
710 CHAPTER 15 •Sockets and Networking
Figure 15.3: An internet is a col-
lection of distinct networks joined
together by routers.
Router RouterRouter
RouterLAN LAN
LAN LANWAN
SELF-STUDY EXERCISES
EXERCISE 15.1 In a network of ten computers, which topology would
require the most cables?
EXERCISE 15.2 Which topology would be most resistant to having one
of its computers crash?
EXERCISE 15.3 Which topology would be least resistant to having one
of its computers crash?
15.2.3 Network Protocols
Aprotocol is a set of rules that governs the communication of infor-
mation. For example, the World Wide Web is based on the HyperText
Transfer Protocol (HTTP) . HTTP describes how information is to be ex-
changed between a Web browser, such as Internet Explorer or Ne tscape Network protocols
Navigator, and a Web server, which stores an individual’s or company’s
Web pages. Web pages are encoded in the HyperText Markup Language
(HTML) . Among other things, the HTTP protocol can interpret HTML
pages.
Similarly, the Simple Mail Transfer Protocol (SMTP) is a set of rules
that governs the transfer of e-mail . And the File Transfer Protocol (FTP) is
the protocol that governs the transfer of ﬁles across the Inte rnet.
Application Protocols
These three examples—HTTP , SMTP , and FTP—are examples of appli ca-
tion protocols. They are relatively high-level protocols t hat support and
govern a particular network application, such as e-mail or WWW ac-
cess. Among the things they determine how we address differe nt com-
puters on the network. For example, the HTTP protocol speciﬁe s Web
addresses by using a Uniform Resource Locator (URL) . A URL speci-
ﬁes three necessary bits of information: The method used to t ransfer in-
formation (e.g., HTTP or FTP), the address of the host compute r (e.g.,
SECTION 15.2 •An Overview of Networks 711
www.prenhall.com ), and the path describing where the ﬁle is located
on the host ( /morelli/index.html ):
☛ ✟
M E T H O D: //HOST/PATH
HTTP: // w w w. prenhall . com/ m o r e l l i/index . html
✡ ✠
Similarly, an e-mail address is speciﬁed by the SMTP protoco l to consist
of a local mailbox address ( George.W.Bush ) followed by the address of
the computer ( mail.whitehouse.gov ):
☛ ✟
LOCAL MAILBOX@COMPUTER
George .W. Bush@mail . whitehouse . gov
✡ ✠
Another good example of an application protocol is the Intern et’sDomain
Name System (DNS) , which is the system that governs how names, such
aswhitehouse.gov andjava.trincoll.edu , can be translated into Internet domain names
numeric addresses. In the DNS, each host computer on the Intern et is
identiﬁed with a unique host name—for example, mail ,java —which is
usually made up by the network administrator whose job it is to man-
age an organization’s network. The DNS divides the entire Int ernet into
a hierarchy of domains and subdomains . The generic domains are names
likecom,edu, andmil, which refer to the type of organization— com-
mercial, educational, and military, respectively. In addit ion to these there
are country domains, such as fr,au, andnz, for France, Australia, and
New Zealand. Finally, individuals and organizations can bu y their own
domain names , such as whitehouse ,microsoft , andtrincoll .
What makes the whole system work is that certain computers wit hin
the network are designated as DNS servers. It is their role to t ranslate
names such as java.trincoll.edu to numeric addresses whenever
they are requested to do so by clients such as the SMTP or the HTT P
server. Also, the DNS servers must communicate among themse lves to
make sure that their databases of names and addresses are up- to-date.
SELF-STUDY EXERCISE
EXERCISE 15.4 What’s the URL of the Web server at Prentice Hall?
Identify its component parts—host name, domain name, Internet domain.
15.2.4 Client/Server Applications
The HTTP , FTP , SMTP , and DNS protocols are examples of client/server
protocols , and the applications they support are examples of client/s erver
applications. In general, a client/server application is on e in which the
task at hand has been divided into two subtasks, one performe d by the
client and one performed by the server (Fig. 15.4).Request service
Provide serviceServer Client
FIGURE 15.4 Client/server
application.For example, in the HTTP case, the Web browser plays the role of a
client by requesting a Web page from a Web (HTTP) server. A Web s erver
is just a computer that runs HTTP software—a program that implem ents
the HTTP protocol. For e-mail, the program you use to read your e-mail—
Eudora, Pine, or Outlook—is an e-mail client. It requests cert ain services,
such as send mail or get mail, from an e-mail (SMTP) server, wh ich is
712 CHAPTER 15 •Sockets and Networking
simply a computer that runs SMTP software. In the FTP case, to t ransfer
a program from one computer to another, you would use an FTP cl ient,
such as Fetch. Finally, in the DNS case, the DNS servers handl e requests
for name to address translations that come from HTTP , FTP , and SMTP
servers, acting in this case like clients.
So we can say that a client/server application is one that obs erves the
following protocol:
☛ ✟
Server : Set up a s e r v i c e on a p a r t i c u l a r host computer .
C l i e n t : Contact the server and request the s e r v i c e .
Server : Accept a request from a c l i e n t and provide the s e r v i c e .
✡ ✠
As these examples illustrate, many Internet applications ar e designed as
client/server applications.
JAVA EFFECTIVE DESIGN Divide and Conquer. The client/server
protocol is an example of the effective use of the divide-and -conquer
strategy.
SELF-STUDY EXERCISE
EXERCISE 15.5 Lots of our everyday interactions ﬁt into the client/ser-
ver model. Suppose you are the client in the following servic es:
•Buying a piece of software at a bookstore.
•Buying a piece of software over the phone.
•Buying a piece of software over the Internet.
Identify the server and then describe the basic protocol.
15.2.5 Lower Level Network Protocols
Modern computer networks, such as the Internet, are organize d into a
number of levels of software and hardware. Each level has its own collec-
tion of protocols (Fig. 15.5).Application level: Provide
services. (HTTP , SMTP , DNS)
Transport layer: Deliver packets;
error recovery. (TCP , UDP)
Network layer: Move packets;
provide internetworking. (IP)
Physical and data link layers:
Transmit bits over a medium
from one address to another.
(ETHERNET)
FIGURE 15.5 Levels of network
protocols.The application level, which contains the HTTP , FTP , SMTP , an d DNS
protocols, is the highest level. Underlying the applicatio n-level protocols
are various transmission protocols , such as the Transfer Control Protocol (TCP)
and the User Datagram Protocol (UDP) . These protocols govern the trans-
fer of large blocks of information, or packets , between networked com-
puters. All of the applications we mentioned—WWW, e-mail, and ﬁ le
transfer— involve data transmission and, therefore, rely o n one or more Packet transfer
of the transmission protocols.
At the very lowest end of this hierarchy of protocols are thos e that
govern the transmission of bits or electronic pulses over wi res and those
that govern the delivery of data from node to node. Most of the se proto-
cols are built right into the hardware—the wires, connectors , transmission
devices—that networks use. On top of these are protocols, suc h as the
ethernet protocol and token ring protocol , that govern the delivery of pack-
ets of information on a local area network. These too may be bu ilt right
into the network hardware.
SECTION 15.2 •An Overview of Networks 713
"bonjour"
"au revoir"Ethernet-based LAN Token-ring based LAN
English protocol French protocol Router (IP protocol)hello =bonjour
au revoir =goodbye"hello"
"goodbye"Figure 15.6: Routers between indi-
vidual networks use the IP proto-
col to translate one network pro-
tocol to another.
As you might expect, these lower level protocols are vastly d ifferent
from each other. An ethernet network cannot talk directly to a token ring Disparate protocols
network. How can we connect such disparate networks together ? Think
again of our United Nations analogy. How do we get French-spea king net-
works to communicate with English-speaking networks? The a nswer sup-
plied by the Internet is to use the Internetworking Protocol (IP) , which
governs the task of translating one network protocol to a com mon format
(Fig. 15.6).
To push the UN analogy a bit further, the Internet’s IP is like a u niversal The Internet protocol
language built into the routers that transmit data between d isparate net-
works. On one end of a transmission, a router takes a French pa cket of
information received from one of the delegates in its networ k. The router
translates the French packet into an IP packet, which it then s ends on
through the network to its destination. When the IP packet gets close to its
destination, another router takes it and translates it into an English packet
before sending it on to its destination on its network.
15.2.6 The java.net Package
As we have seen, networks are glued together by a vast array of protocols.
Most of these protocols are implemented in software that run s on general-
purpose computers. You can install software on your persona l computer
to turn it into a Web server, an FTP server, or an e-mail server . Some of the
lower level protocols are implemented in software that runs on special-
purpose computers, the routers. Still other protocols, suc h as the ethernet
protocol, are implemented directly in hardware.
Fortunately, we don’t have to worry about the details of even the high-
est level protocols in order to write client/server applica tions in Java. The
java.net (Fig. 15.7) package supplies a powerful and easy-to-use set of
classes that supports network programming.
Thejava.net.URL class provides a representation of the Internet’s java.net. *
Uniform Resource Locator that we described earlier. We’ll s how how to
use its methods to download WWW pages. We’ll also look at an exam ple
that uses a URL and an input stream so that ﬁles stored on the We b can be
used as input ﬁles to a Java applet or application program.
TheSocket andServerSocket classes provide methods that let us
develop our own networking applications. They enable us to m ake a
direct connection to an Internet host, and read and write data through
InputStream s and OutputStream s. As we will see, this is no
more difﬁcult than reading and writing data to and from ﬁles. The
714 CHAPTER 15 •Sockets and Networking
Figure 15.7: The java.net pack-
age.
java.iojava.lang
ObjectDatagramPacket
DatagramSocket
InetAddress
ServerSocket
Socket
URL
URLConnection HttpURLConnection
URLEncoded
IOExceptionMalformedURLException
ProtocolException
SocketException
UnknownHostException
UnknownServiceExceptionBindException
ConnectException
NoRouteToHostExceptionjava.net
DatagramPacket andDatagramSocket classes provide support for
even lower-level networking applications, based on Interne t packets.
FIGURE 15.8 An applet that
continuously displays slides
downloaded from the Web.15.3 Using Network Resources from an Applet
Suppose you want to write an applet that will automatically d isplay a
slide show consisting of images or documents that you’ve pre pared and
stored on your Web site. Perhaps you can use such an applet to g ive peo-
ple who visit your site a tour of your campus (Fig. 15.8). Or pe rhaps a
company might use such an applet to advertise its products. In addition
to making the slide show available through its main Web site, you can
imagine it running continuously on a computer kiosk in the co mpany’s
Problem statementlobby.
In order to solve this problem we have to be able to download and
display Web resources. As you know, Web resources are multim edia. That
is, they could be documents, images, sounds, video clips, an d so on. All
Web resources are speciﬁed in terms of their Uniform Resourc e Locators Specifying Web resources
(URLs). Thus, to download an image (or an HTML ﬁle or audio clip ), we
usually type its URL into a Web browser. We want our program to know
beforehand the URLs of the images it will display, so there wo n’t be any
SECTION 15.4 •From the Java Library: java.net.URL 715
need for inputting the URL. We want to implement something li ke the
following algorithm:
☛ ✟
repeat f o r e v e r
Generate the URL for the next s l i d e .
Use the URL to download the image or document .
Display the image or document .
✡ ✠
A URL speciﬁcation is just a String , such as,
☛ ✟
http : // w w w. cs . t r i n c o l l . edu : 8 0 / ˜ ram/ j j j /slideshow/ s l i d e 1 . g i f
✡ ✠
which describes how to retrieve the resource. First, it spec iﬁes the
protocol or method that should be used to download the resour ce
(http ). Then, it provides the domain name of the server that
runs the protocol and the port number where the service is run ning
(www.cs.trincoll.edu:80 ). Next, the URL speciﬁes the resource’s ﬁle
name ( ˜ram/jjj/slideshow/slide1.gif ).
15.4 From the Java Library: java.net.URL
GIVEN SUCH a URL speciﬁcation, how can we download its associated
resource? Are there Java classes that can help us solve this p roblem? For-
tunately, there are. First, the java.net.URL class contains methods to
help retrieve the resource associated with a particular URL (Fig. 15.9). The
URL class represents a Uniform Resource Locator. The URL() construc-
tor shown here (there are others) takes a URL speciﬁcation as aString+URL(in urlSpec : String)
+openConnection() : URLConnection
+openStream() : InputStreamURL
FIGURE 15.9 Thejava.net.URL
class.and, assuming it speciﬁes a valid URL, it creates a URL object. If the URL
speciﬁcation is invalid, a MalformedURLException is thrown. A URL
java.sun.com/j2se/1.5.0/docs/api/might be invalid if the protocol were left off or if it is not a k nown pro-
tocol. The following simple code creates a URL for the home pa ge of our
companion Web site:
☛ ✟
URL u r l ;
t r y{
u r l =
new URL( ” http ://w w w. prenhall . com:80/ m o r e l l i/index . html” ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”Malformed URL: ” + u r l . t o S t r i n g ( ) ) ;
}
✡ ✠
Note how we catch the MalformedURLException when we create a
newURL.
Once we have a valid URL instance, it can be used to download the
data or object associated with it. There are different ways to do this. The
openConnection() method creates a URLConnection , which can then
be used to download the resource. You would only use this meth od if
your application required extensive control over the downl oad process.
A much simpler approach would use the openStream() method. This
method will open an InputStream , which you can then use to read the
716 CHAPTER 15 •Sockets and Networking
associated URL data the same way you would read a ﬁle. This met hod
is especially useful for writing Java applications (rather than applets). As
you might guess, downloading Web resources is particularly easy from a
Java applet. Now let’s search around for other methods that w e can use. URLs and streams
15.4.1 Code Reuse: The java.applet.Applet Class
Thejava.applet.Applet class itself contains several useful methods
for downloading and displaying Web resources. These method s are in-
herited by javax.swing.JApplet :
☛ ✟
public c l a s s Applet extends Panel{
public AppletContext getAppletContext ( ) ;
public AudioClip getAudioClip (URL u r l ) ;
public Image getImage (URL u r l ) ;
public void play (URL u r l ) ;
public void showStatus ( S t r i n g msg ) ;
}
✡ ✠
As you see, both the getImage() andgetAudioClip() methods use a
URL to download a resource. An AudioClip is a sound ﬁle encoded in
AUformat, a special type of encoding for sound ﬁles. The getImage()
method can return ﬁles in either GIF orJPEG format, two popular image
ﬁle formats. The play() method downloads and plays an audio ﬁle in
one easy step. For example, to download and play an audio clip within an
applet requires just two lines of code:
☛ ✟
URL u r l ;
t r y{
u r l = new
URL( ” http ://w w w. cs . t r i n c o l l . edu/˜ram/ j j j /slideshow/soun d . au” ) ;
play ( u r l ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”Malformed URL: ” + u r l . t o S t r i n g ( ) ) ;
}
✡ ✠
Similarly, to download (and store a reference to) an image is just as simple:
☛ ✟
URL u r l ;
t r y{
u r l = new
URL( ” http ://w w w. cs . t r i n c o l l . edu/˜ram/ j j j /slideshow/ s l i d e 0 . g i f ” ) ;
imgRef = getImage ( u r l ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”Malformed URL: ” + u r l . t o S t r i n g ( ) ) ;
}
✡ ✠
So, it looks as if we’ve found the methods we need to implement our slide
show applet. We’ll use the URL() constructor to create a URL from a What methods can we use?
String , and we’ll use the Applet.getImage(URL) method to retrieve
the images from the Web.
SECTION 15.5 •The Slide Show Applet 717
15.5 The Slide Show Applet
Problem Speciﬁcation
Let’s suppose our slide show will repeatedly display a set of images
named “slide0.gif,” “slide1.gif,” and “slide2.gif.” Supp ose these images
are stored on a Web site on www.cs.trincoll.edu and are stored in a
directory named /˜ram/jjj/slideshow . This means our program will
have to load the following three URLs:
☛ ✟
http : // w w w. cs . t r i n c o l l . edu/˜ram/ j j j /slideshow/ s l i d e 0 . g i f
http : // w w w. cs . t r i n c o l l . edu/˜ram/ j j j /slideshow/ s l i d e 1 . g i f
http : // w w w. cs . t r i n c o l l . edu/˜ r a m j j j /slideshow/ s l i d e 2 . g i f
✡ ✠
We want our show to cycle endlessly through these images, lea ving about
5 seconds between each slide.
User Interface Design
The user interface for this applet doesn’t contain any GUI co mponents.
It just needs to display an image every 5 seconds. It can use a simp le
paint() method to display an image each time it is repainted:
☛ ✟
public void paint ( Graphics g ) {
i f( currentImage != null )
g . drawImage ( currentImage , 10 , 10 , t h i s ) ;
}
✡ ✠
The assumption here is that the currentImage instance variable will be
set initially to null . Each time an image is downloaded, it will be set to
refer to that image. Because paint() is called before the applet starts
downloading the images, it is necessary to guard against att empting toJApplet
+paint()
+nextSlide()
+init()+WIDTH : int
+HEIGHT : int
-NIMGS : int
-slide[] : Image
-currentImage : Image
-nextImage : intSlideShowApplet
FIGURE 15.10 TheSlideShow-
Applet downloads and displays the
images.draw a null image, which would lead to an exception.
Problem Decomposition
One problem we face with this applet is getting it to pause bet ween each
+run()«interface»
Runnable
+Timer(in a : SlideShowApplet)
+run()-applet : SlideShowAppletTimer
FIGURE 15.11 TheTimer class
delays the applet thread between
each slide.slide. One way to do this is to set up a loop that does nothing fo r about 5
seconds:
☛ ✟
for (i n t k = 0 ; k <1000000; k++ ) ; // B u s y w a i t i n g
✡ ✠
However, this isn’t a very good solution. As we saw in Chapter 1 4, this
is a form of busy waiting that monopolizes the CPU, making it very difﬁ-
cult to break out of the loop. Another problem with this loop i s that we
don’t really know how many iterations to do to approximate 5 s econds of
idleness.
A much better design would be to use a separate timer thread, w hich
cansleep() for 5 seconds between each slide. So our program will have
two classes: one to download and display the slides and one to serve as a
timer (Figs. 15.10 and 15.11).
718 CHAPTER 15 •Sockets and Networking
•SlideShowApplet —This JApplet subclass will take care of down-
loading and displaying the images and starting the timer thr ead.
•Timer —This class will implement the Runnable interface so that it
can run as a separate thread. It will repeatedly sleep for 5 sec onds and
then tell the applet to display the next side.
JAVA EFFECTIVE DESIGN Busy Waiting. Instead of busy waiting,
a thread that sleeps for a brief period on each iteration is a b etter way
to introduce a delay into an algorithm.
15.5.1 The SlideShowApplet class
What should we do with the images we download? Should we repeat edly
download and display them, or should we just download them onc e and
store them in memory? The second of these alternatives seems more efﬁ-
cient. If an image has already been downloaded, it would be was teful to
download it again.
JAVA EFFECTIVE DESIGN Network Trafﬁc. In general, a design
that minimizes network trafﬁc is preferable.
So we’ll need an array to store the images. Our slide show will then
consist of retrieving the next image from the array and displ aying it. To What data do we need?
help us with this task, let’s use a nextImg variable as an array index to
keep track of the next image. Even though it isn’t absolutely necessary, we
could use a third variable here, currentImage , to keep track of the cur-
rent image being displayed. Thus, our applet needs the follo wing instance
variables:
☛ ✟
private s t a t i c f i n a l i n t NIMGS = 3 ;
private Image [ ] s l i d e = new Image [NIMGS ] ;
private Image currentImage = null ;
private i n t nextImg = 0 ;
✡ ✠
Given these variables, let’s now write a method to take care o f choosing Method design
the next slide. Recall that the paint() method is responsible for dis-
playing currentImage , so all this method needs to do is to update both
currentImage andnextImg . This method should be designed so that it
can be called by the Timer thread whenever it is time to display the next
slide, so it should be a public method. It can be a void method with
no parameters, because the applet already contains all the n ecessary in-
SECTION 15.5 •The Slide Show Applet 719
formation to display the next slide. Thus, there’s no need fo r information
to be passed back and forth between Timer and this method:
☛ ✟
public void n e x t S l i d e ( ) {
currentImage = s l i d e [ nextImg ] ;
nextImg = ( nextImg + 1) % NIMGS;
r e p a i n t ( ) ;
}// n e x t S l i d e ( )
✡ ✠
The method’s algorithm is very simple. It sets currentImage to what-
everslide is designated by nextImg and it then updates nextImg ’s
value. Note here the use of modular arithmetic to compute the value
ofnextImg . Given that NIMGS is 3, this algorithm will cause nextImg
to take on the repeating sequence of values 0, 1, 2, 0, 1, 2, and so forth.
Finally, the method calls repaint() to display the image.
JAVA PROGRAMMING TIP Modular Arithmetic. Modular
arithmetic
(x % N ) is useful for cycling repeatedly through the values
0,1,...,N−1.
The applet’s init() method will have two tasks:
•Download and store the images in slide[] .
•Start the Timer thread.
As we discussed, downloading Web resources requires the use of the
getImage() method. Here we just place these method calls in a loop:
☛ ✟
for (i n t k =0; k <NIMGS; k++)
s l i d e [ k ] = getImage ( getCodeBase ( ) ,
” g i f s /demo” + k + ” . g i f ” ) ;
✡ ✠
Note here how we convert the loop variable kinto aString and con-
catenate it right into the URL speciﬁcation. This allows us t o have URLs
containing “slide0.gif,” “slide1.gif,” and “slide2.gif. ” This makes our pro-
gram easily extensible should we later decide to add more sli des to the
show. Note also the use of the class constant NIMGS as the loop bound.
This too adds to the program’s extensibility.
JAVA PROGRAMMING TIP Concatenation. Concatenating an
integer value ( k) with a string lets you create ﬁle names of the form
file1.gif ,file2.gif , and so on.
The task of starting the Timer thread involves creating an instance of
theTimer class and calling its start() method:
☛ ✟
Thread timer = new Thread ( new Timer ( t h i s ) ) ;
timer . s t a r t ( ) ;
✡ ✠
720 CHAPTER 15 •Sockets and Networking
Note that Timer is passed a reference to this applet. This enables Timer
to call the applet’s nextSlide() method every 5 seconds. This program-
ming technique is known as callback and the nextSlide() method is an
example of a callback method (Fig. 15.12).
JAVA PROGRAMMING TIP Callback. Communication between
two objects can often be handled using a callback technique. O ne
object is passed a reference to the other object. The ﬁrst object uses the
reference to call one of the public methods of the other object .
This completes our design and development of SlideShowApplet ,
which is shown in Figure 15.13.: SlideShowApplet : Timer1: start()
nextSlide()
FIGURE 15.12 Timer uses the
nextSlide() method to call back the
applet to remind it to switch to the
next slide.☛ ✟
import java . awt . ∗;
import javax . swing . ∗;
import java . net . ∗;
public c l a s s SlideShowApplet extends JApplet {
public s t a t i c f i n a l i n t WIDTH=300 , HEIGHT=200;
private s t a t i c f i n a l i n t NIMGS = 3 ;
private Image [ ] s l i d e = new Image [NIMGS ] ;
private Image currentImage = null ;
private i n t nextImg = 0 ;
public void paint ( Graphics g ) {
g . setColor ( getBackground ( ) ) ;
g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;
i f( currentImage != null )
g . drawImage ( currentImage , 10 , 10 , t h i s ) ;
}// p a i n t ( )
public void n e x t S l i d e ( ) {
currentImage = s l i d e [ nextImg ] ;
nextImg = ( nextImg + 1) % NIMGS;
r e p a i n t ( ) ;
}// n e x t S l i d e ( )
public void i n i t ( ) {
for (i n t k =0; k <NIMGS; k++)
s l i d e [ k ] = getImage ( getCodeBase ( ) ,
” g i f s /demo” + k + ” . g i f ” ) ;
Thread timer = new Thread ( new Timer ( t h i s ) ) ;
timer . s t a r t ( ) ;
s e t S i z e ( WIDTH, HEIGHT ) ;
}// i n i t ( )
}// S l i d e S h o w A p p l e t
✡ ✠
Figure 15.13: The SlideShowApplet class.
SECTION 15.5 •The Slide Show Applet 721
15.5.2 The Timer Class
TheTimer class is a subclass of Thread , which means it must implement
therun() method. Recall that we never directly call a thread’s run() The timer thread
method. Instead, we call its start() method, which automatically calls
run() . This particular thread has a very simple and singular funct ion.
It should call the SlideShowApplet.nextSlide() method and then
sleep for 5 seconds. So its main algorithm will be:
☛ ✟
while (true ){
applet . n e x t S l i d e ( ) ;
sleep ( 5000 ) ;
}
✡ ✠
However, recall that Thread.sleep() throws the Interrupted-
Exception . This means that we’ll have to embed this while loop in a
try/catch block.
To call the applet’s nextSlide() method, we also need a reference
to theSlideShowApplet , so we need to give it a reference, such as an
instance variable, as well as a constructor that allows the a pplet to pass
Timer a reference to itself.
Given these design decisions, the complete implementation ofTimer
is shown in Figure 15.14. To see how it works, download it from theJava,
Java, Java Web site and run it.
☛ ✟
public c l a s s Timer implements Runnable {
private SlideShowApplet applet ;
public Timer ( SlideShowApplet app ) {
applet = app ;
}
public void run ( ){
t r y{
while (true ){
applet . n e x t S l i d e ( ) ;
Thread . sleep ( 5000 ) ;
}
}catch ( InterruptedException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
}// r u n ( )
}// T i m e r
✡ ✠
Figure 15.14: The Timer class.
SELF-STUDY EXERCISE
EXERCISE 15.6 Describe the design changes you would make to
SlideShowApplet if you wanted to play a soundtrack along with
your slides. Assume that the sounds are stored in a sequence o f ﬁles,
“sound0.au,” sound1.au,” and so forth, on your Web site.
722 CHAPTER 15 •Sockets and Networking
15.6 Using Network Resources from an
Application
TheSlideShowApplet illustrates the ease of downloading Web re-
sources from an applet. However, applets have limited use in t his
regard, because they come with rather severe security restr ictions that
would make them a poor choice for most networking applicatio ns (see
Section 15.10). For example, applets cannot save ﬁles that t hey down- Applet restrictions
load, because they cannot access the host computer’s ﬁle sys tem. Simi-
larly, an applet can only download ﬁles from the same host fro m which it
was downloaded. This wouldn’t be a problem for the slide show applet,
since we can simply store the slides in the same directory as t he applet
itself. So, we want to learn how to download Web resources fro m a Java
application. The next example illustrates a solution to thi s problem.
Problem Speciﬁcation
Suppose a realtor asks you to write a Java application that wi ll allow
customers to view pictures and descriptions of homes from an online Problem statement
database. The application should allow the customer to sele ct a home
and should then display both an image of the home and a text des cription
of its features, such as square footage, asking price, and so on.
Suppose that the database of image and text ﬁles is kept at a ﬁx ed loca-
tion on the Web, but the names of the ﬁles themselves may chang e. This
will enable the company to change the database as it sells the homes. The
company will provide a text ﬁle that contains the names of the ﬁles for the
current selection of homes to input into the program. To simp lify matters,
both image and text ﬁles have the same name but different exte nsions—
for example, ranch.txt andranch.gif . The data ﬁle will store just the
names of the ﬁles, one per line, giving it the following forma t:
☛ ✟
beautifulCape
handsomeRanch
l o v e l y C o l o n i a l
✡ ✠
15.6.1 Downloading a Text File from the Web
This application requires us to solve three new problems:
1. How do we download a text ﬁle of names that we want to use as men u
items?
2. How do we download a text ﬁle and display it in a JTextArea ?
3. How do we download and display an image ﬁle?
The third problem is very similar to the problem we solved in
SlideShowApplet , but here we can’t use the Applet.getImage()
method. However, as we shall see, we can ﬁnd a Java library meth od
to perform this task for us. Therefore, the most challenging part of this
program is the task of downloading a Web ﬁle and using its data in the Understanding the problem
program.
SECTION 15.6 •Using Network Resources from an Application 723
For this program we must make use of two types of data download ed
from the Web. The ﬁrst will be the names of the image and docume nt
ﬁles. We’ll want to read these names and use them as menu items that
the user can select. Second, once the user has selected a hous e to view,
we must download and display an image and a text description o f the
house. Downloading the text is basically the same as downloa ding the
ﬁle of names. The only difference is that we need to display th is text in a
JTextArea . Downloading the image ﬁle can be handled in more or less
the same way that it was handled in the SlideShowApplet — by using
a special Java method to download and display the image ﬁle.
Clearly, the problems of downloading a ﬁle from the Web and re ading a
ﬁle from the disk are quite similar. Recall that we used strea ms to handle
the I/O operation when reading disk ﬁles. The various InputStream
andOutputStream classes contained the read() andwrite() meth-
ods needed for I/O. The situation is the same for downloading W eb ﬁles.
Recall that the URL class contains the openStream() method, which
opens an InputStream to the resource associated with the URL. Once
the stream has been opened, you can read data from the stream ju st as if
it were coming from a ﬁle. The program doesn’t care whether th e data are File download algorithm
coming from a ﬁle on the Internet or a ﬁle on the disk. It just reads data
from the stream. So, to download a data ﬁle from the Internet, r egardless
of whether it’s a text ﬁle, image ﬁle, audio ﬁle, or whatever, you would
use the following general algorithm:
☛ ✟
URL u r l ;
InputStream data ;
t r y{
u r l = new URL( fileURL ) ; // C r e a t e a URL
data = u r l . openStream ( ) ; // O p e n a s t r e a m t o URL
// READ THE F I L E INTO MEMORY }// R e a d d a t
data . c l o s e ( ) ; // C l o s e t h e s t r e a m
}catch ( MalformedURLException e ) {// T h r o w n b y URL ( )
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
}
✡ ✠
The algorithm consists of four basic steps:
•Create a URL instance.
•Open an InputStream to it.
•Read the data.
•Close the stream.
Step 3 of this algorithm—read the data—involves many lines of c ode and
has, therefore, been left as a subtask suitable for encapsul ation within a
method.
Reading the Data
As we saw in the previous chapter, the algorithm for step 3 wil l depend Text or binary data?
on the ﬁle’s data. If it’s a text ﬁle, we would like to read one li ne at a time,
724 CHAPTER 15 •Sockets and Networking
storing the input in a String . If it’s an image or an audio ﬁle, we would
read one byte at a time.
Because our data are contained in a text ﬁle, we want to read on e line at What library methods can we use?
a time. The BufferedReader class contains a readLine() method that
returns either a String storing the line or the value null when it reaches
the end of ﬁle. The following method shows how you would read a text
ﬁle into the program’s JTextArea , which is named display :
☛ ✟
private void readTextIntoDisplay (URL u r l )
throws IOException {
BufferedReader data
=new BufferedReader (
new InputStreamReader ( u r l . openStream ( ) ) ) ;
display . s e t T e x t ( ””) ; // R e s e t t h e t e x t a r e a
S t r i n g l i n e = data . readLine ( ) ;
while ( l i n e != null ){ // R e a d e a c h l i n e
display . append ( l i n e + ”\n”) ;// Add t o d i s p l a y
l i n e = data . readLine ( ) ;
}
data . c l o s e ( ) ;
}// r e a d T e x t I n t o D i s p l a y ( )
✡ ✠
The method is passed the ﬁle’s URL and it uses the URL.openStream()
method to open the input stream. Note that the method throws
IOException , which means that any I/O exceptions that get raised will I/O exceptions
be handled by the calling method.
In this example, the input algorithm reads each line of the ﬁle and adds
it to the display . For our real estate application, the same basic algo-
rithm can be used to read the names of the data ﬁles and store th em in
a menu from which a user makes selections. For example, if we u se a
JComboBox menu named homeChoice , we would simply add each line
to it:
☛ ✟
S t r i n g l i n e = data . readLine ( ) ;
while ( l i n e != null ){
homeChoice . addItem ( l i n e ) ;
l i n e = data . readLine ( ) ;
}
✡ ✠
Interface Design
The interface for this application is very important. It shou ld provide
some means to display a text ﬁle and an image. The text ﬁle can b e
displayed in a JTextArea , and the image can be drawn on a JPanel .
Next, let’s consider the types of controls a user might need. The cus-
tomer should be allowed to select a home to view from a menu of o ptions.
Because the program will have the list of available homes, it can provide
the options in a JComboBox pull-down menu.
To create an appropriate layout, we want to make sure that the controls,
the image, and JTextArea all have their own region of the application’s
SECTION 15.6 •Using Network Resources from an Application 725
JTextArea for displaying
information about
the home.JFrame
Image
drawn hereJPanel JComboBox JTextArea
BorderNorth
BorderLayout east Border westJFrame
	 JComboBox Menu
	 Display JTextArea
	 Canvas JPanelComponent Hierarchy
Choice menuFigure 15.15: User interface de-
sign for the real estate application.
window. This suggests a BorderLayout , which is the default layout
for aJFrame . We can put the JComboBox menu at the “North” border,
and the image and text on the “West” and “East” borders, respe ctively.
Figure 15.15 illustrates these various design decisions.
+RealEstateViewer()
+itemStateChanged()
+main()+WIDTH : int =400
-HEIGHT : int =400
-dataFileURL : String
-baseURL : String
-display : JTextArea
-homeChoice : JComboBox
-imagePanel : ImagePanel
-currentImage : ImageRealEstateViewer+itemStateChanged()«interface»
ItemListener
JFrame
FIGURE 15.16 TheRealEstate-
Viewer class deﬁnes the user
interface.Problem Decomposition: RealEstateViewer
The task of downloading and displaying information from the Internet is
best handled by two separate classes: One to perform the down loading
and user interface tasks and the other to take care of display ing the image.
The task of downloading the image and text ﬁles from the Web ca n be
handled by the program’s main class, the RealEstateViewer , which
will also handle the user interface (Fig. 15.16). As the appl ication’s top-
level window, RealEstateViewer will is subclass of JFrame . Be-
cause its controls will include a JComboBox , it must implement the
itemStateChanged() method of the ItemListener interface.
What components and other instance variables will we need for this
class? According to our interface design, it will need a JComboBox ,
aJTextArea , and the ImagePanel . Because it will be downloading
images, it will need an Image variable.
The constants used by this application include the URL strin g for the
data ﬁle. Also, because all the images and data ﬁles will star t with the
same preﬁx,
☛ ✟
http : //java . t r i n c o l l . edu/˜ j j j a v a /homes/
✡ ✠
we should make this a constant in the program. These prelimin ary de-
cisions lead to the initial version of RealEstateViewer shown in Fig-
ure 15.17. Note that the main() method merely creates an instance of
the application and shows it. Note also that the currentImage variable
is declared public . This will let the ImagePanel have direct access to
currentImage whenever it needs to display a new image.
726 CHAPTER 15 •Sockets and Networking
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import java . net . ∗;
import java . io . ∗;
import javax . swing . ∗;
public c l a s s RealEstateViewer extends JFrame
implements ItemListener {
public s t a t i c f i n a l i n t WIDTH=400 ,HEIGHT=200;
private f i n a l S t r i n g dataFileURL =
” http :// java . t r i n c o l l . edu/˜ j j j a v a /homes/homes . t x t ” ;
private f i n a l S t r i n g baseURL =
” http :// java . t r i n c o l l . edu/˜ j j j a v a /homes/” ;
private JTextArea display = new JTextArea ( 2 0 , 2 0 ) ;
private JComboBox homeChoice = new JComboBox ( ) ;
private ImagePanel imagePanel = new ImagePanel ( t h i s ) ;
public Image currentImage = null ;
public RealEstateViewer ( ) { } // S t u b C o n s t r u c t o r
// I t e m L i s t e n e r i n t e r f a c e
public void itemStateChanged ( ItemEvent evt ) { } // S t u b
public s t a t i c void main ( S t r i n g args [ ] ) {
RealEstateViewer viewer = new RealEstateViewer ( ) ;
viewer . s e t S i z e ( viewer .WIDTH, viewer .HEIGHT ) ;
viewer . s e t V i s i b l e ( true ) ;
viewer . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// R e a l E s t a t e V i e w e r
✡ ✠
Figure 15.17: The RealEstateViewer , Version 1.
TheImagePanel Class
We’ll use a second class, the ImagePanel , to handle displaying the im-
age (Figs. 15.18 and 15.19). The reason we use a separate clas s for this+paintComponent()JPanel
+ImagePanel(in f : RealEstateViewer)
+paintComponent()-frame : RealEstateViewerImagePanel
FIGURE 15.18 An overview of the
ImagePanel class.task is that we want the image to appear in its own panel (which appears
on the West border of the main window). In addition to its const ructor,
the only method needed in this class is the paintComponent() method.
This method will be called automatically whenever the main w indow is
repainted. Its task is simply to get the current image from its parent frame
and display it. Note that a reference to the parent frame is pa ssed to the
object in its constructor.
Method Decomposition
The stub methods listed in the initial version of RealEstateViewer
(Fig. 15.17) outline the main tasks required by the applicat ion. Some of
SECTION 15.6 •Using Network Resources from an Application 727
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
public c l a s s ImagePanel extends JPanel {
private RealEstateViewer frame ;
public ImagePanel ( RealEstateViewer parent ) {
frame = parent ;
}
public void paintComponent ( Graphics g ) {
i f( frame . currentImage != null )
g . drawImage ( frame . currentImage , 0 , 0 , t h i s ) ;
}
}// I m a g e P a n e l
✡ ✠
Figure 15.19: The ImagePanel class.
these methods are very simple and even trivial to implement. Others
should be broken up into subtasks.
The constructor method should be responsible for creating t he user in-
terface, most of which will involve the routine tasks of regi stering a lis-
tener for the homeChoice menu and setting up an appropriate layout
that implements the design we developed for the user interfa ce:
☛ ✟
public RealEstateViewer ( ) {
super (”Home Viewer Application ” ) ;// S e t w i n d o w t i t l e
homeChoice . addItemListener ( t h i s ) ;
t h i s . getContentPane ( ) . add ( ”North” , homeChoice ) ;
t h i s . getContentPane ( ) . add ( ” East ” , display ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , imagePanel ) ;
display . setLineWrap ( true ) ;
initHomeChoices ( ) ; // S e t up c h o i c e b o x
showCurrentSelection ( ) ; // D i s p l a y c u r r e n t home
}
✡ ✠
Note the last two statements of the method. The ﬁrst sets up th e
JComboBox by reading its contents from a ﬁle stored in the company’s
database. Because that task will require several statement s, we deﬁne
it as a separate method, initHomeChoices() , and defer its develop-
ment for now. Similarly, the task of displaying the current m enu choice
has been organized into the showCurrentSelection() method, whose
development we also defer for now.
TheitemStateChanged() method is called automatically when the
user selects a home from the JComboBox menu. Its task is to download ItemListener
728 CHAPTER 15 •Sockets and Networking
and display information about the current menu selection. T o do this, it
can simply call the showCurrentSelection() method:
☛ ✟
public void itemStateChanged ( ItemEvent evt ) {
showCurrentSelection ( ) ;
}
✡ ✠
Downloading the Menu Items
Recall that according to our speciﬁcation, the real estate ﬁ rm stores
its current listing of homes in a text ﬁle, one home per line. T he
initHomeChoices() method downloads the text and uses its contents
to set up the items in the homeChoice JComboBox menu:
☛ ✟
private void initHomeChoices ( ) {
t r y{
URL u r l = new URL( dataFileURL ) ;
BufferedReader data = new BufferedReader (
new InputStreamReader ( u r l . openStream ( ) ) ) ;
S t r i n g l i n e = data . readLine ( ) ;
while ( l i n e != null ){
homeChoice . addItem ( l i n e ) ;
l i n e = data . readLine ( ) ;
}
data . c l o s e ( ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
}// i n i t H o m e C h o i c e s ( )
✡ ✠
It uses the algorithm we developed earlier for downloading a t ext ﬁle.
Each line of the text ﬁle represents a menu item, so, as each li ne is read by
readLine(data) , it is added to the JComboBox menu.
Downloading and Displaying Home Information
TheshowCurrentSelection() method is responsible for download-
ing and displaying images and text ﬁles whenever the user sel ects a home
to view. Recall that our speciﬁcation called for using the na me of the menu
item as a basis for constructing the name of its correspondin g text ﬁle and
image ﬁle. Therefore, the basic algorithm we need is
•Get the user’s home choice.
•Create a URL for the associated text ﬁle.
•Download and display the associated text ﬁle.
•Create a URL for the associated GIF ﬁle.
•Download and display the image.
Because downloading a text document requires stream proces sing, we
should handle that in a separate method. The task of download ing an
SECTION 15.6 •Using Network Resources from an Application 729
image ﬁle is also a good candidate for a separate method. Both of these Method decomposition
methods will use a URL, so we can leave that task up to showCurrent-
Selection() itself. The showCurrentSelection() method will cre-
ate the URLs and then invoke the appropriate methods to downl oad and
display the resources:
☛ ✟
private void showCurrentSelection ( ) {
URL u r l = null ;
// G e t u s e r ’ s c h o i c e
S t r i n g choice = homeChoice . getSelectedItem ( ) . t o S t r i n g ( ) ;
t r y{ // C r e a t e u r l a n d d o w n l o a d f i l e
u r l = new URL( baseURL + choice + ” . t x t ” ) ;
readTextIntoDisplay ( u r l ) ;
// C r e a t e u r l a n d d o w n l o a d i m a g e
u r l = new URL( baseURL + choice + ” . g i f ” ) ;
currentImage = T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . getImage ( u r l ) ;
T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . beep ( ) ; // B e e p u s e r
r e p a i n t ( ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}// T r y / c a t c h b l o c k
}// s h o w C u r r e n t S e l e c t i o n ( )
✡ ✠
Note that we have also elected to handle both the MalformedURLException
andIOException in this method. The advantage of this design is that it
separates exception handling from the normal algorithm and organizes it
into one method. Finally, note how string concatenation is u sed to build
the URL speciﬁcations, each of which consists of three parts : thebaseURL ,
the user’s choice , and the ﬁle extension.
The task of reading the text ﬁle and displaying its contents h as been en-
capsulated into the readTextIntoDisplay() method. This private
utility method performs a standard ﬁle-reading algorithm u sing the
readLine() method that we developed earlier. Figure 15.20 provides
a view of the program’s appearance as it is displaying inform ation to a
user. Figure 15.21 provides the complete implementation of this program.
Figure 15.20: The RealEstate-
Viewer program downloads im-
ages and documents over the
Web.
730 CHAPTER 15 •Sockets and Networking
☛ ✟
import java . awt . ∗;
import java . awt . event . ∗;
import java . net . ∗;
import java . io . ∗;
import javax . swing . ∗;
public c l a s s RealEstateViewer extends JFrame
implements ItemListener {
public s t a t i c f i n a l i n t WIDTH=400 ,HEIGHT=200;
private f i n a l S t r i n g dataFileURL =
” http :// java . t r i n c o l l . edu/˜ j j j a v a /homes/homes . t x t ” ;
private f i n a l S t r i n g baseURL =
” http :// java . t r i n c o l l . edu/˜ j j j a v a /homes/” ;
private JTextArea display = new JTextArea ( 2 0 , 2 0 ) ;
private JComboBox homeChoice = new JComboBox ( ) ;
private ImagePanel imagePanel = new ImagePanel ( t h i s ) ;
public Image currentImage = null ;
public RealEstateViewer ( ) {
super (”Home Viewer Application ” ) ; // S e t w i n d o w t i t l e
homeChoice . addItemListener ( t h i s ) ;
t h i s . getContentPane ( ) . add ( ”North” , homeChoice ) ;
t h i s . getContentPane ( ) . add ( ” East ” , display ) ;
t h i s . getContentPane ( ) . add ( ” Center ” , imagePanel ) ;
display . setLineWrap ( true ) ;
initHomeChoices ( ) ; // S e t up t h e c h o i c e b o x
showCurrentSelection ( ) ; // D i s p l a y t h e c u r r e n t home
}// R e a l E s t a t e V i e w e r ( )
private void initHomeChoices ( ) {
t r y{
URL u r l = new URL( dataFileURL ) ;
BufferedReader data = new BufferedReader (
new InputStreamReader ( u r l . openStream ( ) ) ) ;
S t r i n g l i n e = data . readLine ( ) ;
while ( l i n e != null ){
homeChoice . addItem ( l i n e ) ;
l i n e = data . readLine ( ) ;
}data . c l o s e ( ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
}// i n i t H o m e C h o i c e s ( )
✡ ✠
Figure 15.21: The RealEstateViewer class, Part I.
SECTION 15.6 •Using Network Resources from an Application 731
☛ ✟
private void readTextIntoDisplay (URL u r l ) throws IOException {
BufferedReader data
=new BufferedReader (
new InputStreamReader ( u r l . openStream ( ) ) ) ;
display . s e t T e x t ( ””) ; // R e s e t t h e t e x t a r e a
S t r i n g l i n e = data . readLine ( ) ;
while ( l i n e != null ){ // R e a d e a c h l i n e
display . append ( l i n e + ”\n”) ; // And a d d i t t o t h e d i s p l a y
l i n e = data . readLine ( ) ;
}data . c l o s e ( ) ;
}// r e a d T e x t I n t o D i s p l a y ( )
private void showCurrentSelection ( ) {
URL u r l = null ; // G e t u s e r ’ s c h o i c e
S t r i n g choice = homeChoice . getSelectedItem ( ) . t o S t r i n g ( ) ;
t r y{
u r l = new URL( baseURL + choice + ” . t x t ” ) ; // C r e a t e URL
readTextIntoDisplay ( u r l ) ; // D o w n l o a d a n d d i s p l a y t e x t f i l e
u r l = new URL( baseURL + choice + ” . g i f ” ) ; // C r e a t e URL
// D o w n l o a d i m a g e
currentImage = T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . getImage ( u r l ) ;
T o o l k i t . g e t D e f a u l t T o o l k i t ( ) . beep ( ) ; // A l e r t t h e u s e r
r e p a i n t ( ) ;
}catch ( MalformedURLException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( ”ERROR: ” + e . getMessage ( ) ) ;
}
}// s h o w C u r r e n t S e l e c t i o n ( )
public void itemStateChanged ( ItemEvent evt ) {
showCurrentSelection ( ) ;
}// i t e m S t a t e C h a n g e d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
RealEstateViewer viewer = new RealEstateViewer ( ) ;
viewer . s e t S i z e ( viewer .WIDTH, viewer .HEIGHT ) ;
viewer . s e t V i s i b l e ( true ) ;
viewer . addWindowListener ( new WindowAdapter ( ) {
public void windowClosing ( WindowEvent e ) {
System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
}
}) ;
}// m a i n ( )
}// R e a l E s t a t e V i e w e r
✡ ✠
Figure 15.21: (continued) RealEstateViewer , Part II.
732 CHAPTER 15 •Sockets and Networking
15.6.2 Reusing Code
As in other examples we have developed, our discovery and use of the
Toolkit.getImage() method and other classes from the Java class
library illustrate an important principle of object-orient ed programming.
JAVA EFFECTIVE DESIGN Code Reuse. Before writing code to
perform a particular task, search the available libraries t o see if there is
already code that performs that task.
An important step in designing object-oriented programs is m aking ap-
propriate use of existing classes and methods. In some cases, you want
to directly instantiate a class and use its methods to perfor m the desired
tasks. In other cases, it is necessary to create a subclass (in heritance) or im-
plement an interface (inheritance) in order to gain access t o the methods
you need.
Of course, knowing what classes exist in the libraries is som ething that
comes with experience. There’s no way that a novice Java prog rammer
would know about, say, the Toolkit.getImage() method. However,
one skill or habit that you should try to develop is always to a sk your-
self the question: “Is there a method that will do what I’m tryin g to do
here?” That question should be the ﬁrst question on your sear ch through
the libraries and reference books.
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/api/
✡ ✠
15.7 Client/Server Communication via Socket s
As we said earlier, many networking applications are based o n the client/
server model. According to this model, a task is viewed as a se rvice that
can be requested by clients and handled by servers. In this sec tion, we
develop a simple client/server framework based on a socket connection
between the client and the server.
Asocket is a simple communication channel through which two pro-
grams communicate over a network. A socket supports two-way commu-
nication between a client and a server, using a well-establi shed protocol.
The protocol simply prescribes rules and behavior that both the server and
client must follow in order to establish two-way communicat ion.
According to this protocol, a server program creates a socke t at a certain Sockets and ports
port and waits until a client requests a connection. A port is a particular
address or entry point on the host computer, which typically has hun-
dreds of potential ports. It is usually represented as a simpl e integer value.
For example, the standard port for an HTTP (Web) server is 80. O nce the
connection is established, the server creates input and out put streams to
the socket and begins sending messages to and receiving mess ages from
SECTION 15.7 •Client/Server Communication via Socket s 733
the client. Either the client or the server can close the conn ection, but it’s
usually done by the client.
JAVA DEBUGGING TIP Reserved Port Numbers. Port numbers
below 1024 are reserved for system use and should not be used b y an
application program.
To help clarify this protocol, think of some service perform ed by a hu-
man using a telephone connection. The “server” waits for the phone to Client/server protocol
ring. When it rings, the server picks it up and begins communic ating
with the client. A socket, combined with input and output str eams, is
something like a two-way phone connection.
From the client’s side, the protocol goes as follows: The cli ent creates a
socket and attempts to make a connection to the server. The cl ient has to
know the server’s URL and the port at which the service exists . Once
a connection has been established, the client creates input and output
streams to the socket and begins exchanging messages with th e server.
The client can close the connection when the service is compl eted.
Think again of the telephone analogy. A human client picks up the
phone and dials the number of a particular service. This is an alogous to
the client program creating a socket and making a connection to a server.
Once the service agent answers the phone, two-way communica tion be-
tween the client and the server can begin.
Figure 15.22 provides a view of the client/server connectio n. Note that
a socket has two channels. Once a connection has been establi shed be- Sockets and channels
tween a client and a server, a single two-way channel exists b etween them.
The client’s output stream is connected to the server’s inpu t stream. The
server’s output stream is connected to the client’s input st ream.
JAVA PROGRAMMING TIP Socket Streams. Each socket has two
streams, one for input and one for output.
Output streamInput streamSocket connection
Client ServerFigure 15.22: A socket is a two-
channel communication link.
15.7.1 The Server Protocol
Let’s now see how a client/server application would be coded in Java. The
template in Figure 15.23 shows the code that is necessary on t he server
side. The ﬁrst step the server takes is to create a ServerSocket . The
ﬁrst argument to the ServerSocket() method is the port at which the
service will reside. The second argument speciﬁes the numbe r of clients
734 CHAPTER 15 •Sockets and Networking
that can be backlogged, waiting on the server, before a clien t will be re-
fused service. If more than one client at a time should request service, Java
would establish and manage a waiting list, turning away clie nts when the
list is full.
The next step is to wait for a client request. The accept() method will Waiting for client requests
block until a connection is established. The Java system is respon sible for
waking the server when a client request is received.
☛ ✟
Socket socket ; // R e f e r e n c e t o t h e s o c k e t
ServerSocket port ; // T h e p o r t w h e r e t h e s e r v e r w i l l l i s t e n
t r y{
port = new ServerSocket (10001 , 5 ) ; // C r e a t e a p o r t
socket = port . accept ( ) ; // W a i t f o r c l i e n t t o c a l l
// C o m m u n i c a t e w i t h t h e c l i e n t
socket . c l o s e ( ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}
✡ ✠
Figure 15.23: Template for the server protocol.
Once a connection is established, the server can begin commu nicating
with the client. As we have suggested, a socket connection is like a two-
way telephone conversation. Both the client and server can “ talk” back
and forth to each other. The details of this step are not shown here. As
we will see, the two-way conversation is managed by connecti ng both an
input and an output stream to the socket.
Once the conversation between client and server is ﬁnished—o nce the
server has delivered the requested service—the server can cl ose the con-
nection by calling close() . Thus, there are four steps involved on the
server side:
•Create a ServerSocket and establish a port number.
•Listen for and accept a connection from a client.
•Converse with the client.
•Close the socket.
What distinguishes the server from the client is that the serv er establishes
the port and accepts the connection.
15.7.2 The Client Protocol
The client protocol (Fig. 15.24) is just as easy to implement. Indeed, on
the client side there are only three steps involved. The ﬁrst step is to re-
quest a connection to the server. This is done in the Socket() construc- Initiating a request
tor by supplying the server’s URL and port number. Once the co nnection
is established, the client can carry out two-way communicat ion with the
server. This step is not shown here. Finally, when the client is ﬁnished,
it can simply close() the connection. Thus, from the client side, the
protocol involves just three steps:
SECTION 15.7 •Client/Server Communication via Socket s 735
•Open a socket connection to the server, given its address.
•Converse with the server.
•Close the connection.
What distinguishes the client from the server is that the clie nt initiates the
two-way connection by requesting the service.
☛ ✟
Socket connection ; // R e f e r e n c e t o t h e s o c k e t
t r y{ // R e q u e s t a c o n n e c t i o n
connection = new Socket ( ” java . cs . t r i n c o l l . edu” , 1 0 0 0 1 ) ;
// C a r r y o n a two −way c o m m u n i c a t i o n
connection . c l o s e ( ) ; // C l o s e t h e s o c k e t
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}
✡ ✠
Figure 15.24: Template for the client protocol.
15.7.3 A Two-Way Stream Connection
Now that we have seen how to establish a socket connection bet ween
a client and server, let’s look at the actual two-way communi cation
that takes place. Because this part of the process will be exa ctly the
same for both client and server, we develop a single set of met hods,
writeToSocket() andreadFromSocket() , that may be called by ei-
ther.
ThewriteToSocket() method takes two parameters, the Socket Output routine
and aString , which will be sent to the process on the other end of the
socket:
☛ ✟
protected void writeToSocket ( Socket sock , S t r i n g s t r )
throws IOException {
oStream = sock . getOutputStream ( ) ;
for (i n t k = 0 ; k <s t r . length ( ) ; k++)
oStream . write ( s t r . charAt ( k ) ) ;
}// w r i t e T o S o c k e t ( )
✡ ✠
IfwriteToSocket() is called by the server, then the string will be sent
to the client. If it is called by the client, the string will be s ent to the server.
The method is declared protected because we will deﬁne it in a
superclass so that it can be inherited and used by both the cli ent and Protected methods
server classes. Note also that the method declares that it th rows an
IOException . Because there’s no way to ﬁx an IOException , we’ll just
let this exception be handled elsewhere, rather than handli ng it within the
method.
In order to write to a socket we need only get the socket’s
OutputStream and then write to it. For this example, oStream
is an instance variable of the client/server superclass. We use the
736 CHAPTER 15 •Sockets and Networking
Socket.getOutputStream() method to get a reference to the socket’s
output stream. Note that we are not creating a new output stre am here.
We are just getting a reference to an existing stream, which wa s created
when the socket connection was accepted. Note also that we do not close
the output stream before exiting the method. This is importa nt. If you
close the stream, you will lose the ability to communicate th rough the
socket.
JAVA LANGUAGE RULE Socket Streams. When a socket is
created, it automatically creates its own streams. To use on e you just
need to get a reference to it.
JAVA DEBUGGING TIP Socket Streams. After writing to or reading
from a socket I/O stream, do not close the stream. That would ma ke
the socket unusable for subsequent I/O.
Given the reference to the socket’s output stream, we simply write each
character of the string using the OutputStream.write() method. This
method writes a single byte . Therefore, the input stream on the other
side of the socket must read bytes and convert them back into c haracters.
JAVA EFFECTIVE DESIGN Designing a Protocol. In designing
two-way communication between a client and a server, you are
designing a protocol that each side must use. Failure to desi gn and
implement a clear protocol will cause the communication to b reak
down.
ThereadFromSocket() method takes a Socket parameter and returns Input routine
aString :
☛ ✟
protected S t r i n g readFromSocket ( Socket sock )
throws IOException {
iStream = sock . getInputStream ( ) ;
S t r i n g s t r = ””;
char c ;
while ( ( c = ( char ) iStream . read ( ) ) != ’\n ’)
s t r = s t r + c + ””;
return s t r ;
}
✡ ✠
It uses the Socket.getInputStream() method to obtain a reference to
the socket’s input stream, which has already been created. S o here again
it is important that you don’t close the stream in this method . A socket’s
input and output streams will be closed automatically when t he socket
connection itself is closed.
TheInputStream.read() method reads a single byte at a time from
the input stream until an end-of-line character is received . For this par-
ticular application, the client and server will both read an d write one line
of characters at a time. Note the use of the cast operator (char) in the
SECTION 15.8 •CASE STUDY: Generic Client/Server Classes 737
read() statement. Because byte s are being read, they must be converted
tochar before they can be compared to the end-of-line character or c on-
catenated to the String . When the read loop encounters an end-of-line
character, it terminates and returns the String that was input.
JAVA DEBUGGING TIP Bytes and Chars. It is a syntax error to
compare a byte and achar . One must be converted to the other
using an explicit cast operator.
15.8 CASE STUDY: Generic Client/Server Classes
Suppose your boss asks you to set up generic client/server cl asses that Problem statement
can be used to implement a number of related client/server ap plications.
One application that the company has in mind is a query servic e, in which
the client would send a query string to the server, and the ser ver would
interpret the string and return a string that provides the an swer. For ex-
ample, the client might send the query, “Hours of service,” an d the client
would respond with the company’s business hours.
Another application the company wants will enable the clien t to ﬁll out
an order form and transmit it as a string to the server. The ser ver will
interpret the order, ﬁll it, and return a receipt, including instructions as to
when the customer will receive the order.
All of the applications to be supported by this generic clien -
t/server will communicate via strings, so something very mu ch like the
readFromSocket() andwriteToSocket() methods can be used for
their communication. Of course, you want to design classes s o they can
be easily extended to support byte-oriented, two-way commu nications,
should that type of service become needed.
In order to test the generic models, we will subclass them to cr eate a
simple echo service. This service will echo back to the clien t any message The echo service
that the server receives. For example, we’ll have the client accept key-
board input from the user and then send the user’s input to the server and
simply report what the server returns. The following shows t he output
generated by a typical client session:
☛ ✟
CLIENT : connected to ’ java . cs . t r i n c o l l . edu ’
SERVER : Hello , how may I help you?
CLIENT : type a l i n e or ’ goodbye ’ to quit
INPUT : h e l l o
SERVER : You said ’ h e l l o ’
INPUT : t h i s i s fun
SERVER : You said ’ t h i s i s fun ’
INPUT : java java java
SERVER : You said ’ java java java ’
INPUT : goodbye
SERVER : Goodbye
CLIENT : connection closed
✡ ✠
On the server side, the client’s message will be read from the input stream
and then simply echoed back (with some additional character s attached)
738 CHAPTER 15 •Sockets and Networking
through the output stream. The server doesn’t display a trac e of its activity
other than to report when connections are established and cl osed. We
will code the server in an inﬁnite loop so that it will accept c onnections
from a (potentially) endless stream of clients. In fact, most servers are
coded in this way. They are designed to run forever and must be restarted
whenever the host that they are running needs to be rebooted. The output
from a typical server session is as follows:
☛ ✟
Echo server at java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1 waiti ng for connections
Accepted a connection from java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1
Closed the connection
Accepted a connection from java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1
Closed the connection
✡ ✠
JAVA EFFECTIVE DESIGN Inﬁnite Loop. A server is an application
that’s designed to run in an inﬁnite loop. The loop should be e xited
only when some kind of exception occurs.
15.8.1 Object-Oriented Design
A suitable solution for this project will make extensive use o f object-
oriented design principles. We want Server andClient classes that can
easily be subclassed to support a wide variety of services. T he solution
should make appropriate use of inheritance and polymorphism in its design.
Perhaps the best way to develop our generic class is ﬁrst to de sign the
echo service, as a typical example, and then generalize it.
The Threaded Root Subclass: ClientServer
One lesson we can draw at the outset is that both clients and se rvers
use basically the same socket I/O methods. Thus, as we’ve seen , the
+run()Thread
+run()Client
+run()Server#  readFromSocket(in s : Socket) : String
#  writeToSocket(in s : String, in str)#  iStream : InputStream
#  oStream : OutputStreamClientServer
FIGURE 15.25 Overall design of a
client/server application.readFromSocket() andwriteToSocket() methods could be used by
both clients and servers. Because we want all clients and ser vers to inherit
these methods, they must be placed in a common superclass. Le t’s name
this the ClientServer class.
Where should we place this class in the Java hierarchy? Should it be a
direct subclass of Object , or should it extend some other class that would
give it appropriate functionality? One feature that would m ake our clients
and servers more useful is if they were independent threads. That way
they could be instantiated as part of another object and given the subtask
of communicating on behalf of that object.
Therefore, let’s deﬁne the ClientServer class as a subclass of
Thread (Fig. 15.25). Recall from Chapter 14 that the typical way to d erive
functionality from a Thread subclass is to override the run() method.
Therun() method will be a good place to implement the client and
server protocols. Because they are different, we’ll deﬁne run() in both
theClient andServer subclasses.
SECTION 15.8 •CASE STUDY: Generic Client/Server Classes 739
For now, the only methods contained in ClientServer (Fig. 15.26)
are the two I/O methods we designed. The only modiﬁcation we ha ve
made to the methods occurs in the writeToSocket() method, where
we have added code to make sure that any strings written to the socket
are terminated with an end-of-line character.
This is an important enhancement, because the read loop in th e
readFromSocket() method expects to receive an end-of-line character.
Rather than rely on speciﬁc clients to guarantee that their s trings end with
\n, our design takes care of this problem for them. This ensures that ev-
☛ ✟
import java . io . ∗;
import java . net . ∗;
public c l a s s C l i e n t S e r v e r extends Thread {
protected InputStream iStream ; // I n s t a n c e v a r i a b l e s
protected OutputStream oStream ;
protected S t r i n g readFromSocket ( Socket sock )
throws IOException {
iStream = sock . getInputStream ( ) ;
S t r i n g s t r = ””;
char c ;
while ( ( c = ( char ) iStream . read ( ) ) != ’\n ’)
s t r = s t r + c + ””;
return s t r ;
}
protected void writeToSocket ( Socket sock , S t r i n g s t r )
throws IOException {
oStream = sock . getOutputStream ( ) ;
i f( s t r . charAt ( s t r . length ( ) −1 ) != ’\n ’)
s t r = s t r + ’\n ’;
for (i n t k = 0 ; k <s t r . length ( ) ; k++)
oStream . write ( s t r . charAt ( k ) ) ;
}// w r i t e T o S o c k e t ( )
}// C l i e n t S e r v e r
✡ ✠
Figure 15.26: The ClientServer class serves as the superclass for clien-
t/server applications.
ery communication that takes place between one of our client s and servers
will be line oriented.
JAVA EFFECTIVE DESIGN Defensive Design. Code that performs
I/O, whether across a network or otherwise, should be designe d to
anticipate and remedy common errors. This will lead to more r obust
programs.
740 CHAPTER 15 •Sockets and Networking
Figure 15.27: Design of the
EchoServer class.
+EchoServer(in por : int, in backlogs : int)
 #  provideService(in s : Socket)
+run()-port : ServerSocket
-socket : SocketEchoServerClientServer
15.8.2 The EchoServer Class
Let’s now develop a design for the echo server. This class wil l be a sub-
class of ClientServer (Fig. 15.27). As we saw in discussing the server
protocol, one task that echo server will do is create a ServerSocket
and establish a port number for its service. Then it will wait for a
Socket connection, and once a connection is accepted, the echo serv er
will then communicate with the client. This suggests that ou r server needs What data do we need?
at least two instance variables. It also suggests that the tas k of creat-
ing aServerSocket would be an appropriate action for its constructor
method. This leads to the following initial deﬁnition:
☛ ✟
import java . net . ∗;
import java . io . ∗;
public c l a s s EchoServer extends C l i e n t S e r v e r {
private ServerSocket port ;
private Socket socket ;
public EchoServer ( i n t portNum , i n t nBacklog ) {
t r y{
port = new ServerSocket ( portNum , nBacklog ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}
}
public void run ( ){ } // S t u b m e t h o d
}// E c h o S e r v e r
✡ ✠
Note that the constructor method catches the IOException . Note also
that we have included a stub version of run() , which we want to deﬁne
in this class.
OnceEchoServer has set up a port, it should issue the port.accept()
method and wait for a client to connect. This part of the serve r protocol
belongs in the run() method. As we have said, most servers are designed The server algorithm
to run in an inﬁnite loop. That is, they don’t just handle one re quest and
then quit. Instead, once started (usually by the system), the y repeatedly
SECTION 15.8 •CASE STUDY: Generic Client/Server Classes 741
handle requests until deliberately stopped by the system. T his leads to the
following run algorithm:
☛ ✟
public void run ( ){
t r y{
System . out . p r i n t l n ( ”Echo server at ”
+ InetAddress . getLocalHost ( )
+” waiting f o r connections ” ) ;
while (true ){
socket = port . accept ( ) ;
System . out . p r i n t l n ( ”Accepted a connection from ”
+ socket . getInetAddress ( ) ) ;
provideService ( socket ) ;
socket . c l o s e ( ) ;
System . out . p r i n t l n ( ” Closed the connection \n”) ;
}
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}
}// r u n ( )
✡ ✠
For simplicity, we are printing the server’s status message s on
System.out . Ordinarily these should go to a log ﬁle. Note also
that the details of the actual service algorithm are hidden i n the
provideService() method.
As described earlier, the provideService() method consists of writ-
ing a greeting to the client and then repeatedly reading a str ing from the
input stream and echoing it back to the client via the output s tream. This
is easily done using the writeToSocket() andreadFromSocket()
methods we developed. The implementation of this method is s hown,
along with the complete implementation of EchoServer , in Figure 15.28.
The protocol used by EchoServer.provideService() starts by
saying “hello” and loops until the client says “goodbye.” Whe n the client
says “goodbye,” the server responds with “goodbye.” In all ot her cases
it responds with “You said X,” where X is the string that was re ceived
from the client. Note the use of the toLowerCase() method to con-
vert client messages to lowercase. This simpliﬁes the task o f checking for
“goodbye” by removing the necessity of checking for differe nt spellings
of “Goodbye.”
JAVA EFFECTIVE DESIGN Defensive Design. Converting I/O to
lowercase helps to minimize miscommunication between a cli ent and
server and leads to a more robust protocol.
This completes the design of the EchoServer . We have deliberately
designed it in a way that will make it easy to convert into a gen eric
server. Hence, we have the motivation for using provideService()
as the name of the method that provides the echo service. In ord er to
turnEchoServer into a generic Server class, we can simply make
provideService() an abstract method, leaving its implementation to
theServer subclasses. We’ll discuss the details of this change later. Designing for extensibility
742 CHAPTER 15 •Sockets and Networking
☛ ✟
import java . net . ∗;
import java . io . ∗;
public c l a s s EchoServer extends C l i e n t S e r v e r {
private ServerSocket port ;
private Socket socket ;
public EchoServer ( i n t portNum , i n t nBacklog ) {
t r y{
port = new ServerSocket ( portNum , nBacklog ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}
}// E c h o S e r v e r ( )
public void run ( ){
t r y{
System . out . p r i n t l n ( ”Echo server at ” +
InetAddress . getLocalHost ( ) + ” waiting f o r connections ” ) ;
while (true ){
socket = port . accept ( ) ;
System . out . p r i n t l n ( ”Accepted a connection from ” +
socket . getInetAddress ( ) ) ;
provideService ( socket ) ;
socket . c l o s e ( ) ;
System . out . p r i n t l n ( ” Closed the connection \n”) ;
}// w h i l e
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y / c a t c h
}// r u n ( )
protected void provideService ( Socket socket ) {
S t r i n g s t r = ””;
t r y{
writeToSocket ( socket , ” Hello , how may I help you? \n”) ;
do{
s t r = readFromSocket ( socket ) ;
i f( s t r . toLowerCase ( ) . equals ( ”goodbye” ) )
writeToSocket ( socket , ”Goodbye \n”) ;
else
writeToSocket ( socket , ”You said ’ ” + s t r + ” ’\n”) ;
}while ( ! s t r . toLowerCase ( ) . equals ( ”goodbye” ) ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y / c a t c h
}// p r o v i d e S e r v e r ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
EchoServer server = new EchoServer ( 1 0 0 0 1 , 3 ) ;
server . s t a r t ( ) ;
}// m a i n ( )
}// E c h o S e r v e r
✡ ✠
Figure 15.28: EchoServer simply echoes the client’s message.
SECTION 15.8 •CASE STUDY: Generic Client/Server Classes 743
15.8.3 The EchoClient Class
ClientServer
+EchoClient(in url : String, in port : int)
 # requestService(in s : Socket)
 # readFromKeyboard() : String
+run() # socket : SocketEchoClient
FIGURE 15.29 Design of the
EchoClient class.TheEchoClient class is just as easy to design (Fig. 15.29). It, too, will be a
subclass of ClientServer . It needs an instance variable for the Socket
that it will use, and its constructor should be responsible f or opening a
socket connection to a particular server and port. The main p art of its
protocol should be placed in the run() method. The initial deﬁnition is
as follows:
☛ ✟
import java . net . ∗;
import java . io . ∗;
public c l a s s EchoClient extends C l i e n t S e r v e r {
protected Socket socket ;
public EchoClient ( S t r i n g url , i n t port ){
t r y{
socket = new Socket ( url , port ) ;
System . out . p r i n t l n ( ”CLIENT : connected to ”
+ u r l + ” : ” + port ) ;
}catch ( Exception e ) {
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 1 ) ;
}
}// E c h o C l i e n t ( )
public void run ( ){ } // S t u b m e t h o d
}// E c h o C l i e n t
✡ ✠
The constructor method takes two parameters that specify th e URL and
port number of the echo server. By making these parameters, r ather than
hard coding them within the method, we give the client the ﬂexi bility to
connect to servers on a variety of hosts.
As with other clients, EchoClient ’srun() method will consist of re-
questing some kind of service from the server. Our initial de sign called for
EchoClient to repeatedly input a line from the user, send the line to the The client algorithm
server, and then display the server’s response. Thus, for th is particular
client, the service requested consists of the following alg orithm:
☛ ✟
Wait for the server to say ” h e l l o ” .
Repeat
Prompt and get and l i n e of input from the user .
Send the user ’ s l i n e to the server .
Read the server ’ s response .
Display the response to the user .
u n t i l the user types ”goodbye”
✡ ✠
With an eye toward eventually turning EchoClient into a generic
client, let’s encapsulate this procedure into a requestService()
method that we can simply call from the run() method. Like for the
744 CHAPTER 15 •Sockets and Networking
provideService() method, this design is another example of the en-
capsulation principle:
JAVA EFFECTIVE DESIGN Encapsulation. Encapsulating a portion
of the algorithm into a separate method makes it easy to chang e the
algorithm by overriding the method.
TherequestService() method will take a Socket parameter and per-
form all the I/O for this particular client:
☛ ✟
protected void r e q u e s t S e r v i c e ( Socket socket ) throws IOException {
S t r i n g s e r v S t r = readFromSocket ( socket ) ;
// C h e c k f o r ” H e l l o ”
System . out . p r i n t l n ( ”SERVER : ” + s e r v S t r ) ; // R e p o r t t h e s e r v e r ’ s r e s p o n s e
System . out . p r i n t l n ( ”CLIENT : type a l i n e or ’ goodbye ’ to quit ” ) ;
// P r o m p t
i f( s e r v S t r . substring ( 0 , 5 ) . equals ( ” Hello ” ) ){
S t r i n g u s e r S t r = ””;
do{
u s e r S t r = readFromKeyboard ( ) ; // G e t i n p u t
writeToSocket ( socket , u s e r S t r + ”\n”) ; // S e n d i t t o s e r v e r
s e r v S t r = readFromSocket ( socket ) ; // R e a d t h e s e r v e r ’ s r e s p o n s e
System . out . p r i n t l n ( ”SERVER : ” + s e r v S t r ) ; // R e p o r t s e r v e r ’ s r e s p o n s e
}while ( ! u s e r S t r . toLowerCase ( ) . equals ( ”goodbye” ) ) ; // U n t i l ’ g o o d b y e ’
}
}// r e q u e s t S e r v i c e ( )
✡ ✠
Although this method involves several lines, they should al l be familiar
to you. Each time the client reads a message from the socket, i t prints
it onSystem.out . The ﬁrst message it reads should start with the sub-
string “Hello”. This is part of its protocol with the client. N ote how the
substring() method is used to test for this. After the initial greeting
from the server, the client begins reading user input from th e keyboard,
writing it to the socket, then reading the server’s response , and displaying
it onSystem.out .
Note that the task of reading user input from the keyboard has been
made into a separate method, which is one we’ve used before:
☛ ✟
protected S t r i n g readFromKeyboard ( ) throws IOException {
BufferedReader input = new BufferedReader (
new InputStreamReader ( System . in ) ) ;
System . out . p r i n t ( ”INPUT : ” ) ;
S t r i n g l i n e = input . readLine ( ) ;
return l i n e ;
}// r e a d F r o m K e y b o a r d ( )
✡ ✠
The only method remaining to be deﬁned is the run() , which is
shown with the complete deﬁnition of EchoClient in Figure 15.30.
Therun() method can simply call the requestService() method.
When control returns from the requestService() method, run()
closes the socket connection. Because requestService() might throw
SECTION 15.8 •CASE STUDY: Generic Client/Server Classes 745
anIOException , the entire method must be embedded within a
try/catch block that catches that exception.
Testing the Echo Service
BothEchoServer andEchoClient contain main() methods (Figs. 15.28
and 15.30). In order to test the programs, you would run the ser ver on one
computer and the client on another computer. (Actually they can both be
run on the same computer, although they wouldn’t know this an d would
still access each other through a socket connection.)
TheEchoServer must be started ﬁrst, so that its service will be avail-
able when the client starts running. It also must pick a port nu mber. In
this case it picks 10001. The only constraint on its choice is that it cannot
use one of the privileged port numbers—those below 1024—and it cannot
use a port that’s already in use.
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
EchoServer server = new EchoServer ( 1 0 0 0 1 , 3 ) ;
server . s t a r t ( ) ;
}// m a i n ( )
✡ ✠
When an EchoClient is created, it must be given the server’s URL
(java.trincoll.edu ) and the port that the service is using:
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] ) {
EchoClient c l i e n t =
new EchoClient ( ” java . t r i n c o l l . edu” , 1 0 0 0 1 ) ;
c l i e n t . s t a r t ( ) ;
}// m a i n ( )
✡ ✠
As they are presently coded, you will have to modify both EchoServer
andEchoClient to provide the correct URL and port for your environ-
ment. In testing this program, you might wish to experiment by trying to
introduce various errors into the code and observing the res ults. When
you run the service, you should observe something like the fo llowing
output on the client side:
☛ ✟
CLIENT : connected to java . t r i n c o l l . edu :10001
SERVER : Hello , how may I help you?
CLIENT : type a l i n e or ’ goodbye ’ to quit
INPUT : t h i s i s a t e s t
SERVER : You said ’ t h i s i s a t e s t ’
INPUT : goodbye
SERVER : Goodbye
CLIENT : connection closed
✡ ✠
746 CHAPTER 15 •Sockets and Networking
☛
import java . net . ∗;
import java . io . ∗;
public c l a s s EchoClient extends C l i e n t S e r v e r {
protected Socket socket ;
public EchoClient ( S t r i n g url , i n t port ){
t r y{
socket = new Socket ( url , port ) ;
System . out . p r i n t l n ( ”CLIENT : connected to ” + u r l + ” : ” + port )
}catch ( Exception e ) {
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 1 ) ;
}
}// E c h o C l i e n t ( )
public void run ( ){
t r y{
r e q u e s t S e r v i c e ( socket ) ;
socket . c l o s e ( ) ;
System . out . p r i n t l n ( ”CLIENT : connection closed ” ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
}
}// r u n ( )
protected void r e q u e s t S e r v i c e ( Socket socket ) throws IOException {
S t r i n g s e r v S t r = readFromSocket ( socket ) ; // C h e c k
System . out . p r i n t l n ( ”SERVER : ” + s e r v S t r ) ; // R e p o r t t h e s e r v e r
System . out . p r i n t l n ( ”CLIENT : type a l i n e or ’ goodbye ’ to quit ” ) ;//
i f( s e r v S t r . substring ( 0 , 5 ) . equals ( ” Hello ” ) ){
S t r i n g u s e r S t r = ””;
do{
u s e r S t r = readFromKeyboard ( ) ; // G e t i n p u t f r o
writeToSocket ( socket , u s e r S t r + ”\n”) ; // S e n d i t t o s e r v e r
s e r v S t r = readFromSocket ( socket ) ; // R e a d s e r v e r ’ s r
System . out . p r i n t l n ( ”SERVER : ” + s e r v S t r ) ; // R e p o r t s e r v e r ’ s
}while ( ! u s e r S t r . toLowerCase ( ) . equals ( ”goodbye” ) ) ; // U n t i l ’ g o
}
}// r e q u e s t S e r v i c e ( )
protected S t r i n g readFromKeyboard ( ) throws IOException {
BufferedReader input = new BufferedReader ( new InputStreamReader ( Sys
System . out . p r i n t ( ”INPUT : ” ) ;
S t r i n g l i n e = input . readLine ( ) ;
return l i n e ;
}// r e a d F r o m K e y b o a r d ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
EchoClient c l i e n t = new EchoClient ( ” java . t r i n c o l l . edu” , 1 0 0 0 1 ) ;
c l i e n t . s t a r t ( ) ;
}// m a i n ( )
}// E c h o C l i e n t
✡
Figure 15.30: The EchoClient class prompts the user for a string and
sends it to the EchoServer , which simply echoes it back.
SECTION 15.9 •Playing One Row Nim Over the Network 747
+Server(in port : int, in backlog : int)
+run()
 # provideService(in s : Socket) # port : ServerSocket
 # socket : SocketServer # readFromSocket(in sock : Socket) : String
 # writetoSocket(in sock : Socket, in str : String) # iStream  : InputStream
 # oStream  : OutputStreamClientServer
+NimServer(in portNum : int, in nBacklog : int)
 # provideService(in s : Socket)
+run()-port : ServerSocket
-socket : ServerSocketNimServer+Client()
+run()
 # readFromKeyboard()
 # requestService(in s : Socket) # socket : SocketClient
+NimClient(in url : String, in requestServer : Socket)
 # requestService(in s : Socket)
+main() # socket : SocketNimClient+main()Thread Figure 15.31: Class hierarchy for a
generic client/server application.
15.9 Playing One Row Nim Over the Network
In the previous section we developed and tested a generic echo service.
It is based on a common root class, ClientServer , which is a subclass
ofThread . Both EchoServer andEchoClient extend the root class,
and each implements its own version of run() . In this section, we will
generalize this design so that it can support a wide range of s ervices. To
illustrate the effectiveness of the design, we will use it as the basis for a
program that plays One Row Nim over the Internet.
In order to generalize our design, we begin by identifying tho se ele-
ments that are common to all servers and clients and what is pa rticular to Designing for extensibility
the echo service and client. Clearly, the general server and client protocols
that are deﬁned here in their respective run() methods, are something
that all servers and clients have in common. What differs from one appli-
cation to another is the particular service provided and req uested, as de-
tailed in their respective provideService() andrequestService()
methods. In this example, the service that is provided will be One Row
Nim. The clients that use this service will be (human) player s of the game.
Therefore, the way to generalize this application is to deﬁn e the
run() method in the generic Server andClient classes. The Abstract service methods
748 CHAPTER 15 •Sockets and Networking
overall design of the One Row Nim service will now consist of ﬁ ve
classes organized into the hierarchy shown in Figure 15.31. At the
root of the hierarchy is the ClientServer class, which contains noth-
ing but I/O methods used by both clients and servers. The ab-
stract Server andClient classes contain implementations of the
Thread.run() method, which deﬁnes the basic protocols for servers
and clients, respectively. The details of the particular se rvice are
encoded in the provideService() andrequestService() meth-
ods. Because the run() methods deﬁned in Client andServer
callprovideService() andrequestService() , respectively, these
methods must be declared as abstract methods in the Server and
Client classes. Any class that contains an abstract method must itself
be declared abstract .
Note that we have left the readFromSocket() andwriteToSocket()
methods in the ClientServer class. These methods are written in
a general way and can be used, without change, by a wide range
of clients and servers. If necessary, they can also be overrid den by
a client or server. In fact, as we will see, the NimServer class
does override the writeToSocket() method. Similarly, note that the
readFromKeyboard() method is deﬁned in the Client superclass.
This is a general method that can be used by a large variety of c lients,
so it is best if they don’t have to redeﬁne it themselves.
These design decisions lead to the deﬁnitions of Server and
Client shown in Figures 15.32 and 15.33, respectively. Note
thatprovideService() andrequestService() are left unimple-
mented. Subclasses of Server , such as NimServer , and subclasses of
Client , such as NimClient , can implement provideService() and
requestService() in a way that is appropriate for the particular ser-
vice they are providing.
JAVA EFFECTIVE DESIGN Polymorphism. Deﬁning a method as
abstract within a superclass, and implementing it in various ways
in subclasses, is an example of polymorphism. Polymorphism is a
powerful object-oriented design technique.
15.9.1 The NimServer Class
Given the abstract deﬁnition of the Server class, deﬁning a new ser-
vice is simply a matter of extending Server and implementing the Extensibility
provideService() method in the new subclass. We will name the
subclass NimServer .
SECTION 15.9 •Playing One Row Nim Over the Network 749
☛ ✟
import java . net . ∗;
import java . io . ∗;
public a b s t r a c t c l a s s Server extends C l i e n t S e r v e r {
protected ServerSocket port ;
protected Socket socket ;
public Server ( i n t portNum , i n t nBacklog ) {
t r y{
port = new ServerSocket ( portNum , nBacklog ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y / c a t c h
}// S e r v e r ( )
public void run ( ){
t r y{
System . out . p r i n t l n ( ” Server at ” +
InetAddress . getLocalHost ( ) +
” waiting f o r connections ” ) ;
while (true ){
socket = port . accept ( ) ;
System . out . p r i n t l n ( ”Accepted a connection from ”
+ socket . getInetAddress ( ) ) ;
provideService ( socket ) ;
socket . c l o s e ( ) ;
System . out . p r i n t l n ( ” Closed the connection \n”) ;
}// w h i l e
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y / c a t c h
}// r u n ( )
// I m p l e m e n t e d i n s u b c l a s s
protected a b s t r a c t void provideService ( Socket socket ) ;
}// S e r v e r
✡ ✠
Figure 15.32: The abstract Server class.
750 CHAPTER 15 •Sockets and Networking
☛ ✟
import java . net . ∗;
import java . io . ∗;
public a b s t r a c t c l a s s C l i e n t extends C l i e n t S e r v e r {
protected Socket socket ;
public C l i e n t ( S t r i n g url , i n t port ){
t r y{
socket = new Socket ( url , port ) ;
System . out . p r i n t l n ( ”CLIENT : connected to ” + u r l +
” : ” + port ) ;
}catch ( Exception e ) {
e . p r i n t S t a c k T r a c e ( ) ;
System . e x i t ( 1 ) ;
}// t r y / c a t c h b l o c k
}// C l i e n t ( )
public void run ( ){
t r y{
r e q u e s t S e r v i c e ( socket ) ;
socket . c l o s e ( ) ;
System . out . p r i n t l n ( ”CLIENT : connection closed ” ) ;
}catch ( IOException e ) {
System . out . p r i n t l n ( e . getMessage ( ) ) ;
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y / c a t c h b l o c k
}// r u n ( )
// I m p l e m e n t e d i n s u b c l a s s
protected a b s t r a c t void r e q u e s t S e r v i c e ( Socket socket )
throws IOException ;
protected S t r i n g readFromKeyboard ( ) throws IOException {
BufferedReader input = new BufferedReader
(new InputStreamReader ( System . in ) ) ;
System . out . p r i n t ( ”INPUT : ” ) ;
S t r i n g l i n e = input . readLine ( ) ;
return l i n e ;
}// r e a d F r o m K e y b o a r d ( )
}// C l i e n t
✡ ✠
Figure 15.33: The abstract Client class.
SECTION 15.9 •Playing One Row Nim Over the Network 751
☛ ✟
import java . net . ∗;
import java . io . ∗;
public c l a s s NimServer extends Server {
public NimServer ( i n t port , i n t backlog ) {
super ( port , backlog ) ;
}
protected void provideService ( Socket socket ) {
OneRowNim nim = new OneRowNim ( ) ;
t r y{
writeToSocket ( socket , ”Hi Nim player . You ’ re Player 1 and I ’m Player 2 . ” +
nim . reportGameState ( ) + ” ” + nim . getGamePrompt ( ) + ”\n”) ;
play ( nim , socket ) ;
}catch ( IOException e ) {
e . p r i n t S t a c k T r a c e ( ) ;
}// t r y /catch
}// provideService ( )
private void play (OneRowNim nim , Socket socket ) throws IOException {
NimPlayer computerPlayer = new NimPlayer ( nim ) ;
nim . addComputerPlayer ( computerPlayer ) ;
S t r i n g s t r = ””, response= ””;
i n t userTakes = 0 , computerTakes = 0 ;
do{
s t r = readFromSocket ( socket ) ;
boolean legalMove = f a l s e ;
do{
userTakes = I n t e g e r . p a r s e I n t ( s t r ) ;
i f( nim . t a k e S t i c k s ( userTakes ) ) {
legalMove = true ;
nim . changePlayer ( ) ;
response = nim . reportGameState ( ) + ” ” ;
i f( ! nim . gameOver ( ) ) {
computerTakes = I n t e g e r . p a r s e I n t ( computerPlayer . makeA Move( ””) ) ;
response = response + ” My turn . I take ” + computerTakes + ” s t i c k s . ” ;
nim . t a k e S t i c k s ( computerTakes ) ;
nim . changePlayer ( ) ;
response = response + nim . reportGameState ( ) + ” ” ;
i f( ! nim . gameOver ( ) )
response = response + nim . getGamePrompt ( ) ;
}// i f not game over
writeToSocket ( socket , response ) ;
}el s e{
writeToSocket ( socket , ” That ’ s an i l l e g a l move . Try again . \n”) ;
s t r = readFromSocket ( socket ) ;
}// i f user takes
}while ( ! legalMove ) ;
}while ( ! nim . gameOver ( ) ) ;
}// play
// Overriding writeToSocket to remove \n from s t r
protected void writeToSocket ( Socket soc , S t r i n g s t r ) throws IOException {
S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
for (i n t k = 0 ; k <s t r . length ( ) ; k++)
i f( s t r . charAt ( k ) != ’\n ’)
sb . append ( s t r . charAt ( k ) ) ;
super . writeToSocket ( soc , sb . t o S t r i n g ( ) + ”\n”) ;
}
public s t a t i c void main ( S t r i n g args [ ] ) {
NimServer server = new NimServer ( 1 0 0 0 1 , 5 ) ;
server . s t a r t ( ) ;
}// main ( )
}// NimServer
✡ ✠
Figure 15.34: The NimServer class.
Figure 15.34 provides a deﬁnition of the NimServer subclass. Note
how its implementation of provideService() uses an instance of
theOneRowNim class from Chapter 8. Also, the play() method,
which encapsulates the game-playing algorithm, uses an ins tance of
752 CHAPTER 15 •Sockets and Networking
NimPlayer , also from Chapter 8. You might recall that OneRowNim is
aTwoPlayerGame andNimPlayer deﬁnes methods that allow a com-
puter to play an optimal game of One Row Nim. In this example, th e
server acts as one of the players and use a NimPlayer to manage its play-
ing strategy. Thus, clients that connect to NimServer will be faced by a
computer that plays an optimal game.
If you compare the details of the NimServer ’splay() method with
theplay() method from the implementation of OneRowNim , you will
see that they are very similar. In this implementation, we use public
methods of the OneRowNim object to manage the playing of the game.
Thus,addComputerPlayer() adds an instance of NimPlayer to the
game. The takeSticks() ,changePlayer() , andgameOver() meth-
ods are used to manage the moves made by both itself and the cli ent. And
thegetGamePrompt() andreportGameState() methods are used to
manage the interaction and communication with the client. N ote also
that whenever it is the server’s turn to move, it uses the NimPlayer ’s
makeAMove() method to determine the optimal move to make.
Although the programming logic employed in the play() method
looks somewhat complex, it is very similar to the logic emplo yed in the
Chapter 8 version of the game. The main difference here is tha t the
server uses the writeToSocket() andreadFromSocket() methods
to manage the communication with the client. In this regard, t his instance
ofprovideService() is no different than the provideService()
method we used in the EchoServer class.
Finally, note that NimServer provides an implementation of the
writeToSocket() method. This method is implemented in the Overriding a method
ClientServer() class and is inherited by NimServer . However,
the default implementation assumes that the client will use the a car-
riage return ( \n) to determine the end of a particular message in
the socket. Because OneRowNim ’s methods, getGamePrompt() and
reportGameState() , contain embedded carriage returns, it is necessary
to ﬁlter these. The new version of writeToSocket() performs this ﬁl-
tering and calls the default method ( super.writeToSocket() , after it
has ﬁnished its ﬁltering task.
15.9.2 The NimClient Class
TheNimClient class is even easier to implement. As its task is sim-
ply to manage the communication between the human user and th e
NimServer , it is very similar to the requestService() method we
used in EchoClient . The relationship between the abstract Client class
(Fig. 15.33) and its extension in NimClient (Fig. 15.35) is very similar
to the relationship between Server andNimServer . The request-
Service() method is called by Client.run() . It is implemented in
NimClient . In this way, the Client class can serve as a superclass
for any number of clients. New clients for new services can be derived Creating new clients
fromClient by simply implementing their own requestService()
method.
SECTION 15.9 •Playing One Row Nim Over the Network 753
☛ ✟
import java . net . ∗;
import java . io . ∗;
public c l a s s NimClient extends C l i e n t {
private KeyboardReader kb = new KeyboardReader ( ) ;
public NimClient ( S t r i n g url , i n t port ){
super ( url , port ) ;
}
protected void r e q u e s t S e r v i c e ( Socket socket ) throws IOException {
S t r i n g s e r v S t r = readFromSocket ( socket ) ; // G e t s e r v e r ’ s r e s p o n s e
kb . prompt ( ”NIM SERVER : ” + s e r v S t r + ”\n”) ; // R e p o r t s e r v e r ’ s r e s p o n s e
i f( s e r v S t r . substring ( 0 , 6 ) . equals ( ”Hi Nim” ) ){
S t r i n g u s e r S t r = ””;
do{
u s e r S t r = kb . getKeyboardInput ( ) ; // G e t u s e r ’ s move
writeToSocket ( socket , u s e r S t r + ”\n”) ; // S e n d i t t o s e r v e r
s e r v S t r = readFromSocket ( socket ) ; // R e a d s e r v e r ’ s r e s p o n s e
kb . prompt ( ”NIM SERVER : ” + s e r v S t r + ”\n”) ; // R e p o r t r e s p o n s e
}while ( s e r v S t r . indexOf ( ”Game over ! ” ) ==−1); // U n t i l g a m e o v e r
}
}// r e q u e s t S e r v i c e ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
NimClient c l i e n t = new NimClient ( ” l o c a l h o s t ” , 1 0 0 0 1 ) ;
c l i e n t . s t a r t ( ) ;
}// m a i n ( )
}// N i m C l i e n t
✡ ✠
Figure 15.35: The derived NimClient class.
JAVA EFFECTIVE DESIGN Inheritance. By placing as much
functionality as possible into a generic client/server sup erclass, you
can simplify the creation of new services. This is an effecti ve use of
Java’s inheritance mechanism.
15.9.3 Testing the Nim Service
Testing the One Row Nim service will be no different than test ing the
Echo service. To test the service, you want to run both NimServer and
NimClient at the same time and preferably on different computers. As
they are presently coded, you will have to modify the main() methods
of both NimServer andNimClient to provide the correct URL and port
for your environment.
SELF-STUDY EXERCISE
EXERCISE 15.7 The design of the client/server hierarchy makes it easy
to create a new service by extending both the Server andClient classes.
Describe how you would implement a scramble service with thi s model.
754 CHAPTER 15 •Sockets and Networking
A scramble service can be used by people trying to solve the da ily scram-
ble puzzles found in many newspapers. Given a string of lette rs, the
scramble service will return a string containing all possib le letter com-
binations. For example, given “cat,” the scramble service w ill return “act
atc cat cta tac tca.”
EXERCISE 15.8 Describe what happens when each of the following
errors is introduced into the EchoClient orEchoServer programs:
•Specify the wrong host name when running EchoClient .
•Specify the wrong port number when running EchoClient .
•Remove the reference to \nin the writeToSocket() call in
requestService() .
15.10 Java Network Security Restrictions
One of the most attractive features of Java is that extensive effort has been
made to make it a secure language. This is especially important for a lan-
guage that makes it so easy to implement networking applicat ions. After
all, nobody wants to download a Java applet that proceeds to e rase the
hard disk. Such an applet might be written by a cyber terroris t, deliber-
ately aiming to cause severe damage, or it might be written by a cyber
doofus, who inadvertently writes code that does severe dama ge.
What are some of Java’s techniques for guarding against eithe r deliber-
ate or inadvertent insecure code? One level of security is Ja va’s bytecode Code veriﬁcation
veriﬁcation process, which the Java Virtual Machine performs on any “un-
trusted” code that it receives. Java checks every class that it loads into
memory to make sure it doesn’t contain illegal or insecure co de. Another
line of defense is the so-called sandbox security model , which refers to
the practice of restricting the kinds of things that certain programs can do.
For example, the “sandbox” environment for Java applets res tricts them Limited privileges
from having any access whatsoever to the local ﬁle system.
Another restriction imposed on applets is to limit their net working ca-
pabilities. For example, a Java applet cannot create a netwo rk connection
to any computer except the one from which its code was downloa ded.
Also, a Java applet cannot listen for, or accept, connection s on privileged Limited network access
ports—those numbered 1024 or lower. Together, these two rest rictions
severely limit the kinds of client/server programs that can be built as
applets.
Java sets aside certain locations as repositories for trusted code . For
example, the Java class libraries would be placed in such a lo cation, as
would the directories where your Java programs are stored. A ny class
loaded from some other directory is considered untrusted . By this def-
inition, applets downloaded over the Internet would be consi dered un-
trusted code.
In addition to the restrictions for applets, which apply to al l untrusted Trusted code
code, Java deﬁnes a number of other limitations:
•Untrusted code cannot make use of certain system facilities , such as
System.exit() and classes in the java.security package.
SECTION 15.11 •Java Servlets and Java Server Pages 755
•Untrusted code cannot make use of certain AWT methods, such as
methods that access the system clipboard. Another AWT restri ction
is that any window created by untrusted code must display a me s-
sage informing the user that it is untrusted. You might have s een such
messages on windows opened from applets.
•Untrusted code is limited in the kinds of threads it can creat e.
Security enhancements introduced in JDK 1.2 are based on the concepts
of “permission” and “policy.” Code is assigned “permission s” based on
the security policy currently in effect. Each permission sp eciﬁes the type
of access allowed for a particular resource (such as “read” a nd “write”
access to a speciﬁed ﬁle or directory, or “connect” access to a given host
and port). The policy that controls permissions can be initi alized from an
external conﬁgurable policy ﬁle. Unless a permission is exp licitly granted
to code, it cannot access the resource that is guarded by that permis-
sion. These new enhancements offer a more ﬁne-grained and ex tensible
approach to security for both applets and applications.
As this brief overview illustrates, the Java Virtual Machin e is designed
with security as one of its primary issues. This doesn’t guar antee 100 per-
cent security, but it is a big improvement over some of the lan guages and
systems that preceded Java. Moreover, security is an ongoin g concern
of the Java development process. Flaws in the existing secur ity system
are ﬁxed very quickly. Advanced methods are constantly bein g devel-
oped and incorporated into the system. One such enhancement is the
use of encryption to guarantee the integrity of classes tran sferred over the
network.
15.11 Java Servlets and Java Server Pages
In this chapter we have been discussing the client/server mod el of com-
puting. Thus far we have learned how to implement client/ser ver ap-
plications using socket connections between programs runn ing on differ-
ent computers. Because it requires the programmer to direct ly create and
manage the socket protocol, this socket-level approach is a low-level ap-
proach. It is important to know about sockets and how they are u sed, but
most client/server applications are programmed at a much hi gher level
by using Java library classes.
Our focus in this section will be to give you a brief sense of ho w Java
programs can be integrated into the Web pages. We will discus s two
approaches: Java Server Pages (JSP) and Java servlets . As Web-based ap-
proaches, both of these require the use of HTML (HyperText Mark up Lan-
guage) code, the language that is used for coding Web pages. T his means
that in order to write your own servlets and JSPs you would rea lly have to
learn a little about HTML code. Fortunately, learning HTML cod e is not
difﬁcult and although it doesn’t ﬁt within the scope of this b ook, you can
easily ﬁnd books or Web sites that cover basic HTML coding. Mor eover,
in order for servlets and JSPs to work, they must be associate d with a Web
server that is specially conﬁgured to understand Java code. At the end of
this section we will provide links to a Web site where you can l earn more
about HTML and about how to set up your own JSPs and servlets.
756 CHAPTER 15 •Sockets and Networking
15.11.1 Java Server Pages
A Java Server Page (JSP) is a Web page that contains small snip pets of
Java code. The simple example discussed here was downloaded from on
online tutorial at
☛ ✟
http : //developer . apple . com/ i n t e r n e t /java/tomcat1 . html
✡ ✠
The Java code on a JSP embedded within <% ... %> brackets and inter-
spersed among a page’s HTML tags. The Java code can extend over one
or more lines. Figure 15.36 shows the complete sourcecode fo r a simple
JSP .
☛ ✟
<html><head><t i t l e>Very Simple JSP Example </t i t l e></head>
<body bgcolor= ” white ” >
<h1>Very Basic JSP </h1>
Current time : <%=new java . u t i l . Date ( ) % >
<br><br>
Reload t h i s page to watch the g r e e t i n g change .
<br><br><b>
<!−− including l i n e s of Java code in an HTML page −−>
<%
i n t um = ( i n t) ( Math . random ( ) ∗5 ) ;
switch ( um )
{
case 0 : out . p r i n t l n ( ”Welcome” ) ;break ;
case 1 : out . p r i n t l n ( ” Bienvenidos ” ) ;break ;
case 2 : out . p r i n t l n ( ”Bienvenue” ) ;break ;
case 3 : out . p r i n t l n ( ” Bienvenuti ” ) ;break ;
case 4 : out . p r i n t l n ( ”Willkommen” ) ;break ;
default : out . p r i n t l n ( ”Huh? ” + um) ;
}
out . p r i n t l n ( ”<br>”) ;
%>
</b>
</body>
</html>
✡ ✠
Figure 15.36: A simple JavaServer Page (JSP).
In this example we see two uses of Java code. In the ﬁrst case, a JS P
expression tag is used to display the current date on the Web p age:
☛ ✟
Current time : <%=new java . u t i l . Date ( ) % >
✡ ✠
A JSP expression element begins with <%= and ends with %>. The expres-
sion contained within the tag is evaluated, converted into a JavaString
SECTION 15.11 •Java Servlets and Java Server Pages 757
Figure 15.37: A screen shot of a
JSP .
and inserted into the Web page. In this case the Date object is evaluated
and its string value is displayed on the Web page (Fig. 15.37) .
In the second case, a scriptlet of Java code uses the Math.random()
method to display a random greeting on the Web page. A scriptlet extends
over several lines and is contained within the <%...%> tag (Fig. 15.36).
Note the use of the output statement, out.println() . Theout object is
a built-in output stream. Anything written to out will be transmitted as
part of the HTML code that is sent to the Web page. In this case, on e of
the greetings is displayed each time the page is reloaded.
Obviously, this simple example only scratches the surface o f what you
can do with JSP . If you want to learn more about JSP , there are ma ny help-
ful online tutorials available, such as http://www.jsptut.com/ . How-
ever, remember that in order to experiment with JSP , it will b e necessary
to have access to a JSP-aware Web server either on your own com puter or
on one provided by your service provider.
15.11.2 Java Servlets
A Java servlet is another high-level approach to developing client/serve r
applications. A servlet is a Java program that runs on a Web server and
processes Web pages using the HyperText Transfer Protocol (HT TP). In a
Web application, the browser serves as the client.
Many URLs that we access on the web are pure HTML ﬁles that are
simply transmitted back to the browser by the Web server. For example,
the URL for a simple HTML document on the author’s Web site is:
☛ ✟
http : // w w w. cs . t r i n c o l l . edu/˜ram/ j j j / h e l l o . html
✡ ✠
758 CHAPTER 15 •Sockets and Networking
If you type that URL into a Web browser, the Web server at
www.cs.trincoll.edu would transmit the following text ﬁle to your
browser, which would then render and display the document.
☛ ✟
<HTML>
<HEAD>
<TITLE>Very Simple HTML Document </TITLE>
</ HEAD>
<BODY>
<CENTER><H1>Hello</H1></ CENTER >
</BODY>
</ HTML>
✡ ✠
If we want the server to do some processing and submit the resul ts of
that processing to the browser, we could use a Java servlet. A servlet can
perform some processing task and return the results of that t ask to the
browser in the form of an HTML document.
The difference between a Java servlet and a Java applet is tha t an applet Servlets vs. Applets
performs all of its processing on the client side of the clien t/server connec-
tion. A servlet performs its processing on the server side. Wh en you load
a Java applet into a browser, the Web server downloads the app let’s byte-
code into the browser. The browser then runs the byte code, as suming, of
course, it is equipped with a plugin for the Java Virtual Mach ine (JVM).
When you access a Java servlet from a browser, the Web server pe rforms
some computation and transmits just the results to the browse r.
There are several advantages of servlets over applets. Firs t, servlets cut
down signiﬁcantly on the amount of data that has to be transmi tted to
the browser. Second, because the servlet returns an HTML-enc oded page,
there are many fewer platform-related problems. All browse rs can inter-
pret HTML code, but not all browsers have the right plugins for interpret-
ing Java applets. Third, servlets are not subject to the same s ecurity and
privacy restrictions as Java applets, which, as we saw earli er in the chap-
ter, must be run as untrusted code. Finally, Java servlets ca n directly access
large databases and other resources that are stored on the se rver. Access
to such resources via an applet would be very difﬁcult and ine fﬁcient.
So, servlets have many advantages over applets. Because of t hese ad-
vantages they have quickly become an industry standard for d eveloping
client/server applications on the Web.
15.11.3 A Simple Servlet Example
To illustrate the difference between a Java servlet and a sim ple HTML
page, Figure 15.38 shows a servlet that creates a Web page tha t says
“Hello.” As you can see, a servlet is a Java program. In addi-
tion to libraries that you are already familiar with, such as java.io ,
it also imports names from two new libraries: javax.servlet and
javax.servlet.http . The program deﬁnes a single class, the
HelloServlet class, which is a subclass of HttpServlet , the standard
superclass for all Java servlets.
SECTION 15.11 •Java Servlets and Java Server Pages 759
☛ ✟
import java . io . ∗;
import java . t e x t . ∗;
import java . u t i l . ∗;
import javax . s e r v l e t . ∗;
import javax . s e r v l e t . http . ∗;
public c l a s s H e l l o S e r v l e t extends HttpServlet {
public void doGet ( HttpServletRequest request ,
HttpServletResponse response )
throws IOException , S e r v l e t E x c e p t i o n
{
response . setContentType ( ” t e x t /html” ) ;
P r i n t W r i t e r out = response . getWriter ( ) ;
out . p r i n t l n ( ”<HTML>”) ;
out . p r i n t l n ( ”<HEAD>”) ;
out . p r i n t l n ( ”<TITLE>Simple S e r v l e t </TITLE>”) ;
out . p r i n t l n ( ”</ HEAD>”) ;
out . p r i n t l n ( ”<BODY>”) ;
out . p r i n t l n ( ”<H1>Hi , from a Java S e r v l e t . </H1>”) ;
out . p r i n t l n ( ”</ BODY>”) ;
out . p r i n t l n ( ”</ HTML>”) ;
}
}
✡ ✠
Figure 15.38: A simple Java servlet.
The servlet deﬁnes the doGet() method. This is a method that is de-
ﬁned in the HttpServlet superclass. Our HelloServlet is overriding
that method. In general, Web browsers make two types of reques ts when
they request a Web page, a getor a post . We won’t go into the differences
between these requests. The result in either case is that the Web server
will respond to the request by transmitting some text data to the browser.
When a browser makes a get request, the server will automatica lly call
the servlet’s doGet() method. That’s why we have to override it. The
HttpServlet class also has a default doPost() method, which is called
automatically to handle post requests.
Note the two parameters in the doGet() method: the HttpServlet-
Request and the HttpServletResponse . ThedoPost() method has
the same two parameters. These are the objects that are used to hold the
data that are communicated between the client and the server . When the
client (browser) makes a get request, the HttpServletRequest objects
hold the data contained in the request. These data might incl ude data that
a user has typed into an HTML form. We will see an example of how t o
extract these data in the next section.
TheHttpServletResponse object is where the servlet will write its
response. As you can see from examining the code, the HttpServlet-
Response object has an associated output stream, a PrintWriter , and
it is a simple matter to write text to that output stream. Note that the text
760 CHAPTER 15 •Sockets and Networking
we write is HTML code that is practically identical to the code contained
in the previous HTML example.
15.11.4 The Nim Servlet
The simple servlet in the preceding section illustrates how the servlet com-
municates with the client—by writing HTML code to the HttpServlet-
Response object. Let’s now look at an example that uses two-way com-
munication between the client and server. To keep the exampl e simple,
we will revisit once again on our One Row Nim game. In this appli cation
the servlet will manage the One Row Nim game and will play agai nst a
human player, who will access the game through a Web browser.
Figure 15.39: The interface for the
Nim servlet.
The browser interface for this version of the game is shown in Fig-
ure 15.39. As you can see, it is a simple Web page. The sticks in this
SECTION 15.11 •Java Servlets and Java Server Pages 761
☛ ✟
import java . io . ∗;
import java . u t i l . ∗;
import javax . s e r v l e t . ∗;
import javax . s e r v l e t . http . ∗;
public c l a s s NimServlet extends HttpServlet {
private OneRowNim nim = null ;
private NimPlayer nimPlayer = null ;
public void doPost ( HttpServletRequest request ,
HttpServletResponse response )
throws IOException , S e r v l e t E x c e p t i o n
{
doGet ( request , response ) ;
}
// T h e d o G e t ( ) m e t h o d g o e s h e r e .
}// N i m S e r v l e t
✡ ✠
Figure 15.40: Java code for the NimServlet , minus the doGet() method.
instance are replaced by pennies. In addition to reporting th e total num-
ber of pennies left, the page displays images of pennies. Thi s Web page
itself is organized as a simple HTML form, which contains one t ext ﬁeld
for the user’s input. Each time the user hits the RETURN key in the text
ﬁeld, the user’s input is transmitted to the servlet where it is processed.
The servlet then transmits a new page to the user’s browser, w hich shows
the updated state of the game.
Let’s now look at the servlet program itself, whose code is sh own in
Figures 15.40 and 15.41. This servlet program is quite a bit l onger than
the simple hello server, but it is not really any more complex or difﬁcult.
TheNimServlet extends the HttpServlet superclass and overrides
thedoGet() method. Note that it also overrides the doPost() method,
by simply having that method call the doPost() method. So this servlet
will work for both getand post requests.
NimServlet uses two other objects: a OneRowNim object and a
NimPlayer object. You should be familiar with these from Chapter 8,
so we won’t go over their internal details here. The OneRowNim object
manages the playing of the game and the NimPlayer object acts as a
computer-based player of the game. Note that variable refer ences for
these two objects are declared in the beginning of the class de ﬁnition, but
the objects themselves are declared within the doGet() method.
One of the tricky parts of NimServlet is how we declare the
OneRowNim object. As you might already know, the HTTP protocol is
said to be a stateless protocol, which means that each time a browser sub-
mits a request to a Web server, the Web server sees the request as a com-
pletely independent communication. The server does not, in and of itself,
maintain an internal state that keeps track of a series of tra nsactions with
762 CHAPTER 15 •Sockets and Networking
☛ ✟
public void doGet ( HttpServletRequest request , HttpServletResponse response )
throws IOException , S e r v l e t E x c e p t i o n
{
response . setContentType ( ” t e x t /html” ) ;
P r i n t W r i t e r out = response . getWriter ( ) ;
HttpSession s e s s i o n = request . getSession ( true ) ;
out . p r i n t l n ( ”<html>”) ;
out . p r i n t l n ( ”<body>”) ;
out . p r i n t l n ( ”<head>”) ;
out . p r i n t l n ( ”<t i t l e>Simple Nim Game </t i t l e>”) ;
out . p r i n t l n ( ”</head>”) ;
out . p r i n t l n ( ”<body>”) ;
out . p r i n t l n ( ”<center> <h1>One Row Nim </h1></center >”) ;
out . p r i n t l n ( ”<center> <h3>The Rules </h3>”) ;
out . p r i n t l n ( ”A random number of pennies i s thrown on the t a b l e . <BR>”) ;
out . p r i n t l n ( ”Two players a l t e r n a t e making moves, <BR>”) ;
out . p r i n t l n ( ” picking up between 1 and 3 pennies on each move. <BR>”) ;
out . p r i n t l n ( ”The player who picks up the l a s t penny l o s e s . <BR> <BR>”) ;
i f( nim == null ){
nim = new OneRowNim(7 + ( i n t) ( Math . random ( ) ∗1 1 ) ) ;
nimPlayer = new NimPlayer ( nim ) ;
out . p r i n t l n ( ”<h4>You go f i r s t ! </h4></center >”) ;
}el s e{
i n t userTakes = I n t e g e r . p a r s e I n t ( request . getParameter ( ”pickup” ) ) ;
i f( ! nim . t a k e S t i c k s ( userTakes ) ) {
out . p r i n t l n ( ”<h4> <font c o l o r = ’ red’ >Woops . That ’ s an i l l e g a l move ! . Try again . </font> <h4>”) ;
}el s e i f ( ! nim . gameOver ( ) ) {
nim . changePlayer ( ) ;
out . p r i n t l n ( ”<h4>So , you took <font c o l o r = ’ blue’ >”+ userTakes + ”</font> <BR>”) ;
out . p r i n t l n ( ” That leaves me with <font c o l o r = ’ blue’ >”+ nim . g e t S t i c k s ( ) + ”</font> <BR>”) ;
i n t iTake = nimPlayer . move ( ) ;
out . p r i n t l n ( ”OK. I take <font c o l o r = ’ red’ >”+ iTake + ”</font>pennies. <BR></h4>”) ;
nim . t a k e S t i c k s ( iTake ) ;
nim . changePlayer ( ) ;
}// i f not gameover
}// e l s e nim != n u l l
i f( ! nim . gameOver ( ) ) {
i f( nim . getPlayer ( ) == 1)
out . p r i n t l n ( ”<center> <h3>Who ’ s Turn : <font c o l o r = ’ magenta’ >Your turn </font> <h3></center >”) ;
el s e
out . p r i n t l n ( ”<center> <h3>Who ’ s Turn : <font c o l o r = ’ magenta’ >My turn </font> <h3></center >”) ;
out . p r i n t l n ( ”<center> <h3>Pennies L e f t : <font c o l o r = ’ red’ >”+ nim . g e t S t i c k s ( ) + ”</font> <h3></center >”) ;
out . p r i n t l n ( ”<center>”) ;
for (i n t k =0; k <nim . g e t S t i c k s ( ) ; k++)
out . p r i n t l n ( ”<img s r c = ’ http :// xroads . v i r g i n i a . edu/˜CAP/LINCOLN/cen t . jpg ’ width = ’25 ’ height =’25’ >”) ;
out . p r i n t l n ( ”</center > <br>”) ;
out . p r i n t l n ( ”<center>”) ;
out . p r i n t l n ( ”<form a c t i o n =’/ j j j 3 e /NimServlet ’ method= ’POST’ >”) ;
out . p r i n t l n ( ”<t a b l e border =’0’ >”) ;
out . p r i n t l n ( ”<tr> <td>How many do you pickup ? : </td>”+
”<td> <input type = ’ t e x t ’ name= ’ pickup ’ value=’0’ ></td></tr>”) ;
out . p r i n t l n ( ”</table>”) ;
out . p r i n t l n ( ”</center >”) ;
out . p r i n t l n ( ”</form>”) ;
}el s e{
out . p r i n t l n ( ”<h3> <font c o l o r = ’ red’ >Game over! </font> <h3>”) ;
i f( nim . getPlayer ( ) == 1)
out . p r i n t l n ( ”<center> <h4>And the winner i s : <font c o l o r = ’ magenta’ >Me.</font> <h4></center >”) ;
el s e
out . p r i n t l n ( ”<center> <h4>And the winner i s : <font c o l o r = ’ magenta’ >You.</font> <h4></center >”) ;
out . p r i n t l n ( ”<center> <h4> <font c o l o r = ’ magenta’ >Nice game! </font> <h4></center >”) ;
out . p r i n t l n ( ”<center> <h4>To play again , j u s t reload the page. <h4></center >”) ;
nim = null ;
}// e l s e game over
out . p r i n t l n ( ”</body>”) ;
out . p r i n t l n ( ”</html>”) ;
}// doGet
✡ ✠
Figure 15.41: Java code for the NimServlet ’sdoGet() method.
SECTION 15.11 •Java Servlets and Java Server Pages 763
a particular browser session. For example, when you are shop ping for
books on Amazon, each time you go to a new page, the Amazon web
server treats that request as a completely independent acti on. Web appli-
cations use various techniques to get around the stateless n ature of the
HTTP protocol. One technique is to use cookies to record the progress of a
session. A cookie is a small text ﬁle containing data that the server uses to
keep track of a user’s session. Data that identiﬁes the user a nd the state of
the transaction—for example, buying a book—are passed back an d forth
between the browser and the server each time the user visits t he Amazon
Web site.
Java’s servlet library contains methods and objects that sup port the use
of cookies. But rather than use cookies, we will use the OneRowNim ob-
ject itself to keep track of the state of the Nim game. The ﬁrst t ime the
user submits a request to Nim servlet—that is, when the user ﬁr st visits
the servlet’s URL—the servlet will create an instance of the OneRowNim
object. Creating a OneRowNim object will have the effect of initializing the
game, including the creation of a NimPlayer to play the server’s moves.
TheOneRowNim object will persist throughout the playing of the game
and will handle all subsequent user’s move. When the game is ov er, the
NimServlet will, in effect, dispose of the OneRowNim object by setting
its reference to null . Thus, in outline form, the code for creating and
disposing of the OneRowNim object goes as follows:
☛ ✟
// F i r s t r e q u e s t : S t a r t a new Nim g a m e
i f( nim == null ){
nim = new OneRowNim(7 + ( i n t) ( Math . random ( ) ∗1 1 ) ) ;
nimPlayer = new NimPlayer ( nim ) ;
// C o d e d e l e t e d h e r e .
else{
// C o d e f o r p l a y i n g t h e g a m e g o e s h e r e .
}
i f( ! nim . gameOver ( ) ) {
// C o d e f o r p l a y i n g t h e g a m e g o e s h e r e .
}else{
// C o d e d e l e t e d h e r e .
nim = null ;
}
✡ ✠
Those places where code has been deleted in this segment woul d con-
tain Java code for responding to the user’s input and decidin g how many
pennies to take.
Unlike the HelloServlet , theNimServlet accepts input from the
client. The code for handling user input is as follows:
☛ ✟
i n t userTakes =
I n t e g e r . p a r s e I n t ( request . getParameter ( ”pickup” ) ) ;
✡ ✠
This statements reads the user’s input from the text ﬁeld on t he Web page
by using the request.getParameter() method. This is one of the
public methods of the HttpServletRequest object. The name of the
text ﬁeld is ’pickup’, which is provided as an argument in thi s method
764 CHAPTER 15 •Sockets and Networking
call. As we noted above, the text ﬁeld itself is on element of t he HTML
form contained in the servlet’s Web page. The HTML code for cre ating
the form element is also generated by the servlet:
☛ ✟
out . p r i n t l n ( ”<form a c t i o n =’/ j j j 3 e /NimServlet ’ method= ’POST’ >”) ;
out . p r i n t l n ( ”<t a b l e border =’0’ >”) ;
out . p r i n t l n ( ”<tr><td>How many do you pick up ? : </td>”+
”<td><input type = ’ t e x t ’ name= ’ pickup ’ value=’0’ ></td></tr>”) ;
✡ ✠
Unless you already know something about HTML, you won’t compl etely
understand this code. We will give a minimal explanation. In HT ML, a
text ﬁeld is known as a input element of type ’text’. Note that this code
segment names the element ’pickup’, which allows our progra m to refer
to it by that name.
The remaining details in the servlet have to do with managing the game
and repeat concepts that were covered in Chapter 8. We won’t r epeat them
here, other than to note that any output sent to the client mus t be in the
form of HTML statements, hence the appearance throughout the code of
HTML tags, which are the elements in the angle brackets.
15.11.5 Setting Up and Using Java Servlets
Java servlets can only run on a Web server that is specially co nﬁgured to
interpret them. To experiment with the servlets discussed i n this chapter,
just go to the following URL:
☛ ✟
http : // w w w. cs . t r i n c o l l . edu/˜ram/ j j j / s e r v l e t s
✡ ✠
That web page contains links to both the HelloServlet andNimServlet .
It also contains links to Web sites where you can learn more abo ut creat-
ing servlets. In order to create and run your own servlets, you will need
access to a Web server that has been specially conﬁgured to ru n servlets.
There are several very good free servers that support Java se rvlets. You
can download one of these onto your own computer and follow th e direc-
tions on how to set it up. Links to Java servlet sites are also p rovided on
our servlets page.
CHAPTER SUMMARY Technical Terms
busy waiting
callback method
client
client/server
protocols
domain name
ethernet protocolFile Transfer Protocol
(FTP)
get
HyperText Transfer
Protocol (HTTP)
internet
InternetInternetworking
Protocol (IP)
Java Server Page
(JSP)
packet
port
post
protocol
CHAPTER 15 •Solutions to Self-Study Exercises 765
router
sandbox security
model
scriptlet
serverservlet
Simple Mail Transfer
Protocol (SMTP)
socket
trusted codeUniform Resource
Locator (URL)
World Wide Web
(WWW)
Summary of Important Points
•Aninternet is a collection of two or more distinct networks joined by
routers , which have the task of translating one network’s language t o
the other’s. The Internet is a network of networks that uses the Internet
Protocol (IP) as the translation medium.
•Aprotocol is a set of rules that controls the transfer of information
between two computers in a network. The HyperText Transfer Pro-
tocol (HTTP) governs information exchange on the World Wide Web
(WWW). The Simple Mail Transfer Protocol controls mail service on the
Internet. The File Transfer Protocol (FTP) controls the transfer of ﬁles
between Internet computers. The Domain Name System (DNS) governs
the use of names on the Internet.
•Aclient/server application is one that divides its task between a client,
which requests service, and a server, which provides servic e. Many In-
ternet applications and protocols are based on the client/s erver model.
•Lower-level protocols, such as the ethernet protocol and token ring pro-
tocol , govern the transmission of data between computers on a sing le
network. The Internet Protocol (IP) translates between such protocols.
•AUniform Resource Locator (URL) is a standard way of specifying
addresses on the Internet. It consists of several parts separa ted
by slashes and colons: method://host:port/path/file . The
java.net.URL class is used to represent URLs.
•Files of text or data (images, audio ﬁles) on the Internet or We b can be
downloaded using the same InputStream s andOutputStream s as
ﬁles located on a disk. To read or write a resource located on a network,
you need to connect its URL to an input or output stream.
•Thejava.awt.Toolkit class contains useful methods for down-
loading Image s into an application.
•Asocket is a two-way communication channel between two running
programs on a network. The java.net.Socket class can be used
to set up communication channels for client/server applica tions. The
server process listens at a socket for requests from a client. The client
process requests service from a server listening at a partic ular socket.
Once a connection exists between client and server, input an d output
streams are used to read and write data over the socket.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 15.1 The fully connected mesh topology requires the most cables.
SOLUTION 15.2 The fully connected mesh topology would have the most po-
tential to use alternate routes if one of the host computers crashe d.
SOLUTION 15.3 The star topology would be rendered completely useless if its
central hub crashed.
766 CHAPTER 15 •Sockets and Networking
SOLUTION 15.4 Prentice Hall’s Web server is located at
☛ ✟
http : // w w w. prenhall . com
✡ ✠
The protocol is http . The host computer is named www. Prentice Hall’s domain
name is prenhall , and it is part of the com (commercial) Internet domain.
SOLUTION 15.5
•For buying a piece of software at a bookstore, the server would be the s ales
clerk. The protocol would be to select the software from off the shelf , bring it to
the checkout counter, give the sales clerk money, and get a recei pt.
•For buying a piece of software over the phone, the server would be the tele-
phone sales clerk. The protocol would be to select from a catalog, prov ide the
sales clerk with your credit card information, and say goodbye.
•For buying a piece of software over the Internet, the server would b e the
computer that handles the transaction. The protocol would be to sel ect the
item from a Web-based form, provide the form with personal and paym ent
information, and click on the Buy button.
SOLUTION 15.6 To play sounds along with slides in the SlideShowApplet ,
you would make the following modiﬁcations to the code:
☛ ✟
private URL soundURL [ ] = new URL[NIMGS ] ;
✡ ✠
Declare an array of URLs to store the URLs of the audio ﬁles you want to play.
Assign URLs to the array at the same time you input the images:
☛ ✟
for (i n t k =0; k <NIMGS; k++) {
u r l =
new URL( ” http ://w w w. cs . t r i n c o l l . edu/˜ram/ j j j / s l i d e ” +
k + ” . g i f ” ) ;
s l i d e [ k ] = getImage ( u r l ) ;
soundURL [ k ] =
new URL( ” http ://w w w. cs . t r i n c o l l . edu/˜ram/ j j j /sound” +
k + ” . au” ) ;
}
✡ ✠
Each time an image is displayed in paint() , play the corresponding sound by
using the URL from the array:
☛ ✟
public void paint ( Graphics g ) {
i f( currentImage != null ){
g . drawImage ( currentImage , 1 0 , 1 0 , t h i s ) ;
play ( soundURL [ currentImage ] ) ;
}
}
✡ ✠
SOLUTION 15.7 The scramble service would be implemented by deﬁning two
new classes: The ScrambleServer class is a subclass of Server , and the
ScrambleClient class is a subclass of Client . TheScrambleClient would
implement the requestService() method and the ScrambleServer would
implement the provideService() method.
SOLUTION 15.8
CHAPTER 15 •Exercises 767
•If you specify the wrong host name or port, you will get the following ex cep-
tion:java.net.ConnectException: Connection refused .
•If you leave off the \nin thewriteToSocket() call, nothing will go wrong
because the writeToSocket() method will catch this error and add the end-
of-line character to the string before sending it to the server . The server reads
lines from the client, so every communication must end with \nor the protocol
will break down.
EXERCISES EXERCISE 15.1 Explain the difference between each of the following pairs of
terms:
a.Stream and socket .
b.Internet and internet .
c.Domain name and port.d.Client and server .
e.Ethernet and Internet .
f.URL and domain name . Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 15.2 What is a protocol ? Give one or two examples of protocols that
are used on the Internet.
EXERCISE 15.3 What service is managed by the HTTP protocol?
EXERCISE 15.4 Give examples of client applications that use the HTTP
protocol.
EXERCISE 15.5 Why is it important that applets be limited in terms of their
network and ﬁle system access? Describe the various networking restrictions that
apply to Java applets.
EXERCISE 15.6 What does the Internet Protocol do? Describe how it
would be used to join an ethernet and a token ring network.
EXERCISE 15.7 Describe one or two circumstances under which a Connect-
Exception would be thrown.
EXERCISE 15.8 Modify the SlideShowApplet so that it plays an audio ﬁle
along with each slide.
EXERCISE 15.9 Design and implement a Java applet that downloads a random
substitution cryptogram and provides an interface that helps t he user try to solve
the cryptogram. The interface should enable the user to substi tute an arbitrary
letter for the letters in the cryptogram. The cryptogram ﬁles sh ould be stored in
the same directory as the applet itself.
EXERCISE 15.10 Design and implement a Java application that displays a ran-
dom message (or a random joke) each time the user clicks a GetMessage button.
The messages should be stored in a set of ﬁles in the same directory as the applet
itself. Each time the button is clicked, the applet should downl oad one of the
message ﬁles.
EXERCISE 15.11 Write a client/server application of the message or joke ser-
vice described in the previous exercise. Your implementation s hould extend the
Server andClient classes.
EXERCISE 15.12 Write an implementation of the scramble service. Given a
word, the scramble service will return a string containing all possible permuta-
tions of the letter combinations in the word. For example, given “ma n,” the scram-
ble service will return “amn, anm, man, mna, nam, nma.” Use th eServer and
Client classes in your design. (See the Self-Study Exercises for a descri ption of
the design.)
EXERCISE 15.13 Challenge: Modify the Nim server game in this chapter so
that the client and server can negotiate the rules of the game, i ncluding how many
sticks, how many pick ups per turn, and who goes ﬁrst.
768 CHAPTER 15 •Sockets and Networking
OBJECTIVES
After studying this chapter, you will
•Understand the concepts of a dynamic data structure and an Ab stract Data Type (ADT).
•Be able to create and use dynamic data structures such as link ed lists and binary search trees.
•Understand the stack, queue, set, and map ADTs.
•Be able to use inheritance to deﬁne extensible data structur es.
•Know how to use the TreeSet, TreeMap, HashSet, and HashMap libr ary classes.
•Be able to use the Java generic type construct.
OUTLINE
16.1 Introduction
16.2 The Linked List Data Structure
16.3 Object-Oriented Design: The List Abstract Data Type (AD T)
16.4 The Stack ADT
16.5 The Queue ADT
Special Topic: The LISP Language
16.6 From the Java Library: The Java Collections Framework a nd Generic Types
16.7 Using the Set andMap interfaces
16.8 The Binary Search Tree Data Structure
Chapter Summary
Solutions to Self-Study Exercises
ExercisesChapter 16
Data Structures: Lists,
Stacks, and Queues
769
770 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
16.1 Introduction
Adata structure is used to organize information that a computer can ac-
cess and process easily and efﬁciently. You are already fami liar with one
type of data structure—arrays, which we discussed in Chapter 9. If you
remember, an array is an example of a data structure in which a ll of the
data are of the same type or class and in which individual elem ents are ac-
cessed by their position (index or subscript). An array is an example of a
static structure , because its size is ﬁxed for the duration of the program’s
execution. (This is a different meaning of static than the Java keyword
static .)
TheVector class from Chapter 9 is another example of a data struc-
ture. Like an array, individual vector elements are accesse d by their po-
sition. However, unlike arrays, a vector is an example of a dynamic
structure —that is, one that can grow and shrink during a program’s exe-
cution.
These are only two of the many data structures developed by co mputer
scientists. For more advanced problems, it is often necessa ry to develop
specialized structures to store and manipulate informatio n. Some of these
structures—linked lists, stacks, queues, binary trees, has h tables—have
become classic objects of study in computer science.
This chapter describes how to implement a linked list and how to use
inheritance to extend the list to implement the stack and que ue struc-
tures. Then the Java Collections Framework implementation of numerous
data structures in the java.util package will be described. The data
structure classes in this library make use of a new Java const ruct, called
generic types . Finally, the binary tree data structure that is used in the J ava
Collections Framework will be studied brieﬂy.
16.2 The Linked List Data Structure
As we said, a static data structure is one whose size is ﬁxed during a Static vs. dynamic
program’s execution—a static structure’s memory is allocat ed at compile
time. By contrast, a dynamic structure is one that can grow and shrink as
needed. In this section, we will develop a dynamic list, which is a data
structure whose elements are arranged in a linear sequence. There is a
ﬁrst element in the list, a second element, and so on. Lists ar e quite gen-
eral and, as we will discuss later, lists have a broad range of applications.
Depending on how elements are inserted and removed from a lis t, they
can be used for a range of specialized purposes.
16.2.1 Using References to Link Objects
As you know from earlier chapters, when you create an object us ing the
new operator you get back a reference to the object that you then can assign Referring to objects
to a reference variable. In the following example, bis a reference to a
JButton :
☛ ✟
JButton b = new JButton ( ) ;
✡ ✠
SECTION 16.2 •The Linked List Data Structure 771
Node Data Link Reference Null reference
Abby John KellyFigure 16.1: A linked list of Node s
terminated by a null link.
We have deﬁned many classes that contained references to oth er objects:
☛ ✟
public c l a s s Student {
private S t r i n g name ;
}
✡ ✠
In this example, name is a reference to a String object.
Alinked list is a list in which a collection of nodes are linked together
by references from one node to the next. To make a linked list, we will de-
ﬁne a class of self-referential objects. A self-referential object is an object Self-referential objects
that contains a reference to an object of the same class. The co nvention is
to name these objects Node s:
☛ ✟
public c l a s s Node{
private S t r i n g name ;
private Node next ;
}
✡ ✠+Node(in o : Object)
+setData(in o : Object)
+getData() : Object
+setNext(in link : Node)
+getNext() : Node-data : Object
-next : NodeNode
FIGURE 16.2 TheNode class.In addition to the reference to a String object, each Node object contains
a reference to another Node object. The next variable is often called a
link because it is used to link together two Node objects. For example,
Figure 16.1 provides an illustration of a linked list of Node s.
By assigning references to the next variables in each Node , we can
chain together arbitrarily long lists of objects. Therefore , we will want to
add methods to our Node class that enable us to manipulate a Node ’s next
variable (Fig. 16–2). By assigning it a reference to another Node , we can
link two Node s together. By retrieving the link’s value, we can ﬁnd the
nextNode in the list.
JAVA LANGUAGE RULE Self-Referential Object. Aself-referential
object is one that contains an instance variable that refers to an ob ject of
the same class.
In addition to the link variable, each Node stores some data. In this exam-
ple, the data is a single String . But there’s no real limit to the amount
and type of data that can be stored in a linked list. Therefore , in addition Linking objects together
to methods that manipulate a Node ’s link, we will also want methods to
772 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
manipulate its data. These points suggest the following bas ic design for a
Node :
☛ ✟
public c l a s s Node{
private Object data ;
private Node next ;
public Node( Object obj ) ; // C o n s t r u c t o r
public void setData ( Object obj ) ; // D a t a a c c e s s
public Object getData ( ) ;
public void setNext (Node l i n k ) ; // L i n k a c c e s s
public Node getNext ( ) ;
}// Node
✡ ✠
Note that we have deﬁned the Node ’s data in the most general possible
way: As a reference to an Object . Because the Object class is the root of
Java’s entire class hierarchy, an Object can encompass any kind of data.
By using Java’s wrapper classes, such as Integer andDouble , aNode ’s
data can even include primitive data.
The important point is that regardless of its type of data, a Node will
have data access methods and link access methods. The data ac cess meth- Divide and conquer
ods differ, depending on the type of data, but the link access methods will
generally be the same.
JAVA EFFECTIVE DESIGN Link Versus Data. Making a clear
distinction between an object’s data and those elements used to
manipulate the object is an example of the divide-and-conque r
principle.
SELF-STUDY EXERCISES
EXERCISE 16.1 Write a statement to create a new Node whose data
consist of the String “Hello.”
EXERCISE 16.2 Write a statement to create a new Node whose data
consist of the Student named “William.” Assume that the Student class
has a constructor with a String parameter for the student’s name.
16.2.2 Example: The Dynamic Phone List
Let’s deﬁne a PhoneListNode class that can be used to implement a
phone list (Fig. 16.3). This deﬁnition will be a straightfor ward specializa-
tion of the generic Node list deﬁned in the previous section. Each element
of the phone list will consist of a person’s name and phone num ber. These
will be the node’s data and can be stored in two String variables. To
access these data, we will provide a constructor and a basic s et of access Accessing a list’s data
methods. Thus, we have the deﬁnition shown in Figure 16.4.
SECTION 16.2 •The Linked List Data Structure 773
+PhoneListNode(in name : String, in phone : String)
+setData(in name : String, in phone : String)
+getName() : String
+getData() : String
+toString() : String
+setNext(in next : PhoneListNode)
+getNext() : PhoneListNode-name : String
-phone : String
-next : PhoneListNodePhoneListNode Figure 16.3: Design of the
PhoneListNode class.
☛ ✟
public c l a s s PhoneListNode {
private S t r i n g name ;
private S t r i n g phone ;
private PhoneListNode next ;
public PhoneListNode ( S t r i n g s1 , S t r i n g s2 ) {
name = s1 ;
phone = s2 ;
next = null ;
}// P h o n e L i s t N o d e ( )
public void setData ( S t r i n g s1 , S t r i n g s2 ) {
name = s1 ;
phone = s2 ;
}// s e t D a t a ( )
public S t r i n g getName ( ) {
return name ;
}// g e t N a m e ( )
public S t r i n g getData ( ) {
return name + ” ” + phone ;
}// g e t D a t a ( )
public S t r i n g t o S t r i n g ( ) {
return name + ” ” + phone ;
}// t o S t r i n g ( )
public void setNext ( PhoneListNode nextPtr ) {
next = nextPtr ;
}// s e t N e x t ( )
public PhoneListNode getNext ( ) {
return next ;
}// g e t N e x t ( )
}// P h o n e L i s t N o d e
✡ ✠
Figure 16.4: The PhoneListNode class.
774 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
The constructor and data access methods should be familiar t o you.
Note that the constructor sets the initial value of next tonull , which
means that it refers to no object.
JAVA DEBUGGING TIP Null Reference. A common programming
error is the attempt to use a null reference to refer to an object. This
usually means the reference has not been successfully initi alized.
Let’s discuss the details of the link access methods—the setNext() and
getNext() methods—which are also simple to implement. Because this
is aPhoneListNode , these methods take PhoneListNode as a parame- Manipulating a list’s nodes
ter and return type, respectively. Given a reference to a PhoneListNode ,
thesetNext() method assigns it to next . The getNext() method
simply returns the value of its next link.
Let’s now see how we would use these methods to construct a lis t. The
following statements create three nodes:
☛ ✟
PhoneListNode node1 =
new PhoneListNode ( ”Roger M” ,”090−997−2918” ) ;
PhoneListNode node2 =
new PhoneListNode ( ” Jane M” ,”090−997−1987” ) ;
PhoneListNode node3 =
new PhoneListNode ( ” Stacy K” ,”090−997−9188” ) ;
✡ ✠
The next two statements chain the nodes together into the lis t shown in
Figure 16.5:
☛ ✟
node1 . setNext ( node2 ) ;
node2 . setNext ( node3 ) ;
✡ ✠
If we wanted to add a fourth node to the end of this list, we could use theRoger M
090-997-2918
Jane M
090-997-1987
Stacy K
090-997-9188
FIGURE 16.5 The phone list: a
linked list of nodes, each of which
contains a person’s name and phone
number.following statements:
☛ ✟
PhoneListNode node4 =
new PhoneListNode ( ” gary g” ,”201−119−8765” ) ;
node3 . setNext ( node4 ) ;
✡ ✠
Although this example illustrates the basic technique for i nserting nodes
at the end of the list, it depends too much on our knowledge of t he list.
In order to be truly useful we will have to develop a more genera l set of
methods to create and manipulate a list of nodes. As we will se e, a better
design would be able to ﬁnd the end of the list without knowing anything
about the list’s data.
JAVA EFFECTIVE DESIGN Generality. In a well-designed list data
structure, you should be able to manipulate its elements wit hout
knowing anything about its data.
SECTION 16.2 •The Linked List Data Structure 775
SELF-STUDY EXERCISE
EXERCISE 16.3 Suppose you know that nodeptr is a reference to the
last element of a linked list of PhoneListNode s. Create a new element
for “Bill C” with phone number “111-202-3331” and link it int o the end of
the list.
16.2.3 Manipulating the Phone List
In addition to the Node s that make a list, we must deﬁne a class containing
methods to manipulate the list. This class will include the i nsert, access,
and remove methods. It must also contain a reference to the lis t itself.
This leads to the basic design shown in Figure 16.6. Because t his is a list of
PhoneListNode s, we need a PhoneListNode reference to point to the+PhoneList()
+isEmpty() : boolean
+insert(in node : PhoneListNode)
+getPhone(in name : String) : String
+remove(in name : String)-head : PhoneListNodePhoneList
FIGURE 16.6 ThePhoneList class
has a reference to the ﬁrst node of the
list (head ) and methods to insert,
remove, and look up information. list, which is the purpose of the head variable.
A preliminary coding of the PhoneList class is shown in Figure 16.7.
As you can see there, when a new PhoneList instance is constructed,
head is initialized to null , meaning the list is initially empty. Since An empty list
we will frequently want to test whether the list is empty, we d eﬁne the
boolean isEmpty() method for that purpose. As you can see, its deﬁ-
nition says that a list is empty when the reference to the head of this list
isnull .
JAVA PROGRAMMING TIP Thenull Reference. Anull reference
is useful for deﬁning limit cases, such as an empty list or an
uninstantiated object.
☛ ✟
public c l a s s PhoneList {
private PhoneListNode head ;
public PhoneList ( ) {
head = null ; // S t a r t w i t h e m p t y l i s t
}
public boolean isEmpty ( ) { // D e f i n e s a n e m p t y l i s t
return head == null ;
}
public void i n s e r t ( PhoneListNode node ) { }
public S t r i n g getPhone ( S t r i n g name ) { }
public S t r i n g remove ( S t r i n g name ) { }
public void p r i n t ( ) { }
}// P h o n e L i s t
✡ ✠
Figure 16.7: A preliminary version of the PhoneList class.
Inserting Nodes into a List
Theinsert() method will have the task of inserting new PhoneList-
Node s into the list. There are a number of ways to do this. The node c ould
be inserted at the beginning or at the end of the list, or in alp habetical
776 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
Figure 16.8: Two cases. (a) The
list is empty before the insertion,
which takes place at head . (b) The
list is not empty, so the insertion
takes place at the end of the list.
Abby
529-8109
Gary
529-5112Newnode
529-8109Before insertion
Head Head
(a) Insertion into empty list
(b) Insertion into existing listAfter insertion
Head
Newnode
529-0011Abby
529-8109Head
Gary
529-5112
order, or possibly in other ways. As we’ll see, it is easiest t o insert a new
node at the head of the list. But for this example, let’s devel op a method
that inserts the node at the end of the list.
There are two cases we need to worry about for this algorithm. First, if Insertion algorithm
the list is empty, we can insert the node by simply setting head to point
to the node [Figure 16.8(a)]. Second, if the list is not empty , we must move
through, or traverse , the links of the list until we ﬁnd the last node and
insert the new node after it [Figure 16.8(b)]. In this case, we want to set
thenext variable of the last node to point to the new node. This gives u s
the following algorithm:
☛ ✟
public void i n s e r t ( PhoneListNode newNode) {
i f( isEmpty ( ) )
head = newNode ; // I n s e r t a t h e a d o f l i s t
else{
PhoneListNode current = head ; // S t a r t t r a v e r s a l a t h e a d
while ( current . getNext ( ) != null )// W h i l e n o t l a s t n o d e
current = current . getNext ( ) ; // g o t o n e x t n o d e
current . setNext ( newNode ) ; // Do t h e i n s e r t i o n
}
}// i n s e r t ( )
✡ ✠
Recall that when nodes are linked, their next variables are non- null .
So when a node’s next variable is null , that indicates the end of the
list—there’s no next node. Thus, our algorithm begins by chec king if
the list is empty. If so, we assign head the reference to newNode , the
PhoneListNode that’s being inserted.
If the list is not empty, then we need to ﬁnd the last node. In orde r to Traversing a list
traverse the list, we will need a temporary variable, current , which will
SECTION 16.2 •The Linked List Data Structure 777
always point to the current node. It’s important to understan d the while
loop used here:
☛ ✟
PhoneListNode current = head ; // I n i t i a l i z e r
while ( current . getNext ( ) != null ) // E n t r y c o n d i t i o n
current = current . getNext ( ) ; // U p d a t e r
✡ ✠
The loop variable, current , is initialized by setting it to point to the head
of the list. The entry condition tests whether the next link, leading out
ofcurrent , isnull (Fig. 16.9). That is, when the link coming out of a
node is null , then that node is the last node in the list [Figure 16.9(c)].
Inside the while loop, the update expression simply assigns t he next node
tocurrent . In that way, current will point to each successive node
until the last node is found. It’s very important that the loop exits when
current.getNext() isnull —that is, when the next pointer of the cur-
rent node is null. That way current is pointing to the last node and can Loop-exit condition
be used to set its next variable to the node being inserted [Figure 16.9(d)].
Thus, after the loop is exited, current still points to the last node. At that
point, the setNext() method is used to link newNode into the list as the
new last node.
Head(a) Start at the head of the listCurrent
Head(b) Traverse by following the linksCurrent
Head(c) Find the end of the listCurrent
Head(d) Insert the new nodeCurrent
NewFigure 16.9: The temporary vari-
ablecurrent is used to traverse
the list to ﬁnd its end.
JAVA DEBUGGING TIP List Traversal. A common error in
designing list-traversal algorithms is an erroneous loop- entry or
loop-exit condition. One way to avoid this error is to hand tr ace your
algorithm to make sure your code is correct.
778 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
Printing the Nodes of a List
Theprint() method also uses a traversal strategy to print the data from List traversal
each node of the list. Here again it is necessary to test whethe r the list
is empty. If so, we must print an error message. (This would be a good
place to throw a programmer-deﬁned exception, such as an EmptyList-
Exception .) If the list is not empty, then we use a temporary variable to
traverse the list, printing each node’s data along the way:
☛ ✟
public void p r i n t ( ) {
i f( isEmpty ( ) )
System . out . p r i n t l n ( ”Phone l i s t i s empty” ) ;
PhoneListNode current = head ; // S t a r t t r a v e r s a l a t h e a d
while ( current != null ){ // W h i l e n o t e n d o f l i s t
System . out . p r i n t l n ( current . t o S t r i n g ( ) ) ; // p r i n t d a t a
current = current . getNext ( ) ; //
g o t o n e x t n o d e
}
}// p r i n t ( )
✡ ✠
Note the differences between this while loop and the one used in the
insert() method. In this case, we exit the loop when current becomes
null ; there’s no action to be taken after the loop is exited. The pr int-
ing takes place within the loop. Thus, in this case, the entry condition,
(current != null) , signiﬁes that the task has been completed.
JAVA PROGRAMMING TIP Terminating a Traversal. In designing
list-traversal algorithms where the reference, p, points to the nodes in
the list, if you need to refer to the last node in the list after the traversal
loop exits, then your exit condition should be p.getNext() ==
null . If you have ﬁnished processing the nodes when the loop exits,
your exit condition should be p == null .
Looking up a Node in a List
Because the record associated with a person can be located an ywhere in
the list, the traversal strategy must also be used to look up s omeone’s List traversal
phone number in the PhoneList . Here again we start at the head of the
list and traverse through the next links until we ﬁnd the node containing
the desired phone number. This method takes the name of the pe rson as a
parameter. There are three cases to worry about: (1) The list is empty; (2)
the normal case where the person named is found in the list; an d (3) the
SECTION 16.2 •The Linked List Data Structure 779
person named is not in the list. Because the method returns a String , we
can return error messages in the ﬁrst and third cases:
☛ ✟
public S t r i n g getPhone ( S t r i n g name ) {
i f( isEmpty ( ) ) // C a s e 1 : E m p t y l i s t
return ”Phone l i s t i s empty” ;
else{
PhoneListNode current = head ;
while ( ( current . getNext ( ) != null ) &&
( ! current . getName ( ) . equals (name ) ) )
current = current . getNext ( ) ;
i f( current . getName ( ) . equals (name ) )
return current . getData ( ) ; // C a s e 2 : F o u n d n a m e
else
// C a s e 3 : No s u c h p e r s o n
return (” Sorry . No entry f o r ” + name ) ;
}
}// g e t P h o n e ( )
✡ ✠
Note the while loop in this case. As in the insert() method, when the
loop exits, we need a reference to the current node so that we can print
its phone number [ current.getData() ]. But here there are three ways
to exit the loop: (1) We reach the end of the list without ﬁndin g the named
person; (2) we ﬁnd the named person in the interior of the list ; or (3) we
ﬁnd the named person in the last node of the list. In any case, it is nec- Compound exit condition
essary to test whether the name was found or not after the loop is exited.
Then appropriate action can be taken.
SELF-STUDY EXERCISE
EXERCISE 16.4 What if the exit condition for the while loop in
getPhone() were stated as
☛ ✟
( ( current . getNext ( ) != null )||
( ! current . getName ( ) . equals (name ) ) )
✡ ✠
Removing a Node from a List
By far the most difﬁcult task is that of removing a node from a l ist. In Node-removal algorithm
thePhoneList we use the person’s name to identify the node, and we
return a String that can be used to report either success or failure. There
are four cases to worry about in designing this algorithm: (1 ) The list is
empty, (2) the ﬁrst node is being removed, (3) some other node is being
removed, and (4) the named person is not in the list. The same t raversal
strategy we used in getPhone() is used here, with the same basic while
loop for cases 3 and 4.
As Figure 16.10 shows, the ﬁrst two cases are easily handled. If the list is
empty, we just return an error message. We use current as the traversal
variable. If the named node is the ﬁrst node, we simply need to s ethead
tocurrent.getNext() , which has the effect of making head point to
the second node in the list [Figure 16.11(a)]. Once the node i s cut out from
780 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
☛ ✟
public S t r i n g remove ( S t r i n g name ) {// R e m o v e a n e n t r y b y n a m e
i f( isEmpty ( ) ) // C a s e 1 : e m p t y l i s t
return ”Phone l i s t i s empty” ;
PhoneListNode current = head ;
PhoneListNode previous = null ;
i f( current . getName ( ) . equals (name ) ) {// C a s e 2 : r e m o v e f i r s t n o d e
head = current . getNext ( ) ;
return ”Removed ” + current . t o S t r i n g ( ) ;
}
while ( ( current . getNext ( ) != null ) &&
( ! current . getName ( ) . equals (name ) ) ) {
previous = current ;
current = current . getNext ( ) ;
}
i f( current . getName ( ) . equals (name ) ) {// C a s e 3 : r e m o v e n a m e d n o d e
previous . setNext ( current . getNext ( ) ) ;
return ”Removed ” + current . t o S t r i n g ( ) ;
}else
return (” Sorry . No entry f o r ” + name ) ; // C a s e 4 : n o d e n o t f o u n d
}// r e m o v e ( )
✡ ✠
Figure 16.10: The remove() method.
the chain of links, there will be no further reference to it. In this case, Java
will recapture the memory it uses when it does garbage collec tion.
JAVA LANGUAGE RULE Garbage Collection. Java’s garbage
collector handles the disposal of unused objects automatica lly. This
helps to simplify linked-list applications. In languages su ch as C++,
the programmer would have to dispose of the memory occupied by the
deleted node.
In order to remove some other node besides the ﬁrst, two traver sal vari-
ables are needed: previous andcurrent . They proceed together down
the list, with previous always pointing to the node just before the Tandem traversal
current node. The reason, of course, is that to remove the current
node, you need to adjust the link pointing to it contained in th eprevious
node [Figure 16.11(b)]. That is, the new value of previous.next will
be the current value of current.next . We use the getNext() and
setNext() methods to effect this change:
☛ ✟
previous . setNext ( current . getNext ( ) ) ;
✡ ✠
SECTION 16.2 •The Linked List Data Structure 781
Head
(a) Removing first node
(b) Removing other nodeRemoved nodes
will be garbage
collectedHead
HeadPrevious
HeadPreviousCurrent
CurrentFigure 16.11: Removing different
nodes from a linked list.
Testing the List
In developing list-processing programs, it is important to d esign good test
data. As we have seen, both the insertion and removal operati ons involve
several distinct cases. Proper testing of these methods ide ally would test Designing test data
every possible case. The main() program in Figure 16.12 illustrates the
kinds of tests that should be performed. This method could be incorpo-
rated directly into the PhoneList class, or it could be made part of a
separate class.
Of course, there are often so many combinations of list opera tions that ex-
haustive testing might not be feasible. At the very least you should design
test data that test each of the different conditions identiﬁ ed in your algo-
rithms. For example, in testing removals from a list, you sho uld test all
four cases that we discussed. In testing insertions or lookup s, you should
test all three cases that we identiﬁed.
JAVA EFFECTIVE DESIGN Test Data. Test data for validating
list-processing algorithms should (at least) test each of t he cases
identiﬁed in each of the removal and insertion methods.
SELF-STUDY EXERCISES
EXERCISE 16.5 Trace through the main() method line by line and
predict its output.
EXERCISE 16.6 Design a test of PhoneList that shows that new ele-
ments can be inserted into a list after some or all of its previ ous nodes
have been removed.
782 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] ) {
// C r e a t e l i s t a n d i n s e r t n o d e s
PhoneList l i s t = new PhoneList ( ) ;
l i s t . i n s e r t ( new PhoneListNode ( ”Roger M” ,”997−0020” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ”Roger W ” ,”997−0086” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Rich P” ,”997−0010” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Jane M” ,”997−2101” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Stacy K” ,”997−2517” ) ) ;
// T e s t w h e t h e r i n s e r t i o n s w o r k e d
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
// T e s t w h e t h e r l o o k u p s w o r k
System . out . p r i n t l n ( ”Looking up numbers by name” ) ;
System . out . p r i n t l n ( l i s t . getPhone ( ”Roger M” ) ) ;
System . out . p r i n t l n ( l i s t . getPhone ( ” Rich P” ) ) ;
System . out . p r i n t l n ( l i s t . getPhone ( ” Stacy K” ) ) ;
System . out . p r i n t l n ( l i s t . getPhone ( ”Mary P” ) ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Rich P” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
// T e s t r e m o v a l s , p r i n t i n g l i s t a f t e r e a c h r e m o v a l
System . out . p r i n t l n ( l i s t . remove ( ”Roger M” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Stacy K” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Jane M” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Jane M” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
System . out . p r i n t l n ( l i s t . remove ( ”Roger W ” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
System . out . p r i n t l n ( l i s t . remove ( ”Roger W ” ) ) ;
System . out . p r i n t l n ( ”Phone Directory ” ) ;
l i s t . p r i n t ( ) ;
}// m a i n ( )
✡ ✠
Figure 16.12: A main() method containing a set of tests for the
PhoneList class.
16.3 OBJECT-ORIENTED DESIGN:
The List Abstract Data Type (ADT)
ThePhoneList example from the previous section illustrates the basic
concepts of the linked list. Keep in mind that there are other implemen-
tations that could have been described. For example, some li nked lists
use a reference to both the ﬁrst and last elements of the list. Some lists
SECTION 3 •OOD: The List ADT 783
use nodes that have two pointers, one to the next node and one t o the
previous node. This enables traversals in two directions—fr ont to back
and back to front—as well as making it easier to remove nodes fr om the
list. The example we showed was intended mainly to illustrat e the basic
techniques involved in list processing.
Also, the PhoneList example is limited to a particular type of data— A generic list structure
namely, a PhoneListNode . Let’s develop a more general linked list class
and a more general node class that can be used to store and proc ess lists
of any kind of data.
AnAbstract Data Type (ADT) involves two components: the data that
are being stored and manipulated and the methods and operati ons that
can be performed on those data. For example, an int is an ADT. The
data are the integers ranging from some MININT to some MAXINT . The
operations are the various integer operations: addition, s ubtraction, mul-
tiplication, and division. These operations prescribe the ways that ints
can be used. There are no other ways to manipulate integers.
Moreover, in designing an ADT, it’s important to hide the imp lemen-
tation of the operations from the users of the operations. Th us, our pro- Information hiding
grams have used all of these integer operations on ints, but we have no
real idea how they are implemented—that is, what exact algori thm they
use.
Objects can be designed as ADTs, because we can easily disting uish
an object’s use from its implementation. Thus, the private parts of an
object—its instance variables and private methods—are hidden from the
user while the object’s interface—its public methods—are available. As
with the integer operators, the object’s public methods pres cribe just how
the object can be used.
So let’s design a list ADT. We want it to be able to store any kin d of data,
and we want to prescribe the operations that can be performed on those
data—the insert, delete, and so on. Also, we want to design the ADT so Design speciﬁcations
that it can be extended to create more specialized kinds of li sts.
TheNode Class
JAVA EFFECTIVE DESIGN Generalizing a Type. An effective
strategy for designing a list abstract data type is to start w ith a speciﬁc
list and generalize it. The result should be a more abstract v ersion of
the original list.
Our approach will be to generalize the classes we created in t hePhone-
List example. Thus, the PhoneListNode will become a generic Node
that can store any kind of data (Fig. 16–13). Some of the chang es are
merely name changes. Thus, wherever we had PhoneListNode , we now
have just Node . The link access methods have not changed signiﬁcantly.
What has changed is that instead of instance variables for the name, phone+Node(in o : Object)
+setData(in o : Object)
+getData() : Object
+setNext(in link : Node)
+getNext() : Node
+toString() : String-data : Object
-next : NodeNode
FIGURE 16.13 TheNode class is a
generalization of the
PhoneListNode class.number, and so on, we now have just a single data reference to an Object .
This is as general as you can get, because, as we pointed out ea rlier,data
can refer to any object, even to primitive data.
The implementation of the Node class is shown in Figure 16.14. Note
that the data access methods, getData() andsetData() , use references
784 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
☛ ✟
public c l a s s Node{
private Object data ; // S t o r e s a n y k i n d o f d a t a
private Node next ;
public Node( Object obj ) { // C o n s t r u c t o r
data = obj ;
next = null ;
} // D a t a a c c e s s m e t h o d s
public void setData ( Object obj ) {
data = obj ;
}
public Object getData ( ) {
return data ;
}
public S t r i n g t o S t r i n g ( ) {
return data . t o S t r i n g ( ) ;
} // L i n k a c c e s s m e t h o d s
public void setNext ( Node nextPtr ) {
next = nextPtr ;
}
public Node getNext ( ) {
return next ;
}
}// Node
✡ ✠
Figure 16.14: The Node class is a more abstract version of the Phone-
ListNode class.
toObject for their parameter and return type. Note also how we’ve de-
ﬁned the toString() method. It just invokes data.toString() . Be-
causetoString() is deﬁned in Object , every type of data will have this
method. And because toString() is frequently overridden in deﬁning
new objects, it is useful here.
TheList Class
Let’s now generalize the PhoneList class (Fig. 16–15). The List class
will still contain a reference to the head of the list, which will now be a
list ofNode s. It will still deﬁne its constructor, its isEmpty() method,+List()
+isEmpty() : boolean
+print()
+insertAtFront(in o : Object)
+insertAtRear(in o : Object)
+removeFirst() : Object
+removeLast() : Object-head : NodeList
FIGURE 16.15 TheList class
contains a pointer to the head of the
list and public methods to insert and
remove objects from both the front
and rear of the list.and its print() method in the same way as in the PhoneList .
However, in designing a generic List class, we want to design some
new methods, particularly because we want to use this class a s the basis
for more specialized lists. The PhoneList.insert() method was used
to insert nodes at the end of a list. In addition to this method, let’s design a
method that inserts at the head of the list. Also, PhoneList had a method
to remove nodes by name. However, now that we have generalized our
data, we don’t know if the list’s Object s have a name ﬁeld, so we’ll scrap
this method in favor of two new methods that remove a node from the
beginning or end of the list, respectively.
We already know the basic strategies for implementing these new
methods, which are shown in the deﬁnition in Figure 16.16. We have re-
SECTION 3 •OOD: The List ADT 785
☛ ✟
public c l a s s L i s t{
private Node head ;
public L i s t ( ) {head = null ;}
public boolean isEmpty ( ) {return head == null ;}
public void p r i n t ( ) {
i f( isEmpty ( ) )
System . out . p r i n t l n ( ” L i s t i s empty” ) ;
Node current = head ;
while ( current != null ){
System . out . p r i n t l n ( current . t o S t r i n g ( ) ) ;
current = current . getNext ( ) ;
}
}// p r i n t ( )
public void i n s e r t A t F r o n t ( Object obj ) {
Node newnode = new Node( obj ) ;
newnode . setNext ( head ) ;
head = newnode ;
}
public void insertAtRear ( Object obj ) {
i f( isEmpty ( ) )
head = new Node( obj ) ;
else{
Node current = head ; // S t a r t a t h e a d o f l i s t
while ( current . getNext ( ) != null )// F i n d t h e e n d o f t h e l i s t
current = current . getNext ( ) ;
current . setNext ( new Node( obj ) ) ; // C r e a t e a n d i n s e r t n e w N o d e
}
}// i n s e r t A t R e a r ( )
public Object removeFirst ( ) {
i f( isEmpty ( ) ) // E m p t y L i s t
return null ;
Node f i r s t = head ;
head = head . getNext ( ) ;
return f i r s t . getData ( ) ;
}// r e m o v e F i r s t ( )
public Object removeLast ( ) {
i f( isEmpty ( ) ) // e m p t y l i s t
return null ;
Node current = head ;
i f( current . getNext ( ) == null ){// S i n g l e t o n l i s t
head = null ;
return current . getData ( ) ;
}
Node previous = null ; // A l l o t h e r c a s e s
while ( current . getNext ( ) != null ){
previous = current ;
current = current . getNext ( ) ;
}
previous . setNext ( null ) ;
return current . getData ( ) ;
}// r e m o v e L a s t ( )
}// L i s t
✡ ✠
Figure 16.16: The List ADT.
786 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
named the insertAtRear() method, which otherwise is very similar
to thePhoneList.insert() method. The key change is that now its
parameter must be an Object , because we want to be able to insert any
kind of object into our list. At the same time, our list consist s ofNode s, so
we have to use the Object to create a Node in our insert methods:
☛ ✟
head = new Node( obj ) ;
✡ ✠
Recall that the Node constructor takes an Object argument and simply
assigns it to the data reference. So when we insert an Object into the list,
we make a new Node and set its data variable to point to that Object .
Note that we check whether the list is empty before traversing to the last
node.
The new insertAtFront() method (Fig. 16.16) is simple to imple-
ment, since no traversal of the list is necessary. You just nee d to create
a new Node with the Object as its data element and then link the new
node into the head of the list:
☛ ✟
Node newnode = new Node( obj ) ;
newnode . setNext ( head ) ;
head = newnode ;
✡ ✠
See Figure 16.8a for a graphical representation of this type of insertion.
The new removeFirst() method is also quite simple to implement.
In this case, you want to return a reference to the Object that’s stored in
the ﬁrst node, but you need to adjust head so that it points to whatever the
previous head.next was pointing to before the removal. This requires
the use of a temporary variable, as shown in the method.
The new removeLast() method is a bit more complicated. It handles
three cases: (1) The empty list case, (2) the single node list , and (3) all other
lists. If the list is empty, it returns null . Obviously, it shouldn’t even be
called in this case. In designing subclasses of List we will ﬁrst invoke
isEmpty() before attempting to remove a node.
If the list contains a single node, we treat it as a special case and set
head tonull , thus resulting in an empty list. In the typical case, case
3, we traverse the list to ﬁnd the last node, again using the st rategy of
maintaining both a previous and acurrent pointer. When we ﬁnd
the last node, we must adjust previous.next so that it no longer points
to it.
Testing the List ADT
Testing the list ADT follows the same strategy used in the PhoneList
example. However, one of the things we want to test is that we ca n indeed Heterogeneous lists
create lists of heterogeneous types—lists that include Integer s mixed
withFloat s, mixed with other types of objects. The main() method in
Figure 16.17 illustrates this feature.
SECTION 3 •OOD: The List ADT 787
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] ) {
// C r e a t e l i s t a n d i n s e r t h e t e r o g e n e o u s n o d e s
L i s t l i s t = new L i s t ( ) ;
l i s t . i n s e r t A t F r o n t ( new PhoneRecord ( ”Roger M” ,”997−0020” ) ) ;
l i s t . i n s e r t A t F r o n t ( new I n t e g e r ( 8 6 4 7 ) ) ;
l i s t . i n s e r t A t F r o n t ( new S t r i n g ( ” Hello World” ) ) ;
l i s t . insertAtRear ( new PhoneRecord ( ” Jane M” ,”997−2101” ) ) ;
l i s t . insertAtRear ( new PhoneRecord ( ” Stacy K” ,”997−2517” ) ) ;
// P r i n t t h e l i s t
System . out . p r i n t l n ( ” Generic L i s t ” ) ;
l i s t . p r i n t ( ) ;
// R e m o v e o b j e c t s a n d p r i n t r e s u l t i n g l i s t
Object o ;
o = l i s t . removeLast ( ) ;
System . out . p r i n t l n ( ” Removed ” + o . t o S t r i n g ( ) ) ;
System . out . p r i n t l n ( ” Generic L i s t : ” ) ;
l i s t . p r i n t ( ) ;
o = l i s t . removeLast ( ) ;
System . out . p r i n t l n ( ” Removed ” + o . t o S t r i n g ( ) ) ;
System . out . p r i n t l n ( ” Generic L i s t : ” ) ;
l i s t . p r i n t ( ) ;
o = l i s t . removeFirst ( ) ;
System . out . p r i n t l n ( ” Removed ” +o . t o S t r i n g ( ) ) ;
System . out . p r i n t l n ( ” Generic L i s t : ” ) ;
l i s t . p r i n t ( ) ;
}// m a i n ( )
✡ ✠
Figure 16.17: A series of tests for the List ADT.
JAVA EFFECTIVE DESIGN TheList ADT. One advantage of
deﬁning a List ADT is that it lets you avoid having to write the
relatively difﬁcult list-processing algorithms each time you need a list
structure.
The list we create here involves various types of data. The Phone-
Record class is a scaled-down version of the PhoneListNode we used in
the previous example (Fig. 16.18). Its deﬁnition is shown in F igure 16.19.
Note how we use an Object reference to remove objects from the list in
main() . We use the Object.toString() method to display the object
that was removed.
+PhoneRecord(in name : String, in phone : String)
+toString() : String
+getName() : String
+getPhone() : String-name : String
-phone : StringPhoneRecord Figure 16.18: The PhoneRecord
class stores data for a phone direc-
tory.
788 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
☛ ✟
public c l a s s PhoneRecord {
private S t r i n g name ;
private S t r i n g phone ;
public PhoneRecord ( S t r i n g s1 , S t r i n g s2 ) {
name = s1 ;
phone = s2 ;
}
public S t r i n g t o S t r i n g ( ) {
return name + ” ” + phone ;
}
public S t r i n g getName ( ) {
return name ;
}
public S t r i n g getPhone ( ) {
return phone ;
}
}// P h o n e R e c o r d
✡ ✠
Figure 16.19: A PhoneRecord class.
SELF-STUDY EXERCISES
EXERCISE 16.7 Trace through the main() method line by line and
predict its output.
EXERCISE 16.8 Design a test of the List program that shows that it is
possible to insert new elements into a list after some or all o f its previous
nodes have been removed.
16.4 The Stack ADT
Astack is a special type of list that allows insertions and removals to be
performed only to the front of the list. Therefore, it enforc eslast-in–ﬁrst-
out (LIFO) behavior on the list. Think of a stack of dishes at the salad
bar. When you put a dish on the stack, it goes onto the top of the s tack.
When you remove a dish from the stack, it comes from the top of th e stack
(Fig. 16.20).
The stack operations are conventionally called push , for insert, and
pop, for remove, respectively. Thus, the stack ADT stores a list of data
and supports the following operations:
•Push—inserts an object onto the top of the stack.
•Pop—removes the top object from the stack.
•Empty—returns true if the stack is empty.
•Peek—retrieves the top object without removing it.
Stacks are useful for a number of important computing tasks. For
example, during program execution, method call and return h appens in a Stack applications
LIFO fashion. The last method called is the ﬁrst method exited . There-
fore, a stack structure known as the run-time stack is used to manage
method calls during program execution. When a method is calle d, an
SECTION 16.4 •The Stack ADT 789
Top
In a stack, insertions
and deletions occur
at the topTop NewFigure 16.20: A stack is a list that
permits insertions and removals
only at its top.
activation block is created, which includes the method’s pa rameters, lo-
cal variables, and return address. The activation block is p ushed onto
the stack. When that method call returns, the return address i s retrieved
from the activation block and the whole block is popped off th e stack.
TheException.printStackTrace() method uses the run-time stack
to print a trace of the method calls that led to an exception.
16.4.1 The Stack Class
Given our general deﬁnition of List andNode , it is practically trivial to
deﬁne the stack ADT as a subclass of List (Fig. 16–21). As a subclass of
List , aStack will inherit all of the public and protected methods de-
ﬁned in List . Therefore, we can simply use the insertAtFront() and
removeFirst() methods for the push and pop operations, respectively+List()
 #  isEmpty() : boolean
 #  print()
 #  insertAtFront(in o : Object)
 #  insertAtRear(in o : Object)
 #  removeFirst() : Object
 #  removeLast() : Object #  head : NodeList
+Stack()
+push(in o : Object)
+pop() : Object
+peek() : ObjectStack
FIGURE 16.21 As a subclass of
List , aStack inherits all of its
public (+) and protected (#) elements.
Therefore, push() can be deﬁned in
terms of insertAtFront() and
pop() can be deﬁned in terms of
removeFirst() .(Fig. 16.22). Because the isEmpty() method is deﬁned in List , there’s
no need to override it in Stack . In effect, the push() andpop() methods
☛ ✟
public c l a s s Stack extends L i s t{
public Stack ( ) {
super ( ) ; // I n i t i a l i z e t h e l i s t
}
public void push ( Object obj ) {
i n s e r t A t F r o n t ( obj ) ;
}
public Object pop ( ) {
return removeFirst ( ) ;
}
}// S t a c k
✡ ✠
Figure 16.22: The Stack ADT.
merely rename the insertAtFront() andremoveFirst() methods.
Note that the Stack() constructor calls the superclass constructor. This
is necessary so that the list can be initialized.
Do we have to make any changes to the List class in order to use it
this way? Yes. We want to change the declaration of head fromprivate
790 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
toprotected , so it can be accessed in the Stack class. And we want
to declare List ’spublic access methods, such as insertAtFront()
andremoveFirst() , asprotected . That will allow them to be used
inStack , and in any classes that extend List , but not by other classes.
This is essential. Unless we do this we haven’t really restri cted the stack
operations to push and pop and, therefore, we haven’t really deﬁned a
stack ADT. Remember, an ADT deﬁnes the data and the operation s on the
data. A stack ADT must restrict access to the data to just the pu sh and pop
operations.
JAVA LANGUAGE RULE Protected Elements. An object’s
protected elements are hidden from all other objects except
instances of the same class or its subclasses.
JAVA EFFECTIVE DESIGN Information Hiding. Use the private
andprotected qualiﬁers to hide an ADT’s implementation details
from other objects. Use public to deﬁne the ADT’s interface.
SELF-STUDY EXERCISE
EXERCISE 16.9 Deﬁne the peek() method for the Stack class. It
should take no parameters and return an Object . It should return the
Object on the top of the stack.
16.4.2 Testing the Stack Class
Now let’s test our stack class by using a stack to reverse the letters in a
String . The algorithm is this: Starting at the front of the String , push
each letter onto the stack until you reach the end of the String . Then Reversing a string
pop letters off the stack and concatenate them, left to right , into another
String , until the stack is empty (Fig. 16.23).
Note that because our Node s store Object s, we must convert each
char into aCharacter , using the wrapper class. Note also that we can
use the toString() method to convert from Object toString as we
are popping the stack.
16.5 The Queue ADT
Aqueue is a special type of list that limits insertions to the end of t he list
and removals to the front of the list. Therefore, it enforces ﬁrst-in–ﬁrst-out
(FIFO) behavior on the list. Think of the waiting line at the salad ba r. You
enter the line at the rear and you leave the line at the front (F ig. 16.24).
The queue operations are conventionally called enqueue , for insert, and
dequeue , for remove, respectively. Thus, the queue ADT stores a list of
data and supports the following operations:
•Enqueue—insert an object onto the rear of the list.
•Dequeue—remove the object at the front of the list.
•Empty—return true if the queue is empty.
SECTION 16.5 •The Queue ADT 791
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] ) {
Stack s t a c k = new Stack ( ) ;
S t r i n g s t r i n g = ” Hello t h i s i s a t e s t s t r i n g ” ;
System . out . p r i n t l n ( ” S t r i n g : ” + s t r i n g ) ;
for (i n t k = 0 ; k <s t r i n g . length ( ) ; k++)
s t a c k . push ( new Character ( s t r i n g . charAt ( k ) ) ) ;
Object o = null ;
S t r i n g reversed = ””;
while ( ! s t a c k . isEmpty ( ) ) {
o = s t a c k . pop ( ) ;
reversed = reversed + o . t o S t r i n g ( ) ;
}
System . out . p r i n t l n ( ” Reversed S t r i n g : ” + reversed ) ;
}// m a i n ( )
✡ ✠
Figure 16.23: A method to test the Stack ADT, which is used here to
reverse a String of letters.
Queues are useful for a number of computing tasks. For exampl e, the
ready, waiting, and blocked queues used by the CPU scheduler all use a
FIFO protocol. Queues are also useful in implementing certai n kinds of
simulations. For example, the waiting line at a bank or a bake ry can be
modeled using a queue.
Head
In a queue, insertions
take place at the rear, and
removals occur at the frontHead
NewFigure 16.24: A queue is a list that
permits insertions at the rear and
removals at the front only.
792 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
16.5.1 The Queue Class
TheQueue class is also trivial to derive from List (Fig. 16.25). Here we
just restrict operations to the insertAtRear() andremoveFirst()
methods (Fig. 16.26). To test the methods of this class, we re place the
push() andpop() operations of the last example to enqueue() and
dequeue() , respectively (Fig. 16.27). In this case, the letters of the t est
string will come out of the queue in the same order they went in —FIFO.+List()
 #  isEmpty() : boolean
 #  print()
 #  insertAtFront(in o : Object)
 #  insertAtRear(in o : Object)
 #  removeFirst() : Object
 #  removeLast() : Object #  head : NodeList
+Queue()
+enqueue(in o : Object)
+dequeue() : ObjectQueue
FIGURE 16.25 TheQueue ’s
enqueue() anddequeue()
methods can use the List ’s
insertAtRear() and
removeFirst() methods,
respectively.☛ ✟
public c l a s s Queue extends L i s t{
public Queue ( ) {
super ( ) ; // I n i t i a l i z e t h e l i s t
}
public void enqueue ( Object obj ) {
insertAtRear ( obj ) ;
}
public Object dequeue ( ) {
return removeFirst ( ) ;
}
}// Q u e u e
✡ ✠
Figure 16.26: The Queue ADT.
☛ ✟
public s t a t i c void main ( S t r i n g argv [ ] ) {
Queue queue = new Queue ( ) ;
S t r i n g s t r i n g = ” Hello t h i s i s a t e s t s t r i n g ” ;
System . out . p r i n t l n ( ” S t r i n g : ” + s t r i n g ) ;
for (i n t k = 0 ; k <s t r i n g . length ( ) ; k++)
queue . enqueue ( new Character ( s t r i n g . charAt ( k ) ) ) ;
System . out . p r i n t l n ( ”The current queue : ” ) ;
queue . p r i n t ( ) ;
Object o = null ;
System . out . p r i n t l n ( ”Dequeuing : ” ) ;
while ( ! queue . isEmpty ( ) ) {
o = queue . dequeue ( ) ;
System . out . p r i n t ( o . t o S t r i n g ( ) ) ;
}
}// m a i n ( )
✡ ✠
Figure 16.27: A method to test the Queue ADT. Letters inserted in a queue
come out in the same order they went in.
JAVA EFFECTIVE DESIGN ADTs. ADTs encapsulate and manage
the difﬁcult tasks involved in manipulating the data struct ure. But
because of their extensibility, they can be used in a wide ran ge of
applications.
SECTION 16.5 •The Queue ADT 793
SELF-STUDY EXERCISE
EXERCISE 16.10 Deﬁne a peekLast() method for the Queue class.
It should take no parameters and return an Object . It should return
a reference to the Object stored in the last Node of the list without
removing it.
Special Topic: The LISP Language
One of the very earliest computer languages, and the one that ’s most of-
ten associated with artiﬁcial intelligence (AI), is LISP , whi ch stands for
LIStProcessor. LISP has been, and still is, used to build programs f or hu-
man learning, natural language processing, chess playing, human vision
processing, and a wide range of other applications.
The earliest (pure) versions of LISP had no control structure s and the
only data structure they contained was the list structure. R epetition in the
language was done by recursion. Lists are used for everythin g in LISP ,
including LISP programs themselves. LISP’s unique syntax is s imple. A
LISP program consists of symbols, such as 5and x, and lists of symbols,
such as (5),(1 2 3 4 5) , and ((this 5) (that 10)) , where a list is anything en-
closed within parentheses. The null list is represented by ().
Programs in LISP are like mathematical functions. For exampl e, here’s
a deﬁnition of a function that computes the square of two numb ers:
☛ ✟
( define ( square x ) ( ∗x x ) )
✡ ✠
The expression (square x) is a list giving the name of the function and its
parameter. The expression (* x x) gives the body of the function.
LISP uses preﬁx notation , in which the operator is the ﬁrst symbol in
the expression, as in (* x x) . This is equivalent to (x * x) in Java’s inﬁx
notation , where the operator occurs between the two operands. To run
this program, you would simply input an expression like (square 25) to the
LISP interpreter, and it would evaluate it to 625.
LISP provides three basic list operators. The expression (car x) returns
the ﬁrst element of the (nonempty) list x. The expression (cdr x) returns
the tail of the list x. Finally, (cons z x) constructs a list by making zthe head
of the list and xits tail. For example, if xis the list (1 3 5) , then (car x) is 1,
(cdr x) is(3 5) , and (cons 7 x) is(7 1 3 5) .
Given these basic list operators, it is practically trivial to deﬁne a stack
in LISP:
☛ ✟
( define ( push x s t a c k ) ( cons x s t a c k ) )
( define ( pop s t a c k ) ( s e t f s t a c k ( cdr s t a c k ) ) ( car s t a c k ) )
✡ ✠
The push operation creates a new stack by forming the cons of the element
xand the previous version of the stack. The pop operation retu rns the
carof the stack but ﬁrst changes the stack (using setf ) to the tail of the
original stack.
794 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
These simple examples show that you can do an awful lot of comp uta-
tion using just a simple list structure. The success of LISP , pa rticularly its
success as an AI language, shows the great power and generali ty inherent
in recursion and lists.
16.6 From the Java Library: The Java Collections
Framework and Generic Types
java.sun.com/j2se/1.5.0/docs/api/THE JAVA CLASS LIBRARY contains implementations of some abstract
data types. The Java utility package, java.util. *, contains a good
number of classes and interfaces designed to facilitate sto ring and ma-
nipulating groups of objects. This family of related interfa ces and classes
is called the Java collections framework . It contains structures that corre-
spond to the ADTs that we have just discussed, plus other data s tructures.
Java 5.0 has reimplemented the Java collections framework u sing generic
types that allow a programmer to specify a type for the objects that a re
stored in the structure.
16.6.1 Generic types in Java
Declaring classes that use the generic type construct intro duced in Java 5.0
involves using new syntax to refer to the class name. Such cla sses and in- generic types
terfaces, including those in the collections framework, us e angle brackets
containing one or more variables (separated by commas) to re fer to un-
speciﬁed type names. For example, you would use <E> or<K,V> to refer
to unspeciﬁed type names. Thus, names of classes or interfac es imple-
mented with generic types are written with the syntax ClassName<E> .
Let’s reconsider the Vector class, which was introduced in Chapter 9.
TheVector class, which is part of the Java collections framework, has
a generic type implementation in Java 5.0. Figure 16.28 desc ribes the
+Vector()
+Vector(in size : int)
+addElement(in o : E)
+elementAt(in index : int) : E
+insertElementAt(in o : E, in x : int)
+indexOf(in o : Object) : int
+lastIndexOf(in o : Object) : int
+removeElementAt(in index : int)
+size() : intVector<E>
FIGURE 16.28 The
java.util.Vector class is
implemented with a generic type in
Java 5.0.Vector<E> class. Notice that the Erefers to an unspeciﬁed type name,
that is, the name of a class or interface. This type is speciﬁe d when a
corresponding variable is declared. The type must also be in cluded after a
constructor’s type name when an object is instantiated and as signed to the
variable. The following code demonstrates how to create a Vector<E>
object for storing String objects.
☛ ✟
Vector<String>strVec = new Vector<String>( ) ;
strVec . addElement ( ” alpha ” ) ;
strVec . addElement ( ” beta ” ) ;
S t r i n g s t r = strVec . elementAt ( 0 ) ;
✡ ✠
In effect, the <E> serves as parameter for the type of objects that will be
stored in the Vector . Java 5.0 still allows the use of the unparameterized
Vector class which is equivalent to instantiating a Vector<Object>
SECTION 6 •Java Collections and Generic Types 795
object. If you use a Vector object, the above code would be written as
follows.
☛ ✟
Vector strVec = new Vector ( ) ;
strVec . addElement ( ” alpha ” ) ;
strVec . addElement ( ” beta ” ) ;
S t r i n g s t r = ( S t r i n g ) strVec . elementAt ( 0 ) ;
✡ ✠
One beneﬁt a generic type provides is type checking of method argu-
ments at compile time. If strVec is aVector<String> object, then the
statement
☛ ✟
strVec . addElement ( new I n t e g e r ( 5 7 ) ) ;
✡ ✠
will generate a compile-time error. By contrast, if strVec was just a
plainVector object, no error would be found at compile time. Thus, if
a programmer wishes to create an array of String objects, using generic
types will help guarantee that the objects being stored are ac tually of type
String . In this way, using generic types helps to reduce the number of
programming errors and thereby makes programs safer and mor e robust.
A second beneﬁt of using generic types is that the return type of objects
retrieved from the data structure will be of the speciﬁed typ e rather than
of type Object . If you compare the last statement in each of the two
code segments above, you can see that using a generic type eli minates the
need to cast an Object to aString . This is a big convenience for the
programmer, because forgetting to cast objects from one type to another is
a common programming error.+empty() : boolean
+peek() : E
+pop() : E
+push(in o : E) : E
+search(in o : Object) : intStack<E>Vector<E>
FIGURE 16.29 The
java.util.Stack<E> class is a
subclass of Vector<E> .Thejava.util.Stack<E> class
The Java collections framework includes the Stack<E> class, imple-
mented as a subclass of the Vector<E> class. It contains the methods
shown in Figure 16.29. For the most part, its methods provide the same
functionality as the methods we developed earlier in this ch apter.
Note that the methods provide the functionality of a stack AD T but the de-
tails of its implementation are hidden from the user. An objec t of this class
can be declared, instantiated, and used in a manner like the Vector<E>
code.
☛ ✟
Stack<String>stk = new Stack<String>( ) ;
stk . push ( ” alpha ” ) ;
stk . push ( ” beta ” ) ;
S t r i n g s t r = stk . pop ( ) ;
✡ ✠
SELF-STUDY EXERCISE
EXERCISE 16.11 Write a class with only a main() method that modi-
ﬁes Figure 16.23 so that it uses the parameterized java.util.Stack<E>
class instead of the Stack class used there.
796 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
16.6.2 The List<E> interface
and the LinkedList<E> class
Thejava.util.LinkedList<E> is an implementation of a linked list
(Fig. 16.30). Like our implementation earlier in this chapt er, it contains
methods that can be used to deﬁne the standard stack and queue methods.
+add(in index : int, in o : E)
+addFirst(in o : E)
+addLast(in o : E)
+get(in index : int) : E
+getFirst() : E
+getLast() : E
+removeFirst() : E
+removeLast() : ELinkedList<E>+add(in index : int, in o : E)
+remove(in index : int) : E
+get(in index : int) : EAbstractSequentialList<E>
«interface»
List<E>
FIGURE 16.30 The
LinkedList<E> class implements
theList<E> interface. Only a partial
list of methods are shown.Many of the standard list-processing methods are deﬁned as p art of
thejava.util.List<E> interface. The advantage of deﬁning list op-
erations as an interface is that they can be implemented by a n umber of
data structures. Code for using the list methods can be writt en to work
independently of the data structure being used.
For example, the collections framework contains LinkedList<E> and
ArrayList<E> , both of which implement the List<E> interface. In
this section, we will demonstrate how to make appropriate us e of the
List<E> interface and data structures that implement it.
Suppose that a programmer is developing an application to tr ack ac-
tivity of employees working at a small company’s phone-in he lp desk.
The programmer has decided to use the LinkedList<E> data structure
to store objects of the PhoneRecord class that was deﬁned earlier in this
chapter and will use methods of the List<E> interface to manipulate the
data. A list seems to be an appropriate structure for this pro blem since
•An unknown (but relatively small) amount of data will be invo lved.
•The company wants the data stored in the order it is generated .
•The main use of the data will be to print out the list’s phone re cords.
The programmer might write a short method like that in Figure 16.31 to
demonstrate how the List<E> andLinkedList<E> structures will be
used.
☛ ✟
public s t a t i c void t e s t L i s t ( ) {
List<PhoneRecord >t h e L i s t = new LinkedList <PhoneRecord >( ) ;
// new A r r a y L i s t <P h o n e R e c o r d >( ) ; c o u l d a l s o b e u s e d .
t h e L i s t . add ( new PhoneRecord ( ”Roger M” ,”090−997−2918” ) ) ;
t h e L i s t . add ( new PhoneRecord ( ” Jane M” ,”090−997−1987” ) ) ;
t h e L i s t . add ( new PhoneRecord ( ” Stacy K” ,”090−997−9188” ) ) ;
t h e L i s t . add ( new PhoneRecord ( ”Gary G” ,”201−119−8765” ) ) ;
t h e L i s t . add ( new PhoneRecord ( ” Jane M” ,”090−997−1987” ) ) ;
System . out . p r i n t l n ( ” Testing a LinkedList L i s t ” ) ;
for ( PhoneRecord pr : t h e L i s t )
System . out . p r i n t l n ( pr ) ;
}// t e s t L i s t
✡ ✠
Figure 16.31: A method that demonstrates the interface List<E> and the
classLinkedList<E> .
Note that the statement
☛ ✟
List<PhoneRecord >t h e L i s t = new LinkedList <PhoneRecord >( ) ;
✡ ✠
SECTION 16.7 •Using the Set andMap Interfaces 797
declares a variable theList of interface type List<E> but assigns an ob-
ject of class type LinkedList<E> . This is appropriate because the class
implements the interface and the code uses only methods from the inter-
face. The class ArrayList<E> in the collections framework also imple-
ments the List<E> interface. It uses an array rather than a linked list to
store elements and has a constructor with an int parameter that sets the
size of the array. If the programmer knew that theList would contain
close to, but always less than, 100 elements, then it might be better to
declare:
☛ ✟
List<PhoneRecord >t h e L i s t = new ArrayList <PhoneRecord >(100);
✡ ✠
Also note the unusual looking for loop at the end of the method. This is a
new feature of Java 5.0 which can be used to simplify the codin g of loops
that iterate through every object in a collection of objects. T he statement The for–each loop
☛ ✟
for ( PhoneRecord pr : t h e L i s t ) { ∗∗∗ }
✡ ✠
should be thought of as executing the enclosed statements for each
PhoneRecord object, pr, in the theList data structure. In previous ver-
sions of Java, an interface named Iterator had to be used to enumerate
all the elements in a collection. The Iterator approach is more ﬂexible—
for example, it allows you to iterate through just some of the m embers of
the collection— and will therefore still have to be used for m ore complex
loops.
The output of the method will be:
☛ ✟
Roger M 090 −997−2918
Jane M 090 −997−1987
Stacy K 090 −997−9188
Gary G 201 −119−8765
Jane M 090 −997−1987
✡ ✠
In the next section we will examine two other structures in the collec-
tions framework, the Set interface and the Map interface.
JAVA EFFECTIVE DESIGN Code Reuse. Given the relative
difﬁculty of writing correct and efﬁcient list-processing algorithms,
applications that depend on lists should make use of library classes
whenever possible.
16.7 Using the Set andMap Interfaces
TheSet andMap interfaces are similar to the List interface in that there
are multiple classes in the collections framework that impl ement them.
798 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
16.7.1 Using the Set Interface.
TheSet interface is modeled after the set theory principles taught in math-
ematics. In mathematics, sets are groups of elements with a cl early deﬁned
algorithm for deciding if any given element is in any given se t. Elements
can be added to sets and can be removed from sets. Sets cannot h ave
duplicate elements; if an element is added to a set that alrea dy contains
an element equal to it, the new set still has a single such elem ent. The ele-
ments of a set have no natural order; two sets that have the sam e elements
listed in different orders are considered to be the same set.
In computer science and in Java, data structures that model se ts are
designed for large collections of data. Such data structure s have a method
that determines if an object is in a given set with an efﬁcient a lgorithm. For
large data sets, using such a method is much faster than itera ting through
a list. Sometimes, you may or may not be able to list the elemen ts of
a set data structure in some natural order, depending on how t he data
FIGURE 16.32 A partial list of
methods of the Set<E> interface.structure is implemented. An incomplete listing of the meth ods of the
Set<E> interface is given in the UML diagram in Figure 16.32.
TreeSet<E> andHashSet<E> are two classes in the collections
framework that implement the Set<E> interface. They both provide fast
operations to check whether an element is in a set. They also p rovide quick
insertion of an element into the set or removal of an element f rom a set. For
large sets—those having at least several thousand elements—w here there
are large numbers of insertions, deletions, and tests for wh ether elements
are in a set, linked lists would be much slower.
When using the Set<E> interface for a user-deﬁned class E, you will
likely want to override the deﬁnition of the equals() method from the
Object class in Ebecause that method is used when computing the Overriding methods
value of aSet.contains(anElement) . When using the TreeSet<E>
class for a user deﬁned class E, you should implement the compareTo()
method of the Comparable interface because it is used to order the el-
ements of E. In the next section, we will discuss the speciﬁc manner in
which elements are ordered. Finally, when using the HashSet<E> class
for a user deﬁned class E, you should override the hashCode() method
of theObject class because it is used HashSet<E> .Hash codes are in-
dexes that are computed from the particular object that is bei ng stored
in theHashSet . Given an object’s hash code, the object can be retrieved
directly, as we do with object’s stored in an array. However, we will not
discuss hash codes in any detail in this text.
Problem Statement
Let’s think about a simple example for using a set data struct ure. Sup-
pose that a programmer is developing an application for a lar ge com-
pany for maintaining a no–call list. The programmer has decided to use
theTreeSet<E> data structure to store objects of the PhoneRecord
class that was deﬁned earlier in this chapter and will use met hods of the
Set<E> interface to manipulate the data.
SECTION 16.7 •Using the Set andMap Interfaces 799
ATreeSet seems to be an appropriate structure for this problem, since
•A large amount of data will be involved.
•The company wants the PhoneRecord data stored in alphabeti-
cal order.
•The main use of the data will be to test whether names are in the
set.
The programmer might write a short method like that in Figure 16.33 to
demonstrate how the Set<E> andTreeSet<E> structures will be used.
☛ ✟
public s t a t i c void t e s t S e t ( ) {
Set<PhoneRecord >t h e S e t = new TreeSet <PhoneRecord >( ) ;
// new H a s h S e t <P h o n e R e c o r d >( ) ; c o u l d a l s o b e u s e d .
t h e S e t . add ( new PhoneRecord ( ”Roger M” ,”090−997−2918” ) ) ;
t h e S e t . add ( new PhoneRecord ( ” Jane M” ,”090−997−1987” ) ) ;
t h e S e t . add ( new PhoneRecord ( ” Stacy K” ,”090−997−9188” ) ) ;
t h e S e t . add ( new PhoneRecord ( ”Gary G” ,”201−119−8765” ) ) ;
t h e S e t . add ( new PhoneRecord ( ” Jane M” ,”090−987−6543” ) ) ;
System . out . p r i n t l n ( ” Testing TreeSet and Set ” ) ;
PhoneRecord ph1 =
new PhoneRecord ( ”Roger M” ,”090−997−2918” ) ;
PhoneRecord ph2 =
new PhoneRecord ( ”Mary Q” ,”090−242−3344” ) ;
System . out . p r i n t ( ”Roger M contained in t h e S e t i s ” ) ;
System . out . p r i n t l n ( t h e S e t . contains ( ph1 ) ) ;
System . out . p r i n t ( ”Mary Q contained in t h e S e t i s ” ) ;
System . out . p r i n t l n ( t h e S e t . contains ( ph2 ) ) ;
for ( PhoneRecord pr : t h e S e t )
System . out . p r i n t l n ( pr ) ;
}// t e s t S e t
✡ ✠
Figure 16.33: A method that demonstrates use of the interfac eSet<E>
and the class TreeSet<E> .
In order for the testSet() method to work as we would like, we need
to have the PhoneRecord class implement the Comparable interface
and to override the equals() method. For this example, it is reason-
able to assume that the name ﬁeld of PhoneRecord objects should be
unique so that it can be used to decide if two PhoneRecord objects are
equal. The name ﬁeld of PhoneRecord can also be used to deﬁne the
800 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
other two methods discussed above. Thus, add the following c ode to the
PhoneRecord class.
☛ ✟
public boolean equals ( Object ob ) {
return name . equals ( ( ( PhoneRecord ) ob ) . getName ( ) ) ;
}// e q u a l s ( )
public i n t compareTo ( Object ob ) {
return name . compareTo ( ( ( PhoneRecord ) ob ) . getName ( ) ) ;
}// c o m p a r e T o ( )
public i n t hashCode ( ) {
return name . hashCode ( ) ;
}// h a s h C o d e ( )
✡ ✠
The output of the TestSet() method is listed below:
☛ ✟
Testing TreeSet and Set
Roger M i s contained in t h e S e t i s true
Mary Q i s contained in t h e S e t i s f a l s e
Gary G 201 −119−8765
Jane M 090 −997−1987
Roger M 090 −997−2918
Stacy K 090 −997−9188
✡ ✠
Notice that Jane M PhoneRecord appears only once in the listing of
elements in the set.
16.7.2 Using the Map<K,V> Interface.
TheMap<K,V> interface is modeled after looking up deﬁnitions for words
in a dictionary. In computer science, maps are considered to b e a collection
of pairs of elements. A pair consists of a key that corresponds to a word
being looked up and a value corresponding to the deﬁnition of the word.
Pairs can be added to maps and can be removed from maps. Maps ca nnot
have distinct pairs with the same keys; if you attempt to add a pair to a
FIGURE 16.34 A partial list of
methods of Map<K,V> .map that already contains a pair with the same key, the second pair will
replace the ﬁrst. An incomplete listing of the methods of the Map<K,V>
interface is given in the UML diagram in Figure 16.34. TreeMap<K,V>
andHashMap<K,V> are two classes in the collections framework that
implement the Map<K,V> interface.
Let’s now consider a simple example of using a map data struct ure.
Suppose that our programmer has been hired by a large company to de-
velop an application that maintains an electronic phone lis t for company
employees. The programmer has decided to use the TreeMap<E> data
structure to store pairs of names and telephone numbers and w ill use
methods of the Map<V,K> interface to manipulate the data.
SECTION 16.8 •The Binary Search Tree Data Structure 801
ATreeMap seems like an appropriate data structure for this problem,
since
•A large amount of data will be involved.
•The company wants the PhoneRecord data stored in alphabeti-
cal order.
•The main use of the data will be to use names to access telephon e
numbers.
The programmer might write a short method like that in Figure 16.35 to
demonstrate how the Map<K,V> andTreeMap<K,V> structures will be
used.
☛ ✟
public s t a t i c void testMap ( ) {
Map<String , String >theMap =
new TreeMap <String , String >( ) ;
// new HashMap <K , V>( ) ; c o u l d a l s o b e u s e d
theMap . put ( ”Roger M” ,”090−997−2918” ) ;
theMap . put ( ” Jane M” ,”090−997−1987” ) ;
theMap . put ( ” Stacy K” ,”090−997−9188” ) ;
theMap . put ( ”Gary G” ,”201−119−8765” ) ;
theMap . put ( ” Jane M” ,”090−233−0000” ) ;
System . out . p r i n t l n ( ” Testing TreeMap and Map” ) ;
System . out . p r i n t ( ” Stacy K has phone ” ) ;
System . out . p r i n t ( theMap . get ( ” Stacy K” ) ;
System . out . p r i n t ( ” Jane M has phone ” ) ;
System . out . p r i n t ( theMap . get ( ” Jane M” ) ;
}// t e s t L i s t
✡ ✠
Figure 16.35: A method that demonstrates use of the interfac eMap<K,V>
and the class TreeMap<K,V> .
The output for this test program is:
☛ ✟
Stacy K has phone 090 −997−9188
Jane M has phone 090 −233−0000
✡ ✠
Notice the the second phone number for Jane M is the one that is stored
in the data structure.
16.8 The Binary Search Tree Data Structure
To gain some appreciation of what binary search trees are and why they
are useful in implementing the Set andMap interfaces, let’s make a few
comments about implementing very simple versions of these s tructures.
Like a linked list, a binary tree is a data structure consisting of a col-
lection of nodes that are linked together by references from one node to
another. However, unlike a linked list, each node in a binary t ree contains
references to two other other nodes, ( left andright ), corresponding to
the left- and right-subtrees growing out of a particular nod e. A subtree is
a tree that is part of larger tree. This creates a tree-like st ructure, as shown
802 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
in Figure 16.36. Note that some of the references to other nod es might
be null. The trunk of the tree corresponds to the node labeled root . In
Figure 16.36: A binary search tree
ofPhoneTreeNode s.
computer science, trees are almost always drawn upside down . Thus the
trunk of the tree, root , is at the top of the ﬁgure.
If we assume that the objects contained in a tree are from a class that
implements the Comparable interface, then a binary search tree is a bi-
nary tree in which the objects are ordered so that the object at a particular
node is greater than the objects stored in its left subtree and less than the
objects stored in its right subtree.
Figure 16.36 shows a binary search tree with the phone list da ta that we
have used throughout the chapter. Objects are compared by com paring
the names alphabetically. From the ﬁgure it is easy to see tha t searching
for a object should start at the root of the tree. At each node, e xamining the
name at the node will tell you whether you have found the object there.
Otherwise, by checking the name at the node, you can decide wh ich sub-
tree the data could be in, and you can traverse either left or r ight through
each level of the tree. One can deduce that if the tree is balan ced—that is,
if at most nodes the size of the left subtree is about the same s ize as the
right subtree—searching the tree much faster than searching a linked list.
This is one of the main advantages of using a binary search tre e over a
linked list.
TheTreeSet andTreeMap classes implement sophisticated algo-
rithms for inserting and removing data from a tree, which gua rantees
that the tree remains relatively balanced. The details of th ese algorithms
are beyond the scope of this book, but would be a subject of stud y in a
standard Data Structures and Algorithms course.
We will conclude this subsection by giving a brief outline of an imple-
mentation of a simple binary search tree that stores our phon e list data.
SECTION 16.8 •The Binary Search Tree Data Structure 803
Like our LinkedList example, you need to deﬁne a node class and a
tree class. The node class with unimplemented methods, woul d look like:
☛ ✟
public c l a s s PhoneTreeNode {
private S t r i n g name ;
private S t r i n g phone ;
private PhoneTreeNode l e f t ;
private PhoneTreeNode r i g h t ;
public PhoneTreeNode ( S t r i n g nam, S t r i n g pho ) { }
public void setData ( S t r i n g nam, S t r i n g pho ) { }
public S t r i n g getName ( ) { }
public boolean contains ( S t r i n g nam, S t r i n g pho ) { }
public void i n s e r t ( S t r i n g nam, S t r i n g pho ) { }
// o t h e r m e t h o d s
}// P h o n e T r e e N o d e
✡ ✠
The tree structure itself contains a reference to a node:
☛ ✟
public c l a s s PhoneTree {
private PhoneTreeNode root ;
public PhoneTree ( ) { }
public boolean contains ( S t r i n g nam, S t r i n g pho ) { }
public void i n s e r t ( S t r i n g nam, S t r i n g pho ) { }
// o t h e r m e t h o d s
}// P h o n e T r e e N o d e
✡ ✠
We will implement only the two contains() methods. The PhoneTree
version is very simple:
☛ ✟
public boolean contains ( S t r i n g nam, S t r i n g pho ) {
i f( root == null )return f a l s e ;
else return root . contains (nam, pho ) ;
}// c o n t a i n s ( ) i n P h o n e T r e e
✡ ✠
The implementation of the contains() method of PhoneTreeNode is
only slightly more involved.
☛ ✟
public boolean contains ( S t r i n g nam, S t r i n g pho ) {
i f(name . equals (nam ) )
return true ;
else i f (name . compareTo (nam) <0){// n a m e <nam
i f( r i g h t == null )return f a l s e ;
else return r i g h t . contains (nam, pho ) ;
}else{ {\ c o l o r{cyan}// n a m e >nam}
i f( l e f t == null )return f a l s e ;
else return l e f t . contains (nam, pho ) ;
}
}// c o n t a i n s ( ) i n P h o n e T r e e N o d e
✡ ✠
804 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
CHAPTER SUMMARY In this chapter, we have given you a brief introduction to the c oncept of
a dynamic data structure and tried to illustrate how they wor k and why
they are useful for organizing and managing large amounts of data. We
also introduced you to an important new language feature int roduced in
Java 5.0, the concept of generic types. Obviously, we have on ly scratched
the surface of the important topic of data structures and the algorithms
used to manage them. For a broader and deeper treatment of thi s subject,
you will have to take a Data Structures and Algorithms course, which is a
fundamental course in most computer science curricula.
Technical Terms
Abstract Data Type
(ADT)
binary search tree
data structure
dequeue
dynamic structure
enqueue
ﬁrst-in–ﬁrst-out
(FIFO)
generic typeJava collections
framework
key
last-in–ﬁrst-out
(LIFO)
link
list
linked list
pop
pushqueue
reference
self-referential object
stack
static structure
traverse
value
vector
Summary of Important Points
•Adata structure is used to organize data and make them more efﬁcient
to process. An array is an example of a static structure , since its size
does not change during a program’s execution. A vector is an e xample
of a dynamic structure , one whose size can grow and shrink during a
program’s execution.
•Alinked list is a linear structure in which the individual nodes of the lis t
are joined together by references. A reference is a variable that refers to
an object. Each node in the list has a linkvariable that refers to another
node. An object that can refer to the same kind of object is said t o be
self-referential .
•TheNode class is an example of a self-referential class. It contains a
link variable that refers to a Node . By assigning references to the link
variable, Node s can be chained together into a linked list. In addition
to their link variables, Node s contain data variables, which should be
accessible through public methods.
•Depending on the use of a linked list, nodes can be inserted at various
locations in the list: at the head, the end, or in the middle of the list.
•Traversal algorithms must be used to access the elements of a singly
linked list. To traverse a list you start at the ﬁrst node and f ollow the
links of the chain until you reach the desired node.
•Depending on the application, nodes can be removed from the f ront,
rear, or middle of a linked list. Except for the front node, tr aversal
algorithms are used to locate the desired node.
•In developing list algorithms, it is important to test them th oroughly.
Ideally, you should test every possible combination of inser tions and
CHAPTER 16 •Solutions to Self-Study Exercises 805
removals that the list can support. Practically, you should test every
independent case of insertions and removals that the list su pports.
•AnAbstract Data Type (ADT) is a concept that combines two elements:
A collection of data, and the operations that can be performe d on the
data. For the list ADT, the data are the values ( Object s orints)
contained in the nodes that make up the list, and the operatio ns are
insertion, removal, and tests of whether the list is empty.
•In designing an ADT, it’s important to provide a public interf ace that
can be used to access the ADT’s data. The ADT’s implementatio n de-
tails should not matter to the user and should, therefore, be hidden. A
Java class deﬁnition, with its public andprivate aspects, is perfectly
suited to implement an ADT.
•Astack is a list that allows insertions and removals only at the fron t
of the list. A stack insertion is called a push and a removal is called a
pop. The ﬁrst element in a stack is usually called the top of the st ack.
TheStack ADT can easily be deﬁned as a subclass of List . Stacks are
used for managing the method call and return in most programm ing
languages.
•Aqueue is a list that only allows insertions at the rear and removals
from the front of a list. A queue insertion is called enqueue , and a re-
moval is called dequeue . TheQueue ADT can easily be deﬁned as a
subclass of List . Queues are used for managing the various lists used
by the CPU scheduler—such as the ready, waiting, and blocked q ueues.
•Abinary search tree is a binary tree in which the ordered data stored at
any node is greater than all data stored in the left subtree an d is less
than all data stored in the right subtree.
SOLUTIONS TO
SELF-STUDY EXERCISESSOLUTION 16.1
☛ ✟
Node node = new Node( new S t r i n g ( ” Hello ” ) ) ;
✡ ✠
SOLUTION 16.2
☛ ✟
Node node = new Node( new Student ( ” William ” ) ) ;
✡ ✠
SOLUTION 16.3
☛ ✟
PhoneListNode newNode =
new PhoneListNode ( ” B i l l C” ,”111−202−3331” ) ;
nodeptr . setNext (newNode ) ;
✡ ✠
806 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
SOLUTION 16.4 The following condition is too general. It will cause the loop to
exit as soon as a nonnull node is encountered, whether or not the node ma tches
the one being sought.
☛ ✟
( ( current . getNext ( ) != null )||
( ! current . getName ( ) . equals (name ) ) )
✡ ✠
SOLUTION 16.5 ThePhoneList program will generate the following output,
which has been edited slightly to improve its readability:
☛ ✟
Phone Directory
−−−−−−−−−−−−−−−
Roger M 997 −0020 Roger W 997 −0086 Rich P 997 −0010
Jane M 997 −2101 Stacy K 997 −2517
Looking up numbers by name
Roger M 997 −0020
Rich P 997 −0010
Stacy K 997 −2517
Sorry . No entry for Mary P
Removed Rich P 997 −0010
Phone Directory
−−−−−−−−−−−−−−−
Roger M 997 −0020 Roger W 997 −0086 Jane M 997 −2101
Stacy K 997 −2517
Removed Roger M 997 −0020
Phone Directory
−−−−−−−−−−−−−−−
Roger W 997 −0086 Jane M 997 −2101 Stacy K 997 −2517
Removed Stacy K 997 −2517
Phone Directory
−−−−−−−−−−−−−−−
Roger W 997 −0086 Jane M 997 −2101
Removed Jane M 997 −2101
Phone Directory
−−−−−−−−−−−−−−−
Roger W 997 −0086
Sorry . No entry for Jane M
Phone Directory
−−−−−−−−−−−−−−−
Roger W 997 −0086
Removed Roger W 997 −0086
Phone Directory
−−−−−−−−−−−−−−−
Phone l i s t i s empty
✡ ✠
CHAPTER 16 •Solutions to Self-Study Exercises 807
SOLUTION 16.6 Executing the following method calls will test whether it is
possible to insert items into a list after items have been remov ed:
☛ ✟
// C r e a t e a n d i n s e r t s o m e n o d e s
PhoneList l i s t = new PhoneList ( ) ;
l i s t . i n s e r t ( new PhoneListNode ( ”Roger M” ,”997−0020” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ”Roger W ” ,”997−0086” ) ) ;
System . out . p r i n t l n ( l i s t . remove ( ”Roger M” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Rich P” ,”997−0010” ) ) ;
System . out . p r i n t l n ( l i s t . remove ( ”Roger W ” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Jane M” ,”997−2101” ) ) ;
l i s t . i n s e r t ( new PhoneListNode ( ” Stacy K” ,”997−2517” ) ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Jane M” ) ) ;
System . out . p r i n t l n ( l i s t . remove ( ” Stacy K” ) ) ;
l i s t . p r i n t ( ) ;
// L i s t s h o u l d b e e m p t y
✡ ✠
SOLUTION 16.7 The List ADT program will produce the following output:
☛ ✟
Generic L i s t
−−−−−−−−−−−−−−−
Hello World
8647
Roger M 997 −0020
Jane M 997 −2101
Stacy K 997 −2517
Removed Stacy K 997 −2517
Generic L i s t :
Hello World
8647
Roger M 997 −0020
Jane M 997 −2101
Removed Jane M 997 −2101
Generic L i s t :
Hello World
8647
Roger M 997 −0020
Removed Hello World
Generic L i s t :
8647
Roger M 997 −0020
✡ ✠
808 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
SOLUTION 16.8 Executing the following method calls will test whether it is
possible to insert items into a List after items have been removed:
☛ ✟
// C r e a t e a n d i n s e r t s o m e n o d e s
L i s t l i s t = new L i s t ( ) ;
l i s t . i n s e r t A t F r o n t ( new PhoneRecord ( ”Roger M” ,”997−0020” ) ) ;
l i s t . i n s e r t A t F r o n t ( new PhoneRecord ( ”Roger W ” ,”997−0086” ) ) ;
System . out . p r i n t l n ( ” Current L i s t Elements ” ) ;
l i s t . p r i n t ( ) ;
Object o = l i s t . removeLast ( ) ; // R e m o v e l a s t e l e m e n t
l i s t . i n s e r t A t F r o n t ( o ) ; // I n s e r t a t t h e f r o n t o f t h e l i s t
System . out . p r i n t l n ( ” Current L i s t Elements ” ) ;
l i s t . p r i n t ( ) ;
o = l i s t . removeFirst ( ) ;
System . out . p r i n t l n ( ”Removed ” + o . t o S t r i n g ( ) ) ;
o = l i s t . removeFirst ( ) ;
System . out . p r i n t l n ( ”Removed ” + o . t o S t r i n g ( ) ) ;
l i s t . insertAtRear ( o ) ;
System . out . p r i n t l n ( ” Current L i s t Elements ” ) ;
l i s t . p r i n t ( ) ; // L i s t s h o u l d h a v e o n e e l e m e n t
✡ ✠
SOLUTION 16.9 Thepeek() method should just return the ﬁrst node without
deleting it:
☛ ✟
public Object peek ( ) {
return head ;
}
✡ ✠
SOLUTION 16.10 ThepeekLast() method can be modeled after the List.re-
moveLast() method:
☛ ✟
public Object peekLast ( ) {
i f( isEmpty ( ) )
return null ;
else{
Node current = head ; // S t a r t a t h e a d o f l i s t
while ( current . getNext ( ) != null )// F i n d e n d o f l i s t
current = current . getNext ( ) ;
return current ;
// R e t u r n l a s t n o d e
}
}// p e e k L a s t ( )
✡ ✠
CHAPTER 16 •Exercises 809
SOLUTION 16.11 The following class tests the java.util.Stack<E> class:
☛ ✟
import java . u t i l . ∗;
public c l a s s StackTest {
public s t a t i c void main ( S t r i n g argv [ ] ) {
Stack<Character >s t a c k = new Stack<Character >( ) ;
S t r i n g s t r i n g = ” Hello t h i s i s a t e s t s t r i n g ” ;
System . out . p r i n t l n ( ” S t r i n g : ” + s t r i n g ) ;
for (i n t k = 0 ; k <s t r i n g . length ( ) ; k++)
s t a c k . push ( new Character ( s t r i n g . charAt ( k ) ) ) ;
Character ch = null ;
S t r i n g reversed = ””;
while ( ! s t a c k . empty ( ) ) {
ch = s t a c k . pop ( ) ;
reversed = reversed + ch . charValue ( ) ;
}
System . out . p r i n t l n ( ” Reversed S t r i n g : ” + reversed ) ;
}// m a i n ( )
}// S t a c k T e s t c l a s s
✡ ✠
EXERCISES EXERCISE 16.1 Explain the difference between each of the following pairs of
terms:
a.Stack and queue .
b.Static structure and dynamic structure .
c.Data structure and Abstract Data Type .d.Push and pop.
e.Enqueue and dequeue .
f.Linked list and node . Note: For programming exercises,
ﬁrst draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.EXERCISE 16.2 Fill in the blanks.
a. An Abstract Data Type consists of two main parts: and .
b. An object that contains a variable that refers to an object of th e same class is a
.
c. One application for a is to manage the method call and returns in a
computer program.
d. One application for a is to balance the parentheses in an arithmetic
expression.
e. A operation is one that starts at the beginning of a list and processe s
each element.
f. A vector is an example of a data structure.
g. An array is an example of a data structure.
h. By default, the initial value of a reference variable is .
EXERCISE 16.3 Add a removeAt() method to the List class to return the
object at a certain index location in the list. This method should t ake an int
parameter, specifying the object’s position in the list, and it s hould return an
Object .
EXERCISE 16.4 Add an insertAt() method to the List class that will insert
an object at a certain position in the list. This method should take two parameters,
theObject to be inserted, and an int to designate where to insert it. It should
return a boolean to indicate whether the insertion was successful.
810 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
EXERCISE 16.5 Add a removeAll() method to the List class. This void
method should remove all the members of the list.
EXERCISE 16.6 Write an int method named size() that returns the number
of elements in a List .
EXERCISE 16.7 Write an boolean method named contains(Object o)
that returns true if itsObject parameter is contained in the list.
EXERCISE 16.8 The head of a list is the ﬁrst element in the list. The tailof a list
consists of all the elements except the head. Write a method name dtail() that
returns a reference to the tail of the list. Its return value sh ould be Node .
EXERCISE 16.9 Write a program that uses the List ADT to store a list of 100
random ﬂoating-point numbers. Write methods to calculate the av erage of the
numbers.
EXERCISE 16.10 Write a program that uses the List ADT to store a list of
Student records, using a variation of the Student class deﬁned in Chapter 11.
Write a method to calculate the mean grade point average for all s tudents in the
list.
EXERCISE 16.11 Write a program that creates a copy of a List . It is necessary
to copy each node of the list. This will require that you create new nodes that
are copies of the nodes in the original list. To simplify this task , deﬁne a copy
constructor for your node class and then use that to make copies of eac h node of
the list.
EXERCISE 16.12 Write a program that uses a Stack ADT to determine if a
string is a palindrome—spelled the same way backward and forwa rd.
EXERCISE 16.13 Design and write a program that uses a Stack to determine
whether a parenthesized expression is well-formed. Such an exp ression is well
formed only if there is a closing parenthesis for each opening pare nthesis.
EXERCISE 16.14 Design and write a program that uses Stack s to determine
whether an expression involving both parentheses and square br ackets is well
formed.
EXERCISE 16.15 Write a program that links two lists together, appending the
second list to the end of the ﬁrst list.
EXERCISE 16.16 Design a Stack class that uses a Vector instead of a linked
list to store its elements. This is the way Java’s Stack class is deﬁned.
EXERCISE 16.17 Design a Queue class that uses a Vector instead of a linked
list to store its elements.
EXERCISE 16.18 Write a program that uses the List<E> andLinkedList<E>
classes to store a list of Student records, using a variation of the Student class
deﬁned in Chapter 11. Write a method to calculate the mean grad e point average
for all students in the list.
EXERCISE 16.19 Write an implementation of the insert() method of the
PhoneTree class described at the end of this chapter.
EXERCISE 16.20 Write an implementation of the insert() method of the
PhoneTreeNode class described at the end of this chapter.
CHAPTER 16 •Exercises 811
EXERCISE 16.21 Challenge: Design a List class, similar in functionality to the
one we designed in this chapter, that uses an array to store the list’s elements. Set
it up so that the middle of the array is where the ﬁrst element is placed. That
way you can still insert at both the front and rear of the list. One l imitation of this
approach is that, unlike a linked list, an array has a ﬁxed size . Allow the user to
set the initial size of the array in a constructor, but if the arra y becomes full, don’t
allow any further insertions.
EXERCISE 16.22 Challenge: Add a method to the program in the previous
exercise that lets the user increase the size of the array used to store the list.
EXERCISE 16.23 Challenge: Recursion is a useful technique for list processing.
Write recursive versions of the print() method and the lookup-by-name method
for the PhoneList . (Hint : The base case in processing a list is the empty list. The
recursive case should handle the head of the list and then recur se on the tail of the
list. The tail of the list is everything but the ﬁrst element.)
EXERCISE 16.24 Challenge: Design an OrderedList class. An ordered list is
one that keeps its elements in order. For example, if it’s an ordere d list of integers,
then the ﬁrst integer is less than or equal to the second, the sec ond is less than or
equal to the third, and so on. If it’s an ordered list of employees, t hen perhaps
the employees are stored in order according to their social securi ty numbers. The
OrderedList class should contain an insert(Object o) method that inserts
its object in the proper order. One major challenge in this project is designing
your class so that it will work for any kind of object. ( Hint: Deﬁne an Orderable
interface that deﬁnes an abstract precedes() method. Then deﬁne a subclass of
Node that implements Orderable . This will let you compare any two Node s to
see which one comes before the other.)
812 CHAPTER 16 •Data Structures: Lists, Stacks, and Queues
Appendix A
Coding Conventions
This appendix covers various aspects of programming style and cod ing conven-
tions. It follows the conventions suggested in the Java Language Sp eciﬁcation
(http://java.sun.com/docs/books/jls/ ), which is summarized on Sun’s
Java Web site ( http://java.sun.com/docs/ ). The conventions have been
modiﬁed somewhat to ﬁt the needs of an academic programming course . For
further details see
☛ ✟
http : //java . sun . com/docs/codeconv/index . html
✡ ✠
Coding conventions improve the readability and maintainabilit y of the code.
Because maintenance is often done by programmers who did not have a hand in
designing or writing the original code, it is important that the c ode follow certain
conventions. For a typical piece of commercial software, much more t ime and
expense are invested in maintaining the code than in creating the code.
Comments
Java recognizes two types of comments: C-style comments use the same syntax
found in C and C++. They are delimited by /*...*/and//. The ﬁrst set of
delimiters is used to delimit a multiline comment. The Java com piler will ignore
all text that occurs between /*and*/. The second set of delimiters is used for a
single-line comment. Java will ignore all the code on the rest of th e line following
a double slash ( //). C-style comments are called implementation comments and are
mainly used to describe the implementation of your code.
Documentation comments are particular to Java. They are delimited by
/**...*/. These are used mainly to describe the speciﬁcation or design of
the code rather than its implementation. When a ﬁle containing d ocumentation
comments is processed by the javadoc tool that comes with the Java Development
Kit (JDK), the documentation comments will be incorporated into a n HTML doc-
ument. This is how online documentation has been created for the Ja va library
classes.
Implementation Commenting Guidelines
Implementation (C-style) comments should be used to provide an ov erview of the
code and to provide information that is not easily discernible from the code itself.
They should not be used as a substitute for poorly written or poorly des igned
code.
813
814 APPENDIX A •Coding Conventions
In general, comments should be used to improve the readability of the code. Of
course, readability depends on the intended audience. Code tha t’s easily readable
by an expert programmer may be completely indecipherable to a n ovice. Our
commenting guidelines are aimed at someone who is just learning to program in
Java.
Block Comments
Ablock comment orcomment block is a multiline comment that is used to describe
ﬁles, methods, data structures, and algorithms:
☛ ✟
/∗
∗M u l t i l i n e c o m m e n t b l o c k
∗/
✡ ✠
Single-Line Comments
A single-line comment can be delimited either by //or by/*...*/. The//is
also used to comment out a line of code that you want to skip during a particular
run. The following example illustrates these uses:
☛ ✟
/∗S i n g l e l i n e c o m m e n t ∗/
System . out . p r i n t l n ( ” Hello ” ) ; // E n d o f l i n e c o m m e n t
// S y s t e m . o u t . p r i n t l n ( ” G o o d b y e ” ) ;
✡ ✠
Note that the third line is commented out and would be ignored by the Java
compiler.
In this text, we generally use slashes for single-line and end -of-line comments.
And we frequently use end-of-line comments to serve as a runnin g commentary
on the code itself. These types of comments serve a pedagogical pur pose—to teach
you how the code works. In a “production environment” it would be unusu al to
ﬁnd this kind of running commentary.
Java Documentation Comments
Java’s online documentation has been generated by the javadoc tool that comes
with the Java Development Kit (JDK). To conserve space, we use d ocumentation
comments only sparingly in the programs listed in this textbook it self. However,
javadoc comments are used more extensively to document the online source
code that accompanies the textbook.
Documentation comments are placed before classes, interfaces, constructors,
methods, and ﬁelds. They generally take the following form:
☛ ✟
/∗∗
∗T h e E x a m p l e c l a s s b l a h b l a h
∗@ a u t h o r J . P r o g r a m m e r
∗/
public c l a s s Example {. . .
✡ ✠
APPENDIX A •Coding Conventions 815
Note how the class deﬁnition is aligned with the beginning of the c omment.
Javadoc comments use special tags, such as author and param , to identify certain
elements of the documentation. For details on javadoc , see
☛ ✟
http : //java . sun . com/ j 2 s e /1.5.0/ docs/tooldocs/
✡ ✠
Indentation and White Space
The use of indentation and white space helps to improve the reada bility of the
program. White space refers to the use of blank lines and blank space in a program.
It should be used to separate one program element from another, wit h the goal
being to draw attention to the important elements of the program.
•Use a blank line to separate method deﬁnitions and to separate a class’s in-
stance variables from its methods.
•Use blank spaces within expressions and statements to enhanc e their readabil-
ity.
•Be consistent in the way you use white space in your program.
Code should be indented in a way that shows the logical structure of the pro-
gram. You should use a consistent number of spaces as the size of the indentation
tab. The Java Language Speciﬁcation recommends four spaces.
In general, indentation should represent the contained in relationships within
the program. For example, a class deﬁnition contains declaration s for instance
variables and deﬁnitions of methods. The declarations and deﬁni tions should be
indented by the same amount throughout the class deﬁnition. The s tatements
contained in the body of a method deﬁnition should be indented:
☛ ✟
public void instanceMethod ( ) {
System . out . p r i n t l n ( ” Hello ” ) ;
return ;
}
✡ ✠
An if statement contains an if clause and an else clause, which should be indented:
☛ ✟
i f( condition )
System . out . p r i n t l n ( ” I f part ” ) ; // I f c l a u s e
else
System . out . p r i n t l n ( ” Else part ” ) ; // E l s e c l a u s e
✡ ✠
The statements contained in the body of a loop should be indented:
☛ ✟
for (i n t k = 0 ; k <1 0 0 ; k++) {
System . out . p r i n t l n ( ” Hello ” +’ k ’) ; // L o o p b o d y
}
✡ ✠
Finally, indentation should be used whenever a statement or exp ression is too
long to ﬁt on a single line. Generally, lines should be no longer th an 80 characters.
816 APPENDIX A •Coding Conventions
Naming Conventions
The choice of identiﬁers for various elements within a program can help improve
the readability of the program. Identiﬁers should be descripti ve of the element’s
purpose. The name of class should be descriptive of the class’s role or function.
The name of a method should be descriptive of what the method does.
The way names are spelled can also help improve a program’s reada bility. Ta-
ble A.1 summarizes the various conventions recommended by the Ja va Language
Speciﬁcation and followed by professional Java programmers.
TABLE A.1 Naming rules for Java identiﬁers.
Identiﬁer Type Naming Rule Example
Class Nouns in mixed case with the ﬁrst OneRowNim
letter of each internal word capitalized. TextField
Interfaces Same as class names. Many interface names Drawabl e
end with the sufﬁx able. ActionListener
Method Verbs in mixed case with the ﬁrst letter in actionPerform ed()
lowercase and the ﬁrst letter of internal sleep()
words capitalized. insertAtFront()
Instance Variables Same as method names. The name should maxWid th
be descriptive of how the variable is used. isVisible
Constants Constants should be written in uppercase with MAX LENGTH
internal words separated by . XREF
Loop Variables Temporary variables, such as loop variables, int k ;
may have single character names: i, j, k. int i;
Use of Braces
Curly braces { } are used to mark the beginning and end of a block of code.
They are used to demarcate a class body, a method body, or simply to combine a
sequence of statements into a single code block. There are two con ventional ways
to align braces and we have used both in the text. The opening and closing brace
may be aligned in the same column with the enclosed statements i ndented:
☛ ✟
public void sayHello ( )
{
System . out . p r i n t l n ( ” Hello ” ) ;
}
✡ ✠
This is the style that’s used in the ﬁrst part of the book, because i t’s easier for
someone just learning the syntax to check that the braces match up.
APPENDIX A •Coding Conventions 817
Alternatively, the opening brace may be put at the end of the lin e where the
code block begins, with the closing brace aligned under the begi nning of the line
where the code block begins:
☛ ✟
public void sayHello ( ) {
System . out . p r i n t l n ( ” Hello ” ) ;
}
✡ ✠
This is the style that’s used in the last two parts of the book, and i t seems the style
preferred by professional Java programmers.
Sometimes even with proper indentation, it it difﬁcult to tell wh ich closing
brace goes with which opening brace. In those cases, you should put an end-
of-line comment to indicate what the brace closes:
☛ ✟
public void sayHello ( ) {
for (i n t k =0; k <1 0 ; k++) {
System . out . p r i n t l n ( ” Hello ” ) ;
}// f o r l o o p
}// s a y H e l l o ( )
✡ ✠
File Names and Layout
Java source ﬁles should have the .java sufﬁx, and Java bytecode ﬁles should have
the.class sufﬁx.
A Java source ﬁle can only contain a single public class. Private classes and
interfaces associated with a public class can be included in t he same ﬁle.
Source File Organization Layout
All source ﬁles should begin with a comment block that contains imp ortant iden-
tifying information about the program, such as the name of the ﬁle, author, date,
copyright information, and a brief description of the classes in t he ﬁle. In the
professional software world, the details of this “boilerplate” com ment will vary
from one software house to another. For the purposes of an academic comp uting
course, the following type of comment block would be appropriate:
☛ ✟
/∗
∗F i l e n a m e : E x a m p l e . j a v a
∗A u t h o r : J . P r o g r a m m e r
∗D a t e : A p r i l , 2 0 1 9 9 9
∗D e s c r i p t i o n : T h i s p r o g r a m i l l u s t r a t e s b a s i c
∗ c o d i n g c o n v e n t i o n s .
∗/
✡ ✠
The beginning comment block should be followed by any package and i mport
statements used by the program:
☛ ✟
package java . mypackage ;
import java . awt . ∗;
✡ ✠
818 APPENDIX A •Coding Conventions
The package statement should only be used if the code in the ﬁle belongs to the
package. None of the examples in this book use the package stateme nt. The import
statement allows you to use abbreviated names to refer to the li brary classes used
in your program. For example, in a program that imports java.awt. *we can
refer to the java.awt.Button class as simply Button . If the import statement
were omitted, we would have to use the fully qualiﬁed name.
Theimport statements should be followed by the class deﬁnitions contained
in the ﬁle. Figure A–1 illustrates how a simple Java source ﬁle s hould be formatted
and documented.
☛ ✟
/∗
∗F i l e n a m e : E x a m p l e . j a v a
∗A u t h o r : J . P r o g r a m m e r
∗D a t e : A p r i l , 2 0 1 9 9 9
∗D e s c r i p t i o n : T h i s p r o g r a m i l l u s t r a t e s b a s i c
∗ c o d i n g c o n v e n t i o n s .
∗/
import java . awt . ∗;
/∗∗
∗T h e E x a m p l e c l a s s i s a n e x a m p l e o f a s i m p l e
∗ c l a s s d e f i n i t i o n .
∗@ a u t h o r J . P r o g r a m m e r
∗/
public c l a s s Example {
/∗∗ D o c c o m m e n t f o r i n s t a n c e v a r i a b l e , v a r 1 ∗/
public i n t var1 ;
/∗∗
∗C o n s t r u c t o r m e t h o d d o c u m e n t a t c o m m e n t d e s c r i b e s
∗ w h a t t h e c o n s t r u c t o r d o e s .
∗/
public Example ( ) {
// . . . m e t h o d i m p l e m e n t a t i o n g o e s h e r e
}
/∗∗
∗ An i n s t a n c e M e t h o d ( ) d o c u m e n t a t i o n c o m m e n t d e s c r i b e s
∗ w h a t t h e m e t h o d d o e s .
∗ @ p a r a m N i s a p a r a m e t e r t h a n . . . .
∗ @ r e t u r n T h i s m e t h o d r e t u r n s b l a h b l a h
∗/
public i n t instanceMethod ( i n t N ){
// . . . m e t h o d i m p l e m e n t a t i o n g o e s h e r e }
}
}// E x a m p l e
✡ ✠
Figure A–1: A sample Java source ﬁle.
APPENDIX A •Coding Conventions 819
Statements
Declarations
There are two kinds of declaration statements: ﬁeld declarati ons, which include a
class’s instance variables, and local variable declarations.
•Put one statement per line, possibly followed by an end-of-line com ment if the
declaration needs explanation.
•Initialize local variables when they are declared. Instance variables are given
default initializations by Java.
•Place variable declarations at the beginning of code blocks in wh ich they are
used rather than interspersing them throughout the code block.
The following class deﬁnition illustrates these points:
☛ ✟
public c l a s s Example {
private i n t s i z e = 0 ; // Window l e n g t h a n d w i d t h
private i n t area = 0 ; // Window ’ s c u r r e n t a r e a
public void myMethod ( ) {
i n t mouseX = 0 ; // B e g i n n i n g o f m e t h o d b l o c k
i f( condition ) {
i n t mouseY = 0 ; // B e g i n n i n g o f i f b l o c k
. . .
}// i f
}// m y M e t h o d ( )
}// E x a m p l e
✡ ✠
Executable Statements
Simple statements, such as assignment statements, should be w ritten one per
line and should be aligned with the other statements in the block . Compound
statements are those that contain other statements. Examples w ould include if
statements, for statements, while statements, and do-while s tatements. Com-
pound statements should use braces and appropriate indentation to highlight the
820 APPENDIX A •Coding Conventions
statement’s structure. Here are some examples of how to code sever al kinds of
compound statements:
☛ ✟
i f( condition ) { // A s i m p l e i f s t a t e m e n t
statement1 ;
statement2 ;
}// i f
i f( condition1 ) { // An i f −e l s e s t a t e m e n t
statement1 ;
}else i f ( condition2 ) {
statement2 ;
statement3 ;
}else{
statement4 ;
statement5 ;
}// i f / e l s e
for ( i n i t i a l i z e r ; entry −condition ; updater ) {// F o r l o o p
statement1 ;
statement2 ;
}// f o r
while ( condition ) { // W h i l e s t a t e m e n t
statement1 ;
statement2 ;
}// w h i l e
do{ // Do−w h i l e s t a t e m e n t
statement1 ;
statement2 ;
}while ( condition ) ;
✡ ✠
Preconditions and Postconditions
A good way to design and document loops and methods is to specify thei r pre-
conditions and postconditions. A precondition is a condition that must be true be-
fore the method (or loop) starts. A postcondition is a condition that must be true
after the method (or loop) completes. Although the conditions can be r epresented
formally—using boolean expressions—this is not necessary. It su fﬁces to give a
clear and concise statement of the essential facts before and af ter the method (or
loop).
Chapter 6 introduces the use of preconditions and postconditions an d Chapters
6 through 8 provide numerous examples of how to use them. It may be he lpful to
reread some of those examples and model your documentation after the examples
shown there.
Sample Programs
For speciﬁc examples of well-documented programs used in the tex t, see the
online source code that is available on the accompanying Web site a t
☛ ✟
http : // w w w. prenhall . com/ m o r e l l i
✡ ✠
Appendix B
The Java Development Kit
The Java Development Kit (JDK) for JavaTM2 Platform Standard Edition is a set
of command-line tools for developing Java programs. It is available for free in
versions for recent editions of Microsoft Windows, Linus, Macintosh OS X, and
Solaris (Sun Microsystems).
Download information and documentation are available for the entir e range of
products associated with the JavaTM2 Platform, Standard Edition (J2SE) at;
☛ ✟
http : //java . sun . com/ j 2 s e /
✡ ✠
This appendix summarizes some of the primary tools available in t he JDK. For
more detailed information you should consult Sun’s Web site.
Table B.1 provides a summary of some of the JDK tools.
TABLE B.1 Tools included in the Java Development Kit.
Tool Name Description
javac Java compiler. Translates source code into bytecode.
java Java interpreter. Translates and executes bytecode.
javadoc Java documentation generator. Creates HTML pages from
documentation comments embedded in Java programs.
appletviewer Appletviewer. Used instead of a browser to run Ja va applets.
jar Java archive manager. Manages Java archive (JAR) ﬁles.
jdb Java debugger. Used to ﬁnd bugs in a program.
javap Java disassembler. Translates bytecode into Java sourc e code.
Sun Microsystems provides detailed instructions on how to install JDK for J2SE
on computers running any of the above operating systems, includin g how to set
the system’s PATH and CLASSPATH variables. Installation instru ctions can be
located using the above link to downloading information.
The Java Compiler: javac
The Java compiler ( javac ) translates Java source ﬁles into Java bytecode. A Java
source ﬁle must have the .java extension. The javac compiler will create a
bytecode ﬁle with the same name but with the .class extension. The javac
command takes the following form:
821
822 APPENDIX B •The Java Development Kit
javac [options ] sourceﬁles [ﬁles]
The brackets in this expression indicate optional parts of the com mand. Thus,
options is an optional list of command-line options (including the -classpath
option), and ﬁles is an optional list of ﬁles, each of which contains a list of Java
source ﬁles. The ﬁles option would be used if you were compiling a very large
collection of ﬁles, too large to list each ﬁle individually on the c ommand line.
Most of the time you would simply list the sourceﬁles you are compiling imme-
diately after the word javac , as in the following example:
☛ ✟
j a v a c MyAppletClass . java MyHelperClass . java
✡ ✠
Given this command, javac will read class deﬁnitions contained in MyAppletClass.java
andMyHelperClass.java in the current working directory and translate them
into bytecode ﬁles named MyAppletClass.class andMyHelperClass.class .
If a Java source ﬁle contains inner classes, these would be compil ed into sepa-
rate class ﬁles. For example, if MyAppletClass.java contained an inner class
named Inner ,javac would compile the code for the inner class into a ﬁle named
MyAppletClass$Inner.class .
If you are writing a program that involves several classes, it is not necessary to
list each individual class on the command line. You must list the main class—that
is, the class where execution will begin. The compiler will per form a search for
all the other classes used in the main class. For example, if MyAppletClass uses
an instance of MyHelperClass , you can compile both classes with the following
command:
☛ ✟
j a v a c MyAppletClass . java
✡ ✠
In this case, javac will perform a search for the deﬁnition of MyHelperClass .
How Java Searches for Class Deﬁnitions
When compiling a ﬁle, javac needs a deﬁnition for every class or interface
that’s used in the source ﬁle. For example, if you are creating a su bclass of
java.applet.Applet ,javac will need deﬁnitions for all of Applet ’s super-
classes, including Panel ,Container , andComponent . The deﬁnitions for these
classes are contained in the java.awt package. Here’s how javac will search for
these classes.
Javac will ﬁrst search among its library ﬁles for deﬁnitions of classes , such as
Applet andPanel . Next, javac will search among the ﬁles and directories listed
on the user’s class path . The class path is a system variable that lists all the user The Classpath
directories and ﬁles that should be searched when compiling a us er’s program.
JDK no longer requires a class path variable. The class path ca n be set either by
using the environment variable CLASSPATH or by using the -classpath option
when invoking javac . By default, JDK will check in the current working directory
for user classes. It doesn’t require that the CLASSPATH variable b e set. If this
variable isset, it must include the current directory. The preferred way to set the
classpath is by using -classpath option. For example,
☛ ✟
j a v a c−c l a s s p a t h . . / source : . MyApplet . java
✡ ✠
will tell javac to search in both the current directory (.) and in the ../source
directory for user source ﬁles. Because the details for setting t he CLASSPATH
APPENDIX B •The Java Development Kit 823
variable are system dependent, it’s best to consult the online i nstallation docu-
mentation to see exactly how this is done on your system.
During a successful search, javac may ﬁnd a source ﬁle, a class ﬁle, or both.
If it ﬁnds a class ﬁle but not source ﬁle, javac will use the class ﬁle. This would
be the case for Java library code. If javac ﬁnds a source ﬁle but not a class ﬁle, it
will compile the source and use the resulting class ﬁle. This wou ld be the case for
the ﬁrst compilation of one of your source programs. If javac ﬁnds both a source
and a class ﬁle, it determines whether the class ﬁle is up-to-d ate. If so, it uses it. If
not, it compiles the source and uses the resulting class ﬁle. Thi s would be the case
for all subsequent compilations of one of your source programs.
As noted earlier, if your application or applet uses several sourc e ﬁles, you need
only provide javac with the name of the main application or applet ﬁle. It will
ﬁnd and compile all the source ﬁles, as long as they are located in a directory that’s
listed in the class path.
The Java Interpreter: java
Thejava interpreter launches a Java application. This command takes on e of the
following forms:
java
java[options ]
[options ]classname
-jar[argument . . . ]
ﬁle.jar [ argument . . . ]
If the ﬁrst form is used, java starts a Java runtime environment. It then loads the
speciﬁed classname and runs that class’s main() method, which must be declared
as follows:
☛ ✟
public s t a t i c void main ( S t r i n g args [ ] )
✡ ✠
TheString parameter args[] is an array of strings, which is used to pass any
argument s listed on the command line. Command-line arguments are optional .
If the second form of the java command is used, java will load the classes and
resources from the speciﬁed Java archive (JAR) . In this case, the special -jar option
ﬂag must be speciﬁed. The options can also include many other command-line
options, including the -classpath option.
Theappletviewer
Theappletviewer tool lets you run Java applets without using a Web browser.
This command takes the following form:
appletviewer [threads ﬂag ] [ options ] url . . .
The optional threads ﬂag tells Java which of the various threading options to use.
This is system dependent. For details on this feature and the com mand line options ,
refer to Sun’s Web site.
The appletviewer will connect to one or more HTML documents speciﬁ ed by
their Uniform Resource Locators (URLs) . It will display each applet referenced in
those documents in a separate window. Some example commands would be
☛ ✟
appletviewer http : //www . d o m a i n . e d u / ˜ a c c o u n t / m y a p p l e t . h t m l
appletviewer myapplet . html
✡ ✠
824 APPENDIX B •The Java Development Kit
In the ﬁrst case, the document’s full path name is given. In the s econd case, since
no host computer is mentioned, appletviewer will assume that the applet is
located on the local host and will search the class path for myapplet.html .AppletViewer tags
Onceappletviewer retrieves the HTML document, it will ﬁnd the applet
by looking for either the object ,embed , orapplet tags within the document.
Theappletviewer ignores all other HTML tags. It just runs the applet. If it
cannot ﬁnd one of these tags, the appletviewer will do nothing. If it does locate
an applet, it starts a runtime environment, loads the applet, a nd then runs the
applet’s init() method. The applet’s init() must have the following method
signature:
☛ ✟
public void i n i t ( )
✡ ✠
Theapplet Tag
Theapplet tag is the original HTML 3.2 tag used for embedding applets with in
an HTML document. If this tag is used, the applet will be run by t he browser,
using the browser’s own implementation of the Java Runtime Environ ment (JRE).
Note, however, that if your applet uses the latest Java language features and the
browser is not using the latest version of JRE, the applet may not ru n correctly. For
example, this might happen if your applet makes use of Swing feat ures that are not
yet supported in the browser’s implementation of the JRE. In that c ase, your applet
won’t run under that browser.
To ensure that the applet runs with the latest version of the JRE —the one pro-
vided by Sun Microsystems—you can also use the object or the embed tags.
These tags are used to load the appropriate version of the JRE into the browser
as a plugin module. A plugin is a helper program that extends the browser’s
functionality.
Theapplet tag takes the following form:
☛ ✟
<applet
code= ” yourAppletClass . c l a s s ”
o b j e c t = ” serializedObjectOrJavaBean ”
codebase= ” c l a s s F i l e D i r e c t o r y ”
width= ” pixelWidth ”
height= ” pixelHeight ”
>
<param name= ” . . . ” value= ” . . . ”>
. . .
a l t e r n a t e −t e x t
</applet >
✡ ✠
You would use only the code orobject attribute, not both. For the programs in
this book, you should always use the code tag. The code tag speciﬁes where the
program will begin execution—that is, in the applet class.
The optional codebase attribute is used to specify a relative path to the applet.
It may be omitted if the applet’s class ﬁle is in the same director y as the HTML
document.
Thewidth andheight attributes specify the initial dimensions of the ap-
plet’s window. The values speciﬁed in the applet tag can be overr idden in the
applet itself by using the setSize() method, which the applet inherits from the
java.awt.Component class.
APPENDIX B •The Java Development Kit 825
Theparam tags are used to specify arguments that can be retrieved when the
applet starts running (usually in the applet’s init() method). The methods for
retrieving parameters are deﬁned in the java.applet.Applet class.
Finally, the alternative-text portion of the applet tag provides text that
would be displayed on the Web page if the appletviewer or browser i s unable to
locate the applet.
Here’s a simple example of an applet tag:
☛ ✟
<applet
code= ”HelloWorldApplet . c l a s s ”
codebase= ” c l a s s f i l e s ”
width= ”200 ”
height= ” 200”
>
<param name= ” author ” value= ” Java Java Java ” >
<param name= ” date ” value= ”May 1999 ” >
Sorry , your browser does not seem to be able to
l o c a t e the HelloWorldApplet .
</applet >
✡ ✠
In this case, the applet’s code is stored in a ﬁle name HelloWorld-
Applet.class , which is stored in the classfiles subdirectory—that is, a sub-
directory of the directory containing the HTML ﬁle. The applet’s w indow will be
200×200pixels. And the applet is passed the name of the program’s author a nd
date it was written. Finally, if the applet cannot be located, t he “Sorry . . . ” message
will be displayed instead.
Theobject Tag
Theobject tag is the HTML 4.0 tag for embedding applets and multimedia ob-
jects in an HTML document. It is also an Internet Explorer (IE) 4 .x extension to
HTML. It allows IE to run a Java applet using the latest JRE plug in from Sun. The
object tag takes the following form:
☛ ✟
<o b j e c t
c l a s s i d = ”name of the plugin program”
codebase= ” u r l f o r the plugin program”
width= ” pixelWidth ”
height= ” pixelHeight ”
>
<param name= ”code” value= ” yourClass . c l a s s ” >
<param name= ” codebase ” value= ” c l a s s F i l e D i r e c t o r y ” >
. . .
a l t e r n a t e −t e x t
</o b j e c t >
✡ ✠
826 APPENDIX B •The Java Development Kit
Note that parameters are used to specify your applet’s code and cod ebase. In ef-
fect, these are parameters to the plugin module. An example ta g that corresponds
to theapplet tag for the HelloWorldApplet might be as follows:
☛ ✟
<o b j e c t
c l a s s i d = ” c l s i d : 8 AD9C840 −044E−11D1−B3E9−00805F499D93”
codebase= ” http :// java . sun . com/products/plugin/”
width= ” 200”
height= ” 200”
>
<param name= ”code” value= ”HelloWorldApplet . c l a s s ” >
<param name= ” codebase ” value= ” c l a s s f i l e s ” >
<param name= ” author ” value= ” Java Java Java ” >
<param name= ” date ” value= ”May 1999 ” >
Sorry , your browser does not seem to be able to
l o c a t e the HelloWorldApplet .
</o b j e c t >
✡ ✠
If the browser has an older version of the plug in than shown in the codebase
attribute, the user will be prompted to download the newer versi on. If the browser
has the same or newer version, that version will run. In theory Net scape 6 should
also work the same as IE. For further details on how to use the object tag, see
Sun’s plugin site at:
☛ ✟
http : //java . sun . com/products/plugin/
✡ ✠
Theembed Tag
The embed tag is Netscape’s version of the applet andobject tags. It is in-
cluded as an extension to HTML 3.2. It can be used to allow a Netsc ape 4.x browser
to run a Java applet using the latest Java plugin from Sun. It tak es the following
form:
☛ ✟
<embed
type= ”Type of program”
code= ” yourAppletClass . c l a s s ”
codebase= ” c l a s s F i l e D i r e c t o r y ”
pluginspage= ” l o c a t i o n of plugin f i l e on the web”
width= ” pixelWidth ”
height= ” pixelHeight ”
>
<noembed >
A l t e r n a t i v e t e x t
</noembed >
</embed>
✡ ✠
Thetype andpluginspage attributes are not used by the appletviewer, but they
are necessary for browsers. They would just be ignored by the appl etviewer.
APPENDIX B •The Java Development Kit 827
For example, an embed tag for HelloWorldApplet would be as follows:
☛ ✟
<EMBED
type= ” a p p l i c a t i o n /x −java−applet ; version =1.4 ”
width= ”200 ”
height= ” 200”
code= ”HelloWorldApplet . c l a s s ”
codebase= ” c l a s s f i l e s ”
pluginspage= ” http :// java . sun . com/products/plugin/”
>
<NOEMBED >
Sorry . This page won ’ t be able to run t h i s applet .
</ NOEMBED >
</ EMBED>
✡ ✠
It may be possible to combine the applet ,embed , andobject tags in the
same HTML ﬁle. Sun provides much more information, as well as demo p rograms
on its plugin website:
☛ ✟
http : //java . sun . com/products/plugin/
✡ ✠
The Java Archiver jar Tool
Thejar tool can be used to combine multiple ﬁles into a single JAR archiv e ﬁle.
Although the jar tool is a general-purpose archiving and compression tool, it was
designed mainly to facilitate the packaging of Java applets a nd applications into a
single ﬁle.
The main justiﬁcation for combining ﬁles into a single archive a nd compressing
the archive is to improve download time. The jar command takes the following
format:
jar [options ] destination-ﬁle input-ﬁle [ input-ﬁles ]
For an example of its usage, let’s use it to archive the ﬁles involv ed in the
WordGuess example in Chapter 9. As you may recall, this example used clas ses,
such as TwoPlayerGame , and interfaces, such as IGame , that were developed in
earlier sections of the chapter. So, to help manage the developmen t ofWordGuess ,
it would be useful to have a library containing those ﬁles that mu st be linked
together when we compile WordGuess .
This is a perfect use of a jar ﬁle. Let’s name our library nplayerlib.jar .
We choose this name because the library can be used to create gam e programs that
have Nplayers, including two-player games.
828 APPENDIX B •The Java Development Kit
For the two-player game, WordGuess , we want to combine all the .class ﬁles
needed by WordGuess.java into a single jar ﬁle. Here’s a list of the ﬁles we want
to archive:
☛ ✟
CLUIPlayableGame . c l a s s
ComputerGame . c l a s s
GUIPlayableGame . c l a s s
IGame . c l a s s
KeyboardReader . c l a s s
Player . c l a s s
TwoPlayerGame . c l a s s
U s e r I n t e r f a c e . c l a s s
✡ ✠
Assuming all of these ﬁles are contained in a single directory (a long with other
ﬁles, perhaps), then the command we use from within that direct ory is as follows:
☛ ✟
j a r c f n p l a y e r l i b . j a r ∗.c l a s s
✡ ✠
In this case, the cfoptions specify that we are creating a jar ﬁle named
animated.jar that will consist of all the ﬁles having the .class sufﬁx. This
will create a ﬁle named nplayerlib.jar . To list the contents of this ﬁle, you can
use the following command:
☛ ✟
j a r t f n p l a y e r l i b . j a r
✡ ✠
Once we have created the jar ﬁle, we can copy it into the director y that contains
our source code for the WordGuess program. We would then the following com-
mands to include the code contained in the library when we compil e and run
WordGuess.java
☛ ✟
j a v a c−c l a s s p a t h n p l a y e r l i b . j a r : . WordGuess . java
java−c l a s s p a t h n p l a y e r l i b . j a r : . WordGuess
✡ ✠
These commands, which use the -classpath option, tell javac andjava to in-
clude code from the nplayerlib.jar . The notation :., links code in the current
directory ( ˙) with the library code.
Once we have created a library, we can also use it for Java apple ts. For exam-
ple, suppose we have developed an applet version of the WordGuess game and
linked all of the applet’s code into a jar ﬁle named wordguessapplet.jar . The
APPENDIX B •The Java Development Kit 829
following HTML ﬁle would allow users to download the applet from thei r web
browser:
☛ ✟
<html>
<head><t i t l e>WordGuess Applet </t i t l e></head>
<body>
<applet
archive= ” wordguessapplet . j a r ”
code= ”WordGuessApplet . c l a s s ”
width=350 height =350
>
<parameter name= ” author ” value= ” Java Java Java ” >
<parameter name= ” date ” value= ” April 2005 ” >
</applet >
</body>
</html>
✡ ✠
When speciﬁed in this way, the browser will take care of downloadi ng the archive
ﬁle and extracting the individual ﬁles needed by the applet. Note that the code
attribute must still designate the ﬁle where the program will start execution.
The Java Documentation Tool: javadoc
Thejavadoc tool parses the declarations and documentation comments in a
Java source ﬁle and generates a set of HTML pages that describes the follow-
ing elements: public and protected classes, inner classes, i nterfaces, constructors,
methods, and ﬁelds.
Thejavadoc tool can be used on a single ﬁle or an entire package of ﬁles.
Recall that a Java documentation comment is one that begins with /**and ends
with*/. These are the comments that are parsed by javadoc .
Thejavadoc tool has many features, and it is possible to use Java doclets to
customize your documentation. For full details on using the tool, it i s best to
consult Sun’s Web site. To illustrate how it might be used, let’s ju st look at a simple
example.
TheFirstApplet program from Chapter 1 contains documentation com-
ments. It was processed using the following command:
☛ ✟
javadoc F i r s t A p p l e t . java
✡ ✠
javadoc generated the following HTML documents:
☛ ✟
F i r s t A p p l e t . html −The main documentation f i l e
a l l c l a s s e s −frame . html −Names and l i n k s to a l l the c l a s s e s used in
F i r s t A p p l e t
overview −t r e e . html −A t r e e showing F i r s t A p p l e t ’ s place
in the c l a s s hierarchy
packages . html −D e t a i l s on the packages used in F i r s t A p p l e t
index . html −Top−l e v e l HTML document f o r
F i r s t A p p l e t documentation
index−a l l . html −Summary of a l l methods and v a r i a b l e s in
F i r s t A p p l e t
✡ ✠
830 APPENDIX B •The Java Development Kit
To see how the documentation appears, review the FirstApplet.java source
ﬁle and the documentation it generated. Both are available at
☛ ✟
http : // w w w. prenhall . com/ m o r e l l i/
✡ ✠
Appendix C
The ASCII and Unicode
Character Sets
Java uses version 2.0 of the Unicode character set for representi ng character data.
The Unicode set represents each character as a 16-bit unsigne d integer. It can,
therefore, represent 216=65,536 different characters. This enables Unicode to
represent characters from not only English but also a wide range of international
languages. For details about Unicode, see
☛ ✟
http : // w w w. unicode . org
✡ ✠
Unicode supersedes the ASCII character set (American Standard Code for In-
formation Interchange). The ASCII code represents each charact er as a 7-bit or
8-bit unsigned integer. A 7-bit code can represent only 27=128 characters. In
order to make Unicode backward compatible with ASCII, the ﬁrst 12 8 characters
of Unicode have the same integer representation as the ASCII char acters.
Table C.1 shows the integer representations for the printable subset of ASCII
characters. The characters with codes 0 through 31 and code 127 a renonprintable
characters, many of which are associated with keys on a standard keyboard. For
example, the delete key is represented by 127, the backspace by 8, and the return
key by 13.
831
832 APPENDIX C •ASCII and Unicode Character Sets
TABLE C.1 ASCII codes for selected characters
☛ ✟
Code 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
Char SP ! ” # $ % & ’ ( ) ∗+ ,− . /
Code 48 49 50 51 52 53 54 55 56 57
Char 0 1 2 3 4 5 6 7 8 9
Code 58 59 60 61 62 63 64
Char : ; < => ? @
Code 65 66 67 68 69 70 71 72 73 74 75 76 77
Char A B C D E F G H I J K L M
Code 78 79 80 81 82 83 84 85 86 87 88 89 90
Char N O P Q R S T U V W X Y Z
Code 91 92 93 94 95 96
Char [ \ ] ˆ ‘
Code 97 98 99 100 101 102 103 104 105 106 107 108 109
Char a b c d e f g h i j k l m
Code 110 111 112 113 114 115 116 117 118 119 120 121 122
Char n o p q r s t u v w x y z
Code 123 124 125 126
Char { | } ˜
✡ ✠
Appendix D
Java Keywords
The words shown in Table D.1 are reserved for use as Java keywords and cannot
be used as identiﬁers. The keywords const andgoto , which are C++ keywords,
are not actually used in Java. They were included mainly to ena ble better error
messages to be generated when they are mistakenly used in a Ja va program.
The words true ,false , andnull may look like keywords but are technically
considered literals . They also cannot be used as identiﬁers.
TABLE D.1 The Java keywords cannot be used as names for identiﬁers.
abstract continue for new switch
assert default goto package synchronized
boolean do if private this
break double implements protected throw
byte else import public throws
case enum instanceof return transient
catch extends int short try
char ﬁnal interface static void
class ﬁnally long strictfp volatile
const ﬂoat native super while
833
834 APPENDIX D •Java Keywords
Appendix E
Operator Precedence
Hierarchy
Table E.1 summarizes the precedence and associativity relat ionships for Java op-
erators. Within a single expression, an operator of order mwould be evaluated be-
fore an operator of order nifm<n. Operators having the same order are evaluated
according to their association order. For example, the expression
☛ ✟
25 + 5 ∗2 + 3
✡ ✠
would be evaluated in the order shown by the following parenthesiz ed expression:
☛ ✟
(25 + (5 ∗2 ) ) + 3 == >(25 + 10) + 3 == >35 + 3 == >38
✡ ✠
In other words, because *has higher precedence than +, the multiplication op-
eration is done before either of the addition operations. And becaus e addition
associates from left to right, addition operations are performed f rom left to right.
Most operators associate from left to right, but note that assignme nt operators
associate from right to left. For example, consider the following c ode segment:
☛ ✟
i n t i , j , k ;
i = j = k = 1 0 0 ; // E q u i v a l e n t t o i = ( j = ( k = 1 0 0 ) ) ;
✡ ✠
In this case, each variable will be assigned 100 as its value. But it’s important that
this expression be evaluated from right to left. First, kis assigned 100. Then its
value is assigned to j. And ﬁnally j’s value is assigned to i.
For expressions containing mixed operators, it’s always a good idea t o use
parentheses to clarify the order of evaluation. This will also h elp avoid subtle
syntax and semantic errors.
835
836 APPENDIX E •Operator Precedence Hierarchy
TABLE E.1 Java operator precedence and associativity table.
Order Operator Operation Association
0( ) Parentheses
1++ -- · Postincrement, Postdecrement, Dot Operator L to R
2++ -- + - ! Preincrement, Predecrement, R to L
Unary plus, Unary minus, Boolean NOT
3(type) new Type Cast, Object Instantiation R to L
4*/ % Multiplication, Division, Modulus L to R
5+ - + Addition, Subtraction, String Concatenation L to R
6< > <= >= Relational Operators L to R
7== != Equality Operators L to R
8∧ Boolean XOR L to R
9&& Boolean AND L to R
10 —— Boolean OR L to R
11 = += -= *= /= %= Assignment Operators R to L
Appendix F
Java Inner Classes
This appendix describes basic features of some advanced eleme nts of the Java lan-
guage. As for many language features, there are details and su btleties involved in
using these features that are not covered here. For further deta ils, you should
consult Sun’s online references or other references for a more compreh ensive
description.
What Are Inner Classes?
Inner classes were introduced in Java 1.1. This features lets you deﬁne a clas s as
part of another class, just as ﬁelds and methods are deﬁned withi n classes. Inner
classes can be used to support the work of the class in which they a re contained.
Java deﬁnes four types of inner classes. A nested top-level class or interface
is a static member of an enclosing top-level class or interface. Such classes are
considered top-level classes by Java.
Amember class is a nonstatic inner class. It is not a top-level class. As a full-
ﬂedged member of its containing class, a member class can refer to the ﬁelds and
methods of the containing class, even the private ﬁelds and methods. Just as
you would expect for the other instance ﬁelds and methods of a class, all instances
of a member class are associated with an instance of the enclosing class.
Alocal class is an inner class that’s deﬁned within a block of Java code, such as
within a method or within the body of a loop. Local classes have local sc ope—they
can only be used within the block in which they are deﬁned. Local c lasses can refer
to the methods and variables of their enclosing classes. They ar e used mostly to
implement adapters , which are used to handle events.
When Java compiles a ﬁle containing a named inner class, it crea tes sepa-
rate class ﬁles for them with names that include the nesting cl ass as a quali-
ﬁer. For example, if you deﬁne an inner class named Metric inside a top-
level class named Converter , the compiler will create a class ﬁle named
Converter$Metric.class for the inner class. If you wanted to access the in-
ner class from some other class (besides Converter ), you would use a qualiﬁed
name: Converter.Metric .
Ananonymous class is a local class whose deﬁnition and use are combined into
a single expression. Rather than deﬁning the class in one state ment and using it
in another, both operations are combined into a single expression. Anonymous
classes are intended for one-time use. Therefore, they don’t conta in constructors.
Their bytecode ﬁles are given names like ConverterFrame$1.class .
837
838 APPENDIX F •Java Inner Classes
Nested Top-Level Versus Member Classes
TheConverter class (Figure F–1) shows the differences between a nested top-
level class and a member class. The program is a somewhat contriv ed example
that performs various kinds of metric conversions. The outer Converter class
☛ ✟
public c l a s s Converter {
private s t a t i c f i n a l double INCH PER METER = 3 9 . 3 7 ;
private f i n a l double LBS PER KG = 2 . 2 ;
public s t a t i c c l a s s Distance {// N e s t e d Top −l e v e l c l a s s
public double metersToInches ( double meters ) {
return meters ∗INCH PER METER ;
}
}// D i s t a n c e
public c l a s s Weight { // M e m b e r c l a s s
public double kgsToPounds ( double kg ){
return kg∗LBS PER KG ;
}
}// W e i g h t
}// C o n v e r t e r
public c l a s s ConverterUser {
public s t a t i c void main ( S t r i n g args [ ] ) {
Converter . Distance d i s t a n c e = new Converter . Distance ( ) ;
Converter converter = new Converter ( ) ;
Converter . Weight weight = converter . new Weight ( ) ;
System . out . p r i n t l n ( ”5 m = ” + d i s t a n c e . metersToInches ( 5 ) + ” in ” ) ;
System . out . p r i n t l n ( ”5 kg = ” + weight . kgsToPounds ( 5 ) + ” l b s ” ) ;
}
}// C o n v e r t e r U s e r
✡ ✠
Figure F–1: A Java application containing a top-level neste d class.
serves as a container for the inner classes, Distance andWeight , which perform
speciﬁc conversions.
TheDistance class is declared static , so it is a top-level class. It is contained
in theConverter class itself. Note the syntax used in ConverterUser.main()
to create an instance of the Distance class:
☛ ✟
Converter . Distance d i s t a n c e = new Converter . Distance ( ) ;
✡ ✠
A fully qualiﬁed name is used to refer to the static inner class via its containing
class.
TheWeight class is not declared static . It is, therefore, associated with in-
stances of theConverter class. Note the syntax used to create an instance of the
Weight class:
☛ ✟
Converter converter = new Converter ( ) ;
Converter . Weight weight = converter . new Weight ( ) ;
✡ ✠
APPENDIX F •Java Inner Classes 839
Before you can create an instance of Weight , you have to declare an instance of
Converter . In this example, we have used two statements to create the weight
object, which requires using the temporary variable, converter , as a reference to
theConverter object. We could also have done this with a single statement by
using the following syntax:
☛ ✟
Converter . Weight weight = new Converter ( ) . new Weight ( ) ;
✡ ✠
Note that in either case the qualiﬁed name Converter.Weight must be used to
access the inner class from the ConverterUser class.
There are a couple of other noteworthy features in this example. Fi rst, an inner
top-level class is really just a programming convenience. It be haves just like any
other top-level class in Java. One restriction on top-level inner classes is that they
can only be contained within other top-level classes, although th ey can be nested
one within the other. For example, we could nest additional convert er classes
within the Distance class. Java provides special syntax for referring to such
nested classes.
Unlike a top-level class, a member class is nested within an in stance of its con-
taining class. Because of this, it can refer to instance varia bles (LBS_PER_KG ) and
instance methods of its containing class, even to those declared private . By con-
trast, a top-level inner class can only refer to class variable s (INCH_PER_METER )—
that is, to variables that are declared static . So you would use a member class if
it were necessary to refer to instances of the containing class .
There are many other subtle points associated with member class es, including
special language syntax that can be used to refer to nested me mber classes and
rules that govern inheritance and scope of member classes. For th ese details you
should consult the Java Language Speciﬁcation , which can be accessed online at
☛ ✟
http : //java . sun . com/docs/books/ j l s /html/index . html
✡ ✠
Local and Anonymous Inner Classes
In this next example, ConverterFrame , a local class is used to create an
ActionEvent handler for the application’s two buttons (Fig. F–2).
As we have seen, Java’s event-handling model uses predeﬁned in terfaces, such
as the ActionListener interface, to handle events. When a separate class is
deﬁned to implement an interface, it is sometimes called an adapter class. Rather
than deﬁning adapter classes as top-level classes, it is often more convenient to
deﬁne them as local or anonymous classes.
The key feature of the ConverterFrame program is the createJButton()
method. This method is used instead of the JButton() constructor to create but-
tons and to create action listeners for the buttons. It takes a sin gleString param-
eter for the button’s label. It begins by instantiating a new JButton , a reference
to which is passed back as the method’s return value. After creating an instance
button, a local inner class named ButtonListener is deﬁned.
The local class merely implements the ActionListener interface by deﬁning
theactionPerformed method. Note how actionPerformed() uses the con-
taining class’s converter variable to acquire access to the metersToInches()
andkgsToPounds() methods, which are inner class methods of the Converter
class (Fig. F–1). A local class can use instance variables, su ch asconverter , that
are deﬁned in its containing class.
After deﬁning the local inner class, the createJButton() method creates an
instance of the class ( listener ) and registers it as the button’s action listener.
840 APPENDIX F •Java Inner Classes
☛ ✟
import javax . swing . ∗;
import java . awt . ∗;
import java . awt . event . ∗;
public c l a s s ConverterFrame extends JFrame {
private Converter converter = new Converter ( ) ; // R e f e r e n c e t o a p p
private J T e x t F i e l d i n F i e l d = new J T e x t F i e l d ( 8 ) ;
private J T e x t F i e l d outField = new J T e x t F i e l d ( 8 ) ;
private JButton metersToInch ;
private JButton kgsToLbs ;
public ConverterFrame ( ) {
metersToInch = c r e a t e J B u t t o n ( ” Meters To Inches ” ) ;
kgsToLbs = c r e a t e J B u t t o n ( ” Kilos To Pounds” ) ;
getContentPane ( ) . setLayout ( new FlowLayout ( ) ) ;
getContentPane ( ) . add ( i n F i e l d ) ;
getContentPane ( ) . add ( outField ) ;
getContentPane ( ) . add ( metersToInch ) ;
getContentPane ( ) . add ( kgsToLbs ) ;
}// C o n v e r t e r F r a m ( )
private JButton c r e a t e J B u t t o n ( S t r i n g s ) {// A m e t h o d t o c r e a t e a J B u t t o n
JButton j b u t t o n = new JButton ( s ) ;
c l a s s ButtonListener implements ActionListener {// L o c a l c l a s s
public void actionPerformed ( ActionEvent e ) {
double inValue = Double . valueOf ( i n F i e l d . getText ( ) ) . doubleVal ue ( ) ;
JButton button = ( JButton ) e . getSource ( ) ;
i f( button . getText ( ) . equals ( ” Meters To Inches ” ) )
outField . s e t T e x t ( ””+ converter . new Distance ( ) . metersToInches ( inValue ) ) ;
else
outField . s e t T e x t ( ””+ converter . new Weight ( ) . kgsToPounds ( inValue ) ) ;
}// a c t i o n P e r f o r m e d ( )
}// B u t t o n L i s t e n e r
ActionListener l i s t e n e r = new ButtonListener ( ) ; // C r e a t e a l i s t e n e r
j b u t t o n . addActionListener ( l i s t e n e r ) ; // R e g i s t e r b u t t o n s w i t h l i s t e n e r
return j b u t t o n ;
}// c r e a t e J B u t t o n ( )
public s t a t i c void main ( S t r i n g args [ ] ) {
ConverterFrame frame = new ConverterFrame ( ) ;
frame . s e t S i z e ( 2 0 0 , 2 0 0 ) ;
frame . s e t V i s i b l e ( true ) ;
}// m a i n ( )
}// C o n v e r t e r F r a m e
✡ ✠
Figure F–2: The use of a local class as an ActionListener adapter.
When a separate object is created to serve as listener in this w ay, it is called an
adapter . It implements a listener interface and thereby serves as ad apter between
the event and the object that generated the event. Any action ev ents that occur
on any buttons created with this method will be handled by this ad apter. In other
APPENDIX F •Java Inner Classes 841
words, for any buttons created by the createJButton() method, a listener ob-
ject is created and assigned as the button’s event listener. By using local classes,
the code for doing this is much more compact and efﬁcient.
Local classes have some important restrictions. Although an inst ance of a local
class can use ﬁelds and methods deﬁned within the class itself or inherited from its
superclasses, it cannot use local variables and parameters de ﬁned within its scope
unless these are declared final . The reason for this restriction is that final vari-
ables receive special handling by the Java compiler. Because the compiler knows
that the variable’s value won’t change, it can replace uses of the variable with their
values at compile time.
842 APPENDIX F •Java Inner Classes
Anonymous Inner Classes
An anonymous inner class is just a local class without a name. Inst ead of using two
separate statements to deﬁne and instantiate the local class , Java provides syntax
that let’s you do it in one expression. The following code illustrate s how this is
done:
☛ ✟
private JButton c r e a t e J B u t t o n ( S t r i n g s ) {// A m e t h o d t o c r e a t e a J B u t t o n
JButton j b u t t o n = new JButton ( s ) ;
j b u t t o n . addActionListener ( new ActionListener ( ) { // A n o n y m o u s c l a s s
public void actionPerformed ( ActionEvent e ) {
double inValue = Double . valueOf ( i n F i e l d . getText ( ) ) . doubleVal ue ( ) ;
JButton button = ( JButton ) e . getSource ( ) ;
i f( button . getLabel ( ) . equals ( ” Meters To Inches ” ) )
outField . s e t T e x t ( ””+ converter . new Distance ( ) . metersToInches ( inValue ) ) ;
else
outField . s e t T e x t ( ””+ converter . new Weight ( ) . kgsToPounds ( inValue ) ) ;
}// a c t i o n P e r f o r m e d ( )
}) ; // A c t i o n L i s t e n e r
return j b u t t o n ;
}// c r e a t e J B u t t o n ( )
✡ ✠
Note that the body of the class deﬁnition is put right after the new operator. The
result is that we still create an instance of the adapter object , but we deﬁne it on
the ﬂy. If the name following new is a class name, Java will deﬁne the anonymous
class as a subclass of the named class. If the name following new is an interface, the
anonymous class will implement the interface. In this example , the anonymous
class is an implementation of the ActionListener interface.
Local and anonymous classes provide an elegant and convenient way to im-
plement adapter classes that are intended to be used once and h ave relatively
short and simple implementations. The choice of local versus anony mous should
largely depend on whether you need more than one instance of the cla ss. If so, or if
it’s important that the class have a name for some other reason (read ability), then
you should use a local class. Otherwise, use an anonymous class. As in all design
decisions of this nature, you should use whichever approach or styl e makes your
code more readable and more understandable.
Appendix G
Java Autoboxing and
Enumeration
This appendix describes some basic properties of autoboxing and enumeration , two
of the features added to the Java language with the release of Ja va 5.0. As for
many language features, there are details and subtleties in volved in using these
features that are not covered here. For further details, you shoul d consult Sun’s
online references or other references for a more comprehensive des cription.
Autoboxing and Unboxing
Autoboxing refers to the automatic storing of a value of primitive type into a n
object of the corresponding wrapper class. Before autoboxing, it wa s necessary to
explicitly box values into wrapper class objects with code like :
☛ ✟
I n t e g e r iObj = new I n t e g e r ( 3 4 5 ) ;
double num = −2.345;
Double dObj = new Double (num ) ;
✡ ✠
Java 5.0 automatically creates a wrapper class object from a val ue of primitive type
in many situations where a wrapper class object is expected. Th e assignments
above can be accomplished with the simpler code:
☛ ✟
I n t e g e r iObj = 3 4 5 ;
double num = −2.345;
Double dObj = num;
✡ ✠
There is a corresponding feature in Java 5.0 which automaticall y performs the
unboxing of primitive values from wrapper class objects. Instead of the ex plicit
unboxing in:
☛ ✟
i n t m = iObj . intValue ( ) ;
double x = dObj . doubleValue ( ) ;
✡ ✠
843
844 APPENDIX G •Java Autoboxing and Enumeration
Java 5.0 allows the simpler:
☛ ✟
i n t m = iObj ;
double x = dObj ;
✡ ✠
Java 5.0 provides autoboxing of primitive values and automatic un boxing of
wrapper class objects in expressions or in arguments of methods, w here such a
conversion is needed to complete a computation. Beginning program mers are
unlikely to encounter many problems that require such conversi ons. One situa-
tion which often requires boxing and unboxing are applications th at involve data
structures. The generic type data structures of Chapter 16 mu st store objects but
the data to be stored might be represented as values of a primiti ve type. The
code segment below should give you some idea of the type of situation wh ere
autoboxing and unboxing can be a genuine help simplifying one’s cod e:
☛ ✟
Stack<Integer >s t a c k = new Stack<Integer >( ) ;
for(i n t k =−1; k>−5; k−−)
s t a c k . push ( k ) ;
while ( ! s t a c k . empty ( ) )
System . out . p r i n t l n ( Math . abs ( s t a c k . pop ( ) ) ) ;
✡ ✠
Notice that the stack.push(k) method is expecting an Integer object so the
int value stored in kwill be autoboxed into such an object before the method
is executed. Also note that the Math.abs() method in the last line of the code
fragment is expecting a value of primitive type so the Integer value returned by
stack.pop() must be automatically unboxed before the Math.abs() method
can be applied.
Sun’s online Java 5.0 documentation can be consulted for a more precis e de-
scription of where autoboxing and unboxing takes place and a list of some special
situations where code allowing autoboxing can lead to confusion and problems.
Enumeration
A new enumeration construct was included in Java 5.0 to make it simpler to repre-
sent a ﬁnite list of named values as a type. The enum keyword was added as part
of this construct. Standard examples of lists of values appropriat e for enumera-
tions are the days of the week, months of the year, the four seasons, t he planets,
the four suits in a deck of cards, and the ranks of cards in a deck of c ards. The
following declaration of Season enumerated type is an example used by the Sun
online documentation.
☛ ✟
public enum Season {spring , summer , f a l l , winter }
✡ ✠
Compiling a ﬁle that contains only this statement will create a Season.class
ﬁle that deﬁnes a Java type just in the same way that compiling c lass deﬁnitions
does. The variables and values of type Season can be referred to in other classes
APPENDIX G •Java Autoboxing and Enumeration 845
just like other types and values. For example, the following stat ements are valid
statements in a method deﬁnition in another class:
☛ ✟
Season s1 = winter ;
i f( s1 == spring )
System . out . p r i n t l n ( s1 ) ;
✡ ✠
Note that the values of enumerated types can be used in assignme nt statements,
equality relations, and it will be printed out exactly as decla red in the enum
statement.
Theenum declaration could also occur inside the deﬁnition of a class and be
declared as either public orprivate . In this case the visibility of the type would
be determined in a manner similar to inner classes.
A standard way to represent such a ﬁnite list of values in Java b efore the enum
construct was to create a list of constants of type int. For example, if one wanted
to represent the four seasons you would have to do it inside a deﬁni tion of a class,
say of a class named Calendar . Such a representation might look like:
☛ ✟
public c l a s s Calendar {
public s t a t i c f i n a l i n t SPRING = 0 ;
public s t a t i c f i n a l i n t SUMMER = 1 ;
public s t a t i c f i n a l i n t FALL = 2 ;
public s t a t i c f i n a l i n t WINTER = 3 ;
// O t h e r C a l e n d a r d e f i n i t i o n s
}// C a l e n d a r
✡ ✠
In addition to being a lengthier declaration, note that other cla sses that wish to
refer to this representation would have to use notation something like:
☛ ✟
i n t s1 = Calendar .WINTER;
i f( s1 == Calendar . SPRING)
System . out . p r i n t l n ( s1 ) ;
✡ ✠
In addition to being more awkward, note that the println() call will print out
an integer in this case. Some additional code would have to be writt en to be able
to print the names of the seasons from the int values used to represent them. It is
the case that for methods in the Calendar class, the names of the constants look
very much like the values of the enum type.
846 APPENDIX G •Java Autoboxing and Enumeration
To illustrate a couple of additional advantages of the enum structure, lets con-
sider using the int representation above in a method deﬁnition that describes the
start date of a given season. Code for such a method would look something like:
☛ ✟
public s t a t i c S t r i n g s t a r t D a t e ( i n t s ){
switch ( s ){
case SPRING : return ” Vernal Equinox” ;
case SUMMER : return ”Summer S o l s t i c e ” ;
case FALL : return ”Autumnal Equinox” ;
case WINTER : return ” Winter S o l s t i c e ” ;
}// s w i t c h
return ” e r r o r ” ;
}// s t a r t D a t e ( )
✡ ✠
This method has a problem referred to as not being typesafe . We would want the
startDate() method to be called only with an argument equal to an int value
of 0, 1, 2, or 3. There is no way to tell the compiler to make sure tha t other int
values are not used as an argument to this method.
Let’s contrast this with a similar startDate() method that can refer to the
Season enumerated type that was deﬁned above. The Calendar class (Figure G–
1) shows the deﬁnition of a startDate() method as well as a method to print
a list of seasons with corresponding starting dates. Note that the parameter of
☛ ✟
public c l a s s Calendar {
public s t a t i c S t r i n g s t a r t D a t e ( Season s ) {
switch ( s ){
case spring : return ” Vernal Equinox” ;
case summer : return ”Summer S o l s t i c e ” ;
case f a l l : return ”Autumnal Equinox” ;
case winter : return ”Winter S o l s t i c e ” ;
}// s w i t c h
return ” e r r o r ” ;
}// s t a r t D a t e ( )
public s t a t i c void printDates ( ) {
for ( Season s : Season . values ( ) )
System . out . p r i n t l n ( s + ”−”+ s t a r t D a t e ( s ) ) ;
}// p r i n t D a t e s ( )
}// C a l e n d a r
✡ ✠
Figure G–1: A Calendar class using the Season .
startDate() is of type Season and so the Java compiler can check that call
to this method have an argument of this type. This time the startDate() is
typesafe.
TheprintDates() method illustrates another feature of the enumeration
structure. The for loop in this method is the for-in loop which was added
to Java 5.0. The expression Season.values() denotes a list of the elements of
the type in the order that they were declared. The for-in loop iterates through
all the values of the type in the correct order and, in this case, p rints out the type
APPENDIX G •Java Autoboxing and Enumeration 847
name followed by a dash followed by the String computed by the startDate()
method. The output when the printDates() method is called is given below:
☛ ✟
spring −Vernal Equinox
summer −Summer S o l s t i c e
f a l l−Autumnal Equinox
winter −Winter S o l s t i c e
✡ ✠
Thefor-in loop provides a very nice way to iterate through the values of any
enumerated type. You may wish to write a corresponding method for t he earlier
int representation of the seasons for a comparison.
Sun’s online Java 5.0 documentation provides a more precise deﬁniti on of enu-
merated types and describes quite a number of other features th at we have not
alluded to.
848 APPENDIX G •Java Autoboxing and Enumeration
Appendix H
Java and UML Resources
Reference Books
•David Flanagan, Java in a Nutshell Edition 5 , 5th ed., O’Reilly and Associates
2005. Part of the O’Reilly Java series, this book provides a concise desktop
reference to Java and the API.
•James Gosling, Bill Joy, and Guy Steele, The Java Language Speciﬁcation , 3d ed.,
Addison-Wesley, 2005. This book, which is part of Addison-Wesley ’s Java Se-
ries, provides a detailed description of the Java language. An on line version is
available at
☛ ✟
http : //java . sun . com/docs/books/ j l s
✡ ✠
•Martin Fowler, UML Distilled , 3d ed., Addison-Wesley, 2003. This book, which
is part of Addison-Wesley’s Object Technology Series, provides a con cise intro-
duction to UML.
Online References
•http://www.omg.org/ contains good information on UML.
•http://java.sun.com/j2se is one of Sun Microsystems’ Java Web sites.
From this page you can ﬁnd links to downloads of JDK, API speciﬁcati ons, and
documentation on all of Java, including Swing, AWT, and new featur es of Java
5.0.
•http://java.sun.com/docs/codeconv/ provides a description of coding
conventions suggested by the Java Language Speciﬁcation and followed by the
Java programming community. (These are summarized in Appendi x A.)
•http://java.sun.com/tutorial provides an online Java tutorial.
•http://www.JARS.com provides reviews and ratings of the best Java applets.
•http://www.java-news-center.org/ is a clearinghouse for Java news,
programming examples, debugging tips, and many other useful r esources.
849

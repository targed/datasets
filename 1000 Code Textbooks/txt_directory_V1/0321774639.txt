
Programming in Go
The Developer’s Library Series  from Addison-Wesley provides 
practicing programmers with unique, high-quality references and 
tutorials on the latest programming languages and technologies they 
use in their daily work. All books in the Developer’s Library are written by 
expert technology practitioners who are exceptionally skilled at organizing 
and presenting information in a way that’s useful for other programmers. 
Developer’s Library books cover a wide range of topics, from open-
source programming languages and databases, Linux programming, 
Microsoft,  and Java, to Web development, social networking platforms, 
Mac/iPhone programming, and Android programming.
Visit developers-library.com for a complete list of available productsDeveloper’s Library Series
Programming in Go
Creating Applications for the 21st Century
Mark Summerﬁeld
Upper Saddle River, NJ ·Boston ·Indianapolis ·San Francisco
pNew York ·Toronto ·Montreal ·London ·Munich ·Paris ·Madrid p
Capetown ·Sydney ·Tokyo ·Singapore ·Mexico City
Many of the designations used by manufacturersand sellers to distinguish their products are claimed as
trademarks. Where those designations appear in this book, and the publisher was aware of a trademark
claim, the designations have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but make no expressed or
implied warranty of any kind and assume no responsibility for errors or omissions. No liability is
assumed for incidental or consequential damages in connection with or arising out of the use of the
information or programs contained herein.
The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases
or special sales, which may include electronic versions and/or custom covers and content particular
to your business, training goals, marketing focus, and branding interests. For more information,
please contact:
        U.S. Corporate and Government Sales
        (800) 382-3419
        corpsales@pearsontechgroup.com
For sales outside the United States, please contact:
        International Sales
        international@pearsoned.com
Visit us on the Web: informit.com/aw
Library of Congress Cataloging-in-Publication Data
Summerﬁeld, Mark.
     Programming in Go : creating applications for the 21st century / Mark Summerﬁeld.
              p. mcm.
     Includes bibliographical references and index.
     ISBN 978-0-321-77463-7 (pbk. : alk. paper)
1. Go (Computer program language) 2. Computer programming 3. Application software—
Development I. Title.
     QA76.73.G63S86 2012
     005.13 ’3—dc23
2012001914
Copyright ©2012 Qtrac Ltd.
All rights reserved. Printed in the United States of America. This publication is protected by
copyright, and permission must be obtained from the publisher prior to any prohibited reproduction,
storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical,
photocopying, recording, or likewise. To obtain permission to use material from this work, please
submit a written request to Pearson Education, Inc., Permissions Department, One Lake Street, Upper
Saddle River, New Jersey 07458, or you may fax your request to (201) 236-3290.
ISBN-13: 978-0-321-77463-7
ISBN-10: 0-321-77463-9
Text printed in the United States on recycled paper at RR Donnelley in Crawfordsville, Indiana.
First printing, April 2012
This book is dedicated to
Jasmin Blanchette and Trenton Schulz
This page intentionally left blank 
Contents at a Glance
Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv
Introduction ...................................................... 1
Chapter 1. An Overview in Five Examples ...................... 7
Chapter 2. Booleans and Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Chapter 3. Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
Chapter 4. Collection Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
Chapter 5. Procedural Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
Chapter 6. Object-Oriented Programming . . . . . . . . . . . . . . . . . . . . . . 253
Chapter 7. Concurrent Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
Chapter 8. File Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Chapter 9. Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
Appendix A. Epilogue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
Appendix B. The Dangers of Software Patents . . . . . . . . . . . . . . . . . . 437
Appendix C. Selected Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
www.qtrac.eu/gobook.html
This page intentionally left blank 
Contents
Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv
Introduction ...................................................... 1
Why Go? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
The Structure of the Book ........................................ 4
Acknowledgments ................................................ 5
Chapter 1 .An Overview in Five Examples ........................ 7
1.1. Getting Going ................................................ 7
1.2. Editing, Compiling, and Running ............................ 9
1.3. Hello Who? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.4. Big Digits—Two-Dimensional Slices . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.5. Stack—Custom Types with Methods . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.6. Americanise—Files, Maps, and Closures . . . . . . . . . . . . . . . . . . . . . . 29
1.7. Polar to Cartesian—Concurrency . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
1.8. Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
Chapter 2 .Booleans and Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.1. Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.1.1. Constants and Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
2.1.1.1. Enumerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.2. Boolean Values and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
2.3. Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
2.3.1. Integer Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.3.1.1. Big Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
2.3.2. Floating-Point Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
2.3.2.1. Complex Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
2.4. Example: Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
2.4.1. Implementing Simple Statistics Functions . . . . . . . . . . . . . . . . 73
2.4.2. Implementing a Basic HTTP Server . . . . . . . . . . . . . . . . . . . . . . 75
2.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
ix
Chapter 3 .Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
3.1. Literals, Operators, and Escapes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
3.2. Comparing Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
3.3. Characters and Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
3.4. Indexing and Slicing Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
3.5. String Formatting with the Fmt Package . . . . . . . . . . . . . . . . . . . . . . 93
3.5.1. Formatting Booleans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
3.5.2. Formatting Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
3.5.3. Formatting Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
3.5.4. Formatting Floating-Point Numbers . . . . . . . . . . . . . . . . . . . . 100
3.5.5. Formatting Strings and Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
3.5.6. Formatting for Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
3.6. Other String-Related Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
3.6.1. The Strings Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
3.6.2. The Strconv Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
3.6.3. The Utf8 Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
3.6.4. The Unicode Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
3.6.5. The Regexp Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
3.7. Example: M3u2pls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
3.8. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Chapter 4 .Collection Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
4.1. Values, Pointers, and Reference Types . . . . . . . . . . . . . . . . . . . . . . . . 140
4.2. Arrays and Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
4.2.1. Indexing and Slicing Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
4.2.2. Iterating Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
4.2.3. Modifying Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.2.4. Sorting and Searching Slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
4.3. Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
4.3.1. Creating and Populating Maps . . . . . . . . . . . . . . . . . . . . . . . . . . 166
4.3.2. Map Lookups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
4.3.3. Modifying Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
4.3.4. Key-Ordered Map Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
4.3.5. Map Inversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
4.4. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
4.4.1. Example: Guess Separator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
4.4.2. Example: Word Frequencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
4.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
x
Chapter 5 .Procedural Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
5.1. Statement Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
5.1.1. Type Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
5.1.2. Type Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
5.2. Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
5.2.1. If Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
5.2.2. Switch Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
5.2.2.1. Expression Switches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
5.2.2.2. Type Switches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
5.3. Looping with For Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
5.4. Communication and Concurrency Statements . . . . . . . . . . . . . . . . 205
5.4.1. Select Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
5.5. Defer, Panic, and Recover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
5.5.1. Panic and Recover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
5.6. Custom Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
5.6.1. Function Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
5.6.1.1. Function Calls as Function Arguments . . . . . . . . . . . . . . 220
5.6.1.2. Variadic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
5.6.1.3. Functions with Multiple Optional Arguments . . . . . . . . 222
5.6.2. The init() and main() Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 224
5.6.3. Closures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
5.6.4. Recursive Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
5.6.5. Choosing Functions at Runtime . . . . . . . . . . . . . . . . . . . . . . . . . . 230
5.6.5.1. Branching Using Maps and Function References . . . . 230
5.6.5.2. Dynamic Function Creation . . . . . . . . . . . . . . . . . . . . . . . . 231
5.6.6. Generic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
5.6.7. Higher Order Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
5.6.7.1. Memoizing Pure Functions . . . . . . . . . . . . . . . . . . . . . . . . 241
5.7. Example: Indent Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
5.8. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
Chapter 6 .Object-Oriented Programming . . . . . . . . . . . . . . . . . . . . . . 253
6.1. Key Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
6.2. Custom Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
6.2.1. Adding Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
6.2.1.1. Overriding Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
6.2.1.2. Method Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
6.2.2. Validated Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
xi
6.3. Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
6.3.1. Interface Embedding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
6.4. Structs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
6.4.1. Struct Aggregation and Embedding . . . . . . . . . . . . . . . . . . . . . . 275
6.4.1.1. Embedding Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
6.4.1.2. Embedding Anonymous Values That Have Methods . . 277
6.4.1.3. Embedding Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
6.5. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
6.5.1. Example: FuzzyBool—A Single-Valued Custom Type . . . . . . 282
6.5.2. Example: Shapes—A Family of Custom Types . . . . . . . . . . . . 289
6.5.2.1. Package-Level Convenience Functions . . . . . . . . . . . . . . 289
6.5.2.2. A Hierarchy of Embedded Interfaces . . . . . . . . . . . . . . . . 294
6.5.2.3. Freely Composable Independent Interfaces . . . . . . . . . . 294
6.5.2.4. Concrete Types and Methods . . . . . . . . . . . . . . . . . . . . . . . . 295
6.5.3. Example: Ordered Map—A Generic Collection Type . . . . . . 302
6.6. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Chapter 7 .Concurrent Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
7.1. Key Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
7.2. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
7.2.1. Example: Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
7.2.2. Example: Concurrent Grep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
7.2.3. Example: Thread-Safe Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
7.2.4. Example: Apache Report . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
7.2.4.1. Synchronizing with a Shared Thread-Safe Map . . . . . . 341
7.2.4.2. Synchronizing with a Mutex-Protected Map . . . . . . . . 345
7.2.4.3. Synchronizing by Merging Local Maps via Channels 347
7.2.5. Example: Find Duplicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
7.3. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
Chapter 8 .File Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
8.1. Custom Data Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
8.1.1. Handling JSON Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
8.1.1.1. Writing JSON Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366
8.1.1.2. Reading JSON Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
8.1.2. Handling XML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
8.1.2.1. Writing XML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
8.1.2.2. Reading XML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
8.1.3. Handling Plain Text Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
xii
8.1.3.1. Writing Plain Text Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
8.1.3.2. Reading Plain Text Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
8.1.4. Handling Go Binary Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
8.1.4.1. Writing Go Binary Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
8.1.4.2. Reading Go Binary Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386
8.1.5. Handling Custom Binary Files . . . . . . . . . . . . . . . . . . . . . . . . . . 387
8.1.5.1. Writing Custom Binary Files . . . . . . . . . . . . . . . . . . . . . . 388
8.1.5.2. Reading Custom Binary Files . . . . . . . . . . . . . . . . . . . . . . 392
8.2. Archive Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
8.2.1. Creating Zip Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
8.2.2. Creating Optionally Compressed Tarballs . . . . . . . . . . . . . . . . 399
8.2.3. Unpacking Zip Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
8.2.4. Unpacking Optionally Compressed Tarballs . . . . . . . . . . . . . . 403
8.3. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405
Chapter 9 .Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
9.1. Custom Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
9.1.1. Creating Custom Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
9.1.1.1. Platform-Speciﬁc Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
9.1.1.2. Documenting Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
9.1.1.3. Unit Testing and Benchmarking Packages . . . . . . . . . . 414
9.1.2. Importing Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
9.2. Third-Party Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
9.3. A Brief Survey of Go’s Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
9.4. A Brief Survey of the Go Standard Library . . . . . . . . . . . . . . . . . . . . 419
9.4.1. Archive and Compression Packages . . . . . . . . . . . . . . . . . . . . . . 419
9.4.2. Bytes and String-Related Packages . . . . . . . . . . . . . . . . . . . . . . 419
9.4.3. Collection Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
9.4.4. File, Operating System, and Related Packages . . . . . . . . . . . . 423
9.4.4.1. File Format-Related Packages . . . . . . . . . . . . . . . . . . . . . . 424
9.4.5. Graphics-Related Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
9.4.6. Mathematics Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
9.4.7. Miscellaneous Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
9.4.8. Networking Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
9.4.9. The Reﬂect Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
9.5. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
xiii
Appendix A .Epilogue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
Appendix B .The Dangers of Software Patents . . . . . . . . . . . . . . . . . . 437
Appendix C .Selected Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
xiv
Tables
2.1. Go’s Keywords .............................................. 52
2.2. Go’s Predeﬁned Identiﬁers .................................. 52
2.3. Boolean and Comparison Operators .......................... 57
2.4. Arithmetic Operators Applicable to All Built-In Numbers ...... 59
2.5. Go’s Integer Types and Ranges .............................. 60
2.6. Arithmetic Operators Applicable Only to Built-In Integer Types 60
2.7. Go’s Floating-Point Types .................................... 64
2.8. The Math Package’s Constants and Functions #1 .............. 65
2.9. The Math Package’s Constants and Functions #2 .............. 66
2.10. The Math Package’s Constants and Functions #3 .............. 67
2.11. The Complex Math Package’s Functions ...................... 71
3.1. Go’s String and Character Escapes .......................... 84
3.2. String Operations .......................................... 85
3.3. The Fmt Package’s Print Functions .......................... 94
3.4. The Fmt Package’s Verbs .................................... 95
3.5. The Fmt Package’s Verb Modiﬁers ............................ 96
3.6. The Strings Package’s Functions #1 .......................... 108
3.7. The Strings Package’s Functions #2 .......................... 109
3.8. The Strconv Package’s Functions #1 .......................... 114
3.9. The Strconv Package’s Functions #2 .......................... 115
3.10. The Utf8 Package’s Functions ................................ 118
3.11. The Unicode Package’s Functions ............................ 119
3.12. The Regexp Package’s Functions ............................ 121
3.13. The Regexp Package’s Escape Sequences .................... 121
3.14. The Regexp Package’s Character Classes .................... 122
3.15. The Regexp Package’s Zero-Width Assertions ................ 122
3.16. The Regexp Package’s Quantiﬁers ............................ 123
3.17. The Regexp Package’s Flags and Groups ...................... 123
3.18. The *regexp.Regexp Type’s Methods #1 ...................... 124
3.19. The *regexp.Regexp Type’s Methods #2 ...................... 125
4.1. Slice Operations ............................................ 151
xv
4.2. The Sort Package’s Functions ................................ 161
4.3. Map Operations ............................................ 165
5.1. Built-In Functions .......................................... 187
8.1. Format Speed and Size Comparisons ........................ 363
8.2. The Fmt Package’s Scan Functions .......................... 383
xvi
Introduction
The purpose of this book is to teach solid idiomatic Go programming using
all the features the language provides, as well as the most commonly used Go
packages from Go’s standard library. The book is also designed to serve as a
useful reference once the language is learned. To meet both of these goals the
book is quite comprehensive and tries to cover every topic in just one place—and
with forward and backward cross-references throughout.
Go is quite C-like in spirit, being a small and efﬁcient language with convenient
low-level facilities such as pointers. Yet Go also offers many features associated
with high- or very high-level languages, such as Unicode strings, powerful built-
in data structures, duck typing, garbage collection, and high-level concurrency
support that uses communication rather than shared data and locks. Go also
has a large and wide-ranging standard library.
The reader is assumed to have programming experience in a mainstream pro-
gramming language such as C, C ++, Java,Python,or similar,although all of Go’s
unique features and idioms are illustrated with complete runnable examples
that are fully explained in the text.
To successfully learn any programming language it is necessary to write pro-
grams in that language. To this end the book’s approach is wholly practical, and
readers are encouraged to experiment with the examples, try the exercises, and
write their own programs to get hands-on experience. As with all my previous
books, the quoted code snippets are of “live code”; that is, the code was auto-
matically extracted from .gosource ﬁles and directly embedded in the PDF that
went to the publisher—so there are no cut and paste errors, and the code works.
Wherever possible, small but complete programs and packages are used as ex-
amples to provide realistic use cases. The examples, exercises, and solutions are
available online at www.qtrac.eu/gobook.html .
The book’s key aim is to teach the Go language, and although many of the
standard Go packages are used, not all of them are. This is not a problem, since
reading the book will provide enough Go knowledge for readers to be able to
make use of any of the standard packages, or any third-party Go package, and
of course, be able to create their own packages.
Why Go?
The Go programming language began as an internal Google project in 2007. The
original design was by Robert Griesemer and Unix luminariesRob Pike and Ken
Thompson. On November 10, 2009, Go was publicly unveiled under a liberal
1
2 Introduction
open source license. Go is being developed by a team at Google which includes
the original designers plus Russ Cox, Andrew Gerrand, Ian Lance Taylor, and
many others. Go has an open development model and many developers from
around the world contribute to it, with some so trusted and respected that they
have the same commit privileges as the Googlers. In addition, many third-party
Go packages are available from the Go Dashboard ( godashboard.appspot.com/
project).
Go is the most exciting new mainstream language to appear in at least 15
years and is the ﬁrst such language that is aimed squarely at 21st century
computers—and their programmers.
Go is designed to scale efﬁciently so that it can be used to build very big appli-
cations—and to compile even a large program in mere seconds on a single com-
puter. The lightning-fast compilation speed is made possible to a small extent
because the language is easy to parse, but mostly because of its dependency
management. If ﬁle app.go depends on ﬁle pkg1.go ,w h i c hi nt u r nd e p e n d so n
pkg2.go , in a conventional compiled language app.go would need both pkg1.go ’s
and pkg2.go ’s object ﬁles. But in Go, everything that pkg2.go exports is cached
inpkg1.go ’s object ﬁle, so pkg1.go ’s object ﬁle alone is sufﬁcient to build app.go .
For just three ﬁles this hardly matters, but it results in huge speedups for large
applications with lots of dependencies.
Since Go programs are so fast to build, it is practical to use them in situations
where scripting languages are normally used (see the sidebar “Go Shebang
Scripts”, ➤10). Furthermore, Go can be used to build web applications using
Google’s App Engine.
Go uses a very clean and easy-to-understand syntax that avoids the complexity
and verbosity of older languages like C ++(ﬁrst released in 1983) or Java (ﬁrst
released in 1995). And Go is a strongly statically typed language, something
which many programmers regard as essential for writing large programs. Yet
Go’s typing is not burdensome due to Go’s short “declare and initialize” variable
declaration syntax (where the compiler deduces the type so it doesn’t have to be
written explicitly), and because Go supports a powerful and convenient version
of duck typing.
Languages like C and C ++require programmers to do a vast amount of book-
keeping when it comes to memory management—bookkeeping that could be
done by the computer itself, especially for concurrent programs where keeping
track can be ﬁendishly complicated. In recent years C ++has greatly improved
in this area with various “smart” pointers, but is only just catching up with Java
with regard to its threading library. Java relieves the programmer from the
burden of memory management by using a garbage collector. C has only third-
party threading libraries, although C ++now has a standard threading library.
However, writing concurrent programs in C, C ++, or Java requires considerable
Introduction 3
bookkeeping by programmers to make sure they lock and unlock resources at
the right times.
The Go compiler and runtime system takes care of the tedious bookkeeping. For
memory management Go has a garbage collector, so there’s no need for smart
pointers or for manually freeing memory. And for concurrency, Go provides a
form of CSP (Communicating Sequential Processes) based on the ideas of com-
puter scientist C. A. R. Hoare, that means that many concurrent Go programs
don’t need to do any locking at all. Furthermore, Go uses goroutines —very
lightweight processes which can be created in vast numbers that are automati-
cally load-balanced across the available processors and cores—to provide much
more ﬁne-grained concurrency than older languages’ thread-based approach-
es. In fact, Go’s concurrency support is so simple and natural to use that when
porting single-threaded programs to Go it often happens that opportunities for
using concurrency arise that lead to improved runtimes and better utilization of
machine resources.
Go is a pragmatic language that favors efﬁciency and programmer convenience
over purity. For example, Go’s built-in types and user-deﬁned types are not the
same, since the former can be highly optimized in ways the latter can’t be. Go
also provides two fundamental built-in collection types: slices (for all practical
purposes these are references to variable-length arrays) and maps (key–value
dictionaries or hashes). These collection types are highly efﬁcient and serve
most purposes extremely well. However, Go supports pointers (it is a fully com-
piled language—there’s no virtual machine getting in the way of performance),
so it is possible to create sophisticated custom types, such as balanced binary
trees, with ease.
While C supports only procedural programming and Java forces programmers
to program everything in an object-oriented way, Go allows programmers to use
the paradigm best suited to the problem. Go can be used as a purely procedural
language, but also has excellent support for object-oriented programming. As
we will see, though, Go’s approach to object orientation is radically different
from, say, C ++,J a v a ,o rP y t h o n — a n di se a s i e rt ou s ea n dm u c hm o r eﬂ e x i b l e
than earlier forms.
Like C, Go lacks generics (templates in C ++-speak); however, in practice the
other facilities that Go provides in many cases obviate the need for generics.
Go does not use a preprocessor or include ﬁles (which is another reason why it
compiles so fast), so there is no need to duplicate function signatures as there is
in C and C ++.A n dw i t hn op r e p r o c e s s o r ,ap r o g r a m ’ ss e m a n t i c sc a n n o tc h a n g e
behind a Go programmer’s back as it can with careless #deﬁne s in C and C ++.
Arguably, C ++, Objective-C, and Java have all attempted to be better Cs (the
latter indirectly as a better C ++).Go can also be seen as an attempt to be a better
C, even though Go’s clean, light syntax is reminiscent of Python—and Go’s slices
and maps are very similar to Python’s lists and dicts. However, Go is closer in
4 Introduction
spirit to C than to any other language, and can be seen as an attempt to avoid C’s
drawbacks while providing all that’s best in C, as well as adding many powerful
and useful features that are unique to Go.
Originally Go was conceived as a systems programming language for developing
large-scale programs with fast compilation that could take advantage of dis-
tributed systems and multicore networked computers. Go’s reach has already
gone far beyond the original conception and it is now being used as a highly
productive general-purpose programming language that’s a pleasure to use and
maintain.
The Structure of the Book
Chapter 1 begins by explaining how to build and run Go programs. The chapter
then provides a brief overview of Go’s syntax and features, as well as introduc-
ing some of its standard library. This is done by presenting and explaining a se-
ries of ﬁve very short examples, each illustrating a variety of Go features. This
chapter is designed to provide just a ﬂavor of the language and to give readers a
feel for the scope of what is required to learn Go. (How to obtain and install Go
is also explained in this chapter.)
Chapters 2 to 7 cover the Go language in depth. Three chapters are devoted
to built-in data types: Chapter 2 covers identiﬁers, Booleans, and numbers;
Chapter 3 covers strings; and Chapter 4 covers Go’s collection types.
Chapter 5 describes and illustrates Go’s statements and control structures.
It also explains how to create and use custom functions, and completes the
chapters that show how to create procedural nonconcurrent programs in Go.
Chapter 6 shows how to do object-oriented programming in Go. This chapter
includes coverage of Go structs used for aggregating and embedding (delegat-
ing) values, and Go interface s for specifying abstract types, as well as how to
produce an inheritance-like effect in some situations. The chapter presents
several complete fully explained examples to help ensure understanding, since
Go’s approach to object orientation may well be different from most readers’ ex-
perience.
Chapter 7 covers Go’s concurrency features and has even more examples than
the chapter on object orientation, again to ensure a thorough understanding of
these novel aspects of the Go language.
Chapter 8 shows how to read and write custom binary, Go binary, text, JSON,
and XML ﬁles. (Reading and writing text ﬁles is very brieﬂy covered in Chap-
ter 1 and several subsequent chapters since this makes it easier to have useful
examples and exercises.)
The book’s ﬁnal chapter is Chapter 9. This chapter begins by showing how to
import and use standard library packages, custom packages, and third-party
Introduction 5
packages. It also shows how to document, unit test, and benchmark custom
packages. The chapter’s last sections provide brief overviews of the tools
provided with the gccompiler, and of Go’s standard library.
Although Go is quite a small language, it is a very rich and expressive language
(as measured in syntactic constructs,concepts,and idioms), so there is a surpris-
ing amount to learn. This book shows examples in good idiomatic Go style right
from the start.★This approach, of course, means that some things are shown be-
fore being fully explained. We ask the reader to take it on trust that everything
will be explained over the course of the book (and, of course, cross-references are
provided for everything that is not explained on the spot).
Go is a fascinating language, and one that is really nice to use. It isn’t hard to
learn Go’s syntax and idioms,but it does introduce some novel conceptsthat may
be unfamiliar to many readers. This book tries to give readers the conceptual
breakthroughs—especially in object-oriented Go programming and in concur-
rent Go programming—that might take weeks or even months for those whose
only guide is the good but rather terse documentation.
Acknowledgments
Every technical book I have ever written has beneﬁted from the help and advice
of others, and this one is no different in this regard.
I want to give particular thanks to two friends who are programmers with
no prior Go experience: Jasmin Blanchette and Trenton Schulz. Both have
contributed to my books for many years, and in this case their feedback has
helped to ensure that this book will meet the needs of other programmers new
to Go.
The book was also greatly enhanced by the feedback I received from core Go
developer Nigel Tao. I didn’t always take his advice, but his feedback was
always illuminating and resulted in great improvements both to the code and to
the text.
Ih a da d d i t i o n a lh e l pf r o mo t h e r s ,i n c l u d i n gD a v i dB o d d i e ,ap r o g r a m m e rn e w
to Go, who gave some valuable feedback. And Go developers Ian Lance Taylor,
and especially Russ Cox, between them solved many problems both of code and
concepts, and provided clear and precise explanations that contributed greatly
to the book’s accuracy.
During the writing of the book I asked many questions on the golang-nuts mail-
ing list and always received thoughtful and useful replies from many different
★The one exception is that in the early chapters we always declare channels to be bidirectional,
even when they are used only unidirectionally. Channels are declared to have a particular direction
wherever this makes sense, starting from Chapter 7.
6 Introduction
posters. I also received feedback from readers of the Safari “rough cut” preview
edition that led to some important clariﬁcations.
The Italian software company www.develer.com , in the person of Giovanni Bajo,
was kind enough to provide me with free Mercurial repository hosting to aid
my peace of mind over the long process of writing this book. Thanks to Lorenzo
Mancini for setting it all up and looking after it for me. I’m also very grateful
to Anton Bowers and Ben Thompson who have been hosting my web site,
www.qtrac.eu , on their web server since early 2011.
Thanks to Russel Winder for his coverage of software patents in his blog, www
.russel.org.uk . Appendix B borrows a number of his ideas.
And as always, thanks to Jeff Kingston, creator of the lout typesetting sys-
tem that I have used for all my books and many other writing projects over
many years.
Particular thanks to my commissioning editor, Debra Williams Cauley, who so
successfully made the case for this book with the publisher, and who provided
support and practical help as the work progressed.
Thanks also to production manager Anna Popick, who once again managed the
production process so well, and to the proofreader, Audrey Doyle, who did such
excellent work.
As ever, I want to thank my wife, Andrea, for her love and support.
1An Overview in Five
Examples
§1.1. Getting Going ➤7
§1.2. Editing, Compiling, and Running ➤9
§1.3. Hello Who? ➤14
§1.4. Big Digits—Two-Dimensional Slices ➤16
§1.5. Stack—Custom Types with Methods ➤21
§1.6. Americanise—Files, Maps, and Closures ➤29
§1.7. Polar to Cartesian—Concurrency ➤40
This chapter provides a series of ﬁve explained examples. Although the exam-
ples are tiny, each of them (apart from “Hello Who?”) does something useful,
and between them they provide a rapid overview of Go’s key features and some
of its key packages. (What other languages often call “modules” or “libraries”
are called packages in Go terminology, and all the packages supplied with Go as
standard are collectively known as the Go standard library .) The chapter’s pur-
pose is to provide a ﬂavor of Go and to give a feel for the scope of what needs to
be learned to program successfully in Go. Don’t worry if some of the syntax or
idioms are not immediately understandable;everything shown in this chapter is
covered thoroughly in subsequent chapters.
Learning to program Go the Go way will take a certain amount of time and
practice. For those wanting to port substantial C, C ++, Java, Python, and other
programs to Go, taking the time to learn Go—and in particular how its object-
orientation and concurrency features work—will save time and effort in the long
run. And for those wanting to create Go applications from scratch it is best to
do so making the most of all that Go offers, so again the upfront investment in
learning time is important—and will pay back later.
1.1. Getting Going
Go programs are compiled rather than interpreted so as to have the best possible
performance. Compilation is very fast—dramatically faster than can be the
case with some other languages, most notably compared with C and C ++.
7
8 Chapter 1. An Overview in Five Examples
The Go Documentationi
Go’s ofﬁcial web site is golang.org which hosts the most up-to-date Go docu-
mentation. The “Packages” link provides access to the documentation on all
the Go standard library’s packages—and to their source code, which can be
very helpful when the documentation itself is sparse. The “Commands” link
leads to the documentation for the programs distributed with Go (e.g., the
compilers, build tools, etc.). The “Speciﬁcation” link leads to an accessible, in-
formal, and quite thorough Go language speciﬁcation. And the “Effective Go”
link leads to a document that explains many best practices.
The web site also features a sandbox in which small (somewhat limited) Go
programs can be written, compiled, and run, all online. This is useful for be-
ginners for checking odd bits of syntax and for learning the Go fmtpackage’s
sophisticated text formatting facilities or the regexppackage’s regular expres-
sion engine. The Go web site’s search box searches only the Go documenta-
tion; to search for Go resources generally, visit go-lang.cat-v.org/go-search .
The Go documentation can also be viewed locally, for example, in a web
browser. To do this, run Go’s godoctool with a command-line argument that
tells it to operate as a web server. Here’s how to do this in a Unix console
(xterm,gnome-terminal ,konsole,Terminal.app , or similar):
$godoc -http=:8000
Or in a Windows console (i.e., a Command Prompt orMS-DOS Prompt window):
C:\>godoc -http=:8000
The port number used here is arbitrary—simply use a different one if it
conﬂicts with an existing server. This assumes that godocis in your PATH.
To view the served documentation, open a web browser and give it a location
ofhttp://localhost:8000 . This will present a page that looks very similar to
thegolang.org web site’s front page. The “Packages” link will show the docu-
mentation for Go’s standard library, plus any third-party packages that have
been installed under GOROOT. IfGOPATHis deﬁned (e.g., for local programs and
packages), a link will appear beside the “Packages” link through which the
relevant documentation can be accessed. (The GOROOTandGOPATHenvironment
variables are discussed later in this chapter and in Chapter 9.)
It is also possible to view the documentation for a whole package or a single
item in a package in the console using godocon the command line. For ex-
ample, executing godoc image NewRGBA will output the documentation for the
image.NewRGBA() function, and executing godoc image/png will output the docu-
mentation for the entire image/png package.
1.1. Getting Going 9
The standard Go compiler is called gcand its toolchain includes programs such
as5g,6g, and 8gfor compiling, 5l,6l, and 8lfor linking, and godocfor viewing the
Go documentation. (These are 5g.exe,6l.exe, etc., on Windows.) The strange
names follow the Plan 9 operating system’s compiler naming conventions where
the digit identiﬁes the processor architecture (e.g., “5” for ARM, “6” for AMD-
64—including Intel 64-bit processors—and “8” for Intel 386.) Fortunately, we
don’t need to concern ourselves with these tools, since Go provides the high-level
gobuild tool that handles the compiling and linking for us.
All the examples in this book—available from www.qtrac.eu/gobook.html —have
been tested using gcon Linux, Mac OS X, and Windows using Go 1. The Go
developers intend to make all subsequent Go 1. xversions backward compatible
with Go 1, so the book’s text and examples should be valid for the entire 1. x
series. (If incompatible changes occur, the book’s examples will be updated to
the latest Go release, so as time goes by, they may differ from the code shown in
the book.)
To download and install Go, visit golang.org/doc/install.html which provides
instructions and download links. At the time of this writing, Go 1 is available in
source and binary form for FreeBSD 7+, Linux 2.6+, Mac OS X (Snow Leopard
and Lion), and Windows 2000+, in all cases for Intel 32-bit and AMD 64-bit
processor architectures. There is also support for Linux on ARM processors. Go
prebuilt packages are available for the Ubuntu Linux distribution, and may be
available for other Linuxes by the time you read this. For learning to program
in Go it is easier to install a binary version than to build Go from scratch.
Programs built with gcuse a particular calling convention. This means that
programs compiled with gccan be linked only to external libraries that use the
same calling convention—unless a suitable tool is used to bridge the difference.
Go comes with support for using external C code from Go programsin the form of
thecgotool ( golang.org/cmd/cgo ), and at least on Linux and BSD systems, both C
and C ++code can be used in Go programs using the SWIG tool ( www.swig.org ).
In addition to gcthere is also the gccgocompiler. This is a Go-speciﬁc front end
togcc(the GNU Compiler Collection) available for gccfrom version 4.6. Like gc,
gccgomay be available prebuilt for some Linux distributions. Instructions for
building and installing gccgoare given at golang.org/doc/gccgo_install.html .
1.2. Editing, Compiling, and Running
Go programs are written as plain text Unicode using the UTF-8 encoding.★
Most modern text editors can handle this automatically, and some of the most
popular may even have support for Go color syntax highlighting and automatic
★Some Windows editors (e.g., Notepad) go against the Unicode standard’s recommendation and
insert the bytes 0xEF,0xBB,0xBF, at the start of UTF-8 ﬁles. This book’s examples assume that UTF-8
ﬁles do not have these bytes.
10 Chapter 1. An Overview in Five Examples
Go Shebang Scriptsi
One side effect of Go’s fast compilation is that it makes it realistic to write
Go programs that can be treated as shebang #!scripts on Unix-like systems.
This requires a one-off step of installing a suitable tool. At the time of this
writing, two rival tools provide the necessary functionality: gonow(github.com/
kless/gonow ), and gorun(wiki.ubuntu.com/gorun ).
Once gonoworgorunis available, we can make any Go program into a
shebang script. This is done with two simple steps. First, add either
#!/usr/bin/env gonow or#!/usr/bin/env gorun , as the very ﬁrst line of the .go
ﬁle that contains the main()function (in package main). Second, make the ﬁle
executable (e.g., with chmod +x). Such ﬁles can only be compiled by gonowor
gorunrather than in the normal way since the #!line is not legal in Go.
When gonoworgorunexecutes a .goﬁle for the ﬁrst time, it will compile the
ﬁle (extremely fast, of course), and then run it. On subsequent uses, the
program will only be recompiled if the .gosource ﬁle has been modiﬁed since
the previous compilation. This makes it possible to use Go to quickly and
conveniently create various small utility programs, for example, for system
administration tasks.
indentation. If your editor doesn’t have Go support, try entering the editor’s
name in the Go search engine to see if there are suitable add-ons. For editing
convenience, all of Go’s keywords and operators use ASCII characters; however,
Go identiﬁers can start with any Unicode letter followed by any Unicode letters
or digits, so Go programmers can freely use their native language.
To get a feel for how we edit, compile, and run a Go program we’ll start with
the classic “Hello World” program—although we’ll make it a tiny bit more
sophisticated than usual. First we will discuss compiling and running, then in
the next section we will go through the source code—in ﬁle hello/hello.go —in
detail, since it incorporates some basic Go ideas and features.
All of the book’s examples are available from www.qtrac.eu/gobook.html and
unpack to directory goeg. So ﬁle hello.go’s full path (assuming the exam-
ples were unpacked in the home directory—although anywhere will do) is
$HOME/goeg/src/hello/hello.go . When referring to ﬁles the book always assumes
the ﬁrst three components of the path, which is why in this case the path is giv-
en only as hello/hello.go . (Windows users must, of course, read “ /”s as “ \”s and
use the directory they unpacked the examples into, such as C:\goegor%HOME-
PATH%\goeg .)
If you have installed Go from a binary package or built it from source and in-
stalled it as root or Administrator, you should have at least one environment
variable, GOROOT,w h i c hc o n t a i n st h ep a t ht ot h eG oi n s t a l l a t i o n ,a n dy o u r PATH
should now include $GOROOT/bin or%GOROOT%\bin .T oc h e c kt h a tG oi si n s t a l l e d
1.2. Editing,Compiling,and Running 11
correctly, enter the following in a console ( xterm,gnome-terminal ,konsole,Termi-
nal.app, or similar):
$go version
Or on Windows in an MS-DOS Prompt orCommand Prompt window:
C:\>go version
If you get a “command not found” or “‘go’ is not recognized…” error message
then it means that Go isn’t in the PATH. The easiest way to solve this on Unix-like
systems (including Mac OS X) is to set the environment variables in .bashrc
(or the equivalent ﬁle for other shells). For example, the author’s .bashrcﬁle
contains these lines:
export GOROOT=$HOME/opt/go
export PATH=$PATH:$GOROOT/bin
Naturally, you must adjust the values to match your own system. (And, of
course, this is only necessary if the go version command fails.)
On Windows, one solution is to create a batch ﬁle that sets up the environment
for Go, and to execute this every time you start a console for Go programming.
However, it is much more convenient to set the environment variables once and
for all through the Control Panel .T od ot h i s ,c l i c k Start (the Windows logo), then
Control Panel , then System and Security , then System , then Advanced system settings ,
and in the System Properties dialog click the Environment Variables button, then the
New… button, and add a variable with the name GOROOTand a suitable value,
such as C:\Go. In the same dialog, edit the PATHenvironment variable by adding
the text ;C:\Go\bin at the end—the leading semicolon is vital! In both cases
replace the C:\Gopath component with the actual path where Go is installed if
it isn’t C:\Go. (Again, this is only necessary if the go version command failed.)
From now on we will assume that Go is installed and the Go bindirectory
containing all the Go tools is in the PATH. (It may be necessary—once only—to
open a new console window for the new settings to take effect.)
Two steps are required to build Go programs: compiling and linking.★Both of
these steps are handled by the gotool which can not only build local programs
and packages, but can also fetch, build, and install third-party programs
and packages.
★Since the book assumes the use of the gccompiler, readers using gccgowill need to follow the
compile and link process described in golang.org/doc/gccgo_install.html . Similarly, readers using
other compilers will need to compile and link as per their compiler’s instructions.
12 Chapter 1. An Overview in Five Examples
For the gotool to be able to build local programs and packages, there are three
requirements. First, the Go bindirectory ( $GOROOT/bin or%GOROOT%\bin ) must be
in the path. Second, there must be a directory tree that has an srcdirectory
and under which the source code for the local programs and packages resides.
For example, the book’s examples unpack to goeg/src/hello ,goeg/src/bigdigits ,
and so on. Third, the directory above thesrcdirectory must be in the GOPATH
environment variable. For example, to build the book’s helloexample using the
gotool, we must do this:
$export GOPATH=$HOME/goeg
$cd $GOPATH/src/hello
$go build
We can do almost exactly the same on Windows:
C:\>set GOPATH=C:\goeg
C:\>cd %gopath%\src\hello
C:\goeg\src\hello> go build
In both cases we assume that the PATHincludes $GOROOT/bin or%GOROOT%\bin .Once
thegotool has built the program we can run it. By default the executable is
given the same name as the directory it is in (e.g., helloon Unix-like systemsand
hello.exe on Windows). Once built, we can run the program in the usual way.
$./hello
Hello World!
Or:
$./hello Go Programmers!
Hello Go Programmers!
On Windows it is very similar:
C:\goeg\src\hello> hello Windows Go Programmers!
Hello Windows Go Programmers!
We have shown what must be typed in bold and the console’s text in roman.W e
have also assumed a $prompt, but it doesn’t matter what it is (e.g., C:\>).
Note that we do notneed to compile—or even explicitly link—any other pack-
ages (even though as we will see, hello.go uses three standard library packages).
This is another reason why Go programs build so quickly.
1.2. Editing,Compiling,and Running 13
If we have several Go programs, it would be convenient if all their executables
could be in a single directory that we could add to our PATH. Fortunately, the go
tool supports this as follows:
$export GOPATH=$HOME/goeg
$cd $GOPATH/src/hello
$go install
Again, we can do the same on Windows:
C:\>set GOPATH=C:\goeg
C:\>cd %gopath%\src\hello
C:\goeg\src\hello> go install
The go install command does the same as go build only it puts the executable
in a standard location ( $GOPATH/bin or%GOPATH%\bin ). This means that by adding
a single path ( $GOPATH/bin or%GOPATH%\bin ) to our PATH,allthe Go programs that
we install will conveniently be in the PATH.
In addition to the book’s examples, we are likely to want to develop our own
Go programs and packages in our own directory. This can easily be accom-
modated by setting the GOPATHenvironment variable to two (or more) colon-
separated paths (semicolon-separated on Windows); for example, export
GOPATH=$HOME/app/go:$HOME/goeg orSET GOPATH=C:\app\go;C:\goeg .★In this case
we must put all our program and package’s source code in $HOME/app/go/src or
C:\app\go\src . So, if we develop a program called myapp, its.gosource ﬁles would
go in $HOME/app/go/src/myapp orC:\app\go\src\myapp . And if we use go install to
build a program in a GOPATHdirectory where the GOPATHhas two or more directo-
ries, the executable will be put in the corresponding directory’s bindirectory.
Naturally, it would be tedious to export or set the GOPATHevery time we wanted
to build a Go program,so it is best to set this environment variable permanently.
This can be done by setting GOPATHin the .bashrcﬁle (or similar) on Unix-like
systems (see the book’s example’s gopath.sh ﬁle). On Windows it can be done
either by writing a batch ﬁle (see the book’s example’s gopath.bat ﬁle), or by
adding it to the system’s environment variables: Click Start (the Windows logo),
then Control Panel , then System and Security , then System , then Advanced system
settings , and in the System Properties dialog click the Environment Variables button,
then the New… button, and add a variable with the name GOPATHand a suitable
value, such as C:\goegorC:\app\go;C:\goeg .
Although Go uses the gotool as its standard build tool, it is perfectly possible to
usemakeor some of the modern build tools, or to use alternative Go-speciﬁc build
★From now on we will almost always show Unix-style command lines only, and assume that
Windows programmers can mentally translate.
14 Chapter 1. An Overview in Five Examples
tools, or add-ons for popular IDEs (Integrated Development Environments)
such as Eclipse and Visual Studio.
1.3. Hello Who?
Now that we have seen how to build the helloprogram we will look at its source
code. Don’t worry about understanding all the details—everything shown
in this chapter (and much more!) is covered thoroughly in the subsequent
chapters. Here is the complete helloprogram (in ﬁle hello/hello.go ):
// hello.go
package main
import (➊
"fmt"
"os"
"strings"
)
func main() {
    who := "World!" ➋
if len (os.Args) > 1{/*os.Args[0] is "hello" or "hello.exe" */➌
        who = strings.Join(os.Args[ 1:],"")➍
    }
    fmt.Println( "Hello", who)➎
}
Go uses C ++-style comments: //for single-line comments that ﬁnish at the end
of the line and /*…*/for comments that can span multiple lines. It is conven-
tional in Go to mostly use single-line comments, with spanning comments often
used for commenting out chunks of code during development.★
Every piece of Go code exists inside a package, and every Go program must have
amainpackage with a main()function which serves as the program’s entry point,
that is, the function that is executed ﬁrst. In fact, Go packages may also have
init()functions that are executed before main(), as we will see (§1.7, ➤40); full
details are given later (§5.6.2, ➤224). Notice that there is no conﬂict between
the name of the package and the name of the function.
Go operates in terms of packages rather than ﬁles. This means that we can split
ap a c k a g ea c r o s sa sm a n yﬁ l e sa sw el i k e ,a n df r o mG o ’ sp o i n to fv i e wi ft h e ya l l
have the same package declaration, they are all part of the same package and
no different than if all their contents were in a single ﬁle. Naturally, we can also
★We use some simple syntax highlighting and sometimes highlight lines or annotate them with
numbers ( ➊,➋, …), for ease of reference in the text. None of this is part of the Go language.
1.3. Hello Who? 15
break our applications’ functionality into as many local packages as we like, to
keep everything neatly modularized, something we will see in Chapter 9.
The importstatement (14 ➤,➊)i m p o r t st h r e ep a c k a g e sf r o mt h es t a n d a r dl i -
brary. The fmtpackage provides functions for formatting text and for read-
ing formatted text (§3.5, ➤93), the ospackage provides platform-independent
operating-system variables and functions, and the stringspackage provides
functions for manipulating strings (§3.6.1, ➤107).
Go’s fundamental types support the usual operators (e.g., +for numeric addition
and for string concatenation),and the Go standard library supplementsthese by
providing packages of functions for working with the fundamental types, such
asthe stringspackage imported here. It isalso possible to create our own custom
types based on the fundamental types and to provide our own methods—that
is, custom type-speciﬁc functions—for them. (We will get a taste of this in §1.5,
➤21, with full coverage in Chapter 6.)
The reader may have noticed that the program has no semicolons, that the im-
ports are not comma-separated, and that the ifstatement’s condition does not
require parentheses. In Go, blocks, including function bodies and control struc-
ture bodies (e.g., for ifstatements and for forloops), are delimited using braces.
Indentation is used purely to improve human readability. Technically, Go state-
ments are separated by semicolons, but these are put in by the compiler, so we
don’t have to use them ourselves unless we want to put multiple statements on
the same line. No semicolons and fewer commas and parentheses give Go pro-
grams a lighter look and require less typing.
Go functions and methods are deﬁned using the funckeyword. The mainpack-
age’s main()function always has the same signature—it takes no arguments
and returns nothing. When main.main() ﬁnishes the program will terminate and
return 0to the operating system. Naturally, we can exit whenever we like and
return our own choice of value, as we will see (§1.4, ➤16).
The ﬁrst statement in the main()function (14 ➤,➋; using the :=operator) is
called a short variable declaration in Go terminology. Such a statement both
declares and initializes a variable at the same time. Furthermore,we don’t need
to specify the variable’s type because Go can deduce that from the initializing
value. So in this case we have declared a variable called whoof type string, and
thanks to Go’s strong typing we may only assign strings to who.
As with most languages the ifstatement tests a condition—in this case, how
many strings were entered on the command-line—which if satisﬁed executes
the corresponding brace-delimited block. We will see a more sophisticated
ifstatement syntax later in this chapter (§1.6, ➤29), and further on (§5.2.1,
➤192).
The os.Argsvariable is a slice of strings (14 ➤,➌). Arrays, slices, and other col-
lection data types are covered in Chapter 4 (§4.2, ➤148). For now it is sufﬁcient
16 Chapter 1. An Overview in Five Examples
to know that a slice’s length can be determined using the built-in len()function
and its elements can be accessed using the []index operator using a subset of
the Python syntax. In particular, slice[n] returns the slice’s nth element (count-
ing from zero), and slice[n:] returns another slice which has the elements from
thenth element to the last element. In the collections chapter we will see the
full generality of Go’s syntax in this area. In the case of os.Args, the slice should
always have at least one string (the program’s name), at index position 0. (All Go
indexing is 0-based.)
If the user has entered one or more command line arguments the ifcondition
is satisﬁed and we set the whostring to contain all the arguments joined up as a
single string (14 ➤,➍). In this case we use the assignment operator ( =), since if
we used the short variable declaration operator ( :=)w ew o u l de n du pd e c l a r i n g
and initializing a new whovariable whose scope was limited to the ifstatement’s
block. The strings.Join() function takes a slice of strings and a separator
(which could be empty, i.e., ""), and returns a single string consisting of all the
slice’s strings with the separator between each one. Here we have joined them
using a single space between each.
Finally, in the last statement (14 ➤,➎), we print Hello, a space, the string held
in the whovariable, and a newline. The fmtpackage has many different print
variants, some like fmt.Println() which will neatly print whatever they are
given, and others like fmt.Printf() that use placeholders to provide very ﬁne
control over formatting. The print functions are covered in Chapter 3 (§3.5,
➤93).
The helloprogram presented here has shown far more of the language’sfeatures
than such programs conventionally do. The subsequent examples continue in
this vein, covering more advanced features while keeping the examples as short
as possible. The idea here is to simply acquire some basic familiarity with the
language and to get to grips with building, running, and experimenting with
simple Go programs,while at the same time getting a ﬂavor of Go’s powerful and
novel features. And, of course,everything presented in this chapter is explained
in detail in the subsequent chapters.
1.4. Big Digits—Two-Dimensional Slices
The bigdigits program (in ﬁle bigdigits/bigdigits.go ) reads a number entered
on the command line (as a string), and outputs the same number onto the
console using “big” digits. Back in the twentieth century, at sites where lots of
users shared a high-speed line printer, it used to be common practice for each
user’s print job to be preceded by a cover page that showed some identifying
details such as their username and the name of the ﬁle being printed, using this
kind of technique.
1.4. Big Digits—Two-Dimensional Slices 17
We will review the code in three parts:ﬁrst the imports, then the static data, and
then the processing. But right now, let’s look at a sample run to get a feel for
how it works:
$./bigdigits 290175493
222    9999    000     1   77777  55555     4     9999   333
2   2  9   9   0   0   11       7  5        44    9   9  3   3
   2   9   9  0     0   1      7   5       4 4    9   9      3
  2     9999  0     0   1     7     555   4  4     9999    33
2         9  0     0   1    7         5  444444      9      3
2          9   0   0    1   7      5   5     4        9  3   3
22222      9    000    111  7       555      4        9 333
Each digit is represented by a slice of strings, with all the digits together repre-
sented by a slice of slices of strings. Before looking at the data, here is how we
could declare and initialize single-dimensional slices of strings and numbers:
longWeekend := []string{ "Friday" ,"Saturday" ,"Sunday" ,"Monday" }
var lowPrimes = []int{ 2,3,5,7,11,13,17,19}
Slices have the form []Type, and if we want to initialize them we can immedi-
ately follow with a brace-delimited comma-separated list of elements of the cor-
responding type. We could have used the same variable declaration syntax for
both, but have used a longer form for the lowPrimes slice to show the syntactic
difference and for a reason that will be explained in a moment. Since a slice’s
Type can itself be a slice type we can easily create multidimensional collections
(slices of slices, etc.).
The bigdigits program needs to import only four packages.
import (
"fmt"
"log"
"os"
"path/filepath"
)
The fmtpackage provides functions for formatting text and for reading format-
ted text (§3.5, ➤93). The logpackage provides logging functions. The ospack-
age provides platform-independent operating-system variables and functions
including the os.Argsvariable of type []string (slice of strings) that holds the
command-line arguments. And the pathpackage’s filepath package provides
functions for manipulating ﬁlenames and paths that work across platforms.
Note that for packages that are logically inside other packages, we only specify
the last component of their name (in this case filepath) when accessing them in
our code.
18 Chapter 1. An Overview in Five Examples
For the bigdigits program we need two-dimensional data (a slice of slices of
strings). Here is how we have created it, with the strings for digit 0 laid out to
illustrate how a digit’s strings correspond to rows in the output, and with the
strings for digits 3 to 8 elided.
var bigDigits = [][]string{
    {"  000  " ,
" 0   0 " ,
"0     0" ,
"0     0" ,
"0     0" ,
" 0   0 " ,
"  000  " },
    {"1","11 ","1","1","1","1","111"},
    {" 222 ","2   2","   2 ","  2  "," 2   ","2    ","22222"},
// ... 3 to 8 ...
    {" 9999","9   9","9   9"," 9999","    9","    9","    9"},
}
Variables declared outside of any function or method may not use the :=oper-
ator, but we can get the same effect using the long declaration form (with key-
word var) and the assignment operator ( =) as we have done here for the bigDigits
variable (and did earlier for the lowPrimes variable).We still don’t need to specify
bigDigits ’ type since Go can deduce that from the assignment.
We leave the bean counting to the Go compiler, so there is no need to specify the
dimensions of the slice of slices. One of Go’s many conveniences is its excellent
support for composite literals using braces, so we don’t have to declare a data
variable in one place and populate it with data in another—unless we want to,
of course.
The main()function that reads the command line and uses the data to produce
the output is only 20 lines.
func main() {
if len (os.Args) == 1{➊
        fmt.Printf( "usage: %s <whole-number>\n" , filepath.Base(os.Args[ 0]))
        os.Exit( 1)
    }
    stringOfDigits := os.Args[ 1]
for row :=range bigDigits[ 0]{➋
        line := ""
for column := range stringOfDigits { ➌
            digit := stringOfDigits[column] - '0'➍
if0<= digit && digit <= 9{➎
1.4. Big Digits—Two-Dimensional Slices 19
                line += bigDigits[digit][row] + "  "➏
            } else {
                log.Fatal( "invalid whole number" )
            }
        }
        fmt.Println(line)
    }
}
The program begins by checking to see if it was invoked with any command-line
arguments. If it wasn’t, len(os.Args) will be 1(recall that os.Args[0] holds the
program’s name, so the slice’s length is normally at least 1), and the ﬁrst if
statement (18 ➤,➊) will be satisﬁed. In this case we output a suitable usage
message using the fmt.Printf() function that accepts %placeholders similar to
those supported by the C/C ++printf() function or by Python’s %operator. (See
§3.5, ➤93 for full details.)
The path/filepath package provides path manipulation functions—for example,
thefilepath.Base() function returns the basename (i.e., the ﬁlename) of the
given path. After outputting the message the program terminates using the
os.Exit() function and returns 1to the operating system. On Unix-like systems
a return value of 0is used to indicate success, with nonzero values indicating a
usage error or a failure.
The use of the filepath.Base() function illustrates a nice feature of Go: When a
package is imported, no matter whether it is top-level or logically inside another
package (e.g., path/filepath ), we always refer to it using only the last component
of its name (e.g., filepath). It is also possible to give packages local names to
avoid name collisions; Chapter 9 provides the details.
If at least one command-line argument was given, we copy the ﬁrst one into
thestringOfDigits variable (of type string). To convert the number that the
user entered into big digits we must iterate over each row in the bigDigits slice
to produce each line of output, that is, the ﬁrst (top) string for each digit, then
the second, and so on. We assume that all the bigDigits ’ slices have the same
number of rows and so take the row count from the ﬁrst one. Go’s forloop has
various syntaxes for different purposes; here (18 ➤,➋and 18 ➤,➌) we have used
for…rangeloops that return the index positions of each item in the slices they
are given.
The row and column loops part of the code could have been written like this:
for row := 0; row < len(bigDigits[0]); row++ {
    line := ""
for column := 0; column < len(stringOfDigits); column++ {
        ...
20 Chapter 1. An Overview in Five Examples
This is a form familiar to C, C ++, and Java programmers and is perfectly valid
in Go.★However, the for…rangesyntax is shorter and more convenient. (Go’s
forloops are covered in §5.3, ➤203.)
At each row iteration we set that row’s lineto be an empty string. Then we
iterate over the columns (i.e., the characters) in the stringOfDigits string we
received from the user. Go strings hold UTF-8 bytes, so potentially a character
might be represented by two or more bytes. This isn’t an issue here because we
are only concerned with the digits 0,1, …, 9each of which is represented by a
single byte in UTF-8 and with the same byte value as in 7-bit ASCII. (We will
see how to iterate over a string character by character—regardless of whether
the characters are single- or multibyte—in Chapter 3.)
When we index a particular position in a string we get the bytevalue at that
position. (In Go the bytetype is a synonym for the uint8type.) So we retrieve the
byte value of the command-line string at the given column and subtract the byte
value of digit 0 from it to get the number it represents (18 ➤,➍). In UTF-8 (and
7-bit ASCII) the character '0'is code point (character) 48 decimal, the character
'1'is code point 49, and so on. So if, for example, we have the character '3'(code
point 51), we can get its integer value by doing the subtraction '3' - '0' (i.e., 51
−48) which results in an integer (of type byte) of value 3.
Go uses single quotes for character literals, and a character literal is an integer
that’s compatible with any of Go’s integer types. Go’s strong typing means
we cannot add, say, an int32to an int16without explicit conversion, but Go’s
numeric constants and literals adapt to their context, so in this context '0'is
considered to be a byte.
If the digit(of type byte) is in range (18 ➤,➎) we can add the appropriate string
to the line. (In the ifstatement the constants 0and 9are considered to be bytes
because that’s digit’s type, but if digitwas of a different type, say, int, they
would be treated as that type instead.) Although Go strings are immutable (i.e.,
they cannot be changed), the +=append operator is supported to provide a nice
easy-to-use syntax. (It works by replacing the original string under the hood.)
There is also support for the +concatenate operator which returns a new string
that is the concatenation of its left and right string operands. (The stringtype
is covered fully in Chapter 3.)
To retrieve the appropriate string (19 ➤,➏) we access the bigDigits ’s slice that
corresponds to the digit, and then within that to the row (string) we need.
If the digitis out of range (e.g., due to the stringOfDigits containing a nondigit),
we call the log.Fatal() function with an error message. This function logs the
★Unlike C, C ++, and Java, in Go the ++and --operators may only be used as statements, not
expressions. Furthermore, they may only be used as postﬁx operators, not preﬁx operators. This
means that certain order of evaluation problems cannot occur in Go—so thankfully,expressions like
f(i++) anda[i] = b[++i] cannot be written in Go.
1.4. Big Digits—Two-Dimensional Slices 21
date, time, and error message—to os.Stderr if no other log destination is explic-
itly speciﬁed—and calls os.Exit(1) to terminate the program. There is also a
log.Fatalf() function that does the same thing and which accepts %placehold-
ers. We didn’t use log.Fatal() in the ﬁrst ifstatement (18 ➤,➊) because we
want to print the program’s usage message without the date and time that the
log.Fatal() function normally outputs.
Once all the number’s strings for the given row have been accumulated the
complete line is printed. In this example, seven lines are printed because each
digit in the bigDigits slice of strings is represented by seven strings.
One ﬁnal point is that the order of declarations and deﬁnitions doesn’t generally
matter. So in the bigdigits/bigdigits.go ﬁle we could declare the bigDigits
variable before or after the main()function. In this case we have put main()ﬁrst
since for the book’s examples we usually prefer to order things top-down.
The ﬁrst two examples have covered a fair amount of ground, but both of them
show material that is familiar from other mainstream languages even though
the syntax is slightly different. The following three examples take us beyond
the comfort zone to illustrate Go-speciﬁc features such as custom Go types, Go
ﬁle handling (including error handling) and functions as values, and concurrent
programming using goroutines and communication channels.
1.5. Stack—Custom Types with Methods
Although Go supports object-oriented programming it provides neither class-
es nor inheritance ( is-arelationships). Go does support the creation of custom
types, and Go makes aggregation ( has-a relationships) extremely easy. Go also
allows for the complete separation of a type’s data from its behavior, and sup-
ports duck typing .D u c kt y p i n gi sap o w e r f u la b s t r a c t i o nm e c h a n i s mt h a tm e a n s
that values can be handled (e.g., passed to functions),based on the methods they
provide, regardless of their actual types. The terminology is derived from the
phrase, “If it walks like a duck, and quacks like a duck, it isad u c k ” .A l lo ft h i s
produces a more ﬂexible and powerful alternative to the classes and inheritance
approach—but does require those of us used to the more traditional approach to
make some signiﬁcant conceptual adjustments to really beneﬁt from Go’s object
orientation.
Go representsdata using the fundamental built-in types such as keyword!!struct
bool,int, and string, or by aggregations of types using structs.★Go’s custom
types are based on the fundamental types, or on structs, or on other custom
types. (We will see some simple examples later in this chapter; §1.7, ➤40.)
★Unlike C ++, Go’s structs are notclasses in disguise. For example, Go’s structs support aggregation
and delegation, but not inheritance.
22 Chapter 1. An Overview in Five Examples
Go supports both named and unnamed custom types. Unnamed types with
the same structure can be used interchangeably; however, they cannot have
any methods. (We will discuss this more fully in §6.4, ➤275.) Any named cus-
tom type can have methods and these methods together constitute the type’s
interface. Named custom types—even with the same structure—are not inter-
changeable. (Throughout the book any reference to a “custom type” means a
named custom type, unless stated otherwise.)
An interface is a type that can be formally deﬁned by specifying a particular
set of methods. Interfaces are abstract and cannot be instantiated. A concrete
(i.e., noninterface) type that has the methods speciﬁed by an interface fulﬁlls
the interface, that is, values of such a concrete type can be used as values of the
interface’s type as well as of their own actual type. Yet no formal connection
need be established between an interface and a concrete type that provides the
methods speciﬁed by the interface. It is sufﬁcient for a custom type to have the
interface’s methods for it to satisfy that interface. And, of course, a type can
satisfy more than one interface simply by providing all the methods for all the
interfaces we want it to satisfy.
The empty interface (i.e., the interface that has no methods) is speciﬁed as
interface{} .★Since the empty interface makes no demands at all (because it
doesn’t require any methods), it can stand for any value (in effect like a pointer
to any value), whether the value is of a built-in type or is of a custom type. (Go’s
pointers and references are explained later; §4.1, ➤140.) Incidentally, in Go
terminology we talk about types and values rather than classes and objects or
instances (since Go has no classes).
Function and method parameters can be of any built-in or custom type—or of
any interface type. In the latter case this means that a function can have a
parameter that says, for example, “pass a value that can read data”, regardless
of what that value’s type actually is. (We will see this in practice shortly; §1.6,
➤29.)
Chapter 6 covers all of these matters in detail and presents many examples to
ensure that the ideas are understood. For now, let’s just look at a very simple
custom type—a stack—starting with how values are created and used, and then
looking at the implementation of the custom type itself.
We will start with the output produced by a simple test program:
$./stacker
81.52
[pin clip needle]
-15
hay
★Go’s empty interface can serve the same role as a reference to a Java Object or as C/C ++’svoid*.
1.5. Stack—Custom Types with Methods 23
Each item was popped from the custom stack and printed on its own line.
The simple test program that produced this output is stacker/stacker.go . Here
are the imports it uses:
import (
"fmt"
"stacker/stack"
)
The fmtpackage is part of Go’s standard library, but the stackpackage is a local
package speciﬁc to the stackerapplication. A Go program or package’s imports
are ﬁrst searched for under the GOPATHpath or paths, and then under GOROOT.
In this particular case the program’s source code is in $HOME/goeg/src/stacker/
stacker.go and the stackpackage is in $HOME/goeg/src/stacker/stack/stack.go .
The gotool will build both of them so long as the GOPATHis (or includes) the path
$HOME/goeg/ .
Import paths are speciﬁed using Unix-style “/”s, even on Windows. Every local
package should be stored in a directory with the same name as the package.
Local packages can have their own packages (e.g., like path/filepath ), in exactly
the same way as the standard library. (Creating and using custom packages is
covered in Chapter 9.)
Here’s the simple test program’s main()function that produced the output:
func main() {
var haystack stack.Stack
    haystack.Push( "hay")
    haystack.Push( -15)
    haystack.Push([]string{ "pin","clip","needle" })
    haystack.Push( 81.52)
for {
        item, err := haystack.Pop()
iferr !=nil {
break
        }
        fmt.Println(item)
    }
}
The function begins by declaring the haystack variable of type stack.Stack . It is
conventional in Go to always refer to types, functions, variables, and other items
in packages using the syntax pkg.item, where pkgis the last (or only) component
of the package’s name. This helps prevent name collisions. We then push some
items onto the stack and then pop them off and print each one until there are
no more left.
24 Chapter 1. An Overview in Five Examples
One amazingly convenient aspect of our custom stack is that despite Go’s strong
typing, we are not limited to storing homogeneous items (items all of the same
type), but can freely mix heterogeneous items (items of various types). This
is because the stack.Stack type simply stores interface{} items (i.e., values
ofanytype) and doesn’t care what their types actually are. Of course, when
those items are used, then their type does matter. Here, though, we only use the
fmt.Println() function and this uses Go’s introspection facilities (from the re-
flectpackage) to discover the types of the items it is asked to print. (Reﬂection
is covered in a later chapter; §9.4.9, ➤427.)
Another nice Go feature illustrated by the code is the forloop with no conditions.
This is an inﬁnite loop, so in most situations we will need to provide a means
of breaking out of the loop—for example, using a breakstatement as here, or
areturnstatement. We will see an additional forsyntax in the next example
(§1.6, ➤29); the complete range of forsyntaxes is covered in Chapter 5.
Go functions and methods can return a single value or multiple values. It is
conventional in Go to report errors by returning an error value (of type error)
as the last (or only) value returned by a function or method. The custom stack.
Stacktype respects this convention.
Now that we have seen the custom stack.Stack type in use we are ready to
review its implementation (in ﬁle stacker/stack/stack.go ).
package stack
import "errors"
type Stack [] interface {}
The ﬁle starts conventionally by specifying its package name. Then it imports
other packages that it needs—in this case just one, errors.
When we deﬁne a named custom type in Go what we are doing is binding an
identiﬁer (the type’s name) to a new type that has the same underlying rep-
resentation as an existing (built-in or custom) type—and which is treated by
Go as different from the underlying representation. Here, the Stacktype is a
new name for a slice (i.e., a reference to a variable-length array) of interface{}
values—and is considered to be different from a plain []interface{} .
Because all Go types satisfy the empty interface, values of any type can be
stored in a Stack.
The built-in collection types (maps and slices), communication channels (which
can be buffered), and strings, can all return their length (or buffer size) using
the built-in len()function. Similarly, slices and channels can also report their
capacity (which may be greater than the length being used) using the built-in
cap()function. (All of Go’s built-in functions are listed in Table 5.1, ➤187, with
cross-references to where they are covered; slices are covered in Chapter 4; §4.2,
1.5. Stack—Custom Types with Methods 25
➤148.) It is conventional for custom collection types—our own, and those in the
Go standard library—to support corresponding Len()and Cap()methods when
these make sense.
Since the Stacktype uses a slice for its underlying representation it makes sense
to provide Stack.Len() and Stack.Cap() methods for it.
func (stack Stack) Len() int {
return len (stack)
}
Both functions and methods are deﬁned using the funckeyword.However, in the
case of methods the type of value to which the method applies is written after
thefunckeyword and before the method’s name, enclosed in parentheses. After
the function or method’s name comes a—possibly empty—parenthesized list of
comma-separated parameters (each written in the form variableName type ).After
the parameters comes the function or method’s opening brace (if it has no return
value), or a single return value (e.g., as a type name such as the intreturned by
theStack.Len() method shown here), or a parenthesized list of return values,
followed by an opening brace.
In most cases a variable name for the value on which the method is called is also
given—as here where we have used the name stack(and with no conﬂict with
the package’s name). The value on which the method is called is known in Go
terminology as the receiver .★
In this example the type of the receiver is Stack, so the receiver is passed by
value. This means that any changes made to the receiver would be made on a
copy of the original value and in effect lost. This is no problem for methods that
don’t modify the receiver, such as the Stack.Len() method shown here.
The Stack.Cap() method is almost identical to the Stack.Len() method (and so
is not shown). The only difference is that the Stack.Cap() method returns the
cap()rather than the len()of the receiver stack.T h es o u r c ec o d ea l s oi n c l u d e s
aStack.IsEmpty() method, but this is so similar to Stack.Len() —it just returns a
boolindicating whether the stack’s len()equals 0—that again it isn’t shown.
func (stack*Stack) Push(x interface {}) {
*stack = append (*stack, x)
}
The Stack.Push() method is called on a pointer to a Stack(explained in a mo-
ment), and is passed a value ( x) of any type. The built-in append() function takes
as l i c ea n do n eo rm o r ev a l u e sa n dr e t u r n sa( p o s s i b l yn e w )s l i c ew h i c hh a st h e
★In other languages the receiver is typically called thisorself; using such names works ﬁne in Go,
but is not considered to be good Go style.
26 Chapter 1. An Overview in Five Examples
original slice’s contents, plus the given value or values as its last element or ele-
ments. (See §4.2.3, ➤156.)
If the stack has previously had items popped from it ( ➤28), the underlying
slice’s capacity is likely to be greater than its length, so the push could be very
cheap: simply a matter of putting the xitem into the len(stack) position and
increasing the stack’s length by one.
The Stack.Push() method always works (unless the computer runs out of memo-
ry), so we don’t need to return an errorvalue to indicate success or failure.
If we want to modify a value we must make its receiver a pointer.★Apointer
is a variable that holds the memory address of another value. One reason that
pointers are used is for efﬁciency—for example,if we have a value of a large type
it is much cheaper to pass a pointer to the value as a parameter than to pass the
value itself. Another use is to make a value modiﬁable. For example, when a
variable is passed into a function the function gets a copy of the value (e.g., the
stackpassed into the stack.Len() function; 25 ➤). This means that if we make
any changes to the variable inside the function, they will have no effect on the
original value. If we need to modify the original value—as here where we want
to append to the stack—we must pass a pointer to the original value, and then
inside the function we can modify the value that the pointer points to.
Ap o i n t e ri sd e c l a r e db yp r e c e d i n gt h et y p en a m ew i t has t a r( i . e . ,a na s t e r i s k , *).
So here, in the Stack.Push() method, the stackvariable is of type *Stack, that is,
thestackvariable holds a pointer to a Stackvalue and not an actual Stackvalue.
We can access the actual Stackvalue that the pointer points to by dereferencing
the pointer—this simply means that we access the value the pointer points to.
Dereferencing is done by preceding the variable name with a star. So here,when
we write stackwe are referring to a pointer to a Stack(i.e., to a *Stack), and when
we write *stackwe are dereferencing the pointer, that is, referring to the actual
Stackthat the pointer points to.
So, in Go (and C and C ++for that matter), the star is overloaded to mean multi-
plication (when between a pair of numbers or variables, e.g., x*y), pointer dec-
laration (when preceding a type name, e.g., z*MyType ), and pointer dereference
(when preceding a pointer variable’s name, e.g., *z). Don’t worry too much about
these matters for now: Go’s pointers are fully explained in Chapter 4.
Note that Go’s channels, maps, and slices are all created using the make()func-
tion, and make()always returns a reference to the value it created. References
behave very much like pointers in that when they are passed to functions any
changes made to them inside the function affect the original channel, map, or
slice. However, references don’t need to be dereferenced, so in most cases there’s
no need to use stars with them. But if we want to modify a slice inside a func-
★Go pointers are essentially the same as in C and C ++except that pointer arithmetic isn’t supported
—or necessary; see §4.1, ➤140.
1.5. Stack—Custom Types with Methods 27
tion or method using append() (as opposed to simply changing one of its existing
items), then we must either pass the slice by pointer, or return the slice (and set
the original slice to the function or method’s return value), since append() some-
times returns a different slice reference than the one it was passed.
The Stacktype uses a slice for its representation and therefore Stackvalues
can be used with functions that operate on a slice, such as append() and len().
Nonetheless, Stackvalues are values in their own right, distinct from their
representation, so they must be passed by pointer if we want to modify them.
func (stack Stack) Top() ( interface {},error ){
if len (stack) == 0{
return nil , errors.New( "can't Top() an empty stack" )
    }
return stack[len(stack)-1],nil
}
The Stack.Top() method returns the item at the top of the stack (the item that
was added last) and a nilerror value; or a nilitem and a non- nilerror value,
if the stack is empty. The stackreceiver is passed by value since the stack
isn’t modiﬁed.
The errortype is an interface type (§6.3, ➤265) which speciﬁes a single method,
Error() string . In general, Go’s library functions return an erroras their last (or
only) return value to indicate success (where errorisnil) or failure. Here, we
have made our Stacktype work like a standard library type by creating a new
errorvalue using the errorspackage’s errors.New() function.
Go uses nilfor zero pointers (and for zero references); that is, for pointers that
point to nothing and for references that refer to nothing.★Such pointers should
be used only in conditions or assignments; methods should not normally be
called on them.
Constructorsare never called implicitly in Go. Instead Go guaranteesthat when
a value is created it is always initialized to its zero value. For example, numbers
are initialized to 0, strings to the empty string, pointers to nil, and the ﬁelds
inside structs are similarly initialized. So there is no uninitialized data in Go,
thus eliminating a major source of errors that afﬂicts many other program-
ming languages. If the zero value isn’t suitable we can write a construction
function—and call it explicitly—as we do here to create a new error. It is also
possible to prevent values of a type being created without using a constructor
function, as we will see in Chapter 6.
★Go’s nilis in effect the same as NULL or0in C and C ++,nullin Java, and nilin Objective-C.
28 Chapter 1. An Overview in Five Examples
If the stack is nonempty we return its topmost value and a nilerror value. Since
Go uses 0-based indexing the ﬁrst element in a slice or array is at position 0 and
the last element is at position len(sliceOrArray )-1.
There is no formality when returning more than one value from a function or
method; we simply list the types we are returning after the function or method’s
name and ensure that we have at least one returnstatement that has a corre-
sponding list of values.
func (stack*Stack) Pop() ( interface {},error ){
    theStack := *stack
if len (theStack) == 0{
return nil , errors.New( "can't Pop() an empty stack" )
    }
    x := theStack[ len(theStack) -1]➊
*stack = theStack[: len(theStack) -1]➋
return x,nil
}
The Stack.Pop() method is used to remove and return the top (last added) item
from the stack. Like the Stack.Top() method it returns the item and a nilerror,
or if the stack is empty, a nilitem and a non- nilerror.
The method must have a receiver that is a pointer since it modiﬁes the stack by
removing the returned item. For syntactic convenience, rather than referring
to*stack(the actual stack that the stackvariable points to) throughout the
method, we assign the actual stack to a local variable ( theStack), and work with
that variable instead. This is quite cheap, because *stackis pointing to a Stack,
which uses a slice for its representation, so we are really assigning little more
than a reference to a slice.
If the stack is empty we return a suitable error. Otherwise we retrieve the
stack’s top (last) item and store it in a local variable ( x). Then we take a slice of
the stack (which itself is a slice). The new slice has one less element than the
original and is immediately set to be the value that the stackpointer points to.
And at the end,we return the retrieved value and a nilerror. We can reasonably
expect any decent Go compiler to reuse the slice, simply reducing the slice’s
length by one, while leaving its capacity unchanged, rather than copying all the
data to a new slice.
The item to return is retrieved using the []index operator with a single index
(➊); in this case the index of the slice’s last element.
The new slice is obtained by using the []slice operator with an index range
(➋). An index range has the form first :end. Iffirst is omitted—as here—0 is
assumed, and if endis omitted, the len()of the slice is assumed. The slice thus
obtained has elements with indexes from and including the first up to and
1.5. Stack—Custom Types with Methods 29
excluding theend. So in this case, by specifying the last index as one less than
the length, we slice up to the last but one element, effectively removing the last
element from the slice. (Slice indexing is covered in Chapter 4, §4.2.1, ➤153.)
In this example we used Stackreceivers rather than pointers (i.e., of type *Stack)
for those methods that don’t modify the Stack.For custom types with lightweight
representations (say, a few ints orstrings), this is perfectly reasonable. But for
heavyweight custom types it is usually best to always use pointer receivers since
ap o i n t e ri sm u c hc h e a p e rt op a s s( t y p i c a l l yas i m p l e3 2 -o r6 4 - b i tv a l u e ) ,t h a n
a large value, even for methods where the value isn’t modiﬁed.
A subtle point to note regarding pointers and methods is that if we call a method
on a value, and the method requires a pointer to the value it is called on, Go
is smart enough to pass the value’s address rather than a copy of the value
(providing the value is addressable; §6.2.1, ➤258). Correspondingly, if we call
a method on a pointer to a value, and the method requires a value, Go is smart
enough to dereference the pointer and give the method the pointed-to value.★
As this example illustrates, creating custom types in Go is generally straight-
forward, and doesn’t involve the cumbersome formalities that many other lan-
guages demand. Go’s object-oriented features are covered fully in Chapter 6.
1.6. Americanise—Files, Maps, and Closures
To have any practical use a programming language must provide some means
of reading and writing external data. In previous sections we had a glimpse of
Go’s versatile and powerful print functions from its fmtpackage; in this section
we will look at Go’s basic ﬁle handling facilities. We will also look at some more
advanced features such as Go’s treatment of functions and methods as ﬁrst-class
values which makes it possible to pass them as parameters. And in addition we
will make use of Go’s maptype (also known as a data dictionary or hash).
This section provides enough of the basics so that programs that read and write
text ﬁles can be written—thus making the examples and exercises more inter-
esting. Chapter 8 provides much more coverage of Go’s ﬁle handling facilities.
By about the middle of the twentieth century, American English surpassed
British English as the most widely used form of English. In this section’s
example we will review a program that reads a text ﬁle and writes out a copy of
the ﬁle into a new ﬁle with any words using British spellings replaced with their
U.S. counterparts. (This doesn’t help with differences in semantics or idioms,
of course.) The program is in the ﬁle americanise/americanise.go , and we will
review it top-down, starting with its imports, then its main()function, then the
functions that main()calls, and so on.
★This is why Go does not have or need the ->indirection operator used by C and C ++.
30 Chapter 1. An Overview in Five Examples
import (
"bufio"
"fmt"
"io"
"io/ioutil"
"log"
"os"
"path/filepath"
"regexp"
"strings"
)
All the americanise program’s imports are from Go’s standard library. Packages
can be nested inside one another without formality, as the iopackage’s ioutil
package and the pathpackage’s filepath package illustrate.
The bufiopackage provides functions for buffered I/O, including ones for read-
ing and writing strings from and to UTF-8 encoded text ﬁles. The iopackage
provides low-level I/O functions—and the io.Reader and io.Writer interfaces we
need for the americanise() program. The io/ioutil package provides high-level
ﬁle handling functions. The regexppackage provides powerful regular expres-
sion support. The other packages( fmt,log,filepath,and strings) have been men-
tioned in earlier sections.
func main() {
    inFilename, outFilename, err := filenamesFromCommandLine() ➊
iferr !=nil {
        fmt.Println(err) ➋
        os.Exit( 1)
    }
    inFile, outFile := os.Stdin, os.Stdout ➌
ifinFilename != ""{
ifinFile, err = os.Open(inFilename); err != nil {
            log.Fatal(err)
        }
defer inFile.Close() ➍
    }
ifoutFilename != ""{
ifoutFile, err = os.Create(outFilename); err != nil {
            log.Fatal(err)
        }
defer outFile.Close() ➎
    }
iferr = americanise(inFile, outFile); err != nil {
        log.Fatal(err)
1.6. Americanise—Files,Maps,and Closures 31
    }
}
The main()function gets the input and output ﬁlenames from the command line,
creates corresponding ﬁle values, and then passes the ﬁles to the americanise()
function to do the work.
The function begins by retrieving the names of the ﬁles to read and write and an
errorvalue. If there was a problem parsing the command line we print the error
(which contains the program’s usage message), and terminate the program.
Some of Go’s print functions use reﬂection (introspection) to print a value using
the value’s Error()string method if it has one, or its String()string method if it
has one, or as best they can otherwise. If we provide our own custom types with
one of these methods, Go’s print functions will automatically be able to print
values of our custom types, as we will see in Chapter 6.
Iferrisnil, we have inFilename and outFilename strings (which may be empty),
and we can continue. Files in Go are represented by pointers to values of
type os.File,a n ds ow ec r e a t et w os u c hv a r i a b l e si n i t i a l i z e dt ot h es t a n d a r d
input and output streams (which are both of type *os.File). Since Go functions
and methods can return multiple values it follows that Go supports multiple
assignments such as the ones we have used here (30 ➤,➊,➌).
Each ﬁlename is handled in essentially the same way. If the ﬁlename is empty
the ﬁle has already been correctly set to os.Stdin oros.Stdout (both of which are
of type *os.File, i.e., a pointer to an os.Filevalue representing the ﬁle); but if
the ﬁlename is nonempty we create a new *os.Fileto read from or write to the
ﬁle as appropriate.
The os.Open() function takes a ﬁlename and returns an *os.Filevalue that can
be used for reading the ﬁle. Correspondingly, the os.Create() function takes a
ﬁlename and returns an *os.Filevalue that can be used for reading or writing
the ﬁle, creating the ﬁle if it doesn’t exist and truncating it to zero length if
it does exist. (Go also provides the os.OpenFile() function that can be used to
exercise complete control over the mode and permissions used to open a ﬁle.)
In fact, the os.Open() ,os.Create() , and os.OpenFile() functions return two
values: an *os.Fileand nilif the ﬁle was opened successfully, or niland an
errorif an error occurred.
Iferrisnilwe know that the ﬁle was successfully opened so we immediately
execute a deferstatement to close the ﬁle. Any function that is the subject of a
deferstatement (§5.5, ➤212) must be called—hence the parentheses after the
functions’ names (30 ➤,➍,➎)—but the calls only actually occur when the func-
tion in which the deferstatements are written returns. So the deferstatement
“captures” the function call and sets it aside for later. This means that the de-
ferstatement itself takes almost no time at all and control immediately passes
to the following statement. Thus, the deferred os.File.Close() method won’t
32 Chapter 1. An Overview in Five Examples
actually be called until the enclosing function—in this case, main()—returns
(whether normally or due to a panic, discussed in a moment), so the ﬁle is open
to be worked on and yet guaranteed to be closed when we are ﬁnished with it, or
if a panic occurs.
If we fail to open the ﬁle we call log.Fatal() with the error. As we noted in a
previous section, this function logs the date, time, and error (to os.Stderr un-
less another log destination is speciﬁed), and calls os.Exit() to terminate the
program. When os.Exit() is called (directly, or by log.Fatal() ), the program is
terminated immediately—and any pending deferred statements are lost. This
is not a problem, though, since Go’s runtime system will close any open ﬁles, the
garbage collector will release the program’s memory, and any decent database
or network that the application might have been talking to will detect the ap-
plication’s demise and respond gracefully. Just the same as with the bigdigits
example, we don’t use log.Fatal() in the ﬁrst ifstatement (30 ➤,➋), because the
errcontains the program’s usage message and we want to print this without the
date and time that the log.Fatal() function normally outputs.
In Go a panic is a runtime error (rather like an exception in other languages).
We can cause panics ourselves using the built-in panic()function, and can stop
ap a n i ci ni t st r a c k su s i n gt h e recover() function (§5.5, ➤212). In theory, Go’s
panic/recover functionality can be used to provide a general-purpose exception
handling mechanism—but doing so is considered to be poor Go practice. The
Go way to handle errors is for functions and methods to return an errorvalue
as their sole or last return value—or nilif no error occurred—and for callers to
always check the error they receive. The purpose of panic/recover is to deal with
genuinely exceptional (i.e., unexpected) problems and notwith normal errors.★
With both ﬁles successfully opened (the os.Stdin,os.Stdout , and os.Stderr ﬁles
are automatically opened by the Go runtime sytem), we call the americanise()
function to do the processing, passing it the ﬁles on which to work. If ameri-
canise() returns nilthemain()function terminates normally and any deferred
statements—in this case, ones that close the inFileand outFileif they are not
os.Stdin and os.Stdout —are executed. And if erris not nil, the error is printed,
the program is exited, and Go’s runtime system closes any open ﬁles.
The americanise() function accepts an io.Reader and an io.Writer , not *os.Files,
but this doesn’t matter since the os.Filetype supports the io.ReadWriter inter-
face (which simply aggregates the io.Reader and io.Writer interfaces) and can
therefore be used wherever an io.Reader or an io.Writer is required. This is
an example of duck typing in action—the americanise() function’s parameters
are interfaces, so the function will accept any values—no matter what their
types—that satisfy the interfaces, that is, any values that have the methods the
★Go’s approach is very different from C ++, Java, and Python, where exception handling is often used
for both errors and exceptions. The discussion and rationale for Go’s panic/recover mechanism is at
https://groups.google.com/group/golang-nuts/browse_thread/thread/1ce5cd050bb973e4?pli=1 .
1.6. Americanise—Files,Maps,and Closures 33
interfaces specify. The americanise() function returns nil, or an errorif an error
occurred.
func filenamesFromCommandLine() (inFilename, outFilename string,
    err error ){
if len (os.Args) > 1&& (os.Args[ 1]= ="-h"|| os.Args[ 1]= ="--help" ){
        err = fmt.Errorf( "usage: %s [<]infile.txt [>]outfile.txt" ,
            filepath.Base(os.Args[ 0]))
return "","", err
    }
if len (os.Args) > 1{
        inFilename = os.Args[ 1]
if len (os.Args) > 2{
            outFilename = os.Args[ 2]
        }
    }
ifinFilename != ""&& inFilename == outFilename {
        log.Fatal( "won't overwrite the infile" )
    }
return inFilename, outFilename, nil
}
The filenamesFromCommandLine() function returns two strings and an error
value—and unlike the functions we have seen so far, here the return values are
given variable names, not just types. Return variables are set to their zero val-
ues (empty strings and nilforerrin this case) when the function is entered, and
keep their zero values unless explicitly assigned to in the body of the function.
(We will say a bit more on this topic when we discuss the americanise() func-
tion, next.)
The function begins by seeing if the user has asked for usage help.★If they have,
we create a new errorvalue using the fmt.Errorf() function with a suitable
usage string, and return immediately. As usual with Go code, the caller is
expected to check the returned errorand behave accordingly (and this is exactly
what main()does). The fmt.Errorf() function is like the fmt.Printf() function we
saw earlier, except that it returns an errorvalue containing a string using the
given format string and arguments rather than writing a string to os.Stdout .
(The errors.New() function is used to create an errorgiven a literal string.)
If the user did not request usage information we check to see if they entered any
command-line arguments, and if they did we set the inFilename return variable
to their ﬁrst command-line argument and the outFilename return variable
★The Go standard library includes a flagpackage for handling command-line arguments.
Third-party packages for GNU-compatible command-line handling are available from godashboard.
appspot.com/project . (Using third-party packages is covered in Chapter 9.)
34 Chapter 1. An Overview in Five Examples
to their second command-line argument. Of course, they may have given no
command-line arguments,in which case both inFilename and outFilename remain
empty strings; or they may have entered just one, in which case inFilename will
have a ﬁlename and outFilename will be empty.
At the end we do a simple sanity check to make sure that the user doesn’t over-
write the input ﬁle with the output ﬁle, exiting if necessary—but if all is well,
we return.★Functions or methods that return one or more values must have at
least one returnstatement. It can be useful for clarity, and for godoc-generated
documentation, to give variable names for return types, as we have done in this
function. If a function or method has variable names as well as types listed for
its return values,then a bare returnis legal (i.e.,a returnstatement that does not
specify any variables). In such cases, the listed variables’ values are returned.
We do not use bare returns in this book because they are considered to be poor
Go style.
Go takes a consistent approach to reading and writing data that allows us to
read and write to ﬁles, to buffers (e.g., to slices of bytes or to strings), and to
the standard input, output, and error streams—or to our own custom types—so
long as they provide the methods necessary to satisfy the reading and writing
interfaces.
For a value to be readable it must satisfy the io.Reader interface. This interface
speciﬁes a single method with signature, Read([]byte) (int, error) . The Read()
method reads data from the value it is called on and puts the data read into the
given byte slice. It returns the number of bytes read and an errorvalue which
will be nilif no error occurred, or io.EOF(“end of ﬁle”) if no error occurred
and the end of the input was reached, or some other non- nilvalue if an error
occurred. Similarly, for a value to be writable it must satisfy the io.Writer
interface. This interface speciﬁes a single method with signature, Write([]byte)
(int, error) . The Write()method writes data from the given byte slice into the
value the method was called on, and returns the number of bytes written and
anerrorvalue (which will be nilif no error occurred).
The iopackage provides readers and writers but these are unbuffered and
operate in terms of raw bytes. The bufiopackage providesbuffered input/output
where the input will work on any value that satisﬁes the io.Reader interface (i.e.,
provides a suitable Read()method), and the output will work on any value that
satisﬁes the io.Writer interface (i.e., provides a suitable Write()method). The
bufiopackage’s readers and writers provide buffering and can work in terms of
bytes or strings, and so are ideal for reading and writing UTF-8 encoded text
ﬁles.
★In fact, the user could still overwrite the input ﬁle by using redirection—for example,
$./americanise infile > infile —but at least we have prevented an obvious accident.
1.6. Americanise—Files,Maps,and Closures 35
var britishAmerican = "british-american.txt"
func americanise(inFile io.Reader, outFile io.Writer) (err error ){
    reader := bufio.NewReader(inFile)
    writer := bufio.NewWriter(outFile)
defer func () {
iferr ==nil {
            err = writer.Flush()
        }
    }()
var replacer func (string) string ➊
ifreplacer, err = makeReplacerFunction(britishAmerican); err != nil {
return err
    }
    wordRx := regexp.MustCompile( "[A-Za-z]+" )
    eof := false
for !eof {
var line string ➋
        line, err = reader.ReadString( '\n')
iferr == io.EOF {
            err = nil // io.EOF isn't really an error
            eof = true // this will end the loop at the next iteration
        } else if err !=nil {
return err// finish immediately for real errors
        }
        line = wordRx.ReplaceAllStringFunc(line, replacer)
if_, err = writer.WriteString(line); err != nil {➌
return err
        }
    }
return nil
}
The americanise() function buffers the inFilereader and the outFilewriter.
Then it reads lines from the buffered reader and writes each line to the buffered
writer, having replaced any British English words with their U.S. equivalents.
The function begins by creating a buffered reader and a buffered writer through
which their contentscan be accessed as bytes—or more conveniently in this case,
as strings. The bufio.NewReader() construction function takes as argument any
value that satisﬁes the io.Reader interface (i.e., any value that has a suitable
Read()method) and returns a new buffered io.Reader that reads from the given
reader. The bufio.NewWriter() function is synonymous. Notice that the ameri-
canise() function doesn’t know or care what it is reading from or writing to—the
reader and writer could be compressed ﬁles, network connections, byte slices
36 Chapter 1. An Overview in Five Examples
([]byte), or anything else that supports the io.Reader and io.Writer interfaces.
This way of working with interfaces is very ﬂexible and makes it easy to com-
pose functionality in Go.
Next we create an anonymous deferred function that will ﬂush the writer’s
buffer before the americanise() function returns control to its caller. The anony-
mous function will be called when americanise() returns normally—or abnor-
mally due to a panic. If no error has occurred and the writer’s buffer contains
unwritten bytes, the bytes will be written before americanise() returns. Since it
is possible that the ﬂush will fail we set the errreturn value to the result of the
writer.Flush() call. A less defensive approach would be to have a much simpler
deferstatement of defer writer.Flush() to ensure that the writer is ﬂushed be-
fore the function returns and ignoring any error that might have occurred before
the ﬂush—or that occurs during the ﬂush.
Go allows the use of named return values, and we have taken advantage of this
facility here ( err error ), just as we did previously in the filenamesFromCommand-
Line()function. Be aware, however, that there is a subtle scoping issue we must
consider when using named return values. For example, if we have a named
return value of value , we can assign to it anywhere in the function using the as-
signment operator ( =)a sw e ’ de x p e c t . H o w e v e r ,i f w eh a v eas t a t e m e n ts u c ha s if
value :=…, because the ifstatement starts a new block, the value in the ifstate-
ment will be a new variable, so the ifstatement’s value variable will shadow the
return value variable. In the americanise() function, erris a named return value,
so we have made sure that we never assign to it using the short variable decla-
ration operator ( :=) to avoid the risk of accidentally creating a shadow variable.
One consequence of this is that we must declare the other variables we want to
assign to at the same time, such as the replacer function (35 ➤,➊) and the line
we read in (35 ➤,➋). An alternative approach is to avoid named return values
and return the required value or values explicitly, as we have done elsewhere.
One other small point to note is that we have used the blank identiﬁer, _(35 ➤,
➌). The blank identiﬁer serves as a placeholder for where a variable is expected
in an assignment, and discards any value it is given. The blank identiﬁer is
not considered to be a new variable, so if used with :=, at least one other (new)
variable must be assigned to.
The Go standard library contains a powerful regular expression package
called regexp(§3.6.5, ➤120). This package can be used to create pointers to
regexp.Regexp values (i.e., of type *regexp.Regexp ). These values provide many
methods for searching and replacing. Here we have chosen to use the reg-
exp.Regexp.ReplaceAllStringFunc() method which given a string and a “replacer”
function with signature func(string)string , calls the replacer function for every
match,passing in the matched text,and replacing the matched text with the text
the replacer function returns.
1.6. Americanise—Files,Maps,and Closures 37
If we had a very small replacer function, say, one that simply uppercased the
words it matched, we could have created it as an anonymous function when we
called the replacement function. For example:
line = wordRx.ReplaceAllStringFunc(line,
func (word string) string { return strings.ToUpper(word) })
However, the americanise program’s replacer function, although only a few lines
long, requires some preparation, so we have created another function, makeRe-
placerFunction() , that given the name of a ﬁle that contains lines of original and
replacement words, returns a replacer function that will perform the appropri-
ate replacements.
If the makeReplacerFunction() returns a non- nilerror, we return and the caller is
expected to check the returned errorand respond appropriately (as it does).
Regular expressions can be compiled using the regexp.Compile() function which
returns a *regexp.Regexp and nil, orniland errorif the regular expression is
invalid. This is ideal for when the regular expression is read from an external
source such as a ﬁle or received from the user. Here, though, we have used the
regexp.MustCompile() function—this simply returns a *regexp.Regexp , or panics
if the regular expression, or “regexp”, is invalid. The regular expression used
in the example matches the longest possible sequence of one or more English
alphabetic characters.
With the replacer function and the regular expression in place we start an inﬁ-
nite loop that begins by reading a line from the reader. The bufio.Reader.Read-
String() method reads (or, strictly speaking, decodes ) the underlying reader’s
raw bytes as UTF-8 encoded text (which also works for 7-bit ASCII) up to and in-
cluding the speciﬁed byte (or up to the end of the ﬁle). The function conveniently
returns the text as a string, along with an error(ornil).
If the errorreturned by the call to the bufio.Reader.ReadString() method is not
nil,e i t h e rw eh a v er e a c h e dt h ee n do f t h ei n p u to rw eh a v eh i tap r o b l e m . A tt h e
end of the input errwill be io.EOFwhich is perfectly okay, so in this case we set
errtonil(since there isn’t really an error), and set eoftotrueto ensure that the
loop ﬁnishes at the next iteration, so we won’t attempt to read beyond the end of
the ﬁle. We don’t return immediately we get io.EOF, since it is possible that the
ﬁle’s last line doesn’t end with a newline, in which case we will have received a
line to be processed, in addition to the io.EOFerror.
For each line we call the regexp.Regexp.ReplaceAllStringFunc() method, giving it
the line and the replacer function. We then try to write the (possibly modiﬁed)
line to the writer using the bufio.Writer.WriteString() method—this method ac-
cepts a stringand writes it out as a sequence of UTF-8 encoded bytes, returning
the number of bytes written and an error(which will be nilif no error occurred).
We don’t care how many bytes are written so we assign the number to the blank
38 Chapter 1. An Overview in Five Examples
identiﬁer, _. Iferris not nilwe return immediately, and the caller will receive
the error.
Using bufio’s reader and writer as we have done here means that we can work
with convenient high level stringvalues, completely insulated from the raw
bytes which represent the text on disk. And, of course, thanks to our deferred
anonymous function, we know that any buffered bytes are written to the writer
when the americanise() function returns, providing that no error has occurred.
func makeReplacerFunction(file string) ( func (string) string, error ){
    rawBytes, err := ioutil.ReadFile(file)
iferr !=nil {
return nil , err
    }
    text := string(rawBytes)
    usForBritish := make (map[string]string)
    lines := strings.Split(text, "\n")
for _, line := range lines {
        fields := strings.Fields(line)
if len (fields) == 2{
            usForBritish[fields[ 0]] = fields[ 1]
        }
    }
return func (word string) string {
ifusWord, found := usForBritish[word]; found {
return usWord
        }
return word
    },nil
}
The makeReplacerFunction() takes the name of a ﬁle containing original and
replacement strings and returns a function that given an original string returns
its replacement, along with an errorvalue. It expects the ﬁle to be a UTF-8
encoded text ﬁle with one whitespace-separated original and replacement word
per line.
In addition to the bufiopackage’s readers and writers, Go’s io/ioutil package
provides some high level convenience functions including the ioutil.ReadFile()
function used here. This function reads and returns the entire ﬁle’s contents as
raw bytes (in a []byte) and an error. As usual, if the error is not nilwe immedi-
ately return it to the caller—along with a nilreplacer function. If we read the
bytes okay, we convert them to a string using a Go conversion of form type (vari-
able ).ConvertingUTF-8bytestoastringisverycheapsinceGo’ sstringsusethe
UTF-8 encoding internally. (Go’s string conversions are covered in Chapter 3.)
1.6. Americanise—Files,Maps,and Closures 39
The replacer function we want to create must accept a string and return a
corresponding string, so what we need is a function that uses some kind of
lookup table. Go’s built-in mapcollection data type is ideal for this purpose (§4.3,
➤164). A mapholds key–value pairs with very fast lookup by key. So here we will
store British words as keys and their U.S. counterparts as values.
Go’s map, slice, and channel types are created using the built-in make()function.
This creates a value of the speciﬁed type and returns a reference to it. The
reference can be passed around (e.g., to other functions) and any changes made
to the referred-to value are visible to all the code that accesses it. Here we have
created an empty map called usForBritish , with string keys and string values.
With the map in place we then split the ﬁle’s text (which is in the form of a single
long string) into lines, using the strings.Split() function. This function takes a
string to split and a separator string to split on and does as many splits as pos-
sible. (If we want to limit the number of splits we can use the strings.SplitN()
function.)
The iteration over the lines uses a forloop syntax that we haven’t seen before,
this time using a rangeclause. This form can be conveniently used to iterate
over a map’s keys and values, over a communication channel’s elements, or—as
here—over a slice’s (or array’s) elements. When used on a slice (or array),
the slice index and the element at that index are returned on each iteration,
starting at index 0 (if the slice is nonempty). In this example we use the loop to
iterate over all the lines, but since we don’t care about the index of each line we
assign it to the blank identiﬁer ( _)w h i c hd i s c a r d si t .
We need to split each line into two: the original string and the replacement
string. We could use the strings.Split() function but that would require us to
specify an exact separator string, say, "",w h i c hm i g h tf a i lo nah a n d - e d i t e dﬁ l e
where sometimes users accidentally put in more than one space, or sometimes
use tabs. Fortunately, Go provides the strings.Fields() function which splits
the string it is given on whitespace and is therefore much more forgiving of
human-edited text.
If the fieldsvariable (of type []string) has exactly two elements we insert the
corresponding key–value pair into the map. Once the map is populated we are
ready to create the replacer function that we will return to the caller.
We create the replacer function as an anonymous function given as an argument
to the returnstatement—along with a nil error value. (Of course, we could
have been less succinct and assigned the anonymous function to a variable and
returned the variable.) The function has the exact signature required by the
regexp.Regexp.ReplaceAllStringFunc() method that it will be passed to.
Inside the anonymous replacer function all we do is look up the given word. If
we access a map element with one variable on the left-hand side, that variable
is set to the corresponding value—or to the value type’s zero value if the given
40 Chapter 1. An Overview in Five Examples
key isn’t in the map. If the map value type’s zero value is a legitimate value,
then how can we tell if a given key is in the map? Go provides a syntax for
this case—and that is generally useful if we simply want to know whether a
particular key is in the map—which is to put two variables on the left-hand side,
the ﬁrst to accept the value and the second to accept a boolindicating if the key
was found. In this example we use this second form inside an ifstatement that
has a simple statement (a short variable declaration), and a condition (the found
Boolean). So we retrieve the usWord(which will be an empty string if the given
word isn’t a key in the map),and a foundﬂag of type bool.If the British word was
found we return the U.S. equivalent; otherwise we simply return the original
word unchanged.
There is a subtlety in the makeReplacerFunction() function that may not be
immediately apparent. In the anonymous function created inside it we access
theusForBritish map, yet this map was created outside the anonymous function.
This works because Go supports closures (§5.6.3, ➤225). A closure is a function
that “captures” some external state—for example, the state of the function it
is created inside, or at least any part of that state that the closure accesses. So
here, the anonymous function that is created inside the makeReplacerFunction()
is a closure that has captured the usForBritish map.
Another subtlety is that the usForBritish map is a local variable and yet we will
be accessing it outside the function in which it is declared. It is perfectly ﬁne to
return local variables in Go. Even if they are references or pointers, Go won’t
delete them while they are in use and will garbage-collect them when they are
ﬁnished with (i.e., when every variable that holds, refers, or points to them has
gone out of scope).
This section has shown some basic low-level and high-level ﬁle handling func-
tionality using os.Open() ,os.Create() , and ioutil.ReadFile() . In Chapter 8
there is much more ﬁle handling coverage, including the writing and reading
of text, binary, JSON, and XML ﬁles. Go’s built-in collection types—slices and
maps—largely obviate the need for custom collection types while providing ex-
tremely good performance and great convenience. Go’s collection types are cov-
ered in Chapter 4. Go’s treatment of functions as ﬁrst-class values in their own
right and its suppport for closures makes it possible to use some advanced and
very useful programming idioms. And Go’s deferstatement makes it straight-
forward to avoid resource leakage.
1.7. Polar to Cartesian—Concurrency
One key aspect of the Go language is its ability to take advantage of modern
computerswith multiple processorsand multiple cores,and to do so without bur-
dening programmers with lots of bookkeeping. Many concurrent Go programs
can be written without any explicit locking at all (although Go does have locking
1.7. Polar to Cartesian—Concurrency 41
primitives for when they’re needed in lower-level code, as we will see in Chap-
ter 7).
Two features make concurrent programming in Go a pleasure. First, goroutines
(in effect very lightweight threads/coroutines) can easily be created at will with-
out the need to subclass some “thread” class (which isn’t possible in Go anyway).
Second, channels provide type-safe one-way or two-way communication with gor-
outines and which can be used to synchronize goroutines.
The Go way to do concurrency is to communicate data, not to share data. This
makes it much easier to write concurrent programs than using the traditional
threads and locks approach, since with no shared data we can’t get race condi-
tions (such as deadlocks), and we don’t have to remember to lock or unlock since
there is no shared data to protect.
In this section we will look at the ﬁfth and last of the chapter’s “overview”
examples. This section’s example program uses two communication channels
and does its processing in a separate Go routine. For such a small program this
is complete overkill, but the point is to illustrate a basic use of these Go features
in as clear and short a way as possible. More realistic concurrency examples
that show many of the different techniques that can be used with Go’s channels
and goroutines are presented in Chapter 7.
The program we will review is called polar2cartesian ; it is an interactive console
program that prompts the user to enter two whitespace-separated numbers—a
radius and an angle—which the program then uses to compute the equivalent
cartesian coordinates. In addition to illustrating one particular approach to con-
currency,it also shows some simple structs and how to determine if the program
is running on a Unix-like system or on Windows for when the difference matters.
Here is an example of the program running in a Linux console:
$./polar2cartesian
Enter a radius and an angle (in degrees), e.g., 12.5 90, or Ctrl+D to quit.
Radius and angle: 5 30.5
Polar radius=5.00 θ=30.50° →Cartesian x=4.31 y=2.54
Radius and angle: 5 -30.25
Polar radius=5.00 θ=-30.25° →Cartesian x=4.32 y=-2.52
Radius and angle: 1.0 90
Polar radius=1.00 θ=90.00° →Cartesian x=-0.00 y=1.00
Radius and angle: ^D
$
The program is in ﬁle polar2cartesian/polar2cartesian.go , and we will review
it top-down, starting with the imports, then the structs it uses, then its init()
function, then its main()function, and then the functions called by main(), and so
on.
42 Chapter 1. An Overview in Five Examples
import (
"bufio"
"fmt"
"math"
"os"
"runtime"
)
The polar2cartesian program imports several packages, some of which have
been mentioned in earlier sections, so we will only mention the new ones here.
The mathpackage provides mathematical functions for operating on ﬂoating-
point numbers (§2.3.2, ➤64) and the runtimepackage provides functions that
access the program’s runtime properties, such as which platform the program is
running on.
type polarstruct {
    radius float64
θ      float64
}
type cartesian struct {
    x   float64
    y   float64
}
In Go a structis a type that holds (aggregates or embeds) one or more data ﬁelds.
These ﬁelds can be built-in types as here ( float64), or structs, or interface s, or
any combination of these. (An interface data ﬁeld is in effect a pointer to an
item—of any kind—that satisﬁes the interface, i.e., that has the methods the
interface speciﬁes.)
It seems natural to use the Greek lowercase letter theta ( θ) to represent the
polar coordinate’s angle, and thanks to Go’s use of UTF-8 we are free to do so.
This is because Go allows us to use any Unicode letters in our identiﬁers, not
just English letters.
Although the two structs happen to have the same data ﬁeld types they are dis-
tinct typesand no automatic conversion between them is possible. This supports
defensive programming; after all, it wouldn’t make sense to simply substitute a
cartesian’s positional coordinates for polar coordinates. In some cases such con-
versions do make sense, in which case we can easily create a conversion method
(i.e., a method of one type that returned a value of another type) that made use
of Go’s composite literal syntax to create a value of the target type populated by
the ﬁelds from the source type. (Numeric data type conversions are covered in
Chapter 2; string conversions are covered in Chapter 3.)
1.7. Polar to Cartesian—Concurrency 43
var prompt = "Enter a radius and an angle (in degrees), e.g., 12.5 90, " +
"or %s to quit."
func init() {
ifruntime.GOOS == "windows" {
        prompt = fmt.Sprintf(prompt, "Ctrl+Z, Enter" )
    }else {// Unix-like
        prompt = fmt.Sprintf(prompt, "Ctrl+D" )
    }
}
If a package has one or more init()functions they are automatically executed
before themainpackage’s main()function is called. (In fact, init()functions must
never be called explicitly.) So when our polar2cartesian program is invoked
this init()function is the ﬁrst function that is called. We use init()to set the
prompt to account for platform differences in how end of ﬁle is signiﬁed—for
example, on Windows end of ﬁle is given by pressing Ctrl+Z then Enter. Go’s run-
timepackage provides the GOOS(Go Operating System) constant which is a string
identifying the operating system the program is running on. Typical values are
darwin(Mac OS X), freebsd,linux, and windows.
Before diving into the main()function and the rest of the program we will
brieﬂy discuss channels and show some toy examples before seeing them in
proper use.
Channels are modeled on Unix pipes and provide two-way (or at our option,
one-way) communication of data items. Channels behave like FIFO (ﬁrst in,
ﬁrst out) queues, hence they preserve the order of the items that are sent into
them. Items cannot be dropped from a channel, but we are free to ignore any or
all of the items we receive. Let’s look at a very simple example. First we will
make a channel:
messages := make (chan string, 10)
Channels are created with the make()function (Chapter 7) and are declared us-
ing the syntax, chanType. Here we have created the messages channel to send and
receive strings. The second argument to make()is the buffer size (which defaults
to 0); here we have made it big enough to accept ten strings. If a channel’s buffer
is ﬁlled it blocks until at least one item is received from it. This means that any
number of items can pass through a channel, providing the items are retrieved
to make room for subsequent items. A channel with a buffer size of 0 can only
send an item if the other end is waiting for an item. (It is also possible to get
the effect of nonblocking channels using Go’s selectstatement, as we will see in
Chapter 7.)
Now we will send a couple of strings into the channel:
44 Chapter 1. An Overview in Five Examples
messages <- "Leader"
messages <- "Follower"
When the <-communication operator is used as a binary operator its left-hand
operand must be a channel and its right-hand operand must be a value to send
to the channel of the type the channel was declared with. Here, we ﬁrst send the
string Leaderto the messages channel, and then we send the string Follower.
message1 := <-messages
message2 := <-messages
When the <-communication operator is used as a unary operator with just a
right-hand operand (which must be a channel), it acts as a receiver, blocking
until it has a value to return. Here, we retrieve two messages from the messages
channel. The message1 variable is assigned the string Leaderand the message2
variable is assigned the string Follower; both variables are of type string.
Normally channels are created to provide communication between goroutines.
Channel sends and receives don’t need locks, and the channel blocking behavior
can be used to achieve synchronization.
Now that we have seen some channel basics, let’s see channels—and goroutines
—in practical use.
func main() {
    questions := make (chan polar)
defer close (questions)
    answers := createSolver(questions)
defer close (answers)
    interact(questions, answers)
}
Once any init()functions have returned, Go’s runtime system then calls the
mainpackage’s main()function.
Here, the main()function begins by creating a channel (of type chan polar ) for
passing polarstruct s, and assigns it to the questions variable. Once the channel
has been created we use a deferstatement to call the built-in close()function
(➤187) to ensure that it is closed when it is no longer needed. Next we call the
createSolver() function, passing it the questions channel and receiving from it
ananswerschannel (of type chan cartesian ). We use another deferstatement to
ensure that the answerschannel is closed when it is ﬁnished with. And ﬁnally,
we call the interact() function with the two channels, and in which the user
interaction takes place.
1.7. Polar to Cartesian—Concurrency 45
func createSolver(questions chan polar)chan cartesian {
    answers := make (chan cartesian)
go func () {
for {
            polarCoord := <-questions ➊
θ:= polarCoord. θ*math.Pi / 180.0// degrees to radians
            x := polarCoord.radius *math.Cos( θ)
            y := polarCoord.radius *math.Sin( θ)
            answers <- cartesian{x, y} ➋
        }
    }()
return answers
}
The createSolver() function begins by creating an answerschannel to which it
will send the answers (i.e., cartesian coordinates) to the questions (i.e., polar
coordinates) that it receives from the questions channel.
After creating the channel,the function then has a gostatement. A gostatement
is given a function call (syntactically just like a deferstatement), which is exe-
cuted in a separate asynchronous goroutine. This means that the ﬂow of control
in the current function (i.e., in the main goroutine) continues immediately from
the following statement. In this case the gostatement is followed by a return
statement that returns the answerschannel to the caller. As we noted earlier,it is
perfectly safe and good practice in Go to return local variables, since Go handles
the chore of memory management for us.
In this case we have (created and) called an anonymous function in the gostate-
ment. The function has an inﬁnite loop that waits (blocking its own goroutine,
but not any other goroutines, and not the function in which the goroutine was
started), until it receives a question—in this case a polarstruct on the questions
channel. When a polar coordinate arrives the anonymous function computesthe
corresponding cartesian coordinateusing some simple math (and using the stan-
dard library’s mathpackage), and then sends the answer as a cartesian struct
(created using Go’s composite literal syntax), to the answerschannel.
In➊the<-operator is used as a unary operator, retrieving a polar coordinate
from the questions channel. And in ➋the<-operator is used as a binary opera-
tor; its left-hand operand being the answerschannel to send to, and its right-hand
operand being the cartesian to send.
Once the call to createSolver() returns we have reached the point where we have
two communication channels set up and where a separate goroutine is waiting
for polar coordinatesto be sent on the questions channel—and without any other
goroutine, including the one executing main(),b e i n gb l o c k e d .
46 Chapter 1. An Overview in Five Examples
const result = "Polar radius=%.02f θ=%.02f° →Cartesian x=%.02f y=%.02f\n"
func interact(questions chan polar, answers chan cartesian) {
    reader := bufio.NewReader(os.Stdin)
    fmt.Println(prompt)
for {
        fmt.Printf( "Radius and angle: " )
        line, err := reader.ReadString( '\n')
iferr !=nil {
break
        }
var radius, θfloat64
if_, err := fmt.Sscanf(line, "%f %f", &radius, & θ); err != nil {
            fmt.Fprintln(os.Stderr, "invalid input" )
continue
        }
        questions <- polar{radius, θ}
        coord := <-answers
        fmt.Printf(result, radius, θ, coord.x, coord.y)
    }
    fmt.Println()
}
This function is called with both channels passed as parameters. It begins by
creating a buffered reader for os.Stdin since we want to interact with the user in
the console. It then prints the prompt that tells the user what to enter and how
to quit. We could have made the program terminate if the user simply pressed
Enter (i.e., didn’t type in any numbers), rather than asking them to enter end of
ﬁle. However, by requiring the use of end of ﬁle we have made polar2cartesian
more ﬂexible, since it is also able to read its input from an arbitrary external ﬁle
using ﬁle redirection (providing only that the ﬁle has two whitespace-separated
numbers per line).
The function then starts an inﬁnite loop which begins by prompting the user to
enter a polar coordinate (a radius and an angle).After asking for the user’s input
the function waits for the user to type some text and press Enter, or to press Ctrl+D
(orCtrl+Z ,Enter on Windows) to signify that they have ﬁnished. We don’t bother
checking the error value; if it isn’t nilwe break out of the loop and return to the
caller ( main()), which in turn will return (and call its deferred statements to close
the communication channels).
We create two float64s to hold the numbers the user has entered and then use
Go’s fmt.Sscanf() function to parse the line. This function takes a string to parse,
a format—in this case two whitespace-separated ﬂoating-point numbers—and
one or more pointers to variables to populate. (The &address of operator is used
to get a pointer to a value; see §4.1, ➤140.) The function returns the number of
1.7. Polar to Cartesian—Concurrency 47
items it successfully parsed and an error(ornil).In the case of an error,we print
an error message to os.Stderr —this is to make the error message visible on the
console even if the program’s os.Stdout is redirected to a ﬁle. Go’s powerful and
ﬂexible scan functions are shown in use in Chapter 8 (§8.1.3.2, ➤380), and listed
in Table 8.2 ( ➤383).
If valid numbers were input and sent to the questions channel (in a polarstruct ),
we block the main goroutine waiting for a response on the answerschannel. The
additional goroutine created in the createSolver() function is itself blocked wait-
ing for a polaron the questions channel, so when we send the polar, the addi-
tional goroutine performs the computation, sends the resultant cartesian to the
answerschannel, and then waits (blocking only itself) for another question to
arrive. Once the cartesian answer is received in the interact() function on the
answerschannel, interact() is no longer blocked. At this point we print the re-
sultstring using the fmt.Printf() function, and passing the polar and cartesian
values as the arguments that the resultstring’s %placeholders are expecting.
The relationship between the goroutines and the channels is illustrated in Fig-
ure 1.1.Main goroutine
init()
main()
createSolver()
interact()Solver goroutine
func() // anonymousQuestions
Answers
Figure 1.1 Two communicating goroutines
The interact() function’s forloop is an inﬁnite loop, so as soon as a result is
printed the user is once again asked to enter a radius and angle, with the loop
being broken out of only if the readerreads end of ﬁle—either interactively from
the user or because the end of a redirected input ﬁle has been reached.
The calculations in polar2cartesian are very lightweight, so there was no real
need to do them in a separate goroutine. However, a similar program that
needed to do multiple independent heavyweight calculations as the result of
each input might well beneﬁt from using the approach shown here, for example,
with one goroutine per calculation. We will see more realistic use cases for
channels and goroutines in Chapter 7.
We have now completed our overview of the Go language as illustrated by the
ﬁve example programs reviewed in this chapter. Naturally, Go has much more
to offer than there has been space to show here, as we will see in the subsequent
chapters, each of which focuses on a speciﬁc aspect of the language and any
relevant packages from the standard library. This chapter concludes with a
small exercise, which despite its size, requires some thought and care.
48 Chapter 1. An Overview in Five Examples
1.8. Exercise
Copy the bigdigits directory to, say, my_bigdigits , and modify my_bigdigits/big-
digits.go to produce a version of the bigdigits program (§1.4, 16 ➤) that can
optionally output the number with an overbar and underbar of “ *”s, and with
improved command-line argument handling.
The original program output its usage message if no number was given; change
this so that the usage message is also output if the user gives an argument of -h
or--help. For example:
$./bigdigits --help
usage: bigdigits [-b|--bar] <whole-number>
-b --bar  draw an underbar and an overbar
If the --bar(or-b) option is notpresent the program should have the same
behavior as before. Here is an example of the expected output if the option is
present:
$./bigdigits --bar 8467243
*************************************************
888      4     666   77777   222      4     333
8   8    44    6          7  2   2    44    3   3
8   8   4 4    6         7      2    4 4        3
888   4  4    6666     7      2    4  4      33
8   8  444444  6   6   7      2     444444      3
8   8     4    6   6  7      2         4    3   3
888      4     666   7      22222     4     333
*************************************************
The solution requires more elaborate command-line processing than the version
shown in the text, although the code producing the output only needs a small
change to output the overbar before the ﬁrst row and the underbar after the
last row. Overall, the solution needs about 20 extra lines of code—the solution’s
main()function is twice as long as the original (~40 vs. ~20 lines), mostly due to
the code needed to handle the command line. A solution is provided in the ﬁle
bigdigits_ans/bigdigits.go .
Hints:The solution also has a subtle difference in the way it builds up each row’s
line to prevent the bars extending too far. Also, the solution imports the strings
package and uses the strings.Repeat(string, int) function. This function
returns a string that contains the stringit is given as its ﬁrst argument repeated
by the number of times of the intgiven as its second argument. Why not look
this function up either locally (see the sidebar “The Go Documentation”, 8 ➤),
or at golang.org/pkg/strings , and start to become familiar with the Go standard
library’s documentation.
1.8. Exercise 49
It would be much easier to handle command-line arguments using a package de-
signed for the purpose. Go’s standard library includes a rather basic command
line parsing package, flag, that supports X11-style options (e.g., -option). In ad-
dition, several option parsers that support GNU-style short and long options
(e.g., -oand --option) are available from godashboard.appspot.com/project .
This page intentionally left blank 
Index
Symbols & Numbers
!logical NOToperator, 57
!=inequality operator, 56–57, 68–69,
70, 164
""double quotes, 83
#!shebang scripts, 10
$replacements in regular expres-
sions, 120, 126, 129
%modulus operator and formatting
placeholder, 47, 60, 69; see also
format speciﬁer
%=augmented modulus operator, 60
&address of and bitwise ANDopera-
tor, 45, 46, 55, 60, 142, 143, 144,
167, 246, 247, 248, 267, 269, 284,
382, 383, 384, 387, 393, 394, 395
&&logical ANDoperator, 56, 57
&=augmented bitwise ANDoperator,
60
&^bitwise clear operator, 60
&^=augmented bitwise clear opera-
tor, 60
*multiplication, dereference, point-
er declaration operator and for-
matting placeholder, 26, 59, 69,
96, 100, 142, 143, 144, 178, 247,
248, 249, 259, 284, 305, 370, 382,
394
*=augmented multiplication opera-
tor, 59, 147
+addition, concatenation, and unary
plus operator, 20, 59, 84, 85, 226
++increment operator, 20, 59, 186,
188
+=augmented addition and string
append operator, 20, 59, 84, 85,
88, 140; see also append()-subtraction and unary minus oper-
ator, 59
--decrement operator, 20, 59, 186,
188
-=augmented subtraction operator,
59
.selector operator, 148, 275
...ellipsis operator, 149, 156, 158,
160, 176, 219, 221, 222, 233, 242,
268, 287, 378
/division operator, 59
/**/multiline comments, 14, 51
//single-line comments, 14, 51
/=augmented division operator, 59
:=short variable declaration opera-
tor, 15, 18, 36, 53, 188, 189, 198,
203
;semicolon, 15, 186
<less than comparison operator,
56–57
<-send/receive communication oper-
ator, 44, 45, 207, 210, 318–357
<<bitwise shift left operator, 55, 60
<<=augmented bitwise shift left op-
erator, 60
<=less than or equal comparison op-
erator, 56–57
=assignment operator, 16, 18, 36,
188, 212
==equality operator, 56–57, 68–69,
70, 164
>greater than comparison operator,
56–57
>=greater than or equal comparison
operator, 56–57
>>bitwise right shift operator, 60
>>=augmented bitwise right shift
operator, 60
[]index and slice operator,16,28,85,
91, 203, 242, 339, 355, 357, 393
443
444 Index
\(backslash), 84
\a(alert or bell), 84
\b(backspace), 84
\f(form feed), 84
\n(newline), 51, 84
\r(carriage return), 84
\t(tab), 84
\Uhhhhhhhh (rune literal), 84
\uhhhh (rune literal), 84
\v(vertical tab), 84
\xhh(rune literal), 84
^bitwise XORand complement opera-
tor, 60
^=augmented bitwise XORoperator,
60
_blank identiﬁer, 36, 52–53, 154,
170, 188, 291, 358, 417; see also
identiﬁers
``backticks, 75, 78, 96
{}braces, 15, 186
|bitwise ORoperator, 55, 60
|=augmented bitwise ORoperator,
60
||logical ORoperator, 56, 57, 178
5g,6g,8g(tool), 9
5l,6l,8l(tool), 9
7-bit ASCII encoding, 82
A
Abs()
cmplxpackage, 71
mathpackage, 65, 68
abstract vs. concrete types, 22
abstraction and abstract types; see
interfaces
access operator; see[]index oper-
ator
access, serialized, 318–319, 335, 341
accessing maps, 39, 168–169, 231
accuracy, ﬂoating-point, 64
Acos()
cmplxpackage, 71
mathpackage, 65Acosh()
cmplxpackage, 71
mathpackage, 65
Add()
Inttype, 63
WaitGroup type, 350, 351, 352, 354
address; seepointers
After()(timepackage), 332, 333, 426
aggregation, 254–256, 275–282; see
alsoembedding
alert or bell ( \a), 84
aliasing, package names, 409, 418
americanise (example), 29–40
and, logical; see&&operator
anonymous ﬁelds, structkeyword
anonymous functions, 36, 37, 110,
112, 206, 208, 212, 216, 218, 225,
226, 239, 240, 243, 290
anonymous struct, 275
apachereport (example), 341–349
API (Application Programming In-
terface); seeinterfaces
App Engine, Google, 2, 435
append() (built-in),25, 27, 55, 77, 129,
132, 150, 151, 156–157, 158, 159,
160, 170, 176, 178, 179, 187, 232,
240, 247, 249, 272, 355, 374, 382,
392, 410; see also +=
AppendBool() (strconvpackage), 114
AppendFloat() (strconvpackage), 114
AppendInt() (strconvpackage), 114
AppendQuote() (strconvpackage), 114
AppendQuoteRune() (strconvpackage),
114
AppendQuoteRuneToASCII() (strconv
package), 114
AppendUInt() (strconvpackage), 114
archive ﬁles; see.tarﬁles and .zip
ﬁles
archive(package)
tar(package); seetop-level entry
zip(package); seetop-level entry
archive_file_list (exercise), 250
Index 445
Argsslice ( ospackage), 14, 15, 17, 19,
131–132, 232
arguments,command line, 16, 17, 19,
232; see also flagpackage and
commandLineFiles()
arguments, function and method;
seeparameters
arrays, 140, 148–150; see also slices
iterating, 203
multidimensional, 148
mutability, 149
ASCII encoding, 82
Asin()
cmplxpackage, 71
mathpackage, 65
Asinh()
cmplxpackage, 71
mathpackage, 65
assertions, type; seetype assertions
assertions, zero-width in regular ex-
pressions, 122
assignment operators; see=and :=
operators
assignments, multiple, 31, 188
associative array; seemaptype
asynchronous, channel, 207; see also
channels
Atan()
cmplxpackage, 71
mathpackage, 65
Atan2()(mathpackage), 65
Atanh()
cmplxpackage, 71
mathpackage, 65
Atoi()(strconvpackage), 116, 134,
390
atomic updates, 338
audio format, Vorbis, 130
B
backslash ( \), 84
backreferences, in regular expres-
sions, 126backspace ( \b), 84
backticks ( ``), 75, 96
backtracking,in regular expressions,
120
balanced binary tree; seeomapexam-
ple
bare returns, 34, 189, 219
Base()(filepath package), 19,
131–132, 194, 327
benchmarking, 415–416
big(package; mathpackage)
Int(type); seetop-level entry
NewInt(), 63
ProbablyPrime() , 425
Rat(type); seetop-level entry
big-O notation, 89
bigdigits (example), 16–21, 48
bigdigits (exercise), 48
BigEndian (variable; binarypackage),
389
binary ﬁles, 387–397; see also .gob
ﬁles
binary number, formatting as, 98
binary(package; encoding package),
388, 391
BigEndian (variable), 389
LittleEndian (variable), 388, 389
Read(), 391, 393, 395
Write(), 388
binary tree; seeomapexample
binary vs. linear search, 162–163
bisectLeft() (example), 314
blank identiﬁer ( _), 36, 52–53, 154,
170, 188, 291, 358, 417; see also
identiﬁers
blocking, channel, 207–208, 209; see
alsochannels
bool(type; built-in), 53, 56–57, 195,
204, 318
formatting, 97
Bool()(Valuetype), 428
Boolean expressions, 193, 204
braces ( {}), 15, 186
446 Index
branching, 192–202
break(statement), 24, 177, 186, 204,
205, 331
Buffer(type; bytespackage), 111,
200, 201, 243
ReadRune() , 113
String(), 88, 200, 243
WriteRune() , 111
WriteString() , 88, 111, 200, 243
buffers; seebufiopackage and File
type
bufio(package), 30, 34, 38
NewReader() , 35, 176, 333, 380
NewWriter() , 35, 378
Reader(type); seetop-level entry
Writer(type); seetop-level entry
building Go programs, 11–13
built-in functions
append(), 25, 27, 55, 77, 129, 132,
150, 151, 156–157, 158, 159,
160, 170, 176, 178, 179, 187,
232, 240, 247, 249, 272, 355,
374, 382, 392, 410; see also
+=
cap(), 24, 149, 151, 152, 157, 187,
324
close(), 44, 187, 211, 320, 321,
324, 325, 329, 330, 340, 343
complex() , 58, 187; see also cmplx
package
copy(), 157–158, 159, 187, 268
delete(), 165, 169, 187, 339
imag(), 70, 101, 187
len(), 15, 20, 24, 27, 69, 85, 90,
148, 149, 151, 152, 157, 159,
165, 169, 187, 340
make(), 26, 38, 39, 43, 44, 127, 129,
150, 151, 152, 157, 159, 165,
172, 176, 178, 179, 187, 207,
208, 209, 211, 240, 242, 246,
247, 323, 324, 328, 337, 339,
341, 346, 348, 355, 374, 392,
393, 395, 410
new(), 145, 146, 152, 187, 346panic(), 32, 69, 70, 113, 187, 191,
196, 213–218, 219, 220, 243
real(), 70, 101, 187
recover() , 32, 187, 213–218
see also functions and special
functions
built-in types; seebool,byte,error,
int,map,rune,string,uint;see
alsostandard library’s types
byte ordering, 83, 389
byte(type; built-in), 20, 59, 60, 82,
104, 132, 190
conversion from string, 89–90,
164, 373, 391
conversion of []bytetostring, 38,
85, 164, 334, 395
formatting, 102
see also runeand stringtypes
bytes(package), 419
Buffer(type); seetop-level entry
TrimRight() , 333, 334
C
C code, external, 9
Call()(Valuetype), 429, 430
Caller() (runtimepackage), 291
calling functions, 220–221; see also
functions
CanBackquote() (strconvpackage),
114
CanSet() (Valuetype), 428
cap()(built-in), 24, 149, 151, 152,
157, 187, 324
carriage return ( \r), 84
case(keyword); seeselectand switch
statements
Cbrt()(mathpackage), 65
Ceil()(mathpackage), 65
cgo(tool), 9
cgrep(example), 326–334
chan(keyword), 43, 44, 208, 209, 210,
318–357; see also channels
Index 447
channels, 41, 43–44, 206–212,
318–357
inﬁnite, 208
iterating, 203
character; seerunetype
character classes in regular expres-
sions, 122
character encoding,ﬁxed vs.variable
width, 83
character literal, 20; see also rune
type
checked type assertion; seetype as-
sertions
class, 254; see also typekeyword
close()(built-in), 44, 187, 211, 320,
321, 324, 325, 329, 330, 340, 343
Close()(Filetype), 31, 176, 213, 293,
333, 343, 353, 398, 400
closures, 40, 163, 225–227, 239, 240,
243, 244, 352
cmplx(package; mathpackage), 70
Abs(), 71
Acos(), 71
Acosh(), 71
Asin(), 71
Asinh(), 71
Atan(), 71
Atanh(), 71
Conj(), 71
Cos(), 71
Cosh(), 71
Cot(), 71
Exp(), 71
Inf(), 71
IsInf(), 71
IsNaN(), 71
Log(), 71
Log10(), 71
NaN(), 71
Phase(), 71
Polar(), 71
Pow(), 71
Rect(), 71Sin(), 71
Sinh(), 71
Sqrt(), 71
Tan(), 71
Tanh(), 71
code point, Unicode; seerunetype
collection packages, 421–423
collections, slices, maptype, and omap
example
color(package)
RGBA(type); seetop-level entry
command-line arguments, 16, 17, 19,
232; see also flagpackage
commandLineFiles() (example), 176,
410
commas() (example), 357
comments, Go, 14, 51
CommonPathPrefix() (exercise), 250
CommonPrefix() (exercise), 250
Communicating Sequential Process-
es (CSP), 3, 315
communication,between goroutines;
seechannels,goroutines,and the
chanand gokeywords
comparisons, 56–57, 70, 84, 86–87;
see also <,<=,==,!=,>=, and >op-
erators
compilation speed, 2
Compile() (regexppackage), 37, 121,
214, 327
CompilePOSIX() (regexppackage), 121
complex() (built-in), 58, 70, 187; see
also cmplxpackage
Complex() (Valuetype), 428
complex64 (type; built-in), 64, 70
complex128 (type; built-in), 64, 70,
101, 187
comparisons, 70
conversion to complex64 , 70
formatting, 101
literals, 53, 70
see also cmplxpackage and imag()
and real()
448 Index
composing functionality, 35
composite literals, 18, 45, 150, 152,
153, 166, 167
compositing, image, 290
composition; seeaggregation and em-
bedding
compress (package)
gzip(package), seetop-level en-
try
concatenation, fast string, 88
concatenation, string;see+and+=op-
erators
concrete vs. abstract types, 22
concurrency; seechannels, gorou-
tines, and the chanand gokey-
words
conditional branching, 192–202
Conj()(cmplxpackage), 9
console; seeStderr,Stdin, and Std-
outstreams
const(keyword), 45, 53, 54, 58, 133,
336, 364, 379, 390
constant expressions, 58
constants,numeric; seeunder literals
and speciﬁc types
construction functions, 27, 263, 264,
306
constructors; seeconstruction func-
tions
container (package), 421–423
heap(package), 421–422
list(package), 422–423
ring(package), 423
containers; seeslices, maptype, and
omapexample
Contains() (stringspackage), 108
contents of; seepointers and *deref-
erence operator
continue (statement), 132, 133, 186,
204, 205, 324
conversions,42, 57, 61, 162, 190–191,
288
[]bytetostring, 38, 85, 164, 334,
395[]runetostring, 91, 272
complex128 tocomplex64 , 70
downsizing, 58, 61
float64toint, 69
inttofloat64, 61, 73
inttoint64, 63
runetostring, 87–88, 246
stringto[]byte, 85, 164, 373, 391
stringto[]rune, 85
stringtofloat64, 77
see also thestrconvpackage
copy()(built-in), 157–158, 159, 187,
268
Copy()(iopackage), 353, 354, 399,
401, 402, 405
copy on write, of strings, 140
Copysign() (mathpackage), 65
coroutines; seechannels, goroutines,
and the chanand gokeywords
Cos()
cmplxpackage, 71
mathpackage, 45, 65
Cosh()
cmplxpackage, 71
mathpackage, 65
Cot()(cmplxpackage), 9
Count()(stringspackage), 108, 172,
173
Cox, Russ, 2, 120, 436
Create() (Filetype), 31, 293, 397,
400
CreateHeader() (Writertype), 398,
399
cross-platform code, 410–411
crypto(package), 425
rand(package), seetop-level en-
try
sha1(package), seetop-level en-
try
.csvﬁles, 424
csv(package; encoding package), 424
currying; seeclosures
Index 449
custom packages, 24–29, 408–417;
see also packages
custom types, 55, 103, 255–282
named vs. unnamed, 22
see also type
D
Dashboard, Go, 2
data structures, slices, maptype, and
struct
database (package)
sql(package), 423
deadlock, 317–318, 340
debugging, 55, 103–106
decimal number, formatting as, 99;
see also inttype
declarations, order of, 21
Decode()
gobpackage
Decodertype, 387
jsonpackage
Decodertype, 369, 370
xmlpackage
Decodertype, 375, 377
DecodeConfig() (imagepackage), 358
DecodeLastRune() (utf8package), 118
DecodeLastRuneInString() (utf8pack-
age), 91, 118, 229, 230
Decoder(type)
gobpackage
Decode(), 387
jsonpackage), 369
Decode(), 369, 370
xmlpackage
Decode(), 375, 377
DecodeRune() (utf8package), 118
DecodeRuneInString() (utf8package),
91, 92, 93, 118, 203, 229, 230
DeepEqual() (reflectpackage), 57,
236, 427
default(keyword); seeselectand
switchstatementsdefer(statement), 31–32, 35, 36, 44,
97, 176, 211–213, 216, 218, 333,
343, 353, 378, 398, 400
deﬁning methods, 25
deﬁnitions, order of, 21
delegation; seeembedding
delete() (built-in), 165, 169, 187,
339
dereferencing pointers; seepointers
dictionary; seemaptype
Dim()(mathpackage), 65
Div()(Inttype), 63
division by zero, 68
documentation, Go, 8
documentation, package, 411–413
domain name resolution; seenet
package
Done()(WaitGroup type), 350, 352,
354
double quotes ( " "), 83
doubly linked list; seelistpackage
downloading Go, 9
downsizing; seeconversions
Draw()(drawpackage), 290
draw(package; imagepackage)
Draw(), 290
Image(interface), 290, 293, 319
duck typing, 21, 32, 254–255, 268
Duration (type; timepackage), 332,
333
E
E(constant; mathpackage), 65, 104,
105
Elem()(Valuetype), 429
else(keyword); seeifstatement
embedding, 254–256, 261, 270–274,
275–282, 294, 300; see also ag-
gregation
empty interface; seeinterface{}
empty struct, 328
450 Index
Encode()
gobpackage
Encodertype, 385, 386
jsonpackage
Encodertype, 367, 370
xmlpackage
Encodertype, 373, 375
Encoder(type)
gobpackage
Encode(), 385, 386
jsonpackage, 367
Encode(), 367, 370
xmlpackage, 373
Encode(), 373, 375
EncodeRune() (utf8package), 118
encoding
ASCII (7-bit, US-), 82
of characters, ﬁxed vs. variable
width, 83
UTF-8; seeUnicode
encoding (package)
binary(package), seetop-level en-
try
csv(package); seetop-level entry
gob(package); seetop-level entry
json(package), seetop-level en-
try
xml(package); seetop-level entry
end of ﬁle; seeEOF
endianness, 83, 389
endsoftpatents.org (web site), 439
entry point, 14, 224–225
enumerations, 54–56; see also const
and iota
environment variables
GOPATH, 8, 13, 23, 408, 409, 410,
411, 417, 418
GOROOT, 8, 10, 11, 23, 408, 410, 418,
424
PATH, 10
see also variables
EOF(iopackage), 34, 35, 37, 113, 177,
268, 333, 343, 381, 404EqualFloat() (example), 68–69
EqualFloatPrec() (example), 69
EqualFold() (stringspackage), 108,
163
equality comparisons ( ==,!=), 56–57,
68–69, 70, 164
Erf()(mathpackage), 65
Erfc()(mathpackage), 65
error handling, 24, 32, 145, 213
Error()(method), 31
error(type; built-in), 24, 27, 34, 58,
93, 134, 145, 213, 214, 216, 284,
285
Errorf() (fmtpackage), 33, 58, 94, 97,
216, 285, 293, 365, 382, 384
errors(package), 24
New(), 27, 33, 194, 384
escapes, 84, 102, 375, 377; see also
regexppackage’s escapes
EscapeString() (htmlpackage), 78
examples, 10
americanise , 29–40
apachereport , 341–349
bigdigits , 16–21, 48
bisectLeft() , 314
cgrep, 326–334
commandLineFiles() , 176, 410
commas(), 357
EqualFloat() , 68–69
EqualFloatPrec() , 69
filter, 322–326
Filter(), 240–241
findduplicates , 349–357
FuzzyBool , 282–288
guess_separator , 171–174
hello, 14–16
Humanize() , 100
indent_sort , 244–249
InsertStringSlice() , 158
InsertStringSliceCopy() ,
157–158
invoicedata , 362–397
logPanics() , 218
Index 451
m3u2pls, 130–135
Memoize() , 242–244
omap, 302–310, 409, 412–413,
414–416
pack, 397–405
Pad(), 99
palindrome , 232
pi_by_digits , 62–64
polar2cartesian , 40–47
RemoveStringSlice() , 160
RemoveStringSliceCopy() ,
159–160
RomanForDecimal() , 243–244
safemap, 334–340
shaper, 289–301
SimplifyWhitespace() , 111
SliceIndex() , 238–239
stacker, 21–29, 408–409
statistics , 72–78
statistics_nonstop , 216–218
unpack, 397–405
wordfrequencies , 174–180
exceptions; seepanic()and recov-
er()
exec(package; ospackage), 426
exercises
archive_file_list , 250
bigdigits , 48
CommonPathPrefix() , 250
CommonPrefix() , 250
Flatten() , 181
font, 311
imagetag, 358
.iniﬁle to map, 181
invoicedata , 406
IsPalindrome() , 250
linkcheck , 432
linkutil, 431–432
Make2D(), 181
mapto.iniﬁle, 182
oslice, 313–314
playlists , 135–136
quadratic , 79
safeslice , 357–358shaper, 311–313
sizeimages , 359
soundex, 136–137
statistics , 79
UniqueInts() , 180
unpack, 405
utf16-to-utf8 , 405
Exit()(ospackage), 19, 20, 32,
131–132, 327
exiting; seetermination and Exit()
Exp()
cmplxpackage, 71
Inttype, 63
mathpackage, 65
Exp2()(mathpackage), 65
Expand() (Regexptype), 124
ExpandString() (Regexptype), 124
Expm1()(mathpackage), 65
exponential notation, 64, 101
exported identiﬁers, 52, 202, 264
expression switches, 195–197
Ext()(filepath package), 293, 324,
325
extension, ﬁle, 194
external C code, 9
F
factory function, 226, 291, 298
fallthrough (statement), 186, 195,
196–197
false(built-in); seebooltype
fast compilation, 2
fast stringconcatenation, 88
Fatal()(logpackage), 19, 20, 32,
131–132, 342
Fatalf() (logpackage), 20, 327
FieldByName() (Valuetype), 428
ﬁelds; seestructkeyword
Fields() (stringspackage), 38, 39,
76, 77, 107–110, 108, 111
FieldsFunc() (stringspackage), 108,
178
452 Index
ﬁle globbing, 176, 410–411
ﬁle sufﬁx, 194
File(type; ospackage), 31, 32, 176
Close(), 31, 176, 213, 293, 333,
343, 353, 398, 400
Create(), 31, 293, 397, 400
Open(), 31, 176, 212, 333, 342, 353,
398, 400
OpenFile() , 31, 397
ReadAt(), 397
Readdir() , 361
Readdirnames() , 361
Seek(), 397
Stat(), 397, 398, 399, 400
WriteAt() , 397
ﬁle types
.csv, 424
.go, 84, 408, 410
.gob, 385–387
.ini, 131, 181–182
.jpgand .jpeg, 293
.m3u, 130–135
.pls, 130–135
.png, 293
.tar, 399–401, 403–405
.txt, 377–384
.zip, 397–399, 401–403
FileInfo (interface; ospackage), 351,
361, 397, 399
Mode(), 351, 401
ModTime() , 401
Size(), 351, 353, 401
FileInfoHeader() (zippackage), 398,
399
filepath (package; pathpackage), 17,
19, 424
Base(), 19, 131–132, 194, 327
Ext(), 293, 324, 325
FromSlash() , 135
Glob(), 176, 410
Separator (constant), 134, 135
ToSlash() , 399
Walk(), 349, 352filter(example), 322–326
Filter() (example), 240–241
Find()(Regexptype), 124
FindAll() (Regexptype), 124
FindAllIndex() (Regexptype), 124
FindAllString() (Regexptype), 124,
127
FindAllStringIndex() (Regexptype),
124
FindAllStringSubmatch() (Regexp
type), 124, 127
FindAllStringSubmatchIndex() (Regexp
type), 124, 128
FindAllSubmatch() (Regexptype), 124
FindAllSubmatchIndex() (Regexptype),
124
findduplicates (example), 349–357
FindIndex() (Regexptype), 124
FindReaderIndex() (Regexptype), 124
FindReaderSubmatchIndex() (Regexp
type), 124
FindString() (Regexptype), 124
FindStringIndex() (Regexptype), 124
FindStringSubmatch() (Regexptype),
124, 127, 343, 344, 348
FindStringSubmatchIndex() (Regexp
type), 124
FindSubmatch() (Regexptype), 125
FindSubmatchIndex() (Regexptype),
125
ﬁxed vs. variable-width character
encoding, 83
flag(package), 426
ﬂags, regular expression, 123
Flatten() (exercise), 181
Float()(Valuetype), 428
float32(type; built-in), 61, 64, 70,
283, 285, 427
Float32bits() (mathpackage), 65
Float32frombits() (mathpackage), 65
float64(type; built-in), 61, 62, 64–70,
73, 100, 187, 221, 304, 318
accuracy, 64
Index 453
comparisons, 57, 68–69
conversion from int, 61, 69, 73
conversion from string,seeParse-
Float()
formatting, 100–101
literals, 53, 58
see also mathpackage
Float64bits() (mathpackage), 65
Float64frombits() (mathpackage), 65
Float64s() (sortpackage), 73, 161
Float64sAreSorted() (sortpackage),
161
Floor()(mathpackage), 66
Flush()(Writer), 35, 36, 378
fmt(package), 55, 93–106, 192
Errorf(), 33, 58, 94, 97, 216, 285,
293, 365, 382, 384
format speciﬁer, 96, 97; see also
%symbol
Fprint(), 76, 94, 96
Fprintf() , 76, 94, 97, 200, 201,
378
Fprintln() , 45, 94, 96
Fscan(), 383
Fscanf(), 383, 384
Fscanln() , 383
Print(), 94, 96
Printf(), 19, 47, 94–106, 113, 178,
192
Println() , 19, 24, 45, 53, 72,
94–106
Scan(), 383
Scanf(), 383
Scanln(), 383
Sprint(), 94, 99, 178, 242, 357
Sprintf() , 43, 55, 69, 78, 85, 94,
97, 100, 101, 242, 286, 355
Sprintln() , 94
Sscan(), 383
Sscanf(), 45, 46, 382, 383
Sscanln() , 383
Stringer (interface), 265,
266–267, 286
font(exercise), 311forloop, 19, 23, 24, 38, 39, 74, 89,
110, 132, 147, 154, 155, 168, 170,
172, 177, 186, 200, 203–205, 320,
321, 324, 325, 330, 331, 339, 343,
355, 390
form feed ( \f), 84
Form(ﬁeld; Requesttype), 76
format speciﬁer, fmtpackage, 96, 97;
see also %symbol
Format() (Timetype), 368, 379, 390
FormatBool() (strconvpackage), 114,
116
FormatFloat() (strconvpackage), 114
FormatInt() (strconvpackage), 114,
117
formatting
bools, 97
complex numbers, 101
ﬂoating-point numbers, 100–101
for debugging, 103–106
integers, 98–99
maps, 106
pointers, 96, 104
runes, 99
slices, 101–103
strings, 101–103
FormatUInt() (strconvpackage), 114
Fprint() (fmtpackage), 76, 94, 96
Fprintf() (fmtpackage), 76, 94, 97,
200, 201, 378
Fprintln() (fmtpackage), 45, 94, 96
Frexp()(mathpackage), 66
FromSlash() (filepath package), 135
Fscan()(fmtpackage), 383
Fscanf() (fmtpackage), 383, 384
Fscanln() (fmtpackage), 383
FullRune() (utf8package), 118
FullRuneInString() (utf8package),
118
454 Index
func(keyword), 14, 15, 25, 35, 45, 55,
208, 216, 218, 219, 223, 226, 232,
238, 240, 241, 243, 246, 291, 303,
305, 323, 324, 343, 378, 379, 388,
389, 413
FuncForPC() (runtimepackage), 291,
292
functionality, composing, 35
functions, 219–244
anonymous, 36, 37, 110, 112, 206,
208, 212, 216, 218, 225, 226,
239, 240, 243, 290
calling, 220–221
closures, 40, 163, 225–227, 239,
240, 243, 244
construction, 27, 306
factory, 226, 291, 298
generic, 232–238; see also higher
order functions
higher order, 37, 38, 238–244,
257
literal; seeclosures
optional parameters, 222–223
parameters, 220–223, 254–255
pure, 241; see also memoizing
recursive, 227–230, 247, 307
references to, 92, 110, 112, 140,
148, 223, 226, 230–231, 242,
310
variadic, 198, 219, 221–222
wrapper, 218, 226
see also built-in functions and
special functions
FuzzyBool (example), 282–288
G
Gamma()(mathpackage), 66
garbage collector, 3, 32, 40, 139, 141
gc(tool), 9
gccgo(tool), 9
generic functions, 232–238; see also
higher order functions
Gerrand, Andrew, 2, 207Getgid() (ospackage), 401
getters, 264–265
Getuid() (ospackage), 401
GID; seeGetgid()
Glob()(filepath package), 176, 410
globbing, ﬁle, 176, 410–411
Go
building programs, 11–13
comments, 14, 51
Dashboard, 2
documentation, 8
downloading, 9
history of, 1
identiﬁers, 9, 42, 52–53, 58; see
alsoblank identiﬁer
installing, 9, 10–11
shebang ( #!) scripts, 10
source code encoding, 9
speciﬁcation, 69
go build(tool), 11–12, 23, 409, 411
.goﬁles, 84, 408, 410
go fix(tool), 418
go get(tool), 417–418
go install (tool), 1, 13, 409
go(statement), 45, 206, 208, 209,
211, 224, 320–357; see also gor-
outines
go test(tool), 415–416
go version (tool), 11
go vet(tool), 418
GOARCH(constant; runtimepackage),
410, 424
.gobﬁles, 385–387
gob(package; encoding package), 385
GobDecoder (interface), 386
GobEncoder (interface), 386
NewDecoder() , 386
NewEncoder() , 385
godashboard.appspot.com (web site),
407, 417, 423, 426
godoc(tool), 8, 411–413, 419
gofmt(tool), 186, 188, 419
golang.org (web site), 8, 436
Index 455
GOMAXPROCS() (runtimepackage), 327
gonow(third-party tool), 10
Google, 1–2
App Engine, 2, 435
GOOS(constant; runtimepackage), 43,
176, 399, 410, 424
GOPATH(environment variable), 8, 13,
23, 408, 409, 410, 411, 417, 418
GOROOT(environment variable), 8, 10,
11, 23, 408, 410, 418, 424
GOROOT() (runtimepackage), 424
goroutines, 3, 41, 45, 206–212,
318–357
gorun(third-party tool), 10
goto(statement), 205
greedy matching in regular expres-
sions, 123, 127
Griesemer, Robert, 1
grouping constants, imports, and
variables, 54
grouping in regular expressions,
123
guard, type switch, 198, 199
guess_separator (example), 171–174
gzip(package; compress package),
400
NewReader() , 403
NewWriter() , 400
Reader(type), 403
Writer(type), 400
H
HandleFunc() (httppackage), 75, 218
handling errors, 24, 32, 213
hash table; seemaptype
HasPrefix() (stringspackage), 108,
132, 194, 246, 260, 382
HasSuffix() (stringspackage), 108,
131–132, 226, 400, 403
Header(constant; xmlpackage), 373
Header(type; tarpackage), 401, 404
heap(package; container package),
421–422hello(example), 14–16
hexadecimal number, formatting as,
98, 102
higher order functions, 37, 38,
238–244, 257
history, of Go, 1
Hoare, C. A. R, 3
html(package)
EscapeString() , 78
template (package), seetop-level
entry
HTMLEscape() (template package), 78
http(package; netpackage)
HandleFunc() , 75, 218
ListenAndServe() , 75
Request(type); seetop-level entry
ResponseWriter (interface), 76
Humanize() (example), 100
Hyphen(constant; unicodepackage),
272
Hypot()(mathpackage), 66, 304
I
identiﬁers, Go, 9, 42, 52–53, 58; see
alsoblank identiﬁer
IEEE-754 ﬂoating-point format, 64
if(statement), 15, 189, 192–194,
220; see also switchstatement
Ilogb()(mathpackage), 66
imag()(built-in), 70, 101, 187
Image(interface)
drawpackage, 290, 293, 319
imagepackage, 289, 293, 319
image(package), 289, 425
DecodeConfig() , 358
draw(package), 290
Image(interface), 289, 293, 319
jpeg(package), 293
NewRGBA() , 290, 319
png(package), 293
RGBA(type), 290
Uniform() , 290
456 Index
image(package) (continued)
ZP(zero Point), 290
imagetag (exercise), 358
imaginary numbers; seecomplex128
type and imag()
immutability, of strings, 84
import paths, 23
import(statement), 14, 15, 358, 409,
416–417, 418
indent_sort (example), 244–249
Index()
reflectpackage, 235, 236, 428
stringspackage, 92, 103, 108,
133, 134, 383
index operator; see[]index and slice
operator
IndexAny() (stringspackage), 108,
133, 134
IndexFunc() (stringspackage), 92,
93, 108
indexing slices, 153–154
indexing strings, 20, 90–93
IndexRune() (stringspackage), 108
indirection; seepointers and *deref-
erence operator
Inf()
cmplxpackage, 71
mathpackage, 66
inferred type, 53, 70
inﬁnite channel, 208
inﬁnite loop, 24, 203, 208; see also
forloop
inheritance, 240, 294, 300, 436
.iniﬁle to map(exercise), 181
.iniﬁles, 131, 181–182
init()(special function), 43, 215,
224–225, 231–232, 241, 242,
243, 290, 417
initializing, 27
slices, 17
variables, 15, 74
input/output (I/O); seeFiletype and
fmtpackageInsertStringSlice() (example), 158
InsertStringSliceCopy() (example),
157–158
installing Go, 9, 10–11
instances; seevalues
Int(type; bigpackage), 57, 61–64
Add(), 63
Div(), 63
Exp(), 63
Mul(), 63
Sub(), 63
int(type; built-in), 55, 57, 58, 59–61,
69, 116, 117, 188, 208, 215, 237,
318, 390, 394
comparisons, 57
conversion from int64, 63
conversion to float64, 61, 69
conversion to string, 85
formatting, 98–99
literals, 53, 58
see also strconvpackage
Int()(Valuetype), 428, 430
int8(type; built-in), 60, 391, 395
int16(type; built-in), 60, 392
int32(type;built-in), 59, 60, 388, 390,
395; see also runetype
int64(type;built-in), 60, 61, 116, 117,
215, 241, 356, 391, 401, 430
conversion from int, 63
integer literals, 53, 58
integers; seeintand similar types
and Intand Rattypes
Interface (interface; sortpackage),
161, 162, 246, 249, 421
interface (keyword), 220, 237,
265–274, 294, 295, 335, 364
interface{} , 24, 27, 150, 165, 191,
192, 197, 198, 199, 220, 234,
235, 237, 241, 242, 243, 255,
265, 284, 303, 337, 378, 388, 389,
421–423
Interface() (reflectpackage), 235
Index 457
interfaces, 22, 202, 255, 265–274,
301, 319
see also Image,Interface ,Reader,
ReaderWriter ,ResponseWriter ,
Stringer, and Writerinter-
faces
interpreted string literals, 83
Intn()(randpackage), 209, 426
introspection; seereflectpackage
Ints()(sortpackage), 161, 180
IntsAreSorted() (sortpackage), 161
inversion, map, 170–171, 179
invoicedata (example), 362–397
invoicedata (exercise), 406
io(package), 30, 34, 424
Copy(), 353, 354, 399, 401, 402,
405
EOF, 34, 35, 37, 113, 177, 268, 333,
343, 381, 404
Pipe(), 322
ReadCloser (interface), 403
Reader(interface), 32, 34, 35, 255,
268, 269–270, 364, 365, 369,
375, 380, 384, 386, 392, 393
ReaderWriter (interface), 32
WriteCloser (interface), 400
Writer(interface), 32, 34, 35, 93,
255, 354, 364, 366, 373, 378,
385, 388, 399
iota(keyword), 54, 336
ioutil(package; iopackage), 30,
424
ReadAll() , 424
ReadFile() , 38, 131–132, 424
TempFile() , 424
WriteFile() , 424
Is()(unicodepackage), 118, 119, 258,
272
IsControl() (unicodepackage), 119
IsDigit() (unicodepackage), 119
IsGraphic() (unicodepackage), 119
IsInf()
cmplxpackage, 71
mathpackage, 66IsLetter() (unicodepackage), 119,
178
IsLower() (unicodepackage), 119
IsMark() (unicodepackage), 119
IsNaN()
cmplxpackage, 71
mathpackage, 66
IsOneOf() (unicodepackage), 119
IsPalindrome() (exercise), 250
IsPrint() (strconvpackage), 114
IsPrint() (unicodepackage), 119
IsPunct() (unicodepackage), 119
IsSorted() (sortpackage), 161
IsSpace() (unicodepackage), 92, 111,
119, 272
IsSymbol() (unicodepackage), 119
IsTitle() (unicodepackage), 119
IsUpper() (unicodepackage), 119
IsValid() (Valuetype), 430
iterating; seeforloop and range
iterating arrays, 203
iterating channels, 203
iterating maps, 170, 203
iterating slices, 154–156, 203
iterating strings, 88–90, 203
Itoa()(strconvpackage), 85, 114,
117
J
J0()(mathpackage), 66
J1()(mathpackage), 66
JavaScript Object Notation; see
JSON
Jn()(mathpackage), 66
Join()(stringspackage), 14, 16, 55,
108, 111, 180, 414
.jpegand .jpgﬁles, 293
jpeg(package; imagepackage), 293
JSON (JavaScript Object Notation),
199–202, 363, 365–371
json(package; encoding package),
202, 366
458 Index
json(package; encoding package)
(continued)
Decoder(type); seetop-level entry
Encoder(type); seetop-level entry
Marshal() , 368, 370
NewDecoder() , 369
NewEncoder() , 367
Unmarshal() , 199, 201, 202, 369,
370
justiﬁcation, of output, 96, 98
K
keywords, 52
case;seeselectand switchstate-
ments
chan, 43, 44, 208, 209, 210,
318–357; see also channels
const, 45, 53, 58, 133, 336, 364,
379, 390
default;seeselectand switch
statements
else;seeifstatement
func, 14, 15, 25, 35, 45, 55, 208,
216, 218, 219, 223, 226, 232,
238, 240, 241, 243, 246, 291,
303, 305, 323, 324, 343, 378,
379, 388, 389, 413
interface , 220, 237, 265–274, 294,
295, 335, 364
iota, 54, 336
nil, 27, 216, 257, 305
range, 19, 38, 39, 74, 89, 110, 147,
154, 155, 168, 170, 172, 200,
203–205, 324, 325, 330, 331,
339, 343, 355, 390
struct, 42, 73, 96, 104, 132, 167,
199, 202, 222, 223, 233, 237,
241, 245, 255, 259–260,
261–262, 275–282, 284, 285,
305, 308, 326, 328, 330, 335,
337, 343, 350, 354, 362, 366,
372, 387type, 24, 42, 55, 73, 132, 198–199,
202, 223, 245, 246, 254, 255,
256–257, 265, 284, 294, 295,
305, 335, 366, 379, 389, 412
var, 23, 53, 188, 192, 201, 241,
257, 272, 378, 382, 388
see also statements
Kind(type; reflectpackage), 430
Kind()(Valuetype), 235
L
label, 205, 331
LastIndex() (stringspackage), 92,
108, 194
LastIndexAny() (stringspackage),
108
LastIndexFunc() (stringspackage),
92, 108
Ldexp()(mathpackage), 66
left-justiﬁcation, of output, 96, 98
left-leaning red-black tree; seeomap
example
len()(built-in), 15, 20, 24, 27, 69, 85,
90, 148, 149, 151, 152, 157, 159,
165, 169, 187, 340
Len()(reflectpackage), 235, 430
Lgamma() (mathpackage), 66
library types; seestandard library’s
types
linear vs. binary search, 162–163
linefeed; seenewline
linkcheck (exercise), 432
linkutil (exercise), 431–432
list(package; container package),
422–423
ListenAndServe() (httppackage), 75
LiteralPrefix() (Regexptype), 125
literals, 58
character, 20
complex, 53, 70
composite, 18, 45, 150, 152, 153,
166, 167
Index 459
ﬂoating point, 53; see also float64
type
function; seeclosures
integer, 53; see also intand simi-
lar types
string, 75, 83
LittleEndian (variable; binarypack-
age), 388
Ln2(constant; mathpackage), 66
Ln10(constant; mathpackage), 66
local variables, 40, 45, 141
Lock()(RWMutextype), 346
Log()
cmplxpackage, 71
mathpackage, 66
log(package), 426
Fatal(), 19, 20, 32, 131–132, 342
Fatalf(), 20, 327
Printf(), 134, 217, 291
Println() , 176, 177, 353
SetFlags() , 426
SetOutput() , 426
Log2E(constant; mathpackage), 66
Log10()
cmplxpackage, 71
mathpackage, 66
Log10E(constant; mathpackage), 66
Log1p()(mathpackage), 66
Log2()(mathpackage), 66
Logb()(mathpackage), 66
logic, short circuit, 56
logical operators; see!,&&,^, and ||
operators
logPanics() (example), 218
lookups, map, 39, 168–169, 231
looping; seeforloop
M
.m3uﬁles, 130–135
m3u2pls(example), 130–135
main(package), 14, 15, 206, 224main()(special function), 14, 15, 206,
214, 215, 224–225, 327
make()(built-in), 26, 38, 39, 43, 44,
127, 129, 150, 151, 152, 157, 159,
165, 172, 176, 178, 179, 187, 207,
208, 209, 211, 240, 242, 246, 247,
323, 324, 328, 337, 339, 341, 346,
348, 355, 374, 392, 393, 395, 410
Make2D() (exercise), 181
Map()(stringspackage), 108,
111–112, 132, 133, 258
mapto.iniﬁle (exercise), 182
map(type; built-in), 38, 39, 77, 127,
146, 164–171, 175–180, 199,
242, 243, 298, 318, 335, 339, 345,
346, 348, 355, 356
accessing, 39, 168–169, 231
formatting, 106
inversion, 170–171, 179
iterating, 170, 203
modifying, 169
multivalued, 175
operations, 165
see also omapexample
Marshal() (jsonpackage), 368, 370
Match()
regexppackage, 121
Regexptype, 125, 333, 334
MatchReader()
regexppackage, 121
Regexptype, 125
MatchString()
regexppackage, 121
Regexptype, 125
math(package), 69
Abs(), 65, 68
Acos(), 65
Acosh(), 65
Asin(), 65
Asinh(), 65
Atan(), 65
Atan2(), 65
Atanh(), 65
460 Index
math(package) (continued)
big(package); seetop-level entry
Cbrt(), 65
Ceil(), 65
cmplx(package), seetop-level en-
try
Copysign() , 65
Cos(), 45, 65
Cosh(), 65
Dim(), 65
E(constant), 65, 104, 105
Erf(), 65
Erfc(), 65
Exp(), 65
Exp2(), 65
Expm1(), 65
Float32bits() , 65
Float32frombits() , 65
Float64bits() , 65
Float64frombits() , 65
Floor(), 66
Frexp(), 66
Gamma(), 66
Hypot(), 66, 304
Ilogb(), 66
Inf(), 66
IsInf(), 66
IsNaN(), 66
J0(), 66
J1(), 66
Jn(), 66
Ldexp(), 66
Lgamma(), 66
Ln2 (constant) , 66
Ln10 (constant) , 66
Log(), 66
Log2E (constant) , 66
Log10(), 66
Log10E (constant) , 66
Log1p(), 66
Log2(), 66
Logb(), 66
Max(), 66MaxInt32 (constant), 69, 215, 239
MaxUint8 (constant), 58
Min(), 66, 68
MinInt32 (constant), 69, 215
Mod(), 66, 68
Modf(), 67, 68, 69, 70, 100
NaN(), 67, 68
Nextafter() , 67, 68
Phi(constant), 67, 105
Pi(constant), 45, 67, 105
Pow(), 67
Pow10(), 67
rand(package), seetop-level en-
try
Remainder() , 67
Signbit() , 67
Sin(), 45, 67
SinCos(), 67
Sinh(), 67
SmallestNonzeroFloat64 (con-
stant), 68
Sqrt(), 67, 221
Sqrt2(constant), 67
SqrtE(constant), 67
SqrtPhi(constant), 67
SqrtPi(constant), 67
Tan(), 67
Tanh(), 67
Trunc(), 67
Y0(), 67
Y1(), 67
Yn(), 67
Max()(mathpackage), 66
maximum characters to output, 96,
103
MaxInt32 (constant; mathpackage),69,
215, 239
MaxRune(constant; unicodepackage),
82
MaxUint8 (constant; mathpackage),
58
Memoize() (example), 242–244
memoizing, 241–244
Index 461
memory management; seegarbage
collection
method expressions, 263
method sets, 22, 191, 260
MethodByName() (Valuetype), 430
methods, 29, 255, 258–265, 277–278
deﬁning, 25
Error(), 31
overriding, 261–262
String(), 31, 55, 96, 103, 155, 166,
260, 265, 266–267, 286
Min()(mathpackage), 66, 68
minimum ﬁeld width, 96, 103
MinInt32 (constant; mathpackage),
69, 215
MkdirAll() (ospackage), 401, 402,
404
Mod()(mathpackage), 66
Mode()(FileInfo interface), 351, 401
ModeType (constant; ospackage), 351,
352
Modf()(mathpackage), 67, 69, 70, 100
modifying maps, 169
modifying slices, 147, 156–160
ModTime() (FileInfo interface), 401
Mul()(Inttype), 63
multidimensional arrays, 148
multidimensional slices, 17–18, 150,
204–205
multiple assignments, 31, 188
multivalued maps, 175
MustCompile() (regexppackage), 35,
37, 121, 126, 214, 343, 348
MustCompilePOSIX() (regexppackage),
121
mutability, of arrays, 149
mutability, of slices, 140
mutual recursion, 227, 228–229
N
Name(type; xmlpackage), 372, 374
named ﬁelds; seestructkeywordnamed replacements in regular ex-
pressions, 126
named return values, 36, 189, 212,
219, 221, 309
named vs. unnamed custom types,
22
NaN()
cmplxpackage, 71
mathpackage, 67
net(package), 427
http(package), seetop-level en-
try
rpc(package), 427
smtp(package), 427
url(package), 427
New()
errorspackage, 27, 33, 194, 384
sha1package, 353, 354
new()(built-in), 145, 146, 152, 187,
346
NewDecoder()
gobpackage, 386
jsonpackage, 369
xmlpackage, 375
NewEncoder()
gobpackage, 385
jsonpackage, 367
xmlpackage, 373
NewInt() (bigpackage), 63
newline ( \n), 51, 84
NewReader()
bufiopackage, 35, 45, 176, 333,
380
gzippackage, 403
stringspackage, 108
tarpackage, 403
NewReplacer() (stringspackage), 108
NewRGBA() (imagepackage), 290, 319
NewTicker() (timepackage), 426
NewWriter()
bufiopackage, 35, 378
gzippackage, 400
tarpackage, 400
462 Index
NewWriter() (continued)
zippackage, 398
Nextafter() (mathpackage), 67
nil(keyword), 27, 216, 257, 305
nonblocking, channel, 207, 209; see
alsochannels
nongreedy matching in regular ex-
pressions, 123, 127
normalization, of whitespace, 111
normalization, Unicode, 86
not, logical; see!operator
null; seenil
number formatting, 98–101
numbers; seefloat64,int, and other
speciﬁc numeric types
NumCPU() (runtimepackage), 327, 328
NumGoroutine() (runtimepackage),
351, 353
NumSubexp() (Regexptype), 125
O
O_RDWR(constant; ospackage), 397
objects; seevalues
octal number, formatting as, 98
Ogg container, 130
omap(example), 302–310, 409,
412–413, 414–416
Open()(Filetype), 31, 176, 212, 333,
342, 353, 398, 400
OpenFile() (Filetype), 31, 397
OpenReader() (zippackage), 401, 402
operations on maps, 165
operations on slices, 151
operators
!logical NOT, 57
!=inequality, 56–57, 68–69, 70,
164
%modulus and formatting place-
holder, 47, 60, 69; see also for-
mat speciﬁer
%=augmented modulus, 60&address of and bitwise AND, 45,
46, 55, 60, 142, 143, 144, 167,
246, 247, 248, 267, 269, 284,
382, 383, 384, 387, 393, 394,
395
&&logical AND, 56, 57
&=augmented bitwise AND, 60
&^bitwise clear, 60
&^=augmented bitwise clear, 60
*multiplication, dereference,
pointer declaration and for-
matting placeholder, 26, 59,
69, 96, 100, 142, 143, 144,
178, 247, 248, 249, 259, 284,
305, 370, 382, 394
*=augmented multiplication, 59,
147
+addition, concatenation, and
unary plus, 20, 59, 85, 226
++increment, 20, 59, 186, 188
+=augmented addition and
string append, 20, 59, 84, 85,
88, 140
-subtraction and unary minus,
59
--decrement, 20, 59, 186, 188
-=augmented subtraction, 59
.selector, 148, 275
...ellipsis, 149, 156, 158, 160,
176, 219, 221, 222, 233, 242,
268, 287, 378
/division, 59
/=augmented division, 59
:=short variable declaration, 15,
18, 36, 53, 140, 188, 189, 198,
203
<less than comparison, 56–57
<-send/receive communication,
44, 45, 207, 210, 318–357
<<bitwise shift left, 55, 60
<<=augmented bitwise shift left,
60
<=less than or equal comparison,
56–57
Index 463
=assignment, 16, 18, 36, 188,
212
==equality, 56–57, 68–69, 70,
164
>greater than comparison,
56–57
>=greater than or equal compari-
son, 56–57
>>bitwise right shift, 60
>>=augmented bitwise right
shift, 60
[]index and slice, 15, 28, 85, 91,
203, 242, 339, 355, 357, 393
^bitwise XORand complement,
60
^=augmented bitwise XOR, 60
|bitwise OR, 55, 60
|=augmented bitwise OR, 60
||logical OR, 56, 57, 178
overloading, 61
optional parameters, 222–223
optional statement, 193, 195, 198,
203
or, logical; see||operator
order of declarations and deﬁnitions,
21
ordered comparisons ( <,<=,>=,>),
56–57
ordered map; seeomapexample
os(package), 423
Args(slice), 14, 15, 17, 19,
131–132, 232
exec(package), seetop-level en-
try
Exit(), 19, 20, 32, 131–132, 327
File(type); seetop-level entry
FileInfo (interface), seetop-level
entry
Getgid(), 401
Getuid(), 401
MkdirAll() , 401, 402, 404
ModeType (constant), 351, 352
O_RDWR(constant), 397
Stderr(stream), 20, 32, 46Stdin(stream), 31, 32
Stdout(stream), 31, 32, 46, 94,
131
oslice(exercise), 313–314
overloading, 258
overloading, operator, 61
overriding methods, 261–262
P
pack(example), 397–405
package, 14, 215–216, 407–431
aliasing names, 409, 418
collection, 421–423; see also con-
tainerpackage
custom, 24–29, 408–417
documenting, 411–413
main, 14, 15
third-party, 417–418
variables, 18
see also bufio,bytes,cmplx,con-
tainer,crypto,draw,encoding,
errors,filepath,fmt,http,im-
age,io,ioutil,json,math,net,
os,rand,regexp,reflect,run-
time,sha1,sort,strings,sync,
and timepackages
package(statement), 408, 412
Pad()(example), 99
padding, of output, 96, 98
palindrome (example), 232
panic()(built-in), 32, 69, 70, 113,
187, 191, 196, 213–218, 219, 220,
243
parameters, 22, 141–142, 220–223,
254–255
Parse()(timepackage), 370, 376, 377,
383, 395
ParseBool() (strconvpackage), 98,
115, 116
ParseFloat() (strconvpackage), 77,
115, 116
ParseForm() (Requesttype), 76
464 Index
ParseInt() (strconvpackage), 115,
116
ParseUInt() (strconvpackage), 115,
116
patents, software, 437–439
PATH(environment variable), 10
path, import, 23
path(package), 424
path/filepath package; seefilepath
package
Phase()(cmplxpackage), 9
Phi(constant; mathpackage), 67, 105
Pi(constant; mathpackage), 45, 67,
105
pi_by_digits (example), 62–64
Pike, Rob, 1, 385, 431
Pipe()(iopackage), 322
placeholder ( %,*);see%,Printf(), and
Sprintf() ;see also blank identi-
ﬁer
plain text ﬁles; see.txtﬁles
platform-speciﬁc code, 410–411
playlists (excercise), 135–136
.plsﬁles, 130–135
.pngﬁles, 293
png(package; imagepackage), 293
pointers, 26, 27, 28, 29, 139, 141–148,
152, 167, 247–248, 260, 267, 285,
318, 362, 369
formatting, 96, 104
Polar()(cmplxpackage), 9
polar2cartesian (example), 40–47
polymorphism, 198
Porter-Duff image compositing, 290
Pow()
cmplxpackage, 71
mathpackage, 67
Pow10()(mathpackage), 67
predeﬁned identiﬁers, 52
Print()(fmtpackage), 94, 96
Printf()
fmtpackage, 19, 47, 94–106, 113,
178, 192logpackage, 134, 217, 291
Println()
fmtpackage, 19, 24, 45, 53, 72,
94–106
logpackage, 176, 177, 353
private; seeunexported identiﬁers
ProbablyPrime() (bigpackage), 425
public; seeexported identiﬁers
pure functions, 241; see also memo-
izing
Q
quadratic (exercise), 79
quantiﬁers in regular expressions,
123
Quote()(strconvpackage), 115, 117
QuoteMeta() (regexppackage), 121,
128
QuoteRune() (strconvpackage), 115
QuoteRuneToASCII() (strconvpack-
age), 115
quotes; see" "double quotes and raw
strings
R
rand(package)
cryptopackage, 426
mathpackage, 426
Intn(), 209, 426
range(keyword), 19, 38, 39, 74, 89,
110, 147, 154, 155, 168, 170, 172,
200, 203–205, 324, 325, 330, 331,
339, 343, 355, 390
Rat(type; bigpackage), 57, 61
rationals; seeRattype
raw string ( ``), 75, 96
RE2 regular expression engine; see
regexppackage
Read()(binarypackage), 391, 393,
395
ReadAll() (ioutilpackage), 424
ReadAt() (Filetype), 397
Index 465
ReadBytes() (Readertype), 333, 334
ReadCloser (interface; iopackage),
403
ReadCloser (type; zippackage), 401
Readdir() (Filetype), 361
Readdirnames() (Filetype), 361
Reader(interface; iopackage), 32, 34,
35, 255, 268, 269–270, 364, 365,
369, 375, 380, 384, 386, 392, 393
Reader(type)
bufiopackage, 35, 38, 177
ReadBytes() , 333, 334
ReadString() , 35, 37, 45, 177,
343, 381
gzippackage, 403
stringspackage, 113
tarpackage, 403, 405
ReaderWriter (interface; iopackage),
32
ReadFile() (ioutilpackage), 38,
131–132
reading ﬁles; seeFiletype and ioutil
package
ReadRune() (Buffertype), 113
ReadString() (Readertype), 35, 37, 45,
177, 343, 381
real()(built-in), 70, 101, 187
real numbers; seefloat64and com-
plex128types and real()
receive, channel; seechannels, <-op-
erator, and chankeyword
receiver, 25, 28, 258, 261, 266, 267,
269, 277, 367
recover() (built-in), 32, 187,
213–218
Rect()(cmplxpackage), 9
recursion, mutual, 227, 228–229
recursive functions, 227–230, 247,
307
red-black tree; seeomapexample
references, 26, 27, 39, 92, 110, 112,
140, 141, 146, 148, 150, 153, 223,
226, 230–231, 242, 310, 318reflect(package), 235–236,
427–431
DeepEqual() , 57, 236, 427
Kind(type), 430
Slice(constant), 235
TypeOf(), 427, 428, 430
Value(type); seetop-level entry
ValueOf() , 235, 427, 428, 429, 430
regexp(package), 36, 120–129, 214
assertions, zero-width, 122
character classes, 122
Compile() , 37, 121, 214, 327
CompilePOSIX() , 121
escapes, 121
ﬂags, 123
greedy and nongreedy matching,
123, 127
grouping, 123
Match(), 121
MatchReader() , 121
MatchString() , 121
MustCompile() , 35, 37, 121, 126,
214, 343, 348
MustCompilePOSIX() , 121
quantiﬁers, 123
QuoteMeta() , 121, 128
Regexp(type); seetop-level entry
zero-width assertions, 122
Regexp(type; regexppackage), 35, 37,
318, 328, 344
Expand(), 124
ExpandString() , 124
Find(), 124
FindAll() , 124
FindAllIndex() , 124
FindAllString() , 124, 127
FindAllStringIndex() , 124
FindAllStringSubmatch() , 124, 127
FindAllStringSubmatchIndex() ,
124, 128
FindAllSubmatch() , 124
FindAllSubmatchIndex() , 124
FindIndex() , 124
466 Index
Regexp(type; regexppackage) (contin-
ued)
FindReaderIndex() , 124
FindReaderSubmatchIndex() , 124
FindString() , 124
FindStringIndex() , 124
FindStringSubmatch() , 124, 127,
343, 344, 348
FindStringSubmatchIndex() , 124
FindSubmatch() , 125
FindSubmatchIndex() , 125
LiteralPrefix() , 125
Match(), 125, 333, 334
MatchReader() , 125
MatchString() , 125
NumSubexp() , 125
ReplaceAll() , 120, 125
ReplaceAllFunc() , 125
ReplaceAllLiteral() , 125
ReplaceAllLiteralString() , 125,
128–129
ReplaceAllString() , 120, 125, 126,
129
ReplaceAllStringFunc() , 35,
36–37, 125, 129, 359
String(), 125
SubexpNames() , 125
Remainder() (mathpackage), 67
remote procedure call (RPC), 427
RemoteAddr (ﬁeld; Requesttype), 217
RemoveStringSlice() (example), 160
RemoveStringSliceCopy() (example),
159–160
Repeat() (stringspackage), 48, 99,
108, 243, 246
Replace() (stringspackage), 76, 77,
109, 110, 399
ReplaceAll() (Regexptype), 120, 125
ReplaceAllFunc() (Regexptype), 125
ReplaceAllLiteral() (Regexptype),
125
ReplaceAllLiteralString() (Regexp
type), 125, 128–129ReplaceAllString() (Regexptype),
120, 125, 126, 129
ReplaceAllStringFunc() (Regexptype),
35, 36–37, 125, 129, 359
replacement character, Unicode
(U+FFFD), 85, 118
replacements, $in regular expres-
sions, 120, 126, 129
reporting errors; seeerror handling
Request(type; httppackage), 76
Form(ﬁeld), 76
ParseForm() , 76
RemoteAddr (ﬁeld), 217
ResponseWriter (interface; httppack-
age), 76
return(statement), 28, 34, 70, 186,
189, 194, 219, 220, 240, 309
return values, 24, 28, 31, 33, 40, 45,
53, 145, 189, 219
bare, 34, 189, 219
named, 36, 212, 221, 309
unnamed, 190
RGBA(colortype), 147
RGBA(imagetype), 290
right-justiﬁcation, of output, 96, 98
ring(package; container package),
423
RLock()(RWMutextype), 346
RomanForDecimal() (example),
243–244
rpc(package; netpackage), 427
rune(type; built-in), 59, 60, 82, 83,
87–90, 104, 190, 230, 246, 420
conversion to string, 87–88,
89–90, 91, 246, 272
formatting, 96, 99
literal, 84
see also int32and stringtypes
RuneCount() (utf8package), 118
RuneCountInString() (utf8package),
85, 99, 177, 178, 229
RuneLen() (utf8package), 118
Index 467
RuneStart() (utf8package), 118
RUnlock() (RWMutextype), 346
runtime(package), 424
Caller(), 291
FuncForPC() , 291, 292
GOARCH(constant), 410, 424
GOMAXPROCS() , 327
GOOS(constant), 43, 176, 399, 410,
424
GOROOT(), 424
NumCPU(), 327, 328
NumGoroutine() , 351, 353
Version() , 424
runtime system, Go’s, 32
RWMutex(type; syncpackage), 345,
346
Lock(), 346
RLock(), 346
RUnlock() , 346
Unlock(), 346
S
safemap(example), 334–340
safeslice (exercise), 357–358
Scan()(fmtpackage), 383
Scanf()(fmtpackage), 383
Scanln() (fmtpackage), 383
scientiﬁc notation, 64, 101
scope, 141, 225, 239, 240
scoping problem; seeshadow vari-
ables
Search() (sortpackage), 161, 163
SearchFloat64s() (sortpackage), 161
searching, slices, 162–164
searching, strings, 87
SearchInts() (sortpackage), 161
SearchStrings() (sortpackage), 161
Seek()(Filetype), 397
select(statement), 209–212, 321,
331, 333
self;seereceiver
semicolon ( ;), 15, 186send,channel; seechannels, <-opera-
tor, and chankeyword
Separator (constant; filepath pack-
age), 134, 135
serialized access, 318–319, 335, 341
SetFlags() (logpackage), 426
SetInt() (Valuetype), 429
SetOutput() (logpackage), 426
SetString() (Valuetype), 428
setters, 264–265
SHA-1 (Secure Hash Algorithm),
349, 354–53
sha1(package; cryptopackage)
New(), 353, 354
Size(constant), 355
shadow variables, 36, 189, 192, 200,
201, 281, 282, 300, 301
shaper(example), 289–301
shaper(exercise), 311–313
shebang ( #!) scripts, 10
short circuit logic, 56
short variable declaration, 15, 53,
140, 188
Signbit() (mathpackage), 67
Simple Mail Transport Protocol
(SMTP), 427
simple statement, 193, 195, 203
SimpleFold() (unicodepackage), 119
simpliﬁcation, of whitespace, 111,
128–129
SimplifyWhitespace() (example), 111
Sin()
cmplxpackage, 71
mathpackage, 45, 67
SinCos() (mathpackage), 67
Sinh()
cmplxpackage, 71
mathpackage, 67
Size(constant; sha1package), 355
Size()(FileInfo interface), 351, 353,
401
sizeimages (exercise), 359
468 Index
Slice(constant; reflectpackage),
235
slice operator; see[]index and slice
operator
SliceIndex() (example), 238–239
slices, 17, 140, 146–147, 149–164,
232, 234, 318
formatting, 101–103
indexing, 153–154
initializing, 17
iterating, 154–156, 203
modifying, 147, 156–160
multidimensional, 17–18, 150,
204–205
mutability, 140
operations on, 151
searching, 162–164
slicing, 153–154
sorting, 160–164
see also under types, e.g., byte
for[]byteand stringfor
[]string
slicing, slices, 153–154
slicing, strings, 90–93
SmallestNonzeroFloat64 (constant;
mathpackage), 68
smtp(package; netpackage), 427
sockets; seenetpackage
software patents, 437–439
sort(package), 160–164, 246
Float64s() , 73, 161
Float64sAreSorted() , 161
Interface (interface), 161, 162,
246, 249, 421
Ints(), 161, 180
IntsAreSorted() , 161
IsSorted() , 161
Search(), 161, 163
SearchFloat64s() , 161
SearchInts() , 161
SearchStrings() , 161
Sort(), 161, 162, 248, 249Strings() , 160, 161, 163, 170, 178,
180, 356
StringsAreSorted() , 161
Sort()(sortpackage), 161, 162, 248,
249
sorted map; seeomapexample
sorting, slices, 160–164
sorting, strings, 87
soundex(exercise), 136–137
source code encoding, Go, 9
special functions
init(), 43, 215, 224–225,
231–232, 241, 242, 243, 290,
417
main(), 14, 15, 206, 214, 215,
224–225, 327
see also built-in functions and
functions
speciﬁcation, Go, 69
Split()(stringspackage), 38, 39,
107, 109, 132, 133, 422
SplitAfter() (stringspackage), 107,
109
SplitAfterN() (stringspackage), 107,
109
SplitN() (stringspackage), 39, 107,
109
Sprint() (fmtpackage), 94, 99, 178,
242, 357
Sprintf() (fmtpackage), 43, 55, 69,
78, 85, 94, 97, 100, 101, 242, 286,
355
Sprintln() (fmtpackage), 94
sql(package; database package), 423
Sqrt()
cmplxpackage, 71
mathpackage, 67
Sqrt2(constant; mathpackage), 67
SqrtE(constant; mathpackage), 67
SqrtPhi(constant; mathpackage), 67
SqrtPi(constant; mathpackage), 67
Sscan()(fmtpackage), 383
Sscanf() (fmtpackage), 45, 46, 382,
383
Index 469
Sscanln() (fmtpackage), 383
stack trace, 214
stacker(example), 21–29, 408–409
standard library, 419–431
types; seeFile,Int,Rat,Reader,
Regexp, and Writer
startup, application; seeentry point
statcall;seeFileInfo interface
Stat()(Filetype), 397, 398, 399, 400
statements
break, 24, 177, 186, 204, 205, 331
continue, 132, 133, 186, 204, 205,
324
defer, 31–32, 35, 36, 44, 176,
211–213, 216, 218, 333, 343,
353, 378, 398, 400
fallthrough , 186, 195, 196–197
forloop, 19, 23, 24, 38, 39, 74,
89, 110, 132, 147, 154, 155,
168, 170, 172, 177, 186, 200,
203–205, 320, 321, 324, 325,
330, 331, 339, 343, 355, 390
go, 45, 206, 208, 209, 211, 224,
320–357; see also goroutines
goto, 205
if, 15, 189, 192–194, 220; see also
switchstatement
import, 14, 15, 358, 409, 416–417,
418
optional, 193, 195, 198, 203
package, 408, 412
return, 28, 34, 70, 186, 189, 194,
219, 220, 240, 309
select, 209–212, 321, 331, 333
simple, 193, 195, 203
switch, 110, 129, 174, 195–202,
220, 233, 235, 282, 285, 365;
see also ifstatement
terminator, ( ;), 186
see also keywords
statistics (example), 72–78
statistics (exercise), 79
statistics_nonstop (example),
216–218Stderrstream ( ospackage), 20, 32,
46
Stdinstream ( ospackage), 31, 32, 46
Stdoutstream ( ospackage), 31, 32,
94, 131
strconv(package), 113–117
AppendBool() , 114
AppendFloat() , 114
AppendInt() , 114
AppendQuote() , 114
AppendQuoteRune() , 114
AppendQuoteRuneToASCII() , 114
AppendUInt() , 114
Atoi(), 116, 134, 390
CanBackquote() , 114
FormatBool() , 114, 116
FormatFloat() , 114
FormatInt() , 114, 117
FormatUInt() , 114
IsPrint() , 114
Itoa(), 85, 114, 117
ParseBool() , 98, 115, 116
ParseFloat() , 77, 115, 116
ParseInt() , 115, 116
ParseUInt() , 115, 116
Quote(), 115, 117
QuoteRune() , 115
QuoteRuneToASCII() , 115
Unquote() , 115, 117
UnquoteChar() , 115
see also conversions
String()
Buffertype, 88, 200, 243
Regexptype, 125
Valuetype, 428, 429
String() (method), 31, 55, 96, 103,
155, 166, 260, 265, 266–267,
286
string(type; built-in), 20, 81–129,
140, 190, 238, 318
comparisons, 57, 84, 86–87
concatenation; see+and +=oper-
ators
concatenation, fast, 88
470 Index
string(type; built-in) (continued)
conversion from []byte, 38, 85,
164, 334, 373, 395
conversion from []rune, 85, 91
conversion from float64;see
ParseFloat()
conversion from rune, 89–90, 246
conversion to []byte, 85, 89–90,
164, 391
conversion to []rune, 85, 87–88,
246, 272
conversion to int, 85
formatting, 101–103
immutability, 84, 140
indexing, 20, 90–93
interpreted literals, 83
iterating, 88–90, 203
literals, 75, 83
raw ( ``), 75, 78, 96
searching, 87
slicing, 90–93
sorting, 87
see also byteand runetypes
Stringer (interface; fmtpackage),
265, 266–267, 286
stringspackage, 91, 107–113, 419
Contains() , 108
Count(), 108, 172, 173
EqualFold() , 108, 163
Fields(), 38, 39, 76, 77, 107–110,
108, 111
FieldsFunc() , 108, 178
HasPrefix() , 108, 132, 194, 246,
260, 382
HasSuffix() , 108, 131–132, 226,
400, 403
Index(), 92, 103, 108, 133, 134,
383
IndexAny() , 108, 133, 134
IndexFunc() , 92, 93, 108
IndexRune() , 108
Join(), 14, 16, 55, 108, 111, 180,
414LastIndex() , 92, 108, 194
LastIndexAny() , 108
LastIndexFunc() , 92, 108
Map(), 108, 111–112, 132, 133,
258
NewReader() , 108, 113
NewReplacer() , 108
Reader(type); seetop-level entry
Repeat(), 48, 99, 108, 243, 246
Replace() , 76, 77, 109, 110, 399
Split(), 38, 39, 107, 109, 132, 133,
422
SplitAfter() , 107, 109
SplitAfterN() , 107, 109
SplitN(), 39, 107, 109
Title(), 109
ToLower() , 109, 162, 163, 177, 194,
246, 259, 293, 306, 324
ToTitle() , 109
ToUpper() , 37, 109, 259, 302
Trim(), 109
TrimFunc() , 109
TrimLeft() , 109, 399
TrimLeftFunc() , 109
TrimRight() , 109, 127
TrimRightFunc() , 109
TrimSpace() , 111, 132, 177, 246,
376, 383
Strings() (sortpackage), 160, 161,
163, 170, 178, 180, 356
StringsAreSorted() (sortpackage),
161
strong typing, 15, 20, 24
struct(keyword), 42, 73, 96, 104,
132, 167, 199, 202, 222, 223, 245,
254, 255, 259–260, 261–262,
275–282, 284, 285, 305, 308, 326,
328, 330, 335, 337, 343, 350, 354,
362, 366, 372, 387
Sub()(Inttype), 63
SubexpNames() (Regexptype), 125
substrings; seestringtype’s slicing
sufﬁx, ﬁle, 194
swapping values, 188
Index 471
switch(statement), 110, 174,
195–202, 220, 233, 235, 282, 285,
365; see also ifstatement
sync(package)
RWMutex(type); seetop-level entry
WaitGroup (type), seetop-level en-
try
synchronization, 44, 315, 318, 321
synchronous, channel, 207; see also
channels
T
tab ( \t), 84
tags, struct, 279, 371, 372, 428
Tan()
cmplxpackage, 71
mathpackage, 67
Tanh()
cmplxpackage, 71
mathpackage, 67
.tarﬁles, 399–401, 403–405
tar(package; archivepackage),
399–401, 403–405
Header(type), 401, 404
NewReader() , 403
NewWriter() , 400
Reader(type), 403, 405
Writer(type); seetop-level entry
Taylor, Ian Lance, 2
TCP/IP; seenetpackage
TempFile() (ioutilpackage), 424
template (package; htmlpackage),
420–421
template (package; textpackage),
420–421
HTMLEscape() , 78
terminal; seeStderr,Stdin, and Std-
outstreams
Terminal_Punctuation (constant; uni-
codepackage), 258
termination, 15, 317, 321
terminator, statement ( ;), 186
testing(package), 414–416text; seestringtype
text ﬁles; see.txtﬁles
text(package)
template (package), seetop-level
entry
third-party packages, 417–418
this; seereceiver
Thompson, Ken, 1
threads; seechannels, goroutines,
and the chanand gokeywords
Tick()(timepackage), 426
time(package), 426
After(), 332, 333, 426
Duration (type), 332, 333
NewTicker() , 426
Parse(), 370, 376, 377, 383, 395
Tick(), 426
Time(type); seetop-level entry
Unix(), 391
Time(type; timepackage), 362, 363,
368, 377, 383, 390, 394, 395, 426
Format(), 368, 379, 390
Unix(), 391
Title()(stringspackage), 109
To()(unicodepackage), 119
ToLower()
stringspackage, 109, 162, 163,
177, 194, 246, 259, 293, 306,
324
unicodepackage, 119, 272
tools
5g,6g,8g,9
5l,6l,8l,9
cgo,9
gc,9
gccgo,9
go build, 11–12, 23, 409, 411
go fix, 418
go get, 417–418
go install , 1, 13, 409
go test, 415–416
go version , 11
go vet, 418
472 Index
tools (continued)
godoc, 8, 411–413, 419
gofmt, 186, 188, 419
tools (third-party)
gonow, 10
gorun, 10
ToSlash() (filepath package), 399
ToTitle()
stringspackage, 109
unicodepackage, 119
ToUpper()
stringspackage, 37, 109, 259,
302
unicodepackage, 119, 272
trace, stack, 214
Trim()(stringspackage), 109
TrimFunc() (stringspackage), 109
TrimLeft() (stringspackage), 109,
399
TrimLeftFunc() (stringspackage),
109
TrimRight()
bytespackage, 333, 334
stringspackage, 109, 127
TrimRightFunc() (stringspackage),
109
TrimSpace() (stringspackage), 111,
132, 177, 246, 376, 383
true(built-in); seebooltype
Trunc()(mathpackage), 67
.txtﬁles, 377–384
type
abstract vs. concrete, 22
deduction, 18
method sets; see22, 191, 260; see
alsomethods
see also built-in types, custom
types, and standard library’s
types
type assertions, 191–192, 200, 233,
234, 237, 242, 300, 319
type conversions, 190–191; see also
conversions and the strconv
packagetype, inference, 53, 70
type(keyword), 24, 42, 55, 73, 132,
161, 190, 198–199, 202, 223,
233, 237, 241, 245, 246, 254, 255,
256–257, 265, 284, 294, 295, 305,
335, 366, 379, 389, 412
type modiﬁer; seepointers and *
pointer declaration operator
type safety; seeduck typing and in-
terfaces
type switchguard, 198, 199
type switches, 197–202, 233, 235,
282, 285; see also switchstate-
ment
TypeOf() (reflectpackage), 427, 428,
430
typing, duck, 21, 32, 268
typing, strong, 15, 20, 24
U
UDP; seenetpackage
UID; seeGetuid()
uint(type; built-in), 60, 69
uint8(type; built-in); seebytetype
uint16(type; built-in), 60, 388, 393
uint32(type; built-in), 60, 388, 393
uint64(type; built-in), 60
uintptr(type; built-in), 60
unbound methods (method expres-
sions), 263
unchecked type assertion; seetype
assertions
unexported identiﬁers, 52, 264
Unicode, 52, 82–84, 86–87
normalization, 86
U+FFFDreplacement character, 85,
118
whitespace, 92
Unicode code point; seerunetype
unicode(package), 118, 420
Hyphen(constant), 272
Is(), 118, 119, 258, 272
IsControl() , 119
Index 473
IsDigit() , 119
IsGraphic() , 119
IsLetter() , 119, 178
IsLower() , 119
IsMark(), 119
IsOneOf() , 119
IsPrint() , 119
IsPunct() , 119
IsSpace() , 92, 111, 119, 272
IsSymbol() , 119
IsTitle() , 119
IsUpper() , 119
MaxRune(constant), 82
SimpleFold() , 119
Terminal_Punctuation (constant),
258
To(), 119
ToLower() , 119, 272
ToTitle() , 119
ToUpper() , 119, 272
utf8(package), seetop-level en-
try
utf16(package), 420
Uniform() (imagepackage), 290
UniqueInts() (exercise), 180
unit testing, 414–415
Unix()
timepackage, 391
Timetype, 391
Unlock() (RWMutextype), 346
Unmarshal() (jsonpackage), 199, 201,
202, 369, 370
unnamed return values, 190, 219
unnamed struct, 275
unnamed vs. named custom types,
22
unpack(example), 397–405
unpack(exercise), 405
Unquote() (strconvpackage), 115,
117
UnquoteChar() (strconvpackage), 115
untyped constants; seeunder literals
and speciﬁc typesurl(package; netpackage), 427
US-ASCII encoding, 82
UTF-8; seestringtype and Unicode
utf8(package; unicodepackage), 117,
420
DecodeLastRune() , 118
DecodeLastRuneInString() , 91,
118, 229, 230
DecodeRune() , 118
DecodeRuneInString() , 91, 92, 93,
203, 229, 230
EncodeRune() , 118
FullRune() , 118
FullRuneInString() , 118
RuneCount() , 118
RuneCountInString() , 85, 99, 177,
178, 229
RuneLen() , 118
RuneStart() , 118
UTFMax(constant), 177
Valid(), 118
ValidString() , 118
utf16(package; unicodepackage),
420
utf16-to-utf8 (exercise), 405
UTFMax(constant; utf8package), 177
V
Valid()(utf8package), 118
validation, 263–265
ValidString() (utf8package), 118
Value(type; reflectpackage), 235,
427–431
Bool(), 428
Call(), 429, 430
CanSet(), 428
Complex() , 428
Elem(), 429
FieldByName() , 428
Float(), 428
Index(), 235, 236, 428
Int(), 428, 430
Interface() , 235
474 Index
Value(type; reflectpackage) (contin-
ued)
IsValid() , 430
Kind(), 235
Len(), 235, 430
MethodByName() , 430
SetInt(), 429
SetString() , 428
String(), 428, 429
ValueOf() (reflectpackage), 235,
427, 428, 429, 430
values, 140–148, 255; see also vari-
ables
values, swapping, 188
var(keyword), 23, 53, 188, 192, 201,
241, 257, 272, 378, 382, 388
variable vs. ﬁxed-width character
encoding, 83
variables, 140–148, 242, 265, 290
declaration, short, 15, 53, 140,
188
initializing, 15, 74
local, 40, 45, 141
package, 18
shadow, 36, 189, 192, 200, 201,
281, 282, 300, 301
see also environment variables
variadic function, 198, 219, 221–222
variant; seeinterface{}
Version() (runtimepackage), 424
vertial tab ( \v), 84
virtual functions, 254
Vorbis audio format, 130
W
Wait()(WaitGroup type), 317, 350,
354
WaitGroup (type; syncpackage), 317,
350
Add(), 350, 351, 352, 354
Done(), 350, 352, 354
Wait(), 317, 350, 354
Walk()(filepath package), 349, 352web applications, 2, 72, 79–80
web sites
endsoftpatents.org , 439
godashboard.appspot.com , 407,
417, 423, 426
golang.org , 8, 436
www.nosoftwarepatents.com , 439
www.qtrac.eu ,1
while loop; seeforloop
whitespace, 92, 111, 128–129
wordfrequencies (example), 174–180
wrapper function, 218, 226
Write()(binarypackage), 388
WriteAt() (Filetype), 397
WriteCloser (interface; iopackage),
400
WriteFile() (ioutilpackage), 424
WriteHeader() (Writertype), 401
Writer(interface; iopackage), 32, 34,
35, 93, 255, 354, 364, 366, 373,
378, 385, 388, 399
Writer(type)
bufiopackage, 35, 38
Flush(), 35, 36, 378
WriteString() , 35, 37
gzippackage, 400
tarpackage, 400
WriteHeader() , 401
zippackage, 397, 398
CreateHeader() , 398, 399
WriteRune() (Buffertype), 111
WriteString()
Buffertype, 88, 111, 200, 243
Writertype, 35, 37
writing ﬁles; seeFiletype and ioutil
package
X
XML format, 363, 371–377
xml(package; encoding package), 371,
372
Decoder(type); seetop-level entry
Index 475
Encoder(type); seetop-level entry
Header(constant), 373
Name(type), 372, 374
NewDecoder() , 375
NewEncoder() , 373
xor, logical; see^operator
Y
Y0()(mathpackage), 67
Y1()(mathpackage), 67
Yn()(mathpackage), 67
Z
zero, division by, 68
zero value, 27, 33, 39, 53, 54, 149,
150, 152, 168, 173, 189, 191, 216,
222, 257, 263, 275, 308, 346, 383
zero-width assertions in regular ex-
pressions, 122
.zipﬁles, 397–399, 401–403
zip(package; archivepackage),
397–399, 401–403
FileHeader (type), 399
FileInfoHeader() , 398, 399
NewWriter() , 398
OpenReader() , 401, 402
ReadCloser (type), 401
Writer(type); seetop-level entry
ZP(zero Point;imagepackage), 290
Mark Summerﬁeld
Mark is a computer science graduate with many years of experience working
in the software industry, primarily as a programmer. He has also spent many
years writing and editing technical documentation. Mark owns Qtrac Ltd.
(www.qtrac.eu ), where he works as an independent programmer, author, editor,
and trainer, specializing in the C ++, Go, and Python languages, and the Qt,
PyQt, and PySide libraries.
Other books by Mark Summerﬁeld:
•Advanced Qt Programming (2011, ISBN-13: 978-0-321-63590-7)
•Programming in Python 3 (First Edition, 2009, ISBN-13:
978-0-13-712929-4; Second Edition, 2010, ISBN-13: 978-0-321-68056-3)
•Rapid GUI Programming with Python and Qt (2008, ISBN-13:
978-0-13-235418-9)
Other books by Jasmin Blanchette and Mark Summerﬁeld:
•C++GUI Programming with Qt 4 (First Edition, 2006, ISBN-13:
978-0-13-187249-3; Second Edition, 2008, ISBN-13: 978-0-13-235416-5)
•C++GUI Programming with Qt 3 (2004, ISBN-13:!978-0-13-124072-8)
Production
The text was written using gvim .Thetypesetting—includingallthediagrams—
wasdone using the louttypesetting language. All of the code snippetswere auto-
matically extracted directly from the example programs and from test programs
using a custom tool written in Go. The index was compiled by the author. The
text and source code was version-controlled using Mercurial . The monospaced
code font was derived from a condensed version of DejaVu Mono and modiﬁed
using FontForge . The book was previewed using evince andgv,and converted to
PDF by Ghostscript . The cover was provided by the publisher. Note that only
printed editions are deﬁnitive: eBook versions are not under the author’s control
and are often retypeset, which can introduce errors.
All the editing and processing was done on Debian and Ubuntu systems. All
the example programs have been tested using the ofﬁcial gcGo compiler on
Linux, Mac OS X, and Windows using Go 1 and should work with all subsequent
Go 1. xversions.

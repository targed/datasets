CSC322
C Programming and UNIX
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Hackers!
Hacker [originally, someone who makes furniture with an axe] 1. A person who
enjoys exploring the details of programmable systems and how to stretch their
capabilities, as opposed to most users, who prefer to learn only the minimum
necessary. 2. One who programs enthusiastically (even obsessively) or who
enjoys programming rather than just theorizing about programming. 3. A person
capable of appreciating hack value. 4. A person who is good at programming
quickly. 5. An expert at a particular program, or one who frequently does work
using it or on it; as in ‘a Unix hacker’. (Deﬁnitions 1 through 5 are correlated, and
people who ﬁt them congregate.) 6. An expert or enthusiast of any kind. One
might be an astronomy hacker, for example. 7. One who enjoys the intellectual
challenge of creatively overcoming or circumventing limitations. 8. [deprecated]
A malicious meddler who tries to discover sensitive information by poking around.
Hence ‘password hacker’, ‘network hacker’. The correct term for this sense is
cracker.
The New Hacker’s Dictionary (aka the Jargon File)
Stephan Schulz 2
UNIX and You
The
Operating SystemUNIX
Stephan Schulz 3
UNIX and You
The
Operating SystemUNIX
Stephan Schulz 4
UNIX and You
The
Operating SystemUNIX
C
Stephan Schulz 5
Our AIM
etc dev usr home/
joe jackjillbin
hda mouse mtalsman cat
PID:
182PID:
512I
t
e
r
n
e
tn
COperating SystemTheUNIX
Stephan Schulz 6
The Myth
UNIX is a big-iron operating system
UNIX is complicated
UNIX is hard to use
UNIX has been created by SUN, IBM, HP, and other large companies
UNIX is monolithic
Stephan Schulz 7
Counterpoint
UNIX was developed on small machines and became popular on the “killer
micros”. UNIX dialects now run on everything from a PDA to CRAY supercom-
puters
UNIX is based on simple and elegant principles (but has added a some cruft over
the years)
UNIX is not particularly hard to use (compared to the power it gives to the
user), but has a reasonably steep learning curve. It’s not a “show-me” operating
system, but a “tell me” operating system,
UNIX has been created in a research environment, and much of it has been
developed in informal settings by hackers. Much of the impetus for UNIX comes
from free versions (Linux, Net-, Open-, FreeBSD), although many companies
contribute to it’s development
Many UNIX kernels are monolithic, but the UNIX system is extremly modular.
Stephan Schulz 8
UNIX
First portable operating system (NetBSD: 18 processor architecures, ≈50 com-
puter architecures)
Written in a “high-level” language (C)
Small (for what it does):
–Recent LINUX kernel: 2.4 million LOC (1.4 million for driver, 0.4 million
architecture-dependent stuﬀ (16 ports)
–Windows 2000: Estimates range from 29 million to 65 million LOC, supports
just 1.5 architecures
Modular (though often on a monolithic kernel)
–Separate windowing system (X) and window managers
–Various Desktop-Solutions (CDE, KDE, Gnome)
–Toolbox-philosphy : Combine (lot’s of) simple tools
–Underneath: Strong and simple abstraction (“ Everything is a ﬁle ”)
Stephan Schulz 9
C
“Pragmatic” high level language:
–Handles characters, numbers, adresses as implemented by most computers
–Small core language, much functionality provided by libraries (mostly in C!)
–Compilers are easy to write
–Compilers are easy to port
–Even naive compilers produce reasonably eﬃcent code
Hacker-friendly
–Straightforward compilation (nothing is hidden)
–Compact source code (fewer keystrokes, fast to read)
–Typed, but no bondage-and-discipline language
Adequate support for building abstractions
–Structures (composing objects), unions, enumerations
–Arrays and pointer
–Support for deﬁning new types
Stephan Schulz 10
UNIX history tree (simpliﬁed)
For a fuller tree see http://www.levenez.com/unix/
Stephan Schulz 11
A Short History of UNIX and C
1969 Ken Thompson wrote the ﬁrst UNIX (in assembler) on a PDP7 at AT&T Bell
Labs, allegedly to play Space Travel
1970 Brian Kernighan coins the name UNIX. The UNIX project gets a PDP11 and
a task: Writing a text processing system
1971-72 Creation of C (Dennis Ritchie), UNIX rewritten in C
1972 Pipes arrive, UNIX installed on 10 (!) systems
1975 AT&T UNIX “Version 6” distributed with sources under academic licenses
1976 Ken Thompson in Berkely, leading to BSD UNIX
1977 1BSD release
1978 UNIX “Version 7”, leading to System V (AT&T)
Stephan Schulz 12
A Short History of UNIX and C
1978 3BSD, adding virtual memory
1980 Microsoft XENIX brand of UNIX
1982 4.2BSD, adding TCP/IP
1982 SGI IRIX
1983 Bjarne Stroustrup creates C++ (at AT&T Bell labs)
1983 GNU Project announced (Aim: Free UNIX-like system)
1983-1984 Berkeley Internet Name Demon (BIND) created
1984 SUN introduces NFS (Network File System)
1985 Free Software Foundation (Stallman), GNU manifesto, GNU Emacs
Stephan Schulz 13
A Short History of UNIX and C
1986 HP-UX, SunOS3.2 (from BSD Unix), “attack of the killer micros”
1986 MIT Project Athena creates X11 (Network window system)
1986 POSIX.1 (Portable operating system interface standard)
1988 GNU GPL
1988 System VR4 “One UNIX to rule them all” (AT&T+SUN)
1988 NeXTCUBE with NeXTSTEP operating system
1989 ANSI-C Standard “C89”(adds prototypes, standard library)
1889 SunOS 4.0x
1990 Net/1 Release (free BSD UNIX)
1990 IBM AIX
Stephan Schulz 14
A Short History of UNIX and C
1991 Linux 0.01, “attack of the killer PCs” (continuing till this day)
1991 World Wide Web born
1991–1992 Lawsuits around BSD UNIX Net/1 and Net/2 releases
1992 SunOS 5 aka Solaris-2 (from System VR4)
1993 FreeBSD 1.0
1994 Linux 1.0
1994 NetBSD 1.0, 4.4BSD Lite (unencumbered by AT&T copyrights, becomes new
base for all non-commercial BSD ﬂavours)
1995 “UNIX wars” are over
1996 Tux the Penguin becomes Linux mascot
Stephan Schulz 15
A Short History of UNIX and C
1998 UNIX-98 branding (Single UNIX speciﬁcation)
2000 New ANSI “C99”
2001 IBM runs prime time TV ads for Linux
2001 UNIX-based MacOS X
2002 Linux is at version 2.4, Emacs is version 21.2, SunOS is at 5.9 (aka Solaris 9),
BIND is version 9.2.1
Stephan Schulz 16
Another Opinion
UNIX is notan operating system. . .
. . . but is the collected folklore of the
hacker community!
Stephan Schulz 17
Spot the Even Ones
Stephan Schulz 18
Upshot
You don’t have to grow a beard
to become a world-class UNIX hacker. . .
. . . but it does seem to help!
Stephan Schulz 19
CSC322
C Programming and UNIX
UNIX from a User’s Perspective
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
UNIX Architecture
HardwareUNIX KernelLibrariesShellApplication
Stephan Schulz 21
UNIX Architecture
HardwareUNIX KernelLibrariesShellApplication
Stephan Schulz 22
Some Concepts
UNIX is a multi-user system. Each user has:
–User name (mine is schulz on most machines)
–Numerical user id (e.g. 500)
–Home directory: A place where (most of) his or her ﬁles are stored
UNIX is a multi-tasking system, i.e. it can run multiple programs at once. A
running program (with its data) is called a process . Each process has:
–Owner (a user)
–Working directory (a place in the ﬁle system)
–Various resources
Ashell is a command interpreter, i.e. a process accepting and executing commands
from a user.
–A shell is typically owned by the user using it
–The initial working directory of a shell is typically the users home directory
(but can be changed by commands)
Stephan Schulz 23
More on Users
There are two kinds of users:
–Normal users
–Super users (“root”)
Super-users:
–Have unlimited access to all ﬁles and resources
–Always have numerical user id 0
–Normally have user name “root” (but there can be more than one user name
associated with UID 0)
–Can seriously damage the system!
Normal users
–Can only access ﬁles if they have the appropriate permissions
–Can belong to one or more groups . Users within a group can share ﬁles
–Usually cannot damage the system or other users ﬁles!
Stephan Schulz 24
The User Interface
UNIX: Provide Tools, Not Policy
–Most tools operate on all (ASCII) ﬁle formats
–Extremely conﬁgurable environment – diﬀerent users have diﬀerent user expe-
riences
–No restrictions ⇔Little consistency
–We will assume the default environment on the lab machines for examples
X Window System: Provide Mechanisms, Not Policy
–Windowing system oﬀers (networked) drawing primitives
–Diﬀerent GUIs built on top of this
–GUI conventions may even diﬀer from one application to the other!
–Modern desktop environments (GNOME/ KDE ) try to change this, but you are
bound to use many legacy applications anyways!
Stephan Schulz 25
My Graphical Desktop
Stephan Schulz 26
Default KDE Desktop (SuSE Linux)
Stephan Schulz 27
Desktop Discussion
My Desktop
–Uses windowing mostly to provide a better text-based interface (compared to
pure text terminals)
–Text editor and shell (command line) windows
–(Can also run graphical applications)
KDE Desktop
–Graphical, mouse-based user experience
–Mostly a launcher for GUI-based programs
∗Oﬃce prgrams
∗Graphics programs
∗Web browser
–Can also run shell windows!
Stephan Schulz 28
KDE Desktop with Terminal Application
Stephan Schulz 29
Exploring the Text Interface
Convention: System output is shown in typewriter font , user input is written in
bold face , and comments (not to be entered) are written in italics .
whoami will print the user name of the current user (more exactly: It will print
the ﬁrst user name associated with the eﬀective user id )
[schulz@gettysburg ∼]$whoami
schulz
pwd prints the current working directory (more later):
[schulz@gettysburg ∼]$pwd
/lee/home/graph/schulz Non-standard setup!
lslists the ﬁles in the current working directory:
[schulz@gettysburg ∼]$ls
core Desktop Not much there at the moment
Stephan Schulz 30
Text Interface Example (contd.)
Most UNIX programs accept options to modify they behavior. One-letter
(“short”) options start with a single dash, followed by a letter:
[schulz@gettysburg ∼]$ls -a (Show all ﬁles, even hidden ones)
. .gnome
.. .ICEauthority
.bash_logout .kde
.bash_profile .mcop
.bashrc .MCOP-random-seed
core .mcoprc
.DCOPserver_hopewell.cs.miami.edu .screenrc
.DCOPserver_potomac.cs.miami.edu .ssh
.DCOPserver_richmond.cs.miami.edu .tcshrc
Desktop .xauth
.emacs .Xauthority
.first_start_kde .xsession-errors
As you can see, hidden ﬁles start with a dot.
Stephan Schulz 31
The UNIX File System
In UNIX, all ﬁles are organized in a single directory tree , regardless of where they
are stored physically
There are two main types of ﬁles:
–Plain ﬁles (containing data)
–Directories (“folders”), containing both plain ﬁles (optionally) and other direc-
tories
Each ﬁle in a directory is identiﬁed by its name and has a number of attributes:
–Name
–Type
–Owner
–Group (each ﬁle belongs to one group, even if the owner belongs to multiple
groups)
–Access rights
–Access dates
Stephan Schulz 32
Typical File System Layout
dev tmp usr bin etc home
(Devices) (Configuration) (Home directories) (Temporary files)/
cplsps hdahdbkbdpasswd hosts joejaneschulz
(Private files)local lib bin
libbin coreDesktop(Vendor) (Vendor)(Root directory)
(System programs) (User programs)
(Site−installed)
Files in the directory trees are described by pathnames
–Pathnames consist of ﬁle names, separated by slashes ( /)
–Absolute pathnames start with a /./bin/cp denotes cp
–Relative pathnames are interpreted relative to the current working directory. If
/home is the current working directory, then schulz/core denotes core
Stephan Schulz 33
Moving Through the File System
We can use the command cdto change our working directory:
[schulz@gettysburg ∼]$pwd
/lee/home/graph/schulz
cd /
[schulz@gettysburg /]$ pwd
/
[schulz@gettysburg /]$ cd bin
[schulz@gettysburg /bin]$ pwd
/bin
[schulz@gettysburg /bin]$ cd /lee/home/graph/schulz
[schulz@gettysburg ∼]$pwd
/lee/home/graph/schulz
Each directory contains two special entries: .and..
–.represents the directory itself. cd . is a NOP
–..normally represents the parent directory. cd .. moves the working directory
up one level. In /,..points to /itself
Stephan Schulz 34
More about ﬁles
We can use the -l(“long format”) option to lsto show us all all attributes
[schulz@gettysburg ∼]$ls -l
-rw------- 1 schulz users 1531904 Aug 29 10:55 core
drwxr-xr-x 3 schulz users 4096 Aug 29 10:55 Desktop
The long format of lsshows us more about the ﬁles:
–The ﬁrst letter tells us the ﬁle type .dis a directory, -means a plain ﬁle
–The next nine letters describe access rights , i.e. who is allowed to read, write,
and execute the ﬁle. More on those later!
–The next number is the number of (hard) links to a ﬁle. More on that much
later!
–Next is the user that owns the ﬁle
–After that, the group that owns the ﬁle
–Next comes the ﬁle size in bytes
–Then the date the ﬁle was changed for the last time
–Finally, the name of the ﬁle
Stephan Schulz 35
UNIX Online Documentation 1
The UNIX Programmer’s Manual (“man pages”)
–Traditionally available on every UNIX system, quite terse
–Usage: man [section] <command>
–Sections (may diﬀer by UNIX ﬂavour):
1.User commands
2.System calls
3.C library routines
4.Device drivers and network interfaces
5.File formats
6.Games and demos
7.Misc. (ASCII, macro packages, tables, etc)
8.Commands for system administration
9.Locally installed manual pages. (i.e. X11)
–man -k <term> gives you a list of pages relevant to <term>
–To leave the man program (or rather the pager it uses), hit q
Stephan Schulz 36
UNIX Online Documentation 2
GNU info ﬁles
–Available with most Linux systems and most GNU packages
–Usage: info <command> , then browse interactively
–You can also use the info reader build into GNU Emacs
∗Enter emacs, then type C-h i, then select topic
∗If you do not use Emacs, you should ;-)
∗. . . but we will introduce it later on
Stephan Schulz 37
Exercises
Move through the ﬁle system using cd. You can inspect most ﬁles using
more <file> if they are ASCII text. Try e.g. /etc/passwd and/etc/hosts .
Tryman man andinfo info
Read the man and info documentation for
–ls
–whoami
–cd
–pwd
Don’t worry if you don’t understand everything!
(Do worry if you understand nothing!)
Stephan Schulz 38
CSC322
C Programming and UNIX
UNIX from a User’s Perspective II
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Command Format
Normal UNIX command format: <command > <arg1>. . .<argn>
–The ﬁrst word is interpreted as a command
–The remaining words (separated by spaces or blanks) are arguments
–The implementation of a command is free in how it treats the arguments
–Convention: Arguments starting with a dash -areoptions
Many characters have special meaning in most shells, including $, (, ), [,
], *, &, |, ;, \, , ’, ", ’ ’ (blank, the argument separator)
–Arguments may be enclosed in single quotes ( ’ ’) or in double quotes ( " ")
to suppress most special meanings
∗Single quotes suppress (nearly) all special meanings
∗Double quotes suppress most special meanings
∗In particular, both suppress the meaning of blank: A string ’a a’ will appear
as a single argument to a command
∗Quotes are notpassed on to the command!
–The backslash \can be used to suppress the special meaning of individual
characters. \”represents a double quote, \\a backslash character
Stephan Schulz 40
Command Types
There are diﬀerent types of commands a shell can execute:
Shell built-in commands are executed directly by the shell
–Examples: cd,pwd,echo ,alias
Shell functions are user-deﬁned shell extensions
–Particularly useful in scripting , rare in interactive use
Executable programs (the normal case) are loaded from the disk and executed
–Examples: ls,whoami ,man
–If apathname is given, that ﬁle is executed (if possible)
–If just a ﬁlename is given, bash searches in all directories speciﬁed in the
variable $PATH
–Note that neither .nor∼are necessarily in $PATH !
Stephan Schulz 41
UNIX User Commands: echo and touch
echo <arg1>. . . prints its arguments to the screen
–echo is often a shell built-in command. To guarantee the behavior described
in the man-page, use /bin/echo
–Example:
[schulz@gettysburg ∼]$echo ”Hello World”
Hello World (simplest ”Hello World” program in UNIX)
[schulz@gettysburg ∼]$echo ’$PATH = ’ $PATH
$PATH = .:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/us
r/java/jdk1.3.1 01/bin:/home/graph/schulz/bin:/usr/X11R6/bin
touch <ﬁle1>. . . sets the access and modiﬁcation time of the given ﬁles to
the current time
–If one of the ﬁles does not exist, touch will create an empty ﬁle of that name
–Important option:
∗-c: Do notcreate non-existing ﬁles (long form --no-create is supported by
modern implementations (GNU))
∗Other options: man touch
Stephan Schulz 42
UNIX User Commands: rm, mkdir, rmdir
rm<ﬁle1>, . . . will delete the named ﬁles
–Important options:
∗-f:Force removal, never ask the user (even if the user has withdrawn write
permission for that ﬁle)
∗-i:Interactively ask the user about each ﬁle to be deleted
∗-r: If some of the ﬁles are directories, recursively delete their contents ﬁrst,
then delete them
mkdir <ﬁle1>. . . will create the directories named (if the user has the permission
to do so)
rmdir <ﬁle1>. . . will delete the directories named (if the user has the permission
to do so and if they are empty)
Stephan Schulz 43
Eﬀective Shell Use: History
Modern shells like the bash or the tcsh keep a history of your previous commands
–Type history to see these commands
–Type !<number >re-execute the command with the given number
–Type !<command >to re-execute the most recent command starting with the
(partial) word <command >
Example:
[schulz@gettysburg ∼]$history
(. . . many entries omitted)
194 more CSC322.tex
195 gv CSC322 1.pdf
196 ls
197 ll CSC322 1.pdf
198 history
–!197 will execute ll CSC322 1.pdf
–!gwill execute gv CSC322 1.pdf
Stephan Schulz 44
Eﬀective Shell Use: Editing/Completion
While typing commands, bash oﬀers you many ways to ease your task:
–[Backspace] will delete the character preceding the cursor
–[C-d] (hold down [CTRL] , then press [d]) will delete the character under the
cursor (if there is such a character)
–[C-k] will delete all characters under and right of the cursor
–Left arrow and right arrow move the cursor in the command line (alternatively,
try[C-b] and[C-f] )
–[C-a] and[C-e] move to the begin and end of the line, respectively
–Up arrow and down arrow will move you through the history (as will [C-p] and
[C-n] )!
–In general, default bash key bindings are inspired by emacs editing commands
One of the more intriguing features: Name completion
–At any time, hit [TAB] , and bash will complete the current word as far
as possible. Hitting [C-d] at the end of a non-empty line will list possible
completions
–It is quite smart (conﬁgurably smart, in fact) about this
Stephan Schulz 45
Eﬀective Shell Use: Globbing
Idea: Use simple patterns to describe setsof ﬁlenames
A string is a wildcard pattern if it contains one of ?,*or[
A wildcard pattern expands into all ﬁle names matching it
–A normal letter in a pattern matches itself
–A ? in a pattern matches any one letter
–A * in a pattern matches any string
–A pattern [l1. . . l n]matches any one of the enclosed letters (exception: ! as
the ﬁrst letter)
–A pattern [!l1. . . l n]matches any one of the characters notin the set
–A leading .in a ﬁlename is never matched by anything except an explicit
leading dot
–For more: man 7 glob
Important: Globbing is performed by the shell !
Stephan Schulz 46
Example: File Handling and Globbing
$mkdir TEST DIR
$cd TEST DIR
$touch a ba bba bbba bbbba bbbbba LongFilename .LongHiddenFile
$ls -a
. .. a ba bba bbba bbbba bbbbba LongFilename .LongHiddenFile
$echo *a* (Everything with an a anywhere)
a ba bba bbba bbbba bbbbba LongFilename
$echo *Long*
LongFilename (Note: Does not match .LongHiddenFile)
$echo .* (all hidden ﬁles)
. .. .LongHiddenFile
$echo [ab]*
a ba bba bbba bbbba bbbbba
$echo *[ae] (everything that ends in a or e)
$echo ?*[ae] (everything that ends in a or e and has at least one more letter)
ba bba bbba bbbba bbbbba LongFilename
Stephan Schulz 47
Example: File Handling and Globbing (Contd.)
$cd ..
$rmdir TEST DIR
rmdir: ‘TEST DIR’: Directory not empty
$rm TEST DIR/*
rmdir: ‘TEST DIR’: Directory not empty
$rmdir TEST DIR
$rm TEST DIR/.L*
$rmdir TEST DIR
Alternative:
$mkdir TEST DIR
$touch TEST DIR/.HiddenFile
$rmdir TEST DIR
rmdir: ‘TEST DIR’: Directory not empty
$rm -r TEST DIR
Stephan Schulz 48
UNIX User Commands: cat/more/less
cat<ﬁle1>. . . will con catenate the named ﬁles and print them to standard
output (by default, your terminal)
–It’s usually just used to display short ﬁles ;-)
more andlessarepagers
–Each will show you a text (e.g. the contents of a ﬁle given on the command
line) by pages, stopping after each page and waiting for a key press (normally
[space])
–Major diﬀerences:
∗more will automatically exit at the end of the data, less requires explicit
termination with [q]
∗less allows you to scroll backwards (using [p]),more only allows scrolling
forward
–For more (or less): man more ,man less
Stephan Schulz 49
Text Editing under UNIX
There are 3 ways to edit text under UNIX:
1.Theviway
2.Theemacs way
3.The wrong way
vi(thevisual editor) is the text editor written by Bill Joy for BSD UNIX (published
about 1978)
–Screen-oriented WYSIWYG editor (for plain text)
–Available on just about any UNIX system
–About 35% of all serious UNIX hackers still prefer vi(or a derivative)!
–Current version on Lab machines: vim 5.8.7 (ViImproved)
emacs (editing macros) started in 1976 as a set of TECO macros on ITS
–Currently popular emacs versions (GNU Emacs and XEmacs) go back to 1985
GNU Emacs by Stallman. Both basically are a LISP system with a large text
editing library and an editor-like user interface
–About 35% of all serious UNIX hackers use Emacs. Also widespread use on
other operating systems
–emacs on the lab machines is GNU Emacs 20.7.1
Stephan Schulz 50
vi ﬂyby
Getting into it: vi<ﬁle>
Modal interface: Normally letters denote editing commands, only in insert mode
can actual letters be typed into the ﬁle
The editor starts in command mode (see next slide)
Insert mode (shows {-- INSERT --} in bottom line):
Key Eﬀect
[ESC] Go back to command mode
Any normal key Insert corresponding letter
[Backspace] Delete last typed letter
Tutorials e.g. at http://www.cfm.brown.edu/Unixhelp/vi_.html .
Stephan Schulz 51
vi ﬂyby II
Command mode (commands marked (*) change into insert mode):
Key(s) Eﬀect
Cursor keys Move around
:r<ﬁle> Insert ﬁle content at cursor position
:w Write ﬁle
:q Leave vi
:wq Write ﬁle and leave
:q! Leave vi even if unsafed changes
:h Help!
i Insert text at the cursor position (*)
a Insert text after the cursor position (*)
A Insert text at the end of the current line (*)
o Open a new line and insert text (*)
j Join two lines into one
x Delete character under cursor
dd Delete current line
. Repeat last command
:<no> Goto line number <no>
Stephan Schulz 52
Emacs for Everyone
Getting into it: emacs <ﬁle>or just emacs & (remark: Normally, emacs is only
started once, and you visit diﬀerent ﬁles from within the editor. Emacs can work
on many ﬁles at once)
Emacs is extremely conﬁgurable and extendable:
–Special modes support nearly all programming languages
∗Indentation
∗Compilation/Error correcting
∗Debugging
–You can read email and USENET news in emacs
–Emacs can be used as a web browser
An Emacs window normally has diﬀerent sub-regions:
–Menu bar (operate with a mouse, many frequently used commands)
–One or more text windows , each displaying a buﬀer (a text editing area)
–One mode line for each text window, displaying various pieces of information
–Finally, the mini-buﬀer for typing complex commands and dialogs
Stephan Schulz 53
Emacs for Everyone II
Stephan Schulz 54
Emacs for Everyone III
Emacs is non-modal, normal keys always insert the corresponding letter
Commands are typed by using [CRTL] or[ALT] in combination with normal
keys. We write e.g. [C-a] or[M-a] to denote [a]pressed with [CRTL] or[ALT]
(Mformeta ).[C-h t] is[C-h] followed by plain [t].
Key(s) What it does
[C-h t] Enter the emacs tutorial
[C-x C-c] Leave emacs
Cursor keys Move around
[C-x C-f] Open a new ﬁle (*)
[C-x C-s] Save current ﬁle
[C-x s] Save all changed ﬁles (*)
[M-x] Call arbitrary LISP function by name (*)
[C-s] Incremental search (try it!) (*)
Entries marked with (*) will ask for additional information in the mini-buﬀer
Stephan Schulz 55
Exercises
Experiment with bash command line editing and history
Create some ﬁles and play with globbing
Write a short text in both viandemacs
Read the viandemacs tutorials
Note: You are strongly encuraged to learn basics of both editors, and to become
proﬁcient in at least one of them. I’ll not examinate you about either, but don’t
complain if you have troube with any other editor
Stephan Schulz 56
ed is the standard text editor
When I log into my Xenix system with my 110 baud teletype, both vi
*and* Emacs are just too damn slow. They print useless messages like,
’C-h for help’ and ’"foo" File is read only’. So I use the editor
that doesn’t waste my VALUABLE time.
Ed, man! !man ed
ED(1) UNIX Programmer’s Manual ED(1)
NAME
ed - text editor
SYNOPSIS
ed [ - ] [ -x ] [ name ]
DESCRIPTION
Ed is the standard text editor.
- ---
Computer Scientists love ed, not just because it comes first
alphabetically, but because it’s the standard. Everyone else loves ed
because it’s ED!
Stephan Schulz 57
"Ed is the standard text editor."
And ed doesn’t waste space on my Timex Sinclair. Just look:
- -rwxr-xr-x 1 root 24 Oct 29 1929 /bin/ed
- -rwxr-xr-t 4 root 1310720 Jan 1 1970 /usr/ucb/vi
- -rwxr-xr-x 1 root 5.89824e37 Oct 22 1990 /usr/bin/emacs
Of course, on the system *I* administrate, vi is symlinked to ed.
Emacs has been replaced by a shell script which 1) Generates a syslog
message at level LOG_EMERG; 2) reduces the user’s disk quota by 100K;
and 3) RUNS ED!!!!!!
"Ed is the standard text editor."
Let’s look at a typical novice’s session with the mighty ed:
golem> ed
?
help
?
Stephan Schulz 58
?
?
quit
?
exit
?
bye
?
hello?
?
eat flaming death
?^C
?
^C
?
^D
?
- ---
Note the consistent user interface and error reportage. Ed is
generous enough to flag errors, yet prudent enough not to overwhelm
the novice with verbosity.
Stephan Schulz 59
"Ed is the standard text editor."
Ed, the greatest WYGIWYG editor of all.
ED IS THE TRUE PATH TO NIRVANA! ED HAS BEEN THE CHOICE OF EDUCATED
AND IGNORANT ALIKE FOR CENTURIES! ED WILL NOT CORRUPT YOUR PRECIOUS
BODILY FLUIDS!! ED IS THE STANDARD TEXT EDITOR! ED MAKES THE SUN
SHINE AND THE BIRDS SING AND THE GRASS GREEN!!
When I use an editor, I don’t want eight extra KILOBYTES of worthless
help screens and cursor positioning code! I just want an EDitor!!
Not a "viitor". Not a "emacsitor". Those aren’t even WORDS!!!! ED!
ED! ED IS THE STANDARD!!!
TEXT EDITOR.
When IBM, in its ever-present omnipotence, needed to base their
"edlin" on a UNIX standard, did they mimic vi? No. Emacs? Surely
you jest. They chose the most karmic editor of all. The standard.
Ed is for those who can *remember* what they are working on. If you
are an idiot, you should use Emacs. If you are an Emacs, you should
not be vi. If you use ED, you are on THE PATH TO REDEMPTION. THE
Stephan Schulz 60
SO-CALLED "VISUAL" EDITORS HAVE BEEN PLACED HERE BY ED TO TEMPT THE
FAITHLESS. DO NOT GIVE IN!!! THE MIGHTY ED HAS SPOKEN!!!
?
Stephan Schulz 61
CSC322
C Programming and UNIX
UNIX from a User’s Perspective
The Goodies
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
UNIX User Commands: grep
Usage: grep <regexp > <ﬁle1>. . .
–grep will scan the input ﬁle(s) and print all lines containing a string that
matches the regular expression <regexp >
–Important options:
∗-i: Ignore upper and lower case in the regular expression
∗-v: Print all lines notmatching the regular expression
–The name comes from an old editor command sequence standing for globally
search for regular expression, print matches
–It is one of the most useful UNIX tools!
Regular expressions (much more by man grep ):
–A normal character matches itself
–A.matches any normal character
–A*after a pattern matches any number of repetitions
–A range [...] works as for globbing (but use ^instead of !for negation)
–Remember that many character are special for the shell – use quotes!
–Example: grep ”Ste.*ulz” <ﬁle>will ﬁnd many versions of my full name in
<file>
Stephan Schulz 63
Input and Output
Each UNIX process normally is created with 3 input/output streams:
–Standard Input or stdin (ﬁle descriptor 0 ) is used for normal input. Many
UNIX programs will read from stdin , if no ﬁle names are given
–Standard Output or stdout (ﬁle descriptor 1 ) is used for all normal output
–Standard Error or stderr (ﬁle descriptor 2 ) is used for out of band output like
warnings or error messages
By default, all three are connected to your terminal
It is possible to redirect the output streams into ﬁles
It is possible to make stdin read from a ﬁle
It is possible to connect one processes stdout to another ones stdin
Stephan Schulz 64
Simple Output Redirection
You can redirect the normal output of a command by appending > <file> to
the command.
–Example 1:
$ man stdin >stdin man page
$ more stdin man page
STDIN(3) System Library Functions Manual STDIN(3)
NAME
stdin, stdout, stderr - standard I/O streams
...
–Example 2: On the lab machines, the global password ﬁle is served over the
NIS (or Yellow Pages) protocol, and is shown by the command ypcat passwd .
ypcat passwd >mypasswd gives you a private copy for password “quality
checking”
–Example 3: cat>myﬁle.c can replace a text editor (hit [C-d] on a line of its
own to indicate the end of input)
Stephan Schulz 65
Output Redirection II
By default, stderr is not redirected, so you can still see error messages on the
terminal (and discard the normal output if it is useless)
To redirect stderr , use 2>(redirect ﬁle descriptor 2):
–$ man bla will print No manual entry for bla
–$ man bla 2 >error will save that error message in the ﬁle error
Special case: If you are not interested in any output, you can redirect it to
/dev/null (a UNIX device ﬁle that just accepts data and ignores it):
–$ man bla 2 >/dev/null will make sure that you do not see the error message
–Alternatively, $ man if bla >/dev/null will give you just the error message
(even though man also prints the man page for the shell-built-in if)
Stephan Schulz 66
Input Redirection
You can also redirect the stdin ﬁle descriptor to read from a ﬁle
–Append < <file> to the command
–This is e.g. useful if you use an interactive program always for the same task
(i.e. you always type the same data into the ﬁle)
–Some UNIX commands only accept input on stdin (e.g. the trutility)
Example: cat<ﬁleis equivalent to cat ﬁle ! (Why? )
Stephan Schulz 67
Shell Pipes
Pipes are a general tool for inter-process communication (IPC)
The shell allows us to easily set up pipes connecting stdout of one process to
stdin of another
Example: man bash |catwill print the bash man page without using the pager
–This can be chained: man bash |grep -i redir |grep -i input will print just
the lines containing information about input redirection
–ypcat passwd |grep schulz will give you just my entry in the password ﬁle
Stephan Schulz 68
Basic Process Control
You can start processes in the foreground or in the background
–Foreground processes are started by just typing a normal command
–Background processes are started by appending an ampersand (&) to the
command. This is particularly useful for graphical applications: emacs &
–While a foreground process is running, the shell is blocked because the process
is using the terminal as its stdin (i.e. you can have at most one non-suspended
foreground process)
–(Most) foreground processes can be terminated by hitting [C-c] (often written
as^C).
–(Most) foreground processes can be suspended by hitting [C-z]
–A suspended process can be continued by typing fg(to continue it as a
foreground process) or bg(to let it run in the background)
–A background process will be suspended automatically, if it needs to read data
from stdin
–jobs gives a numbered list of all processes started by the shell
–You can use fg % <no>to take a particular process into the foreground ( bg
%<no>works on the same principle)
–You can use kill % <no>to terminate the named job
Stephan Schulz 69
UNIX User Commands: Yes
Usage: yes [arg]
If no argument is given, yeswill print an inﬁnite sequence of lines containing just
the character y
If an argument is given, yeswill print an inﬁnite sequence of lines containing that
argument
Very little more is available by printing man yes
Stephan Schulz 70
Job Control Example
$emacs & (Start emacs in the background – it opens its own window )
$yes Hello (Start yes in the foreground)
Hello
Hello
Hello
...
^C (Enough of that)
$jobs
[1] Running emacs (Just my emacs)
$yes Hi (I can never get enough)
Hi
Hi
...
^Z (Suspend it)
Suspended (Indeed!)
$jobs
[1] Running emacs
[2] + Suspended yes
$kill %1 (Ooops! Emacs window closes)
Stephan Schulz 71
Notice: Lab Hours
At the moment, a TA for CSC322 is in the lab Friday 4-6pm and Sunday 2-6pm.
Stephan Schulz 72
CSC322
C Programming and UNIX
Programming in C - Basics
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
A Bird’s Eye View of C
A C program is a collection of
–Declarations
–Deﬁnitons
for
–Functions
–Variables
–Datatypes
A program may be spread over multiples ﬁles
A program ﬁle may contain preprocessor directives that
–Include other ﬁles
–Introduce and expand macro deﬁnitions
–Conditionally select certain parts of the source code for compilation
Stephan Schulz 74
A First C Program
Consider the following C program
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
printf("Hello World! \n");
return EXIT SUCCESS;
}
Assume that it is stored in a ﬁle called hello.c in the current working directory.
Then:
$gcc -o hello hello.c
(Note: Compiles without warning or error)
$./hello
Hello World!
Stephan Schulz 75
A Closer Look (1)
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
printf ("Hello World! \n");
return EXIT SUCCESS ;
}
We are including two header ﬁles from the standard library
–stdio.h contains declarations for buﬀered, stream-based input and output
(we include it for the declaration of printf )
–stdlib.h contains declarations for many odds and ends from the standard
library (it gives us EXIT SUCCESS )
–In general, preprocessor directives start with a hash #
Stephan Schulz 76
A Closer Look (2)
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
printf("Hello World! \n");
return EXIT SUCCESS;
}
The program consist of one function named main()
–main() returns a int(integer value) to its calling environment
–In this case, it takes no arguments (its argument list is void )
–In general, any C program is started by a call to its main() function, and
terminates if main() returns
Stephan Schulz 77
A Closer Look (3)
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
printf("Hello World! \n");
return EXIT SUCCESS;
}
Thefunction body contains two statements:
–A call to the standard library function printf() with the argument ”Hello
World! \n” (a string ending with a newline character)
–Areturn statement, returning the value of the symbol EXIT SUCCESS to the
caller of main()
Stephan Schulz 78
A Closer Look (4)
gccis the GNU C compiler, the standard compiler on most free UNIX system
(and often the preferred compiler on many other systems)
–On traditional systems, the compiler is normally called cc
gcctakes care of all stages of compiling:
–Preprocessing
–Compiling
–Linking
It automagically recognizes what to do (by looking at the ﬁle name suﬃx)
Important options:
–-o<name >: Give the name of the output ﬁle
–-ansi : Compile strict ANSI-89 C only
–-Wall : Warn about all dubious lines
–-c: Don’t perform linking, just generate a (linkable) object ﬁle
–-O–-O6: Use increasing levels of optimization to generate faster executables
Stephan Schulz 79
A More Advanced Example
/* A program that prints a Fahrenheit -> Celsius conversion table */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int fahrenheit, celsius;
printf("Fahrenheit -> Celsius\n\n");
fahrenheit = 0;
while(fahrenheit <= 300)
{
celsius = (fahrenheit-32)*5/9;
printf("%3d %3d\n", fahrenheit, celsius);
fahrenheit = fahrenheit + 10;
}
return EXIT_SUCCESS;
}
Stephan Schulz 80
The Fahrenheit-Celsius Example
Compilation:
$gcc -ansi -Wall -W -o celsius fahrenheit celsius fahrenheit.c
Running it:
$./celsius fahrenheit |more
Fahrenheit -> Celsius
0 -17
10 -12
20 -6
30 -1
40 4
50 10
60 15
70 21
80 26
90 32
100 37
--More--
Stephan Schulz 81
Comments
Comments in C are enclosed in /*and*/
Comments can contain any sequence of characters except for */(although your
compiler may complain if it hits a second occurence of /*in a comment)
Comments can span multiple lines
In assignments (and in live) use comments wisely
–Do explain important ideas, like i.e. what a function or program does
–Do explain clever tricks (if needed)
–Donotrepeat things obvious from the program code anyways
Bad commenting will aﬀect grading!
Stephan Schulz 82
Variables
“int fahrenheit, celsius; ” declares two variables of type intthat can store
a signed integer value from a ﬁnite range
–By intention, intis the fastest datatype available on any given C implemen-
tation
–On most modern UNIX systems, int is a 32 bit type and interpreted in 2s
complement, giving a range from -2 147 483 648 — 2 147 483 647. This is
notpart of the C language deﬁnition, though!
In general, a variable in a program corresponds to a memory location and can
store a value of a speciﬁc type
–All variables must be declared, before they can be used
–Variables can be local to a function (like the variables we have used so far),
local to a single source ﬁle, or global to the hole program
A variables value is changed by an assignment , an expression of the form
“var = expression; ”
Stephan Schulz 83
(Arithmetic) Expressions
C supports various arithmetic operators, including the usual +, - ,* , /
–Subexpressions can be grouped using parenthenses
–Normal arithmetic operations can be used on both integer and ﬂoating point
values, with the type of the arguments determining the type of the result
–Example: (fahrenheit-32)*5/9 is an arithmetic expression in C, implemeting
the well-known formula C=5
9(F−32)for converting Fahrenheit to Celsius
∗Since all arguments are integer, all intermediate results are also integer (as
well as the ﬁnal result)
∗Therefore we have to multiply with 5 ﬁrst, then divide by nine (multiplying
with (5/9) would eﬀectively multiply with 0)
Bit-wise, logical and operator comparison operators also normally also return
numeric values
Possible operands include variables, numerical (and other) constants, and function
calls
Note: In C, anynormal statement is an expression and has a value, including the
assignment!
Stephan Schulz 84
Simple Loops
Awhile-loop has the form
while(<expr>)
<body>
where <body> either can be a single statement, terminated by a semicolon ’ ;’,
or a statement block, included in curly braces ’{}’
It operates as follows:
–At the beginning of the loop, the controlling expression is evaluated
–If it evaluates to a non-zero value, the loop body is executed once, and control
returns to the while
–If it evaluates to 0, the body is skipped, and the program continues on the
next statement after the loop
Note: The body can also be empty (but this is usually a programming bug)
Stephan Schulz 85
Formatted Output
printf() is a function for formatted output
It has at least one argument (the format string ), but may have an arbitrary
number of arguments
–The control string may contain various placeholders, beginning with the
character %, followed by (optional) formatting instructions, and a letter (or
letter combination) indicating the desired output format
–Each placeholder corresponds to exactly one of the additional arguments
(modern compilers will complain, if the arguments and the control string do
not match)
–In particular, %3drequests the output of a normal intin decimal representation,
and with a width of atleast 3 characters
Note: printf() is not part of the C language proper, but of the (standardized)
C library
Stephan Schulz 86
UNIX User Commands: cp and mv
cpwill either copy one ﬁle to another, or it will copy any number of ﬁles into a
directory
–Usage: cp<ﬁle1> <ﬁle2>
Copy <ﬁle1>to<ﬁle2>
–Usage: cp<ﬁle1>. . .<ﬁlen> <dest>
Copy the named ﬁles into <dest>
mvwill likewise move ﬁles
–Usage: mv<ﬁle1> <ﬁle2>
Move <ﬁle1>to<ﬁle2>
–Usage: mv<ﬁle1>. . .<ﬁlen> <dest>
Move the named ﬁles into <dest>
Warning: Unless used with option -i, both commands will happily overwrite
existing ﬁles!
Again, a more complete description is available by man!
Stephan Schulz 87
Assignment(also see Website)
Write the following two C programs:
–celsius2fahrenheit should print a conversion table from Celsius to Fahren-
heit, from -50 to +150 degrees Celsius, in steps of 5 degrees
–imp metric should print two tables side by side (equivalent to a 4-column)
table, one for the conversion from yards into meters, the other one for the
conversion from km into miles. The output should use int values, but you
can use the ﬂoating point conversion factors of 0.9144 (from yards to meters)
and1.609344 from mile to km. Try to make the program round correctly!
Sample Output:
Yards Meters Km Miles
0 0 1 1
10 9 2 1
20 18 3 2
30 27 4 2
40 37 5 3
...
100 91 11 7
Stephan Schulz 88
CSC322
C Programming and UNIX
Programming in C
Extended Introduction
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Statements, Blocks, and Expressions
C programs are mainly composed of statements
In C, a statement is either:
–An expression, followed by a semicolon ’ ;’ (as a special case, an empty expres-
sion is also allowed, i.e. a single semicolon represents the empty statement)
–A ﬂow-control statement ( if,while ,goto ,break . . . )
–Ablock of statements (or compound statement ), enclosed in curly braces ’ {}’.
A compound statement can also include new variable declarations.
Note: The following is actually legal C (although a good compiler will warn you
that some of your statements have no eﬀect):
{
int a;
10+20;
10*(a=printf("Hello\n"));
}
Stephan Schulz 90
Flow-Control: if
The primary means for conditional execution in C is the ifstatement:
if(<expr>)
<statement>
–If the expression evalutes to a non-zero (“true”) value, then the statement will
be executed
–<statement> can also be a block of statements – in fact, it quite often is
good style to always use a block, even if it contains only a single statement
An if statement can also have a branch that is taken if the expression is zero
(“false”):
if(<expr>)
<statement>
else
<statement>
Stephan Schulz 91
Flow-Control: while
C supports diﬀerent structured loop constructs, including a standard while -loop
(see also example from last lesson):
while(<expr>)
<statement>
When control reaches the while at the top of the loop, the expression is tested
–If it evaluates to true (non-zero), the body of the loop is executed and control
returns to the while
–If it evaluates to false (i.e. zero), control directly goes to the statement
following the body of the loop
Note: An empty loop body is possible (and sometimes useful)
Again: In many cases it is recommended to use a block even if it contains only
one statement (or even no statements)
Stephan Schulz 92
Flow-Control: for
Thefor-loop in C is a construct that combines initialization, test, and update of
loop variables in one place:
for(<expr1>; <expr2>; <expr3>)
<statement>
–Before the loop is entered, <expr1> is evaluated
–Before each loop iteration, <expr2> is evaluated
∗If it is true, the body is executed, then <expr3> is evaluated and control
returns to the top of the loop
∗If it is false, control goes to the ﬁrst statement after the body
∗In the typical case, both <expr1> and<expr3> are assignments to the same
variable, while <expr2> tests some property depending on that variable
Stephan Schulz 93
Example
Here is the Fahrenheit/Celsius conversation using for:
/* A program that prints a Fahrenheit -> Celsius conversion table */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int fahrenheit, celsius;
printf("Fahrenheit -> Celsius\n\n");
for(fahrenheit=0; fahrenheit<=300; fahrenheit=fahrenheit+10)
{
celsius = (fahrenheit-32)*5/9;
printf("%3d %3d\n", fahrenheit, celsius);
}
return EXIT_SUCCESS;
}
Stephan Schulz 94
forvs.while
Note that foris more general than while:
while(<expr>) and for(;<expr>;)
<statement> <statement>
are equivalent.
Alternatively, you can achieve the functionality of forusing just while (how?)
The preference for one or the other often is a matter of personal choice
–If there are clear initialization and update steps, foris often more convenient
–In other cases, while is more natural
Stephan Schulz 95
Variable Declarations
Variable names:
–A valid variable name starts with a letter or underscore ( ), and may contain
any sequence of letters, underscores, and digits
–Capitalization is signiﬁcant – avariable is diﬀerent from AVariable
–In addition to the language keywords , certain other names are reserved (by the
standard library or by the implementation). In particular, avoid using names
that start with an underscore!
Variable declarations:
–A (simple) variable declaration has the form <type> <varlist>; , where
<type> is a type identiﬁer (e.g. int), and <varlist> is a coma-separated list
of variable names
–In ANSI-89 C, variables can only be declared outside any blocks or directly
after an open curly brace. The new standard relaxes this requirement
–A variable declared in a block is (normally) visible just inside that block
Stephan Schulz 96
Types: Integers and Characters
C has a large number of integer data types:
–It oﬀers char ,short ,int,long and (since the last language revision) long
long types, all of which may represent integers from diﬀerent ranges
–Note that in particular char is an integer data type, i.e. characters are
represented by their numerical encoding in the character set (normally ASCII)
–Any of those can be signed orunsigned , i.e. capable of representing positive
numbers only or both negative and positive numbers
–All types can be freely mixed in expressions
–Unsigned types always follow the rules of arithmetic modulo 2n, where nis
the width (in bits) of their representation (i.e. values greater than 2n−1are
reduced by subtracting 2nuntil the result is in the range 0−2n−1)
Integer constants are normally type intif they can be represented by that data
type
–123isint
–316L islong
–922U isunsigned int
Stephan Schulz 97
Integer Type Table
Type Alias Signed/Unsigned? Width(*)
char Implementation 8 bit
signed char Signed 8 bit
unsigned char Unsigned 8 bit
short int short Signed 16 bit
signed short int short Signed 16 bit
unsigned short int unsigned short Unsigned 16 bit
int Signed 32 bit
signed int int Signed 32 bit
unsigned int unsigned Unsigned 32 bit
long int long Signed 32 bit
signed long int long Signed 32 bit
unsigned long int unsigned long Unsigned 32 bit
long long int long long Signed 64 bit
signed long long int long long Signed 64 bit
unsigned long long int unsigned long long Unsigned 64 bit
Note (*): Width is notdeﬁned by the language standard but reﬂects currently
common implementation choices!
Stephan Schulz 98
Simple Character I/O
The C library deﬁnes the three I/O streams stdin ,stdout , and stderr , and
guarantees that they are open for reading or writing, respectively
Reading characters from stdin :int getchar(void)
–getchar() returns the numerical (ASCII) value of the next character in the
stdin input stream
–If there are no more characters available, getchar() returns the special value
EOF that is guaranteed diﬀerent from any normal character (that is why it
returns intrather than char
Printing characters to stdout :int putchar(int)
–putchar(c) prints the character con the stdout steam
–(It returns that character, or EOF on failure)
getchar() ,putchar() , and EOFare declared in <stdio.h>
Stephan Schulz 99
Example: File Copying
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int c;
c=getchar();
while(c!=EOF)
{
putchar(c);
c=getchar();
}
return EXIT_SUCCESS;
}
Copies stdin tostdout – to make a a ﬁle copy, use
cat ﬁle |ourcopy >newﬁle
Introduces !=(“not equal”) relational operator
Stephan Schulz 100
Example: File Copying (idiomatic)
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int c;
while((c=getchar())!=EOF)
{
putchar(c);
}
return EXIT_SUCCESS;
}
Remember: Variable assignments have a value!
Improvement: No duplication of call to getchar()
Stephan Schulz 101
Example: Character Counting
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int c;
long count = 0;
while((c=getchar())!=EOF)
{
count++;
}
printf("Number of characters: %ld\n", count);
return EXIT_SUCCESS;
}
New idiom: ++operator (increases value of variable by 1)
Test: $man cat |charcount
1091
Stephan Schulz 102
Exercises
Write a programm that continually increases the value of a short and a
unsigned short variable and prints both (you can use printf("%6d %6u",
var1, var2); to print them). What happens if you run the programm for some
time? You can pipe the output into lessand search for interesting things ( man
less to learn how!). Remember that [C-c] will terminate most programs under
UNIX!
Write a program that counts lines in the input. Hint: The standard library makes
sure that any line in the input ends with a newline (’ \n’)
Write a program that computes the factorial of a number (given as a constant in
the program). Test it for values of 3, 18, and 55. Any observations?
Stephan Schulz 103
CSC322
C Programming and UNIX
Programming in C
More on Expressions
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Nomination: Most Useless Use of catAward
Ifourcopy is a program that just copies stdin tostdout , then
–cat ﬁle |ourcopy >newﬁle will indeed copy ﬁletonewﬁle
–So will ourcopy <ﬁle>newﬁle
–(So will cat<ﬁle>newﬁle )
Stephan Schulz 105
UNIX User Commands: wc
Usage: wc<ﬁle1>...
wccounts the bytes, words and lines in each ﬁle speciﬁed (or in stdin if none is
given) and print the results, including the total for all input ﬁles.
Important options:
–-c: Print just the byte count
–-w: Print just the word count
–-l: Print just the line count
Example:
$wc<wordcount.c
24 53 369
Notice: The program does not print unnecessary headers or footers. The output
can easily be interpreted by other programs!
More: man wc
Stephan Schulz 106
Example: Word Counting
/* Count words */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int c, in_word=0;
long words = 0;
while((c=getchar())!=EOF)
{
if(c == ’ ’ || c == ’\n’ || c == ’\t’)
{
in_word = 0;
}
else if(!in_word)
{
in_word = 1;
words++;
}
}
printf("%ld words counted\n", words);
return EXIT_SUCCESS;
}
Stephan Schulz 107
Character Constants
In C, characters are just small integers
We can write character constants symbolically, by enclosing them in single quotes:
–’a’is the numerical value of a lower case ain the character encoding (97 for
ASCII)
–’A’is upper case A(65 for ASCII)
–These values can be assigned to any integer variable!
You can use escape sequences (starting with \) for non-printable characters:
–\tis the tabulator character (HT), ASCII 9
–\nis the newline character (LF), ASCII 10 (and used by C to mark the end of
the current line)
–\ais the BEL character, printing it will normally make the terminal beep
–\0is the NULcharacter, ASCII 0, and used by C to mark the end of a string
–\\is the backslash itself, ASCII 92
You can get all C escape sequences (and more) via man ASCII
Stephan Schulz 108
Another View at Expressions
Expressions are build from operators andoperands , with parentheses for grouping
–Most operators are unary (taking one operand) or binary (taking two)
–Operands can be
∗(Sub-)Expressions
∗Constants
∗Function calls
–In C, binary operators are written in inﬁx, i.e. between the operands: 10+15
–Unary operators are written either in preﬁx or postﬁx (some can even be
written either way, with slightly diﬀerent eﬀects)
All operators have a precedence , deﬁning how to interprete operations with
multiple operators
–In the absence of parentheses, operators with a higher precedence bind tighter
than those with a lower precedence: 10+3*4 == 22 is true, 10+4*3==42 is
false
–In doubt, we can always fully parenthesize expressions: 10+3*4 == 10+(3*4) ,
but(10+4)*3==42
Stephan Schulz 109
Expressions: Associativity of Binary Operators
Binary operators have an additional property: Associativity
–Example: 25+12+11 can be interpreted as (25+12)+11 or as 25+(12+11)
Stephan Schulz 110
Expressions: Associativity of Binary Operators
Binary operators have an additional property: Associativity
–Example: 25+12+11 can be interpreted as (25+12)+11 or as 25+(12+11)
–Worse: What about 25-12-11?
By convention, standard arithmetic operators are left-associative , i.e. the bind to
the left
–Thus: 25-12-11 == (25-12)-11 has the value 2
We will note associativity for many operators speciﬁcally, but unless otherwise
noted, it’s probably left-associative!
Stephan Schulz 111
Expressions: Relational Operators
Relational operators take two arguments and return a truth value (0 or 1)
We already have seen the equational operators. They apply to all basic data
types and pointers:
–a == b (equal ) evaluates to 1 if the two arguments have the same value,
otherwise it evaluates to 0
–a != b evaluates to 1 if the two arguments have diﬀerent values
–Note: a == b == c is evaluated as (a == b) == c , i.e. it compares cto
either 0 or 1!
We can also compare the same types using the greater/lesser relations:
–>evaluates to 1, if the ﬁrst argument is greater than the second one
–<evaluates to 1, if the second argument is greater than the ﬁrst one
–a >= b evaluates to 1, if either a > b == 1 or(a == b) ==1
–a <= b evaluates to 1, if either a < b == 1 or(a == b) == 1
Precedence rule: The relational operators have lower precedence than the arith-
metic ones ( a+1 < 2*b makes sense)
Stephan Schulz 112
Expressions: Logical Operators
Logical operators operate on truth values, i.e. all non-zero values are treated the
same way (representing true)
The binary logical operators are ||and&&
–a||b evaluates to 1, if at least one of aorbis non-zero (otherwise it evaluates
to 0)
–a&&b evaluates to 1, if both aandbare non-zero
–Both ||and&&are evaluated left-to-right, and the evaluation stops as soon
as we can be sure of the result (short-circuit evaluation)
∗Example: If a!=b , then (a==b)&&c will not evaluate c
∗Similarly: (a==0 || 10/a >= 1) will never divide by zero!
!is the (unary) logical negation operator, !aevaluates to 1, if ahas the value
0, it evaluates to 0 in all other cases
Precedence rules:
–The binary logical operators have lower precedence than the relational ones
–||has lower precedence than &&
–!has a higher precedence than even arithmetic operators
Stephan Schulz 113
Expressions: Assignments
Theassignment operator is=(a single equal sign)
–a = b is an expression with the value of b
–As a side eﬀect , it will change the value of ato that same value
The expression on the left hand side of an assignment ( a) has to be an lvalue ,
i.e. something we can assing to. Legal lvalues are
–Variables
–Dereferenced pointers (“memory locations”)
–Elements in a struct, union, or array
The assignment operator is right-associative (so you can write
a = b = c = d = 0; to set all for variables to zero)
The assignment operator has extremely low precedence (lower than all other
operators we have covered up to now)
Stephan Schulz 114
Floating Point Numbers
C supports three types of ﬂoating point numbers, float ,double , and long
double
–float is the most memory-eﬃcient representation (typically 32 bits), but has
limited range and precision
–double is the most commonly used ﬂoating point type. In particular, most
numerical library functions accept and return double arguments. Doubles
normally take up 64 bits
–long double oﬀers extended range and precision (sometimes using 128 bits)
and is a recent addition
Floating point constants are written using a decimal point, or exponential notation
(or both):
–1.0is a ﬂoating point constant
–1is an integer constant. . .
–. . . but 1e0and1.0E0 are both ﬂoating point constants
If we mix integer and ﬂoating point numbers in an expression, a value of a
“smaller” type is converted to that of the bigger one transparently:
–9/2 == 4 , but 9/2.0 == 4.5 and9.0/2 == 4.5
Stephan Schulz 115
Fahrenheit to Celsius – More Exactly
/* A program that prints a Fahrenheit -> Celsius conversion table */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int fahrenheit;
double celsius;
printf("Fahrenheit -> Celsius\n\n");
for(fahrenheit=0; fahrenheit<=300; fahrenheit=fahrenheit+10)
{
celsius = (fahrenheit-32.0)*5.0/9.0;
printf("%3d %7.3f\n", fahrenheit, celsius);
}
return EXIT_SUCCESS;
}
Remark: The %7.3f conversion speciﬁcation prints a float ordouble with a
total width of 7 characters and 3 fractional digits
Stephan Schulz 116
Administrative Notes
Please sshtolee.cs.miami.edu to use the lab machines over the net.
To change your password on the lab machines, use yppasswd . Also check
http://www.cs.miami.edu/~irina/password.html for the password policy
To submit programming assignments, create a subdirectoy with the name
ASSIGNMENT <no> (where <no> is the number of the current assigment) and
copy the relevant ﬁles to it
Example: To submit the current assignment, do e.g.
$cd∼(go home)
$mkdir ASSIGNMENT 2
$cp mystuﬀ/celsius2fahrenheit* ASSIGNMENT 2
$cp mystuﬀ/imp metric* ASSIGNMENT 2
Stephan Schulz 117
Excercises
Expand the word count program to count characters, words, and lines (of stdin )
aswcdoes
Write a program that prints useful imperial to metric (and back) conversion
tables to a reasobale precision
Stephan Schulz 118
CSC322
C Programming and UNIX
Programming in C
Simple Arrays and Functions
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Arrays
Aarray is a data structure that holds elements of one type so that each element
can be (eﬃciently) accessed using an index
In C, arrays are always indexed by integer values
Indices always run from 0 to some ﬁxed, predetermined value
<type> <var> [<elements>]; deﬁnes a variable of an array type:
–<type> can be any valid C type, including user-deﬁned types
–<var> is the name of the variable deﬁned
–<elements> is the number of elements in the array (Note: Indices run from 0
to<elements> -1)
Example: char x[10]; deﬁnes the variable x to hold 10 elements of type char ,
x[5] accesses the 5th element of that array
Stephan Schulz 120
Example: Counting Character Frequencies
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
int main(void)
{
int freq_count[128];
int i, c;
for(i=0; i<128; i++)
{
freq_count[i] = 0;
}
while((c=getchar())!=EOF)
{
if(c <= 127) /* Ignore non-ASCII */
{
freq_count[c]++;
}
}
Stephan Schulz 121
Example: Counting Character Frequencies (Contd.)
for(i=0; i<128; i++)
{
if(isprint(i))
{
printf("%c: %d\n", i, freq_count[i]);
}
}
return EXIT_SUCCESS;
}
Remark: isprint(i) is true, if iis a printable character. It is deﬁned in
ctype.h
Stephan Schulz 122
Initializing Arrays
In the example, we used an explicit loop to initialize the array
For short arrays we can also list the initial values in the deﬁnition of the array:
–int days per month[12] = {31,28,31,30,31,30,31,31,30,31,30,31 };
–The number of values has to be smaller than or equal to the number of
elements in the array
–Unspeciﬁed elements are initialized to all bits zero , (i.e. 0 for all basic data
types)
If we give an explicit intializer, we can omit the size of the array:
–int days per month[] = {31,28,31,30,31,30,31,31,30,31,30,31 };
–The compiler will automatically allocate an array of suﬃcient size to hold all
the values in the initializer
Stephan Schulz 123
Array Layout
C arrays are implemented as a sequence of consequtive memory locations of the
right size to hold the element
Example:
Address Array Element Content
0
. . .
112 Other data
120 days per month[0] 31
124 days per month[1] 28
128 days per month[2] 31
132 days per month[3] 30
136 days per month[4] 31
140 days per month[5] 30
144 days per month[6] 31
148 days per month[7] 31
152 days per month[8] 30
156 days per month[9] 31
160 days per month[10] 30
164 days per month[11] 31
168 Other data
. . .
Stephan Schulz 124
No Safety Belts and No Air Bag!
C does not check if the index is in the valid range!
–If you access days per month[13] you might change some critical other data
–The operating system may catch some of these wrong accesses, but do not
rely on it!)
This is source of many of the buﬀer-overﬂow errors exploited by crackers and
viruses to hack into systems!
Stephan Schulz 125
Character Arrays
Character arrays are the most frequent kind of arrays used in C
–They are used for I/O operations
–They are used for implementing string operations in C
To make the use of character arrays easier, we can use string constants to
initialize them. The following deﬁnitions are equivalent:
–char hello[] = {’H’,’e’,’l’,’l’,’o’,’\0’};
–char hello[] = "Hello";
–char hello[6] = "Hello";
Notice that the string constant is automatically terminated by a NUL character!
Stephan Schulz 126
Functions
Functions are the primary means of structuring programs in C
A function is a named subroutine
–It accepts a number of arguments, processes them, and (optionally) returns a
result
–Functions also may have side eﬀects , like I/O or changes to global data
structures
–In C, any subroutine is called a function , wether it actually returns a result or
is only called for its side eﬀect
Note: A function hides its implementation
–To use a function, we only need to know its interface, i.e. its name, parameters,
and return type
–We can improve the implementation of a function without aﬀecting the rest of
the program
Function can be reused in the same program or even diﬀerent programs, allowing
people to build on existing code
Stephan Schulz 127
Function Deﬁnitions
A function deﬁnition consists of the following elements:
–Return type (or void ) if the function does not return a value
–Name of the function
–Parameter list
–Function body
The name follows the same rules as variable names
Theparameter list is a list of coma-separated pairs of the form <type> <name>
The body is a sequence of statements included in curly braces
Example:
int timesX(int number, int x)
{
return x*number;
}
Stephan Schulz 128
Function Calling
A function is called from another part of the program by writing its name,
followed by a parenthesized list of arguments (where each argument has to have
a type matching that of the corresponding parameter of the function)
If a function is called, control passes from the call of the function to the function
itself
–The parameters are treated as local variables with the values of the arguments
to the call
–The function is executed normally
–If control reaches the end of the function body, or a return statement is
executed, control returns to the caller
–Areturn statement may have a single argument of the same type as the
return type of the function. If the statement is executed, the argument of
return becomes the value returned to the caller
We can only call functions that have already been declared or deﬁned at that
point in the program!
Stephan Schulz 129
Example: Printing Character Frequencies
int print_freq(char c, int freq)
{
int i;
printf("%c :", c);
if(freq < 75)
{
for(i=0; i<freq; i++)
{
putchar(’#’);
}
}
else
{
printf("#....(%d)...#",freq);
freq = -1;
};
printf("\n", c);
return freq;
}
Stephan Schulz 130
Example: Printing Character Frequencies (contd.)
Assume that the previous function deﬁnition is inserted into the frequency
counting program just in front of the int main(void) line
We can then modify main as follows:
...
for(i=0; i<128; i++)
{
if(isprint(i))
{
print_freq(i, freq_count[i]);
}
}
return EXIT_SUCCESS;
}
The program will then print frequency histograms instead of just numbers
Stephan Schulz 131
Exercises
Rewrite the Fahrenheit →Celsius Program to use a function for the actual con-
version
Stephan Schulz 132
Assignment
A prime number is a (positive integer) number that is evenly divisible only by 1
and itself
1.Write a function isprime() that determines if an integer number is prime.
You can use the %modulus operator (division rest on integers) or work with
plain division. Use your function to implement a program primes simple
that prints all primes between 0 and 10000.
2.TheSieve of Erathostenes is a more eﬃcient (and ancient) algorithm for
ﬁnding all primes up to a given number. It starts with a list of all numbers
from 2 to the desired limit. It traverses this list, starting at two. Whenever
it encounteres a new number, it strikes all multiples of it from the list. What
remains at the end is a list of prime numbers.
Example:
Initial list: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
Striking multiples of 2: 2 3 5 7 9 11 13 15
Striking multiples of 3: 2 3 5 7 11 13
(There are no multiples of any remainig number, so we skip the rest)
Use the Sieve algorithm in a second program, primes sieve , that prints all
primes between 0 and 10000. Hint: Use an array!
Stephan Schulz 133
CSC322
C Programming and UNIX
Programming in C
More on Functions
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Review of Function Properties
Afunction is a named subroutine
It accepts a number of arguments of a predetermined type and returns a value of
a given type
It can have its own local variables
A function can be called from other places in the program, including other
functions
Functions have to be known (either deﬁned or declared) before they can be called
Stephan Schulz 135
Example: Reading Integers
We want to write a function that reads a positive integer number from stdin ,
using only getchar()
A number is deﬁned as a sequence of decimal digits (characters from the range
’0’to’9’
–We can use the function isdigit(c) from ctype.h to test if a character is a
(decimal) digit
–The C standard guarantees that ’0’ to ’9’ have consecutive numerical values.
We can thus get the value of a single character cthat represents a digit by
the expression c-’0’
Idea: We read the most signiﬁcant digits ﬁrst. So whenever we read a new digit,
the value of what we have read so far increases 10-fold:
Read Value
1 1
13 10*1+3 = 13
137 10*13+7 = 137
1375 10*137+5 = 1375
Stephan Schulz 136
Example: int read int10(void)
/* We assume that stdio and ctype have been included */
/* A function that reads a positive integer number in base 10 from
* stdin. Return number or -1 on failure. Will read one character
* ahead! */
int read_int10(void)
{
int res = 0, c, count=0;
while(isdigit(c=getchar()))
{
res = (res*10)+c-’0’;
count++;
}
if(count > 0) /* We read something */
{
return res;
}
return -1;
}
Stephan Schulz 137
Improving the Function
read int10(void) works ﬁne, but can only read number in decimal notation
We want to have a function that can read numbers in any base between 2 and
10 now
Examples:
–142 in base 8 has the value 1∗82+ 4∗81+ 2∗80= 1∗64 + 4 ∗8 + 2 = 98
–101010 in base two has the value 1∗25+0∗24+1∗23+0∗22+1∗21+0∗20=
32 + 8 + 2 = 42
–1873 is not a valid number in base 6! All digits have to be smaller than the
base
The principle is the same, we just use a parameter base instead of the hardwired
value 10!
Stephan Schulz 138
Do we have a Valid Digit?
/* Is a character a valid digit in base b? */
int is_base_digit(int c, int base)
{
if(c - ’0’ < 0)
{
return 0;
}
if(c - ’0’ >= base)
{
return 0;
}
return 1;
}
Stephan Schulz 139
Reading a Number in any Base ( <=10)
/* A function that reads a positive integer number in any base from stdin */
int read_int_b(int base)
{
int res = 0, c, count = 0;
res = 0;
while(is_base_digit((c=getchar()),base))
{
res = (res*base)+c-’0’;
count++;
}
if(count > 0) /* We read something */
{
return res;
}
return -1;
}
Stephan Schulz 140
Build General Functions!
Good programs are build by breaking the task into many functions that are:
–Small – at most one screen page (in your favourite editor)
–Simple – they only do one thing, and they do that well
–General – so that they can be reused at other parts in the program
Going from general to speciﬁc is (generally) easy:
/* Alternative to read_int10 */
int read_int10b(void)
{
return read_int_b(10);
}
Stephan Schulz 141
Recursive Functions
As we stated above, functions can call other functions. They can also call
themselves recursively
A recursive function always has to handle at least two cases:
–The base case handles a simple situation without further calls to the same
function
–Therecursive cases may do some work, and in between make recursive calls to
the function for smaller (in some sense) subtasks
Recursion is one of the most important programming principles!
Stephan Schulz 142
Example: Printing Integers
We now want to print positive integer numbers to stdout , using only putchar()
Consider a number in base 10: 421 = 42 ∗10 + 1
We can split the task into two subtasks:
–Print everything but the last digit (recursively)
–Print the last digit
Base case: There are no digits to print any more
Basic operations:
–To get the last digit, we use the modulus operator %
–To get rid of the last digit, we divide the number by the desired base (remember,
integer division truncates)
Stephan Schulz 143
Example: Decimal Representation of 421
Let’s do an example: We want to print the number 421 in base 10
–Step 1: 421%10 = 1 and421/10 = 42 . Hence the last number to print is 1
and the rest we still have to print is 42
–Step 2: 42%10 = 2 and42/10 = 4 . The second last digit is 2, the rest is 4
–Step 3: 4%10 = 4 and4/10 = 0 . The next digit is 4
–Step 4: Our rest is 0, hence there is nothing to do but printing the digits in
the right order
The same principle applies for other bases (just replace 10 by your base)
Stephan Schulz 144
Writing a Number in any Base ( <=10)
/* Write non-zero positive integer in any base to stdout */
void write_int_b_rekursive(int value, int base)
{
int digit;
digit = value % base;
value = value/base;
if(value!=0)
{
write_int_b_rekursive(value, base);
}
putchar(digit + ’0’);
}
Problem: What happens if the input is 0?
(Answer: It works ﬁne, but by accident, not by design!)
Stephan Schulz 145
Writing Integers (Contd.)
We can wrap the simple recursive function to handle the abnormal case (but, as
we saw on the last slide, we don’t need to):
/* Write positive integer in any base to stdout */
void write_int_b(int value, int base)
{
if(value == 0)
{
putchar(’0’);
}
write_int_b_rekursive(value, base);
}
Stephan Schulz 146
Putting Things Together: A Base Converter
We now use the deﬁned function to write a program that reads pairs number
base and prints them back in the new base :
–number is considered to be a decimal number
–base should be a decimal number between 2 and 10 (inclusive)
–Numbers and pairs are separated by a single, arbitrary character (including
space and newline)
–The program terminates, if one of the numbers is invalid
Stephan Schulz 147
The Base Converter
int main(void)
{
int num, base;
while(1)
{
printf("Input decimal value and desired base!\n");
num = read_int10();
if(num == -1)
{
return EXIT_SUCCESS;
}
base = read_int10();
if(base == -1 || base < 2 || base > 10)
{
printf("Error: No valid base!\n");return EXIT_FAILURE;
}
write_int_b(num, base);
putchar(’\n’);
}
}
Stephan Schulz 148
Usage Example
$./base converter
Input decimal value and desired base!
123123 3
20020220010
Input decimal value and desired base!
42 10
42
Input decimal value and desired base!
42 Hallo!
Error: No valid base!
$
Stephan Schulz 149
Exercise
Extend the base converter to work with base 16, using 0-9 and A-F as digits
(allow both upper and lower case!)
Extend the base converter to accept tripplets input-base,value,outputbase ,
where value is interpreted in input-base (and input-base is a single hexadecimal
digit >=2). Add reasonably robust error handling!
The complete base converter code from the lecture is available from the CSC322
web page or directly at http://www.cs.miami.edu/~schulz/CSC322/base_
converter.c
Stephan Schulz 150
CSC322
C Programming and UNIX
Programming in C
Program Structure and the C Preprocessor
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Simple Program Structure
Headers
(Declarations)
ExecutableC Preprocessor
Sources
(Definitions)
Is combibed intoCompiler
Stephan Schulz 152
Program Structure In Detail
Files Library
RTE
(Shared libs)ObjectHeaders
(Declarations)
System System
Library
ExecutableC Preprocessor
Sources
(Definitions)
Includes
Translates into
Is combibed intoCompiler
Linker
Stephan Schulz 153
Program Structure for Multi-File Programs
FilesObject
FilesObject
Files Files Files Library
RTE
(Shared libs)Headers Headers Headers
(Declarations) (Declarations) (Declarations)
Object Object ObjectHeaders
(Declarations)
System System
Library
ExecutableC Preprocessor
Compiler
LinkerSources
(Definitions)Sources
(Definitions)Sources
(Definitions)
Includes
Translates into
Is combibed into
Stephan Schulz 154
The C Preprocessor
The C preprocessor performs a textual rewriting of the program text before it is
ever seen by the compiler proper
–It includes the contents of other ﬁles
–It expands macro deﬁnitions
–It conditionally processes or removes segments of the program text
Preprocessor directives start with a hash #and traditionally are written starting
in the very ﬁrst column of the program text
After preprocessing, the program text is free of all preprocessor directives
Normally, gccwill transparently run the preprocessor. Run gcc -E <file> if you
want to see the preprocessor output
Stephan Schulz 155
Including Other Files: #include
The#include directive is used to include other ﬁles (the contents of the named
ﬁle replaces the #include directive)
Form 1: #include "file"
–The preprocessor will search for file in the current directory
–What happens if ﬁle is not found in the current directory, is implementation-
deﬁned
∗UNIX compilers will typically treat ﬁleas a pathname (that may be either
absolute or relative)
∗If the ﬁle is not found, the compiler prints an error message and aborts
Form 2: #include <file>
–file will be searched for in an implementation-deﬁned way
–UNIX compilers will typically treat file as a ﬁle name relative to the system
include directory ,/usr/include on the lab machines
–You can add to the list of directories that will be searched using
gcc -I <includedir>
Stephan Schulz 156
Example: Include
myﬁle.c:
A Poem
#include "mary"mary:
Mary had a little lamb,
Its fleece was white as snow;
And everywhere that Mary went
The lamb was sure to go.
$gcc -E myﬁle.c
# 1 "myfile.c"
A Poem
# 1 "mary" 1
Mary had a little lamb,
Its fleece was white as snow;
And everywhere that Mary went
The lamb was sure to go.
# 4 "myfile.c" 2
Stephan Schulz 157
Include Discussion
Include directives are typically used for sharing common declarations between
diﬀerent program parts
Libraries (including the standard library) come with header ﬁles that deﬁne their
interface by
–Deﬁning data types and constants
–Declaring functions (and deﬁning macros)
–Declaring variables
Note that included ﬁles can contain further #include statements (that will be
automatically expanded by the preprocessor)
–This is frequent in system ﬁles, where the standard-prescribed include ﬁles
often include system-speciﬁc ﬁles actually describing the features
Stephan Schulz 158
Simple Macro Deﬁnitions: #define
The #define directive is used to deﬁne macros
Simple Form: #define <name> <replacement text>
–This will deﬁne a macro for <name> , which has to follow the common rules for
C identiﬁers (alphanumeric characters and underscore, should not start with a
digit)
–Any normal occurence of <name> after the deﬁnition will be replaced by
<replacement text>
–Replacement will not take place in strings!
–The macro deﬁnition normally ends at the end of the line, however, it can be
extended to the next line by appending \as the very last character of the line
Note that macro expansion even takes place within further macro deﬁnitions!
Most common use: Symbolic constants (e.g. EOF)
Stephan Schulz 159
Simple #define Example
reality.c:
#define true 1
#define false 0
void reality_check(void)
{
if(true == false)
{
printf("Reality is broken!\n");
}
}
$gcc -E reality.c
# 4 "reality.c"
void reality_check(void)
{
if(1 == 0)
{
printf("Reality is broken!\n");
}
}
Stephan Schulz 160
Macros with Arguments
Macro deﬁnitions can also contain formal arguments
#define <name>(arg1,...,arg1) <replacement text>
If a macro with arguments is expanded, any occurence of a formal argument in
the replacement text is replaced with the actual value of the arguments in the
macro call
This allows a more eﬃcient way of implementing small “functions”
–But: Macros cannot do recursion
–Macro calls have slightly diﬀerent semantics from function calls
–Therefore macros are usually only used for very simple tasks
By convention, preprocessor deﬁned constants and many macros are written in
ALL CAPS (using underscores for structure)
Stephan Schulz 161
#define Examples
macrotest.c:
#define XOR(x,y) ((!(x)&&(y))||((x)&&!(y))) /* Exclusive or */
#define EQUIV(x,y) (!XOR(x,y))
void test_macro(void)
{
printf("XOR(1,1) : %d\n", XOR(1,0));
printf("EQUIV(1,0): %d\n", EQUIV(1,0));
}
$gcc -E reality.c
# 4 "macrotest.c"
void test_macro(void)
{
printf("XOR(1,1) : %d\n", ((!(1)&&(0))||((1)&&!(0))));
printf("EQUIV(1,0): %d\n", (!((!(1)&&(0))||((1)&&!(0)))));
}
Stephan Schulz 162
#define Caveats
Since macros work by textual replacement, there are some unexpected eﬀects:
–Consider #define FUN(x,y) x*y + 2*x
∗Looks innocent enough, but: FUN(2+3,4) expands into 2+3*4+2*2+3 (not
(2+3)*4+2*(2+3) )
∗To avoid this, always enclose each formal parameter in parentheses (unless
you know what you are doing)
–Now consider FUN(var++,1)
∗It expands into x++*1 + 2*x++
∗Macro arguments may be evaluated more than once!
∗Thus, avoid using macros with expressions that have side eﬀects
Other frequent problems:
–Semicolons at the end of a macro deﬁnition ( wrong! )
–“Invisible” syntax errors (run gcc -E and check the output if you cannot locate
an error)
Stephan Schulz 163
Conditional Compilation: #if/#else/#endif
We can use preprocessor directives to conditionally include or exclude parts of
the program:
–Program parts may be enclosed in #if <expr> /#endif pairs
–<expr> has to be a constant integer expression
–If it evaluates to 0, the text in the #if <expr> /#endif bracket is ignored,
otherwise it is included
–There also is an optional #else “branch”
Most frequent use: Test for the deﬁnition of macros
–defined(<macro>) evaluates to 1 if <macro> is deﬁned (even as the empty
string), 0 otherwise
–Short form: #if defined(<macro>) is equivalent to #ifdef <macro> ,
#if !defined(<macro>) is equivalent to #ifndef <macro> ,
–E.g.: #ifndef EOF
#define EOF -1
#endif
Stephan Schulz 164
Example: #ifdef
cond preproc.c:
#define hallo
#define fred barney
#define test 2+2
#if defined(hallo)
"Hallo"
#else
#ifdef fred
"Fred"
#endif
#endif
#if test
"test"
#endif
$gcc -E cond preproc.c
# 5 "cond_preproc.c"
"Hallo"
"test"
Stephan Schulz 165
Exercises
Search the /usr/include directory (use grep for faster progress) and ﬁnd out
where the following functions/macros are deﬁned, and, for the macros, what
their value is
–LONG MAX
–ULONG MAX
–getchar()
–getc()
–EOF
–EXIT FAILURE
–EXIT SUCCESS
–NULL
Stephan Schulz 166
CSC322
C Programming and UNIX
Programming in C
C Preprocessor/Declarations and Scoping
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Conditional Compilation: #if/#else/#endif
We can use preprocessor directives to conditionally include or exclude parts of
the program:
–Program parts may be enclosed in #if <expr> /#endif pairs
–<expr> has to be a constant integer expression
–If it evaluates to 0, the text in the #if <expr> /#endif bracket is ignored,
otherwise it is included
–There also is an optional #else “branch”
Most frequent use: Test for the deﬁnition of macros
–defined(<macro>) evaluates to 1 if <macro> is deﬁned (even as the empty
string), 0 otherwise
–Short form: #if defined(<macro>) is equivalent to #ifdef <macro> ,
#if !defined(<macro>) is equivalent to #ifndef <macro> ,
–E.g.: #ifndef EOF
#define EOF -1
#endif
Stephan Schulz 168
Example: #ifdef
cond preproc.c:
#define hallo
#define fred barney
#define test 2+2
#if defined(hallo)
"Hallo"
#else
#ifdef fred
"Fred"
#endif
#endif
#if test
"test"
#endif
$gcc -E cond preproc.c
# 5 "cond_preproc.c"
"Hallo"
"test"
Stephan Schulz 169
More on Preprocessor Deﬁnitions
You can use #undef <name> to get rid of a deﬁnition
–This is most often used to start from a clean slate:
#undef true
#undef false
#define true 1
#define false 0
–It is, however, forbidden to undeﬁne implementation-deﬁned names
You can use the -Doption to gccto cause certain names to be deﬁned throughout
the process
–This is often used to select one of many alternatives for compilation
∗With or without internal consistency checkes
∗With or without certain features (e.g. Demo version vs. commercial version)
∗. . .
Certain names may be predeﬁned by the implementation (most starting with two
underscores: __FILE__ ,__STDC__ . . . )
Stephan Schulz 170
Combinations of #ifdef and #include
#ifdef/endif also can be used to conditionally include or exclude ﬁles
Usage: Compile for diﬀerent operating systems:
#ifdef __LINUX__
#include "linux.h"
#elif defined(__BSD__)
#include "bsd.h"
#else
#include "default.h"
#endif
Usage: Guarding against multiple inclusions
#ifndef THIS_HEADER
#define THIS_HEADER
<lots of stuff>
#endif
Stephan Schulz 171
Separate Compilation
C supports the separate compliation of multiple source ﬁles
–Each source ﬁle is translated into an object ﬁle
–Alinker combines diﬀerent object ﬁles into the ﬁnal executable
gccby default tries to create an executable program by performing operations as
follows:
1.Preprocessing
2.Compilation (and assembly)
3.Linking
For multi-ﬁle programs, we have to perform separate compilation:
–gcc -c ﬁle.c -o ﬁle.o will compile ﬁle.c intoﬁle.o without linking
–gcc -o progname ﬁle1.o ﬁle2.o ﬁle3.o will link the three precomiled object
ﬁles into an executable
Stephan Schulz 172
Deﬁnitions and Declarations
Deﬁnitions cause the deﬁned objects to be created
–Variable deﬁnitions allocate an appropriate amount of memory (and associate
it with the variable name)
–Function deﬁnitions cause code to be generated
Declarations only state information about an object
–For variables, they state the type
–For functions, the state return type and argument types
There can be any number of compatible declarations for an object
There can be only one deﬁnition for the object
A function or variable can only be used inside the scope of a matching declaration
Any deﬁnition also implicitly declares an object
Stephan Schulz 173
Explicit Declarations
Variables can be declared by adding the extern keyword to the syntax of a
deﬁnition:
–extern int counter;
–extern char filename[MAXPATHLEN];
Function declarations just consist of the function header, terminated by a semi-
colon:
–int isdigit(int c);
–int putchar(int c);
–bool TermComputeRWSequence(PStack p stack,Term p from,Term p to);
Alternatively, the names of the formal parameters can be omitted
–int isdigit(int);
–int putchar(int);
–bool TermComputeRWSequence(PStack p,Term p,Term p);
–However, the ﬁrst form is often preferred because the paramter names may
document the purpose of the parameter
Stephan Schulz 174
Scoping Rules
There are two kinds of declarations in C
–Declarations written inside a block are called local declarations
–Declarations outside any block are global declarations
The scope of a local declaration begins at the declaration and ends at the end of
the innermost enclosing block
The scope of a global declaration begins at the declaration and continues to the
end of the source ﬁle
–Note that this refers to ﬁles after preprocessing, i.e. a declaration in a header ﬁle
also is visible in the including ﬁle (from the point of the #include statement)
Stephan Schulz 175
Scope Example
| extern int global_count;
|
||| int abs_val ( double number )
||| {
|||| double help = number;
||||
|||| if(number < 0)
|||| {
|||| help = -1 * help;
|||| global_count++;
|||| }
||||}
||
||| int main()
||| {
||| printf("\%7f\n", abs_val(-1.0));
||| }
|||
||| int global_count;
Stephan Schulz 176
Limiting Potential Scope
By default, all declared variables and functions are accessible from any source ﬁle
in the program
–Of course, they may have to be declared to be visible
Problems: We have no control over the use of these objects in other source ﬁles
–Reuse of libraries may fail because of namespace polution
–Unintentional or malicious misuse of internal functions may lead to program
misbehaviour
The static keyword, applied to a global deﬁnition (or declaration), limits the
accessibility of the declared object to the source ﬁle it is deﬁned in
–static int internal help fun(int a1, int a2);
In general, it is a good idea to declare everything not expected to be used by
other program part static
Stephan Schulz 177
Lifetime and Initialization of Variables
Global variables have unlimited lifetime
–They are created and initialized when the program starts
–The expression used in the initialzation has to be constant , i.e. it has to be
fully evaluable at compile time
–If not explicitly initialized, they are guaranteed to be initialized to 0
–They keep their values until the program terminates (unless explicitely changed,
of course)
Most local variables (and function parameters) only have limited lifetime
–They are also called automatic variables and are typically allocated on the
stack
–They are created when the variable comes into scope and are destroyed when
the variable goes out of scope – in particular, each recursive call gets a fresh
copy of the variable
–The initializing expression can use all variables and functions currently in scope
–They are reinitialized every time they come into scope, if not initialized
explicitly, they contain undeﬁned values (“junk”)
Stephan Schulz 178
Persistent Local Variables: static again
static local variables have unlimited lifetime
–They are initalized the very ﬁrst time they come into scope
–They are shared between diﬀerent calls to the same function
–They keep their values in between calls
–However, they can only be accessed from inside their corresponing block
Stephan Schulz 179
Example: Static and Automatic Variables
#include <stdio.h>
#include <stdlib.h>
static int global_count = 0;
void counter_fun(void)
{
static int static_count = 0;
int auto_count = 0;
int pseudo_count = global_count;
global_count++; auto_count++; static_count++; pseudo_count++;
printf("Global: %3d Auto: %3d Static: %d Pseudo: %d\n",
global_count,auto_count, static_count, pseudo_count);
}
int main(void)
{
counter_fun();
counter_fun();
global_count = 0;
counter_fun();
counter_fun();
return EXIT_SUCCESS;
}
Stephan Schulz 180
Example: Static and Automatic Variables(Contd.)
$gcc -o vartest vartest.c
$./vartest
Global: 1 Auto: 1 Static: 1 Pseudo: 1
Global: 2 Auto: 1 Static: 2 Pseudo: 2
Global: 1 Auto: 1 Static: 3 Pseudo: 1
Global: 2 Auto: 1 Static: 4 Pseudo: 2
$
Stephan Schulz 181
Assignment
Write a data safe library oﬀering the following functionality:
–Calling data safe(ds register, 0, 0) will return a unique random key (a
positive integer). Use rand() to generate random numbers (and man rand
to ﬁnd out how).
–Calling data safe(ds store, key, value) will store the value (a positive
integer) in the data safe (under the key). It should return the value if everything
worked, -1 otherwise (e.g. if there is no space left)
–Calling data safe(ds retrieve, key, n) will retrieve the nthvalue stored
under the key, or -1 if less then nvalues have been stored under the key
–Calling data safe(ds delete, key, 0) will delete all entries stored under
key (you may then reuse key for future register calls, as long as you still
generate a random key)
–Make sure that at least 100 keys can be in use in parallel, and that at least
10000 data items can be stored in total
Make sure that the data is not accessible in any other way (using legal C)
Stephan Schulz 182
Implement the libray in its own source ﬁle, with a header ﬁle data safe.h that
contains allnecessary declarations
Write a main program dstest.c that uses the library, storing 10 values under 3
diﬀerent keys, retrieving them and delete them. Use a reasonably varied sequence
of storage, retrieval, and registration
Hints:
–Use static local variables to store the necessary data in the data safe()
function
–Use preprocessor #define statements to deﬁne the symbolic constants
dsregister ,dsstore ,. . .
–Be careful to avoid handing a key already in use out on registration. Carefully
design your data structures ﬁrst, the operations will be simple to implement
Stephan Schulz 183
CSC322
C Programming and UNIX
Programming in C
rpn calc: An Extended Example
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Project: An RPN Calculator
Aim: A calculator program that can do simple arithmentic
–Conversion between diﬀerent bases
–Addition, subtraction, multiplication...
We’ll use reverse polish notation
–Operator is written after arguments: 7 5 + =7+5
–More complicated: 12 2 5 2 * + - =(12-(2+(5*2)))
Advantages of RPN
–Easy to understand
–Easy to implement
–No hassle with recursive parsing of parentheses and precedences
–Can easily and consistently handle operators of any arity (number of arguments)
Stephan Schulz 185
Some Sugested Operators
Arithmetic operators (others may be added):
+Pop two numbers , add them
-Pop two numbers, subtract ﬁrst from second
*Pop two numbers , multiply them
/Pop two numbers, divide second by ﬁrst
%Pop two numbers, divide second by ﬁrst, giving the division rest
Non-Arithmetic operators (non-exclusive):
pPrint the topmost number on the stack
oPop topmost number on the stack, use it as new output base
iPop topmost number on the stack, use it as new input base
SPrint the whole stack (mainly for debugging)
PPrint input and output bases (in decimal)
Stephan Schulz 186
Usage Example
$ ./rpn calc
10 8 +
S
18
3 / p
6
3 / p
2
o
p
Stack underflow error
P
Input base (decimal): 10 Output Base (decimal): 2
255
p
11111111
16 p
10000
10 o
S
255 16
Stephan Schulz 187
Implementation
Basic idea:
–Input is a sequence of numbers andoperators
–If a number is read, it is pushed onto a stack
–If an operator is read, the necessary number or arguments is popped of the
stack, the operation is performed, and the result is placed in the stack
Input and output can happen in any representation from base 2-16
–There is a strong convention for representing these numbers:
∗Digits are 0-9 with nominal value, A-F (or a-f) with values 10-15
–Input and output use independent bases (base conversion made easy)
Recognizing numbers and operators
–Any string of valid digits in the current input base is a number
–Any string starting with -and directly followed by valid digits in the current
input base is a number
–Everything else is treated as an operator
Stephan Schulz 188
Subtasks
From the above, we can identify a number of subtasks:
–Reading numbers and operators
–Printing numbers
–Handling the stack
–Executing the actual operations
Input handling is the hardest task!
–We need to read up to 2 characters to decide if we read a number or an
operator ( ’-+’ represents two operators, ’-1’ a number)
–Rather than handling explicit lookahead variables throughout the program, we
can build a general character I/O-library that allows us to read ahead, but to
maintain (or restore) the status of the input queue
Stephan Schulz 189
Program Organization
ctype.h stdlib.h
chario.h
integerio.h
chario.o integerio.o rpn_calc.o (libc)
rpn_calcintegerio.c chario.cstdio.h
Link (gcc)Compile (gcc −c)#include
rpn_calc.c
Stephan Schulz 190
The Character I/O Library: Ideas
Main interface similar to getchar()
Read character can be “pushed back” into the input queue
Implementation:
–Internal buﬀer of character
–Pushed characters go into the buﬀer
–Reading ﬁrst tries the buﬀer, and only reads stdio if the buﬀer is empty
Additional help-functions
–Look at a character, but don’t read it
–Skip while space
Stephan Schulz 191
The Character I/O Library: chario.h
#ifndef UNGETCHAR
#define UNGETCHAR
#include <stdio.h>
#include <ctype.h>
/* Maximal number of characters the can be pushed back */
#define MAX_BUFFERED_CHARS 1024
/* As getchar(), but with unget cabability (provided by PushChar() */
int GetChar(void);
/* Push back a character into the read queue. Return c or EOF if the
queue is full. */
int PushChar(int c);
/* Return the next character, but do _not_ read it */
int LookChar(void);
/* Skip over white space characters. Return the first non-white
character (but it is not removed from the queue), or EOF if the
pushback queue is full. */
int SkipSpace(void);
#endif
Stephan Schulz 192
The Character I/O Library: Global Variables and Includes
#include "chario.h"
static int char_buff[MAX_BUFFERED_CHARS];
static int buff_pos = 0;
Stephan Schulz 193
The Character I/O Library: Reading and Unreading
int GetChar(void)
{
if(buff_pos)
{
buff_pos--;
return char_buff[buff_pos];
}
return getchar();
}
int PushChar(int c)
{
if(buff_pos < MAX_BUFFERED_CHARS)
{
char_buff[buff_pos] = c;
buff_pos++;
return c;
}
return EOF;
}
Stephan Schulz 194
The Character I/O Library: Help Functions
int LookChar(void)
{
int c = GetChar();
PushChar(c);
return c;
}
int SkipSpace(void)
{
int c;
while(isspace((c=GetChar())))
{ /* Empty body */ }
return PushChar(c);
}
Stephan Schulz 195
The Integer I/O Library: Ideas
We use the same algorithms as discussed before
However, because we allow bases up to 16, we add some additional helper
functions for
–Recognizing valid digits
–Converting numerical values to character representation of digits
–Giving the numerical value of digits
Second diﬀerence: We allow negative numbers
–We cannot use -1to signal failure
–Instead: We write a separate function that predicts the presence (or absence)
of a number in the input stream
–The calling functions have to make sure that the integer reading function is
only called if there is valid input (i.e. success is guaranteed)
Stephan Schulz 196
The Integer I/O Library: integerio.h
#include "chario.h"
/* Read an integer in base base. */
int read_int_base(int base);
/* Check if there is a integer to be read, i.e. a digit or ’-’
directly followed by a digit */
int int_available(int base);
/* Write integer in any base to stdout */
void write_int_base(int value, int base);
Stephan Schulz 197
The Integer I/O Library: Includes
#include "integerio.h"
Stephan Schulz 198
The Integer I/O Library: Helper functions 1
/* Consider c as a hexadecimal digit (0..9, a..f, A..F) and return its
numerical value. If not a valid digit, return -1 */
static int hex_digit_value(int c)
{
if(c >= ’0’ && c <= ’9’)
{
return c - ’0’;
}
if(c >= ’a’ && c <= ’f’)
{
return c - ’a’ + 10;
}
if(c >= ’A’ && c <= ’F’)
{
return c - ’A’ +10;
}
return -1;
}
Stephan Schulz 199
The Integer I/O Library: Helper functions 2
/* Check if a character c is a valid digit in base. */
static int is_base_digit(int c, int base)
{
int value = hex_digit_value(c);
if(value < 0 || value >= base)
{
return 0;
}
return 1;
}
Stephan Schulz 200
The Integer I/O Library: Helper functions 3
/* Given an int 0<= value < 16, return the Hexadecimal digit with that
value */
static int int_to_hexdigit(int value)
{
if(value<=9)
{
return value + ’0’;
}
else
{
return value - 10 + ’A’;
}
}
Stephan Schulz 201
The Integer I/O Library: Reading Integers
/* Read an integer in base base. */
int read_int_base(int base)
{
int res = 0, c, sign = 1;
if((c=GetChar())==’-’)
{
sign = -1;
}
else
{
PushChar(c); /* Unread Character */
}
while(is_base_digit((c=GetChar()),base))
{
res = (res*base)+hex_digit_value(c);
}
PushChar(c);
return res*sign;
}
Stephan Schulz 202
The Integer I/O Library: Checking for Integer Presence
/* Check if there is a integer to be read, i.e. a digit or ’-’
directly followed by a digit */
int int_available(int base)
{
int save_char , res = 0;
if(is_base_digit(LookChar(), base))
{
res = 1;
}
else if(LookChar() == ’-’)
{
save_char = GetChar();
if(is_base_digit(LookChar(), base))
{
res = 1;
}
PushChar(save_char);
}
return res;
}
Stephan Schulz 203
The Integer I/O Library: Writing Integers
/* Write integer in any base (2<= base <=16) to stdout */
void write_int_base(int value, int base)
{
int digit;
if(value < 0)
{
putchar(’-’);
value = -1*value;
}
digit = value % base;
value = value/base;
if(value!=0)
{
write_int_base(value, base);
}
putchar(int_to_hexdigit(digit));
}
Stephan Schulz 204
Exercises
Download the program from http://www.cs.miami.edu/~schulz/CSC322.
html , compile it, and read the source code. You may want to add more
operators (e.g. tto duplicate the top of the stack, sto switch the two topmost
numbers,. . .
Stephan Schulz 205
CSC322
C Programming and UNIX
Programming in C
rpn calc: An Extended Example (Part 2)
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Recapitulation: Some of our Library Functions
The integerio library oﬀers functios for reading and printing integers. All
functions have a parameter base for selecting the number system (2–16, or
binary to hexadecimal)
int read int base(int base);
–Reads an integer from the standard input (using our GetChar()/PushChar()
interface), returning its value
–If no valid integer can be found, behavior is undeﬁned!
int int available(int base);
–Returns 1(true), if a valid integer can be read from standard input, 0 otherwise
–Does not consume any characters from the input stream!
void write int base(int value, int base);
–Prints an integer number to stdout , using the number system selected by
base
Additional function from chario.c :int SkipSpace(void)
Stephan Schulz 207
The Main Calculator Program
Aim: RPN (Postﬁx) calculator program
–Input: Operators and Numbers (operands)
–Numbers are pushed on a stack
–Operators pop operands and push the result of the operation
while(there is input)
{
if(input is a number)
{
num = read_number();
push(num);
}
else if(input is a valid operator)
{
pop operands, apply operator, push result;
}
else
{
print error mesage;
}
}
Stephan Schulz 208
Case Distinctions
Note: The operator determines which actions we have to perform
–This is a case distinction : Based on a single (integer) value, we have to select
one alternative
–Possible implementation:
if(value == val1)
{
action1;
}
else if((value == val2)
{
action2;
}
...
else
{
default_action;
}
Stephan Schulz 209
C Alternative: switch
switch(E)
{
case val1: action1;
break; /* Otherwise we fall through! */
case val2: action2;
... break;
default: default_action;
break;
}
Ehas to be an integer-valued expression
val1 ,val2 ,. . . have to be constant integer expressions
Eis evaluated and the result is compared to each of the constants after the case
labels. Execution starts with the ﬁrst statement after the matching case. If no
case matches, execution starts with the (optional) default case.
Note: Execution does notstop at the next case label! Use break; to break out
of the switch
Stephan Schulz 210
The Stack Abstract Datatype
Astack is alast-in ﬁrst-out (LIFO) data structure
–It can store values of a given type
–Values can be pushed onto a stack
–The topmost element can be retrieved by poping it oﬀ the stack
–Typically, only the top element is accessed (enforced either by convention or
by design)
–Stacks can have a predetermined size (maximal number of elements) or grow
as needed
Stack impementation in C:
–Values are stored in an array of the correct type
–Astack pointer contains the index of the next unused cell
Stephan Schulz 211
Stack Implementation in rpn calc.c
We use a ﬁxed maximal stack size:
#define STACKSIZE 1024
–Using a symbolic constant avoids mistyping and misreading, and allows us to
eaily change the stack size later!
Our stack data structure is realized by two variables:
–int stack[STACKSIZE]; stores the values
–int sp = 0; is the stack pointer , and initially points to the ﬁrst element of
stack
Stack operations are implemented as specialized macros
Stephan Schulz 212
Pushing things onto the stack: PUSH()
/* If stack is full, print an error message,
otherwise push the value onto the stack */
#define PUSH(value) \
if(sp < STACKSIZE) \
{ \
stack[sp] = (value);\
sp++;\
}\
else\
{\
printf("Stack overflow error\n");\
}
Stephan Schulz 213
Poping values: POP ORFAIL()
/* If stack is empty, print an error message and "break;",
otherwise pop the top value into varname */
#define POP_OR_FAIL(varname) \
if(sp > 0)\
{\
sp--;\
(varname) = stack[sp];\
}\
else\
{\
printf("Stack underflow error\n");\
break;\
}
Note that the macro contains a break; statement in the error case
–Limits general usability but. . .
–. . . exits the case it is used in early!
Stephan Schulz 214
The Main Program: Prelimaries and Declarations
int main(void)
{
int num, arg1, arg2, i;
int stack[STACKSIZE];
int sp = 0, in_base = 10, out_base = 10;
SkipSpace();
The number systems to be used for input and output is determined by inbase
andout base
–Both are initialized to 10 (decimal)
Note that the next character to be read is meaningful (not white space) now
–This will be a loop invariant of the main loop)
Stephan Schulz 215
The Main Loop: Overall Structure
while(LookChar()!=EOF)
{
if(int_available(in_base))
{
num = read_int_base(in_base);
PUSH(num);
}
else
{ /* Operator! */
switch(GetChar())
{
case ’o’:
... /* Handle different cases */
default:
printf("Unknown operand\n");
break;
}
}
SkipSpace();
}
return EXIT_SUCCESS;
}
Stephan Schulz 216
The Main Loop: Arithmetic operators
switch(GetChar())
{
...
case ’+’:
POP_OR_FAIL(arg2);
POP_OR_FAIL(arg1);
num = arg1+arg2;
PUSH(num);
break;
case ’-’:
POP_OR_FAIL(arg2);
POP_OR_FAIL(arg1);
num = arg1-arg2;
PUSH(num);
break;
case ’*’:
POP_OR_FAIL(arg2);
POP_OR_FAIL(arg1);
num = arg1*arg2;
PUSH(num);
break;
Stephan Schulz 217
case ’/’:
POP_OR_FAIL(arg2);
POP_OR_FAIL(arg1);
num = arg1/arg2;
PUSH(num);
break;
case ’%’:
POP_OR_FAIL(arg2);
POP_OR_FAIL(arg1);
num = arg1%arg2;
PUSH(num);
break;
...
}
Stephan Schulz 218
The Main Loop: I/O operators
switch(GetChar())
{
...
case ’p’:
POP_OR_FAIL(num);
write_int_base(num,out_base);
putchar(’\n’);
PUSH(num);
break;
case ’o’:
POP_OR_FAIL(num);
if(num < 2 || num >16)
{
printf("Only bases 2-16 (decimal) supported\n");
}
else
{
out_base = num;
}
break;
Stephan Schulz 219
case ’i’:
POP_OR_FAIL(num);
if(num < 2 || num >16)
{
printf("Only bases 2-16 (decimal) supported\n");
}
else
{
in_base = num;
}
break;
Stephan Schulz 220
case ’S’:
for(i=0; i<sp; i++)
{
write_int_base(stack[i],out_base);
putchar(’ ’);
}
putchar(’\n’);
break;
case ’P’:
printf("Input base (decimal): %d Output Base (decimal): %d\n",
in_base,out_base);
break;
...
}
Stephan Schulz 221
Manual Compilation
First, we comile all of the source ﬁles individually:
$gcc -ansi -Wall -c -o chario.o chario.c
$gcc -ansi -Wall -c -o integerio.o integerio.c
$gcc -ansi -Wall -c -o rpn calc.o rpn calc.c
Then we perform the linking step:
$gcc -ansi -Wall -o rpn calc chario.o integerio.o rpn calc.o
Now the program is ready to run:
$./rpn calc
2 o 10 p
1010
Stephan Schulz 222
UNIX User Commands: dc
dcis an arbitrary precision RPN calculator
–It handles ﬂoating point numbers (to any preselected precision)
–It handles bignums , i.e. integers tgat do not ﬁt into any standard data type
–It has a lot of build-in functionality and can be extended by user-deﬁned macros
Usage is quite similar to our rpncalc
For more: man dc or (particularly) info dc (or read info in emacs: [C-h i] )
Stephan Schulz 223
Exercises
Read the man and info pages for dc
Play with the program
Enjoy the weekend and be merry
Note: I’ve updated the rpn calc sources on the web page to the latest version
(changes only comments and style)
Stephan Schulz 224
CSC322
C Programming and UNIX
Programming in C
More on Operators and Expressions
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Increment and Decrement Operators
C supports the unary operators ++and--for incrementing and decrementing
variables
–++increments a variable by 1
–--decrements a variable by 1
Both can be used as preﬁx andpostﬁx operators: x++or++x
–In both cases, xis incremented by 1
–The diﬀerence is in the value of the expression:
∗The expression x++has the value of xbefore incrementing
∗++x has the value of xafter incrementing, i.e. it is equivalent to the
assignment x=x+1
Both forms are used, but the postﬁx form is more common
Stephan Schulz 226
Example
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int x,y;
x=5; y=5;
printf("x = %d y = %d\n", x, y);
printf("x++ = %d ++y = %d\n", x++, ++y);
printf("x = %d y = %d\n", x, y);
printf("x-- = %d --y = %d\n", x--, --y);
printf("x = %d y = %d\n", x, y);
return EXIT_SUCCESS;
}
Output:
x = 5 y = 5
x++ = 5 ++y = 6
x = 6 y = 6
x-- = 6 --y = 5
x = 5 y = 5
Stephan Schulz 227
Binary Number Representation
C guarantees a base 2 representation for all unsigned integer types:
–Example: 16 bit representation ( short on many implementations) of 42
0 0 0 0 0 00000101010
21521421321221121029282726252423222120
42 = 25+ 23+ 21= 32 + 8 + 2
–If a result of an arithmetic operation results in a value not representable by the
result type, it is reduced modulo 2n, where nis the width of the result type
An unsigned number of a narrower type is converted to a wider type by adding
an appropiate number of leading zeroes:
–The 8 bit representation ( char on many implementations) of 42 is:
00101010
2726252423222120
The exact representation for signed integers is not ﬁxed, however, positive signed
integers are guaranteed to have the same representation in signed and unsigned
types
Stephan Schulz 228
Bitwise Operators
Bitwise operators operate on the binary representation of numbers
The binary bitwise operators include
–Bitwise and(&) sets a bit in the result, if it is set in both operands:
6 & 3 == 2
–|is the bitwise or, i.e. the result bit is set, if at least one of the corresponding
bits in the input is set:
6 | 3 == 7
–^is the bitwise exclusive or (or xor) (the result bit is set if and only if the two
operands diﬀer at that position):
6 ^ 3 == 5
The bitwise not(orone’s complement ) toggles all bits
–The result value depends on the number format
–For 16 bit unsigned short, ~42 == 65493
Stephan Schulz 229
Bitwise Shifting
C also supports the shifting of binary numbers
The binary operator <<shifts an integer value left, ﬁlling up vacant spaces with
zero: 1 << 3 == 8
–Left-shifting by nbits is equivalent to multiplication with 2n(but may be
faster on ancient compilers)
The binary operator >>shifts an integer value right
–For unsigned value, the new bits become zero
–For signed values, either zeroes are shifted in ( logical shift ), or the ﬁrst (sign)
bit is replicated (arithmetic shift, equivalent to division by 2n)
Note: The shift operators are used seldomly
–C++ has even recycled them for I/O operations
–Binary and, or, and not, on the other hand, are used frequently to manipulate
binary ﬂags packed into a single integer value
Stephan Schulz 230
Example
These macros can be used to set and query properties in a variable, where each
property is encoded in a single bit
#define SetProp(var, prop) ((var) = (var) | (prop))
#define DelProp(var, prop) ((var) = (var) & ~(prop))
#define FlipProp(var, prop) ((var) = (var) ^ (prop))
/* Absolutely assign properties masked by sel */
#define AssignProp(var, sel, prop) DelProp((var),(sel));\
SetProp((var),(sel)&(prop))
/* Are _all_ properties in prop set in var? */
#define QueryProp(var, prop) (((var) & (prop)) == (prop))
/* Are any properties in prop set in var? */
#define IsAnyPropSet(var, prop) ((var) & (prop))
Stephan Schulz 231
Assignment Operators
Very frequently, programming tasks require the updating of a varible, based on
it’s old value
–Frequent example: i=i+1;
In addition to the general assignment operator, C oﬀers operators combining
update and assignment
–If<op> is a binary operator, then <op>= is the corresponding assignment
operator
–x <op>= <expr> is equivalent to x = x <op> <expr>
–This is supported for <op> ∈ { +, -, *, /, %, <<, >>, &, ^, | }
Most frequently used
–+=(as in fahrenheit += 10 )
–-=(e.g. in the update part of a for loop)
Stephan Schulz 232
Conditional Expressions
Similarly to conditional statements ( if/else ), C has conditional expressions:
–If<test>, <e1>, <e2> are expressions, then <test> ? <e1> : <e2> is
aconditional expression
∗If<test> evaluates to true (non-zero), then <e1> is evaluated and its value
returned
∗Otherwise, <e2> is evaluated and returned
Example 1:
#define MAX(a,b) ((a>b)?a:b)
Example 2:
printf("There %s %d item%s left\n",
(count==1)?"is":"are",
count,
(count==1)?"":"s");
Stephan Schulz 233
Expression Sequences
The coma operator separates two expressions: <expr1>, <expr2>
–Expressions are evaluated left to right
–The value of a coma-separated sequence is the value of the last expression in
it
–Don’t confuse it with the coma separating function call arguments!
Nearly only legitimate use: Initialize and update in forloops:
for(cels=0, fahr=-32; cels <= 100; cels+=5,fahr+=9)
{
printf("%3d %3d\n", cels, fahr);
}
Stephan Schulz 234
Type Conversion (Casting)
As already stated, C performs type conversion in many situations automatically
–If diﬀerent numeric types are used in an expression, all values are promoted to
the “largest” type
–If a value of an unsigned integer type is assigned to a “smaller” variable of
smaller type, excess bits are dropped
–For signed types, conversion is only partially speciﬁed
In addition, values can be coerced to a diﬀerent type
–Acast expression has the syntax (<type>) <value>
Example:
printf("Int: %d Float: %d\n",
(1/2)*2,
(int) (((float)1/2)*2));
Int: 0 Float: 1
Stephan Schulz 235
Exercises
Write a function that counts the number of bits that are one in an unsigned
long number (Footnote: Allegedly the NSA sponsors the inclusion of hardware to
make this operation fast in many chips because they need it for speeding up the
cracking of encrypted documents)
Rewrite imp metric to use comma-separated expressions to build the tables
Stephan Schulz 236
CSC322
C Programming and UNIX
Programming in C
Expressions and the Type System
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Getting the Size of Objects and Types
A ﬁnal operator is sizeof
–sizeof can be applied to an expression or to a parenthesized type name
–Applying it to an expression is equivalent to applying it to the type of the
expression
sizeof returns the number of character-sized memory units necessary to store
an object of the type
–By deﬁnition, sizeof (char) == 1
Example:
printf("sizeof 1: %d sizeof (short)1: %d\n", sizeof 1, sizeof ((short)1));
sizeof 1: 4 sizeof (short)1: 2
Note: sizeof will be useful for dynamic memory handling
Stephan Schulz 238
Order Of Execution
In general, the order of execution of subexpressions is notdeﬁned!
Exceptions:
–&&,||,?:, and ,
If you need a particular order of execution, you must force it
–Since statements are executed sequentially, compute subexpression in separate
statments (assigning them to diﬀerent variables)
–Other sequence points are set by the operators listed above
The example on the next page may print One Two One Two orTwo One One
Two
Stephan Schulz 239
Example
#include <stdio.h>
#include <stdlib.h>
int one(void)
{
printf("One ");
return 1;
}
int two(void)
{
printf("Two ");
return 1;
}
int main(void)
{
one()+two();
one()&&two();
printf("\n");
return EXIT_SUCCESS;
}
Stephan Schulz 240
Types in C
C oﬀers a set of basic types built into the language
We can deﬁne new, quasi-basic types as enumerations
We can construct new types using type contruction :
–Arrays over a base type
–Structures, combining diﬀerent base types in one object
–Unions (can store diﬀerent type values alternatively)
–Pointer to a base type
This generates a recursive type hierarchy!
–We can use new types to build further on them
–E.g. Arrays of Pointers, Structures combining unions and enumerations, . . .
Stephan Schulz 241
Basic Types
Basic types in C:
–char (typically used to represent characters)
–short
–int
–long
–long long
–float
–double
All integer types come in and unsigned variety
Stephan Schulz 242
Deﬁning New Types with typedef
The typedef keyword is used to deﬁne new names for types in C
General syntax: If we add typedef to a variable deﬁnition, it turns into a type
deﬁnition
Examples:
unsigned long ulong; /* Define variable */
typedef long ulong_t; /* Define a new type ulong_t */
ulong_t ulong1; /* Define variable of new type */
char string[80]; /* Defining an array variable *
typedef char string_t[80]; /* Define a string type */
string_t string1; /* Define a variable of that type -- we can use
string1[32] now */
Stephan Schulz 243
Symbolic Names in the Data Safe Assignement
The data safe assignement calls for a function data safe() with three arguments
–The ﬁrst argument is a symbolic method: dsregister ,dsstore ,
dsretrieve ,dsdelete
–We can implement this using a intargument and #define :
#define ds_register 1
#define ds_store 2
#define ds_retrieve 3
#define ds_delete 4
int data_safe(int method, int key, int value_or_index);
Problems:
–Nothing in the declaration of data safe() tells us that the intis anything
but a number
–The #define statements are independent
Wouldn’t it be nice to create a new type to reﬂect the intended use?
Stephan Schulz 244
Enumerations in C
Enumeration data types can represent values from a ﬁnite domain using symbolic
names
–The possible values are explictly listed in the deﬁnition of the data type
–Typically, each value can be used in only one enumeration
In C, enumerations are created using the enum keyword
In C, enumeration types are integer types
–A deﬁnition of an enumeration type just assigns numerical values to the
symbolic name
–Unless explicitely chosen otherwise, the symbolic names are numbered starting
at 0, and increasing by one for each name
–Jowever, anyintvalue can be assigned to a variable of an enumeration type
–Likewise, we can assing any enumeration constant to any integer type variable
C enumerations have only mnemonic value, they do not enable the compiler to
catch bugs resulting from mixing up diﬀerent types
Stephan Schulz 245
Enumeration Syntax
An enumeration type is deﬁned by the enum keyword, followed by a list of
identiﬁers ( enumeration constants ) in curly brackets
The following code describes an enumeration data type for the data safe methods:
enum{ds_register, ds_store, ds_retrieve, ds_delete}
It can be used like any other type speciﬁer:
int data_safe(enum{ds_register, ds_store, ds_retrieve, ds_delete}method,
int key, int value_or_index);
...
key = data_safe(ds_register, 0, 0);
Stephan Schulz 246
enum and typedef
Typically, enumeration data type are used to deﬁne new types
–The enum keyword describes the new type
–The typedef keyword assigns a name to the type
–The new type can then be used consistently throughout the program
Example:
typedef enum{ds_register, ds_store, ds_retrieve, ds_delete}DS_operation;
int data_safe(DS_operation method, int key, int value_or_index);
...
key = data_safe(ds_register, 0, 0);
Typically, enumerations (and other new data types) are declared in header ﬁles
(.hﬁles), and form part of the interface of a module
Stephan Schulz 247
More on Enumerations
Since enumeration are actually integer types, we can assign speciﬁc values to the
constants
–We can even assign the same value to diﬀerent constants!
Example (also note preferred form of formatting for enums):
typedef enum
{
ds_register = 1,
ds_store = 2,
ds_retrieve = 3,
ds_delete = 4,
ds_forget = 4
}DS_operation;
Stephan Schulz 248
Aggregating Data Types
Let’s again look at the data safe assignment
–We somehow have to associate a keyand a value (or multiple values)
–Simple approach: Use two arrays, one for keys, one for values
–Ifkeys[i] = key , then values[i] holds a value associated with key
However, the association between those two elements is not reﬂected by this
construction
–The two arrays are independent
–They can be manipulated independently
–There is not even a guaranty that both arrays have the same size!
–If we pass key and value to a function, we have to pass them as individual
elements (what if we have 132 diﬀerent elements?)
Solution: Creating structures that combine diﬀerent elements into one
Stephan Schulz 249
struct
Astructure is a datatype that may have any number of members
–Members can have diﬀerent types
–Members can have any other type (including arrays or other structures)
–Members are referred to by their name in the structure
Java analogy: A structure type is a class, but:
–No member functions
–All members are public
Structures are deﬁned using the struct keyword, followed by an optional name
and a list of member deﬁnitions in curly braces
–Each member deﬁnition is a normal variable deﬁnition, giving type and name
of the member
Stephan Schulz 250
Structure Example
Consider the following deﬁnition:
struct key_assoc {int key; int value;} key_pair;
–It creates a variable key pair with two members
–They can be referred to by name:
key_pair.value = 10;
...
if(key_pair.key == user_key)
{
count++;
}
Stephan Schulz 251
stuct and typedef
As with enumerations, structures are usually used with typedef :
typedef struct key_assoc
{
int key;
int value;
} key_pair_t;
static key_pair_t key_value_array[10000];
–The ﬁrst deﬁnition deﬁnes a new type, key pair t
–The second one creates an array of 10000 of these pairs
Using the name ( struct key assoc ), we can refer to the array even before we
have seen the full deﬁnition
–Important for self-referential data types using pointers
Stephan Schulz 252
Exercises
Create a function that has two primary colours (red, blue, yellow) as input, and
returns the colour that results from mixing them
–Use an enumeration type for the colours
–Use an struct to hold triples (colour1, colour2, mix) and an array to store all
associations
–You can use linear search to ﬁnd matching patterns for your input
Stephan Schulz 253
CSC322
C Programming and UNIX
Programming in C
Data Structures and Pointers
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Representing Related Objects
Assume the following problem:
–In a drawing program, we need to represent geometrical shapes (circles, squares,
rectangles, triangles...)
–There is some common information for all shapes:
∗Border colour
∗Line width
∗Fill colour (if any)
–However, the coordinates are diﬀerent for each shape:
∗For a circle, we need center point and radius
∗For a square or rectangle we need two corners
∗For a triangle we need three corners
Object-oriented languages allow a base class shape, and derived classes for the
diﬀerent shapes
–In C, we have to program this explicitely, using unions !
Stephan Schulz 255
Unions
Unions of base types allow the new type to store one value of any of its base
types (but only one at a time)
The syntax is analogous to that of structures:
–The keyword union is followed by a list of member deﬁnitions in curly braces
Example
–union {int i; float f; char *str; }numval
–numval can store either an integer or a ﬂoating point number, or a pointer to
a character (normally a string)
–Access is as for structures: numval.i is the integer value
Note: Unions weaken the type system:
–numval.f=1.0; printf("%d\n",numval.i);
–Situations like that are, in general, impossible to detect at compile time
Stephan Schulz 256
Shape Example Continued (1)
typedef enum
{
circle,
square,
rectangle,
triangle
}ShapeType;
typedef enum
{
red,
green,
blue,
black, white
}ColourType
typedef struct
{
int center_x;
int center_y;
int radius;
}CircleCoord;
Stephan Schulz 257
Shape Example Continued (2)
typedef struct
{
int lower_left_x;
int lower_left_y;
int upper_right_x;
int upper_right_y;
}RectangleCoord;
typedef RectangleCoord SquareCoord;
typedef struct
{
int point1_x;
int point1_y;
int point2_x;
int point2_y;
int point3_x;
int point4_y;
}TriangleCoord;
Stephan Schulz 258
Shape Example Continued (3)
typedef union
{
CircleCoord circle_coord;
RectangleCoord rect_coord;
SquareCoord square_coord;
TriangleCoord tria_coord;
}ShapeCoord;
typedef struct
{
ShapeType type;
int border_width;
ColourType border_colour;
ColourType fill_colour;
ShapeCoord coords;
}Shape;
Stephan Schulz 259
Shape Example Continued (4)
void draw_shape(Shape draw_obj)
{
switch(draw_obj.type)
{
case circle:
draw_circle(draw_obj.coords.circle_coord.center_x,
draw_obj.coords.circle_coord.center_y,
draw_obj.coords.circle_coord.radius,
draw_obj.border_width,
draw_obj.border_colour,
draw_obj.fill_colour);
break;
case square:
draw_square(draw_obj.coords.square_coord.lower_left_x,
draw_obj.coords.square_coord.lower_left_y,
draw_obj.coords.square_coord.upper_right_x,
draw_obj.coords.square_coord.upper_right_y,
draw_obj.border_width,
draw_obj.border_colour,
draw_obj.fill_colour);
break;
...
Stephan Schulz 260
Pointers
Pointers are derived types of a base type
–Apointer is the memory address of an object of the base type
–Given a pointer, we can manipulate the object pointed to
Notice that there are twoparts to a pointer:
–The actual memory address (a dynamic feature in the running program)
–Thetype of the pointer (pointer to int, pointer to Shape . . . ) telling us how
to interprete the data at that address (a static feature that can be determined
at compile time)
C uses the unary *to deﬁne variables of pointer types:
–int *count; deﬁnes the variable count as a pointer to int
–Notice that this pointer does not contain a valid address - there is no object
of type intcreated along with the pointer!
–Pointers can be deﬁned for any valid type in C: struct {double real;double
imag; }*complex deﬁnes complex as a pointer to the struct
Stephan Schulz 261
Basic Pointer Operations in C
The most basic operations on pointers are:
–Given an object, return a pointer to it
–Given a pointer, give the object it points to ( dereference the pointer)
C uses the unary *operator for both pointer deﬁnition and pointer dereferencing,
and&for getting the adress of an existing object
–int var;int *p; deﬁnes var to be a variable of type int andpto be a
variable of type pointer to int
–p = &var makes ppoint to var(i.e.pnow stores the address of var)
–*p = 17; assigns 17 to the intobject that ppoints to (in our example, it
would set varto 17)
–Note that &(*p) == p always is true for a pointer variable pointing to a valid
object, as is *(&var)==var for an arbitrary variable!
Stephan Schulz 262
Pointers - A simple Example
#include <stdio.h>
#include <stdlib.h>
void swap(int *x, int *y)
{
int z;
z =*x;
*x =*y;
*y = z;
}
int main(void)
{
int var1=7, var2=42;
printf("var1: %d var2: %d\n", var1, var2);
swap(&var1, &var2);
printf("var1: %d var2: %d\n", var1, var2);
return EXIT_SUCCESS;
}
Stephan Schulz 263
Example Continued
Output of the program:
var1: 7 var2: 42
var1: 42 var2: 7
Note that this technique is an example of a frequent way to simulate call by
reference in C
–Instead of passing an object, we pass a reference to it
–Allows changes to the object inside the function
–Often cheaper (especially for big objects)
Stephan Schulz 264
Why Pointers?
The are two main reasons for using pointers:
–Eﬃciency
–Dynamically growing data structures
Eﬃciency Aspects
–Pointers are typically represented by one machine word
–Storing pointers instead of copies of large objects safes memories
–Passing pointers instead of large objects is much more eﬃcient
Dynamically growing data structures
–Each data type has a ﬁxed size and memory layout
–Pointers allow us to build dynamically growing data structures by adding and
removing ﬁxed size cells
Stephan Schulz 265
Pointing at Nothing and Pointing Nowhere
Pointers of type void* are a special case:
–Avoid* pointer is a generic pointer , without associated base type
–void* pointers can be assigned to variables of any other pointer type (and
vice versa)
–Such pointers are used for primarily for dynamic memory handling
C has a special, reserved NULL pointer of type void*
–The NULL pointer is guranteed to be diﬀerent from all pointers pointing to
legitimate objects
–It can be written as plain 0(in a pointer context)
–stdlib.h deﬁnes a symbolic namen, NULL , for the NULL pointer
–Dereferencing NULL is illegal!
–Notice that NULL is considered to be false if used in logical expressions
–Note: For most current machines, the NULL pointer actually is address 0.
However, this is not guaranteed (and is false for some machines with strange
memory models)
Stephan Schulz 266
Exercises
Write a program that prints the sizes of various build-in and self-deﬁned data
types (e.g. the Shape type and its subtypes). Do you see a relation between
them?
Write a program that uses swap() to sort an array of integers and print it. If
you feel adventurous, use read int base() from the rpn calc example (or a
similar function) to read integers to ﬁll the array
Notes
Please email the TA, Raghu, at his UMiami address, raghu@lee.cs.miami.edu
from now on
Your grades for the assignments will be placed into your home directories
Solutions to the prime number assignment will be available shortly after noon
Stephan Schulz 267
CSC322
C Programming and UNIX
Programming in C
Dynamic Data Structures
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Refresher: Pointers
Apointer type is a derived type of a base type
–A pointer is the address of an object of the base type
–Given a pointer p,*pgives us the object it points to
–Given an object o,&ogives us a pointer to that object in memory
An object of type void* is a generic pointer (i.e. a plain address without
associated base type)
–A pointer of type void* can be assigned to a variable of any other pointer
type
–Similarly, a value of any pointer type can be assigned to a void* variable
The special value NULL is a pointer of type void*
–It is guaranteed diﬀerent from all pointers to valid object
–Its logical value is false, while that of all other pointers is true
Stephan Schulz 269
Dynamic Memory Handling
The C library oﬀers functions for dynamic memory handling
–We can request a block of memory of a certain size
–If such a block is available, we will get a void* pointer to it
–This block can be used to store any object that ﬁts into it
–If we do not need that object anymore, we can return it to the library
Such blocks can be used to build arbitray sized data structures
–. . . e.g. by allocating bigger and bigger arrays if the need arrises
–. . . or by using pointers within a structure to point to additional structures
(which may contain further pointers)
Stephan Schulz 270
The malloc() function
We request a block of memory using malloc() (declared in <stdlib.h> )
–It’s declared as void *malloc(size t size); , i.e. it returns a generic
pointer
–size tis a new data type from the standard library. It’s guaranteed to be an
unsigned integer data type (often unsigned int )
–malloc() allocates a region big enough to hold the requested number of bytes
on the heap (a reserved memory region) and returns the address of the ﬁrst
byte (a pointer to that region)
–The sizeof operator is used to get the necessary size for the object datatype
-p = malloc(sizeof(int)); allocates a memory region big enough to store
an integer and makes ppoint to it
-The void* pointer is silently converted to a pointer to int
–If no memory is available on the heap, malloc() will return the NULL pointer
(also written as plain 0)
Stephan Schulz 271
Freeing Allocated Memory
The counterpart to malloc() isfree()
–It is declared in <stdlib.h> as
void free(void* ptr);
–free() takes a pointer allocated with malloc() and returns the memory to
the heap
Note that it is a bug to call free() with a pointer notobtained by calling
malloc() (i.e. a pointer generated by applying &to a variable)
It also is a bug to call free() with the same pointer more than once
Stephan Schulz 272
More on Dynamic Memory Allocation
Good programming practice always checks if malloc() succeeded (i.e. returns
notNULL )
–In multi-tasking systems, even small allocations may fail, because other pro-
cesses consume resources
–The OS may limit memory usage to small values
–Failing to implement that chack can lead to erratic and non-reproducable
failure!
Similarly, each call to malloc() should (eventually) be followed by a call to
free() for the pointer obtained
–If you do not know if you still need a piece of memory, or if a pointer still
points somewhere, you are in deep trouble , anyways!
–By consequently freeing all allocated memory, you can easily check if you
return the same number of block you allocate!
Stephan Schulz 273
Pointers are a Mixed Blessing!
Dangling pointers
–Adangling pointer is a pointer not pointing to a valid object
–A call to free() leaves the pointer dangling (the pointer variable still holds
the adress of a block of memory, but we are no longer allowed to use it)
–Copying a pointer may also lead to additional dangling pointer if we call
free() on one of the copies
–Trying to access a dangling pointer typcially causes hard to ﬁnd errors, including
crashes
Memory leaks
–Amemory leak is a situation where we lose the reference to an allocated piece
of memory:
p = malloc(100000 * sizeof(int));
p = NULL; /* We just lost a huge gob of memory! */
–Memory leaks can cause programs to eventually run out of memory
–Periodically occurring leaks are catastophic for server programs!
Stephan Schulz 274
Example: SecureMalloc()
Note: In my programs, there is typically at most a single call to malloc():
void* SecureMalloc(size_t size)
{
void* res = malloc(size);
if(!res)
{
printf("malloc() failure -- out of memory?");
exit(EXIT_FAILURE);
}
return res;
}
Stephan Schulz 275
Pointers and Structures/Unions
Most interesting data strucures use pointers to structures
–Examples: Linear lists (see below), binary trees, terms,. . .
Most frequent operation: Given a pointer, access one of the elements of the
structure (or union) pointed to
–(*list).value = 0;
–Note that that requires parentheses in C
More intuitive alternative:
–The ->operator combines dereferencing and selection
–list->value = 0;
–This is the preferred form (and seen nearly exclusively in many programs)
Stephan Schulz 276
Example: Linear Lists (of Integers)
A list over a can be recursively deﬁned as follows:
–The empty list is a list
–Iflis a list and eis an element of the base type, then e . l is a list
We can represent that in C as follows:
–The empty list is represented by the NULL pointer
–A non-empty list is represented by a pointer to a struct containing the
element and a pointer to the rest of a list
Some list operations:
–Insert an element as the ﬁrst element
–Insert an element as the last element
–Print the list elements in order
–Free the memory taken up by a list
Stephan Schulz 277
Example Continued
Graphical representation of the list structure for (7,9,13):
NULL 7 9 13
Notice the anchor of the list
Stephan Schulz 278
Example – Declarations
#ifndef INT_LISTS
#define INT_LISTS
#include <stdlib.h>
#include <stdio.h>
typedef struct int_list_cell
{
int value;
struct int_list_cell *next;
}IntListCell;
typedef IntListCell *IntList_p;
void* SecureMalloc(size_t size);
void IntListInsertFirst(IntList_p *list, int new_val);
void IntListInsertLast(IntList_p *list, int new_val);
void IntListFree(IntList_p list);
void IntListPrint(IntList_p list);
#endif
Stephan Schulz 279
Example – Inserting At the Front
/* Insert a new integer as the first element of an integer list */
void IntListInsertFirst(IntList_p *list, int new_val)
{
IntList_p handle;
handle = SecureMalloc(sizeof (IntListCell));
handle->value = new_val;
handle->next = *list;
*list = handle;
}
Stephan Schulz 280
Example – Inserting At the End
/* Insert a new integer as the last element of an integer list */
void IntListInsertLast(IntList_p *list, int new_val)
{
IntList_p handle, last;
handle = SecureMalloc(sizeof (IntListCell));
handle->value = new_val;
handle->next = NULL;
if(!*list)
{
*list = handle;
}
else
{
last = find_last_element(*list);
last->next = handle;
}
}
Stephan Schulz 281
Example – Helper Function
//* Helper function: Given a non-empty list, return last element */
IntList_p find_last_element(IntList_p list)
{
if(list->next)
{
return find_last_element(list->next);
}
return list;
}
Stephan Schulz 282
Example – Freeing Lists
/* Free the memory taken up by a list */
void IntListFree(IntList_p list)
{
if(list)
{
IntListFree(list->next); /* Free rest */
free(list); /* Free this cell */
}
}
Stephan Schulz 283
Example – Printing Lists
/* Print a list as a sequence of numbers */
void IntListPrint(IntList_p list)
{
IntList_p handle;
for(handle = list; handle; handle = handle->next)
{
printf("%d ", handle->value);
}
putchar(’\n’);
}
Stephan Schulz 284
Example – Main Function
int main(void)
{
int value;
IntList_p list1 = NULL, list2 = NULL;
SkipSpace();
while(int_available(10))
{
value = read_int_base(10);
IntListInsertFirst(&list1, value);
IntListInsertLast(&list2, value);
SkipSpace();
}
printf("List1: ");
IntListPrint(list1);
printf("List2: ");
IntListPrint(list2);
IntListFree(list1);
IntListFree(list2);
return EXIT_SUCCESS;
}
Stephan Schulz 285
Assignment
Abinary search tree is either empty, or it consist of a node storing a key(the root
of the tree), and a left and right subtree, such that all keys in the left subtree
are smaller than the key in the node, and all keys in the right subtree are bigger
–To print a tree in (left-to-right) preorder , you ﬁrst print the root, then the left
subtree, then the right subtree
–To print a tree in (left-to-right) postorder , you ﬁrst print the left subtree, then
the right subtree, then the root
–To print a tree in natural order , you ﬁrst print the left tree, then the root, then
the right tree
Design a data structure for binary search trees with int keys, using dynamic
memory handling
Implement functions to:
–Insert keys into the tree (ignoring keys already in the tree)
–Print a tree in preorder, natural order, and postorder
–Free the memory taken up by the tree
Stephan Schulz 286
Use this datatype and the functions from integerio to write a program that
reads a list of integers from stdin into a tree, and prints that tree in the three
diﬀerent orders
You can use the code from the linear list example as a base. The complete code
will be available from the course homepage
Stephan Schulz 287
CSC322
C Programming and UNIX
Programming in C
Pointers and Arrays
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Midterm Examn
Monday, Oct. 14th, 11:00 – 11:50
Topics: Everything we did so far
–UNIX ﬁle system layout
–Simple UNIX utilities
–Job Control
–Basic C
–Compilation and the preprocessor
–C ﬂow control and functions
–Data structures in C
–Pointers
Friday we will refresh some of that stuﬀ (but doreread the lecture notes yourself,
and check the example solutions on the web)
Stephan Schulz 289
Refresher: Pointers
Apointer type is a derived type of a base type
–A pointer is the address of an object of the base type
–Given a pointer p,*pgives us the object it points to
–Given an object o,&ogives us a pointer to that object in memory
An object of type void* is a generic pointer (i.e. a plain address without
associated base type)
–A pointer of type void* can be assigned to a variable of any other pointer
type
–Similarly, a value of any pointer type can be assigned to a void* variable
The special value NULL is a pointer of type void*
–It is guaranteed diﬀerent from all pointers to valid object
–Its logical value is false, while that of all other pointers is true
Stephan Schulz 290
Refresher: Dynamic Memory Handling
void* malloc(size t size); is a function from <stdlib.h>
–It will return a pointer to an otherwise unused block of memory with at least
size bytes (or NULL if no memory is available)
–Typical use: int *p = malloc(sizeof(int));
void free(void* ptr); is the counterpart to malloc()
–It takes a pointer to a block allocated with malloc() and returns the block
to the heap
–It is a (usually fatal) bug to call free() more than once for the same block,
or with a pointer not obtained from malloc()
Very frequent case: Allocation of memory for struct s
–Accessing elements in a struct: (*list).value = 0;
–More readable alternative: list->value = 0;
Stephan Schulz 291
Pointers and Arrays in C
In C, arrays and pointers are strongly related:
–Everwhere except in a deﬁnition and the left hand side of an assignment, an
array is equivalent to a pointer to its ﬁrst element
–In particular, arrays are passed to functions by passing their address!
–More exactly: An array degenerates to a pointer if passed or used in pointer
contexts
Not only can we treat arrays as pointers, we can also apply array operations to
pointers:
–Ifpis a pointer to the ﬁrst element of an array, we can use p[3] to access
the third element of that array
–In general, if ppoints to some memory address corresponding to an array
element a[j] ,p[i] points to a[j+i]
Stephan Schulz 292
Graphic Example
array[0]
array[9]...
...
...a
b10
11
10   int array[10];
   int *a, *b;
   a = array;
   b = &(array[0]);
   array[0] = 10;
   a[1] = 11;
   b[3] = *a;
Stephan Schulz 293
Example
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
char a[] = "CSC322\n";
char *b;
int i;
b=a;
printf(b);
for(i=0;b[i];i++)
{
printf("Character %d: %c\n", i, b[i]);
}
return EXIT_SUCCESS;
}
Stephan Schulz 294
Example Output
Compiling: gcc -o csc322 csc322.c
Running:
CSC322
Character 0: C
Character 1: S
Character 2: C
Character 3: 3
Character 4: 2
Character 5: 2
Character 6:
Stephan Schulz 295
Parameter Passing in C
In C, parameters to functions are always passed by value
–The formal parameter (in the function) is a local variable
–It is initialized to the value of the actual parameter (the expression we used in
the function call)
–Changing the local variable in the function does not change the formal
parameter
Arrays degenerate into pointers to the ﬁrst element, however!
–That pointer is still passed by value, however, in eﬀect the array is passed by
reference
–We can thus change the array elements from inside the function!
This is frequently used for eﬃcient array manipulation!
–Sorting arrays
–Reading elements into an array from stdin
–Applying a transformation to all elements
Stephan Schulz 296
Example
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
void upcase(char *string)
{
int i;
for(i=0; string[i]; i++)
{
string[i] = toupper(string[i]);
}
}
int main(void)
{
char str[] = "A test string.";
printf("%s\n", str);
upcase(str);
printf("%s\n", str);
return EXIT_SUCCESS;
}
Stephan Schulz 297
Example Output
A test string.
A TEST STRING.
Stephan Schulz 298
CSC322
C Programming and UNIX
Midterm Review
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
UNIX Concepts
UNIX is a multi-user system
–Users hava a user name, a numerical user id (e.g. 500), and a home directory
–The privileged user root with UID 0 has (essentially) unlimited access
UNIX is a multi-tasking system, i.e. it can run multiple programs at once. A
running program (with its data) is called a process . Each process has:
–Owner (a user)
–Working directory (a place in the ﬁle system)
–Various resources
Ashell is a command interpreter, i.e. a process accepting and executing commands
from a user.
–A shell is typically owned by the user using it
–The initial working directory of a shell is typically the users home directory
(but can be changed by commands)
Stephan Schulz 300
The File System
dev tmp usr bin etc home
(Devices) (Configuration) (Home directories) (Temporary files)/
cplsps hdahdbkbdpasswd hosts joejaneschulz
(Private files)local lib bin
libbin coreDesktop(Vendor) (Vendor)(Root directory)
(System programs) (User programs)
(Site−installed)
In UNIX, all ﬁles are organized in a single directory tree
There are two main types of ﬁles:
–Plain ﬁles (containing data)
–Directories, containing both plain ﬁles (optionally) and other directories
Stephan Schulz 301
Globbing
Glob patterns describe sets of ﬁle names
A string is a wildcard pattern if it contains one of ?,*or[
A wildcard pattern expands into all ﬁle names matching it
–A normal letter in a pattern matches itself
–A ? in a pattern matches any one letter
–A * in a pattern matches any string
–A pattern [l1. . . l n]matches any one of the enclosed letters (exception: ! as
the ﬁrst letter)
–A pattern [!l1. . . l n]matches any one of the characters notin the set
–A leading .in a ﬁlename is never matched by anything except an explicit
leading dot
Important: Globbing is performed by the shell , not an application program!
Stephan Schulz 302
Some Important UNIX Commands (1)
Orientation and moving around
–whoami
–pwd – print working directory
–cd– change directory
–ls– list ﬁles (Important options: -a,-l)
Operating on ﬁles
–cat– concatenate and print ﬁles
–lessandmore – print ﬁles page by page
–touch – change access dates (or create empty ﬁles)
–mv– move ﬁles
–cp– copy ﬁles
–rm– remove ﬁles
–wc– count words (and lines and characters)
Stephan Schulz 303
Some Important UNIX Commands (2)
Working on Directories:
–mkdir – make a new directory
–rmdir – remove an empty directory
Miscellanous
–man – read the manual ( -k: Search for keywords in the manual)
–info – read info format documentation (also available through emacs
–echo – Print arguments
–grep – Search lines matching a regular expression
Stephan Schulz 304
Input and Output Redirection, Piping
The three standard UNIX IO channels are
–stdin (Standard Input)
–stdout (Standard Output)
–stderr (Errors)
Normal output redirection redirects stdout into a ﬁle:
Input redirection makes stdin read from a ﬁle
Piping connects one processes stdout to the stdin of another process
cat > newfile # Read stdin, write to newfile
cat < newfile # Read newfile, write to terminal
cat > newfile < oldfile # Poor man’s copy
cat newfile | wc # Count words in newfile
Stephan Schulz 305
Process Control
Processes started from the shell can be
–Running or Suspended
–In the foreground (accepting keyboard input) or in the background
Simple process control:
–Running a command followed by & starts it in the background (normally
commands are executed in the foreground)
–^Z(Control-Z) will suspend a foreground process
–^C(Control-C) will terminate it
–fgwakes a suspended process and puts it into the foreground
–bgputs it into the background
–killcan be used to terminate it
–jobs prints a list of active processes started from a shell
Stephan Schulz 306
C Compiling with gcc
Programs consisting of a single .cﬁlecan be compiled in one step
–gcc -o ﬁle ﬁle.c will compile ﬁle.c into an executable program ﬁle
Multiple C ﬁles must be compiled and linked separately!
–gcc -c -o ﬁle1.o ﬁle1.c compiles the ﬁle into an object ( .o) ﬁle
–gcc -o ﬁle ﬁle1.o ﬁle2.o... links the diﬀerent object ﬁles together to form an
executable
Important gccoptions:
–-o<name >: Give the name of the output ﬁle
–-ansi : Compile strict ANSI-89 C only
–-Wall : Warn about all dubious lines
–-c: Don’t perform linking, just generate a (linkable) object ﬁle
–-O–-O6: Use increasing levels of optimization to generate faster executables
Stephan Schulz 307
C Datatypes
The language oﬀers a set of basic types built into the language
–char, short, int, long, long long
–float, double
–Integer data types come in signed and unsigned variety!
We can deﬁne new, quasi-basic types as enumerations ( enum )
We can derive new types as follows:
–Arrays over a base type ( [])
–Structures combining base types ( struct )
–Unions (able to store alternative types) ( union )
–Pointer to a base type ( *)
typedef is used to deﬁne named new types
Stephan Schulz 308
Flow Control
if...else
–Conditional execution
switch
–Select between many alternatives, based on a single integer type variable
–Remember fall through property and break; !
while
–Loop as long as a condition is true
for
–As while, but included initialization and update in a single statement
Stephan Schulz 309
Functions
Any C program is a collection of functions
–There has to be exactly onefunction called main() in the program
–Execution starts by a call to main() (executed by the OS)
–Afunction deﬁnition consists of a header and a body
The header consists of:
–Thereturn type of the function
–Thename of the function
–A parenthesized list of formal arguments
Thebody of the function is a sequence of declarations and statements
–Execution of the function ends when a return statement is encountered or
the end of the body is reaches
–The argument of the return statement is the value returned from the function
call
Stephan Schulz 310
C Preprocessor
The#include directive is used to include other ﬁles (the contents of the named
ﬁle replaces the #include directive)
The #define directive is used to deﬁne macros
–Macros can simply deﬁne a textual constant
–Macros can have formal arguments, which will be instanciated in the replace-
ment text
#if/#else/#endif is used for conditional compilaton
–The controlling expression of the #ifhas to be a constant integer expression
–Special case: #ifdef tests if a macro is deﬁned
–Special case: #ifndef tests if a macro is notdeﬁned
Stephan Schulz 311
Exercises
Reread the lecture notes
Download the C examples from the Web
–Read the code
–Compile them by hand
–Run them
Stephan Schulz 312
CSC322
C Programming and UNIX
Programming in C
Dynamic Arrays and Pointer Arithmetic
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Dynamically Allocated Arrays
Since pointers and arrays can be used interchangably in many contexts, we can
usemalloc() to allocate arrays of whatever size we need!
–The size of an array of nelements of type tis just n*sizeof(t)
Applications:
–We can allocate arrays in a function and return pointers to them (remember
that local variables are destroyed when control leaves a function)
–We can determine array size at run time
–We can dynamically increase array size by:
∗Allocating a bigger array
∗Copying the old array into the initial part of the new array
∗Freeing the old array
Stephan Schulz 314
Example
#include <stdio.h>
#include <stdlib.h>
#define BUF_SIZE 1024
int main(void)
{
int c, count=0;
char* buffer;
buffer = malloc(sizeof(char)*BUF_SIZE);/* Missing check! */
while((c=getchar())!=EOF)
{
if(count == BUF_SIZE-1)
{
printf("Buffer full\n"); exit(EXIT_FAILURE);
}
buffer[count++] = c;
}
buffer[count] = ’\0’;
printf("%s\n", buffer);
free(buffer);
return EXIT_SUCCESS;
}
Stephan Schulz 315
Changing Allocated Block Size: realloc()
void* realloc(void* ptr, size t size); is deﬁned in <stdlib.h>
–It’s ﬁrst argument is a pointer to a block of memory on the heap (obtained
with malloc() ,realloc() , or an equivalent function)
–The second argument is a desired new size of the block
–realloc() returns a pointer to a new block of memory, of the desired size (if
available, otherwise NULL )
–Ifrealloc() is successfull, the initial part of the new block (up to the smaller
of the two sizes) will be identical to the old block
Special cases:
–ifptris NULL, realloc() is equivalent to malloc()
–Ifsize isNULL ,realloc() is equivalent to free
–As with malloc() , we always have to check the return value!
Most common use: Increase the size of some array
Stephan Schulz 316
Example: Growing the Buﬀer as Needed
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int c, count=0, size = 2;
char* buffer;
buffer = malloc(sizeof(char)*size); /* Missing check! */
while((c=getchar())!=EOF)
{
if(count == size - 1)
{
size = size * 2;
buffer = realloc(buffer, size); /* Missing check! */
}
buffer[count++] = c;
}
buffer[count] = ’\0’;
printf("%s\n", buffer);
free(buffer);
return EXIT_SUCCESS;
}
Stephan Schulz 317
Additional Pointer Properties
Pointers of the same type can be compared using <, >, <=, >=
–The result is only deﬁned, when both pointers point at elements in the
same array or struct, or if both pointers point to addresses within the same
malloc() ed block
–Pointers to elements with a smaller index are smaller than pointers to elements
with a larger index
Pointer arithmetic allows addition of integers to (non-void) pointers
–Ifppoints to element nin an array, p+kpoints to element n+k
–As a special case, p[n] and*(p+n) can again be used interchangably (and
often are in practice)
–Most frequent case: Use p++to advance a pointer to the next element in an
array
–Note that pointer arithmetic only works on non- void pointers
Stephan Schulz 318
Pointer Arithmetic
char arr1[28]
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
0cp
\0cp+1
cp+2
cq=cp+12int arr2[7]
17
42
−13
−1ip
2147483647
10242p+1
iq
iq+2&ip[2]
=ip+3char *cp, *cq;
int *ip, *iq;
Stephan Schulz 319
Pointer Arithmetic Example
#include <stdlib.h>
#include <stdio.h>
int print_str(char *string)
{
int i = 0;
while(*string)
{
putchar(*string);
string++;
i++;
}
return i;
}
int main(int argc, char* argv[])
{
char message[] = "Hello World!\n";
int count;
count = print_str(message);
printf("Printed %d characters!\n", count);
return EXIT_SUCCESS;
}
Stephan Schulz 320
Reading the Command Line: argc and argv
The C standard deﬁnes a standardized way for a program to access its (command
line) arguments: main() can be deﬁned with two additional arguments
–int argc gives the number of arguments (including the program name)
–char *argv[] is an array of pointers to character strings each corresponding
to a command line argument
Since the name under which the program was called is included among its
arguments, argc is always at least one
–argv[0] is the program name
–argv[argc-1] is the last argument
–argv[argc] is guranteed to be NULL
Stephan Schulz 321
Example: Echoing Arguments
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[])
{
int i;
for(i=1; i<argc; i++)
{
printf("%s ", argv[i]);
}
putchar(’\n’);
return EXIT_SUCCESS;
}
Stephan Schulz 322
Example: Echoing Arguments – Idiomatic
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[])
{
char **p;
for(p=argv+1; *p; p++)
{
printf("%s ", *p);
}
putchar(’\n’);
return EXIT_SUCCESS;
}
Stephan Schulz 323
Exercises
Write a function that reads a line (terminated by ’\n’ ) into an array, and a
program that reads ﬁles line by line and prints it back. You can assume a
reasonable ﬁxed length (e.g. 1024 characters) per line
Write a library that implements a dynamic array type for char arrays.
–Implement functions that can assign and retrieve values from arbitrary positions,
e.g. void darrayassign(darray p array, int index, char newval)
andchar darrayvalue(darray p array, int index)
–Write a function darrayalloc() that returns a pointer to a freshly allocated
dynamic array
–Write a function darrayfree() that frees such an array
–Hint: Use a struct that contains at least a pointer to the dynamically
allocated proper array and the currently allocated array size. If an index
greater than the size occurs, use realloc() to increase the size
Put the two together: Write a function that can read a line of any length and
returns (a pointer to) it
Stephan Schulz 324
CSC322
C Programming and UNIX
Making Programming Easier
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
The rpn calc Example
ctype.h stdlib.h
chario.h
integerio.h
chario.o integerio.o rpn_calc.o (libc)
rpn_calcintegerio.c chario.cstdio.h
Link (gcc)Compile (gcc −c)#include
rpn_calc.c
Stephan Schulz 326
The rpn calc Example (Simpliﬁed)
chario.h
integerio.h
chario.o integerio.o rpn_calc.o
rpn_calcintegerio.c chario.c rpn_calc.c
Stephan Schulz 327
Program Dependencies
In the example, changing one ﬁle may make many steps necessary to propagate
the change
–If any .hﬁle has been changed, all .cﬁles that include it may have to be
recompiled
–If any .cﬁle has changed, it has to be recompiled
–If any .oﬁle has changed, we need to relink the program
–In more complex programs, even more such situations exist!
Recompiling allﬁles and relinking (in the right order) solves the problem. . .
–Very expensive for large programs
∗Mozilla, Windows NT: Many hours
∗Linux kernel (on modern machine): Many minutes
∗E theorem prover: 1-2 minutes
–We still need to know the right order!
Recompiling by hand is error-prone (and inconvenient)
Stephan Schulz 328
UNIX User Utilities: make
make is a UNIX utility that can automatically update large projects with complex
dependencies
–Dependencies and build instructions are described in a ﬁle called Makefile
(preferred form) or makefile
A makeﬁle contains a number of rules for rebuilding the project
A rule consist of a target , a list of prerequisites , and commands for rebuilding
–Thetarget normally is a ﬁle that needs rebuilding
–Theprerequisites are all ﬁles that are needed to rebuild the target
–Finally, the commands describe how to rebuild the target
Semantics:
–Execution begins with the ﬁrst target (or a target given on the command line)
–First, rules for all prerequisites are activated (if any)
–Then, if the target does not exist, or if any of the prerequisites is younger than
the target, the commands are executed
Stephan Schulz 329
Example: rpn calc makeﬁle
# Relink rpn_calc if one of the object files changed
rpn_calc: chario.o integerio.o rpn_calc.o
gcc -ansi -Wall -o rpn_calc chario.o integerio.o rpn_calc.o
# Recompile chario if either the .h or the .h changed
chario.o: chario.h chario.c
gcc -ansi -Wall -c -o chario.o chario.c
#...
integerio.o: chario.h integerio.h integerio.c
gcc -ansi -Wall -c -o integerio.o integerio.c
#...
rpn_calc.o: integerio.h chario.h rpn_calc.c
gcc -Wall -ansi -c -o rpn_calc.o rpn_calc.c
# General format:
#
# TARGET: PREREQUISITES
# [TAB] command1
# [TAB] command2 ...
Stephan Schulz 330
Built-In Rules and Makeﬁle Variables
make knows how to remake many types of ﬁles!
–In particular, make knows how to run the C compiler to build object ( .o) ﬁles
from .cﬁles
We could have omitted the comiler command e.g. from the rule for chario.o :
chario.o: chario.h chario.c
make allows the use of variables , both for custimization and for more compact
makeﬁles
–Variables are setusing the assignment operator:
RPN=chario.o integerio.o rpn_calc.o
–Variables are referenced using a $: $(RPN)
Important predeﬁned variables:
–CC: Name of the C compiler
–CFLAGS : Additional ﬂags for the C compiler
Stephan Schulz 331
Example: rpn calc makeﬁle revisited
CC=gcc
CFLAGS=-Wall -ansi -O6
RPN=chario.o integerio.o rpn_calc.o
# Relink rpn_calc if one of the object files changed
rpn_calc: chario.o integerio.o rpn_calc.o
gcc -ansi -Wall -o rpn_calc $(RPN)
chario.o: chario.h chario.c
integerio.o: chario.h integerio.h integerio.c
rpn_calc.o: integerio.h chario.h rpn_calc.c
Rebuilding from scratch:
$rm *.o
$make
gcc -Wall -ansi -O6 -c -o chario.o chario.c
gcc -Wall -ansi -O6 -c -o integerio.o integerio.c
gcc -Wall -ansi -O6 -c -o rpn calc.o rpn calc.c
gcc -ansi -Wall -o rpn calc chario.o integerio.o rpn calc.o
Stephan Schulz 332
Phony Targets
Not all targets need to correspond to ﬁles
–Targets not corresponding to a ﬁle are called phony
–Since no corresponding ﬁle exists, commands in rules with phony targets are
always executed
Frequent use: Cleanup commands
clean:
rm *.o
rm rpn_calc
Stephan Schulz 333
Assignment
Write a program sort csc322 that reads an arbitray length ﬁle line by line
(allowing for arbitrary line length), sort the lines in ASCIIbetical order, and prints
it back
–Order: A letter that has a smaller numerical value is smaller than a letter that
has a bigger numerical value. To compare strings, ﬁnd the ﬁrst character that
diﬀers (including the terminating ’\0’ )
–Hints:
∗If you are lazy, reuse the binary tree code for sorting!
∗Deﬁne a data type for the lines, using struct andchar*
Include a Makefile for building your ﬁnal program from the sources!
–More hint: If you are lazy, read man makedepend
Stephan Schulz 334
CSC322
C Programming and UNIX
Odds And Ends
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Errors, Bugs, and Other Unpleasant Animals
Most hard-to-handle errors are notsyntax errors
–Most syntax errors go away with experience
–Even if not, they are usually easy to ﬁnd and ﬁx!
Most serious problems are runtime errors, resulting from faulty program logic
–Finding logic errors is hard
–Not ﬁnding them is worse!
Examples:
–Spacecraft may crash (Mars Climate Orbiter) or explode (Ariane-5)
–Medical devices may actually kill patients (Therac-25 cancer treatment device)
–The IRS may decide you are a tax evader, and have you arrested!
Ways to (more) correct software:
–Formal methods and a controlled development process
–Testing
–Internal consistency checks
Stephan Schulz 336
Assertions
Internal consistency check are used to verify that assumptions about the state of
the program are true
–Very frequent use: Check if parameters to functions have valid values
–Check loop invariants
–Check array boundaries
Problems
–Checks are inconvenient to program
–The checks may cause unacceptable slowdowns (E theorem prover: Factor of
2–3, depending on input data)
C solution: The <assert.h> header ﬁle and macros
–Convenient way to add simple consistency checks
–Checks can be disabled at compile time (now slow-down for ﬁnal product)
Stephan Schulz 337
<assert.h> and assert()
The assert() macro is deﬁned in assert.h
It is used with a single argument
If that argument has the truth value “true”, nothing happens
Otherwise, assert() prints an error message and aborts the program
–Error message contains text of the assertion, name of source ﬁle, line in ﬁle
If the preprocessor macro NDEBUG is deﬁned, assert() is ignored (deﬁned as the
empty macro)
Careful use of assert() while testing makes your programs much more robust
and helps you weed out errors earlier!
Stephan Schulz 338
Example
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
int gcd(int a, int b)
{
assert(a>0);assert(b>0);
if(a==b)
{
return a;
}
if(a > b)
{
return gcd(a-b,b);
}
return gcd(b-a,a);
}
int main(void)
{
printf("Result: %d\n", gcd(15,3));
printf("Result: %d\n", gcd(0,2));
return EXIT_SUCCESS;
}
Stephan Schulz 339
Example (Continued)
$gcc -ansi -Wall -o gcd assert gcd assert.c
$./gcd assert
Result: 3
gcd assert: gcd assert.c:7: gcd: Assertion ‘a>0’ failed.
Abort
$gcc -ansi -Wall -o gcd assert gcd assert.c -DNDEBUG
$./gcd assert
Result: 3
Segmentation fault
Stephan Schulz 340
Search in Loops
A frequent use of loops is to search for something in a sequence (list or array) of
elements
First attempt: Search for an element with property Pinarray
for(i=0; (i< array_size) && !P(array[i]); i=i+1)
{ /* Empty Body */ }
if(i!=array_size)
{
do_something(array[i]);
}
–Combines property test and loop traversal test (unrelated tests!) in one
expression
–Property test is negated
–We still have to check if we found something at the end (in a not very intuitive
test)
Is there a better way?
Stephan Schulz 341
Early Exit: break
C oﬀers a way to handle early loop exits
The break; statement will always exit the innermost (structured) loop (or
switch) statement
Example revisited:
for(i=0; i< array_size; i=i+1)
{
if(P(array[i])
{
do_something(array[i]);
break;
}
}
–Iﬁnd this easier to read
–Note that the loop is still single entry/single exit, although control ﬂow in the
loop is more complex
Stephan Schulz 342
Selective Operations and Special Cases
Assume we have a sequence of elements, and have to handle them diﬀerently,
depending on properties:
for(i=0; i< array_size; i=i+1)
{
if(P1(array[i])
{
/* Nothing to do */
}
else if(P2(array[i]))
{
do_something(array[i]);
}
else
{
do_something_really_complex(array[i]);
}
}
Because of the special cases, all the main stuﬀ is hidden away in an else
Wouldn’t it be nice to just goto the top of the loop?
Stephan Schulz 343
Early Continuation: continue
Acontinue; statement will immediately start a new iteration of the current loop
–For C forloops, the update expression will be evaluated!
Example with continue:
for(i=0; i< array_size; i=i+1)
{
if(P1(array[i])
{
continue;
}
if(P2(array[i]))
{
do_something2(array[i]);
continue;
}
do_something_really_complex(array[i]);
}
Stephan Schulz 344
do/while Loops
Both while andforloops in C are controlled at the top
–If the controlling expression is false, the loop is not entered at all
Occasionally, we can express some algorithms more conveniently, if we have a
controlling expression at the end of the loop
–Loop body is always executed at least once!
C language construct: do/while() loop
do
{
loop body
}while(E);
–IfEevaluates to true at the end of the loop, control is transferred back to the
do
Stephan Schulz 345
Example
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[])
{
int c;
do
{
printf("Please choose 1 for half of a bad joke or 2 for a cool number!\n");
c=getchar();
}while(!(c==’1’ || c==’2’));
if(c==’1’)
{
printf("Why did the chicken cross the road? ...\n");
}
else
{
printf("42\n");
}
return EXIT_SUCCESS;
}
Stephan Schulz 346
Some Loop Statistics
E theorem prover
–State of the art automated theorem prover
–About 100000 lines of C code (20000 statements, the rest is comments, white
space, deﬁnitions....)
–Total of 942 structured loop statements in code base
521for() loops
–Most iterate over integer values ( for i=0; i<limit; i++)
421while loops
–Many iterate over linked structures:
while(handle is not NULL)
{
do something with *handle;
make handle point to "next" element;
}
0doloops, but plenty of recursion
Stephan Schulz 347
Exercises
Go back over your excercises ans assignments, and think about good places to
insert assert() statements
Write a non-recursive function that searches for a value in a binary search tree.
Usebreak to leave the lopp if you found it!
Think about uses for do/while ;-)
Stephan Schulz 348
CSC322
C Programming and UNIX
Function Pointers
C Standard Library (1)
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Functions as Arguments
Occasionally, you want to be able to pass around functions just like data
Example:
–Conﬁgure an event handler (“call this function if the UPS signals power-down”)
–Simulate some object-oriented techniques (virtual functions), e.g. to implement
destructors
–Most importantly: Parameterize algorithms
Functional languages have functions as ﬁrst class objects
C is less ﬂexible, but gives us function pointers to pass as arguments and store in
variables
–Idea: Pointers are addresses in memory
–Functions are pieces of code in memory
Stephan Schulz 350
Function Pointers
We can use the address of a function to call it!
–As with normal pointers, we need know the type of the function (in this case,
the return type and the type of the arguments it takes)
Syntax: Same principle as for other type!
–To declare a function pointer, use a function declaration, but add parentheses
and add a * to denote that it is a pointer:
int (*add)(int x1, int x2);
–This declares addto be a pointer to a function accepting two integer arguments
and returning a third integer
To use a function pointer: Just dereference the pointer
a = (*add)(10,20);
To assign a value to the pointer, just get the address of a function:
add = &some_function_name;
Stephan Schulz 351
Function Pointers (2)
To confuse students (and for convenience), it is possible to omit both the
dereferencing in calling and the ampersand in assigning:
add = somefunction
a = add(10,20);
–Since there is nothing else you can do with functions in C, these simpliﬁcations
do not create am ambiguity
–They tend to make code easier to read, though, especially with functions that
return pointers
Note: Since declarations quickly become hard to read, it is wise to always use
typedef to deﬁne a suitble function pointer type!
Stephan Schulz 352
Example
#include <stdlib.h>
#include <stdio.h>
int add(int x1, int x2)
{ return x1+x2; }
int subtract(int x1, int x2)
{ return x1-x2; }
void use_fun(int limit, int (*fun)(int x1, int x2))
{
int i;
for(i=0; i<limit; i++)
{
printf("Result: %d\n",fun(20,i));
}
}
int main(int argc, char* argv[])
{
use_fun(5, &add); /* Can drop & here */
printf("--------\n");
use_fun(5, subtract); /* Can add & here! */
return EXIT_SUCCESS;
}
Stephan Schulz 353
Example Output
Result: 20
Result: 21
Result: 22
Result: 23
Result: 24
--------
Result: 20
Result: 19
Result: 18
Result: 17
Result: 16
Stephan Schulz 354
C Library Functions: qsort()
qsort() is a very useful C library function (declared in <stdlib.c> that is able
to sort any kind of array (and normally does so very eﬃciently)!
qsort is deﬁned as follows:
void qsort(void *base, size_t nmemb, size_t size,
int(*compar)(const void *, const void *));
–The ﬁrst argument points to the array to be sorted (i.e. to its ﬁrst argument)
–The second argument is the number of elements in the array
–The third argument gives the size if a single element
–Finally, the last element is a function pointer of a function taking two pointer
arguments, and returning an integer value
Stephan Schulz 355
C Library Functions: qsort() (2)
qsort deﬁnition (repeated):
void qsort(void *base, size_t nmemb, size_t size,
int(*compar)(const void *, const void *));
Purpose of compar : Let the caller deﬁne an order on elements
–(*compar)() is called by qsort() to compare two arguments
–It gets pointers to two array elements as arguments
–It should compare these elements and return
∗0, if the two elements are equal (under the order)
∗A negative integer, if the ﬁrst element is smaller
∗A positive integer, if the ﬁrst element is greater
Stephan Schulz 356
Example
#include <stdlib.h>
#include <stdio.h>
typedef int (*CompareFun)(const void* arg1, const void* arg2);
int compare_ints(int *arg1, int* arg2)
{
if(*arg1 < *arg2)
{
return -1;
}
if(*arg1 > *arg2)
{
return 1;
}
return 0;
}
Stephan Schulz 357
Example (continued)
int main(int argc, char* argv[])
{
int array[10], i;
for(i=0; i<10; i++)
{
array[i] = rand()%128;
}
printf("Unsorted: \n");
for(i=0; i<10; i++)
{
printf("%d\n", array[i]);
}
qsort(array, 10, sizeof(int), (CompareFun)compare_ints);
printf("Sorted: \n");
for(i=0; i<10; i++)
{
printf("%d\n", array[i]);
}
return EXIT_SUCCESS;
}
Stephan Schulz 358
Example (Output)
Unsorted:
103
70
105
115
81
127
74
108
41
77
Sorted:
41
70
74
77
81
103
105
108
115
127
Stephan Schulz 359
The C Standard Library
The C Standard Library contains a large number of functions, some data types
and system dependend constants
–Covers many things that other languages handle in the main language
–Also contains primitives for extending some parts of the language
–Notably missing: Any functionality for graphics (only stream-based I/O)
Most parts of the library are automatically linked with the C programs (exception:
Floating point math functions)
The standard library is part of the C standard, and has to be supported on any
standards-compliant full C implementation
–Code written using only the standard library should be highly portable
The library has 15 parts with corresponding header ﬁles
–Some declarations are repeated in diﬀerent headers
Stephan Schulz 360
C Standard Library Organisation
–assert.h : Assertions (*)
–ctype.h : Character classes (+)
–errno.h : Error reporting for library functions
–float.h : Implementation limits for ﬂoating point numbers
–limits.h : Limits for other things
–locale.h : Localization support
–math.h : Mathematical functions
–setjmp.h : Non-local function exits
–signal.h : Signal handling
–stdarg.h : Support for functions with a variable number of arguments (as
e.g.printf() )
–stddef.h : Standard macros and typedefs
–stdio.h : Input and output (+)
–stdlib.h : Miscellaneous library functions (+)
–string.h : String (character array) handling
–time.h : Functions about time and date
Stephan Schulz 361
Error Handling: errno.h
Library functions typically signal an error by returning an out of range value, i.e.
a value that cannot possibly be correct
–For many functions that is -1orNULL
They communicate the cause of the error by setting the global int variable
errno to a speciﬁc value
–At the program start, errno is guaranteed to have the value 0
–No library function will ever set errno to0, but failed library functions will set
it to an implemetation-deﬁned value encoding the cause of the error
Error codes have symbolic names (with #define ):
–EDOM : (Required by the standard) Domain error for some math functions
–ERANGE : (Required by the standard) Range error for some math functions
–EAGAIN : (UNIX) Temporary problem, try again
–ENOMEM : (UNIX) Out of memory
–EBUSY : (UNIX) Some necessary resource is already in use
–EINVAL : (UNIX) Invalid argument to some function
Stephan Schulz 362
Example
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
int main(int argc, char* argv[])
{
char *res;
printf("errno: %d\n", errno);
res = strdup("Hallo"); /* Allocate space, copy the string to it */
if(!res)
{
printf("Could not copy string, errno: %d = %d\n", errno, ENOMEM);
}
else
{
printf("All is fine, errno: %d\n", errno);
free(res);
}
return EXIT_SUCCESS;
}
Stephan Schulz 363
Exercises
Write a program that sorts an arbitrary sized array of double values
Think about a program that sorts pointers to char, based on the characters (or
character arrays) the pointers point to (yes, this is a hint for your assignement)
Check out /usr/include/errno.h and/usr/include/asm/errno.h
Stephan Schulz 364
CSC322
C Programming and UNIX
C Standard Library
Characters and Strings
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Character Classes and <ctype.h>
Th C standard deﬁnes several character classes in a portable way
–We can use these functions regardless of the underlying character set of the
implementation
–Most of these functions can be (and are) implemented in a very eﬃcient
manner for ASCII characters
C characters are integer values, typically 8 bits wide
–On most implementations, char is an 8 bit extension to ASCII (in recent time,
isolatin-1 or variants have become popular)
–There is limited support for bigger character sets using wchar t
Character handling functions are deﬁned in <ctype.h>
Stephan Schulz 366
Some C Character Classes
All character class functions accept and return intvalues
–Behaviour is only deﬁned if the input is from the range of unsigned char or
EOF
–Each function returns true (non-0) if the character is in the range, 0otherwise
Character class test functions
–isdigit(c) : Digits, i.e. {0-9}
–isalpha(c) : Upper and lower case characters ( {a-z,A-Z }, in some locales
additional characters, e.g. umlauts like ¨ a,¨O,. . .
–isalnum(c) : Equivalent to (isdigit(c)||isalpha(c))
–iscntrl(c) : Control characters, i.e. non-printable characters (in ASCII, those
are characters with codes 0 to 31 and 127)
–isxdigit(c) : Hexadecimal digits, {0-9,a-z,A-Z }
–islower(c) : Lower case letters
–isupper(c) : Upper case letters
–ispunct(c) : Printing characters that are neither letters, digits, nor space
–isprint(c) : Normal, printable characters
Stephan Schulz 367
Character Class Conversion Functions
There are two functions for converting characters from one class to another:
–tolower(c) converts upper case characters to lower case characters
–toupper(c) converts lower case characters to upper case characters
Both functions return the character unchanged, if it is not a upper or lower case
character, respectively
Stephan Schulz 368
Example
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
int main(void)
{
int c;
while((c=getchar())!=EOF)
{
if(iscntrl(c))
{
printf("<control-character %d\n", c);
}
else
{
putchar(toupper(c));
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 369
Example Output
$man man |ctypedemo
MAN(1) MANUAL PAGER UTILS MAN(1)<control-charac
ter 10>
<control-character 10>
<control-character 10>
<control-character 10>
N<control-character 8>
NA<control-character 8>
AM<control-character 8>
ME<control-character 8>
E<control-character 10>
MAN - AN INTERFACE TO THE ON-LINE REFERENCE MANUALS<control-character 10>
<control-character 10>
S<control-character 8>
SY<control-character 8>
YN<control-character 8>
NO<control-character 8>
OP<control-character 8>
PS<control-character 8>
SI<control-character 8>
Stephan Schulz 370
Strings
Strings are not part of the C language proper
–String literals are supported
–Limited support by functions the C standard library
String-handling functions are operating on char* (pointer to char) values
–It is the responsibility of the program to make sure that there is suﬃcient
space for the operations available!
Convention for strings:
–Strings are \0terminated arrays of character
–Important: Size of the array is nottaken into account!
char excess[10000] = "a"; /* String length 1, takes up two
characters, a and \0 */
char tooshort[2];
tooshort[0] = ’a’;
tooshort[1] = ’b’; /* tooshort is not a valid string, if treated
as one, behaviour is undefined */
Stephan Schulz 371
String Functions from <string.h> (1)
char *strcpy(char* s, const char *ct)
–Copy a ’\0’ -terminated string from cttos
–Returns s
–smust point to a suﬃciently large area of memory!
–Note: For all string functions that copy strings, source and target areas may
not overlap (otherwise, behaviour is undeﬁned)
char *strncpy(char* s, const char *ct, size t n)
–Asstrcpy() , but copies at most ncharacters
–Note: If ctis longer than n,swill not be ’\0’ -terminated
–Ifctis shorter than n, then the result will be padded with additional ’\0’
characters (i.e. smust always have space for ncharacters, even if ctis shorter
than ncharacters)
size t strlen(const char *cs)
–Return the length of the string at cs
–Does not count the trailing ’\0’
Stephan Schulz 372
Example: Duplicating Strings
Several UNIX standards deﬁne a function strdup() that allocates enough
memory for a string, and then copies it, returning the pointer to the newly
allocated memory
Our version also makes sure that there is memory available:
char* SecureStrdup(char* str)
{
char *newstr = SecureMalloc(strlen(str)+1);
return strcpy(newstr,str);
}
Stephan Schulz 373
String Functions from <string.h> (2)
char *strcat(char *s, const char *ct)
–Concatenates ctat the end of s
–Returns s
–Result is always ’\0’ terminated
char *strncat(char *s, const char *ct, size t n)
–Asstrcat() , but copies at most ncharacters from ct
–Result is always ’\0’ (even if ctis longer than n
Examples:
char *t="World";
char s[10] = "Hello";
strncat(s,t,3); /* Ok, t now points to "HelloWor" */
strcat(s,t); /* Error: "HelloWorld" requires 11 character (’\0’!) */
Stephan Schulz 374
String Functions from <string.h> (3)
int strcmp(const char* cs, const char* ct)
–Compare two strings in the lexical extension of the natural order on characters
–First diﬀering character decides which string is bigger (including terminating
’\0’ , i.e. a substring is always smaller than a superstring)
–Return value: Integer <0, ifcsis smaller, >0, ifctis smaller, or 0if both are
equal
int strncmp(const char* cs, const char* ct, size t n)
–Asstrcmp() , but compare at most ncharacters
char *strchr(const char *s, int c)
–Return pointer to the ﬁrst occurrence of cincs(orNULL , ifcis not present
incs)
char *strrchr(const char *s, int c)
–Return pointer to the lastoccurrence of cincs(orNULL )
Stephan Schulz 375
String Functions from <string.h> (4)
char *strpbrk(const char *cs, const char *ct)
–Returns pointer to ﬁrst character from ctincs(orNULL ), i.e. ctis treated as
asetof characters
–Example:
strpbrk("Hello", "eul"); /* Returns pointer to the "e" in "Hello" */
char* strstr(const char *cs, const char *ct)
–Return pointer to ﬁrst occurrence of ctincs, orNULL ifctis not a substring
ofcs
char *strerror(int n)
–Return a pointer to a string description of the library error with error code n
(as deﬁned in <errno.h> )
–Ifnis not a known error code, a pointer to a generic “unknown error code”
message is returned
Stephan Schulz 376
Generic Memory Access Functions
The original C standard used char* as a generic pointer, hence generic memory
handling functions are lumped in with strings
–Character is just another name for Byte in C, anyways
–However, ANSI C has the generic void* pointer type
The following functions are generally very similar to the string functions, but do
not use a delimiter like ’\0’
–All operations specify a lenght parameter n, and handle exactly ncharacters
These functions basically treat the virtual memory as one big character array!
–Used to implement many basic operations
–Typically implemented very eﬃciently (often by processor speciﬁc assembler
subroutines)
Stephan Schulz 377
Memory Functions from <string.h> (1)
void *memcpy(void *s, const void *ct, size t n)
–Copy a sequence of nbytes from cttos
–The regions may not overlap!
void *memmove(void *s, const void *ct, size t n)
–Copy a sequence of nbytes from cttos
–There are no additional constraints (i.e. memmove() has to handle cases where
the regions overlap)
int memcmp(const void *cs, const void *ct, size t n)
–Compare the ﬁrst ncharacters found at csandct
–Return value: As strcmp() (<, >, = 0 )
Stephan Schulz 378
Memory Functions from <string.h> (2)
void *memchr(const char *s, int c, size t n)
–Search for character cin the ﬁrst nbytes at cs, return pointer to it (or NULL )
void *memset(void *s, int c, size t n)
–Place character cinto the ﬁrst ncharacters at s, returning s
Stephan Schulz 379
Exercises
Write a simple version of grep (looking for plain strings in stdin only)
Write a version of memmove() (the hard part is handling overlapping arrays –
remember that you can compare pointers with <,>and==)!
Stephan Schulz 380
CSC322
C Programming and UNIX
C Standard Library
Memory Handling and IO
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Generic Memory Access Functions
The original C standard used char* as a generic pointer, hence generic memory
handling functions are lumped in with strings
–Character is just another name for Byte in C, anyways
–However, ANSI C has the generic void* pointer type
The following functions are generally very similar to the string functions, but do
not use a delimiter like ’\0’
–All operations specify a lenght parameter n, and handle exactly ncharacters
These functions basically treat the virtual memory as one big character array!
–Used to implement many basic operations
–Typically implemented very eﬃciently (often by processor speciﬁc assembler
subroutines)
Stephan Schulz 382
Memory Functions from <string.h> (1)
void *memcpy(void *s, const void *ct, size t n)
–Copy a sequence of nbytes from cttos
–The regions may not overlap!
void *memmove(void *s, const void *ct, size t n)
–Copy a sequence of nbytes from cttos
–There are no additional constraints (i.e. memmove() has to handle cases where
the regions overlap)
int memcmp(const void *cs, const void *ct, size t n)
–Compare the ﬁrst ncharacters found at csandct
–Return value: As strcmp() (<, >, = 0 )
Stephan Schulz 383
Memory Functions from <string.h> (2)
void *memchr(const char *s, int c, size t n)
–Search for character cin the ﬁrst nbytes at cs, return pointer to it (or NULL )
void *memset(void *s, int c, size t n)
–Place character cinto the ﬁrst ncharacters at s, returning s
Stephan Schulz 384
Example
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[])
{
char carray[10];
int iarray[10], i;
memset(&carray[0], ’a’, 10*sizeof(char));
memset(&iarray[0], ’a’, 10*sizeof(int));
for(i=0; i<10; i++)
{
printf("%c : %d\n", carray[i], iarray[i]);
}
memset(&carray[0], ’b’, 10*sizeof(char));
memmove(&iarray[0], &carray[0], 10*sizeof(char));
for(i=0; i<10; i++)
{
printf("%c : %d\n", carray[i], iarray[i]);
}
return EXIT_SUCCESS;
}
Stephan Schulz 385
Example Output
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
a : 1633771873
b : 1650614882
b : 1650614882
b : 1633772130
b : 1633771873
b : 1633771873
b : 1633771873
b : 1633771873
b : 1633771873
b : 1633771873
b : 1633771873
Stephan Schulz 386
Input and Output in the Standard Library
Input and output in C is based on the concept of streams of bytes
–Binary streams are raw, unprocessed bytes (only guarantee: If you write data
to a binary stream, and then read it back, it is unchanged)
–Text streams are composed of (possibly empty) lines, separated by a single new-
line ( ’\n’ ) character (the library has to make sure other text representations
are converted properly)
–In UNIX, text and binary streams are identical
–In Windows, the library has to convert the newline/linefeed sequence used to
separate lines to a single newline for text streams (but, of course, may not
mangle binary streams)
Streams are represented by FILE* objects in C (“ﬁle pointers”)
–The FILE type is deﬁned in <stdio.h>
–A stream normally has to be explicitely opened (connected to an input and
output device) and should be closed (made available for resuse)
Stephan Schulz 387
Standard Streams
By default, each program has three text streams open on startup:
–stdin is the standard input (normally reading from keyboard)
–stdout is the standard output (normally conected to the terminal)
–stderr is the standard error channel (also connected to the terminal)
The I/O-functions we have used so far implicitely use the default streams:
–printf() andputchar() write to stdout
–getchar() reads from stdin
Stephan Schulz 388
Opening File Streams
In addition to the standard streams, we can create additional streams, normally
associated with a ﬁle. The most general function is:
FILE* fopen(const char *filename, const char *mode)
–The ﬁrst argument hat to be a valid ﬁlename
–The second argument describes the mode in which the ﬁle should be opened
Themode is a string of characters
–"r"opens a ﬁle for reading in text mode
–"w"opens a ﬁle for writing in text mode (will create new ﬁle, overwriting an
existing ﬁle)
–"a"opens a ﬁle for writing in text mode (but will append new output to the
end of an existing ﬁle)
–Adding a "b"will open the ﬁle as a binary ﬁle (e.g. "rb" : Read binary)
fopen() returns a valid ﬁle pointer, if successful, or NULL if it fails
–In the case of failure, it sets errno to an appropriate value!
Stephan Schulz 389
Closing and Reopening File Streams
Once we are done with a certain ﬁle, we have to close it
–The number of simultaneously open ﬁles is limited for most operating systems.
Closing a stream makes it available for other purposes
–Streams may be buﬀered . Closing a straem ﬂushes the buﬀer (i.e. prints all
remaining characters)
int fclose(FILE *stream) closes the ﬁle associated with stream
–It returns 0if no errors occurred, EOFotherwise
FILE* freopen(const char *filenam, const char *mode, FILE *stream)
–This function closes stream and reopens it with a new associated ﬁle
–It is useful to e.g. redirect stdin into a ﬁle (from within the program)
Stephan Schulz 390
Simple Stream Based I/O Functions (Characters)
int fgetc(FILE *stream)
–Return the next character from the named stream (or EOF if no character is
available or an error occurs)
–Note: getchar() is equivalent to fgetc(stdin)
int fputc(int c, FILE *stream)
–Print the character cto the stream, returning cor EOF in case of error
–putchar(c) is equivalent to fputc(c, stdout)
int getc(FILE *stream) is equivalent to fgetc() , except that it may be
implemented as a macro (and may hence evaluate stream more than once)
Similarly, int putc(int c, FILE *stream) is equivalent to fputc , but may
be a macro
Stephan Schulz 391
Simple Stream Based I/O Functions (Strings)
int fputs(const char *s, FILE *stream)
–Writes the string pointed to by the ﬁrst argument to the denoted stream
–Returns EOF on failure, a non-negative value otherwise
char *fgets(char *s, int n, FILE *stream)
–Read at most n-1characters into the array pointed to by s, stops early if a
newline is encountered
–*sis always ’\0’ terminated
–Returns s, orNULL on error
Note: There also is a function char *gets(char *s) that attempts to read a
line of input from stdin
–Never use gets() !
–Since there is no way to specify a maximal number of characters to read, we
cannot ensure that gets() will not result in a buﬀer overﬂow error!
Stephan Schulz 392
Example: Simple catImplementation
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
void print_file(FILE *stream)
{
int c;
while((c=fgetc(stream))!=EOF)
{
fputc(c, stdout);
}
}
Stephan Schulz 393
Example Continued
int main(int argc, char *argv[])
{
int i;
FILE *file;
if(argc == 1)
{
print_file(stdin);
}
else
{
Stephan Schulz 394
Example Continued
for(i=1; i<argc; i++)
{
file = fopen(argv[i], "rb");
if(!file)
{
int errno_safe = errno;
assert(errno);
fputs(argv[0],stderr); /* Print program name */
fputs(": ", stderr);
fputs(strerror(errno_safe), stderr);
fputc(’\n’, stderr);
return EXIT_FAILURE;
}
print_file(file);
fclose(file); /* Assuming it works... */
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 395
Example Output
$man man |./mycat1
man(1) man(1)
NAME
man - format and display the on-line manual pages
manpath - determine user’s search path for man pages
...
$./mycat1 does notexist
./mycat1: No such file or directory
$./mycat1 mycat1.c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
void print_file(FILE *stream)
Stephan Schulz 396
Exercises
Write a version of memmove() using pointer assignment (the hard part is handling
overlapping arrays – remember that you can compare pointers with <,>and==)!
You may need to cast void* tochar* to access individual bytes.
Write a version of wcthat more closely mimics the behaviour of the UNIX
version, i.e. that gives separate accounts and a total if called with more than one
argument (if called with a single arguments, it just gives an account for that ﬁle,
if called with none, it reads from stdin )
Stephan Schulz 397
CSC322
C Programming and UNIX
C Standard Library
Input and Output
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Remark about fgets()
char *fgets(char *s, int n, FILE *stream)
–Read at most n-1characters into the array pointed to by s, stops early if a
newline is encountered
–*sis always ’\0’ terminated
–Returns s, orNULL on error
Note:
–It is the responsibility of the caller (i.e. your program) to provide enough
memory!
–salready has to point to an array (or malloc()ed area of suﬃcient size
This holds for most standard library functions!
–. . . including gets() (never use gets() !)
Stephan Schulz 399
Example: Simple catImplementation
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
void print_file(FILE *stream)
{
int c;
while((c=fgetc(stream))!=EOF)
{
fputc(c, stdout);
}
}
Stephan Schulz 400
Example Continued
int main(int argc, char *argv[])
{
int i;
FILE *file;
if(argc == 1)
{
print_file(stdin);
}
else
{
Stephan Schulz 401
Example Continued
for(i=1; i<argc; i++)
{
file = fopen(argv[i], "rb");
if(!file)
{
int errno_safe = errno;
assert(errno);
fputs(argv[0],stderr); /* Print program name */
fputs(": ", stderr);
fputs(strerror(errno_safe), stderr);
fputc(’\n’, stderr);
return EXIT_FAILURE;
}
print_file(file);
fclose(file); /* Assuming it works... */
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 402
Example Output
$man man |./mycat1
man(1) man(1)
NAME
man - format and display the on-line manual pages
manpath - determine user’s search path for man pages
...
$./mycat1 does notexist
./mycat1: No such file or directory
$./mycat1 mycat1.c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
void print_file(FILE *stream)
Stephan Schulz 403
Reminder: Using stdin
You can redirect ﬁles into stdin :
–mycat1 < mycat.c
You can type into stdin from your terminal
–Type [C-d] (^d), ”Control-D” to indicate end of input
–Depending on your version of UNIX and your terminal, you may have to type
[C-d] on a line of it’s own
Stephan Schulz 404
Buﬀering and Flushing
Both input and output streams can be buﬀered
–Unbuﬀered streams will pass on each individual character as soon as possible
–Fully buﬀered streams will wait until the (arbitrary sized) buﬀer is full until
they pass on the collected data as one chunk
–Text streams can also be line buﬀered . A line buﬀered stream will collect at
most one line of data
int fflush(FILE* stream) willﬂush all buﬀers associated with an output
stream
–Causes data to be actually written (if the writing process dies, the data is
safe), although the OS may still have another layer of buﬀers
–Return value: 0on success, EOFon failure
–Calling fflush(NULL) ﬂushes allopen streams
–Calling fflush(NULL) on an input stream invokes undeﬁned behaviour
Stephan Schulz 405
Buﬀering
By default, the standard streams are buﬀered as follows:
–stdin is line buﬀered
–stdout is line buﬀered
–stderr is unbuﬀered
You can change the buﬀering state with the funcion
int setvbuff(FILE *stream, char* buff, int mode, size t size)
–buff points to a buﬀer of at least size byte (or it is NULL, in which case a
buﬀer will be malloc() ed)
–Mode can be one of three predeﬁned values:
∗IOFBF for full buﬀering
∗IONBF to disable buﬀering
∗IOLBF to enable line buﬀering
void setbuf(FILE *stream, char *buff) is a simpler interface:
–Ifbuff is zero, buﬀering is switched of
–Otherwise, full buﬀering wit a buﬀer size BUFSIZ is enabled (and buff has to
point to a large enough buﬀer!)
Stephan Schulz 406
Example
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[])
{
char name[80];
char buffer[BUFSIZ];
setbuf(stdout, buffer);
printf("Please enter name: ");
fgets(name,80,stdin);
printf("Your name is: %s\n", name);
setbuf(stdout, NULL);
printf("Please enter name: ");
fgets(name,80,stdin);
printf("Your name is: %s\n", name);
return EXIT_SUCCESS;
}
Stephan Schulz 407
Example Behaviour
$./buﬀtest
Stephan
Please enter name: Your name is: Stephan
Please enter name: Schulz
Your name is: Schulz
Stephan Schulz 408
More Operations on Files
int remove(const char *filename)
–Removes a ﬁle (as in rm)
–Return 0 on success, something else on failure
in rename(const char *oldname, const char *newname)
–Rename a ﬁle (as in mv)
–Return 0 on success, something else on failure
FILE *tmpfile(void)
–Creates a temporary ﬁle with mode wb+(reading and writing in binary)
–The ﬁle will vanish if the program terminates normally
–On failure, NULL will be returned
Stephan Schulz 409
Even More File Operations
char *tmpnam(char *s)
–Creates a ﬁle name that is diﬀerent from any existing name
–If called with argument NULL , will return a pointer to a static buﬀer containing
the name
–Otherwise, shas to point to an array of at least Ltmpnam bytes
–Note: Using tmpnam() in security-critical applications is discouraged, as it
creates a race condition (what if another process creates a ﬁle with the name
in between the call to tmpnam() andfopen() ?)
Stephan Schulz 410
Error Functions
Each FILE data structure stores two pieces of information:
–Ifend-of-file has been reached during reading
–If an error occurred
int feof(FILE *stream) returns true if the end-of-ﬁle indicator has been set
int ferror(FILE *stream) returns true if the error indicator is set
void clearerr(FILE *stream) clears both indicators
void perror(const char *s prints an error message to stderr as follows:
–First, the supplied string is printed, followed by a colon
–Then the error message for the current value of errno is printed, followed by
a newline
Stephan Schulz 411
Exercises
Write a simple database that keeps given name, family name, and date of birth
for a person. Subtasks:
–Create a dialog where people can enter data
–Create an interface for searching for data, based on any criterium
–Create an interface where you can print lists of people, possibly sorted by any
of the data ﬁelds
You need to think about the data base structure (a ﬂat text ﬁle should work, see
e.g./etc/passwd for ideas)
You need an architecture for your overall program
–The conventional way is to use one monolithic program with a a menue
structure (use text menues...)
–The UNIX way would be to write one program for each task
Stephan Schulz 412
CSC322
C Programming and UNIX
C Standard Library
Formated Output
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Formatted Output
The formatted output functions oﬀer a very convenient way of printing data in a
controlled manner
–They are able to print all basic C datatypes (and strings)
–They can print any number of arguments with one command
–For most datatypes, there are multiple useful formats
–Argument output and descriptive strings can be interspersed easily
Output format is determined by a format string argument
–The format string contains ordinary text that is copied directly to the output
–It also contains conversion speciﬁers that describe how to format additional
arguments
Formatted output functions are variadic , i.e. they take a variable number of
arguments
–Number of arguments is determined by the number of conversion speciﬁers
–Modern compilers check this property if the format string is constant
Stephan Schulz 414
A ﬁrst Example
printf("%d divided by %d = %f\n",22,7,22/7.0);
–The ﬁrst argument to printf is the format string
–It contains 3 conversion speciﬁers:
∗The ﬁrst %dspeciﬁes an intargument that should be printed in decimal
notation and corresponds to the ﬁrst extra argument, 22
∗The second %dcorresponds to the third argument, 7
∗Finally, the %fspeciﬁes a double (ﬂoating point) argument that should be
printed in pure decomal notation (with fractional part after the decimal dot)
The format string also contains additional text
–Text is printed
–Note that normal conventions hold, i.e. \nin a string literal is the newline
character
Output printed:
22 divided by 7 = 3.142857
Stephan Schulz 415
The printf() Family of Functions
All functions are declared in <stdio.h>
int printf(char *format, ...);
–Print the additional arguments under control of the argument string to stdout
–Returns number of characters printed, or any negative number on error
int fprintf(FILE *stream, char *format, ...);
–Asprintf() , but print to the designated output stream
int sprintf(char *s, char *format, ...);
–Instead of actually printing anything, sprintf() will store the output charac-
ters in the character array spoints to
–The string will be \0terminated
–It is the responsibility of the programmer to make sure *sis big enough
–The returned count of characters does not include the terminating nulchar-
acter (i.e. it is the same value that printf() would return)
Stephan Schulz 416
Format Speciﬁers
Format speciﬁers always start with a %character, and end in a conversion letter
–The conversion letter describes the basic output format
–It normally also decribes which kind of argument has to follow
Optional parts of a format speciﬁer include (in order)
–Flags (aﬀect how the result will be printed)
–Minimum ﬁeld width (if fewer characters are necessary, padding will be used)
–Precision (number of signiﬁcant digits/characters)
–Size modiﬁer (e.g. require short orlong instead of int)
Stephan Schulz 417
Some Conversion Letters (1)
d: Convert an intargument and print it in decimal representation
i: Alias for d
u: Convert an unsigned int argument and print it in decimal representation
o: Convert an unsigned int argument and print it in octal representation
x: Convert an unsigned int argument and print it in hexadecimal representa-
tion, using {a, b, c, d, e, f }for the extra hexadecimal digits
X: As x, but use upper case hex digits ( {A, B, C, D, E, F })
p: Convert a void* pointer and print it in an implementation-deﬁned manner
(for our system, and for many other systems, the argument is printed as a
hexadecimal number representig the address)
Stephan Schulz 418
Some Conversion Letters (2)
f: Print a double argument ( float is converted automatically) as a sequence
of digits with a decimal point
–Unless otherwise speciﬁed via the precision modiﬁer, 6 digits are printed after
the decimal point
e: Print a double argument in normalized exponential form, with 1 digit before
the decimal dot (and by default 6 digits after the dot). Example: 3.141593e+01
(= 3.141593 ∗101)
E: As e, but print upper case Ebefore exponent
g: “Human-friendly ﬂoating point output”. Print a double number either as
with e(for very small numbers) or with fletters, cutting of unneccessary training
zeros
G: As g, but use Einstead of e
Stephan Schulz 419
Some Conversion Letters (3)
c: Print a single int argument by converting it to char and printing the
corresponding character (use %ito print the numeric value of a character)
s: Print a C style string, converting a char* argument pointing to a \0-terminated
string
%: Convert no arguments, just print a single %character (i.e. %%in the format
string generates a single %in the output)
Remarks:
–We have not covered some of the more esoteric conversions
–The 1995 addendum to C89 and the C99 standard add additional conversion
characters
–For more details, check man 3 printf
Stephan Schulz 420
Example
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
char *p = "This is a string";
printf("12 with... %%d: %d, %%u: %u, %%o: %o, %%x: %x, %%X: %X\n",
12, 12, 12, 12, 12);
printf("12.5 with... %%f: %f, %%e: %e, %%E: %E, \n%%g: %g, %%G: %G\n",
12.5,12.5,12.5,12.5,12.5);
printf("Printing a character with %%c: %c and %%d: %d\n",
’a’, ’a’);
printf("This is a string \"%s\" and its address: %p\n", p,p);
return EXIT_SUCCESS;
}
Stephan Schulz 421
Example Output
12 with... %d: 12, %u: 12, %o: 14, %x: c, %X: C
12.5 with... %f: 12.500000, %e: 1.250000e+01, %E: 1.250000E+01,
%g: 12.5, %G: 12.5
Printing a character with %c: a and %d: 97
This is a string "This is a string" and its address: 0x80485a0
Stephan Schulz 422
Size Modiﬁers
Size modiﬁers are used to change the default argument size:
–The lmodiﬁer changes integer arguments to their long variants
–It changes hmodiﬁer indicates that the argument is of type short orunsigned
short instead of the default int
The C99 standard introduces additional size modiﬁers:
–zindicates argument of type size t(for integer arguments)
–llindicates long long versions of the integers
–hhindicates char arguments instead of inttypes
For us, the %ldversion (long integer) is probably the most important one
Stephan Schulz 423
Specifying Minimum Field Width
The minimum ﬁeld width is an integer literal between the %and the conversion
letter (with optional size modiﬁer)
–It may be preceded by any ﬂags
–The precision, if any, follows it
By default, any value is printed right-justiﬁed in its ﬁeld
–Padding is done with spaces:
printf("|%7d|\n",12);
| 12|
If the natural value representation is bigger than the minimum ﬁeld width, the
speciﬁcation has no eﬀect
printf("|%7s|\n", "A long string");
|A long string|
Stephan Schulz 424
The Flags
-: Left-justify output (only useful in connection with a width speciﬁcation)
0: Use 0for padding to requested ﬁeld width (by default, ’ ’(space) is used
+: For numerical values: Always print a sign, either +or-
’ ’(space): Always print a character for the sign, -for negative numbers, ’ ’
for positive ones
#: Use a variant of the conversion operation
–For%o, print a leading 0
–For%x, print a leading 0x
–For%X, print a leading 0X
–For ﬂoating point numbers, trailing digits and decimal dot are always printed
with the #ﬂag
Stephan Schulz 425
The Precision
The precision ﬁeld is used for a number of diﬀerent things:
–For any integer conversion character, it gives a minimum number of digits to
print (by adding leading zeros)
–For%e, %E and%f, it gives the number of digits in the fractional part
–For%gand%G, it is the number of signiﬁcant digits to be printed
–Finally, for strings ( %s), it gives the maximal number of characters to be
printed from the string
Stephan Schulz 426
Example
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
printf("Floating point example: |%+8.2f|\n", 3.0/7.0);
printf("Floating point example: |% 8.2f|\n", 3.0/7.0);
printf("String: %-7.7s\n", "Longish String");
printf("String: %-7.7s\n", "short");
printf("String: %7.7s\n", "short");
return EXIT_SUCCESS;
}
Output:
Floating point example: | +0.43|
Floating point example: | 0.43|
String: Longish
String: short
String: short
Stephan Schulz 427
Assignment
Write an archiver program arch322 . Your program should accept any number of
arguments (to be treated as ﬁlenames). It should write (to stdout ) an archive,
i.e. a ﬁle that contains enough information to recreate the original ﬁles with their
names. For simplicity, allow only ﬁles in the current directory to be archived
(check, if the arguments contain a /and print an error message if yes). Also
print useful error messages if one of the named ﬁles does not exist, etc.
Write a dearchiver dearch322 that accepts an archive ﬁle (in your format) on
stdin and recreates the original ﬁles in the current directory. Print an error
message if the ﬁle is not a valid archive.
You are free to design your own archive format, but you may get some ideas from
reading the documentation (man/info) on tar/gtar . Please document your
format in one or two paragraphs. You may assume UNIX I/O, i.e. no diﬀerence
between text and binary I/O.
Example:
Stephan Schulz 428
$ arch322 Makefile sort_csc322.c utilities.c > myarch.arch
$ mkdir NEW
$ cd NEW
$ dearch322 < ../myarch.arch
Recreating Makefile
Recreating sort_csc322.c
Recreating utilities.c
$ ls
$
Makefile sort_csc322.c utilities.c
Stephan Schulz 429
CSC322
C Programming and UNIX
Asynchronous Events and Signals
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Processes
A UNIX process is an instance of a program in execution. It can be described by
–The executable code (stored in the text segment of the virtual memory image
of the process
–The program data (stored in the data segement)
–The state, including stack pointer and stack, program counter, etc. (usually
collected in a process control block, or PCB)
A process uses certain resources:
–Processor time on a CPU
–Memory, both virtual or real
–File descriptors
–. . .
Some of its important properties are
–Owner
–Process id (pid), a unique non-negative integer
–Parent (exception: init )
Stephan Schulz 431
UNIX User Commands: ps
Usage: ps<complicated options >
–psshows information about currently executing processes
–It is one of the least standardized UNIX tools
Our Linux pscan assume many diﬀerent personalities
–Diﬀerent personalities show diﬀerent behaviour
–. . . and accept diﬀerent options.
Default behaviour ( pswithout options):
–Show information about all existing processes of the current user controlled by
the same terminal pswas run on
–For each process, list:
∗Process Id ( PID)
∗Controlling terminal ( TTY)
∗CPU time used by the process
∗Name of the executable program ﬁle
Stephan Schulz 432
Vanilla psExample
$ps
PID TTY TIME CMD
1125 pts/3 00:00:01 tcsh
7157 pts/3 00:00:00 xevil
7189 pts/3 00:00:00 gv
7193 pts/3 00:00:00 gs
7194 pts/3 00:00:00 ps
Stephan Schulz 433
Some psOptions
Some simple BSD style options for the default personality (note: BDS style
options for psarenotpreceeded by a dash!)
–a: Print information about allprocesses that are connected to any terminal
–x: Print information about processes notconnected to a terminal
–U<username >: Print information about processes owned by the named user
–u: User oriented output with more interesting information:
∗Owner of a process ( USER )
∗Process Id ( PID)
∗Percentage of available CPU used by the process ( %CPU )
∗Percentage of memory used ( %MEM ) (note that this measures virtual
memory usage, real memory usage may be lower because of shared pages)
∗Virtual memory size of the process in KByte ( VSZ)
∗Size of the resident set , i.e. the recently referenced pages not swapped out
(RSS)
∗Controlling terminal ( TTY)
∗Time or date when the process was started ( START )
∗Seconds of CPU time used ( TIME )
∗Full command used to start the process ( COMMAND )
Stephan Schulz 434
Interesting psExample
$ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.1 1368 432 ? S Oct30 0:04 init
root 2 0.0 0.0 0 0 ? SW Oct30 0:03 [keventd]
root 3 0.0 0.0 0 0 ? SW Oct30 0:00 [kapmd]
...
root 486 0.0 0.1 1372 408 ? S Oct30 0:00 /sbin/dhcpcd -n -h wombat eth0
root 551 0.0 0.2 1644 668 ? S Oct30 0:00 syslogd -m 0
...
schulz 1095 0.0 4.8 16112 12268 ? S Oct30 4:40 emacs -geometry 96x77+0+0 /home/schulz/.todo
schulz 1096 0.0 0.8 4944 2216 ? S Oct30 0:05 xterm -geometry 80x40-0-170 -sb -sl 360 -s -T Compile -n Compile
schulz 1997 0.0 0.5 3072 1476 ? S Oct31 0:12 ssh sherman emacs
root 4073 0.0 1.0 7480 2768 pts/3 S Oct31 0:03 /usr/local/lib/xmcd/bin-Linux-i686/xmcd
schulz 22637 0.0 0.5 2940 1444 pts/5 S Nov05 0:03 ssh -X sunbroy2.informatik.tu-muenchen.de
schulz 22645 4.0 18.7 82248 47832 ? S Nov05 31:04 /usr/local/mozilla/mozilla-bin
schulz 6722 0.0 0.0 0 0 ? Z Nov05 0:00 [plugger <defunct>]
schulz 7189 0.0 0.8 3948 2220 pts/3 S 00:15 0:00 gv CSC322_1.pdf
schulz 7235 0.4 2.2 10060 5668 pts/3 S 00:41 0:00 gs -dNOPLATFONTS -sDEVICE=x11alpha -dNOPAUSE -dQUIET -dSAFER -
schulz 7236 76.8 38.0 98072 96896 pts/0 R 00:43 0:33 eprover /home/schulz/SOURCES/E/PROVER/SET103-6+rm_eq_rstfp.lop
news 7237 0.5 1.0 3704 2796 ? S 00:43 0:00 leafnode
schulz 7258 0.0 0.2 2624 708 pts/3 R 00:43 0:00 ps aux
Stephan Schulz 435
CSC322
C Programming and UNIX
Signals and Signal Handlers
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Signals
Signals are a way to signal unusal events to a process
–Run time errors
–User requests
–Pending communication
In general, signals can arrive assynchronously, i.e. at any time
Signals can have many diﬀerent values, depending on the value, the process can
–Ignore a signal
–Perform a default action (deﬁned by the implementation)
–Invoke an explicit signal handler
Stephan Schulz 437
Standard C Signals
Standard C deﬁnes a small number of signals, UNIX deﬁnes many more
Signal Meaning Default Action (UNIX)
SIGABRT Abort the process Terminate
SIGFPE Floating point exception Terminate with core
SIGILL Illegal instruction Terminate with core
SIGINT Interactive interrupt Terminate
SIGSEGV Illegal memory access Terminate with core
SIGTERM Termination request Terminate
Note: SIGINT is generated when you press [CTRL-C] !
–The signal is delivered to the process
–The default action is to terminate the process
Stephan Schulz 438
Some UNIX Signals
UNIX deﬁnes about 60 diﬀerent signals, including all Standard C signals
Some important UNIX signals:
Signal Meaning Default Action (UNIX)
SIGHUP Terminal connection lost (or control-
ling process dies)Terminate
SIGKILL Kill process, cannot be caught or
ignoredTerminate
SIGBUS Bus error Terminate with core
SIGSTOP Stop a process (does not terminate,
cannot be caught or ignored)Suspends process
SIGCONT Continue suspended process Ignored (*)
SIGURG Out of band data arrived on a socket Ignore
SIGXCPU CPU time limit reached Terminate with core
(*) OS will still wake process up
[CTRL-Z] generates SIGSTOP !
Stephan Schulz 439
UNIX User Command: kill
Note: kill is often implemented as a shell built-in
–Syntax may diﬀer slightly from the kill program
–Allows use of kill in job control
Usage for our kill :kill [-<SIG>] <pid> ...
–If no signal is speciﬁed, SIGTERM is sent
–Signals can be speciﬁed symbolically (for a list of names run kill -l ) or
numerically ( man 7 signal gives a list of signals and their numeric values)
kill accepts a list of <pid> arguments
–Most common case: <pid> is a normal process id (a positive integer). The
signal is sent to the corresponding process
–If<pid> is-1, the signal is sent to allprocesses of the user ( kill -KILL
-1is a sureﬁre way to log yourself out)
–Finally, if <pid> is any other negative number, the signal is sent to the
corresponding process group
Stephan Schulz 440
UNIX User Commands: top
topis an interactive version of ps
–It shows various information about the topprocessed currently running
–Also shows general system information
–All information is periodically updates
–topseems to be more consistent between diﬀerent UNIX dialects, and is often
preferred for interactive use (or even for scripting)
topalso can be used to send signals to processes
–Press [k]and then specify process and signal
Non-interactive use of top (“better ps”):
–top -b -n1 will print a single page in a ps-like manner
For more information: man top or run topand hit [h]for help
Stephan Schulz 441
topExample
11:09pm up 8 days, 1:15, 7 users, load average: 0.59, 0.21, 0.07
78 processes: 71 sleeping, 4 running, 3 zombie, 0 stopped
CPU states: 95.2% user, 4.7% system, 0.0% nice, 0.0% idle
Mem: 254576K av, 249892K used, 4684K free, 0K shrd, 7428K buff
Swap: 522072K av, 30888K used, 491184K free 68440K cached
PID USER PRI NI SIZE RSS SHARE STAT %CPU %MEM TIME COMMAND
12692 schulz 25 0 25548 24M 664 R 89.3 10.0 0:08 eprover
1040 root 15 0 89416 15M 5424 S 5.5 6.4 919:35 X
1097 schulz 15 0 2324 2124 1676 S 3.7 0.8 0:15 xterm
12693 schulz 16 0 924 924 728 R 1.1 0.3 0:00 top
1096 schulz 15 0 2512 2252 1708 R 0.1 0.8 0:07 xterm
1 root 15 0 472 432 416 S 0.0 0.1 0:04 init
2 root 15 0 0 0 0 SW 0.0 0.0 0:04 keventd
3 root 15 0 0 0 0 SW 0.0 0.0 0:00 kapmd
4 root 34 19 0 0 0 SWN 0.0 0.0 0:00 ksoftirqd_CPU0
5 root 15 0 0 0 0 SW 0.0 0.0 0:09 kswapd
6 root 15 0 0 0 0 SW 0.0 0.0 0:00 bdflush
7 root 15 0 0 0 0 SW 0.0 0.0 0:00 kupdated
8 root 25 0 0 0 0 SW 0.0 0.0 0:00 mdrecoveryd
12 root 15 0 0 0 0 SW 0.0 0.0 0:01 kjournald
...
Stephan Schulz 442
Catching Signals
User programs can set up a signal handler to catch signals
–A signal handler is a normal function
–It has to be explicitely set up for each signal type
–It will be called asynchronously when a signal of the correct type has been
caught
–When the signal handler returns, the program will resume execution at the old
spot
UNIX implements several diﬀerent ways of handling signals, we will concentrate
on the ANSI C signal handling
–All use the same signal: Signals are small integers
–However, for all existing signals, we use the #defined name showed above
(SIGHUP . . . )
Signal handling stuﬀ is deﬁned in <signal.h>
Stephan Schulz 443
ANSI C Signal Handling with signal.h
signal.h deﬁnes the signal() function for establishing signal handlers as
follows:
void (*signal(int sig, void (*handler)(int)))(int)
Huh?
Stephan Schulz 444
ANSI C Signal Handling with signal.h
signal.h deﬁnes the signal() function for establishing signal handlers as
follows:
void (*signal(int ig, void (*handler)(int)))(int)
We can break this deﬁnition up as follows:
typedef void (*SigHandler)(int);
SigHandler signal(int sig, SigHandler handler);
–The ﬁrst argument to signal() is the signal to be caught
–The second argument is a pointer to the new signal handler
–Return value is a pointer to the old signal handler for that signal (or SIG ERR
if no signal handler could be established)
Predeﬁned (pseudo) signal handlers (possible arguments to signal() :
–SIG DFL: Revert to the default behaviour for that signal
–SIG IGN: Ignore the signal from now on
Stephan Schulz 445
ANSI C Signal Handling (Continued)
Additional deﬁnitions in signal.h :
sig atomic tis an integer type
–We are guartanteed that an assignment to a variable of this type is atomic ,
i.e. will not be interrupted by e.g. another signal
–That means that it’s value will always be well-deﬁned
int raise(int sig) raises a signal to the program
–Return value: 0 on success, something else otherwise
Stephan Schulz 446
ANSI C Signal Handers
A signal handler is a function that returns nothing and gets the signal that was
caught as an argument
There are several limitations on signal handler:
–Since signals can arrive asynchronously, the state of the program is not
well-deﬁned!
–Signals may be handled even within a single C statement
–Therefore a signal handler cannot make many assumptions about the state of
the program
–For maximum portability, a signal handler should only
∗Reestablish itself by calling signal()
∗Assing a value to a variable of type volatile sig atomic t
∗Return or terminate the program (e.g. calling exit() )
Once a signal has been caught, the signal handler for that signal is reset to
default behaviour
–If you want to catch multiple signals, the signal handler has to reestablish itself
Stephan Schulz 447
Common UNIX functions: sleep()
Often, a program only has to perform task only occasionally, or it has to wait for
a certain event to happen. ANSI C has no way of delaying a program
–Old-style home computer programmers use busy delay loop
–However, those are unacceptable on multi-user systems
–Moreover, they can usually be optimized away by a good compiler
All UNIX versions address this problem with the sleep() function (normally
deﬁned in <unistd.h> ):
unsigned int sleep(unsigned int seconds);
sleep() makes the current process sleep (do nothing ;-) until either
–(At least) seconds seconds have elapsed or
–A non-ignored signal arrives
Return value:
–0if sleep terminated because of elapsed time
–Number of seconds left when the process was awakened by a signal
Stephan Schulz 448
Example: Counting Signals (Fluﬀ)
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <assert.h>
typedef void (*SigHandler)(int);
volatile sig_atomic_t sig_int_flag = 0;
volatile sig_atomic_t sig_term_flag = 0;
void EstablishSignal(int sig, SigHandler handler)
{
SigHandler res;
res = signal(sig, handler);
if(res == SIG_ERR)
{
perror("Could not establish signal handler");
exit(EXIT_FAILURE);
}
}
Stephan Schulz 449
Example: Counting Signals (The Signal Handlers)
void sig_int_handler(int sig)
{
EstablishSignal(SIGINT, sig_int_handler);
assert(sig == SIGINT);
printf("Caught SIGINT!\n"); /* Risky */
sig_int_flag = 1;
}
void sig_term_handler(int sig)
{
EstablishSignal(SIGTERM, sig_term_handler);
assert(sig == SIGTERM);
printf("Caught SIGTERM!\n"); /* Risky! */
sig_term_flag = 1;
}
Stephan Schulz 450
Example: Counting Signals (Main)
int main(int argc, char* argv[])
{
int i;
int int_counter = 0;
EstablishSignal(SIGTERM, sig_term_handler);
EstablishSignal(SIGINT, sig_int_handler);
for(i=0; i<1000 && !sig_term_flag; i++)
{
printf("Going to sleep!\n");
sleep(30);
if(sig_int_flag)
{
sig_int_flag = 0;
int_counter++;
}
}
printf("SIGINTs: %d Iterations:%d\n", int_counter, i);
return EXIT_SUCCESS;
}
Stephan Schulz 451
Example Session: Live
(Change to Terminal!)
Stephan Schulz 452
Exercises
Start a long running process (e.g. top) in one xterm
Send it various signals and see how it behaves
Read man 7 signal ,man kill andman 2 kill
Download the source to the signal handler example and play with it
–Send diﬀerent signals to it
–Add your own signal handler
–Write a generic signal handler function that catches more than one signal (and
works correctly for multiple signals)
Stephan Schulz 453
CSC322
C Programming and UNIX
The UNIX File System
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
UNIX File System
UNIX philosophy: Everything is a ﬁle
–Plain ﬁles
–Hardware devices (Keyboard, mouse, hard drives)
–Network connections
Consequently, UNIX speciﬁes a lot more properties and has more ways of
manipulating a ﬁle then ANSI C
–Low-level IO
–File access rights
–Diﬀerent ﬁle types
Note: These are not ANSI C features
–We have to call gccwithout the-ansi option to use most of these features
(otherwise, most UNIX extensions are disabled)
Stephan Schulz 455
UNIX File Types (1)
Regular ﬁles
–Boring old data ﬁle (most common type of ﬁle)
–UNIX does not care what is inside that ﬁle
Directories
–Stores names and pointers to more information
–Write access is limited to kernel ﬁle system functions to assure the integrity of
the ﬁle system
Character special ﬁles
–Represent hardware devices that generate individual characters ( /dev/kbd ,
/dev/mouse )
Block special ﬁles
–Represent hardware where data is available in ﬁxed-size blocks (e.g. hard
drives, /dev/hda in Linux)
Stephan Schulz 456
UNIX File Types (2)
FIFOs (named pipes)
–Special ﬁles used for interprocess communication
Sockets
–Special ﬁles used for network communication (or local interprocess communi-
cation)
–Not available in all UNIX versions (some don’t represent network connections
as ﬁles in the ﬁle system)
Symbolic links
–A symbolic link is a ﬁle containing just a ﬁle name
–The kernel normally automatically redirects any access to the link to the named
ﬁle
Stephan Schulz 457
The stat() Functions
The three functions in the stat family all allow us to extract information about
a ﬁle
–Who owns it
–How big is it
–What kind of ﬁle is it
–. . .
They are speciﬁed as follows:
#include <sys/types.h>
#include <sys/stat.h>
int stat(const char *pathname, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *pathname, struct stat *buf);
Stephan Schulz 458
The stat() Functions (2)
All three functions perform the same basic function:
–Write information about a ﬁle into the structure bufpoints to (and which we
have to provide)
–Return 0 if the operation was possible, -1 otherwise (in which case they also
seterrno )
Diﬀerences:
–fstat() accepts a low level ﬁle descriptor referring to an open ﬁle
–lstat() will not follow symbolic links, but give information about the link
itself ( stat() given information about the ﬁle pointed to)
How exactly struct stat is deﬁned may diﬀer
–It always constains certain standard members
Stephan Schulz 459
The stat() Functions (3)
struct stat {
dev_t st_dev; /* device number*/
dev_t st_rdev; /* device type (if inode device) */
ino_t st_ino; /* inode number */
mode_t st_mode; /* access rights and file type */
nlink_t st_nlink; /* number of hard links */
uid_t st_uid; /* user ID of owner */
gid_t st_gid; /* group ID of owner */
off_t st_size; /* total size, in bytes */
unsigned long st_blksize; /* blocksize for filesystem I/O */
unsigned long st_blocks; /* number of blocks allocated */
time_t st_atime; /* time of last access */
time_t st_mtime; /* time of last modification */
time_t st_ctime; /* time of last change */
};
Interpretation of some ﬁelds is supported by predeﬁne macros
–E.g. stmode
Stephan Schulz 460
Example: Simple ls -l Version
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
void stat_file(char *fname)
{
struct stat buff;
char* type = "Unknown";
if(lstat(fname, &buff) < 0)
{
err_sys("lstat");
}
Stephan Schulz 461
Example Continued
if(S_ISREG(buff.st_mode))
{
type = "Regular file";
}
else if(S_ISDIR(buff.st_mode))
{
type = "Directory";
}
else if(S_ISCHR(buff.st_mode))
{
type = "Character special file";
}
else if(S_ISBLK(buff.st_mode))
{
type = "Block special file";
}
else if(S_ISFIFO(buff.st_mode))
{
type = "Pipe or FIFO";
}
Stephan Schulz 462
Example Continued
else if(S_ISLNK(buff.st_mode))
{
type = "Symbolic link";
}
else if(S_ISSOCK(buff.st_mode))
{
type = "Socket";
}
printf("%-30s %10ld Bytes %s\n", fname, buff.st_size,type);
}
int main(int argc, char *argv[])
{
int i;
for(i=1; i<argc; i++)
{
stat_file(argv[i]);
}
return EXIT_SUCCESS;
}
Stephan Schulz 463
Example Output
$/SOURCES/CSC 322/myls *
BINTREE 533 Bytes Directory
LIST_DEMO 549 Bytes Directory
Makefile 1322 Bytes Regular file
Makefile~ 1277 Bytes Regular file
RPN_CALC 630 Bytes Directory
RPN_CALC.tgz 10197 Bytes Regular file
SORT 373 Bytes Directory
a.out 13756 Bytes Regular file
base_converter 14634 Bytes Regular file
base_converter.c 1918 Bytes Regular file
base_converter.c~ 430 Bytes Regular file
celsius2fahrenheit 13633 Bytes Regular file
celsius2fahrenheit.c 395 Bytes Regular file
charcount 13639 Bytes Regular file
charcount.c 216 Bytes Regular file
charcount.c~ 114 Bytes Regular file
charuniq 13643 Bytes Regular file
charuniq.c 571 Bytes Regular file
...
Stephan Schulz 464
Example Output (of device directory /dev/ )
$/SOURCES/CSC 322/myls *
...
cdrom 8 Bytes Symbolic link
cdu535 0 Bytes Block special file
cfs0 0 Bytes Character special file
cm205cd 0 Bytes Block special file
cm206cd 0 Bytes Block special file
console 0 Bytes Character special file
core 11 Bytes Symbolic link
cpu 196 Bytes Directory
cua0 0 Bytes Character special file
cua1 0 Bytes Character special file
...
ham 0 Bytes Character special file
hda 0 Bytes Block special file
hda1 0 Bytes Block special file
hda10 0 Bytes Block special file
hda11 0 Bytes Block special file
hda12 0 Bytes Block special file
...
Stephan Schulz 465
Links
Links form a connection between a ﬁle name and the actual ﬁle
There are two kinds of links:
–Hard links
–Symbolic (or soft) links
A hard link links a name and a ﬁle
–Each ﬁle can have multiple hard links
–All are equivalent (no concept of “original link”), access is equally eﬃcient for
all hard links
–rmactually only removes a link, if the number of links becomes 0, the ﬁle is
ﬁnally removed)
–Typically, it is only possible to have hard links to a ﬁle on the same physical
partition or medium
Stephan Schulz 466
Links (2)
Soft links create indirect aliases for a ﬁle
–They are just ﬁles that contain another ﬁle name
–Following a soft link incurrs a small performance penalty
–Symbolic links point anywhere in the ﬁle system (no limitations as to physical
medium, networked ﬁle system, . . . )
–Symbolic links do not inﬂuence the ﬁle pointed to at all!
–If the ﬁle does not exist any more, the link still exists, but is broken
Most user-created links are soft links nowadays
–Used to share ﬁles
–Used to hide ﬁle system reorganization
Stephan Schulz 467
UNIX User Commands: ln
lnis used to create both hard and symbolic links
Usage is similar to mvandcp:
–ln <target> : Create a link to <target> in the current directory (under the
same ﬁle name)
–ln <target> <name> : Make <name> a link to <target>
–ln <target1>...<targetn> <dir> : Create links to all targets in the current
directories
Important option: -s(create symbolic links)
More: man ln
Stephan Schulz 468
Exercises
Read man stat and extend the lsexample to show more information (e.g.
everything ls -l shows)
Explain the diﬀerence between mv filea fileb ,cp filea fileb and ln
filea fileb
Stephan Schulz 469
CSC322
C Programming and UNIX
The UNIX File System
File modes
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
File Ownership
All ﬁles have an owner (a user)
–ls -l displays the user name (if available) or the numerical user id (e.g. for
ﬁles of a user that no longer exists)
Similarly, each ﬁle has a group associated with it
–This will be similarly displayed by ls -l
Owner and group of a ﬁle determine who has what kind of access to that ﬁle.
Access types are
–Read access (open a ﬁle for reading, reading data)
–Write access (change a ﬁle)
–Execute access (run a ﬁle as a program, or, for directories, access ﬁle names in
that directory
Stephan Schulz 471
ls -l Output Explained
−rw−r−−r−−    1 schulz   schulz    1283190 Nov 11 10:35 CSC322.pdf
File size in Bytes (st_size)
Group that owns the file (st_gid)
User that owns the file (st_uid)
File access rights (encoded in st_mode)
File type (encoded in st_mode)Number of hard links (st_nlink)Filename
Modification time (st_mtime)
Note: All information (except for the ﬁle name) are available by calling one of
thestat() functions!
Stephan Schulz 472
User Groups
Groups are used in UNIX to give a group of users the ability to access a common
resource
–Most obvious use: Share ﬁles on the disk
–In practice more important: Allow access to a hardware device (Note: A
modem is a ﬁle, e.g. /dev/modem !)
Every user belongs to a primary group
–The primary group for a user is listed in the passwd ﬁle (as a numerical group
idorgid):
schulz:x:500: 500:Stephan Schulz:/home/schulz:/bin/tcsh
∗For normal UNIX systems, /etc/passwd
∗For systems running NIS, see the ﬁle with ypcat passwd
–After logging in, the users primary group is active (the gidof the shell has the
value for the primary group)
∗Processes started by another process (including the shell) inherit the gid
Stephan Schulz 473
Groups (Continued)
Additional group information is in /etc/group :
–For each group, a symbolic name (displayed by ls -l ) and a list of users
belonging to that group:
daemon:x:2:root,bin,daemon
schulz:x:500:
Secondary groups are additional groups which list the user as a member
–A user can explicitely change to such a group using the newgrp command
(man newgrp )
Stephan Schulz 474
UNIX User Utilities: chown and chgrp
chown is used to change the owner of a ﬁle
–Usage: chown <newuser> <file1> ...
–On most systems, only root is allowed to use chown (there are security issues
even with giving away ﬁles!)
chgrp changes the group of a ﬁle
–Usage: chgrp <newuser> <file1> ...
–On most systems, you can only change the group of a ﬁle to a group in which
you are a member (see above)
Important option for both: -R
–Recursively apply the operation to subdirectories and ﬁles in them
Stephan Schulz 475
File Mode Bits
The status word of a ﬁle (the stmode ﬁeld in struct stat also contains 9 bits
describing ﬁle access rights
–Note: These rights exist for all ﬁles, includding special ﬁles and directories!
There are three diﬀerent groups with potentiallty diﬀerent access rights:
–Theuser who owns the ﬁle
–Members of the group associated with the ﬁle
–Other users
There are also three diﬀerent types of access:
–Read access
–Write access
–Execute access
There are three more bits describing special properties
–The setuid bit: If true, the ﬁle will run under the eﬀective user id of the
program owner (not the one who started it)
–Thesetgid bit: Same thing for the group id
–Thesticky bit with complex semantics and interesting history
Stephan Schulz 476
Symbolic Encoding
ls -l prints a string of 9 letters to represent the 9 12 ﬁle mode bits
Normal case: The setuid, setgid and sticky bit are all cleared (0):
–The mode has the form uuugggooo to encode user, group, and other access
rights
–Each letter may be -to denote that that bit is clear
–Or it may have the mnemonic value of that right:
∗rfor read (ﬁrst letter)
∗wfor write (second letter)
∗xfor execute (third letter)
If one of the special bits is set, this is denoted by changing the last letter of each
group ( x) to another letter. Common cases (more: info ls ):
–sin the user executable position: The ﬁle is user executable and the setuid
bit is set
–sin the group executable position: The ﬁle is group executable, and the
setgid bit is set
Stephan Schulz 477
Numerical Encoding
The 12 permission bits are normally represented by 4 octal digits (each digit
represents 3 bits):
–0001 represents execute access for others
–0002 represents write access for others
–0004 represents read access for others
–0010 represents execute access for group
–0020 represents write access for group
–0040 represents read access for group
–0100 represents execute access for user
–0200 represents write access for user
–0400 represents read access for user
–1000 is the sticky bit
–2000 is the setgid bit
–4000 is the setuid bit
To generate a composite mode, just add up the individual modes
Leading zeroes (especially the ﬁrst one) are often omitted
Stephan Schulz 478
Examples
rw-r--r-- is the most common mode for a regular ﬁle on a conventional UNIX
system:
–The user is allowed to read and write the ﬁle
–Everyone else is allowed to read the ﬁle (no secrets ;-)
–Corresponding numerical value:
0004 Other read
0040 Group read
0400 User read
0200 User write
---------------
0644
Numeric mode 666(the number of the beast) gives full read and write access for
everyone ( rw-rw-rw- )
–Some people claim that this is not coincidence. . .
Stephan Schulz 479
UNIX User Utilities: chmod
chmod is used to change the ﬁle access bits
Usage 1: chmod <numeric-mode> files
–Sets the ﬁle mode of the named ﬁles to the octal mode absolutely
Usage 2: chmod <symbolic-mode-command> files
–The symbolic mode command can add or remove privileges for the diﬀerent
groups
–Format: <who><what><right>
∗<who> can be any sequence of letters from ugoora(equivalent to ugo)
∗<what> can be
·+to add rights
·-to remove rights
·=to absolutely assign rights
∗<right> can be any combination of letters from rwx
Important option: -R
–Recursively modify ﬁles and subdirectories
Stephan Schulz 480
chmod Examples
chmod ugo+rwx myfile # Grant full access rights to everybody
chmod 777 myfile # Grant full access rights to everybody
chmod -R go-rwx . # Paranoid: Remove read, write, and exute
# rights for all other people on the current
# directory and all files and subdirectory
chmod -R 644 . # Trying to fix things, but removed all
# execute rights from programs _and_
# directories (makes things hard to fix ;-)
Stephan Schulz 481
File Mode Creation Mask
Each process maintains a ﬁle mode creation mask
–This mask determines, which access rights are granted for newly created ﬁles
and directories
–The colloquial name is umask
–The umask is inherited by new processes started (i.e. your ﬁles will be created
with rights based on the umask of your shell)
The umask contains 9 bits, corresponding to the rwxrwxrwx access rights
–Bits set in the mask are always cleared
–All other rights are granted by default (with the xbits only set for executables
and directories)
The shell maintains a umask that can be set with the umask command (which
is normally in a user conﬁguration ﬁle)
–Example: umask 022
–Removes write permissions for everybody but the owner
Stephan Schulz 482
Exercises
Read the man and info pages on chmod ,chown andchgrp
The UNIX commands chmod andchown correspond to system calls of the same
name. To ﬁnd out how they work, read:
–man 2 chmod
–man 2 chown
Use this information to implement a rudimentary version of chmod
Stephan Schulz 483
CSC322
C Programming and UNIX
The UNIX File System
File Descriptors
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
File Decriptors
Files are identiﬁed for the kernel as ﬁle descriptors
–A ﬁle descriptor is a small, non-negative integer
–It’s used as an index into the ﬁle descriptor table of a process to obtain more
information
For many purposes, ﬁle descriptors are quite similar to ﬁle pointers (FILE*) from
the C standard I/O library
Hower, ﬁle descriptor I/O is much more lowlevel
–No formatted I/O
–No buﬀering – each I/O operation directly causes a system call to actually
perform the data transfer
Notes:
–UNIX’s standard I/O library is implemented using ﬁle descriptors
–Network communication also works via ﬁle descriptors
Stephan Schulz 485
Opening Files: open()
The open() system call opens a named ﬁle and returns a ﬁle descriptor (or -1
on failure)
It is deﬁned as follows:
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int oflag, mode_t mode);
Arguments:
–pathname is a standard UNIX ﬁle name as for fopen()
–oflag contains the options. The value is created by bitwise ORing of one of
the following values with a number of option ﬂags:
∗ORDONLY : Open the ﬁle for reading
∗OWRONLY : Open the ﬁle for writing
∗ORDWR : Open for reading and writing
–The third argument is only interpreted if open() is used for ﬁle creation (and
can be omitted otherwise)
Stephan Schulz 486
Option ﬂags for open()
Note: All of the following ﬂags have to be ORed (using the bitwise or operator |
with the main access mode ( ORDONLY, O WRONLY,O RDWR )
Options:
–OAPPEND : All output on this ﬁle descriptor is appended at the end of the ﬁle
–OCREAT : If the ﬁle does not exist, create it
–OEXCL : Only used with OCREAT – give an error, if the named ﬁle already
exists
–OTRUNC : If the ﬁle exists and is opened for writing or r/w, truncate it to
lenght 0
–OSYNC : Only return from writes to that ﬁle when the physical output is
complete
There are some more ﬂags that we only discuss when necessary
Example: fd = open("/tmp/testfile", O WDONLY|O APPEND|O SYNC)
Stephan Schulz 487
Using open() to create ﬁles
If the option OCREAT is given, open() will create a ﬁle if no ﬁle with the given
name exists
This also requires the third argument to open() (which otherwise is ignored or
can be omitted)
–This argument describes the access rights set for the new ﬁle
–It is created by binary ORing of the following constants:
SIRUSR Read Permission for the user
SIWUSR Write permission for the user
SIXUSR Execute permission for the user
SIRGRP Read Permission for the group
SIWGRP Write permission for the group
SIXGRP Execute permission for the group
SIROTH Read Permission for the others
SIWOTH Write permission for the others
SIXOTH Execute permission for the others
–Note: These are the same values used by stmode instruct stat
Stephan Schulz 488
Notes on open() and close()
The mode given to open() is modiﬁed by the umask of the process
The ﬁle mode is only set if the ﬁle is actually created (not even if it exists but is
truncated with OTRUNC )
A ﬁle is closed using the close() function:
#include <unistd.h>
int close(int fd);
–Return value: 0 on success, -1 on failure
There are three predeﬁned ﬁle descriptors that are open by default, corresponding
to the 3 standard I/O channels:
–STDIN FILENO (traditionally 0)
–STDOUT FILENO (traditionally 1)
–STDERR FILENO (traditionally 2)
Stephan Schulz 489
File Descriptor I/O: read() and write()
The functions read() andwrite() perform unbuﬀered input and output:
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
–ssize tis an integer type deﬁned in <unistd.h>
–fdis the ﬁle descriptor for input or output
–bufis a pointer to an area of memory
∗write() reads the data to write from this buﬀer
∗read() stores the read data in the buﬀer
–count is the number of bytes to transfer (and should not be bigger than the
size of *buf !)
Both functions return the number of bytes transmitted
–Forwrite() , a smaller number than requested signals an error
–Forread() :
∗0indicates end of ﬁle
∗-1signals error
∗Everything else is normal (there may be fewer characters than requested
currently available)
Stephan Schulz 490
Example: Simple cat
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
Stephan Schulz 491
Example Continued
#define BUF_SIZE 1024
int main(int argc, char* argv[])
{
int fd;
char buf[BUF_SIZE];
ssize_t count, check;
if(argc!=2)
{
fprintf(stderr, "USAGE: mycat2 file");
exit(EXIT_FAILURE);
}
fd = open(argv[1], O_RDONLY);
if(fd == -1)
{
err_sys("open");
}
Stephan Schulz 492
Example Continued
while((count = read(fd,&buf,BUF_SIZE)))
{
if(count==-1)
{
err_sys("read");
}
check = write(STDOUT_FILENO, &buf, count);
if(check!=count)
{
err_sys("write");
}
}
if(close(fd) == -1)
{
err_sys("close");
}
return EXIT_SUCCESS;
}
Stephan Schulz 493
The Standard I/O Library and File Descriptors
Remember that a ﬁle pointer is actually of type FILE*
It typically points to a structure in an array
–stdin points to element number 0
–stdout points to element number 1
–stderr points to element number 2
–More elements are ﬁlled in for each use of fopen()
Each of the structures contains:
–A buﬀer
–Some counters and positions to manage the buﬀer
–Afile descriptor
–Flags for the access mode (read or write)
Consider the case of writing:
–All write commands just write into the buﬀer space
–If the buﬀer is full or a fflush() command is issued (or the stream is closed),
all of the buﬀer is written using a single write() command
Reading similarly reads a large block and hands it out piecewise
Stephan Schulz 494
Cheating with fdopen()
Formatted, buﬀered output is very convenient and quite eﬃcient for many small
I/O operations ( getchar() ,fprintf() , . . . )
–Normally much better than read() andwrite()
–But some I/O methods only give us ﬁle descriptors (dammit!)
Solution: The function fdopen() will generate an entry in the FILE array from
a ﬁle descriptor and return the pointer to it
#include <stdio.h>
FILE *fdopen(int fildes, const char *mode);
filedes has to be an open ﬁle descriptor
mode is a string as for fopen() ("r", "w" . . . ) and must be compatible with
the ﬂags of the ﬁle descriptior
Stephan Schulz 495
Exercises
Write simple version of cpusing open() ,read() andwrite() . Use a default
buﬀer size, but support an option -bthat allows you to set the buﬀer size from
the command line. Measure the speed of copying a large ﬁle for diﬀerent sizes
Examples:
–mycp file1 file2 copies file1 tofile2 , using the default buﬀer size
–mycp -b3 file2 file2 copies the ﬁle using a buﬀer of 3 bytes
Use the fstat() command on both ﬁles to get the native block size of the ﬁle
systems for both ﬁles (the stblksize ﬁeld in struct stat ). What do you
notice? Can you write a better cpnow?
Stephan Schulz 496
CSC322
C Programming and UNIX
More on File Descriptors
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
More on the UNIX I/O System
The ﬁle descriptor typically is an index into a table that contains information
about all open ﬁles of the process
–That table contains just the ﬂags (read/write) for that ﬁle descriptor and a
pointer to the kernels global ﬁle table
The ﬁle table isglobal and shared by all processes. It has one entry per opened
ﬁle , containing:
–File status ﬂags (read, write, append,sync. . . , the things we passed to open()
–Current oﬀset into the ﬁle: The position where the next read or write will start
–A pointer to the vnode of the ﬁle
∗The vnode contains the ﬁle type and information about how to actually
access the ﬁle, as well as the current real ﬁle size
∗It also gives us a way to access the inode that contains all the information
we get with stat()
∗There is only one vnode per ﬁle, i.e. the vnode is the same for all ﬁle
descriptors and all processes that access the same ﬁle
Stephan Schulz 498
The UNIX File I/O System
FILE* myfileFILE array entry
Buffer
File descriptor
fd n: flags :Process table File table entry
Status flags
Offset
Standard IO Library
Per−Process Data Structures Global, Shared Data Structuresvnode table entry
current
filesize
...Actual
Stephan Schulz 499
Blocking vs. Nonblocking I/O
All I/O we have seen so far is blocking
–read() waits ( blocks ) until some input becomes available
–It then returns the read data
–Similarly, if write() temporarily cannot write the data, it blocks until it can
Non-blocking I/O always returns immediately from the I/O function
–If the I/O failed temporarily, the functions return -1
–errno is set to EWOULDBLOCK
Question: How do we achieve non-blocking I/O?
Answer: By manipulating the ﬁle descriptor
–Each ﬁle descriptor has a number of associated ﬂags
–One of these selects blocking vs. non-blocking behaviour
Stephan Schulz 500
Manipulating File Descriptors: fcntl()
fcntl() is a catch-all function for manipulating ﬁle descriptors
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);
We are only interested in the use of fcntl() for getting and changing the ﬁle
status ﬂags:
–ORDONLY ,OWRONLY ,ORDWR
–OAPPEND
–ONONBLOCK
–OSYNC
–. . . (depending on UNIX version)
fcntl() may return various values, depending on cmd
–On error, it always returns -1and sets errno
Stephan Schulz 501
fcntl() Continued
Using fcntl() to get the ﬁle status ﬂags:
flags = fcntl(fd, F_GETFL);
–To interprete the result, we need to logically AND it with the ﬂag we are
interested in (see example)
–To get the read/write status, AND the result with OACCMODE
To set the ﬁle status ﬂags:
fcntl(fd, F_SETFL, newflags);
–If we only want to change a single ﬂag, we have to get the old value and use
binary operations to change just that ﬂag!
–Example:
int flags = fcntl(STDIN_FILENO, F_GETFL);
flags = flags | O_NONBLOCK;
fcntl(STDIN_FILENO, F_SETFL, flags);
Stephan Schulz 502
Example: Printing Flags for a File Descriptor
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
Stephan Schulz 503
Example (2)
void print_fd_file_status(int fd)
{
int flags = fcntl(fd, F_GETFL);
if(flags == -1)
{
err_sys("fcntl");
}
printf("Flags for file descriptor %d\n", fd);
switch(flags & O_ACCMODE)
{
case O_RDONLY:
printf("Read only\n");
break;
case O_WRONLY:
printf("Write only\n");
break;
case O_RDWR:
printf("Read/Write\n");
break;
default:
printf("Strange\n");
}
Stephan Schulz 504
Example (3)
if(flags & O_APPEND)
{
printf("Append is set\n");
}
if(flags & O_NONBLOCK)
{
printf("Non-blocking\n");
}
if(flags & O_SYNC)
{
printf("Synchronous writes\n");
}
}
int main(int argc, char* argv[])
{
print_fd_file_status(STDIN_FILENO);
print_fd_file_status(STDOUT_FILENO);
print_fd_file_status(STDERR_FILENO);
print_fd_file_status(42);
return EXIT_SUCCESS;
}
Stephan Schulz 505
Example Output
$./fcntl_example
Flags for file descriptor 0
Read/Write
Flags for file descriptor 1
Read/Write
Flags for file descriptor 2
Read/Write
fcntl: Bad file descriptor
$./fcntl_example < signal_test.c
Flags for file descriptor 0
Read only
Flags for file descriptor 1
Read/Write
Flags for file descriptor 2
Read/Write
fcntl: Bad file descriptor
Stephan Schulz 506
Multiplexing I/O
Often, a program has to be able to read data from multiple sources
–Data from the user
–Data from the network
–Data from a ﬁle that is in the process of being written
Bad solution: Polling
–Switch all ﬁle descriptors to non-blocking
–Test them one after the other, until one of them has data
–Uses to much system resources!
Minimally better: Polling with a short waiting time between I/O attempts
–But: Lousy reaction time
Right solution: Use the right tool ( select() )
Stephan Schulz 507
Multiplexing I/O: select()
select() is used to watch a set of ﬁle descriptors for one of three conditions:
–A ﬁle descriptor is ready for reading
–A ﬁle descriptor is ready for writing
–Is there an exceptional condition for a ﬁle descriptor?
We can tell the function to either
–Return immediately, telling us the current status
–Wait until at least one of the conditions becomes true
–Wait until at least one of the conditions becomes true, but at most a ﬁxed
amount of time
Speciﬁcation:
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
int select(int max_fdp1, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
struct timeval *tvptr);
Stephan Schulz 508
select() Arguments
fdsetis deﬁned in sys/types.h
–It is a data type that can store a set of ﬁle descriptors
–We only know how to manipulate it:
∗FDZERO(fd set *set) removes all ﬁle descriptors from the set
∗FDSET(int fd, fd set *set) inserts fdinto the set
∗FDCLR(int fd, fd set *set) removes fdfrom the set
∗FDISSET(int fd, fd set *set) returns true, if fdis contained in *set
The three fdset* arguments are used for input andoutput of select()
–The fdsetstructures the arguments point to describe which ﬁle descriptors
we are interested in
–If the pointer is NULL , we are not interested in any ﬁle descriptor for the
corresponding property
–Ifselect() returns, the set have been modiﬁed to contain just the descriptors
for which the property is true
int max fdp1 has to be at least one bigger than the biggest ﬁle descriptor in
any one of the three sets
–It is used to speed up things in the UNIX kernel
Stephan Schulz 509
select() Arguments and Return Value
The last argument to select() is a pointer to a struct timeval
This struct has two ﬁelds:
–long tv_sec; /* Seconds */
–long tv_usec; /* Microseconds */
There are two possible cases:
–tvptr isNULL : In this case, select() waits until one of the ﬁle descriptors is
ready (or a signal is caught)
–tvptr points to a valid struct timeval : In this case, select() waits at
most the speciﬁed time
Return value:
–-1on error or if select() returned because of a signal ( errno will be set!)
–Otherwise, the number of ﬁle descriptors for which the speciﬁed condition is
true is returned
Stephan Schulz 510
Example
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char* argv[])
{
fd_set readfds;
fd_set writefds;
int res;
FD_ZERO(&readfds);
FD_ZERO(&writefds);
FD_SET(STDIN_FILENO, &readfds);
FD_SET(STDOUT_FILENO, &writefds);
FD_SET(STDERR_FILENO, &writefds);
res = select(3, &readfds, &writefds, NULL, NULL);
printf("%d file descriptors are ready\n", res);
Stephan Schulz 511
Example (2)
if(FD_ISSET(STDIN_FILENO, &readfds))
{
printf("STDIN is ready for reading\n");
}
if(FD_ISSET(STDOUT_FILENO, &writefds))
{
printf("STDOUT is ready for writing\n");
}
if(FD_ISSET(STDERR_FILENO, &writefds))
{
printf("STDERR is ready for writing\n");
}
return EXIT_SUCCESS;
}
Stephan Schulz 512
Example Output
$ ./select_example
2 file descriptors are ready
STDOUT is ready for writing
STDERR is ready for writing
$ ./select_example < select_example.c
3 file descriptors are ready
STDIN is ready for reading
STDOUT is ready for writing
STDERR is ready for writing
Stephan Schulz 513
Internet Assignment (I)
On the assignment home page you will ﬁnd links to two binary programs, a chat
server and a chat client. In the end, you should turn in a program that has the
same functionality as the client
Step 1:
–Download the programs and understand what they do
–To start the server, type ./chat server <port> , where <port> is an integer
greater than 1024
–To connect to the sever, type ./chat client <ip-addr> <port> <nick>
∗<ip-addr> is the IP-Address of the server host (use 127.0.0.1 if the server
runs on the same host, use nslookup <name> for other hosts)
∗<port> is the same number as used for the server
∗<nick> is the nickname under which you will chat
Caveats:
–Due to ﬁrewalling, do not expect to be able to reach a server from outside the
lab
–The binaries only run under Linux
I will try to keep a server running on leeon port 6666 for all of you to share
Stephan Schulz 514
CSC322
C Programming and UNIX
Basic UNIX Network Programming
Introduction
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Networking
Stephan Schulz 516
Networking
Stephan Schulz 517
Networking
Stephan Schulz 518
Networking
Stephan Schulz 519
Networking
Stephan Schulz 520
Networking
Stephan Schulz 521
Networking
The Internet
Stephan Schulz 522
Networking Concepts
Is communication occuring between two partners, or is it a broadcast communi-
cation?
–How are partners identiﬁed ( addressed )?
Is traﬃc stream oriented orpacket oriented ?
–Stream-oriented: Messages arrive as stream of bytes (similar to reading from
a ﬁle)
–Packet oriented: Traﬃc arrives in the form of distinct pakets of a ﬁxed (or
ﬁxed maximal) size
Is the communication reliable or unreliable?
–Can messages disappear?
–Can the order of messages change?
–Can messages be duplicated?
Stephan Schulz 523
Network Layers
Level 0: Physical or Hardware layer
–Copper wires or optical ﬁber
–Radio waves or laser beams for wireless protocols
Level 1: Data Link Layer
–How is data transported?
–Examples: Ethernet, Token ring, ATM, ISDN
Level 2: Network layer
–How are individual hosts or networks assembles into a network?
–Examples: Internet protocol (IP)
Level 3: Transport layer
–Converts from standard user pakets to network layer pakets
–May include error checking and correcting
–Examples: TCP and UDP
Higher layers. . .
–Take care of data representation at various levels
Stephan Schulz 524
The Internet Protocol (IP)
Level 2 protocol (Hardware-Agnostic)
Prevalent protocol today: IPv4
–Unreliable (“best eﬀort”)
–Packet-oriented ( IP-Datagrams )
–Can be addressed to individual hosts or broadcast adresses
–Addresses are 32 bit numbers (“4 binary octets”), normally written as dotted
decimal numbers: 127.0.0.1
–Addresses denote individual hosts!
Currently being deployed: IPv6
–Shares many properties
–But: 128 bit addresses (8 4-digit hex numbers, written in Hex and separated
by colons: 21DA:00D3:0000:2A3B:02AA:00BF:FE28:9C5A )
Stephan Schulz 525
The User Datagram Protocol (UDP)
Based on IP
Still. . .
–paket-oriented
–unreliable
Adds: Service multiplexing
–The same host can have many diﬀerent communications
–Each communication uses a diﬀerent port
Supported by UNIX with sockets with socket type SOCK DGRAM
Used for:
–DNS (Domain name service)
–NFS (Network ﬁle system)
Stephan Schulz 526
The Transmission Control Protocol (TCP)
Based on IP, but. . .
–Connection-based
–Stream-oriented
–Reliable
–Service multiplexing (with ports)
Supported by UNIX with sockets with socket type SOCK STREAM
Addresses for TCP (and UDP) have two parts:
–TheIP number for specifying the host
–Theport number for specifying the port
Most services are associated with a ﬁxed port number:
–HTTP (WWW): Port 80
–SMTP (Email transport): Port 25
–FTP (File Transfer): Port 21
–For a semi-complete list: more /etc/services
–Server port numbers up to 1024 are normally reserved for root
Stephan Schulz 527
UNIX Sockets
Sockets are special ﬁle descriptors used for many diﬀerent kind of inter-process
communication
–Local
–Networked
We can create sockets for diﬀerent communication styles
–Stream oriented
–Datagram
Sockets are used on both sides of a communictation
–The receiver creates a socket and associates it with a port
–The sender creates a socket and connects it to the receiver
Stephan Schulz 528
Client/Server Model
Aserver oﬀers a certain service
–It is ready to accept connections on a certain port
Aclient initiates communication by trying to connect to that port
Stephan Schulz 529
CSC322
C Programming and UNIX
Basic UNIX Network Programming
Simple Connections
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
The Client Side for TCP Connections
The client has to perform the following steps:
–Create a socket for stream-oriented communication over IP
–Create an address structure for the server address
–Connect the socket to the server port
–Use the connection
Stephan Schulz 531
Creating Sockets with socket() (1)
To create a socket, we call socket()
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
On success, socket() returns a valid ﬁle descriptor just like open()
–After enough black magic, we can use it with read() andwrite()
On failure, the function returns -1and sets errno
Stephan Schulz 532
Creating Sockets with socket() (2)
int socket(int domain, int type, int protocol);
Thedomain argument describes the protocol family that will be used. Interesting
values:
–PFINET : Internet with IPv4
–PFINET6 : Internet with IPv6
–PFLOCAL : Local communication
The type describes the communication style:
–SOCK STREAM for connection based streams
–SOCK DGRAM for datagrams
The last argument speciﬁes the protocol
–There normally is only a single protocol for each domain/type pair, use 0to
select this (the default)
–PFINET/SOCK STREAM gives us TCP/IPv4
–PFINET/SOCK DGRAM gives us UDP/IPv4
Stephan Schulz 533
Socket Adresses
This is a reasonably ugly topic!
Because sockets are used for so many things, there is no single data type for
socket addresses
–Instead, each address family has its own format
–We have to pass this by address (casted to a bogus type struct sock addr* )
–Additionally, we have to tell the system the size of our address format
Because diﬀerent computer models use diﬀerent data formats ( Big Endian vs.
Little Endian ), we have to convert values to network order using:
#include <netinet/in.h>
uint32_t htonl(uint32_t hostlong); /* Host to Network conversion for long */
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort); /* Network to host conversion for short */
Stephan Schulz 534
Socket Adresses for IPv4
For IPv4 addresses, we use the data type struct sock addr in
It contains the following ﬁelds we have to ﬁll:
u_char sin_family; /*----Internet address family */
u_short sin_port; /*----Port number */
struct in_addr sin_addr; /*----Holds the IP address */
Forsin family , we use a predeﬁned constant AFINET
For the port, we use the port number, converted with htons()
sin addr is ﬁlled in by the function inet pton() :
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
int inet_pton(int af, const char *src, void *dst);
Stephan Schulz 535
inet pton()
int inet_pton(int af, const char *src, void *dst);
inet pton() converts an internet address in string form to a network address
structure
First argument: Address family
–AFINET for IPv4 adresses
–AFINET6 for IPv6 adresses
Second argument: Pointer to string containing address
–For IPv4: IP-Numbers (4 numbers with dots)
–IPv6: Hex representation (8 4-digit hex numbers separated by colons)
Third argument: Pointer to the destination
–Normaly a pointer to the sin addr ﬁeld in a struct sock addr in
Stephan Schulz 536
Connecting to a Remote Port: connect()
After we have prepared an address in a struct sock adr in, we can connect
an existing socket to a remote port:
#include <sys/types.h>
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
–sockfd : Socket you want to connect
–serv addr: Pointer to the carefully prepared address you want to connect to,
casted to struct sockaddr*
–addrlen : Size of your actual structure, i.e. sizeof(struct sockadr in)
∗Remember that by casting the second argument, we actually lie to the about
the data structure we are pointing to
∗That’s ok – the socket library knows that we are probably lying
∗Passing the length helps the library to straighten things out
Return value: 0 on success, -1 on failure
Stephan Schulz 537
Example: Getting an Insult
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
int sock;
struct sockaddr_in server_addr;
char buf[80];
int msg_len,res;
Stephan Schulz 538
Example (2)
sock = socket(PF_INET, SOCK_STREAM, 0); /* Check against -1 omitted! */
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(1695);
res = inet_pton(AF_INET, "128.138.196.16", &server_addr.sin_addr);
if(res < 0)
{
err_sys("inet_pton (no valid address family)");
}
if(res == 0)
{
fprintf(stderr, "Not a valid IP address");
exit(EXIT_FAILURE);
}
res = connect(sock, (struct sockaddr *) &server_addr,
sizeof(server_addr));
if(res == -1)
{
err_sys("connect");
}
Stephan Schulz 539
Example (3)
while(1)
{
msg_len = read(sock, buf, 80);
if(msg_len == 0)
{
break;
}
write(STDOUT_FILENO, buf,msg_len);
}
close(sock);
return EXIT_SUCCESS;
}
Stephan Schulz 540
The Server Side
Aserver has a more complex task than a client
General steps:
–Create a socket (we now how to do this)
–Create an address (on its own machine)
–Bind the socket to the address
–Listen for incomming connections on that socket
For each client:
–Accept the connection (on a new socket)
–Use the connection
–Close the connection
Stephan Schulz 541
Server Side Addresses
We need to specify a local address for the listening port
–It contains the address family, IP address, and port
Instead of actually digging out the servers IP address (which may be complex),
we use the special address 0.0.0.0 orINADDR ANY
Given this address, the server will accept connections on any IP address which
refers to it
Example:
struct sockaddr_in sock_name;
int sock;
short port;
...Get socket, set port to some value...
memset(&sock_name, 0, sizeof(sock_name)); /* Clear address */
sock_name.sin_family = AF_INET; /* Set address family */
sock_name.sin_port = htons(port); /* Set port */
sock_name.sin_addr.s_addr = htonl(INADDR_ANY);/* Set address */
Stephan Schulz 542
Naming a Socket (Binding a Socket to an Address)
Once we have created a socket and a local address, we need to bind the socket
to an address
–All future operations will make use of that address
#include <sys/types.h>
#include <sys/socket.h>
int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);
–sock fd: Socket we want to bind
–myaddr : Pointer to the address
–addrlen : Lenght of that address
–See remarks for connect() !
Return value:
–0 on success
–-1 on failure
Stephan Schulz 543
Listening for Incoming Connections
We use the listen() function call to make a socket listen for incoming connec-
tions:
#include <sys/socket.h>
int listen(int sock, int backlog);
–sock is the ﬁle descriptor we want to set to listening state
–backlock is the number of pending connections allowed at any one time
∗If more unanswered connection request are received, they will be refused or
ignores
∗If we accept a connection, that slot becomes available again
∗A good value is 5 ;-)
Return value: 0 on success, -1 on failure
Stephan Schulz 544
Accepting Connections
To ﬁnally establish a connection, we have to accept it:
#include <sys/types.h>
#include <sys/socket.h>
int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);
–sock : The socket we expect connection on
–addr : A pointer to an address structure (or NULL)
–addrlen : A pointer to an integer variable of type socklen tthat initialy has
to contain the size of *addr
Ifaccept() returns. . .
–The return value is the ﬁle descriptor of a newsocket (or -1)
–Ifaddr is not NULL , the address of the remote socket is written into it
–*addrlen is changed to the actual size of the new variable
By default, accept() blocks until a connection request is received
–If we set the socket to non-blocking (using fcntl() ), it will return with -1
and set errno toEWOULDBLOCK if there are no pending requests
Stephan Schulz 545
Example: Greeting the World
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <ctype.h>
#include <unistd.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
int sock, con_sock;
struct sockaddr_in sock_name;
Stephan Schulz 546
Example (2)
if(argc!=2)
{
fprintf(stderr, "Usage: simple_server <port>\n");
exit(EXIT_FAILURE);
}
sock = socket(PF_INET, SOCK_STREAM, 0);
if(sock == -1)
{
err_sys("socket");
}
sock_name.sin_family = AF_INET;
sock_name.sin_port = htons(atoi(argv[1]));
sock_name.sin_addr.s_addr = htonl(INADDR_ANY);
if (bind(sock, (struct sockaddr *) &sock_name, sizeof(sock_name)) < 0)
{
err_sys("bind");
}
if(listen(sock, 1) == -1)
{
err_sys("listen");
}
Stephan Schulz 547
Example (3)
while(1)
{
con_sock = accept(sock, NULL, NULL);
if(con_sock == -1)
{
err_sys("accept");
}
write(con_sock, "Hiho and welcome!\n", strlen("Hiho and welcome!\n"));
if(close(con_sock) == -1)
{
err_sys("close(con_sock)");
}
}
/* sock closed automatically when we exit via ^C */
}
Stephan Schulz 548
More Information
manpages:
–man socket
–man 2 bind
–man accept
The GNU C library documentation on sockets
–Available by doing info libc
–In emacs: [C-h i]
–On the internet, e.g. at:
∗http://www.gnu.org/manual/glibc-2.2.3/html_chapter/libc_16.html
∗http://www.gnuenterprise.org/doc/glibc-doc/html/chapters_16.html
Stephan Schulz 549
Internet Assignment (II)
Step 2: Write a simple client that
–reads IP adress, port and nickname from the command line
–Connects to the speciﬁed server
–Uses select() or non-blocking read() to read everything the server transmits
–Closes the connection
Step 3: Modify the client to keep on reading. Be sure to use select() now!
Step 4: Write a second client that connects, reads input from the terminal, and
sends it to the server (prepended with the nickname and a colon).
–You should be able to see what you send if you simultaneously connect with
the client from step 3.
–If the user types [C-D] to signal end of input, close the connection to the
server and terminate
Step 5: Put everything together, using select() on the network connection and
standard input.
–Send input from the terminal to the server
–Set input from the network to standard output
Stephan Schulz 550
CSC322
C Programming and UNIX
Process Creation and Termination (I)
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Subprocesses
UNIX is a multi-process operating systems
–Many processes run at the same time
–Processes can be created and can terminated
Processes form a hierarchy
–All processes have a unique parent
–In the end, all (real) processes descent from the init process
Parent and child share a special relationship
–The parent has to retrieve the termination status of a process
–The child can get his parents process id
–If a parent dies, its special role is taken over by the init process
Stephan Schulz 552
Process Properties
For each process, we can get various identiﬁers:
–The process id
–The process id of the parent
–Therealuser id of the process (i.e. the user id of the owner)
–Theeﬀective user id of the process (i.e. the user id that is used to check acces
rights). It can diﬀer e.g. for programs with the setuid bit set
–The real group id
–The eﬀective group id
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void); /* Get process id */
pid_t getppid(void); /* Get parent process id */
uid_t getuid(void); /* Get real user id */
uid_t geteuid(void); /* Get effective user id */
gid_t getgid(void); /* Get real group id id */
gid_t getggid(void); /* Get effective group id */
Stephan Schulz 553
Standard Execution of a UNIX Program
Creation of the process
–Can only happen via the fork() process
Executution of a program
–Via the kernel system call exec()
–Comes in various handy library variants
Running
–Process runs in its own process space (virtual memory)
Termination
–Normal exit
–Call to abort()
–Catching a signal for which the default action is aborting
Stephan Schulz 554
Exiting
There are three normal ways of terminating a program
Calling return st; from main() (ANSI C)
–In that case the exit status of the program is st
–Interpretation of the exit status is implementation-deﬁned for ANSI C (but
deﬁned for UNIX)
Calling exit(st); from anywhere in the program (ANSI C)
–Exit status is st
–Inmain() ,exit() andreturn are equivalent
–In both cases, some cleanup actions are performed
∗Exit handlers are called
∗All open ﬁles are ﬂushed and closed
Calling exit(st) (UNIX) or Exit(st) (new in ANSI-C 99, may not be widely
supported)
–Program is immediately terminated
–Exit status is st
Stephan Schulz 555
Exit Formalities
#include <stdlib.h>
void exit(int status);
void _Exit(int status); /* New in C99 */
#include <unistd.h>
void _exit(int status);
ANSI C deﬁnes three diﬀerent exit statuses:
–EXIT SUCCESS (instdlib.h )
–EXIT FAILURE (instdlib.h )
–0(equivalent to EXIT SUCCESS
In practice, EXIT SUCCESS is nearly always just #define d as 0
Stephan Schulz 556
Cleaning up: atexit()
ANSI C allows us to register up to 32 functions that will be called whenever the
program terminates normally:
#include <stdlib.h>
int atexit(void (*func)(void));
–Argument is a pointer to a function that neither takes an argument nor returns
a value
–Return value for atexit() is0on success, -1on error
Each call to atexit() results in a single call to the registered function
–Registered functions are called in reverse order of registration
–We can register the same function more than once
Note: Exit handlers should only access global variables
Stephan Schulz 557
Example
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
int handler_counter=0;
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
void handler1(void)
{
printf("Handler1, counter = %d\n", handler_counter);
handler_counter++;
}
void handler2(void)
{
printf("Handler2, counter = %d\n", handler_counter);
handler_counter++;
}
Stephan Schulz 558
Example (2)
int main(void)
{
if(atexit(handler1) != 0)
{
err_sys("atexit");
}
if(atexit(handler2) != 0)
{
err_sys("atexit");
}
if(atexit(handler1) != 0)
{
err_sys("atexit");
}
if(atexit(handler1) != 0)
{
err_sys("atexit");
}
printf("My PID is %d and my parents PID is %d\n", getpid(), getppid());
return EXIT_SUCCESS;
}
Stephan Schulz 559
Example Output
My PID is 2019 and my parents PID is 746
Handler1, counter = 0
Handler1, counter = 1
Handler2, counter = 2
Handler1, counter = 3
Stephan Schulz 560
Running other Programs: system()
The system() function is deﬁned by ANSI C
#include <stdlib.h>
int system(const char *command);
system() hands the string pointed to by command to the systems command
processor for execution
–system() returns, when the command returns
–Return value of system() in this case is implementation-deﬁned
Ifcommand isNULL ,system() checks if the implementation hasa command
processor
–It returns 0, if not
–Anything else, otherwise
Stephan Schulz 561
system() in UNIX
On UNIX, there always is a command processor
–The command is handed to the standard shell, /bin/sh
–It can make use of all shell facilities, including I/O redirection
The return value of the system() command normally is an encoding of the exit
status of the executed command
–If for some reason no new process for the shell can be created, -1is returned
(and errno is set to specify what went wrong)
–If the shell cannot be executed, it is treated as if the shell returned 127
–Otherwise, the return value is an encoding of the exit status of the shell (which
always returns the exit status of the command, if it could be executed)
Stephan Schulz 562
Termination Status Interpretation
Termination status can come from multiple sources
–system() (which nicely packs up all the work for us)
–Functions that retrieve the exit status of a child process: wait() and
waitpid() (more later)
Interpretation depends on the cause of the termination of the child process.
Assume that status is the termination status
–IfWIFEXITED(status) is true, the process terminated normally (i.e. via
exit() ,exit() orreturn from main)
∗WEXITSTATUS(status) returns the (lower 8 bit of) the value that was
passed to exit()
–IfWIFSIGNALED(status) is true, the process was terminated because of an
uncaught signal with default action abort
∗WTERMSIG(status) gives the number of the signal
IfWIFSTOPPED(staus) is true, the process is currently stopped (via SIGSTOP or
SIGSTP )
–WSTOPSIG(status) returns the number of the stop signal
Stephan Schulz 563
Example: Executing Commands
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
int handler_counter=0;
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
Stephan Schulz 564
Example: Executing Commands
int main(int argc, char* argv[])
{
int i, status;
for(i=1; i<argc; i++)
{
status = system(argv[i]);
if(status == -1)
{
err_sys("system");
}
if(WIFEXITED(status))
{
printf("Exited normally, returning %d\n", WEXITSTATUS(status));
}
else
{
printf("Handle this in your assignment\n");
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 565
Example Output
$ ./system example ”date” ”man does notexist” ”whoami -q”
Tue Nov 26 04:59:29 CET 2002
Exited normally, returning 0
No manual entry for does_not_exist
Exited normally, returning 16
whoami: invalid option -- q
Try ‘whoami --help’ for more information.
Exited normally, returning 1
Stephan Schulz 566
Exercises
Write a program that prints it parents PID and modify the last example to print
its PID. Run the program via the example code. What do you notice? Why?
Extend the example to a shell that reads commands from the user and executes
them
–Handle all cases of why a process can terminate, and print a useful message
for all cases
Stephan Schulz 567
CSC322
C Programming and UNIX
Process Creation and Termination (II)
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Creating new Processes: fork()
Theonly way of creating a new process under UNIX is via the fork() function
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
fork() creates a new child process that is in nearly all ways an exact copy of the
parent
Execution continues in both parent andchild
Only (major) diﬀerences:
–New PID and new parent PID
–Return value of fork
Return value of fork()
–On failure: -1,errno will be set
–On success:
∗In the child, 0will be returned
∗In the parent, the PID of the child (a value >0) will be returned
Stephan Schulz 569
Example
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
pid_t pid, ppid, child_pid;
int some_var = 42;
pid = getpid();
printf("Parent. My PID is %d and I am about to procreate\n", pid);
child_pid = fork();
if(child_pid<0)
{
err_sys("fork");
}
Stephan Schulz 570
Example
if(child_pid == 0)
{
pid = getpid();
ppid = getppid();
printf("Child. My PID is %d, my parent is %d\n", pid, ppid);
printf("Child: some_var=%d - Changing it now!\n", some_var);
some_var=7;
printf("Child: some_var=%d\n", some_var);
}
else
{
printf("Parent. My PID is %d, my child is %d\n", pid, child_pid);
printf("Parent: some_var=%d\n", some_var);
printf("Going to sleep now, waiting for my child to die...\n");
sleep(5);
printf("I’m awake again. some_var is still %d\n", some_var);
}
return EXIT_SUCCESS;
}
Stephan Schulz 571
Example Output
Parent. My PID is 12625 and I am about to procreate
Parent. My PID is 12625, my child is 12626
Parent: some_var=42
Going to sleep now, waiting for my child to die...
Child. My PID is 12626, my parent is 12625
Child: some_var=42 - Changing it now!
Child: some_var=7
I’m awake again. some_var is still 42
Notice that I took a snapshot of the processes with top:
PID USER PRI ... SHARE STAT %CPU %MEM TIME COMMAND
12625 schulz 16 ... 280 S 0.0 0.1 0:00 fork_example
12626 schulz 16 ... 0 Z 0.0 0.0 0:00 fork_example <defunct>
-As long as the parent lives, the child remains around as a zombie
-As the parent dies, the init process gets the termination status and is delivered
from its undead state
Stephan Schulz 572
Comments on fork()
Order of execution for parent and child is unpredictable!
Forked processes behave as if an actual copy has been made
–All of the processes memory is accessible in both parent and child
–Changing them in one does not aﬀect the other
On modern UNIX versions, fork() is implemented with copy on write
–Both processes actually share the same pages in memory
–Only when a process actually tries to change a value in memory is a private
copy created
–Consequence: Forking is very cheap – it only has to copy basic process
structures
UNIX programmers use forking a lot!
–Servers may fork one process for each connection!
–Shells fork for executing commands
Stephan Schulz 573
Don’t Do This!
#include <unistd.h>
int main(int argc, char* argv[])
{
while(1)
{
fork();
}
}
Stephan Schulz 574
Don’t Do This!
#include <unistd.h>
int main(int argc, char* argv[])
{
while(1)
{
fork();
}
}
It is the simplest version of a fork bomb
–Will create an exponentially growing number of processes
–Quickly consumes all system resources
–Makes system essentially unusable
Stephan Schulz 575
Forking and I/O
As the example showed, both parent and child were able to write to stdout
–In general, parent and child share ﬁle descriptors open at the time of fork()
–This can be problematic, as the order in which output is written is undeﬁned
–Even worse for input or output to ﬁles or sockets (on the screen, we can usually
ﬁgure things out)
If responsibility for ﬁle descriptors is clear, parent can delegate communication to
child
–Eample: Parent just accepts() connections
–Child actually performs communication on the ﬁle descriptor
–Both parent and child need to close an open ﬁle descriptor!
Parent and child share ﬁle descriptor, but not standard I/O library buﬀers
–Can have unexpected eﬀects!
Stephan Schulz 576
I/O Setup before Forking
FILE* myfileFILE array entry
Buffer
File descriptor
fd n: flags :Process table File table entry
Status flags
Offset
Standard IO Library
Per−Process Data Structures Global, Shared Data Structuresvnode table entry
current
filesize
...Actual
Stephan Schulz 577
I/O Setup after Forking
FILE* myfileFILE array entry
Buffer
File descriptor
fd n: flags :Process table
Standard IO Library
Per−Process Data Structures
FILE* myfileFILE array entry
Buffer
File descriptor
fd n: flags :Process table
Standard IO Library
Per−Process Data StructuresFile table entry
Status flags
Offset
Global, Shared Data Structuresvnode table entry
current
filesize
...Actual
Stephan Schulz 578
Example: Buﬀerd I/O and Forking
/* Usual includes and stuff omitted */
int main(int argc, char* argv[])
{
pid_t child_pid;
printf("Hiho "); /* <--- Note: No Newline! */
child_pid = fork();
if(child_pid<0)
{
err_sys("fork");
}
if(child_pid == 0)
{
printf("from the child!\n");
}
else
{
printf("from the parent!\n");
sleep(1);
}
return EXIT_SUCCESS;
}
Stephan Schulz 579
Example Output
$fork example2
Hiho from the parent!
Hiho from the child!
stdout is line buﬀered
–Since we did not print a full line (and did not call flush() , the string was not
printed
–Calling fork() duplicated the buﬀer contents
–Then, both parent and child caused a ﬂush
Stephan Schulz 580
Waiting for Children to Die
As stated above, parents need to get the termination status of their children
(otherwise those children become zombies)
They can do so by calling wait()
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
–wait() waits until a child terminates
–It returns the PID of the terminated child
–Ifstatus is not equal to NULL , it writes the termination status of the child
into the variable it points to
–Note: If some children have already terminated, wait() picks one of those
and returns its data
–If there are no children, wait() returns -1and sets errno
Stephan Schulz 581
Example
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
pid_t pid, ppid, child_pid;
int i, status;
pid = getpid();
printf("Parent. My PID is %d and I am about to procreate\n", pid);
fflush(stdout);
Stephan Schulz 582
Example (2)
for(i=0; i<3; i++)
{
child_pid = fork();
if(child_pid<0)
{
err_sys("fork");
}
if(child_pid == 0)
{
break; /* Only the parent forks! */
}
}
if(child_pid == 0)
{
pid = getpid();
ppid = getppid();
printf("Child. My PID is %d, my parent is %d\n", pid, ppid);
sleep(1);
exit(i);
}
Stephan Schulz 583
Example (3)
printf("Parent: Waiting for my children\n");
while((child_pid = wait(&status))!=-1)
{
printf("Child %d terminated with termination status %d\n", child_pid, status);
if(WIFEXITED(status))
{
printf("Termination normal, exit status %d\n", WEXITSTATUS(status));
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 584
Example Output
Output:
Parent. My PID is 13565 and I am about to procreate
Child. My PID is 13567, my parent is 13565
Child. My PID is 13568, my parent is 13565
Child. My PID is 13569, my parent is 13565
Parent: Waiting for my children
Child 13569 terminated with termination status 512
Termination normal, exit status 2
Child 13568 terminated with termination status 256
Termination normal, exit status 1
Child 13567 terminated with termination status 0
Termination normal, exit status 0
Stephan Schulz 585
Exercises
Here is a function that computes the rollercoaster numbers
long rollercoaster(long i)
{
printf("%ld\n", i);
if(i==1)
{
return 0;
}
if(i%2==0)
{
return 1+rollercoaster(i/2);
}
return 1+rollercoaster(3*i+1);
}
Write a program that forks of 10 processes, each of which computes the
rollercoaster numbers for one of the numbers from 11 to 20 and prints it
Make the parent wait for all children and print the PID’s and the exit status of
each in the order in which the children terminate, then terminate the parent
Stephan Schulz 586
CSC322
C Programming and UNIX
Process Control (System Calls)
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Process Groups
UNIX processes are organized in process groups
–A process group has a group leader
–All processes in the group have the same process group id (which is the process
idof the group leader)
Some operations can be done not just for single processes, but for a whole group:
–Delivering signals with kill
–Waiting for process termination with waitpid() (later)
By default, a process inherits the process group id from its parent
–Processes can change their own process group id
∗. . . to become process group leaders in a new process group, or
∗. . . to join an existing process group
–Parents can change the process group id of their children (unless the children
already called exec() )
Note: Don’t confuse the pgid (process group) with the gid(user/owner group)
Stephan Schulz 588
Getting and Changing Process Groups
#include <sys/types.h>
#include <unistd.h>
pid_t getpgrp(void);
int setpgid(pid_t pid, pid_t pgrp);
getpgrp() always returns the process group id of the current process
–No error condition!
setpgid(pid t pid, pid t pgrp) sets the process group id of the process
with the PID pidtopgrp
–Return value: 0 on success, -1 on error ( errno set)
–Special values:
∗Ifpidis 0, the PID of the calling process is assumed
∗Ifpgrp is 0, the process id denoted by the ﬁrst argument is assumed (i.e.
that process is made into a process group leader of a new process group)
–Note that this means that setpgid(0,0) makes the current process into a
process group leader
Stephan Schulz 589
Example
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
pid_t pid, pgid, child_pid;
int i, res;
pid = getpid();
pgid = getpgrp();
printf("Parent. My PID is %d and my process group is %d\n",pid,pgid);
Stephan Schulz 590
Example (2)
res = setpgid(0,0);
if(res==-1)
{
err_sys("setpgid");
}
printf("Parent. I’m now the process group leader.\n");
for(i=0; i<3; i++)
{
child_pid = fork();
if(child_pid<0)
{
err_sys("fork");
}
if(child_pid == 0)
{
break; /* Only the parent forks! */
}
}
Stephan Schulz 591
Example (3)
if(child_pid == 0)
{
pid = getpid();
pgid = getpgrp();
printf("Child %d. My PID is %d, my process group is %d.\n", i, pid, pgid);
sleep(1);
res = setpgid(0,0);
if(res==-1)
{
err_sys("setpgid");
}
pid = getpid();
pgid = getpgrp();
printf("Child %d. I’m now independent, pid %d and pgid %d\n",i, pid,pgid);
printf("Child %d exiting\n", i);
exit(EXIT_SUCCESS);
}
printf("Parent, sleeping.\n");
sleep(3);
printf("Parent, exiting.\n");
return EXIT_SUCCESS;
}
Stephan Schulz 592
Example Output
$./pg example
Parent. My PID is 1946 and my process group is 1946
Parent. I’m now the process group leader.
Parent, sleeping.
Child 0. My PID is 1947, my process group is 1946.
Child 1. My PID is 1948, my process group is 1946.
Child 2. My PID is 1949, my process group is 1946.
Child 0. I’m now independent, pid 1947 and pgid 1947
Child 0 exiting
Child 1. I’m now independent, pid 1948 and pgid 1948
Child 1 exiting
Child 2. I’m now independent, pid 1949 and pgid 1949
Child 2 exiting
Parent, exiting.
Note that the parent starts out as a process group leader!
–Most shells with build-in job control will always execute commands in their
own process group
Stephan Schulz 593
UNIX System Call: kill
#include <signal.h>
int kill(pid_t pid, int sig);
kill() sends the signal sigto the process or processes speciﬁed by pid
–pid > 0 : Signal is send to process with PID pid
–pid == 0 : Signal is sent to all processes in the same process group (if process
has permission to send it)
–pid < 0 : Signal is sent to all processes with process group id |pid|
–Special case: pid == -1 : Most UNIX versions send signal to allprocesses
with the same user id (real or eﬀective) as the caller
Possible signals: As for the kill command (deﬁned in <signal.h>
–Also see man signal
Note: kill() is the function used to implement the kill command
Stephan Schulz 594
Is this good for Something?
There are amany possible situations where an application consists of a setof
processes:
–Server may have one process that accepts() connections, multiple workers
that serve individual connections
–Competitive theorem prover runs many search strategies in parallel
If we make the top level control program into a process group leader, termination
becomes a lot easier
–We can kill whole process group with one command
–The leader can be made to automatically kill all processes
Stephan Schulz 595
Example
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
int main(int argc, char* argv[])
{
pid_t pid, pgid, child_pid;
int i, res;
res = setpgid(0,0);
if(res==-1)
{
err_sys("setpgid");
}
Stephan Schulz 596
Example (2)
pid = getpid();
pgid = getpgrp();
printf("Queen bee:PID is %d process group is %d\n",pid,pgid);
for(i=0; i<3; i++)
{
child_pid = fork();
if(child_pid<0)
{
err_sys("fork");
}
if(child_pid == 0)
{
break; /* Only the parent forks! */
}
}
Stephan Schulz 597
Example (3)
if(child_pid == 0)
{
while(1)
{
printf("Worker bee %d gathering honey\n", i);
sleep(1);
}
}
for(i=0; i<3; i++)
{
printf("Queen bee sleeping\n");
sleep(1);
}
printf("Queen bee terminates\n");
kill(-getpgrp(), SIGTERM); /* Commented out for version 2 */
return EXIT_SUCCESS;
}
Stephan Schulz 598
Example Output with kill
Queen bee:PID is 2412 process group is 2412
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee terminates
Stephan Schulz 599
Example Output without kill
schulz@leonardo 4:31am [CSC_322] ./pgkill_example
Queen bee:PID is 2460 process group is 2460
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee sleeping
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Queen bee terminates
schulz@leonardo 4:32am [CSC_322] Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Worker bee 0 gathering honey
Worker bee 1 gathering honey
Worker bee 2 gathering honey
Worker bee 0 gathering honey
...
Stephan Schulz 600
Waiting for Termination: waitpid()
The wait() function waits for termination of anychild of a process
–It blocks until a child terminates
–It cannot check the status of a speciﬁc child
POSIX introduced waitpid() as a more general interface solving this problem:
#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t wpid, int *status, int options);
Stephan Schulz 601
waitpid() continued
Return value: PID of terminated child (or 0 if no child terminated, or -1 on error)
wpid : Process id describing processes we are waiting for
–wpid == -1 : Wait for all processes
–wpid > 0 : Wait for process with PID wpid
–wpid < -1 : Wait for all processes in process group with PDID |wpid|
–wpid == 0 : Wait for all children with PGID of the caller
status : As for wait() , if!=NULL , termination status is written into it
options : (Can be combined with |)
–0: Normal blocking wait
–WNOHANG : Return immediately with 0if no child is available
–WUNTRACED : Used for job control and stopped processes
Stephan Schulz 602
Exercises
Write a program that keeps a network server alive (or reaninmates it):
–The server accepts connections
–For each connection, it forks a child that reads input from the net and appends
it to a log ﬁle
–All those processes should be in the same process group
The monitor program just starts the main server process, makes it the group
leader, and waits for the server to terminate
–In that case, it kills all of the server processes and restarts the server
Stephan Schulz 603
CSC322
C Programming and UNIX
Program Execution
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Process Environment
Each UNIX process has an environment
–the Environment consists of a list of strings
–Normally, those strings have the form name=value (and most functions for
manipulating the environment assume this form)
–The name is called an environment variable
–Since most environment variables are created and maintained by the shell, they
are often also called shell variables
Children inherit the environment of their parents
–Note that children get a copy of the environment
–Each process can change its own environment, but not that of its parent
Environment variables are used for a large number of things
–Where to look for executable programs
–Which editor to use (in well-written applications)
–What is the users username?
–Some mandated by standards (POSIX, SUSv2), others just customary
Stephan Schulz 605
Environment and the Shell
You can print the environment using the printenv program
–Just printenv prints all environment variables (and their values)
–printenv <name> prints the value of the variable with name <name>
Since no process can modify its parents environment, you need to use a build-in
command to change a shells environment
–tcsh: setenv VAR VALUE andunsetenv VAR
–bash: export VAR=VALUE andunset VAR
Stephan Schulz 606
Example: Part of my Environment
$printenv
PWD=/home/schulz/SOURCES/CSC_322
VENDOR=intel
HOSTNAME=wombat
QTDIR=/usr/lib/qt3-gcc2.96
LESSOPEN=|/usr/bin/lesspipe.sh %s
USER=schulz
LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:
MACHTYPE=i386
XDM_MANAGED=/var/run/xdmctl/xdmctl-:0,maysd,mayfn,sched
XMODIFIERS=@im=none
EDITOR=emacsclient
LANG=C
HOST=wombat
DISPLAY=:0.0
FROM=Stephan Schulz <schulz@cs.miami.edu>
LOGNAME=schulz
SHLVL=3
GROUP=schulz
TEXINPUTS=:~/TEXT/TEXLIB/
SUPPORTED=en_US.iso885915:en_US:en:de_DE@euro:de_DE:de
SHELL=/bin/tcsh
HOSTTYPE=i386-linux
CVSROOT=stephan@gw.safelogic.se:/CVS
OSTYPE=linux
HOME=/home/schulz
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
PATH=/home/schulz/bin:/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin:/usr/X11R6/bin:.
_=/usr/X11R6/bin/xterm
TERM=xterm
WINDOWID=18874382
Stephan Schulz 607
Some Important Environment Variables
PATH (POSIX) determines where the shell looks for executable programs
–List of directory names, separated by colon
–Can contain .to include working directory ( Dangerous on multi-user systems)
EDITOR (traditional) is used by good UNIX program to determine which editor
to run if you have to edit text
LOGNAME (POSIX) is your user name
TERM (POSIX) is your (text) terminal type
–If you have trouble with remote logins, set it to vt100
HOME (POSIX) is your home directory
DISPLAY (X11 Window System) is the name of your display
–UNIX can run programs on one host, and display them on another
–DISPLAY tells it where to show output for X programs
Stephan Schulz 608
Accessing the Environment from a Program
There are two ways to access the environment of a process:
–Via the environ variable
–Viagetenv() andputenv()
If we want to go through all of the environment, we need to declare the environ
variable :
extern char **environ;
–It points to a NULL -terminated array of pointers
–Each array element points to \0-terminated C string of the form
<name>=<value>
Stephan Schulz 609
Example
#include <stdlib.h>
#include <stdio.h>
extern char **environ;
int main(int argc, char* argv[])
{
char **handle;
for(handle=environ; *handle; handle++)
{
printf("%s\n", *handle);
}
return EXIT_SUCCESS;
}
Stephan Schulz 610
The POSIX Interface to the Environment
#include <stdlib.h>
char *getenv(const char *name);
int putenv(char *string);
getenv() takes a pointer to an environment variable name and returns its value
(orNULL if the variable does not exist)
–It’s even part of ANSI C (but ANSI C says nothing about the enviroment)
putenv() takes a single string of the form <name>=<value>
–Adds the string (i.e. the <name>=<value> pair) to the environment
–If<name> exists, the old deﬁnition is changed
–Note that some versions of UNIX include just the pointer in the environment,
while others create a copy of the string
Additional functions of interest:
–clearenv() : Clears environment (POSIX, but not traditional)
–unsetenv() : Remove a single variable (traditional)
–setenv() : More ﬂexible version of putenv() (traditional)
Stephan Schulz 611
Executing New Programs
A process can cause the execution of a new program via one of the exec functions
–Causes this same process to replace its own program, data, and stack with
new data
–Program code is loaded from disk
–Heap and stack are reinitialized
–New program starts running at its main() function
There are 6 diﬀerent exec functions that diﬀer in:
–How they look for the program to run (via path or via absolute ﬁlename)
–How they accept arguments for the new program (as additional arguments to
theexec function or via an array of pointers)
–How they handle the environment (inheritance of completely new environment)
Stephan Schulz 612
The 6 exec Functions
#include <unistd.h>
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg , ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *filename, char *const argv [], char *const envp[]);
All return -1 on error, and not at all on success
execlp() andexecvp() take a ﬁlename and search the PATH directories for the
program
execl() ,execlp() and execle() take arguments for the new program as
additional arguments
–The list has to end with an additional NULL argument
–The others take a pre-created argv vector
Finally, execle() andexecve() take an explicit environment pointer
Stephan Schulz 613
The execvp() function
execvp(const char *file, char *const argv[]) is reaonably easy to use:
–First argument is a ﬁle name (not containing any /)
–The program to be executed is found as by the shell, by looking through all
the directories in PATH
Second argument is a pointer to an array of argument pointers
–Same format and conventions as argv in main
–First argument should be program name
–Array should be NULL terminated
Upon execution, the new program runs
–Keeps old PID, GID, PGID, working directory, . . .
–Normal ﬁle descriptors stay open (unless the the ﬂag FDCLOEXEC is set using
fcntl() )
Stephan Schulz 614
Example: A mini-Shell
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>
#define MAX_LINE 1024
void err_sys(char* message)
{
perror(message);
exit(EXIT_FAILURE);
}
Stephan Schulz 615
Example (2)
void* secure_malloc(int size)
{
void* res = malloc(size);
if(!res)
{
fprintf(stderr, "malloc() failure -- out of memory?");
exit(EXIT_FAILURE);
}
return res;
}
char* secure_strdup(char* source)
{
void* res = secure_malloc(strlen(source)+1);
strcpy(res, source);
return res;
}
Stephan Schulz 616
Example (3)
int count_words(char* line)
{
int words=0, in_word=0;
while(*line)
{
if(isspace(*line))
{
in_word = 0;
}
else
{
if(in_word == 0)
{
words++;
in_word = 1;
}
}
line++;
}
return words;
}
Stephan Schulz 617
Example (4)
char **build_argv(char* line)
{
int argc = count_words(line);
int i;
char *new;
char **argv;
if(argc == 0)
{
return NULL;
}
argv = secure_malloc(sizeof(char*)*(argc+1));
Stephan Schulz 618
Example (5)
for(i=0; i<argc; i++)
{
while(isspace(*line))
{
line++;
}
for(new=line; *new && !isspace(*new); new++);
/* Empty body */
*new = ’\0’;
argv[i] = secure_strdup(line);
line = new+1;
}
argv[i] = NULL;
return argv;
}
Stephan Schulz 619
Example (6)
void print_argv(char **argv)
{
int i;
printf("Command: %s\n", argv[0]);
printf("Arguments:\n");
for(i=0; argv[i]; i++)
{
printf("%s\n", argv[i]);
}
printf("=======\n");
}
Stephan Schulz 620
Example (7)
int main(void)
{
pid_t child_pid;
char line[MAX_LINE];
char *line_res;
char **argv;
while(1)
{
printf("# ");fflush(NULL);
line_res = fgets(line, MAX_LINE, stdin);
if(!line_res)
{
break;
}
argv = build_argv(line);
if(!argv)
{
continue;
}
print_argv(argv);
Stephan Schulz 621
Example (8)
child_pid = fork();
if(child_pid == -1)
{
err_sys("fork");
}
if(child_pid == 0) /* Child! */
{
setpgid(0,0);
if(execvp(argv[0], argv) == -1)
{
err_sys("execvp");
}
}
else
Stephan Schulz 622
Example (9)
{ /* Parent */
setpgid(child_pid, child_pid);
if(wait(NULL) == -1)
{
err_sys("wait");
}
free(argv);
}
}
return EXIT_SUCCESS;
}
Stephan Schulz 623
Example Usage
schulz@wombat 2:01am [CSC_322] ./shell_example
# echo Hallo
Command: echo
Arguments:
echo
Hallo
=======
Hallo
# ls -l macrotest.c wordcount env_example.c
Command: ls
Arguments:
ls
-l
macrotest.c
wordcount
env_example.c
=======
-rw-rw-r-- 1 schulz schulz 233 Dec 3 21:31 env_example.c
-rw-rw-r-- 1 schulz schulz 206 Nov 26 23:41 macrotest.c
-rwxrwxr-x 1 schulz schulz 13715 Nov 26 23:47 wordcount
Stephan Schulz 624
Example Usage (2)
# ls *
Command: ls
Arguments:
ls
*
=======
ls: *: No such file or directory
# hallo
Command: hallo
Arguments:
hallo
=======
execvp: No such file or directory
Stephan Schulz 625
Exercises
Extend the shell example (code is on the web page) to
–Have better error handling
–Do background processing (with &)
–Support job control
–Oﬀer I/O redirection with >and<
Read the man pages on popen() andpipe() to see how we could achive piping
If you are adventurous, implement:
–Piping
–Globbing (read man glob )
Stephan Schulz 626
CSC322
C Programming and UNIX
Final Review
Stephan Schulz
Department of Computer Science
University of Miami
schulz@cs.miami.edu
http://www.cs.miami.edu/~schulz/CSC322.html
Prerequisites: CSC220 or EEN218
Final Examn
Place and Time:
–Room LC 192 (the normal room)
–Monday, Dec. 16th, 11:00 a.m. – 13:30 p.m.
Topics:
–Everything we covered in this class
–Emphasis will be on second half
You may bring:
–Lecture notes, your own notes, books, printouts of your (or my solutions)to
the exercises. . .
–. . . but no computers, PDAs, mobile phones (switch them oﬀ and stow them
away) or similar items
Note: I’ll only review material from the second half of the semester today
–Check lecture notes, pages 299–312 for overview of ﬁrst half
Stephan Schulz 628
Pointers and Dynamic Arrays
Arrays are passed as pointers to the ﬁrst element
–Arrays and pointers (to an allocated memory region) can be used in the same
way (i.e. we can index a pointer: p[5] )
–We can use realloc() to dynamically enlarge dynamically allocated arrays
Pointer arithmetic: We can add and subtract integers to pointers to step through
an array
–p[5] is equivalent to *(p+5)
The following two program snippets are equivalent:
int a[SIZE], i; int a[SIZE], *handle;
/* Assume some initialization in both versions */
for(i=0; a[i]; i++) for(handle = a; *handle; handle++)
{ {
printf("%d\n", a[i]) printf("%d\n", *handle)
} }
Stephan Schulz 629
Make
Make is a tool for automating multi-program builds
–Rule-based (rules are stored in Makefile )
–Performs just the necessary operations to update all program parts
–You specify dependencies andactions
Example:
PROGS=hello fahrenheit2celsius fahrenheit2celsius2 fahrenheit2celsius3 \
charcount ourcopy wordcount escape base_converter inc_example
all: $(PROGS)
clean:
rm $(PROGS)
hello: hello.c
gcc -ansi -Wall -o hello hello.c
fahrenheit2celsius: fahrenheit2celsius.c
gcc -ansi -Wall -o fahrenheit2celsius fahrenheit2celsius.c
...
Stephan Schulz 630
New Flow Control Constructs
break is used to break out of loops (and switch statments
–Immediately transfers control to the ﬁrst statement after the loop
continue allows early continuation of a loop
–Transfers control back to the beginning of the loop
–In case of forloops, update expression will be evaluated
do/while loops test the condition at the end of the loop
–Loop body always gets executed once
–Otherwise similar to plain while loop
Stephan Schulz 631
Function Pointers and qsort()
We can use pointers to functions (of a speciﬁc type) to
–Implement generic functions and data types
–Emulate object-oriented constructs (virtual functions)
–Implement call back and signal handlers
Using function pointer:
–Just use the function name or use the address operator ( &fun
–Calling the function: Either use pointer as is, or dereference: (*fun)(arg1)
Example for function pointer usage: qsort() from stdlib
void qsort(void *base, size_t nmemb, size_t size,
int(*compar)(const void *, const void *));
Stephan Schulz 632
Standard Library: Characters and Strings
ctype.h contains character classiﬁcation functions:
–isspace(c)
–isprint(c)
–isdigit(c)
–isalpha(c)
–isalnum(c) . . .
–Also: toupper(c) ,tolower(c)
String ( \0terminated sequence of characters) functions are deﬁned in string.h
–strcpy(to,from) copies a \0-terminated string to exiting memory
–strcat(to,from) appends a string at the end of an existing string
–strcmp(s1,s2) compares two strings, returns value <0, 0, >0
–strncopy(), strncat(), strncmp() limit operation to a given number of
characters
–strpbrk() searches for characters in a string
–strstr() seraches for a substring
Stephan Schulz 633
Standard Library: Memory Accesses
Memory access functions treat memory as a large array of characters
–Important diﬀerence to string functions: Not \0-terminated, you always have
to give a lenght
Functions:
–memcpy(to, from, n) copies nbytes
–memmove(to, from, n) does the same even for overlapping regions of memory
–memcmp(s1,s2,n) compares two memory regions
–memchr(s, c, n) searches for character cin memory region starting at s
–memset(s,c,n) writes ncopies of character cinto memory (used e.g. to zero
out socket address data structures)
Stephan Schulz 634
Standard Library: Buﬀered I/O
Standard library supports buﬀered IO viastreams
–Stream creation: fopen(filename, mode)
–Stream destruction: fclose(stream)
–Predeﬁned streams: stdin, stdout, stderr
–Text streams: Lines separated by \n
–Binary streams: Raw data (under UNIX, no diﬀerence)
Basic I/O functions:
–fgetc(stream) reads a single character and returns it as an int(and EOFon
end of ﬁle)
–fputc(c, stream) writes a single character to a stream
–fgets(s,n,stream ) reads a single line or ncharacters (whichever is less) into
thepreallocated memory at s
–fputs(s, stream) writes a \0-terminated string to the stream
Streams can be fflush() ed, and we can change buﬀering with setvbuff() and
setbuf()
Stephan Schulz 635
Standard Library: Formatted Output
printf(format,...) and fprintf(stream, format, ...) write an arbi-
trary number of arguments under the control of a format string
–Format string contains plain characters and conversion speciﬁers starting with
a%
–Each conversion speciﬁer must have a matching argument
–Conversion speciﬁers specify in which form argument is printed
Conversion speciﬁer format:
–%, followed by optional ﬂags, ﬁeld width, precision, size modiﬁer
–Ends in a conversion letter
Example: printf("%-5ld\n", i)
–Prints integer, at least 5 characters, left-justiﬁed (ﬁlls up with spaces), followed
by a newline
Important conversion letters: d(int), s(string), c(character), g(ﬂoating point
number)
Stephan Schulz 636
Processes and Signals
Processes are running programs and have a number of properties
–Owner, PID, GID, PGID, Parent
–Each process has its own virtual memory and cannot (directly) access other
processes data
–Multiple processes can run “at the same time”
We can use a number of tools to work with running processes:
–pslists running processes
–topgives an interactive view of running processes
kill <pid> can be used to send signals to process <pid>
–By default sends SIGTERM
–You can also send other signals, e.g. kill -HUP <pid>
Signals can also be generated by other events, e.g.
–Floating point exception
–Illegal memory access
Stephan Schulz 637
Signal Handling
Each signal has a default action (either abort, abort with core dump, or ignore)
–Action can be changed!
Thesignal(sig, handler) function can be used to change the behaviour of a
process to a signal
–sigis the signal to respond to
–handler is a pointer to a function that returns void and takes an int(the
signal) as an argument
–Predeﬁned pseudo-handlers: SIG DFL (re-establish default behaviour),
SIG IGN(ignore signal)
Established signal handlers catch a single signal!
–Must reestablish handler from within the handler
Signals can occur at any time, state of the program may be undeﬁned
–It’s dangerous to do much beyond exiting, manipulating variables of type
volatile sig atomic t, and calling signal() again
Stephan Schulz 638
UNIX File System (I)
UNIX: Everything is a ﬁle
File types:
–Regular ﬁle
–Directory
–Character special ﬁle
–Block special ﬁle
–Socket
–Symbolic link
stat() functions give us information about ﬁles
–Owner
–Mode
–Size
–Access and modiﬁcation times
Stephan Schulz 639
UNIX File System (II)
Importsant concepts:
–File ownership and group ownership
–Access rights (read, write, execute for user/group/others)
–Links: Connect a name to a ﬁle
∗Hard links: Directory entries
∗Soft links: Files with names of another ﬁle as data
Important utilities:
–ln: Creates links (both symbolic and hard)
–ls: Shows ﬁles and ﬁle information
–chmod : Allows us to change the mode of a ﬁle
–chgrp : Changes group
–chown : Changes owner
Stephan Schulz 640
File Descriptors and select()
File descriptors are used by the UNIX kernel to represent open ﬁles
–File descriptors are small integers (indices into the process ﬁle table)
–Can be associated with a number of ﬂags we can manipulate with fcntl() or
set when we open the ﬁle: ONONBLOCK ,OAPPEND , . . .
–Predeﬁned: STDIN FILENO ,STDOUT FILENO ,STDERR FILENO
–Opening ﬁles: open()
–Using ﬁles: read(fd, buf, n) andwrite(fd, buf, n)
–Closing: close()
select(maxfd, readfds, writefds, exceptfds, time) waits for certain
things to become true for sets of ﬁle descriptors
–Any of the ﬁle descriptors in readfds() is ready for reading
–Any of the ﬁle descriptors in writefds() is ready for writing
–An exceptional circumstance happens for one of the ﬁle descriptors in
exceptfds()
–Return value: Number of ﬁle descriptors for which condition is true
–Also removes all ﬁle descriptors from sets for which condition is nottrue
Stephan Schulz 641
Networking Concepts
Communication can be
–Broadcast vs. dedicated partners
–Stream-oriented vs. packet-oriented
–Reliable vs. unreliable
Communication partners need to be uniquely identiﬁed
–For IP: IP addresses (denote hosts) (4 8 bit numbers, e.g. 127.0.0.1)
–For TCP/IP: IP address and port (16-bit integer)
UNIX uses sockets (a special kind of ﬁle descriptors) for communication
–Bi-directional streams
–Use with read() andwrite()
Stephan Schulz 642
TCP/IP (v4) Connections
Reliable, stream-oriented, between two partners
Client:
–Create a socket: socket(PF INET, SOCK STREAM, 0)
–Fill in struct sockaddr inaddress structure
∗sin family = AF INET
∗sin port = htons(port)
∗sin addr ﬁlled in with inet ptons()
–Connect socket to address: connect(sock, addr, addr len)
–Use socker and close() it
Server:
–Create socket
–Create its own address (normally with INADDDR ANY)
–bind() ing the socket to the address
–listen() ing on the socket
–accepting( ) the connection (giving a newsocket)
–Use and close the socket
Stephan Schulz 643
Creating and Ending Processes
fork() creates new process
–Both parent and child execute the same program
Parent has to wait() orwaitpid() to pick up the childs termination status
–Otherwise child becomes zombie
–But orphans are inherited by init
Process termination
–exit()
–return from main()
–Abort (from a signal)
Stephan Schulz 644
Process Environment and Program Execution
Processes have access to environment variables
–Inherited from (or set up by) parent
–Can be modiﬁed
To start a new program:
–fork() to create a new process
–Call one of the exec functions with:
∗Executable name (ﬁlename or path name)
∗Arguments (individual or as array)
∗For some functions, environment pointer
Stephan Schulz 645
Exercises
Learn hard ;-)
Stephan Schulz 646

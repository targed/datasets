
How To Code in Python 3Lisa Tagliaferri
DigitalOcean, New York City, New York, USA
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0International License.ISBN 978-0-9997730-1-7
About DigitalOceanDigitalOcean is a cloud services platform delivering the simplicitydevelopers love and businesses trust to run production applications atscale. It provides highly available, secure and scalable compute, storageand networking solutions that help developers build great softwarefaster. Founded in 2012 with ofﬁces in New York and Cambridge, MA,DigitalOcean offers transparent and affordable pricing, an elegant userinterface, and one of the largest libraries of open source resourcesavailable. For more information, please visithttps://www.digitalocean.com or follow @digitalocean on Twitter.Read this book online and receive server credit viahttps://do.co/python-book.DigitalOcean Community TeamDirector of Community: Etel SverdlovTechnical Writers: Melissa Anderson, Brian Boucheron, Mark Drake,Justin Ellingwood, Katy Howard, Lisa TagliaferriTechnical Editors: Brian Hogan, Hazel Virdó
How To Code in Python 31. Introduction2. Python 2 vs Python 3: Practical Considerations3. How To Install Python 3 and Set Up a Local ProgrammingEnvironment on Ubuntu 16.044. How To Install Python 3 and Set Up a Local ProgrammingEnvironment on macOS5. How To Install Python 3 and Set Up a Local ProgrammingEnvironment on Windows 106. How To Install Python 3 and Set Up a Local ProgrammingEnvironment on CentOS 77. How To Install Python 3 and Set Up a Programming Environment onan Ubuntu 16.04 Server8. How To Write Your First Python 3 Program9. How To Work with the Python Interactive Console10. How To Write Comments11. Understanding Data Types12. An Introduction to Working with Strings13. How To Format Text14. An Introduction to String Functions15. How To Index and Slice Strings16. How To Convert Data Types17. How To Use Variables18. How To Use String Formatters19. How To Do Math with Operators20. Built-in Python 3 Functions for Working with Numbers
21. Understanding Boolean Logic22. Understanding Lists23. How To Use List Methods24. Understanding List Comprehensions25. Understanding Tuples26. Understanding Dictionaries27. How To Import Modules28. How To Write Modules29. How To Write Conditional Statements30. How To Construct While Loops31. How To Construct For Loops32. How To Use Break, Continue, and Pass Statements when Workingwith Loops33. How To Deﬁne Functions34. How To Use *args and **kwargs35. How To Construct Classes and Deﬁne Objects36. Understanding Class and Instance Variables37. Understanding Inheritance38. How To Apply Polymorphism to Classes39. How To Use the Python Debugger40. How To Debug Python with an Interactive Console41. How To Use Logging42. How To Port Python 2 Code to Python 3
IntroductionWhy Learn To CodeSoftware and technology are becoming increasingly integrated into oureveryday lives, allowing us to accomplish tasks, navigate to destinations,make purchases, and stay connected with friends. Because of howpervasive software now is to the human experience, it is important for allof us to learn some of the key foundational elements of computerprogramming. While some may choose to study computer science as partof their formal education, everyone can beneﬁt from an understanding ofalgorithmic thinking and computational processes. Learning how thesoftware that we use on a daily basis is made can allow us as end users toevaluate how and why these applications are developed, enabling us tothink critically about these tools and how to improve them.Just like any other product, computer programs are designed anddeveloped by people who have unconscious biases, make errors, andmay not be considering all aspects of a problem they are trying to solve.Though development teams may do thorough testing and work to createsophisticated and useful programs, they do not always meet the needsand expectations of all users. While not everyone needs to learn to codecomplex programs, learning how coding works can help shape the futureof technology and increase the number of stakeholders, decision makers,and knowledge producers who can work to build better software foreveryone.Some of us may choose to solve challenging problems within thetechnology sector, but for those of us not working in computer science, a
programming background can still be a great asset to our professionalﬁelds. Computer programming provides many applications acrossdomains, and can help us solve problems in specialities such as medicine,economics, sociology, history, and literature, to name a few. Byintegrating technology’s methodologies into our own ﬁelds, we canleverage computational logic and software design and developmentpractices in our work. When we synthesize knowledge across spheresand collaborate with people from different backgrounds, we can innovatein new, more inclusive ways that can enact meaningful impact acrossmany communities.Why Learn PythonExtremely versatile and popular among developers, Python is a goodgeneral-purpose language that can be used in a variety of applications.For those with an understanding of English, Python is a very human-readable programming language, allowing for quick comprehension.Because Python supports multiple styles including scripting and object-oriented programming, it is considered to be a multi-paradigm languagethat enables programmers to use the most suitable style to complete aproject. Increasingly used in industry, Python offers a lot of potential forthose who would like to begin coding while also being a good choice forthose looking to pick up an additional programming language.Learning the key concepts of Python can help you understand howprograms work while also imparting foundational logic that can serveyou in other domains. Understanding what Python and computerprogramming can offer you both as a user and as a developer isimportant as technology is further integrated into daily life.
As you work through this book, you will be able to increase yourawareness of computer programming, improve your logical thinking,and eventually become a producer of software. Being able to createsoftware that runs is a very rewarding endeavor, and can help you servethose around you by increasing their access and empowering them tobecome collaborators. The more communities involved in the creation ofsoftware development, the more communities there will be whose needsare served by software.How To Use This BookThis book is designed to be used in a way that makes sense for you.While it is arranged to ramp up an emerging developer, do not beconstrained by the order: feel free to move throughout the book in a waythat makes sense for you. Once you are familiar with the concepts, youcan continue to use the book as a source of reference.If you use the book in the order it is laid out, you’ll begin yourexploration in Python by understanding the key differences betweenPython 3 and the previous versions of the language. From there, you’llset up a programming environment for your relevant local or server-based system, and begin by learning general Python code structure,syntax, and data types. Along the way, you’ll gain a solid grounding incomputational logic within Python, which can help you learn otherprogramming languages. While the beginning of the book focuses onscripting in Python, the end of the book will take you through object-oriented coding in Python, which can make your code more modular,ﬂexible, and complex without repetition. By the end of the book, you’lllearn how to debug your Python code and ﬁnally how to port Pythoncode across versions.
When you are done with the book, we encourage you to look atproject-based tutorials to put your knowledge into play while creatingprojects that can help you solve problems. While you are working onthese projects, you can continue to refer to the chapters in this book asreference material.As part of your learning process and once you feel comfortable, werecommend that you contribute to an open-source project to improveprograms and drive greater access via software and technicaldocumentation pull requests or repository maintenance. Our communityis bigger than just us and building software together can make sure thateveryone has an opportunity to participate in the technology we useevery day.
Python 2 vs Python 3: PracticalConsiderationsPython is an extremely readable and versatile programming language.With a name inspired by the British comedy group Monty Python, it wasan important foundational goal of the Python development team to makethe language fun to use. Easy to set up, and written in a relativelystraightforward style with immediate feedback on errors, Python is agreat choice for beginners.As Python is a multiparadigm language — that is, it supports multipleprogramming styles including scripting and object-oriented — it is goodfor general purpose use. Increasingly used in industry by organizationssuch as United Space Alliance (NASA’s main shuttle support contractor),and Industrial Light & Magic (the VFX and animation studio ofLucasﬁlm), Python offers a lot of potential for those looking to pick up anadditional programming language.Developed in the late 1980s and ﬁrst published in 1991, Python wasauthored by Guido van Rossum, who is still very active in thecommunity. Conceived as a successor to the ABC programminglanguage, Python’s ﬁrst iteration already included exception handling,functions, and classes with inheritance. When an important Usenetnewsgroup discussion forum called comp.lang.python was formed in1994, Python’s user base grew, paving the way for Python to become oneof the most popular programming languages for open sourcedevelopment.General Overview
Before looking into potential opportunities related to — and the keyprogrammatic differences between — Python 2 and Python 3, let’s take alook into the background of the more recent major releases of Python.Python 2Published in late 2000, Python 2 signalled a more transparent andinclusive language development process than earlier versions of Pythonwith the implementation of PEP (Python Enhancement Proposal), atechnical speciﬁcation that either provides information to Pythoncommunity members or describes a new feature of the language.Additionally, Python 2 included many more programmatic featuresincluding a cycle-detecting garbage collector to automate memorymanagement, increased Unicode support to standardize characters, andlist comprehensions to create a list based on existing lists. As Python 2continued to develop, more features were added, including unifyingPython’s types and classes into one hierarchy in Python version 2.2.Python 3Python 3 is regarded as the future of Python and is the version of thelanguage that is currently in development. A major overhaul, Python 3was released in late 2008 to address and amend intrinsic design ﬂaws ofprevious versions of the language. The focus of Python 3 developmentwas to clean up the codebase and remove redundancy, making it clearthat there was only one way to perform a given task.Major modiﬁcations to Python 3.0 included changing the printstatement into a built-in function, improve the way integers are divided,and providing more Unicode support.
At ﬁrst, Python 3 was slowly adopted due to the language not beingbackwards compatible with Python 2, requiring people to make adecision as to which version of the language to use. Additionally, manypackage libraries were only available for Python 2, but as thedevelopment team behind Python 3 has reiterated that there is an end oflife for Python 2 support, more libraries have been ported to Python 3.The increased adoption of Python 3 can be shown by the number ofPython packages that now provide Python 3 support, which at the timeof writing includes 339 of the 360 most popular Python packages.Python 2.7Following the 2008 release of Python 3.0, Python 2.7 was published onJuly 3, 2010 and planned as the last of the 2.x releases. The intentionbehind Python 2.7 was to make it easier for Python 2.x users to portfeatures over to Python 3 by providing some measure of compatibilitybetween the two. This compatibility support included enhanced modulesfor version 2.7 like unittest to support test automation, argparse forparsing command-line options, and more convenient classes in collections.Because of Python 2.7’s unique position as a version in between theearlier iterations of Python 2 and Python 3.0, it has persisted as a verypopular choice for programmers due to its compatibility with manyrobust libraries. When we talk about Python 2 today, we are typicallyreferring to the Python 2.7 release as that is the most frequently usedversion.Python 2.7, however, is considered to be a legacy language and itscontinued development, which today mostly consists of bug ﬁxes, willcease completely in 2020.
Key DifferencesWhile Python 2.7 and Python 3 share many similar capabilities, theyshould not be thought of as entirely interchangeable. Though you canwrite good code and useful programs in either version, it is worthunderstanding that there will be some considerable differences in codesyntax and handling.Below are a few examples, but you should keep in mind that you willlikely encounter more syntactical differences as you continue to learnPython.PrintIn Python 2, print is treated as a statement instead of a function, whichwas a typical area of confusion as many other actions in Python requirearguments inside of parentheses to execute. If you want your console toprint out Sammy the Shark is my favorite sea creature inPython 2 you can do so with the following print statement:print "Sammy the Shark is my favorite sea creature"With Python 3, print() is now explicitly treated as a function, so toprint out the same string above, you can do so simply and easily usingthe syntax of a function:print("Sammy the Shark is my favorite sea creature")This change made Python’s syntax more consistent and also made iteasier to change between different print functions. Conveniently, the 
print() syntax is also backwards-compatible with Python 2.7, so yourPython 3 print() functions can run in either version.Division with IntegersIn Python 2, any number that you type without decimals is treated as theprogramming type called integer. While at ﬁrst glance this seems like aneasy way to handle programming types, when you try to divide integerstogether sometimes you expect to get an answer with decimal places(called a ﬂoat), as in:5 / 2 = 2.5However, in Python 2 integers were strongly typed and would notchange to a ﬂoat with decimal places even in cases when that wouldmake intuitive sense.When the two numbers on either side of the division / symbol areintegers, Python 2 does ﬂoor division so that for the quotient x thenumber returned is the largest integer less than or equal to x. This meansthat when you write 5 / 2 to divide the two numbers, Python 2.7returns the largest integer less than or equal to 2.5, in this case 2:a = 5 / 2print aOutput2
To override this, you could add decimal places as in 5.0 / 2.0 to getthe expected answer 2.5.In Python 3, integer division became more intuitive, as in:a = 5 / 2print(a)Output2.5You can still use 5.0 / 2.0 to return 2.5, but if you want to do ﬂoordivision you should use the Python 3 syntax of //, like this:b = 5 // 2print(b)Output2This modiﬁcation in Python 3 made dividing by integers much moreintuitive and is a feature that is not backwards compatible with Python2.7.Unicode SupportWhen programming languages handle the string type — that is, asequence of characters — they can do so in a few different ways so thatcomputers can convert numbers to letters and other symbols.
Python 2 uses the ASCII alphabet by default, so when you type "Hello, Sammy!" Python 2 will handle the string as ASCII. Limited toa couple of hundred characters at best in various extended forms, ASCIIis not a very ﬂexible method for encoding characters, especially non-English characters.To use the more versatile and robust Unicode character encoding,which supports over 128,000 characters across contemporary and historicscripts and symbol sets, you would have to type u"Hello, Sammy!",with the u preﬁx standing for Unicode.Python 3 uses Unicode by default, which saves programmers extradevelopment time, and you can easily type and display many morecharacters directly into your program. Because Unicode supports greaterlinguistic character diversity as well as the display of emojis, using it asthe default character encoding ensures that mobile devices around theworld are readily supported in your development projects.If you would like your Python 3 code to be backwards-compatible withPython 2, though, you can keep the u before your string.Continued DevelopmentThe biggest difference between Python 3 and Python 2 is not a syntacticalone, but the fact that Python 2.7 will lose continued support in 2020 andPython 3 will continue to be developed with more features and more bugﬁxes.Recent developments have included formatted string literals, simplercustomization of class creation, and a cleaner syntactical way to handlematrix multiplication.Continued development of Python 3 means that developers can rely onhaving issues ﬁxed in a timely manner, and programs can be more
effective with increased functionality being built in over time.Additional Points to ConsiderAs someone starting Python as a new programmer, or an experiencedprogrammer new to the Python language, you will want to considerwhat you are hoping to achieve in learning the language.If you are hoping just to learn without a set project in mind, you willlikely most want to take into account that Python 3 will continue to besupported and developed, while Python 2.7 will not.If, however, you are planning to join an existing project, you will likelymost want to see what version of Python the team is using, how adifferent version may interact with the legacy codebase, if the packagesthe project uses are supported in a different version, and what theimplementation details of the project are.If you are beginning a project that you have in mind, it would beworthwhile to investigate what packages are available to use and withwhich version of Python they are compatible. As noted above, thoughearlier versions of Python 3 had less compatibility with libraries built forversions of Python 2, many have ported over to Python 3 or arecommitted to doing so in the next four years.ConclusionPython is a versatile and well-documented programming language tolearn, and whether you choose to work with Python 2 or Python 3, youwill be able to work on exciting software projects.Though there are several key differences, it is not too difﬁcult to movefrom Python 3 to Python 2 with a few tweaks, and you will often ﬁndthat Python 2.7 can easily run Python 3 code, especially when you are
starting out. You can learn more about this process by reading the tutorialHow To Port Python 2 Code to Python 3.It is important to keep in mind that as more developer and communityattention focuses on Python 3, the language will become more reﬁnedand in-line with the evolving needs of programmers, and less supportwill be given to Python 2.7.
How To Install Python 3 and Set Up a LocalProgramming Environment on Ubuntu 16.04This tutorial will get you up and running with a local Python 3programming environment in Ubuntu 16.04.Python is a versatile programming language that can be used for manydifferent programming projects. First published in 1991 with a nameinspired by the British comedy group Monty Python, the developmentteam wanted to make Python a language that was fun to use. Easy to setup, and written in a relatively straightforward style with immediatefeedback on errors, Python is a great choice for beginners andexperienced developers alike. Python 3 is the most current version of thelanguage and is considered to be the future of Python.This tutorial will guide you through installing Python 3 on your localLinux machine and setting up a programming environment via thecommand line. This tutorial will explicitly cover the installationprocedures for Ubuntu 16.04, but the general principles apply to anyother distribution of Debian Linux.PrerequisitesYou will need a computer with Ubuntu 16.04 installed, as well as haveadministrative access to that machine and an internet connection.Step 1 — Setting Up Python 3We’ll be completing our installation and setup on the command line,which is a non-graphical way to interact with your computer. That is,
instead of clicking on buttons, you’ll be typing in text and receivingfeedback from your computer through text as well. The command line,also known as a shell, can help you modify and automate many of thetasks you do on a computer every day, and is an essential tool forsoftware developers. There are many terminal commands to learn thatcan enable you to do more powerful things. The article “An Introductionto the Linux Terminal” can get you better oriented with the terminal.On Ubuntu 16.04, you can ﬁnd the Terminal application by clicking onthe Ubuntu icon in the upper-left hand corner of your screen and typing“terminal” into the search bar. Click on the Terminal application icon toopen it. Alternatively, you can hit the CTRL, ALT, and T keys on yourkeyboard at the same time to open the Terminal applicationautomatically.
Ubuntu Terminal
Ubuntu 16.04 ships with both Python 3 and Python 2 pre-installed. Tomake sure that our versions are up-to-date, let’s update and upgrade thesystem with apt-get:sudo apt-get updatesudo apt-get -y upgradeThe -y ﬂag will conﬁrm that we are agreeing for all items to beinstalled, but depending on your version of Linux, you may need toconﬁrm additional prompts as your system updates and upgrades.Once the process is complete, we can check the version of Python 3that is installed in the system by typing:python3 -VYou will receive output in the terminal window that will let you knowthe version number. The version number may vary, but it will looksimilar to this:OutputPython 3.5.2To manage software packages for Python, let’s install pip:sudo apt-get install -y python3-pipA tool for use with Python, pip installs and manages programmingpackages we may want to use in our development projects. You can
install Python packages by typing:pip3 install package_nameHere, package_name can refer to any Python package or library, suchas Django for web development or NumPy for scientiﬁc computing. So ifyou would like to install NumPy, you can do so with the command pip3 install numpy.There are a few more packages and development tools to install toensure that we have a robust set-up for our programming environment:sudo apt-get install build-essential libssl-dev libffi-dev python-devOnce Python is set up, and pip and other tools are installed, we can setup a virtual environment for our development projects.Step 2 — Setting Up a Virtual EnvironmentVirtual environments enable you to have an isolated space on yourcomputer for Python projects, ensuring that each of your projects canhave its own set of dependencies that won’t disrupt any of your otherprojects.Setting up a programming environment provides us with greatercontrol over our Python projects and over how different versions ofpackages are handled. This is especially important when working withthird-party packages.You can set up as many Python programming environments as youwant. Each environment is basically a directory or folder in your
computer that has a few scripts in it to make it act as an environment.We need to ﬁrst install the venv module, part of the standard Python 3library, so that we can create virtual environments. Let’s install venv bytyping:sudo apt-get install -y python3-venvWith this installed, we are ready to create environments. Let’s choosewhich directory we would like to put our Python programmingenvironments in, or we can create a new directory with mkdir, as in:mkdir environmentscd environmentsOnce you are in the directory where you would like the environmentsto live, you can create an environment by running the followingcommand:python3 -m venv my_envEssentially, this sets up a new directory that contains a few itemswhich we can view with the ls command:ls my_envOutputbin include lib lib64 pyvenv.cfg share
Together, these ﬁles work to make sure that your projects are isolatedfrom the broader context of your local machine, so that system ﬁles andproject ﬁles don’t mix. This is good practice for version control and toensure that each of your projects has access to the particular packagesthat it needs. Python Wheels, a built-package format for Python that canspeed up your software production by reducing the number of times youneed to compile, will be in the Ubuntu 16.04 share directory.To use this environment, you need to activate it, which you can do bytyping the following command that calls the activate script:source my_env/bin/activateYour prompt will now be preﬁxed with the name of your environment,in this case it is called my_env. Your preﬁx may look somewhat different,but the name of your environment in parentheses should be the ﬁrstthing you see on your line:(my_env) sammy@sammy:~/environments$This preﬁx lets us know that the environment my_env is currentlyactive, meaning that when we create programs here they will use onlythis particular environment’s settings and packages.Note: Within the virtual environment, you can use the command python instead of python3, and pip instead of pip3 if you wouldprefer. If you use Python 3 on your machine outside of an environment,you will need to use the python3 and pip3 commands exclusively.After following these steps, your virtual environment is ready to use.
Step 3 — Creating a Simple ProgramNow that we have our virtual environment set up, let’s create a simple“Hello, World!” program. This will make sure that our environment isworking and gives us the opportunity to become more familiar withPython if we aren’t already.To do this, we’ll open up a command-line text editor such as nano andcreate a new ﬁle:(my_env) sammy@sammy:~/environments$ nano hello.pyOnce the text ﬁle opens up in the terminal window we’ll type out ourprogram:print("Hello, World!")Exit nano by typing the control and x keys, and when prompted tosave the ﬁle press y.Once you exit out of nano and return to your shell, let’s run theprogram:(my_env) sammy@sammy:~/environments$python hello.pyThe hello.py program that you just created should cause your terminalto produce the following output:OutputHello, World!
To leave the environment, simply type the command deactivate andyou will return to your original directory.ConclusionCongratulations! At this point you have a Python 3 programmingenvironment set up on your local Ubuntu machine and can begin acoding project!To set up Python 3 on another computer, follow the local programmingenvironment guides for Debian 8, CentOS 7, Windows 10, or macOS. Youcan also read about installing Python and setting up a programmingenvironment on an Ubuntu 16.04 server, which is especially useful whenworking on development teams.With your local machine ready for software development, you cancontinue to learn more about coding in Python by following“Understanding Data Types in Python 3” and “How To Use Variables inPython 3”.
How To Install Python 3 and Set Up a LocalProgramming Environment on macOSPython is a versatile programming language that can be used for manydifferent programming projects. First published in 1991 with a nameinspired by the British comedy group Monty Python, the developmentteam wanted to make Python a language that was fun to use. Easy to setup, and written in a relatively straightforward style with immediatefeedback on errors, Python is a great choice for beginners andexperienced developers alike. Python 3 is the most current version of thelanguage and is considered to be the future of Python.This tutorial will guide you through installing Python 3 on your localmacOS machine and setting up a programming environment via thecommand line.PrerequisitesYou will need a macOS computer with administrative access that isconnected to the internet.Step 1 — Opening TerminalWe’ll be completing most of our installation and set up on the commandline, which is a non-graphical way to interact with your computer. Thatis, instead of clicking on buttons, you’ll be typing in text and receivingfeedback from your computer through text as well. The command line,also known as a shell, can help you modify and automate many of the
tasks you do on a computer every day, and is an essential tool forsoftware developers.The macOS Terminal is an application you can use to access thecommand line interface. Like any other application, you can ﬁnd it bygoing into Finder, navigating to the Applications folder, and then into theUtilities folder. From here, double-click the Terminal like any otherapplication to open it up. Alternatively, you can use Spotlight by holdingdown the command and spacebar keys to ﬁnd Terminal by typing it outin the box that appears.
macOS TerminalThere are many more Terminal commands to learn that can enable youto do more powerful things. The article “An Introduction to the Linux
Terminal” can get you better oriented with the Linux Terminal, which issimilar to the macOS Terminal.Step 2 — Installing XcodeXcode is an integrated development environment (IDE) that is comprisedof software development tools for macOS. You may have Xcode installedalready. To check, in your Terminal window, type:xcode-select -pIf you receive the following output, then Xcode is installed:Output/Library/Developer/CommandLineToolsIf you received an error, then in your web browser install Xcode fromthe App Store and accept the default options.Once Xcode is installed, return to your Terminal window. Next, you’llneed to install Xcode’s separate Command Line Tools app, which youcan do by typing:xcode-select --installAt this point, Xcode and its Command Line Tools app are fullyinstalled, and we are ready to install the package manager Homebrew.Step 3 — Installing and Setting Up Homebrew
While the OS X Terminal has a lot of the functionality of Linux Terminalsand other Unix systems, it does not ship with a good package manager. Apackage manager is a collection of software tools that work to automateinstallation processes that include initial software installation, upgradingand conﬁguring of software, and removing software as needed. Theykeep installations in a central location and can maintain all softwarepackages on the system in formats that are commonly used. Homebrewprovides OS X with a free and open source software package managingsystem that simpliﬁes the installation of software on OS X.To install Homebrew, type this into your Terminal window:/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"Homebrew is made with Ruby, so it will be modifying yourcomputer’s Ruby path. The curl command pulls a script from thespeciﬁed URL. This script will explain what it will do and then pausesthe process to prompt you to conﬁrm. This provides you with a lot offeedback on what the script is going to be doing to your system and givesyou the opportunity to verify the process.If you need to enter your password note that your keystrokes will notdisplay in the Terminal window but they will be recorded, simply pressthe return key once you’ve entered your password. Otherwise press theletter y for “yes” whenever you are prompted to conﬁrm the installation.Let’s walk through the ﬂags that are associated with the curlcommand:
The -f or --fail ﬂag tells the Terminal window to give no HTMLdocument output on server errors.The -s or --silent ﬂag mutes curl so that it does not show theprogress meter, and combined with the -S or --show-error ﬂag itwill ensure that curl shows an error message if it fails.The -L or --location ﬂag will tell curl to redo the request to anew place if the server reports that the requested page has moved toa different location.Once the installation process is complete, we’ll put the Homebrewdirectory at the top of the PATH environment variable. This will ensurethat Homebrew installations will be called over the tools that Mac OS Xmay select automatically that could run counter to the developmentenvironment we’re creating.You should create or open the ~/.bash_profile ﬁle with thecommand-line text editor nano using the nano command:nano ~/.bash_profileOnce the ﬁle opens up in the Terminal window, write the following:export PATH=/usr/local/bin:$PATHTo save your changes, hold down the control key and the letter o,and when prompted press the return key. Now you can exit nano byholding the control key and the letter x.For these changes to activate, in the Terminal window, type:
source ~/.bash_profileOnce you have done this, the changes you have made to the PATHenvironment variable will be effective.We can make sure that Homebrew was successfully installed bytyping:brew doctorIf no updates are required at this time, the Terminal output will read:OutputYour system is ready to brew.Otherwise, you may get a warning to run another command such as brew update to ensure that your installation of Homebrew is up todate.Once Homebrew is ready, you can install Python 3.Step 4 — Installing Python 3You can use Homebrew to search for everything you can install with the brew search command, but to provide us with a shorter list, let’sinstead search for just the available Python-related packages or modules:brew search pythonThe Terminal will output a list of what you can install, like this:
Outputapp-engine-python          micropython                python3                 boost-python               python                     wxpython                 gst-python                 python-markdown            zpython                  homebrew/apache/mod_python               homebrew/versions/gst-python010        homebrew/python/python-dbus              Caskroom/cask/kk7ds-python-runtime     homebrew/python/vpython                  Caskroom/cask/mysql-connector-python   Python 3 will be among the items on the list. Let’s go ahead and installit:brew install python3The Terminal window will give you feedback regarding the installationprocess of Python 3, it may take a few minutes before installation iscomplete.Along with Python 3, Homebrew will install pip, setuptools andwheel.A tool for use with Python, we will use pip to install and manageprogramming packages we may want to use in our developmentprojects. You can install Python packages by typing:
pip3 install package_nameHere, package_name can refer to any Python package or library, suchas Django for web development or NumPy for scientiﬁc computing. So ifyou would like to install NumPy, you can do so with the command pip3 install numpy.setuptools facilitates packaging Python projects, and wheel is a built-package format for Python that can speed up your software productionby reducing the number of times you need to compile.To check the version of Python 3 that you installed, you can type:python3 --versionThis will output the speciﬁc version of Python that is currentlyinstalled, which will by default be the most up-to-date stable version ofPython 3 that is available.To update your version of Python 3, you can ﬁrst update Homebrewand then update Python:brew updatebrew upgrade python3It is good practice to ensure that your version of Python is up-to-date.Step 5 — Creating a Virtual EnvironmentNow that we have Xcode, Homebrew, and Python installed, we can goon to create our programming environment.
Virtual environments enable you to have an isolated space on yourcomputer for Python projects, ensuring that each of your projects canhave its own set of dependencies that won’t disrupt any of your otherprojects.Setting up a programming environment provides us with greatercontrol over our Python projects and over how different versions ofpackages are handled. This is especially important when working withthird-party packages.You can set up as many Python programming environments as youwould like. Each environment is basically a directory or folder in yourcomputer that has a few scripts in it to make it act as an environment.Choose which directory you would like to put your Pythonprogramming environments in, or create a new directory with mkdir, asin:mkdir Environmentscd EnvironmentsOnce you are in the directory where you would like the environmentsto live, you can create an environment by running the followingcommand:python3.6 -m venv my_envEssentially, this command creates a new directory (in this case calledmy_env) that contains a few items: - The pyvenv.cfg ﬁle points to thePython installation that you used to run the command. - The libsubdirectory contains a copy of the Python version and has a site-
packages subdirectory inside it that starts out empty but will eventuallyhold the relevant third-party modules that you install. - The includesubdirectory compiles packages. - The bin subdirectory has a copy of thePython binary along with the activate shell script that is used to set upthe environment.Together, these ﬁles work to make sure that your projects are isolatedfrom the broader context of your local machine, so that system ﬁles andproject ﬁles don’t mix. This is good practice for version control and toensure that each of your projects has access to the particular packagesthat it needs.To use this environment, you need to activate it, which you can do bytyping the following command that calls the activate script:source my_env/bin/activateYour prompt will now be preﬁxed with the name of your environment,in this case it is called my_env:(my_env) Sammys-MBP:~ sammy$This preﬁx lets us know that the environment my_env is currentlyactive, meaning that when we create programs here they will use onlythis particular environment’s settings and packages.Note: Within the virtual environment, you can use the command python instead of python3, and pip instead of pip3 if you wouldprefer. If you use Python 3 on your machine outside of an environment,you’ll need to use the python3 and pip3 commands exclusively, as python and pip will call an earlier version of Python.
After following these steps, your virtual environment is ready to use.Step 6 — Creating a Simple ProgramNow that we have our virtual environment set up, let’s create a simple“Hello, World!” program. This will make sure that our environment isworking and gives us the opportunity to become more familiar withPython if we aren’t already.To do this, we’ll open up a command-line text editor such as nano andcreate a new ﬁle:(my_env) Sammys-MBP:~ sammy$ nano hello.pyOnce the text ﬁle opens up in Terminal we’ll type out our program:print("Hello, World!")Exit nano by typing the control and x keys, and when prompted tosave the ﬁle press y.Once you exit out of nano and return to your shell, let’s run theprogram:(my_env) Sammys-MBP:~ sammy$ python hello.pyThe hello.py program that you just created should cause Terminal toproduce the following output:OutputHello, World!
To leave the environment, simply type the command deactivate andyou’ll return to your original directory.ConclusionCongratulations! At this point you have a Python 3 programmingenvironment set up on your local Mac OS X machine and can begin acoding project!To set up Python 3 on another computer, follow the local programmingenvironment guides for Ubuntu 16.04, Debian 8, CentOS 7, or Windows10. You can also read about installing Python and setting up aprogramming environment on an Ubuntu 16.04 server, which isespecially useful when working on development teams.With your local machine ready for software development, you cancontinue to learn more about coding in Python by following“Understanding Data Types in Python 3” and “How To Use Variables inPython 3”.
How To Install Python 3 and Set Up a LocalProgramming Environment on Windows 10Python is a versatile programming language that can be used for manydifferent programming projects. First published in 1991 with a nameinspired by the British comedy group Monty Python, the developmentteam wanted to make Python a language that was fun to use. Easy to setup, and written in a relatively straightforward style with immediatefeedback on errors, Python is a great choice for beginners andexperienced developers alike. Python 3 is the most current version of thelanguage and is considered to be the future of Python.This tutorial will guide you through installing Python 3 on your localWindows 10 machine and setting up a programming environment via thecommand line.PrerequisitesYou will need a Windows 10 computer with administrative access that isconnected to the internet.Step 1 — Opening and Conﬁguring PowerShellWe’ll be completing most of our installation and setup on a command-line interface, which is a non-graphical way to interact with yourcomputer. That is, instead of clicking on buttons, you’ll be typing in textand receiving feedback from your computer through text as well. Thecommand line, also known as a shell, can help you modify and automate
many of the tasks you do on a computer every day, and is an essentialtool for software developers.PowerShell is a program from Microsoft that provides a command-lineshell interface. Administrative tasks are performed by running cmdlets,which are pronounced command-lets, specialized classes of the .NETsoftware framework that can carry out operations. Open-sourced inAugust 2016, PowerShell is now available across platforms, for bothWindows and UNIX systems (including Mac and Linux).To ﬁnd Windows PowerShell, you can right-click on the Start menuicon on the lower left-hand corner of your screen. When the menu popsup, you should click on “Search,” then type “PowerShell” into the searchbar. When you are presented with options, right-click on “WindowsPowerShell,” the Desktop app. For our purposes, we’ll select “Run asAdministrator.” When you are prompted with a dialogue box that asks“Do you want to allow this app to make changes to your PC?” click on“Yes.”Once you do this, you’ll see a text-based interface that has a string ofwords that looks like this:
Windows 10 PowerShellWe can switch out of the system folder by typing the followingcommand:cd ~Then we’ll be in a directory such as PS C:\Users\Sammy.To continue with our installation process, we are going to set up somepermissions through PowerShell. Conﬁgured to run in the most securemode by default, there are a few levels of permissions that you can set upas an administrator:
Restricted is the default execution policy, under this mode you willnot be able to run scripts, and PowerShell will work only as aninteractive shell.AllSigned will enable you to run all scripts and conﬁguration ﬁlesthat are signed by a trusted publisher, meaning that you couldpotentially open your machine up to the risk of running maliciousscripts that happen to be signed by a trusted publisher.RemoteSigned will let you run scripts and conﬁguration ﬁlesdownloaded from the internet signed by trusted publishers, againopening your machine up to vulnerabilities if these trusted scriptsare actually malicious.Unrestricted will run all scripts and conﬁguration ﬁles downloadedfrom the internet as soon as you conﬁrm that you understand thatthe ﬁle was downloaded from the internet. In this case no digitalsignature is required so you could be opening your machine up tothe risk of running unsigned and potentially malicious scriptsdownloaded from the internet.We are going to use the RemoteSigned execution policy to set thepermission for the current user that allows the PowerShell to acceptdownloaded scripts that we trust without making the permissions asbroad as they would be with an Unrestricted permission. In thePowerShell, let’s type:Set-ExecutionPolicy -Scope CurrentUserPowerShell will then prompt us to provide an execution policy, andsince we want to use RemoteSigned, we’ll type:
RemoteSignedOnce we press enter we’ll be asked if we do want to change theexecution policy. Type the letter y for “yes,” and allow the changes totake effect. We can conﬁrm that this worked by asking for the currentpermissions across the machine by typing:Get-ExecutionPolicy -ListYou should receive output that looks something like this:Output        Scope ExecutionPolicy        ----- ---------------MachinePolicy       Undefined   UserPolicy       Undefined      Process       Undefined  CurrentUser    RemoteSigned LocalMachine       UndefinedThis conﬁrms that the current user can run trusted scripts downloadedfrom the internet. We can now move on to downloading the ﬁles we willneed to set up our Python programming environment.Step 2 — Installing the Package Manager ChocolateyA package manager is a collection of software tools that work toautomate installation processes that include the initial installation,upgrading and conﬁguring of software, and removing software as
needed. They keep software installations in a central location and canmaintain all software packages on the system in formats that arecommonly used.Chocolatey is a command-line package manager built for Windowsthat works like apt-get does on Linux. Available in an open-sourceversion, Chocolatey will help you quickly install applications and tools,and we will be using it to download what we need for our developmentenvironment.Before we install the script, let’s read it to conﬁrm that we are happywith the changes it will make to our machine. To do this, we will use the.NET scripting framework to download and display the Chocolateyscript within the terminal window. We’ll create a WebClient object called $script (you can call it whatever you want as long as you use $ as theﬁrst character), that shares Internet connection settings with InternetExplorer:$script = New-Object Net.WebClientLet’s look at the options that we have available to us by piping theobject to the Get-Member class to return all members (properties andmethods) of this WebClient object:$script | Get-MemberSnippet of Ouput . . .DownloadFileAsync         Method     void DownloadFileAsync(uri address, string fileName), void 
DownloadFileAsync(ur...DownloadFileTaskAsync     Method     System.Threading.Tasks.Task DownloadFileTaskAsync(string address, string fileNa...DownloadString            Method     string DownloadString(string address), string DownloadString(uri address) #method we will useDownloadStringAsync       Method     void DownloadStringAsync(uri address), void DownloadStringAsync(uri address, Sy...DownloadStringTaskAsync   Method     System.Threading.Tasks.Task[string] DownloadStringTaskAsync(string address), Sy… . . .Looking over the output, we can identify the DownloadStringmethod that we can use to display the script and signature in thePowerShell window. Let’s implement this method:$script.DownloadString("https://chocolatey.org/install.ps1")After we inspect the script, we can install Chocolatey by typing thefollowing into PowerShell:iwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex
The cmdlet iwr or Invoke-WebRequest allows us to extract datafrom the web. This will pass the script to the iex or Invoke-Expression cmdlet, which will execute the contents of the script,running the installation script for the Chocolatey package manager.Allow PowerShell to install Chocolatey. Once it is fully installed, wecan begin installing additional tools with the choco command.If we need to upgrade Chocolatey at any time in the future, we can runthe following command:choco upgrade chocolateyWith our package manager installed, we can go on to install the rest ofwhat we need for our Python 3 programming environment.Step 3 — Installing the Text Editor nano (Optional)We are now going to install nano, a text editor that uses a command lineinterface, which we can use to write programs directly withinPowerShell. This is not a compulsory step, as you can alternatively use atext editor with a graphical user interface such as Notepad, but nano willget us more accustomed to using PowerShell.Let’s use Chocolatey to install nano:choco install -y nanoHere we used the -y ﬂag so that we conﬁrm automatically that wewant to run the script without being prompted.Once nano is installed, we will be able to use the nano command tocreate new text ﬁles and will eventually use it to write our ﬁrst Python
program.Step 4 — Installing Python 3Just like we did with nano above, we will use Chocolatey to installPython 3:choco install -y python3PowerShell will now install Python 3, generating output withinPowerShell during that process.Once the process is completed, you should see the following output:OutputEnvironment Vars (like PATH) have changed. Close/reopen your shell to See the changes (or in powershell/cmd.exe just type 'refreshenv').The install of python3 was successful. Software installed as 'EXE', install location is likely default.Chocolatey installed 1/1 packages. 0 packages failed. See the log for details (C:\ProgramData\chocolatey\logs\chocolatey.log).With the installation is ﬁnished, you’ll want to conﬁrm that Python isinstalled and ready to go. To see the changes, use the command 
refreshenv or close and re-open PowerShell as an Administrator, thencheck the version of Python available to you on your local machine:python -VYou should get output such as:OutputPython 3.5.1Alongside Python, pip will be installed, which will manage softwarepackages for Python. Let’s ensure that pip is up-to-date by upgrading it:python -m pip install --upgrade pipWith Chocolatey, we can call Python 3 with the python command. Wewill use the -m ﬂag to run the library module as a script, terminating theoption list, and from there use pip to install its upgrade.Once Python is installed and pip updated, we can set up a virtualenvironment for our development projects.Step 5 — Setting Up a Virtual EnvironmentNow that we have Chocolatey, nano, and Python installed, we can go onto create our programming environment with the venv module.Virtual environments enable you to have an isolated space on yourcomputer for Python projects, ensuring that each of your projects canhave its own set of dependencies that won’t disrupt any of your otherprojects.
Setting up a programming environment provides us with greatercontrol over our Python projects and over how different versions ofpackages are handled. This is especially important when working withthird-party packages.You can set up as many Python programming environments as youwant. Each environment is basically a directory or folder in yourcomputer that has a few scripts in it to make it act as an environment.Choose which directory you would like to put your Pythonprogramming environments in, or create a new directory with mkdir, asin:mkdir Environmentscd EnvironmentsOnce you are in the directory where you would like the environmentsto live, you can create an environment by running the followingcommand:python -m venv my_envUsing the python command, we will run the venv library module tocreate the virtual environment that in this case we have called my_env.Essentially, venv sets up a new directory that contains a few itemswhich we can view with the ls command:ls my_envOutput
Mode                LastWriteTime         Length Name----                -------------         ------ ----d-----        8/22/2016   2:20 PM                Included-----        8/22/2016   2:20 PM                Libd-----        8/22/2016   2:20 PM                Scripts-a----        8/22/2016   2:20 PM            107 pyvenv.cfgTogether, these ﬁles work to make sure that your projects are isolatedfrom the broader context of your local machine, so that system ﬁles andproject ﬁles don’t mix. This is good practice for version control and toensure that each of your projects has access to the particular packagesthat it needs.To use this environment, you need to activate it, which you can do bytyping the following command that calls the activate script in the Scripts directory:my_env\Scripts\activateYour prompt will now be preﬁxed with the name of your environment,in this case it is called my_env:(my_env) PS C:\Users\Sammy\Environments>This preﬁx lets us know that the environment my_env is currentlyactive, meaning that when we create programs here they will use only
this particular environment’s settings and packages.Step 6 — Creating a Simple ProgramNow that we have our virtual environment set up, let’s create a simple“Hello, World!” program. This will make sure that our environment isworking and gives us the opportunity to become more familiar withPython if we aren’t already.To do this, we’ll open up nano and create a new ﬁle:(my_env) PS C:\Users\Sammy> nano hello.pyOnce the text ﬁle opens up in Terminal we’ll type out our program:print("Hello, World!")Exit nano by typing the control and x keys, and when prompted tosave the ﬁle press y then the enter key.Once you exit out of nano and return to your shell, let’s run theprogram:(my_env) PS C:\Users\Sammy> python hello.pyThe hello.py program that you just created should cause Terminal toproduce the following output:OutputHello, World!
To leave the environment, simply type the command deactivate andyou will return to your original directory.ConclusionCongratulations! At this point you should have a Python 3 programmingenvironment set up on your local Windows 10 machine and can begin acoding project!To set up Python 3 on another computer, follow the local programmingenvironment guides for Ubuntu 16.04, Debian 8, CentOS 7, or macOS.You can also read about installing Python and setting up a programmingenvironment on an Ubuntu 16.04 server, which is especially useful whenworking on development teams.With your local machine ready for software development, you cancontinue to learn more about coding in Python by following“Understanding Data Types in Python 3” and “How To Use Variables inPython 3”.
How To Install Python 3 and Set Up a LocalProgramming Environment on CentOS 7Python is a versatile programming language that can be used for manydifferent programming projects. First published in 1991 with a nameinspired by the British comedy group Monty Python, the developmentteam wanted to make Python a language that was fun to use. Easy to setup, and written in a relatively straightforward style with immediatefeedback on errors, Python is a great choice for beginners andexperienced developers alike. Python 3 is the most current version of thelanguage and is considered to be the future of Python.This tutorial will guide you through installing Python 3 on your localCentOS 7 machine and setting up a programming environment via thecommand line.PrerequisitesYou will need a CentOS 7 computer with a non-root superuser accountthat is connected to the internet.Step 1 — Preparing the SystemWe will be completing this installation through the command line. Ifyour CentOS 7 computer starts up with a Graphical User Interface (GUI)desktop, you can gain access to the command line interface through theMenu, by navigating to Applications, then Utilities, and then clicking onTerminal. If you need more guidance on the terminal, be sure to readthrough the article “An Introduction to the Linux Terminal.”
Before we begin with the installation, let’s make sure to update thedefault system applications to have the latest versions available.We will be using the open-source package manager tool yum, whichstands for Yellowdog Updater Modiﬁed. This is a commonly used toolfor working with software packages on Red Hat based Linux systemslike CentOS. It will let you easily install and update, as well as removesoftware packages on your computer.Let’s ﬁrst make sure that yum is up to date by running this command:sudo yum -y updateThe -y ﬂag is used to alert the system that we are aware that we aremaking changes, preventing the terminal from prompting us to conﬁrm.Next, we will install yum-utils, a collection of utilities and plugins thatextend and supplement yum:sudo yum -y install yum-utilsFinally, we’ll install the CentOS Development Tools, which are used toallow you to build and compile software from source code:sudo yum -y groupinstall developmentOnce everything is installed, our setup is in place and we can go on toinstall Python 3.Step 2 — Installing and Setting Up Python 3
CentOS is derived from RHEL (Red Hat Enterprise Linux), which hasstability as its primary focus. Because of this, tested and stable versionsof applications are what is most commonly found on the system and indownloadable packages, so on CentOS you will only ﬁnd Python 2.Since instead we would like to install the most current upstream stablerelease of Python 3, we will need to install IUS, which stands for Inlinewith Upstream Stable. A community project, IUS provides Red HatPackage Manager (RPM) packages for some newer versions of selectsoftware.To install IUS, let’s install it through yum:sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpmOnce IUS is ﬁnished installing, we can install the most recent versionof Python:sudo yum -y install python36uWhen the installation process of Python is complete, we can check tomake sure that the installation was successful by checking for its versionnumber with the python3.6 command:python3.6 -VWith a version of Python 3.6 successfully installed, we will receive thefollowing output:
OutputPython 3.6.1We will next install pip, which will manage software packages forPython:sudo yum -y install python36u-pipA tool for use with Python, we will use pip to install and manageprogramming packages we may want to use in our developmentprojects. You can install Python packages by typing:sudo pip3.6 install package_nameHere, package_name can refer to any Python package or library, suchas Django for web development or NumPy for scientiﬁc computing. So ifyou would like to install NumPy, you can do so with the command pip3.6 install numpy.Finally, we will need to install the IUS package python36u-devel,which provides us with libraries and header ﬁles we will need for Python3 development:sudo yum -y install python36u-develThe venv module will be used to set up a virtual environment for ourdevelopment projects in the next step.Step 3 — Setting Up a Virtual Environment
Now that we have Python installed and our system set up, we can go onto create our programming environment with venv.Virtual environments enable you to have an isolated space on yourcomputer for Python projects, ensuring that each of your projects canhave its own set of dependencies that won’t disrupt any of your otherprojects.Setting up a programming environment provides us with greatercontrol over our Python projects and over how different versions ofpackages are handled. This is especially important when working withthird-party packages.You can set up as many Python programming environments as youwant. Each environment is basically a directory or folder in yourcomputer that has a few scripts in it to make it act as an environment.Choose which directory you would like to put your Pythonprogramming environments in, or create a new directory with mkdir, asin:mkdir environmentscd environmentsOnce you are in the directory where you would like the environmentsto live, you can create an environment by running the followingcommand:python3.6 -m venv my_envEssentially, this command creates a new directory (in this case calledmy_env) that contains a few items that we can see with the ls command:
bin include lib lib64 pyvenv.cfgTogether, these ﬁles work to make sure that your projects are isolatedfrom the broader context of your local machine, so that system ﬁles andproject ﬁles don’t mix. This is good practice for version control and toensure that each of your projects has access to the particular packagesthat it needs.To use this environment, you need to activate it, which you can do bytyping the following command that calls the activate script in the bindirectory:source my_env/bin/activateYour prompt will now be preﬁxed with the name of your environment,in this case it is called my_env:(my_env) [sammy@localhost] environments]$This preﬁx lets us know that the environment my_env is currentlyactive, meaning that when we create programs here they will use onlythis particular environment’s settings and packages.Note: Within the virtual environment, you can use the command python instead of python3.6, and pip instead of pip3.6 if you wouldprefer. If you use Python 3 on your machine outside of an environment,you will need to use the python3.6 and pip3.6 commands exclusively.After following these steps, your virtual environment is ready to use.Step 4 — Creating a Simple Program
Now that we have our virtual environment set up, let’s create a simple“Hello, World!” program. This will make sure that our environment isworking and gives us the opportunity to become more familiar withPython if we aren’t already.To do this, we’ll open up a command-line text editor such as vim andcreate a new ﬁle:(my_env) [sammy@localhost] environments]$ vi hello.pyOnce the text ﬁle opens up in our terminal window, we will have totype i to enter insert mode, and then we can write our ﬁrst program:print("Hello, World!")Now press ESC to leave insert mode. Next, type :x then ENTER to saveand exit the ﬁle.We are now ready to run our program:(my_env) [sammy@localhost] environments]$ python hello.pyThe hello.py program that you just created should cause the terminalto produce the following output:OutputHello, World!
To leave the environment, simply type the command deactivate andyou’ll return to your original directory.ConclusionCongratulations! At this point you have a Python 3 programmingenvironment set up on your local CentOS 7 machine and can begin acoding project!To set up Python 3 on another computer, follow the local programmingenvironment guides for Ubuntu 16.04, Debian 8, macOS, or Windows 10.You can also read about installing Python and setting up a programmingenvironment on an Ubuntu 16.04 server, which is especially useful whenworking on development teams.With your local machine ready for software development, you cancontinue to learn more about coding in Python by following“Understanding Data Types in Python 3” and “How To Use Variables inPython 3”.
How To Install Python 3 and Set Up aProgramming Environment on an Ubuntu16.04 ServerThis tutorial will get your Ubuntu 16.04 or Debian 8 server set up with aPython 3 programming environment. Programming on a server hasmany advantages and makes it easier for teams to collaborate on adevelopment project. The general principles of this tutorial will apply toany distribution of Debian Linux.Python is a versatile programming language that can be used for manydifferent programming projects. First published in 1991 with a nameinspired by the British comedy group Monty Python, the developmentteam wanted to make Python a language that was fun to use. Easy to setup, and written in a relatively straightforward style with immediatefeedback on errors, Python is a great choice for beginners andexperienced developers alike. Python 3 is the most current version of thelanguage and is considered to be the future of Python.This tutorial will guide you through installing Python 3 on a DebianLinux server and setting up a programming environment.PrerequisitesBefore you begin, you’ll need a server with Ubuntu 16.04, Debian 8, oranother version of Debian Linux installed. You’ll also need a sudo non-root user, which you can set up by following one of the tutorials below:Initial Server Setup with Ubuntu 16.04Initial Server Setup with Debian 8
If you’re not already familiar with a terminal environment, you mayﬁnd the article “An Introduction to the Linux Terminal” useful forbecoming better oriented with the terminal.Step 1 — Setting Up Python 3Ubuntu 16.04, Debian 8, and other versions of Debian Linux ship withboth Python 3 and Python 2 pre-installed. To make sure that our versionsare up-to-date, let’s update and upgrade the system with apt-get:sudo apt-get updatesudo apt-get -y upgradeThe -y ﬂag will conﬁrm that we are agreeing for all items to beinstalled, but depending on your version of Linux, you may need toconﬁrm additional prompts as your system updates and upgrades.Once the process is complete, we can check the version of Python 3that is installed in the system by typing:python3 -VYou’ll receive output in the terminal window that will let you knowthe version number. The version number may vary depending onwhether you are on Ubuntu 16.04, Debian 8, or another version of Linux,but it will look similar to this:OutputPython 3.5.2
To manage software packages for Python, let’s install pip:sudo apt-get install -y python3-pipA tool for use with Python, pip installs and manages programmingpackages we may want to use in our development projects. You caninstall Python packages by typing:pip3 install package_nameHere, package_name can refer to any Python package or library, suchas Django for web development or NumPy for scientiﬁc computing. So ifyou would like to install NumPy, you can do so with the command pip3 install numpy.There are a few more packages and development tools to install toensure that we have a robust set-up for our programming environment:sudo apt-get install build-essential libssl-dev libffi-dev python3-devOnce Python is set up, and pip and other tools are installed, we can setup a virtual environment for our development projects.Step 2 — Setting Up a Virtual EnvironmentVirtual environments enable you to have an isolated space on your serverfor Python projects, ensuring that each of your projects can have its ownset of dependencies that won’t disrupt any of your other projects.
Setting up a programming environment provides us with greatercontrol over our Python projects and over how different versions ofpackages are handled. This is especially important when working withthird-party packages.You can set up as many Python programming environments as youwant. Each environment is basically a directory or folder on your serverthat has a few scripts in it to make it act as an environment.We need to ﬁrst install the venv module, part of the standard Python 3library, so that we can invoke the pyvenv command which will createvirtual environments for us. Let’s install venv by typing:sudo apt-get install -y python3-venvWith this installed, we are ready to create environments. Let’s choosewhich directory we would like to put our Python programmingenvironments in, or we can create a new directory with mkdir, as in:mkdir environmentscd environmentsOnce you are in the directory where you would like the environmentsto live, you can create an environment by running the followingcommand:pyvenv my_envEssentially, pyvenv sets up a new directory that contains a few itemswhich we can view with the ls command:
ls my_envOutputbin include lib lib64 pyvenv.cfg shareTogether, these ﬁles work to make sure that your projects are isolatedfrom the broader context of your local machine, so that system ﬁles andproject ﬁles don’t mix. This is good practice for version control and toensure that each of your projects has access to the particular packagesthat it needs. Python Wheels, a built-package format for Python that canspeed up your software production by reducing the number of times youneed to compile, will be in the Ubuntu 16.04 share directory but inDebian 8 it will be in each of the lib directories as there is no sharedirectory.To use this environment, you need to activate it, which you can do bytyping the following command that calls the activate script:source my_env/bin/activateYour prompt will now be preﬁxed with the name of your environment,in this case it is called my_env. Depending on what version of DebianLinux you are running, your preﬁx may look somewhat different, but thename of your environment in parentheses should be the ﬁrst thing yousee on your line:(my_env) sammy@ubuntu:~/environments$
This preﬁx lets us know that the environment my_env is currentlyactive, meaning that when we create programs here they will use onlythis particular environment’s settings and packages.Note: Within the virtual environment, you can use the command python instead of python3, and pip instead of pip3 if you wouldprefer. If you use Python 3 on your machine outside of an environment,you will need to use the python3 and pip3 commands exclusively.After following these steps, your virtual environment is ready to use.Step 3 — Creating a Simple ProgramNow that we have our virtual environment set up, let’s create a simple“Hello, World!” program. This will make sure that our environment isworking and gives us the opportunity to become more familiar withPython if we aren’t already.To do this, we’ll open up a command-line text editor such as nano andcreate a new ﬁle:(my_env) sammy@ubuntu:~/environments$ nano hello.pyOnce the text ﬁle opens up in the terminal window we’ll type out ourprogram:print("Hello, World!")Exit nano by typing the control and x keys, and when prompted tosave the ﬁle press y.Once you exit out of nano and return to your shell, let’s run theprogram:
(my_env) sammy@ubuntu:~/environments$ python hello.pyThe hello.py program that you just created should cause your terminalto produce the following output:OutputHello, World!To leave the environment, simply type the command deactivate andyou will return to your original directory.ConclusionCongratulations! At this point you have a Python 3 programmingenvironment set up on your Debian Linux server and you can now begina coding project!To set up Python 3 on another computer, follow the local programmingenvironment guides for Ubuntu 16.04, Debian 8, Windows 10, or macOS.With your server set up for software development, you can continue tolearn more about coding in Python by following “Understanding DataTypes in Python 3” and “How To Use Variables in Python 3”.
How To Write Your First Python 3 ProgramThe “Hello, World!” program is a classic and time-honored tradition incomputer programming. Serving as a simple and complete ﬁrst programfor beginners, as well as a good program to test systems andprogramming environments, “Hello, World!” illustrates the basic syntaxof programming languages.This tutorial will walk you through writing a “Hello, World” programin Python 3.PrerequisitesYou should have Python 3 installed as well as a local programmingenvironment set up on your computer.If you don’t have one set up, you can use one of the installation andsetup guides below that is appropriate for your operating system:Ubuntu 16.04 or Debian 8CentOS 7Mac OS XWindows 10Writing the “Hello, World!” ProgramTo write the “Hello, World!” program, let’s open up a command-line texteditor such as nano and create a new ﬁle:nano hello.py
Once the text ﬁle opens up in the terminal window we’ll type out ourprogram:hello.pyprint("Hello, World!")Let’s break down the different components of the code.print() is a function that tells the computer to perform an action. Weknow it is a function because it uses parentheses. print() tells Pythonto display or output whatever we put in the parentheses. By default, thiswill output to the current terminal window.Some functions, like the print() function, are built-in functionsincluded in Python by default. These built-in functions are alwaysavailable for us to use in programs that we create. We can also deﬁne ourown functions that we construct ourselves through other elements.Inside the parentheses of the print() function is a sequence ofcharacters — Hello, World! — that is enclosed in quotation marks.Any characters that are inside of quotation marks are called a string.Once we are done writing our program, we can exit nano by typing thecontrol and x keys, and when prompted to save the ﬁle press y.Once you exit out of nano you’ll return to your shell.Running the “Hello, World!” ProgramWith our “Hello, World!” program written, we are ready to run theprogram. We’ll use the python3 command along with the name of ourprogram ﬁle. Let’s run the program:python3 hello.py
The hello.py program that you just created will cause your terminal toproduce the following output:OutputHello, World!Let’s go over what the program did in more detail.Python executed the line print("Hello, World!") by calling the print() function. The string value of Hello, World! was passed tothe function.In this example, the string Hello, World! is also called an argumentsince it is a value that is passed to a function.The quotes that are on either side of Hello, World! were notprinted to the screen because they are used to tell Python that theycontain a string. The quotation marks delineate where the string beginsand ends.Since the program ran, you can now conﬁrm that Python 3 is properlyinstalled and that the program is syntactically correct.ConclusionCongratulations! You have written the “Hello, World!” program inPython 3.From here, you can continue to work with the print() function bywriting your own strings to display, and can also create new programﬁles.Keep learning about programming in Python by reading our fulltutorial series How To Code in Python 3.
How To Work with the Python InteractiveConsoleThe Python interactive console (also called the Python interpreter orPython shell) provides programmers with a quick way to executecommands and try out or test code without creating a ﬁle.Providing access to all of Python’s built-in functions and any installedmodules, command history, and auto-completion, the interactive consoleoffers the opportunity to explore Python and the ability to paste codeinto programming ﬁles when you are ready.This tutorial will go over how to work with the Python interactiveconsole and leverage it as a programming tool.Entering the Interactive ConsoleThe Python interactive console can be accessed from any local computeror server with Python installed.The command you generally will want to use to enter into the Pythoninteractive console for your default version of Python is:pythonIf you have set up a programming environment, you can launch theenvironment and access the version of Python and modules you haveinstalled in that environment by ﬁrst entering into that environment:cd environments
. my_env/bin/activateThen typing the python command:(my_env) sammy@ubuntu:~/environments$ pythonIn this case, the default version of Python is Python 3.5.2, which isdisplayed in the output once we enter the command, along with therelevant copyright notice and some commands you can type for extrainformation:OutputPython 3.5.2 (default, Nov 17 2016, 17:05:23)[GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.>>>The primary prompt for the next command is three greater-than signs(>>>):>>>You can target speciﬁc versions of Python by appending the versionnumber to your command, with no spaces:python2.7
OutputPython 2.7.12 (default, Nov 19 2016, 06:48:10)[GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.>>>Here, we received the output that Python 2.7.12 will be used. If this isour default version of Python 2, we could also have entered into thisinteractive console with the command python2.Alternatively, we can call the default Python 3 version with thefollowing command:python3OutputPython 3.5.2 (default, Nov 17 2016, 17:05:23)[GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.>>>We could have also called the above interactive console with thecommand python3.5.With the Python interactive console running, we can move ontoworking with the shell environment for Python.Working with the Python Interactive Console
The Python interactive interpreter accepts Python syntax, which youplace following the >>> preﬁx.We can, for example, assign values to variables:>>> birth_year = 1868Once we have assigned the integer value of 1868 to the variable birth_year, we will press return and receive a new line with the threegreater-than signs as a preﬁx:>>> birth_year = 1868We can continue to assign variables and then perform math withoperators to get calculations returned:>>> birth_year = 1868>>> death_year = 1921>>> age_at_death = death_year - birth_year>>> print(age_at_death)53>>>As we would with a script in a ﬁle, we assigned variables, subtractedone variable from the other, and asked the console to print the variablethat represents the difference.Just like in any form of Python, you can also use the interactive consoleas a calculator:
>>> 203 / 2010.15>>>Here, we divided the integer 203 by 20 and were returned thequotient of 10.15.Multiple LinesWhen we are writing Python code the will cover multiple lines, theinterpreter will use the secondary prompt for continuation lines, threedots (...).To break out of these continuation lines, you will need to press ENTERtwice.We can see what this looks like in the following code that assigns twovariables and then uses a conditional statement to determine what toprint out to the console:>>> sammy = 'Sammy'>>> shark = 'Shark'>>> if len(sammy) > len(shark):...     print('Sammy codes in Java.')... else:...     print('Sammy codes in Python.')...Sammy codes in Python.>>>
In this case the lengths of the two strings are equal, so the elsestatement prints. Note that you will need to keep Python indentingconvention of four whitespaces, otherwise you will receive an error:>>> if len(sammy) > len(shark):... print('Sammy codes in Java.')  File "<stdin>", line 2    print('Sammy codes in Java.')        ^IndentationError: expected an indented block>>>You can not only experiment with code across multiple lines in thePython console, you can also import modules.Importing ModulesThe Python interpreter provides a quick way for you to check to see ifmodules are available in a speciﬁc programming environment. You cando this by using the import statement:>>> import matplotlibTraceback (most recent call last):  File "<stdin>", line 1, in <module>ImportError: No module named 'matplotlib'In the case above, the module matplotlib was not available within thecurrent programming environment.
In order to install it, we’ll need to leave the interactive interpreter andinstall with pip as usual:(my_env) sammy@ubuntu:~/environments$ pip install matplotlibOutputCollecting matplotlib  Downloading matplotlib-2.0.2-cp35-cp35m-manylinux1_x86_64.whl (14.6MB)...Installing collected packages: pyparsing, cycler, python-dateutil, numpy, pytz, matplotlibSuccessfully installed cycler-0.10.0 matplotlib-2.0.2 numpy-1.13.0 pyparsing-2.2.0 python-dateutil-2.6.0 pytz-2017.2Once the matplotlib module along with its dependencies aresuccessfully installed, you can go back into the interactive interpreter:(my_env) sammy@ubuntu:~/environments$ python>>> import matplotlibAt this point you will receive no error message and can use theinstalled module either within the shell or within a ﬁle.Leaving the Python Interactive Console
There are two main ways to leave the Python interactive console, eitherwith a keyboard shortcut or a Python function.The keyboard shortcut CTRL + D in *nix-based systems or CTRL + Zthen the CTRL key in Windows systems will interrupt your console andreturn you to your original terminal environment:...>>> age_at_death = death_year - birth_year>>> print(age_at_death)53>>>sammy@ubuntu:~/environments$Alternatively, the Python function quit() will quit out of theinteractive console and also bring you back to the original terminalenvironment that you were previously in:>>> octopus = 'Ollie'>>> quit()sammy@PythonUbuntu:~/environments$When you use the function quit(), it will show up in your historyﬁle, but the keyboard shortcut CTRL + D will not be recorded:File: /home/sammy/.python_history...age_at_death = death_year - birth_yearprint(age_at_death)
octopus = 'Ollie'quit()Quitting the Python interpreter can be done either way, depending onwhat makes sense for your workﬂow and your history needs.Accessing HistoryOne of the useful things about the Python interactive console is that all ofyour commands are logged to the .python_history ﬁle in *nix-basedsystems, which you can look at in a text editor like nano, for instance:nano ~/.python_historyOnce opened with a text editor, your Python history ﬁle will looksomething like this, with your own Python command history:File: /home/sammy/.python_historyimport pygamequit()if 10 > 5:    print("hello, world")else:    print("nope")sammy = 'Sammy'shark = 'Shark'...
Once you are done with your ﬁle, you can press CTRL + X to leavenano.By keeping track of all of your Python history, you can go back toprevious commands and experiments, and copy and paste or modify thatcode for use in Python programming ﬁles or in a Jupyter Notebook.ConclusionThe Python interactive console provides a space to experiment withPython code. You can use it as a tool for testing, working out logic, andmore.For use with debugging Python programming ﬁles, you can use thePython code module to open up an interactive interpreter within a ﬁle,which you can read about in our guide How To Debug Python with anInteractive Console.
How To Write CommentsComments are lines that exist in computer programs that are ignored bycompilers and interpreters. Including comments in programs makes codemore readable for humans as it provides some information orexplanation about what each part of a program is doing.Depending on the purpose of your program, comments can serve asnotes to yourself or reminders, or they can be written with the intentionof other programmers being able to understand what your code is doing.In general, it is a good idea to write comments while you are writing orupdating a program as it is easy to forget your thought process later on,and comments written later may be less useful in the long term.Comment SyntaxComments in Python begin with a hash mark (#) and whitespacecharacter and continue to the end of the line.Generally, comments will look something like this:# This is a commentBecause comments do not execute, when you run a program you willnot see any indication of the comment there. Comments are in the sourcecode for humans to read, not for computers to execute.In a “Hello, World!” program, a comment may look like this:hello.py
# Print “Hello, World!” to consoleprint("Hello, World!")In a for loop that iterates over a list, comments may look like this:sharks.py# Define sharks variable as a list of stringssharks = ['hammerhead', 'great white', 'dogfish', 'frilled', 'bullhead', 'requiem']# For loop that iterates over sharks list and prints each string itemfor shark in sharks:   print(shark)Comments should be made at the same indent as the code it iscommenting. That is, a function deﬁnition with no indent would have acomment with no indent, and each indent level following would havecomments that are aligned with the code it is commenting.For example, here is how the again() function from the How ToMake a Simple Calculator Program in Python 3 tutorial is commented,with comments following each indent level of the code:calculator.py...# Define again() function to ask user if they want to use the calculator againdef again():
    # Take input from user    calc_again = input('''Do you want to calculate again?Please type Y for YES or N for NO.''')    # If user types Y, run the calculate() function    if calc_again == 'Y':        calculate()    # If user types N, say good-bye to the user and end the program    elif calc_again == 'N':        print('See you later.')    # If user types another key, run the function again    else:        again()Comments are made to help programmers, whether it is the originalprogrammer or someone else using or collaborating on the project. Ifcomments cannot be properly maintained and updated along with thecode base, it is better to not include a comment rather than write acomment that contradicts or will contradict the code.When commenting code, you should be looking to answer the whybehind the code as opposed to the what or how. Unless the code is
particularly tricky, looking at the code can generally tell what the code isdoing or how it is doing it.Block CommentsBlock comments can be used to explain more complicated code or codethat you don’t expect the reader to be familiar with. These longer-formcomments apply to some or all of the code that follows, and are alsoindented at the same level as the code.In block comments, each line begins with the hash mark and a singlespace. If you need to use more than one paragraph, they should beseparated by a line that contains a single hash mark.Here is an example of a block comment that deﬁnes what is happeningin the main() function deﬁned below:# The main function will parse arguments via the parser variable.  These# arguments will be defined by the user on the console.  This will pass# the word argument the user wants to parse along with the filename the# user wants to use, and also provide help text if the user does not# correctly pass the arguments.def main():  parser = argparse.ArgumentParser()  parser.add_argument(      "word",
      help="the word to be searched for in the text file."  )  parser.add_argument(      "filename",      help="the path to the text file to be searched through"  )...Block comments are typically used when operations are lessstraightforward and are therefore demanding of a thorough explanation.You should try to avoid over-commenting the code and should tend totrust other programmers to understand Python unless you are writingfor a particular audience.Inline CommentsInline comments occur on the same line of a statement, following thecode itself. Like other comments, they begin with a hash mark and asingle whitespace character.Generally, inline comments look like this:[code]  # Inline comment about the codeInline comments should be used sparingly, but can be effective forexplaining tricky or non-obvious parts of code. They can also be useful ifyou think you may not remember a line of the code you are writing in the
future, or if you are collaborating with someone who you know may notbe familiar with all aspects of the code.For example, if you don’t use a lot of math in your Python programs,you or your collaborators may not know that the following creates acomplex number, so you may want to include an inline comment aboutthat:z = 2.5 + 3j  # Create a complex numberInline comments can also be used to explain the reason behind doingsomething, or some extra information, as in:x = 8  # Initialize x with an arbitrary numberComments that are made in line should be used only when necessaryand when they can provide helpful guidance for the person reading theprogram.Commenting Out Code for TestingIn addition to using comments as a way to document code, the hashmark can also be used to comment out code that you don’t want toexecute while you are testing or debugging a program you are currentlycreating. That is, when you experience errors after implementing newlines of code, you may want to comment a few of them out to see if youcan troubleshoot the precise issue.Using the hash mark can also allow you to try alternatives while you’redetermining how to set up your code. For example, you may be decidingbetween using a while loop or a for loop in a Python game, and can
comment out one or the other while testing and determining which onemay be best:guess.pyimport randomnumber = random.randint(1, 25)# number_of_guesses = 0for i in range(5):# while number_of_guesses < 5:    print('Guess a number between 1 and 25:')    guess = input()    guess = int(guess)    # number_of_guesses = number_of_guesses + 1    if guess < number:        print('Your guess is too low')    if guess > number:        print('Your guess is too high')    if guess == number:        breakif guess == number:
    print('You guessed the number!')else:    print('You did not guess the number. The number was ' + str(number))<figure class="code">Commenting out code with the hash mark can allow you to try outdifferent programming methods as well as help you ﬁnd the source of anerror through systematically commenting out and running parts of aprogram.ConclusionUsing comments within your Python programs helps to make yourprograms more readable for humans, including your future self.Including appropriate comments that are relevant and useful can make iteasier for others to collaborate with you on programming projects andmake the value of your code more obvious.From here, you may want to read about Python’s Docstrings in PEP257 to provide you with more resources to properly document yourPython projects.
Understanding Data TypesIn Python, like in all programming languages, data types are used toclassify one particular type of data. This is important because the speciﬁcdata type you use will determine what values you can assign to it andwhat you can do to it (including what operations you can perform on it).In this tutorial, we will go over the important data types native toPython. This is not an exhaustive investigation of data types, but willhelp you become familiar with what options you have available to you inPython.BackgroundOne way to think about data types is to consider the different types ofdata that we use in the real world. An example of data in the real worldare numbers: we may use whole numbers (0, 1, 2, …), integers (…, -1, 0,1, …), and irrational numbers (ۛ), for example.Usually, in math, we can combine numbers from different types, andget some kind of an answer. We may want to add 5 to ۛ, for example:5 + πWe can either keep the equation as the answer to account for theirrational number, or round ۛ to a number with a brief number ofdecimal places, and then add the numbers together:5 + π = 5 + 3.14 = 8.14
But, if we start to try to evaluate numbers with another data type, suchas words, things start to make less sense. How would we solve for thefollowing equation?sky + 8For computers, each data type can be thought of as being quitedifferent, like words and numbers, so we will have to be careful abouthow we use them to assign values and how we manipulate them throughoperations.NumbersAny number you enter in Python will be interpreted as a number; youare not required to declare what kind of data type you are entering.Python will consider any number written without decimals as an integer(as in 138) and any number written with decimals as a ﬂoat (as in 138.0).IntegersLike in math, integers in computer programming are whole numbers thatcan be positive, negative, or 0 (…, -1, 0, 1, …). An integer can also beknown as an int. As with other programming languages, you shouldnot use commas in numbers of four digits or more, so when you write1,000 in your program, write it as 1000.We can print out an integer in a simple way like this:print(-25)
Output-25Or, we can declare a variable, which in this case is essentially a symbolof the number we are using or manipulating, like so:my_int = -25print(my_int)Output-25We can do math with integers in Python, too:int_ans = 116 - 68print(int_ans)Output48Integers can be used in many ways within Python programs, and asyou continue to learn more about the language you will have a lot ofopportunities to work with integers and understand more about this datatype.Floating-Point NumbersA ﬂoating-point number or a ﬂoat is a real number, meaning that it canbe either a rational or an irrational number. Because of this, ﬂoating-point
numbers can be numbers that can contain a fractional part, such as 9.0or -116.42. Simply speaking, for the purposes of thinking of a float ina Python program, it is a number that contains a decimal point.Like we did with the integer, we can print out a ﬂoating-point numberin a simple way like this:print(17.3)Output17.3We can also declare a variable that stands in for a ﬂoat, like so:my_flt = 17.3print(my_flt)Output17.3And, just like with integers, we can do math with ﬂoats in Python, too:flt_ans = 564.0 + 365.24print(flt_ans)Output929.24
With integers and ﬂoating-point numbers, it is important to keep inmind that 3 ≠ 3.0, as 3 refers to an integer while 3.0 refers to a ﬂoat.BooleansThe Boolean data type can be one of two values, either True or False.Booleans are used to represent the truth values that are associated withthe logic branch of mathematics, which informs algorithms in computerscience.Whenever you see the data type Boolean, it will start with a capitalizedB because it is named for the mathematician George Boole. The values True and False will also always be with a capital T and F respectively,as they are special values in Python.Many operations in math give us answers that evaluate to either Trueor False:greater than500 > 100 True1 > 5 Falseless than200 < 400 True4 < 2 Falseequal5 = 5 True500 = 400 False
Like with numbers, we can store a Boolean value in a variable:my_bool = 5 > 8We can then print the Boolean value with a call to the print()function:print(my_bool)Since 5 is not greater than 8, we will receive the following output:OuputFalseAs you write more programs in Python, you will become more familiarwith how Booleans work and how different functions and operationsevaluating to either True or False can change the course of the program.StringsA string is a sequence of one or more characters (letters, numbers,symbols) that can be either a constant or a variable. Strings exist withineither single quotes ' or double quotes " in Python, so to create a string,enclose a sequence of characters in quotes:'This is a string in single quotes.'"This is a string in double quotes."
You can choose to use either single quotes or double quotes, butwhichever you decide on you should be consistent within a program.The simple program “Hello, World!” demonstrates how a string can beused in computer programming, as the characters that make up thephrase Hello, World! are a string.print("Hello, World!")As with other data types, we can store strings in variables:hw = "Hello, World!"And print out the string by calling the variable:print(hw)OuputHello, World!Like numbers, there are many operations that we can perform onstrings within our programs in order to manipulate them to achieve theresults we are seeking. Strings are important for communicatinginformation to the user, and for the user to communicate informationback to the program.ListsA list is a mutable, or changeable, ordered sequence of elements. Eachelement or value that is inside of a list is called an item. Just as strings are
deﬁned as characters between quotes, lists are deﬁned by having valuesbetween square brackets [ ].A list of integers looks like this:[-3, -2, -1, 0, 1, 2, 3]A list of ﬂoats looks like this:[3.14, 9.23, 111.11, 312.12, 1.05]A list of strings:['shark', 'cuttlefish', 'squid', 'mantis shrimp']If we deﬁne our string list as sea_creatures:sea_creatures = ['shark', 'cuttlefish', 'squid', 'mantis shrimp']We can print them out by calling the variable:print(sea_creatures)And we see that the output looks exactly like the list that we created:Output['shark', 'cuttlefish', 'squid', 'mantis shrimp']
Lists are a very ﬂexible data type because they are mutable in that theycan have values added, removed, and changed. There is a data type thatis similar to lists but that can’t be changed, and that is called a tuple.TuplesA tuple is used for grouping data. It is an immutable, or unchangeable,ordered sequence of elements.Tuples are very similar to lists, but they use parentheses ( ) instead ofsquare brackets and because they are immutable their values cannot bemodiﬁed.A tuple looks like this:('blue coral', 'staghorn coral', 'pillar coral')We can store a tuple in a variable and print it out:coral = ('blue coral', 'staghorn coral', 'pillar coral')print(coral)Ouput('blue coral', 'staghorn coral', 'pillar coral')Like in the other data types, Python prints out the tuple just as we hadtyped it, with parentheses containing a sequence of values.Dictionaries
The dictionary is Python’s built-in mapping type. This means thatdictionaries map keys to values and these key-value pairs are a usefulway to store data in Python. A dictionary is constructed with curly braceson either side { }.Typically used to hold data that are related, such as the informationcontained in an ID, a dictionary looks like this:{'name': 'Sammy', 'animal': 'shark', 'color': 'blue', 'location': 'ocean'}You will notice that in addition to the curly braces, there are also colonsthroughout the dictionary. The words to the left of the colons are thekeys. Keys can be made up of any immutable data type. The keys in thedictionary above are: 'name', 'animal', 'color', 'location'.The words to the right of the colons are the values. Values can becomprised of any data type. The values in the dictionary above are: 'Sammy', 'shark', 'blue', 'ocean'.Like the other data types, let’s store the dictionary inside a variable,and print it out:sammy = {'name': 'Sammy', 'animal': 'shark', 'color': 'blue',  'location': 'ocean'}print(sammy)Ouput{'color': 'blue', 'animal': 'shark', 'name': 'Sammy', 'location': 'ocean'}
If we want to isolate Sammy’s color, we can do so by calling sammy['color']. Let’s print that out:print(sammy['color'])OutputblueAs dictionaries offer key-value pairs for storing data, they can beimportant elements in your Python program.ConclusionAt this point, you should have a better understanding of some of themajor data types that are available for you to use in Python. Each of thesedata types will become important as you develop programming projectsin the Python language.You can learn about each of the data types above in more detail byreading the following speciﬁc tutorials: - Numbers - Booleans - Strings -Lists - Tuples - DictionariesOnce you have a solid grasp of data types available to you in Python,you can learn how to convert data types.
An Introduction to Working with StringsA string is a sequence of one or more characters (letters, numbers,symbols) that can be either a constant or a variable. Made up of Unicode,strings are immutable sequences, meaning they are unchanging.Because text is such a common form of data that we use in everydaylife, the string data type is a very important building block ofprogramming.This Python tutorial will go over how to create and print strings, howto concatenate and replicate strings, and how to store strings in variables.Creating and Printing StringsStrings exist within either single quotes ' or double quotes " in Python,so to create a string, enclose a sequence of characters in one or the other:'This is a string in single quotes.'"This is a string in double quotes."You can choose to use either single quotes or double quotes, butwhichever you decide on you should be consistent within a program.We can print out strings by simply calling the print() function:print("Let's print out this string.")Output
Let's print out this string.With an understanding of how strings are formatted in Python, let’stake a look at how we can work with and manipulate strings inprograms.String ConcatenationConcatenation means joining strings together end-to-end to create a newstring. To concatenate strings, we use the + operator. Keep in mind thatwhen we work with numbers, + will be an operator for addition, butwhen used with strings it is a joining operator.Let’s combine the strings "Sammy" and "Shark" together withconcatenation through a print() statement:print("Sammy" + "Shark")OutputSammySharkIf we would like a whitespace between the two strings, we can simplyinclude the whitespace within a string, like after the word “Sammy”:print("Sammy " + "Shark")OutputSammy Shark
Be sure not to use the + operator between two different data types. Wecan’t concatenate strings and integers together, for instance. So, if we tryto write:print("Sammy" + 27)We will receive the following error:OutputTypeError: Can't convert 'int' object to str implicitlyIf we wanted to create the string "Sammy27", we could do so byputting the number 27 in quotes ("27") so that it is no longer an integerbut is instead a string. Converting numbers to strings for concatenationcan be useful when dealing with zip codes or phone numbers, forexample, as we don’t want to perform addition between a country codeand an area code, but we do want them to stay together.When we combine two or more strings through concatenation we arecreating a new string that we can use throughout our program.String ReplicationThere may be times when you need to use Python to automate tasks, andone way you may do this is through repeating a string several times. Youcan do so with the * operator. Like the + operator, the * operator has adifferent use when used with numbers, where it is the operator formultiplication. When used with one string and one integer, * is the string
replication operator, repeating a single string however many times youwould like through the integer you provide.Let’s print out “Sammy” 9 times without typing out “Sammy” 9 timeswith the * operator:print("Sammy" * 9)OutputSammySammySammySammySammySammySammySammySammyWith string replication, we can repeat the single string value theamount of times equivalent to the integer value.Storing Strings in VariablesVariables are symbols that you can use to store data in a program. Youcan think of them as an empty box that you ﬁll with some data or value.Strings are data, so we can use them to ﬁll up a variable. Declaringstrings as variables can make it easier for us to work with stringsthroughout our Python programs.To store a string inside a variable, we simply need to assign a variableto a string. In this case let’s declare my_str as our variable:my_str = "Sammy likes declaring strings."Now that we have the variable my_str set to that particular string, wecan print the variable like so:print(my_str)
And we will receive the following output:OutputSammy likes declaring strings.By using variables to stand in for strings, we do not have to retype astring each time we want to use it, making it simpler for us to work withand manipulate strings within our programs.ConclusionThis tutorial went over the basics of working with the string data type inthe Python 3 programming language. Creating and printing strings,concatenating and replicating strings, and storing strings in variables willprovide you with the fundamentals to use strings in your Python 3programs.Continue learning more about strings by taking a look at the followingtutorials: - How To Format Text in Python 3 - An Introduction to StringFunctions - How To Index and Slice Strings - How To Use StringFormatters
How To Format TextAs strings are often made up of written text, there are many instanceswhen we may want to have greater control over how strings look tomake them more readable for humans through punctuation, line breaks,and indentation.In this tutorial, we’ll go over some of the ways we can work withPython strings to make sure that all output text is formatted correctly.String LiteralsLet’s ﬁrst differentiate between a string literal and a string value. A stringliteral is what we see in the source code of a computer program,including the quotation marks. A string value is what we see when wecall the print() function and run the program.In the “Hello, World!” program, the string literal is "Hello, World!" while the string value is Hello, World! without thequotation marks. The string value is what we see as the output in aterminal window when we run a Python program.But some string values may need to include quotation marks, likewhen we are quoting a source. Because string literals and string valuesare not equivalent, it is often necessary to add additional formatting tostring literals to ensure that string values are displayed the way in whichwe intend.Quotes and Apostrophes
Because we can use single quotes or double quotes within Python, it issimple to embed quotes within a string by using double quotes within astring enclosed by single quotes:'Sammy says, "Hello!"'Or, to use a possessive apostrophe in a string enclosed by doublequotes:"Sammy's balloon is red."In the way we combine single and double quotes, we can control thedisplay of quotation marks and apostrophes within our strings.Multiple LinesPrinting strings on multiple lines can make text more readable tohumans. With multiple lines, strings can be grouped into clean andorderly text, formatted as a letter, or used to maintain the linebreaks of apoem or song lyrics.To create strings that span multiple lines, triple single quotes ''' ortriple double quotes """ are used to enclose the string.'''This string is onmultiple lineswithin three singlequotes on either side.'''
"""This string is onmultiple lineswithin three doublequotes on either side."""With triple quotes, you can print strings on multiple lines to make text,especially lengthy text, easier to read.Escape CharactersAnother way to format strings is to use an escape character. Escapecharacters all start with the backslash key ( \ ) combined with anothercharacter within a string to format the given string a certain way.Here is a list of several of the common escape characters:ESCAPE CHARACTERHOW IT FORMATS\New line in a multi-line string\Backslash'Apostrophe or single quote"Double quote| Line break | Tab (horizontal indentation)Let’s use an escape character to add the quotation marks to theexample on quotation marks above, but this time we’ll use doublequotes:
print("Sammy says, \"Hello!\"")OutputSammy says, "Hello!"By using the escape character \" we are able to use double quotes toenclose a string that includes text quoted between double quotes.Similarly, we can use the escape character \' to add an apostrophe in astring that is enclosed in single quotes:print('Sammy\'s balloon is red.')OutputSammy's balloon is red.Because we are now using the escape character we can have anapostrophe within a string that uses single quotes.When we use triple quotes like we did above, we will see that there is aspace at the top and bottom when we print the string. We can removethose spaces by using the \ escape key at the top of our string and againat the end of the string while keeping the text within the program veryreadable."""\This multi-line stringhas no space at thetop or the bottomwhen it prints.\
"""Similarly, we can use the  escape character to break lines withouthitting the enter or return key:print("This stringspans multiplelines.")OutputThis stringspans multiplelines.We can combine escape characters, too. Let’s print a multi-line stringand include tab spacing for an itemized list, for example:print("1.   Shark2.  Shrimp10. Squid")Output1.  Shark2.  Shrimp10. SquidThe horizontal indentation provided with the ` ` escape characterensures alignment within the second column in the example above,
making the output extremely readable for humans.Though the  escape character works well for short string literals, it isimportant to ensure that source code is also readable to humans. In thecase of lengthy strings, the triple quote approach to multi-line strings isoften preferable.Escape characters are used to add additional formatting to strings thatmay be difﬁcult or impossible to achieve. Without escape characters, howwould you construct the string Sammy says, "The balloon's color is red."?Raw StringsWhat if we don’t want special formatting within our strings? Forexample, we may need to compare or evaluate strings of computer codethat use the backslash on purpose, so we won’t want Python to use it asan escape character.A raw string tells Python to ignore all formatting within a string,including escape characters.We create a raw string by putting an r in front of the string, rightbefore the beginning quotation mark:print(r"Sammy says,\"The balloon\'s color is red.\"")OutputSammy says,\"The balloon\'s color is red.\"By constructing a raw string by using r in front of a given string, wecan retain backslashes and other characters that are used as escapecharacters.
ConclusionThis tutorial went over several ways to format text in Python 3 throughworking with strings. By using techniques such as escape characters orraw strings, we are able to ensure that the strings of our program arerendered correctly on-screen so that the end user is able to easily read allof the output text.Continue learning more about strings by taking a look at the followingtutorials: - An Introduction to String Functions - How To Index and SliceStrings - How To Use String Formatters
An Introduction to String FunctionsPython has several built-in functions associated with the string data type.These functions let us easily modify and manipulate strings. We canthink of functions as being actions that we perform on elements of ourcode. Built-in functions are those that are deﬁned in the Pythonprogramming language and are readily available for us to use.In this tutorial, we’ll go over several different functions that we can useto work with strings in Python 3.Making Strings Upper and Lower CaseThe functions str.upper() and str.lower() will return a stringwith all the letters of an original string converted to upper- or lower-caseletters. Because strings are immutable data types, the returned string willbe a new string. Any characters in the string that are not letters will notbe changed.Let’s convert the string Sammy Shark to be all upper case:ss = "Sammy Shark"print(ss.upper())OuputSAMMY SHARKNow, let’s convert the string to be all lower case:
print(ss.lower())Ouputsammy sharkThe str.upper() and str.lower() functions make it easier toevaluate and compare strings by making case consistent throughout.That way if a user writes their name all lower case, we can still determinewhether their name is in our database by checking it against an all upper-case version, for example.Boolean MethodsPython has some string methods that will evaluate to a Boolean value.These methods are useful when we are creating forms for users to ﬁll in,for example. If we are asking for a post code we will only want to accepta numeric string, but when we are asking for a name, we will only wantto accept an alphabetic string.There are a number of string methods that will return Boolean values:METHODTRUE IFstr.isalnum()String consists of only alphanumeric characters(no symbols)str.isalpha()String consists of only alphabetic characters (nosymbols)str.islower()String’s alphabetic characters are all lower casestr.isnumeric()String consists of only numeric characters
str.isspace()String consists of only whitespace charactersstr.istitle()String is in title casestr.isupper()String’s alphabetic characters are all upper caseLet’s look at a couple of these in action:number = "5"letters = "abcdef"print(number.isnumeric())print(letters.isnumeric())OutputTrueFalseUsing the str.isnumeric() method on the string 5 returns a valueof True, while using the same method on the string abcdef returns avalue of False.Similarly, we can query whether a string’s alphabetic characters are intitle case, upper case, or lower case. Let’s create a few strings:movie = "2001: A SAMMY ODYSSEY"book = "A Thousand Splendid Sharks"poem = "sammy lived in a pretty how town"Now let’s try the Boolean methods that check for case:
print(movie.islower())print(movie.isupper())print(book.istitle())print(book.isupper())print(poem.istitle())print(poem.islower())Now we can run these small programs and see the output:Output of movie stringFalseTrueOutput of book stringTrueFalseOutput of poem stringFalseTrueChecking whether characters are lower case, upper case, or title case,can help us to sort our data appropriately, as well as provide us with theopportunity to standardize data we collect by checking and thenmodifying strings as needed.
Boolean string methods are useful when we want to check whethersomething a user enters ﬁts within given parameters.Determining String LengthThe string method len() returns the number of characters in a string.This method is useful for when you need to enforce minimum ormaximum password lengths, for example, or to truncate larger strings tobe within certain limits for use as abbreviations.To demonstrate this method, we’ll ﬁnd the length of a sentence-longstring:open_source = "Sammy contributes to open source."print(len(open_source))Output33We set the variable open_source equal to the string "Sammy contributes to open source." and then we passed that variableto the len() method with len(open_source). We then passed themethod into the print() method so that we could see the output on thescreen from our program.Keep in mind that any character bound by single or double quotationmarks — including letters, numbers, whitespace characters, and symbols— will be counted by the len() method.join(), split(), and replace() Methods
The str.join(), str.split(), and str.replace() methods are afew additional ways to manipulate strings in Python.The str.join() method will concatenate two strings, but in a waythat passes one string through another.Let’s create a string:balloon = "Sammy has a balloon."Now, let’s use the str.join() method to add whitespace to thatstring, which we can do like so:" ".join(balloon)If we print this out:print(" ".join(balloon))We will see that in the new string that is returned there is added spacethroughout the ﬁrst string:OuputS a m m y   h a s   a   b a l l o o n .We can also use the str.join() method to return a string that is areversal from the original string:print("".join(reversed(balloon)))
Ouput.noollab a sah ymmaSWe did not want to add any part of another string to the ﬁrst string, sowe kept the quotation marks touching with no space in between.The str.join() method is also useful to combine a list of strings intoa new single string.Let’s create a comma-separated string from a list of strings:print(",".join(["sharks", "crustaceans", "plankton"]))Ouputsharks,crustaceans,planktonIf we want to add a comma and a space between string values in ournew string, we can simply rewrite our expression with a whitespace afterthe comma: ", ".join(["sharks", "crustaceans", "plankton"]).Just as we can join strings together, we can also split strings up. To dothis, we will use the str.split() method:print(balloon.split())Ouput['Sammy', 'has', 'a', 'balloon.']The str.split() method returns a list of strings that are separatedby whitespace if no other parameter is given.
We can also use str.split() to remove certain parts of an originalstring. For example, let’s remove the letter a from the string:print(balloon.split("a"))Ouput['S', 'mmy h', 's ', ' b', 'lloon.']Now the letter a has been removed and the strings have beenseparated where each instance of the letter a had been, with whitespaceretained.The str.replace() method can take an original string and return anupdated string with some replacement.Let’s say that the balloon that Sammy had is lost. Since Sammy nolonger has this balloon, we will change the substring "has" from theoriginal string balloon to "had" in a new string:print(balloon.replace("has","had"))Within the parentheses, the ﬁrst substring is what we want to bereplaced, and the second substring is what we are replacing that ﬁrstsubstring with. Our output will look like this:OuputSammy had a balloon.Using the string methods str.join(), str.split(), and str.replace() will provide you with greater control to manipulate
strings in Python.ConclusionThis tutorial went through some of the common built-in methods for thestring data type that you can use to work with and manipulate strings inyour Python programs.You can learn more about other data types in “Understanding DataTypes,” read more about strings in “An Introduction to Working withStrings,” and learn about changing the way strings look in “How ToFormat Text in Python 3.”
How To Index and Slice StringsThe Python string data type is a sequence made up of one or moreindividual characters that could consist of letters, numbers, whitespacecharacters, or symbols. Because a string is a sequence, it can be accessedin the same ways that other sequence-based data types are, throughindexing and slicing.This tutorial will guide you through accessing strings throughindexing, slicing them through their character sequences, and go oversome counting and character location methods.How Strings are IndexedLike the list data type that has items that correspond to an index number,each of a string’s characters also correspond to an index number, startingwith the index number 0.For the string Sammy Shark! the index breakdown looks like this:SAMMYSHARK!01234567891011As you can see, the ﬁrst S starts at index 0, and the string ends at index11 with the ! symbol.We also notice that the whitespace character between Sammy and Shark also corresponds with its own index number. In this case, theindex number associated with the whitespace is 5.The exclamation point (!) also has an index number associated with it.Any other symbol or punctuation mark, such as *#$&.;?, is also a
character and would be associated with its own index number.The fact that each character in a Python string has a correspondingindex number allows us to access and manipulate strings in the sameways we can with other sequential data types.Accessing Characters by Positive Index NumberBy referencing index numbers, we can isolate one of the characters in astring. We do this by putting the index numbers in square brackets. Let’sdeclare a string, print it, and call the index number in square brackets:ss = "Sammy Shark!"print(ss[4])OutputyWhen we refer to a particular index number of a string, Python returnsthe character that is in that position. Since the letter y is at index number4 of the string ss = "Sammy Shark!", when we print ss[4] wereceive y as the output.Index numbers allow us to access speciﬁc characters within a string.Accessing Characters by Negative Index NumberIf we have a long string and we want to pinpoint an item towards theend, we can also count backwards from the end of the string, starting atthe index number -1.For the same string Sammy Shark! the negative index breakdownlooks like this:
SAMMYSHARK!-12-11-10-9-8-7-6-5-4-3-2-1By using negative index numbers, we can print out the character r, byreferring to its position at the -3 index, like so:print(ss[-3])OutputrUsing negative index numbers can be advantageous for isolating asingle character towards the end of a long string.Slicing StringsWe can also call out a range of characters from the string. Say we wouldlike to just print the word Shark. We can do so by creating a slice, whichis a sequence of characters within an original string. With slices, we cancall multiple character values by creating a range of index numbersseparated by a colon [x:y]:print(ss[6:11])OutputShark
When constructing a slice, as in [6:11], the ﬁrst index number iswhere the slice starts (inclusive), and the second index number is wherethe slice ends (exclusive), which is why in our example above the rangehas to be the index number that would occur just after the string ends.When slicing strings, we are creating a substring, which is essentially astring that exists within another string. When we call ss[6:11], we arecalling the substring Shark that exists within the string Sammy Shark!.If we want to include either end of a string, we can omit one of thenumbers in the string[n:n] syntax. For example, if we want to printthe ﬁrst word of string ss — “Sammy” — we can do so by typing:print(ss[:5])OutputSammyWe did this by omitting the index number before the colon in the slicesyntax, and only including the index number after the colon, which refersto the end of the substring.To print a substring that starts in the middle of a string and prints tothe end, we can do so by including only the index number before thecolon, like so:print(ss[7:])Outputhark!
By including only the index number before the colon and leaving thesecond index number out of the syntax, the substring will go from thecharacter of the index number called to the end of the string.You can also use negative index numbers to slice a string. As we wentthrough before, negative index numbers of a string start at -1, and countdown from there until we reach the beginning of the string. When usingnegative index numbers, we’ll start with the lower number ﬁrst as itoccurs earlier in the string.Let’s use two negative index numbers to slice the string ss:print(ss[-4:-1])OutputarkThe substring “ark” is printed from the string “Sammy Shark!”because the character “a” occurs at the -4 index number position, and thecharacter “k” occurs just before the -1 index number position.Specifying Stride while Slicing StringsString slicing can accept a third parameter in addition to two indexnumbers. The third parameter speciﬁes the stride, which refers to howmany characters to move forward after the ﬁrst character is retrievedfrom the string. So far, we have omitted the stride parameter, and Pythondefaults to the stride of 1, so that every character between two indexnumbers is retrieved.Let’s look again at the example above that prints out the substring“Shark”:
print(ss[6:11])OutputSharkWe can obtain the same results by including a third parameter with astride of 1:print(ss[6:11:1])OutputSharkSo, a stride of 1 will take in every character between two indexnumbers of a slice. If we omit the stride parameter then Python willdefault with 1.If, instead, we increase the stride, we will see that characters areskipped:print(ss[0:12:2])OutputSmySakSpecifying the stride of 2 as the last parameter in the Python syntax ss[0:12:2] skips every other character. Let’s look at the characters thatare printed in red:Sammy Shark!
Note that the whitespace character at index number 5 is also skippedwith a stride of 2 speciﬁed.If we use a larger number for our stride parameter, we will have asigniﬁcantly smaller substring:print(ss[0:12:4])OutputSyaSpecifying the stride of 4 as the last parameter in the Python syntax ss[0:12:4] prints only every fourth character. Again, let’s look at thecharacters that are printed in red:Sammy Shark!In this example the whitespace character is skipped as well.Since we are printing the whole string we can omit the two indexnumbers and keep the two colons within the syntax to achieve the sameresult:print(ss[::4])OutputSyaOmitting the two index numbers and retaining colons will keep thewhole string within range, while adding a ﬁnal parameter for stride willspecify the number of characters to skip.
Additionally, you can indicate a negative numeric value for the stride,which we can use to print the original string in reverse order if we set thestride to -1:print(ss[::-1])Output!krahS ymmaSThe two colons without speciﬁed parameter will include all thecharacters from the original string, a stride of 1 will include everycharacter without skipping, and negating that stride will reverse theorder of the characters.Let’s do this again but with a stride of -2:print(ss[::-2])Output!rh maIn this example, ss[::-2], we are dealing with the entirety of theoriginal string as no index numbers are included in the parameters, andreversing the string through the negative stride. Additionally, by havinga stride of -2 we are skipping every other letter of the reversed string:!krahS[whitespace]ymmaSThe whitespace character is printed in this example.By specifying the third parameter of the Python slice syntax, you areindicating the stride of the substring that you are pulling from the
original string.Counting MethodsWhile we are thinking about the relevant index numbers that correspondto characters within strings, it is worth going through some of themethods that count strings or return index numbers. This can be usefulfor limiting the number of characters we would like to accept within auser-input form, or comparing strings. Like other sequential data types,strings can be counted through several methods.We’ll ﬁrst look at the len() method which can get the length of anydata type that is a sequence, whether ordered or unordered, includingstrings, lists, tuples, and dictionaries.Let’s print the length of the string ss:print(len(ss))Output12The length of the string “Sammy Shark!” is 12 characters long,including the whitespace character and the exclamation point symbol.Instead of using a variable, we can also pass a string right into the len() method:print(len("Let's print the length of this string."))Output38
The len() method counts the total number of characters within astring.If we want to count the number of times either one particular characteror a sequence of characters shows up in a string, we can do so with the str.count() method. Let’s work with our string ss = "Sammy Shark!" and count the number of times the character “a” appears:print(ss.count("a"))Output2We can search for another character:print(ss.count("s"))Output0Though the letter “S” is in the string, it is important to keep in mindthat each character is case-sensitive. If we want to search for all the lettersin a string regardless of case, we can use the str.lower() method toconvert the string to all lower-case ﬁrst. You can read more about thismethod in “An Introduction to String Methods in Python 3.”Let’s try str.count() with a sequence of characters:likes = "Sammy likes to swim in the ocean, likes to spin up servers, and likes to smile."
print(likes.count("likes"))Output3In the string likes, the character sequence that is equivalent to “likes”occurs 3 times in the original string.We can also ﬁnd at what position a character or character sequenceoccurs in a string. We can do this with the str.find() method, and itwill return the position of the character based on index number.We can check to see where the ﬁrst “m” occurs in the string ss:print(ss.find("m"))Ouput2The ﬁrst character “m” occurs at the index position of 2 in the string“Sammy Shark!” We can review the index number positions of the string ss above.Let’s check to see where the ﬁrst “likes” character sequence occurs inthe string likes:print(likes.find("likes"))Ouput6
The ﬁrst instance of the character sequence “likes” begins at indexnumber position 6, which is where the character l of the sequence likesis positioned.What if we want to see where the second sequence of “likes” begins?We can do that by passing a second parameter to the str.find()method that will start at a particular index number. So, instead of startingat the beginning of the string, let’s start after the index number 9:print(likes.find("likes", 9))Output34In this second example that begins at the index number of 9, the ﬁrstoccurrence of the character sequence “likes” begins at index number 34.Additionally, we can specify an end to the range as a third parameter.Like slicing, we can do so by counting backwards using a negative indexnumber:print(likes.find("likes", 40, -6))Output64This last example searches for the position of the sequence “likes”between the index numbers of 40 and -6. Since the ﬁnal parameterentered is a negative number it will be counting from the end of theoriginal string.
The string methods of len(), str.count(), and str.find() canbe used to determine length, counts of characters or character sequences,and index positions of characters or character sequences within strings.ConclusionBeing able to call speciﬁc index numbers of strings, or a particular slice ofa string gives us greater ﬂexibility when working with this data type.Because strings, like lists and tuples, are a sequence-based data type, itcan be accessed through indexing and slicing.You can read more about formatting strings and string methods tocontinue learning about strings.
How To Convert Data TypesIn Python, data types are used to classify one particular type of data,determining the values that you can assign to the type and the operationsyou can perform on it. When programming, there are times we need toconvert values between types in order to manipulate values in a differentway. For example, we may need to concatenate numeric values withstrings, or represent decimal places in numbers that were initialized asinteger values.This tutorial will guide you through converting numbers, strings,tuples and lists, as well as provide examples to help familiarize yourselfwith different use cases.Converting Number TypesIn Python, there are two number data types: integers and ﬂoating-pointnumbers or ﬂoats. Sometimes you are working on someone else’s codeand will need to convert an integer to a ﬂoat or vice versa, or you mayﬁnd that you have been using an integer when what you really need is aﬂoat. Python has built-in methods to allow you to easily convert integersto ﬂoats and ﬂoats to integers.Converting Integers to FloatsPython’s method float() will convert integers to ﬂoats. To use thisfunction, add an integer inside of the parentheses:float(57)
In this case, 57 will be converted to 57.0.You can also use this with a variable. Let’s declare f as equal to 57,and then print out the new ﬂoat:f = 57print(float(f))Output57.0By using the float() function, we can convert integers to ﬂoats.Converting Floats to IntegersPython also has a built-in function to convert ﬂoats to integers: int().The int() function works similarly to the float() function: you canadd a ﬂoating-point number inside of the parentheses to convert it to aninteger:int(390.8)In this case, 390.8 will be converted to 390.You can also use this with variables. Let’s declare b as equal to 125.0,and c as equal to 390.8, then print out the new ﬂoats:b = 125.0c = 390.8print(int(b))
print(int(c))Output125390When converting ﬂoats to integers with the int() function, Pythoncuts off the decimal and remaining numbers of a ﬂoat to create an integer.Even though we may want to round 390.8 up to 391, Python will not dothis through the int() function.Numbers Converted Through DivisionIn Python 3, relevant quotients are converted from integers to ﬂoatswhen doing division though they are not in Python 2. That is, when youdivide 5 by 2, in Python 3 you will get a ﬂoat for an answer (2.5):a = 5 / 2print(a)Output2.5In Python 2, since you were dealing with two integers, you wouldreceive an integer back as your answer, instead: 5 / 2 = 2. Read“Python 2 vs Python 3: Practical Considerations” for more informationabout the differences between Python 2 and Python 3.Converting with Strings
A string is a sequence of one or more characters (letters, numbers,symbols). Strings are a common form of data in computer programs, andwe may need to convert strings to numbers or numbers to strings fairlyoften, especially when we are taking in user-generated data.Converting Numbers to StringsWe can convert numbers to strings through using the str() method.We’ll pass either a number or a variable into the parentheses of themethod and then that numeric value will be converted into a stringvalue.Let’s ﬁrst look at converting integers. To convert the integer 12 to astring value, you can pass 12 into the str() method:str(12)When running str(12) in the Python interactive shell with the python command in a terminal window, you’ll receive the followingoutput:Output'12'The quotes around the number 12 signify that the number is no longeran integer but is now a string value.With variables we can begin to see how practical it can be to convertintegers to strings. Let’s say we want to keep track of a user’s dailyprogramming progress and are inputting how many lines of code they
write at a time. We would like to show this feedback to the user and willbe printing out string and integer values at the same time:user = "Sammy"lines = 50print("Congratulations, " + user + "! You just wrote " + lines + " lines of code.")When we run this code, we receive the following error:OutputTypeError: Can't convert 'int' object to str implicitlyWe’re not able to concatenate strings and integers in Python, so we’llhave to convert the variable lines to be a string value:user = "Sammy"lines = 50print("Congratulations, " + user + "! You just wrote " + str(lines) + " lines of code.")Now, when we run the code, we receive the following output thatcongratulates our user on their progress:Output
Congratulations, Sammy! You just wrote 50 lines of code.If we are looking to convert a ﬂoat to a string rather than an integer toa string, we follow the same steps and format. When we pass a ﬂoat intothe str() method, a string value of the ﬂoat will be returned. We canuse either the ﬂoat value itself or a variable:print(str(421.034))f = 5524.53print(str(f))Output421.0345524.53We can test to make sure it’s right by concatenating with a string:f = 5524.53print("Sammy has " + str(f) + " points.")OutputSammy has 5524.53 points.We can be sure our ﬂoat was properly converted to a string because theconcatenation was performed without error.
Converting Strings to NumbersStrings can be converted to numbers by using the int() and float()methods.If your string does not have decimal places, you’ll most likely want toconvert it to an integer by using the int() method.Let’s use the example of the user Sammy keeping track of lines of codewritten each day. We may want to manipulate those values with math toprovide more interesting feedback for the user, but those values arecurrently stored in strings:lines_yesterday = "50"lines_today = "108"lines_more = lines_today - lines_yesterdayprint(lines_more)OutputTypeError: unsupported operand type(s) for -: 'str' and 'str'Because the two numeric values were stored in strings, we received anerror. The operand - for subtraction is not a valid operand for two stringvalues.Let’s modify the code to include the int() method that will convertthe strings to integers, and allow us to do math with values these thatwere originally strings.
lines_yesterday = "50"lines_today = "108"lines_more = int(lines_today) - int(lines_yesterday)print(lines_more)Output58The variable lines_more is automatically an integer, and it is equal tothe numeric value of 58 in this example.We can also convert the numbers in the example above to ﬂoat valuesby using the float() method in place of the int() method. Instead ofreceiving the output of 58, we’ll receive the output of 58.0, a ﬂoat.The user Sammy is earning points in decimal valuestotal_points = "5524.53"new_points = "45.30"new_total_points = total_points + new_pointsprint(new_total_points)Output5524.5345.30
In this case, using the + operand with two strings is a valid operation,but it is concatenating two strings rather than adding two numeric valuestogether. So, our output looks unusual since it just places the two valuesnext to each other.We’ll want to convert these strings to ﬂoats prior to performing anymath with the float() method:total_points = "5524.53"new_points = "45.30"new_total_points = float(total_points) + float(new_points)print(new_total_points)Output5569.83Now that we have converted the two strings to ﬂoats, we receive theanticipated result that adds 45.30 to 5524.53.If we try to convert a string value with decimal places to an integer,we’ll receive an error:f = "54.23"print(int(f))OutputValueError: invalid literal for int() with base 10: 
'54.23'If we pass a decimal value in a string to the int() method we’llreceive an error because it will not convert to an integer.Converting strings to numbers enables us to quickly modify the datatype we are working with so that we can perform operations on numericvalues that were originally cast as strings.Converting to Tuples and ListsYou can use the methods list() and tuple() to convert the valuespassed to them into the list and tuple data type respectively. In Python: -a list is a mutable ordered sequence of elements that is contained withinsquare brackets [ ]. - a tuple is an immutable ordered sequence ofelements contained within parentheses ( ).Converting to TuplesLet’s start with converting a list to a tuple. Converting a list to a tuple,because it’s an immutable data type, can allow substantial optimizationto the programs that we create. When we use the method tuple() it willreturn the tuple version of the value passed to it.print(tuple(['pull request', 'open source', 'repository', 'branch']))Output('pull request', 'open source', 'repository', 'branch')
We see that a tuple is printed out in the output, as the items are nowcontained within parentheses rather than square brackets.Let’s use tuple() with a variable that represents a list:sea_creatures = ['shark', 'cuttlefish', 'squid', 'mantis shrimp']print(tuple(sea_creatures))Output('shark', 'cuttlefish', 'squid', 'mantis shrimp')Again, we see that the list value is changed to a tuple value, indicatedby the parentheses. We can convert any iterable type to a tuple, includingstrings:print(tuple('Sammy'))Output('S', 'a', 'm', 'm', 'y')Because we can iterate through strings, we can convert them to tupleswith the tuple() method. With data types that are not iterable,however, like integers and ﬂoats, we will receive a type error:print(tuple(5000))OutputTypeError: 'int' object is not iterable
While it is possible to convert the integer to a string and then convertto a tuple, as in tuple(str(5000)), it is best to opt for readable codeover complicated conversions.Converting to ListsConverting values, especially tuples, to lists can be useful when you needto have a mutable version of that value.We’ll use the list() method to convert the following tuple to a list.Because the syntax for creating a list uses parentheses, be sure to includethe parentheses of the list() method, and in this case the print()method as well:print(list(('blue coral', 'staghorn coral', 'pillar coral')))Output['blue coral', 'staghorn coral', 'pillar coral']The square brackets signal that a list has been returned from theoriginal tuple value that was passed through the list() method.To make the code more readable, we can remove one of the pairs ofparentheses by using a variable:coral = ('blue coral', 'staghorn coral', 'pillar coral')list(coral)If we print list(coral) we would receive the same output as above.
Just like tuples, strings can be converted to lists:print(list('shark'))Output['s', 'h', 'a', 'r', 'k']Here the string 'shark' was converted to a list, providing a mutableversion of the original value.ConclusionThis Python tutorial demonstrated how to convert several of theimportant native data types to other data types, primarily through built-in methods. Being able to convert data types in Python provides youwith extra ﬂexibility when writing your programs.
How To Use VariablesVariables are an important programming concept to master. They areessentially symbols that stand in for a value you’re using in a program.This tutorial will cover some variable basics and how to best use themwithin the Python 3 programs you create.Understanding VariablesIn technical terms, a variable is assigning a storage location to a valuethat is tied to a symbolic name or identiﬁer. The variable name is used toreference that stored value within a computer program.You can think of a variable as a label that has a name on it, which youtie onto a value:
Variables in PythonLet’s say we have an integer, 103204934813, and we want to store itin a variable rather than continuously retype the long number over and
over again. Instead, let’s use something that’s easy to remember like thevariable my_int:my_int = 103204934813If we think of it like a label that is tied to the value, it will looksomething like this:
Python Variable ExampleThe label has the variable name my_int written on it, and is tied to theinteger value 103204934813.The phrase my_int = 103204934813 is an assignment statement,which consists of a few parts:the variable name (my_int)the assignment operator, also known as the equal sign (=)the value that is being tied to the variable name (103204934813)Together, those three parts make up the statement that sets the variablemy_int equal to the value of the integer 103204934813.
As soon as we set a variable equal to a value, we initialize or createthat variable. Once we have done that, we are set to use the variableinstead of the value. In Python, variables do not need explicit declarationprior to use like some programming languages; you can start using thevariable right away.As soon as we set my_int equal to the value of 103204934813, wecan use my_int in the place of the integer, so let’s print it out:print(my_int)Output103204934813Using variables, we can quickly and easily do math. With my_int = 1040, let’s subtract the integer value 813:print(my_int - 813)Output103204934000In this example, Python does the math for us, subtracting 813 from thevariable my_int to return the sum 103204934000.Speaking of math, variables can be set equal to the result of a mathequation. Let’s add two numbers together and store the value of the suminto the variable x:x = 76 + 145
The above example may look like something you’re already familiarwith: algebra. In algebra, letters and other symbols are used to representnumbers and quantities within formulas and equations, just like howvariables are symbolic names that represent the value of a data type. Forcorrect Python syntax, you’ll need to make sure that your variable is onthe left side of any equations.Let’s go ahead and print x:print(x)Output221Python returned the value 221 because the variable x was set equal tothe sum of 76 and 145.Variables can represent any data type, not just integers:my_string = 'Hello, World!'my_flt = 45.06my_bool = 5 > 9 #A Boolean value will return either True or Falsemy_list = ['item_1', 'item_2', 'item_3', 'item_4']my_tuple = ('one', 'two', 'three')my_dict = {'letter': 'g', 'number': 'seven', 'symbol': '&'}If you print any of the above variables, Python will return what thatvariable is equivalent to. For example, let’s work with the assignment
statement for the list data type above:my_list = ['item_1', 'item_2', 'item_3', 'item_4']print(my_list)Output['item_1', 'item_2', 'item_3', 'item_4']We passed the list value of ['item_1', 'item_2', 'item_3', 'item_4'] to the variable my_list, and then used the print()function to print out that value by calling my_list.Variables work by carving out a little area of memory within yourcomputer which accepts speciﬁed values that are then associated withthat space.Naming Variables: Rules and StyleThe naming of variables is quite ﬂexible, but there are some rules youneed to keep in mind:Variable names must only be one word (as in no spaces)Variable names must be made up of only letters, numbers, andunderscore (_)Variable names cannot begin with a numberFollowing the rules above, let’s look at both valid and invalid variablenames:VALIDINVALIDWHY INVALID
my_intmy-intHyphens are not permittedint44intCannot begin with a numberMY_INT$MY_INTCannot use symbols other than _another_intanother intCannot be more than one wordSomething else to keep in mind when naming variables, is that theyare case-sensitive, meaning that my_int, MY_INT, My_Int, and mY_iNtare all completely different variables. You should avoid using similarvariable names within a program to ensure that both you and yourcurrent and future collaborators can keep your variables straight.Finally, some notes about style. Conventionally speaking, whennaming variables it is customary to begin them with a lower-case letterand to use underscores when separating words. Beginning with anupper-case letter is not invalid, and some people may prefer camelCaseor mixed upper- and lower-case letters when writing their variables, butthese are less conventional choices.CONVENTIONALSTYLEUNCONVENTIONALSTYLEWHY UNCONVENTIONALmy_intmyIntcamelCase not conventionalint4Int4Upper-case ﬁrst letter notconventionalmy_ﬁrst_stringmyFirstStringcamelCase not conventionalThe most important style choice you can make is to be consistent. Ifyou begin working on an existing project that has been using camelCase
for its variable names, then it is best to continue using the existing style.PEP 8 is the ofﬁcial Python code style guide and it addresses many ofthe stylistic questions you may have about Python. In general, readabilityand consistency are favored over other stylistic concerns.Reassigning VariablesAs the word variable implies, Python variables can be readily changed.This means that you can connect a different value with a previouslyassigned variable very easily through simple reassignment.Being able to reassign is useful because throughout the course of aprogram, you may need to accept user-generated values into alreadyinitialized variables, or may have to change the assignment to somethingyou previously deﬁned.Knowing that you can readily and easily reassign a variable can also beuseful in situations where you may be working on a large program thatwas begun by someone else and you are not clear yet on what hasalready been deﬁned.Let’s assign x ﬁrst as an integer, and then reassign it as a string:#Assign x to be an integerx = 76print(x)#Reassign x to be a stringx = "Sammy"print(x)Output
76SammyThe example above shows that we can ﬁrst assign the variable x andassign it with the value of an integer, and then reassign the variable xassigning it this time with the value of a string.If we rewrote the program this way:x = 76x = "Sammy"print(x)We would only receive the second assigned value as the output sincethat was the most recent assignment:OutputSammyReassigning variables can be useful in some cases, but you will want tobe aware of the readability of your code and work to make your programas clear as possible.Multiple AssignmentWith Python, you can assign one single value to several variables at thesame time. This lets you initialize several variables at once, which youcan reassign later in the program yourself, or through user input.Through multiple assignment, you can set the variables x, y, and z tothe value of the integer 0:
x = y = z = 0print(x)print(y)print(z)Output000In this example, all three of the variables (x, y, and z) are assigned tothe same memory location. They are each equal to the value of 0.Python also allows you to assign several values to several variableswithin the same line. Each of these values can be of a different data type:j, k, l = "shark", 2.05, 15print(j)print(k)print(l)Outputshark2.0515In the example above, the variable j was assigned to the string "shark", the variable k was assigned to the ﬂoat 2.05, and the variable l was assigned to the integer 15.
This approach to assigning multiple variables to multiple values in oneline can keep your lines of code down, but make sure you are notcompromising readability for fewer lines of code.Global and Local VariablesWhen using variables within a program, it is important to keep variablescope in mind. A variable’s scope refers to the particular places it isaccessible within the code of a given program. This is to say that not allvariables are accessible from all parts of a given program — somevariables will be global and some will be local.Global variables exist outside of functions. Local variables exist withinfunctions.Let’s take a look at global and local variables in action:#Create a global variable, outside of a functionglb_var = "global"#Define a functiondef var_function():    lcl_var = "local" #Create a local variable, inside function    print(lcl_var)#Call function to print local variablevar_function()#Print global variable outside functionprint(glb_var)
OutputlocalglobalThe above program assigns the global variable glb_var outside ofany function, then deﬁnes the function var_function(). Inside of thefunction a local variable called lcl_var is assigned and then printedout. The program ends by calling the var_function() and thenprinting the glb_var.Because glb_var is a global variable, we can refer to it in var_function(). Let’s modify the small program above to do that:glb_var = "global"def var_function():    lcl_var = "local"    print(lcl_var)    print(glb_var) #Print glb_var within functionvar_function()print(glb_var)Outputlocalglobalglobal
We now have the global variable glb_var printed out twice, becauseit is printed both by the function and outside of the function.What if we try to call the local variable outside of the function?glb_var = "global"def var_function():    lcl_var = "local"    print(lcl_var)print(lcl_var)OutputNameError: name 'lcl_var' is not definedWe cannot use a local variable outside of the function it is assigned in.If we try to do so, we’ll receive a NameError in return.Let’s look at another example where we use the same variable namefor a global variable and a local variable:num1 = 5 #Global variabledef my_function():    num1 = 10 #Use the same variable name num1    num2 = 7 #Assign local variable    print(num1) #Print local variable num1    print(num2) #Print local variable num2
#Call my_function()my_function()#Print global variable num1print(num1)Output1075Because the local variable of num1 is assigned locally within a function,when we call that function we see num1 as equal to the local value of 10.When we print out the global value of num1 after calling my_function(), we see that the global variable num1 is still equal tothe value of 5.It is possible to assign global variables within a function by usingPython’s global statement:def new_shark():    #Assign variable as global    global shark    shark = "Sammy"#Call new_shark() functionnew_shark()
#Print global variable sharkprint(shark)Even though the variable shark was assigned locally within the new_shark() function, it is accessible outside of the function because ofthe global statement used before the assignment of the variable withinthe function. Due to that global statement, when we call print(shark) outside of the function we don’t receive an error.Though you can assign a global variable within a function, you likelywill not need to do this often, and should err on the side of readablecode.Something else to keep in mind is that if you reference a variablewithin a function, without also assigning it a value, that variable isimplicitly global. In order to have a local variable, you must assign avalue to it within the body of the function.When working with variables, it is important to decide whether it ismore appropriate to use a global or local variable. Usually it is best tokeep variables local, but when you are using the same variablethroughout several functions, you may want to initialize a globalvariable. If you are working with the variable only within one function orone class, you’ll probably want to use a local variable instead.ConclusionThis tutorial went through some of the common use cases of variableswithin Python 3. Variables are an important building block ofprogramming, serving as symbols that stand in for the value of a datatype you are using in a program.
How To Use String FormattersPython’s str.format() method of the string class allows you to dovariable substitutions and value formatting. This lets you concatenateelements together within a string through positional formatting.This tutorial will guide you through some of the common uses offormatters in Python, which can help make your code and program morereadable and user friendly.Using FormattersFormatters work by putting in one or more replacement ﬁelds orplaceholders — deﬁned by a pair of curly braces {} — into a string andcalling the str.format() method. You’ll pass into the method thevalue you want to concatenate with the string. This value will be passedthrough in the same place that your placeholder is positioned when yourun the program.Let’s print out a string that uses a formatter:print("Sammy has {} balloons.".format(5))OutputSammy has 5 balloons.In the example above, we constructed a string with a pair of curlybraces as a placeholder:
"Sammy has {} balloons."We then added the str.format() method and passed the value ofthe integer 5 to that method. This places the value of 5 into the stringwhere the curly braces were:Sammy has 5 balloons.We can also assign a variable to be equal to the value of a string thathas formatter placeholders:open_string = "Sammy loves {}."print(open_string.format("open source"))OutputSammy loves open source.In this second example, we concatenated the string "open source"with the larger string, replacing the curly braces in the original string.Formatters in Python allow you to use curly braces as placeholders forvalues that you’ll pass through with the str.format() method.Using Formatters with Multiple PlaceholdersYou can use multiple pairs of curly braces when using formatters. If we’dlike to add another variable substitution to the sentence above, we can doso by adding a second pair of curly braces and passing a second valueinto the method:
new_open_string = "Sammy loves {} {}."                      #2 {} placeholdersprint(new_open_string.format("open-source", "software"))    #Pass 2 strings into method, separated by a commaOutputSammy loves open-source software.To add another substitution, we added a second pair of curly bracesinto the original string. Then, we passed two strings into the str.format() method, separating them by a comma.Following the same syntax, we can add additional substitutions:sammy_string = "Sammy loves {} {}, and has {} {}."                      #4 {} placeholdersprint(sammy_string.format("open-source", "software", 5, "balloons"))    #Pass 4 strings into methodOutputSammy loves open-source software, and has 5 balloons.In sammy_string we added 4 pairs of curly braces as placeholders forvariable substitution. We then passed 4 values into the str.format()method, mixing string and integer data types. Each of these values areseparated by a comma.Reordering Formatters with Positional and Keyword Arguments
When we leave curly braces empty without any parameters, Python willreplace the values passed through the str.format() method in order.As we have seen, so far, a formatter construction with two empty curlybraces with two values passed through will look like this:print("Sammy the {} has a pet {}!".format("shark", "pilot fish"))OutputSammy the shark has a pet pilot fish!The ﬁrst pair of curly braces is substituted with the string value of "shark", and the second pair is substituted with the string value of "pilot fish".The values that exist within the method look like this:("shark", "pilot fish")They are essentially the tuple data type and each individual valuecontained in the tuple can be called by its index number, which startswith the index number 0.We can pass these index numbers into the curly braces that serve as theplaceholders in the original string:print("Sammy the {0} has a pet {1}!".format("shark", "pilot fish"))
In the above example, the output will be what we get without passingindex numbers into the braces as we are calling the values in the tuple inorder:OutputSammy the shark has a pet pilot fish!But, if we reverse the index numbers with the parameters of theplaceholders we can reverse the values being passed into the string:print("Sammy the {1} has a pet {0}!".format("shark", "pilot fish"))OutputSammy the pilot fish has a pet shark!If you call an index number of 2 in a tuple that has values at indexpositions 0 and 1, then you are calling on a value that is out of range.When you call an index number that is out of range, you’ll receive anerror message:print("Sammy the {2} has a pet {1}!".format("shark", "pilot fish"))OutputIndexError: tuple index out of range
The error message we see refers to the tuple only having values atindex numbers 0 and 1, therefore placing index number 2 out of range.Let’s add a few more placeholders and a few more values to pass tothem, so we can understand how we can reorder formatters a little better.First, here is a new string with four placeholders:print("Sammy is a {}, {}, and {} {}!".format("happy", "smiling", "blue", "shark"))OutputSammy is a happy, smiling and blue shark!Without parameters, the values that are passed into the str.format() method are concatenated into the string in order.The string values contained in the tuple correspond to the followingindex numbers:“HAPPY”“SMILING”“BLUE”“SHARK”0123Let’s use the index numbers of the values to change the order that theyappear in the string:print("Sammy is a {3}, {2}, and {1} {0}!".format("happy", "smiling", "blue", "shark"))OutputSammy is a shark, blue, and smiling happy!
Since we started with index number 3, we called the last value of "shark" ﬁrst. The other index numbers included as parameters changethe order of how the words appear within the original string.In addition to positional arguments, we can also introduce keywordarguments that are called by their keyword name:print("Sammy the {0} {1} a {pr}.".format("shark", "made", pr = "pull request"))OutputSammy the shark made a pull request.This example shows the use of a keyword argument being used withpositional arguments. We can ﬁll in the keyword argument pr alongsidepositional arguments, and can move these arguments around to changethe resulting string:print("Sammy the {pr} {1} a {0}.".format("shark", "made", pr = "pull request"))OutputSammy the pull request made a shark.Positional and keyword arguments used with string formatters give usmore control over manipulating our original strings through reordering.Specifying Type
We can include more parameters within the curly braces of our syntax.We’ll use the format code syntax {field_name:conversion}, where field_name speciﬁes the index number of the argument to the str.format() method that we went through in the reordering section,and conversion refers to the conversion code of the data type thatyou’re using with the formatter.The conversion type refers to the the single-character type code thatPython uses. The codes that we’ll be using here are s for string, d todisplay decimal integers (10-base), and f which we’ll use to display ﬂoatswith decimal places. You can read more about the Format-SpeciﬁcationMini-Language through Python 3’s ofﬁcial documentation.Let’s look at an example where we have an integer passed through themethod, but want to display it as a ﬂoat by adding the f conversion typeargument:print("Sammy ate {0:f} percent of a {1}!".format(75, "pizza"))OutputSammy ate 75.000000 percent of a pizza!We used the syntax of {field_name:conversion} for the ﬁrst curlybrace replacement ﬁeld to output a ﬂoat. The second curly braces onlyuses the ﬁrst parameter {field_name}.In the example above, there are a lot of numbers displaying after thedecimal point, but you can limit those. When you are specifying f forﬂoat values, you can additionally specify the precision of that value by
including a full stop . followed by the number of digits after the decimalyou would like to include.If Sammy ate 75.765367% of the pizza, but we don’t need to have ahigh level of accuracy, we can limit the places after the decimal to 3 byadding .3 before the conversion type f:print("Sammy ate {0:.3f} percent of a pizza!".format(75.765367))OutputSammy ate 75.765 percent of a pizza!If we just want one decimal place, we can rewrite the string andmethod like so:print("Sammy ate {0:.1f} percent of a pizza!".format(75.765367))OutputSammy ate 75.8 percent of a pizza!Note that modifying precision will cause the number to be rounded.Although we display a number with no decimal places as a ﬂoat, if wetry to change the ﬂoat to an integer by using the d conversion type, wewill receive an error:print("Sammy ate {0:d} percent of a pizza!".format(75.765367))
OutputValueError: Unknown format code 'd' for object of type 'float'If you would like no decimal places to be shown, you can write yourformatter like so:print("Sammy ate {0:.0f} percent of a pizza!".format(75.765367))OutputSammy ate 75 percent of a pizza!This will not convert your ﬂoat to an integer, but instead limit thenumber of places shown after the decimal point.Padding Variable SubstitutionsBecause the placeholders are replacement ﬁelds, you can pad or createspace around an element by increasing ﬁeld size through additionalparameters. This can be useful when we need to organize a lot of datavisually.We can add a number to indicate ﬁeld size (in terms of characters) afterthe colon : in the curly braces of our syntax:print("Sammy has {0:4} red {1:16}!".format(5, "balloons"))Output
Sammy has    5 red balloons        !In the example above, we gave the number 5 a character ﬁeld size of 4,and the string balloons a character ﬁeld size of 16 (because it is a longstring).As we see, by default strings are left-justiﬁed within the ﬁeld, andnumbers are right-justiﬁed. You can modify this by placing an alignmentcode just following the colon. < will left-align the text in a ﬁeld, ^ willcenter the text in the ﬁeld, and > will right-align it.Let’s left-align the number and center the string:print("Sammy has {0:<4} red {1:^16}!".format(5, "balloons"))OutputSammy has 5    red     balloons    !Now we see that 5 is left-aligned, providing space in the ﬁeld before red, and balloons is centered in its ﬁeld with space to the left and rightof it.By default, when we make a ﬁeld larger with formatters, Python willﬁll the ﬁeld with whitespace characters. We can modify that to be adifferent character by specifying the character we want it to be directlyfollowing the colon:print("{:*^20s}".format("Sammy"))Output
*******Sammy********We are accepting the string being passed to str.format() in theindex position of 0 since we did not specify otherwise, including thecolon, and specifying that we will use * instead of space to ﬁll up theﬁeld. We’re centering the string with ^, specifying that the ﬁeld is 20characters in size, and also indicating that we are working with a stringconversion type by including s.We can combine these parameters with other parameters we’ve usedbefore:print("Sammy ate {0:5.0f} percent of a pizza!".format(75.765367))OutputSammy ate    76 percent of a pizza!In the parameters within the curly braces, we speciﬁed the index ﬁeldnumber of the ﬂoat and included the colon, indicated the size of the ﬁeldnumber and included the full stop, wrote in the number of places afterthe decimal place, and then speciﬁed the conversion type of f.Using VariablesSo far, we have passed integers, ﬂoats, and strings into the str.format() method, but we can also pass variables through themethod. This works just like any other variable.nBalloons = 8
print("Sammy has {} balloons today!".format(nBalloons))OutputSammy has 8 balloons today!We can use variables for both the original string and what is passedinto the method :sammy = "Sammy has {} balloons today!"nBalloons = 8print(sammy.format(nBalloons))OutputSammy has 8 balloons today!Variables can be easily substituted for each part of our formatter syntaxconstruction. This makes it easier to work with when we are taking inuser-generated input and assigning those values to variables.Using Formatters to Organize DataFormatters can be seen in their best light when they are being used toorganize a lot of data in a visual way. If we are showing databases tousers, using formatters to increase ﬁeld size and modify alignment canmake your output more readable.Let’s look at a typical for loop in Python that will print out i, i*i, and i*i*i in the range from 3 to 12:
for i in range(3,13):    print(i, i*i, i*i*i)Output3 9 274 16 645 25 1256 36 2167 49 3438 64 5129 81 72910 100 100011 121 133112 144 1728While the output is organized in a way, the numbers overﬂow intoeach other’s columns, making the bottom of the output less readable. Ifyou are working with a bigger data set with many small and bignumbers, this can pose a problem.Let’s use formatters to give more space to these numbers:for i in range(3,13):    print("{:3d} {:4d} {:5d}".format(i, i*i, i*i*i))Here, in our curly braces, we didn’t add the ﬁeld name for indexnumber and started with the colon, followed by the number for the ﬁeldsize, and a d conversion type since we’re working with integers. In thisexample, we accommodated for the size of each expected output, giving
2 extra character spaces for each, depending on the maximum possiblenumber size, so our output looks like this:Output  3    9    27  4   16    64  5   25   125  6   36   216  7   49   343  8   64   512  9   81   729 10  100  1000 11  121  1331 12  144  1728We can specify a consistent ﬁeld size number in order to have evencolumns, making sure that we accommodate the larger numbers:for i in range(3,13):    print("{:6d} {:6d} {:6d}".format(i, i*i, i*i*i))Output     3      9     27     4     16     64     5     25    125     6     36    216     7     49    343     8     64    512
     9     81    729    10    100   1000    11    121   1331    12    144   1728We can also manipulate the alignment of the columns by adding <, ^,and > for text alignment, change d to f to add decimal places, changeﬁeld name index numbers, and more to ensure that we are displaying thedata as we would like.ConclusionUsing formatters for variable substitution can be effective way toconcatenate strings and organize values and data. Formatters represent asimple but non-descriptive way for passing variable substitutions into astring, and are useful for making sure output is readable and userfriendly.
How To Do Math with OperatorsNumbers are extremely common in programming. They are used torepresent things like screen size dimensions, geographic locations,money and points, the amount of time that passes in a video, positions ofgame avatars, and colors through assigning numeric codes.Being able to effectively perform mathematical operations inprogramming is an important skill to develop because of how frequentlyyou’ll be working with numbers. Though a high-level understanding ofmathematics can certainly help you become a better programmer, it is nota prerequisite. If you don’t have a background in mathematics, try tothink of math as a tool to accomplish what you would like to achieve,and as a way to improve your logical thinking.We’ll be working with two of Python’s most used numeric data types,integers and ﬂoats:Integers are whole numbers that can be positive, negative, or 0 (…, -1, 0, 1, …).Floats are real numbers, they contain a decimal point (as in 9.0 or -2.25).This tutorial will go over operators that can be used with number datatypes in Python.OperatorsAn operator is a symbol or function that indicates an operation. Forexample, in math the plus sign or + is the operator that indicates
addition.In Python, we will see some familiar operators that are brought overfrom math, but other operators we will use are speciﬁc to computerprogramming.Here is a quick reference table of math-related operators in Python.We’ll be covering all of the following operations in this tutorial.OPERATIONWHAT IT RETURNSx + ySum of x and yx - yDifference of x and y-xChanged sign of x+xIdentity of xx * yProduct of x and yx / yQuotient of x and yx // yQuotient from ﬂoor division of x and yx % yRemainder of x / yx ** yx to the y powerWe’ll also be covering compound assignment operators, including +=and *=, that combine an arithmetic operator with the = operator.Addition and SubtractionIn Python, addition and subtraction operators perform just as they do inmathematics. In fact, you can use the Python programming language as acalculator.
Let’s look at some examples, starting with integers:print(1 + 5)Output6Instead of passing integers directly into the print statement, we caninitialize variables to stand for integer values:a = 88b = 103print(a + b)Output191Because integers can be both positive and negative numbers (and 0too), we can add a negative number with a positive number:c = -36d = 25print(c + d)Output-11
Addition will behave similarly with ﬂoats:e = 5.5f = 2.5print(e + f)Output8.0Because we added two ﬂoats together, Python returned a ﬂoat valuewith a decimal place.The syntax for subtraction is the same as for addition, except you’llchange your operator from the plus sign (+) to the minus sign (-):g = 75.67h = 32print(g - h)Output43.67Here, we subtracted an integer from a ﬂoat. Python will return a ﬂoat ifat least one of the numbers involved in an equation is a ﬂoat.Unary Arithmetic Operations
A unary mathematical expression consists of only one component orelement, and in Python the plus and minus signs can be used as a singleelement paired with a value to return the value’s identity (+), or changethe sign of the value (-).Though not commonly used, the plus sign indicates the identity of thevalue. We can use the plus sign with positive values:i = 3.3print(+i)Output3.3When we use the plus sign with a negative value, it will also return theidentity of that value, and in this case it would be a negative value:j = -19print(+j)Output-19With a negative value the plus sign returns the same negative value.The minus sign, alternatively, changes the sign of a value. So, when wepass a positive value we’ll ﬁnd that the minus sign before the value willreturn a negative value:i = 3.3
print(-i)Output-3.3Alternatively, when we use the minus sign unary operator with anegative value, a positive value will be returned:j = -19print(-j)Output19The unary arithmetic operations indicated by the plus sign and minussign will return either the value’s identity in the case of +i, or theopposite sign of the value as in -i.Multiplication and DivisionLike addition and subtraction, multiplication and division will look verysimilar to how they do in mathematics. The sign we’ll use in Python formultiplication is * and the sign we’ll use for division is /.Here’s an example of doing multiplication in Python with two ﬂoatvalues:k = 100.1l = 10.1
print(k * l)Output1011.0099999999999When you divide in Python 3, your quotient will always be returned asa ﬂoat, even if you use two integers:m = 80n = 5print(m / n)Output16.0This is one of the major changes between Python 2 and Python 3.Python 3’s approach provides a fractional answer so that when you use /to divide 11 by 2 the quotient of 5.5 will be returned. In Python 2 thequotient returned for the expression 11 / 2 is 5.Python 2’s / operator performs ﬂoor division, where for the quotient xthe number returned is the largest integer less than or equal to x. If yourun the above example of print(80 / 5) with Python 2 instead ofPython 3, you’ll receive 16 as the output without the decimal place.In Python 3, you can use // to perform ﬂoor division. The expression 100 // 40 will return the value of 2. Floor division is useful when youneed a quotient to be in whole numbers.
ModuloThe % operator is the modulo, which returns the remainder rather thanthe quotient after division. This is useful for ﬁnding numbers that aremultiples of the same number, for example.Let’s look at the modulo in action:o = 85p = 15print(o % p)Output10To break this down, 85 divided by 15 returns the quotient of 5 with aremainder of 10. The value 10 is what is returned here because themodulo operator returns the remainder of a division expression.If we use two ﬂoats with the modulo, a ﬂoat value will be returned forthe remainder:q = 36.0r = 6.0print(o % p)Output0.0
In the case of 36.0 divided by 6.0, there is no remainder, so the value of 0.0 is returned.PowerThe ** operator in Python is used to raise the number on the left to thepower of the exponent of the right. That is, in the expression 5 ** 3, 5 isbeing raised to the 3rd power. In mathematics, we often see thisexpression rendered as 5³, and what is really going on is 5 is beingmultiplied by itself 3 times. In Python, we would get the same result of 125 by running either 5 ** 3 or 5 * 5 * 5.Let’s look at an example with variables:s = 52.25t = 7print(s ** t)1063173305051.292Raising the ﬂoat 52.25 to the power of 7 through the ** operatorresults in a large ﬂoat value returned.Operator PrecedenceIn Python, as in mathematics, we need to keep in mind that operatorswill be evaluated in order of precedence, not from left to right or right toleft.If we look at the following expression:
u = 10 + 10 * 5We may read it left to right, but remember that multiplication will bedone ﬁrst, so if we call print(u), we will receive the following value:Output60This is because 10 * 5 evaluates to 50, and then we add 10 to return 60 as the ﬁnal result.If instead we would like to add the value 10 to 10, then multiply thatsum by 5, we can use parentheses just like we would in math:u = (10 + 10) * 5print(u)Output100One way to remember the order of operation is through the acronymPEMDAS:ORDERLETTERSTANDS FOR1PParentheses2EExponent3MMultiplication4DDivision
5AAddition6SSubtractionYou may be familiar with another acronym for the order of operations,such as BEDMAS or BODMAS. Whatever acronym works best for you,try to keep it in mind when performing math operations in Python sothat the results that you expect are returned.Assignment OperatorsThe most common assignment operator is one you have already used:the equals sign =. The = assignment operator assigns the value on theright to a variable on the left. For example, v = 23 assigns the value ofthe integer 23 to the variable v.When programming, it is common to use compound assignmentoperators that perform an operation on a variable’s value and then assignthe resulting new value to that variable. These compound operatorscombine an arithmetic operator with the = operator, so for addition we’llcombine + with = to get the compound operator +=. Let’s see what thatlooks like:w = 5w += 1print(w)Output6
First, we set the variable w equal to the value of 5, then we used the +=compound assignment operator to add the right number to the value ofthe left variable and then assign the result to w.Compound assignment operators are used frequently in the case of forloops, which you’ll use when you want to repeat a process several times:for x in range (0, 7):    x *= 2    print(x)Output024681012With the for loop, we were able to automate the process of the *=operator that multiplied the variable w by the number 2 and thenassigned the result in the variable w for the next iteration of the for loop.Python has a compound assignment operator for each of the arithmeticoperators discussed in this tutorial:y += 1          # add then assign valuey -= 1          # subtract then assign value
y *= 2          # multiply then assign valuey /= 3          # divide then assign valuey // = 5        # floor divide then assign valuey **= 2         # increase to the power of then assign valuey %= 3          # return remainder then assign valueCompound assignment operators can be useful when things need to beincrementally increased or decreased, or when you need to automatecertain processes in your program.ConclusionThis tutorial covered many of the operators you’ll use with the integerand ﬂoat numeric data types. If you would like to keep reading aboutnumbers in Python, you can continue onto Built-in Python 3 Functionsfor Working with Numbers.To learn more about other data types, take a look at UnderstandingData Types in Python 3, and learn about how to convert data types byreading How To Convert Data Types in Python 3.
Built-in Python 3 Functions for Working withNumbersPython 3 comes with many built-in functions that you can readily use inany program that you’re working on. Some functions enable you toconvert data types, and others are speciﬁc to a certain type, like strings.This tutorial will go through a few of the built-in functions that can beused with numeric data types in Python 3. We’ll go over the followingfunctions: - abs() for absolute value - divmod() to ﬁnd a quotient andremainder simultaneously - pow() to raise a number to a certain power - round() to round a number to a certain decimal point - sum() tocalculate the sum of the items in an iterable data typeBecoming familiar with these methods can give you more ﬂexibilitywhen programming so that you can make informed decisions whendeciding what operators and functions to use. We’ll go through some ofthese functions with examples throughout this tutorial.Absolute ValueThe built-in function abs() will return the absolute value of a numberthat you pass to it. In mathematics, absolute value refers to the distancethat a number is on the number line from 0. Absolute value does not takeinto consideration which direction from zero the number lies, meaningthat negative numbers will be represented with positive numbers.To give some examples, the absolute value of 15 is 15, the absolutevalue of -74 is 74, and the absolute value of 0 is 0.Absolute value is an important concept for calculus and real analysis,but it also makes sense when we think about everyday situations like
distance travelled. For example, if we are trying to get somewhere that is58 miles away but we travel 93 miles instead, we overshot our originaldestination. If we want to calculate now how many miles left to travel toget to the intended destination, we’ll end up with a negative number, butwe can’t travel negative miles.Let’s use abs() to solve this problem:destination_miles.pymiles_from_origin = 58  # Miles destination is from originmiles_travelled = 93    # Miles travelled from origin to destination (too many)# Calculate how many miles destination is from current location:miles_to_go = miles_from_origin - miles_travelledprint(miles_to_go)      # Print how many miles left (a negative number)print(abs(miles_to_go)) # Use absolute value to account for negative numberOutput-3535In the output, we see that if we don’t use the abs() function, in thisinstance we have a negative number, -35. Though we may be in a
position where miles_travelled is less than miles_from_origin,including the abs() function takes the possibility of a negative numberinto account.With a negative number, abs() will return a positive number asabsolute values are always positive numbers or zero.Let’s go through using abs() with a positive number and zero:print(abs(89.9))print(abs(0))Output89.90We’re most likely to use abs() with a variable that may be positive ornegative in an instance when we are looking only for a positive number.To account for a negative input or result, we’ll use abs() to modify whatis returned to be a positive number.Finding the Quotient and Remainder in One FunctionBecause both ﬂoor division (which returns a quotient), and modulodivision (which returns a remainder), are closely related, it can be usefulto use a function that combines both operations at once.The Python built-in function divmod() combines the two, returningﬁrst the quotient that comes from ﬂoor division, then the remainder.Because divmod() will be working with two numbers, we need topass two numbers to it.
divmod(a,b)With this function we are basically performing the following:a // ba & bLet’s say we have written a book that is 80,000 words long. With ourpublisher, we have the option of either 300 or 250 words per page, andwe’d like to get a sense of how many pages we would have in each case.With divmod() we can see immediately how many pages we wouldhave, and how many words would be spilled over onto an additionalpage.words_per_page.pywords = 80000       # How many words in our bookper_page_A = 300    # Option A, 300 words per pageper_page_B = 250    # Option B, 25- words per pageprint(divmod(words,per_page_A)) # Calculate Option Aprint(divmod(words,per_page_B)) # Calculate Option BOutput(266, 200)(320, 0)In Option A, we will have 266 pages ﬁlled with words and 200 wordsleft over (⅔ of a page) for a total of 267 pages, and in Option B we’ll have
an even 320-page book. If we want to be environmentally-conscious, wecan choose Option A, but if we want to look more impressive with abigger-sized book we may choose Option B.Because the function divmod() can take both integers and ﬂoats, let’salso go through an example that uses ﬂoats:a = 985.5b = 115.25print(divmod(a,b))Output(8.0, 63.5)In this example, 8.0 is the ﬂoor quotient of 985.5 divided by 115.25,and 63.5 is the remainder.Keep in mind that you can use the ﬂoor division operator // and themodulo operator % to verify what divmod() did:print(a//b)print(a%b)Output8.063.5When using the divmod() function in Python. we get both the wholenumber of times the division occurs and the remainder returned.
PowerIn Python, you can use the operator ** to raise a number by an exponent,or you can use the built-in function pow() which takes in two numbers.To see how the pow() function works, let’s say we are doing researchon bacteria and want to see how many bacteria we’ll have at the end ofthe day if we start with 1. The particular bacteria we’re working withdoubles each hour, so we’ll be calculating 2 (doubling) to the power ofthe total number of hours (24 in our case).bacteria.pyhours = 24total_bacteria = pow(2,hours)print(total_bacteria)Output16777216We passed two integers to the pow() function and determined that bythe end of this 24-hour period, we’ll have over 16 million bacteria.In mathematics, if we want to calculate 3 to the power of 3, it isgenerally written like this:3³The computation that we are completing is 3 x 3 x 3, which is equal to27.To calculate 3³ in Python, we would type out pow(3,3).
The function pow() will take both integers and ﬂoats, and provides analternative to using the ** operator when you intend to raise numbers toa certain power.Rounding NumbersBeing able to quickly and readily round numbers becomes importantwhen working with ﬂoats that have a lot of decimal places. The built-inPython function round() takes in two numbers, one to be rounded, andone that speciﬁes the number of decimal places to include.We’ll use the function to take a ﬂoat with more than 10 decimal placesand use the round() function to reduce decimal places to 4:i = 17.34989436516001print(round(i,4))Output17.3499In the example above, the ﬂoat 17.34989436516001 is rounded to 17.3499 because we have speciﬁed that the number of decimal placesshould be limited to 4.Note also that the round() function rounds numbers up, so instead ofproviding 17.3498 as the output, it has provided 17.3499 because thenumber following the decimal number 8 is the number 9. Any numberthat is followed by the number 5 or greater will be rounded up to thenext whole number.Let’s break down the syntax for round():
round(number to round,number of decimal places)In everyday life, rounding numbers happens often, especially whenworking with money; we can’t split up a penny evenly among severalfriends.Let’s go through an example of a simple program that can calculate atip. Here we’ll provide ﬁgures, but we could rewrite the program tobring in user-provided numbers instead. In this example, 3 friends wentto a restaurant who want to split a bill of $87.93 evenly, along withadding a 20% tip.bill_split.pybill = 87.93                # Total billtip = 0.2                   # 20% tipsplit = 3                   # Number of people splitting the billtotal = bill + (bill * tip) # Calculate the total billeach_pay = total / split    # Calculate what each person paysprint(each_pay)             # What each person pays before roundedprint(round(each_pay,2))    # Round the number — we can’t split pennies
Output35.17200000000000435.17In this program, we ask ﬁrst for output of the number after wecalculate the total bill plus tip divided by 3, which evaluates to a numberwith a lot of decimal places: 35.172000000000004. Since this numberdoesn’t make sense as a monetary ﬁgure, we use the round() functionand limit the decimal places to 2, so that we can provide an output thatthe 3 friends can actually work with: 35.17.If you would prefer to round to a number with only 0 as a decimalvalue, you can do so by using 0 as the second parameter in the round()function:round(345.9874590348545304636,0)This would evaluate to 346.0.You can also pass integers into round() without receiving an error, incase you receive user input in the form of an integer rather than a ﬂoat.When an integer is passed as the ﬁrst parameter, an integer will bereturned.Calculating a SumThe sum() function is used for calculating sums of numeric compounddata types, including lists, tuples, and dictionaries.We can pass a list to the sum() function to add all the items in the listtogether in order from left to right:
some_floats = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]print(sum(some_floats))Output49.5This will work similarly with tuples and dictionaries:print(sum((8,16,64,512)))   # Calculate sum of numbers in tupleprint(sum({-10: 'x', -20: 'y', -30: 'z'}))  # Calculate sum of numbers in dictionaryOutput600 # Sum of numbers in tuple-60 # Sum of numbers in dictionaryThe sum() function can take up to 2 arguments, so you can add anadditional number in integer or ﬂoat form to add to the numbers thatmake up the argument in the ﬁrst position:some_floats = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]print(sum(some_floats, 0.5))print(sum({-10: 'x', -20: 'y', -30: 'z'},60))
Output50.00When you don’t include a second argument, the sum() functiondefaults to adding 0 to the iterable compound data type.ConclusionThis tutorial covered some built-in methods that you can use withnumeric data types in the Python programming language.To learn more about working with numbers, you can read “How To DoMath in Python 3 with Operators”, and to learn more about lists, take alook at “Understanding Lists in Python 3.”
Understanding Boolean LogicThe Boolean data type can be one of two values, either True or False. Weuse Booleans in programming to make comparisons and to control theﬂow of the program.Booleans represent the truth values that are associated with the logicbranch of mathematics, which informs algorithms in computer science.Named for the mathematician George Boole, the word Boolean alwaysbegins with a capitalized B. The values True and False will also alwaysbe with a capital T and F respectively, as they are special values inPython.In this tutorial, we’ll go over the basics you’ll need to understand howBooleans work, including Boolean comparison and logical operators, andtruth tables.Comparison OperatorsIn programming, comparison operators are used to compare values andevaluate down to a single Boolean value of either True or False.The table below shows Boolean comparison operators.OPERATORWHAT IT MEANS==Equal to!=Not equal to<Less than>Greater than
<=Less than or equal to>=Greater than or equal toTo understand how these operators work, let’s assign two integers totwo variables in a Python program:x = 5y = 8We know that in this example, since x has the value of 5, it is less than y which has the value of 8.Using those two variables and their associated values, let’s go throughthe operators from the table above. In our program, we’ll ask Python toprint out whether each comparison operator evaluates to either True orFalse. To help us and other humans better understand this output, we’llhave Python also print a string to show us what it’s evaluating.x = 5y = 8print("x == y:", x == y)print("x != y:", x != y)print("x < y:", x < y)print("x > y:", x > y)print("x <= y:", x <= y)print("x >= y:", x >= y)Output
x == y: Falsex != y: Truex < y: Truex > y: Falsex <= y: Truex >= y: FalseFollowing mathematical logic, in each of the expressions above, Pythonhas evaluated:Is 5 (x) equal to 8 (y)? FalseIs 5 not equal to 8? TrueIs 5 less than 8? TrueIs 5 greater than 8? FalseIs 5 less than or equal to 8? TrueIs 5 not less than or equal to 8? FalseAlthough we used integers here, we could substitute them with ﬂoatvalues.Strings can also be used with Boolean operators. They are case-sensitive unless you employ an additional string method.We can look at how strings are compared in practice:Sammy = "Sammy"sammy = "sammy"print("Sammy == sammy: ", Sammy == sammy)
OutputSammy == sammy:  FalseThe string "Sammy" above is not equal to the string "sammy", becausethey are not exactly the same; one starts with an upper-case S and theother with a lower-case s. But, if we add another variable that is assignedthe value of "Sammy", then they will evaluate to equal:Sammy = "Sammy"sammy = "sammy"also_Sammy = "Sammy"print("Sammy == sammy: ", Sammy == sammy)print("Sammy == also_Sammy", Sammy == also_Sammy)OutputSammy == sammy:  FalseSammy == also_Sammy:  TrueYou can also use the other comparison operators including > and < tocompare two strings. Python will compare these strings lexicographicallyusing the ASCII values of the characters.We can also evaluate Boolean values with comparison operators:t = Truef = Falseprint("t != f: ", t != f)
Outputt != f:  TrueThe above code block evaluated that True is not equal to False.Note the difference between the two operators = and ==.x = y   # Sets x equal to yx == y  # Evaluates whether x is equal to yThe ﬁrst, = is the assignment operator, which will set one value equalto another. The second, == is a comparison operator which will evaluatewhether two values are equal.Logical OperatorsThere are three logical operators that are used to compare values. Theyevaluate expressions down to Boolean values, returning either True or False. These operators are and, or, and not and are deﬁned in the tablebelow.OPERATORWHAT IT MEANSWHAT IT LOOKS LIKEandTrue if both are truex and yorTrue if at least one is truex or ynotTrue only if falsenot xLogical operators are typically used to evaluate whether two or moreexpressions are true or not true. For example, they can be used todetermine if the grade is passing and that the student is registered in the
course, and if both cases are true then the student will be assigned agrade in the system. Another example would be to determine whether auser is a valid active customer of an online shop based on whether theyhave store credit or have made a purchase in the past 6 months.To understand how logical operators work, let’s evaluate threeexpressions:print((9 > 7) and (2 < 4))  # Both original expressions are Trueprint((8 == 8) or (6 != 6)) # One original expression is Trueprint(not(3 <= 1))          # The original expression is FalseOutputTrueTrueTrueIn the ﬁrst case, print((9 > 7) and (2 < 4)), both 9 > 7 and 2 < 4 needed to evaluate to True since the and operator was being used.In the second case, print((8 == 8) or (6 != 6)), since 8 == 8evaluated to True, it did not make a difference that 6 != 6 evaluates toFalse because the or operator was used. If we had used the and operator,this would evaluate to False.In the third case, print(not(3 <= 1)), the not operator negatesthe False value that 3 <=1 returns.Let’s substitute ﬂoats for integers and aim for False evaluations:
print((-0.2 > 1.4) and (0.8 < 3.1)) # One original expression is Falseprint((7.5 == 8.9) or (9.2 != 9.2)) # Both original expressions are False       print(not(-5.7 <= 0.3))             # The original expression is TrueIn the example above, - and must have at least one False expressionevaluate to False, - or must have both expressions evaluate to False, - not must have its inner expression be True for the new expression toevaluate to False.If the results above seem unclear to you, we’ll go through some truthtables below to get you up to speed.You can also write compound statements using and, or, and not:not((-0.2 > 1.4) and ((0.8 < 3.1) or (0.1 == 0.1)))Let’s look at the inner-most expression ﬁrst: (0.8 < 3.1) or (0.1 == 0.1). This expression evaluates to True because both mathematicalstatements are True.Now, we can take the returned value True and combine it with thenext inner expression: (-0.2 > 1.4) and (True). This examplereturns False because the mathematical statement -0.2 > 1.4 isFalse, and (False) and (True) returns False.Finally, we have the outer expression: not(False), which evaluatesto True, so the ﬁnal returned value if we print this statement out is:Output
TrueThe logical operators and, or, and not evaluate expressions andreturn Boolean values.Truth TablesThere is a lot to learn about the logic branch of mathematics, but we canselectively learn some of it to improve our algorithmic thinking whenprogramming.Below are truth tables for the comparison operator ==, and each of thelogic operators and, or, and not. While you may be able to reason themout, it can also be helpful to work to memorize them as that can makeyour programming decision-making process quicker.== Truth TableX==YRETURNSTrue==TrueTrueTrue==FalseFalseFalse==TrueFalseFalse==FalseTrueAND Truth TableXANDYRETURNSTrueandTrueTrueTrueandFalseFalse
FalseandTrueFalseFalseandFalseFalseOR Truth TableXORYRETURNSTrueorTrueTrueTrueorFalseTrueFalseorTrueTrueFalseorFalseFalseNOT Truth TableNOTXRETURNSnotTrueFalsenotFalseTrueTruth tables are common mathematical tables used in logic, and areuseful to memorize or keep in mind when constructing algorithms(instructions) in computer programming.Using Boolean Operators for Flow ControlTo control the stream and outcomes of a program in the form of ﬂowcontrol statements, we can use a condition followed by a clause.A condition evaluates down to a Boolean value of True or False,presenting a point where a decision is made in the program. That is, a
condition would tell us if something evaluates to True or False.The clause is the block of code that follows the condition and dictatesthe outcome of the program. That is, it is the do this part of theconstruction “If x is True, then do this.”The code block below shows an example of comparison operatorsworking in tandem with conditional statements to control the ﬂow of aPython program:if grade >= 65:                 # Condition    print("Passing grade")      # Clauseelse:    print("Failing grade")This program will evaluate whether each student’s grade is passing orfailing. In the case of a student with a grade of 83, the ﬁrst statement willevaluate to True, and the print statement of Passing grade will betriggered. In the case of a student with a grade of 59, the ﬁrst statementwill evaluate to False, so the program will move on to execute the printstatement tied to the else expression: Failing grade.Because every single object in Python can be evaluated to True or False,the PEP 8 Style Guide recommends against comparing a value to True orFalse because it is less readable and will frequently return anunexpected Boolean. That is, you should avoid using if sammy == True: in your programs. Instead, compare sammy to another non-Boolean value that will return a Boolean.Boolean operators present conditions that can be used to decide theeventual outcome of a program through ﬂow control statements.
ConclusionThis tutorial went through comparison and logical operators belongingto the Boolean type, as well as truth tables and using Booleans forprogram ﬂow control.You can learn more about other data types in our “Understanding DataTypes” tutorial, and can read about conditional statements in our “HowTo Write Conditional Statements tutorial.
Understanding ListsA list is a data structure in Python that is a mutable, or changeable,ordered sequence of elements. Each element or value that is inside of alist is called an item. Just as strings are deﬁned as characters betweenquotes, lists are deﬁned by having values between square brackets [ ].Lists are great to use when you want to work with many relatedvalues. They enable you to keep data together that belongs together,condense your code, and perform the same methods and operations onmultiple values at once.When thinking about Python lists and other data structures that aretypes of collections, it is useful to consider all the different collections youhave on your computer: your assortment of ﬁles, your song playlists,your browser bookmarks, your emails, the collection of videos you canaccess on a streaming service, and more.To get started, let’s create a list that contains items of the string datatype:sea_creatures = ['shark', 'cuttlefish', 'squid', 'mantis shrimp', 'anemone']When we print out the list, the output looks exactly like the list wecreated:print(sea_creatures)Output
['shark', 'cuttlefish', 'squid', 'mantis shrimp', 'anemone']As an ordered sequence of elements, each item in a list can be calledindividually, through indexing. Lists are a compound data type made upof smaller parts, and are very ﬂexible because they can have valuesadded, removed, and changed. When you need to store a lot of values oriterate over values, and you want to be able to readily modify thosevalues, you’ll likely want to work with list data types.In this tutorial, we’ll go through some of the ways that we can workwith lists in Python.Indexing ListsEach item in a list corresponds to an index number, which is an integervalue, starting with the index number 0.For the list sea_creatures, the index breakdown looks like this:‘SHARK’‘CUTTLEFISH’‘SQUID’‘MANTIS SHRIMP’‘ANEMONE’01234The ﬁrst item, the string 'shark' starts at index 0, and the list ends atindex 4 with the item 'anemone'.Because each item in a Python list has a corresponding index number,we’re able to access and manipulate lists in the same ways we can withother sequential data types.Now we can call a discrete item of the list by referring to its indexnumber:
print(sea_creatures[1])OutputcuttlefishThe index numbers for this list range from 0-4, as shown in the tableabove. So to call any of the items individually, we would refer to theindex numbers like this:sea_creatures[0] = 'shark'sea_creatures[1] = 'cuttlefish'sea_creatures[2] = 'squid'sea_creatures[3] = 'mantis shrimp'sea_creatures[4] = 'anemone'If we call the list sea_creatures with an index number of any that isgreater than 4, it will be out of range as it will not be valid:print(sea_creatures[18])OutputIndexError: list index out of rangeIn addition to positive index numbers, we can also access items fromthe list with a negative index number, by counting backwards from theend of the list, starting at -1. This is especially useful if we have a longlist and we want to pinpoint an item towards the end of a list.
For the same list sea_creatures, the negative index breakdownlooks like this:‘SHARK’‘CUTTLEFISH’‘SQUID’‘MANTIS SHRIMP’‘ANEMONE’-5-4-3-2-1So, if we would like to print out the item 'squid' by using itsnegative index number, we can do so like this:print(sea_creatures[-3])OutputsquidWe can concatenate string items in a list with other strings using the +operator:print('Sammy is a ' + sea_creatures[0])OutputSammy is a sharkWe were able to concatenate the string item at index number 0 with thestring 'Sammy is a '. We can also use the + operator to concatenate 2or more lists together.With index numbers that correspond to items within a list, we’re ableto access each item of a list discretely and work with those items.
Modifying Items in ListsWe can use indexing to change items within the list, by setting an indexnumber equal to a different value. This gives us greater control over listsas we are able to modify and update the items that they contain.If we want to change the string value of the item at index 1 from 'cuttlefish' to 'octopus', we can do so like this:sea_creatures[1] = 'octopus'Now when we print sea_creatures, the list will be different:print(sea_creatures)Output['shark', 'octopus', 'squid', 'mantis shrimp', 'anemone']We can also change the value of an item by using a negative indexnumber instead:sea_creatures[-3] = 'blobfish'print(sea_creatures)Output['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone']
Now 'blobfish' has replaced 'squid' at the negative indexnumber of -3 (which corresponds to the positive index number of 2).Being able to modify items in lists gives us the ability to change andupdate lists in an efﬁcient way.Slicing ListsWe can also call out a few items from the list. Let’s say we would like tojust print the middle items of sea_creatures, we can do so by creatinga slice. With slices, we can call multiple values by creating a range ofindex numbers separated by a colon [x:y]:print(sea_creatures[1:4])Output['octopus', 'blobfish', 'mantis shrimp']When creating a slice, as in [1:4], the ﬁrst index number is where theslice starts (inclusive), and the second index number is where the sliceends (exclusive), which is why in our example above the items atposition, 1, 2, and 3 are the items that print out.If we want to include either end of the list, we can omit one of thenumbers in the list[x:y] syntax. For example, if we want to print theﬁrst 3 items of the list sea_creatures — which would be 'shark', 'octopus', 'blobfish' — we can do so by typing:print(sea_creatures[:3])Output
['shark', 'octopus', 'blobfish']This printed the beginning of the list, stopping right before index 3.To include all the items at the end of a list, we would reverse thesyntax:print(sea_creatures[2:])Output['blobfish', 'mantis shrimp', 'anemone']We can also use negative index numbers when slicing lists, just likewith positive index numbers:print(sea_creatures[-4:-2])print(sea_creatures[-3:])Output['octopus', 'blobfish']['blobfish', 'mantis shrimp', 'anemone']One last parameter that we can use with slicing is called stride, whichrefers to how many items to move forward after the ﬁrst item is retrievedfrom the list. So far, we have omitted the stride parameter, and Pythondefaults to the stride of 1, so that every item between two index numbersis retrieved.The syntax for this construction is list[x:y:z], with z referring tostride. Let’s make a larger list, then slice it, and give the stride a value of
2:numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]print(numbers[1:11:2])Output[1, 3, 5, 7, 9]Our construction numbers[1:11:2] prints the values between indexnumbers inclusive of 1 and exclusive of 11, then the stride value of 2tells the program to print out only every other item.We can omit the ﬁrst two parameters and use stride alone as aparameter with the syntax list[::z]:print(numbers[::3])Output[0, 3, 6, 9, 12]By printing out the list numbers with the stride set to 3, only everythird item is printed:0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12Slicing lists with both positive and negative index numbers andindicating stride provides us with the control to manipulate lists andreceive the output we’re trying to achieve.Modifying Lists with Operators
Operators can be used to make modiﬁcations to lists. We’ll look at usingthe + and * operators and their compound forms += and *=.The + operator can be used to concatenate two or more lists together:sea_creatures = ['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone']oceans = ['Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic']print(sea_creatures + oceans)Output['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic']Because the + operator can concatenate, it can be used to add an item(or several) in list form to the end of another list. Remember to place theitem in square brackets:sea_creatures = sea_creatures + ['yeti crab']print (sea_creatures)Output['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab']
The * operator can be used to multiply lists. Perhaps you need to makecopies of all the ﬁles in a directory onto a server, or share a playlist withfriends — in these cases you would need to multiply collections of data.Let’s multiply the sea_creatures list by 2 and the oceans list by 3:print(sea_creatures * 2)print(oceans * 3)Output['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab', 'shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab']['Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic', 'Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic', 'Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic']By using the * operator we can replicate our lists by the number oftimes we specify.We can also use compound forms of the + and * operators with theassignment operator =. The += and *= compound operators can be usedto populate lists in a quick and automated way. You can use theseoperators to ﬁll in lists with placeholders that you can modify at a latertime with user-provided input, for example.Let’s add an item in list form to the list sea_creatures. This itemwill act as a placeholder, and we’d like to add this placeholder itemseveral times. To do this, we’ll use the += operator with a for loop.
for x in range(1,4):    sea_creatures += ['fish']    print(sea_creatures)Output['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab', 'fish']['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab', 'fish', 'fish']['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab', 'fish', 'fish', 'fish']For each iteration of the for loop, an extra list item of 'fish' is addedto the original list sea_creatures.The *= operator behaves in a similar way:sharks = ['shark']for x in range(1,4):    sharks *= 2    print(sharks)Output['shark', 'shark']['shark', 'shark', 'shark', 'shark']['shark', 'shark', 'shark', 'shark', 'shark', 'shark', 'shark', 'shark']
The operators + and * can be used to concatenate lists and multiplylists. The compound operators += and *= can concatenate lists andmultiply lists and pass the new identity to the original list.Removing an Item from a ListItems can be removed from lists by using the del statement. This willdelete the value at the index number you specify within a list.From the sea_creatures list, let’s remove the item 'octopus'. Thisitem is located at the index position of 1. To remove the item, we’ll usethe del statement then call the list variable and the index number of thatitem:sea_creatures =['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab']del sea_creatures[1]print(sea_creatures)Output['shark', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab']Now the item at index position 1, the string 'octopus', is no longerin our list sea_creatures.We can also specify a range with the del statement. Say we wanted toremove not only the item 'octopus', but also 'blobfish' and 'mantis shrimp' as well. We can call a range in sea_creatureswith the del statement to accomplish this:
sea_creatures =['shark', 'octopus', 'blobfish', 'mantis shrimp', 'anemone', 'yeti crab']del sea_creatures[1:4]print(sea_creatures)Output['shark', 'anemone', 'yeti crab']By using a range with the del statement, we were able to remove theitems between the index number of 1 (inclusive), and the index numberof 4 (exclusive), leaving us with a list of 3 items following the removal of3 items.The del statement allows us to remove speciﬁc items from the list datatype.Constructing a List with List ItemsLists can be deﬁned with items that are made up of lists, with eachbracketed list enclosed inside the larger brackets of the parent list:sea_names = [['shark', 'octopus', 'squid', 'mantis shrimp'],['Sammy', 'Jesse', 'Drew', 'Jamie']]These lists within lists are called nested lists.To access an item within this list, we will have to use multiple indices:print(sea_names[1][0])print(sea_names[0][0])
OutputSammysharkThe ﬁrst list, since it is equal to an item, will have the index number of0, which will be the ﬁrst number in the construction, and the second listwill have the index number of 1. Within each inner nested list there willbe separate index numbers, which we will call in the second indexnumber:sea_names[0][0] = 'shark'sea_names[0][1] = 'octopus'sea_names[0][2] = 'squid'sea_names[0][3] = 'mantis shrimp'sea_names[1][0] = 'Sammy'sea_names[1][1] = 'Jesse'sea_names[1][2] = 'Drew'sea_names[1][3] = 'Jamie'When working with lists of lists, it is important to keep in mind thatyou’ll need to refer to more than one index number in order to accessspeciﬁc items within the relevant nested list.ConclusionThe list data type is a ﬂexible data type that can be modiﬁed throughoutthe course of your program. This tutorial covered the basic features oflists, including indexing, slicing, modifying, and concatenating lists.
From here, you can ﬁnd out more about working with lists in Pythonby reading “How To Use List Methods,” and about list comprehensionsto create lists based on existing lists. To learn more about data types ingeneral you can read our “Understanding Data Types” tutorial.
How To Use List MethodsPython 3 has a number of built-in data structures, including lists. Datastructures provide us with a way to organize and store data, and we canuse built-in methods to retrieve or manipulate that data.To get the most out of this tutorial, you should have some familiaritywith the list data type, its syntax, and how it is indexed. You can reviewlists by reading the tutorial Understanding Lists in Python 3.Here, we’ll go through the built-in methods that you can use to workwith lists. We’ll add items to and remove items from lists, extend lists,reverse and sort lists, and more.It is important to keep in mind that lists are mutable — or changeable— data types. Unlike strings, which are immutable, whenever you use amethod on a list you will be affecting the list itself and not a copy of thelist.For this tutorial, we’ll be working primarily with a list comprised of aninventory of various ﬁsh that we need to modify as ﬁsh are added to orremoved from a municipal aquarium.list.append()The method list.append(x) will add an item (x) to the end of a list.We’ll start with a list of our ﬁsh that are dispersed throughout theaquarium.fish = ['barracuda','cod','devil ray','eel']
This list is comprised of 4 string items, and their index numbers rangefrom 'barracuda' at 0 to 'eel' at index 3.We just got a new ﬁsh into the aquarium today, and we would like toadd that ﬁsh to our list. We’ll pass the string of our new ﬁsh type, 'flounder' into the list.append() method, and then print out ourmodiﬁed list to conﬁrm that the item was added.fish.append('flounder')print(fish)Output['barracuda', 'cod', 'devil ray', 'eel', 'flounder']Now, we have a list of 5 string items that ends with the item we passedto the .append() function.list.insert()The list.insert(i,x) method takes two arguments, with i being theindex position you would like to add an item to, and x being the itemitself.Our aquarium acquired another new ﬁsh, an anchovy. You may havenoticed that so far the list fish is in alphabetical order. Because of this,we don’t want to just add the string 'anchovy' to the end of fish withthe list.append() function. Instead, we’ll use list.insert() toadd 'anchovy' to the beginning of this list at index position 0:fish.insert(0,'anchovy')print(fish)
Output['anchovy', 'barracuda', 'cod', 'devil ray', 'eel', 'flounder']In this case, we added the string item to the front of the list. Each of thesuccessive items will now be at a new index number as they have allmoved down. Therefore, 'barracuda' will be at index 1, 'cod' will beat index 2, and 'flounder' — the last item — will be at index 5.If, at this point, we are bringing a damselﬁsh to the aquarium and wewanted to maintain alphabetical order based on the list above, we wouldput the item at index 3: fish.insert(3,'damselfish').list.extend()If we want to combine more than one list, we can use the list.extend(L) method, which takes in a second list as its argument.Our aquarium is welcoming four new ﬁsh from another aquarium thatis closing. We have these ﬁsh together in the list more_fish:more_fish = ['goby','herring','ide','kissing gourami']We’ll now add the items from the list more_fish to the list fish andprint the list to ensure that the second list was incorporated:fish.extend(more_fish)print(fish)Output['anchovy', 'barracuda', 'cod', 'devil ray', 'eel', 
'flounder', 'goby', 'herring', 'ide', 'kissing gourami']At this point, the list fish is comprised of 10 items.list.remove()When we need to remove an item from a list, we’ll use the list.remove(x) method which removes the ﬁrst item in a list whosevalue is equivalent to x.A group of local research scientists have come to visit the aquarium.They are doing research on the kissing gourami species of ﬁsh. They haverequested for us to loan our kissing gourami to them, so we’d like toremove the 'kissing gourami' item from the list to reﬂect thischange:fish.remove('kissing gourami')print(fish)Output['anchovy', 'barracuda', 'cod', 'devil ray', 'eel', 'flounder', 'goby', 'herring', 'ide']Following the use of the list.remove() method, our list no longerhas the 'kissing gourami' item.If you pass an item in for x in list.remove() that does not exist inthe list, you’ll receive the following error:Output
ValueError: list.remove(x): x not in listKeep in mind that list.remove() will only remove the ﬁrst instanceof the item you pass to it, so if we had two kissing gouramis at ouraquarium and we only loaned one to the scientists, we could use thesame construction of fish.remove('kissing gourami') and stillhave the second kissing gourami on our list.list.pop()We can use the list.pop([i]) method to return the item at the givenindex position from the list and then remove that item. The squarebrackets around the i for index tell us that this parameter is optional, soif we don’t specify an index (as in fish.pop()), the last item will bereturned and removed.Our devil ray has gotten too large for our aquarium, and thankfully anaquarium a few towns over can accommodate the ray’s needs. We’ll use .pop() and specify the index number (3) of the string item 'devil ray' to remove the item from our list, and through returning it we’llconﬁrm that we are removing the correct item.print(fish.pop(3))print(fish)Outputdevil ray['anchovy', 'barracuda', 'cod', 'eel', 'flounder', 'goby', 'herring', 'ide']
By using the .pop() method we were able to return and remove 'devil ray' from the list fish.If we were to pass no parameters to this method and perform fish.pop(), the last item 'ide' would be returned and then removedfrom the list.list.index()When lists start to get long, it becomes more difﬁcult for us to count outour items to determine at what index position a certain value is located.We can use list.index(x), where x is equivalent to an item value, toreturn the index in the list where that item is located. If there is more thanone item with value x, this method will return the ﬁrst index location.print(fish)print(fish.index('herring'))Output['anchovy', 'barracuda', 'cod', 'eel', 'flounder', 'goby', 'herring', 'ide']6Although the list fish is not very long, we’re still able to determinethe index position of the item 'herring' without counting. The indexof each item is very important to know so that we are able to manipulatelists effectively.We’ll receive an error if we specify a value with .index() and nosuch value exists in the given list: ValueError: 'x' is not in list.
list.copy()When we are working with a list and may want to manipulate it inmultiple ways while still having the original list available to usunchanged, we can use list.copy() to make a copy of the list.We’ll pass the value returned from fish.copy() to the variable fish_2, and then print out the value of fish_2 to ensure that it is a listwith the same items as fish.fish_2 = fish.copy()print(fish_2)Output['anchovy', 'barracuda', 'cod', 'eel', 'flounder', 'goby', 'herring', 'ide']At this point, both fish and fish_2 are equivalent lists.list.reverse()We can reverse the order of items in a list by using the list.reverse()method. Perhaps it is more convenient for us to use reverse alphabeticalorder rather than traditional alphabetical order. In that case, we need touse the .reverse() method with the fish list to have the list bereversed in place.fish.reverse()print(fish)
Output['ide', 'herring', 'goby', 'flounder', 'eel', 'cod', 'barracuda', 'anchovy']After using the .reverse() method, our list begins with the item 'ide', which was at the end of our list, and ends with 'anchovy',which was at the beginning of the list.list.count()The list.count(x) method will return the number of times the value x occurs within a speciﬁed list. We may want to use this method whenwe have a long list with a lot of matching values. If we had a largeraquarium, for example, and we had an item for each and every neontetra that we had, we could use .count() to determine the total numberof neon tetras we have at any given time.We’ll use our current list to count the number of times the item 'goby' appears:print(fish.count('goby'))Output1Because the string 'goby' appears only one time, the number 1 isreturned when we use the .count() method.Let’s also use this method with an integer list. Our aquarium iscommitted to providing great care for each and every ﬁsh, so we arekeeping track of how old each of our ﬁsh are so we can ensure that their
diets meet ﬁsh’s needs based on their ages. This second list, fish_agescorresponds to the type of ﬁsh from our other list, fish.Because 1-year-old ﬁsh have special dietary needs, we’re going tocount how many 1-year-old ﬁsh we have:fish_ages = [1,2,4,3,2,1,1,2]print(fish_ages.count(1))Output3The integer 1 occurs in the list fish_ages 3 times, so when we usethe .count() method, the number 3 is returned.list.sort()We can use the list.sort() method to sort the items in a list.Just like list.count(), list.sort() can make it more apparenthow many of a certain integer value we have, and it can also put anunsorted list of numbers into numeric order.Let’s use the integer list, fish_ages to see the .sort() method inaction:fish_ages.sort()print(fish_ages)Output[1, 1, 1, 2, 2, 2, 3, 4]
By using .sort() with fish_ages, the integer values are returned inorder. In practice, since these ages correspond to speciﬁc ﬁsh, you wouldlikely want to make a copy of the original list prior to sorting it.list.clear()When we’re done with a list, we can remove all values contained in it byusing the list.clear() method.The local government has decided to take over our aquarium, makingit a public space for the people in our city to enjoy. Since we’re no longerworking on the aquarium ourselves, we no longer need to keep aninventory of the ﬁsh, so let’s clear the fish list:fish.clear()print(fish)Output[]We receive square brackets as our output after using the .clear()function on fish, letting us know that the list is now clear of all items.ConclusionAs a mutable, or changeable, ordered sequence of elements, lists are veryﬂexible data structures in Python. List methods enable us to work withlists in a sophisticated manner. We can combine methods with otherways to modify lists in order to have a full range of tools to use listseffectively in our programs. From here, you can read about listcomprehensions to create lists based on existing lists.
Understanding List ComprehensionsList comprehensions offer a succinct way to create lists based on existinglists. When using list comprehensions, lists can be built by leveraging anyiterable, including strings and tuples.Syntactically, list comprehensions consist of an iterable containing anexpression followed by a for clause. This can be followed by additional for or if clauses, so familiarity with for loops and conditionalstatements will help you understand list comprehensions better.List comprehensions provide an alternative syntax to creating lists andother sequential data types. While other methods of iteration, such as for loops, can also be used to create lists, list comprehensions may bepreferred because they can limit the number of lines used in yourprogram.List ComprehensionsIn Python, list comprehensions are constructed like so:list_variable = [x for x in iterable]A list, or other iterable, is assigned to a variable. Additional variablesthat stand for items within the iterable are constructed around a forclause. The in keyword is used as it is in for loops, to iterate over the iterable.Let’s look at an example that creates a list based on a string:
shark_letters = [letter for letter in 'shark']print(shark_letters)Here, the new list is assigned to the variable shark_letters, and letter is used to stand in for the items contained in the iterable string 'shark'.For us to conﬁrm what the new list shark_letters looks like, wecall for it to print() and receive the following output:Output['s', 'h', 'a', 'r', 'k']The list we created with the list comprehension is comprised of theitems in the string 'shark', that is, one string for each letter.List comprehensions can be rewritten as for loops, though not every for loop is able to be rewritten as a list comprehension.Using our list comprehension that created the shark_letters listabove, let’s rewrite it as a for loop. This may help us better understandhow the list comprehension works.shark_letters = []for letter in 'shark':    shark_letters.append(letter)print(shark_letters)
When creating a list with a for loop, the variable assigned to the listneeds to be initialized with an empty list, as it is in the ﬁrst line of ourcode block. The for loop then iterates over the item, using the variable letter in the iterable string 'shark'. Within the for loop, each itemwithin the string is added to the list with the list.append(x) method.Rewriting the list comprehension as a for loop provides us with thesame output:Output['s', 'h', 'a', 'r', 'k']List comprehensions can be rewritten as for loops, and some forloops can be rewritten to be list comprehensions to make code moresuccinct.Using Conditionals with List ComprehensionsList comprehensions can utilize conditional statements to modify existinglists or other sequential data types when creating new lists.Let’s look at an example of an if statement used in a listcomprehension:fish_tuple = ('blowfish', 'clownfish', 'catfish', 'octopus')fish_list = [fish for fish in fish_tuple if fish != 'octopus']print(fish_list)
The list comprehension uses the tuple fish_tuple as the basis for thenew list called fish_list. The keywords of for and in are used, asthey were in the section above, and now an if statement is added. The if statement says to only add those items that are not equivalent to thestring 'octopus', so the new list only takes in items from the tuple thatdo not match 'octopus'.When we run this, we’ll see that fish_list contains the same stringitems as fish_tuple except for the fact that the string 'octopus' hasbeen omitted:Output['blowfish', 'clownfish', 'catfish']Our new list therefore has every item of the original tuple except forthe string that is excluded by the conditional statement.We’ll create another example that uses mathematical operators,integers, and the range() sequence type.number_list = [x ** 2 for x in range(10) if x % 2 == 0]print(number_list)The list that is being created, number_list, will be populated withthe squared values of each item in the range from 0-9 if the item’s value isdivisible by 2. The output is as follows:Output[0, 4, 16, 36, 64]
To break down what the list comprehension is doing a little more, let’sthink about what would be printed out if we were just calling x for x in range(10). Our small program and output would then look likethis:number_list = [x for x in range(10)]print(number_list)Output[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Now, let’s add the conditional statement:number_list = [x for x in range(10) if x % 2 == 0]print(number_list)Output[0, 2, 4, 6, 8]The if statement has limited the items in the ﬁnal list to only includethose items that are divisible by 2, omitting all of the odd numbers.Finally, we can add the operator to have each x squared:number_list = [x ** 2 for x in range(10) if x % 2 == 0]print(number_list)
So each of the numbers in the previous list of [0, 2, 4, 6, 8] arenow squared:Output[0, 4, 16, 36, 64]You can also replicate nested if statements with a list comprehension:number_list = [x for x in range(100) if x % 3 == 0 if x % 5 == 0]print(number_list)Here, the list comprehension will ﬁrst check to see if the number x isdivisible by 3, and then check to see if x is divisible by 5. If x satisﬁesboth requirements it will print, and the output is:Output[0, 15, 30, 45, 60, 75, 90]Conditional if statements can be used to control which items from anexisting sequence are included in the creation of a new list.Nested Loops in a List ComprehensionNested loops can be used to perform multiple iterations in our programs.This time, we’ll look at an existing nested for loop construction andwork our way towards a list comprehension.Our code will create a new list that iterates over 2 lists and performsmathematical operations based on them. Here is our nested for loop
code block:my_list = []for x in [20, 40, 60]:    for y in [2, 4, 6]:        my_list.append(x * y)print(my_list)When we run this code, we receive the following output:Output[40, 80, 120, 80, 160, 240, 120, 240, 360]This code is multiplying the items in the ﬁrst list by the items in thesecond list over each iteration.To transform this into a list comprehension, we will condense each ofthe lines of code into one line, beginning with the x * y operation. Thiswill be followed by the outer for loop, then the inner for loop. We’lladd a print() statement below our list comprehension to conﬁrm thatthe new list matches the list we created with our nested for loop blockabove:my_list = [x * y for x in [20, 40, 60] for y in [2, 4, 6]]print(my_list)
Output[40, 80, 120, 80, 160, 240, 120, 240, 360]Our list comprehension takes the nested for loops and ﬂattens theminto one line of code while still creating the exact same list to assign tothe my_list variable.List comprehensions provide us with a succinct way of making lists,enabling us to distill several lines of code into a single line. However, it isworth keeping in mind that the readability of our code should alwaystake precedence, so when a list comprehension line becomes too long orunwieldy, it may be best to break it out into loops.ConclusionList comprehensions allow us to transform one list or other sequence intoa new list. They provide a concise syntax for completing this task,limiting our lines of code.List comprehensions follow the mathematical form of set-buildernotation or set comprehension, so they may be particularly intuitive toprogrammers with a mathematical background.Though list comprehensions can make our code more succinct, it isimportant to ensure that our ﬁnal code is as readable as possible, so verylong single lines of code should be avoided to ensure that our code isuser friendly.
Understanding TuplesA tuple in Python looks like this:coral = ('blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral')A tuple is a data structure that is an immutable, or unchangeable,ordered sequence of elements. Because tuples are immutable, their valuescannot be modiﬁed.Tuples are used for grouping data. Each element or value that is insideof a tuple is called an item.Tuples have values between parentheses ( ) separated by commas ,.Empty tuples will appear as coral = (), but tuples with even onevalue must use a comma as in coral = ('blue coral',).If we print() the tuple above, we’ll receive the following output,with the tuple still typed by parentheses:print(coral)Output('blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral')When thinking about Python tuples and other data structures that aretypes of collections, it is useful to consider all the different collections youhave on your computer: your assortment of ﬁles, your song playlists,
your browser bookmarks, your emails, the collection of videos you canaccess on a streaming service, and more.Tuples are similar to lists, but their values can’t be modiﬁed. Because ofthis, when you use tuples in your code, you are conveying to others thatyou don’t intend for there to be changes to that sequence of values.Additionally, because the values do not change, your code can beoptimized through the use of tuples in Python, as the code will beslightly faster for tuples than for lists.Indexing TuplesAs an ordered sequence of elements, each item in a tuple can be calledindividually, through indexing.Each item corresponds to an index number, which is an integer value,starting with the index number 0.For the coral tuple, the index breakdown looks like this:‘BLUE CORAL’‘STAGHORN CORAL’‘PILLAR CORAL’‘ELKHORN CORAL’0123The ﬁrst item, the string 'blue coral' starts at index 0, and the listends at index 4 with the item 'elkhorn coral'.Because each item in a Python tuple has a corresponding indexnumber, we’re able to access items.Now we can call a discrete item of the tuple by referring to its indexnumber:print(coral[2])
Outputpillar coralThe index numbers for this tuple range from 0-3, as shown in the tableabove. So to call any of the items individually, we would refer to theindex numbers like this:coral[0] = 'blue coral'coral[1] = 'staghorn coral'coral[2] = 'pillar coral'coral[3] = 'elkhorn coral'If we call the tuple coral with an index number of any that is greaterthan 3, it will be out of range as it will not be valid:print(coral[22])OutputIndexError: tuple index out of rangeIn addition to positive index numbers, we can also access items fromthe tuple with a negative index number, by counting backwards from theend of the tuple, starting at -1. This is especially useful if we have a longtuple and we want to pinpoint an item towards the end of a tuple.For the same tuple coral, the negative index breakdown looks likethis:‘BLUE CORAL’‘STAGHORN CORAL’‘PILLAR CORAL’‘ELKHORN CORAL’
-4-3-2-1So, if we would like to print out the item 'blue coral' by using itsnegative index number, we can do so like this:print(coral[-4])Outputblue coralWe can concatenate string items in a tuple with other strings using the + operator:print('This reef is made up of ' + coral[1])OutputThis reef is made up of staghorn coralWe were able to concatenate the string item at index number 0 with thestring 'This reef is made up of '. We can also use the + operatorto concatenate 2 or more tuples together.With index numbers that correspond to items within a tuple, we’reable to access each item of a tuple discretely.Slicing TuplesWe can use indexing to call out a few items from the tuple. Slices allow usto call multiple values by creating a range of index numbers separated bya colon [x:y].
Let’s say we would like to just print the middle items of coral, we cando so by creating a slice.print(coral[1:3])Output('staghorn coral', 'pillar coral')When creating a slice, as in [1:3], the ﬁrst index number is where theslice starts (inclusive), and the second index number is where the sliceends (exclusive), which is why in our example above the items atposition, 1 and 2 are the items that print out.If we want to include either end of the list, we can omit one of thenumbers in the tuple[x:y] syntax. For example, if we want to print theﬁrst 3 items of the tuple coral — which would be 'blue coral', 'staghorn coral', 'pillar coral' — we can do so by typing:print(coral[:3])Output('blue coral', 'staghorn coral', 'pillar coral')This printed the beginning of the tuple, stopping right before index 3.To include all the items at the end of a tuple, we would reverse thesyntax:print(coral[1:])
Output('staghorn coral', 'pillar coral', 'elkhorn coral')We can also use negative index numbers when slicing tuples, just likewith positive index numbers:print(coral[-3:-1])print(coral[-2:])Output('staghorn coral', 'pillar coral')('pillar coral', 'elkhorn coral')One last parameter that we can use with slicing is called stride, whichrefers to how many items to move forward after the ﬁrst item is retrievedfrom the tuple.So far, we have omitted the stride parameter, and Python defaults tothe stride of 1, so that every item between two index numbers isretrieved.The syntax for this construction is tuple[x:y:z], with z referring tostride. Let’s make a larger list, then slice it, and give the stride a value of2:numbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)print(numbers[1:11:2])Output
(1, 3, 5, 7, 9)Our construction numbers[1:11:2] prints the values between indexnumbers inclusive of 1 and exclusive of 11, then the stride value of 2tells the program to print out only every other item.We can omit the ﬁrst two parameters and use stride alone as aparameter with the syntax tuple[::z]:print(numbers[::3])Output(0, 3, 6, 9, 12)By printing out the tuple numbers with the stride set to 3, only everythird item is printed:0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12Slicing tuples with both positive and negative index numbers andindicating stride provides us with the control to receive the output we’retrying to achieve.Concatenating and Multiplying TuplesOperators can be used to concatenate or multiply tuples. Concatenationis done with the + operator, and multiplication is done with the *operator.The + operator can be used to concatenate two or more tuples together.We can assign the values of two existing tuples to a new tuple:coral = ('blue coral', 'staghorn coral', 'pillar 
coral', 'elkhorn coral')kelp = ('wakame', 'alaria', 'deep-sea tangle', 'macrocystis')coral_kelp = (coral + kelp)print(coral_kelp)Output('blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral', 'wakame', 'alaria', 'deep-sea tangle', 'macrocystis')Because the + operator can concatenate, it can be used to combinetuples to form a new tuple, though it cannot modify an existing tuple.The * operator can be used to multiply tuples. Perhaps you need tomake copies of all the ﬁles in a directory onto a server or share a playlistwith friends — in these cases you would need to multiply collections ofdata.Let’s multiply the coral tuple by 2 and the kelp tuple by 3, andassign those to new tuples:multiplied_coral = coral * 2multiplied_kelp = kelp * 3print(multiplied_coral)print(multiplied_kelp)
Output('blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral', 'blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral')('wakame', 'alaria', 'deep-sea tangle', 'macrocystis', 'wakame', 'alaria', 'deep-sea tangle', 'macrocystis', 'wakame', 'alaria', 'deep-sea tangle', 'macrocystis')By using the * operator we can replicate our tuples by the number oftimes we specify, creating new tuples based on the original datasequence.Existing tuples can be concatenated or multiplied to form new tuplesthrough using the + and * operators.Tuple FunctionsThere are a few built-in functions that you can use to work with tuples.Let’s look at a few of them.len()Like with strings and lists, we can calculate the length of a tuple by usinglen(), where we pass the tuple as a parameter, as in:len(coral)This function is useful for when you need to enforce minimum ormaximum collection lengths, for example, or to compare sequenced data.If we print out the length for our tuples kelp and numbers, we’llreceive the following output:
print(len(kelp))print(len(numbers))Output413We receive the above output because the tuple kelp has 4 items:kelp = ('wakame', 'alaria', 'deep-sea tangle', 'macrocystis')And the tuple numbers has 13 items:numbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)Although these examples have relatively few items, the len()function provides us with the opportunity to see how many items are inlarge tuples.max() and min()When we work with tuples composed of numeric items, (includingintegers and ﬂoats) we can use the max() and min() functions to ﬁndthe highest and lowest values contained in the respective tuple.These functions allow us to ﬁnd out information about quantitativedata, such as test scores, temperatures, prices, etc.Let’s look at a tuple comprised of ﬂoats:
more_numbers = (11.13, 34.87, 95.59, 82.49, 42.73, 11.12, 95.57)To get the max(), we would pass the tuple into the function, as in max(more_numbers). We’ll combine this with the print() function sothat we can output our results:print(max(more_numbers))Output95.59The max() function returned the highest value in our tuple.Similarly, we can use the min() function:print(min(more_numbers))Output11.12Here, the smallest ﬂoat was found in the tuple and printed out.Just like with the len() function, the max() and min() functions canbe very useful when working with tuples that contain many values.How Tuples Differ from ListsThe primary way in which tuples are different from lists is that theycannot be modiﬁed. This means that items cannot be added to orremoved from tuples, and items cannot be replaced within tuples.
You can, however, concatenate 2 or more tuples to form a new tuple.Let’s consider our coral tuple:coral = ('blue coral', 'staghorn coral', 'pillar coral', 'elkhorn coral')Say we want to replace the item 'blue coral' with a different itemcalled 'black coral'. If we try to change that output the same waywe do with a list, by typing:coral[0] = 'black coral'We will receive an error as our output:OutputTypeError: 'tuple' object does not support item assignmentThis is because tuples cannot be modiﬁed.If we create a tuple and decide what we really need is a list, we canconvert it to a list. To convert a tuple to a list, we can do so with list():list(coral)And now, our coral data type will be a list:coral = ['blue coral', 'staghorn coral', 'pillar coral']
We can see that the tuple was converted to a list because theparentheses changed to square brackets.Likewise, we can convert lists to tuples with tuple().You can learn more about data type conversion by reading “How ToConvert Data Types in Python 3.”ConclusionThe tuple data type is a sequenced data type that cannot be modiﬁed,offering optimization to your programs by being a somewhat faster typethan lists for Python to process. When others collaborate with you onyour code, your use of tuples will convey to them that you don’t intendfor those sequences of values to be modiﬁed.This tutorial covered the basic features of tuples, including indexing,slicing and concatenating tuples, and showing built-in functions that areavailable.
Understanding DictionariesThe dictionary is Python’s built-in mapping type. Dictionaries map keysto values and these key-value pairs provide a useful way to store data inPython.Typically used to hold data that are related, such as the informationcontained in an ID or a user proﬁle, dictionaries are constructed withcurly braces on either side { }.A dictionary looks like this:sammy = {'username': 'sammy-shark', 'online': True, 'followers': 987}In addition to the curly braces, there are also colons (:) throughout thedictionary.The words to the left of the colons are the keys. Keys can be made upof any immutable data type. The keys in the dictionary above are: - 'username' - 'online' - 'followers'Each of the keys in the above example are string values.The words to the right of the colons are the values. Values can becomprised of any data type. The values in the dictionary above are: - 'sammy-shark' - True - 987Each of these values is either a string, Boolean, or integer.Let’s print out the dictionary sammy:print(sammy)
Output{'username': 'sammy-shark', 'followers': 987, 'online': True}Looking at the output, you may notice that the order of the key-valuepairs has shifted. That is because the dictionary data type is unordered.In this regard, dictionaries are unlike lists or tuples that preserve orderand can be indexed. Whenever you print out a dictionary, the order willbe arbitrary, but the key-value pairs will remain intact, enabling us toaccess data based on their relational meaning.Accessing Dictionary ElementsBecause the dictionary data structure is unordered, we cannot call itsvalues by an index number, as we can with lists and tuples. We can,however, call its values by referencing the related keys.Accessing Data Items with KeysBecause dictionaries offer key-value pairs for storing data, they can beimportant elements in your Python program.If we want to isolate Sammy’s username, we can do so by calling sammy['username']. Let’s print that out:print(sammy['username'])Outputsammy-shark
Dictionaries behave like a database in that instead of calling an integerto get a particular index value as you would with a list, you assign avalue to a key and can call that key to get its related value.By invoking the key 'username' we receive the value of that key,which is 'sammy-shark'.The remaining values in the sammy dictionary can similarly be calledusing the same format:sammy['followers']# Returns 987sammy['online']# Returns TrueBy making use of dictionaries’ key-value pairs, we can reference keysto retrieve values.Using Functions to Access ElementsIn addition to using keys to access values, we can also work with somebuilt-in functions: - dict.keys() isolates keys - dict.values()isolates values - dict.items() returns items in a list format of (key, value) tuple pairsTo return the keys, we would use the dict.keys() function. In ourexample, that would use the variable name and be sammy.keys(). Let’spass that to a print() function and look at the output:print(sammy.keys())
Outputdict_keys(['followers', 'username', 'online'])We receive output that places the keys within an iterable view object ofthe dict_keys class. The keys are then printed within a list format.This function can be used to query across dictionaries. For example, wecan take a look at the common keys shared between two dictionary datastructures:sammy = {'username': 'sammy-shark', 'online': True, 'followers': 987}jesse = {'username': 'JOctopus', 'online': False, 'points': 723}for common_key in sammy.keys() & jesse.keys():    print(sammy[common_key], jesse[common_key])The dictionary sammy and the dictionary jesse are each a user proﬁledictionary.Their proﬁles have different keys, however, because Sammy has asocial proﬁle with associated followers, and Jesse has a gaming proﬁlewith associated points. The 2 keys they have in common are usernameand online status, which we can ﬁnd when we run this small program:Outputsammy-shark JOctopusTrue False
We could certainly improve on the program to make the output moreuser-readable, but this illustrates that dict.keys() can be used tocheck across various dictionaries to see what they share in common ornot. This is especially useful for large dictionaries.Similarly, we can use the dict.values() function to query thevalues in the sammy dictionary, which would be constructed as sammy.values(). Let’s print those out:sammy = {'username': 'sammy-shark', 'online': True, 'followers': 987}print(sammy.values())Outputdict_values([True, 'sammy-shark', 987])Both the methods keys() and values() return unsorted lists of thekeys and values present in the sammy dictionary with the view objects of dict_keys and dict_values respectively.If we are interested in all of the items in a dictionary, we can accessthem with the items() function:print(sammy.items())Outputdict_items([('online', True), ('username', 'sammy-shark'), ('followers', 987)])
The returned format of this is a list made up of (key, value) tuplepairs with the dict_items view object.We can iterate over the returned list format with a for loop. Forexample, we can print out each of the keys and values of a givendictionary, and then make it more human-readable by adding a string:for key, value in sammy.items():    print(key, 'is the key for the value', value)Outputonline is the key for the value Truefollowers is the key for the value 987username is the key for the value sammy-sharkThe for loop above iterated over the items within the sammydictionary and printed out the keys and values line by line, withinformation to make it easier to understand by humans.We can use built-in functions to access items, values, and keys fromdictionary data structures.Modifying DictionariesDictionaries are a mutable data structure, so you are able to modify them.In this section, we’ll go over adding and deleting dictionary elements.Adding and Changing Dictionary ElementsWithout using a function, you can add key-value pairs to dictionaries byusing the following syntax:
dict[key] = valueWe’ll look at how this works in practice by adding a key-value pair to adictionary called usernames:usernames = {'Sammy': 'sammy-shark', 'Jamie': 'mantisshrimp54'}usernames['Drew'] = 'squidly'print(usernames)Output{'Drew': 'squidly', 'Sammy': 'sammy-shark', 'Jamie': 'mantisshrimp54'}We see now that the dictionary has been updated with the 'Drew': 'squidly' key-value pair. Because dictionaries are unordered, this paircan occur anywhere in the dictionary. If we use the usernamesdictionary later in our program ﬁle, it will include the additional key-value pair.Additionally, this syntax can be used for modifying the value assignedto a key. In this case, we’ll reference an existing key and pass a differentvalue to it.Let’s consider a dictionary drew that is one of the users on a givennetwork. We’ll say that this user got a bump in followers today, so weneed to update the integer value passed to the 'followers' key. We’lluse the print() function to check that the dictionary was modiﬁed.
drew = {'username': 'squidly', 'online': True, 'followers': 305}drew['followers'] = 342print(drew)Output{'username': 'squidly', 'followers': 342, 'online': True}In the output, we see that the number of followers jumped from theinteger value of 305 to 342.We can use this method for adding key-value pairs to dictionaries withuser-input. Let’s write a quick program, usernames.py that runs on thecommand line and allows input from the user to add more names andassociated usernames:usernames.py# Define original dictionaryusernames = {'Sammy': 'sammy-shark', 'Jamie': 'mantisshrimp54'}# Set up while loop to iteratewhile True:    # Request user to enter a name    print('Enter a name:')
    # Assign to name variable    name = input()    # Check whether name is in the dictionary and print feedback    if name in usernames:        print(usernames[name] + ' is the username of ' + name)    # If the name is not in the dictionary...    else:        # Provide feedback                print('I don\'t have ' + name + '\'s username, what is it?')        # Take in a new username for the associated name        username = input()        # Assign username value to name key        usernames[name] = username        # Print feedback that the data was updated        print('Data updated.')Let’s run the program on the command line:
python usernames.pyWhen we run the program we’ll get something like the followingoutput:OutputEnter a name:Sammysammy-shark is the username of SammyEnter a name:JesseI don't have Jesse's username, what is it?JOctopusData updated.Enter a name:When we are done testing the program, we can press CTRL + C toescape the program. You can set up a trigger to quit the program (such astyping the letter q) with a conditional statement to improve the code.This shows how you can modify dictionaries interactively. With thisparticular program, as soon as you exit the program with CTRL + Cyou’ll lose all your data unless you implement a way to handle readingand writing ﬁles.We can also add and modify dictionaries by using the dict.update() function. This varies from the append() functionavailable in lists.In the jesse dictionary below, let’s add the key 'followers' andgive it an integer value with jesse.update(). Following that, let’s 
print() the updated dictionary.jesse = {'username': 'JOctopus', 'online': False, 'points': 723}jesse.update({'followers': 481})print(jesse)Output{'followers': 481, 'username': 'JOctopus', 'points': 723, 'online': False}From the output, we can see that we successfully added the 'followers': 481 key-value pair to the dictionary jesse.We can also use the dict.update() method to modify an existingkey-value pair by replacing a given value for a speciﬁc key.Let’s change the online status of Sammy from True to False in the sammy dictionary:sammy = {'username': 'sammy-shark', 'online': True, 'followers': 987}sammy.update({'online': False})print(sammy)Output
{'username': 'sammy-shark', 'followers': 987, 'online': False}The line sammy.update({'online': False}) references theexisting key 'online' and modiﬁes its Boolean value from True to False. When we call to print() the dictionary, we see the update takeplace in the output.To add items to dictionaries or modify values, we can use wither the dict[key] = value syntax or the function dict.update().Deleting Dictionary ElementsJust as you can add key-value pairs and change values within thedictionary data type, you can also delete items within a dictionary.To remove a key-value pair from a dictionary, we’ll use the followingsyntax:del dict[key]Let’s take the jesse dictionary that represents one of the users. We’llsay that Jesse is no longer using the online platform for playing games, sowe’ll remove the item associated with the 'points' key. Then, we’llprint the dictionary out to conﬁrm that the item was deleted:jesse = {'username': 'JOctopus', 'online': False, 'points': 723, 'followers': 481}del jesse['points']
print(jesse)Output{'online': False, 'username': 'JOctopus', 'followers': 481}The line del jesse['points'] removes the key-value pair 'points': 723 from the jesse dictionary.If we would like to clear a dictionary of all of its values, we can do sowith the dict.clear() function. This will keep a given dictionary incase we need to use it later in the program, but it will no longer containany items.Let’s remove all the items within the jesse dictionary:jesse = {'username': 'JOctopus', 'online': False, 'points': 723, 'followers': 481}jesse.clear()print(jesse)Output{}The output shows that we now have an empty dictionary devoid ofkey-value pairs.If we no longer need a speciﬁc dictionary, we can use del to get rid ofit entirely:
del jesseprint(jesse)When we run a call to print() after deleting the jesse dictionary,we’ll receive the following error:Output...NameError: name 'jesse' is not definedBecause dictionaries are mutable data types, they can be added to,modiﬁed, and have items removed and cleared.ConclusionThis tutorial went through the dictionary data structure in Python.Dictionaries are made up of key-value pairs and provide a way to storedata without relying on indexing. This allows us to retrieve values basedon their meaning and relation to other data types.From here, you can learn more about other data types in our“Understanding Data Types” tutorial.You can see the dictionary data type used in programming projectssuch as web scraping with Scrapy.
How To Import ModulesThe Python programming language comes with a variety of built-infunctions. Among these are several common functions, including: - print() which prints expressions out - abs() which returns theabsolute value of a number - int() which converts another data type toan integer - len() which returns the length of a sequence or collectionThese built-in functions, however, are limited, and we can make use ofmodules to make more sophisticated programs.Modules are Python .py ﬁles that consist of Python code. Any Pythonﬁle can be referenced as a module. A Python ﬁle called hello.py has themodule name of hello that can be imported into other Python ﬁles orused on the Python command line interpreter. You can learn aboutcreating your own modules by reading How To Write Modules in Python3.Modules can deﬁne functions, classes, and variables that you canreference in other Python .py ﬁles or via the Python command lineinterpreter.In Python, modules are accessed by using the import statement.When you do this, you execute the code of the module, keeping thescopes of the deﬁnitions so that your current ﬁle(s) can make use of these.When Python imports a module called hello for example, theinterpreter will ﬁrst search for a built-in module called hello. If a built-in module is not found, the Python interpreter will then search for a ﬁlenamed hello.py in a list of directories that it receives from the sys.path variable.
This tutorial will walk you through checking for and installingmodules, importing modules, and aliasing modules.Checking For and Installing ModulesThere are a number of modules that are built into the Python StandardLibrary, which contains many modules that provide access to systemfunctionality or provide standardized solutions. The Python StandardLibrary is part of every Python installation.To check that these Python modules are ready to go, enter into yourlocal Python 3 programming environment or server-based programmingenvironment and start the Python interpreter in your command line likeso:(my_env) sammy@ubuntu:~/environments$ pythonFrom within the interpreter you can run the import statement tomake sure that the given module is ready to be called, as in:>>> import mathSince math is a built-in module, your interpreter should complete thetask with no feedback, returning to the prompt. This means you don’tneed to do anything to start using the math module.Let’s run the import statement with a module that you may not haveinstalled, like the 2D plotting library matplotlib:>>> import matplotlib
If matplotlib is not installed, you’ll receive an error like this:OutputImportError: No module named 'matplotlib'You can deactivate the Python interpreter with CTRL + D and theninstall matplotlib with pip.Next, we can use pip to install the matplotlib module:(my_env) sammy@ubuntu:~/environments$ pip install matplotlibOnce it is installed, you can import matplotlib in the Pythoninterpreter using import matplotlib, and it will complete withouterror.Importing ModulesTo make use of the functions in a module, you’ll need to import themodule with an import statement.An import statement is made up of the import keyword along withthe name of the module.In a Python ﬁle, this will be declared at the top of the code, under anyshebang lines or general comments.So, in the Python program ﬁle my_rand_int.py we would importthe random module to generate random numbers in this manner:my_rand_int.pyimport random
When we import a module, we are making it available to us in ourcurrent program as a separate namespace. This means that we will haveto refer to the function in dot notation, as in [module].[function].In practice, with the example of the random module, this may look likea function such as: - random.randint() which calls the function toreturn a random integer, or - random.randrange() which calls thefunction to return a random element from a speciﬁed range.Let’s create a for loop to show how we will call a function of the random module within our my_rand_int.py program:my_rand_int.pyimport randomfor i in range(10):    print(random.randint(1, 25))This small program ﬁrst imports the random module on the ﬁrst line,then moves into a for loop which will be working with 10 elements.Within the loop, the program will print a random integer within therange of 1 through 25 (inclusive). The integers 1 and 25 are passed to random.randint() as its parameters.When we run the program with python my_rand_int.py, we’llreceive 10 random integers as output. Because these are random you’lllikely get different integers each time you run the program, but they’lllook something like this:Output
69114322101159The integers should never go below 1 or above 25.If you would like to use functions from more than one module, youcan do so by adding multiple import statements:my_rand_int.pyimport randomimport mathYou may see programs that import multiple modules with commasseparating them — as in import random, math — but this is notconsistent with the PEP 8 Style Guide.To make use of our additional module, we can add the constant pifrom math to our program, and decrease the number of random integersprinted out:my_rand_int.pyimport random
import mathfor i in range(5):    print(random.randint(1, 25))print(math.pi)Now, when we run our program, we’ll receive output that looks likethis, with an approximation of pi as our last line of output:Output1810713103.141592653589793The import statement allows you to import one or more modules intoyour Python program, letting you make use of the deﬁnitionsconstructed in those modules.Using from … importTo refer to items from a module within your program’s namespace, youcan use the from … import statement. When you import modules thisway, you can refer to the functions by name rather than through dotnotation
In this construction, you can specify which deﬁnitions to referencedirectly.In other programs, you may see the import statement take inreferences to everything deﬁned within the module by using an asterisk(*) as a wildcard, but this is discouraged by PEP 8.Let’s ﬁrst look at importing one speciﬁc function, randint() from therandom module:my_rand_int.pyfrom random import randintHere, we ﬁrst call the from keyword, then random for the module.Next, we use the import keyword and call the speciﬁc function wewould like to use.Now, when we implement this function within our program, we willno longer write the function in dot notation as random.randint() butinstead will just write randint():my_rand_int.pyfrom random import randintfor i in range(10):    print(randint(1, 25))When you run the program, you’ll receive output similar to what wereceived earlier.
Using the from … import construction allows us to reference thedeﬁned elements of a module within our program’s namespace, lettingus avoid dot notation.Aliasing ModulesIt is possible to modify the names of modules and their functions withinPython by using the as keyword.You may want to change a name because you have already used thesame name for something else in your program, another module youhave imported also uses that name, or you may want to abbreviate alonger name that you are using a lot.The construction of this statement looks like this:import [module] as [another_name]Let’s modify the name of the math module in our my_math.pyprogram ﬁle. We’ll change the module name of math to m in order toabbreviate it. Our modiﬁed program will look like this:my_math.pyimport math as mprint(m.pi)print(m.e)Within the program, we now refer to the pi constant as m.pi ratherthan math.pi.
For some modules, it is commonplace to use aliases. The matplotlib.pyplot module’s ofﬁcial documentation calls for use of plt as an alias:import matplotlib.pyplot as pltThis allows programmers to append the shorter word plt to any ofthe functions available within the module, as in plt.show(). You cansee this alias import statement in use within our “How to Plot Data inPython 3 Using matplotlib tutorial.”ConclusionWhen we import modules we’re able to call functions that are not builtinto Python. Some modules are installed as part of Python, and some wewill install through pip.Making use of modules allows us to make our programs more robustand powerful as we’re leveraging existing code. We can also create ourown modules for ourselves and for other programmers to use in futureprograms.
How To Write ModulesPython modules are .py ﬁles that consist of Python code. Any Pythonﬁle can be referenced as a module.Some modules are available through the Python Standard Library andare therefore installed with your Python installation. Others can beinstalled with Python’s package manager pip. Additionally, you cancreate your own Python modules since modules are comprised of Python.py ﬁles.This tutorial will guide you through writing Python modules for usewithin other programming ﬁles.Writing and Importing ModulesWriting a module is just like writing any other Python ﬁle. Modules cancontain deﬁnitions of functions, classes, and variables that can then beutilized in other Python programs.From our Python 3 local programming environment or server-basedprogramming environment, let’s start by creating a ﬁle hello.py thatwe’ll later import into another ﬁle.To begin, we’ll create a function that prints Hello, World!:hello.py# Define a functiondef world():    print("Hello, World!")
If we run the program on the command line with python hello.pynothing will happen since we have not told the program to do anything.Let’s create a second ﬁle in the same directory called main_program.py so that we can import the module we just created,and then call the function. This ﬁle needs to be in the same directory sothat Python knows where to ﬁnd the module since it’s not a built-inmodule.main_program.py# Import hello moduleimport hello# Call functionhello.world()Because we are importing a module, we need to call the function byreferencing the module name in dot notation.We could instead import the module as from hello import worldand call the function directly as world(). You can learn more about thismethod by reading how to using from … import when importingmodules.Now, we can run the program on the command line:python main_program.pyWhen we do, we’ll receive the following output:
OutputHello, World!To see how we can use variables in a module, let’s add a variabledeﬁnition in our hello.py ﬁle:hello.py# Define a functiondef world():    print("Hello, World!")# Define a variableshark = "Sammy"Next, we’ll call the variable in a print() function within our main_program.py ﬁle:main_program.py# Import hello moduleimport hello# Call functionhello.world()# Print variableprint(hello.shark)
Once we run the program again, we’ll receive the following output:OutputHello, World!SammyFinally, let’s also deﬁne a class in the hello.py ﬁle. We’ll create theclass Octopus with name and color attributes and a function that willprint out the attributes when called.hello.py# Define a functiondef world():    print("Hello, World!")# Define a variableshark = "Sammy"# Define a classclass Octopus:    def __init__(self, name, color):        self.color = color        self.name = name    def tell_me_about_the_octopus(self):        print("This octopus is " + self.color + ".")        print(self.name + " is the octopus's name.")
We’ll now add the class to the end of our main_program.py ﬁle:main_program.py# Import hello moduleimport hello# Call functionhello.world()# Print variableprint(hello.shark)# Call classjesse = hello.Octopus("Jesse", "orange")jesse.tell_me_about_the_octopus()Once we have called the Octopus class with hello.Octopus(), wecan access the functions and attributes of the class within the main_program.py ﬁle’s namespace. This lets us write jesse.tell_me_about_the_octopus() on the last line withoutinvoking hello. We could also, for example, call one of the class’sattributes such as jesse.color without referencing the name of the hello module.When we run the program, we’ll receive the following output:OutputHello, World!
SammyThis octopus is orange.Jesse is the octopus's name.It is important to keep in mind that though modules are oftendeﬁnitions, they can also implement code. To see how this works, let’srewrite our hello.py ﬁle so that it implements the world() function:hello.py# Define a functiondef world():    print("Hello, World!")# Call function within moduleworld()We have also deleted the other deﬁnitions in the ﬁle.Now, in our main_program.py ﬁle, we’ll delete every line except forthe import statement:main_program.py# Import hello moduleimport helloWhen we run main_program.py we’ll receive the following output:OutputHello, World!
This is because the hello module implemented the world() functionwhich is then passed to main_program.py and executes when main_program.py runs.A module is a Python program ﬁle composed of deﬁnitions or codethat you can leverage in other Python program ﬁles.Accessing Modules from Another DirectoryModules may be useful for more than one programming project, and inthat case it makes less sense to keep a module in a particular directorythat’s tied to a speciﬁc project.If you want to use a Python module from a location other than thesame directory where your main program is, you have a few options.Appending PathsOne option is to invoke the path of the module via the programming ﬁlesthat use that module. This should be considered more of a temporarysolution that can be done during the development process as it does notmake the module available system-wide.To append the path of a module to another programming ﬁle, you’llstart by importing the sys module alongside any other modules youwish to use in your main program ﬁle.The sys module is part of the Python Standard Library and providessystem-speciﬁc parameters and functions that you can use in yourprogram to set the path of the module you wish to implement.For example, let’s say we moved the hello.py ﬁle and it is now onthe path /usr/sammy/ while the main_program.py ﬁle is in anotherdirectory.
In our main_program.py ﬁle, we can still import the hello moduleby importing the sys module and then appending /usr/sammy/ to thepath that Python checks for ﬁles.main_program.pyimport syssys.path.append('/usr/sammy/')import hello...As long as you correctly set the path for the hello.py ﬁle, you’ll beable to run the main_program.py ﬁle without any errors and receivethe same output as above when hello.py was in the same directory.Adding the Module to the Python PathA second option that you have is to add the module to the path wherePython checks for modules and packages. This is a more permanentsolution that makes the module available environment-wide or system-wide, making this method more portable.To ﬁnd out what path Python checks, run the Python interpreter fromyour programming environment:pythonNext, import the sys module:>>> import sys
Then have Python print out the system path:>>> print(sys.path)Here, you’ll receive some output with at least one system path. Ifyou’re in a programming environment, you may receive several. You’llwant to look for the one that is in the environment you’re currentlyusing, but you may also want to add the module to your main systemPython path. What you’re looking for will be similar to this:Output'/usr/sammy/my_env/lib/python3.5/site-packages'Now you can move your hello.py ﬁle into that directory. Once thatis complete, you can import the hello module as usual:main_program.pyimport hello...When you run your program, it should complete without error.Modifying the path of your module can ensure that you can access themodule regardless of what directory you are in. This is useful especiallyif you have more than one project referencing a particular module.ConclusionWriting a Python module is the same as writing any other Python .pyﬁle. This tutorial covered how to write deﬁnitions within a module, make
use of those deﬁnitions within another Python programming ﬁle, andwent over options of where to keep the module in order to access it.You can learn more about installing and importing modules by readingHow To Import Modules in Python 3.
How To Write Conditional StatementsConditional statements are part of every programming language. Withconditional statements, we can have code that sometimes runs and atother times does not run, depending on the conditions of the program atthat time.When we fully execute each statement of a program, moving from thetop to the bottom with each line executed in order, we are not asking theprogram to evaluate speciﬁc conditions. By using conditional statements,programs can determine whether certain conditions are being met andthen be told what to do next.Let’s look at some examples where we would use conditionalstatements:If the student receives over 65% on her test, report that her gradepasses; if not, report that her grade failsIf he has money in his account, calculate interest; if he doesn’t,charge a penalty feeIf they buy 10 oranges or more, calculate a discount of 5%; if theybuy fewer, then don’tThrough evaluating conditions and assigning code to run based onwhether or not those conditions are met, we are writing conditional code.This tutorial will take you through writing conditional statements inthe Python programming language.If statement
We will start with the if statement, which will evaluate whether astatement is true or false, and run code only in the case that the statementis true.In a plain text editor, open a ﬁle and write the following code:grade = 70if grade >= 65:    print("Passing grade")With this code, we have the variable grade and are giving it theinteger value of 70. We are then using the if statement to evaluatewhether or not the variable grade is greater than or equal ( >= ) to 65. If itdoes meet this condition, we are telling the program to print out thestring Passing grade.Save the program as grade.py and run it in a local programmingenvironment from a terminal window with the command python grade.py.In this case, the grade of 70 does meet the condition of being greaterthan or equal to 65, so you will receive the following output once you runthe program:OutputPassing gradeLet’s now change the result of this program by changing the value ofthe grade variable to 60:
grade.pygrade = 60if grade >= 65:    print("Passing grade")When we save and run this code, we will receive no output becausethe condition was not met and we did not tell the program to executeanother statement.To give one more example, let us calculate whether a bank accountbalance is below 0. Let’s create a ﬁle called account.py and write thefollowing program:account.pybalance = -5if balance < 0:    print("Balance is below 0, add funds now or you will be charged a penalty.")When we run the program with python account.py, we’ll receivethe following output:OutputBalance is below 0, add funds now or you will be charged a penalty.
In the program we initialized the variable balance with the value of -5, which is less than 0. Since the balance met the condition of the ifstatement (balance < 0), once we save and run the code, we willreceive the string output. Again, if we change the balance to 0 or apositive number, we will receive no output.Else StatementIt is likely that we will want the program to do something even when an if statement evaluates to false. In our grade example, we will wantoutput whether the grade is passing or failing.To do this, we will add an else statement to the grade conditionabove that is constructed like this:grade.pygrade = 60if grade >= 65:    print("Passing grade")else:    print("Failing grade")Since the grade variable above has the value of 60, the if statementevaluates as false, so the program will not print out Passing grade.The else statement that follows tells the program to do somethinganyway.When we save and run the program, we’ll receive the followingoutput:
OutputFailing gradeIf we then rewrite the program to give the grade a value of 65 orhigher, we will instead receive the output Passing grade.To add an else statement to the bank account example, we rewrite thecode like this:account.pybalance = 522if balance < 0:    print("Balance is below 0, add funds now or you will be charged a penalty.")else:    print("Your balance is 0 or above.")OutputYour balance is 0 or above.Here, we changed the balance variable value to a positive number sothat the else statement will print. To get the ﬁrst if statement to print,we can rewrite the value to a negative number.By combining an if statement with an else statement, you areconstructing a two-part conditional statement that will tell the computerto execute certain code whether or not the if condition is met.
Else if statementSo far, we have presented a Boolean option for conditional statements,with each if statement evaluating to either true or false. In many cases,we will want a program that evaluates more than two possible outcomes.For this, we will use an else if statement, which is written in Python as elif. The elif or else if statement looks like the if statement and willevaluate another condition.In the bank account program, we may want to have three discreteoutputs for three different situations:The balance is below 0The balance is equal to 0The balance is above 0The elif statement will be placed between the if statement and the else statement as follows:account.py. . .if balance < 0:    print("Balance is below 0, add funds now or you will be charged a penalty.")elif balance == 0:    print("Balance is equal to 0, add funds soon.")else:    print("Your balance is 0 or above.")
Now, there are three possible outputs that can occur once we run theprogram: - If the variable balance is equal to 0 we will receive theoutput from the elif statement (Balance is equal to 0, add funds soon.) - If the variable balance is set to a positive number, wewill receive the output from the else statement (Your balance is 0 or above.). - If the variable balance is set to a negative number, theoutput will be the string from the if statement (Balance is below 0, add funds now or you will be charged a penalty).What if we want to have more than three possibilities, though? We cando this by writing more than one elif statement into our code.In the grade.py program, let’s rewrite the code so that there are a fewletter grades corresponding to ranges of numerical grades:90 or above is equivalent to an A grade80-89 is equivalent to a B grade70-79 is equivalent to a C grade65-69 is equivalent to a D grade64 or below is equivalent to an F gradeTo run this code, we will need one if statement, three elifstatements, and an else statement that will handle all failing cases.Let’s rewrite the code from the example above to have strings thatprint out each of the letter grades. We can keep our else statement thesame.grade.py. . .if grade >= 90:
    print("A grade")elif grade >=80:    print("B grade")elif grade >=70:    print("C grade")elif grade >= 65:    print("D grade")else:    print("Failing grade")Since elif statements will evaluate in order, we can keep ourstatements pretty basic. This program is completing the following steps:1. If the grade is greater than 90, the program will print A grade, ifthe grade is less than 90, the program will continue to the nextstatement…2. If the grade is greater than or equal to 80, the program will print B grade, if the grade is 79 or less, the program will continue to thenext statement…3. If the grade is greater than or equal to 70, the program will print C grade, if the grade is 69 or less, the program will continue to thenext statement…4. If the grade is greater than or equal to 65, the program will print D grade, if the grade is 64 or less, the program will continue to the
next statement…5. The program will print Failing grade because all of the aboveconditions were not met.Nested If StatementsOnce you are feeling comfortable with the if, elif, and elsestatements, you can move on to nested conditional statements. We canuse nested if statements for situations where we want to check for asecondary condition if the ﬁrst condition executes as true. For this, wecan have an if-else statement inside of another if-else statement. Let’slook at the syntax of a nested if statement:if statement1:              #outer if statement    print("true")    if nested_statement:    #nested if statement        print("yes")    else:                   #nested else statement        print("no")else:                       #outer else statement    print("false")A few possible outputs can result from this code:If statement1 evaluates to true, the program will then evaluatewhether the nested_statement also evaluates to true. If both
cases are true, the output will be:OutputtrueyesIf, however, statement1 evaluates to true, but nested_statement evaluates to false, then the output will be:OutputtruenoAnd if statement1 evaluates to false, the nested if-else statementwill not run, so the else statement will run alone, and the outputwill be:OutputfalseWe can also have multiple if statements nested throughout our code:if statement1:                  #outer if    print("hello world")    if nested_statement1:       #first nested if        print("yes")
    elif nested_statement2:     #first nested elif        print("maybe")    else:                       #first nested else        print("no")elif statement2:                #outer elif    print("hello galaxy")    if nested_statement3:       #second nested if        print("yes")    elif nested_statement4:     #second nested elif        print("maybe")    else:                       #second nested else        print("no")else:                           #outer else    statement("hello universe")In the above code, there is a nested if statement inside each ifstatement in addition to the elif statement. This will allow for moreoptions within each condition.Let’s look at an example of nested if statements with our grade.pyprogram. We can check for whether a grade is passing ﬁrst (greater thanor equal to 65%), then evaluate which letter grade the numerical gradeshould be equivalent to. If the grade is not passing, though, we do not
need to run through the letter grades, and instead can have the programreport that the grade is failing. Our modiﬁed code with the nested ifstatement will look like this:grade.py. . .if grade >= 65:    print("Passing grade of:")    if grade >= 90:        print("A")    elif grade >=80:        print("B")    elif grade >=70:        print("C")    elif grade >= 65:        print("D")else:    print("Failing grade")If we run the code with the variable grade set to the integer value 92,the ﬁrst condition is met, and the program will print out Passing grade of:. Next, it will check to see if the grade is greater than or equalto 90, and since this condition is also met, it will print out A.
If we run the code with the grade variable set to 60, then the ﬁrstcondition is not met, so the program will skip the nested if statementsand move down to the else statement, with the program printing out Failing grade.We can of course add even more options to this, and use a second layerof nested if statements. Perhaps we will want to evaluate for grades ofA+, A and A- separately. We can do so by ﬁrst checking if the grade ispassing, then checkingto see if the grade is 90 or above, then checkingtosee if the grade is over 96 for an A+ for instance:grade.py. . .if grade >= 65:    print("Passing grade of:")    if grade >= 90:        if grade > 96:            print("A+")        elif grade > 93 and grade <= 96:            print("A")        elif grade >= 90:            print("A-"). . .In the code above, for a grade variable set to 96, the program will runthe following:
1. Check if the grade is greater than or equal to 65 (true)2. Print out Passing grade of:3. Check if the grade is greater than or equal to 90 (true)4. Check if the grade is greater than 96 (false)5. Check if the grade is greater than 93 and also less than or equal to 96(true)6. Print A7. Leave these nested conditional statements and continue withremaining codeThe output of the program for a grade of 96 therefore looks like this:OutputPassing grade of:ANested if statements can provide the opportunity to add severalspeciﬁc levels of conditions to your code.ConclusionBy using conditional statements like the if statement, you will havegreater control over what your program executes. Conditional statementstell the program to evaluate whether a certain condition is being met. Ifthe condition is met it will execute speciﬁc code, but if it is not met theprogram will continue to move down to other code.To continue practicing conditional statements, try using differentoperators, combining operators with and or or, and using conditionalstatements alongside loops. You can also go through our tutorial on How
To Make a Simple Calculator Program to gain more familiarity withconditional statements.
How To Construct While LoopsComputer programs are great to use for automating and repeating tasksso that we don’t have to. One way to repeat similar tasks is throughusing loops. We’ll be covering Python’s while loop in this tutorial.A while loop implements the repeated execution of code based on agiven Boolean condition. The code that is in a while block will executeas long as the while statement evaluates to True.You can think of the while loop as a repeating conditional statement.After an if statement, the program continues to execute code, but in a while loop, the program jumps back to the start of the while statementuntil the condition is False.As opposed to for loops that execute a certain number of times, whileloops are conditionally based, so you don’t need to know how manytimes to repeat the code going in.While LoopIn Python, while loops are constructed like so:while [a condition is True]:    [do something]The something that is being done will continue to be executed until thecondition that is being assessed is no longer true.Let’s create a small program that executes a while loop. In thisprogram, we’ll ask for the user to input a password. While going through
this loop, there are two possible outcomes:If the password is correct, the while loop will exit.If the password is not correct, the while loop will continue toexecute.We’ll create a ﬁle called password.py in our text editor of choice, andbegin by initializing the variable password as an empty string:password.pypassword = ''The empty string will be used to take in input from the user within the while loop.Now, we’ll construct the while statement along with its condition:password.pypassword = ''while password != 'password':Here, the while is followed by the variable password. We are lookingto see if the variable password is set to the string password (based onthe user input later), but you can choose whichever string you’d like.This means that if the user inputs the string password, then the loopwill stop and the program will continue to execute any code outside ofthe loop. However, if the string that the user inputs is not equal to thestring password, the loop will continue.
Next, we’ll add the block of code that does something within the while loop:password.pypassword = ''while password != 'password':    print('What is the password?')    password = input()Inside of the while loop, the program runs a print statement thatprompts for the password. Then the variable password is set to theuser’s input with the input() function.The program will check to see if the variable password is assigned tothe string password, and if it is, the while loop will end. Let’s give theprogram another line of code for when that happens:password.pypassword = ''while password != 'password':    print('What is the password?')    password = input()print('Yes, the password is ' + password + '. You may enter.')
The last print() statement is outside of the while loop, so when theuser enters password as the password, they will see the ﬁnal printstatement outside of the loop.However, if the user never enters the word password, they will neverget to the last print() statement and will be stuck in an inﬁnite loop.An inﬁnite loop occurs when a program keeps executing within oneloop, never leaving it. To exit out of inﬁnite loops on the command line,press CTRL + C.Save the program and run it:python password.pyYou’ll be prompted for a password, and then may test it with variouspossible inputs. Here is sample output from the program:OutputWhat is the password?helloWhat is the password?sammyWhat is the password?PASSWORDWhat is the password?passwordYes, the password is password. You may enter.Keep in mind that strings are case sensitive unless you also use a stringfunction to convert the string to all lower-case (for example) before
checking.Example Program with While LoopNow that we understand the general premise of a while loop, let’screate a command-line guessing game that uses a while loop effectively.To best understand how this program works, you should also read aboutusing conditional statements and converting data types.First, we’ll create a ﬁle called guess.py in our text editor of choice.We want the computer to come up with random numbers for the user toguess, so we’ll import the random module with an import statement. Ifyou’re unfamiliar with this package, you can learn more aboutgenerating random numbers from the Python docs.guess.pyimport randomNext, we’ll assign a random integer to the variable number, and keepit in the range of 1 through 25 (inclusive), in the hope that it does notmake the game too difﬁcult.guess.pyimport randomnumber = random.randint(1, 25)At this point, we can get into our while loop, ﬁrst initializing avariable and then creating the loop.
guess.pyimport randomnumber = random.randint(1, 25)number_of_guesses = 0while number_of_guesses < 5:    print('Guess a number between 1 and 25:')    guess = input()    guess = int(guess)    number_of_guesses = number_of_guesses + 1    if guess == number:        breakWe’ve initialized the variable number_of_guesses at 0, so that weincrease it with each iteration of our loop so that we don’t have aninﬁnite loop. Then we added the while statement so that the number_of_guesses is limited to 5 total. After the ﬁfth guess, the userwill return to the command line, and for now, if the user enterssomething other than an integer, they’ll receive an error.Within the loop, we added a print() statement to prompt the user toenter a number, which we took in with the input() function and set tothe guess variable. Then, we converted guess from a string to aninteger.
Before the loop is over, we also want to increase the number_of_guesses variable by 1 so that we can iterate through theloop 5 times.Finally, we write a conditional if statement to see if the guess thatthe user made is equivalent to the number that the computer generated,and if so we use a break statement to come out of the loop.The program is fully functioning, and we can run it with the followingcommand:python guess.pyThough it works, right now the user never knows if their guess iscorrect and they can guess the full 5 times without ever knowing if theygot it right. Sample output of the current program looks like this:OutputGuess a number between 1 and 25:11Guess a number between 1 and 25:19Guess a number between 1 and 25:22Guess a number between 1 and 25:3Guess a number between 1 and 25:8
Let’s add some conditional statements outside of the loop so that theuser is given feedback as to whether they correctly guess the number ornot. These will go at the end of our current ﬁle.guess.pyimport randomnumber = random.randint(1, 25)number_of_guesses = 0while number_of_guesses < 5:    print('Guess a number between 1 and 25:')    guess = input()    guess = int(guess)    number_of_guesses = number_of_guesses + 1    if guess == number:        breakif guess == number:    print('You guessed the number in ' + str(number_of_guesses) + ' tries!')else:    print('You did not guess the number. The number was ' + str(number))
At this point, the program will tell the user if they got the number rightor wrong, which may not happen until the end of the loop when the useris out of guesses.To give the user a little help along the way, let’s add a few moreconditional statements into the while loop. These can tell the userwhether their number was too low or too high, so that they can be morelikely to guess the correct number. We’ll add these before our if guess == number lineguess.pyimport randomnumber = random.randint(1, 25)number_of_guesses = 0while number_of_guesses < 5:    print('Guess a number between 1 and 25:')    guess = input()    guess = int(guess)    number_of_guesses = number_of_guesses + 1    if guess < number:        print('Your guess is too low')    if guess > number:        print('Your guess is too high')
    if guess == number:        breakif guess == number:    print('You guessed the number in ' + str(number_of_guesses) + ' tries!')else:    print('You did not guess the number. The number was ' + str(number))When we run the program again with python guess.py, we see thatthe user gets more guided assistance in their guessing. So, if therandomly-generated number is 12 and the user guesses 18, they will betold that their guess is too high, and they can adjust their next guessaccordingly.There is more that can be done to improve the code, including errorhandling for when the user does not input an integer, but in this examplewe see a while loop at work in a short command-line program.ConclusionThis tutorial went over how while loops work in Python and how toconstruct them. While loops continue to loop through a block of codeprovided that the condition set in the while statement is True.From here, you can continue to learn about looping by readingtutorials on for loops and break, continue, and pass statements.
How To Construct For LoopsUsing loops in computer programming allows us to automate and repeatsimilar tasks multiple times. In this tutorial, we’ll be covering Python’sfor loop.A for loop implements the repeated execution of code based on a loopcounter or loop variable. This means that for loops are used most oftenwhen the number of iterations is known before entering the loop, unlikewhile loops which are conditionally based.For LoopsIn Python, for loops are constructed like so:for [iterating variable] in [sequence]:    [do something]The something that is being done will be executed until the sequence isover.Let’s look at a for loop that iterates through a range of values:for i in range(0,5):   print(i)When we run this program, the output looks like this:Output
01234This for loop sets up i as its iterating variable, and the sequenceexists in the range of 0 to 5.Then within the loop we print out one integer per loop iteration. Keepin mind that in programming we tend to begin at index 0, so that is whyalthough 5 numbers are printed out, they range from 0-4.You’ll commonly see and use for loops when a program needs torepeat a block of code a number of times.For Loops using range()One of Python’s built-in immutable sequence types is range(). In loops,range() is used to control how many times the loop will be repeated.When working with range(), you can pass between 1 and 3 integerarguments to it:start states the integer value at which the sequence begins, if this isnot included then start begins at 0stop is always required and is the integer that is counted up to butnot includedstep sets how much to increase (or decrease in the case of negativenumbers) the next iteration, if this is omitted then step defaults to 1
We’ll look at some examples of passing different arguments to range().First, let’s only pass the stop argument, so that our sequence set up is range(stop):for i in range(6):   print(i)In the program above, the stop argument is 6, so the code will iteratefrom 0-6 (exclusive of 6):Output012345Next, we’ll look at range(start, stop), with values passed forwhen the iteration should start and for when it should stop:for i in range(20,25):   print(i)Here, the range goes from 20 (inclusive) to 25 (exclusive), so the outputlooks like this:
Output2021222324The step argument of range() is similar to specifying stride whileslicing strings in that it can be used to skip values within the sequence.With all three arguments, step comes in the ﬁnal position: range(start, stop, step). First, let’s use a step with a positivevalue:for i in range(0,15,3):   print(i)In this case, the for loop is set up so that the numbers from 0 to 15print out, but at a step of 3, so that only every third number is printed,like so:Output036912
We can also use a negative value for our step argument to iteratebackwards, but we’ll have to adjust our start and stop argumentsaccordingly:for i in range(100,0,-10):   print(i)Here, 100 is the start value, 0 is the stop value, and -10 is the range,so the loop begins at 100 and ends at 0, decreasing by 10 with eachiteration. We can see this occur in the output:Output100908070605040302010When programming in Python, for loops often make use of the range() sequence type as its parameters for iteration.For Loops using Sequential Data Types
Lists and other data sequence types can also be leveraged as iterationparameters in for loops. Rather than iterating through a range(), youcan deﬁne a list and iterate through that list.We’ll assign a list to a variable, and then iterate through the list:sharks = ['hammerhead', 'great white', 'dogfish', 'frilled', 'bullhead', 'requiem']for shark in sharks:   print(shark)In this case, we are printing out each item in the list. Though we usedthe variable shark, we could have called the variable any other validvariable name and we would get the same output:Outputhammerheadgreat whitedogfishfrilledbullheadrequiemThe output above shows that the for loop iterated through the list,and printed each item from the list per line.Lists and other sequence-based data types like strings and tuples arecommon to use with loops because they are iterable. You can combinethese data types with range() to add items to a list, for example:
sharks = ['hammerhead', 'great white', 'dogfish', 'frilled', 'bullhead', 'requiem']for item in range(len(sharks)):   sharks.append('shark')print(sharks)Output['hammerhead', 'great white', 'dogfish', 'frilled', 'bullhead', 'requiem', 'shark', 'shark', 'shark', 'shark', 'shark', 'shark']Here, we have added a placeholder string of 'shark' for each item ofthe length of the sharks list.You can also use a for loop to construct a list from scratch:integers = []for i in range(10):   integers.append(i)print(integers)In this example, the list integers is initialized empty, but the forloop populates the list like so:Output
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Similarly, we can iterate through strings:sammy = 'Sammy'for letter in sammy:   print(letter)OutputSammyIterating through tuples is done in the same format as iteratingthrough lists or strings above.When iterating through a dictionary, it’s important to keep the key :value structure in mind to ensure that you are calling the correct elementof the dictionary. Here is an example that calls both the key and thevalue:sammy_shark = {'name': 'Sammy', 'animal': 'shark', 'color': 'blue', 'location': 'ocean'}for key in sammy_shark:   print(key + ': ' + sammy_shark[key])
Outputname: Sammyanimal: sharklocation: oceancolor: blueWhen using dictionaries with for loops, the iterating variablecorresponds to the keys of the dictionary, and dictionary_variable[iterating_variable] corresponds to thevalues. In the case above, the iterating variable key was used to stand forkey, and sammy_shark[key] was used to stand for the values.Loops are often used to iterate and manipulate sequential data types.Nested For LoopsLoops can be nested in Python, as they can with other programminglanguages.A nested loop is a loop that occurs within another loop, structurallysimilar to nested if statements. These are constructed like so:for [first iterating variable] in [outer loop]: # Outer loop    [do something]  # Optional    for [second iterating variable] in [nested loop]:   # Nested loop        [do something]  The program ﬁrst encounters the outer loop, executing its ﬁrstiteration. This ﬁrst iteration triggers the inner, nested loop, which then
runs to completion. Then the program returns back to the top of the outerloop, completing the second iteration and again triggering the nestedloop. Again, the nested loop runs to completion, and the program returnsback to the top of the outer loop until the sequence is complete or a breakor other statement disrupts the process.Let’s implement a nested for loop so we can take a closer look. In thisexample, the outer loop will iterate through a list of integers called num_list, and the inner loop will iterate through a list of strings called alpha_list.num_list = [1, 2, 3]alpha_list = ['a', 'b', 'c']for number in num_list:    print(number)    for letter in alpha_list:        print(letter)When we run this program, we’ll receive the following output:Output1abc2ab
c3abcThe output illustrates that the program completes the ﬁrst iteration ofthe outer loop by printing 1, which then triggers completion of the innerloop, printing a, b, c consecutively. Once the inner loop has completed,the program returns to the top of the outer loop, prints 2, then againprints the inner loop in its entirety (a, b, c), etc.Nested for loops can be useful for iterating through items within listscomposed of lists. In a list composed of lists, if we employ just one forloop, the program will output each internal list as an item:list_of_lists = [['hammerhead', 'great white', 'dogfish'],[0, 1, 2],[9.9, 8.8, 7.7]]for list in list_of_lists:    print(list)Output['hammerhead', 'great white', 'dogfish'][0, 1, 2][9.9, 8.8, 7.7]In order to access each individual item of the internal lists, we’llimplement a nested for loop:
list_of_lists = [['hammerhead', 'great white', 'dogfish'],[0, 1, 2],[9.9, 8.8, 7.7]]for list in list_of_lists:    for item in list:        print(item)Outputhammerheadgreat whitedogfish0129.98.87.7When we utilize a nested for loop we are able to iterate over theindividual items contained in the lists.We can see nested for loops working in use in a working program inour tutorial on the Natural Language Processing Toolkit (NLTK).ConclusionThis tutorial went over how for loops work in Python and how toconstruct them. For loops continue to loop through a block of codeprovided a certain number of times.
From here, you can continue to learn about looping by readingtutorials on while loops and break, continue, and pass statements.To work with for loops in projects, follow along with the followingtutorials: - How To Create a Twitterbot with Python 3 and the TweepyLibrary - How To Work with Language Data in Python 3 using theNatural Language Toolkit NLTK - How To Graph Word Frequency Usingmatplotlib with Python 3
How To Use Break, Continue, and PassStatements when Working with LoopsUsing for loops and while loops in Python allow you to automate andrepeat tasks in an efﬁcient manner.But sometimes, an external factor may inﬂuence the way your programruns. When this occurs, you may want your program to exit a loopcompletely, skip part of a loop before continuing, or ignore that externalfactor. You can do these actions with break, continue, and passstatements.Break StatementIn Python, the break statement provides you with the opportunity toexit out of a loop when an external condition is triggered. You’ll put the break statement within the block of code under your loop statement,usually after a conditional if statement.Let’s look at an example that uses the break statement in a for loop:number = 0for number in range(10):   number = number + 1   if number == 5:      break    # break here
   print('Number is ' + str(number))print('Out of loop')In this small program, the variable number is initialized at 0. Then a for statement constructs the loop as long as the variable number is lessthan 10.Within the for loop, the number increases incrementally by 1 witheach pass because of the line number = number + 1.Then, there is an if statement that presents the condition that if thevariable number is equivalent to the integer 5, then the loop will break.Within the loop is also a print() statement that will execute witheach iteration of the for loop until the loop breaks, since it is after the break statement.To see when we are out of the loop, we have included a ﬁnal print()statement outside of the for loop.When we run this code, our output will be the following:OutputNumber is 1Number is 2Number is 3Number is 4Out of loopThis shows that once the integer number is evaluated as equivalent to5, the loop breaks, as the program is told to do so with the breakstatement.
The break statement causes a program to break out of a loop.Continue StatementThe continue statement gives you the option to skip over the part of aloop where an external condition is triggered, but to go on to completethe rest of the loop. That is, the current iteration of the loop will bedisrupted, but the program will return to the top of the loop.The continue statement will be within the block of code under theloop statement, usually after a conditional if statement.Using the same for loop program as in the Break Statement sectionabove, we’ll use a continue statement rather than a break statement:number = 0for number in range(10):   number = number + 1   if number == 5:      continue    # continue here   print('Number is ' + str(number))print('Out of loop')The difference in using the continue statement rather than a breakstatement is that our code will continue despite the disruption when thevariable number is evaluated as equivalent to 5. Let’s look at our output:
OutputNumber is 1Number is 2Number is 3Number is 4Number is 6Number is 7Number is 8Number is 9Number is 10Out of loopHere we see that the line Number is 5 never occurs in the output,but the loop continues after that point to print lines for the numbers 6-10before leaving the loop.You can use the continue statement to avoid deeply nestedconditional code, or to optimize a loop by eliminating frequentlyoccurring cases that you would like to reject.The continue statement causes a program to skip certain factors thatcome up within a loop, but then continue through the rest of the loop.Pass StatementWhen an external condition is triggered, the pass statement allows youto handle the condition without the loop being impacted in any way; allof the code will continue to be read unless a break or other statementoccurs.As with the other statements, the pass statement will be within theblock of code under the loop statement, typically after a conditional if
statement.Using the same code block as above, let’s replace the break or continue statement with a pass statement:number = 0for number in range(10):   number = number + 1   if number == 5:      pass    # pass here   print('Number is ' + str(number))print('Out of loop')The pass statement occurring after the if conditional statement istelling the program to continue to run the loop and ignore the fact thatthe variable number evaluates as equivalent to 5 during one of itsiterations.We’ll run the program and take a look at the output:OutputNumber is 1Number is 2Number is 3Number is 4Number is 5
Number is 6Number is 7Number is 8Number is 9Number is 10Out of loopBy using the pass statement in this program, we notice that theprogram runs exactly as it would if there were no conditional statementin the program. The pass statement tells the program to disregard thatcondition and continue to run the program as usual.The pass statement can create minimal classes, or act as a placeholderwhen working on new code and thinking on an algorithmic level beforehammering out details.ConclusionThe break, continue, and pass statements in Python will allow you touse for loops and while loops more effectively in your code.You can see break and pass statements in action in our tutorial “HowTo Create a Twitterbot with Python 3 and the Tweepy Library.”
How To Deﬁne FunctionsA function is a block of instructions that performs an action and, oncedeﬁned, can be reused. Functions make code more modular, allowingyou to use the same code over and over again.Python has a number of built-in functions that you may be familiarwith, including:print() which will print an object to the terminalint() which will convert a string or number data type to an integerdata typelen() which returns the length of an objectFunction names include parentheses and may include parameters.In this tutorial, we’ll go over how to deﬁne your own functions to usein your coding projects.Deﬁning a FunctionLet’s start with turning the classic “Hello, World!” program into afunction.We’ll create a new text ﬁle in our text editor of choice, and call theprogram hello.py. Then, we’ll deﬁne the function.A function is deﬁned by using the def keyword, followed by a nameof your choosing, followed by a set of parentheses which hold anyparameters the function will take (they can be empty), and ending with acolon.In this case, we’ll deﬁne a function named hello():
hello.pydef hello():This sets up the initial statement for creating a function.From here, we’ll add a second line with a 4-space indent to provide theinstructions for what the function does. In this case, we’ll be printing Hello, World! to the console:hello.pydef hello():    print("Hello, World!")<figure class="code">Our function is now fully deﬁned, but if we run the program at thispoint, nothing will happen since we didn’t call the function.So, outside of our deﬁned function block, let’s call the function with hello():hello.pydef hello():    print("Hello, World!")hello()<figure class="code">Now, let’s run the program:
python hello.pyYou should receive the following output:OutputHello, World!Functions can be more complicated than the hello() function wedeﬁned above. For example, we can use for loops, conditionalstatements, and more within our function block.For example, the function deﬁned below utilizes a conditionalstatement to check if the input for the name variable contains a vowel,then uses a for loop to iterate over the letters in the name string.names.py# Define function names()def names():    # Set up name variable with input    name = str(input('Enter your name: '))    # Check whether name has a vowel    if set('aeiou').intersection(name.lower()):        print('Your name contains a vowel.')    else:        print('Your name does not contain a vowel.')    # Iterate over name    for letter in name:        print(letter)
# Call the functionnames()<figure class="code">The names() function we deﬁned above sets up a conditionalstatement and a for loop, showing how code can be organized within afunction deﬁnition. However, depending on what we intend with ourprogram and how we want to set up our code, we may want to deﬁne theconditional statement and the for loop as two separate functions.Deﬁning functions within a program makes our code modular andreusable so that we can call the same functions without rewriting them.Working with ParametersSo far we have looked at functions with empty parentheses that do nottake arguments, but we can deﬁne parameters in function deﬁnitionswithin their parentheses.A parameter is a named entity in a function deﬁnition, specifying anargument that the function can accept.Let’s create a small program that takes in parameters x, y, and z. We’llcreate a function that adds the parameters together in differentconﬁgurations. The sums of these will be printed by the function. Thenwe’ll call the function and pass numbers into the function.add_numbers.pydef add_numbers(x, y, z):    a = x + y
    b = x + z    c = y + z    print(a, b, c)add_numbers(1, 2, 3)<figure class="code">We passed the number 1 in for the x parameter, 2 in for the yparameter, and 3 in for the z parameter. These values correspond witheach parameter in the order they are given.The program is essentially doing the following math based on thevalues we passed to the parameters:a = 1 + 2b = 1 + 3c = 2 + 3The function also prints a, b, and c, and based on the math above wewould expect a to be equal to 3, b to be 4, and c to be 5. Let’s run theprogram:python add_numbers.pyOutput3 4 5
When we pass 1, 2, and 3 as parameters to the add_numbers()function, we receive the expected output.Parameters are arguments that are typically deﬁned as variables withinfunction deﬁnitions. They can be assigned values when you run themethod, passing the arguments into the function.Keyword ArgumentsIn addition to calling parameters in order, you can use keywordarguments in a function call, in which the caller identiﬁes the argumentsby the parameter name.When you use keyword arguments, you can use parameters out oforder because the Python interpreter will use the keywords provided tomatch the values to the parameters.Let’s create a function that will show us proﬁle information for a user.We’ll pass parameters to it in the form of username (intended as astring), and followers (intended as an integer).proﬁle.py# Define function with parametersdef profile_info(username, followers):    print("Username: " + username)    print("Followers: " + str(followers))<figure class="code">Within the function deﬁnition statement, username and followersare contained in the parentheses of the profile_info() function. The
block of the function prints out information about the user as strings,making use of the two parameters.Now, we can call the function and assign parameters to it:proﬁle.pydef profile_info(username, followers):    print("Username: " + username)    print("Followers: " + str(followers))# Call function with parameters assigned as aboveprofile_info("sammyshark", 945)# Call function with keyword argumentsprofile_info(username="AlexAnglerfish", followers=342)<figure class="code">In the ﬁrst function call, we have ﬁlled in the information with ausername of sammyshark and followers being 945, in the secondfunction call we used keyword arguments, assigning values to theargument variables.Let’s run the program:python profile.pyOutputUsername: sammysharkFollowers: 945
Username: AlexAnglerfishFollowers: 342The output shows us the usernames and numbers of followers for bothusers.This also permits us to modify the order of the parameters, as in thisexample of the same program with a different call:proﬁle.pydef profile_info(username, followers):    print("Username: " + username)    print("Followers: " + str(followers))# Change order of parametersprofile_info(followers=820, username="cameron-catfish")<figure class="code">When we run the program again with the python profile.pycommand, we’ll receive the following output:OutputUsername: cameron-catfishFollowers: 820Because the function deﬁnition maintains the same order of print()statements, if we use keyword arguments, it does not matter which order
we pass them into the function call.Default Argument ValuesWe can also provide default values for one or both of the parameters.Let’s create a default value for the followers parameter with a value of1:proﬁle.pydef profile_info(username, followers=1):    print("Username: " + username)    print("Followers: " + str(followers))Now, we can run the function with only the username functionassigned, and the number of followers will automatically default to 1. Wecan also still change the number of followers if we would like.proﬁle.pydef profile_info(username, followers=1):    print("Username: " + username)    print("Followers: " + str(followers))profile_info(username="JOctopus")profile_info(username="sammyshark", followers=945)When we run the program with the python profile.py command,we’ll receive the following output:Output
Username: JOctopusFollowers: 1Username: sammysharkFollowers: 945Providing default parameters with values can let us skip deﬁningvalues for each argument that already has a default.Returning a ValueYou can pass a parameter value into a function, and a function can alsoproduce a value.A function can produce a value with the return statement, which willexit a function and optionally pass an expression back to the caller. If youuse a return statement with no arguments, the function will return None.So far, we have used the print() statement instead of the returnstatement in our functions. Let’s create a program that instead of printingwill return a variable.In a new text ﬁle called square.py, we’ll create a program thatsquares the parameter x and returns the variable y. We issue a call toprint the result variable, which is formed by running the square()function with 3 passed into it.square.pydef square(x):    y = x ** 2    return y
result = square(3)print(result)<figure class="code">We can run the program and see the output:python square.pyOutput9The integer 9 is returned as output, which is what we would expect byasking Python to ﬁnd the square of 3.To further understand how the return statement works, we cancomment out the return statement in the program:square.pydef square(x):    y = x ** 2    # return yresult = square(3)print(result)<figure class="code">Now, let’s run the program again:
python square.pyOutputNoneWithout using the return statement here, the program cannot returna value so the value defaults to None.As another example, in the add_numbers.py program above, wecould swap out the print() statement for a return statement.add_numbers.pydef add_numbers(x, y, z):    a = x + y    b = x + z    c = y + z    return a, b, csums = add_numbers(1, 2, 3)print(sums)<figure class="code">Outside of the function, we set the variable sums equal to the result ofthe function taking in 1, 2, and 3 as we did above. Then we called a printof the sums variable.Let’s run the program again now that it has the return statement:python add_numbers.py
Output(3, 4, 5)We receive the same numbers 3, 4, and 5 as output that we receivedpreviously by using the print() statement in the function. This time itis delivered as a tuple because the return statement’s expression list hasat least one comma.Functions exit immediately when they hit a return statement,whether or not they’re returning a value.return_loop.pydef loop_five():    for x in range(0, 25):        print(x)        if x == 5:            # Stop function at x == 5            return    print("This line will not execute.")loop_five()<figure class="code">Using the return statement within the for loop ends the function, sothe line that is outside of the loop will not run. If, instead, we had used a break statement, only the loop would have exited at that time, and thelast print() line would run.
The return statement exits a function, and may return a value whenissued with a parameter.Using main() as a FunctionAlthough in Python you can call the function at the bottom of yourprogram and it will run (as we have done in the examples above), manyprogramming languages (like C++ and Java) require a main function inorder to execute. Including a main() function, though not required, canstructure our Python programs in a logical way that puts the mostimportant components of the program into one function. It can also makeour programs easier for non-Python programmers to read.We’ll start with adding a main() function to the hello.py programabove. We’ll keep our hello() function, and then deﬁne a main()function:hello.pydef hello():    print("Hello, World!")def main():Within the main() function, let’s include a print() statement to letus know that we’re in the main() function. Additionally, let’s call the hello() function within the main() function:hello.pydef hello():    print("Hello, World!")
def main():    print("This is the main function")    hello()Finally, at the bottom of the program we’ll call the main() function:hello.pydef hello():    print("Hello, World!")def main():    print("This is the main function.")    hello()main()<figure class="code">At this point, we can run our program:python hello.pyWe’ll receive the following output:OutputThis is the main function.
Hello, World!Because we called the hello() function within main() and then onlycalled main() to run, the Hello, World! text printed only once, afterthe string that told us we were in the main function.Next we’re going to be working with multiple functions, so it is worthreviewing the variable scope of global and local variables. If you deﬁne avariable within a function block, you’ll only be able to use that variablewithin that function. If you would like to use variables across functions itmay be better to declare a global variable.In Python, '__main__' is the name of the scope where top-level codewill execute. When a program is run from standard input, a script, orfrom an interactive prompt, its __name__ is set equal to '__main__'.Because of this, there is a convention to use the following construction:if __name__ == '__main__':    # Code to run when this is the main program hereThis lets program ﬁles be used either: - as the main program and runwhat follows the if statement - as a module and not run what followsthe if statement.Any code that is not contained within this statement will be executedupon running. If you’re using your program ﬁle as a module, the codethat is not in this statement will also execute upon its import whilerunning the secondary ﬁle.Let’s expand on our names.py program above, and create a new ﬁlecalled more_names.py. In this program we’ll declare a global variable
and modify our original names() function so that the instructions are intwo discrete functions.The ﬁrst function, has_vowel() will check to see if the name stringcontains a vowel.The second function print_letters() will print each letter of the name string.more_names.py# Declare global variable name for use in all functionsname = str(input('Enter your name: '))# Define function to check if name contains a voweldef has_vowel():    if set('aeiou').intersection(name.lower()):        print('Your name contains a vowel.')    else:        print('Your name does not contain a vowel.')# Iterate over letters in name stringdef print_letters():    for letter in name:        print(letter)With this set up, let’s deﬁne the main() function which will contain acall to both the has_vowel() and the print_letters() functions.
more_names.py# Declare global variable name for use in all functionsname = str(input('Enter your name: '))# Define function to check if name contains a voweldef has_vowel():    if set('aeiou').intersection(name.lower()):        print('Your name contains a vowel.')    else:        print('Your name does not contain a vowel.')# Iterate over letters in name stringdef print_letters():    for letter in name:        print(letter)# Define main method that calls other functionsdef main():    has_vowel()    print_letters()Finally, we’ll add the if __name__ == '__main__': constructionat the bottom of the ﬁle. For our purposes, since we have put all the
functions we would like to do in the main() function, we’ll call the main() function following this if statement.more_names.py# Declare global variable name for use in all functionsname = str(input('Enter your name: '))# Define function to check if name contains a voweldef has_vowel():    if set('aeiou').intersection(name.lower()):        print('Your name contains a vowel.')    else:        print('Your name does not contain a vowel.')# Iterate over letters in name stringdef print_letters():    for letter in name:        print(letter)# Define main method that calls other functionsdef main():    has_vowel()    print_letters()
# Execute main() functionif __name__ == '__main__':    main()<figure class="code">We can now run the program:python more_names.pyThe program will show the same output as the names.py program,but here the code is more organized and can be used in a modular waywithout modiﬁcation.If you did not want to declare a main() function, you alternativelycould have ended the program like this:more_names.py...if __name__ == '__main__':    has_vowel()    print_letters()Using main() as a function and the if __name__ == '__main__': statement can organize your code in a logical way,making it more readable and modular.Conclusion
Functions are code blocks of instructions that perform actions within aprogram, helping to make our code reusable and modular.To learn more about how to make your code more modular, you canread our guide on How To Write Modules in Python 3.
How To Use *args and **kwargsIn function deﬁnitions, parameters are named entities that specify anargument that a given function can accept.When programming, you may not be aware of all the possible usecases of your code, and may want to offer more options for futureprogrammers working with the module, or for users interacting with thecode. We can pass a variable number of arguments to a function by using *args and **kwargs in our code.Understanding *argsIn Python, the single-asterisk form of *args can be used as a parameterto send a non-keyworded variable-length argument list to functions. It isworth noting that the asterisk (*) is the important element here, as theword args is the established conventional idiom, though it is notenforced by the language.Let’s look at a typical function that uses two arguments:lets_multiply.pydef multiply(x, y):    print (x * y)In the code above, we built the function with x and y as arguments,and then when we call the function, we need to use numbers tocorrespond with x and y. In this case, we will pass the integer 5 in for xand the integer 4 in for y:
lets_multiply.pydef multiply(x, y):    print (x * y)multiply(5, 4)Now, we can run the above code:python lets_multiply.pyWe’ll receive the following output, showing that the integers 5 and 4were multiplied as per the multiply(x,y) function:Output20What if, later on, we decide that we would like to multiply threenumbers rather than just two? If we try to add an additional number tothe function, as shown below, we’ll receive an error.lets_multiply.pydef multiply(x, y):    print (x * y)multiply(5, 4, 3)OutputTypeError: multiply() takes 2 positional arguments but 
3 were givenSo, if you suspect that you may need to use more arguments later on,you can make use of *args as your parameter instead.We can essentially create the same function and code that we showedin the ﬁrst example, by removing x and y as function parameters, andinstead replacing them with *args:lets_multiply.pydef multiply(*args):    z = 1    for num in args:        z *= num    print(z)multiply(4, 5)multiply(10, 9)multiply(2, 3, 4)multiply(3, 5, 10, 6)When we run this code, we’ll receive the product for each of thesefunction calls:Output209024900
Because we used *args to send a variable-length argument list to ourfunction, we were able to pass in as many arguments as we wished intothe function calls.With *args you can create more ﬂexible code that accepts a variedamount of non-keyworded arguments within your function.Understanding **kwargsThe double asterisk form of **kwargs is used to pass a keyworded,variable-length argument dictionary to a function. Again, the twoasterisks (**) are the important element here, as the word kwargs isconventionally used, though not enforced by the language.Like *args, **kwargs can take however many arguments you wouldlike to supply to it. However, **kwargs differs from *args in that youwill need to assign keywords.First, let’s simply print out the **kwargs arguments that we pass to afunction. We’ll create a short function to do this:print_kwargs.pydef print_kwargs(**kwargs):        print(kwargs)Next, we’ll call the function with some keyworded arguments passedinto the function:print_kwargs.pydef print_kwargs(**kwargs):        print(kwargs)
print_kwargs(kwargs_1="Shark", kwargs_2=4.5, kwargs_3=True)Let’s run the program above and look at the output:python print_kwargs.pyOutput{'kwargs_3': True, 'kwargs_2': 4.5, 'kwargs_1': 'Shark'}Because the dictionary data type is unordered, we received the key-value pairs in a random order, but it is important to note that a dictionarycalled **kwargs is created and we can work with it just like we canwork with other dictionaries.Let’s create another short program to show how we can make use of **kwargs. Here we’ll create a function to greet a dictionary of names.First, we’ll start with a dictionary of two names:print_values.pydef print_values(**kwargs):    for key, value in kwargs.items():        print("The value of {} is {}".format(key, value))print_values(my_name="Sammy", your_name="Casey")We can now run the program and look at the output:
python print_values.pyOutputThe value of your_name is CaseyThe value of my_name is SammyAgain, because dictionaries are unordered, your output may be withthe name Casey ﬁrst or with the name Sammy ﬁrst.Let’s now pass additional arguments to the function to show that **kwargs will accept however many arguments you would like toinclude:print_values.pydef print_values(**kwargs):    for key, value in kwargs.items():        print("The value of {} is {}".format(key, value))print_values(            name_1="Alex",            name_2="Gray",            name_3="Harper",            name_4="Phoenix",            name_5="Remy",            name_6="Val"        )
When we run the program at this point, we’ll receive the followingoutput, which is again unordered:OutputThe value of name_2 is GrayThe value of name_6 is ValThe value of name_4 is PhoenixThe value of name_5 is RemyThe value of name_3 is HarperThe value of name_1 is AlexUsing **kwargs provides us with ﬂexibility to use keywordarguments in our program. When we use **kwargs as a parameter, wedon’t need to know how many arguments we would eventually like topass to a function.Ordering ArgumentsWhen ordering arguments within a function or function call, argumentsneed to occur in a particular order:1. Formal positional arguments2. *args3. Keyword arguments4. **kwargsIn practice, when working with explicit positional parameters alongwith *args and **kwargs, your function would look like this:
def example(arg_1, arg_2, *args, **kwargs):...And, when working with positional parameters along with namedkeyword parameters in addition to *args and **kwargs, your functionwould look like this:def example2(arg_1, arg_2, *args, kw_1="shark", kw_2="blobfish", **kwargs):...It is important to keep the order of arguments in mind when creatingfunctions so that you do not receive a syntax error in your Python code.Using *args and **kwargs in Function CallsWe can also use *args and **kwargs to pass arguments into functions.First, let’s look at an example with *args.some_args.pydef some_args(arg_1, arg_2, arg_3):    print("arg_1:", arg_1)    print("arg_2:", arg_2)    print("arg_3:", arg_3)args = ("Sammy", "Casey", "Alex")some_args(*args)
In the function above, there are three parameters deﬁned as arg_1, arg_, and arg_3. The function will print out each of these arguments.We then create a variable that is set to an iterable (in this case, a tuple),and can pass that variable into the function with the asterisk syntax.When we run the program with the python some_args.pycommand, we’ll receive the following output:Outputarg_1: Sammyarg_2: Caseyarg_3: AlexWe can also modify the program above to an iterable list data typewith a different variable name. Let’s also combine the *args syntax witha named parameter:some_args.pydef some_args(arg_1, arg_2, arg_3):    print("arg_1:", arg_1)    print("arg_2:", arg_2)    print("arg_3:", arg_3)my_list = [2, 3]some_args(1, *my_list)If we run the program above, it will produce the following output:Output
arg_1: 1arg_2: 2arg_3: 3Similarly, the keyworded **kwargs arguments can be used to call afunction. We will set up a variable equal to a dictionary with 3 key-valuepairs (we’ll use kwargs here, but it can be called whatever you want),and pass it to a function with 3 arguments:some_kwargs.pydef some_kwargs(kwarg_1, kwarg_2, kwarg_3):    print("kwarg_1:", kwarg_1)    print("kwarg_2:", kwarg_2)    print("kwarg_3:", kwarg_3)kwargs = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_3": "Remy"}some_kwargs(**kwargs)Let’s run the program above with the python some_kwargs.pycommand:Outputkwarg_1: Valkwarg_2: Harperkwarg_3: Remy
When calling a function, you can use *args and **kwargs to passarguments.ConclusionWe can use the special syntax of *args and **kwargs within a functiondeﬁnition in order to pass a variable number of arguments to thefunction.Creating functions that accept *args and **kwargs are best used insituations where you expect that the number of inputs within theargument list will remain relatively small. The use of *args and **kwargs is primarily to provide readability and convenience, butshould be done with care.
How To Construct Classes and DeﬁneObjectsPython is an object-oriented programming language. Object-orientedprogramming (OOP) focuses on creating reusable patterns of code, incontrast to procedural programming, which focuses on explicitsequenced instructions. When working on complex programs inparticular, object-oriented programming lets you reuse code and writecode that is more readable, which in turn makes it more maintainable.One of the most important concepts in object-oriented programming isthe distinction between classes and objects, which are deﬁned as follows:Class — A blueprint created by a programmer for an object. Thisdeﬁnes a set of attributes that will characterize any object that isinstantiated from this class.Object — An instance of a class. This is the realized version of theclass, where the class is manifested in the program.These are used to create patterns (in the case of classes) and then makeuse of the patterns (in the case of objects).In this tutorial, we’ll go through creating classes, instantiating objects,initializing attributes with the constructor method, and working withmore than one object of the same class.ClassesClasses are like a blueprint or a prototype that you can deﬁne to use tocreate objects.
We deﬁne classes by using the class keyword, similar to how wedeﬁne functions by using the def keyword.Let’s deﬁne a class called Shark that has two functions associated withit, one for swimming and one for being awesome:shark.pyclass Shark:    def swim(self):        print("The shark is swimming.")    def be_awesome(self):        print("The shark is being awesome.")Because these functions are indented under the class Shark, they arecalled methods. Methods are a special kind of function that are deﬁnedwithin a class.The argument to these functions is the word self, which is a referenceto objects that are made based on this class. To reference instances (orobjects) of the class, self will always be the ﬁrst parameter, but it neednot be the only one.Deﬁning this class did not create any Shark objects, only the patternfor a Shark object that we can deﬁne later. That is, if you run theprogram above at this stage nothing will be returned.Creating the Shark class above provided us with a blueprint for anobject.Objects
An object is an instance of a class. We can take the Shark class deﬁnedabove, and use it to create an object or instance of it.We’ll make a Shark object called sammy:sammy = Shark()Here, we initialized the object sammy as an instance of the class bysetting it equal to Shark().Now, let’s use the two methods with the Shark object sammy:sammy = Shark()sammy.swim()sammy.be_awesome()The Shark object sammy is using the two methods swim() and be_awesome(). We called these using the dot operator (.), which isused to reference an attribute of the object. In this case, the attribute is amethod and it’s called with parentheses, like how you would also callwith a function.Because the keyword self was a parameter of the methods as deﬁnedin the Shark class, the sammy object gets passed to the methods. The self parameter ensures that the methods have a way of referring toobject attributes.When we call the methods, however, nothing is passed inside theparentheses, the object sammy is being automatically passed with the dotoperator.Let’s add the object within the context of a program:
shark.pyclass Shark:    def swim(self):        print("The shark is swimming.")    def be_awesome(self):        print("The shark is being awesome.")def main():    sammy = Shark()    sammy.swim()    sammy.be_awesome()if __name__ == "__main__":    main()<figure class="code">Let’s run the program to see what it does:python shark.pyOutputThe shark is swimming.The shark is being awesome.
The object sammy calls the two methods in the main() function of theprogram, causing those methods to run.The Constructor MethodThe constructor method is used to initialize data. It is run as soon as anobject of a class is instantiated. Also known as the __init__ method, itwill be the ﬁrst deﬁnition of a class and looks like this:class Shark:    def __init__(self):        print("This is the constructor method.")If you added the above __init__ method to the Shark class in theprogram above, the program would output the following without yourmodifying anything within the sammy instantiation:OutputThis is the constructor method.The shark is swimming.The shark is being awesome.This is because the constructor method is automatically initialized. Youshould use this method to carry out any initializing you would like to dowith your class objects.Instead of using the constructor method above, let’s create one thatuses a name variable that we can use to assign names to objects. We’llpass name as a parameter and set self.name equal to name:
shark.pyclass Shark:    def __init__(self, name):        self.name = nameNext, we can modify the strings in our functions to reference thenames, as below:shark.pyclass Shark:    def __init__(self, name):        self.name = name    def swim(self):        # Reference the name        print(self.name + " is swimming.")    def be_awesome(self):        # Reference the name        print(self.name + " is being awesome.")Finally, we can set the name of the Shark object sammy as equal to "Sammy" by passing it as a parameter of the Shark class:shark.pyclass Shark:    def __init__(self, name):        self.name = name
    def swim(self):        print(self.name + " is swimming.")    def be_awesome(self):        print(self.name + " is being awesome.")def main():    # Set name of Shark object    sammy = Shark("Sammy")    sammy.swim()    sammy.be_awesome()if __name__ == "__main__":    main()<figure class="code">We can run the program now:python shark.pyOutputSammy is swimming.Sammy is being awesome.
We see that the name we passed to the object is being printed out. Wedeﬁned the __init__ method with the parameter name (along with the self keyword) and deﬁned a variable within the method.Because the constructor method is automatically initialized, we do notneed to explicitly call it, only pass the arguments in the parenthesesfollowing the class name when we create a new instance of the class.If we wanted to add another parameter, such as age, we could do soby also passing it to the __init__ method:class Shark:    def __init__(self, name, age):        self.name = name        self.age = ageThen, when we create our object sammy, we can pass Sammy’s age inour statement:sammy = Shark("Sammy", 5)To make use of age, we would need to also create a method in theclass that calls for it.Constructor methods allow us to initialize certain attributes of anobject.Working with More Than One ObjectClasses are useful because they allow us to create many similar objectsbased on the same blueprint.
To get a sense for how this works, let’s add another Shark object toour program:shark.pyclass Shark:    def __init__(self, name):        self.name = name    def swim(self):        print(self.name + " is swimming.")    def be_awesome(self):        print(self.name + " is being awesome.")def main():    sammy = Shark("Sammy")    sammy.be_awesome()    stevie = Shark("Stevie")    stevie.swim()if __name__ == "__main__":  main()<figure class="code">We have created a second Shark object called stevie and passed thename "Stevie" to it. In this example, we used the be_awesome()method with sammy and the swim() method with stevie.
Let’s run the program:python shark.pyOutputSammy is being awesome.Stevie is swimming.The output shows that we are using two different objects, the sammyobject and the stevie object, both of the Shark class.Classes make it possible to create more than one object following thesame pattern without creating each one from scratch.ConclusionThis tutorial went through creating classes, instantiating objects,initializing attributes with the constructor method, and working withmore than one object of the same class.Object-oriented programming is an important concept to understandbecause it makes code recycling more straightforward, as objects createdfor one program can be used in another. Object-oriented programs alsomake for better program design since complex programs are difﬁcult towrite and require careful planning, and this in turn makes it less work tomaintain the program over time.
Understanding Class and Instance VariablesObject-oriented programming allows for variables to be used at the classlevel or the instance level. Variables are essentially symbols that stand infor a value you’re using in a program.At the class level, variables are referred to as class variables, whereasvariables at the instance level are called instance variables.When we expect variables are going to be consistent across instances,or when we would like to initialize a variable, we can deﬁne that variableat the class level. When we anticipate the variables will changesigniﬁcantly across instances, we can deﬁne them at the instance level.One of the principles of software development is the DRY principle,which stands for don’t repeat yourself. This principle is geared towardslimiting repetition within code, and object-oriented programmingadheres to the DRY principle as it reduces redundancy.This tutorial will demonstrate the use of both class and instancevariables in object-oriented programming within Python.Class VariablesClass variables are deﬁned within the class construction. Because theyare owned by the class itself, class variables are shared by all instances ofthe class. They therefore will generally have the same value for everyinstance unless you are using the class variable to initialize a variable.Deﬁned outside of all the methods, class variables are, by convention,typically placed right below the class header and before the constructormethod and other methods.
A class variable alone looks like this:class Shark:    animal_type = "fish"Here, the variable animal_type is assigned the value "fish".We can create an instance of the Shark class (we’ll call it new_shark)and print the variable by using dot notation:shark.pyclass Shark:    animal_type = "fish"new_shark = Shark()print(new_shark.animal_type)Let’s run the program:python shark.pyOutputfishOur program returns the value of the variable.Let’s add a few more class variables and print them out:shark.pyclass Shark:
    animal_type = "fish"    location = "ocean"    followers = 5new_shark = Shark()print(new_shark.animal_type)print(new_shark.location)print(new_shark.followers)Just like with any other variable, class variables can consist of any datatype available to us in Python. In this program we have strings and aninteger. Let’s run the program again with the python shark.pycommand and see the output:Outputfishocean5The instance of new_shark is able to access all the class variables andprint them out when we run the program.Class variables allow us to deﬁne variables upon constructing theclass. These variables and their associated values are then accessible toeach instance of the class.Instance VariablesInstance variables are owned by instances of the class. This means thatfor each object or instance of a class, the instance variables are different.
Unlike class variables, instance variables are deﬁned within methods.In the Shark class example below, name and age are instancevariables:class Shark:    def __init__(self, name, age):        self.name = name        self.age = ageWhen we create a Shark object, we will have to deﬁne these variables,which are passed as parameters within the constructor method oranother method.class Shark:    def __init__(self, name, age):        self.name = name        self.age = agenew_shark = Shark("Sammy", 5)As with class variables, we can similarly call to print instancevariables:shark.pyclass Shark:    def __init__(self, name, age):        self.name = name        self.age = age
new_shark = Shark("Sammy", 5)print(new_shark.name)print(new_shark.age)When we run the program above with python shark.py, we’llreceive the following output:OutputSammy5The output we receive is made up of the values of the variables that weinitialized for the object instance of new_shark.Let’s create another object of the Shark class called stevie:shark.pyclass Shark:    def __init__(self, name, age):        self.name = name        self.age = agenew_shark = Shark("Sammy", 5)print(new_shark.name)print(new_shark.age)stevie = Shark("Stevie", 8)print(stevie.name)
print(stevie.age)The stevie object, like the new_shark object passes the parametersspeciﬁc for that instance of the Shark class to assign values to theinstance variables.Instance variables, owned by objects of the class, allow for each objector instance to have different values assigned to those variables.Working with Class and Instance Variables TogetherClass variables and instance variables will often be utilized at the sametime, so let’s look at an example of this using the Shark class we created.The comments in the program outline each step of the process.shark.pyclass Shark:    # Class variables    animal_type = "fish"    location = "ocean"    # Constructor method with instance variables name and age    def __init__(self, name, age):        self.name = name        self.age = age    # Method with instance variable followers    def set_followers(self, followers):
        print("This user has " + str(followers) + " followers")def main():    # First object, set up instance variables of constructor method    sammy = Shark("Sammy", 5)    # Print out instance variable name    print(sammy.name)    # Print out class variable location    print(sammy.location)    # Second object    stevie = Shark("Stevie", 8)    # Print out instance variable name    print(stevie.name)    # Use set_followers method and pass followers instance variable    stevie.set_followers(77)    # Print out class variable animal_type    print(stevie.animal_type)
if __name__ == "__main__":    main()<figure class="code">When we run the program with python shark.py, we’ll receive thefollowing output:OutputSammyoceanStevieThis user has 77 followersfishHere, we have made use of both class and instance variables in twoobjects of the Shark class, sammy and stevie.ConclusionIn object-oriented programming, variables at the class level are referredto as class variables, whereas variables at the object level are calledinstance variables.This differentiation allows us to use class variables to initialize objectswith a speciﬁc value assigned to variables, and use different variables foreach object with instance variables.Making use of class- and instance-speciﬁc variables can ensure that ourcode adheres to the DRY principle to reduce repetition within code.
Understanding InheritanceObject-oriented programming creates reusable patterns of code to curtailredundancy in development projects. One way that object-orientedprogramming achieves recyclable code is through inheritance, when onesubclass can leverage code from another base class.This tutorial will go through some of the major aspects of inheritancein Python, including how parent classes and child classes work, how tooverride methods and attributes, how to use the super() function, andhow to make use of multiple inheritance.What Is Inheritance?Inheritance is when a class uses code constructed within another class. Ifwe think of inheritance in terms of biology, we can think of a childinheriting certain traits from their parent. That is, a child can inherit aparent’s height or eye color. Children also may share the same last namewith their parents.Classes called child classes or subclasses inherit methods and variablesfrom parent classes or base classes.We can think of a parent class called Parent that has class variablesfor last_name, height, and eye_color that the child class Child willinherit from the Parent.Because the Child subclass is inheriting from the Parent base class,the Child class can reuse the code of Parent, allowing the programmerto use fewer lines of code and decrease redundancy.Parent Classes
Parent or base classes create a pattern out of which child or subclassescan be based on. Parent classes allow us to create child classes throughinheritance without having to write the same code over again each time.Any class can be made into a parent class, so they are each fullyfunctional classes in their own right, rather than just templates.Let’s say we have a general Bank_account parent class that has Personal_account and Business_account child classes. Many ofthe methods between personal and business accounts will be similar,such as methods to withdraw and deposit money, so those can belong tothe parent class of Bank_account. The Business_account subclasswould have methods speciﬁc to it, including perhaps a way to collectbusiness records and forms, as well as an employee_identification_number variable.Similarly, an Animal class may have eating() and sleeping()methods, and a Snake subclass may include its own speciﬁc hissing()and slithering() methods.Let’s create a Fish parent class that we will later use to construct typesof ﬁsh as its subclasses. Each of these ﬁsh will have ﬁrst names and lastnames in addition to characteristics.We’ll create a new ﬁle called fish.py and start with the __init__()constructor method, which we’ll populate with first_name and last_name class variables for each Fish object or subclass.ﬁsh.pyclass Fish:    def __init__(self, first_name, last_name="Fish"):        self.first_name = first_name        self.last_name = last_name
We have initialized our last_name variable with the string "Fish"because we know that most ﬁsh will have this as their last name.Let’s also add some other methods:ﬁsh.pyclass Fish:    def __init__(self, first_name, last_name="Fish"):        self.first_name = first_name        self.last_name = last_name    def swim(self):        print("The fish is swimming.")    def swim_backwards(self):        print("The fish can swim backwards.")We have added the methods swim() and swim_backwards() to the Fish class, so that every subclass will also be able to make use of thesemethods.Since most of the ﬁsh we’ll be creating are considered to be bony ﬁsh(as in they have a skeleton made out of bone) rather than cartilaginousﬁsh (as in they have a skeleton made out of cartilage), we can add a fewmore attributes to the __init__() method:ﬁsh.pyclass Fish:    def __init__(self, first_name, last_name="Fish",                 skeleton="bone", eyelids=False):
        self.first_name = first_name        self.last_name = last_name        self.skeleton = skeleton        self.eyelids = eyelids    def swim(self):        print("The fish is swimming.")    def swim_backwards(self):        print("The fish can swim backwards.")Building a parent class follows the same methodology as building anyother class, except we are thinking about what methods the child classeswill be able to make use of once we create those.Child ClassesChild or subclasses are classes that will inherit from the parent class. Thatmeans that each child class will be able to make use of the methods andvariables of the parent class.For example, a Goldfish child class that subclasses the Fish classwill be able to make use of the swim() method declared in Fish withoutneeding to declare it.We can think of each child class as being a class of the parent class.That is, if we have a child class called Rhombus and a parent class called Parallelogram, we can say that a Rhombus is a Parallelogram, justas a Goldfish is a Fish.The ﬁrst line of a child class looks a little different than non-childclasses as you must pass the parent class into the child class as a
parameter:class Trout(Fish):The Trout class is a child of the Fish class. We know this because ofthe inclusion of the word Fish in parentheses.With child classes, we can choose to add more methods, overrideexisting parent methods, or simply accept the default parent methodswith the pass keyword, which we’ll do in this case:ﬁsh.py...class Trout(Fish):    passWe can now create a Trout object without having to deﬁne anyadditional methods.ﬁsh.py...class Trout(Fish):    passterry = Trout("Terry")print(terry.first_name + " " + terry.last_name)print(terry.skeleton)print(terry.eyelids)terry.swim()
terry.swim_backwards()We have created a Trout object terry that makes use of each of themethods of the Fish class even though we did not deﬁne those methodsin the Trout child class. We only needed to pass the value of "Terry" tothe first_name variable because all of the other variables wereinitialized.When we run the program, we’ll receive the following output:OutputTerry FishboneFalseThe fish is swimming.The fish can swim backwards.Next, let’s create another child class that includes its own method.We’ll call this class Clownfish, and its special method will permit it tolive with sea anemone:ﬁsh.py...class Clownfish(Fish):    def live_with_anemone(self):        print("The clownfish is coexisting with sea anemone.")
Next, let’s create a Clownfish object to see how this works:ﬁsh.py...casey = Clownfish("Casey")print(casey.first_name + " " + casey.last_name)casey.swim()casey.live_with_anemone()When we run the program, we’ll receive the following output:OutputCasey FishThe fish is swimming.The clownfish is coexisting with sea anemone.The output shows that the Clownfish object casey is able to use the Fish methods __init__() and swim() as well as its child classmethod of live_with_anemone().If we try to use the live_with_anemone() method in a Troutobject, we’ll receive an error:Outputterry.live_with_anemone()AttributeError: 'Trout' object has no attribute 'live_with_anemone'
This is because the method live_with_anemone() belongs only tothe Clownfish child class, and not the Fish parent class.Child classes inherit the methods of the parent class it belongs to, soeach child class can make use of those methods within programs.Overriding Parent MethodsSo far, we have looked at the child class Trout that made use of the pass keyword to inherit all of the parent class Fish behaviors, andanother child class Clownfish that inherited all of the parent classbehaviors and also created its own unique method that is speciﬁc to thechild class. Sometimes, however, we will want to make use of some of theparent class behaviors but not all of them. When we change parent classmethods we override them.When constructing parent and child classes, it is important to keepprogram design in mind so that overriding does not produceunnecessary or redundant code.We’ll create a Shark child class of the Fish parent class. Because wecreated the Fish class with the idea that we would be creating primarilybony ﬁsh, we’ll have to make adjustments for the Shark class that isinstead a cartilaginous ﬁsh. In terms of program design, if we had morethan one non-bony ﬁsh, we would most likely want to make separateclasses for each of these two types of ﬁsh.Sharks, unlike bony ﬁsh, have skeletons made of cartilage instead ofbone. They also have eyelids and are unable to swim backwards. Sharkscan, however, maneuver themselves backwards by sinking.In light of this, we’ll be overriding the __init__() constructormethod and the swim_backwards() method. We don’t need to modify
the swim() method since sharks are ﬁsh that can swim. Let’s take a lookat this child class:ﬁsh.py...class Shark(Fish):    def __init__(self, first_name, last_name="Shark",                 skeleton="cartilage", eyelids=True):        self.first_name = first_name        self.last_name = last_name        self.skeleton = skeleton        self.eyelids = eyelids    def swim_backwards(self):        print("The shark cannot swim backwards, but can sink backwards.")We have overridden the initialized parameters in the __init__()method, so that the last_name variable is now set equal to the string "Shark", the skeleton variable is now set equal to the string "cartilage", and the eyelids variable is now set to the Booleanvalue True. Each instance of the class can also override theseparameters.The method swim_backwards() now prints a different string thanthe one in the Fish parent class because sharks are not able to swimbackwards in the way that bony ﬁsh can.We can now create an instance of the Shark child class, which will stillmake use of the swim() method of the Fish parent class:
ﬁsh.py...sammy = Shark("Sammy")print(sammy.first_name + " " + sammy.last_name)sammy.swim()sammy.swim_backwards()print(sammy.eyelids)print(sammy.skeleton)When we run this code, we’ll receive the following output:OutputSammy SharkThe fish is swimming.The shark cannot swim backwards, but can sink backwards.TruecartilageThe Shark child class successfully overrode the __init__() and swim_backwards() methods of the Fish parent class, while alsoinheriting the swim() method of the parent class.When there will be a limited number of child classes that are moreunique than others, overriding parent class methods can prove to beuseful.The super() Function
With the super() function, you can gain access to inherited methodsthat have been overwritten in a class object.When we use the super() function, we are calling a parent methodinto a child method to make use of it. For example, we may want tooverride one aspect of the parent method with certain functionality, butthen call the rest of the original parent method to ﬁnish the method.In a program that grades students, we may want to have a child classfor Weighted_grade that inherits from the Grade parent class. In thechild class Weighted_grade, we may want to override a calculate_grade() method of the parent class in order to includefunctionality to calculate a weighted grade, but still keep the rest of thefunctionality of the original class. By invoking the super() function wewould be able to achieve this.The super() function is most commonly used within the __init__() method because that is where you will most likely need toadd some uniqueness to the child class and then complete initializationfrom the parent.To see how this works, let’s modify our Trout child class. Since troutare typically freshwater ﬁsh, let’s add a water variable to the __init__() method and set it equal to the string "freshwater", butthen maintain the rest of the parent class’s variables and parameters:ﬁsh.py...class Trout(Fish):    def __init__(self, water = "freshwater"):        self.water = water        super().__init__(self)
...We have overridden the __init__() method in the Trout childclass, providing a different implementation of the __init__() that isalready deﬁned by its parent class Fish. Within the __init__()method of our Trout class we have explicitly invoked the __init__()method of the Fish class.Because we have overridden the method, we no longer need to pass first_name in as a parameter to Trout, and if we did pass in aparameter, we would reset freshwater instead. We will thereforeinitialize the first_name by calling the variable in our object instance.Now we can invoke the initialized variables of the parent class andalso make use of the unique child variable. Let’s use this in an instance ofTrout:ﬁsh.py...terry = Trout()# Initialize first nameterry.first_name = "Terry"# Use parent __init__() through super()print(terry.first_name + " " + terry.last_name)print(terry.eyelids)# Use child __init__() overrideprint(terry.water)
# Use parent swim() methodterry.swim()OutputTerry FishFalsefreshwaterThe fish is swimming.The output shows that the object terry of the Trout child class isable to make use of both the child-speciﬁc __init__() variable waterwhile also being able to call the Fish parent __init__() variables of first_name, last_name, and eyelids.The built-in Python function super() allows us to utilize parent classmethods even when overriding certain aspects of those methods in ourchild classes.Multiple InheritanceMultiple inheritance is when a class can inherit attributes and methodsfrom more than one parent class. This can allow programs to reduceredundancy, but it can also introduce a certain amount of complexity aswell as ambiguity, so it should be done with thought to overall programdesign.To show how multiple inheritance works, let’s create a Coral_reefchild class than inherits from a Coral class and a Sea_anemone class.We can create a method in each and then use the pass keyword in the Coral_reef child class:
coral_reef.pyclass Coral:    def community(self):        print("Coral lives in a community.")class Anemone:    def protect_clownfish(self):        print("The anemone is protecting the clownfish.")class CoralReef(Coral, Anemone):    passThe Coral class has a method called community() that prints oneline, and the Anemone class has a method called protect_clownfish() that prints another line. Then we call bothclasses into the inheritance tuple. This means that Coral is inheritingfrom two parent classes.Let’s now instantiate a Coral object:coral_reef.py...great_barrier = CoralReef()great_barrier.community()
great_barrier.protect_clownfish()The object great_barrier is set as a CoralReef object, and can usethe methods in both parent classes. When we run the program, we’ll seethe following output:OutputCoral lives in a community.The anemone is protecting the clownfish.The output shows that methods from both parent classes wereeffectively used in the child class.Multiple inheritance allows us to use the code from more than oneparent class in a child class. If the same method is deﬁned in multipleparent methods, the child class will use the method of the ﬁrst parentdeclared in its tuple list.Though it can be used effectively, multiple inheritance should be donewith care so that our programs do not become ambiguous and difﬁcultfor other programmers to understand.ConclusionThis tutorial went through constructing parent classes and child classes,overriding parent methods and attributes within child classes, using the super() function, and allowing for child classes to inherit from multipleparent classes.Inheritance in object-oriented coding can allow for adherence to theDRY (don’t repeat yourself) principle of software development, allowingfor more to be done with less code and repetition. Inheritance also
compels programmers to think about how they are designing theprograms they are creating to ensure that code is effective and clear.
How To Apply Polymorphism to ClassesPolymorphism is the ability to leverage the same interface for differentunderlying forms such as data types or classes. This permits functions touse entities of different types at different times.For object-oriented programming in Python, this means that aparticular object belonging to a particular class can be used in the sameway as if it were a different object belonging to a different class.Polymorphism allows for ﬂexibility and loose coupling so that codecan be extended and easily maintained over time.This tutorial will go through applying polymorphism to classes inPython.What Is Polymorphism?Polymorphism is an important feature of class deﬁnition in Python that isutilized when you have commonly named methods across classes orsubclasses. This allows functions to use objects of any of thesepolymorphic classes without needing to be aware of distinctions acrossthe classes.Polymorphism can be carried out through inheritance, with subclassesmaking use of base class methods or overriding them.Python’s duck typing, a special case of dynamic typing, usestechniques characteristic of polymorphism, including late binding anddynamic dispatch. The term “duck typing” is derived from a quote ofwriter James Whitcomb Riley: “When I see a bird that walks like a duckand swims like a duck and quacks like a duck, I call that bird a duck.”
Appropriated by Italian computer engineer Alex Martelli in a message tothe comp.lang.python newsgroup, the use of duck typing is concernedwith establishing the suitability of an object for a speciﬁc purpose. Whenusing normal typing this suitability is determined by the type of an objectalone, but with duck typing the presence of methods and properties areused to determine suitability rather than the actual type of the object inquestion. That is to say, you check whether the object quacks like a duckand walks like a duck rather than asking whether the object is a duck.When several classes or subclasses have the same method names, butdifferent implementations for these same methods, the classes arepolymorphic because they are using a single interface to use with entitiesof different types. A function will be able to evaluate these polymorphicmethods without knowing which classes are invoked.Creating Polymorphic ClassesTo make use of polymorphism, we’re going to create two distinct classesto use with two distinct objects. Each of these distinct classes need tohave an interface that is in common so that they can be usedpolymorphically, so we will give them methods that are distinct but thathave the same name.We’ll create a Shark class and a Clownfish class, each of which willdeﬁne methods for swim(), swim_backwards(), and skeleton().polymorphic_ﬁsh.pyclass Shark():    def swim(self):        print("The shark is swimming.")
    def swim_backwards(self):        print("The shark cannot swim backwards, but can sink backwards.")    def skeleton(self):        print("The shark's skeleton is made of cartilage.")class Clownfish():    def swim(self):        print("The clownfish is swimming.")    def swim_backwards(self):        print("The clownfish can swim backwards.")    def skeleton(self):        print("The clownfish's skeleton is made of bone.")In the code above, both the Shark and Clownfish class have threemethods with the same name in common. However, each of thefunctionalities of these methods differ for each class.Let’s instantiate these classes into two objects:polymorphic_ﬁsh.py...sammy = Shark()
sammy.skeleton()casey = Clownfish()casey.skeleton()When we run the program with the python polymorphic_fish.py command, we can see that each object behavesas expected:OutputThe shark's skeleton is made of cartilage.The clownfish's skeleton is made of bone.Now that we have two objects that make use of a common interface,we can use the two objects in the same way regardless of their individualtypes.Polymorphism with Class MethodsTo show how Python can use each of these different class types in thesame way, we can ﬁrst create a for loop that iterates through a tuple ofobjects. Then we can call the methods without being concerned aboutwhich class type each object is. We will only assume that these methodsactually exist in each class.polymorphic_ﬁsh.py...sammy = Shark()
casey = Clownfish()for fish in (sammy, casey):    fish.swim()    fish.swim_backwards()    fish.skeleton()We have two objects, sammy of the Shark class, and casey of the Clownfish class. Our for loop iterates through these objects, calling theswim(), swim_backwards(), and skeleton() methods on each.When we run the program, the output will be as follows:OutputThe shark is swimming.The shark cannot swim backwards, but can sink backwards.The shark's skeleton is made of cartilage.The clownfish is swimming.The clownfish can swim backwards.The clownfish's skeleton is made of bone.The for loop iterated ﬁrst through the sammy instantiation of the Shark class, then the casey object of the Clownfish class, so we seethe methods related to the Shark class ﬁrst, then the Clownfish class.This shows that Python is using these methods in a way withoutknowing or caring exactly what class type each of these objects is. That is,using these methods in a polymorphic way.
Polymorphism with a FunctionWe can also create a function that can take any object, allowing forpolymorphism.Let’s create a function called in_the_pacific() which takes in anobject we can call fish. Though we are using the name fish, anyinstantiated object will be able to be called into this function:polymorphic_ﬁsh.py…def in_the_pacific(fish):Next, we’ll give the function something to do that uses the fish objectwe passed to it. In this case we’ll call the swim() methods, each of whichis deﬁned in the two classes Shark and Clownfish:polymorphic_ﬁsh.py...def in_the_pacific(fish):    fish.swim()Next, we’ll create instantiations of both the Shark and Clownfishclasses if we don’t have them already. With those, we can call their actionusing the same in_the_pacific() function:polymorphic_ﬁsh.py...def in_the_pacific(fish):
    fish.swim()sammy = Shark()casey = Clownfish()in_the_pacific(sammy)in_the_pacific(casey)When we run the program, the output will be as follows:OutputThe shark is swimming.The clownfish is swimming.Even though we passed a random object (fish) into the in_the_pacific() function when deﬁning it, we were still able to useit effectively for instantiations of the Shark and Clownfish classes. The casey object called the swim() method deﬁned in the Clownfish class,and the sammy object called the swim() method deﬁned in the Sharkclass.ConclusionBy allowing different objects to leverage functions and methods insimilar ways through polymorphism, making use of this Python featureprovides greater ﬂexibility and extendability of your object-orientedcode.
How To Use the Python DebuggerIn software development, debugging is the process of looking for andthen resolving issues that prevent the software from running correctly.The Python debugger provides a debugging environment for Pythonprograms. It supports setting conditional breakpoints, stepping throughthe source code one line at a time, stack inspection, and more.Working Interactively with the Python DebuggerThe Python debugger comes as part of the standard Python distributionas a module called pdb. The debugger is also extensible, and is deﬁned asthe class Pdb. You can read the ofﬁcial documentation of pdb to learnmore.We’ll begin by working with a short program that has two globalvariables, a function that creates a nested loop, and the if __name__ == '__main__': construction that will call the nested_loop()function.looping.pynum_list = [500, 600, 700]alpha_list = ['x', 'y', 'z']def nested_loop():    for number in num_list:        print(number)
        for letter in alpha_list:            print(letter)if __name__ == '__main__':    nested_loop()We can now run this program through the Python debugger by usingthe following command:python -m pdb looping.pyThe -m command-line ﬂag will import any Python module for you andrun it as a script. In this case we are importing and running the pdbmodule, which we pass into the command as shown above.Upon running this command, you’ll receive the following output:Output> /Users/sammy/looping.py(1)<module>()-> num_list = [500, 600, 700](Pdb)In the output, the ﬁrst line contains the current module name (asindicated with <module>) with a directory path, and the printed linenumber that follows (in this case it’s 1, but if there is a comment or othernon-executable line it could be a higher number). The second line showsthe current line of source code that is executed here, as pdb provides aninteractive console for debugging. You can use the command help tolearn its commands, and help command to learn more about a speciﬁc
command. Note that the pdb console is different than the Pythoninteractive shell.The Python debugger will automatically start over when it reaches theend of your program. Whenever you want to leave the pdb console, typethe command quit or exit. If you would like to explicitly restart aprogram at any place within the program, you can do so with thecommand run.Using the Debugger to Move through a ProgramWhen working with programs in the Python debugger, you’re likely touse the list, step, and next commands to move through your code.We’ll go over these commands in this section.Within the shell, we can type the command list in order to getcontext around the current line. From the ﬁrst line of the program looping.py that we displayed above — num_list = [500, 600, 700] — that will look like this:(Pdb) list  1  -> num_list = [500, 600, 700]  2     alpha_list = ['x', 'y', 'z']  3       4       5     def nested_loop():  6         for number in num_list:  7             print(number)  8             for letter in alpha_list:  9                 print(letter) 10     
 11     if __name__ == '__main__':(Pdb)The current line is indicated with the characters ->, which in our caseis the ﬁrst line of the program ﬁle.Since this is a relatively short program, we receive nearly all of theprogram back with the list command. Without providing arguments,the list command provides 11 lines around the current line, but youcan also specify which lines to include, like so:(Pdb) list 3, 7  3       4       5     def nested_loop():  6         for number in num_list:  7             print(number)(Pdb)Here, we requested that the lines 3-7 be displayed by using thecommand list 3, 7.To move through the program line by line, we can use step or next:(Pdb) step> /Users/sammy/looping.py(2)<module>()-> alpha_list = ['x', 'y', 'z'](Pdb)(Pdb) next
> /Users/sammy/looping.py(2)<module>()-> alpha_list = ['x', 'y', 'z'](Pdb)The difference between step and next is that step will stop within acalled function, while next executes called functions to only stop at thenext line of the current function. We can see this difference when wework with the function.The step command will iterate through the loops once it gets to therunning of the function, showing exactly what the loop is doing, as it willﬁrst print a number with print(number) then go through to print theletters with print(letter), return to the number, etc:(Pdb) step> /Users/sammy/looping.py(5)<module>()-> def nested_loop():(Pdb) step> /Users/sammy/looping.py(11)<module>()-> if __name__ == '__main__':(Pdb) step> /Users/sammy/looping.py(12)<module>()-> nested_loop()(Pdb) step--Call--> /Users/sammy/looping.py(5)nested_loop()-> def nested_loop():(Pdb) step> /Users/sammy/looping.py(6)nested_loop()
-> for number in num_list:(Pdb) step> /Users/sammy/looping.py(7)nested_loop()-> print(number)(Pdb) step500> /Users/sammy/looping.py(8)nested_loop()-> for letter in alpha_list:(Pdb) step> /Users/sammy/looping.py(9)nested_loop()-> print(letter)(Pdb) stepx> /Users/sammy/looping.py(8)nested_loop()-> for letter in alpha_list:(Pdb) step> /Users/sammy/looping.py(9)nested_loop()-> print(letter)(Pdb) stepy> /Users/sammy/looping.py(8)nested_loop()-> for letter in alpha_list:(Pdb)The next command, instead, will execute the entire function withoutshowing the step-by-step process. Let’s quit the current session with the exit command and then begin the debugger again:
python -m pdb looping.pyNow we can work with the next command:(Pdb) next> /Users/sammy/looping.py(5)<module>()-> def nested_loop():(Pdb) next> /Users/sammy/looping.py(11)<module>()-> if __name__ == '__main__':(Pdb) next> /Users/sammy/looping.py(12)<module>()-> nested_loop()(Pdb) next500xyz600xyz700xyz--Return--> /Users/sammy/looping.py(12)<module>()->None
-> nested_loop()(Pdb)  While going through your code, you may want to examine the valuepassed to a variable, which you can do with the pp command, which willpretty-print the value of the expression using the pprint module:(Pdb) pp num_list[500, 600, 700](Pdb)Most commands in pdbhave shorter aliases. For step that short formis s, and for next it is n. The help command will list available aliases.You can also call the last command you called by pressing the ENTER keyat the prompt.BreakpointsYou typically will be working with larger programs than the exampleabove, so you’ll likely be wanting to look at particular functions or linesrather than going through an entire program. By using the breakcommand to set breakpoints, you’ll run the program up until thespeciﬁed breakpoint.When you insert a breakpoint, the debugger assigns a number to it.The numbers assigned to breakpoints are successive integers that beginwith the number 1, which you can refer to when working withbreakpoints.Breakpoints can be placed at certain line numbers by following thesyntax of <program_file>:<line_number> as shown below:
(Pdb) break looping.py:5Breakpoint 1 at /Users/sammy/looping.py:5(Pdb)Type clear and then y to remove all current breakpoints. You canthen place a breakpoint where a function is deﬁned:(Pdb) break looping.nested_loopBreakpoint 1 at /Users/sammy/looping.py:5(Pdb)To remove current breakpoints, type clear and then y. You can alsoset up a condition:(Pdb) break looping.py:7, number > 500Breakpoint 1 at /Users/sammy/looping.py:7(Pdb)     Now, if we issue the continue command, the program will breakwhen the number x is evaluated to being greater than 500 (that is, whenit is set equal to 600 in the second iteration of the outer loop):(Pdb) continue500xyz> /Users/sammy/looping.py(7)nested_loop()
-> print(number)(Pdb)To see a list of breakpoints that are currently set to run, use thecommand break without any arguments. You’ll receive informationabout the particularities of the breakpoint(s) you’ve set:(Pdb) breakNum Type         Disp Enb   Where1   breakpoint   keep yes   at /Users/sammy/looping.py:7    stop only if number > 500    breakpoint already hit 2 times(Pdb)We can also disable a breakpoint with the command disable and thenumber of the breakpoint. In this session, we add another breakpoint andthen disable the ﬁrst one:(Pdb) break looping.py:11Breakpoint 2 at /Users/sammy/looping.py:11(Pdb) disable 1Disabled breakpoint 1 at /Users/sammy/looping.py:7(Pdb) breakNum Type         Disp Enb   Where1   breakpoint   keep no    at /Users/sammy/looping.py:7    stop only if number > 500
    breakpoint already hit 2 times2   breakpoint   keep yes   at /Users/sammy/looping.py:11(Pdb)To enable a breakpoint, use the enable command, and to remove abreakpoint entirely, use the clear command:(Pdb) enable 1Enabled breakpoint 1 at /Users/sammy/looping.py:7(Pdb) clear 2Deleted breakpoint 2 at /Users/sammy/looping.py:11(Pdb)Breakpoints in pdb provide you with a lot of control. Some additionalfunctionalities include ignoring breakpoints during the current iterationof the program with the ignore command (as in ignore 1), triggeringactions to occur at a breakpoint with the commands command (as in command 1), and creating temporary breakpoints that are automaticallycleared the ﬁrst time program execution hits the point with the commandtbreak (for a temporary break at line 3, for example, you could type tbreak 3).Integrating pdb into ProgramsYou can trigger a debugging session by importing the pdb module andadding the pdb function pdb.set_trace() above the line where youwould like the session to begin.
In our sample program above, we’ll add the import statement and thefunction where we would like to enter into the debugger. For ourexample, let’s add it before the nested loop.# Import pdb moduleimport pdbnum_list = [500, 600, 700]alpha_list = ['x', 'y', 'z']def nested_loop():    for number in num_list:        print(number)        # Trigger debugger at this line        pdb.set_trace()        for letter in alpha_list:            print(letter)if __name__ == '__main__':    nested_loop()By adding the debugger into your code you do not need to launchyour program in a special way or remember to set breakpoints.Importing the pdb module and running the pdb.set_trace()function lets you begin your program as usual and run the debuggerthrough its execution.
Modifying Program Execution FlowThe Python debugger lets you change the ﬂow of your program atruntime with the jump command. This lets you skip forward to preventsome code from running, or can let you go backwards to run the codeagain.We’ll be working with a small program that creates a list of the letterscontained in the string sammy = "sammy":letter_list.pydef print_sammy():    sammy_list = []    sammy = "sammy"    for letter in sammy:        sammy_list.append(letter)        print(sammy_list)if __name__ == "__main__":    print_sammy()If we run the program as usual with the python letter_list.pycommand, we’ll receive the following output:Output['s']['s', 'a']['s', 'a', 'm']['s', 'a', 'm', 'm']
['s', 'a', 'm', 'm', 'y']With the Python debugger, let’s show how we can change theexecution by ﬁrst jumping ahead after the ﬁrst cycle. When we do this,we’ll notice that there is a disruption of the for loop:python -m pdb letter_list.py> /Users/sammy/letter_list.py(1)<module>()-> def print_sammy():(Pdb) list  1  -> def print_sammy():  2         sammy_list = []  3         sammy = "sammy"  4         for letter in sammy:  5             sammy_list.append(letter)  6             print(sammy_list)  7       8     if __name__ == "__main__":  9         print_sammy() 10      11     (Pdb) break 5Breakpoint 1 at /Users/sammy/letter_list.py:5(Pdb) continue> /Users/sammy/letter_list.py(5)print_sammy()-> sammy_list.append(letter)(Pdb) pp letter
's'(Pdb) continue['s']> /Users/sammy/letter_list.py(5)print_sammy()-> sammy_list.append(letter)(Pdb) jump 6> /Users/sammy/letter_list.py(6)print_sammy()-> print(sammy_list)(Pdb) pp letter'a'(Pdb) disable 1Disabled breakpoint 1 at /Users/sammy/letter_list.py:5(Pdb) continue['s']['s', 'm']['s', 'm', 'm']['s', 'm', 'm', 'y']The above debugging session puts a break at line 5 to prevent codefrom continuing, then continues through code (along with pretty-printing some values of letter to show what is happening). Next, weuse the jump command to skip to line 6. At this point, the variable letter is set equal to the string 'a', but we jump the code that addsthat to the list sammy_list. We then disable the breakpoint to proceedwith the execution as usual with the continue command, so 'a' isnever appended to sammy_list.Next, we can quit this ﬁrst session and restart the debugger to jumpback within the program to re-run a statement that has already been
executed. This time, we’ll run the ﬁrst iteration of the for loop again inthe debugger:> /Users/sammy/letter_list.py(1)<module>()-> def print_sammy():(Pdb) list  1  -> def print_sammy():  2         sammy_list = []  3         sammy = "sammy"  4         for letter in sammy:  5             sammy_list.append(letter)  6             print(sammy_list)  7       8     if __name__ == "__main__":  9         print_sammy() 10      11     (Pdb) break 6Breakpoint 1 at /Users/sammy/letter_list.py:6(Pdb) continue> /Users/sammy/letter_list.py(6)print_sammy()-> print(sammy_list)(Pdb) pp letter's'(Pdb) jump 5> /Users/sammy/letter_list.py(5)print_sammy()-> sammy_list.append(letter)(Pdb) continue
> /Users/sammy/letter_list.py(6)print_sammy()-> print(sammy_list)(Pdb) pp letter's'(Pdb) disable 1Disabled breakpoint 1 at /Users/sammy/letter_list.py:6(Pdb) continue['s', 's']['s', 's', 'a']['s', 's', 'a', 'm']['s', 's', 'a', 'm', 'm']['s', 's', 'a', 'm', 'm', 'y']In the debugging session above, we added a break at line 6, and thenjumped back to line 5 after continuing. We pretty-printed along the wayto show that the string 's' was being appended to the list sammy_listtwice. We then disabled the break at line 6 and continued running theprogram. The output shows two values of 's' appended to sammy_list.Some jumps are prevented by the debugger, especially when jumpingin and out of certain ﬂow control statements that are undeﬁned. Forexample, you cannot jump into functions before arguments are deﬁned,and you cannot jump into the middle of a try:except statement. Youalso cannot jump out of a finally block.The jump statement with the Python debugger allows you to changethe execution ﬂow while debugging a program to see whether ﬂowcontrol can be modiﬁed to different purposes or to better understandwhat issues are arising in your code.
Table of Common pdb CommandsHere is a table of useful pdb commands along with their short forms tokeep in mind while working with the Python debugger.COMMANDSHORT FORMWHAT IT DOESargsaPrint the argument list of thecurrent functionbreakbCreates a breakpoint (requiresparameters) in the programexecutioncontinuec or contContinues program executionhelphProvides list of commands orhelp for a speciﬁed commandjumpjSet the next line to be executedlistlPrint the source code aroundthe current linenextnContinue execution until thenext line in the currentfunction is reached or returnsstepsExecute the current line,stopping at ﬁrst possibleoccasionppppPretty-prints the value of theexpression
quit or exitqAborts the programreturnrContinue execution until thecurrent function returnsYou can read more about the commands and working with thedebugger from the Python debugger documentation.ConclusionDebugging is an important step of any software development project.The Python debugger pdb implements an interactive debuggingenvironment that you can use with any of your programs written inPython.With features that let you pause your program, look at what valuesyour variables are set to, and go through program execution in a discretestep-by-step manner, you can more fully understand what your programis doing and ﬁnd bugs that exist in the logic or troubleshoot knownissues.
How To Debug Python with an InteractiveConsoleDebugging is a part of the software development process whereprogrammers look for and then resolve issues that prevent the softwarefrom running correctly.A useful and quick tool for debugging is the Python code modulebecause it can be used to emulate the interactive interpreter. The modulealso provides the opportunity for you to experiment with code that youwrite in Python.Understanding the code ModuleRather than step through code with a debugger, you can add the codemodule to your Python program to instruct the program to stopexecution and enter into the interactive mode in order to examine howyour code is working. The code module is part of the Python standardlibrary.This is useful because you are able to leverage an interpreter withoutsacriﬁcing the complexity and permanence that programming ﬁles canprovide. Through using the code module you can avoid using print()statements throughout your code as a form of debugging, which canbecome unwieldy over time.To make use of the module as a method for debugging, you can use theinteract() function of the module, which stops execution of theprogram at the point at which it is called, and provides you with an
interactive console so that you can examine the current state of yourprogram.The function with its possible parameters are as follows:code.interact(banner=None, readfunc=None, local=None, exitmsg=None)This function runs a read-eval-print loop, and creates an objectinstance of the InteractiveConsole class, which emulates thebehavior of the interactive Python interpreter.The optional parameters are as follows: - banner can be set to a string,so that you can ﬂag where the interpreter launches - readfunc can beused as the InteractiveConsole.raw_input() method - localwill set the default namespace for the interpreter loop - exitmsg can beset to a string to note where the interpreter endsWith the local parameter, you can use, for example: - local=locals() for a local namespace - local=globals() for aglobal namespace - local=dict(globals(), **locals()) to useboth the global namespace and the present local namespaceNote that the exitmsg parameter is new for Python 3.6, so if you areusing an older version of Python, update it or leave off the exitmsgparameter.You can place the interact() function wherever you would like inyour program to launch the interactive interpreter in the code.Working with the code ModuleLet’s look at this in the context of a bank account balances program calledbalances.py. We’ll set the local parameter to locals() to set the
namespace to local.balances.py# Import code moduleimport codebal_a = 2324bal_b = 0bal_c = 409bal_d = -2account_balances = [bal_a, bal_b, bal_c, bal_d]def display_bal():    for balance in account_balances:        if balance < 0:            print("Account balance of {} is below 0; add funds now."                  .format(balance))        elif balance == 0:            print("Account balance of {} is equal to 0; add funds soon."                  .format(balance))        else:            print("Account balance of {} is above 
0.".format(balance))# Use interact() function to start the interpreter with local namespacecode.interact(local=locals())display_bal()We used the function code.interact() with the local=locals()parameter to use the local namespace as the default within the interpreterloop.Let’s run the program above, using the python3 command if we’renot in a virtual environment, or the python command if we are:python balances.pyOnce we run the program, we’ll receive the following output initially:Python 3.5.2 (default, Nov 17 2016, 17:05:23)[GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.(InteractiveConsole)>>>Your cursor will be placed at the end of the >>> line, just like it wouldbe in the Python interactive shell.From here, you can issue calls to print variables, functions, etc.:
>>> print(bal_c)409>>> print(account_balances)[2324, 0, 409, -2]>>> print(display_bal())Account balance of 2324 is 0 or above.Account balance of 0 is equal to 0, add funds soon.Account balance of 409 is 0 or above.Account balance of -2 is below 0, add funds now.None>>> print(display_bal)<function display_bal at 0x104b80f28>>>>We see that, by using the local namespace, we are able to print thevariables and invoke the function. The ﬁnal print() call shows thelocation of the function display_bal within computer memory.Once you are satisﬁed with what you have been able to examine fromworking with the interpreter, you can press CTRL + D for *nix-basedsystems, or CTRL + Z for Windows-based systems to leave the consoleand continue with the execution of the program.If you would like to leave the console without running the remainderof the program, you can do so by typing quit() and the program willbe aborted.To leverage the banner and exitmsg parameters, we can do so asfollows:balances.py
...# Use interact() function to start the interpretercode.interact(banner="Start", local=locals(), exitmsg="End")display_bal()When we run the program, we’ll receive the following output when werun the program:Start>>>Using the banner parameter can allow you to set multiple pointswithin your code and give you the ability to identify them. For example,you can have a banner that prints "In for-loop" with an exitmsgthat prints "Out of for-loop", so you can tell exactly where you arein the code.From here, we can use the interpreter as usual. Once we type CTRL + D to exit the interpreter, we’ll receive the exit message and the functionwill run:EndAccount balance of 2324 is 0 or above.Account balance of 0 is equal to 0, add funds soon.Account balance of 409 is 0 or above.Account balance of -2 is below 0, add funds now.
The program has now fully run following the interactive session.Once you are done using the code module to debug your code, youshould remove the code functions and import statement so that yourprogram will run as usual. The code module provides a utility, so onceyou are done it is important to clean up after yourself.ConclusionUsing the code module to launch an interactive console can allow you tolook at what the code is doing on a granular level to understand itsbehavior and make changes as needed. To read more about it, you canread the ofﬁcial documentation of the code module.To learn more about other methods you can use to debug your Pythoncode, read our tutorial on how to use the Python debugger pdb, and ourtutorial on how to use logging.
How To Use LoggingThe logging module is part of the standard Python library andprovides tracking for events that occur while software runs. You can addlogging calls to your code to indicate what events have happened.The logging module allows for both diagnostic logging that recordsevents related to an application’s operation, as well as audit loggingwhich records the events of a user’s transactions for analysis. It isespecially used to record events to a ﬁle.Why Use the logging ModuleThe logging module keeps a record of the events that occur within aprogram, making it possible to see output related to any of the eventsthat occur throughout the runtime of a piece of software.You may be more familiar with checking that events are occurring byusing the print() statement throughout your code. The print()statement does provide a basic way to go about debugging your code toresolve issues. While embedding print() statements throughout yourcode can track the execution ﬂow and the current state of your program,this solution proves to be less maintainable than using the loggingmodule for a few reasons:It becomes difﬁcult to distinguish between debugging output andnormal program output because the two are mixedWhen using print() statements dispersed throughout code, thereis no easy way to disable the ones that provide debugging output
It becomes difﬁcult to remove all the print() statements when youare done with debuggingThere is no log record that contains readily available diagnosticinformationIt is a good idea to get in the habit of using the logging module inyour code as this is more suitable for applications that grow beyondsimple Python scripts and provides a sustainable approach to debugging.Because logs can show you behavior and errors over time, they alsocan give you a better overall picture of what is going on in yourapplication development process.Printing Debug Messages to ConsoleIf you are used to using the print() statement to see what is occurringin a program, you may be used to seeing a program that deﬁnes a classand instantiates objects that looks something like this:pizza.pyclass Pizza():    def __init__(self, name, price):        self.name = name        self.price = price        print("Pizza created: {} (${})".format(self.name, self.price))    def make(self, quantity=1):        print("Made {} {} pizza(s)".format(quantity, self.name))
    def eat(self, quantity=1):        print("Ate {} pizza(s)".format(quantity, self.name))pizza_01 = Pizza("artichoke", 15)pizza_01.make()pizza_01.eat()pizza_02 = Pizza("margherita", 12)pizza_02.make(2)pizza_02.eat()The code above has an __init__ method to deﬁne the name and price of an object of the Pizza class. It then has two methods, onecalled make() for making pizzas, and one called eat() for eatingpizzas. These two methods take in the parameter of quantity, which isinitialized at 1.Now let’s run the program:python pizza.pyWe’ll receive the following output:OutputPizza created: artichoke ($15)Made 1 artichoke pizza(s)Ate 1 pizza(s)
Pizza created: margherita ($12)Made 2 margherita pizza(s)Ate 1 pizza(s)While the print() statement allows us to see that the code isworking, we can use the logging module to do this instead.Let’s remove or comment out the print() statements throughout thecode, and add import logging to the top of the ﬁle:pizza.pyimport loggingclass Pizza():    def __init__(self, name, value):        self.name = name        self.value = value...The logging module has a default level of WARNING, which is a levelabove DEBUG. Since we’re going to use the logging module fordebugging in this example, we need to modify the conﬁguration so thatthe level of logging.DEBUG will return information to the console forus. We can do that by adding the following line below the importstatement:pizza.pyimport logging
logging.basicConfig(level=logging.DEBUG)class Pizza():...This level of logging.DEBUG refers to a constant integer value thatwe reference in the code above to set a threshold. The level of DEBUG is10.Now, we will replace all of the print() statements with logging.debug() statements instead. Unlike logging.DEBUG whichis a constant, logging.debug() is a method of the logging module.When working with this method, we can make use of the same stringpassed to print(), as shown below.pizza.pyimport logginglogging.basicConfig(level=logging.DEBUG)class Pizza():    def __init__(self, name, price):        self.name = name        self.price = price        logging.debug("Pizza created: {} (${})".format(self.name, self.price))
    def make(self, quantity=1):        logging.debug("Made {} {} pizza(s)".format(quantity, self.name))    def eat(self, quantity=1):        logging.debug("Ate {} pizza(s)".format(quantity, self.name))pizza_01 = Pizza("artichoke", 15)pizza_01.make()pizza_01.eat()pizza_02 = Pizza("margherita", 12)pizza_02.make(2)pizza_02.eat()At this point, when we run the program with the python pizza.pycommand, we’ll receive this output:OutputDEBUG:root:Pizza created: artichoke ($15)DEBUG:root:Made 1 artichoke pizza(s)DEBUG:root:Ate 1 pizza(s)DEBUG:root:Pizza created: margherita ($12)DEBUG:root:Made 2 margherita pizza(s)DEBUG:root:Ate 1 pizza(s)
The log messages have the severity level DEBUG as well as the word root embedded in them, which refers to the level of your Pythonmodule. The logging module can be used with a hierarchy of loggersthat have different names, so that you can use a different logger for eachof your modules.For example, you can set loggers equal to different loggers that havedifferent names and different output:logger1 = logging.getLogger("module_1")logger2 = logging.getLogger("module_2")logger1.debug("Module 1 debugger")logger2.debug("Module 2 debugger")OutputDEBUG:module_1:Module 1 debuggerDEBUG:module_2:Module 2 debuggerNow that we have an understanding of how to use the loggingmodule to print messages to the console, let’s move on to using the logging module to print messages out to a ﬁle.Logging Messages to a FileThe primary purpose of the logging module is to log messages to a ﬁlerather than to a console. Keeping a ﬁle of messages provides you withdata over time that you can consult and quantify so that you can seewhat changes need to be made to your code.
To start logging to a ﬁle, we can modify the logging.basicConfig() method to include a filename parameter.In this case, let’s call the ﬁlename test.log:pizza.pyimport logginglogging.basicConfig(filename="test.log", level=logging.DEBUG)class Pizza():    def __init__(self, name, price):        self.name = name        self.price = price        logging.debug("Pizza created: {} (${})".format(self.name, self.price))    def make(self, quantity=1):        logging.debug("Made {} {} pizza(s)".format(quantity, self.name))    def eat(self, quantity=1):        logging.debug("Ate {} pizza(s)".format(quantity, self.name))pizza_01 = Pizza("artichoke", 15)pizza_01.make()
pizza_01.eat()pizza_02 = Pizza("margherita", 12)pizza_02.make(2)pizza_02.eat()The code above is the same as it was in the previous section, exceptthat now we added the ﬁlename for the log to print to. Once we run thecode with the python pizza.py command, we should have a new ﬁlein our directory called test.log.Let’s open the test.log ﬁle with nano (or the text editor of yourchoice):nano test.logWhen the ﬁle opens, we’ll see the following:test.logDEBUG:root:Pizza created: artichoke ($15)DEBUG:root:Made 1 artichoke pizza(s)DEBUG:root:Ate 1 pizza(s)DEBUG:root:Pizza created: margherita ($12)DEBUG:root:Made 2 margherita pizza(s)DEBUG:root:Ate 1 pizza(s)This is similar to the console output that we encountered in theprevious section, except now it is in the test.log ﬁle.
Let’s close the ﬁle with CTRL + x and move back into the pizza.pyﬁle so that we can modify the code.We’ll keep much of the code the same, but modify the parameters inthe two pizza instances, pizza_01 and pizza_02:pizza.pyimport logginglogging.basicConfig(filename="test.log", level=logging.DEBUG)class Pizza():    def __init__(self, name, price):        self.name = name        self.price = price        logging.debug("Pizza created: {} (${})".format(self.name, self.price))    def make(self, quantity=1):        logging.debug("Made {} {} pizza(s)".format(quantity, self.name))    def eat(self, quantity=1):        logging.debug("Ate {} pizza(s)".format(quantity, self.name))# Modify the parameters of the pizza_01 object
pizza_01 = Pizza("Sicilian", 18)pizza_01.make(5)pizza_01.eat(4)# Modify the parameters of the pizza_02 objectpizza_02 = Pizza("quattro formaggi", 16)pizza_02.make(2)pizza_02.eat(2)With these changes, let’s run the program again with the python pizza.py command.Once the program has run, we can open our test.log ﬁle again withnano:nano test.logWhen we look at the ﬁle, we’ll see that several new lines were added,and that the previous lines from the last time that the program ran wereretained:test.logDEBUG:root:Pizza created: artichoke ($15)DEBUG:root:Made 1 artichoke pizza(s)DEBUG:root:Ate 1 pizza(s)DEBUG:root:Pizza created: margherita ($12)DEBUG:root:Made 2 margherita pizza(s)DEBUG:root:Ate 1 pizza(s)DEBUG:root:Pizza created: Sicilian ($18)
DEBUG:root:Made 5 Sicilian pizza(s)DEBUG:root:Ate 4 pizza(s)DEBUG:root:Pizza created: quattro formaggi ($16)DEBUG:root:Made 2 quattro formaggi pizza(s)DEBUG:root:Ate 2 pizza(s)While this information is certainly useful, we can make the log moreinformative by adding additional LogRecord attributes. Primarily, wewould like to add a human-readable time stamp that tells us when theLogRecord was created.We can add that attribute to a parameter called format, referencing itas shown in the table with the string %(asctime)s. Additionally, tokeep the DEBUG level name, we’ll need to include the string %(levelname)s and to keep the string message that we ask the logger toprint out we’ll include %(message)s. Each of these attributes will beseparated by a colon, as shown in the code added below.pizza.pyimport logginglogging.basicConfig(    filename="test.log",    level=logging.DEBUG,    format="%(asctime)s:%(levelname)s:%(message)s"    )class Pizza():
    def __init__(self, name, price):        self.name = name        self.price = price        logging.debug("Pizza created: {} (${})".format(self.name, self.price))    def make(self, quantity=1):        logging.debug("Made {} {} pizza(s)".format(quantity, self.name))    def eat(self, quantity=1):        logging.debug("Ate {} pizza(s)".format(quantity, self.name))pizza_01 = Pizza("Sicilian", 18)pizza_01.make(5)pizza_01.eat(4)pizza_02 = Pizza("quattro formaggi", 16)pizza_02.make(2)pizza_02.eat(2)When we run the code above with the added attributes with the python pizza.py command, we’ll get new lines added to our test.log ﬁle that include the human-readable time stamp in additionto the level name of DEBUG and the associated messages that are passedinto the logger as strings.
OutputDEBUG:root:Pizza created: Sicilian ($18)DEBUG:root:Made 5 Sicilian pizza(s)DEBUG:root:Ate 4 pizza(s)DEBUG:root:Pizza created: quattro formaggi ($16)DEBUG:root:Made 2 quattro formaggi pizza(s)DEBUG:root:Ate 2 pizza(s)2017-05-01 16:28:54,593:DEBUG:Pizza created: Sicilian ($18)2017-05-01 16:28:54,593:DEBUG:Made 5 Sicilian pizza(s)2017-05-01 16:28:54,593:DEBUG:Ate 4 pizza(s)2017-05-01 16:28:54,593:DEBUG:Pizza created: quattro formaggi ($16)2017-05-01 16:28:54,593:DEBUG:Made 2 quattro formaggi pizza(s)2017-05-01 16:28:54,593:DEBUG:Ate 2 pizza(s)Depending on your needs, you may want to make use of additionalLogRecord attributes in your code in order to make your program ﬁles’logs relevant to you.Logging debugging and other messages into separate ﬁles providesyou with a holistic understanding of your Python program over time,giving you the opportunity to troubleshoot and modify your code in amanner that is informed by the historical work put into the program, aswell as the events and transactions that occur.Table of Logging Levels
As a developer, you can ascribe a level of importance to the event that iscaptured in the logger by adding a severity level. The severity levels areshown in the table below.Logging levels are technically integers (a constant), and they are all inincrements of 10, starting with NOTSET which initializes the logger at thenumeric value of 0.You can also deﬁne your own levels relative to the predeﬁned levels. Ifyou deﬁne a level with the same numeric value, you will overwrite thename associated with that value.The table below shows the various level names, their numeric value,what function you can use to call the level, and what that level is usedfor.LEVELNUMERIC VALUEFUNCTIONUSED TOCRITICAL50logging.critical()Show a serious error,the program may beunable to continuerunningERROR40logging.error()Show a more seriousproblemWARNING30logging.warning()Indicate somethingunexpectedhappened, or couldhappenINFO20logging.info()Conﬁrm that thingsare working asexpected
DEBUG10logging.debug()Diagnose problems,show detailedinformationThe logging module sets the default level at WARNING, so WARNING, ERROR, and CRITICAL will all be logged by default. In the exampleabove, we modiﬁed the conﬁguration to include the DEBUG level with thefollowing code:logging.basicConfig(level=logging.DEBUG)You can read more about the commands and working with thedebugger from the ofﬁcial logging documentation.ConclusionDebugging is an important step of any software development project.The logging module is part of the standard Python library, providestracking for events that occur while software runs, and can output theseevents to a separate log ﬁle to allow you to keep track of what occurswhile your code runs. This provides you with the opportunity to debugyour code based on understanding the various events that occur fromrunning your program over time.
How To Port Python 2 Code to Python 3Python was developed in the late 1980s and ﬁrst published in 1991. Witha name inspired by the British comedy group Monty Python, Python wasconceived as a successor to the imperative general-purpose ABCprogramming language. In its ﬁrst iteration, Python already includedexception handling, functions, and classes with inheritance.This tutorial will guide you through best practices and considerationsto make when migrating code from Python 2 to Python 3 and whetheryou should maintain code that is compatible with both versions.BackgroundPython 2 was published in 2000, signalling a more transparent andinclusive language development process. It included many moreprogrammatic features and added more features throughout itsdevelopment.Python 3 is regarded as the future of Python and is the version of thelanguage that is currently in development. Released in late 2008, Python3 addressed and amended intrinsic design ﬂaws. However, Python 3adoption has been slow due to the language not being backwardscompatible with Python 2.Python 2.7 was published in 2010 as the last of the 2.x releases. Theintention behind Python 2.7 was to make it easier for Python 2.x users toport features over to Python 3 by providing some measure ofcompatibility between the two.
You can learn more about Python versions and choosing which to useby reading our tutorial “Python 2 vs Python 3: Practical Considerations.”Start with Python 2.7To move to Python 3, or to support Python 2 and Python 3simultaneously, you should ensure that your Python 2 code is completelyPython 2.7 compatible.Many developers have already been working exclusively with Python2.7 code, but it is important to conﬁrm that anything that is onlysupported by earlier versions is working properly with Python 2.7 and isconsistent with Python 2.7 style.Making sure that your code is in Python 2.7 is especially importantbecause it is the only version of Python 2 that is still being maintainedand receiving bugﬁxes. If you are working on an earlier version ofPython 2, you will have to work around issues you encounter with codethat is no longer supported and is no longer receiving buxﬁxes.Additionally, some tools that make it easier for you to port code, suchas the Pylint package that looks for programming errors, is not supportedby versions of Python that are earlier than 2.7.It is important to keep in mind that though Python 2.7 is currently stillbeing supported and maintained, it will eventually meet its end of life.PEP 373 details the Python 2.7 release schedule and, at the time ofwriting, marks its sunset date as 2020.Test CoverageCreating test cases can be an important part of the work done to migratePython 2 to Python 3 code. If you are maintaining more than one version
of Python, you should also ensure that your test suite has good coverageoverall to ensure that each version is still working as expected.As part of your testing, you can add interactive Python cases to thedocstrings of all of your functions, methods, classes, and modules andthen use the built-in doctest module to verify that they work as shown.Alongside doctest, you can use the coverage.py package to trackunit test coverages. This tool will monitor your program and note whichparts of the code have been executed and which parts could have beenexecuted but were not. coverage.py can print out reports to thecommand line or provide HTML output. It is typically used to measurethe effectiveness of tests, showing you what parts of the code are beingexercised by testing and which are not.Keep in mind that you are not aiming for 100% test coverage — youwant to make sure that you cover any code that is confusing or unusual.For best practices, you should aim for 80% coverage.Learn About Differences Between Python 2 and Python 3Learning about the differences between Python 2 and Python 3 willensure that you are able to leverage the new features that are available, orwill be available, in Python 3.Our guide on “Python 2 vs Python 3” goes over some of the keydifferences between the two versions, and you can review the ofﬁcialPython documentation for more detail.When getting started with porting and migration, there are severalsyntax changes that you can implement now.print
The print statement of Python 2 has changed to a print() function inPython 3.PYTHON 2PYTHON 3print "Hello, World!"print("Hello, World!")execThe exec statement of Python 2 has changed to a function that allowsexplicit locals and globals in Python 3.PYTHON 2PYTHON 3exec codeexec(code)exec code in globalsexec(code, globals)exec code in (globals, locals)exec(code, globals, locals)/ and //Python 2 does ﬂoor division with the / operator, Python 3 introduced //for ﬂoor division.PYTHON 2PYTHON 35 / 2 = 25 / 2 = 2.55 // 2 = 2To make use of these operators in Python 2, import division fromthe __future__ module:
from __future__ import divisionRead more about division with integers.raiseIn Python 3, raising exceptions with arguments requires parentheses, andstrings cannot be used as exceptions.PYTHON 2PYTHON 3raise Exception, argsraise Exceptionraise Exception(args)raise Exception, args, tracebackraise Exception(args).with_traceback(traceback)raise "Error"raise Exception("Error")exceptIn Python 2 it was difﬁcult to list multiple exceptions, but that haschanged in Python 3.Note that as is used explicitly with except in Python 3PYTHON 2PYTHON 3except Exception, variable:except AnException as variable:except (OneException, TwoException) as variable:
defIn Python 2, functions can take in sequences like tuples or lists. In Python3, this unpacking has been removed.PYTHON 2PYTHON 3def function(arg1, (x, y)):def function(arg1, x_y): x, y = x_yexprThe backtick syntax of Python 2 no longer exists. Use repr() or str.format() in Python 3.PYTHON 2PYTHON 3x = `355/113`x = repr(355/113):String FormattingString formatting syntax has changed from Python 2 to Python 3.PYTHON 2PYTHON 3"%d %s" % (i, s)"{} {}".format(i, s)"%d/%d=%f" % (355, 113, 355/113)"{:d}/{:d}={:f}".format(355, 113, 355/113)Learn How To Use String Formatters in Python 3.classThere is no need to state object in Python 3.Python 2
class MyClass(object):    passPython 3class MyClass:    passIn Python 3, metaclasses are set with the metaclass keyword.Python 2class MyClass:    __metaclass__ = MyMetaclass MyClass(MyBase):    __metaclass__ = MyMetaPython 3class MyClass(metaclass=type):    passclass MyClass(MyBase, metaclass=MyMeta):    passUpdate Code
There are two main tools you can use to automatically update your codeto Python 3 while keeping it compatible with Python 2: future andmodernize. Each of these tools behaves somewhat differently: futureworks to make Python 3 idioms and best practices exist in Python 2,while modernize aims for a Python 2/3 subset of Python that uses thePython six module to improve compatibility.Using these tools to handle the details of rewriting the code can helpyou identify and correct potential problems and ambiguities.You can run the tool over your unittest suite to visually inspect andverify the code, and ensure that the automatic revisions made areaccurate. Once the tests pass, you can transform your code.From here, you will likely need to do some manual revision, especiallytargeting the changes between Python 2 and 3 noted in the section above.Leveraging future, you should consider adding this importstatement to each of your Python 2.7 modules:from __future__ import print_function, division, absolute_imports, unicode_literalsWhile this will also lead to rewrites, it will ensure that your Python 2code aligns with Python 3 syntax.Finally, you can use the pylint package to identify any otherpotential issues in the code. This package contains hundreds ofindividual rules that cover a broad spectrum of problems that may occur,including PEP 8 style guide rules, as well as usage errors.You may ﬁnd that there are some constructs in your code that couldpotentially confuse pylint and tools used for automatic migration. If
you can’t simplify these constructs, you’ll need to employ thoroughunittest cases.Continuous IntegrationIf you’re going to maintain your code for multiple versions of Python,you’ll need to remain vigilant about running and re-running yourunittest suite through continuous integration (rather than manually) asoften as possible on the code as you develop it.If you make use of the six package as part of your Python 2 and 3compatibility maintenance, you’ll need to use multiple environments foryour testing.One environment management tool you may consider using is the toxpackage, as it will check your package installs with different Pythonversions, run tests in each of your environments, and act as a frontend toContinuous Integration servers.ConclusionIt is important to keep in mind that as more developer and communityattention focuses on Python 3, the language will become more reﬁnedand in-line with the evolving needs of programmers, and less supportwill be given to Python 2.7. If you decide to maintain versions of yourcode base for both Python 2 and Python 3, you may have increasingdifﬁculty with the former as it will receive fewer bugﬁxes over time.It is worthwhile to look at projects that ported Python 2 to Python 3,including case studies such as Porting chardet to Python 3.

  
Page 1 / 978 A complete analysis of the Tizen platform with 70 easily understandable examples.  
 
Author: Jung, Dong -Geun (Denis.Jung)  
Except as noted, this content - excluding the Code Examples - is 
licensed under Creative Commons Attribution 3.0 and all of the 
Code Examples contained herein  are licensed under BSD -3-
Clause.  
For details, see the Content License  
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
  

  
Page 2 / 978 Table Of Contents  
Table Of Contents  ................................ ................................ ................................ ................................ .............  2 
1. Introducing EFL  ................................ ................................ ................................ ................................ ............  6 
2. Establishing a Tizen Development Environment  ................................ ................................ ...... 11 
3. Running a Tizen Development Environment ................................ ................................ ..............  22 
4. Executing Examples  ................................ ................................ ................................ ................................  31 
5. Creating a BasicUI example  ................................ ................................ ................................ ...............  42 
6. Using a Label Widget  ................................ ................................ ................................ .........................  65 
7. Using a Button Widget  ................................ ................................ ................................ .....................  73 
8. Creating a Background with a Bg Widget  ................................ ................................ ............  90 
9. Resizing the Screen with a Conformant Container  ................................ ........................  102 
10. Using an Entry Widget  ................................ ................................ ................................ .................  110 
11. Using a Check Widget  ................................ ................................ ................................ ...................  123 
12. Using a Radio Widget  ................................ ................................ ................................ ...................  135 
13. Using a Popup  ................................ ................................ ................................ ................................ ... 148 
14. Using a Slider Widget  ................................ ................................ ................................ ...................  168 
15. Adding a Text Item to the List Widget.  ................................ ................................ ............  177 
16. Displaying an Icon in a GenList Widget  ................................ ................................ ............  188 
17. Creating a Complex Gallery Widget  ................................ ................................ .....................  202 
18. Creating a Simple Web Browser Using the WebView Widget  .............................  215 
  
Page 3 / 978 19. Implementing a Tab Screen with a Layout Container  ................................ ................  227 
20. Implementing a Header and a Navigation Bar with a Naviframe Widget  ... 236 
21. Placing Widgets in Sequence with the Box Container  ................................ ..............  248 
22. Creating a Sub Page with a Scroller Widget  ................................ ................................ .. 260 
23. Using Strings  ................................ ................................ ................................ ................................ ....... 273 
24. The String Structure 'Eina_Strbuf'  ................................ ................................ ...........................  285 
25. Array Structure Eina_List  ................................ ................................ ................................ ...............  295 
26. Using Timers ................................ ................................ ................................ ................................ ........ 309 
27. Time & Date  ................................ ................................ ................................ ................................ ....... 316 
28. Calendar Example  ................................ ................................ ................................ .............................  331 
29. Requesting a Mouse Touch Event  ................................ ................................ ..........................  346 
30. Calculator Example  ................................ ................................ ................................ ...........................  356 
31. Displaying a Gradient on the Canvas  ................................ ................................ ..................  373 
32. Displaying a Square on the Canvas  ................................ ................................ ......................  384 
33. Displaying Polygons on the Canvas  ................................ ................................ ......................  389 
34. Displaying Text on the Canvas  ................................ ................................ ................................ . 397 
35. Displaying an Image on the Canvas  ................................ ................................ .....................  402 
36. Creating a Customized Button  ................................ ................................ ................................ . 412 
37. Using an Animator  ................................ ................................ ................................ ..........................  430 
38. Playing Audio  ................................ ................................ ................................ ................................ ...... 452 
  
Page 4 / 978 39. Playing Video  ................................ ................................ ................................ ................................ ...... 468 
40. Recording Audio  ................................ ................................ ................................ ................................  488 
41. Camera Capture  ................................ ................................ ................................ ................................ . 509 
42. System Information  ................................ ................................ ................................ .........................  532 
43. System Preferences  ................................ ................................ ................................ ..........................  546 
44. Battery Status  ................................ ................................ ................................ ................................ ..... 557 
45. Generating Vibration  ................................ ................................ ................................ .......................  567 
46. LED Flash Backlight  ................................ ................................ ................................ .........................  580 
47. Event for Rotating the Screen Orientation  ................................ ................................ ....... 589 
48. Hardware Key Events and Debug Mode  ................................ ................................ ............  601 
49. Lifecycle and Debug Mode  ................................ ................................ ................................ ......... 611 
50. Using a Notify  ................................ ................................ ................................ ................................ .... 622 
51. Using a Acceleration Sensor  ................................ ................................ ................................ ...... 638 
52. Using a Gravity Sensor  ................................ ................................ ................................ .................  653 
53. Using an Orientation Sensor  ................................ ................................ ................................ ..... 662 
54. Using a Magnetic Sensor  ................................ ................................ ................................ .............  674 
55. Using a Proximity Sensor  ................................ ................................ ................................ ............  686 
56. Using a GPS Sensor  ................................ ................................ ................................ ........................  695 
57. Google Maps Library  ................................ ................................ ................................ ......................  708 
58. Reading and Writing Text Files ................................ ................................ ................................  753 
  
Page 5 / 978 59. Requesting a File List ................................ ................................ ................................ .....................  767 
60. Using Preference  ................................ ................................ ................................ ...............................  786 
61. Example of Making a Report Card with SQLite  ................................ ............................  797 
62. Calling an External App Using AppControl  ................................ ................................ ...... 818 
63. Developing a Service App  ................................ ................................ ................................ ........... 842 
64. Alarm: Starting an APP at a Specified Time  ................................ ................................ ... 852 
65. Text to Speech (TTS)  ................................ ................................ ................................ ......................  867 
66. Multi -Language Support  ................................ ................................ ................................ ...............  882 
67. JSON Parsing  ................................ ................................ ................................ ................................ ....... 897 
68. XML Parsing  ................................ ................................ ................................ ................................ ......... 907 
69. Checking Network Status  ................................ ................................ ................................ .............  923 
70. HTTP Communication  ................................ ................................ ................................ .....................  936 
71. Creating a Wearable Source Project  ................................ ................................ .....................  949 
72. Wearable System Information  ................................ ................................ ................................ ... 959 
73. Using a Pressure Sensor  ................................ ................................ ................................ ..............  968 
 
 
  
  
Page 6 / 978 1. Introducing EFL  
The core part of Tizen Native API consists of EFL, which is a complex library 
integrating multiple libraries.  
The following picture is the diagram of an EFL block.  
 
An upper library refers to its sub libraries. For instance, Elementary relies on 
all of the sub libraries, while Encore refers to Evas, Eet, and Eina.  
1) Eina  
Eina, one of the most basic elements of EFL, is a data structure library. Similar 
to STL of C++, it provides users with useful features to implement complex 
logics including alignment, list, hash, tree, and shared strings in an easy, fast, 
and safe way. These features of data structure allow applications, as well as all 
EFL libraries in the upper leve l of Eina library, to effectively practice necessary 
logics.  

  
Page 7 / 978 2) Eet  
Eet performs the role of data encoding and decoding. You can save arbitrary 
data structures or image data as compressed files, or transfer them to a 
different machine via a network. You ca n also read the compressed files and 
decode them later. Using this compression feature of Eet which is very similar 
to the principle of .Zip files, you can instantly access data located in an 
arbitrary place from a file. If you use the encryption function,  you can store 
data stably.  
  
3) Evas  
Evas plays the role of a canvas. Evas enables you to express images, texts, and 
different shapes including squares, lines, and polygons within a Window . All 
outputs are objectified. As Evas provides these objects as a n Evas_Object type, 
you can access all graphic obje cts using the interface of Evas_ Object during 
programming, and express desired graphic objects on the screen. In addition, 
the interface is provided for Evas so that each object properly responds to 
events  that you input.  
Evas adopts a retained -mode as a rendering method, which manages objects 
throughout the scene graph internally, and automatically optimizes and 
renders objects to be seen on the screen. Thus, app developers are not 
encumbered by a complicated rendering mechanism.  
Basically, Evas supports the rendering methods of a software, but also helps 
the acceleration of hardware via back -end supports.  
  
Page 8 / 978 4) Ecore  
As a system -based library supporting users' convenience, Ecore provides 
functions rel ated to main loop, timing, event, connection, IPC, thread, 
Windows systems, and so on. Ecore internally processes complicated settings 
and stages of use related to the API of each system. This simplification helps 
users to save time and effort when they pr actice the functions of the system 
in person.  
EFL applications work based on a main loop provided by Ecore. As the 
functions provided by Ecore are processed in connection with the main logic 
of Ecore's main loop, if necessary, you should use not the system  API, but the 
functions provided by Ecore.  
  
5) Edje  
Edje provides functions to compose a complicated GUI. Edje uses EDC as a 
script language. Referring to the EDC script, you can separate the GUI from 
the program code to design a program. EDC is converted  to the type of EDJ 
binary throughout the edje_cc compiler. The program can read this EDJ file 
during the run time to bind it as an Evas_Object to build a GUI. Due to this 
Edje feature, you can change the design of the GUI in an application without 
complyi ng it again.   
  
  
Page 9 / 978 6) Embryo  
Embryo, a virtual machine of bytecode, is used for a small program which can 
be implemented within an EDC file. In most cases, you can additionally use 
Embryo script language with C -language style to practice simple calculations 
or functions like changing the status of each object. This kind of Embryo script 
is converted to PAWN binary via the PAWN compiler. The PAWN program does 
not need to reply on the environments of a machine; instead, it can be 
deciphered via the virtual machi ne of Abstract Machine eXecutive (AMX) for 
operation. In addition, only one output guarantees the same operation in 
different system environments.  
  
7) Emotion  
Emotion is the library of video and audio playback. Emotion plays a video 
using other video play  plug-ins including Gstreamer, Xine, or VLC. The video 
outputs are synchronized with Evas objects to be provided to a user. 
Accordingly, the user can play the video, and also easily compose the screen 
in connection with the GUI.  
  
8) Elementary  
Elementary is a widget toolkit library, providing widgets for general use such 
as buttons, lists, labels, and sliders. In addition, it provides the change of 
dynamic themes and the scalability of GUI to support 'Look & Feel' and various 
screen resolutions respectivel y. 
  
Page 10 / 978 9) Efreet, Eio, Eeze, Ethumb, and Eldbus  
Additional libraries include Efreet, Eio, Eeze, Ethumb, and Eldbus.  
Efreet is a library designed to make an application work in accordance with 
the standards of Freedesktop.org related to icons, desktop files, m enus, and 
so on.  
Eio is a library for asynchronous I/O. Ethumb provides functions to generate 
thumbnail images by adding the frame images.  
Eeze is used to manipulate hardware devices through udev. For instance, 
related to the status of devices, Eeze can be  used to determine the status of 
the devices including whether a CD -Rom has a disk inserted, the temperature 
of CPU, and the remaining power of the battery. Finally, Eldbus is a wrapper 
around the dbus library, which is a message bus system. It also implem ents a 
set of specifications of dbus to practice IPC.  
  
10) Language Bindings  
Basically, EFL supports C language, and is also involved in the language 
binding projects using Elev8 (JavaS cript), Python, Pearl, C++, and Vala.  
 (Reference: EFL Korea Community)  
  
  
Page 11 / 978 2. Establishing a Tizen Development Environment  
 
A. Download of Java Development Kit (JDK)  
Tizen uses Java to support all types of OS in development environments. For 
that reason, your device needs to have JDK installed. If JDK is not installed, 
you will see an error message during the installation of Tizen SDK, and the 
installation will fail to complete. Follow the steps below:  
  
1) Open a web browser, and go to 
http://www.oracle.com/technetwork/java/javase/downloads.  
 
  

  
Page 12 / 978 2) Press the Java DOWNLOAD (or JDK DOWNLOAD) button. When the screen 
is changed, check the checkbox of 'Accept License Agreement.'  
3) Download Java SE Development Kit xux. Simply select the OS version you 
are using from the list. If you use a 32 -bit OS, click Windows x86. If you use  
a 64-bit OS, click Windows x64.  
 
   

  
Page 13 / 978 B. Installation of Java Development Kit (JDK)  
1) Double -click the EXE file downloaded. Then, you will see the installation 
screen. Click the Next button.  
   
2) When the screen is displayed with items to be selected for installation, click 
the Next button with the default settings as is.  
3) Once JDK starts the installation, wait until the installation finishes. When 
you see the screen asking for the installation path of JRE, click the Next button. 
If you want to desig nate the installation path somewhere other than the 
default folder (e.g. C:/Program Files/Java/jre7/ ), change the path by clicking 
Change.  
   

  
Page 14 / 978 4) Once JRE starts the installation, wait until the installation finishes. When 
you see the screen indicating th at the installation has been completed, click 
the Close button.  
   
  
 
  

  
Page 15 / 978 C. Download of Tizen SDK  
This section will introduce you how to build Tizen development environments. 
First of all, you need to download the SDK installation file.  
Go to https://www.tizen.org/.  
 
  
Click the DOWNLOAD THE SDK button on the first screen. You will then move 
to the SDK download page.  
If you use a 32 -bit version of Windows, select and download Windows XP/7 
32bits from Install Manager. If you use a 64 -bit versio n of Windows, select and 
download Windows XP/7 64bits. Ubuntu 32 -/64-bit and Mac OS are also 
supported.  

  
Page 16 / 978  
Download the Install Manager file. Scroll down and download the same items 
for SDK image. Once you download Install Manager, the necessary files will 
be automatically downloaded from the Internet during installation. You may 
need to download image files in advance to prevent any errors from occurring 
during installation.  

  
Page 17 / 978  
 
D. Installation of Tizen SDK  
This section will inform you how to install Tizen S DK. The instructions are 
based on SDK version 2.4.0b. However, you can easily apply them to other 
versions. Furthermore, the simple installation of Tizen SDK enables novices to 
install it without even referring to the manual.  
When the download is completed , double -click the EXE file 
(tizen_sdk_2.x.xx_window -32.exe) to execute it. If you see a warning window, 
ignore it and click Yes.  

  
Page 18 / 978 When the installation screen appears, you need to designate an image file. 
Click the Advanced button on the right.  
 
  
Check t he checkbox next to SDK Image, and click the Open file button on the 
right. This will open a popup  window from where you can open files. Select 
the image file (tizen -sdk-image -TizenSDK_2.4.x_xxxx_xxxx_x_rel -windows -
32.zip) you downloaded from the Tizen dev eloper website. The Zip file will be 
decompressed. Wait until the decompression is completed.  
 

  
Page 19 / 978 When the decompression is completed, click the OK button to close the window. 
Click the Install button on the main screen, and move to the next page.  
When the S elect Install Type screen is displayed, check 2.4 Mobile and 2.4 
Wearable, and click the Next button.  
 
When the Software License Agreement screen is displayed, click the 'I agree' 
button.  
 
  

  
Page 20 / 978 In the Ready to install screen, designate the paths where SDK will be installed 
and where an SDK data folder will be located, respectively. The SDK default 
path is C: \tizen-sdk. If you want to change the path, click the address field 
and designate your desired folder.  
The default data folder path is C:\tizen-sdk-data. If you prefer a simple folder 
structure, you can edit the path to the inside of the SDK folder, like C: \tizen-
sdk\data. 
Click the Install button to start the installation.  
 
Once JRE starts installing, wait until the process finishes.  

  
Page 21 / 978  
During installation, you may see a popup  window informing you that you need to 
update the hardware acceleration driver. Click Yes and continue to install.  
 
 When the installation is completed, click the Close button.  
  

  
Page 22 / 978 3. Running a Tizen Development Environ ment 
 
A. Taking a Look at the Installed SDK  
This section will introduce you to the kind of data that will be included in the 
installed SDK. When you open an SDK folder, you will see the folder list as 
below. If you followed the default settings, the path o f your installation folder 
would be C:/tizen -sdk. 
 
Let's take a look at some important folders from the list. The ' \documents' 
folder includes the PDF manuals related to Tizen API and development.  
The '\platforms' folder includes various examples using v irtual device 
(emulator) and Tizen API.  
The examples of native apps are saved in the folder ' \platforms \tizen-
x.x\mobile \samples \Template \Native.'  

  
Page 23 / 978 The examples of web apps are saved in the folder '\tizen-
sdk\platforms \tizen-x.x\mobile \samples \Template \Web.' As the whole 
source project is included, you can check the results by directly loading, 
building, and executing them in an IDE. The following folder has the most 
useful resources to developers.  
The '\ide' folder includes development environment tools which developers 
can use to create Tizen applications. This folder has an IDE where you can 
create a new project, enter source code, create widgets on the screen in UI 
editor and designate their prop erties, and build the project and execute it with 
emulator and as target. App developers do not need to use the contents of 
this folder.  
The '\tools' folder includes tools that you can use to create a certification, 
and build and execute source projects at  Linux. 
  
F. Execution of IDE -Development Environment Tools  
Now, let's see how to run the tools in the actual development environments. 
First, we need to create a work folder before executing the IDE. In this example, 
a new folder is created in the C: driv e root folder, and named ‘tizen -work.' You 
can choose any paths and names for your folder.  
  
Page 24 / 978  
The next step is to execute Tizen IDE in the installed SDK. You can simply 
follow the path [All programs > Tizen SDK > Tizen IDE] from the Start menu 
of Windows.  
[ Tip! ] 
Tizen uses Eclipse as its IDE (development tool). It means that Tizen shares 
the same development tool with Java and Android.  
As the native apps of Tizen use C language, not Java, it is possible for 
developers to use Visual Studio. In this case, ho wever, developers may need 
to purchase the license of the program for individual use. To avoid such 
inconvenience, Eclipse is provided as a basic specification. Developers can 
create their applications for free using this program.  
If you are familiar with Visual Studio and other development environments, 
you will quickly become used to the environments of Eclipse.  
When you initially execute IDE, you will see the popup  window as shown below. 
This is the screen where you can designate a work folder in which to save 
source projects.  

  
Page 25 / 978  
Click the Browse button, and designate a folder which will be used as a work 
space. In this case, C: \tizen-work has been used as the work folder. If you 
have designated a folder, select the checkbox next to 'Use this as the default 
and do not ask again,' and click the OK button to go to the next step. It is 
recommended to check this message, otherwise you will see this window every 
time you execute IDE.  
When IDE is executed, you will see a screen as shown below. This is the screen 
introducing tips for use. Click the × symbol in the top right corner of the 
window to close it.  

  
Page 26 / 978  
When the screen is closed, you will a screen as shown below. If yo u have 
experience of developing with Java or Android, you may be familiar with this 
screen.  
 

  
Page 27 / 978 This section will introduce you briefly to each field. The main menu and tool 
bar are at the top. Shortcut keys and menus are available if you do not wish 
to use the tool bar.  
On the right side of the tool bar, you will see a square marked 'Tizen Web.' 
You can use this to convert between web apps and native apps, and between 
debug mode and execution mode. When you execute an application in debug 
mode, another butto n will be added. As a result, using two toggle -type 
buttons, you can move between debug and execution modes as you wish.  
Below the left side of the tool bar, you will see a field called 'Project Explorer.' 
This field shows you the list of all the projects saved in the work folder and 
fields in the sub files (e.g. Source and resource files). When you select a source 
file of UI screen information file in this field, the detailed information is 
displayed in the middle of the screen. You can also modify the pro perties of 
a project or execute it from the shortcut menu.  
The field ‘Connection Explorer’ displays a list of devices available to install 
developed apps. Emulator will be displayed when it is executed. When you 
connect a phone with a cable, the phone will  be added.  
Now, you will see several tabs at the bottom of the screen in the center. The 
most important of these are as follows. 'Problems' displays log messages, 
warnings, or error messages that occur while you are building a project. When 
any build error  occurs, you can correct it referring to the messages displayed 
here. 
'Log' displays log messages occurring while you are executing an application. 
You can check the status of progress while executing an application by 
applying API functions such as AppLog () or AppLogDebugTag() for the source 
code.  
  
Page 28 / 978 G. Running an Emulator  
In this section, you will learn how to create and run an emulator. Click 
[Windows Start button > All Programs > Tizen SDK > Emulator Manager]. If 
you see a warning window, ignore it and click the Yes button.  
 
If you initially run the Emulator Manager, you need to create an emulator. Click 
the '+' sign below 'Create New VM' on the left.  
 
Then, you will see a screen where you can designate the options of the 
emulator on the right. Designa te wvga as the name property. You can leave 
the rest as the default properties. Click the Confirm button to create a new 
emulator.  

  
Page 29 / 978  
Now, you will have a new emulator named wvga on the left side of the screen. 
Click the arrow button below the new emulator icon to run the emulator. If 
you want to change the options of the emulator, click the Reset button.  
 
When the 'Windows Security Warning' popup  window appears, click the 
Unblock button to continue the process. You may see a little square popup  
window on t he right side of the emulator. This window includes hardware keys. 
It has Menu, Home, Back, Power, Volume+, and Volume - from the top. It has 
mostly similar functions to the hardware keys supported by Android.  

  
Page 30 / 978  
When it is converted to sleep mode, simply cl ick the Home button to turn on 
the screen again. Then, drag the screen to unlock.  
 
  

  
Page 31 / 978 4. Executing Examples  
SDK provides you with guide manuals, but examples for actual practice may 
be more helpful. Such examples will be the resources you would refer to the 
most frequently while you are working on your future projects. You will be 
shown how to add the examples to an IDE and run them using an emulator. 
Let’s take a look at some important examples first.  
  
A. Adding a Sample to an IDE  
You are now ready to devel op Tizen applications. Let's practice the process 
using an example.  
Select [File > New > Other ...] from the main menu.  
 
When a new popup  window appears, you will see a list in tree structure. Open 
the Tizen folder, and select ‘Tizen Native Project’ from  among the items. Then, 
click the Next button.  

  
Page 32 / 978  
When the ‘Create a Tizen Native Application Project’ popup  window appears, 
click the 'Online Sample' button on the right side of the Template button. Now, 
you will see the list of examples for native apps. W hen you select [UI > UI 
Controls] from the list on the left, you will see the screen capture image on 
the right.  
At this stage, you need to name the project. This process imports one of the 
existing examples, so you can just give it the same name as the original 
example. Type 'UIControls' in the field 'Project name,' and click Finish.  

  
Page 33 / 978  
When you see a popup  window asking you if you want to open ‘Perspective,’ 
click Yes after checking the 'Remember my decision' checkbox.  
 
The popup  window will close, and the example will be added to 'Project 
Explorer.'   

  
Page 34 / 978 This process is not to import files from the ‘ /platforms ' folder of SDK, but to 
import the files you have copied to your work folder. When you open the 
work folder ( C:/tizen -work) that you designated, you c an see the ‘UIControls’ 
folder is copied.  
UIControls is an example that shows you all kinds of widgets supported by 
Tizen and how to use Container.  
When you click the '+' sign on the left side of Basic App which has been 
added to 'Project Explorer,' you wi ll see a list in tree structure and several 
folders. Now, let's see what kinds of files are in each folder.  
 
The ‘/src' folder includes source files (.c). The ‘ /inc' folder includes header files 
(.h). When a basic project is created, the main screen of it  is automatically 
generated.  
You can work in source files for the main screen when a new screen is added. 
However, it is recommended that you create new source files because it makes 
the management and reuse for other projects easier.  

  
Page 35 / 978 In the case of crea ting a library, it would be better for you to work with a new 
header file.  
The images for app icons are saved in the ‘ /shared/res ' folder. From your smart 
phone, you can run an application by touching a certain icon from the icon 
list. The app icon images are used in this case.  
Using the 'tizen -manifest.xml' file, you can designate various information 
related to an app, including application ID, the version of SDK, the image for 
the app icon, and Label text.  
  
B. Building a Sample  
To run a source project u sing the emulator, you need to build the EXE file first. 
The native app development of Tizen uses C language, so it is not built 
automatically like with Java or Android. Also, you need to choose in which 
mode you wish to build the source project.  
Build mo de has two types – debug and release modes. In debug mode, you 
can display desired information in the log window as log messages during 
execution. This mode can also perform debugging.  
In release mode, you can only run the program, but cannot check log 
messages. For that reason, you should use debug mode while developing an 
application, and use the package built in release mode when you finally 
register it at the seller website.  
  
  
Page 36 / 978 The default setting is debug mode. If you want to change to build mode, 
right-click the source project at ‘Project Explorer,’ and choose items you want 
from [Build Configurations > Set Active].  
 
At the left bottom of Eclipse, there is the 'Connection Explorer' window. You 
will see the emulator you have just created has been regis tered. If you connect 
a terminal using a USB cable, you will also see the additional device.  
To run the emulator, select the emulator from the 'Connection Explorer' 
window, and build your project. If you want to test at a terminal, you can 
select the termi nal and build your project.  
 
If you successfully designated build mode, you are ready to build your project. 
Select [Build Project] from the project shortcut menu to start building.  

  
Page 37 / 978  
You will see a new popup  window displaying the progress rate of the build. 
Wait until this window automatically disappears. If the popup  window 
disappears, and if no errors are displayed on the 'Problems' tab, this means 
that your project has been successfully built. If any error messages are 
displayed, correct the issues and build it again.  
 
Once the project is built, it is ready to be r un. Select [Run As > 1 Tizen Native 
Application] from the shortcut menu of the source project.  

  
Page 38 / 978  
  
C. Creating a Certificate  
At this stage, you may see a warning window indicating that Secure Profile 
does not exist. From Tizen SDK 2.1, you should create a certificate to install 
an app in an emulator or terminal by using the following procedure.  
 
Click the link at Preferences > Security Profiles from the popup  window. A new 
popup  window will then be displayed. Click the Add button on the right. When 
the ‘Pr ofile Name’ popup  window appears, enter the name of your profile, for 
example your name or the name of your company. Click the OK button to 
close the popup  window.  

  
Page 39 / 978  
A new item is then added to Profiles. Now, it is time to enter detailed 
information. Click  the Generate button on the right side of Author Certification.  
 
When the ‘Certificate Generator’ popup  window appears, enter the name of 
the file as the Key filename, the name of affiliated group as the Alias, and a 
password in the password and password confirmation fields. You can use the 
name of Profiles for Key filename and Alias. Now, you have entered all 
information required for use. Once you have finished entering the information, 
click the OK button to close the popup  window.  

  
Page 40 / 978  
A popup  window askin g if you wish to use this certificate will appear 
automatically whenever you open this project. Simply click the Yes button.  
 
Now, click the Apply and OK buttons in order, then the popup  window will 
disappear. When you click the OK button in the ‘Signing’  popup  window, the 
source project will be installed on the emulator. If you need to edit the 
certificate later, select [Windows > Preferences] from the main menu of Eclipse, 
and select [Tizen SDK > Security Profiles] from the list in the tree structure on 
the left when the 'Preferences' popup  window appears.  
  

  
Page 41 / 978 When the app is successfully installed on the emulator, UIControls will be run. 
This example comprehensively shows how to use widgets and containers 
supported by UIControls Tizen.  
 
  

  
Page 42 / 978 5. Creating a Basic UI example  
In this section, we will make a new source project using the BasicUI method, 
and output text 'Hello World.'  
  
1) Creating a Source Project  
The first step is to create a new source project. Select [File > New > Tizen 
Native Project] from the main  menu of Eclipse.  
 
When a popup  window for creating a source project appears, select [Template 
> MOBILE -2.x > Basic UI Application]. For all examples introduced here, you 
can follow this method.  
Enter 'HelloWorld' in the Project name field.  

  
Page 43 / 978  
The field Package name will be automatically filled. If you’re developing an 
app which will be registered with app stores, you can use the website address 
for the Package name. For instance, if your domain name is ‘www.abc.com,’ 
you can enter ‘com.abc.helloworld’ as  the Package name.  
Now, click the Finish button to create a new source project.  
  
  

  
Page 44 / 978 2) Components of Source Project  
Let’s see some basic compon ents of a source project. The ‘ inc' folder has 
libraries.  
This folder includes header files in C language (.h). Y ou can mostly use this 
folder to define libraries, function headers, or global variables.  
The ‘res’ folder is usually used to save resource files including image or audio 
files. 
The ‘src’ folder includes the source files in C language (.c). This folder is mainly 
used to define the features of functions. Most tasks are performed here.  
The ‘shared’ folder includes the app icon images. When you distribute your 
apps to app stores, you can save your app icons here. For Tizen store, you 
should use app icons with a round shape.  
The ‘tizen -manifest.xml’ file includes various app information (e.g. the name 
and version of app) and user’s rights (privilege). It is basically the same as 
AndroidManifest.xml in Android.  
 

  
Page 45 / 978 3) Running a Basic Source Project  
In order to run the source project, first right -click the HelloWorld project. Then, 
select [Build Project] from the shortcut menu. When the project is successfully 
built, right -click the project again, and select [Run As > 1 Tizen Native 
Application] from the shortcut men u. 
When the example runs on the emulator, you will see the indicator at the top, 
and the app screen below the indicator. Then, you will see the text, 'Hello EFL.' 
This text is displayed using Label Widget.  
 
  
  

  
Page 46 / 978 4) Basic Source Code  
Now, let’s change the text, Hello EFL, displayed in Label Widget. To do this, 
we need to e dit the source file. Open the ‘ src’ folder, and double -click the 
'helloworld.c' file. You will now see the content of the file as shown below on 
the main screen of Eclipse.  
┌────────────── ───────┐  
#include "helloworld.h"  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
static void  
win_delete_request_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    ui_app_exit();  
} 
  
static void  
win_back_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    /* Let window go to hide state. */  
    elm_win_lower(ad ->win);  
} 
└─────────────────────┘  
  
  
Page 47 / 978 The command #include “helloworld.h” refers to ‘helloworld.h’ i n the ‘inc' folder. 
In general, header files are declared with library include, global variables, and 
function headers, while source files are defined with the content of the 
function.  
‘appdata_s’ is a structure to save data used in an app.  
‘win_delete_request_cb()’ is an event function which is run when the request 
for app removal occurs. This function is not directly called.  
‘win_back_cb()’ is an even function which is run when the Back button is clicked. 
This function is not directly calle d. 
A little further down, you will see another function, 'create_base_gui().' This 
function creates windows consisting of a screen, various containers, and a 
widget.  
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    /* Window */  
    ad->win = elm_win_util_standard_add(PACKAGE, PACKAGE);  
    elm_win_autodel_set(ad ->win, EINA_TRUE);  
  
    if (elm_win_wm_rotation_supported_get(ad ->win)) {  
        int rots[4] = { 0, 90, 180, 270 };  
        elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 4);  
    } 
  
    evas_object_smart_callback_add(ad ->win, "delete,request", win_delete_request_cb, NULL);  
    eext_object_event_callback_add(ad ->win, EEXT_CALLBACK_BACK, win_back_cb, ad);  
  
Page 48 / 978   
    /* Conformant */  
    ad->conform = el m_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
  
    /* Label*/  
    ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    elm_object_content_set(ad ->conform, ad ->label);  
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
The following are explanations of some lines of the ma jor code.  
elm_win_util_standard_add() is an API that creates the Window object. The 
window is the topmost object in the screen layout. An app has a single window. 
You can place a widget in a window. However, the more common method is 
to add a container and  then add a widget on top of the container.  
elm_win_wm_rotation_available_rotations_set() is an API that specifies the 
orientation of the screen. If you pass the four angles, 0, 90, 180, and 270, as 
an array, all screen orientations are supported.   
  
Page 49 / 978 evas_ob ject_smart_callback_add() is an API that specifies an event callback 
function for a smart object such as a widget or container. For the first 
parameter, pass the object where the event occurs; for the second parameter, 
the type of the event; for the third parameter, the name of the callback 
function; and for the fourth parameter, user data. If the type of the event is 
"delete,request", it means that the object shall be deleted.  
eext_object_event_callback_add() is an API that specifies an event callback 
function for an object. You can use this API for both smart objects and general 
objects. For the first parameter, pass the object where the event occurs; for 
the second parameter, the type of the event; for the third parameter, the name 
of the callback functio n; and for the fourth parameter, user data. 
EEXT_CALLBACK_BACK indicates a Back button click event.  
elm_conformant_add() is an API that creates a Conformant. A Conformant 
changes the size of the window when a new element (for example, a keypad) 
is added to  the screen. An app must have no more than a single Conformant. 
It is also possible for an app to not have a Conformant.  
A Conformant is necessary to display an indicator (status bar) at the top of 
the screen. It is also possible not to display an indicato r when a Conformant 
exists. 
elm_win_indicator_mode_set() is an API that specifies whether to display an 
indicator.  
elm_win_indicator_opacity_set() is an API that specifies the opacity of the 
indicator.  
  
  
Page 50 / 978 evas_object_size_hint_weight_set() is an API that specifies the rough size of an 
object. The following are the parameters listed in order: the object, horizontal 
size hint, and vertical size hint. EVAS_HINT_EXPAND means specifying as large 
a size as the space allows.  
elm_win_resize_object_add() is an API that resizes the Window object while 
adding a different object to it.  
evas_object_show() is an API that displays an object. When an object is created, 
the default value of the object is Hide. You can use this function for all objects 
without exception.  
elm_label_add() is an API that creates a Label widget. A Label widget lets you 
display text as well as change text properties such as the font size and color 
by using HTML tags.  
  
  
  
Page 51 / 978 5) Changing the Text in a Label  
Now, we are going to change the text 'Hello EFL' displayed on the screen. 
Change the function ‘elm_object_text_set()’ as shown below.  
┌─────────────────────┐  
    ad->label = elm_label_add(ad ->conform);  
    //elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    elm_object_text_set( ad->label, "Hello World");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
└─────────────────────┘  
elm_object_text_set() is an API that changes the caption text of a widget. You 
can use this function for Button and Entr y widgets as well as Label widgets. 
You can also specify text properties by using HTML tags when creating text.  
Let's run the example again. When you run an example for the second time, 
click [Run > Run] in the main menu or press the 'Ctrl + F11' hotkey.  
The example runs again, and the text on the screen changes to 'Hello World.'  
 
  
  

  
Page 52 / 978 6) Changing the Position of a Label Using Absolute Coordinates  
Labels are placed on the left side of the screen. The 
evas_object_size_hint_weight_set() function specifies th e relative size of an 
object because the function's both horizontal and vertical options are 
specified as 'EVAS_HINT_EXPAND.' For the first parameter, enter the object 
whose properties you want to specify; for the second parameter, enter a 
horizontal size hint; and for the third parameter, a vertical size hint.  
Now, let's change the position of the Label by specifying its absolute 
coordinates. Change the code as shown below.  
 ┌─────────────────────┐  
    elm_object_text_set(ad ->label, "Hello World");  
    //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPA
ND); 
    //elm_object_content_set(ad ->conform, ad ->label);  
    evas_object_move(ad ->label, 100, 200);  
    evas_object_resize(ad ->label, 400, 100);  
    evas_object_show(ad ->label);  
└─────────────────────┘  
evas_object_move() is a function that specifies the size of an object as an 
absolute value. Enter parameter values in the following order: the object whose 
properties you want to specify, the position of the X coordinate, and the 
position of the Y coordinate.  
evas_object_resize() is a function that specifies the position of an object as an 
absolute value. Enter parameter values in the following order: the object whose 
properties you want to specify, the X coordinate (width), and the Y coordinate 
(height).  
  
Page 53 / 978 Run the app again, and you can see the position of the Label has changed.  
 
 
7) Enabling Various Resolutions Using a Box Container  
Specifying absolute coordinates as shown above is convenient. However, you 
cannot use the various resolutions of your terminal that way. We are now 
going to learn how to enable various resolutions by using a Box container.  
Add a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Eva s_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there i s "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_o bject_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  

  
Page 54 / 978         evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actuall y put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
my_box_pack() is a function that adds a widget into a Box container. A Box is 
a container that successively adds widgets or containers in the horizontal or 
vertical orientation. It performs a similar role as Android's LinearLayout. This 
function will be used a lot in other examples later on. A detailed explanation 
of the Box container will be given in a Box example.  
For the first parameter of the my_box_pack() function, enter the handle of the 
Box container . For the second parameter, enter the widget or container to be 
added to the Box container.  
For the third parameter, enter a hint for the horizontal size of the widget. 
Entering EVAS_HINT_EXPAND or 1.0 specifies the horizontal size of the widget 
as large a s possible; entering 0.0 specifies the size as small as possible. In the 
case of Bg widgets, the default size is 0. Therefore, if you specify 0.0, the 
widget will not appear on the screen.  
  
  
Page 55 / 978 For the fourth parameter, enter a hint for the vertical size of t he widget.  
For the fifth parameter, enter a horizontal position for the widget. Entering 0.0 
left-aligns the widget; entering 0.5 center -aligns the widget; entering 1.0 right -
aligns the widget; and entering EVAS_HINT_FILL or -1 lets the widget occupy 
the whole horizontal area.  
For the 6th parameter, enter a vertical position for the widget. Entering 0.0 
top-aligns the widget; entering 0.5 middle -aligns the widget; entering 1.0 
bottom -aligns the widget; and entering EVAS_HINT_FILL or -1 lets the widget 
occup y the whole vertical area.  
Modify the source code at the bottom of the create_base_gui() function as 
shown below.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_IN DICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->confor m); 
 
    { 
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        elm_object_content_set( ad->conform, box);  
        evas_object_show(box);  
 
        { 
  
Page 56 / 978             /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Hello World");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
The symbol { } was used to clarify the inclusion relationship between the upper 
Window and the bottom Window. It is not necessary to use the symbol. 
However, because there is a huge difference in readability between when you 
use it and when you do not, we recommend you make a habit of using it.  
elm_box_add() is an API that creates a Box container.   
  
Page 57 / 978 Let's run the example again. Little differ ence has been made. The widget, 
however, is now displayed in the same position on the screens of terminals 
with different resolutions.  
 
 
8) Inefficient Code Modifications  
By removing unnecessary parts from the source code that are added by 
default when you have created a source project, you can enhance performance. 
Let’s modify the source code using the method recommended by Carsten 
Haitzler, the developer of EFL.  
Go to the top of the source file, delete the win_delete_request_cb() function, 
and modify t he win_back_cb() function as shown below.  
  

  
Page 58 / 978 ┌─────────────────────┐  
/*static void  
win_delete_request_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
 ui_app_exit();  
}*/ 
 
static void  
win_back_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
 appdat a_s *ad = data;  
 /* Let window go to hide state. */  
 //elm_win_lower(ad ->win);  
 elm_win_iconified_set(ad ->win, EINA_TRUE);  
} 
└─────────────────────┘  
win_delete_request_cb() is the callback function used at the below code of the 
create_base_gui() function. This is an event used on PCs and therefore means 
little on mobile devices.  
Evas_object_smart_callback_add(ad ->win, "delete,request", 
win_delete_request_cb, NULL);  
Go to the create_base_gui() function and modify the beginning of the function 
as shown below.  
  
  
Page 59 / 978 ┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    /* set up policy to exit when last window is closed */  
    elm_policy_set(ELM_POLICY_QUIT, ELM_POLICY_QUIT_LAST_WINDOW_CLOSED);  
 
    /* Window */  
    ad->win = elm_win_util_standard_add(PACKAGE, PACKAGE);  
    elm_win_autodel_set(ad ->win, EINA_TRUE);  
 
    int rots[4] = { 0, 90, 180, 270 };  
    elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 4);  
 
    eext_object_event_callback_add(a d->win, EEXT_CALLBACK_BACK, win_back_cb, ad);  
 
    /* child object - indent to how relationship */  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_op acity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
└─────────────────────┘  
Using the e lm_policy_set() function, we made the app close when the last 
window closes.  
In the case of mobiles devices, the elm_win_wm_rotation_supported_get() 
function is supported regardless of the model. Therefore, it does not require 
  
Page 60 / 978 consideration and has been re moved.  
Lastly, let's remove unnecessary event callback functions. Go to the bottom of 
the source file and delete the following four callback functions:  
- ui_app_orient_changed()  
- ui_app_region_changed()  
- ui_app_low_battery()  
- ui_app_low_memory()  
Then, from the main() function at the bottommost of the source file, delete 
the part that specifies the functions above as callback functions.  
┌─────────────────────┐  
int 
main(int argc, char *argv[])  
{ 
    appdata_s ad = {0,};  
    int ret = 0;  
 
    ui_app_lifecy cle_callback_s event_callback = {0,};  
    app_event_handler_h handlers[5] = {NULL, };  
 
    event_callback.create = app_create;  
    event_callback.terminate = app_terminate;  
    event_callback.pause = app_pause;  
    event_callback.resume = app_resume;  
    event_callback.app_control = app_control;  
 
    //ui_app_add_event_handler(&handlers[APP_EVENT_LOW_BATTERY], 
APP_EVENT_LOW_BATTERY, ui_app_low_battery, &ad);  
    //ui_app_add_event_handler(&handlers[APP_EVENT_LOW_MEMORY], 
APP_EVENT_LOW_MEMORY, ui_app_low_mem ory, &ad);  
    //ui_app_add_event_handler(&handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED],  
  
  
Page 61 / 978 APP_EVENT_DEVICE_ORIENTATION_CHANGED, ui_app_orient_changed, &ad);  
    ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_L
ANGUAGE_CHANGED,  ui_app_lang_changed, &ad);  
    //ui_app_add_event_handler(&handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_
EVENT_REGION_FORMAT_CHANGED, ui_app_region_changed, &ad);  
    //ui_app_remove_event_handler(handlers[APP_EVENT_LOW_MEMORY]);  
 
    ret = ui_app_main(argc, argv, &event_callback, &ad);  
    if (ret != APP_ERROR_NONE) {  
        dlog_print(DLOG_ERROR, LOG_TAG, "app_main() is failed. err = %d", ret);  
    } 
 
    return ret;  
} 
└─────────────────────┘  
  
  
Page 62 / 978 9) Related APIs  
appdata_s: a structure that saves app information.  
void create_base_gui(appdata_s *ad): a function that creates a window and 
various containers and widgets that compose the screen.  
void win_delete_request_cb(): an event function that is executed when a 
request for dele ting the app occurs. This function is not directly called.  
void win_back_cb(): an even function that is executed when the Back button 
is clicked. This function is not directly called.  
Evas_Object *elm_win_util_standard_add(char *name, char *title): a funct ion 
that creates a Window object. The window is the topmost object in the screen 
layout. An app has a single window. You can place a widget in a window. 
However, the more common method is to add a container and then add a 
widget on top of the container.  
void elm_win_wm_rotation_available_rotations_set(Elm_Win *obj, const int 
*rotations, unsigned int count): an API that specifies the orientation of the 
screen. If you pass the four angles, 0, 90, 180, and 270, as an array, all screen 
orientations are supporte d. 
void evas_object_smart_callback_add(Evas_Object *obj, const char *event, 
Evas_Smart_Cb func, const void *data): an API that specifies an event callback 
function for a smart object such as a widget or container. For the first 
parameter, pass the object w here the event occurs; for the second parameter, 
the type of the event; for the third parameter, the name of the callback 
function; and for the fourth parameter, user data. If the type of the event is 
  
Page 63 / 978 "delete,request", it means that the object shall be del eted. 
void eext_object_event_callback_add(Evas_Object *obj, Eext_Callback_Type 
type, Eext_Event_Cb func, void *data): an API that specifies an event callback 
function for an object. You can use this API for both smart objects and general 
objects. For the f irst parameter, pass the object where the event occurs; for 
the second parameter, the type of the event; for the third parameter, the name 
of the callback function; and for the fourth parameter, user data. 
EEXT_CALLBACK_BACK indicates a Back button click e vent. 
Evas_Object *elm_conformant_add(Evas_Object *parent): a function that 
creates a Conformant container. A Conformant changes the size of the window 
when a new element such as a keypad is added to the screen. An app must 
have no more than a single Confo rmant. It is also possible for an app to not 
have a Conformant. A Conformant is necessary to display an indicator (status 
bar) at the top of the screen. It is also possible not to display an indicator 
when a Conformant exists.  
void elm_win_indicator_mode_s et(Elm_Win *obj, Elm_Win_Indicator_Mode 
mode): an API that specifies whether to display an indicator.  
void elm_win_indicator_opacity_set(Elm_Win *obj, 
Elm_Win_Indicator_Opacity_Mode mode): an API that specifies the opacity of 
the indicator.  
void evas_objec t_size_hint_weight_set(Evas_Object *obj, double x, double y): an 
API that specifies the rough size of an object. The following are the parameters 
listed in order: the object, horizontal size hint, and vertical size hint. 
EVAS_HINT_EXPAND means specifying a s large a size as the space allows.  
  
Page 64 / 978 void elm_win_resize_object_add(Elm_Win *obj, Evas_Object *subobj): an API 
that resizes the window object while adding a different object to it.  
Evas_Object *elm_label_add(Evas_Object *parent): a function that creates a 
Label widget. A Label widget lets you display text as well as change text 
properties such as the font size and color by using HTML tags.  
void evas_object_show(Evas_Object *obj): a function that displays the object 
on the screen. When an object is created, the default value of the object is 
Hide. You can use the evas_object_show() function commonly for all objects.  
void elm_object_text_set(Evas_Object *obj, const char *text): a function that 
changes the caption text of a widget. You can use this function for  Button and 
Entry widgets as well as Label widgets.  
void evas_object_move(Evas_Object *obj, Evas_Coord x, Evas_Coord y): an API 
that specifies the size of an object as absolute values. / parameters: the object 
whose properties you want to specify, the posi tion of the X coordinate, and 
the position of the Y coordinate.  
void evas_object_resize(Evas_Object *obj, Evas_Coord w, Evas_Coord h): an API 
that specifies the position of an object as absolute values. / parameters: the 
object whose properties you want to  specify, width, the Y coordinate (height).  
  
  
Page 65 / 978 6. Using a Label Widget  
You need to use a label widget to display text on the screen. A Label 
widget lets you change text properties such as the font size and color by 
using HTML tags.  
  
1) Center -Aligning Label T ext 
Create a new source project and specify the project name as 'LabelEx.' To 
do so, select [File > New > Tizen Native Project] in the main menu of 
Eclipse and, when a popup  window appears, select [Template > MOBILE -
2.4 > Basic UI Application].  
After a sou rce project is created, open the labelex.c file in the src folder, 
go to the create_base_gui() function, and modify the Label widget -
creating code as shown below.  
┌─────────────────────┐  
 /* Conformant */  
 ad->conform = elm_conformant_add(ad ->win);  
 elm_w in_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
 elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
 evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
 elm_win_resize_object_add(ad ->win, ad ->conform);  
 evas_object_show(ad ->conform);  
 
 /* Label -1 */ 
 ad->label = elm_label_add(ad ->conform);  
  
Page 66 / 978  elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
 //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_H
INT_EXPAND);  
 //elm_object_content_set(ad ->conform, ad ->label);  
 evas_object_move(ad ->label, 120, 80);  
 evas_object_resize(ad ->label, 240, 80);  
 evas_object_show(ad ->label);  
└─────────────────────┘  
elm_object_text_set() is an API that specifies the caption text of a wid get. 
Enter the HTML tag corresponding to your desired properties for the 
second parameter to apply the properties to the text. <align=center> 
center -aligns the text.  
evas_object_move() is an API that specifies the top -left starting position 
of a widget. Fo r the second parameter, enter the desired X coordinate. 
For the third parameter, enter the desired Y coordinate.  
evas_object_resize() is an API that specifies the size of a widget. For the 
second parameter, enter the desired width. For the third parameter,  enter 
the desired height.  
Build and run the source project, and you will now see the text 'Hello 
EFL' displayed on the screen. The text is center -aligned in the horizontal 
orientation.  
 
 
  

  
Page 67 / 978 2) Changing the Font Size  
We are now going to change the font size of the caption text of a Label 
widget. Add a new code at the end of the create_base_gui() function. 
This is a code that creates the second Label widget.  
┌─────────────────────┐  
    /* Label -1 */ 
    ad->label = elm_label_add(ad ->conform);  
    elm_obj ect_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXP
AND);  
    //elm_object_content_set(ad ->conform, ad ->label);  
    evas_object_move(ad ->label, 120, 80);  
    evas_obje ct_resize(ad ->label, 240, 80);  
    evas_object_show(ad ->label);  
 
    /* Label -2 */ 
    Evas_Object *label = elm_label_add(ad ->conform);  
    elm_object_text_set(label, _("<font_size=20><align=center>fontsize is set to 
20</align></font_size>"));  
    evas_object_move(label, 120, 160);  
    evas_object_resize(label, 240, 80);  
    evas_object_show(label);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Evas_Object is a common variable for objects plac ed on the screen such 
as widgets and containers. Therefore, it does not matter if you declare a 
Conformant and a Label as the same variable type.   
  
Page 68 / 978 elm_object_text_set() is a function that changes the caption text of a 
widget. You can use this function for Button and Entry widgets as well as 
Label widgets. Inserting HTML tags into this function displays the text in 
the same way as when seen in your web browser.  
<font_size=20> is a tag that specifies the font size as 20 pixels.  
<align=center> is a tag that sp ecifies the position of the horizontal 
alignment as the center.  
Run the example again, and you will now see the second Label widget 
added and the text 'fontsize is set to 20' displayed. The text is displayed 
smaller in size than the text in the first Label . Center alignment has been 
applied for the horizontal alignment of the text.  
 
  
3) Changing the Font Color  
We are now going to change the font color in a Label widget. As with 
the font size, use HTML tags to change the font color. Add a new code 
at the e nd of the create_base_gui() function.  
┌─────────────────────┐  
    evas_object_show(label);  
 
    /* Label -3 */ 
    label = elm_label_add(ad ->conform);  
    elm_object_text_set(label, _("<color=#FF4500FF><align=right>font color oran

  
Page 69 / 978 ge red</align></color>"));  
    evas_object_move(label, 50, 240);  
    evas_object_resize(label, 380, 80);  
    evas_object_show(label);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
<color=#FF4500FF> inserted in the elm_object_text_set() function is a 
tag that specifies a color. The AARRGGBB format has been employed. 
The opacity is the maximum value, which equals opaque; the color blue 
is 45; the color green is 0; and the color red is the maximum value. 
Entering <colo r=#F40F> produces the same result.  
Run the example again, and you will now see the third Label widget 
added and orange -colored text displayed.  
 
  
4) Ellipses  
We are now going to learn how to display ellipses when a given text is 
too long and goes beyond the right end of the Label. Add a new code 
at the end of the create_base_gui() function.  
  

  
Page 70 / 978 ┌─────────────────────┐  
    evas_object_show(label);  
 
    /* Label -4 */ 
    label = elm_label_add(ad ->conform);  
    elm_object_text_set(label, _("<font_size=24>If t he string length exceeds the 
width</font_size>"));  
    evas_object_move(label, 72, 320);  
    evas_object_resize(label, 560, 80);  
    elm_label_ellipsis_set(label, EINA_TRUE);  
    evas_object_show(label);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_label_ellipsis_set() is an API that applies ellipses to a Label widget. 
For the first parameter, pass the Label widget whose properties you want 
to specify, and for the second parameter, pass true or f alse. EINA_TRUE is 
a Boolean value used in Tizen that indicates ‘true.’ To specify ‘false,’ enter 
EINA_FALSE.  
Run the example again, and you will now see the fourth text displayed 
as well as ellipses displayed at the right end.  
 
   

  
Page 71 / 978 5) Multi -Line Text  
To display multiple lines of text in a Label widget, use the <br/> tag. 
Add a new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    evas_object_show(label);  
 
    /* Label -5 */ 
    label = elm_label_add(ad ->conform);  
    elm_label _line_wrap_set(label, EINA_TRUE);  
    elm_object_text_set(label, _("<font_size=20><align=left>Once upon a time th
ere lived a young prince.<br>Mountan is mountain, water is water. </align></f
ont_size>"));  
    evas_object_move(label, 120, 400);  
    evas_object_resize(label, 240, 160);  
    evas_object_show(label);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_label_line_wrap_set() is an API that sets automatic line wrapping for 
a Label widge t. Passing EINA_TRUE to the second parameter applies 
automatic line wrapping.  
We created the fifth Label widget and entered long text. We broke the 
text into two lines using the <br/> tag.  
  
  
Page 72 / 978 Run the example again, and you will now see the fifth text displa yed and 
the lines broken where the <br/> tags are placed.  
 
  
6) Related APIs  
Evas_Object: a common variable for objects placed on the screen such as 
widgets and containers. Therefore, it does not matter if you declare 
different objects such as a Conformant and a Label as the same variable 
type. 
void elm_object_text_set(Evas_Object *obj, char *text): an API that 
changes the caption text. You can use this function for Button and Entry 
widgets as well as Label widgets. Inserting HTML tags into this f unction 
displays the text in the same way as when seen in your web browser.  
EINA_TRUE: a Boolean value used in Tizen that indicates 'true.'  
EINA_FALSE: a Boolean value used in Tizen that indicates 'false.'  
void elm_label_ellipsis_set(Evas_Object *obj, Eina _Bool ellipsis): an API 
that displays ellipses when the caption text of a Label widget goes 
beyond the right end. Entering EINA_TRUE for the second parameter 
displays ellipses, and entering EINA_FALSE cancels the display of ellipses.   

  
Page 73 / 978 7. Using a Button Widget  
Button widgets receive the user’s input and are used most often among 
the widgets. Button widgets can call a touch event and apply a 
background image using EDJE.  
  
1) Changing the Text in a Label Widget  
Create a new source project and specify the project name as 'ButtonEx.'  
After a source project is created, open the buttonex.c file in the src 
folder and add a new function on top of create_base_gui() function. The 
function you add is the same as the one used in the HelloWorld 
example.  
┌──────────────────── ─┐ 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
    /* create a frame we shall use as padding around the child widget */  
    Evas_Object *frame = elm_frame_add (box); 
    /* use the medium padding style. there is "pad_small", "pad_medium",  
     * "pad_large" and "pad_huge" available as styles in addition to the  
     * "default" frame style */  
    elm_object_style_set(frame, "pad_medium");  
    /* set the input wei ght/aling on the frame insted of the child */  
    evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
    evas_object_size_hint_align_set(frame, h_align, v_align);  
    { 
  
Page 74 / 978         /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_objec t_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
    } 
    /* put the frame into the box instead of th e child directly */  
    elm_box_pack_end(box, frame);  
    /* show the frame */  
    evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and modify the code that 
creates a Label widget.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT _EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
  
Page 75 / 978         evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Press a Button</>");  
            //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EV
AS_HINT_EXPAND);  
            //elm_object_content_set(ad ->conform, ad ->label);  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
The following are the parameters of the my_box_pack() function listed in 
order:  
- Box container  
- Child window  
- Horizontal size hint: 1.0 = maximum. 0.0 = minimum.  
- Vertical size hint: 1.0 = maximum. 0.0 = minimum.  
- Horizontal position: 0.0 = left. 0.5 = center. 1.0 = right. -1 = full.  
- Vertical position: 0.0 = top. 0.5 = middle. 1.0 = bottom. -1 = full.  
Run the example. You will now see the text 'Press Button' displayed on 
the screen.  
  
Page 76 / 978  
  
2) Creating a Button Widget  
We are now going to add a Button widget -creating code at the end of 
the create_base_gui() function.  
 ┌─────────────────────┐  
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Press a Button</>");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text _set(btn, "Default style");  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  

  
Page 77 / 978 elm_button_add() is an API that creates a Button widget.  
Specify the caption text as 'Default style' using the elm_object_text_set() 
function.  
The other functions have already been covered in previous examples.  
Build and run the source project, and you will see a Button widget 
added and the text 'Default style' displayed. Clicking the button does not 
produce any change. This is because we  have not yet defined an event 
function.  
 
 
3) Defining a Button Event Function  
The Enlightenment Foundation Libraries (EFL) used in Tizen define event 
functions in the callback style. You may be familiar with this method if 
you have experience in web prog ramming. Let’s define a Button event 
function now. Add a function called 'btn_default_cb().'  

  
Page 78 / 978 One thing to note is that because this function is called by the 
create_base_gui(), btn_default_cb() must be placed before 
create_base_gui(). Declaring function h eaders in a header file lets 
functions call each other regardless of the order.  
┌─────────────────────┐  
static void  
btn_default_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s* ad = data;  
    elm_object_text_set(obj, "Button Pressed");  
    elm_object_text_set(ad ->label, "Button -1 Pressed");  
} 
  
static void  
create_base_gui(appdata_s *ad)  
{ 
└─────────────────────┘  
The btn_default_cb() function receives three parameters. The first 
parameter is user data sent by the calling side. In this case, we will use 
app data (appdata_s). The second parameter is the object where an 
event has occurred. In this case, the object is the first Button. The third 
parameter is the structure that contains event information.  
elm_object_text_set() is an API that  changes the caption text of a widget.  
elm_object_text_set() is an API that changes the caption text of a widget.  
Now, we need to go to the Button -creating code and specify the 
function above as a callback function. Go to the create_base_gui() 
function and  add a line of code.   
  
Page 79 / 978 ┌─────────────────────┐  
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Default style");  
            evas_object_smart_callback_add(btn, "clicked", btn_defa ult_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
└─────────────────────┘  
evas_object_smart_callback_add() is a function that specifies an event 
callback function for a smart object such as a widget or container. Evas 
objects are all ob jects displayed on the screen. Smart objects are 
supplementary objects other than basic objects (Line, Rect, Polygon, Text, 
Image) provided by Evas. For the first parameter, enter the object where 
an event occurs. For the second parameter, enter the type o f the event. 
‘clicked’ indicates a click event. For the third parameter, enter the name 
of the callback function. For the fourth parameter, enter the type of data 
that will be sent to the callback function. In this case, it is app data.  
Run the example aga in and click the Button.  The texts in the Label and 
Button will be changed.  
 

  
Page 80 / 978 3) Applying an Icon to a Button: Reorder  
Several icon images can be displayed in a Button. We are going to learn 
how to apply each icon image.  
Add a new code at the end of the create_base_gui() function. This is a 
code that creates the second Button.  
┌─────────────────────┐  
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Default style");  
            evas_object_smart_callback_add(btn, "clicked", btn_default_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_style_set(btn, "icon_ reorder");  
            evas_object_smart_callback_add(btn, "clicked", btn_icon_reorder_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
elm_object_style_set() is a function that specifies the style of a widget. 
For the first parameter, enter the widget to which a style will be applied. 
For the second parameter, enter the type of the style. ‘icon_reorder’ 
displays a reorder icon.  
We specified the callback function btn_icon_reorder_cb for 
evas_object_smart_ callback_add(). This function has not been 
implemented yet. As shown below, add a new function on top of the 
create_base_gui() function.  
  
Page 81 / 978 ┌─────────────────────┐  
static void  
btn_icon_reorder_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s * ad = data;  
    elm_object_text_set(ad ->label, "Button -2 Pressed");  
} 
 └─────────────────────┘  
We defined a callback function for the second Button, and we also 
added a text -changing code to the Label widget.  
Run the example again, and you will now see th at a second Button with 
an icon image has been added. Click the second Button.  The text in the 
Label and the second Button will be changed.  
 
 
  

  
Page 82 / 978 4) Applying an Icon to a Button: + and - 
We are now going to create a Button to which a plus icon and a minus 
icon have been applied. Add a new code at the end of the 
create_base_gui() function. This is a code that creates the third Button.  
┌─────────────────────┐  
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_styl e_set(btn, "icon_reorder");  
            evas_object_smart_callback_add(btn, "clicked", btn_icon_reorder_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_style_set(btn, "icon_expand_add");  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
Enter ‘icon_expand_add’ for the second parameter of the 
elm_object_style_set() function, and a plus icon image will th en be 
displayed.  
The way to specify a callback function is following the same procedure 
as before and therefore has been omitted here.  
Run the example again, and you will now see that the third Button with 
a plus icon image has been added.  
  
Page 83 / 978  
 
5) Applying a Background Image to a Button  
To apply a background image to a Button widget, you need to use a 
theme. EFL uses a theme called EDJE. It is a hassle to create a theme file 
from scratch, so we are going to import a theme file from the appendix.  
Create a ne w folder under the /res folder of the source project and 
specify the folder's name as 'edje.' To do so, right -click the /res folder 
and select [New > Folder] in the shortcut menu. When a popup  window 
appears, enter 'edje' in the folder name field and click  the Finish button.  
Go to the appendix’s /etc/edje folder and copy the custom_button.edc 
file to the newly created /res/edje folder.  
You can create a new folder by right -clicking the /res folder and 
selecting [New > Folder] in the shortcut menu. To copy a file to your 
desired folder, drag and drop the file to the folder using the mouse.  

  
Page 84 / 978  
To apply a background image to a Button, you need an image file. We 
are now going to copy an image file that will be used as a background 
image. Create a new folder under the root folder of the source project 
and specify the folder’s name as ‘edje.’ Then, create a new folder under 
the /edje folder and specify the folder’s name as ‘images.’  
Go to the appendix's /image folder and copy the two files, green.png 
and red.png, to the newly created /edje/images folder.  
 
Now, we must add source code. Add a new code at the end of the 
create_base_gui() function. This code registers the EDJE file as a theme 
and creates the fourth Button widget.  
  

  
Page 85 / 978 ┌─────────────────────┐  
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_style_set(btn, "icon_expand_add");  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Theme */  
            char edj_path[PATH_MAX] = "";  
            app_get_resource("edje/custom_button.edj", edj_path, (int)PATH_MAX);  
            elm_theme_extension_add(NULL, edj_path);  
 
            /* Button -4 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_style_set(btn, "customized") ; 
            elm_object_text_set(btn, "Custom style");  
            evas_object_smart_callback_add(btn, "clicked", btn_custom_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
app_get_resource() is a functi on that finds the absolute path of the /res 
folder, adds a subfolder path, and then returns the path. For the first 
parameter, enter the subfolder path. In this case, 
'edje/custom_button.edj' has been sent, and therefore, the full path is 
~/res/edje/custom _button.edj. This function has not been created yet. 
We will create this function shortly.  
elm_theme_extension_add() is a function that registers a theme 
information file. Pass the path of the EDJE file to the second parameter 
of this function.  
  
  
Page 86 / 978 elm_objec t_style_set() is a function that applies a custom theme to a 
Button widget. We specified the name of the custom theme as 
‘customized.’ This theme is defined in the custom_button.edc file.  
Add two new functions on top of the create_base_gui() function. The first 
function is a callback event function for the fifth Button, and the second 
function is a function that returns the absolute path of the /res folder.  
┌─────────────────────┐  
static void  
btn_custom_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s* ad = data;  
    elm_object_text_set(obj, "Button Pressed");  
    elm_object_text_set(ad ->label, "Button -5 Pressed");  
} 
  
static void  
app_get_resource(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_ resource_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
└─────────────────────┘  
The second function ‘app_get_resource()’ has called 
app_get_resource_path(). This func tion finds the absolute path of the /res 
folder and returns the path.   
  
Page 87 / 978 Run the example again, and you will now see the fifth Button widget 
with a green image applied has been added. Clicking the Button 
changes it to a red image. Canceling the click changes  the image back 
to green and changes the caption text.  
   
There are so many elements to explain regarding the EDJE file, so for 
now we are going to address only the most essential. Open the EDJE file 
in the editor. Right -click the /res/edje/custom_button .edc file and select 
[Open With > Text Editor] in the shortcut menu.  
 
You can see the define statement at the top of the file. Within the 
statement, ICON_NORMAL indicates the file name of the background 
image in normal status. If you need to change the fi le name of the 
background image to 'btn_n.png,' modify the define statement as 
follows:  

  
Page 88 / 978 #define ICON_NORMAL btn_n.png  
ICON_PRESSED below it, as you may have guessed, indicates the file 
name of the Button background image in pressed status.  
┌─────────────────────┐  
#define ICON_NORMAL green.png  
#define ICON_PRESSED red.png  
#define BUTTON_MIN_WIDTH 142  
#define BUTTON_MIN_HEIGHT 56  
#define BUTTON_PADDING_LEFT_RIGHT 8  
#define BUTTON_ICON_HEIGHT 46  
#define BUTTON_ICON_WIDTH 46  
#define BUTTON_TEXT _SIZE 30  
└─────────────────────┘  
 Further down, you will see the following code:  
┌─────────────────────┐  
collections {  
   base_scale: 1.8;  
   group { name: "elm/button/base/ customized "; 
      script {  
         public mouse_down = 0;  
         public multi _down = 0;  
      } 
└─────────────────────┘  
For the name property under ‘group,’ you can specify a name for the 
theme. Specify a customized theme name and insert the following into 
the source code.  
elm_object_style_set(btn, "customized");  
  
Page 89 / 978 6) Related APIs  
Evas_Object *elm_button_add(Evas_Object *parent): an API that creates a 
Button widget.  
void evas_object_smart_callback_add(Evas_Object *obj, const char *event, 
Evas_Smart_Cb func, const void *data): an API that specifies a callback 
event function for a widg et or container. / parameters: the object where 
an event occurs, the type of the event (‘clicked’ indicates a click event), 
the name of the callback function, and data that will be sent to the 
callback function.  
Eina_Bool elm_object_style_set(Evas_Object * obj, const char *style): an API 
that specifies a style for a widget. / parameters: a widget to which a 
style will be applied. Specifies the type of the style. ‘icon_reorder’ 
indicates the reorder icon style; ‘icon_expand_add’ indicates the plus icon 
style; ‘icon_expand_delete’ indicates the minus icon style; and 
'customized' indicates the customized style.  
void elm_theme_extension_add(Elm_Theme *th, const char *item): an API 
that registers a theme information file. / parameters: the path of the 
theme and the EDJE file.  
char *app_get_resource_path(void): an API that finds the absolute path of 
the /res folder and returns the path.  
  
  
Page 90 / 978 8. Creating a Background with a Bg Widget  
There are two ways to display a background color or background image 
in a widget. One is  to apply a theme using EDJE, and the other is to use 
a Bg widget. By using a BG widget, you can display a background with 
ease. 
 
1) Creating a color Bg Widget  
Create a new source project and specify the project name as 'BgEx.'  
When the source project is c reated, open the bgex.c file in the src folder 
and add a new function on top of create_base_gui() function.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
   evas_object_size_hint_ali gn_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
   evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
   elm_table_pack(table, child, x, y, w, h);  
   evas_object_show(child);  
} 
└─────────────────────┘  
my_table_pack() is a function that adds a widget or container to the 
Table container. Table is a container that divides the screen into multiple 
cells and places a widget in a desired cell. By using a Table widget, you 
can use various monitor resolutions.  
  
Page 91 / 978 The following are the paramete rs of the my_table_pack() function listed 
in order:  
- Table container  
- Sub-window  
- Horizontal cell number  
- Vertical cell number  
- Number of horizontal cells  
- Number of vertical cells  
We are now going to go to the create_base_gui() function and create a  
Bg widget. Conformant and Label will be deleted because they are not 
necessary for this example.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);*/  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);  
    evas_object_ show(ad ->label);*/  
 
    /* Table */  
  
Page 92 / 978     Evas_Object *table = elm_table_add(ad ->win);  
    /* Make table homogenous - every cell will be the same size */  
    elm_table_homogeneous_set(table, EINA_TRUE);  
    /* Let the table child allocation area expand withi n in the box */  
    evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_EXPA
ND); 
    elm_win_resize_object_add(ad ->win, table);  
    evas_object_show(table);  
 
    { 
        /* Bg -1 Color */  
        Evas_Object *bg = elm_bg_add(ad ->win);  
        my_table_pack(table, bg, 0, 0, 2, 2);  
        elm_bg_color_set(bg, 66, 162, 206);  
        evas_object_show(bg);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Elm_table_add() is an API that creates a Table container.  
elm_bg_add() is an API that creates a Bg widget.  
elm_bg_color_set() is an API that specifies a background color for a Bg 
widget. For the first parameter, enter the Bg widget to which properties 
will be applied. For the second to fourth parameters, enter a color value. 
Enter color values within a range of 0 to 255 for red, green, and blue, in 
this order.  
Run the example, and you will see that the screen has changed to blue. 
  
Page 93 / 978 In other words, a Bg widget has been created in the whole area of the 
screen.  
 
 
2) Applying an Image to a Bg Widget: Original Size  
In this section, we are going to create a Bg widget to which a 
background image has been applied. To do so, an image file is 
necessary.  
We are now going to copy an image file that w ill be used as a 
background image. Create a new folder under the /res folder of the 
source project and specify the folder's name as 'images.' Right -click the 
/res folder and select [New > Folder] in the shortcut menu. When a 
popup  window appears, enter 'im ages' in the folder name field and click 
the Finish button.  
Then, go to the appendix's /Image folder and copy the logo.png file to 
the newly created /res/images folder. To copy a file to your desired 
folder, drag and drop the file to the folder using the m ouse. 

  
Page 94 / 978  
We are now going to create a new Bg widget and specify a background 
image. Add a new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    { 
        /* Bg-1 Color */  
        Evas_Object *bg = elm_bg_add(ad ->win);  
        my_table_pack(table, bg, 0, 0, 2, 2);  
        elm_bg_color_set(bg, 66, 162, 206);  
        evas_object_show(bg);  
 
        /* Image path */  
        char buf[PATH_MAX];  
        app_get_resource("images/logo.png", buf, (int)PATH_MAX);  
 
        /* Bg -2 Image Center */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_CENTER);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 2, 0, 2, 2);  
    } 
└─────────────────────┘   

  
Page 95 / 978 app_get_resource() i s a function that finds the absolute path of the /res 
folder, adds the subfolder path, and then returns the path. For the first 
parameter, enter the subfolder path. In this case, ‘images/logo.png’ has 
been sent, and therefore, the full path is ~/res/images /logo.png. This 
function has not been created yet. We will create the function shortly.  
elm_bg_option_set() specifies a style in which an image is displayed. 
Entering ELM_BG_OPTION_CENTER for the second parameter displays 
the image at the center of the Bg widget in its original size.  
elm_bg_file_set() is a function that specifies an image file for a Bg 
widget. For the first parameter, specify the Bg widget to which properties 
will be applied. For the second parameter, pass the path of the file.  
We are now g oing to create a function that returns the absolute path of 
the /res folder. Add a new code on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
app_get_resource(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_resource_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
└─────────────────────┘  
Because the source code is the same as the one used in the Bu ttonEx 
example, it will not be explained in detail.  
  
Page 96 / 978 Run the example again, and you will now see an image displayed on the 
right side of the screen. The right side is the area specified for the 
second Bg, and the image has been displayed at the center in it s 
original size.  
 
 
3) Applying an Image to a Bg Widget: Resizing While Maintaining 
the Original Proportion  
In this section, we are going to learn how to make an image fill an area 
while maintaining the original proportion of the image. Add a new code 
at the end of the create_base_gui() function.  
┌─────────────────────┐  
        /* Bg-2 Image Center */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_CENTER);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 2, 0, 2, 2);  
 

  
Page 97 / 978         /* Bg -3 Image Scale */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_SCALE);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 0, 2, 2, 2);  
    } 
└─────────────────────┘  
Entering 'ELM_BG_OPTION_SCALE' for the second parameter of the 
elm_bg_option_set() function makes an image fill the Bg area while 
maintaining the original aspect ratio of the image.  
Run the example again, and you will now see a large image displayed in 
the bott om left corner of the screen.  
 
4) Applying an Image to a Bg Widget: Resizing Ignoring the Original 
Proportion  
In this section, we are going to learn how to make an image fill an area 
ignoring the original proportion of the image. Add a new code at the 
end of the create_base_gui() function. This is a code that creates the 
fourth Bg widget.  

  
Page 98 / 978 ┌─────────────────────┐  
        /* Bg-3 Image Scale */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_SCALE);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 0, 2, 2, 2);  
 
        /* Bg -4 Image Stretch */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_STRETCH);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 2, 2, 2, 2);  
    } 
└─────────────────────┘  
Entering 'ELM_BG_OPTION_STRETCH' for the second parameter of the 
elm_bg_option_set() function makes an image fill the Bg area.  
Run the example again, and you will now see a large image dis played in 
the bottom right corner of the screen. You can see that the aspect ratio 
of displayed image is different from the original.  
 

  
Page 99 / 978 5) Applying an Image to a Bg Widget: Tile Style  
In this section, we are going to learn how to repeatedly display an imag e 
in a tile -like pattern. Add a new code at the end of the create_base_gui() 
function. This is code that creates the fifth Bg widget.  
┌─────────────────────┐  
        /* Bg-4 Image Stretch */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, E LM_BG_OPTION_STRETCH);  
        elm_bg_file_set(bg, buf, NULL);  
        my_table_pack(table, bg, 2, 2, 2, 2);  
 
        /* Bg -5 Image Tile */  
        bg = elm_bg_add(ad ->win);  
        elm_bg_option_set(bg, ELM_BG_OPTION_TILE);  
        elm_bg_file_set(bg, buf , NULL);  
        my_table_pack(table, bg, 1, 1, 2, 2);  
    } 
└─────────────────────┘  
Entering 'ELM_BG_OPTION_TILE' for the second parameter of the 
elm_bg_option_set() function displays an image repeatedly.  
Run the example again, and you will now see that an image is 
repeatedly displayed at the center of the screen.  
  
Page 100 / 978  
 
6) Related APIs  
Evas_Object *elm_bg_add(Evas_Object *parent): a function that creates a 
Bg widget.  
void elm_bg_color_set(Evas_Object *obj, int r, int g, int b): a function that 
specifies a ba ckground color for a Bg widget. / parameters: the Bg 
widget to which properties will be applied and, for the second to fourth 
parameters, color values. Enter color values within a range of 0 to 255 
for red, green, and blue, in this order.  
void elm_bg_optio n_set(Evas_Object *obj, Elm_Bg_Option option): a 
function that specifies a style in which an image will be displayed in a 
Bg widget. / parameters: The first parameter is the Bg widget object 
while the second is the image placement style. The style types ar e as 
follows:  
 - ELM_BG_OPTION_CENTER: displays the image at the center of the Bg 
area in its original size.  

  
Page 101 / 978  - ELM_BG_OPTION_SCALE: displays the image so that it fills the Bg area 
while maintaining its original aspect ratio.  
 - ELM_BG_OPTION_STRETCH: disp lays the image so that it fills the Bg 
area. 
 - ELM_BG_OPTION_TILE: displays the image repeatedly.  
Eina_Bool elm_bg_file_set(Evas_Object *obj, const char *file, const char 
*group): a function that specifies an image file for a Bg widget. / 
parameters: the Bg widget object and the path of the file.  
  
  
Page 102 / 978 9. Resizing the Screen with a  Conformant Container  
To display an indicator at the top of the screen (status bar), you need to 
use a Conformant container. You can hide an indicator even if a 
Conformant container exi sts. A Conformant container is also necessary 
for resizing the screen when a new panel such as a keypad has 
appeared. We are going to learn how to use a Conformant container 
through an example.  
 
1) Hiding the Indicator  
Create a new source project and speci fy the project name as 
'ConformantEx.'  
After a source project is created, open the bgex.c file under the src 
folder and add a new function on top of the create_base_gui() function. 
This function was used previously in the HelloWorld example.  
┌───────────── ────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_m edium");  
  
Page 103 / 978    /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, E VAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, f rame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Add a Button widget to implement a feature that hides an indicator. Add 
new code at the end of the create_base_gui() function. This code creates 
a Box container and adds a  Button widget.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, 
EVAS_HINT_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
  
Page 104 / 978     evas_object_show(ad ->conform);  
 
    {  
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, 
EVAS_HINT_EXPAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object _show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Hello EFL");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Hide");  
            evas_object_smart_callback_add(btn, "clicked", btn_hide_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We are going to implement a feature that hides an indicator when a 
newly added Button is tapped. Add a Button callback function on top of 
the create_base_gui() function.   
  
Page 105 / 978 ┌─────────────────────┐  
static void  
btn_hide_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad  = (appdata_s*)data;  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_HIDE);  
} 
└───────────────────── ┘ 
elm_win_indicator_mode_set() is an API that changes the mode of the 
indicator. Pass the Window object to the first parameter. An app can only 
have a single Window. Then, pass the mode type to the second 
parameter. Passing ELM_WIN_INDICATOR_HIDE hides the  indicator.  
Build and run the example, and you will now see an indicator at the top 
of the screen. Click the Hide button, and the indicator will disappear.  
  
There is a difference in the size of Button widgets between when there is an 
indicator and when there is no indicator. Because we specified the height of 
the Label widget as minimum, the Button vertically stretches as much as the 
height of the indicator when the indicator is no longer present.  

  
Page 106 / 978 2) Displaying an Indicator  
We are now going to implement a feature that displays an indicator that 
has previously disappeared. Add new code at the end of the 
create_base_gui() function. This is a code that creates the second Button.  
┌─────────────────────┐  
            /* Button -1 */ 
            Evas_Object *btn  = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Hide");  
            evas_object_smart_callback_add(btn, "clicked", btn_hide_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Show");  
            evas_object_smart_callback_add(btn, "clicked", btn_show_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└──────────── ─────────┘  
Then, add a callback function for the second Button on top of the 
create_base_gui() function.  
 ┌─────────────────────┐  
static void  
btn_show_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad  = (appdata_s*)data;  
    elm_win_i ndicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
} 
└─────────────────────┘  
  
Page 107 / 978 Run the example again, and click the Hide button. The indicator 
disappears.  
Now, click the Show button. The indicator appears again.  
  
 
3) Creating an Entry Widget  
Entry is an editor widget that receives text from the user. Because text is 
entered by using a keypad, the size of the screen needs to be changed. 
To that end, you need to add a different container such as a Box or 
Layout on top of a Conformant container and then add an Entry over 
the newly added container.  
Go to the create_base_gui() function and add new code at the end of 
the function. This code creates an Entry widget.  
  

  
Page 108 / 978 ┌─────────────────────┐  
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Show");  
            evas_object_smart_callback_add(btn, "clicked", btn_show_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Entry */  
            Evas_Object *entry = elm_entr y_add(ad ->conform);  
            elm_object_text_set(entry, "Entry");  
            my_box_pack(box, entry, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
elm_entry_add() is an API that creates an Entry widget. We have created 
an Entry on top of a C onformant.  
Build and run the example. You will see a Label widget at the top of the 
screen, and below that, the text 'Entry' which is the Entry widget we 
created. The background color of the Entry is the same as the color of 
the screen background, so the b oundary is not visible. We will learn how 
to specify a background color later on.  
Tap the text 'Entry.' A keypad appears, and the screen shrinks vertically. 
Now, we can see 'Entry' clearly.  
  
Page 109 / 978   
 
4) Related APIs  
Evas_Object *elm_entry_add(Evas_Object *paren t): an API that creates an 
Entry widget.  
void elm_win_indicator_mode_set (Evas_Object *obj, 
Elm_Win_Indicator_Mode mode): an API that changes the mode of the 
indicator. / parameters: the Window object and the mode type. Passing 
ELM_WIN_INDICATOR_HIDE hides  the indicator.  
  

  
Page 110 / 978 10. Using an Entry Widget  
To receive text string input from the user, you can use an Entry widget. 
We are now going to learn how to create an Entry widget and request 
the content of the user's input.  
 
1) Creating an Entry Widget  
Create a new source project and specify the project name as 'EntryEx.'  
After the source project is created, open the entryex.c file under the src 
folder and add a new function on top of the create_base_gui() function. 
This function adds a widget to a Table container.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
    evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND,  EVAS_HINT_EXPAND);  
    elm_table_pack(table, child, x, y, w, h);  
    evas_object_show(child);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and create a Box container, a 
Table container, and an Entry widget.  
  
Page 111 / 978 ┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVA S_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_box_add(ad ->conform);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box) ; 
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->conform);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set paddin g of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 20 * elm_config_scale_get(), 20 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weig ht_set(table, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_box_pack_end(box, table);  
        evas_object_s how(table);  
 
  
Page 112 / 978         { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_table_pack(table, ad ->label, 0, 0, 4, 1);  
 
            /* Entry -1 */ 
            Evas_Object *entry = elm_entry_add(ad ->conform);  
            elm_entry_single_line_set(entry, EINA_TRUE);  
            elm_entry_entry_insert(entry, "Entry -1"); 
            my_table_pack(table, entry, 0, 2, 4, 1);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Table is a container that enables the placing of a widget based on the 
aspect ratio of the screen. We need to use a Table because in order to 
use a Bg as the background of an Entry, the two must be positioned in 
the same space. We used a Box to specify the distance between widgets.  
elm_table_padding_set() is an API that specifies paddings.  
elm_entry_add() is an API that creates an Entry widget.  
elm_entry_si ngle_line_set() is an API that sets/unsets multi -line 
entry.  Passing EINA_TRUE to the second parameter sets single -line entry 
only, while passing EINA_FALSE sets multi -line entry.  
  
  
Page 113 / 978 elm_entry_entry_insert() is an API that adds caption text to an Entry 
widget. In other words, it adds new text next to existing text.  
Build and run the source project. The text 'Entry -1' you see at the 
bottom of the screen is the Entry widget we created.  
If you click the Entry widget, a keypad appears so that you can enter 
new text. 
You can use your keyboard for text entry in emulators.  
  
 
2) Displaying Guide Text  
Guide text is text that explains the role of the editor. If an entry field is 
empty, Guide text appears, and, once you enter text using a keypad, the 
Guide text disappears. Smartphones have small screens, so it is 
necessary to use space efficiently. Because Guide text can replace Label 
widgets, using Guide text helps save space.  

  
Page 114 / 978 Add new code to the Entry -creating code of the create_base_gui() 
function.  
┌────────── ───────────┐  
            /* Entry -1 */ 
            Evas_Object *entry = elm_entry_add(ad ->conform);  
            elm_entry_single_line_set(entry, EINA_TRUE);  
            elm_entry_entry_insert(entry, "Entry -1"); 
            elm_object_part_text_set(entry, "elm.guide", "Input Text");  
            my_table_pack(table, entry, 0, 2, 4, 1);  
└─────────────────────┘  
Passing 'elm.guide' to the second parameter of the 
elm_object_part_text_set() function enables specifying G uide text for an 
Entry widget. Pass the content of the Guide text to the third parameter.  
 
Run the example again and delete the content of the Entry widget. The 
text 'Input Text' appears. The Guide text disappears once you enter text 
into the Entry widget.  
  
 
  

  
Page 115 / 978 3) Creating a Background with the Bg Widget  
Because the background color of an Entry widget is white, and the color 
of the screen background is also white, the boundary between the Entry 
widget and the screen is unclear. There are two ways to displ ay a 
background color in an Entry widget. One is to use a Bg widget and the 
other is to use EDJE.  
We are now going to learn how to use a Bg widget as a background. 
Add new code at the end of the create_base_gui() function. This code 
creates a Bg widget and  specifies the same coordinates as an Entry 
widget for the Bg widget. Please take note that a Bg widget must be 
created before an Entry widget.  
┌─────────────────────┐  
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_table_pack(table, ad ->label, 0, 0, 4, 1);  
 
            /* Bg -1 */ 
            Evas_Object *bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 170, 220, 255);  
            my_table_pack(table, bg, 0, 2, 4, 1);  
 
            /* Entry -1 */ 
            Evas_Object *entry = elm_entry_add(ad ->conform);  
└─────────────────────┘  
  
  
Page 116 / 978 We created a Bg widget before an Entry widget and specified the same 
coordinates for both widgets. Doing so makes the Bg widget look like 
the background of the Entry widget.  
Run the example again, and you will now see the background of the 
Entry widget.  
 
 
4) Importing Text Entered in the Entry Widget  
We are now going to learn how to request te xt entered in an Entry 
widget when a Button is tapped. To use an Entry widget in event 
functions, it is necessary to declare it as a global variable or AppData.  
At the top of the source code, you will see an appdata_s structure 
defined. This is a structure  to store data used in apps. By default, 
Window, Conformant, and Label are declared. We will add an Entry here.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *entry ; 
} appdata_s;  
└─────────────────────┘  

  
Page 117 / 978 Then, go back to the create_base_gui() function and add new code at 
the end of the function. This code creates a Button widget and stores an 
Entry widget in an AppData structure.  
┌─────────────────────┐  
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_table_pack(table, ad ->label, 0, 0, 4, 1);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Get Text");  
            evas_object_smart_callback_add(btn, "clicked", btn_clicked_cb, ad);  
            my_table_pack(table, btn, 0, 1, 4, 1);  
 
            /* Bg-1 */ 
            Evas_Object *bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 170, 220, 255);  
            my_table_pack(table, bg, 0, 2, 4, 1);  
 
            /* Entry -1 */ 
            Evas_Object *entry = elm_entry_add(ad ->conform);  
            elm_entry_single_line_set(entry, EINA_TRUE);  
            elm_entry_entry_insert(entry, "Entry -1"); 
            elm_object_part_text_set(entry, "elm.guide", "Input Text");  
            my_table_pack(table, entry, 0, 2, 4, 1);  
            ad->entry = entry;  
└── ───────────────────┘  
We are now going to create a Button callback function. Add a new 
function on top of the create_base_gui() function. This code requests an 
Entry widget's text and displays it in a Label widget.  
  
Page 118 / 978 ┌─────────────────────┐  
static void  
btn_cl icked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s* ad = data;  
    char* text = elm_entry_entry_get(ad ->entry);  
    elm_object_text_set(ad ->label, text);  
} 
└─────────────────────┘  
elm_entry_entry_get() is a function that requests the text of an Entry 
widget. Think of the function as the reverse of elm_entry_entry_insert().  
Run the example again, change the text of the Entry widget, and then 
click the Button. The text entered in the Entry is displayed in the Label.  
 
 
5) The Entry Widget Dedicated to Password Entry  
When you enter a password, it is necessary to display the text as 
wildcard characters so that the password cannot be seen by people 
nearby. We are now going to create an Entry widget dedicated to 
password entry. Add new c ode at the end of the create_base_gui() 
function. This code creates a second Bg widget and an Entry widget.  

  
Page 119 / 978 ┌─────────────────────┐  
            /* Entry -1 */ 
            Evas_Object *entry = elm_entry_add(ad ->conform);  
            elm_entry_single_line_set (entry, EINA_TRUE);  
            elm_entry_entry_insert(entry, "Entry -1"); 
            elm_object_part_text_set(entry, "elm.guide", "Input Text");  
            my_table_pack(table, entry, 0, 2, 4, 1);  
            ad->entry = entry;  
 
            /* Bg -2 */ 
            bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 170, 220, 255);  
            my_table_pack(table, bg, 0, 3, 4, 1);  
 
            /* Entry -2 */ 
            entry = elm_entry_add(ad ->conform);  
            elm_entry_single_line_set(entr y, EINA_TRUE);  
            elm_entry_entry_insert(entry, "Entry -2"); 
            elm_entry_password_set(entry, EINA_TRUE);  
            my_table_pack(table, entry, 0, 3, 4, 1);  
        } 
└─────────────────────┘  
elm_entry_password_set() is an API that sets password -only mode. 
Passing EINA_TRUE to the second parameter sets password -only mode, 
while passing EINA_FALSE turns off the mode.  
Run the example again. When you enter text in the second Entry, the 
text is displayed as wildcard characters so that other p eople cannot 
identify the password.  
  

  
Page 120 / 978 6) Entering Multiple Lines in the Entry Widget  
To enter multiple lines of text in the Entry widget, you can use the same 
way as the Label widget. Add new code at the end of the 
create_base_gui() function. This code ad ds a third Bg widget and an 
Entry widget.  
┌─────────────────────┐  
        /* Entry -2 */ 
        entry = elm_entry_add(ad ->conform);  
        elm_entry_single_line_set(entry, EINA_TRUE);  
        elm_entry_entry_insert(entry, "Entry -2"); 
        elm_entry_pas sword_set(entry, EINA_TRUE);  
        my_table_pack(table, entry, 0, 3, 4, 1);  
 
        /* Bg -3 */ 
        bg = elm_bg_add(ad ->conform);  
        elm_bg_color_set(bg, 170, 220, 255);  
        my_table_pack(table, bg, 0, 4, 4, 2);  
 
        /* Entry -3 */ 
        entry = elm_entry_add(ad ->conform);  
        elm_object_signal_emit(entry, "elm,state,scroll,enabled", "");  
        elm_object_text_set(entry, "<font_size=30><align=left>Once upon a time
 there was a prince who was so selfish and unkind that he and all who  lived i
n his castle were put under a powerful spell.<br>The prince was turned into a 
terrible beast.</align></font_size>");  
        my_table_pack(table, entry, 0, 4, 4, 2);  
    } 
└─────────────────────┘  
  
  
Page 121 / 978 elm_object_text_set() is an API used when we changed the caption text 
of the Label and Button widgets. It can also be used for the Entry 
widget. However, it must be used together with the 
elm_object_signal_emit() function. You need to pass HTML tags to the 
second parameter.  
<font_size=20> is a tag th at specifies the font size of text.  
<align=left> is a tag that specifies the horizontal alignment as left 
alignment.  
<br> is a tag for line wrapping.  
Run the example again. Multiple lines of text are displayed in the third 
Entry. Try entering text yourself  using the keypad. You can see that the 
font size has changed. Properties specified with HTML tags only apply to 
output, not to input.  
 
 
  

  
Page 122 / 978 7) Related APIs  
Evas_Object *elm_entry_add(Evas_Object *parent): an API that creates an 
Entry widget.  
void elm_entry _single_line_set(Evas_Object *obj, Eina_Bool single_line): an 
API that sets/unsets multi -line. / parameters: the Entry object and 
whether to display in single -line mode. Passing EINA_TRUE to the second 
parameter sets single -line entry only, while passing E INA_FALSE sets 
multi-line entry.  
void elm_entry_entry_insert(Evas_Object *obj, const char *entry): an API 
that adds caption text to an Entry widget. In other words, it adds new 
text next to existing text.  
void elm_object_part_text_set(Evas_Object *obj, con st char *part, const 
char *text): an API that specifies Guide text for an Entry widget. / 
parameters: the Entry object and the area to which the text is 
applied.  Passing 'elm.guide' enables specifying Guide text for an Entry 
widget. Pass the content of the  Guide text to the third parameter.  
char *elm_entry_entry_get(Evas_Object *obj): an API that requests the text 
of an Entry widget. Think of the function as the reverse of 
elm_entry_entry_insert().  
void elm_entry_password_set(Evas_Object *obj, Eina_Bool pas sword): an 
API that sets the password -only mode. Passing EINA_TRUE to the second 
parameter sets password -only mode while passing EINA_FALSE unsets 
the mode.   
  
Page 123 / 978 11. Using a  Check Widget  
To enable choosing between On and Off, you can use the Check widget. 
We are n ow going to learn how to create a Check widget and request 
the event of the user.  
 
1) Creating a Check Widget  
Create a new source project and specify the project name as 'CheckEx.'  
After the source project is created, open the source file (~.c) under the 
src folder and add new variables to the appdata structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *check1;  
    Evas_Object *check2;  
    Evas_Object *check3;  
    Evas_Object *check4;  
} appdata_s;  
└─────────────────────┘  
We added four Check widget variables. We are now going to create a 
Check widget with the source code. Add a new function on top of the 
create_base_gui() function. This function adds a widget to a Box 
container.  
  
Page 124 / 978 ┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_me dium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into t he frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EV AS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and add new code.  
  
Page 125 / 978 ┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_ add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* check 1 */  
            ad->check1 = elm_check_add(ad ->conform);  
            elm_object_style_set(ad ->check1,"popup");  
            elm_object_text_set(ad ->check1, "Editable");  
            my_box_pack(box, ad ->check1, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_s how(ad ->win);  
└─────────────────────┘  
  
  
Page 126 / 978 We created a Box and a Check widget, and also added the Check widget 
and a Label widget to the Box.  
elm_check_add(Evas_Object *parent) is an API that creates a Check 
widget.  
elm_object_text_set(obj, text) is an API t hat specifies the caption text of a 
widget.  
We are now going to build and run the example. A Check widget is 
displayed on the screen. Tapping the square area displays a checkmark. 
Tapping the area again makes the checkmark disappear.  
  
 
  

  
Page 127 / 978 2) Changing the  symbol of the Check Widget  
We are now going to change the symbol of a Check widget. To do so, 
you need to change the style. Add new code to the create_base_gui() 
function.  
┌─────────────────────┐  
            /* check 1 */  
            ad->check1 = elm_chec k_add(ad ->conform);  
            elm_object_style_set(ad ->check1,"popup");  
            elm_object_text_set(ad ->check1, "Editable");  
            my_box_pack(box, ad ->check1, 1.0, 1.0, -1.0, -1.0); 
 
            /* check 2 */  
            ad->check2 = elm_check _add(ad ->conform);  
            elm_object_style_set(ad ->check2, "favorite");  
            elm_object_text_set(ad ->check2, "Favorite");  
            elm_check_state_set(ad ->check2, EINA_TRUE);  
            my_box_pack(box, ad ->check2, 1.0, 1.0, -1.0, -1.0); 
 
            /* check 3 */  
            ad->check3 = elm_check_add(ad ->conform);  
            elm_object_style_set(ad ->check3, "on&off");  
            elm_object_text_set(ad ->check3, "On / Off");  
            elm_check_state_set(ad ->check3, EINA_FALSE);  
            my_box_pack(box, ad ->check3, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
The second and third Check widgets are created.  
  
  
Page 128 / 978 elm_object_style_set(Evas_Object *obj, const char *style) is an API that 
specifies the style of an object. The style types for the Check widget are 
as follows:  
 - favorite: asterisk symbol  
- on&off: power on/off symbol  
We specified the style of the second Check widget as "favorite." An 
asterisk symbol is displayed.  
We specified the style of the third Check widget as "on&off." A power 
on/off symbol is displayed.  
elm_check_state_set(Elm_Check *obj, Eina_Bool state) is an API that 
specifies the On/Off status of a Check widget. Passing EINA_TRUE to the 
second parameter changes the state of the Check widget to On while 
passing EINA_FALSE changes it to Off.  
Run the example again. The second and third Check widgets are created, 
and the symbol is changed now.  
  
 
  

  
Page 129 / 978 3) Requesting an On/Off Event for the Check Widget  
We are n ow going to call an event that occurs when the user taps a 
Check widget. To do so, you need to specify an event callback function 
for the Check widget. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* check 1 */  
    ad->check1  = elm_check_add(ad ->conform);  
    elm_object_style_set(ad ->check1,"popup");  
    elm_object_text_set(ad ->check1, "Editable");  
    evas_object_smart_callback_add(ad ->check1, "changed", check_changed_cb, a
d); 
    my_box_pack(box, ad ->check1, 1.0, 1.0, -1.0, -1.0); 
 
    /* check 2 */  
    ad->check2 = elm_check_add(ad ->conform);  
    elm_object_style_set(ad ->check2, "favorite");  
    elm_object_text_set(ad ->check2, "Favorite");  
    elm_check_state_set(ad ->check2, EINA_TRUE);  
    evas_object_smart_callback_add(ad ->check2, "changed", check_changed_cb, a
d); 
    my_box_pack(box, ad ->check2, 1.0, 1.0, -1.0, -1.0); 
 
    /* check 3 */  
    ad->check3 = elm_check_add(ad ->conform);  
    elm_object_style_set(ad ->check3, "on&off");  
    elm_object_text_set(ad ->check3, "On / Off");  
    elm_check_state_set(ad ->check3, EINA_FALSE);  
    evas_object_smart_callback_add(ad ->check3, "changed", check_changed_cb, a
d); 
    my_box_pack(box, ad ->check3, 1.0, 1.0, -1.0, -1.0); 
└─────────────────────┘  
  
Page 130 / 978 evas_object_smart_callbac k_add(Evas_Object *obj, char *event, 
Evas_Smart_Cb func, void *data) is an API that specifies a callback 
function for a smart object such as a widget or container. Passing 
'changed' to the second parameter lets a callback function be called 
when the status  of the Check widget changes.  
We are now going to create a callback function. Add a new function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
check_changed_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s  *ad = data;  
    int check_num = 0;  
    if( obj == ad ->check1 )  
        check_num = 1;  
    else if( obj == ad ->check2 )  
        check_num = 2;  
    else if( obj == ad ->check3 )  
        check_num = 3;  
    else 
        return;  
  
    Eina_Bool state = elm_chec k_state_get(obj);  
    char buf[64];  
  
    sprintf(buf, "Check -%d is %s", check_num, state ? "checked" : "unchecked");  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
  
  
Page 131 / 978 This code figures out what number a Check widget has been tapped by 
the user, calls the status of the Check widget, and then displays the 
status in the Label widget.  
The first parameter of the Check widget status changing event function 
receives user data; the second parameter receives the object where an 
event has occurre d; and the third parameter receives event information.  
elm_check_state_get(const Elm_Check *obj) is an API that returns the 
On/Off status of a Check widget. The function performs a role that is the 
opposite of the role of the elm_check_state_set() function . 
Run the example again. When you tap a Check widget, the number and 
status of the Check widget are displayed in the Label widget.  
 
 
  

  
Page 132 / 978 4) Enabling/Disabling the Check Widget  
Lastly, we are going to learn how to disable a Check widget. Add code 
that create s a fourth Check widget to the create_base_gui() function.  
┌─────────────────────┐  
        /* check 3 */  
        ad->check3 = elm_check_add(ad ->conform);  
        elm_object_style_set(ad ->check3, "on&off");  
        elm_object_text_set(ad ->check3, "On / Off" ); 
        elm_check_state_set(ad ->check3, EINA_FALSE);  
        evas_object_smart_callback_add(ad ->check3, "changed", check_changed_cb, a
d); 
        my_box_pack(box, ad ->check3, 1.0, 1.0, -1.0, -1.0); 
 
        /* check 4 */  
        ad->check4 = elm_check_a dd(ad ->conform);  
        elm_object_style_set(ad ->check4, "on&off");  
        elm_object_text_set(ad ->check4, "Disable");  
        elm_object_disabled_set(ad ->check4, EINA_TRUE);  
        evas_object_smart_callback_add(ad ->check4, "changed", check_changed_c
b, ad);  
        my_box_pack(box, ad ->check4, 1.0, 1.0, -1.0, -1.0); 
    } 
└─────────────────────┘  
elm_object_disabled_set(Evas_Object *obj, Eina_Bool disabled) is an API 
that changes the active/inactive status of an object . Passing EINA_TRUE 
to the second parameter disables the object, while passing EINA_FALSE 
enables the object.  
  
  
Page 133 / 978 Run the example again. A fourth Check widget is added. Because the 
Check widget has been disabled, tapping it does not product any 
change.  
 
 
5) Related APIs  
Evas_Object* elm_check_add(Evas_Object *parent) is an API that creates a 
Check widget.  
Eina_Bool elm_object_style_set(Evas_Object *obj, const char *style) is an 
API that specifies the style of an object. The style types for the Check 
widget a re as follows:  
 - "popup": checkmark  
- favorite: asterisk symbol  
- on&off : power on/off symbol  
void elm_object_text_set(obj, text) is an API that specifies the caption text 
of a widget.  
  

  
Page 134 / 978 void elm_check_state_set(Elm_Check *obj, Eina_Bool state) is an API  that 
specifies the On/Off status of a Check widget. Passing EINA_TRUE to the 
second parameter changes the state of the Check widget to On, while 
passing EINA_FALSE changes it to Off.  
void evas_object_smart_callback_add(Evas_Object *obj, char *event, 
Evas_Smart_Cb func, void *data) is an API that specifies a callback 
function for a smart object such as a widget or container. Passing 
'changed' to the second parameter lets a callback function be called 
when the status of the Check widget changes.  
Eina_Bool el m_check_state_get(const Elm_Check *obj) is an API that 
returns the On/Off status of a Check widget. The function performs a 
role that is the opposite of the role of the elm_check_state_set() function.  
void elm_object_disabled_set(Evas_Object *obj, Eina_Boo l disabled) is an 
API that changes the active/inactive status of an object. Passing 
EINA_TRUE to the second parameter disables the object while passing 
EINA_FALSE enables the object.  
  
  
Page 135 / 978 12. Using a  Radio Widget  
To enable selecting one menu from multiple menus, you can use the 
Radio widget. We are now going to learn how to create a Radio widget 
and request the event of the user.  
 
1) Creating a Radio Widget  
Create a new source project and specify the project name as 'RadioEx.'  
After the source project is created, open the source file (~.c) under the 
src folder and add a new function on top of the create_base_gui() 
function. This function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium ", 
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set (frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
  
Page 136 / 978         evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXP AN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and add new code.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_IND ICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
  
Page 137 / 978         evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Select Radio");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            Evas_Obj ect *radio, *radio_group;  
 
            /* radio 1 -1 */ 
            radio = elm_radio_add(ad ->conform);  
            elm_object_text_set(radio, "Cat");  
            elm_radio_state_value_set(radio, 1);  
            radio_group = radio;  
            my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
 
            /* radio 1 -2 */ 
            radio = elm_radio_add(ad ->conform);  
            elm_object_text_set(radio, "Dog");  
            elm_radio_state_value_set(radio, 2);  
            elm_radio_group_add(radio, radio_group);  
            my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
 
            /* radio 1 -3 */ 
            radio = elm_radio_add(ad ->conform);  
            elm_object_text_set(radio, "Hamster");  
            elm_radio_state_value_set(radio, 3);  
            elm_radio_group_add(radio, radio_group);  
            my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
  
Page 138 / 978     evas_object_show(ad ->win);  
└─────────────── ──────┘  
Three Radio widgets are created.  
elm_radio_add(Evas_Object *parent) is an API that creates a Radio 
widget.  
elm_radio_state_value_set(Elm_Radio *obj, int value) is an API that 
specifies a status value for a Radio widget. In the case of the Radio 
widget, several widgets function as a group. Therefore, it is necessary to 
specify a different ID value for each widget.  
radio_group is the Radio group variable. Use the first Radio widget as a 
Radio group.  
elm_radio_group_add(Elm_Radio *obj, Evas_Object * group) is an API that 
adds a widget to a Radio group. Pass the widget to be added to the first 
parameter. Then, pass the Radio group to the second parameter.  
Build and run the example. Three Radio widgets are displayed on the 
screen, and if you tap a Radio  widget, a checkmark is displayed.  
If you select a different Radio widget, the position of the checkmark is 
moved.  
  
Page 139 / 978   
 
2) Requesting a Radio Widget Item Selection Event  
In this section, we are going to find out which item number has been 
selected by calli ng an event that occurs when the user taps a Radio 
widget. To do so, you need to specify an event callback function for the 
Radio widget. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
        /* radio 1 -1 */ 
        radio = elm_ra dio_add(ad ->conform);  
        elm_object_text_set(radio, "Cat");  
        elm_radio_state_value_set(radio, 1);  
        radio_group = radio;  
        evas_object_smart_callback_add(radio, "changed", radio_animal_cb, ad);  
        my_box_pack(box, radio, 1.0, 1 .0, -1.0, -1.0); 
 
        /* radio 1 -2 */ 
        radio = elm_radio_add(ad ->conform);  
        elm_object_text_set(radio, "Dog");  
        elm_radio_state_value_set(radio, 2);  
        evas_object_smart_callback_add(radio, "changed", radio_animal_cb, ad);  
        elm_radio_group_add(radio, radio_group);  
        my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 

  
Page 140 / 978  
        /* radio 1 -3 */ 
        radio = elm_radio_add(ad ->conform);  
        elm_object_text_set(radio, "Hamster");  
        elm_radio_state_value_set(radio, 3);  
        evas_object_smart_callback_add(radio, "changed", radio_animal_cb, ad);  
        elm_radio_group_add(radio, radio_group);  
        my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
└─────────────────────┘  
evas_object_smart_callback_add(Evas_Object *obj, char *event, 
Evas_Smart_Cb func, void *data) is an API that specifies a callback 
function for a smart object such as a widget or container. Passing 
'changed' to the second parameter lets a callback function be c alled 
when the status of the Radio widget changes.  
We are now going to create a callback function. Add a new function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
radio_animal_cb(void *data, Evas_Object *obj, void *event_i nfo) 
{ 
    appdata_s *ad = data;  
    int value = 0;  
    value = elm_radio_value_get(obj);  
    char buf[64];  
    sprintf(buf, "Animal Radio : %d", value);  
  
    // 1st Radio Group  
    switch( value ) {  
    case 1 :  
        sprintf(buf, "%s %s ", buf, "Cat") ; 
  
Page 141 / 978         break;  
    case 2 :  
        sprintf(buf, "%s %s ", buf, "Dog");  
        break;  
    case 3 :  
        sprintf(buf, "%s %s ", buf, "Hamster");  
        break;  
    } 
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
This code calls the status value of the Radio widget selected by the user 
and then displays the status value and the animal name of the Radio 
widget in the Label widget.  
elm_radio_value_get(const Elm_Radio *obj) is an API that returns the 
status value of a Radio widget. I t returns the status value of the currently 
selected Radio widget.  
Run the example again. Tapping the Radio widget displays the status 
value and animal name of the Radio widget.  
 

  
Page 142 / 978 3) A Second Radio Group  
In the case of the Radio widget, several widgets fun ction as a group. We 
are now going to learn add three new Radio widgets and divide them 
into two Radio groups. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
        /* radio 1 -3 */ 
        radio = elm_radio_add(ad ->conform);  
        elm_object_text_set(radio, "Hamster");  
        elm_radio_state_value_set(radio, 3);  
        evas_object_smart_callback_add(radio, "changed", radio_animal_cb, ad);  
        elm_radio_group_add(radio, radio_group);  
        my_box_pack(box, radio, 1.0, 1.0,  -1.0, -1.0); 
 
        /* radio 2 -1 */ 
        radio = elm_radio_add(ad ->conform);  
        elm_object_text_set(radio, "Cookie");  
        elm_radio_state_value_set(radio, 1);  
        radio_group = radio;  
        evas_object_smart_callback_add(radio, "changed", radio_dessert_cb, ad);  
        my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
 
        /* radio 2 -2 */ 
        radio = elm_radio_add(ad ->conform);  
        elm_object_text_set(radio, "Icecream");  
        elm_radio_state_value_set(radio, 2);  
        evas_object_smart_callback_add(radio, "changed", radio_dessert_cb, ad);  
        elm_radio_group_add(radio, radio_group);  
        my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
 
        /* radio 2 -3 */ 
        radio = elm_radio_add(ad ->conform);  
  
Page 143 / 978         elm_object_text_set(radio, "Juice");  
        elm_radio_state_value_set(radio, 3);  
        evas_object_smart_callback_add(radio, "changed", radio_dessert_cb, ad);  
        elm_radio_group_add(radio, radio_gro up); 
        my_box_pack(box, radio, 1.0, 1.0, -1.0, -1.0); 
    } 
└─────────────────────┘  
This code adds three new Radio widgets. We specified the widgets as 1, 
2, and 3, respectively using the elm_radio_state_value_set() function.  
We specified the first R adio widget as a Radio group, and we also added 
the second and third Radio widgets to the Radio group using the 
elm_radio_group_add() function.  
Then, we specified the name of the event callback function as 
'radio_dessert_cb.' We are now going to create a c allback function. Add a 
new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
radio_dessert_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int value = 0;  
    value = elm_radio_value_get(obj);  
    char buf[64];  
    sprintf(buf, "Dessert Radio : %d", value);  
  
    switch( value ) {  
    case 1 :  
        sprintf(buf, "%s %s ", buf, "Cookie");  
        break;  
  
Page 144 / 978     case 2 :  
        sprintf(buf, "%s %s ", buf, "Icecream");  
        break;  
    case 3 :  
        sprintf(buf, "%s %s ", buf, "Juice");  
        break;  
    } 
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
  
  
Page 145 / 978 The content of the new function is very similar to that of the 
radio_animal_cb() function.  
Run the example again, and you will now see a total of six Radio 
widgets displayed. Tapping the Radio widget displays checkmarks for the 
first and second groups.  
  
 
4) Changing Selected Radio Items with Source Code  
We are now going to implement a feature that  automatically selects the 
first item of the second group when the example is executed. Add new 
code at the end of the create_base_gui() function.  
┌─────────────────────┐  
            /* radio 2 -3 */ 
            radio = elm_radio_add(ad ->conform);  
            elm_object_text_set(radio, "Juice");  
            elm_radio_state_value_set(radio, 3);  
            evas_object_smart_callback_add(radio, "changed", radio_dessert_cb, ad);  
            elm_radio_group_add(radio, radio_group);  

  
Page 146 / 978             my_box_pa ck(box, radio, 1.0, 1.0, -1.0, -1.0); 
 
            /* Set selection to 2nd radio */  
            elm_radio_value_set(radio_group, 1);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_radio_value_set(Elm_Radio *obj, int value) is an API that sets a value 
for a Radio group. The Radio widget that matches the set value will be 
selected.  
Run the example again. The first item of the second group is selected 
automatically.  
 
 
  

  
Page 147 / 978 5) Related API s 
Evas_Object* elm_radio_add(Evas_Object *parent): an API that creates a 
Radio widget.  
void elm_radio_state_value_set(Elm_Radio *obj, int value): an API that 
specifies a status value for a Radio widget. In the case of the Radio 
widget, several widgets func tion as a group. Therefore, it is necessary to 
specify a different ID value for each widget.  
void elm_radio_group_add(Elm_Radio *obj, Evas_Object *group): an API 
that adds a widget to a Radio group. Pass the widget to be added to 
the first parameter. Then,  pass the Radio group to the second parameter.  
void evas_object_smart_callback_add(Evas_Object *obj, char *event, 
Evas_Smart_Cb func, void *data): an API that specifies a callback function 
for a smart object such as a widget or container. Passing 'changed'  to 
the second parameter lets a callback function be called when the status 
of the Radio widget changes.  
int elm_radio_value_get(const Elm_Radio *obj):an API that returns the 
status value of a Radio widget. It returns the status value of the currently 
selected Radio widget.  
void elm_radio_value_set(Elm_Radio *obj, int value): an API that sets a 
value for a Radio group. The Radio widget that matches the set value 
will be selected.  
  
  
Page 148 / 978 13. Using a Popup  
To display a simple message to the user, you can use a popup. You can 
make a popup close after a certain amount of time has passed, and you 
can also make a popup receive the user's input.  
 
1) Creating a Button Widget  
Create a new source project and specify the project name as 'PopupEx.'  
After the source project is created, open the popupex.c file under the src 
folder and add new variables to the appdata_s structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object * box; 
    Evas_Object *popup;  
    Evas_Object *entry;  
    int popupNum;  
} appdata_s;  
└─────────────────────┘  
'box' is a container to place widgets in sequence.  
'popup' is the handle of a popup widget. It is used to close a popup or 
to transmit data.  
  
Page 149 / 978 'entry' is used for the user to enter text in a popup  window.  
'popupNum' saves the index number of the current popup  window.  
 
Add a new function on top of the create_base_gui() function. This 
function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame  insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_ size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in t he frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
  
Page 150 / 978      } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(fra me); 
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and create four Button 
widgets. In this example, we will create four different types of popups.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win); 
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_ad d(ad->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in vertically - default mode for box */  
        ad->box = elm_box_add(ad ->win);  
        evas_object_si ze_hint_weight_set(ad ->box, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
        elm_object_content_set(ad ->conform, ad ->box);  
        evas_object_show(ad ->box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
  
Page 151 / 978             elm_object_text_set(ad ->label, "Please click a button below");  
            my_box_pack(ad ->box, ad ->label, 1.0, 0.0, 0.5, 0.0);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Popup Text");  
            evas_object_smart_callback_add(btn, "clicked", make_popup_text, ad);  
            my_box_pack(ad ->box, btn, 1.0, 0.0, -1.0, -1.0); 
 
            /* Button -2 */ 
            btn = elm_button_add(a d->conform);  
            elm_object_text_set(btn, "Popup 1 Button");  
            evas_object_smart_callback_add(btn, "clicked", make_popup_text_1butt
on, ad);  
            my_box_pack(ad ->box, btn, 1.0, 0.0, -1.0, -1.0); 
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Popup 3 Buttons");  
            evas_object_smart_callback_add(btn, "clicked", make_popup_text_3butt
on, ad);  
            my_box_pack(ad ->box, btn, 1.0, 0.0, -1.0, -1.0); 
 
            /* Button -4 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Popup Input Text");  
            evas_object_smart_callback_add(btn, "clicked", make_popup_input_text,
 ad); 
            /* Note: this last button has weight 1 and align 0 so that the whol
e UI is  
             * nicely and tightly packed at the top of the window.  
             */ 
            my_box_pack(ad ->box, btn, 1.0, 1.0, -1.0, 0.0);  
        } 
  
Page 152 / 978     } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Box on top of a Conformant, and we also added one Label 
and four Button widgets on top of the Box.  
To prevent build errors, it is necessary t o create callback functions for 
Buttons. Add four new functions on top of the create_base_gui() 
function. We will define the content of the functions later.  
┌─────────────────────┐  
static void  
make_popup_text(void *data, Evas_Object *obj, void *event_info)  
{  } 
  
static void  
make_popup_text_1button(void *data, Evas_Object *obj, void *event_info)  
{  } 
  
static void  
make_popup_text_3button(void *data, Evas_Object *obj, void *event_info)  
{  } 
  
static void  
make_popup_input_text(void *data, Evas_Object *obj, vo id *event_info)  
{  } 
└─────────────────────┘  
 
  
Page 153 / 978 Build and run the source project, and then you can see a Label and 
Buttons. We specified the area heights of the first to third Buttons as 
minimum. We specified the area height of the fourth Button as 
maximum b y passing 1.0 to the fourth parameter of the my_box_pack() 
function. In addition, we specified the height of each Button as minimum 
by passing 0.0 to the sixth parameter. Doing so concentrates the widgets 
at the top.  
 
 
2) Creating a Text Popup  
In this section, we are going to create the most basic popup that 
displays a text message. Add popup -creating code to the first Button's 
callback function.  
┌─────────────────────┐  
static void  
make_popup_text(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    ad->popup = elm_popup_add(ad ->grid);  
    elm_popup_align_set(ad ->popup, ELM_NOTIFY_ALIGN_FILL, 1.0);  
    evas_object_size_hint_weight_set(ad ->popup, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_text_set(ad ->popup, "Text popup  - timeout of 3 sec is set.");  
  
    evas_object_show(ad ->popup);  

  
Page 154 / 978     ad->popupNum = 1;  
} 
└─────────────────────┘  
elm_popup_add() is an API that creates a popup.  
elm_popup_align_set() is an API that specifies the position of a popup. 
For the second paramet er, enter a horizontal position for the popup. 
Entering ELM_NOTIFY_ALIGN_FILL lets the popup use the whole 
horizontal area of the screen. For the third parameter, enter a vertical 
position for the popup. The acceptable range of values is 0.0 -1.0. 
evas_obje ct_size_hint_weight_set() is an API that specifies a hint for the 
size of a widget. The second parameter indicates the width, while the 
third parameter indicates the height.  EVAS_HINT_EXPAND is an option 
that allocates a widget as much space as possible in  a given area.  
Specifying '1' as popupNum is to remember that it is a first popup.   
Run the example again and click the first Button. A popup appears at 
the bottom of the screen, and a text message is displayed.  
  

  
Page 155 / 978 3) Setting an Auto Shutdown Timer  
You can not close popups because there is no Button on them. Let's 
implement a feature that automatically closes a popup after a certain 
amount of time has passed.  
Add new code to the make_popup_text() function.  
┌─────────────────────┐  
    ~ 
    elm_object_text_set(ad ->popup, "Text popup - timeout of 3 sec is set.");  
    elm_popup_timeout_set(ad ->popup, 3.0);  
    evas_object_smart_callback_add(ad ->popup, "timeout", popup_timeout, ad);  
    evas_object_show(ad ->popup);  
    ~ 
└─────────────────── ──┘  
elm_popup_timeout_set() is an API that sets a timer event for a popup. 
For the second parameter, enter a time interval. Entering 3.0 lets a timer 
event occur at 3 second intervals.  
evas_object_smart_callback_add() is an API that specifies a callback 
function that receives events. Entering 'timeout' for the second 
parameter lets a callback function be called when a timer event occurs. 
For the third parameter, enter the name of the callback function.  
We are now going to create a timer event function. Add a new function 
on top of the make_popup_text() function.  
This new function deletes a popup and displays text in the Label widget.  
 
  
Page 156 / 978 ┌─────────────────────┐  
static void  
popup_timeout(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_del(obj);  
    elm_object_text_set(ad ->label, "Time out");  
} 
└─────────────────────┘  
evas_object_del() is an API that deletes an object. In this case, we deleted 
the subject of the timer event. In other words, a popup is deleted.  
Run the ex ample again and click the first Button. A popup appears and 
then disappears automatically after a short while.  
 
4) Closing a Popup When the Block Area is Touched  
In this section, we are going to implement a feature that closes an 
existing popup when the ar ea outside the popup is tapped.  
Add new code at the end of the make_popup_text() function.  
┌─────────────────────┐  
    evas_object_smart_callback_add(ad ->popup, "timeout", popup_timeout, ad);  
    evas_object_smart_callback_add(ad ->popup, "block,clicked", popup_block_clicke
d, ad);  
    evas_object_show(ad ->popup);  
└─────────────────────┘  
  
  
Page 157 / 978 We passed the popup to the first parameter of the 
evas_object_smart_callback_add() function and 'block,clicked' to the 
second parameter. Doing so enables requesting an eve nt when the area 
outside the popup is tapped.  
We are now going to create a function that requests this event. Add a 
new function on top of the make_popup_text() function.  
This new function deletes a popup and displays text in the Label widget.  
┌─────────── ──────────┐  
static void  
popup_block_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_del(obj);  
    elm_object_text_set(ad ->label, "Block Clicked");  
} 
└─────────────────────┘  
Run the example again, click th e first Button, and when a popup 
appears, click the area outside the popup. The popup disappears, and 
the text ‘Block Clicked’ is displayed in the Label widget.  
 
 

  
Page 158 / 978 5) Adding a Button to a Popup  
In this section, we are going to implement a feature that crea tes a 
Button on top of a popup that appears when the second Button is 
tapped and closes the popup when the created Button is tapped.  
Add new code to the make_popup_text_1button() function. This code 
creates a popup and adds a Button on top of the popup.  
┌─────────────────────┐  
static void  
make_popup_text_1button(void *data, Evas_Object *obj, void *event_info)  
{ 
    Evas_Object *btn;  
    appdata_s *ad = data;  
  
    /* popup */  
    ad->popup = elm_popup_add(ad ->grid);  
    elm_popup_align_set(ad ->popup, ELM_NOTIFY_ALIGN_FILL, 1.0);  
    evas_object_smart_callback_add(ad ->popup, "block,clicked", popup_block_clicke
d, ad);  
    evas_object_size_hint_weight_set(ad ->popup, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_text_set(ad ->popup, "1Button popup");  
  
    /* ok button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "OK");  
    elm_object_part_content_set(ad ->popup, "button1", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn1_clicked, ad);  
  
    evas_object_show(ad ->popup);  
    ad->popupNum = 2;  
} 
└─────────────────────┘  
  
Page 159 / 978 Now, let's implement a feature that displays text in the Label widget 
when a Button added on top of a popup is tapped. Add a new function 
on top of the make_popup_text_1button() function. This new f unction is 
an OK button event function.  
┌─────────────────────┐  
static void  
popup_btn1_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char *input;  
    Eina_Strbuf *str;  
 
    /* use eina_strbuf here for safe string allocation and formatting */  
    input = elm_entry_entry_get(ad ->entry);  
    str = eina_strbuf_new();  
    eina_strbuf_append_printf(str, "Input: '%s'", input);  
    elm_object_text_set(ad ->label, eina_strbuf_strin g_get(str));  
    eina_strbuf_free(str);  
 
    /* Destroy the popup AFTER reading from its child entry */  
    evas_object_del(ad ->popup);  
    ad->popup = NULL;  
} 
└─────────────────────┘  
eina_strbuf_new() is an API that creates a StrBuf object. StrBuf is a 
structure that makes it easy to use strings.  
eina_strbuf_append_printf() is an API that adds a new string to a StrBuf.  
  
  
Page 160 / 978 eina_strbuf_string_get() is an API that returns the string stored in a 
StrBuf.  
eina_strbuf_free() is an API that deletes a StrBuf object.  
Run the example again and click the second Button. A popup appears, 
and you can see a text message and a Button.  
Clicking the OK button makes the popup disappear and changes the text 
in the Label widget.  
  
 
6) Adding Three Buttons to a Popup  
In this section, we are going to add three Buttons to a popup. Add new 
code to the make_popup_text_3button() function. This code creates a 
popup and adds three Buttons on top of the popup.  
Copying and modifying the content of the make_popup_text_1button()  
function will spare you some typing.  

  
Page 161 / 978 ┌─────────────────────┐  
static void  
make_popup_text_3button(void *data, Evas_Object *obj, void *event_info)  
{ 
    Evas_Object *btn;  
    appdata_s *ad = data;  
  
    /* popup */  
    ad->popup = elm_popup_add(ad ->grid);  
    elm_popup_align_set(ad ->popup, ELM_NOTIFY_ALIGN_FILL, 1.0);  
    evas_object_smart_callback_add(ad ->popup, "block,clicked", popup_block_clicke
d, ad);  
    evas_object_size_hint_weight_set(ad ->popup, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_text _set(ad ->popup, "3Button popup");  
  
    /* ok button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "OK");  
    elm_object_part_content_set(ad ->popup, "button1", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn1_click ed, ad);  
  
    /* cancel button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "Cancel");  
    elm_object_part_content_set(ad ->popup, "button2", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn2_clicked, ad);  
  
    /* close button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "Close");  
    elm_object_part_content_set(ad ->popup, "button3", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn3_clicked, ad);  
  
  
Page 162 / 978     evas_object_show(ad ->popup);  
    ad->popupNum = 3;  
} 
└─────────────────────┘  
Now, let's implement a feature that displays text in the Label widget 
when a Button on top of a popup is tapped. Add two new functions on 
top of the make_popup_text_3button() function. These new funct ions are 
event functions for the Cancel button and the Close button.  
┌─────────────────────┐  
static void  
popup_btn2_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_del(ad ->popup);  
    elm_object_text_set( ad->label, "Button -2 Clicked");  
} 
  
static void  
popup_btn3_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_del(ad ->popup);  
    elm_object_text_set(ad ->label, "Button -3 Clicked");  
} 
└─────────────────────┘  
 Run the example again and click the third Button. Three Buttons then 
appear over a popup.  
Clicking any one of the Buttons makes the popup disappear and 
changes the text in the Label.  
  
Page 163 / 978   
 
7) Adding an Entry Widget to a Popup  
In this section, we are going  to implement a feature that adds an entry 
to a popup so that the user can enter text in the popup. Add new code 
to the make_popup_input_text() function. This code creates a popup and 
adds one Entry and two Buttons on top of the popup.  
Copying and modifyi ng the content of the make_popup_text_1button() 
function will spare you some typing.  
┌─────────────────────┐  
static void  
make_popup_input_text(void *data, Evas_Object *obj, void *event_info)  
{ 
    Evas_Object *btn;  
    appdata_s *ad = data;  
    Evas_Object  *entry;  
  
    /* popup */  
    ad->popup = elm_popup_add(ad ->grid);  

  
Page 164 / 978     elm_popup_align_set(ad ->popup, ELM_NOTIFY_ALIGN_FILL, 1.0);  
    evas_object_smart_callback_add(ad ->popup, "block,clicked", popup_block_clicke
d, ad);  
    evas_object_size_hint_weight_se t(ad->popup, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_part_text_set(ad ->popup, "title,text", "Input Text");  
  
    /* entry */  
    entry = elm_entry_add(ad ->popup);  
    evas_object_size_hint_weight_set(entry, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    evas_object_size_hint_align_set(entry, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    elm_object_part_content_set(ad ->popup, "elm.swallow.content" , entry);  
    evas_object_show(entry);  
    ad->entry = entry;  
  
    /* OK button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "OK");  
    elm_object_part_content_set(ad ->popup, "button1", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn1_clicked, ad);  
  
    /* Cancel button */  
    btn = elm_button_add(ad ->popup);  
    elm_object_text_set(btn, "Cancel");  
    elm_object_part_content_set(ad ->popup, "button2", btn);  
    evas_object_smart_callback_add(btn, "clicked", popup_btn2_clicked, ad);  
  
    evas_object_show(ad ->popup);  
    ad->popupNum = 4;  
} 
└──────────────────── ─┘ 
  
  
Page 165 / 978 Run the example again and click the fourth Button, and you will now see 
an Entry added to the popup.  
 
Now, let's implement a feature that, when the user enters text into an 
Entry and taps the OK button, displays the text in the Label.  
Add new code to  the popup_btn1_clicked() function. If the current 
popup is a fourth popup, this code requests the caption text in the Entry 
of the popup and displays it in the Label. Then, this code initializes the 
Entry widget.  
┌─────────────────────┐  
static void  
popup_btn1_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
 
    if (ad ->popupNum == 4) {  
        const char *input;  
        Eina_Strbuf *str;  
 
        /* use eina_strbuf here for safe string allocation and formatting */  

  
Page 166 / 978         input = elm_entry_entry_get(ad ->entry);  
        str = eina_strbuf_new();  
        eina_strbuf_append_printf(str, "Input: '%s'", input);  
        elm_object_text_set(ad ->label, eina_strbuf_string_get(str));  
        eina_strbuf_free(str);  
    } else {  
        elm_object_text_set(ad ->label, "Button 1 clicked.");  
    } 
 
    /* Destroy the popup AFTER reading from its child entry */  
    evas_object_del(ad ->popup);  
    ad->popup = NULL;  
 
    /* Entry will be deleted when the popup is deleted (child widget) */ 
    ad->entry = NULL;  
} 
└─────────────────────┘  
Run the example again and click the fourth Button. When a popup 
appears, enter text in the Entry and click the OK button.  
The popup disappears, and the text is displayed in the Label.  
  
 
  

  
Page 167 / 978 8) Related APIs 
Evas_Object *elm_popup_add(Evas_Object *parent): an API that creates a 
popup.  
void elm_popup_align_set(Evas_Object *obj, double horizontal, double 
vertical): an API that specifies the position of a popup. For the second 
parameter, enter a horizontal position for the popup. Entering 
ELM_NOTIFY_ALIGN_FILL lets the popup use the whole horizontal area of 
the screen. For the third parameter, enter a vertical position for the 
popup. The acceptable range of values is 0.0 -1.0. 
void evas_object_size_hint_weigh t_set(Evas_Object *obj, double x, double 
y): an API that specifies the rough size of an object. / parameters:the 
Window object, width hint, and height hint. EVAS_HINT_EXPAND is an 
option that expands the object as much as possible.  
void elm_popup_timeout_s et(Evas_Object *obj, double timeout): an API 
that specifies a timer for a popup.  For the second parameter, enter a 
time interval. Entering 3.0 lets a timer event occur at 3 second intervals.  
void evas_object_smart_callback_add(Evas_Object *obj, const char  *event, 
Evas_Smart_Cb func, const void *data): an API that specifies a callback 
function that receives events. Entering 'timeout' for the second 
parameter lets a callback function be called when a timer event occurs. 
For the third parameter, enter the nam e of the callback function.  
void evas_object_del(Evas_Object *obj): an API that deletes an object.  
  
  
Page 168 / 978 14. Using a Slider Widget  
To let the user enter values, you need to use the Slider widget. This 
widget is also useful for scanning through the playlist in an  audio or 
video player.  
 
1) Creating a Slider Widget  
Create a new source project and specify the project name as 'SliderEx.'  
After the source project is created, open the sliderex.c file under the src 
folder and add a new function on top of the create_base _gui() function. 
This function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the 
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     {  
        /* tell the child that is packed into the frame to be able to expand */  
  
Page 169 / 978         evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame  into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and create a Box container 
and a Slider widget.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_wei ght_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
 
  
Page 170 / 978         evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Please test the slider below");  
            my_box_pack(box, ad ->label, 1.0, 0.1, 0.5, 1.0);  
 
            /* Slider -1 */ 
            Evas_Objec t *slider = elm_slider_add(ad ->conform);  
            elm_slider_min_max_set(slider, 0, 9);  
            elm_slider_value_set(slider, 5);  
            my_box_pack(box, slider, 1.0, 0.1, -1.0, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_slider_add() is an API that creates a Slider widget.  
elm_slider_min_max_set() is an API that specifies the range of a Slider. 
For the second parameter , enter the minimum value. For the third 
parameter, enter the maximum value. The variable type is 'double.'  
elm_slider_value_set() is an API that specifies the current value of a Slider.  
Build and run the source project. You can see a Slider widget. Move t he 
trackbar to the left and right.  
  
Page 171 / 978   
2) Displaying an Indicator in the Slider Widget  
The indicator is a feature that displays the current value of the slider as 
the trackbar is dragged. Add new code to the code that creates a Slider.  
┌─────────────────── ──┐  
        /* Slider -1 */ 
        Evas_Object *slider = elm_slider_add(ad ->conform);  
        elm_slider_min_max_set(slider, 0, 9);  
        elm_slider_value_set(slider, 5);  
        elm_slider_indicator_show_set(slider, EINA_TRUE);  
        elm_slider_indica tor_format_set(slider, "%1.0f");  
        my_box_pack(box, slider, 1.0, 0.1, -1.0, 0.0);  
└─────────────────────┘  
elm_slider_indicator_show_set() is an API that specifies whether to display 
an indicator in a Slider. Passing EINA_TRUE to the second parameter 
displays an indicator. Passing EINA_FALSE does the opposite.  
elm_slider_indicator_format_set() is an API that specifies a format for text 
displayed in an indicator.  
Run the example again and move the trackbar around. Numbers appear 
above the trackbar.  
 
  

  
Page 172 / 978 3) Slider Tracking Event  
In this section, we are going to request in real time, an event that occurs 
when the user drags a trackbar. This feature is necessary when you 
implement a video player.  
Add new code to the code that creates a Slider.  
┌───────────── ────────┐  
        /* Slider -1 */ 
        Evas_Object *slider = elm_slider_add(ad ->conform);  
        elm_slider_min_max_set(slider, 0, 9);  
        elm_slider_value_set(slider, 5);  
        elm_slider_indicator_show_set(slider, EINA_TRUE);  
        elm_slider_ indicator_format_set(slider, "%1.0f");  
        evas_object_smart_callback_add(slider, "changed", slider_changed_cb, ad);  
        my_box_pack(box, slider, 1.0, 0.1, -1.0, 0.0);  
└─────────────────────┘  
Passing 'changed' to the second parameter of the 
evas_ob ject_smart_callback_add() function enables requesting an event 
when the value of the slider changes.  
Now, let's define an event function. Add a new function on top of the 
create_base_gui() function. This code requests the current value of the 
Slider and di splays it in the Label widget.  
┌─────────────────────┐  
static void  
slider_changed_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
Page 173 / 978     char buf[64];  
  
    double value = elm_slider_value_get(obj);  
    sprintf(buf, "Slider : %d ", (int)value);  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
elm_slider_value_get() is an API that performs the opposite function of 
elm_slider_value_set(). It returns the current value of the Slider. The 
variable type is 'double.'  
Run the example again and move the trackbar around. The current value 
of the Slider is displayed in the Label widget.  
 
 
4) Displaying a Center Point  
You can display a center point at the center of a Slider. We are now 
going to add code that creates a new Label and Slider to the 
create_base_gui() function.  
┌─────────────────────┐  
        /* Slider -1 */ 
        Evas_Object *slider = elm_slider_add(ad ->conform);  
        elm_slider_min_max_set(slider, 0, 9);  
        elm_slider_value_set(slider, 5);  
        elm_slider_indicator_show_set(slider, EINA_TRUE);  
        elm_slider_indicator_format_set(slider, "%1.0f");  

  
Page 174 / 978         evas_object_smart_callback_add(slider, "changed", slider_changed_cb, ad);  
        my_box_pack(box, slider, 1.0, 0.1, -1.0, 0.0);  
 
        /* Label-2 */ 
        ad->label2 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label2, "Please test the slider below");  
        my_box_pack(box, ad ->label2, 1.0, 0.1, 0.5, 1.0);  
 
        /* Slider -2 */ 
        slider = elm_slider_add(ad ->conform ); 
        elm_slider_min_max_set(slider, 0, 99);  
        elm_slider_value_set(slider, 30);  
        elm_object_style_set(slider, "center_point");  
        evas_object_smart_callback_add(slider, "changed", slider2_changed_cb, ad);  
        my_box_pack(box, slider, 1.0, 0.1, -1.0, 0.0);  
    } 
└─────────────────────┘  
We passed the Slider widget to the first parameter of the 
elm_object_style_set() function and 'center_point' to the second 
parameter. Doing so displays a grid at the cente r of the Slider widget.  
We are now going to define a callback function for the second Slider. 
Add a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
slider2_changed_cb(void *data, Evas_Object *obj, void *event_info ) 
{ 
    appdata_s *ad = data;  
    char buf[64];  
 
    double value = elm_slider_value_get(obj);  
    sprintf(buf, "Slider value: %d", (int)value);  
  
Page 175 / 978     elm_object_text_set(ad ->label2, buf);  
} 
└─────────────────────┘  
Run the example again, and you will now see  a second Slider widget 
created and the center point displayed. Drag the trackbar, and values will 
be displayed in the second Label.  
 
 
5) Related APIs  
Evas_Object *elm_slider_add(Evas_Object *parent): an API that creates a 
Slider widget.  
void elm_slider_m in_max_set(Evas_Object *obj, double min, double max): 
an API that specifies the range of a Slider widget. Parameters: Slider 
widget object, minimum value, and maximum value.  
void elm_slider_value_set(Evas_Object *obj, double val): an API that 
specifies the  current value of a Slider widget.  
  

  
Page 176 / 978 void elm_slider_indicator_show_set(Evas_Object *obj, Eina_Bool show): an 
API that specifies whether to display an indicator in a Slider widget. 
Passing EINA_TRUE to the second parameter displays an indicator. 
Passing EINA_FALSE does the opposite.  
void elm_slider_indicator_format_set(Evas_Object *obj, const char 
*indicator): an API that specifies the format of text displayed in an 
indicator. / parameters: Slider object and text format.  
double elm_slider_value_get(const Evas_Object *obj): an API that returns 
the current value of a Slider. The variable type is 'double.'  
Eina_Bool elm_object_style_set(Evas_Object *obj, const char *style): an API 
that specifies the style of an object. Passing the Slider widget to the first 
parameter and passing 'center_point' to the second parameter displays a 
grid at the center of the Slider widget.  
  
  
Page 177 / 978 15. Adding a Text Item to the List Widget.  
To display a list of multiple text items on the screen, you need to use the 
List widget. The List widget can be scrolled up and down and also 
enables requesting the user's selection event. We are now going to learn 
how to use the List widget through an example.  
 
1) Creating a Text List Widget  
Create a new source project and specify the project name as 'ListEx.'  
After the source project is created, open the source file (~.c) under the 
src folder and add a new function on top of the create_base_gui() 
function. This function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack( Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium p adding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of t he child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
  
Page 178 / 978         /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actuall y put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and create a Box container 
and a List widget. Next, add 10 text items.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
 
  
Page 179 / 978         evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS
_HINT_EXPAND);  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* List */  
            const char *items[] = { "Seoul", "Tokyo", "Newyork", "Londeon", "Ba
ijing", "Kongga", "Moscuba", "Singgapol", "Pusan", "Hongkong" };  
            Evas_Object *list = elm_list_add(ad ->conform);  
 
            for(int i=0; i < 10; i++)  
                elm_list_item_append(list, items[i], NULL, NULL, NULL, (void*)i);  
            elm_list_go(list);  
            my_box_pack(box, list, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────── ──────────────┘  
elm_list_add() is an API that adds a new List widget.  
  
  
Page 180 / 978 elm_list_item_append() is an API that adds items to a List widget. The 
first parameter indicates the object of the List widget, while the second 
parameter indicates the text string. The third parameter indicates the left 
icon, and the fourth parameter indicates the right icon. For the fifth 
parameter, specify the item selection event function in callback style. 
Then, pass user data to the sixth parameter. Although 'appdata' is passed 
generally, we passed the index numbers in order to identify which 
number the item is.  
elm_list_go() is an API that reflects changes to items on the screen by 
refreshing the screen. It is necessary to call this function to reflect the 
change on the screen w hen a new item has been added or when an 
existing item has been deleted or modified.  
Run the example, and you will see a List widget created and 10 text 
items displayed. You can scroll through a list by dragging your mouse up 
and down. If you select an ite m, a checkmark appears.  
 

  
Page 181 / 978 2) Automatically Removing the Checkmark  
If you select an item, a checkmark appears and stays displayed. 
Sometimes this feature is necessary, but other times it is not. We are 
now going to learn how to disable this feature. Add a new line of code 
to the create_base_gui() function.  
┌─────────────────────┐  
            elm_list_go(list);  
            evas_object_smart_callback_add(list, "selected", list_selected_cb, NULL);  
            my_box_pack(box, list, 1.0, 1.0, -1.0, -1.0); 
        } 
└─────────────────────┘  
This code specifies a callback function that is called when the user 
selects a List widget item. In other words, a callback function needs to 
be defined.  
Add a new function on top of the create_base_gui() function.  
┌─────────── ──────────┐  
static void  
list_selected_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    Elm_Object_Item *it = event_info;  
    elm_list_item_selected_set(it, EINA_FALSE);  
} 
└─────────────────────┘  
  
  
Page 182 / 978 elm_list_item_selected_set() is an API that displa ys/removes the 
checkmark for List widget items. You need to pass the item object to the 
first parameter. In this case, pass 'event_info' that is passed from the 
third parameter of the callback function. Passing EINA_TRUE to the 
second parameter displays th e checkmark while passing EINA_FALSE 
removes the checkmark.  
Run the example again and select a List widget item. This time, a 
checkmark appears and then disappears.  
 
3) Requesting a List Widget Item Selection Event  
In this section, we are going to implement a feature that, when the user 
selects a List widget item, requests the index number and text of the 
item and displays them in a Label widget.  
Modify the code that adds items to a List widget as shown below.  
┌─────────────────────┐  
    for(int i= 0; i < 10; i++)  
        elm_list_item_append(list, items[i], NULL, NULL, list_item_clicked, (void*)i);  
        //elm_list_item_append(list, items[i], NULL, NULL, NULL, (void*)i);  
└─────────────────────┘  
We specified the item selection event callback functi on as 
list_item_clicked. We are now going to define this function.  
Add a new function on top of the create_base_gui() function.  
 
  
Page 183 / 978 ┌─────────────────────┐  
static void  
list_item_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    int index = (int) data; 
    Elm_Object_Item *it = event_info;  
    const char *item_text = elm_object_item_text_get(it);  
  
    char buf[PATH_MAX];  
    sprintf(buf, "%d - %s", index, item_text);  
    dlog_print(DLOG_INFO, "tag", "%s", buf);  
} 
└─────────────────────┘  
When the u ser selects an item in a List widget, this function is called. 
The first parameter receives the index number of the item. The second 
parameter receives the object of the List widget, and the third parameter 
receives the object of the selected item.  
elm_object_item_text_get() is an API that returns the text of an item.  
And after that is code that stores the index number and text of the item 
in string variables and displays them in the Log pane.  
Build the example again and run it. Select an item, and y ou will now see 
information about the item displayed in the Log pane. If you cannot see 
the Log pane at the bottom of Eclipse, select [Window > Show View > 
Other...] in the menu and then select [Tizen > Log] in the popup  window.  
To view log messages, selec t Tag from the combo box at the bottom of 
the Eclipse Log pane and enter 'tag' in the Edit box to the right.  
  
Page 184 / 978  
  
4) Displaying Item Information in the Label Widget  
Instead of 'appdata,' we passed the index number of the selected item to 
the item selection event function. To display information about the item in 
the Label widget, you need to specify appdata as a global variable.  
Add a new line of code at the top of the source file.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
appdata_s* m_ad = 0;  
└─────────────────────┘  
This code declares appdata as a global variable.  
  

  
Page 185 / 978 Then, implement the global variable at the beginning of the 
create_base_gui() function as shown be low. 
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    m_ad = ad;  
└─────────────────────┘  
The Label widget can now be used anywhere.  
Go back to the list_item_clicked() function and add a new line of code at 
the end of the function as shown below.  
┌─────────────────────┐  
    dlog_print(DLOG_INFO, "tag", "%s", buf);  
    elm_object_text_set(m_ad ->label, buf);  
} 
└─────────────────────┘  
This code displays information about a selected List widget item in the 
Label widget.  
Run the example  again and select the following List widget item. 
Information about the selected item is displayed in the Label widget.  
  
Page 186 / 978  
5) Related APIs  
Evas_Object *elm_list_add(Evas_Object *parent): an API that adds a List 
widget. / parameters: parent object.  
Elm_Objec t_Item *elm_list_item_append(Evas_Object *obj, const char 
*label, Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const 
void *data): an API that adds items to a List widget. / parameters: List 
widget, item text, left icon, right icon, name of the item selection event 
function, and user data.  
void elm_list_go(Evas_Object *obj): an API that starts a list. This function 
must be called first before displaying a List widget on the screen. It is 
necessary to call this function to reflect the change on th e screen when 
a new item has been added or when an existing item has been deleted 
or modified. / parameters: List widget.  
void elm_list_item_selected_set(Elm_Object_Item *it, Eina_Bool selected): 
an API that displays/removes the item checkmark. / parameter s: List 
widget and whether to display the checkmark.  

  
Page 187 / 978 const char *elm_object_item_text_get(const Elm_Object_Item *it): an API 
that returns the text of an item. / parameters: object of the item.  
  
  
Page 188 / 978 16. Displaying an Icon in a  GenList Widget  
To display an icon or two-line text in a List widget, you can use the 
GenList widget. You can also divide lists into groups.  
In the case of the GenList widget, adding/deleting an item and adding 
content such as an icon require processing by a callback function, and a 
structure must be used to store item data. Therefore, the GenList widget 
is more cumbersome to use than the List widget. Let's learn in detail 
how to use the GenList widget through an example.  
 
1) Creating a GenList Widget & Displaying Text  
Create a new source proje ct and specify the project name as 'GenListEx.'  
After the source project is created, open the source file (~.c) under the 
src folder and define a new structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
typedef struct item_data  
{ 
     int index;  
     Elm_Object_Item *item;  
} item_data_s;  
└─────────────────────┘  
  
Page 189 / 978 item_data is a structure that stores GenList widget item data.  
Add a new function on top of the c reate_base_gui() function. This 
function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "defa ult" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the exp anded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set( frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
  
Page 190 / 978 Next, go to the create_base_gui() function and create a B ox container 
and a List widget. Then, add 10 text items.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND); 
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* Genlist */  
            Evas_Object *genlist = elm_genlist_add(ad ->conform);  
            my_box_pack(box, genlist, 1.0, 1.0, -1.0, -1.0); 
 
            /* Create item class */  
  
Page 191 / 978             Elm_Genlist_Item_Class *itc = elm_genlist_item_class_new();  
            itc->item_style = "end_icon";  
            itc->func.text_get = gl_text_get_cb;  
            itc->func.del = gl_del_cb;  
 
            /* Item add */  
            for(int i=0; i <  10 ; i++)  
            { 
                item_data_s *id = calloc(sizeof(item_data_s), 1);  
                id->index = i;  
                id->item = elm_genlist_item_append(genlist, itc, id, NULL, ELM_G
ENLIST_ITEM_NONE, NULL, id);  
            } 
 
            elm_genlist_item_class_free(itc);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Box and then created a GenList and added it to the Box.  
elm_genlist_add() is a n API that creates a GenList widget.  
elm_genlist_item_class_new() is an API that creates a class for a GenList 
item.  
Elm_Genlist_Item_Class is the class of a GenList item. You specify a 
GenList style and callback function using this class. The style types  are as 
follows:  
- Passing "end_icon" to the item_style property displays the icon at the 
right end.  
  
Page 192 / 978 - For the func.text_get property, enter a callback function that specifies 
the text of the item.  
- For the func.del property, enter a callback function tha t deletes the 
item. 
elm_genlist_item_append() is an API that adds items to a GenList. When 
this function is called, the callback function entered for the func.text_get 
property is called automatically. The parameters listed in order are: 
GenList object, it em class, parent item, item type, name of the item 
selection event callback function, and user data.  
elm_genlist_item_class_free() is an API that deletes the class of a GenList 
item. 
Now, let's define a callback function that specifies the text of a GenLis t 
widget item. Add a new function on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static char*  
gl_text_get_cb(void *data, Evas_Object *obj, const char *part)  
{ 
    const char *items[] = { "Seoul", "Tokyo", "Newyork", "Londeon", "Baijing",  "Kongga
", "Moscuba", "Singgapol", "Pusan", "Hongkong" };  
    item_data_s *id = data;  
  
    if (!strcmp(part, "elm.text")) {  
        return strdup(items[id ->index]);  
    } 
  
    return NULL;  
} 
└─────────────────────┘  
  
  
Page 193 / 978 This code is a callback function that  enters data in a GenList widget 
item. User data is passed to the first parameter.  In this case, the item 
data structure is passed. The index property contains the index number 
of the item. The second parameter is the object of the item. To the third 
param eter, the type of the element is passed.  
One GenList item can have various elements. For example, if this value is 
"elm.text," it means the item has the text element.  
strcmp (char *, char *) is an API that compares two strings. If the two 
strings turn out to be the same string, value '0' is returned.  
The function described above needs to return the text that matches a 
given item index number, and the reason for using the strdup() function 
is to create a new string. Not doing so terminates the function and a t 
the same time makes string data disappear.  
Now, let's define a callback function that is called when an item is 
deleted. Add a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
gl_del_cb(void *data, Evas_Object *o bj) 
{ 
    item_data_s *id = data;  
    free(id);  
} 
└─────────────────────┘  
User data is passed to the first parameter. This is an item data structure, 
and as such is what you need to delete.  
  
Page 194 / 978 Build and run the example. A GenList is created, and 10 text items  are 
added.  
 
 
2) Displaying an Icon in the GenList Widget  
In this section, we are going to display an icon image to the right of an 
item. To do so, an image file is necessary. Copy the appendix's 
/Image/iu.png file to the /res folder of the source project.  
 
Then, create a callback function that adds an icon image to a GenList 
item. As shown below, add the following three functions to the 
create_base_gui() function.  

  
Page 195 / 978 ┌─────────────────────┐  
static void  
app_get_resource(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_resource_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
  
static Evas_Object*  
create_image(Evas_Object  *parent)  
{ 
    char img_path[PATH_MAX] = { 0, };  
    app_get_resource("iu.png", img_path, PATH_MAX);  
    Evas_Object *img = elm_image_add(parent);  
    elm_image_file_set(img, img_path, NULL);  
    return img;  
} 
  
static Evas_Object*  
gl_content_get_cb(void *data, Evas_Object *obj, const char *part)  
{ 
    Evas_Object *content = create_image(obj);  
    evas_object_size_hint_min_set(content, 50, 50);  
    evas_object_size_hint_max_set(content, 50, 50);  
    return content;  
} 
└─────────────────────┘  
app_get_resourc e() is a function that adds the path of the res folder to 
the name of a file and returns it.  
  
Page 196 / 978 app_get_resource_path() is an API that returns the absolute path of the 
res folder.  
create_image() is a function that creates an Image object to which an 
image fil e has been applied.  
elm_image_add() is an API that creates an Image object.  
elm_image_file_set() is an API that, by specifying the path of an image 
file for an Image object, loads the image.  
gl_content_get_cb() is a callback function that specifies an icon  image for 
a GenList item.  
evas_object_size_hint_min_set() is an API that specifies a hint for the 
minimum size of an object. In this case, we specified absolute value '50' 
as the hint.  
evas_object_size_hint_max_set() is an API that specifies a hint for th e 
maximum size of an object. In this case, we specified absolute value '50' 
as the hint.  
  
We are now going to assign the icon specifying callback function you 
just created to GenList items. Go to the create_base_gui() function and 
add a new line of code.  
┌─────────────────────┐  
    Elm_Genlist_Item_Class *itc = elm_genlist_item_class_new();  
    itc->item_style = "end_icon";  
  
Page 197 / 978     itc->func.text_get = gl_text_get_cb;  
    itc->func.del = gl_del_cb;  
    itc->func.content_get = gl_content_get_cb;  
└────────────── ───────┘  
Run the example again, and you will now see an icon displayed to the 
right of GenList items.  
 
 
3) Requesting the Index Number of a Selected Item  
In this section, we are going to implement a feature that, when the user 
selects an item, displays the index number of the item in a Label widget. 
Add one global variable and one function at the top of the source file.  
┌─────────────────────┐  
typedef struct item_data  
{ 
     int index;  
     Elm_Object_Item *item;  
} item_data_s;  
  

  
Page 198 / 978 appdata_s* m_ad = 0;  
  
static void  
list_item_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    item_data_s *id = data;  
    char buf[PATH_MAX];  
    sprintf(buf, "Item -%d", id ->index);  
    elm_object_text_set(m_ad ->label, buf);  
} 
└─────────────────────┘  
m_ad is a global  variable that stores appdata.  
list_item_clicked() is an item selection event callback function that 
displays the text of a given item in a Label widget. Item data is passed 
to the first parameter. The index property contains the index number of 
the item. We are going to change this index number into a string and 
display the string in the Label widget.  
Store appdata in the global variable. Add a new line of code at the 
beginning of the create_base_gui() function.  
┌─────────────────────┐  
create_base_gui(appd ata_s *ad)  
{ 
    m_ad = ad;  
└─────────────────────┘  
Now, we only need to define a callback function. Modify the code of the 
create_base_gui() function.   
  
Page 199 / 978 ┌─────────────────────┐  
    for(int i=0; i < 10 ; i++)  
    { 
        item_data_s *id = calloc(sizeof(item_data_s), 1);  
        id->index = i;  
        id->item = elm_genlist_item_append(genlist, itc, id, NULL, ELM_GENLIST_ITE
M_NONE, list_item_clicked, id);  
        //id->item = elm_genlist_item_append(genlist, itc, id, NULL, ELM_GENLIST_I
TEM_N ONE, NULL, id);  
    } 
└─────────────────────┘  
We specified the item selection event callback function as 
'list_item_clicked,' and  specified the GenList click event callback function 
as 'gl_selected_cb.'  
Run the example again. If you select an item, the ind ex number of the 
item is displayed in the Label widget.  
 
 
  

  
Page 200 / 978 4) Related APIs  
Evas_Object *elm_genlist_add(Evas_Object *parent): an API that adds a 
GenList widget. / parameters: parent object.  
Elm_Genlist_Item_Class *elm_genlist_item_class_new(void): an API  that 
creates an item class.  
Elm_Genlist_Item_Class: the class of a GenList item.  
  - item_style: the style of the item  
- func.text_get: item text specifying callback function  
- func.content_get: item icon specifying callback function  
- func.del: item dele ting event callback function  
Elm_Object_Item *elm_genlist_item_append(Evas_Object *obj, 
Elm_Genlist_Item_Class *itc, void *data, Elm_Object_Item *parent, 
Elm_Genlist_Item_Type type, Evas_Smart_Cb func, void *func_data): an API 
that adds items to a GenList.  When this function is called, the callback 
function entered for the func.text_get property is called automatically. / 
parameters: GenList object, item class, parent item, item type (fifth 
parameter), name of the item selection event callback function, and  user 
data. 
void elm_genlist_item_class_free(Elm_Genlist_Item_Class *itc): an API that 
deletes a GenList item class. / parameters: object of the GenList item 
class 
char *app_get_resource_path(void): an API that returns the absolute path 
of the res folder.  
  
Page 201 / 978 sprintf(char*, char*, ...) : an API that creates a format string.  
snprintf(char*, int, char*, ...) : an API that creates a format string with a 
specified length.  
Evas_Object *elm_image_add(Evas_Object *parent): an API that creates an 
Image object. / parame ters: parent object.  
Eina_Bool  elm_image_file_set(Evas_Object *obj, char *file, char *group): an 
API that specifies an image file for an Image object. / parameters: Image 
object, path of the image file, and the name of the image group (if the 
image file is  an Edje file).  
void evas_object_size_hint_min_set(Evas_Object *obj, Evas_Coord w, 
Evas_Coord h): an API that specifies a hint for the minimum size of an 
object. / parameters: object, width hint, and height hint.  
void evas_object_size_hint_max_set(Evas_Obj ect *obj, Evas_Coord w, 
Evas_Coord h): an API that specifies a hint for the maximum size of an 
object. / parameters: object, width hint, and height hint.  
strcmp(char*, char*): an API that compares the lengths of two strings. If 
the two strings turn out to have the same length, value 0 is returned.  
strdup(char*): an API that creates and returns another identical string.  
void elm_genlist_item_selected_set(Elm_Object_Item *it, Eina_Bool 
selected): an API that displays/removes the item checkmark. / 
parameters: List widget and whether to display the checkmark.  
  
  
Page 202 / 978 17. Creating a Complex Gallery Widget  
We are now going to learn how to create a complex widget by 
combining two or more widgets. In this example, we will create a Gallery 
widget using a GenGrid widget and a B g widget.  
 
1) Creating a GenGrid Widget & Adding an Image  
Create a new source project and specify the project name as 
'GengridGallery.'  
In this example, we are going to create a Gallery widget that displays 
images. Therefore, image files are needed Copy 10  image files, from 
0.jpg through 9.jpg, under the appendix's /Image folder to the /res 
folder of the source project.  
 
 

  
Page 203 / 978 Then, open the source file (~.c) under the src folder, add new variables 
to the appdata structure, and then define the new structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *gengrid;  
    Evas_Object *bg;  
} appdata_s;  
  
typedef struct itemdata {  
    int index;  
    const char *path;  
} itemdata_s;  
└─────────────────────┘  
We added GenGrid and Bg variables to the AppData structure.  
itemdata is a structure that stores GenGrid item information. Item 
information consists of index numbers and image file paths.  
 
We are now going to create a Gen Grid widget and add images. The 
method to do so is similar to the case of the GenList widget. Add a new 
function on top of the create_base_gui() function. This function adds a 
widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_ Object *box, Evas_Object *child,  
  
Page 204 / 978             double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium paddin g style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the ch ild */ 
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actuall y put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Go to the create_base_gui() function and add new code that creates a 
Box container, a GenGrid widget, and a Bg widget. Label will not be used 
in this example, so delete it.  
  
  
Page 205 / 978 ┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT _EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Gengrid */  
            ad->gengrid = create_gengrid(ad ->conform);  
            my_box_pack(box, ad ->gengrid, 1.0, 1.0, -1.0, -1.0); 
 
            /* Bg -1 Color */  
            ad->bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(ad ->bg, 66, 162, 206);  
            my_box_pack(box, ad ->bg, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
  
Page 206 / 978 create_gengrid() is a function that creates and then returns a GenGrid 
widget. We will crea te this widget in a short while.  
elm_bg_color_set() is a function that specifies a background color for a 
Bg widget. This feature is unnecessary in this example, but we used it 
nonetheless to identify the position of the Bg widget. Annotate it after 
the co mpletion of this example if you want to.  
We are now going to define a function that creates a GenGrid widget. 
Add a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static Evas_Object*  
create_gengrid(appdata_s *ad)  
{ 
    Elm_Gengrid_Item_Class *gic;  
    Evas_Object *gengrid;  
    char buf[PATH_MAX];  
  
    gengrid = elm_gengrid_add(ad ->conform ); 
    elm_gengrid_item_size_set(gengrid, ELM_SCALE_SIZE(60), ELM_SCALE_SIZE(60));  
    elm_gengrid_horizontal_set(gengrid, EINA_TR UE); 
  
    gic = elm_gengrid_item_class_new();  
    gic->func.content_get = gengrid_content_get_cb;  
  
    for(int i = 0; i < 10; i++) {  
        itemdata_s *id = calloc(sizeof(itemdata_s), 1);  
        snprintf(buf, sizeof(buf), "%s%d.jpg", app_get_resource_p ath(), i);  
        id->index = i;  
        id->path = strdup(buf);  
        elm_gengrid_item_append(gengrid, gic, id, NULL, id);  
    } 
  
    return gengrid;  
} 
└─────────────────────┘  
  
Page 207 / 978 elm_gengrid_add() is an API that creates a GenGrid widget.  
elm_gengrid_item _size_set() is an API that specifies the size of the icon 
item of a GenGrid widget.  
elm_gengrid_horizontal_set() is an API that sets/unsets the slide 
orientation to horizontal. The slide orientation is set to vertical by 
default.  
elm_gengrid_item_class_new() is an API that creates an item class for a 
GenGrid item.  
Elm_Gengrid_Item_Class is the item class of a GenList widget. The class 
types are as follows:  
 - func.content_get: assign the name of the callback function that 
specifies  the icon item.  
 - item_style: specify the item style. The default setting is "default".  
 - func.text_get: assign the name of the callback function that specifies 
the text item.  
 - func.del: assign the name of the item deleting event callback function. 
Data can be deleted using this function.  
app_get_resource_path() is an API that returns the absolute path of the 
/res folder.  
elm_gengrid_item_append() is an API that adds new items to a GenGrid. 
The parameters listed in order are: GenGrid object, item class,  item data 
structure, name of the item selection event callback function, and user 
data.  
  
Page 208 / 978 We are now going to define a function that adds icon images to a 
GenGrid item. Add a new function on top of the create_gengrid() 
function. This function is called aut omatically once a new item is created.  
┌─────────────────────┐  
static Evas_Object*  
gengrid_content_get_cb(void *data, Evas_Object *obj, const char *part)  
{ 
    itemdata_s *id = data;  
  
    if (!strcmp(part, "elm.swallow.icon")) {  
        Evas_Object *img = elm_image_add(obj);  
  
        elm_image_file_set(img, id ->path, NULL);  
        elm_image_aspect_fixed_set(img, EINA_FALSE);  
        evas_object_show(img);  
        return img;  
    } 
    return NULL;  
} 
└─────────────────────┘  
The first parameter of the fun ction above is the user data, and the 
second parameter is the item object.  The type of the element is passed 
to the third parameter.  
A GenGrid widget item consists of multiple elements, and you need to 
create icon images when the element type is "elm.swall ow.icon."  
elm_image_add() is an API that creates an image object.  
elm_image_file_set() is an API that, by specifying the path of an image 
file for an Image object, loads the image.  
  
Page 209 / 978 elm_image_aspect_fixed_set() is an API that specifies whether to crop the 
image. Passing EINA_TRUE to the second parameter lets the size of the 
image be reduced without any area cropped. Passing EINA_FALSE causes 
a cropped area in the image so that the image fills the whole item area. 
The default setting is EINA_TRUE.  
Build and r un the example. Ten icon images are displayed at the top of 
the screen. Drag the screen to the left and right. The image list is 
scrolled. The square shown below is the Bg widget.  
 
 
2) Displaying a Selected Icon in the Bg Widget  
In this section, we are going to implement a feature that, when the user 
selects an icon from a GenGrid, displays the image in a Bg widget.  
 

  
Page 210 / 978 Add a global variable at the top of the source file. This global variable 
stores appdata.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *gengrid;  
    Evas_Object *bg;  
} appdata_s;  
  
appdata_s* m_ad = 0;  
└─────────────────────┘  
Then, initialize the global variable at the beginnin g of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    m_ad = ad;  
└─────────────────────┘  
We are now going to create an event callback function for when the 
user selects a GenGrid item. Modify the cod e of the create_gengrid() 
function at the bottom as shown below. We specified the item selection 
event callback function as gengrid_it_cb.  
┌─────────────────────┐  
    for(int i = 0; i < 10; i++) {  
        itemdata_s *id = calloc(sizeof(itemdata_s), 1);  
  
Page 211 / 978         snprintf(buf, sizeof(buf), "%s%d.jpg", app_get_resource_path(), i);  
        id->index = i;  
        id->path = strdup(buf);  
        elm_gengrid_item_append(gengrid, gic, id, gengrid_it_cb, id);  
        //elm_gengrid_item_append(gengrid, gic, id, NUL L, id);  
    } 
  
    return gengrid;  
} 
└─────────────────────┘  
Add a new function on top of the create_gengrid() function. The function 
added is the item selection event callback function.  
┌─────────────────────┐  
static void  
gengrid_it_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    itemdata_s *id = data;  
    elm_bg_file_set(m_ad ->bg, id ->path, NULL);  
} 
└─────────────────────┘  
The first parameter of the function is the item data structure. The path 
property contains the path of the image file.  
elm_bg_file_set() is an API that specifies a background image file for a Bg 
widget.  
Run the example again and select an item icon. The matching image is 
displayed in the Bg widget.  
  
Page 212 / 978   
 
3) Related APIs  
Elm_Gengrid_Item_Class: the class of a GenGrid item. The class types are 
as follows:  
 - func.content_get: assign the name of the callback function that 
specifies the icon item.  
 - item_style: specify the item style. The default setting is "default".  
 - func.text_get: assign the name of the callback function that specifies 
the text item.  
 - func.del: assign the name of the item deleting event callback function. 
Data can be deleted using this function.  
Evas_Object*elm_gengrid_add(Evas_Object *parent): an API that creates a 
GenGrid widget. / parameters: parent object.  
  

  
Page 213 / 978 void elm_gengrid_item_size_set(Evas_Object *obj, Evas_Coord w, 
Evas_Coord h): an API that specifies the icon item size of a GenGrid. / 
parameters: GenGrid object, width, and height.  
void elm_gengrid_horizontal_set(Evas_Object *obj, Eina_Bool hori zontal): 
an API that sets/unsets the GenGrid slide orientation to horizontal. The 
slide orientation is set to vertical by default. / parameters: GenGrid 
object and EINA_TRUE or EINA_FALSE.  
Elm_Gengrid_Item_Class *elm_gengrid_item_class_new(void): an API th at 
creates a GenGrid item class.  
char *app_get_resource_path(void): an API that returns the absolute path 
of the /res folder.  
Elm_Object_Item *elm_gengrid_item_append(Evas_Object *obj, const 
Elm_Gengrid_Item_Class *gic, const void *data, Evas_Smart_Cb func , const 
void *func_data): an API that adds new items to a GenGrid. / parameters: 
GenGrid object, item class, item data structure, name of the item 
selection event callback function, and user data.  
Evas_Object *elm_image_add(Evas_Object *parent): an API tha t creates an 
image object.  
Eina_Bool elm_image_file_set(Evas_Object *obj, const char *file, const char 
*group): an API that, by specifying the path of an image file for an 
Image object, loads the image.  
  
  
Page 214 / 978 void elm_image_aspect_fixed_set(Evas_Object *obj, E ina_Bool fixed): an 
API that sets the image cropping property of an Image object. Passing 
EINA_TRUE to the second parameter lets the size of the image be 
reduced without any area cropped. Passing EINA_FALSE causes a 
cropped area in the image so that the im age can fill an image in the 
whole item area. The default setting is EINA_TRUE.  
  
  
Page 215 / 978 18. Creating a Simple Web Browser Using the 
WebView Widget  
To display web pages on the screen, you need to use the WebView 
widget. For a WebView widget to be created, it is neces sary to specify 
an Evas object as its parent. Evas is the canvas used in EFL. In this 
example, we are going to create a simple web browser example using 
the WebView widget.  
 
1) Creating a WebView Widget & Displaying a Web Page  
Create a new source project a nd specify the project name as 
'WebViewEx.'  
After the source project is created, open the source file (~.c) under the 
src folder and add new code at the top. This code declares a library 
header file and adds variables to the appdata structure.  
┌─────────── ──────────┐  
#include "webviewex.h"  
#include <EWebKit.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *entry;  
    Evas_Object *web_view;  
} appdata_s;  
└─────────────────────┘  
  
Page 216 / 978 Add a new function on top of the create_base_gui() function. This 
function adds a widget to a Table container.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
   evas_object_size_hint_align_set( child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
   evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
   elm_table_pack(table, child, x, y, w, h);  
   evas_object_show(child);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() fun ction and add new code. This code 
creates one Box container, one Table container, one Entry widget, three 
Button widgets, and one WebView widget. Conformant and Label are 
not necessary in this example, so we will annotate them.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_ HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);*/  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
  
Page 217 / 978 XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);  
    evas_object_show(ad ->label);*/  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_win_resize_object_add(ad ->win, box);  
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->win);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels mul tiplied by scale factor of UI */  
        elm_table_padding_set(table, 5 * elm_config_scale_get(), 10 * elm_config_
scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(table, EVAS_ HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_box_pack_end(box, table);  
        evas_object_show(table);  
 
        { 
            /* Entry */  
            ad->entry = elm_entry_add(ad ->win);  
            elm_entry_scrollable_set(ad ->entry, EINA_TRUE);  
            eext_entry_selection_back_event_allow_set(ad ->entry, EINA_TRUE);  
            elm_object_text_set(ad ->entry, "http://www.tizen.org");  
  
Page 218 / 978             my_table_pack(table, ad ->entry, 0, 0, 3, 1);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Prev");  
            evas_object_smart_callback _add(btn, "clicked", btn_prev_cb, ad);  
            my_table_pack(table, btn, 0, 1, 1, 1);  
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Go");  
            evas_object_smart_callback_add(btn, "cl icked", btn_go_cb, ad);  
            my_table_pack(table, btn, 1, 1, 1, 1);  
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Next");  
            evas_object_smart_callback_add(btn, "clicked", btn_next_cb, ad);  
            my_table_pack(table, btn, 2, 1, 1, 1);  
 
            /* WebView */  
            Evas *evas = evas_object_evas_get(ad ->win);  
            ad->web_view = ewk_view_add(evas) ; 
            ewk_view_url_set(ad ->web_view, elm_object_text_get(ad ->entry) );  
            my_table_pack(table, ad ->web_view, 0, 2, 3, 8);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
  
  
Page 219 / 978 We annotated Conformant and Label and created one Entry widget, 
three Button widgets, and one WebView widget.  
Passing ELM_WIN_INDICATOR_SHOW to the second parameter of the 
elm_win_indicator_mode_set() function displays an indicato r at the top of 
the screen, while passing ELM_WIN_INDICATOR_HIDE hides the indicator. 
Hiding the indicator is recommended for maximum use of space.  
evas_object_evas_get() is an API that creates an Evas object. Evas is a 
canvas on which images or shapes can  be drawn.  
ewk_view_add() is an API that creates a WebView widget. For a WebView 
widget to be created, it is necessary to specify an Evas object as its 
parent.  
ewk_view_url_set() is an API that specifies a URL path for a WebView 
widget. For the first param eter, specify the WebView widget object, and 
for the second parameter, specify a URL path. We passed the caption 
text of the Entry widget: http://www.tizen.org is the Tizen developer 
support website.  
Because we created three Buttons, three callback functio ns are needed. 
Add three new functions on top of the create_base_gui() function. We 
will define the content of the functions later.  
┌─────────────────────┐  
static void  
btn_go_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
  
  
Page 220 / 978 static void  
btn_prev_cb (void *data, Evas_Object *obj, void *event_info)  
{ 
} 
static void  
btn_next_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
└─────────────────────┘  
If you run the example in this status, web pages will not be displayed. 
This is because it is necessary  to support user privileges to enable the 
use of a network.  
Open the tizen -manifest.xml file under the root folder of the source 
project by double -clicking the file. You can see a number of Tab buttons 
at the bottom. Select Privileges from among them.  
Then, click the Add button and, when a popup  window appears, select 
http://tizen.org/privilege/internet from the list and click the OK button.  
  
Page 221 / 978  
Selecting tizen -manifest.xml from among the Tab buttons at the bottom 
displays source code.  
┌─────────────────────┐   
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org.tizen.
webviewex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org.tizen.webviewex" exec="webv iewex" multiple="false" no
display="false" taskmanage="true" type="capp">  
        <label>webviewex</label>  
        <icon>webviewex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/internet</privilege>  
    </privileges>  

  
Page 222 / 978 </manifest>  
└─────────────────────┘  
Now, this example is capable of network communications. Build and run 
the example. You will see the Tizen developer support website.  
 
 
2) Going to a Desired Website  
In this section, we are going to implement a feature that, when the user 
enters a URL address in an Entry widget and taps the Go button, directs 
the user to the URL address. Add new code to the Go button callback 
function.  
┌─────────────────────┐  
static void  
btn_go_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s* ad = data;  
    ewk_view_url_set(ad ->web_view, elm_object_text_get(ad ->entry) );  
} 
└─────────────────────┘  

  
Page 223 / 978 User data is passed to the first parameter of the callback function.  
The newly added code specifies the text enter ed in the Entry widget as a 
URL address for the WebView widget.  
Run the example again. Enter the address of your desired website in the 
Entry and tap the Go button. The web page is displayed in the WebView.  
 
 
3) Going to Prev/Next Pages  
In this section, we are going to implement a feature that directs the user 
to the previous page when the Prev button is tapped and directs the 
user to the next page when the Next button is tapped.  
Add new code to the btn_prev_cb() function.  
┌─────────────────────┐  
static void 
btn_prev_cb(void *data, Evas_Object *obj, void *event_info)  
{ 

  
Page 224 / 978     appdata_s* ad = data;  
    if( ewk_view_back_possible( ad ->web_view ) == EINA_TRUE )  
        ewk_view_back( ad ->web_view );  
} 
└─────────────────────┘  
ewk_view_back_possible() is an API t hat determines whether it is possible 
to go back to the previous screen.  
ewk_view_back() is an API that moves the app to the previous screen.  
Then, add new code to the btn_next_cb() function.  
┌─────────────────────┐  
static void  
btn_next_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s* ad = data;  
    if( ewk_view_forward_possible( ad ->web_view ) == EINA_TRUE )  
        ewk_view_forward( ad ->web_view );  
} 
└─────────────────────┘  
ewk_view_forward_possible() is an API that determines wheth er it is 
possible to go to the next screen.  
ewk_view_forward() is an API that moves the app to the next screen.  
Run the example again. Slide up the web page, and the link 
'DOWNLOAD THE SDK' will appear. Click the link. If this link is not 
shown, click any other link shown on the screen.  
  
  
Page 225 / 978 When a new page is shown, click the Prev button. You are switched to 
the original screen.  
This time, click the Next Button. The Download screen appears again.  
  
 
5) Related APIs  
Evas *evas_object_evas_get(const Evas_Object *obj): an API that creates 
an Evas object. Evas is a canvas on which images or shapes can be 
drawn.  
Evas_Object* ewk_view_add(Evas* e): an API that creates a WebView 
widget. For a WebView widget to be created, it is necessary to specify 
an Evas  object as its parent.  
Eina_Bool ewk_view_url_set(Evas_Object* o, const char* url): an API that 
specifies a URL path for a WebView widget. parameters: WebView widget 
object and URL path.  
  

  
Page 226 / 978 Eina_Bool ewk_view_back_possible(Evas_Object* o): an API that 
determines whether it is possible to go back to the previous screen.  
Eina_Bool ewk_view_back(Evas_Object* o): an API that moves to the 
previous screen.  
Eina_Bool ewk_view_forward_possible(Evas_Object* o): is an API that 
determines whether it is possible to  go to the next screen.  
Eina_Bool ewk_view_forward(Evas_Object* o): an API that moves to the 
next screen.  
  
  
Page 227 / 978 19. Implementing a Tab Screen with a  Layout 
Container  
Using the Tab screen, you can switch between screens easily. In this 
example, we are going to lear n how to implement a Tab screen using 
the Layout and Box containers.  
 
1) Creating a Layout Container & Placing Widgets  
Create a new source project and specify the project name as 'LayoutEx.'  
After the source project is created, open the source file (~.c) u nder the 
src folder and add new code at the top. This code adds variables to the 
appdata structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object * box1; 
    Evas_Obj ect *box2; 
} appdata_s;  
└─────────────────────┘  
In this example, we are going to implement the Tab screen. box1 
becomes a first Tab screen, and box2 becomes a second Tab screen.  
  
  
Page 228 / 978 Add a new function on top of the create_base_gui() function. This 
function a dds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the 
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center i n it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
  
Page 229 / 978 Then, go back to the create_base_gui() function and create a Box 
container, a Table container, and Button widgets. Annotate Conformant 
and Label.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN _INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);*/  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform ); 
    elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
    { 
        /* Main Box */  
        Evas_Object *box = create_box(ad ->win);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->win);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 5 * elm_config_scale_get(), 5 * elm_config_sc
ale_get());  
        /* Let the table child allocation area expand within in the box */  
  
Page 230 / 978         evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, 
EVAS_HINT_EXPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, 1.0);  
        elm_box_pack_end(box, table) ; 
        evas_object_show(table);  
 
        { 
            /* Tab Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Tab -1"); 
            evas_object_smart_callback_add(btn, "clicked", btn_tab1_cb, ad);  
            my_table_pack(table, btn, 0, 5, 1, 1);  
 
            /* Tab Button -2 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Tab -2"); 
            evas_object_smart_callback_add(btn, "clicked", btn_tab2_cb, ad);  
            my_table_pack(table, btn, 1, 5, 1, 1);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Table and added two Buttons to the Table. We used a Box 
to specify the distanc e between widgets.  
We are now going to create callback functions for the Buttons. Add two 
new functions on top of the create_base_gui() function. We will define 
the content of the functions later.   
  
Page 231 / 978 ┌─────────────────────┐  
static void  
btn_tab1_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
  
static void  
btn_tab2_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
└─────────────────────┘  
Build and run the example. You can see two Buttons at the bottom of 
the screen.  
 
 
  

  
Page 232 / 978 2) Creating a  Tab Screen  
We are now going to create two Tab screens. Add new code to the 
create_base_gui() function. This code creates two Layouts and two Boxes 
and adds widgets on top of them.  
┌─────────────────────┐  
            /* Tab Button -2 */ 
            btn = el m_button_add(ad ->win);  
            elm_object_text_set(btn, "Tab -2"); 
            evas_object_smart_callback_add(btn, "clicked", btn_tab2_cb, ad);  
            my_table_pack(table, btn, 1, 5, 1, 1);  
 
            /* Layout -1 */ 
            Evas_Object *layout1 = elm_layout_add(ad ->win);  
            elm_layout_theme_set(layout1, "layout", "drawer", "panel");  
            my_table_pack(table, layout1, 0, 0, 2, 5);  
 
            /* Box -1 */ 
            ad->box1 = create_box(layout1);  
            elm_win_resize_object_add(ad ->win, ad ->box1);  
 
            { 
                /* Label */  
                ad->label = elm_label_add(layout1);  
                elm_object_text_set(ad ->label, "Tab -1"); 
             my_box_pack(ad ->box1, ad ->label, 1.0, 0.0, -1.0, 0.5);  
            } 
 
            /* Layout -2 */ 
            Evas_Object *layout2 = elm_layout_add(ad ->win);  
            elm_layout_theme_set(layout2, "layout", "drawer", "panel");  
            my_table_pack(table, layout2, 0, 0, 2, 5);  
  
Page 233 / 978  
            /* Box -2 */ 
            ad->box2 = create_box(layout2);  
            elm_win_resize_object_add(ad ->win, ad ->box2);  
            evas_object_hide(ad ->box2);  
 
            { 
                /* Button */  
                btn = elm_button_add(layout2);  
                elm_object_text_set(btn, "Tab -2"); 
                my_box_pack(ad ->box2, btn, 1.0, 0.0, -1.0, 0.5);  
            } 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We crea ted two Layouts and added a Box on top of each Layout. The 
Layouts will act as Tab screens. We added a Label to the first Tab screen, 
and we added Buttons to the second Tab screen.  
elm_layout_add() is an API that creates a Layout container.  
elm_layout_them e_set() is an API that specifies a theme style for a 
Layout. To place a Window in a Layout, you need to specify the theme 
style of the Layout as 'panel.' To do so, pass the following parameter 
values:  
elm_layout_theme_set(layout, "layout", "drawer", "panel ") 
  
Page 234 / 978 evas_object_hide() is an API that hides a Window. It performs the 
opposite function of evas_object_show().  
We are now going to implement a feature that, when one of the two 
Buttons at the bottom of the screen, displays the matching Tab screen 
and hides the other. Add new code to the Button callback function.  
┌─────────────────────┐  
static void  
btn_tab1_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_show(ad ->box1); 
    evas_object_hide(ad ->box2); 
} 
  
static void 
btn_tab2_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    evas_object_hide(ad ->box1); 
    evas_object_show(ad ->box2); 
} 
└─────────────────────┘  
Tapping the first Button displays the first Layout and hides the second 
Layout.  
Tapping the second Button displays the second Layout and hides the 
first Layout.  
 
  
Page 235 / 978 Run the example again. Tapping a Button at the bottom of the screen 
displays the matching Tab screen.  
  
 
4) Related APIs  
Evas_Object *elm_layout_add(Evas_Object *pa rent): an API that creates a 
Layout container.  
Eina_Bool elm_layout_theme_set(Evas_Object *obj, const char *clas, const 
char *group, const char *style): an API that specifies a theme style for a 
Layout. To place a Window in a Layout, you need to specify th e theme 
style of the Layout as 'panel.'  
void evas_object_hide(Evas_Object *obj): an API that hides a Window. It 
performs the opposite function of evas_object_show().  
  

  
Page 236 / 978 20. Implementing a Header  and a Navigation Bar 
with a  Naviframe Widget  
To implement the Head er and Footer (Toolbar), you can use the 
Naviframe widget. In this example, we are going to learn how to display 
title text in a header and display a navigation bar in a footer.  
 
1) Creating a Header  
Create a new source project and specify the project name  as 
'NaviframeEx.' After the source project is created, open the source file 
(~.c) under the src folder and add new code at the top. This code adds 
variables to the appdata structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *nf;  
    Evas_Object *layout;  
    Elm_Object_Item *frame_item;  
    Evas_Object *toolbar;  
    Elm_Object_Item *btn1;  
    Elm_Object_Item *btn2;  
    Elm_Object_Item *btn3;  
} appdata_s;  
└─────────────────────┘  
  
  
Page 237 / 978 nf is the object of a Naviframe, and layout is the main container that will 
be added to a Naviframe.  
Elm_Object_Item is the item structure of a Naviframe.  
btn1-btn3 are Buttons that will be added to a navigation bar.  
Add a new fu nction on top of the create_base_gui() function. This 
function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_al ign) 
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addit ion to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the exp anded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set( frame, child);  
  
Page 238 / 978      } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, go to the create_base_gui() function and add new co de. This code 
creates a Naviframe, a Layout, and a Naviframe item.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_se t(ad->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Naviframe */  
        ad->nf = elm_naviframe_add(ad ->conform);  
        elm_object_part_content_set(ad ->conform, "elm.swallow.content", ad ->nf); 
        elm_object_content_set(ad ->conform, ad ->nf); 
 
        /* child object - indent to how relationship */  
        /* A box to put thin gs in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->conform);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->nf, box);  
        evas_object_show(box);  
  
Page 239 / 978         { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Press Toolbar Button");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
            /* Header */  
            ad->frame_item = elm_naviframe_item_push(ad ->nf, "Naviframe Ex", 
NULL, NULL, box, NULL);  
 
            /* Toolbar */  
            ad->toolbar = toolbar_add(ad, ad ->nf); 
            elm_object_item_part_content_set(ad ->frame_item, "toolbar", ad ->tool
bar); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We added a Naviframe on top of a Conformant, and we added a Box on 
top of the Naviframe.  
elm_naviframe_add() is an API that creates a Naviframe  object.  
evas_object_size_hint_weight_set() is an API that specifies a hint for the 
size of an object. The parameters listed in order are: object, horizontal 
size hint, and vertical size hint. EVAS_HINT_EXPAND is an option that 
specifies the size of an obj ect as large as possible.  
  
  
Page 240 / 978 evas_object_size_hint_align_set() specifies a hint for the alignment of an 
object. The parameters listed in order are: object, horizontal alignment 
hint, and vertical alignment hint. EVAS_HINT_FILL is an option that lets 
an obje ct fill as much space as possible in a given area.  
elm_naviframe_item_push() is an API that creates a Naviframe item. The 
parameters listed in order are: Naviframe object, title text, the object of 
the Button for moving to the previous item, the object of the Button for 
moving to the next item, content, and item style.  
Build and run the example. Title text is displayed in the Header.  
 
 
  

  
Page 241 / 978 2) Displaying a Toolbar in the Footer  
In this section, we are going to add a Footer to a Naviframe item and 
create three Tab buttons.  
Add a new function on top of the create_base_gui() function. This 
function creates and then returns a Toolbar.  
┌─────────────────────┐  
static Evas_Object *tool bar_add(appdata_s *ad, Evas_Object *parent)  
{ 
    Evas_Object *toolbar = elm_toolbar_add(parent);  
    evas_object_show(toolbar);  
  
    ad->btn1 = elm_toolbar_item_append(toolbar, NULL, "Left", on_btn1_cb, ad);  
    ad->btn2 = elm_toolbar_item_append(toolbar , NULL, "Center", on_btn2_cb, ad);  
    ad->btn3 = elm_toolbar_item_append(toolbar, NULL, "Right", on_btn3_cb, ad);  
    return toolbar;  
} 
└─────────────────────┘  
elm_toolbar_add() is an API that creates a Toolbar object.  
elm_toolbar_item_append() is an API that adds items to a Toolbar. The 
parameters listed in order are: Toolbar object, icon image, caption text, 
name of the Button click event callback function, and user data.  
Now, let's create callback functions for the Tab buttons. Add three new 
functions o n top of the toolbar_add() function. This code changes the 
text in a Label widget when the user taps a Tab button.  
  
  
Page 242 / 978 ┌─────────────────────┐  
static void on_btn1_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = (appdata_s*)data;  
    elm_object_text_set(ad ->label, "Button -1 Pressed");  
} 
  
static void on_btn2_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = (appdata_s*)data;  
    elm_object_text_set(ad ->label, "Button -2 Pressed");  
} 
  
static void on_btn3_cb(void * data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = (appdata_s*)data;  
    elm_object_text_set(ad ->label, "Button -3 Pressed");  
} 
└─────────────────────┘  
Now, we need to call the elm_toolbar_add() function to create a Toolbar. 
Add new code at the  end of the create_base_gui() function.  
┌─────────────────────┐  
        /* Header */  
        ad->frame_item = elm_naviframe_item_push(ad ->nf, "Naviframe Ex", NULL, N
ULL, box, NULL);  
 
        /* Toolbar */  
        ad->toolbar = toolbar_add(ad, ad ->nf); 
        elm_object_item_part_content_set(ad ->frame_item, "toolbar", ad ->toolbar);  
    } 
} 
└─────────────────────┘  
  
Page 243 / 978 We created a Toolbar by calling the toolbar_add() function. Next, specify 
the Toolbar as the content of the Naviframe item.  
elm_object_item_pa rt_content_set() is an API that specifies content for an 
object item. The parameters listed in order are: object item, content part 
name, and content object.  
Run the example again. You will now see a Footer at the bottom of the 
screen and three Buttons in the Footer. Clicking a Button changes the 
text in the Label widget. A checkmark appears below the selected 
Button.  
  
 
  

  
Page 244 / 978 3) Changing the Properties of the Toolbar  
The appearance of the screen is not good with the text placed at the 
top. So, we are going t o move text to the center and remove the 
checkmark.  
Add two new lines of code to the toolbar_add() function.  
┌─────────────────────┐  
static Evas_Object *toolbar_add(appdata_s *ad, Evas_Object *parent)  
{ 
    Evas_Object *toolbar = elm_toolbar_add(parent);  
    evas_object_show(toolbar);  
    elm_toolbar_select_mode_set(toolbar, ELM_OBJECT_SELECT_MODE_NONE);  
    elm_toolbar_transverse_expanded_set(toolbar, EINA_TRUE);  
  
    ad->btn1 = elm_toolbar_item_append(toolbar, NULL, "Left", on_btn1_cb, ad);  
    ad->btn2 = elm_toolbar_item_append(toolbar, NULL, "Center", on_btn2_cb, ad);  
    ad->btn3 = elm_toolbar_item_append(toolbar, NULL, "Right", on_btn3_cb, ad);  
    return toolbar;  
} 
└─────────────────────┘  
elm_toolbar_select_mode_set() is an API that specifies the sel ect mode of 
a Toolbar. Passing ELM_OBJECT_SELECT_MODE_NONE to the second 
parameter removes the checkmark. The default setting is 
ELM_OBJECT_SELECT_MODE_DEFAULT.  
elm_toolbar_transverse_expanded_set() is an API that specifies whether to 
expand the size of a Toolbar. Entering EINA_TRUE to the second 
parameter lets the Toolbar fill the entire area of the Footer, and as a 
result, text is displayed at the center.  
  
Page 245 / 978 Run the example again. The text of the Toolbar is displayed at the center, 
and tapping a Tab button d oes not display the checkmark.  
 
 
4) Related APIs  
Elm_Object_Item: the structure of an object item or a Naviframe item.  
Elm_Object_Item *elm_naviframe_item_push(Evas_Object *obj, char 
*title_label, Evas_Object *prev_btn, Evas_Object *next_btn, Evas_Object 
*content, char *item_style): an API that creates a Naviframe object. / 
parameters: Naviframe object, title text, the object of the Button for 
moving to the previous item, the object of the Button for moving to the 
next item, content, and item style.  
void e vas_object_size_hint_weight_set(Evas_Object *obj, double x, double 
y): an API that specifies a hint for the rough size of an object. / 

  
Page 246 / 978 parameters: object, horizontal size hint, and vertical size hint. 
EVAS_HINT_EXPAND is an option that specifies the size o f an object to 
be as large as possible.  
void evas_object_size_hint_align_set(Evas_Object *obj, double x, double 
y): an API that specifies a hint for the alignment of an object. / 
parameters: object, horizontal alignment hint, and vertical alignment 
hint. E VAS_HINT_FILL is an option that lets an object fill as much space 
as possible in a given area.  
Elm_Object_Item *elm_naviframe_item_push(Evas_Object *obj, char 
*title_label, Evas_Object *prev_btn, Evas_Object *next_btn, Evas_Object 
*content, char *item_styl e): an API that creates a Naviframe item. / 
parameters: Naviframe object, title text, the object of the Button for 
moving to the previous item, the object of the Button for moving to the 
next item, content, and item style.  
Evas_Object *elm_toolbar_add(Evas _Object *parent): an API that creates a 
Toolbar.  
Elm_Object_Item *elm_toolbar_item_append(Evas_Object *obj, char *icon, 
char *label, Evas_Smart_Cb func, void *data): an API that adds items to a 
Toolbar. / parameters: Toolbar object, icon image, caption tex t, name of 
the Button click event callback function, and user data.  
void elm_object_item_part_content_set(Elm_Object_Item *it, char *part, 
Evas_Object *content): an API that specifies content for an object item.  / 
parameters: object item, content part name , and content object.  
  
  
Page 247 / 978 void elm_toolbar_select_mode_set(Evas_Object *obj, 
Elm_Object_Select_Mode mode): an API that specifies the select mode of 
a Toolbar. / parameters: Toolbar object and select mode. The default 
select mode is ELM_OBJECT_SELECT_MODE_DEF AULT. Passing 
ELM_OBJECT_SELECT_MODE_NONE hides the checkmark.  
void elm_toolbar_transverse_expanded_set(Evas_Object *obj, Eina_Bool 
transverse_expanded): an API that specifies whether to expand the size 
of a Toolbar. / parameters: Toolbar object and whethe r to expand the 
size of the Toolbar. Entering EINA_TRUE lets the Toolbar fill the entire 
area of the Footer, and as a result, text is displayed at the center.  
  
  
Page 248 / 978 21. Placing Widgets in Sequence with the Box 
Container  
To enable support of various terminals with different resolutions, you can 
use relative coordinates when placing widgets. The Table container lets 
you specify coordinates for a widget based on the aspect ratio. On the 
other hand, the Box container is used to place widgets in sequence or 
place widget s using relative coordinates (left, right, and center, or top, 
bottom, and middle). This feature is similar to Android's LinearLayout. In 
this example, we are going to learn how to place widgets horizontally 
and vertically using the Box container.  
 
1) Creating a  Horizontal Box  
In this example, three Box containers and six Button widgets will be 
created. To make the source code simple, we are first going to create a 
function that creates Boxes and a function that creates Buttons.  
Create a new source project and specify the project name as 'BoxEx.' 
After the source project is created, open the source file (~.c) under the 
src folder and add two new functions on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static Evas_Object*  
create_box(Evas_Ob ject *parent)  
{ 
  
Page 249 / 978     Evas_Object *box = elm_box_add(parent);  
    evas_object_show(box);  
    return box;  
} 
  
static Evas_Object *  
create_button(Evas_Object *parent, char *text)  
{ 
    Evas_Object *button = elm_button_add(parent);  
    elm_object_text_set(butto n, text);  
    evas_object_show(button);  
    return button;  
} 
└─────────────────────┘  
create_box() is a function that creates and then returns a Box container.  
elm_box_add() is an API that creates a Box container.  
create_button() is a function that creates a Button widget, specifies 
caption text to it, and then returns the widget.  
We are now going to create two Boxes and three Buttons using the 
functions we just created and place them horizontally. Go back to the 
create_base_gui() function and add new code. Label will not be used in 
this example, so delete it.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
 
  
Page 250 / 978     evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relations hip */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = create_box(ad ->win);  
        elm_box_padding_set(box, 10, 10);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
 
        { /* child object - indent to how relationship */  
            /* Create horizontal box */  
            Evas_Object *horizontal_box = create_box(ad ->win);  
            elm_box_horizontal_set(horizontal_bo x, EINA_TRUE);  
            elm_box_padding_set(horizontal_box, 10, 10);  
            elm_box_pack_end(box, horizontal_box);  
 
            { /* child object - indent to how relationship */  
                Evas_Object *btn = create_button(horizontal_box, "Left "); 
                elm_box_pack_end(horizontal_box, btn);  
 
                btn = create_button(horizontal_box, "Mid");  
                evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0.0);  
                evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.0);  
                elm_box_pack_end(horizontal_box, btn);  
 
                btn = create_button(horizontal_box, "Right");  
                elm_box_pack_end(horizontal_box, btn);  
            } 
        } 
    } 
  
Page 251 / 978  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_box_padding_set() is an API that specifies the paddings of a Box 
container. The parameters listed in order are: container objec t, left & 
right paddings, and top & bottom paddings.  
evas_object_size_hint_weight_set() is an API that specifies a hint for the 
size of the space an object occupies. The parameters listed in order are: 
object, horizontal size hint, and vertical size hint. EVAS_HINT_EXPAND is 
an option that specifies the size of an object as large as possible.  
evas_object_size_hint_align_set() is an option that specifies a hint for the 
size of an object itself. The parameters listed in order are: object, 
horizontal size hint , and vertical size hint. EVAS_HINT_FILL is an option 
that specifies the size of an object as large as possible.  
elm_win_resize_object_add() is an API that specifies the size of an object 
as the same size as another object. We passed 'win' to the first 
parameter and 'main_box' to the second parameter. Doing so resizes the 
main_box so that it fills the whole area of the screen.  
elm_box_horizontal_set() is an API that specifies the alignment 
orientation of a Box. Passing EINA_TRUE to the second parameter sets  
the alignment to horizontal while passing EINA_FALSE sets the alignment 
to vertical. The default setting is vertical.  
elm_box_pack_end() is an API that adds a new object to a Box container. 
  
Page 252 / 978 If the alignment is horizontal, a new object will be added at the  right 
side of the screen. If the alignment is vertical, a new object will be 
added at the bottom of the screen.  
Build and run the example. Three Buttons are horizontally aligned at the 
center of the screen. Despite having specified the size of the second 
Button as maximum, the second Button is occupying the smallest 
possible space. This is because we did not specify the width of the Box 
container.  
 
  
  

  
Page 253 / 978 2) Maximizing the Size of an Object  
In this section, we are going to learn how to specify the width of a Box 
as maximum. Add new code to the create_base_gui() function's code that 
creates a second Button.  
┌─────────────────────┐  
    /* Create horizontal box */  
    Evas_Object *horizontal_box = create_box(ad ->win);  
    elm_box_horizontal_set(horizontal_box, EINA_TRUE);  
    elm_box_padding_set(horizontal_box, 10, 10);  
    evas_object_size_hint_weight_set(horizontal_box, EVAS_HINT_EXPAND, 0.0);  
    evas_object_size_hint_align_set( horizontal_box, EVAS_HINT_FILL, 0.0);  
    elm_box_pack_end(main_box, horizontal_box);  
└─────────────────────┘  
We passed EVAS_HINT_EXPAND to the second parameter of the 
evas_object_size_hint_weight_set() function so that the width of the 
Button is maximized . We specified 0.0 for the third parameter so that the 
height of the Button is minimized.  
However, this action alone will not change the width of the Button. 
evas_object_size_hint_weight_set() is a function that procures space, and 
evas_object_size_hint_al ign_set() is a function that specifies the alignment 
of content.  
  
  
Page 254 / 978 Enter a horizontal alignment type for the second parameter of the 
evas_object_size_hint_align_set() function: 0.0 indicates left alignment; 0.5 
indicates center alignment; 1.0 indicates ri ght alignment; and passing 
EVAS_HINT_FILL specifies the width of the content as maximum.  
Enter a vertical alignment value type for the third parameter. 0.0 
indicates top alignment; 0.5 indicates center alignment; 1.0 indicates 
bottom alignment; and passin g EVAS_HINT_FILL specifies the height of 
the content as maximum.  
Run the example again. You will now see the width of the second Button 
expanded.  
 
 
  

  
Page 255 / 978 3) Changing the Position of a Box  
Because the second Box is placed at the center of the screen, the 
Buttons are also placed at the center of the screen. The Box container 
places widgets in sequence. Therefore, adding a new Box to the first Box 
moves the second Box upward. Add new code at the bottom of the 
create_base_gui() function. This code creates a third Box and adds it to 
the first Box.  
┌─────────────────────┐  
                btn = create_button(horizontal_box, "Right");  
                elm_box_pack_end(horizontal_box, btn);  
            } 
 
            /* Create vertical box */  
            Evas_Object *ver tical_box = create_box(ad ->win);  
            elm_box_padding_set(vertical_box, 10, 10);  
            // Set area size  
            evas_object_size_hint_weight_set(vertical_box, EVAS_HINT_EXPAND, EV
AS_HINT_EXPAND);  
            evas_object_size_hint_align_set(vertical_box, EVAS_HINT_FILL, EVAS_HI
NT_FILL);  
            elm_box_pack_end(box, vertical_box);  
        } 
    } 
└─────────────────────┘  
The alignment of the first Box is vertical, and therefore the newly added 
Box will be placed below the second Box.  
  
  
Page 256 / 978 We procured the maximum possible space by passing 
EVAS_HINT_EXPAND to the evas_object_size_hint_weight_set() function, 
and we also specified the size of the content as maximum by passing 
EVAS_HINT_FILL to the evas_o bject_size_hint_align_set() function.  
Run the example again, and you will now see the Buttons have moved 
to the top of the screen.  
 
 
4) Aligning Widgets Vertically  
We are now going to add three Buttons to the third Box. Because we did 
not specify the alig nment of the Buttons, the Buttons will be aligned 
vertically. Add new code at the bottom of the create_base_gui() function.  
┌─────────────────────┐  
            /* Create vertical box */  

  
Page 257 / 978             Evas_Object *vertical_box = create_box(ad ->win);  
            elm_box_padding_set(vertical_box, 10, 10);  
            // Set area size  
            evas_object_size_hint_weight_set(vertical_box, EVAS_HINT_EXPAND, EVAS_
HINT_EXPAND);  
            evas_object_size_hint_align_set(vertical_box, EVAS_HINT_FILL, EVAS_HINT_ FI
LL); 
            elm_box_pack_end(box, vertical_box);  
 
            { /* child object - indent to how relationship */  
             Evas_Object *btn = create_button(vertical_box, "Top");  
                evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0.0);  
                evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.0);  
                elm_box_pack_end(vertical_box, btn);  
 
                btn = create_button(vertical_box,  "Center");  
                evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, EVAS_H
INT_EXPAND);  
                evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, EVAS_HINT_FI
LL); 
                elm_box_pack_end(vertical_box, btn);  
 
                btn = create_button(vertical_box, "Bottom");  
                evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0.0);  
                evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.0);  
                elm_box_pack_end(vertical_box, btn);  
            } 
        } 
    } 
└─────────────────────┘  
We specified the widths and heights of the first and third Buttons as 
minimum.  
  
Page 258 / 978 We specified the width and height of the second Button as maximum.  
Run the example again. You will now see the newly added th ree Buttons 
aligned vertically.  
 
 
5) Related APIs  
Evas_Object *elm_box_add(Evas_Object *parent): an API that creates a 
Box container.  
void elm_box_padding_set(Evas_Object *obj, Evas_Coord horizontal, 
Evas_Coord vertical): an API that specifies paddings. /  parameters: 
container object, left & right paddings, and top & bottom paddings.  
void evas_object_size_hint_weight_set(Evas_Object *obj, double x, double 
y): an API that specifies a hint for the size of the space an object 

  
Page 259 / 978 occupies. / parameters: object, h orizontal size hint, and vertical size hint. 
EVAS_HINT_EXPAND is an option that specifies the size of an object as 
large as possible.  
void evas_object_size_hint_align_set(Evas_Object *obj, double x, double 
y): an API that specifies a hint for the size of a n object. / parameters: 
object, horizontal size hint, and vertical size hint. EVAS_HINT_FILL is an 
option that specifies the size of an object as large as possible.  
void elm_win_resize_object_add(Evas_Object *obj, Evas_Object *subobj): 
an API that specifies the size of an object as the same size as another 
object. / parameters: Window object and object whose size will be 
changed.  
void elm_box_horizontal_set(Evas_Object *obj, Eina_Bool horizontal): an 
API that specifies the orientation of a Box. / pa rameters: object and 
orientation.  Passing EINA_TRUE sets the orientation of the Box to 
horizontal while passing EINA_FALSE sets the orientation of the Box to 
vertical. The default setting is vertical.  
void elm_box_pack_end(Evas_Object *obj, Evas_Object *su bobj): an API 
that adds a new object to a Box container. If the alignment is horizontal, 
a new object will be added at the right side of the screen. If the 
alignment is vertical, a new object will be added at the bottom of the 
screen. / parameters: Box obj ect and content object.  
  
  
Page 260 / 978 22. Creating a Sub Page with a  Scroller Widget  
When you develop a commercial app, you need to create multiple 
pages. You can use the following methods to implement multiple pages.  
 - With the use of a Toolbar and a number of layouts,  making it so that 
the matching layout can be shown/hidden when a Tab button is tapped.  
- Moving a layout with Scroller widget.  
In this example, we are going to learn how to move between pages 
using the Scroller widget. We are also going to create a source  file 
relevant to a second page.  
 
1) UI Task for the Main Page  
In this section, by using the Naviframe widget, we are going to display a 
header on the main page and add one Button to the main page.  
Create a new source project and specify the project name a s 'Multipage.' 
After the source project is created, open the source file (~.c) under the 
src folder and add a new variable to the appdata structure. This variable 
is for the Naviframe object that displays the title.  
┌─────────────────────┐  
typedef struct a ppdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *nf;  
    Evas_Object *label;  
} appdata_s;  
└─────────────────────┘  
  
Page 261 / 978 Add a new function on top of the create_base_gui() function. This 
function adds a widget to a Box container.  
┌─────── ──────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_m edium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, E VAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, f rame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
  
Page 262 / 978 Then, go to the create_base_gui() function and modify the code as 
shown below. This code creates a Naviframe, Box, Label, Button, and 
Header.  
┌─────────────────────┐  
    //eext_object_event_callback_add(ad ->win, EEXT_CALLBACK_BACK, win_back_c
b, ad);  
 
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Naviframe */  
        ad->nf = e lm_naviframe_add(ad ->conform);  
        elm_object_part_content_set(ad ->conform, "elm.swallow.content", ad ->nf); 
        elm_object_content_set(ad ->conform, ad ->nf); 
 
        Evas_Object *box = elm_box_add(ad ->nf); 
        elm_box_padding_set(box, 10 * elm_ config_scale_get(), 10 * elm_config_sc
ale_get());  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->nf, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
  
Page 263 / 978             ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "Press Button");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
            /* Button */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Sub Window");  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, 0.0);  
 
            /* Header */  
            Elm_Object_Item *nf_it;  
            nf_it = elm_naviframe_item_push(ad ->nf, "Main Window", NULL, NUL
L, box, NU LL); 
            eext_object_event_callback_add(ad ->nf, EEXT_CALLBACK_BACK, eext_n
aviframe_back_cb, NULL);  
            elm_naviframe_item_pop_cb_set(nf_it, naviframe_pop_cb, ad ->win);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
The code below terminates the app when the Back button is tapped. The 
problem is that the app also gets terminated even when the Back button 
is tapped on the sub page. For this reason, we will annotate this co de 
for now.  
eext_object_event_callback_add(ad ->win, EEXT_CALLBACK_BACK, 
win_back_cb, ad);  
The code below moves the app back to the main page when the Back 
button is tapped on the sub page.  
  
Page 264 / 978 eext_object_event_callback_add(ad ->nf, EEXT_CALLBACK_BACK, 
eext_nav iframe_back_cb, NULL);  
We also need a feature that terminates the app when the Back button is 
tapped on the main page. This is because we annotated the code that 
calls the win_back_cb callback function. For this reason, we will add the 
code shown below. Th e naviframe_pop_cb function is called when the 
Back button is tapped on the main page.  
elm_naviframe_item_pop_cb_set(nf_it, naviframe_pop_cb, ad ->win);  
Now, let's create the naviframe_pop_cb callback function. Add a new 
function on top of the create_base_g ui() function.  
┌─────────────────────┐  
static Eina_Bool  
naviframe_pop_cb(void *data, Elm_Object_Item *it)  
{ 
    ui_app_exit();  
    return EINA_FALSE;  
} 
└─────────────────────┘  
The function above is called when the Back button is tapped on the 
main page.  
ui_app_exit() is an function that terminates the app.  
Build and run the example. You can see a Header, Label, and Button.  
  
Page 265 / 978  
 
2) Creating a  Sub Page  
In this section, we are going to implement a feature that makes the sub 
page appear when a Button is tapped.  It does not matter if you add sub 
page-creating code to the main source file (multipage.c). However, as the 
code gets longer, it becomes more difficult to manage. In addition, using 
multiple source files also makes it more convenient to use the features 
when you develop a different app later.  
We are now going to create a new source file. Right -click the /src folder 
and select [New > File] in the shortcut menu.  
 
When a popup  window appears, enter 'sub_view.c' in the file name field 
and click the Finish but ton. A new source file will then be created under 
the /src folder.  

  
Page 266 / 978  
Double -click the newly created source file (sub_view.c) and open it in 
Edit mode.  We are now going to add code that creates a sub page and 
icon Button.  
┌─────────────────────┐  
#include "m ultipage.h"  
  
static Evas_Object*  
create_button_view(Evas_Object *parent)  
{ 
    Evas_Object *btn, *img, *box;  
  
    box = elm_box_add(parent);  
    evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    evas_object_size_hint_align_se t(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  

  
Page 267 / 978      /* icon_reorder style */  
    btn = elm_button_add(box);  
    elm_object_style_set(btn, "icon_reorder");  
    evas_object_show(btn);  
    elm_box_pack_end(box, btn);  
  
    return box;  
} 
  
void 
sub_view_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    Evas_Object *scroller, *layout;  
    Evas_Object *nf = data;  
  
    scroller = elm_scroller_add(nf);  
    layout = create_button_view(scroller);  
    elm_object_content_set(scroller, layout);  
  
    elm_naviframe _item_push(nf, "Sub Window", NULL, NULL, scroller, NULL);  
} 
└─────────────────────┘  
Because the sub page needs to be linked to the first page, we will declare 
the main header file (multipage.h).  
create_button_view() is a function that creates a Box contain er and adds a 
Button widget on top of the Box container.  
sub_view_cb() is a function that displays a second page by creating a 
Scroller and Layout.  
elm_scroller_add() is an API that creates a new Scroller.  
  
Page 268 / 978 elm_object_content_set() is an API that specifies the content of a container. 
Passing a Scroller to the first parameter and passing a layout to the second 
parameter displays the layout on the screen.  
Change the title text of the Header and specify the Scroller as the content 
of the Naviframe by using the elm_naviframe_item_push() function.  
The sub_view_cb() function needs to be called when the Button on the 
first page is tapped. To that end, we must declare a function in the header 
file. Open the /inc folder, and double -click the 'multipage.h' file. When t he 
file is open, declare the sub page creating function at the bottom of the 
file. 
┌─────────────────────┐  
#if !defined(PACKAGE)  
#define PACKAGE "org.tizen.multipage"  
#endif  
  
void sub_view_cb(void *data, Evas_Object *obj, void *event_info);  
  
#endif /* __multipage_H__ */  
└─────────────────────┘  
The function can now be called on the main page. Go to the Multipage.c 
file and add a new line of code to the Button -creating code of the 
create_base_gui() function. This new code calls the sub page -creating 
function when the Button on the main page is tapped.  
┌─────────────────────┐  
            /* Button */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Sub Window");  
  
Page 269 / 978             evas_object_smart_callback_add(btn,  "clicked", sub_view_cb, ad ->nf); 
            my_box_pack(box, btn, 1.0, 0.0, -1.0, 0.0);  
└─────────────────────┘  
Run the example again. When you tap the Button on the screen, the sub 
page appears, and you can see an icon Button at the center of the screen . 
To go back to the main page, tap the Back button.  
  
 
3) Moving to the Main Page with a Tap of a Button  
In this section, we are going to implement a feature that moves the app 
to the main page when the Button on the sub page is tapped. To do so, 
we need  to call the elm_naviframe_item_pop() function.  
Go to the sub_view_cb() function of the sub_view.c file and modify the 
code. Pass the Naviframe to the create_button_view() function, and  
┌─────────────────────┐  
    scroller = elm_scroller_add(nf);  
    layout = create_button_view(scroller, nf);  
    //layout = create_button_view(scroller);  
    elm_object_content_set(scroller, layout);  
  
    elm_naviframe_item_push(nf, "Sub Window", NULL, NULL, scroller, NULL);  

  
Page 270 / 978 } 
└─────────────────────┘  
 then add new c ode to the create_button_view() function.  
┌─────────────────────┐  
static Evas_Object*  
create_button_view(Evas_Object *parent, Evas_Object *nf)  
{ 
    Evas_Object *btn, *img, *box;  
  
    box = elm_box_add(parent);  
    evas_object_size_hint_weight_set(box, E VAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
  
    /* icon_reorder style */  
    btn = elm_button_add(box);  
    elm_object_style_set(btn, "icon_reorder");  
    evas_object_smart_callback_add(bt n, "clicked", btn_back_cb, nf);  
    evas_object_show(btn);  
    ~ 
└─────────────────────┘  
The NaviFrame object is passed to the function's parameter.  We specified 
the Button callback function as btn_back_cb and passed the Naviframe 
to user data.  
Lastly, add  the Button callback function on top of the 
create_button_view() function.  
┌─────────────────────┐  
void 
btn_back_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
  
Page 271 / 978     Evas_Object *nf = data;  
    elm_naviframe_item_pop(nf);  
} 
└─────────────────────┘  
elm_naviframe_item_pop() is the command for moving to the top of the 
list of pages accumulated in the stack of a Naviframe. In other words, it is 
the command for moving to the main page.  
Run the example again, go to the sub page, and tap the icon Button. Y ou 
are taken to the main page.  
Tapping the Back button on the sub page directs you to the main page 
while tapping the Back button on the main page makes the app screen 
disappear. It does not mean that the app has been closed; it means the 
app has been swit ched to Background mode.  
 
4) Related APIs  
eext_object_event_callback_add(ad ->win, EEXT_CALLBACK_BACK, 
win_back_cb, ad): code that terminates the app when the Back button is 
tapped. You must annotate this code in order for the app not to be 
terminated when the Back button is tapped on the sub page.  
eext_object_event_callback_add(ad ->nf, EEXT_CALLBACK_BACK, 
eext_naviframe_back_cb, NULL): code that moves the app back to the 
main page when the Back button is tapped on the sub page.  
 
  
Page 272 / 978 elm_naviframe_item_pop_cb_se t(nf_it, naviframe_pop_cb, ad ->win): code 
that specifies the callback function for when the Back button is tapped on 
the main page as naviframe_pop_cb.  
ui_app_exit(): an API that terminates the app.  
Evas_Object *elm_naviframe_add(Evas_Object *parent): an A PI that creates 
a new Scroller.  
void elm_object_content_set(Evas_Object *obj, Evas_Object *content): an 
API that specifies content for a container. / parameters: container object 
and content object.  
Elm_Object_Item *elm_naviframe_item_push(Evas_Object *obj , const char 
*title_label, Evas_Object *prev_btn, Evas_Object *next_btn, Evas_Object 
*content, const char *item_style): an API that specifies the Header title text 
and content of a Naviframe. / parameters: Naviframe object, title text, the 
object of the Bu tton for moving to the previous item, the object of the 
Button for moving to the next item, content, and user data  
Evas_Object *elm_naviframe_item_pop(Evas_Object *obj): an API for 
moving to the top of the list of pages accumulated in the stack of a 
Navifr ame. / parameters: the Naviframe object.  
  
  
Page 273 / 978 23. Using Strings  
String conversion or string search is a feature frequently used when 
developing an app. In this example, we are going to learn how to find the 
position of a string and convert strings into numbers by  using basic APIs 
written in C.  
 
1) Copying a String  
Create a new source project and specify the project name as 'StringEx.' 
After the source project is created, add new code by opening the source 
file (~.c) under the src folder and going to the create_bas e_gui() function.  
┌─────────────────────┐  
    /* Label*/  
    ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_object_conten t_set(ad ->conform, ad ->label);  
    elm_label_line_wrap_set(ad ->label, EINA_TRUE);  
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_string_result(ad ->label);  
└─────────────────────┘  
  
  
Page 274 / 978 elm_label_line_wrap_set() is an  API that specifies automatic line wrapping 
for a Label widget.  
show_string_result() is a function that displays the result of a string 
conversion. Now, let's start building the example.  
Add a new function on top of the create_base_gui() function.  
┌─────── ──────────────┐  
static void  
show_string_result(Evas_Object *label)  
{ 
    char buf[PATH_MAX], str1[100];  
    char *str2;  
    strcpy(str1, "12345");  
    sprintf(buf, "[%s]", str1);  
  
    elm_object_text_set(label, buf);  
} 
└─────────────────────┘  
strcpy() is an API that copies a string. The first parameter indicates the 
address of the memory where the string gets stored, while the second 
parameter indicates data about the original string. In this case, we enter 
the text '12345' in a string variable called 'str 1.' 
sprintf() is an API that creates a new string of a specific format type. The 
first parameter indicates the address of the memory where the string get 
stored, the second parameter indicates the format type, and the third 
parameter and later parameters i ndicate data to be assigned to the format.  
  
  
Page 275 / 978 Build and run the example. We outputted the original string enclosed in 
square brackets.  
 
 
2) Requesting the Length of a String  
In this section, we are going to request the length of a string stored in 
the str1  variable. Add new code at the end of the show_string_result() 
function.  
┌─────────────────────┐  
   strcpy(str1, "12345");   
   sprintf(buf, "[%s]", str1);  
  
    int length = strlen(str1);  
    sprintf(buf, "%s<br>Length : %d", buf, length);  
  
    elm_object _text_set(label, buf);  
└─────────────────────┘  
strlen() is an API that requests and then returns the length of a string. str1 
is a char array, so it has a fixed length. In such cases, the length from the 
beginning of the string to before the End symbol (\0) will be returned.  
Run the example again. The length of the string is displayed.  
  

  
Page 276 / 978 3) Extracting a Specific Length of Characters from the Beginning of a 
String  
In this section, we are going to extract the first three characters from the 
str1 variable.  Add new code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>Length : %d", buf, length);  
  
    str2 = eina_stringshare_add_length(str1, 3);  
    sprintf(buf, "%s<br>Front 3 : %s", buf, str2);  
  
    elm_objec t_text_set(label, buf);  
└─────────────────────┘  
eina_stringshare_add_length() is an API that extracts a specific length of 
characters from the beginning of a string. The first parameter indicates 
data about the original string, while the second parameter i ndicates the 
length to be extracted. The extracted string will be returned.  
Run the example again. The characters '123' are extracted from the 
beginning of the string '12345.'  
 
 
  

  
Page 277 / 978 4) Extracting a Specific Part of a String  
In this section, we are going to learn how to extract a certain length of 
characters from a string by specifying the starting point of extraction. Add 
new code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>Front 3 : %s", buf, str2);  
  
    str2 = eina_stringshare_add_length(str1 + 2, 3);  
    sprintf(buf, "%s<br>substr 3 : %s", buf, str2);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
We passed 'str1 + 2' to the first parameter of the 
eina_stringshare_add_length() functio n. Doing so eventually passes the 
characters '345.'  
Run the example again. Three characters are extracted from the string 
'12345,' beginning from the third character position.  
 
 
  

  
Page 278 / 978 5) Converting a String into a Numeric Value  
To convert a string into a number, you can use the atoi() function. Add 
new code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>substr 3 : %s", buf, str2);  
  
    int i = atoi(str1);  
    sprintf(buf, "%s<br>string to int '%s' + 3 =  %d", buf, str1, i + 3);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
atoi() is an API that converts a string into the int type.  
atol() is an API that converts a string into the long type.  
atof is an API that coverts a string into the float type.  
Run the example again. The string '12345' is converted into a number, and 
the result of adding 3 to the number is displayed on the screen.  
 
  
  

  
Page 279 / 978 6) Converting a Number into a String  
To convert a nu mber into a string, you can use the sprintf() function. Add 
new code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>string to int '%s' : %d", buf, str1, i);  
  
    char str3[100];  
    i = 6789;  
    sprintf(s tr3, "%d", i);  
    sprintf(buf, "%s<br>int to string %d : '%s'", buf, i, str3);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
The following are symbols commonly used in string -type format 
statements:  
- %s: replace with a string.  
- %d: repl ace with a number such as an int or a long.  
- %c: replace with one character.  
- %f: replace with a real number such as a float or a double.  
Run the example again. The number '6789' is converted into a string.  
 
  

  
Page 280 / 978 7) Combining Strings  
In this section, we are going to learn how to combine two strings into one. 
Add new code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>int to string %d : '%s'", buf, i, str3);  
  
    strcat(str1, str3);  
    sprintf(buf, "%s<br >add '%s' : %s", buf, str3, str1);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
strcat() is a function that combines two strings. This function appends a 
second string to the end of the first parameter. It is not that a new string 
is crea ted but that a new string is appended to an existing string.  
Run the example again. '6789' is added to '12345' to make '123456789.'  
 
 
  

  
Page 281 / 978 8) Finding the Position of a String  
In this section, we are going to learn how to find the position of a string. 
Add ne w code at the end of the show_string_result() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>add '%s' : %s", buf, str3, str1);  
  
    str1[0] = ' \0'; 
    str3[0] = ' \0'; 
  
    strcpy(str1, "This is a simple string");  
    sprintf(buf, "%s<br><br> [%s]", buf, str1);  
  
    elm_object_text_set(label, buf);  
    str2 = strstr( str1, "simple" );  
    sprintf(buf, "%s<br>search  'simple' : %s", buf, str2);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
'\0' is the End symbol that indicates the end of a string. Entering this 
symbol in the first character of a char array initializes the string as a blank.  
strstr() is an API that finds the position of a certain string contained in a 
string. This function does not return the index number; it ret urns the 
pointer where the string starts. In other words, it returns a string.  
To find the starting position of a certain char in a string, you can use the 
strchr(char*, int) function.  
  
  
Page 282 / 978 Run the example again. The string that comes after the starting posit ion 
of the string 'simple' is displayed.  
 
 
9) Copying a Specific Length of a String  
In this section, we are going to change the string 'simple' into 'sample.' To 
do so, we need to use the strncpy() function. Add new code at the end of 
the show_string_resu lt() function.  
┌─────────────────────┐  
    sprintf(buf, "%s<br>search  'simple' : %s", buf, str2);  
  
    strncpy( str2, "sample", 6 );  
    sprintf(buf, "%s<br>change  'simple' to 'sample' : %s", buf, str1);  
  
    elm_object_text_set(label, buf);  
└─────────────────────┘  
strncpy() is a function that copies a specific length of a string. str2 indicates 
the position where the string 'simple' starts. Therefore, 'simple' is 
eventually changed into 'sample.'  
Run the example again. You will now see 'simpl e' is changed into 'sample.'  

  
Page 283 / 978  
 
10) Related APIs  
char *strcpy (char *dest, char *src): an API that copies a string. / parameters: 
address of the memory where the string gets stored and data about the 
original string.  
int sprintf (char *s, char *format, ... ) : an API that creates a new string of a 
specific format type. / parameters: the address of the memory where the 
string get stored, format type, and, from the third parameter on, data to 
be assigned to the format.  
size_t strlen (char *s): an API that requ ests and then returns the length of 
a string. In string type format statements, %s is a symbol replaced by a 
string. %d is a symbol replaced by a number such as int or long. %c is a 
symbol replaced by a character. %f is a symbol replaced by a real number 
such as float or double.  
Eina_Stringshare *eina_stringshare_add_length(const char *str, unsigned int 
slen): an API that extracts a specific length of characters from the 
beginning of a string. / parameters: data about the original string and the 
length to b e extracted. / return: extracted string.  

  
Page 284 / 978 int atoi (char *nptr): an API that converts a string into the int type.  
long int atol (char *nptr): an API that converts a string into the long type.  
double atof (char *nptr): an API that converts a string into th e float type.  
char *strcat (char *__dest, char *__src): an API that combines two strings. 
This function appends a second string to the end of the first string. In this 
case, a new string is not created, but appended to an existing string.  
char *strstr (ch ar *haystack, char *needle): an API that finds the position 
of a certain string contained in a string. This function does not return the 
index number; it returns the pointer to where the string starts. Therefore, 
it returns a string.  
char *strchr (char *s,  int c): an API that searches the starting position of a 
certain character in a string.  
char *strncpy (char *dest,  char *src, size_t n): an API that copies a specific 
length of a string.  
 
  
  
Page 285 / 978 24. The String Structure 'Eina_Strbuf'  
Sometimes you feel like you’ve hit a dead end while handling strings using 
APIs written in C. EFL provides a string structure called ‘Eina_Strbuf.’ In this 
example, we are going to learn how to delete part of a string, change a 
string into a different string, and insert a new string int o the middle of an 
existing string.  
1) Entering a String in Eina_Strbuf  
Create a new source project and specify the project name as 'EinaStrbufEx.' 
After the source project is created, open the source file (~.c) under the src 
folder, move to the create_base_gui() function and add new code.  
┌─────────────────────┐  
    /* Label*/  
    ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXP AN
D); 
    elm_object_content_set(ad ->conform, ad ->label);  
    elm_label_line_wrap_set(ad ->label, EINA_TRUE);  
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_eina_strbuf_result(ad ->label);  
└─────────────────────┘  
elm_label_line_wrap_set() is an API that specifies automatic line wrapping 
for a Label widget.  
  
Page 286 / 978 show_eina_strbuf_result() is a function that displays the result of using 
Eina_Strbuf on the screen. Now, let's start building the example.  
Create a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
show_eina_strbuf_result(Evas_Object *label)  
{ 
    Eina_Strbuf *strline, *strbuf;  
    /* Create Eina_Strbuf */  
    strbuf = eina_strbuf_new();  
    /* Addend string */  
    eina_str buf_append(strbuf, "Hello Tizen");  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
    /* Free memory */  
    eina_strbuf_free(strbuf);  
} 
└─────────────────────┘  
eina_strbuf_new() is an API that creates a new Eina_Strbuf object.  
eina_strbuf_append() is an API that adds a string to Eina_Strbuf.  
eina_strbuf_string_get() is an API that requests the string stored in 
Eina_Strbuf.  
eina_strbuf_free() is an API that deletes the data stored in Eina_Strbuf.  
Build and run the example.  
  
Page 287 / 978  
2) Adding a String in a Specified Format  
To add a new string in a specified format, you need to use the 
eina_strbuf_append_printf() function. Add new code in the middle of the 
show_eina_strbuf_result() function.  
┌─────────────────────┐  
    eina_strbuf_append(s trbuf, "Hello Tizen");  
  
    /* Reset string */  
    strline = eina_strbuf_new();  
    eina_strbuf_append(strline, "Append string");  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    elm_object_text_set(label, eina_strb uf_string_get(strbuf));  
    /* Free memory */  
    eina_strbuf_free(strline);  
    eina_strbuf_free(strbuf);  
└─────────────────────┘  
We created a new Eina_Strbuf object using the eina_strbuf_new() function 
and entered a string using the eina_strbuf_append() function.  
eina_strbuf_append_printf() is an API that adds a new string by specifying 
a format statement. The first parameter indicates the Eina_Strbuf object, 
the second parameter indicates the format type, and the third parameter 
and later parameters indicate data to be assigned to the format.  
Run the example again. Two lines of a string are displayed.  

  
Page 288 / 978  
3) Requesting the Length of a String  
To request the length of a string stored in Eina_Strbuf, you need to use 
the eina_strbuf_length_get() function. A dd new code at the end of the 
show_eina_strbuf_result() function.  
┌─────────────────────┐  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    /* Length of string */  
    eina_strbuf_append_printf(strbuf, "<br>Length : %d ",  
            eina_strbuf_length_get(strline) );  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
└─────────────────────┘  
eina_strbuf_length_get() is an API that returns the length of a string stored 
in Eina_Strbuf.  
Run the example again . The length of the string ‘Append string,’ 13, is 
displayed.  
 
 
 

  
Page 289 / 978 4) Deleting Part of a String  
To delete part of a string, you need to use the eina_strbuf_remove() 
function. Add new code at the end of the show_eina_strbuf_result() 
function.  
┌────────────── ───────┐  
    eina_strbuf_append_printf(strbuf, "<br>Length : %d", eina_strbuf_length_get(strline)
 ); 
  
    /* Remove part of string */  
    eina_strbuf_remove(strline, 3, 6);  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
└─────────────────────┘  
eina_strbuf_remove() is an API that removes only part of a string. The first 
parameter indicates the Eina_Strbuf object, the second parameter indicates 
the start position of removal, and the third parameter indicates the end 
position of removal. For example, entering ‘6’ deletes all characters up to 
the sixth.  
Run the example again. Index numbers 3 to 5 (the fourth to sixth 
characters) are deleted.  
 
 

  
Page 290 / 978 5) Replacing  a String  
To replace a string with another string, you need to use the 
eina_strbuf_replace() function. Add new code at the end of the 
show_eina_strbuf_result() function.  
┌─────────────────────┐  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_st ring_get(strline) );  
  
    /* Replace string */  
    eina_strbuf_reset(strline);  
    eina_strbuf_append(strline, "I () () the ()");  
    eina_strbuf_replace(strline, "()", "can", 1);  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
└─────────────────────┘  
eina_strbuf_reset() is an API that resets the string stored in Eina_Strbuf.  
eina_strbuf_replace() is a function that changes a stri ng into a different 
string. The first parameter indicates the Eina_Strbuf object; the second 
parameter indicates the string to change; the third parameter indicates the 
string into which the existing string will be changed; and the fourth 
parameter indicat es the number of times of change.  
Run the example again. The first '()' is changed into 'can.'  
  

  
Page 291 / 978 6) Replacing All Identical Strings  
In this section, we are going to learn how to replace all identical strings. 
Add new code at the end of the show_eina_strbuf_result() function.  
┌─────────────────────┐  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    /* Replace all */  
    eina_strbuf_replace_all(strline, "()", "can");  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
└─────────────────────┘  
eina_strbuf_replace_all() is an API that replaces all identical strings. The 
first parameter indicates the Eina_Strbuf ob ject, the second parameter 
indicates the string to change, and the third parameter indicates the string 
into which the existing string will be changed.  
Run the example again. All ‘()’s are changed into ‘can.’  
 
 
  

  
Page 292 / 978 7) Inserting a String into the Middle of A nother String  
In this section, we are going to learn how to insert a string into the middle 
of another string. Add new code at the end of the show_eina_strbuf_result() 
function.  
┌─────────────────────┐  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_s trbuf_string_get(strline) );  
  
    /* Insert string */  
    eina_strbuf_insert(strline, " not", 5);  
    eina_strbuf_append_printf(strbuf, "<br>%s", eina_strbuf_string_get(strline) );  
  
    elm_object_text_set(label, eina_strbuf_string_get(strbuf));  
└─────────────────────┘  
eina_strbuf_insert() is an API that inserts a string into a specific position of 
another string. The first parameter indicates the Eina_Strbuf object, and 
the second parameter indicates the string to be inserted, and the third 
param eter indicates the insertion position.  
Run the example again. The string 'not' is inserted into index number 5 
(the sixth character).  
 
 
  

  
Page 293 / 978 8) Related APIs  
Eina_Strbuf *eina_strbuf_new(void): an API that creates a new Eina_Strbuf 
object.  
Eina_Bool eina_strb uf_append(Eina_Strbuf *buf, char *str): an API that adds 
a string to Eina_Strbuf.  
char *eina_strbuf_string_get(Eina_Strbuf *buf): an API that requests the 
string stored in Eina_Strbuf.  
void eina_strbuf_free(Eina_Strbuf *buf): an API that deletes the data s tored 
in Eina_Strbuf.  
Eina_Bool eina_strbuf_append_printf(Eina_Strbuf *buf, char *fmt, ...) : an API 
that adds a new string by specifying a format statement. / parameters: 
Eina_Strbuf object, format type, and from the third parameter on, data to 
be assigne d to the format.  
size_t eina_strbuf_length_get(Eina_Strbuf *buf): an API that returns the 
string stored in Eina_Strbuf.  
Eina_Bool eina_strbuf_remove(Eina_Strbuf *buf, size_t start, size_t end): an 
API that removes only part of a string.  / parameters: Eina_ Strbuf object, 
the start position of removal, and the end position of removal.  
void eina_strbuf_reset(Eina_Strbuf *buf): an API that resets the string stored 
in Eina_Strbuf.  
  
  
Page 294 / 978 Eina_Bool eina_strbuf_replace(Eina_Strbuf *buf, char *str, char *with, 
unsigned int n): an API that changes a string into another string. / 
parameters: Eina_Strbuf object, the string to change, the string into which 
the existing string will be changed, and number of changed times.  
int eina_strbuf_replace_all(Eina_Strbuf *buf, char *st r, char *with): an API 
that replaces all identical strings. / parameters: Eina_Strbuf object, the 
string to change, and the string into which the existing string will be 
changed.  
Eina_Bool eina_strbuf_insert(Eina_Strbuf *buf, char *str, size_t pos): an API  
that inserts a string into a particular position of another string. / 
parameters: Eina_Strbuf object, the string to be inserted, and insertion 
position.  
  
  
Page 295 / 978 25. Array Structure Eina_List  
When you are developing apps, there are times when it is necessary to 
manage multiple strings or user data in an array. EFL provides an array 
structure called 'Eina_List.' We are now going to learn how to use it 
through an example.  
 
1) Creating a List Widget  
Create a new source project and specify the project name as 'EinaListEx.' 
After the source project is created, open the source file (~.c) under the src 
folder and add new code. Add new variables to the appdata structure, 
define the new structure, and store 10 strings in a char* array.  
┌─────────────────────┐  
typede f struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *list;  
    Evas_Object *button;  
    Eina_List *data_list;  
} appdata_s;  
 
typedef struct {  
    appdata_s  *ad;  
    char       *data;  
    int         id ; 
} itemdata_s;  
  
Page 296 / 978  
/* List */  
const char *items[] = {  
        "Seoul", "Tokyo", "New York", "London", "Beijing",  
        "Moscow", "Singapore", "Busan", "Hong Kong", "Paris",  
        NULL 
}; 
└─────────────────────┘  
list is the variable for the List widget.  
button is the variable for the Delete button.  
data_list is the variable for the array structure Eina_List.  
Itemdata_s is a structure for the List Widget's event data. We are now 
going to enter app data in ad, enter the string selected by the user in 
data, and enter the number of the selected items in id.  
Items[] stores 10 strings that will be added to the List widget.  
 
Go to the create_base_gui() function and add new code. This code creates 
Frame, Table, Button, and List widgets.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_H INT_EXPAND, EVAS_HINT_EX
PAND);  
  
Page 297 / 978     elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* A frame surrounding the whole UI, for outer padding */  
        Evas_Object *frame;  
        frame = elm_frame_add(ad ->conform);  
        evas_object_size_hint_weight_set(frame, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        evas_object_size_hint_align_set(frame, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, frame);  
        evas_object_show(frame) ; 
 
        /* A table to layout our objects */  
        Evas_Object *table;  
        table = elm_table_add(frame);  
        evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        evas_object_size_hint_align_set(table, EVAS_HINT_F ILL, EVAS_HINT_FILL);  
        elm_object_content_set(frame, table);  
        evas_object_show(table);  
        /* Set inner padding */  
        elm_table_padding_set(table, 5 * elm_scale_get(), 5 * elm_scale_get());  
 
        { 
            /* Label */  
            ad->label = elm_label_add(table);  
            elm_object_text_set(ad ->label, "Please select an item");  
            evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, 0);  
            evas_object_size_hint_align_set(ad ->label, EVAS_HIN T_FILL, 0.5);  
            elm_table_pack(table, ad ->label, 0, 0, 1, 1);  
            evas_object_show(ad ->label);  
 
            /* Minus button */  
  
Page 298 / 978             ad->button = elm_button_add(ad ->conform);  
            elm_object_text_set(ad ->button, "Remove");  
            //evas_object_smart_callback_add(ad ->button, "clicked", btn_clicked_c
b, ad);  
            evas_object_size_hint_weight_set(ad ->button, EVAS_HINT_EXPAND, 0);  
            evas_object_size_hint_align_set(ad ->button, EVAS_HINT_FILL, 0.5);  
            elm_table_pack(table, ad ->button, 1, 0, 1, 1);  
            evas_object_show(ad ->button);  
 
            /* List view */  
            ad->list = elm_list_add(ad ->conform);  
            elm_list_mode_set(ad ->list, ELM_LIST_COMPRESS);  
            evas_object_size _hint_weight_set(ad ->list, EVAS_HINT_EXPAND, EVAS_
HINT_EXPAND);  
            evas_object_size_hint_align_set(ad ->list, EVAS_HINT_FILL, EVAS_HINT_F
ILL); 
            elm_table_pack(table, ad ->list, 0, 1, 2, 1);  
        } 
    } 
 
    /* Let's add some elements to our lists */  
    populate_list(ad);  
 
    /* Go should be called before show for proper display */  
    elm_list_go(ad ->list);  
    evas_object_show(ad ->list);  
 
    /* Show window after base gui is set up */  
    evas_object_s how(ad ->win);  
└─────────────────────┘  
Adding a Table to a Frame makes it possible to specify an outer margin.  
 
  
Page 299 / 978 populate_list() is a function that adds 10 text items to a List widget. We 
are now going to create one. Create a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
populate_list(appdata_s *ad)  
{ 
    /* Now, let's create an Eina_List and add some data items to it */  
    for (unsigned i = 0; items[i]; i++)  
    { 
        elm_list_item_append(ad ->list, items[i], NULL, NULL, NULL, NULL); 
    } 
 
    elm_list_go(ad ->list); 
} 
└─────────────────────┘  
This code adds 10 text items to a List. Refer to the ListEx example for 
explanations of each code.  
Build and run the example. One Label widget, one Button widget, and one 
List widget are created. And also, 10 text items are added to the List 
widget.  
  
Page 300 / 978  
 
2) Inputting and Outputting Data in Eina_List  
In this section, we are going to learn how to input and output string data 
in Eina_List. Modify the code of the populate_list() function as follows:  
┌─────────────────────┐  
populate_list(appdata_s *ad)  
{ 
    /* Now, let's create an Eina_List and add some data items to it */  
    for (unsigned i = 0; items[i]; i++)  
    { 
     itemdata_s *idata = calloc(1, sizeof(itemdata_s));  
     idata->ad = ad;  
     idata->data = strdup(items[i]);  
     idata->id = i + 1;  
        ad->data_list = eina_list_append(ad ->data_list, idata);  
        //eli = elm_list_item_append(ad ->list, items[i], NULL, NULL, NULL, NULL);  
 
        itemdata_s *itemdata = ein a_list_nth(ad ->data_list, i);  
        elm_list_item_append(ad ->list, itemdata ->data, NULL, NULL, NULL, NULL);  

  
Page 301 / 978     } 
 
    elm_list_go(ad ->list); 
} 
└─────────────────────┘  
This code stores all item data in the Itemdata_s structure variable, stores 
the data in Eina_List, and then adds the string stored in Eina_List to a List 
widget.  
eina_list_append(Eina_List*, void*) is an API that adds a new item to 
Eina_List. Because it returns Eina_List's pointer, it is necessary to store the 
address of the pointer in the  Eina_List variable.  
eina_list_nth(Eina_List*, unsigned int) is an API that returns item data 
stored in a particular position.  
eina_list_count(Eina_List*) is an API that returns the number of items stored 
in Eina_List.  
Run the example again. A list identic al to the previous list appears. This 
time, however, data has been stored in a global variable, and therefore 
can be used anywhere.  
 
3) Displaying Data about a Selected Item on the Screen  
In this section, we are going to implement a feature that, when the user 
selects a List widget item, displays the text of the item in a Label widget. 
Modify the code of the populate_list() function as follows:  
  
Page 302 / 978 ┌─────────────────────┐  
populate_list(appdata_s *ad)  
{ 
    for (unsigned i = 0; items[i]; i++)  
    { 
     itemdata _s *idata = calloc(1, sizeof(itemdata_s));  
     idata->ad = ad;  
     idata->data = strdup(items[i]);  
     idata->id = i + 1;  
        ad->data_list = eina_list_append(ad ->data_list, idata);  
        //eli = elm_list_item_append(ad ->list, items[i], NULL, NULL , NULL, NULL);  
 
        itemdata_s *itemdata = eina_list_nth(ad ->data_list, i);  
        //elm_list_item_append(ad ->list, itemdata ->data, NULL, NULL, NULL, NULL);  
        Elm_List_Item *eli;  
        eli = elm_list_item_append(ad ->list, itemdata ->data, NULL,  NULL, list_ite
m_clicked_cb, idata);  
    } 
 
    elm_list_go(ad ->list); 
} 
└─────────────────────┘  
This code specifies the name of the item selection callback function for 
when an item is added to the List widget and passes the item data.  
We specified the name of the item selection callback function as 
list_item_clicked.  
We are now going to define the callback function. Add a new function on 
top of the populate_list() function.  
 
  
Page 303 / 978 ┌─────────────────────┐  
static void  
list_item_clicked_cb(void *data, Evas_Objec t *obj, void *event_info)  
{ 
    itemdata_s *idata = data;  
    char buf[256];  
 
    snprintf(buf, 256, "%d. %s", idata ->id, idata ->data);  
    elm_object_text_set(idata ->ad->label, buf);  
} 
└─────────────────────┘  
list_item_clicked_cb() is the List item select ion event function. It displays 
the text of a selected item in a Label.  
It converts the item number and text into a single string using the sprintf() 
function.  
It displays item data in the Label widget using the elm_object_text_set() 
function.  
Run the exam ple again. Select a List widget item, and you will now see its 
item number and text displayed in the Label widget.  
  
Page 304 / 978  
 
4) Deleting Data  
In this section, we are going to implement a feature that deletes the 
currently selected item when a Button is clicked. A dd a new line to the 
Button -creating code of the create_base_gui() function.  
┌─────────────────────┐  
        /* Minus button */  
        ad->button = elm_button_add(ad ->conform);  
        elm_object_text_set(ad ->button, "Remove");  
        evas_object_smart_callback_add(ad ->button, "clicked", btn_clicked_cb, ad);  
        evas_object_size_hint_weight_set(ad ->button, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->button, EVAS_HINT_FILL, 0.5);  
        elm_table_pack(t able, ad ->button, 1, 0, 1, 1);  
        evas_object_show(ad ->button);  
└─────────────────────┘  
We specified the name of the Button callback function as btn_clicked_cb.  
 

  
Page 305 / 978 Now, we need to define the callback function. Create a new function on 
top of the create_ base_gui() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    Elm_List_Item *it;  
 
    if (!elm_list_items_get(ad ->list)) 
    { 
     elm_object_text_set(ad ->button, " Remove");  
     populate_list(ad);  
     return;  
    } 
 
    it = elm_list_selected_item_get(ad ->list); 
    if (!it) 
    { 
     elm_object_text_set(ad ->label, "No item selected");  
     return;  
    } 
 
    /* Delete widget item, this will call item_del_cb */  
    elm_object_item_del(it);  
    /* If no more elements, offer to repopulate list */  
    if (!ad ->data_list)  
    { 
     elm_object_text_set(ad ->button, "Populate");  
     return;  
    } 
} 
└─────────────────────┘  
  
Page 306 / 978 If the selected item does not exist in the Lis t widget, this code displays 
the text “Remove” in the Button widget and exits the function.  
If the selected item exists in the List widget, this code deletes the item 
and displays the text “Populate” in the Button widget.  
When the List widget's item is del eted, the item's data stored in the array 
structure must be deleted together with the item. Add a new line of code 
at the end of the populate_list() function.  
┌─────────────────────┐  
        itemdata_s *itemdata = eina_list_nth(ad ->data_list, i);  
        Elm_List_Item *eli;  
        eli = elm_list_item_append(ad ->list, itemdata ->data, NULL, NULL, list_item_cli
cked_cb, idata);  
        elm_object_item_del_cb_set(eli, item_del_cb);  
    } 
 
    elm_list_go(ad ->list); 
} 
└─────────────────────┘  
elm_object_item_del_cb_set() is an API that specifies the name of an item 
deletion callback function.  
We specified the callback function as item_del_cb. Add the callback 
function on top of the elm_object_item_del_cb_set() function.  
┌─────────────────────┐  
static void  
item_del_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
  
Page 307 / 978     /* Those are the arguments */  
    Elm_Widget_Item *it = event_info;  
    itemdata_s *idata = data;  
    (void) it;  
 
    /* Remove list element from Eina_List */  
    idata->ad->data_list = eina_list_remove(idata ->ad->data_list, idata);  
    free(idata ->data);  
    free(idata);  
} 
└─────────────────────┘  
item_del_cb() is a List item deletion event function. It deletes item data 
stored in Eina_List.  
eina_list_remove() is an API that dele tes items stored in Eina_List.  
Run the example again. Select an item and tap the Button, and the item 
will be deleted.  
   
 

  
Page 308 / 978 5) Related APIs  
Eina_List *eina_list_append(Eina_List *list, const void *data): an API that 
adds a new item to Eina_List. Because it returns Eina_List's pointer, it is 
necessary to store the address of the pointer in the Eina_List variable. / 
parameters: Eina_List object, item data object.  
unsigned int eina_list_count(const Eina_List *list): an API that returns the 
number of items st ored in Eina_List. / parameters: Eina_List object.  
void *eina_list_nth(const Eina_List *list, unsigned int n): an API that returns 
item data stored in a particular position. / parameters: Eina_List object, 
item index number.  
Eina_List *eina_list_remove(Ein a_List *list, const void *data): an API that 
deletes an item stored in Eina_List. Because it returns Eina_List's pointer, it 
is necessary to store the address of the pointer in the Eina_List variable. / 
parameters: Eina_List object, item data object.  
void elm_list_clear(Evas_Object *obj): an API that deletes all the items in 
the list from a List widget.  
  
  
Page 309 / 978 26. Using Timers  
A timer lets an event occur at regular time intervals. Timers are used 
necessarily for alarm apps and animation effects. When you develop an 
app, multiple timers are operated at the same time. We are now going to 
learn how to use it through an example.  
 
1) Starting a Timer Event  
Create a new source project and specify the project name as 'TimerEx.' 
After the source project is created, open the source file (~.c) under the src 
folder and add a new variable to the appdata structure.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Ecore_Timer *timer1;  
    int timer_count;  
} appdata_s;  
└─────────────────────┘  
Ecore_Timer is the timer structure.  
timer_count is a variable that stores the number of times a timer event 
has occurred.  
Add two new functions on top of the create_base_gui() function.  
  
Page 310 / 978 ┌─────────────────────┐  
static void 
my_box_pack(Evas_Object *box, Evas_Object *child, double h_weight, double v_weight,  
  double h_align, double v_align)  
{ 
    /* we use a frame for padding only */  
    Evas_Object *frame = elm_frame_add(box);  
    elm_object_style_set(frame, "pad_small") ; 
    evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
    evas_object_size_hint_align_set(frame, h_align, v_align);  
    { 
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        evas_object_size_hint_align_ set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
    } 
    elm_box_pack_end(box, frame);  
    evas_object_show(frame);  
} 
 
static Evas_Object *  
my_button_add(Evas_Object *parent, const  char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
└─────────────────────┘  
  
Page 311 / 978 my_box_pack() is a function that adds a widget to a Box container.  
my_button_add() is a function that creates and then returns a Button 
widget.  
Go back to the create_base_gui() function and add new code. This code 
creates two Boxes and two Buttons.  
┌────── ───────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set (ad->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *btn, *box;  
 
        /* Container: standard box */  
        box = elm_box_add(ad ->win);  
        elm_box_horizontal_set(box, EINA_FALSE);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label */  
            ad->label = elm_label_add(box);  
  
Page 312 / 978             elm_object_text_set(ad ->label, "No timer");  
            my_box_pack(box, ad ->label, EVAS_HINT_EXPAND, 0.0, 0.5, 0.0);  
 
            /* Button -1 */ 
            btn = my_button_add(box, "Start", btn_start_cb, ad);  
            my_box_pack(box, btn, EVAS_HINT_EXPAND, 0, EVAS_HINT_FILL, EVAS
_HINT_FILL);  
 
            /* Button -2 */ 
            btn = my_button_add(box, "Stop", btn _stop_cb, ad);  
            my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EV
AS_HINT_FILL, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
The first Button is responsibl e for starting a timer. We are now going to 
create a callback function for the Button. Add two new functions on top 
of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_start_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    ad->timer_count = 0;  
    ad->timer1 = ecore_timer_add(1.0, timer1_cb, ad);  
    elm_object_text_set(ad ->label, "Timer started");  
} 
 
  
Page 313 / 978 static void  
btn_stop_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
└─────────────────────┘  
The btn_start_cb() function is called when the first Button is clicked. This 
code resets the count of timer event occurrences to '0' and creates/starts 
a new timer.  
ecore_timer_add(double, Ecore_Task_Cb, void*) is an API that creates and 
then returns a new  timer. The first parameter indicates the time interval. 
The unit of time is seconds. For example, to make an event occur every 
1.5 seconds, you need to pass ‘1.5’. The second parameter indicates the 
name of the timer event callback function, while the thi rd parameter 
indicates user data.  
btn_stop_cb() is the event function for the second Button. We will add this 
feature in a short while.  
We are now going to create a timer event callback function. Add a new 
function on top of the btn_start_cb() function.  
┌─────────────────────┐  
static Eina_Bool  
timer1_cb(void *data EINA_UNUSED)  
{ 
    appdata_s *ad = data;  
    ad->timer_count ++;  
    char buf[100];  
    sprintf(buf, "Count - %d", ad ->timer_count);  
  
    elm_object_text_set(ad ->label, buf);  
  
Page 314 / 978     return ECORE_CAL LBACK_RENEW;  
} 
└─────────────────────┘  
When a timer event occurs, this new function is called. This code increases 
the count of timer event occurrences and displays the current count on 
the screen.  
Build and run the example. Tap the Start button, and you w ill see the 
number in the Label widget increases once every second.  
   
 
2) Stopping Timers  
In this section, we are going to implement a feature that stops the timer 
when the Stop button is tapped. Add code on top of the btn_stop_cb() 
function as shown below:  
┌─────────────────────┐  
static void  
btn_stop_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    ecore_timer_freeze(ad ->timer1);  
    ecore_timer_del(ad ->timer1);  
    elm_object_text_set(ad ->label, "Timer stopped");  
} 
└─────────────────────┘  

  
Page 315 / 978 ecore_timer_freeze(Ecore_Timer*) is an API that pauses a timer event. To 
resume a timer event, you need to use the ecore_timer_thaw() function.  
ecore_timer_del(Ecore_Timer*) is an API that deletes a timer object.  
Run the example agai n. Tap the Start button, and then after a while, tap 
the Stop button. The timer event then stops.  
   
 
3) Related APIs  
Ecore_Timer *ecore_timer_add(double in, Ecore_Task_Cb func, void *data): 
an API that creates and then returns a new timer. / parameters:  time 
interval (unit: second), name of the timer event callback function, and user 
data. 
void ecore_timer_freeze(Ecore_Timer *timer): an API that pauses a timer 
event.  
void ecore_timer_thaw(Ecore_Timer *timer): an API that resumes a timer.  
void *ecore_tim er_del(Ecore_Timer *timer): an API that deletes a timer 
object.  
  

  
Page 316 / 978 27. Time & Date  
Using i18n_ucalendar_h enables requesting the current date and time, and 
it also enables adding two different times. We are now going to learn how 
to use it through an example.  
 
1) Requesting the Time Zone  
Create a new source project and specify the project name as 'DateTime.' 
After the source project is created, open the source file (~.c) under the src 
folder and add a new variable to the appdata structure. Include the library 
header file as well.  
┌─────────────────────┐  
#include "datetime.h"  
#include <utils_i18n.h>  
 
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label1;  
    Evas_Object *label2;  
    Evas_Object *label3;  
    Evas_Object *l abel4;  
    Evas_Object *label5;  
    Evas_Object *slide;  
    Ecore_Timer *timer;  
    char *tzid;  
    i18n_ucalendar_h ucal;  
} appdata_s;  
└─────────────────────┘  
  
Page 317 / 978 We are going to display the time zone in label1, the current date and time 
in label2, the POSIX time in label3, the title of the time addition in label4, 
and the result of the time addition in label5.  
slide is a Slide widget that changes the current date to the date resulting 
from an addition.  
tzid is a string variable that stores the time zone.  
i18n_ucalendar_h is a structure that stores date and time information.  
We are now going to create eight Label widgets on the screen. To request 
the current time, you also need to request the time zone setting. Go back 
to the create_base_gui() function and add new code.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object _size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Table */  
    Evas_Object *table = elm_table_add(ad ->win);  
    elm_table_padding_set(tabl e, 5 * elm_scale_get(), 5 * elm_scale_get());  
    elm_object_content_set(ad ->conform, table);  
    evas_object_show(table);  
 
    { 
        Evas_Object *o;  
  
Page 318 / 978         /* Timezone label */  
        o = elm_label_add(table);  
        elm_object_text_set(o, "Time Zo ne:"); 
        table_pack(table, o, 0, 0, 1, 1, 0.5, 1.0, 1.0, 1.0);  
 
        ad->label1 = elm_label_add(table);  
        table_pack(table, ad ->label1, 1, 0, 1, 1, 0.5, 1.0, 0.0, 1.0);  
 
        system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_TIMEZON
E, &ad ->tzid);  
        elm_object_text_set(ad ->label1, ad ->tzid);  
 
        /* Current time label */  
        o = elm_label_add(table);  
        elm_object_text_set(o, "Current Time:");  
        table_pack(table, o, 0, 1, 1, 1, 0.5, 0.0, 1.0, 0.5);  
 
        ad->label2 = elm_label_add(table);  
        table_pack(table, ad ->label2, 1, 1, 1, 1, 0.5, 0.0, 0.0, 0.5);  
 
        /* Current time label  */ 
        o = elm_label_add(table);  
        elm_object_text_set(o, "Since Epoch:");  
        table_pack(table, o, 0, 2, 1, 1, 0.5, 0.0, 1.0, 0.5);  
 
        ad->label3 = elm_label_add(table);  
        table_pack(table, ad ->label3, 1, 2, 1, 1, 0.5, 0.0, 0.0,  0.5); 
 
        /* Showcase datetime computation */  
        ad->label4 = elm_label_add(table);  
        elm_object_text_set(ad ->label4, "40 days later:");  
        table_pack(table, ad ->label4, 0, 3, 1, 1, 0.5, 0.0, 1.0, 0.5);  
 
        ad->label5 = elm_label _add(table);  
  
Page 319 / 978         table_pack(table, ad ->label5, 1, 3, 1, 1, 0.5, 0.0, 0.0, 0.5);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created four Labels and two Buttons.  
system_settings_get_value_string() is an API that requests system 
configuration information. Passing 
SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE to the first parameter returns 
the time zone string to the second parameter.  
Build and run the example. The time zone s pecified in Settings is displayed 
in Label1.  
 
 
  

  
Page 320 / 978 2) Creating the Current Time  
When you create an i18n_ucalendar_h object, the current time is 
automatically stored. Create a new function on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static i18n_ucalendar_h  
create_time(char *tzid)  
{ 
    i18n_ucalendar_h ucal;  
    i18n_uchar *_tzid = (i18n_uchar*)calloc(strlen(tzid) + 1, sizeof(i18n_uchar));  
    // converts 'tzid' to unicode string  
    i18n_ustring_copy_ua(_tzid, tzid);  
    // gets length of '_tzid'  
    int len = i18n_ustring_get_length(_tzid);  
    // creates i18n_ucalendar_h  
    int ret = i18n_ucalendar_create(_tzid, len, "en_US", I18N_UCALENDAR_TRADITION
AL, &ucal);  
    if (ret != 0)  
    { 
     dlog_print(DLOG_ERROR, LOG_TAG, "i18n_ucalend ar_create() failed with err =
 %d", ret);  
     return NULL;  
    } 
 
    return ucal;  
} 
└─────────────────────┘  
To create an i18n_ucalendar_h object, you need to convert the time zone 
into the i18n_uchar format.   
  
Page 321 / 978 i18n_ustring_copy_ua() is an API that copies the time zone stored in a char 
array to an i18n_uchar array.  
i18n_ustring_get_length() is an API that returns the length of an i18n_uchar 
array. 
i18n_ucalendar_create(i18n_uchar *zone_id, int32_t len, char *locale, 
i18n_ucalendar_type_e type, i18n_ucalenda r_h *calendar) is an API that 
creates an i18n_ucalendar_h object. For the first parameter, the time zone 
is returned; for the second parameter, the length of the time zone string; 
for the third parameter, the name of the region; for the fourth parameter, 
the ucalendar type; and for the fifth parameter, the i18n_ucalendar_h 
object.  
You can obtain the current time this way. We are now going to convert 
the date and time stored in i18n_ucalendar_h into a string and display the 
string on the screen. Create a new  function on top of the create_base_gui() 
function. This function receives an i18n_ucalendar_h object and converts 
its date and time into a string.  
┌─────────────────────┐  
static void  
update(appdata_s *ad)  
{ 
    int year, month, day, hour, minute, second;  
    i18n_udate udate;  
    char buf[256];  
    int diff;  
 
    /* Current time */  
    i18n_ucalendar_get_now(&udate);  
  
Page 322 / 978     i18n_ucalendar_set_milliseconds(ad ->ucal, udate);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_YEAR, &year);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MONTH, &month);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_DATE, &day);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_HOUR_OF_DAY, &hour);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MINUTE, &minute);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_SECOND, &second);  
    snprintf(buf, sizeof(buf), "%d/%02d/%02d %02d:%02d:%02d", year, month + 1, d
ay, hour, minute, second);  
    elm_object_text_set(ad ->label2, buf);  
} 
└─────────────────────┘  
i18n_ucalendar_ get(i18n_ucalendar_h,  i18n_ucalendar_date_fields_e, 
int32_t) is an API that requests a type of data from i18n_ucalendar_h. 
Passing I18N_UCALENDAR_YEAR to the second parameter makes the 
third parameter return the year value.  
This code requests the year, mon th, date, hour, minute, and second values, 
in order.  
By using the sprintf() function, this code turns the six types of time values 
into a single string printf() and returns the string. One thing to note is that 
in the case of month, value '1' needs to be a dded. The range of values for 
month is 0 to 11.  
We are now going to display the current time on the screen using the two 
functions we just created. Add new code at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
  
Page 323 / 978     evas_object_show(ad ->win);  
 
    /* Prepare calendar object and 1 -second timer */  
    ad->ucal = create_time(ad ->tzid);  
    update(ad);  
} 
└─────────────────────┘  
Run the example again. The current date and time are displayed in Label2.  
 
 
3) Digital Watch  
In this section, we are going to implement a feature that renews the date 
and time displayed in Label2 once every second. In other words, by using 
a timer, we will be implementing a feature that functions the same as a 
digital w atch. Add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    /* Prepare calendar object and 1 -second timer */  
    ad->ucal = create_time(ad ->tzid); 
    ad->timer = ecore_timer_add(1.0, timer_cb, ad);  
    update(ad);  
} 
└─────────────────────┘   

  
Page 324 / 978 This code generates a timer event once every second. Now, we need to 
create a timer event function. Create a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static Eina_Bool  
timer_cb(void *data)  
{ 
 appdata_s *ad = data;  
 update(ad);  
 return ECORE_CALLBACK_RENEW;  
} 
└─────────────────────┘  
When a timer event occurs, this code calls the update() function and 
renews the time and d ate. Run the example again. The time changes once 
every second.  
   
 
  

  
Page 325 / 978 4) Calculating POSIX Time  
The time unit used on computers is the millisecond, and if you convert 
the amount of time from 1 A.D. to the current year into a time value in 
milliseconds, a n astronomical number will be created. Therefore, it became 
necessary to come up with a new time system that starts after the advent 
of the computer. 0:00:00 January 1, 1970 is the date that was eventually 
decided on as the starting date. This system is ca lled POSIX time. With 
the use of POSIX time, it is possible to calculate how much time has passed 
since the app started.  
Add a new line of code to the update() function. This code specifies the 
name of the Button callback function.  
┌─────────────────────┐  
static void  
update(appdata_s *ad)  
{ 
    int year, month, day, hour, minute, second;  
    i18n_udate udate;  
    char buf[256];  
    int diff;  
 
    /* Current time */  
    i18n_ucalendar_get_now(&udate);  
    i18n_ucalendar_set_milliseconds(ad ->ucal, udate);  
    ~ 
    elm_object_text_set(ad ->label2, buf);  
 
    /* POSIX time since EPOCH */  
    snprintf(buf, sizeof(buf), "%llums", (unsigned long long) udate);  
    elm_object_text_set(ad ->label3, buf);  
} 
└─────────────────────┘  
  
Page 326 / 978 i18n_udate is the same type of data as double. POSIX time has a very 
large numeric value, so it is necessary to use this type of format.  
i18n_ucalendar_get_now(i18n_udate) is an API that converts the current 
time to a time in milliseconds.  
i18n_ucalendar_set_milliseconds(i18n_ucalendar_h, i18n_ udate) is an API 
that specifies a new time in i18n_ucalendar_h.  
Run the example again, and you will now see POSIX time displayed in 
label3. The displayed unit of time is milliseconds.  
 
 
4) Calculating Time  
In this section, we are going to learn how to add  numbers to the date. 
First, add one Slider widget. Add new code at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
        ad->label5 = elm_label_add(table);  
        table_pack(table, ad ->label5, 1, 3, 1, 1, 0.5, 0.0, 0.0, 0.5);  
 
        /* Spinner for more time difference */  
        ad->slide = elm_slider_add(table);  
        elm_slider_min_max_set(ad ->slide, -365, 365);  
        elm_slider_value_set(ad ->slide, 40);  
        table_pack(table, ad ->slide, 0, 4, 2, 1, 1.0, 2.0, -1.0, 0.0);  

  
Page 327 / 978         evas_object_smart_callback_add(ad ->slide, "changed", spinner_cb, ad);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Slider widget and specified a range of -365 to +365 for th e 
widget. We specified the value as 40.  
We are now going to create an event function for the Slider. Create a new 
function on top of the create_base_gui() function. When the value of the 
Slider is changed, the update() function is called.  
┌──────────────── ─────┐  
static void  
spinner_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
 appdata_s *ad = data;  
 update(ad);  
} 
└─────────────────────┘  
Lastly, add new code at the end of the update() function.  
┌─────────────────────┐  
static void  
update(appdata_s *ad) 
{ 
    ~ 
 
    /* POSIX time since EPOCH */  
    snprintf(buf, sizeof(buf), "%llums", (unsigned long long) udate);  
  
Page 328 / 978     elm_object_text_set(ad ->label3, buf);  
 
    /* 40 days later (label) */  
    diff = (int) elm_slider_value_get(ad ->slide);  
    if (diff > = 0) 
        snprintf(buf, sizeof(buf), "%d day%s later:", diff, (diff > 1) ? "s" : "");  
    else if (diff < 0)  
     snprintf(buf, sizeof(buf), "%d day%s earlier:", -diff, (diff < -1) ? "s" : "");  
    elm_object_text_set(ad ->label4, buf);  
 
    /* 40 days l ater (value) */  
    i18n_ucalendar_add(ad ->ucal, I18N_UCALENDAR_DATE, diff);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_YEAR, &year);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MONTH, &month);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_DATE,  &day);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_HOUR_OF_DAY, &hour);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MINUTE, &minute);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_SECOND, &second);  
    snprintf(buf, sizeof(buf), "%d/%02d/%02d %02d:%02d:%02d", year, month + 
1, day, hour, minute, second);  
    elm_object_text_set(ad ->label5, buf);  
} 
└─────────────────────┘  
Distinguishing between negative and positive values, this code displays a 
given S lider value in label4 and displays the sum of the current date and 
the value in label5.  
i18n_ucalendar_add() is a function that adds a number to a particular item 
of the i18n_ucalendar_h object. Passing 18N_UCALENDAR_DATE to the 
second parameter and passin g 40 to the third parameter creates a date 
that is 40 days after the current date.  
  
Page 329 / 978 Run the example again and tap the second Button. The date that is 40 
days after the current date is displayed in label4. Dragging through the 
Slider changes the date used fo r calculation.  
   
 
5) Related APIs  
int system_settings_get_value_string(system_settings_key_e key, char 
**value): an API that requests system configuration information. Passing 
SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE to the first parameter returns 
the time z one string to the second parameter.  
i18n_uchar* i18n_ustring_copy_ua ( i18n_uchar *dest, const char *src ): an 
API that copies the time zone stored in the char array to the i18n_uchar 
array. 
int32_t i18n_ustring_get_length ( i18n_uchar *s ): an API that re turns the 
length of the i18n_uchar array.  
int i18n_ucalendar_create ( i18n_uchar *zone_id, int32_t len, char *locale, 
i18n_ucalendar_type_e type, i18n_ucalendar_h *calendar ): an API that 
creates an i18n_ucalendar_h object. / parameters: time zone, length of the 
time zone string, region name, ucalendar type, and the i18n_ucalendar_h 
object return.  
  

  
Page 330 / 978 int i18n_ucalendar_get ( i18n_ucalendar_h calendar, 
i18n_ucalendar_date_fields_e field, int32_t *val ): an API that requests one 
type of data from i18n_ucalendar_h. / parameters: i18n_ucalendar_h 
object, date and time fields, and the date and time values return.  
The date and time field types:  
 - I18N_UCALENDAR_YEAR: year  
 - I18N_UCALENDAR_MONTH: month  
 - I18N_UCALENDAR_DATE: date  
 - I18N_UCALENDAR_DA Y_OF_WEEK: day of the week  
 - I18N_UCALENDAR_AM_PM: a.m. or p.m.  
 - I18N_UCALENDAR_HOUR: hours  
 - I18N_UCALENDAR_MINUTE: minutes  
 - I18N_UCALENDAR_SECOND: seconds  
 - I18N_UCALENDAR_MILLISECOND: milliseconds  
i18n_udate: the same type of data as double. It i s used for storing POSIX 
time. 
int i18n_ucalendar_get_milliseconds( i18n_ucalendar_h calendar, 
i18n_udate *date ): an API that the converts the time stored in 
i18n_ucalendar_h into POSIX time. The displayed unit of time is 
milliseconds.  
int i18n_ucalendar_ add (i18n_ucalendar_h calendar, 
i18n_ucalendar_date_fields_e field, int32_t amount ): an API that adds a 
number to a particular item of the 18n_ucalendar_h object. / parameters: 
i18n_ucalendar_h object, date and time fields, and the numbers being 
added.   
  
Page 331 / 978 28. Calendar Example  
In this example, we are going to learn how to create a calendar using 
i18n_ucalendar_h.  
 
1) Screen UI Composition  
Create a new source project and specify the project name as 'CalendarEx.' 
After the source project is created, open the source  file (~.c) under the src 
folder and add a new variable to the appdata structure and also add a 
library header file.  
┌─────────────────────┐  
#include "calendarex.h"  
#include <utils_i18n.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *c onform;  
    Evas_Object *label;  
    Evas_Object *label_day[6][7];  
    char *tzid;  
    i18n_ucalendar_h ucal;  
} appdata_s;  
└─────────────────────┘  
label_day is a Label widget array that displays the date. The space allowed 
for displaying the date is up to 7  columns horizontally and up to 6 rows 
vertically.  
  
Page 332 / 978 In tzid, store the time zone.  
In ucal, store the current date and time.  
We are now going to add Label widgets for displaying the date to the 
screen. Create a new function on top of the create_base_gui() fu nction. 
This function adds a widget to a Table.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
   evas_object_size_hint_align_set(child, 0.5, 0.5);  
   evas_object_size_hint_weight_set (child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
   elm_table_pack(table, child, x, y, w, h);  
   evas_object_show(child);  
} 
└─────────────────────┘  
Then, add new code at the end of the create_base_gui() function. This 
code creates a Box and a Table and adds a Label. Annotate the 
Conformant -creating code.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_ INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);*/  
 
  
Page 333 / 978     /* Box to put the table in so we can bottom -align the t able 
     * window will stretch all resize object content to win size */  
    Evas_Object *box = elm_box_add(ad ->win);  
    evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_win_resize_object_add(ad ->win, box);  
    evas_objec t_show(box);  
 
    /* Table */  
    Evas_Object *table = elm_table_add(ad ->win);  
    /* Make table homogenous - every cell will be the same size */  
    elm_table_homogeneous_set(table, EINA_TRUE);  
    /* Set padding of 10 pixels multiplied by scale factor of  UI */ 
    elm_table_padding_set(table, 10 * elm_config_scale_get(), 10 * elm_config_scal
e_get());  
    /* Let the table child allocation area expand within in the box */  
    evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_EXPA
ND); 
    /* Set table to fiill width but align to bottom of box */  
    evas_object_size_hint_align_set(table, EVAS_HINT_FILL, 0.0);  
    elm_box_pack_end(box, table);  
    evas_object_show(table);  
 
    { 
        /* Label*/  
        ad->label = elm_label_add(ad ->win); 
        elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
        my_table_pack(table, ad ->label, 0, 0, 7, 1);  
 
        for(int j=0; j < 6; j++)  
        { 
            for(int i=0; i < 7; i++)  
            { 
                ad->label_day [j][i] = elm_label_add(ad ->win);  
  
Page 334 / 978                 elm_object_text_set(ad ->label_day[j][i], ".");  
                my_table_pack(table, ad ->label_day[j][i], i, j + 2, 1, 1);  
            } 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
By using two for -loops, we created a Label widget that is 6 columns 
vertically and 7 rows horizontally.  
Build and run the example. The symbol '.' is displayed in the newly added 
Label. 
 
 
2) Displaying the Current Date and Time  
In this section, we are going to create an i18n_ucalendar_h object and 
displays the current date and time on the screen. Add two new functions 
on top of the create_base_gui() function.  
┌─────────────────────┐  
static i18n_ucalendar_h  

  
Page 335 / 978 create_time(char *tzid)  
{ 
    i18n_ucalendar_h ucal;  
    i18n_uchar *_tzid = (i18n_uchar*)calloc(strlen(tzid) + 1, sizeof(i18n_uchar));  
    i18n_ustring_copy_ua(_tzid, tzid);  
    int len = i18n_ustring_get_length(_tzid);  
    int ret = i18n_ucalendar_create (_tzid, len, "en_US", I18N_UCALENDAR_TRADITIONA
L, &ucal);  
    return ucal;  
} 
  
static char* time2string(i18n_ucalendar_h ucal)  
{ 
    int year, month, day, hour, minute, second;  
    i18n_ucalendar_get(ucal, I18N_UCALENDAR_YEAR, &year);  
    i18n_ucalendar_ge t(ucal, I18N_UCALENDAR_MONTH, &month);  
    i18n_ucalendar_get(ucal, I18N_UCALENDAR_DATE, &day);  
    i18n_ucalendar_get(ucal, I18N_UCALENDAR_HOUR, &hour);  
    i18n_ucalendar_get(ucal, I18N_UCALENDAR_MINUTE, &minute);  
    i18n_ucalendar_get(ucal, I18N_UCALEN DAR_SECOND, &second);  
  
    char *buf = malloc(100);  
    sprintf(buf, "Now :%04d -%02d-%02d %02d:%02d:%02d", year, month + 1, day, ho
ur, minute, second);  
    return buf;  
} 
└─────────────────────┘  
create_time() is a function that creates and then returns an 
i18n_ucalendar_h object, and time2string() is a function that converts the 
date stored in i18n_ucalendar_h to a string and returns the string. For 
detailed information, see the DateTime example.  
  
Page 336 / 978 In this section, we are going to use the function above and d isplay the 
current date and time on the screen. Add new code at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    evas_object_show(ad ->win);  
  
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE, &
ad->tzid);  
    ad->ucal = create_time(ad ->tzid);  
    char *buf = time2string(ad ->ucal);  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
Request the time zone using the system_settings_get_value_string() 
function.  
Create an i18n_ucalendar_h object using t he create_time() function.  
Convert the date and time stored in i18n_ucalendar_h into a single string 
using the time2string() function.  
Run the example again. The current date and time are displayed in the 
Label widget.  
 
 
  

  
Page 337 / 978 3) Calculating Calendar Dates  
In this section, we are going to find out what day of the week the current 
month's first day is and enter a date in the Label array. Create a new 
function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
draw_calendar(appdata_s *ad) 
{ 
    int date, month, dow, days, is_leap;  
    int max_day[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  
  
    i18n_ucalendar_set(ad ->ucal, I18N_UCALENDAR_DATE, 1);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MONTH, &month);  
    i18n_ucale ndar_get(ad ->ucal, I18N_UCALENDAR_DAY_OF_WEEK, &dow);  
    days = max_day[month];  
  
    if( month == 1 )  
    { 
        i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_IS_LEAP_MONTH, &is_leap);  
        if( is_leap == 1 )  
            days = 29;  
    } 
  
    int i=0, j=0;  
    char buf[10];  
  
    i = dow - 1; 
    for(int d=1; d <= days; d++)  
    { 
        sprintf(buf, "%d", d);  
        elm_object_text_set(ad ->label_day[j][i], buf);  
  
Page 338 / 978         i ++; 
        if( i >= 7 )  
        { 
            i = 0;  
            j ++; 
        } 
    } 
} 
└─────────────────────┘  
max_day[] is an array that stores a maximum number of days for January 
through December.  
i18n_ucalendar_set() is an API that specifies a new value for a particular 
item of an i18n_ucalendar_h object. Passing I18N_U CALENDAR_DATE to 
the second parameter and passing 1 to the third parameter change the 
current date to the 1st.  
i18n_ucalendar_get() is an API that returns the value of a particular item 
of an i18n_ucalendar_h object. The date item types are as follows:  
- Passing I18N_UCALENDAR_MONTH to the second parameter makes the 
third parameter return the value of Month.  
- Passing I18N_UCALENDAR_DAY_OF_WEEK to the second parameter 
makes the third parameter return the number of Day of Week.  
- Passing I18N_UCALENDAR_IS_LE AP_MONTH to the second parameter 
makes the third parameter return whether or not the current month is a 
leap month.  
If the current month is a leap month, the max day is changed to 29 days.  
  
  
Page 339 / 978 The part after the above is code that converts the numbers that 
respectively correspond to the days between the first day and the last day 
of a month to strings and then display them in the relevant Label widget.  
We need to let this function be called when the app is executed. Add a 
new line of code at the end of the c reate_base_gui() function.  
┌─────────────────────┐  
    elm_object_text_set(ad ->label, buf);  
  
    draw_calendar(ad);  
} 
└─────────────────────┘  
Run the example again. The calendar that corresponds to today's date is 
displayed.  
 
 
4) Displaying the Current D ate 
In this section, we are going to implement a feature that encloses the 
number corresponding to today's date in the '[]' symbol. Add new code 
to the draw_calendar() function.   

  
Page 340 / 978 ┌─────────────────────┐  
static void  
draw_calendar(appdata_s *ad)  
{ 
    int date, month, dow, days, is_leap;  
    int max_day[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  
  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_DATE, &date);  
    i18n_ucalendar_set(ad ->ucal, I18N_UCALENDAR_DATE, 1);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_MONTH, &month);  
    i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_DAY_OF_WEEK, &dow);  
    days = max_day[month];  
  
    if( month == 1 )  
    { 
        i18n_ucalendar_get(ad ->ucal, I18N_UCALENDAR_IS_LEAP_MONTH, &is_leap);  
        if( is_leap = = 1 ) 
            days = 29;  
    } 
  
    int i=0, j=0;  
    char buf[10];  
  
    i = dow - 1; 
    for(int d=1; d <= days; d++)  
    { 
        sprintf(buf, "%d", d);  
        if( d == date )  
            sprintf(buf, "[%d]", d);  
        elm_object_text_set(ad ->label_day[j][i], buf);  
        ~ 
└─────────────────────┘  
  
  
Page 341 / 978 Request today's date using the i18n_ucalendar_get() function and store it 
in a variable.  
When it is a turn for today’s date in the for -loop, the symbol '[]' is added 
to the value.  
Run the example a gain. You will now see today's date distinguished from 
the other dates.  
 
 
5) Calendar Widget  
Using the Calendar widget makes it easy to create a Calendar. Create a 
new example and specify its name as CalendarWidgetEx.  
Add new code to the create_base_gui()  function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_si ze_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  

  
Page 342 / 978     evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->win);  
            elm_object_text_set(ad ->label, "<align=center>Calendar</>");  
            evas_object_ size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, 0.0);  
            evas_object_size_hint_align_set(ad ->label, EVAS_HINT_FILL, 0.5);  
            elm_box_pack_end(box, ad ->label);  
            evas_object_show(ad ->label);  
 
            Evas_Object *cal = elm_ calendar_add(ad ->win);  
            evas_object_size_hint_weight_set(cal, EVAS_HINT_EXPAND, EVAS_HINT_
EXPAND);  
            evas_object_size_hint_align_set(cal, EVAS_HINT_FILL, 0.5);  
            elm_box_pack_end(box, cal);  
            evas_object_show(cal);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_calendar_add() is an API that creates a Calendar widget.   
  
Page 343 / 978 Run the example, and you will now see a Calendar displayed. Use the 
left/right arrow to go to the previous/next month.  
 
For detailed information on how to use the Calendar widget, refer to the 
following path in Help Contents.  
API References > Native Application > Mobile Native > Native API 
Reference > UI > EFL > Elementar y > Elementary Widgets  
 
6) Related APIs  
int system_settings_get_value_string(system_settings_key_e key, char 
**value): an API that requests system configuration information. Passing 
SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE to the first parameter returns 
the tim e zone string to the second parameter.  
i18n_uchar* i18n_ustring_copy_ua ( i18n_uchar *dest, const char *src ): an 
API that copies the time zone stored in the char array to the i18n_uchar 
array. 
 

  
Page 344 / 978 int32_t i18n_ustring_get_length ( i18n_uchar *s ): an API tha t returns the 
length of the i18n_uchar array.  
int i18n_ucalendar_create ( i18n_uchar *zone_id, int32_t len, char *locale, 
i18n_ucalendar_type_e type, i18n_ucalendar_h *calendar ): an API that 
creates an i18n_ucalendar_h object. / parameters: time zone, len gth of the 
time zone string, region name, ucalendar type, and the i18n_ucalendar_h 
object return.  
int i18n_ucalendar_get ( i18n_ucalendar_h calendar, 
i18n_ucalendar_date_fields_e field, int32_t *val ): an API that requests one 
type of data from i18n_ucalen dar_h. / parameters: i18n_ucalendar_h 
object, date and time fields, and the date and time values return.  
The date and time field types:  
 - I18N_UCALENDAR_YEAR: year  
 - I18N_UCALENDAR_MONTH: month  
 - I18N_UCALENDAR_DATE: date  
 - I18N_UCALENDAR_DAY_OF_WEEK: day of the week  
 - I18N_UCALENDAR_AM_PM: a.m. or p.m.  
 - I18N_UCALENDAR_HOUR: hours  
 - I18N_UCALENDAR_MINUTE: minutes  
 - I18N_UCALENDAR_SECOND: seconds  
 - I18N_UCALENDAR_MILLISECOND: milliseconds  
i18n_udate: the same type of data as double. It is used for storing POSIX 
time. 
 
  
Page 345 / 978 int i18n_ucalendar_get_milliseconds( i18n_ucalendar_h calendar, 
i18n_udate *date ): an API that the converts the time stored in 
i18n_ucalendar_h into POSIX time. The displayed unit of time is 
milliseconds.  
int i18n_ucalendar_add ( i18n _ucalendar_h calendar, 
i18n_ucalendar_date_fields_e field, int32_t amount ) : an API that adds a 
number to a particular item of the 18n_ucalendar_h object. / parameters: 
i18n_ucalendar_h object, date and time fields, and the numbers being 
added.  
  
  
Page 346 / 978 29. Requesti ng a Mouse Touch Event  
To create an image viewer, you need to implement a feature that displays 
images in a slideshow where the user can switch between the images by 
dragging the screen left and right. In addition, in the case of musical 
instrument apps su ch as ocarina and piano apps, it is necessary to request 
multi-touch information. Besides the apps mentioned above, the majority 
of games and quality other apps also use touch events. In this example, 
we are going to learn how to request an event when the user has touched 
a Window.  
 
1) Requesting a Container Touch Event  
Create a new source project and specify the project name as 
‘MouseTouchEvent.’ After the source project is created, open the source 
file (~.c) under the src folder and add new code at the en d of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Label*/  
    ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_object_content_set(ad ->conform, ad ->label);  
    evas_object_show(ad ->label);  
  
    /* Mouse Touch event callback */  
    evas_object_event_callback_add( ad ->conform, EVAS_CALLBACK_MOUSE_DOWN,
  
Page 347 / 978  on_mouse_down , ad);  
    evas_object_event_callback_add( ad->conform, EVAS_CALLBACK_MOUSE_MOVE, 
on_mouse_move , ad);  
    evas_object_event_callback_add( ad ->conform, EVAS_CALLBACK_MOUSE_UP , on_
mouse_up , ad);  
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
evas_object_event_callback_add() is an API that specifies a callback 
function for an evas object. Evas objects in this case are all objects 
displayed on the screen. Therefore, evas objects include both basic 
objects (Line, Rect, Polygon, Text, and Image) a nd smart objects 
(containers and widgets).  
For the first parameter, enter the object that an event will occur. In this 
case, we specified the object as Conformant.  
For the second parameter, enter the event type. 
EVAS_CALLBACK_MOUSE_DOWN indicates the Touc h Down event. 
EVAS_CALLBACK_MOUSE_MOVE indicates the Touch Move event. 
EVAS_CALLBACK_MOUSE_UP indicates the Touch Cancel event.  
For the third parameter, enter the name of the callback function. The 
fourth parameter indicates user data.  
We are now going to implement a callback function that is called when 
the user touches a Conformant. Add three new functions on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
on_mouse_down(void *data, Evas *e, Evas_Object *obj, void *event_info)  
  
Page 348 / 978 { 
    appdata_s *ad = data;  
    Evas_Event_Mouse_Down *ev = event_info;  
    char buf[100];  
  
    sprintf(buf, "Win Mouse down:%d,%d", ev ->canvas.x, ev ->canvas.y);  
    elm_object_text_set(ad ->label, buf);  
} 
  
static void  
on_mouse_move(void *data, Evas *e, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    Evas_Event_Mouse_Move *ev = event_info;  
    char buf[100];  
  
    sprintf(buf, "Win Mouse move:%d,%d/%d,%d",  
            ev->prev.canvas.x, ev ->prev.canvas.y, ev ->cur.canvas.x, ev ->cur.canv as.y); 
    elm_object_text_set(ad ->label, buf);  
} 
  
static void  
on_mouse_up(void *data, Evas *e, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    Evas_Event_Mouse_Up *ev = event_info;  
    char buf[100];  
  
    sprintf(buf, "Win Mouse up:% d,%d", ev ->canvas.x, ev ->canvas.y);  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
  
  
Page 349 / 978 on_mouse_down() is the callback function for when a Conformant is Touch 
Downed. The first parameter receives user data, and the second parameter 
receives the object where an event has occurred. The third parameter 
receives the Evas_Event_Mouse_Down object that contains Touch event 
information.  
Among the properties of an Evas_Event_Mouse_Down object, the canvas 
property contains Touch point coordina tes. 
on_mouse_move() is the callback function for when a Conformant is Touch 
Moved. The first parameter receives user data, and the second parameter 
receives the object where an event has occurred. The third parameter 
receives the Evas_Event_Mouse_Move obj ect that contains Touch event 
information.  
Among the properties of an Evas_Event_Mouse_Move object, the 
prev.canvas property contains the previous Touch point coordinates. 
cur.canvas contains the current Touch point coordinates.  
on_mouse_up() is the callba ck function for when a Conformant is Touch 
Canceled. The first parameter receives user data, while the second 
parameter receives the object where an event has occurred. The third 
parameter receives the Evas_Event_Mouse_Up object that contains Touch 
event i nformation.  
Among the properties of an Evas_Event_Mouse_UP object, the canvas 
property contains Touch point coordinates.  
Build and run the example. Touch the screen using your mouse. You will 
see the current point coordinates displayed in the Label widget.  
  
Page 350 / 978 Drag the screen using your mouse, you can see the previous Touch point 
coordinates and the current Touch point coordinates displayed in the Label 
widget.  
Removing your finger from your mouse displays the last point coordinates 
in the Label widget.  
            
 
 
  

  
Page 351 / 978 3) Requesting a Multi Touch Event  
In this section, we are going to request each relevant piece of touch 
information when the user has touched the screen with multiple fingers. 
Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Mouse Touch event callback */  
    evas_object_event_callback_add( ad ->conform, EVAS_CALLBACK_MOUSE_DOWN, on
_mouse_down , ad);  
    evas_object_event_callback_add( ad ->conform, EVAS_CALLBACK_MOUSE_MOVE, on_
mouse_move , ad);  
    evas_object_event_callback_add( ad ->conform, EVAS_CALLBACK_MOUSE_UP, on_mo
use_up , ad);  
  
    /* Multi Touch event callback */  
    evas_object_event_callback_add(ad ->conform, EVAS_CALLBACK_MULTI_DOWN, 
multi_down_cb, ad);  
    evas_object_event_callback_add(ad ->conform, EVAS_CALLBACK_MULTI_MOVE, m
ulti_move_cb, ad);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
EVAS_CALLBACK_MULTI_DOWN indicates the Multi Touch Down eve nt.  
EVAS_CALLBACK_MULTI_MOVE indicates the Multi Touch Move event.  
We are now going to create a Multi Touch event function. Add two new 
functions to the create_base_gui() function.  
 
  
Page 352 / 978 ┌─────────────────────┐  
static void  
multi_down_cb(void *data, Evas *e, E vas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    Evas_Event_Multi_Down *ev = (Evas_Event_Multi_Down*)event_info;  
    char buf[100];  
  
    sprintf(buf, "Multi down : %d - %d,%d", ev ->device, ev ->canvas.x, ev ->canvas.y);  
    elm_object_text _set(ad ->label, buf);  
} 
  
static void  
multi_move_cb(void *data, Evas *e, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    Evas_Event_Multi_Move *ev = (Evas_Event_Multi_Move*)event_info;  
    char buf[100];  
  
    sprintf(buf, "Multi move :  %d - %d,%d", ev ->device, ev ->cur.canvas.x, ev ->cur.canv
as.y); 
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
multi_down_cb() indicates the Multi Touch Down event function. The first 
point's event is not received. The third parameter re ceives the 
Evas_Event_Multi_Down object that contains Touch event information.  
Among the properties of an Evas_Event_Multi_Down object, the canvas 
property contains Touch point coordinates. The device property contains 
the ID of the Touch point. When a Mov e event or an Up event has occurred, 
the event can be identified by the ID.   
  
Page 353 / 978 multi_move_cb() indicates the Multi Touch Move event function. The first 
point's event is not received. The third parameter receives the 
Evas_Event_Multi_Move object that contains  Touch event information.  
Among the properties of an Evas_Event_Multi_Move object, the cur 
property contains Touch point coordinates. The device property contains 
the ID of the Touch point. When a Down event has occurred, the event 
can be identified by the  ID. 
Run the example again. To test out Multi Touch in an emulator, left -click 
two spots on the screen while holding down the Ctrl key on your keyboard. 
Then, a gray circle appears. To test out a Multi Touch Move event, drag 
the gray circle. Removing your finger from the Ctrl key makes the Multi 
Touch marks disappear.  
 
 
  

  
Page 354 / 978 4) Related APIs  
void evas_object_event_callback_add(Evas_Object *obj, Evas_Callback_Type 
type, Evas_Object_Event_Cb func, void *data): an API that specifies a 
callback function for an eva s object. Evas objects refer to all objects 
displayed on the screen. Therefore, evas objects include both basic objects 
(Line, Rect, Polygon, Text, and Image) and smart objects (containers and 
widgets). / parameters: object where an event occurs, type of t he event, 
name of the callback function, and user data. The event types are as 
follows:  
 - EVAS_CALLBACK_MOUSE_DOWN: Touch Down event  
- EVAS_CALLBACK_MOUSE_MOVE: Touch Move event  
- EVAS_CALLBACK_MOUSE_UP: Touch Cancel event  
- EVAS_CALLBACK_MULTI_DOWN: Mult i Touch Down event  
- EVAS_CALLBACK_MULTI_MOVE: Multi Touch Move event  
Evas_Event_Mouse_Down: Touch Down event information structure. 
Among the properties, the canvas property contains Touch point 
coordinates.  
Evas_Event_Mouse_Move: Touch Move event informa tion structure. Among 
the properties, the prev.canvas property contains the previous Touch point 
coordinates. cur.canvas contains the current Touch point coordinates.  
Evas_Event_Mouse_Up: Touch Cancel event information structure. Among 
the properties, the canvas property contains Touch point coordinates.  
  
  
Page 355 / 978 Evas_Event_Multi_Down: Multi Touch Down event information structure. 
Among the properties, the canvas property contains Touch point 
coordinates. The device property contains the ID of the Touch point. Whe n 
a Move event or an Up event has occurred, the event can be identified by 
the ID.  
Evas_Event_Multi_Move: Multi Touch Move event information structure. 
Among the properties of the object, the cur property contains Touch point 
coordinates. The device proper ty contains the ID of the Touch point. When 
a Down event has occurred, the event can be identified by the ID.   
  
Page 356 / 978 30. Calculator Example  
In this example, we are going to learn how to create a simple calculator 
using mathematical functions.  
 
1) Screen UI Composition  
Create a new source project and specify the project name as 'CalculatorEx.' 
After the source project is created, open the source file (~.c) under the src 
folder, add a new variable to the appdata structure, and also add a library 
header file an d define statements.  
┌─────────────────────┐  
#include "calculatorex.h"  
#include <math.h>  
  
#define ID_BACK                      101 
#define ID_CLEAR                     102 
#define ID_DOT                       103 
#define ID_EQUAL                     104 
#define ID_PLUS                      111 
#define ID_MINUS                     112 
#define ID_MULTIPLY              113 
#define ID_DIVIDE                    114 
#define ID_X2                        121 
#define ID_X3                        122 
#define ID_SQRT                      123 
#define ID_RECIPE                    124 
  
typedef struct appdata {  
  
Page 357 / 978     Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object * entry; 
    float value;  
    int calc_mode;  
} appdata_s;  
└─────────────────────┘  
math.h is the mathematical functions library header file.  
In define statements, define IDs for distinguishing between Buttons.  
In 'entry' that has been added to the appdata structure, the result of the 
calculation is displayed. In 'value', a temporary result of the calculation is 
stored. 
In calc_mode, the types of the calculation (+, - , *, /) are stored.  
In this example, a large number of Button widgets will be created. To 
reduce the source code, we are now going to create a Button -creating 
function. Add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
 
static void  
create_button(Evas_Object *parent, const char* text, int x, int y, int w, int h, void *da
ta) 
{ 
    Evas_Obje ct *btn = elm_button_add(parent);  
  
Page 358 / 978     elm_object_text_set(btn, text);  
    evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    elm_table_pack(parent, btn, x , y, w, h);  
    evas_object_smart_callback_add(btn, "clicked", btn_clicked_cb, data);  
    evas_object_show(btn);  
} 
└─────────────────────┘  
btn_clicked_cb() is the Button callback function. The same callback function 
will be called by multiple Buttons.  
create_button() is a function that receives Button -related information and 
creates a Button widget.  
We are now going to create a Box, a Table, and 22 Buttons. Add new code 
to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND); 
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Obj ect *box = elm_box_add(ad ->win);  
         
  
Page 359 / 978 evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
        elm_win_resize_object_add(ad ->win, box);  
        evas_object_show(box);  
        /* Table */  
        Evas_Object *table = elm_table_ add(ad ->win);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 10 * elm_ config_scale_get(), 10 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, 1.0);  
        elm_object_content_set(ad ->conform, table);  
        evas_object_show(table);  
 
        { /* child object - indent to how relationship */  
            /* Entry */  
            ad->entry = elm_entry_add(ad ->win);  
            elm_object_text_set(ad ->entry, "0");  
            evas_object_size_hint_weight_set(ad ->entry, EVAS_HINT_EXPAND, EVA S
_HINT_EXPAND);  
            evas_object_size_hint_align_set(ad ->entry, EVAS_HINT_FILL, EVAS_HINT
_FILL);  
            elm_table_pack(table, ad ->entry, 0, 0, 4, 1);  
            evas_object_show(ad ->entry);  
 
            create_button(table, "Back", 0, 1, 2, 1,  ID_BACK);  
            create_button(table, "Clear", 2, 1, 2, 1, ID_CLEAR);  
 
            create_button(table, "7", 0, 2, 1, 1, 7);  
            create_button(table, "8", 1, 2, 1, 1, 8);  
  
Page 360 / 978             create_button(table, "9", 2, 2, 1, 1, 9);  
            create_button(table, "/", 3, 2, 1, 1, ID_DIVIDE);  
 
            create_button(table, "4", 0, 3, 1, 1, 4);  
            create_button(table, "5", 1, 3, 1, 1, 5);  
            create_button(table, "6", 2, 3, 1, 1, 6);  
            create_button(table, "*", 3, 3, 1, 1 , ID_MULTIPLY);  
 
            create_button(table, "1", 0, 4, 1, 1, 1);  
            create_button(table, "2", 1, 4, 1, 1, 2);  
            create_button(table, "3", 2, 4, 1, 1, 3);  
            create_button(table, " -", 3, 4, 1, 1, ID_MINUS);  
 
            create_button(table, "0", 0, 5, 1, 1, 0);  
            create_button(table, ".", 1, 5, 1, 1, ID_DOT);  
            create_button(table, "=", 2, 5, 1, 1, ID_EQUAL);  
            create_button(table, "+", 3, 5, 1, 1, ID_PLUS);  
 
            create_button(table, "x^2", 0, 6, 1, 1, ID_X2);  
            create_button(table, "x^3", 1, 6, 1, 1, ID_X3);  
            create_button(table, "sqrt", 2, 6, 1, 1, ID_SQRT);  
            create_button(table, "1/x", 3, 6, 1, 1, ID_RECIPE);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
To place the widgets on the screen based on the aspect ratio, we created 
a Table. In addition, to specify the distance between the widgets, we 
created a Box.  
  
Page 361 / 978 To display calculation results, we created an Entry widget.  
The following is code that creates a total of 22 Button widgets. In the case 
of number Buttons, the relevant numeric value is passed to the callback 
function as user data. In the case of other Buttons, the ID value defined 
the define statement is passed as user data.  
Build and run the example. You can see an Entry widget at the top of the 
screen and 22 Button widgets below the Entry widget.  
 
 
2) Implementing the Number Button Feature  
In this section, we are going to implement a feature that, when a number 
Button between Button 0 and Button 9 is clicked, adds the relevant 
number to a Label widget. First, declare appdata as a global variable.  
┌─────────────────────┐  
typedef struct appdat a { 
    Evas_Object *win;  

  
Page 362 / 978     Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *nf;  
    Elm_Object_Item *frame_item;  
    float value;  
    int calc_mode;  
} appdata_s;  
  
appdata_s* m_ad = 0;  
└─────────────────────┘  
Then, initialize the appdata variable at the beginning of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    m_ad = ad;  
└─────────────────────┘  
We are now going to create a function that converts the caption text of 
an Entry into a  number and also create a function that adds text to an 
Entry widget. Add two new functions on top of the btn_clicked_cb() 
function.  
┌─────────────────────┐  
static float  
get_entry_value()  
{ 
    char* text = elm_object_text_get(m_ad ->entry);  
    float value  = atof(text);  
    return value;  
  
Page 363 / 978 } 
 
static void  
append_number_label(char str_new) {  
    char buf[100];  
 
    char* text = elm_object_text_get(m_ad ->entry);  
    float value = get_entry_value();  
    if( value == 0.f )  
        sprintf(buf, "%c", str_new);  
    else 
        sprintf(buf, "%s%c", text, str_new);  
 
    elm_object_text_set(m_ad ->entry, buf);  
} 
└─────────────────────┘  
get_entry_value() is a function that coverts the caption text of an Entry 
into the float type and then returns it.  
append_number_lab el() is a function that receives the char variable and 
adds it at the end of the caption text of an Entry.  
This function needs to be called when the user taps a number Button. Add 
the following code to the btn_clicked_cb() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    char* text = NULL;  
    int length = 0;  
    float value = 0.f;  
  
Page 364 / 978     int id = (int)data;  
  
    if( id >= 0 && id <= 9 )  
    { 
        append_number_label('0' + id);  
        return; 
    } 
} 
└─────────────────────┘  
If the user data is a number between 0 and 9, the Button is deemed a 
number Button, and new text is added to the caption text of a Label 
widget.  
Run the example again. Click a number Button, and then the relevant value 
is added to the Label widget.  
 
 
  

  
Page 365 / 978 3) Implementing the Dot, Clear, and Back Button Features  
In this section, we are going to implement the ‘.’ button, Back button, and 
Clear button features. Add new code at the end of the btn_clicked_cb() 
function.  
┌────── ───────────────┐  
    if( id >= 0 && id <= 9 )  
    { 
        append_number_label('0' + id);  
        return;  
    } 
  
    switch( id )  
    { 
    case ID_DOT :  
        append_number_label('.');  
        break;  
    case ID_CLEAR :  
        elm_object_text_set(m_a d->label, "0");  
        break;  
    case ID_BACK :  
        text = elm_object_text_get(m_ad ->label);  
        length = strlen(text);  
        if( length > 0 )  
            text = eina_stringshare_add_length(text, length - 1); 
        if( strlen(text) < 1 )  
            text = "0";  
        elm_object_text_set(m_ad ->label, text);  
        break;  
    } 
} 
└─────────────────────┘  
  
Page 366 / 978 If the user has clicked the '.' button, it adds the '.' symbol to the end of 
the Label text.  
If the user has tapped the Clear button, thi s code changes the Label text 
to '0.' 
If the user has tapped the Back button, this code deletes the last character 
of the Label text.  
eina_stringshare_add_length(char*, unsigned int) is an API that extracts a 
specified length of characters from the beginni ng of a string.  
Run the example again. Tap the '.' button on the keypad, and the symbol 
‘.’ is added at the right end of the Label text.  
Tap the Back button, and one character at the right end of the Label text 
is deleted.  
Tap the Clear button, and the ent ire text is changed to '0.'  
 
 

  
Page 367 / 978 4) Arithmetic Operations  
In this section, we are going to create a function that enters a float type 
value in a Label widget and performs an arithmetic operation when the 
‘=’ button is tapped. Add two new functions on top of the btn_clicked_cb() 
function.  
┌─────────────────────┐  
static void  
set_entry_value(float value)  
{ 
    char buf[100];  
    sprintf(buf, "%f", value);  
    elm_object_text_set(m_ad ->entry, buf);  
} 
 
static void  
btn_equal_clicked()  
{ 
    float value2 = get_entry_value();  
 
    switch( m_ad ->calc_mode )  
    { 
    case ID_PLUS :  
        m_ad->value += value2;  
        break;  
    case ID_MINUS :  
        m_ad->value -= value2;  
        break;  
    case ID_MULTIPLY :  
        m_ad->value *= valu e2; 
        break;  
    case ID_DIVIDE :  
  
Page 368 / 978         m_ad->value /= value2;  
        break;  
    } 
 
    set_entry_value(m_ad ->value);  
} 
└─────────────────────┘  
set_label_value() is a function that receives a real number, converts it into 
a string, and then enters  it in a Label widget.  
btn_equal_clicked() is a function that performs computation using two 
numbers according to the type of the arithmetic operation.  
Add new code to the btn_clicked_cb() function.  
┌─────────────────────┐  
    ~ 
    case ID_BACK :  
        text = elm_object_text_get(m_ad ->label);  
        length = strlen(text);  
        if( length > 0 )  
            text = eina_stringshare_add_length(text, length - 1); 
        if( strlen(text) < 1 )  
            text = "0";  
        elm_object_text_set(m_ad ->label, text);  
        break;  
    case ID_PLUS :  
    case ID_MINUS :  
    case ID_MULTIPLY :  
    case ID_DIVIDE :  
        m_ad->value = get_label_value();  
        elm_object_text_set(m_ad ->label, "0");  
        m_ad->calc_mode = id;  
        break;  
  
Page 369 / 978     case ID_EQU AL : 
        btn_equal_clicked();  
        break;  
    } 
} 
└─────────────────────┘  
When the user taps the Arithmetic Operations button, this code converts 
Entry text into numbers and stores them in a global variable;  
it changes Entry text to '0' and then stores the type of the arithmetic 
operation in a global variable.  
When the user taps the ‘=’ button, this code calls the btn_equal_clicked() 
function.  
Run the example again. Then, enter '11' and tap the '+' Button. The 
number '0' is displayed in the Entry widget.  
Then, enter ‘35’ and tap the ‘=’ button. The result of the operation is 
displayed in the Entry widget.  
It is recommended that you test out subtraction, multiplication, and 
division as well.  
           
  

  
Page 370 / 978 5) Calculating the Square and Square Root of a Number  
In this section, we are going to calculate the square and square root of a 
number using mathematical functions. Add new code at the end of the 
btn_clicked_cb() function.  
┌─────────────────────┐  
    ~ 
    case ID_EQUAL :  
        btn_equal_clicke d(); 
        break;  
    case ID_X2 :  
        value = get_label_value();  
        value = pow( value, 2 );  
        set_label_value(value);  
        break;  
    case ID_X3 :  
        value = get_label_value();  
        value = pow( value, 3 );  
        set_label_v alue(value);  
        break;  
    case ID_SQRT :  
        value = get_label_value();  
        value = sqrt( value );  
        set_label_value(value);  
        break;  
    case ID_RECIPE :  
        value = get_label_value();  
        value = 1.f / value;  
        set_label_value(value);  
        break;  
    } 
} 
└─────────────────────┘  
  
  
Page 371 / 978 pow(double, double) is a mathematical function that calculates the square 
of a number. Passing 2 to the second parameter returns the square of the 
number, while passing 3 retu rns the cube of the number.  
sqrt(double) is a mathematical function that calculates the square root of 
a number.  
To request the inverse number of a number, divide 1 by the number.  
Run the example again. Enter the number 3 and tap the ‘x^2’ button, and 
the square of the number is then displayed.  
Tapping the ‘sqrt’ button in that status calculates the square root of the 
calculated value and in turn displays the original numerical value of the 
number.  
Tapping the '1/x' Button displays the inverse number of the  number.  
       
 
  

  
Page 372 / 978 6) Related APIs  
double pow(double, double): an API that is the mathematical function for 
calculating the square of a number. / parameters: original number and 
raise power.  
double sqrt(double): an API that calculates the square root of  a number. / 
parameters: original number.  
  
  
Page 373 / 978 31. Displaying a Gradient on the  Canvas  
It is common for newcomers to app development to ask   
what skills are essential for success in the field.   
The answer is invariably that they need good graphics/rendering skil ls first 
and foremost.  
Second, good Object Oriented Programming (OOP) skills are required.  
As time passes, app development is becoming increasingly easy. In the 
past, it was commonplace for developers to implement features 
themselves through hard coding. T hese days, however, platforms provide 
a variety of features, and developers only need to call and use APIs already 
provided by platforms.  
Graphics is the most difficult part and still demands a lot of effort when 
developing a commercial smartphone app. Whe n two given apps have the 
same features, the user chooses the one with better graphics. The most 
essential quality required of the app developer is the skill to implement 
diverse and impressive graphics that suit the user's taste.  
Evas is the canvas provid ed in EFL. All shapes drawn on Evas get created 
as objects. In this example, we are going to learn how to draw a line on 
this canvas.  
 
  
  
Page 374 / 978 1) Creating a Canvas and Drawing a Gradient  
Create a new source project and specify the project name as 
'DrawGradiation .' After the source project is created, open the source file 
(~.c) under the src folder and add new code at the top as shown below:  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    //Evas_Object *label;  
    Evas_Object *imgs[5];  
} appdata_s;  
 
static Evas_Object *  
create_gradient_rect(appdata_s *ad)  
{ 
    /* Generate gradient data on the fly */  
    const int colors[2][4] = {  
            /* red to blue */  
            { 255, 0, 0, 255 }, { 0, 0, 255, 255 },  
    }; 
 
    const int b_r = colors[0][0], b_g = colors[0][1], b_b = colors[0][2], b_a = col
ors[0][3];  
    const int e_r = colors[1][0], e_g = colors[1][1], e_b = colors[1][2], e_a = col
ors[1][3];  
 
    Evas_Object *img;  
    unsigned int *data32;  
 
    /* Create image object, set its image data size & type */  
    Evas* canvas = evas_object_evas_get(ad ->win);  
    img = evas_object_image_filled_add(canvas);  
    /* BGRA data */  
  
Page 375 / 978     evas_object_image_colorspace_set(img, EVAS_COLORSPACE_ARGB8888);  
    /* Size is 255x1 */  
    evas_object_image_size_set(img, 255, 1);  
    /* Mark image as having alpha */  
    evas_object_image_alpha_set(img, EINA_TRUE);  
 
    /* get a writable data pointer */  
    data32 = evas_object_image_data_get(img, EINA_TRUE);  
 
    for (un signed x = 0; x < 255; x++)  
    { 
        int r, g, b, a;  
        /* interpolate alpha */  
        a = (b_a * (255 - x) + e_a * x) / (2 * 255);  
        /* interpolate red */  
        r = (b_r * b_a * (255 - x) + e_r * e_a * (x)) / (2 * 255 * 255);  
        /* interpolate green */  
        g = (b_g * b_a * (255 - x) + e_g * e_a * (x)) / (2 * 255 * 255);  
        /* interpolate blue */  
        b = (b_b * b_a * (255 - x) + e_b * e_a * (x)) / (2 * 255 * 255);  
        /* write pixel value now */  
        data32[x] = (a << 24) | (r << 16) | (g << 8) | b;  
    } 
 
    /* very important: set data back */  
    evas_object_image_data_set(img, data32);  
 
    evas_object_size_hint_weight_set(img, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    evas_object_size_hint_align_set(i mg, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_show(img);  
    return img;  
} 
└─────────────────────┘  
  
Page 376 / 978 To draw a picture on the screen, you need to use a canvas called Evas. In 
this section, we are going to create five Image objects. imgs[5] added to 
the appdata structure is an array variable that stores an Image object.  
create_gradient_rect() is a function that creates and then returns a 
gradated Image object. The following are descriptions of the functions:  
colors[2][4] is an array variable that stores  two kinds of colors. One is the 
gradient start color, and the other is the gradient end color. A color 
consists of a total of four numeric values. The numeric values listed in 
order are Red, Green, Blue, and Alpha (semi -transparent).  
evas_object_evas_get( ) is an API that creates an Evas object.  
evas_object_image_filled_add() is an API that creates an Image object.  
evas_object_image_colorspace_set() is an API that specifies the color space 
of an Image object. Passing EVAS_COLORSPACE_ARGB8888 to the second 
parameter lets one pixel consist of four different data (Red, Green, Blue, 
and Alpha).  
evas_object_image_size_set() is an API that specifies the size of an Image 
object. Passing 255 to the second parameter makes the number of 
horizontal pixels be 255. Pass ing 1 to the third parameter makes the 
number of vertical pixels be 1.  
evas_object_image_alpha_set() is an API that specifies whether to apply 
semi-transparency to an Image object.  
  
  
Page 377 / 978 evas_object_image_data_get() is an API that returns the original data of an 
Image object as an array.  
evas_object_image_data_set() performs the opposite function of 
evas_object_image_data_get(). It is an API that specifies original data for 
an Image object.  
We are now going to create and display a gradated Image object on the 
screen using this function. Add new code to the create_base_gui() function. 
Label will not be used in this example, so annotate it.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_objec t_show(ad ->conform);  
 
    Evas_Object *box = elm_box_add(ad ->conform);  
    elm_box_padding_set(box, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        ad->imgs[0] = create_gradient_rect(ad);  
        elm_box_pack_end(box, ad ->imgs[0]);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘   
  
Page 378 / 978 We created a Box object and an Image object and displayed them on the 
screen. Run the example. A gradated square whose left side is in red and 
whose right side is in blue is displayed on the screen.  
 
 
2) Creating Various Gradated Squares  
In this section, we are going to implement a feature in the 
create_gradient_rect() function we created in the previous section that 
creates four different kinds of gradated squares. Modify the code as 
follows:  
┌─────────────────────┐  
static Evas_Object *  
create_gradient_rect(appdata_s *ad, unsigned i)  
//create_gradient_rect(appdata_s *ad ) 
{ 
    /* Generate gradient data on the fly */  
    const int colors[8][4] = {  
        /* red to blue */  
        { 255, 0, 0, 255 }, { 0, 0, 255, 255 },  
        /* black to transparent */  
        { 0, 0, 0, 255 }, { 0, 0, 0, 0 },  
        /* green to orange  */ 
        { 0, 255, 0, 255 }, { 255, 128, 0, 255 },  

  
Page 379 / 978         /* yellow to cyan */  
        { 255, 255, 0, 255 }, { 0, 255, 255, 255 }  
    }; 
    /*const int colors[2][4] = {  
         red to blue  
        { 255, 0, 0, 255 }, { 0, 0, 255, 255 },  
    };*/ 
 
    const int b_r = colors[i*2][0], b_g = colors[i*2][1], b_b = colors[i*2][2], b_a 
= colors[i*2][3];  
    const int e_r = colors[i*2+1][0], e_g = colors[i*2+1][1], e_b = colors[i*2+1]
[2], e_a = colors[i*2+1][3];  
 
    Evas_Object *img;  
    unsigned int *data32;  
└─────────────────────┘  
Calling the function above four times will create four different gradated 
Images. Modify the bottom of the create_base_gui() function as follows:  
┌─────────────────────┐  
    { 
        //ad->imgs[0] = create _gradient_rect(ad);  
        //elm_box_pack_end(box, ad ->imgs[0]);  
        for (unsigned i = 0; i < 4; i++)  
        { 
            ad->imgs[i] = create_gradient_rect(ad, i);  
            elm_box_pack_end(box, ad ->imgs[i]);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
  
Page 380 / 978 Run the example again. Four gradated squares are displayed on the screen.  
 
 
3) Creating a Rainbow Square Using an Image File  
In this section, we are going to display a rainbow square on the screen 
using an Image file. Copy the rainbow.png file under the appendix’s 
/Image folder to the /res folder of the source project.  
 
Now, we need to let source code load the Image file and assign it to the 
Image object. Go to the sour ce file and add a new function on top of the 
create_base_gui() function.   

  
Page 381 / 978 ┌─────────────────────┐  
static Evas_Object *  
create_rainbow_rect(appdata_s *ad)  
{ 
    /* A much simpler method for gradients is to simply use an image from disk *
/ 
    Evas_Object *i mg; 
    char path[PATH_MAX];  
 
    /* Create image object, set its image data size & type */  
    Evas* canvas = evas_object_evas_get(ad ->win);  
    img = evas_object_image_filled_add(evas_object_evas_get(canvas));  
 
    snprintf(path, sizeof(path), "%s/rainbo w.png", app_get_resource_path());  
    dlog_print(DLOG_ERROR, LOG_TAG, "path: '%s'", path);  
    evas_object_image_file_set(img, path, NULL);  
 
    evas_object_size_hint_weight_set(img, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    evas_object_size_hint_align_set( img, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_show(img);  
    return img;  
} 
└─────────────────────┘  
evas_object_image_file_set() is an API that, by specifying the path of an 
image file for an Image object, loads the file.  
We are now going to load and display the Image file on the screen using 
the function above. Add new code to the create_base_gui() function.  
  
  
Page 382 / 978 ┌─────────────────────┐  
    { 
        for (unsigned i = 0; i < 4; i++)  
        { 
            ad->imgs[i] = create_gradient_rect(ad, i);  
            elm_box_pack_end(box, ad ->imgs[i]);  
        } 
 
        ad->imgs[5] = create_rainbow_rect(ad);  
        elm_box_pack_end(box, ad ->imgs[5]);  
    } 
└─────────────────────┘  
Run the example again, and you will now see a rainbow square displayed 
at the b ottom of the screen.  
 
 
  

  
Page 383 / 978 4) Related APIs  
Evas *evas_object_evas_get(Evas_Object *obj): an API that creates an Evas 
object. / parameters: Window object.  
evas_object_image_filled_add() is an API that creates an Image object.  
evas_object_image_colorspace_set() is an API that specifies the color space 
of an Image object. Passing EVAS_COLORSPACE_ARGB8888 to the second 
parameter lets one pixel consist of four different data (Red, Green, Blue, 
and Alpha).  
evas_object_image_size_set () is an API that specifies the size of an Image 
object. Passing 255 to the second parameter makes the number of 
horizontal pixels be 255. Passing 1 to the third parameter makes the 
number of vertical pixels be 1.  
evas_object_image_alpha_set() is an API th at specifies whether to apply 
semi-transparency to an Image object.  
evas_object_image_data_get() is an API that returns the original data of an 
Image object as an array.  
evas_object_image_data_set() performs the opposite function of 
evas_object_image_data_ get(). It is an API that specifies original data for 
an Image object.  
evas_object_image_file_set() is an API that, by specifying the path of an 
image file for an Image object, loads the file.  
  
  
Page 384 / 978 32. Displaying a Square on the  Canvas  
To draw a shape on the screen, you need to use a canvas. Evas is the 
canvas provided in EFL. All shapes drawn on Evas get created as objects. 
In this example, we are going to learn how to draw a square on the canvas.  
 
1) Creating a Canvas and Drawing a Square  
Create a new source  project and specify the project name as 'DrawRect.' 
After the source project is created, open the source file (~.c) under the src 
folder and add new code to the create_base_gui() function. Label will not 
be used in this example, so annotate it.  
┌───────── ────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=center>Hello EF L</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
  
Page 385 / 978     { /* child object - indent to how relationship */  
        /* A grid to stretch content within grid size */  
        Evas_Object *grid = elm_grid_add(ad ->win);  
        evas_object_size_hint_weight_set(grid, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, grid);  
        evas_object_show(grid);  
 
        { 
            /* Canvas */  
            Evas* canvas = evas_object_evas_get(ad ->win);  
 
            /* Rect -1 */ 
            Evas_Object *rect = evas_object_rectangle_add(canvas);  
            evas_object_color_set(rect, 255, 0, 0,  192); 
            evas_object_show(rect);  
            elm_grid_pack(grid, rect, 4, 5, 52, 31);  
       } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
elm_grid_add() is an API that creates a Gr id container. Grid is a container 
that enables placing objects on the screen based on the aspect ratio. The 
difference with Table is that Table divides areas by cell and that the 
maximum value is specified as 100 by default.  
elm_grid_pack() is an API that places objects in a Grid container. The first 
parameter indicates the Grid; the second parameter indicates the object; 
the third parameter indicates the horizontal position; the fourth parameter 
indicates the vertical position; the fifth parameter indicate s the width; and 
  
Page 386 / 978 the sixth parameter indicates the height. Passing 4 to the third parameter 
places the object in the position that is 4% in the horizontal direction.  
elm_grid_size_set(obj, w, h) is an API that specifies the size of a Grid. The 
default size  of a Grid is 100 in width and 100 in height.  
evas_object_evas_get(Evas_Object *) is an API that creates an Evas object.  
evas_object_rectangle_add(Evas *) is an API that creates a Rectangle object 
on a canvas.  
evas_object_color_set(Evas_Object *, int, int,  int, int) is an API that specifies 
a color for a shape. The parameters listed in order are Red, Green, Blue, 
and semi -transparency. Entering 255, 0, 0, 192 creates a semi -transparent 
red. 
Build and run the example. A pink -colored square is displayed on th e 
screen. We specified red for the square. However, because semi -
transparency has been applied to the square, it looks pink.  
 
 
  

  
Page 387 / 978 2) Overlaying Two Semi -Transparent Squares  
In this section, we are going to see how the colors change when we add 
two squares and then overlay them. Add new code to the create_base_gui() 
function.  
┌─────────────────────┐  
            /* Rect -1 */ 
            Evas_Object *rect = evas_object_rectangle_add(canvas);  
            evas_object_color_set(rect, 255, 0, 0, 192);  
            evas_object_show(rect);  
            elm_grid_pack(grid, rect, 4, 5, 52, 31);  
 
            /* Rect -2 */ 
            rect = evas_object_rectangle_add(canvas);  
            evas_object_color_set(rect, 0, 255, 0, 192);  
            evas_object_show(rect);  
            elm_grid_pack(grid, rect, 44, 5, 52, 31);  
 
            /* Rect -3 */ 
            rect = evas_object_rectangle_add(canvas);  
            evas_object_color_set(rect, 0, 0, 255, 192);  
            evas_object_show(rect);  
            elm_grid_pack(grid, rect, 24, 29, 52, 31);  
       } 
    } 
└─────────────────────┘  
We specified the color of the second square as a semi -transparent green.  
We specified the color of the third square as a semi -transparent blue.  
Run the example ag ain. Three squares are displayed on the screen.  
  
Page 388 / 978 The colors of the overlaid areas change to their intermediate colors 
because semi -transparency has been applied.  
 
 
3) Related APIs  
Evas *evas_object_evas_get(Evas_Object *obj): an API that creates an Evas 
object. / parameters: Window object.  
Evas_Object *evas_object_rectangle_add(Evas *e): an API that creates a 
Rectangle object on a canvas.  
void evas_object_color_set(Evas_Object *obj, int r, int g, int b, int a): an API 
that specifies a color for a shape. / p arameters: shape object, Red, Green, 
Blue, and semi -transparency. The allowed range of color values is 0 to 255. 
For example, if you want to create the Yellow, enter 255,255,0,255.  
  

  
Page 389 / 978 33. Displaying Polygons on the  Canvas  
To draw a shape on the screen, you need  to use a canvas. Evas is the 
canvas provided in EFL. All shapes drawn on Evas get created as objects. 
In this example, we are going to learn how to draw polygons on the canvas.  
 
1) Creating a Canvas & Drawing a Triangle  
Create a new source project and spe cify the project name as 
'DrawPolygon.' After the source project is created, open the source file 
(~.c) under the src folder and add new code to the create_base_gui() 
function. Label will not be used in this example, so annotate it.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=center>Hello EFL< /align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
  
Page 390 / 978     { 
        /* Canvas */  
        Evas* canvas = evas_object_evas_get(ad ->win);  
 
        /* Polygon - Triangle */  
        Evas_Object *polygon = evas_object_polygon_add(canvas);  
        evas_object_polygon_point_add(polygon, 20, 50);  
        evas_object_polygon_point_add(polygon, 170, 150);  
        evas_object_polygon_point_add(polygon, 20, 250);  
        evas_object_color_set(polygon, 255, 200, 0, 255);  
        evas_object_show(polygon);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
evas_object_evas_get(Evas_Object *) is an API that creates an Evas object.  
evas_object_polygon_add(Evas *) is an API that creates a Polygon object 
on a canvas.  
evas_object_polygon_point_add(Evas_Object *, Evas_Coord, Evas_Coord) is 
an API that adds point coordinates to a Polygon object. A Polygon must 
have at least t hree points. The first parameter indicates the Polygon object; 
the second parameter indicates the x -coordinate; and the third parameter 
indicates the y -coordinate.  
evas_object_color_set(Evas_Object *, int, int, int, int) is an API that specifies 
a color for a shape. The parameters listed in order are the shape object, 
Red, Green, Blue, and semi -transparency.   
  
Page 391 / 978 Build and run the example. A yellow triangle is displayed on the screen.  
 
 
2) Displaying a Pentagon  
Adding four points to a Polygon object creates a square while adding five 
points creates a pentagon. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
        /* Polygon - Triangle */  
        Evas_Object *polygon = evas_object_polygon_add(canvas);  
        evas_object_polygon_point _add(polygon, 20, 50);  
        evas_object_polygon_point_add(polygon, 170, 150);  
        evas_object_polygon_point_add(polygon, 20, 250);  
        evas_object_color_set(polygon, 255, 200, 0, 255);  
        evas_object_show(polygon);  
 
        /* Polygon - Pentagon */  
        polygon = evas_object_polygon_add(canvas);  
        evas_object_polygon_point_add(polygon, 360, 50);  
        evas_object_polygon_point_add(polygon, 460, 130);  
        evas_object_polygon_point_add(polygon, 410, 230);  
        evas_object_pol ygon_point_add(polygon, 310, 230);  
        evas_object_polygon_point_add(polygon, 260, 130);  
        evas_object_color_set(polygon, 255, 128, 128, 255);  
        evas_object_show(polygon);  
    } 

  
Page 392 / 978 └─────────────────────┘  
We created a new Polygon object and added five points to it.  
Run the example again, and you will now see a pink pentagon displayed 
on the screen.  
 
 
3) Drawing a Regular Polygon Using a Polygon  
Regular polygons are shapes all of whose angles are equal in measure and 
all of whose sides have t he same length, such as squares and regular 
hexagons. In this section, we are going to create a function that creates a 
regular polygon. Because we will use mathematical functions, include the 
library at the top of the source file.  
┌─────────────────────┐  
#include "drawpolygon.h"  
#include <math.h>  
└─────────────────────┘  
Create a new function on top of the create_base_gui() function. This 
function creates a regular polygon.  
┌─────────────────────┐  
static Evas_Object*  
  

  
Page 393 / 978 crate_circle(Evas* canvas, int x, int y, int radius, int r, int g, int b, int a, int edge_cou
nt) 
{ 
    int x1, y1, x2, y2;  
    float angle=0.f;  
  
    Evas_Object *polygon = evas_object_polygon_add(canvas);  
  
    for(int i=0; i < edge_count; i++)  
    { 
        angle = (M_PI * 2) / (float)edge_count * i;  
        x1 = sin(angle) * radius + x;  
        y1 = cos(angle) * radius + y;  
        evas_object_polygon_point_add(polygon, x1, y1);  
    } 
    evas_object_color_set(polygon, r, g, b, a);  
    evas_object_show(polygon);  
    return polyg on; 
} 
└─────────────────────┘  
M_PI is a constant that contains the Pi value.  
sin(double) is an API that calculates sine. The unit of angle is Pi. For 
example, to specify the sine as 180 degrees, pass Pi, and to specify the 
sine as 90 degrees, pass Pi /2.  
cos(double) is an API that calculates cosine. The unit of angle is Pi.  
We are now going to create a regular octagon using the functions above. 
Add a new line of code at the end of the create_base_gui() function.  
┌─────────────────────┐  
  
Page 394 / 978         /* Polygon - Pentagon */  
        polygon = evas_object_polygon_add(canvas);  
        evas_object_polygon_point_add(polygon, 360, 50);  
        evas_object_polygon_point_add(polygon, 460, 130);  
        evas_object_polygon_point_add(polygon, 410, 230);  
        evas_object_ polygon_point_add(polygon, 310, 230);  
        evas_object_polygon_point_add(polygon, 260, 130);  
        evas_object_color_set(polygon, 255, 128, 128, 255);  
        evas_object_show(polygon);  
 
        /* Polygon - 10 */ 
        crate_circle(canvas, 180, 340 , 100, 128, 128, 255, 255, 8);  
    } 
└─────────────────────┘  
The create_circle() function’s parameters listed in order are the Evas object, 
center x -coordinate, center y -coordinate, radius, Red, Green, Blue, semi -
transparent color, and number of points.  
Run the example again, and you will now see a purple regular octagon 
displayed on the screen.  
 
 
  

  
Page 395 / 978 4) Drawing a Circle Using the Polygon Widget  
If you increase the number of points of a regular polygon, it will eventually 
look like a circle. Add a new line  of code at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
        /* Polygon - 10 */ 
        crate_circle(canvas, 180, 340, 100, 128, 128, 255, 255, 8);  
 
        /* Polygon - Circle */  
        crate_circle(canvas, 280, 600, 1 60, 0, 255, 0, 255, 90);  
    } 
└─────────────────────┘  
We added 90 points to a polygon. We are now going to see the result of 
this addition.  
Run the example again, and you will now see a yellow -green regular 90 -
angle polygon displayed on the screen. Due to the po lygon’s great number 
of points, it looks like a circle.  
  
Page 396 / 978  
 
5) Related APIs  
Evas *evas_object_evas_get(Evas_Object *obj): an API that creates an Evas 
object. / parameters: Window object.  
Evas_Object *evas_object_polygon_add(Evas *e): is an API that creates a 
Polygon object on a canvas.  
void evas_object_polygon_point_add(Evas_Object *obj, Evas_Coord x, 
Evas_Coord y): an API that adds point coordinates to a Polygon object. / 
parameters: Polygon, x -coordinate, and y -coordinate.  
void evas_object_color_set(Evas_Object *obj, int r, int g, int b, int a): an API 
that specifies a color for a shape. / parameters: shape object, Red, Green, 
Blue, and semi -transparency. The allowed range of color values is 0 to 255. 
For example, if you want to create the Yellow, enter 255,255,0,255.   

  
Page 397 / 978 34. Displaying Text on the  Canvas  
To draw a shape on the screen, you need to use a canvas. Evas is the 
canvas provided in EFL. All shapes drawn on Evas get created as objects. 
In this example, we are going to learn how to display a string on a canvas.  
 
1) Displaying Text on the  Canvas  
Create a new source project and specify the project name as 
'CanvasTextColor.' After the source project is created, open the source file 
(~.c) under the src folder and add a text object cre ating function on top 
of the create_base_gui() function.  
┌─────────────────────┐  
// Create Text object  
static Evas_Object *  
create_text(Evas *canvas, Evas_Object *grid,  
            Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h,  
            const c har *str, int font_size,  
            int r, int g, int b, int a)  
{ 
   Evas_Object *text = evas_object_text_add(canvas);  
   evas_object_text_text_set(text, str);  
   evas_object_text_font_set(text, "DejaVu", font_size);  
   evas_object_color_set(text, r, g, b , a); 
   elm_grid_pack(grid, text, x, y, w, h);  
   evas_object_show(text);  
} 
└─────────────────────┘  
  
Page 398 / 978 evas_object_text_add(Evas *) is an API that creates a text object on a canvas.  
evas_object_text_text_set(Evas_Object *, char *) is an API that specifies a 
string for a text object.  
evas_object_text_font_set(Evas_Object *, char *, Evas_Font_Size) is an API 
that specifies a font for a text object. The first parameter indicates the text 
object, the second parameter indicates the font type, and the third 
paramet er indicates the font size.  
We are now going to display text on the canvas using the function we just 
created. Add new code to the create_base_gui() function. Label will not be 
used in this example, so annotate it.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVA S_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
    /* child object - indent to how relationship */  
  
Page 399 / 978     /* A grid to stretch content within grid size */  
    Evas_Obj ect *grid = elm_grid_add(ad ->win);  
    elm_grid_size_set(grid, 480, 800);  
    evas_object_size_hint_weight_set(grid, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    elm_object_content_set(ad ->conform, grid);  
    evas_object_show(grid);  
 
    { /* child object - indent to how relationship */  
        Evas* canvas = evas_object_evas_get(ad ->win);  
 
        create_text(canvas, grid, 50, 100, 300, 100,  
                "Hello World!", 60, 80, 80, 255, 255);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Grid container to assign relative coordinates to the text 
object.  
elm_grid_size_set() is an API that changes the size of a Grid. The default 
width of a Grid is 100, and the default height is 100 as well. We changed 
the size of a Grid to 480 x 800 in the code above. This new setting enables 
more precise placement than the default setting.  
Create an Evas object using the evas_object_evas_get() function.  
Create a text object using the create_t ext() function. The parameters listed 
in order are the canvas object, Grid, x -coordinate, y -coordinate, width, 
height, text string, font size, Red, Green, Blue, and semi -transparent color.  
  
Page 400 / 978 Build and run the example. The text 'Hello World' is displayed on t he 
screen in purple.  
 
 
2) Applying a Shadow to Text  
To apply a shadow effect to text, you need to display two texts after 
specifying a different color and a different position for each. Add new 
code to the create_base_gui() function. We created the second  text with 
the same content and size as the first text.  
┌─────────────────────┐  
    { /* child object - indent to how relationship */  
        Evas* canvas = evas_object_evas_get(ad ->win);  
 
        create_text(canvas, grid, 54, 104, 300, 100,  
                "Hello World!", 60, 120, 120, 120, 255);  
 
        create_text(canvas, grid, 50, 100, 300, 100,  
                "Hello World!", 60, 80, 80, 255, 255);  
    } 
└─────────────────────┘  
The second text will become the shadow and will be displayed before the 
first text. In addition, the position will be different, and its color is gray.  

  
Page 401 / 978 Run the example again. A shadow effect has been applied to text.  
 
 
3) Related APIs  
Evas *evas_object_evas_get(Evas_Object *obj): an API that creates an Evas 
object. / parameters: Window object.  
Evas_Object *evas_object_text_add(Evas *e): an API that creates a text 
object on a canvas.  
void evas_object_text_text_set(Evas_Object *obj, const char *text): an API 
that specifies a string for a text object.  
void evas_object_tex t_font_set(Evas_Object *obj, const char *font, 
Evas_Font_Size size): an API that specifies a font or a text object. / 
parameters: text object, font type, and font size.  
void evas_object_color_set(Evas_Object *obj, int r, int g, int b, int a): an API 
that specifies a color for a shape. / parameters: shape object, Red, Green, 
Blue, and semi -transparency. The allowed range of color values is 0 to 255. 
For example, if you want to create the Yellow, enter 255,255,0,255.  
  

  
Page 402 / 978 35. Displaying an Image on the Canvas  
To dra w a shape on the screen, you need to use a canvas. Evas is the 
canvas provided in EFL. All shapes drawn on Evas get created as objects. 
In this example, we are going to learn how to display an image on a 
canvas.  
 
1) Displaying an Image on the Canvas  
Create  a new source project and specify the project name as ‘CanvasImage.’ 
In this example, we need to use an image file. Copy the tizen_logo.png 
file under the appendix’s /Image folder to the /res folder of the source 
project.  
 
To use the image file we just co pied, we need to find the absolute path 
of the image file. After the source project is created, open the source file 
(~.c) under the src folder and add a new function to the create_base_gui() 
function. This function returns the absolute path of a file stor ed under the 
/res folder.   

  
Page 403 / 978 ┌─────────────────────┐  
static void  
app_get_resource(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_resource_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
└─────────────────────┘  
Go back to the create_base_gui() function and add new code. This code 
creates a canvas and loads an image file to create an Image object. 
Annotate the Label -creating co de. 
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint _weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=c enter>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
  
Page 404 / 978     { /* child object - indent to how relationship */  
        /* A grid to stretch conten t within grid size */  
        Evas_Object *grid = elm_grid_add(ad ->win);  
        elm_grid_size_set(grid, 480, 800);  
        evas_object_size_hint_weight_set(grid, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, grid);  
        evas_object_show(grid);  
 
        { 
            /* Canvas */  
            Evas* canvas = evas_object_evas_get(ad ->win);  
 
            char img_path[PATH_MAX] = "";  
            app_get_resource("tizen_logo.png", img_path, PATH_MAX);  
 
            /* Image -1 */ 
            Evas_Object *img = evas_object_image_filled_add(canvas);  
            evas_object_image_file_set(img, img_path, NULL);  
            elm_grid_pack(grid, img, 40, 10, 400, 280);  
            evas_object_show(img);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Grid container to assign relative coordinates to the Image 
object. To assign more precise coordinates to the image object, we 
specifi ed the size of the Grid as 480x800 using the elm_grid_size_set() 
function.  
  
Page 405 / 978 evas_object_image_filled_add(Evas *) is an API that creates an Image object 
that lets an original image fill the entire space of an area.  
evas_object_image_file_set(Evas_Object *, c har *, char *) is an API that loads 
an image file into an Image object.  
Build and run the example. An image is displayed on the screen. You will 
now see the original image is long horizontally but also has been stretched 
vertically.  
 
 
2) Displaying an Ima ge on the Canvas in Tile Format  
In this section, we are going to learn how to place images in a given area 
in a tile format. Add new code at the end of the create_base_gui() function. 
This code creates a second Image object.  
┌─────────────────────┐  
            /* Image -1 */ 
            Evas_Object *img = evas_object_image_filled_add(canvas);  
            evas_object_image_file_set(img, img_path, NULL);  
            elm_grid_pack(grid, img, 40, 10, 400, 280);  
            evas_object_show(img);  
 
            /* Image -2 */ 

  
Page 406 / 978             int w, h;  
            img = evas_object_image_add(canvas);  
            evas_object_image_file_set(img, img_path, NULL);  
            evas_object_image_size_get(img, &w, &h);  
            evas_object_image_fill_set(img, 110, 37, w, h);  
            elm_grid_pack(grid, img, 40, 310, 400, 280);  
            evas_object_show(img);  
        } 
    } 
└─────────────────────┘  
evas_object_image_add(Evas *) is an API that creates an Image object that 
displays an image in a tile format. The siz e and start position of the image 
need to be specified.  
evas_object_image_size_get(const Evas_Object *, int *, int *) is an API that 
returns the size of an original image. The first parameter receives the 
Image object; the second parameter receives the wid th of an original 
image; and the third parameter receives the height of an original image.  
evas_object_image_fill_set(Evas_Object *, Evas_Coord, Evas_Coord, 
Evas_Coord, Evas_Coord) is an API that specifies the display position and 
size of an original image  for an Image object. The parameters listed in 
order are the Image object, x -coordinate, y -coordinate, width, and height.  
Run the example again. The image is placed in a tile format.  
  
Page 407 / 978  
 
3) Displaying an Image as Large as Possible Retaining the Original 
Proportions  
In this section, we are going to learn how to display an image as large as 
possible in a given area. To display an image retaining its original 
proportions, a calculation needs to be performed. Create a new function 
on top of the create_base_gui( ) function. This function creates an Image 
object by calculating the size of the image to be displayed.  
┌─────────────────────┐  
// Create IMAGE object. Source image's rate is no change  
static Evas_Object *  
create_image(Evas *canvas, Evas_Object *grid, const char *img_path, int x, int y, int 
w, int h)  
{ 
   int source_w, source_h, new_x, new_y, new_w, new_h;  
   float rate_h, rate_v, rate;  
 
   // Create IMAGE object  
   Evas_Object *img = evas_object_image_add(canvas);  
   // Set source image file  
   evas_ob ject_image_file_set(img, img_path, NULL);  

  
Page 408 / 978    // Get source image size  
   evas_object_image_size_get(img, &source_w, &source_h);  
   // Load failed - zero sized image  
   if ((source_w == 0) || (source_h == 0))  
     { 
        evas_object_del(img);  
        return NULL;  
     } 
 
   // Calculage Zoom rate  
   rate_h = (float)w / (float)source_w;  
   rate_v = (float)h / (float)source_h;  
   rate = (rate_h < rate_v) ? rate_h : rate_v;  
 
   // Calculate output image size  
   new_w = source_w * rate;  
   new_h = source_h * rate; 
   evas_object_image_fill_set(img, 0, 0, new_w, new_h);  
 
   // Calculate output Image position  
   new_x = x + (w - new_w) / 2;  
   new_y = y + (h - new_h) / 2;  
   elm_grid_pack(grid, img, new_x, new_y, new_w, new_h);  
 
   evas_object_show(img);  
   return img;  
} 
└─────────────────────┘  
Now, let's create a third Image object by calling the function we just 
created. Add new code at the end of the create_base_gui() function.  
  
  
Page 409 / 978 ┌─────────────────────┐  
            /* Image -2 */ 
            int w, h;  
            img = evas_object_image_add(canvas);  
            evas_object_image_file_set(img, img_path, NULL);  
            evas_object_image_size_get(img, &w, &h);  
            evas_object_image_fill_set(img, 110, 37, w, h);  
            elm_grid_pack(grid, img , 40, 310, 400, 280);  
            evas_object_show(img);  
 
            /* Image -3 */ 
            create_image(canvas, grid, img_path, 40, 610, 400, 180);  
        } 
    } 
└─────────────────────┘  
The parameters of the create_image() function listed in order are the 
canvas object, path of the image file, x -coordinate, y -coordinate, width, 
and height.  
Run the example again. A third image is displayed at the bottom of the 
screen, and the original proportions of the original image have been 
retained.  
  
Page 410 / 978  
 
4) Relate d APIs  
Evas *evas_object_evas_get(Evas_Object *obj): an API that creates an Evas 
object. / parameters: Window object.  
Evas_Object *evas_object_image_filled_add(Evas *e): an API that creates an 
Image object that lets an original image fill the entire space of an area.  
void evas_object_image_file_set(Evas_Object *obj, const char *file, const 
char *key): an API that loads an image file into an Image object.  
Evas_Object *evas_object_image_add(Evas *e): an API that creates an Image 
object that displays an image in a tile format. The size and start position 
of the image need to be specified.  
  

  
Page 411 / 978 void evas_object_image_size_get(const Evas_Object *obj, int *w, int *h): an 
API that returns the size of an original image. The first parameter receives 
the Image object; th e second parameter receives the width of an original 
image; and the third parameter receives the height of an original image.  
void evas_object_image_fill_set(Evas_Object *obj, Evas_Coord x, Evas_Coord 
y, Evas_Coord w, Evas_Coord h): an API that specifies t he display position 
and size of an original image for an Image object. / parameters: Image 
object, x -coordinate, y -coordinate, width, and height.  
  
  
Page 412 / 978 36. Creating a Customized Button  
Basic widgets provided by a system are often simply not enough to satisfy 
users' various demands. In such cases, it is necessary to create customized 
widgets yourself. In this example, we are going to create a customized 
Button widget.  
 
1) Displaying Text on the Canvas  
Create a new source project and specify the project name as 
'CustomButtonEx.' After the source project is created, create a library file 
for the customized Button: Right -click the /inc folder and select [New > 
Header File] in the shortcut menu.  
 
When a popup  window appears, enter CustomButton.h in the header file 
field and tap the Finish button.  

  
Page 413 / 978  
We are now going to implement a feature that displays a background 
square in the customized widget. When the /inc/CustomButton.h file is 
created, add source code to it. This code declares a library header file, 
defines da ta structures, and creates a background square.  
┌─────────────────────┐  
#ifndef CUSTOMBUTTON_H_  
#define CUSTOMBUTTON_H_  
  
#include <app.h>  
#include <Elementary.h>  
#include <system_settings.h>  
#include <efl_extension.h>  
#include <dlog.h>  
  
typedef struct buttondata {  
    Evas_Object *rect;  
    Evas_Object *text;  
} buttondata_s;  
  
Evas_Object*  
create_rect(Evas* canvas,  Evas_Object* grid,  int x, int y, int w, int h,  

  
Page 414 / 978         int r, int g, int b, int a)  
{ 
    Evas_Object *rect = evas_object_rectangle_add(canva s); 
    evas_object_color_set(rect, r, g, b, a);  
    elm_grid_pack (grid, rect, x, y, w, h);  
    evas_object_show(rect);  
    return rect;  
} 
  
buttondata_s*  
create_button(Evas* canvas, Evas_Object* grid, Evas_Coord x, Evas_Coord y, Evas_
Coord w, Evas_Coord h, 
        const char* str, Evas_Object_Event_Cb func)  
{ 
    buttondata_s* bd = (buttondata_s*)malloc( sizeof( buttondata_s) );  
  
    /* Rectangle */  
    bd->rect = create_rect(canvas, grid, x, y, w, h, 128, 128, 255, 255);  
  
    return bd;  
} 
  
#endif /* CUSTOMBUTTON_H_ */  
└─────────────────────┘  
buttondata is a data structure used in a customized widget. rect indicates 
the coordinates of a widget in an area. text stores the caption text string.  
create_rect() is a function that creates a Rect object on a c anvas. The 
parameters listed in order are the canvas object, x -coordinate, y -
coordinate, width, height, Red, Green, Blue, and semi -transparent color.  
  
  
Page 415 / 978 evas_object_rectangle_add(Evas *) is an API that creates a Rectangle object 
on a canvas.  
evas_object_col or_set(Evas_Object *, int, int, int, int) is an API that specifies 
a color for a shape. The parameters listed in order are Red, Green, Blue, 
and semi -transparency. Entering 255, 0, 0, 192 creates a semi -transparent 
red. 
create_button() is a function that c reates a customized Button widget. We 
need to make this function able to be called from the outside. The 
parameters listed in order are the canvas, x -coordinate, y -coordinate, width, 
height, caption text, and name of the callback event function.  
malloc(siz e_t) is an API that procures and then returns a specified size of 
memory.  
sizeof() is an API that requests and then returns the memory size of an 
object.  
Now, let's create a customized widget object on the main screen. Open 
the source file (~.c) under the src folder and add new code.  
┌─────────────────────┐  
#include "custombuttonex.h"  
#include "custombutton.h"  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
  
Page 416 / 978 buttondata_s* m_bd1;  
└─────────────────────┘  
Include the customized Button widget file and create the buttondata 
structure as a global variable.  
Then, go to the create_base_gui() function and add new code. This code 
creates a canvas object and a customized Button widget. Annot ate the 
Label-creating code.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text _set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
    { /* child object - indent to how relationship */  
        /* A grid to stretch content within grid size */  
        Evas_Object *grid = elm_grid_add(ad ->win);  
     elm_grid_size_set(grid, 480, 800);  
        evas_object_size_hint_weight_set(grid, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
  
Page 417 / 978         elm_object_content_set(ad ->conform, grid);  
        evas_object_show(grid);  
 
        { 
            /* Canvas */  
            Evas* canvas = evas_object_evas_get(ad ->conform);  
 
            /* Custom Button -1 */ 
            m_bd1 = create_button(canvas, grid, 50, 200, 300, 100, "Button -1", 
NULL); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Grid container to assign relative coor dinates to the object. 
We changed the size of the Grid to 480x800 using the elm_grid_size_set() 
function.  
evas_object_evas_get(Evas_Object *) is an API that creates an Evas object.  
create_button() is a function that actually creates the customized Button 
we just created in the customized Button widget file (CustomButton.h).  
Build and run the example. A sky blue square is displayed on the screen. 
This is the background square for the customized Button .  
  
Page 418 / 978  
 
2) Displaying Caption Text  
In this section, we are g oing to display caption text on a square 
background. To display text, we will use TextBlock. TextBlock is a canvas 
object that makes it possible to specify the properties of text such as font 
size and color using HTML tags. Go back to the CustomButton.h fi le and 
add a new function on top of the create_button() function.  
┌─────────────────────┐  
// Create TextBlock object  
Evas_Object*  
create_textblock(Evas* canvas, Evas_Object* grid, Evas_Coord x, Evas_Coord y, Evas_Co
ord w, Evas_Coord h, const char* str)  
{ 
    Evas_Object *textblock = evas_object_textblock_add(canvas);  
    elm_grid_pack(grid, textblock, x, y, w, h);  
 
    Evas_Textblock_Style *st = evas_textblock_style_new();  
    evas_textblock_style_set(st, "DEFAULT='font=Sans font_size=50 color=#eee wrap=
mixed align=center'");  
    evas_object_textblock_style_set(textblock, st);  
    evas_textblock_style_free(st);  
    evas_object_textblock_text_markup_set(textblock, str);  
    evas_object_show(textblock);  
 

  
Page 419 / 978     return textblock;  
} 
└─────────────────────┘  
evas_ob ject_textblock_add(Evas *) is an API that creates a TextBlock object.  
Evas_Textblock_Style is a style structure that stores the property 
information of TextBlock.  
evas_textblock_style_new() is an API that creates an Evas_Textblock_Style 
object.  
evas_textbl ock_style_set(Evas_Textblock_Style *, char *) is an API that 
specifies a style for Evas_Textblock_Style. Pass the Evas_Textblock_Style 
object to the first parameter. For the second parameter, specify text 
properties using HTML tags.  
font=Sans is a tag that  specifies the font as Sans serif/Gothic.  
font_size=50 is a tag that specifies the font size as 50.  
color=#eee is a tag that specifies the font color as gray.  
align=center is a tag that specifies the horizontal alignment as center.  
evas_object_textblock_st yle_set(Evas_Object *, Evas_Textblock_Style *) is an 
API that specifies a style for a TextBlock object. Pass the TextBlock object 
to the first parameter, and pass the Evas_Textblock_Style object to the 
second parameter.  
evas_textblock_style_free(Evas_Textb lock_Style *) is an API that deletes an 
Evas_Textblock_Style object.  
  
  
Page 420 / 978 evas_object_textblock_text_markup_set(Evas_Object *, const char *) is an 
API that specifies a text string for a TextBlock object.  
We need to make this function be called by the create_t extblock() function. 
Add new code to the create_textblock() function.  
┌─────────────────────┐  
    bd->rect = create_rect(canvas, grid, x, y, w, h, 128, 128, 255, 255);  
  
    /* Text */  
    bd->text = create_textblock(canvas,  grid, x, y, w, h, str);  
  
    return bd;  
└─────────────────────┘  
The parameters of the create_textblock() function listed in order are the 
canvas object, x -coordinate, y -coordinate, width, height, and text string.  
Run the example again. Caption text is displayed in the square area.  
 
 
  

  
Page 421 / 978 3) Center -Aligning Caption Text  
Currently, the caption text is displayed at the top of the square. We are 
now going to change the position of the caption text to center. Add new 
code to the create_textblock() function.  
┌─────────────────────┐  
    Evas_Textblock_Style *st = evas_textblock_style_new();  
    evas_textblock_style_set(st, "DEFAULT='font=Sans font_size=50 color=#eee wrap=m
ixed align=center'");  
    evas_object_textblock_style_set(textblock, st);  
    evas_textblock_style_free(st);  
    evas_object_textblock_valign_set(textblock, 0.5);  
    evas_object_textblock_text_markup_set(textblock, str);  
    evas_object_show(textblock);  
└─────────────────────┘  
evas_object_textblock_valign_set(Evas_Object *, double) is an API that 
specifies the vertic al alignment of TextBlock caption text. Passing 0 to the 
second parameter top -aligns the text, passing 1 bottom -aligns the text, 
and passing 0.5 center -aligns the text.  
Run the example again. This time, the caption text is displayed in the 
center.  
 
 

  
Page 422 / 978 4) Requesting a Button Click Event  
In this section, we are going to implement a feature that changes the 
background color when a customized Button is tapped. To do so, we need 
to request a Touch event. Add new code at the end of the create_button() 
function.  
┌─────────────────────┐  
    bd->text = create_textblock(canvas, grid, x, y, w, h, str);  
  
    evas_object_event_callback_add( bd ->text, EVAS_CALLBACK_MOUSE_DOWN, on_
mouse_down, (void*)bd);  
    evas_object_event_callback_add( bd ->text, EVAS_CALLBACK_MOUSE_U P , on_mou
se_up, (void*)bd);  
  
    return bd;  
└─────────────────────┘  
This code calls the on_mouse_down function when a Touch Down event 
occurs in TextBlock.  
This code calls the on_mouse_up function when a Touch Cancel event 
occurs in TextBlock.  
We are now going to create the callback functions. Add two new functions 
on top of the create_button() function.  
┌─────────────────────┐  
// Touch Down event callback  
void 
on_mouse_down(void *data, Evas *e, Evas_Object *button, void *event_info)  
{ 
  
Page 423 / 978     buttondata_s* bd  = (buttondata_s*)data;  
    evas_object_color_set(bd ->rect, 255, 128, 128, 255);  
} 
 
// Touch Up event callback  
void 
on_mouse_up(void *data, Evas *e, Evas_Object *button, void *event_info)  
{ 
    buttondata_s* bd = (buttondata_s*)data;  
    evas_object_color_set(bd ->rect, 128, 128, 255, 255);  
} 
└─────────────────────┘  
This code changes the background color to pink when the user Touch 
Downs a customized Button and changes the background color back to 
sky-blue when the user Touch Cancels th e customized Button.  
Run the example again. Tap and then untap the Button. The background 
color then changes.  
 
 
  

  
Page 424 / 978 5) Requesting a Click Event on the Main Screen  
To request a Button click event on the main screen, you need to let a 
callback function be cal led when a Touch Cancel event occurs. Add new 
code at the end of the create_button() function.  
┌─────────────────────┐  
    evas_object_event_callback_add( bd ->text, EVAS_CALLBACK_MOUSE_DOWN, on_mo
use_down, (void*)bd);  
    evas_object_event_callback_add( bd ->text, EVAS_CALLBACK_MOUSE_UP, on_mouse_
up, (void*)bd);  
    evas_object_event_callback_add( bd ->text, EVAS_CALLBACK_MOUSE_UP , func, (v
oid*)bd);  
  
    return bd;  
└─────────────────────┘  
When the user taps and then untaps the Button, the function passed is 
displayed on the main screen.  
Go to the main source file (custombuttonex.c) and modify the code of the 
create_base_gui() function.  
┌─────────────────────┐  
    { 
        /* Canvas */  
        Evas* canvas = evas_object_evas_get(ad ->conform);  
 
        /* Custom Button -1 */ 
        //m_bd1 = create_button(canvas, 50, 200, 300, 100, "Button -1", NULL);  
        m_bd1 = create_button(canvas, grid, 50, 200, 300, 100, "Button -1", on_b
tn1_cb);  
    } 
└─────────────────────┘  
  
Page 425 / 978 We specified the name of the c allback function for the customized Button 
as on_btn1_cb. Now, we need to add the callback function. Create a new 
function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
on_btn1_cb(void *data, Evas *e, Evas_Object *button, vo id *event_info)  
{ 
    dlog_print(DLOG_ERROR, "tag", "on_btn1_cb -1"); 
} 
└─────────────────────┘  
This code displays a log message when the user taps the customized 
Button.  
Run the example again. Click the Button, and then the message 
'on_btn1_cb -1' is displa yed in the Log pane.  
 
 
  

  
Page 426 / 978 6) Changing Caption Text  
In this section, we are going to implement a feature that changes the 
caption text of a first Button when a newly added second customized 
Button is tapped. To do so, we need to add a text -changing function  to 
the custom widget file (CustomButton.h). Where the function gets placed 
does not really matter. However, it is advisable that you place a function 
called from the outside at the bottommost possible position. This is 
because it is possible another funct ion may be called from this function.  
┌─────────────────────┐  
void set_button_text(buttondata_s* bd, const char* str)  
{ 
    evas_object_textblock_text_markup_set(bd ->text, str);  
} 
  
#endif /* CUSTOMBUTTON_H_ */  
└─────────────────────┘  
When this function is  called on the main screen, the caption text of the 
relevant Button is changed. Go to the main source file (custombuttonex.c) 
and add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    { 
        /* Canvas */  
        Evas* ca nvas = evas_object_evas_get(ad ->conform);  
 
        /* Custom Button -1 */ 
        m_bd1 = create_button(canvas, grid, 50, 200, 300, 100, "Button -1", on_btn1_
cb); 
 
  
Page 427 / 978         /* Custom Button -2 */ 
        create_button(canvas, grid, 50, 400, 300, 100, "Button -2", on_btn2_cb);  
    } 
└─────────────────────┘  
This code creates a second customized Button, specifies the caption text 
as "Button -2", and specifies the callback function as on_btn2_cb.  
Lastly, we need to add the callback function for the second Button. Cre ate 
a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
on_btn2_cb(void *data, Evas *e, Evas_Object *button, void *event_info)  
{ 
    set_button_text(m_bd1, "Pressed");  
} 
└─────────────────────┘  
This code changes th e caption text of the first Button to ‘Pressed’ when 
the user taps the second Button.  
Run the example again. Tap the second Button, and the caption text of 
the first Button is changed.  
  
Page 428 / 978  
 
7) Related APIs  
Evas_Object *evas_object_textblock_add(Evas *e): an API that creates a 
TextBlock object.  
Evas_Textblock_Style: a style structure that stores the property information 
of TextBlock.  
Evas_Textblock_Style *evas_textblock_style_new(): an API that creates an 
Evas_Textblock_Style object.  
void evas_textblock_style_ set(Evas_Textblock_Style *ts, const char *text): an 
API that defines the style of Evas_Textblock_Style. / parameters: 
Evas_Textblock_Style object and HTML tags.  
void evas_object_textblock_style_set(Evas_Object *obj, Evas_Textblock_Style 
*ts): an API that s pecifies a style for a TextBlock object. / parameters: 
TextBlock object and Evas_Textblock_Style object.  
  

  
Page 429 / 978 void evas_textblock_style_free(Evas_Textblock_Style *ts): an API that deletes 
an Evas_Textblock_Style object.  
void evas_object_textblock_text_markup_ set(Evas_Object *obj, const char 
*text): an API that specifies a string for a TextBlock object.  
void evas_object_textblock_valign_set(Evas_Object *obj, double align): an 
API that specifies the vertical alignment of TextBlock caption text. Passing 
0 to the second parameter top -aligns the text, passing 1 bottom -aligns 
the text, and passing 0.5 center -aligns the text.  
  
  
Page 430 / 978 37. Using an  Animator  
Using the Animator enables making a change to an object on the screen 
at certain intervals. The Animator is similar to the T imer, but its difference 
with the Timer is that it can produce various effects. Let's learn in detail 
how to use the GenList widget through an example.  
 
1) Creating an Animation  
Create a new source project and specify the project name as 'AnimatorEx.' 
After the source project is created, open the source file (~.c) under the src 
folder and add variables at the top of the source file.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *rect1;  
    Evas_Object *rect2;  
} appdata_s;  
  
Eina_Bool anim_continue = ECORE_CALLBACK_RENEW;  
Ecore_Pos_Map pos_map = ECORE_POS_MAP_LINEAR;  
└─────────────────────┘  
rect1 and rect2 are square objects to which an animation will be applied.  
  
  
Page 431 / 978 anim_continue is a Boolean variable that determines whether to continue 
the animation.  
Ecore_Pos_Map is an option that specifies the style of an animation. We 
will use it in a TimeLine animation.  
We are now going to create a first square object and an Ani mator object. 
Add new code to the create_base_gui() function. Annotate the 
Conformant -creating code and the Label -creating code.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_objec t_show(ad ->conform);*/  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->confor m, ad ->label);  
    evas_object_show(ad ->label);*/  
 
    /* Evas */  
    Evas *evas = evas_object_evas_get(ad ->win);  
 
    /* Rect -1 */ 
    ad->rect1 = evas_object_rectangle_add(evas);  
  
Page 432 / 978     evas_object_pass_events_set(ad ->rect1, EINA_TRUE);  
    evas_object_color_set(ad ->rect1, 0, 0, 160, 160);  
    evas_object_resize(ad ->rect1, 50, 50);  
    evas_object_show(ad ->rect1);  
 
    /* Animation -1 */ 
    Ecore_Animator *anim = ecore_animator_add(on_next_frame1, ad ->rect1);  
    ecore_animator_frametime_ set(1. / 60);  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Create an Evas object to create a Rectangle object.  
ecore_animator_add(Ecore_Task_Cb, void *) is an API that creates an 
Animator object. Th e first parameter indicates the frame event callback 
function, and the second parameter indicates user data. It generally passes 
an object or appdata to which you will apply the animation.  
ecore_animator_frametime_set(double) is an API that specifies a fra me 
time interval for an animation. For example, if you specify the interval as 
1/60, 60 frame events occur for one second. The unit is seconds.  
We are now going to create a frame event function. Create a new function 
on top of the create_base_gui() functio n. 
┌─────────────────────┐  
static Eina_Bool on_next_frame1(void *data)  
{ 
    static int x = 0;  
    if (x >= 350)  
  
Page 433 / 978         x = 0;  
    evas_object_move(data, x += 2, 50);  
    return anim_continue;  
} 
└─────────────────────┘  
evas_object_move() is an API that changes the position of an object. This 
function increases the x -coordinate of an object by 2 at every frame. When 
the x-coordinate becomes greater than 350, it starts back from 0.  
If the value returned from the frame event function is 
ECORE_CALLBACK_RENEW , the animation continues. If the value 
ECORE_CALLBACK_CANCEL is returned, the animation pauses.  
Build and run the example. A blue square moves from left to right. When 
the blue square has moved a certain distance, it restarts its movement 
from the left en d of the screen.  
   
 
2) Stopping an Animation  
To stop an animation, the frame event function needs to return 
ECORE_CALLBACK_CANCEL. We are now going to implement a feature 
that stops an animation when a Button is tapped. Create a new function 
on top of t he create_base_gui() function. This function adds a widget to a 
Table container.  

  
Page 434 / 978 ┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
   evas_object_size_hint_align_set(child, EVAS_HINT_FIL L, 0.5);  
   evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
   elm_table_pack(table, child, x, y, w, h);  
   evas_object_show(child);  
} 
└─────────────────────┘  
Then, add new code to the create_base_gui() function. This code crea tes a 
Box and a Table and adds a Button.  
┌─────────────────────┐  
    /* Rect -1 */ 
    ad->rect1 = evas_object_rectangle_add(evas);  
    evas_object_pass_events_set(ad ->rect1, EINA_TRUE);  
    evas_object_color_set(ad ->rect1, 0, 0, 160, 160);  
    evas_object_resize(ad ->rect1, 50, 50);  
    evas_object_show(ad ->rect1);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_bo x_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_win_resize_object_add(ad ->win, box);  
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->win);  
        /* Make table homogenous - every cell will be the same size */  
  
Page 435 / 978         elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 20 * elm_config_scale_get( ), 10 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */ 
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, 1.0);  
        elm_box_pack_end(box, table);  
        evas_object_show(table);  
 
        { 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "■");  
            evas_object_smart_callback_add(btn, "clicked", btn_stop_cb, NULL);  
            my_table_pack(table, btn, 0, 0, 2, 1);  
        } 
    } 
 
    evas_object_raise(ad ->rect1);  
 
    /* Animation -1 */ 
    Ecore_Animator *anim = ecore_animator_add(on_next_frame1, ad ->rect1);  
└─────────────────────┘  
evas_object_raise() is an API that moves an object to the topmost level of 
the screen so that it is not hidden by other objects.  
  
  
Page 436 / 978 We need to make it so that when the Button is tapped, 
ECORE_CALLBACK_CANCEL gets stored in anim_continue.  We are now 
going to add the callback function for the Button on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_stop_cb(void *data, Evas_Object *o bj, void *event_info)  
{ 
    anim_continue = ECORE_CALLBACK_CANCEL;  
} 
└─────────────────────┘  
We made it so that when the Button is tapped, the on_next_frame1() 
returns ECORE_CALLBACK_CANCEL, and as a result, the animation stops.  
Run the example again. Tap the Button, and the square stops its movement.  
 
 
  

  
Page 437 / 978 3) Pausing/Resuming an Animation with the Timer Widget  
To pause an animation, you need to use the ecore_animator_freeze() 
function. To resume an animation, you need to use the 
ecore_animator_thaw() function. Add new code to the create_base_gui() 
function. This code creates two Timers.  
┌─────────────────────┐  
    /* Animation -1 */ 
    Ecore_Animator *anim = ecore_animator_add(on_next_frame1, ad ->rect1);  
    /* add 2 timers to go off every 6 seconds */  
    ecore_timer_add(6, freeze_anim, anim);  
    Ecore_Timer *timer = ecore_timer_add(6, thaw_anim, anim);  
    /* delay the last timer by 3 seconds so the 2 timers are offset */  
    ecore_timer_delay(timer, 3);  
└─────────────────────┘  
Two Timers have now be en created. The first Timer is responsible for 
pausing an animation, while the second Timer is responsible for resuming 
an animation.  
ecore_timer_delay() is an API that starts a Timer after a certain amount of 
time has passed. In the case of the second Ti mer, the event occurs after 3 
+ 6 = 9 seconds, and afterwards, an event occurs every 6 seconds.  
We are now going to create a timer event function. Add two new functions 
on top of the create_base_gui() function.  
┌─────────────────────┐  
static Eina_Bool free ze_anim(void *data)  
{ 
    ecore_animator_freeze(data);  
    // Animation stop Timer delete  
  
Page 438 / 978     return ECORE_CALLBACK_CANCEL;  
} 
  
static Eina_Bool thaw_anim(void *data)  
{ 
    ecore_animator_thaw(data);  
    // Animation restart Timer delete  
    return ECORE_CALLBACK_CANCEL;  
} 
└─────────────────────┘  
The freeze_anim() function will be called 3 seconds after the app starts.  
ecore_animator_freeze(Ecore_Animator *) is an API that pauses an 
animation.  
The thaw_anim() function will be called 6 seconds after the app starts.  
ecore_animator_thaw(Ecore_Animator *) is an API that resumes an 
animation.  
Run the example again, and you will now see a moving animation pause 
and resume every 3 seconds.  
 
4) TimeLine Animation  
In this section, we are going to implement an  animation that plays for a 
certain amount of time. Add new code to the create_base_gui() function. 
This code creates a second Rectangle object and a TimeLine animation.  
  
Page 439 / 978 ┌─────────────────────┐  
    /* Rect -1 */ 
    ad->rect1 = evas_object_rectangle_add(eva s); 
    evas_object_pass_events_set(ad ->rect1, EINA_TRUE);  
    evas_object_color_set(ad ->rect1, 0, 0, 160, 160);  
    evas_object_resize(ad ->rect1, 50, 50);  
    evas_object_show(ad ->rect1);  
 
    /* Rect -2 */ 
    ad->rect2 = evas_object_rectangle_add(evas);  
    evas_object_pass_events_set(ad ->rect2, EINA_TRUE);  
    evas_object_color_set(ad ->rect2, 0, 55, 0, 160);  
    evas_object_resize(ad ->rect2, 50, 50);  
    evas_object_show(ad ->rect2);  
 
    { 
    ~ 
    } 
 
    evas_object_raise(ad ->rect1);  
    evas_object_raise(ad ->rect2);  
 
    /* Animation -1 */ 
    Ecore_Animator *anim = ecore_animator_add(on_next_frame1, ad ->rect1);  
    /* add 2 timers to go off every 6 seconds */  
    ecore_timer_add(6, freeze_anim, anim);  
    Ecore_Timer *timer = ecore_ti mer_add(6, thaw_anim, anim);  
    /* delay the last timer by 3 seconds so the 2 timers are offset */  
    ecore_timer_delay(timer, 3);  
 
    /* Animation -2 */ 
    ecore_animator_timeline_add(4, on_next_frame2, ad ->rect2);  
 
    /* Show window after base gui is  set up */  
  
Page 440 / 978     evas_object_show(ad ->win);  
└─────────────────────┘  
ecore_animator_timeline_add(double, Ecore_Timeline_Cb, void *) is an API 
that creates a TimeLine animation. The first parameter indicates the play 
time, and the unit is seconds. The second p arameter is the function name 
of the frame event, and the third is the user data.  
We are now going to apply to the second square an animation that 
changes the position, size, and color of the square. Add new code on top 
of the create_base_gui() function. T his is the TimeLine animation frame 
event function.  
┌─────────────────────┐  
static Eina_Bool on_next_frame2(void *data, double pos)  
{ 
    double frame = ecore_animator_pos_map(pos, pos_map, 1.2, 15);  
    evas_object_resize(data, 50 * (1 + frame * 2), 50 * (1 + frame * 2));  
    evas_object_move(data, 200 * frame, 200 * frame + 100);  
    evas_object_color_set(data, 255 * frame, 0, 255 * (1 - frame), 255);  
    return ECORE_CALLBACK_RENEW;  
} 
└─────────────────────┘  
ecore_animator_pos_map() is an API that return s the resulting value that 
is mapped onto the position of the current animation. Returned values 
range between 0 and 1. The resulting value when the animation starts is 
0, and it gradually increases and eventually reaches 1 when the animation 
stops. The se cond parameter of the Timeline animation event function 
must be passed to the first parameter. For the second parameter, enter 
the style of the animation. The style types are as follows:  
  
Page 441 / 978  - ECORE_POS_MAP_LINEAR, /**< Linear 0.0 -> 1.0 */  
- ECORE_POS_MAP_AC CELERATE, /**< Start slow then speed up */  
- ECORE_POS_MAP_DECELERATE, /**< Start fast then slow down */  
- ECORE_POS_MAP_SINUSOIDAL, /**< Start slow, speed up then slow 
down at the end */  
- ECORE_POS_MAP_ACCELERATE_FACTOR, /**< Start slow then speed up, 
v1 being a power factor, @c 0.0 being linear, @c 1.0 being normal 
accelerate, @c 2.0 being much more pronounced accelerate (squared), @c 
3.0 being cubed, and so on */  
- ECORE_POS_MAP_DECELERATE_FACTOR, /**< Start fast then slow down, 
v1 being a power factor,  @c 0.0 being linear, @c 1.0 being normal 
decelerate, @c 2.0 being much more pronounced decelerate (squared), 
@c 3.0 being cubed, and so on */  
- ECORE_POS_MAP_SINUSOIDAL_FACTOR, /**< Start slow, speed up then 
slow down at the end, v1 being a power factor, @c 0.0 being linear, @c 
1.0 being normal sinusoidal, @c 2.0 being much more pronounced 
sinusoidal (squared), @c 3.0 being cubed, and so on */  
 
- ECORE_POS_MAP_DIVISOR_INTERP, /**< Start at gradient * v1, 
interpolated via power of v2 curve */  
- ECORE_POS_MA P_BOUNCE, /**< Start at @c 0.0 then "drop" like a ball 
bouncing to the ground at @c 1.0, and bounce v2 times, with decay factor 
of v1 */  
- ECORE_POS_MAP_SPRING /**< Start at @c 0.0 then "wobble" like a 
spring with rest position @c 1.0, and wobble v2 times,  with decay factor 
of v1 */  
  
  
Page 442 / 978 For the third parameter of the ecore_animator_pos_map() function, enter 
the intensity of speed change. For the fourth parameter, enter the tempo 
of speed change.  
The following code specifies the size, position, and color of a square.  
Run the example again, and you will now see a blue square turn red and 
become larger as it moves to the bottom right.  
   
 
  

  
Page 443 / 978 5) Applying Acceleration to a TimeLine Animation  
The style applied to the animation we just created is 
ECORE_POS_MAP_LINEA R. It is an option that keeps the animation 
moving at a certain speed. We are now going to apply an option that 
makes the animation move slowly at first and then gradually increase in 
speed. Add new code to the create_base_gui() function. This code 
creates  a new Button.  
┌─────────────────────┐  
    { 
        /* Button -1 */ 
        Evas_Object *btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "■");  
        evas_object_smart_callback_add(btn, "clicked", btn_stop_cb, NULL);  
        my_table_pack( table, btn, 0, 0, 2, 1);  
 
        /* Button -2 */ 
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Accelerate");  
        evas_object_smart_callback_add(btn, "clicked", btn_accelerate_cb, ad ->rect
2); 
        my_table_pack(table, btn, 0, 1, 1, 1);  
    } 
} 
└─────────────────────┘  
Next, we will create a callback function for the second Button. Create a 
new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
  
Page 444 / 978 btn_accelerat e_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_MAP_ACCELERATE;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
} 
└─────────────────────┘  
We have changed the animation style to ECORE_POS_MAP_ACCELERATE. 
This is the acceleration option.  
We created a Timeline animation using the ecore_animator_timeline_add() 
function.  
Run the example again and tap the Accelerate button. This starts the 
animation.  
 
 
  

  
Page 445 / 978 6) Other Animation Styles  
We are going to apply different styles to the Timeline animation. Add four 
Buttons to the create_base_gui() function.  
┌─────────────────────┐  
        /* Button -2 */ 
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Accelerate");  
        evas_object_smart_callback_add(btn, "c licked", btn_accelerate_cb, ad ->rect2);  
        my_table_pack(table, btn, 0, 1, 1, 1);  
 
        /* Button -3 */ 
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Decelerate");  
        evas_object_smart_callback_add(btn, "clicked", btn _decelerate_cb, ad ->rect
2); 
        my_table_pack(table, btn, 1, 1, 1, 1);  
 
        /* Button -4 */ 
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Sinusoidal");  
        evas_object_smart_callback_add(btn, "clicked", btn_sinusoidal_ cb, ad ->rect
2); 
        my_table_pack(table, btn, 0, 2, 1, 1);  
 
        /* Button -5 */ 
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Bounce");  
        evas_object_smart_callback_add(btn, "clicked", btn_bounce_cb, ad ->rect2);  
        my_table_pack(table, btn, 1, 2, 1, 1);  
 
        /* Button -6 */ 
  
Page 446 / 978         btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Spring");  
        evas_object_smart_callback_add(btn, "clicked", btn_spring_cb, ad ->rect2);  
        my_table_pack(table, btn, 0, 3, 1, 1);  
    } 
} 
└─────────────────────┘  
You need four matching Button callback functions as well. Add four new 
functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_decelerate_cb( void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_MAP_DECELERATE;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
} 
  
static void  
btn_sinusoidal_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_ MAP_SINUSOIDAL;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
} 
  
static void  
btn_bounce_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_MAP_BOUNCE;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
} 
  
static void  
  
Page 447 / 978 btn_spring_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_MAP_SPRING;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
} 
└─────────────────────┘  
ECORE_POS_MAP_ACCELERATE is the opposite property of 
ECORE_P OS_MAP_ACCELERATE. It creates movement that is fast at first, 
but gradually loses speed.  
ECORE_POS_MAP_SINUSOIDAL creates movement that starts slow, 
becoming faster before becoming slow again at the end.  
ECORE_POS_MAP_BOUNCE creates vibration similar to a bouncing ball. It 
does not exceed the ending point, however.  
ECORE_POS_MAP_SPRING creates vibration like a bouncing ball. It slows 
to stop after bouncing off the ending point.  
Run the example again and tap the Buttons you added, one at a time.  
 

  
Page 448 / 978 7) Continu ous Animations  
We will implement a feature that automatically starts the second 
animation after one type of animation ends, using the Timer. Create a new 
Button on the create_base_gui() function.  
┌─────────────────────┐  
            /* Button -6 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Spring");  
            evas_object_smart_callback_add(btn, "clicked", btn_spring_cb, ad ->rect2);  
            my_table_pack(table, btn, 0, 3, 1, 1);  
 
            /* Button -7 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Twice");  
            evas_object_smart_callback_add(btn, "clicked", btn_twice_cb, ad ->rect
2); 
            my_table_pack(table, btn, 1, 3, 1, 1);  
        } 
    } 
└─────────────────────┘   
Then, add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static Eina_Bool  
start_second_anim(void *data)  
{ 
    pos_map = ECORE_POS_MAP_SPRING;  
    ecore_animator_timeline_add(4, on_next_frame2, data); 
    return ECORE_CALLBACK_CANCEL;  
} 
  
Page 449 / 978 static void  
btn_twice_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    pos_map = ECORE_POS_MAP_ACCELERATE;  
    ecore_animator_timeline_add(4, on_next_frame2, data);  
    ecore_timer_add(4, start_second_anim , data);  
} 
└─────────────────────┘  
start_second_anim() is the function that starts the second animation.  
btn_twice_cb() is the callback function of the seventh Button. Start the 
acceleration animation and use the Timer to enable the second animation 
to beg in automatically 4 seconds later.  
Run the example again and tap the ‘Twice’ button. The acceleration 
animation begins and ends, followed by the Spring animation.  
 
 
  

  
Page 450 / 978 8) Related APIs  
void  ecore_animator_frametime_set(double frametime):  specifies the time 
frame between the animations. / parameters: time interval of the frame (in 
seconds).  
Ecore_Animator  *ecore_animator_add(Ecore_Task_Cb func, void *data): 
creates an Animator object. / parameters: callback function for the frame 
event, user data. It general ly passes an object or appdata to which you 
will apply the animation.  
void  ecore_animator_freeze(Ecore_Animator *animator): pauses the 
animation.  
void ecore_animator_thaw(Ecore_Animator *animator): restarts the 
animation.  
Ecore_Animator *ecore_animator_ti meline_add(double runtime, 
Ecore_Timeline_Cb func, void *data): creates a Timeline animation. / The 
first parameter is the run time in seconds. The second parameter is the 
function name of the frame event, and the third is the user data.  
EAPI double ecore_ animator_pos_map(double pos, Ecore_Pos_Map map, 
double v1, double v2): returns the resulting value mapped onto the current 
animation's position. The returned value is between 0 and 1. The resulting 
value when the animation starts is 0, and it gradually inc reases, eventually 
reaching 1 when the animation stops. Simply pass the second parameter 
of the Timeline animation event function to the first parameter. For the 
second parameter, specify Ecore_Pos_Map. For the third parameter, specify 
the intensity. For t he fourth parameter, specify the rate of speed change.  
  
Page 451 / 978 The types of Ecore_Pos_Map are as follows:  
 - ECORE_POS_MAP_LINEAR, /**< Linear 0.0 -> 1.0 */  
 - ECORE_POS_MAP_ACCELERATE, /**< Start slow then speed up */  
 - ECORE_POS_MAP_DECELERATE, /**< Start fast then slow down */  
 - ECORE_POS_MAP_SINUSOIDAL, /**< Start slow, speed up then slow 
down at the end */  
 - ECORE_POS_MAP_ACCELERATE_FACTOR, /**< Start slow then speed up, 
v1 being a power factor, @c 0.0 being linear, @c 1.0 being normal 
accelerate, @c 2.0 be ing much more pronounced accelerate (squared), @c 
3.0 being cubed, and so on */  
 - ECORE_POS_MAP_DECELERATE_FACTOR, /**< Start fast then slow down, 
v1 being a power factor, @c 0.0 being linear, @c 1.0 being normal 
decelerate, @c 2.0 being much more pronoun ced decelerate (squared), 
@c 3.0 being cubed, and so on */  
 - ECORE_POS_MAP_SINUSOIDAL_FACTOR, /**< Start slow, speed up then 
slow down at the end, v1 being a power factor, @c 0.0 being linear, @c 
1.0 being normal sinusoidal, @c 2.0 being much more pronoun ced 
sinusoidal (squared), @c 3.0 being cubed, and so on */  
 - ECORE_POS_MAP_DIVISOR_INTERP, /**< Start at gradient * v1, 
interpolated via power of v2 curve */  
 - ECORE_POS_MAP_BOUNCE, /**< Start at @c 0.0 then "drop" like a ball 
bouncing to the ground at @ c 1.0, and bounce v2 times, with decay factor 
of v1 */  
 - ECORE_POS_MAP_SPRING /**< Start at @c 0.0 then "wobble" like a 
spring with rest position @c 1.0, and wobble v2 times, with decay factor 
of v1 */  
  
  
Page 452 / 978 38. Playing Audio  
When Sony came up with a portable aud io device in 1979, the market 
research returned negative feedback. This did not stop Sony President 
Orita, however; his persistence gave birth to the Walkman. Soon, it became 
a bestseller. In the 21st century, a man named Steve Jobs created a small 
MP3 pla yer and caused a worldwide sensation. With the endless flow of 
smartphones, however, stand -alone portable music players are facing 
obsoleteness.  
Using a player, you can play audio and video. In this section, we will discuss 
how to play an audio file.  
 
1) Loading an Audio File  
Create a new source project and specify the project name as ‘AudioPlayer.’ 
Copy the audio file. Copy two files, bg1.mp3 and SampleAAC.aac, under 
the /Audio folder of the appendix to the /res folder of the source project.  
 
  

  
Page 453 / 978 Now, enter  the source code. Open the source file (~.c) under the src folder 
and add libraries and variables at the top of the screen.  
┌─────────────────────┐  
#include "audioplayer.h"  
#include <player.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    player_h player;  
} appdata_s;  
  
const char* file_name[] = { "SampleAAC.aac", "bg1.mp3" };  
└─────────────────────┘  
player_h is a Player structure that plays media such as audio and video.  
file_name[] is  an array of strings that save the file name.  
As you run the app, a Player object will be automatically created and the 
first audio file loaded. Add new code at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
    evas_object_show(ad ->win); 
  
    // Create Player  
    ad->player = create_player();  
  
    // Load audio file to Player  
    prepare_player(ad, 0);  
└─────────────────────┘   
  
Page 454 / 978 The create_player() function creates the Player, while the prepare_player() 
function loads the audio file. Now, let us start building it step by step. Add 
six functions on top of the create_base_gui() function.  
┌─────────────────────┐  
// Get player state  
static player_state_e  
get_player_state(player_h player)  
{ 
    player_state_e state;  
    player_get_state(player, &state);  
    return state;  
} 
  
// Play completed event function  
static void  
on_player_completed(player_h* player)  
{ 
    if(player)  
        player_stop(player);  
} 
  
// Create Player  
static player_h  
create_player()  
{ 
    player _h player;  
  
    player_create(&player);  
    player_set_completed_cb(player, on_player_completed, player);  
  
    return player;  
} 
  
Page 455 / 978   
// Stop play  
static void  
stop_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) == PLAYER_STATE_PLAYING || get_player_state(ad ->
player) == PLAYER_STATE_PAUSED)  
    { 
        player_stop(ad ->player);  
    } 
} 
  
// Get full path of source file  
static inline const char*  
get_resource_path(const char *file_path)  
{ 
    static char absolute_path[PATH_MAX] = {' \0'}; 
  
    static char *res_path_buff = NULL;  
    if(res_path_buff == NULL)  
        res_path_buff = app_get_resource_path();  
  
    snprintf(absolute_path, PATH_MAX, "%s%s", res_path_buff, file_path);  
    return absolute_path;  
} 
  
// Load file to Player  
static void  
prepare_player(appdata_s* ad, int index)  
{ 
    // Stop play  
    stop_player(ad, NULL, NULL);  
  
Page 456 / 978     // Close file  
    player_unprepare(ad ->player);  
  
    const char* file = file_name[index];  
    // Get  full path of source file  
    const char *res_path = get_resource_path(file);  
  
    // Load file  
    player_set_uri(ad ->player, res_path);  
    // Prepare play  
    int result = player_prepare(ad ->player);  
    dlog_print(DLOG_INFO, "tag", "File load : %d", r esult);  
} 
└─────────────────────┘  
The get_player_state() function returns the current status of the Player.  
player_get_state(player_h, player_state_e) is an API that returns the current 
status of the Player. The first parameter is the Player object, while the 
second parameter returns the status value. The types of player_state_e 
status are:  
  - PLAYER_STATE_NONE,          /**< Player is not created */  
  - PLAYER_STATE_IDLE,          /**< Player is created, but not prepared */  
  - PLAYER_STATE_READY,         /**< Player is ready to play media */  
  - PLAYER_STATE_PLAYING,       /**< Player is playing media */  
  - PLAYER_STATE_PAUSED,        /**< Player is paused while playing 
media */  
on_player_completed() is a callback function invoked upon completion of 
playback. 
  
Page 457 / 978 player_stop(player_h) is an API that stops the playback.  
The create_player() function creates a Player object.  
player_create(player_h *) is an API that creates a Player object.  
player_set_completed_cb(player_h, player_completed_cb, void *) is an API 
that specifies the callback function upon completion of playback. The 
second parameter is the name of the callback function, whereas the third 
parameter is the user data.  
The stop_player() function stops the playback.  
The get_resource_path() function retur ns the full path to all the files saved 
under the /res folder.  
The prepare_player() function loads the audio file.  
player_unprepare(player_h) is an API that closes the file you loaded to the 
Player.  
player_set_uri(player_h, const char *) is an API that loads a file to the Player.  
player_prepare(player_h) is an API that prepares for playback by the Player. 
When it is ready to play, it returns 0.  
If you build and start running this way, you will see or hear nothing on 
the screen. If you check the message o n the Log window, ‘File load: 0’ is 
displayed.  
  
Page 458 / 978  
 
2) Playing Audio  
We will implement a feature that plays the audio file when the Button is 
tapped. Create a new function on top of the create_base_gui() function. 
This function adds a widget to a Box contain er. 
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
                        double h_weight, double v_weight, double h_align, double 
v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_med ium"); 
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 

  
Page 459 / 978         /* tell the child that is packed into th e frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the  box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Add new code to the create_base_gui() function. This code creates a Box 
and adds a Button.  
┌─────────────── ──────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conf orm, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in ver ticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
  
Page 460 / 978         evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->win);  
            elm_object_text_set(ad ->label, "<align=center>Hello Tizen</>");  
            /* expand horizontally but not vertical ly, and fill horiz,  
             * align center vertically */  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
            /* Play Button */  
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Play");  
            evas_object_smart_callback_add(btn, "clicked", start_player, ad);  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, 0.0);  
         } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Let’s create a  callback function for the Button. Create a new function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
// Start play  
static void start_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) != PLAYER_STATE_PLAYING)  
  
Page 461 / 978         player_start(ad ->player);  
} 
└─────────────────────┘  
The start_player() function starts playing the audio.  
player_start(player_h) is an API that starts playing the audio.  
Run the example again an d tap the Play button. The audio will now be 
played.  
 
 
3) Pausing and Stopping  
We will now add two Buttons to implement the Pause and Stop features. 
Add new code to the create_base_gui() function.  
┌─────────────────────┐  
            /* Play Button */  
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Play");  
            evas_object_smart_callback_add(btn, "clicked", start_player, ad);  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, 0.0);  
 
            /* Pause Button */  
            btn = elm_button_add(ad ->win);  

  
Page 462 / 978             elm_object_text_set(btn, "Pause");  
            evas_object_smart_callback_add(btn, "clicked", pause_player, ad);  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 
 
            /* Stop Button */  
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Stop");  
            evas_object_smart_callback_add(btn, "clicked", stop_player, ad);  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 
         } 
    } 
└─────────────── ──────┘  
We have added two Buttons. We are now going to create a callback 
function for the Buttons. Add new code on top of the create_base_gui() 
function.  
┌─────────────────────┐  
// Pause play  
static void pause_player(void *data, Evas_Object *obj, void *eve nt_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) == PLAYER_STATE_PLAYING )  
        player_pause(ad ->player);  
} 
└─────────────────────┘  
The start_player() function pauses the audio playback.  
player_start(player_h) is an API that p auses the audio playback.  
  
  
Page 463 / 978 You do not need to create another callback function for the Stop button 
because you already have the stop_player() function in place.  
Run the example again and tap the Play button to play the audio. Tap the 
Pause button to pause  or the Play Again button to restart. Tap the Stop 
button to stop or the Play Again button to start playing from the 
beginning.  
 
 
4) Changing the Audio File  
We will implement a feature that changes the audio file by adding two 
Buttons. Add new code to the  create_base_gui() function.  
┌─────────────────────┐  
        /* Label*/  
        ad->label = elm_label_add(ad ->win);  
        elm_object_text_set(ad ->label, "<align=center>Hello Tizen</>");  
        /* expand horizontally but not vertically, and fill horiz,  
         * align center vertically */  
        my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
        /* File Load -1 Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "File -1"); 
        evas_object_smart_callback_add(btn, "clicked", btn_load_file1, ad);  
        /* epand both horiz and vert, fill horiz and vert */  

  
Page 464 / 978         my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 
 
         /* File Load -2 Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Fi le-2"); 
        evas_object_smart_callback_add(btn, "clicked", btn_load_file2, ad);  
        my_box_pack(box, btn, 1.0, 1.0, -1.0, 0.0);  
 
        /* Play Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Play");  
        evas_object_smart_callback_add(btn, "clicked", start_player, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 0.0);  
└─────────────────────┘  
We have created two Buttons. Finally, we are ready to create a callback 
function for the Buttons. Add new code on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static void  
btn_load_file1(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    // Load file to Player  
    prepare_player(ad, 0);  
} 
  
static void  
btn_load_file2(void *dat a, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    // Load file to Player  
  
Page 465 / 978     prepare_player(ad, 1);  
} 
└─────────────────────┘  
The btn_load_file1() function loads the first audio file. If you pass 0 to the 
second parameter of the prepar e_player() function, the first audio file will 
be loaded.  
The btn_load_file2() function loads the first audio file. If you pass 1 to the 
second parameter of the prepare_player() function, the second audio file 
will be loaded.  
Run the example again and tap the File -2 button followed by the Play 
button. You will hear different audio. Now, tap the File -1 button followed 
by the Play button. You will hear the audio you heard before.  
 
 
  

  
Page 466 / 978 5) Related APIs  
int  player_get_state(player_h player, player_state_e *state): an API that 
returns the current status of the Player. The first parameter is the Player 
object, while the second parameter returns the status value. The types of 
player_state_e status are:  
  - PLAYER_STATE_NONE,          /**< Player is not created  */ 
  - PLAYER_STATE_IDLE,          /**< Player is created, but not prepared */  
  - PLAYER_STATE_READY,         /**< Player is ready to play media */  
  - PLAYER_STATE_PLAYING,       /**< Player is playing media */  
  - PLAYER_STATE_PAUSED,        /**< Playe r is paused while playing media 
*/ 
int  player_stop(player_h player): an API that stops the playback.  
int  player_create(player_h *player): an API that creates a Player object.  
int  player_set_sound_type(player_h player, sound_type_e type): an API 
that spe cifies the sound type. To play the audio file, simply specify 
SOUND_TYPE_MEDIA.  
int  player_set_volume(player_h player, float left, float right): an API that 
specifies the speaker volume. The volume values range from 0 to 1.0. / 
parameters:  Player  object,  left volume, right volume.  
int  player_set_looping(player_h player, bool looping):  an API that 
determines whether the audio will loop or not. If you pass True to the 
second parameter, it is looped. False will play it only once.  
  
  
Page 467 / 978 int  player_set_completed_cb(player_h player, player_completed_cb 
callback, void *user_data): an API that specifies the callback function 
upon completion of playback. / parameters: Player object, name of 
callback function, user data.  
int  player_unprepare(play er_h player): an API that closes the file you 
loaded to the Player.  
int  player_set_uri(player_h player, const char * uri): an API that loads a file 
to the Player.  
int  player_prepare(player_h player): an API that prepares for playback by 
the Player. When it is ready to play, it returns 0.  
int  player_start(player_h player): an API that starts playing the audio.  
int  player_pause(player_h player): an API that pauses the audio playback.  
  
  
Page 468 / 978 39. Playing Video  
Using a player, you can play audio and video. The differ ence between the 
two is that playing video requires a screen. The solution is to create an 
image object to work with the Player. In this section, we will discuss how 
to play a video file.  
 
1) Creating a  Screen  
Create a new source project and specify the pr oject name as ‘VideoPlayer.’ 
Copy the video file. Copy two files, color_short.mp4 and sampleH263.3gp, 
under the /Video folder of the appendix to the /res folder of the source 
project.  
 
Unlike playing audio where you only need a Player and an audio file, t o 
play a video file you need a screen. You can build a screen in the following 
ways: 
 - Create EVAS  
 - Create an image object  
 - Specify that image object as a display for the Player  

  
Page 469 / 978 First, open the source file (~.c) under the src folder and add libraries and 
variables at the top of the screen.  
┌─────────────────────┐  
#include "videoplayer.h"  
#include <player.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    player_h player;  
    Evas_Object *video_rect ; 
} appdata_s;  
  
const char* file_name[] = { "sampleH263.3gp", "color_short.mp4" };  
└─────────────────────┘  
player_h is a Player structure that plays media such as audio and video. 
video_rect is an image object where video is displayed.  
file_name[] is an a rray of strings that save the file name.  
We are going to create an Image object to use as screen and a Bg widget 
to use as screen background. This is because the video will only look and 
feel the way it was intended on a black background. Create a new func tion 
on top of the create_base_gui() function. This function adds a widget to a 
Table. 
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
  
Page 470 / 978 { 
   evas_object_size_hint_align_set(child, EVAS_HI NT_FILL, EVAS_HINT_FILL);  
   evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
   elm_table_pack(table, child, x, y, w, h);  
   evas_object_show(child);  
} 
└─────────────────────┘  
Then, add new code to the create_base_gui() function. Conformant and 
Label are annotated.  
┌─────────────────────┐  
    /* Conformant */  
    /*ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_ INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);*/  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform) ; 
    elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
    Evas_Object *bg, *btn;  
 
    /* Backgrou nd */ 
    bg = elm_bg_add(ad ->win);  
    elm_bg_color_set(bg, 0, 0, 0);  
    elm_win_resize_object_add(ad ->win, bg);  
  
Page 471 / 978     evas_object_show(bg);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_win_resize_object_add(ad ->win, box);  
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->win);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 p ixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 10 * elm_config_scale_get(), 10 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(ta ble, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_box_pack_end(box, table);  
        evas_object_show(table ); 
 
        { 
            /* Container: standard table */  
            Evas_Object *tbl = elm_table_add(ad ->win);  
            evas_object_size_hint_weight_set(tbl, EVAS_HINT_EXPAND, EVAS_HINT_
EXPAND);  
            evas_object_size_hint_align_set(tbl, EVAS_HI NT_FILL, EVAS_HINT_FILL);  
            elm_object_content_set(ad ->conform, tbl);  
            evas_object_show(tbl);  
  
Page 472 / 978  
            /* The video object */  
            ad->video_rect = video_rect_add(tbl);  
            my_table_pack(table, ad ->video_rect, 0, 0, 3, 3);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
To change the background color to black, we have created a Bg widget. 
We have created a Table container to place  the widget based on the aspect 
ratio and used the Box to set the width between the widgets.  
The video_rect_add() function creates returns as well as an Evas image 
object. Now, let's start building this function step by step. Add two new 
functions on top o f the create_base_gui() function.  
┌─────────────────────┐  
// Get full path of resource file  
static inline const char *get_resource_path(const char *file_path)  
{ 
    static char absolute_path[PATH_MAX] = {' \0'}; 
    static char *res_path_buff = NULL;  
    if(res_path_buff == NULL)  
    { 
        res_path_buff = app_get_resource_path();  
    } 
  
    snprintf(absolute_path, PATH_MAX, "%s%s", res_path_buff, file_path);  
    return absolute_path;  
} 
  
Page 473 / 978 // Create Image for screen  
static Evas_Object *  
video_rect_add(Evas_ Object *parent)  
{ 
    Evas *evas = evas_object_evas_get(parent);  
    Evas_Object *image = evas_object_image_filled_add(evas);  
    evas_object_size_hint_weight_set(image, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    evas_object_size_hint_align_set(image, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_show(image);  
    return image;  
} 
└─────────────────────┘  
The get_resource_path() function returns the full path to all the files saved 
under the /res folder. We wil l use this when loading the video file.  
The video_rect_add() function creates Evas and Image objects in the screen 
area. 
Build and run the example. The entire screen display is black.  
  
Page 474 / 978  
 
2) Loading a video File  
As you run the app, you will create a Player object automatically and load 
the first video file. Add new code at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    // Create Player  
    ad->player = create_player();  
 
    // Load audio file to Player  
    prepare_player(ad, 0);  
} 
└─────────────────────┘  

  
Page 475 / 978 The create_player() function creates the Player, while the prepare_player() 
function loads the video file. Now, let’s start building it step by  step. Add 
five functions on top of the create_base_gui() function. From here, 
everything appears very similar to the AudioPlayer example.  
┌─────────────────────┐  
// Get player state  
static player_state_e  
get_player_state(player_h player)  
{ 
    player_state_e state;  
    player_get_state(player, &state);  
    return state;  
} 
  
// Play completed event function  
static void  
on_player_completed(player_h* player)  
{ 
    if(player)  
        player_stop(player);  
} 
  
// Create player  
static player_h  
create_player()  
{ 
    player_h player;  
  
    player_create(&player);  
    player_set_sound_type(player, SOUND_TYPE_MEDIA);  
    player_set_volume(player, 1.0, 1.0);  
    player_set_looping(player, false);  
  
Page 476 / 978     player_set_completed_cb(player, on_player_completed,  player);  
  
    return player;  
} 
  
// Stop play  
static void  
stop_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) == PLAYER_STATE_PLAYING || get_player_state(ad ->
player) == PLAYER_STATE_PAUSED)  
        player_stop(ad ->player);  
} 
  
// Load video file to Player  
static void  
prepare_player(appdata_s* ad, int index)  
{ 
    player_stop(ad ->player);  
    // Close file  
    player_unprepare(ad ->player);  
  
    const char* file = file_na me[index];  
    // Get full path of resource file  
    const char *res_path = get_resource_path(file);  
  
    // Load file  
    player_set_uri(ad ->player, res_path);  
    player_set_display(ad ->player, PLAYER_DISPLAY_TYPE_EVAS, GET_DISPLAY(ad ->video
_rect));  
    player_set_display_mode(ad ->player, PLAYER_DISPLAY_MODE_FULL_SCREEN);  
    // Prepare play  
  
Page 477 / 978     int result = player_prepare(ad ->player);  
    dlog_print(DLOG_INFO, "tag", "File load : %d", result);  
} 
└─────────────────────┘  
The get_player_state() function  returns the current status of the Player.  
player_get_state(player_h, player_state_e) is an API that returns the current 
status of the Player. The first parameter is the Player object, and the second 
parameter returns the status value. The types of player_ state_e status are:  
  - PLAYER_STATE_NONE,          /**< Player is not created */  
  - PLAYER_STATE_IDLE,          /**< Player is created, but not prepared */  
  - PLAYER_STATE_READY,         /**< Player is ready to play media */  
  - PLAYER_STATE_PLAYING,       /**< Player is playing media */  
  - PLAYER_STATE_PAUSED,        /**< Player is paused while playing 
media */  
on_player_completed() is a callback function invoked upon completion of 
playback.  
player_stop(player_h) is an API that stops the playback.  
The create_player() function creates a Player object.  
player_create(player_h *) is an API that creates a Player object.  
player_set_sound_type(player_h, sound_type_e) is an API that specifies the 
sound type. To play the video file, simply specify SOUND_TYPE_MED IA. 
player_set_volume(player_h, float, float) is an API that specifies the speaker 
volume. The volume values range from 0 to 1.0. The second parameter is 
  
Page 478 / 978 the left volume, while the third parameter is the right volume.  
player_set_looping(player_h, bool) is an API that determines whether the 
video will loop or not. If you pass True to the second parameter, it is 
looped. False will play it only once.  
player_set_completed_cb(player_h, player_completed_cb, void *) is an API 
that specifies the callback function u pon completion of playback. The 
second parameter is the name of the callback function, while the third 
parameter is the user data.  
The stop_player() function stops the playback.  
The prepare_player() function loads the video file.  
player_unprepare(player_h)  is an API that closes the file you loaded to the 
Player.  
player_set_uri(player_h, const char *) is an API that loads a file to the Player.  
The player_set_display(player_h, player_display_type_e, player_display_h) 
function specifies the screen to the Playe r. The first parameter specifies 
the Player object, while the second parameter specifies the screen type. 
If it is a canvas screen, specify PLAYER_DISPLAY_TYPE_EVAS. The third 
parameter passes the player_display_h object that corresponds to the 
screen.  
The GET_DISPLAY() function requests player_display_h from the object.  
player_prepare(player_h) is an API that prepares for playback by the Player. 
When it is ready to play, it returns 0.  
  
Page 479 / 978 If you build and start running this way, you will see or hear nothing on  
the screen. If you check the message on the Log window, ‘File load: 0’ is 
displayed.  
 
 
3) Playing  Video  
We will implement a feature that plays the video file when the Button is 
tapped. Add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Table */  
    ~ 
    elm_box_pack_end(box, table);  
    evas_object_show(table);  
 
    { 
        /* Play Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Play");  
        evas_object_smart_callbac k_add(btn, "clicked", start_player, (void*)ad);  
        my_table_pack(table, btn, 0, 3, 1, 1);  
 

  
Page 480 / 978         /* Container: standard table */  
        Evas_Object *tbl = elm_table_add(ad ->win);  
        evas_object_size_hint_weight_set(tbl, EVAS_HINT_EXPAND, EVAS_ HINT_EXPAND);  
        evas_object_size_hint_align_set(tbl, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, tbl);  
        evas_object_show(tbl);  
└─────────────────────┘  
We have added a code that creates a Button. Now, we need to  create a 
callback function for the Button. Create a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
// Start play  
static void  
start_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) != PLAYER_STATE_PLAYING)  
        player_start(ad ->player);  
} 
└─────────────────────┘  
The start_player() function starts playing the video.  
player_start(player_h) is an API that starts playing the video.  
Run the example again and tap the Play button. This plays the video.  
  
Page 481 / 978  
 
4) Pausing and Stopping  
We will now add two Buttons to implement the Pause and Stop features. 
Add new code to the create_base_gui() function.  
┌─────────────────────┐  
        /* Play Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Play");  
        evas_object_smart_callback_add(btn, "clicked", start_player, (void*)ad);  
        my_table_pack(table, btn, 0, 3, 1, 1);  
 
        /* Pause Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Pause");  
        evas_object_smart_callback_add(btn, "clicked", pause_player, (void*)ad);  
        my_table_pack(table, btn, 1, 3, 1, 1);  
 
        /* Stop Button */  
        btn = elm_b utton_add(ad ->win);  
        elm_object_text_set(btn, "Stop");  

  
Page 482 / 978         evas_object_smart_callback_add(btn, "clicked", stop_player, (void*)ad);  
        my_table_pack(table, btn, 2, 3, 1, 1);  
 
        /* Container: standard table */  
        Evas_Object *tbl =  elm_table_add(ad ->win);  
        evas_object_size_hint_weight_set(tbl, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
        evas_object_size_hint_align_set(tbl, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, tbl);  
        evas_object_ show(tbl);  
└─────────────────────┘  
We have added two Buttons. We are now going to create a callback 
function for the Buttons. Add new code on top of the create_base_gui() 
function.  
┌─────────────────────┐  
// Pause play  
static void pause_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    if( get_player_state(ad ->player) == PLAYER_STATE_PLAYING )  
        player_pause(ad ->player);  
} 
└─────────────────────┘  
The start_player() function pauses the video playback.  
player_start(player_h) is an API that pauses the video playback.  
You do not need to create another callback function for the Stop button 
because you already have the stop_player() function in place.  
  
Page 483 / 978 Run the example again and tap the Play button to play the  video. Tap the 
Pause button to pause or the Play Again button to restart. Tap the Stop 
button to stop or the Play Again button to start playing from the 
beginning.  
 
 
5) Changing the Video File  
We will implement a feature that changes the video file by adding two 
Buttons. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
        /* Stop Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "Stop");  
        evas_object_smart_callback_add(btn, "clicked", st op_player, (void*)ad);  
        my_table_pack(table, btn, 2, 3, 1, 1);  
 
        /* File Load -1 Button */  
        btn = elm_button_add(ad ->win);  

  
Page 484 / 978         elm_object_text_set(btn, "File -1"); 
        evas_object_smart_callback_add(btn, "clicked", btn_load_file1 , (void*)ad);  
        my_table_pack(table, btn, 0, 4, 3, 1);  
 
        /* File Load -2 Button */  
        btn = elm_button_add(ad ->win);  
        elm_object_text_set(btn, "File -2"); 
        evas_object_smart_callback_add(btn, "clicked", btn_load_file2, (void*) ad); 
        my_table_pack(table, btn, 0, 5, 3, 1);  
 
        /* Container: standard table */  
        Evas_Object *tbl = elm_table_add(ad ->win);  
        evas_object_size_hint_weight_set(tbl, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
        evas_object_size_hint_align_set(tbl, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, tbl);  
        evas_object_show(tbl);  
└─────────────────────┘  
We have created two Buttons. Finally, we are ready to create a callback 
function for the Buttons. Add new code on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static void  
btn_load_file1(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    // Load file to Player  
    prepare_player(ad,  0); 
} 
  
static void  
btn_load_file2(void *data, Evas_Object *obj, void *event_info)  
  
Page 485 / 978 { 
    appdata_s *ad = data;  
    // Load file to Player  
    prepare_player(ad, 1);  
} 
└─────────────────────┘  
The btn_load_file1() function loads the first video file. If you  pass 0 to the 
second parameter of the prepare_player() function, the first video file will 
be loaded.  
The btn_load_file2() function loads the first video file. If you pass 1 to the 
second parameter of the prepare_player() function, the second video file 
will be loaded.  
Run the example again and tap the File -2 button followed by the Play 
button. You see a different video. Now, tap the File -1 button followed by 
the Play button. You will see the same video you saw before.  
 
 

  
Page 486 / 978 6) Related APIs  
int  player_get_s tate(player_h player, player_state_e *state): an API that 
returns the current status of the Player. The first parameter is the Player 
object, while the second parameter returns the status value. The types of 
player_state_e status are:  
  - PLAYER_STATE_NONE ,          /**< Player is not created */  
  - PLAYER_STATE_IDLE,          /**< Player is created, but not prepared */  
  - PLAYER_STATE_READY,         /**< Player is ready to play media */  
  - PLAYER_STATE_PLAYING,       /**< Player is playing media */  
  - PLAYER_STATE_PAUSED,        /**< Player is paused while playing media 
*/ 
int player_stop(player_h player): an API that stops the playback.  
int player_create(player_h *player): an API that creates a Player object.  
int  player_set_sound_type(player_h player, sound_type_e type): an API 
that specifies the sound type. To play the video file, simply specify 
SOUND_TYPE_MEDIA.  
int  player_set_volume(player_h player, float left, float right): an API that 
specifies the speaker volume. The volume values range from 0 to  1.0. / 
parameters:  Player  object,  left volume, right volume.  
int  player_set_looping(player_h player, bool looping):  an API that 
determines whether the audio will loop or not. If you pass True to the 
second parameter, it is looped. False will play it only  once. 
 
  
Page 487 / 978 int  player_set_completed_cb(player_h player, player_completed_cb 
callback, void *user_data): an API that specifies the callback function 
upon completion of playback. / parameters: Player object, name of 
callback function, user data.  
int  player_un prepare(player_h player): an API that closes the file you 
loaded to the Player.  
int  player_set_uri(player_h player, const char * uri): an API that loads a 
file to the Player.  
int  player_prepare(player_h player): an API that prepares for playback by 
the Player. When it is ready to play, it returns 0.  
int  player_start(player_h player): an API that starts playing the video.  
int  player_pause(player_h player): an API that pauses the video 
playback.  
  
  
Page 488 / 978 40. Recording Audio  
You can record sound using the microphone that comes with your 
smartphone. You can record music at a concert, record your own voice to 
send to someone instead of a text message, or use it as a memo pad. Let 
us find out in detail how to do this with an example.  
1) Registering a Privilege  
Create a n ew source project and specify the project name as ‘RecorderEx.’ 
You need to have the applicable user privilege to be able to use the 
recorder. After the source project is created, open the tizen -manifest.xml 
file and click ‘Privileges’ from the lower tab b uttons. Then, click the Add 
button in the upper right corner. In the popup  window, select 
http://tizen.org/privilege/recorder from the list and click the OK button to 
close the window.  
  
Page 489 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" pa ckage="org. exam
ple.recorderex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .recorderex" exec="recorderex" multiple="false" 
nodisplay="false" taskmanage="true" type="capp">  
        <label>recorderex</label>  
        <icon>recorderex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/recorder</privilege>  
    </privileges>  

  
Page 490 / 978 </manifest>  
└─────────────────────┘  
 
2) Creating a Recorder  
To create a Recorder, you must specify the Co dec, file type, and quality. 
Open the source file (~.c) under the src folder and add libraries, variables, 
and structure at the top of the screen.  
┌─────────────────────┐  
#include "recorderex.h"  
#include <recorder.h>  
#include <player.h>  
  
typedef struct ap pdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
 
    Evas_Object *btn_rec, *btn_recstop, *btn_play, *btn_playstop;  
 
    player_h player;  
    recorder_h recorder;  
    recorder_audio_codec_e *codec_list;  
    int codec_list_len;  
    char file_path[PATH_MAX];  
    recorder_audio_codec_e codec;  
    recorder_file_format_e file_format;  
    FILE *preproc_file;  
} appdata_s;  
  
  
Page 491 / 978 typedef struct  
{ 
    recorder_audio_codec_e *codec_list;  
    int len;  
} supported_encoder_data;  
└─────────────────────┘  
In this example, we are going to create a total of four Button widgets.  
You have declared four variables (btn_rec, btn_recstop, btn_play, 
btn_playstop) to change the Enable status of each Button.  
player_h is a player structure that we used in the AudioPlayer and 
VideoPlayer examples.  
recorder_h is a recorder structure.  
recorder_audio_codec_e is an Enumeration that saves the types of codec.  
codec_list_len is a variable that saves the number of codec lists.  
file_path[] is a variable th at saves the path to the recorded file.  
recorder_file_format_e is an Enumeration that saves information on the file 
type. 
FILE is a file data stream that you use for file input/output.  
supported_encoder_data is a structure that saves the list of supported 
codecs.  
We will now create a Recorder object. Add new code at the end of the 
create_base_gui() function.  
  
Page 492 / 978 ┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    // Create recorder  
    _recorder_create(ad);  
    ad->codec_list = audio_recorder_get_supported_encoder(ad ->recorder, &ad ->c
odec_list_len);  
    ad->codec = ad ->codec_list_len ? ad ->codec_list[0] : RECORDER_AUDIO_CODE
C_PCM;  
  
    _codec_set(ad, codec);  
} 
└───────────────────── ┘ 
The _recorder_create() function creates a Recorder.  
  
  
Page 493 / 978 The audio_recorder_get_supported_encoder() function requests a list of 
supported codecs and returns it.  
When you have the codec list in hand, save the first codec to a variable 
called codec. If the li st does not exist, save the PCM codec instead.  
The _codec_set() function specifies the codec.  
 
Next, we need to enter the code required to create a Recorder. Add eight 
new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
// Check  is recording  
static bool  
_recorder_is_recording(appdata_s *ad)  
{ 
    recorder_state_e state = RECORDER_STATE_NONE;  
    recorder_get_state(ad ->recorder, &state);  
    return state == RECORDER_STATE_RECORDING;  
} 
 
// Stop recording  
static void  
record_stop(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    if (ad->recorder)  
    { 
        recorder_commit(ad ->recorder);  
        // Check is recording  
        if (!_recorder_is_recording(ad))  
  
Page 494 / 978         { 
            recorder _unprepare(ad ->recorder);  
        } 
        elm_object_disabled_set(ad ->btn_play, EINA_FALSE);  
        elm_object_disabled_set(ad ->btn_rec, EINA_FALSE);  
        elm_object_disabled_set(ad ->btn_playstop, EINA_TRUE);  
        elm_object_disabled_set(ad ->btn_r ecstop, EINA_TRUE);  
    } 
} 
 
// Maximum recording time event callback function  
static void  
_on_recording_limit_reached_cb(recorder_recording_limit_type_e type, void *user_data)  
{ 
    appdata_s *ad = user_data;  
    if(type == RECORDER_RECORDING_LIMIT_TIME)  
        // Stop recording  
        record_stop(ad, NULL, NULL);  
} 
  
// Create recorder  
static void  
_recorder_create(appdata_s *ad)  
{ 
    if(recorder_create_audiorecorder(&ad ->recorder) == RECORDER_ERROR_NONE)  
    { 
        // Set maximum recording time ev ent callback function  
        recorder_set_recording_limit_reached_cb(ad ->recorder, _on_recording_limit_reache
d_cb, ad);  
        recorder_attr_set_audio_channel(ad ->recorder, 1);  
        recorder_attr_set_audio_device(ad ->recorder, RECORDER_AUDIO_DEVICE_MI C); 
        recorder_attr_set_time_limit(ad ->recorder, 20);  
    } 
} 
  
Page 495 / 978 static bool  
_recorder_supported_audio_encoder_cb(recorder_audio_codec_e codec, void *user_data)  
{ 
    bool result = false;  
    supported_encoder_data *data = user_data;  
  
    if(data && c odec != RECORDER_AUDIO_CODEC_DISABLE)  
    { 
        data->codec_list = realloc(data ->codec_list, sizeof(supported_encoder_data) * (d
ata->len + 1));  
        data->codec_list[data ->len] = codec;  
        ++(data ->len); 
        result = true;  
    } 
  
    return result;  
} 
  
recorder_audio_codec_e*  
audio_recorder_get_supported_encoder(recorder_h recorder, int *list_length)  
{ 
    supported_encoder_data data = {0};  
    data.codec_list = NULL;  
    data.len = 0;  
  
    int res = recorder_foreach_supported_aud io_encoder(recorder, _recorder_supported
_audio_encoder_cb, &data);  
  
    if(res && list_length)  
    { 
        *list_length = data.len;  
    } 
  
    return data.codec_list;  
  
Page 496 / 978 } 
  
const char*  
get_file_format_by_codec(appdata_s* ad)  
{ 
    switch(ad ->codec)  
    { 
    case RECORDER_AUDIO_CODEC_AMR:  
        ad->file_format = RECORDER_FILE_FORMAT_AMR;  
        return "AMR";  
        break;  
    case RECORDER_AUDIO_CODEC_AAC:  
        ad->file_format = RECORDER_FILE_FORMAT_MP4;  
        return "MP4";  
        break;  
    case RECORDER_AUDIO_CODEC_VORBIS:  
        ad->file_format = RECORDER_FILE_FORMAT_OGG;  
        return "OGG";  
        break;  
    } 
  
    ad->file_format = RECORDER_FILE_FORMAT_WAV;  
    return "WAV";  
} 
  
static void  
_codec_set(appdata_s *ad)  
{ 
    char f ile_name[NAME_MAX] = {' \0'}; 
    const char *file_ext = get_file_format_by_codec(ad);  
  
    char *data_path = app_get_data_path();  
    snprintf(file_name, NAME_MAX, "record.%s", file_ext);  
    snprintf(ad ->file_path, PATH_MAX, "%s%s", data_path, file_name) ; 
  
Page 497 / 978     free(data_path);  
} 
└─────────────────────┘  
The _recorder_is_recording() function checks the status of recording.  
The record_stop() function stops recording.  
recorder_commit(recorder_h recorder) is an API that stops recording and 
saves the data.  
recorder_unprepare(recorder_h recorder) is an API that initializes the 
recorder.  
_on_recording_limit_reached_cb() is an event function that is invoked when 
the maximum recording time is reached. It forcibly stops the recording.  
The _recorder_create() funct ion creates a Recorder.  
recorder_create_audiorecorder() is an API that creates a Recorder.  
recorder_set_recording_limit_reached_cb() is an API that specifies the event 
function for reaching the maximum time for recording.  
recorder_attr_set_audio_channel() is an API that specifies the number of 
audio channels. Specify 1 in Mono and 2 in Stereo.  
recorder_attr_set_audio_device() is an API that specifies the recording 
device. On your smartphone, it is okay to specify 
RECORDER_AUDIO_DEVICE_MIC since you are usin g a microphone.  
 
  
Page 498 / 978 recorder_attr_set_time_limit() is an API that specifies the maximum time 
for recording (in seconds).  
_recorder_supported_audio_encoder_cb() is a callback function that 
receives the list of supported audio codecs.  
The audio_recorder_get_supported_encoder() function requests a list of 
supported codecs and returns it.  
recorder_foreach_supported_audio_encoder(recorder_h recorder, 
recorder_supported_audio_encoder_cb callback, void *user_data) is an API 
that requests a list of supported codecs. It passes the list data to the 
callback function instead of requesting the list right away.  
The get_file_format_by_codec() function returns either the file format or 
file extension depending on the codec type.  
The _codec_set() function  specifies the codec.  
 
3) Getting Started with Recording  
We will add two Buttons to the screen to implement the Pause and Stop 
Recording features. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
  
Page 499 / 978 PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *btn, *frame, *tbl;  
 
        /* Frame for some outer padding */  
        frame = elm_frame_add(ad ->conform);  
        elm_object_style_set(frame, "pad_medium");  
        elm_object_content_set(ad ->conform, frame);  
        evas_object_show(frame);  
 
        /* Table to pack our elements */  
        tbl = elm_table_add(frame);  
        elm_table_padding_set(tbl, 5 * elm _scale_get(), 5 * elm_scale_get());  
        elm_object_content_set(frame, tbl);  
        evas_object_show(tbl);  
 
        { 
            /* Just a label */  
            ad->label = elm_label_add(tbl);  
            elm_object_text_set(ad ->label, "Audio recorder" ); 
            evas_object_size_hint_align_set(ad ->label, 0.5, 0.5);  
            evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS
_HINT_EXPAND);  
            elm_table_pack(tbl, ad ->label, 0, 0, 2, 1);  
            evas_object_show(ad ->label ); 
 
            /* Record Start Button */  
            btn = elm_button_add(tbl);  
            elm_object_text_set(btn, "Recording Start");  
            evas_object_smart_callback_add(btn, "clicked", record_start, (void*)ad);  
            evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
  
Page 500 / 978             evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.5);  
            elm_table_pack(tbl, btn, 0, 1, 1, 1);  
            evas_object_show(btn);  
            ad->btn_rec = bt n; 
 
            /* Record Stop Button */  
            btn = elm_button_add(tbl);  
            elm_object_disabled_set(btn, EINA_TRUE);  
            elm_object_text_set(btn, "Recording Stop");  
            evas_object_smart_callback_add(btn, "clicked", record_s top, (void*)ad);  
            evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
            evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.5);  
            elm_table_pack(tbl, btn, 1, 1, 1, 1);  
            evas_object_show(btn);  
            ad->btn_recstop = btn;  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We have created a Table container in order to place the widget based on 
the aspect ratio and specified the outside margin using the Frame.  
We will implement a feature that starts recording. Add two new functions 
on top of the create_base_gui() function.  
┌─────────────────────┐  
// Apply settings to recorder  
static void _recorder_apply_settings(appdata_s *ad)  
{ 
    if(ad->recorder)  
  
Page 501 / 978     { 
        // Set record file name  
        recorder_set_filename(ad ->recorder, ad ->file_path);  
        // Set record file format  
        recorder_set_file_format(ad ->recorder, ad ->file_format);  
        // Set record codec  
        recorder_set_audio_encoder(ad ->recorder, ad ->codec);  
    } 
} 
// Start recording  
static void  
record_start(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    if (ad->recorder)  
    { 
        // Apply settings to recorder  
        _recorder_apply_settings(ad);  
        recorder_prepare(ad ->recorder);  
        recorder_start(ad ->recorder);  
        elm_object_disabled_set(ad ->btn_recstop, EINA_FALSE);  
        elm_object_disabled_set(ad ->btn_rec, EINA_TRUE);  
        elm_object_disabled_set( ad->btn_play, EINA_TRUE);  
        elm_object_disabled_set(ad ->btn_playstop, EINA_TRUE);  
    } 
} 
└─────────────────────┘  
The _recorder_apply_settings() function specifies information about the 
recording.  
recorder_set_filename() is an API that specifies the file name of the 
recording.  
  
Page 502 / 978 recorder_set_file_format() is an API that specifies the recording format.  
recorder_set_audio_encoder() is an API that specifies the codec.  
The record_start() function starts recording.  
recorder_prepare() is an API that prepares for recording.  
recorder_start() is an API that starts recording.  
After building the example, run it and tap the Rec Start button to start 
recording. Recording ends automatically after 20 seconds. You can also 
stop manually by tapping the Rec Stop button. U nfortunately, there is no 
way to hear the recorded audio file as we have not yet implemented the 
audio playback feature.  
 
 
  

  
Page 503 / 978 4) Playing the Recording  
We will now implement a feature that plays the audio file. Add a code 
that creates two new Buttons to the  create_base_gui() function.  
┌─────────────────────┐  
            /* Record Stop Button */  
            ~ 
            evas_object_show(btn);  
            ad->btn_recstop = btn;  
 
            /* Play Start Button */  
            btn = elm_button_add(tbl);  
            elm_object_disabled_set(btn, EINA_TRUE);  
            elm_object_text_set(btn, "Play Start");  
            evas_object_smart_callback_add(btn, "clicked", start_player, (void*)ad);  
            evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, EVAS _HINT
_EXPAND);  
            evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.0);  
            elm_table_pack(tbl, btn, 0, 2, 1, 1);  
            evas_object_show(btn);  
            ad->btn_play = btn;  
 
            /* Play Stop Button */  
            btn = elm_button_add(tbl);  
            elm_object_disabled_set(btn, EINA_TRUE);  
            elm_object_text_set(btn, "Play Stop");  
            evas_object_smart_callback_add(btn, "clicked", stop_player, (void*)ad);  
            evas_object_size_ hint_weight_set(btn, EVAS_HINT_EXPAND, EVAS_HINT
_EXPAND);  
            evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0.0);  
            elm_table_pack(tbl, btn, 1, 2, 1, 1);  
            evas_object_show(btn);  
  
Page 504 / 978             ad->btn_playstop = btn;  
        } 
    } 
 
    // create player  
    ad->player = create_player();  
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
The create_player() function creates a Player. Next, add five new functions 
on top of the create_base_gui() function. You will see this is almost the 
same as the source code in the AudioPlayer example.  
┌─────────────────────┐  
// Get player state  
static player_state_e get_player_state(player_h player)  
{ 
    player_state_e state;  
    player_get_state(player, &state);  
    return state;  
} 
 
// Stop play  
static void  
stop_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
 
    if( get_player_state(ad ->player) == PLAYER_STATE_PLAYING || get_player_state(ad -
>player) == PLAYER_STATE_PAUSED)  
        player_stop(ad ->player);  
  
Page 505 / 978     elm_object_disabled_set(ad ->btn_play, EINA_FALSE);  
    elm_object_disabled_set(ad ->btn_playstop, EINA_TRUE);  
    elm_object_disabled_set(ad ->btn_rec, EINA_FALSE);  
    elm_object_disable d_set(ad ->btn_recstop, EINA_TRUE);  
} 
 
// Load file to player  
static void  
prepare_player(appdata_s* ad)  
{ 
    stop_player(ad, NULL, NULL);  
    player_unprepare(ad ->player);  
    player_set_uri(ad ->player, ad ->file_path);  
    player_prepare(ad ->player);  
} 
 
// Start play  
static void  
start_player(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    prepare_player(ad);  
 
    if (get_player_state(ad ->player) != PLAYER_STATE_PLAYING)  
    { 
        player_start(ad ->player);  
 
        elm_o bject_disabled_set(ad ->btn_rec, EINA_TRUE);  
        elm_object_disabled_set(ad ->btn_recstop, EINA_TRUE);  
        elm_object_disabled_set(ad ->btn_play, EINA_TRUE);  
        elm_object_disabled_set(ad ->btn_playstop, EINA_FALSE);  
    } 
} 
 
  
Page 506 / 978 // Create player  
static player_h create_player()  
{ 
    player_h player;  
  
    player_create(&player);  
    player_set_completed_cb(player, NULL, player);  
  
    return player;  
} 
└─────────────────────┘  
Please see the AudioPlayer example for more details.  
Run the example. You need to connect a microphone if you are testing on 
your desktop with an emulator. On a phone or a laptop, a microphone is 
not required for testing.  Try testing by following the steps below:  
 - Tap the Record Start button to record voice.  
 - Tap the Record Stop button to stop recording. It stops automatically 
after 20 seconds.  
 - The Play Start button will play the audio you have recorded.  
 - If you would like to stop playing during playback, tap the Play Stop 
button.  
 
 
  

  
Page 507 / 978 5) Related APIs  
int  preference_set _int(const char *key, int value): an API that saves an 
integer value in the local memory. It passes a key value to the first 
parameter and data to the second parameter.  
int  preference_set_boolean(const char *key, bool value): an API that saves 
a Boolean v alue in the local memory. It passes a key value to the first 
parameter and data to the second parameter.  
int  preference_get_boolean(const char *key, bool *value): an API that 
requests Boolean -type data from the local memory. As it passes a key 
value to th e first parameter, the result value is returned from the second 
parameter.  
int  preference_get_int(const char *key, int *value): an API that requests 
integer -type data from the local memory. As it passes a key value to the 
first parameter, the result value  is returned from the second parameter.  
int  recorder_create_audiorecorder(recorder_h *recorder): an API that 
creates a Recorder.  
int  recorder_set_recording_status_cb(recorder_h recorder, 
recorder_recording_status_cb callback, void *user_data): an API spe cifying 
an event function that changes the status of recording.  
int  recorder_set_recording_limit_reached_cb(recorder_h recorder, 
recorder_recording_limit_reached_cb callback, void *user_data): an API 
specifying an event function that reaches the maximum t ime for 
recording.  
  
Page 508 / 978 int  recorder_attr_set_audio_channel(recorder_h recorder, int 
channel_count): an API that specifies the number of audio channels. 
Specify 1 in Mono and 2 in Stereo.  
int  recorder_attr_set_audio_device(recorder_h recorder, 
recorder_audio_ device_e device): an API that specifies the recording 
device. On your smartphone, you can specify 
RECORDER_AUDIO_DEVICE_MIC since you are using a microphone.  
int  recorder_attr_set_time_limit(recorder_h recorder, int second): an API 
that specifies the maxi mum time for recording (in seconds).  
int  recorder_set_filename(recorder_h recorder, const char *path): an API 
that specifies the file name of the recording.  
int  recorder_set_file_format(recorder_h recorder, recorder_file_format_e 
format): an API that spe cifies the recording format.  
int  recorder_set_audio_encoder(recorder_h recorder, 
recorder_audio_codec_e codec): an API that specifies the codec.  
int  recorder_prepare(recorder_h recorder): an API that prepares for 
recording.  
int  recorder_start(recorder_h  recorder): an API that starts recording.   
  
Page 509 / 978 41. Camera Capture  
Digital cameras are becoming increasingly obsolete as the performance of 
smartphones' built -in cameras makes rapid and steady progress. In fact, 
smartphone cameras have shown remarkable improvement comparable to 
the level of conventional digital cameras. Consumers nowadays place great 
emphasis on the camera quality when choosing a smartphone. A built -in 
camera is used not only for taking photos but also for all sorts of other 
purposes, including vide o calls, augmented reality, or as barcode scanners.  
In this section, we are going to watch a video in Preview mode using the 
camera mounted on your phone. We will also learn how to take a picture 
and save it as a file.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as ‘CameraEx.’ 
You need to have the applicable user privilege to be able to use the 
camera. After the source project is created, open the tizen -manifest.xml 
file and click Privileges from the lower t ab buttons. Then, click the Add 
button in the upper right corner. In the popup  window, select 
http://tizen.org/privilege/camera from the list and click the OK button to 
close the window.  
  
Page 510 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" pa ckage="org. exam
ple.cameraex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .cameraex" exec="cameraex" multiple="false" n
odisplay="false" taskmanage="true" type="capp">  
        <label>cameraex</label>  
        <icon>came raex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/camera</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  
  

  
Page 511 / 978 You need a screen to play a preview video. We are now going to copy the 
EDJE fil e. Do the following:  
 - Right-click the /res folder and select [New > Folder] in the shortcut 
menu.  
 
 - When prompted, enter ‘edje’ in the Folder name field.  
 
  

  
Page 512 / 978  - Copy the camera_capture.edc and camera_capture.edj files located 
under the /etc/edje folder of the appendix to the new folder.  
 
 
2) Camera Preview Video  
Open the source file (~.c) under the src folder and add libraries and 
variables at the top of the screen.  
┌─────────────────────┐  
#include "cameracapture.h"  
#include <camera.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *layout;  
    Evas_Object *camera_rect;  
    Evas_Object * image ;  
    Evas_Object * box; 
 

  
Page 513 / 978     camera_h camera;  
    char *image_path;  
} appdata_s;  
└─────── ──────────────┘  
The preview video resembles the screen we used in the VideoPlayer 
example. The layout is the preview area, while camera_rect is the Image 
object that displays the preview video.  
We will display the picture we took in the image object.  
camera_h is a camera structure.  
image_path is a file path to which you save the picture you have taken.  
We are now going to create a Camera object and display the preview 
video on the screen. Create a new function on top of the create_base_gui() 
function. This function adds a Widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
                        double h_weight, double v_weight, double h_align, double 
v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame styl e */ 
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
  
Page 514 / 978    evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_si ze_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the ch ild directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, add new code to the create_base_gui() function. The Label -creating 
code will not be used in this example, so annotate it.  
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    /* first say that we prefer acceleration via opengl - before we create any w
indows */  
    elm_config_accel_preference_set("opengl");  
 
    ~ 
 
    eext_object_event_callback_add(ad ->win, EEXT_CALLBACK_BACK, win_back_cb, ad);  
 
    /* Conformant */  
  
Page 515 / 978     ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
    elm_object_content_set(ad ->conform, ad ->label);*/  
 
    { /* child object - indent to how relationship */  
        /* A box to  put things in verticallly - default mode for box */  
        ad->box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(ad ->box, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
        elm_object_content_set(ad ->conform, ad ->box);  
        evas_object_sh ow(ad ->box);  
 
        { /* child object - indent to how relationship */  
            /* Create preview screen */  
            Evas_Object *layout = _main_layout_add(ad, ad ->win);  
            my_box_pack(ad ->box, layout, 0.9, 1.0, -1.0, -1.0); 
         } 
    } 
 
    _create_camera(ad);  
    // Start camera preview  
    camera_start_preview(ad ->camera);  
 
  
Page 516 / 978     /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
To display the camera preview, you must use the OpenGL lib rary. You can 
do this by simply passing ‘opengl’ to the elm_config_accel_preference_set() 
function.  
The _main_layout_add() function creates a Layout object that belongs to 
the preview area.  
The _create_camera() function creates a Camera object.  
camera_start_preview() is an API that starts a preview.  
We will begin creating the functions we mentioned above. Add four new 
functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static inline const char*  
get_resource_path(const char  *file_path)  
{ 
    static char absolute_path[PATH_MAX] = "";  
    static char *res_path_buff = NULL;  
    if (res_path_buff == NULL)  
        res_path_buff = app_get_resource_path();  
    snprintf(absolute_path, sizeof(absolute_path), "%s%s", res_path_buff, fi le_path);  
    return absolute_path;  
} 
 
// Create preview screen  
static Evas_Object*  
  
Page 517 / 978 _main_layout_add(appdata_s *ad, Evas_Object *parent)  
{ 
    Evas_Object *layout = elm_layout_add(parent);  
    ad->layout = layout;  
 
    char *edje_path = get_resource_path(" edje/camera_capture.edj");  
    elm_layout_file_set(ad ->layout, edje_path, "camera_capture");  
 
    Evas *evas = evas_object_evas_get(parent);  
    ad->camera_rect = evas_object_image_filled_add(evas);  
    elm_object_part_content_set(layout, "render", ad ->camera_rect);  
 
    return layout;  
} 
 
static void _destroy_camera(appdata_s *ad)  
{ 
    if(ad->camera)  
    { 
        camera_stop_preview(ad ->camera);  
        camera_destroy(ad ->camera);  
        ad->camera = NULL;  
    } 
} 
  
static void  
_create_camera(appdata_s *ad) 
{ 
    if(ad->camera)  
        _destroy_camera(ad);  
  
    if(camera_create(CAMERA_DEVICE_CAMERA0, &ad ->camera) == CAMERA_ERROR_N
ONE) 
    { 
  
Page 518 / 978         camera_set_capture_format(ad ->camera, CAMERA_PIXEL_FORMAT_JPEG);  
        camera_set_display(ad ->camera, CA MERA_DISPLAY_TYPE_EVAS, GET_DISPLAY(ad -
>camera_rect));  
        camera_set_display_mode(ad ->camera, CAMERA_DISPLAY_MODE_FULL);  
        camera_set_display_rotation(ad ->camera, CAMERA_ROTATION_ 270); 
        camera_set_display_flip(ad ->camera, CAMERA_FLIP_VERT ICAL); 
    } 
    else 
        ad->camera = NULL;  
} 
└─────────────────────┘  
The get_resource_path() returns the absolute path to the files located 
under the /res folder.  
The _main_layout_add() function creates a Layout object that belongs to 
the preview area. The details overlap with the VideoPlayer example.  
The _destroy_camera() function deletes a Camera object.  
camera_stop_preview(camera_h) is an API that stops the camera preview.  
camera_destroy(camera_h) is an API that deletes a Camera object.  
The _cre ate_camera() function creates and previews a Camera object.  
camera_create(camera_device_e, camera_h *) is an API that creates a 
Camera object. If CAMERA_DEVICE_CAMERA0 is passed to the first 
parameter, use the rear camera. If CAMERA_DEVICE_CAMERA1 is passe d, 
use the front camera. The Camera object that has been created is returned 
to the second parameter.  
  
Page 519 / 978 camera_set_capture_format(camera_h, camera_pixel_format_e) is an API 
that specifies the format of your photo image. Photos are generally large 
in size, so  the JPEG format is recommended.  
camera_set_display(camera_h, camera_display_type_e, camera_display_h) is 
an API that designates a preview screen to the Camera object. While using 
an Evas -based object, pass CAMERA_DISPLAY_TYPE_EVAS to the second 
parameter.  Pass the camera_display_h object that you requested by 
passing the Image object to the GET_DISPLAY() function, to the third 
parameter.  
camera_set_display_mode(camera_h, camera_display_mode_e) is an API 
that specifies the expand/collapse options of the pre view video. The 
option types are as follows:  
  - CAMERA_DISPLAY_MODE_LETTER_BOX = 0,    /**< Letter box */  
  - CAMERA_DISPLAY_MODE_ORIGIN_SIZE,       /**< Origin size */  
  - CAMERA_DISPLAY_MODE_FULL,           /**< Full screen */  
  - CAMERA_DISPLAY_MODE_CR OPPED_FULL,      /**< Cropped full 
screen */  
camera_set_display_rotation(camera_h, camera_rotation_e) is an API that 
specifies the rotation angle of the camera.  
camera_set_display_flip(camera_h, camera_flip_e) is an API that specifies 
whether it is vertica l or horizontal. The option types are as follows:  
  - CAMERA_FLIP_NONE,    /**< No Flip */  
  - CAMERA_FLIP_HORIZONTAL,  /**< Horizontal flip */  
  - CAMERA_FLIP_VERTICAL,    /**< Vertical flip */  
  - CAMERA_FLIP_BOTH     /** Horizontal and vertical flip */  
  
Page 520 / 978 Build an example and try running it. It should be tested on a PC with a 
smartphone or a webcam attached to it. The preview video is displayed at 
the top of the screen.  
 
 
3) Fixing the Screen Orientation  
The preview shifts as you turn the screen in a horizonta l position. This is 
because the screen orientation has changed from Portrait to Landscape. 
Let's now fix the screen orientation. Above the create_base_gui() function 
is a code that specifies the types of screen orientation. Make changes as 
follows:  
┌────── ───────────────┐  
    if (elm_win_wm_rotation_supported_get(ad ->win)) {  
        //int rots[4] = { 0, 90, 180, 270 };  
        int rots[4] = { 0 };  
        //elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 
4); 
        elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 
1); 
    } 
└─────────────────────┘  

  
Page 521 / 978 ‘0’ means Portrait Primary as opposed to ‘180,’ which means Portrait 
Secondary. ‘90’ means Landscape Primary, whereas ‘270’ means Landscape  
Secondary. Currently, only the Portrait Primary mode is supported.  
We will have the Camera object automatically deleted when you exit the 
app. Below the source file, add new code to the app_terminate() function.  
┌─────────────────────┐  
static void  
app_ter minate(void *data)  
{ 
    _destroy_camera(data);  
} 
└─────────────────────┘  
app_terminate() is a callback function that is executed when you exit the 
app. You can change the callback function in the main() function.  
If you run the example again and rotate th e screen, the location of the 
preview no longer shifts.  
 
4) Rotating the Preview with the Screen Orientation  
This time, we are going to demonstrate a feature that rotates the camera 
automatically as the screen rotates its orientation. Modify the code for t he 
main() function and ui_app_orient_changed() below the source file.  
┌─────────────────────┐  
static void  
ui_app_orient_changed(app_event_info_h event_info, void *user_data)  
  
Page 522 / 978 { 
 appdata_s *ad = user_data;  
 app_device_orientation_e screen_rot = 0;  
 camera_ro tation_e camera_rot = CAMERA_ROTATION_270;  
 bool horizontal_box = false;  
 /* Properly handle rotation */  
 app_event_get_device_orientation(event_info, &screen_rot);  
 switch (screen_rot)  
 { 
 case APP_DEVICE_ORIENTATION_0:  
  camera_rot = CAMERA_ROTATION_270;  
  break;  
 case APP_DEVICE_ORIENTATION_90:  
  camera_rot = CAMERA_ROTATION_180;  
  horizontal_box = true;  
  break;  
 case APP_DEVICE_ORIENTATION_180:  
  camera_rot = CAMERA_ROTATION_90;  
  break;  
 case APP_DEVICE_ORIENTATION_270:  
  camera_rot = CAMERA_ROTATION_ NONE;  
  horizontal_box = true;  
  break;  
 } 
 /* Set camera preview rotation */  
 camera_set_display_rotation(ad ->camera, camera_rot);  
 /* Make sure to rotate the window itself */  
 elm_win_rotation_with_resize_set(ad ->win, screen_rot);  
 /* Relayout elements in the window by chosing horizontal vs. vertical b
ox */ 
 elm_box_horizontal_set(ad ->box, horizontal_box);  
} 
 
int 
  
Page 523 / 978 main(int argc, char *argv[])  
{ 
 appdata_s ad = {0,};  
 int ret = 0;  
 
 ui_app_lifecycle_callback_s event_callback = {0,};  
 app_event_handler_h handlers[5] = {NULL, };  
 
 event_callback.create = app_create;  
 event_callback.terminate = app_terminate;  
 event_callback.pause = app_pause;  
 event_callback.resume = app_resume;  
 event_callback.app_control = app_control;  
 
 ui_app_add_event_handler(&handlers [APP_EVENT_DEVICE_ORIENTATION_C
HANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, ui_app_orient_changed, 
&ad);  
 ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP
_EVENT_LANGUAGE_CHANGED, ui_app_lang_changed, &ad);  
 
 ret = ui_app_main(argc, arg v, &event_callback, &ad);  
 if (ret != APP_ERROR_NONE) {  
  dlog_print(DLOG_ERROR, LOG_TAG, "app_main() is failed. err = %d", 
ret); 
 } 
 
 return ret;  
} 
└─────────────────────┘  
In the main() function, specify the event function for changing the screen 
orientat ion to ui_app_orient_changed(). If this code does not exist, add 
one. 
  
Page 524 / 978 Then, add new code to the ui_app_orient_changed() function.  
app_event_get_device_orientation() is an API that requests screen 
orientation from the event object. APP_DEVICE_ORIENTATION_0 or 
APP_DEVICE_ORIENTATION_180 is the Portrait mode; 
APP_DEVICE_ORIENTATION_90 or APP_DEVICE_ORIENTATION_270 is the 
Landscape mode.  
camera_set_display_rotation() is an API that rotates the camera.  
elm_win_rotation_with_resize_set() is an API that resizes th e window to 
align with the screen orientation.  
 
5) Camera Capture  
We will now implement a feature that captures a preview video and save 
it as an image file by tapping a Button. Add a Button -creating code to the 
create_base_gui() function.  
┌─────────────────────┐  
        { /* child object - indent to how relationship */  
            /* Create preview screen */  
            Evas_Object *layout = _main_layout_add(ad, ad ->win);  
            my_box_pack(ad ->box, layout, 0.9, 1.0, -1.0, -1.0); 
 
            /* Capture button */  
            Evas_Object *btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "#");  
            evas_object_smart_callback_add(btn, "clicked", btn_capture_cb, ad);  
            my_box_pack(ad ->box, btn, 0.1, 0.0, -1.0, 0.5);  
  
Page 525 / 978          } 
    } 
└─────────────────────┘  
Then, add five new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static inline char*  
gen_data_path(const char *file_name)  
{ 
    static char *absolute_path = NULL;  
    char r esult[PATH_MAX] = "";  
    if (absolute_path == NULL)  
       absolute_path = app_get_data_path();  
    snprintf(result, sizeof(result), "%s/%s", absolute_path, file_name);  
    return strdup(result);  
} 
 
// Save image data to file  
static char*  
_save_file(appdata_s *ad, camera_image_data_s *image)  
{ 
    char buf[PATH_MAX] = "";  
    snprintf(buf, PATH_MAX, "camera_capture.jpg");  
    char *file_name = gen_data_path(buf);  
 
    FILE *f = fopen(file_name, "w");  
 
    if(f) 
    { 
        fwrite(image ->data, image ->size, 1, f);  
        fclose(f);  
    } 
    else 
  
Page 526 / 978     { 
        free(file_name);  
        file_name = NULL;  
    } 
    return file_name;  
} 
 
static void  
_on_camera_capture_cb(camera_image_data_s *image, camera_image_data_s *postview,
 camera_image_dat a_s *thumbnail, void *user_data)  
{ 
    appdata_s *ad = user_data;  
    free(ad ->image_path);  
} 
 
static void _on_camera_capture_completed_cb(void *user_data)  
{ 
    appdata_s *ad = user_data;  
    camera_start_preview(ad ->camera);  
} 
  
static void  
btn_capture_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = (appdata_s *)data;  
    camera_start_capture(ad ->camera, _on_camera_capture_cb, _on_camera_capture_co
mpleted_cb, ad);  
} 
└─────────────────────┘  
The gen_data_path() function  returns the path to a file under the /data 
folder inside the app. You cannot create or modify files in the /res folder. 
For this reason, the files must be saved to the /data folder or public folder.  
  
Page 527 / 978 app_get_data_path() is an API that returns the absolute path to the /data 
folder.  
The _save_file() function saves the image data to a data file.  
_on_camera_capture_cb() is a callback function that receives the data 
captured by the camera. Save the data with this function.  
_on_camera_capture_completed_cb() is an  event callback function for 
completed camera capture. The preview must be restarted with this 
function since the preview ends after capturing.  
btn_capture_cb() is the callback function of the Button.  
camera_start_capture(camera_h, camera_capturing_cb, 
camera_capture_completed_cb, void *) is an API that starts the camera 
capture. The first parameter is a Camera object; the second parameter is 
a data transfer function; the third parameter is an event callback function 
for completing the capture; and the four th parameter is user data.  
Run the example again and tap the Button. If you hear the camera clicking, 
it means you have captured successfully. The feature of displaying the 
saved file is not implemented yet.  
  
Page 528 / 978  
 
5) Displaying the Saved Image File on the Scr een 
Now, we will add a feature that displays the saved image file in the Image 
object. Add a code that generates an Image object to the 
_main_layout_add() function.  
┌─────────────────────┐  
// Create preview screen  
static Evas_Object*  
_main_layout_add(appdata_s *ad, Evas_Object *parent)  
{ 
    ~ 
 
    Evas *evas = evas_object_evas_get(parent);  
    ad->camera_rect = evas_object_image_filled_add(evas);  
    elm_object_part_content_set(layout, "render", ad ->camera_rect);  
 
    ad->image = elm_ image_add(parent);  
    elm_object_part_content_set(layout, "gallery", ad ->image);  

  
Page 529 / 978     return layout;  
} 
└─────────────────────┘  
Load the image file to the Image object once the camera capture is done. 
Add new code to the _on_camera_capture_completed_cb() fu nction.  
┌─────────────────────┐  
static void  
_on_camera_capture_cb(camera_image_data_s *image, camera_image_data_s *postview,
 camera_image_data_s *thumbnail, void *user_data)  
{ 
    appdata_s *ad = user_data;  
    free(ad ->image_path);  
    ad->image_path = _s ave_file(ad, image);  
} 
└─────────────────────┘  
Run the example again and tap the Button to display the captured image 
in the Bg widget.  
 

  
Page 530 / 978 6) Related APIs  
int camera_start_preview(camera_h camera): an API that starts the preview.  
int camera_stop_preview(camera_h camera): an API that stops the preview.  
int camera_destroy(camera_h camera): an API that deletes a Camera object.  
int camera_create(camera_device_e device, camera_h *camera): an API that 
creates a Camera object. If CAMERA_DEVIC E_CAMERA0 is passed to the 
first parameter, the rear camera is used. If CAMERA_DEVICE_CAMERA1 is 
passed, the front camera is used. The Camera object that has been created 
is returned to the second parameter.  
int camera_set_capture_format(camera_h camera, c amera_pixel_format_e 
format): an API that specifies the format of your photo image. 
CAMERA_PIXEL_FORMAT_JPEG will create an image in JPEG.  
Int camera_set_display(camera_h camera, camera_display_type_e type, 
camera_display_h display): an API that designates  a preview screen to the 
Camera object. While using an Evas -based object, pass 
CAMERA_DISPLAY_TYPE_EVAS to the second parameter. Pass the 
camera_display_h object that you requested by passing the Image object 
to the GET_DISPLAY() function, to the third par ameter.  
Int camera_set_display_mode(camera_h camera, camera_display_mode_e 
mode): an API that specifies the expand/collapse options of the preview 
video. The option types are as follows:  
  - CAMERA_DISPLAY_MODE_LETTER_BOX = 0,    /**< Letter box */  
  - CAMERA_DISPLAY_MODE_ORIGIN_SIZE,       /**< Origin size */  
  
Page 531 / 978   - CAMERA_DISPLAY_MODE_FULL,          /**< Full screen */  
  - CAMERA_DISPLAY_MODE_CROPPED_FULL,      /**< Cropped full 
screen */  
int camera_set_display_rotation(camera_h camera, camera_rotation_e 
rotation): an API that specifies the rotation angle of the camera.  
int camera_set_display_flip(camera_h camera, camera_flip_e flip): an API 
that specifies whether it is vertical or horizontal. The option types are as 
follows:  
  - CAMERA_FLIP_NONE,   /**< No Flip */  
  - CAMERA_FLIP_HORIZONTAL, /**< Horizontal flip */  
  - CAMERA_FLIP_VERTICAL,   /**< Vertical flip */  
  - CAMERA_FLIP_BOTH    /** Horizontal and vertical flip */  
char *app_get_data_path(void): an API that returns the absolute path to 
the /data fold er. 
int camera_start_capture(camera_h camera, camera_capturing_cb 
capturing_cb, camera_capture_completed_cb completed_cb, void 
*user_data): an API that starts camera capture. / parameters:  Camera 
object, data transfer function, event callback function for completing the 
capture, and user data.  
  
  
Page 532 / 978 42. System Information  
During app development, system information is often displayed on the 
Help screen for you. If you are developing an app that utilizes a camera, 
you need to check whether you have a rear camera or a  front camera.  To 
make it compatible with devices with different resolutions, you also have 
to request the number of monitor pixels. In this example, we will learn 
how to request the system information.  
 
1) Whether or Not There is a Rear Camera  
Create a ne w source project and specify the project name as ‘SystemInfo.’ 
After the source project is created, open the source file (~.c) under the src 
folder and add a library header file as well as variables at the top.  
┌─────────────────────┐  
#include "systeminfo. h" 
#include <system_info.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label1;  
    Evas_Object *label2;  
    Evas_Object *label3;  
    Evas_Object *label4;  
    Evas_Object *label5;  
    Evas_Object *label6;  
} appdata_s;  
└─────────────────────┘  
  
Page 533 / 978 We have declared a total of six Label widget variables. We will now display 
whether or not the rear camera exists in the first Label, whether or not 
the front camera exists in the second Label, and whether or not you can 
make a call in the third Label. The number of horizontal pixels will be in 
the fourth Label, the number of vertical pixels in the fifth Label, and the 
platform version in the sixth Label. Create three new functions on top of 
the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int col, int row, int spanx, int s
pany, 
      bool h_expand, bool v_expand, double h_align, double v_align)  
{ 
    /* Create a frame around the child, for padding */  
    Evas_Object *frame = elm_frame_add(table);  
    elm_object_style_set(frame, "pad_small");  
 
    evas_object_size_hint_weight_set(frame, h_expand ? EVAS_HINT_EXPAND : 0, v_exp
and ? EVAS_HINT_EXPAND : 0);  
    evas_object_size_hint_align_set(frame, h_align,  v_align);  
 
    /* place child in its box */  
    { 
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(frame, child);  
        evas_object_show(child);  
    } 
 
    elm_table_pack(table, frame, col, row, spanx, spany);  
  
Page 534 / 978     evas_object_show(frame);  
} 
 
static Evas_Object *  
my_button_add(Evas_Object *parent, const char *text, Evas_S mart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
 
static Evas_Object *  
my_label_add(Evas_Object *pa rent, const char *text)  
{ 
    Evas_Object *btn;  
 
    btn = elm_label_add(parent);  
    elm_object_text_set(btn, text);  
 
    return btn;  
} 
└─────────────────────┘  
The my_table_pack() function adds a widget to the Table container.  
The my_button_add() function  creates a Button widget.  
The my_label_add() function creates a Label widget.   
  
Page 535 / 978 Add new code within the create_base_gui() function. This code creates one 
Frame, one Table, and one Button, as well as twelve Label widgets.  
┌─────────────────────┐  
    /* Confo rmant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAN D, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *tbl, *btn, *frame, *o;  
 
        /* Frame */  
        frame = elm_frame_add(ad ->win);  
        elm_object_style_set(frame , "pad_medium");  
        elm_object_content_set(ad ->conform, frame);  
        evas_object_show(frame);  
 
        /* Container: standard table */  
        tbl = elm_table_add(ad ->win);  
        /* Make this table homogeneous for nicer, fixed layout */  
        elm_table_homogeneous_set(tbl, EINA_TRUE);  
        elm_object_content_set(frame, tbl);  
        evas_object_show(tbl);  
 
        { 
            /* Button */  
            btn = my_button_add(tbl, "Load System Info", btn_clicked_cb, ad);  
            my_table_pack(tbl, btn, 0, 0, 2, 1, EVAS_HINT_EXPAND, 0, EVAS_HINT
  
Page 536 / 978 _FILL, EVAS_HINT_FILL);  
            o = my_label_add(tbl, "Back Camera:");  
            my_table_pack(tbl, o, 0, 1, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label1 = my_l abel_add(tbl, "");  
            my_table_pack(tbl, ad ->label1, 1, 1, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Front Camera:");  
            my_table_pack(tbl, o, 0, 2, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL ); 
 
            ad->label2 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label2, 1, 2, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Telephony:");  
            my_table_pack(tbl, o, 0, 3, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label3 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label3, 1, 3, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Screen Width:");  
            my_table_pack(tbl, o, 0, 4, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label4 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label4, 1, 4, 1, 1, EVAS_HINT_E XPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Screen Height:");  
  
Page 537 / 978             my_table_pack(tbl, o, 0, 5, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
            ad->label5 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label5, 1, 5, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Platform Version:");  
            my_table_pack(tbl, o, 0, 6, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label6 = my_label_add(tbl, " "); 
            my_table_pack(tbl, ad ->label6, 1, 6, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We are now going to create callback  functions for the Buttons. Add new 
code on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char buf[100];  
    char *sValue = NULL;  
    bool bValue = false;  
    int nValue = 0;  
    int ret;  
 
  
Page 538 / 978     ret = system_info_get_platform_bool("http://tizen.org/feature/camera.back", &bVal
ue); 
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_object_text_set(ad ->label1, bValue ? "True" : "Fal se"); 
    } 
} 
└─────────────────────┘  
system_info_get_platform_bool(char *, bool *) is an API that requests the 
system information. It returns data in Boolean format. The first parameter 
is a key value. Passing “http://tizen.org/feature/camera.back” return s 
whether or not there is a rear camera.  
Build and run the example. Tapping the Button will change the text in the 
first Label. Running it from an emulator displays False; running it from a 
user device displays True.  
 
  

  
Page 539 / 978 2) Whether or Not There is a Front Camera  
We will now discover if we have a front camera and display it on the 
screen. Add new code at the end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    ret = system_info_get_platform_bool("http://tizen.org/feature/camera.back", &bVal
ue); 
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_object_text_set(ad ->label1, bValue ? "True" : "False");  
    } 
 
    ret = system_info_get_platform_bool("http://tizen.org/feature/camera.front", 
&bValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_object_text_set(ad ->label2, bValue ? "True" : "False");  
    }  
} 
└─────────────────────┘  
Passing “http://tizen.org/feature/camera.front” to the first parameter 
returns whether or not there is a front camera.  
Build and run the example. Tap the B utton; you will see True displayed in 
the second Label.  
 

  
Page 540 / 978 3) Are There Telephony Features?  
We will now discover if there are telephony features. Add new code at the 
end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    ret = system_info_get_pla tform_bool("http://tizen.org/feature/camera.front", &bVal
ue); 
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_object_text_set(ad ->label2, bValue ? "True" : "False");  
    } 
 
    ret = system_info_get_platform_bool("http://tizen.org/feature/network. telepho
ny", &bValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_object_text_set(ad ->label3, bValue ? "True" : "False");  
    } 
} 
└─────────────────────┘  
Passing “http://tizen.org/feature/network.telephony” to the first parameter 
of the system_info_get_platform_bool() function returns whether or not 
there are telephony features. A True value does not necessarily mean that 
you can use the telephony or network. It just means that you have a 
hardware communication tool in place. You will not  be able to use the 
communication feature if you do not have a USIM chip or you have 
disabled the network feature under Preferences.  
Build and run the example. Tap the Button; you will see True displayed in 
the third Label.  
  
Page 541 / 978  
 
4) Number of Monitor Pixels  
Let’s request the number of monitor pixels. Add new code at the end of 
the btn_clicked_cb() function.  
┌─────────────────────┐  
    ret = system_info_get_platform_bool("http://tizen.org/feature/network.telephony", 
&bValue);  
    if (ret == SYSTEM_INFO_ERROR_NO NE) 
    { 
        elm_object_text_set(ad ->label3, bValue ? "True" : "False");  
    } 
 
    ret = system_info_get_platform_int("tizen.org/feature/screen.width", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "%d px", nValue);  
        elm_object_text_set(ad ->label4, buf);  
    } 
 
    ret = system_info_get_platform_int("tizen.org/feature/screen.height", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "%d px", nValue);  

  
Page 542 / 978         elm_object_text_set(ad ->label5,  buf); 
    } 
} 
└─────────────────────┘  
system_info_get_platform_int(char *, int *) is an API that requests the 
system information. It returns data in integer format. The first parameter 
is a key value. Passing “http://tizen.org/feature/screen.width” returns the 
number of horizontal monitor pixels. Passing 
“tizen.org/feature/screen.height” returns the number of vertical monitor 
pixels.  
Build and run the example. Tap the Button; you will see numbers displayed 
in the fourth Label and fifth Label.  
 
 
  

  
Page 543 / 978 5) Platform Version  
Let's request the platform version. Add new code at the end of the 
btn_clicked_cb() function.  
┌─────────────────────┐  
    ret = system_info_get_platform_int("tizen.org/feature/screen.height", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NON E) 
    { 
        sprintf(buf, "%d px", nValue);  
        elm_object_text_set(ad ->label5, buf);  
    } 
 
    ret = system_info_get_platform_string("http://tizen.org/feature/platform.versio
n", &sValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        elm_o bject_text_set(ad ->label6, sValue);  
        free(sValue);  
    } 
} 
└─────────────────────┘  
system_info_get_platform_string(char *, char  **) is an API that requests the 
system information. It returns data in string format. The first parameter is 
a key value.  Passing “http://tizen.org/feature/platform.version” returns the 
platform version.  
Build and run the example. Tap the Button; you will see the platform 
version displayed in the sixth Label.  
  
Page 544 / 978  
 
6) Related APIs  
To view the types of system information, key values, and return formats 
from the Help Contents list. Select [Help > Help Contents] from the main 
menu.  
 
With the Help Contents running, choose [Tizen Mobile Native App 
Programming > Programming Guide > System > System Information] 
from the tree list on  the left side. You will see the keys, return types, and 
description on the right side of the screen.  

  
Page 545 / 978  
int system_info_get_platform_bool(const char *key, bool *value): an API 
that requests the system information. It returns data in Boolean format.  
int system_info_get_platform_int(const char *key, int *value): an API that 
requests the system information. It returns data in integer format.  
int system_info_get_platform_string(const char *key, char **value): an API 
that requests the system information. It ret urns data in string format.  
  

  
Page 546 / 978 43. System Preferences  
Multilingual support requires you to check the language settings of the 
user. If you are in silent mode when a new message arrives, you would 
need a vibrating alert. In this example, we will learn how to req uest 
information about the system preferences.  
1) Requesting Language Settings  
Create a new source project and specify the project name as 
‘SystemSetting.’ After the source project is created, open the source file 
(~.c) under the src folder and add variabl es at the top of the source file.  
┌─────────────────────┐  
#include "systemsetting.h"  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label1;  
    Evas_Object *label2;  
    Evas_Object *label3;  
    Evas_Object *label4;  
} appdata_s;  
└─────────────────────┘  
We have declared a total of four Label widget variables. We will mark 
language settings for the first Label as well as whether silent mode is 
enabled or not for the second Label, including the time zone for the  third 
Label, and the device name for the fourth Label.  
  
Page 547 / 978 Create three new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int col, int row, int spanx, int s
pany, 
        bool h_expand, bool v_expand, double h_align, double v_align)  
{ 
    /* Create a frame around the child, for padding */  
    Evas_Object *frame = elm_frame_add(table);  
    elm_object_style_set(frame, "pad_small");  
 
    evas_object_size_hint_weight_set (frame, h_expand ? EVAS_HINT_EXPAND : 0, v_exp
and ? EVAS_HINT_EXPAND : 0);  
    evas_object_size_hint_align_set(frame, h_align, v_align);  
 
    /* place child in its box */  
    { 
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXP AN
D); 
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(frame, child);  
        evas_object_show(child);  
    } 
 
    elm_table_pack(table, frame, col, row, spanx, spany);  
    evas_object_show(frame);  
} 
 
static Evas_Object *  
my_button_add(Evas_Object *parent, const char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
  
Page 548 / 978  
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_ callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
 
static Evas_Object *  
my_label_add(Evas_Object *parent, const char *text)  
{ 
    Evas_Object *btn;  
 
    btn = elm_label_add(parent);  
    elm_object_text_set(btn, text);  
 
    return btn;  
} 
└─────────────────────┘  
The my_table_pack() function adds a widget to the Table container.  
The my_button_add() function creates a Button widget.  
The my_label_add() function creates a Label widget.  
Add new code within the create_base_gui() function.  This co de creates one 
Frame, one Table, and one Button widget, as well as eight Label widgets.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win _indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
  
Page 549 / 978     evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Ob ject *tbl, *btn, *frame, *o;  
 
        /* Frame */  
        frame = elm_frame_add(ad ->win);  
        elm_object_style_set(frame, "pad_medium");  
        elm_object_content_set(ad ->conform, frame);  
        evas_object_show(frame);  
 
        /* Container: standar d table */  
        tbl = elm_table_add(ad ->win);  
        /* Make this table homogeneous for nicer, fixed layout */  
        elm_table_homogeneous_set(tbl, EINA_TRUE);  
        elm_object_content_set(frame, tbl);  
        evas_object_show(tbl);  
 
        { 
            /* Button */  
            btn = my_button_add(tbl, "Load System Settings", btn_clicked_cb, a
d); 
            my_table_pack(tbl, btn, 0, 0, 2, 1, EVAS_HINT_EXPAND, 0, EVAS_HINT
_FILL, EVAS_HINT_FILL);  
 
            /* Fields */  
            o = my_la bel_add(tbl, "Language:");  
            my_table_pack(tbl, o, 0, 1, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label1 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label1, 1, 1, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
  
Page 550 / 978             o = my_label_add(tbl, "Silent mode:");  
            my_table_pack(tbl, o, 0, 2, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label2 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label2, 1, 2, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Time zone:");  
            my_table_pack(tbl, o, 0, 3, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label3  = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label3, 1, 3, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
 
            o = my_label_add(tbl, "Device name:");  
            my_table_pack(tbl, o, 0, 4, 1, 1, EVAS_HINT_EXPAND, 0, 1.0, EVAS_HI
NT_FILL);  
 
            ad->label4 = my_label_add(tbl, "");  
            my_table_pack(tbl, ad ->label4, 1, 4, 1, 1, EVAS_HINT_EXPAND, 0, 0.0,
 EVAS_HINT_FILL);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We are now going to create callback functions for the Buttons. Add new 
code on top of the create_base_gui() function.  
  
Page 551 / 978 ┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char buf[100];  
    char *sValue = NULL;  
    bool bValue;  
 
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_LANGUAGE, &sVa
lue); 
    elm_object_text_s et(ad->label1, sValue);  
    free(sValue);  
} 
└─────────────────────┘  
system_settings_get_value_string(system_settings_key_e, char **) is an API 
that requests the system preferences. It returns data in string format. The 
first parameter is a key value. Passing 
SYSTEM_SETTINGS_KEY_LOCALE_LANGUAGE returns the language type 
specified by the user.  
Build and run the example. Tap the Button; you will see the language type 
displayed in the first Label.  
  
Page 552 / 978  
 
2) Requesting the Silent Mode  
We will mark whether silen t mode is enabled or not on the screen. Add 
new code at the end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_LANGUAGE, &sVa
lue); 
    elm_object_text_set(ad ->label1, sValue);  
    free(sValue);  
 
    system_settings_get_value_bool(SYSTEM_SETTINGS_KEY_SOUND_SILENT_MODE,
 &bValue);  
    elm_object_text_set(ad ->label2, bValue ? "On" : "Off");  
} 
└─────────────────────┘  
system_settings_get_value_bool(system_settings_key_e, bool *) is an API 
that requests the system preferences. It returns data in Boolean format. 

  
Page 553 / 978 The first parameter is a key value. Passing 
SYSTEM_SETTINGS_KEY_SOUND_SILENT_MODE returns whether or not 
silent mode is enabled.  
Build and run the example. Tap the Button; you will se e whether silent 
mode is enabled or not in the second Label.  
 
 
3) Requesting  the Time Zone  
We will request the time zone this time. Add new code at the end of the 
btn_clicked_cb() function.  
┌─────────────────────┐  
    system_settings_get_value_bool(SYSTEM _SETTINGS_KEY_SOUND_SILENT_MODE, &b
Value);  
    elm_object_text_set(ad ->label2, bValue ? "On" : "Off");  
 
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE, 
&sValue);  
    elm_object_text_set(ad ->label3, sValue);  
    free(sValue);  
} 
└─────────────────────┘  
  

  
Page 554 / 978 Passing SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE to the first parameter 
of the system_settings_get_value_string() function returns the time zone in 
a string.  
Build and run the example. Tap the Button; you will see the time zone set 
by the user in the third Label.  
 
 
4) Requesting the Device Name  
Now, we will request the device name. Add new code at the end of the 
btn_clicked_cb() function.  
┌─────────────────────┐  
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCALE_TIMEZONE, &sVal
ue); 
    elm_object_text_set(ad ->label3, sValue);  
    free(sValue);  
 
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_DEVICE_NAME, &sVal
ue); 
    elm_object_text_set(ad ->label4, sValue);  
    free(sValue);  
} 
└─────────────────────┘  

  
Page 555 / 978 When you pass  SYSTEM_SETTINGS_KEY_DEVICE_NAME to the first 
parameter of the system_settings_get_value_string() function, it returns 
the device name in a string.  
Build and run the example. Tap the Button; you will see the device name 
displayed in the fourth Label.  
 
 
5) Related APIs  
Let’s take a look at the types of system preferences, key values, and return 
formats from the list. To see a list of key values for the System Information, 
open a web browser and go to the address below:  
https://developer.tizen.org/documentat ion/guides/native -
application/system/system -information  

  
Page 556 / 978  
int system_settings_get_value_int(system_settings_key_e key, int *value): 
an API that requests the system preferences. It returns data in integer 
format.  
int system_settings_get_value_bool(system_se ttings_key_e key, bool 
*value): an API that requests the system preferences. It returns data in 
Boolean format.  
int system_settings_get_value_string(system_settings_key_e key, char 
**value): an API that requests the system preferences. It returns data in 
string format.   

  
Page 557 / 978 44. Battery Status  
Video playback must stop if the device’s battery level drops to 15% or 
lower. If not, you could miss an important call. While the device is charging, 
it is safe for playback to continue even if the battery level is low. We wil l 
now learn how to check the current battery status and request battery -
related events.  
 
1) Requesting the Battery Status  
Create a new source project and specify the project name as ‘BatteryInfo.’ 
After the source project is created, open the source file ( ~.c) under the src 
folder and add a library at the top of the screen.  
┌─────────────────────┐  
#include "batteryinfo.h"  
#include <device/battery.h>  
#include <device/callback.h>  
└─────────────────────┘  
device/battery.h is a library header file containing inf ormation about the 
battery.  
device/callback.h is a library header file for event callbacks related to 
devices.  
  
  
Page 558 / 978 We will implement a feature that displays the battery level as well as 
whether it is being charged or not on the screen when the Button is 
tapped. Create a new function on top of the create_base_gui() function. 
This function adds a Widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h _align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available  as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_s ize_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, 
EVAS_HINT_EXPAND);  
        /* fill the expanded area (abov e) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘   
  
Page 559 / 978 Then, it adds the Box - and Button -creating code at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->win);  
            elm_object_text_set(ad ->label, "<align=center>Hello Tizen</>");  
            /* expand  horizontally but not vertically, and fill horiz,  
             * align center vertically */  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Default style");  
            evas_object_smart_callback_add(btn, "clicked", show_battery_state, ad);  
  
Page 560 / 978             /* epand both horiz and vert, fill horiz and vert */  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, 0. 0); 
         } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Add a Button callback function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
show_battery_state(void  *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int result=0, percent=0;  
    bool charging = false;  
    device_battery_get_percent(&percent);  
    device_battery_is_charging(&charging);  
    char buf[100];  
    sprintf(buf, "Batter y Remain : %d %% - %s", percent, charging ? "charging" : "un
charging");  
  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
device_battery_get_percent(int *) is an API that returns the battery level 
converted into percentage.  
device_battery_is_charging(bool *) is an API that returns the charging state. 
It returns true while charging; otherwise, it returns false.   
  
Page 561 / 978 Build and run the example. Tap the Button; you will see the battery level 
and charging state in the Label widget. If  you have run it from the emulator, 
it will probably display ‘50% remaining, uncharging.’  
 
 
2) Changing the Battery Status in the Emulator  
Use the Control Panel to change the battery status in the emulator. Right -
click the emulator and choose [Control Pan el] from the shortcut menu.  
 
In the new popup  window, choose [Event Injector > Battery] from the tree 
list on the left side.   

  
Page 562 / 978 When you see a slider that looks like a battery, drag the bar to change 
the value, and then select the Connect Radio button under  the Charger.  
Then, tap the ‘Default style’ button in the emulator to show brand new 
information.  
 
 
3) Requesting an Event for Changing the Battery Status  
Let's implement a feature that automatically requests an event when you 
have connected the charging cable. Add new code at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    evas_object_show(ad ->win);  
  
    device_add_callback(DEVICE_CALLBACK_BATTERY_CHARGING, battery_charging_c
b, ad);  
} 
└─────────────────────┘  
  

  
Page 563 / 978 device_add_callback(device_callback_e, device_changed_cb, void *) is an 
API that specifies an event callback function for the device. You can 
request an event for connecting the charger by passing 
DEVICE_CALLBACK_BATTERY_CHARGING to the first parameter. Pa ssing 
DEVICE_CALLBACK_BATTERY_LEVEL requests an event for changing the 
battery level.  
Now, create a callback function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void battery_charging_cb(device_callback_e type, void *value, voi d *user_data)  
{ 
    appdata_s *ad = user_data;  
    char buf[100];  
    sprintf(buf, "Battery Charging - %s", (int)value ? "Connect" : "Disconnect");  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
If you have passed 1 to the second parame ter of the charger event, it is a 
connection event; 0 represents a disconnection event.  
Run the example again and tap the radio buttons several times in turn 
under the Charger in the Control Panel. A new message is displayed in 
the Label widget.  
 
 
  

  
Page 564 / 978 4) Requesting the  Event for Low Battery Levels  
The device should switch to sleep mode once the battery level has 
dropped below 15%. There is a function named ui_app_low_battery() 
below the source file. This is an event function that alerts you of low 
battery le vel. Add new code to the ui_app_low_battery() function.  
If this function does not exist, or if you would like to change the name, 
you may do so in the main() function.  
┌─────────────────────┐  
static void  
ui_app_low_battery(app_event_info_h event_info, void  *user_data)  
{ 
    show_battery_state(user_data, NULL, NULL);  
} 
 
int 
main(int argc, char *argv[])  
{ 
    appdata_s ad = {0,};  
    int ret = 0;  
 
    ui_app_lifecycle_callback_s event_callback = {0,};  
    app_event_handler_h handlers[5] = {NULL, };  
 
    event_callback.create = app_create;  
    event_callback.terminate = app_terminate;  
    event_callback.pause = app_pause;  
    event_callback.resume = app_resume;  
    event_callback.app_control = app_control;  
 
 
  
Page 565 / 978     ui_app_add_event_handler(&handlers[APP_E VENT_LOW_BATTERY], APP_EVENT_
LOW_BATTERY, ui_app_low_battery, &ad);  
    ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVE
NT_LANGUAGE_CHANGED, ui_app_lang_changed, &ad);  
 
    ret = ui_app_main(argc, argv, &event_callback, &ad);  
    if (ret != APP_ERROR_NONE) {  
    dlog_print(DLOG_ERROR, LOG_TAG, "app_main() is failed. err = %d", ret);  
    } 
 
    return ret;  
} 
└─────────────────────┘  
When the battery reaches a critical level, it automatically displays the 
current battery status on the screen.  
Run the example again and check the Disconnect box in the Control Panel, 
and then change the battery level to less than 15%. A warning popup  
appears, and the message in the Label widget is changed.  
 
  

  
Page 566 / 978 5) Related APIs  
device/battery.h: a library he ader file that contains information about the 
battery.  
device/callback.h: a library header file for event callbacks related to devices.  
device_battery_get_percent(int *): an API that returns the battery level 
converted into percentage.  
int  device_battery_ get_percent(int *percent): an API that returns the 
charging state. It returns true while charging; otherwise, it returns false.  
int  device_add_callback(device_callback_e type, device_changed_cb 
callback, void *user_data): an API that specifies an event ca llback 
function for the device. You can request an event for connecting the 
charger by passing DEVICE_CALLBACK_BATTERY_CHARGING to the first 
parameter. Passing DEVICE_CALLBACK_BATTERY_LEVEL requests an event 
for changing the battery level.  
  
  
Page 567 / 978 45. Generating Vib ration  
If you receive a message in silent mode, it is helpful to be notified with a 
vibration. Vibration effects will help users stay immersed in the game but 
at the same time be aware they have new messages. You have yourself a 
4D experience if you combine it with 3D graphics.  In this example, we will 
learn how to generate vibration.  
1) Registering a Privilege  
Create a new source project and specify the project name as ‘VibrateEx.’ 
You need to have the applicable user privilege to be able to use the 
vibration feature. After the source project is created, open the tizen -
manifest.xml file and click Privileges from the lower tab buttons. Then, 
click the Add button in the upper right corner. In the popup  window, select 
http://tizen.org/privilege/haptic fr om the list and click the OK button to 
close the window.  
  
Page 568 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────── ──┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.vibrateex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .vibrateex" exec ="vibrateex" multiple="false" no
display="false" taskmanage="true" type="capp">  
        <label>vibrateex</label>  
        <icon>vibrateex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/haptic</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 569 / 978 2) Requesting the Number of Haptic Devices  
Haptic is a touch -driven interface. We will request the count to find out 
how many Haptic devices are mounted to your phone. Open the source 
file (~.c) under the sr c folder and add a library header file as well as 
variables at the top.  
┌─────────────────────┐  
#include "vibrateex.h"  
#include <device/haptic.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    haptic_ device_h handle;  
    haptic_effect_h effect_handle;  
  
    Ecore_Timer *timer1;  
    int timer_count;  
} appdata_s;  
└─────────────────────┘  
device/haptic.h is a library for controlling the Haptic device.  
haptic_device_h is a handle capable of controlling the Haptic device.  
haptic_effect_h is a handle capable of controlling one of the Haptic effects.  
Add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
  
Page 570 / 978     evas_object_show(ad ->win);  
  
    haptic_count(ad);  
} 
└─────────────────────┘  
The haptic_count() function displays the number of Haptic devices. Create 
this function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
haptic_count(appdata_s *ad)  
{ 
    int erro r, num;  
    error = device_haptic_get_count(&num);  
  
    char buf[100];  
    sprintf(buf, "Haptic count : %d", num);  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
device_haptic_get_count(int *device_number) is an API that returns the 
number of Haptic devices. If less than 1, the vibration feature will not be 
supported.  
Build an example and install it on your smartphone. You cannot test the 
vibration feature in the emulator. Once the example is executed, the 
number of Haptic devices is di splayed in the Label widget.  
 

  
Page 571 / 978 2) Generating a  Vibration Feature  
Create a Haptic object to generate vibration. Create two new functions on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_sm all", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_siz e_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPA ND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_objec t_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
 
  
Page 572 / 978 static Evas_Object *  
my_button_add(Evas_Object *parent, const char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
└─────────────────────┘  
The my_box_pack() function adds a widget to the Box container.  
The my_button_add() function creates a Button widget.  
Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->confo rm = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    Evas_Object *btn, *box;  
 
    /* Container: standard table */  
    box = elm_box_add(ad ->win);  
  
Page 573 / 978     elm_box_homogeneous_set(box, EINA_TRUE);  
    elm_box_horizontal_set(box, EINA_FALSE);  
    evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Label*/  
        ad->label = elm_label_add(box);  
        my_box_pack(box, ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, 0.
5, 0.5);  
 
        /* Buttons */  
        btn = my_button_add(box, "Vibrate", btn_vibrate_c b, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_H
INT_FILL, EVAS_HINT_FILL);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    /* Haptic */  
    haptic_count(ad);  
    device_haptic_open(0 , &ad ->handle);  
} 
└─────────────────────┘  
device_haptic_open(int, haptic_device_h *) is an API that creates a haptic 
object. Passing the Haptic device number to the first parameter makes the 
second parameter return a Haptic object in response.  
  
Page 574 / 978 We are going  to implement a feature that generates vibration for 5 
seconds when you tap the button. Create a Button callback function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_vibrate_cb(void *data, Evas_Object *obj, void *event _info) 
{ 
    appdata_s *ad = data;  
    int error = device_haptic_vibrate(ad ->handle, 5000, 100, &ad ->effect_handle);  
} 
└─────────────────────┘  
device_haptic_vibrate(haptic_device_h, int, int, haptic_effect_h *) is an API 
that generates vibration. The first  parameter returns a Haptic object; the 
second parameter returns the duration (in milliseconds); the third 
parameter returns the intensity (0 –100); and the fourth parameter returns 
a Haptic effect -controlling handle. It is used to stop the vibration forcib ly. 
Run the example again and tap the Button. The vibration lasts for 5 
seconds.  
 

  
Page 575 / 978 3) Stopping the Vibration Feature  
We will now implement a feature that forces the vibration to stop by 
adding a second Button. Add a Button -creating code to the 
create_base_ gui() function.  
┌─────────────────────┐  
        /* Buttons */  
        btn = my_button_add(box, "Vibrate", btn_vibrate_cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_HINT_
FILL, EVAS_HINT_FILL);  
        btn = my_button_add(bo x, "Stop", btn_stop_cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_H
INT_FILL, EVAS_HINT_FILL);  
    } 
└─────────────────────┘  
Then, create a Button callback function on top of the create_base_gui() 
function.  
┌─────────────── ──────┐  
static void  
btn_stop_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int error = device_haptic_stop(ad ->handle, &ad ->effect_handle);  
} 
└─────────────────────┘  
device_haptic_stop(haptic_device_h, haptic_effect_h) is an API that stops 
the Haptic features. It passes a Haptic object to the first parameter and 
an effect -controlling handle to the second.  
  
Page 576 / 978 Run the example again and tap the first Button. Once the vibration starts, 
tap the second Button. This will stop the vibration.  
 
 
4) Dynamic Vibrate  
We will implement a feature that switches the vibration on/off using a 
timer. Add the third Button -creating code to the create_base_gui() function.  
┌─────────────────────┐  
        btn = my_button_add(box, "Stop", btn_stop_ cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_HINT_
FILL, EVAS_HINT_FILL);  
 
        btn = my_button_add(box, "Dynamic Vibrate", btn_dynamic_cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_H
INT_FILL, EVAS_HINT_FILL);  
    } 
└─────────────────────┘  
Finally, add three new functions on top of the create_base_gui() function.  

  
Page 577 / 978 ┌─────────────────────┐  
static void  
dynamic_vibrate(appdata_s *ad)  
{ 
    if( ad->effect_handle != NULL )  
        device_haptic_stop(ad ->handle, &ad ->effect_handle);  
 
    if( (ad ->timer_count % 2) == 0 )  
        device_haptic_vibrate(ad ->handle, 500, 100, &ad ->effect_handle);  
} 
 
static Eina_Bool  
timer1_cb(void *data EINA_UNUSED)  
{ 
    appdata_s *ad = data;  
    ad->timer_count ++;  
    dynamic_vibrate(ad);  
 
    if(ad->timer_count > 5)  
    { 
        ecore_timer_del(ad ->timer1);  
        ad->timer1 = NULL;  
    } 
    return ECORE_CALLBACK_RENEW;  
} 
 
static void  
btn_dynamic_cb(void *data, Evas_Object *obj, void *event_ info) 
{ 
    appdata_s *ad = data;  
    ad->timer_count = 0;  
    if (ad->timer1)  
     ecore_timer_del(ad ->timer1);  
    ad->timer1 = ecore_timer_add(0.5, timer1_cb, ad);  
    ad->effect_handle = NULL;  
  
Page 578 / 978  
    dynamic_vibrate(ad);  
} 
└─────────────────────┘  
The dynamic_vibrate() function is invoked every 0.5 seconds to switch the 
vibration on/off.  
timer1_cb() is a timer event function invoked every 0.5 seconds. Tapping 
the third Button will invoke this function six times.  
The btn_dynamic_cb() function resets the global variable and starts the 
timer. 
Run the example again and tap the third Button. Vibration switches on/off 
every 0.5 seconds.  
 
 
  

  
Page 579 / 978 5) Related APIs  
int  device_haptic_get_count(int *device_number): an API that returns the 
number of Haptic devices. If l ess than 1, the vibration feature will not be 
supported.  
int  device_haptic_open(int device_index, haptic_device_h *device_handle): 
an API that creates a haptic object. Passing the Haptic device number to 
the first parameter makes the second parameter retu rn a Haptic object in 
response.  
int  device_haptic_vibrate(haptic_device_h device_handle, int duration, int 
feedback, haptic_effect_h *effect_handle): an API that generates a vibration. 
The first parameter returns a Haptic object; the second parameter retu rns 
the duration (in milliseconds); the third parameter returns the intensity (0 –
100); and the fourth parameter returns a Haptic effect -controlling handle. 
This is used to stop the vibration forcibly.  
int  device_haptic_stop(haptic_device_h device_handle, haptic_effect_h 
effect_handle): an API that stops the Haptic features. It passes a Haptic 
object to the first parameter and an effect -controlling handle to the 
second parameter.  
  
  
Page 580 / 978 46. LED Flash Backlight  
In this example, we will learn how to turn on/off the LE D backlight that is 
used for the camera flash.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as ‘LedFreshEx.’ 
You need to have the applicable user privilege to be able to control the 
backlight. After the source project is created, open the tizen -manifest.xml 
file and click Privileges from th e lower tab buttons. Then, click the Add 
button in the upper right corner. In the popup  window, select 
http://tizen.org/privilege/led from the list and click the OK button to close 
the window.  
 

  
Page 581 / 978 After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2 .3" package="org. exam
ple.ledfreshex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .ledfreshex" exec="ledfreshex" multiple="false" 
nodisplay="false" taskmanage="true" type="capp">  
        <label>ledfreshex</label>  
        <icon>ledfreshex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/led</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  
  
2) Requesting the Maximum Brightness of LED  
The brightness should b e specified when the LED is on. Let's request the 
maximum brightness. Open the source file (~.c) under the src folder and 
add a library header file as well as variables at the top.  
┌─────────────────────┐  
#include "ledfresh.h"  
#include <device/led.h>  
  
typedef struct appdata {  
  
Page 582 / 978     Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    int max;  
} appdata_s;  
└─────────────────────┘  
device/led.h is a LED -controlling library.  
max is a variable that saves the maximum brightness.  
Add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    get_max_brightness(ad);  
} 
└─────────────────────┘  
The get_max_brightness function requests the maximum br ightness of the 
LED backlight. Create this function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
get_max_brightness(appdata_s *ad)  
{ 
    int error = device_flash_get_max_brightness(&ad ->max);  
    int val = 0;  
    error = de vice_flash_get_brightness(&val);  
  
    char buf[ PATH_MAX ]; 
    sprintf(buf, "Max brightness : %d / %d", ad ->max, val);  
  
Page 583 / 978     elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
device_flash_get_max_brightness(int *) is an API that requests the 
maximum brightness of the LED backlight.  
device_flash_get_brightness(int *) is an API that requests the current 
brightness of the LED backlight.  
Run the example. Both maximum brightness and current brightness are 
displayed in the Label widget.  
 
 
3) LED On /Off 
We will implement a feature that turns on/off the LED backlight by adding 
two Buttons. Create two new functions on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  

  
Page 584 / 978     * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame , h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
 
static Evas_Object *  
my_button_add(Evas_Object *p arent, const char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
└────────────────── ───┘  
  
Page 585 / 978 Add a widget -creating code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    Evas_O bject *btn, *box;  
 
    /* Container: standard table */  
    box = elm_box_add(ad ->win);  
    elm_box_homogeneous_set(box, EINA_TRUE);  
    elm_box_horizontal_set(box, EINA_FALSE);  
    evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Label*/  
        ad->label = elm_label_add(ad ->conform);  
        my_box_pack(box, ad ->label,  EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, 0.
5, 0.5);  
 
        /* Button -1 */ 
        btn = my_button_add(box, "LED On", btn_led_on_cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_H
INT_FILL, EVAS_HINT_FILL);  
  
Page 586 / 978         /* Button -2 */ 
        btn = my_button_add(box, "LED Off", btn_led_off_cb, ad);  
        my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EVAS_H
INT_FILL, EVAS_HINT_FILL);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Then, create a Button callback function on top of the create_base_gui() 
function.  
┌─────────────────────┐  
static void  
btn_led_on_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    device_flash_set_bri ghtness(ad ->max);  
    device_led_play_custom(1000, 500, 0xFFFFFF00, LED_CUSTOM_DEFAULT);  
} 
 
static void  
btn_led_off_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    device_led_stop_custom();  
} 
└─────────────────────┘  
device_flash_set_brightness(int ) is an API that specifies the brightness of 
the LED.  
  
  
Page 587 / 978 device_led_play_custom(on, off, color, int) is an API that starts LED On.  
device_led_stop_custom(void) is an LED Off API.  
Run the example again. The LED On button turns on the LED; the LED Off 
button turns it off.  
 
 
4) Troubleshooting LED Off  
Depending on the model, LED may not go off with the 
device_led_stop_custom() function. In this case, simply decrease the 
brightness to the lowest level possible. Modify the btn_led_off_cb() 
function as shown below.  
┌─────────────────────┐  
static void  
btn_led_off_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    device_flash_set_brightness(0);  
    device_led_stop_custom();  
} 
└─────────────────────┘  

  
Page 588 / 978 You can forcibly turn it off using the device_flash_set_ brightness() function 
to set the brightness to 0.  
 
5) Related APIs  
device/led.h: a LED -controlling library.  
device_flash_get_max_brightness(int *): an API that requests the maximum 
brightness of the LED backlight.  
int  device_flash_get_brightness(int *brig htness): an API that requests the 
current brightness of the LED backlight.  
int  device_flash_set_brightness(int brightness): an API that specifies the 
brightness of the LED.  
int  device_led_play_custom(int on, int off, unsigned int color, unsigned int 
flags): an API that starts LED On.  
int  device_led_stop_custom(void): an LED Off API.  
  
  
Page 589 / 978 47. Event for Rotating the Screen Orientation  
Orientation refers to the direction in which your phone rotates. Portrait 
means vertical; Landscape means horizontal. We will find  out how to check 
the current orientation of your phone and request the Orientation event.  
 
1) Requesting the Orientation  
Create a new source project and specify the project name as 
‘OrientationEvent.’ After the source project is created, open the source f ile 
(~.c) under the src folder and add new code at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    // Show now orientation  
    show_orientation(ad, NULL,  NULL);  
} 
└─────────────────────┘  
The show_orientation() function requests the current screen orientation, 
and then outputs it to the Label widget. Next, create a new function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
// Show now or ientation  
static void  
  
Page 590 / 978 show_orientation(appdata_s *ad, Evas_Object *obj, void *event_info)  
{ 
    // Get orientation  
    int result = elm_win_rotation_get(ad ->win);  
  
    switch( result )  
    { 
    case APP_DEVICE_ORIENTATION_0 :  
        elm_object_text_set( ad->label, "Portrait -1"); 
        break;  
    case    APP_DEVICE_ORIENTATION_90 :  
        elm_object_text_set(ad ->label, "Landscape -1"); 
        break;  
    case APP_DEVICE_ORIENTATION_180 :  
        elm_object_text_set(ad ->label, "Portrait -2"); 
        break; 
    case APP_DEVICE_ORIENTATION_270 :  
        elm_object_text_set(ad ->label, "Landscape -2"); 
        break;  
    default :  
        elm_object_text_set(ad ->label, "Other Event");  
        break;  
    } 
} 
└─────────────────────┘  
The show_orientation() function requests the Orientation, and then 
outputs it to the Label widget.  
elm_win_rotation_get(const Evas_Object *) is an API that returns the 
current Orientation. The returned types are as follows:  
 - APP_DEVICE_ORIENTATION_0 : Portrait First  
 - APP_DEV ICE_ORIENTATION_90 : Landscape First  
  
Page 591 / 978  - APP_DEVICE_ORIENTATION_180 : Portrait Second  
 - APP_DEVICE_ORIENTATION_270 : Landscape Second  
Build and run the example. You will see the ‘Portrait -1’ text in the Label 
widget.  
 
 
2) Rotating the Screen in the Emulat or 
We will implement a feature that outputs the orientation when the Button 
is tapped. Create a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
                        double h_weight, double v_weight, double h_align, double 
v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medi um", 
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  

  
Page 592 / 978         evas_object_size_hint_weight_set(chi ld, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└──────────────── ─────┘  
Then, add a Button -creating code to the create_base_gui() function.  
┌─────────────────────┐  
 /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opaci ty_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPA ND, EVAS_HINT_EX
PAND);  
  
Page 593 / 978         elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->win);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EV
AS_HINT_EXPAND);  
            //elm_object_content_set(ad ->conform, ad ->label);  
            my_box_p ack(box, ad ->label, 1.0, 0.0, -1.0, 0.0);  
 
            /* Button -1 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Now Orientation");  
            evas_object_smart_callback_add(btn, "clicked", show_orientation, (void
 *)ad); 
            my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Let us now rotate the emulator. Right -click the emulator and select [Rotate 
> Landscape] from the shortcut menu.  
  
Page 594 / 978       
As the screen orientation rotates, tap the Button. This time, you will see 
the ‘Landscape -2’ text.  
Change it back to Portrait and tap the Button to display Portrait -1. 
 
3) Rotating the Orientation  
We are going t o implement a feature that changes the Orientation when 
you tap the Button. Add the second Button -creating code to the 
create_base_gui() function.  
┌─────────────────────┐  
            /* Button -1 */ 
            btn = elm_button_add(ad ->win);  
            elm_object_text_set(btn, "Now Orientation");  
            evas_object_smart_callback_add(btn, "clicked", show_orientation, (void *)a
d); 
            my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 

  
Page 595 / 978             /* Button -2 */ 
            btn = elm_button_add(ad ->win); 
            elm_object_text_set(btn, "Orientation Change");  
            evas_object_smart_callback_add(btn, "clicked", btn_orientation_change
_cb, (void *)ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, 0.0);  
        } 
    } 
└───────────────────── ┘ 
Then, create a callback function of the newly created Button on top of the 
create_base_gui() function.  
┌─────────────────────┐  
// 'Orientation Change' Button event function  
static void  
btn_orientation_change_cb(void *data, Evas_Object *obj, void *event_i nfo) 
{ 
    appdata_s *ad = (appdata_s*)data;  
    // Get orientation  
    int result = elm_win_rotation_get(ad ->win);  
  
    if( result == APP_DEVICE_ORIENTATION_0 || result == APP_DEVICE_ORIENTATION_
180 ) 
        elm_win_rotation_with_resize_set(ad ->win, APP_DEVICE_ORIENTATION_90);  
    else 
        elm_win_rotation_with_resize_set(ad ->win, APP_DEVICE_ORIENTATION_0);  
} 
└─────────────────────┘  
This code identifies the current Orientation and changes it as needed, 
from Portrait to Landscape and vice -versa. 
  
Page 596 / 978 elm_win_rotation_with_resize_set(Evas_Object *, int) is an API that changes 
the orientation. The option types are as follows:  
 - APP_DEVICE_ORIENTATION_0 : Portrait First  
 - APP_DEVICE_ORIENTATION_90 : Landscape First  
 - APP_DEVICE_ORIENTATION_180 : Portrait  Second  
 - APP_DEVICE_ORIENTATION_270 : Landscape Second  
Run the example again and tap the second Button. Each time you tap the 
Button, the Landscape mode and Portrait mode appear in turn.  
   
 
4) Requesting an Event for Changing the Orientation  
Let's mak e a request for the event when the Orientation changes. Add 
new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    // Show now orientation  
    show_orientation(ad, NULL, NULL);  
  

  
Page 597 / 978     // Set callback function of orientation chang e event  
    evas_object_smart_callback_add(ad ->win, "rotation,changed", win_rotation_chan
ged_cb, ad);  
} 
└─────────────────────┘  
evas_object_smart_callback_add(Evas_Object *, char *, Evas_Smart_Cb, void 
*) is an API that specifies an event callback function  for a smart object, 
such as a Layout container or Button widget. You can request the event 
for changing the Orientation by passing Win to the first parameter and 
specifying “rotation,changed” for the second parameter.  
We are ready to create an event funct ion for changing the Orientation. 
Create a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
// Orientation changed event function  
static void  
win_rotation_changed_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = (appdata_s*)data;  
    show_orientation(ad, NULL, NULL);  
} 
└─────────────────────┘  
If the Orientation changes, the function above is invoked. Request the 
Orientation information to display it on the screen.  
Run the example again and tap the second Button. If the screen 
orientation changes, Landscape -1 automatically appears in the Label 
widget.  
  
Page 598 / 978  
 
5) Fixing the Orientation  
We are going to lock the Orientation so that it stays in place when you 
rotate the phone. The allowable Orientation ty pes are defined in the 
beginning of the create_base_gui() function.  
┌─────────────────────┐  
    int rots[4] = { 0, 90, 180, 270 };  
    elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 4);  
└─────────────────────┘  
Change this as sh own below.  
┌─────────────────────┐  
    int rots[1] = { 0 };  
    elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 1);  
└─────────────────────┘  

  
Page 599 / 978 elm_win_wm_rotation_available_rotations_set(Evas_Object *, int *, unsigned 
int) is an API  that specifies the allowable types of Orientation. It passes 
the array that holds the angle to the second parameter and the data count 
saved in the array to the third parameter.  
Run the example again, and then right -click and select [Rotate > 
Landscape] f rom the shortcut menu. While the emulator rotates, the 
Orientation mode remains intact.  
     
 
6) Related APIs  
int  elm_win_rotation_get(const Evas_Object *obj): an API that returns the 
current Orientation. The returned types are as follows:  
 - APP_DEVICE_ORIENTATION_0 : Portrait First  
 - APP_DEVICE_ORIENTATION_90 : Landscape First  
 - APP_DEVICE_ORIENTATION_180 : Portrait Second  

  
Page 600 / 978  - APP_DEVICE_ORIENTATION_270 : Landscape Second  
void  elm_win_rotation_with_resize_set(Evas_Object *, int): an API tha t 
changes the Orientation. The option types are as follows:  
 - APP_DEVICE_ORIENTATION_0 : Portrait First  
 - APP_DEVICE_ORIENTATION_90 : Landscape First  
 - APP_DEVICE_ORIENTATION_180 : Portrait Second  
 - APP_DEVICE_ORIENTATION_270 : Landscape Second  
void  evas_object_smart_callback_add(Evas_Object *obj, const char *event, 
Evas_Smart_Cb func, const void *data): an API that specifies an event 
callback function for a smart object, such as a Layout container or Button 
widget. You can request the event for changi ng the Orientation by passing 
Win to the first parameter and specifying “rotation,changed” for the 
second parameter.  
void  elm_win_wm_rotation_available_rotations_set(Evas_Object *obj, 
const int *rotations, unsigned int count): an API that specifies the 
allowable types of Orientation. It passes the array that holds the angle to 
the second parameter and the data count saved in the array to the third 
parameter.  
  
  
Page 601 / 978 48. Hardware Key Events and Debug Mode  
You must program the use of the Up/Down keys for adjusting the volume 
when you build an audio/video player or a game/instrument app. In 
addition, you should be able to perform a specific action (for instance, 
displaying the menu when pressing the hardware Menu button). Typically, 
pressing the hardware Back button takes you back to the previous screen 
or exits the app. Note, however, that you need to perform other actions 
(for instance, displaying a warning popup ) from time to time.  In this 
example, we will learn how to request hardware key events.  
 
1) Requesting a Hardware Key Event  
Create a new source project and specify the project name as 
‘HardwareKeyEvent.’ After the source project is created, open the source 
file (~.c) under the src folder and add new c ode at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    /* Hardware key event callback */  
    evas_object_event_callback_add(ad ->win, EVAS_CALLBACK_KEY_DO WN, on_keyd
own_cb, ad);  
} 
└─────────────────────┘  
  
  
Page 602 / 978 EVAS_CALLBACK_KEY_DOWN represents a callback function of the 
hardware key down event.  
We are now going to create a callback function. Add new code on top of 
the create_base_gui() function.  
┌────────────── ───────┐  
static void  
on_keydown_cb(void *data, Evas *evas, Evas_Object *o, void *event_info)  
{ 
    appdata_s* ad = data;  
    Evas_Event_Key_Down *ev = event_info;  
  
    char *old_msg = elm_object_text_get(ad ->label);  
    char total_msg[PATH_MAX];  
    char *key_value = strdup( ev ->keyname );  
  
    if( strcmp(ev ->keyname, "XF86Menu") ==0 ) {  
        key_value = "Menu";  
    } 
    else if( strcmp(ev ->keyname, "XF86Home") ==0 ) {  
        key_value = "Home";  
    } 
    else if( strcmp(ev ->keyname, "XF86Back") ==0 ) { 
        key_value = "Back";  
    } 
    else if( strcmp(ev ->keyname, "XF86PowerOff") ==0 ) {  
        key_value = "Power";  
    } 
    else if( strcmp(ev ->keyname, "XF86AudioRaiseVolume") ==0 ) {  
        key_value = "Volume Up";  
    } 
    else if( strcmp(ev ->keyname, "XF86AudioLowerVolume") ==0 ) {  
  
Page 603 / 978         key_value = "Volume Down";  
    } 
    else { 
        key_value = ev ->keyname;  
    } 
  
    sprintf(total_msg, "%s<br/>Key input: [%s]", old_msg, key_value);  
    elm_object_text_set(ad ->label, total_msg);  
} 
└─────────────────────┘  
on_keydown_cb() is an event function for the hardware key. The first 
parameter receives user data; the second parameter receives the object 
where an event has occurred; and the third parameter receives the event 
information.  
The eve nt information is saved in Evas_Event_Key_Down format. The 
keyname property holds key values in string format. The types of key 
values are as follows:  
 - XF86Menu: Menu key  
 - XF86Home: Home key  
 - XF86Back: Back key  
 - XF86PowerOff: Power key  
 - XF86Audio RaiseVolume: Volume Up key  
 - XF86AudioLowerVolume: Volume Down key  
Build and run the example. Press the Volume up, Volume Down, and Menu 
hardware keys. The key types are displayed in the Label widget.  
  
Page 604 / 978  
Press an alphanumeric key plus Ctrl+Shift on your ke yboard. The value of 
each key is displayed. If your phone has a built -in hardware keypad, you 
may request individual key input.  
 
Now, press the Home key. The app disappears. Press and hold the Home 
key again to see the list of apps you have run so far. Se lect 
HardwareKeyEvent from the list. You will see the example again and 
confirm that the Home key has been accepted.  
     

  
Page 605 / 978 Now, press the Back key. Once the app has disappeared, press and hold 
the Home key and choose HardwareKeyEvent from the app list.  
Next, press the Power key. When the screen turns Off, press the Home key 
and drag over the screen to unlock it.  
 
 
2) Checking with the Log Message  
It is difficult to check the Home key, Back key, and Power key right away. 
We will use the Log message to faci litate this. Add a new line of code to 
the on_keydown_cb() function.  
┌─────────────────────┐  
static void  
on_keydown_cb(void *data, Evas *evas, Evas_Object *o, void *event_info)  
{ 
    appdata_s* ad = data;  
    Evas_Event_Key_Down *ev = event_info;  
    dlog_print(DLOG_INFO, "tag", ev ->keyname);  
  
    char *old_msg = elm_object_text_get(ad ->label);  

  
Page 606 / 978     char total_msg[PATH_MAX];  
    char *key_value = strdup( ev ->keyname );  
└─────────────────────┘  
This code outputs the key value to a Log message.  
Choose  Log from the panels of Eclipse as below. Select the Tag in the 
combo box and enter ‘tag’ in the edit box on the right.  
Run the example again and press the Hardware key. Pressing the Home 
key, Back key, or Power key may cause the screen to disappear, but t he 
message remains in place.  
 
 
3) Debug Mode  
We will learn how to specify a break point at a specific source code 
location and check the values of the variables in real time.  
  

  
Page 607 / 978 Click the border of the Edit window left of the next code of the 
on_keydown_cb () function. You will see a light blue circle. This is the break 
point. 
char *key_value = strdup( ev ->keyname );  
 
Let's change this to debug mode. Choose Debug from the tab buttons in 
the upper right corner of Eclipse. If you do not see a Tab button calle d 
Debug, then choose Open Perspective. In the popup  window that appears, 
choose Debug from the list.  
 

  
Page 608 / 978 Let's start debugging now. Typically, Ctrl+F11 is used to run an app; for 
debugging, F11 is preferred. You may also choose [Run > Debug] from 
the main me nu. 
If the app stops running when it reaches the main() function, press F8 and 
skip to the next step.  
If it is running, press the Menu key. An arrow is displayed at the break 
point, and it stops working.  
In the Variables panel in the upper right corner of Eclipse, you will see a 
list of variables. Choose ev here to open a tree list.  
A key value is displayed on the right side of the keyname in the sub 
properties.  
To continue, press F8 and go to the next step.  
 

  
Page 609 / 978 Use the following keyboard shortcuts in debug mode:  
 - F11: Start debugging  
 - F8: Next step  
 - F5: Step into  
 - F6: Step over  
 - F7: Step return  
 - Ctrl+F2: Stop debugging  
 
4) Related APIs  
You can request a hardware key down event by passing 
EVAS_CALLBACK_KEY_DOWN to the second parameter of the 
void  evas_object_event_callback_add(Evas_Object *obj, 
Evas_Callback_Type type, Evas_Object_Event_Cb func, void *data) function.  
The hardware key event information is saved in Evas_Event_Key_Down 
format. The keyname property holds key values in string format. T he types 
of key values are as follows:  
 - XF86Menu: Menu key  
 - XF86Home: Home key  
 - XF86Back: Back key  
 - XF86PowerOff: Power key  
 - XF86AudioRaiseVolume: Volume Up key  
 - XF86AudioLowerVolume: Volume Down key  
int  dlog_print(log_priority prio, const ch ar *tag, const char *fmt, ...) : an 
API that outputs Log messages in real time.  
  
Page 610 / 978 Use the following keyboard shortcuts in debug mode:  
 - F11: Start debugging  
 - F8: Next step  
 - F5: Step into  
 - F6: Step over  
 - F7: Step return  
 - Ctrl+F2: Stop debugging  
  
  
Page 611 / 978 49. Lifecycle and Debug Mode  
When you run the app for the first time, it creates a container and a widget 
that make up the UI.  At this point, you can easily allocate memory to the 
variables. When the app is shut down, you need to delete the memory. If 
you need  to play background music, play the music that plays when you 
first run the app. This must be stopped when the app is terminated. When 
the app hides behind the background, the animation that appears on the 
screen should be stopped in order to reduce the CP U load.  The animation 
must then resume when switching from background to foreground.  We 
will look at the lifecycle in this example.  
 
1) Events for the Lifecycle  
For the lifecycle of Tizen native apps, refer to the following diagram:  
 

  
Page 612 / 978 The app execution gen erally follows this order: app_create_cb() => 
app_control_cb() => app_resume_cb() functions.  
The app_terminate_cb() is invoked when you exit the app.  
When the app is paused, such as when switching to background mode, 
the app_pause_cb() function is invoked.  
When the app resumes, the app_resume_cb() function is invoked.  
If another app makes a request for an app Launch, the app_control_cb() 
function in invoked.  
 
2) Event Functions for the Lifecycle  
Create a new source project and specify the project name as ‘L ifeCycle.’ 
After the source project is created, open the source file (~.c) under the src 
folder and add new code at the top.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
static void  
show_message(appdata_s* ad, const char* msg)  
{ 
    dlog_print(DLOG_ERROR, "tag", msg);  
  
Page 613 / 978     char *old_msg = elm_object_text_get(ad ->label);  
    char total_msg[PATH_MAX];  
    sprintf(total_msg, "%s<br/>%s", old_msg, msg);  
    elm_obj ect_text_set(ad ->label, total_msg);  
} 
 
static void  
win_back_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    show_message(ad, "win_back_cb()");  
    /* Let window go to hide state. */  
    elm_win_iconified_set(ad ->win, EINA _TRUE);  
} 
└─────────────────────┘  
The show_message() adds a new message to the Label widget. We have 
placed it at the top so it can be easily invoked from anywhere.  
win_back_cb() is an even callback function that is run when the Back button 
is tapped. An a ppdata object is passed to the first parameter.  
Underneath the source file, you will see various event callback functions 
and their definitions. To one of these functions, add a code that is 
associated with the lifecycle.  
┌─────────────────────┐  
static bool 
app_create(void *data)  
{ 
    appdata_s *ad = data;  
    create_base_gui(ad);  
    show_message(ad, "app_create()");  
  
Page 614 / 978     return true;  
} 
  
static void  
app_control(app_control_h app_control, void *data)  
{ 
    appdata_s *ad = data;  
    show_message(ad, "app _control()");  
} 
  
static void  
app_pause(void *data)  
{ 
    appdata_s *ad = data;  
    show_message(ad, "app_pause()");  
} 
  
static void  
app_resume(void *data)  
{ 
    appdata_s *ad = data;  
    show_message(ad, "app_resume()");  
} 
  
static void  
app_terminate(void  *data)  
{ 
    appdata_s *ad = data;  
    show_message(ad, "app_terminate()");  
} 
└─────────────────────┘  
  
  
Page 615 / 978 app_create() is a callback function executed when you create an app. Call 
the create_base_gui() function, which creates a UI object from here.  
app_control() is a callback function that is run when there is an app Launch 
request in another app.  
app_pause() is a callback function executed when the app switches to 
background mode.  
app_resume() is a callback function executed when the app switches fr om 
background mode to foreground mode.  
app_terminate() is a callback function that is executed when you exit the 
app. 
You specify these five callback functions in the main() function. The main() 
function is where you normally make changes to the callback f unctions.  
Build and run the example. Once the app starts running, confirm that three 
additional functions have been run. The order is app_create() => 
app_control() => app_resume().  
 
Tap the Back button if the app is running. The app is nowhere to be found , 
but that does not mean the app is down. It is still running in background 
mode.  
  

  
Page 616 / 978 We will invoke the app again. Press and hold the Home button to see a 
list of apps you have run up to this point. Choose LifeCycle from the list.  
You will see the example a gain; confirm that three additional functions 
have been run. The app runs in the following order: win_back_cb() => 
app_pause() => app_resume(). The Back button will run the win_back_cb() 
function. When the app switches to background mode, the app_resume() 
function is executed. If it switches to foreground mode, the app_resume() 
function is executed.  
   
We are now going to exit the app. Press and hold the Home button to 
see a list of apps. Tap Clear all to exit all the apps.  

  
Page 617 / 978  
The app has been shut down. New messages pass by in a flash, so there 
is no way of checking them. Luckily, we have something called real -time 
Log messages. Select the Log panel at the bottom of Eclipse and choose 
the Tag in the combo box. Then, enter ‘tag’ in the edit box on the righ t. 
The output message is displayed in the Label widget. You will see that 
app_terminate() has been added to the bottom. This means that the 
app_terminate() function was executed when you shut down the app.  
 

  
Page 618 / 978 3) Debug Mode  
We will learn how to specify a bre ak point at a specific source code 
location and check the values of the variables in real time.  
Go to the win_back_cb() function and tap the border of the Edit window 
on the left of the invoking code of show_message(). You will see a light 
blue circle. Thi s is the break point.  
 
Similarly, specify a break point to the invoking code of show_message() in 
the following five functions:  
 - app_create()  
 - app_control()  
 - app_pause()  
 - app_resume()  
 - app_terminate()  
Let's change this to debug mode. Choose Debu g from the tab buttons in 
the upper right corner of Eclipse.  
Let's start debugging now. Typically, Ctrl+F11 is used to run an app; for 
debugging, F11 is preferred.  
If the app stops running when it reaches the main() function, press F8 and 
skip to the next step. 

  
Page 619 / 978 If the app starts running, stop at the app_create() function. If you press F8, 
it will pass the break point and make another stop at the app_control() 
function.   
Next, it stops at the app_resume() function one more time. If you press F8 
again, the ap p will appear on the screen.  
 
If you tap the Back button, it will stop at the win_back_cb() function. If you 
press F8, it will stop at the app_pause() function.  
If you press F8 again, the app disappears from the screen.  
If you press and hold the Home key,  and then select LifeCycle from the 
app list, it will stop at the app_resume() function.  
Pressing F8 will bring it back on the screen.  
 

  
Page 620 / 978 Use the following keyboard shortcuts in debug mode:  
 - F11: Start debugging  
 - F8: Next step  
 - F5: Step into  
 - F6: Ste p over  
 - F7: Step return  
 - Ctrl+F2: Stop debugging  
 
4) Related APIs  
void win_back_cb(void *data, Evas_Object *obj, void *event_info): an event 
callback function that is executed when the user taps the Back button. An 
appdata object is passed to the first  parameter.  
bool app_create(void *data): a callback function that is executed when you 
create the app. Call the create_base_gui() function, which creates a UI 
object from here.  
void app_control(): a callback function that is run when there is an app 
Launch  request in another app.  
void app_pause(): a callback function that is executed when the app 
switches to background mode.  
void app_resume(): a callback function that is executed when the app 
switches from background mode to foreground mode.  
  
  
Page 621 / 978 void app_terminate(): a callback function that is executed when you exit 
the app.  
Use the following keyboard shortcuts in debug mode:  
 - F11: Start debugging  
 - F8: Next step  
 - F5: Step into  
 - F6: Step over  
 - F7: Step return  
 - Ctrl+F2: Stop debugging  
  
  
Page 622 / 978 50. Using a Notify  
Use Notify when you want to pass a new message to the user. You can 
make the message disappear after a while or even add a widget such as 
a Button. You can also block the user's UI events and display them at the 
bottom.  
 
1) Specifying a Timeout for a Notify  
Create a new source project and specify the project name as ‘NotifyEx.’ 
After the source project is created, open the source file (~.c) under the src 
folder and add a new function on top of the create_base_gui() function. 
This function adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child w idget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(fram e, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
  
Page 623 / 978         /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_objec t_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of th e child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Then, add new code to the create_base_gui() function. This code creates a 
Box container, a Button, and a Notify object.  
┌──── ─────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_s et(ad->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how relationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
         
  
Page 624 / 978 evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello EFL</align>");  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            Evas_Object* notify = creat e_notify_top_timeout(box);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Top / Time out");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
The create_notify_top_timeout() function creates a Notify object and 
specifies the Timeout. Next, create a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static Evas_Object*  
create_notify_top_timeout(Evas_Object *parent)  
{ 
    Evas_Object *notify;  
  
Page 625 / 978     Evas_Object *box;  
    Evas_Object *label;  
  
    /* Create notify (top -aligned / hide automatically) */  
    notify = elm_notify_add(parent);  
    elm_notify_align_set(notify, 0.5, 0.0);  
    elm_notify_timeout_set(notify, 3.0);  
  
    /* Create box for stacking notify message */  
    box = elm_box_add(notify);  
    evas_object_show(box);  
  
    /* Create label for notify message */  
    label = elm_label_add(box);  
    evas_object_size_hint_min_set(label, ELM_SCALE_SIZE(480), 0);  
    elm_label_line_wrap_set(label, ELM_WRAP_WORD);  
    elm_object_text_set(label, "<fon t align=center>This notification will hide automatic
ally in 3 seconds  later.</font>");  
    elm_box_pack_end(box, label);  
    evas_object_show(label);  
  
    elm_object_content_set(notify, box);  
    return notify;  
} 
  
static void  
btn_click_cb(void *data, Eva s_Object *obj, void *event_info)  
{ 
    Evas_Object *notify = data;  
    evas_object_show(notify);  
} 
└─────────────────────┘  
elm_notify_add(Evas_Object *) is an API that creates a Notify object.  
  
Page 626 / 978 elm_notify_align_set(Evas_Object *, double, double) is an API that specifies 
the position of the Notify on the aspect ratio. For the second parameter, 
specify the horizontal position. It is placed on the left for 0, in the middle 
for 0.5, and on the right for 1. For the third parameter, specify the vertical 
position.  It is placed at the top for 0, in the center for 0.5, and at the 
bottom for 1.  
elm_notify_timeout_set(Evas_Object *, double) is an API that specifies a 
Timeout for the Notify. Specify an interval to the second parameter in 
seconds.  
The next code creates a  Box container in the Notify and a Label widget in 
the Box container.  
The btn_click_cb() function displays the Notify on the screen when the 
user taps the Button.  
Build and run the example. If you tap the Button, a Notify appears for 3 
seconds, and then di sappears.  
 

  
Page 627 / 978 2) Resizing Notify  
Sometimes, the text string displayed in a Notify is truncated. We will try 
to fix this by changing the App base scale. Add a new line of code to the 
app_create() function.  
┌─────────────────────┐  
static bool  
app_create(void * data) 
{ 
    appdata_s *ad = data;  
    elm_app_base_scale_set(1.8);  
    create_base_gui(ad);  
  
    return true;  
} 
└─────────────────────┘  
elm_app_base_scale_set(double) is an API that changes the App base scale. 
The default scale is 1.0. As the scale value grows, the Notify area becomes 
smaller.  
Run the example again and tap the Button. This time, the text in the Notify 
appears correctly.  
  
Page 628 / 978  
 
3) Adding a Button Widget to Notify  
We will implement, by adding a Button to the Notify, a feature that makes 
the Notify disappear when you tap the Button instead of when Timeout 
occurs. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_t ext_set(btn, "Top / Time out");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            notify = create_notify_top_manual(box);  
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Top / Manual");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 

  
Page 629 / 978         } 
    } 
└─────────────────────┘  
This is the code that creates the second Notify and the second Button. 
Add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_hide_notify_cb(void *data, Evas_Object *obj, void *event_ info) 
{ 
    Evas_Object *notify = data;  
    evas_object_hide(notify);  
} 
  
static Evas_Object*  
create_notify_top_manual(Evas_Object *parent)  
{ 
    Evas_Object *notify;  
    Evas_Object *box;  
    Evas_Object *label;  
    Evas_Object *btn;  
  
    /* Create notify (top -aligned / hide manually) */  
    notify = elm_notify_add(parent);  
    elm_notify_align_set(notify, 0.5, 0.0);  
    elm_notify_timeout_set(notify, 0.0);  
  
    /* Create box for stacking notify message and button vertically */  
    box = elm_box_add (notify);  
    elm_box_horizontal_set(box, EINA_FALSE);  
    evas_object_show(box);  
  
    /* Create label for notify message */  
  
Page 630 / 978     label = elm_label_add(box);  
    evas_object_size_hint_min_set(label, ELM_SCALE_SIZE(480), 0);  
    elm_label_line_wrap_set(labe l, ELM_WRAP_WORD);  
    elm_object_text_set(label, "<font align=center>Click OK button to hide notification
</center>");  
    elm_box_pack_end(box, label);  
    evas_object_show(label);  
  
    /* Create button to hide notify */  
    btn = elm_button_add(box);  
    elm_object_text_set(btn, "OK");  
    evas_object_size_hint_min_set(btn, ELM_SCALE_SIZE(80), ELM_SCALE_SIZE(58));  
    elm_box_pack_end(box, btn);  
    evas_object_show(btn);  
    evas_object_smart_callback_add(btn, "clicked", btn_hide_notify_cb, notify);  
  
    elm_object_content_set(notify, box);  
  
    return notify;  
} 
└─────────────────────┘  
The btn_hide_notify_cb() hides Notify. Tapping the Button added to the 
Notify will invoke this function.  
The create_notify_top_manual() creates the second Notify objec t. This code 
creates a Box container in the Notify and a Label widget and a Button 
widget in the Box container.  
Run the example again and tap the second Button. The Notify is displayed, 
and you will see that a Label and a Button have been added. Tapping th e 
Button will cause the Notify to disappear.  
  
Page 631 / 978  
 
4) Notify for Blocking Events  
We will implement a feature that blocks the user’s events while a Notify 
is displayed. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
            /* Butt on-2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Top / Manual");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            notify = create_notify_top_block(box);  
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Top / Block");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, noti fy); 
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 

  
Page 632 / 978     } 
└─────────────────────┘  
This is the code that creates the third Notify and the third Button. Create 
a new function on top of the create_base_gui() function.  
┌──────────────────── ─┐ 
static Evas_Object*  
create_notify_top_block(Evas_Object *parent)  
{ 
    Evas_Object *notify;  
    Evas_Object *box;  
    Evas_Object *label;  
  
    /* Create notify (top -aligned / hide automatically / block outside events) */  
    notify = elm_notify_add(par ent); 
    elm_notify_align_set(notify, 0.5, 0.0);  
    elm_notify_timeout_set(notify, 3.0);  
    elm_notify_allow_events_set(notify, EINA_FALSE);  
  
    /* Create box for stacking notify message */  
    box = elm_box_add(notify);  
    evas_object_show(box);  
  
    /* Create label for notify message */  
    label = elm_label_add(box);  
    evas_object_size_hint_min_set(label, ELM_SCALE_SIZE(480), 0);  
    elm_label_line_wrap_set(label, ELM_WRAP_WORD);  
    elm_object_text_set(label, "<font align=center>Outside events  are blocked while n
otification shows.</center>");  
    elm_box_pack_end(box, label);  
    evas_object_show(label);  
  
    elm_object_content_set(notify, box);  
  
Page 633 / 978     return notify;  
} 
└─────────────────────┘  
elm_notify_allow_events_set(Evas_Object *, Eina_Bool) is a function that 
determines whether or not to allow user events when a Notify is in Show 
state. The user events will be blocked if you pass EINA_FALSE to the second 
parameter.  
Run the example again and tap the third Button. A Notify appears for 3 
seconds  and disappears again. While the Notify is in Show state, tapping 
the other Buttons has no effect.  
 
 
  

  
Page 634 / 978 5) Changing the Position of a Notify  
We will implement a feature that displays a Notify at the bottom. Add 
new code to the create_base_gui() function.  
┌─────────────────────┐  
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Top / Block");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            notify = create_notify_bottom_timeout(box);  
 
            /* Button -4 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Bottom / Timeout");  
            evas_object_smart_callback_add(btn, "clicked", btn_click_cb, notify);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
This is the code that creates the fourth Notify and the fourth Button. 
Create a new fu nction on top of the create_base_gui() function.  
┌─────────────────────┐  
static Evas_Object*  
create_notify_bottom_timeout(Evas_Object *parent)  
{ 
    Evas_Object *notify;  
    Evas_Object *box;  
    Evas_Object *label;  
  
Page 635 / 978      /* Create notify (bottom -aligned / hide automatically) */  
    notify = elm_notify_add(parent);  
    elm_notify_align_set(notify, 0.5, 1.0);  
    elm_notify_timeout_set(notify, 3.0);  
  
    /* Create box for stacking notify message */  
    box = elm_box_add(notify);  
    evas_object_show(box);  
  
    /* Create label for notify message */  
    label = elm_label_add(box);  
    evas_object_size_hint_min_set(label, ELM_SCALE_SIZE(480), 0);  
    elm_label_line_wrap_set(label, ELM_WRAP_WORD);  
    elm_object_text_set(label, "<font align=center>This notificat ion shows at the botto
m of the screen.</center>");  
    elm_box_pack_end(box, label);  
    evas_object_show(label);  
  
    elm_object_content_set(notify, box);  
    return notify;  
} 
└─────────────────────┘  
elm_notify_align_set(Evas_Object *, double, double) is  an API that specifies 
the position of the Notify on the aspect ratio. For the second parameter, 
specify the horizontal position. It is placed on the left for 0, in the middle 
for 0.5, and on the right for 1. For the third parameter, specify the vertical 
position. It is placed at the top for 0, in the center for 0.5, and at the 
bottom for 1.  
Run the example again and tap the fourth Button. A Notify appears briefly 
at the bottom, and then disappears.  
  
Page 636 / 978  
 
6) Related APIs  
Evas_Object  *elm_notify_add(Evas_Object *parent): an API that creates a 
Notify object.  
void  elm_notify_align_set(Evas_Object *obj, double horizontal, double 
vertical): an API that specifies the position of the Notify on the aspect 
ratio. For the second parameter, sp ecify the horizontal position. It is placed 
on the left for 0, in the middle for 0.5, and on the right for 1. For the third 
parameter, specify the vertical position. It is placed at the top for 0, in the 
center for 0.5, and at the bottom for 1.  
void  elm_n otify_timeout_set(Evas_Object *obj, double timeout): an API 
that specifies a Timeout for the Notify. Specify an interval to the second 
parameter in seconds.  
  

  
Page 637 / 978 void  elm_notify_allow_events_set(Evas_Object *obj, Eina_Bool allow): a 
function that determines whether or not to allow user events when the 
Notify is in Show state. The user events will be blocked if you pass 
EINA_FALSE to the second parameter.  
  
  
Page 638 / 978 51. Using  a Acceleration Sensor  
You can measure the shaking of your phone with the accelerator sensor. 
You can measure the directions of the X -, Y-, and Z -axes. In addition, you 
can choose to apply gravity or discard it and separate those results. To 
test the accelerator sensor in the emulator, use the Control Panel.  
 
1) Determining Whether the Accelerator Sen sor Is Supported or Not  
Create a new source project and specify the project name as 
‘SensorAcceleration.’ After the source project is created, open the source 
file (~.c) under the src folder and add a library header file as well as 
variables.  
┌──────────── ─────────┐  
#include "sensoracceleration.h"  
#include <sensor.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
    Evas_Object *label2;  
} appdata_s;  
└─────────────────────┘  
sensor .h is a header file for various sensor libraries.  
  
Page 639 / 978 We are going to display whether or not the accelerator sensor is 
supported on label0, the current acceleration value on label1 and the 
maximum value of acceleration on label2.  
Create a new function on top o f the create_base_gui() function. This 
function adds a widget to a Box container.  
Create two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_ supported = false;  
    sensor_is_supported(SENSOR_ACCELEROMETER, &is_supported);  
    sprintf(buf, "Acceleration Sensor is %s", is_supported ? "support" : "not support");  
    elm_object_text_set(ad ->label0, buf);  
} 
 
static void  
my_box_pack(Evas_Object *box,  Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there i s "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_o bject_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
  
Page 640 / 978         /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_ HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
The show_is_supported() function identifies whether the accelerator sensor 
is supported or not, and then displays the result in the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that requests whether 
or not a specific sensor is s upported. Passing SENSOR_ACCELEROMETER 
to the first parameter makes the second parameter return whether or not 
the sensor is supported.  
my_box_pack() is a function that adds a widget to a Box container.  
All you have to do is invoke the show_is_supported() function while the 
app is running. Invoke the function above at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
  
Page 641 / 978     ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR _SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND , EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Msg - "); 
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Value - "); 
            my_box_pack(box, ad ->label1, 1.0, 0.0, -1.0, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
  
Page 642 / 978     show_is_supported(ad);  
} 
└─────────────────────┘  
We have added two Label widgets. Plus, we have invoked a function to 
determine whether or not the sensor is supported.  
Build and run the example. If the accelerator sensor is supported, you will 
see the message ‘Acceleration Sensor is supported.’ Not all smartphones 
support the sensor. If this is the case, please test it in the emulator.  
 
 
2) Requesting the  Event for the Accelerator Sensor  
We will implement a feature that requests the corresponding event as you 
shake the device and displays that acceleration value on the screen. Add 
a structure fo r the sensor and a global variable to the top of the source 
file. 
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
    Evas_Object *label2;  
} appdata_s;  
  

  
Page 643 / 978 typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  
sensorinfo is a structure that includes a sensor object and an eve nt listener 
variable.  
sensor_info is a global variable of the sensorinfo structure.  
To request a sensor event, start the listener. We will request an accelerator 
sensor event using the sensor object and event listener. Create two new 
functions above the cr eate_base_gui() function.  
┌─────────────────────┐  
static void _new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *use
r_data)  
{ 
    if( sensor_data ->value_count < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*) user_data;  
  
    sprintf(buf, "Value - X : %0.1f / Y : %0.1f / Z : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
} 
  
static void  
  
Page 644 / 978 start_acceleration_sensor(appdata_s *ad) 
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_ACCELEROMETER, &sensor_info.sensor);  
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor_info.se nsor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└─────────────────────┘  
_new_sensor_value() is an event callback function for the accelerator sensor. 
Output a new sensor value to the screen. The sensor data are passed to 
the second parameter. values[0] contains x -axis data, values[1] contains y -
axis data, and values[2] contains z -axis data.  
start_acceleration_sensor() is a callback function that starts the accelerator 
sensor and specifies the event callb ack function.  
sensor_get_default_sensor(sensor_type_e, sensor_h *) is an API that returns 
a sensor object. Passing SENSOR_ACCELEROMETER to the first parameter 
returns an accelerator sensor object to the second parameter.  
sensor_create_listener(sensor_h, se nsor_listener_h *) is an API that creates 
an event listener. Passing a sensor object to the first parameter returns a 
listener object to the second parameter.  
sensor_listener_set_event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callback function to the 
listener. The parameters follow this order: event listener, interval (in 
milliseconds), callback function name, and user data.  
  
Page 645 / 978 sensor_listener_start(sensor_listener_h) is an API that starts the listener.  
 
We will o perate the event listener automatically when the app starts 
running. Invoke the function above at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_i s_supported(ad);  
    start_acceleration_sensor(ad);  
} 
└─────────────────────┘  
Let's run the example again. To test on your smartphone, simply shake the 
device. Use the Control Panel for testing in the emulator.  
Right-click the emulator and select the Control Panel from the shortcut 
menu.  
 

  
Page 646 / 978 In the Control Panel, select [Event Injector > 3 -Axis Sensors] from the tree 
list on the left, followed by Acceleration from the tab buttons on the right 
side of the screen.  
Drag the three sliders one at a time. If t he X, Y, and Z values change on 
the app screen, it means you have correctly received the accelerator data.  
 
 
3) Requesting the Maximum Acceleration Value  
If you try testing it with your smartphone, the characters are hardly visible 
when you are shaking th e phone. When you stop shaking to see the values, 
the downward direction is 9.8, and the rest is reset to 0. For that reason, 
we need a feature that saves the maximum value when testing on your 
phone.  
Declare an array variable in number format at the top of the source file 
and reset it to 0. This variable saves the maximum acceleration value.  

  
Page 647 / 978 ┌─────────────────────┐  
typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
  
float value[3] = {0.f, 0.f, 0.f};  
└─────────────────────┘  
Add new code to the create_base_gui() function.  
┌─────────────────────┐  
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Value - "); 
            my_box_pack(box, ad ->label1, 1.0, 0.0, -1.0, 0.0);  
 
            /* Button */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Init Max Val ue"); 
            evas_object_smart_callback_add(btn, "clicked", btn_clicked, ad);  
            my_box_pack(box, btn, 1.0, 0.0, -1.0, -1.0); 
 
            /* Label -2 */ 
            ad->label2 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label2, "Max - "); 
            my_box_pack(box, ad ->label2, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
  
Page 648 / 978 This code adds a Button widget and a Label widget. We will implement a 
feature that displays the maximum value of the accelerator sen sor in the 
third Label and reset the maximum value to 0 when you tap the Button. 
Add two new functions and new code to the _new_sensor_value() function.  
┌─────────────────────┐  
static float get_absolute_max(float value1, float value2)  
{ 
    float v1 = valu e1 > 0.f ? value1 : -value1;  
    float v2 = value2 > 0.f ? value2 : -value2;  
    float result = v1 > v2 ? v1 : v2;  
    return result;  
} 
  
static void _new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *use
r_data)  
{ 
    if( sensor_data ->value_count < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "Value - X : %0.1f / Y : %0.1f / Z : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
  
    for(int i=0; i < 3; i++)  
        value[i] = get_absolute_max(value[i], sensor_data ->values[i]);  
  
    sprintf(buf, "Max - X: %0.1f / Y: %0.1f / Z: %0.1f",  
            value[0], value[1], value[2]);  
    elm_object_t ext_set(ad ->label2, buf);  
} 
  
Page 649 / 978 /* Button click event function */  
static void  
btn_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    for(int i=0; i < 3; i++)  
        value[i] = 0.f;  
} 
└─────────────────────┘  
The get_absolute_max(float, float) functi on returns a higher value by 
changing two real numbers to absolute values.  
The codes you added in the _new_sensor_value() function save the 
maximum values of X, Y, and Z axes in the global variable and output them 
to the Label widget.  
The btn_clicked() fun ction resets the maximum value saved in the global 
variable to 0 when you tap the Button.  
Install the example and shake the phone. When you stop shaking, the 
value in the second Label is reset, but the maximum value remains intact 
in the third Label.  
You can measure a new value by holding the Button and shaking again.  
 

  
Page 650 / 978 4) Requesting Pure Acceleration without Gravity  
As you may have noticed in the result values, the acceleration we 
calculated includes the gravity. Now, let’s obtain the acceleration value 
alone, excluding the gravity.  
Make changes to the code of the start_acceleration_sensor() function as 
follows:  
┌─────────────────────┐  
static void  
start_acceleration_sensor(appdata_s *ad)  
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    //sensor_get_defaul t_sensor(SENSOR_ACCELEROMETER, &sensor_info.sensor);  
    sensor_get_default_sensor(SENSOR_LINEAR_ACCELERATION, &sensor_info.senso
r); 
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor _info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└─────────────────────┘  
SENSOR_ACCELEROMETER is a sensor type representing the acceleration 
that includes the gravity.  
SENSOR_LINEAR_ACCELERATION represents the accelerator sensor free of 
gravity.  
Install the example and shake the phone. What you see now is the pure 
acceleration.  
  
Page 651 / 978 To test in the emulator, select [Event Injector > 3 -Axis Sensors] in the 
Control Panel and click GUI from the tab buttons  on the right.  
Click the Portrait button and Landscape button back and forth. If you set 
the sensor type to SENSOR_ACCELEROMETER, the total of X, Y, and Z will 
be 9.8. With SENSOR_LINEAR_ACCELERATION, the total will be 0.  
 
 
5) Related APIs  
int  sensor_is_ supported(sensor_type_e type, bool *supported): an API 
that requests whether or not a specific sensor is supported. Passing 
SENSOR_ACCELEROMETER to the first parameter makes the second 
parameter return whether or not the accelerator sensor is supported.  
 - SENSOR_ACCELEROMETER: the accelerator sensor that includes the 
gravity.  

  
Page 652 / 978  - SENSOR_LINEAR_ACCELERATION: the accelerator sensor without the 
gravity.  
int  sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor): an 
API that returns a sensor object. Passing SENSOR_ACCELEROMETER to the 
first parameter returns an accelerator sensor object to the second 
parameter.  
int  sensor_create_listener(sensor_h sensor, sensor_listener_h *listener): an 
API that creates an event listener. Passing a sensor object to t he first 
parameter returns a listener object to the second parameter.  
int  sensor_listener_set_event_cb(sensor_listener_h listener, unsigned int 
interval_ms, sensor_event_cb callback, void *data): an API that specifies a 
callback function to the listener. / parameters: event listener, interval (in 
milliseconds), callback function name, and user data.  
int  sensor_listener_start(sensor_listener_h listener): an API that starts the 
listener.  
 
  
  
Page 653 / 978 52. Using a Gravity Sensor  
The direction of the device can be estimated  by the gravity sensor. The 
sensor helps to measure the directions of the X -, Y-, and Z -axes. Use the 
Control Panel to test the gravity sensor on the emulator.  
 
1) Determining if the Gravity Sensor is Supported  
Create a new source project and specify the p roject name as 
'SensorGravity.' After the source project is created, open the source file 
(~.c) under the src folder and add library header files and variables.  
┌─────────────────────┐  
#include "sensorgravity.h"  
#include <sensor.h>  
  
typedef struct appdata  { 
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
sensor.h is a library header file for various sensors.  
We are going to display whether the sensor is supported on label0, and 
the current grav ity value on label1.  
Create two functions on top of the create_base_gui() function.  
  
Page 654 / 978 ┌─────────────────────┐  
static void show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_supported = false;  
    sensor_is_supported(SENSOR_GRAVITY, & is_supported);  
    sprintf(buf, "Gravity Sensor is %s", is_supported ? "support" : "not support");  
    elm_object_text_set(ad ->label0, buf);  
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h _align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available  as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_s ize_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (abov e) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
  
Page 655 / 978    elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
show_is_supported() is a function that determines if the gravity sensor is 
supported and display s the result on the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that determines if a 
certain sensor is supported. Passing SENSOR_GRAVITY to the first 
parameter makes the second parameter return whether or not the sensor 
is supp orted.  
my_box_pack() is a function that adds a widget to a Box.  
We need to call the show_is_supported() function when the app is run. 
Call the function above at the end of the create_base_gui() 
function.┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND); 
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
  
Page 656 / 978         box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Msg - "); 
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_la bel_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Value - "); 
            my_box_pack(box, ad ->label1, 1.0, 1.0, -1.0, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    show_is_suppor ted(ad);  
} 
└─────────────────────┘  
We added a Box container and two Label widgets. Then, we called the 
function to determine if the sensor is supported.  
Build and run the example. If the gravity sensor is supported, you will see 
the message 'Gravity Sensor  is supported.' Some smartphones may not 
support the sensor. In such cases, you need to test it on the emulator.  
  
Page 657 / 978  
 
2) Requesting a Gravity Sensor Event  
We will implement a feature that displays the gravity value on the screen 
by getting the event when the  device direction changes. Add a sensor -
related structure and global variables at the top of the source 
file.┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
  
typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  
sensorinfo is the structure including a sensor object and event listener 
variables.  
sensor_info is a global variable of the sensorinfo structure.  

  
Page 658 / 978 Requesting a sensor event means to start the listener. We are now going 
to request a gravity sensor event by using the sensor object and event 
listener. Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void _new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *use
r_data)  
{ 
    if( sensor_data ->value_cou nt < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "Gravity - X : %0.1f / Y : %0.1f / Z : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
} 
  
static void  
start_gravity_sensor(appdata_s *ad)  
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_GRAVITY, &sensor_info.sensor);  
    err = sensor_create_listener(sensor_info.sen sor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor_info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└─────────────────────┘  
_new_sensor_value() is an event callback functi on for the gravity sensor. 
Output new sensor values on the screen.  
  
  
Page 659 / 978 The sensor data is passed to the second parameter as an array. The 
direction data of the X -, Y-, and Z -axes is saved in values[0], vales[1], and 
values[2], respectively.  
start_gravity_sen sor() is a function that starts the gravity sensor and 
specifies the event callback function.  
sensor_get_default_sensor(sensor_type_e, sensor_h *) is an API that returns 
the sensor object. Passing SENSOR_GRAVITY to the first parameter returns 
the gravity s ensor object to the second parameter.  
sensor_create_listener(sensor_h, sensor_listener_h *) is an API that creates 
an event listener. Passing the sensor object to the first parameter returns 
the listener object to the second parameter.  
sensor_listener_set_ event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callback function to the 
listener. The parameters listed in order are an event listener, time interval 
(in milliseconds), name of the callback function, and user data. 
sensor_listener_start(sensor_listener_h) is an API that starts the listener.  
We will make the event listener operate automatically when the app is run. 
Call the function above at the end of the create_base_gui() function. 
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_is_supported(ad);  
    start_gravity_sensor(ad);  
  
Page 660 / 978 } 
└─────────────────────┘  
Run the example again. On a smartphone, simply rotate the phone for 
testing. On an emulator, use the Control Panel for testing.  
Right-click the emulator and select Control Panel from the shortcut menu.  
On the Control Panel, select [Event Injector > 3 -Axis Sensors] from the list 
in tree structure on the left, and then click GUI from the tab buttons  on 
the right side of the screen.  
Clicking the Portrait button on the right side of the screen on the Control 
Panel displays 'X : 0.0 / Y : 9.8 / Z : 0.0' on the second Label widget of the 
app screen.  
 
Clicking the Landscape button on the right side of th e screen on the 
Control Panel displays 'X : 9.8 / Y : 0.0 / Z : 0.0' on the second Label widget 
of the app screen.  

  
Page 661 / 978  
 
3) Related APIs  
int sensor_is_supported(sensor_type_e type, bool *supported):  an API that 
determines if a certain sensor is supported. Pas sing SENSOR_GRAVITY to 
the first parameter makes the second parameter return whether or not the 
gravity sensor is supported.  
int  sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor):  an 
API that returns the sensor object. Passing SENSOR_GRAVITY  to the first 
parameter returns the gravity sensor object to the second parameter.  
int  sensor_create_listener(sensor_h sensor, sensor_listener_h *listener):  an 
API that creates an event listener. Passing the sensor object to the first 
parameter returns th e listener object to the second parameter.  
int sensor_listener_set_event_cb(sensor_listener_h listener, unsigned int 
interval_ms, sensor_event_cb callback, void *data):  an API that specifies a 
callback function to the listener. / parameters: event listener , time interval 
(in milliseconds), name of the callback function, and user data  
int sensor_listener_start(sensor_listener_h listener):  an API that starts the 
listener.   

  
Page 662 / 978 53. Using an Orientation Sensor  
The orientation sensor can measure three types of direction s.  
- Azimuth is a compass sensor. This shows the difference of the angle from 
the Arctic when the phone is laid on the floor.  
- Pitch shows the angle on the Z -axis when the phone is standing. It 
usually works as a handle in airplane or car games.  
- Roll shows the angle on the Y -axis when the phone is laid in Landscape 
mode. It usually works to control speed in airplane or car games.  
When the phone is in Portrait mode, the horizontal direction will be the 
X-axis, and the vertical direction will be the Y -axis. The forward and 
backward directions will be the Z -axis. Use the Control Panel to test the 
orientation sensor on the emulator.  
 
 
  

  
Page 663 / 978 1) Determining if the Orientation Sensor is Supported  
Create a new source project and specify the project name as 
'SensorOrientation.' After the source project is created, open the source 
file (~.c) under the src folder and add library header files and variables.  
┌─────────────────────┐  
#include "sensororientation.h"  
#include <sensor.h>  
 
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
└─────────────────────┘  
sensor.h is a library header file for various sensors.  
We are going to display if the orientation sensor is supported on label0, 
and the current gravity value on label1.  
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_supported = false;  
    sensor_is_supported(SENSOR_ORIENTATION, &is_supported);  
    sprintf(buf, "Orientation Sensor is %s", is_supported ? "support" : "not support");  
  
Page 664 / 978     elm_object_text_set(ad ->label0, buf);  
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_me dium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight _set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT _EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child) ; 
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
  
  
Page 665 / 978 show_is_supported() is  a function that determines if the orientation sensor 
is supported and displays the result on the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that determines if a 
certain sensor is supported. Passing SENSOR_ORIENTATION to the f irst 
parameter makes the second parameter return whether or not the sensor 
is supported.  
my_box_pack() is a function that adds a widget to a Box.  
We need to call the show_is_supported() function when the app is run. 
Call the function above at the end of th e create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box , *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
  
Page 666 / 978  
        { /* child object - indent to how relationship */  
            /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Msg - "); 
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Orientation - "); 
            my_box_pack(box, ad ->label1, 1.0, 1.0, -1.0, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    show_is_supported(ad);  
} 
└─────────────────────┘  
We created a Box container and two Label widgets. Then, we called the 
function to determine if the sensor is supported.  
Build and run the example. If the orientation sensor is supported, you will 
see the message 'Orientation Sensor is supported.' Some smartphones 
may not support the sensor. In such cases, you need to test it on the 
emulator.  
 

  
Page 667 / 978 2) Requesting the  Orientation Sensor Event  
We will implement a feature that displays the value on the screen by getting the e
vent when the device direction changes. Add a sensor -related structure and global 
variables at the top of the source file.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
  
typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  
sensorinfo is the structure including a sensor object and event listener 
variables.  
sensor_info is a global variable of the sensorinfo structure.  
Requesting a sensor event starts the listener. We are now going to call an 
orientation sensor event by using the sensor object and event listener. 
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
  
Page 668 / 978 _new_sensor_value(sensor_h sensor, sensor_even t_s *sensor_data, void *user_data)  
{ 
    if( sensor_data ->value_count < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "Azimuth : %0.1f <br>Pitch : %0.1f <br>Roll : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
} 
 
static void  
start_orientation_sensor(appdata_s *ad)  
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_ORIENTATION, &s ensor_info.sensor);  
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor_info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└── ───────────────────┘  
_new_sensor_value() is an event callback function for the orientation sensor. 
Output new sensor values on the screen.  
The sensor data is passed to the second parameter as an array. The 
direction data of Azimuth, Pitch, and Roll data is  saved in values[0], vales[1], 
and values[2], respectively.  
start_orientation_sensor() is a function that starts the orientation sensor 
and specifies the event callback function.  
  
Page 669 / 978 sensor_get_default_sensor(sensor_type_e, sensor_h *) is an API that returns 
the sensor object. Passing SENSOR_ORIENTATION to the first parameter 
returns the orientation sensor object to the second parameter.  
sensor_create_listener(sensor_h, sensor_listener_h *) is an API that creates 
an event listener. Passing the sensor object to the first parameter returns 
the listener object to the second parameter.  
sensor_listener_set_event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callback function to the 
listener. The parameters listed in order are  an event listener, time interval 
(in milliseconds), name of the callback function, and user data.  
sensor_listener_start(sensor_listener_h) is an API that starts the listener.  
We will make the event listener operate automatically when the app is run. 
Call the function above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_is_supported(ad);  
    start_orientation_sensor(ad);  
} 
└─────────────────────┘  
When you run the test in this status, the phone may change to Landscape 
mode when rotating the phone. Fix the screen direction to Portrait mode. 
At the top of the create_base_gui() function, make the code below support 
four directions.  
  
Page 670 / 978 ┌────────────────── ───┐  
    int rots[4] = { 0, 90, 180, 270 };  
    elm_win_wm_rotation_available_rotations_set(ad ->win, (const int *)(&rots), 4);  
└─────────────────────┘  
Modify the code as follows.  
┌─────────────────────┐  
    int rots[1] = { 0 };  
    elm_win_wm_rotation_avai lable_rotations_set(ad ->win, (const int *)(&rots), 1);  
└─────────────────────┘  
Run the example again. On a smartphone, simply rotate the phone for 
testing. On an emulator, use the Control Panel for testing.  
Right-click the emulator and select Control Panel  from the shortcut menu.  
On the Control Panel, select [Event Injector > 3 -Axis Sensors] from the list 
in tree structure on the left, and then click GUI from the tab buttons on 
the right side of the screen.  
First, let's test Azimuth. Click the Portrait butt on, and move the slider of 
X-axis to the left end. Then, the phone will be laid flat. Now, drag the 
slider of Z -axis to the right and left. On the app screen, the values of 
Azimuth will change from 0 to 360.  
  
Page 671 / 978  
Second, let's test Pitch. Click the Portrait b utton, and drag the slider of Z -
axis to the right and left. On the app screen, the values of Azimuth will 
change from -180 to 180.  
 
Third, let’s test Roll. Tap the Landscape button, and drag the slider of Y -
axis to the right and left. On the app screen, the values of Roll will change 
from -180 to 180.  

  
Page 672 / 978  
 
3) Related APIs  
int  sensor_is_supported(sensor_type_e type, bool *supported):  an API 
that determines if a certain sensor is supported. Passing 
SENSOR_ORIENTATION to the first parameter makes the second 
parameter return whether or not the orientation sensor is supported.  
int  sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor):  an 
API that returns the sensor object. Passing SENSOR_ORIENTATION to the 
first parameter returns the orientation sens or object to the second 
parameter.  
int  sensor_create_listener(sensor_h sensor, sensor_listener_h *listener):  an 
API that creates an event listener. Passing the sensor object to the first 
parameter returns the listener object to the second parameter.  
  

  
Page 673 / 978 int  sensor_listener_set_event_cb(sensor_listener_h listener, unsigned int 
interval_ms, sensor_event_cb callback, void *data):  an API that specifies a 
callback function to the listener. / parameters: event listener, time interval 
(in milliseconds), name of th e callback function, and user data.  
int  sensor_listener_start(sensor_listener_h listener):  an API that starts the 
listener.  
  
  
Page 674 / 978 54. Using a Magnetic Sensor  
You can use a magnetic sensor when developing a compass app or 
measuring the magnetic field strength. It ca n be measured from the 
strength of the X -, Y-, and Z -axes. When the phone is in Portrait mode, 
the horizontal direction will be the X -axis, and the vertical direction will 
be the Y -axis. The forward and backward directions will be the Z -axis. Use 
the Contr ol Panel to test the magnetic sensor on the emulator.  
 
1) Determining If the Magnetic Sensor is Supported  
Create a new source project and specify the project name as 
'SensorMagnetic.' After the source project is created, open the source file 
(~.c) under th e src folder and add library header files and variables.  
┌─────────────────────┐  
#include "sensormagnetic.h"  
#include <sensor.h>  
#include <math.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
    Evas_Object *label2;  
} appdata_s;  
└─────────────────────┘  
  
Page 675 / 978 sensor.h is a library header file for various sensors.  
math.h is a math library header file.  
We are going to display if the magnetic sensor is supported on label0, 
and the magnetic values of the three axes on label1. We are going to 
display the value of the whole magnetic field on label2.   
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_supported = false;  
    sensor_is_supported(SENSOR_MAGNETIC, &is_supported);  
    sprintf(buf, "Magnetic Sensor is %s", is_supported ? "support" : "not support");  
    elm_object_text_set(ad ->label0, buf);  
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on  the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
  
Page 676 / 978      { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_objec t_show(frame);  
} 
└─────────────────────┘  
show_is_supported() is a function that determines if the magnetic sensor 
is supported and displays the result on the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that determines if a 
certain sensor is supported. Passing SENSOR_MAGNETIC to the first 
parameter makes the second parameter return whether or not the sensor 
is supported.  
my_box_pack() is a function that adds a widget to a Box.  
We need to call the function above when the app is run. Call the function 
above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
  
Page 677 / 978     elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_op acity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Msg - "); 
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Value - "); 
            my_box_pack(box, ad ->label1, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -2 */ 
            ad->label2 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label2, "Strength : ");  
            my_box_pack(box, ad ->label2, 1.0, 1.0, -1.0, 0.0);  
        } 
    } 
  
Page 678 / 978  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    show_is_supported(ad);  
} 
└─────────────────────┘  
Three Label widgets have been created. Then, the function is called to 
determine if the sensor is supported.  
Build and run the exa mple. If the magnetic sensor is supported, you will 
see the message 'Magnetic Sensor is supported.' Some smartphones may 
not support the sensor. In such cases, you need to test it on the emulator.  
 
 
  

  
Page 679 / 978 2) Requesting the  Magnetic Sensor Event  
We will implement a feature that displays the value on the screen by 
requesting an event when the magnetic field around changes. Add a 
sensor -related structure and global variables at the top of the source file.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
    Evas_Object *label2;  
} appdata_s;  
  
typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  
sensorinfo is the structure including a sensor object and event listener 
variables.  
sensor_info is a global variable of the sensorinfo structure.  
Requesting a sensor event starts the lis tener. We are now going to request 
a magnetic sensor event by using the sensor object and event listener. 
Create two functions on top of the create_base_gui() function.  
  
Page 680 / 978 ┌─────────────────────┐  
static void  
_new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *user_data)  
{ 
    if( sensor_data ->value_count < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "X : %0.1f / Y : %0.1f / Z : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
} 
 
static void  
start_magnetic_sensor(appdata_s *ad)  
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_MAGNETIC, &sensor_info.sensor) ; 
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor_info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└──────────────────── ─┘ 
_new_sensor_value() is an event callback function for the magnetic sensor. 
Output new sensor values on the screen.  
The sensor data is passed to the second parameter as an array. The 
direction data of the X -, Y-, and Z -axes is saved in values[0], vales[1 ], and 
values[2], respectively.  
  
  
Page 681 / 978 start_magnetic_sensor() is a function that starts the magnetic sensor and 
specifies the event callback function.  
sensor_get_default_sensor(sensor_type_e, sensor_h *) is an API that returns 
the sensor object. Passing SENSOR _MAGNETIC to the first parameter 
returns the magnetic sensor object to the second parameter.  
sensor_create_listener(sensor_h, sensor_listener_h *) is an API that creates 
an event listener. Passing the sensor object to the first parameter returns 
the listen er object to the second parameter.  
sensor_listener_set_event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callback function to the 
listener. The parameters listed in order are an event listener, time interval 
(in milliseconds), name of the callback function, and user data.  
sensor_listener_start(sensor_listener_h) is an API that starts the listener.  
We will make the event listener operate automatically when the app is run. 
Call the function above at the end of the c reate_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_is_supported(ad);  
    start_magnetic_sensor(ad);  
} 
└─────────────────────┘  
  
  
Page 682 / 978 Run the example again. On a smartphone , simply bring the phone near 
to a magnet, or rotate it while laying it on the floor for testing. On an 
emulator, use the Control Panel for testing.  
Right-click the emulator and select Control Panel from the shortcut menu.  
On the Control Panel, select [Eve nt Injector > 3 -Axis Sensors] from the list 
in tree structure on the left, and then click Magnetic from the tab buttons 
on the right side of the screen.  
Drag the three sliders on the right screen of the Control Panel. The values 
of the second Label widget on the app screen will change.  
 
 
3) Getting the Whole Magnetic Values  
Now, we will learn how to get the whole magnetic values by integrating 
the values of the X -, Y-, and Z -axes. To get the whole magnetic values, 
add up the squares of the three values, an d then the square roots. Add a 
new function on top of the _new_sensor_value() function, and modify the 
code of the _new_sensor_value() function.  
┌─────────────────────┐  
static float  

  
Page 683 / 978 _magnetic_strength_get(const float *values)  
{ 
    float sum = 0.0;  
    for(int i=0; i < 3; i++)  
        sum += values[i] * values[i];  
  
    return sqrt(sum);  
} 
 
static void  
_new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *user_data)  
{ 
    if( sensor_data ->value_count < 3 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "X : %0.1f / Y : %0.1f / Z : %0.1f",  
            sensor_data ->values[0], sensor_data ->values[1], sensor_data ->values[2]);  
    elm_object_text_set(ad ->label1, buf);  
  
    float str ength = _magnetic_strength_get(sensor_data ->values);  
    sprintf(buf, "Strength : %0.1f", strength);  
    elm_object_text_set(ad ->label2, buf);  
} 
└─────────────────────┘  
_magnetic_strength_get(const float *) is a function that sums the squares 
of three valu es saved in the array, and returns the square roots of the 
result.  
sqrt(double) is a math API to calculate a square root.  
  
Page 684 / 978 Run the example again. Now, the result of calculating the magnetic values 
will be displayed on the third Label.  
 
 
4) Related APIs  
int  sensor_is_supported(sensor_type_e type, bool *supported):  an API 
that determines if a certain sensor is supported. Passing 
SENSOR_MAGNETIC to the first parameter makes the second parameter 
return whether or not the magnetic sensor is supported.  
int  sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor):  an 
API that returns the sensor object. Passing SENSOR_MAGNETIC to the first 
parameter returns the magnetic sensor object to the second parameter.  
int  sensor_create_listener(sensor_h sensor, s ensor_listener_h *listener):  an 
API that creates an event listener. Passing the sensor object to the first 
parameter returns the listener object to the second parameter.  
int  sensor_listener_set_event_cb(sensor_listener_h listener, unsigned int 
interval_ms , sensor_event_cb callback, void *data):  an API that specifies a 
callback function to the listener. / parameters: event listener, time interval 
(in milliseconds), name of the callback function, and user data.  
  

  
Page 685 / 978 int  sensor_listener_start(sensor_listener_h listener):  an API that starts the 
listener.  
sqrt(double): A math API that calculates a square root.  
  
  
Page 686 / 978 55. Using a Proximity Sensor  
When your phone rings and you bring the phone close to your face, the 
phone screen turns off.  This feature is enabled by the prox imity sensor. 
Use the Control Panel to test the proximity sensor on the emulator.  
 
1) Determining if the Proximity Sensor is Supported  
Create a new source project and specify the project name as 
'SensorProximity.' After the source project is created, open the source file 
(~.c) under the src folder and add library header files and variables.  
┌─────────────────────┐  
#include "sensorproximity.h"  
#include <sensor.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
└─────────────────────┘  
sensor.h is a library header file for various sensors.  
We are going to display if the proximity sensor is supported on label0, 
and the distance value on label1.  
  
Page 687 / 978 Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_supported = false;  
    sensor_is_supported(SENSOR_PROXIMITY, &is_supported);  
    sprintf(buf, "Proximity Sens or is %s", is_supported ? "support" : "not support");  
    elm_object_text_set(ad ->label0, buf);  
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a fram e we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_al ign, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it  */ 
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
  
Page 688 / 978         elm_object_content_set(frame, child);  
     } 
   /* put the frame into  the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
show_is_supported() is a function that determines if the proximity sensor 
is supported and displays the  result on the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that determines if a 
certain sensor is supported. Passing SENSOR_PROXIMITY to the first 
parameter makes the second parameter return whether or not the sensor 
is support ed. 
my_box_pack() is a function that adds a widget to a Box container.  
We need to call the show_is_supported() function when the app is run. 
Call the function above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_H INT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationship */  
  
Page 689 / 978         Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_ob ject_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Msg - "); 
            my_box_pack(box, ad ->label0, 1.0, 0 .0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Value - "); 
            my_box_pack(box, ad ->label1, 1.0, 1.0, -1.0, 0.0);  
 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    show_is_supported(ad);  
} 
└─────────────────────┘  
We created a Box and two Label widgets. Then, we called the function to 
determine if the sensor is supported.  
  
Page 690 / 978 Build and run the example. If the proximity sensor is supported, you will 
see the message 'Proximity Sensor is supported.' Some smartphones may 
not support the sensor. In such cases, you need to test it on the emulator.  
 
 
2) Requesting a Proximity Sensor Event  
We will implement a feature that displays the distance value on the screen 
by getting the event when the proximity sensor detects an object. Add a 
sensor -related structure and global variables at the top of the source file.  
┌─────────────────────┐  
typedef struct a ppdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
  
typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  

  
Page 691 / 978 sensorinfo is the structure including a sensor object and event listener 
variables.  
sensor_info is a global variable of the sensorinfo structure.  
Requesting a sensor event starts the listener. We are now going to request 
a proximity sensor event by using the sensor object and event listener. 
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
_new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data,  void *user_data)  
{ 
    if( sensor_data ->value_count < 1 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "Distance : %0.1f", sensor_data ->values[0]);  
    elm_object_text_set(ad ->label1, buf);  
} 
  
static void  
start_proximity_sensor(appdata_s *ad)  
{ 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_PROXIMITY, &sensor_info.sensor);  
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_set_event_cb(sensor_info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└─────────────────────┘  
  
Page 692 / 978 _new_sensor_value() is an event callback function for the proximity sensor. 
Output new sensor values on the screen.  
The sensor data will be passed to the second parameter. The distance data 
is saved in values[0].  
start_proximity_sensor() is a function that starts the proximity sensor and 
specifies the event callback function.  
sensor_get_ default_sensor(sensor_type_e, sensor_h *) is an API that returns 
the sensor object. Passing SENSOR_PROXIMITY to the first parameter 
returns the proximity sensor object to the second parameter.  
sensor_create_listener(sensor_h, sensor_listener_h *) is an API  that creates 
an event listener. Passing the sensor object to the first parameter returns 
the listener object to the second parameter.  
sensor_listener_set_event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callbac k function to the 
listener. The parameters listed in order are an event listener, time interval 
(in milliseconds), name of the callback function, and user data.  
sensor_listener_start(sensor_listener_h) is an API that starts the listener.  
We will make the e vent listener operate automatically when the app is run. 
Call the function above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
  
Page 693 / 978     show_is_supported(ad ); 
    start_proximity_sensor(ad);  
} 
└─────────────────────┘  
Run the example again. On a smartphone, simply bring the phone close 
to your face for testing. On an emulator, use the Control Panel.  
Right-click the emulator and select Control Panel from the sh ortcut menu.  
On the Control Panel, select [Event Injector > Proximity] from the list in 
tree structure on the left.  
Clicking the ON button on the right side of the screen on the Control 
Panel displays 0.0 on the second Label widget of the app screen.  Clicking 
the OFF button displays 5.0 on the Label widget.  
 
 
  

  
Page 694 / 978 3) Related APIs  
int  sensor_is_supported(sensor_type_e type, bool *supported):  an API 
that determines if a certain sensor is supported. Passing 
SENSOR_PROXIMITY to the first parameter m akes the second parameter 
return whether or not the proximity sensor is supported.  
int  sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor):  an 
API that returns the sensor object. Passing SENSOR_PROXIMITY to the first 
parameter returns the prox imity sensor object to the second parameter.  
int  sensor_create_listener(sensor_h sensor, sensor_listener_h *listener):  an 
API that creates an event listener. Passing the sensor object to the first 
parameter returns the listener object to the second parame ter. 
int  sensor_listener_set_event_cb(sensor_listener_h listener, unsigned int 
interval_ms, sensor_event_cb callback, void *data):  an API that specifies a 
callback function to the listener. / parameters: event listener, time interval 
(in milliseconds), na me of the callback function, and user data.  
int  sensor_listener_start(sensor_listener_h listener):  an API that starts the 
listener.  
  
  
Page 695 / 978 56. Using a GPS Sensor  
You need to know the geographic coordinates of locations to successfully 
use a map or navigation app. The coordinates are also essential for 
location -based services of SNS including Facebook and Twitter, as well as 
other informative apps. In this example, we will learn how to use a GPS 
sensor using Location Manager.  
 
1) Registering a Privilege  
Create a new  source project and specify the project name as 'SensorGps.' 
You need to have the applicable user privileges to use Location Manager. 
After the source project is created, open the tizen -manifest.xml file, and 
click Privileges among the tab buttons below. T hen, click the Add button 
in the upper right corner. When the popup  window appears, select 
http://tizen.org/privilege/location from the list, and click the OK button to 
close the window.  
  
Page 696 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" pa ckage="org. exam
ple.sensorgps" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .sensorgps" exec="sensorgps" multiple="false" 
nodisplay="false" taskmanage="true" type="capp">  
        <label>sensorgps</label>  
        <icon> sensorgps.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/location</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 697 / 978 2) Checking the Status of Location Manager  
Now, we need to determine if Location Manager is available.  Open the 
source file (~.c) under the src folder and add library header files and 
variables.  
┌─────────────────────┐  
#include "sensorgps.h"  
#include <locations.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Objec t *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
    location_manager_h manager;  
} appdata_s;  
└─────────────────────┘  
location.h is a library header file for Location Manager.  
We are going to display the status on label0, and location information on 
label1.  
location_manager_h is the Location Manager structure.  
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
state_changed_cb(location_service_state_e state, void *user_data)  
{ 
    appdata _s *ad = user_data;  
  
Page 698 / 978     char buf[100];  
    char *enable = (state == LOCATIONS_SERVICE_ENABLED) ? "Enable" : "Disable";  
    sprintf(buf, "State is %s", enable);  
    elm_object_text_set(ad ->label0, buf);  
} 
  
static void  
show_state(appdata_s *ad)  
{ 
    location_manager_create(LOCATIONS_METHOD_GPS, &ad ->manager);  
    location_manager_set_service_state_changed_cb(ad ->manager, state_changed_cb, a
d); 
    location_manager_start(ad ->manager);  
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
        double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(fr ame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
  
Page 699 / 978         /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
state_changed_cb() is an event callback function that changes the status 
of Location Manager. Now, the status values will be passed to the first 
parameter. The status types are as follows:  
 - LOCATIONS_SERVICE_DISABLED: Service is unavailable.  
 - LOCATIONS_SERVICE_ENABLED: Service is av ailable.  
show_state() is a function that requests an event to change the status.  
location_manager_create(location_method_e, location_manager_h*) is an 
API that creates the Location Manager object. Passing 
LOCATIONS_METHOD_GPS to the first parameter makes t he second 
parameter return the Location Manager object. The types of information 
collection for locations are as follows:  
 - LOCATIONS_METHOD_GPS : Uses GPS.  
 - LOCATIONS_METHOD_WPS : Uses Wi -Fi. 
 - LOCATIONS_METHOD_HYBRID : Automatically selects between G PS 
and Wi -Fi. 
location_manager_set_service_state_changed_cb(location_manager_h, 
location_service_state_changed_cb, void *) is an API that specifies the 
  
Page 700 / 978 name of the event function for Location Manager status change. The 
parameters listed in order are the Location Manager object, name of the 
event callback function, and user data.  
location_manager_start(location_manager_h) is an API that operates 
Location Manager.  
my_box_pack() is a function that adds a widget to a Box.  
We will make the Location Manager ope rate automatically when the app 
is run. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win _indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object  - indent to how relationship */  
        Evas_Object * box, *btn;  
 
        /* A box to put things in verticallly - default mode for box */  
        box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND) ; 
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
  
Page 701 / 978             /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Hello EFL");  
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    show_state(ad);  
} 
└─────────────────────┘  
Create a Box and Label widge t, and call the event request function to 
change the status of Location Manager.  
Build and run the example. If the Label widget displays 'State is Enable,' 
the GPS is working normally.  
 
 
3) Requesting Coordinates of the Current Location  
We will implement a feature that displays the coordinates of the current 
location on the screen when you tap the button. Add new code to the 
create_base_gui() function.  
┌─────────────────────┐  
        { /* child object - indent to how relationship */  

  
Page 702 / 978             /* Label -0 */ 
            ad->label0 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label0, "Hello EFL");  
            my_box_pack(box, ad ->label0, 1.0, 0.0, -1.0, 0.0);  
 
            /* Label -1 */ 
            ad->label1 = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label1, "Hello EFL");  
            my_box_pack(box, ad ->label1, 1.0, 0.0, -1.0, 0.0);  
 
            /* Button */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Get Location");  
            evas_object_smart_callback_add(btn, "clicked", btn_clicked_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, 0.0);  
        } 
    } 
└─────────────────────┘  
We added one Label widget and one Butt on widget.  
We are now going to create a button callback function. Add new code on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    double altitude, latitude, longitude, climb, direction, speed;  
    double horizontal, vertical;location_accuracy_level_e level;time_t timestamp;  
  
    location_manager_get_location(ad ->manager, &altitude, &latitude, &longitude,  
                                                &climb, &direction, &speed, &level, &horizontal, 
  
Page 703 / 978 &vertical, &timestamp);  
    char buf[100];  
    sprintf(buf, "%0.5f/%0.5f", latitude, longitude);  
    elm_object_text_set(ad ->label1, buf);  
} 
└─────────────────────┘  
location_manager_get_location(location_manager_h, double *, double *, 
double *, double *, double *, double *, location_accuracy_level_e *, double 
*, double*, time_t*) is an API that requests the information of the current 
location. The parameters listed in  order are the object of Location Manager, 
altitude, latitude, longitude, vertical movement speed, direction, horizontal 
movement speed, accuracy, horizontal accuracy (in meters), vertical 
accuracy (in meters), and time.  
The next code outputs the coordinat es of latitude and longitude on the 
second Label widget.  
Run the example again. Use the Control Panel to test it on the emulator. 
Right-click the emulator and select Control Panel from the shortcut menu.  
On the Control Panel, select [Event Injector > Locat ion] from the list in 
tree structure on the left. Then, input a latitude coordinate in Latitude on 
the right of the screen (e.g. 37.49819), and a longitude coordinate in 
Longitude (e.g. 127.02761). Input 500 for Altitude, and 100 for Horizontal 
Accuracy. T hen, click the Inject Location button. When you tap the button 
on the app screen, the coordinates of latitude and longitude that you 
entered from the Control Panel will be displayed in the second Label 
widget.  
  
Page 704 / 978  
 
4) Requesting a Location Movement Event  
We will show you how to make the new coordinates of latitude and 
longitude display automatically on the screen when the user's locations 
changes. Add a new line of code at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
    /* Show window a fter base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_state(ad);  
    location_manager_set_position_updated_cb(ad ->manager, position_updated_cb, 
2, ad);  
} 
└─────────────────────┘  

  
Page 705 / 978 location_manager_set_position_updated_cb(location_manager_h, 
location_position_updated_cb, int, void *) is an API that requests an event 
to change the location information. The parameters listed in order are the 
Location Manager object, name of the event callback function, time 
interval, and user data.  
Finally, we are  going to create a callback function. Add a new function on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void position_updated_cb(double latitude, double longitude, double altitude, ti
me_t timestamp, void *user_data)  
{ 
    appdata_ s *ad = user_data;  
    char buf[100];  
    sprintf(buf, "%0.5f/%0.5f - %ld", latitude, longitude, timestamp);  
    elm_object_text_set(ad ->label1, buf);  
} 
└─────────────────────┘  
position_updated_cb() is a callback function that is called when a new 
location  information is received. The parameters listed in order are 
latitudes, longitudes, altitudes, time, and user data.  
The coordinates of latitude and longitude, as well as the time are output 
on the screen within the function.  
Run the example again. Change t he values of latitude (e.g. 37.666) and 
longitude (e.g. 127.02761), and click the Inject Location button. The 
coordinates of latitude and longitude will automatically change on the app 
screen.  
  
Page 706 / 978  
 
5) Related APIs  
int  location_manager_create(location_method _e method, 
location_manager_h* manager):  an API that creates the Location 
Manager object. Passing LOCATIONS_METHOD_GPS to the first 
parameter makes the second parameter return the Location Manager 
object. The types of information collection for locations a re as follows:  
 - LOCATIONS_METHOD_GPS : Uses GPS.  
 - LOCATIONS_METHOD_WPS : Uses Wi -Fi. 
 - LOCATIONS_METHOD_HYBRID : Automatically selects between GPS 
and Wi -Fi. 

  
Page 707 / 978 int  location_manager_set_service_state_changed_cb(location_manager_h 
manager, location_servi ce_state_changed_cb callback, void *user_data):  an 
API that specifies the name of the event function to change the status of 
Location Manager. The parameters listed in order are the Location 
Manager object, name of the event callback function, and user dat a. 
int  location_manager_start(location_manager_h manager):  an API that 
operates Location Manager  
int  location_manager_get_location(location_manager_h manager, double 
*altitude, double *latitude, double *longitude, double *climb, double 
*direction, double  *speed, location_accuracy_level_e *level, double 
*horizontal, double *vertical, time_t *timestamp):  an API that requests the 
information of the current location. The parameters listed in order are the 
object of Location Manager, altitude, latitude, longit ude, vertical 
movement speed, direction, horizontal movement speed, accuracy, 
horizontal accuracy (in meters), vertical accuracy (in meters), and time.  
int  location_manager_set_position_updated_cb(location_manager_h 
manager, location_position_updated_cb c allback, int interval, void 
*user_data):  an API that requests the event of location information 
change. The parameters listed in order are the Location Manager object, 
name of the event callback function, time interval, and user data.  
  
  
Page 708 / 978 57. Google Map s Library  
You can use Google Maps for an electronic map. Pass the coordinates of 
latitude and longitude, as well as the values of the Zoom level to the 
Google Maps server, and then enter the map data received from the server 
to the canvas. Hard coding the example c an be rather time -consuming, so 
we will call the library file to implement it in an easier way.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as 'MapViewEx.' 
You need to have the applicable user privileges to communic ate with the 
Google Maps server. After the source project is created, open the tizen -
manifest.xml file, and click Privileges among the tab buttons below. Then, 
click the Add button in the upper right corner. When the popup  window 
appears, select http://tiz en.org/privilege/internet from the list, and click 
the OK button to close the window.  
  
Page 709 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the x ml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.mapviewex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .mapviewex" exec="mapviewex" multiple="false
" nodisplay="false" taskmanage="true" type="capp">  
        <label>mapviewex</label>  
        <icon>mapviewex.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/ privilege/internet</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 710 / 978 2) Copying Library Files  
Realizing the features of an electronic map through hard coding is rather 
time-consuming, so we will simply copy the library file for use. Copy th e 
MapView.h file in the /etc folder of the appendix to the /inc folder of the 
source project.  
Image files are also used in the map source code. Create a new folder 
under the /res folder of the source project and specify the folder's name 
as 'images.' Then,  copy two image files (NULL.PNG and white.PNG) from 
the /image folder of the appendix to the folder that you have just created.  
 
 
3) Creating a MapView Widget  
We have copied all library and image files we need. We are now going to 
create a MapView widget  using the source code. Open the source file (~.c) 
under the /src folder and add the library and the coordinates of latitude 
and longitude.  
┌─────────────────────┐  
#include "mapviewex.h"  

  
Page 711 / 978 #include "MapView.h"  
  
#define START_LATITUDE 40.779986  
#define START _LONGITUDE -73.9615488  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
└─────────────────────┘  
MapView.h is a MapView library file that we have just copied from the 
appendix.  
START_LATITUDE and START_LONGITUDE are the coordinates of latitude 
and longitude for Central Park in Manhattan, New York City. You can 
choose any coordinates you wish.  
Add new code to the create_base_gui() function. Annotate the Label 
widget.  
┌─────────────────────┐  
    /* Label*/  
    /*ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, "Hello EFL");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_object_content_set(ad ->conform, ad ->label);  
    evas_obje ct_show(ad ->label);*/  
  
    create_map(ad ->conform, START_LATITUDE, START_LONGITUDE);  
  
  
Page 712 / 978     /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
create_map(Evas_Object *, double, double) is a function that creat es a 
MapView widget. The parameters listed in order are a container, and the 
coordinates of latitude and longitude.  
Build and run the example. If you have any errors while building the 
example, open the /inc/MapView.h file, and correct the #include 
<curl/c url.h> code as follows:  
#include <curl.h>  
The electronic map is displayed, and you will see two buttons. When you 
tap the '+' button, the map will be zoomed in, while tapping the ' -' button 
will zoom out the map. You can also drag the map in any direction you 
want. 
   

  
Page 713 / 978  
 
4) Source Code of MapView Widget  
Now, we will learn about the source code used in the MapView library. 
Open the MapView.h file that you copied to the /inc folder, and scroll to 
the bottom. At the end of create_map(), you will find the code as follows.  
int  mkdir(char *__path, __mode_t __mode): an API that creates a new 
folder.  
make_new_url() is a function that creates a URL path that requests map 
data to the Google Maps server using the coordinates of latitude and 
longitude. The created  URL address will be saved in global variables such 
as place_api_url or curr_url.  
arrange_start_main_page() is a function that passes the coordinates of 
latitude and longitude to the Google Map server.  

  
Page 714 / 978 map_dload_thread() is an event function for the map da ta download 
thread.  
save_map_temp_file() is a function that saves map data received from the 
server as a file.  
update_main_page() is a function that saves map data into a tile, and 
changes the location and size of the tile.  
mouse_down_cb() is a function th at handles the event when the user Touch 
Downs the map tile.  
mouse_move_cb()  is a function that handles the event when the user Touch 
Moves the map tile.  
mouse_up_cb()  is a function that handles the event when the user Touch 
Cancels the map tile.  
map_zoom_ in() is a callback function for the '+' button. It increases the 
Zoom level, and changes the center coordinate. Then, it calls the 
arrange_start_main_page() function.  
map_zoom_out() is a callback function for the ' -' button. It decreases the 
Zoom level, an d changes the center coordinate. Then, it calls the 
arrange_start_main_page() function.  
 
  
  
Page 715 / 978 5) Source Code of MapView.h  
If you cannot download the appendix file, create a text file and name the 
file as 'MapView.h.' Then, copy the code below.  
Among the defi ne statement, for <Google Map Key> at the end of 
START_URL and PLACE_API_URL, enter the Google Maps key that you own.  
┌─────────────────────┐  
/* 
 * MapView.h  
 * 
 *  Created on: Apr 29, 2015  
 *      Author: 김시찬  Samsung Electronics co  
 */ 
  
#ifndef MAPVIEW_H_  
#define MAPVIEW_H_  
  
#include <app.h>  
#include <Evas_GL.h>  
#include <Evas_GL_GLES2_Helpers.h>  
#include <Elementary.h>  
#include <system_settings.h>  
#include <efl_extension.h>  
#include <dlog.h>  
#include <curl/curl.h>  
#include <math.h>  
#include <dl og.h>  
#include <locations.h>  
  
#define TMP_DIR "/tmp/map_temp"  
#define START_URL "http://maps.googleapis.com/maps/api/staticmap?language=korean
  
Page 716 / 978 &zoom=99&center=unknown&size=480x800&key=<Google Map Key>"  
#define PLACE_API_URL "https://maps.googleapis.com/map s/api/place/textsearch/xml?
query=where&sensor=true&key=<Google Map Key>"  
  
#define MAX_TMP_FILENAME_LEN 256  
#define MAX_URL_LEN 2048  
#define MAP_TILE_X 3  
#define MAP_TILE_Y 3  
#define MAX_ZOOM_SCALE 19  
#define MIN_ZOOM_SCALE 0  
#define START_ZOOM_LEVEL 13  
#define X_RESOLUTION 480  
#define Y_RESOLUTION 800  
#define ALL_TILE_USABLE_X 1000  
#define ALL_TILE_USABLE_Y 1000  
#define GEO_INFO_STR_NUM 20  
#define MAP_DLOAD_Q_NUM 500  
#define PLACE_SEARCHED_NUM 100  
#define PLACE_INFO_MAX (100*1000)  
  
typedef struct mapdat a { 
    float            xangle;  
    float            yangle;  
    Eina_Bool        mouse_down : 1;  
    Eina_Bool        mouse_move : 1;  
    Eina_Bool        mouse_move_update : 1;  
    Eina_Bool        wait_for_update : 1;  
    Ecore_Thread*    thread;  
} map data_s;  
  
typedef struct all_tile_info {  
    double lati_of_center;  
    double longti_of_center;  
    char download_ok;  
  
Page 717 / 978     char download_request;  
    char file_name[MAX_TMP_FILENAME_LEN];  
}all_tile_info_s;  
  
typedef struct index_of_all_tile {  
    int x; 
    int y; 
}index_of_all_tile_s;  
  
typedef struct certer_tile_info {  
    int x_info;  
    int y_info;  
}certer_tile_info_s;  
  
typedef struct map_dload_queue {  
    char url[MAX_URL_LEN];  
    char filename[MAX_TMP_FILENAME_LEN];  
    index_of_all_tile_s index;  
}map_dload_queue_s;  
  
typedef struct place_search_list {  
    double str_lati;  
    double str_longti;  
} place_search_list_s;  
  
typedef struct tile_info {  
    int curr_x;  
    int curr_y;  
    char file_name[MAX_TMP_FILENAME_LEN];  
}tile_info_s;  
  
typedef struc t MemoryStruct {  
    char *memory;  
    size_t size;  
  
Page 718 / 978 } MemoryStruct_s;  
  
enum 
{ 
    URL_CHANGED,  
    URL_NOT_CHANGED,  
}new_url_result;  
  
enum 
{ 
    ZOOM_CHANGED,  
    CENTER_NAME_CHANGED,  
    CENTER_GEOMETRY_CHANGED,  
    ADD_NEW_MARKER,  
    ADD_NEW_MULTI_MARKER,  
    DELITE_MARKER,  
    PLACE_INFO,  
    MAX_REASON  
}new_url_reason;  
  
const tile_info_s tile_info_init_information[MAP_TILE_X][MAP_TILE_Y] = {  
        {{-X_RESOLUTION,Y_RESOLUTION}, { -X_RESOLUTION,0}, { -X_RESOLUTION, -Y_RESO
LUTION}} , 
        {{0,Y_RESOLUTION}, {0,0}, {0, -Y_RESOLUTION}},  
        {{X_RESOLUTION,Y_RESOLUTION}, {X_RESOLUTION,0}, {X_RESOLUTION, -Y_RESOLU
TION}}  
        }; 
tile_info_s tile_info[MAP_TILE_X][MAP_TILE_Y];  
  
//appdata_s *ad_g;  
mapdata_s *m_md;  
Evas *m_canvas;  
Evas_Object* main_page[MAP_TILE_X][MAP_TILE_Y];  
Evas_Object *m_btn1;  
  
Page 719 / 978 Evas_Object *m_btn2;  
  
int map_dload_q_idx = 0;  
char do_not_update_map = 0;  
map_dload_queue_s map_dload_q[MAP_DLOAD_Q_NUM];  
all_tile_info_s all_tiles[ALL_TILE_USABLE_X][ALL_TILE_USABLE_Y] ; 
char place_api_url[MAX_URL_LEN] = PLACE_API_URL;  
char curr_url[MAX_URL_LEN] = START_URL;  
char search_str[MAX_REASON][20]={"zoom=", "center=", "center=", "&", "&", "&marke
rs=", "query="};  
int place_searched_num;  
place_search_list_s place_search_list[PLACE _SEARCHED_NUM];  
location_manager_h  l_manager;  
int location_initialized = 0;  
double map_start_lati_of_center = 37.259606;  
double map_start_longti_of_center = 127.045828;  
double x_moved = 0;  
double y_moved = 0;  
Ecore_Timer * get_geometry_timer = NULL;  
static char temp_place_info[PLACE_INFO_MAX];  
  
Eina_Lock      set_info_mutex;  
extern int map_dload_q_idx;  
int current_zoom_level = START_ZOOM_LEVEL;  
certer_tile_info_s current_center;  
double curr_user_lati;  
double curr_user_longti;  
char m_icon_path[100];  
  
void update_main_page(void);  
Eina_Bool get_changed_location(void *data);  
  
double next_lati_value(double curr_lati, int diff, int curr_zoom)  
{ 
  
Page 720 / 978     double lat;  
  
    int y1 = floor((1.0 - log(tan(curr_lati * ELM_PI / 180.0) +  
                               (1.0 / cos(curr_lati * ELM_PI / 180.0)))  
                     / ELM_PI) / 2.0 * (Y_RESOLUTION*pow(2, curr_zoom)));  
  
    double n = ELM_PI - (2.0 * ELM_PI * (y1+2.5*diff) / (Y_RESOLUTION*pow(2, curr_
zoom)));  
    lat = 180.0 / ELM_PI *atan(0.5 * (exp(n) - exp(-n))); 
  
    return lat;  
} 
  
double next_longti_value(double curr_longti, int diff, int curr_zoom)  
{ 
    double lon;  
  
    int x1 = floor((curr_longti + 180.0) / 360.0 * (X_RESOLUTION*pow(2, curr_zoom)));  
  
    lon = ((x1+1.875*diff) / ((double)X_RESOLUTION *pow(2, curr_zoom)) * 360.0) - 18
0; 
  
    return lon;  
} 
  
double latitude_of_polar(int polar)// polar=1 : Arctic, polar= -1 : Antarctic  
{ 
    double n, y, lat;  
  
    if(polar==1)  
        y = 0;  
    else 
        y = Y_RESOLUTION;  
    n = ELM_PI - (2.0 * ELM_PI * y / Y_RESOLUTION);  
  
Page 721 / 978     lat = 180.0 / ELM_PI *atan(0.5 * (exp(n) - exp(-n))); 
    return lat;  
} 
  
void delete_all_marker_from_url(char* url)  
{ 
    char tmp_url_1[MAX_URL_LEN]={0,}, tmp_url_2[MAX_URL_LEN]={0,};  
    char* next_pos = NULL;  
    char* p os_and_oper = NULL;  
  
    next_pos = strstr(url, "&markers=");  
  
    while(next_pos!=NULL)  
    { 
        pos_and_oper = strstr((next_pos+1), "&");  
        memset(tmp_url_1, 0, MAX_URL_LEN);  
        memcpy(tmp_url_1, url, (next_pos -url)); 
        memset(tmp _url_2, 0, MAX_URL_LEN);  
        memcpy(tmp_url_2, pos_and_oper, strlen(url) -(pos_and_oper -url)); 
        memset(url, 0, MAX_URL_LEN);  
        snprintf(url, MAX_URL_LEN, "%s%s", tmp_url_1, tmp_url_2);  
        next_pos = strstr(url, "&markers=");  
    } 
} 
  
int make_new_url(int reason, int zoom, void* data, double x_changed, double y_chan
ged) 
{ 
    char prev[MAX_URL_LEN]={0,}, new_url[MAX_URL_LEN]={0,}, tmp_str_changed[MAX_
URL_LEN]={0,}, tmp_str_changed_1[MAX_URL_LEN]={0,}, tmp_str_end[MAX_URL_LEN]=
{0,}; 
    char *url_handle;  
    char str_lati[GEO_INFO_STR_NUM]={0,}, str_longi[GEO_INFO_STR_NUM]={0,};  
    char* pos = NULL;  
  
Page 722 / 978     char* pos_and_oper = NULL;  
    char* pos_comma = NULL;  
    double   latitude, longitude;  
  
    if(reason == PLACE_INFO)  
    { 
        url_handle = place_api_url;  
    } 
    else 
    { 
        url_handle = curr_url;  
    } 
    memcpy(prev, url_handle, strlen(url_handle));  
  
    pos = strstr(prev, search_str[reason]);  
  
    if(pos == NULL)  
    { 
        return URL_NOT_CHANGED;  
    } 
  
    pos_and_oper = strstr(pos, "&"); // to search first '&' from after "zoom=..."  
  
    if(pos_and_oper == NULL)  
    { 
        return URL_NOT_CHANGED;  
    } 
  
    memcpy(tmp_str_end, pos_and_oper, strlen(prev) - ((int)pos_and_oper -(int)prev));  
  
    switch  (reason)  
    { 
        case ZOOM_CHANGED:  
        { 
  
Page 723 / 978             if(zoom>0)  
            { 
                if(current_zoom_level<MAX_ZOOM_SCALE) current_zoom_level++;  
                else return URL_NOT_CHANGED;  
            } 
            else if(zoom<0)  
            { 
                if(current_zoom_level>MIN_ZOOM_SCALE) current_zoom_level --; 
                else return URL_NOT_CHANGED;  
            } 
            snprintf(tmp_str_changed, sizeof(tmp_str_changed), "zoom=%d", current_zoo
m_level);  
        } 
        break;  
  
        case CENTER_NAME_CHANGED:  
        { 
            snprintf(tmp_str_changed, sizeof(tmp_str_changed), "center=%s", (char*)data);  
        } 
        break;  
  
        case CENTER_GEOMETRY_CHANGED:  
        { 
            pos_comma = strstr (pos, ","); // to search first ',' from after "center=..."  
  
            memcpy(str_lati, (char*)((int)pos+strlen("center=")), (int)pos_comma - ((int)pos
+strlen("center=")));  
            memcpy(str_longi, (char*)((int)pos_comma+1), ((int)pos_and_oper -((int)pos_co
mma+1)) );  
            latitude = atof(str_lati);  
            longitude = atof(str_longi);  
  
            if(latitude>90) latitude=90;  
            if(latitude< -90) latitude= -90; 
  
Page 724 / 978   
            if(longitude>180) longitude=( -1)*(360 -longitude);  
            if(longitude< -180) longitude=(longitude+360);  
  
            snprintf(tmp_str_changed, sizeof(tmp_str_changed), "center=%f,%f", latitude, l
ongitude);  
        } 
        break;  
  
        case ADD_NEW_MARKER:  
        { 
            char tmp_char = '%';  
            snprintf(tmp_str_changed, sizeof(tmp_str_changed), "&markers=color:blue%c7
Clabel:U%c7C%f,%f", tmp_char, tmp_char, y_changed, x_changed);  
        } 
        break;  
  
        case ADD_NEW_MULTI_MARKER:  
        { 
            char tmp_char = '%';  
            int i = place_searched_num;  
  
            while(i --) 
            { 
                snprintf(tmp_str_changed_1, sizeof(tmp_str_changed_1), "%s&markers=colo
r:red%c7Clabel:S%c7C%f,%f", tmp_str_changed, tmp_char, tmp_char, place_search_list[i].
str_lati, place_search_list[i].str_longti);  
                snprintf(tmp_str_changed, sizeof(tmp_str_changed), "%s", tmp_str_changed
_1); 
            } 
        } 
        break;  
  
        case DELITE_MARKER:  
  
Page 725 / 978         { 
            //do not process tmp_str_changed b ecause we just need to set tmp_str_ch
anged=""  
            delete_all_marker_from_url(tmp_str_end);// remove all "&markers.." from tmp_
str_end  
        } 
        break;  
  
        case PLACE_INFO:  
        { 
            snprintf(tmp_str_changed, sizeof(tmp_str _changed), "query=%s", (char*)data);  
        } 
        break;  
  
        default :  
            break;  
    } 
  
    memcpy(&new_url[0], prev, ((int)pos -(int)prev));  
    memcpy(&new_url[((int)pos -(int)prev)], tmp_str_changed, strlen(tmp_str_changed));  
    memcpy(&new_url[((int)pos -(int)prev)+strlen(tmp_str_changed)], tmp_str_end, strlen(t
mp_str_end));  
  
    memset(url_handle, 0, MAX_URL_LEN);  
    memcpy(url_handle, new_url, strlen(new_url));  
  
    return URL_CHANGED;  
} 
  
void request_map_download(int x_ info, int y_info, double latitude, double longitude)  
{ 
    char buf[100];  
  
    if(all_tiles[x_info][y_info].download_request)  
  
Page 726 / 978         return;  
  
    all_tiles[x_info][y_info].download_request = 1;  
  
    memset(all_tiles[x_info][y_info].file_name, 0, MAX_TM P_FILENAME_LEN);  
  
    if(longitude>200 || longitude< -200 || latitude<latitude_of_polar( -1) || latitude>latitu
de_of_polar(1))  
    { 
        snprintf(all_tiles[x_info][y_info].file_name, sizeof(all_tiles[x_info][y_info].file_name), 
"%s/white.PNG", m_icon_path);  
        return;  
    } 
  
    all_tiles[x_info][y_info].lati_of_center = latitude;  
    all_tiles[x_info][y_info].longti_of_center = longitude;  
    snprintf(all_tiles[x_info][y_info].file_name, sizeof(all_tiles[x_info][y_info].file_name), "%s
/%d_%f,%f.PNG", TMP_DIR, current_zoom_level, latitude, longitude);  
  
    memset(buf, 0, 100);  
    snprintf(buf, sizeof(buf), "%f,%f", latitude, longitude);  
  
    make_new_url(CENTER_NAME_CHANGED, 0, buf, 0, 0);  
  
    eina_lock_take(&set_info_mutex);  
    memse t(&map_dload_q[map_dload_q_idx].url[0], 0, MAX_URL_LEN);  
    memcpy(&map_dload_q[map_dload_q_idx].url[0], curr_url, MAX_URL_LEN);  
    memset(&map_dload_q[map_dload_q_idx].filename[0], 0, MAX_TMP_FILENAME_LEN);  
    memcpy(&map_dload_q[map_dload_q_idx].filen ame[0], all_tiles[x_info][y_info].file_na
me, MAX_TMP_FILENAME_LEN);  
    map_dload_q[map_dload_q_idx].index.x = x_info;  
    map_dload_q[map_dload_q_idx].index.y = y_info;  
    map_dload_q_idx++;  
    eina_lock_release(&set_info_mutex);  
  
Page 727 / 978 } 
  
int save_map_temp_f ile(char* url, char* file_name)  
{ 
    CURL *curl_handle;  
    FILE *currfile;  
    int ret_val=0;  
  
    curl_global_init(CURL_GLOBAL_ALL);  
  
    /* init the curl session */  
    curl_handle = curl_easy_init();  
  
    /* set URL to get */  
    curl_easy_setopt(curl_handle, CURLOPT_URL, url);  
  
    /* no progress meter please */  
    curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);  
  
    /* open the files */  
    currfile = fopen(file_name,"w");  
    if (currfile == NULL) {  
        curl_easy_cleanup(curl_handle);  
        return -1; 
    } 
  
    /* we want the headers to this file handle */  
    curl_easy_setopt(curl_handle,   CURLOPT_WRITEDATA, currfile);  
  
    /* 
     *    * Notice here that if you want the actual data sent anywhere else  but 
     *       * stdout, you should consider using the CURLOPT_WRITEDATA option.  */ 
  
    /* get it! */  
  
Page 728 / 978     ret_val = curl_easy_perform(curl_handle);  
  
    /* close the header file */  
    fclose(currfile);  
  
    /* cleanup curl stuff */  
    curl_easy_cleanup(curl_handle);  
  
    return ret_val;  
} 
  
int map_download(char* tmp_url, char* tmp_filename)  
{ 
    if(save_map_temp_file(tmp_url, tmp_filename) != 0)  
    { 
        return 0;//fail  
    } 
  
    return 1;//success  
} 
  
void set_map_main_ti le_info(int current_center_x, int current_center_y)  
{ 
    for(int i=0; i<MAP_TILE_X ; i++)  
    { 
        for(int j=0; j<MAP_TILE_Y ; j++)  
        { 
            memset(tile_info[i][j].file_name, 0, MAX_TMP_FILENAME_LEN);  
  
            if(all_tiles[current_c enter_x -(1-i)][current_center_y -(1-j)].download_ok)  
            { 
                memcpy(tile_info[i][j].file_name, all_tiles[current_center_x -(1-i)][current_cente
r_y-(1-j)].file_name,  
                    strlen(all_tiles[current_center_x -(1-i)][current_center_y -(1-j)].file_name));  
  
Page 729 / 978             } 
            else 
            { 
                snprintf(tile_info[i][j].file_name, sizeof(tile_info[i][j].file_name), "%s/NULL.PN
G", m_icon_path ); 
            } 
        } 
    } 
    current_center.x_info = current_center_x;  
    current_center.y_info = current_center_y;  
} 
  
void mouse_move_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)  
{ 
    Evas_Event_Mouse_Move *ev;  
    ev = (Evas_E vent_Mouse_Move *)event_info;  
    //appdata_s *ad = data;  
    mapdata_s *md = data;  
  
    if(md->mouse_down == EINA_TRUE)  
    { 
        if((ev->cur.canvas.x != ev ->prev.canvas.x) || (ev ->cur.canvas.y != ev ->prev.canvas.
y)) 
        { 
            ecore_timer _del(get_geometry_timer);  
        } 
  
        // x point check  
        if(ev->cur.canvas.x > ev ->prev.canvas.x) //x++  
        { 
            if(tile_info[1][1].curr_x > 0)  
            { 
                for(int j=0 ; j<MAP_TILE_Y ; j++)  
                { 
  
Page 730 / 978                     if(! all_tiles[current_center.x_info -2][current_center.y_info+(1 -j)].download_
request)  
                    { 
                        double lati_of_center = all_tiles[current_center.x_info][current_center.y
_info].lati_of_center;  
                        double longti_of_center = all_tiles[current_center.x_info][current_cent
er.y_info].longti_of_center;  
                        double longti_for_end_check;  
  
                        lati_of_center = next_lati_value(lati_of_center, Y_RESOLUTIO N*(j-1), c
urrent_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION
*(-1), current_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION
*(-1), current_z oom_level);  
  
                        request_map_download(current_center.x_info -2, current_center.y_info+
(1-j), lati_of_center, longti_of_center);  
                    } 
                } 
            } 
  
            for(int i=0; i<MAP_TILE_X ; i++)  
            { 
                for(int j=0; j<MAP_TILE_Y ; j++)  
                { 
                    tile_info[i][j].curr_x = tile_info[i][j].curr_x+(ev ->cur.canvas.x - ev->prev.ca
nvas.x);  
                    evas_object_move(main_page[i][j], tile_info[i][j].curr _x, tile_info[i][j].curr_
y); 
                } 
            } 
            x_moved = x_moved + (ev ->cur.canvas.x - ev->prev.canvas.x);  
  
  
Page 731 / 978             if(tile_info[1][1].curr_x > X_RESOLUTION)  
            { 
                set_map_main_tile_info(current_center.x_info -1, current_center.y_info);  
                update_main_page();  
  
                for(int i=0; i<MAP_TILE_X ; i++)  
                { 
                    for(int j=0; j<MAP_TILE_Y ; j++)  
                    { 
                        evas_object_move(main_page[i][j], tile_info[i][j].curr_x -X_RESOLUTION,
 tile_info[i][j].curr_y);  
                        tile_info[i][j].curr_x = tile_info[i][j].curr_x -X_RESOLUTION;  
                    } 
                } 
            } 
        } 
        else if(ev ->cur.canvas.x < ev ->prev.canvas.x) //x -- 
        { 
            if(tile_info[1][1].curr_x < 0)  
            { 
                for(int j=0 ; j<MAP_TILE_Y ; j++)  
                { 
                    if(! all_tiles[ current_center.x_info+2][current_center.y_info+(1 -j)].download
_request)  
                    { 
                        double lati_of_center = all_tiles[current_center.x_info][current_center.y
_info].lati_of_center;  
                        double longti_of_c enter = all_tiles[current_center.x_info][current_cent
er.y_info].longti_of_center;  
                        double longti_for_end_check;  
  
                        lati_of_center = next_lati_value(lati_of_center, Y_RESOLUTION*(j -1), c
urrent_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION,
  
Page 732 / 978  current_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION,
 current_zoom_level);  
  
                        request_map_download(current_center.x_info+2, current_center.y_info
+(1-j), lati_of_center, longti_of_center);  
                    } 
                } 
            } 
  
            for(int i=0; i<MAP_TILE_X ; i++)  
            { 
                for(int j=0; j<MA P_TILE_Y ; j++)  
                { 
                    tile_info[i][j].curr_x = tile_info[i][j].curr_x+(ev ->cur.canvas.x - ev->prev.ca
nvas.x);  
                    evas_object_move(main_page[i][j], tile_info[i][j].curr_x, tile_info[i][j].curr_
y); 
                } 
            } 
            x_moved = x_moved + (ev ->cur.canvas.x - ev->prev.canvas.x);  
  
            if(tile_info[1][1].curr_x < -(X_RESOLUTION -80)) 
            { 
                set_map_main_tile_info(current_center.x_info+1, current_center.y_info);  
                update_main_page();  
  
                for(int i=0; i<MAP_TILE_X ; i++)  
                { 
                    for(int j=0; j<MAP_TILE_Y ; j++)  
                    { 
                        evas_object_move(main_page[i][j], tile_info[i][j].c urr_x+X_RESOLUTIO
N, tile_info[i][j].curr_y);  
                        tile_info[i][j].curr_x = tile_info[i][j].curr_x+X_RESOLUTION;  
  
Page 733 / 978                     } 
                } 
            } 
        } 
  
        // y point check  
        if(ev->cur.canvas.y > ev ->prev.canvas.y) // y++  
        { 
            if(tile_info[1][1].curr_y > 0)  
            { 
                for(int i=0 ; i<MAP_TILE_Y ; i++)  
                { 
                    if(! all_tiles[current_center.x_info -(1-i)][current_center.y_info+2].download_
request)  
                    { 
                        double lati_of_center = all_tiles[current_center.x_info][current_center.y
_info].lati_of_center;  
                        double longti_of_center = all_tiles[current_center.x_info][current_cent
er.y_info]. longti_of_center;  
  
                        lati_of_center = next_lati_value(lati_of_center, Y_RESOLUTION*( -1), cu
rrent_zoom_level);  
                        lati_of_center = next_lati_value(lati_of_center, Y_RESOLUTION*( -1), cu
rrent_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION
*(i-1), current_zoom_level);  
  
                        request_map_download(current_center.x_info -(1-i), current_center.y_inf
o+2, lati_of_center, longti_of_center);  
                    } 
                } 
            } 
  
            for(int i=0; i<MAP_TILE_X ; i++)  
  
Page 734 / 978             { 
                for(int j=0; j<MAP_TILE_Y ; j++)  
                { 
                    tile_info[i][j].curr_y = tile_info[i][j].curr_y+(ev ->cur.canvas.y - ev->prev.c
anvas.y);  
                    evas_object_move(main_page[i][j], tile_info[i][j].curr_x, tile_info[i][j].curr_
y); 
                } 
            } 
            y_moved = y_moved + (ev ->cur.canvas.y - ev->prev.canvas.y);  
  
            if(tile_info[1][1].curr_y > Y_RESOLUTION)  
            { 
                set_map_main_tile_info(current_center.x_info, current_center.y_info+1);  
                update_main_page();  
  
                for(int i=0; i<MAP_TILE_X ; i++)  
                { 
                    for(int j=0; j<MAP_TILE_Y ; j++)  
                    { 
                        evas_object_move(main_page[i][j], tile_info[i][j].curr_x, tile_info[i][j].cur
r_y-Y_RESOLUTION);  
                        tile_info[i][j].curr_y = tile_info[i][j].cur r_y-Y_RESOLUTION;  
                    } 
                } 
            } 
        } 
        else if(ev ->cur.canvas.y < ev ->prev.canvas.y) // y -- 
        { 
            if(tile_info[1][1].curr_y < 0)  
            { 
                for(int i=0 ; i<MAP_TILE_Y ; i ++) 
                { 
                    if(! all_tiles[current_center.x_info -(1-i)][current_center.y_info -2].download_r
  
Page 735 / 978 equest)  
                    { 
                        double lati_of_center = all_tiles[current_center.x_info][current_center.y
_info].lati_of_center;  
                        double longti_of_center = all_tiles[current_center.x_info][current_cent
er.y_info].longti_of_center;  
  
                        lati_of_center = next_lati_value(l ati_of_center, Y_RESOLUTION, curren
t_zoom_level);  
                        lati_of_center = next_lati_value(lati_of_center, Y_RESOLUTION, curren
t_zoom_level);  
                        longti_of_center = next_longti_value(longti_of_center, X_RESOLUTION
*(i-1), current_zoom_level);  
  
                        request_map_download(current_center.x_info -(1-i), current_center.y_inf
o-2, lati_of_center, longti_of_center);  
                    } 
                } 
            } 
  
            for(int i=0; i<MAP_TILE_X ; i+ +) 
            { 
                for(int j=0; j<MAP_TILE_Y ; j++)  
                { 
                    tile_info[i][j].curr_y = tile_info[i][j].curr_y+(ev ->cur.canvas.y - ev->prev.c
anvas.y);  
                    evas_object_move(main_page[i][j], tile_info[ i][j].curr_x, tile_info[i][j].curr_
y); 
                } 
            } 
            y_moved = y_moved + (ev ->cur.canvas.y - ev->prev.canvas.y);  
  
            if(tile_info[1][1].curr_y < -(Y_RESOLUTION -200)) 
            { 
  
Page 736 / 978                 set_map_main_tile_in fo(current_center.x_info, current_center.y_info -1); 
                update_main_page();  
  
                for(int i=0; i<MAP_TILE_X ; i++)  
                { 
                    for(int j=0; j<MAP_TILE_Y ; j++)  
                    { 
                        evas_object_move(main_page[i][j], tile_info[i][j].curr_x, tile_info[i][j].cur
r_y+Y_RESOLUTION);  
                        tile_info[i][j].curr_y = tile_info[i][j].curr_y+Y_RESOLUTION;  
                    } 
                } 
            } 
        } 
    } 
} 
  
void mouse_up_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)  
{ 
    Evas_Event_Mouse_Move *ev;  
    ev = (Evas_Event_Mouse_Move *)event_info;  
  
    //appdata_s *ad = data;  
    mapdata_s *md = data;  
    md->mouse_down = EINA_FALSE;  
} 
  
void mouse_down_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)  
{ 
    Evas_Event_Mouse_Move *ev;  
    ev = (Evas_Event_Mouse_Move *)event_info;  
  
    //appdata_s *ad = data;  
    mapdata_s *md = data;  
  
Page 737 / 978     md->mouse_down = EINA_TRUE;  
} 
  
void update_main_page(void)  
{ 
    for(int i=0; i<MAP_TILE_X ; i++)  
    { 
        for(int j=0; j<MAP_TILE_Y ; j++)  
        { 
            if(main_page[i][j] != NULL)  
            { 
                evas_object_del(main_page[i][j]);  
                main_page[i][j] = NULL;  
            } 
  
            main_page[i][j] = evas_object_image_filled_add(m_canvas);  
  
            evas_object_image_file_set(main_page[i][j], tile_info[i][j].file_name, NULL);  
            evas_object_move(main_page[i][j], tile_ info[i][j].curr_x, tile_info[i][j].curr_y);  
            evas_object_resize(main_page[i][j], X_RESOLUTION, Y_RESOLUTION);  
            evas_object_show(main_page[i][j]);  
            evas_object_raise (m_btn1);  
            evas_object_raise (m_btn2);  
  
            evas_object_event_callback_add(main_page[i][j], EVAS_CALLBACK_MOUSE_MOV
E, mouse_move_cb, m_md);  
            evas_object_event_callback_add(main_page[i][j], EVAS_CALLBACK_MOUSE_DO
WN, mouse_down_cb, m_md);  
            evas_object_event_callback_add(mai n_page[i][j], EVAS_CALLBACK_MOUSE_UP, 
mouse_up_cb, m_md);  
        } 
    } 
} 
  
  
Page 738 / 978 void map_dload_thread(void *data, Ecore_Thread *thread)  
{ 
    int dload_success=0;  
  
   while (1)  
   { 
       while(map_dload_q_idx && !do_not_update_map)  
       { 
           char dload_url[MAX_URL_LEN] = {0,};  
           char dload_filename[MAX_TMP_FILENAME_LEN] = {0,};  
           index_of_all_tile_s index;  
  
           eina_lock_take(&set_info_mutex);  
           map_dload_q_idx --; 
           memcpy(dload_url, &map_dload_q[m ap_dload_q_idx].url[0], MAX_URL_LEN);  
           memcpy(dload_filename, &map_dload_q[map_dload_q_idx].filename[0], MAX_T
MP_FILENAME_LEN);  
           index.x = map_dload_q[map_dload_q_idx].index.x;  
           index.y = map_dload_q[map_dload_q_idx].index.y;  
           eina_lock_release(&set_info_mutex);  
  
           dload_success = 0;  
           do 
           { 
               dload_success = map_download(dload_url, dload_filename);  
           } while(dload_success==0);  
  
           all_tiles[index.x][index.y] .download_ok = 1;  
           set_map_main_tile_info(current_center.x_info, current_center.y_info);  
           update_main_page();  
  
           //ecore_thread_feedback(thread, &index);  
       } 
   } 
  
Page 739 / 978 } 
  
void  thread_feedback(void *data, Ecore_Thread *thread, void *msg_data)  
{ 
    //TODO  
} 
  
void  thread_end(void *data, Ecore_Thread *thread)  
{ 
    //TODO  
} 
  
void  thread_cancel(void *data, Ecore_Thread *thread)  
{ 
    //TODO  
} 
  
void loc_state_changed_cb(location_service_state_e state, void *user_data)  
{ 
    if(state == LOCATIONS_SERVICE_ENABLED)  
        location_initialized = 1;  
} 
  
int make_start_url(double lati, double longti)  
{ 
    char buf[GEO_INFO_STR_NUM];  
    map_start_lati_of_center = lati;  
    map_start_longti_of_center = longti;  
  
    if(make_new_url(ZOOM_CHANGED, 0, NULL, 0, 0) != URL_CHANGED)  
        return URL_NOT_CHANGED;  
  
    memset(buf, 0, GEO_INFO_STR_NUM);  
    snprintf(buf, sizeof(buf), "%f,%f", map_start_lati_of_center, map_start_longti_of_cente
  
Page 740 / 978 r); 
    if(make_new_url(CENT ER_NAME_CHANGED, 0, buf, 0, 0) != URL_CHANGED)  
        return URL_NOT_CHANGED;  
  
    return URL_CHANGED;  
} 
  
void arrange_start_main_page(void)  
{ 
    map_dload_q_idx = 0;  
    do_not_update_map = 1;  
  
    x_moved = 0;  
    y_moved = 0;  
  
    current_center.x _info = ALL_TILE_USABLE_X/2;  
    current_center.y_info = ALL_TILE_USABLE_Y/2;  
  
    for(int i=0; i<ALL_TILE_USABLE_X ; i++)  
    { 
        for(int j=0; j<ALL_TILE_USABLE_Y ; j++)  
        { 
            all_tiles[i][j].download_ok = 0;  
            all_tiles[i][j].download_request = 0;  
            memset(all_tiles[i][j].file_name, 0, MAX_TMP_FILENAME_LEN);  
        } 
    } 
  
    for(int i=0; i<MAP_TILE_X ; i++)  
    { 
        for(int j=0; j<MAP_TILE_Y ; j++)  
        { 
            tile_info[ i][j].curr_x = tile_info_init_information[i][j].curr_x;  
            tile_info[i][j].curr_y = tile_info_init_information[i][j].curr_y;  
  
Page 741 / 978   
            if(i==1 && j==1) continue;  
            request_map_download(current_center.x_info -(1-i), current_center.y_in fo-(1-j), 
                    next_lati_value(map_start_lati_of_center, Y_RESOLUTION*(1 -j), current_zo
om_level),  
                    next_longti_value(map_start_longti_of_center, X_RESOLUTION*(i -1), curre
nt_zoom_level));  
        } 
    } 
    //download cete r map first for visual effect  
    request_map_download(current_center.x_info, current_center.y_info, map_start_lati_of_
center, map_start_longti_of_center);  
    do_not_update_map = 0;  
  
    set_map_main_tile_info(current_center.x_info, current_center.y_info ); 
} 
  
void map_zoom_in()  
{ 
    if(make_new_url(ZOOM_CHANGED, 1, NULL, 0, 0) == URL_CHANGED)  
    { 
        map_start_lati_of_center = next_lati_value(map_start_lati_of_center, y_moved*( -1), 
current_zoom_level -1); 
        map_start_longti_of_center = next_longti_value(map_start_longti_of_center, -x_mo
ved, current_zoom_level -1); 
  
        arrange_start_main_page();  
    } 
} 
  
void map_zoom_out()  
{ 
    if(make_new_url(ZOOM_CHANGED, -1, NULL, 0, 0) == URL_CHANGED)  
    { 
  
Page 742 / 978         map_start_lati_of_center = n ext_lati_value(map_start_lati_of_center, y_moved*( -1), 
current_zoom_level+1);  
        map_start_longti_of_center = next_longti_value(map_start_longti_of_center, -x_mo
ved, current_zoom_level+1);  
  
        arrange_start_main_page();  
    } 
} 
  
static size_t  
WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)  
{ 
    size_t realsize = size * nmemb;  
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;  
  
    mem->memory = realloc(mem ->memory, mem ->size + realsize + 1);  
    if(mem ->memory == NULL) {  
        /* out of memory! */  
        printf("not enough memory (realloc returned NULL) \n"); 
        return 0;  
    } 
  
    memcpy(&(mem ->memory[mem ->size]), contents, realsize);  
    mem->size += realsize;  
    mem->memory[mem ->size] = 0;  
  
    return realsize;  
} 
  
int get_geometry_info_of_place(char* url, double* start_latitude, double* start_longitu
de) 
{ 
    CURL *curl_handle;  
    MemoryStruct_s chunk;  
  
Page 743 / 978     int ret_val=0;  
    char* search_index = NULL;  
    char* pos = NULL;  
    char* pos_lat i_start = NULL;  
    char* pos_lati_end = NULL;  
    char* pos_longti_start = NULL;  
    char* pos_longti_end = NULL;  
    char tmp_str_lati[GEO_INFO_STR_NUM]={0,}, tmp_str_longti[GEO_INFO_STR_NUM]=
{0,}; 
    double tmp_lati_sum=0, tmp_longti_sum=0;  
  
    chunk .memory = malloc(1);  /* will be grown as needed by the realloc above */  
    chunk.size = 0;    /* no data at this point */  
  
    curl_global_init(CURL_GLOBAL_ALL);  
  
    /* init the curl session */  
    curl_handle = curl_easy_init();  
  
    /* set URL to get */  
    curl_easy_setopt(curl_handle, CURLOPT_URL, url);  
    curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);  
  
    /* no progress meter please */  
    //curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);  
  
    /* send all data to this function  */ 
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);  
  
    /* we want the headers to this file handle */  
    curl_easy_setopt(curl_handle,   CURLOPT_WRITEDATA, (void *)&chunk);  
  
    /* some servers don't like request s that are made without a user -agent 
         field, so we provide one */  
  
Page 744 / 978     curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl -agent/1.0");  
  
    /* 
     *    * Notice here that if you want the actual data sent anywhere else but  
     *       * stdout, you should consider using the CURLOPT_WRITEDATA option.  */ 
  
    /* get it! */  
    ret_val = curl_easy_perform(curl_handle);  
  
    memset(temp_place_info, 0, PLACE_INFO_MAX);  
    memcpy(temp_place_info, chunk.memory, chunk.size);  
  
    /* cleanup curl stuff */  
    curl_easy_cleanup(curl_handle);  
  
    if(chunk.memory)  
        free(chunk.memory);  
  
      /* we're done with libcurl, so clean it up */  
    curl_global_cleanup();  
  
    place_searched_num = 0;  
    search_index = temp_place_info;  
    while(1) 
    { 
        pos = strstr(search_index, "<location>");  
        if(pos != NULL)// detected one more  
        { 
            pos_lati_start = strstr((char*)pos, "<lat>");  
            pos_lati_end = strstr((char*)pos, "</lat>");  
            pos_longti_sta rt = strstr((char*)pos, "<lng>");  
            pos_longti_end = strstr((char*)pos, "</lng>");  
  
            memset(tmp_str_lati, 0, GEO_INFO_STR_NUM);  
  
Page 745 / 978             memcpy(tmp_str_lati, (char*)(pos_lati_start+5), pos_lati_end -(pos_lati_start+5));  
            place_search_list[place_searched_num].str_lati = atof(tmp_str_lati);  
  
            memset(tmp_str_longti, 0, GEO_INFO_STR_NUM);  
            memcpy(tmp_str_longti, (char*)(pos_longti_start+5), pos_longti_end -(pos_longt
i_start+5));  
            place_search_list[place_searched_num].str_longti = atof(tmp_str_longti);  
  
            place_searched_num++;  
            search_index = pos+1;//just for next search  
        } 
        else 
        { 
            break; //couldn't find anymore.  
        } 
    } 
  
    for(int i=0 ; i<place_searched_num ; i++)  
    { 
        tmp_lati_sum = tmp_lati_sum + place_search_list[i].str_lati;  
        tmp_longti_sum = tmp_longti_sum + place_search_list[i].str_longti;  
    } 
  
    *start_latitude = place_search_l ist[0].str_lati;  
    *start_longitude = place_search_list[0].str_longti;  
  
    return ret_val;  
} 
  
//handle key event for search  
void key_down_cb(void *data, Evas *evas, Evas_Object *obj, void *event_info)  
{ 
    const int MAX_CUR = 20;  
    static char buf[50];  
  
Page 746 / 978     static int cur = 0;  
    double latitude, longitude;  
    static char geometry_buf[50]={0,};  
  
    Evas_Event_Key_Down *ev = event_info;  
    Evas_Object *input = data;  
    char tmp[50];  
  
    if (cur == 0) snprintf(buf, sizeof(buf), " \0"); 
  
    if (!strcmp(ev ->keyname, "Return"))  
    { 
        evas_object_text_text_set(input, "");  
        cur = 0;  
        for(int i =0 ; i<strlen(buf) ; i++)  
        { 
            if(buf[i]==' ') buf[i]=','; // google api can't recognize ' '  
        } 
        if(make_new_url(PLACE_INFO, 0, buf, 0, 0) == URL_CHANGED)//make url for qu
ery of place info.  
        { 
            if(!get_geometry_info_of_place(place_api_url, &latitude, &longitude)) // get pl
ace info data using query url and parse it.  
            { 
                memset(geometry_buf, 0, 50);  
                snprintf(geometry_buf, sizeof(geometry_buf), "%f,%f", latitude, longitude);  
                make_new_url(DELITE_MARKER, 0, NULL, 0, 0); // delete all previous mark
ers 
                if((make_new_url(CEN TER_NAME_CHANGED, 0, geometry_buf, 0, 0) == UR
L_CHANGED)  
                && (make_new_url(ADD_NEW_MULTI_MARKER, 0, NULL, 0, 0) == URL_C
HANGED))  
                { 
                    map_start_lati_of_center = latitude;  
  
Page 747 / 978                     map_start_longti_of_center = longitude;  
                    arrange_start_main_page();  
                    update_main_page();  
                } 
            } 
        } 
        return;  
    } 
  
    if (!strcmp(ev ->keyname, "BackSpace"))  
    { 
        snprintf(tmp, strlen(buf), "%s", buf);  
        evas_object_text_text_set(input, tmp);  
        strcpy(buf, tmp);  
        cur--; 
        return;  
    } 
  
    if (cur >= MAX_CUR) return;  
  
    if(!strcmp(ev ->keyname, "space"))  
    { 
        snprintf(tmp, sizeof(tmp), "%s%s", buf, " "); // replace ' ' to ' '  
        evas_object_text_text_set(input, tmp);  
        cur++;  
        strcpy(buf, tmp);  
    } 
    else if(!strcmp(ev ->keyname, "comma"))  
    { 
        snprintf(tmp, sizeof(tmp), "%s%s", buf, ","); 
        evas_object_text_text_set(input, tmp);  
        cur++;  
        strcpy(buf, tmp);  
    } 
  
Page 748 / 978     else if((!strcmp(ev ->keyname, "Caps_Lock"))  
            || !strcmp(ev ->keyname, "Shift_L")  
            || !strcmp(ev ->keyname, "Num_Lock")  
            || !strcmp(ev ->keyname, "Left")  
            || !strcmp(ev ->keyname, "Right")  
            || !strcmp(ev ->keyname, "Up")  
            || !strcmp(ev ->keyname, "Down"))  
    { 
        // to be ignored...  
    } 
    else 
    { 
        snprintf(tmp, sizeof(tmp), "%s %s", buf, ev ->keyname);  
        evas_object_text_text_set(input, tmp);  
        cur++;  
        strcpy(buf, tmp);  
    } 
} 
  
void go_to_current_geometry(void)  
{ 
    double altitude, climb, direction, speed;  
    double horizontal, vertical;location_accuracy_le vel_e level;time_t timestamp;  
    char buf[100];  
  
    if(!location_initialized)  
        return;  
  
    location_manager_get_last_location(l_manager, &altitude, &curr_user_lati, &curr_user
_longti,  
                                                 &climb, & direction, &speed, &level, &horizontal,
 &vertical, &timestamp);  
  
    memset(buf, 0, 100);  
  
Page 749 / 978     snprintf(buf, sizeof(buf), "%f,%f", curr_user_lati, curr_user_longti);  
    if(make_new_url(CENTER_NAME_CHANGED, 0, buf, 0, 0) != URL_CHANGED)  
        return;  
    make_new_url(DELITE_MARKER, 0, NULL, 0, 0);  
    if(make_new_url(ADD_NEW_MARKER, 0, buf, curr_user_longti, curr_user_lati) != URL
_CHANGED)  
        return;  
  
    map_start_lati_of_center = curr_user_lati;  
    map_start_longti_of_center = curr_user_longti;  
  
    arrange_start_main_page();  
  
    get_geometry_timer = ecore_timer_add(1, get_changed_location, NULL);  
} 
  
Eina_Bool get_changed_location(void *data)  
{ 
    double altitude, latitude, longtitude, climb, direction, speed;  
    double horizontal, vertical; location_accuracy_level_e level;time_t timestamp;  
  
    if(!location_initialized)  
        return ECORE_CALLBACK_RENEW;  
  
    location_manager_get_last_location(l_manager, &altitude, &latitude, &longtitude,  
                                                 &climb, &direction, &speed, &level, &horizontal,
 &vertical, &timestamp);  
  
    if((latitude != curr_user_lati) || (longtitude != curr_user_longti))  
    { 
        ecore_timer_del(get_geometry_timer);  
        go_to_current_geometry();  
        return ECORE_CAL LBACK_CANCEL;  
    } 
  
Page 750 / 978     else 
    { 
        return ECORE_CALLBACK_RENEW;  
    } 
} 
  
//go to current user's point  
void current_btn_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)  
{ 
    go_to_current_geometry();  
} 
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    int btn_num = (int)data;  
    //dlog_print(DLOG_ERROR, "tag", "clicked event on Button:%d", btn_num);  
  
    switch( btn_num ) {  
    case 1 :  
        map_zoom_in();  
        break;  
    case 2 :  
        map_zoom_out();  
        break;  
    } 
} 
  
void create_map(Evas_Object *win, double lati, double longti)  
{ 
    m_md = (mapdata_s*)malloc( sizeof( mapdata_s) );  
  
    /* Button -1 */ 
    m_btn1 = elm_button_add(win);  
    elm_object_text_set(m_btn1, "+" ); 
  
Page 751 / 978     evas_object_move(m_btn1, 20, 20);  
    evas_object_resize(m_btn1, 50, 50);  
    evas_object_smart_callback_add(m_btn1, "clicked", btn_clicked_cb, (void *)1);  
    evas_object_show(m_btn1);  
  
    /* Button -2 */ 
    m_btn2 = elm_button_add(win);  
    elm_object_text_set(m_btn2, " -"); 
    evas_object_move(m_btn2, 90, 20);  
    evas_object_resize(m_btn2, 50, 50);  
    evas_object_smart_callback_add(m_btn2, "clicked", btn_clicked_cb, (void *)2);  
    evas_object_show(m_btn2);  
  
    /* Canvas */  
    m_canvas = evas_object_evas_get(win);  
  
    char *res_path = app_get_resource_path();  
    if (res_path) {  
        snprintf(m_icon_path, PATH_MAX, "%s%s", res_path, "images");  
        free(res_path);  
    } 
  
    /* Thread */  
    ecore_thread_feedback_run(map_dload_thr ead, thread_feedback, thread_end, thread
_cancel, NULL, EINA_TRUE);  
    eina_lock_new(&set_info_mutex);  
  
    /* LocationManager */  
    location_manager_create(LOCATIONS_METHOD_GPS, &l_manager);  
    location_manager_set_service_state_changed_cb(l_manager, l oc_state_changed_cb, N
ULL) ;  
    location_manager_start(l_manager);  
  
    mkdir(TMP_DIR, 0755);  
  
Page 752 / 978   
    if( make_start_url(lati, longti) != URL_CHANGED ) //let's make start url to load  
        return;  
  
    arrange_start_main_page();  
} 
  
  
#endif /* MAPVIEW_ H_ */ 
└─────────────────────┘  
  
  
Page 753 / 978 58. Reading and Writing Text Files  
If you want to read and write text data in a file, use the FILE structure. You 
can read files in the /res folder, but cannot write them. The files in the 
/data folder are available both for reading and writing.  
 
1) Reading Text Files  
Now, we are going to read text files in the /res folder and display them 
on the screen.  
Create a new source project and specify the project name as 'TextFileView.' 
After the source project is created, copy the te xt.txt file in the /etc folder 
of the appendix to the /res folder of the source project.  
 
The ext.txt file includes greetings in different languages as follows:  
┌─────────────────────┐  
Good morning <br/>  
早上好  <br/>  
Hyvää Huomenta <br/>  
Bonjour <br/>  
Guten Morgen <br/>  
Jó reggelt kívánok <br/>  

  
Page 754 / 978 Buon giorno <br/>  
おはようございます。  <br/>  
안녕하세요  <br/>  
Bună dimineaţa! <br/>  
Buenos Días. <br/>  
Günaydın <br/>  
Xin chào <br/>  
Здра́вствуйте <br/>  
└─────────────────────┘  
Then, open the source file (~.c) under the src folder and add variables to 
the appdata structure,  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    //Evas_Object *label;  
    Evas_Object *entry;  
} appdata_s;  
└─────────────────────┘  
Entry widget variables are n ow added.  
Create two functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int col, int row, int spanx, int s
pany, 
      double h_expand, double v_expand, double h_align, double v_align)  
{ 
    /* Create a frame around the child, for padding */  
    Evas_Object *frame = elm_frame_add(table);  
  
Page 755 / 978     elm_object_style_set(frame, "pad_small");  
 
    evas_object_size_hint_weight_ set(frame, h_expand, v_expand);  
    evas_object_size_hint_align_set(frame, h_align, v_align);  
 
    /* place child in its box */  
    { 
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        evas_object_size_hint_align_s et(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(frame, child);  
        evas_object_show(child);  
    } 
 
    elm_table_pack(table, frame, col, row, spanx, spany);  
    evas_object_show(frame);  
} 
 
static Evas_Object *  
my_button_add(Ev as_Object *parent, const char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
└─────────────────────┘  
my_table_pack() is a function that adds a widget to a Table.  
  
Page 756 / 978 my_button_add() is a function that creates a Button widget.  
Then, move to the create_base_gui() function, and add the widget -creating 
code for Frame, Table, Button, and En try widgets. Annotate the Label 
widget -creating code.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, EL M_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *tbl, *btn, *frame;  
 
        /* Frame */  
        frame = elm_frame_add(ad ->win);  
        elm_object_style_set(frame, "pad_medium");  
        elm_object_content_set(ad ->conform, frame);  
        evas_object_size_hint_weight_set(frame, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        evas_object_size_hint_align_set(frame, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        evas_object_show(frame);  
 
        /* Container: standard table */  
        tbl = elm_table_add(ad ->win);  
        evas_object_size_hint_weight_set(tbl, EVAS_HINT_EXPAND, EVAS_HIN T_EXP
AND);  
        evas_object_size_hint_align_set(tbl, EVAS_HINT_FILL, EVAS_HINT_FILL);  
  
Page 757 / 978         elm_object_content_set(frame, tbl);  
        evas_object_show(tbl);  
 
        { 
            /* Button -1 */ 
            btn = my_button_add(ad ->conform, "Read", b tn_read_cb, ad);  
            my_table_pack(tbl, btn, 0, 0, 1, 1, EVAS_HINT_EXPAND, 0.0, EVAS_HI
NT_FILL, EVAS_HINT_FILL);  
 
            /* Entry */  
            ad->entry = elm_entry_add(ad ->conform);  
            elm_entry_scrollable_set(ad ->entry, EINA_TRUE) ; 
            elm_object_signal_emit(ad ->entry, "elm,state,scroll,enabled", "");  
            elm_object_text_set(ad ->entry, "Please press <b>Read</> button");  
            my_table_pack(tbl, ad ->entry, 0, 1, 2, 1, EVAS_HINT_EXPAND, EVAS_
HINT_EXPAND, EVAS_HI NT_FILL, EVAS_HINT_FILL);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
Add three new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
app_get_resource(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_resource_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
  
Page 758 / 978     } 
} 
  
static char*  
read_file(const char* filepath)  
{ 
    FILE *fp = fopen(filepath, "r");  
    if (fp == NULL)  
        return NULL;  
    fseek(fp, 0, SEEK_END);  
    int bufsize = ftell(fp);  
    rewind(fp);  
    if (bufsize < 1)  
        return NULL;  
  
    char *buf = malloc(sizeof(char) * (bufsize));  
    memset(buf, ' \0', sizeof(buf));  
    char str[200];  
  
    while(fgets(str, 200, fp) != NULL) {  
        dlog_print(DLOG_ERROR, "tag", "%s", str);  
        sprintf(buf + strlen(buf), "%s", str);  
    } 
    fclose(fp) ; 
    return buf;  
} 
  
static void  
btn_read_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char filepath[PATH_MAX] = { 0, };  
    char *buf = NULL;  
    app_get_resource("text.txt", filepath, PATH_MAX);  
  
Page 759 / 978     buf = read_file( filepath);  
  
    elm_object_text_set(ad ->entry, buf);  
} 
└─────────────────────┘  
app_get_resource() is a function that requests the absolute path of a file 
saved in the /res folder, and returns it.  
read_file() is a function that reads the content of a text file and returns it.  
fopen(char *, char *) is an API that returns the handle of a file. Pass the 
file path to the first parameter, and specify the file access mode to the 
second parameter. “r” indicates read only, while “w” indicates write only.  
fseek(FILE  *, int, int) is an API that moves to a certain location of Filestream. 
The first, second, and third parameters are Filestream, the count of moved 
bytes, and starting point, respectively. SEEK_SET, SEEK_CUR, and SEEK_END 
indicate the start of a file, curre nt location, and the end of the file, 
respectively.  
ftell(FILE *) is an  API that returns the current location of Filestream as the 
byte count. When it is located at the end, it will return the file size.  
rewind(FILE *) is an  API that turns back the locatio n of Filestream to the 
original location.  
fgets(char *, int, FILE *) is an API that reads text data from a file. Passing 
the maximum length of text to the second parameter and the Filestream 
to the third parameter makes the first parameter return the strin g data.  
  
Page 760 / 978 fclose(FILE *) is an API that closes the Filestream.  
btn_read_cb() is a Button callback function. Request the text file path, read 
the content of the file, and enter it in the Entry widget.  
Build and run the example. Tap the Read button, and the gr eetings in 
different languages will be output in the Entry widget.  
 
 
  

  
Page 761 / 978 2) Writing a Text File  
We will implement a feature that, by adding a Button, saves a modified 
text as a file. The /res folder does not allow writing a file.  So, you should 
save it in t he /data folder. Add the second Button -creating code to the 
create_base_gui() function.  
┌─────────────────────┐  
        { 
            /* Button -1 */ 
            btn = my_button_add(ad ->conform, "Read", btn_read_cb, ad);  
            my_table_pack(tbl, btn, 0, 0, 1, 1, EVAS_HINT_EXPAND, 0.0, EVAS_HINT_FI
LL, EVAS_HINT_FILL);  
 
            /* Button -2 */ 
            btn = my_button_add(ad ->conform, "Write", btn_write_cb, ad);  
            my_table_pack(tbl, btn, 1, 0, 1, 1, EVAS_HINT_EXPAND, 0.0, EVAS_HI
NT_FILL, EVAS_HINT_FILL);  
 
            /* Entry */  
            ad->entry = elm_entry_add(ad ->conform);  
            elm_entry_scrollable_set(ad ->entry, EINA_TRUE);  
            elm_object_signal_emit(ad ->entry, "elm,state,scroll,enabled", "");  
            elm_object_text_set(ad ->entry, "Please press <b>Read</> button");  
            my_table_pack(tbl, ad ->entry, 0, 1, 2, 1, EVAS_HINT_EXPAND, EVAS_HINT
_EXPAND, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        } 
    } 
└─────────────────────┘  
To save text in  a file, add three new functions on top of the 
create_base_gui() function.  
  
Page 762 / 978 ┌─────────────────────┐  
static void  
app_get_data(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_data_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
  
static char*  
write_file(const char* filepath, const char* buf)  
{ 
    FILE *fp;  
    fp = fopen(filepath, "w");  
    fputs(buf, fp);  
    fclose(fp);  
} 
  
static void  
btn_write_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char* buf = elm_entry_entry_get(ad ->entry);  
  
    char filepath[PATH_MAX] = { 0, };  
    app_get_data("text.txt", filepath, PATH_MAX);  
    write_file( filepath, buf);  
} 
└─────────────────────┘  
  
  
Page 763 / 978 app_get_data() is a function that returns the absolute path of the file 
existing in the /data folder.  
app_get_data_path() is an API that returns the absolute path of the /data 
folder.  
write_file() is a function t hat saves text data in a file.  
fputs(char *, FILE *) is an API that saves text data in Filestream.  
btn_write_cb() is a callback function for the second Button. Request the 
absolute path of the /data folder, and save the text data entered in the 
Entry in th e file. 
Run the example again. Tap the Read button to call the file, modify the 
content of the Entry, and tap the Write button.  
Now, the modified content is saved in the /data folder.  
 
 

  
Page 764 / 978 3) Reading a File in the /data Folder  
Unfortunately, the modified co ntent will not be kept if you close the app 
and run it again. This is because the modified file is saved in the /data 
folder, but read from the /res folder. We are now going to change the 
feature so that when reading the file, the app searches for the file  in the 
/data folder first, and when the file is not there, proceeds to search the 
/res folder.  
Modify the content of the btn_read_cb() function as below. The function 
should be located lower than the app_get_data() function.  
┌─────────────────────┐  
static void 
app_get_data(const char *res_file_in, char *res_path_out, int res_path_max)  
{ 
    char *res_path = app_get_data_path();  
    if (res_path) {  
        snprintf(res_path_out, res_path_max, "%s%s", res_path, res_file_in);  
        free(res_path);  
    } 
} 
  
static void  
btn_read_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char filepath[PATH_MAX] = { 0, };  
    app_get_data("text.txt", filepath, PATH_MAX);  
    // Read file in /data folder  
    char *buf = NULL;  
    buf = re ad_file(filepath);  
  
Page 765 / 978     // If doesn't exist file in /data folder, read file in /res folder  
    if( buf == NULL ) {  
        app_get_resource("text.txt", filepath, PATH_MAX);  
        buf = read_file(filepath);  
    } 
  
    elm_object_text_set(ad ->entry, buf);  
} 
└─────────────────────┘  
The file is read from the /data folder first. If the data does not exist there, 
then it will be read from the /res folder.  
Run the example again. Tap the Read button to call the file, modify the 
content of the Entry widget, and ta p the Write button to save it.  
Close the app (press and hold the Home button, and tap Clear All when 
the app list appears) and run it again. If you see the modified content 
when you tap the Read button, it is successfully done.  
 
4) Related APIs  
FILE  *fopen(char *,  char *): an API that returns the handle of a file. Pass 
the file path to the first parameter, and specify the file access mode to the 
second parameter. “r” indicates read only, while “w” indicates write only.  
int  fseek(FILE *__stream, long int _ _off, int __whence):  an API that moves 
to a certain location of Filestream. The first, second, and third parameters 
are Filestream, the count of moved bytes, and starting point, respectively. 
  
Page 766 / 978 SEEK_SET, SEEK_CUR, and SEEK_END indicate the start of a file, c urrent 
location, and the end of the file, respectively.  
long int ftell(FILE *__stream):  an API that returns the current location of 
the Filestream as the byte count. When it is located at the end, it will 
return the file size.  
void  rewind(FILE *__stream):  an API that turns back the location of the 
Filestream to the original location.  
char  *fgets(char *__s, int __n, FILE *__stream): an API that reads text data 
from a file. Passing the maximum length of text to the second parameter 
and the Filestream to the  third parameter makes the first parameter return 
the string data.  
int fclose(FILE *__stream):  an API to close the Filestream.  
char *app_get_data_path(void): an API that returns the absolute path of 
the /data folder.  
int fputs(char *__s, FILE *__stream): a n API that saves text data in the 
Filestream.  
  
  
Page 767 / 978 59. Requesting a File List  
Some file management apps like Astro have been used as an essential 
tool for file management for years. Requesting a file list is an essential 
feature for content -playing apps including  an image viewer or audio player, 
as well as for file management apps. In this example, we are going to 
build a simple file management app where we can add files and folder 
lists to the List widget, select items, and move the folder path.  
 
1) Registering a  Privilege  
Create a new source project and specify the project name as FileList. You 
need to have the applicable user privileges to request the file list saved in 
the memory. After the source project is created, open the tizen -
manifest.xml file, and click Privileges among the tab buttons below. Then, 
click the Add button in the upper right corner. When the popup  window 
appears, select http://tizen.org/privilege/mediastorage from the list, and 
click the OK button to close the window.  
  
Page 768 / 978  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="utf -8"?> 
<manifest xmlns="http://tizen.org/ns /packages" api -version="2.3" package="org. exam
ple.filelist" version="1.0.0">  
    <profile name="mobile" />  
    <ui-application appid="org. example .filelist" exec="filelist" type="capp" multiple="fa
lse" taskmanage="true" nodisplay="false">  
        <icon>file list.png</icon>  
        <label>filelist</label>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/mediastorage</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 769 / 978 The shared memory of the emulator basically has divided folders, but it 
does not hold files. To test this feature, we are going to copy a few image 
files to the emulator memory. You can check the folder list in tree structure 
in Connection Explorer on the bottom left of Eclipse. The path of the 
shared folder to save images is /opt/usr/media/Images. Select this folder, 
and select 'Push the file to the connected target device' from the tool bar 
at the top.  
When the popup  window for file selection appears, go to the /Image 
folder of the appendix, select  three image files (0.jpg, 1.jpg, and 2.jpg), 
and click the OK button. You can choose any files you want to use.  
 

  
Page 770 / 978  
When the popup  window closes, the selected files will be copied in the 
/Images folder.  
 
 
  

  
Page 771 / 978 2) Requesting an Internal Memory Folder List  
In this section, we are going to request the internal memory folder list of 
the emulator. Open the source file (~.c) under the src folder and add 
defined variables and invariables.  
┌─────────────────────┐  
#include "filelist.h"  
  
#define FM_PHONE_FOLDER    "/opt/usr/media"  
#define FM_MEMORY_FOLDER   "/opt/storage/sdcard"  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *list;  
    char *current_path;  
} appdata_s;  
└─────────────────────┘  
“/opt/usr/media” is a root path for the shared folder of the internal 
memory.  
“/opt/storage/sdcard” is a root path for the shared folder of the external 
memory.  
list is a List widget variable to display the file list.  
current_path is a string variable that sav es the absolute path of the current 
folder.  
Add new code at the end of the create_base_gui() function.  
  
Page 772 / 978 ┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    ad->current_path = calloc(PATH_MAX, sizeof(ch ar)); 
    strcpy(ad ->current_path, FM_PHONE_FOLDER );  
    read_dir( ad );  
} 
└─────────────────────┘  
Allocate the memory to current_path, and copy the internal memory root 
folder path.  
read_dir() is a function that requests the file list within a certain folder. 
Now, we are going to build the example.  
Add a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
read_dir(appdata_s *ad)  
{ 
    DIR *dir =  opendir(ad ->current_path);  
    if( !dir )  
        return;  
  
    struct dirent *pDirent = NULL;  
    char buf[100];  
  
    while ((pDirent = readdir(dir)) != NULL)  
    { 
        if( pDirent ->d_type == DT_DIR ) {  
            dlog_print(DLOG_INFO, "tag", "[Fol der] %s", pDirent ->d_name);  
  
Page 773 / 978         } 
        else { 
            dlog_print(DLOG_INFO, "tag", "[File] %s", pDirent ->d_name);  
        } 
    } 
    closedir(dir);  
} 
└─────────────────────┘  
DIR is a structure that controls folders. It can read or delete a file  list, and 
create a folder.  
opendir(char *) is an API that returns a DIR object to control a certain 
folder.  
dirent is a structure to save a file (or folder) information. Among the 
properties, the file name is saved in d_name. The type of the file is saved  
in d_type. DT_DIR indicates a folder; otherwise, the object is a file.  
readdir(DIR *) is an API that reads the file list from a certain folder and 
returns it as a type of dirent one by one. On reaching the end of the file 
list, NULL is returned.  
Next, we are going to build code that distinguishes files and folders, and 
outputs the result as a Log message.  
closedir(DIR *) is an API that closes DIR.  
Build and run the example. The file and folder list existing in the shared 
folder of the internal memory appea rs on the Log panel.  
  
Page 774 / 978  
 
3) Adding a File List to List Widget  
Now, we will add the file list to the List widget as an item. Input Box - and 
List-creating code to the create_base_gui() function. Annotate the Label 
widget.  
┌─────────────────────┐  
    /* Confor mant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND , EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Box */  

  
Page 775 / 978         Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT _EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* List */  
            ad->list = elm_list_add(ad ->conform);  
            elm_list_mode_set(ad ->list, ELM_LIST_COMPRESS);  
            evas_object_size_hint_weight_set(ad ->list, EVAS_HINT_EXPAND, EVAS_
HINT_EXPAND);  
            evas_object_size_hint_align_set(ad ->list, EVAS_HINT_FILL, EVAS_HINT_F
ILL); 
            elm_box_pack_end(box, ad ->list);  
            evas_object_show(ad ->list);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
Modify the read_dir() function as follows:  
┌─────────────────────┐  
static void  
read_dir(appdata_s *ad)  
{ 
    DIR *dir = opendir(a d->current_path);  
    if( !dir )  
        return;  
  
    struct dirent *pDirent = NULL;  
  
Page 776 / 978     char buf[100];  
    elm_list_clear(ad ->list);  
  
    while ((pDirent = readdir(dir)) != NULL)  
    { 
        if( pDirent ->d_type == DT_DIR ) {  
            dlog_print(DLOG_INFO, "tag", "[Folder] %s", pDirent ->d_name);  
            sprintf(buf, "[ %s", pDirent ->d_name);  
        } 
        else { 
            dlog_print(DLOG_INFO, "tag", "[File] %s", pDirent ->d_name);  
            sprintf(buf, "# %s", p Dirent ->d_name);  
        } 
        elm_list_item_append(ad ->list, buf, NULL, NULL, NULL, ad);  
    } 
    closedir(dir);  
} 
└─────────────────────┘  
elm_list_clear(Evas_Object *) is an API that deletes all the items of the List 
widget.  
To identify files from f olders, the '[' symbol is added in front of the name 
if the content is a folder, while the '#' symbol is added in front of the 
name if the content is a file.  
elm_list_item_append(Evas_Object *, char *, Evas_Object *, Evas_Object *, 
Evas_Smart_Cb , void *) is an API that adds a new item to the List widget.  
Run the example again. The folder and file list within the root folder is 
added to the List widget. The '.' symbol indicates the current folder, while 
the '..' symbol indicates a top -level folder.  
  
Page 777 / 978  
 
4) Mo ving a Folder  
We will implement a feature that when the user selects a List widget item, 
directs the user to the folder. To do so, the following features are necessary.  
 - Event callback function for selection of a List widget item  
 - Removing the '.' and '..' symbols from the content list  
 - If the current folder is not a root folder, the '..' symbol should be added 
in the first item.  
Add new code to the read_dir() function.  
┌─────────────────────┐  
static void  
read_dir(appdata_s *ad)  
{ 
    DIR *dir = opendir(ad ->current_path);  
    if( !dir )  

  
Page 778 / 978         return;  
  
    struct dirent *pDirent = NULL;  
    char buf[100];  
    elm_list_clear(ad ->list); 
  
    if( strcmp(ad ->current_path, FM_PHONE_FOLDER) != 0 )  
        elm_list_item_append(ad ->list, "..", NULL, NU LL, list_item_clicked, ad);  
  
    while ((pDirent = readdir(dir)) != NULL)  
    { 
        if( strcmp(pDirent ->d_name, ".") == 0 )  
            continue;  
        if( strcmp(pDirent ->d_name, "..") == 0 )  
            continue;  
  
        if( pDirent ->d_type == D T_DIR ) {  
            dlog_print(DLOG_INFO, "tag", "[Folder] %s", pDirent ->d_name);  
            sprintf(buf, "[ %s", pDirent ->d_name);  
        } 
        else { 
            dlog_print(DLOG_INFO, "tag", "[File] %s", pDirent ->d_name);  
            sprintf(buf,  "# %s", pDirent ->d_name);  
        } 
        elm_list_item_append(ad ->list, buf, NULL, NULL, list_item_clicked, ad);  
        //elm_list_item_append(ad ->list, buf, NULL, NULL, NULL, ad);  
    } 
    closedir(dir);  
} 
└─────────────────────┘  
If the current folder is an internal memory root folder, add the symbol '..' 
as the first item of the List widget.  
  
Page 779 / 978 If the content name is '.' or '..,' it can simply be ignored.  
Specify the name of the item selection event callback function as 
list_item_clicked. Now, we a re going to build this function. Create three 
functions on top of the read_dir() function.  
┌─────────────────────┐  
static char*  
get_file_name(const char* item_text, bool *is_file)  
{ 
    if( item_text[0] == '#' )  
        *is_file = true;  
    else 
        *is_file = false;  
  
    if( strcmp(item_text, "..") == 0 )  
        return item_text;  
    return item_text + 2;  
} 
  
static char*  
get_new_path(char *current_path, const char *folder_name)  
{ 
    if( strcmp(folder_name, "..") == 0)  
    { 
        int pos = strlen( current_path ) - strlen( strrchr( current_path, '/') );  
        current_path[pos] = ' \0'; 
    } 
    else 
        sprintf(current_path, "%s/%s", current_path, folder_name);  
    return current_path;  
} 
  
static void  
list_item_clicked(void *data, Evas_ Object *obj, void *event_info)  
  
Page 780 / 978 { 
    Elm_Object_Item *it = event_info;  
    const char *item_text = elm_object_item_text_get(it);  
  
    bool is_file;  
    char *file_name = get_file_name(item_text, &is_file);  
    if( is_file )  
        return;  
  
    appdata_s  *ad = data;  
    ad->current_path = get_new_path(ad ->current_path, file_name);  
  
    read_dir( ad );  
} 
└─────────────────────┘  
get_file_name() is a function that receives the text of a List item, removes 
the symbols, and identifies between a folder and a file. 
If the first character is '#,' it is a file. If the first character is '[,' then it is a 
folder. If the text is '..,' it indicates a top -level folder.  
get_new_path() is a function that requests the whole folder path by 
receiving the current path and the new folder name.  
strrchr(char *, int) is an API that searches certain characters from a string. 
Start to search from the end. Return the pointer of the character at the 
very end.  
If the name of the new folder is '..,' it indicates that this is the top -level 
folder. In this case, you need to delete the name of the last folder in the 
current folder path. Otherwise, add a new folder name at the end of the 
current folder path to create an absolute path.  
  
Page 781 / 978 list_item_clicked() is an event function to select a L ist widget item. Request 
the caption text of the item, and separate the name of content. Then, 
create a new folder path, and add the content in the folder to the List 
widget.  
However, if you build it as it is now, an error will occur because the 
read_dir()  and list_item_clicked() functions call each other. In such cases, 
declare the header of the function. The location is either the top of the 
source file or the header file. In this example, we will declare it at the top 
of the source file. Go to the top of  the source file, and declare the read_dir() 
function.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *list;  
    char *current_path;  
} appdata_s;  
  
static void read_d ir(appdata_s *ad);  
└─────────────────────┘  
Run the example again, and you will now see the '.' and '..' symbols are 
gone. When you select the Images item, the file list that you just copied 
will be displayed. The '..' symbol has been added to the first ite m. If you 
select it, it returns to the previous folder.  
  
Page 782 / 978    
 
5) ELM File Selector  
You can easily implement a file manager by using the ELM File Selector 
widget. Create a new source project, and specify the name as 
ElmFileSelectorEx.  
After the source project is created, open the tizen -manifest.xml file, and 
add the following privilege.  
http://tizen.org/privilege/mediastorage  
Open the source file (/src/elmfileselectorex.c), and add the new code to 
the create_base_gui() function. This code creates a Box and FileSelector 
widget. Delete the Label widget -creating code.  
  

  
Page 783 / 978 ┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set (ad->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Box */  
        Evas_Object  *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            Evas_Object *fs = elm_fileselector_add( ad->conform);  
            evas_object_size_hint_weight_set(fs, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
            evas_object_size_hint_align_set(fs, EVAS_HINT_FILL, EVAS_HINT_FILL);  
            elm_box_pack_end(box, fs);  
            evas_object_show(fs);  
 
            elm_fileselector_path_set(fs, FM_PHONE_FOLDER);  
            //elm_fileselector_expandable_set(fs, EINA_TRUE);  
            elm_fileselector_is_save_set(fs, EINA_FALSE);  
            elm_fileselector_mode_set(fs, ELM_FILESELECTOR_LIST);  
            elm_fileselector_folder_only_set(fs, EINA_FALSE);  
        } 
    } 
 
  
Page 784 / 978     /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
Build and run the example. The folder list is displayed in the FileSelector 
widget.  
 
See the link below for further information on how to use the FileSelector 
widget.  
https://docs.enlightenment.org/elementary/1.15.0/fileselector_example.html  
https://docs.enlightenment.org/elementary/1.15.0/group__Fileselector.html  
 
  

  
Page 785 / 978 6) Related APIs  
DIR: a structure that controls a folder. It can read or delete a file list, and 
create a folder.  
DIR *opendir(char *__name): an API that returns a DIR object to control a 
specific folder.  
dirent: a structure that saves file (or folder) information. Among t he 
properties, the file name is saved in d_name. The type of the file is saved 
in d_type. DT_DIR indicates a folder; otherwise, the object is a file.  
struct dirent *readdir(DIR *__dirp): an API that reads the file list within a 
certain folder and returns t he files as a type of dirent one by one. Once 
reaching the end of the file list, NULL is returned.  
int closedir(DIR *__dirp): an API that closes DIR.  
void  elm_list_clear(Evas_Object *obj): an API that deletes all the items of 
the List widget.  
Elm_Object_I tem *elm_list_item_append(Evas_Object *obj, const char *label, 
Evas_Object *icon, Evas_Object *end, Evas_Smart_Cb func, const void *data): 
an API that adds new items to the List widget.  
char *strrchr(char *__s, int __c): an API that searches certain charac ters from 
a string. It starts to search from the end, and returns the pointer of the 
character at the very end.  
  
  
Page 786 / 978 60. Using Preference  
It is convenient if you save information such as the environment settings 
of an app in the registry. Preference is a storage space where you can save 
data locally. You can save the environment settings information here. 
When the app is deleted, the preference will also be deleted.  
 
1) Saving String Data in Preference  
Create a new source project and specify the project name as 
'PreferenceEx.' After the source project is created, open the source file (~.c) 
under the src folder and add library header files and variables.  
┌─────────────────────┐  
#include "preferenceex.h"  
#include <app_preference.h>  
#include <stdlib.h>  
 
typedef struct  appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *entry1;  
    Evas_Object *spinner1;  
} appdata_s;  
 
const char *string_key = "string_key";  
const char *integer_key = "integer_key";  
└─────────────────────┘  
app_preference.h is a library header file used for Preference.  
  
Page 787 / 978 stdlib.h is a library header file to change the type of strings and numbers.  
We are going to input string data at entry1, and number data at spinner1.  
Now, we are going to add some widgets on the screen. Create two 
functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
    evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    elm_table_pack(table, child, x, y, w, h);  
    evas_object_show(child);  
} 
 
static Evas_Object *  
my_button_add(Evas_Object *parent, const char *text, Evas_Smart_Cb cb, void *cb_dat
a) 
{ 
    Evas_Object *btn;  
 
    btn = elm_button_add(parent);  
    elm_object_text_set(btn, text);  
    evas_object_smart_callback_add(btn, "clicked", cb, cb_data);  
 
    return btn;  
} 
└─────────────────────┘  
my_table_pack() is a function that adds a widget to  a Table.  
  
Page 788 / 978 my_button_add() is a function that creates a Button widget.  
Next, add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show( ad->conform);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_box_add(ad ->conform);  
        evas_object_size_hint_weight_set(b ox, EVAS_HINT_EXPAND, 0.0);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->conform);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 10 * elm_config_scale_g et(), 30 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, 0.0);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, 0.0);  
        elm_box_pack_end(box, table);  
  
Page 789 / 978         evas_object_show(table);  
 
        { 
            /* Label -1 */ 
            Evas_Object *label = elm_label_add(ad ->conform);  
            elm_object_te xt_set(label, "Pet name:");  
            my_table_pack(table, label, 0, 0, 1, 1);  
 
         /* Bg -1 */ 
            Evas_Object *bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 210, 210, 210);  
            my_table_pack(table, bg, 1, 0, 1, 1);  
 
            /* Entry -1 */ 
            ad->entry1 = elm_entry_add(ad ->conform);  
            my_table_pack(table, ad ->entry1, 1, 0, 1, 1);  
 
            /* Label -2 */ 
            label = elm_label_add(ad ->conform);  
            elm_object_text_set(label, "Percentage:");  
            my_table_pack(table, label, 0, 1, 1, 1);  
 
            /* Spinner -1 */ 
            ad->spinner1 = elm_spinner_add(ad ->conform);  
            elm_spinner_editable_set(ad ->spinner1, EINA_TRUE);  
            elm_spinner_interval_set(ad ->spinner1, 1);  
            elm_spinner_min_max_set(ad ->spinner1, 0, 100);  
            elm_spinner_label_format_set(ad ->spinner1, "%.0f");  
            my_table_pack(table, ad ->spinner1, 1, 1, 1, 1);  
 
            Evas_Object *btn;  
 
            /* Button -Save */ 
            btn = my_button_add(ad ->conform, "Save", btn_save_cb, ad);  
  
Page 790 / 978             my_table_pack(table, btn, 0, 3, 2, 1);  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win); 
} 
└─────────────────────┘  
We have added one Box, one Table, two Label, one Bg, one Entry, one 
Spinner, and one Button widget. Enter a string in the first Entry, and tap 
the Button. The string will be saved in Preference.  
Create a Button callback fun ction on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_save_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char *string_value;  
    int integer_value;  
 
    string_value = elm_object_text_get(ad ->entry1);  
    preference_set_string(string_key, string_value);  
} 
└─────────────────────┘  
preference_set_string(char *, char *) is an API that saves string data in 
Preference. Pass the Key to the first parameter, an d string data to the 
second parameter. Keys must be the same when performing reading and 
writing.  
  
Page 791 / 978 Build and run the example. Enter a string in the first Entry, and tap the 
Save button. The string will be saved. Unfortunately, we have not yet built 
the read ing feature. Now, we are going to build the example.  
 
 
2) Reading a String Preference  
We will implement a feature that reads data in Preference by adding a 
second Button. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
            Evas_Object *btn;  
 
            /* Button -Load */  
            btn = my_button_add(ad ->conform, "Load", btn_read_cb, ad);  
            my_table_pack(table, btn, 0, 2, 2, 1);  
 
            /* Button -Save */  
            btn = my_button_add(ad ->conform, "Save", btn_save_cb, ad);  
            my_table_pack(table, btn, 0, 3, 2, 1);  
        } 
    } 
└─────────────────────┘  

  
Page 792 / 978 Then, we are going to create a callback function for the added Button. 
Add a new function on top of the create_base_gui() function . 
┌─────────────────────┐  
static void  
btn_read_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char *string_value = "";  
    bool existing = false;  
 
    if ((preference_is_existing(string_key, &existing) == 0) && existing)  
    { 
        preference_get_string(string_key, &string_value);  
        elm_object_text_set(ad ->entry1, string_value);  
        free(string_value);  
    } 
} 
└─────────────────────┘  
When reading data in Preference, we first need to check if the data exists.  
preference_is_existing(const char *, bool *) is an API that determines if 
certain data exists in Preference. Passing a Key to the first parameter makes 
the second parameter return whether or not the data exists.  
preference_get_string(char *, char **) is an  API that reads string data from 
Preference. Passing a Key to the first parameter makes the second 
parameter return the string data.  
  
  
Page 793 / 978 Run the example again, enter the string in the first Entry, and tap the Save 
button. Then, delete the characters entered in the Entry, and tap the Read 
button. The string that has been just entered will be displayed in the Entry.  
 
 
3) Reading and Writing Preference Numbers  
Now, we are going to save numbers in Preference, and read them again. 
First, add new code as follows t o the storage function.  
┌─────────────────────┐  
static void  
btn_save_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char *string_value;  
    int integer_value;  
 
    string_value = elm_object_text_get(ad ->entry1);  
    preference_set_string(string_key, string_value);  
 
    integer_value = (int) elm_spinner_value_get(ad ->spinner1);  
    preference_set_int(integer_key, integer_value);  

  
Page 794 / 978 } 
└─────────────────────┘  
atoi(char *), which is the acronym of Array to Int, is an API t hat changes a 
string to numbers.  
preference_set_int(char *, int) is an API that saves integer -type data in 
Preference.  
Also, add new code to a function that reads data.  
┌─────────────────────┐  
static void  
btn_read_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char *string_value = "";  
    int integer_value;  
    bool existing = false;  
 
    if ((preference_is_existing(string_key, &existing) == 0) && existing)  
    { 
        preference_get_string(string_key, & string_value);  
        elm_object_text_set(ad ->entry1, string_value);  
        free(string_value);  
    } 
 
    if ((preference_is_existing(integer_key, &existing) == 0) && existing)  
    { 
        preference_get_int(integer_key, &integer_value);  
        elm_spinner_value_set(ad ->spinner1, (double) integer_value);  
    } 
} 
  
Page 795 / 978 └─────────────────────┘  
preference_get_int(char *, int *) is an API that reads integer -type data from 
Preference.  
eina_convert_itoa(int, char *) is an API that converts integers to strings.  
Run the example again. Enter a string in the first Entry, and enter numbers 
in the second Entry. Then, tap the Save button.  
If you change the input data, run it again, and tap the Read button, the 
data saved in Preference will be displayed again.  
 
  

  
Page 796 / 978 4) Related APIs  
int  preference_set_string(const char *key, const char *value): an API that 
saves string data in Preference. Pass the Key to the first parameter, and 
string data to the second parameter. Keys must be the same when 
performing reading and writin g. 
int  preference_is_existing(const char *key, bool *existing): an API that 
determines if certain data exists in Preference. Passing a Key to the first 
parameter makes the second parameter return whether or not the data 
exists.  
int  preference_get_string( const char *key, char **value): an API that reads 
string data from Preference. Passing a Key to the first parameter makes 
the second parameter return the string data.  
int  atoi(char *__nptr): the acronym of Array to Int; an API that changes a 
string to num bers. 
int  preference_set_int(char *key, int value): an API that saves integer -type 
data in Preference.  
int  preference_get_int(char *key, int *value): an API that reads integer -
type data from Preference.  
int  eina_convert_itoa(int n, char *s): an API that  converts integers to 
strings.  
  
  
Page 797 / 978 61. Example of Making a Report Card with SQLite  
The information of user environment settings can be saved by using 
Preference. However, systematic and massive data like schedule 
management, contact information, and score manag ement should be 
handled with a DB. Most mobile platforms provide SQLite as a DB. Tizen 
also supports SQLite. SQLite has relatively small maximum data capacity 
compared to Oracle or MS -SQL, but it is big enough for mobile devices. 
In addition, with easy ope ration and utilization of standard SQL query 
statements, SQLite has excellent compatibility with DBs which used to be 
used by other systems.  
One DB includes one or more tables. A table is a two -dimensional table 
similar to an Excel spreadsheet. Multiple c olumns are placed horizontally 
on the table. Whenever data that consists of a collection of individual 
fields is filled, a new column of records will be added in the vertical 
direction. In this example, we are going to create a simple example of 
report car d using SQLite.  
 
1) Creating a DB  
Create a new source project and specify the project name as SqliteEx. After 
the source project is created, open the source file (~.c) under the src folder, 
and add a library header file, variables, and a structure.  
┌────── ───────────────┐  
#include "sqliteex.h"  
#include <sqlite3.h>  
  
Page 798 / 978 #include <stdlib.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *entry1;  
    Evas_Object *entry2;  
    Evas_Object *entry3;  
    Evas_Object *list;  
  
    sqlite3 *db; // Database handle  
    char *current_key;  
} appdata_s;  
  
typedef struct recdata {  
    char key[10];  
    char name[255];  
    char english[10];  
    char math[10];  
} recdata_s;  
  
appdata_s *m_ad;  
└─────────────────────┘  
sqlite3.h is a library header file to use SQLite.  
stdlib.h is a library header file to change the type of strings and numbers.  
We added three Entries to the appdata structure. Now, we are going to 
enter a student name, and English a nd Math scores, respectively.  
Then, we will output the DB list of the report card in the List widget.  
  
Page 799 / 978 sqlite3 is the object variable of the DB.  
We are going to save the Key values of the currently selected records in 
current -key. 
recdata is a structure to  save the student’s score data. One recdata means 
one record.  
m_ad is declared as a global variable to make the appdata accessible 
anywhere.  
Now, we are going to create a DB file in the /data folder, and then 
create a report card table. Create three functi ons on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static int CreateTable(appdata_s *ad)  
{ 
   char *ErrMsg;  
   char *sql = "CREATE TABLE IF NOT EXISTS ReportCard(KEY INTEGER PRIMARY KEY,
 NAME TEXT NOT NULL, ENGLISH INT NOT NULL, MATH INT  NOT NULL);";  
  
   int ret = sqlite3_exec(ad ->db, sql, NULL, 0, &ErrMsg);  
   return ret;  
} 
  
static void  
init_db(appdata_s *ad)  
{ 
    sqlite3_shutdown();  
    sqlite3_config(SQLITE_CONFIG_URI, 1);  
    sqlite3_initialize();  
  
Page 800 / 978     char * resource = app_get_data _path();  
    int siz = strlen(resource) + 10;  
    char * path = malloc(sizeof(char)*siz);  
    strncat(path, resource, siz);  
    strncat(path, "test.db", siz);  
  
    sqlite3_open(path, &ad ->db); 
    free(path);  
  
    CreateTable(ad);  
} 
 
static void  
my_table_pack(Evas_Object *table, Evas_Object *child, int x, int y, int w, int h)  
{ 
    evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);  
    elm_table_p ack(table, child, x, y, w, h);  
    evas_object_show(child);  
} 
└─────────────────────┘  
CreateTable() is a function that creates a table by using an SQL query 
statement.  
Among the query statement, 'CREATE TABLE' is a command to create a 
table. 
'IF NOT EXISTS ' is a command to create a table if there is no existing table.  
In this example, the table name has been specified as ReportCard.  
  
  
Page 801 / 978 'KEY INTEGER PRIMARY KEY' is code to add a Key column. The available 
type is numbers. Whenever a record is added, the number  will 
automatically increase.  
'NAME TEXT NOT NULL' is code to add a column which saves a name. The 
available type is text, and it cannot be left blank.  
'ENGLISH INT NOT NULL' is code to add a column which saves the English 
scores. The available type is num bers, and it cannot be left blank.  
'MATH INT NOT NULL' is code to add a column which saves the Math 
scores. The available type is numbers, and it cannot be left blank.  
sqlite3_exec(sqlite3*, char *, int(*callback), void *, char **) is an API that 
carries o ut an SQL query statement. The parameters listed in order are an 
SQLite object, query statement, name of the callback function, user data, 
and error message return.  
init_db() is a function that creates a DB file.  
sqlite3_shutdown() is an API that closes t he DB.  
sqlite3_config(int, ...) is an API that defines the properties of the DB. 
Passing SQLITE_CONFIG_URI saves data in the DB file.  
sqlite3_initialize() is an API that initializes the DB.  
app_get_data_path() is an API that returns the absolute path of the /data 
folder. The /res folder does not allow writing, so we will create a DB file in 
the /data folder.  
  
Page 802 / 978 strncat(char *, char *, size_t) is an API that adds a new string at the end of 
a string by defining the maximum length of the string. The parameters 
listed in order are original string arrays, string data to be added, and 
maximum length.  
sqlite3_open(char *, sqlite3 **) is an API that opens the DB file.  You need 
to create a DB file if it does not already exist. Passing the file path to the 
first parameter makes the second parameter return the DB object.  
my_table_pack() is a function that adds a widget to a Table.  
We are going to make the DB file automatically open when the app is run. 
Call the function above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    init_db(ad);  
} 
└─────────────────────┘  
2) Adding New Records  
We will implement a f eature that adds new records in the DB when a 
student name, and English and Math scores are entered in three Entry 
widgets, and then a Button is tapped. Add new code to the 
create_base_gui() function. Annotate the Label 
widget.┌─────────────────────┐  
    /* Conformant */  
  
Page 803 / 978     ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HIN T_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* Box to put the table in so we can bottom -align the table  
         * window will stretch all resize object content to win size */  
        Evas_Object *box = elm_box_add(ad ->conform);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, 0.0);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        /* Table */  
        Evas_Object *table = elm_table_add(ad ->conform);  
        /* Make table homogenous - every cell will be the same size */  
        elm_table_homogeneous_set(table, EINA_TRUE);  
        /* Set padding of 10 pixels multiplied by scale factor of UI */  
        elm_table_padding_set(table, 10 * elm_config_scale_get(), 10 * elm_config
_scale_get());  
        /* Let the table child allocation area expand within in the box */  
        evas_object_size_hint_weight_set(table, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        /* Set table to fiill width but align to bottom of box */  
        evas_object_size_hint_align_set(table, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_box_pack_end(box, table);  
        evas_object_show(table);  
 
        { 
            /* Bg -1 */ 
            Evas_Object *bg = elm_bg_add(ad ->conform);  
  
Page 804 / 978             elm_bg_color_set(bg, 210, 210, 210);  
            my_table_pack(table, bg, 0, 0, 1, 1);  
 
            /* Entry -1 */ 
            ad->entry1 = elm_entry_add(ad ->conform);  
            elm_object_part_text_set(ad ->entry1, "elm.guide", "Name");  
            my_table_pack(table, ad ->entry1, 0, 0, 1, 1);  
 
            /* Bg -2 */ 
            bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 210, 210, 210);  
            my_table_pack(table, bg, 1, 0, 1, 1);  
 
            /* Entry -2 */ 
            ad->entry2 = elm_entry_add(ad ->conform);  
            elm_object_part_text_set(ad ->entry2, "elm.guide", "English");  
            my_table_pack(table, ad ->entry2, 1, 0, 1 , 1); 
 
            /* Bg -3 */ 
            bg = elm_bg_add(ad ->conform);  
            elm_bg_color_set(bg, 210, 210, 210);  
            my_table_pack(table, bg, 2, 0, 1, 1);  
 
            /* Entry -3 */ 
            ad->entry3 = elm_entry_add(ad ->conform);  
            elm_object_part_text_set(ad ->entry3, "elm.guide", "Math");  
            my_table_pack(table, ad ->entry3, 2, 0, 1, 1);  
 
            /* Button -Add */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Add" ); 
            evas_object_smart_callback_add(btn, "clicked", btn_add_cb, ad);  
            my_table_pack(table, btn, 0, 1, 1, 1);  
        } 
  
Page 805 / 978     } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We have  created one Box, one Table, three Bg, and three Entry widgets. 
We also created a Button widget.  
We will implement a feature that adds data that is entered in the Entry to 
the DB when you tap the button. Create two functions on top of the 
create_base_gui()  function.  
┌─────────────────────┐  
static int  
InsertRecord(appdata_s *ad, unsigned char *name, int english, int math)  
{ 
    char sql[256];  
    char *ErrMsg;  
    snprintf(sql, 256, "INSERT INTO ReportCard VALUES(NULL, \'%s\',%d,%d);", name, 
english, math);  
    int ret = sqlite3_exec(ad ->db, sql, NULL, 0, &ErrMsg);  
    return ret;  
} 
  
static void  
btn_add_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    char* s_name = elm_object_text_get(ad ->entry1);  
    char* s_english = elm _object_text_get(ad ->entry2);  
    int n_english = atoi (s_english);  
  
Page 806 / 978     char* s_math = elm_object_text_get(ad ->entry3);  
    int n_math = atoi (s_math);  
  
    InsertRecord(ad, s_name, n_english, n_math);  
} 
└─────────────────────┘  
InsertRecord() is a function that adds new records by using an SQL query 
statement.  
From the statement, 'INSERT INTO ReportCard' is a command to add new 
records to the table whose name is 'ReportCard.'  
Pass the record data to VALUES(). We will not check the first column Key 
because it is created automatically.  
When the user taps the Button, the btn_add_cb() function requests the 
data that is input in Entry, and saves it in the DB.  
Build and run the example. Enter a student name in the first Entry, English 
scores in the second Entry, and Math scores in the third Entry. Then, tap 
the Add button. Now, the new records are added to the DB.  
Unfortunately, there is no way for us to check this ourselves. We have not 
yet implemented a feature to allow us to read data saved in the DB.  
 
 

  
Page 807 / 978 3) Reading the Data Saved in DB  
We will implement a feature that outputs data saved in the DB and 
displays it on the screen. To do so, we need to add the List widget -creating 
code to the create_base_gui() function.  
┌─────────────────────┐  
static void  
create_base_gui(appdata_s *ad)  
{ 
    m_ad = ad;  
  
    ~ 
 
            /* Button -Add */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Add");  
            evas_object_smart_callback_add(btn, "clicked", btn_add_c b, ad);  
            my_table_pack(table, btn, 0, 1, 1, 1);  
 
            /* List */  
            ad->list = elm_list_add(ad ->conform);  
            elm_list_mode_set(ad ->list, ELM_LIST_COMPRESS);  
            elm_list_go(ad ->list); 
            my_table_pack(table, ad ->list, 0, 2, 3, 8);  
        } 
    } 
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
appdata objects are saved in the global variables to be able to use them 
  
Page 808 / 978 anywher e. Add two new functions. These functions should be placed on 
top of init_db() and btn_add_cb().  
┌─────────────────────┐  
static int db_read_cb(void *counter, int argc, char **argv, char **azColName)  
{ 
    char buf[255];  
  
    recdata_s* rd = malloc(sizeof(recdata_s));  
    strcpy(rd ->key, argv[0]);  
    strcpy(rd ->name, argv[1]);  
    strcpy(rd ->english, argv[2]);  
    strcpy(rd ->math, argv[3]);  
  
    sprintf(buf, "%s / %s / %s / %s", argv[0], argv[1], argv[2], argv[3]);  
    elm_list_item_append(m _ad->list, buf, NULL, NULL, NULL, (void*)rd);  
    elm_list_go(m_ad ->list); 
    return 0;  
} 
  
static int read_db(appdata_s *ad)  
{ 
    char *sql = "select * from ReportCard";  
    int counter=0;  
    char *ErrMsg;  
  
    elm_list_clear(ad ->list); 
    int ret = sqlite3_exec(ad ->db, sql, db_read_cb, &counter, &ErrMsg);  
    return ret;  
} 
└─────────────────────┘  
When reading multiple records from the DB, individual record information 
  
Page 809 / 978 will be passed to the callback function. db_read_cb() is a callback function 
that r eceives a record and handles it. The data is passed to the third 
parameter as an array.  
Create the recdata_s structure, save data of each field, and add up all data 
to one string. Then, add the string to the List widget as a new item.  
read_db() is a funct ion that reads all data saved in the DB, and outputs it 
in the List widget.  
'select * from ReportCard' is a query statement that returns all data saved 
in the ReportCard table.  
Call the function above when the app is run and the Button is tapped. 
Add new c ode at the end of the init_db() and btn_add_cb() functions.  
┌─────────────────────┐  
static void  
init_db(appdata_s *ad)  
{ 
    ~  
    CreateTable(ad);  
    read_db(ad);  
} 
  
static void  
btn_add_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    ~  
    InsertRecord(ad, s_name, n_english, n_math);  
    read_db(ad);  
} 
  
Page 810 / 978 └─────────────────────┘  
This is the reason why the read_db() function should be placed on top of 
the init_db() and btn_add_cb() functions.  
Run the example again. The data that we just inpu t has been added to 
the List widget. Input new data, and tap the Add button. You will now see 
a new item has been added to the List widget.  
   
 
4) Modifying Data  
We will now learn how to modify data that is already saved. When the 
user selects a List ite m, the data of the item can be output in the Entry. 
We will implement this feature now. In the db_read_cb() function, specify 
the name of a callback function to the code that adds a new item. Then, 
create the callback function.  
┌─────────────────────┐  
static void  
list_item_clicked(void *data, Evas_Object *obj, void *event_info)  
{ 
    recdata_s* rd = (recdata_s*)data;  
    m_ad->current_key = rd ->key; 

  
Page 811 / 978     elm_object_text_set(m_ad ->entry1, rd ->name);  
    elm_object_text_set(m_ad ->entry2, rd ->english);  
    elm_object_text_set(m_ad ->entry3, rd ->math);  
} 
  
static int db_read_cb(void *counter, int argc, char **argv, char **azColName)  
{ 
    char buf[255];  
  
    recdata_s* rd = malloc(sizeof(recdata_s));  
    strcpy(rd ->key, argv[0]);  
    strcpy(rd ->name, argv[1]);  
    strcpy(rd ->english, argv[2]);  
    strcpy(rd ->math, argv[3]);  
  
    sprintf(buf, "%s / %s / %s / %s", argv[0], argv[1], argv[2], argv[3]);  
    elm_list_item_append(m_ad ->list, buf, NULL, NULL, list_item_clicked, (void*)rd);  
    //elm_list_item_append(m_ ad->list, buf, NULL, NULL, NULL, (void*)rd);  
    elm_list_go(m_ad ->list); 
    return 0;  
} 
└─────────────────────┘  
list_item_clicked() is an event callback function to select a List widget item. 
Save the Key values in global variables, and output other data  in the Entry 
widget.  
The code for adding items in the List widget is modified in the db_read_cb() 
function. The name of the item selection callback function is specified.  
Then, add new Button -creating code to the create_base_gui() function.  
  
  
Page 812 / 978 ┌─────────── ──────────┐  
            /* Button -Add */  
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Add");  
            evas_object_smart_callback_add(btn, "clicked", btn_add_cb, ad);  
            my_table_pack(table, b tn, 0, 1, 1, 1);  
 
            /* Button -Update */  
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Update");  
            evas_object_smart_callback_add(btn, "clicked", btn_update_cb, ad);  
            my_table_pack(table, btn, 1, 1, 1, 1);  
 
            /* List */  
            ad->list = elm_list_add(ad ->conform);  
            elm_list_mode_set(ad ->list, ELM_LIST_COMPRESS);  
            elm_list_go(ad ->list); 
            my_table_pack(table, ad ->list, 0, 2, 3, 8);  
└─────────────────────┘  
We will now implement a feature that modifies the data of the currently 
selected item when you tap the button. Create two functions on top of 
the create_base_gui() function.  
┌─────────────────────┐  
static int  
UpdateRecord(appdata_s *ad, unsigned char *name, unsigned char *english, unsigne
d char *math)  
{ 
    char sql[256];  
    char *ErrMsg;  
    snprintf(sql, 256, "UPDATE ReportCard SET NAME= \'%s\', ENGLISH= \'%s\', MAT
H=\'%s\' WHERE KEY= \'%s\';", 
  
Page 813 / 978             name, e nglish, math, ad ->current_key);  
    int ret = sqlite3_exec(ad ->db, sql, NULL, 0, &ErrMsg);  
    return ret;  
} 
  
static void  
btn_update_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    char* s_name = elm_object_text_get(ad ->entry1);  
    char* s_english = elm_object_text_get(ad ->entry2);  
    char* s_math = elm_object_text_get(ad ->entry3);  
  
    UpdateRecord(ad, s_name, s_english, s_math);  
  
    read_db(ad);  
} 
└─────────────────────┘  
UpdateRecord() is a function that modifies data saved in the DB.  
From the query statement, 'UPDATE ReportCard' modifies data saved in 
the ReportCard table.  
SET NAME= \’%s\’ saves string data in the NAME column.  
WHERE KEY= \’%s\’ modifies records whose Key values are the same.  
btn_update_cb() is a function that saves data that is input in the Entry to 
the currently selected record.   
  
  
Page 814 / 978 Run the example again. Select one of the List items, modify the data in 
the Entry, and tap the Update button. The data is now modified in the List 
widget and saved in the DB.  
   
 
5) Deleting Records  
We will implement a feature that deletes selected records by tapping a 
third Button. For this, we need to add a third Button. Add the Button -
creating code in the create_base_gui() function.  
┌─────────── ──────────┐  
            /* Button -Update */  
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Update");  
            evas_object_smart_callback_add(btn, "clicked", btn_update_cb, ad);  
            my_table_pack(table, btn, 1, 1, 1, 1);  
 
            /* Button -Del */  
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Del");  
            evas_object_smart_callback_add(btn, "clicked", btn_del_cb, ad);  
            my_table_pack(table, btn, 2, 1, 1, 1);  
 

  
Page 815 / 978             /* List */  
            ad->list = elm_list_add(ad ->conform);  
            elm_list_mode_set(ad ->list, ELM_LIST_COMPRESS);  
            elm_list_go(ad ->list); 
            my_table_pack(table, ad ->list, 0, 2, 3, 8);  
└─────────────────────┘  
Then, add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static int  
DelRecord(appdata_s *ad)  
{ 
    char sql[256];  
    char *ErrMsg;  
    snprintf(sql, 256, "DELETE FROM ReportCard WHE RE KEY= \'%s\';", ad ->current_k
ey); 
  
    int ret = sqlite3_exec(ad ->db, sql, NULL, 0, &ErrMsg);  
    return ret;  
} 
  
static void  
btn_del_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    DelRecord(ad);  
  
    read_db(ad);  
} 
└─────────────────────┘  
DelRecord() is a function that deletes the records saved in the DB.  
  
Page 816 / 978 From the query statement, 'DELETE FROM ReportCard' deletes data from 
the ReportCard table.  
WHERE KEY= \’%s\’ deletes records whose Key values are the same.  
btn_del_ cb() is a function that deletes the currently selected List item when 
the user taps the Del button.   
Run the example again. Add some other items, select one of the List items, 
and tap the Del button. The selected item will be deleted.  
   
 
6) Related API s 
int sqlite3_exec(sqlite3*, char *, int (*callback), void *, char **): an API that 
carries out an SQL query statement. The parameters listed in order are an 
SQLite object, query statement, name of the callback function, user data, 
and error message return . 
int sqlite3_shutdown(): an API that closes the DB.  
int sqlite3_config(int, ...): an API that defines the properties of the DB. 

  
Page 817 / 978 Passing SQLITE_CONFIG_URI saves data in the DB file.  
int sqlite3_initialize(): an API that initializes the DB.  
char *app_get_da ta_path(): an API that returns the absolute path of the 
/data folder. The /res folder does not allow writing, so we will create a DB 
file in the /data folder.  
char *strncat(char *, char *, size_t): an API that adds a new string at the 
end of a string by de fining the maximum length of the string. The 
parameters listed in order are original string arrays, string data to be 
added, and maximum length.  
int sqlite3_open(char *, sqlite3 **): an API that opens the DB file.  You need 
to create a DB file if it does not already exist. Passing the file path to the 
first parameter makes the second parameter return the DB object.  
  
  
Page 818 / 978 62. Calling an External App Using AppControl  
When you develop an app, you may need to add features like an image 
viewer or camera. Realizing all the required features through hard coding 
would be rather difficult, but there simpler ways to achieve your aims. 
AppControl refers to apps installed on the Tizen platform as default. You 
can load this AppControl from other apps. Even though the apps are n ot 
default ones, you can load AppControl if you know the package name.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as 
'AppControlEx.' You need to have the applicable user privileges to run an 
external app. After the  source project is created, open the tizen -
manifest.xml file, and click Privileges among the tab buttons below. Then, 
click the Add button in the upper right corner. When the popup  window 
appears, select http://tizen.org/privilege/appmanager.launch from the list, 
and click the OK button to close the window.  
  
Page 819 / 978  
Repeat the same process to add the following two user privileges.  
 - http://tizen.org/privilege/internet  
 - http://tizen.org/ privilege/email  
After saving, click the tizen -manifest.xml button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<manifest xmlns="http://tizen.org/ns/pa ckages" api -version="2.3" package="org. exam
ple.appcontrolex" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .appcontrolex" exec="appcontrolex" multiple="f
alse" nodisplay="false" taskmanage="true" type="capp">  
        <label>appcontrolex</label>  
        <icon>appcontrolex.png</icon>  
    </ui-application>  
    <privileges>  

  
Page 820 / 978         <privilege>http://tizen.org/privilege/internet</privilege>  
        <privilege>http://tizen.org/privilege/appmanager.launch</privilege>  
        <privilege>http://tizen.org/privilege/email</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  
 
2) Loading the Example  
Open the source file (~.c) under the src folder, and add library header files, 
variables, and a structure.  
┌─────────────────────┐  
#include "appcontrolex.h"  
#include <app.h>  
#include <app_control.h>  
  
#define FM_PHONE_FOLDER    "/opt/usr/media"  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
└───── ────────────────┘  
app.h and app_control.h are library header files to use AppControl.  
“/opt/usr/media” is a root path for the shared folder.  
  
  
Page 821 / 978 Let’s load the HelloWorld example from all the examples we have built so 
far. Add the Box - and Button -creating co de to the create_base_gui() 
function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { /* child object - indent to how relationsh ip */ 
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, bo x); 
        evas_object_show(box);  
 
        { /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->win);  
            elm_object_text_set(ad ->label, "<align=center>Hello Tizen</>");  
            evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS
_HINT_EXPAND);  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Sample App");  
  
Page 822 / 978             evas_object_smart_callback_add(btn, "clicked", btn_sample_app_cb, ad);  
            /* epand both horiz and vert, fill horiz and vert */  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
Create two functions on top of the create_base_gui() function.  
 ┌─────────────────────┐  
static void  
btn_sample_app_cb(void *data, Evas_Object *obj,  void *event_info)  
{ 
    appdata_s *ad = data;  
  
    app_control_h app_control;  
    app_control_create(&app_control);  
    app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    app_control_set_app_id (app_control, "org. example .helloworl d"); 
  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_E
RROR_NONE)  
       dlog_print(DLOG_INFO, "tag", "Succeeded to launch a Helloworld app.");  
    else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch a calculator app ."); 
  
    app_control_destroy(app_control);  
} 
 
static void  
  
Page 823 / 978 my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the 
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(frame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center i n it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
Btn_sample_app_cb() is a Button callback function.  
app_control_h is an AppControl structure.  
app_control_create(app_control_h *) is an API that creates an AppControl 
  
Page 824 / 978 object.  
app_control_set_operation(app_control_h, char *) is an  API that specifies 
the role of AppControl. When loading an external app, simply pass 
APP_CONTROL_OPERATION_DEFAULT.  
app_control_set_app_id(app_control_h, char *) is an  API that specifies the 
package name of the example to be loaded to AppControl. The package 
name of the HelloWorld example is "org.example.helloworld."  
app_control_send_launch_request(app_control_h, app_contro l_reply_cb, 
void *) is an API that runs AppControl.  
app_control_destroy(app_control_h) is an API that deletes the AppControl 
object.  
my_box_pack() is a function that adds a widget to a Box.  
Before running the example, check if the HelloWorld example is ins talled 
on the emulator. If it is not installed yet, create a source project with the 
name 'HellowWorld,' and install it on the emulator.  
Once the HellowWorld example is installed on the emulator, build the 
AppControlEx example and run it. Tap the Button, a nd the HelloWorld 
example will run.  
  
Page 825 / 978    
 
3) Passing Data to Other Apps  
Now, we are going to pass data when loading the HelloWorld example. 
Add new code to the btn_sample_app_cb() function of the appcontrolex.c 
file. 
┌[appcontrolex.c]──────────────┐  
static void  
btn_sample_app_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    app_control_h app_control;  
    app_control_create(&app_control);  
    app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    app_con trol_add_extra_data(app_control, "pet", "dog");  
    app_control_add_extra_data(app_control, "dessert", "juice");  
    app_control_set_app_id (app_control, "org.example.helloworld");  
  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_C ONTROL_E
RROR_NONE)  
       dlog_print(DLOG_INFO, "tag", "Succeeded to launch a Helloworld app.");  

  
Page 826 / 978     else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch a calculator app.");  
  
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_add_extra_data(app_control_h, char *, char *) is an  API that 
adds data to AppControl. The parameters listed in order are an AppControl 
object, Key values, and text data.  
The sending part has been built. Now, we will implement the receiving 
part. Open the source file (/src/helloworld.c) of the HelloWorld example, 
and add a global variable at the top.  
┌[helloworld.c]───────────── ──┐ 
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
} appdata_s;  
  
char recv_data[100];  
└─────────────────────┘  
Event functions are called as many as the added number of data to 
AppControl. To save all the data, global variables have been declared.  
Go to the bottom of the source file, you will see the app_control() function. 
This is the event function of AppControl. Now, add new code and functions.  
  
  
Page 827 / 978 ┌[helloworld.c]─────── ─────────┐  
bool _app_control_extra_data_cb(app_control_h app_control, const char *key, void 
*data)  
{ 
    int ret;  
    char *value;  
  
    ret = app_control_get_extra_data(app_control, key, &value);  
    strcat(recv_data, key);  
    strcat(recv_data, ":");  
    strcat(recv_data, value);  
    strcat(recv_data, " / ");  
  
    appdata_s *ad = data;  
    elm_object_text_set(ad ->label, recv_data);  
    return true; 
} 
  
static void  
app_control(app_control_h app_control, void *data)  
{ 
    app_control_foreach_extra_data(app_control, _app_control_extra_data_cb, data);  
} 
└─────────────────────┘  
  
  
Page 828 / 978 _app_control_extra_data_cb() is a callback function that receives indi vidual 
data. As we passed two data in the AppControlEx example, this function 
will be called twice.  
app_control_get_extra_data(app_control_h, char *, char **) is an API that 
extracts data from AppControl. Passing a Key to the second parameter 
makes the thi rd parameter return the data.  
app_control() is a callback function which is run when an AppControl 
object is received.  
app_control_foreach_extra_data(app_control_h, app_control_extra_data_cb, 
void *) is an API that specifies a processing function for indi vidual data 
saved in the AppControl object.  
We will install the HelloWorld example on the emulator, and then run the 
AppControlEX example. When you tap the Button, the HelloWorld example 
will run, and the data passed from the AppControlEX example will be 
displayed in the Label widget.  
 
 
  

  
Page 829 / 978 4) Camera AppControl  
Now, we will learn how to load the camera app from among the default 
apps. Go to the source file of the AppControlEX example, and create a 
new Button at the end of the create_base_gui() function.  
┌[appcontrolex.c]──────────────┐  
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Sample App");  
            evas_object_smart_callback_add(btn, "clicked", btn_sample_app_cb, ad);  
            /* epand both horiz and vert, fill horiz and vert */  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Camera");  
            evas_object_smart_callback_add(btn, "clicked", btn_camera_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
Now, we are going to create a callback function for the second Button. 
Add a new  function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_camera_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    app_control_h app_control;  
  
    app_control_create(&app_control);  
  
Page 830 / 978     app_control_set_operation(app_control, APP_CONTROL_OPERATION_CREATE_CONTE
NT); 
    app_control_set_mime(app_control, "image/jpg");  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_E
RROR_NONE)  
       dlog_print(DLOG_INFO, " tag", "Succeeded to launch camera app.");  
    else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch camera app.");  
  
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_set_operation(app_control_h, char *) is an  API that specif ies 
the role of AppControl. When you take a picture, an image file will be 
created. So, you need to pass 
APP_CONTROL_OPERATION_CREATE_CONTENT.  
app_control_set_mime(app_control_h, char *) is an  API that specifies the 
MIME type. There might be different kind s of camera  apps installed. That 
is why you should specify the MIME type rather than a certain app.  
Run the example again and tap the second Button. Then, the camera app 
will be run. If the emulator cannot be run, you can test it from your phone.  
  
Page 831 / 978    
 
5) Email AppControl  
Now, we will learn how to load the email app from among the default 
apps. Create a new Button at the end of the create_base_gui() function.  
┌─────────────────────┐  
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Camera");  
            evas_object_smart_callback_add(btn, "clicked", btn_camera_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "E -mail");  
            evas_object_smart_callback_add(btn, "clicked", btn_email_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  

  
Page 832 / 978 Then, we are going to c reate a callback function for the third Button. Add 
a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_email_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    app_control_h app_control;  
    char *mail_ad dress = "topofsan@naver.com";  
    char *subject = "Tutorial message title";  
    char *message = "Tutorial message content.";  
  
    app_control_create(&app_control);  
    app_control_set_operation(app_control, APP_CONTROL_OPERATION_COMPOSE);  
    app_control_ set_app_id(app_control, "email -composer -efl"); 
    app_control_add_extra_data(app_control, APP_CONTROL_DATA_TEXT, message);  
    app_control_add_extra_data(app_control, APP_CONTROL_DATA_TO, mail_address);  
    app_control_add_extra_data(app_control, APP_CONT ROL_DATA_SUBJECT, subject);  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_E
RROR_NONE)  
       dlog_print(DLOG_INFO, "tag", "Succeeded to launch e -mail app.");  
    else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch e-mail app.");  
  
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_set_operation(app_control_h, char *) is an  API that specifies 
the role of AppControl. When sending an email, pass 
APP_CONTROL_OPERATION_COMPOSE.  
  
  
Page 833 / 978 app_control_set_ app_id(app_control_h, char *) is an  API that specifies the 
package name of the example to be loaded to AppControl. Sending an 
email works with "email -composer -efl." 
app_control_add_extra_data(app_control_h, char *, char *) is an  API that 
adds data to AppCo ntrol. The parameters listed in order are an AppControl 
object, Key values, and text data. Keys that are used for the email are as 
follows:  
 - APP_CONTROL_DATA_TEXT: Body of the email  
 - APP_CONTROL_DATA_TO: The recipient’s email address  
 - APP_CONTROL_DAT A_SUBJECT: Subject (title) of the email  
Run the example again and tap the third Button.  The email app will run. 
If the emulator cannot be run, you can test it from your phone.  
   
 
  

  
Page 834 / 978 6) Image Viewer AppControl  
Now, we will learn how to load the Image Viewer app from among the 
default apps. You need an image file to display an image in the Image 
Viewer app.  Check if the 0.jpg file exists in the /opt/usr/media/Images 
folder of the emulator. If the file does not exist, copy the 0.jpg file from 
the /image folder of the appendix to the user device. Now, simply drag 
the file from the Eclipse Connection Explorer to the 
/opt/usr/media/Images folder.  
 
Create a new Button at the end of the create_base_gui() function.  
  

  
Page 835 / 978 ┌─────────────────────┐  
            /* Butt on-3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "E -mail");  
            evas_object_smart_callback_add(btn, "clicked", btn_email_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -4 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Image Viewer");  
            evas_object_smart_callback_add(btn, "clicked", btn_image_viewer_cb, a
d); 
            my_box_pack(box, btn, 1.0, 1.0,  -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
Next, we are going to create a callback function for the fourth Button. Add 
a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_image_viewer_cb(void *data, E vas_Object *obj, void *event_info)  
{ 
    app_control_h app_control;  
    char buf[PATH_MAX];  
    strcat(buf, FM_PHONE_FOLDER);  
    strcat(buf, "/Images/0.jpg");  
  
    app_control_create(&app_control);  
    app_control_set_operation(app_control, APP_CONTROL_O PERATION_VIEW);  
    app_control_set_uri(app_control, buf);  
    app_control_set_mime(app_control, "image/*");  
  
  
Page 836 / 978 if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_ERR
OR_NONE)  
       dlog_print(DLOG_INFO, "tag", "Succeeded to launch Image Viewer app.");  
    else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch Image Viewer app.");  
  
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_set_operation(app_control_h, char *) is an  API that specifies 
the role of  AppControl. When loading the Image Viewer app, simply pass 
APP_CONTROL_OPERATION_VIEW.  
app_control_set_uri(app_control_h, char *) is an  API that specifies the path 
of content. The path of the image file is specified.  
app_control_set_mime(app_control_h, ch ar *) is an  API that specifies the 
MIME type. There might be different kinds of Image  Viewer  apps installed. 
That is why we should specify the MIME type rather than a specific app.  
Run the example again and tap the fourth Button. Then, Image View will 
be run. 
  
Page 837 / 978    
 
  

  
Page 838 / 978 7) Web Browser AppControl  
Now, we will learn how to load the web browser app from among the 
default apps. Create a new Button at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
            /* Button -4 */ 
            btn = elm _button_add(ad ->conform);  
            elm_object_text_set(btn, "Image Viewer");  
            evas_object_smart_callback_add(btn, "clicked", btn_image_viewer_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -5 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Web browser");  
            evas_object_smart_callback_add(btn, "clicked", btn_web_browser_cb, a
d); 
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
Next, we are going to create a callback function for the fifth Button. Add 
a new function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_web_browser_cb(void *data, Evas_Object *obj, void *event_inf o) 
{ 
    app_control_h app_control;  
  
    app_control_create(&app_control);  
  
Page 839 / 978     app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    app_control_set_app_id(app_control, "com.samsung.browser");  
    app_control_set_uri(app_control, "www .tizen.org");  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_E
RROR_NONE)  
        dlog_print(DLOG_INFO, "tag", "Succeeded to launch browser app.");  
    else 
        dlog_print(DLOG_INFO, "tag", "Failed to launch browser app. "); 
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_set_app_id(app_control_h, char *) is an  API that specifies the 
package name of the example to be loaded to AppControl. The package 
name of the default web browser app is "com.s amsung.browser."  
app_control_set_uri(app_control_h, char *) is an  API that specifies the path 
of content. In this case, we specified the Tizen website address.  
Run the example again and tap the fifth Button. The web browser will run.  
     
 

  
Page 840 / 978 8) Related APIs 
int app_control_create(app_control_h *): creates an AppControl object.  
int app_control_set_operation(app_control_h, char *):  an API that specifies 
the role of AppControl. When loading an external app, simply pass 
APP_CONTROL_OPERATION_DEFAULT.  
int app _control_set_app_id(app_control_h, char *):  an API that specifies the 
package name of the example to be loaded to AppControl. The package 
name of the HelloWorld example is "org.example.helloworld."  
int app_control_send_launch_request(app_control_h, app_con trol_reply_cb, 
void *): an API that runs AppControl.  
int app_control_destroy(app_control_h): deletes the AppControl object.  
int app_control_add_extra_data(app_control_h, char *, char *):  an API that 
adds data to AppControl. The parameters listed in order a re an AppControl 
object, Key values, and text data.  
int app_control_get_extra_data(app_control_h, char *, char **):  an API that 
extracts data from AppControl. Passing a Key to the second parameter 
makes the third parameter return the data.  
int app_control_ foreach_extra_data(app_control_h, 
app_control_extra_data_cb, void *): an API that specifies a processing 
function for individual data saved in the AppControl object.  
  
  
Page 841 / 978 int app_control_set_operation(app_control_h, char *):  an API that specifies 
the role of AppControl. When you take a picture, an image file will be 
created. So, you need to pass 
APP_CONTROL_OPERATION_CREATE_CONTENT.  
int app_control_set_mime(app_control_h, char *):  an API that specifies the 
MIME type.  
int app_control_set_operation(app_control_h , char *):  an API that specifies 
the role of AppControl. When sending an email, pass 
APP_CONTROL_OPERATION_COMPOSE. When loading the Image Viewer 
app, pass APP_CONTROL_OPERATION_VIEW.  
int app_control_set_app_id(app_control_h, char *):  an API that specifies  the 
package name of the example to be loaded to AppControl. Sending an 
email works with "email -composer -efl." The package name of the default 
web browser app is "com.samsung.browser."  
int app_control_add_extra_data(app_control_h, char *, char *):  an API t hat 
adds data to AppControl. The parameters listed in order are an AppControl 
object, Key values, and text data. Keys that are used for the email are as 
follows:  
 - APP_CONTROL_DATA_TEXT: Body of the email  
 - APP_CONTROL_DATA_TO: The recipient’s email addr ess 
 - APP_CONTROL_DATA_SUBJECT: Subject (title) of the email.  
int app_control_set_uri(app_control_h, char *):  an API that specifies the 
path of content.  
  
  
Page 842 / 978 63. Developing a Service App  
Service is an app running in the background without a UI visible to the 
user. Features such as antivirus, anti -theft, and communication features are 
often implemented using a Service app.  
 
1) Creating a Source Project for Service  
The first step is to create a new source project. Select [File > New Tizen 
Native Project] from the main menu of Eclipse.  
When a popup  window appears, select [Template > MOBILE -2.x > Service 
Application].  
Enter 'ServiceEx' in the Project name field and click Finish.  
  
Page 843 / 978  
We are now going to implement a feature that automatically terminates a 
Service app 5 s econds after it is launched. Open the source file (~.c) under 
the src folder and add a #define constant and variables.  
┌─────────────────────┐  
#include <service_app.h>  
#include "serviceex.h"  
#include <ecore.h>  
  
Ecore_Timer *timer1;  
int timer_count = 0;  
└─────────────────────┘  
Ecore_Timer is the Timer structure.  
Enter the count of the Timer event occurrences in timer_count.  

  
Page 844 / 978 We will make it so that a Timer is launched automatically when a Service 
app is launched. service_app_create() is an event function t hat is called 
when a Service app is launched. service_app_terminate() is an event 
function that is called when a Service app is launched. Add new code.  
┌─────────────────────┐  
bool service_app_create(void *data)  
{ 
    dlog_print(DLOG_DEBUG, "tag", "%s", __ func__);  
    timer_count = 0;  
    timer1 = ecore_timer_add(1.0, timer1_cb, NULL);  
    return true;  
} 
  
void service_app_terminate(void *data)  
{ 
    dlog_print(DLOG_DEBUG, "tag", "%s", __func__);  
    return;  
} 
└─────────────────────┘  
This code displays a log message when an app is launched and terminated. 
This code also starts a Timer when an app is launched.  
We are now going to create a callback function for the Timer event. Add 
a new function on top of the service_app_create() function.  
┌──────────────── ─────┐  
static Eina_Bool  
timer1_cb(void *data EINA_UNUSED)  
{ 
    timer_count ++;  
    char buf[100];  
  
Page 845 / 978     sprintf(buf, "Count - %d", timer_count);  
    dlog_print(DLOG_DEBUG, "tag", "%s - %s", __func__, buf);  
  
    if( timer_count > 5 )  
        service_app_exi t(); 
    return ECORE_CALLBACK_RENEW;  
} 
└─────────────────────┘  
timer1_cb() is the Timer event function. Executed once every second, this 
function displays a log message and, 5 seconds later, automatically 
terminates the app.  
service_app_exit() is an API t hat terminates a Service app.  
Build and run the example. No changes occur on the emulator. This is 
because Service apps do not have a UI screen. We are now going to view 
the log message. To view log messages, select a Tag from the combo box 
at the bottom o f the Eclipse Log pane and enter 'tag' in the Edit box to 
the right. An app start message, six counts, and an app termination 
message are displayed.  
 

  
Page 846 / 978 2) Sending an Event from an External App to a Service App  
In this section, we are going to implement a feature that terminates a 
Service app by letting an external app send an event. The process is the 
same as when passing data from the AppControlEx example to the 
HelloWorld example.  
The service_app_control() function in the source file is the AppControl 
event function. Add new code to this function and add a new function on 
top of it.  
┌─────────────────────┐  
bool _app_control_extra_data_cb(app_control_h app_control, const char *key, void 
*data)  
{ 
    int ret;  
    char *value;  
  
    ret = app_control_get_ext ra_data(app_control, key, &value);  
    dlog_print(DLOG_DEBUG, "tag", "%s - %s : %s", __func__, key, value);  
    if( strcmp(key, "dessert") == 0 && strcmp(value, "juice") == 0 )  
    { 
        dlog_print(DLOG_DEBUG, "tag", "Close message received");  
        service_app_exit();  
    } 
    return true;  
} 
  
void service_app_control(app_control_h app_control, void *data)  
{ 
    dlog_print(DLOG_DEBUG, "tag", "%s", __func__);  
    app_control_foreach_extra_data(app_control, _app_control_extra_data_cb, NULL);  
    return; 
  
Page 847 / 978 } 
└─────────────────────┘  
_app_control_extra_data_cb() is a callback function that receives individual 
data. If two pieces of data are saved in AppControl, this function is called 
twice. 
app_control_get_extra_data(app_control_h, char *, char **) is an API that 
extracts data from AppControl. Passing a key to the second parameter 
makes the third parameter return data.  
service_app_control() is a callback function which is run when an 
AppControl object is received.  
app_control_foreach_extra_data(app_contro l_h, app_control_extra_data_cb, 
void *) is an API that specifies a function that processes individual data 
saved in an AppControl object.   
Modify the code of the timer1_cb() function as follows. The Service app is 
automatically terminated after 5 seconds, and therefore it is necessary to 
specify a longer time.  
┌─────────────────────┐  
static Eina_Bool  
timer1_cb(void *data EINA_UNUSED)  
{ 
    timer_count ++;  
    char buf[100];  
    sprintf(buf, "Count - %d", timer_count);  
    dlog_print(DLOG_DEBUG, "tag", "%s - %s", __func__, buf);  
  
    //if( timer_count > 5 )  
  
Page 848 / 978     if( timer_count > 50 )  
        service_app_exit();  
    return ECORE_CALLBACK_RENEW;  
} 
└─────────────────────┘  
We are now going to implement a feature that makes an external app call 
a Service app. Ope n the source file we created previously in the 
AppControlEx example. Then, add Button -creating code at the end of the 
create_base_gui() function.  
┌[appcontrolex.c]─────── ───┐  
            /* Button -5 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Web browser");  
            evas_object_smart_callback_add(btn, "clicked", btn_web_browser_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -6 */ 
            btn = elm_button_add(a d->conform);  
            elm_object_text_set(btn, "Service close");  
            evas_object_smart_callback_add(btn, "clicked", btn_service_close_cb, a
d); 
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
Add a  Button callback function on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
  
Page 849 / 978 btn_service_close_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
  
    app_control_h app_control;  
    app_control_create (&app_control);  
    app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    app_control_add_extra_data(app_control, "pet", "dog");  
    app_control_add_extra_data(app_control, "dessert", "juice");  
    app_control_set_app_id (app_control, "org.example .serviceex");  
  
    if (app_control_send_launch_request(app_control, NULL, NULL) == APP_CONTROL_E
RROR_NONE)  
       dlog_print(DLOG_INFO, "tag", "Succeeded to launch a Service app.");  
    else 
       dlog_print(DLOG_INFO, "tag", "Failed to launch a Service app.");  
  
    app_control_destroy(app_control);  
} 
└─────────────────────┘  
app_control_h is an AppControl structure.  
app_control_create(app_control_h *) is an API that creates an AppControl 
object.  
app_control_set_operation(app_control_h, c har *) is an API that specifies 
the role of AppControl. To load an external app, pass 
APP_CONTROL_OPERATION_DEFAULT.  
app_control_add_extra_data(app_control_h, char *, char *) is an API that 
adds data to AppControl. The parameters listed in order are an App Control 
  
Page 850 / 978 object, Key values, and text data.  
app_control_set_app_id(app_control_h, char *) is an  API that specifies the 
package name of the example to be loaded to AppControl.  
app_control_send_launch_request(app_control_h, app_control_reply_cb, 
void *) is an  API that runs AppControl.  
app_control_destroy(app_control_h) is an API that deletes an AppControl 
object.  
Run the Service app and then run the AppControlEx example. Tap the sixth 
Button. The Service app will stop displaying log messages. In other words, 
the Service app has been terminated.  
   
 
  

  
Page 851 / 978 3) Related APIs  
app_control_h: the AppControl structure.  
int app_control_create(app_control_h *): an API that creates an AppControl 
object.  
int app_control_set_operation(app_control_h, char *): an API that specif ies 
the role of AppControl. To load an external app, pass 
APP_CONTROL_OPERATION_DEFAULT.  
int app_control_add_extra_data(app_control_h, char *, char *): an API that 
adds data to AppControl. The parameters listed in order are an AppControl 
object, Key values , and text data.  
int app_control_set_app_id(app_control_h, char *): an API that specifies the 
package name of the example to be loaded to AppControl.  
int app_control_send_launch_request(app_control_h, app_control_reply_cb, 
void *): an API that runs AppCont rol. 
int app_control_destroy(app_control_h): an API that deletes an AppControl 
object.  
int app_control_get_extra_data(app_control_h, char *, char **): an API that 
extracts data from AppControl. Passing a key to the second parameter 
makes the third parameter return data.  
int app_control_foreach_extra_data(app_control_h, 
app_control_extra_data_cb, void *): an API that specifies a processing 
function for individual data saved in the AppControl object.  
  
Page 852 / 978 64. Alarm : Starting an APP at a Specified Time  
When you  develop an alarm app such as a wake -up call app, it is necessary 
to enable the app to be started automatically after a specified amount of 
time, even when it is closed. Using Alarm makes it possible to enable an 
app to be started at a specified time. It h as a Timer feature, and therefore 
it can also enable an App to be started after a certain amount of time has 
passed. Alarm works in a similar way to AppControl.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as 'Alarm. ' You 
need to have the applicable user privileges to use the Alarm. After the 
source project is created, open the tizen -manifest.xml file, and click 
Privileges among the tab buttons below. Then, click the Add button in the 
upper right corner. When the popup window appears, select 
http://tizen.org/privilege/alarm.set from the list, and click the OK button 
to close the window.  
  
Page 853 / 978  
After saving, click the ‘tizen -manifest.xml’ button in the far right corner 
from the tab buttons located at the bottom; you should b e able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.alarm" version="1.0.0">  
    <profile name="m obile"/>  
    <ui-application appid="org. example .alarm" exec="alarm" multiple="false" nodisplay
="false" taskmanage="true" type="capp">  
        <label>alarm</label>  
        <icon>alarm.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http ://tizen.org/privilege/alarm.set</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 854 / 978 2) Starting a Timer Alarm  
In this section, we are going to implement a feature that runs the 
HelloWorld example 3 seconds after a Button is tapped. If the HelloWorld 
example has not been installed on your emulator, install the HelloWorld 
example first. Open the source file (~.c) under the src folder and add 
library header files and variables.  
┌─────────────────────┐  
#include "alarm.h"  
#include <app_alarm.h>  
#include <time.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    int timer_id;  
    int date_id;  
} appdata_s;  
└─────────────────────┘  
app_alarm.h is a library header file for using an Alarm.  
time.h is a library header file for using time -related APIs.  
In timer_id, we will enter the ID of the Timer Alarm. We can terminate the 
Alarm using this.  
In date_id, we will enter the ID of the Date Alarm. We can terminate the 
Alarm using this.  
  
Page 855 / 978 Add a new function on  top of the create_base_gui() function. This function 
adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child,  
            double h_weight, double v_weight, double h_align, double v_align)  
{ 
   /* create a frame we shall use as padding around the child widget */  
   Evas_Object *frame = elm_frame_add(box);  
   /* use the medium padding style. there is "pad_small", "pad_medium",  
    * "pad_large" and "pad_huge" available as styles in addition to the  
    * "default" frame style */  
   elm_object_style_set(frame, "pad_medium");  
   /* set the input weight/aling on the frame insted of the child */  
   evas_object_size_hint_weight_set(fr ame, h_weight, v_weight);  
   evas_object_size_hint_align_set(frame, h_align, v_align);  
     { 
        /* tell the child that is packed into the frame to be able to expand */  
        evas_object_size_hint_weight_set(child, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
        /* fill the expanded area (above) as opposaed to center in it */  
        evas_object_size_hint_align_set(child, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        /* actually put the child in the frame and show it */  
        evas_object_show(child);  
        elm_object_content_set(frame, child);  
     } 
   /* put the frame into the box instead of the child directly */  
   elm_box_pack_end(box, frame);  
   /* show the frame */  
   evas_object_show(frame);  
} 
└─────────────────────┘  
  
Page 856 / 978 Add Button -creating code at the  end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        /* child object - indent to how re lationship */  
        /* A box to put things in verticallly - default mode for box */  
        Evas_Object *box = elm_box_add(ad ->win);  
        evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* child object - indent to how relationship */  
            /* Label*/  
            ad->label = elm_label_add(ad ->conform);  
            elm_object_text_set(ad ->label, "<align=center>Hello Tizen</>");  
            /* expand horizontally but not vertically, and fill horiz,  
            * align center vertically */  
            my_box_pack(box, ad ->label, 1.0, 0.0, -1.0, 0.5);  
 
            /* Button -1 */ 
            Evas_Object *btn = elm_button_ add(ad ->conform);  
            elm_object_text_set(btn, "Start Timer Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_start_timer_cb, ad);  
  
Page 857 / 978             /* epand both horiz and vert, fill horiz and vert */  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
Add a Button callback function on top of the create_base_gui() function.  
┌──── ─────────────────┐  
static void  
btn_start_timer_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int ret;  
    int DELAY = 3;  
    int REMIND = 0;  
  
    app_control_h app_control = NULL;  
    ret = app_control_create(&app_cont rol); 
    ret = app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    ret = app_control_set_app_id (app_control, "org. example .helloworld");  
    ret = alarm_schedule_after_delay(app_control, DELAY, REMIND, &ad ->timer_id);  
    dlog_print (DLOG_DEBUG, "tag", "result = %d", ret);  
    elm_object_text_set(ad ->label, "Timer Alarm Started");  
} 
└─────────────────────┘  
app_control_h is an AppControl structure.  
 
  
Page 858 / 978 app_control_create(app_control_h *) is an API that creates an AppControl 
object.  
app_control_set_operation(app_control_h, char *) is an API that specifies 
the role of AppControl. To load an external app, pass 
APP_CONTROL_OPERATION_DEFAULT.  
app_control_set_app_id(app_control_h, char *) is an  API that specifies the 
package name of the ex ample to be loaded to AppControl. The package 
name of the HelloWorld example is "org.example.helloworld."  
alarm_schedule_after_delay(app_control_h, int, int, int *) is an API that 
passes an AppControl event after a certain amount of time has passed. 
The se cond parameter indicates the time interval for the first execution, 
and the third parameter indicates the time interval for re -executions. 
Entering 0 runs the AppControl event only once. The fourth parameter 
receives the ID of the Alarm, which is necessary  for terminating the Alarm.  
Build and run the example. Tap the Button, and the HelloWorld example 
will be run after 3 seconds.  
   

  
Page 859 / 978 3) Terminating a Timer Alarm  
In this section, we are going to implement a feature that adds a Button to 
the Alarm example an d terminates the Alarm. Add new code at the end 
of the create_base_gui() function.  
┌─────────────────────┐  
            /* Button -1 */ 
            Evas_Object *btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Start Timer Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_start_timer_cb, ad);  
            /* epand both horiz and vert, fill horiz and vert */  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Stop Timer Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_stop_timer_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
Then, create a Button callback function on top of the create_base_gui() 
function and modify the btn_start_timer_cb() function.  
┌─────────────────────┐  
static void  
btn_start_timer_cb(void *data, Evas_Object *obj, void *event_in fo) 
{ 
    appdata_s *ad = data;  
    int ret;  
    int DELAY = 3;  
  
Page 860 / 978     //int REMIND = 0;  
    int REMIND = 8;  
  
    app_control_h app_control = NULL;  
    ret = app_control_create(&app_control);  
    ret = app_control_set_operation(app_control, APP_CONTROL_OPERA TION_DEFAULT);  
    ret = app_control_set_app_id (app_control, "org. example .helloworld");  
    ret = alarm_schedule_after_delay(app_control, DELAY, REMIND, &ad ->timer_id);  
    dlog_print(DLOG_DEBUG, "tag", "result = %d", ret);  
    elm_object_text_set(ad ->label, "Timer Alarm Started");  
} 
 
static void  
btn_stop_timer_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    alarm_cancel(ad ->timer_id);  
    elm_object_text_set(ad ->label, "Timer Alarm Stopped");  
} 
└─────────────────────┘  
Changing the value of the REMIND variable to 8 runs the HelloWorld 
example every 8 seconds.  
  
  
Page 861 / 978 btn_stop_timer_cb() is a function that terminates the Timer Alarm when 
the user taps a Button.  
alarm_cancel(int alarm_id) is an API that terminates an Alarm. It p asses the 
ID of an Alarm.  
Run the example again and tap the first Button. The HelloWorld example 
is run. Terminate the HelloWorld app; it is then run again every 8 seconds. 
Tap the second Button, and the HelloWorld example will no longer be run: 
the Alarm has been terminated.  
To terminate an Alarm, its ID is required. Therefore, if you have started an 
Alarm, you need to terminate the Alarm by tapping the second Button. If 
the HelloWorld example keeps being run even after you tap the Stop 
button, delete your  emulator and create it again. It will then be reset.  
 
 
  

  
Page 862 / 978 3) Date Alarm  
We are now going to implement a feature that runs a certain app at a 
specified time. Add two Button -creating codes to the create_base_gui() 
function.  
┌─────────────────────┐  
            /* Button -2 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Stop Timer Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_stop_timer_cb, ad);  
            my_box_pack(box, btn, 1.0, 1. 0, -1.0, -1.0); 
 
            /* Button -3 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Start Date Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_start_date_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
 
            /* Button -4 */ 
            btn = elm_button_add(ad ->conform);  
            elm_object_text_set(btn, "Stop Date Alarm");  
            evas_object_smart_callback_add(btn, "clicked", btn_stop _date_cb, ad);  
            my_box_pack(box, btn, 1.0, 1.0, -1.0, -1.0); 
        } 
    } 
└─────────────────────┘  
This is code that creates a third Button and a fourth Button. Then, add a 
Button callback function on top of the create_base_gui() function.  
┌── ───────────────────┐  
static void  
  
Page 863 / 978 btn_start_date_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int ret;  
  
    struct tm date;  
    ret = alarm_get_current_time(&date);  
    date.tm_sec+=4;  
  
    app_control_h app_control =  NULL; 
    ret = app_control_create(&app_control);  
    ret = app_control_set_operation(app_control, APP_CONTROL_OPERATION_DEFAULT);  
    ret = app_control_set_app_id (app_control, PACKAGE);  
    ret = alarm_schedule_at_date(app_control, &date, 0, &ad ->date_id);  
    elm_object_text_set(ad ->label, "Date Alarm Started");  
} 
  
static void  
btn_stop_date_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    alarm_cancel(ad ->date_id);  
    elm_object_text_set(ad ->label, "Date Alarm S topped");  
} 
└─────────────────────┘  
btn_start_date_cb() is a function that creates a Date Alarm.  
struct tm is a time structure where the time and date are saved.  
alarm_get_current_time(struct tm *) is an API that returns the current time 
in struct tm type.  
  
Page 864 / 978 In tm.tm_sec, time is saved in seconds. We specified the execution time as 
4 seconds after the current time.  
alarm_schedule_at_date(app_control_h, struct tm *, int, int *) is an API that 
runs an AppControl event at a specified time. Pass the struct tm obj ect 
that contains the time and date to the second parameter, and pass the re -
execution interval to the third parameter. Passing 0 runs it only once. The 
fourth parameter receives the ID of the Alarm, which is necessary for 
terminating the Alarm.  
btn_stop_d ate_cb() is a function that terminates a Date Alarm.  
Run the example again. Tap the third Button and close the app, and the 
Alarm example is run again.  
This time, tap the third Button and then the fourth Button immediately 
after. Then, close the app, and y ou will see no changes happen, which 
means the Date Alarm has been terminated.  
 
 

  
Page 865 / 978 4) Related APIs  
app_control_h: the AppControl structure.  
int app_control_create(app_control_h *): an API that creates an AppControl 
object.  
int app_control_set_operation(app_ control_h, char *): an API that specifies 
the role of AppControl. To load an external app, pass 
APP_CONTROL_OPERATION_DEFAULT.  
int app_control_set_app_id(app_control_h, char *): an API that specifies the 
package name of the example to be loaded to AppControl. The package 
name of the HelloWorld example is "org.example.helloworld."  
int alarm_schedule_after_delay(app_control_h, int, int, int *): an API that 
passes an AppControl after a certain amount of time has passed. The 
second parameter indicates t he time interval for the first execution, while 
the third parameter indicates the time interval for re -executions. Entering 
0 runs the AppControl event only once. The fourth parameter receives the 
ID of the Alarm, which is necessary for terminating the Ala rm. 
int alarm_cancel(int alarm_id): an API that terminates an Alarm. It passes 
the ID of an Alarm.  
struct tm: a time structure where the time and date can be saved.  
int alarm_get_current_time(struct tm *): an API that returns the current 
time in struct tm type. 
  
  
Page 866 / 978 int alarm_schedule_at_date(app_control_h, struct tm *, int, int *): an API 
that runs an AppControl event at a specified time.Pass the struct tm object 
that contains the time and date to the second parameter, and pass the re -
execution interval to th e third parameter. Passing 0 runs it only once. The 
fourth parameter receives the ID of the Alarm, which is necessary for 
terminating the Alarm.   
  
Page 867 / 978 65. Text to Speech (TTS)  
Text to Speech (TTS) is a feature that reads text aloud in a human voice. 
Speech to Text (STT), meanwhile, is a feature that recognizes a person's 
voice and reproduces it as text. In this example, we are going to learn how 
to use TTS.  
 
1) Adding a Feature  
Create a new source project and specify the project name as 'TtsEx.' To 
use TTS, you need  to add relevant features. After the source project is 
created, open the tizen -manifest.xml file, and click Features among the 
tab buttons below. Then, click the Add button in the upper right corner. 
When a popup  window appears, select 
http://tizen.org/fea ture/speech.recognition from the list, and click the OK 
button to close the window.  
  
Page 868 / 978  
Add the following feature by repeating the procedure above.  
 - http://tizen.org/feature/speech.synthesis  
After saving, click the tizen -manifest.xml button in the far righ t corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.ttsex" version="1.0.0">  
    <profi le name="mobile"/>  
    <ui-application appid="org. example .ttsex" exec="ttsex" multiple="false" nodisplay=
"false" taskmanage="true" type="capp">  
        <label>ttsex</label>  
        <icon>ttsex.png</icon>  
    </ui-application>  
    <feature name="http://tizen.org/feature/speech.recognition">true</feature>  
    <feature name="http://tizen.org/feature/speech.synthesis">true</feature>  

  
Page 869 / 978 </manifest>  
└─────────────────────┘  
 
2) Creating & Deleting TTS  
Open the source file (~.c) under the src folder a nd add library header files 
and variables.  
┌─────────────────────┐  
#include "ttsex.h"  
#include <tts.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object *entry;  
    Evas_Object *button;  
    tts_h tts;  
} appdata_s;  
└─────────────────────┘  
tts.h is a library header file for using TTS.  
We are going to make the Entry widget receive a string input.  
We are going to make it so that the string starts playing when the Button 
widget is tapped.  
tts_h is the TTS structure.  
  
Page 870 / 978 We are now going to implement a feature that automatically creates a TTS 
object when the app is launched and deletes the TTS object when the app 
is closed. Add five new functions on top of the create_base_gui() function.  
┌─────────────── ──────┐  
static void  
state_changed_cb(tts_h tts, tts_state_e previous, tts_state_e current, void* user_data)  
{ 
    appdata_s *ad = user_data;  
 
    switch (current)  
    { 
    case TTS_STATE_PLAYING:  
        elm_object_text_set(ad ->button, "Stop");  
        break;  
    case TTS_STATE_READY:  
    default:  
        elm_object_text_set(ad ->button, "Play");  
        break;  
    } 
} 
 
static void  
utterance_completed_cb(tts_h tts, int utt_id, void *user_data)  
{ 
    appdata_s *ad = user_data;  
 
    dlog_print(DLOG_ INFO, LOG_TAG, "Utterance completed: %d", utt_id);  
    elm_object_text_set(ad ->button, "Stop (idle)");  
} 
 
static void  
utterance_started_cb(tts_h tts, int utt_id, void *user_data)  
  
Page 871 / 978 { 
    appdata_s *ad = user_data;  
 
    dlog_print(DLOG_INFO, LOG_TAG, "Utterance started: %d", utt_id);  
    elm_object_text_set(ad ->button, "Stop (speaking)");  
} 
 
static tts_h  
create_tts_handle(appdata_s *ad)  
{ 
    tts_h tts;  
    int ret = tts_create(&tts);  
    if (TTS_ERROR_NONE != ret)  
    { 
        dlog_print(DLOG_INFO, "tag", "%s err = %d", __func__, ret);  
    } 
    else 
    { 
        tts_set_utterance_started_cb(tts, utterance_started_cb, ad);  
        tts_set_utterance_completed_cb(tts, utterance_completed_cb, ad);  
        tts_set_state _changed_cb(tts, state_changed_cb, ad);  
        tts_prepare(tts);  
    } 
 
    return tts;  
} 
 
static void  
destroy_tts_handle(tts_h tts)  
{ 
    int ret = tts_destroy(tts); // tts is the TTS handle  
    if (TTS_ERROR_NONE != ret)  
    { 
        dlog_print(DLOG_INFO, "tag", "%s err = %d", __func__, ret);  
  
Page 872 / 978     } 
} 
└─────────────────────┘  
state_changed_cb() is a TTS status change event function. The parameters 
listed in order are a TTS object, previous status value, current status value, 
and user data. This function converts the status value into a string and 
displays it on the screen.  
tts_state_e is an INT variable that stores TTS status information. The status 
types are as follows:  
- TTS_STATE_CREATED: TTS created.  
- TTS_STATE_READY: TTS rea dy to play.  
- TTS_STATE_PLAYING: TTS playing.  
- TTS_STATE_PAUSED: TTS paused.  
utterance_completed_cb() is a TTS playing completion event function.  
utterance_started_cb() is a TTS playing start event function.  
create_tts_handle() is a function that creates and then returns a TTS object.  
tts_create(tts_h*) is an API that creates a TTS object.  
  
  
Page 873 / 978 tts_set_utterance_started_cb() is an API that specifies the name of the TTS 
playing start event callback function.  
tts_set_utterance_completed_cb() is an API that specifies the name of the 
TTS playing completion event callback function.  
tts_set_state_changed_cb(tts_h, tts_state_changed_cb, void*) is an API that 
specifies the name of the TTS status change event callback function. The 
parameters listed in order are a TTS object, name of the callback function, 
and user data.  
tts_prepare(tts_h) is an API that changes the status of a TTS object to 
Ready.  
destroy_tts_handle() is a function that deletes a TTS object.  
tts_destroy(tts_h) is an API that deletes a TTS object.  
The functions above need to be called when the app is launched and 
closed.  
Add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_play_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
} 
 
static void  
my_box_pack(Evas_Object *box, Evas_Object *child, double h_weight, double v_weight,  
        double h_align, double v_align)  
  
Page 874 / 978 { 
 /* create a frame we shall use as padding around the child widget */  
evas_object_size_hint_align_set(frame, h_align, v_align);  
{ 
evas_object_show(frame);  
} 
└─────────────────────┘  
btn_play_cb() is the Button event function. We will define the content of 
this function later.  
my_box_pack() is a function that adds a widget to a Box container.  
Add new code to the create_base_gui() funct ion. This code creates a Box, 
an Entry, and a Button. Next, call the function that creates a TTS object.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_S HOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    { 
        Evas_Object *btn, *box;  
 
        /* Container: standard box */  
        box = elm_box_add(ad ->win);  
        elm_box_homogeneous_set(box, EINA_TRUE);  
        elm_box_horizontal_set(box, EINA_FALSE);  
  
Page 875 / 978         evas_object_size_hint_weight_set(box,  EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
        evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_object_content_set(ad ->conform, box);  
        evas_object_show(box);  
 
        { 
            /* Entry */  
            ad->entry = elm_entry_add(box);  
            elm_entry_single_line_set(ad ->entry, EINA_FALSE);  
            elm_entry_scrollable_set(ad ->entry, EINA_TRUE);  
            elm_object_text_set(ad ->entry, "Hello world");  
            my_box_pack(box, ad ->entry, EVAS_HINT_EXPAN D, EVAS_HINT_EXPAN
D, EVAS_HINT_FILL, EVAS_HINT_FILL);  
 
            /* Button -1 */ 
            btn = elm_button_add(box);  
            elm_object_text_set(btn, "Play/Stop");  
            evas_object_smart_callback_add(btn, "clicked", btn_play_cb, ad);  
            my_box_pack(box, btn, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND, EV
AS_HINT_FILL, 0.0);  
            ad->button = btn;  
        } 
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    ad->tts = create_tts_handle(ad);  
} 
└─────────────────────┘  
  
  
Page 876 / 978 Add new code to the app_terminate() function. When the app is closed, 
the TTS object will also be deleted.  
┌─────────────────────┐  
static void  
app_terminate(void *data)  
{ 
    appdata_s *ad = data;  
    destroy_tts_handle(ad ->tts); 
} 
└─────────────────────┘  
Build and run the example. When a TTS object is created and its status 
becomes Ready, the caption text of the Button changes to 'Play.' Now, it 
is ready to play.  
 
 
3) Converting a String to Voice  
In this section, we are going to implement a feature that, when a string is 
entered in an Entry widget and a Button is tapped, outputs the string as 
voice.  
  

  
Page 877 / 978 Add two new functions on top of the create_base_gui() function. Then, fill 
out content in the Button event function.  
┌─────────────────────┐  
static void  
add_text(tts_h tts, appdata_s *ad)  
{ 
    const char* text = "Good morning"; // Text for read  
    const char* language = "en_US"; // Language  
    int voice_type = TTS_VOICE_TYPE_FEMALE; // Voice type  
    int speed = TTS_S PEED_AUTO;  
    int utt_id; // Utterance ID for the requested text  
    text = elm_object_text_get(ad ->entry);  
 
    int ret = tts_add_text(tts, text, language, voice_type, speed, &utt_id);  
    if (TTS_ERROR_NONE != ret)  
    { 
        dlog_print(DLOG_INFO, "t ag", "%s err = %d", __func__, ret);  
    } 
} 
 
static int  
get_state(tts_h* tts)  
{ 
    tts_state_e current_state;  
    int ret;  
    ret = tts_get_state(*tts, &current_state);  
 
    if (TTS_ERROR_NONE != ret)  
    { 
        dlog_print(DLOG_INFO, "tag", "%s state = %d", __func__, ret);  
        return -1; 
    } 
  
Page 878 / 978     else 
    { 
        dlog_print(DLOG_INFO, "tag", "%s state = %d", __func__, current_state);  
        return (int) current_state;  
    } 
} 
 
static void  
btn_play_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    int state = get_state(&ad ->tts); 
    if ((tts_state_e) state == TTS_STATE_READY || (tts_state_e) state == TTS_STAT
E_PAUSED)  
    { 
        add_text(ad ->tts, ad);  
        int ret = tts_play(ad ->tts); 
        if (TTS_ERROR_NONE != ret)  
        { 
            dlog_print(DLOG_INFO, "tag", "%s err = %d", __func__, ret);  
        } 
    } 
    else if ((tts_state_e) state == TTS_STATE_PLAYING)  
    { 
        int ret = tts_stop(a d->tts); 
        if (TTS_ERROR_NONE != ret)  
        { 
            dlog_print(DLOG_INFO, "tag", "%s err = %d", __func__, ret);  
        } 
    } 
} 
└─────────────────────┘  
add_text() is a function that adds a string to a TTS object.  
  
Page 879 / 978 tts_add_text(tts_h, char*,char*, int, int, int*) is an API that adds a string to 
a TTS object. The parameters listed in order are a TTS object, string, voice 
type, and speed.  
The voice types are as follows:  
- TTS_VOICE_TYPE_AUTO: auto voice type.  
- TTS_VO ICE_TYPE_MALE: male voice.  
- TTS_VOICE_TYPE_FEMALE: female voice.  
- TTS_VOICE_TYPE_CHILD: child's voice.  
get_state() is a function that returns the current status of TTS.  
tts_get_state(tts_h tts, tts_state_e* state) is an API that returns the current 
status of TTS.  
btn_play_cb() is a callback function that starts TTS when a Button is tapped. 
This function starts playing TTS when the current status of TTS is Ready 
or Paused, and stops TTS when it is being played.  
tts_play(tts_h tts) is an API that starts the  playback of TTS.  
tts_stop(tts_h tts) is an API that stops the playback of TTS.  
Run the example again. Tap the Button, and TTS will start playing. Tap the 
Button again, and TTS will stop playing. Tap the Button once again, and 
TTS will start playing again.  
  
Page 880 / 978  
 
4) Related APIs  
int tts_create(tts_h*): an API that creates a TTS object.  
int tts_set_state_changed_cb(tts_h tts, tts_state_changed_cb callback, void* 
user_data): an API that specifies the name of the TTS status change event 
callback function. The parameters listed in order are a TTS object, name 
of the callback function, and user data.  
int tts_prepare(tts_h tts): an API that changes the status of a TTS object to 
Ready.  
int tts_destroy(tts_h tts): an API that deletes a TTS object.  
int tts_add_text(t ts_h tts, const char* text, const char* language, int 
voice_type, int speed, int* utt_id): an API that adds a string to a TTS object. 
The parameters listed in order are a TTS object, string, voice type, and 
speed. The voice types are as follows:  
- TTS_VOIC E_TYPE_AUTO: auto voice type.  
- TTS_VOICE_TYPE_MALE: male voice.  
- TTS_VOICE_TYPE_FEMALE: female voice.  
- TTS_VOICE_TYPE_CHILD: child's voice.  

  
Page 881 / 978 int tts_get_state(tts_h tts, tts_state_e* state): an API that returns the current 
status of TTS.  
int tts_play(tts _h tts): an API that starts the playback of TTS.  
int tts_stop(tts_h tts): an API that stops the playback of TTS.   
  
Page 882 / 978 66. Multi-Language Support  
With the opening of the App Store to individual developers, it has become 
possible for developers in Asia to sell their  apps to European consumers. 
However, creating different language versions of an app for multi -
language support can be very difficult and time -consuming. This problem 
is solved by adding language -specific texts that have the same meaning 
saved to Resources  and calling the relevant text when necessary. In this 
example, we are going to learn how to store multi -language information 
in a PO file and call it from the source code.  
1) Adding Multi -Language Information to Resources  
Create a new source project and s pecify the project name as 'MultiLang.' 
Now that a source project has been created, we are now going to add 
multi-language information. Store multi -language information under the 
/res/po folder. Right -click the /res folder and select [New > Folder] in the 
shortcut menu. When a popup  window appears, enter 'po' in the folder 
name field and click the Finish button.  
  
Page 883 / 978  
A multi -language information file is not created automatically, making it 
necessary to create a multi -language information file manually. Right -click 
the /res/po folder and select [New > File] in the shortcut menu. When a 
popup  window appears, enter 'en.po' in the file name field and click the 
Finish button.  

  
Page 884 / 978  
en.po is a file that stores English -related information. Because most apps 
support Englis h, this is an essential multi -language information file. As the 
number of supported languages increases, the number of po files also 
increases. When a po file is created, the content of the file is displayed in 
the Editor. If the Editor does not open autom atically, double -click the en.po 
file. 
When the Add Languages popup  window appears, we will check several 
items (en_US (English), ko_KR (Korean), and ru_RU (Russian)) in the 
language list.  

  
Page 885 / 978  
We are now going to add a message. Click the 'Add String Key' but ton on 
the right of the screen and enter IDS_DONE for MsgID. Then, enter ‘OK’ 
in the English column field. Enter ‘ 확인’ in the Korean field, and enter ‘OK’ 
in the Russian field.  
 

  
Page 886 / 978 We are going to add one more message. Click the 'Add String Key' button 
and th en enter the following text in the newly added item: IDS_CURRENT, 
Current Status, 현재 상태, and Текущее состояние.  
Click the 'Add String Key' button once again and then enter the following 
text in the newly added item: IDS_SELECT_ITEM, Select item, 항목 선택, 
and Выберите элемент.  
 
 
2) Requesting Multi -Language Information from Source Code  
After the source project is created, open the source file (~.c) under the src 
folder and add a variable to the appdata structure.  
┌─────────────────────┐  
typedef struct appdata  { 
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    Evas_Object* naviframe;  
} appdata_s;  
└─────────────────────┘  
We are now going to apply the multi -language text relevant to 
IDS_CURRENT to the Label widget. Then, go to the create_base_gui() 

  
Page 887 / 978 function and modify the Label widget -creating code.  
┌─────────────────────┐  
    /* Label*/  
    ad->label = elm_label_add(ad ->conform);  
    elm_object_text_set(ad ->label, i18n_get_text("IDS_CURRENT"));  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPA
ND); 
    elm_object_content_set(ad ->conform, ad ->label);  
  
     /* Show window after base gui is set u p */ 
     evas_object_show(ad ->win);  
└─────────────────────┘  
i18n_get_text(const char *message) is an API that returns multi -language 
information which corresponds to the language in Settings.  
Build and run the example. The multi -language information you a dded to 
the po file will be displayed on the screen.  
 
 
3) Applying Multi -Language to NaviFrame  
To apply multi -language to the title text of the header, you need to use 
the i18n_get_text() function. You need to use a different method to make 
the change be applied automatically when you have changed the 
language in Settings. Add NaviFrame - and Box -creating code to the 
create_base_gui() function.  

  
Page 888 / 978 ┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_ mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Naviframe */  
    ad->naviframe = elm_naviframe_add(ad ->conform);  
    eext_object_event_callback_add(ad ->naviframe, EEXT_CALLBACK_BACK, win_ba
ck_cb, ad);  
    elm_object_content_set(ad ->conform, ad ->naviframe);  
 
    /* Box */  
    Evas_Object *box = elm_box_add(ad ->naviframe);  
    elm_box_padding_set(box, 0, ELM_SCALE_SIZE(20));  
 
    /* Push a view to naviframe */  
    Elm_Object_Item *nf_it = elm_naviframe_item_push(ad ->naviframe, "IDS_SELE
CT_ITEM", NULL, NULL, box , NULL);  
    /* Mark naviframe title as translatable text */  
    elm_object_item_part_text_translatable_set(nf_it, NULL, EINA_TRUE);  
 
    { 
        /* Label*/  
        ad->label = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label, i18n_get_t ext("IDS_CURRENT"));  
        //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_H
INT_EXPAND);  
        //elm_object_content_set(ad ->conform, ad ->label);  
        evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, 0.0);  
  
Page 889 / 978         evas_object_size_hint_align_set(ad ->label, 0.5, 0.0);  
        elm_box_pack_end(box, ad ->label);  
        evas_object_show(ad ->label);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
└─────────────────────┘  
We created a Naviframe and a Box container and specified the title text 
as "IDS_SELECT_ITEM." Doing so displays the title as "IDS_SELECT_ITEM." 
Therefore, something must be added.  
elm_object_item_part_text_translatable_set(it, part, translatable) is an API 
that makes i t so that the text of an object is requested from Resources. If 
the third parameter is EINA_TRUE, then the text is received from Resources. 
If it is EINA_FALSE, the text entered is used as it is.  
Run the example again. A header will be displayed, with mult i-languages 
applied to the title.  
 
 

  
Page 890 / 978 4) Applying Multi -Language to a Widget  
You need to use a different method to apply multi -language to widgets 
such as Label, Button, and Entry widgets. Add Button - and Label -creating 
code to the create_base_gui() functio n. 
┌─────────────────────┐  
    { 
        /* Label*/  
        ad->label = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label, i18n_get_text("IDS_CURRENT"));  
        evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, 0.0);  
        evas_object_size_hint_align_set(ad ->label, 0.5, 0.0);  
        elm_box_pack_end(box, ad ->label);  
        evas_object_show(ad ->label);  
 
        /* Button */  
        Evas_Object* btn = elm_button_add(ad ->conform);  
        elm_object_translatable_text_set(btn, " IDS_DONE");  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0.0);  
        evas_object_size_hint_align_set(btn, -1.0, 0.0);  
        elm_box_pack_end(box, btn);  
        evas_object_show(btn);  
 
        /* Label*/  
        Evas_Object *o = elm_label_add(ad ->conform);  
        elm_label_line_wrap_set(o, ELM_WRAP_WORD);  
        elm_object_text_set(o, "This label is not translatable.<br/>"  
            "Go to Settings to change the device language and see how the ab
ove it ems will get translated.<br/>"  
            "Supported languages are: English, Korean, Russian.");  
        evas_object_size_hint_weight_set(o, EVAS_HINT_EXPAND, EVAS_HINT_EXPA
ND); 
  
Page 891 / 978         evas_object_size_hint_align_set(o, -1.0, 0.0);  
        elm_box_pack_e nd(box, o);  
        evas_object_show(o);  
    } 
└─────────────────────┘  
elm_object_translatable_text_set(obj, text) is an API that automatically 
applies the text, which is registered as Resources in a widget. When the 
user changes the language in Settings, the new multi -language is 
automatically applied to a widget's text.  
The second Label widget was used to display the text phrase to the user; 
it has no other particular functions.  
Run the example again. The new language has been applied to the Button 
widget . 
 
 
  

  
Page 892 / 978 5) Changing the Language Automatically  
The default language for the emulator is English (United States). We are 
going to change it to another language. Start the MultiLang app, tap the 
Back button, and then go to the App List screen. Tap the Setting s icon 
and select 'Language and input' from the list. When the screen changes, 
select 'Display language.' When the Language list appears, select one 
language between Korean and Russian.  
 
Exit the Settings screen and run the MultiLang example again. Press and 
hold the Home button, and a list of apps run so far will appear. Select 
MultiLang from among the apps. When the example changes to 
Foreground mode, the new language is automatically applied to the 
NaviFrame and Button. The language of the Label widget has not been 
changed from English. We need to manually set multi -language again by 
requesting an event that changes the language in Settings.  
 

  
Page 893 / 978 Go to the bottom of the source file, and there you will see a function 
named ui_app_lang_changed().  Add new code  at the end of this function. 
┌─────────────────────┐  
static void  
ui_app_lang_changed(app_event_info_h event_info, void *user_data)  
{ 
    /*APP_EVENT_LANGUAGE_CHANGED*/  
    char *locale = NULL;  
    system_settings_get_value_string(SYSTEM_SETTINGS_KEY_LOCAL E_LANGUAGE, &local
e); 
    elm_language_set(locale);  
    free(locale);  
  
    appdata_s* ad = user_data;  
    elm_object_text_set(ad ->label, i18n_get_text("IDS_CURRENT"));  
} 
└─────────────────────┘  
ui_app_lang_changed() is an event function which is run when the 
language in Settings is changed. To change the name of the function, 
modify it from the main() function.  
We have set multi -language again for the Label widget. Doing so makes 
multi-language automatically reflected in widgets when the user changes 
the language in Settings.  
Run the example again and change the language in Settings to English 
(United States). Afterwards, go back to the MultiLang example, and you 
will now see the new language is automatically applied.  
  
Page 894 / 978    
 
6) Changing Text of an App Icon  
Go to the App icon list screen by tapping the Back button, and you will 
see the icon for the MultiLang example. The Label text is displayed as 
'multilang.' We are going to learn how to apply multi -language to it.  
 
Open the tizen -manifest.xml file and click  the tizen -manifest.xml button 
among the tab buttons below, and you will see its source code. The code 
<label>multilang</label> displayed is that Label text of the app icon. Add 
new XML code.  
┌─────────────────────┐  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.multilang" version="1.0.0">  
    <profile name="mobile" />  
    <ui-application appid="org. example .multilang" exec="multilang" type="capp" multi
ple="false" taskmanage="true" nodisplay="false">  
        <icon>multilang.png</icon>  
        <label>multilang</label>  
        <label xml:lang="en -us">English</label>  

  
Page 895 / 978         <label xml:lang="ko -kr">Korean</label>  
        <label xml:lang="ru -ru">Russian</label>  
    </ui-application>  
</manifest>  
└─────────────────────┘  
Enter a text phrase for each language using the label tag to apply multi -
language. Run the example again, and change the language in Settings to 
Korean or Russian. Then, go back to the App Icon List screen, and you will 
see the text of the app icon has changed to the chosen language.  
 
 
  

  
Page 896 / 978 7) Related APIs  
char* i18n_get_text(const char *message): an API that returns multi -
language information which corresponds to the language in Settings.  
void elm_object_translatable_text_set( obj, text): an API that applies text 
registered in Resources to a widget. When the user changes the language 
in Settings, the new language is automatically applied to a widget's text.  
void elm_object_item_part_text_translatable_set(it, part, translatable):  an 
API that makes it so that the text of an object can be requested from 
Resources. If the third parameter is EINA_TRUE, then the text is received 
from Resources. If it is EINA_FALSE, the default text is used as it is.  
void ui_app_lang_changed(): an event  function which is run when the 
language in Settings is changed. To change the name of the function, 
modify it from the main() function.  
  
  
Page 897 / 978 67. JSON Parsing  
Like XML, JSON (Java Script Object Notation) is a protocol used for data 
transmission. As the name implie s, it is commonly used in JavaScript, but 
because of its better ease of use than XML, it is now widely used in web 
based communications. For example, the following XML statement and 
JSON statement have the same content, but you can see that the JSON 
statem ent is much simpler. This is because JSON statements include only 
the necessary information. In this example, we are going to learn how to 
parse JSON data.  
XML format - <name>Obama</name><math>50</math>  
JSON format - [name:Obama, math:50]  
 
1) Requesting JSON Array Data  
Create a new source project and specify the project name as 'JsonParse.' 
Open the source file (~.c) under the src folder and add a library header 
file. 
┌─────────────────────┐  
#include "jsonparse.h"  
#include <json -glib/json -glib.h>  
└─────── ──────────────┘  
json-glib/json -glib.h is a library header file for JSON parsing.  
  
  
Page 898 / 978 JSON statements save arrays in the '[]' symbol. We are now going to 
extract data from an array one by one. Add a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
parse_json(appdata_s *ad)  
{ 
    JsonParser *parser = json_parser_new ();  
    char buf[256];  
    buf[0] = ' \0'; 
  
    const char* data1 = "[11, 22, 33, 44, 55]";  
  
    if( json_parser_load_from_data( parser, data1, strlen (data1), NULL))  
    { 
        JsonNode *root = json_parser_get_root (parser);  
        JsonArray *temp_array = json_node_get_array ( root );  
        for(int i=0; i < json_array_get_length(temp_array); i++ )  
            sprintf(buf, "%s - %d", buf, json_array_get_int_element(temp_array, i));  
    } 
  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  
JsonParser is a structure used for parsing JSON data.  
json_parser_new() is an API that creates a JsonParser object.  
We saved a JSON state ment in a string variable named data1. This is an 
array that has five numeric items.  
  
Page 899 / 978 json_parser_load_from_data(JsonParser*, gchar*, gssize, GError**) is an API 
that enters a JSON statement in a JsonParser object. The parameters listed 
in order are a JsonP arser object, JSON data, data length, and error code.  
json_parser_get_root(JsonParser*) is an API that returns the start position 
of JsonParser. The return format is JsonNode.  
json_node_get_array(JsonNode*) is an API that returns a Json statement 
as an arr ay. The return format is JsonArray.  
json_array_get_length(JsonArray*) is an API that returns the number of 
items in a Json array. The return format is guint.  
json_array_get_int_element(JsonArray*, guint) is an API that converts a 
certain item of a Json arr ay into an integer and returns it. The return 
format is gint64.  
When the example is run, the function above is automatically run. Add a 
new line of code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui  is set up */  
    evas_object_show(ad ->win);  
  
    parse_json(ad);  
} 
└─────────────────────┘  
We are now going to build and run the example. Five saved pieces of data 
in a Json array are displayed in the Label widget.  
  
Page 900 / 978  
 
2) Requesting Data with a Key  
Generally, Json statements are in the following form. name is the Key, and 
Obama is the data.  
{name:Obama, math:50}  
We are now going to learn how to request data using the value of a Key. 
Add new code to the parse_json() function.  
┌─────────────────────┐  
     ~ 
    const char* data2 = "{'time': '03:53:25 AM', 'millisec_epoch': 1362196405309, 
'date': '03 -02-2013'}";  
    if( json_parser_load_from_data( parser, data2, strlen(data2), NULL))  
    { 
        JsonNode *root = json_parser_get_root (parser);  
        JsonObject *obj = json_node_get_object(root);  
        char* time_data = json_object_get_string_member (obj, "time");  
        long long epoch_data = json_object_get_int_member (obj, "millisec_epoch");  
        sprintf(buf, "%s <br/><br/> time - %s <br/> epoch  - %lld", buf, time_dat
a, epoch_data);  
    } 
  
    elm_object_text_set(ad ->label, buf);  
} 
└─────────────────────┘  

  
Page 901 / 978 We saved a Json statement in a string variable named data2, and we also 
entered the Json statement in a JsonParser object using the 
json_parse r_load_from_data() function.  
json_node_get_object(JsonNode*) is an API that returns a Json statement 
in JsonObject form.  
json_object_get_string_member(JsonObject*, gchar*) is an API that makes 
JsonObject return data in string format. Passing the Key to the  second 
parameter sees data returned in gchar* format.  
json_object_get_int_member(JsonObject*, gchar*) is an API that makes 
JsonObject return data in numerical form. Passing the Key to the second 
parameter sees data returned in gint64 format.  
Run the examp le again. Data for the time item and data for the epoch 
item are displayed on the screen.  
 
 
  

  
Page 902 / 978 3) Multi -Level Parsing  
Looking at the following Json statement, you can see that coord includes 
a Json object and a Json array. In this section, we are going to learn how 
to parse complex Json statements like that.  
{'coord':{'lon':127.03, 'lat':37.5}, 'weather':[{'id':800, 'main':'Clear'}, {'id':887, 
'main':'Cloudy'}]}  
Add new code at the end of the parse_json() function.  
This code requests data from a Json object  included in a Json statement.  
┌─────────────────────┐  
    ~ 
    const char* data3 = "{'coord':{'lon':127.03, 'lat':37.5},  
        'weather':[{'id':800, 'main':'Clear'}, {'id':887, 'main':'Cloudy'}]}";  
    if( json_parser_load_from_data( parser, data3, st rlen(data3), NULL))  
    { 
        JsonNode *root = json_parser_get_root (parser);  
        JsonObject *obj = json_node_get_object(root);  
        JsonNode *temp_node = json_object_get_member (obj, "coord");  
        JsonObject *temp_object = json_node_get_obj ect(temp_node);  
        sprintf(buf, "%s <br/><br/> coord:lon - %0.2f", buf,  
            json_object_get_double_member (temp_object, "lon"));  
    } 
  
    elm_object_text_set(ad ->label, buf);  
└─────────────────────┘  
  
  
Page 903 / 978 We saved a Json statement in a string variable named data3, and we also 
entered the Json statement in a JsonParser object using the 
json_parser_load_from_data() function.  
We requested the Json node at the start point using the 
json_parser_get_root() function, and we are now going to convert th e 
Json statement into JsonObject form using the json_node_get_object() 
function.  
json_object_get_member(JsonObject *, gchar*) is an API that returns a 
certain JsonObject. The parameters listed in order are a JsonParser and 
member name. The return format is  JsonNode.  
We requested JsonObject from JsonNode using the json_node_get_object() 
function.  
json_object_get_double_member(JsonObject *,  gchar*) is an API that 
makes JsonObject return data in the form of real numbers. Passing the 
Key to the second parameter  sees data returned in gdouble format.  
Run the example again. The screen displays the data corresponding to the 
lon Key in the coord group.  
 
 
  

  
Page 904 / 978 4) Parsing Data from an Inner Group of an Array  
In this section, we are going to request the value that corresp onds to 'id' 
in the first item of an array called 'weather' in the same Json statement. 
Add new code to the parse_json() function.  
┌─────────────────────┐  
    const char* data3 = "{'coord':{'lon':127.03, 'lat':37.5}, 'weather':[{'id':800, 'main':'Clea
r'},  
        {'id':887, 'main':'Cloudy'}]}";  
    if( json_parser_load_from_data( parser, data3, strlen(data3), NULL))  
    { 
        JsonNode *root = json_parser_get_root (parser);  
        JsonObject *obj = json_node_get_object(root);  
        JsonNode *temp_nod e = json_object_get_member (obj, "coord");  
        JsonObject *temp_object = json_node_get_object(temp_node);  
        sprintf(buf, "%s <br/><br/> coord:lon - %0.2f", buf,  
            json_object_get_double_member (temp_object, "lon"));  
  
        temp_node  = json_object_get_member ( obj,"weather" );  
        JsonArray *temp_array = json_node_get_array ( temp_node );  
        temp_node = json_array_get_element(temp_array, 0 );  
        temp_object = json_node_get_object( temp_node );  
        sprintf(buf, "%s < br/> weather:id - %d", buf, json_object_get_int_member  
             (temp_object, "id"));  
    } 
  
    elm_object_text_set(ad ->label, buf);  
└─────────────────────┘  
Request an array node called 'weather' using the json_object_get_member() 
function and conve rt the array node into JsonArray form using the 
json_node_get_array() function.  
  
Page 905 / 978 Request the node for the first item using the json_array_get_element() 
function and convert it into JsonObject form using the 
json_node_get_object() function.  
Lastly, convert t he data corresponding to a Key named 'id' into an integer 
using the json_object_get_int_member() function.  
Run the example again. The value corresponding to the 'id' of the first 
array item will be displayed on the screen.  
 
 
5) Related APIs  
JsonParser *js on_parser_new(): an API that creates a JsonParser object.  
gboolean json_parser_load_from_data(JsonParser*, gchar*, gssize, GError**): 
an API that enters a JSON statement in a JsonParser object. The 
parameters listed in order are a JsonParser object, JSON d ata, data length, 
and error code.  
JsonNode* json_parser_get_root(JsonParser*): an API that returns the start 
position of JsonParser. The return format is JsonNode.  
JsonArray* json_node_get_array(JsonNode*): an API that returns a Jason 
statement in array fo rm. The return format is JsonArray.  

  
Page 906 / 978 guint json_array_get_length(JsonArray*): an API that returns the number of 
items in a Json array. The return format is guint.  
gint64 json_array_get_int_element(JsonArray*, guint): an API that converts 
a certain item of a  Json array into an integer and returns the integer. The 
return format is gint64.  
JsonObject* json_node_get_object(JsonNode*): an API that returns a Jason 
statement in JsonObject form.  
gchar* json_object_get_string_member(JsonObject*, gchar*): an API that 
makes JsonObject return data in a string form. Passing the Key to the 
second parameter sees data returned in gchar* format.  
gint64 json_object_get_int_member(JsonObject*, gchar*): an API that 
makes JsonObject return data in numeric form. Passing the Key to  the 
second parameter sees data returned in gint64 format.  
JsonNode* json_object_get_member(JsonObject *, gchar*): an API that 
returns a certain JsonObject. The parameters listed in order are a 
JsonParser and member name. The return format is JsonNode.  
  
  
Page 907 / 978 68. XML Parsing  
When a mobile app communicates with a service via HTTP, data is 
transmitted in XML form. XML is a document protocol for systemically 
storing data, and it is widely used not only for communications but also 
for storing data necessary for develop ing apps, such as screen layouts and 
resource data. In this example, we are going to learn how to parse XML 
data. 
 
1) Requesting XML Data  
Create a new source project and specify the project name as 'XmlParse.' 
Open the source file (~.c) under the src folde r and add library header files 
and variables.  
┌─────────────────────┐  
#include "xmlparse.h"  
#include <libxml/HTMLparser.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label;  
    bool value_begin;  
    int valu e_type;  
    char buffer[1024];  
} appdata_s;  
└─────────────────────┘  
  
Page 908 / 978 libxml/HTMLparser.h is a library header file for XML parsing.  
value_begin is a variable for storing information on whether to start data.  
value_type is a variable for storing the data type . 
buffer[] is a string array variable for storing parsed data.  
The following is a simple XML statement. name indicates the name of the 
node, and Elsa indicates data. We are now going to parse this.  
<name>Elsa</name><math>95</math>  
Add a new function on top  of the create_base_gui() function. This function 
adds a widget to a Box container.  
┌─────────────────────┐  
static void  
my_box_pack(Evas_Object *box, Evas_Object *child, double h_weight, double v_weight,  
        double h_align, double v_align)  
{ 
 /* create  a frame we shall use as padding around the child widget */  
 Evas_Object *frame = elm_frame_add(box);  
 /* use the medium padding style. there is "pad_small", "pad_medium",  
  * "pad_large" and "pad_huge" available as styles in addition to the  
  * "default" frame style */  
 elm_object_style_set(frame, "pad_medium");  
 
evas_object_show(frame);  
} 
└─────────────────────┘  
  
  
Page 909 / 978 Then, add Box - and Button -creating code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    Evas_Object *box, *btn;  
 
    /* Box */  
    box = elm_box_add(ad ->conform);  
    elm_box_horizontal_set(box, EINA_FALSE ); 
    evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D); 
    evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Label */  
        ad->label = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label, "<align=center>Hello EFL</>");  
        my_box_pack(box, ad ->label, 1.0, 1.0, -1.0, -1.0); 
 
        /* Button -1 */ 
        btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Parse1");  
        evas_object_smart_callback_add(btn, "clicked", btn_parse1_cb, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 1.0);  
  
Page 910 / 978     } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
Add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
void 
walkTree1(xmlNode * a_node, appdata_s *ad)  
{ 
    xmlNode *cur_node = NULL;  
    xmlChar *key = NULL;  
    xmlChar *value = NULL;  
  
    for (cur_node = a_node; cur_node; cur_node = cur_node ->next)  
    { 
        if(!strcmp((const char*)cur_node ->name, "name"))  
            ad->value_type = 1;  
        if(!strcmp((const char*)cur_node ->name, "math"))  
            ad->value_type = 2;  
  
        if(!strcmp((const char*)cur_node ->name, "text")) {  
            if( ad->value_type == 1 )  
            { 
                value = cur_node ->content;  
                strcat(ad ->buffer, "Name : ");  
                strcat(ad ->buffer, (char*)value);  
                ad->value_type = 0;  
            } 
            else if( ad ->value_type == 2 )  
            { 
  
Page 911 / 978                 value = cur_node ->content;  
                strcat(ad ->buffer, " / Math : ");  
                strcat(ad ->buffer, (char*)value);  
                strcat(ad ->buffer, "<br/>");  
                ad->value_type = 0;  
            } 
        } 
  
        walkTree1(cur_node ->children, ad);  
    } 
} 
  
static void  
btn_parse1_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char* buf = "<name>Elsa</name><math>95</math>";  
  
    htmlParserCtxtPtr parser = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL, 
0); 
    htmlCtxtUseOptions(parser, HTML_PARSE_NOBLANKS | HTML_PARSE_NOERROR | H
TML_PARSE_NOWARNING | HTML_PARSE_NONET);  
    htmlParse Chunk(parser, buf, strlen(buf), 0);  
  
    ad->buffer[0] = ' \0'; 
    ad->value_type = 0;  
    walkTree1(xmlDocGetRootElement(parser ->myDoc), ad);  
    elm_object_text_set(ad ->label, ad ->buffer);  
} 
└─────────────────────┘  
walkTree1() is a function that extracts data corresponding to "name" and 
"math" in the xmlNode object and adds the data to a global variable.  
  
Page 912 / 978 Request the individual nodes included in the XML statement from the for -
loop, and afterwards, if the name of a gi ven individual node is 'name' or 
'math,' request the data. In order to move on to the next node, the 
function calls itself.  
xmlNode is a structure variable that points to a certain point in an XML 
statement. The properties are as follows:  
 - next: returns the pointer of the next node.  
 - name: the name of the node If 'text' is saved in this property, it means 
that the node is data. In such cases, data can be requested from the 
content property.  
 - content: node data.  
 - properties: node properties data.  
btn_parse1_cb() is a function that creates an XML parser object, enters an 
XML statement, and then calls the function that runs parsing.  
htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void *user_data, char 
*chunk, int size, char *filename, xmlCharEncoding en c) is an API that 
creates an XML parser object.  
htmlParserCtxtPtr is the XML parser structure. Among the properties, 
myDoc contains an XML statement in xmlDocPtr form.  
htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options) is an API that 
specifies an opti on for an XML parser. This option can be specified 
redundantly.  
htmlParseChunk(htmlParserCtxtPtr ctxt, char *chunk, int size, int terminate) 
is an API that enters an XML statement in a XML parser.  
  
Page 913 / 978 xmlDocGetRootElement(xmlDocPtr doc) is an API that returns the start 
node of an XML statement.  
We are now going to build and run the example. Tap the Button, and the 
name node's data and the math node's data will be displayed on the 
screen.  
 
 
2) Requesting Node Properties Data  
As shown below, XML lets you specify  properties for a node. In this section, 
we are going to learn how to request node properties data.  
<student name="Aurora" math="27"></student>  
Add code that creates a second Button at the end of the 
create_base_gui() function.  

  
Page 914 / 978 ┌─────────────────────┐  
        /* Button -1 */ 
        btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Parse1");  
        evas_object_smart_callback_add(btn, "clicked", btn_parse1_cb, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 1.0);  
 
        /* Button -2 */ 
        btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Parse2");  
        evas_object_smart_callback_add(btn, "clicked", btn_parse2_cb, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 1.0);  
    } 
└─────────────────────┘  
Add two new  functions on top of the create_base_gui() function.  
┌─────────────────────┐  
void 
walkTree2(xmlDoc *doc, xmlNode * a_node, appdata_s *ad)  
{ 
    xmlNode *cur_node = NULL;  
    xmlAttr *cur_attr = NULL;  
    xmlChar *key = NULL;  
  
    for (cur_node = a_node; c ur_node; cur_node = cur_node ->next)  
    { 
        for (cur_attr = cur_node ->properties; cur_attr; cur_attr = cur_attr ->next) {  
            key = xmlGetProp(cur_node, cur_attr ->name);  
  
            if(!strcmp((const char*)cur_attr ->name, "name"))  
            { 
                strcat(ad ->buffer, "Name : ");  
                strcat(ad ->buffer, key);  
  
Page 915 / 978             } 
            if(!strcmp((const char*)cur_attr ->name, "math"))  
            { 
                strcat(ad ->buffer, " / Math : ");  
                strcat(ad ->buffer, key);  
                strcat(ad ->buffer, "<br/>");  
            } 
  
            if(key!=NULL) { xmlFree(key); key=NULL; }  
        } 
        walkTree2(doc, cur_node ->children, ad);  
    } 
} 
  
static void  
btn_parse2_cb(void * data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char* buf = "<?xml version= \"1.0\" encoding= \"utf-8\"?> <grade> <na
me>M.I.T</name> <student name= \"Aurora \" math= \"27\"></student> <student 
name= \"Piana \" math= \"88\"></student > <student name= \"Tangled \" math= \"7
7\"></student> </grade>";  
  
    htmlParserCtxtPtr parser = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL, 
0); 
    htmlCtxtUseOptions(parser, HTML_PARSE_NOBLANKS | HTML_PARSE_NOERROR | H
TML_PARSE_NOWARNING | HTML_PAR SE_NONET);  
  
    htmlParseChunk(parser, buf, strlen(buf), 0);  
    ad->buffer[0] = ' \0'; 
    walkTree2(parser ->myDoc, xmlDocGetRootElement(parser ->myDoc), ad);  
    elm_object_text_set(ad ->label, ad ->buffer);  
} 
└─────────────────────┘  
  
Page 916 / 978 walkTree2() is a functi on that requests the properties data of an XML node 
and displays it on the screen.  
Request the individual nodes included in the XML statement from the first 
for-loop and request individual properties from the second for -loop. Then, 
if the name of a given individual node is 'name' or 'math,' request data. 
In order to move on to the next node, the function calls itself.  
Among the properties of xmlNode, the 'properties' property contains the 
properties of the node in xmlAttr form.  
xmlGetProp(xmlNodePtr node, const xmlChar *name) is an API that returns 
node properties data. Pass the XML node to the first parameter, and pass 
the name of the property to the second parameter.  
xmlFree(xmlChar*) is an API that deletes XML data.  
btn_parse2_cb() is a function that cre ates an XML parser object, enters an 
XML statement, and then calls the function that runs properties data 
parsing.  
Run the example again and tap the second Button. Node properties data 
are displayed on the screen.  
  
Page 917 / 978  
 
3) Multi -Level Node Parsing  
The followi ng XML statement has a total of three <student> nodes, and 
each <student> includes a <name> node and a <math> node. We are 
now going to learn how to access nodes using a tree structure.  
<student><name>Obama</name><math>50</math></student>  
<student><name>Ps y</name><math>70</math></student>  
<student><name>Yuna</name><math>65</math></student>  
Add code that creates a third Button at the end of the create_base_gui() 
function.  
┌─────────────────────┐  
        /* Button -2 */ 
        btn = elm_button_add(ad ->conform ); 
        elm_object_text_set(btn, "Parse2");  

  
Page 918 / 978         evas_object_smart_callback_add(btn, "clicked", btn_parse2_cb, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 1.0);  
 
        /* Button -3 */ 
        btn = elm_button_add(ad ->conform);  
        elm_obj ect_text_set(btn, "Parse3");  
        evas_object_smart_callback_add(btn, "clicked", btn_parse3_cb, ad);  
        my_box_pack(box, btn, 1.0, 0.0, -1.0, 1.0);  
    } 
└─────────────────────┘  
Add two new functions on top of the create_base_gui() function.  
┌─────────────────────┐  
void 
walkTree3(xmlDoc *doc, xmlNode * a_node, appdata_s *ad)  
{ 
    xmlNode *cur_node = NULL;  
    xmlAttr *cur_attr = NULL;  
    xmlChar *key = NULL;  
    xmlChar *value = NULL;  
  
    for (cur_node = a_node; cur_node; cur_node = cur_no de->next)  
    { 
        if(!strcmp((const char*)cur_node ->name, "student") )  
            ad->value_begin = true;  
  
        if(!strcmp((const char*)cur_node ->name, "name") && ad ->value_begin)  
            ad->value_type = 1;  
        if(!strcmp((const char*)c ur_node ->name, "math") && ad ->value_begin)  
            ad->value_type = 2;  
  
        if(!strcmp((const char*)cur_node ->name, "text")) {  
            if( ad->value_type == 1 )  
  
Page 919 / 978             { 
                value = (char*)cur_node ->content;  
                strcat(ad ->buffer, "Name : ");  
                strcat(ad ->buffer, (char*)value);  
                ad->value_type = 0;  
            } 
            else if( ad ->value_type == 2 )  
            { 
                value = (char*)cur_node ->content;  
                strcat(ad ->buffer, " / Math : ");  
                strcat(ad ->buffer, (char*)value);  
                strcat(ad ->buffer, "<br/>");  
                ad->value_type = 0;  
            } 
        } 
  
        walkTree3(doc, cur_node ->children, ad);  
    } 
} 
 
static void  
btn_parse3_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    const char* buf = "<?xml version= \"1.0\" encoding= \"utf-8\"?> <grade> <na
me>M.I.T</name> <student><name>Obama</name><math>50</math></student> 
<student><name>Psy</name><math>70</math></student> <student><name>Yuna
</name><math>65</math></student> </grade>";  
  
    htmlParserCtxtPtr parser = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL, 
0); 
    htmlCtxtUseOptions(parser, HTML_PARSE_NOBLANKS | HTML_PARSE_NOERROR | H
TML_PARSE_NOWARNING | HTML_PARSE_NONET);  
    htmlParseChunk(parser, buf, strlen(buf), 0);  
  
Page 920 / 978      ad->value_begin = false;  
    ad->buffer[0] = ' \0'; 
    ad->value_type = 0;  
    walkTree3(parser ->myDoc, xmlDocGetRootElement(parser ->myDoc) , ad); 
  
    elm_object_text_set(ad ->label, ad ->buffer);  
} 
└─────────────────────┘  
walkTree3() is a function that requests the data of the second node in an 
XML tree structure and displays it on the screen.  
This function extracts nodes from an XML statement one by one. If the 
name of the node is 'student,' this function determines the node as the 
first node and sets the global variable 'value_begin' to true.  
If the name of the node is 'name' or 'math,' and t he global variable 
'value_begin' is true, this function determines the node as the second node 
and calls itself.  
If the name of the node is 'text,' it determines the node as data and then 
reads the value of its content property and adds the value to the gl obal 
variable. In order to move on to the next node, the function calls itself.  
btn_parse3_cb() is a function that creates an XML parser object, enters an 
XML statement, and then calls the function that runs parsing of the second 
node's data.  
Run the examp le again and tap the third Button. The second node's data 
will be displayed on the screen.  
  
Page 921 / 978  
 
4) Related APIs  
htmlParserCtxtPtr htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void 
*user_data, char *chunk, int size, char *filename, xmlCharEncoding enc): an  
API that creates an XML parser object.  
htmlParserCtxtPtr: the XML parser structure. Among the properties, myDoc 
contains an XML statement in xmlDocPtr form.  
int htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options): an API that 
specifies an option for a n XML parser. This option can be specified 
redundantly.  
int htmlParseChunk(htmlParserCtxtPtr ctxt, char *chunk, int size, int 
terminate): an API that enters an XML statement in an XML parser.  
  

  
Page 922 / 978 xmlNodePtr xmlDocGetRootElement(xmlDocPtr doc): an API that re turns 
the start node of an XML statement.  
xmlChar* xmlGetProp(xmlNodePtr node, const xmlChar *name): an API 
that returns node properties data. Pass the XML node to the first 
parameter, and pass the name of the property to the second parameter.  
void xmlFree (xmlChar*): an API that deletes XML data.  
  
  
Page 923 / 978 69. Checking Network Status  
It is advisable to check the status of your network before communicating 
with a server. In this example, we are going to learn how to check the 
availability of communication, mobile commun ication, and Wi -Fi 
communication.  
1) Registering a Privilege  
Create a new source project and specify the project name as 
'NetConnection.' You need to have the applicable user privileges to check 
communication status. After the source project is created, open the tizen -
manifest.xml file, and click Privileges among th e tab buttons below. Then, 
click the Add button in the upper right corner. When a popup  window 
appears, select http://tizen.org/privilege/network.get from the list, and 
click the OK button to close the window.  
 

  
Page 924 / 978 After saving, click the 'tizen -manifest.xml'  button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.netconnecti on" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .netconnection" exec="netconnection" multiple
="false" nodisplay="false" taskmanage="true" type="capp">  
        <label>netconnection</label>  
        <icon>netconnection. png</icon>  
    </ui-application>  
    <privileges>  
        <privilege>http://tizen.org/privilege/network.get</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  
 
2) Checking Connection Status  
In this section, we are going to check whether ther e is a network 
connection. Open the source file (~.c) under the src folder and add library 
header files and variables.  
┌─────────────────────┐  
#include "netconnection.h"  
#include <net_connection.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
  
Page 925 / 978     Evas_Object *conform;  
    Evas_Object *label1;  
    Evas_Object *label2;  
    Evas_Object *label3;  
    connection_h connection;  
} appdata_s;  
└─────────────────────┘  
net_connection.h is a library header file for checking connection status.  
We will display connection status in label1, mobile connection status in 
label2, and Wi -Fi connection status in label3.  
connection_h is the communication information structure.  
Add a new function on top of the create_base_gui() function. This function 
checks connection st atus and displays it on the screen.  
┌─────────────────────┐  
static int  
net_state(appdata_s *ad)  
{ 
    int error_code;  
  
    error_code = connection_create(&ad ->connection);  
    if (error_code != CONNECTION_ERROR_NONE) {  
        dlog_print(DLOG_ERROR, "tag" , "connection error");  
       return error_code;  
    } 
  
    connection_type_e net_state;  
    error_code = connection_get_type(ad ->connection, &net_state);  
    switch( net_state )  
  
Page 926 / 978     { 
    case CONNECTION_TYPE_DISCONNECTED     : /**< Disconnected */  
        elm_object_text_set(ad ->label1, "Net state Disconnected");  
        break;  
    case CONNECTION_TYPE_WIFI : /**< Wi -Fi type */  
        elm_object_text_set(ad ->label1, "Net state Wifi");  
        break;  
    case CONNECTION_TYPE_CELLULAR : /**< Cellular  type */  
        elm_object_text_set(ad ->label1, "Net state Cellular");  
        break;  
    case CONNECTION_TYPE_ETHERNET : /**< Ethernet type */  
        elm_object_text_set(ad ->label1, "Net state Ethernet");  
        break;  
    case CONNECTION_TYPE_BT : /** < Bluetooth type */  
        elm_object_text_set(ad ->label1, "Net state BT");  
        break;  
    } 
    return error_code;  
} 
└─────────────────────┘  
connection_create(connection_h* connection) is an API that creates a 
connection_h object.  
connection_get_type (connection_h connection, connection_type_e* type) 
is an API that returns current communication status. The return format is 
connection_type_e. The types of connection_type_e are as follows:  
 - CONNECTION_TYPE_DISCONNECTED: communication disconnected.  
- CONNECTION_TYPE_WIFI: Wi -Fi type.  
- CONNECTION_TYPE_CELLULAR: mobile communication type.  
- CONNECTION_TYPE_ETHERNET: Ethernet type.  
- CONNECTION_TYPE_BT: Bluetooth type.  
  
Page 927 / 978 Modify the code of the create_base_gui() function. This code creates Frame, 
Box, and Lab el widgets and calls the function above.  
┌─────────────────────┐  
 
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Frame for outer padding */  
    Evas_Objec t *frame = elm_frame_add(ad ->win);  
    elm_object_style_set(frame, "pad_huge");  
    elm_object_content_set(ad ->conform, frame);  
    evas_object_show(frame);  
 
    /* Vertical box */  
    Evas_Object *vbox = elm_box_add(ad ->win);  
    elm_box_padding_set(vbox, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object_content_set(frame, vbox);  
    evas_object_show(vbox);  
 
    { 
        /* Label -1 */ 
        ad->label1 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label1 , "Net state");  
        evas_object_size_hint_weight_set(ad ->label1, EVAS_HINT_EXPAND, 0);  
        elm_box_pack_end(vbox, ad ->label1);  
        evas_object_show(ad ->label1);  
  
Page 928 / 978     } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win); 
 
    int error_code = net_state(ad);  
} 
└─────────────────────┘  
This code deletes the connection_h object when the app is closed. Add 
new code to the app_terminate() function.  
┌─────────────────────┐  
static void  
app_terminate(void *data)  
{ 
    appdata_s *ad = data;  
    connection_destroy(ad ->connection);  
} 
└─────────────────────┘  
connection_destroy(connection_h connection) is an API that deletes a 
connection_h object.  
Build and run the example. The type of communication is displayed in the 
Label widget.  
  
Page 929 / 978  
 
2) Requesting Mobile Connection Status  
In this section, we are going to request the connection status of mobile 
communication, which is a charged communication. Add a new function 
on top of the create_base_gui() function.  
┌─────────────────────┐  
static v oid 
cellular_state(appdata_s *ad)  
{ 
    int error_code;  
    connection_cellular_state_e state;  
    error_code = connection_get_cellular_state(ad ->connection, &state);  
  
    switch( state )  
    { 
   case CONNECTION_CELLULAR_STATE_OUT_OF_SERVICE:  
      elm_object_text_set(ad ->label2, "Cell state Out of service");  
      break;  
   case CONNECTION_CELLULAR_STATE_FLIGHT_MODE:  
      elm_object_text_set(ad ->label2, "Cell state Flight mode");  
      break;  
   case CONNECTION_CELLULAR_STATE_ROAMING_OFF:  

  
Page 930 / 978       elm_object_text_set(ad ->label2, "Cell state Roaming off");  
      break;  
   case CONNECTION_CELLULAR_STATE_CALL_ONLY_AVAILABLE:  
      elm_object_text_set(ad ->label2, "Cell state Call only");  
      break;  
   case CONNECTION_CELLULAR_STATE_AVAILABLE:  
      elm_object_text_set(ad ->label2, "Cell state Available");  
      break;  
   case CONNECTION_CELLULAR_STATE_CONNECTED:  
      elm_object_text_set(ad ->label2, "Cell state Connected");  
      break;  
   default:  
      elm_object_text_set(ad ->label2, "Cell state Er ror"); 
      break;  
    } 
} 
└─────────────────────┘  
connection_get_cellular_state(connection_h connection, 
connection_cellular_state_e* state) is an API that returns mobile 
connection status. The return format is connection_cellular_state_e. The 
types of connection_cellular_state_e are as follows:  
- CONNECTION_CELLULAR_STATE_OUT_OF_SERVICE: disconnected.  
- CONNECTION_CELLULAR_STATE_FLIGHT_MODE: flight mode.  
- CONNECTION_CELLULAR_STATE_ROAMING_OFF: roaming off.  
- CONNECTION_CELLULAR_STATE_CALL_ONLY_AVAILABL E: only calls 
available.  
- CONNECTION_CELLULAR_STATE_AVAILABLE: connection available but 
not yet connected.  
- CONNECTION_CELLULAR_STATE_CONNECTED: connected.  
  
Page 931 / 978 We are now going to add a new Label widget and display the result of 
the function above on the scr een. Add new code to the create_base_gui() 
function.  
┌─────────────────────┐  
        /* Label -1 */ 
        ad->label1 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label1, "Net state");  
        evas_object_size_hint_weight_set(ad ->label1, E VAS_HINT_EXPAND, 0);  
        elm_box_pack_end(vbox, ad ->label1);  
        evas_object_show(ad ->label1);  
 
        /* Label -2 */ 
        ad->label2 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label2, "Cell state");  
        evas_object_size_h int_weight_set(ad ->label2, EVAS_HINT_EXPAND, 0);  
        elm_box_pack_end(vbox, ad ->label2);  
        evas_object_show(ad ->label2);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    int error_code = net_state(ad);  
    if (error_code == CONNECTION_ERROR_NONE) {  
        cellular_state(ad);  
    } 
} 
└─────────────────────┘  
Run the example again. The mobile connection status will be displayed in 
the second Label widget.  
  
Page 932 / 978  
 
3) Requesting WiFi Status  
In this section, we are going to request WiFi connection status. Add a new 
function on top of the create_base_gui() function.  
┌─────────────────────┐  
connection_get_wifi_state(connection_h connection, 
connection_wifi_state_e* state) is an API that returns the Wi -Fi 
connection status. The return format is connection_wifi_state_e. The 
types of connection_wifi_state_e are as follows:  
- CONNECTION_WIFI_STATE_DEACTIVATED: Wi -Fi deactivated.  
- CONNECTION_WIFI_STATE_DISCONNECTED: Wi -Fi disconnected.  
- CONNECTION_W IFI_STATE_CONNECTED: Wi -Fi connected.  
We are now going to add a new Label widget and display the result of 
the function above on the screen. Add new code to the create_base_gui() 
function.  
┌─────────────────────┐  
        /* Label -2 */ 

  
Page 933 / 978         ad->label2 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label2, "Cell state");  
        evas_object_size_hint_weight_set(ad ->label2, EVAS_HINT_EXPAND, 0);  
        elm_box_pack_end(vbox, ad ->label2);  
        evas_object_show(ad ->label2);  
 
        /* Labe l-3 */ 
        ad->label3 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label3, "Wifi state");  
        evas_object_size_hint_weight_set(ad ->label3, EVAS_HINT_EXPAND, 0);  
        elm_box_pack_end(vbox, ad ->label3);  
        evas_object_show(a d->label3);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
 
    int error_code = net_state(ad);  
    if (error_code == CONNECTION_ERROR_NONE) {  
        cellular_state(ad);  
        wifi_state(ad);  
    } 
} 
└─────────────────────┘  
Run the example again. The current Wi -Fi connection status will be 
displayed in the third Label widget.  
  
Page 934 / 978  
 
4) Related APIs  
int connection_create(connection_h* connection) is an API that creates a 
connection_h object.  
int connection_ get_type(connection_h connection, connection_type_e* 
type) is an API that returns the current communication status. The return 
format is connection_type_e. The types of connection_type_e are as follows:  
 - CONNECTION_TYPE_DISCONNECTED: disconnected.  
 - CONNECTION_TYPE_WIFI: Wi -Fi type  
 - CONNECTION_TYPE_CELLULAR: mobile communication type.  
 - CONNECTION_TYPE_ETHERNET: Ethernet type.  
 - CONNECTION_TYPE_BT: Bluetooth type.  
int connection_destroy(connection_h connection) is an API that deletes a 
connection_h o bject. 

  
Page 935 / 978 int connection_get_cellular_state(connection_h connection, 
connection_cellular_state_e* state) is an API that returns mobile 
communication status. The return format is cconnection_cellular_state_e. 
The types of connection_cellular_state_e are as fol lows: 
 - CONNECTION_CELLULAR_STATE_OUT_OF_SERVICE: disconnected.  
 - CONNECTION_CELLULAR_STATE_FLIGHT_MODE: flight mode.  
 - CONNECTION_CELLULAR_STATE_ROAMING_OFF: roaming off.  
 - CONNECTION_CELLULAR_STATE_CALL_ONLY_AVAILABLE: only calls 
available.  
 - CONNECTION_CELLULAR_STATE_AVAILABLE: connection available but 
not yet connected.  
 - CONNECTION_CELLULAR_STATE_CONNECTED: connected.  
int connection_get_wifi_state(connection_h connection, 
connection_wifi_state_e* state) is an API that returns the Wi -Fi 
comm unication status. The return format is connection_wifi_state_e. The 
types of connection_wifi_state_e are as follows:  
 - CONNECTION_WIFI_STATE_DEACTIVATED: Wi -Fi deactivated.  
 - CONNECTION_WIFI_STATE_DISCONNECTED: Wi -Fi disconnected.  
 - CONNECTION_WIFI_STAT E_CONNECTED: Wi -Fi connected.  
  
  
Page 936 / 978 70. HTTP Communication  
HTTP communication is easy to use and capable of transferring large 
amounts of data at once. This property makes it attractive for use in 
mobile devices.  In this example, we are going to implement a featur e that 
requests weather information via HTTP communication and downloads 
images from a web server.  
 
1) Registering a Privilege  
Create a new source project and specify the project name as 'HttpRequest.' 
You need to have the applicable user privileges to use  communication. 
After the source project is created, open the tizen -manifest.xml file, and 
click Privileges among the tab buttons below. Then, click the Add button 
in the upper right corner. When a popup  window appears, select 
http://tizen.org/privilege/in ternet from the list, and click the OK button to 
close the window.  
  
Page 937 / 978  
After saving, click the 'tizen -manifest.xml' button in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api -version="2.3" package="org. exam
ple.httprequest" version="1.0.0">  
    <profile name="mobile"/>  
    <ui-application appid="org. example .httprequest" exec="httprequest" multiple="fals
e" nodisplay="false" taskmanage="true" type="capp">  
        <label>httprequest</label>  
        <icon>httprequest.png</icon>  
    </ui-application>  
    <privileges>  
        <privilege> http://tizen.org/privilege/internet</privilege>  
    </privileges>  
</manifest>  
└─────────────────────┘  

  
Page 938 / 978 2) Requesting Text Communication Data  
In this section, we are going to implement a feature to receive text data 
from a web server. Open the source file (~ .c) under the src folder and add 
a library header, variables, and a structure.  
┌─────────────────────┐  
#include "httprequest.h"  
#include <curl/curl.h>  
  
typedef struct MemoryStruct {  
    char *memory;  
    size_t size;  
} memoryStruct;  
  
typedef struct appda ta { 
    Evas_Object *win;  
    Evas_Object *conform;  
    //Evas_Object *label;  
    Evas_Object * entry; 
    Evas_Object *icon;  
    memoryStruct ms;  
} appdata_s;  
└─────────────────────┘  
For HTTP communication, the CURL library is used. curl/curl.h is a CURL  
library header file.  
memoryStruct is a structure that stores communication result data.  
icon is an Evas Image object.  
We are now going to implement a feature that connects to a server and 
  
Page 939 / 978 receives text data from it. Add three new functions on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static size_t  
write_memory_cb(void *contents, size_t size, size_t nmemb, void *userp)  
{ 
    size_t realsize = size * nmemb;  
    memoryStruct *mem = (memoryStruct *)userp;  
  
    mem->memory = realloc(mem ->memory, mem ->size + realsize + 1);  
    if(mem ->memory == NULL) {  
        /* out of memory! */  
        dlog_print(DLOG_INFO, "tag", "not enough memory (realloc returned NULL)");  
        return 0;  
    } 
  
    memcpy(&(mem ->memory[mem ->size]), contents, reals ize); 
    mem->size += realsize;  
    mem->memory[mem ->size] = 0;  
    return realsize;  
} 
 
void 
get_http_data(const char* url, memoryStruct *data)  
{ 
    CURL *curl_handle;  
    CURLcode res;  
  
    data->memory = malloc(1);  /* will be grown as needed by the realloc above */  
    data->size = 0;    /* no data at this point */  
  
    curl_global_init(CURL_GLOBAL_ALL);  
  
Page 940 / 978   
    /* init the curl session */  
    curl_handle = curl_easy_init();  
  
    /* specify URL to get */  
    curl_easy_setopt(curl_handle, CURLOPT_URL,  url); 
  
    /* send all data to this function  */ 
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, write_memory_cb);  
  
    /* we pass our 'chunk' struct to the callback function */  
    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)data) ; 
  
    /* some servers don't like requests that are made without a user -agent 
    field, so we provide one */  
    curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl -agent/1.0");  
  
    /* get it! */  
    res = curl_easy_perform(curl_handle);  
  
    /* cleanup curl stuff */  
    curl_easy_cleanup(curl_handle);  
  
    /* we're done with libcurl, so clean it up */  
    curl_global_cleanup();  
} 
 
static void  
btn_download_text(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char url[100]={0,};  
  
    sprintf(url, "http://api.openweathermap.org/data/2.5/weather?lat=37.498&lon=127.0
  
Page 941 / 978 27&units=metric");  
    get_http_data(url, &ad ->ms); 
  
    elm_object_text_set(ad ->label, ad ->ms.memory);  
    free( ad ->ms.memory);  
} 
└──────────────────── ─┘ 
write_memory_cb() is an event function that receives server responses. The 
parameters listed in order are the content, byte unit, memory size, and 
user data.  
You can calculate the total memory size by multiplying the second 
parameter by the third parame ter. The byte unit is mostly 1.  
The next code assigns memory to the memory property of the 
memoryStruct structure using the realloc() function and copies data using 
the memcpy() function.  
Then, it adds the size of memory to the size property of the memoryS truct 
structure and replaces the end of the data with 0 to mark the end.  
get_http_data() is a function that attempts communication with the server.  
curl_global_init(long flags) is an API that initializes the CURL library. For 
apps that use CURL, this API m ust be run once initially.  
curl_easy_init(void) is an API that creates a CURL object.  
curl_easy_setopt(CURL *curl, CURLoption option, ...) is an API that specifies 
an option for a CURL object. The option types are as follows:  
  
Page 942 / 978 - CURLOPT_URL: specifies a URL  address.  
- CURLOPT_WRITEFUNCTION: specifies a callback function that receives 
communication results.  
- CURLOPT_WRITEDATA: specifies user data.  
- CURLOPT_USERAGENT: specifies a user agent.  
curl_easy_perform(CURL *curl) is an API that starts communication w ith a 
server.  
curl_easy_cleanup(CURL *curl) is an API that deletes CURL data.  
curl_global_cleanup(void) is an API that deletes the entire data of the CURL 
library. Once CURL is used, this API should be called at least once before 
closing the app.  
btn_download_text() is a function that, when the user taps a Button, 
receives text data from a server and displays the result in a Label widgets.  
Request weather information for a place with latitude coordinate 37.498 
and longitude coordinate 127.027.  
We are going to create a Button that receives data from the weather 
forecast server. Add new code at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mo de_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EX
PAND);  
  
Page 943 / 978     elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Vertical box */  
    Evas_Object *vbox = elm_box_add(ad ->win);  
    elm_box_padding_set(vbox, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object_content_set(ad ->conform, vbox);  
    evas_object_show(vbox);  
 
    { 
        /* Entry */  
        ad->entry = elm_entry_add(ad ->conform);  
        evas_object_size_hint_weight_set(ad ->entry, EVAS_HINT_EXPAND, EVAS_HI
NT_EXPAND);  
        evas_object_size_hint_align_set(ad ->entry, EVAS_HINT_FILL, EVAS_HINT_FIL
L); 
        elm_box _pack_end(vbox, ad ->entry);  
        evas_object_show(ad ->entry);  
 
        /* Button -1 */ 
        Evas_Object *btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Text");  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0);  
        evas_object_smart_callback_add(btn, "clicked", btn_download_text, ad);  
        elm_box_pack_end(vbox, btn);  
        evas_object_show(btn);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
  
Page 944 / 978 We created Box, Entry, and Button widgets.  
We are now going to build and run the example. Tap the Button and, 
when a response is received from the server, Json type weather 
information is displayed on the screen.  
 
For information on how to extract individual pieces of data from a Json 
statement, see the JsonParse example.  
 
3) Downloading Images  
In this section, we are going to implement a feature that downloads 
images from a web server and  displays them in an Image object. Add 
Image object - and Button widget -creating code to the create_base_gui() 
function.  
  

  
Page 945 / 978 ┌─────────────────────┐  
    { 
        /* Entry */  
        ad->entry = elm_entry_add(ad ->conform);  
        evas_object_size_hint_weight_set(ad ->entry, EVAS_HINT_EXPAND, EVAS_HINT_E
XPAND);  
        evas_object_size_hint_align_set(ad ->entry, EVAS_HINT_FILL, EVAS_HINT_FILL);  
        elm_box_pack_end(vbox, ad ->entry);  
        evas_object_show(ad ->entry);  
 
        /* Image */  
        ad->icon = elm_image_add(ad ->conform);  
        evas_object_size_hint_weight_set(ad ->icon, EVAS_HINT_EXPAND, EVAS_HIN
T_EXPAND);  
        evas_object_size_hint_align_set(ad ->icon, EVAS_HINT_FILL, EVAS_HINT_FIL
L); 
        elm_box_pack _end(vbox, ad ->icon);  
        evas_object_show(ad ->icon);  
 
        /* Button -1 */ 
        Evas_Object *btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Text");  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0);  
        evas_object_smart_callback_add(btn, "clicked", btn_download_text, ad);  
        elm_box_pack_end(vbox, btn);  
        evas_object_show(btn);  
 
        /* Button -2 */ 
        btn = elm_button_add (ad->conform);  
        elm_object_text_set(btn, "Image");  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0);  
        evas_object_smart_callback_add(btn, "clicked", btn_download_image, ad);  
  
Page 946 / 978         elm_box_pack_end(vbox, btn);  
        evas_object_show(btn);  
    } 
└─────────────────────┘  
We created an Image object and saved it in the icon variable of the 
appdata structure. Then, we created a second Button and specified the 
name of the callback function as btn_download_image.  
Lastly, we need to create a Button callback function. Add a new function 
on top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_download_image(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char url[100]={0,};  
  
    sprintf(url, "https://www.tizen.org/sites/all/themes/tizen_theme/logo.png");  
    get_http_data(url, &ad ->ms); 
  
    // update icon image.  
    if ( elm_image_memfile_set( ad ->icon, ad ->ms.memory , ad ->ms.size, "png", 0) =
= EINA_FALSE)  
    { 
        dlog_print(DLOG_DEBUG, "tag", "%s : image setting error " , __func__);  
    } 
    free( ad ->ms.memory);  
} 
└─────────────────────┘  
  
  
Page 947 / 978 elm_image_memfile_set(Evas_Object *obj, const void *img, size_t size, 
const char *format, const char *key) is an API that enters original image 
data in an Evas Image object. The parameters listed in order are an Evas 
Image object, image data, data size, and image type.  
Build the example and tap the second Button. The Tizen logo image 
downloaded from the web server is displayed on the screen.  
 
 
4) Related APIs  
CURLcode curl_global_init(long flags): an API that initializes the CURL 
library. For apps that u se CURL, this API must be run once initially.  
CURL* curl_easy_init(void): an API that creates a CURL object.  
CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...): an API that 
specifies an option for a CURL object. The option types are as follows:  
 - CURLOPT_URL: specifies a URL address.  
- CURLOPT_WRITEFUNCTION: specifies a callback function that receives 
communication results.  
- CURLOPT_WRITEDATA: specifies user data.  
- CURLOPT_USERAGENT: specifies a user agent.  

  
Page 948 / 978 CURLcode curl_easy_perform(CURL *cur l): an API that starts 
communication with a server.  
void curl_easy_cleanup(CURL *curl): an API that deletes CURL data.  
void curl_global_cleanup(void): an API that deletes the entire data of the 
CURL library. Once CURL is used, this API should be called at least once 
before closing the app.  
Eina_Bool elm_image_memfile_set(Evas_Object *obj, const void *img, size_t 
size, const char *format, const char *key): an API that enters original image 
data in an Evas Image object. The parameters listed in order are an E vas 
Image object, image data, data size, and image type.  
  
  
Page 949 / 978 71. Creating a Wearable Source Project  
In this example, we are going to learn how to create a wearable emulator 
and a wearable source project.  
 
A. Running a Wearable Emulator  
In this section, you will learn how to create and run an emulator. Click 
[Windows Start button > All Programs > Tizen SDK > Emulator Manager]. 
If you see a warning window, ignore it and click the Yes button.  
When Emulator Manager is launched, click the second tab button 
'wearable.'  When there is no existing wearable emulator, an emulator 
needs to be created. Click the '+' sign below 'Create New VM' on the left.  
 

  
Page 950 / 978 You will then see a screen where you can designate the options of the 
emulator on the right. Specify 'gears' as the name property. You can leave 
the rest as the default properties. Click the Confirm button to create a 
new emulator.  
 
You will now see a new emulator named 'gears' on the left side of the 
screen. Click the arrow button below the new emulator icon to run the 
emulator. If you want to change the options of the emulator, click the 
Reset button.  
 

  
Page 951 / 978 When the 'Windows Security Warning' popup  window appears, tap the 
Unblock button to continue the process. There is a power button at the 
top right of the emulator, which performs two functions: Power and Home. 
Clicking it once turns on/off the screen, and clicking and holding it 
terminates the em ulator.  
   
When it has been switched to Sleep mode, click the power button, or 
right-click the mouse and then select Close from the shortcut menu.  
Flicking up displays a list of apps, and flicking down moves back to the 
previous screen.  
B. We are now going to create a new source project and create an example 
that requests a Button click event.  
  

  
Page 952 / 978 1) Creating a Source Project  
The first step is to create a new source project. Select [File > New > Tizen 
Native Project] from the main menu of Eclipse.  
 
When  a popup  window for creating a source project appears, select 
[Template > WEARABLE -2.x > Basic UI Application].  
Enter 'WearableEx' in the Project name field.  
 
The field Package name will be automatically filled. Now, click the Finish 
button to create a new source project.  

  
Page 953 / 978 2) Components of Source Project  
The basic source projects of wearable apps are very similar to those of 
mobile apps. The Includes  folder contains libraries.  
This folder includes header files in C language (.h). You can mostly use 
this folder to define libraries, function headers, or global variables.  
The ‘res’ folder is usually used to save resource files including image or 
audio files.  
The ‘src’ folder includes the source files in C language (.c). This folder is 
mainly used to define th e features of functions. Most tasks are performed 
here. 
The ‘shared’ folder includes the app icon images. When you distribute 
your apps to app stores, you can save your app icons here. For Tizen store, 
you should use app icons with a round shape.  
The ‘tize n-manifest.xml’ file includes a variety of app information (e.g. the 
name and version of app) and user’s rights (privileges). It is basically the 
same as AndroidManifest.xml in Android.  
 
 
  

  
Page 954 / 978 3) Running a Basic Source Project  
We are going to run the source project the way it was first created. Right -
click the WearableEx project and then select [Build Project] from the 
shortcut menu. When the project is successfully built, right -click the 
project and select [Run As > 1 Tizen Native Application] from the short cut 
menu. If there is no certificate installed, install a certificate in the same 
way as mobile emulators.  
When the example is run on the emulator, you will see the text 'Hello EFL' 
at the top. This text is displayed using Label Widget.  
 
 
  

  
Page 955 / 978 4) Changing th e Text in a Label  
Now, let’s change the text, 'Hello EFL,' displayed in the Label widget. To 
do this, we need to edit the source file. Open the src folder, and double -
click the 'wearableex.c' file. You can now see the content of the file as 
shown below on the main screen of Eclipse. The source code is similar to 
that for mobile apps, so please see the explanation provided at the 
beginning of this guide.  
We are now going to change the text 'Hello EFL' displayed on the screen. 
Modify the create_base_gui() function as shown 
below:┌─────────────────────┐  
    ad->label = elm_label_add(ad ->conform);  
    //elm_object_text_set(ad ->label, "<align=center>Hello EFL </align>");  
    elm_object_text_set(ad ->label, "Hello World");  
    evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_HINT_EXPAN
D);  
    elm_object_content_set(ad ->conform, ad ->label);  
  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
elm_object_text_set() is an API that changes the caption text of a widget. 
You can use this function for Button and Entry widgets as well as Label 
widgets. You can also specify text properties by using HTM L tags when 
creating text.  
Let's run the example again. When you run an example for the second 
  
Page 956 / 978 time, click [Run > Run] in the main menu or press the 'Ctrl + F11' hotkey. 
The example runs again, and the text on the screen changes to 'Hello 
World.'  
 
 
5) Adding a Button Widget  
In this section, we are going to implement a feature that changes the text 
of a Label when a Button is clicked. The process is the same as for mobile 
apps. Add new code to the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_ EXPAND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Box */  
    Evas_Object *box = elm_box_add(ad ->win);  
    elm_box_padding_set(box, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Label*/  
        ad->label = elm_label_add(ad ->conform);  

  
Page 957 / 978         elm_object_text_set(ad ->label, "Hello World");  
        evas_object_size_hint_weight_set(ad ->label, EV AS_HINT_EXPAND, EVAS_HI
NT_EXPAND);  
        evas_object_size_hint_align_set(ad ->label, EVAS_HINT_FILL, 0.0);  
        elm_box_pack_end(box, ad ->label);  
        evas_object_show(ad ->label);  
 
        /* Button */  
        Evas_Object *btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "Press");  
        evas_object_smart_callback_add(btn, "clicked", btn_click_cb, ad);  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, EVAS_HINT_EXP
AND);  
        evas_object_size_hint_align_set(btn, EV AS_HINT_FILL, 0.0);  
        elm_box_pack_end(box, btn);  
        evas_object_show(btn);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
This code creates a Box container and a Button widget. We specified the 
name of the click event callback function as 'btn_click_cb.' We are now 
going to create this function. Add a new function on top of the 
create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_click_cb(void *data, Evas_Object *obj,  void *event_info)  
{ 
    appdata_s *ad = data;  
  
Page 958 / 978     elm_object_text_set(ad ->label, "Button Pressed");  
} 
└─────────────────────┘  
This code changes the text of the Label widget to 'Button Pressed' when 
a Button is clicked. Run the example again and tap the Bu tton. The text in 
the Label changes. You can see that using the Basic UI is a similar process 
to mobile apps.  
   
  

  
Page 959 / 978 72. Wearable System Information  
At the beginning of this guide, we learned how to request mobile system 
information. In this example, we are going to build the same app as a 
wearable app and see in what ways they are different from each other and 
in others how they are the same.  
1) Existence of a Rear Camera  
Create a new source project and then specify the type as Basic UI 
Application and speci fy the project name as 'wSystemInfo.' After the 
source project is created, open the source file (~.c) under the src folder 
and add a library header file and variables at the top of the source file.  
┌─────────────────────┐  
#include "systeminfo.h"  
#include < system_info.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label1;  
    Evas_Object *label2;  
    Evas_Object *label3;  
    Evas_Object *label4;  
    Evas_Object *label5;  
} appdata_s;  
└─────────────────────┘  
We declared a total of five Label widget variables. In the first Label, we are 
going to display whether or not a rear camera exits; in the second Label, 
  
Page 960 / 978 availability of phone calls; in the third Label, the number of horizontal 
pixels on the monitor; in the  fourth Label, the number of vertical pixels on 
the monitor; and in the fifth Label, the version of the platform.  
Add new code in the create_base_gui() function. This code creates one 
Button widget and five Label widgets.  
┌─────────────────────┐  
    /* Con formant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, ELM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXP AND, EVAS_HINT_EX
PAND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(ad ->conform);  
 
    /* Box */  
    Evas_Object *box = elm_box_add(ad ->win);  
    elm_box_padding_set(box, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object _content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Button */  
        Evas_Object *btn = elm_button_add(ad ->conform);  
        elm_object_text_set(btn, "System Info");  
        evas_object_smart_callback_add(btn, "clicked", btn_clicked_cb, ad);  
        evas_object_size_hint_weight_set(btn, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(btn, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, btn);  
        evas_object_show(btn);  
 
  
Page 961 / 978         /* Label -1 */ 
        ad->label1 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label1, "Back Camera :");  
        evas_object_size_hint_weight_set(ad ->label1, EVAS_HINT_EXPAND, 0);  
        evas_object_ size_hint_align_set(ad ->label1, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label1);  
        evas_object_show(ad ->label1);  
 
        /* Label -2 */ 
        ad->label2 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label2, "Telephony :"); 
        evas_object_size_hint_weight_set(ad ->label2, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->label2, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label2);  
        evas_object_show(ad ->label2);  
 
        /* Label -3 */ 
        ad->label3 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label3, "Pixel Width :");  
        evas_object_size_hint_weight_set(ad ->label3, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->label3, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label3);  
        evas_object_show(ad ->label3);  
 
        /* Label -4 */ 
        ad->label4 = elm_label_add(ad ->conform);  
        elm_object_text_set(ad ->label4, "Pixel Height :");  
        evas_object_size_hint_weight_set(ad ->label4, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->label4, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label4);  
        evas_object_show(ad ->label4);  
 
        /* Label -5 */ 
        ad->label5 = elm_label_add(ad ->conform);  
  
Page 962 / 978         elm_object_text_set(ad ->label5, "Platform Ver :");  
        evas_object_size_hint_weight_set(ad ->label5, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->label5, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label5);  
        evas_object_show(ad ->label5);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
} 
└─────────────────────┘  
We are now going to create a Button callback function. Add new code on 
top of the create_base_gui() function.  
┌─────────────────────┐  
static void  
btn_clicked_cb(void *data, Evas_Object *obj, void *event_info)  
{ 
    appdata_s *ad = data;  
    char buf[100];  
    char *sValue = NULL;  
    bool bValue = false;  
    int nValue = 0;  
    int ret;  
  
    ret = system_info_get_platform_bool("http://tizen.org/feature/camera.back", &bValu
e); 
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Back Camera : %s", bValue ? "True" : "False");  
        elm_object_text_set(ad ->label1, buf);  
    } 
} 
└─────── ──────────────┘   
  
Page 963 / 978 system_info_get_platform_bool(char *, bool *) is an API that requests 
system information. The type of returned data is Boolean. The first 
parameter is the key value, and passing 
'http://tizen.org/feature/camera.back' to the first parameter  returns 
whether or not a rear camera exists.  
Build and run the example. Tap the Button, and you will see the text of 
the first Label has changed. Clicking the Button in an emulator displays 
'False,' while tapping the Button in a user device displays 'True .' 
 
 
2) Existence of a Phone Feature  
In this section, we are going to check whether or not a phone feature 
exists. Add new code at the end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Back Camera : %s", bValue ? "True" : "False");  
        elm_object_text_set(ad ->label1, buf);  

  
Page 964 / 978     } 
  
    ret = system_info_get_platform_bool("http://tizen.org/feature/network.telephon
y", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE ) 
    { 
        sprintf(buf, "Telephony : %s", bValue ? "True" : "False");  
        elm_object_text_set(ad ->label2, buf);  
    } 
} 
└─────────────────────┘  
Passing 'http://tizen.org/feature/network.telephony' to the first parameter 
of the system_info_get_plat form_bool() function returns whether or not a 
phone feature exists. Even if the returned value is True, it does not mean 
that you can make phone calls or that you can use a network. This only 
means that the device is fitted with a hardware communication fe ature. 
You cannot use communication if the device does not have a USIM chip, 
or if the network feature has been deactivated in Settings.  
Build and run the example. Tap the Button and you will see the text 'True' 
displayed in the second Label.  
 
 
  

  
Page 965 / 978 4) Numbe r of Pixels on the Monitor  
In this section, we are going to request the number of pixels of the monitor. 
Add new code at the end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Telephony : %s", bValue ? "True" : "False");  
        elm_object_text_set(ad ->label2, buf);  
    } 
  
    ret = system_info_get_platform_int("tizen.org/feature/screen.width", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Pixel Width : %d", nValue);  
        elm_object_text_set(ad ->label3, buf);  
    } 
  
    ret = system_info_get_platform_int("tizen.org/feature/screen.height", &nValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Pixel Height : %d", nValue);  
        elm_object_text_set(ad ->label4, buf);  
    } 
} 
└─────────────────────┘  
  
  
Page 966 / 978 system_info_get_platform_int(char *, int *) is an API that requests system 
information. The type of returned data is an integer. The first parameter is 
the key value, and passi ng 'http://tizen.org/feature/screen.width' returns 
the number of horizontal pixels on the monitor. Passing 
'tizen.org/feature/screen.height,' meanwhile, returns the number of vertical 
pixels on the monitor.  
Build and run the example. Tap the Button, and yo u will see the values 
displayed in the third Label and fourth Label, respectively.  
 
 
5) Version of the Platform  
In this section, we are going to request the version of the platform. Add 
new code at the end of the btn_clicked_cb() function.  
┌─────────────────────┐  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Pixel Height : %d", nValue);  
        elm_object_text_set(ad ->label4, buf);  
    } 

  
Page 967 / 978      ret = system_info_get_platform_string("http://tizen.org/feature/platform.versio
n", &sValue);  
    if (ret == SYSTEM_INFO_ERROR_NONE)  
    { 
        sprintf(buf, "Platform Ver : %s", sValue);  
        elm_object_text_set(ad ->label5, buf);  
    } 
} 
└─────────────────────┘  
system_info_get_platform_string(char *, char  **) is an API that requ ests 
system information. The type of returned data is string. The first parameter 
is the key value, and passing 'http://tizen.org/feature/platform.version' 
returns the version of the platform.  
Build and run the example. Tap the Button, and you will see the  version 
of the platform displayed in the fifth Label.  
 
This illustrates that we can also use the APIs that we used for mobile apps 
for wearable apps.  
  

  
Page 968 / 978 73. Using a Pressure Sensor  
Features that smartphones do not have, such as heart rate sensors and 
pressure sensors, are added to wearable devices. In this example, we are 
going to learn how to use the pressure sensor.  
 
1) Adding a Feature  
Create a new source project and specify the project name as 
'wSensorPressure.' To use the pressure sensor feature, you need to add 
the relevant feature. After the source project is created, open the tizen -
manifest.xml file, and click Features among the tab buttons below. Then, 
click the Add button in the upper right corner. When a popup  window 
appears, select http://ti zen.org/feature/sensor.barometer from the list, and 
click the OK button to close the window.  
  
Page 969 / 978  
Add the following feature by repeating the procedure above.  
 - http://tizen.org/feature/sensor.barometer.wakeup  
After saving, click the 'tizen -manifest.xml' butt on in the far right corner 
from the tab buttons located at the bottom; you should be able to see 
the source code of the xml file.  
┌─────────────────────┐  
<?xml version="1.0" encoding="UTF -8" standalone="no"?>  
<manifest xmlns="http://tizen.org/ns/packages" api-version="2.3.1" package="org. exa
mple.wsensorpressure" version="1.0.0">  
    <profile name="wearable"/>  
    <ui-application appid="org. example .wsensorpressure" exec="wsensorpressure" multi
ple="false" nodisplay="false" taskmanage="true" type="capp">  
        <label>wsensorpressure</label>  
        <icon>wsensorpressure.png</icon>  

  
Page 970 / 978     </ui-application>  
    <feature name="http://tizen.org/feature/sensor.barometer">true</feature>  
    <feature name="http://tizen.org/feature/sensor.barometer.wakeup">true</feat
ure> 
</manifest>  
└─────────────────────┘  
 
2) Determining Whether the Pressure Sensor is Supported  
Create a new source project and specify the project name as 
'wSensorPressure.' After the source project is created, open the source file 
(~.c) under the src fold er and add a library header file and variables.  
┌─────────────────────┐  
#include "wsensorpressure.h"  
#include <sensor.h>  
  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
└─────────────────────┘  
sensor.h is the header file for various sensor libraries.  
In label0, we are going to display whether or not the pressure sensor is 
supported, and in label1, the level of pressure.  
  
  
Page 971 / 978 Add a new function on top of the create _base_gui() function.  
┌─────────────────────┐  
static void show_is_supported(appdata_s *ad)  
{ 
    char buf[PATH_MAX];  
    bool is_supported = false;  
    sensor_is_supported(SENSOR_PRESSURE, &is_supported);  
    sprintf(buf, "Pressure Sensor is %s", is_suppor ted ? "support" : "not support");  
    elm_object_text_set(ad ->label0, buf);  
} 
└─────────────────────┘  
show_is_supported() is a function that, after determining whether the 
pressure sensor is supported, displays the result in the first Label widget.  
sensor_is_supported(sensor_type_e, bool *) is an API that requests whether 
a certain sensor is supported. Passing SENSOR_PRESSURE to the first 
parameter makes the second parameter return whether or not the pressure 
sensor is supported.  
We need to make it so that this function is called when the app is run. 
Call the function above at the end of the create_base_gui() function.  
┌─────────────────────┐  
    /* Conformant */  
    ad->conform = elm_conformant_add(ad ->win);  
    elm_win_indicator_mode_set(ad ->win, E LM_WIN_INDICATOR_SHOW);  
    elm_win_indicator_opacity_set(ad ->win, ELM_WIN_INDICATOR_OPAQUE);  
    evas_object_size_hint_weight_set(ad ->conform, EVAS_HINT_EXPAND, EVAS_HINT_EXP
AND);  
    elm_win_resize_object_add(ad ->win, ad ->conform);  
    evas_object_show(a d->conform);  
  
Page 972 / 978  
    /* Box */  
    Evas_Object *box = elm_box_add(ad ->win);  
    elm_box_padding_set(box, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(10));  
    elm_object_content_set(ad ->conform, box);  
    evas_object_show(box);  
 
    { 
        /* Label -0 */ 
        ad->label0 = elm_label_add(ad ->conform);  
        elm_label_line_wrap_set(ad ->label0, EINA_TRUE);  
        elm_object_text_set(ad ->label0, "Msg - "); 
        //evas_object_size_hint_weight_set(ad ->label, EVAS_HINT_EXPAND, EVAS_H
INT_EXPAND);  
        //elm_object _content_set(ad ->conform, ad ->label);  
        evas_object_size_hint_weight_set(ad ->label0, EVAS_HINT_EXPAND, 0);  
        evas_object_size_hint_align_set(ad ->label0, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label0);  
        evas_object_show(ad ->label0);  
 
        /* Label -1 */ 
        ad->label1 = elm_label_add(ad ->conform);  
        elm_label_line_wrap_set(ad ->label1, EINA_TRUE);  
        elm_object_text_set(ad ->label1, "Value - "); 
        evas_object_size_hint_weight_set(ad ->label1, EVAS_HINT_EX PAND, 0);  
        evas_object_size_hint_align_set(ad ->label1, EVAS_HINT_FILL, 0);  
        elm_box_pack_end(box, ad ->label1);  
        evas_object_show(ad ->label1);  
    } 
 
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);   
 
    show_is_supported(ad);  
  
Page 973 / 978 } 
└─────────────────────┘  
We created a Box container and two Label widgets. We also called the 
function that determines whether or not a sensor is supported.  
Build and run the example. If the pressure sensor is supported, the 
message ' Pressure Sensor is supported' is displayed. Some models may 
not support the sensor. In such cases, you need to test it on the emulator.  
 
 
2) Requesting a Pressure Sensor Event  
In this section, we are going to implement a feature that, when an object 
is detected by a pressure sensor, requests the relevant event and then 
displays the distance on the screen. Add a sensor -related structure and 
global variable at the top of the source file.  
┌─────────────────────┐  
typedef struct appdata {  
    Evas_Object *win;  
    Evas_Object *conform;  
    Evas_Object *label0;  
    Evas_Object *label1;  
} appdata_s;  
  

  
Page 974 / 978 typedef struct _sensor_info  
{ 
    sensor_h sensor;        /**< Sensor handle */  
    sensor_listener_h sensor_listener;  
} sensorinfo;  
  
static sensorinfo sensor_info;  
└─────────────────────┘  
sensorinfo is a structure that includes the sensor object and event listener 
variable.  
sensor_info is the global variable of the sensorinfo structure.  
Requesting a sensor event means starting a listener. We are now going to 
reques t a pressure sensor event using a sensor object and an event listener. 
Add two new functions at the top of the create_base_gui() function.  
┌─────────────────────┐  
static void _new_sensor_value(sensor_h sensor, sensor_event_s *sensor_data, void *use
r_data)  
{ 
    if( sensor_data ->value_count < 1 )  
        return;  
    char buf[PATH_MAX];  
    appdata_s *ad = (appdata_s*)user_data;  
  
    sprintf(buf, "Pressure : %0.1f hPa", sensor_data ->values[0]);  
    elm_object_text_set(ad ->label1, buf);  
} 
  
static void  
start_pressure_sensor(appdata_s *ad)  
  
Page 975 / 978 { 
    sensor_error_e err = SENSOR_ERROR_NONE;  
    sensor_get_default_sensor(SENSOR_PRESSURE, &sensor_info.sensor);  
    err = sensor_create_listener(sensor_info.sensor, &sensor_info.sensor_listener);  
    sensor_listener_ set_event_cb(sensor_info.sensor_listener, 100, _new_sensor_value, ad);  
    sensor_listener_start(sensor_info.sensor_listener);  
} 
└─────────────────────┘  
_new_sensor_value() is the callback function for the pressure sensor event. 
It displays a new sensor va lue on the screen.  
Sensor data is passed to the second parameter. Numeric data is saved in 
values[0].  
start_pressure_sensor() is a function that starts the pressure sensor and 
specifies an event callback function.  
sensor_get_default_sensor(sensor_type_e, s ensor_h *) is an API that returns 
the sensor object. Passing SENSOR_PRESSURE to the first parameter makes 
the second parameter return the pressure sensor object.  
  
  
Page 976 / 978 sensor_create_listener(sensor_h, sensor_listener_h *) is an API that creates 
an event listen er. Passing the sensor object to the first parameter makes 
the second parameter return the listener object.  
sensor_listener_set_event_cb(sensor_listener_h, unsigned int, 
sensor_event_cb, void *) is an API that specifies a callback function for a 
listener. The parameters listed in order are an event listener, time interval 
(in milliseconds), name of the callback function, and user data.  
sensor_listener_start(sensor_listener_h) is an API that starts a listener.  
We are going to make it so that an event listene r is automatically run 
when the app is run. Call the function above at the end of the 
create_base_gui() function.  
┌─────────────────────┐  
    /* Show window after base gui is set up */  
    evas_object_show(ad ->win);  
  
    show_is_supported(ad);  
    start_pressure_sensor(ad);  
} 
└─────────────────────┘  
Let's run the example again. When testing the feature on the emulator, 
use the Control Panel.  
Right-click the emulator and select Control Panel in the shortcut menu.  
When the Control Panel appears, s elect the [Event Injector > Pressure] 
from the tree list to the left.  
  
Page 977 / 978 Drag the slide bar in the right pane of Control Panel left and right. If the 
figure on the emulator's second Label changes, it means that the feature 
has been implemented successfully.  
 
 
3) Related APIs  
int sensor_is_supported(sensor_type_e type, bool *supported): an API that 
requests whether or not a certain sensor is supported. Passing 
SENSOR_PRESSURE to the first parameter makes the second parameter 
return whether or not the pressure sensor is supported.  
int sensor_get_default_sensor(sensor_type_e type, sensor_h *sensor): an 
API that returns the sensor object. Passing SENSOR_PRESSURE to the first 
parameter makes the second parameter return the pressure sensor object.  
int sensor_create_ listener(sensor_h sensor, sensor_listener_h *listener): an 
API that creates an event listener. Passing the sensor object to the first 
parameter makes the second parameter return the listener object.  
int sensor_listener_set_event_cb(sensor_listener_h listen er, unsigned int 
interval_ms, sensor_event_cb callback, void *data): an API that specifies a 
callback function for a listener. / parameters: an event listener, time interval 

  
Page 978 / 978 (in milliseconds), name of the callback function, and user data.  
int sensor_listen er_start(sensor_listener_h listener): an API that starts a 
listener.  

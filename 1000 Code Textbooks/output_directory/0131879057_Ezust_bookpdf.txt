An Introduction to Design
Patterns in C++ with Qt 4ezus_138004_fm.qxd  8/3/06  4:25 PM  Page i
Perens_Series_7x9_25.qxd  5/22/06  1:15 PM  Page 1
Upper Saddle River, NJ • Boston • Indianapolis • San Francisco
New Y ork • T oronto • Montreal • London • Munich • Paris • MadridCapetown • Sydney • T okyo • Singapore • Mexico CityAn Introduction to 
Design Patterns
in C++ with Qt 4
Alan Ezust
Paul Ezustezus_138004_fm.qxd  8/3/06  4:25 PM  Page iii
Many of the designations used by manufacturers and se llers to distinguish their products are claimed as trade-
marks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the des-
ignations have been printed with initial capital letters or in all capitals.
The authors and publisher have taken care in the preparation of this book, but make no expressed or implied war-
ranty of any kind and assume no responsibility for errors  or omissions. No liability is assumed for incidental or
consequential damages in connection with or arising out of the use of the information or programs containedherein.
The publisher offers excellent discounts on this book when  ordered in quantity for bulk purchases or special sales,
which may include electronic versions and/or custom covers and content particular to your business, training goals,marketing focus, and branding interests. For more information, please contact:
U.S. Corporate and Government Sales
(800) 382-3419corpsales@pearsontechgroup.com
For sales outside the United States, please contact:
International Sales
international@pearsoned.com
This Book Is Safari Enabled
The Safari® Enabled icon on the cover of your favorite technology book means the book is
available through Safari Bookshelf. When you buy this book, you get free access to the onlineedition for 45 days.
Safari Bookshelf is an electronic reference library that lets you easily search thousands of technical books, ﬁnd code
samples, download chapters, and access technical information whenever and wherever you need it.
T o gain 45-day Safari Enabled access to this book:• Go to http://www.prenhallprofessional.com/safarienabled• Complete the brief registration form• Enter the coupon code 1AMQ-56YL-KJ1A-LXLU-GGLTIf you have difﬁculty registering on Safari Bookshelf or accessing the online edition, please e-mail 
customer-service@safaribooksonline.com.
Visit us on the Web: www.prenhallprofessional.com
Library of Congress Cataloging-in-Publication DataEzust, Alan.
An introduction to design patterns in C++ with Qt 4 / Alan Ezust, Paul Ezust.
p. cm.
Includes bibliographical references and index.ISBN 0-13-187905-7 (pbk. : alk. paper)
1. C++ (Computer program language) 2. Softwar e patterns. 3. Computer software—Reusability.
I. Ezust, Paul. II. Title.
QA76.73.C153E94 2006
005.13 /H110323—dc22
2006011947
Copyright © 2007 Pearson Education, Inc.
This material may only be distributed subject to the terms and conditions set forth in the Open Publication License,
v1.0 or later. (The latest version is presentl y available at http://www.opencontent.org/openpub/.)
For information regarding permissions, write to:
Pearson Education, Inc.
Rights and Contracts DepartmentOne Lake StreetUpper Saddle River, NJ 07458Fax: (201) 236-3290
ISBN 0-13-187905-7T ext printed in the United States on recycled paper at Courier in Stoughton, Massachusetts.First printing, August 2006ezus_138004_fm.qxd  8/3/06  4:25 PM  Page iv
This book is dedicated to Miriam Ezust,
without whom none of our work 
would have been possible.ezus_138004_fm.qxd  8/3/06  4:25 PM  Page v
ezus_138004_fm.qxd  8/3/06  4:25 PM  Page vi
Contents
Preface   xix
Acknowledgments   xxiiiRationale for the Book   xxvAbout the Authors   xxvii
PART I Introduction to C++ and Qt 4 2
1 C++ Introduction 5
1.1 Overview of C++ 6
1.2 A Brief History of C++ 61.3 Setup: Open-Source Platforms 7
1.3.1 *nix 7
1.3.2 Downloading from Source 9
1.4 Setup: Win32 12
1.5 C++ First Example 121.6 Input and Output 161.7 Identiﬁers, Types, and Literals 191.8 C++ Simple Types 22
1.8.1 main and Command Line Arguments   24
1.8.2 Arithmetic 25
1.9 C++ Standard Library Strings 30
1.10 Streams 311.11 The Keyword const 341.12 Pointers and Memory Access 36
1.12.1 The Unary Operators & and * 36
1.12.2 Operators new and delete 38
viiezus_138004_fm.qxd  8/3/06  4:25 PM  Page vii
1.13 const* and *const 40
1.14 Reference Variables 43
Points of Departure   44Review Questions   45
2 Classes 47
2.1 Structs 482.2 Class Deﬁnitions 492.3 Member Access Speciﬁers 512.4 Encapsulation 542.5 Introduction to UML 54
2.5.1 UML Relationships 55
2.6 Friends of a Class 552.7 Constructors 562.8 Subobjects 582.9 Destructors 602.10 The Keyword static 612.11 Copy Constructors and Assignment Operators 642.12 Conversions 672.13 const Member Functions 68
Review Questions   79
3 Introduction to Qt   81
3.1 Example Project: Using QApplication 
and QLabel 82
3.2 Makeﬁle, qmake, and Project Files 83
3.2.1 #include: Finding Header Files 85
3.2.2 The make Command 863.2.3 Cleaning Up Files 88
3.3 Getting Help Online 89
3.4 Style Guidelines and Naming Conventions 903.5 The Qt Core Module 913.6 Streams and Dates 91
Points of Departure   93Review Questions   94viiiCONTENTSezus_138004_fm.qxd  8/3/06  4:25 PM  Page viii
4 Lists 95
4.1 Introduction to Containers 96
4.2 Iterators 97
4.2.1 QStringList and Iteration 97
4.3 Relationships 99
Points of Departure   102Review Questions   103
5 Functions 105
5.1 Function Declarations 1065.2 Overloading Functions 1075.3 Optional Arguments 1095.4 Operator Overloading 1115.5 Parameter Passing by Value 1165.6 Parameter Passing by Reference 1185.7 References to const 1215.8 Function Return Values 1225.9 Returning References from Functions 1225.10 Overloading on const-ness 1245.11 Inline Functions 1265.12 Inlining versus Macro Expansion 127
Review Questions   133
6 Inheritance and Polymorphism 135
6.1 Simple Derivation 136
6.1.1 Inheritance Client Code Example 141
6.2 Derivation with Polymorphism 1426.3 Derivation from an Abstract Base Class 1486.4 Inheritance Design 1526.5 Overloading, Hiding, and Overriding 1546.6 Constructors, Destructors, and Copy Assignment Operators 1556.7 Processing Command-Line Arguments 158
6.7.1 Derivation and ArgumentList 159
Points of Departure   164Review Questions   165CONTENTS
ixezus_138004_fm.qxd  8/3/06  4:25 PM  Page ix
PART II Higher-Level Programming 166
7 Libraries 169
7.1 Code Containers 170
7.2 Reusing Other Libraries 1717.3 Organizing Libraries: Dependency Management 173
7.3.1 Installing Libraries 176
7.4 Installing Libraries: A Lab Exercise 176
7.4.1 Fixing the Linker Path 177
7.5 Frameworks and Components 178
Review Questions   180
8 Introduction to Design Patterns 181
8.1 Iteration and the Visitor Pattern 182
8.1.1 Directories and Files: QDir and QFileInfo 183
8.1.2 Visitor Pattern 1848.1.3 Customizing the Visitor Using Inheritance 186
Review Questions   190
9 QObject 191
9.1 QObject’s Child Managment 194
9.2 Composite Pattern: Parents and Children 196
9.2.1 Finding Children 199
9.3 QApplication and the Event Loop 200
9.3.1 Layouts: A First Look 202
9.3.2 Connecting to Slots 2039.3.3 Signals and Slots 204
9.4 Q_OBJECT and moc: A Checklist 209
9.5 Values and Objects 2109.6 tr() and Internationalization 211
Point of Departure   211Review Questions   212xCONTENTSezus_138004_fm.qxd  8/3/06  4:25 PM  Page x
10 Generics and Containers 213
10.1 Generics and T emplates 214
10.1.1 Function Templates 214
10.1.2 Class Templates 216
10.2 Containers 219
10.3 Managed Containers, Composites,
and Aggregates 221
10.4 Implicitly Shared Classes 22410.5 Generics, Algorithms, and Operators 22510.6 Serializer Pattern 227
10.6.1 Beneﬁts of the Serializer 229
10.7 Sorted Map Example 229
Review Questions   235
11 Qt GUI Widgets 237
11.1 Widget Categories 23911.2 QMainWindow and QSettings 240
11.2.1 QSettings: Saving and Restoring 
Application State 242
11.3 Dialogs 244
11.3.1 Input Dialogs and Widgets 246
11.4 Images and Resources 248
11.5 Layout of Widgets 251
11.5.1 Spacing, Stretching, and Struts 254
11.5.2 Moving Widgets across Layouts 256
11.6 QActions, QMenus, and QMenuBars 260
11.7 QActions, QT oolbars, and QActionGroups 262
11.7.1 The Command Pattern 262
11.8 Regions and QDockWidgets 27011.9 Views of a QStringList 272
Points of Departure   274Review Questions   275CONTENTS
xiezus_138004_fm.qxd  8/3/06  4:25 PM  Page xi
12 Concurrency 277
12.1 QProcess and Process Control 278
12.1.1 Processes and Environment 280
12.1.2 Qonsole: Writing an Xterm in Qt 28412.1.3 Qonsole with Keyboard Events 286
12.2 Threads and QThread 290
12.2.1 QPixmap and QThread Animation 
Example: Movie Player 290
12.2.2 Movie Player with QTimer 29412.2.3 Multiple Threads, Queues, and Loggers 
Example: Giant 296
12.2.4 Thread Safety and QObjects 302
12.3 Summary: QProcess and QThread 303
Review Questions   305
13 Validation and Regular Expressions 307
13.1 Validators 30813.2 Regular Expressions 310
13.2.1 Regular Expression Syntax 311
13.2.2 Regular Expressions: Phone 
Number Recognition 313
13.3 Regular Expression Validation 316
Review Questions   319
14 Parsing XML 321
14.1 The Qt XML Module 32514.2 Event-Driven Parsing 32514.3 XML, Tree Structures, and DOM 329
14.3.1 Visitor Pattern: DOM Tree Walking 331
14.3.2 Generation of XML with DOM 335
Review Questions   340
15 Meta Objects, Properties, and Reﬂective Programming 341
15.1 Anti-patterns 342
15.2 QMetaObject: The MetaObject Pattern 344xiiCONTENTSezus_138004_fm.qxd  8/3/06  4:25 PM  Page xii
15.3 Type Identiﬁcation and qobject_cast 345
15.4 Q_PROPERTY Macro: Describing QObject Properties 34715.5 QVariant Class: Accessing Properties 35015.6 DataObject: An Extension of QObject 35315.7 Property Containers: PropsMap 355
Review Questions   357
16 More Design Patterns 359
16.1 Creational Patterns 360
16.1.1 Abstract Factory 361
16.1.2 Abstract Factories and Libraries 36316.1.3 qApp and Singleton Pattern 36516.1.4 Creation Rules and friend Functions
(What Friends Are Really For) 366
16.1.5 Beneﬁts of Using Factories 369
16.2 Serializer Pattern Revisited 373
16.2.1 Exporting to XML 37516.2.2 Importing Objects with an Abstract Factory 376
16.3 The Façade Pattern 381
16.3.1 Functional Façade 38416.3.2 Smart Pointers: auto_ptr 38416.3.3 FileTagger: Façade Example 385
Points of Departure   389
Review Questions   390
17 Models and Views 391
17.1 M-V-C: What about the Controller? 39217.2 Dynamic Form Models 393
17.2.1 Form Models 397
17.2.2 Form Views 40017.2.3 Unforseen Types 40317.2.4 Controlling Actions 40417.2.5 DataObject Form Model 405
17.3 Qt 4 Models and Views 409
17.4 Table Models 411CONTENTS
xiiiezus_138004_fm.qxd  8/3/06  4:25 PM  Page xiii
17.5 Tree Models 417
17.5.1 Extended Tree Widget Items 418
Review Questions   421
18 Qt SQL Classes 423
18.1 Introduction to MySQL 424
18.2 Queries and Result Sets 42718.3 Database Models 429
Review Questions   433
PART III C++ Language Reference 434
19 Types and Expressions 437
19.1 Operators 438
19.2 Evaluation of Logical Expressions 44319.3 Enumerations 44319.4 Signed and Unsigned Integral Types 44519.5 Standard Expression Conversions 44719.6 Explicit Conversions 44919.7 Safer Typecasting Using ANSI C++ Typecasts 450
19.7.1 static_cast and const_cast 450
19.7.2 reinterpret_cast 45319.7.3 Why Not Use C-style Casts? 454
19.8 Run-Time Type Identiﬁcation (RTTI) 454
19.8.1 typeid Operator 456
19.9 Member Selection Operators 457
Point of Departure   458Review Questions   461
20 Scope and Storage Class 463
20.1 Declarations and Deﬁnitions 46420.2 Identiﬁer Scope 465
20.2.1 Default Scope of Identiﬁers: A Summary 466
20.2.2 File Scope versus Block Scope and operator:: 468
20.3 Storage Class 470
20.3.1 Globals, statics, and QObject 471xivCONTENTSezus_138004_fm.qxd  8/3/06  4:25 PM  Page xiv
20.4 Namespaces 473
20.4.1 Anonymous Namespaces 476
20.4.2 Open Namespaces 47620.4.3 Namespace, static Objects and extern 476
Review Questions   478
21 Statements and Control Structures 479
21.1 Statements 480
21.2 Selection Statements 48021.3 Iteration 48321.4 Exceptions 485
21.4.1 Exception Handling 486
21.4.2 Exception Types 48621.4.3 throwing Things Around 48721.4.4 try and catch 49021.4.5 More about throw 49421.4.6 Rethrown Exceptions 49621.4.7 Exception Expressions 497
Review Questions   502
22 Memory Access 503
22.1 Pointer Pathology 504
22.2 Further Pointer Pathology with Heap Memory 50622.3 Memory Access Summary 50922.4 Introduction to Arrays 50922.5 Pointer Arithmetic 51022.6 Arrays, Functions, and Return Values 51122.7 Different Kinds of Arrays 51322.8 Valid Pointer Operations 51322.9 What Happens If new Fails? 515
22.9.1 set_new_handler(): Another Approach to New Failures 516
22.9.2 Using set_new_handler and bad_alloc 51722.9.3 Checking for null: The Updated Way to Test for New Failures 518
22.10 Chapter Summary 519
Review Questions   521CONTENTS
xvezus_138004_fm.qxd  8/3/06  4:25 PM  Page xv
23 Inheritance in Detail 523
23.1 Virtual Pointers and Virtual Tables 524
23.2 Polymorphism and virtual Destructors 52623.3 Multiple Inheritance 528
23.3.1 Multiple Inheritance Syntax 529
23.3.2 Multiple Inheritance with Abstract Interfaces 531
Point of Departure   532
23.3.3 Resolving Multiple Inheritance Conﬂicts 532
23.4 public, protected, and private Derivation 536
Review Questions   539
24 Miscellaneous Topics 541
24.1 Functions with Variable-Length Argument Lists 54224.2 Resource Sharing 543
PART IV Programming Assignments 548
25 MP3 Jukebox Assignments 551
25.1 Data Model: Mp3File 553
25.2 Visitor: Generating Playlists 55525.3 Preference: An Enumerated Type 55625.4 Reusing id3lib 55925.5 PlayListModel Serialization 56025.6 T esting Mp3File Related Classes 56125.7 Simple Queries and Filters 56125.8 Mp3PlayerView 56325.9 Models and Views: PlayList 56525.10 Source Selector 56625.11 Persistent Settings 56725.12 Edit Form View for FileTagger 56825.13 Database View 569
Points of Departure   571xviCONTENTSezus_138004_fm.qxd  8/3/06  4:25 PM  Page xvi
PART V Appendices   572
Appendix A: C++ Reserved Keywords 575
Appendix B: Standard Headers 577Appendix C: The Development Environment 579
C.1 The Preprocessor: For #including Files 579
C.2 Understanding the Linker 582
C.2.1 Common Linker Error Messages 584
C.3 Debugging 587
C.3.1 Building a Debuggable Target 588
C.3.2 gdb Quickstart 589C.3.3 Finding Memory Errors 590
C.4 Qt Assistant and Designer 593
C.5 Open-Source IDEs and Development T ools 594
C.5.1 UML Modeling Tools 597
C.5.2 jEdit 598
Bibliography   601
Index   603CONTENTS
xviiezus_138004_fm.qxd  8/3/06  4:25 PM  Page xvii
ezus_138004_fm.qxd  8/3/06  4:25 PM  Page xviii
Preface
C++ had been in use for many years before it was standardized in 1989, which
makes it a relatively mature language compared to others that are in popular usetoday. It is a very important language for building fast, efﬁcient, mission-criticalsystems. C++ is also one of the most ﬂexible languages around, giving developersmany choices of programming styles for use in high-level GUI code as well as low-level device drivers.
For a few years in the early ’90s, C++ was the most popular object-oriented
(OO) language in use, and many computer science (CS) students were introducedto object-oriented programming (OOP) via C++. This was because C++ provideda relatively easy transition to OOP for C programmers, and many CS professors hadbeen teaching C previously.
Starting around 1996, Java gained favor over C++ as the ﬁrst OO language
for students to learn. There are a number of reasons that Java gained so muchpopularity.
■The language itself is simpler than C++.
■The language has built-in garbage collection, so programmers do notneed to concern themselves with memory de-allocation.
■A standard set of GUI classes is included in the development kit.
■The built-in String class supports Unicode.
■Multithreading is built into the language.
■It is easier to build and “plug in” Java Archives (JARs) than it is to recom-pile and relink libraries.
■Many Web servers provide Java APIs for easy integration.
■Java programs are platform independent (Wintel, Solaris, MacOS, Linux,*nix, etc.).
xixezus_138004_fm.qxd  8/3/06  4:25 PM  Page xix
Many of Java’s beneﬁts listed above can be achieved with C++ used in conjunction
with Qt 4.
■Qt provides a comprehensive set of GUI classes that run faster, look bet-ter, and are more ﬂexible than Java’s 
Swing classes.
■Signals and slots are easier to use than (Action|Event|Key)Listener
interfaces in Java.
■Qt 4 has a plugin architecture that makes it possible to load code into anapplication without recompiling or relinking.
■Qt 4 provides foreach , which makes iteration through collections sim-
pler to read and write.
Although Qt does not provide garbage collection, there are a variety of alternatives
one can use to avoid the need to delete heap objects directly.
1. Containers (see Section 10.2)
2. Parents and children (see Section 9.2)3.
auto_ptr (see Section 16.3.2)
4.QPointer (see Section 19.9).
5. Subobjects (see Section 2.8)6. Stack objects (see Section 20.3)
Using C++ with Qt comes very close to Java in ease of use, comprehensiveness,
and convenience. It signiﬁcantly exceeds Java in the areas of speed and efﬁciency,making everything from processing-intensive server applications to high-speedgraphics-intensive games possible.
Another beneﬁt of learning C++ with Qt comes from Qt’s widespread use in
open-source projects. There is already a great wealth of free open-source code thatyou can learn from, reuse, and perhaps help to improve.
How to Use This Book
Part I contains an introduction to C++, UML, and the Qt core. This part isdesigned to avoid forward referencing as much as possible, and it presents the top-ics in an order and a level of detail that should not overwhelm someone who isnew to C/C++.
In Part II, you will ﬁnd higher-level programming ideas, Qt modules, and
design patterns. Here we present paradigm-shifting ways of writing code andorganizing objects in a modular fashion.xxPREFACEezus_138004_fm.qxd  8/3/06  4:25 PM  Page xx
For completeness and for reference, Part III covers in more depth some of the
“dry” but important C++ features that were introduced in Part I. By the time the
reader has reached this point, these ideas should be a lot easier to understand.
At the end of each chapter, you will ﬁnd exercises and review questions. Most
of the programming exercises have solutions available on our Web site. For thequestions, if the answers are not in the preceding chapter, then often there arepointers on where to ﬁnd them. If this book is used for a course, these questionscould be asked by the student or by the teacher, in the classroom or on an exam.
Source code ﬁles for all the examples in this book are contained in the ﬁle
src.tar.gz, which can be downloaded from http://oop.mcs.suffolk.edu/dist.
A Note about Formats and Book Production
What you are reading now is only one of a number of possible versions of this textavailable. Because the document was originally written in XML, using a “literalprogramming” style, we can generate a variety of different versions (bulletedslides, paragraphed textbook, with or without solutions, etc.) in a variety of dif-ferent formats (html, pdf, ps, htmlhelp).
Each programming example is extracted from working source code. The Web
version provides a hyperlink from each code excerpt to its full source ﬁle. Thismakes it very easy to try the examples yourself. The text and listings in the Webversion also contain hyperlinks from each library ClassName to its class docu-mentation page.
We wrote the original manuscript using jEdit and gnu-emacs, marking it up
with a modiﬁed DocBook/XML syntax that we converted into pure DocBook/XMLusing a custom XML processor called Slacker’s DocBook written in Python. Mostof the original diagrams were produced with Umbrello or Dia, but a couple wereproduced with Doxygen and Dot. The ﬁnal book was typeset in QuarkXPress. Wegenerate many different versions (ove rhead slides, textbooks, labs, and solutions) of
this text for our own use, some in HTML, some in PostScript, and some in PDF.
The XML and image processors we used were Apache Ant, Xerces, FOP , Gnu
xsltproc, ReportLab pyRXP , ImageMagick, JAI, JINI, and XEP . We did all of theediting and processing of the original manuscript on GNU/Linux systems underKDE. The example programs all compile and run under Linux.
The cover photo is of the Panama Canal. Before there was a Panama Canal,
ships had to travel down and then up the entire length of South America to getfrom one coast of the United States to the other. The canal provided a muchshorter and more direct path. The aim of this book is to provide a shorter andPREFACE
xxiezus_138004_fm.qxd  8/3/06  6:52 PM  Page xxi
xxiiPREFACE
more direct path for programmers who don’t have a lot of extra time and who
need to obtain working mastery of C++ OOP and design patterns. Qt 4 makes thispossible.
Style Conventions
■Monospace —used for any literal symbol that appears in the code
listings
■ Bold —used the ﬁrst time a term appears (key terms, deﬁned terms, etc.)
■Italic —used for emphasis, and also used for wildcards (terms that need
to be replaced by “real types” when they are actually used). In monospacetext, these terms are set italic and monospace.ezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxii
Acknowledgments 
Thanks to the many authors and contributors involved in following open-source
projects, for making the free tools, for answering questions, and for writing gooddocs. We used all of these programs to make this book:
■jEdit (http://jedit.sourceforge.net)
■Umbrello (http://uml.sourceforge.net/index.php)
■Firefox (http://www.mozilla.org/products/ﬁrefox/),Mozilla (http://www.mozilla.org/)
■Doxygen (http://www.stack.nl/~dimitri/doxygen/)
■dia (http://www.gnome.org/projects/dia/)
■imagemagick (http://www.image magick.org/script/index.php)
■graphviz (http://www.research.att.com/sw/tools/graphviz/)
■KDE (http://www.kde.org/), kdevelop (http://www.kdevelop.org/),
kdbg (http://members.nextra.at/johsixt/kdbg.html)
■docbook (http://www.docbook.org/),docbook-xsl (http://docbook.sourceforge.net/projects/xsl/)
■xsltproc, xmllint, gnu xml libs (http://xmlsoft.org/XSLT/xsltproc2.html)
■cvs (http://www.nongnu.org/cvs/),subversion (http://subversion.tigris.org/)
■MoinMoin (http://moinmoin.wikiwikiweb.de/)
■Bugzilla (http://www.bugzilla.org/)
■Apache httpd (http://httpd.apache.org/), ant (http://ant.apache.org/),fop (http://xmlgraphics.apache.org/fop/)
■gaim (http://gaim.sourceforge.net)
■Python (http://www.python.org)
xxiiiezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxiii
xxivACKNOWLEDGMENTS
■ReportLab PyRXP (http://www.reportlab.org/pyrxp.html)
■pyQt (http://www.riverbankcomputing.co.uk/pyqt/index.php),
pyKDE (http://www.riverbankcomputing.co.uk/pykde/index.php),qscintilla (http://www.riverbankcomputing.co.uk/qscintilla/index.php),eric3 (http://www.die-offenbachs.de/detlev/eric3.html)
■mysql (http://www.mysql.com/)
■GNU Emacs (http://www.gnu.org/software/emacs/emacs.html)
■Linux (http://www.kernel.org/), gcc (http://gcc.gnu.org/),gdb (http://www.gnu.org/software/gdb/gdb.html)
■valgrind (http://valgrind.org/)
Thanks to Norman Walsh [docbook] and Bob Stayton [docbookxsl] for develop-
ing and documenting a superb system of publishing tools. Thanks to the rest ofthe docbook community for help and guidance.
Thanks to the volunteers at debian.org for keeping Sid up to date and still sta-
ble enough to be a productive develo pment platform. Thanks to irc.freenode.net
for bringing together a lot of good brains.
Thanks to Emily Ezust for wordsmithing skills and for getting us started with
Qt in the ﬁrst place. Thanks to the reviewers who provided input and valuablefeedback on the text: Mark Summerﬁeld, Johan Thelin, Stephen Dewhurst, HalFulton, David Boddie, Andy Shaw, and Jasmin Blanchette [Blanchette04], who alsotaught us the Qt 4 dance! 
Thanks to Matthias Ettrich for the vision and motivation. Thanks to the rest of
the team at Trolltech for writing good docs, answering questions on the mailinglists, and being so “open” with the open-source community.
Thanks to the editorial and production staff at Prentice Hall for their meticu-
lous reading of our book and for helping us to ﬁnd the many errors that were dis-tributed throughout the text.
Finally, thanks to Suffolk University, a source of great support throughout this
project. In particular, thanks to Andrew T eixeira for his tireless help in maintain-ing the servers that we used heavily for the past two years and for his invaluabletechnical advice. Thanks also to the students who took CMPSC 331/608 using theevolving preliminary versions of this book since the fall of 2003 and who providedus with a stream of valuable feedback.ezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxiv
Rationale for the Book 
At Suffolk University, we buck the popular trend and continue teaching object-
oriented programming using C++. For many years we taught a standard one-semester OOP/C++ course that followed a CS1-CS2 sequence based on the Cprogramming language. Students developed substantial mastery of the core C++language and an understanding of some OO concepts such as encapsulation, refac-toring, and tool development. However, we found that STL is a library that oftenoverwhelms students and causes them to spend too much time on low-level pro-gramming constructs and template issues. STL is not enough to write applicationswith graphical interfaces, and another framework would have to be used anyway.
During the summer of 2003 we got together and decided to develop a book
that would approach OOP/C++ at a higher level. We wanted to provide a sub-stantial introduction to GUI programming using the multi-platform Qt frame-work, as well as touch upon some important design patterns that are used.
We designed this ﬁrst as a textbook to be used in a university class, but it is
designed in an extensible way and crammed with information that will make it use-ful for readers with a wide range of backgrounds: from those who already programin C or another procedural language and wish to learn OO and GUI programming,to those who have no C background but are familiar with Basic, Java, Python, oranother programming language and wish to learn C++. The ﬁrst part of the bookis aimed at familiarizing all audiences with basic C++ elements, OO concepts,UML, and the core Qt classes.
We believe that readers will understand ideas best when they apply them, and
we found this to be especially true with design patterns. Many of the Qt classes orcode examples are concrete implementations of some of the more popular designpatterns described in Design Patterns [Gamma95]. For each design pattern that we
discuss, we make available the source code for our example and include exercisesthat challenge readers to reuse, reﬁne, and extend that code.
xxvezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxv
xxviRATIONALE FOR THE BOOK
Reuse of libraries requires an understanding not only of libraries but also of
modular software, the linker, and library design. We have included a substantialamount of advice distilled from experience (ours and our students’) and fromonline discussion communities. We found that this helped our students to copewith most of the problems they encountered in courses based on early versions ofthis book.
We used preliminary versions of this book in Suffolk University’s OOP/C++
course each semester during the academic years 2003–2004 through 2005–2006,with increasingly promising results and with much valuable feedback from ourstudents. In the earlier version of this course, students typically would write thou-sands of lines of code for their programming projects. By contrast, with theemphasis now on code reuse and the exploitation of robust tool libraries, studentprogramming projects have fewer lines of student code, but are much more inter-esting and, we feel, much more valuable learning experiences.
There are many C++ books out there that either teach C++ or teach Qt, but
we found that the C++ books use a variety of different programming styles, andthey emphasize some topics that we do not use very often with Qt. The Qt bookswe have seen all assume prior C++ knowledge. This book, by contrast, assumes noC or C++ programming experience, and it covers the language features of C++that you need to know in order to use Qt 4 classes as early as possible in the exam-ples and assignments. It can be used as a textbook for teaching C++ and designpatterns, with an emphasis on open-source code reuse.
As far as we know, there are no university-level C++ textbooks that contain Qt
examples and also provide review questions, exercises, solutions, and lecture slidesfor instructors.ezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxvi
About the Authors
Paul Ezust started teaching mathematics at Suffolk University in 1967. Soon after
completing his Ph.D. in mathematics from Tufts University in 1975, he wasappointed chair of the Suffolk University Department of Mathematics, a positionthat he still holds. Over the next few years he led a successful departmental effortto develop courses and curricula in computer science based on guidelines pub-lished by the Association for Computing Machinery (ACM). In 1982 the depart-ment was renamed Mathematics and Computer Science. T oday the departmenthas very successful undergraduate and graduate programs in computer scienceand is continuing to grow and develop. Paul has taught computer science coursesfor nearly 30 years, focusing for the past ten years on object-oriented program-ming. Over the years he has also done extensive outside consulting, contract pro-gramming, and research in computational mathematics. This book, which wasoriginally going to be an extrapolation of a course that he had developed andreﬁned for about eight years, has evolved into one that represents a complete par-adigm shift for him and a totally different approach to teaching object-orientedprogramming, thanks to gentle but persistent pressure from his son Alan.
If you ignore shovelling snow, Alan Ezust ’s ﬁrst paying job was as a teaching
assistant when he was 13. The class was an introduction to Logo on the Apple II,and the students were primary and secondary school teachers, many of whomwere using a computer for the ﬁrst time. Computer language training has been oneof his passions ever since. Alan studied computer science at McGill University,receiving his M.Sc. in 1995. He gained more than ten years experience writingcourse material and teaching programming languages at McGill University,Suffolk University, Learnix Limited, Nortel, Objectivity, Corel, and Hewlett
xxviiezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxvii
Packard. While at Learnix, he had the unique experience of getting paid to teach
his father C++ in a classroom setting. Little did he know at the time, this would bethe start of a long-term professional collaboration. Alan now lives in Victoria,British Columbia. He is working toward a Ph.D. and contributing to the develop-ment of open-source software (jEdit, Umbrello, KDE) in his spare time.xxviiiABOUT THE AUTHORSezus_138004_fm.qxd  8/3/06  4:25 PM  Page xxviii
An Introduction to Design
Patterns in C++ with Qt 4ezus_138004_fm.qxd  8/3/06  4:25 PM  Page 1
PART I 
Introduction to
C++ and Qt 4ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 2
Chapter 1. C++ Introduction . . . . . . . . . . . . . . . . . 5
Chapter 2. Classes . . . . . . . . . . . . . . . . . . . . . . . . . 47Chapter 3. Introduction to Qt . . . . . . . . . . . . . . . 81Chapter 4. Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95Chapter 5. Functions . . . . . . . . . . . . . . . . . . . . . . 105Chapter 6. Inheritance and Polymorphism. . . 135
3ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 3
ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 4
1CHAPTER 1
C++ Introduction
In this chapter the language is introduced. Basic con-
cepts such as keywords, literals, identifiers, declara-tions, native types, and type conversions are defined.Some history and evolution are discussed, along withthe relationship between C++ and the C language.
51.1 Overview of C++ . . . . . . . . . . . . . . . . . . . . . . 61.2 A Brief History of C++ . . . . . . . . . . . . . . . . . 61.3 Setup: Open-Source Platforms. . . . . . . . . . 71.4 Setup: Win32 . . . . . . . . . . . . . . . . . . . . . . . . 121.5 C++ First Example . . . . . . . . . . . . . . . . . . . 121.6 Input and Output . . . . . . . . . . . . . . . . . . . . 161.7 Identifiers, Types, and Literals . . . . . . . . . 191.8 C++ Simple Types . . . . . . . . . . . . . . . . . . . . 221.9 C++ Standard Library Strings . . . . . . . . . 301.10 Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311.11 The Keyword const . . . . . . . . . . . . . . . . . . 341.12 Pointers and Memory Access . . . . . . . . . 361.13 const* and *const . . . . . . . . . . . . . . . . . . . . 401.14 Reference Variables . . . . . . . . . . . . . . . . . . 43ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 5
1.1 Overview of C++
C++ was originally an extension to C, also known as “C with Objects.” It enhances
C by adding several higher-level features such as strong typing, data abstraction, ref-erences, operator and function overloading , and considerable support for object-
oriented programming.
C++ retains the key features that have made C such a popular and successful
language: speed, efficiency, and a wide range of expressiveness that allows pro-gramming at many levels, from the lowest (such as direct operating system calls orbitwise operations) to the highest level (manipulating large complex objects orgraphs of objects).
A fundamental design decision was made at the beginning for C++: Any fea-
tures added to C++ should not cause a run-time penalty on C code that does notuse them.
1Certainly, there are added burdens on the compiler, and some features
have a run-time cost if they are used, but a C program that is compiled by a C++compiler should run just as fast as it would if compiled by a C compiler.
1.2 A Brief History of C++
C++ was designed by Bjarne Stroustrup while he was working for AT&T Bell Labs,
which eventually packaged and marketed it. Initial versions of the language weremade available internally at AT&T beginning in 1981. C++ steadily evolved inresponse to user feedback.
The first edition of Stroustrup’s book, The C++ Programming Language , was
published in early 1986. In 1989 with the release of Version 2.0, C++ was rapidlyacknowledged as a serious, useful language. In that year, work began on establish-ing an internationally recognized language standard for C++.
Standardization under the control of ANSI (American National Standards
Institute) Committee X3J16 began in 1989 and was completed and published inter-nally in 1997 by the X3 Secretariat under the title Draft Standard—The
C++ Language, X3J16/97-14882, Information Technology Council (NSITC),
1 Unfortunately, exception handling broke this rule and does cause a bit of overhead if enabled. This
is why many libraries still do not use exceptions.ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 6
Washington, DC. In June 1998, the draft standard was unanimously accepted by the
representatives of the 20 principal nations that participated in the nine-yearANSI/ISO (International Standards Organization) effort.
The third edition of Stroustrup’s book [Stroustrup97], was published in 1997.
It is widely regarded as the definitive C++ reference.
Y ou can view an HTML version of the ANSI/ISO Draft Standard at http://
oop.mcs.suffolk.edu/draftstandard
1.3 Setup: Open-Source Platforms
Open-source development tools ( ssh,bash ,gcc) are available natively on UNIX
and their related platforms. This includes Mac OS/X, which is a BSD-baseddistribution.
2
1.3.1 *nix
When we discuss something that’s specific to UNIX-derived platforms (Linux,
BSD, Solaris, etc.), we will use the shorthand * nixfor “most flavors of UNIX.”
Another important acronym is POSIX , which stands for Portable Operating
System Interface for UNI X.The development of this family of standards was spon-
sored by the IEEE (Institute of Electrical and Electronics Engineers), an organiza-tion for engineers, scientists, and students that is best known for developingstandards for the computer and electronics industry.
3
This section is for readers who are using a computer with some flavor of *nix
installed.
The examples in this book were tested with Qt 4.1. We recommend that you
use the same version or a later one. The first step in setting up your computer forthis book is to make sure that the full installation of Qt 4 is available to you. Thisincludes, in addition to the source and compiled library code, the Qt Assistantdocumentation system, program examples, and the Qt Designer program.
If your system has KDE 3.x (the K Desktop Environment) installed, then
there is already a run-time version of Qt 3.x installed. Qt 4 needs to be
installed separately. Our examples do not compile under Qt 3.1.3 SETUP: OPEN-SOURCE PLATFORMS
7
2BSD stands for Berkeley Software Distribution, a facility of the Computer Systems Research Group
(CSRG) of the University of California at Berkeley. CSRG has been an important center of develop-ment for UNIX and for various basic protocols (e.g., TCP/IP) since the 1980s.
3If we wanted to write a POSIX regular expression (see Section 13.2) for *nix, it might look like this:
(lin|mac-os|un|solar|ir|ultr|ai|hp)[iu]?[sx] .ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 7
T o see which (if any) version of Qt has already been installed on your system,
start with the following commands:
which qmake
qmake -v
The output of the first command tells you where the qmake executable is located.
If that output looks like this: bash:qmake:command notfound , it is possible
that
1. The “full” Qt (including development tools) is not installed
2. It is installed, but your PATH does not include /path/to/qt4 /bin
If you can run it, qmake -v provides version information. If it reports
Using Qt version 4.x.y 
then, check whether these other Qt tools are available:
which moc
which uicwhich assistantwhich designer
If these executables are all found, and from the same place as qmake , Qt 4 is
installed and ready to use.
If the tests outlined above indicate that you have an earlier version or no Qt
installed, or that you are missing some components of Qt 4, then you will need toinstall the latest release of Qt 4.
Installing Qt 4 from Packages
On some *nix systems it is possible to install Qt 4 from a package that con-
tains compiled code.
Using your *nix package manager (e.g., apt ,urpmi ,aptitude ,
kpackage ,synaptic ,rpmdrake , etc.), you can easily and quickly install
the packages that comprise Qt 4. Here is a list of packages available onDebian systems (the lists will differ on other distros).
[ROOT@lazarus]# apt-cache search qt4
libqt4-core - Qt 4 core non-GUI functionality run-time librarylibqt4-debug - Qt 4 debugging run-time librarieslibqt4-dev - Qt 4 development fileslibqt4-gui - Qt 4 core GUI functionality run-time libraryCHAPTER 1: C++ INTRODUCTION
8ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 8
libqt4-qt3support - Qt 3 compatibility library for Qt 4
libqt4-sql - Qt 4 SQL database moduleqt4-designer - Qt 4 Designerqt4-dev-tools - Qt 4 development toolsqt4-doc - Qt 4 API documentationlibqt4-designer - Qt 4 Designer libraries[ROOT@lazarus]#
As you can see, in Debian, Qt 4 has been split into many separate packages
to give package maintainers more flexibility when they deploy. When devel-oping, you need the full Qt 4 package with developers’ tools, full headers,docs, designer, assistant, and examples.1.3 SETUP: OPEN-SOURCE PLATFORMS
9
1.3.2 Downloading from Source
Y ou can download, unpack, and compile the latest open-source tarball from
Trolltech.4Two typical places to unpack the tarball are /usr/local/ (if you are
root) or $HOME/qt (if you are not).
A tarball is a file produced by the tarcommand (tape archive) that can
combine many files, as specified in the command line, into one file(which is generally given the extension 
.tar ) for ease of storage or
transfer. The combined file is generally compressed using a utility like
gzip or bzip2 , which appends the extension .gz or .bz to the tar file.
The command line for unpacking a tarball depends on how it was
created.You can usually determine this from its extension.
tar -vxf whatever.tar      // uses the "verbose" switch
tar -zxf whatever.tar.gz  // compressed with gziptar -zxf whatever.tgz      // also compressed with gziptar -jxf whatever.tar.bz2  // compressed with bzip2
A tar file can preserve directory structures and has many options and
switches. You can read the online documentation for these utilities bytyping:
info tar
info gzipinfo bzip
4http://www.troltech.com/download/opensource.htmlezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 9
The Qt source tarball contains the complete source code of the Qt library, plus
numerous examples, tutorials, and extensions with full reference documentation.The tarball contains simple installation instructions (in the 
README and
INSTALL files) and a configure --help message. Be sure to read the README
file before you attempt to install software from any open-source tarball.
Compiling from source can take 2 to 3 hours (depending on the speed of your
system), but it is worth the time. Example 1.1 shows the options we use to config-ure qt:4.
EXAMPLE 1.1 ../bin/qtconfigure
#!/bin/sh
# This is a script which I use to configure and# make qt4 - it includes extra options I use for working with mysql.# # Before you run this, be sure you have at least the# mysql client header files :
# apt-get install libmysqlclient-dev mysql-server mysql-clientINSTALLDIR=/usr/local/qt4
./configure -prefix $INSTALLDIR -fast -qt-gif \#          for mysql:
-I/usr/include/mysql -qt-sql-mysql
#          for odbc:
-plugin-sql-odbc -qt-sql-odbc
make
Y ou can run this as a regular user as long as you have write permissions in that
directory. Notice that this script runs make right after it is finished with
configure , so it will run for quite a while.
In the final step, make install copies the executables and headers into
another location from the unzipped tarball source tree. If you are installing in acommon location, you need to be root to do this.
After installation, try qmake -v to determine which version of qmake is
found by your shell. For systems that have more than one version
installed, this is especially important to do.CHAPTER 1: C++ INTRODUCTION
10ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 10
> which qmake
/usr/local/qt-x11-opensource-src-4.1/bin/qmake> qmake -v
QMake version: 2.00aUsing Qt version 4.1 in /usr/local/qt-x11-opensource-src-4.1/lib>
After installing, check your environment variables and make sure that
■QTDIR contains the path to the main directory of the Qt 4 installation.5
■PATH contains $QTDIR/bin (the path to the Qt executables).
■MANPATH contains $QTDIR/doc (the path to the Qt documentation).
■LD_LIBRARY_PATH contains $QTDIR/lib (the path to the Qt
libraries).
The bash command env will display the current values of all your
environment variables.
The shell script in Example 1.2 shows how we set the values with bash , but the
actual values depend on where the files are located on your system.
EXAMPLE 1.2 src/libs/utils/qt.sh
# Typical user specific environment and startup values for QT
# depending on how and where qt was installed on your systemexport QTDIR=/usr/local/qt4export PATH=$QTDIR/bin:$PATHexport MANPATH=$QTDIR/doc/man:$MANPATH
# Location of your own libraries - source and target.
export CPPLIBS=~/projects/libs
# LD Library path - where to search for shared object libraries
# at runtime.
export LD_LIBRARY_PATH=$CPPLIBS:$QTDIR/lib:$LD_LIBRARY_PATH1.3 SETUP: OPEN-SOURCE PLATFORMS
11
5Qt 4 does not require the use of this environment variable, but we use this variable to refer to the
“Qt install” directory in our examples.ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 11
1.4 Setup: Win32
There are two versions of Qt available on Win32 platforms.
1. The open-source edition, which supports MinGW6 (the Minimalist Gnu
for Windows ), can be downloaded and used for free with open-source
projects.
2. The Qt 4 Commercial Edition can be used with Microsoft compilers,
such as Microsoft Visual C++ 6, and later versions of Developer’s Studio.
Installing either edition is a snap: The Win32 installer guides you through the
process, registers extensions, and sets environment variables for you. The open-source edition can even download and install MinGW for you.
After Qt is installed, you should click
Start -> Programs -> Qt by Trolltech -> Build debug symbols
This may take a couple of hours.
Next, open a shell window by clicking
Start -> Programs -> Qt by Trolltech -> Command Prompt
Now you can run qmake -v from the command prompt to see the currently
installed version of Qt. qmake ,assistant ,designer ,qtdemo ,qtconfig ,
g++, and make should all be findable in your search path now.
Try the qtdemo that is also available from the Start menu.
MSYS (from MinGW) and Cygwin7both offer bash and xterm-like shell
windows to simulate a *nix system in Win32 environments.
For building the Qt debug symbols, we found that the configure
and make scripts did not work. However, for building our own apps, we
have been able to run qmake and make inside a bash shell from Cygwin.
1.5 C++ First Example
Throughout this book we will use code examples to explain and illustrate impor-
tant programming and OOP issues. Our aim in each case is to use a minimalexample that will illustrate the ideas and techniques briefly and efficiently.
Example 1.3 provides a quick overview of some elementary C++ syntax.CHAPTER 1: C++ INTRODUCTION
12
6http://www.mingw.org/
7http://www.cygwin.comezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 12
EXAMPLE 1.3 src/early-examples/fac.cpp
// Computes and prints n! for a given n. 
// Uses several basic elements of C++.
#include <iostream>
int main() {
using namespace std;/* Declarations of variables */int factArg = 0 ;int fact (1) ;do {
cout << "Factorial of: ";cin >> factArg;if( factArg < 0 ) {
cout << "No negative values, please!" << endl;
}
} while(factArg < 0) ;int i = 2;while( i <= factArg ) {
fact = fact * i;i = i + 1;
}
cout << "The Factorial of " << factArg << " is: " << fact << endl;
return 0;
131211109876543211.5 C++ FIRST EXAMPLE
13
start of function “main,” which returns int
Permits us to use the symbols cin, cout, and endl without prefixing each name with std::C style initialization syntaxC++ style initialization syntaxstart of “do..while” loopwrite to standard outputread from standard input and convert to intend of if blockif false, break out of do loopstart of while loopend of while blockWhen main returns 0, that normally means “no errors.”
end of main block
On most platforms it is simple to compile and run this program using the ubiqui-
tous GNU C compiler, gcc. The command to compile a C++ program is g++,b u t
this is simply an alias to gcc with some C++ options switched on.
When invoking the compiler, we recommend always maximizing the amount of
diagnostic information that is available from the compilation process. Accordingly,we include three switches on the command line: (1) -ansi (which turns off GNU141312111098765432}
Standard c++ library. In older versions of C++, you might find <iostream.h> instead, but that ver-
sion is regarded as obsolete or ”deprecated.”114ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 13
extensions that conflict with ISO C++), (2) -pedantic (which issues all the warnings
that are demanded by strict ISO C++ and rejects any program that uses forbiddenextensions), and (3) -Wall (which enables all possible warnings about constructionsthat might be considered questionable even if they conform to the standard).
src/early-examples> g++ -ansi -pedantic -Wall fac.cpp
or
src/early-examples> g++ -ansi -pedantic -Wall  -o execFile fac.cpp
In the second version shown above, -o execFile is an optional switch that tells
the compiler to name the executable result of the compilation “execFile.” If weomit that switch, as in the first version, the compiler will produce an executable filenamed 
a.out . In either case, if there already exists a file in the same directory
with the name of our target executable, then the compiler will quietly and auto-matically overwrite it.
We have mentioned here just a few of the most commonly used compiler
switches. On a *nix system you can view the manual pages , a summary of the 
g++
command options and how they are used, by typing the command
man g++
The command
info g++
often displays more readable documentation. One advantage is that the info
command allows you to do an incremental search for a word in the documenta-
tion by typing ctrl-s. On most systems these commands allow you to browse theonline documentation for 
g++ one screen at a time. For more complete gcc doc-
umentation, visit the GNU online document center.8
After it has been compiled successfully, our program can be run by typing the
name of the executable file. Here is an example done on a *nix platform:
src/early-examples> ./a.out
Factorial of: -3
No negative values, please!Factorial of: 5
The Factorial of 5 is: 120src/early-examples>CHAPTER 1: C++ INTRODUCTION
14
8http://www.gnu.org/software/gcc/onlinedocs/ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 14
This short program has several of the language elements that show up in most
C++ programs. Some interesting differences between C++ and other languages(especially C) can be seen in this example.
Comments
C++ has single-line comments as in Java. Any text between the //and the end of
the line is a comment. C-style comment delimiters for multiline comments canalso be used: The text between  
/*and */is a comment.
#include
T o reuse functions, types, or identifiers from libraries, we use the preprocessordirective
#include (see Section C.1). As in C, all preprocessor directives begin
with the pound sign character, #, and are evaluated just before the compiler com-
piles your code. In this example, the included header <iostream> contains the
Standard Library definitions for input/output.
The Using Namespace Directive
Symbols from the Standard Library (see Appendix B) are all enclosed in the
namespace std.
Anamespace (see Section 20.4) is a collectio n of classes, functions, and objects
that can be addressed with a name prefix. The using declaration tells the compiler to
add all symbols from the namespace std to our global namespace.
Declaring and Initializing Variables
Variable declarations come in three styles in C++:
type-expr  variableName ;
type-expr  variableName = init-expr ;
type-expr  variableName (init-expr );
In the first form, the variable might not be initialized. The third form is an alter-
nate syntax for the second.
Selection
C++ provides the usual assortment of syntax variations for selection, which wediscuss in Section 21.2.1.5 C++ FIRST EXAMPLE
15ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 15
Iteration
We used two of the three iteration structures provided by C++ in our example. All
three are discussed in Section 21.3.
1.6 Input and Output
In Example 1.3, the directive
#include <iostream>
allowed us to make use of the predefined global input and output stream objects.
They are
1.cin—standard input , the keyboard by default
2.cout —standard output , the console screen by default
3.cerr —standard error , another output stream to the console screen that
flushes more often and is normally used for error messages
T o send output to the screen in Example 1.3, we made use of the global stream
object (of the class ostream ), called cout . We called one of its member func-
tions, whose name is operator<<() . This function overloads the insertion oper-
ator <<and defines it like a global function.9The syntax for that output statement
is also quite interesting. Instead of using the rather bulky function notation:
cout.operator<<("Factorial of :");
we invoked the same function using the more elegant and readable infix syntax:
cout << "Factorial of:  " ;
This operator is predefined for use with many built-in types, as we see in the next
output statement.
cout << "The cost is $" << 23.45 << " for " << 6 << 
"items." << '\n';
In Example 1.4, we can see the operator>>() used for input with istream in
an analogous way to <<for ostream .CHAPTER 1: C++ INTRODUCTION
16
9We will discuss overloaded functions and oper ators in more detail later in Section 5.2.ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 16
EXAMPLE 1.4 src/iostream/io.cpp
#include <string>
#include <iostream>
int main() {
using namespace std;const int THISYEAR = 2006;string yourName;int birthYear;
cout << " What is your name? "  << flush;
cin >> yourName;
cout << "What year were you born? " ;
cin >> birthYear;
cout << "Your name is " << yourName
<< " and you are approximately "<< (THISYEAR - birthYear)<< " years old. " << endl;
}
The symbols flush and endl are manipulators that were added to the std
namespace for convenience.10Manipulators are implicit calls to functions that can
change the state of a stream object in various ways.
Notice also that we are using the string type from the Standard Library.
We will discuss this type and demonstrate some of its functions shortly (seeSection 1.9).
EXERCISES: INPUT AND OUTPUT
1.Using Example 1.4, do the following experiments:
■First, compile and run it to see its normal behavior.
■What happens if you enter a non-numeric value for the birth year?
■What happens if you enter a name such as Curious George as your name?
■What happens if you remove the following line?
using namespace std;1.6 INPUT AND OUTPUT
17
10We discuss these further in Section 1.10.ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 17
■Replace the statement
cin >> yourName;
with the statement
getline(cin, yourName);
and try Curious George again.
■Can you explain the differences in behavior between cin >> and
getline() ? We discuss this later in Section 1.9.
■Add some more questions to the program that require a variety of numeri-
cal and string answers, and test the results.
2.Consider the program shown in Example 1.5.
EXAMPLE 1.5 src/early-examples/fac2.cpp
#include <iostream>
long factorial(long n) {
long ans = 1;for (long i = 2; i <= n; ++i) {
ans = ans * i;if (ans < 0) {
return -1;
}
}return ans;
}
int main() {
using namespace std;cout << "Please enter n: " << flush;long n;  cin >> n;
if (n >= 0) {
long nfact = factorial(n);if (nfact < 0) {
cerr << "overflow error: "
<< n << " is too big." << endl;
}21CHAPTER 1: C++ INTRODUCTION
18ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 18
else {
cout << "factorial(" << n << ") = "
<< nfact << endl;
}
}else {
cerr << "Undefined:  "
<< "factorial of a negative number: " << n << endl;
}return 0;
}
long int
read from stdin, try to convert to long
■Test the program in Example 1.5 with a variety of input values, including
some non-numeric values.
■Determine the largest input value that will produce a valid output.
■Can you change the program so that it will produce valid results for largerinput values?
■Modify the program so that it cannot produce invalid results.
■Explore the effects of using the statement
if(cin >> n)   {  ...  }
to enclose the processing of nin this program. In particular, try entering
non-numeric data after the prompt. This is an example of the use of a con-version operator, which we discuss in more detail in Section 2.13.
■Modify the program so that it will accept values from the user until the value9999 is entered.
1.7 Identifiers, Types, and Literals
Identifiers are names that are used in C++ programs for functions, parameters,
variables, constants, classes, and types. An identifier consists of a sequence of let-ters, digits, and underscores that does not begin with a digit. An identifier cannotbe a reserved keyword. See Appendix A for a list of them. The standard does notspecify a limit to the length of an identifier, but certain implementations of C++only examine the first 31 characters to distinguish between identifiers.211.7 IDENTIFIERS, TYPES, AND LITERALS
19ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 19
A literal is a constant value that appears somewhere in a program. Since every
value has a type, every literal has a type also. It is possible to have literals of eachof the native data types, as well as character string literals. Table 1.1 shows someexamples of literals.
TABLE 1.1 Examples of Literals
Literal Meaning
5 an int literal
5u u or Uspecifies unsigned int
5L l or L specifies long int after an integer
05 an octal int literal
0x5 a hexadecimal int literal
true a bool literal
5.0F f or F specifies single precision float ing point literal
5.0 a double precision float ing point literal
5.0L l or L specifies long double if it comes after a
floating point
'5' a char literal (ASCII 53)
"50" a const char* containing the chars '5' ,'0' ,
and '\0'
"any""body" "anybody"
'\a' alert
'\\' backslash
'\b' backspace
'\r' carriage return
'\" single quote
'\"' double quote
'\f' formfeed  (newpage)
'\t' tab
'\n' newline char literal
"\n" newline followed by null terminator ( const char* )
'\0' null character
'\v' vertical tab
"a string with another const char*
newline\n"CHAPTER 1: C++ INTRODUCTION
20ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 20
String literals are special in C++, due to its historical roots in the C language.
Example 1.6 shows how certain characters need to be escaped inside double-quoted string delimiters.
EXAMPLE 1.6 src/early-examples/literals.cpp
#include <iostream>
#include <string>
int main() {
using namespace std;const char* charstr = "this is one very long string "
"so I will continue it on the next line";
string str = charstr;cout << str << endl;cout << "\nA\tb\\c\'d\"" << endl;return 0;
}
STL strings can hold onto C-style char* strings.
We compile and run the way we described earlier:
src/early-examples>  g++ -ansi -pedantic -Wall literals.cpp
src/early-examples>  ./a.out
The output should look something like this:111.7 IDENTIFIERS, TYPES, AND LITERALS
21
this is one very long string so I will continue it on the next line
A       b\c'd"
Notice that this program shows a way to avoid very long lines when dealing with
string literals. They can be broken at any white space character and are concate-nated automatically using this syntax.
EXERCISES: IDENTIFIERS, TYPES,
AND LITERALS
Modify Example 1.6 so that, with a single output statement, the output becomes:
1.GNU stands for "GNU's Not Unix".
2.Title 1         "Cat Clothing "
Title 2         "Dog Dancing "ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 21
1.8 C++ Simple Types
The simple types supported in C/C++ are
■A Boolean type ( bool )
■Character types ( char and wchar_t )
■Integer types ( short,int,long )
■Floating point numbers ( double,float,longdouble , etc.)
■Pointers (int*,char*,bool*,double*,void* , etc.)
In addition, C and C++ both provide a name that signifies the absence of type
information ( void ).
C++ simple types can (variously) be modified by the following keywords to
produce other simple types:
■short
■long
■signed
■unsigned11
TABLE 1.2 Simple Types Hierarchy
Byte/char types Integral types Floating point types
bool short int float
char int doublesigned char long int long doubleunsigned char unsigned shortwchar_t unsigned int
unsigned long
C++ compilers allow you to omit“int”from shortint ,longint , andunsigned
int. Y ou can omit signed from most types, since that is the default.
Since the range of values for a particular type depends on the underlying archi-
tecture of the machine on which the compiler is running, the ANSI/ISO standardfor C++ does not specify the size (in bytes) of any of these types. It only guaranteesCHAPTER 1: C++ INTRODUCTION
22
11For a brief discussion of the differences between signed and unsigned integral types, see Section 19.4.ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 22
that a given type (e.g., int) must not be smaller than one that appears above it
(e.g.,short ) in Table 1.2.
There is a special operator sizeof() that returns the number of chars12that
a given expression requires for storage. Unlike most functions, the sizeof()
operator can take value expressions or type expressions.
Example 1.7 shows how sizeof() can be used, and some of the values it
returns on a 32-bit x86 system.
EXAMPLE 1.7 src/early-examples/size.cpp
#include <assert.h>
#include <iostream>#include <string>
int main(int argc, char* argv[]) {
using namespace std;int i=0;
char array1[34] = "This is a dreaded C array of char";
char array2[] = "if not for main, we could avoid it entirely.";
char *charp = array1;
string stlstring = "This is an Standard Library string. Muchpreferred." ;
assert (sizeof(i) == sizeof(int));cout << "sizeof char = " << sizeof(char) << '\n';cout << "sizeof wchar_t = " << sizeof(wchar_t) << '\n';cout << "sizeof int = " << sizeof(int) << '\n';cout << "sizeof long = " << sizeof(long) << '\n';cout << "sizeof float = " << sizeof(float) << '\n';cout << "sizeof double = " << sizeof(double) << '\n';cout << "sizeof double* = " << sizeof(double*) << '\n';cout << "sizeof array1 = " << sizeof(array1) << '\n';cout << "sizeof array2 = " << sizeof(array2) << '\n';
cout << "sizeof stlstring = " << sizeof(stlstring) << endl;
cout << "length of stlstring= " << stlstring.length() << endl;
cout << "sizeof char* = " << sizeof(charp) << endl;return 0;
}
Output:
sizeof char = 1
sizeof wchar_t = 4sizeof int = 4sizeof long = 411.8 C++ SIMPLE TYPES
23
12On most systems, a single char is a byte.continuedezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 23
sizeof float = 4
sizeof double = 8sizeof double* = 4sizeof array1 = 34sizeof array2 = 46sizeof stlstring = 4length of stlstring = 38sizeof char* = 4
pointer to first element of array
Notice that all pointers are the same size, regardless of their type.
sizeof(stlstring) indicates it is only 4 bytes, but it is a complex class that
uses dynamic memory, so we use length() to get the number of characters in
the string .
The ranges of values for the integral types ( bool, char, int ) are defined
in the standard header file limits.h . On a typical *nix installation that file can
be found in a subdirectory of /usr/include .
1.8.1 main and Command Line Arguments
main() is a function (see Chapter 5), that is called at program startup. If the
program accepts command line arguments, we must define main with its full
parameter list.
C permits flexibility in the ways that arguments are defined in main() , so you
may see it defined in a variety of ways:
int main(int argc, char* argv[])
int main(int argc, char ** argv)int main(int argCount, char * const argValue[])
All of the above forms are valid, and each defines two parameters. These parame-
ters contain enough information to reconstruct the command line argumentspassed into the program from the parent process (a command line shell, a windowmanager, etc.).
Example 1.8 is a simple 
main program that prints its command line arguments.
EXAMPLE 1.8 src/main/main1.cpp
#include <iostream>
using namespace std;1CHAPTER 1: C++ INTRODUCTION
24ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 24
int main (int argCount, char* argValue[]) {
for (int i=0; i<argCount; ++i) {
cout << "argv# " << i << " is " << argValue[i] << endl;
}return 0;
}
argValue ,o r  argv for short, is a two-dimensional array (see Section 22.4) of
char. argCount ,o r  argc for short, is the number of char arrays in argv.
argv contains each command line string as an item in its array.
int main() “returns” an integer, which should be 0 if all went well, or a non-
zero error code if something went wrong.
Try not to confuse this interpretation of 0with the bool value false ,
which is equal to zero.
If we run this program and pass some arguments, we will see something like thisin the output:
~/src/main> ./a.out foo bar "space wars" 123
argv# 0 is ./a.outargv# 1 is fooargv# 2 is barargv# 3 is space warsargv# 4 is 123
The first argument is always the name of the executable. The other arguments are
taken from the command line as strings separated by spaces or tabs. T o pass astring that contains spaces as a single argument, you must enclose the string inquotes.
1.8.2 Arithmetic
Each programming language must provide facilities for doing basic arithmetic. For
each of its native numerical types,C++ provides these four basic arithmetic operators:
■Addition ( +)
■Subtraction ( -)1.8 C++ SIMPLE TYPES
25ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 25
■Multiplication ( *)
■Division (/)
These operator symbols are used to form expressions in the standard infix syntax
that we learned in math class.
C++ provides shortcut operators that combine each of the basic operators
with the assignment operator ( =) so that, for example, it is possible to write
x += y;
instead of
x = x + y;
C++ also provides unary increment (++) and decrement (--) operators that can beused with integral types. If one of these operators is applied to a variable on the left(prefix), then the operation is performed before the rest of the expression is evalu-
ated. If it is applied to a variable on the right (postfix), then the operation is per-formed after the rest of the expression is evaluated. Examples 1.9 through 1.13demonstrate the use of the C++ arithmetic operators.
EXAMPLE 1.9 src/arithmetic/arithmetic.cpp
[ . . . . ]
#include <iostream>
int main() {
using namespace std;double x(1.23), y(4.56), z(7.89) ;int i(2), j(5), k(7);x += y ;z *= x ;cout << "x = " << x << "\tz = " << z
<< "\nx - z = " << x - z << endl ;
Integer division is handled as a special case. The result of dividing one int by
another produces an int quotient and an int remainder. The operator /is used to
obtain the quotient. The operator %(called the modulus operator ) is used to obtain
the remainder.
Example 1.10 shows the use of these integer arithmetic operators.CHAPTER 1: C++ INTRODUCTION
26ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 26
EXAMPLE 1.10 src/arithmetic/arithmetic.cpp
[ . . . . ]1.8 C++ SIMPLE TYPES
27
cout << "k / i = " << k / i
<< "\tk % j = " << k % j << endl ;
cout << "i = " << i << "\tj = " << j << "\tk = " << k << endl;cout << "++k / i = " << ++k / i << endl;cout << "i = " << i << "\tj = " << j << "\tk = " << k << endl;cout << "i * j-- = " << i * j-- << endl;
cout << "i = " << i << "\tj = " << j << "\tk = " << k << endl;
Mixed expressions, if valid, generally produce results that are of the widest of the
argument types. We discuss this in more detail in Chapter 19.
Example 1.11 shows that the result of a double d i v i d e db ya n int is adouble.
EXAMPLE 1.11 src/arithmetic/arithmetic.cpp
[ . . . . ]
cout << "z / j = " << z / j << endl ;
C++ also provides a full set of boolean operators to compare numeric expressions.Each of these operators returns a 
bool value of either false or true.
■Less than  ( <)
■Less than or equal to  ( <=)
■Equal to (==)
■Not equal to  ( !=)
■Greater than ( >)
■Greater than or equal to ( >=)
A bool expression can be negated with the unary not (!) operator. Two bool
expressions can be combined with the operators
■and (&&)
■or  (||)ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 27
We discuss bool expressions in more detail in Section 19.2.
EXAMPLE 1.12 src/arithmetic/arithmetic.cpp
[ . . . . ]
/*   if() ... else   approach */
if(x * j <= z)
cout << x * j << " <= " << z << endl ;
else
cout << x * j << " > " << z << endl;
/* conditional operator approach */cout << x * k
<<( (x * k < y * j) ? " < " : " >= ")<< y * j << endl;
}
In addition to the binary boolean operators, Example 1.12 makes use of the
conditional-expression.
The expression
(boolExpr ) ? expr1: expr2
returns expr1 ifboolExpr is true , otherwise it returns expr2.Example 1.13
shows the output that this program produces.
EXAMPLE 1.13 src/arithmetic/arithmetic.cpp
[ . . . . ]
Output:
x = 5.79        z = 45.6831
x - z = -39.8931k / i = 3       k % j = 2i = 2   j = 5   k = 7++k / i = 4i = 2   j = 5   k = 8i * j-- = 10i = 2   j = 4   k = 8z / j = 11.420823.16 <= 45.6831
46.32 >= 18.24CHAPTER 1: C++ INTRODUCTION
28ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 28
1.8 C++ SIMPLE TYPES
29
EXERCISES: C++ SIMPLE TYPES
1.Here is an old favorite: Write a short program that asks the user to choose
Celsius-to-Fahrenheit or Fahrenheit-to-Celsius. Then ask for a lower bound, anupper bound, and an increment. Using that information, produce an appropiatetable with column headings. The 
main() part of your program should be
relatively short. Most of the work should be performed by functions thatyou design, e.g.,
celsiusToFahrenheit(), fahrenheitToCelsius(),
makeTable() , and so forth (with appropriate parameter lists).
2.If you #include <cstdlib> , you can make use of the random() function
that generates a sequence of pseudo-random longints in the range from 0
to RAND_MAX , which can be used in many interesting ways. It works by com-
puting the next number in its sequence from the last number that it generated.The function 
srandom(unsigned int seed) sets its argument as the ini-
tializing value (seed) for the random sequence. Write a short program that teststhis function by allowing the user to supply the seed from the keyboard andthen generating a list of pseudo-random numbers.
3.One trick is to use 
srandom(time(0)) to seed the random() function. Since
time(0) returns the number of seconds since some initial starting point, the
seed will be different each time you run the program. This allows you to writeprograms that have usefully unpredictable behavior patterns. Write a programthat simulates a dice game that the user can play with the computer. Here arethe rules to apply to your game:
■The game is about repeated “throws” of a pair of dice.
■Each die has six faces, which are numbered 1 through 6.
■A throw results in a number that is the total of the two top faces.
■The first throw establishes the player’s number.
■If that number is 7 or 11, the player automatically wins.
■If that number is 2, the player automatically loses.
■Otherwise, the player continues throwing until she wins (by matching hernumber) or loses (by throwing a 7 or an 11).
4.Write a program that accepts two values from the user (customer): the total
purchase amount and the amount submitted for payment.
Each of these values can be stored in a variable of type 
double . Then com-
pute and display the change that will be given to the user. Express the changein terms of the number of $10 bills, $5 bills, $1 bills, quarters, dimes, nickels, andpennies. (Presumably, this output could be sent to a machine that dispensesthose items automatically.)ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 29
For example, if the total purchase amount is $73.82 and the customer pays
with a $100 bill, then the change should be: two $10 bills, one $5 bill, one $1 bill,no quarters, one dime, one nickel, and three pennies.
Convert the amount that is owed the customer to pennies, which can be
stored as an int and then use the integer division operators.
1.9 C++ Standard Library Strings
Our early (pre-Qt) examples will make use of C++ Standard Library strings (see
Appendix B). Standard Library strings have many disadvantages when comparedto QStrings, but they are easy to use and have a similar public interface thatincludes many functions to construct and modify strings.
Example 1.14 demonstrates its basic usage.
EXAMPLE 1.14 src/generic/stlstringdemo.cpp
#include <string>
#include <iostream>
int main() {
using namespace std;string s1("This "), s2("is a "), s3("string.");s1 += s2;string s4 = s1 + s3;cout << s4 << endl;
string s5("The length of that string is: ");
cout << s5 << s4.length << " characters." << endl;
cout << "Enter a sentence: " << endl;
getline(cin, s2);cout << "Here is your sentence: \n" << s2 << endl;cout << "The length of it was: " << s2.length() << endl;return 0;
}
concatenation11CHAPTER 1: C++ INTRODUCTION
30ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 30
Here is the compile and run:
src/generic> g++ -ansi -pedantic -Wall stlstringdemo.cpp
src/generic> ./a.out
This is a string.The length of that string is 17Enter a sentence:20 years hard labourHere is your sentence:20 years hard labourThe length of it was: 20src/generic>
Observe that we used the getline(istream, string) function to take a
string from standard input stream. We will learn more about input from
streams in the following section.
1.10 Streams
Streams are objects used for reading and writing. The Standard Library defines
<iostream>, while Qt defines < QTextStream> for the equivalent functionality.
iostream defines the three global streams:
■cin—standard input (keyboard)
■cout —standard output (console screen)
■cerr —standard error (console screen)
Also defined (in both <iostream> and <QTextStream> ) are manipulators,
such as flush and endl . A manipulator can be added to
■An output stream to change the way the output data is formatted
■An input stream to change the way that the input data is interpreted
The code in Example 1.15 demonstrates the use of several manipulators applied to
the standard output stream.
EXAMPLE 1.15 src/stdstreams/streamdemo.cpp
#include <iostream> 
int main() {
using namespace std;int num1(1234), num2(2345) ;1.10 STREAMS
31
continuedezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 31
cout << oct << num2 << '\t'
<< hex << num2 << '\t'
<< dec << num2<< endl;
cout << (num1 < num2) << endl;cout << boolalpha
<< (num1 < num2)<< endl;
double dub(1357);cout << dub << '\t'
<< showpos << dub << '\t'<< showpoint << dub<< endl;
dub = 1234.5678;cout << dub << '\t'
<< fixed << dub << '\t'<< scientific << dub << '\n'<< noshowpos << dub<< endl;
}
Output:4451    929     2345
1true1357    +1357   +1357.00+1234.57        +1234.567800    +1.234568e+03
1.234568e+03
Streams are used for reading from or writing to files, network connections, and
also strings. One useful feature of streams is that they make it easy to producestrings from mixed types of data. In Example 1.16, we will create some stringsfrom numerics and write them to a file.
EXAMPLE 1.16 src/stl/streams/streams.cpp
[ . . . . ]
int main() {
using namespace std;ostringstream strbuf;
int lucky = 7;
float pi=3.14;double e=2.71;CHAPTER 1: C++ INTRODUCTION
32ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 32
/* An in-memory stream */
strbuf << "luckynumber " << lucky << endl
<< "pi " << pi << endl<< "e " << e << endl;
string strval = strbuf.str();
cout << strval;
/* An output file stream. */
ofstream outf;outf.open("mydata");outf << strval ;outf.close();
convert the stringstream to a string
creates (or overwrites) a disk file for output
After the strings have been written, we have a couple of choices for how to read
them. We can use the analogous input operators that we wrote to output, andbecause there is whitespace between each record, the insertion operator will workas shown in Example 1.17.
EXAMPLE 1.17 src/stl/streams/streams.cpp
[ . . . . ]
/* An input file stream */
ifstream inf;inf.open("mydata");string newstr;int lucky2;inf >> newstr >> lucky2;if (lucky != lucky2)
cerr << "ERROR! wrong lucky number" << endl;
float pi2;
inf >> newstr >> pi2;if (pi2 != pi) cerr << "ERROR! Wrong pi." << endl;
double e2;
inf >> newstr >> e2;if (e2 != e) cerr << "e2: " << e2 << " e: " << e << endl;
inf.close();  21211.10 STREAMS
33ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 33
In addition, we can read files line-by-line and deal with each line as a string, as
shown in Example 1.18.
EXAMPLE 1.18 src/stl/streams/streams.cpp
[ . . . . ]
/* Read line-by-line */
inf.open("mydata");while(not inf.eof()) {
getline(inf, newstr);cout << newstr << endl;
}inf.close();return 0;
}
EXERCISE: STREAMS
Modify the program in Example 1.16 so that it does the following:
■It gets the file name from the user as an STL string fileName . You will need to
use the function fileName.c_str() to convert the string to a form that is
acceptable to the open( ) function.
■It makes sure that the file specified by the user does not already exist (or that itis all right to overwrite it if it does exist) before opening it for output.
■It makes sure that the file exists before attempting to read from it. (Hint: Afterthe call to 
open , you can test the ifstream variable as if it were a bool .
false means that the file does not exist.)
1.11 The Keyword const
Declaring an entity to be const tells the compiler to make it “read-only.” const
can be applied usefully in a large number of programming situations, as we will
soon see.
Because it cannot be assigned to, a const object must be properly initialized.
For example:
const int x = 33;
const int v[] = {3, 6, x, 2 * x};CHAPTER 1: C++ INTRODUCTION
34ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 34
Working with the declarations above:
++x ;           // error
v[2] = 44;  // error
Compilers can take advantage of an object being read-only in various ways. For
integers and some simple types, no storage needs to be allocated for a const
unless its address is taken. Therefore, most optimizing compilers try to store themin static memory.
It is good programming style to use 
const entities instead of embedding con-
stant expressions (sometimes called “magic n umbers”) in your code. This will gain
you flexibility later when you need to change the values and, in general, it willimprove the maintainability of your programs. For example, instead of somethinglike this:
for(i = 0; i < 327; ++i) {
...
}
use something like this:
// const declaration section of your codeconst int SIZE = 327;...for(i = 0; i < SIZE; ++i) {
...
}
In some C/C++ programs, you might see constants defined with pre-
processor macros like this:
#define STRSIZE 80
[...]char str[STRSIZE];
Preprocessor macros get replaced before the compiler sees them. Using
macros instead of constants means that the compiler cannot performthe same level of type checking as it can with proper constant expres-sions. Generally 
const expressions are preferred to macros for defining
constant values in C++ programs.1.11 THE KEYWORD CONST
35ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 35
1.12 Pointers and Memory Access
C and C++ distinguish themselves from many other languages by permitting
direct access to memory through the use of pointers. This section explains thebasic pointer operations and modifiers, and introduces dynamic memory usage.Pointers can seem complicated at first. We discuss pointer use and misuse in moredetail in Chapter 22.
1.12.1 The Unary Operators & and *
A variable is an object with a name recognized by the compiler. A variable’s name
can be used as if it is the object itself. For example, if we say:
int  x  =  5;
we can use xto stand for the integer object whose value is 5, and  we can manip-
ulate the integer object directly through the name x. For example:
++x ;    // symbol x now refers to an integer with value 6
An object (in the most general sense) is a chunk of memory that can hold data.
Each object has a memory address (where the data begins). The unary &operator,
also known as the address-of operator, when applied to any object, returns the
memory address of that object. For example, &xreturns the memory address of x.
An object that holds the memory address of another object is called a pointer .
We say that the pointer points to the object at the stored memory address.
int*  y  =  &x ;
In this example, ypoints to the integer x. The asterisk *following the int indi-
cates that yis a pointer to int. Here we have initialized the int pointer yto the
address of the int variable x. One of the powerful features of pointers is that, sub-
ject to rules that we will explore shortly, it is possible for a pointer of one type tohold the address of an object of a different (but related) type.
Zero (
0), often represented by the macro NULL in C programs, is a special
value that can be legally assigned to a pointer, usually when it is being initialized(or re-initialized).
0is not the address of any object. A pointer that stores the value
0is called a null pointer . Stroustrup recommends the use of 0rather than the
macro NULL in C++ programs.
A pointer to a simple type uses exactly the same amount of memory as a
pointer to a large complicated object. That size is usually the same as
sizeof(int) on that machine.CHAPTER 1: C++ INTRODUCTION
36ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 36
The unary *operator , also known as the dereference operator , when applied
to a non-null pointer returns the object at the address stored by the pointer.
The symbol *is used in two different ways in connection with pointers:
■It can serve as a type modifier in a pointer variable definition.
■It can be used as the dereference operator.
Dereferencing a null or uninitialized pointer causes a run-time error, usu-
ally a segmentation fault or, in Windows, a General Protection Fault (GPF).
It is the responsibility of the programmer to make sure that no attempt
is made to dereference a null or uninitialized pointer. We will discuss
techniques to ensure that such errors are avoided.
EXAMPLE 1.19 src/pointers/pointerdemo.cpp
// Filename pointerdemo.cpp
#include <iostream>
using namespace std;
int main() {
int x = 4;int* px = 0 ;px = &x;cout << "x = " << x
<< " *px = " << *px<< " px = " << px<< " &px = " << &px << endl;
x = x + 1;cout << "x = " << x
<< " *px = " << *px<< " px = " << px << endl;
*px = *px + 1;cout << "x = " << x
<< " *px = " << *px<< " px = " << px << endl;
return 0;
}211.12 POINTERS AND MEMORY ACCESS
37
continuedezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 37
Output:
OOP> ./a.out
x = 4 *px = 4 px = 0xbffff514 &px = 0xbffff510x = 5 *px = 5 px = 0xbffff514x = 6 *px = 6 px = 0xbffff514OOP>
type modifier
unary dereference operator
The particular values of the addresses will, of course, be different when the code
in Example 1.19 is executed on different machines.
The variable xaccesses its data directly , but the variable pxaccesses the same
data indirectly. This is why the word indirection is often used to characterize the
process of accessing data through a pointer. The relationship between the two vari-ables,
xand px, is illustrated in Figure 1.1.21CHAPTER 1: C++ INTRODUCTION
38
Name: px
Value: 0xbfff514
Name: x
Value: 4Location: 0xbffff510
Location: 0xbfff514
FIGURE 1.1 Pointer demo
1.12.2 Operators new and delete
C++ has a mechanism that permits storage to be allocated dynamically at run-
time. This means that the programmer does not need to anticipate the memoryneeds of a program in advance and make allowances for the maximum amountof memory that might be needed by the program. Dynamic allocation of storageat runtime is a powerful tool that helps to build programs that are efficientand flexible.
The 
new operator allocates storage from the memory heap (also called the
heap, free pool, or free storage) and returns a pointer to the newly allocatedobject. If for some reason it is not possible for the memory to be allocated, anexception is thrown (see Section 22.9).ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 38
In general, the code that calls new should document, or be physically
located near, the code that frees the memory. The goal is to keep mem-
ory management code as simple and reliable as possible.
The delete operator releases dynamically allocated memory and returns it to the
memory heap. delete should be applied only to pointers returned by the new ,or
to null pointers. Heap memory that is no longer needed should be released forreuse. Failure to do so can result in crippling memory leaks.
Qt, the Standard Library, and boost.org provide a variety of classes and
functions to help manage and clean up heap memory. In addition tocontainer classes, each library has one or more smart pointer class. A
smart pointer is an object that stores and manages a pointer to a heap
object. It behaves much like an ordinary pointer except that it automati-cally deletes the heap object at the appropriate time. Qt has 
QPointer ,
the Standard Library has std::auto_ptr , and Boost has a
shared_ptr . Using one of these classes makes C++ memory man-
agement much easier than it used to be.
The syntax of the new and delete operators is demonstrated in the code frag-
ment shown in Example 1.20.
EXAMPLE 1.20 src/pointers/newdelete/ndysntax.cpp
{ 
int* ip = 0;ip = new int;int* jp = new int(13);[...]delete ip;           delete jp;
}
null pointer
allocate space for an intallocate and initialize
Without this, we have a memory leak.432143211.12 POINTERS AND MEMORY ACCESS
39ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 39
EXERCISES: POINTERS AND MEMORY ACCESS
1.Predict the output of the program shown in Example 1.21.
EXAMPLE 1.21 src/pointers/newdelete1.cpp
#include <iostream> 
using namespace std;
int main() {
const char tab = '\t';int n = 13;int* ip = new int(n + 3);double d = 3.14;double* dp = new double(d + 2.3);char c = 'K';char* cp = new char(c + 5);cout << *ip << tab << *dp << tab << *cp << endl;int* ip2 = ip;cout << ip << tab << ip2 << endl;*ip2 += 6;cout << *ip << endl;delete ip;cout << *ip2 << endl;cout << ip << tab << ip2 << endl;
}
Then compile and run the code. Explain the output, especially the last two lines.
2.Modify Example 1.19 to do some arithmetic with the value pointed to by jp.
Assign the result to the location in memory pointed to by ip, and print the
result. Print out the values from different places in the program. Investigate howyour compiler and run-time system react to placement of the outputstatements.
1.13 const* and *const
Suppose that we have a pointer ptr that is storing the address of a variable vbl:
Type* ptr = &vbl;
When using a pointer, two objects are involved: the pointer itself and the object
pointed to. This means there are two possible layers of protection that we mightwant to impose with 
const :CHAPTER 1: C++ INTRODUCTION
40ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 40
1. If we want to make sure that ptr cannot point to any other memory
location, we can write it one of two ways:
Type* const ptr = &vbl;
Type* const ptr(&vbl);
The pointer is a const but the addressed object can be changed.
2. If we want to make sure that the value of vbl cannot be changed by
dereferencing  ptr, we can write it in two ways:
const Type* ptr = &vbl;
const Type* ptr(&vbl);
In this case, the addressed object is a constant but the pointer is not.
In addition, if we want to impose both kinds of protection we can write:
const Type* const ptr = &vbl;
const Type* const ptr(&vbl);
Here is a good way to remember which is which: Read each of the
following definitions from right to left (starting with the defined variable).1.13 CONST* AND *CONST
41
A short program that demonstrates the two kinds of protection is shown
in Example 1.22.
EXAMPLE 1.22 src/constptr/constptr.cpp
#include <iostream> 
using namespace std;
int main() {
int m1(11), m2(13);const int* n1(&m1);int* const n2(&m2);// First snapshotcout << "n1 = " << n1 << '\t' << *n1 << '\n'
<< "n2 = " << n2 << '\t' << *n2 << endl;
n1 = &m2;//*n1 = 15;m1 = 17;
21const char * x = &p;        /* x is a pointer to const char*/
char * const y = &q; /* y is a const pointer to char */const char * const z = &r; /* z is a const pointer to a const char */
continuedezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 41
0xbffff504First Snapshot
const (via n1)
m1
location 0xbffff504n111
0xbffff500const
m2
location 0xbffff500n213
0xbffff504Second Snapshot
const (via n1)
m1
location 0xbffff504n117
0xbffff500const
m2
location 0xbffff500n216//n2 = &m1;
*n2 = 16;// Second snapshotcout << "n1 = " << n1 << '\t' << *n1 << '\n'
<< "n2 = " << n2 << '\t' << *n2 << endl;
return 0;
}
Output:
src/constptr> g++ constptr.cpp
src/constptr> ./a.out
n1 = 0xbffff504 11n2 = 0xbffff500 13n1 = 0xbffff500 16n2 = 0xbffff500 16src/constptr>
error: assignment of read-only location
m2 is an ordinary int variable—OK to assignerror: assignment of read-only variable ‘n2’
okay to change target
Figure 1.2 shows two snapshots of memory that may help to clarify what is hap-
pening when the program runs. Notice that the program produces a memory leak.432143CHAPTER 1: C++ INTRODUCTION
42
FIGURE 1.2 Two snapshots of memory showing what the program
in Example 1.2 producesezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 42
An object that is read-only when accessed through one pointer may be changeable
when accessed through another pointer. This fact is commonly exploited in thedesign of functions.
char* strcpy(char* dst, const char* src); // strcpy cannot change *src
It is okay to assign the address of a variable to a pointer to const . It is an error to
assign the address of a const object to an unrestricted (i.e., non-const) pointer
variable because that would allow the const object’s value to be changed.
int a = 1;
const int c = 2;const int* p1 = &c;   // OKconst int* p2 = &a;   // OKint* p3 = &c;        // error*p3 = 5;             // error
It is good programming practice to use const to protect  pointer and reference
parameters that do not need to be altered by the action of a function. Read-onlyreference parameters provide the power and efficiency of pass-by-reference withthe safety of pass-by-value (see Section 5.6).
1.14 Reference Variables
We observed earlier that an object (in the most general sense) is a contiguous
region of storage. An lvalue is an expression that refers to an object. Examples of
lvalues are variables, array cells, and dereferenced pointers. In essence, an lvalue isanything with a memory address that can be given an alternate name. By contrast,temporary or constant expressions such as 
i+1 or 3are not lvalues.
In C++, a reference provides a mechanism for assigning an alternative name
to an lvalue. References are useful for avoiding copies when a copy is costly orunnecessary, for example, when passing a very large object as a parameter to afunction. A reference must be initialized when it is declared, and the initializermust be an lvalue.
T o create a reference to an object of type 
SomeType , a variable must be
declared to be of type  SomeType& . For example:
int n;
int& rn = n;1.14 REFERENCE VARIABLES
43ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 43
The ampersand &following the int indicates that rnis an int reference. The ref-
erence variable rnis an alias for the actual variable n. Note that the &is being used
here as a type modifier in a declaration, rather than as an operator on an lvalue.
For its entire life, a reference variable will be an alias for the actual lvalue that
initialized it. This association cannot be revoked or transferred. For example:
int a = 10, b = 20;
int& ra = a;         // ra is an alias for ara = b;             // this causes a to be assigned the value 20
const int c = 45;   // c is a constant: its value is read-only.
const int & rc = c; // legal but probably not very useful.rc = 10;            // compiler error - const data may not 
// be changed.
The reader has surely noticed that the use of the ampersand in this section might
be confused with its use in the earlier section on pointers. T o avoid confusion, justremember these two facts:
1. The address-of operator applies to an object and returns its address.
Hence, it will only appear on the right side of an assignment or in aninitializing expression for a pointer variable.
2. In connection with references, the ampersand is used only in the declara-
tion of a reference. Hence, it will only appear to the left of the referencename as it is being declared.
POINTS OF DEPARTURE
1. See Section 22.1 to learn more about how pointers can be used or
misused.
2. See Chapter 19 to learn more about how pointers and types can be
converted.CHAPTER 1: C++ INTRODUCTION
44ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 44
REVIEW QUESTIONS
45
REVIEW QUESTIONS
1. What is a stream? What kinds of streams are there?
2. Give one reason to use an ostrstream .
3. What is the main difference between getline and the >> operator?
4. What is the type of each expression?
a. 3.14
b. ‘D’c. “d”d. 6e. 6.2ff. “something stringey”g.
false
5. In Example 1.23, identify the type and value of each “thing”:
EXAMPLE 1.23 src/types/types.cpp
#include <iostream>
int main() {
using namespace std;int i = 5;int j=6;int *p = &i;                           int& r=i;int& rpr=(*p);i = 10;p = &j;                               rpr = 7;                              
r = 8;                                
cout << "i=" << i << " j=" << j << endl;  
}
*p: ______
*p: ________*p: ________rpr: ________
i: ________ j: ________
6. What is the difference between a pointer and a reference?
7. Why does main(int argc, char* argv[]) sometimes have
parameters? What are they used for?5432154321ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 45
ezus_138004_ch01.qxd  8/4/06  9:36 AM  Page 46
2CHAPTER 2 
Classes
This chapter provides an introduction to classes and
objects, and how member functions operate onobjects. UML is introduced. static and const
members are explained. Constructors, destructors,copy operations, and friends are discussed.
472.1 Structs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482.2 Class Definitions . . . . . . . . . . . . . . . . . . . . . 492.3 Member Access Specifiers . . . . . . . . . . . . 512.4 Encapsulation . . . . . . . . . . . . . . . . . . . . . . . 542.5 Introduction to UML . . . . . . . . . . . . . . . . . 542.6 Friends of a Class . . . . . . . . . . . . . . . . . . . . 552.7 Constructors . . . . . . . . . . . . . . . . . . . . . . . . 562.8 Subobjects . . . . . . . . . . . . . . . . . . . . . . . . . . 582.9 Destructors . . . . . . . . . . . . . . . . . . . . . . . . . 602.10 The Keyword static. . . . . . . . . . . . . . . . . . . 612.11 Copy Constructors and Assignment
Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
2.12 Conversions . . . . . . . . . . . . . . . . . . . . . . . . . 672.13 const Member Functions . . . . . . . . . . . . . 68ezus_138004_ch02.qxd  8/3/06  4:27 PM  Page 47
2.1 Structs
In the C language, there is the struct keyword, for defining a structured chunk
of memory.
EXAMPLE 2.1 src/structdemo/demostruct.h
[ . . . . ]
struct Fraction {
int numer, denom;string description;
};
[ . . . . ]
A structured piece of memory is comprised of smaller chunks of memory of var-
ious types and sizes, each chunk accessible by name. Example 2.1 shows the defi-nition of a 
struct .
Example 2.2 shows how we can use a structured chunk of memory (containing
subobjects) as a single entity. Each data member ( numer ,denom ,description )
is accessible by name.
EXAMPLE 2.2 src/structdemo/demostruct.cpp
[ . . . . ]
void printFraction (Fraction f) {
cout << f.numer << "/" << f.denom << endl;cout << "    =?  "  << f.description << endl;
}
int main()  {
Fraction f1;fl.numer = 4;
fl.denom = 5;fl.description = "four fifths";1
ezus_138004_ch02.qxd  8/3/06  4:27 PM  Page 48
Fraction f2 = {2, 3, "two thirds"};
f1.numer = f1.numer + 2;
printFraction (f1);printFraction (f2);return 0;
}
Output:
6/5
=? four fifths2/3=? two thirds
Passing a struct by value could be expensive if it has large components.
member initialization
2.2 Class Definitions
C++ has another datatype called class that is very similar to struct . A simple
class definition looks like this:
class className {
members
};
The first line of the class definition is called the classHead . The features of a class
include data members, member functions, and access specifiers. Member func-tions are used to manipulate or manage the data members.
After a class has been defined, the class name can be used as a type for vari-
ables, parameters, and returns from functions. Variables of a class type are calledobjects ,o r  instances , of a class.
Member functions for class 
Tspecify the behavior of all objects of type Tand
have access to all members of the c lass. Non-member functions normally manip-
ulate objects indirectly by calling member functions. The set of values of the datamembers of an object is called the state of the object.
T o define a class (or any other type) we generally place the definition in a
header file , preferably with the same name as the class and with the .hextension.
Example 2.3 shows a class definition defined in a header file.2122.2 CLASS DEFINITIONS
49ezus_138004_ch02.qxd  8/3/06  4:27 PM  Page 49
EXAMPLE 2.3 src/classes/fraction.h
#ifndef _FRACTION_H_ 
#define _FRACTION_H_  
#include <string>
using namespace std;
class Fraction {
public:
void set(int numerator, int denominator);double toDouble() const;string toString() const;
private:
int m_Numerator;int m_Denominator;
};
#endif
Header files are #included in other files by the preprocessor. T o prevent a
header file from accidentally being #included more than once in any compiled
file, we wrap it with #ifndef-#define . . . #endif preprocessor macros
(see Section C.1).
Generally, we place the definitions of member functions outside the class def-
inition in a separate implementation file with the .cpp extension.
The definition of any class member outside the class definition requires a
scope resolution operator of the form ClassName:: before its name. The scope
resolution operator tells the compiler that the scope of the class extends beyondthe class definition and includes the code between the 
::and the closing brace of
the function definition.
Example 2.4 is an implementation file that corresponds to Example 2.3.
EXAMPLE 2.4 src/classes/fraction.cpp
#include "fraction.h"
#include <sstream>
void Fraction::set(int nn, int nd) {
m_Numerator = nn;m_Denominator = nd;
}CHAPTER 2: CLASSES
50ezus_138004_ch02.qxd  8/3/06  4:27 PM  Page 50
double Fraction::toDouble() const {
return 1.0 * m_Numerator / m_Denominator;
}
string Fraction::toString() const {
ostringstream sstr;sstr << m_Numerator << "/" << m_Denominator; return sstr.str();
}
a stream we write to, but that does not get output anywhere
convert the stream just written to a string
Every identifier has a scope (see Section 20.2), a region of code where a name is
“known” and accessible. Class member names have class scope . Class scope
includes the entire class definition, regardless of where the identifier was declared,as well as inside each member function definition, starting at the 
::and ending at
the closing brace of the definition.
So, for example, the members, Fraction::m_Numerator and
Fraction::m_Denominator are visible inside the definitions of
Fraction::toString() and Fraction::toDouble() even though those
function definitions are in a separate file.
2.3 Member Access Specifiers
Thus far we have worked with class definition code and class implementation
code . There is a third category of code as it relates to a given class. Client code is
code that is outside the scope of the class but that uses objects of the class.
Generally, client code #includes the header file that contains the class definition.
We now revisit the Fraction class, focusing on its member access specifiers.
See Example 2.5.
EXAMPLE 2.5 src/classes/fraction.h
#ifndef _FRACTION_H_
#define _FRACTION_H_
#include <string>
using namespace std;21212.3 MEMBER ACCESS SPECIFIERS
51
continuedezus_138004_ch02.qxd  8/3/06  4:27 PM  Page 51
class Fraction {
public:
void set(int numerator, int denominator);double toDouble() const;string toString() const;
private:
int m_Numerator;int m_Denominator;
};
#endif
The member access specifiers, public ,protected , and private , are used in
a class definition to specify where in a program the affected members can beaccessed. The following list provides an informal first approximation of the defi-nitions of these three terms. Refinements are contained in footnotes.
■A public member can be accessed (using an object of the class1) any-
where in a program that #includes the class definition file.
■A protected member can be accessed inside the definition of a mem-
ber function of its own class, or a member function of a derived class.2
■A private member is only accessible by member functions of its own
class.3
Accessibility versus Visibility
There is a subtle difference between accessibility and visibility . In order for
a named item to be accessible, it must first be visible (in our scope). Not allvisible items are accessible. Accessibility depends on member access speci-fiers:public/private/protected.CHAPTER 2: CLASSES
52
1public static members can be accessed without an object. We discuss this in Section 2.10.
2We discuss derived classes in Chapter 6.
3Private members are also accessible by friends of the class, which we discuss in Section 2.6.Example 2.6 shows client code that demonstrates visibility errors in a variety of
ways. This example also focuses on block scope , which extends from an opening
brace to a closing brace. A variable dec lared inside a block is visible and accessible
only between its declaration and the closing brace. In the case of a function,ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 52
the block that contains the function definition also includes the function’s param-
eter list.
EXAMPLE 2.6 src/classes/fraction-client.cpp
#include "fraction.h"
#include <iostream>
int main() {
const int DASHES = 30;using namespace std;
{                             
int i;for(i = 0; i < DASHES; ++i)
cout << "=";
cout << endl;
}   
// cout << "i = " << i << endl;
Fraction f1, f2;f1.set(3, 4);f2.set(11,12);// f2.m_Numerator = 12;         cout << "The first fraction is: " << f1.toString() << endl;cout << "\nThe second fraction, expressed as a double is: "
<< f2.toDouble() << endl;
return 0;
}
nested scope—inner block
error—i no longer exists, so it is not visible in this scope.set through a member function
error—m_Numerator is visible but not accessible.
Now we can describe the difference between struct and class in C++.
Stroustrup defines a struct to be a class in which members are by default
public , so that
struct T { ... 
means precisely
class T {public: ...432143212.3 MEMBER ACCESS SPECIFIERS
53ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 53
2.4 Encapsulation
Encapsulation is the first conceptual step in object-oriented programming. It
involves
■Packaging data with the functions that can operate on that data in well-named classes
■Providing clearly named and well-documented public functions that
allow users of the class to do whatever  needs to be done with objects of
this class
■Hiding implementation details
The set of public function prototypes in a class is called its public interface .
The set of non- public members, as well as the function definitions them-
selves, comprise the implementation .
One immediate advantage of encapsulation is that it permits the programmer
to use a consistent naming scheme for the members of classes. For example, thereare many different classes for which it might make sense to have a data memberthat contains the ID of the particular instance. We could adopt the convention ofcalling such a data member 
m_ID in every class that needs one. Because class
member names are not visible outside the class scope, there is no danger of ambi-guity if a member name is also used somewhere else in the program.
2.5 Introduction to UML
UML, the Unified Modeling Language, is a language for object-oriented design.
We use UML diagrams, because “a picture is worth 1K words.” UML class dia-grams can show the important elements of and relationships between classes in aconcise and intuitive way. UML is much more than just class diagrams. Otherkinds of UML diagrams can illustrate how classes collaborate with one anotherand how users interact with classes.We will only use a small subset of UML in thisbook.
Most of our diagrams were created with a design tool called Umbrello.
4For a
good overview of UML, we recommend The Umbrello UML Modeller Handbook ,
available from the help menu of Umbrello. Another reference that provides maxi-mum content and minimal bulk is [Fowler04].CHAPTER 2: CLASSES
54
4http://uml.sourceforge.netezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 54
2.6 FRIENDS OF A CLASS
55
Person
-m_Name : string - private
+ publicClassName
Data Members
Member Functions + getPosition() : Position
+ getEmployer() : Employer+ getName() : string
Figure 2.1 is a class diagram with only one class: Person. Notice that the declarations
appear in the name : type , Pascal-style, rather than the more familiar C++/Java style,
where the names come after the types. This is to help with readability—because wetend to read from left to right, this syntax helps us find names faster. Notice also that
public members are preceded by a plus sign ( +) andprivate members are pre-
ceded by a minus sign ( -).
2.5.1 UML Relationships
UML is especially good at describ ing relationships between classes. Looking ahead
to Example 2.9, we describe the subobject relationship in UML. Because the sub-objects are strictly part of the parent object and cannot possibly exist as stand-alone objects, we could use the composition relationship. As Figure 2.2 shows, the
filled-in diamond indicates that the object on that side is composed (partially) of
the object(s) from the other side of the relationship.
2.6 Friends of a Class
Now that we know about accessibility rules, we need to know how to break them
occasionally. The friend mechanism makes it possible for a class to allow non-
member functions to access its private data. The keyword friend is followed byFIGURE 2.1 Person class
Square
 - m_UpperLeft : Point
 - m_LowerLeft : Point
+ Square(ulx : int, uly : int, lrx : int, lry : int)
+ Square(ul : const Point&, lr : const Point&)Point
 - x : int
 - y : int
+ Point(xx : int, yy : int)
+ ~ Point()
FIGURE 2.2 Compositionezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 55
a class or a function declaration. friend declarations are located inside a class
definition. Here are some syntax examples.
class Timer {
friend class Clock;friend void Time::toString();friend ostream& operator <<(ostream& os, const Timer& obj);[ . . . ]   
private:
long m_Elapsed;
};
A friend can be a class, a member function of another class, or a non-member
function. In the previous example, class Clock is a friend , so all of its member
functions can access Timer::m_Elapsed .Time::toString() is a friend of
Timer and is assumed (by the compiler) to be a valid member of class Time .T h e
third friend is a non-member function, an overloaded insertion operator ,
which inserts its second argument into the output stream and returns a referenceto the stream so that the operation can be chained.
Breaking encapsulation can compromise the maintainability of your programs,
so you should use the 
friend mechanism sparingly and carefully. Typically,
friend functions are used for two purposes.
1. For factory methods when we want to enforce creational rules (see
Section 16.1.4) on a class
2. For global operator functions such as << and >> when we do not wish
to make the operator a member function, or do not have write-access tothe class definition
2.7 Constructors
Aconstructor , sometimes abbreviated as ctor, is a special member function that
controls the process of object initialization. Each constructor must have the samename as its class. Constructors do not return anything and do not have return types.
There is a special syntax for constructor definitions:
ClassName ::ClassName ( parameter_list )
:init-list
{
constructor body
}
optional11CHAPTER 2: CLASSES
56ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 56
Between the closing parenthesis of the parameter list and the opening brace of a
function body, an optional member initialization list can be given. A member ini-
tialization list begins with a colon (:) and is followed by a comma-separated list
of member initializers, each of the form 
member_name (initializing_expression )
If (and only if) no constructor is specified in a class definition, the compiler will
supply one that looks like this:
ClassName ::ClassName () 
{ }
A constructor that can be called with no arguments has the name default con-
structor . We say that a default constructor gives default initialization to an object
of its class. Any data member that is not explicitly initialized in the member ini-tialization list of a constructor is given default initialization.
Classes can have several constructors, each of which initializes in a different
(and presumably useful) way. Example 2.7 has three constructors.
EXAMPLE 2.7 src/ctor/complex.h
class Complex {
public:
Complex(double realPart, double imPart);Complex(double realPart);Complex();
private:
double m_R, m_I;
};
Example 2.8 shows the implementatio n with some client code.
EXAMPLE 2.8 src/ctor/complex.cpp
#include "complex.h"
#include <iostream>using namespace std;
Complex::Complex(double realPart, double imPart)
:   m_R(realPart), m_I(imPart)
{ 
cout << "complex(" << m_R << "," << m_I << ")" << endl;
}12.7 CONSTRUCTORS
57
continuedezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 57
Complex::Complex(double realPart) {
Complex(realPart, 0);
}
Complex::Complex() : m_R(0.0), m_I(0.0) {}int main() {
Complex C1;Complex C2(3.14);Complex C3(6.2, 10.23);
}
member initialization list
Call one constructor from another, java-style.
The default constructor for this class gives default initialization to the two data
members of the object C1. That initialization is the same kind that would be given
to a pair of variables of type double in the following code fragment:
double x, y;
cout << x << '\t' << y << endl;
What would you expect to be the output of that code?
2.8 Subobjects
An object can contain another object, in which case the contained object is
considered to be a subobject . In Example 2.9, each Square object has two Point
subobjects. Notice that Point has a function named ~Point . We discuss this
kind of function in the next section.
EXAMPLE 2.9 src/subobject/subobject.h
[ . . . . ]
class Point {
public:
Point(int xx, int yy) : m_x(xx), m_y(yy){}~Point() {
cout << "point destroyed: ("
<< m_x << "," << m_y << ")" << endl;
}
private:
int m_x, m_y;
};212CHAPTER 2: CLASSES
58ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 58
class Square {
public:
Square(int ulx, int uly, int lrx, int lry): m_UpperLeft(ulx, uly), m_LowerRight (lrx, lry){}
Square(const Point& ul, const Point& lr) :
m_UpperLeft(ul), m_LowerRight(lr) {}private:
Point m_UpperLeft, m_LowerRight;
};
[ . . . . ]
Initialization is required because there is no default ctor.
Initialize using the implicitly generated Point copy ctor.
embedded subobjects
Whenever an instance of Square is created, each of its subobjects is created with
it, so that the three objects occupy contiguous chunks of memory.
The Square is composed of two Point objects.
Because Point has no default constructor, we must properly initialize for each
Point subobject in the member initialization list of Square (see Example 2.10).
EXAMPLE 2.10 src/subobject/subobject.cpp
#include "subobject.h"
int main() {
Square sq1(3,4,5,6);Point p1(2,3), p2(8, 9);Square sq2(p1, p2);
}
Even though no destructor was defined for Square , each of its Point subobjects
is properly destroyed whenever the containing object is. This is an example ofcomposition.
point destroyed: (8,9)
point destroyed: (2,3)point destroyed: (8,9)point destroyed: (2,3)point destroyed: (5,6)point destroyed: (3,4)3213212.8 SUBOBJECTS
59ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 59
2.9 Destructors
A destructor , sometimes abbreviated as dtor, is a special member function that
automates clean-up actions just before an object is destroyed.
WHEN IS AN OBJECT DESTROYED?
■When a local (automatic) object goes out of scope (e.g., when a func-
tion call returns)
■When an object created by the new operator is specifically destroyed
by the use of the operator delete
■Just before the program terminates, all objects with static storage
are destroyed
The destructor’s name is the classname preceded by the tilde (~) character. It has
no return type and no parameters, so it cannot be overloaded. If the class definitioncontains no destructor definition, the compiler will supply one that looks like this:
ClassName::~ClassName() 
{ }
We will look at a less trivial example of a destructor in the next section.
WHEN DO WE NEED TO WRITE A DESTRUCTOR? In general, a class
that directly manages or shares an external resource (opens a file, opensa network connection, creates a proces s, etc.) needs to free the resource
at some appropriate time. Such classes are usually wrappers that areresponsible for object cleanup.
Qt’s container classes make it easy for us to avoid writing code that
directly manages dynamic arrays.
Y ou do notneed a destructor if your class:
■Has simple type members that are not pointers
■Has class members with properly defined destructors themselves
The default compiler-generated destructor calls the destructors on each of its class
members in the order that they are listed in the class definition before the objectis destroyed. It does nothing with pointers or simple types.CHAPTER 2: CLASSES
60ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 60
2.10 The Keyword static
The keyword static can be applied to a variable declaration to give the variable
static storage class (see Section 20.3).
A local static variable is created only once, the first time its declaration
statement is processed by the running program. It is destroyed when the programterminates. A 
static data member of a class is created once, just before the pro-
gram begins execution, and is destroyed when the program terminates.
A static data member is a piece of data that is associated with the class itself
rather than one that belongs to a particular object. It does not affect the sizeof()
an object of the class. Each object of a class maintains its own set of non- static
data members, but there is only one instance of any static data member, and it
can be shared by all objects of the class.
static class members are preferable to (and can generally replace the use of)
global variables because they do not pollute the global namespace.
static data members must be declared static in (and only in) the class
definition.
A class member function that does not in any way access the non- static data
members of the class can (and should) be declared static . In Example 2.11, the
static data member is a private counter that keeps track of the number of
Thing objects that exist at any given moment. The public static member func-
tion displays the current value of the static counter.
EXAMPLE 2.11 src/statics/static.h
[ . . . . ]
class Thing {public:
Thing(int a, int b);~Thing();void display() const ;static void showCount();
private:
int m_First, m_Second;static int sm_Count;
};
[ . . . . ]
The class UML diagram for Thing is shown in Figure 2.3. Notice that the static
members are underlined in the diagram.2.10 THE KEYWORD STATIC
61ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 61
CHAPTER 2: CLASSES
62
5The exception to this rule is a staticconstint , which can be initialized in the class definition.Each static data member must be initialized (defined) outside the class defini-
tion, preferably in the class implementation file (not a header file) as shown inExample 2.12.
5
EXAMPLE 2.12 src/statics/static.cpp
#include "static.h"
#include <iostream>
int Thing::sm_Count = 0;Thing::Thing(int a, int b)
: m_First(a), m_Second(b) {
++sm_Count;
}
Thing::~Thing() {
--sm_Count;
}
void Thing::display() const {
using namespace std;cout << m_First << "$$" << m_Second;
}
void Thing::showCount() {
using namespace std;cout << "Count = " << sm_Count << endl;
}
Must initialize static member!
static function2121Thing
 - m_First : int
 - m_Second : int - sm_Count : int
+ Thing(a : int, b : int)+ ~ Thing()+ display()+ showCount() 
FIGURE 2.3 Thing class diagramezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 62
Notice that the term static does not appear in the definitions of
sm_Count or showCount() . This is because the keyword static
would mean something quite different there: It would change the scope
of the variable from global to file-scope (see Section 20.2).
Block-Scope static
static s that are defined inside a function or a block of code are initialized when
they are executed for the first time.
long nextNumber() {
int localvar(24);static long nmber = 1000;cout << nmber + localvar;return ++nmber;
}
The first call to nextNumber() initializes localvar to 24 and nmber to 1000 ,
displays 1124 on the screen, and returns 1001. When the function returns,
localvar is destroyed but nmber is not destroyed. Each time that this function
is called,localvar gets created and initialized to 24again. The static variable
nmber persists between calls and holds onto the value that it obtained in the last
call. So, for example, the next time the function is called, 1025 is displayed and
1002 is returned.
static Initialization
A static object that is not defined in a block or function is initialized when its
corresponding object module (see Sectio n 7.1) is loaded for the first time. Most of
the time, this is at program startup, before main() starts. The order in which
modules get loaded and variables ge t initialized is implementation dependent.
A static object is constructed once and persists until the program termi-
nates. A static data member is a static object that has class scope.
In Example 2.13, we make use of an internal block so that we can introduce
some local objects that will be destroyed before the program ends.2.10 THE KEYWORD STATIC
63ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 63
EXAMPLE 2.13 src/statics/static-test.cpp
#include "static.h"
int main() {
Thing::showCount();Thing t1(3,4), t2(5,6);t1.showCount();{
Thing t3(7,8), t4(9,10);Thing::showCount(); 
}
Thing::showCount(); 
return 0;
}
No objects exist at this point.
direct access through objectAn inner block of code is entered.
end inner block
Here is the compile and run.
src/statics> g++ -ansi -pedantic -Wall static.cpp static-test.cpp 
src/statics> ./a.out
Count = 0Count = 2Count = 4Count = 2src/statics>   
2.11 Copy Constructors and Assignment
Operators
C++ gives almost god-like powers to the designer of a class. Object “life cycle”
management means taking complete control over the behavior of objects duringbirth, reproduction, and death. We have already seen how constructors manage thebirth of an object and how destructors are used to manage the death of an object.This section investigates the reproduction process: the use of copy constructorsand assignment operators.
A copy constructor is a constructor that has a prototype like this:
ClassName (const ClassName & x);43214321CHAPTER 2: CLASSES
64ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 64
The purpose of a copy constructor is to create an object that is an exact copy of an
existing object of the same class.
An assignment operator for a class overloads the symbol =and gives it a
meaning that is specific to the class. There is one particular version of the assign-ment operator that has the following prototype:
ClassName & operator=(const ClassName & x);
Because it is possible to have several different overloaded versions of the
operator=() in a class, we call this particular version the copy assignment
operator (see Example 2.14).
EXAMPLE 2.14 src/lifecycle/copyassign/fraction.h
[ . . . . ]
class Fraction {public:
Fraction(int n, int d) : m_Numer(n), m_Denom(d) {
++ctors;
}Fraction(const Fraction& other)
:  m_Numer(other.m_Numer), m_Denom(other.m_Denom) {
++copies;
}Fraction& operator=(const Fraction& other) {
m_Numer = other.m_Numer;m_Denom = other.m_Denom;++assigns;return *this;
}
Fraction multiply(Fraction f2)  {
return Fraction (m_Numer*f2.m_Numer, m_Denom*f2.m_Denom);
}
static void report();
private:
int m_Numer, m_Denom;static int assigns;static int copies;static int ctors;
};
[ . . . . ]2.11 COPY CONSTRUCTORS AND ASSIGNMENT OPERATORS
65ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 65
The version of Fraction in Example 2.14 defines three static counters, so
that we can count the total number of times ea ch member function is called. This
should help us better understand when objects are copied. Example 2.15 uses it tocreate, copy, and assign some objects.
EXAMPLE 2.15 src/lifecycle/copyassign/copyassign.cpp
#include <iostream>
#include "fraction.h"
int main() {
using namespace std;Fraction twothirds(2,3);Fraction threequarters(3,4); Fraction acopy(twothirds);Fraction f4 = threequarters;cout << "after declarations" ;Fraction::report();f4 = twothirds;cout << "before    multiply" ;Fraction::report();f4 = twothirds.multiply(threequarters);cout << "after     multiply" ;Fraction::report();return 0;
}
using 2-arg constructor
using copy constructoralso using copy constructorassignment
Lots of objects get created here.
src/ctor> g++ -ansi -pedantic -Wall copyassign.cpp
src/ctor> ./a.out
after declarations
[ assigns: 0 copies: 2 ctors: 2 ]
before    multiply
[ assigns: 1 copies: 2 ctors: 2 ]
after     multiply
[ assigns: 2 copies: 3 ctors: 3 ]
src/ctor> 
As you can see, the call to multiply creates three Fraction objects.
Can you explain why?5432154321CHAPTER 2: CLASSES
66ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 66
It is important to know that the compiler will supply default versions of the copy
constructor and/or the copy assignment operator if one or both are missing fromthe class definition. The compiler-supplied default versions have the followingprototypes for a class 
T:
T::T(const T& other);
T& T::operator=(const T& other);
2.12 Conversions
A constructor that can be called with a single argument (of a different type) is
aconversion constructor because it defines a conversion from the argument type
to the constructor’s class. See Example 2.16.
EXAMPLE 2.16 src/ctor/conversion/fraction.cpp
class Fraction {
public:
Fraction(int n, int d = 1)
: m_Numerator(n), m_Denominator(d) {}
private:
int m_Numerator, m_Denominator;
};int main() {
Fraction frac(8);Fraction frac2 = 5;frac = 9;frac = (Fraction) 7;frac = Fraction(6);frac = static_cast<Fraction>(6);return 0;
}
default argument
conversion constructor callcopy init (calls conversion ctor too)conversion followed by assignmentC-style typecast (deprecated)explicit temporary, also a C++ typecast
preferred ANSI style typecast
In Example 2.16, the Fraction variablefrac is initialized with a single int.T h e
matching constructor is the two argument version, but the second parameter(denominator) defaults to 1. Effectively, this converts the integer 8 to the fraction 8/1.
The conversion constructor for ClassA is automatically called when an object of
that class is required and when such an object can be created by that constructorfrom the value of TypeB that was supplied as an initializer or assigned value.765432176543212.12 CONVERSIONS
67ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 67
For example, if frac is of type Fraction as defined above, then we can write
the statement
frac = 19;    
Since 19 is not a Fraction object, the compiler checks to see whether it can be
converted to a Fraction object. Since we have a conversion constructor, this is
indeed possible.
So under the covers, the statement f=1 9 makes two “implicit” calls to
Fraction member functions:
1.Fraction::Fraction(19); to convert from int to Fraction .
2.Fraction::operator=() to perform the assignment.
This causes a temporary Fraction object on the stack to be created, which is
then popped off when the statement is finished executing.
Since we have not defined Fraction::operator=() , the compiler uses a
default assignment operator that it supplied.
Fraction& operator=(const Fraction& fobj); 
This operator performs a memberwise assignment, from each data member of
fobj to the corresponding member of the host object.
Ordinarily, any constructor that can be called with a single argument of differ-
ent type is a conversion constructor that has the implicit mechanisms discussedhere. If the implicit mechanisms are not appropriate for some reason, it is possi-ble to suppress them. The keyword explicit prevents implicit mechanisms from
using that constructor.
2.13 const Member Functions
When a class member function X::f() is invoked through an object x
x.f(); 
we refer to xas the host object .
The const keyword has a special meaning when it is applied to a (non-static)
class member function. Placed after the parameter list, const becomes part of the
function signature and guarantees that the function will not change the state ofthe host object.
A good way to think of this is to realize that each non-static member function
has an implicit parameter, named 
this , which is a pointer to the host object.
When we declare a member function to be const , we are telling the compiler that,
as far as the function is concerned, this is a pointer to const.CHAPTER 2: CLASSES
68ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 68
T o explain how const changes the way a function is invoked, we look at how
the original C++ to C preprocessor dealt with member functions.
Since C did not support overloaded func tions or member functions, the pre-
processor translated the function into a C function with a “mangled” name, whichdistinguished itself from other functions by encoding the full signature in thename. The mangling process also added an extra implicit parameter to the param-eter list:
this , a pointer to the host object. Example 2.17 shows how member
functions might be seen by a linker after a translation into C.
EXAMPLE 2.17 src/const/constmembers.cpp
#include <iostream>
class Point {
public:Point(int px, int py) 
: m_X(px), m_Y(py) {}
void set(int nx, int ny) {
m_X = nx;m_Y = ny;
}void print() const {
using namespace std;cout << "[" << m_X << "," << m_Y << "]";m_X = 5;
}
private:
int m_X, m_Y;
};
int main() {
Point p(1,1);const Point q(2,2);p.set(4,4);p.print();q.set(4,4);return 0;
}
mangled version: _Point_set_int_int(Point* this, int nx, int ny)
mangled version: _Point_print_void_const(const Point* this)Error: this->m_X = 5, *this is const.Okay to reassign p
Error! const object cannot call non-const methods.54321543212.13 CONST MEMBER FUNCTIONS
69ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 69
In a real compiler, the mangled names for set and print would be compressed
significantly to save space and hence would be less understandable to a humanreader.
We can think of the 
const in the signature of print() as a modifier of the
invisible this parameter that points to the host object. This means that the mem-
ory pointed to by this cannot be changed by the action of the print() func-
tion. It is a compiler error to change anything via this in a const member
function. The reason that the assignment
x = 5;
produces an error is that it is equivalent to
this->x = 5;
The assignment violates the rules of const .
EXERCISES: CLASSES
Examples 2.18–2.20 are part of a single program. Use them together to answer the
following questions.
1.EXAMPLE 2.18 src/early-examples/thing.h
#ifndef THING_H_
#define THING_H_
class Thing {
public:
void set(int num, char c);void increment();void show();
private:
int m_Number;char m_Character;
};#endif
EXAMPLE 2.19 src/early-examples/thing.cpp
#include <iostream>#include "thing.h"
void Thing::set(int num, char c) {
m_Number = num;m_Character = c;
}CHAPTER 2: CLASSES
70ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 70
void Thing::increment() {
++m_Number;++m_Character;
}
void Thing::show() {
using namespace std;cout << m_Number << '\t' << m_Character << endl;
}
EXAMPLE 2.20 src/early-examples/thing-demo.cpp
#include <iostream>#include "thing.h"
void display(Thing t, int n) {
int i;for (i = 0; i < n; ++i)
t.show();
}
int main() {
using namespace std;Thing t1, t2;t1.set(23, 'H');t2.set(1234, 'w');t1.increment();
//    cout << t1.m_Number;  
display(t1, 3);
//    cout << i << endl;
t2.show();return 0;
}
a.Uncomment the two commented out lines of code in thing-demo.cpp
(Example 2.20) and try to compile the program using 
g++ -ansi -pedantic -Wall thing.cpp thing-demo.cpp 
Explain the difference between the errors that are reported by the compiler.
b.Add public member functions to the definition of the class Thing so that
the data members can be kept private and the client code can still outputtheir values.
2.Implement the member functions of this slightly enhanced 
Fraction class
from Section 2.2. Given the UML diagram below, define the class, and each2.13 CONST MEMBER FUNCTIONS
71ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 71
member specified, for an enhanced Fraction class. You can use Example 2.4
as a starting point.CHAPTER 2: CLASSES
72
Write some client code to test all of the new operations and verify that proper
calculations are done.
3.Suppose that you wanted to write an application for a company that matches
employers and job seekers. A first step would be to design appropriate classes.
The UML diagram, The Company Chart, shows three classes, with Person
having two subobjects: Employer and Position.Fraction
 - m_Numerator : int
 - m_Denominator : int
+ set(numerator : int, denominator : int)
+ toDouble() : double+ toString() : string+ add(other : const Fraction&) : Fraction+ subtract(other : const Fraction&) : Fraction+ multiply(other : const Fraction&) : Fraction+ divide(other : const Fraction&) : Fraction
Person
 - m_Name : string
 - m_Employed : bool - m_position : Position - m_employer : Employer
+ Person(name : string)
+ toString() : string+ setPosition(newC : Company, newP : Position)
Employer
 - m_Name : string
 - m_market : string
+ hire(newHire : Person&, pos : Position) : bool
+ Employer(name : string, market : string)+ toString() : stringPosition
 - m_Name : string
 - m_Description : string
+ Position(name : string, description : string)
+ toString() : stringezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 72
2.13 CONST MEMBER FUNCTIONS
73
In order to do this exercise, you will need to use forward declarations (see
Section C.1).
a.Write classes for Person ,Position , and Employer as described in The
Company Chart.
b.For Person::getPosition() and getEmployer() , create and return
something funny if the person has not yet been hired by a company.
c.For the hire(...) function, set the Person ’s state so that future calls to
getPosition() and getEmployer() give the correct result.
d.In the main() program, create at least two Employers, the “StarFleet
Federation” and the “Borg.”
e.Create at least two employees, Jean-Luc Picard and Wesley Crusher.
f.For each class, write a toString() function that gives you a string rep-
resentation of the object.
g.Write a main program that creates some objects and then prints out each
company’s list of employees.
4.Define a class to represent a modern automobile.
Here are some features of this class.
■ The constructor requires an odometer reading and a value for the aver-
age fuel consumption rate in miles per gallon to initialize those two datamembers.
■ Thedrive() function should be reasonably smart:
■It should not permit the car to drive if there is no fuel.
■It should adjust the odometer and the fuel amount correctly.
■It should return the amount of fuel left in the tank.
■ TheaddFuel() function should adjust the fuel amount correctly and
return the resulting amount of fuel in the tank. addFuel(0) should fill
the tank.
Write client code to test this class.Hondurota
 - m_Fuel : double
 - m_Speed : double - m_Odometer : double - sm_FuelTankCapacity : double
 - sm_FuelConsumptionRate : double
+ Hondurota(odom : double, mpg : double)
+ getFuel() : double+ getSpeed() : double+ getOdometer() : double+ drive(speed : double, minutes : int) : double+ addFuel(gal : double) : doubleezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 73
5.In the previous problem we really did not make use of the speed  member. The
drive() function assumed an average speed and used an average fuel con-sumption rate. Now let’s use the speed member to make things a bit morerealistic.
Add a member function to the 
Hondurota class that has the prototype
double highwayDrive(double distance, double speedLimit); 
The return value is the elapsed time for the trip.
When driving on a highway, it is usually possible to travel at or near the
speed limit. Unfortunately, various things happen that can cause traffic to movemore slowly—sometimes much more slowly.
Another interesting factor is the effect that changing speed has on the fuel
consumption rate. Most modern automobiles have a speed that is optimal forfuel efficiency (e.g., 45 mph).
Calculating how long it will take to travel a particular distance on the high-
way, and how much fuel the trip will consume, is the job of this new function.
■ Write the function so that it updates the speed, the odometer, and the fuelamount every minute until the given distance has been travelled.
■ Use 45 mph as the speed at which fuel is consumed precisely at the storedsm_FuelConsumptionRate.
■ Use an adjusted consumption rate for other speeds, increasing the rate ofconsumption by 1% for each mile per hour that the speed differs from45 mph.
■ Your car should stop if it runs out of fuel.
■ Assume that you are travelling at the speed limit, except for random differ-ences that you compute each minute by generating a random speedadjustment between –5 mph and +5 mph. Don’t allow your car to drivefaster than 40 mph above the speed limit. Of course, your car should notdrive slower than 0 mph. If a random speed adjustment produces an unac-ceptable speed, generate another one.
Write client code to test this  function.
6.Be the computer and predict the output of Example 2.21.
EXAMPLE 2.21 src/statics/static3.h
#ifndef _STATIC_3_H_
#define _STATIC_3_H_
#include <string>
using namespace std;CHAPTER 2: CLASSES
74ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 74
class Client {
public:
Client(string name) : m_Name(name), m_ID(sm_SavedID++)
{ }
static int getSavedID() {
if(sm_SavedID > m_ID) return sm_SavedID;else return 0;
}string getName() {return m_Name;}int getID() {return m_ID; }
private:
string m_Name;int m_ID;static int sm_SavedID ;
};
#endif
EXAMPLE 2.22 src/statics/static3.cpp
#include "static3.h"
#include <iostream>
int Client::sm_SavedID(1000);int main() {
Client cust1("George");cout << cust1.getID() << endl;cout << Client::getName() << endl;
}
7.2.13 CONST MEMBER FUNCTIONS
75
Design and implement a Date class subject to the following restrictions and
suggestions.
■ Each Date must be stored as a single integer equal to the number of days
since the fixed base date, January 1, 1000 (or some other date if you prefer).Let’s call that data member m_DaysSinceBaseDate .Date
 - m_DaysSinceBaseDate : unsigned long
+ Date()
+ Date(m : unsigned, d : unsigned, y : unsigned)+ toString(brief : bool) : string+ setT oT oday()+ getWeekDay() : string+ lessThan(d : const Date&) : bool+ equals(d : const Date&) : bool+ daysAfter(d : const Date&) : int+ addDays(days : int) : Date+ leapyear(year : unsigned) : bool
+ monthname(month : unsigned) : string+ yeardays(year : unsigned) : unsigned+ monthdays(month : unsigned, year : unsigned) : unsignedezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 75
■ The base year should be stored as a static unsigned int (e.g., 1000).
■ The class has a constructor and a set function that have month, day, year
parameters. These three values must be used to compute the number ofdays from the base date to the given date. We have specified a privatemember function named mdy2dsbd() to do that calculation for both.
■ ThetoString() function returns a representation of the stored date in
some standard string format that is suitable for display (e.g., yyyy/mm/dd).This involves reversing the computation used in the mdy2dsbd() function
described above. We have specified a private member function namedgetMDY() to do that calculation. We have also suggested a parameter for
thetoString() function (bool brief ) to allow a choice of date formats.
■ We have specified several static utility functions (e.g., leapyear() ) that
are static because they do not affect the state of this class.
■ Make sure you use the correct rule for determining whether or not a given
year is a leap year!
■ Create a file named date.h to store your class definition.
■ Create a file named date.cpp that contains the definitions of all the func-tions declared in date.h.
■ Write client code to test your Date class thoroughly.
■ Here is the code for setToToday() that makes use of the system clock to
determine today’s date. You will need to #include <time.h> (from the
C Standard Library) to use this code.
void Date::setToToday() {
struct tm *tp = new(tm);time_t now;now = time(0);tp = localtime(&now);set(1 + tp->tm_mon, tp->tm_mday, 1900 + tp->tm_year);
}
■getWeekDay() function returns the name of the week day corresponding
to the stored date. Use this in the fancy version of toString() . Hint:
January 1, 1900, was a Monday.
8.Consider the class shown in Example 2.23.
EXAMPLE 2.23 src/destructor/demo/thing.h
#ifndef THING_H_
#define THING_H_
#include <iostream>
#include <string>using namespace std;CHAPTER 2: CLASSES
76ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 76
class Thing {
public:
Thing(int n) : m_Num(n) {
}
~Thing() {
cout << "destructor called: " 
<< m_Num << endl;
}
private:
string m_String;int m_Num;
};
#endif
The client code in Example 2.24 constructs several objects in various ways and
destroys most of them.
EXAMPLE 2.24 src/destructor/demo/destructor-demo.cpp
#include "thing.h"
void function(Thing t) {
Thing lt(106);Thing* tp1 = new Thing(107);Thing* tp2 = new Thing(108);delete tp1;
}
int main() {
Thing t1(101), t2(102);Thing* tp1 = new Thing(103);function(t1);{
Thing t3(104);Thing* tp = new Thing(105);
}delete tp1;return 0;
}
nested block/scope112.13 CONST MEMBER FUNCTIONS
77ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 77
CHAPTER 2: CLASSES
78
Here is the output of this program.
destructor called: 107
destructor called: 106destructor called: 101destructor called: 104destructor called: 103destructor called: 102destructor called: 101
a.How many objects were created but not destroyed?
b.Why does 101 appear twice in the list?ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 78
REVIEW QUESTIONS
79
REVIEW QUESTIONS
1. What is the main advantage of using a struct ?
2. Describe at least one difference between a class and a struct .
3. How does class scope differ from block scope? 4. Describe two situations where it is okay to use 
friend functions.
5. How does a static data member differ from a non- static data mem-
ber?
6. What is the difference between a static member function and a non-
static member function?
7. What does it mean to declare a member function to be const ?
8. Explain what would happen (and why) if a class Thad a copy construc-
tor with the following prototype.
T::T(T other); 
9. Critique the design shown in The Company Chart in Exercise 3. What
problems do you see with it? In particular, how would you write
Employer::getEmployees() or Position::getEmployer() ?ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 79
ezus_138004_ch02.qxd  8/3/06  4:28 PM  Page 80
3CHAPTER 3 
Introduction to Qt
This chapter introduces the Qt development envi-
ronment, including the compiler, linker, make, andqmake. It includes a first example using Qt, andintroduces iterators and lists.
Qt is a modular system of classes and tools that
makes it easier for you to write smaller modules ofcode yourself. This chapter explains how to startreusing Qt.
813.1 Example Project: Using QApplication 
and QLabel . . . . . . . . . . . . . . . . . . . . . . . . . . 82
3.2 Makefile, qmake, and Project Files . . . . . . 833.3 Getting Help Online . . . . . . . . . . . . . . . . . . 893.4 Style Guidelines and Naming 
Conventions . . . . . . . . . . . . . . . . . . . . . . . . . 90
3.5 The Qt Core Module . . . . . . . . . . . . . . . . . . 913.6 Streams and Dates . . . . . . . . . . . . . . . . . . . . 91ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 81
3.1 Example Project: Using QApplication 
and QLabel
Example 3.1 shows a simple main program that creates a QApplication and a
QLabel ,manipulates some QStrings, and then pops up a graphical window.
1http://www.unicode.org/standard/standard.htmlThis example makes use of Qt’sQString class, which is a dynamic string imple-
mentation that supports the Unicode standard.1QString contains many helpful
member functions for converting and formatting strings in different ways. Thisexample also makes use of
QTextStream ,a very flexible Qt class that can provide
a well-developed stream interface for re ading or writing text to various objects
(e.g., text files, strings, and byte arrays).
EXAMPLE 3.1 src/qapp/main.cpp
#include <QApplication>
#include <QString>#include <QLabel>#include <QWidget>#include <QDebug>#include <QTextStream>
int main(int argc, char * argv[]) {
QApplication myapp(argc, argv);QWidget wid;qDebug() << "sizeof widget: " << sizeof(wid) 
<< " sizeof qapplication: " << sizeof(myapp) ;
QString message;QTextStream buf(&message);buf << "A QWdget is " << sizeof(wid)
<< " bytes. \nA QObject is " << sizeof(QObject)
321
ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 82
<< " bytes. \nA QApplication is " << sizeof(myapp)
<< " bytes.";
qDebug() << message;QLabel label(message);label.show();return myapp.exec();
};
All Qt GUI applications need to create one of these at the start of main().
We are only creating this to see how big it is.This is a stream that allows us to “write” to the string, similar in usage to std::stringstream.Create a GUI widget with the message.Make the label visible.
Enter the event loop, and wait for the user to do something. When the user exits, so does
myapp.exec().
T o build this app, we need a project file . A project file describes the project by list-
ing all of the other files, as well as all of the options and file locations that areneeded to build the project. Because this is a very simple application, the projectfile is also simple, as shown in Example 3.2.
EXAMPLE 3.2 src/qapp/qapp.pro
TEMPLATE = app
SOURCES += main.cpp
The first line, TEMPLATE = app , indicates that qmake should start with a tem-
plated Makefile suited for building applications. If this project file were for a
library, you would see TEMPLATE = lib to indicate that a Makefile library
template should be used instead. A third possibility is that we might have oursource code distributed among several subdirectories, each having its own projectfile. In such a case we might see  
TEMPLATE = subdirs in the project file located
in the parent directory, which would cause a Makefile to be produced in the par-
ent directory and also in each subdirectory.
3.2 Makefile, qmake, and Project Files
C++ applications are generally composed of many source files, header files, and
external libraries. During the normal course of project development, source filesand libraries get added, changed, or removed. During the testing/developmentphase, the project is recompiled and re-linked many times. T o produce an exe-cutable, all changed source files must be recompiled, and the object files must allbe re-linked.6543216543.2 MAKEFILE, QMAKE, AND PROJECT FILES
83ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 83
Keeping track of all of the parts of such a project requires a mechanism that
precisely specifies the input files involved, the tools needed to build, the interme-diate targets and their dependencies, and the final executable target.
The most widely used utility for handling the job of building a project is
make .
It reads the details of the project specifications and the instructions for the compiler
from aMakefile ,which resembles a shell script but contains (at a minimum):
■ Rules for building certain kinds of files (e.g., to get a . ofile from a .cpp
file, we must run gcc-c on the.cpp file)
■ Ta r g e t s that specify which executables (or libraries) must be built
■ Dependencies that list which targets need to be rebuilt when certain files
get changed
The make command by default loads the file named Makefile from your current
working directory and performs the specified build steps ( compiling and linking ).
The immediate benefit of using make is that it recompiles only the files that
need to be rebuilt, rather than blindly recompiling every source file every time.Figure 3.1 is a diagram that attempts to show the steps involved in building a Qtapplication. T o learn more about 
make , we recommend the book The Linux
Development Platform by Rafeeq Ur Rehman and Christopher Paul (Prentice Hall).CHAPTER 3: INTRODUCTION TO QT
84
qmake -project qapp.pro
qmake
libqapp.lib
libqapp.somake distgeneratesCreate Initial
qapp.tar.gz template=librebuild
makefile
if needed
qapp
template=appOther
Librariessources
headers
make, gmake,
or nmakeMakefile
FIGURE 3.1 (q)make build stepsezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 84
With Qt, it is not necessary to write Makefiles . Qt provides a tool called qmake
to generate Makefiles for you. It is still necessary to somehow run make and
understand its output. Most IDEs run make (or something similar) under the cov-
ers and either display or filter its output.
The following transcript shows which files get created at each step of the build
process for Example 3.1.
src/qapp> ls -sF
total 296
4 main.cpp    
src/qapp> qmake -project
src/qapp> ls -sF
total 296
4 main.cpp  4  qapp.pro
src/qapp> qmake
src/qapp> ls -sF
total 296
4 main.cpp  4 qapp.pro   4 Makefile
src/qapp> make3.2 MAKEFILE, QMAKE, AND PROJECT FILES
85
g++ -c -pipe -g -Wall -W             # compile step
-D_REENTRANT -DQT_CORE_LIB -DQT_GUI_LIB -DQT_SHARED-I/usr/local/qt/mkspecs/linux-g++ -I.-I/usr/local/qt/include/QtGui -I/usr/local/qt/include/QtCore-I/usr/local/qt/include -I. -I. -I. -o main.o main.cpp
g++ -Wl,-rpath,/usr/local/qt/lib     # link step   
-L/usr/local/qt/lib -L/usr/local/qt/lib -lQtGui_debug -L/usr/X11R6/lib -lpng -lXi -lXrender -lXinerama -lfreetype -lfontconfig -lXext -lX11 -lm -lQtCore_debug -lz -ldl -lpthread-o qapp main.o
src/qapp> ls -sF
total 420
4 main.cpp    132 main.o 124 qapp*
8 Makefile    4 qapp.pro            
src/qapp>                       
3.2.1 #include: Finding Header Files
There are three commonly used ways to #include a library header file:
#include <headerFile>
#include "headerFile"#include "path/to/headerFile"
The angle brackets (< >) indicate that the preprocessor must look (sequentially)
in the directories listed in the include path for the file.Notice that we can see the arguments passed to the compiler when we run make .
If any errors are encountered, we will see them too.ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 85
A quoted filename indicates that the preprocessor should look for
headerfile in the including file’s directory first. A quoted path indicates that
the preprocessor should check the path directory first. The path information canbe absolute or relative (to the including file’s directory). If no file is found at thespecified location, the directories listed  in the include path are searched for
headerfile .
If versions of the file exist in more than one directory in the include path, the
search will stop as soon as the first occurrence of the file has been found. If the fileis not found in any of the directories of the search path, then the compiler willreport an error.
For items in the C++ Standard Library, the compiler generally already knows
where to find the header files. For other libraries, we can expand the search pathby adding a 
-I/path/to/headerfile switch to the compiler.
If you use an IDE, there will be a Project->Settings->Preprocessor ,
or Project->Options->Libraries configuration menu that lets you specify
additional include directories, which end up getting passed as -Iswitches to the
compiler.
With qmake , as we will soon see, you can add INCLUDEPATH += dirname
lines to the project file. These directories end up in the generated Makefile as
INCPATH macros, which then get passed on to the compiler/preprocessor at build
time.
In general, it is a good idea to #include non-Qt header files after Qt
header files. Since Qt does define many symbols, in the compiler as well
as the preprocessor, this helps you avoid/find name clashes more easily.
3.2.2 The make Command
Instead of running the command line compiler directly, we will start using make ,2
which greatly simplifies the build process when a project involves multiple source
files and libraries.
We have seen before that qmake (without arguments) reads a project file and
builds a Makefile . Example 3.3 is a slightly abbreviated look at the Makefile
for the previous qapp project.CHAPTER 3: INTRODUCTION TO QT
86
2Depending on your development environment, this program goes under many other names, such as
mingw32-make ,nmake ,gmake ,o r  unsermake .ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 86
EXAMPLE 3.3 src/qapp/Makefile-abbreviated
# Excerpts from a makefile
####### Compiler, tools and optionsCC          = gcc     # executable for C compiler
CXX         = g++     # executable for c++ compilerLINK        = g++     # executable for linker3.2 MAKEFILE, QMAKE, AND PROJECT FILES
87
# flags that get passed to the compiler
CFLAGS = -pipe -g -Wall -W -D_REENTRANT $(DEFINES)CXXFLAGS = -pipe -g -Wall -W -D_REENTRANT $(DEFINES)INCPATH = -I/usr/local/qt/mkspecs/default -I. \
-I$(QTDIR)/include/QtGui -I$(QTDIR)/include/QtCore \-I$(QTDIR)/include
# Linker flags
LIBS = $(SUBLIBS) -L$(QTDIR)/lib -lQtCore_debug 
-lQtGui_debug -lpthread
LFLAGS = -Wl,-rpath,$(QTDIR)/lib
# macros for performing other operations as part of build steps:
QMAKE        = /usr/local/qt/bin/qmake
####### FilesHEADERS     =    # If we had some, they’d be here. 
SOURCES     = main.cppOBJECTS     = main.o[snip]QMAKE_TARGET = qappDESTDIR     = TARGET      = qapp  # default target to build
first: all           # to build "first" we must build "all"####### Implicit rules.SUFFIXES: .c .o .cpp .cc .cxx .C.cpp.o:
$(CXX) -c $(CXXFLAGS) $(INCPATH) -o $@ $<
## Possible targets to buildall: Makefile $(TARGET)  # this is how to build "all"$(TARGET):  $(OBJECTS) $(OBJMOC)    # this is how to build qapp
$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJMOC) $(OBJCOMP) \
$(LIBS)
continuedezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 87
qmake:  FORCE             # "qmake" is a target too! 
@$(QMAKE) -o Makefile qapp.pro  # what does it do?
dist:                                 # Another target 
@mkdir -p .tmp/qapp \
&& $(COPY_FILE) --parents $(SOURCES) $(HEADERS) \ 
$(FORMS) $(DIST) .tmp/qapp/ \ 
&&  (cd 'dirname .tmp/qapp' \ && $(TAR) qapp.tar qapp \ 
&& $(COMPRESS) qapp.tar) \ 
&& $(MOVE) 'dirname .tmp/qapp'/qapp.tar.gz . \ && $(DEL_FILE) -r .tmp/qapp
clean:compiler_clean                # yet another target
-$(DEL_FILE) $(OBJECTS)-$(DEL_FILE) *~ core *.core
####### Dependencies for implicit rules
main.o: main.cpp
The command make checks the dependencies and perfor ms each build step spec-
ified in the Makefile . The name and location of the final result can be set with
the project variables, TARGET and target.path .I fTARGET is not specified, the
name defaults to the name of the directory in which the project file is located. If
target.path is not specified, the location defaults to the directory in which the
project file is located.
3.2.3 Cleaning Up Files
make can clean up the generated files for you with the two targets clean and
distclean . Observe how they are different from the following code:
src/qapp> make clean
rm -f main.orm -f *~ core *.coresrc/qapp> ls
Makefile  main.cpp  qapp  qapp.pro
src/qapp> make distclean
rm -f qmake_image_collection.cpprm -f main.orm -f *~ core *.corerm -f qapprm -f Makefilesrc/qapp> ls
main.cpp  qapp.pro
After a make distclean , the only files that remain are the source files that
can go into a tarball for distribution.CHAPTER 3: INTRODUCTION TO QT
88ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 88
If you modify a project file since the last execution of make , the next
invocation of make should rebuild the Makefile itself (via qmake )
before re-running make on the newly generated Makefile .
In other words, the Makefile is qmake -aware and can re- qmake
itself.
The command make dist will create a tarball (dirname.tar.gz) that
contains all the source files that the project file knows about.
As we add more source-code, header, or library modules for our project, we edit
the .pro file and add the new items to the SOURCES ,HEADERS ,and LIBS lists. The
same documentation standards that apply to C++ source code should be appliedto project files (where comments begin with 
#).
We think of the project file as a map of our project, containing references to all
files and locations required for building our application or library. Like other
source code files, this is both human readable and machine readable. The .pro file
is the first place to look when we encounter “not found” or “undefined” messages dur-ing the build process (especially at link time) . For further details we recommend that
you read Trolltech’s guide to qmake.
3
3.3 Getting Help Online
In addition to the Trolltech Online Documentation,4which includes links to API
docs as well as FAQs,5there are many online resources available to you.
1. The Qt Interest Mailing List6provides a developer community and
searchable archives. Searching on a class you are trying to use, or an errormessage you do not understand, will often give you useful results.
2. QtCentre,
7a Web-based online community.
3. If it’s not directly related to Qt, and the error message is short and rare
enough, Google might even come up with interesting hits.
4. There is also a #qt irc channel on irc.freenode.net.3.3 GETTING HELP ONLINE
89
3http://trolltech.com/qmake-manual.html
4http://doc.trolltech.com
5http://www.trolltech.com/developer/faqs/
6http://lists.trolltech.com/qt-interest/
7http://www.qtcentre.org/ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 89
3.4 Style Guidelines and Naming Conventions
C++ is a powerful language that supports many different programming styles. The
coding style used in most Qt programs is not “pure” C++. Instead, it uses combi-nation of macros and preprocessor trickery to achieve a higher-level dynamic lan-guage that more closely resembles Java or Python than C++. In fact, to take fulladvantage of Qt’s power and simplicity, we tend to abandon the Standard Libraryentirely.
We find there are certain aspects to “Qt programming style” that are worth emu-
lating, and they are summarized here. For a more complete guide, see “DesigningQt-Style C++ APIs,” by Matthias Ettrich, published by Trolltech.
■Class names begin with a capital letter: class Customer
■Function names begin with a lowercase letter.
■Although permitted by the compiler, periods, underscores, dashes, andfunny characters should be avoided whenever possible (except where
noted below).
■Multi-word names have subsequent words capitalized: class
FileTaggervoidgetStudentInfo() for example.
■Constants should be in CAPS .
■Each class name should be a noun or a noun phrase: class
LargeFurryMammal; for example.
■Each function name should be a verb or a verb phrase:
processBookOrder(); for example.
■Each bool variable name should produce a reasonable approximation of
a sentence when used in an if() statement: boolisQualified; for
example.
For data members, we use a common prefix.
■Member name: m_Color, m_Width (prepend lowercase m_)
■static data members: sm_Singleton, sm_ObjCount
For each attribute, we have naming conventions for their corresponding
getters/setters.
■Non-boolean getters: color() or getColor()8
■Boolean getters: isChecked() or isValid()
■Setter:setColor(const Color& newColor); CHAPTER 3: INTRODUCTION TO QT
90
8The latter is Java style, the former is Qt style. Both conventions are widely used. Try to be consistent
in your code.ezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 90
A consistent naming convention greatly improves the readability and maintain-
ability of a program.
3.5 The Qt Core Module
Qt 4 is a library consisting of smaller libraries, or modules . The most popular ones
are 
■core—including QObject ,QThread ,QFile , and so forth
■gui—all classes derived from QWidget , and some related classes
■xml—for parsing and serializing XML 
■sql—for communicating with SQL databases
■net—for communicating data between hosts on specific protocols (http,tcp, udp)
Except for core, modules need to be “enabled” in qmake project files in order to be
used. For example:
QT += xml  # to use the xml module
QT += gui  # to use QWidgetsQT += sql  # to use SQL module
The following section will introduce some of the core library classes.
3.6 Streams and Dates
In subsequent examples, we use instances of QTextStream , which behave in a
similar way to the C++ Standard Library’s global iostream objects. We have
given them the familiar names: cin,cout,andcerr.For convenience, we have
placed these definitions, along with some other useful functions, into a namespaceso that they can be easily added to any program.
EXAMPLE 3.4 src/libs/utils/qstd.h
[ . . . . ]
namespace qstd {
extern QTextStream cin;extern QTextStream cout;extern QTextStream cerr;bool yes(QString yesNoQuestion);bool more(QString prompt);int promptInt(int base = 10);double promptDouble();13.6 STREAMS AND DATES
91
continuedezus_138004_ch03.qxd  8/4/06  9:37 AM  Page 91
void promptOutputFile(QFile& outfile);
void promptInputFile(QFile& infile);
[ . . . . ]
declared only—defined in the .cpp file
Example 3.4 declares the iostream-like QT extStreams, and Example 3.5 contains
the required definitions of these static objects.
EXAMPLE 3.5 src/libs/utils/qstd.cpp
[ . . . . ]
QTextStream qstd::cin(stdin, QIODevice::ReadOnly);
QTextStream qstd::cout(stdout, QIODevice::WriteOnly);
QTextStream qstd::cerr(stderr, QIODevice::WriteOnly);
<QTextStream> works with Unicode QStrings and other Qt types, so we will use
it in favor of <iostream> in most of our examples henceforth. The program in
Example 3.6 uses QTextStream objects and functions from the qstdnamespace
just described. It also uses some of the QDate member functions and displays dates
in several different formats.
EXAMPLE 3.6 src/qtio/qtio-demo.cpp
[ . . . . ]
int main() {
using namespace qstd;QDate d1(2002, 4,1), d2(QDate::currentDate());int days;cout << "The first date is: " << d1.toString()
<< "\nToday’s date is: "<< d2.toString("ddd MMMM d, yyyy")<< endl;
if (d1 < d2)
cout << d1.toString("MM/dd/yy") << " is earlier than "
<< d2.toString("yyyyMMdd") << endl;
cout << "There are " << d1.daysTo(d2)
<< " days between "<< d1.toString("MMM dd, yyyy") << " and "<< d2.toString(Qt::ISODate) << endl;
cout << "Enter number of days to add to the first date: "
<< flush;
days = promptInt();1CHAPTER 3: INTRODUCTION TO QT
92ezus_138004_ch03.qxd  8/4/06  9:38 AM  Page 92
cout << "The first date was " << d1.toString()
<< "\nThe computed date is "<<  d1.addDays(days).toString() << end1;
cout << "First date displayed in longer format: "
<<  d1.toString("dddd, MMMM dd, yyyy") << end1;
[ . . . . ]
Here is the output of this program.
The first date is: Mon Apr 1 2002Today’s date is: Wed January 4, 200604/01/02 is earlier than 20060104There are 1374 days between Apr 01, 2002 and 2006-01-04Enter number of days to add to the first date: : 1234
The first date was Mon Apr 1 2002The computed date is Wed Aug 17 2005First date displayed in longer format: Monday, April 01, 2002
EXERCISE: THE QT CORE MODULE
1.Write a birthday reminder application called birthdays . Classes to reuse are
QDate ,QFile ,QString ,QStringList , and QTextStream .
■ Store name/birthday pairs in any format you like, in a file called
birthdays.dat .
■birthdays with no command line arguments opens the file and lists all
birthdays coming up in the next 30 days, in chronological order.
■birthdays-a"johnsmith""yyyy-mm-dd" should add an entry to
the file.
■birthdays-n40 shows birthdays coming up in the next 40 days.
■birthdays namespec searches for the birthday paired with the name
namespec .
POINTS OF DEPARTURE
1. Visit the Unicode Web site. Explain what it is and why it is important
that QString supports the Unicode standard.
2. Explore the QString documentation. Explain what it means for a string
implementation to support the Unicode standard.
3. Look up make in the documentation. Discuss four useful command line
options for the make command.3.6 STREAMS AND DATES
93ezus_138004_ch03.qxd  8/4/06  9:38 AM  Page 93
CHAPTER 3: INTRODUCTION TO QT
94
REVIEW QUESTIONS
1. What is a project file? How can you produce one for your project?
2. What does the TEMPLATE variable mean in the qmake project file?
What are possible values?
3. What is a Makefile? How can you produce a Makefile for your project?ezus_138004_ch03.qxd  8/4/06  9:38 AM  Page 94
4.1 Introduction to Containers . . . . . . . . . . . . 96
4.2 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 974.3 Relationships . . . . . . . . . . . . . . . . . . . . . . . . . 994CHAPTER 4
Lists
Whenever possible, we use lists in favor of arrays.Thischapter explains ways of grouping things together in lists and how to iterate through them.
95ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 95
4.1 Introduction to Containers
There are many occasions when it is necessary to deal with collections of things.
The classic approach in languages like C is to use arrays to store such collections. InC++ arrays are regarded as evil. Here are a few good reasons to avoid using arrays.
■Array subscripts are not checked to make sure that they are not out ofrange. A programmer using an array has the responsibility to write extracode to do the range checking.
■Arrays are either fixed in size or they must use dynamic memory fromthe heap. With heap arrays, the programmer is responsible for makingsure that, under all possible cir cumstances, the memory gets properly
deallocated when the array is destroyed. T o do this properly requiresdeep knowledge of C++, exceptions, and what happens under excep-tional circumstances.
■Inserting, prepending, or appending elements to an array can be expen-sive operations (in terms of both run time and developer time).
The Standard Library and Qt both provide the programmer with lists that resize
themselves as needed and also perform range checking.
std::list and QList
are each considered basic generic containers in their respective libraries. They are
similar to each other in interface (the way they are used from client code), but very
different in implementation (the way they behave at runtime).
A generic container is named as such because
1. Generics are classes or functions that accept template (see Section 10.1)
parameters so that they can operate on any type.
2. Containers (see Section 10.2)  are objects that can contain other objects.
T o use a QList , the client code must contain a declaration that answers the ques-
tion: “List of what?” Like other generic containers, QList is a template class (see
Chapter 10) and must be declared in the following way.
QList<double>  doublList;
QList<Thing>  thingList;
ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 96
QList supports many operations. As with any class you reuse, it is recommended
that you scan the API docs to get an overview of its full capabilities. With a singlefunction call, items can be added, removed, swapped, queried, cleared, moved,located, and counted in a variety of ways.
4.2 Iterators
Any time you have a container of things, sooner or later you are probably going to
loop through the container and do something with each thing. An iterator is an
object that provides indirect access to each element in a container. It is specificallydesigned to be used in a loop.
Qt 4 supports the following styles of iteration:
1. Qt 4 style 
foreach loops, similar to Perl and Python
2. Java 1.2 style Iterator
3. Standard Library style ContainerType ::iterator
4. Hand-made while or for loops that use getters of the container
The next section demonstrates the various styles of iteration available in C++ with
Qt 4.
4.2.1 QStringList and Iteration
For text processing, it is very useful to work with lists of strings. QStringList
isderived from QList<QString> so it inherits all ofQList ’s behavior (see
Chapter 6). In addition, QStringList has some string-specific convenience
functions such as indexOf() ,join() , and replaceInStrings() .
Converting between lists and individual strings is quite easy with perl-like
split() and join() functions. Example 4.1 demonstrates lists, iterations,
split() , and join() .
EXAMPLE 4.1 src/collections/lists/lists-examples.cpp
#include <QStringList>
#include <QDebug>#include <cassert>
/* Some simple examples using QStringList, split and join */4.2 ITERATORS
97
continuedezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 97
int main() {
QString winter = "December, January, February";
QString spring = "March, April, May";QString summer = "June, July, August";QString fall = "September, October, November";
QStringList list;
list << winter;list += spring;list.append(summer);  list << fall;
qDebug() << "The Spring months are: " << list[1] ;QString allmonths = list.join(", "); 
/* from list to string - join with a ", " delimiter */qDebug() << allmonths;
QStringList list2 = allmonths.split(", ");  
/* split is the opposite of join. Each month will have itsown element. */
assert(list2.size() == 12);foreach (QString str, list)  {
qDebug() << QString(" [%1] ").arg(str);
}
for (QStringList::iterator it = list.begin();
it != list.end(); ++it) {     
QString current = *it;qDebug() << "[[" << current << "]]";
}
QListIterator<QString> itr (list2);
while (itr.hasNext()) {
QString current = itr.next();qDebug() << "{" <<  current << "}";
}
return 0;
}
append operator 1
append operator 2append member functionAssertions abort the program if the condition is not satisfied.Qt 4 foreach loop, similar to Perl/Python and Java 1.5 style for loops.C++ STL-style iterationpointer-style dereferenceJava 1.2 style iterator
Java iterators point in between elements.987654321987654321CHAPTER 4: LISTS
98ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 98
4.3 RELATIONSHIPS
99
4.3 Relationships
When there is a one-to-one or a one-to-many correspondence between objects
of certain types, we can describe a relationship between them in a UML class
diagram.
Employer
 - m_Name : QString
 - m_EmployeeList : QList<Person*> - m_OpeningList : QList<Position*>
+ hire(newHire : Person&, forPosition : Position) : bool
Person
 - m_Name : QString
 - m_Employed : bool
+ getPosition() : Position
+ getEmployer() : Employer+ getName() : QString+employer 1
* +m_employeeListsrc/collections> ./collections
The Spring months are: March, April, MayDecember, January, February, March, April, May, June, July, August,September, October, November
[December][January][February][March][April][May][June][July][August][September][October][November]
src/collections>
FIGURE 4.1 Simple relationship
In the relationship shown in Figure 4.1, we see a diamond on the Employer
side that can be read to mean “From the Employer , there is an employeeList
containing Persons .”ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 99
Since there could be many Person instances working for the Employer , there
is a *on the Person end of the relationship. This is a one to many relationship
between Employer and Person ,w h e r e  *takes on its regular expression defini-
tion, of “0 or more” of something (see Chapter 13).
Revisiting the company UML diagram from The Company Chart in Chapter 2,
Exercise 3, another set of relationships, as shown in Figure 4.2, is revealed when welook at the company from the 
Employer ’sviewpoint. These relationships areCHAPTER 4: LISTS
100
1. There is a composition relationship between Employer and
Position . This indicates that the Employer owns the Position , and
the Position should not exist without the Employer .
2. There is an aggregate relationship (the hollow diamond) from the
Employer to its employees. The Employer groups together a collec-
tion ofPerson s and gets them to do things during working hours. In an
aggregate relationship, the lifetimes of the objects on either end are not
related to each other.Employer
 - m_Name : QString
 - m_EmployeeList : QList<Person*> - m_OpeningList : QList<Position*>
+ hire(newHire : Person&, forPosition : Position) : bool
Person
 - m_Name : QString
 - m_Employed : bool
+ getPosition() : Position
+ getEmployer() : Employer+ getName() : QStringPosition
 - m_Name : QString
 - m_Description : QString
+ getEmployer() : Employeraggregation
associationComposition - Employer owns Position
*
1
1
FIGURE 4.2 The employer’s view of the companyezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 100
3. The Person and the Position have an association between them. An
association is a bidirectional relationship and does not specify anythingabout ownership or management between objects. Although our dia-gram indicates a 1:1 relationship between them, it is possible that other
Employer s many hire many Persons for the same Position .I n  s u c h
a case, the numbers should reflect that in the diagram.
EXERCISES: RELA TIONSHIPS
In these exercises you are to implement some relationships based on Figure 4.2.
The diagram is only a starting point—you will need to add some members to theclasses.
1.Implement the 
findJobs() function to look at an Employer , and get a list
of all open Position s.
2.Implement the apply() function to call Employer::hire() , and return the
same result as hire , if successful.
3.Have the Employer::hire() function randomly return false half of the
time, to make things interesting.
4.Create some more test Employer objects (Galactic Empire and Klingon
Empire),Person objects (Darth Vader, C3PO, Data), and Position objects
(Tie Fighter Pilot, Protocol Android, Captain) in your client code.
5.Make up some funny job application scenarios, and run your program to deter-
mine whether they are successful.
EXERCISES: CONTACT LIST4.3 RELATIONSHIPS
101
Contact
- category : int
- firstName : QString- lastName : QString- streetAddress : QString- zipCode : QString- city : QString- phoneNumber : QString
+ toString() : QStringContactList
+ add(c : Contact)
+ remove(c : Contact)+ getPhoneList(category : int) : QStringList+ getMailingList(category : int) : QStringList
1.This UML diagram describes a data model for a contact system. ContactList
can derive from or reuse any Qt container that you wish, as long as it supports
the operations listed.ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 101
■getPhoneList(int category) accepts a value to be compared with
a Contact ’s category member for selection purposes. It returns a
QStringList containing, for each selected Contact , the name and
phoneNumber, separated by the tab symbol: "\t" .
■getMailingList() has a similar selection mechanism and returns a
QStringList containing address label data.
2.Write aContactFactory class that generates random Contact s. Example 4.2
contains a substantial hint.
EXAMPLE 4.2 src/containers/contact/testdriver.cpp
[ . . . . ]
void createRandomContacts(ContactList& cl, int n=10) {
static ContactFactory cf;for (int i=0; i<n; ++i) {
cf >> cl;
}
}
adds a Contact into the ContactList
There are many ways to generate random names/addresses. One way is to have
the ContactFactory create lists of typical first names, last names, street
names, city names, and so forth. When it is time to generate a contact, it can picka random element from each list, add randomly generated address numbers,zip codes, and so on. We demonstrate the use of the random function in“Exercise: C++ Simple Types” in Chapter 1.
3.Write client code to test your classes. In particular, the client code should gen-
erate some random contacts, try out the queries, and print the original list, aswell as the query results, to the standard output. Summarize the results by list-ing the number of elements in the original 
ContactList compared to the
query results.
POINTS OF DEPARTURE
1. Read the API docs for QList and find three distinct ways of adding ele-
ments to the list.
2. List three methods that exist in QStringList but are not in QList .
3. Why does QList have an iterator and an Iterator ? What is the
difference between them?11CHAPTER 4: LISTS
102ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 102
REVIEW QUESTIONS
103
REVIEW QUESTIONS
1. What is an iterator?
2. Draw a UML diagram with three or more classes that have at least one
of each kind of relationship: aggreg ation and composition. The classes
should represent real-world concepts, and the relationships shouldattempt to represent reality. Write a couple of paragraphs explaining whythere is a relationship of each kind there.ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 103
ezus_138004_ch04.qxd  8/4/06  9:38 AM  Page 104
5.1 Function Declarations . . . . . . . . . . . . . . . 106
5.2 Overloading Functions . . . . . . . . . . . . . . 1075.3 Optional Arguments . . . . . . . . . . . . . . . . 1095.4 Operator Overloading . . . . . . . . . . . . . . 1115.5 Parameter Passing by Value . . . . . . . . . 1165.6 Parameter Passing by Reference . . . . . 1185.7 References to const . . . . . . . . . . . . . . . . . 1215.8 Function Return Values . . . . . . . . . . . . . 1225.9 Returning References from 
Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 122
5.10 Overloading on const-ness . . . . . . . . . . 1245.11 Inline Functions . . . . . . . . . . . . . . . . . . . . 1265.12 Inlining versus Macro Expansion . . . . . 1275CHAPTER 5
Functions
In this chapter we discuss the essentials of functiondeclarations, prototypes, and signatures; overloadingfunctions; function call resolution; default/optionalarguments; temporary variables and when they’recreated; reference parameters and return values; andinline functions.
105ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 105
5.1 Function Declarations
Functions in C++ are very similar to functions and subroutines in other lan-
guages. C++ functions, however, support many features that are not found insome languages, so it is worthwhile discussing each of them here. Each functionhas:
1. A name
2. A return type (which may be void)3. A parameter list (which may be empty)4. A body (a group of statements)
The first three are the function’s interface, and the last is the implementation.
A function must be declared before it is used for the first time. The mechanism
for declaring a function is called a function prototype. A function prototype is a
declaration that must include
■The function’s return type
■The function’s name
■An ordered, comma separated list of the types of the function’sparameters
Here are a few prototypes.
int toCelsius(int fahrenheitValue);
QString toString();int main(int argc, char* argv[]);
Even though parameter names are optional in function prototypes, it is good pro-
gramming practice to use them. They constitute a very effective and efficient partof the documentation for a program. Furthermore, many documentation genera-tors (e.g., kdoc) require them.
A simple example can help to show why parameter names should be used in
function prototypes. Suppose we needed a constructor for a 
Date class that we
designed and we wanted that constructor to initialize the Date with values for
the year, month, and day. If we presented the prototype as Date(int ,int ,int) ,
the user of that class would not know immediately what order to list the three
ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 106
values when constructing a Date object. Since several of the possible orderings are
in common use somewhere on the planet, there is no “obvious” answer that wouldeliminate the need for more information. By simply naming the parameters theproblem is eliminated and the function has documented itself.
In multi-file applications, function prototypes are usually stored in header
files.
5.2 Overloading Functions
The signature of a function consists of its name and its parameter list. In C++, the
return type is notpart of the signature.
C++ permits overloading of function names. A function name is overloaded
if it has more than one meaning within a given scope. Overloading occurs whentwo or more functions within a given scope have the same name but differentsignatures. It is an error to have two functions in the same scope with the samesignature but different return types.
Function Call Resolution
When a function call is made to an ov erloaded function within a given scope,
the C++ compiler determines from the arguments which version of the functionto invoke. T o do this, a match must be found between the number and type of thearguments and the signature of exactly one of the overloaded functions. This is thesequence of steps that the compiler takes to  determine which overloaded function
to call.
1. If there is an exact match with one function, call it.
2. Else, match through standard type promotions (see Section 19.5).3. Else, match through conversion constructors or conversion operators
(see Section 2.12).
4. Else, match through ellipsis (
...) (see Section 24.1), if found
5. Else, report an error.
Example 5.1 shows a class with six member functions, each with a distinct signa-
ture. Keep in mind that each function has an additional implicit parameter: this .
The keyword const , following the parameter list, protects the host object from
the action of the function and is part of its signature.5.2 OVERLOADING FUNCTIONS
107ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 107
EXAMPLE 5.1 src/functions/function-call.cpp
[ . . . . ]
class SignatureDemo {
public:
SignatureDemo(int val) : m_Val(val) {}void demo(int n)
{cout << ++m_Val << "\tdemo(int)" << endl;}
void demo(int n) const
{cout << m_Val << "\tdemo(int) const" << endl;}
/*  void demo(const int& n)   
{cout << ++m_Val << "\tdemo(int&)" << endl;}  */
void demo(short s)  
{cout << ++m_Val << "\tdemo(short)" << endl;}
void demo(float f)  
{cout << ++m_Val << "\tdemo(float)" << endl;}
void demo(float f) const 
{cout << m_Val << "\tdemo(float) const" << endl;}
void demo(double d)
{cout << ++m_Val << "\tdemo(double)" << endl;}
private:
int m_Val;
};
overloaded on const-ness
clashes with previous function
Example 5.2 contains some client code that tests the overloaded functions from
SignatureDemo .
EXAMPLE 5.2 src/functions/function-call.cpp
[ . . . . ]
int main() {
SignatureDemo sd(5);const SignatureDemo csd(17);sd.demo(2);    csd.demo(2);  int i = 3;sd.demo(i);short s = 5;sd.demo(s);csd.demo(s);  sd.demo(2.3);  float f(4.5);   sd.demo(f);csd.demo(f);    csd.demo(4.5);  return 0;
}
3212121CHAPTER 5: FUNCTIONS
108ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 108
const version is called.
Non-const short cannot be called, so a promotion to int is required to call the const int version.
This is double, not float.
The output should look something like this:
6       demo(int)
17      demo(int) const7       demo(int)8       demo(short)17      demo(int) const9       demo(double)10      demo(float)17      demo(float) const
EXERCISES: OVERLOADING FUNCTIONS
1.Experiment with Example 5.1. Start by uncommenting the third member func-
tion and compiling.
2.Try adding the following line just before the end of main() :
csd.demo(4.5);
What happened? Explain the error message.
3.Add other function calls and other variations on the demo() function.
Explain each result.
5.3 Optional Arguments
Function parameters can have default values, making them optional. The default
value for an optional argument can be a constant expression or an expression thatdoes not involve local variables.
Parameters with default arguments must be the right-most (trailing) parame-
ters in the parameter list.
Trailing arguments with default values can be left out of the function call. The
corresponding parameters will then be initialized with the default values.
From the viewpoint of the function, if it is called with one missing argument,
then that argument must correspond to the last parameter in the list. If two argu-ments are missing, they must correspond to the last two parameters in the list (andso forth).
Because an optional argument specifier applies to a function’s interface, it
belongs with the declaration, not the defin ition of the function if the declaration
is kept in a separate header file.3215.3 OPTIONAL ARGUMENTS
109ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 109
A function with default arguments can be called in more than one way. If all
arguments for a function are optional, the function can be called with no argu-ments. Declaring a function with 
noptional arguments can be thought of as an
abbreviated way of declaring n+1 functions, one for each possible way of calling
the function.
In Example 5.3 the constructor for the Date class has three parameters; each
parameter is optional and defaults to 0.
EXAMPLE 5.3 src/functions/date.h
[ . . . . ]
class Date {public:
Date(int d = 0, int m = 0, int y = 0);void display(bool eoln = true) const;
private:
int m_Day, m_Month, m_Year;
};
[ . . . . ]
The constructor definition shown in Example 5.4 looks the same as usual; no
default arguments need to be specified there.
EXAMPLE 5.4 src/functions/date.cpp
#include <QDate>
#include "date.h"#include <iostream>
Date::Date(int d , int m , int y ) 
: m_Day(d), m_Month(m), m_Year(y) {
static QDate currentDate = QDate::currentDate();if (m_Day == 0) m_Day = currentDate.day(); 
if (m_Month == 0) m_Month = currentDate.month();if (m_Year == 0) m_Year = currentDate.year();
}
void Date::display(bool eoln) const {
using namespace std;cout << m_Year << "/" << m_Month << '/' << m_Day;if (eoln)
cout << endl;
}
We use Qt’s QDate class only to get the current date.11CHAPTER 5: FUNCTIONS
110ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 110
If 0 is the actual value of any of the supplied arguments, it will be replaced with a
sensible value, derived from the current date.
EXAMPLE 5.5 src/functions/date-test.cpp
#include "date.h"
#include <iostream>
int main() {
using namespace std;Date d1;Date d2(15);Date d3(23, 8);Date d4(19, 11, 2003);
d1.display(false);
cout << '\t';d2.display();d3.display(false);cout << '\t';d4.display();return 0;
}
The client code in Example 5.5 demonst rates that by defining default values we
are, in effect, overloading the function. The different versions of the function exe-cute the same code, but with different values passed in for the later parameters.
So if we ran this program on November 26, 2005, it should show us this in the
output:
src/functions> qmake
src/functions> make
[ compiler linker messages ] src/functions> ./functions
11/26/2005      11/15/20058/23/2005       11/19/2003src/functions>    
5.4 Operator Overloading
The keyword operator is used in C++ to define a new meaning for an operator
symbol such as +,-,=,*,&, and so forth. Adding a new meaning to an opera-
tor symbol is a specialized form of function overloading.5.4 OPERATOR OVERLOADING
111ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 111
Operator overloading provides a more compact syntax for calling functions,
which can lead to more readable code (assuming the operators are used in waysthat are commonly understood).
It is possible to overload nearly al l of the existing operator symbols in C++.
For example, suppose that we want to define a class named 
Complex to represent
complex numbers.1T o specify how to do the basic arithmetic operations with
these objects we could overload the f our arithmetic operator symbols. While we
are at it, we could also overload the insertion symbol so that output statementsbecome more readable.
Example 5.6 shows a class definition with both members and non-member
operators.
EXAMPLE 5.6 src/complex/complex.hCHAPTER 5: FUNCTIONS
112
1Complex numbers were introduced initially to  describe the solutions to equations such as x2–
6x + 25 = 0 . Using the quadratic formula one can easily determine that the roots of this equation
are 3 + 4i and 3 – 4i . The complex numbers consist of all numbers of the form a + bi ,w h e r e
aand bare real numbers and iis the square root of –1. Since that set includes such numbers for which
b= 0, it is clear that the real numbers are a subset of the complex numbers.#include <iostream>
using namespace std;
class Complex {
// binary non-member friend function declarationsfriend ostream& operator<<(ostream& out, const Complex& c);friend Complex operator-(const Complex& c1, const Complex & c2);friend Complex operator*(const Complex& c1, const Complex & c2);friend Complex operator/(const Complex& c1, const Complex & c2);
public:
Complex(double re = 0.0, double im = 0.0);
// binary member function operators
Complex& operator+= (const Complex& c);Complex& operator-= (const Complex& c);
Complex operator+(const Complex & c2);
1
private:
double m_Re, m_Im;
};
This should be a non-member friend like the other non-mutating operators.1ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 112
The operators declared in Example 5.6 are all binary (accept 2 operands). For the
member functions, there is only one formal parameter because the first (left)operand is implicit:
*this . The member operators definitions are shown in
Example 5.7.
EXAMPLE 5.7 src/complex/complex.cpp
[ . . . . ]
Complex& Complex::operator+=(const Complex& c) {
m_Re += c.m_Re;m_Im += c.m_Im;return *this;
}
Complex Complex::operator+(const Complex& c2) {
return Complex(m_Re + c2.m_Re, m_Im + c2.m_Im);
}
Complex& Complex::operator-=(const Complex& c) {
m_Re -= c.m_Re;m_Im -= c.m_Im;return *this;
}
Example 5.8 shows the definitions of the non-member friend functions. They are
defined like ordinary global functions.
EXAMPLE 5.8 src/complex/complex.cpp
[ . . . . ]
ostream& operator<<(ostream& out, const Complex& c) {
out << '(' << c.m_Re << ',' << c.m_Im << ')' ;return out;
}
Complex operator-(const Complex& c1, const Complex& c2) {
return Complex(c1.m_Re - c2.m_Re, c1.m_Im - c2.m_Im);
}
We have expressed the mathematical rules that define each of the four algebraic
operations in C++ code. These details are encapsulated and hidden so that clientcode does not need to deal with them. Example 5.9 shows some client code thatdemonstrates and tests the 
Complex class.5.4 OPERATOR OVERLOADING
113ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 113
EXAMPLE 5.9 src/complex/complex-test.cpp
#include "complex.h"
#include <iostream>
int main() {
using namespace std;Complex c1(3.4, 5.6);Complex c2(7.8, 1.2);
cout << c1 << " + " << c2 << " = " << c1 + c2 << endl;
cout << c1 << " - " << c2 << " = " << c1 - c2 << endl;Complex c3 = c1 * c2;cout << c1 << " * " << c2 << " = " << c3 << endl;cout << c3 << " / " << c2 << " = " << c3 / c2 << endl;cout << c3 << " / " << c1 << " = " << c3 / c1 << endl;
return 0;
}
Here is the output of the program in Example 5.9:
(3.4,5.6) + (7.8,1.2) = (11.2,6.8)
(3.4,5.6) - (7.8,1.2) = (-4.4,4.4)(3.4,5.6) * (7.8,1.2) = (19.8,47.76)(19.8,47.76) / (7.8,1.2) = (3.4,5.6)(19.8,47.76) / (3.4,5.6) = (7.8,1.2)
Member versus Global Operators
As we have seen, it is possible to overload operators as member functions, or
as global functions. The primary difference that you will notice first is howthey can be called. In particular, a member function operator requires an
object as the left operand. A global function, in contrast, permits the samekinds of type conversions for either operand.
Example 5.10 shows why 
Complex::operator+() would be better
suited as a non-member function.
EXAMPLE 5.10 src/complex/complex-conversions.cpp
#include "complex.h"
int main() {
Complex c1 (4.5, 1.2);Complex c2 (3.6, 1.5);CHAPTER 5: FUNCTIONS
114ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 114
Complex c3 = c1 + c2;
Complex c4 = c3 + 1.4;Complex c5 = 8.0 - c4;Complex c6 = 1.2 + c4;
}
Right operand is promoted.
Left operand is promoted.
Error: Left operand is not promoted for member operators.3213215.4 OPERATOR OVERLOADING
115
There are some limitations on operator ov erloading. Only built-in operators can be
overloaded. It is not possible to introduce definitions for symbols such as $,",or '
that do not already possess operator definitions. Although new meanings can be
defined for built-in operators, their associativity and precedence remain the same.
It is possible to overload all of the built-in binary and unary operators except
for these:
■The ternary conditional operator testExpr ? valueIfTrue :
valueIfFalse
■Scope resolution operator ::
■Member select operators .and .*
Here is one way to remember which operators can be overloaded: If it
has a dot in it (.) anywhere, it’s probably not allowed.
Overloading the comma operator is allowed, but not recommended
until you are a C++ expert.
We have provided a complete table of operator symbols and their characteristics
in Section 19.1.ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 115
EXERCISES: OPERA TOR OVERLOADING
1.Continue the development of the Fraction class by adding overloaded oper-
ators for addition, subtraction, multiplication, division, and various kinds of com-parison. In each case the parameter should be a 
const Fraction& .W r i t e
client code to test your new operators.
2.To be really useful, a Fraction object should be able to interact with other
kinds of numbers. Expand the definition of Fraction so that the operators in
Exercise 1 also work for int and double . It should be clear, for example, how
to get frac + num to be correctly evaluated. How would you handle the
expression num+frac , where frac is a Fraction and num is an int ? Write
client code to test your new functions.
3.Add arithmetic and comparison operators to the class Complex . Write client
code to test your expanded class.
5.5 Parameter Passing by Value
By default, C++ parameters are passed by value. When a function is called, a tem-
porary (local) copy of each argument object is made and placed on the programstack. Only the local copy is manipulated inside the function, and the argumentobjects from the calling block are not affected by these manipulations. The tem-
porary stack variables are all destroyed when the function returns. A useful way tothink of value parameters is this: V alue parameters are merely local variables that
are initialized by copies of the corresponding argument objects that are specifiedwhen the function is called. Example 5.11 gives a short demonstration.
EXAMPLE 5.11 src/functions/summit.cpp
#include <iostream>
int sumit(int num) {
int sum = 0;for (; num ; --num)  
sum += num;
return sum;
}
int main() {
using namespace std;int n = 10;cout << n  << endl;cout << sumit(n) << endl;cout << n << endl; return 0;
}
21CHAPTER 5: FUNCTIONS
116ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 116
Output:
10
5510
The parameter gets reduced to 0.
See what sumit() did to n.
If a pointer is passed to a function, a temporary copy of that pointer is placed on
the stack. Changes to that pointer will have no effect on the pointer in the callingblock. For example, the temporary pointer could be assigned a different value (seeExample 5.12).
EXAMPLE 5.12 src/functions/pointerparam.cpp
#include <iostream>
using namespace std;
void messAround(int* ptr) {
*ptr = 34;ptr = 0;
}
int main() {
int n(12);     int* pn(&n);    cout << "n = " << n << "\tpn = " << pn << endl;messAround(pn);  cout << "n = " << n << "\tpn = " << pn << endl;return 0;
}
Output:
n = 12  pn = 0xbffff524
n = 34  pn = 0xbffff524
Change the value that is pointed to.
Change the address stored by ptr.Initialize an int.Initialize a pointer that points to n.
See what is changed by messAround().
In the output we display the hexidecimal value of the pointer pnas well as the
value ofnso that there can be no doubt about what was changed by the action of
the function.5432154321215.5 PARAMETER PASSING BY VALUE
117ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 117
5.6 Parameter Passing by Reference
Large objects, or objects with expensive copy constructors, should not be passed
by value because the creation of temporary copies consumes time, machine cycles,and memory needlessly. In C, we passed objects by pointer to avoid copying them.However, using pointers requires a different syntax from using regular variables.Further, accidental misuse of pointers can cause data corruption, leading to run-time errors that can be very difficult to find and fix. In C++ (and C99), we can passby reference, which offers the same performance as a pointer-pass. With objects,this permits use of the 
(.) operator for accessing members.
A reference parameter is simply a parameter that is an alias for something else.
T o declare a parameter to be a reference, put the ampersand character (&) betweenthe type name and the parameter name.
A reference parameter of a function is initialized by the actual argument being
passed when the function is called. That argument must be, as with any reference,a non-
const lvalue. Changes to a non-const reference parameter in the function
cause changes to the actual object used to initialize the parameter. This feature isoften exploited to allow functions, which can return at most one value, to causechanges in several objects, effectively allowing the function to return several values.Example 5.13 shows how reference parameters can be used with integers.
EXAMPLE 5.13 src/reference/swap.cpp
#include <iostream>
using namespace std;
void swap(int &a, int &b) {
int temp = a;cout << "Inside the swap() function:\n"
<< "address of a: " << &a<< "\taddress of b: " << &b<< "\naddress of temp: " << &temp << endl;
a = b;b = temp;
}
int main() {
int n1 = 25;int n2 = 38;int n3 = 71;int n4 = 82;cout << "Initial values:\n"
<< "address of n1: " << &n1<< "\taddress of n2: " << &n2<< "\nvalue of n1: " << n1<< "\t\t\tvalue of n2: " << n2CHAPTER 5: FUNCTIONS
118ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 118
<< "\naddress of n3: " << &n3
<< "\taddress of n4: " << &n4<< "\nvalue of n3: " << n3<< "\t\t\tvalue of n4: " << n4<< "\nMaking the first call to swap()" << endl;
swap(n1,n2);cout << "After the first call to swap():\n"
<< "address of n1: " << &n1<< "\taddress of n2: " << &n2<< "\nvalue of n1: " << n1<< "\t\t\tvalue of n2: " << n2<< "\nMaking the second call to swap()" << endl;
swap(n3,n4);cout << "After the second call to swap():\n"
<< "address of n3: " << &n3<< "\taddress of n4: " << &n4<< "\nvalue of n3: " << n3<< "\tvalue of n4: " << n4 << endl;
return 0;
}
There are extra output statements in Example 5.13 to help keep track of the
addresses of the important variables.
Initial values:
address of n1: 0xbffff3b4       address of n2: 0xbffff3b0value of n1: 25                value of n2: 38address of n3: 0xbffff3ac       address of n4: 0xbffff3a8value of n3: 71                value of n4: 82
Initially our stack might look something like Figure 5.1:5.6 PARAMETER PASSING BY REFERENCE
119
As the program proceeds, we will see output like this:
Making the first call to swap()
Inside the swap() function:address of a: 0xbffff3b4        address of b: 0xbffff3b0address of temp: 0xbffff394
When references get passed to functions, the values that get pushed onto the stack
are addresses , not values. Under the covers, pass-by-reference is very much like
pass-by-pointer. Our stack now might look like Figure 5.2:FIGURE 5.1 Before first swap()25
387182Stack
0xbffff3a8
Before first swap()n1
n2n3n4ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 119
CHAPTER 5: FUNCTIONS
120
After the first call to swap():
address of n1: 0xbffff3b4        address of n2: 0xbffff3b0value of n1: 38                 value of n2: 25Making the second call to swap()Inside the swap() function:
Now our stack might look like Figure 5.3:Stack
inside first swap()0xbffff394
0xbffff3b4int main()
{
int n1, n2, n3, n4;cout << "initial values..."swap(n1, n2);cout << "after first call.."swap(n3, n4);cout << "after second call..."
}25
0xbffff3b40xbffff3b0[retaddrs]25387182 0xbffff3a8
Stack
inside second swap()0xbffff394
0xbffff3b4int main()
{
int n1, n2, n3, n4;cout << "initial values..."swap(n1, n2);cout << "after first call.."swap(n3, n4);cout << "after second call..."
}71
0xbffff3ac0xbffff3a8[retaddrs]38257182
0xbffff3a8
address of a: 0xbffff3ac        address of b: 0xbffff3a8
address of temp: 0xbffff394After the second call to swap():address of n3: 0xbffff3ac       address of n4: 0xbffff3a8value of n3: 82 value of n4: 71
The swap() function is actually working with n1and n2during the first call and
with n3and n4during the second call.
Pass-by-reference is an alternate syntax for passing by pointer. Under the
covers, it is implemented the same way (i.e., the value is not copied). The maindifference between pass-by-pointer and pass-by-reference is that you must de-ref-erence a pointer, while a reference is accessible in the same way as the referred“thing.”FIGURE 5.2 Inside first swap()
FIGURE 5.3 Inside second swap()ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 120
PASS-BY-POINTER OR PASS-BY-REFERENCE? When you have a
choice, it is generally preferable to use references instead of pointersbecause this can reduce the number of places where a programmer canaccidentally corrupt memory. It is only when you need to manageobjects (creation, destruction, adding to a managed container) that youneed to operate on pointers, and those routines can usually be encapsu-
lated as member functions.
5.7 References to const
Declaring a reference parameter to be const tells the compiler to make sure that
the function does not attempt to change that object. For objects larger than apointer, a reference to 
const is an efficient alternative to a value parameter
because no data is copied. Example 5.14 contains three functions, each acceptinga parameter in a different way.
EXAMPLE 5.14 src/const/reference/constref.cpp
class Person {
public:
void setNameV( QString newName) {
newName += " Smith";m_Name = newName;
}
void setNameCR( const QString& newName) {
//      newName += " Python";
m_Name = newName;
}void setNameR( QString& newName) {
m_Name += " Dobbs";m_Name = newName;
}
private:
QString m_Name;
};
int main() {
Person p;QString name("Bob");p.setNameCR(name);
//  p.setNameR("Monty");
p.setNameCR("Monty");
6543215.7 REFERENCES TO CONST
121
continuedezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 121
p.setNameV("Connie");
p.setNameR(name);cout << name;
}
Changes a temporary that’s about to be destroyed.
Error: Can’t change const&.Changes the original Qstring.No temporaries are created.Error: Cannot convert to a QString&.char* converts to temporary and gets passed by const reference.
Temporary QString #1 is created to convert char* to QString. Temporary #2 is created when itis passed by value.
No temporaries are created.
5.8 Function Return Values
Some functions return a value when they have finished performing the task for
which they were designed. Space for a temp orary return object is usually a regis-
ter (if it can fit), but sometimes it is an obje ct allocated on the stack. The tempo-
rary return object is initialized when the return statement is executed and exists
just long enough to be used in whatever expression contains the function call. It isgenerally a copy of an object that is local to the function or an object constructedfrom an expression in the 
return statement.
5.9 Returning References from Functions
Sometimes it can be very useful to design a function so that it returns a reference.
For example, when we overload the insertion operator, operator<<(ostream&,
NewType) ,we always return a reference to the output stream. This makes it possi-
ble to chain operations like this:
cout << thing1 << thing2 << thing3 ... ;
A reference return (especially of *this ) is used to provide lvalue behavior for
member functions.
As with reference parameters, it is possible to protect a reference return by
specifying that the object it aliases is const.
Example 5.15 captures the essence of reference returns.8765432187CHAPTER 5: FUNCTIONS
122ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 122
EXAMPLE 5.15 src/reference/maxi.cpp
#include <iostream>
using namespace std;
int& maxi(int& x, int& y) { 
return (x > y) ? x : y;
}
int main() {
int a = 10, b = 20;maxi(a,b) = 5;maxi(a,b) += 6;++maxi(a, b) ;cout << a << '\t' << b << endl;return 0;
}
Output:
17      5
Assigns the value 5 to b.
Increases a by 6. a is now 16.
Increments a by 1.
As we see in the main() function, the reference return value of the function
maxi() makes the expression maxi(a,b) into a modifiable lvalue .
Be very careful that your function does not return a reference to a tem-
porary (local) object. A moment’s thought should make that restriction
clear: When the function returns, all of its local variables are destroyed.
int& max(int i,int j) {
int retval = i > j ? i : j;
return retval;
}
Code like the above may generate a compiler warning (if you are lucky). Alas, the
compiler does not consider it an error.
badmax.cpp:4: warning: reference to local variable 'retval' returned
A more practical example showing the benefits of reference returns is coming upin Example 5.16, which defines some common operators for vectors.3213215.9 RETURNING REFERENCES FROM FUNCTIONS
123ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 123
5.10 Overloading on const-ness
const changes the signature of a member function. This means that functions
can be overloaded on const-ness. Example 5.16 shows a homemade vector classwith member functions overloaded in this way.
EXAMPLE 5.16 src/const/overload/constoverload.h
#ifndef CONSTOVERLOAD_H
#define CONSTOVERLOAD_H
#include <iostream>class Point3 {
public:
friend std::ostream& operator<<(std::ostream& out, constPoint3& v);
Point3(double x = 0, double y = 0, double z = 0);double& operator[](int index);    const double& operator[](int index) const;Point3 operator+(const Point3& v) const;Point3 operator-(const Point3& v) const;Point3 operator*(double s) const;
private:
static const int cm_Dim = 3;double m_Coord[cm_Dim];
};
#endif
a 3D point (of double)
overloaded on const-ness
scalar multiplication321321CHAPTER 5: FUNCTIONS
124
EXERCISES: OVERLOADING ON CONST-NESS
1.In Example 5.17, the compiler can tell the difference between calls to the const
and to the non- const versions of operator[] based on the const -ness of
the object.ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 124
EXAMPLE 5.17 src/const/overload/constoverload-client.cpp
#include "constoverload.h"
#include <iostream>
int main( ) {
using namespace std;Point3 pt1(1.2, 3.4, 5.6);const Point3 pt2(7.8, 9.1, 6.4);double d ;d = pt2[2];cout << d << endl;d = pt1[0];cout << d << endl;d = pt1[3];cout << d << endl;pt1[2] = 8.7;cout << pt1 << endl;//  pt2[2] = 'd';cout << pt2 << endl;return 0;
}
__________
____________________
__________
a. Which operator is called for each of the notes?
b. Why is the last assignment commented out?
c.The operator function definitions are shown in Example 5.18. The fact that
the two function bodies are identical is worth pondering. If index is in
range, each function returns m_Coord[index] , so what is the difference
between them?
EXAMPLE 5.18 src/const/overload/constoverload.cpp
[ . . . . ]
const double& Point3::operator[](int index) const {
if ((index >= 0) && (index < cm_Dim))
return m_Coord[index];
else
return zero(index);
}432143215.10 OVERLOADING ON CONST-NESS
125
continuedezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 125
double& Point3::operator[](int index) {
if ((index >= 0) && (index < cm_Dim))
return m_Coord[index];
else
return zero(index);
}
[ . . . . ]
5.11 Inline Functions
T o avoid the overhead associated with a function call (creation of a stack frame
containing copies of arguments or addresses of reference parameters and thereturn address) C++ permits you to declare functions to be 
inline . Such a dec-
laration is a request to the compiler that it replace each call to the function with the
fully expanded code of the function. For example:
inline int max(int a, int b){
return a > b ? a : b ;
}
int main(){
int temp = max(3,5);
etc....
}
The compiler could substitute the expanded code for max as shown here.
int main() {
int temp;  {
int a = 3;int b = 5;temp = a > b ? a : b;
}etc.......
}
The inlining of a function can give a significant boost in performance if it is called
repeatedly (e.g., inside a large loop). The penalty for inlining a function is that itmight make the compiled code larger, which will cause the program to use morememory while it is running. For small functions that get called many times, thatmemory effect will be small while the potential performance gain might be large.
There are no simple answers to the question of whether inlining will improve
the performance of your program or not. A lot depends on the optimization set-tings of the compiler. A lot depends on the nature of the program. Does it makevery heavy use of the processor? Does it make heavy use of system memory? DoesCHAPTER 5: FUNCTIONS
126ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 126
it spend a lot of its time interacting with slow devices (e.g., input and output)? The
answers to these questions affect the answer to the question of whether or not to
inline , and we leave them to a more advanced treatment of the subject. For an
overview of the complexity of this issue, visit Marshall Cline’s FAQ Lite site.2
An inline function is similar to a #define macro with one very important
difference: The substitution process for a #define macro is handled by the pre-
processor, which is essentially a text editor. The substitution process for an
inline function is handled by the compiler, w hich will perform the operation
much more intelligently with proper type checking. We discuss this in more detailin the next section.
Some Rules about Inline Functions
■An inline function must be defined before it is called (a declaration is not
enough).
■An inline definition can only occur once in any source code module.
■If a class member function’s definition appears inside the class definition,the function is implicitly inline.
If a function is too complex, or the compiler options are switched, the com-
piler may ignore the 
inline directive. Most compilers refuse to inline func-
tions that contain:
■while, for, do . . . while statements
■switch statements
■More than a certain number of lines of code
If the compiler does refuse to inline a function, it treats it as a normal func-
tion and generates regular function calls.
5.12 Inlining versus Macro Expansion
Macro expansion is a mechanism for placing code inline by means of the follow-
ing preprocessor directive.
#define MACRO_ID expr
This is very different from an inline function.5.12 INLINING VERSUS MACRO EXPANSION
127
2http://snet.wit.ie/GreenSpirit/c++-faq-lite/inline-functions.htmlezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 127
Macro expansion provides no type checking for arguments. It is essentially an
editing operation: Each occurrence of MACRO_ID is replaced by expr . Careful use
of parentheses in macros is necessary to avoid precedence errors. But parentheseswon’t solve all the problems associated with macros, as we will see in Example 5.19.Errors caused by macros can lead to very strange (and unclear) compiler errors. Or,more dangerously, it can lead to invalid results, as the program in Example 5.19demonstrates.
EXAMPLE 5.19 src/functions/inlinetst.cpp
// Inline functions vs macros
#include <iostream>
#define  BADABS(X)   (((X) < 0)? -(X) : X)#define  BADSQR(X) (X * X)#define  BADCUBE(X) (X) * (X) * (X)
using namespace std;inline double square(double x) {
return x * x ;
}
inline double cube(double x) {
return x * x * x;
}
inline int absval(int n) {
return (n >= 0) ? n : -n;
}
int main() {
cout << "Comparing inline and #define\n" ;double  t = 30.0;int i = 8, j = 8, k = 8, n = 8; cout << "\nBADSQR(t + 8) = " << BADSQR(t + 8) 
<< "\nsquare(t + 8) = " << square(t + 8)<< "\nBADCUBE(++i) = " << BADCUBE(++i)<< "\n i = " << i<< "\ncube(++j) = " << cube(++j)<< "\nj = " << j<< "\nBADABS(++k) = " << BADABS(++k)<< "\nk = " << k<< "\nabsval(++n) = " << absval(++n)<< "\nn = " << n << endl;
}CHAPTER 5: FUNCTIONS
128ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 128
Here is the output.
Comparing inline and #define
BADSQR(t + 8) = 278
square(t + 8) = 1444BADCUBE(++i) = 1100
i = 11
cube(++j) = 729j = 9BADABS(++k) = 10k = 10absval(++n) = 9n = 9
BADSQR(t+8) gives us the wrong results because
BADSQR(t + 8)
=   (t + 8 * t + 8)          (preprocessor)=   (30.0 + 8 * 30.0 + 8)   (compiler)=   (30 + 240 + 8)          (run-time)=   278
More troubling, however, are the errors produced by BADCUBE and BADABS ,
which both have sufficient parentheses to prevent the kind of error that occurredwith 
BADSQR . Here is what happened with BADCUBE(++i) .
BADCUBE(++i)
=   ((++i) * (++i)) * (++i)   // left associativity =   ((10) * (10)) * (11)=   1100
In general, code substitution macros should be avoided. They are regarded as evil
by most serious C++ programmers. Preprocessor macros are used mostly for thefollowing:
1.
#ifndef/#define/#endif wrapping around header files to avoid
multiple inclusion
2.#ifdef/#else/#endif to conditionally compile some parts of code
but not others
3.__FILE__ and __LINE__ macros for debugging and profiling
As a rule, we use inline functions in favor of macros for code substitutions. The
exception to this rule is the use of Qt macros that insert code into programs thatuse certain Qt classes. It is easy to see why some C++ experts look very suspi-ciously at Qt’s use of macros.5.12 INLINING VERSUS MACRO EXPANSION
129ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 129
EXERCISES: ENCRYPTION
1.In Example 5.16, we declared but did not implement three operators for the
Point3 class. Add implementations for these three operators and add tests to
the client code.
2.In this exercise, we will reuse the random() function from the < cstdlib > (see
Appendix B).
random() generates a pseudo-random integer in the range from 0to
RAND_MAX (commonly set to 2147483647).
Write a function
int myRand(int min, int max);
that returns a pseudo-random int in the range from min to max - 1 .
3.Write the function
QVector<int> randomPerm(int n, unsigned key);
that uses the myRand() function  (seeded with key) to produce a permutation
of the numbers 0,...n .
4.Encryption and privacy are becoming increasingly important. One way to think
of encryption is that we start with a string of text that we pass to one or moretransforming functions. The result of these transformations is a string ofencrypted text that we can then transmit more safely. The recipient of theencrypted string then applies the inverses of the transforming functions tothe string of encrypted text (i.e., decrypts it) and obtains a copy of the originalstring. The sender of the encrypted string must share some information withthe recipient that permits the string to be decrypted (i.e., a key). In the followingexercises we explore a few simple designs for the transforming functions.
a. Write the function
QString shift(const QString& text, unsigned key);
shift() uses the parameter key to set the random function’s seed by
calling srandom() . For each character chin the given string, text , pro-
duce a shifted character by adding the next pseudo-random int to thecode for 
ch. The shifted character is then put in the corresponding place in
the new string. When all the characters of text have been processed,
shift() returns the new string.
b. The next function to write is:
QString unshift(const QString& cryptext, unsigned key);
This function reverses the process described in the previous exercise.CHAPTER 5: FUNCTIONS
130ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 130
c. Write code to test the two functions described above.
d. Another approach to encryption (which can be combined with the
approach described above) is to permute the characters of the givenstring. Write the function
QString permute(const QString& text, unsigned key);
that uses the randomPerm() function to generate a permutation of the
characters of the original string, text .
e. Write the function
QString unpermute(const QString& scrtext, unsigned key);
that reverses the action of the permute() function described above.
f. Write code to test the two functions described above.
g. Write code to test shift() and permute() being applied to the same
string, followed by unpermute() and unshift() .
5.Implement a Crypto class that encapsulates the functions from the preceding
exercises. You can use the following UML diagram to get you started.5.12 INLINING VERSUS MACRO EXPANSION
131
Crypto
- m_Key : ushort
- m_OpSequence : QString- m_CharSetSize : ushort- m_Perm : QVector
+ Crypto(key : ushort, opseq : QString, charsiz : ushort)
+ encrypt(str : const QString&) : QString+ decrypt(str : const QString&) : QString
- shift(str : const QString&) : QString- unshift(str : const QString&) : QString- permute(str : const QString&) : QString- unpermute(str : const QString&) : QString- limitedRand(max : int) : int
- randomPerm(n : int)
m_OpSequence is a QString consisting of the characters 'p' and 's' that
represent permute() and shift() . The encrypt() function applies those
functions to the given string in the order that they appear in the
m_OpSequence string. Example 5.20 shows some code to test your class.
Note that all of the member functions of Crypto are “silent” (i.e., no interac-
tion with the user). User interactions take place only in the client code.ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 131
CHAPTER 5: FUNCTIONS
132
EXAMPLE 5.20 src/functions/cryptoclass/crypto-client.cpp
#include "crypto.h"
#include <QTextStream>QTextStream cout(stdout, QIODevice::WriteOnly);
int main()  {
QString str1 ("This is a sample string"), str2;cout << "Original string: " << str1 << endl;QString seqstr("pspsps");ushort key(13579);Crypto crypt(key, seqstr);str2 = crypt.encrypt(str1);cout << "Encrypted string: " << str2 << endl;cout << "Recovered string: " << crypt.decrypt(str2) << endl;
}ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 132
REVIEW QUESTIONS
133
REVIEW QUESTIONS
1. What is the difference between a function declaration and a function
definition?
2. Why are default argument specifiers in the declaration but not the
definition?
3. For overloading arithmetic symbols ( +,-,*./) on Fraction objects,
which is better, member functions or non-member global operators?
4. Explain the difference between pass-by-value and pass-by-reference. Why
would you use one instead of the other?
5. Explain the difference between preprocessor macros and inline
functions.ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 133
ezus_138004_ch05.qxd  8/4/06  9:39 AM  Page 134
6.1 Simple Derivation . . . . . . . . . . . . . . . . . . . 136
6.2 Derivation with Polymorphism . . . . . . . . 1426.3 Derivation from an Abstract 
Base Class . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
6.4 Inheritance Design . . . . . . . . . . . . . . . . . . . 1526.5 Overloading, Hiding, and Overriding . . . 1546.6 Constructors, Destructors, and Copy
Assignment Operators . . . . . . . . . . . . . . . 155
6.7 Processing Command-Line 
Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . 1586CHAPTER 6
Inheritance and 
Polymorphism
This chapter introduces the concepts and shows
some examples of how to define inheritance rela-tionships between C++ classes. Overriding methods,the virtual keyword, and simple examples show
how polymorphism works.
135ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 135
6.1 Simple Derivation
■Chapter 2
■Chapter 5
Inheritance is a way of organizing classes that is supported by all object-oriented
languages. It allows different classes to share code in many different ways.
T o employ inheritance, we place the common features of similar classes
together in a base class and then derive other classes from it. Each derived class
inherits all the members of the base class and can override or extend each baseclass function as needed. Inheritance from a common base class significantly sim-plifes the derived classes and, with the use of certain design patterns, allows us toeliminate redundant code.
WHAT’S WRONG WITH REPEATED CODE? Software that contains
repeated pieces of identical or very similar code is error prone and diffi-cult to maintain. If repeated code is allowed in a program, it can bedifficult to keep track of all the repetitions.
Code often needs to be changed for one reason or another. If you
need to change a piece of code that has been repeated several times,you must locate all of the repetitions and apply the change to each ofthem. Chances are good that at least one repetition will be missed or that
the intended change will not be applied precisely to all repetitions.
Refactoring is a process of improving the design of software, without changing its
underlying behavior. One step of refactoring involves replacing similar code withcalls to library functions or base class methods.
We will demonstrate inheritance with a simple example. The base class
Student is supposed to contain the attributes that are common to all students.
We kept the list of attributes short for this example, but you can easily imagineother attributes that might be appropriate.
ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 136
We derived two classes from Student that describe particular kinds of stu-
dents. The first derived class, Undergrad , contains only those properties that are
specific to undergraduate students. The second derived class, GradStudent ,c o n -
tains only those properties that are specific to graduate students. The UML dia-gram shown in Figure 6.1 describes these relationships.
The pound sign (
#) that precedes Student::m_Year indicates that m_Year
is a protected member of that class. Recall that protected members of a class
are accessible to the member functions of derived classes. The open arrowhead
(pointing at the base class) is used to indicate class inheritance. This arrow is alsocalled generalization because it points from the more specific (derived) class to
the more general (base) class. The derived classes are also called subclasses of the
base class.
Example 6.1 shows the definitions of the three classes.
EXAMPLE 6.1 src/derivation/qmono/student.h
#ifndef STUDENT_H
#define STUDENT_H
#include <QString>6.1 SIMPLE DERIVATION
137
 - mName : QString
 - mMajor : QString - mStudentId : int # mY ear : int
+ getClassName()
+ Student()+ ~ Student()+ toString()+ yearStr()Student
Undergrad
+ Undergrad()
+ getClassName()GradStudent
 - mSupport : QString
+ GradStudent()
+ getClassName()+ toString() - supportStr()
FIGURE 6.1 UML diagram of inheritance
continuedezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 137
class Student  {
public:
Student(QString nm, long id, QString m_Major, int year = 1);~Student() {}QString getClassName() const;QString toString() const;QString yearStr() const;
private:
QString m_Name;QString m_Major;long m_StudentId;
protected:
int m_Year;
};
class Undergrad: public Student {
public:
Undergrad(QString name, long id, QString major, int year);QString getClassName() const;
};
class GradStudent : public Student {
public:
enum Support { ta, ra, fellowship, other };GradStudent(QString nm, long id, QString major, 
int yr, Support support);
QString getClassName() const ;
QString toString() const;
protected:
static QString supportStr(Support sup) ;
private:
Support  m_Support;
};
#endif        //  #ifndef STUDENT_H
There are other ways of identifying the classname that are better than defining a
getClassName() for each class. getClassName() is used here only to demonstrate how inheri-
tance and polymorphism work.
The classHead of each derived class specifies the base class from which it is derived
and the kind of derivation that is being used. In this case we are using public
derivation.1
Notice that each of the three classes has a function named getClassName() ,
and two of them have a function named toString() . Even though Undergrad11CHAPTER 6: INHERITANCE AND POL YMORPHISM
138
1We discuss the three kinds of derivation—public, protected, and private—in Section 23.4.ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 138
does not contain a toString() declaration in its definition, it inherits one from
the base class.
The student functions are defined in Example 6.2.
EXAMPLE 6.2 src/derivation/qmono/student.cpp
[ . . . . ]
#include <QTextStream>
#include "student.h"6.1 SIMPLE DERIVATION
139
Student::Student(QString nm, long id, QString major, int year)
: m_Name(nm), m_Major(major), m_StudentId(id), m_Year(year) {}
QString Student::getClassName() const {
return "Student";
}
QString Student::toString() const {
QString retval;QTextStream os(&retval);os << "[" << getClassName() << "]" 
<< " name: " << m_Name<< " Id: " << m_StudentId<< " Year: " << yearStr()<< " Major: " << m_Major  ;
return retval;
}1
We write to the stream, and return the string it uses.
Undergrad is not very different from Student, except for one function:
getClassName() .
EXAMPLE 6.3 src/derivation/qmono/student.cpp
[ . . . . ]
Undergrad::Undergrad(QString name, long id, QString major, int year)
: Student(name, id, major, year)
{ }
QString Undergrad::getClassName() const {
return "Undergrad";
}
The base class object is considered a subobject of the derived object. Class members and base
classes both must be initialized and cleaned up, in an order determined by the order that they
appear in the class definition.111ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 139
Member Initialization for Base Classes
Because each Undergrad is aStudent , whenever an Undergrad object is cre-
ated, a Student object must also be created. In fact, one Student constructor is
always called to initialize the Student part of any derived class. In the member
initializers of a constructor, you can think of the base class name as an implicitmember of the derived class.
■It gets initialized first, before the initialization of the derived class members.
■If you do not specify how the base class is initialized, the default
constructor will be called.
GradStudent has all the features of Student plus some added attributes that
need to be properly handled.
EXAMPLE 6.4 src/derivation/qmono/student.cpp
[ . . . . ]
GradStudent::
GradStudent(QString nm, long id, QString major, int yr, 
Support support) :Student(nm, id, major, yr), 
m_Support(support) { }
QString GradStudent::toString() const {
QString result;QTextStream os(&result);os <<  Student::toString()
<< "\n  [Support: "<< supportStr(m_Support)<< " ]\n";
return result;
}
base class version
. . . plus items that are specific to GradStudent
Extending
Inside GradStudent::toString() , before the GradStudent attributes are
printed, we explicitly call Student::toString() , which handles the base class
attributes. In other words, GradStudent::toString() extends the function-
ality ofStudent::toString() .
It is worth noting here that, since most of the data members of Student are
private , we need a  base class function (e.g., toString() ) in order to access
the base class data members. AGradStudent object cannot directly access the2121CHAPTER 6: INHERITANCE AND POL YMORPHISM
140ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 140
private members of Student even though it contains those members . This arrange-
ment definitely takes some getting used to!
6.1.1 Inheritance Client Code Example
GradStudent is aStudent , in the sense that a GradStudent object can be used
wherever a Student object can be used. The client code shown in Example 6.5
creates some instances and performs operations on a GradStudent or an
Undergrad instance directly and also indirectly, through pointers.
EXAMPLE 6.5 src/derivation/qmono/student-test.cpp
#include <QTextStream>
#include "student.h"
static QTextStream cout(stdout, QIODevice::WriteOnly); void graduate(Student* student) {
cout << "\nThe following "
<< student->getClassName()<< " has graduated\n "<< student->toString() << "\n";
}
int main() {
Undergrad us("Frodo", 5562, "Ring Theory", 4);6.1 SIMPLE DERIVATION
141
GradStudent gs("Bilbo", 3029, "History", 6, GradStudent::fellowship);
cout << "Here is the data for the two students:\n";cout << gs.toString() << endl;cout << us.toString() << endl;cout << "\nHere is what happens when they graduate:\n";graduate(&us);graduate(&gs);
continuedreturn 0;
}
T o build this application we use qmake and make as follows:
src/derivation/qmono> qmake -project
src/derivation/qmono> qmake
src/derivation/qmono> make
We then can run it like this:
src/derivation/qmono> ./qmono
Here is the data for the two students:ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 141
[Student]2name: Bilbo Id: 3029 Year: gradual student Major:
History
[Support: fellowship]
[Student] name: Frodo Id: 5562 Year: senior Major: Ring TheoryHere is what happens when they graduate:The following Student has graduated
[Student] name: Frodo Id: 5562 Year: senior Major: Ring Theory
The following Student has graduated
[Student] name: Bilbo Id: 3029 Year: gradual student Major:History
src/derivation/qmono> 
Calling student->toString() from the function graduate() invokes
Student::toString() regardless of what kind of object student points to. If
the object is, in fact, a GradStudent , then there should be a mention of the
fellowship in the graduation message. In addition, we should be seeing“[GradStudent]” in the 
toString() messages, and we are not.
It would be more appropriate to use run-time binding for indirect function
calls to determine which toString() is appropriate for each object.
Because of its C roots, C++ has a compiler that attempts to bind function invo-
cations at compile time, for performance reasons. With inheritance and base classpointers, the compiler can have no way of knowing what type of object it is oper-ating on. In the absence of run-time checking, an inappropriate function can becalled. C++ requires the use of a special keyword to enable run-time binding onfunction calls via pointers and references. The keyword is 
virtual , and it enables
polymorphism, which is explained in the next section.
6.2 Derivation with Polymorphism
We can now discuss a very powerful feature of object-oriented programming:
polymorphism . Example 6.6 differs from the previous example in only one
important way: the use of the keyword virtual in the base class definition.CHAPTER 6: INHERITANCE AND POL YMORPHISM
142
2It would be nice if we saw [GradStudent] here.ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 142
EXAMPLE 6.6 src/derivation/qpoly/student.h
[ . . . . ]
class Student  {
public:
Student(QString nm, long id, QString m_Major, int year = 1);virtual QString getClassName() const;QString toString() const;virtual ~Student() {}QString yearStr() const;
private:
QString m_Name;QString m_Major;long m_StudentId;
protected:
int m_Year;
};// derived classes are the same as before...[ . . . . ]
Note the keyword virtual here.
This should be virtual, too.
It is a good idea to make the destructor virtual, too.
By simply adding the keyword virtual to at least one member function we have
created a polymorphic type . When virtual is specified on a function, it
becomes a method in that class and all derived classes. Example 6.7 shows thesame client code again:
EXAMPLE 6.7 src/derivation/qpoly/student-test.cpp
#include <QTextStream> 
#include "student.h"
static QTextStream cout(stdout, QIODevice::WriteOnly); void graduate(Student* student) {
cout << "\nThe following "
<< student->getClassName()<< " has graduated\n "<< student->toString() << "\n";
}3213216.2 DERIVATION WITH POL YMORPHISM
143
int main() {
Undergrad us("Frodo", 5562, "Ring Theory", 4);
GradStudent gs("Bilbo", 3029, "History", 6, GradStudent::fellowship);
cout << "Here is the data for the two students:\n";cout << gs.toString() << endl;cout << us.toString() << endl;
continuedezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 143
cout << "\nHere is what happens when they graduate:\n";
graduate(&us);graduate(&gs);return 0;
}
Running this version of the program produces slightly different output, as shown
here.
Here is the data for the two students:
[GradStudent] name: Bilbo Id: 3029 Year: gradual student Major:History
[Support: fellowship ]
[Undergrad] name: Frodo Id: 5562 Year: senior Major: Ring TheoryHere is what happens when they graduate:The following Undergrad has graduated
[Undergrad] name: Frodo Id: 5562 Year: senior Major: Ring Theory
The following GradStudent has graduated
[GradStudent] name: Bilbo Id: 3029 Year: gradual student Major:
History
3
Notice that we now see [GradStudent] and [UnderGrad] in the output, thanks to the
fact thatgetClassName() isvirtual . There is still a problem with the output of
graduate() for theGradStudent ,h o w e v e r .T h e Support piece is missing.
With polymorphism, indirect calls (via pointers and references) to methods are
resolved at runtime. This is sometimes called dynamic ,o r  late run-time binding .
Direct calls ( notthrough pointers or references) of methods are still resolvable by
the compiler. That is called static binding or compile-time binding .
In this example, when graduate() receives the address of a GradStudent
object,student->toString() calls the Student version of the function.
However, when the Student::toString() calls getClassName() (indirectly
through this , a base class pointer), it is a virtual method call, bound at
runtime.
Try adding the keyword virtual to the declaration of toString() in the
Student class definition so that you can see the support data displayed properly.
In C++, dynamic binding is an option that one must switch on with the key-
word virtual .CHAPTER 6: INHERITANCE AND POL YMORPHISM
144
3What happened to the Fellowship?ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 144
EXERCISE: DERIVA TION WITH
POL YMORPHISM
Be the computer and predict the output of the programs shown in Examples 6.8
through 6.12. Then compile and run the programs to check your answers.
1.EXAMPLE 6.8 src/polymorphic1.cc
#include <iostream>
using namespace std;
class A {
public:
virtual void foo() {
cout << "A's foo()" << endl;bar();
}virtual void bar() {
cout << "A's bar()" << endl;
}
};
class B: public A {
public:
void foo() {
cout << "B's foo()" << endl;A::foo();
}void bar() {
cout << "B's bar()" << endl;
}
};
int main() {
B bobj;
A *aptr = &bobj;aptr->foo();A aobj = *aptr;aobj.foo();
}
2.EXAMPLE 6.9 src/polymorphic2.cc
#include <iostream>using namespace std;
class A {
public:
virtual void foo() {
cout << "A's foo()" << endl;
}
};6.2 DERIVATION WITH POL YMORPHISM
145
continuedezus_138004_ch06.qxd  8/4/06  6:53 PM  Page 145
class B: public A {
public:
void foo() {
cout << "B's foo()" << endl;
}
};
class C: public B {
public:
void foo() {
cout << "C's foo()" << endl;
}
};
int main() {
C cobj;
B *bptr = &cobj;bptr->foo();A* aptr = &cobj;aptr->foo();
}
3.EXAMPLE 6.10 src/derivation/exercise/Base.h
[ . . . . ]class Base {public:
Base();void a();virtual void b() ;virtual void c(bool condition=true);virtual ~Base() {}
};
class Derived : public Base {
public:
Derived();virtual void a();void b();void c();
};[ . . . . ]
EXAMPLE 6.11 src/derivation/exercise/Base.cpp
[ . . . . ]Base::Base() {
cout << "Base::Base() " << endl;a();c();CHAPTER 6: INHERITANCE AND POL YMORPHISM
146ezus_138004_ch06.qxd  8/4/06  6:53 PM  Page 146
}
void Base::c(bool condition) {
cout << "Base::c()" << endl;
}void Base::a() {
cout << "Base::A" << endl;b();
}void Base::b() {
cout << "Base::B" << endl;
}
Derived::Derived() {
cout << "Derived::Derived() " << endl;
}
void Derived::a() {
cout << "Derived::a()" << endl;c();
}void Derived::b() {
cout << "Derived::b()" << endl;
}
void Derived::c() {
cout << "Derived::c()" << endl;
}[ . . . . ]
EXAMPLE 6.12 src/derivation/exercise/main.cpp
[ . . . . ]int main (int argc, char** argv) {
Base b;
Derived d;
cout << "Objects Created" << endl;
b.b();cout << "Calling derived methods" << endl;d.a();d.b();d.c();cout << ".. via base class pointers..." << endl;Base* bp = &d;bp->a();bp->b();bp->c();
}
[ . . . . ]6.2 DERIVATION WITH POL YMORPHISM
147ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 147
An abstract base class is used to encapsulate common features of concrete
classes . An abstract class cannot be instantiated. Nevertheless, this scheme is quite
useful and efficient for organizing our knowledge of the vastly complex biologicalworld. In the simplified taxonomic organization chart shown in Figure 6.2, we cansee that a primate is a mammal that has certain additional characteristics, a gorillais a hominid with certain additional characteristics, and so forth.
A concrete class represents a particular kind of entity, something that really
exists and can be instantiated. For example, walking through the woods you willnever encounter a real, live animal that is completely described by the designationCarnivora or Felidae. Y ou may, depending on where you walk, find a lion, asiamese cat, or a common housecat ( Felis silvestris ). But there is no instance of a
Hominidae (i.e., of a base class) in the concrete world that is not also an instanceof some particular species. If a biologist ever finds a concrete instance that doesnot fit into an existing species definition, then that biologist may define and namea new species and become famous.
T o summarize, the more general cat egories (class, order, family, subfamily) are
all abstract base classes that cannot be instantiated in the concrete world. They6.3 Derivation from an Abstract Base ClassCHAPTER 6: INHERITANCE AND POL YMORPHISM
148
ClassMammalia
OrderPrimates OrderCarnivora
FamilyHominidae FamilyFelidae
GenusFelis
SpeciesSilvestris SpeciesHomoSapiensGenusGorilla GenusHomo
FIGURE 6.2 Animal taxonomyezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 148
6.3 DERIVATION FROM AN ABSTRACT BASE CLASS
149
were invented by people to help with the classification and organization of the
concrete classes (species).
Back to Programming
At first it might seem counterintuitive to define a class for an abstract idea that hasno concrete representative. But classes are groupings of functions and data, and are
useful tools to enable certain kinds of organization and reuse. Categorizing thingsmakes the world simpler and more manageable for humans and computers.
As we study design patterns and develop frameworks and class libraries, we
will sometimes design inheritance trees where only the leaf nodes can be instanti-ated, and the inner nodes are all abstract.
Once again, an abstract base class is a class that is impossible and/or inappro-
priate to instantiate. Features of a class that tell the compiler to enforce this rule are:
■There is at least one purevirtual function.
■There are no public constructors.
Figure 6.3 shows a class hierarchy with an abstract base class, Shape .Shape is
abstract because it contains pure virtual functions.
Rectangle CircleShape
Square
FIGURE 6.3 Shapes UML diagram
A pure virtual function has the following declaration syntax:
virtual returnType functionName (parameterList )=0;
Example 6.13 shows the base class definition.
EXAMPLE 6.13 src/derivation/shape1/shapes.h
[ . . . . ]
class Shape {
public:
virtual double area() = 0;virtual QString getName() = 0; 21
continuedezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 149
virtual QString getDimensions() = 0;
virtual ~Shape() {}
};
an abstract base class
pure virtual function
getName() ,area() , and getDimension() are all pure virtual functions.
Because they are defined to be pure virtual , no function definition is required
in the Shape class. Any concrete derived class must override and define allpure
virtual base class functions for instantiation to be permitted. In other words, anyderived class that does not override and define allpure virtual base class functions
is, itself, an abstract class. Example 6.14 shows  the derived class definitions.
EXAMPLE 6.14 src/derivation/shape1/shapes.h
[ . . . . ]
class Rectangle : public Shape {
public:
Rectangle(double h, double w) :
m_Height(h), m_Width(w) {}
double area();QString getName();QString getDimensions();
protected:
double m_Height, m_Width;
};
class Square : public Rectangle {
public:
Square(double h) : Rectangle(h,h) {}double area();QString getName();    QString getDimensions();
};
We want to access m_Height in Square class.
Base class name in member initialization list—pass arguments to base class ctor
Rectangle ,Circle , and Square are derived from Shape . Their implementa-
tions are shown in Example 6.15.
EXAMPLE 6.15 src/derivation/shape1/shapes.cpp
#include "shapes.h"
double Circle::area() {
return(3.14159 * m_Radius * m_Radius);
}212121CHAPTER 6: INHERITANCE AND POL YMORPHISM
150ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 150
6.3 DERIVATION FROM AN ABSTRACT BASE CLASS
151
double Rectangle::area() {
return (m_Height * m_Width);
}double Square::area() {
return (Rectangle::area());
}
[ . . . . ]
calling base class version on ‘this’
We provide some client code to exercise these classes in Example 6.16.
EXAMPLE 6.16 src/derivation/shape1/shape1.cpp
#include "shapes.h"#include <QString>#include <QDebug>
void showNameAndArea(Shape* pshp) {
qDebug() << pshp->getName() 
<< " " << pshp->getDimensions() << " area= " << pshp->area();
}
int main() {    
Shape shp;
Rectangle  rectangle(4.1, 5.2);
Square   square(5.1);Circle   circle(6.1);
qDebug() << "This program uses hierarchies for Shapes";
showNameAndArea(&rectangle);showNameAndArea(&circle);showNameAndArea(&square);return 0;
}
ERROR: Instantiation is not allowed on classes with pure virtual functions.
In the global function showNameAndArea() the base class pointer, pshp , is suc-
cessively given the addresses of objects of the three subclasses. For each addressassignment,
pshp polymorphically invokes the correct getName() and area()
functions. Example 6.17 shows the output of the program.1111ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 151
EXAMPLE 6.17 src/derivation/shape1/shape.txt
This program uses hierarchies for Shapes
RECTANGLE  Height = 4.1 Width = 5.2   area = 21.32
CIRCLE  Radius = 6.1   area = 116.899
SQUARE  Height = 5.1    area = 26.01
6.4 Inheritance Design
Sometimes defining an inheritance relationship helps at first (e.g., by reducing
redundant code), but causes problems later when other classes must be added tothe hierarchy. Some up-front analysis can help make things easier and avoid prob-lems later.
Example 6.14, in which we derived from the abstract 
Shape class, demon-
strates an inheritance relationship of two levels of depth. The Rectangle class
was used as a classification of objects and also as a concrete class.
Is a square a kind of rectangle?  Geometrically it certainly is. Here are some def-
initions that we borrow from elementary geometry.
■A shape is a closed two-dimensional object in the plane, with a graphicalway of representing itself, together with a point that is considered its“center.”
■A rectangle is a shape consisting of four straight line segments with only90-degree angles.
■A square is a rectangle with equal sides.
As we attempt to represent an inheritance tree of classes, it helps to list the kinds
of capabilities that we will need to provide for each class. They would be:
■Drawable
■Scalable
■Loadable
■Savable
After we describe the interface in further detail, the geometric definitions for
shape classification may not lead to the ideal taxonomy for these shape classes.
As we perform an analysis, some questions arise:
■What are the common operations and features we want to describe inour abstract base classes?
■What other kinds of shapes will we use in our application?CHAPTER 6: INHERITANCE AND POL YMORPHISM
152ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 152
6.4 INHERITANCE DESIGN
153
■A rhombus is four-sided, like a rectangle, so should Rectangle derive
from Rhombus ?
■Should we have a base class for all four-sided objects?
■Is a Square substitutable for a Rectangle ?
■Should we have a different base class for all five-sided objects?
■Should we have a general base class for polygons and represent the num-ber of sides as an attribute?
■What are the common operations we will want to perform on all shapes?
■Is our program going to perform geometric proof searches to identifyobjects?
■Why do we need a Rectangle class as the base class of a Square ?
Using a UML modeling tool makes it easier to try out different ideas before writ-
ing concrete code. UML diagrams are especially useful for focusing on anddescribing small parts of a larger system.
Polygon CircleShape
Ellipse Square Pentagon Rhombus
FIGURE 6.4 Another way to represent shapes
In Figure 6.4, we have concrete classes that serve as templates for creating the more
“specific” shapes. The leaf classes are, in some cases, constrained versions of theirbase classes. The vector-representation, drawing, and loading/saving of the objectsis handled in the abstract base classes.
In the geometric sense, given a circle, one can prove it is also an ellipse,
because an equation exists that specifies an ellipse, with its two focibeing equal. In contrast, the diagram in Figure 6.4 shows Ellipse to be akind of Circle, with an extra point, or an extra degree of freedom.Would itmake more sense to reverse the inheritance relationship? Or to have a
completely different tree? Where is the is-arelationship?ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 153
6.5 Overloading, Hiding, and Overriding
First, let us recall the definitions of two terms that often get confused:
■When two or more versions of a function foo exist in the same scope
(with different signatures), we say that foo has been overloaded .
■When a virtual function from the base class also exists in the derived
class, with the same signature , we say that the derived version overrides
the base class version.
Example 6.18 demonstrates overloading and overriding and introduces another
relationship between functions that have the same name.
EXAMPLE 6.18 src/derivation/overload/account.h
[ . . . . ]
class Account {protected:
static const int SS_LEN = 80;
public:
virtual void deposit(double amt);virtual const char* toString() const;virtual const char* toString(char delimiter);
protected:
unsigned  m_AcctNo;double    m_Balance;char     m_Owner[SS_LEN];
};
class InsecureAccount: public Account {
public:
const char* toString() const;void deposit(double amt, QDate postDate);
};[ . . . . ]
overloaded function
Overrides base method and hides toString(char).
Does not override any method, but hides all Account : : deposit() methods.
Function Hiding
A member function of a derived class with the same name as a function in the base
class hides all functions in the base class with that name. In addition:
■Only the derived class function can be called directly.
■The class scope resolution operator  may be used to call hidden base
functions explicitly.321321CHAPTER 6: INHERITANCE AND POL YMORPHISM
154ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 154
6.6 CONSTRUCTORS, DESTRUCTORS, AND COPY ASSIGNMENT OPERATORS
155
The client code in Example 6.19 shows how to call a base class function that has
been hidden by a derived class function with the same name.
EXAMPLE 6.19 src/derivation/overload/account.cpp
#include  "account.h"
#include <cstring>#include <iostream>using namespace std;
int main() {
InsecureAccount acct;acct.deposit(6.23);        acct.m_Balance += 6.23;    acct.Account::deposit(6.23);  return 0;
}
Error! No matching function—hidden by deposit(double, int)
Error! Member is protected, inaccessible.
Hidden does not mean inaccessible. We can still access hidden public members via scope
resolution.
6.6 Constructors, Destructors, and Copy
Assignment Operators
Three special kinds of member functions are never inherited:
1. Copy constructors
2. Copy assignment operators3. Destructors
These three functions are generated au tomatically by the compiler for classes that
do not specify them.
WHY ARE THESE FUNCTIONS SPECIAL? The base class functions
are not sufficient to initialize, copy, or destroy a derived instance.
Constructors
For a class that inherits from another, the base class constructor must be called as
part of its initialization process. The derived constructor may specify which base
class constructor is called in its initialization list.321321ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 155
A class with no constructors is automatically given a compiler-generated
default constructor that calls the default constructor for each of its base classes. Ifa class has some constructors but no default constructor, then it has no default ini-tialization. In this case, any derived class constructor must make a specific baseclass constructor call in its initialization list.
Order of Initialization
Initialization proceeds in the following order:
1. Base classes first, in the order in which they are listed in the classHead of
the derived class
2. Data members, in declaration order
Copy Assignment Operators
A copy assignment operator will be generated automatically by the compiler for
each class that does not have one explicitly defined for it. It calls its base class
operator= and then performs memberwise assig nments in declaration order.
Other member function operators are inherited the same way as normal mem-
ber functions.
Copy Constructors
Like the copy assignment operator, the copy constructor gets generated automaticallyfor classes that do not have one defined. The compiler-generated copy constructorwill carry out member-by-member initialization, much as one would expect.
EXAMPLE 6.20 src/derivation/assigcopy/account.h
[ . . . . ]
class Account {
public:
Account(unsigned acctNum, double balance, string owner);virtual ~Account();
private:
unsigned  m_AcctNum;double    m_Balance;string    m_Owner;
};
In Example 6.20, we defined a single constructor that takes arguments, so this class
has no default constructor (i.e., the compiler will notgenerate one for us).CHAPTER 6: INHERITANCE AND POL YMORPHISM
156ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 156
6.6 CONSTRUCTORS, DESTRUCTORS, AND COPY ASSIGNMENT OPERATORS
157
We did notdefine a copy constructor, which means the compiler willgenerate
one for us. Therefore, this class can be initialized in exactly two ways.
EXAMPLE 6.21 src/derivation/assigcopy/account.h
[ . . . . ]
class JointAccount : public Account {
public:
JointAccount (unsigned acctNum, double balance, 
string owner, string jowner);
JointAccount(const Account & acct, string jowner);~JointAccount();
private:
string m_JointOwner;
};
In the derived class defined in Example 6.21, we have two constructors. Both of
them require base class initialization.
EXAMPLE 6.22 src/derivation/assigcopy/account.cpp
[ . . . . ]
#include  "account.h"
#include <iostream>
Account::Account(unsigned acctNum, double balance, string owner) {
m_Balance=balance;m_AcctNum = acctNum;m_Owner = owner;
}
JointAccount::JointAccount (unsigned acctNum, double balance,
string owner, string jowner)
:Account(acctNum, balance, owner), 
m_JointOwner(jowner) {
}
JointAccount::JointAccount (const Account& acc, string jowner)
:Account(acc) {m_JointOwner = jowner;
}
Base class initialization is required.
Compiler-generated copy constructor is called.
In Example 6.22, the compiler allows JointAccount::JointAccount to call
Account(constAccount&) , even though there isn’t one defined. The compiler-
generated copy constructor will do a memberwise copy.2121ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 157
Destructors
Destructors are not inherited. Just as with the copy constructor and copy assign-
ment operator, the compiler will generate a destructor if we do not define oneexplicitly. Base class destructors are automat ically called on all derived objects
regardless of whether a destructor is defined in the class. Members and base-classparts are destroyed in the reverse order of initialization.
6.7 Processing Command-Line Arguments
Applications that run from the command line are often controlled through com-
mand line arguments, which can be switches or parameters. ls,g++, and qmake
are familiar examples of such applications. Handling the different kinds of com-mand line arguments can be done in a variety of ways. Suppose that you are writ-ing a program that supports these options:
Usage:
a.out [-v] [-t] inputfile.ext [additional files]
If -v is present then verbose  = true;If -t is present then testmode = true;
In usage descriptions, optional arguments ar e always enclosed in [square brackets]
while required arguments are not. This program accepts an arbitrarily long list,consisting of at least one file name, and performs the same operation on each file.
In general, command line arguments can be any of the following:
■ Switches , such as -verbose or -t
■ Parameters (typically filespecs), simple strings not associated with
switches
■ Switched parameters such as the gnu compiler’s optional -oswitch,
which requires an accompanying parameter, the name of the executable
file to generate
The following line contains examples of all three kinds of arguments:
g++ -ansi -pedantic -Wall -o myapp someclass.cpp someclass-demo.cpp
Example 6.23 shows how a C program might deal with command line arguments:
EXAMPLE 6.23 src/reuse/argproc.cpp
[ . . . . ]
#include <cstring>
bool test = false;
bool verbose = false;CHAPTER 6: INHERITANCE AND POL YMORPHISM
158ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 158
6.7 PROCESSING COMMAND-LINE ARGUMENTS
159
void processFile(char* filename) {
[ . . . . ]
}
/*
@param argc - the number of arguments@param argv - an array of argument strings
*/int main (int argc, char *argv[]) {
// recall that argv[0] holds the name of the executable.for (int i=1; i < argc; ++i) {
if (strcmp(argv[i], "-v")==0) {
verbose = true;
}if (strcmp(argv[i], "-t") ==0) {
test = true;
}
}for (int i=1; i < argc; ++i) {
if (argv[i][0] != '-') 
processFile(argv[i]);
}
}[ . . . . ]
first process the switches
make a second pass to operate on the non-switched arguments
In Qt, we wish to avoid the use of arrays, pointers, and <cstring> in favor of
more object-oriented constructs.
In Example 6.24, we will see how code like this could be greatly simplified
through the use of higher-level classes, QString and QStringList .
6.7.1 Derivation and ArgumentList
In this section, we present the ArgumentList class, an example from libutils
(see Section 7.2). It reuses QString and QStringList to simplify the process-
ing of command-line arguments.
Operationally, ArgumentList is a class that we initialize with the main()
function’s int and char** parameters that capture the command line argu-
ments. Conceptually, ArgumentList is a list of QStrings. Structurally, it is
derived from QStringList , with some added functionality. We could also say
that ArgumentList is extended from QStringList (as they do in Java-land).
Example 6.24 contains the class definition for ArgumentList .2121ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 159
EXAMPLE 6.24 src/libs/utils/argumentlist.h
#ifndef ARGUMENTLIST_H
#define ARGUMENTLIST_H
#include <QStringList>class ArgumentList : public QStringList {
public:
ArgumentList();
ArgumentList(int argc, char* argv[]); {
argsToStringlist(argc, argv);
}
ArgumentList(const QStringList& argumentList): 
QStringList(argumentList) {}
bool getSwitch(QString option);QString getSwitchArg(QString option, 
QString defaultRetValue=QString());
private:
void argsToStringlist(int argc,  char* argv[]);
};
#endif
Because it is publicly derived from QStringList ,ArgumentList supports the
full interface of QStringList and can be used wherever a QStringList is
expected. In addition to its constructors, ArgumentList defines a few additional
functions:
■argsToStringList() extracts the command-line arguments from the
given array of char arrays and loads them into a QStringList . This
function is private because it is part of the implementation of this class,not part of the public interface. It is needed by the constructors but notby client code.
■getSwitch() finds and removes a switch from the string list, if that
switch exists. It returns true if the switch was found.
■getSwitchArg() finds and removes a switch and its accompanying argu-
ment from the string list and returns the argument if the switch is found. Itdoes nothing and returns a
defaultValue if the switch is not found.
Example 6.25 shows the implementation code for these functions.
EXAMPLE 6.25 src/libs/utils/argumentlist.cpp
#include <QApplication>
#include "argumentlist.h"CHAPTER 6: INHERITANCE AND POL YMORPHISM
160ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 160
6.7 PROCESSING COMMAND-LINE ARGUMENTS
161
ArgumentList::ArgumentList() {
if (qApp != NULL)  
argsToStringlist(qApp->argc(), qApp->argv());
}
void ArgumentList::argsToStringlist(int argc, char * argv []) {
for (int i=0; i < argc; ++i) {
*this += argv[i];
}
}
bool ArgumentList::getSwitch (QString option) {
QMutableStringListIterator itr(*this);while (itr.hasNext()) {
if (option == itr.next()) {
itr.remove();return true;
}
}return false;
}
QString ArgumentList::getSwitchArg(QString option, QString
defaultValue) {
if (isEmpty())
return defaultValue;
QMutableStringListIterator itr(*this);while (itr.hasNext()) {
if (option == itr.next()) {
itr.remove();QString retval = itr.next();itr.remove();return retval;
}
}return defaultValue;
}
a global pointer to the current qApplication
In the client code shown in Example 6.26, all argument processing code has been
removed from main() . No loops, char* ,o r  strcmp are to be found.
EXAMPLE 6.26 src/reuse/main.cpp
#include <QString>
#include <QDebug>#include <argumentlist.h>  // in our utils lib
void processFile(QString filename, bool verbose) {
if (verbose)11
continuedezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 161
qDebug() << QString("Do something chatty with
%1.").arg(filename);
else
qDebug() << filename;
}
void runTestOnly(QStringList & listOfFiles, bool verbose) {
foreach (QString current, listOfFiles) {
processFile(current, verbose);
}
}
int main( int argc, char * argv[] ) {
ArgumentList al(argc, argv);
QString appname = al.takeFirst();qDebug() << "Running " << appname;
bool verbose = al.getSwitch("-v");
bool testing = al.getSwitch("-t");if (testing) {
runTestOnly(al, verbose);return 0;
} else {
qDebug() << "This Is Not A Test";
}
}
Qt improved foreach loop.
Instantiate the ArgumentList with command line args.The first item in the list is the name of the executable.Now all switches have been removed from the list. Only filenames remain.
ArgumentList can be used in place of QStringList.
Here are some sample outputs from running the program in Example 6.26:
src/reuse> ./reuse item1 "item2 item3" item4 item5
"Running ./reuse"This Is Not A Testsrc/reuse> ./reuse -t item1 "item2 item3" item4 item5
"Running ./reuse""item1""item2 item3""item4""item5"src/reuse> ./reuse -v -t "foo bar" 123 space1 "1 1"
"Running ./reuse""Do something chatty with foo bar.""Do something chatty with 123.""Do something chatty with space1.""Do something chatty with 1 1."src/reuse>
The project file in Example 6.27 shows how to reuse the classes in our utils
library.5432154321CHAPTER 6: INHERITANCE AND POL YMORPHISM
162ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 162
6.7 PROCESSING COMMAND-LINE ARGUMENTS
163
EXAMPLE 6.27 src/reuse/reuse.pro
TEMPLATE = app
INCLUDEPATH += $$(CPPLIBS)/utilsLIBS += -L$$(CPPLIBS) -lutils# Input
SOURCES += main.cpp
EXERCISE: INHERITANCE AND
POL YMORPHISM
1.The classes in the diagram below are intended to help organize the film collec-
tion in the college library.
a. Implement the Film classes. Make sure that the constructors have sufficient
parameters to initialize all data members. We have suggested enum types
FilmTypes (Action, Comedy, SciFi, . . .) and MPAARatings (G, PG, PG-13, . . .)
for use in the Entertainment class.
Film
 - m_FilmID : QString
 - m_Title : QString - m_Director : QString - mFilmLength : int - m_ReleaseDate : QDate
+ Film()
+ toString() FilmList
+ toString() : QString
+ findFilm(id : QString) : Film*+ getID(title : QString) : QString+ addFilm(film : Film*)+ removeFilm(filmID : QString)
Entertainment
 - m_Type : FilmTypes
 - m_Rating : MPAARatings
+ Entertainment()
+ toString() : QStringEducational
 - m_Subject : QString
 - m_GradeLevel : int
+ Educational()
+ toString() : QStringQListezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 163
CHAPTER 6: INHERITANCE AND POL YMORPHISM
164
4http://oop.mcs.suffolk.edu/qtdocs/hierarchy.htmlb. Implement the FilmList class as a container of Film pointers. Make sure
that the addFilm() function does not permit the same Film to be added
more than once.
c.Write client code to test these classes. Put a mixture of Entertainment
and Educational films into the FilmList and exercise all the member
functions.
2.Revisit the birthday reminder exercise (“Exercise: The Qt Core Module” in
Chapter 3) and use an ArgumentList object to process the command-line
arguments.
POINTS OF DEPARTURE
1. Which methods are in QStringList but not in QList ? Would it make
sense to put them in QList ?
2. Examine the Qt class hierarchy.4The most important classes are those
with the most derived classes. Which three classes have the most derivedclasses? Write a paragraph about each of them and why you think it isimportant.ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 164
REVIEW QUESTIONS
165
REVIEW QUESTIONS
1. What is inheritance for?
2. Explain polymorphism. What is it? How can you use it? 3. Explain the difference between dynamic binding and static binding.
Describe the conditions that enable each.
4. How do you override a base class method?5. What is a pure virtual function? What is it used for?6. What is an abstract class? What is it used for? What can you do with a
concrete class that you cannot do with an abstract class?
7. What does it mean for a base class function to be hidden ? What can
cause this to happen?
8. Which member functions cannot be inherited from the base class?
Explain why.ezus_138004_ch06.qxd  8/4/06  9:40 AM  Page 165
PART II 
Higher-Level
Programming ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 166
Chapter 7. Libraries . . . . . . . . . . . . . . . . . . . . . . 169
Chapter 8. Introduction to Design Patterns. . 181Chapter 9. QObject . . . . . . . . . . . . . . . . . . . . . . 191Chapter 10. Generics and Containers . . . . . . . 213Chapter 11. Qt GUI Widgets . . . . . . . . . . . . . . . . 237Chapter 12. Concurrency. . . . . . . . . . . . . . . . . . . 277Chapter 13. Validation and Regular 
Expressions . . . . . . . . . . . . . . . . . . . 307
Chapter 14. Parsing XML . . . . . . . . . . . . . . . . . . . 321Chapter 15. Meta Objects, Properties,
and Reflective Programming. . . . 341
Chapter 16. More Design Patterns . . . . . . . . . . 359Chapter 17. Models and Views. . . . . . . . . . . . . . 391Chapter 18. Qt SQL Classes. . . . . . . . . . . . . . . . . 423
167ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 167
ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 168
1697CHAPTER 7
Libraries 
Libraries are groups of code modules organized in a
reusable way. This chapter introduces how they arebuilt, reused, and designed.
7.1 Code Containers . . . . . . . . . . . . . . . . . . . . . 170
7.2 Reusing Other Libraries . . . . . . . . . . . . . . 1717.3 Organizing Libraries: Dependency
Management . . . . . . . . . . . . . . . . . . . . . . . . 173
7.4 Installing Libraries: A Lab Exercise . . . . . 1767.5 Frameworks and Components . . . . . . . . 178ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 169
Libraries generally contain code that has already been designed, tested, and
compiled, and can be easily linked into your application. Libraries are essential formaking software reuse possible. They can be packaged in a number of differentways, such as
1. Source code
2. Binary format (dynamic library, shared object, static library, run-time
library), called libfor short.
3. lib + header files (sometimes referred to as “-dev” or “-devel” packages in
Linux package managers)
The lib+header combo allows you to distribute your library without the
full source. Others can still compile their apps with it. The binary formatcan only be used with an app that was already compiled against the
library.
A lib is a file that contains several compiled files (called object files ) that are
indexed to make it easy for the linker to locate symbols (e.g., names of classes,members, functions, variables, etc.) and their definitions. Packaging these object
files in one lib expedites the linking process significantly.
7.1 Code Containers
One aspect of C++ that makes it very powerful is its ability to package code in sev-
eral different ways.
Table 7.1 defines some terms that are used to describe containers of code. The
table is arranged (approximately) in order of increasing granularity from top tobottom.
ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 170
TABLE 7.1 Reusable Components
Term Visible attributes Description
class class Classname A collection of functions and 
{ body } ; data members, and descriptions 
of its lifecycle management (constructors and destructors)
namespace namespace name A collection of declarations and 
{ body } ; definitions, of classes, functions 
and static members, perhaps spanning multiple files
header file .h Class definitions, template 
definitions, function declarations (with default argument definitions),inline definitions, static object declarations
source code .cpp Function definitions, static object 
module definitions
compiled .o or .obj Each .cpp module is compiled into 
“object” module a binary module as an intermediate 
step in building a library or executable.
library .lib or .la (+ .so or An indexed collection of object 
.dll if dynamic) files linked together. No 
main()
function must exist in any code module in a library.
devel package lib + header files A library along with accompanying 
header files
application
.exe on windows, A collection of object files, linked 
no particular with libraries, to form an application.extension on *nix Contains exactly one function 
definition called main() .
7.2 Reusing Other Libraries
Many of our examples link with various libraries that we have supplied. The one we
use most frequently is called libutils . Y ou can download a tarball containing
this library here.1Create a shell/environment variable CPPLIBS that points to a
convenient (empty) directory and then unpack the utils tarball in that directory.7.2 REUSING OTHER LIBRARIES
171
1http://oop.mcs.suffolk.edu/distezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 171
When we set up projects that reuse utils we will always assume that
the shell/environment variable $CPPLIBS (or %CPPLIBS% in Windows)
has been properly set to contain the “libs root.” This variable is used fortwo purposes: It is the parent directory of all the C++ source code forlibraries supplied by us (or by you), and it is also the destination directory
of the compiled shared object code for those libraries.
qmake can access an environment variable such as CPPLIBS from inside a proj-
ect file using the syntax $$(CPPLIBS) .qmake can also include other project file
(fragments). For example, the project file in Example 7.1 includes a .pri file locatedin a directory relative to your environment variable 
CPPLIBS.
EXAMPLE 7.1 src/qapp-gui/qapp-gui.pro
include ($$(CPPLIBS)/utils/common.pri)
TEMPLATE = app
# InputHEADERS += messager.h
SOURCES += main.cpp messager.cpp
The command
qmake -project
produces a project file that contains information based on the contents of the
current working directory. In particular, qmake cannot know about external
libraries that you may need to build your project. So, if your project depends onan external library, you must edit the project file and add assignments to three ofthe variables.
For example, suppose we are developing an application that uses our 
utils
library. The header files are located in $CPPLIBS/utils and the lib shared
object files are located in $CPPLIBS . Then we must add the following lines to the
project file
INCLUDEPATH += $$(CPPLIBS)/utils # the source header files
LIBS += -L$$(CPPLIBS) # add this to the lib search pathLIBS += -lutils                # link with libutils.so
Assignments to the LIBS variable generally contain two kinds of linker switches
that are passed directly to the compiler and the linker. For more information aboutwhat the linker switches mean see Section C.2.CHAPTER 7: LIBRARIES
172ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 172
7.3 Organizing Libraries: Dependency
Management
A dependency between two program elements exists if one is reusing the other,
that is, if using or testing one (the reuser) requires the presence and correctness ofthe other one (the reused). In the case of classes, a dependency exists if the imple-mentation of the reuser class must be changed whenever the interface of thereused class is changed.
Another way of describing this relationship is to say that 
ProgElement1
depends on ProgElement2 ifProgElement2 is needed in order to build
ProgElement1 .
This dependency is a compile-time dependency ifProgElement1.h must
be #included in ProgElement2.cpp in order to compile.
It is a link-time dependency if the object file ProgElement2.o contains
symbols that are defined in ProgElement1.o .
We depict the dependency between a reuser ClassA and a reused ClassB
with a UML diagram, as shown in Figure 7.1.7.3 ORGANIZING LIBRARIES: DEPENDENCY MANAGEMENT
173
A dependency between ClassA and ClassB can arise in a variety of ways. In each
of the following situations, a change in the interface of ClassB might necessitate
changes in the implementation of ClassA .
■ClassA has a data member that is a ClassB object or pointer.
■ClassA is derived from ClassB.
■ClassA has a function that takes a parameter of type ClassB .
■ClassA has a function that uses a static member of ClassB .
■ClassA sends a message (e.g., a signal) to ClassB .2
In each case, it is necessary to #include ClassB in the implementation file for
ClassA .
In the package diagram shown in Figure 7.2, we have displayed parts of our
own libs collection of libraries. There are direct and indirect dependencies
shown. At this level of granularity we are concerned with the dependencies between
libraries (indicated by dashed arrows).
2We discuss signals and slots in Section 9.3.2.FIGURE 7.1 DependencyClassA ClassB dependencyezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 173
FIGURE 7.2 Libraries and their dependenciesCHAPTER 7: LIBRARIES
174
If you wish to reuse one of the libraries shown in Figure 7.2, you need to ensure
that all of its dependent libraries are also part of your project. For example, if youuse the 
filetagger library, there is a chain of dependencies that requires you to
also make available the dataobjects library (e.g., FileTagger is derived from
DataObject ), the utils library (e.g., the test code generally reuses the various
assert macros in utils ), and the id3lib library (e.g., FileTagger has a mem-
ber of type auto_ptr<ID3_Tag*> and defines some functions with parameters
of type ID3_FrameID* ).
Code reuse, a valuable and important goal, always produces dependencies.
When designing classes and libraries it is important to make sure that we produceas few unnecessary or unintentional dependencies as possible because they tend toslow down compile times and reduce the reusability of your classes and libraries.Each 
#include directive produces a dependency and should be carefully exam-
ined to make sure that it is really nec essary. This is especially true in header files:
Each time a header file is #included it brings all of its own #includes along
with it so that the number of dependencies grows accordingly.Objects for storing/managing
data read from user or file
classes related to
MP3 Manager apps
Model-View derived classesGeneral-purpose
classes + testcaseframeworkutils
ArgumentList
FileVisitorassertequals.hT estCaselogger.hlogwindow.hqstd.hcommon.prixmlExportlibs
DataObjectObjectFactoryConstraintConstraintMgrXmlimportPropsMapAddressCountry
FormModelFormViewQuestionChoiceDelegateMp3SongMp3PlayerPlayListPreferenceFileTaggerCustomerCustomerList
Qt4dataobjects
formscustomer
filetagger
id3libezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 174
A forward declaration of a class declares its name as a valid class name
but leaves out its definition. This permits that name to be used as a typefor pointers and references that are not dereferenced before the defini-tion is encountered. Forward declarations make it possible for classes tohave circular relationships without having circular dependencies
between header files (which the compiler will not permit).
In a class definition, one good rule to follow is this: Do not use an #include if a
forward declaration will suffice. For example, the header file "classa.h" might
look something like this:
#include "classb.h"
#include "classd.h"// other #include directives as neededclass ClassC;    // forward declarationclass ClassA : public ClassB {
public:
ClassC* f1(ClassD);
// other stuff that does not involve ClassC 
};
We have (at least) two intentional reuse dependencies in this definition: ClassB
and ClassD , so both #include directives are necessary. A forward declaration of
ClassC is sufficient, however, since the class definition only involves a pointer to
that class.
It is very important to make sure that there are no circular dependencies in
your project (i.e., in a diagram like the one in Figure 7.2, there must be no path thatpermits you to return to the starting location by following a sequence of arrows.)
3
Dependency management is an important issue that is the subject of several
articles and for which a variety of tools have been developed. Two open-sourcetools are
■cinclude2dot , a perl script that analyzes C/C++ code and produces a
dependency graph.
■Makedep , a C/C++ dependency generator for large software projects
that parses all source files in a directory tree and constructs a largedependency file for inclusion in a Makefile.7.3 ORGANIZING LIBRARIES: DEPENDENCY MANAGEMENT
175
3Such a path is called a cycle .ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 175
7.3.1 Installing Libraries
After a library has been written and tested, it will be installed at the end of the
build process in the directory specified by the DESTDIR variable. For example, the
project file for our utils library contains the following relevant lines:CHAPTER 7: LIBRARIES
176
4http://oop.mcs.suffolk.edu/distTEMPLATE = lib     # Build this as a library, not as an application
DESTDIR=$$(CPPLIBS) # Place the compiled shared object code here
For library templates, qmake can generate a Makefile with the install target
so that the command
make install
will, after a successful build, copy the library to some particular location. Forexample, on a *nix platform, the following lines could be added to the project filefor 
utils :
target.path=/usr/lib
INSTALLS += target
Then, if you have write access there, the command
make install
would copy the libutils.so files and their associated symlinks to the directory
/usr/lib .
If you need to relocate a library, the procedure varies from platform to plat-
form. In Windows, you can copy its .dll file into an appropriate directory that islisted in your PATH variable. In *nix, you can copy the shared object file and asso-ciated symbolic links into a directory that is listed in 
/etc/ld.so.conf or one
that is findable by searching in LD_LIBRARY_PATH .
During development, it is usually sufficient to make and install libraries in
your home directory, and adjust LD_LIBRARY_PATH appropriately. At deploy-
ment time, on a *nix platform, it may be desirable to install the library in
/usr/local , a systemwide location accessible to all other users. This would
require superuser permissions.
7.4 Installing Libraries: A Lab Exercise
A number of examples in this book make use of classes found in one of the
libraries that were written for this book. The source code for these classes is avail-able for download.
4In the HTML version of this book, the class names are allezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 176
hyperlinked to API docs.5Here you learn how to download and install these extra
classes.
Instructions for installing libraries on a *nix platform for use with the book
examples follow.
■Create a ~/projects/libs directory.
■Create a shell/environment variable CPPLIBS that  contains the absolute
path ofprojects/libs .
■Y ou should already have a shell/environment variable QTDIR that con-
tains the absolute path of the directory that contains Qt 4.6
■Download libs.pro ,utils.tar.gz , and dataobjects.tar.gz.7
■Unpack these two tarballs in the $CPPLIBS directory. That should
result in two new subdirectories, $CPPLIBS/utils and $CPPLIBS/
dataobjects .
■Create or modify a $CPPLIBS/libs.pro SUBDIRS project to build
only libutils followed by libdataobjects .
■Build the libraries from the libs directory in two steps:
1.qmake // to create a Makefile
2.make // to build the library
■Verify that the libraries are built and that the shared object files (e.g.,
libutils.so) are located in the $CPPLIBS directory.
7.4.1 Fixing the Linker Path
■Update the shell/environment variable LD_LIBRARY_PATH (*nix) or
PATH (win32) to include CPPLIBS .
■Create a projects/tests directory. This is where you can keep code
for testing various library components.
■Download main.cpp from Example 6.26 into projects/tests and
write/modify a tests.pro file to build that application using the utils
library.
■Run the application.
■Verify that it gives the same output that we displayed back in Chapter 6when we discussed the 
ArgumentList class.7.4 INSTALLING LIBRARIES: A LAB EXERCISE
177
5http://oop.mcs.suffolk.edu/api
6This is not required by Qt 4, but is required by Qt 3 and KDE, and is used for Qt 4 as a way of
pointing to “the current version of Qt that you are using.”
7From http://oop.mcs.suffolk.edu/distezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 177
On a *nix platform a shell script is generally used to define environment
variables. Example 7.2 shows a bash script that handles the job.
EXAMPLE 7.2 src/bash/env-script.sh
export CPPLIBS=$HOME/cs331/projects/libs
export QTDIR=/usr/local/qtexport LD_LIBRARY_PATH=$QTDIR/lib:$CPPLIBS
export PATH=$QTDIR/bin:$PATH
You can run this script by typing one of the following commands:
source env-script.sh
or
. env-script.sh
Notice the dot (.) at the beginning of the second version. In the bash
shell, the dot is equivalent to the command, source .
If you want to make sure that these environment variables are auto-
matically set at the start of each shell, you can source the script from
~/.bashrc , which runs automatically whenever bash starts.
Hamish Whittal has put together a very nice online guide to shell
scripting at http://learnlinux.tsf.org.za/courses/build/shell-scripting.
7.5 Frameworks and Components 
Organization of classes goes beyond simple inheritance. Carefully designed frame-
works allow one to find and reuse components much more easily. All large soft-ware projects are built on top of frameworks, and we discuss some of the morepopular ones in use today.
Code reuse is the holy grail of programming. In the past, computer time was
expensive and programmer time was relatively cheap, but now things are exactlyreversed. T oday all software is built out of building blocks, which are themselvespieces of software. We never start from scratch. It is a waste of programmers’ timeto reinvent and reimplement things that have already been designed, imple-mented, refined, and tested by recognized experts.
A framework is a (typically large) collection of general-purpose (or domain-
specific) classes and conventions designed to improve the consistency of design.Frameworks are often used to create graphical applications, database applications,or other complex pieces of software.CHAPTER 7: LIBRARIES
178ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 178
A framework has a well-documented public Application Programmers’
Interface, or API. An API is a description of the public functions, classes, and
interfaces in a library. T o implement frameworks, design patterns are used.
Development with design patterns involves looking for pertinent objects and pos-sible hierarchies. The classes and patterns used are given good descriptive namesso that we can define them once and reuse them elsewhere. We will discuss designpatterns shortly in Chapter 8.
Qt 4 is one of many open-source object-oriented frameworks that provide a set
of reusable components for building cross-platform applications. Some others
worth knowing about are:
■boost: an open-source cross-platform library of C++ utility classes
■mono: an open-source implementation of Microsoft’s .NET, the API forC#, which is built on top of libgtk
■libgtk, libgtk++: the widgets used under the Gnome desktop, Mozilla,GAIM, GIMP , Evolution, and many other open-source programs
■wxWidgets: another C++ cross platform widget toolkit
■Wt8: a Qt-like framework for building Web applications using boost and
AJAX.9
With a multi-platform framework like Qt 4, you can gain enormous benefits fromthe creative efforts of others. Software built on top of (strictly using) Qt 4 will be
based on components that have already been tested on Windows, Linux, and MacOS/X by hundreds of programmers.
T oolkits like Qt 4 (and also Gtk++, the cross-platform Gnu T oolkit) have parts
that are implemented differently on each platform. This is why Qt-based applica-tions look like KDE apps in Linux and like Windows apps in Windows.7.5 FRAMEWORKS AND COMPONENTS
179
8http://jose.med.kuleuven.ac.be/wt
9A system of JavaScript and XML-rpc that gives list/tree/table views inside a Web pageezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 179
CHAPTER 7: LIBRARIES
180
REVIEW QUESTIONS
1. For each of these items, list whether it would be found in a header ( .h)
file or an implementation ( .cpp ) file, and why.
a. Function definitions
b. Function declarationsc. Static object declarationsd. Static object definitionse. Class definitionsf. Class declarationsg. Inline function definitionsh. Inline function declarationsi. Default argument specifiers
2. What is the difference between a compile-time dependency and a link-
time dependency?ezus_138004_ch07.qxd  8/4/06  9:41 AM  Page 180
1818CHAPTER 8
Introduction to 
Design Patterns
Design patterns are efficient and elegant solutions to
common problems in object-oriented softwaredesign. They are high-level abstract templates thatcan be applied to particular kinds of design problems.
8.1 Iteration and the Visitor Pattern . . . . . . . 182ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 181
In their very influential book ,Design Patterns , Erich Gamma, Richard Helm,
Ralph Johnson, and John Vlissides, often (affectionately) referred to as the “Gangof Four,” analyzed 23 specific patterns [Gamma95]. Each pattern has a sectiondevoted to it, including
■A pattern name
■A description of the kinds of problems to which one might apply thepattern
■An abstract description of a design problem and how its solution can beobtained
■A discussion of the results and trade-offs that can occur when the pat-tern is applied
Design patterns are used for many different purposes. As a result, they are subdi-
vided into categories. The three main categories are
■ Creational patterns , which manage the creation of objects
■ Structural patterns , which describe how objects are connected together
to form more complex objects
■ Behavioral patterns, which are used to describe how code is organized,
to assign responsibility or roles to certain classes, and to specify the wayobjects communicate with each other
The Gang of Four assert that design patterns are “descriptions of communicating
objects and classes that are customized to sol ve a general design problem in a par-
ticular context.” As we continue to develop applications with Qt, we will discussand give examples of several design patterns.
8.1 Iteration and the Visitor Pattern
In this section, we discuss some elegant ways to reuse QFile ,QDir , and
QFileInfo . We present a visitor object that processes each file in a file system. By
separating the visitor code from the application logic, we have a FileVisitor
that can be used by other programs. Maximum code reuse is demonstratedthrough careful interface design.
ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 182
8.1.1 Directories and Files: QDir and QFileInfo
There will be many occasions when it is necessary to write a program to visit files
of a certain type, and to perform some operation on each. Since directories cancontain subdirectories as well as files, the visiting code may need to be recursive.Qt has two particularly useful classes for visiting files and getting informationabout their contents:
QDir and QFileInfo . Using these classes, we can write
portable (Win32, MacOS, and *nix) code that searches a file system.
Example 8.1 will assemble a list of absolute path names of MP3 files that are
scattered throughout the subdirectories below a given path. The final productmight be a playlist that we present to a piece of software such as Winamp, XMMS,or amaroK. Here is our first try.
EXAMPLE 8.1 src/visitorsrc/recurseadddir.cpp
/* This function searches for all Mp3 files in a directory
tree and adds them. */
void Mp3Db::recurseAddDir(QDir d) {
d.setSorting( QDir::Name );d.setFilter( QDir::Files | QDir::Dirs );QStringList qsl = d.entryList();foreach (QString entry, qsl) {
QFileInfo finfo(entry);if ( finfo.isSymLink () && !m_SymLink )
return;
if ( finfo.isDir() ) {
if (!m_Recursive )
return;
QString dirname = finfo.fileName();if ((dirname==".") || (dirname == ".."))
return;
QDir d(finfo.filePath());if (skipDir(d))
return;
recurseAddDir(d);
} else {
if (fi->extension(false)=="mp3") {
addMp3File(fi->absFilePath());
}
}
}
}
non-reusable part
Example 8.1 shows how the APIs of QDir andQFileInfo can be used for travers-
ing directories. It is not well-designed for reuse, however, since there is application-specific code in the example.118.1 ITERATION AND THE VISITOR PATTERN
183ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 183
8.1.2 Visitor PatternCHAPTER 8: INTRODUCTION TO DESIGN PATTERNS
184
The Visitor pattern , like most design patterns, describes how to separate
code in a more reusable way. In this case, an operation is to be performed onselected objects in some organized collection. The idea of this pattern is tomaintain a separation between visiting code and the code that processeseach visited item. Then we can plug application-specific code for processingeach selected file into our reusable visiting code.
In this section, we present some code from our libutils (see Section 7.4) called
FileVisitor . Given a path to a directory, FileVisitor traverses all the files
and subdirectories in that path. We can impose constraints so that we skip overfiles that we do not wish to process.
FileVisitor applies the function
processFile() to each file that satisfies our constraints.
T o make FileVisitor into a reusable tool, we keep the file-processing
operation separate from the file-traversing code. There are two ways we can plugin the processing code: through inheritance/polymorphism or signals/slots(see Section 9.3.3).
T o use the inheritance approach, we override the
virtual method
processFile() . By deriving from FileVisitor , we can customize its behavior
as it deals with individual files. Since the FileVisitor ’sprocessFile emits a
signal, we could connect the signal to a slot and avoid inheritance entirely.
EXAMPLE 8.2 src/libs/utils/filevisitor.h
[ . . . . ]
#include <QDir>#include <QObject>
class FileVisitor : public QObject {
Q_OBJECT
public:
FileVisitor(QString nameFilter="*",
bool recursive=true, bool symlinks=false);
public slots:
void processFileList(QStringList sl);void processEntry(QString pathname);ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 184
signals:
void foundFile(QString filename);
protected:
virtual void processFile(QString filename);
[ . . . . ]
protected:
QString m_NameFilter;bool m_Recursive;QDir::Filters m_DirFilter;
};
[ . . . . ]
The constraints ( m_NameFilter ,m_DirFilter , and m_Recursive ) are
stored as data members of FileVisitor , shown in Example 8.2. If
m_Recursive is true, then the FileVisitor will descend into each subdirec-
tory that it encounters. Example 8.3 shows how the visitor deals with files anddirectories. Notice, that since the 
FileVisitor ’s processFile emits a signal,
we could create a concrete FileVisitor and connect the foundFile() to a
slot, avoiding inheritance entirely.
EXAMPLE 8.3 src/libs/utils/filevisitor.cpp8.1 ITERATION AND THE VISITOR PATTERN
185
[ . . . . ]
void FileVisitor::processFile(QString filename) {
//  qDebug() << QString("FileVisitor::processFile(%1)").arg(filename);emit foundFile(filename);
}
void FileVisitor::processEntry(QString current) {
QFileInfo finfo(current);processEntry(finfo);
}
void FileVisitor::processEntry(QFileInfo finfo) {
//   qDebug(QString("ProcessEntry: %1").arg(finfo.fileName()));
if (finfo.isDir()) {
QString dirname = finfo.fileName();if ((dirname==".") || (dirname == ".."))
return;
QDir d(finfo.filePath());if (skipDir(d))
return;
processDir(d);
} else
processFile(finfo.filePath());
}1
continuedezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 185
[ . . . . ]
void FileVisitor::processDir(QDir& d) {
QStringList filters;filters += m_NameFilter;d.setSorting( QDir::Name );QStringList files = d.entryList(filters, m_DirFilter);foreach(QString entry, files) {
processEntry(d.filePath(entry));
}
if (m_Recursive) {
QStringList dirs = d.entryList(QDir::Dirs);foreach (QString dir, dirs) {
processEntry(d.filePath(dir));
}
} 
}[ . . . . ]
Override this method to do something more interesting with each file.
After all the files in a directory’s list are processed and if m_Recursive is true,
processDir() obtains a list of entries and calls processEntry() recursively
on each of them.
8.1.3 Customizing the Visitor Using Inheritance
Figure 8.1 shows an extended FileVisitor , customized for the specific purpose
of tracking code dependencies.1CHAPTER 8: INTRODUCTION TO DESIGN PATTERNS
186
FIGURE 8.1 Code Visitor UMLFileVisitor
+ processFile(filename : QString)
CodeVisitor
 - m_NumFiles : int
 - m_Result : QStringList
+ CodeVisitor(filter : QString, recursive : bool)
+ processFile(filename : QString)+ getNumFiles() : int+ getResultString() : QString
The codevisitor application opens each file that it visits and collects all the
#include lines in a QStringList . The class definition is shown in Example 8.4.ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 186
EXAMPLE 8.4 src/visitor/codevisitor/codevisitor.h
[ . . . . ]
class CodeVisitor : public FileVisitor {
public:
CodeVisitor(QString filter = "-h", bool recursive = true) : 
FileVisitor(filter, recursive), m_NumFiles(0) {}
void processFile(QString filename);int getNumFiles() const;QString getResultString() const;
private:
int m_NumFiles;QStringList m_Result;
};
[ . . . . ]
The implementation shown in Example 8.5, consists mainly of overriding the
processFile() method.
EXAMPLE 8.5 src/visitor/codevisitor/codevisitor.cpp
[ . . . . ]
void CodeVisitor::processFile(QString filename) {
m_Result << filename;QString line;QFile file(filename);file.open(QIODevice::ReadOnly);QTextStream filestream(&file);while(! filestream.atEnd()) {
line = filestream.readLine();if(line.startsWith("#include"))
m_Result << QString("    %1").arg(line);
}file.close();++m_NumFiles;
}
Example 8.6 is an application for reporting on dependencies of source code files.
EXAMPLE 8.6 src/visitor/codevisitor/codevisitor-test.cpp
#include <argumentlist.h>
#include <codevisitor.h>#include <QApplication>#include <qstd.h>using namespace qstd;8.1 ITERATION AND THE VISITOR PATTERN
187
continuedezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 187
void usage(QString appname) {
cout << appname << " Usage: \n"
<< "codevisitor [-r] [-d startdir] [-f filter] [file-
list]\n"
<< "\t-r        \tvisitor will recurse into subdirs\n"<< "\t-d startdir\tspecifies starting directory\n"<< "\t-f filter\tfilename filter to restrict visits\n"<< "\toptional list of files to be visited" << endl;
}
int main(int argc, char** argv) {
ArgumentList al(argc, argv);QString appname = al.takeFirst();if(al.count() == 0) {
usage(appname);exit(1);
}bool recursive(al.getSwitch("-r"));QString startdir(al.getSwitchArg("-d"));QString filter(al.getSwitchArg("-f"));CodeVisitor cvis(filter, recursive);if(startdir != QString()) {
cvis.processEntry(startdir);
}else if(al.size()) {
cvis.processFileList(al);
}else
return 1;
cout << "Files Processed: " << cvis.getNumFiles() << endl;cout << cvis.getResultString() << endl;return 0;
}
app name is always first in the list.
Decoupling
Notice that codevisitor also reuses our ArgumentList class.main() passes
an ArgumentList to the FileVisitor function, processFileList
(QStringList) . Both FileVisitor and ArgumentList depend on
QStringList , but neither depends on the other. Thus, each can be compiled and
reused separately. We can also pass one as an argument to the other’s function.
Now,main() is free of iteration code, conditionals, and data structure manip-
ulations. Dealing with these higher-level objects makes main() easier to read and
understand. Here are some sample runs of this app.
src/visitor/codevisitor> ./codevisitor
./codevisitor Usage:codevisitor [-r] [-d startdir] [-f filter] [file-list]11CHAPTER 8: INTRODUCTION TO DESIGN PATTERNS
188ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 188
-r           visitor will recurse into subdirs
-d startdir    specifies starting directory-f filter      filename filter to restrict visitsoptional list of files to be visited
src/visitor/codevisitor> ./codevisitor -r -d "../" -f "*.h"
Files Processed: 3../imagexport.h
#include <filevisitor.h>#include <QApplication>#include <qonsole.h>
../qonsole.h
#include <QMainWindow>
../codevisitor/codevisitor.h
#include <filevisitor.h>#include <QStringList>
src/visitor/codevisitor>   
EXERCISES: ITERA TION AND THE VISITOR
PA TTERN
1.diskusage reports, in various formats, the amount of disk space used in a
directory tree. It traverses all files and computes total file sizes, providing differ-ent levels of detail (depending on command line arguments) in its report.
diskusage [-v] [-b] [-k] [-m] fileOrDirName 
[fileName2 dirName3 ...]
Option for diskusage Description
-v Verbose—show each file visited and its total
-k Print size in kilobytes (1024 bytes)
-m Print size in megabytes (1024 kbytes)
a.Write a tool diskusage that prints the summary information (totals) of files
found for each argument supplied (directory or file), in kilobytes. For example:
OOP> diskusage .
30102k    .
b.Implement the options -v,-k, and -m. Check that subdirectories in the tra-
versal each have their own totals properly calculated. Compare your resultsto the *nix command 
du.
2.Use FileVisitor to implement the playlist problem that was described in
Section 8.1.1.8.1 ITERATION AND THE VISITOR PATTERN
189ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 189
CHAPTER 8: INTRODUCTION TO DESIGN PATTERNS
190
REVIEW QUESTIONS
1. What is a design pattern? What is an example of a design pattern? Why
would you use it?
2. Why does the FileVisitor need to be recursive?
3. There are three kinds of design patterns: structural, creational, and
behavioral. Which kind is the visitor? Why?
4.FileVisitor could be used to make changes to selected files. T esting
such an app would be quite risky. How would you do it?ezus_138004_ch08.qxd  8/4/06  9:42 AM  Page 190
1919CHAPTER 9
QObject
An important class to become familiar with is the one
from which all Qt Widgets are derived: QObject .
9.1 QObject’s Child Managment . . . . . . . . . . 194
9.2 Composite Pattern: Parents 
and Children . . . . . . . . . . . . . . . . . . . . . . . . 196
9.3 QApplication and the Event Loop . . . . . 2009.4 Q_OBJECT and moc: A Checklist . . . . . . . 2099.5 Values and Objects. . . . . . . . . . . . . . . . . . . 2109.6 tr() and Internationalization. . . . . . . . . . . 211ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 191
We will refer to any object of a class derived from QObject as a QObject .
Here is an abbreviated look at its definition.
class QObject {
public:
QObject(QObject* parent=0);QObject * parent () const;QString objectName() const;void setParent ( QObject * parent );const ObjectList & children () const;// ... more ...
};
The first interesting thing that we observe is that QObject ’s copy constructor is not
public .QObject s are not meant to be copied. In general, QObject s are intended
to represent unique objects with identity; that is, they correspond to real-worldthings that also have some sort of persistent identity. One immediate consequenceof not having access to its copy constructor is that a 
QObject can never be passed
by value to any function. Copying a QObject ’s data members into another
QObject is still possible, but the two objec ts are still considered unique.
One immediate consequence of not having access to its copy constructor is
that QObject s can never be passed by value to any function.
Each QObject can have (at most) one parent object and an arbitrarily large
container of QObject* children. Each QObject stores pointers to its children in
a QObjectList .1The list itself is created in a lazy-fashion to minimize the over-
head for objects which do not use it. Since each child is a QObject and can have
an arbitrarily large collection of children, it is easy to see why copying QObject s
is not permitted.
The notion of children can help to clarify the notion of identity and the no-
copy policy for QObject s. If you represent individual humans as QObject s, the
idea of a unique identity for each QObject is clear. Also clear is the idea of chil-
dren. The rule that allows each QObject to have at most one parent can be seen
as a way to simplify the implementation of this class. Finally, the no-copy policystands out as a clear necessity. Even if it were possible to “clone” a person (i.e., copy
1QObjectList is a typedef (i.e., an alias) for QList<QObject*> .ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 192
CHAPTER 9: QOBJECT
193
its data members to another QObject ), the question of what to do with the chil-
dren of that person makes it clear that the clone would be a separate and distinctobject with a different identity.
Each 
QObject parent manages its children. This means that the QObject
destructor automatically dest roys all of its child objects.
The child list establishes a bidirectional , one-to-many association between
objects. Setting the parent of one obje ct implicitly adds its address to the child list
of the other, for example
objA->setParent(objB);
adds the objA pointer to the child list of objB . If we subsequently have
objA->setParent(objC);
then the objA pointer is removed from the child list of objB and added to the
child list of objC . We call such an action reparenting .
Parent Objects versus Base Classes
Parent objects should not be confused with base classes . The parent-child
relationship is meant to describe containment, or management, of objects atruntime. The base-derived relationship is a static relationship betweenclasses determined at compile-time.
It is possible that a parent can also be an instance of a base class of some
of its child objects. These two kinds of relationships are distinct and mustnot be confused, especially considering that many of our classes will bederived directly or indirectly from 
QObject .
It is already possible to understand some of the reasons for not permitting
QObject s to be copied. For example, should the copy have the same parent as the
original? Should the copy have (in some sense) the children of the original? A shal-low copy of the child list would not work because then each of the children wouldhave two parents. Furthermore, if the copy gets destroyed (e.g., if the copy was avalue parameter in a function call), each child needs to be destroyed too. Even withresource sharing methods, this approach would introduce some serious difficul-ties. A deep copy of the child list could be a costly operation if the number of chil-dren were large and the objects pointed to were large. Since each child could alsohave arbitrarily many children, this questionable approach would also generateserious difficulties.ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 193
9.1 QObject’s Child Managment
Example 9.1 shows a QObject derived class.
EXAMPLE 9.1 src/qobject/person.h
[ . . . . ]
class Person : public QObject {
public:
Person(QObject* parent, QString name);virtual ~Person();
};
[ . . . . ]
The complete implementation is shown in Example 9.2 to show that there is no
explicit object deletion done in ~Person() .
EXAMPLE 9.2 src/qobject/person.cpp
#include "person.h"
#include <QTextStream>static QTextStream cout(stdout, QIODevice::WriteOnly);
Person::Person(QObject* parent, QString name)
: QObject(parent) {
setObjectName(name);cout << QString("Constructing Person: %1").arg(name) << endl;
}
Person::~Person() {
cout << QString("Destroying Person: %1").arg(objectName()) <<endl;
}
main() , shown in Example 9.3, creates some objects, adds them to other objects,
and then exits. All heap objects were implicitly destroyed.
EXAMPLE 9.3 src/qobject/main.cpp
#include <QTextStream>
#include "person.h"
static QTextStream cout(stdout, QIODevice::WriteOnly);CHAPTER 9: QOBJECT
194ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 194
int main(int , char**) {
cout << "First we create a bunch of objects." << endl;Person bunch(0, "A Stack Object");/* other objects are created on the heap */Person *mike = new Person(&bunch, "Mike");Person *carol = new Person(&bunch, "Carol");new Person(mike, "Greg");new Person(mike, "Peter");new Person(mike, "Bobby");new Person(carol, "Marcia");new Person(carol, "Jan");new Person(carol, "Cindy");new Person(0, "Alice");cout << "\nDisplay the list using QObject::dumpObjectTree()"
<< endl;
bunch.dumpObjectTree();cout << "\nProgram finished - destroy all objects." << endl;return 0;
}
not a pointer
We do not need to remember pointers to children, since we can reach them via objectnavigation.
Alice has no parent—memory leak?
Here is the output of this program:
First we create a bunch of objects.
Constructing Person: A Stack ObjectConstructing Person: MikeConstructing Person: CarolConstructing Person: GregConstructing Person: PeterConstructing Person: BobbyConstructing Person: MarciaConstructing Person: JanConstructing Person: CindyConstructing Person: Alice
Display the list using QObject::dumpObjectTree()
QObject::A Stack Object
QObject::Mike
QObject::GregQObject::PeterQObject::Bobby
QObject::Carol
QObject::MarciaQObject::JanQObject::Cindy3213219.1 QOBJECT’S CHILD MANAGMENT
195
continuedezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 195
CHAPTER 9: QOBJECT
196
Program finished - destroy all objects.
Destroying Person: A Stack ObjectDestroying Person: MikeDestroying Person: GregDestroying Person: PeterDestroying Person: BobbyDestroying Person: CarolDestroying Person: MarciaDestroying Person: JanDestroying Person: Cindy
Notice that Alice is not part of the dumpObjectTree() and does not get
destroyed.
EXERCISE: QOBJECT’S CHILD MANAGMENT
Add the function
void showTree(QObject* theparent)
to main.cpp.The output of this function, after all objects have been created, should
look like this:
Member: Mike - Parent: A Stack Object
Member: Greg - Parent: MikeMember: Peter - Parent: MikeMember: Bobby - Parent: MikeMember: Carol - Parent: A Stack ObjectMember: Marcia - Parent: CarolMember: Jan - Parent: CarolMember: Cindy - Parent: Carol
9.2 Composite Pattern: Parents and Children
According to [Gamma95], the Composite pattern is intended to facilitate build-
ing complex (composite) objects from simpler (component) parts by representingthe part-whole hierarchies as tree-like structures. This must be done in such a waythat clients do not need to distinguish between simple parts and more complexparts that are made up of (i.e., contain) simpler parts.
In Figure 9.1 there are two distinct classes for describing the two roles.
■A composite object is something that can contain children.
■A component object is something that can have a parent.
In Figure 9.2, we can see that QObject is both composite andcomponent. We can
express the whole-part relationship as a parent-child relationship between
QObject s. The highest level (i.e., most “composite”) QObject in such a treeezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 196
9.2 COMPOSITE PATTERN: PARENTS AND CHILDREN
197
FIGURE 9.1 Components and composites
FIGURE 9.2 QObject
(i.e., the root of the tree) will have lots of children but no parent. The simplest
QObject s (i.e., the leaf nodes of this tree) will each have a parent but no children.
Client code can recursively deal with each node of the tree.
For an example of how this pattern might be used, let’s look at Suffolk
University. In 1906 the founder, Gleason Archer, decided to start teaching the prin-ciples of law to a small group of tradesmen who wanted to become lawyers. He wasassisted by one secretary and, after a while, a few instructors. The organizationalchart for this new school was quite simple: a single office consisting of severalemployees with various tasks. As the enterprise grew, the chart gradually becamemore complex with the addition of new offices and departments. T oday, 100 yearsComponent
+ setParent(parent : Composite*)
LeafClient
CustomerComposite
+ findChildren(name : QString)
CustomerList
QObject
+ QObject(parent : QObject*)
+ ~ QObject()+ objectName() : QString+ setObjectName(name : const QString&)+ findChild(name : const QString&) : QObject*+ findChildren(name : const QString&) : QObjectList+ findChildren(re : const QRegExp&) : QObjectList+ children() : const QObjectList&+ setParent( : QObject*)+ isAncestorOf(child : const QObject*) : bool+ parent() : QObject*+children *
1
+parentezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 197
later, the Law School has been joined with a College of Arts and Sciences, a School
of Management, a School of Art and Design, campuses abroad, and many special-ized offices so that the organizational chart has become quite complex and prom-ises to become more so. Figure 9.3 shows an abbreviated and simplified subchartof today’s Suffolk University.
Each box in the chart is a component. It may be composite and have sub-
components which, in turn, may be composite or simple components. For example,the PresidentOffice has individual employees (e.g., the President and his assistants)and sub-offices (e.g., DiversityServices). The leaves of this tree are the individualemployees of the organization.
We can use the Composite pattern to model this structure. Each node of the
tree can be represented by an object of
class OrgUnit : public QObject {
public:
QString getName();double getSalary();
private:
QString m_Name;double m_Salary;
};
The QObject public interface allows us to build up a tree-like representation of
the organization with code that instantiates an OrgUnit and then calls
setParent() to add it to the appropriate child list.CHAPTER 9: QOBJECT
198
FIGURE 9.3 Suffolk University organizational chartUniversity
EnrollmentVPOffice
AdmissionsPresidentOffice
DiversityServices
AdmOfficerA AdmOfficerB
FinanceDptLawSchool
LawDeanOffice EnglishDpt
Math/CSDptSSOM
ProfD ProfCAcctDpt
ProfA ProfF ProfEDeanACAS
HistoryDptezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 198
For each OrgUnit pointer ouptr in the tree, we initialize its m_Salary data
member as follows:
■Ifouptr points to an individual employee, we use that employee’s actual
salary.
■Otherwise we initialize it to 0.
We can implement the getSalary() method somewhat like this:
double OrgUnit::getSalary() {
QList<OrgUnit*> childlst = findChildren<OrgUnit*>();double salaryTotal(m_Salary);if(!childlst.isEmpty())
foreach(OrgUnit* ouptr, childlst)
salaryTotal += ouptr->getSalary();
return salaryTotal;
}
A call to getSalary() from any particular node returns the total salary for the
part of the university represented by the subtree whose root is that node. Forexample, if
ouptr points to University ,ouptr->getSalary() returns the
total salary for the entire university. But if ouptr points to EnglishDpt , then
ouptr->getSalary() returns the total salary for the English Department.
9.2.1 Finding Children
QObject provides convenient and powerful functions named findChildren()
for finding children in the child list. The signature of one of its overloaded forms
looks like this:
QList<T> parentObj .findChildren<T> ( const QString & name) const
Ifname is an empty string, findChildren() works as a class filter by returning
a QList holding pointers to all children, which can be typecast to type T.
T o call the function, you must supply a template parameter after the function
name, as shown in Example 9.4.
EXAMPLE 9.4 src/findchildren/findchildren.cpp
[ . . . . ]
/* Filter on Customer* */
QList<Customer*> custlist = parent.findChildren<Customer*>();foreach (Customer* current, custlist) {
qDebug() << current->toString();
}
[ . . . . ]9.2 COMPOSITE PATTERN: PARENTS AND CHILDREN
199ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 199
9.3 QApplication and the Event Loop
Interactive Qt applications with GUI have a different control flow from console
applications and filter applications2because they are event-based, and often multi-
threaded. Objects are frequently sending messages to each other, making a linearhand-trace through the code rather difficult.
Observer Pattern
When writing event-driven programs, GUI views need to respond to changes
in the state of data model objects, so that they can display the most recentinformation possible.
When a particular subject object changes state, it needs an indirect way
to alert (and perhaps send additional information to) all the other objectsthat are listening to state-change events, known as observers. A design pat-tern that enables such a message-passing mechanism is called the Observer
pattern , sometimes also known as the Publish-Subscribe pattern.
There are many different implementations of this pattern. Some common
characteristics that tie them together are
1. They all enable concrete subject classes to be decoupled from
concrete observer classes.
2. They all support broadcast-style (one to many) communication.3. The mechanism used to send information from subjects to observers is
completely specified in the subject’s base class.
Qt’s approach is very different from Java’s approach, because signals and slots
rely on generated code, while Java just renames observer to listener.
The Qt class QEvent encapsulates the notion of an event. QEvent is the base class
for several specific event classes such as QActionEvent ,QFileOpenEvent ,
QHoverEvent ,QInputEvent ,QMouseEvent , and so forth. QEvent objects
can be created by the window system in response to actions of the user (e.g.,
QMouseEvent ) at specified time intervals ( QTimerEvent ) or explicitly by an
application program. The type() member function returns an enum that has
nearly a hundred specific values that can identify the particular kind of event.
A typical Qt program creates objects, co nnects them, and then tells the applica-
tion to exec() . At that point, the objects can send information to each other in aCHAPTER 9: QOBJECT
200
2A filter application is not interactive. It simply reads from standard input and writes to standard
output.ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 200
variety of ways. QWidgets send QEvents to other QObjects in response to user
actions such as mouse clicks and keyboard  events. A widget can also respond to
events from the window manager such as repaints, resizes, or close events.Furthermore,
QObjects can transmit information to one another by means of sig-
nals and slots.
Each QWidget can be specialized to handle keyboard and mouse events in its
own way. Some widgets will emit a signal in response to receiving an event.
An event loop is a program structure that permits events to be prioritized,
enqueued, and dispatched to objects. Writing an event-based application meansimplementing a passive interface of functions that only get called in response to
certain events. The event loop generally continues running until a terminatingevent occurs (e.g., the user c licks on the QUIT button).
Example 9.5 shows a simple application that initiates the event loop by calling
exec() .
EXAMPLE 9.5 src/eventloop/main.cpp
[ . . . . ]
int main(int argc, char * argv[]) {
QApplication myapp(argc, argv);
QWidget rootWidget;
setGui(&rootWidget);
rootWidget.show();
return myapp.exec();
};
Every GUI, multithreaded, or event-driven Qt Application must have a QApplication object
defined at the top of main().
Show our widget on the screen.
Enter the event loop.
When we run this app, we first see a widget on the screen as shown in the following
figure.3213219.3 QAPPLICATION AND THE EVENT LOOP
201
ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 201
We can type in the QTextEdit on the screen, or click on the Shout button. When
Shout is clicked, a widget is superimposed on our original widget as shown in thenext figure.CHAPTER 9: QOBJECT
202
This message dialog knows how to self-destruct, because it has its own buttons and
actions.
9.3.1 Layouts: A First Look
Whenever more than a single widget needs to be displayed, they must be arranged
in some form of a layout (see Section 11.5). Layouts are derived from the abstract
base class,QLayout , which is derived from QObject . Layouts are geometry man-
agers that fit into the composition hierarchy of a graphical interface. Typically, westart with a widget that will contain all of the parts of our graphical construction.We select one or more suitable layouts to be children of our main widget (or ofone another) and then we add widgets to the layouts.
It is important to understand that widgets in a layout are not children of
the layout—they are children of the widget that owns the layout. Only awidget can be the parent of another widget. It may be useful to think of
the layout as an older sibling acting as the nanny of its widgets.
In Example 9.6, we are laying out widgets in a vertical fashion with QVBoxLayout .
EXAMPLE 9.6 src/eventloop/main.cpp
[ . . . . ]
QWidget* setGui(QWidget *box) {
QLayout* layout = new QVBoxLayout;box->setLayout(layout);
QTextEdit *te = new QTextEdit;
layout->addWidget(te);
321ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 202
te->setHtml("Some <b>text</b> in the <tt>QTextEdit</tt>"
"edit window <i>please</i>?");
QPushButton *quitButton=new QPushButton("Quit");
layout->addWidget(quitButton);
QPushButton *shoutButton = new QPushButton("Shout");
layout->addWidget(shoutButton);
Messager *msgr = new Messager("This dialog will self-
destruct.", box);
QObject::connect(quitButton, SIGNAL(clicked()),
qApp, SLOT(quit())); 49.3 QAPPLICATION AND THE EVENT LOOP
203
connect() is actually a static member of QObject and can be called with any
QObject or, as we showed, by means of its class scope resolution operator. qApp
is a global pointer that points to the currently running QApplication .
The second connect goes to a slot that we declare in Example 9.7.
EXAMPLE 9.7 src/eventloop/messager.h
#ifndef MESSAGER_H
#define MESSAGER_H
#include <QObject>
#include <QString>#include <QErrorMessage>QObject::connect(quitButton, SIGNAL(clicked()), qApp, SLOT(quit()));
qApp->connect(shoutButton, SIGNAL(clicked()), msgr, SLOT(shout()));
continuedqApp->connect(shoutButton, SIGNAL(clicked()), msgr, SLOT(shout()));
return box;
}
box is the parent of layout.
This is the window for qDebug messages.te is the child of layout.
qApp is a global variable that points to the current QApplication object.
The widgets are arranged vertically in this layout, from top to bottom, in the order
that they were added to the layout.
9.3.2 Connecting to Slots
In Example 9.7, we saw the following connections established:4321ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 203
class Messager : public QObject {
Q_OBJECT
public:
Messager (QString msg, QWidget* parent=0);
public slots:
void shout();
private:
QWidget* m_Parent;QErrorMessage* message;
};
#endif
Declaring a member function to be a slot enables it to be connected to a signal
so that it can be called passively in response to some event. For its definition,
shown in Example 9.8, we have kept things quite simple: the shout() function
simply pops up a message box on the screen.
EXAMPLE 9.8 src/eventloop/messager.cpp
#include "messager.h"
Messager::Messager(QString msg, QWidget* parent)
: m_Parent(parent) {
message = new QErrorMessage(parent);setObjectName(msg);
}
void Messager::shout() {
message->showMessage(objectName());
}
9.3.3 Signals and Slots
When the main thread of a C++ program calls qApp->exec() , it enters into an
event loop, where messages are handled and dispatched. While qApp is executing
its event loop, it is possible for QObject s to send messages to one another.
Asignal is a message that is presented in a class definition like a void function
declaration. It has a parameter list but no function body. A signal is part of the inter-face of a class. It looks like a function but it cannot be called—it must be emitted by
an object of that class. A signal is implicitly
protected , and so are all the identifiers
that follow it in the class definition until another access specifier appears.
A slot is a void member function. It can be called as a normal member
function.CHAPTER 9: QOBJECT
204ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 204
A signal of one object can be connected to the slots of one or more3other objects,
provided the objects exist and the parameter lists are assignment compatible4from
the signal to the slot. The syntax of the connect statement is:
bool QObject::connect(senderqobjptr,
SIGNAL(signalname(argtypelist)),receiverqobjptr,SLOT(slotname(argtypelist))optionalConnectionType);
Any QObject that has a signal can emit that signal. This will result in an indirect
call to all connected slots.
QWidgets already emit signals in response to events, so you only need to make
the proper connections to receive those signals. Arguments passed in the emit
statement are accessible as parameters in the slot function, similar to a functioncall, except that the call is indirect. The argument list is a way to transmit infor-mation from one object to another.
Example 9.9 defines a class that uses signals and slots to transmit a single 
int
parameter.
EXAMPLE 9.9 src/widgets/sliderlcd/sliderlcd.h
[ . . . . ]
class QSlider;class QLCDNumber;class LogWindow;class QErrorMessage;
class SliderLCD : public QMainWindow {
Q_OBJECT
public:
SliderLCD(int minval = -273, int maxval = 360);void initSliderLCD();
public slots:
void checkValue(int newValue);void showMessage();
signals:
void toomuch();
private:
int m_Minval, m_Maxval;LogWindow* m_LogWin;QErrorMessage *m_ErrorMessage;9.3 QAPPLICATION AND THE EVENT LOOP
205
3Multiple signals can be connected to the same slot also.
4Same number of parameters, each one being assignment compatible.continuedezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 205
QLCDNumber* m_LCD;
QSlider* m_Slider;
};#endif
[ . . . . ]
In Example 9.10, we can see how the widgets are initially created and connected.
EXAMPLE 9.10 src/widgets/sliderlcd/sliderlcd.cpp
[ . . . . ]
SliderLCD::SliderLCD(int min, int max) : m_Minval(min),
m_Maxval(max) {
initSliderLCD();
}
void SliderLCD::initSliderLCD() {
m_LogWin = new LogWindow();QDockWidget *logDock = new QDockWidget("Debug Log");logDock->setWidget(m_LogWin);logDock->setFeatures(0);setCentralWidget(logDock);
m_LCD = new QLCDNumber();
m_LCD->setSegmentStyle(QLCDNumber::Filled);QDockWidget *lcdDock = new QDockWidget("LCD");lcdDock->setFeatures(QDockWidget::DockWidgetClosable);lcdDock->setWidget(m_LCD);addDockWidget(Qt::LeftDockWidgetArea, lcdDock);
m_Slider = new QSlider( Qt::Horizontal);
QDockWidget* sliderDock = new QDockWidget("How cold is it
today?");
sliderDock->setWidget(m_Slider);sliderDock->setFeatures(QDockWidget::DockWidgetMovable);/* Can be moved between doc areas */addDockWidget(Qt::BottomDockWidgetArea, sliderDock);
m_Slider->setRange(m_Minval, m_Maxval);
m_Slider->setValue(0);m_Slider->setFocusPolicy(Qt::StrongFocus);m_Slider->setSingleStep(1);m_Slider->setPageStep(20); m_Slider->setFocus();
connect(m_Slider, SIGNAL(valueChanged(int)),  /*SliderLCD is a
QObject so
connect does not need scope resolution. */
this, SLOT(checkValue(int)));
654321CHAPTER 9: QOBJECT
206ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 206
connect(m_Slider, SIGNAL(valueChanged(int)),
m_LCD, SLOT(display(int)));
connect(this, SIGNAL(toomuch()),
this, SLOT(showMessage()));
m_ErrorMessage = NULL;
}
a class defined in the utils library
cannot be closed, moved, or floatedcan be closedStep each time left or right arrow key is pressed.Step each time PageUp/PageDown key is pressed.Give the slider focus.
Normally there is no point in connecting a signal to a slot on the same object, but we do it for
demonstration purposes.
Only the argument types belong in the connect statement; for example, the fol-
lowing is not legal:765432179.3 QAPPLICATION AND THE EVENT LOOP
207
connect( button, SIGNAL(valueChanged(int)), lcd, SLOT(setValue(3)))
Example 9.11 defines the two slots, one of which conditionally emits another
signal.
EXAMPLE 9.11 src/widgets/sliderlcd/sliderlcd.cpp
[ . . . . ]
void SliderLCD::checkValue(int newValue) {
if (newValue> 120) {
emit toomuch();
}
}
/* This slot is called indirectly via emit because
of the connect */
void SliderLCD::showMessage() {
if (m_ErrorMessage == NULL) {
m_ErrorMessage = new QErrorMessage(this);
}if (!m_ErrorMessage->isVisible()) {
QString message("Too hot outside! Stay in. ");m_ErrorMessage->showMessage(message);
}
}
Emit a signal to anyone interested.
This is a direct call to a slot. It’s a member function.
Example 9.12 contains client code to test this class.2121ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 207
CHAPTER 9: QOBJECT
208
EXAMPLE 9.12 src/widgets/sliderlcd/sliderlcd-demo.cpp
#include "sliderlcd.h"
#include <QApplication>#include <QDebug>
int main(int argc, char ** argv) {
QApplication app(argc, argv);SliderLCD slcd;slcd.show();qDebug() << QString("This is a debug message.");return app.exec();
}
Whenever the slider produces a new value, that value is transmitted as an argu-
ment from the valueChanged(int) signal to the display(int) slot of
the lcd.
Synchronous or Asynchronous?
In single-threaded applications, or in multithreaded applications where the
emitting and receiving QObject s are in the same thread, signals are sent in
a synchronous manner. This means the thread blocks (suspends execution)
until the code for the slots has completed execution (see Section 12.2).
In multi-threaded applications, where signals are emitted by an object in
one thread and received by an object in another, it is possible to have signalsqueued, or executed in an asynchronous way, depending on the optional
Qt::ConnectionType passed to connect() .
EXERCISES: SIGNALS AND SLOTS
1.Modify the sliderlcd program as follows:
■Make the lcd display show the temperatures as hexadecimal integers.
■Make the lcd display characters have a different (“flat”) style.ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 208
9.4 Q_OBJECT AND MOC: A CHECKLIST
209
■Give the slider a vertical orientation.
■Give the slider and the lcd display more interesting colors.
■Add a push button that the user can click to switch the lcd display from dec-
imal mode to hexadecimal mode.
■Make the push button into a toggle that allows the user to switch back andforth between decimal and hexadecimal modes.
2.Write an application, similar to the one in Section 9.3, but that has four buttons.
The first one, labeled Advice, should be connected to a slot that randomlyselects a piece of text (such as a fortune cookie) and displays it in the
QTextEdit window.The second one, labeled Weather, randomly selects a sen-
tence about the weather and displays it in the QTextEdit window. The third
one, labeled Next Meeting, pops up a message dialog with a randomly gener-ated (fictitious) meeting time and descriptive message in it. The fourth one,labeled Quit, terminates the program. Use signals and slots to connect the but-ton clicks with the appropriate functions.
9.4 Q_OBJECT and moc: A Checklist
QObject supports features not normally available in C++ objects.
■Children (see the first two sections of Chapter 9)
■Signals and slots (see Section 9.3.3)
■MetaObjects, metaproperties, metamethods (see Chapter 15)
■qobject_cast (see Section 15.3)
These features are only possible through the use of generated code. The Meta
Object Compiler, moc, generates additional functions for each QObject -derived
class that uses the macro. Generated code can be found in files with names
moc_filename.cpp .
This means that some errors from the compiler/linker may be confuscated5
when moc is not able to find or process your classes. T o help ensure that moc
processes each of your QObject -derived classes, here are some guidelines for
writing C++ code and qmake project files.
■Each class definition should go in its own .h file.
■Its implementation should go in a corresponding .cpp file.
■The header file should be “ #ifndef wrapped” to avoid multiple inclusion.
■Each source (.cpp) file should be listed in the SOURCES variable of the
project file, otherwise it will not be compiled.
5confusing + obfuscatedezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 209
■The header file should be listed in the HEADERS variable of the .pro file.
Without this, moc will not preprocess the file.
■The Q_OBJECT macro must appear inside the class definition, so that
moc will know to generate code for it.
MUL TIPLE INHERITANCE AND QOBJECT Because each Q_OBJECT
has signals and slots, it needs to be preprocessed by moc .moc works
under the assumption that you are only deriving from QObject once,
and further,that it is the first base class in the list of base classes.If you acci-
dentally inherit from QObject multiple times, or if it is not the first base
class in the inheritance list, you may receive very strange errors from moc-
generated code.
9.5 Values and Objects
We can divide C++ types into two categories: value types and object types.
Instances of value types are relatively “simple”: They occupy contiguous mem-
ory space, and can be copied or compared quickly. Examples of value types are
Anything* ,int,char ,QString ,QDate , and QVariant .
Instances of object types , on the other hand, are typically more complex and
maintain some sort of identity. Object types are rarely copied (cloned). If cloningis permitted, the operation is usually expensive and results in a new object (graph)that has a separate identity from the original.
The designers of
QObject asserted an unequivocal “no copy” policy by desig-
nating its assignment operator and copy constructor private . This effectively
prevents the compiler from generating assignment operators and copy construc-tors for 
QObject -derived classes. One consequence of this scheme is that any
attempt to pass or return QObject -derived classes by value to or from functions
results in a compile-time error.
EXERCISES: QOBJECT
1.Rewrite the Contact and ContactList from “Exercise: Contact List”in Chapter 4 so
that they both derive from QObject .
When a Contact is to be added to a ContactList, make the Contact the child
of the ContactList.
2.Port the client code you wrote for “Exercise: Contact List” to use the new
versions of Contact and ContactList.CHAPTER 9: QOBJECT
210ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 210
9.6 TR() AND INTERNATIONALIZATION
211
9.6 tr( ) and Internationalization
If you are writing a program that will ever be translated into another language
(internationalization) , Qt Linguist and Qt translation tools have already solved
the problem of how to organize and where to put the translated strings. T o prepareour code for translation, we use 
QObject::tr() to surround any translatable
string in our application. The tr() function is generated for every QObject and
places its international strings in its own “namespace,” which has the same nameas the class.
tr() serves two purposes:
1. It makes it possible for Qt’s lupdate tool to extract all of the translat-
able string literals.
2. If a translation is available, and the language has been selected, the
strings will actually be translated into the selected language at runtime.
If no translation is available, tr() returns the original string.
It is important that each translatable string is indeed fully inside the
tr() function and extractable at compile time. For strings with parame-
ters, use the QString::arg() function to place parameters inside
translated strings. For example,
statusBar()->message
(tr("%1 of %2 complete. progress: %3%%").arg(processed).arg(total).arg(percent));
This way, translations can place the parameters in different order in situ-
ations where language changes the order of words/ideas.
For a much more complete guide to internationalization, we recommend
[Blanchette06], written by one of Linguist’s lead developers.
POINT OF DEPARTURE
There are other open-source implementations of signals and slots, similar to theQt 
QObject model. One is called xlobject (available at http://sourceforge.net/
projects/xlobject). In contrast to Qt, it does not require any moc-style preprocess-
ing, but instead relies heavily on templates, so it is only supported by modern (post-2002) C++ compilers. The boost library (available from http://www.boost.org)
also contains an implementation of signals and slots.ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 211
CHAPTER 9: QOBJECT
212
REVIEW QUESTIONS
1. What does it mean when object A is the parent of object B?
2. What happens to a QObject when it is reparented?
3. Why is the copy constructor of QObject not public?
4. What is the composite pattern?5. How can 
QObject be both composite and component?
6. How can you access the children of a QObject ?
7. What is an event loop? How is it initiated?8. What is a signal? How do you call one?9. What is a slot? How do you call one?
10. How are signals and slots connected?11. How can information be transmitted from one object to another?12. Deriving a class from 
QObject more than once can cause problems.
How might that happen accidentally?
13. What is the difference between value types and object types? Give
examples.
ezus_138004_ch09.qxd  8/4/06  9:43 AM  Page 212
10.1 Generics and Templates . . . . . . . . . . . . . 214
10.2 Containers . . . . . . . . . . . . . . . . . . . . . . . . . 21910.3 Managed Containers, Composites,
and Aggregates . . . . . . . . . . . . . . . . . . . . 221
10.4 Implicitly Shared Classes . . . . . . . . . . . . 22410.5 Generics, Algorithms, and Operators. . 22510.6 Serializer Pattern . . . . . . . . . . . . . . . . . . . 22710.7 Sorted Map Example . . . . . . . . . . . . . . . . 22910CHAPTER 10
Generics and Containers
This chapter covers more deeply the subject ofgenerics. Generics are classes and functions that canoperate just as easily on objects as primitive types. Qtcontainer classes are generic, template-based classes,and we will see examples using lists, sets, and maps.Operators,managed containers,and resource sharingare also discussed.
213ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 213
10.1 Generics and Templates
C++ supports four distinct categories of types:
1. Primitives: int,char ,float ,double ,e t c .
2. Pointers3. Instances of
class/struct
4. Arrays
Because there is no common base type for these four distinct type categories, writ-
ing generic functions and classes that can operate on multiple type categorieswould be very difficult without the use of templates . T emplates provide a means
for C++ to generate different versio ns of classes and functions with parameterized
types and common behavior. They are distinguished by the use of the keyword
template , and a template parameter enclosed in angle brackets <>.
A template parameter differs from a function parameter in that it can be used
to pass not only variables and values, but also type expressions.
template <class T> class String { ... }; 
template <class T, int max > Buffer { ...
T v[max]; 
};String <char> s1;Buffer <int, 10> intBuf10;
10.1.1 Function Templates
Function templates are used to create type-checked functions which all work on
the same pattern. Example 10.1 defines a template function that raises a value oftype Tto the power expby repeatedly applying the 
operator*= .
EXAMPLE 10.1 src/templates/template-demo.cpp
[ . . . . ]
template <class T> T power (T a, int exp) {
T ans = a;while (--exp > 0) {
ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 214
ans *= a;
}return (ans);
}
When the function is called, as shown in Example 10.2, different function bod-
ies will be automatically generated by the compiler based on the argument typessupplied in the function call. Even though the word 
class is in the template
parameter, we can supply a class or a primitive type for T. The only limitation on
the type Tis that it must be a type for which the operator*= is defined.
EXAMPLE 10.2 src/templates/template-demo.cpp
[ . . . . ]
int main() {
Complex z(3,4), z1;Fraction f(5,6), f1;int n(19);z1 = power(z,3);f1 = power(f,4);z1 = power<Complex>(n, 4);z1 = power(n,5);
}
First instantiation T is Complex.
Second instantiation T is Fraction.
Supply an explicit template parameter if the actual argument is not “specific” enough. Thisresults in a call to a function that was already instantiated.
Which version gets called?
Each time the compiler sees a template function used for the first time with a spe-
cific combination of parameter types, we say the template is instantiated .
Subsequent uses of of power(Complex,int) or power(Fraction,int) will
be translated into ordinary function calls.
EXERCISES: FUNCTION TEMPLA TES
1.Complete Example 10.2. In particular, write a generic Complex and Fraction
class, and fix main() so that it works and uses those classes.
2.Write a template version of swap() , based on Example 5.13. Write client code
to test it thoroughly.4321432110.1 GENERICS AND TEMPLATES
215ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 215
3.Are there any types for which swap() does not work?
4.Specify the restrictions on the class parameter in your template swap function.
10.1.2 Class Templates
Like functions, classes can also use parameterized types. Class templates are used
to generate generic containers of data. The parameter is the answer to the ques-tion, “Container of what?” All Qt container classes and, of course, all classes in theStandard T emplate Library (STL) are parameterized.
We will discuss a homemade example of a template stack class. Figure 10.1
shows a UML diagram of two template classes.CHAPTER 10: GENERICS AND CONTAINERS
216
FIGURE 10.1 Template-based stack
UML locates the template parameter in a small offset box in the upper-right cor-
ner of the class box. Example 10.3 contains definitions for these classes.
EXAMPLE 10.3 src/collections/stack/stack.h
[ . . . . ]
#include <qstd.h>
template<class T> class Node {
public:
Node(T invalue): m_Value(invalue), m_Next(0) {}~Node() ;Node
 - mValue : T
 - mNext : Node<t>*
+ Node(val : T)
+ ~Node()+ getValue() : T+ setValue(value : T)+ getNext() : Node<t>*+ setNext(next : Node<t>*)
Stack
 - mHead : Node<t>*
 - mCount : int
+ Stack()
+ ~Stack()+ push(t : const T&)+ pop() : T+ top() : T+ count() : intT
Tezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 216
T getValue() const {return m_Value;}
void setValue(T value) {m_Value = value;}Node<T>* getNext() const {return m_Next;}void setNext(Node<T>* next) {m_Next = next;}
private:
T m_Value;Node<T>* m_Next;
};
template<class T> Node<T>::~Node() {
using namespace qstd;cout << m_Value << " deleted " << endl;if(m_Next) {
delete m_Next; 
}
}
template<class T> class Stack {
public:
Stack(): m_Head(0), m_Count(0) {}~Stack<T>() {delete m_Head;} void push(const T& t);T pop();T top() const;int count() const;
private:
Node<T> *m_Head;int m_Count;
};
Notice that template definitions, shown in Example 10.4 (classes and functions),
appear in the header file. This is necessary for the compiler to generate code froma template declaration. Also notice the re quired template declaration code,
template<class T> . This code must precede each class or function definition
that has a template parameter in its name.
EXAMPLE 10.4 src/collections/stack/stack.h
[ . . . . ]
template <class T> void Stack<T>::push(const T& value) {
Node<T> *newNode = new Node<T>(value);newNode->setNext(m_Head);m_Head = newNode;++m_Count;
}
template <class T>  T Stack<T>::pop() {
Node<T> *popped = m_Head;if (m_Head != 0) {10.1 GENERICS AND TEMPLATES
217
continuedezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 217
m_Head = m_Head->getNext();
T retval = popped->getValue();popped->setNext(0);
delete popped;--m_Count;return retval;
}return 0;
}
The creation of objects is handled generically in the template function, push() .
The destructor for the Node<T> class recursively deletes Node pointers until it
reaches one with a zero m_Next pointer.1Controlling creation and destruction of
Node<T> objects this way enables Stack<T> to completely manage its dynamic
memory. Example 10.5 contains some client code to demonstrate these classes.
EXAMPLE 10.5 src/collections/stack/main.cpp
#include <QDebug>
#include <QString>#include "stack.h"
int main() {
Stack<int> intstack1, intstack2;int val;for(val = 0; val < 4; ++val) {
intstack1.push(val);intstack2.push(2 * val);
}while (intstack1.count()) {
val = intstack1.pop();qDebug() << val;
}Stack<QString> stringstack;stringstack.push("First on");stringstack.push("second on");stringstack.push("first off");QString val2;while (stringstack.count()) {
val2 = stringstack.pop();qDebug() << val2;
}qDebug() << "Now intstack2 will self destruct.";return 0;
}CHAPTER 10: GENERICS AND CONTAINERS
218
1This is a consequence of the fact that calling delete on a pointer automatically invokes the destruc-
tor associated with that pointer.ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 218
Output:
3 deleted
32 deleted21 deleted10 deleted0first off deleted"first off"second on deleted"second on"First on deleted"First on"Now intstack2 will self destruct.6 deleted4 deleted2 deleted
0 deleted
EXERCISES: CLASS TEMPLA TES
1.Place the function definitions for Stack in a separate file ( stack.cpp ), mod-
ify the project file appropriately, and then build the app. Explain the results.
2.How general is this application (i.e., what conditions must the class Tsatisfy in
order to be used here)?
3.What limits the size of a Stack<T> ?
4.Write a template Queue<T> class and client code to test it.
10.2 Containers
Qt’s container classes are used to collect value types (things that can be copied),
including pointers to object types (but  not object types themselves). Qt contain-
ers are defined as template classes which leave the collected type unspecified. Eachdata structure is optimized for different kinds of operations. In Qt 4, there areseveral template container classes to choose from.
■QList <T>is implemented using an array, with space preallocated at
both ends. It is optimized for index-based random access and, for listswith less than a thousand items, it also gives good performance withoperations like prepend() and append().10.2 CONTAINERS
219ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 219
■QStringList is a convenience class that is derived from
QList<QString> .
■QLinkedList <T>is optimized for sequential access with iterators and
quick, constant-time inserts anywhere in the list. Sorting and searching areslow. It has several convenience functions for frequently used operations.
■QVector <T>stores its data in contiguous memory locations and is
optimized for random access by index. Generally, QVector objects are
constructed with an initial size. There is no automatic preallocation ofmemory at either end, so insertions, ap pends, and prepends are expensive.
■QStack <T>is publicly derived from QVector <T>, so the public
interface of QVector is available to QStack objects. However, the 
last-in-first-out semantics are implemented by the push() ,pop() ,
and top() functions.
■QMap <Key, T >is an ordered associative container that stores (key,
value) pairs and is designed for fast lookup of the value associated with a key and for easy insertions. It keeps its keys in sorted order, for fastsearching and subranging, by means of a skip-list dictionary
2that is
probabilistically balanced and uses memory very efficiently. The Key
type must have an operator<() and operator==() .
■QHash <Key, T >is an associative container that uses a hash table to
facilitate key lookups. It provides very fast lookups (exact key match)and insertions, but slow searching and no sorting. The 
Key type must
have an operator==() .
■QMultiMap <Key, T >is a subclass of QMap , and QMultiHash <Key, T >
is a subclass of QHash . These two classes allow multiple values to be
associated with a single key.
■QCache <Key, T >is also an associative container but it provides fastest
access to recently used items and automatic removal of infrequently useditems based on cost functions.
■QSet <T>stores values of type T using a QHash with keys in T and a
dummy value associated with each key. This arrangement optimizeslookups and insertions.
QSet has functions for the usual set operations
(e.g., union, intersection, set difference, etc.). The default constructorcreates an empty set.
A type parameter T for a template container class or key type for an associative
container must be an assignable data type (i.e., a value type; see Section 9.5) .ThisCHAPTER 10: GENERICS AND CONTAINERS
220
2ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdfezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 220
means that it must have a public default constructor, copy constructor, and assign-
ment operator.
Basic types (e.g., int, double, char, etc.) and pointers are assignable. Some Qt
types are assignable (e.g., QString ,QDate ,QTimer ).QObject and types derived
from QObject are not assignable . If you need to group objects of some non-
assignable type, you can define a container of pointers, e.g., QList<QFile*> .
10.3 Managed Containers, Composites,
and Aggregates
Value containers are containers of uniform (same-typed) values, for example,
QString ,byte ,int,float , etc. Pointer containers are containers of pointers to
(polymorphic commonly typed) objects. They can be managed or unmanaged .
Both kinds of containers can grow at runtime by allocating additional heap
memory as needed. This is always done in an exception-safe way, so you don’t needto worry about possible memory leaks.
In the case of pointer containers to heap objects, however, one must decide
which class is responsible for managing the heap objects. UML diagrams can dis-tinguish between managed and unmanaged containers by using composite (filled
diamond) and aggregate (empty diamond) connectors, as shown in Figure 10.2.10.3 MANAGED CONTAINERS, COMPOSITES, AND AGGREGATES
221
FIGURE 10.2 Aggregates and compositions
In general, we can say that a managed container is a composite, because the con-
tainer manages its pointed-to objects. In other words, when a composite isdestroyed, it destroys (cleans up) its enti re self (because the smaller objects are
part of its composition).
When one object embeds another as a sub-object, it is also considered a
composition.
In Figure 10.2, there are two kinds of
Customer containers, CustomerList
and CustDb .CustDb and CustomerList both reuse template containers.QList<Customer*>
CustomerList Customer CustDb
AddressQObjectezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 221
CustomerList objects are aggregates—temporary structures to hold the results
o faq u e r y ,o rau s e rs e l e c t i o n . CustDb , on the other hand, is a singleton composite
that manages all of the Customer objects that exist.
In the case of the Customer and Address relationship, this diagram indi-
cates that one or more Address objects should be associated with a particular
Customer . When the Customer object is destroyed, it is reasonable to destroy all
of its Address objects at the same time. Thus, the Customer object manages its
Addresses , which gives us another example of a composite relationship.
This suggested design does impose some limitations on possible use of
Address ; in particular, there is no easy way to find all customers at a
particular address. If Address and Customer were independently
managed, then we could form bidirectional relationships between the
classes.
Typically, a managed container deletes any heap objects it “owns” when the con-
tainer itself is destroyed. With a Qt container of pointers, one can use
qDeleteAll(container) , an algorithm that calls delete on each element in
the container.
Copying a managed container can be defined in a number of ways:
■For some containers, the feature might be disabled.
■For others, it might be called a deep copy, where all contained objects arecloned and placed in the new container.
■Another approach, taken with the design of Qt containers, is implicitsharing, explained in the next section.
When a container only provides an indexing or reference navigation mechanism
to its objects we call it an aggregate container .
In this case, the container does not manage its objects, it only provides a con-
venient way to access them. When an aggregate container is copied, only referencesto the collected objects are copied. When an aggregate container is deleted, onlythe references are removed. There is no impact on the underlying objects in thecontainer.
A managed container is a composition, and an unmanaged container of
objects is usually (but not always) represented in a UML diagram as
aggregation.CHAPTER 10: GENERICS AND CONTAINERS
222ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 222
EXERCISE: MANAGED CONTAINERS,
COMPOSITIONS AND AGGREGA TES
This exercise involves designing some data types to represent a deck and a hand
of cards. The following UML diagram suggests one way of representing them.10.3 MANAGED CONTAINERS, COMPOSITES, AND AGGREGATES
223
Here are some hints:
■The CardDeck constructor generates a complete deck of 52 cards in a con-
venient order.
■CardDeck::deal(int k) should use the random() function from
<stdlib.h> to pick kcards from the deck (removing each one from the deck
after it is picked) to fill a CardHand object.
■Initialize the random() function from the system clock so that the results will bedifferent each time you run the app. The syntax is
srandom(time(0));Card
 - mFaceNbr : int
 - mSuitNbr : QString - smFaces : QStringList - smSuits : QStringList
+ Card(faceNbr : int, suitNbr : int)+ toString() : QString+ getFace() : QString+ setFaceNbr(faceNbr : int)+ getSuit() : QString+ setSuitNbr(suitNbr : int)+ getValue() : intCardDeck
+ CardDeck()+ deal(handSize : int) : Hand+ toString() : QString+ getCardsLeft() : int+ restoreDeck()+ shuffle()CardHand
+ getValue() : int+ toString() : QStringQList<Card>ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 223
■Evaluate the hand using the rules of the game of bridge: Ace /H110054, King /H110053,
Queen /H110052, Jack /H110051; all other cards have zero value. Use this formula to calcu-
late the return values for the getValue() functions.
■Example 10.6 gives a piece of client code that you can start with for testing.
EXAMPLE 10.6 src/cardgame/datastructure/cardgame-client.cpp
#include "carddeck.h"
#include <qstd.h>using namespace qstd;
int main() {
CardDeck deck;CardHand hand;int handSize, playerScore, progScore;cout << "How many cards in a hand? " << flush;handSize = promptInt();do {
hand = deck.deal(handSize);cout << "Here is your hand:" << endl;cout << hand.toString() << endl;playerScore = hand.getValue();cout << QString("Your score is: %1 points.")
.arg(playerScore) << endl;
// Now a hand for the dealer:hand = deck.deal(handSize);progScore = hand.getValue();cout << "Here is my hand:" << endl;cout << hand.toString() << endl;cout << QString("My score is: %1 points.")
.arg(progScore) << endl;
cout << QString("%1 win!!")
.arg((playerScore > progScore)?"You":"I") << endl;
} while(more("hand"));
}
for cout, endl, and more()
10.4 Implicitly Shared Classes
A hybrid kind of managed container is the implicitly shared container. Container
classes in the Qt library implement “lazy copy on write,” or implicit sharing . This
means they have reasonably fast3copy constructors and assignment operators.
Only when the copy is actually modified are the collected objects cloned from theoriginal container. That is when there will be a time/memory penalty.11CHAPTER 10: GENERICS AND CONTAINERS
224
3Operations should be “not much slower” than the time it takes to do one pointer-copy and one
integer increment.ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 224
QString and QStringList are both implemented this way, meaning that it
is fast to pass and return these objects by value. If you need to change values storedin the container from inside a function, you can pass the container by reference. Itis still faster to pass by 
const reference, which allows C++ to optimize out the
copy operation entirely. With const reference, the function cannot make changes
to the container at all.
Implicitly shared classes work by reference-counting, to prevent the accidental
deletion of shared managed objects. Since implicitly shared memory is encapsu-lated, the user of the class does not need to be concerned with reference counts ordirect memory pointers.
We look in more detail at the implementation of a reference counted class in
Section 24.2.
10.5 Generics, Algorithms, and Operators
Overloading operator symbols makes it p ossible to define a common interface for
our classes that is consistent with that of the basic types. Many generic algorithmstake advantage of this by using the common operators to perform basic functionssuch as comparison.
The
qSort() function is a generic algorithm that is implemented using the heap
sort algorithm. In Example 10.7, we show how it can be used on two similar butdifferent containers.
qSort() can be applied to any Qt container of objects that have publicly
defined functions operator<() and operator==() . Containers of built-in
numeric types can also be sorted with this function.
EXAMPLE 10.7 src/collections/sortlist/sortlist4.cpp
#include <QList>
#include <assertequals.h>#include <QtAlgorithms>    // for qSort()#include <qstd.h>        // for cin and coutusing namespace qstd;
class CaseIgnoreString : public QString {
public:
CaseIgnoreString(const QString& other = QString()) :QString(other) {}10.5 GENERICS, ALGORITHMS, AND OPERATORS
225
continuedezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 225
bool operator<(const QString & other) const {
return toLower() < other.toLower();
}bool operator==(const QString& other) const {
return toLower() == other.toLower();
}
};
int main() {
CaseIgnoreString s1("Apple"), s2("bear"), 
s3 ("CaT"), s4("dog"), s5 ("Dog");
ASSERT_TRUE(s4 == s5);
ASSERT_TRUE(s2 < s3);ASSERT_TRUE(s3 < s4);
QList<CaseIgnoreString> namelist;namelist << s5 << s1 << s3 << s4 << s2;qSort(namelist.begin(), namelist.end());
int i=0;foreach (QString stritr, namelist) {
cout << QString("namelist[%1] = %2")
.arg(i++).arg(stritr) << endl;
}
QStringList strlist;
strlist << s5 << s1 << s3 << s4 << s2;
qSort(strlist.begin(), strlist.end());
cout << "StringList sorted: " + strlist.join(", ") << endl;return 0;
}
Insert all items in an order that is definitely not sorted.
The value collection holds QString, but we are adding CaseIgnoreString. A conversion is
required.
operator<<() , which is the left shift operator from C, has been overloaded in
the QList class to append items to the list.
Example 10.8 shows the output of this program.
EXAMPLE 10.8 src/collections/sortlist/sortlist-output.txt
namelist[0] = Apple
namelist[1] = bearnamelist[2] = CaTnamelist[3] = dognamelist[4] = Dog
StringList sorted: Apple, CaT, Dog, bear, dog2121CHAPTER 10: GENERICS AND CONTAINERS
226ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 226
10.6 SERIALIZER PATTERN
227
Notice that the sorting order is case sensitive when we add CaseIgnoreString
objects to a QStringList .This is because a CaseIgnoreString must be con-
verted into a QString as it is added to strlist . Therefore, when strlist's
elements are compared, they are compared as QStrings.
EXERCISES: GENERICS, ALGORITHMS,
AND OPERA TORS
1.A QStringList is a value container of objects that have lazy copy-on-write.
In a way, it is like a pointer-collection, but smarter. In Example 10.7, a
CaseIgnoreString was added to a QStringList , which required a con-
version. Does this require a copy of the actual string data? Why or why not?
2.Add some more functions to ContactList :
4Sockets are addressable entities, used as endpoints for sending and receiving data between computers.
Qt has an abstract base class named QAbstractSocket , which provides the interface for working
with various kinds of sockets, and a concrete QTcpSocket class, which provides a TCP (Transmission
Control Protocol) socket.ContactList
+ operator +=(c : Contact)
+ operator -=(c : Contact)+ sortByCategory()+ sortByZip()
Operators +=and -=should add() and remove() respectively.
Write some client code that tests these functions.
10.6 Serializer Pattern
A serializer is an object that is responsible only for reading or writing objects.
With QDataStream , it is already possible to serialize and deserialize all
QVariant -supported types, including QList ,QMap ,QVector, and others.
For other file formats, or more complex object models, we isolate the reading/writing in separate reader and writer classes. These classes are examples ofthe Serializer pattern [Martin 98].
A serializer that reads and writes to files should handle all of the file and/or
stream initialization and cleanup.A serializer could also be used to send objectsover a network from one socket to another.
4In that case it would be responsi-
ble for connecting and disconnecting to/from the appropriate socket.ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 227
CHAPTER 10: GENERICS AND CONTAINERS
228
FIGURE 10.3 The Serializer pattern
In C++, serializer classes can have overloaded input/output operators, similar to
iostream or QTextStream , so that we can use them with a familiar interface.
T o read a file into the container, it should be as easy as this:
ContactList cl;
ContactListReader reader("somefile.txt");reader >> cl;
And analogously, when it is time to output, the client code should look like this:
ContactListWriter writer("somefile.txt");writer << cl;
We achieve this by defining the following insertion operators:
ContactListReader& operator>>(ContactListReader& reader,
ContactList& cl);
ContactListWriter& operator<< (ContactListWriter& writer,
const ContactList& cl);
Example 10.9 shows how to implement customized i/o operators.
EXAMPLE 10.9 src/containers/contact/serializer.cpp
[ . . . . ]
ContactListReader& operator>>(ContactListReader& reader,
ContactList& cl) {reader.read(cl);return reader;
}
ContactListWriter& operator<< (ContactListWriter& writer,
const ContactList& cl) {writer.write(cl);return writer;
}In Figure 10.3, we have a UML diagram for two serializer classes. T ogether, they
can read and write ContactList objects.
ContactListReader
+ ContactListReader(fileName : constQString&)
+ read(contactList : ContactList&) : int
ContactListWriter
+ ContactListWriter(fileName : constQString&)+ write(contactList : constContactList&) : bool+ ContactListWriter(fileName : constQString&)ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 228
In Example 10.9, we defined global (non-member) operators. It would also be
possible to write member function operators. The reason it is necessary to definenon-member operators for 
iostream and QTextStream is because we cannot
modify those classes to add member functions.
10.6.1 Benefits of the Serializer
By using the serializer, it will become much easier to change the file format, or the
transport layer, with only small changes in client code. In addition, removing seri-alization code from the model makes the model simpler and easier to maintain.
EXERCISES: SERIALIZER PA TTERN
1.Revisiting the Contact List exercise from Section 4.3, complete the implemen-
tation of ContactListWriter and ContactListReader classes for the
ContactList , following the Serializer pattern, so that you can read and write
a ContactList to a file.
When each Contact is serialized, it should be written on a single line, in a
tab-separated format (tabs separating each field in the record). Therefore, a seri-alized 
ContactList should have a sequence of lines, each line representing a
Contact .
2.Write a main program that supports, at minimum, the following command line
arguments. Feel free to add others after these are working.10.7 SORTED MAP EXAMPLE
229
Contact List Test Driver usage
contact [-i inputfile] [-c] [-o outputfile] [-p]
-i  read contact list from specified inputfile into ContactList-c  generate 10 more random contacts and add to ContactList-o  write ContactList list to specified output file-p  print ContactList to standard output
If an invalid option is supplied, or if no options are supplied, it should print the
above “Contact List Usage” .
10.7 Sorted Map Example
As we mentioned earlier, QMap is an associative array that maintains key sorting-
order as items are added and removed. Key-based insertions and deletions are fast(log(n)) and iteration is done in key order.
QMap is a value container, but pointers are simple values, so we can use a QMap
to store pointers to heap allocated QObject s. By default, value containers do not
manage heap objects, so to avoid memory leaks we must ensure they are destroyedezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 229
at the proper time. Figure 10.4 describes a class that extends a QMap to contain
information about textbooks. By deriving from QMap , the entire public interface
ofQMap becomes part of the public interface of T extbookMap. We only added a
destructor plus two convenience functions to facilitate adding and displayingT extbooks in the container.CHAPTER 10: GENERICS AND CONTAINERS
230
FIGURE 10.4 TextBookMap
In TextbookMap , defined in Example 10.10, we store ISBN numbers as keys, and
pointers to T extbook objects as val ues. Example 10.10 shows the class definitions.
EXAMPLE 10.10 src/containers/qmap/textbook.h
#ifndef _TEXTBOOK_H_
#define _TEXTBOOK_H_
#include <QObject>
#include <QString>
class Textbook : public QObject {
Q_OBJECT
public:
Textbook(QString title, QString author, QString 
isbn, uint year);[ . . . . ]private:
uint m_YearPub;QString m_Title, m_Author, m_Isbn;
};
class TextbookMap : public QMap<QString, Textbook*> {
public:
~TextbookMap();void add(Textbook* text);void showAll() const;
};
#endifT extbookMap
+ ~ T extbookMap()
+ add(text : T extbook*)+ showAll()T extbookQObject QMapezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 230
EXAMPLE 10.11 src/containers/qmap/qmap-example.cpp
[ . . . . ]
TextbookMap::~TextbookMap() {
cout << "Destroying TextbookMap ..." << endl;foreach (QString key, keys())
delete value(key);
clear(); 
}
void TextbookMap::add(Textbook* text) {
insert(text->getIsbn(), text);
}
void TextbookMap::showAll() const {
foreach (QString key, keys()) {
Textbook* tb = value(key);  cout << '[' << key << ']' << ":" 
<< tb->toString() << endl;
}
}
keys() is a QMap function.
Get and delete a pointer from the map
In Example 10.11, the destructor  iterates through the QMap , deleting each pointer.
This is necessary for a value container to manage its objects.
Notice in the client code, shown in Example 10.12, that when we remove() a
pointer from the TextbookMap we also remove its responsibility for deleting
that pointer.
EXAMPLE 10.12 src/containers/qmap/qmap-example.cpp
[ . . . . ]
int main() {212110.7 SORTED MAP EXAMPLE
231
continuedTextbook* t1 = new Textbook("The C++ Programming Language",
"Stroustrup", "0201700735", 1997);
Textbook* t2 = new Textbook("XML in a Nutshell", "Harold", 
"0596002920", 2002);
Textbook* t3 = new Textbook("UML Distilled", "Fowler", 
"0321193687", 2004);
Textbook* t4 = new Textbook("Design Patterns", "Gamma", 
"0201633612", 1995);
{ 1ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 231
TextbookMap m;
m.add(t1);m.add(t2);m.add(t3);m.add(t4);m.showAll();m.remove (t3->getIsbn());
}cout << "After m has been destroyed we still have: \n" 
<< t3->toString() << endl;
return 0;
}
inner block for demonstration purposes
removed but not deleted
end of block, local variables destroyed.
When TextbookMap::ShowAll() iterates through the container, we can see
from the output in Example 10.13 that the Textbooks have been placed in order
by ISBN (the key).
EXAMPLE 10.13 src/containers/qmap/qmap-example-output.txt
src/containers/qmap> ./qmap
[0201633612]:Title: Design Patterns; Author: Gamma; ISBN:0201633612; Year: 1995[0201700735]:Title: The C++ Programming Language; Author:Stroustrup; ISBN: 0201700735; Year: 1997[0321193687]:Title: UML Distilled; Author: Fowler; ISBN:0321193687; Year: 2004[0596002920]:Title: XML in a Nutshell; Author: Harold; ISBN:0596002920; Year: 2002Destroying TextbookMap ...After m has been destroyed we still have:Title: UML Distilled; Author: Fowler; ISBN: 0321193687; Year: 2004
src/containers/qmap>32132CHAPTER 10: GENERICS AND CONTAINERS
232ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 232
10.7 SORTED MAP EXAMPLE
233
EquivMap
+ ~EquivMap()
+ set(k1 : QString, k2 : QString)+ unset(k1 : QString, k2 : QString)+ getEquivs(key : QString) : EquivClass&Engine
+ showEqualities(symbol : QString)+ processLine(inputline : QString) : QString
EquivClassQObject
QMapQSet
-m_Equivs1
*QString
EquivClassQString
An equivalence relation is a boolean operator, equiv , on a set Sof symbols that has
three properties:
1.Reflexivity: For any symbol sin S, we always have
s equivs
2.Symmetry: For any symbols sand tin S,
if s equiv t then t equiv s
3.Transitivity: For any symbols s,t, and uin S,
if s equiv t and t equiv u then s equiv u
Another example of an equivalence relation is the operator== relationship
between pointers.This one is very easy to check, because their addresses also mustbe equal. If the set members are different symbols with different values, we need tokeep track of the sets themselves in order to determine which symbols are relatedto each other.EXERCISE: QSETS AND QMAPS
This exercise requires you to use a map of sets to implement a dynamic equiva-
lence relation.ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 233
An equivalence relation, equiv , partitions the set Sof symbols into subsets called
equivalence classes. An equivalence class is a set of symbols that are equivalentto one another. It is easy to see that two equivalence classes are either equal ordisjoint.
1.Write a program that repeatedly asks the user to enter assertions or commands,
and keeps track of equivalency sets for all QStrings that it sees. At any time, theuser should be able to see the contents of any equivalence class. In other words,
processLine() should expect strings of the following form:
a. To make an equivalence assertion between two strings: string1=string2
b. To list the contents of string1 ’s EquivClass: string1 (no = symbol in the
line)
2.Add another function, takeback(int n) , which takes an integer that refers
to the nth assertion. The function should “undo” the nth assertion that was per-
formed, fixing up all EquivClass sets in the equivalence engine. After this, list
the updated equivalences of both symbols involved.
Have the processLine() function scan for messages of the form “take-
back n” and call this takeback() in response.CHAPTER 10: GENERICS AND CONTAINERS
234ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 234
REVIEW QUESTIONS
235
REVIEW QUESTIONS
1. Explain an important difference between a template parameter and a
function parameter.
2. What does it mean to instantiate a template function? Describe one way
to do this.
3. Normally, you need to place template definitions in header files. Why is
this?
4. Qt’s container classes are used to collect value types. What kinds of
things are not appropriate to store by value in a value collection?
5. Which containers provide a mappings from key to value? List and
describe at least two, and tell how they are different from each other.
6. What does it mean for a container to “manage” its heap objects? How
does a container of pointers to heap objects become a “managedcontainer”?ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 235
ezus_138004_ch10.qxd  8/4/06  9:44 AM  Page 236
11.1 Widget Categories . . . . . . . . . . . . . . . . . . 239
11.2 QMainWindow and QSettings . . . . . . . 24011.3 Dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24411.4 Images and Resources . . . . . . . . . . . . . . 24811.5 Layout of Widgets . . . . . . . . . . . . . . . . . . 25111.6 QActions, QMenus,
and QMenuBars . . . . . . . . . . . . . . . . . . . . 260
11.7 QActions, QToolbars,
and QActionGroups . . . . . . . . . . . . . . . . 262
11.8 Regions and QDockWidgets . . . . . . . . . 27011.9 Views of a QStringList . . . . . . . . . . . . . . 27211CHAPTER 11
Qt GUI Widgets 
This chapter provides an overview of the GUI build-ing blocks, called widgets, that are part of the Qtlibrary and includes some simple examples of how touse them.
237ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 237
Widgets, objects of classes derived from QWidget , are reusable building
blocks with a visual representation on the screen. The common features of a
QWidget are shown in Figure 11.1.
QWidget is a class that uses multiple inheritance (see Section 23.3). A QWidget
is aQObject , and thus can have parents, signals, slots, and managed children.
AQWidget is aQPaintDevice , the base class of all objects that can be
“painted.”
QWidgets interact with their children in interesting ways. A widget that has
no parent is called a window . If one widget is a parent of another widget, the
boundaries of the child widget lie completely within the boundaries of the par-ent. The contained child widget is displayed according to layout rules (seeSection 11.5).
A 
QWidget can handle events by responding to signals from various entities
in the window system (e.g., mouse, keyboard, other processes, etc.). It can paint itsown rectangular image on the screen. It can remove itself from the screen in a waythat respects whatever else is on the screen at the moment.
A typical desktop GUI application can contain many (hundreds is not unusual)
different 
QWidget -derived objects, deployed according to parent-child relation-
ships and arranged according to the specifications of the applicable layouts.
A QWidget is considered to be the simplest of all GUI classes, because it is ren-
dered as an empty box. The class itself is quite complex, containing hundreds offunctions. When you reuse 
QWidget and its subclasses you are standing on the
shoulders of giants, because every QWidget is built on top of layers of Qt code,QPaintDevice QObject
QWidget
FIGURE 11.1 QWidget’s Heritageezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 238
which in turn are built on top of different layers of native widget libraries, depend-
ing on your platform (X11 in Linux, Cocoa on MacOS, and Win32 in Windows).
In fact,QWidget is a Façade for the widget classes from each of these native
window libraries (see Section 16.3).
11.1 Widget Categories
Qt widgets can be categorized in a number of ways to make it easier to find classes
you are likely to use. The more complex widgets may cross over into more thanone category. This section provides a brief overview of some of the classes we arelikely to use as we get started with GUI programming.
There are four categories of widgets. Button widgets, in “Windows style,” are
shown in Figure 11.2.11.1 WIDGET CATEGORIES
239
Input widgets, in “Plastique style,” are shown in Figure 11.3.
FIGURE 11.2 Button widgets, in “Windows style”
FIGURE 11.3 Input widgets, in “Plastique style”ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 239
Display widgets are non-interactive widgets, such as QLabel ,QProgressBar ,
and QPixMap .
Container widgets, such as the QMainWindow ,QFrame ,QToolBar ,
QTabWidget , and QStackedWidget , contain other widgets.
These widgets are used as building blocks to create other more complex
widgets, such as:
■Dialogs for asking the user questions or  popping up information, such as
the QFileDialog ,QInputDialog , and QErrorMessage .
■Views that provide displays of collections of data such as QListView ,
QTreeView , and QTableView .
In addition, there are some Qt classes that do not have any graphical representa-
tion (so they are not widgets) but are used in GUI development. They include
■Qt Data types: QPoint and QSize are popular types to use when work-
ing with graphical objects.
■Controller classes: QApplication and QAction are both objects that
manage the GUI application’s control flow.
■Layouts: These are objects that dynamically manage the layout of widgets.There are specific layout varieties:
QHBoxLayout ,QVBoxLayout ,
QGridLayout ,e t c .
■Models: The QAbstractItemModel and its derived classes
QAbstractListModel and QAbstractTableModel are part of Qt’s
model/view framework, and are used as base classes for classes that rep-resent data for a 
QListView ,QTreeView ,o r  QTableView .
■Database models: These are for use with QTableView (or other
customized view classes) using SQL Databases as data sources:
QSqlTableModel and QSqlRelationalModel .
T o see more widgets rendered in differe nt styles, check out TrollT ech’s Qt Widget
Gallery1, which contains a variety of screenshots and source code for renderingthe widgets in different styles.
1
11.2 QMainWindow and QSettings 
Most QApplications manage a single QMainWindow . As Figure 11.4 shows, the
QMainWindow has some features that are common to most desktop applications:
■A central widget
■Menu barCHAPTER 11: QT GUI WIDGETS
240
1http://oop.mcs.suffolk.edu/qt docs/gallery.htmlezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 240
■Status bar
■Dock regions11.2 QMAINWINDOW AND QSETTINGS
241
Because the QMainWindow is the parent of all other widgets (in that main win-
dow), it is common practice to extend that class for some applications, as shownin Example 11.1.
EXAMPLE 11.1 src/widgets/mainwindow/mymainwindow.h
[ . . . . ]
class MyMainWindow : public QMainWindow {
Q_OBJECT
public:
MyMainWindow();void closeEvent(QCloseEvent *event);
protected slots:
virtual void newFile();virtual void open();virtual bool save();
[ . . . . ]
overridden from base class to capture when the user wants to close the window11
FIGURE 11.4 A main windowezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 241
11.2.1 QSettings: Saving and Restoring 
Application State
All modern desktop applications have a way for users to configure the settings.
The settings/preferences/options need to  be persistent. The mechanism for that is
included with QSettings . As you develop a new QMainWindow application, the
first persistent settings you may want to save will probably be the window size andposition. Y ou may also want to save the names of the most recent documents thatwere opened by the application.
QSettings is a persistent map of key/value pairs. It is a QObject and uses
QObject ’s property interface, setValue() and value() , to set and get its
values. It can be used to store any data that needs to be remembered across multi-ple executions.
The 
QSettings constructor has two QString parameters: one for the organ-
ization name and one for the application name. Y ou can establish defaults for thesevalues with the two 
QCoreApplication functions,setOrganizationName()
and setApplicationName() , after which you can use the default QSettings
constructor. Each combination of names defines a unique persistent map that doesnot clash with settings from other-named Qt applications.
Monostate Pattern
A class that allows multiple instances to share the same state is an imple-
mentation of the Monostate pattern . Two instances of QSettings with
the same organization/application name can be used to access the samepersistent map data. This makes it easy for applications to access commonsettings from different source files.
QSettings is an implementation of the Monostate pattern.CHAPTER 11: QT GUI WIDGETS
242
The actual mechanism for the persistent storage of QSettings data is imple-
mentation dependent and quite flexible. Some possibilities for its storage include
the Win32 registry (in Windows) and your $HOME/.qt directory (in Linux). Formore detailed information, see the Qt 
QSettings API documentation.
QMainWindow::saveState() returns a QByteArray that contains infor-
mation about the main window’s toolbars and dockwidgets. T o do this it makes useof the
objectName property for each of those subwidgets, thus making it important
that each name be unique. saveState() has an optional int versionNumberezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 242
parameter. The QSettings object stores that QByteArray with the key string
"state" .
QMainWindow::restoreState() takes aQByteArray , presumably cre-
ated bysaveState() , and uses the information that it holds to put the toolbars
and dockwidgets into a prior arrangement. It too has an optional versionNumber
parameter. We show the use of these functions in Example 11.2.
EXAMPLE 11.2 src/widgets/mainwindow/mymainwindow.cpp
[ . . . . ]
void MyMainWindow::readSettings() { 11.2 QMAINWINDOW AND QSETTINGS
243
QSettings settings("objectlearning.net", "Qt4 Sample Main");
QPoint pos = settings.value("pos", QPoint(200, 200)).toPoint();QSize size = settings.value("size", QSize(400, 400)).toSize();QByteArray state = settings.value("state", QByteArray()).toByteArray();restoreState(state);resize(size);move(pos);
}
void MyMainWindow::writeSettings() {
/* Save postion/size of main window */
QSettings settings("objectlearning.net", "Qt4 Sample Main");
settings.setValue("pos", pos());settings.setValue("size", size());settings.setValue("state", saveState());
}1
The constructor takes the organization name and the app name as arguments.
By placing the “root program logic” in a derived class of QMainWindow or
QApplication , the main() becomes quite simple, as shown in Example 11.3.
EXAMPLE 11.3 src/widgets/mainwindow/mainwindow-main.cpp
#include "mymainwindow.h"
#include <QApplication>
int main( int argc, char ** argv ) {
QApplication a( argc, argv );MyMainWindow mw;mw.show();return a.exec();
}1ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 243
11.3 Dialogs
A dialog box pops up, shows the user something, and gets a response back from
the user. It’s a brief interaction that can (optionally) force the user to respond.CHAPTER 11: QT GUI WIDGETS
244
QDialog , the base class for dialogs, has a bool attribute named modal .I fmodal
is set to true , the dialog box blocks input to all other visible windows in its par-
ent. A modal dialog box must be dismissed (by clicking on one of its buttons)
before the application can proceed.
In general, dialog boxes should be used only for obtaining or communicating
important information that should (or must) be dealt with before the programcan proceed.
The
QMessageBox (derived from QDialog ) class produces a modal dialog
with a brief message (or question), a distinctive icon, and from one to three buttons.Each of the icons characterizes a particular severity level and corresponds to a par-ticular kind of message box.
QMessageBox has a number of static convenience functions that cause these
kinds of dialogs to pop up. A short application demonstrating the use of the vari-ous kinds of
QMessagebox is shown in Examples 11.4 and 11.5.
EXAMPLE 11.4 src/widgets/dialogs/messagebox/dialogs.h
#ifndef APPWINDEMO_H
#define APPWINDEMO_H
#include <QMainWindow>
class Dialogs : public QMainWindow {
Q_OBJECT
public:
Dialogs();
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 244
public slots:
void askQuestion();void askDumbQuestion();
private:
QString answer;
};
#endif 
EXAMPLE 11.5 src/widgets/dialogs/messagebox/dialogs.cpp
[ . . . . ]
void Dialogs::askQuestion() {
bool done=false;QString q1("Who was Canadian Prime Minister in 1847?"),
a0("John A. Macdonald"), a1("Alexander Mackenzie"),a2("Sir Wilfred Laurier");
while (!done) {
int ans = QMessageBox::
question( this,"Difficult Question",
q1, a0, a1, a2, 
0,
-1 ) ;
if (ans > 0) return;switch( ans ) {case 0:
answer = a0;break;
case 1:
answer = a1;break;
case 2:
answer = a2;break;
}QString q2(QString("Your answer was: %1."
" That is incorrect.\n Try again?")
.arg(answer));
int again = QMessageBox::
question(this, "Your Score", q2,432111.3 DIALOGS
245
continued"No", "Yes", "I give up - what’s the answer?");
if ( again <1 ) {
return;ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 245
}
if (again == 2) {
QMessageBox::information(this, "Ha Ha!",
"There was no prime minister until 1867","Grrrrr.....");
return;
}
}
}
Message box is modal relative to its parent.
default valueValue sent on “esc” or “windowclose” .
If window was closed, no QButton was pressed.
When you build and run this application, notice that once the critical dialog is on-
screen, you cannot interact with the main window at all—the pull down
Questions menu is not receiving events, and even the window manager can’t kill
the main window. This is the power of a modal dialog.4321CHAPTER 11: QT GUI WIDGETS
246
11.3.1 Input Dialogs and Widgets
When a user enters text into a box, it is an input widget, probably a QLineEdit
(for single lines), a QComboBox (for a choice of values), QSpinBox (for a num-
ber), or QTextEdit (for multiple lines of text). These widgets are never “solitary”
because there needs to be at least a label nearby that tells the user what informa-tion is required.
Input dialogs are higher-level widgets that group together the lower-level
input widgets with labels and decorations for convenience.
QInputDialog has a
label, an input widget (such as a QLineEdit ), and, like the message dialogs, one
to three buttons.
QInputDialog has four configurable static functions that determine the char-
acteristics of the data entry widget. It can return a QString , an int, or a double.
Example 11.6 is a short application that supplies the static function getItem()
with a QStringList to store a set of possible responses and returns the QString
selected by the user.
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 246
EXAMPLE 11.6 src/widgets/dialogs/inputdialog/inputdialog.cpp
#include <QInputDialog>
#include <QStringList>#include <QApplication>
int main(int argc, char** argv) {
QApplication app(argc, argv);app.setQuitOnLastWindowClosed(false);QStringList hobbits, yesno;11.3 DIALOGS
247
By default, Qt expects a GUI app to have a single top-level window (i.e., a
window with no parent). Our Hobbit selection app has two. This cancause some confusion about when the program is finished.
We inserted the following function call to address this problem:
app.setQuitOnLastWindowClosed(false);hobbits << "Frodo" << "Bilbo" << "Samwise" < "Merry" << "Pippin";
yesno << "yes" << "no";QString outcome, more, title("Hobbit Selector");QString query("Pick your favorite Hobbit");do {
QString pick = 
QInputDialog::getItem(0, title, query, hobbits);
outcome = QString("You picked %1, try again?").arg(pick);more = QInputDialog::
getItem(0, "Pick a Hobbit", outcome, yesno, 1, false);
}  while (more == "yes");
}
The first call to getItem() uses the overloaded version that accepts a
QStringList . This puts a QComboBox (editable by default) on the screen, pre-
filled with the values from the QStringList . The user can then select one of the
choices or type in a new string.
We supplied six arguments in the second call to getItem() , resulting in a
non-editable combobox. Here are two screenshots of the running program.
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 247
EXERCISE: DIALOGS
Make the following modifications of the Hobbit Selection app.
1.Remove the line 
app.setQuitOnLastWindowClosed(false);
and see if you can explain the results.
2.Change the app so that each time the user, by editing one of the selections in
the list, creates a new Hobbit name, that name becomes one of the (sorted)choices for the next iteration.
3.In both of the getItem() dialogs of the Hobbit Selection app, there is no differ-
ence between OK and Cancel. What should that difference be? As CaptainPicard would say, “Make it so.”
11.4 Images and Resources
Graphic images can be used to add visual impact to various applications. In this
section, we show how to build an application or a library that includes graphicimages in the project.
Qt 4 enables projects to make use of binary resources, such as images, sounds,
icons, text in some exotic font, and so forth. Resources such as these are generallystored on disk in separate binary files. The advantage of incorporating binarydependencies in the actual project is that they can then be addressed using pathsthat do not depend on the local file system, and they can “move” with the executable.
In the next examples, we will demonstrate how to create and reuse a library
that includes images, one for each card in a deck of playing cards.
The first step is to list the binary files we wish to use in a Resource
Collection File , an XML file that has the extension .
qrc. The resource file in
libcards2 is automatically generated by a python script. Here is an abbrevi-
ated listing of it.
<!DOCTYPE RCC>
<RCC version="1.0"><qresource><file alias="images/qh.png">images/qh.png</file><file alias="images/qd.png">images/qd.png</file><file alias="images/jc.png">images/jc.png</file>[ ... ]<file alias="images/jd.png">images/jd.png</file><file alias="images/ac.png">images/ac.png</file></qresource></RCC>CHAPTER 11: QT GUI WIDGETS
248ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 248
RCC is a file format, required by qmake and rcc (Qt’s resource compiler), that
generally consists of a list of <file> elements enclosed by <qresource> tags.
Each <file> element contains a relative path and an optional file alias.
We must add a RESOURCES line in the project file that contains the name of
the qresource file, as shown in Example 11.7.
EXAMPLE 11.7 src/libs/cards2/cards2.pro
# project file for libcards2
include ($$(CPPLIBS)/utils/common.pri)TEMPLATE = lib
INCLUDEPATH += .QT += gui# For locating the files.RESOURCES = cards2.qrc
SOURCES += cardpics.cpp
HEADERS += cardpics.hDESTDIR=$$(CPPLIBS)target.path=$$(CPPLIBS)unix {
UI_DIR = .uiMOC_DIR = .mocOBJECTS_DIR = .obj
}
When this project is built, the resource compiler generates an extra file named
cards2_qrc.cpp that contains byte arrays defined in C++. This file gets com-
piled and linked into the project binary (executable or library) instead of the orig-inal files. The 
DESTDIR line specifies that the shared object files for libcards2
will be located in $CPPLIBS with the other libraries that we have built.
In libcards2 , we defined a class named CardPics , shown in Example 11.8,
which utilizes the QPixmap class. There are three Qt classes that facilitate the han-
dling of images.
1.QPixmap : designed and optimized for drawing on the screen
2.QImage : designed for input and output operations and for direct pixel
access
3.QPicture : designed to enable scalability11.4 IMAGES AND RESOURCES
249ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 249
EXAMPLE 11.8 src/libs/cards2/cardpics.h
[ . . . . ]
class CardPics {
public:
CardPics();static CardPics* instance();QPixmap get(QString card);static const QString values, suits;
protected:
static QString fileName(QString card);    
private:
QMap<QString, QPixmap> m_pixmaps;
};
[ . . . . ]
Attaching required binary data files to projects as resources makes the project more
robust. The source code does not need to use nonportable pathnames for theresource files. T o refer to a file that is stored as a resource, we can use the alias thatwas established in the 
RCC file, and precede it with the prefix, “ :/”. Each resource
then appears (to Qt) to be located in a private virtual file system, rooted at :/.
Example 11.9 shows some Qpixmaps created with pathnames of this format.
EXAMPLE 11.9 src/libs/cards2/cardpics.cpp
[ . . . . ]
const QString CardPics::values="23456789tjqka";const QString CardPics::suits="cdhs";
CardPics* CardPics::instance() {
static CardPics* inst = 0;if (inst == 0)
inst = new CardPics;
return inst;
}
CardPics::CardPics() {
foreach (QChar suit, suits) {
foreach (QChar value, values) {
QString card = QString("%1%2").arg(value).arg(suit);QPixmap pixmap(fileName(card)); CHAPTER 11: QT GUI WIDGETS
250
m_pixmaps[card]= pixmap;
}
}
}
QString CardPics::fileName(QString card) {
return QString(":images/%1.png").arg(card);
}ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 250
QPixmap CardPics::get(QString card) {
return m_pixmaps[card];
}
[ . . . . ]
Each resource is used to construct a QPixmap , which gets added to CardPics for
easy access with the get() function.
11.5 Layout of Widgets
A widget can be popped up on the screen, like a dialog, or it can be made a part of
a larger window. Whenever we wish to arrange smaller widgets inside larger ones,we use layouts. A layout is an object that belongs to exactly one widget. Its sole
responsibility is to organize the space occupied by its owner’s child widgets.
Although each widget has a 
setGeometry() function that allows you to set
its size and position, absolute sizing and positioning are rarely used in a window-ing application because they impose an undesirable rigidity on the design.Proportional resizing, splitters, scrollbars when needed, and flexible arrangementof visual space are all achieved quite naturally through the use of layouts.
The process of specifying the way that your widgets will be arranged on the
screen consists of dividing the screen into regions, each controlled by a 
QLayout .
Layouts can arrange their widgets
■Vertically ( QVBoxLayout )
■Horizontally ( QHBoxLayout )
■In a grid (QGridLayout )
■In a stack where only one widget is visible at any time ( QStackedLayout )
Widgets are added to QLayouts using the addWidget() function.
Layouts are not widgets, and they have no visual representation. Qt supplies an
abstract base class named QLayout plus several concrete QLayout subclasses:
QBoxLayout (particularized to QHBoxLayout and QVBoxLayout ),
QGridLayout , and QStackedLayout . Each of the layout types has an appro-
priate set of functions to control the spacing, sizing, alignment, and access to itswidgets.
For its geometry management to work, each 
QLayout object must have a par-
ent that is either a QWidget or another QLayout . The parent of a QLayout can
be specified when the layout is constructed by passing the constructor a pointer tothe parent widget or layout. It is also possible to construct a 
QLayout without
specifying its parent, in which case you can call QWidget ::addLayout() at some
later time.11.5 LAYOUT OF WIDGETS
251ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 251
Layouts can have child layouts. One layout can be added as a sub-layout to
another by calling addLayout() . The exact signature depends on the kind of
layout used. If the parent of a layout is a widget, that widget cannot be the parentof any other layout.CHAPTER 11: QT GUI WIDGETS
252
FIGURE 11.5 Rows and columns
The CardTable class defined in Example 11.10 reuses libcards2 , for easy access
to QPixmaps of playing cards (see Section 11.4). Constructing a CardTable
object puts Figure 11.5 on the screen.
EXAMPLE 11.10 src/layouts/boxes/cardtable.h
#ifndef CARDTABLE_H
#define CARDTABLE_H#include <carddeck.h>#include <QWidget>
class CardTable : public QWidget {
public:
CardTable();
private:
CardDeck m_deck;
};
#endif        //  #ifndef CARDTABLE_H
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 252
CardTable is implemented in Example 11.11 by making use of the fact that a
QLabel can hold an image. This implementation demonstrates some simple but
useful layout techniques.
EXAMPLE 11.11 src/layouts/boxes/cardtable.cpp
[ . . . . ]
// Given a pixmap, return a label with that pixmap on it.static QLabel* label(QPixmap pm) {
QLabel* retval = new QLabel();retval->setPixmap(pm);return retval;
}
CardTable::CardTable() {
// create 2 rows of cards:
QHBoxLayout *row = new QHBoxLayout();row->addWidget(label(m_deck.get(1)));  row->addWidget(label(m_deck.get(2)));row->addWidget(label(m_deck.get(3)));row->addWidget(label(m_deck.get(4)));    
QVBoxLayout* rows = new QVBoxLayout();
rows->addLayout(row);
row = new QHBoxLayout();
row->addWidget(label(m_deck.get(5)));row->addWidget(label(m_deck.get(6)));row->addWidget(label(m_deck.get(7)));rows->addLayout(row);
// create a column of buttons:
QVBoxLayout *buttons = new QVBoxLayout();buttons->addWidget(new QPushButton("Deal"));buttons->addWidget(new QPushButton("Shuffle"));
// Bring them together:
QHBoxLayout* cols = new QHBoxLayout();setLayout(cols);cols->addLayout(rows);cols->addLayout(buttons);
}[ . . . .]
the “root layout” for this widget
Add both card rows as a column.
Add column of buttons as another column.32132111.5 LAYOUT OF WIDGETS
253ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 253
The simple piece of client code shown in Example 11.12 suffices to put the window
on the screen.
EXAMPLE 11.12 src/layouts/boxes/boxes.cpp
#include <QApplication>
#include "cardtable.h"
int main(int argc, char* argv[]) {
QApplication app (argc, argv);CardTable ct;ct.show();return app.exec();
}
If you build and run this example and use your mouse to resize the window, you will
notice that the width of the buttons stretches first to gobble up extra space, but thatthere is also stretchable spacing between the cards, as well as between the buttons. Ifwe removed the buttons, we could observe that the horizontal spacing between thecards would grow evenly and uniformly.
11.5.1 Spacing, Stretching, and Struts
T o get finer control over the layout of widgets, we can use the API of the QLayout
class. Box layouts, for example, offer the following functions:
1.addSpacing(int size) adds a fixed number of pixels to the end of
the layout.
2.addStretch(int stretch = 0) adds a stretchable number of
pixels. It starts at a minimum amount and stretches to use all availablespace. In the event of multiple stretches in the same layout, this can beused as a growth factor.
3.
addStrut(int size) imposes a minimum size to the perpendicular
dimension (i.e., the width of a VBoxLayout or the height of anHboxLayout).
Revisiting Example 11.11, we will make the layout behave a little better during
resizing. Figure 11.6 shows the results of adding some stretch and some spacers tothis application.
Normally, layouts try to treat all widgets equally. When we want one widget to
be off to a side, or pushed away from another, we can use stretches and spacing toCHAPTER 11: QT GUI WIDGETS
254ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 254
deviate from that norm. Example 11.13 demonstrates how to use stretches and
spacing.
EXAMPLE 11.13 src/layouts/stretch/cardtable.cpp
[ . . . . ]
QVBoxLayout *buttons = new QVBoxLayout();
buttons->addStretch(1);
buttons->addWidget(new QPushButton("Deal"));buttons->addWidget(new QPushButton("Shuffle"));buttons->addSpacing(20);
QHBoxLayout* cols = new QHBoxLayout();
setLayout(cols);cols->addLayout(rows);cols->addStretch(30);cols->addLayout(buttons);
}[ . . . . ]
stretchable space before buttons in column
fixed spacing after buttons
Adds a fixed spacing of 30 that stretches
If you build and run this application using the code from Example 11.13 instead
of Example 11.11, you can resize the main window and observe that the buttonsno longer grow, and are pushed off to the corner. The horizontal spacing betweenthe cards does not grow, but the vertical spacing does.32132111.5 LAYOUT OF WIDGETS
255
FIGURE 11.6 Improved layout with stretch and spacersezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 255
11.5.2 Moving Widgets across Layouts
Figure 11.7 shows the basic layout for our next example, which demonstrates what
happens when a widget is added to more than one layout.CHAPTER 11: QT GUI WIDGETS
256
FIGURE 11.7 Moving labels application
This application moves QLabels from one layout to the other in response to
the button press. In Example 11.14 we derive from QApplication a class that
defines the GUI.
EXAMPLE 11.14 src/layouts/moving/moving.h
[ . . . . ]
class MovingApp : public QApplication {
Q_OBJECT
public:
MovingApp(int argc, char* argv[]);
public slots:
void moveLeft();void moveRight();void newLeft();void newRight();
private:
QString nextLabel();QMainWindow m_MainWindow;QQueue<QLabel*> m_LeftQueue, m_RightQueue;QVBoxLayout *m_LeftLayout, *m_RightLayout;int m_Count;
};
[ . . . . ]
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 256
The constructor starts by creating the layouts and the various widgets, as we see in
Example 11.15.
EXAMPLE 11.15 src/layouts/moving/moving.cpp
[ . . . . ]
MovingApp::MovingApp(int argc, char* argv[]) :
QApplication(argc, argv),m_MainWindow(), m_Count(0)  {
QWidget *center = new QWidget(&m_MainWindow);
m_MainWindow.setCentralWidget(center);
QGridLayout *mainGrid = new QGridLayout;m_LeftLayout = new QVBoxLayout;
m_RightLayout = new QVBoxLayout;
mainGrid->addLayout(m_LeftLayout, 0,0);
mainGrid->addLayout(m_RightLayout, 0, 1);    QPushButton *moveRight = new QPushButton("Move Right");QPushButton *moveLeft = new QPushButton("Move Left");mainGrid->addWidget(moveRight, 1,0);mainGrid->addWidget(moveLeft, 1,1);
QPushButton *addRight = new QPushButton("Add Right");
QPushButton *addLeft = new QPushButton("Add Left");
mainGrid->addWidget(addLeft, 2,0);
mainGrid->addWidget(addRight, 2,1);center->setLayout(mainGrid);
The QMainWindow takes ownership of this widget and makes it the central widget.We do not
need to delete it.
After creation of the various layouts and widgets, signals must be connected to
slots, as we see in Example 11.16.
EXAMPLE 11.16 src/layouts/moving/moving.cpp1111.5 LAYOUT OF WIDGETS
257
continued[ . . . .]
connect(moveRight, SIGNAL(pressed()), this, SLOT(moveRight()));
connect(moveLeft, SIGNAL(pressed()), this, SLOT(moveLeft()));connect(addRight, SIGNAL(pressed()), this, SLOT(newRight()));connect(addLeft, SIGNAL(pressed()), this, SLOT(newLeft()));    ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 257
// What do the insertStretch lines do?
m_LeftLayout->insertStretch(0);m_RightLayout->insertStretch(0);
newLeft();
newRight();m_MainWindow.move(200,200);m_MainWindow.resize(300, 500);m_MainWindow.show();
This puts a label in the left layout.
This puts a label in the right layout.
Because a widget cannot exist in more than one layout at any given time, it disap-
pears from the first layout and shows up in the new one. Each widget retains itsparent after the layout change. The code for the movement slots is shown inExample 11.17.
EXAMPLE 11.17 src/layouts/moving/moving.cpp
[ . . . . ]
void MovingApp::moveLeft() {
if (m_RightQueue.isEmpty()) return;QLabel *top = m_RightQueue.dequeue();m_LeftQueue.enqueue(top);m_LeftLayout->addWidget(top);
}
void MovingApp::moveRight() {
if (m_LeftQueue.isEmpty()) return;QLabel *top = m_LeftQueue.dequeue();m_RightQueue.enqueue(top);m_RightLayout->addWidget(top);
}
By adding it to the left, it disappears from the right.
EXERCISES: LA YOUT OF WIDGETS
1.There are many ways of getting information from the user. The keeper of the
Bridge of Death wants to know the answers to three questions, as we see in thefollowing figure.112121CHAPTER 11: QT GUI WIDGETS
258ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 258
■Create a dialog that asks these questions of the user, using QLineEdit
widgets and two QPushButtons to submit or cancel the request. Check the
responses to make sure they are correct. If they are not correct, output afunny message.
■Change the third question randomly so that half of the time it asks “What isthe mean air speed velocity of an unladen swallow?”
2.The 15 puzzle (or n
2/H11002 1 puzzle) involves a 4 /H110034 (n/H11003n) grid that contains 15
tiles numbered 1 to 15 (1 to n2 /H11002 1), and one empty space. The only tiles that
can move are those next to the empty space.
■Create a 15 puzzle with QPushButtons in a QGridLayout .
■At the start of the game, the tiles are presented to the player in “random”order. The object of the game is to rearrange them so that they are inascending order, with the lowest numbered tile in the upper-left corner.
■If the player solves the puzzle, pop up a QMessageBox saying “YOU WIN!”
(or something more clever).
■Add some buttons:
■Shuffle: Randomize the tiles by performing a large number (at least 50)of legal tile slides.
■Quit: To leave the game.
Sample 15 Puzzle11.5 LAYOUT OF WIDGETS
259
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 259
Model-View-Controller Design for PuzzleCHAPTER 11: QT GUI WIDGETS
260
11.6 QActions, QMenus, and QMenuBars
A QAction is a QObject that is a base class for user-selected actions. It provides
a rich interface that can be used for a wide variety of actions, as we will soon see.The 
QWidget interface enables each widget to maintain a QList<QAction*> .
A QMenu is a QWidget that provides a particular kind of view for a collection
of QActions. A QMenuBar is a collection of menus.DESIGN SUGGESTIONS Want to get a head start using the model-
view-controller style? It comes up later, but you can try it now. Define theclasses shown in the accompanying figure and try to partition your codeproperly into them.
PuzzleWindow
+ PuzzleWindow()
Visual Code for showing a puzzle+ mw
Non-Visual class - for representing the “state” of the puzzleQMainWindow
QWidget
QObjectQApplication
PuzzleApp
 - inModel : PuzzleModel*
 - mView : PuzzleView* - mw : PuzzleWindow - mActions : QActionGroup*
+ PuzzleApp(argc : int, argv[] : char*)
+ createWidgets()+ createActions()
PuzzleView
 - mModel : PuzzleModel* - mLayout : QGridLayout* - mButtons : QButtonGroup
+ PuzzleView( : PuzzleModel*)
+ refresh()
PuzzleModel
+ value(r : int, c : int) : int+ slide(tilenum : int) : bool+ neighboring(r : int, c : int) : bool+ signal : gridChanged()QPushButton
+ number : int
+ Tile(tileNumber : int)
*Tileezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 260
When the parent of a QMenu is a QMenuBar , the QMenu appears as a pull-
down menu with a familiar interface. When its parent is not a QMenuBar it can
pop up, like a dialog, in which case it is considered a context menu .2A QMenu can
have another QMenu as its parent, in which case it becomes a submenu.
T o help the user make the right choice, each action can have the following:
■T ext and/or icon that appears on a menu and/or button
■An accelerator or a shortcut key
■A “What’s this?” and a tool-tip
■A way to toggle the state of the action between visible/invisible,enabled/disabled, and checked/not checked
■changed() ,hovered() ,toggled() , and triggered() signals
The Dialog in Example 11.4 had a menubar with a single menu that gave two
choices.11.6 QACTIONS, QMENUS, AND QMENUBARS
261
2A context menu is usually activated by clicking the right mouse button or by pressing the “menu”
button. It is called a context menu because the menu always depends on the context (which QWidget
is currently selected or focused).
Example 11.18 shows the code that sets up that menubar.
EXAMPLE 11.18 src/widgets/dialogs/messagebox/dialogs.cpp
[ . . . . ]
/* Insert a menu into the menubar */
QMenu *menu = new QMenu("&Questions", this);
QMainWindow::menuBar()->addMenu(menu);/* Add some choices to the menu */
menu->addAction("&Ask question",
this, SLOT(askQuestion()), tr("Alt+A"));
menu->addAction("Ask a &dumb question",
this, SLOT(askDumbQuestion()), tr("Alt+D"));
}ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 261
The calls to QMenu::addAction(text, target, slot, shortcut) each
create an unnamed QAction and call QWidget::addAction(QAction*) to
install it in the menu. The latter call adds the new action to the menu’s
QList<QAction*> .
11.7 QActions, QToolbars, and QActionGroups
11.7.1 The Command Pattern
The Command pattern , as described in [Gamma95] encapsulates operations
as objects with a common execution interface. This can make it possible toplace operations in a queue, log operations, and undo the results of analready executed operation.
Because an application might provide a variety of different ways for the user to
issue the same command (e.g., menus, toolbar buttons, keyboard shortcuts),encapsulating each command as an action helps to ensure consistent, synchro-
nized behavior across the application.
QAction is, therefore, an ideal base class for
implementing the Command pattern.
In Qt GUI applications, actions are typically “triggered” in one of the follow-
ing ways:
■A user clicks on a menu choice.
■A user presses a shortcut key.
■A user clicks on a toolbar button.
There are several overloaded forms of QMenu::addAction() . We will use the ver-
sion inherited from QWidget ,addAction(QAction*) in Example 11.19. Here
we see how to add actions to menus, action groups, and toolbars. We start by deriv-ing a class from
QMainWindow and equipping it with several QAction members
plus aQActionGroup and aQToolBar .
EXAMPLE 11.19 src/widgets/menus/study.h
[ . . . . ]
class Study : public QMainWindow {
Q_OBJECT
public:
Study();CHAPTER 11: QT GUI WIDGETS
262ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 262
public slots:
void actionEvent(QAction* act);
private:
QActionGroup* actionGroup;
QToolBar *toolbar;
QAction *useTheForce;
QAction *useTheDarkSide;QAction *studyWithObiWan;QAction *studyWithYoda;QAction *studyWithEmperor;QAction *fightYoda;QAction *fightDarthVader;QAction *fightObiWan;QAction *fightEmperor;
protected:
QAction* addChoice(QString name, QString text);
};
[ . . . . ]
for catching the signals
for displaying the actions as buttons
The constructor for this class sets up the menus and installs them in the QMenuBar
that is already part of the base class. (See Example 11.20.)
EXAMPLE 11.20 src/widgets/menus/study.cpp
[. . . . ]
Study::Study() {
actionGroup = new QActionGroup(this);actionGroup->setExclusive(false);statusBar();
QWidget::setWindowTitle( "to become a jedi, you wish?" );
QMenu* useMenu = new QMenu("&Use", this);QMenu* studyMenu = new QMenu("&Study", this);QMenu* fightMenu = new QMenu("&Fight", this);
useTheForce = addChoice("useTheForce", "Use The &Force");
useTheForce->setStatusTip("This is the start of a journey...");
useTheForce->setEnabled(true);useMenu->addAction(useTheForce);
[ . . . . ]
21212111.7 QACTIONS, QTOOLBARS, AND QACTIONGROUPS
263
continuedezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 263
studyWithObiWan = addChoice("studyWithObiWan", "&Study With
Obi Wan");
studyMenu->addAction(studyWithObiWan);
studyWithObiWan->setStatusTip("He will certainly open doorsfor you...");
fightObiWan = addChoice("fightObiWan", "Fight &Obi Wan");
fightMenu->addAction(fightObiWan);
fightObiWan->setStatusTip(
"You’ll learn some tricks from him that way, for sure!");
[ . . . . ]
QMainWindow::menuBar()->addMenu(useMenu);
QMainWindow::menuBar()->addMenu(studyMenu);    QMainWindow::menuBar()->addMenu(fightMenu);
toolbar = new QToolBar("Choice ToolBar", this);
toolbar->addActions(actionGroup->actions());
QMainWindow::addToolBar(Qt::LeftToolBarArea, toolbar);QObject::connect(actionGroup, SIGNAL(triggered(QAction*)), 
this, SLOT(actionEvent(QAction*)));
QWidget::move(300, 300);
QWidget::resize(300, 300);
}
The ClassName:: prefixes we use in methods here are not necessary, because the methods can
be called on “this” . We list the classname only to show the human reader from which class themethod was inherited.
It’s already in a QActionGroup, but we also add it to a QMenu.This gives us visible buttons in a dockable widget for each of the QActions.
Instead of connecting each individual action’s signal, we perform one connect to an
actionGroup that contains them all.
It is possible to connect individual QAction triggered() signals to individual
slots. It is also possible to group related QAction st o g e t h e ri na QActionGroup ,a s
we have just done. QActionGroup offers a single signal triggered(QAction*) ,
which makes it possible to handle the group of actions in a uniform way.
After being created, each QAction is added to three other objects (via
addAction() ):
1. A QActionGroup , for signal handling
2. A QMenu , one of three possible pull-down menus in a QMenuBar
3. A QToolBar , where it is rendered as a button432143CHAPTER 11: QT GUI WIDGETS
264ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 264
EXAMPLE 11.21 src/widgets/menus/study.cpp11.7 QACTIONS, QTOOLBARS, AND QACTIONGROUPS
265
[ . . . . ]
// Factory method for creating QActions initialized in a uniform way
QAction* Study::addChoice(QString name, QString text) {
QAction* retval = new QAction(text, this);retval->setObjectName(name);retval->setEnabled(false);retval->setCheckable(true);actionGroup->addAction(retval);
1
return retval;
}
Add every action we create to a QActionGroup so that we only connect one signal to a slot.
T o make this example a bit more interesting, we established some logical depend-
encies between the menu choices so that they were consistent with the plot of thevarious movies. This logic is expressed in the 
actionEvent() function. (See
Example 11.22).
EXAMPLE 11.22 src/widgets/menus/study.cpp
[ . . . . ]
void Study::actionEvent(QAction* act) {
QString name = act->objectName();QString msg = QString();
if (act == useTheForce ) {
studyWithObiWan->setEnabled(true);fightObiWan->setEnabled(true);useTheDarkSide->setEnabled(true);       
}if (act == useTheDarkSide) {
studyWithYoda->setEnabled(false);fightYoda->setEnabled(true);studyWithEmperor->setEnabled(true);fightEmperor->setEnabled(true);fightDarthVader->setEnabled(true);
}
if (act == studyWithObiWan) {
fightObiWan->setEnabled(true);fightDarthVader->setEnabled(true);studyWithYoda->setEnabled(true);
}
[ . . . . ]1
continuedezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 265
if (act == fightObiWan ) {
if (studyWithEmperor->isChecked()) {
msg = "You are victorious!"; 
}else {
msg = "You lose.";act->setChecked(false);studyWithYoda->setEnabled(false);
}
}
[ . . . . ]
if (msg != QString()) {
QMessageBox::information(this, "Result", msg, "ok");
}
}
Because all actions are in a QActionGroup , a single triggered(QAction*)
signal can be connected to the actionEvent() slot.
The client code in Example 11.23 shows how the program starts.
EXAMPLE 11.23 src/widgets/menus/study.cpp
[ . . . .]
int main( int argc, char ** argv ) {
QApplication a( argc, argv );Study study;study.show();return a.exec();
}
Here is a screenshot of the running program.CHAPTER 11: QT GUI WIDGETS
266
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 266
All menu choices except one are initial ly disabled. As the user selects from the
available choices, other options become enabled or disabled. Also, notice that thethere is consistency between the buttons and the choices in the menus. Clicking onan enabled button causes the corresponding menu item to be checked.
QAction
stores the state (enabled/checked), and the QMenu and QToolBar provide views
of the QAction .
EXERCISES: QACTIONS, QMENUS,
AND QMENUBARS
1.(Discussion question) There are QAction s as children of QWidget s all over the
place. How do you gather them all for a ShortcutView widget that lets the userdisplay and change all of the keyboard shortcuts in the application?
2.Revisit the 15 puzzle application in Section 11.5.2 and add 
QActions for:
■Shuffle puzzle
■Reset puzzle
■Quit
For Quit, pop up a message box asking whether the user is sure before actually
quitting.
3.Write a “login” application using QMainWindow . Start with these QActions:
■Login
■Create New User
■Edit Preferences
■Change Password
These choices should be available by pull-down menu as well as toolbar. Create
QActions and a QActionGroup for them all.
The last two choices should be disabled unless the user is logged in.The initial login screen should have 
QLineEdits for a user id and a pass-
word. If the user chooses “Create New User” or “Change Password” , the programshould display a new form with 
QLineEdits . It should ask for the password
twice, and make sure the passwords match, before actually performing theoperation. If the passwords mismatch, try again.
For “Login” , it should check that the user exists and that the password is valid,
before letting you log in, and enabling the other 
QActions .
If the user chooses “Edit Preferences” it should ask the following questions:
■What is your name?
■What is your quest?11.7 QACTIONS, QTOOLBARS, AND QACTIONGROUPS
267ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 267
■What is your favorite color? (Use a QComboBox with preset colors to red,
green, blue, black, pink, and chartreuse to choose from.)
It should remember these for each user from previous sessions.
The program should load the user data from a file called “users.xml” on
startup and save to the same file when finished, without any interaction. Loadand save in any format you want, using 
QTextStream and QFile .
EXERCISE: CARD GAME GUI
Write a blackjack game, with the following actions:
1.New game
2.Deal new hand
3.Shuffle deck
4.Hit me—ask for another card
5.Stay—evaluate my hand
6.Quit—stop playing
These actions and the rules of the game are explained below.
When the game starts, the user and the dealer are each dealt a “hand” of cards.
Each hand initially consists of two cards. The user plays her hand first by decidingto add cards to her hand with the “Hit me” action zero or more times. Each Hit addsone card to her hand.The user signals that she wants no more cards with the “Stay”action.CHAPTER 11: QT GUI WIDGETS
268
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 268
For the purposes of evaluation of a hand, a “face card” (Jack, Queen, and King)
counts as 10 points, an Ace can count as 1 or 11 points, whichever is best. Eachother card has a number and a point value equal to that number. If the hand con-sists of an Ace plus a Jack, then it is best to count the Ace as 11 so that the totalscore is 21. But if the hand consists of an 8 plus a 7, and an Ace is added to the hand,it is best to count the Ace as 1.
The object of the game is to achieve the highest point total that is not greater
than 21. If a player gets a point total gr eater than 21, that player is “busted” (loses)
and the hand is finished.
If a player gets five cards in her hand with a total that is not greater than 21, then
that player wins the hand.
After the user either wins, loses, or Stays, the dealer can take as many hits as nec-
essary to obtain a point total greater than 18. When that state is reached the dealermust Stay and the hand is finished. The player whose score is closer to, but notgreater than, 21 wins. If the two scores are equal, the dealer wins.
When the hand is over, the user can only select “Deal hand” , “New game” , or
“Quit” (i.e., Hit and Stay are disabled).
After the user selects “Deal hand” , that choice should be disabled until the hand
is finished.
Keep track of the number of games won by the dealer and by the user, starting
with zero for each player, by adding one point to the total for the winner of eachhand. Display these totals above the cards.
Deal more cards without resetting the deck until the deck becomes empty or
the user chooses “Shuffle deck” . Try to reuse or extend the 
CardDeck and related
classes that you developed earlier in Section 10.3. Add a graphical representationto your game by showing a 
QLabel with a QPixMap for each card, as was done in
Chapter 11.
Provide a pull-down menu and a toolbar for each of the QActions . Make sure
that Hit and Stay are only enabled after the game has started.
Show how many cards are left in the deck in a read only QSpinBox at the top
of the window.
New game should zero the games won totals and reset the deck.11.7 QACTIONS, QTOOLBARS, AND QACTIONGROUPS
269ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 269
BlackJack UML DiagramCHAPTER 11: QT GUI WIDGETS
270
QMainWindow QWidget
BlackJack
+ BlackJack()
+ loadSettings()+ closeEvent(event : QCloseEvent*)+ deal()+ actionEvent(act : QAction*)
Hand
+ Hand(name : QString)+ operator <<(card : Card*) : Hand&# handChanged()Deck
+ Deck()+ shuffle()+ reset()+ pick() : Card*+ toString() : QString # cardsLeft( : int)
Card
 - m_label : QLabel* - m_name : QString
+ Card(name : QString)
+ name() : const QString&+ label() : QLabel*+ value() : int+ isAce() : boolHandView
+ HandView(hand : Hand*)+ setModel(hand : Hand*)+ rescanHand()2
2
1
*1
52+m_deck
11.7.1.1 Design Suggestions
Try to keep the model classes separate from the view classes, rather than adding
GUI to the model classes. Keeping a strong separation between model and viewwill give us benefits later.
Figure 11.10 is only a starting point. Y ou need to decide on the base class(es)
to extend for defining the model classes, as well as which containers to reuse.
T o modify the UML diagram you can try loading the diagram file,
cardgame.xmi, into 
umbrello .
11.8 Regions and QDockWidgets
Any class that derives from QMainWindow has four dock window regions, one on
each of the four sides of the central widget. These four regions are used for attach-ing secondary windows to the central widget.ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 270
A QDockWidget can be thought of as an envelope for another widget. It has
a title bar and a content area to contain the other widget. Depending on how it isset, a 
QDockWidget can be undocked, resized, dragged to a different location, or
docked to the same or to a different dock window region by the end user.
The QMainWindow correctly creates the slidable QSplitter s between the
central widget and the QDockWidgets. The two principal QMainWindow func-
tions for managing the dock window regions are
1.setCentralWidget(QWidget*) , which establishes the central widget
2.addDockWidget(Qt::DockWidgetAreas ,QDockWidget*) , which
adds the given QDockWidget to the specified dock window region.
DockWindows are very important in integrated development environments,
because different tools or views are needed in different situations. Each view is awidget, and they can all be “plugged” into the main window quite easily with thedocking mechanism as shown in Figure 11.8.11.8 REGIONS AND QDOCKWIDGETS
271
FIGURE 11.8 Dragged DockWindows
Like most KDE applications, kdbg , the stand-alone KDE debugger, makes use of
DockWindows. kdbg has a source code window (central widget) and dockable
views for things such as:
■Program stack
■Output
■Watches
■Local variables
■Threadsezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 271
These widgets do not all need to be visible at the same time, so there is a View
menu that lets you select or de-select all of the different views.
QMainWindow ::createPopupMenu() returns this menu, permitting you to add
it to toolbars or other pull-down menus.
11.9 Views of a QStringList
Example 11.24 demonstrates the use of the simplest concrete model,
QStringListModel .
EXAMPLE 11.24 src/modelview/qstringlistmodel/simplelistapp.h
#ifndef SIMPLELIST_H
#define SIMPLELIST_H
#include <QApplication>
#include <QListView>#include <QStringListModel>#include <QMainWindow>#include <QPushButton>/* Controller example */
class SimpleListApp : public QApplication {
Q_OBJECTpublic:SimpleListApp(int argc, char* argv[]); 
public slots:
void showNewChanges();void addItem();
private:
QStringListModel m_Model;QMainWindow m_Window;QListView m_View;QPushButton m_Button;
};
#endif
created first
destroyed first
SimpleListApp extends QApplication and is the “managing object” for all
others.
Because all of the objects ar e direct children of the SimpleListApp ,w e
defined the other objects as members, rather than pointers to heap objects. Theircreation and destruction is then done during 
SimpleListApp ’s creation and
destruction. The model is listed before the view so that it is destroyed after the view.2121CHAPTER 11: QT GUI WIDGETS
272ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 272
The implementation of this class, with a bit of client code, is shown in
Example 11.25.
EXAMPLE 11.25 src/modelview/qstringlistmodel/simplelistapp.cpp
#include "simplelistapp.h"
#include <QDebug>#include <QVBoxLayout>
SimpleListApp::SimpleListApp(int argc, char* argv[]) :
QApplication(argc, argv), m_Button("Insert") {11.9 VIEWS OF A QSTRINGLIST
273
QString englishDays = "Monday,Tuesday,Wednesday,Thursday,Friday,"
"Saturday,Sunday";
QString frenchDays = "Lundi,Mardi,Mercredi,Jeudi,Vendredi"
",Samedi,Dimanche";
QString dutchDays = "Mandaag,Dinsdag,Wowoensdag,Dunderdag,"
"Vrijdag,Zaterdag,Zonedag";
QStringList days = dutchDays.split(",");                         m_Model.setStringList(days);m_View.setModel(&m_Model);connect(this, SIGNAL(aboutToQuit()), 
this, SLOT(showNewChanges()));
QWidget *wid = new QWidget(&m_Window);QVBoxLayout *layout = new QVBoxLayout(wid);m_Window.setCentralWidget(wid);layout->addWidget(&m_View);layout->addWidget(&m_Button);connect (&m_Button, SIGNAL(clicked()),
this, SLOT(addItem()));
m_Window.setVisible(true);
}
void SimpleListApp::addItem() {
static int itemnumber = 1;QString str = QString("item #%1").arg(itemnumber++);QStringList sl = m_Model.stringList();sl << str;m_Model.setStringList(sl);
}
void SimpleListApp::showNewChanges() {
qDebug() << " The new days of the week: ";qDebug() << m_Model.stringList().join(",");
}
int main(int argc, char* argv[]) {
SimpleListApp app(argc, argv);return app.exec();
}ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 273
CHAPTER 11: QT GUI WIDGETS
274
When the app in Example 11.24 is run an editable QListView appears. Y ou can
use the mouse or arrow keys to navigate, and use F2 or double-click to edit.After you exit, you will see the revised days of the week:
The new days of the week:
"Mandaag,Dinsdag,Wednesday,Thursday,Friday,Saturday,Zonedag"
EXERCISE: VIEWS OF A QSTRINGLIST
Provide a graphical front-end for the equivalence engine from Section 10.7. The
UI should have a QLineEdit for the the user to type in new equivalences, and 
two  QListView widgets side by side above it.
In the diagram shown here, the item bis selected on the left, and we can see that
b’s equivalences are c,d,eon the right. Any time the “Submit” button is clicked,
whatever is in the TextEdit is added to the equivalence engine, and we should beable to see that in subsequent views.
POINTS OF DEPARTURE
■Read the Qt Designer Manual and follow the tutorial to familiarize your-
self with a more graphical way of defining GUIs.
■Qt Quarterly3has an article that discusses how to write a shortcut editor.
3http://doc.trolltech.com/qq/qq14-actioneditor.htmlezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 274
REVIEW QUESTIONS
275
REVIEW QUESTIONS
1. List six things that QWidgets have in common.
2. How can you save and later restore the size, position, and arrangements
of widgets for a GUI app?
3. Why would you want to do such a thing?4. What is a dialog? Where is an appropriate place to use it?5. What is a 
QLayout ? What is its purpose? What is an example of a con-
crete QLayout class?
6. Can a widget be a child of a layout?7. Can a layout be a child of a widget?8. Revisiting Example 11.15, how does the 
QGridLayout determine the
number of columns? What would be the effect of using 
mainGrid->addWidget(moveLeft, 1,2); 
in line 25?
9. What are the advantages of listing our images in a resources file?
10. What is the difference between a spacer and a stretch?11. What is a 
QAction ? How are actions triggered?
12. It is possible to create QMenus without using QActions. What are the
advantages of using a QAction ?ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 275
ezus_138004_ch11.qxd  8/4/06  9:58 AM  Page 276
27712.1 QProcess and Process Control. . . . . . . . 278
12.2 Threads and QThread . . . . . . . . . . . . . . . 29012.3 Summary: QProcess and QThread. . . . 30312CHAPTER 12
Concurrency
QProcess and QThread provide two approaches
to concurrency. We discuss how to create andcommunicate with processes and threads, as well astechniques for monitoring and debugging them.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 277
12.1 QProcess and Process Control
QProcess is a very convenient (and cross-platform) class for starting and con-
trolling other processes. It is derived from QObject and takes full advantage of
signals and slots to make it easier to “hook up” with other Qt classes.
We discuss now a simple example that starts a process and views its continu-
ally running output. Example 12.1 shows the definition of a simple class derivedfrom 
QProcess .1
EXAMPLE 12.1 src/logtail/logtail.h
[ . . . . ]
#include <QObject>#include <QProcess>class LogTail : public QProcess {
Q_OBJECT
public:
LogTail(QString fn = QString());~LogTail();
public slots:
void logOutput();
};
[ . . . . ]
A QProcess can spawn another process using the start() function. The new
process is a child process in that it will terminate when the parent process does.Example 12.2 shows the implementation of the constructor and destructor of the
LogTail class.2
EXAMPLE 12.2 src/logtail/logtail.cpp
[ . . . . ]
LogTail::LogTail(QString fn) {
if (fn == QString()) {
fn = "/var/log/apache/access.log";
}
1tail-f runs forever showing whatever is appended to a file, and is useful for showing the contents
of a log file of a running process.
2It is also possible to use startDetached() to start a process that will continue to live after the call-
ing process exits.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 278
connect (this, SIGNAL(readyReadStandardOutput()),
this, SLOT(logOutput()));
QStringList argv;argv << "-f" << fn;// We want to exec "tail -f filename"start("tail", argv); 
}
LogTail::~LogTail() {
terminate();  
}
When there is input ready, we will know about it.
Returns immediately, and now there is a forked process running independently but “attached”to this process. When the calling process exits, the forked process will terminate.
Attempts to terminate this process.
The child process can be treated as a sequential I/O device with two predefined out-
put channels that represent two separate streams of data: stdout and stderr .
The parent process can select an output channel with setReadChannel()
(default is stdout ). The signal readyReadStandardOutput() is emitted when
data is available on the selected channel of the child process. The parent process canthen read its output by calling 
read() ,readLine() ,o r  getChar() . If the child
process has standard input enabled, the parent can use write() to send data to it.
Example 12.3 shows the implementation of the slot logOutput() , which 
is connected to the signal readyReadStandardOutput() and uses
readAllStandardOutput() so that it pays attention only to stdout .
EXAMPLE 12.3 src/logtail/logtail.cpp
[ . . . . ]
// tail sends its output to stdout.
void LogTail::logOutput() {  
QByteArray bytes = readAllStandardOutput();QStringList lines = QString(bytes).split("\n");foreach (QString line, lines) {
qDebug() << line;
}
}
event driven—passive interface
The use of signals eliminates the need for a read loop. When there is no more input
to be read, the slot will no longer be called. Signals and slots make concurrent codemuch simpler to read, because they hide the event-handling and dispatching code.Some client code is shown in Example 12.4.1132132112.1 QPROCESS AND PROCESS CONTROL
279ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 279
EXAMPLE 12.4 src/logtail/logtail.cpp
[ . . . . ]
#include <QApplication>
#include <logwindow.h>#include <argumentlist.h>
int main (int argc, char* argv[]) {
QApplication app(argc, argv);ArgumentList al;LogWindow lw("debug");lw.setWindowTitle("logtail demo");QString filename;if (al.size() > 1) filename = al[1];LogTail tail(filename);lw.show();return app.exec();
}
Create a scrolling edit window watching debug messages.
Create object, but start process too.
This application appends lines to the LogWindow whenever they appear in the
specified log file. The default log file is named access.log for the apache Web
server on a typical *nix local host.
12.1.1 Processes and Environment
Environment variables are name/value string pairs that can be stored quite easily
in a map or a hash table. Every running process has an environment , or a collec-
tion of environment variables. Most programming languages support a way ofgetting and setting these variables.
The most common environment variables are
1.
PATH , a list of directories to search for executables
2.HOME , the location of your home directory
3.HOSTNAME (*nix) or COMPUTERNAME (win32), which usually gives you
the name of your machine
4.USER (*nix) or USERNAME (Win32), which usually gives you the cur-
rently logged-in user
Another environment variable you will encounter in the context of the exercises is
CPPLIBS , which denotes the location of our own C++ libraries.
Environment variables and their values are arbitrarily set by the parent process,
so they can be any pair of strings. Programs that depend on specific variables are2121CHAPTER 12: CONCURRENCY
280ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 280
generally not portable, but depend someho w on their parent process. Variables pro-
vide a convenient cross- language mechanism for communicating information
between processes.
Operating system shells allow the user to set environment variables for that
process and its future children. Here are some examples.
1. Microsoft Windows desktop: start -> settings -> system ->
advanced -> environment variables12.1 QPROCESS AND PROCESS CONTROL
281
3Some platforms also offer setenv() , which is more convenient but less portable.2. Microsoft command prompt: set VARIABLE=value and echo
%VARIABLE%
3. bash command line: exportVARIABLE=value andecho$VARIABLE
Many programming languages support getting and setting environment variables
too, as listed here.
1. C/C++: getenv() and putenv() from <cstdlib > (see Appendix B)3
2. Python: os.getenv() and os.putenv()
3. Perl:%ENV hashtable
4. Java 1.5: ProcessBuilder.environment()
5. Qt 4:QProcess::environment()
ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 281
Changing the environment does not affect other processes that are already running.
Environments are inherited from the parent process at process creation time.
Any program that you run is quite possibly a few levels deep in the process tree.
This is because the typical desktop operating system environment consists ofmany processes running together. In Figure 12.1 indentation levels indicate theparent-child relationships. Processes that are at the same indentation level are sib-lings (i.e., children of the same parent).CHAPTER 12: CONCURRENCY
282
FIGURE 12.1 Linux process hierarchy
Whenever program A runs program B, A is the parent process of B. B inherits (a
copy of) A ’s environment when B is created. Changes to B’s environment frominside B will only affect B and B’s future children, and will always be invisible to A.
In Example 12.5, we verify that the value given to  
setenv() is propagated to
its child process.
EXAMPLE 12.5 src/environment/setenv.cpp
#include <qstd.h>
#include <argumentlist.h>#include <QProcess>#include <cstdlib>Init
startxll
kdm
kde
konsole
bash
qmake
make
g++
./environmentezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 282
class Fork : public QProcess {
public:
Fork(QStringList argv = QStringList() ) {
execute("environment", argv);
}~Fork() {
waitForFinished();
}
};
int main(int argc, char* argv[]) {
using namespace qstd;ArgumentList al(argc, argv);
al.removeFirst();
bool fork=al.getSwitch("-f");
QStringList extraVars;
if (al.count()  > 0) {
setenv("PENGUIN", al.first().toAscii(), true);
}cout << " HOME=" << getenv("HOME") << endl;cout << " PWD=" << getenv("PWD") << endl;cout << " PENGUIN=" << getenv ("PENGUIN") << endl;
if (fork) {
Fork f;
}
}
Runs this same app as a child.
When this program is run, our output looks like this:
/home/lazarus/src/environment> export PENGUIN=tux
/home/lazarus/src/environment> ./environment -f
HOME=/home/lazarusPWD=/home/lazarus/src/environmentPENGUIN=tuxHOME=/home/lazarusPWD=/home/lazarus/src/environmentPENGUIN=tux
/home/lazarus/src/environment> ./environment -f opus
HOME=/home/lazarusPWD=/home/lazarus/src/environmentPENGUIN=opusHOME=/home/lazarusPWD=/home/lazarus/src/environmentPENGUIN=opus1112.1 QPROCESS AND PROCESS CONTROL
283ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 283
CHAPTER 12: CONCURRENCY
284
12.1.2 Qonsole: Writing an Xterm in Qt
A command line shell reads commands from the user and prints the output. In
this example, we have a LogWindow (see Section 7.4) providing a view of the out-
put of another running process, in this case, bash . The QProcess is a model ,
representing a running process. Figure 12.2 shows a screenshot of Qonsole , our
first attempt at a GUI for a command shell.
FIGURE 12.3 Qonsole UML: Model and viewFIGURE 12.2 Qonsole1
Because it connects signals to slots and handles user interactions, Qonsole is con-
sidered a controller . Because it derives from QMainWindow , it also contains some
view code. The UML diagram in Figure 12.3 shows the relationships between theclasses in this application.
QMainWindow QT extEdit
QProcessQonsole
+ Qonsole()
+ execute()+ showOutput()LogWindow
QLineEdit-mInputArea
Model-mBash
ViewViewView
Controller
-mLogw- shouldScroll : int
In Example 12.6 we see how the constructor establishes the structure of
Qonsole and the important connections between its components.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 284
EXAMPLE 12.6 src/qonsole/qonsole1/qonsole.cpp
[ . . . . ]
Qonsole::Qonsole() {
m_Logw = new LogWindow("debug"); m_Logw->setReadOnly(true);setCentralWidget(m_Logw); m_InputArea = new  QLineEdit(); QDockWidget* qdw = new QDockWidget("Type commands here");qdw->setWidget(m_InputArea);addDockWidget(Qt::BottomDockWidgetArea, qdw);connect (m_InputArea, SIGNAL(returnPressed()),
this, SLOT(execute()));
m_Bash = new QProcess();m_Bash->setReadChannelMode(QProcess::MergedChannels);connect (m_Bash, SIGNAL(readyReadStandardOutput()),
this, SLOT(showOutput()));
m_Bash->start("bash", QStringList() << "-i");
}
Merge stdout and stderr.
Run bash in interactive mode.
Whenever bash outputs anything, Qonsole sends it to the LogWindow .W h e n e v e r
the user presses the return key, Qonsole grabs any text that is in the QLineEdit
and sends it to bash , which interprets it as a command, as we see in Example 12.7.
EXAMPLE 12.7 src/qonsole/qonsole1/qonsole.cpp
[ . . . . ]
void Qonsole::showOutput() { 
QByteArray bytes = m_Bash->readAllStandardOutput();QStringList lines = QString(bytes).split("\n");foreach (QString line, lines) {
m_Logw->append(line);
}
}
void Qonsole::execute() {
QString cmdStr = m_InputArea->text() + "\n";m_InputArea->setText("");m_Logw->append(cmdStr);QByteArray bytes = cmdStr.toUtf8();m_Bash->write(bytes);
}
A slot that gets called whenever input is ready
8-bit Unicode Transformation Format
Send the data into the stdin stream of the bash child process
Example 12.8 shows the client code that launches this application.321321212112.1 QPROCESS AND PROCESS CONTROL
285ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 285
EXAMPLE 12.8 src/qonsole/qonsole1/qonsole.cpp
[ . . . . ]
#include <QApplication>int main(int argc, char* argv[]) {
QApplication app(argc, argv);Qonsole qon;qon.show();return app.exec();
}
12.1.3 Qonsole with Keyboard Events
In the preceding example, Qonsole had a separate widget for user input. For a more
authentic xterm experience, the user should be able to type commands in the com-mand output window. T o accomplish this 
Qonsole needs to capture keyboard
events. The first step is to override the QObject base class eventFilter()
method, as we see in Example 12.9, the revised class definition.
EXAMPLE 12.9 src/qonsole/keyevents/qonsole.h
[ . . . . ]
class Qonsole : public QMainWindow {
Q_OBJECT
public:
Qonsole();public slots:
void execute();
void showOutput();bool eventFilter(QObject *o, QEvent *e)  ;
protected:
void updateCursor();
private:
QString m_UserInput;LogWindow* m_Logw;QProcess* m_Bash;
};
[ . . . . ]
As we discussed in Section 9.3, an event is an object derived from QEvent . Within
the context of an application, such a QEvent is associated with a QObject that is
its intended receiver. The receiving object has a handler to process the event. An
eventFilter examines a QEvent and determines whether or not to permit it to
be processed by the intended receiver. We have provided our revised Qonsole
application with an eventFilter() function that will be used to filter keyboardCHAPTER 12: CONCURRENCY
286ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 286
events from m_Logw , an extended QTextEdit .QOnsole , an extended
QMainWindow , is the intended recipient of those events. The implementation of
this function is shown in Example 12.10.
EXAMPLE 12.10 src/qonsole/keyevents/qonsole.cpp
[ . . . . ]
bool Qonsole::eventFilter(QObject *o, QEvent *e) {
if (e->type() == QEvent::KeyPress) {
QKeyEvent *k = static_cast<QKeyEvent*> (e);int key = k->key();QString str = k->text();m_UserInput.append(str);updateCursor();if ((key == Qt::Key_Return) || (key == Qt::Key_Enter) ) {
execute();return true;
}else {
m_Logw->insertPlainText(str);return true;
}
}return QMainWindow::eventFilter(o,e);
}
We processed the event. This prevents other widgets from seeing it.
Let the base class eventFilter have a shot at it.
Each time a key is pressed by the user the character generated by that key is
appended to the mUserInput string and the position of the cursor in the
LogWindow is adjusted by the member function updateCursor() . When the
Enter key is pressed, the member function execute() is called so that the com-
mand string can be sent to the shell and then reset. Example 12.11 shows theimplementation of these two functions.
EXAMPLE 12.11 src/qonsole/keyevents/qonsole.cpp
[ . . . . ]
bool Qonsole::eventFilter(QObject *o, QEvent *e) {
if (e->type() == QEvent::KeyPress) {
QKeyEvent *k = static_cast<QKeyEvent*> (e);int key = k->key();QString str = k->text();m_UserInput.append(str);updateCursor();212112.1 QPROCESS AND PROCESS CONTROL
287
continuedezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 287
if ((key == Qt::Key_Return) || (key == Qt::Key_Enter) ) {
execute();return true;
}else {
m_Logw->insertPlainText(str);return true;
}
}return QMainWindow::eventFilter(o, e);
}
We processed the event. This prevents other widgets from seeing it.
Let the base class eventFilter have a shot at it.
All that remains to be done is to call the base class function
installEventFilter() on mLogw , the widget whose events we want to cap-
ture. This is done in the constructor, as we see in Example 12.12.
Here is the controller code that sets up Qonsole.
EXAMPLE 12.12 src/qonsole/keyevents/qonsole.cpp
[ . . . . ]
Qonsole::Qonsole() {
m_Logw = new LogWindow("debug");setCentralWidget(m_Logw);m_Logw->installEventFilter(this);m_Logw->setLineWrapMode(QTextEdit::WidgetWidth);m_Bash = new QProcess();m_Bash->setReadChannelMode(QProcess::MergedChannels);connect (m_Bash, SIGNAL(readyReadStandardOutput()),
this, SLOT(showOutput()));
m_Bash->start("bash", QStringList("-i"), QIODevice::ReadWrite);
}
EXERCISES: QPROCESS AND PROCESS
CONTROL
1.Modify Qonsole to support the backspace key.
2.Modify Qonsole to support multiple simultaneous terminals in separate tabs.
3.The command htpasswd4can be run from the shell, and it provides a
command-line interface for encrypting and storing passwords. It stores a list ofnames and passwords separated by colons in a text file. The passwords areencrypted with a user-selectable protocol.2121CHAPTER 12: CONCURRENCY
288
4This command is available on most Linux systems, since it is included with Apache httpd server, one
of the most widely used Web servers. It is also available on other platforms at no change.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 288
The constructor should load all users and encrypted passwords into a QMap .
addUser will require using QProcess to run htpasswd .checkPassword
will use the in-memory map and the htpasswd-nb command to verify that
the password is correct.
Write a graphical front-end to this application—a login screen, as in the fig-
ure that follows.If htpasswd has been installed on your *nix system you can learn about its
command-line options by viewing its manual page.
Write a Qt wrapper, called Users , around the htpasswd command. It
should have the interface shown in the following figure.12.1 QPROCESS AND PROCESS CONTROL
289
Use message boxes to describe precisely any errors that occur during login. For
example if the user enters the correct username but an incorrect password, theerror message should be different from the one for an incorrect username. In areal-world security application, you would not have different error messages (noreason to help would-be hackers gaining access to our systems, right?) but wewant a different message to help in testing.
If the user clicks Register , show another dialog (or modify the existing one)
so that it asks for the password twice, to verify that the user entered it correctly.
The authors encountered some difficulties using the crypt()(-d)
and MD5 (-m) encryption schemes for this problem, so we recommend
using SHA ( -s) encryption.Users
+ containsUser(userName : QString) : bool
+ checkPassword(user : QString, pw : QString) : bool+ addUser(user : QString, pw : QString) : bool
ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 289
12.2 Threads and QThread
Platform-independent threads are a rarity in C++ open-source libraries, because
threads are handled in different ways by different operating systems. On the otherhand, it is not possible to write GUI applicat ions without threads, since a user click
may take just an instant, while the work that needs to be done in response maytake much longer. Users are accustomed to being able to continue moving andclicking while their work is being done, and seeing constant progress feedback atthe same time.
A single process can simulate multitasking by supporting multiple threads.
Each thread has its own call stack and a current statement to execute. A multi-threaded process iterates through the threads, switching to each thread’s stack, exe-cuting some statements for awhile, and then switching to the next thread. Qt’sthread model permits the prioritizing and control of threads.
12.2.1 QPixmap and QThread Animation 
Example: Movie Player
In this section we write a multithreaded animation viewer application. This appli-
cation loops through a sequence of eight images on the screen. The user controlsthe time interval between images to speed up or slow down the process. Figure 12.4shows the two main classes for this application.CHAPTER 12: CONCURRENCY
290
FIGURE 12.4 UML diagram for Movie and MovieViewQMainWindow QThread
MovieThread
 - mPics : QVector<QPixmap>
 - mDelay : int
+ MovieThread()
+ ~ MovieThread()+ run()+ loadPics()+ stop()+ addFile(filename : const QString&)+ setInterval(newDelay : int)# show(image : const QPixmap*)MovieView
 - label : QLabel*
 - slider : QSlider*
+ MovieView()
+ setDelay(delayval : int)+ showPix(pix : const QPixmap*)# intervalChanged(newInterval : int)ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 290
12.2 THREADS AND QTHREAD
291
We will start with the top-level code in Example 12.13 and then drill down to the
lower layers of code.
EXAMPLE 12.13 src/threads/animate/moviethreadmain.cpp
[ . . . . ]
A new thread starts executing at this point, but the method returns immediately. The new
thread starts by calling movie.run().
The interface for starting a thread is similar to that of starting a process—in bothcases,
start() returns immediately. Instead of running another program, the
newly created thread runs in the same process, shares the same memory, and startsby calling the 
run() function.
The MovieThread does not actually display anything—it is a model that
stores the data representing the movie. Periodically, it emits a signal containing apointer to the correct pixmap to display as seen in Example 12.14.
EXAMPLE 12.14 src/threads/animate/moviethread.cpp
[ . . . . ]
void MovieThread::run() {
int current(0), picCount(m_Pics.size());while (true) {
msleep(m_Delay);   emit show(&m_Pics[current]);current = (current + 1) % picCount; 
}
}1[ . . . . ]
int main(int argc, char** argv) {
QApplication app(argc, argv);MovieView view;MovieThread movie;app.connect(&movie, SIGNAL(show(const QPixmap*)),
&view, SLOT(showPix(const QPixmap*)));
app.connect(&view, SIGNAL(intervalChanged(int)),
&movie, SLOT(setInterval(int)));
app.connect(&app, SIGNAL(aboutToQuit()), &movie, SLOT(stop()));movie.start();view.show();return app.exec();
}
1ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 291
In Example 12.15 we can see the slot that actually displays the images and the slot
that responds to the slider signals. These slots are in the view class, as they should be.
EXAMPLE 12.15 src/threads/animate/movieview.cpp
[ . . . . ]
void MovieView::showPix(const QPixmap* pic) {
label->setPixmap(*pic);
}
void MovieView::setDelay(int newValue) {
QString str;str = QString("%1ms delay between frames").arg(newValue);slider->setToolTip(str);emit intervalChanged(newValue);
}
T o summarize: the run() function emits a signal from the (model)
MovieThread object, which will be received by a slot in the (view) MovieView
object, as arranged by the connect() statement in the main() function (shown
in Example 12.13). Signals are ideal for transmitting data to objects across threads.In Example 12.16 we see how the view is created, and how the slider controls thespeed of the animation.
EXAMPLE 12.16 src/threads/animate/movieview.cpp
[ . . . . ]
MovieView::MovieView() {
resize(200, 200);
slider = new QSlider(Qt::Vertical);
slider->setRange(1,500);slider->setTickInterval(10);slider->setValue(100);slider->setToolTip("How fast is it spinning?");
connect(slider, SIGNAL(valueChanged(int)), this,
SLOT(setDelay(int)));
QDockWidget *qdw = new QDockWidget("Delay");qdw->setWidget(slider);addDockWidget(Qt::LeftDockWidgetArea, qdw);label = new QLabel("Movie");setCentralWidget(label);
}CHAPTER 12: CONCURRENCY
292ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 292
The user controls the time interval between image exposures with a QSlider
widget that is placed in a dock widget.
In Example 12.17, to avoid a crash on exit, we introduced a delay that makes
sure the thread has enough time to be properly terminated.
EXAMPLE 12.17 src/threads/animate/moviethread.cpp
[ . . . . ]
void MovieThread::stop() {
terminate();wait(5000);
}
Putting it all together, we have produced a movie of a spinning yin-yang symbol,
using resources, signals, slots, and threads, with an interface that gives the usercontrol of the spin speed via a docked slider widget. The following figure is ascreenshot of the running program.12.2 THREADS AND QTHREAD
293
T o load images from disk, we use the Qt resource feature (discussed in Section 11.4),
which permits us to “embed” binary files into the executable.
EXAMPLE 12.18 src/threads/animate/moviethread.cpp
[ . . . . ]
void MovieThread::loadPics() {
FileVisitor fv("*.jpg");connect (&fv, SIGNAL(foundFile(const QString&)),
this, SLOT(addFile(const QString&)));
fv.processEntry(":/images/");
} 1
continuedezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 293
void MovieThread::addFile(const QString& filename) {
m_Pics << QPixmap(filename);
}
We are using resources, which link binary files into the executable. They exist in a file system
rooted at “:”. See file: animate.qrc for list of embedded resources (.jpg files).
12.2.2 Movie Player with QTimer
The MovieThread object, discussed in Section 12.2.1, simply emitted a signal
periodically, with the interval determined by the user. This is a very simple use ofa thread.
The 
QTimer class is well suited for emitting periodic signals to drive anima-
tions and other rapid but brief operations.5In Example 12.19 we derive our movie
model class from QTimer instead of deriving it from QThread .
EXAMPLE 12.19 src/threads/animate/movietimer.h
[ . . . . ]
class MovieTimer :public QTimer {
Q_OBJECT
public:
MovieTimer();~MovieTimer();void loadPics();
public slots:
void nextFrame();void addFile(const QString& filename);void setInterval(int newDelay);
signals:
void show(const QPixmap *image);
private:
QVector<QPixmap> pics;int current;
};
[ . . . . ]
The MovieTimer class can be used in place of the MovieThread class of the
previous example. We need to change only one line of the client code fromExample 12.13, as we show in Example 12.20.1CHAPTER 12: CONCURRENCY
294
5Connecting a QTimer signal to a slot that takes a relatively long time to execute may slow down the
main thread and cause the QTimer to miss clock ticks.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 294
12.2 THREADS AND QTHREAD
295
EXAMPLE 12.20 src/threads/animate/movietimermain.cpp
[ . . . . ]
int main(int argc, char** argv) {
QApplication app(argc, argv);MovieView view;MovieTimer movie;app.connect(&movie, SIGNAL(show(const QPixmap*)),
&view, SLOT(showPix(const QPixmap*)));
app.connect(&view, SIGNAL(intervalChanged(int)),
&movie, SLOT(setInterval(int)));
[ . . . . ]
Starts the timer, not a thread.
In fact, the implementation of MovieTimer is simpler than that of MovieThread,
as shown in Example 12.21.
EXAMPLE 12.21 src/threads/animate/movietimer.cpp
[ . . . . ]
MovieTimer::MovieTimer(): current(0) {
setInterval(100);loadPics();connect(this, SIGNAL(timeout()), this, SLOT(nextFrame()));
}
void MovieTimer::nextFrame() {
current = (current + 1) % pics.size();emit show(&pics[current]);
}
QTimer is very convenient and can be used in some situations where, at first, you
might think of using a QThread .A  QTimer with a timeout of 0 will emit its sig-
nal as fast as possible, but only when the Qt event queue is empty. By rewriting a“worker thread” to operate in small chunks when its slot is repeatedly called, you
can achieve something similar to multithreading without slowing down the userinterface response.1app.connect(&app, SIGNAL(aboutToQuit()), &movie, SLOT(stop()));
movie.start();view.show();return app.exec();
}1ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 295
CHAPTER 12: CONCURRENCY
296
12.2.3 Multiple Threads, Queues, and Loggers
Example: Giant
In this section, we present an example of a consumer-producer problem inspired
by the famous fable, “Jack and the Beanstalk.” As we see in Figure 12.5, the mainwindow of the application shows a split-screen view (provided by the
QSplitter ) of two text areas.
6We discussed how to obtain and install libutils in Section 7.4.FIGURE 12.5 Giant versus Jack main window
The slider docked on the left determines the rate at which Jack steals the items on
his list from the Giant. That rate has a random component. The LineEdit dockedon the bottom allows the user to give Jack things to say to the Giant. Each text areais a 
LogWindow that monitors a named Logger . Both classes are provided in
libutils and are documented in our API Docs.6
A Logger is an abstraction for a named stream of bytes. A Logger gets
attached to a LogWindow through signals and slots.
Loggers are important tools for debugging (and, sometimes, even visualizing)
multitasking processes. These are based on the Java loggers, but take advantage ofezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 296
12.2 THREADS AND QTHREAD
297
Qt’s signals and slots, which can send messages and objects across threads. The
UML diagram in Figure 12.6 shows how these classes are related.
FIGURE 12.7 Speaking with signals
When this program executes, two threads are running, Jack and Giant. Each thread
emits signals and writes to loggers independently. The sequence diagram inFigure 12.7 shows how this works in one thread.
Jack and Giant have no knowledge of each other—they are strictly decou-
pled. They do not include each other’s header files, and they are connected to eachQT extEdit
LogWindow
 - shouldScroll : int
+ LogWindow(logName : QString, parent : QWidget*)
+ log(logname : QString)+ append(str : QString)+ checkScroll(newValue : int)
QObject
Logger
 - sm_LogMap : QMap<QString, Logger * >
+ getLogger(logname : QString) : Logger*
+ myDebugHandler(type : QtMsgType, msg : const char*)+ info(str : QString)# data(str : const QString&)# Logger(logname : QString)
: m_JackWindow :  jacklog: m_Jack
: speak signal()
: data signal()
append slotlog slotFIGURE 12.6 Loggersezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 297
CHAPTER 12: CONCURRENCY
298
LogWindowQThread
0..1
20..1
-m_Giant-m_Jack
GiantWindow
 - m_GiantLogWindow : LogWindow*
  - m_JackLogWindow : LogWindow* - m_LineEdit : QLineEdit* - m_SpeakButton : QPushButton* - m_KillButton : QPushButton* - m_GiantSlider : QSlider* - m_Giant : Giant* - m_Jack : Jack*
+ GiantWindow()
+ ~ GiantWindow()+ speakJack()+ bigT ext(text : QString)+ smallT ext(text : QString)+ setDelay(delayval : int)+ terminateThreads()Giant
 - m_Fifo : QQueue< QString >
 - m_Delay : int - m_IsDead : bool
+ Giant()
+ run()+ hear(text : const QString&)+ die()+ setDelay(newDelay : int)# say(line : QString)# small(line : QString)# giantDead() - process(message : QString) - distort(text : QString) : QStringJack
 - m_Fifo : QQueue< QString >
 - m_Delay : int - m_BeanstalkChopped : bool - m_Stuff : QStringList
+ Jack()
+ run()+ setDelay(newDelay : int)+ killGiant()# chopBeanstalk()
Each thread has an incoming message queue (fifo). Messages may arrive in the
Giant’s queue faster than he can handle them. Some messages will be respondedto, some will be ignored.
T o make things more interesting, we have connected Jack’s 
Logger ’s data sig-
nal to the Giant’s hear slot, so the Giant is somewhat aware of what Jack is doing
and can react to it. We show the class definition for Giant in Example 12.22.FIGURE 12.8 Jack and Giant UMLother exclusively by signals and slots in controller code from GiantWindow .
These relationships are depicted in the UML diagram in Figure 12.8.ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 298
EXAMPLE 12.22 src/threads/giant/giant.h
[ . . . . ]
class Giant :public QThread {
Q_OBJECT
public:
Giant();void run();
public slots:
void hear(const QString& text);void die();void setDelay(int newDelay);
signals:
void say(QString line);void small(QString line);void giantDead();
private:
void process(QString message);QString distort(QString text);QQueue<QString> m_Fifo;int m_Delay;bool m_IsDead;
};
[ . . . . ]
Even without threads, both Jack and Giant have slots and receive signals emitted
from the Qt event loop, as we see in Example 12.23.
EXAMPLE 12.23 src/threads/giant/giant.cpp
[ . . . . ]
void Giant::die() {
if (m_IsDead)
return;
m_IsDead = true;m_Fifo << "What? You nasty little worm.";m_Fifo << "I will squash you!!! ";m_Fifo << "So you’re running back down the beanstalk.";m_Fifo << "I am coming right after you!";msleep(m_Delay);m_Fifo << "Oh no!! Someone chopped the beanstalk!!";m_Fifo << "aaaaaaaaa!!! .........";m_Fifo << "   *splat* \n";
}
void Giant::hear(const QString &text) {
QString t2 = ":" + text;m_Fifo << t2;
}
Which thread is going to sleep here, the Giant or the MainThread?1112.2 THREADS AND QTHREAD
299ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 299
In addition to responding to signals from the main thread, Jack and Giant each
override the run() function. Example 12.24 shows the Giant’s thread code, which
is a typical “infinite” loop, reading input when there is some and sleeping whenthere is not.
T o simulate the 
Giant ’s difficulty hearing the sounds made by a creature as
tiny as Jack, we use the distort() function to introduce some noise into his
process() function.
EXAMPLE 12.24 src/threads/giant/giant.cpp
[ . . . . ]
void Giant::run() {
int zcount = 0;while (true) {
zcount = 0;while (m_Fifo.isEmpty()) {
msleep(m_Delay);++zcount ;if (m_IsDead) {
emit giantDead();break;
}if (zcount > 3) {
m_Fifo << "zzzzzz";
}
}QString message = m_Fifo.dequeue();msleep(m_Delay);process(message);
}
}
void Giant::process(QString message) {
if(message.startsWith(":")) {
QStringList l = message.split(":");msleep(m_Delay);if(! l[1].startsWith("(")) {
QString msg = l[1];emit say ("Did I hear a mouse speak? It sounded like");emit say (distort(msg));emit say ("I never could understand those darned mice.");if (msg.startsWith("I FOUND")) {
msg = msg.remove("I FOUND the ").remove("!!");msg = QString("Hey! Where is my %1?").arg(msg);emit say(msg);
}
}
} else
emit say(message);
}CHAPTER 12: CONCURRENCY
300ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 300
GiantWindow is a very primitive GUI front end for Giant. It has slots that can be
hooked up to the giant’s signals, as we see in Example 12.25.
EXAMPLE 12.25 src/threads/giant/giantwindow.h
[ . . . . ]
class GiantWindow : public QMainWindow {
Q_OBJECT
public:
GiantWindow();~GiantWindow();
public slots:
void speakJack();void bigText(QString text);void smallText(QString text);void setDelay(int delayval);void terminateThreads();
private:
LogWindow *m_GiantLogWindow;LogWindow *m_JackLogWindow;QLineEdit *m_LineEdit;QPushButton *m_SpeakButton, *m_KillButton;QSlider *m_GiantSlider;Giant* m_Giant;Jack* m_Jack;
};
[ . . . . ]
The constructor spells out the details of arranging things on the screen and con-
necting signals with slots. Example 12.26 shows some of those details.
EXAMPLE 12.26 src/threads/giant/giantwindow.cpp12.2 THREADS AND QTHREAD
301
continued[ . . . . ]
GiantWindow::GiantWindow() {
resize(800, 600);m_Giant = new Giant();m_Jack = new Jack();
/* The giant talks to the GiantWindow through signals and slots */connect (m_Giant, SIGNAL(say(QString)), this,
SLOT(bigText(QString)));
connect (m_Giant, SIGNAL(small(QString)), this,
SLOT(smallText(QString)));
connect (m_Jack,  SIGNAL(chopBeanstalk()), m_Giant, SLOT(die()));connect (m_Giant, SIGNAL(giantDead()), this,
SLOT(terminateThreads()));ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 301
m_GiantLogWindow = new LogWindow("giant");
m_GiantLogWindow->setToolTip("This is what the giant says");
m_JackLogWindow = new LogWindow("jack");
m_JackLogWindow->setToolTip("This is what Jack is doing");Logger *jackLog = Logger::getLogger("jack");
connect (jackLog, SIGNAL(data(const QString&)),
m_Giant, SLOT(hear(const QString&)));
QSplitter *split = new QSplitter(this);split->addWidget(m_GiantLogWindow);split->addWidget(m_JackLogWindow);setCentralWidget(split);
[ . . . . ]
A LogWindow will display all messages sent to the logger of the same name. In this case,
Logger::getLogger(“jack”) will return an object through which you send messages that get dis-played in this window.
The giant can hear what Jack is saying!!split-window container with draggable splitter between two widgets
We can only add two widgets to split.
12.2.4 Thread Safety and QObjects
A QObject that was created in a particular thread “belongs” to that thread and its
children must also belong to the same thread. Having parent-child relationshipsthat cross over threads is forbidden by Qt.
A thread-safe object is one that can be accessed concurrently by multiple
threads and is guaranteed to always be in a “valid” state.
QObject s are not “thread
safe” by default. T o make an object thread safe, there are a number of approachesto take. Some are listed here, but we recommend the Qt 4 Thread Support
7docu-
mentation for further details.
1.QMutex , for mutual exclusion, along with QMutexLocker , allows an
individual thread T to protect (lock) an object or a section of code sothat no other thread can access it until T releases (unlocks) it.
2.
QWaitCondition , combined with QMutex , can be used to put a thread
into a non-busy block state where it can wait for another thread to wakeit up.
3. A 
QSemaphore is a more generalized QMutex for situations where a
thread may need to lock more than one resource before doing its work.Semaphores make it possible to ensure that a thread only locks resourceswhen enough are available for it to do its job.43214321CHAPTER 12: CONCURRENCY
302
7http://oop.mcs.suffolk.edu/qtdocs/threads.htmlezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 302
EXERCISE: THREADS AND QTHREAD
■Write a program that tells the user how many prime numbers exist in a range
between two numbers supplied in the command line.
■Make the progress bar show the progress of the search (estimated number
of numbers left to check, relative to number of numbers checked). Alsoshow how many primes have been found so far.
■Make the start/stop buttons start/stop the search for prime numbers.Make sure the search thread does not take up so much CPU time that youare unable to perform other user interactions.
■Create a QListWidget (or QListView) that shows the prime numbers
found so far during the search.
■Display the elapsed search time and the number of primes found per second.12.3 SUMMARY: QPROCESS AND QTHREAD
303
12.3 Summary: QProcess and QThread
QProcess and QThread are similar in concept and have one special thing in
common: a powerful start() function that causes an execution fork (twoezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 303
CHAPTER 12: CONCURRENCY
304
“things” are happening, when before the re was only one). Table 12.1 summarizes
the main differences between a process and a thread.
TABLE 12.1 QProcess versus QThread
QProcess QThread
Runs a (presumably) different program Runs in the same process, shares code,
in separate process, separate memory. and shares memory with other threads.
Communicates with child process via Shares memory and code with peer 
streams (stdin ,stdout ,stderr ) threads. Synchronizes using locks, wait 
and passes in data initially using conditions, mutexes, and semaphores.command line arguments (
argc ,argv ) 
or environment variables ( getenv() .
See Appendix B.
Managed by the operating system Managed by the processezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 304
REVIEW QUESTIONS
305
REVIEW QUESTIONS
1. What are two important differences between a process and a thread?
2. List and explain at least two mechanisms by which a parent process
communicates information to its child process.
3. List and explain at least two mechanisms by which threads synchronize
with each other.
4. In what situations can a QTimer be used instead of a QThread ? Why
would one want to do that?ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 305
ezus_138004_ch12.qxd  8/4/06  10:01 AM  Page 306
30713.1 Validators . . . . . . . . . . . . . . . . . . . . . . . . . . 308
13.2 Regular Expressions. . . . . . . . . . . . . . . . . 31013.3 Regular Expression Validation. . . . . . . . 31613CHAPTER 13
Validation and Regular
Expressions
Validation of input data is an important issue that can
be handled in an object-oriented way by a combina-tion of Qt classes. This chapter discusses some effi-cient ways of validating input, including the use ofregular expressions.ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 307
13.1 Validators
V alidators are nonvisual objects that are attached to input widgets (such as
QLineEdit ,QSpinBox , and QComboBox ) to provide a general framework for
checking user input. Qt has an abstract class named QValidator that establishes
the interface for all built-in and custom validators.
There are two concrete subclasses that can be used for numeric range check-
ing:QIntValidator and QDoubleValidator . There is also a concrete sub-
class that can be used for validating a string with a specified regular expression. Wewill discuss regular expressions in the next section.
QValidator:: validate() is a pure virtual method that returns an enumer-
ated value, as follows:
■Invalid : The expression does not satisfy the required conditions and
further input will not help.
■Intermediate : The expression does not satisfy the required condi-
tions, but further input might produce an acceptable result.
■Acceptable : The expression satisfies the required conditions.
Other member functions enable the setting of the conditions that validate() uses.
In Example 13.1 we have a short app that uses the two numerical validators. It
takes an int and a double from the user to display the product. Each input is
given a range check when the user presses return.
EXAMPLE 13.1 src/validate/inputform.h
[ . . . . ]
class InputForm : public QMainWindow {
Q_OBJECT
public:
InputForm(int ibot, int itop, double dbot, double dtop);void setupForm();public slots:
void computeResult();
ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 308
private:
int m_BotI, m_TopI;double m_BotD, m_TopD;QIntValidator* m_IValid;QDoubleValidator* m_DValid;QGridLayout* m_Layout;QLineEdit *m_IntEntry, *m_DoubleEntry;QLabel* m_Result;QWidget* m_Center;
};
[ . . . . ]
In Example 13.2, validators are initialized with range values in the constructor
and are assigned to their respective input widgets in the setupForm() function.
EXAMPLE 13.2 src/validate/inputform.cpp13.1 VALIDATORS
309
[ . . . . ]
InputForm::InputForm(int ibot, int itop, double dbot, double dtop):
m_BotI(ibot), m_TopI(itop), m_BotD(dbot), m_TopD(dtop),m_IValid(new QIntValidator(ibot, itop, this)),m_DValid(new QDoubleValidator(dbot, dtop, 2, this)),
[ . . . . ]
void InputForm::setupForm() {
[ . . . . ]
m_IntEntry->setValidator(m_IValid);
m_DoubleEntry->setValidator(m_DValid);connect(m_IntEntry, SIGNAL(returnPressed()), 
this, SLOT(computeResult()));
connect(m_DoubleEntry, SIGNAL(returnPressed()),
this, SLOT(computeResult()));
}
[ . . . . ]
The running program looks like the screenshot that follows.
If you run it, try to enter a non- int textfield, or a non- float in the second. Y ou
should notice that it does not recognize invalid characters as input.ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 309
CHAPTER 13: VALIDATION AND REGULAR EXPRESSIONS
310
13.2 Regular Expressions
Regular expressions are powerful tools for validating input, for extracting data
from input, and for searching and replacing (see Table 13.1). The regular expres-sion pattern matching language is used to describe regular expressions. A regularexpression ( regex for short) describes constraints on the way a string is composed.
TABLE 13.1 Examples of Regular Expressions
Pattern Meaning 
hello matches the literal string, hello
c*at (quantifier) zero or more occurrances of c, followed by at
c?at zero or 1 occurrances of c, followed by at
c.t (character set: anychar) c followed by any character 
followed by t: cat, cot, c3t, ct
c.*t (char set and quantifier) c followed by 0 or more anychar followed by t:
ct,caaatttt ,carsdfsdft
ca+t (quantifier) + means 1 or more of the preceding “thing,”
so this matches cat ,caat ,caaaat ,b u t  n o t  ct
c\.\*t (literals) backslashes precede special characters 
to “escape them,” so this matches the literal: c.*t
c\\\.t (literals) c\.t
c[0-9a-c]+z matches c312abbaz caa211bac2z 
the(cat|dog)ate (alternation) the cat ate the fish or the dog
the(fish|mouse) ate the mouse or the dog ate the fish ,a n d  
the obvious last one.
\w+ (charset) a sequence of alphanumerics, or a word, same as 
[a-zA-Z0-9]+
\W a character that is not part of a word (punctuation,
whitespace, etc.) 
\s{5} exactly 5 whitespace chars (tabs, spaces, newlines) 
\S{1,5} at least 1, at most 5 non-whitespace (printable characters)  
\d a digit [0-9] (and \Dis a non-digit, i.e., [^0-9] )  
\d{3}-\d{4} 7-digit phone numbers: 555-1234
\bm[A-Z]\w+ \b means word boundary: matches mBuffer but not 
StreamBufferezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 310
Regular expressions were first available in tools such as vi,emacs ,awk,sed,
and the POSIX Standard Library. Perl was the first mainstream programming lan-guage to integrate regular expressions so tightly into the language that it causedmany people to learn regular expressions for the first time. Many enhancementshave been made to the version of regular expressions that Perl recognizes. Theenhancements are part of what we call Perl-style extended regular expressions.
These extended regular expressions are also available in Java and Python.
Qt has a class,
QRegExp , that implements most of the Perl-style extended reg-
ular expression language.
13.2.1 Regular Expression Syntax
A regular expression can be a simple string, in which case it specifies an exact string
match, or it can be a string that includes regular expression meta-characters .A
meta-character is a character that describes other characters.
Here are some of the most commonly used meta-characters.
1. Special characters
■. (the dot matches any character)
■\n(matches the newline character)
■\f(matches the form feed character)
■\t(matches the tab character)
■\xhhhh (matches the Unicode character whose code is the hexadeci-
mal number hhhh in the range 0x0000 to 0xFFFF )
2. Quantifiers: Modifiers that specify the number of occurrences of the pre-
ceding character (or group) that may appear in the matching expression.
■+(1 or more occurrences)
■?(0 or 1 occurrences)
■*(0 or more occurrences)
■{i,j} (at least ibut not more than joccurrences)
3. Character sets: Sets of allowable va lues for the character in the specified
position of the matching expression. Several character sets are predefined:
■\s(matches any whitespace character)
■\S(matches any non-whitespace character)
■\d(matches any digit character: '0' to '9')
■\D(matches any non-digit character)13.2 REGULAR EXPRESSIONS
311ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 311
■\w(matches any “word” character; i.e., any letter or digit or the
underscore ‘_’)
■\W(matches any non-word character)
Character sets can also be specified in square brackets:
■[AEIOU] (matches any of the chars 'A','E','I','O',o r  'U')
■[a-g] (the dash makes this a range from ‘a’ to ‘g’)
■[^xyz] (matches any character except for 'x','y', and 'z')
4. Grouping and capturing characters (round parentheses): Characters that
can be used to form a group. Groups can be back-referenced, meaningthat if there is a match, the grouped values can be captured and accessedin various ways.
For convenience, up to 9 groups can be referenced within the regular
expression by using the identifiers 
\1thru \9.
There is also a QRegExp member function  cap(int nth) that
returns the nth group (as a QString ).
5. Anchoring characters: Assertions that specify the boundaries of a match-
ing effort.
■The caret ( ^), if it is the first character in the regex, indicates that the
match starts at the beginning of the string.
■The dollar sign ( $), when it is the last character in the regex, means
that the effort to match must continue to the end of the string.
■In addition, there are word boundary ( \b) or non-word boundary
(\B) assertions that help to focus the attention of the regex.
Backslashes are used for escaping special characters in C++ strings as
well, so this means that regular expression strings inside C++ stringsmust be “double-backslashed.” In other words, every 
\becomes \\,a n d
to match the backslash character itself you will need four: \\\\
There is much more to regular expressions. Time spent learning to use them is
well-invested time. The documentation for QRegExp is a good place to start. For
a much more extensive discussion, we recommend [Fried198].CHAPTER 13: VALIDATION AND REGULAR EXPRESSIONS
312ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 312
13.2.2 Regular Expressions: Phone 
Number Recognition
The Problem
We want to specify conditions, in a generic way, that must be satisfied by input
data at runtime. For example:
■In a U.S. address, every zip code can have five digits, followed by anoptional dash (-) and four more digits.
■A U.S. phone number consists of ten digits, usually grouped 3 + 3 + 4,with optional parentheses and dashes and an optional initial 1.
■A U.S. state abbreviation must be one from the set of 50 approvedabbreviations.
How can we impose conditions such as these on incoming data in an object-
oriented way?
Suppose that you wanted to write a program that recognized phone number
formats, and could accept Dutch or U.S./Canada phone numbers. Y ou would needto take the following things into consideration.
■For any U.S./Canada format numbers, there must AAA EEE NNNN ,
where A = area code, E = exchange, and N = number.
■For Dutch format numbers, there must be CC MM followed by eitherNN NN NNN or NNN NNNN, where C = country code, M = municipalcode, and N = localNumberDigits.
■There might be dashes or spaces between number clusters.
■There might be +or 00in front of the country code.
Imagine how you would write this program using the standard tools available to
you in C++. It would be necessary to write lengthy parsing routines for each pos-sible format. Example 13.3 shows the desired output of such a program.
EXAMPLE 13.3 src/regexp/testphone.txt
$> ./testphone
Enter a phone Number (or q to quit): 1112223333validated: (US/Canada) +1 111-222-3333Enter a phone Number (or q to quit): 20618676017validated: (Europe) +20 (0)61-86-76-017Enter a phone Number (or q to quit): 31206472582validated: (Europe) +31 (0)20-64-72-582Enter a phone Number (or q to quit): 16175551212validated: (US/Canada) +1 617-555-121213.2 REGULAR EXPRESSIONS
313
continuedezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 313
Enter a phone Number (or q to quit): +31 20 64 28 258
validated: (Europe) +31 (0)20-64-28-258Enter a phone Number (or q to quit): 1 (617) 222 3333validated: (US/Canada) +1 617-222-3333Enter a phone Number (or q to quit): 31 20 111 1111validated: (Europe) +31 (0)20-11-11-111Enter a phone Number (or q to quit): asdfUnknown formatEnter a phone Number (or q to quit): 111 2222 333Unknown formatEnter a phone Number (or q to quit): 111223Unknown formatEnter a phone Number (or q to quit): 1112222333validated: (US/Canada) +1 111-222-2333Enter a phone Number (or q to quit): q
$ >
A procedural C-style solution that shows how to use QRegExp is shown in
Example 13.4.
EXAMPLE 13.4 src/regexp/testphoneread.cpp
[ . . . . ]
QRegExp usformat("(\\+?1[- ]?)?\\(?(\\d{3})\\)?[\\s-]?(\\d{3})[\\s-]?(\\d{4}"); 
QRegExp nlformat
("(\\+|00)?[\\s\\-]?(31)[\\s\\-]?(\\d\\d)[\\s\\-]?(.*)$");  
QRegExp nlformat2
("(\\d\\d)(\\d\\d)(\\d{3}");
QRegExp filtercharacters
("[\\s-\\+\\(\\)\\-]");
QString stdinReadPhone() {
QString str;bool format=false;do {
cout << "Enter a phone Number (or q to quit): ";cout.flush();str = cin.readLine();if (str=="q")
return str;
if (usformat.exactMatch(str)) {
format = true;QString areacode = usformat.cap(2);QString exchange = usformat.cap(3);QString number = usformat.cap(4);str = QString("(US/Canada) +1 %1-%2-%3")
.arg(areacode).arg(exchange).arg(number);
}
[ . . . . ]654321CHAPTER 13: VALIDATION AND REGULAR EXPRESSIONS
314ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 314
if (format == false) {
cout << "Unknown format" << endl;
}
} while (format == false) ;return str;
}
int main() {
QString str;do {
str =  stdinReadPhone();if (str != "q")
cout << "validated: " << str << endl;
} while (str != "q");return 0;
}[ . . . . ]
All usformat numbers have country code 1, and have 3 + 3 + 4 = 10 digits.White spaces, dashes,
and parantheses between these digit groups are ignored, but they help to make the digitgroups recognizable.
Netherlands (country code 31) numbers have 2 + 2 + 7 = 11 digits.The last seven digits will be arranged as 2 + 2 + 3.These are characters we ignore in the last seven digits of NL numbers.
Ensures that the user-entered phone string complies with a regular expression and extractsthe proper components from it.
Keep asking until you get a valid number.
EXERCISES: REGULAR EXPRESSIONS: PHONE
NUMBER RECOGNITION
1.Rewrite the birthday reminder application from Section 3.6 so that it accepts
dates in any of the following formats:
■YYYY-MM-DD
■YYYY/MM/DD
■MM/DD (year defaults to this year)
■MMM DD YYYY (y ear optional, defaults to this year) (MMM = 3-letter abbre-
viation for month, ignores upper/lower case but does verify validity ofmonth abbreviation)
2.Many operating systems come with a reasonably good list of words that are
used by various programs to check spelling. On *nix systems the word list isgenerally named (at least indirectly) “words” . You can locate the file on your *nixsystem by typing the command
locate words | grep dict
Piping the output of this command through grep reduces the output to thoselines that contain the string “dict” .65432113.2 REGULAR EXPRESSIONS
315ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 315
Once you have located your system word list file, write a program that will
read lines from the file and, using a suitable regex, display all the words that dothe following:
a.Begin with a pair of repeated letters
b.End in “gory”
c.Have more than one pair of repeated letters
d.Are palindromes
e.Consist of letters arranged in strictly increasing alphabetic order (e.g., knot)
If you cannot find such a suitable word list on your system, you can use the file
canadian-english-small.gz , in our dist directory.1After you download it,
you must uncompress it with the command
gunzip canadian-english-small.gz
13.3 Regular Expression Validation
The classQRegExpValidator uses aQRegExp to validate an input string. In
Example 13.5, we defined a main window class that contains a QRegExpValidator
and some input widgets.
EXAMPLE 13.5 src/validate/regexval/rinputform.h
[ . . . . ]
class RinputForm : public QMainWindow {
Q_OBJECT
public:
RinputForm();void setupForm();
public slots:
void computeResult();
private:
QRegExpValidator* m_PhoneValid;QGridLayout* m_Layout;QLineEdit* m_PhoneEntry;QWidget* m_Center;QLabel* m_PhoneResult;QString m_Phone;static QRegExp sm_PhoneFormat; 
};
[ . . . . ]CHAPTER 13: VALIDATION AND REGULAR EXPRESSIONS
316
1http://oop.mcs.suffolk.edu/distezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 316
We borrowed the regex from Example 13.4 and used it to initialize the static
QRegExp . The program in Example 13.6 takes a phone number from the user and
displays it only if it is valid.
EXAMPLE 13.6 src/validate/regexval/rinputform.cpp13.3 REGULAR EXPRESSION VALIDATION
317
As we have seen, the QValidator classes provide a powerful mechanism for val-
idating input data. Qt has provided two numerical range validators and a regularexpression validator. If other types of data need to be validated, it is not difficultto produce other subclasses of
QValidator .[ . . . . ]
QRegExp RinputForm::sm_PhoneFormat(
"(\\+?1[- ]?)?\\(?(\\d{3,3})\\)?[\\s-]?(\\d{3,3})[\\s-]?(\\d{4,4})");
RinputForm::RinputForm() :
m_PhoneValid(new QRegExpValidator(sm_PhoneFormat, this)),[ . . . . ]
void RinputForm::setupForm() {
[ . . . . ]
m_PhoneEntry->setValidator(m_PhoneValid);
connect(m_PhoneEntry, SIGNAL(returnPressed()), 
this, SLOT(computeResult()));
}
void RinputForm::computeResult() {
m_Phone = m_PhoneEntry->text();if (sm_PhoneFormat.exactMatch(m_Phone)) {
QString areacode = sm_PhoneFormat.cap(2);QString exchange = sm_PhoneFormat.cap(3);QString number = sm_PhoneFormat.cap(4);
m_PhoneResult->setText(QString("(US/Canada) +1 %1-%2-%3")
.arg(areacode).arg(exchange).arg(number));
}
}
[ . . . . ]
The QRegExpValidator will not permit entry of any characters that would pro-
duce an invalid result. Here is a snapshot of the running program.
ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 317
EXERCISES: VALIDA TION AND REGULAR
EXPRESSIONS
1.Write a program that extracts the hyperlinks from HTML files using regular
expressions. Each hyperlink looks like this:
<a href="http://www.web.www/location/page.html">The Label</a>
For each hyperlink encountered in the input file, print just the URL and label,separated by a tab.
Keep in mind that optional whitespace can be found in different parts
of the above example pattern. Test your program on a variety of differentWeb pages and verify that your program does indeed catch all the links.
2.You just changed companies and you want to reuse some open-source code
that you wrote for the previous company. Now you need to rename all the datamembers in your source code. The previous company wanted data membersnamed like this:
mVarName , but your new company wants them named like
this:m_varName . Extend FileVisitor and perform a substitution in the text
of each visited file so that all data members conform to the new company’scoding standards.
3.Write a program that asks the user for a palindrome in a 
QLineEdit and has a
validator that enforces the rule that the letters (ignoring uppercase and lower-case and whitespace) do indeed have the same order in either direction.CHAPTER 13: VALIDATION AND REGULAR EXPRESSIONS
318ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 318
REVIEW QUESTIONS
319
REVIEW QUESTIONS 
1. What is a regular expression? What can you use it for?
2. What is a validator? What is it used for?3. What is a regular expression meta-character? There are four kinds of
metacharacters: quantifier, character set, group, and anchor. Give exam-ples of each type, and explain what they mean.ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 319
ezus_138004_ch13.qxd  8/4/06  10:02 AM  Page 320
32114.1 The Qt XML Module . . . . . . . . . . . . . . . . . 325
14.2 Event-Driven Parsing. . . . . . . . . . . . . . . . 32514.3 XML, Tree Structures, and DOM. . . . . . . 32914CHAPTER 14
Parsing XML
This chapter introduces two ways of parsing XMLdata, available from Qt’s XML module. We demon-strate event-driven parsing with SAX, the Simple APIfor XML, and tree-style parsing with DOM, theDocument Object Model.ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 321
XML is an acronym for eXtensible Markup Language. It is a markup language
similar to HTML (HyperT ext Markup Language), but with stricter syntax and nosemantics (i.e., no meanings associated with the tags).
XML’s stricter syntax is in strong contrast to HTML. For example:
■Each XML <tag> must have a closing </tag> , or be self-closing, like
this:<br/> .
■XML tags are case sensitive: <tag> is not the same as <Tag> .
■Characters such as > and < that are not actually part of a tag must bereplaced by passive equivalents such as 
&gt; and &lt; in an XML 
document to avoid confusing the parser.
Example 14.1 is an HTML document that does not conform to XML rules.
EXAMPLE 14.1 src/xml/html/testhtml.html
<html>
<head> <title> This is a title </title>
<!-- Unterminated <link> and <input> tags are quite commonplace
in HTML code:    -->
<link rel="Saved&nbsp; Searches" title="oopdocbook"
href="buglist.cgi?cmdtype=runnamed&amp;namedcmd=oopdocbook">
<link rel="Saved&nbsp;Searches" title="queryj"
href="buglist.cgi?cmdtype=runnamed&amp;namedcmd=queryj">
</head><body><p> This is a paragraph. What do you think of that? </p>
Html makes use of unterminated line-breaks: <br>
And those do not make XML parsers happy. <br>
<ul>
<li> HTML is not very strict.<li> An unclosed tag doesn't bother HTML parsers one bit.</ul>
</body>
</html>
ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 322
If we combined XML syntax with HTML element semantics, we would get a
language called XHTML. Example 14.2 shows Example 14.1 rewritten as XHTML.
EXAMPLE 14.2 src/xml/html/testxhtml.html
<!DOCTYPE xhtml >
<html><head><title> This is a title </title><!-- These links are now self-terminated: --><link rel="Saved&nbsp;Searches" title="oopdocbook"
href="buglist.cgi?cmdtype=runnamed" />
<link rel="Saved&nbsp;Searches" title="queryj"
href="buglist.cgi?namedcmd=queryj" />
</head><body>
<p> This is a paragraph. What do you think of that? </p><p>
Html self-terminating linebreaks are ok: <br/>They don’t confuse the XML parser. <br/></p>
<ul>
<li> This is proper list item </li><li> This is another list item </li></ul>
</body>
</html>
XML is a whole class of file formats that is understandable and editable by humans
as well as by programs. XML has become a popular format for storing andexchanging data from Web applications. It is also a natural language for represent-ing hierarchical (tree-like) information, which includes most documentation.
Many applications (e.g., Qt Designer, Umbrello, Dia) use an XML file format
for storing data. Qt Designer’s .ui files use XML to describe the layout of Qt widg-ets in a GUI. The book you are reading now is written in a flavor of XML calledSlacker’s DocBook.
1It’s like DocBook,2an XML language for writing books, but
it adds some shorthand tags from XHTML and custom tags for describingcourseware.CHAPTER 14: PARSING XML
323
1http://slackerdoc.tigris.org/
2http://www.docbook.orgezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 323
An XML document is comprised of nodes . Elements arenodes and look like
this:<tag> text or elements </tag> . An opening tag can contain attributes .A n
attribute has the form: name="value" . Elements nested inside one another form
a parent-child tree structure.
EXAMPLE 14.3 src/xml/sax1/samplefile.xml
<section id="xmlintro">
<title> Intro to XML </title><para> This is a paragraph </para><ul>
<li> This is an unordered list item. </li><li c="textbook"> This only shows up in the textbook </li>
</ul><p> Look at this example code below: </p><include src="xmlsamplecode.cpp" mode="cpp"/>
</section>
In Example 14.3, <ul> has two <li> children, and its parent is a <section> .
Elements with no children can be self-terminated with a />, i.e., <include/> .
Some elements such as <section> and <include> have attributes. Indenting
nested elements helps readability, but extra whitespace is ignored by most parsers.
How many direct children are there of the <section> ?
XML Editors
There are several open-source XML editors available. You are encouraged to
try them before you go with a commercial solution.
1. jEdit3has an XML plugin that works quite well. Be sure to use this option:
“insert closing tag when </ is typed” .
2. For KDE users, there is quanta.4Like kdevelop, this is based on Kate, the
KDE advanced text editor. If you are accustomed to using emacs keys, besure to get this Kate plugin: ktexteditor-emacsextensions.
5CHAPTER 14: PARSING XML
324
3http://www.jedit.org
4http://quanta.kdewebdev.org/
5http://www.kde-apps.org/content/show.php?content=21706ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 324
XMLLINT T h ef r e et o o l xmllint is very handy for checking an XML file
for errors.It reports very descriptive error messages (mismatched start/endtags, missing characters, etc.) and points out where the errors are. It can
also be used to indent/“pretty print”a well-formed XML document.
14.1 The Qt XML Module
Qt’s XML Module includes the following APIs of interest:
■A C++ version of the SAX2 parser6
■A C++ implementation of DOM, The Document Object Model7
SAX, which stands for Simple API for XML, is a low-level event-driven way of
parsing XML. SAX can run on an XML file of any size.
DOM is a higher-level interface for dealing with XML elements as objects in a
navigable tree structure. DOM loads the XML file into memory, so the maximumfile size your application can handle is limited by the amount of available RAM.
14.2 Event-Driven Parsing
Working with SAX-style XML parsers means doing event-driven programming.
The flow of execution depends entirely on the data that is being read from a file.This inversion of control means that the thread of execution will be more diffi-
cult to trace. Our code will be called by code inside the Qt library.
Invoking the parser involves creating a 
reader and a handler , hooking them
up, and calling parse() , as shown in Example 14.4.
EXAMPLE 14.4 src/xml/sax1/tagreader.cpp
#include "structureparser.h"
#include <QFile>#include <QXmlInputSource>#include <QXmlSimpleReader>#include <QDebug>14.2 EVENT-DRIVEN PARSING
325
6http://www.saxproject.org 
7http://www.w3c.org/DOM/continuedezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 325
int main( int argc, char **argv ) {
if ( argc < 2 ) {
qDebug() << QString("Usage: %1 <xmlfile>").arg(argv[0]);return 1;
}for ( int i=1; i < argc; ++i ) {
QFile xmlFile( argv[i] );QXmlInputSource source( &xmlFile );StructureParser handler;QXmlSimpleReader reader;reader.setContentHandler( &handler );reader.parse( source );
}return 0;
}
a custom derived instance of QXmlContentHandler
the generic parserHook up the objects together.
Start parsing.
The interface for parsing XML is described in the abstract base class
QXmlContentHandler . We call this a passive interface because these methods
get called, just not from our code. QXmlSimpleReader is provided, which reads an
XML file and generates parse events, calling methods on a content handler inresponse to them. Figure 14.1 shows the main classes involved.43214321CHAPTER 14: PARSING XML
326
FIGURE 14.1 Abstract and concrete SAX classesQXmlDefaultHandler
MyHandlerQXmlSimpleReaderQXmlReader QXmlContentHandler
+ startDocument()
+ endDocument()+ startElement()+ endElement()+ characters()+ parse()ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 326
FIGURE 14.2 Plug-in component architecture14.2 EVENT-DRIVEN PARSING
327
For the reader to provide any useful information, it needs an object to receive
parse events. This object, a parse event handler , must implement a published
interface, so it can “plug” into the parser, as shown in Figure 14.2.
QXMLReader
QXmlContentHandler
The handler derives (directly or indirectly) from QXmlContentHandler .T h e
virtual methods get called by the parser when it encounters various elements of
the XML file during parsing. This is event-driven programming: You do not call
these functions directly .
EXAMPLE 14.5 src/xml/sax1/structureparser.h
#include <QXmlDefaultHandler>
class QString;class MyHandler : public QXmlDefaultHandler {
public:
bool startDocument();bool startElement( const QString & namespaceURI,
const QString & localName,const QString & qName,const QXmlAttributes & atts);
bool characters(const QString& text);bool endElement( const QString & namespaceURI,
const QString & localName,const QString & qName );
private:
QString indent;
};
#endif
These passively called functions are often referred to as callbacks . They respond to
events generated by the parser. The client code of MyHandler is the
QXmlSimpleReader class, inside the Qt XML Module.ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 327
CONTENTHANDLER OR DEFAUL THANDLER?
QXmlContentHandler is an abstract class with many pure virtual
methods, all of which must be overridden by any concrete derived class.
Qt has provided a concrete class named QXmlDefaultHandler that
implements the base class pure virtual methods as empty do-nothing
bodies. You can think of this class as a concrete base class. Handlersderived from this class are not required to override all of the methods but
must override some in order to accomplish anything.
If we do not properly override each hand ler method that will be used by our app,
the corresponding QXmlDefaultHandler method, which does nothing, will be
called instead. In the body of a handler function, you can
■Store the parse results in a data structure
■Create objects according to certain rules
■Print or transform the data in a different format
■Do other useful things
See Example 14.6.
EXAMPLE 14.6 src/xml/sax1/myhandler.cpp
[ . . . . ]
QTextStream cout(stdout, QIODevice::WriteOnly);
bool MyHandler::startDocument() {
indent = "";return TRUE;
}
bool MyHandler::characters(const QString& text) {
QString t = text;cout << t.remove('\n');return TRUE;
}
bool MyHandler::startElement( const QString&,
const QString&,const QString& qName,const QXmlAttributes& atts) {
QString str = QString("\n%1\\%2").arg(indent).arg(qName);cout << str;if (atts.length()>0) {
QString fieldName = atts.qName(0);QString fieldValue = atts.value(0);cout << QString("(%2=%3)").arg(fieldName).arg(fieldValue);CHAPTER 14: PARSING XML
328ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 328
}
cout << "{";indent += "    ";return TRUE;
}
bool MyHandler::endElement( const QString&,
const QString& ,const QString& ) {
indent.remove( 0, 4 );cout << "}";return TRUE;
}
[ . . . . ]
The QXmlAttributes object passed into the startElement() function is a
map, used to hold the name = value attribute pairs that were contained in the XML
elements.
As it processes the file, the parse() function calls characters() ,
startElement() , and endElement() as these “events” are encountered in the
file. In particular, each time a string of ordinary characters (between the beginningand end of a tag) is encountered, it’s passed as an array of bytes to the
characters() function.
We ran the previous program on Example 14.3 and it transformed that docu-
ment into Example 14.7, something that looks a little like LaT eX, another documentformat.
EXAMPLE 14.7 src/xml/sax1/tagreader-output.txt
\section(id=xmlintro){
\title{ Intro to XML }\para{ This is a paragraph }\ul{
\li{ This is an unordered list item. }\li(c=textbook){ This only shows up in the textbook }   }
\p{ Look at this example code below: }
\include(src=xmlsamplecode.cpp){}}
14.3 XML, Tree Structures, and DOM
The Document Object Model (DOM) is a highe r-level interface for operating on
XML documents. Working with and navigating through DOM documents is verystraightforward (especially if you are familiar with 
QObject children).14.3 XML, TREE STRUCTURES, AND DOM
329ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 329
SAX OR DOM? DOM requires the entire document to be loaded into
memory, so it should not be used on large files. SAX, in contrast, can writeor dispose of processed data while parsing and processing more data in
a very large document.CHAPTER 14: PARSING XML
330
FIGURE 14.3 QDom UML model
The main classes in DOM are shown in Figure 14.3. setContent() parses the
file, after which the QDomDocument contains a structured tree comprised of
QDomNode objects. Each QDomNode could be an instance of QDomElement ,
QDomAttr ,o r  QDomText .E v e r y  QDomNode has a parent except the root, which is
a QDomDocument . Every node is reachable from the parent. DOM is another
application of the Composite pattern.QDomNodeListPrivateUnpublished Classes
children0..1
+ impl
0..1
+ implQDomNodePrivate
QDomDocument
QDomT extQDomElementQDomNodeList
 - impl : QDomNodeListPrivate*
QDomNode
# impl : QDomNodePrivate*
QDomElementezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 330
The QDom classes are wrappers around private implementation classes.
They contain no data except a pointer. This makes it possible to passaround 
QDomNode by value to other functions that can change the
addressed objects (by adding attributes or children or by changing
attributes). This gives QDom a more Java-like interface.
14.3.1 Visitor Pattern: DOM Tree Walking
Qt 4 provides full read/write access to trees of XML data. Nodes can be navigated
through an interface which is similar to but slightly different from the QObject
interface. Under the surface, SAX performs the parsing, and DOM defines a
ContentHandler that creates the tree of objects in memory. All client code needsto do is call 
setContent() , and this causes the input to be parsed and the tree to
be generated.
Example 14.8 transforms an XML document in place. After the tree is manip-
ulated, it is serialized to a QTextStream where it will become savable/parsable
again.
EXAMPLE 14.8 src/xml/domwalker/main.cpp
[ . . . . ]
int main(int argc, char **argv) {
QApplication app(argc, argv);QString filename;if (argc < 2) {
cout << "Usage: " << argv[0] << " filename.xml" << endl;filename = "samplefile.xml";
}else {
filename = argv[1];
}QFile f(filename);QString errorMsg;int errorLine, errorColumn;QDomDocument doc("SlackerDoc");bool result = doc.setContent(&f, &errorMsg,
&errorLine, &errorColumn);
QDomNode before = doc.cloneNode(true);Slacker slack(doc);QDomNode after = slack.transform();cout << QString("Before: ") << before << endl;cout << QString("After: ") << after << endl;
432114.3 XML, TREE STRUCTURES, AND DOM
331
continuedezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 331
FIGURE 14.4 Domwalker and SlackerCHAPTER 14: PARSING XML
332
QWidget * view = twinview(before, after);
view->show();app.exec();delete view;
}
[ . . . . ]
Parse the file into a DOM tree, and store tree in empty doc.
deep copySend the tree to Slacker.Start the visitation.
a pair of QTreeView objects separated by slider, using the QDomDocuments as models
The Slacker class is derived from DomWalker , another application of the Visitor
pattern, specialized for walking through DOM trees.
Figure 14.4 shows the main classes used in this example.543215
DomWalker
# m_Doc : QDomDocument
# DomWalker(doc : QDomDocument)
+ ~ DomWalker()+ visit(current : QDomElement) : QDomElement+ transform() : QDomDocument# walkTree(current : QDomNode) : QDomNode# createElement(name : QString) : QDomElement
Slacker
+ Slacker(doc : QDomDocument)+ visit(current : QDomElement) : QDomElementQDomDocument
+ m_Doc
EXAMPLE 14.9 src/xml/domwalker/domwalker.cpp
[ . . . . ]
QDomDocument DomWalker::transform() {
walkTree(m_Doc);return m_Doc;
}
QDomNode DomWalker::walkTree(QDomNode current) {
QDomNodeList dnl = current.childNodes();for (int i=dnl.count()-1; i >=0; --i)
walkTree(dnl.item(i));1ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 332
if (current.nodeType() == QDomNode::ElementNode) {
QDomElement ce = current.toElement();return visit(ce);
}return current;
}[ . . . . ]
First process the children recursively.
We only want to process elements, leaving all nodes unchanged.
instead of a typecast
Notice that the walkTree() method, defined in Example 14.9, contains no
pointers or typecasts. The QDom(Node|Element|Document|Attribute )
types are smart-pointers. We “downcast” from QDomNode to QDomElement ,o r
QDomXXX, using QDomNode::toElement() or toXXX() conversion functions.
When traversing a tree, it is possible to use only the QDomNode interface,
but when operating on an actual XML element, “casting” down to
QDomElement adds some convenient functions for dealing with the
Element as a whole, as well as its attributes (which are themselves
QDomNode child objects).
Even though in this example QDomNode/QDomElement objects are being passed
and returned by value, it is still possible to change the underlying DOM objectsthrough the temporary copies. Through inter face trickery, QDom objects look and
feel like Java-style references, and hold pointers inside, rather than actual data.
Slacker defines how to transform documents from one XML format to
another. It is an extension of DomWalker and overrides just one method, visit() .
Defined in Example 14.10, this method has a special rule for each kind of element.
EXAMPLE 14.10 src/xml/domwalker/slacker.cpp
[ . . . . ]
QDomElement Slacker::visit(QDomElement element) {
QString name = element.tagName();[ . . . . ]
/* Mapping elements: */
if (name == "p") {
element.setTagName("para");return element;
}3213214.3 XML, TREE STRUCTURES, AND DOM
333
continuedezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 333
if (name == "ul") {
element.setTagName("unorderedlist");return element;
}if (name == "b") {
element.setAttribute("role", "strong");element.setTagName("emphasis");return element;
}/* This transformation is more interesting because we
replace <li> text </li> with<listitem><para> text </para></listitem>
*/if (name == "li") {
QDomNode parent = element.parentNode();QDomElement listitem = createElement("listitem");parent.replaceChild(listitem, element); /*
remove the li tag, but put a listitem in its place */
element.setTagName("para");listitem.appendChild(element);return listitem;
}[ . . . . ]
Recall element is the original <li>text</li> node.
When we run this example, it pops up a tree view of the before/after XML docu-
ments side by side, so we can inspect them, as the next screenshot shows.11CHAPTER 14: PARSING XML
334
ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 334
14.3.2 Generation of XML with DOM
DOM documents are normally created by parsers to represent XML from an input
stream, but DOM can also be used to generate XML structures as output. It ispreferable to generate XML through an API rather than by printing formattedstrings because DOM generation guarantees that the resulting document will beparsable again.
In Figure 14.5,
DocbookDoc is a factory for QDomElement s. It is derived
from QDomDocument , and specialized for creating Docbook/XML documents.14.3 XML, TREE STRUCTURES, AND DOM
335
FIGURE 14.5 DocbookDocQDomDocument
DocbookDoc
+ currentParent : Element
+ currentChapter : Element
+ DocbookDoc(title : QString)
+ title(title : QString, parent : Element) : Element+ chapter(title : QString) : Element+ section(title : QString) : Element+ bold(boldT ext : QString) : Element+ formalpara(title : QString, text : QString) : Element+ para(text : QString) : Element+ setRole(el : Element, role : QString)
ZenFlesh
+ ZenFlesh()
In the header file for this class, excerpted in Example 14.11, we added a typedef
to improve readability. In the DOM standard, all DOM classes are simply called
Node ,Element ,Document , and Attribute .
EXAMPLE 14.11 src/libs/docbook/docbookdoc.h
typedef QDomElement Element;
Saves on typing and is consistent with Java DOM.
We can build documents by creating chapters, sections, and paragraphs, as we see
in Example 14.12.11ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 335
EXAMPLE 14.12 src/xml/xmlbuilder/zenflesh.cpp
#include <qstd.h>
using namespace qstd;#include "../docbook.h"
class ZenFlesh : public DocbookDoc {
public: ZenFlesh();
};
ZenFlesh::ZenFlesh() :
DocbookDoc("Zen Flesh, Zen Bones") {
chapter("101 Zen Stories");
section("A cup of tea");para("Nan-in served a cup of tea.");section("Great Waves");QDomElement p = para("o-nami the wrestler sat in meditation"
"and tried to imagine himself as a bunch of great waves.");
setRole(p, "remark");chapter("The Gateless Gate");formalpara("The Gateless Gate",
"In order to enter the gateless gate, you must have a ");
bold(" mindless mind.");
section("Joshu’s dog");
para("Has a dog buddha nature or not?");
section("Haykujo’s Fox");
QDomElement fp = formalpara("This is a special topic",
"Which should have a role= remark attribute");
setRole(fp, "remark");
}
int main() {
ZenFlesh book;cout << book << endl;
}
The constructor generates a little book in XML, which after pretty-printing, could
look like Example 14.13.
EXAMPLE 14.13 src/xml/zen.xml
<book>
<title>Zen Flesh, Zen Bones</title><chapter>
<title>101 Zen Stories</title><section>
<title>A cup of tea</title>CHAPTER 14: PARSING XML
336ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 336
<para>Nan-in served a cup of tea.</para>
</section><section>
<title>Great Waves</title><para>o-nami the wrestler sat in meditation and triedto imagine himself as a bunch of great waves.</para>
</section>
</chapter><chapter>
<title>The Gateless Gate</title><formalpara>
<title>The Gateless Gate</title>In order to enter the gateless gate,you must have a <emphasis role="strong">mindless mind</emphasis>
</formalpara><section>
<title>Joshu’s dog</title><para>Has a dog buddha nature or not?</para>
</section><section>
<title>Haykujo’s Fox</title><formalpara role="remark">
<title>This is a special topic</title>Which should have a role="remark" attribute
</formalpara>
</section>
</chapter>
</book>
The advantage of this format is that it can be easily converted into HTML (or PDF,
or LaT eX) using xsltproc and the Docbook/XSL stylesheets [ docbookxsl ].
Example 14.14 shows the invocation for generating an HTML version.
EXAMPLE 14.14 src/xml/zen2html
#!/bin/sh
# translates zen.xml into index.html# requires gnu xsltproc and docbook-xsl
xsltproc ../../../docbook-xsl/html/onechunk.xsl zen.xml
Now let’s look at Example 14.15, where the elements are created. Each major
Docbook language element has a corresponding factory method in DocbookDoc .14.3 XML, TREE STRUCTURES, AND DOM
337ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 337
EXAMPLE 14.15 src/libs/docbook/docbookdoc.cpp
[ . . . . ]
DocbookDoc::DocbookDoc(QString titleString) {
Element root = createElement("book");appendChild(root);title(titleString, root);currentParent = root;
}
Element DocbookDoc::bridgehead(QString titleStr) {
Element retval = createElement("bridgehead");Element titleEl = title(titleStr);currentParent.appendChild(retval);return retval;
}
Element DocbookDoc::title(QString name, Element parent) {
Element retval = createElement("title");QDomText tn = createTextNode(name);retval.appendChild(tn);if (parent != Element())
parent.appendChild(retval);
return retval;
}
Element DocbookDoc::chapter(QString titleString) {
Element chapter = createElement("chapter");title(titleString, chapter);documentElement().appendChild(chapter);currentParent = chapter;currentChapter = chapter;return chapter;
}
Element DocbookDoc::para(QString textstr) {
QDomText tn = createTextNode(textstr);Element para = createElement("para");para.appendChild(tn);currentParent.appendChild(para);currentPara = para;return para;
}
In addition, we have some character-level elements that only modify text, shown
in Example 14.16.CHAPTER 14: PARSING XML
338ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 338
EXAMPLE 14.16 src/libs/docbook/docbookdoc.cpp
[ . . . . ]
Element DocbookDoc::bold(QString text) {
QDomText tn = createTextNode(text);Element emphasis = createElement("emphasis");setRole(emphasis, "strong");emphasis.appendChild(tn);currentPara.appendChild(emphasis);return emphasis;
}
void  DocbookDoc::setRole(Element el, QString role) {
el.setAttribute("role", role);
}
Because each QDomNode must be created by QDomDocument , it makes sense to
extend QDomDocument to write our own DOM factory.
DocbookDoc adds its newly created Elements as children to previously created
Elements, depending on what kind of Element is being created.
EXERCISE: XML, TREE STRUCTURES,
AND DOM
Rewrite the Slacker transformer tree-walker so that instead of modifying a DOM
tree in place, it creates a new DOM tree using an Element factory derived from a
QDomDocument . You can use the DocbookDoc class as a starting point.14.3 XML, TREE STRUCTURES, AND DOM
339ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 339
CHAPTER 14: PARSING XML
340
REVIEW QUESTIONS
1. If there is a syntax error in your XML file, how do you determine the
cause and location?
2. SAX is an event-driven parser. What kinds of events does it respond to?3. Qt (as well as other language frameworks) offers two XML parser APIs,
one is SAX and the other is DOM. Compare and contrast them. Whywould you use one rather than the other?
4. If you have a 
QDomNode and it is actually “pointing” to a QDomElement ,
how do you get a reference to the QDomElement ?
5. Explain how DomWalker is an application of the Visitor pattern.
ezus_138004_ch14.qxd  8/4/06  10:03 AM  Page 340
34115.1 Anti-patterns . . . . . . . . . . . . . . . . . . . . . . . 342
15.2 QMetaObject: The MetaObject 
Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
15.3 Type Identification 
and qobject_cast . . . . . . . . . . . . . . . . . . . 345
15.4 Q_PROPERTY Macro: Describing 
QObject Properties . . . . . . . . . . . . . . . . . 347
15.5 QVariant Class: Accessing 
Properties . . . . . . . . . . . . . . . . . . . . . . . . . 350
15.6 DataObject: An Extension 
of QObject . . . . . . . . . . . . . . . . . . . . . . . . . 353
15.7 Property Containers: PropsMap . . . . . . 35515CHAPTER 15
Meta Objects, Properties,
and Reflective Programming
In this chapter we introduce the idea of reflection,
the self-examination of an object’s members. Usingreflective programming, it becomes possible to writegeneral-purpose operations that work on classes ofvaried structures. Using QVariant , a generic value-
holder, we can operate on built-in types as well asother common types in a uniform way.ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 341
15.1 Anti-patterns
Anti-pattern1is a term first coined by [Gamma95] to mean a common design
pitfall. An anti-pattern is called this because many design patterns are designed toavoid such pitfalls.
In other words, design patterns are commonly used solutions to anti-patterns,
which are commonly faced problems. Some examples of anti-patterns are:
■Copy and paste programming: Copying and modifying existing codewithout creating more generic solutions.
■Hard coding: Embedding assumptions about the environment (such asconstant numbers) in multiple parts of the software
■Interface bloat: Having too many methods, or too many arguments infunctions; in general, refers to a complicated interface that is hard toreuse or implement
■Reinventing the (square) wheel: Implementing some code when some-thing (better) already exists in the available APIs
■God Object: An object that has too much information or too muchresponsibility. This can be the result of having too many functions in asingle class. It can arise from many situations, but often happens whencode for a model and view are combined in the same class.
In Figure 15.1,
customer includes member functions for importing and export-
ing its individual data members in XML format. getWidget() provides a special
GUI widget that the user can use to enter data from a graphical application. Inaddition, there are custom methods for input/output via 
iostream .
This class is a model, because it holds onto data and represents some abstract
entity. However, this class also contains view code, because of the createWidget()
method. In addition, it contains serialization code specific to the data type. That is
1http://en.wikipedia.org/wiki/Anti-patternezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 342
too much responsibility for a data model. It is quickly becoming an example of the
God Object anti-pattern.
As we add other data model classes ( Address ,ShoppingCart ,Catalog ,
CatalogItem , etc.), each of them also would need these methods:
■createWidget()
■importXML()
■exportXML()
■operator<<()
■operator>>()
This could lead to the use of copy-and-paste programming, another anti-pattern.
If we ever change the data structure, corresponding changes would need to be
made to all presentation and I/O methods. Bugs introduced when maintainingthis code are very likely.
If
Customer were reflective , meaning that it had the ability to determine use-
ful things about its own members (e.g.: How many properties? What are theirnames? What are their types? How do I load/store them? What are the childobjects?), then we could define a generic way to read and write objects that wouldwork for 
Customer and any other similarly reflective class.15.1 ANTI-PATTERNS
343
FIGURE 15.1 Anti-patternCustomer
  - name : QString
 - address : QString - city : QString - birthdate : QDate
+ setName(newName : QString)
+ setAddress(newAddress : QString)+ setCity(newCity : QString)+ setBirthdate(newDate : const QDate&)+ getName() : QString+ getAddress() : QString+ getCity() : QString+ getBirthdate() : QDate+ exportXML(os : ostream&)+ importXML(is : istream&)+ createWidget() : QWidget*+ getWidget() : QWidget*
operator<<(ostream& out, const Customer& cust) : ostream&operator>>(istream& in, Customer& cust): istream&ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 343
15.2 QMetaObject: The MetaObject Pattern
By abstracting the abstract data type itself, we achieve what is called a MetaObject .
A MetaObject is an object that describes the structure of another object.2
The MetaObject Pattern
The QMetaObject is Qt’s implementation of the MetaObject pattern. It
provides information about properties and methods of a QObject. TheMetaObject pattern is sometimes known as the Reflection pattern.
A class that has a MetaObject supports reflection . This is a feature found in many
object-oriented languages. It does not exist in C++, but Qt’s MetaObject compiler(
moc) generates the code to support this for desired classes.
As long as certain conditions apply,3each class derived from QObject will
have a QMetaObject generated for it by moc, as shown in Figure 15.2. QObject
has a member function that returns a pointer to the object’s QMetaObject .
QMetaObject* QObject::metaObject () const [virtual]
A QMetaObject can be used to invoke functions such as:
■className() , which returns the class name as a constchar*
■superClass() , which returns a pointer to the QMetaObject of the
base class if there is one (or 0if there is not)
■methodCount() , which returns the number of member functions of
the class
■Several other useful functions that we will discuss in this chapter
The signal and slot mechanism also relies on the QMetaObject .
By using the QMetaObject and QMetaProperty , it is possible to write code
that is generic enough to handle all self-describing classes.CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
344
2Meta , the latin root meaning about , is used for its literal definition here.
3Each class must be defined in a header file, listed in the project file’s HEADERS , and must include the
Q_OBJECT macro in its class definition.ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 344
15.3 TYPE IDENTIFICATION AND QOBJECT_CAST
345
FIGURE 15.2 MetaObjectsCustomer
+mCustomerId: int
+mBalance: double
QMetaPropertyAddress
+mStreet: QString+mCity: QString+mState: QString+mZip: QStringQObject
+metaObject(): QMetaObject*+property(name:char*): QVariant+setProperty(name:QString,value:QVariant): bool
QMetaObject
+findProperty(name): QMetaProperty
Customer metaobj
mCustomerid-metaProp
mBalance-metaPropAddress metaobj
mStreet-metaProp
mCity-MetaProp
mState-Metapropmoc_customer.cpp
moc_address.cpp
15.3 Type Identification and qobject_cast
RTTI ,o r  Run-Time Type Identification , as its name suggests, is a system for
determining at runtime the actual type of an object, to which we may only have abase class pointer.
In addition to C++’s RTTI operators,
dynamic_cast and typeid (Sec-
tion 19.8), Qt provides two mechanisms for run-time type identification.
1.qobject_cast
2.QObject::inherits()ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 345
qobject_cast is an ANSI-style typecast operator (Section 19.7). ANSI typecasts
look a lot like template functions:
DestType * qobject_cast< DestType *> ( QObject * qoptr )
A typecast operator converts an expression from one type to another, following
certain rules and restrictions imposed by the types and the language. Like othercast operators,
qobject_cast takes the destination type as a template parame-
ter. It returns a different-typed pointer to the same object. If at runtime the actualpointer type cannot be converted to 
DestType *,then the conversion fails and the
value returned is NULL .
As the signature suggests, qobject_cast is type-restricted to arguments of
type DestType *, where DestType is derived from QObject and the class was fully
processed by moc. Therefore, qobject_cast is actually a downcast operator,
similar to dynamic_cast .
In situations where you have base class pointers to derived class objects, down-
casting makes it possible to call derived class methods that do not exist in the baseclass interface. In Example 15.1, we take advantage of the fact that 
QApplication ,
and MyApplication , both derive from QObject .
EXAMPLE 15.1 src/qtrtti/myapp-classdef.cpp
class MyApplication : public QApplication {
Q_OBJECT   /* Required for Qt RTTI */public:
static MyApplication* instance();QString imagesURL() const;[... other members ...]
};
MyApplication* MyApplication::instance() {
static MyApplication* inst = 0;if (inst == 0) {
inst = qobject_cast<MyApplication*>(qApp);
}return inst;
}
Because qApp always points to the currently running QApplication , this func-
tion will return non-zero only if a MyApplication is the current running appli-
cation. The downcast operation, which some say is expensive, happens only once ,t o
ensure a properly typed MyApplication pointer. Future calls to instance()
will return the previously cast pointer, avoiding repeated calls to expensive run-time checking operations. Now it becomes possible to obtain the properly typed
MyApplication instance from other locations in the code:CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
346ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 346
.
QString imagePath(QString filename) {
MyApplication* app = MyApplication::instance();QString path = app->imagesURL() + "/" + filename;  return path;
}
The same file separator char works on alloperating systems that support Qt!
The implementation of qobject_cast makes no use of C++ RTTI. The
code for this operator is generated by the MetaObject Compiler (moc) .
QObject also offers a Java-style typechecking function, inherits() . Unlike
qobject_cast ,inherits() accepts a char* type name instead of a type
expression. This operation is slower than qobject_cast because it requires an
extra hashtable lookup, but it can be useful if you need input-driven type checking.
Example 15.2 shows some client code that uses inherits() .
EXAMPLE 15.2 src/qtrtti/qtrtti.cpp
[ . . . . ]
//  QWidget* w = &s;
if (w->inherits("QAbstractSlider"))  cout << "Yes, it is ";
else cout << "No, it is not";cout << "a QAbstractSlider" << endl;
if (w->inherits("QListView")) cout << "Yes, it is ";
else  cout << "No, it is not ";cout << "a QListView" << endl;
return 0;
}
pointer to some widget
15.4 Q_PROPERTY Macro: Describing 
QObject Properties
The property facility gives us a choice of ways to access data members:
■Directly, through the classic getters/setters (faster, more efficient)
■Indirectly, through the QObject/QMetaObject interface (more generic)111115.4 Q_PROPERTY MACRO: DESCRIBING QOBJECT PROPERTIES
347ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 347
EXAMPLE 15.3 src/properties/customer-props.h 
[ . . . . ]
class CustProps : public QObject {
Q_OBJECT
/* Each property declaration has the following syntax:Q_PROPERTY( type name READ getFunction [WRITE setFunction]
[RESET resetFunction] [DESIGNABLE bool][SCRIPTABLE bool] [STORED bool] )*/
Q_PROPERTY( QString Id READ getId WRITE setId );
Q_PROPERTY( QString Name READ getName WRITE setName );Q_PROPERTY( QString Address READ getAddress WRITE setAddress );Q_PROPERTY( QString Phone READ getPhone WRITE setPhone);Q_PROPERTY( QDate DateEstablished
READ getDateEstablishedWRITE setDateEstablished );
Q_PROPERTY( CustPropsType Type READ getType WRITE setType );Q_ENUMS( CustPropsType ) ;
public:
enum CustPropsType{ Corporate, Individual, Educational, Government };
CustProps(QObject *parent = 0, const QString name = QString());QString getId() const {
return m_Id;
}
[ . . . . ]CustPropsType getType() const {
return m_Type;
}
QString getTypeString() const;
void setId(const QString &newId);
[ . . . . ]// Overloaded, so we can set the type 2 different ways:
void setType(CustPropsType newType);void setType(QString newType);
private:
QString m_Id, m_Name, m_Address, m_Phone;QDate m_Date;CustPropsType m_Type;
};[ . . . . ]
macro required for moc to preprocess class
special macro to generate string-to-enum conversion functions
The enum type definition must be in the same class definition as the Q_ENUMS macro.321321CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
348ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 348
In Example 15.3, we have a customer class with a Qt property defined for each data
member. The name of a property must not be the same as any data member name.We have adopted the common practice of giving each property that correspondsto a data member a name that is based on the corresponding data member name.If the data member is 
m_DataItem , the corresponding property is named
DataItem . We discuss an example of a class that has properties that do not cor-
respond to data members in Section 16.3.3.
Notice the enum CustPropsType that is defined in the public section of
the class CustProps . Just above that definition, the Q_ENUMS macro tells moc
to generate some functions for this property in the QMetaProperty to aid in
string conversions for enum values.
The setters and getters are defined in Example 15.4. They are implemented in
the usual way.
EXAMPLE 15.4 src/properties/customer-props.cpp 
[ . . . . ]
CustProps::CustProps(QObject *parent, const QString name)
:QObject(parent) {setObjectName(name);
}
void CustProps::setId(const QString &newId) {
m_Id=newId;
}[ . . . . ]void CustProps::setType(CustPropsType theType) {
m_Type=theType;
}
/* Method for setting enum values from Strings. */
void CustProps::setType(QString newType) {
static const QMetaObject* meta = metaObject();
static int propindex = meta->indexOfProperty("Type");static const QMetaProperty mp = meta->property(propindex);
QMetaEnum menum = mp.enumerator();
const char* ntyp = newType.toAscii().data();m_Type = static_cast<CustPropsType>(menum.keyToValue(ntyp));
}
QString CustProps::getTypeString() const {
return property("Type").toString();
}[ . . . . ]
Overloaded version that accepts a string as an argument. Sets value to /H110021 if unknown.
Because they are static locals, the initializations happen only once.
This code gets executed each time.32132115.4 Q_PROPERTY MACRO: DESCRIBING QOBJECT PROPERTIES
349ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 349
The implementation of the overloaded function setType(QString) takes
advantage of QMetaProperty ’s Q_ENUM macro to convert the QString to the
proper enumerated value. T o obtain the correct QMetaProperty object for an
enum, we first get the QMetaObject and call functions indexOfProperty()
and property() to find it. QMetaProperty has a function called
enumerator() that you can use to convert strings to enums. If the given
QString argument does not match one of the enumerators, the keyToValue()
function will return the value /H110021.
Static Local Variables
Observe that we have declared the three local (block scope) variables, meta ,
propindex , and mp, to be static .
Each call to this function will require the same QMetaProperty object,
so there is no need to have repeated calls to the QMetaObject functions
require the iteration each time. static local variables are initialized only
once, which is our intention—repeated calls to this function will use thesame 
QMetaProperty object to do the conversion. Using static local
variables this way in a function can greatly improve the run-time perform-ance for that function.
4
15.5 QVariant Class: Accessing Properties
One frequently encountered problem C++ developers have as they try to make
things more object oriented, arises from the fact that primitive types of C++ (e.g.,
int,float ,char* , etc.) do not derive from a common base class. They’re called
primitive because they’re smaller, simpler, and used to compose more complex
things.
We would like to be able to retrieve the value of any property through the fol-
lowing function:
[returntype] QObject::property(QString propertyName);
T emplates are one way to address this issue—template functions cause code to begenerated for each used type. In Qt, we have another object-oriented way to solvethe problem: through the use of
QVariant .CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
350
4This depends on how expensive creating the obje cts are and how often the function is called.ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 350
QVariant is a union wrapper5for all the basic types, as well as all permitted
Q_PROPERTY types. Y ou can create a QVariant as a wrapper around another
typed value. It remembers its type, and has member functions for getting and set-
ting its value.
QVariant has a rich interface for data conversion and validity checking. In
particular, there is a toString() function that returns a QString representation
for its different types. This class gr eatly simplifies the property interface.
Example 15.5 shows some client code for the CustProps class defined in
Example 15.3.
EXAMPLE 15.5 src/properties/testcustomerprops.cpp 
[ . . . . ]
int main() {
CustProps cust;cust.setName("Falafal Pita");cust.setAddress("41 Temple Street; Boston, MA; 02114");cust.setPhone("617-555-1212");cust.setType("Government");ASSERT_EQUALS(cust.getType(), CustProps::Government);QString originalid = "834";cust.setId(originalid);QVariant v = cust.property("Id");QString str = v.toString();ASSERT_EQUALS(originalid, str);QDate date(2003, 7, 15);cust.setProperty("DateEstablished", QVariant(date));QDate anotherDate = cust.getDateEstablished();ASSERT_EQUALS(date, anotherDate);cust.setId(QString("anotherId"));qDebug() << objToString(&cust);cust.setType(CustProps::Educational);qDebug() << " Educational=" << cust.getType();cust.setType("BogusType");qDebug() << " Bogus= " << cust.getType();return 0;
}
765432115.5 QVARIANT CLASS: ACCESSING PROPERTIES
351
5A union is astruct that declares several data members that are all allocated at the same address.
This means that the union will occupy only enough memory to accommodate the largest of the
declared data members. When instantiated, a union can only store a value for one of the declared
members.continuedezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 351
setting some simple properties
setting enum property as a stringcomparing to enum valuesetting a string propertygetting it back as a QVariant through the QObject base class methodsetting date properties, wrapped in QVariants
The date comes back through the type-specific getter.
In Example 15.6, we show a reflective objToString() method that works on any
class with Qt properties defined. It works by iterating through each property()
value, in a way that is comparable to the java.lang.reflect interface.
EXAMPLE 15.6 src/properties/testcustomerprops.cpp 
[ . . . . ]
QString objToString(const QObject* obj) {
QStringList result;const QMetaObject *meta = obj->metaObject();result += QString("class %1 : public %2 {")
.arg(meta->className())
.arg(meta->superClass()->className());
for (int i=0; i < meta->propertyCount(); ++i) {
const QMetaProperty qmp = meta->property(i);result += QString("  %1 %2 = %3;")
.arg(qmp.type()).arg(qmp.name()).arg(obj->property(qmp.name()).toString());
}result += "};";return result.join("\n");
}
We introspect into the object via the QMetaObject.
The program outputs an object’s state in a C++-style format:
src/properties> ./properties
class CustProps : public QObject {
10 objectName = ;10 Id = anotherId;10 Name = Falafal Pita;10 Address = 41 Temple Street; Boston, MA; 02114;10 Phone = 617-555-1212;14 DateEstablished = 2003-07-15;2 Type = 3;
};
Educational= 2Bogus=  -1117654321CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
352ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 352
15.6 DATAOBJECT: AN EXTENSION OF QOBJECT
353
FIGURE 15.3 DataObject15.6 DataObject: An Extension of QObject
We have developed an extension to QObject named DataObject that we can
use as a base class for other data types that require any of the following features:
■A virtual interface for obtaining properties, MetaProperties, and
metaClass information
■Convenience functions for copying and comparing property values ofDataObjects
■A toString() function that returns a presentation of all the properties
of the object in XML format
This improved interface makes DataObject a Façade for QObject .
DataObject , shown in Figure 15.3, is used in several forthcoming examples
to demonstrate various design patterns.
QObject
DataObject
+ DataObject(name : QString)
+ readFrom(source : const QObject&) : bool+ write T o(de st : QObject&) : bool+ equals(other : const QObject&, compare Children : bool) : bool+ operator ==(other : const DataObject&) : bool+ className() : QString+ propertyNames() : QStringList+ numProperties() : uint+ toString(indentlevel : int) : QString+ property(name : constchar*) : QVariant+ clone() : DataObject*+ setProperty(propName : const char*, qv : const QVariant&) : bool
PropsMap
DataObject is Qt-property aware and takes advantage of this interface for read-
ing and writing properties of arbitrary QObject s, as shown in Example 15.7.ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 353
EXAMPLE 15.7 src/libs/dataobjects/dataobject.cpp 
[ . . . . ]
bool DataObject::readFrom(const QObject& source) {
bool retval = true;const QMetaObject* meta = source.metaObject();int count = meta->propertyCount();for (int i=0; I<count; ++i) {
QMetaProperty metap = meta->property(i);const char* pname = metap.name();if (metap.isWritable()) {
retval = setProperty(pname, source.property(pname))
&& retval;
}
}return retval;
}
[ . . . . ]bool DataObject::writeTo(QObject& dest) const {
bool result = true;foreach (QString propname, propertyNames()) {
if (metaProperty(propname).isWritable()) {
QVariant val = property(propname);result = dest.setProperty(propname.toAscii(), val) 
&& result;
}
}return result;
}
EXERCISES: META OBJECTS, PROPERTIES,
AND REFLECTIVE PROGRAMMING
1.Many people have several pets, each of which require periodic maintenance
(visits to the veterinarian, immunizations, vitamins, grooming, etc.).
■Derive a class named Pet from DataObject . Supply this class with appro-
priate attributes that can uniquely describe the pet (type, breed, name, ID,birthday, etc.). For each attribute, you will need a getter and a setter so that
you can set up a 
Q_PROPERTY .
■Derive another class from DataObject that you can call Maintenance (if
you can’t think of a better name). This class should have attributes thatuniquely describe a particular maintenance event (type of event, date, cost,etc.).
Maintenance objects will be stored as children of Pet objects.
■Derive a PetList class from DataObject .Pet objects will be children of
PetList .CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
354ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 354
■Serialization is facilitated by the DataObject::toString() function.
Find out how to use this for your PetWriter class and how to reverse the
action in your PetReader class.
■Design a nice GUI for these classes so that the user can enter, store, and dis-play data.
2.Do the exercise in Section 25.1.
15.7 Property Containers: PropsMap
Some objects, such as FileTagger (see Section 16.3.3) are heavyweight objects ,
meaning that creating/copying them requires allocation of external resources (the
ID3_tag object, specifically). If you only wish to capture the object’s proper-
ties without allocating another external resource, this is a form of in-memoryserialization.
PropsMap has its name because it uses a map as a container for name/
property pairs, Perl-style.6Example 15.8 defines the class, using a QMap to store
the properties.
EXAMPLE 15.8 src/libs/dataobjects/propsmap.h 
[ . . . . ]
class PropsMap : public DataObject {
Q_OBJECT
public:
PropsMap(QString classn=QString()): m_ClassName(classn) {}PropsMap(const QObject& other);virtual QString className() const;bool readFrom(const QObject& source);QVariant property(QString key) const {
return m_ValueMap[key];
}virtual QStringList propertyNames() const {
return m_ValueMap.keys();
}
public slots:
virtual bool setProperty(const QString& key,
const QVariant& value) ;
virtual bool setProperty(const QString& key,
const QString& value) ;15.7 PROPERTY CONTAINERS: PROPSMAP
355
6In perl, each “object” is simply a hashtable of key/value pairs with methods on it. All an object’s data
members are stored in the hash table.continuedezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 355
private:
QMap<QString, QVariant> m_ValueMap;QString m_ClassName;
};[ . . . . ]
holder of properties
the pseudo-class that the object belongs to
The implementation of these methods, shown in Example 15.9, is straightforward.
EXAMPLE 15.9 src/libs/dataobjects/propsmap.cpp 
#include <qmetaobject.h>#include <qvariant.h>#include "propsmap.h"
PropsMap::PropsMap(const QObject& other) {
readFrom(other);
}
bool PropsMap::readFrom(const QObject& source) {
m_ClassName =source.metaObject()->className();return DataObject::readFrom(source);
}
QString PropsMap::className() const {
if (m_ClassName != QString())
return m_ClassName;
else
return "PropsMap";
}
bool PropsMap::setProperty(const QString& key,
const QString & value) {
return setProperty(key, QVariant(value));
}bool PropsMap::setProperty(const QString& key,
const QVariant& value) {
m_ValueMap[key]=value;return true;
}
As you examine the code in libdataobject , you will find that PropsMap is
used for the following purposes:
1. As a default type to return from ObjectFactory when nothing is
known about the given classname
2. As a temporary container of property information from FileTagger
objects2121CHAPTER 15: META OBJECTS, PROPERTIES, AND REFLECTIVE PROGRAMMING
356ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 356
REVIEW QUESTIONS
357
REVIEW QUESTIONS
1. What is an anti-pattern? Give two examples.
2. How do you determine the number of properties defined in a QObject ?
3. How does the QMetaObject code for each of your QObject -derived
classes get generated?
4. What is a downcast? In what situations do we use them?5. What are the advantages of defining properties over regular getters and
setters?
6. What does the 
property() function return? How do we obtain the
actual stored value?ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 357
ezus_138004_ch15.qxd  8/4/06  10:04 AM  Page 358
35916.1 Creational Patterns . . . . . . . . . . . . . . . . . 360
16.2 Serializer Pattern Revisited . . . . . . . . . . 37316.3 The Façade Pattern . . . . . . . . . . . . . . . . . 38116CHAPTER 16
More Design Patterns
In this chapter, we present design patterns from eachof the three categories: creational, structural, andbehavioral.ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 359
16.1 Creational Patterns
By using creational patterns to manage object creation, we gain flexibility that
makes it possible to choose or change the kinds of objects created or used at run-time, and also to manage object deletion automatically. Especially in large softwaresystems, managing the creation of objects is important for flexibility in programdesign, maintaining a separation between layers of code and ensuring that objectsare properly deleted when they are no longer needed.
In C++, a factory is a program component, generally a class, that is responsi-
ble for creating objects. The idea of a fact ory is to separate object creation from
object usage.
A factory class generally has a func tion that obtains dynamic memory for the
new object and returns a base class pointer to that object. This approach allowsnew derived types to be introduced without necessitating changes to the code thatuses the created object.
We will discuss several design patterns that use factories and show examples of
these design patterns.
When the responsibility for heap object creation is delegated to a 
virtual
function, we call this a Factory method .
By making the factory method pure virtual and writing concrete derived
factory classes, this becomes an abstract factory .
The Abstract Factory pattern provides an interface for defining factories
that share abstract features but differ in concrete details. Client code caninstantiate a particular subfactory and then use the abstract interface to cre-ate objects.
By imposing creation rules that prevent direct instantiation of a class, we can
force clients to use factory methods to create all instances. When we combine cre-ation rules with a factory method that always returns the same singleton object,this is an example of the Singleton pattern .ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 360
The Singleton pattern restricts a class so that only one instance can be
created. This can be accomplished by making its constructor private or
protected and providing an instance() function that creates a new
instance if one does not already exist, but returns a pointer or reference tothat instance if it does.16.1 CREATIONAL PATTERNS
361
Consider two ways of creating a Customer:
Customer* c1 = new Customer(name);
Customer* c2 = CustomerFactory::instance()->newCustomer(name)
In the first case, we are hard-coding the class name and calling a constructor
directly. The object will be created in memory using the default heap storage.Hard-coded class names in client code can limit the reusability of the code.
In the second case, we create a
Customer object indirectly using a factory
method called newCustomer() .I nf a c t ,newCustomer() is being called on a
singleton CustomerFactory instance.CustomerFactory is a singleton
because only one instance is available to us, via a static factory method,
instance() .
16.1.1 Abstract Factory
AbstractFactory , defined in Example 16.1, is a simple class.
EXAMPLE 16.1 src/libs/dataobjects/abstractfactory.h
[ . . . . ]
class AbstractFactory {
public:
virtual DataObject* newObject (QString className) = 0;virtual ~AbstractFactory() {}
};
[ . . . . ]
The newObject() method is pure virtual , so it must be overridden in derived
classes. Example 16.2 shows a concrete class derived from AbstractFactory .ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 361
EXAMPLE 16.2 src/libs/dataobjects/objectfactory.h
[ . . . . ]
class ObjectFactory : public QObject, public AbstractFactory {
Q_OBJECT
public:
static ObjectFactory* instance() ;virtual DataObject* newObject (QString className);Address* newAddress (Country::CountryType country =
Country::Undefined);
Address* newAddress (QString countryName = "USA");
protected:
ObjectFactory() {}
};
[ . . . . ]
ObjectFactory knows how to create a couple of concrete types. Since it is pos-
sible for any string to be supplied to newObject() ,ObjectFactory handles
the case when an unknown class is passed. This is where PropsMap comes into
play.ObjectFactory creates a PropsMap if it does not recognize the given class
name, as we see in Example 16.3. A PropsMap is a DataObject that holds prop-
erty values in a hash table, Perl-style.
EXAMPLE 16.3 src/libs/dataobjects/objectfactory.cpp
[ . . . . ]
DataObject* ObjectFactory::newObject(QString className) {
DataObject* retval = 0;if (className == "UsAddress") {
retval = newAddress(Country::USA);
} else if (className == "CanadaAddress") {
retval = newAddress(Country::Canada);
} else {
qDebug() << QString("Generic PropsMap created for new %1")
.arg(className);
retval = new PropsMap(className);retval->setParent(this);
}return retval;
}
Initially set the parent of the new object to the factory.11CHAPTER 16: MORE DESIGN PATTERNS
362ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 362
newObject() returns the address of an object w hose parent is initially set to an
ObjectFactory singleton.1The parent can be changed later but this ensures
that, by default, the object gets deleted with the factory if it’s not managed byanother object. This is an important measure to prevent memory leaks.
16.1.2 Abstract Factories and Libraries
We now discuss two libraries, libdataobjects and libcustomer , each with
its own ObjectFactory , as shown in the UML diagram in Figure 16.1.16.1 CREATIONAL PATTERNS
363
CustomerFactory , defined in Example 16.4, extends the functionality of
ObjectFactory .
1newAddress() also sets the parent to the factory.lib QT
QObjectLibraries and their
dependencies
lib DataObjects
DataObjectAbstractObjectFactory
ObjectFactory
+newObject(className:QString): DataObject*
lib Customer
CustomerFactory
+newObject(className:QString): DataObject*Customer
FIGURE 16.1 Libraries and factoriesezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 363
EXAMPLE 16.4 src/libs/customer/customerfactory.h
[ . . . . ]
class CustomerFactory : public ObjectFactory {
Q_OBJECT
public:
static CustomerFactory* instance();DataObject* newObject(QString classname);Customer* newCustomer(QString name = "", 
Country::CountryType country=Country::Undefined);
protected:
CustomerFactory() {};
};
[ . . . . ]
CustomerFactory inherits the ability to create Address objects from
ObjectFactory . In addition, it knows how to create Customer objects.
CustomerFactory overrides and extends the newObject(QString) method
to support more types, as shown in Example 16.5.
EXAMPLE 16.5 src/libs/customer/customerfactory.cpp
[ . . . . ]
DataObject* CustomerFactory::
newObject (QString className) {
qDebug() << QString("CustomerFactory::newObject(%1)")
.arg(className);
if (className == "Customer")
return newCustomer();
if (className == "CustomerList") {
DataObject* retval = new CustomerList();retval->setParent(this);return retval;
}return ObjectFactory::newObject(className);
}
Guarantee the heap memory is freed eventually when this object factory is destroyed, unless
it is reparented and killed sooner.
For each of the three returned objects the parent is set to be the factory. We see this
explicitly in the case of a CustomerList object. If the newCustomer() function
is called, it also returns an object that is parented by the factory, as we see inExample 16.6.11CHAPTER 16: MORE DESIGN PATTERNS
364ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 364
EXAMPLE 16.6 src/libs/customer/customerfactory.cpp
[ . . . . ]
Customer* CustomerFactory::
newCustomer (QString name, Country::CountryType country) {
Customer* cust = new Customer();cust->setName(name);cust->setParent(this);if (country != 0) {
Address* defaultAddress = newAddress(country);defaultAddress->setParent(cust);cust->setAddress(defaultAddress);
}return cust;
}
16.1.3 qApp and Singleton Pattern
As we discussed earlier, the Singleton pattern is a specialized factory that is used in
situations where at most one instance of a class should be created. We use this pat-tern to manage a singleton 
ObjectFactory instance. The class definition in
Example 16.7 has two distinctive features that characterize this singleton: a non-public constructor and a 
public static instance() function.
EXAMPLE 16.7 src/libs/dataobjects/objectfactory.h
[ . . . . ]
class ObjectFactory : public QObject, public AbstractFactory {
Q_OBJECT
public:
static ObjectFactory* instance() ;virtual DataObject* newObject (QString className);Address* newAddress (Country::CountryType country =
Country::Undefined);
Address* newAddress (QString countryName = "USA");
protected:
ObjectFactory() {}
};
[ . . . . ]
The instance() function, defined in Example 16.8, is our singleton factory. It
creates an object if needed, but only the first time that the function is invoked. Italways returns a pointer to the same object on subsequent calls.16.1 CREATIONAL PATTERNS
365ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 365
EXAMPLE 16.8 src/libs/dataobjects/objectfactory.cpp
[ . . . . ]
ObjectFactory* ObjectFactory::instance() {
static ObjectFactory* singleton = 0;if (singleton == 0) {
singleton = new ObjectFactory();
singleton->setParent(qApp);
}return singleton;
}
static
guarantees this object is deleted when the application is done
For the parent of this object, we set it to qApp . This is a pointer to a singleton
instance of a QApplication , which was presumably created in main() .T h e
QApplication instance exists precisely as long as the application is running.
WHY NOT USE STATIC FOR OUR SINGLETON? If you make the
singleton ObjectFactory a static object instead of a heap object,
then children of the factory object will be destroyed after the
QApplication is destroyed. Unless there is a compelling reason to the
contrary, an application should not do anything after the QApplication
has been destroyed —including object cleanup. Static objects from differ-
ent files of a multi-file application are destroyed in a linker-dependentorder. That order of destruction may cause unintended side-effects (e.g.,segmentation faults at termination).
To avoid this problem, you should follow this rule: Each 
QObject
should either be allocated on the stack or be allocated on the heap withanother 
QObject (or qApp ) as its parent.This guarantees that there will
not be any leftover pieces to be destroyed after the QApplication is
destroyed.
If a QObject is allocated on the heap, and its parent is set to qApp ,
then it is deleted at the “last possible moment.” Children of this singleton
factory will be deleted just before the factory is deleted.
16.1.4 Creation Rules and friend Functions (What
Friends Are Really For)
Y ou can design a class to have a creation rule, such as: All new Customers must
be created indirectly through a CustomerFactory . Y ou can enforce this rule by
defining only non-public constructors. In particular, make sure that you make the2121CHAPTER 16: MORE DESIGN PATTERNS
366ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 366
copy constructor and the assignment operator non-public. If you omit them from
the class definition, the compiler will supply public versions of these two member
functions, thus producing two “loopholes” in your creation rule. For example, thismight permit clients to create
Customer instances that are not children of your
factory (which could lead to memory leaks). It is important to document this ruleclearly in your class definition, as we did with the comment in Example 16.9.
EXAMPLE 16.9 src/libs/customer/customer.h
[ . . . . ]
class Customer : public DataObject {
Q_OBJECT
[ . . . . ]
friend class CustomerFactory;
protected:
Customer(QString name=QString()) {
setObjectName(name);
}
Customer(QString name, QString id, CustomerType type);
We declared the constructors of Customer as protected, so all Customer objects must be
created indirectly through a CustomerFactory.
In Example 16.9, the constructors are protected .2CustomerFactory is
declared to be a friend class inside Customer. This gives CustomerFactory
permission to access the non-public members of Customer. In this way, we have
made it impossible for client code to create Customer objects except through the
CustomerFactory. In Example 16.10, we have a similar setup with the various
Address classes. The base class, Address , is abstract.
EXAMPLE 16.10 src/libs/dataobjects/address.h
[ . . . . ]
class Address : public ConstrainedDataObject {
Q_OBJECT
public:[ . . . . ]
protected:
Address(QString addressName = QString()) {
setObjectName(addressName);
}11116.1 CREATIONAL PATTERNS
367
2This permits us to write derived classes that reuse this constructor.continuedezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 367
public:
virtual Country::CountryType getCountry() = 0;
[ . . . . ]
private:
QString m_Line1, m_Line2, m_City, m_Phone;
};
protected constructor
In the derived classes, defined in Example 16.11, we have protected the
constructors and given friend status to a factory, this time DataObjects::
ObjectFactory . This gives ObjectFactory permission to access the non-
public members of UsAddress and CanadaAddress .
EXAMPLE 16.11 src/libs/dataobjects/address.h
[ . . . . ]
class UsAddress : public Address {
Q_OBJECT
public:
Q_PROPERTY( QString State READ getState WRITE setState );Q_PROPERTY( QString Zip READ getZip WRITE setZip );friend class ObjectFactory;
protected:
UsAddress(QString name=QString()) : Address(name) {}static QString getPhoneFormat();
public:
static void initConstraints() ;
[ . . . . ]
private:
QString m_State, m_Zip;
};
class CanadaAddress : public Address {
Q_OBJECT
public:
Q_PROPERTY( QString Province READ getProvince 
WRITE setProvince );
Q_PROPERTY( QString PostalCode READ getPostalCode 
WRITE setPostalCode );
friend class ObjectFactory;
protected:
CanadaAddress(QString name=QString()): Address(name) {}static QString getPhoneFormat();
public:
static void initConstraints() ;
[ . . . . ]211CHAPTER 16: MORE DESIGN PATTERNS
368ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 368
private:
QString m_Province, m_PostalCode;
};
All new UsAddress objects must be created indirectly through an ObjectFactory.
All new CanadaAddress objects must be created indirectly through an ObjectFactory.
It is now impossible to create Address objects except through the factory or from
the derived classes.
If you are writing a multi-threaded application that uses an
ObjectFactory , you need to be careful about the ownership of
objects.
Making a QObject the parent of a child in another thread will result in an error mes-
sage such as the following one:2116.1 CREATIONAL PATTERNS
369
New parent must be in the same thread as the previous parent", file 
kernel/qobject.cpp, line 1681Aborted
To make our ObjectFactory work in a multi-threaded environment, we can:
1. Explicitly pass the parent when we create each object (to prevent the default
parenting behavior)
2. Write the factory’s singleton() function to return an object that belongs
to the local thread
16.1.5 Benefits of Using Factories
One of the benefits of factory patterns is that we can ensure that the created
objects are destroyed by assigning them parents before returning them. Any objectcreated by 
ObjectFactory is deleted when the ObjectFactory singleton is
destroyed (unless the object’s parent is changed).
As processing continues, we normally expect the created objects to acquire
more appropriate parents. In fact, we can regard created objects that retain the fac-tory  parent as “unclaimed” objects. We can clean up all of the  heap memory usedby unclaimed objects by iterating through the children of the factory and deleting
them.
3
3This is similar to the way that garbage-collected heaps work.ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 369
Indirect object creation also makes it possible to decide at runtime which class
objects to create. This allows the “plugging in” of replacement classes withoutrequiring changes in the client code. In Section 16.2, we will see an example of amethod that makes use of factory objects to create trees of connected, client-defined objects based on the contents of an XML file.
Libraries and Plugins
When constructing a large system we group classes together in libraries when
they share some common features or need to be used together. Substantialapplications generally make use of components from several libraries, somesupplied by the development team and some supplied by third-party devel-opers (e.g., Qt from Trolltech). Only the public interface of a library classappears in the client code of reusers. Library designers should be able tochange the implementation of any class without breaking client code. Manylibraries permit the “plugging in” of outside classes by publishing interfacesand documenting how to implement them. Libraries can facilitate the cre-ation of such plug-in classes by providing a factory base class from which spe-cialized factory classes can be derived as needed.
Another benefit of the factory method (or indirect object creation in general) is
that you can enforce post-constructor initialization of objects, including the invo-cation of virtual functions.
Polymorphism from Constructors
An object is not considered “fully constructed” until the constructor has finishedexecuting. An object’s vpointer does not point to the correct vtable until the end of
the constructor’s execution. Therefore, calls to methods of
this from the con-
structor cannot use polymorphism!
Factory methods are required when any polymorphic behavior is needed dur-
ing object initialization. Example 16.12 demonstrates this problem.CHAPTER 16: MORE DESIGN PATTERNS
370ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 370
EXAMPLE 16.12 src/ctorpoly/ctorpoly.cpp
#include <iostream>
using namespace std;
class A {
public:
A() {
cout << "in A ctor" << endl;foo();
}virtual void foo() {
cout << "A's foo()" << endl;
}
};
class B: public A {
public:
B() {
cout << "in B ctor" << endl;
}void foo() {
cout << "B's foo()" << endl;
}
};
class C: public B {
public:
C() {
cout << "in C ctor" << endl;
}
void foo() {
cout << "C's foo()" << endl;
}
};
int main() {
C* cptr = new C;cout << "After construction is complete:" << endl;cptr->foo();return 0;
}
Its output is given in Example 16.13.16.1 CREATIONAL PATTERNS
371ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 371
EXAMPLE 16.13 src/ctorpoly/ctorpoly-output.txt
src/ctorpoly> ./a.out
in A ctorA's foo()in B ctorin C ctorAfter construction is complete:C's foo()
src/ctorpoly>
Notice that the wrong version of foo() was called while the new Cobject was
being constructed. Y ou can find more discussion on vtables in Section 23.1.
EXERCISES: CREA TIONAL PA TTERNS
1.Complete the implementation of the Address ,Customer , and
CustomerList classes.
Apply the ideas that we discussed in Section 10.6 to write a
CustomerWriter class. Make sure that you use the Q_PROPERTY features of
Customer and Address so that your CustomerWriter class will not need
to be rewritten if you change the implementation of Customer.
Keep in mind that Address objects are stored as children of Customer
objects. Here is one output format that you might consider using:
Customer {
Id=83438DateEstablished=2004-02-01Type=CorporateobjectName=Bilbo BagginsUsAddress {
Line1=52 Shire RoadLine2=Suite 6City=BrightonPhone=1234567890State=MAZip=02201addressName=home
}
}
Another possibility arises if you make use of the Dataobject ::toString()
function.
2.Write a CustomerReader class that creates all of its new objects by reusing
the CustomerFactory class that we supplied.CHAPTER 16: MORE DESIGN PATTERNS
372ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 372
Write a CustomerListWriter and a CustomerListReader class that
serialize and deserialize lists of Customer objects. How much of the
CustomerWriter/Reader code can you reuse here?
Write client code to test your classes.
16.2 Serializer Pattern Revisited
In this section, we combine QMetaObjects with the SAX2 parser to show how
one can write a general-purpose XML encoding/decoding tool that works on
QObjects with well-defined Q_PROPERTY s and children. This gives us a nice
example that combines the MetaObject pattern with the Serializer pattern.
T o encode and decode DataObjects as XML, we must define a mapping
scheme. Such a mapping must capture not only the QObject ’s properties, types,
and values, but it must also capture existing relationships between the object andits children, between each child and all of its children, and so on.
The parent-child relationships of XML elements naturally map to 
QObject
parents and children. These relationships define a tree structure.
Consider the class definition for Customer shown in Example 16.14.
EXAMPLE 16.14 src/xml/propchildren/customer.h16.2 SERIALIZER PATTERN REVISITED
373
[ . . . . ]
class Customer : public QObject {
Q_OBJECT
public:
Q_PROPERTY( QString Name READ objectName WRITE setObjectName );Q_PROPERTY( QDate Date READ getDate WRITE setDate );Q_PROPERTY( int LuckyNumber READ getLuckyNumber 
WRITE setLuckyNumber );
Q_PROPERTY( QString State READ getState WRITE setState );Q_PROPERTY( QString Zip READ getZip WRITE setZip );Q_PROPERTY( QString FavoriteFood READ getFavoriteFood 
WRITE setFavoriteFood );
Q_PROPERTY( QString FavoriteDrink READ getFavoriteDrink 
WRITE setFavoriteDrink);
// typical setters and getters
[ . . . . ]
private:
QString m_Name, m_State, m_Zip;QString m_FavoriteFood, m_FavoriteDrink;QDate m_Date;int m_LuckyNumber;
};
[ . . . . ]ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 373
Exploiting the ability of QObject subclasses to maintain a collection of child
objects, we define a CustomerList class in Example 16.15 that stores Customers
as children.
EXAMPLE 16.15 src/xml/propchildren/customerlist.h
#ifndef CUSTOMERLIST_H
#define CUSTOMERLIST_H
#include <QList>
#include "customer.h"
class CustomerList : public QObject {
Q_OBJECT  
public:
CustomerList(QString listname = QString()) {
setObjectName(listname);
}QList<Customer*> getCustomers();static CustomerList* sample();
};
#endif
An example of the desired XML format for storing the data of a
CustomerList is shown in Example 16.16.
EXAMPLE 16.16 src/xml/propchildren/customerlist.xml
<object class="CustomerList" name="Customers" >
<object class="Customer" name="Simon" >
<property name="Name" type="QString" value="Simon" /><property name="Date" type="QDate" value="1963-11-22" /><property name="LuckyNumber" type="int" value="834" /><property name="State" type="QString" value="WA" /><property name="Zip" type="QString" value="12345" /><property name="FavoriteFood" type="QString" value="Donuts" /><property name="FavoriteDrink" type="QString" alue="YooHoo"/>
</object>
<object class="Customer" name="Raja" >
<property name="Name" type="QString" value="Raja" /><property name="Date" type="QDate" value="1969-06-15" /><property name="LuckyNumber" type="int" value="62" /><property name="State" type="QString" value="AZ" /><property name="Zip" type="QString" value="54321" />CHAPTER 16: MORE DESIGN PATTERNS
374ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 374
<property name="FavoriteFood" type="QString" value="Mushrooms" />
<property name="FavoriteDrink" type="QString" value="Jolt" />
</object>16.2 SERIALIZER PATTERN REVISITED
375
continued</object>
With this kind of information in an input file, we should be able to fully recon-
struct not only the properties and their types, but also the tree structure of parent-child relationships between objects for a 
CustomerList .
16.2.1 Exporting to XML
We define in Example 16.17 a simplified class that can be used to export the cur-
rent state of a QObject to an XML string with elements that contain, for each
property, its name, type, and value.
EXAMPLE 16.17 src/xml/propchildren/xmlexport.h
[ . . . . ]
class XMLExport {
public:
virtual ~XMLExport() {}virtual QString objectToXml(const QObject* ptr,
int indentlevel=0);
};
[ . . . . ]
In Example 16.18 we show the definition of objectToXml() , a recursive func-
tion that constructs strings for each of the object’s properties and then iteratesover the object’s children, recursively calling 
objectToXml() on each child.
EXAMPLE 16.18 src/xml/propchildren/xmlexport.cpp
[ . . . . ]
QString XMLExport::objectToXml(const QObject* doptr,
int indentlevel) {
QStringList result;QString indentspace;
indentspace.fill(' ', indentlevel*3);
const QMetaObject* meta = doptr->metaObject();result += QString("\n%1<object class=\"%2\" name=\"%3\" >").
arg(indentspace).arg(meta->className()).arg(doptr->objectName());    ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 375
for (int i= 0; i < meta->propertyCount(); ++i) {
QMetaProperty qmp = meta->property(i);const char* propname = qmp.name();if (strcmp(propname, "objectName")==0)
continue;
QVariant qv;if (qmp.isEnumType()) {
QMetaEnum qme = qmp.enumerator();qv = qme.valueToKey(qv.toInt());
} else {
qv = doptr->property(propname);
}
result += QString (1CHAPTER 16: MORE DESIGN PATTERNS
376
"%1 <property name=\"%2\" type=\"%3\" value=\ "%4\" />"
).arg(indentspace).arg(propname). arg(qv.typeName())
.arg(variantToString(qv));
}
QObjectList childlist = doptr->findChildren<QObject*> (QString());
foreach (QObject* objptr, childlist) {
if (objptr->parent()==doptr) {
result += objectToXml(objptr, indentlevel+1);
}
}result += QString("%1</object>\n").arg(indentspace);  return result.join("\n");
}[ . . . . ]
Iterate through each property.
Iterate through the child list.findChildren also includes grandchildren and great-great grandchildren, so we skip over those.
recursive call
objectToXml() uses Qt’s properties and QMetaObject facilities to reflect on
the class. As it iterates it appends each line to a QStringList . When iteration is
complete, the <object> is closed. The return QString is then produced quickly
by calling QStringList::join("\n") .
16.2.2 Importing Objects with an Abstract Factory
Section 14.24321432ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 376
The importing routine is a bit more sophisticated than the exporting routine, and
it has a couple of interesting features.
■It parses XML using the SAX parser.
■Depending on the input, it creates objects.
■The number and types of objects, as well as their parent-child relation-
ships, must be reconstructed from the information in the file.
Example 16.19 shows the class definition for DataObjectReader .
EXAMPLE 16.19 src/libs/dataobjects/dataobjectreader.h
[ . . . . ]
#include <QString>#include <QStack>#include <QQueue>#include <QXmlDefaultHandler>
class AbstractFactory;
class DataObject;class DataObjectReader : public QXmlDefaultHandler {
public:
DataObjectReader (AbstractFactory* factory=0) : 
m_Factory(factory), m_Current(0) { }
DataObjectReader (QString filename,
AbstractFactory* factory=0);
void parse(QString text);void parseFile(QString filename);DataObject* getRoot();~DataObjectReader();
// callback methods from QXmlDefaultHandler
bool startElement( const QString & namespaceURI,
const QString & name,const QString & qualifiedName,
const QXmlAttributes & attributes );
bool endElement(  const QString & namespaceURI,
const QString & localName,
const QString & qualifiedName);
bool endDocument();
private:
void addCurrentToQueue();AbstractFactory* m_Factory;DataObject* m_Current;QQueue<DataObject*> m_ObjectList;QStack<DataObject*> m_ParentStack;
};
[ . . . . ]
Figure 16.2 shows the relationships between the various classes that we will be using.16.2 SERIALIZER PATTERN REVISITED
377ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 377
CHAPTER 16: MORE DESIGN PATTERNS
378
<<interface>>
QXmlContentHandler<<interface>>
QXmlReader
QXmlDefaultHandler QXmlSimpleReader
DataObjectReader
 - m_Factory : AbstractFactory*
 - m_Current : DataObject* - m_ObjectList :  QQueue<DataObject*> - m_ParentStack : QStack<DataObject*>
+ DataObjectReader()+ DataObjectReader()+ parse()+ parseFile()+ getRoot()+ ~ DataObjectReader()+ startElement()+ endElement()+ endDocument() - addCurrentT oQueue()AbstractFactory
+ newObject(className : QString) : DataObject *
+ ~ AbstractFactory()
ObjectFactory
+ instance() : ObjectFactory*
+ newObject(className : QString) : DataObject*
+ newAddress(country : Country.CountryType) : Address*+ newAddress(countryName : QString) : Address*# ObjectFactory()0..1
+ m_Factory
FIGURE 16.2 DataObjectReader and its related classes
DataObjectReader is derived from QXmlDefaultHandler , which is a 
plugin for the QXmlSimpleReader .AbstractFactory is a plugin for
DataObjectReader . When we create a DataObjectReader , we must supply
it with a concrete class, such as ObjectFactory or DataObjectFactory .
DataObjectReader is now completely separate from the specific types of
objects that it can create. T o use it with your own types, just derive a factory from
AbstractFactory for them.
Think about Example 16.16 as you read the code that constructs objects from
it in the code the follows.
startElement() is called when the SAX parser encounters the initial tag of
an XML element. As we see in Example 16.20, the parameters to this function con-tain all the information we need to create an object. All other objects that areencountered between
startElement() and the matching endElement() are
children of m_Current .ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 378
EXAMPLE 16.20 src/libs/dataobjects/dataobjectreader.cpp
[ . . . . ]
bool DataObjectReader::startElement( const QString &,
const QString & elementName,const QString &,const QXmlAttributes & atts) {
if (elementName == "object") {
if (m_Current != 0)                              
m_ParentStack.push(m_Current);                
QString classname = atts.value("class");QString instancename = atts.value("name");
if (m_Factory ==0) {
m_Current =
ObjectFactory::instance()->newObject(classname);
} else {
m_Current=m_Factory->newObject(classname);
}m_Current->setObjectName(instancename);if (!m_ParentStack.empty()) {
m_Current->setParent(m_ParentStack.top());
}return true;
}if (elementName == "property") {
QString fieldType = atts.value("type");QString fieldName = atts.value("name");QString fieldValue = atts.value("value");QVariant qv = variantFrom(fieldType, fieldValue);bool ok = m_Current->setProperty(fieldName, qv);if (!ok) {432116.2 SERIALIZER PATTERN REVISITED
379
qDebug() << "setProperty(" << fieldName << ") failed";
}
}return true;
}
Unnamed parameters are a way of avoiding “parameter not used”warnings from the compiler.
It is necessary to include the parameters, even though we do not need them for this applica-tion, so that the signature matches that of the base class method and polymorphic overrideswill be properly called.
if we are already inside an <object>Keep track of the current parent.
If this element has a parent, it is on the top of the stack. Set its parent.
The Object is “finished” when we reach endElement() , which is defined in
Example 16.21.4321ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 379
EXAMPLE 16.21 src/libs/dataobjects/dataobjectreader.cpp
[ . . . . ]
bool DataObjectReader::endElement( const QString & , 
const QString & elementName,const QString & ) { 
if (elementName == "object") {
if (!m_ParentStack.empty())
m_Current = m_ParentStack.pop();
else {
addCurrentToQueue();
}
}return true;
}
DataObjectReader uses an Abstract Factory to do the actual object creation.
The callback function, newObject (QString className ), creates an object
that can hold all of the properties described in className .ObjectFactory
creates “pseudo-objects” that are not exactly the CustomerList and Customer
classes, but they “mimic” them well enough that the export/import process worksround-trip. Y ou can write a concrete factory that returns the proper types for each
classname if you want the de-serialized tree to have the same types as the objects
in the original tree.
Each time a new address type is added to this library, we can add another else
clause to the createObject function, as shown in Example 16.22.
EXAMPLE 16.22 src/libs/dataobjects/objectfactory.cpp
[ . . . . ]
DataObject* ObjectFactory::newObject(QString className) {
DataObject* retval = 0;if (className == "UsAddress") {
retval = newAddress(Country::USA);
} else if (className == "CanadaAddress") {
retval = newAddress(Country::Canada);
} else {
qDebug() << QString("Generic PropsMap created for new %1 ").
arg(className);retval = new PropsMap(className);retval->setParent(this);
}return retval;
}
Initially set the parent of the new object to the factory.11CHAPTER 16: MORE DESIGN PATTERNS
380ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 380
16.3 The Façade Pattern
A class that uses the Façade pattern provides “a unified interface to a set of
interfaces in a subsystem. Façade defines a higher-level interface that makesthe subsystem easier [and safer] to use.”
4When a class interface is too com-
plicated to use effectively (leads to hard-to-debug errors from improper use)or does not use a programming style that fits into our larger framework, afaçade should be used. A façade is a class with a clear simple interface thatencapsulates and hides a complicated set of classes and/or functions.
Experience gained from the struggle to reuse classes with difficult interfaces can
provide valuable motivation for desig ning elegant, friendly, and useful interfaces
for your own classes.
MP3 files have become a popular format for storing songs and other audio
content. Each MP3 file stores audio data which, when processed by a programsuch as XMMS, can be output as audio. The file also stores metadata , or struc-
tured information about the audio content. The defacto standard for specifyingMP3 metadata is called ID3.
Using 
id3lib , an open-source library, the metadata can be loaded into an
object of class ID3_Tag .A n  ID3_Tag is a collection of ID3_Frame objects plus
file data. An ID3_Frame object consists of a collection of ID3_Field objects. An
ID3_Field can represent three possible types of data: integers, binary data, or
text strings. Figure 16.3 shows the relationships between the types in a collabora-tion diagram originally generated by Doxygen.
id3lib5is an old, fast, open-source C/C++ library for reading and writing
ID3v2 tags from mp3 files. Because of its arcane programming style, it is being
shunned by KDE developers in favor of a newer library, taglib ,6which is more
flexible (can handle other file formats as well as MP3) and uses a more modernprogramming style.16.3 THE FAÇADE PATTERN
381
4[Gamma 95]
5http://id3lib.sourceforge.net/
6http://developer.kde.org/~wheeler/taglib.htmlezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 381
ID3 tag information can be used by an MP3 player to display pertinent infor-
mation (e.g., title, performer, etc.) about a selection that is currently being played
or that is being queued for play. It can also be used to organize collections of audiofiles or to create playlists.
In Example 16.23 we see some low-level code that uses the 
id3lib to get pref-
erence data set by the popular commercial program MusicMatch Jukebox , as sug-
gested by the id3lib tutorial.7CHAPTER 16: MORE DESIGN PATTERNS
382
7http://id3lib.sourceforge.net/api/index.htmlFIGURE 16.3 ID3_Tag and its related classesID3_Header::Info ID3_Flags
ID3_Header Mp3_Headerinfo
ID3_TagHeader Mp3Info
ID3_TagImpl
ID3_Tag_flags_info
_hdr
_impl_mp3_info_mp3_header_output_file_tags
_tags_to_parse
ID3_Header::Info ID3_FieldDef DEFAULT ID3_Flags
ID3_Header ID3_FrameDef
ID3_FrameHeader
ID3_FrameImpl
ID3_Frame_flags_info aeFieldDefs
_hdr
_impl_frame_defezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 382
EXAMPLE 16.23 src/facade/id3lib-usage.cpp
[ . . . . ]
#include <id3/tag.h>#include <id3/misc_support.h>#include <QString>
QString getStringField(ID3_Tag &tag, ID3_FrameID id,
ID3_FieldID fieldid) {
static char buffer[256];
const int size=255;
ID3_Frame* myFrame = tag.Find(id);
if (myFrame) {
ID3_Field *myField = myFrame->GetField(fieldid);if (myField)
myField->Get(buffer, size);
}return QString(buffer);
}
QString getPreference(QString filename) {
QString retval;
ID3_Tag tag;
tag.Link(filename.toAscii());
QString commentType = getStringField(tag, ID3FID_COMMENT,
ID3FN_DESCRIPTION);
if (commentType == "MusicMatch_Preference")  {
retval = getStringField(tag, ID3FID_COMMENT, ID3FN_TEXT);return retval;
} else
return "Undefined";
}[ . . . . ]
gets the MusicMatch preference
The code in Example 16.23 has some style issues that make it hard to fit into our
Qt-style framework.
■First,char arrays should be avoided whenever possible. We use
QString instead, to support Unicode, improve readability, and reduce
the chance of bugs.
■Client code should not need to deal with ID3Frame or ID3Field
objects, or their ID enumerators.
■Class and function capitalization rules of id3lib are inconsistent with
our style guidelines (see Section 3.4).1116.3 THE FAÇADE PATTERN
383ezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 383
16.3.1 Functional Façade
id3lib has a collection of convenience func tions for getting and setting the more
popular tags without needing to use the enum constants or to deal with frames and
fields. The convenience functions are defined in misc_support.cpp .8In a sense,
these functions are a façade for the ID3_tag class and related functions.
Unfortunately, the convenience functions are ordinary C functions, which meansthey use C-style coding to access ID3 data.
Using these functions instead of the 
ID3_tag class and functions, client code
does become simpler. For example, to get or add the genre of a song, we can usethese functions:
char * ID3_GetGenre ( const ID3_Tag * tag);
ID3_Frame * ID3_AddGenre (ID3_Tag * tag, size_t genre, bool replace);
ThegetPreference() function, rewritten to use this library, is also much simpler:
QString getPreference(QString filename) const  {
ID3_Tag tag; tag.Link(filename);             return ID3_GetComment(&tag, "MusicMatch_Preference");
}
So, the advantages to using these functions are
■They have already been tested and debugged.
■They have removed the need to use enum constants, frames, or fields.
The disadvantages to using this library directly in C++ client code are 
■We have an object that maintains the state of an MP3 tag record (ID3_Tag) ,
but we are no longer using its interface to access and change its values.
■We are using C coding style in client code.
16.3.2 Smart Pointers: auto_ptr
A wrapper encapsulates and manages at least one other object. If that object is a
heap object, we can use the Standard Library auto_ptr to ensure that the object is
always destroyed when the wrapper is.
auto_ptr is a template type , so it can be instantiated for use with any other
type. In Example 16.24, we work with the Customer type.CHAPTER 16: MORE DESIGN PATTERNS
384
8http://id3lib.sourceforge.net/api/misc_support.cpp.htmlezus_138004_ch16.qxd  8/4/06  10:05 AM  Page 384
EXAMPLE 16.24 auto_ptr code fragment
for (int i=0; i< someNumber; ++i) {             
auto_ptr<Customer> custPtr;auto_ptr<Customer> custPtr2 (new Customer());custPtr = custPtr2;
}
The loop is here to demonstrate how a block of code creates and destroys its local objects on
the stack.
a null auto_ptr
custPtr2 is initialized to point to and manage the new Customer object.
custPtr takes ownership of custPtr2 , meaning that custPtr2 will be NULL after this
statement is over.At the end of each iteration, the local custPtr goes out of scope, and the heap Customer
instance gets destroyed.
An auto_ptr<Customer> is type-restricted , to point to objects derived from
Customer , as specified in the template parameter. An attempt to use this to point
to any other type will result in a compiler error.
When an auto_ptr is destroyed, the pointed-to heap object is delete d.
Therefore, when the above code in Example 16.24 is executed, there will be nomemory leaks, even though the loop created many 
new heap objects and the code
contains no corresponding delete .
Assignment with auto_ptr is very different from assignment with other types.
Usually, the right side is not changed. However, the auto_ptr on the right side of
an assignment always becomes NULL , while the left side takes ownership of the
pointed-to object. This guarantees that only one auto_ptr is ever pointing to an
object and ensures that the object will get deleted exactly once by its auto_ptr .
Guarded pointers9such as the auto_ptr are frequently used in wrappers and
façades, as we show in the next example.
16.3.3 FileTagger: Façade Example
In this section, we discuss a Qt-style façade for id3lib . T o this end, we employ
another pattern that is closely related to the façade.543215432116.3 THE FAÇADE PATTERN
385
9QPointer is another guarded pointer, similar to auto_ptr , but specifically for use on QObjects .
Guarded pointers are discussed in more detail in Section 19.9.ezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 385
The Adaptor pattern converts the interface of a class into another interface
that clients expect, so classes that originally had incompatable interfaces canbe used together. Adaptor is also known as the Wrapper pattern.
10
Figure 16.4 shows the relationships between the classes that we will use for
FileTagger , a façade for id3lib , and a wrapper for an ID3_Tag .CHAPTER 16: MORE DESIGN PATTERNS
386
QObject
DataObjectID3_FrameImpl
ID3_T agImplID3_Frame
- _impl : ID3_FrameImpl*
FileT agger
- mTag : ID3_Tag*
- mFilename : QString
Implementation0..1
+mTag-_frames 0..*+_impl 0..1
+_impl 0..1
ID3_T ag
- _impl : ID3_TagImpl*
FIGURE 16.4 FileTagger and the classes it fronts for
Here are the requirements for FileTagger .
1. It must safely allocate and free any resources that it uses (such as
ID3_Tag objects from the heap).
2. It should provide a QObject properties interface compatible with moc.
3. It must expose all features of id3lib that we need to use, so that it is
not necessary to include the id3lib headers from any other source code
module.
4. It must provide a clean and simple interface with self-explanatory
function names.
10When the same pattern is arrived at by different people, and given different names, its importance
is emphasized.ezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 386
5. It must have getters and setters for the standard tag items (artist, album,
title, genre, preference, track number) as specified in an abstract class,
Mp3Song .
6. It must hide all of id3lib ’s enumerated constants and noncompliant
capitalization conventions from the users of this class.
7. It must not use C-style char arrays to represent strings. Instead, it
should use Unicode QString s.
8. It should emit signals when its properties are changed.
9. It should define slots for setting properties.
Example 16.25 shows the class definition for the FileTagger class.
EXAMPLE 16.25 src/libs/filetagger/filetagger.h
[ . . . . ]
#include <QString>
#include <memory>#include <dataobject.h>#include "mp3song.h"#include <id3/tag.h>
class FileTagger : public DataObject, public Mp3Song {
Q_OBJECT
public:
Q_PROPERTY( QString Artist READ getArtist 
WRITE setArtist );
Q_PROPERTY( QString TrackTitle READ getTrackTitle 
WRITE setTrackTitle );
Q_PROPERTY( QString AlbumTitle READ getAlbumTitle 
WRITE setAlbumTitle );
Q_PROPERTY( QString TrackNumber READ getTrackNumber 
WRITE setTrackNumber );
Q_PROPERTY( QString Genre READ getGenre 
WRITE setGenre);
Q_PROPERTY( QString Comment READ getComment 
WRITE setComment);
Q_PROPERTY(QString Preference READ getPreference 
WRITE setPreference);
Q_PROPERTY( QString Filename READ getFilename 
WRITE setFilename );
// read only propertiesQ_PROPERTY(QString Url READ getUrl);Q_PROPERTY(int TrackTime READ getTrackTime);
public:
FileTagger(QString filename = "");~FileTagger();bool isValid() const;16.3 THE FAÇADE PATTERN
387
continuedezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 387
/* getters ...*/
QString getFilename() const {return m_Filename; }QString getPreference() const;
[ . . . . ]
private:
std::auto_ptr<ID3_Tag> m_Tag; QString m_Filename;
};
In Example 16.26 we show the implementation details for some of the member
functions. The setter for m_FileName not only assigns a value to that member but
it also clears the ID3_Tag and establishes a link between that tag and the named file.
auto_ptr works as a smart pointer, managing the memory for us so that the
destructor does not need to delete that memory.
EXAMPLE 16.26 src/libs/filetagger/filetagger.cpp
[ . . . . ]
// macro for converting QSrtings to ASCII
#define ASCII toAscii().data()
bool FileTagger::isValid() const {
if (m_Tag.get() == NULL)
return false;
return m_Tag->HasV1Tag ();
}
void FileTagger::setFilename(const QString & filename) {
std::auto_ptr<ID3_Tag> newTag( new ID3_Tag() );
m_Tag = newTag;m_Filename = filename;m_Tag->Link(m_Filename.ASCII);emit propertyChanged("all", "all");
}
FileTagger::~FileTagger() {
//    delete m_Tag;}
get() returns the managed pointer.
auto_ptr has an operator-> that lets us use it like a pointer.We can’t assign an auto_ptr to anything but another auto_ptr.using ASCII conversion macro
not needed with auto_ptr
The other setters and getters, shown in Example 16.27, make use of the C-style
convenience functions from the ID3 misc_s upport library. Those functions have
names like ID3_AddSomething() or ID3_GetSomething() , and each takes a5432154321CHAPTER 16: MORE DESIGN PATTERNS
388ezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 388
regular pointer to an ID3_Tag. The auto_ptr has a get() function for return-
ing that pointer.
EXAMPLE 16.27 src/libs/filetagger/filetagger.cpp
[ . . . . ]
void FileTagger::setPreference(const QString& prefstr) {
ID3_AddComment(m_Tag.get(),  prefstr.ASCII,
"MusicMatch_Preference", "en", true);
}
QString FileTagger::getPreference() const {
return ID3_GetComment(m_Tag.get(), "MusicMatch_Preference");
}
void FileTagger::setGenre(const QString& newGenre) {
ID3_AddGenre(m_Tag.get(), newGenre.ASCII, true);
}
QString FileTagger::getGenre() const {
return ID3_GetGenre(m_Tag.get());
}
Each of the ID3 fields we plan to use is now mapped to a Qt property with a proper
getter and a setter. No char* are needed to work with ID3 tags for any applica-
tion that uses this class.
EXERCISES: THE FAÇADE PA TTERN
1.Build view classes for the Customer and CustomerList classes that you
defined in “Exercises: Creational Patterns” in Section 16.1.6.
CustomerView should display the current values of all Customer
attributes.
CustomerList should only display a list of Customer names. If the user
clicks on a name in that list, the corresponding CustomerView should appear.
2.Compile and install libid3 according to the instructions in Section 25.4. Write
a test program to verify that you can read and write ID3 tags.
POINTS OF DEPARTURE
1. Try to come up with another UserType you might want to add to
QVariant for a new type of InputField .
2. Further discussion of moc and marshalling objects using metaobjects can
be found in Qt Quarterly .1116.3 THE FAÇADE PATTERN
389
11http://doc.trolltech.com/qq/qq14-metatypes.htmlezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 389
7CHAPTER 16: MORE DESIGN PATTERNS
390
REVIEW QUESTIONS
1. How can a creational pattern help manage object destruction?
2. How can properties help us write a more general-purpose Writer ?
3. How can an Abstract Factory help us write a more general-purpose
Reader ?
4. What is auto_ptr used for?
5. What is special about assignment between auto_ptr objects?
6. We can create a FormModel in a number of ways. One approach is to
create Question objects directly and add them. Another way is to create
a FormModel from a DataObject . Why would we use one technique
instead of the other?
7. Name other examples of façades that we have worked with in the book.
Explain why they are façades (or wrappers).
ezus_138004_ch16.qxd  8/4/06  10:06 AM  Page 390
39117.1 M-V-C: What about the Controller? . . . 392
17.2 Dynamic Form Models . . . . . . . . . . . . . . 39317.3 Qt 4 Models and Views . . . . . . . . . . . . . . 40917.4 Table Models . . . . . . . . . . . . . . . . . . . . . . . 41117.5 Tree Models . . . . . . . . . . . . . . . . . . . . . . . . 41717CHAPTER 17
Models and Views
The Model-View pattern describes techniques ofseparating the underlying data (the model) from theclass that presents the user with a GUI (the view).In this chapter we will see a model for a form, and acouple of ways to view and enter data into it. Qtmodel and view classes are discussed, and we willsee examples of lists, trees, and tables.ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 391
In several earlier examples we saw code that maintained a clean separation
between model classes that represent data and view code that presents a user
interface. There are several important reasons for enforcing this separation.
First of all, separating model from view reduces the complexity of each. Model
code and view code have completely different maintenance imperatives—changesare driven by completely different factors—so it is much easier to maintain eachof them when they are kept separate. Furthermore, the separation of model fromview makes it possible to maintain several different, but consistent, views of thesame data model. The number of sophisticated view classes that can be reusedwith well-designed models is constantly growing.
Some older GUI toolkits offer lists, trees, and tables, but they require the devel-
oper to store model data inside them. Storing data inside view classes leads to astrong dependency between the user interface and the underlying data model. Thisdependency makes it very difficult to reuse the view classes.
17.1 M-V-C: What about the Controller?
There is a third tier to the model/view structure: the controller. Controller code is
code that manages the interactions among events, models, and views. Factorymethods, and creation and destruction code in general fall into the realm of thecontroller.
Model-View-Controller (MVC) , illustrated in Figure 17.1, is a design pattern
that is used for applications in which a variety of views of the same data need tobe maintained. The pattern specifies that the mo del code (responsible for main-
taining the data), the view code (responsible for displaying all or part of the datain various ways), and the controller code (responsible for handling events thatimpact the data or the model) be kept as separate as possible from one another.This separation allows views and controllers to be added or removed withoutrequiring changes in the model.
ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 392
FIGURE 17.1 Model-View-Controller pattern17.2 DYNAMIC FORM MODELS
393
A controller class is a class whose specific purpose is to encapsulate controller
code. A complex application might have multiple controllers for the different sub-components, or layers, of the application.
Qt 4 classes that are considered controller classes include 
QApplication ,
QAction , and their derived types. Code that connects signals to slots can also
be considered controller code. As we shall see, keeping controller code out ofmodel and view classes will yield additional design benefits.
17.2 Dynamic Form Models
A collection of questions and blanks to fill in the answers is called a form . Quite
common in GUI applications, a form is used whenever a series of questions needsto be asked of the user. There are many ways to design and implement forms. Inthis section, we will make a model for the form, and then a view for it.
EXAMPLE 17.1 src/libs/forms/testform.cpp
[ . . . . ]
class BridgeKeeper : public FormModel {
public:
BridgeKeeper();
};Controller
View1 View2
ModelController establishes
connections betweenmodel and views.
Views display
data from modelor accept changesfrom user.
Model emits signals
as needed
continuedezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 393
BridgeKeeper::BridgeKeeper() {
FormFactory ff;*this << ff.newQuestion("name", "What is your name?");*this << ff.newQuestion("quest", "What is your quest?");QStringList colors;colors << "red" << "blue" << "green" << "orange";*this << ff.newQuestion("color", 
"What is your favorite color?",colors);
*this << ff.newQuestion("speed", 
"What is the mean air speed of an unladen swallow?",
QVariant::Int); 
}
The model created in Example 17.1 represents a form containing questions of
different“types,”where the first two are simple string inputs, but the last two are con-strained to a set of possible values. The
main program creates a model and a view,
and hooks them together. In Example 17.2, you can think of main as the controller.
EXAMPLE 17.2 src/libs/forms/testform.cpp
[ . . . . ]
int main(int argc, char** argv) {
QApplication a(argc, argv);QMainWindow mw;BridgeKeeper keeper;qDebug() << keeper.toString();FormDialog fv(&keeper);fv.setWindowTitle("I am the keeper of the Bridge of Death.");mw.setCentralWidget(&fv);mw.setVisible(true);int retval =  a.exec();QVariant speed = keeper.property("speed");QVariant color = keeper.property("color");QVariant quest = keeper.property("quest");QVariant name = keeper.property("name");    if (color.toString() == "blue") {
qDebug() << "no, I mean red! aaaaaaahhhhhhhhhhh!" ;
}else {
qDebug() << "My name is " << name.toString() 
<< ", and I " << quest.toString() << ". My favorite color is " << color.toString()<< ". The speed is " << speed.toInt();
}
return retval;
}CHAPTER 17: MODELS AND VIEWS
394ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 394
In Example 17.2, you can think of main as the controller.
The FormDialog below is automatically generated from the model above,
even though it does not depend on the specific model.17.2 DYNAMIC FORM MODELS
395
The dialog embeds a FormView , which contains the actual input widgets.
1. View classes access Question s only through the public polymorphic
interface.
2. Model classes emit signals to communicate information to views, instead
of invoking objects directly through references or pointers passed aroundas function parameters.
3. The code that does depend on both mo del and view (or on specific types
of
Question ) is kept separate as controller code.
A FormModel wraps a collection of Question s, which are model classes. A
FormView wraps a collection of InputField s, which are views (because they
derive from QWidget ), but encapsulate complex input widgets.
In the Doxygen collaboration diagram in Figure 17.2, there is a 1:1 correspon-
dence between InputField and Question , but the classes are strictly decoupled .1
AQuestion models (ideally) all of the information needed by FormFactory
to create an appropriate InputField .AFormView is a grouping of input widgets.
An input widget serves as a proxy, or delegate, between Qt input widgets and
Question -derived models.
1“Strictly decoupled” means that they know nothing about each other.ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 395
The Strategy pattern encapsulates each member of a family of algorithms
so that they can be selected independently by clients. Each encapsulatedalgorithm is called a strategy .
Figure 17.3 shows that an InputField can be a variety of things. Because Qt
input widgets2do not have a common QVariant -based interface for getting and
setting data, the InputField serves as an adaptor , that provides a property-like
interface.InputField uses the Strategy pattern to organize the getters and set-
ters for different types as virtual functions.
With a hierarchy of views, we end up with an extensible framework for adding
other kinds of InputField s later.
EXERCISES: DYNAMIC FORM MODELS
1.Add a DoubleInputField class, derived from InputField , and update the
FormFactory to return it as needed.
2.Write a testcase with a QVariant Question in it, and verify that a
QDoubleSpinBox shows up.CHAPTER 17: MODELS AND VIEWS
396
2QLineEdit ,QComboBox ,QDateEdit ,QSpinBoxQList< In putField*>QList< Quest ion*>
QSplitter InputList
mSplitter mFieldsm M o delmQuest ions
mLa belLayout 
mEditLayout
FormViewQVBoxLa yout FormMo delQObject Quest ionList
FIGURE 17.2 Formsezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 396
17.2.1 Form Models
In addition to different kinds of input widgets (for the different data types), there
can also be different kinds of Question models for getting/setting the data in dif-
ferent places.
The FormModel and the Question classes, shown in Figure 17.4, are two
adjoining layers in the model. Because they are models, they are meant to be verysimple classes, holding data but containing no GUI or controller code.
FormModel provides a simple operation, setValues() , for updating all of
its Question ’s values, shown in Example 17.3.
EXAMPLE 17.3 src/libs/forms/formmodel.cpp
[ . . . . ]
bool FormModel::setValues(QList<QVariant> list) {
bool retval = true;for (int i=0; i<list.size(); ++i) {
QString str = list.at(i).toString();Question* q = m_Questions.at(i);retval = q->setValue(str) && retval;
}emit modelChanged();return retval;
}17.2 DYNAMIC FORM MODELS
397
InputField
+ InputField(name : QSt ring, parent : QO bject*) 
+ value() : QVariant 
+ widget() : QWidget* 
+ setView(newValue : QVariant) 
+ ne wValue(ne wString : const QSt ring&) 
+ clearView() 
# valueChange d(val : QVa riant)
StringInputField
- qle : QL ineEdit*IntInputField
- qspin : QS pinBox*
ChoiceInputField
- qcb : QCom boBox*DateInputField
- qde : QDateT imeE dit*
FIGURE 17.3 Input fieldsezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 397
Question encapsulates all the things that are needed for an interaction with a
user, including the type and value of the expected answer. The constructors,declared in Example 17.4, are 
protected because we will use a factory to create
Question objects.
EXAMPLE 17.4 src/libs/forms/question.h
[ . . . . ]
class Question : public QObject {
Q_OBJECT
protected:
Question(QString name, QString label = QString(),
QVariant::Type type=QVariant::String);
Question(QString name, QString label,
QStringList choices, bool open=false);
Question() {}
public:
virtual Qt::ItemFlags flags() const;virtual QString toString() const;virtual QVariant value() const;CHAPTER 17: MODELS AND VIEWS
398
FormMo del
 # m_Quest ions : Quest ionList
+ Fo rmMo del(name : QSt ring)
+ keys() : QSt ringList
+ toSt ring() : QSt ring
+ operator <<(q : Quest ion*) : Fo rmMo del&
+ quest ions() : const Quest ionList&
+ property(name : QSt ring) : QVa riant
+ setVa lues(v list : QL ist) : bool
+ setP roperty(name : QSt ring, va lue : QVa riant) : bool
+ quest ion(name : QSt ring) : Quest ion*
+ insert(position : int, q : Quest ion*)
+ remove(name : QSt ring) : bool
# mo delChange d()
Ques tion
- m_La bel : QSt ring 
- m_Va lue : QVa riant 
- m_C hoices : QSt ringList 
- m_T ype : QVa riant, T ype+ m_Quest ions *
FIGURE 17.4 FormModel and Questionezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 398
virtual QVariant::Type type() const ;
QStringList choices() const ;QString label() const {return m_Label;}virtual ~Question() {}
public slots:
virtual bool setValue(QVariant newValue);
signals:
void valueChanged();
protected:
void setType(QVariant::Type type) ;void setLabel(QString label) ;
private:       
QString m_Label;QVariant m_Value;QStringList m_Choices;QVariant::Type m_Type;
};
[ . . . . ]
When we need a Question instance,FormFactory creates it by using one of the
protected constructors, defined in Example 17.5.
EXAMPLE 17.5 src/libs/forms/question.cpp17.2 DYNAMIC FORM MODELS
399
[ . . . . ]
Question::Question( QString name, QString label, QVariant::Type t):
m_Label(label) {
setObjectName(name);if (m_Label == QString())
m_Label = name;   
m_Value = QVariant(t);m_Type = m_Value.type();
}
Question::Question(  QString name, QString label, QStringList choices,
bool) : m_Label(label), m_Choices(choices) {
setObjectName(name);if (m_Label == QString())
m_Label = name;
m_Type = QVariant::StringList;
}ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 399
The view classes, shown in Figure 17.5, are separated into three layers.
1.FormDialog includes the buttons and actions plus some management/
controller code.
2.FormView is solely responsible for holding layouts for labels and input
widgets.
3.InputField is responsible for a single input widget.CHAPTER 17: MODELS AND VIEWS
400
FIGURE 17.5 Form viewsFormDialog
 - m_Model : FormModel *
 - m_View : FormView *
 - m_ Layout : QVBoxLayout * 
 - m_O kAction : QAction *
 - m_CancelAction : QAction *
 - m_CloseAfterAction : bool
+ Form Dialog(model : FormModel *, parent : QWidget *)
+ ~ Form Dialog()
+ setModel(mod : FormModel *)
+ cancel()+ apply() + setCloseAfterAction(closeAfterO k : bool) 
# questionAdded()
# Form Dialog() 
# createActions()
FormView
# m_LabelLayout : QVBoxLayout *
# m_EditLayout : QVBoxLayout * 
# m_Model : FormModel *
# m_Fields : Input List 
+ fields() : Input List
 # FormView()0..1 -m_View
InputField
+ InputField(name : QString, parent : QObject*)
+ value() : QVariant
+ widget() : QWidget*
+ setView(newValue : QVariant)
+ clearView()
+ setReadOnly( : bool)
# valueChanged(val : QVariant)*17.2.2 Form Viewsezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 400
FormView can be automatically created from a FormModel without any knowl-
edge of the individual InputField or Question types. This is thanks to the
createEditor Factory method, used in Example 17.6, which returns polymor-
phic objects.
EXAMPLE 17.6 src/libs/forms/formfactory.cpp
[ . . . . ]
FormView* FormFactory::formView(FormModel* mod) {
FormView* retval = new FormView();retval->m_Model = mod;retval->m_LabelLayout = new QVBoxLayout();retval->m_EditLayout = new QVBoxLayout();foreach (Question* q, mod->questions()) {
QLabel* label = new QLabel(q->label());retval->m_LabelLayout->addWidget(label);InputField* editField = createEditor(q);  retval->m_Fields += editField;label->setBuddy(editField->widget());retval->m_EditLayout->addWidget(editField->widget());
}QWidget* labels = new QWidget();labels->setLayout(retval->m_LabelLayout);QWidget* edits = new QWidget();edits->setLayout(retval->m_EditLayout);retval->addWidget(labels);retval->addWidget(edits);return retval;
}
This is a factory method that returns polymorphic concrete instances.
The specific InputField types that get created depend on the type of the
Question passed in, and that is determined in FormFactory , shown in
Example 17.7.
EXAMPLE 17.7 src/libs/forms/formfactory.cpp
[ . . . . ]
InputField* FormFactory::createEditor(Question* q) {
QVariant::Type type = q->type();InputField* retval = 0;switch(type) {case QVariant::StringList:
retval = new ChoiceInputField(
q->objectName(), q->choices());1117.2 DYNAMIC FORM MODELS
401
continuedezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 401
break;
case QVariant::String:
retval = new StringInputField(q->objectName());break;
case QVariant::Int:
retval =  new IntInputField(q->objectName());break;
case Variant::Dir:
retval = new DirInputField(q->objectName());break;
default:
retval=new StringInputField(q->objectName(), 0);qDebug() << QString("Unknown property type %1").arg(type);
}if (q->flags() != Qt::ItemIsEditable) {
retval->setReadOnly(true);
}CHAPTER 17: MODELS AND VIEWS
402
return retval;
}
In Example 17.7, notice the switch statement, which is normally to be avoided in
object-oriented code. We have it here to map polymorphically from the
QVariant::Type (an enumerated value) to an InputField class. This makes
it possible for us to use the Strategy pattern on InputField (which provides
input and output in various ways, on various types).
By default, createEditor() returns a StringInputField , shown in
Example 17.8. It has a simple QLineEdit as its input widget.
EXAMPLE 17.8 src/libs/forms/inputfields.h
[ . . . . ]
class StringInputField : public InputField {
Q_OBJECT
public:
StringInputField(QString name, QWidget* parent = 0);QVariant value() const ;QWidget* widget() const ;
public slots:
void setReadOnly(bool v);void setView(QVariant qv);void clearView();
protected:
QLineEdit *qle;
};ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 402
17.2.3 Unforseen Types
It is possible there will be other “types” of data that correspond to different kinds
of input widgets, but are not among those defined in QVariant . In Example 17.9,
we introduce user-defined enumerated values above QVariant (127) that will
not share a value with those already predefined in QVariant::Type .
EXAMPLE 17.9 src/libs/dataobjects/variant.h
#ifndef VARIANT_H
#define VARIANT_H#include <QVariant>
namespace Variant {
const QVariant::Type File = static_cast<QVariant::Type(128);const QVariant::Type Dir = static_cast<QVariant::Type(129);
}
#endif
A directory can be encoded and decoded as a QString quite naturally, but a
Question with a Variant::Directory as its type gives a hint to the
FormFactory that the input widget it creates should be a QFileDialog that is
already in “directory-chooser” mode.
EXAMPLE 17.10 src/libs/forms/dirinputfield.h
[ . . . . ]
class DirInputField : public StringInputField {
Q_OBJECT
public:
DirInputField(QString name);QWidget* widget() const;void clearView();static void setFileDialog(QFileDialog* fd) {
sFileDialog = fd;
}
public slots:
void browse();private:QHBoxLayout *m_Layout;QPushButton *m_Button;QWidget *m_Widget;static QFileDialog* sFileDialog;
};
[ . . . . ]17.2 DYNAMIC FORM MODELS
403ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 403
TheDirInputField , defined in Example 17.10, extends the StringInputField
and still has the QLineEdit for accepting a string from the user. In addition, there is
aBrowse button, which when clicked will pop up a QFileDialog pre-set to accept
only a directory as a valid selection.
17.2.4 Controlling Actions
In this section, we discuss issues of synchronizing data between the model and the
view. Since these methods depend on both model and view, we are going to isolatethem from both, in their own controller classes. In Example 17.11, we derived twocustom 
QAction classes, each responsible for synchronizing in one direction.
EXAMPLE 17.11 src/libs/forms/formactions.h
[ . . . . ]
class OkAction : public QAction {
Q_OBJECT
public:
OkAction(FormModel* model, FormView* view);
public slots:
void ok();
private:
FormModel *m_Model;FormView *m_View;
};
class CancelAction : public QAction {
Q_OBJECT
public slots:
void cancel();
[ . . . . ]
OkAction (or apply) should send the data from the view to the model.
CancelAction , in the case where the dialog is not to be closed afterwards,
should do the opposite (send the data from the model back to the view, to restoreold or set default values). Their definitions are in Example 17.12.
EXAMPLE 17.12 src/libs/forms/formactions.cpp
#include <QDebug>
#include "formactions.h"#include "formmodel.h"#include "formview.h"#include "inputfield.h"#include "question.h"CHAPTER 17: MODELS AND VIEWS
404ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 404
OkAction::OkAction(FormModel* model, FormView* view) :
QAction( tr("&Ok"), view), m_Model(model), m_View(view) {connect (this, SIGNAL(triggered()), this, SLOT(ok()));
}
void OkAction::ok() {
qDebug() << "OK()" << endl;QList<QVariant> values;InputList fields = m_View->fields();foreach (InputField* field, fields) {
QVariant v = field->value();qDebug() << "submitting value: " << v.toString();values += v;
}m_Model->setValues(values);qDebug() << m_Model->toString();
}
CancelAction::CancelAction(FormModel* model, FormView* view) :
QAction( tr("&Cancel"), view), m_Model(model), m_View(view) {connect (this, SIGNAL(triggered()), this, SLOT(cancel()));
}
void CancelAction::cancel() {
qDebug() << "Cancel() " << endl;QList<Question*> qlist = m_Model->questions();InputList fields = m_View->fields();for (int i=qlist.size()-1; i>-1; --i) {
Question* q = qlist.at(i);InputField* f = fields.at(i);qDebug() << QString(" name: %1  val: %2")
.arg(q->objectName()).arg(q->value().toString());
f->setView(q->value());
}
}
These actions are in fact delegates , and perform a similar function to Qt’s
QItemDelegate .
17.2.5 DataObject Form Model
In Example 17.1, we extended FormModel , and in the constructor we created and
added Question objects to compose a custom form. The FormModel itself can
be used in other ways, including those listed below.
1. Creating a FormModel from a DataObject (one Question per 
property)
2. Connecting fields of a FormModel to QSettings values, to give 
persistence17.2 DYNAMIC FORM MODELS
405ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 405
PropQuestion , shown in Figure 17.6, serves as a proxy or delegate between a
DataObject property and an InputField widget. We see this in Example 17.13:
Most of the methods simply pass on the request to the underlying DataObject ,
mDest .
EXAMPLE 17.13 src/libs/forms/propquestion.cpp
#include "propquestion.h"
#include <QMetaProperty>#include <QVariant>
PropQuestion::PropQuestion(QString name, DataObject* dest):
m_Dest(dest) {setObjectName(name);CHAPTER 17: MODELS AND VIEWS
406
3This is how Designer recreates its GUIs.
4Basically, this is similar to importing and exporting in XML, except that the tags we use, < form >
and <input >, are specified by the W3C [w3c]. By using this format, we can create XHTML forms
and load them in as FormModels.3. Importing and exporting in XML3
4. Importing and exporting in HTML4
5. Can you think of others?
We wish to create a FormModel from a DataObject , so this means that another
function goes into the ModelFactory .W e  e x t e n d e d  Question , the basic
FormModel building block, so that it would get/set values from/to a DataObject
property instead of its own m_Value .
QObject
QString
QStringListQVariant Question
DataObjectPropQuestion
+m_Dest+m_Choices
+m_Prop+m_Label
+m_Value
0..1QMetaProperty
FIGURE 17.6 Rephrasing the questionezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 406
EXAMPLE 17.14 src/libs/forms/testform2.cpp
#include <QMainWindow>
#include <QApplication>#include "formfactory.h"#include "formdialog.h"#include "formmodel.h"#include "filetagger.h"
int main(int argc, char** argv) {
QApplication a(argc, argv);QMainWindow mw;17.2 DYNAMIC FORM MODELS
407
m_Prop = m_Dest->metaProperty(name);
setLabel(name);setType(m_Prop.type());
}
Qt::ItemFlags PropQuestion::flags() const {
if (m_Prop.isWritable()) return Qt::ItemIsEditable;else return Qt::ItemIsSelectable;
}
QVariant PropQuestion::value() const {
return m_Dest->property(objectName());
}
bool PropQuestion::setValue(QVariant newValue) {
return m_Dest->setProperty(objectName(), newValue);
}
Example 17.14 uses the DataObject model applied to the FileTagger class to
auto-generate a form, which looks like Figure 17.7.
FIGURE 17.7 Auto-generated FileTagger form
continuedezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 407
FileTagger ft;
FormModel* mod = FormFactory::newForm(&ft);FormDialog dialog(mod);mw.setCentralWidget(&dialog);mw.setVisible(true);return a.exec();
}
The newForm Factory method defined in Example 17.15 simply returns a
PropQuestion instead of a Question when it is creating the FormModel from
a DataObject .
EXAMPLE 17.15 src/libs/forms/formfactory.cpp
[ . . . . ]
FormModel* FormFactory::newForm(DataObject* dobj) {
QStringList props = dobj->propertyNames();FormModel *mod = new FormModel(dobj->className());foreach (QString prop, props) {
if (prop == "objectName")
continue;
PropQuestion *pq = new PropQuestion(prop, dobj);*mod << pq;
}return mod;
}
EXERCISES: DA TAOBJECT FORM MODEL
1.Example 17.16 is an XHTML [w3c] fragment that contains three different kinds
of input widgets and roughly represents the form we’ve seen earlier.
EXAMPLE 17.16 src/modelview/html/bridgekeeper.html
<form>
<title> I am the keeper of the bridge of death </title><p> Answer these questions three and you can proceed over thebridge. </p><label for="name">What is your name? </label><input name="name" type="text">
<label for="quest">What is your quest? </label>
<input name="quest" type="text" />
<label for="color">What is your favorite color? </label>
<select name="color">
<option value="blue">blue</option><option value="green">green</option>CHAPTER 17: MODELS AND VIEWS
408ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 408
<option value="orange">orange</option>
<option value="burgundy">burgundy</option><option value="crimson">crimson</option>
</select>
<input type="submit" name="ok" value="ok" />
<input type="submit" name="cancel" value="cancel" />
</form>
It is possible to preview it in a browser by opening it as a file. It doesn’t look
fancy without any css styling, but you can use it as a sanity check for your files.
Write a FormReader class that can read an XML file of the above format.
(Do not worry about handling XHTML elements or formats that are not shownin Example 17.16.)
2.Write a 
FormWriter class that can write a FormModel to an XML file in the
same format.
3.Write a Mad Libs game that asks the user for a bunch of nouns, verbs, adjectives,
and adverbs such that when the form is submitted, it sticks the strings into aparagraph and shows the result to the user. The passage of text should be atleast two paragraphs long, and contain at least ten blanks to be filled in.
17.3 Qt 4 Models and Views
Qt 4 offers general-purpose view classes for the most common types of views: lists,
trees, and tables. This includes abstract and concrete data models that can beextended and customized to hold different kinds of data.
Figure 17.8 shows the four main types of classes in the Qt 4 model-view
framework. Each class has a specific role.
1. Item models are objects for repr esenting a data model for multiple items.
Item models store the actual data that is to be viewed/manipulated.
2. Views are objects for acquiring, changing, and displaying the data. Each
view holds a pointer to a model. View classes make frequent calls to itemmodel methods to get and set data.
3. Selection models are objects that d escribe which items in the model are
selected in the view. Each view has a selection model.
4.
QModelIndex acts like a cursor, or a smart pointer, providing a uniform
way to iterate through list, tree, or table items inside the model.17.3 QT 4 MODELS AND VIEWS
409ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 409
The code fragment below shows how to create and connect a view to a model.
class MyTableModel : public QDefaultTableModel   {...};
// ...myModel = new MyTableModel();myView = new QTableView();myView->setModel(myModel);
After setModel() is called, the view should automatically update itself whenever
the model changes (assuming the mode l is written properly).
As we write the implementation of MyTableModel , we are once again imple-
menting a passive interface , and there is an inversion of control. All the methods
we override in MyTableModel are called from QTableView or QModelIndex .CHAPTER 17: MODELS AND VIEWS
410
QAbs tractItemMo del
Cursor or sma rt-pointer to mo del
QAbs tractItemV iew
QListView QTreeViewQItemSe lectionModel
Which items a re selected in the viewAbstract types for displaying in the view
Different ways to v iew the mo delConc rete mo del for relational database ta bles
Conc rete mo del for items in a tree/ta bleQStandardItemMo delconc rete list mo delQStringListModelQAbs tractListModel QAbs tractTableModel
QSqlRelationalTableModel
QTab leViewQMo delIndex
FIGURE 17.8 Qt 4 Model/View classesezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 410
ABSTRACT OR DEFAUL T? When extending QAbstractxxxModel ,
derived classes need to override allof the pure virtual methods and define
a full implementation for the model. In contrast, by extending one of the
QDefaultxxxModel classes, a derived class inherits a default imple-
mentation that does not require overrides of all methods. Each method
has an empty stub in the default base class.
Views
A View class encapsulates the components of a graphical user interface that
accesses the data in a model. Views come in a variety of different sizes and shapes.In general, they are usually
■Lists in various arrangements
■Tables, perhaps with interactive elements
■Trees representing objects in a parent-child hierarchy
■Graphs and charts
Model Index
The QModelIndex class provides a generic access system that works for all classes
derived from QAbstractItemModel . This system treats model data as if it were
arranged in a rectangular array with row and column indices, regardless of whatunderlying data structure actually holds the data.
QModelIndex objects, created by the model, can be used by model, view, or
delegate code to locate particular items in the data model. QModelIndex objects
have short life spans and can become invalid shortly after being created, so theyshould be used immediately and then discarded.
QModelIndex::isValid() should be called before using a QModelIndex
object that has existed for more than a few operations. QPersistentModelIndex
objects have longer life spans but still should be checked with isValid() before
being used.
17.4 Table Models
It would be useful to have an editable QTableView for viewing and editing a col-
lection of DataObjects. For this, we extend and customize the QAbstractTable
Model . See Example 17.17.17.4 TABLE MODELS
411ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 411
EXAMPLE 17.17 src/libs/dataobjects/dataobjecttablemodel.h
[ . . . . ]
class DataObjectTableModel : public QAbstractTableModel {
Q_OBJECT
public:
DataObjectTableModel(DataObject* headerModel = 0);virtual DataObject* record(int rowNum) const ;virtual bool insertRecord(DataObject* newRecord, 
int position = -1,
const QModelIndex& = QModelIndex());
QStringList toStringList() const;QString toString() const;virtual int fieldIndex(QString fieldName) const;virtual ~DataObjectTableModel();
[ . . . . ]
public slots:
void reset();void checkDirty();
protected slots: 
void changeProperty(const QString&, const QVariant&);
protected:
QList<DataObject*> m_Data;QStringList m_Headers;DataObject* m_Original;QTimer m_Timer;bool m_Dirty;void extractHeaders(DataObject* hmodel);
public:
DataObjectTableModel& operator<<(DataObject* newObj) {
insertRecord(newObj);return *this;
}
};CHAPTER 17: MODELS AND VIEWS
412
The name, DataObjectTableModel , is quite self-descriptive: a table of
DataObjects. Using this class to group DataObjects makes creating editable viewsreasonably simple. Example 17.18 shows the client code that produced the screen-shot above.ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 412
EXAMPLE 17.18 src/modelview/tablemodel/tablemodel.cpp
#include "dataobjecttablemodel.h"
#include "customerfactory.h"#include "country.h"
DataObjectTableModel* model() {
CustomerFactory* fac = CustomerFactory::instance();17.4 TABLE MODELS
413
continuedCustomer* cust1 = fac->newCustomer("luke skywalker", Country::USA);
DataObjectTableModel* retval = newDataObjectTableModel(cust1);  cust1->setId("14123");*retval << cust1;          *retval << fac->newCustomer("Ben Kenobi", Country::Canada);*retval << fac->newCustomer("Princess Leia", Country::USA);    return retval;
}
#include <QTableView>
#include <QApplication>#include <QMainWindow>#include <QDebug>
int main(int argc, char** argv) {
QApplication app(argc, argv);DataObjectTableModel *mod = model();QMainWindow mainwin;QTableView view ;view.setModel(mod);mainwin.setCentralWidget(&view);mainwin.setVisible(true);int retval =  app.exec();qDebug() << "Application Exited. " << endl;qDebug() << mod->toString() << endl;delete mod;return retval;
}21
header model
Insert row into table.
In the public interface, we want convenient functions for operating on rows as
DataObject records. See Example 17.19.
EXAMPLE 17.19 src/libs/dataobjects/dataobjecttablemodel.cpp
[ . . . . ]
bool DataObjectTableModel::
insertRecord(DataObject* newRow, int position, 
const QModelIndex &parent) {21ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 413
if (position==-1)
position=rowCount()-1;
connect (newRow, SIGNAL(propertyChanged(const QString&,
const QVariant&)),
this, SLOT(changeProperty(const QString&,
const QVariant&)));
beginInsertRows(parent, position, position);m_Data.insert(position, newRow);endInsertRows();return true;
}
DataObject* DataObjectTableModel::
record(int rowNum) const {
return m_Data.at(rowNum);
}
But How Does It Work?
QAbstractTableModel has a series of pure virtual functions, declared in
Example 17.20, which must be overridden, because they are invoked by
QTableView to get and set data.
EXAMPLE 17.20 src/libs/dataobjects/dataobjecttablemodel.h
[ . . . . ]
/* Methods which are required to be overridden
because of QAbstractTableModel */
int rowCount(const QModelIndex& parent = QModelIndex()) const;
int columnCount(const QModelIndex& parent = QModelIndex())
const;
QVariant data(const QModelIndex& index, int role) const;QVariant headerData(int section, Qt::Orientation orientation,
int role = DisplayRole) const;
ItemFlags flags(const QModelIndex &index) const;bool setData(const QModelIndex &index, const QVariant &value,
int role = EditRole);
bool insertRows(int position, int rows,
const QModelIndex &index = QModelIndex());
bool removeRows(int position, int rows,
const QModelIndex &index = QModelIndex());
Example 17.21 shows the methods used to get data in and out of the model.CHAPTER 17: MODELS AND VIEWS
414ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 414
EXAMPLE 17.21 src/libs/dataobjects/dataobjecttablemodel.cpp
[ . . . . ]
QVariant DataObjectTableModel::
data(const QModelIndex &index, int role) const {
if (!index.isValid())
return QVariant();
if (role == DisplayRole) {
int row(index.row()), col(index.column());
DataObject* lineItem(m_Data.at(row));
return lineItem->property(m_Headers.at(col));
} else
return QVariant();
}
bool DataObjectTableModel::
setData(const QModelIndex &index, const QVariant &value,
int role) {
bool changed=false;if (index.isValid() && role == EditRole) {
int row(index.row()), col(index.column());17.4 TABLE MODELS
415
return changed;
}
This is a mapping layer from objects to tables. Since the tables need to show
header data, the table model has one DataObject , designated the header model ,
which it uses to obtain headers. Example 17.22 defines headerData , the method
that table models call, which we can override to provide the proper header names.
EXAMPLE 17.22 src/libs/dataobjects/dataobjecttablemodel.cpp
[ . . . . ]
QVariant DataObjectTableModel::
headerData(int section, Qt::Orientation orientation,
int role) const {
if (role != DisplayRole)
return QVariant();
if(orientation == Qt::Vertical)
return QVariant(section);
if (m_Headers.size() ==0)
return QVariant();
return m_Headers.at(section);
}DataObject* lineItem(m_Data.at(row));
changed = lineItem->setProperty(m_Headers.at(col), value);if(changed)
emit dataChanged(index, index);
}
continuedezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 415
CHAPTER 17: MODELS AND VIEWS
416
int DataObjectTableModel::rowCount(const QModelIndex&) const  {
return m_Data.count();
}
int DataObjectTableModel::
columnCount(const QModelIndex &parent) const {
Q_UNUSED(parent);return m_Headers.size();
}
The other methods in the abstract interface, shown in Example 17.23, tell views
which items are editable ( flags() ), or allow client code to insert and remove rows.
EXAMPLE 17.23 src/libs/dataobjects/dataobjecttablemodel.cpp
[ . . . . ]
ItemFlags DataObjectTableModel::
flags(const QModelIndex &index) const {
if (!index.isValid())
return ItemIsEnabled;
// TODO - check the metaProperty to see if it is read/writereturn QAbstractItemModel::flags(index) | ItemIsEditable;
}
void DataObjectTableModel::
reset() {
QModelIndex br = index(rowCount()-1, columnCount()-1);QModelIndex tl = index(0,0);emit dataChanged(tl, br);m_Dirty = false;
}
bool DataObjectTableModel::
insertRows(int position, int rows, const QModelIndex &parent) {
beginInsertRows(parent, position, position+rows-1);for (int row = 0; row < rows; ++row) {
DataObject* dobj = m_Original->clone();m_Data.insert(position, dobj);
}endInsertRows();return true;
}
bool DataObjectTableModel::
removeRows(int position, int rows, const QModelIndex& parent) {
for (int row = 0; row < rows; ++row) {
delete m_Data.at(position);m_Data.removeAt(position);
}QModelIndex topLeft(index(position, 0, parent));ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 416
17.5 TREE MODELS
417
QModelIndex bottomRight(index(position + 1, columnCount(), parent));
emit dataChanged(topLeft, bottomRight);return true;
continued}
17.5 Tree Models
T o represent data for a hierarchy of widgets (parents and children), Qt offers two
choices of models:
1.QAbstractItemModel is a general-purpose, but very complex class, that
can be used with QTreeView as well asQListView andQTableView .
2.QTreeWidgetItem is a simpler model, specifically for use with
QTreeWidget .
The QTreeWidgetItem class is a tree node that can be instantiated or extended.
The widget items need to be connected together in a tree-like fashion, similar to
QObject children (Section 9.2) or QDomNodes (Section 14.3). In fact,
QTreeWidgetItem is another implementation of the Composite pattern.
EXAMPLE 17.24 src/widgets/trees/treedemo.cpp
#include <QTreeWidget>
#include <QTreeWidgetItem>#include <QApplication>
QTreeWidgetItem *item(QString name, QTreeWidgetItem* parent=0) {
QTreeWidgetItem *retval = new QTreeWidgetItem(parent);retval->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEditable
| Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled |Qt::ItemIsEnabled);
retval->setText(0, name);return retval;
}
int main(int argc, char** argv) {
QApplication app(argc, argv);QTreeWidgetItem *root = item("root");QTreeWidgetItem *colors = item("colors", root);item("blue", colors);item("red", colors);item("orange", colors);
QTreeWidgetItem *sports = item("sports", root);
item("baseball", sports);item("hockey", sports);item("curling", sports);
QTreeWidgetItem *food = item("food", root);
item("rutabega", food);ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 417
item("macademia nuts", food);
item("bok-choy", food);
QTreeWidget *tree = new QTreeWidget();
tree->addTopLevelItem(root);tree->setColumnCount(1);tree->setVisible(true);return app.exec();
}
Example 17.24 is a simple main program that creates a tree model and a view for
it. When you run it, you should see a tree widget that looks like Figure 17.9.CHAPTER 17: MODELS AND VIEWS
418
FIGURE 17.9 Tree Widget
Because the items are editable, you can edit them with the F2 key. Y ou might notice
that other familiar keyboard shortcuts (cut, copy, paste, ctrl+cursor keys, etc.) fromyour window environment will also work inside these list widgets and text areas.
17.5.1 Extended Tree Widget Items 
This section discusses the design behind the qjots application. qjots has a
TreeView on the left, and it allows you to organize your notes and Web bookmarksin a tree-like fashion. The figure that follows demonstrates this.
ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 418
The main idea behind this application is that whenever an item is selected in the
tree on the left, the appropriate view should be shown on the right. This is actu-ally a typical feature for most GUI applications.
The 
QTreeWidgetItem is a natural base class to extend for abstract data
types. However, it is not a QObject , so it does not support signals or slots (which
we need on this model). Therefore, we will use multiple inheritance (Section 23.3)to bring both classes together. Notice in Example 17.25 that this class is abstract,because of a pure 
virtual function. We plan to extend this class further for the
specific types of data to display.
EXAMPLE 17.25 src/modelview/qjots/item.h
[ . . . . ]
class Item : public DataObject, public QTreeWidgetItem {
Q_OBJECT
Q_PROPERTY( QString Name READ name WRITE setName );
public:
Item();virtual ~Item() {}QTreeWidgetItem* parent() const {
return QTreeWidgetItem::parent();
}virtual void setName(QString name) ;virtual QDomElement element( QDomDocument doc)=0;virtual QWidget* detailView() =0;virtual QString name() const ;
};[ . . . . ]
Required to eliminate the conflict between the two base class versions.
Notice that parent() must be defined in Item to eliminate the conflict between
the two base class definitions. What is nice about extending the Item class is thatyou can initialize each instance with default flags, like we see in Example 17.26.
EXAMPLE 17.26 src/modelview/qjots/item.cpp
[ . . . . ]
Item::Item() {
setFlags(Qt::ItemIsSelectable | Qt::ItemIsEditable
| Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled| Qt::ItemIsEnabled );
}
[ . . . . ]1117.5 TREE MODELS
419ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 419
CHAPTER 17: MODELS AND VIEWS
420
DataO bject
Folder Note Project Bookma rkQTreeWidgetItem
ItemEXERCISES: TREE MODELS
Your assignment is to write a qjots application that permits the user to create,
select, view, and edit at least three different “kinds” of items in a TreeWidget. If youwant, you can use bookmarks, notes, and folders, as shown in the diagram below.Alternately, you can make up your own data model or adapt one from a previousassignment.
1.Use a 
QSplitter to separate the left and the right sides of your
QMainWindow .
2.Write serializers so that the entire tree can be loaded and saved to disk.
3.Allow the user to select items in a tree on the left, so that they are visible/
editable in a “detailed view” on the right side.
4.Allow the user to add and delete items from the tree.qjots Data Typesezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 420
REVIEW QUESTIONS
421
REVIEW QUESTIONS
1. What is controller code? Which Qt classes are controller classes?
2. What pattern(s) is/are used in the design of InputField ?
3. Because there is a 1:1 correspondence between InputField and
Question , we could easily combine the two classes into one. What
would you call that class? Explain the advantages or disadvantages of thisdesign.
4. How do you determine what item(s) is/are selected in a 
QListView ?
5. If we wanted to iterate through items in an QAbstractItemModel ,
what would be a good class to use?
6. There are two distinct model-view class pairs for storing and displaying
tree-like data. What are they called? Why would you use one versus theother?ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 421
ezus_138004_ch17.qxd  8/3/06  4:30 PM  Page 422
42318.1 Introduction to MySQL . . . . . . . . . . . . . . 424
18.2 Queries and Result Sets . . . . . . . . . . . . . 42718.3 Database Models . . . . . . . . . . . . . . . . . . . 42918CHAPTER 18
Qt SQL Classes
This chapter gives a general introduction to the capa-bilities of Qt’s SQL classes, using MySQL as an exam-ple back end.ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 423
Qt 4 provides a platform-neutral database interface similar to JDBC but without
the annoying mandatory exception-handling code. Y ou can use Qt to connect to avariety of different SQL databases, including Oracle, PostgreSQL, and SybaseSQL.In the examples that follow, we use MySQL
1because it
1. Is open source
2. Is available on all platforms3. Comes pre-installed on most Linux distributions4. Has excellent documentation5. Is very widely used
18.1 Introduction to MySQL
After you have installed MySQL on your system, you can create a database from its
shell by entering mysql as the “root” or admin user, as shown here.2
/home/files> mysql -u root
Welcome to the MySQL monitor.  Commands end with ; or \g.Type 'help;' or '\h' for help. Type '\c' to clear the buffer.mysql>
Next, cut and paste the following lines from Example 18.1 into the MySQL shell.
EXAMPLE 18.1 src/sql/dbcreate.sql
create database mp3db;use mp3db;
1http://dev.mysql.com/doc/
2 If you did not install MySQL yourself, then you may need to ask a system admin to create a MySQLaccount for you.grant all on mp3db.* to 'mp3user'@'localhost' identified by 'mp3dbpw';
grant all on mp3db.* to mp3user identified by 'mp3dbpw';ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 424
The last two lines grant user permissions for mp3user , which is the userid we will
use for all subsequent operations on the data.
Connecting to MySQL from Qt
Connecting initially to the database requires four pieces of information: user, pass-word, database, and host, as shown in Example 18.2.
EXAMPLE 18.2 src/sql/mp3db.cpp
[ . . . . ]
bool Mp3db::connect()
{
QSqlDatabase db;db = QSqlDatabase::addDatabase("QMYSQL");db.setDatabaseName("mp3user");db.setUserName("mp3db");db.setPassword("mp3dbpw");if (!db.open()) {
qCritical("Cannot open database: %s (%s)", 
db.lastError().text().toLatin1().data(),qt_error_string().toLocal8Bit().data());
return false;
}return true;
}
After the database connection has been opened , we use a very powerful class called
QSqlQuery , which has a member function exec() that enables us to submit
standard SQL statements to the database.
Defining a Table
Each database has a collection of tables . A table is very much like an array of
struct , where each column corresponds to a data member. T o define a table, we
must describe each of the columns, which can also be thought of as fields, prop-erties, or data members.18.1 INTRODUCTION TO MYSQL
425ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 425
EXAMPLE 18.3 src/sql/filetagger.sql
CREATE TABLE FileTagger (
Artist     varchar(100),TrackTitle  varchar(100),AlbumTitle  varchar(100),TrackNumber    varchar(10),Genre         varchar(20),Comment          varchar(200),Preference     varchar(20),Filename       varchar(200),PRIMARY KEY(Filename),INDEX(Preference),INDEX(Genre)
);
Example 18.3 defines a single table in SQL called FileTagger . This table has
a structure that includes columns for each of the properties of the FileTagger
class. There are three ways you can create this table.
1. Cut and paste the contents of Example 18.3 into the mysql shell.
2. Source the file from the mysql shell.
> mysql mp3db -u mp3user -p
Enter password: XXXXX
mysql> source filetagger.sql
3. Pass it as a string to QSqlQuery::exec() .
If you don’t want to keep reentering the db/user/pw each time you run
mysql’s command line shell, you can set default values in ~/.my.cnf
(*nix) or c:\mysql\my.cnf (Win32).
[mysql]
user=mp3userpassword=mp3dbpw
database=mp3db
Inserting Rows
We wish to extract data from the ID3 tags of MP3 files and import them into the
FileTagger table. The first step is to prepare an SQL statement for inserting the
data, as shown in Example 18.4. Prepared statements are useful when we mustCHAPTER 18: QT SQL CLASSES
426ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 426
execute the same SQL statement repeatedly—the server only needs to parse the
string once.
EXAMPLE 18.4 src/sql/mp3db.cpp
[ . . . . ]
Mp3db::Mp3db()  {
connect();m_insertQuery.prepare("INSERT INTO FileTagger ("
"Artist, TrackTitle, AlbumTitle,TrackNumber, Genre, ""Comment, Preference, Filename) VALUES(?,?,?,?,?,?,?,?)");
}
We left the ?character in the parts of the SQL prepared statement where we later
wish to bind values. When we have a FileTagger object with the desired data to
import, we call addFile() , shown in Example 18.5. This method binds the val-
ues into the prepared statement.
EXAMPLE 18.5 src/sql/mp3db.cpp
[ . . . . ]
void Mp3db::addFile(FileTagger* song) {
m_insertQuery.addBindValue(song->getArtist());m_insertQuery.addBindValue(song->getTrackTitle());m_insertQuery.addBindValue(song->getAlbumTitle());m_insertQuery.addBindValue(song->getTrackNumber());m_insertQuery.addBindValue(song->getGenre());m_insertQuery.addBindValue(song->getComment());m_insertQuery.addBindValue(song->getPreference());m_insertQuery.addBindValue(song->getFilename());m_insertQuery.exec();
}
18.2 Queries and Result Sets
In Example 18.6, we define a function that queries an existing amaroK3MySQL
database. amaroK is a jukebox program for KDE that can use a variety of differentback ends for storing its Mp3 metadata. Instead of storing all tag data for a song18.2 QUERIES AND RESULT SETS
427
3http://amarok.kde.org/ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 427
in a single row, like we did in Example 18.5, amaroK spreads the tag data across
many tables with relatively fewer rows. import () will query the “ tags ” table
and, for each URL, insert a row of preference data into the “statistics” table.
EXAMPLE 18.6 src/mmjbamarok/tool.cpp
[ . . . . ]
void import() {
using namespace qstd;RatingMapper mapper;FileTagger ft;QSqlDatabase db = connect();
QSqlQuery insert;
int entries=0;insert.prepare("INSERT INTO statistics (rating, url)"
" VALUES (?, ?) "" ON DUPLICATE KEY UPDATE rating=? ");  
QSqlQuery query;query.exec("select url from tags");         while (query.next()) {                   
QString filename = query.value(0).toString();ft.setFilename(filename);QString preference = ft.getPreference();int rating = mapper.toRating(preference); if (rating == 0) continue; insert.addBindValue(rating);          insert.addBindValue(filename);insert.addBindValue(rating);if (insert.exec()) {
cerr << rating << " : " << filename << endl;entries++;
}else {
cerr << "Error inserting " << filename  << endl;
}
}cerr << "Entries imported:" << entries << endl;
}
Prepare an SQL statement that inserts a new (rating, url) record or updates the current record
(new rating) if the record is already there. Each ? is a positional parameter to which we lateraddBindValue().
Find all urls in the “tags” table. There is one for each song.Iterate through result set.
first positional parameter43214321CHAPTER 18: QT SQL CLASSES
428ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 428
In this example, a JDBC programmer might observe that QSqlQuery serves the
purpose of at least two JDBC classes. It is being used in two ways.
1. As a PreparedStatement—something to store the query, add bind values
to, etc.
2. As a cursor into the ResultSet—something to iterate through the query
results
The function iterates through all songs that are in amaroK’s library. For each song,
it extracts the preference string from a MusicMatch ID3v2 tag and, with the help
ofRatingMapper , translates the preference string into an integer number
of “stars.” Finally, the number of stars is inserted into amaroK’s statistics table,under the “rating” column.
18.3 Database Models
Qt 4 provides database model classes that extend the QAbstractTableModel
but operate on SQL data instead of objects in memory.
Figure 18.1 shows the UML design for a minimal application that displays a
view of a table. The DbViewApp is responsible for initializing and connecting the
objects in our application. We will create a QTableView of an SQL table called
“FileTagger.” Example 18.7 establishes the database connection.18.3 DATABASE MODELS
429
DbViewApp
 - model : QSqlTableModel*
 - view : QTableView*
+ createConnection() : bool
+ DbViewApp(argc : int, argv[] : char*)+ ~ DbViewApp()Controller
QTableView
QSqlTableModel
FIGURE 18.1 DbViewAppezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 429
EXAMPLE 18.7 src/modelview/database/dbviewapp.cpp
[ . . . . ]
//#include "mp3tablemodel.h"#include "dbviewapp.h"
#include <QSqlTableModel>#include <QSqlRelationalDelegate>#include <QDebug>#include <QTableView>#include <QSqlTableModel>#include <QSqlError>
bool DbViewApp::createConnection() 
{
QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");db.setDatabaseName("mp3db"); db.setUserName("mp3user");db.setPassword("mp3dbpw");  
if (!db.open()) {
qCritical("Cannot open database: %s (%s)",
db.lastError().text().toLatin1().data(),
qt_error_string().toLocal8Bit().data());
return false;
}else {
qDebug() << "Database Opened";return true;
}
}
It would be better to get this information from an encrypted file, rather than hardcoded in the
source.
By setting an EditStrategy on the model, it is possible for views of the data to
provide editable text fields. OnManualSubmit means that the changes that are
made in the view are not sent to the server until submitAll() is called.
QTableView has functions that allow us to customize the selection behavior
and mode for the view. The parameters we set, shown in Example 18.8, permitonly a single row selection.11CHAPTER 18: QT SQL CLASSES
430ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 430
EXAMPLE 18.8 src/modelview/database/dbviewapp.cpp
[ . . . . ]
DbViewApp::DbViewApp(int argc, char* argv[]) :
QApplication(argc, argv) {
createConnection();  
model = new QSqlTableModel(this);model->setTable("FileTagger");   model->setEditStrategy(QSqlTableModel::OnManualSubmit);
view = new QTableView();
view->setWindowTitle("Mp3s in the Database");view->setModel(model);      view->setSelectionBehavior(QAbstractItemView::SelectRows);view->setSelectionMode(QTableView::SingleSelection);model->select();view->setVisible(true);qDebug() << "DbViewApp()";
}
The connection must be created before any models are created.
When you run the application, it will permit viewing and editing of the
FileTagger SQL table of the mp3db database, as shown in the following
screenshot.1118.3 DATABASE MODELS
431
ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 431
CHAPTER 18: QT SQL CLASSES
432
Because there is no “submit” button, there is no way to actually change the data,
so changes to text fields will not be persistent.
There is no actual SQL code in Example 18.8, because the Qt class provides a
higher-level interface. The model class performs database reflection to determinewhich columns to display.ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 432
REVIEW QUESTIONS
433
REVIEW QUESTIONS
1.QSqlQuery is a multipurpose class. Explain some of the ways it can be
used.
2. What view classes are suitable for displaying a database model?ezus_138004_ch18.qxd  8/4/06  10:06 AM  Page 433
PART III 
C++ Language
Referenceezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 434
Chapter 19. Types and Expressions . . . . . . . . . 437
Chapter 20. Scope and Storage Class . . . . . . . . 463Chapter 21. Statements and Control 
Structures . . . . . . . . . . . . . . . . . . . . . 479
Chapter 22. Memory Access . . . . . . . . . . . . . . . . 503Chapter 23. Inheritance in Detail . . . . . . . . . . . 523Chapter 24. Miscellaneous Topics . . . . . . . . . . . 541
435ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 435
ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 436
43719CHAPTER 19
Types and Expressions
This chapter seeks to provide a deeper understand-
ing of C++’s strong typing system, and shows howexpressions are evaluated and converted.
19.1 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . 438
19.2 Evaluation of Logical Expressions . . . . 44319.3 Enumerations . . . . . . . . . . . . . . . . . . . . . . 44319.4 Signed and Unsigned 
Integral Types . . . . . . . . . . . . . . . . . . . . . . 445
19.5 Standard Expression Conversions . . . . 44719.6 Explicit Conversions. . . . . . . . . . . . . . . . . 44919.7 Safer Typecasting Using 
ANSI C++ Typecasts . . . . . . . . . . . . . . . . . 450
19.8 Run-Time Type 
Identification (RTTI) . . . . . . . . . . . . . . . . . 454
19.9 Member Selection Operators . . . . . . . . 457ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 437
Here we formally define some terms that we have been using. Operators are
special kinds of functions that perfor m calculations on operands and return
results. Operands are the arguments supplied to the operator.
Operators can be thought of as ordinary functions, except that it is possible
to call them using operator symbols (e.g., +,-,*,/, etc.) in addition to the longer
function-call syntax.
An expression consists of a single operand, multiple operands with operators
interspersed, or functions with arguments. Each expression has a type and a value.The value is obtained by applying the definitions of the operators and/or functionsto the operands (and/or arguments).
19.1 Operators
Operators fall into broad classifications according to their primary use.
Assignment operators =,+=,*=,...
Arithmetic operators +,-,*,/,%
Relational operators <,<=,>,>=,==,!=
Logical operators &&,||,!
Bitwise operators &,|,^,~,<<,>>
Memory management operators new,delete ,sizeof
Pointer and access operators *,&,.,->,[]
Scope resolution operators ::
Miscellaneous operators conditional ( ?:), comma ( ,)
Operators have predefined meanings for built-in types, but not all operators are
defined for all built-in types.
ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 438
Operator Characteristics
Operators have the following special characteristics:
■Precedence
■Associativity
■Number of required operands
Table 19.1 lists all the C++ operators and their characteristics, grouped by prece-
dence and purpose, with groups of highest precedence listed first.
■The Operands column contains the n umber of operands that the opera-
tor requires.
■The Description column contains the conventional meaning of the oper-ator for built-in types.
■The Assoc column indicates the associativity that governs how an expres-sion is evaluated if the same operator occurs more than once.
■ L indicates left-to-right associativity. Example:
d = a + b + c;  // a+b is evaluated first, then (a+b)+c
assignment is evaluated last because of lower precedence.
■ R indicates right-to-left associativity:
c = b = a;     // a is assigned to b, then to c.
■The Ovl column indicates whether or not the operator may be over-loaded (redefined) for custom types.
■The possible values for that column are:
■ Y: This operator can be overloaded  as a global or member function.
■ M: This operator can be overloaded  only as a class member function.
■ N: This operator cannot be overloaded.19.1 OPERATORS
439ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 439
TABLE 19.1 C++ Operators
Operator Operands Description Example Assoc Ovl
:: one Global Scope Resolution :: name RN
:: two Class/namespace scope resolution className::memberName LN
-> two Member selector via ptr ptr->memberName LN
. two Member selector via obj obj.memberName LN
-> one Smart ptr obj->member RM
[ ] two Subscript operator ptr[expr] LM
( ) anyaFunction call function (argList) LN
( ) any Value construction className (argList) LM
++ one Post increment varName++ RY
-- one Post decrement varName-- RY
typeid one Type identification typeid(type)or typeid(expr) RN
dynamic_cast two runtime checked conv dynamic_cast< type>(expr) LN
static_cast two compile time checked conv static_cast< type>(expr) LN
reinterpret_cast two unchecked conv reinterpret_cast< type>(expr) LN
const_cast two const conv const_cast< type>(expr) LN
sizeof one Size in bytes sizeof expr or sizeof(type) RN
++ one Pre Increment ++varName RY
-- one Pre Decrement --varName RY
~ one Bitwise negation ~expr RY
! one Logical negation !expr RY
+, - one Unary plus, unary minus +expr or -expr RY
440ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 440
* one Pointer dereference * ptr RY
& one Address-of & lvalue RY
new one Allocate new type or new type(expr-list ) RY
new [ ] two Allocate array new type [size ] LY
delete one Deallocate delete ptr RY
delete [ ] one Deallocate array delete [ ] ptr RM
( ) two C-style type cast (type )expr RNb
->* two Member ptr selector via ptr ptr->*ptrToMember LM
.* two Member ptr selector via obj obj.*ptrToMember LN
* two Multiply expr1 *expr2 LY
/ two Divide expr1 /expr2 LY
% two Remainder expr1 %expr2 LY
+ two Add expr1 +expr2 LY
- two Subtract expr1 - expr2 LY
<< two Bitwise left shift expr <<shiftAmt LY
>> two Bitwise right shift expr>> shiftAmt LY
< two Less than expr1< expr2 LY
<= two Less or equal expr1<= expr2 LY
> two Greater expr1> expr2 LY
>= two Greater or equal expr1>= expr2 LY
== two Equalcexpr1== expr2 LY
!= two Not equal expr1!= expr2 LY
& two Bitwise AND expr1& expr2 LY
441continuedezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 441
TABLE 19.1 (Continued )
Operator Operands Description Example Assoc Ovl
^ two Bitwise XOR (exclusive OR) expr1^ e2 LY
| two Bitwise OR (inclusive OR) expr1| expr2 LY
&& two Logical AND expr1&& expr2 LY
|| two Logical OR expr1|| expr2 LY
= two Assign expr1= expr2 RY
*= two Multiply and assign expr1*= expr2 RY
/= two Divide and assign expr1/= expr2 RY
%= two Modulo and assign expr1%= expr2 RY
+= two Add and assign expr1+= expr2 RY
-= two Subtract and assign expr1-= expr2 RY
<<= two Left shift and assign expr1<<= expr2 RY
>>= two Right shift and assign expr1>>= expr2 RY
&= two And and assign expr1&= expr2 RY
|= two Inclusive or and assign expr1|= expr2 RY
*= two Exclusive or and assign expr1^= expr2 RY
? : three Conditional expression bool? expr: expr LN
throw one Throw exception throw expr RN
, two Sequential Evaluation (comma) expr, expr LY
aThe function call operator may be declared to take any number of operands.
bThe type-cast operator may use constructors or conversion operators to convert custom types.
cNote that for float anddouble , this operator should not be used, as it requires an “exact” match, which is architecture-dependent, and not always
reliable. 442ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 442
19.2 Evaluation of Logical Expressions
In C and C++, evaluation of a logical expression stops as soon as the logical value
of the entire expression is determined. This shortcut mechanism may leave someoperands unevaluated. The value of an expression of the form
expr1&& expr2&& ... && exprn
is true if and only if all of the operands are true . If one or more of the operands
is false , the value of the expression is false . Evaluation of the expression
proceeds sequentially, from left to right, and is guaranteed to stop (and return the
value false ) if it encounters an operand that has the value false .
Similarly, an expression of the form
expr1|| expr2|| ... || exprn
is false if and only if all of the operands are false . Evaluation of the expression
proceeds sequentially, from left to right, and is guaranteed to stop (and return the
value true ) if it encounters an operand that has the value true .
Programmers often exploit this system with statements like:
if( x != 0 &&  y/x < z) { 
// do something ...
}else {
// do something else ...
}
Ifxwere equal to 0, evaluating the second expression would produce a run-time
error. Fortunately, that cannot happen.
Logical expressions often make use of both &&and ||. It is important to
remember that &&has higher precedence than ||. In other words, x || y && z
means x || (y && z) , not (x || y) && z .
19.3 Enumerations
In Chapter 2 we discussed at some length how we can add new types to the C++
language by defining classes. Another way to add new types to C++ deserves somemore discussion.
The keyword 
enum is used for assigning integral values to C++ identifiers. For
example, when designing data structures that perform bitwise operations, it is veryconvenient to give names to the various bitmasks. The main purpose for an 
enum
is to make the code more readable and, hence, easier to maintain. For example,
enum {UNKNOWN, JAN, FEB, MAR };19.3 ENUMERATIONS
443ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 443
defines three constant identifiers, numbered in ascending order, starting at 0. It is
equivalent to
enum {UNKNOWN=0, JAN=1, FEB=2, MAR=3};
The identifiers, JAN,FEB, and MAR are called enumerators .
They can be defined and initialized to arbitrary integer values.
enum Ages {manny = 10, moe, jack = 23, 
scooter = jack + 10};
If the first enumerator, manny , had not been initialized, it would have been given
the value 0. Since we initialized manny to 10and we did not assign a value to moe,
the value of moe is 11. The values of enumerators need not be distinct.
When an enum has a tag name , then a new type is defined. For example,
enum Winter {JAN=1, FEB, MAR, MARCH = MAR };
The name Winter is called a tag name. Now, we can declare variables of type
Winter .
Winter m = JAN;
int i = JAN; // OK - enum can be implicitly converted to intm = i;         // ERROR! An explicit cast is required.m = static_cast<Winter>(i);  // OKi = m;         // OKm = 4;         // ERROR
The tag name and the enumerators must be distinct identifiers within their scope.
Enumerations can be implicitly converted to ordinary integer types, but the
reverse is not possible without an explicit cast. Example 19.1 demonstrates the useof
enum and also shows how the compiler symbols look when they are printed out.
EXAMPLE 19.1 src/enums/enumtst.cpp
#include <iostream>
using namespace std;
int main(int, char** ) {
enum Signal { off, on } sig;        sig = on;enum Answer { no, yes, maybe = -1 };  Answer ans = no;                   enum { lazy, hazy, crazy } why;     int  i, j = on;                    sig = off;  i = ans; // ans = sig;                      ans = static_cast<Answer>(sig);     ans = (sig ? no : yes);why = hazy;cout << "sig, ans, i, j, why "
<< sig << ans << i << j << why << endl;
7654321CHAPTER 19: TYPES AND EXPRESSIONS
444ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 444
return 0;
}
Output:OOP> gpp enumtest.cc
a, b, i, j, why 01011OOP>
a new type, two new enum identifiers, and a variable definition all in one line
just the type/enum definitionsan instance of an enuma typeless enum variableAn enum can always convert to int.Conversions between enum types cannot be done implicitly.
Conversion is okay with a cast.
19.4 Signed and Unsigned Integral Types
This section explains the differences between signed and unsigned integral types.
The underlying binary representation of an object x of any integral type looks
like this (assuming n-bit storage):
dn–1dn–2...d2d1d0
where each diis either 0 or 1. The computation of the decimal equivalent value of
x depends on whether x is an unsigned or signed type. If x is unsigned, the deci-mal equivalent value is
dn–1*2n–1+ dn–2*2n–2+...+ d2*22+ d1*21+ d0*20
The largest (positive) value that can be expressed by an unsigned integer is, therefore,
2n– 1 = 1*2n–1+ 1*2n–2+...+ 1*22+ 1*21+ 1*20
If x is signed, the decimal equivalent value is
dn–1*-(2n–1) + dn–2*2n–2+...+ d2*22+ d1*21+ d0*20
The largest (positive) value that can be expressed by a signed integer is
2n–1– 1 = 0*-(2n–1) + 1*2n–2+...+ 1*22+ 1*21+ 1*20
This is called “two’s complement” representation. T o determine the representationof the negative of a signed integer,
1. Compute the “one’s complement” of the number (i.e., replace each bit
with its complement).
2. Add 1 to the “one’s complement” produced in the first step.
8-Bit Integer Example
Suppose that we have a tiny system that uses only 8 bits to represent a number. On
this system, the largest unsigned integer would be
11111111 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255765432119.4 SIGNED AND UNSIGNED INTEGRAL TYPES
445ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 445
But that same number, interpreted as a signed integer, would be
11111111 = –128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = –1
EXERCISES: SIGNED AND UNSIGNED
INTEGRAL TYPES
You be the computer …
For these exercises, simulate the action of the computer as it executes the given
code and specify what you think the output will be. You can always compile andrun the code yourself to see if your output is correct. If you disagree with the com-puter, try to explain why.
1.
#include <iostream>
using namespace std;int main() { 
unsigned n1 = 10;unsigned n2 = 9;char *cp;cp = new char[n2 – n1];if(cp == 0)
cout << "That's all!" << endl;
cout << "bye bye!" << endl;
}
2.#include <iostream>
using namespace std;
int main() {
int x(7), y = 11;char ch = 'B';double z(1.34);ch += x;cout << ch << endl;cout << y + z << endl;cout << x + y * z << endl;cout << x / y * z << endl;
}
3.#include <iostream>
using namespace std;
bool test(int x, int y)
{ return x / y; }
int main()
{ int m = 17, n = 18;
cout << test(m,n) << endl;cout << test(n,m) << endl;m += n;n /= 5;cout << test(m,n) << endl;
}CHAPTER 19: TYPES AND EXPRESSIONS
446ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 446
19.5 Standard Expression Conversions
Expression conversions, including implicit type conversions through promotion
or demotion, and explicit casting through a variety of casting mechanisms are dis-cussed in this section.
Suppose xand yare numeric variables. An expression of the form x op y has
both a value and a type. When this expression is evaluated, temporary copies of x
and yare used. If xand yhave different types, the one with the shorter type may
need to be converted (widened) before the operation can be performed. An implicitconversion of a number that preserves its value is called a promotion .
Automatic Expression Conversion 
Rules for x op y
1. Any bool ,char ,signedchar ,unsignedchar ,enum ,shortint ,
or unsignedshortint is promoted to int. This is called an integral
promotion .
2. If, after the first step, the expression is of mixed type, then the operand of
smaller type is promoted to that of the larger type, and the value of theexpression has that type.
3. The hierarchy of types is indicated by the arrows in Figure 19.1.19.5 STANDARD EXPRESSION CONVERSIONS
447
FIGURE 19.1 Hierarchy of basic typesbool
intunsigned int
if int is the same 
size as long int
floatunsigned long long intchar (signed or unsigned)
long double doubleif short int 
is the same 
size as intshort int
unsigned shortezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 447
We note that the relationship between unsigned and long depends on the
implementation. For example, on a system that implements int with the same
number of bytes as long , it would not be possible to promote unsigned to
long , so the promotion process would bypass long and promote unsigned to
unsignedlong . Now assume that we have the following declarations:
double d;
int i;
In general, a promotion such as d = i; will be well behaved. An assignment that
causes a demotion such as i = d; will result in a loss of information. Assuming
the compiler permits the assignment, the fractional part of dwould be discarded.
Example 19.2 demonstrates some of the conversions we have discussed.
EXAMPLE 19.2 src/mixed-types.cpp
#include <iostream>
using namespace std;
int main() {
int i, j = 88;double d = 12314.8723497;cout << "initially d = " << d
<< "  and j = " << j << endl;
cout << "The sum is: " << d + i << endl;i = d;cout << "after demoting d,  i = " << i << endl;d = j;cout << "after promoting j,  d = " << d << endl;
}
Here is the compile and run.
src> g++ mixed-types.cpp
mixed-types.cpp: In function 'int main()':mixed-types.cpp:10: warning: converting to 'int' from 'double'src> ./a.out
initially d = 12314.9  and j = 88The sum is: 1.34527e+08after demoting d,  i = 12314after promoting j,  d = 88src>CHAPTER 19: TYPES AND EXPRESSIONS
448ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 448
EXERCISE: STANDARD EXPRESSION
CONVERSIONS
Assume that we have the following declarations:
double d = 123.456;
int i = 789, j = –1;uint k = 10;
■What is the type and what is the value of d + i ?
■What is the type and what is the value of j + k ?
■What happens with a promotion such as  d = i; ?
■What happens with a demotion such as i = d; ?
19.6 Explicit Conversions
Explicit conversions are called casts . Casting is sometimes necessary, but it tends
to be overused and can be a major source of errors. In fact, Bjarne Stroupstrup, thecreator of C++, is on record recommending that they be used as little as possible.
Because of its roots in the C language, C++ supports the old-style (unsafe) 
C-style casting 
(type)expr :
double d=3.14;
int i = (int)d;
C++ also supports an alternate constructor-style syntax for casts:
Typet = Type(arglist)
A cast causes a temporary value of the specified type to be created and pushed
onto the program stack. If Type is a class, a temporary object is created and ini-
tialized by the appropriate conversion constructor. If Type is a native type,
Type(arg) is equivalent to (Type) arg . The temporary is kept on the stack just
long enough to evaluate the expression it is in. After that, it is destroyed.
For example,
double d = 3.14;
Complex c = Complex(d);19.6 EXPLICIT CONVERSIONS
449ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 449
19.7 Safer Typecasting Using 
ANSI C++ Typecasts
ANSI C++ adds four cast operators, with template-style syntax, that more clearly
express the intentions of the programmer and make casts easier to spot in thecode. These ANSI typecasts are:
■static_cast< type>(expr)—for converting between related types
■const_cast< type> expr —for casting away const or volatile
■dynamic_cast< type>(expr)—for safe navigation through an inher-
itance hierarchy
■reinterpret_cast< type>(expr)—for type conversions of point-
ers, between unrelated types
19.7.1 static_cast and const_cast
static_cast< DestType >(expr)converts the value expr to type DestType ,
provided that the compiler knows of an implicit conversion from expr to DestType .
All type-checking is done at compile time.
static_cast<char>('A' + 1.0);
static_cast<double>(static_cast<int>(y) + 1);
The static_cast operator converts between related types such as one pointer
type to another, an enumeration type to an integral type, or a floating-point typeto an integral type. These conversions are well defined, portable, and invertible.The compiler can apply some minimal type checking for each 
static_cast .
static_cast cannot cast away const ness. For that you must use
const_cast< DestType >(expr), which creates a non- const version of expr.
In that case, the DestType can differ from the type of expr only in the presence
or absence of const/volatile .
For an int i ,static_cast<double>(i) will create a temporary of type
double , which has the value of i. The variable iitself is not changed by this cast.
Example 19.3 contains both kinds of casts.
EXAMPLE 19.3 src/ansicast/m2k.cpp
// Miles are converted to kilometers.
#include <QTextStream>
QTextStream cin(stdin, QIODevice::ReadOnly);
QTextStream cout(stdout, QIODevice::WriteOnly);QTextStream cerr(stderr, QIODevice::WriteOnly);CHAPTER 19: TYPES AND EXPRESSIONS
450ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 450
const double  m2k = 1.609;    // conversion constant
inline double mi2km(int miles) {
return (miles * m2k);
}
int main() {
int  miles;double kilometers;cout << "Enter distance in miles: " << flush;cin >> miles ;  kilometers = mi2km(miles);cout << "This is approximately "
<<  static_cast<int>(kilometers)<< "km."<< endl;
cout << "Without the cast, kilometers = "
<< kilometers << endl;
double* dp = const_cast<double*>(&m2k); cout << "m2k: " << m2k << endl;cout << "&m2k: " << &m2k << "  dp: " << dp << endl;cout << "*dp: " << *dp << endl;*dp = 1.892;  cout << "Can we reach this statement? " << endl;return 0;
}
Output:Enter distance in miles: 23
This is approximately 37km.Without the cast, kilometers = 37.007m2k: 1.609&m2k: 0x8049048  dp: 0x8049048*dp: 1.609Segmentation fault
What are we attempting to do here?
Here are some observations regarding the previous example.
■The mixed expression miles * m2k is implicitly widened to double .
■The safe cast static_cast<int>(kilometres) truncates the
double value to int.
■The cast did not change the variable kilometres .
■The results of our attempt to assign to *dp are undefined.
Casting Away const
In general, const_cast is only used for const -references and pointers to non-
const objects. Using const_cast to change const objects has undefined1119.7 SAFER TYPECASTING USING ANSI C++ TYPECASTS
451ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 451
behavior because const objects may be stored in read-only memory (which the
operating system protects). In the case of const int , trying to change it by cast-
ing away const depends on compiler optimization techniques, which frequently
optimize them out of existance (by doing pre-compilation value replacement).Consider Example 19.4.
EXAMPLE 19.4 src/casts/constcast1.cpp
#include <iostream>
using namespace std;
int main() {
const int N = 22;int * pN = const_cast<int*>(&N);*pN = 33;cout << N << '\t' << &N << endl;cout << *pN << '\t' << pN << endl;
}
Output:22      0xbf91cfa0
33      0xbf91cfa0
The above output, obtained with gcc version 4.0.3, could be different on your sys-
tem, because the behavior is undefined.
In this example we used const_cast to obtain a regular pointer to a const
int. Because the const int is in stack storage class, we don’t get a segmentation
fault by attempting to change the memory. The compiler is unable to “optimizeout” the int, and the 
const_cast tells it not to even try.
EXERCISES: STA TIC_CAST AND CONST_CAST
1.In Example 19.4, try moving the
const int N = 22;
above or below
int main() {
Observe and explain the difference in output.
2.Predict the output of Example 19.5.
Remove the const_cast from the call to f2() inside f1() , and predict
the output again.CHAPTER 19: TYPES AND EXPRESSIONS
452ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 452
EXAMPLE 19.5 src/casts/constcast2.cpp
#include <iostream>
void f2(int& n) {
++n;
}
void f1(const int& n, int m) {
if(n < m) 
f2(const_cast<int&>(n));
}
using namespace std;int main() {
int num1(10), num2(20);f1(num1, num2);cout << num1 << endl;
}
19.7.2 reinterpret_cast
reinterpret_cast is used for casts that are representation- or system-
dependent; examples are conversions between unrelated types such as int to
pointer or between unrelated pointer types such as int* to double* . It cannot
cast away const .reinterpret_cast s are dangerous, generally not portable,
and should be avoided.
Consider the following situation.
Spam spam;
Egg* eggP;eggP = reinterpret_cast<Egg*>(&spam);eggP->scramble();   
reinterpret_cast takes some spam and gives us an Egg-shaped pointer, with-
out any concern for type compatibility.
By using eggP , we are reinterpreting the bits of spam as if they were bits of egg.
In some countries, this would be sacrilege!19.7 SAFER TYPECASTING USING ANSI C++ TYPECASTS
453ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 453
What Is It Really Used For?
Sometimes, a C function returns a void* pointing to a type that is known to the
developer. In such a case, a typecast from void* to the actual type is needed. If
you are sure it is pointing to an Egg,reinterpret_cast<Egg*> is the appro-
priate cast to use. There is no compiler or runtime checking on such a cast.
19.7.3 Why Not Use C-style Casts?
C-style casts are deprecated and should not be used anymore. Consider the fol-
lowing situation, quite similar to the previous example.
Apple apple;
Orange* orangeP;// other processing steps ...orangeP = (Orange*) &apple;orangeP->squeeze();
The problem is that we can not tell from looking at this code whether the devel-
oper is aware that an Apple is not compatible with an Orange. From looking at it,it is unclear whether this is a proper type conversion or a non-portable pointerconversion.
Errors caused by such a cast can be very difficult to understand and correct. If
a system-dependent cast is necessary, it is preferable to use 
reinterpret_cast
over a C-style cast so that, when troubles arise, it will be easier to spot the likelysource of those troubles in the code.
19.8 Run-Time Type Identification (RTTI)
This section covers dynamic_cast and typeid , two operators that enable
runtime type identification (RTTI).
When operating on hierarchies of typ es, sometimes it is necessary to downcast
a pointer to a more specific type. Without a downcast, only the interface of thepointer type (the base class) is available. One common situation where downcast-ing is used is inside functions that accept base class pointers.
The conversion of a base class pointer to  a derived class pointer is called
downcasting because casting from the base class to a derived class is considered
moving down the class hierarchy.
RTTI allows programmers to safely convert pointers and references to objects
from base to derived types.
dynamic_cast< D*>(ptr) takes two operands: a pointer type D*and a
pointerptr of a polymorphic type B*.I fDis a base class of B(or ifBis the same as
D),dynamic_cast< D*>(ptr) is an upcast (or not a cast at all) and is equivalentCHAPTER 19: TYPES AND EXPRESSIONS
454ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 454
tostatic_cast< D*>(ptr) .B u ti fptr has the address of an object of type D,
whereDis derived from B, the operator returns a downcast pointer of type D*,
pointing to the same object. If the cast is not possible, then a null pointer isreturned.
dynamic_cast performs runtime checking to determine whether the pointer/
reference conversion is valid.
Example 19.6 shows operations on a collection of QWidget s. In fact, we wish
to operate only buttons and sliders, leaving the rest alone.
EXAMPLE 19.6 src/rtti/dynamic_cast.cpp
[ . . . . ]
int processWidget(QWidget* wid) {
if (widpointer->inherits("QAbstractSpinBox")) {  
QAbstractSpinBox* qasbp = 
static_cast <QAbstractSpinBox*> (widpointer);
qasbp->setAlignment(Qt::AlignHCenter);
}else {
QAbstractButton* buttonPtr = 
dynamic_cast<QAbstractButton*>(widpointer);
if (buttonPtr) {                        
buttonPtr->click();qDebug() << QString("I clicked on the %1 button:")
.arg(buttonPtr->text());
}return 1;
}return 0;
}[ . . . . ]QVector<QWidget*> widvect;
widvect.append(new QPushButton("Ok"));
widvect.append(new QCheckBox("Checked"));widvect.append(new QComboBox());widvect.append(new QMenuBar());widvect.append(new QCheckBox("With Fries"));widvect.append(new QPushButton("Nooo!!!!"));widvect.append(new QDateTimeEdit());widvect.append(new QDoubleSpinBox());foreach (QWidget* widpointer, widvect) {
processWidget(widPointer);
}
return 0;
}
only for QObjects processed by moc
If non-null, it’s a valid QAbstractButton.212119.8 RUN-TIME TYPE IDENTIFICATION (RTTI)
455ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 455
qobject_cast (see Section 15.3) is faster than dynamic_cast ,b u t
only works on QObject -derived types.
In terms of run-time cost, dynamic_cast is considerably more expensive, per-
haps 10 to 50 times the cost of a static_cast . However, they are not inter-
changable operations and are used in very different situations.
19.8.1 typeid Operator
Another operator that is part of RTTI is typeid() , which returns type informa-
tion about its argument. For example:
void f(Person& pRef) {
if(typeid(pRef) == typeid(Student) {
// pRef is actually a reference to a Student object.// Proceed with Student specific processing.
}else {
// The Object referred to by pRef is not a Student.// Do whatever alternative stuff is required.
}
}
typeid() returns a type_info object that corresponds to the argument’s type.
If two objects are the same type, their type_info objects should be equal.
The typeid() operator can be used for polymorphic types or non-polymorphic
types. It can also be used on basic types as well as custom classes. Furthermore, thearguments to 
typeid() can be type names or object names.
This is one possible implementation of the type_info class.
class type_info {
private:
type_info(const type_info& ); // cannot be copied by userstype_info& operator=(const type_info&);// implementation dependent representation
public:
virtual ~type_info();bool operator==(const type_info&) const;bool operator!=(const type_info&) const;bool before(const type_info& rhs) const;const char* name() const;// returns a pointer to the name of the type
}CHAPTER 19: TYPES AND EXPRESSIONS
456ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 456
19.9 Member Selection Operators
There are two forms of the member selection operator:
1.pointer ->memberName
2.object ->memberName
They look the same, but differ in the following ways.
1. The first is binary, the second is unary.
2. The first is global and not overloa dable, the second is an overloadable
member function.
When it is defined for a class, the unary operator->() should return a pointer
to an object that has a member whose name is memberName .
An object that implements operator-> is typically called a smart pointer .
Smart pointers are so called because they can be programmed to be “smarter” thanordinary pointers. For example, a 
QPointer is automatically set to 0 when the
referenced object is destroyed. Examples of smart pointers include
1. STL style iterators
2.auto_ptr —the STL smart pointer
3.QPointer —the Qt 4 smart pointer
All of these smart pointers are template classes.
Example 19.7 shows the source code for QPointer .
EXAMPLE 19.7 src/pointers/autoptr/qpointer.h19.9 MEMBER SELECTION OPERATORS
457
continued[ . . . . ]
template <class T>class QPointer{
QObject *o;
public:
inline QPointer() : o(0) {}inline QPointer(T *p) : o(p)
{ QMetaObject::addGuard(&o); }
inline QPointer(const QPointer<T> &p) : o(p.o)
{ QMetaObject::addGuard(&o); }
inline ~QPointer()
{ QMetaObject::removeGuard(&o); }
inline QPointer<T> &operator=(const QPointer<T> &p)
{ if (this != &p) QMetaObject::changeGuard(&o, p.o); return 
*this; }
inline QPointer<T> &operator=(T* p)
{ if (o != p) QMetaObject::changeGuard(&o, p); return *this; }ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 457
inline bool isNull() const
{ return !o; }
inline T* operator->() const
{ return static_cast<T*>(const_cast<QObject*>(o)); }
[ . . . . ]
The operators make use of two ANSI-style typecasts (Section 19.7): static_cast
and const_cast .const_cast is required because the function is const , and it
must return a non- const pointer. RTTI is not necessary here because the template
ensures that the actual pointer stored was a T*. Therefore, static_cast can be
used instead of dynamic_cast .
A QPointer <T> is said to be a guarded pointer to a QObject of type T.B y
guarded we mean that the QPointer is automatically set to 0 if the object that it
is pointing to is destroyed. Here is a code fragment that demonstrates how a
QPointer can be used.
[. . .]
QPointer<QIntValidator> val = new QIntValidator(someParent);val->setRange(20, 60);[. . .]
In that second line of code, val-> returns a pointer to the newly allocated object,
and that pointer is used to access the setRange() member function.
POINT OF DEPARTURE
Guarded pointers are discussed further in Qt Quarterly .1
EXERCISES: TYPES AND EXPRESSIONS
1.Imagine you are required to use a library of classes that have been poorly writ-
ten and you have no way to improve them. (It could happen!) The code inExample 19.8 includes one such badly written example class and a small pro-gram that uses it. The program logic shows some objects being created andpassed to a function that receives them as 
const references (an implicit vow
not to change them) and then prints an arithmetic result. Unfortunately,because the class was badly written, something goes wrong along the way.CHAPTER 19: TYPES AND EXPRESSIONS
458
1http://doc.trolltech.com/qq/qq14-guardedpointers.htmlezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 458
EXAMPLE 19.8 src/const/cast/const.cc
#include <iostream>
using namespace std;
class Snafu {
public:
Snafu(int x) : mData(x) {}void showSum(Snafu & other) const {
cout << mData + other.mData << endl; 
}
private:
int mData;
};
void foo(const Snafu & myObject1,
const Snafu & myObject2) {
// [ . . . ]  myObject1.showSum(myObject2);
}
int main() {
Snafu myObject1(12345);
Snafu myObject2(54321);
foo(myObject1, myObject2);
}
Answer these questions.
a.What went wrong?
b.What change to the class would fix it?
Unfortunately, you can’t change the class. Come up with at least two ways to fix
the program without changing the class definition. What would be the best ofthese and why?
2.The code in Example 19.9 is an incomplete attempt to create a class that
counts, for each instantiation, the number of times an object’s data are printed.Review the program and then make it work properly.19.9 MEMBER SELECTION OPERATORS
459ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 459
EXAMPLE 19.9 src/const/cast/const2.cc
#include <iostream>
using namespace std;
class Quux {
public:
Quux(int initializer) :
mData(initializer), printcounter(0) {}
void print() const;void showprintcounter() const {
cout << printcounter << endl; 
}
private:
int mData;int printcounter;
};
void Quux::print() const {
cout << mData << endl; 
}
int main() {
Quux a(45);a.print();a.print();a.print();a.showprintcounter();const Quux b(246);b.print();b.print();b.showprintcounter();return 0;
}CHAPTER 19: TYPES AND EXPRESSIONS
460ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 460
REVIEW QUESTIONS
461
REVIEW QUESTIONS
1. What is the difference between a statement and an expression?
2. What is the difference between an ov erloaded operator and a function?
3. What ways can you introduce a new type into C++?4. Which cast operator is best suited for numeric values?5. What happens when you assign an 
int variable to a double value?
6. Which cast operator is best suited for downcasting through polymorphic
hierarchies?
7. Why are ANSI casts preferred over C-style casts?8. What is a situation in which you might find the 
reinterpret_cast
used in a reasonable way?ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 461
ezus_138004_ch19.qxd  8/3/06  4:33 PM  Page 462
46320.1 Declarations and Definitions . . . . . . . . 464
20.2 Identifier Scope . . . . . . . . . . . . . . . . . . . . 46520.3 Storage Class . . . . . . . . . . . . . . . . . . . . . . 47020.4 Namespaces . . . . . . . . . . . . . . . . . . . . . . . 47320CHAPTER 20
Scope and Storage Class
Identifiers have scope, objects have a storage class,and variables have both. In this chapter, we discussthe difference between declarations and definitions,and how to determine the scope of identifiers andthe storage class of objects.ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 463
20.1 Declarations and Definitions
Any identifier must be declared or defined before it is used.
Declaring a name means telling the compiler what type to associate with that
name. The location of the declaration determines its scope . Scope is a region of
code where an identifier can be used.
Defining an object , or variable, means allocating space and (optionally)
assigning an initial value. For example,
double x, y, z;
char* p;int i = 0; QString message("Hello");
Defining a function means completely describing its behavior in a block of C++
statements. For example,
int max(int a, int b) {
return a > b ? a : b;
}
Defining a class means specifying its structure in a sequence of declarations of
function and data members.
EXAMPLE 20.1 src/early-examples/decldef/point.h
class Point {                      
public:
Point(int x, int y, int z);     int distance(Point other);      double norm() const {           
return distance(Point(0,0,0));
} 
private:
int m_Xcoord, m_Ycoord, m_Zcoord;  
};
a class definition
a constructor declarationa function declarationdeclaration and definition
data member declaration
Example 20.2 contains some declarations that are not definitions.5432154321
ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 464
EXAMPLE 20.2 src/early-examples/decldef/point.cpp
extern int step;      
class Map;           int max(int a, int b);
an object (variable) declaration
a class declaration
a global (non-member) function declaration
In each case, there is an implicit promise to the compiler (which will be enforced by
the linker) that the declared name will be defined somewhere else in the program.
Each definition is adeclaration. There can be only one definition of any name
in any scope, but there can be multiple declarations.
Variable initialization is optional in C++. Nevertheless, it is strongly recom-
mended that an initial value be provided for all variable definitions, other-wise invalid results or strange runtime errors can occur that are oftendifficult to locate. It is worth repeating this rule: All objects and variables
should be properly initialized at creation time.
20.2 Identifier Scope
Every identifier has a scope that is determined by where it is declared. Identifier
Scope in a program is the region(s) of the program within which the identifier can
be used. Using a name outside of its scope is an error.
The same name may declared/used in different scopes. Ambiguities are resolved
as follows:
1. The name from the most local scope is used.
2. If the name is not defined in the most local scope, the same name
defined in the nearest enclosing scope will be used.
3. If the name is not defined in any enclosing scope, then the compiler will
report an error.
There are five possible scopes in C++.
1. Block scope (local to a block of statements)
2. Function scope (the entire extent of a function)132132120.2 IDENTIFIER SCOPE
465
1Only labels have function scope.ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 465
3. Class scope (the entire extent of a class, including its member functions)
4. File scope (the entire extent of a source code file)5. Global scope (the entire extent of a program)
Because the compiler only deals with one source file at a time, only the Linker
can tell the difference between global and file scope, as Example 20.3 shows.
EXAMPLE 20.3 Global versus File scope
// In File 1:
int g1;        // globalint g2;        // globalstatic int g3; // keyword static limits g3 to file scope(etc.)
// In File 2:
int g1;          // linker error!extern int g2;    // okay, share variable spacestatic int g3;    // okay: 2 different variable spaces
(etc.)
20.2.1 Default Scope of Identifiers: A Summary
Let’s look at the five scopes in a bit more detail.
1. Block scope. An identifier declared inside curly braces (excluding
namespace b l o c k s ){...}o ri na function parameter list has block scope.
Block scope extends from the declaration to the enclosing right brace.
2. Function scope. Labels in C/C++ have their own scope. They are accessi-
ble before and after their declarat ion, for the whole function. C supports
a very rarely used and often shunned goto statement that requires a
label. The thing that makes its scope unique is that the label (the declara-tion) can appear after the first 
goto that uses it. Example 20.4 shows an
example of its use. goto is seldom used by serious programmers but
labels , because they exist, sometimes pop up in code and are used to
solve various compatibility problems.2
Avoid goto and labels in your code.CHAPTER 20: SCOPE AND STORAGE CLASS
466
2Such as preventing the C++ compiler from choking on the signals: and slots: declarations.ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 466
3. Class scope. An identifier that is declared inside a class definition has
class scope . Class scope is anywhere in the class definition3or in the
bodies of member functions.4
4. File scope. This is basically the same as global scope, except that file
scope variables are not exported to the linker. The keyword static hides
an identifier from other source files and gives it file scope. File scopevariables cannot be declared
extern and accessed from another file.
File scope variables, because they are not exported, do not pollute the
global namespace. They are often used in C programs because C has noconcept of
private class members.
File scope is available in C++ for backward compatibility with C, but we
prefer to use namespaces or static class members instead.
5. Global scope. An identifier whose declaration is not in between
braces (round or curly) has global scope. The scope of such anidentifier begins at the declaration and extends from there to thebottom of the source code file.
extern declarations may be used to access
global definitions in other source files.
An identifier in a namespace is available from other scopes through the
using keyword. It is also available globally through the use of the scope
resolution::operator. Namespace variables and static class members are
accessible globally and have static storage, like global variables, except thatthey do not enlarge the global namespace. See Section 20.4 for more details.
Use of global scope for variables is unnecessary in C++. In general, only
classes and namespaces should be defined in global scope. If you need a“global” variable, you can achieve something similar through the use of
public static class member or a namespace member.
EXAMPLE 20.4 src/goto/goto.cpp
[ . . . . ]
int look() {
int i=0;for (i=0; i<10; ++i) {20.2 IDENTIFIER SCOPE
467
3Including inline function definitions above the declarations of referred members
4Keeping in mind that the scope of non- static members excludes the bodies of static member
functionscontinuedezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 467
if (i == rand() % 20)
goto found;  
}return -1;
found:                 
return i;
}[ . . . . ]
It would be better to use break or continue.
goto serves as a forward declaration to a label.
20.2.2 File Scope versus Block Scope and operator::
We have seen and used the scope resolutio n operator to extend the scope of a class
or access its members with  ClassName:: . A similar syntax is used to access the
individual symbols in a namespace with NamespaceName:: . C++ also has a
(unary) file scope resolution operator, ::, that provides access to global, name-
space, or file scope objects from inside an enclosed scope. The following exercise
deals with the use of this operator with various scopes.
EXERCISE: FILE SCOPE VERSUS BLOCK
SCOPE AND OPERA TOR::
Determine the scope of each of the variables in Example 20.5. Then be the com-
puter and predict the output of the program.
EXAMPLE 20.5 src/early-examples/scopex.cpp
#include <iostream>
using namespace std;
long x = 17;
float y = 7.3;          static int z = 11;      
class Thing {
int m_Num;         
public:
static int sm_Count;Thing(int n = 0) : m_Num(n) {++sm_Count;}~Thing() {--sm_Count;}int getNum() { return m_Num; }
};43212121CHAPTER 20: SCOPE AND STORAGE CLASS
468ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 468
int Thing::sm_Count = 0;
Thing t(11);
int fn(char c, int x) { 
int z = 5;         double y = 6.933; { 
char y;   Thing z(4);        y = c + 3; ::y += 0.3;        cout << y << endl;  
}cout << Thing::sm_Count
<< endl;      
y /= 3.0;          ::z++;             cout << y << endl;return x + z;
}
int main() {
int x, y = 10; char ch = 'B';     x = fn(ch, y); cout << x << endl; cout << ::y << endl;       cout << ::x / 2 << endl;cout << ::z << endl;
}
Scope: ________________
Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________Scope: ________________
Scope: ________________ 1514131211109876543211514131211109876520.2 IDENTIFIER SCOPE
469ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 469
20.3 Storage Class
Whenever an object is created, space is allocated in one of four possible places.
Each of these places is called a storage class .
While scope refers to a region of code where an identifier is accessible, storage
class refers to a location in memory.
1. The static area: Global variables, static locals, and static data mem-
bers are all stored in the static storage area. The lifetime of a static
object begins when its object module loads and ends when the programterminates.
It is used often for pointers, simple types, and string constants, less
often for complex objects.
2. The program stack (automatic storage—
auto5): Local variables, func-
tion parameters, and temporary objects are all stored on the stack. Forlocal (block-scope) variables, the lifetime is determined by the bracketsaround the code that is executed.
Objects on the stack include functi on parameters, return values, local
or temporary variables. Stack storag e is allocated automatically when an
object definition is executed. Objects in this storage class are local to afunction or a block of statements.
6
3. The heap or free storage (dynamic storage): Objects created via new are
examples.
The lifetime of a heap object is determined entirely by the use of new
and delete .
In general, the allocation and fr eeing of heap objects should be in
carefully encapsulated classes.
4. Another storage class, left over from C, is called register .It is a special-
ized form of automatic storage. This category of storage can be requestedby using the keyword,
register in the variable declaration. Most C++
compilers ignore this keyword and put such variables on the stack. Usingthis storage class for an object means that you cannot take its address.CHAPTER 20: SCOPE AND STORAGE CLASS
470
5The optional keyword auto is almost never used.
6Or to a member of another object that isezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 470
20.3.1 Globals, statics, and QObject
Global objects need to be “global” for two reasons.
1. They need a lifetime that is the same as the application.
2. They need to be available from many different places in the application.
In C++, we avoid the use of global scope at all costs, in favor of other approaches.
We still use global scope identifiers for the following:
1. Class names
2. Namespace names3. The global pointer 
qApp , which points to the running QApplication
object
By turning a global object into a static class member, or a namespace member,
we can avoid increasing the size of the global namespace while keeping the objectaccessible from other source code modules.
statics and QObject
When creating QObject or other interesting classes,7it is important that
their destructors do not get called after the QApplication has been
destroyed (after main() is finished).
static QObjects (and other complex objects) cleaned up after a
QApplication has been destroyed could have difficulties in clean-up
code. This is because QApplication , when it is destroyed, takes a lot of
other objects with it.
In general, we want to have control over the order of destruction of all
complex objects. One way to ensure this is to make each QObject allocated
on the stack, or on the heap, and then added as a child/grandchild of another
QObject already on the stack.
The QApplication (or its derived instance) is the “rootiest” stack object
of them all, so we try to make it the “last QObject standing.”
20.3.1.1 Globals and const
The scope of const variables is slightly different from the scope of regular globals.
A global object that has been declared const has file scope, by default. It may
be exported to other files by declaring it extern at the point where it is initialized.20.3 STORAGE CLASS
471
7By “interesting” we mean any class with a destructor that has some important cleaning up to do.ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 471
For example, in one file, we could have this:
const int NN = 10;      //must be initialized
//declaration and definition - allocates storage
extern const int QQ = 7;   
int main() {
NN = 12;       // Error!int array[NN];  // OKQQ++;           // Error!return 0;
}
In another file, we might have
const int NN = 33;      // a different constant
// declare global constant - storage allocated elsewhere
extern const int QQ;    // external declaration ...
The second file has a constintNN that is separate and distinct from the const
with the same name in the first file. The second file can share the use of the const
intQQ because of the extern modifier.
EXERCISE: STORAGE CLASS
In Example 20.6, identify the scope/storage class of each of object’s creation/
definition. If there is a name clash, indicate there is an error with the definition.
EXAMPLE 20.6 src/storage/storage.cpp
#include <qstd.h>
using namespace qstd;
int i;                                   
static int j;                            extern int k;                            const int l=10;                           extern const int m=20;                    
class Point                              
{
public:QString name;                        QString toString() const;private:static int count;int x, y;                            
};
int Point::count = 0;                     
987654321CHAPTER 20: SCOPE AND STORAGE CLASS
472ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 472
QString Point::toString() const {
return QString("(%1,%2)").arg(x).arg(y);  
}
int main(int argc, char** argv)            
{
int j;                               register int d;int* ip = 0;                         ip = new int(4);                      Point p;                             Point* p2 = new Point();              
}
Scope: ______________   Storage class: ____________
Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________S/SC of argc and argv: _________________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________Scope: ______________   Storage class: ____________
Scope: ______________   Storage class: ____________
20.4 Namespaces
In C and C++ there is one global scope that contains
■The names of all global functions and variables
■Class and type names that are commonly available to all programs
Classes are one way of grouping names (members) under a common heading (the
classname), but sometimes it is desirable to have a higher level grouping of names.
The namespace mechanism provides a way to partition the global scope into
individually named sub-scopes. This helps avoid naming conflicts that can arisewhen developing a program that uses modules with name conflicts.
The syntax for defining a namespace is
namespace namespaceName { decl1, decl2, ...}
Any legal identifier can be used for the optional namespaceName .
Examples 20.7 and 20.8 define two separate namespaces in different files, each
containing functions with the same name.161514131211109876543211615141312111020.4 NAMESPACES
473ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 473
EXAMPLE 20.7 src/namespace/a.h
#include <iostream>
namespace A {
using namespace std;void f() {
cout << "f from A\n";
}
void g() {
cout << "g from A\n";
}
}
EXAMPLE 20.8 src/namespace/b.h
#include <iostream>
namespace B {
using namespace std;void f() {
cout << "f from B\n";
}
void g() {
cout << "g from B\n";
}
}
Example 20.9 includes both header files and uses sc ope resolution to call functions
declared in either file.
EXAMPLE 20.9 src/namespace/namespace1.cc
#include "a.h"
#include "b.h"
int main() {
A::f();B::g();
}
Output:f from A
g from BCHAPTER 20: SCOPE AND STORAGE CLASS
474ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 474
The using keyword permits individual members of a namespace to be referenced
without scoping. The syntax can take two forms.
1. The using directive:using namespace namespaceName —imports
the entire namespace into the current scope
2. The using declaration: using namespaceName::identifier —imports a
particular identifier from that namespace
Care must be exercised to make sure that ambiguities are not produced when iden-
tifiers are present in more than one included namespace. We show an example ofsuch an ambiguous function call in Example 20.10.
EXAMPLE 20.10 src/namespace/namespace2.cc
#include "a.h"
#include "b.h"
int main() {
using A::f;      f();using namespace B;  g();             f();             
}
Output:f from A
g from Bf from A
declaration—brings A::f() into scope
directive—brings all of B into scopeokay
ambiguous
NAMESPACE ALIASES To make the names of various namespaces
unique, programmers sometimes produce extremely long namespacenames. One can easily introduce an alias for a long namespace namewith a command such as:
namespacexyz=verylongcomplicatednamespacename;4321432120.4 NAMESPACES
475ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 475
20.4.1 Anonymous Namespaces
A namespace without a name is an anonymous namespace. This is similar to
static global, or file scope identifier. It is accessible from that point down to the
end of the file.8
Example 20.11 shows how anonymous namespaces can eliminate the need for
static globals.
EXAMPLE 20.11 src/namespace/anonymouse.h
namespace {
const int MAXSIZE = 256;
}
void f1() {
int s[MAXSIZE];
}
20.4.2 Open Namespaces
Any namespace definition is open in the sense that you can add members to an
existing namespace by declaring a second namespace with the same name but withnew items. The new items will be appended to the namespace in the order inwhich the namespace declarations are encountered by the compiler.
Classes are similar to namespaces but classes are not open because they serve as
a pattern for the creation of objects.
The 
using directive does not extend the scop e in which it is used; it imports
names from the specified namespace into the current scope.
Names locally defined take precedence over names from the namespace (which
are still accessible using the sc ope resolution operator).
20.4.3 Namespace, static Objects and extern
Objects declared inside namespaces are implicitly static , meaning that they are
created once for the entire application. The initialization of a static object mustexist in only one C++ module. T o declare a 
static object (global or
namespace ) without defining it, use the keyword extern .9Example 20.12 shows
how to declare namespace variables.CHAPTER 20: SCOPE AND STORAGE CLASS
476
8Unless it appears inside another namespace (whic h the language permits), in which case the scope
is further narrowed by the brackets of its enclosing namespace.
9Even inside namespaces!ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 476
EXAMPLE 20.12 src/libs/utils/qstd.h
[ . . . . ]
namespace qstd {
extern QTextStream cin;  extern QTextStream cout;extern QTextStream cerr;bool yes(QString yesNoQuestion);bool more(QString prompt);int promptInt(int base = 10);double promptDouble();void promptOutputFile(QFile& outfile);void promptInputFile(QFile& infile);
[ . . . . ]
declared only—defined in the .cpp file
Each variable must be defined in a .cpp file, as shown in Example 20.13.
EXAMPLE 20.13 src/libs/utils/qstd.cpp
[ . . . . ]
QTextStream qstd::cin(stdin, QIODevice::ReadOnly);QTextStream qstd::cout(stdout, QIODevice::WriteOnly);
QTextStream qstd::cerr(stderr, QIODevice::WriteOnly);1120.4 NAMESPACES
477ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 477
CHAPTER 20: SCOPE AND STORAGE CLASS
478
REVIEW QUESTIONS
1. What is a scope? What kinds of “things” have a scope?
2. What is a storage class? What kinds of “things” have a storage class?3. When are 
static objects initialized? Be sure to mention both globals
and block-scope objects.
4. How does const act as a scope modifier?
5. What does extern mean?
6. The keyword static has many meanings depending upon where it is
used.
a. Explain how static can be used as a scope modifier.
b. Explain how static can be used as a storage-class modifier.
c. Give another use for the keyword static .ezus_138004_ch20.qxd  8/4/06  10:07 AM  Page 478
47921.1 Statements . . . . . . . . . . . . . . . . . . . . . . . . 480
21.2 Selection Statements . . . . . . . . . . . . . . . 48021.3 Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . 48321.4 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 48521CHAPTER 21
Statements and Control
Structures
Programs consist of statements of various kinds.
Control structures are statements that control theway other statements are executed. This chapter for-mally defines the language elements and showswhat kind of control structures are available.ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 479
21.1 Statements
A C++ program contains statements that alter the state of the storage managed by
the program and determine the flow of program execution. There are several typesof C++ statements, most of which are inherited from the C language. First, thereis the simple statement, terminated with a semicolon, such as
x = y + z;
Next, there is the compound statement ,o r  block , consisting of a sequence of
statements enclosed in curly braces.
{
int temp = x;x = y;y = temp;
}
The above example is a single compound statement that contains three simple
statements. The variable temp is local to the block and is destroyed when the end
of the block is reached.
In general, a compound statement can be placed wherever a simple statement
can go. The reverse is not always true, however. In particular, the function definition
double area(double length, double width) {
return length * width;
}
cannot be replaced by
double area(double length, double width)
return length * width;
The body of a function definition must always include a block.
21.2 Selection Statements
Every programming language has at least one control structure that allows the
flow of the program to branch depending on the outcome of a boolean condition.
ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 480
In C and C++ we have ifand switch . The ifstatement typically has the
following form.
if(boolExpression )
statement
It can have an optional else attached.
if(boolExpression )
statement1
else
statement2
Conditional statements can be nested, which means that they can get quite compli-
cated. A very important rule to keep in mind is that an else orelse if clause is
activated when the boolExpression of the immediately preceding openifevalu-
ates tofalse. This can be confusing when your program logic allows you to omit
some else clauses. Consider the following badly indented example, where xis anint.21.2 SELECTION STATEMENTS
481
if (x>0)
if (x > 100)
cout << "x is over a hundred";
else
if (x == 0) // no! this cannot be true -the indentation is misleading
cout << "x is 0";
else
cout << "x is negative"; // no! x is between 1 and 100 inclusive!
We can clarify and repair this logic with braces.
if (x>0) {
if (x > 100)
cout << "x is over a hundred";
}else
if (x == 0)  // now this is possible.
cout << "x is 0";
else
cout << "x is negative";
An ifwithout an else can be closed by enclosing the ifstatement in braces {},
making it a compound statement.
switch is another branching construct, which permits the execution of dif-
ferent code depending the value of a parameter.
switch(integralExpression ) {
case value1:
statement1;
break;
case value2:
statement2;
break;...
continuedezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 481
case valuen:
statementn;
break;
default:
defaultStatement ;
}nextStatement ;
The switch statement is a computed goto statement. Each case is followed by
a unique case label value, which is compared to the integralExpression .
When the switch causes a jump to a case label whose value matches the
integralExpression , statements are executed from that point on until the end of the
switch block or a branching statement (e.g., break ) is reached.
The optional default label is the jump destination when the integralExpression
does not match any case label value. If default is omitted, and no matching
case label exists, then the switch block is skipped.
The integralExpression must be an expression that evaluates to an integer. Each
case label, except default , must be an integer constant.1
Any switch statement such as the one above can be rewritten as a long
if ... else statement. However, the runtime performance of a switch is con-
siderably better because it requires only a single comparison and performs onlyone branch.
if(integralExpression == value1)
statement1;
else if( integralExpression == value2)
statement2;
...else if( integralExpression == value
n)
statementn;
else
defaultStatement ;
Long compound conditional statements and switch statements
should to be avoided in object-oriented programming (unless they areisolated in factory code), because they tend to make functions complexand hard to maintain.
If each 
case can be rewritten as a method of a different class, you
can use the Strategy pattern (and the virtual table) instead of writing
your own switch statement.CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
482
1case labels are not the same as goto labels that are used as destinations for the infamous goto
statement. goto labels must be identifiers. In particular, they cannot be integers.ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 482
EXERCISE: SELECTION STA TEMENTS
Be the computer and predict the output of the program in Exercise 21.1. Then run
it and compare your predicted output with the output produced by the computer.
EXAMPLE 21.1 src/early-examples/nestedif.cpp
#include <iostream>
using namespace std;
void nestedif1 () {
int m = 5, n = 8, p = 11;if (m > n)
if (p > n)
cout << "red" << endl;
else
cout << "blue" << endl;
}
void nestedif2() {
int m = 5, n = 8,  p = 11;if (m > n) {
if (p > n)
cout << "red"  << endl;
} else
cout << "blue" << endl;
}
int main() {
nestedif1();nestedif2();return 0;
}
21.3 Iteration
C++ provides three iteration structures.
1.while
while ( loopCondition ) {
loopBody
}
a. Evaluate loopCondition first.
b. Execute loopBody repeatedly until loopCondition is false .21.3 ITERATION
483ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 483
2.do..while :
do {
loopBody
} while ( loopCondition ) ;
a. Execute loopBody first.
b. Evaluate loopCondition .
c. Execute loopBody repeatedly until loopCondition is false.
3.for loop:
for ( initStatement ; loopCondition ; incrStmt ) {
loopBody
}
a. Execute initStatement first.
b. Execute loopBody repeatedly until loopCondition is false.
c. After each execution of loopBody ,e x e c u t e  incrStmt .
With each of these iteration structures, the loopBody code gets repeated as long as
loopCondition evaluates to boolean true . The doloop differs from the other two
in that its loopCondition gets checked at the bottom of the loop, so its loopBody is
always executed at least once.
A common programming error is to place a semicolon after the while .
while (notFinished());
doSomething();
The first semicolon terminates the while statement entirely and produces a loop
with an empty loopBody . Even though doSomething() is indented, it does not
get executed inside the loop. The loopBody is responsible for changing the
loopCondition. IfnotFinished() is initially true, then the empty loopBody
will cause an infinite loop. If notFinished() is initially false, then the loop ter-
minates immediately and doSomething() gets executed exactly once.
C++ provides break and continue for finer control over code executed
inside loops.
while ( moreWorkToDo ) {
statement1;
if ( specialCase ) continue;
statement2;
if ( noMoreInput ) break;
statement3;
// continue jumps here}// break jumps here
■break jumps out of the current control structure, whether it is a
switch ,for,while ,o r  do..while .
■continue only operates inside loops, and it skips the rest of the current
iteration to the check if there is moreWorkToDo .CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
484ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 484
EXERCISES: ITERA TION
1.Write the function isPrime(int n) that returns true if nis prime and false
otherwise. Supply an interactive main() to test your function.
2.Write the function primesBetween(int min, int max) that displays on
the screen all the prime numbers that are between min and max . Supply an
interactive main() to test your function.
3.Write the function power2(int n) that computes and returns the value of 2
raised to the power n. Supply an interactive main() to test your function.
4.Write a binary logarithm function binLog(int n) that computes and returns
an int equal to the integral part of log2(n) , where nis positive. This is equiv-
alent to finding the exponent of the largest power of 2 that is less than or equalto 
n. For example, binLog(25) is 4. There are at least two simple, iterative ways
to do this computation. Supply an interactive main() to test your function.
21.4 Exceptions
We all know that things sometimes break and that improbable or unforseen events
can mess up the most carefully laid plans. This is especially true with program-ming and might explain why programmers have such great respect for Murphy’sLaw.
2When we write programs we try to anticipate the things that can go wrong
and make allowances for them, so we try to make our programs foolproof. Thismay seem inconsistent with a very important corollary to Murphy’s law,
3but we
persevere anyway.
Exception handling permits the program to respond to an exceptional situa-
tion by invoking a procedure that is sp ecifically designed to handle it. This can
allow the program to recover from a condition that might normally cause it tocrash or get into a bad state.
Exception handling was added to C++ relatively late in the development of the
language. As with any good thing, there is a cost associated with exception handling.Enabling exception handling adds a significant amount of additional code to theexecutable, which can degrade run-time performance. Some developers avoid this
feature completely. Qt 4 library code, for example, does not require any exceptionhandling by client code.21.4 EXCEPTIONS
485
2Whatever can go wrong will go wrong.
3It is impossible to make anything foolproof because fools are too clever.ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 485
21.4.1 Exception Handling
Here is a summary of how exception handling works in C++. An exception is an
object or piece of data that is thrown from one place (the location of the error) toanother (a 
catch statement that contains the appropriate code for handling the
situation). The context for exception handling is a try block, which is followed by
one or more catch statements. Here is an arrangement that might be used to han-
dle exceptions.
try {
// to do something
}catch ( ExceptionType
1& refName ) {
// handle one ExceptionType
}...catch ( ExceptionType
N& optionalParam ) {
// statements for processing one of the possible thrown exceptions.
}
21.4.2 Exception Types
The keyword throw can be followed by an expression of any type . In particular,
this includes
■Standard exceptions
■Built-in types
■Custom classes
The exception-handling mechanism can transmit information about a run-time
problem. Even though it is perfectly legal to throw a piece of data of a simple type(e.g.,
int), this is not regarded as good practice. Instead, it is best to work with
std::exception objects of classes with descriptive names and a consistent
interface that can be used by client code to increase the informational value of
catch statements.
Example 21.2 contains some custom exception types.
EXAMPLE 21.2 src/exceptions/example/exceptions.h
[ . . . . ]
/* a custom exception with no data */class SizeMatchError {
public:
SizeMatchError() {}CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
486ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 486
QString what() {
return "Size mismatch for Vector addition!";
}
};class BadSizeError {/* a custom exception with data */
public:
BadSizeError(int sz): m_Sz(sz) {}QString what() const {
return QString("Invalid size for Vector: %1").arg(m_Sz);
}int m_Sz;
};
#include <stdexcept>
using std::exception;class RangeError : public exception { /* a custom exception extending from std::exception */
public:
RangeError() {}const char* what() const throw() {  
return "Subscript out of range!";
}
};[ . . . . ]
Matches base class virtual signature.
21.4.3 throwing Things Around
Generally, throw statements occur inside function definitions and transmit infor-
mation to the client code about an exceptional circumstance. The expressioninside the throw is copied into a temporary buffer, making it possible to throw
temporary stack objects. A 
throw statement resembles a function call, but really
it is more like an express- return . This is why.
■A throw statement always returns information to a position we were
before—further back on the stack.
■There is no way to go “back” to the location of the throw , because
throw is going “back” already.
■The stack is unwound , meaning that all stack objec ts are cleaned up, until
we reach the stack frame corresponding to a try/catch block with a
compatible catch parameter.
■If a matching catch statement is found, its code is executed.
■If no matching catch is found, the default handler (terminate() or
abort() ) is called, which results in the program terminating.1121.4 EXCEPTIONS
487ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 487
throwing from Constructors and Destructors
For a variety of reasons, exceptions do not mix well with constructors and
destructors.
1. Throwing from a destructor is a very bad idea , especially if one of those
objects is being cleaned up as a result of another throw .
2. Throwing an exception from a constructor means that the object’s
destructor will never be called.
To avoid this, these functions should be exception-safe, meaning that they
catch and handle any possible exceptions that might be thrown.
throw() in a Function Signature
The ANSI/ISO standard permits member function  declarations in class definitions
to specify which exceptions might be thr own when the function is called. This dec-
laration syntax informs the authors of client code so that they can place try
blocks and catch statements appropriately. A throw() expression in a function
declaration is part of that function’s signature.
The template-based Vector class defined in Example 21.3 throws a variety of
different kinds of exceptions and demonstrates this feature.
EXAMPLE 21.3 src/exceptions/example/vector.h
[ . . . . ]
#include "exceptions.h"
using std::bad_alloc;
template <class T> class Vector {
public:
typedef T* iterator;explicit Vector(int n = 100) throw(BadSizeError, bad_alloc);Vector(const Vector & v) throw(bad_alloc);Vector(const T* a, int n) throw(BadSizeError, bad_alloc);~Vector();void display() const;iterator begin() const {
return m_P;
}iterator end() const {
return m_P + m_Size;
}T& operator[](int i) throw(RangeError);Vector& operator=(const Vector& v) throw(bad_alloc);CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
488ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 488
Vector operator+(const Vector& v) const throw(SizeMatchError);
private:
int m_Size;T* m_P;void copy(const T* a, int n) throw(BadSizeError, bad_alloc);
};
The conditions for each throw are specified in the member function definitions,
shown in Example 21.4. Notice we have function definitions in a header file; thisis because they are template functions (see Section 10.1).
EXAMPLE 21.4 src/exceptions/example/vector.h
[ . . . . ]
template <class T> Vector<T>::
Vector(int n) throw(BadSizeError, bad_alloc) : m_Size(n) {
if(n <= 0)
throw BadSizeError(n);
m_P = new T[m_Size];  
}[ . . . . ]
template <class T> T& Vector<T>::
operator[](int i) throw(RangeError) {
if(i >= 0 && i < m_Size )
return (m_P[i]);
else
throw RangeError();
}[ . . . . ]
template <class T> Vector<T> Vector<T>::
operator+(const Vector& v) const throw(SizeMatchError) {
if(m_Size != v.m_Size) {
throw SizeMatchError();
} else {
Vector sum(m_Size);for(int i = 0; i < m_Size; ++i)
sum.m_P[i] = m_P[i] + v.m_P[i];
return sum;
}
}
new will throw bad_alloc if it fails.1121.4 EXCEPTIONS
489ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 489
21.4.4 try and catch
Exceptions are raised when certain kinds of operations fail during the execution of
a function. If an exception is thrown from within a try block (perhaps deeply
nested within the block), it can be handled by a catch statement with a parame-
ter that is compatible with the exception type.
The syntax of a try block has the following form:
try compoundStatement handlerList
The order in which handlers are defined determines the order that they will be
tested against the type of the thrown expression. It is an error to list handlers in anorder that prevents any of them from being called.
4
The throw expression matches the catch parameter type if it is assignment-
compatible with that type.
The syntax of a handler has the following form:
catch ( formalArgument ) compoundStatement
A catch statement looks like the definition of a function that has one parameter
but no return type. It is a good idea to declare the formalArgument as a reference,
to avoid making an unnecessary copy.
If a thrown exception is not caught by an appropriate handler, the default han-
dler will abort the program.
EXAMPLE 21.5 src/exceptions/catch.cpp
#include <iostream>
#include <stdlib.h>
using namespace std;void foo() {
int i, j;i = 14;j = 15;throw i;
}
void call_foo() {
int k;k = 12;foo();throw ("This is from call_foo");
}CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
490
4An example would be having a catch(QObject&) before a catch(QWidget&) . Since only one
catch gets executed and the QObject is more general than the QWidget , it makes no sense to have
the catch(QWidget&) unless it appears before the catch(QObject&) .ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 490
void call_foo2() {
double x = 1.3;unsigned m = 1234;throw (x);throw m;
}
int main() {
try {
call_foo();call_foo2();
}catch(const char* message) {  
cerr << message << endl;exit(1);
}catch(int &n) {
cout << "caught int " << n << endl;
}catch(double& d) {         
cout << "caught a double:" << d << endl;
}catch( ... ) {             
cerr << "ellipsis catch" << endl;abort();
}
}
Output:# with the first throw commented out
src/generic> g++ catch.cpp
src/generic> ./a.out
This is from call_foosrc/generic>
# with the first two throws commented out
src/generic> g++ catch.cpp
src/generic> ./a.out
caught a doublesrc/generic>
# with the first three throws commented out
src/generic> g++ catch.cpp
src/generic> ./a.out
ellipsis catchAbortedsrc/generic>
# with all the throws enabled
src/generic> g++ catch.cpp
src/generic> ./a.out
caught int 14src/generic>32121.4 EXCEPTIONS
491
continuedezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 491
Is const necessary here?
abstract parameter
default action to be taken
Example 21.5 demonstrates a few interest ing possibilities for handlers. The formal
parameter of catch() can be abstract (i.e., it can have type information without
a variable name). The final catch(...) can use an ellipsis and matches any
exception type.
The system calls clean-up functions, including destructors for stack objects
and for objects local to the try block. When the handler has completed execution,
if the program has not been terminated, then execution will resume at the firststatement following the 
try block.
Example 21.6 shows some client code for the Vector template class and excep-
tion classes that we defined in the preceding sections. Depending on how muchsystem memory you have on your computer, you may need to adjust the initialvalues of
BIGSIZE and WASTERS to get this program to run properly. The output
is included after the code.
EXAMPLE 21.6 src/exceptions/example/exceptions.cpp
#include "vector.h"
#include <qstd.h>using namespace qstd;
void g (int m) {
static int counter(0);static const int BIGSIZE(50000000), WASTERS(6);++counter;try {
Vector<int> a(m), b(m), c(m);cerr << "in try block, doing vector calculations. m= "
<< m << endl;
for (int i = 0; i < m; ++i) {
a[i] = i;b[i] = 2 * i + 1;
}c = a + b;c.display();if (counter == 2)
int value = c[m];                
if(counter ==3) {
Vector<int> d(2*m);for(int i = 0; i < 2*m; ++i)
d[i] = i * 3;
c = a + d;                    
}
21321CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
492ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 492
if(counter == 4) {
for(int i = 0; i < WASTERS; ++i)  
double* ptr = new double(BIGSIZE);
Vector<int> d(100 * BIGSIZE);Vector<int> e(100 * BIGSIZE);   
for(int i = 0; i < BIGSIZE; ++i)
d[i] = 3 * i;
}
}catch(BadSizeError& bse) {              
cerr << bse.what() << endl;
}catch(RangeError& rer) {
cerr << rer.what() << endl;
}catch(SizeMatchError& sme) {
cerr << sme.what() << endl;
}catch(...) {
cerr << "Unhandled error! Aborting..." << endl;abort();
}cerr << "This is what happens after the try block." << endl;
}
int main() {
g(-5);                                g(5);g(7);g(9);
}
Output:src/exceptions/example> ./example
Invalid size for Vector: -5This is what happens after the try block.in try block, doing vector calculations. m= 5<1, 4, 7, 10, 13>Subscript out of range!This is what happens after the try block.in try block, doing vector calculations. m= 7<1, 4, 7, 10, 13, 16, 19>Size mismatch for Vector addition!This is what happens after the try block.in try block, doing vector calculations. m= 9<1, 4, 7, 10, 13, 16, 19, 22, 25>Unhandled error! Aborting...Abortedsrc/exceptions/example> 654321.4 EXCEPTIONS
493
continuedezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 493
Expect RangeError to be thrown.
Expect SizeMatchError to be thrown.Use up most of the available memory.Expect bad_alloc to be thrown.Always catch exception objects by reference.
Expect BadSizeError to be thrown.
Because we did not have a handler for the bad_alloc exception, the default han-
dler was called.
EXERCISE: TRY/CA TCH
Do some experiments with the code in Example 21.6. For example:
1.What happens if we omit the default handler?
2.What happens if we omit one of the exception types from the throw() list in
the member function header?
21.4.5 More about throw
Syntactically, throw can be used in three ways:
1.throw expression . This form raises an exception. The innermost try
block in which an exception is raised is used to select the catch state-
ment that handles the exception.
2.throw . This form, with no argument, is used inside a catch to rethrow
the current exception. It is typically used when you want to propagate theexception to the next outer level.
3.returnType functionName (arglist ) 
throw (exceptionType list ). An excep-
tion specification is part of the function signature. A throw following a
function prototype indicates that the exception could be thrown frominside the function body and, therefore, should be handled by client code.
This construct is somewhat controversial. The C++ developer commu-
nity is split about when it is a good idea to use exception specifications.
In Example 21.7, we make use of the fact that C++ allows composite objects to be
thrown. We define a class specifically so that we can throw an object of that type ifnecessary. We use the quadratic formula to compute one of the roots of a quad-ratic equation, and we must be careful not to allow a negative value to be passedto the square root function.654321CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
494ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 494
EXAMPLE 21.7 src/exceptions/throw0/throw0.cpp
[....]
class NegArg {
public:
NegArg(double d) : m_Val(d), m_Msg("Negative value") {}QString getMsg() {
return QString("%1: %2").arg(m_Msg).arg(m_Val);
}
private:
double m_Val;QString m_Msg;
} ;
double discr(double a, double b, double c) {
double d = b * b - 4 * a * c;if(d < 0)
throw NegArg(d);
return d;
}
double quadratic_root1(double a, double b, double c) {
return (-b + sqrt(discr(a,b,c))/(2 * a));
}
int main() {
try {
cout << quadratic_root1(1, 3, 1) << endl;cout << quadratic_root1(1, 1, 1) << endl;
}catch(NegArg& narg) {
cout << "Attempt to take square root of "
<< narg.getMsg() << endl;
}cout << "Just below the try block." << endl;
}
Output:-1.88197
Attempt to take square root of Negative value: -3
Just below the try block.
The NegArg object thrown by the discr() function persists until the handler
with the appropriate signature, catch(NegArg) , exits. The NegArg object is
available for use inside the handler—in this case to display some informationabout the problem. In this example, the throw prevented the program fromattempting to compute the square root of a negative number.21.4 EXCEPTIONS
495ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 495
When a nested function throws an exception, the process stack is “unwound”
until an exception handler with the right signature is found.
21.4.6 Rethrown Exceptions
Using throw without an expression rethrows a caught exception. The catch that
rethrows the exception presumably cannot complete the handling of the existingexception, so it passes control to the nearest surrounding 
try block where a suit-
able handler with the same signature (or ellipsis) is invoked. The exception expres-sion continues to exist until all handling is completed.
If the exception handler does not terminate the execution of the program, exe-
cution resumes below the outermost 
try block that last handled the rethrown
expression. See Example 21.8.
EXAMPLE 21.8 src/exceptions/throw2/throw2.cpp
#include <iostream>
void foo() {
int i, j;i = 14;j = 15;throw i;
}
void call_foo() {
int k;k = 12;foo();
}
int main() {
using namespace std;try {
cout << "In the outer try block" << endl;try {
call_foo();  
}catch(int n) {
cout << "I can’t handle this exception!" << endl;throw;
}
}catch(float z) {
cout << "Wrong catch!" << endl;
}catch(char s) {
cout << "This is also wrong!" << endl;
}1CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
496ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 496
catch(int n) {
cout << "\ncaught it " << n << endl;
}cout << "Just below the outermost try block." << endl;
}
Output:In the outer try block
I can’t handle this exception!
caught it 14
Just below the outermost try block.
foo exited with i and j destroyed.
Remember that we do not recommend throwing basic types such as int,
float, and char. A single number or character conveys little informationand does not explain itself to someone reading the code.We violate thatrule in some of our examples only to keep them as simple and brief as
possible.
21.4.7 Exception Expressions
As we just saw, it is often a good idea to  package exception information as an object
of a class. The thrown expression can then provide information that the handlercan use when it executes. For example, such a class could have several constructors.The 
throw can supply appropriate arguments for the particular constructor that
fits the exception.121.4 EXCEPTIONS
497
class VectError {
private:
int m_Ub, m_Index, m_Size;
public:
VectError(Error er, int ix, int ub); // subscript out of boundsVectError(Error er, int sz);         // out of memoryenum Error { BOUNDS, HEAP, OTHER }  m_ErrType;. . .
};
With such a class definition, an exception can be thrown as follows:
throw VectError(VectError::BOUNDS, i, ub);orthrow VectError(VectError::HEAP, size);ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 497
Notice that this is a temporary object that is being "thrown," but the
throw unwinds all stack objects until it gets a matching handler. How
can this work?
Exception objects are copied into a sp ecial location (not the stack) before the stack
is unwound.
It is possible to nest try blocks. If no matching handler is available in the
immediate try block, the search continues, stepwise, in each of the surrounding
try blocks. If no handler can be found that matches, then the default handler is
used, for example, terminate() .
EXERCISES: EXCEPTIONS 
1.It is often a good idea to organize exception types in hierarchies. This is done
for the same reasons that we organize any classes in hierarchies.
Assume that DerivedTypeError is derived from BaseTypeError .H o w
many errors can you find in the following sequence of handlers?
catch(void*)            // any char* would match
catch(char*)catch(BaseTypeError&)   // any DerivedTypeError& would matchcatch(DerivedTypeError&)
2.As we have seen, you can throw standard exceptions, custom classes, or even
basic types (but please don’t throw those). Example 21.9 demonstrates the useof custom exceptions inside the scope of a named namespace. This
namespace contains the main class definitions.
EXAMPLE 21.9 src/exceptions/registrar/registrar.h
[ . . . . ]
#include "exceptions.h"#include <QStringList>
namespace Registrar_Namespace {
class Student {
public:
Student(const QString& name);long getNumber() const;QString getName() const;// other members as needed ...CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
498ezus_138004_ch21.qxd  8/4/06  10:08 AM  Page 498
private:
long m_Number;             QString m_Name;static long nextNumber();   
};
class Registrar {
public:
static Registrar& instance();void insert(const Student& stu) throw (DupNumberException);void insert(const QString& name);void remove(const Student& stu) throw (NoStudentException);void remove(const long num)    throw (NoNumberException);bool isInList(const Student& stu) const;bool isInList(const QString& name) const;
QStringList report(QString name="all");// other members as needed
private:
Registrar() {};Registrar(const Registrar&);  Registrar& operator=(const Registrar&);QList<Student> m_List;
};
}[ . . . . ]
32121.4 EXCEPTIONS
499
student number
used by constructor
private constructors
In the next fragment, shown in Example 21.10, we added some exceptions to
the same namespace from another header file.
EXAMPLE 21.10 src/exceptions/registrar/exceptions.h
#ifndef EXCEPTIONS_H
#define EXCEPTIONS_H
#include <QString>namespace Registrar_Namespace {
class Exception {
public:
Exception (const QString& reason);virtual ~Exception () { }QString what () const;
private:
QString m_Reason;
};321
continuedezus_138004_ch21.qxd  8/4/06  10:09 AM  Page 499
class NoNumberException : public Exception {
public:
NoNumberException(const QString& reason);
};
class NoStudentException : public Exception {
public:
NoStudentException(const QString& reason);
};
class DupNumberException : public Exception {
public:
DupNumberException(const QString& reason);
};
}
#endif        //  #ifndef EXCEPTIONS_H
The implementation file shown in Example 21.11 is not complete but there is
enough code to get you started.
EXAMPLE 21.11 src/exceptions/registrar/registrar.cpp
/*  Selected implementation examples
This file is not complete! */
#include "registrar.h"namespace Registrar_Namespace {long Student::nextNumber() {      
static long number = 1000000;return ++number;
}
Registrar& Registrar::instance() {  
static Registrar onlyInstance;
return onlyInstance;
}
Exception::
Exception(const QString& reason) : m_Reason(reason) {}
QString Exception::what() const {
return m_Reason;
}
NoNumberException::
NoNumberException(const QString& reason) : Exception(reason) {}
NoStudentException::
NoStudentException(const QString& reason) : Exception(reason) {}21CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
500ezus_138004_ch21.qxd  8/4/06  10:09 AM  Page 500
DupNumberException::
DupNumberException(const QString& reason) : Exception(reason) {}
}
Without the above using decl, this would be “long Registrar_Namespace::Student::nextNumber.”
Implementation of Singleton factory method: This is the only way clients can create instances of
this Registrar.
Example 21.12 gives some client code to test these classes.
EXAMPLE 21.12 src/exceptions/registrar/registrarClientCode.cpp
#include "registrar.h"
#include <qstd.h>
int main() {
using namespace qstd;using namespace Registrar_Namespace;Registrar& reg = Registrar::instance();while(1) {
try {
reg.insert("George");reg.insert("Peter");reg.insert("Mildred");Student s("George");reg.insert(s);reg.remove(1000004);reg.remove(1000004);reg.remove(s);QStringList report = reg.report();foreach (QString line, report) {
cout << line << endl;
}
} catch (NoStudentException& nse) {
cout << nse.what() << endl;
}catch (NoNumberException& nne) {
cout << nne.what() << endl;
}catch (DupNumberException& dne) {
cout << dne.what() << endl;
}
}
}
a. There are missing function definitions, which need to be defined before this
application is built. Define the missing functions.
b. Complete and test the client code, and ensure that it works under exceptional
circumstances.2121.4 EXCEPTIONS
501ezus_138004_ch21.qxd  8/4/06  10:09 AM  Page 501
CHAPTER 21: STATEMENTS AND CONTROL STRUCTURES
502
REVIEW QUESTIONS
1. What is the difference between a compound statement and a simple
statement?
2. How can you guarantee that at least one case will be executed for any
given switch value?
3. What are the advantages and disadvantages of the three iteration struc-
tures? For each, discuss the kinds of situations that would lead you toprefer using it rather than the other two.
4. What happens if a thrown exception is not caught?5. How can an author of client code know what exceptions need to be
handled from a function?
6. How can you catch an unforseen exception?7. In response to a throw, what happens to the stack?8. After an exception is handled, how do we return to the location of the
throw ?
9. Why should we always catch objects by reference or pointer?
10. What happens when a destructor throws an exception?11. What happens when a constructor throws an exception?12. Which types are preferable for throwing, basic types or object types?
Explain the advantages of one over the other.ezus_138004_ch21.qxd  8/4/06  10:09 AM  Page 502
50322.1 Pointer Pathology . . . . . . . . . . . . . . . . . 504
22.2 Further Pointer Pathology 
with Heap Memory . . . . . . . . . . . . . . . . 506
22.3 Memory Access Summary . . . . . . . . . . 50922.4 Introduction to Arrays . . . . . . . . . . . . . 50922.5 Pointer Arithmetic . . . . . . . . . . . . . . . . . 51022.6 Arrays, Functions, and 
Return Values . . . . . . . . . . . . . . . . . . . . . 511
22.7 Different Kinds of Arrays . . . . . . . . . . . 51322.8 Valid Pointer Operations . . . . . . . . . . . 51322.9 What Happens If new Fails? . . . . . . . . 51522.10 Chapter Summary . . . . . . . . . . . . . . . . . 51922CHAPTER 22
Memory Access
Arrays and pointers are low-level building blocks ofC programs that provide fast access to hardwarememory. This chapter discusses the different ways toorganize and access memory.ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 503
Direct manipulation of memory entails some serious risks and requires good
practices and thorough testing to avoid serious errors. Improper use of pointersand dynamic memory can cause program crashes that result from heap corrup-tion and memory leaks. Heap corruption is especially difficult to debug because itgenerally leads to segmentation faults that halt the program at a point in the codethat may be far from the point at which the heap became corrupted.
Both Qt and Standard Library container classes permit the safe use of dynamic
memory without adversely affecting performance.
1Arrays are used to implement
most container classes but are hidden from client code. The safety factors come
from the careful design of each container API so that actions that might producememory problems are not permitted.
Qt offers many containers, ranging from high-level template classes such as the
ones we discussed in Section 10.2 to low-level containers such as 
QBitArray and
QByteArray .
Generally, when writing applications that reuse those containers, it is easy to
avoid the use of arrays entirely. When Qt is not available, or when you are writingan interface to C code, you may need to use arrays and pointers and work directlywith allocated memory.
22.1 Pointer Pathology
In Section 1.12 we introduced pointers and demonstrated some of the basics of
working with them. We now look at two short code examples to demonstrate someof the weird and dangerous things that can happen when pointers are not handledcorrectly.
EXAMPLE 22.1 src/pointers/pathology/pathologydecls1.cpp
[ . . . . ]
int main() {
int a, b, c; int* d, e, f;  
21
1In the sequel, whenever we use the term container , with no further qualification, we mean Qt or
Standard Library container.ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 504
int *g, *h;  
int* i, * j; 
return 0;
}
As expected, this line creates three ints.
This line creates one pointer to an int and two ints. (!)This line creates two pointers to int.
This line also creates two pointers to int.
Example 22.1 shows a few of the many ways one can declare pointers. A beginner
would be forgiven for thinking the second line of main() creates three pointers—
after all, in line one, similar syntax creates three integers. However, when multiplevariables are declared on one line, the * type modifier symbol applies only to thevariable that immediately follows it, not the type that precedes it. Since whitespace isignored by the compiler, the location of whitespace can help or confuse the reader.
EXAMPLE 22.2 src/pointers/pathology/pathologydecls2.cpp
[ . . . . ]
int main() {
int myint = 5;int *ptr1 = &myint;cout << "*ptr1 = " << *ptr1 << endl;int anotherint = 6;
//    *ptr1 = &anotherint;  
int *ptr2;             
cout << "*ptr2 = " << *ptr2 << endl;*ptr2 = anotherint;   
int yetanotherint = 7;
int *ptr3;ptr3 = &yetanotherint;  cout << "*ptr3 = " << *ptr3 << endl;*ptr1 = *ptr2;       cout << "*ptr1 = " << *ptr1 << endl;
return 0;
}[ . . . . ]
error—invalid conversion from int* to int
uninitialized pointerunpredictable resultsregular assignment
dangerous assignment!543215432143214322.1 POINTER PATHOLOGY
505ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 505
Example 22.2 is broken up into three sections. Only the first and third sections are
equivalent; the second contains a common beginner’s mistake.
src/pointers/pathology> g++ pathologydecls2.cpp
pathologydecls.cpp: In function 'int main()':pathologydecls.cpp:17: error: invalid conversion from 'int*' to 'int'src/pointers/pathology>
After commenting out the invalid conversion, we can try again.
*ptr1 = 5*ptr2 = 1256764*ptr3 = 7*ptr1 = 6
The value of *ptr2 is unpredictable.
Dereferencing uninitialized pointers for read purposes is bad enough, but then
we wrote to it. This is a form of memory corruption , which can cause problems
later in the program’s execution. Notice the inconsistent value that *ptr1 obtained
from *ptr2.
22.2 Further Pointer Pathology 
with Heap Memory
The result of applying delete to a pointer that holds the address of a valid object
in the heap is to change the status of that heap memory from “in use” to “available.”After 
delete has been applied to a pointer, the state of that pointer itself is
undefined . The pointer may or may not still store the address of that deleted mem-
ory, so a second application of delete to the same pointer may cause run-time
problems—possibly heap corruption.
In general, the compiler cannot detect attempts to apply delete repeatedly to
the same object, especially if that piece of memory (or a part thereof) has sincebeen reallocated. T o help avoid the very undesirable consequences of a repeated
delete , it is good practice to assign NULL to a pointer immediately after it has
been deleted.
Ifdelete is applied to a null pointer, there is no action and no error.
Applying delete to a non-null pointer that was not returned by new produces
undefined results. In general, the compiler will not be able to determine whetherthe pointer was or was not returned by 
new, so undefined run-time behavior can
result. Bottom line: It is the programmer’s responsibility to use delete correctly .
One of the richest sources of run-time errors is the production of memory
leaks . A memory leak is produced when a program causes memory to be allocated
and then loses track of that memory so that it can neither be accessed nor deleted.CHAPTER 22: MEMORY ACCESS
506ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 506
An object that is not properly deleted will occupy memory until the process
terminates.
Some programs (e.g., operating systems) stay active for a long time. Suppose
such a program contains a frequently executed routine that produces a memoryleak each time it is run. The heap will gradually become perforated with blocks ofinaccessable, undeleted memory. At some point a routine that needs a substantialamount of contiguous dynamic memory may have its request denied. If the pro-gram was not expecting an event like that, it may not be able to continue.
The operators 
new and delete give the C++ programmer increased power as
well as increased responsibility.
Here is some sample code that illustrates a memory leak. After defining a cou-
ple of pointers, memory will look a little like Figure 22.1.
int* ip = new int;        // allocate space for an int
int* jp = new int(13);    // allocate and initializecout << ip  << '\t'  <<  jp  << endl;22.2 FURTHER POINTER PATHOLOGY WITH HEAP MEMORY
507
FIGURE 22.1 Initial values of memory 
Now we add one more line of code.
jp = new int(3);   // reassign the pointer - MEMORY LEAK!!
After executing the single line above, our memory looks like Figure 22.2.
FIGURE 22.2 Memory after leak0x8049d38
0x8049e48
jpip Location: 0x8049d38
Location: 0x8049e4813?
0x8049d38
0x8049e58
jpip Location: 0x8049d38
Memory leak. 
Allocated memory with nothing pointing to it.
Location: 0x8049e4813
Location: 0x8049e583?ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 507
EXAMPLE 22.3 src/pointers/pathology/pathologydemo1.cpp
#include <iostream>
using namespace std;
int main() {
int* jp = new int(13);  cout << jp << '\t' << *jp << endl;delete jp;delete jp;           jp = new int(3);      cout << jp << '\t' << *jp << endl;jp = new int(10);    cout << jp << '\t' << *jp << endl;int* kp = new int(17);cout << kp << '\t' << *kp << endl;return 0;
}
Output:OOP> g++ pathologydemo1.cpp
OOP> ./a.out0x8049e08       130x8049e08       30x8049e08       10Segmentation faultOOP>
allocate and initialize
error: pointer already deletedReassign the pointer—MEMORY LEAK!
Reassign the pointer—MEMORY LEAK!
In Example 22.3, we deleted the pointer jptwice. The second deletion is a serious
error but the compiler did not catch it. That error corrupted the heap, made any fur-ther memory allocation impossible, and made the behavior of the program beyondthat point undefined . For example, notice that when we attempted to produce a
memory leak by reassigning the pointer
jp, we did not get any new memory. When
we attempted to introduce another pointer variable we got a segmentation fault.This is all undefined behavior and may be different on another platform or withanother compiler.43214321CHAPTER 22: MEMORY ACCESS
508ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 508
22.3 Memory Access Summary
Here is a list of the most important points that we have raised about memory access.
■The operators new and delete give the C++ programmer increased
power as well as increased responsibility.
■Improper use of pointers and dynamic memory can cause programcrashes that result from heap corruption and memory leaks.
■Qt and STL container classes permit the safe use of dynamic memorywithout adversely affecting performance.
■In a multiple variable declaration, the unary * operator applies only tothe variable that immediately follows it, not the type that precedes it.
■Dereferencing an uninitialized pointer is a serious error that may not becaught by the compiler.
■After delete has been applied to a pointer, the state of that pointer is
undefined.
■It is good practice to assign NULL to a pointer immediately after it has
been deleted.
■Applying delete to a non-null pointer that was not returned by new
produces undefined results.
■The compiler cannot be relied upon to detect the improper use of
delete , so it is the programmer’s responsibility to use delete correctly.
■A memory leak is produced when a program causes memory to be allo-cated and then loses track of that memory so that it can neither beaccessed nor deleted.
22.4 Introduction to Arrays
An array is a sequence of contiguous memory cells, all of the same size. Each cell
is called an array element ,o r  e n t r y .
When an array is declared, the size of the array must be made known. This can
be done by explicitly or by initialization:
int a[10]; // explicitly creates uninitialized cells a[0], 
// a[1],..., a[9]
int b[] = {1, 3, 5, 7}; // implicitly creates and initializes 
// b[0],..., b[3]
The array name is an alias for a const typed pointer to the first cell of the array.
A pointer declaration such as
int* ptr; 22.4 INTRODUCTION TO ARRAYS
509ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 509
only creates the pointer variable. There is no automatic default initialization of
pointer variables. It is an error to attempt to dereference an uninitialized pointer.
Array indices are relative offsets from the base address:
a[k] is equivalent to *(a + k) 
The following bit of code demonstrates an interesting aspect of array indices.
#include <iostream.h>
int main(){
int a[] = {10, 11, 12, 13, 14, 15};int* b = a + 1;cout << "a[3] = " << a[3] << endl
<< "b[3] = " << b[3] << endl;
}
Its output looks like this.
a[3] = 13b[3] = 14
Notice that bwas not declared as an array, but we can use the []operator anyway.
There is a special syntax for defining a dynamic array consisting of a given
number of elements of some type.
uint n;
ArrayType* pt;pt = new ArrayType[n];
This version of new allocates ncontiguous blocks of memory, each of size
sizeof(ArrayType) and returns a pointer to the first block. Each element of
the newly allocated array is given default initialization. T o properly deallocate this
array, it is necessary to use the syntax:
delete[] pt;
Using delete without the empty brackets to delete a dynamic array produces
undefined results.
22.5 Pointer Arithmetic
The result of applying the operators +,-,++,o r  --to a pointer depends on the
type of object pointed to. When an arithmetic operator is applied to a pointer pof
type T*,pis assumed to point to an element of an array of objects of type T.
■p+1 points to the next element of the array.
■p-1 points to the preceding element of the array.
■In general, the address p+k is k*sizeof( T)bytes larger than the
address p.
Subtraction of pointers is defined only when both pointers point to elements ofthe same array. In this case the difference is an int equal to the number of arrayelements between the two elements.CHAPTER 22: MEMORY ACCESS
510ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 510
The results of pointer arithmetic are undefined outside the context of an array.
It is the responsibility of the programmer to ensure that pointer arithmetic is usedappropriately.
EXAMPLE 22.4 src/arrays/pointerArith.cpp
[ . . . . ]
int main()  {
using namespace std;int y[] = {3, 6, 9};int x = 23;int* px;px = &y;  px = y; cout << "What's next: " << *++px << endl;cout << "What's next: " << *++px << endl;cout << "What's next: " << *++px << endl;cout << "What's next: " << *++px << endl;return 0;
}
The & is redundant here.
y, or any array name, is an “alias” for a pointer to the first element in the array.
If we ran the above example, we might2see something like this:
What's next: 6What's next: 9What's next: 23What's next: -1073751080
Notice that neither the compiler nor the run-time system reported an error mes-
sage. C++ happily reads from arbitrary memory addresses and reports them in thetype of your choice, giving the C++ developer great power and many opportunitiesto make great errors.
22.6 Arrays, Functions, and Return Values
As in C, the declared return type of a function cannot be array (e.g., it cannot look
like int[] or char[] or Point[] ). Returning (addresses to) arrays from func-
tions that are pointer-typed is allowed. However, this is not recommended in thepublic interface of a class.
An array is a piece of unprotected memory. A class that encapsulates that
memory should not have public member functions that return pointers to it.Doing so opens up the possibility for incorre ct use of the memory by client code.212122.6 ARRAYS, FUNCTIONS, AND RETURN VALUES
511
2In general, accessing memory beyond the boundary of an array is nonportable, and since that is what
we are doing (on purpose), the results will also be nonportable.ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 511
A properly designed class completely encapsulates all interactions with any arrays
used in the implementation of that class.
Arrays are never passed to functions by value—the array elements will not be
copied. If a function is called with an array in its argument list, for example,
int a[] = {10, 11, 12, 13, 14, 15};
[ ... ]f(a[]);[ ... ]
then the array expression is interpreted as a pointer to the first element in the
array.
EXAMPLE 22.5 src/arrays/returningpointers.cpp
#include <assert.h>
int paramSize;void bar(int *integers) {
integers[2]=3;                   
}
int* foo(int arrayparameter[]) {
using namespace std;paramSize = sizeof(arrayparameter);bar(arrayparameter);                return arrayparameter;            
}
int main(int argc, char** argv) {
int intarray2[40] = {9,9,9,9,9,9,9,2,1};char chararray[20] = "Hello World";  int intarray1[20];             int* retval;                  
//    intarray1 = foo(intarray2);       
retval = foo(intarray2);
assert (retval[2] == 3);assert (retval[2] = intarray2[2]);assert (retval == intarray2);int refSize = getSize(intarray2);assert(refSize == paramSize);return 0;
}
Change the third element in the incoming array.
Pass an array by pointer to a function.Return an array as a pointer from a function.special syntax for initializing char arrayuninitialized memoryuninitialized pointer
Error—intarray1 is like a // char* const. It cannot be assigned to.76543217654321CHAPTER 22: MEMORY ACCESS
512ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 512
22.7 Different Kinds of Arrays
Arrays of primitive types, such as int,char , and byte , are used to implement
caches. Arrays of objects are supported in the C++ language for backward com-patibility with C’s arrays of
struct s, but are only used for uniform collections of
identical structures, rather than collections of similar polymorphic objects.
If you need random access to the stored items, QList (from Qt) or vector
(from STL) can be used instead of an array. Both are implemented as dynamic arraysunder the covers. It is preferable to use those containers in favor of arrays wheneverpossible, because containers correctly and saf ely allocate and free memory for you.
22.8 Valid Pointer Operations
Here is a list of the operations that can prop erly be performed with pointers.
Creation The initial value of a pointer has three possible sources:
■A const pointer such as an array name
■An address obtained by using the address-of operator, &
■A value obtained by a dynamic memory allocation operator (e.g., new)
Assignment
■A pointer can be assigned the address stored by a pointer of the same
type or of a derived type.
■A variable of type void* can be assigned a pointer of any type without anexplicit cast.
■A (non-void*) pointer can be assigned the address stored by a pointer ofa different (and non-derived) type only with an explicit cast.
■An array name is a const pointer and cannot be assigned to.
■A NULL pointer (value 0) can always be assigned to any pointer. (Note:Stroustrup recommends that 0 be used instead of NULL.)
Arithmetic
■Incrementing and decrementing a pointer: p++ and p--
■Adding or subtracting an integer: p + k andp - k
■Such expressions are defined only if the resulting pointer value is within
the range of the same array. The only exception to this rule is that apointer is allowed to point to the memory cell that is one positionbeyond the end of the array as long as no attempt is made to dereferencethat address.22.8 VALID POINTER OPERATIONS
513ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 513
■For subtraction, two pointers that point to two members of an array can
be subtracted, yielding an int that represents the number of array ele-
ments between the two members.
Comparison
■Pointers to entries of the same array can be compared with ==,!=,<,>,
etc.
■Any pointer can be compared with 0.
Indirection
■Ifpis a pointer of type T*, then *pis a variable of type Tand can be
used on the left side of an assignment.
Indexing
■A pointer pcan be used with an array index operator p[i] where iis 
an int.
■The compiler interprets such an expression as *(p+i) .
■Indexing makes sense and is defined only in the context of an array, butthe compiler will not prevent its use with non-array pointers where theresults are undefined.
The following bit of code in Example 22.6 demonstrates this last point rather
clearly.
EXAMPLE 22.6 src/arrays/pointerIndex.cpp
#include <iostream>
using namespace std;
int main()  {
int x = 23;int* px = &x;cout << "px[0] = " << px[0] << endl;cout << "px[1] = " << px[1] << endl;cout << "px[-1] = " << px[-1] << endl;return 0;
}
Output:src/arays> g++ pointerIndex.cc // compile & run on a Sun station
src/arays> a.out
px[0] = 23px[1] = 5px[-1] = -268437516
src/arays> g++ pointerIndex.cc // compile & run on a Linux box
src/arays> ./a.outCHAPTER 22: MEMORY ACCESS
514ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 514
px[0] = 23
px[1] = -1073743784px[-1] = -1073743852
src/arays>
22.9 What Happens If new Fails?
Section 21.4
Every book on C++ has a section on handling new failures. The accepted wisdom
for how to handle such failures tends to vary, because the behavior of a C++ pro-gram when it runs out of memory is not the same from one platform to another.
We begin our discussion with a caveat. When a C++ program has a memory
leak and runs for a long time, eventually there will be no memory available to it.Y ou might think that would cause an exception to be thrown. However most mod-ern operating systems (including *nix and Win32) implement virtual memory,
which permits the operating system, when its random access memory (RAM) fills
up beyond some preset level, to copy the contents of memory that has not beenused recently to a special place on the system disk drive. This substitution of rela-tively slow memory (disk storage) for fast memory (RAM) is generally invisible to
the user (except for the performance degradation). If the demands on the systemRAM are especially heavy, the OS will use virtual memory to keep satisfying allo-cation requests until the system starts thrashing.
3When this happens, the whole
system grinds to a halt until the system administrator can intervene and kill thememory-eating process. At no point will any of the memory allocation failure-
handling code be reached in the errant process. It is for this reason that memoryallocation errors are handled differe ntly, or not at all, in various applications.
Having said this, the ANSI/ISO standard does specify that the free store oper-
ator 
new should throw a bad_alloc exception instead of returning NULL if it
cannot carry out an allocation request. If a thrown bad_alloc exception is not
caught by a catch() block, the default exception handler is called, which could be
either abort() or terminate() .
Example 22.7 demonstrates this feature of C++.22.9 WHAT HAPPENS IF NEW FAILS?
515
3When a system is constantly swapping memory back and forth to disk, preventing other I/O from
happening, we call that “thrashing.”ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 515
EXAMPLE 22.7 src/newfailure/bad-alloc1.cpp
#include <iostream>
#include <new>using namespace std;
void memoryEater() {
int i = 0;double* ptr;try {
while(1) {
ptr = new double[50000000];cerr << ++i << '\t' ;
}
} catch (bad_alloc& excpt) {
cerr << "\nException occurred: "<< excpt.what() << endl;
}
}
int main() {
memoryEater();  cout << "Done!" << endl;return 0;
}
Output:src/newfailure> g++ bad-alloc1.cpp
src/newfailure> ./a.out1       2       3       4       5       6       7Exception occurred: St9bad_allocDone!src/newfailure>
Try to use up the memory.
22.9.1 set_new_handler(): Another Approach 
to new Failures
We can specify what new should do when there is not enough memory to satisfy
an allocation request. When new fails, it first calls the function specified by
set_new_handler() .I fnew_handler has not been set, a bad_alloc object
is thrown that can be queried, as shown in Example 22.7, for more information bycalling one of its member functions. Example 22.8 shows how to specify our own
new_handler .11CHAPTER 22: MEMORY ACCESS
516ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 516
EXAMPLE 22.8 src/newfailure/setnewhandler.cpp
#include <iostream>
#include <cstdlib>#include <new>using namespace std;
void memoryEater() {
int i = 0;double* ptr;while(1) {
ptr = new double[50000000];cerr << ++i << '\t' ;
}
}
void out_of_store() {
cerr << "\noperator new failed: out of store\n";exit(1);
}
int main() {
set_new_handler(out_of_store);memoryEater(); cout << "Done!" << endl;return 0;
}
Output:src/newfailure> g++ setnewhandler.cpp
src/newfailure> ./a.out1       2       3       4       5       6       7operator new failed: out of store
OOP>
Note the absence of a try block.
EXERCISE: SET_NEW_HANDLER()—ANOTHER
APPROACH TO NEW FAILURES
What happens if the last command in the out_of_store() function is not
exit() ?
22.9.2 Using set_new_handler and bad_alloc
Example 22.9 throws a standard exception from the new_handler .22.9 WHAT HAPPENS IF NEW FAILS?
517ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 517
EXAMPLE 22.9 src/newfailure/bad-alloc2.cpp
#include <iostream>
#include <cstdlib>#include <new>using namespace std;
void memoryEater() {
int i = 0;double* ptr;try {
while(1) {
ptr = new double[50000000];cerr << ++i << '\t' ;
}
} catch(bad_alloc& excpt) {
cerr << "\nException occurred: "<< excpt.what() << endl;
}
}
void out_of_store() {
cerr << "\noperator new failed: out of store\n";throw bad_alloc();
}
int main() {
set_new_handler(out_of_store);memoryEater(); cout << "Done!" << endl;return 0;
}
Output:src/newfailure> g++ bad-alloc2.cpp
src/newfailure> ./a.out1       2       3       4       5       6       7operator new failed: out of store
Exception occurred: St9bad_alloc
Done!
src/newfailure>
22.9.3 Checking for null: The Updated Way 
to Test for new Failures
Y ou may encounter the old null-checking style for detecting failures of new in
legacy code. That’s a sure sign that there are going to be problems with mainte-nance. Fortunately, there is a simple way to update that old approach.CHAPTER 22: MEMORY ACCESS
518ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 518
In Example 22.10, we add the qualifier (nothrow) to the allocation statement.
As its name suggests, this qualifier suppresses the throwing of bad_alloc and
allows new to return a 0pointer if it fails.
EXAMPLE 22.10 src/newfailure/nullchecking.cpp
#include <iostream>
#include <new>using namespace std;
void memoryEater() {
int i = 0;double* ptr;while(1) {
ptr = new (nothrow) double[50000000];if (ptr == 0)
return;
cerr << ++i << '\t' ;
}
}
int main() {
memoryEater(); cout << "Done!" << endl;return 0;
}
Output:src/newfailure> g++ nullchecking.cpp
src/newfailure> ./a.out1       2       3       4       5       6       7      Done!
src/newfailure>
22.10 Chapter Summary
Here is a list of the most important points that we have raised in this chapter.
■An array is a sequence of contiguous memory cells, all of the same size.
■The array name is an alias for a const-typed pointer to the first cell of the
array.
■There is no automatic default initialization of pointer variables.
■Array indices are relative offsets from the base address.
■Array subscripts are valid only when used to access members of an arrayand only within the declared limits of the array.22.10 CHAPTER SUMMARY
519ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 519
■The standard does not guarantee that the compiler will catch attempts to
use the subscript operator with a pointer that is not an array.
■Arrays are passed to and returned from functions as pointers.
■It is possible to apply the arithmetic operators +,-,++, and --to an
array pointer, subject to sensible limitations.
■The results of pointer arithmetic are undefined outside the context of anarray.
■The standard does not guarantee that the compiler will catch attempts tomisuse pointer arithmetic.
■Pointers can acquire values only in the following ways:
■by initialization when they are first created
■by assignment after they exist
■as a result of pointer arithmetic
■A dynamic array of size elements of type Tis allocated using the syntax
uint size;
T* pt;pt = new T[size] ;
■Each element of the dynamic array is given default initialization when
the array is allocated.
■T o deallocate such a dynamic array it is necessary to use the syntax
delete[] pt;
■The ANSI/ISO standard requires the free store operator new to throw a
bad_alloc exception instead of returning NULL if it cannot carry out anallocation request.
■The qualified operator new(nothrow) will return 0 if it cannot carry
out an allocation request.
■Dynamic arrays should be carefully encapsulated in classes that aredesigned with proper destructors, copy constructors, and copy assignmentoperators.CHAPTER 22: MEMORY ACCESS
520ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 520
REVIEW QUESTIONS
521
REVIEW QUESTIONS
1. What is defined in the following statement?
int* p, q;
2. What is a memory leak? How does it happen?
3. How do the +,-,++, and --operators work differently on pointers
versus regular numbers?
4. What happens if delete is applied to a pointer that has just been deleted?5. When an array is passed to a function as a parameter, what is being
copied onto the stack?
6. What is dynamic memory? How do you obtain it in C++?7. What happens when a program runs out of memory? How can a
program recover from such a situation?
8. Under what situations is it appropriat e to check whether a value from
new is null?ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 521
ezus_138004_ch22.qxd  8/4/06  10:09 AM  Page 522
52323.1 Virtual Pointers and Virtual Tables. . . . 524
23.2 Polymorphism and virtual 
Destructors . . . . . . . . . . . . . . . . . . . . . . . . 526
23.3 Multiple Inheritance . . . . . . . . . . . . . . . . 52823.4 public, protected, and private 
Derivation . . . . . . . . . . . . . . . . . . . . . . . . . 53623CHAPTER 23
Inheritance in Detail
This chapter formalizes and details some of the con-cepts introduced earlier in Chapter 6. We explain howconstructors, destructors, and copy assignment oper-ators are generated and used by derived classes. Wediscuss how the keywords public ,private ,a n d
protected can be used for base classes as well as
class members. We also provide examples of multipleinheritance.ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 523
23.1 Virtual Pointers and Virtual Tables
Each class that contains methods ( virtual functions) has a virtual jump table,
or vtable , which is generated as part of the “lightweight” C++ execution environ-
ment. The vtable can be implemented in a number of ways, but the simplestimplementation (which is often the fastest and most lightweight) contains a list ofpointers to all methods of that class. Depending on the optimization policies, itmay contain additional information to aid in debugging. The compiler substitutesfunction names with indirect (relative to the vtable list) references to method calls.
With this in mind, we can define polymorphic type explicitly as a class that
contains one or more methods and, thus, requires the use of a vtable. Eachinstance of a polymorphic type has a 
typeid , which can be quite naturally imple-
mented as the address of the vtable for the class.
vtable instead of switch
To implement indirect method calling through vtables, the compiler gener-
ates a jump table, which is similar to a switch statement, for each polymor-
phic class. Programmers can often exploit vtables instead of writing theirown 
switch statements or large compound conditionals. This is implicit in
a number of design patterns such as the Command, Visitor, Interpreter, andStrategy patterns.
A vtable cannot be built for a class unless the me thod definitions for all overrides
are fully defined and findable by the linker.
The typeid of an object is set after the object’s constructor has executed. If
there are base classes, the typeid for an object may be set multiple times, after
each base class initialization. We will use the classes defined in Example 23.1 todemonstrate that calling a 
virtual function from a constructor or destructor
can have unexpected consequences.
ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 524
EXAMPLE 23.1 src/derivation/typeid/vtable.h
[ . . . . ]
class Base {
protected:
int m_X, m_Y;
public:
Base();virtual ~Base();virtual void virtualFun() const;
};
class Derived : public Base {
int m_Z;
public:
Derived();~Derived();void virtualFun() const ;
};
[ . . . . ]
Example 23.2 shows what happens when a virtual function is called from a
base class constructor or destructor.
EXAMPLE 23.2 src/derivation/typeid/vtable.cpp
#include <QString>
#include <qstd.h>using namespace qstd;#include "vtable.h"
Base::Base() {
m_X = 4;m_Y = 12;cout << " Base::Base: " ;virtualFun();
}
Derived::Derived() {
m_X = 5;m_Y = 13;m_Z = 22;
}
void Base::virtualFun() const {
QString val=QString("[%1,%2]").arg(m_X).arg(m_Y);cout << " VF: the opposite of Acid: " << val << endl;
}
void Derived::virtualFun() const {
QString val=QString("[%1,%2,%3)")23.1 VIRTUAL POINTERS AND VIRTUAL TABLES
525
continuedezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 525
.arg(m_X).arg(m_Y).arg(m_Z);
cout << " VF: add some treble: " << val << endl;
}
Base::~Base() {
cout << " ~Base() " << endl;virtualFun();
}
Derived::~Derived() {
cout << " ~Derived() " << endl;
}
int main() {
Base b;Derived d;
}
In the output that follows, we see that the derived VF: does not get called from
Base::Base(), because the base class initializer is inside an object that is not yet a
Derived instance.
Base::Base:  VF: the opposite of Acid: [4,12]
Base::Base:  VF: the opposite of Acid: [4,12]~Derived()~Base()VF: the opposite of Acid: [5,13]~Base()VF: the opposite of Acid: [4,12]
Calling virtual methods from destructors is also not recommended. In the pre-
ceding output, we can see that the base virtualFun is always called from the base
class constructors or destructor . Dynamic binding does not happen inside con-
structors or destructors.
23.2 Polymorphism and virtual Destructors
When operating on classes in inheritance hierarchies, we often maintain contain-
ers of base class pointers that hold addresses of derived objects.
Example 23.3 defines a Bank class that has a container of various kinds of
Account .CHAPTER 23: INHERITANCE IN DETAIL
526ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 526
EXAMPLE 23.3 src/derivation/assigcopy/bank.h
#ifndef BANK_H
#define BANK_H#include <QList>class Account;
class Bank {
public:
Bank& operator<< (Account* acct);  ~Bank();
private:
QList<Account*> m_Accounts;
};#endif
This is how we add object ptrs into m_Accounts.
Bank is able to perform uniform operations on its collected Account s by calling
virtual methods on each one.
EXAMPLE 23.4 src/derivation/assigcopy/bank.cpp
[ . . . . ]
#include "bank.h"
#include "account.h"
Bank::~Bank() {
foreach (Account* acct, m_Accounts) {
delete acct;
}m_Accounts.clear();
}
In Example 23.4, delete acct causes an indirect call to the destructor of
Account , as well as the subsequent release of allocated memory. However, while
every address in the list is an Account , some (perhaps all) might point to derived-
class objects and therefore requir e derived-class destructor calls.
If the destructor is virtual , the compiler allows run-time binding on the
destructor call, instead of simply calling Account::~Account() on each one.1123.2 POL YMORPHISM AND VIRTUAL DESTRUCTORS
527ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 527
EXAMPLE 23.5 src/derivation/assigcopy/bank.cpp
[ . . . . ]
Bank& Bank::operator<< (Account* acct) {
m_Accounts << acct;return *this;   
}
int main(int argc, char* argv[]) { 
Bank b;Account* a1 = new Account(1, 423, "Gene Kelly");JointAccount *a2 = new JointAccount(2, 1541, "Fred Astaire","Ginger Rodgers");b << a1;b << a2;
}
At this point, the bank and all the accounts are destroyed.
Without declaring ~Account() to be virtual in the base class, we would get an
incorrect result from running Example 23.5.1
Closing Acct - sending e-mail to primary acctholder:Gene Kelly
Closing Acct - sending e-mail to primary acctholder:Fred Astaire
By making the destructor virtual , both types of Account will get destroyed
properly and, in this example, both account holders of a joint account will getproper e-mail notifications when the 
Bank is destroyed.
Closing Acct - sending e-mail to primary acctholder:Gene Kelly
Closing Joint Acct - sending e-mail to joint acctholder:GingerRodgersClosing Acct - sending e-mail to primary acctholder:Fred Astaire
If you declare one or more virtual methods in a class, you should
define a virtual destructor for that class, even if it has an empty body.
23.3 Multiple Inheritance
Multiple inheritance is a form of inheritance in which a class inherits the struc-
ture and behavior of more than one base class.11CHAPTER 23: INHERITANCE IN DETAIL
528
1Compilers report a missing virtual in the destructor as a warning, and the behavior is undefined,
so you may not see the same thing on your system.ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 528
Common uses of multiple inheritance:
■For crossing the functionality of very different classes with little overlap,
such as in Figure 23.1.
■For implementing a common “pure interface” (class with only pure
virtual functions) in a variety of different ways.223.3 MULTIPLE INHERITANCE
529
2As we see in Section 23.3.2.FIGURE 23.1 QWidget’s inheritance
Multiple inheritance hierarchies are more complex and are harder to design, imple-
ment, and understand than single inheritance hierarchies. They can be used to solvesome difficult design problems, but should not be  used if a simpler approach (such
as aggregation) is feasible. As with single inheritance, multiple inheritance definesa static relationship among classes. It cannot be changed at runtime.
23.3.1 Multiple Inheritance Syntax
The example in this section demonstrates multiple inheritance syntax and usage.
FIGURE 23.2 Window and ScreenRegion
The two base classes shown in Figure 23.2, Rectangle and ScreenRegion ,
each have particular roles to play on the screen. One class is concerned with shapeand location, while the other is concerned with color and visibility characteristics.A 
Window must be a Rectangle and a ScreenRegion . They are defined in
Example 23.6.QWidgetQPaintDevice QObject
WindowRectangle ScreenRegionezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 529
EXAMPLE 23.6 src/multinheritance/window.h
#include "color.h"
#include "point.h"
class Rectangle {
public:
Rectangle( Const Point& ul, int length, int width);Rectangle( const Rectangle& r) ;void move (const Point &newpoint);
private:
Point m_UpperLeft;int m_Length, m_Width;
};
class ScreenRegion {
public:
ScreenRegion( Color c=White);ScreenRegion (const ScreenRegion& sr);virtual color Fill( Color newColor) ;void show();void hide();
private:
Color m_Color;// other members...
};class Window: public Rectangle, public ScreenRegion {
public:
Window( const Point& ul, int len, int wid, Color c)
: Rectangle(ul, len, wid), ScreenRegion(c) {}  
Window( const Rectangle& rect, const ScreenRegion& sr)
: Rectangle(rect), ScreenRegion(sr) {}       
// Other useful member functions ...
};
Use base class ctors.
Use base class copy ctors.
There are some syntax items in the classHead of the derived class that deserve some
attention.
■An access specifier, e.g., public or protected , must appear before
each base class name if the derivation is not private.
■Default derivation is private .
■It is possible to have a mixture of public ,protected , and private
derivations.2121CHAPTER 23: INHERITANCE IN DETAIL
530ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 530
■The comma ( ,) character separates the base classes.
■The order of base class initialization is the order in which the base classes
are listed in the classHead .
Client code to put a Window on the screen is shown in Example 23.7.
EXAMPLE 23.7 src/multinheritance/window.cpp
#include "window.h"
int main() {
Window w(Point(15,99), 50, 100, Color(22));w.show();          w.move (Point(4,6));  return 0;
}
calls ScreenRegion::show();
calls Rectangle::move();
Member Initialization
Default initialization or assignment proceeds member by member in the order
that data members are declared in the class definition: First, base classes; then,
derived class members.
23.3.2 Multiple Inheritance with Abstract Interfaces
One situation where it is appropriate to use multiple inheritance is when more
than one abstract interface is needed. Figure 23.3 shows a class diagram based onthe MP3 Data Model assignment in Section 25.1.
FileTagger inherits the
DataObject/QObject for its signals and slots, as well as for its property()
and setProperty() functions. FileTagger also needs the Mp3Song interface
that defines all of the fields for which an ID3 tag should have getters/setters.Similarly,
Mp3File needs both the DataObject and the Mp3Song interfaces,
even though it is not connected to a physical MP3 file.212123.3 MULTIPLE INHERITANCE
531ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 531
Multiple inheritance can help reduce dependencies for client code. For exam-
ple, a client function can have an Mp3Song parameter without needing id3lib or
Qt in order to exploit the Mp3Song interface.Mp3Song , with only pure virtual
functions, enforces the interface on all derived classes. Separating the interface from
different implementations makes plugin-frameworks possible.
In Figure 23.3, QObject is one of the base classes that is multiply inher-
ited. One restriction Qt has is that QObject must only be inherited once
by each class; further, the QObject -derived base must be listed first in
the list of base classes. Breaking this rule will lead to strange errors from
the code generated by moc , the MetaObject compiler.
POINT OF DEPARTURE
Multiple inheritance with QObject is discussed further in Qt Quarterly .3
23.3.3 Resolving Multiple Inheritance Conflicts
Figure 23.4 shows a UML diagram where multiple inheritance is being used incor-
rectly, for both interface and implementation. T o make things even more compli-cated, we are inheriting from the same base class twice.CHAPTER 23: INHERITANCE IN DETAIL
532
FIGURE 23.3 MP3 data modelPlayListModel
Mp3SongQObject
DataObject
Mp3File FileT agger
- mTag : ID3_Tag*
- mFilename : QString*
3http://doc.trolltech.com/qq/qq15-academic.html#multipleinheritanceezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 532
FIGURE 23.4 Person–Student–Teacher23.3 MULTIPLE INHERITANCE
533
Here, the class GradTeachingFellow is derived from two classes: Student and
Teacher .
class GradTeachingFellow : public Student,
public Teacher {
// class member functions and data members
};
Name conflicts and design problems can arise from the improper use of multiple
inheritance. In the above example, getDepartment() function exists in both
Student and Teacher . The student could be studying in one department and
teaching in another, for example.
What happens when you call getDepartment() on a
GraduateTeachingFellow ?Person
+mName
+mBirthDate+mSex
+getName()
+getBirthDate()+getSex()
GradT eachingFellow
+getSupervisor()T eacher
+getRank()
+getDepartment()+getCourseInfo()Student
+getAddress()
+getDepartment()ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 533
GraduateTeachingFellow gtf;
Person* pptr = &gtf;Student * sptr = &gtf;;Teacher* tptr = &gtf;gtf.Teacher::getDepartment(); gtf.Student::getDepartment();sptr->getDepartment() tptr->getDepartment() pptr->getDepartment(); // ambiguous - run-time error if virtualgtf.getDepartment(); // Compiler error - ambiguous function call
The problem, of course, is that we have provided no getDepartment() func-
tion in the GradTeachingFellow class. When the compiler looks for a
getDepartment() function,Student and Teacher have equal priority.
Inheritance conflicts like these should be avoided because they lead to much
design confusion later. However, in this case they can also be resolved with the aidof scope resolution.
23.3.3.1 virtual Inheritance
In Figure 23.4, we inherited more than once from the same base class. There is
another problem with that model: redundancy. When we create instances of thismultiply inherited class, they might look like Figure 23.5.CHAPTER 23: INHERITANCE IN DETAIL
534
FIGURE 23.5 GradTeachingFellow—nonvirtual
Person has attributes that we wish to inherit only once. It makes no sense for 
a GradTeachingFellow to have two birthdates and two names. virtua l
inheritance allows us to avoid the redundancy.GradT eachingFellow
Student
T eacher
Grad T. F.+mName
+mBirthDate+mSex+mAddress+mDepartment+mName+mBirthDate+mSex+mRank+mDepartment+mCourseInfo+mSupervisorezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 534
The strange problems that can arise when multiple inheritance is used in con-
troversial ways, especially with the added complexities of virtual versus nonvirtualinheritance/functions, seem to have prompted the designers of Java to excludemultiple inheritance from their language. Instead, Java allows the programmer todefine an 
interface , which consists only of abstract (pure virtual ) functions.
A Java class can then use the implement sclause to implement as many interfaces
as it needs.
23.3.3.2 virtual Base Classes
A base class may be declared virtual .A  virtual base class shares its represen-
tation with all other classes that have the same virtual base class.
Add the keyword virtual in the classHead as shown in Example 23.8,
leaving all the other details of the class definitions the same.
EXAMPLE 23.8 src/multinheritance/people.h
#include "qdatetime.h"
class Person {
public:
Person(QString name, QDate birthdate)QObject(name.ascii()),m_Birthdate(birthdate) {}
Person(const Person& p) : QObject(p),
m_Birthdate(p.m_Birthdate) {}
private:
QDate m_Birthdate;
};
class Student : virtual public Person {  
// other class members
};
class Teacher : virtual public Person {  
// other class members
}
class GraduateTeachingFellow :
public Student, public Teacher {     
public:
GraduateTeachingFellow(const Person& p,
const Student& s, const Teacher& t):
Person(p), Students(s), Teacher(t) {}  
}
432123.3 MULTIPLE INHERITANCE
535
continuedezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 535
CHAPTER 23: INHERITANCE IN DETAIL
536
FIGURE 23.6 GradTeachingFellow—virtual
Each instance of a class that virtually inherits from another has a pointer (or a
variable offset) to its virtual base class subobject. The virtual base class pointer
is invisible to the programmer and, in general, not necessary to change.
With multiple inheritance, each virtual base class pointer points to the same
object, effectively allowing the base class ob ject to be shared among all of the
derived-class “parts.”
For any class with a virtual base among its base classes, a member initial-
ization entry for that virtual base must appear in the member initialization forthat class. Otherwise, the virtual base gets default initialization.
23.4 public, protected, and private Derivation
Most of the time, you will see classes using public derivation. For example,
class Square : publicShape {
// ...};
public derivation describes an interface relationship between two classes. This
means that the interface (public part) of the base class merges with the interfacemName 
mBirthdate mSex
mAddress 
mDepartment
mRank 
mDepartment mCourseInfo
mSupervisorPerson
Student
T eacher
GradT eachingFellowNote keyword virtual here.
virtual inheritanceVirtual not needed here.
It is necessary to initialize all virtual base classes explicitly in multiply-derived classes, to resolve
ambiguity about how they should be initialized.
After using virtual inheritance, an instance of GradTeachingFellow
might look like Figure 23.6.4321ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 536
of the derived class. When there is an is-a relationship between the derived and
base class types, public derivation is appropriate.
Much less commonly you will see protected or private derivation. This is
considered an implementation relationship , rather than an is-arelationship. The
base class interface ( public part) gets merged with the implementation
(private or protected , depending on the kind of derivation) of the derived
class. In effect, private derivation is like adding an extra object as a private
data member to your class.
Similarly,protected derivation is like adding an object as a protected
data member to the derived class that shares its this pointer.
Example 23.9 is a concrete example of a situation in which private deriva-
tion might be appropriate. The template class Stack is privately derived from
QList . The rationale for doing this is that a stack is, by definition, a datastructure
that limits access to the top item. The class QStack , which is publicly derived from
QVector , has the expected public interface for a stack but it also allows client code
unlimited access to the items in the stack because it contains the entire publicinterface of
QVector . Our Stack class is privately derived from QList , so its
public interface limits client code access to the handful of stack operations that are
consistent with the definition of that data structure.
EXAMPLE 23.9 src/privatederiv/stack.h
#ifndef _STACK_H_
#define _STACK_H_
#include <QList>template<class T>
class Stack : private QList<T> { public:
bool isEmpty() const {
return QList<T>::isEmpty();
}T pop() {
return takeFirst();
}void push(const T& value) {
prepend(value);
}const T& top() const {
return first();
}23.4 PUBLIC, PROTECTED, AND PRIVATE DERIVATION
537
continuedezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 537
int size() const {
return QList<T>::size();
}void clear() {
QList<T>::clear();
}
};
#endif 
Example 23.10 shows that an attempt by client code to make use of the Stack ’s
base class ( QList ) interface is not allowed.
EXAMPLE 23.10 src/privatederiv/stack-test.cpp
#include "stack.h"
#include <QString>#include <qstd.h>using namespace qstd;
int main() {
Stack<QString> strs;strs.push("hic");strs.push("haec");strs.push("hoc");
//strs.removeAt(2);  
int n = strs.size();cout << n << " items in stack" << endl;for(int i = 0; i < n; ++i)
cout << strs.pop() << endl;
}
Error—inherited QList methods are private.
So,private derivation provides a way to hide the public interface of a base class
that was only needed for implementation purposes. What about protected
derivation?
Suppose we wish to derive XStack , a particular kind of stack, from the Stack
class. With Stack privately derived from QList , we will not be able to make use
of any QList member functions when we implement XStack.
If we need to use some of the QList functions when we implement XStack ,
then we must use protected derivation when we derive Stack from QList .
protected derivation makes the public interface of QList protected in
Stack .
Internally, this allows classes derived from Stack to make use of the inherited
QListprotected interface.11CHAPTER 23: INHERITANCE IN DETAIL
538ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 538
REVIEW QUESTIONS
539
REVIEW QUESTIONS
1. What is a vtable?
2. What is a polymorphic type?3. Which kinds of member functions are not inherited? Why?4. Under what circumstances should we have virtual destructors?5. What happens when a 
virtual function is called from a base-class
constructor?
6. What is virtual inheritance? What problems can it be used to solve?
7. Why would one use non-public derivation?ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 539
ezus_138004_ch23.qxd  8/3/06  4:34 PM  Page 540
54124.1 Functions with Variable-Length 
Argument Lists . . . . . . . . . . . . . . . . . . . . . 542
24.2 Resource Sharing . . . . . . . . . . . . . . . . . . . 54324CHAPTER 24 
Miscellaneous Topics
Variable length argument lists are referenced, but notcompletely explained earlier in the book, so they arediscussed in this chapter. An example of resourcesharing is also presented.ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 541
24.1 Functions with Variable-Length 
Argument Lists
In C and in C++ it is possible to define functions that have parameter lists ending
with an ellipsis (. . .). The ellipsis allows the number of parameters and their types
to be specified by the caller. The usual example of such a function is from
<stdio.h>.
int printf(char* formatstr, ...)
This flexible mechanism permits calls such as
printf("Eschew Obfuscation!\n");
printf("%d days hath %s\n", 30, "September");
T o define a function that uses the ellipsis you need to
#include <cstdarg>
which adds to the std namespace a set of macros for accessing the items in the
argument list. There must be at least one parameter other than the ellipsis in theparameter list. A variable, usually named 
ap(argument pointer), of type
va_list is used to traverse the list of unnamed arguments. The macro
va_start(ap, p)
where p is the last named parameter in the list, initializes apso that it points to the
first of the unnamed arguments. The macro
va_arg(ap, typename)
returns the argument that apis pointing to and uses the typename to determine
(i.e., with sizeof ) how large a step to take to find the next argument. The macro
va_end(ap)
must be called after all of the unnamed arguments have been processed. It cleansup the unnamed argument stack and ensures that the program will behave prop-erly after the function has terminated.
Example 24.1 shows how to use these features.
ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 542
EXAMPLE 24.1 src/ellipsis/ellipsis.cpp
#include <cstdarg>
#include <iostream>using namespace std;
double mean(int n ...) {  
va_list ap;        double sum(0);int count(n);va_start(ap, n);  for(int i = 0; i < count; ++i) {
sum += va_arg(ap, double);
}va_end(ap);        return sum / count;
}
432124.2 RESOURCE SHARING
543
int main() {
cout << mean(4, 11.3, 22.5, 33.7, 44.9) << endl;cout << mean (5, 13.4, 22.5, 123.45, 421.33, 2525.353) << endl;
}
First parameter is number of args.
Sequentially points to each unnamed arg.ap now points to first unnamed arg.
Clean up before returning.
24.2 Resource Sharing
Garbage collection is a process that recovers heap memory that is no longer being
referenced. Languages such as LISP , Smalltalk, and Java have built-in garbage col-lectors that run in the background and track object references. When an object isno longer referenced it is deleted, and the memory that it occupied is made avail-able for use by other objects.
The next examples show a way of building garbage collection into the design
of a class by means of reference counting . Reference counting is an example of
resource sharing .
Each object keeps track of its active references. When an object is created, its ref-
erence counter is set to 1. Each time the object is newly referenced, the referencecounter is incremented. Each time it loses a reference, the reference counter isdecremented. When the reference count becomes 0, the shared object can be deal-located.4321ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 543
WHAT ABOUT CHANGES? If the object is about to be changed (e.g.,
a non-const member function is called) and its reference count is
greater than 1, it must be cloned first so that it is no longer shared.
In Example 24.2, we define a homemade string class, MyString , that contains a
private inner class, MyStringPrivate , which is responsible for the creation of
dynamic arrays and for maintaining a reference count.
An inner class is simply a class define d inside another class. Inner classes are
“private” classes, meant to be used only by the containing class.
EXAMPLE 24.2 src/mystring/refcount/refcount.h
[ . . . . ]
class MyString {
class MyStringPrivate {
friend class MyString;  
public:
MyStringPrivate() : m_Len(0), m_RefCount(1) {
m_Chars = new (nothrow) char[1] ;m_Chars[0] = 0;
}MyStringPrivate(const char* p) : m_RefCount(1) {
m_Len = strlen(p);m_Chars = new (nothrow) char[m_Len + 1];if (m_Chars)
strncpy(m_Chars, p, m_Len + 1);
else 
cerr << "Out of memory in MyStringPrivate ctor!"
<< endl;
}~MyStringPrivate() {
delete []m_Chars;
}
private:
int    m_Len, m_RefCount;char*  m_Chars;
};
public:
MyString()  : m_Impl(new MyStringPrivate) {}MyString(const char* p)
: m_Impl(new MyStringPrivate(p)) {}
MyString(const MyString& str);~MyString();1CHAPTER 24: MISCELLANEOUS TOPICS
544ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 544
void operator=(const MyString& str);
void display() const ;int length() const;
private:
MyStringPrivate*  m_Impl;
};[ . . . . ]
Even though this is an inner class, we need to give friend permissions to the containing class.
nothrow
We used the nothrow qualifier for new (Section 22.9.3) to avoid having to
add exception handling code to the example.
The public class MyString , because it manages shared instances of
MyStringPrivate , is sometimes called a handler class . It is responsible for
maintaining the correct value of the reference counter, and for deleting the pointerwhen the counter reaches zero.
In Example 24.3, we have output statements in the definitions of three mem-
ber functions to show the reference counter as objects are created and destroyed.
EXAMPLE 24.3 src/mystring/refcount/refcount.cpp124.2 RESOURCE SHARING
545
[ . . . . ]
MyString::MyString(const MyString& str) : m_St(str.m_St) {
m_St -> m_RefCount++;cout << m_St->m_S << "::refcount: " << m_St->m_RefCount << endl;
}
MyString::~MyString() {
cout << m_St->m_S << "::refcount: " << m_St->m_RefCount << endl;if (--m_St -> m_RefCount == 0) {
cout << m_St->m_S << "::memory released" << endl;delete m_St;
}
}
void MyString::operator=(const MyString& str) {
if (str.m_St != m_St) {
if (--m_St -> m_RefCount == 0)
delete m_St;
m_St = str.m_St;  
1
continuedezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 545
++(m_St->m_RefCount);
}
}[ . . . . ]
Just copy the address.
The client code shown in Example 24.4 contains a function with a value parame-
ter and a main() with an inner block. Inside the block, objects are created, copied,
and destroyed.
EXAMPLE 24.4 src/mystring/refcount/refcount-test.cpp 
#include "refcount.h"
void fiddle(MyString lstr1) {
cout << "inside fiddle()" << endl;MyString lstr2(lstr1);MyString lstr3;lstr3 = lstr2;
}
int main() {
MyString  str1("AABBCCDD");{
cout << "local block begins" << endl;MyString str2(str1);fiddle(str2);cout << "back from fiddle()" << endl;
} cout << "local block ends" << endl;str1.display();cout << endl;return 0;
}1CHAPTER 24: MISCELLANEOUS TOPICS
546ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 546
The output that follows dispassionately shows the entire saga of birth and death as
the process races from opening brace to closing brace.
local block begins
AABBCCDD::refcount: 2AABBCCDD::refcount: 3inside fiddle()AABBCCDD::refcount: 4AABBCCDD::refcount: 5AABBCCDD::refcount: 4AABBCCDD::refcount: 3back from fiddle()AABBCCDD::refcount: 2local block endsAABBCCDDAABBCCDD::refcount: 1AABBCCDD::memory releasedsrc/mystring>
EXERCISES: RESOURCE SHARING
1.Example 24.3 demonstrates reference counting but does not deal with the
question of what to do if a MyString object needs to have its value changed
when its reference counter is grea ter than 1. How would you implement the
cloning of a MyString object when necessary (but only when necessary)?
Implement your solution and test it.
2.Implement a thread-safe version using QMutex .
3.Rewrite MyString using QSharedData and QSharedDataPointer .24.2 RESOURCE SHARING
547ezus_138004_ch24.qxd  8/3/06  4:36 PM  Page 547
PART IV
Programming
Assignmentsezus_138004_ch25.qxd  8/3/06  4:38 PM  Page 548
Chapter 25. MP3 Jukebox Assignments . . . . . 551
549ezus_138004_ch25.qxd  8/3/06  4:38 PM  Page 549
ezus_138004_ch25.qxd  8/3/06  4:38 PM  Page 550
55125CHAPTER 25 
MP3 Jukebox Assignments
In the assignments in this chapter, we will write,
in stages, a program that serves as an MP3 playlistgenerator and database manager. It will generateand play selections of MP3 songs based on what itcan find on our file system and it will permit filter-queries based on data stored in ID3v2 (meta) tag
information.
25.1 Data Model: Mp3File . . . . . . . . . . . . . . . . 553
25.2 Visitor: Generating Playlists . . . . . . . . . . 55525.3 Preference: An Enumerated Type . . . . . 55625.4 Reusing id3lib . . . . . . . . . . . . . . . . . . . . . . 55925.5 PlayListModel Serialization . . . . . . . . . . 56025.6 Testing Mp3File Related Classes . . . . . . 56125.7 Simple Queries and Filters . . . . . . . . . . . 56125.8 Mp3PlayerView . . . . . . . . . . . . . . . . . . . . . 56325.9 Models and Views: PlayList . . . . . . . . . . 56525.10 Source Selector. . . . . . . . . . . . . . . . . . . . 56625.11 Persistent Settings. . . . . . . . . . . . . . . . . 56725.12 Edit Form View for FileTagger . . . . . . . 56825.13 Database View . . . . . . . . . . . . . . . . . . . . 569ezus_138004_ch25.qxd  8/3/06  4:38 PM  Page 551
The features we will implement are inspired by open-source programs such
as amaroK and Juk (and commercial programs such as iTunes and MusicMatchJukebox). These programs all provide similar features and similar styles of userinterface.
The code that does the actual file-tagging is taken from an open-source library,
id3lib1version 3.8.3. This is the same library that is used by MusicMatch Jukebox.
1http://sourceforge.net/projects/id3libFIGURE 25.1 Example screenshot
The media player shown in Figure 25.1 has three major components.
1. A player view that shows the user what is currently playing and provides
some controls for changing volume or position of the song
2. A selector that permits the user to choose (and create new) playlists for
manipulating or playback
3. A song list view, for displaying a list of songs in a tabular form
ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 552
Each of these major components has a view for displaying the data and a model
for storing the data.
■The model for a Mp3PlayerView consists of Mp3Player plus a
FileTagger .
■The model for a source selector is a tree, and you can use either
QTreeWidgetItem or QAbstractItemModel as the base class for this.
■T o start with, the model for a song list view will be a simple PlayList .
Later in the chapter, we will implement another model based onQSqlRelationalTableModel.
Figure 25.2 shows a high-level UML diagram of the major components of this
project. We can see that the 
Controller class, derived from QApplication ,
owns all other objects.25.1 DATA MODEL: MP3FILE
553
FIGURE 25.2 The Controller and its managed objects
25.1 Data Model: Mp3File
■Abstract base classes (Section 6.3)
■Multiple inheritance (Section 23.3)QApplication
QWidgetController
SourceSelectorQDockWidget QProcessQMainWindow
MainWindow
Mp3Player
- mElapsed : double 
- mRemaining : doubleMp3PlayerView
+ Mp3PlayerView() 
+ ~ Mp3PlayerView() + playListMenu() + addWidget() + setNowPlaying() + updateView() + addActions()- mMgr
+ mPlayerezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 553
Figure 25.3 shows a UML diagram of the data model for our MP3 player applica-
tion, at the lowest level.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
554
FIGURE 25.3 Initial data model
Mp3Song is an abstract class (which is why it is italicized in the UML diagram).
This interface is meant to describe a common set of features for different imple-mentations of the 
Mp3Song interface.
EXAMPLE 25.1 ../src/libs/filetagger/mp3song.h
#ifndef _MP3SONG_H
#define _MP3SONG_H
#include <qobject.h>
#include <qstring.h>#include <QStringList>
class Mp3Song {public:
static QStringList fields();virtual ~Mp3Song();
virtual QString getGenre() const =0;
virtual QString getArtist() const =0;virtual QString getAlbumTitle() const =0;virtual QString getTrackTitle() const =0;virtual QString getTrackNumber() const =0;virtual int getTrackTime() const =0;virtual QString getComment() const =0;virtual QString getPreference() const =0 ;virtual QString toString() const =0;virtual QString getUrl() const =0;virtual QString getFilename() const = 0;PlayListModel
Mp3SongQObject
DataObject
Mp3File FileT agger
- mTag : ID3_Tag* 
- mFilename : QString* ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 554
virtual void setPreference(const QString & newPref) = 0;
virtual void setGenre (const QString& newGenre) =0;virtual void setArtist (const QString&  newArtist) =0;virtual void setTrackNumber (const QString& trackNum) = 0;virtual void setTrackTitle (const QString& newTitle) = 0;virtual void setAlbumTitle (const QString& newAlbumTitle) = 0;virtual void setComment (const QString& newComment) = 0;virtual void setFilename (const QString& newFilename) =0 ;25.2 VISITOR: GENERATING PLAYLISTS
555
};
#endif
Note also that there is a getTrackTime() function but no setTrackTime()
method. This is because m_TrackTime is a calculated value, a read-only property.
Derived classes will override this method and return the actual time of the song.
The Assignment
■Define a class Mp3File that implements the Mp3Song interface but
allows you to store and retrieve the values in data members.
■Define a PlayListModel , a collection of Mp3Songs . Reuse a
QList<Mp3Song*> to hold pointers to heap Mp3File objects.
■Write the implementations to the classes described in the UML diagramin Figure 25.3. This includes data members, getters and setters, and a
toString() method for Mp3File .
25.2 Visitor: Generating Playlists
■Command line arguments (Section 1.8.1)
■Visitor pattern (Section 8.1)
In the http://oop.mcs.suffolk.edu/dist folder, you will find filetagger.tar.gz ,
which contains interfaces PlayListModel and Mp3Song , as well as other classes
you might reuse for future assignments. The assignment is to write a Playlist
class and a program that generates instances of them by scanning directories forMP3 files. The program should be called 
playgen . Figure 25.4 shows how the
interfaces are related to PlayList.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 555
playgen (the application) should have a class called PlayGen , containing a
PlayList*scan(QStringdirname) that returns a new PlayList containing
references to each song.
Usage:
playgen dirname
The program should print out the name of each file that it finds (on a line by
itself). But it should do this by first loading the PlayList and then displaying the
string produced by PlayList::toString() .
Classes you can reuse: QFile and QFileInfo , or FileVisitor .CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
556
FIGURE 25.4 PlayList and PlayListModelPlayListModel
+ addFile(s : QString) 
+ toString() : QString 
+ objectName() : QString 
+ clear() 
+ reset() 
+ ~ PlayListModel() 
+ name() : QString 
+ size() : int 
+ get(index : int) : Mp3Song* 
PlayListMp3Song*
25.3 Preference: An Enumerated Type
■Enumerations (Section 19.3)
■Types (Section 19.5)
■Conversions (Section 19.6)
Y our assignment is to design, implement, and test a Preference class.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 556
25.3 PREFERENCE: AN ENUMERATED TYPE
557
Preference is a class that models one field in an ID3 tag. It is intended to
permit the user to specify the quality of an MP3 file (e.g., excellent, good, fair,poor). We need a uniform preference system that will enumerate a fixed set ofvalue choices so that comparisons and subrange queries are possible.
Here is the public interface of the class definition to get you started.
public:
Preference(int value=0);Preference(QString prefstr);/**
If possible, set the host value from the given string and@return true. Otherwise return false.
*/bool fromString(QString);/**
@return a list of all the acceptable Preference names,ordered by value (increasing)
*/virtual QStringList getNames() const;
The Assignment
■Complete the class definition in preference.h .
■Implement all the functions in preference.cpp so that your class can
pass the test case below.
■Write a main.cpp that calls this test case and tests your Preference
class.
■Generate or write a qmake project file that can build the application.
■Verify that makedist creates a dist target (a tarball).
A test case that shows how the Preference class must work is provided in
Example 25.2. Y our Preference class must pass that test.
EXAMPLE 25.2 ../src/libs/filetagger/testpreference.cpp
#include "testpreference.h"
#include "preference.h"#include "qstd.h"using namespace qstd;
void TestPreference::test() {
Preference verygood("Very Good");
Preference verygood2("Very Good");Preference excellent("Excellent");Preference fair("Fair");Preference good("Good");
continuedezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 557
Preference none("None");
Preference poor("Poor");Preference badtaste("Bad Taste");Preference undefined("undefined");ASSERT_EQUALS(verygood, verygood2);ASSERT_NOTEQUALS(verygood, fair);
ASSERT_EQUALS(undefined, 0);
ASSERT_TRUE(none > undefined);ASSERT_TRUE(poor < none);ASSERT_TRUE(badtaste  < poor);ASSERT_TRUE(verygood > good);ASSERT_TRUE(good > fair);ASSERT_TRUE(fair > none);ASSERT_TRUE(fair < verygood);ASSERT_TRUE(verygood < excellent);
ASSERT_EQUALS(verygood.toString(), "Very Good");qDebug() << verygood.toString();
Preference q("notsogood");ASSERT_EQUALS(0, (int)q);qDebug() << q.getNames().join(", ");
/* Optional - Case Ignore conversions? */// Does this print "fair is fair" or "fair is 4"?
cout << "Fair is " << fair;
Preference verygoodlc("very good");
ASSERT_EQUALS(verygood, verygoodlc);
}
The header file is provided to you in Example 25.3 for completeness.
EXAMPLE 25.3 ../src/libs/filetagger/testpreference.h
#include <testcase.h>#include <assertequals.h>
class TestPreference : public TestCase {
TestPreference() : TestCase("TestPreference") {}
protected:
virtual void test() ;
};
When the test case is run, the output should look like this.
<testcase>Very GoodUndefined, Bad Taste, Poor, None, Fair, Good, Very Good, ExcellentCHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
558ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 558
./testpreference.cpp:44: assertequalsfailed: 
expr var="verygood" val="6"  ,   expr var="verygoodlc" val="0" 
<testcaseinfo classname="TestCase" name="unnamed" status="passed" />
</testcase>Fair is Fair25.4 REUSING ID3LIB
559
25.4 Reusing id3lib
Each MP3 file contains meta-data called “ID3 tags” that can be accessed and
manipulated through low-level file operations, or via a higher-level interface. Wesaw two interfaces for using the library in Section 16.3. For this exercise, we haveprovided you with classes from three libraries (http://oop.mcs.suffolk.edu/dist)and you are to write a program that reuses them all.
■Reusing libraries (Chapter 7)
■Visitor pattern (Section 8.1)
■Command line arguments (Section 6.7.1)
■id3lib (Section 16.3) 
■playgen (Section 25.2)
ID3 tags enable you to read and store meta-information about MP3 songs in aspecial part of the MP3 file itself. T o manipulate MP3 files as though they wereC++ objects, getting and setting propert ies that persist in the ID3 tags, we reuse an
ID3 library. Y ou will be provided with a 
FileTagger class that depends on
id3lib , but implements the Mp3Song interface.
Check out some of the executables that come with id3lib:id3info ,
id3convert ,id3tag ,id3cp . They all have man pages.
The Assignment
1. Install id3lib .
2. Build filetagger.cpp with TestFileTagger.cpp and run it on a
folder with some junk MP3 files that you do not care about. Verify thatthe test case passes.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 559
3. Enhance the playgen program so that its output playlist includes ID3
tag information in the playlist.
playgen [directory]
playgen [file1.mp3] [file2.mp3] ...
playgen generates a playlist of all MP3 files in the directory, or of all MP3 files
supplied on the list of command line arguments. It should read the id3tag
information from each file it visits and display each song in the format shown inExample 25.4.
EXAMPLE 25.4 filetagger-examplefiles/test-winamp-playlist.m3u
#EXTM3U
#EXTINF:134,Tom Lehrer - Vatican RagTom Lehrer\YearThatWas\14_Vatican Rag_Tom Lehrer.mp3#EXTINF:131,Tom Lehrer - Folk Song ArmyTom Lehrer\YearThatWas\04_Folk Song Army_Tom Lehrer.mp3#EXTINF:155,Tom Lehrer - National Brotherhood Week
Tom Lehrer\YearThatWas\01_National Brotherhood Week_Tom Lehrer.mp3
It is suggested you use ArgumentList to process command line options, and
FileVisitor to visit each file.
25.5 PlayListModel Serialization
■Streams and files (Section 1.10)
■Serializer pattern (Section 10.6)
Most MP3 players load/save their playlists from/to a file with an M3U extension.
There is simple M3U and extended M3U (EXTM3U). Simple M3U is just a list offilenames separated by newlines. Extended M3U contains extra information fol-lowing a # sign on the preceding line. If you use this format, your program willimmediately work with the most popular MP3 players.
Serialization, as we discussed in Section 10.6, is the process of taking an object
and expressing its state information in a format that allows it to be sent across anetwork or saved to a storage device such as a file or a database. Deserialization is
the process of reconstructing the object from the serialized state information to itsoriginal state.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
560ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 560
25.7 SIMPLE QUERIES AND FILTERS
561
25.6 Testing Mp3File Related Classes
■Define a class TestMp3File and a member function, test() .
■The test case should do the following:
1. Using the classes from playgen , create a PlayList from a direc-
tory specified on the command line, visiting each file.
2. Using PlayListWriter , write the PlayList to a file.
3. Using PlayListReader , read the file into another PlayList
instance.
4. Write an equals() function for PlayList that tests that each
property of the Mp3File in the collection has the same value as the
corresponding one in the original.
25.7 Simple Queries and Filters
■Abstract Factory (Section 16.1)
■Regular expressions (Section 13.2)
■Visitor (Section 8.1)
This exercise is to enhance playgen , so that it generates a PlayList based on
the tag values of visited Mp3Files . T o achieve this, we need multi-dimensional
property constraints.
Two classes from libdataobjects can help you solve this problem.
ConstraintGroup is a class you can reuse for multidimensional Constraint s.FIGURE 25.5 Serialization classes for PlayListModelPlayListReader
+ read(filename : QString) : PlayListModel*
PlayListWriter
+ write(model : PlayListModel, Filename : QString)Now that we have a simple data object, we want to be able to serialize and dese-
rialize it. Write two classes, PlayListReader andPlayListWriter for reading/
writing playlist data.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 561
usage: playgen [options] filespec 
[options] are optional.filespec can be a directory to scan, 
or a list of mp3 files to add to playlist.
Directories are recursed. Additional options can be: 
(filter options) -p Good - filter on Preference-p 5 - equivalent to preference Good-p "Very Good" - Need double quotes around this one -g Chill - filter on Chill genre
-a ".*gabriel.*" - regex filter on artists - need
doublequotes around regex
-b albumpattern - filter on album title-s songpattern - filter on song title
Advanced queries:
If the same switch appears multiple times, OR the values together.
-p Excellent -p "Very Good" (either can be true)
If different switches appear on the same query AND them together.
-p Excellent -g Ambient (both must be true).
-p "6,7" - Allow preferences 6 and 7 only
-p "4:9" - Filter on preferences of the subrange 4 to 9-p "0,5:" - filter on preferences undefined, or anything
better than "good"
-p "1,2,3" - only preferences "badtaste", "poor" and "none"
example:
playgen ./music/comedy/weirdal
make a playlist of all the songs in that directory, without any
filtering, and send to standard output.
playgen -o "weirdalsbest.m3u" -p "Excellent" ./music/
comedy/weirdal
Should go into the weirdal directory and spit out only
the "Excellent" tracks, saving them to a file.
playgen -g "(Rock|Classical|Dub)" ./music/technoFilter on genres - since you're using regular expressions
to match, you have the full regular expression query language here.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
562
In Figure 25.6, the UML diagram shows one possible way of organizing your code.
Y ou are free to deviate from this diagram as you design your own solution.
Y ou might think of your program in the following way.
1. Given an ArgumentList , create an object that represents the collection
of field/value pairs as a set of constraints.
2. Use FileVisitor to visit each file in filespec .Each Constraint is a piece of a query, so a query can be represented by a
ConstraintGroup .ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 562
25.8 MP3PLAYERVIEW
563
3. Use FileTagger to extract the ID3 information of each MP3 file.
4. After you have extracted the ID3 information, check whether the object
satisfies the constraints specified.
5. If the object satisfies your constraints, we want to make a copy of the
FileTagger ’s attributes in a new Mp3File object and add the
Mp3File to the PlayList returned by playgen (instead of adding the
actual FileTagger , which we will reuse for the next visited file).
6. Return a PlayList with the selected songs.
7. Write a factory for Query objects, called QueryFactory , and a func-
tion, called newQuery , to handle all instance creation.
class QueryFactory {
Query * QueryFactory::newQuery(QStringList2args);
};
25.8 Mp3PlayerView
■Widgets (Chapter 11)
■Signals and slots (Section 9.3.3)
■QProcess (Section 12.1)FIGURE 25.6 PlayListGenerator with constraintsConstraintGroup
+ value()
+ hasConstraint()+ toString()+ filter()+ getConstraint()+ setConstraint()
Constraint
- mAlways : bool
+ Constraint(always : bool)
+ accepts(value : QVariant) : bool+ toString() : QStringPlayGenFileVisitor
*
2or ArgumentListezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 563
The minimal MP3 player view has the following features:
■Buttons:play ,stop ,next , and previous
■Sliders: volume control and song progress
■Label: to display “now playing” informationCHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
564
FIGURE 25.7 Mp3PlayerAn example Mp3Player class based on Figure 25.7 is supplied to you. This par-
ticular implementation works by creating QProcess objects, running command-
line programs, passing options, parsing the output, and displaying informationbased on it. It uses 
mpg3213(for MP3 decoding) and alsaplayer4(for volume
control). Y ou can reuse this class if you are using Linux.
QProcess
Mp3Player
+ Mp3Player() 
+ ~ Mp3Player() + play(filename : const QString&) + setVolume(percent : int) + stop() + setPosition(percent : int) 
3http://mpg321.sourceforge.net
4http://www.alsaplayer.org1. Write another Mp3Player -derived class, better suited to your own
platform or personal needs. It can be based onhttp://www.music.mcgill.ca/~gary/rtaudio/index.html#license orhttp://www.speech.kth.se/snack, two open-source libraries for playingmedia files. Alternately, you can write it as a plugin for an already exist-ing media player, such as xmms or Winamp.
2. Write a front-end to this 
Mp3Player class that allows you to load songs,
start/stop, change volume, and see the play progress advance in the slider.
3. Enhance Mp3Player and PlayerView so that you can change the
position of the song playing by manipulating the song progress slider.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 564
25.9 Models and Views: PlayList
■Qt 4 models and views (Section 17.3)
■QAction sa n d  QMenu s (Section 11.6)
This application has a “central widget” that should display the current playlist.
Sometimes it will be a view of a PlayList , but other times, it will show us the
contents of a Database . One approach, shown in Figure 25.8 is to make both
classes multiply-inherit from QAbstractTableModel , so they can both be
viewed in a QTableView .25.9 MODELS AND VIEWS: PLAYLIST
565
FIGURE 25.8 PlayListTableModelPlayListModel
+ addFile(s : QString) 
+ toString() : QString 
+ objectName() : QString 
+ clear() 
+ reset() 
+ ~ PlayListModel() 
+ name() : QString 
+ size() : int 
+ get(index : int) : Mp3Song* 
PlayListQAbstractItemModel
QSQIRelationalT ableModelQAbstractTableModel
DataObjectT ableModel
# mData : QList< DataObject* > 
# mPropModel : DataObject*
Database
T o model a collection of DataObjects as a table, you can reuse
DataObjectTableModel . This class determines what to display in each column
based on Qt properties. This makes PlayListView much easier to write.
1. Write a PlayListView class. Y ou do not need to write any code for
databases, but keep the design considerations of Figure 25.8 in mind asyou write it.
2. Enhance the GUI you wrote in Section 25.8, by adding a
load playlist
button. Add a QAction -derived class called LoadPlayListAction .
Write the action so that it fills up the contents of the PlayListView .
3. Make the Mp3Player work so that it can automatically play one song
after another in the loaded playlist.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 565
25.10 Source Selector
Being able to select from a variety of different “sources” is what makes a player very
powerful and useful. A source could be any of the following:
■A playlist
■A database
■A list of online radio stations
■Tracks on a CD
Any of these can be considered an input source. The other interesting thing they all
have in common is that they can all be represented by a PlayListModel (a col-
lection of songs).
The SourceSelector widget, shown docked on the left in Figure 25.9, per-
mits the user to select the currently playing “source,” which in this case corre-sponds to a 
PlayListModel . However, the SourceSelector manages a
mapping of models to views, to make switching views easy and fast.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
566
FIGURE 25.9 Source Selector view
Clicking on one of the sources in the selector tree should change the currently
visible table or list view in the central widget. Figure 25.10 shows one possible wayof designing the classes that provides a view and a selector of a collection ofsources.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 566
25.11 PERSISTENT SETTINGS
567
FIGURE 25.10 SourceSelector and related classesSourceSelector
- mSourceList : SourceListModel* 
- mViews : QMap< QAbstractItemModel*, QWidget* > - mSourceView : QListView* - mContextMenu : QMenu* - mFormView : Mp3FormView* - mDatabaseView : DatabaseView* - mCurrentModel : PlayListModel* - mSongSelection : QItemSelectionModel* - mCursor : QModelIndex 
DatabaseView
+ DatabaseView(title : QString) 
+ contextMenuEvent(event : QContextMenuEvent*)QListViewQStringListModel
QAbstractItemModelSourceListModel
- mSources : QMap< QString, QAbstractItemModel* >
QT ableView+ mSourceView 0..1Manages the list of Sources
*
*Each source is also a PlayListModel
+ mViews
+ mDatabaseViewProvides a mapping of Models to Views
0..1
25.11 Persistent Settings
QSettings (Section 11.2.1)
Suppose you want to be able to support multiple playlist formats and also remem-
ber the last format used. Or, suppose you want to remember the last opened direc-tory for MP3 files and, independently, the last opened directory for playlist files.
Settings are simply a persistent mapping of name-value pairs. The names can
be anything we like, but using meaningful hierarchical names will aid greatly inorganization. In Qt on *nix, people tend to use the slash (“/”) as a namespacedelimiter—in contrast to Java, which uses a dot (“.”).
In this exercise, we will implement persistent settings by reusing 
QSettings .
A QSettings object reads/stores its settings from/to different places depending
on the operating system.ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 567
The first three settings that the program needs to remember across executions
are listed below. Write a TestCase of the settings class that loads, changes, saves,
loads again, and checks whether the values were changed.
■playlistmgr/outputformat=(extm3u|xml)
■playlistmgr/lastopendir=last opened directory
■playlistmgr/playlistdir=last opened playlist directory
Think of other properties/settings you might want to set from the application that
must persist across executions.
25.12 Edit Form View for FileTagger
Whenever an MP3 song is selected, we want to be able to execute an action on it:
edit tag. This choice should go in context menus for all playlist views, as well as inthe 
MP3 pull-down menu.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
568
Write a form view for FileTagger , called Mp3TagForm , that provides the user
with editable, viewable information about all of the song’s properties. We needezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 568
action buttons as follows:
■Ok: Perform a commit() on the FileTagger (which stores changes to the
actual id3tag in your MP3 file) and return to main screen (hide form).
■Reload : Discard changes and reload tag info.
■Cancel : Discard changes and return to main screen (hide form).
■Play : Play the track.
When editing a song, it should use a QLineEdit for each QString field and a
QComboBox for the preference values. Keep in mind that the URL, filename, and
track length are non-editable fields. Finally, you can use Designer or hand-codeyour dialog.
25.13 Database View
A database view is not very different from an ordinary playlist view except that it
permits you to see a larger collection of songs, organized in different ways to aidin the selection process.
Typically, a database view can be achieved with a table, a tree of lists, or a table
of lists. The simplest way is to use the 
QTableView and then connect it to a model
that represents the data.
Qt, when it is built with the correct options, can access SQL databases, so that
we can use QSqlTableModel . Using this with the regular QTableView gives
you an editable tabular view of a database table. The database view shown inFigure 25.11 looks like an ordinary table view, because it is! It’s just hooked up toa database model.25.13 DATABASE VIEW
569
FIGURE 25.11 QTableView of a database
ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 569
EXAMPLE 25.5 ../src/libs/filetagger/filetagger.sql
create database mp3db;
use mp3db;grant all on mp3db.* to 'mp3db'@'localhost' identified by 'mp3dbpw';grant all on mp3db.* to mp3db identified by 'mp3dbpw';
drop table FileTagger;
CREATE TABLE FileTagger (
Artist      varchar(100),TrackTitle varchar(100),AlbumTitle varchar(100),TrackNumber    varchar(10),Genre         varchar(20),Comment          varchar(200),Preference     varchar(20),Filename       varchar(200),PRIMARY KEY(Filename),INDEX(Preference),INDEX(Artist),INDEX(Genre)
);
Example 25.5 contains the SQL table definition, and Figure 25.12 contains a sug-
gested initial design for the model.
1. Extend the Mp3TableModel so that it derives from PlayListModel
and fits into your larger program.
2. Write a Library menu with an option to “import songs into library,”
which imports the songs into the database and updates the view.CHAPTER 25: MP3 JUKEBOX ASSIGNMENTS
570
FIGURE 25.12 Database table modelQSqlRelationalT ableModel
Mp3T ableModel
- insertQuery : QSqlQuery
- mFileVisitor : FileVisitor- mSelectionModel : QItemSelectionModel*- ft : FileTagger
+ Mp3TableModel()
+ createConnection() : bool+ reset()+ toString() : QString+ addFile(filename : QString)+ clear()ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 570
POINTS OF DEPARTURE
If you reached this point, you have a strong understanding of the benefits and dif-
ficulties of model-view programming. If you compare your application to some-thing like 
juK or amaroK , you can come up with ideas for other features to add.
This might be a good time to download and examine source code of these andother existing KDE projects—you will notice most of them are Qt 3 based, andyou should be able to understand the code now. If you feel confident enough, youmight want to help in the maintenance or porting of existing KDE projects overto Qt 4 / KDE4. Join the mailing lists for your favorite projects.25.13 DATABASE VIEW
571ezus_138004_ch25.qxd  8/3/06  4:39 PM  Page 571
PART V
Appendicesezus_138004_appA.qxd  8/4/06  9:55 AM  Page 572
Appendix A. C++ Reserved Keywords . . . . . . . 575
Appendix B. Standard Headers . . . . . . . . . . . . . 577Appendix C. The Development 
Environment . . . . . . . . . . . . . . . . . 579ezus_138004_appA.qxd  8/4/06  9:55 AM  Page 573
ezus_138004_appA.qxd  8/4/06  9:55 AM  Page 574
Appendix A: C++ Reserved
Keywords
Keywords are identifiers that are part of the basic syntax of the language. These
names have fixed meanings and cannot be used in any way that attempts to changethose meanings.
Here is a list of keywords in C++. Those that are shown in bold are also part
of ANSI C89.
575and
and_eqasmautobitandbitorboolbreakcasecatchcharclasscomplconstconst_castcontinuedefaultdeletedodoubledynamic_cast
elseenumexplicitexportexternfalsefloatforfriendgotoifinlineintlongmutablenamespacenewnotnot_eqoperator
oror_eqprivateprotectedpublicregisterreinterpret_castreturnshortsignedsizeofstaticstatic_caststructswitchtemplatethisthrowtrueezus_138004_appA.qxd  8/4/06  9:55 AM  Page 575
576APPENDIX A: C++ RESERVED KEYWORDS
try
typedeftypeidtypenameunionunsigned
usingvirtualvoidvolatilewchar_t
whilexorxor_eqezus_138004_appA.qxd  8/4/06  9:55 AM  Page 576
Appendix B: Standard Headers
This book uses a small subset of the Standard T emplate Library (STL; also called
the Standard Library ). The standard header files we use are all listed here.
T o use these classes and functions effectively, it is useful to know where to look
for documentation.
Table B.1 lists standard header files. For some header files, there is a man page
for the whole file. In other cases, you might find a man page for the individualfunction also.
If you are using Microsoft Developer’s Studio, the documentation for the stan-
dard libraries comes with the MSDN documentation.
For open-source platforms, it helps to have one but you don’t need a local copy
of
man or the man pages since there are many copies of the documentation1avail-
able on the Web.
5771For examples, see cplusplus.com [http://www.cpl usplus.com/ref/] or Dinkumware [http://www
.dinkumware.com/manuals/reader.aspx?lib=cpp].ezus_138004_appB.qxd  8/4/06  9:56 AM  Page 577
TABLE B.1 Standard headers
Header file Library Man pages
C++ STL
string STL strings type std::string
sstream stringstream, for writing std::stringstream
to strings as if they are 
streams
iostream C++ standard stream std::ios, 
library std::iostream
memory C++ memory-related std::bad_alloc, 
routines std::auto_ptr
C Standard Library
cstring, functions for C char* string, strcpy, 
string.h strings strcmp
cstdlib, c Standard Library random, srandom, 
stdlib.h getenv, setenv
cstdio, stdio.h standard input/output stdin, stdout, 
printf, scanf
cassert assert macros assert
By default, the C++ Standard Library documentation might not be
installed on your system. Search for the string libstdc with your favoritepackage manager, so you can install something like 
libstdc++5-3.
3-doc or libstdc++6-4.0-doc .578APPENDIX B: STANDARD HEADERSezus_138004_appB.qxd  8/4/06  9:56 AM  Page 578
Appendix C: The Development
Environment
C.1 The Preprocessor: For #including Files
This appendix explains some of the mysteries of the C preprocessor, class declara-
tions versus including headers, and some b est practices to reduce dependencies
between header files.
In C++, code reuse is indicated by the presence of a preprocessor directive,
#include , in source code and header files. We #include header files that con-
tain things like class or namespace definitions, const definitions, function proto-types, and so forth. These files are literally included in our own files before the
compiler begins to translate our code.
The compiler will report an error if it sees any identifier defined more than
once. It will tolerate repeated declarations but not repeated definitions.
1To  p re -
vent repeated definitions, we are always careful to use an #ifndef wrapper
around each header file. This tells the C preprocessor to skip the contents if it hasalready seen them. Let’s examine the following class definition in Example C.1.
5791We discuss the difference between declaration and definition in Section 20.1.ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 579
EXAMPLE C.1 src/preprocessor/constraintmap.h
#ifndef CONSTRAINTMAP_H
#define CONSTRAINTMAP_H
/* included class definitions: */
#include <QHash>#include <QString>
class Constraint;                                      class ConstraintMap : public QHash<QString, Constraint*> {  private:
Constraint* m_Constraintptr;                        
//    Constraint m_ConstraintObj;                       
void addConstraint(Constraint& c); 
};
#endif        //  #ifndef CONSTRAINTMAP_H
a forward declaration
Needs definitions of QHash and QString, but only the declaration of Constraint, because it’s apointer.
No problem—it’s just a pointer.
error—incomplete type
As you can see, as long as we use pointers or references, a forward declaration will
suffice. The pointer dereferencing and memb er accessing operations are performed
in the implementation file, which needs the full definition of all types it uses.
EXAMPLE C.2 src/preprocessor/including.cpp
#include "constraintmap.h"
ConstraintMap map;  /* redundant but harmless if #ifndef wrapped */
#include "constraintmap.h"
// Constraint p;  
#include <constraint.h>Constraint q;
Okay—ConstraintMap already included.
error—incomplete type
Now it is a complete type.32132143214321580APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 580
Here are some guidelines to help decide whe ther you need a forward declaration
or the full header file to #include in your header file:
■IfClassA derives from ClassB , the definition of ClassB must be known by
the compiler when it processes the definition of ClassA . Therefore, the
header file for ClassA must tothe header file for ClassB .
■If the definition of ClassA contains a member that is an object of ClassD ,
the header file for ClassA must#include the header file for ClassD . If the
definition of ClassA contains a function that has a parameter or a return
object of ClassD , the header file for ClassA must#include the header file
forClassD .
■If the definition of ClassA only contains non-dereferenced ClassE point-
ers, then a forward declaration ofClassE is sufficient in the ClassA
header file:
class ClassE;
A class that is declared but not defined is considered an incomplete type .A n y
attempt to dereference a pointer or define an object of an incomplete type willresult in a compiler error.
2
The implementation file, classa.cpp ,f o r  ClassA should#include
"classa.h" and also #include the header file for each class that is used by
ClassA (unless that header file has already been included in classa.h ). All
pointer dereferencing should be performed in the .cpp file. This helps reducedependencies between classes and improves compilation speed.
A 
.cpp file should never #include another .cpp file. A header file should
#include as few other header files as possible so that it can be included more
quickly and with fewer depende ncies. A header file should always be #ifndef
wrapped to prevent it from being included more than once.C.1 THE PREPROCESSOR: FOR #INCLUDING FILES
581
2The actual error message may not always be clear, and with QObject s, it might come from the
MOC-generated code rather than your own code.ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 581
Circular Dependencies
Whenever one file #includes another, there is a strong dependency cre-
ated between the files. When a dependency like this exists between headerfiles, it cannot be bidirectional: The preprocessor is unable to cope with acircular dependency between header files, where each one 
#include s the
other. One of the #include statements must be replaced by a forward class
declaration.
Forward declarations help remove circular dependencies between
classes and, in the process, enable bidirectional relationships to existbetween them.
C.2 Understanding the Linker
Figure C.1 shows how the linker accepts binary files, which were generated by the
compiler, and creates executable binaries as its output. The linker executable, on*nix machines is simply called 
ld, and it is run by g++ after all source files are
compiled successfully.
All of these steps are performed when you run make , which prints out every
command before it executes. By reading the output of make , you can see what
arguments are being passed to the compiler and linker. When an error occurs, itimmediately follows the command line that produced the error.
Example C.3 shows the command line options passed to g++ , and attempts to
show how g++ runs the linker, known as ld, and also passes some arguments to it.
EXAMPLE C.3 linker-invocation.txt
g++ -Wl,-rpath,/usr/local/qt-x11-free-3.2.3/lib           
-o hw7                                           .obj/address.o .obj/ca_address.o .obj/constraintgroup.o.obj/customer.o .obj/dataobject.o .obj/dataobjectfactory.o.obj/hw07-demo.o .obj/us_address.o .obj/moc_address.o
.obj/moc_ca_address.o .obj/moc_customer.o .obj/moc_dataobject.o
.obj/moc_us_address.o-L/usr/local/qt-x11-free-3.2.3/lib  -L/usr/X11R6/lib -L/usr/local/utils/lib                            -lutils -lqt -lXext -lX11 -lm
54321582APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 582
Tells g++ to run the linker, and pass these options to ld.
Specify the output to be called hw7.Link these object files into the executable.Add another location for the linker to search for libraries.
Link this app with five more libraries: qt utils, ext, X11, and m54321C.2 UNDERSTANDING THE LINKER
583
FIGURE C.1 The linker’s inputs and outputsg++ linkermain.o address.og++ -c 
(compile only)
Y our executablemain.cpp, .h address.cpp, 
constraintmgr.cpp
Linking entails the following:
■For each library name passed with the -lswitch, find the corresponding
library file, searching the library path, as well as all -Lswitched argu-
ments (which were generated by qmake from the LIB qmake variable).
■ For static libraries, it contains the code to be linked into the executable.
■ For dynamic libraries, it is a catalog listing (often in readable ascii for-
mat) that describes where the actual shar ed objects are for each label
definition. The linker will check to make sure the shared object is whereit should be, and report an error if not.
■For each function that is called from any place in the code we are link-
ing, find the object where that code is located and do a simple, fast checkto determine that there is, indeed, a completely defined function with theezus_138004_appC.qxd  8/3/06  4:41 PM  Page 583
proper name/signature at that location. Report an error if it can’t be
found or isn’t the correct type/name/size.
■For each reference to a variable name, find the object-address where thatvariable is located and do a simple, fast check to make sure the address isa valid one for an object of that type.
This is the general idea. The linker resolves references to names by finding their
real addresses in files and checking the addresses to determine whether they’revalid for the type id. It’s like a directory look-up service for C++ compilers.
C.2.1 Common Linker Error Messages
C++ programmers sometimes spend lots of time trying to understand and repair
compiler and linker errors. If you can’t understand the message, you’re stuck. Witha compiler error, the problem is easier to diagnose because it is related to the com-pilation of one source code module and the header files it includes. The compilergenerally tells you the exact location of an y error that it detects. With a linker error,
the problem is related to how your source code modules link together. When thelinker stage is reached, all the individual modules have compiled without errors.Linker errors can be caused by bugs in C++ code, but they can also be a result ofmistakes in the project file.
C.2.1.1 Unable to Find libxxx.so.x 
For Win32 Users 
At build-time, your IDE needs to be able to find the .DLL. To configure it, drill
into your menu structure until you find project -> properties ->
c/c++ build -> libraries . Here you can add a third-party library, and
you’ll be asked in a dialog for the location of headers and DLL files.
At runtime, your PATH system environment variable must contain the
directory where the required DLLs are located.
Installing a library means making it available for more than a single user on a
system. It is also possible to reuse a library without installing it. All libraries thatyou reuse must either be installed or placed in a directory listed in yourLD_LIBRARY_PATH.584APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 584
When you are reusing a library for the first time, you will probably see this
error message. It means that the linker cannot find the library. When the gnulinker looks for a shared object, it checks at least two places:
1. The directories specified in 
LD_LIBRARY_PATH
2. Installed libraries referenced from a cache file called /etc/ld.so.cache
The Cache File ld.so.cache
The cache file provides fast lookup of shared objects found in the directories
specified in /etc/ld.so.conf . Some directories you might find there are
/lib
/usr/lib/usr/X11R6/lib/usr/i486-linuxlibc1/lib/usr/local/lib/usr/lib/mozilla
If you use a Linux package installer to install a library, it will probably make the
proper changes to 
ld.so.conf and rebuild your cache file. However, if you
manually compile and install libraries, it may be necessary for you to edit thisfile. Afterwards, you can rebuild the cache file with the command 
ldconfig .
C.2.1.2 Undefined Reference to [identifier]
This is the most common and probably the most annoying linker error of all. It
means that the linker cannot find the definition of some named entity in yourcode. Here is some output from 
make .
.obj/ca_address.o(.gnu.linkonce.t._ZN10DataObject16getConstraint-
MgrEv+0x4):In function ' DataObject::getConstraintMgr() ':
/usr/local/qt-x11-free-3.2.3/include/qshared.h:50:undefined reference to ' DataObject::sm_Cm '
collect2: ld returned 1 exit statusmake: *** [hw7] Error 1C.2 UNDERSTANDING THE LINKER
585ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 585
The compiler found the declaration, but the linker can’t find the corresponding
definition. In some part of your code, you are referencing a symbol, but there is no
definition found. The useful bits of information are
■The symbol it can’t find is DataObject::sm_Cm .
■The function that is trying to use it is
DataObject::getConstraintMgr .
The first step is to determine whether we, as humans, can find the missing defini-
tion. If we can’t, how can the linker? If we find it in a .cpp file, we must make surethat
■Both the .cpp and the .h file are mentioned in the project 
■The file is included in a library with which we are linking
Because we are using good naming conventions (see Section 3.4), we can immedi-
ately tell that sm_Cm is a static data member of class DataObject . The compiler
found the declaration, but the linker can’t find the definition.
Because it is static (Section 2.10), the definition for sm_Cm belongs in
dataobject.cpp . The compiler expects to find a definition statement of the
form:
ConstraintMgr DataObject::sm_Cm;
If it’s there and the linker still can’t find it, the most likely causes for this error are
■The .cpp file that contains the definition is not listed in qmake ’s
SOURCES in the .project file.
■The code is located in another library but the linker can’t find the library.
This is solved by adding a missing LIBS argument in the project file.
■-lmylib adds a library to be linked.
■-Lmylibdir adds a directory to the linker’s lib search path list.
C.2.1.3 Undefined Reference to vtable for ClassName 
This is one of the most confusing errors. It generally means that a virtual function
definition is missing. Literally, the vtable for that class (which has addresses of eachthe virtual functions) is unable to be fully constructed.586APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 586
This error can arise from missing function definitions in your code, but it can
also be caused by a missing HEADERS or SOURCES entry in your make/project file.
The resolution is to double-check that al l files are listed properly in the project file
before you delve too deeply into your C++ code.
All-inline Classes
For polymorphic classes,3there should be at least one non-inline definition
(function or static member) in a source (.cpp) file for that header file. Without
this, many linkers will not be able to find any of its virtual method definitions .
All-inline classes are legal in C++, but they do not work in their intended
way when mixed with polymorphism.
C.3 Debugging
The compiler can locate and describe syntax errors. The linker can reveal the exis-
tence of inconsistencies among program components and give some help as tohow to locate them. One of the most challenging aspects to using C++ is learninghow to find and fix various kinds of run-time errors.
Run-time errors are logical errors that can exist in a program that is syntacti-
cally correct and contains no undefined obje cts or functions. Effective use of a
debugger, a program specifically designe d for tracking down runtime errors, can
greatly reduce the amount of time spent dealing with these kinds of errors.
A debugger permits the stepwise execution of your code, as well as the inspec-
tion of object values. Since debuggers work with compiled code, the early versionscould only be used by programmers who were familiar with assembly language.Modern debuggers are able to step concurrently through the compiled machinecode and the original source code. The GNU family of developer tools includesgdb , the source-level GNU debugger, which we can use for C/C++ applications.
gdb has been designed with a command-line interface that is quite powerful but
not particularly user-friendly. Fortunately, there are several open-source graphicalfacades for gdb , one of which we will discuss below. Commercial C++ IDEs (e.g.,
Visual Studio) generally have built-in source-level debuggers.C.3 DEBUGGING
587
3classes with at least one virtual method ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 587
C.3.1 Building a Debuggable Target
For gdb to work, debugging symbols must be built into the code at compile time.
Otherwise, the machine instructions will not be mapped to locations in C++source files. This is easily accomplished by using the appropriate command-lineswitch (
-g) when invoking the compiler:
g++ -g filename.cpp
This often results in a significantly larger executable file. Generally, the growth is pro-
portional to the size and complexity of the source code files. The expanded executablecontains symbol table information that the debugger can use to find source code thatcorresponds to machine instructions. T o get
qmake to generate makefiles with the
-gswitch passed along to g++, add the following line to your qmake project file:
CONFIG += debug
When the Qt library has been built with debugging symbols, you can step throughthe Qt source code just as easily as your own code. Y ou may need to build Qt withdebugging symbols to debug certain programs that contain code directly calledfrom the Qt library.
BUILDING QT WITH DEBUGGING SYMBOLS In Win32, it’s a menu
choice you can click on. On *nix platforms, after unpacking the sourcecode tarball, pass a parameter to the 
configure script before building
and your Qt library will be built with debug symbols.
./configure --enable-debug
make
make install
EXERCISE: BUILDING A DEBUGGABLE
TARGET
■Compare the size of an executable file created with and without the CONFIG +=
debug line in the project file.
■Make a mental note to try this again later with a more complex application.588APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 588
C.3 DEBUGGING
589
4ris the command for “run.”C.3.2 gdb Quickstart
Imagine you are running a program and, for some mysterious reason, it crashes.
[lazarus] app> ./playlistmgr
Segmentation fault[lazarus] app> 
When your app aborts, or crashes, it is helpful to know (as quickly as possible)
exactly where it happened. We can use gdb to locate the trouble spot quickly and
easily.
[lazarus] app> gdb playlistmgr
GNU gdb 6.3-debianCopyright 2004 Free Software Foundation, Inc.This GDB was configured as "i386-linux"...Using host libthread_dblibrary "/lib/tls/libthread_db.so.1".
(gdb) r
4
Starting program: ftgui/app/playlistmgr
[Thread debugging using libthread_db enabled][New Thread -1227622176 (LWP 17021)]Qt: gdb: -nograb added to command-line options.
Use the -dograb option to enforce grabbing.
This is a debug message
Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread -1227622176 (LWP 17021)]0xb7f03320 in FormDialog::createActions (this=0x80ae2a0) at formdialog.cpp:5353          delete m_OkAction;(gdb)
gdb shows you not only the filename, and line number, but also the corre-
sponding line in the source code. However, we still might want to get some contextfor this error. The command
list shows you the surrounding source code for the
current file:
(gdb) list
51     void FormDialog::createActions() {5253         delete m_OkAction;54         delete m_CancelAction;55         m_OkAction = new OkAction(m_Model, m_View);56         m_CancelAction = new CancelAction(m_Model, m_View);57         QHBoxLayout *buttons = new QHBoxLayout(0);(gdb)                                               ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 589
The command where shows you the stack trace, or how we got there.
(gdb) where
#0  0xb7f03320 in FormDialog::createActions (this=0x80ae2a0) atformdialog.cpp:53#1  0xb7f03058 in FormDialog::setModel (this=0x80ae2a0,fmodel=0x80c80d0)
at formdialog.cpp:34
#2  0x080664bd in SettingsDialog (this=0x80ae2a0, parent=0x0) atsettingsdialog.cpp:14#3  0x0805f313 in MainWindow (this=0xbfffdec8) atmainwindow.cpp:42#4  0x08066f14 in Controller (this=0xbfffdec0, argc=1,argv=0xbfffdfe4) at controller.cpp:25#5  0x0805a8a4 in main (argc=1, argv=0xbfffdfe4) at main.cpp:7(gdb)     
Most open-source IDEs use gdb under the hood. They each offer a user interface
that makes certain features easier to learn and use. Four open-source apps thatprovide a front-end for 
gdb are:Eclipse ,kdevelop ,kdbg , and ddd.
VIEWING QSTRINGS INSIDE THE DEBUGGER QString s are hard
to see inside some debuggers because they are indirect pointersto Unicode data. The debugger needs to know extra things about a
QString in order to display it properly.
Download these Qt 4 helper macros from the KDE subversion repos-
itory5and put this in your ~/.gdbinit :
source /path/to/kde/kde-devel-gdb
define pqs
printq4string $arg0
end
Now you should be able to print qstrings with the pqs macro.
C.3.3 Finding Memory Errors
Memory errors are very difficult to track down without the aid of a run-time
analysis tool. A program that analyzes the running performance of a program iscalled a profiler .
valgrind is an open-source profiling tool for Linux that tracks590APPENDIX C: THE DEVELOPMENT ENVIRONMENT
5http://websvn.kde.org/*checkout*/trunk/KDE/kdesdk/scripts/kde-devel-gdbezus_138004_appC.qxd  8/3/06  4:41 PM  Page 590
the memory and CPU usage of your code and detects a variety of errors. These
include
■Memory leaks—memory that is no longer accessible but which has notbeen deleted
■Invalid pointer use for heap memory, such as
■ Out of bounds index
■ Mismatches between allocation and deallocation syntax (e.g., allocating
with new[] but deallocating with delete )
■Use of uninitialized memory
Each of the errors just listed can cause catastrophic results in a piece of software.
Profilers can also be used for performance tuning and determining which code isresponsible for slowing down a program (i.e., finding bottlenecks).
Example C.4 shows a short program that contains a deliberate memory usage
error.
EXAMPLE C.4 src/debugging/wrongdelete.cpp
void badpointer1(int* ip, int n) {
ip = new int[n];delete ip;  
}
int main() {
int* iptr;int num(4);badpointer1(iptr, num);
}
wrong delete syntax
For the output to be human readable, we compile with debugging symbols (-g).
debugging/wrongdelete> g++ -g -pedantic -Wall wrongdelete.cpp
debugging/wrongdelete> ./a.out
debugging/wrongdelete>
The compiler didn’t complain, and even after running the program, no error
behavior is exhibited. However, memory is corrupted by this program.11C.3 DEBUGGING
591ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 591
Here is a (slightly abbreviated) look at valgrind’s analysis of our program. We
have removed the process id of the valgrind job from the beginning of each line.The process id will, of course, be different each time you run valgrind.
src/debugging> valgrind a.out
--3332-- DWARF2 CFI reader: unhandled CFI instruction 0:50--3332-- DWARF2 CFI reader: unhandled CFI instruction 0:50
Mismatched free() / delete / delete []
at 0x401C1CB: operator delete(void*) (vg_replace_malloc.c:246)by 0x80484BD: badpointer1(int*, int) (wrongdelete.cpp:3)by 0x80484F4: main (wrongdelete.cpp:9)
Address 0x4277028 is 0 bytes inside a block of size 16 alloc'd
at 0x401BBF4: operator new[](unsigned)(vg_replace_malloc.c:197)
by 0x80484AC: badpointer1(int*, int) (wrongdelete.cpp:2)by 0x80484F4: main (wrongdelete.cpp:9)
valgrind found the errors and, with debugging symbols, could point us to the
location of the problem code. Example C.5 is a little more interesting because itcontains memory leaks and array index errors.
EXAMPLE C.5 src/debugging/valgrind-test.cpp
#include <iostream>
int badpointer2(int k) {
int* ip = new int[3];ip[0] = k;return ip[3];   
}                
int main() {
using namespace std;int* iptr;int num(4), k;  /* what is the state of iptr? */cout << iptr[num-1] << endl;cout << badpointer2(k) << endl;
}
out of bounds index
memory leak
k is uninitialized.321321592APPENDIX C: THE DEVELOPMENT ENVIRONMENTezus_138004_appC.qxd  8/3/06  4:41 PM  Page 592
Running Example C.5 through valgrind shows us the exact locations of some
errors.C.4 QT ASSISTANT AND DESIGNER
593
For more details, rerun with: -v
--2164-- DWARF2 CFI reader: unhandled CFI instruction 0:50
--2164-- DWARF2 CFI reader: unhandled CFI instruction 0:50
Use of uninitialised value of size 4
at 0x80486AF: main (valgrind-test.cpp:17)
68500558
Invalid read of size 4
at 0x804867C: badpointer2(int) (valgrind-test.cpp:8)by 0x80486DD: main (valgrind-test.cpp:18)
Address 0x4277034 is 0 bytes after a block of size 12 alloc'd
at 0x401BBF4: operator new[](unsigned) (vg_replace_malloc.c:197)by 0x8048667: badpointer2(int) (valgrind-test.cpp:6)by 0x80486DD: main (valgrind-test.cpp:18)
0
ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 19 from 1)
malloc/free: in use at exit: 12 bytes in 1 blocks.malloc/free: 1 allocs, 0 frees, 12 bytes allocated.For counts of detected errors, rerun with: -vsearching for pointers to 1 not-freed blocks.checked 120,048 bytes.
LEAK SUMMARY:
definitely lost: 12 bytes in 1 blocks.
possibly lost: 0 bytes in 0 blocks.
still reachable: 0 bytes in 0 blocks.
suppressed: 0  bytes in 0 blocks.
Use --leak-check=full to see details of leaked memory.
If this is not enough information to find where the memory leak is, we can rerun
valgrind with the switch --leak-check=full .
C.4 Qt Assistant and Designer
Qt comes with two developer’s tools: assistant and designer .
Assistant is an extensible help browser, similar to a Web browser, but it sup-
ports various built-in search and index capabilities.ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 593
Designer not only showcases most of Qt’s widgets, it also permits you to cre-
ate and lay out customized dialogs and widgets. After you are finished designingyour UI, Designer can write the following files for you:
widgetName .ui An xml file that represents a tree of objects and properties.
uic, or the “UI compiler,” comes with Qt and generates
C++ code from this xml file. uic gets run automatically
from make , because qmake generates a Makefile that
runs uic on all .ui files in the project.
projectName .pro Designer can open and manipulate qmake project files,
adding forms to the projects.
widgetName .ui.h C++ source code that is meant to be inserted into gener-
ated code by uic.
Qt Assistant provides tutorials for using the latest version of Qt Designer.
C.5 Open-Source IDEs and Development Tools
It is not practical to do object-oriented development with an ordinary text editor.
Object-oriented development involves working with many classes and many morefiles (headers and sources). Writing code in an edit window is just a small part ofthe development process. A good programmer’s editor or IDE (integrated devel-
opment environment ) should support many of the following features:
■Tree-like structured navigation to object/members in any file
■Refactoring assistance for moving/renaming members
■Integrated debugger
■Context-sensitive help linked to API documentation
■A built-in command-line shell window so you can run programs without
leaving your environment
■A project manager to help manage groups and subgroups of related files
■Editing modes in other programming languages
■Easy keyboard customization—the ability to make any keystroke per-form any task (cursor movement especially, but also window movement)
■An open plug-in architecture so you can add other components
■Integration with a version-control facility is desirable, especially inwindows environments. Look for CVS,
6Subversion,7or Darcs8.594APPENDIX C: THE DEVELOPMENT ENVIRONMENT
6https://www.cvshome.org/
7http://subversion.tigris.org/
8http://darcs.net/ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 594
■Learnable, scriptable macros
■Easy language-aware navigation to your different files (with shortcuts
such as “find declaration,” “find definition,” and “find references”)
An open-source option for Win32 users is Dev C++9from Bloodshed Software,
which works quite well with MinGW and cygwin.
KDE users can use KDevelop3,10a feature-rich, open-source IDE with excellent
C++ and code navigation features. It has built-in support for importing Qt’s
qmake project files. Simply select Project -> Import Existing Project from the menu
and choose the .pro file you wish to work with.
For all platforms, there is Eclipse,11a free Java-based open-source IDE. Y ou can
download plugins for C++ development,12as well as Qt/KDE development.13The
latter allows you to import qmake .pro files into Eclipse as projects directly.C.5 OPEN-SOURCE IDES AND DEVELOPMENT TOOLS
595
9http://www.bloodshed.net/devcpp.html
10http://www.kdevelop.org
11http://www.eclipse.org
12http://www.eclipse.org/cdt/
13http://kde-eclipse.pwsp.net/index.php
14http://kate.kde.org/Maximum Code Reuse: KDevelop
An interesting thing about KDevelop is that it embeds stand-alone applica-
tions and “plugs them in” to the QMainWindow as dock widgets. If you
already use KDE and some of the common *nix development tools, you willfind some familiar apps already available inside the dock windows. In the caseof KDevelop:
■ The debugger is a KDE front end to gdb , similar to kdbg .
■ For CVS browsing, KDevelop has integrated cervisia.
■ By default, KDevelop uses Kate14(the “KDE Advanced Text Editor”) for
editing.
(continued )ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 595
596APPENDIX C: THE DEVELOPMENT ENVIRONMENT
15http://konsole.kde.org/■ The designer for creating widgets is a customized version of Qt’s
Designer.
■ The command-line shell is a dockable window inside KDevelop. It’s the
regular KDE Konsole15xterminal.
Because KDevelop is built on top of KDE libraries, and KDE libraries are based
on Qt, using KDevelop will unable you to become more accustomed to howvarious Qt widgets work. See Figure C.2.
FIGURE C.2 KDevelopezus_138004_appC.qxd  8/3/06  4:41 PM  Page 596
C.5.1 UML Modeling Tools
For creating diagrams in this book using the Unified Modeling Language, we use
two open-source tools, Umbrello16and Dia.17Each tool uses an XML dialect as its
native file format.
Umbrello is the KDE UML Modeler. It can directly import C++ code, making it
very easy to drag and drop imported classes into diagrams, as shown in Figure C.3.C.5 OPEN-SOURCE IDES AND DEVELOPMENT TOOLS
597
16http://uml.sourceforge.net/index.php
17http://www.gnome.org/projects/dia/FIGURE C.3 Umbrello screenshot
Dia is a more general-purpose diagram tool with some UML features. There are
many plugins and utilities that let you import code and export diagrams to andfrom Dia to other languages and formats.
ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 597
C.5.2 jEdit
jEdit18is a mature, open-source, programmer’s text editor. Because it is written
entirely in Java, it works on all platforms. Its keyboard configurability is veryflexible—any action can be bound to a primary and an alternate shortcut.
T o install it, first download a recent (5.0) version of the Java Development
Kit (JDK) from http://java.sun.com, and then download the latest developmentversion of jEdit.
Before using it very much, it is recommended you install some additional pro-
grams for development in C++:
■Plugins: Navigator, Project Viewer, Optional, FastOpen, Info Viewer,Console, Code Browser, XML
■Exuberant ctags version 5.5 or later (for use with Code Browser)
■T oggleHeaderSource version 0.419or later for (easy switching between
header/source)598APPENDIX C: THE DEVELOPMENT ENVIRONMENT
18http://www.jedit.org
19http://community.jedit.org/?q=filestore/browse/34
FIGURE C.4 jEdit screenshotezus_138004_appC.qxd  8/3/06  4:41 PM  Page 598
Check the keyboard configurability, Global Options ->
Shortcuts . Notice that all the plugins and macros have their own
shortcut-able actions. And after you have included some plugins, checkout the
Global Options -> Docking and dock some of the plug-
in’s dockables to the sides of your edit window.C.5 OPEN-SOURCE IDES AND DEVELOPMENT TOOLS
599ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 599
ezus_138004_appC.qxd  8/3/06  4:41 PM  Page 600
Bibliography
C++ References
[Josuttis99] The C++ Standard Library. Nicolai Josuttis. 1999. Addison-Wesley
0-201-37926-0.
[Meyers] Effective C++. Scott Meyers. 1999. Addison-Wesley. 0-201-56364-9.
[Stroustrup97] The C++ Programming Language, Special Edition. Bjarne Stroustrup.
2000. Addison-Wesley. 0-201-70073-5.
Qt References
[Blanchette06] C++ GUI Programming with Qt 4. Jasmin Blanchette and Mark
Summerﬁeld. 2006. Prentice Hall. 0-13-187249-4.
[Blanchette04] C++ GUI Programming with Qt 3. Jasmin Blanchette and Mark
Summerﬁeld. 2004. Prentice Hall. 0-13-124072-2.
[qtapistyle] Designing Qt-Style C++ APIs. Matthias Ettrich. 2005. Trolltech.
http://doc.trolltech.com/qq/qq13-apis.html.
[qttestlib] Writing Unittests for Qt 4 and KDE4 with QtTestLib. Brad Harris. 2005.
developer.kde.org.
OOP References 
[Buschmann96] Pattern-Oriented Software Architecture. Frank Buschmann, Regine
Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. 1996. John Wiley &Sons. 0-471-95869-7.
601ezus_138004_bib.qxd  8/4/06  9:57 AM  Page 601
[Fowler04] UML Distilled, Third Edition. Martin Fowler. 2004. Addison-Wesley.
0-321-19368-7.
[Gamma95] Design Patterns. Erich Gamma, Richard Helm, Ralph Johnson, and
John Vlissides. 1995. Addison-Wesley.0-201-63361-2.
[Martin98] Pattern Languages of Program Design 3. Robert C. Martin, Dirk Riehle,
and Frank Buschmann. 1998. Addison-Wesley. pp. 293–312. 0-201-31011-2.
Docbook References 
[docbook] Docbook: The Deﬁnitive Guide. Norman Walsh. 2005. O’Reilly Associates.
http://www.docbook.org/tdg/en/html/docbook.html
[docbookxsl] Docbook XSL: The Complete Guide. Bob Stayton. 2005. SageHill
Enterprises. http://www.sagehill.net/docbookxsl/
Miscellaneous References 
[w3c] w3c Recommendation: XHTML 1.0 The Extensible HyperText Markup Language.
2005. W3C (World Wide Web Consortium). http://www.w3.org/TR/xhtml1/
[Friedl98] Mastering Regular Expression, Second Edition. Jeffrey Friedl. 1998.
O’Reilly. 1-56592-257-3.
[Rehman03] The Linux Development Platform. Rafeeq Ur Rehman and Christopher
Paul. 2003. Prentice Hall. 0-13-009115-4.
See Element Reference @ W3Schools.com (http://www.w3schools.com/
tags/default.asp) for a good quick reference guide.602BIBLIOGRAPHYezus_138004_bib.qxd  8/4/06  9:57 AM  Page 602
Index
Symbols and Numbers
–ansi switch, 13–14
–pedantic switch, 14–Wall switch, 14—(double dash), unary decrement 
operator, 26, 510
#(pound character), for preprocessor 
directives, 15
#deﬁne macro, 127#ifndef wrapper, 579#include
customizing using inheritance, 186–189ﬁnding header ﬁles, 85–86overview of, 15preprocessor and, 579–581unnecessary dependencies produced
by, 174–175
$ (dollar sign), anchoring characters, 312% (percent sign), modulus operator, 26–27& (ampersand)
reference parameters using, 118type modiﬁer, 44unary address-of operator, 36–38
* (asterisk)
multiplication operator, 26quantiﬁer expressions, 311unary deference operator, 37
/* and */, in comments, 15*nix platform
ﬁxing linker path, 177installing libraries on, 176–178open source development tools, 7–9USER environment variable, 280viewing manual pages, 14
(...) (ellipsis), 542:/., pathname formats and, 250:: (ﬁle scope resolution operator), 468
[ ] (square brackets), in command-line 
arguments, 158
^ (caret), anchoring characters, 312+ (plus sign), addition operator, 25, 510++ (double plus sign), unary increment
operator, 26, 510
< (less than), 27< > (angle brackets), #include directive,
85–86
/H11270(insertion operator), 16
<= (less than or equal to), 27= (assignment operator). SeeAssignment
operators
!= (not equal to), 27== (equal to), 27> (greater than), 27>= (greater than or equal to), 27/H11271(input operator), 16
. (dot)
in bash shell, 178member access and, 118regular expression meta-character, 310operator overloading and, 115
! (exclamation), unary not operator, 27? (question mark), quantiﬁer 
expressions, 311
/ (slash)
division operator, 26as namespace delimiter, 567
– (subtraction operator), 25, 510, (comma operator), 115( ) parentheses
grouping and capturing characters, 312macros and, 128
8-bit integer, 445–446
603ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 603
A
Abstract base classes, 148–152
Abstract Factory pattern
beneﬁts of, 369–372creating rules and friend functions,
366–369
deﬁned, 360exercises, 372–373importing objects, 376–380and libraries, 363–365overview of, 361–363qApp and Singleton pattern, 365–366
Abstract interfaces, multiple inheritance
with, 531–532
Accessibility, 52actionEvent( ), 265–266Adaptor pattern, 386–389addAction( ), 262, 264Addition (+) operator, 25AddLayout, widgets, 251–252Address of (&), unary operators, 36–38Addresses, pass-by-reference, 119addSpacing( ), 254–255addStretch( ), 254–255addStrut( ), 254–255addWidget( ), 251Aggregate containers, 222–224Aggregate relationships
deﬁned, 100pointer containers and, 221–224
Algorithms, generic, 225–227Aliases, namespace, 475amaroK, 427–428American National Standards Institute.
SeeANSI (American National
Standards Institute)
Ampersand character (&), reference 
parameters using, 44, 118
Ampersand character (&), urnary 
operator, 36–38
Anchoring characters, regular 
expressions, 312
Animation, QThread, 290–294Anonymous namespaces, 476ANSI (American National Standards
Institute)
ANSI C89, 575ANSI/ISO Draft Standard for C++, 6–7new operator, 515typecasts, 346, 450Anti-patterns, 342–343
API (Application Programmer’s 
Interface), 179
Applications, reusable components, 171ArgumentList, 159–163Arguments, processing command-line,
158–163
Arithmetic operators
addition, 25, 510division, 26modulus, 26–27multiplication, 26overview of, 24–25pointers and, 510–511, 513–514subtraction, 25symbols for, 438
Array elements, 509Arrays
functions and return values and,
511–512
kinds of, 513new failures and, 515–519overview of, 509–510reasons to avoid using in C++, 96review questions, 521summary, 519–520
Assignable data types, 221Assignment operators
with auto_ptr, 385copy, 64–67, 156for implicitly shared classes, 224pointers and, 513symbols for, 438
Assistant, Qt, 593–594Associations, 101Attributes
Qt naming conventions, 90XML tags, 324
auto_ptr, 384–385, 388–389
B
Base classes, 136–140
derivation from abstract, 148–152extending, 140–142inheritance and, 136initializing, 531member initialization for, 140order of initialization, 156overloading, function hiding, and 
overriding, 154–155604INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 604
parent objects vs., 193
subclasses derived from, 137virtual, 535–536
Bash scripts, 178Behavioral patterns, 182Bi-directional association, in QObject, 193Binary operators, 115Binding
compile-time, 144run-time, 142, 144
Bitwise operators, 438Block scope
vs.ﬁle scope, 468–469
identiﬁer, 466overview of, 52–53, 465statics deﬁned inside, 63
Block statements, 480Boolean
expressions, 480–481operators, 27–28types, 22–24
boost, 179break
from loops, 484from switch, 481
Button widgets, 239byte, arrays, 513
C
C
C++ as extension of, 6preprocessor, 579standard Library, 578
“C with Objects,” 6C++, 5–46
arithmetic operators, 25–29brief history of, 6–7const, 34–35, 40–43ﬁrst example, 12–16identiﬁers, 19–22input and output, 16–19literals, 19–22main( ) and command line 
arguments, 24–25
overview of, 6pointers and memory access, 36–40preprocessor, 579reference materials for, 601reference variables, 43–44reserved keywords, 575–576 scope options, 465–466
simple types, 22–24standard Library, 578standard library strings, 30–31streams, 31–34types, 19–22variable initialization, 465
The C++ Programming Language
(Stroustrup), 6–7
Callbacks
deﬁned, 327importing objects with Abstract 
Factory, 380
case labels, 482CaseIgnoreStrings, 227Case-sensitivity, Qt naming conventions, 90Casts, Casting. SeeTypecasting
catch statements
overview of, 490–494rethrowing caught exceptions, 496throw and, 502
Categories, QWidgets, 239–240Central widget, 270–272cerr
global stream, 31–34input and output, 16
char
arrays, 381, 513throwing, 497
Character sets, regular expressions, 312Character types, 22–24characters( ), 329Children, QObject
Composite pattern, 196–199environment variables, 281–282ﬁnding, 199management of, 194–196overview of, 192–193QProcess, 279QWidgets interacting with, 238widget layout, 202–204, 252
Children, XML elements, 324cin
global stream, 31–34input and output, 16–19
cinclude2dot, 175Circular dependencies, 582class deﬁnitions
friend declarations within, 56overview of, 49–51INDEX
605ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 605
Class scope
deﬁned, 51identiﬁer, 467overview of, 466
Class templates, generating generic 
containers, 216–219
Classes, 47–79
const member functions, 68–78constructors, 56–58conversions, 67–68copy constructors and assignment 
operators and, 64–67
deﬁnitions, 49–51, 464destructors, 60encapsulation, 54form views, 400friends of, 55–56member access speciﬁers, 51–53Qt naming conventions, 90reusable components, 171static keyword, 61–64structs, 48–49subobjects, 58–59templates, 216–219UML, 54–55
className( ), 344Client code, 51–53Code containers, 170–171Code reuse, 579CodeVisitor
customizing using inheritance,
186–189
decoupling, 188–189
Comma operator (,), 115Command line arguments
main( ) function and, 24–25processing, 158–163
Command pattern, 262–267Comments, 15Comparison, pointer operations, 514Compilers
GNU C compiler (Gcc), 13–15moc (Meta Object Compiler),
209–210
switches, 13–14syntax errors, 587
Compile-time
binding, 144dependency, 173
Complex numbers, 112–114Components
Composite pattern, 196–197frameworks with reusable, 179library, 179
Composite pattern
DOM as application of, 330managed containers and, 221–224overview of, 196–197QTreeWidgetItem as implementation of,
417–418
Composition relationships, UML
deﬁned, 55, 99pointer containers and, 221–224
Compound statements, 480Concrete class, 148Concurrency, 277–305
QProcess. SeeQProcess
QThread. SeeQThread
Conditional
statements, 481–482expressions, 28
Conﬂicts, resolving multiple inheritance
conﬂicts, 532–534
Connect to slots, 203–204, 292const
const* and *const, 40–43declaring reference parameter to be,
121–122
and globals, 471–472implicitly shared classes vs., 225
members, 68–78overloading on const-ness,
124–126
overview of, 34–35pointers, 40–43, 513
const_cast, 450–453Constructors (ctor)
conversion, 67–68copy constructors, 64–67exceptions and, 488inheritance and, 155–157overview of, 56–58polymorphism from, 370–372
Container widgets, 240Containers
arrays and, 513class templates generating, 216–219code, 170–171deﬁned, 96, 219exercises and review questions, 233–235606INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 606
generics and, 219–221
implicitly shared, 224–225managed, 221–224overview of, 96–97property, 355–356Qt, 504Serializer pattern, 227–229sorted map example, 229–232
Context menus, 261continue, loops, 484Control, inversion of, 325Control structures
deﬁned, 479exception expressions, 497–501exception handling, 486exceptions, 485iteration structures, 483–485rethrown exceptions and, 496–497review questions, 502throw statements, 486–488try and catch statements, 490–494
Controller classes
deﬁned, 284, 393GUI development, 240MP3 player, 553
Controller code, 392, 394–395Controlling actions, 404–405Convenience functions, ID3Lib, 384Conversions
expressions, 447–449overview of, 67–68
Copy assignment operators,
65–67, 156
Copy constructors
assignment operators and, 64–67for implicitly shared classes, 224never inherited, 156–157not public in QObject, 192
Core module, Qt, 91cout
global stream, 31–34input and output, 16
.cpp extension, class deﬁnitions, 50CPPLIBS
as environment variable, 280reusing other libraries, 171–172
Creational patterns, 360–372
applying, 360–361beneﬁts of, 369–372deﬁned, 182exercises, 372–373
libraries and, 363–365overview of, 361–363qApp and Singleton pattern, 365–366review questions, 390rules and friend functions, 366–369
Cross-language mechanism, 280–281ctor. SeeConstructors (ctor)
CustomerFactory, Abstract Factories,
363–365
Cycle, 175Cygwin, 12
D
Data members, Qt naming conventions, 90Data model, Mp3File, 553–555Data types
assignable, 221GUI development and, 240literals of, 20
Database models
GUI development and, 240Qt SQL, 429–432
Database view, MP3 player, 569–571DataObject
encoding/decoding as XML, 373–375form model, 405–409overview of, 353–354
DataObjectReader, 377–380DataObjectTableModel, 412–417Debugging
building debuggable target, 588–589GNU debugger, 589–590with loggers, 296–297memory errors, 591–593overview of, 587–588
Declarations
applying, 475deﬁnitions compared with, 465names, 464–465
Decoupling, 188–189Decrement (—), unary operators, 26Default arguments, 109Default constructors, 57–58Default labels, 482Deference (*), unary operators, 37Deﬁnitions
class, 49–51, 56, 464declarations compared with, 465environment variables on *nix, 178INDEX
607ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 607
Deﬁnitions ( continued )
object, function, and class, 464–465polymorphic types, 524private, protected, and public 
members, 52
Serializer pattern, 227–229tables in MySQL, 425–426template deﬁnitions in header ﬁles, 217undeﬁned pointers, 508undeﬁned reference to [identiﬁer],
586–587
delegates 360, 395, 405, 406delete operator
applying to pointers, 506–507heap objects and, 470overview of, 39
Dependencies
circular, 582compile-time, 173customizing using inheritance, 187–188deﬁned, 173managing library, 173–175
Derivation
from abstract base class, 148–152from ArgumentList, 160–163kinds of, 138polymorphism and, 142–147public, protected, and private, 536–538simple, 136–140
Derived classes
employing inheritance using, 137–138order of initialization, 156overloading, function hiding, and 
overriding, 154–155
Deserialization, playlists, 560Design, inheritance, 152–153Design patterns, 182–190
Abstract Factory pattern, 360, 361–363Adaptor pattern, 386–389anti-patterns, 342–343Behavorial patterns, 182Command pattern, 262–267Composite pattern, 196–199, 330Creational pattern, 189–190Façade pattern. SeeFaçade patterns
implementing frameworks with, 179Interpreter pattern, 524Iteration and Visitor pattern,
customizing, 184–189
MetaObject pattern, 344–345Model-View-Controller (MVC),
392–393
Monostate pattern, 242Observer (publish-subscribe) pattern, 200overview of, 182Reﬂection pattern, 344Serializer pattern, 227–229, 373–380Strategy pattern, 396Visitor pattern, 182–189, 331–334Wrapper pattern, 386
Designer, Qt, 593–594DESTDIR variable, 176, 249Destructors (dtor)
exceptions and, 488never inherited, 158overview of, 60static keyword and, 61–64virtual, 526–528
DevC++, 595Devel package, reusable components, 171Development environment, 579–599
building debuggable target, 588–589debugging, 587–588GNU debugger and, 588–590jEdit, 598–599linker, 582–584linker error messages, 584–587open source IDEs and development tools,
594–597
preprocessor, 579–581Qt assistant and designer, 593–594UML modeling tools, 597
Development tools, open source, 594–597Dia, UML modeling tools, 597Dialogs
exercise, 248input dialogs and widgets, 246–247overview of, 244–246
Directives, preprocessor, 475Directories
installing libraries in, 176visiting code for, 183
Display widgets, 240distort( ), 300Division (/) operator, 26.dll ﬁle, 176do
loop, 484
Docbook, 323, 602 DocbookDoc class, 335–339
608INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 608
DockWindows, 270–272
DOM (Document Object Model)
classes, 330deﬁned, 329SAX vs., 330
DomWalker, 332Dot (.)
in bash shell, 178operator overloading and, 115
d o  ...w hile, iteration structures, 484
Downcasting. See RTTI
dtor. SeeDestructors (dtor)
Dynamic form models, 393–397Dynamic memory, 511–512Dynamic run-time binding, 144dynamic_cast. See also Typecasting
deﬁned, 345qobject_cast similar to, 346typecasting, 454–456
E
Eclipse, 595Editing, with macro expansion, 128Editors, XML, 324Elements, array, 509Ellipsis (. . .), 542else, conditional statement, 481emit, 201, 205Encapsulation, 54Encryption, 130–132endElement( ), 378–379endl, as manipulator, 17Entries (array elements), 509enum
converting strings to, 350keyword, 443–445
Enumerations, 443–445enumerator( ), 350Env command, 10Environment variables
on *nix platform, 178processes and, 280–281
Equivalence relation, 233–234Errors
liability of macro expansion, 128–129linker error messages, 584–587
Event loop, 201. See also QApplication, and
event loop
Event-driven parsing, XML, 325–329eventﬁlter( ), Qonsole, 286–288Events
Qonsole with keyboard, 286–288QWidgets handling of, 238
Exception
expressions, 497–501handling, 486overview of, 485rethrown, 496–497safety, 302throw( ) in function signature, 488–489throw statements, 486–488try statements, 490–494
Explicit conversions (casts), 449explicit keyword, 68Exporting, to XML, 375–376Expressions
evaluating logical expressions, 443explicit conversions (typecasts), 449standard conversions, 447–449
Extended regular expressions,
Perl-style, 310–311
Extending, 140–141eXtensible Markup Language. SeeXML
(eXtensible Markup Language)
extern keyword
declaring static objects, 476–477ﬁle scope and, 467global scope and, 466
F
Façade patterns
exercises, 389Filetagger example, 385–389functional, 384overview of, 381–383review questions, 390smart pointers, 384–385
Factories
creating questions for forms with,
398–399
deﬁned, 360
Factory method, 360ﬁfo (incoming message queue), 298File formats, MP3 player, 560File scope
vs.block scope, 468–469
vs.global scope, 466
overview of, 466
Filenames, ﬁnding header ﬁles, 86Files, visiting code for, 183INDEX
609ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 609
FileTagger
auto-generated form, 407façade example, 386–389MP3 player, 553, 568SQL table, 426
FileVisitor
customizing using inheritance, 186–189making into reusable tool, 184–186
Filters, MP3 player, 561–563ﬁndChildren( ), 199Floating point numbers, 22–24ﬂush, as manipulator, 17for loops, iteration structures, 484Form views
dynamic form models, 395for MP3 player, 568–569overview of, 400–402
FormDialog, 400FormFactory, 399FormModel, 397–399, 405–409Forms
deﬁned, 393dynamic model, 393–397
FormView, 395, 400–402Forward declarations, 175, 580–582Frameworks, library, 178–179friend 
keyword, 55–56functions, 366–369
Functions, 105–133
declaring, 106–107declaring inline, 126–127deﬁning, 464ellipsis (. . .) and, 542exceptions, 488–489exercises and review questions, 130–133global, 114hiding, 154–155inline vs. macro expansion, 127–130invoking with QMetaObject, 344main( ), 24–25operator overloading as, 111–116with optional arguments, 109–111overloading, 107–109, 154overloading on const-ness, 124–126overriding, 154overview of, 105passing parameters by reference, 118–121passing parameters by value, 116–117prototypes, 106–107public, 54
QObjects can never be passed by value 
to any, 192
Qt naming conventions, 90references to const, 121–122return values, 122returning references from, 122–124scope, 465, 467templates, 214–216with variable-length argument 
lists, 542–543
virtual, 414
G
Garbage collection, 543Gcc (GNU C compiler), 13–15gdb (GNU debugger), 588–590Generalization, 137Generic containers, 96Generics. See also T emplates
algorithms and operators, 225–227deﬁned, 96exercises and review questions, 233–235templates, 214–219
getChar( ), 279getClassName( ), 138–139getline( ) function, 31getSwitch( ), 161Global functions, 114Global scope, 471
vs.ﬁle scope, 466
identiﬁer, 466partitioning into sub-scopes, 473
GNU C compiler (Gcc), 13–15GNU debugger (gdb), 588–590goto
avoiding in code, 468switch statement and, 482
Graphic images, 248–251Grouping characters, regular expressions, 312Gui module, Qt, 91
H
handler, invoking parser, 325–326Handler classes, 545Header ﬁles
class deﬁnition deﬁned in, 49–50ﬁnding with #include, 85–86libraries packaged as lib+, 170610INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 610
reusable components, 171
template deﬁnitions in, 217
Heap arrays, 96Heap memory
beneﬁts of factories, 369corruption, 504garbage collection and, 543new operator allocating storage 
from, 38
pointer problems and, 506–508storage class and, 470
Heavyweight objects, 355Hiding functions, 154–155Hierarchy, types, 22, 447HOME, environment variable, 280Host object, 68HOSTNAME, environment variable, 280HTML (HyperT ext Markup Language)
converting XML into, 335–336uses of, 323XML vs., 322–323
I
ID3 tags, 381–383
reusing, 559–560
ID3Lib
convenience functions, 384façade example, 385–389overview of, 381–383
Identiﬁers
overview of, 19–22scope of, 51, 465
Identity, QObject, 192–193IDEs (integrated development environments)
ﬁnding header ﬁles within, 86open source, 594–597
if statement, 481Images, QWidgets, 248–251Implementation
class deﬁnitions, 50–51of encapsulation, 54relationships, 537
Implicitly shared containers, 224–225Importing objects, with Abstract 
Factory, 376–380
Importing objects with Abstract Factory,
SAX parser, 377
Include path, ﬁles, 85–86Incomplete types, 581Increment (++), unary operators, 26Indexing, pointer operations, 514
indexOfProperty( ), 350Indirection
deﬁned, 38pointer operations, 514
Info command, 14Inheritance, 135–165, 523–539. See also
Multiple inheritance
base classes and, 136client code example, 141–142command-line arguments, processing,
158–160
constructors and, 155–157copy assignment operators and, 156copy constructors and, 156–157deﬁned, 136derivation and ArgumentList, 160–163derivation from abstract base 
class, 148–152
derivation with polymorphism,
142–147
design, 152–153destructors and, 158exercises and review questions, 163–165function hiding, 154–155member initialization and, 140, 531multiple, 528–532order of initialization, 156overloading, 154overriding, 154polymorphism and virtual destructors,
526–528
public, protected, and private derivation,
536–538
QStringList and, 97–99resolving multiple inheritance conﬂicts,
532–534
review questions, 539simple derivation, 136–140virtual base classes and, 535–536virtual inheritance, 534–535virtual pointers and virtual tables and,
524–526
visitor customization with, 186–189
inherits( ), 347Initialization
base class members, 140class members, 531static, 63–64validators, 309INDEX
611ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 611
Inline functions
#deﬁne macro vs., 127
macro expansion vs., 127–129
overview of, 126–127
Input and output, 16–19Input dialogs
exercise, 248and widgets, 246–247
Input widgets
deﬁned, 239dynamic form models, 396form views, 402overview of, 308–309unforeseen types, 403–404
InputField
dynamic forms, 396–397form views, 400–402
Insertion operator ( /H11270), 16
installEventFilter( ), 288instance( )
AbstractFactory and, 361Singleton pattern, 365
Instances, class deﬁnitions, 49Instantiated, template, 215int, Integer Types
arrays and, 512enumerating, 443overview of, 22–24promotion, 447signed and unsigned, 445–446throwing, 497
Integrated development 
environments (IDEs)
ﬁnding header ﬁles within, 86open source, 594–597
Interface
generic containers, 96relationships between classes, 536–537
Internationalization, QObject and, 211Inversion of control, 325iostream, 31is-a relationships, 537ISO, ANSI/ISO Draft Standard 
for C++, 7
istream, 16–19Item models, Qt 4, 409Iteration
deﬁned, 16exercises, 101–103, 485overview of, 97QStringList and, 97–99
structures, 483–484
Iteration, and Visitor pattern, 182–190
customizing with inheritance, 186–189exercises and review questions, 189–190overview of, 184–186QDir and QFileInfo (directories 
and ﬁles), 183
J
JDBC classes, 429JEdit, 598–599join( ), 97–99
K
kdbg, 271KDE 3.x (K Desktop Environment), 7KDE debugger, 271KDevelop, 595–596Keyboard events, Qonsole with, 286–288keyT oValue( ), 350Keywords
C++ reserved, 575–576const, 34–35enum, 443–445explicit, 68extern, 467, 476–477friend, 55–56modifying simple types, 22static, 61–64, 467using, 475virtual, 142–147
L
Late run-time binding, 144Layouts
GUI development, 240QObject, 202–203QWidgets. SeeQLayout, widgets
LD_LIBRARY_PATH, 176–177Leaf nodes, Composite pattern, 197lib ﬁles, 170libcustomer, 363–365libdataobjects, 363–365libgtk++, 179Libraries, 169–180
Abstract Factories and, 363–365code containers, 170–171612INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 612
components, 179
deﬁned, 169dependency management, 173–175ﬁnding header ﬁles within, 86frameworks, 178–179graphic image, 248–251ID3Lib, 381–383installing, 176–178, 585overview of, 170and plugins, 370QWidget and, 239reusing, 171–172review questions, 180
LIBS variable, 172libutils, 171Linker
arguments to, 583error messages, 584–587linking process, 584overview of, 582–584path, 177switches, 172
Link-time dependency, 173The Linux Development Platform 
(Rehman and Paul), 84
List view, media player, 552Lists, 95–103
containers, 96–97exercises and review questions,
101–103
iterators, 97–99overview of, 95relationships, 99–101
Literals, 19–22Local variables, 350Loggers
debugging with, 296–297deﬁned, 296
Logical expressions, evaluating, 443Logical operators, 438LogWindow, 296loops
break and continue, 484for, 484
lupdate tool, 211Lvalue, 43
M
M3U ﬁle format, 560Macro expansion, 127–129main( )
overview of, 24–25QObject child management, 194–196QSettings, 243
make command
cleaning up ﬁles, 88–89handling project ﬁles with, 84–85overview of, 86–88
make dist command, 89makedep dependency generator, 175Makeﬁle
cleaning up ﬁles, 89example of qmake building, 86–88overview of, 84replaced in Qt by qmake, 85
man command, 14Managed containers
implicitly shared, 224–225overview of, 221–224
Manipulators
deﬁned, 17stream, 31–32
Manual pages, viewing on nix system, 14Mapping layer, 415Media players
components, 552–553MP3 player view features, 563–564
Member access speciﬁers, 51–53Member functions, 114Member initialization, 57–58, 531Member selection operators, 457–458Memory access, 503–509
arrays and. SeeArrays
overview of, 504pointer problems and, 504–506pointer problems with heap 
memory, 506–508
pointers, 36–40review questions, 521summary, 509
Memory allocation, thrashing and, 515Memory corruption, 506Memory heap. SeeHeap memory
Memory leaks, 506–507Memory management operators, 438Meta Object Compiler (moc), 209–210Meta-characters, regular expression, 310–312Metadata, MP3 songs, 381, 559MetaObject pattern, 344–345, 373–375methodCount( ), 344INDEX
613ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 613
MinGW (Minimalist Gnu for Windows), 12
Mixed expressions, 27moc (Meta Object Compiler), 209–210modal attribute, 244Models and views, 391–421
controller code, 392controlling actions, 404–405DataObject form model, 405–409dynamic form models, 393–397form models, 397–399form views, 400–402GUI development, 240Model-View-Controller (MVC), 392–393Qt 4, 409–411review questions, 421separating models from views, 392table models, 411–417tree models, 417–420unforeseen types, 403–404
Model-View-Controller (MVC), 392–393Modules, Qt 4, 91Modulus (%) operator, 26–27mono, 179Monostate pattern, 242Movie player
QPixmap and animation, 290–294with QTimer, 294–295
MovieThread, QPixmap and animation,
290–294
MP3 ﬁles, 381, 553–555MP3 jukebox assignments
data model:Mp3File, 553–555database view, 569–571form view for FileTagger, 568–569ID3 tags, reusing, 559–560media player, 552–553MP3 player view features, 563–564persistent settings, 567–568play list models, 565play list serialization, 560Preference class, enumerating, 556–559queries and ﬁlters, 561–563source selector, 566–567testing Mp3File related classes, 561visitor generating playlists, 555–556
MSYS (from Minimalist Gnu for 
Windows), 12
Multiple inheritance
with abstract interfaces, 531–532overview of, 528–529QWidgets using, 238
resolving conﬂicts, 532–534syntax, 529–531
Multiple threads, 296–302Multiplication (*) operator, 26Multithreaded environments, 369MVC (Model-View-Controller), 392–393MySQL, 424–427
connecting from Qt, 425overview of, 424–425row insertion, 426–427table deﬁnition, 425–426
N
Namespaces
aliases, 475anonymous, 476delimiter for, 567open, 476overview of, 15partitioning global scope into 
sub-scopes, 473
reusable components, 171scope identiﬁer, 467static objects and extern keyword and,
476–477
using keyword and, 475
Naming conventions
destructors, 60Qt guidelines, 90–91
Net module, Qt, 91new operator
failures, 515–519heap objects and, 470memory leaks and, 507overview of, 38–39
newObject( ), 361–365, 380nix platform. See*nix platform
Nodes, XML, 324, 330Non-const reference parameters, 118–119Not (!), unary operator, 27nothrow, 544NULL
new failures and, 518–519pointers, 36, 506
O
Object ﬁles, 170Object module, 171614INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 614
Object oriented programming (OOP),
601–602
ObjectFactory
Abstract Factories and libraries and,
362–365
managing singleton instance of, 365–366in multithreaded applications, 369
Objects
changes to, 544–547class deﬁnitions, 49, 464deﬁned, 36global, 471resource sharing and, 543subobjects, 58–59
objectT oXML ( ), 375–376Observer (publish-subscribe) pattern, 200Observer pattern, 200OkAction, 404–405One-to-many relationship, 99One-to-one relationship, 99Online resources
ANSI/ISO Draft Standard for C++, 7downloading open source tarball, 9–11gcc documentation, 14qmake, 89Qt, 89Qt 4 Thread Support, 302shell scripting, 178
OOP (object oriented programming),
601–602
Open namespaces, 476Open source
deﬁning, 7downloading from source, 9–11IDEs and development tools, 594–597requiring Qt 4, 7–9
Operations, with pointers, 513–514Operators, 438–442
arithmetic. SeeArithmetic operators
assignment. SeeAssignment operators
binary, 115boolean, 27–28characteristics of, 439classiﬁed by use, 438delete, 39, 470, 506–507generic, 225–227insertion, 16list of C++ operators, 440–442member selection, 457–458modulus, 26–27new, 38–39, 470, 507, 515–519
overloading, 111–116Run-Time Type Identiﬁcation, 345–347scope resolution, 50, 468Serializer pattern and overloaded i/o,
227–229
shortcut, 26sizeof( ), 23–24typecast, 346typeid, 345unary, 26–27, 36–38, 115
Optional arguments
enclosing in square brackets, 158functions with, 109–111
Ostream, input and output, 16–19Output. SeeInput and output
Overloading
on const-ness, 124–126functions, 107–109, 154operators, 111–116unary operators and, 115
Overriding functions, 154
P
Parameters
command-line arguments, 158function prototypes using, 106–107optional arguments and, 109–111QSettings string, 242reference, declaring to be const, 121–122reference, overview of, 118–121template vs. function, 214
value, 116–117
Parents, QObject
base classes vs., 193
Composite pattern, 196–199layout of widgets, 251overview of, 192–193QProcess, 279QWidgets interacting with, 238
Parents, XML elements, 324parse( ), 325–326, 329Parse event handler, 327Parsers
event-driven, 325–329SAX, 330–334, 377XML, 327
Partitioning, global scope into 
sub-scopes, 473INDEX
615ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 615
Pass-by-pointer, 120–121
Pass-by-reference, 120–121Passive interface, 201, 326–327PATH
as environment variable, 280ﬁxing linker path in Windows, 176–177
Paths, ﬁnding header ﬁles, 85–86Patterns. SeeDesign patterns
Performance, inline functions and, 126–127Perl, regular expressions, 311Persistent settings, MP3 player, 567–568Play lists, MP3 player, 555–556, 561Player view, MP3 player, 552, 563–564Plug-ins
and libraries, 370parsing XML with, 327
Pointers
arithmetic operators and, 510–511const, 513containers, 221heap memory problems and, 506–508memory access and, 36–40operations with, 513–514overview of, 22–24problems due to improper handling of,
504–506
to QObject children, 192smart, 39, 457symbols for, 438
Polymorphism
from constructors, 370–372deﬁning polymorphic type, 524derivation with, 142–147exercises and review questions, 163–165virtual destructors and, 526–528
POSIX (Portable Operating System Interface
for UNIX), 7–9
Preference class, enumerating for MP3 player,
556–559
Prepared statements, 427Preprocessor
development environment, 579–581directives, 15macros, 35
Primitives, 350private derivation, 530, 536–538private member, 52, 55.pro ﬁle, 89process( ), 300Process control. SeeQProcessprocessDir( ), 186
processFile( ), 184–186, 187Proﬁler, ﬁnding memory errors, 591–593Program stack, storage class and, 470Programming style, Qt guidelines, 90–91Project ﬁles
cleaning up, 88–89deﬁned, 83ﬁnding header ﬁles, 85–86handling with make command,
83–85, 86–88
Promotion, expression conversion, 447Properties
accessing, 350–352containers (PropsMap), 355–356describing QObject, 347–350
property( ), 352PropQuestion, 406, 408PropsMap, 355–356, 362protected derivation, 530, 536–538protected member, 52, 137public derivation, 530, 536–538public functions, 54Public interface, 54public member, 52, 55Pure virtual functions, in abstract base 
classes, 149–152
push( ), 218
Q
Q_ENUM macro, 350Q_PROPERTY macro, 347–350, 351QAbstractItemModel, 417QAbstractTableModel, 411–412, 414, 429QAbstractxxxModel, 411QActionGroups, 262–267QActions
exercises, 267–269implementing Command pattern,
262–267
QMenu, QMenuBar and, 260–262Qtoolbars, QActionGroups and,
262–270
synchronizing data between model and
view, 403–404
qApp
deﬁned, 203signals and slots, 204–209Singleton pattern and, 365–366616INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 616
QApplication, and event loop, 200–209
connecting to slots, 203–204layouts, 202–203overview of, 200–202signals and slots, 204–209
QApplication, example creating, 82–83QBoxLayout, 251QByteArray, QSettings, 242–243QCache<Key,T>, 220QCoreApplication functions, 242QDate member functions, 92–93QDefaultxxxModel, 411qDeleteAll ( ), 222QDialog, 244–247QDir, 183QDockWidgets, 270–272QDomDocument, 330, 339QDomElement, 330, 333, 335–336QDomNode, 330–331, 333, 339QDoubleValidator, 308–309QEvents, 200–202, 286QFileInfo, 183QGridLayout, 251–260QHash<Key,T>, 220QHBoxLayout, 251QImage, 249QIntValidator, 308–309qjots application, 418–420QLabel, 82–83, 253QLayout, widgets, 251–260
exercises, 258–260moving widgets across layouts, 256–258overview of, 202–203, 251–254spacing, stretching and struts, 254–255
QLineEdit, 402QLinkedList<T>, 220QList, 96–97, 102QList<QString>, 220QList<T>, 219QListView, 417QMainWindow
managing dock window regions,
270–272
overview of, 240–241QSettings and, 242–243restoreState( ), 243saveState( ), 242
qmake
cleaning up ﬁles, 89example of, 86–88installing libraries, 176–177
online guide to, 89overview of, 85reusing other libraries, 172downloading from source, 10Win32 setup, 12
QMap
example of, 229–234implementing property containers,
355–356
QMap<Key,T>, 220QMenu, 260–262, 267–270QMenuBar, 260–262, 267–270QMessageBox, 244–246QMetaObject, 344–345QMetaProperty
accessing properties, 352describing QObject properties, 349–350overview of, 344–345
QModelIndex, 409, 411QMultiMap<Key,T>, 220QMutex, 302qobject_cast, 345–347QObject::inherits( ), 345QObjectList, 192QObjects, 191–212
child management in, 194–196Composite pattern, 196–199connecting to slots, 203–204DataObject extension of, 353–354deﬁned, 192layouts, 202–203moc and, 209–210overview of, 192–193QApplication and event loop, 200–209QWidgets as, 238review questions, 212signals and slots, 204–209storage class, 471thread safety and, 302tr( ) and internationalization, 211values and objects, 210
Qonsole
with keyboard events, 286–288writing Xterm in Qt, 284–286
QPaintDevice, 238QPicture, 249QPixmap
animation, 290–294handling images, 249–251
INDEX
617ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 617
QProcess, 278–289
exercises, 288–289overview of, 278–280processes and environment, 280–283Qonsole, 284–288QThread vs., 304
review questions, 305
.qrc resource ﬁles, 248QRegExp
overview of, 310–312phone number recognition, 313–316regular expression validation, 316–317
QRegExpValidator, 316–317QSemaphore, 302QSet<T>, 220QSettings, 242–243, 405QSlider widget, 293qSort( ), 225–227QSplitter, 296QSqlQuery, 429QStack<T>, 220QStackedLayout, 251QStackedWidget, 251QString::arg( ), 211QStringList
adding CaseIgnoreStrings to, 227deﬁned, 220derivation and ArgumentList, 160–163as implicitly shared classes, 225input dialogs and widgets, 246–247and iteration, 97–99, 101–102processing command-line 
arguments, 160
views of, 272–274
QStrings
debugging and, 590example using, 82–83as implicitly shared classes, 225input dialogs and widgets, 246–247processing command-line arguments, 160
Qt, 233–235
assistant and designer, 593–594building with debugging symbols, 588connecting to MySQL, 425containers, 504core modules, 91dates, 91–93deﬁned, 81exercises and review questions, 93–94getting help online, 89heap memory cleanup, 39
lists, 96Makeﬁle, 82–85namespace delimiter, 567project ﬁles, 83–89QApplication and QLabel, 82–83QDir and QFileInfo for visiting ﬁles, 183qmake, 85reference material, 601setup, open source platforms, 7–11setup, Win32, 12streams, 91–93style guides and naming conventions, 90widgets. SeeQWidgets
XML Module, 325
Qt 3, 7Qt 4
installing from packages, 8–9models and views, 409–411modules, 91nix open source platform requiring, 7reusable components of, 179viewing version installed on your 
system, 8
Qt Interest Mailing List, 89Qt source tarball, 10Qt SQL, 424–433
database models, 429–432introduction to MySQL, 424–427queries and result sets, 427–429review questions, 433
QTableView, 411–412, 414, 417,
429–431, 565, 569
QtCentre, 89QT extStream, 31, 82–83, 91–93QThread, 290–304
exercises and review questions, 303–305movie player with QTimer, 294–295multiple threads, queues and loggers,
296–302
overview of, 290QPixmap and animation, 290–294QProcess vs., 304
thread safety and QObjects, 302using QTimer vs.,295
QTimer, 294–295QT oolBar, 262–267QTreeView, 417QTreeWidgetItem, 417, 419Quantiﬁers, regular expressions, 311
618INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 618
Queries
MP3 player, 561–563Qt SQL, 427–429
Questions
dynamic form models, 395form models, 397–399rephrasing, 406
Queues, 296–302QValidator, 308QVariant, 350–352QVBoxLayout, 251QVector<T>, 220QWaitCondition, 302QWidget::addLayout, 251QWidgets
categories, 239–240deﬁned, 238dialogs, 244–248images and resources, 248–251layouts, 202–203, 251–260overview of, 238–239QActions, QMenu and QMenuBar,
260–262
QActions, Qtoolbars, and
QActionGroups, 262–270
QMainWindow, 240–241QSettings, 242–243regions and QDockWidgets, 270–272review questions, 275sending QEvents, 201signals and slots, 205–209views of QStringList, 272–274
QXmlContentHandler, 326–327, 328QXmlDefaultHandler, 328, 378QXmlSimpleReader, 326–327QXMLSimpleReader, 378
R
rcc, resource compiler, 249read( ), 279readAllStandardOutput( ), 279reader, invoking parser, 325–326Reading strings, 33–34readLine( ), 279readyReadStandardOutput( ), 279Refactoring, 136Reference counting, 543Reference parameters
declaring to be const, 121–122overview of, 43–44, 118–121Reference returns, from functions, 122–124
Reﬂective, deﬁned, 343Reﬂective programming, 341–358
anti-patterns, 342–343DataObject, 353–355exercises, 354–355PropsMap, 355Q_PROPERTY macro, 347–350QMetaObject, 344–345QVariant class, 350–352review questions, 357RTTI and qobject_cast, 345–347
Reﬂection pattern, 344regex. SeeRegular expressions (regex)
Regions, QDockWidgets and, 270–272Register, storage class, 470Regular expressions (regex)
exercises and review questions, 318–319overview of, 310–311phone number recognition, 313–316syntax, 311–312validation, 316–317
reinterpret_cast, 453–454Relational operators, 438Relationships
deﬁned, 55exercises, 101overview of, 99–101review questions, 103
Reparenting, in QObject, 193Required arguments, 158Reserved keywords, C++, 575–576Resource Collection File, 248Resources
QWidgets, 248–251sharing, 543, 547
restoreState( ), QMainWindow, 243Result sets, Qt SQL, 427–429Rethrown, exceptions, 496–497Return values
arrays, 511–512functions, 122
Returning references, from functions, 122Reusing, other libraries, 171–172Root, of tree, 197Row insertion, MySQL, 426–427RTTI (run-time type identiﬁcation), 454–458
dynamic_cast, 454–456qobject_cast and, 345–347typeid( ), 456INDEX
619ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 619
run( ),
QProcess, 292QThread, 300
Run-time binding
dynamic or late, 144enabling with virtual keyword, 142
Run-time errors, debugging, 588run-time type identiﬁcation. See
RTTI (run-time type identiﬁcation)
S
saveState( ), QMainWindow, 242SAX parser
DOM vs., 330
importing objects with Abstract 
Factory, 377
overview of, 331–334
Scope
block, 52–53class, 51declaration determining, 464ﬁle scope vs.block scope, 468–469
function, 465, 467global, 471identiﬁer, 51, 465, 467resolution operators, 50, 438review questions, 478storage class compared with, 470types of, 465–468
Searches, ﬁnding header ﬁles, 85–86Selection models, Qt 4, 409Selection statements
deﬁned, 15exercise, 483overview of, 480–482
Selector, media player, 552Serialization, playlist, 560Serializer pattern, 373–380
deﬁning, 227–229exporting to XML, 375–376importing objects with Abstract Factory,
376–380
overview of, 373–375review questions, 390
setApplicationName( ), 242setContent( ), 330setGeometry( ) function, 250setOrganizationName( ), 242setReadChannel( ), 279Setup
open source platforms, 7–11Win32, 12
setupForm( ), 309setValue( )
form models, 397–398QSettings, 242
Sharing resources, 543, 547Shell scripting, 178Shortcut operators, 26Shout button, 202Signals
deﬁned, 204making concurrent code easier to 
read, 279
QMetaObject, 344QObject, 204–209slots and, 204–209speaking with, 297–302synchronous or asynchronous, 208transmitting data to objects across 
threads, 292
Signatures, function, 107Signed integral types, 445–446Simple statements, 480Simple types, 22–24, 29–30SimpleListApp, 272–274Singleton pattern
deﬁned, 360–361qApp and, 365–366
Size, pointers, 24sizeof( ) operator, 23–24Slacker class, DOM tree walking, 332–334Slacker’s DocBook, 323Slash (/), as namespace delimiter, 567Slots
connecting signals with, 301–302connections to, 203–204deﬁned, 204making concurrent code easier to 
read, 279
QMetaObject, 344signals and, 204–209
Smart pointers, 39
auto_ptr, 384–385member selection, 457
Sorting, qSort( ), 225–227Source code
libraries packaged as, 170reusable components, 171620INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 620
Source selector, MP3 player, 553,
566–567
Spacing, widget layout, 254–255Special characters, regular 
expressions, 310
split( ), QStringList and iteration,
97–99
SQL, Qt, 424–433
database models, 429–432introduction to MySQL, 424–427overview of, 91queries and result sets, 427–429review questions, 433
Standard headers, 577–578Standard Library (STL)
dynamic memory and, 504ﬁnding header ﬁles within, 86heap memory cleanup, 39lists, 96standard headers, 577–578strings, 30–31
Standards, C++, 6–7start( )
processes, 278–279threads, 291
startElement( ), 378–379State of the object, 49Statements
block, 480compound, 480conditional, 481–482connect( ), 292deﬁned, 479overview of, 480prepared, 427review questions, 502selection, 15, 480–483simple, 480switch, 481–482throw, 486–488, 497–498try and catch, 490–494
static
binding, 144block-scope, 63keyword, 61–64, 467local variables, 350storage area, 470using in Singleton pattern, 365declaring, 476namespaces and, 476–477static_cast, 450
stderr, 279std::list, 96stdout, 279STL (Standard T emplate Library). See
Standard Library (STL)
Storage class
const, 471–472exercise, 472–473globals, statics, and QObjects, 471overview of, 470register, 470review questions, 478
Strategy pattern, 396Streams, 31–34Stretching, widget layout, 254–255String literals, 20–21StringInputField, 402Strings
converting to enums, 350QStringList and iteration, 97–99reading, 33–34Standard Library (STL), 30–31writing, 32–33
Stroustrup, Bjarne, 6–7struct
arrays of, 513classes vs.,5 3
overview of, 48–49
Structural patterns, 182Struts, widget layout, 254–255Subclasses
deﬁned, 137QLayout, 251
SubObjects, 58–59Subtraction ( /H11002) operator, 25
Suffolk University, 197–198superClass( ), 344switch statement, 481–482Switched parameters, command-line
arguments, 158
Switches
command-line arguments, 158–163compiler, 13–14
Symbols, enclosing, 15Syntax
compiler errors, 587multiple inheritance, 529–531regular expressions (regex), 310–312throw, 494
INDEX
621ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 621
T
Table deﬁnition, MySQL, 425–426
Table models, 411–416taglib, 381Tags, XML, 324Tarball
downloading, 9overview of, 9
TARGET, make command, 88target.path, make command, 88T emplate<class T>, 217T emplates. See also Design patterns
auto_ptr, 384–385causing generated code for each 
type, 350
class, 216–219container, 219–221declaration code for, 217functions vs., 214–216
generics and, 214–219instantiated, 215parameters, 214QList as template class, 96–97
T ext editors, 598this pointer, 68–70Thrashing, memory allocation and, 515Threads. SeeQThread
Thread-safe objects, 302Throw( ), in function signature, 488–489throw statements
exception expressions and, 497–498overview of, 486–488uses of, 494
Tilde (~) character, destructor 
names, 60
toString( ), 138–139, 142, 351–353tr( ), and internationalization, 211Trailing arguments, functions with, 109Tree models, 417–420
exercises, 420extended tree widget items, 418–420overview of, 417–418
triggered( ) signals, QAction, 264Trolltech Online Documentation, 89try statements
nesting, 498overview of, 490–494
type( ) member function, 200Type modiﬁer, 44Typecast operators, 346Typecasting, 449–454
ANSI standards, 450const_cast, 450–453C-style, 454downcasting, 333, 454dynamic_cast, 454–456overview of, 449reinterpret_cast, 453–454static_cast, 450typeid( ), 456
typeid operator, 345, 456–458, 524–525Type-restricted, 385Types, 437–461
casting, 449–454conversion, 447enumeration, 443–445exercises, 458–460hierarchy of, 447logical expressions, 443member selection, 457–458operators, 438–442overview of, 19–22review questions, 461run-time type identiﬁcation (RTTI),
454–456
signed and unsigned integral types,
445–446
simple, 22–24, 29–30variables, 49
U
Umbrello design tool, 54, 597The Umbrello UML Modeller 
Handbook ,5 4
UML (Uniﬁed Modeling Language)
diagramming inheritance, 137inheritance design with, 153introduction to, 54–55modeling tools, 597relationships, 55
Unable to Find libxxx.so.x, linker error 
messages, 585
Unary operators
address of (&), 36–38decrement (—), 26deference (*), 37increment (++), 26not (!), 27overloading and, 115
Undeﬁned pointers, 508622INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 622
Undeﬁned Reference to [identiﬁer], linker
error messages, 586–587
Undeﬁned Reference to vtable for
ClassName, linker error messages, 587
Unforeseen types, 403–404Uniﬁed Modeling Language. SeeUML
(Uniﬁed Modeling Language)
Union, 351Unmanaged containers, 221–224Unsigned integral types, 445–446updateCursor( ), 287–288USER, as environment variable, 280USERNAME, as environment variable, 280using declaration, namespaces, 15, 475/usr/local, 176utils library, reusing, 171–172
V
valgrind, proﬁler, 591–593Validation, 307–319
exercises and review questions,
318–319
phone number recognition, 313–316regular expressions, 316–317regular expressions syntax, 310–312using for, 310validators, 308–309
Validators, 308–309Value containers, 221Value parameters, 116–117Values
function return, 122QObject, 210
Variable-length argument lists, 542–543Variables
class types, 49const, 471–472declarations, 15deﬁned, 36environment variables, 280–282global, 466initialization in C++, 465local, 350reference, 43–44
vector class, 488–489Views. See also Models and views
form, 400–402Qt 4, 409–411separating models from views, 392
Virtual base classes, 535–536Virtual destructors, 526–528
virtual functions
overriding and, 154pure, 149–152QAbstractTableModel, 414
Virtual inheritance, 534–535virtual keyword
derivation with polymorphism 
using, 142–147
enabling runtime binding with, 142
virtual methods, parsing XML with, 327Virtual pointers, 524–526Virtual tables (vtables), inheritance and,
524–526
Visibility, 52Visitor, generating playlists, 555–556Visitor pattern, iteration and, 182–190
customizing with inheritance, 186–189DOM tree walking, 331–334exercises and review questions, 189–190overview of, 184–186QDir and QFileInfo (directories and
ﬁles), 183
void, 22Vtables (vitual tables), 524
W
walkTree( ) method, 333while, iteration structures, 483–484Whitespace, pointer problems and, 505Widgets. See also QWidgets
displaying current play list on MP3
player, 565
Qt designer, 594tree, 417–420
Win32, setup, 12Window, QWidget, 238Windows
environment variables, 281installing libraries in, 176–177USERNAME environment 
variable, 280
Wrappers
FileTagger (façade example), 386–389header ﬁles, 50using auto_ptr in, 384–385
write( ), 279Writing strings, 32–33Wt
8, 179
wxWidgets, 179INDEX
623ezus_138004_ind.qxd  8/4/06  1:37 PM  Page 623
X
XML (eXtensible Markup Language),
321–340
encoding/decoding DataObjects as,
373–375
event-driven parsing, 325–329exercises and review questions, 339exporting to, 375–376generating output with DOM,
335–339HTML vs., 321–323
importing objects with Abstract Factory,
376–380
nodes, 324Qt XML Module, 325tree structures and DOM, 329–334XML editors, 324
Xml module, Qt, 91, 325xmllint, 325Xterm, 284–286624INDEXezus_138004_ind.qxd  8/4/06  1:37 PM  Page 624
Using Trolltech’s Qt you can build industrial-strength
C++ applications that run natively on Windows,Linux/Unix, Mac OS X, and embedded Linux—
without making source code changes. With C++ GUI
Programming with Qt 4 , Trolltech insiders have
written a start-to-finish guide to getting great results
with the most powerful version of Qt ever created: Qt 4.1.
Using this book, you’ll discover the most effective Qt
4 programming patterns and techniques and masterkey technologies ranging from Qt’s model/viewarchitecture to Qt’s powerful new 2D paint engine.
The authors provide you with unparalleled insight into Qt’s event model and layout
system. Then, using realistic examples, they introduce superior techniques for
everything from basic GUI development to advanced database and XML integration.
• Includes new chapters on Qt 4’s model/view architecture and Qt’s new plugin
support, along with a brief introduction to Qtopia embedded programming
• Covers all Qt fundamentals, from dialogs and windows to implementing
application functionality
• Introduces best practices for layout management and event processing
• Shows how to make the most of Qt 4’s new APIs, including the powerful new
2D paint engine and the new easy-to-use container classes
• Contains completely updated material in every chapter• Presents advanced Qt 4 techniques covered in no other book, from creating
both Qt and application plugins to interfacing with native APIs
• Contains an in-depth appendix on C++/Qt programming for experienced Java
developers
The accompanying CD-ROM includes the open source edition of Qt 4.1.1 for
Windows, Mac, Linux, and many Unixes, as well as MinGW, a set of freely availabledevelopment tools that can be used to build Qt applications on Windows and wasused to create the source code for the book’s examples.The Only Official Best-Practice
Guide to Qt 4.1 Programming 
For more information, including a sample chapter, visit www.prenhallprofessional.com/title/0131872494.
C++ GUI Programming with Qt 4
0131872494 · © 2006 · 560 pagesJasmin Blanchette and
Mark SummerfieldEzust_BoB.qxd  7/28/06  11:49 AM  Page 1
www.informit.com
YOUR GUIDE TO IT REFERENCE
Articles
Keep your edge with thousands of free articles, in-
depth featur es, interviews, and IT reference recommen-
dations – all written by experts you know and trust.
Online Books
Answers in an instant from InformIT Online Book’s 600+
fully searchable on line books. For a limited time, you canget your first 14 days free .
Catalog
Review online sample chapters, author biographiesand customer r ankings and choose exactly the right book
from a selection of over 5,000 titles. 
IITad_7x9.25  4/17/03  3:49 PM  Page 1
PHPTR_Online_7x9_25.qxd  11/23/04  2:12 PM  Page 1
If you have difficulty registering on Safari Bookshelf or accessing the online edition,  
please e-mail customer-service@safaribooksonline.com.THIS BOOK IS SAFARI ENABLED
INCLUDES FREE 45-DAY ACCESS TO THE ONLINE EDITION
The Safari® Enabled icon on the cover of your favorite technology  
book means the book is available through Safari Bookshelf. When you 
buy this book, you get free access to the online edition for 45 days.
Safari Bookshelf is an electronic reference library that lets you easily 
search thousands of technical books, find code samples, download  
chapters, and access technical information whenever and wherever  
you need it.
TO GAIN 45-DAY SAFARI ENABLED ACCESS TO THIS BOOK:  
 • Go to http://www.prenhallprofessional.com/safarienabled
 • Complete the brief registration form
 • Enter the coupon code found in the front  
of this book on the “Copyright” page

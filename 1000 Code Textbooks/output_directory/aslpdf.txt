Contents
Preface xi
Introduction 1
A Short History of Assemblers and Loaders 7
Types of Assemblers and Loaders 11
1 Basic Principles 13
1.1 Assembler Operation 13
1.1.1 The source line 13
1.2 The Two-Pass Assembler 201.3 The One-Pass Assembler 24
1.4 Absolute and Relocatable Object Files 28
1.4.1 Relocation bits 291.4.2 One-pass, relocatable object ﬁles 301.4.3 The task of relocating 31
1.5 Two Historical Notes 32
1.5.1 Early relocation 321.5.2 One-and-a-half pass assemblers 32
1.6 Forcing Upper 33
1.6.1 Relocating packed instructions 34
vi Contents
1.7 Absolute and Relocatable Address Expressions 35
1.7.1 Summary 36
1.8 Local Labels 36
1.8.1 The LC as a local symbol 38
1.9 Multiple Location Counters 39
1.9.1 The USEdirective 39
1.9.2COMMON blocks 41
1.10 Literals 43
1.10.1 The literal table 431.10.2 Examples 44
1.11 Attributes of Symbols 451.12 Assembly-Time Errors 461.13 Review Questions and Projects 49
1.13.1 Project 1–1 501.13.2 Project 1–2 521.13.3 Project 1–3 531.13.4 Project 1–4 54
2 The Symbol Table 59
2.1 A Linear Array 60
2.2 A Sorted Array 602.3 Buckets with Linked Lists 612.4 A Binary Search Tree 622.5 A Hash Table 63
2.5.1 Closed hashing 632.5.2 Open hashing 65
2.6 Review Questions and Projects 66
2.6.1 Project 2–1 662.6.2 Project 2–2 662.6.3 Project 2–3 67
3 Directives 69
3.1 Introduction 69
3.2 Program Identiﬁcation Directives 733.3 Source Program Control Directives 743.4 Machine Identiﬁcation Directives 763.5 Loader Control Directives 773.6 Mode Control Directives 773.7 Block Control & LC Directives 793.8 Segment Control Directives 853.9 Symbol Deﬁnition Directives 863.10 Base Register Deﬁnition Directives 89
Contents vii
3.11 Subprogram Linkage Directives 90
3.12 Data Generation Directives 933.13 Macro Directives 993.14 Conditional Assembly Directives 993.15 Micro Directives 99
3.15.1 micro substitution 100
3.16 Error Control Directives 1003.17 Listing Control Directives 1013.18 Remote Assembly Directives 1033.19 Code Duplication Directives 1043.20 Operation Deﬁnition Directives 1053.21 OpCode Table Management Directives 1063.22 Summary 107
3.23 Review Questions and Projects 108
3.23.1 Project 3–1 1083.23.2 Project 3–2 108
4 Macros 109
4.1 Introduction 109
4.1.1 The Syntax of macro deﬁnition and expansion 112
4.2 Macro Parameters 114
4.2.1 Properties of macro parameters 116
4.3 Operation of Pass 0 1214.4 MDT Organization 122
4.4.1 The REMOVE directive 123
4.4.2 Order of search of the MDT 123
4.5 Other Features of Macros 124
4.5.1 Associating macro parameters with their arguments. 1244.5.2 Delimiting macro parameters 1254.5.3 Numeric values of arguments 1254.5.4 Attributes of macro arguments 1254.5.5 Directives related to arguments 1264.5.6 Default arguments 1274.5.7 Automatic label generation 1274.5.8 The IRPdirective 128
4.5.9 The PRINT directive 129
4.5.10 Comment lines in macros 129
4.6 Nested Macros 130
4.6.1 Nested macro expansion 130
4.7 Recursive Macros 1334.8 Conditional Assembly 134
4.8.1 Global SET symbols 139
viii Contents
4.8.2 Array SET symbols 140
4.9 Nested Macro Deﬁnition 141
4.9.1 The traditional method 1444.9.2 Revesz’s method 1464.9.3 A note 154
4.10 Summary of Pass 0 1544.11 Review Questions and Projects 156
4.11.1 Project 4–1 1574.11.2 Project 4–2 157
5 The Listing File 159
5.1 A 6800 Example 160
5.2 A VAX Example 1645.3 A MASM Example 1695.4 An MPW Example 1725.5 Review Questions and Projects 175
5.5.1 Project 5–1 175
6 Special Assembler Types 177
6.1 High-Level Assemblers 177
6.1.1 NEAT/3 1786.1.2 PL360 1816.1.3 PL516 1836.1.4 BABBAGE 184
6.2 Summary 1866.3 Meta Assemblers 1866.4 Disassemblers 1896.5 Cross Assemblers 1936.6 Review Questions and Projects 194
6.6.1 Project 6–1 194
7 Loaders 195
7.1 Assemble-Go Loaders 196
7.2 Absolute Loaders 1987.3 Linking Loaders 1997.4 The Modify Loader Directive 209
7.5 Linkage Editors 2117.6 Dymanic Linking 2127.7 Loader Control 2137.8 Library Routines 2147.9 Overlays 2157.10 Multiple Location Counters 219
Contents ix
7.11 Bootstrap Loaders 220
7.12 An N+1 address Assembler-Loader 2217.13 Review Questions and Projects 224
7.13.1 Project 7–1 225
8 A Survey of Some Modern Assemblers 229
8.1 The Microsoft Macro Assembler (MASM) 230
8.1.1 The 80x86 & 80x88 microprocessors 2308.1.2 MASM options 2318.1.3 MASM listing 2338.1.4 MASM source line format 2338.1.5 MASM directives 2338.1.6 MASM expressions 2348.1.7 MASM macros 235
8.2 The Borland Turbo Assembler (TASM) 235
8.2.1 Special TASM features 2368.2.2 TASM local labels 2378.2.3 Automatic jump-sizing 2378.2.4 Forward references to code and data 2388.2.5 Conclusions: 2398.2.6 TASM macros 2398.2.7 The Ideal mode 2398.2.8 TASM directives 240
8.3 The VAX Macro Assembler 240
8.3.1 Special Macro features 240
8.3.2 Data types 2418.3.3 Local labels 2428.3.4 Macro directives 242
8.3.5 Macros 2438.3.6 Addressing modes 243
8.4 The Macintosh MPW Assembler 243
8.4.1 Modules 2458.4.2 Listing ﬁle 2458.4.3 Segments 2468.4.4 Expressions & literals 2468.4.5 Directives 246
References 249
A Addressing Modes 254
A.1 Introduction 254
A.2 Examples of Modes 256
A.2.1 The Direct mode 256A.2.2 The Relative mode 257A.2.3 The Immediate mode 257A.2.4 The Index mode 258
x Contents
A.2.5 The Indirect mode 259
A.2.6 Multilevel or cascaded indirect 260A.2.7 Other addressing modes 260A.2.8 Zero Page mode 260A.2.9 Current Page Direct mode 261A.2.10 Implicit or Implied mode 261A.2.11 Accumulator mode 261A.2.12 Stack mode 261A.2.13 Stack Relative mode 261A.2.14 Register mode 262A.2.15 Register Indirect mode 262A.2.16 Auto Increment/Decrement mode 262
A.3 Base Registers 262A.4 General Remarks 265A.5 Review Questions 267
B Hexadecimal Numbers 268
B.1 Review Questions 270
C Answers to Exercises 271
Index 281
Preface
My computing experience dates back to the early 1960s, when higher-level lan-
guages were fairly new.It is therefore no wonder that my introduction to computersand computing came through assembler language; speciﬁcally, the IBM 7040 assem-bler language.After programming in assembler exclusively (and enthusiastically)for more than a year, I ﬁnally studied Fortran.However, my love aﬀair with as-semblers has continued, and I very quickly discovered the lack of literature in thisﬁeld.In strict contrast to compilers, for which a wide range of literature exists,very little has ever been written on assemblers and loaders.References [1,2,3,64]are the best ones known to me, that describe and discuss the principles of opera-tion of assemblers and loaders.Assembler language textbooks are—of course—verycommon, but they only talk about whatassemblers do, not about howthey do it.
One reason for this situation is that, for many years—from the mid 1950s to
the mid 1970s—assemblers were in decline.The development of Fortran and otherhigher-level languages in the early 1950s overshadowed assemblers.The growth ofhigher-level languages was taken by many a programmer to signal the demise ofassemblers, with the result that the use of assemblers dwindled.The advent of themicroprocessor, around 1975, caused a signiﬁcant change, however.
Initially, there were no compilers available, so programmers had to use assem-
blers, even primitive ones.This situation did not last long, of course, and today, inthe early 1990s, there are many compilers available for microcomputers, but assem-blers have not been neglected.Virtually all software development systems available
xii Preface
for modern computers include an assembler.The assemblers described in Ch.8 are
typical examples.
References [5–7] list three Z-80 assemblers running under CP/M.In spite of
being obsolete, they are good examples of modern assemblers.They are all stateof the art, relocatable assemblers that support macros and conditional assembly.References [5,6] also include linking loaders.These assemblers reﬂect the interestin the Z-80 and CP/M in the early 80s.Current processors, such as the 80x86 andthe 680x0 families, continue the tradition.Modern, sophisticated assemblers areavailable for these processors, and are used extensively by programmers who needoptimized code in certain procedures.
The situation with loaders is diﬀerent.Loaders have always been used.They
are used with as well as with assemblers, but their use is normally transparent tothe programmer.The average programmer hardly notices the existence of loaders,which may explain the lack of literature in this area.
This book diﬀers from the typical assembler text in that it is not a programming
manual, and it is not concerned with any speciﬁc assembler language.Insteadit concentrates on the design and implementation of assemblers and loaders.Itassumes that the reader has some knowledge of computers and programming, and itaims to explain how assemblers and loaders work.Most of the discussion is general,and most of the examples are in a hypothetical, simple, assembler language.Certainexamples are in the assembler languages of actual machines, and those are alwaysspeciﬁed.Some good references for speciﬁc assembler languages are [5, 6, 7, 13, 26,27, 30, 31, 32, 35, 37, 39, 101].
This work has its origins at a point, a few years ago, when my students started
complaining about a lack of literature in this ﬁeld.Since I include assemblers andloaders in classes that I teach every semester, I responded by developing class notes.The notes were an immediate success, and have grown each semester, until I hadenough material for an expository paper on the subject.Since I was too busy topolish the paper and submit it, I pretty soon found myself in a situation where thework was too large for a paper.So here it is at last, in the form of a book.
This is mostly a professional book, intended for computer professionals in gen-
eral, and especially for systems programmers.However, it can be used as a sup-plementary text in a systems programming or computer organization class at anylevel.
Chapter 1 introduces the one-pass and two-pass assemblers, discusses other
important concepts—such as absolute- and relocatable object ﬁles—and describesassembler features such as local labels and multiple location counters.
Data structures for implementing the symbol table are discussed in chapter 2.
Chapter 3 presents many directives and dicusses their formats, meaning, and
implementation.These directives are supported by many actual assemblers and,while not complete, this collection of directives is quite extensive.
The two important topics of macros and conditional assembly are introduced
in chapter 4.The treatment of macros is as complete as practically possible.I have
Preface xiii
tried to include every possible feature of macros and the way it is implemented,
so this chapter can serve as a guide to practical macro implementation.At thesame time, I have tried not to concentrate on the macro features and syntax of anyspeciﬁc assembler.
Features of the listing ﬁle are outlined, with examples, in chapter 5, while
chapter 6 is a general description of the properties of disassemblers, and of threespecial types of assemblers.Those topics, especially meta-assemblers and high-levelassemblers, are of special interest to the advanced reader.They are not new, buteven experienced programmers are not always familiar with them.
Chapter 7 covers loaders.There is a very detailed example of the basic opera-
tion of a one pass linking loader, followed by features and concepts such as dynamicloading, bootstrap loader, overlays, and others.
Finally, chapter 8 contains a survey of four modern, state of the art, assemblers.
Their main characteristics are described, as well as features that distinguish themfrom their older counterparts.
To make it possible to use the book as a textbook, each chapter is sprinkled
with exercises, all solved in appendix C.At the end of each chapter there are reviewproblems and projects.The review questions vary from very easy questions to tasksthat require the student to ﬁnd some topic in textbooks and study it.The projectsare programming assignments, arranged from simple to more complex, that proposevarious assemblers and loaders to be implemented.They should be done in the orderspeciﬁed, since most of them are extensions of their predecessors.Some instructorswould ﬁnd appendix A, on addressing modes, useful.
References are indicated by square brackets.Thus [14] (or Ref.[14]) refers to
Grishman’s book listed in the reference section.
/This is the attention symbol.It is placed in front of paragraphs that require
special attention, that present fundamental concepts, or that are judged importantfor other reasons.
Acknowledgement: I would like to acknowledge the help received from B.A.
Wichmann of the National Physical Laboratory in England.He sent me informationon the PL516 high-level assembler, the BABBAGE language, and the GE 4000family of minicomputers.His was the only help I have received in collecting andanalyzing the material for this book.Johnny Tolliver, of Oak Ridge National Labs,should also be mentioned.His version of the MakeIndex program proved invaluable
in preparing the extensive index of this book.
A human being; an ingenious assembly of portable plumbing
—Christopher Morley
Introduction
/A work on assemblers should naturally start with a deﬁnition. However, com-
puter science is not as precise a ﬁeld as mathematics, so most deﬁnitions are notrigorous. The deﬁnition I like best is:
An assembler is a translator that translates source in-structions (in symbolic language) into target instruc-tions (in machine language), on a one to one basis.
This means that each source instruction is translated into exactly one target in-
struction.
This deﬁnition has the advantage of clearly describing the translation process
of an assembler. It is not a precise deﬁnition, however, because an assembler cando (and usually does) much more than just translation. It oﬀers a lot of help tothe programmer in many aspects of writing the program. The many types of helpoﬀered by the assembler are grouped under the general term directives (orpseudo-
instructions ). All the important directives are discussed in chapters 3 and 4.
/Another good deﬁnition of assemblers is:
An assembler is a translator that translates a machine-
oriented language into machine language.
2 Introduction
This deﬁnition distinguishes between assemblers and compilers. Compilers being
translators of problem-oriented languages or of machine-independent languages.This deﬁnition, however, says nothing about the one-to-one nature of the trans-lation, and thus ignores a most important operating feature of an assembler.
One reason for studying assemblers is that the operation of an assembler re-
ﬂects the architecture of the computer. The assembler language depends heavily onthe internal organization of the computer. Architectural features such as memoryword size, number formats, internal character codes, index registers, and generalpurpose registers, aﬀect the way assembler instructions are written and the way theassembler handles instructions and directives. This fact explains why there is aninterest in assemblers today and why a course on assembler language is still requiredfor many, perhaps even most, computer science degrees.
The ﬁrst assemblers were simple assemble-go systems. All they could do was
to assemble code directly in memory and start execution. It was quickly realized,however, that linking is an important feature, required even by simple programs.
The pioneers of programming have developed the concept of the routine library very
early, and they needed assemblers that could locate library routines, load them intomemory, and link them to the main program. It was this task of locating, loading,and linking—of assembling a single working program from individual pieces—thatcreated the name assembler [4]. Today, assemblers are translators and they work
on one program at a time. The tasks of locating, loading, and linking (as well asmany other tasks) are performed by a loader.
A modern assembler has two inputs and two outputs. The ﬁrst input is short,
typically a single line typed at a keyboard. It activates the assembler and speciﬁesthe name of a source ﬁle (the ﬁle containing the source code to be assembled). Itmay contain other information that the assembler should have before it starts. Thisincludes commands and speciﬁcations such as:
The names of the object ﬁle and listing ﬁle. Display (or do not display) the
listing on the screen while it is being generated. Display all error messages but do
not stop for any error. Save the listing ﬁle and do not print it (see below). This
program does not use macros. The symbol table is larger (or smaller) than usual
and needs a certain amount of memory.
All these terms are explained elsewhere. An example is the command line that
invokes Macro , the VAX assembler. The line:
MACRO /SHOW=MEB /LIST /DEBUG ABC
activates the assembler, tells it that the source program name is abc.mar (the.mar
extension is implied), that binary lines in macro expansions should be listed (shown),that a listing ﬁle should be created, and that the debugger should be included inthe assembly.
Another typical example is the following command line that invokes the Mi-
crosoft Macro assembler (MASM) for the 80x86 microprocessors:
MASM /d /Dopt=5 /MU /V
Introduction 3
It tells the assembler to create a pass 1 listing ( /D), to create a variable optand
set its value to 5, to convert all letters read from the source ﬁle to upper case ( MU),
and to include certain information in the listing ﬁle (the V, or verbose, option).
The second input is the source ﬁle . It includes the symbolic instructions and
directives. The assembler translates each symbolic instruction into one machineinstruction. The directives, however, are not translated. The directives are ourway of asking the assembler for help. The assembler provides the help by executing(rather than translating) the directives. A modern assembler can support as manyas a hundred directives. They range from ORG, which is very simple to execute,
toMACRO , which can be very complex. All the common directives are listed and
explained in chapters 3 and 4.
The ﬁrst and most important output of the assembler is the object ﬁle .I t
contains the assembled instructions (the machine language program) to be loadedlater into memory and executed. The object ﬁle is an important component of theassembler-loader system. It makes it possible to assemble a program once, and laterload and run it many times. It also provides a natural place for the assembler toleave information to the loader, instructing the loader in several aspects of loadingthe program. This information is called loader directives and is covered in chapters
3 and 7. Note, however, that the object ﬁle is optional. The user may specify noobject ﬁle, in which case the assembler generates only a listing.
The second output of the assembler is the listing ﬁle . For each line in the source
ﬁle, a line is created in the listing ﬁle, containing:
The Location Counter (see chapter 1). The source line itself. The machine
instruction (if the source line is an instruction), or some other relevant information(if the source line is a directive).
The listing ﬁle is generated by the assembler, sent to the printer, gets printed,
and is then discarded. The user, however, can specify either not to generate a listingﬁle or not to print it. There are also directives that control the listing. They canbe used to suppress parts of the listing, to print page headers, or to control theprinting of macro expansions.
The cross-reference information is normally a part of the listing ﬁle, although
the MASM assembler creates it in a separate ﬁle and uses a special utility to printit. The cross-reference is a list of all symbols used in the program. For each symbol,the point where it is deﬁned and all the places where it is used, are listed.
/
Exercise .1 Why would anyone want to suppress the listing ﬁle or not to print it?
As mentioned above, the ﬁrst assemblers were assemble-go type systems. They
did not generate any object ﬁle. Their main output was machine instructions loadeddirectly into memory. Their secondary output was a listing. Such assemblers arealso in use today (for reasons explained in chapter 1) and are called one-pass as-semblers. In principle, a one pass assembler can produce an object ﬁle, but such aﬁle would be absolute and its use is limited.
4 Introduction
Most assemblers today are of the two-pass variety. They generate an object ﬁle
that is relocatable and can be linked and loaded by a loader.
A loader, as the name implies, is a program that loads programs into memory.
Modern loaders, however, do much more than that. Their main tasks (chapter7) are loading, relocating, linking and starting the program. In a typical run,a modern linking-loader can read several object ﬁles, load them one by one intomemory, relocating each as it is being loaded, link all the separate object ﬁles intoone executable module, and start execution at the right point. Using such a loaderhas several advantages (see below), the most important being the ability to writeand assemble a program in several, separate, parts.
Writing a large program in several parts is advantageous, for reasons that will
be brieﬂy mentioned but not fully discussed here. The individual parts can bewritten by diﬀerent programmers (or teams of programmers), each concentratingon his own part. The diﬀerent parts can be written in diﬀerent languages. It iscommon to write the main program in a higher-level language and the procedures inassembler language. The individual parts are assembled (or compiled) separately,and separate object ﬁles are produced. The assembler or compiler can only see onepart at a time and does not see the whole picture. It is only the loader that loadsthe separate parts and combines them into a single program. Thus when a programis assembled, the assembler does not know whether this is a complete program orjust a part of a larger program. It therefore assumes that the program will start ataddress zero and assembles it based on that assumption. Before the loader loads theprogram, it determines its true start address, based on the memory areas availableat that moment and on the previously loaded object ﬁles. The loader then loads theprogram, making sure that all instructions ﬁt properly in their memory locations.This process involves adjusting memory addresses in the program, and is calledrelocation .
Since the assembler works on one program at a time, it cannot link individual
programs. When it assembles a source ﬁle containing a main program, the assemblerknows nothing about the existence of any other source ﬁles containing, perhaps,procedures called by the main program. As a result, the assembler may not beable to properly assemble a procedure call instruction (to an external procedure) inthe main program. The object ﬁle of the main program will, in such a case, havemissing parts (holes or gaps) that the assembler cannot ﬁll. The loader has accessto all the object ﬁles that make up the entire program. It can see the whole picture,and one of its tasks is to ﬁll up any missing parts in the object ﬁles. This task iscalled linking .
The task of preparing a source program for execution includes translation (as-
sembling or compiling), loading, relocating, and linking. It is divided between theassembler (or compiler) and the loader, and dual assembler-loader systems are verycommon. The main exception to this arrangement is interpretation . Interpretive
languages such as BASIC orAPLuse the services of one program, the interpreter,
for their execution, and do not require an assembler or a loader. It should be clearfrom the above discussion that the main reason for keeping the assembler and loader
Introduction 5
separate is the need to develop programs (especially large ones) in separate parts.
The detailed reasons for this will not be discussed here. We will, however, point outthe advantages of having a dual assembler-loader system. They are listed below, inorder of importance.
It makes it possible to write programs in separate parts that may also be in
diﬀerent languages.
It keeps the assembler small. This is an important advantage. The size of the
assembler depends on the size of its internal tables (especially the symbol table andthe macro deﬁnition table). An assembler designed to assemble large programs islarge because of its large tables. Separate assembly makes it possible to assemblevery large programs with a small assembler.
When a change is made in the source code, only the modiﬁed program needs to
be reassembled. This property is a beneﬁt if one assumes that assembly is slow andloading is fast. Many times, however, loading is slower than assembling, and thisproperty is just a feature, not an advantage, of a dual assembler-loader system.
The loader automatically loads routines from a library. This is considered by
some an advantage of a dual assembler-loader system but, actually, it is not. Itcould easily be done in a single assembler-loader program. In such a program, thelibrary would have to contain the source code of the routines, but this is typicallynot larger than the object code.
6 Introduction
The words of the wise are as goads, and as nail fastened by masters of
assemblies
—Ecclesiastes 12:11
A Short History of
Assemblers and Loaders
One of the ﬁrst stored program computers was the EDSAC (Electronic De-
lay Storage Automatic Calculator) developed at Cambridge University in 1949 byMaurice Wilkes and W. Renwick [4, 8 & 97]. From its very ﬁrst days the EDSAChad an assembler, called Initial Orders . It was implemented in a read-only memory
formed from a set of rotary telephone selectors, and it accepted symbolic instruc-tions. Each instruction consisted of a one letter mnemonic, a decimal address, anda third ﬁeld that was a letter. The third ﬁeld caused one of 12 constants preset bythe programmer to be added to the address at assembly time.
It is interesting to note that Wilkes was also the ﬁrst to propose the use of
labels (which he called ﬂoating addresses ), the ﬁrst to use an early form of macros
(which he called synthetic orders ), and the ﬁrst to develop a subroutine library [4].
Reference [65] is a very early description of the use of labels in an assembler The
IBM 650 computer was ﬁrst delivered around 1953 and had an assembler very similarto present day assemblers. SOAP (Symbolic Optimizer and Assembly Program) didsymbolic assembly in the conventional way, and was perhaps the ﬁrst assembler todo so. However, its main feature was the optimized calculation of the address ofthe next instruction. The IBM 650 (a decimal computer, incidentally), was basedon a magnetic drum memory and the program was stored in that memory. Each
8 AShort History of Assemblers and Loaders
instruction had to be fetched from the drum and had to contain the address of
its successor. For maximum speed, an instruction had to be placed on the drumin a location that would be under the read head as soon as its predecessor wascompleted. SOAP calculated those addresses, based on the execution times of theindividual instructions. Chapter 7 has more details, and a programming project,on this process.
One of the ﬁrst commercially successful computers was the IBM 704. It had
features such as ﬂoating-point hardware and index registers. It was ﬁrst deliveredin 1956 and its ﬁrst assembler, the UASAP-1, was written in the same year by RoyNutt of United Aircraft Corp. (hence the name UASAP—United Aircraft SymbolicAssembly Program). It was a simple binary assembler, did practically nothingbut one-to-one translation, and left the programmer in complete control over theprogram. SHARE, the IBM users’ organization, adopted a later version of thatassembler [9] and distributed it to its members together with routines producedand contributed by members. UASAP has pointed the way to early assemblerwriters, and many of its design principles are used by assemblers to this day. TheUASAP was later modiﬁed to support macros [62].
In the same year another assembler, the IBM Autocoder was developed by R.
Goldﬁnger [10] for use on the IBM 702/705 computers. This assembler (actuallyseveral diﬀerent Autocoder assemblers) was apparently the ﬁrst to use macros. TheAutocoder assemblers were used extensively and were eventually developed intolarge systems with large macro libraries used by many installations.
Another pioneering early assembler was the UNISAP, [47] for the UNIVAC I
& II computers, developed in 1958 by M. E. Conway. It was a one-and-a-half passassembler, and was the ﬁrst one to use local labels. Both concepts are covered inchapter 1.
By the late ﬁfties, IBM had released the 7000 series of computers. These came
with a macro assembler, SCAT, that had all the features of modern assemblers.It had many directives ( pseudo instructions in the IBM terminology), an extensive
macro facility, and it generated relocatable object ﬁles.
The SCAT assembler (Symbolic Coder And Translator) was originally written
for the IBM 709 [56] and was modiﬁed to work on the IBM 7090. The GAS (Gen-eralized Assembly System) assembler was another powerful 7090 assembler [58].
The idea of macros originated with several people. McIlroy [22] was probably
the ﬁrst to propose the modern form of macros and the idea of conditional assembly.He implemented these ideas in the GAS assembler mentioned above. Reference [60]is a short early paper presenting some details of macro deﬁnition table handling.
One of the ﬁrst full-feature loaders, the linking loader for the IBM 704–709–
7090 computers [59], is an example of an early loader supporting both relocationand linking.
The earliest work discussing meta-assemblers seems to be Ferguson [24]. The
idea of high-level assemblers originated with Wirth [61] and had been extended,
Machine Language
Assembler Language
Absolute Assembler
Directives
External 
Routines
Absolute Assembler 
with
Library RoutinesRelocation 
Bits
External
Relocatable
Routines
Macros Linking Loader Macro Assembler
Conditional Assembly
Full-Feature, Relocatable
Macro Assembler, with
Conditional AssemblyRelocatable
Assembler
and LoaderA Short History of Assemblers and Loaders 9
Phases in the historical development of assemblers and loaders.
10 A Short History of Assemblers and Loaders
a few years later, by an anonymous software designer at NCR, who proposed the
main ideas of the NEAT/3 language [85,86].
The diagram summarizes the main phases in the historical development of
assemblers and loaders.
I would like to present a brief historical background as a preface to the
language speciﬁcation contained in this manual.
—John Warnock Postscript Language Reference Manual, 1985.
Types of
Assemblers and Loaders
A One-pass Assembler: One that performs all its functions by reading the source
ﬁle once.
A Two-Pass Assembler: One that reads the source ﬁle twice.
A Resident Assembler: One that is permanently loaded in memory. Typically
such an assembler resides in ROM, is very simple (supports only a few directivesand no macros), and is a one-pass assembler. The above assemblers are describedin chapter 1.
A Macro-Assembler: One that supports macros (chapter 4).
A Cross-Assembler: An assembler that runs on one computer and assembles pro-
grams for another. Many cross-assemblers are written in a higher-level language tomake them portable. They run on a large machine and produce object code for asmall machine.
A Meta-Assembler: One that can handle many diﬀerent instruction sets.
A Disassembler: This, in a sense, is the opposite of an assembler. It translates
machine code into a source program in assembler language.
12 Typesof Assemblers and Loaders
A high-level assembler. This is a translator for a language combining the features
of a higher-level language with some features of assembler language. Such a languagecan also be considered a machine dependent higher-level language. The above fourtypes are described in chapter 6.
A Micro-Assembler: Used to assemble microinstructions. It is not diﬀerent in
principle from an assembler. Note that microinstructions have nothing to do withprogramming microcomputers.
Combinations of those types are common. An assembler can be a Macro Cross-
Assembler or a Micro Resident one.
A Bootstrap Loader: It uses its ﬁrst few instructions to either load the rest of
itself, or load another loader, into memory. It is typically stored in ROM.
An Absolute Loader: Can only load absolute object ﬁles, i.e., can only load a
program starting from a certain, ﬁxed location in memory.
A Relocating Loader: Can load relocatable object ﬁles and thus can load the same
program starting at any location.
A Linking Loader: Can link programs that were assembled separately, and load
them as a single module.
A Linkage Editor: Links programs and does some relocation. Produces a load
module that can later be loaded by a simple relocating loader. All loader types arediscussed in chapter 7.
1. Basic Principles
The basic principles of assembler operation are simple, involving just one prob-
lem, that of unresolved references . This is a simple problem that has two simple
solutions. The problem is important, however, since its two solutions introduce,in a natural way, the two main types of assemblers namely, the one-pass and the
two-pass .
1.1 Assembler Operation
As mentioned in the introduction, the main input of the assembler is the source
ﬁle. Each record on the source ﬁle is a source line that specifes either an assemblerinstruction or a directive.
1.1.1 The source line
/A typical source line has four ﬁelds. A label (or a location), a mnemonic (or
operation), an operand, and a comment.
Example: LOOP ADD R1,ABC PRODUCING THE SUM
In this example, LOOPis a label, ADDis a mnemonic meaning to add, R1stands
for register 1, and ABCis the label of another source line. R1andABCare two
operands that make up the operand ﬁeld. The example above is, therefore, a double-operand instruction. When a label is used as an operand, we call it a symbol. Thus,in our case, ABCis a symbol.
14 BasicPrinciples Ch. 1
The comment is for the programmer’s use only. It is read by the assembler, it
is listed in the listing ﬁle, and is otherwise ignored.
The label ﬁeld is only necessary if the instruction is referred to from some
other point in the program. It may be referred to by another instruction in thesame program, by another instruction in a diﬀerent program (the two programsshould eventually be linked), or by itself.
The word mnemonic comes from the Greek µν/epsilon1µoνικoσ , meaning pertaining to
memory ; it is a memory aid. The mnemonic is always necessary. It is the operation.
It tells the assembler what instruction needs to be assembled or what directive toexecute (but see the comment below about blank lines).
The operand depends on the mnemonic. Instructions can have zero, one, or
two operands (very few computers have also three operand instructions). Directivesalso have operands. The operands supply information to the assembler about thesource line.
As a result, only the mnemonic is mandatory, but there are even exceptions
to this rule. One exception is blank lines. Many assemblers allow blank lines—inwhich all ﬁelds, including the mnemonic, are missing—in the source ﬁle. They makethe listing more readable but are otherwise ignored.
Another exception is comment lines. A line that starts with a special sym-
bol (typically a semicolon, sometimes an asterisk and, in a few cases, a slash)isconsidered a comment line and, of course, has no mnemonic. Many modern assem-blers (see, e.g., references [37], [99]–[102])support a COMMENT directive that has the
following form:
COMMENT delimiter textdelimiter
Where the text between the delimiters is a comment. This way the programmer
can enter a long comment, spread over many lines, without having to start eachline with the special comment symbol. Example:
COMMENT =This is a long
comment that ...
.
.
...suﬃcient to describe what you want=
Old assemblers were developed on punched-card based computers. They re-
quired the instructions to be punched on cards such that each ﬁeld of the sourceline was punched in a certain ﬁeld on the card. The following is an example fromthe IBMAP (Macro Assembler Program)assembler for the IBM 7040 [12]. A sourceline in this assembler has to be punched on a card with the format:
Sec.1.1 Assembler Operation 15
Columns Field
1-6 Label
7 Blank8- Mnemonic
and also obey the following rules:
The operand must be separated from the mnemonic by at least one blank, and
must start on or before column 16.
The comment must be separated from the operand by at least one blank. If there
is no operand, the comment may not start before column 17.
The comment extends through column 80 but columns 73–80 are normally used
for sequencing and identiﬁcation.
It is obviously very hard to enter such source lines from a keyboard. Modern
assemblers are thus more ﬂexible and do not require any special format. If a labelexists, it must end with a ‘:’. Otherwise, the individual ﬁelds should be separatedby at least one space (or by a tab character), and subﬁelds should be separated byeither a comma or parentheses. This rule makes it convenient to enter source linesfrom a keyboard, but is ambiguous in the case of a source line that has a commentbut no operand.
Example: EI ;ENABLE ALL INTERRUPTS
The semicolon guarantees that the word ENABLE will not be considered an
operand by the assembler. This is why many assemblers require that commentsstart with a semicolon.
/
Exercise 1.1 Why a semicolon and not some other character such as ‘$’ or ‘@’ ?
Many modern assemblers allow labels without an identifying ‘:’. They simply
have to work harder in order to identify labels.
The instruction sets of some computers are designed such that the mnemonic
speciﬁes more than just the operation. It may also contain part of the operand.The Signetics 2650 microprocessor, for example, has many mnemonics that includeone of the operands [13]. A ‘Store Relative’ instruction on the 2650 may be writtenSTRR,R0 SAV ; the mnemonic ﬁeld includes R0(the register to be stored in location
SAV), which is an operand.
On other computers, the operation may partly be speciﬁed in the operand
ﬁeld. The instruction IX7 X2+X5 , on the CDC Cyber computers [14] means: “add
registerX2and register X5as integers, and store the sum in register X7.” The
operation appears partly in the operation ﬁeld (‘I’)and partly in the operand ﬁeld(‘+’), whereas X7(an operand)appears in the mnemonic. This makes it harder
for the assembler to identify the operation and the operands and, as a result, suchinstruction formats are not common.
16 BasicPrinciples Ch. 1
/
Exercise 1.2 What is the meaning of the Cyber instruction FX7 X2+X5 ?
/To translate an instruction, the assembler uses the OpCode table, which is a
static data structure. The two important columns in the table are the mnemonicand OpCode. Table 1–1 is an example of a simple OpCode table. It is part of theIBM 360 OpCode table and it includes other information.
mnemonic
OpCode type length
A 5A RX 4
AD 6A RX 4
ADR 2A RR 2
AER 3A RR 2
AE 1A RR 2
Table 1–1
The mnemonics are from one to four letters long (in many assemblers they
may include digits). The OpCodes are two hexadecimal digits (8 bits) long, and thetypes (which are irrelevant for now)provide more information to the assembler.
The OpCode table should allow for a quick search. For each source line input,
the assembler has to search the OpCode table. If it ﬁnds the mnemonic, it uses theOpCode to start assembling the instruction. It also uses the other information inthe OpCode table to complete the assembly. If it does not ﬁnd the mnemonic in thetable, it assumes that the mnemonic is that of a directive and proceeds accordingly(see chapter 3).
The OpCode table thus provides for an easy ﬁrst step of assembling an instruc-
tion. The next step is using the operand to complete the assembly. The OpCodetable should contain information about the number and types of operands for eachinstruction. In table 1–1 above, the typecolumn provides this information. Type
RRmeans a Register-Register instruction. This is an instruction with two operands,
both registers. The assembler expects two operands, both numbers between 0 and15 (the IBM 360 has 16 general-purpose registers). Each register number is assem-bled as a 4 bit ﬁeld.
/
Exercise 1.3 Why does the IBM 360 have 16 general purpose registers and not a
round number such as 15 or 20?
Example: The instruction ‘ AR 4,6 ’ means: add register 6 (the source)to reg-
ister 4 (the destination operand). It is assembled as the 16-bit machine instruction1A46, in which 1Ais the OpCode and 46, the two operands.
TypeRXstands for Register-indeX. In these instructions the operand consists
of a register followed by an address.
Example: ‘BAL 5,14 ’. This instruction calls a procedure at location 14, and
saves the return address in register 5 ( BALstands for Branch And Link). It is
assembled as the 32-bit machine instruction 4550000E in which 00Eis a 12-bit
Sec.1.1 Assembler Operation 17
address ﬁeld ( Eis hexadecimal 14), 45is the OpCode, 5is register 5, and the two
zeros in the middle are irrelevant to our discussion. (A note to readers familiarwith the IBM 360—This example ignores base registers as they do not contributeanything to our discussion of assemblers.)
/
Exercise 1.4 What are the two zeros in the middle of the instruction used for?
This example is not a typical one. Numeric addresses are rarely used in assem-
bler programming, since keeping track of their values is a tedious task better left tothe assembler. In practice, symbols are used instead of numeric addresses. Thus theabove example is likely to be written as ‘ BAL 5,XYZ ’, whereXYZis a symbol whose
value is an address. Symbol XYZshould be the label of some source line. Typically
the program will contain the two lines
XYZ A 4,ABC ;THE SUBROUTINE STARTS HERE
..BAL 5,XYZ ;THE SUBROUTINE IS CALLED
Besides the basic task of assembling instructions, the assembler oﬀers many
services to the user, the most important of which is handling symbols. This taskconsists of two diﬀerent parts, deﬁning symbols, and using them. A symbol isdeﬁned by writing it as a label. The symbol is used by writing it in the operandﬁeld of a source line. A symbol can only be deﬁned once but it can be used anynumber of times. To understand how a value is assigned to a symbol, consider theexample above. The ‘add’ instruction Ais assembled and is eventually loaded into
memory as part of the program. The value of symbol XYZis the memory address of
that instruction. This means that the assembler has to keep track of the addresseswhere instructions are loaded, since some of them will become values of symbols.To do this, the assembler uses two tools, the location counter (LC), and the symbol
table.
/The LC is a variable, maintained by the assembler, that contains the address
into which the current instruction will eventually be loaded. When the assemblerstarts, it clears the LC, assuming that the ﬁrst instruction will go into location 0.After each instruction is assembled, the assembler increments the LC by the sizeof the instruction (the size in words, not in bits). Thus the LC always containsthe current address. Note that the assembler does not load the instructions intomemory. It writes them on the object ﬁle, to be eventually loaded into memory bythe loader. The LC, therefore, does not point to the current instruction. It justshows where the instruction will eventually be loaded. When the source line hasa label (a newly deﬁned symbol), the label is assigned the current value of the LCas its value. Both the label and its value (plus some other information)are thenplaced in the symbol table.
/The symbol table is an internal, dynamic table that is generated, maintained,
and used by the assembler. Each entry in the table contains the deﬁnition of asymbol and has ﬁelds for the name, value, and type of the symbol. Some symbol
18 BasicPrinciples Ch. 1
tables contain other information about the symbols. The symbol table starts empty,
labels are entered into it as their deﬁnitions are found in the source, and the tableis also searched frequently to ﬁnd the values and types of symbols whose names areknown. Chapter 2 discusses various ways to implement symbol tables.
In the above example, when the assembler encounters the line
XYZ A 5,ABC ;THE SUBROUTINE STARTS HERE
it performs two independent operations. It stores symbol XYZand its value (the
current value of the LC)in the symbol table, and it assembles the instruction.These two operations have nothing to do with each other. Handling the symboldeﬁnition and assembling the instruction are done by two diﬀerent parts of theassembler. Many times they are performed in diﬀerent phases of the assembly.
If the LC happens to have the value 260, then the entry
name value type
XYZ 0104 REL
will be added to the symbol table (104 is the hex value of decimal 260, and the type
REL will be explained later).
When the assembler encounters the line
BAL 5,XYZ
it assembles the instruction but, in order to assemble the operand, the assembler
needs to search the symbol table, ﬁnd symbol XYZ, fetch its value and make it part
of the assembled instruction. The instruction is, therefore, assembled as 45500104 .
/
Exercise 1.5 The address in our example, 104, is a relatively small number. Many
times, instructions have a 12-bit ﬁeld for the address, allowing addresses up to2
12−1 = 4095. What if the value of a certain symbol exceeds that number?
This is, in a very general way, what the assembler has to do in order to assemble
instructions and handle symbols. It is a simple process and it involves only oneproblem which is illustrated by the following example.
BAL 5,XYZ ;CALL THE SUBROUTINE
..
XYZ A 4,ABC ;THE SUBROUTINE STARTS HERE
In this case the value of symbol XYZis needed before labelXYZis deﬁned. When the
assembler gets to the ﬁrst line (the BALinstruction), it searches the symbol table
forXYZand, of course, does not ﬁnd it. This situation is called the future symbol
problem or the problem of unresolved references . TheXYZin our example is a future
symbol or an unresolved reference.
Pass
indicatorLocation counter
Source
file
Source line
buffer
Lexical scan
routineMain
ProgramError 
proc.
Object
code
assembl y
areaObject
file
Table search procedures
Opcode
tableDirective
tableSymbol
tableSec.1.1 Assembler Operation 19
/Obviously, future symbols are not an error and their use should not be prohib-
ited. The programmer should be able to refer to source lines which either precedeor follow the current line. Thus the future symbol problem has to be solved. Itturns out to be a simple problem and there are two solutions, a one-pass assembler
and a two-pass assembler . They represent not just diﬀerent solutions to the future
symbol problem but two diﬀerent approaches to assembler design and operation .
The one-pass assembler, as the name implies, solves the future symbol problemby reading the source ﬁle once. Its most important feature, however, is that it
does not generate a relocatable object ﬁle but rather loads the object code (themachine language program)directly into memory. Similarly, the most importantfeature of the two-pass assembler is that it generates a relocatable object ﬁle, thatis later loaded into memory by a loader. It also solves the future symbol problemby performing two passes over the source ﬁle. It should be noted at this point thata one-pass assembler can generate an object ﬁle. Such a ﬁle, however, would beabsolute , rather than relocatable, and its use is limited. Absolute and relocatable
object ﬁles are discussed later in this chapter. Figure 1–1 is a summary of the mostimportant components and operations of an assembler.
Figure 1–1. The Main Components andOperations of an Assembler.
20 BasicPrinciples Ch. 1
1.2 The Two-Pass Assembler
A two-pass assembler is easier to understand and will be discussed ﬁrst. Such
an assembler performs two passes over the source ﬁle. In the ﬁrst pass it reads theentire source ﬁle, looking only for label deﬁnitions. All labels are collected, assignedvalues, and placed in the symbol table in this pass. No instructions are assembledand, at the end of the pass, the symbol table should contain all the labels deﬁned inthe program. In the second pass, the instructions are again read and are assembled,using the symbol table.
/
Exercise 1.6 What if a certain symbol is needed in pass 2, to assemble an instruc-
tion, and is not found in the symbol table?
/To assign values to labels in pass 1, the assembler has to maintain the LC. This
in turn means that the assembler has to determine the size of each instruction (inwords), even though the instructions themselves are not assembled.
In many cases it is easy to ﬁgure out the size of an instruction. On the IBM 360,
the mnemonic determines the size uniquely. An assembler for this machine keepsthe size of each instruction in the OpCode table together with the mnemonic andthe OpCode (see table 1–1). On the DEC PDP-11 the size is determined bothby the type of the instruction and by the addressing mode(s)that it uses. Mostinstructions are one word (16-bits)long. However, if they use either the index or
index deferred modes, one more word is added to the instruction. If the instruction
has two operands (source and destination)both using those modes, its size will be3 words. On most modern microprocessors, instructions are between 1 and 4 byteslong and the size is determined by the OpCode and the speciﬁc operands used.
This means that, in many cases, the assembler has to work hard in the ﬁrst
pass just to determine the size of an instruction. It has to look at the mnemonicand, sometimes, at the operands and the modes, even though it does not assemblethe instruction in the ﬁrst pass. All the information about the mnemonic andthe operand collected by the assembler in the ﬁrst pass is extremely useful in thesecond pass, when instructions are assembled. This is why many assemblers saveall the information collected during the ﬁrst pass and transmit it to the second passthrough an intermediate ﬁle . Each record on the intermediate ﬁle contains a copy
of a source line plus all the information that has been collected about that line inthe ﬁrst pass. At the end of the ﬁrst pass the original source ﬁle is closed and is nolonger used. The intermediate ﬁle is reopened and is read by the second pass as itsinput ﬁle.
A record in a typical intermediate ﬁle contains:
The record type. It can be an instruction, a directive, a comment, or an invalid
line.
The LC value for the line.
A pointer to a speciﬁc entry in the OpCode table or the directive table. The
second pass uses this pointer to locate the information necessary to assemble orexecute the line.
Sec.1.2 The Two-Pass Assembler 21
A copy of the source line. Notice that a label, if any, is not use by pass 2 but
must be included in the intermediate ﬁle since it is needed in the ﬁnal listing.
Fig. 1–2 is a ﬂow chart summarizing the operations in the two passes.There can be two problems with labels in the ﬁrst pass; multiply-deﬁned labels
andinvalid labels . Before a label is inserted into the symbol table, the table has to
be searched for that label. If the label is already in the table, it is doubly (or evenmultiply-)deﬁned. The assembler should treat this label as an error and the bestway of doing this is by inserting a special code in the typeﬁeld in the symbol table.
Thus a situation such as:
AB ADD 5,X
..
AB SUB 6,Y
..JMP AB
will generate the entry:
name
value type
AB —MTDF
in the symbol table.
Labels normally have a maximum size (typically 6 or 8 characters), must start
with a letter, and may only consist of letters, digits, and a few other characters.Labels that do not conform to these rules are invalid labels and are normally con-sidered a fatal error. However, some assemblers will truncate a long label to themaximum size and will issue just a warning, not an error, in such a case.
/
Exercise 1.7 What is the advantage of allowing characters other than letters and
digits in a label?
The only problem with symbols in the second pass is bad symbols . These are
either multiply-deﬁned or undeﬁned symbols. When a source line uses a symbol inthe operand ﬁeld, the assembler looks it up in the symbol table. If the symbol isfound but has a type of MTDF, or if the symbol is not found in the symbol table (i.e.,
it has not been deﬁned), the assembler responds as follows.
It ﬂags the instruction in the listing ﬁle.
It assembles the instruction as far as possible, and writes it on the object ﬁle.
It ﬂags the entire object ﬁle. The ﬂag instructs the loader not to start execution
of the program. The object ﬁle is still generated and the loader will read and loadit, but not start it. Loading such a ﬁle may be useful if the user wants to see amemory map (see discussion of memory maps in chapter 7).
yesyesread line 
from source file
no
no1
1write source line & other
info on intermediate fileLC:=LC+sizedetermine size
of instructionstore name & value
in symbol tablelabel
defined
?eof 
?
pass 2close source file
rewind intermediate 
filepass 122 BasicPrinciples Ch. 1
Figure 1–2. The Operations of the Two-Pass Assmbler (part 1).
TheJMP AB instruction above is an example of a bad symbol in the operand
ﬁeld. This instruction cannot be fully assembled, and thus constitutes our ﬁrstexample of a fatal error detected and issued by the assembler.
The last important point regarding a two-pass assembler is the box, in the ﬂow
chart above, that says write object instruction onto the object ﬁle. The point is that
when the two-pass assembler writes the machine instruction on the object ﬁle, it hasaccess to the source instruction. This does not seem to be an important point but,in fact, it constitutes the main diﬀerence between the one-pass and the two-pass
yes
nopass 2
2
2write source & object
lines onto listing filewrite object instruction
onto object fileassemble
instructioneof
?stopread next line from
 intermediate fileSec.1.2 The Two-Pass Assembler 23
Figure 1–2. The Operations of the Two-Pass Assmbler (part 2).
assemblers. This point is the reason why a one-pass assembler can only produce
an absolute object ﬁle (which has only limited use), whereas a two-pass assemblercan produce a relocatable object ﬁle, which is much more general. This importanttopic is explained later in this chapter.
24 BasicPrinciples Ch. 1
1.3 The One-Pass Assembler
The operation of a one-pass assembler is diﬀerent. As its name implies, this
assembler reads the source ﬁle once. During that single pass, the assembler handlesboth label deﬁnitions and assembly. The only problem is future symbols and, tounderstand the solution, let’s consider the following example:
LC
36 BEQ AB ;BRANCH ON EQUAL
..
67 BNE AB ;BRANCH ON NOT EQUAL
..
89 JMP AB ;UNCONDITIONALLY
..
126 AB anything
SymbolABis used three times as a future symbol. On the ﬁrst reference, when
the LC happens to stand at 36, the assembler searches the symbol table for AB,d o e s
not ﬁnd it, and therefore assumes that it is a future symbol. It then inserts ABinto
the symbol table but, since ABhas no value yet, it gets a special type. Its type is
U(undeﬁned). Even though it is still undeﬁned, it now occupies an entry in the
symbol table, an entry that will be used to keep track of ABas long as it is a future
symbol. The next step is to set the ‘value’ ﬁeld of that entry to 36 (the currentvalue of the LC). This means that the symbol table entry for ABis now pointing
to the instruction in which ABis needed. The ‘value’ ﬁeld is an ideal place for the
pointer since it is the right size, it is currently empty, and it is associated withAB. TheBEQinstruction itself is only partly assembled and is stored, incomplete,
in memory location 36. The ﬁeld in the instruction were the value of ABshould be
stored (the address ﬁeld), remains empty.
When the assembler gets to the BNEinstruction (at which point the LC stands
at 67), it searches the symbol table for AB, and ﬁnds it. However, ABhas a type
ofU, which means that it is a future symbol and thus its ‘value’ ﬁeld (=36)is not
a value but a pointer . It should be noted that, at this point, a type of Udoes not
necessarily mean an undeﬁned symbol. While the assembler is performing its singlepass, any undeﬁned symbols must be considered future symbols. Only at the end ofthe pass can the assembler identify undeﬁned symbols (see below). The assemblerhandles the BNEinstruction by:
Partly assembling it and storing it in memory location 67.
Copying the pointer 36 from the symbol table to the partly assembled instruction
in location 67. The instruction has an empty ﬁeld (where the value of ABshould
have been), where the pointer is now stored. There may be cases where this ﬁeld
Sec.1.3 The One-Pass Assembler 25
in the instruction is too small to store a pointer. In such a case the assembler must
resort to other methods, one of which is discussed below.
Copying the LC (=67)into the ‘value’ ﬁeld of the symbol table entry for AB,
rewriting the 36.
When the assembler reaches the JMP AB instruction, it repeats the three steps
above. The situation at those three points is summarized below.
memory symbol memory symbol memory symbol
table table table
loccontents nvtloccontents nvtloccontents nvt
36BEQ - .3 6 BEQ - .3 6 BEQ - .
.. .. ...AB36U .AB67 U . AB89U
.6 7 BNE 36 .6 7 BNE 36 .
.. . .
.
89JMP 67
It is obvious that an indeﬁnite number of instructions can refer to ABas a future
symbol. The result will be a linked list linking all these instructions. When the
deﬁnition of ABis ﬁnally found (the LC will be 126 at that point), the assembler
searches the symbol table for ABand ﬁnds it. The ‘type’ ﬁeld is still Uwhich tells
the assembler that ABhas been used as a future symbol. The assembler then follows
the linked list of instructions using the pointers found in the instructions. It startsfrom the pointer found in the symbol table and, for each instruction in the list, theassembler:
saves the value of the pointer found in the address ﬁeld of the instruction. The
pointer is saved in a register or a memory location (‘temp’ in the ﬁgure below), andis later used to ﬁnd the next incomplete instruction.
Stores the value of AB(=126)in the address ﬁeld of the instruction, thereby
completing it.
The last step is to store the value 126 in the ‘value’ ﬁeld of ABin the symbol
table, and to change the type to D. The individual steps taken by the assembler in
our example are shown in the table below.
It, therefore, follows that at the end of the single pass, the symbol table should
only contain symbols with a type of D. At the end of the pass, the assembler scans
the symbol table for undeﬁned symbols. If it ﬁnds any symbols with a type of U,i t
issues an error message and will not start the program.
Figure 1–3 is a ﬂow chart of a one-pass assembler.
The one-pass assembler loads the machine instructions in memory and thus
has no trouble in going back and completing instructions. However, the listinggenerated by such an assembler is incomplete since it cannot backspace the listing
26 BasicPrinciples Ch. 1
Address Contents Contents Contents
36 BEQ - BEQ - BEQ 126
..
67 BNE 36 BNE 126 BNE 126
..
89 JMP 126 JMP 126 JMP 126
temp=67 temp=36 temp=/
Step 1 Step 2 Step 3
ﬁle to complete lines previously printed. Therefore, when an incomplete instruction
(one that uses a future symbol)is loaded in memory, it also goes into the listingﬁle as incomplete. In the example above, the three lines using symbol ABwill be
printed with asterisks ‘*’ or question marks ‘?’, instead of the value of AB.
/The key to the operation of a one-pass assembler is the fact that it loads the
object code directly in memory and does not generate an object ﬁle. This makes itpossible for the assembler to go back and complete instructions in memory at anytime during assembly.
The one-pass assembler can, in principle, generate an object ﬁle by simply
writing the object program from memory to a ﬁle. Such an object ﬁle, however,would be absolute. Absolute and relocatable object ﬁles are discussed below.
One more point needs to be mentioned here. It is the case where the address
ﬁeld in the instruction is too small for a pointer. This is a common case, sincemachine instructions are designed to be short and normally do not contain a fulladdress. Instead of a full address, a typical machine instruction contains two ﬁelds,mode and displacement (or oﬀset), such that the mode tells the computer how to
obtain the full address from the displacement (see appendix A). The displacementﬁeld is small (typically 8–12 bits)and has no room for a full address.
To handle this situation, the one-pass assembler has an additional data struc-
ture, a collection of linked lists, each corresponding to a future symbol. Each linkedlist contains, in its nodes, pointers to instructions that are waiting to be completed.The list for symbol ABis shown below in three successive stages of its construction.
When symbol ABis found, the assembler uses the information in the list to
complete all incomplete instructions. It then returns the entire list to the pool ofavailable memory.
An easy way to maintain such a collection of lists is to house them in an array.
Fig. 1–5 shows our list, occupying positions 5,9,3 of such an array. Each position
yes
no
yes
yes
not 
found
found
noyesnoread line 
from 
source
scan lineenter name,
pointer &
type of U
load in memoryno6
67
73eof
label
defined
a
symbol
used
search
symbol
table
type
=Dcopy pointer
from s.t. to
instruction
being
assembled
place LC in
s.t. to point
to current
instruction
being
assembled
assemble line
print LC, source
& object codes3
5
4
21
3
31start.
lc=0Sec.1.3 The One-Pass Assembler 27
Figure 1–3. The Operations of the One-Pass Assmbler (part 1).
has two locations, the ﬁrst being the data item stored (a pointer to an incomplete
instruction)and the second, the array index of the next node of the list.
no
yesError!
label is
doubly
defined
scan
s.t.
U
symbol
?stop
Error!
undefined 
symbol(s)
stop1search
s.t.
enter
nameLC &
type=D
in s.t.4
2no
yesfoundtype
=U
follow pointer
in value field.
complete all 
instr. waiting
for value of 
the symbol
store LC in
value field of 
s.t., change 
type to D
2528 BasicPrinciples Ch. 1
Figure 1–3. The Operations of the One-Pass Assmbler (part 2).
/
Exercise 1.8 What would be good Pascal declarations for such a future symbol
list:
a. Using absolute pointers.
b. Housed in an array.
1.4 Absolute and Relocatable Object Files
To illustrate the concept of absolute and relocatable object ﬁles, the following
example is used, assuming a two-pass assembler.
LC
86 JMP TO
..
104 TO ADD 1,2
TheJMPinstruction is assembled as ‘ JMP 104 ’ and is written onto the object ﬁle.
When the object ﬁle is loaded starting at address 0, the JMPinstruction is loaded
at location 86 and the ADDinstruction, at location 104. When the JMPis executed,
it will cause a branch to 104, i.e., to the ADDinstruction.
36
3667
6789symbol table
nvt
AB U
36symbol table
nvt
AB Usymbol table
nvt
AB U
LC=36 LC=67 LC=89
symbol table
nvt
AB U536 89 67
 9  3  /3      4     5      6      7      8      9Sec.1.4 Absoluteand Relocatable ObjectFiles 29
Figure 1–4. A linkedlist for symbol AB.
Figure 1–5. Housing a linkedlist in an array.
On subsequent loads, however, the loader may decide to load the program
starting at a diﬀerent address. On large computers, it is common to have severalprograms loaded in memory at the same time, each occupying a diﬀerent area.Assuming that our program is loaded starting at location 500, the JMPinstruction
will go into location 586 and the ADD, into location 604. The JMPshould branch to
location 604 but, since it has not been modiﬁed, it will still branch to location 104which is not only the wrong location, but is even outside the memory area of theprogram.
1.4.1 Relocation bits
In a relocatable object ﬁle, this situation is taken care of by cooperation between
the assembler and the loader. The assembler identiﬁes and ﬂags each item on theobject ﬁle as either absolute or relocatable. The JMPinstruction above would be
relocatable since it uses a symbol ( TO). TheADDinstruction, on the other hand,
would be absolute. It is assembled as ‘ ADD 12 ’ and will always add registers 1 and
2 regardless of the start address of the program.
30 BasicPrinciples Ch. 1
/In its simplest form, ﬂagging each item is done by adding an extra bit, a
relocation bit , to it. The relocation bit is set by the assembler to 0, if the item
is absolute and to 1, if it is relocatable. The loader, when reading the object ﬁleand loading instructions, reads the relocation bits. If an object instruction has arelocation bit of 0, the loader simply loads it into memory. If it has a relocation bitof 1, the loader relocates it by adding the start address to it. It is then loaded intomemory in the usual way. In our example, the ‘ JMP TO ’ instruction will be relocated
by adding 500 to it. It will thus be loaded as ‘ JMP 604 ’ and, when executed, will
branch to location 604 i.e. to the ADDinstruction.
The relocation bits themselves are not loaded into memory since memory should
contain only the object code. When the computer executes the program, it expectsto ﬁnd just instructions and data in memory. Any relocation bits in memory wouldbe interpreted by the computer as either instructions or data.
This explains why a one-pass assembler cannot generate a relocatable object
ﬁle. The type of the instruction (absolute or relocatable)can be determined onlyby examining the original source instruction. The one-pass assembler loads themachine instructions directly in memory. Once in memory, the instruction is justa number. By looking at a machine instruction in memory, it is impossible to tellwhether the original instruction was absolute or relocatable. Writing the machineinstructions from memory to a ﬁle will create an object ﬁle without any relocationbits, i.e., an absolute object ﬁle. Such an object ﬁle is useful on computers were theprogram is always loaded at the same place. In general, however, such ﬁles havelimited value.
Some readers are tempted, at this point, to ﬁnd ways to allow a one-pass
assembler to generate relocation bits. Such ways exist, and two of them will bedescribed here. The point is, however, that the one-pass assembler is a simple,fast, assemble-load-go program. Any modiﬁcations may result in a slow, complexassembler, thereby losing the main advantages of one-pass assembly. It is preferableto keep the one-pass assembler simple and, if a relocatable object ﬁle is necessary, touse a two-pass assembler (see also the discussion of a one-and-a-half pass assemblerbelow).
Another point to realize is that a relocatable object ﬁle contains more than
relocation bits. It contains loader directives and linking information (covered inchapter 7). All this is easy for a two-pass assembler to generate but hard for aone-pass one.
1.4.2 One-pass, relocatable object ﬁles
Two ways are discussed below to modify the one-pass assembler to generate a
relocatable object ﬁle.
1.A common approach to modify the basic one-pass assembler is to have it generate
a relocation bit each time an instruction is assembled. The instruction is thenloaded into memory and the relocation bit may be stored in a special, packed arrayoutside the program area. When the object code is ﬁnally written on the object
Sec.1.4 Absoluteand Relocatable ObjectFiles 31
ﬁle, the relocation bits may be read from the special array and attached each to its
instruction.
Such a method may work, but is cumbersome, especially because of future sym-
bols. In the case of a future symbol, the assembler does not know the type (absoluteor relocatable)of the missing symbol. It thus cannot generate the relocation bit,resulting in a hole in the special array. When the symbol deﬁnition is ﬁnally found,the assembler should complete all the instructions that use this symbol, and alsogenerate the relocation bit and store it in the special array (a process involving bitoperations).
2.Another possible modiﬁcation to the one-pass assembler will be brieﬂy outlined.
The assembler can write each machine instruction on the object ﬁle as soon as it isgenerated and loaded in memory. At that point the source instruction is availableand can be examined, so a relocation bit can be prepared and written on the objectﬁle with the instruction. The only problem is, as before, instructions using futuresymbols. They must go on the object ﬁle incomplete and without relocation bits.At the end of the single pass, the assembler writes the entire symbol table on theobject ﬁle.
The task of completing those instructions is left to the loader. The loader
initially skips the ﬁrst part of the object ﬁle and reads the symbol table. It thenrereads the ﬁle, and loads instructions in memory. Each time it comes across anincomplete instruction, it uses the symbol table to complete it and, if necessary, torelocate it as well.
The trouble with this method is that it shifts assembler tasks to the loader,
forcing the loader to do what is essentially a two-pass job.
None of these modiﬁcations is satisfactory. The lesson to learn from these
attempts is that, traditionally, the one-pass and two-pass assemblers have beendeveloped as two diﬀerent types of assemblers. The ﬁrst is fast and simple; thesecond, a general purpose program which can support many features.
Chapter 7 discusses typical formats of relocatable object ﬁles and other items
added by the assembler to those ﬁles, to be used by the loader.
1.4.3 The task of relocating
The role of the loader is not as simple as may seem from the above discussion.
Relocating an instruction is not always as simple as adding a start address to it.On the IBM 7090/7094 computers [65,66], for example, many instructions have theformat:
Field OpCode Decrement Tag Address
Size (in bits)3 15 3 15
The exact meaning of the ﬁelds is irrelevant except that the Address andDecrement
ﬁelds may both contain addresses. The assembler must determine the types of bothﬁelds (either can be absolute or relocatable), and prepare two relocation bits. Theloader has to read the two bits and should be able to relocate either ﬁeld. Relocatingthe Decrement ﬁeld means adding the start address just to that ﬁeld and not to theentire instruction.
32 BasicPrinciples Ch. 1
/
Exercise 1.9 How can the loader add something to a ﬁeld in the middle of an
instruction ?
The discussion of separate assembly in chapter 3 (the EXTRN andENTRY di-
rectives)shows that each ﬁeld can in fact have three diﬀerent types, Absolute,Relocatable, and special relocation . Thus the assembler generally has to generate
two relocation bits for each ﬁeld which, in the case of the IBM 7090/7094 (or simi-lar computers), implies a total of four relocation bits. Chapter 7 shows how thosepairs of relocation bits are used as identiﬁcation bits, identifying each line in therelocatable object ﬁle as one of four types: an absolute instruction, a relocatableinstruction, an instruction requiring special relocation, or as a loader directives.
On the IBM PC, an absolute object ﬁle uses the extension .COM, and a relo-
catable object ﬁle, the extension .EXE.
1.5Two Historical Notes
1.5.1 Early relocation
The mathematician John von Neumann, the principal contributor to early com-
puter design, was using relocatable code as early as 1945 [11].
1.5.2 One-and-a-half pass assemblers
Some old assemblers use a technique which is intermediate between one-pass
and two-passes. Such assemblers are called one-and-a-half pass assemblers. In theﬁrst pass, such an assembler generates an object ﬁle on a tape (usually a papertape), but that object ﬁle is incomplete. Instructions with forward references areonly partly assembled and go into the object ﬁle with a hole in them. Once suchan instruction is written on the ﬁle, it is impractical to backspace the tape, ﬁnd theinstruction, and store a pointer in it. As a result, the object ﬁle remains incomplete.However, each time an instruction uses a future symbol, an entry is added to thesymbol table with the name of the symbol and the current LC value (which is apointer to the instruction). At the end of the pass, the ﬁnal value of the LC iswritten on the same tape, followed by the entire symbol table (which at that pointshould be complete). In the second pass (the ‘half’ pass), such an assembler readsthe tape backwards (easy to do with paper tape). It ﬁrst reads the symbol table
and stores it in memory. Then it reads the LC value and the object instructions,from last to ﬁrst. The instructions are stored in memory (in reverse, from the LCvalue backwards)and each incomplete instruction is completed using informationfrom the symbol table.
The UNISAP assembler [47] for the UNIVAC I computer is an example of a
one-and-a-half pass assembler.
Sec.1.6 ForcingUpper 33
1.6 Forcing Upper
In most computers, the main problem in designing the instruction set is to
keep the instructions short. Normally we want an instruction to occupy one or twomemory words, at most three words. On some computers, however, this problemdoes not exist. Computers such as the CDC Cyber or the Cray have very longwords (60–64 bits per word)and, consequently, several instructions can be packedin one word. On the Cyber computers, instructions are 15-, 30-, or 60-bits long, so1, 2, 3, or even 4 instructions can be loaded in one word; on the Cray computers,instructions are 16- or 32-bits long, with similar consequences.
On such computers, the LC must contain two parts, one pointing to the current
word and the other, to a position in the word. There are four positions in a word,numbered 0–3, each corresponding to one quarter of the word. At run time, it isonly possible to branch to position 0, and this creates a special problem with labels.An instruction with a label can be referred to from some other place in the programand, as a result, must be the ﬁrst one (position 0)in a word. The assembler on sucha machine must recognize this situation and, each time it sees a label, make surethat the labeled instruction is loaded into the start (position 0)of the next word.This is called forcing the next instruction up , and is done by the assembler padding
the rest of the current word with NOPinstructions. Example:
LC.P
LC.P
15.0 SB5 A6 15.0 L1 SB5 A615.1 SB6 X5 15.1 SB6 X515.2 SX6 A6+B6 16.0 L2 SX6 A6+B616.0 SA1 5 16.1 SA1 5
The P part of the LC indicates the position in the current word. The example
on the left does not have any labels but still has some forcing upper. Three 15-bitinstructions are loaded into location 15, positions 0, 1, 2. The next instruction,‘SA1 5 ’, is 30 bits long and does not ﬁt in the rest of the word. It is forced into
position 0 of word 16, and position 3 of location 15 is padded with a NOinstruction
(which is not shown). In the example on the right, label L2causes a forcing up of
the third instruction, resulting in two NOinstructions padding location 15.
Note. The position counter in the Cyber actually indicates the number of
bits remaining in the current word. It is initialized to 60 and is decremented by thesize of the instruction, in bits. The programmer can explicitly indicate a forcingupper of an instruction by placing a plus ‘+’ in the label ﬁeld of the instruction. Ahyphen ‘-’ in this ﬁeld suppresses an automatic forcing upper.
/
Exercise 1.10 What are other ways to explicitly request a forcing upper?
/
Exercise 1.11 What other case causes a forcing upper situation?
60
301530
3030
15
15
15 1530
15 151515
15
60
301530
3030
15
15
15 1530
15 151515
150
1
2
3
4
534 BasicPrinciples Ch. 1
1.6.1 Relocating packedinstructions
An interesting problem is, how does the assembler handle relocation bits when
several instructions are packed in one word?
In a computer such as the Cyber, only 30- and 60-bit instructions may contain
addresses. There are only six ways of combining instructions in a 60-bit word, asthe following diagram shows.
Figure 1–6. Packing long instructions.
The assembler has to generate one of the values 0–5 as a 3-bit relocation ﬁeld
attached to each word as it is written on the object ﬁle. The loader reads this ﬁeldand uses it to perform the actual relocation.
Figure 1–7. Adding relocation information.
Sec.1.7 Absoluteand Relocatable AddressExpressions 35
1.7 Absolute and Relocatable Address Expressions
Most assemblers can handle address expressions. Generally, an address expres-
sion may be written instead of just a symbol. Thus the instruction ‘ LOD R1,AB+1 ’
loads reg. 1 from the memory location following AB; the instruction ‘ ADD R1,AB+5 ’
similarly operates on the memory location whose address is 5 greater than the ad-dressAB. More complex expressions can be used, and the following two points should
be observed:
Many assemblers (almost all the old ones and some of the newer ones)do not
recognize operator precedence. They evaluate any expression strictly from left toright and do not even allow parentheses. Thus the expression ‘ A+B*C ’ will be eval-
uated by the assembler as ‘ (A+B)*C ’ and not, as might be expected, as ‘ A+(B*C) ’.
The reason is that complex address expressions are rarely necessary in assemblerprograms and it is therefore pointless to add parsing routines to the assembler.However, see Ch. 8 for some interesting exceptions.
When an instruction using an expression is assembled, the assembler should gen-
erate a relocation bit based on the expression. Every expression should thereforehave a well deﬁned type. It should be either absolute or relative. As a result, certainexpressions are considered invalid by the assembler. Examples: ‘ AB+1’ has the same
type asAB. Typically ABis relative, but it is possible to deﬁne absolute symbols (see
the discussion of EQU&SETin chapter 3). In general, an expression of the form
rel+abs, rel-abs , are relative, and expressions of the form abs±absare absolute.
An expression of the form rel−relis especially interesting. Consider the case
LC
16 A LOD
..
27 B STO
The value of Ais 16 and its type is relative (meaning Ais a regular label, deﬁned
by writing it to the left of an instruction). Thus Arepresents address 16 from the
start of the program. Similarly Bis address 27 from the start of the program. It is
thus reasonable to deﬁne the expression B-Aas having a value of 27 −16 = 11 and
a type of absolute. It represents the distance between the two locations, and thatdistance is 11, regardless of where the program starts.
/
Exercise 1.12 What about the expression A-B? is it valid? If yes, what are its
value and type?
On the other hand, an expression of the form rel+relhas no well-deﬁned
type and is, therefore, invalid. Both A&Babove are relative and represent certain
addresses. The sum A+B, however, does not represent any address. In a similar
wayabs∗absisabs,rel∗absisrelbutrel∗relis invalid. abs/abs isabs,rel/abs
isrelbutrel/rel is invalid. All expressions are evaluated at the last possible
moment. Expressions in any pass 0 directives (see Ch. 4 for a discussion of pass 0)
36 BasicPrinciples Ch. 1
are evaluated when the directive is executed, in pass 0. Expressions in any pass 1
directives are, similarly, evaluated in pass 1. All other expressions (in instructionsor in pass 2 directives)are evaluated in pass 2.
An extreme example of an address expression is ‘ A-B+C-D+E ’ where all the
symbols involved are relative. It is executed from left to right ‘ (((A-B)+C)-D)+E ’,
generating the intermediate types: ((( rel−rel)+rel)−rel)+rel→((abs+rel)−
rel)+rel→(rel−rel)+rel→abs+rel→rel. A valid expression.
In general, expressions of the type ‘ X+A-B+C-D+ ···+M-N+Y ’ are valid when ‘ X,Y’
are absolute and ‘ A,B,···,M,N’ are relative. The relative symbols must come in
pairs like A-Bexcept the last one M-N, whereNmay be missing. If Nis missing, the
entire expression is relative, otherwise, it is absolute.
/
Exercise 1.13 How does the assembler handle an expression such as ‘ A-B+K-L ’i n
which all the symbols are relative but K,Lare external?
1.7.1 Summary
The two-pass assembler generates the machine instructions in pass two, where it
has access to the source instructions. It checks each source instruction and generatesa relocation bit according to:
If the instruction uses a relative symbol, then it is relocatable and the relocation
bit is 1.
If the instruction uses an absolute symbol (see the discussion of EQUin chapter 3)
or uses no symbols at all, the instruction is absolute and the relocation bit is 0.
An instruction in the relative mode contains an oﬀset, not the full address, and
is therefore absolute (see App. A for the ralative mode).
The one-pass assembler generates the object ﬁle at the end of its single pass,
by dumping all the machine instructions from memory to the ﬁle. It has no accessto the source at that point and therefore cannot generate relocation bits.
As a result, those two types of assemblers have evolved along diﬀerent lines,
and represent two diﬀerent approaches to the overall assembler design, not just tothe problem of resolving future symbols.
1.8 Local Labels
In principle, a label may have any name that obeys the simple syntax rules of
the assembler. In practice, though, label names should be descriptive. Names suchasDATE, MORE, LOSS, RED are preferable to A001, A002, ...
There are exceptions, however. The use of the non-descriptive label A1in the
following example:
.
JMP A1
DDCT DS 12 reserve 12 locations for array DDCTA1 .
.
Sec.1.8 LocalLabels 37
is justiﬁed since it is only used to jump over the array DDCT. (Note that the array’s
name is descriptive, possibly meaning deductions ordouble-dictionary )TheDSdi-
rective is explained in chapter 3. We say that A1is used only locally, to serve a
limited purpose.
/As a result, many assemblers support a feature called local labels. It is due
to M. E. Conway who used it in the early UNISAP assembler for the UNIVAC Icomputer [47]. The main idea is that if a label is used locally and does not requirea descriptive name, why not give it a name that will signify this fact. Conway usednames such as 1H,2Hfor the local labels. The name of a local label in our examples
is a single decimal digit. When such a label is referred to (in the operand ﬁeld), thedigit is followed by either BorF(for Backward or Forward).
LC
.
.
131: ...
..
17 JMP 1F jump to 24
..
241: LOD R2,1B 1B here means address 13
..
311: ADD R1,2F 2F is address 102
..
1022: DC 1206,-17
..
115 SUB R3,2B-1 102-1=101
Example. Local labels.
The example shows that local labels is a simple, useful, concept that is easy to
implement. In a two-pass assembler, each local label is entered into the symbol tableas any other symbol, in pass 1. Thus the symbol table in our example contains:
Symbol Table
n
v
11 312 413 12 102
38 BasicPrinciples Ch. 1
The order of the labels in the symbol table is important. If the symbol table is
sorted between the two passes, all occurrences of each local label should remainsorted by value. In pass 2, when an instruction uses a local label such as 1F, the
assembler identiﬁes the speciﬁc occurence of label 1 by comparing all local labels1 to the current value of the LC. The ﬁrst such instruction in our example is the‘JMP 1F ’ at LC=17. Clearly, the assembler should look for a local label with the
name ‘1’ and a value ≥17. The smallest such label has value 24. In the second
case, LC=24 and the assembler is looking for a 1B. It needs the label with name ‘1’
and a value which is the largest among all values <24. It therefore identiﬁes the
label as the ‘1’ at 13.
/
Exercise 1.14 If we modify the instruction at 24 above to read 1: LOD R2,1F
would the 1Frefer to address 31 or 24?
In a one-pass assembler, again the labels are recognized and put into the symbol
table in the single pass. An instruction using a local label iBis no problem, since
is needs the most recent occurence of the local label ‘1’ in the table. An instructionusing an iFis handled like any other future symbol case. An entry is opened in the
symbol table with the name iF,at y p eo f U, and a value which is a pointer to the
instruction.
In the example above, a snapshot of the symbol table at LC=32 is:
Symbol Table
n
v t
11 3 D12 4 D1 31 D 31 is the value of the third 12 31 U 31 is a pointer to the ADD instruction
An advantage of this feature is that the local labels are easy to identify as such,
since their names start with a digit. Most assemblers require regular label namesto start with a letter.
In modern assemblers, local labels sometimes use a syntax diﬀerent from the
one shown here. See Ch. 8 for examples.
1.8.1 The LC as a local symbol
Virtually all assemblers allow a notation such as ‘ BPL *+6 ’ where ‘*’ stands
for the current value of the LC. The operand in this case is located at a point 6locations following the BPLinstruction.
The LC symbol can be part of any address expression and is, of course, relo-
catable. Thus *+Ais valid if Ais absolute, while *-Ais always okay (and is absolute
ifAis relative, relative if Ais absolute). This feature is easy to implement. The
address expression involving the ‘*’ is calculated, using the current value of the LC,and the value is used to assemble the instruction, or execute the directive, on thecurrent source line. Nothing is stored in the symbol table.
Sec.1.8 LocalLabels 39
Some assemblers use the asterisk for multiplication, and may designate the
period ‘.’ or the ‘$’ for the LC symbol.
On the PDP-11 the notation ‘ X: .=.+8 ’ is used to increment the LC by 8, and
thus to reserve eight locations (compare this to the DS directive).
/
Exercise 1.15 What is the meaning of JMP * ,JMP *-* ?
1.9 Multiple Location Counters
This feature makes it possible to write the source program in a certain way,
convenient to the programmer, and load it in memory in a diﬀerent way, suitablefor execution. It happens many times that, while writing a program, a new piece ofdata, say an array, is needed at a certain point. It is handy to write the declarationof the array immediately following the ﬁrst instruction that uses it, like:
ADD D,...
DD S1 2
However, at run time, the hardware, after executing the ADDinstruction, would
try to execute the ﬁrst element of array Das an instruction. Obviously, instruc-
tions and data have to be separated, and normally all the arrays and constants aredeclared at the end of the program, following the last executable instruction ( HLT).
1.9.1 The USEdirective
Multiple location counters make it possible to enjoy the best of both worlds.
The data can be declared when ﬁrst used, and can be loaded at the end of theprogram or anywhere else the programmer wishes. This feature uses several direc-tives, covered in chapter 3, the most important of which will be described here.It is based on the principle that new location counters can be declared and givennames, at assembly time, at any point in the source code. The example above canbe handled by declaring a location counter with a name (such as DATA)instructing
the assembler to assemble the DSdirective under that LC, and to switch back to
the main LC—which now must have a name—like any other LC. Its name is ‘ ’ (aspace).
This is done by the special directive USE:
ADD D, ...
USE DATA
DD S 1 2
USE *..
This directive directs the assembler to start using (or to resume the use of)a new
location counter. The name is speciﬁed in the operand ﬁeld, so an empty operandmeans the main LC. The asterisk ‘*’ implies the previous LC, the one that was usedbefore the last USE.
40 BasicPrinciples Ch. 1
/
Exercise 1.16 The previous section discusses the use of asterisk as the LC value.
When executing a USE * , how does the assembler know that the asterisk is not the
LC value?
TheUSEdirectives divide the program into several sections, which are loaded,
by the loader, into separate memory areas. The sections are loaded in the order inwhich their names appear in the source. Fig. 1–8 is a good example:
.
.(1)
.
USE DATA
..(2)
.
USE *
..(3)
.
USE BETA
..(4)
.
USE DATA
..(5)
.
USE < space>
..(6)
.
USE GAMMA
..(7)
.END
Figure 1–8. Dividing a program into sections.
At load time, the diﬀerent sections would be loaded in the order MAIN, DATA,
BETA, GAMMA or 1,3,6,2,5,4,7. Chapter 7 explains the details of such a load, which
involves an additional loader pass.
/
Exercise 1.17 Can we start a program with a USE ABC ? in other words, can the
ﬁrst section be other than the main section?
Another example of the same feature is procedures. In assembler language, a
procedure can be written as part of the main program. However, the procedure
Sec.1.9 MultipleLocationCounters 41
should only be executed when called from the main program. Therefore, it should
be separated from the main instruction stream, since otherwise the hardware wouldexecute it when it runs into the ﬁrst instruction of the procedure. So somethinglike:.
.
0LOD ...
..
15SUB ...
16CALL P
17P ADD R5,N
..
45RET
46CLR ...
..
104 END
is wrong. The procedure is deﬁned on lines 17–45 and is called on line 16. This
makes the source program more readable, since the procedure is written next to itscall. However, the hardware would run into the procedure and start executing itright after it executes line 16, i.e., right after it has been called. The solution is touse a new LC—named, perhaps, PROC—by placing a USE PROC between lines 16, 17
and aUSE * between lines 45, 46.
1.9.2COMMON blocks
Fortran programmers are familiar with the COMMON statement. This is a block
of memory reserved in a common area, accessible to the main program and to allits procedures. It is allocated by the loader high in memory, overlaying the loaderitself. The common area cannot be preloaded with constants, since it uses the samememory area occupied by the loader. In many assemblers, designed to interface withFortran programs, there is a preassigned LC, called //, such that all data declaredunder it end up being loaded in the common area. The concept of labeled commonin Fortran also has its equivalent in assembler language. The Fortran statement‘COMMON/NAM/A(12),B(5) ’ can be written in assembler language as:
.
USE /NAM/
AD S 1 2BD S 5
USE DAT
C DC 56,-90
USE..
42 BasicPrinciples Ch. 1
The two arrays A, B would be loaded in the labeled common /NAM/ , while the
constants labeled Cwould end up as part of section DAT.
The IBM 360 assembler has a CSECT directive, declaring the start of a control
section . However, a control section on the 360 is a general feature. It can be used to
declare sections like those described here, or to declare sections that are consideredseparate programs and are assembled separately. They are later loaded together,by the loader, to form one executable program. The diﬀerent control sections arelinked by global symbols, declared either as external or as entry points. The entireconcept is explained in chapter 3, as part of the discussion of the EXTRN, ENTRY
directives.
The VAX Macro assembler (see Ch. 8)[77] has a .PSECT directive similar to
CSECT , and it does not support multiple LCs. A typical VAX example is:
.TITLE CALCULATE PI
.PSECT DATA, NOEXE,WRT
A=2000B: .WORD 6C: .LONG 8
.PSECT CODE, EXE,NOWRT.ENTRYPI,0..<instructions >
..$EXIT.PSECT CONS, NOEXE,NOWRT
K: .WORD 1230
.END PI
Each.PSECT includes the name of the section, followed by attributes such as
EXE,NOEXE ,WRT,NOWRT .
The memory on the 80x86 microprocessors is organized in 64k (highly over-
lapping)segments. The microprocessor can only generate 16-bit addresses, i.e., itcan only specify an address within a segment. A physical address is created bycombining the 16-bit processor generated address with the contents of one of thesegment registers in a special way (see refs. [38, 57] for the details). There are four
such registers: The DS (data segment), CS (code segment), SS (stack segment) andES (extra segment).
When an instruction is fetched, the PC is combined with the CS register and
the result is used as the address of the next instruction (in the code segment). Whenan instruction speciﬁes the address of a piece of data, that address is combined withthe DS register, to obtain a full address in the data segment. The extra segmentis normally used for string operations, and the stack segment, for stack-orientedinstructions (PUSH, POP or any instructions that use the SP or BP registers).
Sec.1.9 MultipleLocationCounters 43
The choice of segment register is done automatically, depending on what the
computer is doing at the moment. However, there are directives that allow the userto override this choice, when needed.
As a result of this organization, there is no need for multiple LCs on those
microprocessors.
1.10 Literals
Many instructions require their operands to be addresses. The ADDinstruction
is typically written ‘ ADD AB,R3 ’o r‘ADD R3,AB ’ whereABis a symbol and the in-
struction adds the contents of location ABto register 3. Sometimes, however, the
programmer wants to add to register 3, not the contents of any memory locationbut a certain constant, say the number −7. Modern computers support the im-
mediate mode which allows the programmer to write ‘ ADD #-7,R3 ’. The number
sign ‘#’ indicates the immediate mode and it implies that the instruction contains
the operand itself, not the address of the operand. Most old computers, however,do not support this mode; their instructions have to contain addresses, not theoperands themselves. Also, in many computers, an immediate operand must be asmall number.
To help the programmer in such cases, some assemblers support literals .A no-
table example is the MPW assembler for the Macintosh computer (see Ch. 8). Aliteral is a constant preceded by an equal sign ‘=’. Using literals, the programmercan write ‘ ADD =-7,R3 ’ and the assembler handles this by:
Preloading the constant −7 in the ﬁrst memory location in the literal table (how-
ever, see the LITORG directive in chapter 3 for an exception). The literal table is
loaded in memory immediately following the program.
Assembling the instruction as ‘ ADD TMP,R3 ’ whereTMPis the address where the
constant was loaded
Such assemblers may also support octal (=O377 or =377B), hex (=HFF0A),
real (=1.37 or =12E-5)or other literals.
1.10.1 The literal table
To handle literals, the assembler maintains a table, the literal table, similar
to the symbol table. It has columns for the name, value, address and type of eachliteral. In pass 1, when the assembler ﬁnds an instruction that uses a literal, such as−7, it stores the name ( −7)in the ﬁrst available entry in the literal table, together
with the value (1 ...11001
2)and the type (decimal) . The instruction itself is treated
as any other instruction with a future symbol. At the end of pass 1, the assembleruses the LC to assign addresses to the literals in the table. In pass 2, the tableis used, in much the same way as the symbol table, to assemble instructions usingliterals. At the end of pass 2, every entry in the literal table is treated as a DC
directive and is written on the object ﬁle in the usual way. There are three pointsto consider when implementing literals.
44 BasicPrinciples Ch. 1
Two literals with the same name are considered identical; only one entry is gener-
ated in the literal table. On the other hand, literals with diﬀerent names are treatedas diﬀerent even if they have identical values, such as =12.5 and =12.50.
All literals are loaded following the end of the program. If the programmer wants
certain literals to be loaded elsewhere, the LITORG directive can be used. It is fully
described in chapter 3, but the following example clariﬁes a point that should bementioned here. .
ADD =-7,R3
.
LITORG
.
SUB =-7,R4
.
The ﬁrst −7 is loaded, perhaps with other literals, at the point in the program
where the LITORG is speciﬁed. The second −7, even though identical to the ﬁrst, is
loaded separately, together with all the literals used since the LITORG , at the end of
the program.
TheLITORG directive is commonly used to make sure that a literal is loaded
in memory close to the instruction using it. This may be important in case therelative mode is used.
The LC can be used as a literal ‘= ∗’. This is an example of a literal whose name
is always the same, but whose value is diﬀerent for each use.
/
Exercise 1.18 What is the meaning of JMP =* ?
1.10.2 Examples
As has been mentioned before, some assemblers support literals even though
the computer may have an immediate mode, because an immediate operand isnormally limited in size. However, more and more modern computers, such as the68000 and the VAX, support immediate operands of several sizes. Their assemblersdo not have to support any literals. Some interesting VAX examples are:
1.MOVL #7,R6 is assembled into ‘ D0 07 56 ’.D0is the OpCode, 07is a byte with
two mode bits and six bits of operand. The two mode bits ( 00)specify the
short literal mode. This is really a short immediate mode. Even though theword ‘literal’ is used, it is not a use of literal but rather an immediate mode.The diﬀerence is that, in the immediate mode, the operand is part of theinstruction whereas, when a literal is used, the instruction contains the addressof the operand, not the operand itself. The third byte ( 56)speciﬁes the use of
register 6 in mode 5 (register mode). The assembler has generated a three-byteMOVLinstruction in the short literal mode. This mode is automatically selected
by the assembler if the operand ﬁts in six bits.
2.MOVW I^#7,R6 is assembled into ‘ B0 8F 0007 56 ’. Here the user has forced
the assembler to use the immediate mode by specifying I^. The immediate
Sec.1.10 Literals 45
operand becomes a word (2 bytes or 16 bits)and the instruction is now 5 bytes
long. The second byte speciﬁes register F(which happens to be the PC on
the VAX)in mode 8 (autoincrement) . This combination is equivalent to theimmediate mode, where the immediate operand is stored in the third byte ofthe instruction. The last byte ( 56)is as before.
3. Again, a MOVLinstruction but in a diﬀerent context.
LC
MOVL #DATA,R6 assembled into D0 8F 00000037’ 56
..
0037DATA .BYTE ...
..
Even though the operand is small (0037)and ﬁts in six bits, the assembler
has automatically selected the immediate mode ( 8F)and has generated the
constant as a long word (32 bits). The reason is that the source instructionuses a future symbol ( DATA). The assembler has to determine the instruction
size in pass 1 and, since DATAis a future symbol, the assembler does not have
its value and has to assume the largest possible value. The result is a sevenbyte instruction instead of the three bytes in the ﬁrst example!
Incidentally, the qoute in ( 00000047’ )indicates that the constant is relocat-
able.
1.11 Attributes of Symbols
The value of a symbol is just one of several possible attributes of the symbol,
stored, together with the symbol name, in the symbol table. Other attributes maybe the type, LC name, and length. The LC name is important for relocation. So farthe meaning of relocation has been to add the start address of the program. Withmultiple LCs, the meaning of ‘to relocate’ is to add the start address of the currentLC section. When a relocatable instruction is written on the object ﬁle, it is nolonger enough to assign it a relocation bit of 1. The assembler also has to write thename of the LC under which the instruction should be relocated. Actually, a codenumber is written instead of the name. Chapter 7 says more about this feature.
Not every assembler supports the length attribute and, when supported, this
attribute is deﬁned in diﬀerent ways by diﬀerent assemblers. The length of a symbolis deﬁned as the length of the associated instruction. Thus ‘ A LOD R1,54 ’ assigns to
labelAthe size of the LODinstruction (in words). However the directive ‘ CD S3 ’may
assign to label Ceither length 3 (the array size)or length 1 (the size of each array
element). Also, a directive such as ‘ D DC 1.786,‘STRNG’,9 ’ may assign to Deither
length 3 (the number of constants)or the size of the ﬁrst constant, in words.
The most important attribute of a symbol is its value, such as in ‘ SUB R1,XY ’.
However, any attribute supported by the assembler should be accessible to the
46 BasicPrinciples Ch. 1
programmer. Thus things such as ‘ T’A, L’B ’ specify the type and length of symbols
and can be used throughout the program. Examples such as:
H DC L’X the length of X (in words)is preloaded in location H
G DS L’X arrayGhasL’Xelements
AIF (T’X=ABS).Z a conditional assembly directive, see chapter 4.
are possible, even though not common.
1.12 Assembly-Time Errors
Many errors can be detected at assembly time, both in pass 1 and pass 2.
Chapter 4 discusses pass 0, in connection with macros and, that pass, of course,can have its own errors.
Assembler errors can be classsiﬁed in two ways, by their severity, and by their
location on the source line. The ﬁrst classiﬁcation has three classes: Warnings,errors, and fatal errors. A warning is issued when the assembler ﬁnds somethingsuspicious, but there is still a chance that the program can be assembled and runsuccessfully. An example is an ambiguous instruction that can be assembled inseveral ways. The assembler decides how to assemble it, and the warning tells theuser to take a careful look at the particular instruction. A fatal erroris issued whenthe assembler cannot continue and has to abort the assembly. Examples are a badsource ﬁle or a symbol table overﬂow.
If the error is neither a warning nor fatal, the assembler issues a message and
continues, trying to ﬁnd as many errors as possible in one run. No object ﬁle iscreated, but the listing created is as complete as possible, to help the user to quicklyidentify all errors.
The second classiﬁcation method is concerned with the ﬁeld of the source in-
struction where the error was detected. Wrong comments cannot be detected bythe assembler, which leaves four classes of errors, label, operation, operand, andgeneral.
1. Label Errors. A label can either be invalid (syntactically wrong), undeﬁned,
or multiply-deﬁned. Since labels are handled in pass 1, all label errors aredetected in that pass. (although undeﬁned errors are detected at the end ofpass 1).
2. Operation errors. The mnemonic may be unknown to the assembler. This is a
pass 1 (or even pass 0)error since the mnemonic is necessary to determine thesize of the instruction.
3. Operand errors. Once the mnemonic has been determined, the assembler knows
what operands to expect. On many computers, a LODinstruction requires
a register followed by an address operand. A MOVinstruction may require
two address operands, and a RETinstruction, no operands. An error ‘wrong
operand(s)’ is issued if the right type of operand is not found.
Sec.1.12 Assembly-TimeErrors 47
Even if the operands are of the right type, their values may be out of range.
In a seemingly innocent instruction such as ‘ LOD R16,#70000 ’, either operand, or
even both, may be invalid. If the computer has 16 registers, R0-R15 , thenR16is
out of range. If the computer supports 16-bit integers, then the number 70000 istoo large.
Even if the operands are valid, there may still be errors such as a bad addressing
mode. Certain instructions can only use certain modes. A speciﬁc mode can onlyuse addresses in a certain range. Project 1–4 at the end of this chapter describesan assembler where such restrictions exist and quite a few errors are possible.
4. General errors do not pertain to any individual line and have to do with the gen-
eral status of the assembler. Examples are ‘out of memory’, ‘cannot read/writeﬁle xxx’, ‘illegal character read from source ﬁle’, ‘table xxx overﬂow’ ‘phaseerror between passes’.
The last example is particularly interesting and will be described in some de-
tail. It is issued when pass 1 makes an assumption that turns out, in pass 2,to be wrong. This is a severe error that requires a reassembly. Phase errors re-quire a computer with sophisticated instructions and complex memory manage-ment; they don’t exist on computers with simple architectures. The Intel 80x86microprocessors—with variable-size instructions, several oﬀset sizes, and segmentedmemory management—are a good example of computer architecture where phaseerrors may easily occur.
Here are two examples of phase errors on those microprocessors. (Refs. [38, 57]
are good introductions to 8086/8088 architecture and instruction set):
An instruction in a certain code segment refers to a variable declared in a data
segment following the code segment. In pass 1, the assembler assumes that the
variable is declared in the same segment as the instruction, and is a future symbol.The instruction is determined accordingly. In pass 2, when the time comes toassemble the instruction, all the variables are known, and the assembler discoversthat the variable in question is far. A longer instruction is necessary, the pass-1
assumption turns out to be wrong, and pass 2 cannot assemble the instruction. Thiserror is illustrated below.
CODE
S SEGMENT PUBLIC
....MOV AL,ABC....
CODE
S ENDS
DATAS SEGMENT PUBLIC
ABC DB 123
..
DATAS ENDS
END START
48 BasicPrinciples Ch. 1
an instruction in the relative mode has a ﬁeld for the relative address (the oﬀset).
Several possible oﬀset sizes are possible on the 80x86, depending on the distancebetween the instruction and its operand. If the operand is a future symbol, evenin the same segment as the instruction, the assembler has to guess a size for theoﬀset. In pass 2 the operand is known and, if it too far from the instruction, theoﬀset size guessed in pass 1 may turn out to be too small.
The Microsoft macro assembler (MASM), a typical modern assembler for the
80x86 microprocessors, features a list of about 100 error messages. Even an earlyassembler such as IBMAP for the IBM 7090 [65] had a list of 125 error messages,divided into four classes according to the severity of the error.
Sec.1.13 Review Questionsand Projects 49
1.13 Review Questions and Projects
1.What is the general format of an assembler instruction? What is the meaning
of each ﬁeld?
2.What is the diﬀerence between a label and a symbol?
3.List some typical zero-operand instructions.
4.In old assemblers the source ﬁle was punched on cards, one line per card. Why
was it important to punch a sequence number on each card?
5.Use your knowledge of data structures; what are good data structures for an
OpCode table? The table is static (no insertions or deletions)and is searched veryoften.
6.For each of the projects below, if the project describes a 2-pass assembler, design
a format for the intermediate ﬁle. What information should each record contain?
7.Look at several textbooks on assembler language programming for diﬀerent
computers. What are the rules for:
a.Symbol names.
b.The syntax of a source line.
8.The asterisk ‘*’ is a favorite character of assembler writers and has been men-
tioned in this chapter many times, in connection with several diﬀerent assemblerfeatures. What are those features?
9.Look up several textbooks on assembler language programming, to review the
concept of multiple location counters.
10.Manually perform pass 1 over the following section, build the symbol table
and show it at the end of the pass. Assumptions: The LC starts at 0. Mnemonicsending with an Rspecify instructions of size 1; all others, instructions of size 2.
AR 1,2
N LR 3,4
SBI M,3
Q CR 4,5P MVI #5,Q
MR 6,7
Z JMP D
11.The asterisk ‘*’ is used, among other things, to indicate the LC value. It can
be used in address expressions such as *+4. Since such an expression indicates an
address greater than the current address, is it an unresolved reference?
12.What feature of assembler language leads to the idea of a two-pass assembler?
13.Compare and contrast literals and the immediate mode. What are the advan-
tages and disadvantages of each?
50 BasicPrinciples Ch. 1
1.13.1 Project 1–1
Your task is to implement and test the assembler described below. The entire
project should be done twice, as a two-pass and as a one-pass assembler. The sourceand object codes described here are extremely simple, as they ought to be for a ﬁrstproject, and are based on a hypothetical, simple, second generation computer. Thecomputer is supposed to have a single working register, traditionally called theAccumulator (Acc). It has Mwords of storage, each Nbits long. Neither Mnor
Nare speciﬁed, and part of your task is to come up with several sets of reasonable
values, select two sets, and use one for the two-pass and the other, for the one-pass,assembler. This would guarantee a full understanding of the way those values aﬀectthe design of the instruction set, the source instructions, and the object instructions.More about M,Nbelow.
The instruction set is both small and simple, making it easy to implement
the assembler, but hard to write programs for the computer (however, your testprograms should be short and can be meaningless, since they only test the assembler,not the hardware).
mnem
OpCode operand description
LOD 1 yes Acc ←Mem(op)
STO 2 ” Mem(op) ←Acc
ADD 3 ” Acc ←Acc+Mem(op)
BZE 4 ” branch to Op if Acc=0
BNE 5 ” same for Acc <0
BRA 6 ” unconditional branch
INP 7 no Acc ←the next character in the input stream
OUT 8 ” next char in output stream ←Acc
CLA 9 ” Acc ←0
HLT 0 ” stop
The test program below is completely meaningless but it illustrates several
useful points.
1. This simple assembler supports symbols. To be sure, symbols can only be
one letter, but they can be future symbols.
2. The object code is shown in decimal, not binary. The precise bit pattern and
length of each object instruction depends on the choice of M,N. One such choice is
demonstrated below. LC values are not shown either, since instruction sizes dependon the choice of M,N. This is also the reason why the values of symbols X, Yare
unknown.
3. There are no directives, again implying a simple assembler (but harder to
use). This is the reason absolute addresses are used in the example.
4. You design the syntax of the source line. For this ﬁrst project it is best
to use ﬁxed format, making use of the fact that each mnemonic is three characterslong and symbols are a single letter.
Sec.1.13 Review Questionsand Projects 51
Label Source Object
INP 7
STO 50 25 0
INP 7
STO 51 25 1
BZE X 4X
ADD 50 35 0
OUT 8
BRA Y 6Y
X LOD 50 15 0
ADD 50 35 0
YSTO 52 25 2
HLT 0
Test Program
Before implementing the assembler, values for M,Nshould be selected. One
simple, although not a very practical, choice is M=1 0 2 4=1 k,N= 16. This im-
plies that each operand is 10 bits long, and also makes it easy to ﬁt each instructionin one memory word. Each instruction will now have a 6-bit OpCode, allowing forup to 64 instructions, and a 10-bit operand which, in many cases, will be unused.The example above is now duplicated, as table 1–2, with the object codes shown inbinary.
Object
LC
Label Source OpCode Op
0 INP 000111 0
1 STO 50 000010 0000110010
2 INP 000111 0
3 STO 51 000010 0000110011
4 BZE X 000100 0000001000
5 ADD 50 000011 0000110010
6 OUT 001000 0
7 BRA Y 000110 0000001010
8X LOD 50 000001 0000110010
9 ADD 50 000011 0000110010
10YSTO 52 000010 0000110100
11 HLT 000000 0
Table 1–2.
The most important point about this choice of M,Nis the many unused
Op ﬁelds (in a third of the instructions in our example). This clearly points toa very common principle of instruction set design: variable length instructions.Instructions with an Op ﬁeld should be longer than ones with only an OpCode.
52 BasicPrinciples Ch. 1
A choice of M= 256(= 28),N= 8 may clarify this point. M= 256 implies
8-bit addresses. Now each OpCode may occupy one word (8 bits)and each operand,another word (8 bits). Instructions are now either one or two words long, a steptoward a more realistic instruction set.
/
Exercise 1.19 Rewrite the table above for this choice of M,N.
/
Exercise 1.20 There is now room for 256 OpCodes, too many for our simple
computer. We probably need only a 4- or 5-bit OpCode, leaving either 3 or 4unused bits in the ﬁrst word of each instruction. What would be a good way toextend the hardware, so we can use those bits?
Testing: After a choice of M,Nis made, the assembler (actually, two assem-
blers)can be implemented. Testing is a very important task in each of the projectsdescribed here. You should prepare enough test programs to test every instructionin every valid mode, every directive, and every error situation. Since the presentproject is so simple, there are no directives, no modes, and only a few possibleerrors. Subsequent projects will have, of course, more possible errors.
/
Exercise 1.21 What are the assembler errors in this project?
Output: The one-pass assembler should generate the object program in mem-
ory, and a listing ﬁle. The object program should then be printed by you andchecked by hand. The two-pass assembler should generate both an object and alisting ﬁle. The object ﬁle should later be printed, again to verify it by hand.
1.13.2 Project 1–2
Extend the assembler of project 1–1 in the following ways:
1. Label names no longer have to be a single letter. They can be up to 6 letters
and digits, and should start with a letter.
/
Exercise 1.22 Why is it a good idea to require a label to start with a letter? what
is wrong with 1Aas a label?
When local labels are supported, the assembler loses this advantage, since local
label names do start with a digit. On the other hand, it becomes easier to distinguisha local symbol from a regular one.
2. As a result, the source line format may have to be redesigned. Source lines
should have a free format, and you can select one of the two possibilities:
a. A label, if it exists, must start in position 1. Without a label, position 1
must be left blank.
b. A label must be followed by a colon, and a comment must be preceded by a
semicolon. This requires the programmer to work harder but simpliﬁes the lexicalanalysis. The individual ﬁelds of a source line should be separated by commas.
3. The three directives END,DS, andDCshould be supported.
Sec.1.13 Review Questionsand Projects 53
a.ENDsimply signiﬁes the end of the source code.
b. The general format of the DSdirective is:
labelDSoperand
where the label is optional and the operand should be a non-negative integer.
TheDSis similar to the array orDIMENSION statement in higher-level languages,
and is a convenient way to reserve storage in assembler programs. It is describedin chapter 3.
A one-pass assembler executes an ‘ AD S5 ’ by ﬁrst placing label Ain the symbol
table (its value is the usual LC)and then incrementing the LC by 5. Since the one-pass assembler loads the instructions directly in memory, this skips 5 locations,which then become the array.
A two-pass assembler executes the DSin both passes. In pass 1 it places Ain
the symbol table and increments the LC by 5. In pass 2 it has to actually reservethe 5 locations. Your assembler should do it by placing 5 records with zeros in theobject ﬁle.
/
Exercise 1.23 How would the assembler execute an ‘ A DS 5000 ’?
c. The general format of the DCdirective is:
labelDCconstant
where you can limit yourself to non-negative integer constants. Executing this
directive is similar to a DS. In pass 1, the assembler calculates the size of the constant
(in your case, always 1 word), and increments the LC by that size. In pass 2, it writesthe constant on the object ﬁle, with a relocation bit of 0 (absolute). Assemblersnormally allow more than one constant in the DC, and the general format of this
directive is explained in chapter 3.
The two-pass version should now identify each record on the object ﬁle as either
an object instruction or a loader directive. This is done by adding one id bit toeach record.
1.13.3 Project 1–3
Extend project 1–2 by adding relocation bits. This can only be done for the
two-pass assembler. The relocation bit of an instruction is determined in pass 2,when the instruction is assembled. If the instruction uses a relocatable symbol, therelocation bit should be 1. If the instruction uses an absolute symbol (as, e.g., in‘EQU 7 ’)or no symbol at all, the relocation bit should be 0. Instructions without
operands should always have a relocation bit of zero.
If the assembler produces variable length instructions, they should be written
on the object ﬁle in a way that would make it easy for the loader to read andidentify the relocation bits. The choice of M=8 ,N= 8 mentioned before, for
instance, has resulted in instructions being either 8- or 16-bits long. A reasonabledesign of the object ﬁle in such a case is to write the instructions as 10-bit records,where the ﬁrst 8 bits are the instruction (or part of it), bit 9 identiﬁes the record
54 BasicPrinciples Ch. 1
as either an instruction or a loader directive, and bit 10 is the relocation bit. A
short instruction would be written as one record with a relocation bit of 0. A longinstruction would be written as two records, the ﬁrst always having a relocation bitof 0 and the second, the proper relocation bit (the ﬁrst record contains the OpCodeand is therefore absolute). This way the loader can read a record (either a shortinstruction or half of a long one), relocate it if necessary, and immediately load itin memory, without having to identify short and long instructions.
ADCdirective is limited, in our case, to an operand which is a non-negative
integer. Thus our DCs always generate a record with a relocation bit of 0. In general,
however, a DCmay generate relocatable constants, as in table 1–3.
LC
.
.
108A R1,...
..
DC A
Table 1–3.
TheDCgenerates the record 0...0108 01 since the value of label Ais 108
locations from the start of the program.
Notice that now we have three types of records on the object ﬁle, namely, abso-
lute instructions, relocatable instructions, and loader directives. They should eachbe identiﬁed by two bits (see also discussion of special relocation in this chapter).
1.13.4 Project 1–4
This is more than an extension of previous projects. Here we describe a more
realistic assembler that can handle more registers, more directives, and addressingmodes. It still is a very simple assembler, though. A special feature of this assembleris that it can operate as either a one-pass or a two-pass assembler. As usual, itshould read a source ﬁle with a test program, assemble it into machine code andeither load the machine code directly in memory (the one-pass version), or write iton an object ﬁle (the two-pass one). It is suggested to write the one-pass and two-pass assemblers as two separate parts of the project, sharing common procedures.Examples of common procedures are symbol table search, OpCode table search,and lexical scan of the source line.
The Hypothetical Processor
It has sixteen 16-bit registers, two status ﬂags Z,N, and can handle up to 64k
addresses (a choice of M= 16). All instructions have the following format:
OpCode
Register Mode Operand
44 2 6
Sec.1.13 Review Questionsand Projects 55
and are 16-bit long. Each instruction is loaded into one memory word, implying
a choice of N= 16. This roughly corresponds to the architecture of early third-
generation computers. The concept of a status ﬂag is explained in any book oncomputer organization and in many books on assembler language. As mentionedbefore, it is not necessary to understand status ﬂags in order to implement theassembler.
The source instructions are:
Op- Mnemonic valid
Code
Operands ZNmodes Description
0LOD R,Op x x 0123 Load register R from the loc. speciﬁed by Op
1STO R,Op 012 Store R in memory
2ADD R,Op x x 0123 Add contents of memory location to register R
3COM R xx 0 Complement every bit in R
4DIV R,Op x x 0123 R←Quotient(R/Op). Integer/integer division
5JZE Op 012 Jump to address Op if Z=1
6JNE Op 012 Jump if N=1
7JMP Op 012 Unconditional jump
8PRT R,Op 012 Print R characters, starting from location Op.
9OUT Op 012 Print the operand as an integer
10HLTnone 0 Stop the processor
All other OpCodes are not implemented yet and are reserved for future use. It
is important to understand that the assembler only assembles the instructions, and
does not execute them. Therefore the decription of the instructions in not important.
Omitting that column from the table above would not make it impossible (or evenharder)to implement the assembler. An assembler generally does not know whatthe instructions do, what the addressing modes mean, and when and how the statusﬂags are used. These are all run-time features, handled by the hardware.
The modes:
0 - Direct, 1 - Relative. 2 - Indirect. 3 - Immediate. They are special cases
of the modes explained in appendix A. Note that certain instructions can only usecertain modes. An error should be detected (and handled as shown below)if suchan instruction tries to use an invalid mode. Also note that mode 1 can generate,when the instruction is executed, addresses >64k. Those are illegal addresses on
our machine, but can only be detected at run time, so you don’t have to worryabout them.
The indirect & immediate modes are explicitly selected by the programmer. If
a mode is not speciﬁed, the assembler should try the direct mode (as on lines 50,52 in the example below). Since the Op ﬁeld is six bits, a direct address must ﬁtin six bits and is therefore limited to the range 0–63. If the direct mode cannot beused (the Op is >63), the assembler should try the relative mode (as on line 55).
If that mode cannot be used either, the assembler should issue an error, assemblethe line as all zeros, and set a ﬂag that will prevent execution of the program.
/
Exercise 1.24 In what cases is the relative mode invalid?
56 BasicPrinciples Ch. 1
The Directives
1.PASSnwhere nis either 1 or 2. This should always be the ﬁrst line and it
speciﬁes the number of passes.
2.ORGnwhere nis a non-negative integer. This diredctive resets the LC to n.
It is executed in pass 1 and only aﬀects the LC.
3. labelEQUnwhere nis as above. This directive places the label in the symbol
table with a value nand a type of abs. It is executed in pass 1 and only aﬀects the
symbol table.
4.DCminitializes the current location to m, where mis a number as abve or
a string of up to three characters.
5.ENDnindicates the end of the source program. Here nis a symbol and, if
present, it indicates the address of the ﬁrst executable instruction.
see chapter 3 for more information on those directives.
The Object ﬁle
Should contain the machine instructions (absolute and relative), and loader
directives. Each item should be identiﬁed by one bit as either an instruction, dataor a loader directive. There are no relocation bits. Design your own format anddocument your design.
The loader directives are generated by the assembler in response to the ORG,
ENDdirectives.
An example test program
Such a program does not have to be meaningful but, in our case, it is. It
calculates the expression [ −(A+B)+C]/D=[−( 2+2 )+8 ] /2 = 2 and stores it in
registerR1.
address
source code RMOp
49GD C 2 2
50 LOD R1,A 0 1061
51 ADD R1,@B 2 1262
52 COM R1 3 1000
53 ADD R1,#1 2 1301
54 ADD R1,C 2 1063
55 DIV R1,D 4 1109
56 JZE N 5 0059
57 PRT 3,E 8 3108
58 HLT 10 0000
59N PRT 2,F 8 3109address source code RMOp
60 HLT 10 0000
61AC D 2 2
62BD C G 49
63CD C 8 8
64DD C 2 2
65E DC ‘YES’ 89 ASCII
66 6967 8368F DC ‘NO’ 78
69 79
END
Notice that the program starts at address 49 but the ﬁrst executable instruction
is at address 50. The program is loaded in memory locations 49–70 so it wouldstraddle address 63. This is done in order to illustrate both the direct and relativemodes.
Sec.1.13 Review Questionsand Projects 57
General Notes
1. Pass 1 is especially simple since all the instructions have the same size.
You will also ﬁnd that the intermediate ﬁle contains a copy of the source andalmost nothing else. To make this project more interesting, you should redesign theinstruction set to have a few long instructions. Perhaps all the instructions with anOp ﬁeld should be 32 bits long.
2. Notice that the Op ﬁeld is only 6 bits wide. In a one-pass assembler, this
may make it impossible to store a pointer in this ﬁeld and you may have to resortto storing all the unresolved references of each future symbol, in a linked list, asdescribed earlier in this chapter.
The shortage of a single kind of bolt would hold up the entire assembly ...
—Henry Ford, Today and Tomorrow (1926)
2. The Symbol Table
The organization of the symbol table is the key to fast assembly. Even when
working on a small program, the assembler may use the symbol table hundredsof times and, consequently, an eﬃcient implementation of the table can cut theassembly time signiﬁcantly even for short programs.
/The symbol table is a dynamic structure. It starts empty and should support
two operations, insertion and search. In a two-pass assembler, insertions are doneonly in the ﬁrst pass and searches, only in the second. In a one-pass assembler,both insertions and searches occur in the single pass. The symbol table does nothave to support deletions, and this fact aﬀects the choice of data structure forimplementing the table. A symbol table can be implemented in many diﬀerentways but the following methods are almost always used, and will be discussed here:
A linear array.
A sorted array with binary search.
Buckets with linked lists.
A binary search tree.
A hash table.
60 The SymbolTable Ch. 2
2.1 A Linear Array
The symbols are stored in the ﬁrst Nconsecutive entries of an array, and a
new symbol is inserted into the table by storing it in the ﬁrst available entry (entryN+ 1) of the array. A typical Pascal code for such an array would be:
var
symtab: record
N: 0..lim;tabl: array
[0..lim] of record
name: string;valu: integer;type: char;
end
;
end;
Wherelimis some suitable constant. The variable Nis initially set to zero, and it
always points to the last entry in the array. An insertion is done by:
Testing to make sure that N<lim (the symbol table is not full). Incrementing
Nby 1. Inserting the name, value, and type into the three ﬁelds, using Nas an
index.
The insertion takes ﬁxed time, independent of the number of symbols in the table.
To search, the array of names is scanned entry by entry. The number of steps
involved varies from a minimum of 1 to a maximum of N. Every search for a non-
existent symbol involves Nsteps, thus a program with many undeﬁned symbols
will be slow to assemble because the average search time will be high. Assuming aprogram with only a few undeﬁned symbols, the average search time is N/2. In a
two-pass assembler, insertions are only done in the ﬁrst pass so, at the end of thatpass, Nis ﬁxed. All searches in the second pass are performed in a ﬁxed table.
In a one-pass assembler, Ngrows during the pass, and thus each search takes an
average of N/2 steps, but the values of Nare diﬀerent.
Advantages: Fast insertion. Simple operations.
Disadvantages: Slow search, specially for large values of N. Fixed size.
2.2 A Sorted Array
The same as a linear array, but the array (actually, the three arrays) is sorted,
by name, after the ﬁrst pass is completed. This, of course, can only be done in atwo-pass assembler. To ﬁnd a symbol in such a table, binary search is used, whichtakes (see, for example, reference [15]) an average of log
2Nsteps. The diﬀerence
between Nand log2Nis small when Nis small but, for large values of N, the
diﬀerence can get large enough to justify the additional time spent on sorting thetable.
Advantages: Fast insertion and fast search. Since the table is already sorted, the
preparation of a cross-reference listing (see chapter 5) is simpliﬁed.
Disadvantages: The sort takes time, which makes this method useful only for a
large number of symbols (at least a few hundred).
Sec.2.3 Buckets with Linked Lists 61
2.3 Buckets with Linked Lists
An array of 26 entries is declared, to serve as the start of the buckets. Each
entry points to a bucket that is a linked list of all those symbols that start withthe same letter. Thus all the symbols that start with a ‘ C’ are linked together in
a list that can be reached by following the pointer in the third entry of the array.Initially all the buckets are empty (all pointers in the array are null). As symbolsare inserted, each bucket is kept sorted by symbol name. Notice that there is noneed to actually sort the buckets. The buckets are kept in sorted order by carefullyinserting each new symbol into its proper place in the bucket. When a new symbolis presented, to be inserted in a bucket, the bucket is ﬁrst located by using the ﬁrstcharacter in the symbol’s name (one step). The symbol is then compared to theﬁrst symbol in the bucket (the symbol names are compared). If the new symbolis less (in lexicographic order) than the ﬁrst, the new one becomes the ﬁrst inthe bucket. Otherwise, the new symbol is compared to the second symbol in thebucket, and so on. Assuming an even distribution of names over the alphabet, eachbucket contains an average of N/26 symbols, and the average insertion time is thus
1+(N/26)/2=1+ N/52. For a typical program with a few hundred symbols, the
average insertion requires just a few steps.
A search is done by ﬁrst locating the bucket (one step), and then performing
the same comparisons as in the insertion process above. The average search thusalso takes 1 + N/52 steps.
Such a symbol table has a variable size. More nodes can be allocated and added
to the buckets, and the table can, in principle, use the entire available memory.
Advantages: Fast operations. Flexible table size.
Disadvantages: Although the number of steps is small, each step involves the use
of a pointer and is therefore slower than a step in the previous methods (that usearrays). Also, some programmers always tend to assign names that start with an A.
In such a case all the symbols will go into the ﬁrst bucket, and the table will behaveessentially as a linear array.
Such an implementation is recommended only if the assembler is designed to
assemble large programs, and the operating system makes it convenient to allocatestorage for list nodes.
/
Exercise 2.1 What if symbol names can start with a character other than a letter?
Can this data structure still be used? If yes, how?
BGH
A345 J12
CC MED
ZIPTOM
QUE
PETSON62 The SymbolTable Ch. 2
2.4 A Binary Search Tree
This is a general data structure used not just for symbol tables, and is quite
eﬃcient. It can be used by either a one pass or two pass assembler with the sameeﬃciency.
The table starts as an empty binary tree, and the ﬁrst symbol inserted into
the table becomes the root of the tree. Every subsequent symbol is inserted intothe table by (lexicographically) comparing it with the root. If the new symbol isless than the root, the program moves to the left son of the root and compares thenew symbol with that son. If the new symbol is greater than the root, the programmoves to the right son of the root and compares as above. If the new symbol turnsout to be equal to any of the existing tree nodes, then it is a doubly-deﬁned symbol.Otherwise, the comparisons continue until a node is reached that does not have ason. The new symbol becomes the (left or right) son of that node.
Example: Assuming that the following symbols are deﬁned, in this order, in
a program.
BGH J12 MED CC ON TOM A345 ZIP QUE PETS
SymbolBGHbecomes the root of the tree, and the ﬁnal binary search tree is
shown in Fig. 2–1.
Figure 2–1. A Binary Search Tree
Sec.2.4 A Binary SearchTree 63
Reference [15] is a good source for binary search trees and it also discusses the
average times for insertion, search, and deletion (which, in the case of a symboltable, is unnecessary). The minimum number of steps for insertion or search isobviously 1. The maximum number of steps depends on the height of the tree. Thetree in Fig. 2–1 above has a height of 7, so the next insertion will require from 1to 7 steps. The height of a binary tree with Nnodes varies between log
2N(which
is the height of a fully balanced tree), and N(the height of a skewed tree). It can
be proved that an average binary tree is closer to a balanced tree than to a skewedtree, and this implies that the average time for insertion or search in a binary searchtree is of the order of log
2N.
Advantages: Eﬃcient operation (as measured by the average number of steps).
Flexible size.
Disadvantages: Each step is more complex than in an array-based symbol table.
The recommendations for use are the same as for the previous method.
2.5 A Hash Table
This method comes in two varieties, open hash, which uses pointers and has
a variable size, and closed hash, which is a ﬁxed-size array.
2.5.1 Closed hashing
A closed hash table is an array (actually three arrays, for the name,value, and
type), normally of size 2N, where each symbol is stored in an entry. To insert a
new symbol, it is necessary to obtain an index to the entry where the symbol willbe stored. This is done by performing an operation on the name of the symbol, anoperation that results in an N-bit number. An N-bit number has a value between
0 and 2
N−1 and can thus serve as an index to the array. The operation is called
hashing and is done by hashing, or scrambling, the bits that constitute the nameof the symbol. For example, consider 6-character names, such as abcdef . Each
character is stored in memory as an 8-bit ASCII code. The name is divided intothree groups of two characters (16-bits) each, ab cd ef . The three groups are
added, producing an 18-bit sum. The sum is split into two 9-bit halves whichare then multiplied to give an 18-bit product. Finally Nbits are extracted from
the middle of the product to serve as the hash index. The hashing operations aremeaningless since they operate on codes of characters, not on numbers. However,they produce an N-bit number that depends on all the bits of the original name.
A good hash function should have the following two properties:
It should consider all the bits in the original name. Thus when two names that are
slightly diﬀerent are hashed, there should be a good chance of producing diﬀerenthash indexes.
For a group of names that are uniformly distributed over the alphabet, the func-
tion should produce indexes uniformly distributed over the range 0 ...2N−1.
Once the hash index is produced, it is used to insert the symbol into the array.
Searching for symbols is done in an identical way. The given name is hashed, andthe hashed index is used to retrieve the value and the type from the array.
64 The SymbolTable Ch. 2
Ideally, a hash table requires ﬁxed time for insert and search, and can be
an excellent choice for a large symbol table. There are, however, two problemsassociated with this method namely, collisions and overﬂow, that make hash tablesless than ideal.
Collisions involve the case where two entirely diﬀerent symbol names are hashed
into identical indexes. Names such as SYMBandZWYG6 can be hashed into the same
value, say, 54. If SYMB is encountered ﬁrst in the program, it will be inserted
into entry 54 of the hash table. When ZWYG6 is found, it will be hashed, and
the assembler should discover that entry 54 is already taken. The collision problemcannot be avoided just by designing a better hash function. The problem stems fromthe fact that the set of all possible symbols is very large, but any given programuses a small part of it. Typically, symbol names start with a letter, and consist ofletters and digits only. If such a name is limited to six characters, then there are26×36
5(≈1.572 billion) possible names. A typical program rarely contains more
than, say, 500 names, and a hash table of size 512 (= 29) may be suﬃcient. When
1.572 billion names are mapped into 512 positions, more than 3 million names willmap into each position. Thus even the best hash function will generate the sameindex for many diﬀerent names, and a good solution to the collision problem is thekey to an eﬃcient hash table.
The simplest solution involves a linear search. All entries in the symbol table
are originally marked as vacant. When the symbol SYMBis inserted into entry 54,
that entry is marked occupied. If symbol ZWYG6 should be inserted into entry 54
and that entry is occupied, the assembler tries entries 55, 56 and so on. This impliesthat, in the case of a collision, the hash table degrades to a linear table.
Another solution involves trying entry 54 + Pwhere Pand the table size are
relative primes. In either case, the assembler tries until a vacant entry is found oruntil the entire table is searched and found to be all occupied.
Morris [16] presents a complete analysis of hash tables, where it is shown that
the average number of steps to insert (or search for a) symbol is 1 /(1−p) where p
is the percent-full of the table. p= 0 corresponds to an empty table, p=0.5 means
a half-full table, etc. The following table gives the average number of steps for afew values of p.
number
p
of steps
01.4 1.66.5 2.6 2.5.7 3.33.8 5.9 10.95 20
Sec.2.5 A HashTable 65
It is clear that when the hash table gets more than 50%–60% full, performance
suﬀers, no matter how good the hashing function is. Thus a good hash table designmakes sure that the table never gets more than 60% occupied. At that point thetable is considered overﬂowed.
The problem of hash table overﬂow can be handled in a number of ways. Tradi-
tionally, a new, larger table is opened and the original table is moved to the new oneby rehashing each element. The space taken by the original table is then released.Hopgood [17] is a good analysis of this method. A better solution, though, is to useopen hashing.
2.5.2 Open hashing
An open hash table is a structure consisting of buckets, each of which is the
start of a linked list of symbols. It is very similar to the buckets with linked listsdiscussed above. The principle of open hashing is to hash the name of the symboland use the hash index to select a bucket. This is better than using the ﬁrstcharacter in the name, since a good hash function can evenly distribute the namesover the buckets, even in cases where many symbols start with the same letter. Ahoet al. [18] presents an analysis of open hashing.
66 The SymbolTable Ch. 2
2.6 Review Questions and Projects
1.Given a program in which the following labels, in this order, are deﬁned:
AND,ZUG,ZIP,ACT,BIG,ZAP,ACVTS,BIGGER
Insert them in buckets and show the ﬁnal result.2.Sort the above labels alphabetically and use binary search to locate label BIGGER .
Note that the number of labels is even. In such a case, how do you pick up the labelin the middle of the table?
3.Using the hash method described in this chapter, hash symbol BIGGER . Assuming
a hash table of size 512, what index is produced?
4.Tree implementations typically use pointers, but there is a way to implement
a binary tree in an array without using any pointers, not even indexes to arrayelements. This method is ideally suited to a complete binary tree (one where everynode, except the leaves, has two sons) but can be used, with less eﬃciency, for anybinary tree, including a binary search tree. Study the method in any textbook ondata structures, and apply it to the tree of ﬁgure 2–1.
5.Review the methods described in this chapter for symbol table implementation.
For each method, decide whether the method is better suited for a one-pass or atwo-pass assembler, or whether it is equally suited for both. State your reasons.
6.A two-pass assembler stores symbols in the symbol table in pass 1 and searches
the table in pass 2. In between the passes it may sort the table. However, theassembler sometimes has to search the table even in pass 1, such as for an A EQU
Bdirective. How does each of the methods described in this chapter lend itself to
this feature?
2.6.1 Project 2–1
Implement a linear array symbol table and a sorted array symbol table. Use
them in one of the assemblers implemented in the chapter 1 projects. Prepare severaltest programs, each with successively more labels deﬁned and more symbols used.Assemble each test program twice, using the two symbol table implementationsabove, and measure the time it takes to assemble each test program. If the computerdoes not have an internal clock, use your watch. The aim is to ﬁnd the point wherethe sorted symbol table becomes faster than the linear one. At how many symbolsdoes it occur in your case?
2.6.2 Project 2–2
A sorted symbol table can be implemented in two ways. It can be sorted at
the end of pass 1 or it can be kept in sorted order during pass 1, while new symbolsare entered. Compare the two methods by a simulation, as in project 2–1.
Sec.2.6 Review Questionsand Projects 67
2.6.3 Project 2–3
Implement, test, and compare the following four hashing algorithms:
1. Split the symbol name into groups of two characters each. Add all the groups.
Divide the sum by the table size. The hash index is the remainder of thedivision.
2. Split the symbol name into two groups, as equal in size as possible. Add the
two groups. Square the sum. Use the center 16-bit part of the result, anddivide it by the table size. Again, the hash index is the remainder.
3. Split the symbol name into two groups as before. Perform the Exclusive-Or
of the two groups. The hash index is a chunk of size log
2[the table size] taken
from the center of the result.
4. Convert the symbol name into groups of four bits each. Each character of the
name is split into two such groups. Convert each four-bit group into a decimaldigit according to the rule: If the group is ≤9, leave it alone; otherwise, mask
oﬀ the lefmost bit. Thus the character 11010110 is split into 1101, 0110 andthe ﬁrst group (whose value is 13) is converted into 0101 (=5). The result is56.
Each character results in two decimal digits. Concatenate all the left decimal
digits to form one decimal number, and all the right decimal digits, to form anothernumber. The two decimal numbers should be added, the result reversed (e.g. 12345becomes 54321), and divided by the table size. The hash index is the remainder,after being converted back into binary.
To test and compare the four methods, prepare a list of names whose size is
60%–70% of the hash table size. Apply each method to the list. Measure the timeit takes to insert all names in the hash table, and also measure quantities such asthe average number of steps for an insert, and the distribution of hash indexes.
In a symbol there is concealment and yet revelation
—Thomas Carlyle
An idea, in the highest sense of that word, cannot be conveyed but by a
symbol
—Samuel Taylor Coleridge
3. Directives
3.1 Introduction
In addition to assembling instructions, the assembler oﬀers help to the pro-
grammer in the form of directives. The directives are commands to the assembler,directing it to perform operations other than assembling instructions. The direc-tives are thus executed by the assembler, not assembled by it. They may aﬀect all
the operations of the assembler. Directives may aﬀect the object code, the symboltable, the listing ﬁle, and the values of internal assembler parameters. Certain di-rectives are executed in pass 1 and others, in pass 2. Many directives are executedin both passes. Directives that have to do with macros and conditional assemblyare normally executed in a special pass, pass 0. Regardless of when a directive isexecuted, it must be passed over to pass 2, to be included in the listing ﬁle.
Some directives are passed by the assembler to the loader, through the object
ﬁle. They are eventually executed by the loader. Other directives are used asprogramming tools, to simplify the process of writing the program and preparingthe source ﬁle.
Simple assemblers may support only a few directives, while large, modern as-
semblers may support about a hundred. Perhaps the fastest way for the assemblerto identify each directive, is to include all the directives in the OpCode table. Thetable should, in such a case, contain more information, identifying each item aseither a machine instruction or a directive. The table should also specify the pass
yesyesread line 
from source file
no
no1
1write source line & other
info on intermediate fileLC:=LC+sizedetermine size
of instructionstore name
 & value in 
symbol tablelabel
defined
?directive
?
pass 2close source file
rewind intermediate 
filepass 1
generate END
record on inter-
mediate file
END
?
a
pass 1
directive?
execute it
generate a
record on
interme-
diate file
1yes
no
yesno70 Directives Ch. 3
(0,1 or 2) in which the directive should be executed, and should contain the start
address of the routine that executes the directive. If a directive is executed in bothpasses, the table should include two such addresses.
/
Exercise 3.1 Some assemblers require each directive to start with a period ‘.’, for
easy identiﬁcation. Why isn’t such a convention adopted by every assembler?
Figure 3–1 is a generalization of ﬁgure 1–2, that includes directives.
Figure 3–1a. A Two-Pass Assembler with Directives (part 1).
yes
nopass 2
2
2write source & object
lines onto listing filewrite object instruction
onto object fileassemble
instructionEND
?stopread next line from
 intermediate file
directive
?a
pass 2
directive
?
execute ityesyes
nonoSec.3.1 Introduction 71
Figure 3–1b. A Two-Pass Assembler with Directives (part 2).
The directives listed below are classiﬁed by function and, within each function
group, they are listed alphabetically (except when certain directives are needed toexplain others). For each directive, the general format is shown, followed by a shortdescription and by the way it is executed by the assembler (its implementation).An important point to keep in mind about directive execution is that all directivesthat aﬀect the LC must be executed in pass 1. In general, a pass 1 directive is anydirective that aﬀects the layout of the program (as a result, it must—directly or
72 Directives Ch. 3
indirectly—aﬀect the LC).
/Note that the names of directives are determined by the assembler writer and,
as a result, the same directive may have diﬀerent names in diﬀerent assemblers. Inseveral cases, two or three names are mentioned for the same directive.
This chapter lists many directives used by many assemblers. Most are rarely
used and are only supported by a few assemblers. Some directives, however, arecommonly used and are widely supported; those are identiﬁed below by an asterisk.The following is a list of the directives described here, classiﬁed by function.
Program Identiﬁcation ( IDENT ).
Source Program Control (* END,ICTL,INCLUDE ,PUNCH ,REPRO ).
Machine Identiﬁcation ( MACHINE ,p286,PPU).
Loader Control ( LCC).
Mode Control ( ABS,BASE,CODE,QUAL,COL).
Block Control & Location Counter Manipulation ( BEGIN ,COMM,*DS,‘=’,EVEN,
LIMIT ,ODD,ORG,OVERLAY ,POS,USE,‘*’).
Segment Control ( SEGMENT ,ASSUME ,GROUP ).
Symbol Deﬁnition (* EQU,MAX,MIN,MICCNT ,SET).
Base Register Deﬁnition ( USING ,DROP).
Subprogram Linkage ( CSECT ,*ENTRY ,*EXTRN ).
Data Generation ( ASCII ,ASCIIZ ,BSSZ,CON,*DATA,DEC,DEF,DIS,LIT,LITORG ,
PACKED ,RECORD ,STRUC ,VFD).
Macro (* ENDM,IRP,*MACRO ,REMOVE ,SYSLIST ,SYSNDX ).
Conditional Assembly ( AGO,AIF,ANOP,ELSE,ENDIF ,GBLx,IF-ELSE-ENDIF ,IFF,
IFT,IIF,LCLx,SET).
Micro (DECMIC ,MICRO ,OCTMIC ).
Error Control ( ERR,ERRxx).
Listing Control ( EJECT ,*LIST,PDC,SBTTL ,SPACE ,TITLE ,XREF,%OUT).
Remote Assembly ( HERE,RMT).
Code Duplication ( DUP,ECHO,ENDD,STOPDUP ).
Operation Deﬁnition ( OPDEF ,PURGDEF ).
OpCode Table Management ( OPSYN ).
Every assembler manual should describe all the directives supported by the
assembler. References [26, 27, 30, 32, 37, 99, 100, 102, 103] are typical examples oflarge, sophisticated assemblers supporting many directives.
Sec.3.2 Program IdentiﬁcationDirectives 73
3.2 Program Identiﬁcation Directives
(IDENT )
1.IDENT
Label Operation Operand
none IDENT name,origin
The name in the operand ﬁeld becomes the name of the program. This direc-
tive is for the beneﬁt of the loader, which uses the program name to identify theindividual programs loaded, and to print a memory map. This directive is normallynot required and many assemblers do not even support it. Some assemblers use theTITLE directive for this purpose. To execute it, the assembler writes the name on
the object ﬁle together with a special code (a loader directive) that tells the loaderwhat it is. chapter 7 contains examples of loader directives and memory maps. The‘origin’ ﬁeld, if used, indicates the start address of the program. It is only used forabsolute assembly.
A few words about loader directives are in order. The relocatable object ﬁle
contains machine instructions (each with its relocation bit) and should also containloader directives. Both machine instructions and loader directives are written asbinary numbers on the object ﬁle and should be explicitly distinguished. The as-sembler does this by adding one more bit to the relocation bit. With two such bits(identifying bits), the assembler can identify a record on the object ﬁle as one offour diﬀerent types. So far we have seen three types, machine instructions (absoluteand relative), and loader directives. The fourth type is machine instructions thatrequire special relocation. They are discussed later in this chapter, in the sectionon theENTRY ,EXTRN directives.
Throughout this book we will assume that the identiﬁcation bits have the
following meaning:
00—an absolute machine instruction.01—a relative machine instruction.10—a machine instruction that needs special relocation.11—a loader directive.See chapter 7 about speciﬁc loader directives.
74 Directives Ch. 3
3.3 Source Program Control Directives
(*END,ICTL,INCLUDE ,PUNCH ,REPRO ).
2.END
Label Operation Operand
none ENDaddress expression
Indicates to the assembler the end of the source program. Upon reading the
ENDfrom the source ﬁle, the assembler stops reading and completes assembling the
program. Certain assemblers allow the source ﬁle to have more than one program,each having its own END, to indicate separate assembly. In such a case, the assembler
completes one assembly and then tries to read beyond the ENDto see if there is
another program on the same source ﬁle.
The expression in the operand ﬁeld indicates the address of the ﬁrst executable
instruction. It is thus possible to start the source program with some data items orwith a procedure, and follow them by the main program. In such a case the ﬁrstsource line is not the ﬁrst executable instruction. The assembler does not knowwhere execution should start and, if it should start at any point other than thebeginning, that point should be speciﬁed in the operand ﬁeld of the END.
Example:
label
mnemonic operand comment
SUB LOAD A,R1 Program starts with a procedure
.RET End of procedure
DATA 1,2,3 Some data items
STRT CLR R2 First executable instruction
..END STRT Indicates where to start execution
3.ICTL
Label
Operation Operand
none ICTL b,e,c
TheICTL directive was used in punched card-based assemblers. It speciﬁes
card columns for the beginning band end eof the instructions punched on the card,
and for the start cof instructions on continuation cards.
Example: ICTL 25,,26 speciﬁes that instructions start on column 25 and contin-
uation cards start on column 26. Since no value is speciﬁed for e, the default value
of 71 is assumed.
Sec.3.3 SourceProgram ControlDirectives 75
When a source line is too long to ﬁt on one card, a continuation is indicated by
punching something on the column following the end column (usually column 72).The next card is then assumed to be a continuation card.
/
Exercise 3.2 How should the assembler test the values of b,e,cfor validity?
4.INCLUDE
Label
Operation Operand
none INCLUDE ﬁlename
When the INCLUDE directive is encountered, the assembler opens the ﬁle spec-
iﬁed in the INCLUDE and uses it as a source ﬁle. When that ﬁle is fully read, the
assembler returns to the original source ﬁle. The new source ﬁle may itself includeanINCLUDE directive, that will direct the assembler to start reading a third source
ﬁle.
Note. A similar loader directive is mentioned in chapter 7. It it used to explicitly
include an object ﬁle in the load.
5.PUNCH
Label
Operation Operand
optional PUNCH string
The string in the operand ﬁeld is punched on a card. The PUNCH directive has
no other eﬀect on the assembly.
6.REPRO
Label Operation Operand
none REPRO address
The next source line is punched on a card. There is no eﬀect on the assembly.
/
Exercise 3.3 If it does not aﬀect the assembly, what is this directives used for?
76 Directives Ch. 3
3.4 Machine Identiﬁcation Directives
(MACHINE ,p286,PPU)
7.MACHINE
Label Operation Operand
none MACHINE processor code
This directive is used by assemblers that serve a family of computers, such as the
CDC 6000 series, 7000 series, & Cyber series computers. The diﬀerent computersin such a family are upper compatible, but not identical. Some of them supportinstructions and hardware features that others do not. The processor code tellsthe assembler on what machine the program is supposed to run and the assembler,based on this information, can detect errors in the source code that stem from smallincompatibilities berween diﬀerent machines in the same family.
8.p286
Label
Operation Operand
none p286 none
The 80x86 is a family of microprocessors that are diﬀerent but are upper com-
patible. A program intended for the 80286 microprocessor must use this directive,so that the assembler can generate instructions speciﬁc to that machine. There arealsop186and similar directives.
9.PPU
Label
Operation Operand
none PPU string
This directive is speciﬁc to the Cyber 70/76 or CDC 7600. Those machine have
one CP (Central Processor) and several PPUs (Peripheral Processing Units). TheCP and the PPUs have diﬀerent architectures and, as a result, diﬀerent assemblerlanguages. The same assembler, however, can handle programs in either language.The directive declares the program as a PPU, rather than as a CP, program. Thestring operand has to do with the way certain PPU instructions are assembled [30].
Sec.3.4 MachineIdenti ﬁcationDirectives 77
3.5 Loader Control Directives
(LCC)
10.LCC
Label Operation Operand
none LCC loader directive
The loader directive in the operand ﬁeld is written on the object ﬁle. The
loader directive should be coded as a number. This directive allows the advanceduser to explicitly insert loader directives in the object ﬁle.
/
Exercise 3.4 What are examples of loader directives?
3.6Mode Control Directives
(ABS,BASE,CODE,QUAL,COL)
These directives deﬁne the operating characteristics of the assembler. They
allow the programmer to change the way the assembler generates object code ( ABS),
interprets binary data ( BASE), generates character data ( CODE), qualiﬁes symbols
(QUAL), and determines the beginning of comments ( COL)
11.ABS
Label Operation Operand
none ABS none
Directs the assembler to generate an absolute object ﬁle, rather than a relocat-
able one.
12.BASE
Label Operation Operand
none BASE or RADIX number base
The number base operand can be 2, 8, 10, 16, or B, O, D, H, and it determines
the number base (or radix) of all constants used from that point until the next BASE
directive.Thus
BASE 8
..DATA 56 the constant will be interpreted as 56
8
DATA 80 this would be ﬂagged as an error since 8 is invalid as an octal digit
/
Exercise 3.5 In what pass is BASEexecuted, and how?
78 Directives Ch. 3
13.CODE
Label Operation Operand
none CODE char
Computers use diﬀerent character codes, such as the ASCII and EBCDIC. If
the assembler supports more than one code, this directive tells it what code to usefor the current assembly. The operand can be a single letter code such as A (forASCII), E (for EBCDIC), D (for Display, the CDC 6-bit code) or anything else.
14.QUAL
Label
Operation Operand
none QUAL qualiﬁer or blank
A symbol can be qualiﬁed (local) or unqualiﬁed (global). If the assembler
supports this feature then symbols with the same name can be used in diﬀerentprocedures without conﬂict. A qualiﬁed symbol is referred to by writing / quali-
ﬁer/symbol . See table 3–1 for an example. Note, in the table, how a blank space in
the operand ﬁeld stops qualifying. All symbols deﬁned from that point are global.
QUAL PROC1 all symbols deﬁned from this point are
. qualiﬁed by /PROC1/
.
ABC ... the full name is /PROC1/ABC
..
QUAL PROC2 symbols deﬁned from here are qualiﬁed by /PROC2/
..
ABC ... the full name is /PROC2/ABC
..
JMP /PROC2/ABC jumps to the second deﬁnition of ABC
Table 3–1. Qualiﬁed Symbols.
15.COL
Label
Operation Operand
none COL column number
A source line with a comment but without an operand ﬁeld may present a
problem to the assembler. Consider the line ABC HLT 2 TIMES . On many com-
Sec.3.6 ModeControlDirectives 79
puters, the HLTinstruction may be written with or without an operand, and the
assembler has to determine whether the 2is an operand or part of the comment.
Most assemblers require a special character, such as a semicolon, to precede a com-ment. Some old, punched card based assemblers, consider a certain column as thebeginning of comments. The COLdirective can alter that column. Thus COL 40
means that anything on column 40 or after is a comment.
3.7 Block Control & LC Directives
(BEGIN ,COMM,*DS,‘=’,EVEN,LIMIT ,ODD,ORG,OVERLAY ,POS,USE,‘*’)
These directives aﬀect the layout of the program and must, therefore, be exe-
cuted in pass 1.
16.BEGIN
Label Operation Operand
none BEGIN Op1,Op2
Where Op1 is a location counter name, and Op2 is a start value for that location
counter.
Some assemblers can use several location counters to assemble one program
(see example below). The diﬀerent location counters are assigned names, can beinitialized by the programmer to any values, and can be used in any order. Thedefault location counter (the one used in the absence of any BEGIN ) is called ‘blank’
and is initialized to zero. This directive causes the assembler to start using thelocation counter named in Op1, and initializes that location counter to the value ofOp2. The directive may appear anywhere in the program and is used to separatethe program into parts that are written in a certain order and are eventually loadedin memory in a diﬀerent order.
If the ﬁrst line of the program is not a BEGIN , the assembler generates a
‘BEGIN ,0 ’ as the ﬁrst line. Such a program starts by using the blank location
counter, which is initialized to zero (but see also the discussion of ORG).
17.COMM
Label
Operation Operand
name COMM expr
This directive declares the name to be that of an array of size expr. The
array will later be located in blank common. This is handy for compatibility withFortran and other languages that use COMMON . The actual storage space is allocated
by the loader, and the directive is executed by the assembler by generating a loaderdirective and placing it in the object ﬁle.
80 Directives Ch. 3
18.DS
Label Operation Operand
optional DS an expression
TheDS(Deﬁne Storage) directive reserves a number of storage locations to be
used later, as an array. The reserved locations are not preloaded with any value.This directive has the same eﬀect as the DIMENSION statement in Fortran or the
array declaration in Pascal.
Example:
AB DS 5
CD DS N N must be a predeﬁned symbol
EF DS N ×NStorage for N×Nwords, reserved as a linear array
To execute the DS, the assembler evaluates the expression in the operand ﬁeld
(the array size) and increments the LC by this amount. This guarantees that thenext instruction will be loaded in the word following the reserved area.
Example:
LC
15N EQU 5
15CLR R3
16BD S 3
19ADD R2,AB
20CD S N N=5
25...
The above example is easily handled by the assembler. It results, however, in
a fatal mixof instructions and data. At run time, after the computer ex ecutes theCLRinstruction, it fetches the contents of the next location and tries to execute it
as an instruction. That location, however, is the ﬁrst location of the array Band
thus contains data and not an instruction.
TheDSdirectives should therefore be concentrated at the beginning or, prefer-
ably, at the end of the program, following all executable instructions.
/
Exercise 3.6 What are some ways of mixing instructions and data?
Modern computers have a word size that’s a multiple of 8, so their assemblers
have directives such as BYTE(to reserve bytes), WORD(to reserve words), LONG(to
reserve longwords). Older assemblers use names such as BSS(Block Starting with
Symbol), or BES(Block Ending with Symbol). Those are all similar to DS.
/
Exercise 3.7 The directive ‘ B BES 5 ’ causes ﬁve words of storage to be reserved,
and assigns Ba value that is the address of the ﬁrst word following this array. Why
isn’tBassigned the address of the last word of the array, and what is the use of
BES?
Sec.3.7 Block Control& LC Directives 81
/
Exercise 3.8 The directive DS 0seems useless. Still, it has an important use on
some computers, what is it?
19.=
Label Operation Operand
* = address expr
The ‘=’ is similar to DSand is used to reserve storage. The directive ‘ *=*+7 ’
increments the LC by 7 and thus amounts to reserving 7 words of storage. In someassemblers (such as the VAX Macro assembler, see Ch. 8) this directive can be
used to modify the value of any modiﬁable symbol, but we refer to such symbols asSETsymbols and describe the SETdirective in chapter 4.
20.EVEN
Label
Operation Operand
none EVEN none
It directs the assembler to advance the LC to the next even value if it is
currently odd. This is useful on 16-bit computers with byte addressable memory,such as the PDP-11 or the M68000. On such computers, a memory word consistsof two consecutive bytes, the ﬁrst of which starts on an even address. Anything onthe source line following this directive will have a word address.
21.LIMIT
Label
Operation Operand
none LIMIT none
This is executed by generating a ‘ DS 2’ directive at the beginning of the pro-
gram. The loader then stores the upper and lower address boundaries of the programin those two locations. This is done so that the program could determine its ownboundaries in memory at run time.
22.ODD
Label
Operation Operand
none ODD none
Similar to EVENabove, only it directs the assembler to increment the LC by 1
if it is even.
23.ORG
Label Operation Operand
optional ORG expression
82 Directives Ch. 3
TheORGdirective instructs the assembler to continue the assembly from the
memory location speciﬁed by the operand. The operand must be an expressionthat can be immediately evaluated, and its value must be a valid address (i.e., itcannot be negative). Thus the operand can be a number, a known symbol, or anexpression that can be evaluated by the assembler at this point. Such an operandis called “deﬁnable.”
Example: AB ORG 100
Means—continue the assembly from location 100 and assign 100 as the value
of symbol AB.
To execute this directive, the assembler:
Evaluates the operand (pass 1).
Resets the LC to the value of the operand (pass 1).
Stores the label, if there is one, in the symbol table, with the LC as its value
(pass 1).
Prepares a loader directive on the object ﬁle (pass 2). This tells the loader where
to load subsequent instructions.
The LC points to the current address and, by resetting it, the programmer
instructs the assembler to load the instructions that follow into a diﬀerent memoryarea.
Example:
LC
Source
0000LOAD
..
0150ADD
ORG 170
0170COMP
0171SUB
..
The assembler starts at location 0. It resets the LC to 0 and the ﬁrst block of
instructions, from the LOADto theADD, will be assembled and loaded into memory
locations 0000 through 0150. The ‘ ORG 170 ’ causes the COMP instruction to be
loaded into memory location 170, followed by SUBin location 171, and so on. The
area from location 151 to location 169 remains empty and can be used to store data.There are two problems, however:
It is hard to refer to this area since it is not labeled (but see the description of
theEQUdirective for ways to label any memory location).
Sec.3.7 Block Control& LC Directives 83
At run time, the computer will execute the ADDinstruction and will then proceed
to location 0151, trying to execute its contents as an instruction. Since location0151 does not contain an instruction, an error will occur.
The precise error depends on the contents of location 0151. If it contains a bit
pattern that happens to be the code of an instruction, the computer will execute itand proceed to location 0152. If, however, location 0151 contains a bit pattern thatis not the code of any instruction, an interrupt will be generated by the hardware.Most 8-bit microprocessors, unfortunately, simply skip such invalid bit patterns,with no interrupts generated.
If theORGabove is changed to ‘ ORG 150 ’, the assembler will reset the LC to
150, with the result that the COMPinstruction will go into location 0150 (overwriting
theADD), theSUB, into location 0151, and so on. The assembler executes the ORG
without checking its operand, and it is therefore easy to make mistakes.
/
Exercise 3.9 What is a common use of ORG?
Since the assembler does not load the program into memory, it can not directly
execute the ORG. It resets the LC (in pass 1) and writes a loader directive on the
object ﬁle (in pass 2). The actual execution is done by the loader when it ﬁnds theloader directive in the object ﬁle.
24.OVERLAY
Label
Operation Operand
none OVERLAY n
Declares the following code an overlay. The overlay ends at the next OVERLAY
directive or at the end of the program. Overlays are useful when a large programhas to ﬁt in a small memory, or in a multi-user computer where many applicationprograms compete for limited memory. The program can be logically divided into amain part and a number of overlays. At run time, the main part resides in memoryand calls any overlay when needed. The overlays are loaded on top of each other(they overlay each other). Overlays are discussed in detail in chapter 7.
25.POS
Label
Operation Operand
none POS expression
In a computer with a large word size, several instructions can be packed in one
word. An assembler for such a computer uses, in addition to the LC, a positioncounter, SC. The SC tells the assembler where, in the current word, to assemblethe next instruction. If the next instruction is longer than the rest of the word,the assembler ﬁlls the current word with NOP, resets the SC to 0, and increments
the LC by 1. The next instruction thus goes into the next word. This process iscalled a forcing up of the next instruction, and it is discussed in chapter 1. The
84 Directives Ch. 3
POSdirective resets the SC to the value of the expression in the operand ﬁeld. The
expression should not be greater than the word size.
26.USE
Label Operation Operand
none USE LC name or *
This directive tells the assembler to start using the LC named in the operand.
This can be an existing LC or a new one. An asterisk in the operand means returningto the previously used LC. The special name // refers to the special LC used fortheblank common block.
Example:
LC
00USE
00A LOD ... the value of symbol A is 0 relative to the main block
02C STO ... C has a value of 2 relative to the main block
..
56ADD ...
00USE XY a new LC is initialized to 0
00DD S 1 0 symbol D has value of 0 relative to block XY
10E DC 1,2
12.
57USE * switch to the previous LC. Its current value is 57.
More information on the use of USEand on multiple LCs can be found in
chapter 1 and in references [26, 27].
‘*’ The asterisk is not a directive in the usual sense. It is not written on a separate
source line but is rather part of the operand of instructions. It stands for the LCvalue, and is very useful. A typical simple example is:
BPL *+2
ADD ...COM ...
theBPLinstruction branches to the COMinstruction. This is useful in short local
communication between instructions, but requires the programmer to know the sizeof each instruction. The example above would work if the instructions involved are1 word long each. If the ADDinstruction is two words long, the BPLwould branch
to the middle of the ADD.
Sec.3.8 SegmentControlDirectives 85
3.8 Segment Control Directives
(SEGMENT ,ASSUME ,GROUP )
The concept of a segment has originated with large operating systems running
on mainframe computers. However, with the advent of microprocesors that canaddress large memories, this concept has become useful for microcomputers. TheIntel 80x86 & 80x88 microprocessors should speciﬁcally be mentioned in connec-tion with segments. All important assemblers for these families support memorysegmentation and have many directives for that purpose.
A segment is a part of the program, a part that can have any size. The program-
mer divides the program into parts—each a main program, a procedure, a group ofprocedures, or a data block—and declares each part as a segment. The segment,therefore, is a logical part of the program. Depending on memory availability, the
loader loads each segment into a diﬀerent memory area, and the operating systemkeeps track of where each segment is located. Since segments are logical parts of aprogram, they can be shared by programs and can be given access codes. A segmentcan be deﬁned as Execute only, as Read/Write, as Read only, etc.
Segmentation on the Intel 80x86 & 80x88 is diﬀerent. It stems from the in-
ability of older microrpocessors to directly address large memories. This type ofsegmentation is described in chapter 1 (in connection with multiple location coun-ters) and in ref. [35, 38]. Many texts on operating systems (see, e.g., [41]) describesegments and segment addressability in detail.
27.SEGMENT
Label
Operation Operand
symbol SEGMENT parameters
Used to declare the start of a segment. The end of the segment is deﬁned by
anENDSdirective. Example:
MINE SEGMENT PUBLIC
DB 0
BD W 0MINE ENDS
All segments using the parameter PUBLIC and having the same name are concate-
nated into one module (see reference [35] for more information on possible param-eters).
28.ASSUME
Label
Operation Operand
none ASSUME segreg:name
When a program uses segments, every address must have two parts, a segment
address and an oﬀset within the segment. The segment address must be loaded
86 Directives Ch. 3
by the program into one of the segment registers . The oﬀset is included in the
individual instructions. Thus when an instruction is executed that uses an address,the hardware fetches the oﬀset from the instruction, adds it to the contents of oneof the segment registers, and ends up with a complete address. This process iscalled address mapping. The user is responsible for loading the start address ofeach segment into a segment register. The user then needs to tell the assemblerwhat each of the segment registers contains. This is done by the ASSUME directive.
Thus ‘ASSUME DS:MINE ’ tells the assembler that segment register DScontains the
start address of segment MINE. TheASSUME directive does not load the address into
the register—that must be done by an instruction at run time—it only tells theassembler to assume that the register has been loaded.
29.GROUP
Label
Operation Operand
optional GROUP list of segment names
This directs the assembler to group several segments into one contiguous mod-
ule.
The assembler generates a loader directive, and the actual grouping is done by
the loader.
3.9 Symbol Deﬁnition Directives
(*EQU,MAX,MIN,MICCNT ,SET,USING )
30.EQU
Label Operation Operand
symbol EQUor= expression
Where the label is mandatory and the operand is an expression that cannot
include any future symbols. The directive is executed by assigning the operand asthe value of the symbol. The symbol is stored in the symbol table with its valueand with the proper type. This is the ﬁrst example of a symbol whose value is notthe LC. The EQUdirective makes it possible to deﬁne symbols with any values and
any type, absolute or relative.
Example:
LC
AB EQU 0
CD EQU 5
0000EF ADD 1,2
GH EQU AB+1IJ EQU EF+1
Sec.3.9 SymbolDe ﬁnitionDirectives 87
will cause the following to be stored in the symbol table:
namevaluetype
AB 0 ABS
CD 5 ABSEF 0 RELGH 1 ABSIJ 1 REL
The symbol types are worth noting in this example. GHis absolute since it is
deﬁned by absolute quantities only. IJis relative since its deﬁnition contains at least
one relative quantity. See also the discussion of address expressions in chapter 1.
The diﬀerence between GHandIJis in the way they are used. GHis identical
to the number 1 and the two can be used interchangeably. Thus:
ADD R1,R2
ADD R’GH,R2
are identical instructions that add registers 1 and 2. They are assembled into
identical machine instructions and are treated by the loader identically. Symbol IJ,
however, is relative and thus stands for address 1. As a result, ‘ ADD R’IJ,R2 ’i s
wrong and would produce an assembler error message, since the assembler expectsa register number (an absolute number) at this point, but
LOAD R3,1
LOAD R3,IJ
is okay since the second operand of LOAD should be an address. Note, however,
that the two instructions are not identical. They go on the object ﬁle with diﬀerentidentiﬁcation bits.
Chapter 1 explains how the type of a symbol is used by the assembler to
generate relocation bits.
The main use of EQUis in assigning meaningful names to registers and locations
that are frequently used in the program. In the Apple II computer, for example,addresses C000andC010have a special meaning. They are the data register and
the strobe (see reference [40] p. 79) of the keyboard. The directives:
KYBD EQU $C000
STRB EQU $C010
make it easy to input from the keyboard since the programmer has to memorize
the symbols KYBD,STRBinstead of the addresses C000,C010. Notice that the ‘$’ is
used above to specify a hexadecimal constant.
/
Exercise 3.10 A 2-pass assembler can handle future symbols and an instruction
can therefore use a future symbol as an operand. This is not always true for direc-tives. The EQUdirective, for example, cannot use a future symbol. The directive
‘A EQU B+1 ’ is easy to execute if Bis previously deﬁned, but impossible if Bis a
future symbol. What’s the reason for this?
88 Directives Ch. 3
/
Exercise 3.11 Suggest a way for the assembler to eliminate this limitation such
that any source line could use future symbols.
31.MAX and MIN
Label Operation Operand
symbol MAXorMIN list of expressions
The label is mandatory and is assigned the value of the largest (smallest)
expression in the operand ﬁeld.
Example:
AB EQU 0
CD EQU 5GH EQU LQ+AB where LQ is a deﬁned symbol
NOW MAX AB,CD,GH
SymbolNOWis assigned the maximum of the three operands. These directives are
similar to EQUand are used in those rare cases where the largest (or smallest) of a
group of symbols is needed.
/
Exercise 3.12 How isMAXexecuted and in what pass?
32.MICCNT
Label
Operation Operand
symbol MICCNT micro name
The symbol is set to the number of characters in the value of the micro (micros
are discussed in a later section). What makes this directive interesting is that thesymbol can be redeﬁned. Thus:
FST MICRO 1,,*STRING* deﬁnes a 6 character micro
..
AB MICCNT FST AB is set to 6
..
SC MICRO 1,,*ALPHA* deﬁnes a 5-character micro
..
AB MICCNT SC AB is reset to 5
Sec.3.9 SymbolDe ﬁnitionDirectives 89
33.SET
Label Operation Operand
symbol SET expression
TheSETdirective is similar to the EQUdirective except that it allows a redeﬁ-
nition of the symbol. Thus the usage:
.
.
G SET 1 point 1
..
G SET 2 point 2
..
is valid. Between points 1 and 2, the value of symbol Gwill be 1. From point 2 on,
the value of Gwill be 2. The SETdirective is another example where a symbol can
be redeﬁned. The execution of the SETdirective and the reason for having such a
directive are discussed in chapter 4. Certain assemblers (see Ch. 8) use ‘=’ insteadofSET.
3.10 Base Register Deﬁnition Directives
(USING ,DROP)
TheUSING directive is used to declare the currrent base register and its value.
Base registers are used in only a few computers—most notably the IBM 360, 370series—and are explained in appendix A. The value itself is stored in the baseregister at run time by an instruction, and the assembler has no control over it.However, the assembler should know the values of all the base registers at any time.Thus the USING is more like a promise to the assembler that the right value would be
stored. The asembler uses the base register to assemble instructions and to calculatedisplacements. At any time, several registers can be declared as base registers, eachholding a diﬀerent value. When an instruction needs to use a base register, theassembler selects the base register that would result in the smallest displacement.From time to time, the programmer may decide to drop a base register and convertit back to normal use. The DROPdirective is used for that purpose.
34.USING
Label
Operation Operand
none USING name
90 Directives Ch. 3
35.DROP
Label Operation Operand
none DROP name
3.11 Subprogram Linkage Directives
(CSECT ,*ENTRY ,*EXTRN )
ENTRY & EXTRN These have to do with the separate assembly of programs. Many
times the user wants to assemble several programs separately, and then to link andexecute them as one program. This problem can be approached in three ways:
Each program must reside on a separate source ﬁle and each source ﬁle contains
just one program. Upon reading the ENDdirective, the assembler inputs the name
of the next program from the user, locates the source ﬁle, and proceeds to assembleit.
A source ﬁle may contain several programs. On reading the END, the assembler
completes the current assembly, erases the symbol table, closes the object ﬁle, andthen tries to read the same source ﬁle, to see if there is any other program toassemble.
The source ﬁle contains one program, divided into sections by means of a special
directive, such as CSECT .
In a typical assembly run, the user speciﬁes the names of all the source ﬁles,
and the assembler goes over the ﬁles, assembling all the programs on a given sourceﬁle before going to the next ﬁle. One of the programs is the main program and theother ones are procedures or coroutines. The only problem in separate assembly isthe instructions where a program calls another one.
Example:
TITLE A
..JSR Q a Jump SubRoutine instruction
..ENDTITLE B
P ADD ..
..
Q LOD ..
..END
Sec.3.11 Subprogram LinkageDirectives 91
In this example, program Acalls a procedure Qlocated in program B. Notice that
programBcontains another procedure Pand may contain any number of procedures.
The assembler cannot assemble the JSRinstruction because symbol Qis not
deﬁned in program A. The programmer, however, wants to call procedure Qfrom
program Aand to deﬁne Qin program B. Clearly, symbol Qshould be treated in a
special way in program A. It is not deﬁned in A, but it is a deﬁned symbol and it is
deﬁned outside of A. The use of symbol Qis a special case, it is not an error, and
should be specially treated by the assembler. To declare Qas a special symbol, one
that is deﬁned outside (external to) program A, theEXTRN directive should be used.
36.CSECT
Label Operation Operand
none CSECT a symbol
This directive is used on the IBM 360 computers to divide a program into parts,
to be assembled separately. Each part starts with a CSECT and ends with the next
CSECT of with the ENDdiective. The PSECT directive on the VAX is similar. It is
described in Ch. 1.
37.EXTRN
Label Operation Operand
none EXTRN list of symbols
The symbols in the operand ﬁeld are declared as external symbols, symbols
that are used in the current program but are declared elsewhere. In the exampleabove, the declaration:
EXTRN Q orEXTRN P,Q
should be added to program A, preferably at the beginning of the program. The
assembler still does not have a value for Qbut, because of the EXTRN declaration, it
treats the JSRinstruction in a special way and does not consider it an error. The
programs are separately assembled and, therefore, when the assembler assembles A,
it knows nothing about program B (it does not have a value for symbol Q). When
the assembler gets to program B, it has already forgot everything about A(it has
erased the symbol table). Thus, in principle, the assembler cannot assemble theJSRinstruction. Only the loader, while loading all the programs as one executable
module, can use values of special symbols from one program in another. Thus ourJSRinstruction presents a special case, a case that cannot be fully handled by the
assembler, and requires the help of the loader. It is interesting to note here that aone pass assembler, since it does not use a separate loader, cannot handle separatesource ﬁles and thus cannot support the EXTRN, ENTRY directives.
The assembler writes the JSRinstruction on the object ﬁle without the value of
Q, and with special identiﬁcation bits ( id) indicating that the instruction is incom-
plete, and that it is missing the value of symbol Q. The loader eventually reads the
92 Directives Ch. 3
object ﬁle, reads the JSRinstruction, recognizes the id bits, and completes the in-
struction when it ﬁnds the value of symbol Q. This process is explained in chapter 7,
and in this section we will concentrate on the execution of the EXTRN directive.
TheEXTRN speciﬁes that Qis a special symbol, a symbol deﬁned outside the
current program. The assembler stores Q in the symbol table with a special typeext, and without a value. The instruction itself is assembled, and is written on the
object ﬁle, without the value of Qin its address ﬁeld. The assembler stores a pointer
in the empty address ﬁeld, to point to the symbol table entry for Q. At the end of
pass 2, the symbol table is erased, but the special entries[ in the symbol table] arecopied by the assembler onto the object ﬁle, for later use by the loader. The objectﬁle thus contains the object code followed by the special symbol table. It will laterbe shown that there are other items in the object ﬁle. The following diagram showsthe symbol table entry (entry 5) for symbol Q.
name
value type
1. .. .. ..
2...5. Q —e xt
6. .. .. ..
TheJSRinstruction goes on the object ﬁle as the record ‘ OpCode, 5, id=10 ’.
The id indicates (to the loader) that the 5 in the address ﬁeld is not the value of asymbol but a pointer to the special-symbol table at the end of the object ﬁle. Thattable includes the entry ‘ 5 Q ext ’ among, perhaps, other ones.
After recognizing the id and ﬁnding the entry, the loader knows that the JSR
instruction needs the value of symbol Q. This value is deﬁned in program Band
should, therefore, be included in the object ﬁle generated by that program.
The id is a generalization of the concept of a relocation bit, and is discussed in
this chapter, in conjunction with the IDENT directive.
TheEXTRN directive is executed in both passes. In pass 1 the symbol is entered
into the symbol table as a special symbol of type ‘ext’. In pass 2, the objectinstruction is generated and the id bits added to it. Also, the special symbol tableis written onto the object ﬁle.
/
Exercise 3.13 What if an external symbol is used in an address expression, such
as ‘JSR Q+1 ’o r‘DC Q+1 ’?
It should be noted that Macro , the VAX assembler, treats undeﬁned symbols
as external. When an undeﬁned symbol appears in a VAX assembler program, theassembler does not issue an error. It treats the symbol as external, and the error iseventually issued by the linker (when it does not ﬁnd a corresponding entry pointin any of the object ﬁles loaded). This feature is not always desirable, and can bedisabled by the DISABLE GLOBAL directive.
Sec.3.11 Subprogram LinkageDirectives 93
38.ENTRY
Label Operation Operand
none ENTRY list of symbols
The symbols in the operand ﬁeld are deﬁned as entry points to the current
program. An entry point is a point in the program where it can be entered by a callfrom another program. In program Babove,Q(and possibly P) are entry points,
and the directive:
ENTRY Q orENTRY P,Q
should appear at the beginning of B. The assembler executes the directive by storing
the symbols in the symbol table with a type of ent. An example follows:
name
value type
1... .. rel
2... .. abs
3.P 12 ent
4... .. rel
5... .. rel
6.Q 23 ent
7...
At the end of pass 2, the symbol table is erased, but the special entries, those with
a type of extorent, go on the object ﬁle. When the loader reads the object ﬁle for
B, it ﬁnds the entry for Qand uses the value of Qto complete the JSRinstruction
from program A.
This directive is executed partly in pass 1 (setting the type in the symbol table)
and partly in pass 2 (writing the special symbol table on the object ﬁle).
3.12 Data Generation Directives
(ASCII ,ASCIIZ ,BSSZ,CON,*DATA,DEC,DEF,DIS,LIT,LITORG ,PACKED ,RECORD ,
STRUC ,VFD)
39.ASCII
Label Operation Operand
optional ASCII char string
The ASCII codes of all the characters in the string are generated and stored in
consecutive bytes in memory. If there is a label, its value is the address of the ﬁrstbyte. Example:
ASCII "HELLO THERE"
generates (in octal): 150 145 154 154 157 040 164 150 145 162 145 in 11
consecutive bytes.
94 Directives Ch. 3
40.ASCIIZ
Label Operation Operand
optional ASCIIZ char string
Same as the ASCII directive above except that the string of bytes is followed
by a zero byte. This feature is for generating strings that C programs can use.
41.BSSZ
Label Operation Operand
symbol BSSZ expression
Similar to BSSexcept the block being reserved is initialized to all zeros.
/
Exercise 3.14 Why isBSSZdescribed here and not next to BSS?
42.CON
Label Operation Operand
symbol CON expr1,expr2, ...
The expressions are evaluated and stored in consecutive words, one value per
word. This directive is similar to DATA(see below) except that expressions, rather
than constants, can be used, and each value is stored in one word.
43.DATA (or DC)
Label Operation Operand
Optional DATA or DC list of integer, real, or character constants, or symbols
TheDATAorDC(Deﬁne Code) directive preloads the constants in the operand
ﬁeld in successive memory locations. The constants can be of diﬀerent types(some assemblers support a large number of constant types, both numeric andnon-numeric) and can have diﬀerent lengths.
Example: AB DC 1,-5.3,‘DOD$’,XY The operand ﬁeld contains four constants
(notice the three separating commas) that are of diﬀerent types. The ﬁrst is theinteger 1, the second, a real number, the third, a string of length four, and thefourth, the value of symbol XY. The assembler generates the binary values of all
items and stores them in consecutive locations, updating the LC in the process.The assembler executes the DCin both passes. In pass 1 it eveluates the size of each
constant and updates the LC. In pass 2 it generates the binary constants and writesthem on the object ﬁle. Many assemblers permit expressions in a DCdirective, thus
‘DC A-1,B-C, ...’ is valid but all the symbols involved should be known at the time
theDCis encountered in pass 1. Such a DCmay include an external symbol and,
Sec.3.12 DataGenerationDirectives 95
in such a case, the assembler cannot evaluate the expression and has to generate a
modify loader directive.
If the programmer knows the sizes of the data items, they can refer to any of
the items by calculating the sizes of the preceding ones. Assuming that an integernumber occupies one word, a real, two words, and each word can contain twocharacters, the total size of the ﬁrst three items in the example above is ﬁve and thefollowing is true: The instruction ‘ LOD AB+1,R1 ’ will load the real constant −5.3,
whereas ‘ STO R1,AB+4 ’ will store register 1 in the word containing the characters
D$(thereby erasing those characters). The instruction ‘ CMP AB+5,R2 ’ will compare
the value of symbol XY(stored in location ‘ AB+5’) with the contents of register 2.
Some assemblers use DATAinstead of DCwhile others support separate direc-
tives for diﬀerent data types. OCT, DEC, BCD are a few such directives, supported
mostly by old assemblers, that preload octal, decimal, and strings in storage. Theexamples below are from the ASM 86 assembler (references [33–35])—a modern,powerful assembler for Intel 16-bit microprocessors—but are typical to data direc-tives supported by many modern assemblers.
DB (Deﬁne Byte), DW (Deﬁne Word), DD (Deﬁne Double), DQ (Deﬁne Quade,
a quade is 8 consecutive bytes or 64 bits), DT (Deﬁne Ten), ten consecutive bytes).
These directives are powerful, as the following examples illustrate:
DB 12DUP(0) 12 bytes are preloaded with zeros
DW ?,?,? 3 words are reserved but not preloaded
DW 3DUP(?) same as above
DB 2DUP(1,3DUP(2)) eight bytes are preloaded with 1,2,2,2,1,2,2,2
DQ 1.234E a 64-bit real value
DD -9.8E-34 a 32-bit real value
DB ‘HELLO’,0DH,0AH 7 bytes, the last 2 with CR ( 0D16) & LF (0A16).
44.DIS
Label
Operation Operand
symbol DIS n,string
A total of ncharacters from the string are preloaded into successive words in
memory (as many words as necessary to hold ncharacters). If nis larger than
the length of the string, the string is repeatedly loaded into memory until all n
characters have been loaded.
45.DEF
Label Operation Operand
symbol DEF m[,I]
Where mis an address (absolute or relative) and the optional I indicates in-
direct addressing. This directive is used in the HP1000 & 2100 minicomputers [79]
96 Directives Ch. 3
to generate addresses in memory to be used for indirect addressing and cascaded
indirect. The indirect mode and cascaded indirect are covered in chapter 7.
46.DEC
Label Operation Operand
symbol DEC d1[,d2,...,dn]
Generates a string of decimal constants. This directive is used on computers
that support decimal constants.
47.LIT
Label Operation Operand
none LIT list of expressions
The expressions are evaluated and their values inserted into the literal table.
This directive is normally not necessary since literals are added to the literal tablewhen they are found in the source. However, if LITis used early in the program to
load the literal table, the assembler will not load it with duplicate values. Some ex-perienced programmers like to know what their literal table contains. They initiallypreload it with all the literals they think their program is using. At the end of thesecond pass, they print the literal table and, if it contains anything not inserted bythem (through the LIT), they check for a possible error.
48.LITORG
Label
Operation Operand
none LITORG expression
Where the operand ﬁeld is an address expression. This directive explicitly
speciﬁes the beginning address of the literals block.
Examples:
‘LITORG $FF00 ’ All literals declared up to this point should be stored starting at
hexaddress FF00. This example is typical for a mini or microcomputer where the
user is responsible for part of the memory allocation and assignment of addresses.
‘LITORG * ’ All literals declared up to this point should be stored in memory
starting at this point. The asterisk is the current value of the LC. The assemblerstores all literals that have been deﬁned so far in a block starting at the currentLC value, updating the LC. The next source line will be assembled at the addressfollowing this block. This example is common on computers with explicit baseaddressing, like the IBM 360, 370.
To implement literals and the LITORG directive, a two-pass assembler uses two
tools. The intermediate ﬁle and a literal table. The intermediate ﬁle is generated
Sec.3.12 DataGenerationDirectives 97
by the ﬁrst pass and is read by the second pass. It contains a copy of the source
ﬁle plus information on literals. The literal table contains the name, value, size andother attributes of each literal used in the program.
Example:
name
value size
1000 4
13.6 8-1 4DATUM 513.60 8
Where the ‘value’ ﬁeld contains the binary values of the literals. In the ﬁrst pass,
each time a literal is found in the source program, the literal table is checked fora literal with the same name. If no such literal exists, the new literal is addedto the table, otherwise, the existing literal is used. The relative address of theliteral is then written on the intermediate ﬁle following the instruction that usesthe literal. Notice that literals with diﬀerent names and identical values (like 13.6,13.60) appear as diﬀerent entries in the literal table. When a LITORG is encountered
(or, in the absence of a LITORG , at the end of the ﬁrst pass), the assembler copies
the ‘value’ ﬁelds from the literal table to memory (to the memory address speciﬁedin theLITORG or, with no LITORG , the address following the end of the program)
and erases the table. Thus, several literal tables may be generated during the ﬁrstpass. In the second pass the intermediate ﬁle is read and, when an instruction isencountered that uses a literal, the assembler ﬁnds the relative address of the literalin the ﬁle, following the instruction. It uses this address to calculate the absoluteaddress of the literal, and assembles the instruction with that absolute address.Literalsliterals are treated in some detail in chapter 1.
49.PACKED
Label
Operation Operand
symbol PACKED list of expressions
The expressions are calculated and their values are stored in successive memory
locations in packed decimal form.
50.RECORD
Label Operation Operand
symbol RECORD ﬁeld1:size1,ﬁeld2:size2, ...
This is a powerful directive supported by the ASM 86 assembler. It deﬁnes
a template[ for data items] for 8- or 16-bit data item values that are declaredelsewhere. The RECORD directive itself does not load data in memory; it just deﬁnes
the format for data items loaded by other directives.
Example: ID RECORD YR:3,CODE:4,GEN:1
98 Directives Ch. 3
SymbolIDis now the name of a record (just a template, not any actual area in
memory) containing three ﬁelds: YR, a 3-bit value, CODE, a number between 0 and
15, andGEN, a single bit. The total length of the record is thus 8 bits. Each ‘size’
ﬁeld is the size (in bits) of a ﬁeld in the record. To actually allocate memory tosuch a record, other directives are used. For example: ‘ ACT ID 6DUP(?) ’ACTis 6
consecutive bytes, each a record of type ID, uninitialized. ‘ SAM ID 12DUP(5,0,1) ’
SAMis 12 consecutive bytes, each a record of type ID. The individual ﬁelds are
initialized to ‘ YR=5, CODE=0, GEN=1 ’.
Records allow for easy manipulation of small ﬁelds and individual bits while
packing them tightly in either bytes or words. The following example speciﬁesdefault values for the individual ﬁelds.VOL RECORD X:8=‘A’,Y:8=‘B’
The following source lines illustrate actual storage allocation.BAT VOL <,‘Q’> BAT is a record of type VOLwith ﬁeld Yinitialized to ‘ Q’ and
ﬁeldXhaving its default value ‘ A’.
CAT VOL<> CAT is a record of type VOL(2 bytes) where the X, Yﬁelds have the
default values.
To access a record, an instruction such as below can be used.MOV AX,OFFSET CAT . This is an 8086 MOVinstruction [37,38] whose general form
is
MOVdestination,source
TheMOVinstruction above moves OFFSET CAT (the address of record CAT)t o
the 16-bit register AX. The instruction
MOV AH,OFFSET SAM[3] moves the address of the third component of the array
SAMof records to the 8-bit register AH.
For more information on records see [34,35,37].
51.STRUC
Label
Operation Operand
symbol STRUC none
This directive is similar to the record feature in Pascal. It is another of the
powerful directives supported by many 80x86 assemblers. The STRUC is a tem-plate, not a memory area and, once it is deﬁned, many memory areas of the samestructure can be declared.
DIM STRUC
LEN DB 3,5WID DB 0HGT DW 0MISC DB 10DUP(?)DIM ENDS
Sec.3.12 DataGenerationDirectives 99
This deﬁnes a structure called DIMwith 4 ﬁelds, the ﬁrst one is named LENand is
2 bytes long. The last one has the name MISCand is ten bytes long. To actually
build such a structure in memory, source lines such as:
DAN DIM
BAN DIM 5DUP(?)
can be used. The ﬁrst declares DANas a structure of type DIM, the second one
declaresBANas an array of 5 such structures. To access a ﬁeld in a structure, the
name of the structure should be followed by a .field name .
MOV DAN.LEN,AL moves the 8-bit register ALto ﬁeldLENof structure DAN.
52.VFD
Label Operation Operand
symbol VFD l1/expr1,l2/expr2, ...
The expressions are evaluated, the value of expr iis extended or truncated to a
length of l ibits, and all the generated groups of bits are concateneted and packed
tight into consecutive words. This directive is used in those rare cases where theprogrammer knows the binary values of some constants and wants them packed inmemory. VFDstands for Variable Field Deﬁnition.
3.13 Macro Directives
(*ENDM,IRP,*MACRO ,REMOVE ,SYSLIST ,SYSNDX )
Those directives are described in detail in chapter 4.
3.14 Conditional Assembly Directives
(AGO,AIF,ANOP,ELSE,ENDIF ,GBLx,IF-ELSE-ENDIF ,IFF,IFT,IIF,LCLx,SET)
Again, conditional assembly and the above directives are described in detail
in chapter 4, except that SEThas been brieﬂy described in this chapter since it is
similar to EQU.
3.15 Micro Directives
(DECMIC ,MICRO ,OCTMIC )
The ‘micro’ feature enables the programmer to assign names to strings of char-
acters. This allows for more ﬂexibility in manipulating strings at assembly time,especially if the micro feature is used with the AIF,DUP,STOPDUP andSETdirectives.
53.DECMIC
Label
Operation Operand
name DECMIC expr,n
LikeOCTMIC below except that the rightmost n decimal digits are used.
100 Directives Ch. 3
54.MICRO
Label Operation Operand
name MICRO n1,n2,dstring
dstring is a delimited string (it is preceded and followed by the same char-
acter). A substring of n2characters, starting at position n1is extracted and is
assigned the name in the label ﬁeld. The name then becomes a micro name. If n2
is zero, the substring starts at position n1and goes to the end of the original string.
Examples:
AN MICRO 1,,/STRING/ AN is the name of string STRING
BC MICRO 2,3,*NONESUCH* BC is the name of ONE
55.OCTMIC
Label Operation Operand
name OCTMIC expr,n
The expression (which must be numeric) is evaluated by the assembler and the
rightmost noctal digits extracted. They become the string assigned as the value of
name.
Example: Suppose Bis a symbol ( EQUorSET) with absolute value 1024. Then
‘J OCTMIC B,6 ’ will assign the string 002000 to micro name J(since 20008=1024).
3.15.1 micro substitution
It is done by placing a micro name between the two micro delimiters ( /negationslash=) at
any point in any source line (except a comment line). The string is then substitutedfor the micro name. Examples:
COMP /negationslash=BC/negationslash=,R1is assembled as COMP ONE,R1
ADD # /negationslash=J/negationslash=,R2is assembled as ADD #002000,R2 .
3.16Error Control Directives
(ERR,ERRxx)
56.ERR
Label Operation Operand
ﬂag ERR none
This directive generates an assembler error of the type indicated by the ﬂag.
This can be useful in certain conditional assemblies. The example below assumesknowledge of macros and conditional assembly.
Sec.3.16 ErrorControlDirectives 101
SCD MACRO P1,P2
IIF P1=0
A ERR an error of type Awill be generated if the
. macro is expanded with 0 as the value of
. parameter P1
ENDM..SCD 0,GG this expansion will cause such an error
57.ERRxx
Label
Operation Operand
ﬂag ERRxx expression
Will generate an assembler error of type flagwhen a condition detected during
pass 2 is true.
Example:
..
HD S 0 H
is an array of length 0. It is the last address in the program
R ERRPL H-X’FF00 ifH-FF0016 is positive (PL), generate an error of type R.
END
The condition xxcan bePL,MI,ZR,NZ.
3.17 Listing Control Directives
(EJECT ,*LIST,PDC,SBTTL ,SPACE ,TITLE ,XREF,%OUT)
These are relatively simple directives that only aﬀect the listing ﬁle, not the
object code generated. The listing is generated during pass 2, when instructions arebeing assembled, except that the Microsoft macro assembler (MASM) can optionallycreate a pass-1 listing. This is discussed in Ch. 8, and may be useful in debugging.
58.EJECT
Label
Operation Operand
none EJECT none
It causes the next line of the listing to appear at the top of the next page
following the page heading. Some assemblers use PAGEinstead of EJECT .
102 Directives Ch. 3
59.LIST
Label Operation Operand
none LIST ON or OFF
Used to control the listing of the program. LIST ON instructs the assembler
to list subsequent lines. LIST OFF instructs it to suppress listing. The LISTdirec-
tive may appear anywhere in the program and is eﬀective until the next LIST is
encountered or until the end of the program, whichever occurs ﬁrst. Some assem-blers support two directives LIST,NOLIST instead of a LIST ON/OFF . It should be
emphasized that the LIST directive aﬀects the listing ﬁle only. It does not aﬀect
the assembly of the program. The entire program is assembled but the programmermay decide to list only certain parts of it.
60.PDC
Label
Operation Operand
none PDC none
PDCis used to print all the constants generated by a DCdirective. It is described
in chapter 5.
61.SBTTL
Label Operation Operand
none SBTTL a string
Speciﬁes a one-line subheading for the listing ﬁle. The assembler prints the
subheading as the second line of each listing page. The ﬁrst line is the heading (seeTITLE below for other features of the subheading).
62.SPACE
Label
Operation Operand
none SPACE n
Insertsnblank lines in the listing. When the number of blank lines exceeds
the number of lines left on the page, a page is ejected, a new heading is printed,and the rest of the blank lines are allocated on the new page.
63.TITLE
Label
Operation Operand
none TITLE a string
Speciﬁes a one line heading for the listing ﬁle. The assembler prints the heading
at the beginning of every page. The TITLE directive can appear anywhere in the
Sec.3.17 ListingControlDirectives 103
program, and each TITLE supersedes its predecessor. Each TITLE except the ﬁrst
one also causes a page eject. This directive is similar to SBTTL above and both have
the same features.
64.XREF
Label Operation Operand
none XREF string
Controls the printing of the cross-reference table. This table lists all the sym-
bols deﬁned in the program and for each symbol, the numbers of all source linesreferring to it. The operand is a string containing characters that specify whetherto print the table and how to list references to a symbol, by line number within thesource ﬁle, or by page number and line within the page.
65.%OUT
Label
Operation Operand
none %OUT string
It is useful for displaying progress through a long assembly. When the %OUTis
encountered, the operand (a string) is displayed on the standard output device.
3.18 Remote Assembly Directives
(HERE,RMT)
A pair of RMTdirectives deﬁnes source code that is to be remotely saved for
later assembly. The HERE directive directs the assembler to assemble part of the
remote code at a certain point. If any remote code remains unassembled when END
is encountered, it is assembled at the end of the program.
66.HERE
Label Operation Operand
optional HERE none
A remote code that was saved before is fetched and assembled. If the label ﬁeld
has a name, only remote code with that name is assembled. If there is no name, allunlabeled remote code existing at this point is fetched and assembled.
67.RMT
Label
Operation Operand
name RMT none
The name is optional. A pair of RMTdirectives with the same name (or both
without names) delimit a section of code that is saved, to be later assembled by aHEREdirective.
104 Directives Ch. 3
3.19 Code Duplication Directives
(DUP,ECHO,ENDD,STOPDUP )
They provide a handy way to duplicate parts of the code. The assembler is
given a sequence of source lines, and it duplicates and assembles it repeatedly. Theduplication can be stopped after a speciﬁed number of times, or upon a certaincondition being satisﬁed.
68.DUP
Label
Operation Operand
name DUP rep,lcnt
repspeciﬁes how many times to duplicate and assemble the sequence. lcnt
speciﬁes the number of source lines in the sequence. The sequence starts on the linefollowing the DUPand islcntlines long. The lcntparameter is optional and if it
is missing, the sequence goes up to the nearest ENDD. The name is also optional and
serves to identify the sequence duplicated. DUPsequences may be nested, in which
case the names are important and deﬁne the inner and outer DUPranges.
Example:
OUT DUP 3 duplicate 3 times
ADD
INN DUP 2 an inner DUPduplicated twice
SUB
INN ENDD
LOD
OUT ENDD
The resulting code will be:
ADD SUB SUB LOD ADD SUB SUB LOD ADD SUB SUB LOD
Note that the diﬀerent duplicates may be diﬀerent. Using the SETorECHOdirectives,
the user may specify diﬀerent operands each time the DUPrange is duplicated.
69.ECHO
Label
Operation Operand
name ECHO lcnt,p1=list1,p2=list2, ...
Thenameandlcntﬁelds are as before. p1, p2, ...are parameters that ap-
pear in the sequence to be duplicated. Each time the sequence is duplicated, eachoccurence of p1in the body of the sequence is replaced with something from list1 ,
each occurence of p2is replaced with something from list2 , etc.
Each list
ishould have the form ‘ (a1,a2,...,an) ’ wherea1is substituted for
pion the ﬁrst duplication, a2is substituted for piin the second duplication, and
so on.
Sec.3.19 CodeDuplicationDirectives 105
Duplication of the sequence is repeated until the shortest list iis exhausted. If
any of list iis null, the sequence is duplicated zero times and is therefore eﬀectively
skipped.
It should be noted that ECHO is very similar to the MACRO directive. It is a
powerful directive and is handled by the assembler in a way very similar to handlinga macro. The main diﬀerence between ECHOand macros is that the ECHOdoes not
require separate deﬁnition and expansion.
70.ENDD
Label
Operation Operand
name ENDD none
This is used to terminate the sequence of a DUPorECHO.
71.STOPDUP
Label Operation Operand
none STOPDUP none
It is used to prematurely terminate a DUPduplication before the repeat count
is reached, or an ECHOduplication before the shortest list is exhausted. It is used
with conditional assembly such that it is only executed when a decision is made toterminate the duplication.
3.20 Operation Deﬁnition Directives
(OPDEF ,PURGDEF )
72.OPDEF
Label Operation Operand
name OPDEF parameters
This is a very powerful directive, used to add new instructions, or to redeﬁne
existing machine instructions. ‘name’ is the name of the instruction being addedto the instruction set. If it is the name of an existing instruction, then the newinstruction overrides the existing one. The parameters are the operands of the newinstruction. The new instruction is deﬁned in terms of existing ones, so an OPDEF
takes more than one line. A complete deﬁnition starts with an OPDEF line, followed
by several lines of deﬁnition, and is terminated by a line with the ENDM directive
(which also terminates the deﬁnition of a macro, see chapter 4). Example:
ADDX OPDEF P1,P2
ADD #2,P1ADD P1,P2ENDM
106 Directives Ch. 3
A new instruction, ADDX, is deﬁned (or is replacing an existing ADDXinstruction)
that adds its two parameters and adds 2 to the sum. It is deﬁned in terms of existingADDinstructions so the parameters P1,P2 can be any valid operands of the existing
ADDinstruction. To use the new instruction, ADDX X,Y is written in the mnemonic
and operand ﬁelds on a source line.
73.PURGDEF
Label
Operation Operand
name PURGDEF none
The instruction named in the label ﬁeld is removed. It can only be something
originally deﬁned with an OPDEF .
3.21 OpCode Table Management Directives
(OPSYN )
74.OPSYN
Label Operation Operand
mnemonic OPSYN mnemonic
This makes the mnemonic in the label ﬁeld synonymous with the mnemonic in
the operand ﬁeld. However, if the operand ﬁeld is blank, this directive deletes theinstruction from the OpCode table (actually, it is deactivated in the table).
Example: STORE OPSYN STA
Declares the new mnemonic STORE to be the same as the existing mnemonic
STA. The programmer may use this directive to change the names of mnemonics
to more familiar ones, or to ones easier to remember. Notice that STAcan still be
used. This directive applies to mnemonics of instructions and of directives. Thus‘EQUATE OPSYN EQU ’ declares EQUATE as another way of saying EQU.
This directive is rarely supported by assemblers since it is hard to implement. It
requires the OpCode table to be dynamic, so that the assembler can insert the newmnemonics. The OpCode table is usually static, which allows for a fast search. In adynamic OpCode table the search is slower and, since OpCode table search is donevery often, a dynamic OpCode table should be very carefully designed. The maindesign guideline is: If the OPSYN directive has not been used (no new mnemonics
added to the OpCode table), the search time in the dynamic table should be thesame as that of a static table. Only the actual insertion of new mnemonics shoulddegrade the search time. Such an OpCode table can be designed in two ways:
1. As a hash table (chapter 2). A hash table can be designed such that originally
any mnemonic can be found in a one step search. As mnemonics are added,the search time degrades.
Sec.3.21 OpCodeTable ManagementDirectives 107
2. As a main (static) OpCode table, including the original mnemonics, plus an
auxiliary, dynamic table, for the added mnemonics. Executing an OPSYN with
such a double table involves two steps:
•Locating the old mnemonic in the main OpCode table and setting a pointer
to point to it.
•Adding the new mnemonic to the auxiliary table together with the pointer
from step 1.
To search the OpCode table, the assembler ﬁrst searches the main table in the
usual way. If the mnemonic is not found, the assembler searches the auxiliary tableand, on ﬁnding the mnemonic, uses the pointer to ﬁnd the entry in the main tablethat corresponds to that mnemonic.
3.22 Summary
Directives illustrate the hidden power of the assembler. It should now be clear
to the reader that the main task of assembling instructions is simple, and consumesonly a fraction of the power of the assembler. The many directives presented hererange from very simple to very complex(the most complicated ones are covered inthe next chapter), they provide the user with many services, and constitute morethan half the volume of a typical two-pass assembler. One-pass assemblers, designedfor speed, support just a few directives and are, therefore, much simpler.
108 Directives Ch. 3
3.23 Review Questions and Projects
1.Classify all the directives mentioned in this chapter, except the macro and
conditional assembly directives, according to the pass in which they are executed.Note that many directives are executed in both passes.
2.What is the diﬀerence between ‘ A EQU 7 ’ and ‘AD C7 ’? What operations does
the assembler have to perform in pass 1 and in pass 2 in order to execute thosedirectives?
3.Compare the STRUC directive with a Pascal record. What are some diﬀerences
between them?
4.What is the diﬀerence between ENDDandSTOPDUP ?
5.The directives TITLE ,SBTTL mentioned above provide for up to two title lines
on each listing page. Sometimes a programmer wants more than two such lines.Design a HEADdirective where the programmer could print any number of header
lines on each page.
6.After reading chapter 7, ﬁnd uses for the LCCdirective. What loader control
features described in chapter 7 could be speciﬁed by the programmer using LCC?
7.Compare the COMM directive to the method described in chapter 1 (using //
location counters) to declare COMMON blocks.
8.Compare the IRPandDUPdirectives. Why were they listed here under diﬀerent
classes?
9.Directives have diﬀerent names in diﬀerent assemblers. Using several assembler
manuals, list diﬀerent names for the LIST,EXTRN ,&ENTRY directives.
10.Study the directives described in this chapter. Try to identify the three that
are the easiest for the assembler to execute, and the three that are the hardest.
3.23.1 Project 3–1
Extend project 1–3 by adding the EXTRN ,ENTRY directives plus ﬁve more di-
rectives of your choice (except macros, conditional assembly and listing controldirectives).
3.23.2 Project 3–2
TheOPDEF ,PURGDEF andOPSYN directives aﬀect the OpCode table. If those
directives are supported, the OpCode table can no longer be static. Design andimplement a dynamic OpCode table and add it to any of chapter 1 projects, tosupport the three directives above.
Pseudo instructions (also called directives or simply pseudos) provide
information or directions to the assembler that aﬀect the translation
process
—Roy S. Ellizey, Computer System Software (1987)
4. Macros
Webster [42] deﬁnes the word macro (derived from the greek µακρoσ ) as mean-
ing long, great, excessive or large.The word is used as a preﬁx in many compoundtechnical terms, e.g., Macroeconomics, Macrograph, Macronesia. We will see thata single macro directive can result in many source lines being generated, which jus-tiﬁes the use of the word macro in assemblers.As mentioned in the introduction,
macros were introduced into assemblers very early in the history of computing, inthe 1950s.
4.1 Introduction
Strictly speaking, macros are directives but, since they are so commonly used
(and also not easy for the assembler to execute), most assemblers consider them fea-
tures, rather then directives.The concept of a macro is not limited to assemblers, It
is useful in many applications and has been used in many software systems.Refer-ences [19–22] describe the use and implementation of macros in general.Knuth[36]describes the use of macros in a large software system.Dellert [92] is an interestingexample of the use of macros in reprogramming (translating or rewriting a programfrom computer Ato computer B).
/A macro is similar to a subroutine (or a procedure), but there are important
diﬀerences between them.A subroutine is a section of the program that is writtenonce, and can be used many times by simply calling it from any point in the program.Similarly, a macro is a section of code that the programmer writes (deﬁnes) once,
110 Macros Ch. 4
and then can use many times.The main diﬀerence between a subroutine and a
macro is that the former is stored in memory once (just one copy), whereas thelatter is duplicated as many times as necessary.
A subroutine call is speciﬁed by an instruction that is executed by the hardware.
The hardware saves the return address and causes a branch to the start of thesubroutine.Macros, however, are handled in a completely diﬀerent way.A macrocall is speciﬁed by a directive that is executed by the assembler.The assemblergenerates a copy of the macro and places it in the program, in place of the directive.This process is called macro expansion, and each expansion causes another copy ofthe macro to be generated and placed in the program, thus increasing the size ofthe object code.
As a result, subroutines are completely handled by the hardware, at run time;
macros are completely handled by the assembler, at assembly time.The assemblerknows nothing about subroutines; the hardware knows nothing about macros.Asubroutine call instruction is assembled in the usual way and is treated by theassembler as any other instruction.Macro deﬁnition and macro expansion, however,are executed by the assembler, so it has to know all the features, options andexceptions associated with them.The hardware, on the other hand, executes thesubroutine call instruction, so it has to know how to save the return address andhow to branch to the subroutine.The hardware, however, gets to execute the objectcode after it has been assembled, with the macros expanded in place.By lookingat an instruction in the object code, it is impossible to tell whether it came fromthe main program or from an expanded macro.The hardware thus executes theprogram in total ignorance of macros.
Figure 4–1 illustrates the diﬀerences between subroutines and macros:When program Ain ﬁgure 4–1a is executed, execution starts at label Kand each
‘CALL N ’ instruction causes the subroutine (section 1) to be executed.The order of
execution will thus be 2,1,3,1,4.Even though section 1 is the ﬁrst in the program,it is not the ﬁrst to be executed since it constitutes the deﬁnition of a subroutine.When the program is assembled, the assembler reads and assembles the source ﬁlestraight through.It does not change the positions of the diﬀerent sections, anddoes not treat section 1 (the subroutine) in any special way.The order of executionhas therefore to do only with the way the CALL instruction works.This is why
subroutines are a hardware feature.
Program B(Fig.4–1b) is handled in a diﬀerent way.The assembler reads the
MACRO ,ENDM directives and thus recognizes the two instructions DIV,OUTas the
body of macro N.It then places a copy of that body wherever it ﬁnds a source line
withNin the operation ﬁeld.The output is the same program, with the macro
deﬁnition removed, and with all the expansions in place.This output (Fig.4–1c) isready to be assembled, in the usual way, by passes 1 and 2.This is why macros arean assembler feature and handling them is done by a special pass, pass 0, where anew source ﬁle is generated (Fig.4–1d) to be read by pass 1 as its source ﬁle.
Having a separate pass 0 simpliﬁes the design of the assembler, since it divides
the entire assembly job in a logical way between the three passes.The user, of
Sec.4.1 Introduction 111
K CALL N
NL O D
...
RET

1
K CALL N
KI N P
...
SUB

2
K CALL N
CALL N
K CALL N
ADD
...
BPL

3
K CALL N
CALL N
K CALL N
MULT
...
HLT

4
K CALL N
END KN MACRO
DIVOUTENDM
K INP
...
SUBNADD
...
BPLNMULT
...
HLTENDK INP
...
SUBDIVOUTADD
...
BPLDIVOUTMULT
...
HLTEND
Source ﬁle
↓
Pass 0
macro deﬁnitions
& expansions
↓
New source ﬁle
ab c d
Figure 4–1. The diﬀerence between macros and subroutines.
a.A program with a subroutine N. b.A program with a macro N.
c.Same program after the macro expansion. d.A summary of pass 0.
course, has to pay a price in the form of increased assembly time, but this is a
reasonable price to pay for the added power of the assembler.It is possible tocombine passes 0 and 1 into one pass, which speeds up the assembler.However,this results in a very complex pass 1, which takes more time to write and debug,and reduces assembler reliability.
/The task of pass 0 is thus to read the source ﬁle, handle all macro deﬁnitions
and expansions, and generate a new source ﬁle that is identical to the originalﬁle, except that it does not have the macro deﬁnitions, and it has all the macroexpansions in place.In principle, the new source ﬁle should have no mention ofmacros; in practice, it needs to have some macro information which eventually istransferred to pass 2, to be written on the listing ﬁle.This point is further discussedbelow.
112 Macros Ch. 4
4.1.1 The Syntax of macro deﬁnition and expansion
To deﬁne a macro, the MACRO ,ENDMdirectives are used.
NU MACRO the header, or prototype of the macro.
LOD A the body (or model
ADD B statements) of the
STO C deﬁned macro.
ENDM the trailer of the deﬁnition
Those two directives always come in pairs.The MACRO directive deﬁnes the start of
the macro deﬁnition, and should have the macro name in the label ﬁeld.The ENDM
directive speciﬁes the end of the deﬁnition.
Some assemblers use diﬀerent syntax to deﬁne a macro.The IBM 360 assembler
uses the following syntax:
MACRO
&p1 name &p2,&p3, ...
..MEND instead of ENDM
where&p1, &p2 are parameters (explained later), each starting with an ampersand
‘&’.
To expand a macro, the name of the macro is placed in the operation ﬁeld, and
no special directives are necessary.
.
.COMP ..NUSUB ....
The assembler recognizes NUas the name of a macro, and expands the macro by
placing a copy of the macro deﬁnition between the COMPandSUBinstructions.The
object code generated will contain the codes of the ﬁve instructions:
COMP ..
LOD AADD BSTO CSUB ..
Handling macros involves two separate phases.Handling the deﬁnition and
handling the expansions.A macro can only be deﬁned once (see the discussion of
Sec.4.1 Introduction 113
nested macros later for exceptions, however), but it can be expanded many times.
Handling the deﬁnition is a relatively simple process.The assembler reads thedeﬁnition from the source ﬁle and saves it in a special table, the Macro Deﬁnition
Table (MDT).The assembler does not try to check the deﬁnition for errors, to
assemble it, execute it, or do anything else with it.It just saves the deﬁnition as itis (again, there is an exception, mentioned below, that has to do with identifyingparameters).On encountering the MACRO directive, the assembler switches from the
normal mode of operation to a special macro-deﬁnition mode in which it:
locates available space in the MDT
reads source lines and saves them in the MDT until an ENDMis read.
Upon reading ENDM from the source ﬁle, the assembler switches back to the
normal mode.If the ENDMis missing, the assembler stays in the macro deﬁnition
mode and saves source lines in the MDT until an obvious error is found, such asanotherMACRO ,o rt h eENDof the entire program.In such a case, the assembler
issues an error (run away deﬁnition) and aborts the assembly.
Handling a macro expansion starts when the assembler reads a source line that
is not any instruction or directive.The assembler searches the MDT for a macrowith that name and, on locating it, switches from the normal mode of operation toa special macro-expansion mode in which it:
Reads a source line from the MDT.
Writes it on the new source ﬁle, unless it is a pass 0 directive, in which case it is
immediately executed.
Repeats the two steps until the end of the macro is located in the MDT.
The following example illustrates this process.The macro deﬁnition contains
an error and a label.
BAD MACRO
ADD #1,R4A$D R5 wrong mnemonic
LAN CMP R3,R5
ENDM
The deﬁnition is stored in the MDT with the error ( A$D) and the label.Since the
assembler copies the macro deﬁnition verbatim, it does not recognize LANas a label
at this point.The macro may later be expanded several times, causing severalcopies to be written onto the new source ﬁle.Pass 0 does not check these copies inany way and, as a result, does not issue any error messages (note that pass 0 doesnot handle labels and does not maintain the symbol table).When pass 1 reads thenew source ﬁle, it discovers the multiple deﬁnitions of LANand issues an error on
the second and subsequent deﬁnitions.When pass 2 assembles the instructions, itdiscovers the bad A$Dinstructions and ﬂags each of them.
114 Macros Ch. 4
/
Exercise 4.1 In such a case, how can we ever deﬁne a macro with a label?
This does not sound like a good way to implement macros.It would seem
better to assemble the macro when it is ﬁrst encountered, i.e., when its deﬁnition isfound, and to store the assembled version in the MDT.The reason why assemblersdo not do that but rather treat macros as described above, is because of the use ofparameters.
4.2 Macro Parameters
The use of parameters is the most important feature of macros.It is similar
to the use of parameters in subroutines, but there are important diﬀerences.Thefollowing examples illustrate the use of parameters in a simple macro.They showthat parameters can be used in all the ﬁelds of an instruction, not just in theoperation ﬁeld.
12 3 4
MG1 MACRO MG2 MACRO A,B,C MG3 MACRO A,B,C MG4MACRO P
LOD G LOD A A G LOD GADD H ADD B B H P ADD HSTO I STO C C I STO IENDM ENDM ENDM ENDM
Example 1 is a simple, three-line macro without parameters.Every time it is
expanded, the same source lines are generated.They add the contents of memorylocations GandH, and store the result in location I.Example 2 uses three parameters
A,B,C for the three locations involved.The macro still does the same thing but,
each time it is expanded, diﬀerent locations are added, and the result is stored in adiﬀerent location.When such a macro is expanded, the user should specify values(actual arguments) for the three parameters.Thus the expansion ‘ MG2 X,Y,Z ’ would
generate:
LOD X
ADD YSTO Z
For the assembler to be able to assemble those instructions, the arguments
X,Y,Z must be valid symbols deﬁned in the program, i.e., the program should
contain:XD S4
YD C44Z EQU $FF00
or some similar lines on which labels X,Y,Z are deﬁned.
This example shows why the assembler cannot assemble a macro at the time
the deﬁnition is found in the source ﬁle.The macro lines may depend on parametersthat are assigned values only when the macro is expanded.Thus in general, macrolines can only be assembled or executed when the macro is expanded.
The process of assigning the value of an actual argument to a formal parameter
is called binding .Thus the formal parameter Ais bound to the actual argument
Sec.4.2 MacroParameters 115
X.The process of placing the actual arguments in place of the formal parameters
when expanding a macro, is called parameter substitution .
/
Exercise 4.2 Consider the case of an actual argument that happens to be identical
to a formal parameter.If the macro of example 2 above is expanded as ‘ MG2 B,X,Y ’,
we would end up with the expansion
LOD B
ADD XSTO Y
However, Bis the name of the second parameter.Would the assembler perform
double substitution, to end up with LOD X ?
Example 3 is even more striking.Here the parameters are used in the operation
ﬁeld.The operands are always the same.When such a macro is expanded, theuser should specify three arguments which are valid mnemonics.The expansion‘MG3 LOD,SUB,STO ’ would generate:
LOD G
SUB HSTO I
whereas the expansion ‘ MG3 LOD,CMP,JNE ’ would generate
LOD G
CMP HJNE I
which is a very diﬀerent macro.It is obvious now that such a macro cannot be
assembled when it is deﬁned.
In example 4 the parameter is in the label ﬁeld.Each expansion of this macro
will have to specify an argument for the parameter, and that argument will becomea new label.Thus ‘ MG4NON ’ generates
LOD G
NON ADD H
STO I
andMG4BON generates
LOD G
BON ADD H
STO I
Each expansion involves the creation of a new label that will be added to the
symbol table in pass 1.To avoid multiply-deﬁned labels, each expansion should usea diﬀerent argument.The argument could also be null (see below), which wouldgenerate no label.It is important to realize, however, that the label becomes knownonly when the macro is expanded and not before.Macro expansions, therefore, mustbe done early in the assembly process.They cannot be done in the second passbecause the symbol table must be stable during that pass.All macro expansionsare done in pass 0 (except in assemblers that combine passes 0 and 1).
116 Macros Ch. 4
/
Exercise 4.3 How many parameters can a macro have?
Another, more important, reason why macros must be expanded early is the
need to maintain the LC during the ﬁrst pass.The LC is used, during that pass, toassign values to symbols.It is important, therefore, to execute each expansion andto increment the LC while individual lines are expanded.If macros are handled inpass 0, then pass 1 is not concerned about them and it proceeds normally.
The main advantage of having a separate pass 0 is simplicity.Pass 0 only
handles macros and pass 1 remains unchanged.Another advantage is that thememory area used for the MDT in pass 0 can be used for other purposes—likestoring the symbol table—in the other passes.The main disadvantage of pass 0 isthe additional time it takes, but there is a simple way to speed it up.It is onlynecessary to require that all macro deﬁnitions appear at the very beginning of thesource ﬁle.When pass 0 starts, it examines the ﬁrst source line.If it is not a MACRO
directive, pass 0 assumes that there are no macro deﬁnitions (and, consequently, nomacro expansions) in the program, and it immediately starts pass 1, directing it touse the original, instead of the new, source ﬁle.
Another point that should be noted here is the listing information that relates
to macros.In principle, the new source ﬁle, generated by pass 0, contains nomacro information.Pass 0 completely handles all macro deﬁnitions and expansions,and pass 1 needs to know nothing about macros.In practice, though, the userwants to see a listing of the macro deﬁnitions and, sometimes, also listings of allthe expansions.This information can only be generated by pass 0 and should betransferred, ﬁrst to pass 1 through the new source ﬁle, and then to pass 2—wherethe listing is created—through the intermediate ﬁle.This listing information cannotbe transferred by storing it in memory since, with many deﬁnitions and expansions,it may be too large.
A related problem is the listing of macro expansions.The deﬁnition of a macro
should obviously be listed, but a macro may be expanded many times, and the usermay want to suppress the listing of all or some of the expansions.Special directivesthat tell the assembler how to handle listing of macro expansions are discussed laterin this chapter.
4.2.1 Properties of macro parameters
The last example of the use of parameters is a macro whose arguments may be
compound.
C MACRO L1,L2,L3,L4,L5,L6
ADD L1,L2(2) L2 is assumed compound and its 2nd component used
L3B’L4DESTC’L5’D L6..ENDM
Sec.4.2 MacroParameters 117
An expansion of such a macro may look like this
C SUM,(D,T,U),(SUB R1,L1),Z,,SN
The second argument is compound and has three components.The third argumentis also compound, since it has a space and a comma in it, and therefore must beparenthesized.The parentheses of a compound argument are stripped oﬀ duringexpansion.The ﬁfth argument is null.
The above expansion generates:
ADD/visiblespace/visiblespaceSUM,T the symbol ‘ /visiblespace’ stands for a space
SUB/visiblespaceR1,SUMBZ/visiblespaceDESTCD/visiblespaceSN..
which illustrates the following points about handling arguments in a macro expan-
sion:
1.There are two spaces between the ADDand theSUMon the ﬁrst line.This
is because the macro deﬁnition has two spaces between the ADDand theL1.
In the second line, though, there is only one space between the SUBand the
R1.This is because the argument in the expansion has one space in it.The
assembler expands a macro by copying the arguments, as strings, into theoriginal macro line without any editing (except that when the argument iscompound, its parentheses are stripped oﬀ).In the third line, the parameteroccupies three positions ( ‘L4) but the argument Zonly takes one position.
WhenZis substituted for ‘L4, the source line becomes two positions shorter,
which means that the rest of the line is moved two positions to the left.Theassembler also preserves the original space between L4andDEST.As a result,
the expanded line has one space between BZandDEST.
2.The second line of the deﬁnition simply reads L3.The assembler replaces L3
by the corresponding argument ‘ SUB R1,L1 ’ and, before trying to assemble
it, scans the line again, looking for more occurrences of parameters.In ourexample it ﬁnds that the newly generated line has an occurrence of L1in it.
This is immediately replaced by the argument corresponding to L1(SUM) and
the line is then completely expanded.The process of macro expansion turnsout to be a little more complex than originally described.
3.In line three of the deﬁnition the quote (’) separates the character Bfrom the
parameter L4.On expanding this line, the assembler treats the quote as a
separator, removes it, and concatenates the argument Zto the character B,
thus forming BZ.IfBZis a valid mnemonic, the line can be assembled.This is
another example of a macro line that has no meaning before being completelyexpanded.
4.The argument corresponding to parameter L5is null.The result is the string
CDwith nothing between the Cand theD.Again, if CDis a valid mnemonic (or
118 Macros Ch. 4
directive), the line can eventually be assembled (or executed).Otherwise, the
assembler ﬂags it as an error.
Note that there is a diﬀerence between a null argument and an argument that is
blank.In the expansion C SUM,(D,T,U),(SUB/visiblespaceR1,L1),Z,/visiblespace,SN , the ﬁfth argument
is a blank space, which ends up being inserted between the Cand theDin the
expanded source line.The ﬁnal result is C/visiblespaceD/visiblespaceSN which is not the same as CD/visiblespaceSN .It
could even be interpreted by the assembler as C=label,D=mnemonic, SN=operand.
If a mnemonic Dexists, the instruction would be assembled and Cwould be placed
in the symbol table, without any error messages or warnings.
/
Exercise 4.4 What if the last argument of an expansion is null? How can the
assembler distinguish between a missing last argument and a null one?
/A little thinking shows that the precise names of the formal parameters are
not important.The parameters are only used when the macro is expanded.Noparameter names are used after pass 0 (except that the original names should appearin the listing).As a result, the assembler replaces the parameter names with serialnumbers when the macro is placed in the MDT.This makes it easier to locateoccurences of the parameters when the macro is later expanded.Thus in one of theexamples above:
D MACRO A,B,C
LOD AADD BSTO CENDM
macroDis stored in the MDT as:
D3/visiblespace/visiblespaceLOD/visiblespace#1 /visiblespace/visiblespaceADD/visiblespace#2 /visiblespace/visiblespaceSTO/visiblespace#3
The vertical bar is used to separate source lines in the MDT.The ‘3’ in the
second ﬁeld indicates that the macro has three parameters, and #1, #2 etc., referto the parameters.The bold vertical bar
signals the end of the macro in the
MDT.This editing slows down the assembler when handling a macro deﬁnition butit speeds up every expansion.Since a macro is deﬁned once but may be expandedmany times, the advantage is clear.
It is now clear that three special characters are needed when macros are placed
in the MDT.In general, the assembler should use characters that cannot appear inthe original deﬁnition of the macro, and each assembler has a list of characters thatare invalid inside macros, or are even prohibited anywhere in the source ﬁle.
The example above is simple since each parameter is a single letter.In the
general case, a parameter may be a string of characters, called a token.The editing
process mentioned above is done by breaking up each source line into tokens.Atoken is an indivisible unit of the line and is made up of a string of letters and digits,or a single special character.Each token is compared to all parameter names and,in case of a match, the token is replaced by its serial number.The example above
NE DInputstart
mode:=N
Execute itmode:=Dmode
MACRO
pass 0
directivemacro
namemode:=E
output
END
stop1
1
12
2
44
3
3no
nono
noyesyes
yesyesSec.4.2 MacroParameters 119
may now be rewritten with the paramater names changed to more than one letter.
D MACRO AD,BCD,ST7
LOD ADADD BCDSTO ST7ENDM
Let’s follow the editing of the second line.It is broken up into the two tokens
ADDandBCD, and each token is compared with all three parameter names.The ﬁrst
token ‘ADD’ almost matches the ﬁrst parameter ‘ AD’.The second one ‘ BCD’ exactly
matches the second parameter.That token is replaced by the serial number ‘#2’of the parameter, and the entire line—including the serial number—is stored in theMDT.Our new example will be stored in the MDT in exactly the same way asbefore, illustrating the fact that parameter names can be changed without aﬀectingthe meaning of the macro.
Figure 4–2a. Summary of Pass 0 (part I).
E,N D N,D Einput
mode
read line
from sourceread line
from MDT
return returnmodeoutput
write line
in MDTwrite line on
new source
definition
 modeexpansion
 mode
locate space
in MDT
store macro
name andparameters
outputinput
outputinput
mode:=Nend of
macro
scan line &
substituteparameters
Execute itpass 0
directiv e12
3
33
1MEND
mode:=Nyes
no
yesnoyes
no120 Macros Ch. 4
Figure 4–2b. Summary of Pass 0 (part II).
Figure 4–2c. Summary of Pass 0 (part III).
Sec.4.3 Operationof Pass 0 121
4.3 Operation of Pass 0
Pass 0 is devoted to handling macros.Macro deﬁnitions and expansions are
fully done in pass 0, and the output of that pass, the new source ﬁle, containsno trace of any macros (except the listing information mentioned earlier).Theﬁle contains only instructions and directives, and is ready for pass 1.Pass 0 doesnot handle label deﬁnitions, does not use the symbol table, does not maintain theLC, and does not calculate the size of instructions.It should, however, executecertain directives that pertain to macros, and it has to handle two types of specialsymbols.The directives are called pass 0 directives, they have to do with conditionalassembly, and are explained later in this chapter.The special symbols involved areSETsymbols and sequence symbols.They are fully handled by pass 0, are stored in
a temporary symbol table, and are discarded at the end of the pass.The followingrules (and Fig.4–2) summarize the operations of pass 0.
1.Read the next source line.2.If it is MACRO , read the entire macro deﬁnition and store in MDT.Goto 1.
3.If it is a pass 0 directive, execute it.Goto 1.Such a directive is written on the
new source ﬁle but in a special way, not as a normal directive, since it is onlyneeded for the listing in pass 2.
4.If it is a macro name, expand it by bringing in lines from the MDT, substituting
parameters, and writing each line on the new source ﬁle (or executing it if it apass 0 directive).Goto 1.
5.In any other case, write the line on the new source ﬁle.Goto 16.If current line was the ENDdirective, stop (end of pass 0).
To implement those rules, the concept of an operating mode is introduced.
The assembler can be in one of three modes: the normal mode (N)—in which itreads lines from the source ﬁle and writes them to the new source ﬁle; the macrodeﬁnition mode (D)—in which it reads lines from the source ﬁle and writes theminto the MDT; and the macro expansion mode (E)—in which it reads lines from theMDT, substitutes parameters, and writes the lines on the new source ﬁle.A fourthmode (DE) is introduced later in this chapter in connection with nested macros.
/
Exercise 4.5 Normally, the deﬁnition of a macro must precede any expansions of
it.If we eliminate that restriction, what modiﬁcations do we have to make to theassembler?
122 Macros Ch. 4
4.4 MDT Organization
Most computers have operating systems (OS) that provide supervision and
oﬀer services to the users.The date and time are two examples of such services.Touse such a service (e.g., to ask the OS for the date) the user has to place a requestto the OS.Since the typical user cannot be expected to be familiar with the OS, theOS provides built-in macros, called system macros .To get the date, for example,
the user should write a source line such as ‘ DATE D ’ whereDATEis a system macro,
andDis an array in which DATEstores the date.As a result, the MDT does not
start empty.When pass 0 starts, the MDT contains all the system macros.Asmore macro deﬁnitions are added to the MDT, it grows larger and larger and theproblem of eﬃcient search becomes more and more important.The MDT shouldbe organized to allow for eﬃcient search, and most MDTs are organized in one oftwo ways: as a chained MDT, or as an array where each macro is pointed to from
a Macro Name Table (MNT).
A chained MDT is a long array containing all the macro deﬁnitions, linked with
backwards pointers.Each deﬁnition points to its predecessor and each is made upof individual ﬁelds separated by a special character that we will denote
.A typical
deﬁnition contains:
...namepointer#o f
paramsfirst line ...last line namepointer ...
where the last separator is immediately followed by the name of the next macro.
Such an MDT is easy to search by following the pointers and comparing names.Since the pointers point backwards, the table is searched from the end to the be-ginning; an important feature.It guarantees that when a multiply-deﬁned macro isexpanded, the back search will always ﬁnd the last deﬁnition of the macro.Multiply-deﬁned macros are a result of nested macro deﬁnitions(see later), or of macros thatusers write to supersede system macros.In either case, it is reasonable to requirethat the most recent deﬁnition always be used.The advantage of this organizationis its ﬂexibility.It is only limited by one parameter, the size of the array.The totalsize of all the deﬁnitions cannot exceed this parameter.Thus we can deﬁne a fewlong macros or many short ones.
The other way to organize the MDT is to store the macros in an MDT array
with separators as described before, but without pointers.An additional array,called the MNT, contains pairs <macro name, pointer >where the pointers point
to the start of a deﬁnition in the MDT array.The advantage of this organization isthat the MNT has ﬁxed size entries, allowing for a faster search of names.However,the total amount of macros that can be stored in such an MDT is limited by twoparameters.The size of the MDT array—which limits the total size of all themacros—and the size of the MNT—which limits the number of macros that canbe deﬁned.The following diagram is an example of such an MDT organization.Itshows an MDT array with 3 macros.The ﬁrst has 3 parameters, the second, 4, andthe third, 2.The MNT array has ﬁxed-size entries.
name1 name2 name331st line last line 4line line 2 line line MDT Array
MNT with fixed
 length entries.... .... ....Sec.4.4 MDTOrganization 123
Figure 4–3. MNT–MDT structure.
4.4.1 The REMOVE directive
Regardless of the way the MDT is organized, if the assembler supports system
macros, it should also support a directive to remove a macro from the MDT.A userwriting a macro to redeﬁne an existing system macro may want the redeﬁnitionto be temporary.They deﬁne their macro, expand it as many times as necessary,and then remove it such that the original system macro can be used again.Such adirective is typically called REMOVE .
In old assemblers this directive is executed by removing the pointer that points
to the macro, not the macro itself.Removing the macro itself and freeing the spacein the MDT is done by many new assemblers (see Ch.8). It is done by changingthe macro deﬁnition to a null string, and storing another (smaller) macro in thespace thus freed.After deﬁning and removing many macros, the MDT becomesfragmented; it can be defragmented by moving macros around and changing pointersin the MNT.
/
Exercise 4.6 What could be a practical example justifying the actual removal of
a macro from the MDT?
4.4.2Order of search of the MDT
Pass 0 has to identify each source line as either a macro name, a pass 0 directive,
or something else.To achieve quick identiﬁcation, the pass 0!directives should bestored in the MDT with a special ﬂag, identifying them as directives.This way,only the MDT has to be searched in pass 0.
An assembler combining passes 0 and 1 has to do more searching.Each source
line has to be identiﬁed as either an instruction (its size should be determined), asa pass 0 or pass 1 directive (to be executed), as a pass 2 directive (to be written onthe intermediate ﬁle), or as a macro name (to be expanded).
One approach is to search the OpCode table ﬁrst (it should contain all the
mnemonics and directives) and the MDT next, the idea being that most sourcelines are either instructions or directives, macro expansions are relatively rare.
The alternative approach is to search the MDT ﬁrst and the OpCode table next.
This way, the programmer can deﬁne macros which redeﬁne existing instructions ordirectives.If this approach is used, the MDT must be designed to allow for quicksearch.
124 Macros Ch. 4
4.5 Other Features of Macros
4.5.1 Associating macro parameters with their arguments.
Associating macro parameters with their actual arguments can be done in
three ways.By position, by name, and by numeric position in the argument list.The ﬁrst method is the simplest and most common.If the macro is deﬁned as‘M MACRO P1,P2,P3 ’ then the expansion ‘ M ADA,JON,YON ’ obviously associates the
actual value ADAwith the ﬁrst parameter P1, the actual value JONwith the second
parameter P2, etc.The expansion ‘ M ADA,,NON ’ has an empty second argument,
and the second parameter P2is therefore bound to a null value.
Associating by name, however, is diﬀerent.Using the macro deﬁnition above,
we can have an expansion ‘ M P2=DON,P1=SON,P3=YON ’.Here each of the three actual
arguments SON, DON, YON is explicitly associated with one of the parameters.
/
Exercise 4.7 What is the meaning, if at all, of the expansion
‘M P2=DON,P1=DON,P3=DON ’?
It is possible to combine the two methods, such as in ‘ M P3=MAN,DAN,P1=JAN ’.
Here the second argument has no name association and it therefore correspondsto the second parameter.This, of course, implies that an expansion such as‘M P2=MAN,DAN,P1=JAN ’, is wrong.
/
Exercise 4.8 There is, however, a way to assign such an expansion a unique mean-
ing.What is it?
The third method uses a special parameter named SYSLIST such that SYS-
LIST(i) refers to the ith argument of the current macro expansion.A possible
deﬁnition is
M MACRO no parameters are declared.
LOD SYSLIST(2)STO SYSLIST(1)ENDM
The expansion ‘ M X,Y ’ will generate
LOD Y
STO X
Sec.4.5 OtherFeaturesof Macros 125
4.5.2Delimiting macro parameters
In all the examples shown above, macro parameters were delimited by a comma
‘,’.It is possible, however, to use other characters as delimiters, or to use a schemewhere parameters can be delimited in a general way.Such a scheme is used by the“TeX typesetting system [36] that has many features of a programming language,although its main task is to set type.
In “TeX, a macro can be deﬁned by \def\xyz#1.#2./visiblespace {...}.This deﬁnes a
macroxyzwith two parameters.The ﬁrst is delimited by a period ‘. ’, and the
second, by a period and a space ‘ ./visiblespace’.In the expansion
\xyz-12.45,=a98.62./visiblespaceabc ...
the ﬁrst parameter would be bound to ‘ -12’, and the second, to ‘ 45,=a98.62 ’.Note
that the comma is part of the second actual argument, not a delimiter.Also, theperiod in ‘ 98.62 ’ is considered part of the second argument, not a delimiter.
/
Exercise 4.9 What happens if the user forgets the period-space?
4.5.3 Numeric values of arguments
5.Macro arguments are normally treated as strings.However, Macro , the VAX
assembler, can optionally use the value, rather than the name, of an argument.This is speciﬁed by means of a ‘ \’.A simple example is:
.MACRO CLEER ARG
CLRL R’ARG.ENDM
After deﬁning this macro, we assign ‘ CONS=5 ’, and expand CLEER twice.The
expansion ‘ CLEER CONS ’ generates ‘ CLRL RCONS ’ (which is probably wrong),
whereas the expansion ‘ CLEER \CONS ’ generates ‘ CLRL R5 ’.
4.5.4 Attributes of macro arguments
Each argument in a macro expansion has attributes that can be used to make
decisions—inside the macro deﬁnition—each time the macro is expanded.At thetime the macro deﬁnition is written, the arguments are unknown.They only becomeknown when the macro is expanded, and may have diﬀerent attributes each timethe macro is expanded.
/
Exercise 4.10 Chapter 1 mentions attributes of symbols.What is the diﬀerence
between attributes of symbols and of macro arguments?
We will cover the six attributes supported by the IBM 360 assembler and will
use, as an example, the simple macro deﬁnition:
M MACRO P1
P1ENDM
126 Macros Ch. 4
followed by the three expansions:
M FIRST
M SECM (X,Y,Z) the argument is compound
We assume that symbols FIRST ,SECare deﬁned by:
‘FIRST DC P’+1.25’ ’.DCis the Deﬁne Code directive, and symbol FIRST is the
name of a packed decimal constant.
‘SEC ADD 5,OP ’.Symbol SECis the label of an ADDinstruction
The example illustrates the following attributes:
The count attribute, K, is the length of the actual argument.Thus K‘P1is 5 in
the ﬁrst expansion, 3 in the second one, and 7, in the third.
The type attribute, T, is the type of the actual argument.In the ﬁrst expansion
it is ‘P’ (for Packed decimal) and in the second, ‘ I’ (since the argument is an
Instruction).In the third expansion the type is ‘ N’ (a self-deﬁned term).
The length attribute, L, is the number of bytes occupied by the argument in
memory; 2 in the ﬁrst case, since the packed decimal constant 1.25 occupies twobytes, and 4 in the second case, since the ADDinstruction takes 4 bytes.The
compound argument of the third expansion has no length attribute.
The integer attribute, I, is the number of decimal digits in the integer part of the
argument; 1 in the ﬁrst expansion, 0 in the second.
The scaling attribute, S, is the number of decimal digits in the fractional part of
the argument; 2 in the ﬁrst example and 0 in the second one.
The number attribute, Nonly has a meaning if the argument is compound.It
speciﬁes the number of elements in the compound argument.In the third exampleaboveN‘P1is 3.
The attributes can be used in the macro itself and the most common examples
involve conditional assembly (see later in this chapter).
4.5.5 Directives related to arguments
Macro , the VAX assembler, supports several interesting arguments that make
it easy to write sophisticated macros.Here are a few:
The.NARG directive provides the number of actual arguments.There may be
fewer arguments than parameters.Its format is ‘ .NARG symbol ’ and it return the
number of arguments in the symbol.Thus macro Block below:
.MACRO Block A,B,C,D
.NARG Num
...
.BLKW Num.ENDM
Sec.4.5 OtherFeaturesof Macros 127
creates a block of 1–4 words each time it is expanded, depends on the number of
arguments in the expansion.
The directive .NCHR returns the size of a character string.The general format of
this directive is ‘ .NCHR symbol,<string> ’.Thus after deﬁning:
.MACRO Exmpl L,S
.NCHR Size,S
...
L: .BLKW Size
.ENDM
the expansion ‘ Exmpl M,<Yours T> ’ will generate ‘ M: .BLKW 7 ’
TheIF-ELSE-ENDIF directive, mentioned later in this chapter, can be used to
determine whether an argument is BLANK orNOTBLANK , or whether two arguments
areIDENTICAL orDIFFERENT .It can also be used outside macros to compare any
quantities known in pass 0, and to determine if a pass 0 quantity is deﬁned or not.
4.5.6 Default arguments
Some assemblers allow a deﬁnition such as ‘ N MACRO M1,M2=Z,M3 ’, meaning
that if the actual argument binding M2is null in a certain expansion, then M2will
be bound to Zby default.
/
Exercise 4.11 What is the meaning of ‘ N MACRO M1,M2=,M3 ’?
4.5.7 Automatic label generation
When the deﬁnition of a macro contains a label, successive expansions will
result in the label being multiply-deﬁned.
L MACRO
P1 ..BNZ G12 branch on non-zero to label G12
A LOD .. just a line with a label
..
G12 STO ..
ENDM
Each time this macro is expanded, symbols A,G12will be deﬁned.As a result, the
second and subsequent expansions will cause assembler errors.
Most assemblers oﬀer help in the form of automatically generated unique
names.They are called local labels or automatic labels.Here are two examples,the ﬁrst one from the MPW assembler for the Macintosh computer.The two lineswith labels in the above deﬁnition can be written as:
128 Macros Ch. 4
A SYSNDX LOD ...
G12 SYSNDX STO ...
and every time the macro is expanded, the assembler will append a suﬃx of the
form00001 ,00002 ,...to any label generated.This way all labels generated are
unique.In our example they will be A00001 ,G1200002 ,A00003 ,...
The second example is from Macro , the VAX assembler.When a local label
is needed in a macro, a parameters shoudl be added preceded by a ‘?’.Thus in:
.MACRO ABS A,B,?NEG,?DONE
TSTL ABLSS NEGMOVL A,BBRB DONE
NEG: MNEGL A,BDONE: .ENDM
4.5.8 The IRPdirective
A pair of IRPdirectives, placed inside a macro, deﬁne a sequence of lines.They
direct the assembler to repeatedly duplicate and assemble the sequence a numberof times determined by a compound parameter.Here is an example from the MPWassembler for the Macintosh computer:
MAC MACRO P1,P2 P1 should be a compound parameter.
IRP P1ADD P1 this will be repeated for every component of P1
IRP..ENDM
The sequence to be duplicated consists of the single instruction ADD.Each time it is
duplicated, one of the components of the compound parameter P1is selected.The
expansion:
MAC (A,B,#3),H will generate
ADD AADD BADD #3..
Here is another IRPexample, from Macro , the VAX assembler.
Sec.4.5 OtherFeaturesof Macros 129
.MACRO CallProc Name,A,B,C,D
.NARG Num.IRP Temp,<D,C,B,A>.IIF NOT
BLANK,Temp, PUSHL Temp
.ENDRCALLS #<Num-1>,Name.ENDM
TheIRPdirective loops 4 times, assigning the actual arguments of D, C, B, A to
Temp.The.IIF directive (see Ch.3) generates a PUSHL instruction, to push the
argument’s address on the stack, for any non-blank argument.Finally, a CALLS
instruction is generated, to preform the actual procedure call.This is a handymacro that can be used to call procedures with up to 4 parameters.
IRPstands for Indeﬁnite RePeat.
4.5.9 The PRINT directive
When a program contains many long macros that are expanded many times,
the programmer may not want to see all the expansions listed in the printed out-put.The PRINT directive may be used to suppress listing of macro expansions
(‘PRINT NOGEN ’) or to turn on such listings (‘ PRINT GEN ’).This directive does not
aﬀect the listing of the macro deﬁnitions or of the body of the program.Thoselistings are controlled by the LIST,NOLIST directives.
/
Exercise 4.12 Is thePRINT NOGEN itself listed?
Macro , the VAX assembler, supports the similar directives .SHOW &.NOSHOW .
Thus one can write, e.g., ‘ .NOSHOW ME ’ to suppress listings of all macro expansions
(MEstands for Macro Expansion), or ‘ .SHOW MEB ’ (where MEBstands for Macro
Expansion Binary) to list just lines that actually create binary code generatedduring macro expansions.
4.5.10 Comment lines in macros
If a macro deﬁnition contains comment lines such as in:
MACRO A,B,C
* WATCH OUT, PARAMETER B IS SPECIAL
..CR 1
* THE PREVIOUS LINE CHANGES ITS MEANING
..
The comments should be printed, together with the deﬁnition of the macro, in the
listing ﬁle, but should they also be printed with each expansion? The most general
130 Macros Ch. 4
answer is: It depends.Some comments refer to the lines in the body of the macro
and should be printed each time an expansion is printed (as mentioned elsewhere,the printing of macro expansions is optional).Other comments refer to the formalparameters of the macro, and should be printed only when the macro deﬁnitionis printed.The decision should be made by the programmer, which means thatthe assembler should have two types of comment lines, the regular type, which isindicated by an asterisk, and the special type, indicated by another character, suchas a ‘!’, for comments that should be printed only as part of a macro deﬁnition.
4.6 Nested Macros
Another useful feature of macros is the ability to nest them.This can be done
in two ways: Nested macro deﬁnition and nested macro expansion.We will discussthe latter ﬁrst.
4.6.1 Nested macro expansion
This is the case where the expansion of one macro causes another macro (or
even more than one macro) to be expanded.Example:
C MACRO
COMPJMPENDM
A MACRO
ADDCSUBENDM
B MACRO
LODASTOENDM
There is nothing unusual about macro C.An expansion of macro A, however, is
special since it involves an expansion of C.An expansion of Bis even more involved.
Most assemblers support nested macro expansion since it is useful and also easyto implement.They allow it up to a certain maximum depth.In our example,expanding Bturns out to be nested to a depth of 2.Expanding Cis nested to a
depth of 0.
/
Exercise 4.13 Why is nested macro expansion useful?
To understand how this feature is implemented, we expand macro Bin the
example above.Keep in mind that this is done in pass 0.The assembler locates B
in the MDT and switches to the macro expansion mode.In that mode, it fetchesthe source lines from the MDT instead of from the source ﬁle.Otherwise, that
Sec.4.6 NestedMacros 131
mode is very similar to the normal mode.Each line is identiﬁed as either the name
of a macro, a pass 1 directive, or something else.If the line is the name of amacro, the assembler suspends the expansion of B, fully expands the new macro,
and then returns to complete B’s expansion.If the line is a pass 0 directive, the
assembler executes it.If the line is something else, the assembler scans it, substitutesparameters, and writes the line on the new source ﬁle.During this process theassembler maintains a pointer that always points to the current line in the MDT.
When the expansion of Bstarts, the macro is located in the MDT, and a
pointer is set to point to its ﬁrst line.That line ( LOD) is fetched and identiﬁed as an
instruction.It is written on the new source ﬁle, and the pointer is updated to pointto the second line ( A).The second line is then fetched and is identiﬁed as a macro
name.The assembler then suspends the expansion of Band starts expanding Aby
performing the following steps:
It locates macro Ain the macro deﬁnition table
It sets a new pointer to the ﬁrst line of macro A.
It saves the values of the actual arguments of macro B.
From then on, macro Ais expanded in the usual way until its second line ( C)i s
fetched.At that point the new pointer points to that line.The assembler suspendsthe expansion of Aand starts the expansion of macro Cby performing three steps as
above.While expanding macro C, the assembler uses a third pointer and, since Cis
not nested, the expansion terminates normally and the third pointer is discarded.At that point the assembler returns to the expansion of macro Aand resumes using
the second pointer (which should be incremented to point to the next waiting lineofA).When the expansion of Ais completed, the assembler discards the second
pointer and switches to the ﬁrst one—which means resuming the expansion of theoriginal macro B.Three typical steps in this process are shown in ﬁgure 4–4 below.
In part I, the second line of Bhas been fetched and the (ﬁrst) pointer points to
that line.The expansion of macro Ahas just started and the second pointer points
to the ﬁrst line of A.
In part II, the second pointer points to the second line of A.This means that
the line being processed is the second line of A.The expansion of Chas just started.
In part III, the expansion of Chas been completed, the third pointer discarded,
and the assembler is in the process of fetching the third line of A.
The rules for nested macro expansion therefore are:
In the macro expansion mode, when encountering the name of a macro, ﬁnd it in
the MDT, set up a new pointer to point to the ﬁrst line, save the arguments of thecurrent macro, and continue expanding, using the new pointer.
After fetching and expanding the last source line of a macro, discard the current
pointer and start using the previous one (and the previous set of arguments).
If there is no previous pointer, the (nested) macro expansion is over.
IIIC0 COMP JMP A 0 ADD C SUB B 0 LOD A STOIIC0 COMP JMP A 0 ADD C SUB B 0 LOD A STOIC0 COMP JMP A 0 ADD C SUB B 0 LOD A STO132 Macros Ch. 4
Figure 4–4. Three typical steps in a nested macro expansion.
From this discussion it is clear that the pointers are used in a Last In First Out
(LIFO) order, and should thus be stored in a stack.This stack is called the macro
expansion stack (MES), and its size determines the number of possible pointers and
thus the maximum depth of nesting.
Implementing nested macro expansions is, therefore, done by declaring a stack
and using it while expanding a macro.All other details of the expansion remainthe same as in a normal expansion (however, see conditional assembly below).
The following is a set of rules and a ﬂow chart (ﬁgure 4–5, a generalized subset
of ﬁgure 4–2) which illustrate the main operations of a pass 0 supporting nestedmacro expansions.
1.Input line from MDT (since mode=E).
2.If it is a pass 0 directive, execute it.Goto 1.3.If is is a macro name, start a new expansion.Goto 1.
4.If it is an end-of-macro character, stop current expansion and look back in
MES.
•If MES empty, change mode to N.Goto main input.
•Else—start using previous pointer in MES, remain in E mode.Goto 1.
5.Line is something else, substitute parameters and write line on new source ﬁle.
Goto 1.
empty not emptyexpansion
 mode
1
333
3
3 outputinput mode:=N
Execute itend of
macro
pass 0directiv e
scan line &
substituteparametersmacro
nameopen up a new pointer in MES, to 
point to start of new macro in MDTMES
resume
using
previous
parametersyes
no
yesno
noSec.4.6 NestedMacros 133
Figure 4–5. A Summary of pass 0 with nested macro expansions.
4.7 Recursive Macros
A very important special case of nested macro expansion is the case where a
macro expands itself.Macro NOGOOD below is such an example but, as its name
implies, not a good one.
NOGOOD MACRO
INST1NOGOODINST2ENDM
An attempt to expand this macro will generate INST1 and will then start the inner
expansion.The inner expansion will do the same thing.It will generate INST1 and
start a third expansion.There is nothing in this macro to stop any of the innerexpansions and go back to complete the outer ones.Such an expansion will veryquickly overﬂow the MES, no matter how large it is.
It turns out, though, that such macros, called recursive macros, are very useful.
To implement such a macro, a mechanism is necessary that will stop the recursion(the self expansion) at some point.Such a mechanism is supported by many as-semblers and is called conditional assembly .
134 Macros Ch. 4
4.8 Conditional Assembly
This is a general feature that is not limited to macros.If an assembler supports
this feature then it can be used throughout the program.Its main use, however,happens to be inside macros.In the case of a recursive macro, conditional assemblyis mandatory.In order to stop a recursive expansion, a quantity is needed that willhave diﬀerent values for each inner expansion.By updating this quantity each timean expansion starts, the programmer can stop the recursive expansion when thatquantity satisﬁes a certain condition.
Such a quantity must have two attributes.It must have a value in pass 0 at
assembly time (and thus it cannot be the contents of any register or of memory;they only get deﬁned at run time) and the assembler should be able to change itsvalue (therefore it cannot be a constant or a regular symbol; they have ﬁxed values).Such a quantity must therefore be either an actual argument of a macro or a newfeature, and that feature is called a SETsymbol.
SETsymbols are special symbols that can be deﬁned and redeﬁned by the SET
directive, which is very similar to the EQUdirective.The diﬀerences between SET
andEQUsymbols are:
SETsymbols are only used in pass 0 to implement conditional assembly; EQU
symbols are deﬁned in pass 1 and used in pass 2.The SETdirective is thus a pass
0 directive.
SETsymbols can be redeﬁned.Thus it is permissible to have ‘ Q SET 0 ’ followed
by ‘Q SET 1 ’o rb y‘Q SET Q+1 ’.Qis aSETsymbol and its value can be changed
and used in pass 0.The SETdirective is the only way to redeﬁne symbols (see,
however, the MICCNT directive in chapter 3) but it should be emphasized that SET
symbols are diﬀerent from other symbols.They are stored in a temporary symboltable (the main symbol table does not exist in pass 0) and are discarded at the endof pass 0.The recursive macro above can now be written:
NOGOOD MACRO
INST1
Q SET Q+1
NOGOODINST2ENDM
Before such a macro is expanded, Qneeds to be assigned a value with a SET
directive.Assigning a value to Qin any other way would make it a ﬁxed symbol.
The two source lines:Q SET 1
NOGOOD
will start a recursive expansion where, in each step, the value of Q(in the temporary
symbol table) will be incremented by 1.This expansion is still an inﬁnite one and,in order to stop it after Nsteps, a test is necessary, to compare the value of Qto
Sec.4.8 ConditionalAssembly 135
N.This test is another pass 0 directive, typically called AIF(Assembler IF).Its
general form is ‘ AIF exp.symbol ’, where expis a boolean expression containing
only quantities known to the assembler.The assembler evaluates the expressionand, if its value is true, the assembler goes to the line labeled .symbol .
The next version of the same macro is now:
GOOD MACRO
INST1
Q SET Q+1
AIF Q=N.F ifQequalsNthen go to line labeled .F
GOOD
.F INST2
ENDM
An expansion such as
N EQU 2
Q SET 0
GOOD
will generate the following:
1.INST1 generated for the ﬁrst time
2.Q SET Q+1 setsQto 1 in the temp.symbol table
3.AIF Q=N.F Q not equal Nso do not go to .F
4.GOOD start expanding next level
5.INST1 generated for the second time
6.Q SET Q+1 setsQto 2 in the temp.symbol table
7.AIF Q=N.F Q equals 2 so go to .F
8.INST2 generated for the ﬁrst time.Notice that . F
9.INST2 does not appear since it is not a regular symbol
Of the 9 lines expanded, lines 2, 3, 4, 6, 7 are pass 0 directives.They are executed
and do not appear in the ﬁnal program.Lines 1, 5, 8, 9 are instructions, and arethe only ones actually expanded and written onto the new source ﬁle.
The macro has been recursively expanded to a depth of 2 because of the way
symbolsQ,Nhave been deﬁned.It is also possible to say ‘ AIF Q=2.F ’, in which case
the depth of recursion will depend only on the initial value of Q.
/
Exercise 4.14 Is it valid to write ‘ AIF Q>N.F ’?
An important question that should be raised at this point is: what can Nbe?
Clearly it can be anything known in pass 0, such as another (non-future) SETsymbol,
a constant, or an actual argument of the current macro.This, however, oﬀers onlya limited choice and some assemblers allow Nto be an absolute symbol, deﬁned by
anEQU.AnEQU, however, is a pass 1 directive, so such an assembler should look at
eachEQUdirective in pass 0 and—if the EQUdeﬁnes an absolute symbol—execute
136 Macros Ch. 4
it, store the symbol in the temporary symbol table, and write the EQUon the new
source ﬁle for a second execution in pass 1.In pass 1, all EQUdirectives are executed
and allEQUsymbols, absolute and relative, end up in the permanent symbol table.
Some assemblers go one more step and combine pass 0 with pass 1.This makes
for a very complex pass but, on the other hand, it means that conditional assemblydirectives can use any quantities known in pass 1.They can use the values of anysymbols in the symbol table (i.e., any non-future symbols), the value of the LC,and other things known in pass 1 such as the size of the last instruction read.Thefollowing is an example along these lines.
.
.
PD S 1 0 P is the start address of an array of length 10
ND S 3 N is the start address of an array of length 3 immediately
. following array P.Thus N=P+10
.
Q SET P The value of Qis an address
GOOD depth of recursion will be 10 since
. it takes 10 steps to increment the
. value ofQfrom address Pto address N.
The next example is more practical.It is a recursive macro FACTthat calculates
a factorial.Calculating a factorial is a common process and is done by computersall the time.In our example, however, it is done at assembly time , not at run time.
FACT MACRO N
S SET S+1K SET K*S
AIF S=N.DONFACT N
.DON ENDM
The expansion:
S SET 0
K SET 1
FACT 4
will calculate 4! (=24) and store it in the temporary symbol table as the value of the
SETsymbolK.The result can only be used at assembly time, since the SETsymbols
are wiped out at the end of pass 0.Symbol Kcould be used, for example, in an
array declaration such as: ‘ FACT4DS K ’ which declares FACT4 as an array of length
4!.This, of course, can only be done if the assembler combines passes 0 and 1.
TheFACT macro is rewritten below using the IIFdirective. IIFstands for
Immediate IF .It has the form ‘ IIFcondition,source line’.If the condition is true,
Sec.4.8 ConditionalAssembly 137
the source line is expanded, otherwise, it is ignored.
FACT MACRO N
S SET S+1K SET K*S
IIF S /negationslash=N,(FACT N)
ENDM
Some assemblers support directives such as:
IFT.The general form is ‘ IFTcond’.If the condition is true, the assembler skips
the next source line.
IFF.The general form is ‘ IFFcond’.This is the opposite of IFT.
EXIT.This terminates the present expansion.It is used inside an IF to terminate
the expansion early if a certain condition is true.
IF1,IF2,ENDC.These exist on the MASM assembler for the IBM PC.Anyht-
ing between an IF1and anENDCwill be done (assembled or executed) in pass 1.
Similarly for IF2.These directives are illustrated in the MASM example in Ch.5.
IF-ELSE-ENDIF .These can only appear together and they extend the simple IF
into anIF-THEN-ELSE construct.Example:
IF X=2
line 1
ELSE
line 2line 3
ENDIF
IfX=2, then line 1 will be expanded, otherwise, lines 2 & 3 will be expanded.
/
Exercise 4.15 What can Xbe?
The IBM 360, 370 assemblers, were the ﬁrst ones to oﬀer an extensive condi-
tional assembly facility, and similar facilities are featured by nost modern assem-blers.It is interesting to note that the MPW assembler for the Macintosh computersupports conditional assembly directives that are almost identical to those of the old360.Some of the conditional assembly features supported by the 360, 370 assem-blers will be discussed here, with examples.Notice that those assemblers requireall macro parameters and all SETsymbols to start with an ampersand ’&’.
TheAIFdirective on those assemblers has the format ‘ AIF(exp)SeqSymbol’.
The expression may contain SETsymbols, absolute EQUsymbols, constants, at-
tributes of arguments, arithmetic operators, the six relationals ( EQ NE GT LT GE
LE), the logical operators AND OR NOT , and parentheses.SeqSymbol (sequence sym-
bol) is a symbol that starts with a period.Such a symbol is a special one, it has novalue and is not stored in any symbol table.It is used only for conditional assembly
138 Macros Ch. 4
and thus only exists in pass 0.When the assembler executes an AIFand decides to
go to, say, symbol .F, it searches, in the MDT, for a line labeled .F, sets the current
MES pointer to point to that line, and continues the macro expansion.If a linefetched from the MDT has such a label, the line goes on the new source ﬁle withoutthe label, which guarantees that only pass 0 will see the sequence symbols.In con-trast, regular symbols (address symbols and absolute symbols) do not participatein pass 0.They are deﬁned in pass 1, and their values used in pass 2.
Examples:
AIF (&A(&I) EQ ‘ABC’).TGT where&Ais a compound parameter and &Iis aSET
symbol used to select one component of &A.
AIF (T‘&X EQ O).KL if the type attribute of argument &XisO, meaning a null
argument, then go to symbol .KL.
AIF (&J GE 8).HJ where&Jcould be either a parameter or a SETsymbol.
AIF (&X AND &B EQ ‘(’ ).LL where&Xi saBt y p e SETsymbol (see below) and
&Bis either a C type SETsymbol or a parameter.
TheAGODirective: The general format is ‘ AGOSeqSymbol’.It directs the
assembler to the line labeled by the symbol.(This is an unconditional goto atassembly time, not run time.)
TheANOP(Assembler No OPeration) directive.The assembler does nothing in
response to this directive, and its only use is to provide a line that can be labeledwith a sequence symbol.This directive is used in one of the examples at the end ofthis chapter.
SETsymbols.They can be of three types.A (arithmetic), B (boolean) or C
(character).An A type SETsymbol has an integer value.B type have boolean
values of true/false or 1/0.The value of a C type SETsymbol is a string.
AnySETsymbol has to be declared as one of the three types and its type cannot
be changed.Thus:
LCLA &A,&B
LCLB &C,&DLCLC &E,&F
declare the six symbols as local SETsymbols of the appropriate types.A local SET
symbol is only known inside the macro in which it is declared (or inside a control
section , but those will not be discussed here).There are also three directives to
assign values to the diﬀerent types of SETsymbols.
&A SETA 1
&A SETA &A+1&B SETA 1+(B‘1011’*X‘FF1’-15)/&A-N‘SYSLIST(&A) where B‘1011’ is a binary constant,
X‘FF1’ is a hex constant, and N’ is the number attribute(the number of components) of the second argument of the currentexpansion (the second, because &A=2).
&C SETB (&A LT 5)
Sec.4.8 ConditionalAssembly 139
&D SETB 1 means ‘true’
&E SETC ‘’ the null string
&E SETC ‘12’ the string ‘12’
&F SETC ‘34’&F SETC ‘0&E&F.5’ the string ‘012345’.The dot separates the value of &F from the 5
&E SETC ‘ABCDEF’(2,3) the string ‘BCD’.Substring notation is allowed.
4.8.1 Global SET symbols
The three directives GBLA,GBLB,GBLCdeclare global SETsymbols.This feature
is very similar to the COMMON statement in Fortran.Once a symbol has been declared
global in one macro deﬁnition, it can be declared global in other macro deﬁnitionsthat follow, and all those declarations will use the same symbol.
N1 MACRO
GBLA &S
&S SETA 1
AR &S,2N2ENDM
N2 MACRO
LCLA &S
&S SETA 2
SR &S,2 the local symbol is used
N3ENDM
N3 MACRO
GBLA &SCR &S,2 the global symbol is used
ENDM
The expansion N1will generate
AR 1,2
SR 2,2CR 1,2
140 Macros Ch. 4
4.8.2Array SET symbols
Declarations such as ‘ LCLA &A(7) ’ are allowed, and generate a SETsymbol
which is an array.Such symbols can be very useful in sophisticated applications.
References [25–27] contain more information on the macro facilities of the .The following examples summarize many of the features of conditional assembly
discussed here.
SUM MACRO &L,&P1,&P2,&P3
LCLA &SS
&SS SETA 1&L ST&P1 5,TEMP save register 5 in temp
L&P1 5,&P2(1) load ﬁrst component of P2
.B AIF (&SS GE N‘&P2).F if done go to .F
&SS SETA &SS+1 use&SSas a loop index
A&P1 5,&P2(&SS) add next component of P2
AGO .B loop
.F ST&P1 5,&P3 store sum in P3
L&P1 5,TEMP restore register 5
MEND
The expansion ‘ SUM LAB,D,(A,B,C),DEST ’ will generate
LAB STD 5,TEMP
LD 5,AAD 5,BAD 5,CSTD 5,DESTLD 5,TEMP
This macro uses the conditional assembly directives to loop and generate several
AD(Add Double) instructions.The number of instructions generated equals the
number of components (the N attribute) of the third argument.
A more sophisticated version of this macro lets the user specify, in argument
&REG, which register to use.If argument &REGis omitted (its T attribute equals O)
the macro selects register 5.
SUM MACRO &L,&P1,&P2,&P3,&REG
LCLC &CCLCLC &RRLCLA &AA
&AA SETA 1&CC SETC ‘&L’&RR SETC ‘&REG’
AIF (T‘&REG NE ‘O’).Q is argument &REGa null?
&RR SETC ‘5’ yes, use register 5
Sec.4.8 ConditionalAssembly 141
&CC ST&P1 &RR,TEMP and label this instruction
&CC SETC ‘ ’.Q ANOP a source line just to have a label
&CC L&P1 &RR,&P2(1) this inst.is labeled if &REGis not null
.B AIF (&AA GE N‘&P2).F if done, go to .F
&AA SETA &AA+1
A&P1 &RR,&P2(&AA) the main ADDinstr.to be generated
AGO .B loop
.F ST&P1 &RR,&P3
AIF (T‘&REG NE ‘O’).H same text as above
L&P1 &RR,TEMP restore the register
.H ENDM
The expansion ‘ SUM LAB,D,(A,B,C),DEST, ’ generates code identical to the one
generated for the previous example.The expansion ‘ SUM LAB,D,(A,B,C),DEST,3 ’
will generate similar code, the only diﬀerence being that register 3 will be usedinstead of register 5.
4.9 Nested Macro Deﬁnition
This is the case where the deﬁnition of one macro contains the deﬁnition of
another.Example:
X MACRO
MULT the body of Xstarts here ...
Y MACRO
ADDJMPENDMDIV and ends here.It is 6 lines long
ENDM
The deﬁnition of macro Yis nested inside the deﬁnition of X.This feature is not
as useful as nested macro expansion but many modern assemblers support it (olderassemblers typically did not).In this section we will see what this feature means,and look at two diﬀerent ways of implementing it.
The ﬁrst thing that needs to be modiﬁed, in order to implement this feature, is
the macro deﬁnition mode.In this mode, the assembler reads source lines and storesthem in the MDT until it encounters an ENDM.The ﬁrst modiﬁcation has to do with
theMACRO directive itself.When the assembler reads a line with a MACRO directive
while it is in the macro deﬁnition mode, it treats it as any other line (i.e., it storesit in the MDT) but it also increments a special counter, the deﬁnition level counter ,
by 1.This counter starts at 1 when entering deﬁnition mode, and is updated toreﬂect the current level of nested deﬁnitions.When the assembler encounters anENDMdirective, it decrements the counter by 1 and tests it.If the counter is positive,
the assembler treats the ENDMas any other line.If the counter is zero, the assembler
knows that the ENDMsignals the end of the entire nested deﬁnition, and it switches
back to the normal mode.This process is described in more detail below.
142 Macros Ch. 4
In our example, Xwill end up in the MDT as the 6-line macro:
X0MULTY MACROADDJMPENDMDIV(We ignore any pointers.) Macro Ywill not
be recognized as a macro but will be stored in the MDT as part of the deﬁnition ofmacroX.
Another method for matching MACRO-ENDM pairs while reading-in a macro deﬁ-
nition is to require each ENDMto contain the name of the macro it terminates.Thus
the above example should be written:
X MACRO
MULT
Y MACRO
ADDJMPENDM YDIVENDM X
This requires more work on the part of the programmer but, on the other hand,
makes the program easier to read.
/
Exercise 4.16 In the case where both macros X,Yend at the same point
X MACRO
--
Y MACRO
--ENDM YENDM X
do we still need two ENDMlines?
The next thing to modify is the macro expansion mode.While expanding
macroX, the assembler will encounter the inner MACRO directive.This implies that
the assembler should be able to switch to the macro deﬁnition mode from the macroexpansion mode, and not only from the normal mode.This feature does not addany special diﬃculties and is straightforward to implement.While in the macroexpansion mode, if the assembler encounters a MACRO directive, it switches to the
macro deﬁnition mode, allocates an available area in the MDT for the new deﬁnitionand creates that deﬁnition.Speciﬁcally, the assembler:
fetches the next source line from the MDT, not from the source ﬁle.
stores the line in the macro deﬁnition table, as part of the deﬁnition of the new
macro.
repeats until it encounters an ENDMline (more precisely, until it encounters an ENDM
line that matches the current MACRO line).At this point the assembler switches back
to the macro expansion mode, and continues with the normal expansion.
Sec.4.9 NestedMacroDeﬁnition 143
Now may be a good point to mention that such nesting can be done in one
direction only.A macro expansion may cause the assembler to temporarily switch tothe macro deﬁnition mode; a macro deﬁnition, however, cannot cause the assemblerto switch to the expansion mode.When the assembler is in a macro expansionmode, it may expand a macro with nested deﬁnition, so it has to enter the macrodeﬁnition mode from within the macro expansion mode.However, if the assembleris in the macro deﬁnition mode and the macro being deﬁned speciﬁes the expansionof an inner macro, the assembler does not start the nested expansion while in theprocess of deﬁning the outer macro.It therefore does not enter the macro expansionmode from within the macro deﬁnition mode.The reason being that when a macrois deﬁned, its deﬁnition is stored in the MDT without any attempt to assemble,execute, or expand anything.As a result, the assembler can only be in one of thefour following modes: normal, deﬁnition, expansion, & deﬁnition inside expansion.They will be numbered 1–4 and denoted N,D,E,& DE, respectively.
In the example above, when macro Xis deﬁned, macro Ybecomes part of the
body ofXand is not recognized as an independent macro.When Xis expanded,
though, macro Yis deﬁned and, from that point on, Ycan also be expanded.The
only reason to implement and use this feature is that macro Xcan be expanded
several times, each expansion of Xcreating a deﬁnition of Yin the MDT, and those
deﬁnitions—because of the use of parameters—do not have to be the same.
Each time Yis expanded, the assembler should, of course, expand the most
recent deﬁnition of Y(otherwise nested macro deﬁnition would be a completely
useless feature).Expanding the most recent deﬁnition of Yis simple.All that the
assembler has to do is to search the MDT in reverse order ; start from the new macros
and continue with the older ones.This feature of backward search has already beenmentioned, in connection with macros that redeﬁne existing instructions.
The above example can be written, with the inclusion of parameters, and with
some slight changes, to make it more realistic.
X MACRO A,B,C,D
MULT A
Y MACRO C
CADD DIRJMP BENDM YDIV CYDENDM X
The body of Xnow contains a deﬁnition of Yand also an expansion of it.An
expansion of Xwill generate:
AMULTinstruction.
A deﬁnition of Yin the MDT.
144 Macros Ch. 4
ADIVinstruction.
An expansion of Y, consisting of three lines, the last two of which are ADD,JMP.
The expansion X SEC,TOR,DIC,BPL will generate:
MULT SEC ﬁrst line
Y MACRO C macroYgets stored
C in the macro deﬁnition
ADD DIR table with the Bparameter
JMP TOR changed to TORbut with
ENDM Y theCparameter unchanged
DIV DIC second line
Y BPL a line which is expanded to give -
BPL third line. BPLis substituted for the Cparameter
ADD DIR fourth line
JMP TOR ﬁfth line
The only thing that may be a surprise in this example is the fact that macro Y
is stored in the MDT without Cbeing substituted.In other words. Yis deﬁned as
‘Y MACRO C ’ and not as ‘ Y MACRO DIC ’.The rule in such a case is the same as in a
block structured language.Parameters of the outer macro are global and are knowninside the inner macro unless they are redeﬁned by that macro.Thus parameter B
is replaced by its value TORwhenYis deﬁned, but parameter Cis not replaced by
DIC.
Since we are interested in how things are done by the assembler, the imple-
mentation of this feature will be discussed in detail.In fact, we will describe indetail two ways to implement nested macro deﬁnitions.One is the traditional way,described in [28,61].The other, due to Revesz [81] is newer and more elegant.
4.9.1 The traditional method
Normally, when a macro deﬁnition is entered into the MDT, each parameter
is replaced with a serial number #1, #2, ...To support nested macro deﬁnition,
the assembler replaces each parameter, not with a single serial number, but with apair of numbers (deﬁnition level, serial number).To determine those pairs, a stack,called the macro deﬁnition stack (MDS), is used.
When the assembler starts pass 0, it clears the stack and initializes a special
counter (the Dlevel counter mentioned above) to 0.Every time the assembler en-counters a MACRO line, it increments the level counter by 1 and pushes the names
of the parameters of that level into the stack, each with a pair (level counter, i)
attached, where iis the serial number of the parameter.The assembler then starts
copying the deﬁnition into the MDT, comparing every token on every line with thestack entries (starting with the most recent stack entry).If a token in one of themacro lines matches a stack entry, the assembler considers it to be a parameter (ofthe current level or any outer one).It fetches the pair (l, i) from the stack entry
that matched, and stores #(l, i) in the MDT instead of storing the token itself.If
Sec.4.9 NestedMacroDe ﬁnition 145
the token does not match any stack entry, it is considered a stand-alone token and
is copied into the MDT as part of the source line.
When an ENDMis encountered, the stack entries for the current level are popped
out and Dlevel is decremented by 1.After the last ENDMin a nested deﬁnition is
encountered, the stack is left empty and Dlevel should be 0.
The example below shows three nested deﬁnitions and the contents of the MDT.
It also shows the macro deﬁnition stack when the third, innermost, deﬁnition isprocessed (the stack is at its maximum length at this point).
The following points should be noted about this example:
Lines 3,5,8,10 in the MDT show that the assembler did not treat the inner macros
Q,Ras independent ones.They are just part of the body of macro P.
On line 4, the #(2,1) in the MDT means parameter 1 ( A) of level 2 ( Q), while the
#(1,3) means parameter 3 ( C) of level 1 ( P).
On line 7, #(3,3) is parameter 3 ( E)o fl e v e l3( R) and not that of level 2 ( Q).The
His not found in the stack and is therefore considered a stand-alone symbol, not a
parameter.
On line 11, the assembler is back to level 1 where none of the symbols is a pa-
rameter.The stack at this point only contains the four bottom lines, and symbolsE,F,G,H are all considered stand-alone.
# source line
MDT
1P MACRO A,B,C,D P 4
2A,B,C,D #(1,1),#(1,2),#(1,3),#(1,4)
3Q MACRO A,B,E,F Q MACRO #(2,1),#(2,2),#(2,3),#(2,4)
4A,B,C,D #(2,1),#(2,2),#(1,3),#(1,4)
5R MACRO A,C,E,G R MACRO #(3,1),#(3,2),#(3,3),#(3,4)
6A,B,C,D #(3,1),#(2,2),#(3,2),#(1,4)
7E,F,G,H #(3,3),#(2,4),#(3,4),H
8ENDM R ENDM R
9E,F,G,H #(2,3),#(2,4),G,H
10ENDM Q ENDM Q
11E,F,G,H E,F,G,H
12ENDM P
Figure 4–6 is a ﬂow chart (a generalized subset of ﬁgure 4–2) summarizing the
operations described above.
146 Macros Ch. 4
stack
G (3,4) top
E (3,3)C (3,2)A (3,1)F (2,4)E (2,3)B (2,2)A (2,1)D (1,4)C (1,3)B (1,2)A (1,1) bottom
4.9.2Revesz’s method
There is another, newer and more elegant method—due to G.Revesz [81]—for
implementing nested macro deﬁnitions.It uses a single serial number—instead ofa pair—to tageach macro parameter, and also has the advantage that it allows for
an easy implementation of nested macro expansions and nested macro deﬁnitionswithin a macro expansion.
The method is based on the following observation: When a macro Ais being
deﬁned, we are only concerned with the deﬁnition of A(the level 1 deﬁnition) and
not with any inner, nested deﬁnitions, since Ais the only one that is stored in the
MDT as a separate macro.In such a case why be concerned about the parametersof all the inner, higher level, nested deﬁnitions inside A? Any inner deﬁnitions are
only handled when Ais expanded, so why not determine their actual arguments at
that point?
This is an example of an algorithm where laziness pays.We put oﬀ any work
to the latest possible point in time, and the result is simple, elegant, and correct.
The method uses the two level counters Dlevel and Elevel as before.There are
also three stacks, one for formal parameters (P), the second for actual arguments(A), and the third, (MES), for the nested expansion pointers.A non-empty formalparameter stack implies that the assembler is in the deﬁnition mode (D), and anon-empty argument stack, that it is in the expansion mode (E).By examining thestate (empty/non empty) of those two stacks, we can easily tell in which of the 4modes the assembler currently is.
Following are the details of the method in the case of a nested deﬁnition.When
the assembler is in mode 1 or 3, and it ﬁnds a MACRO line, it switches to mode 2 or
4 respectively, where it:
1.Stores the names of the parameters in stack P, each with a serial number
attached.Since stack P should be originally empty, this is level 1 in P.
no
yes
yes no2
5
5 67
inputDlevel:= Dlevel+1
Dlevel=1
?
Clear MDS. Locate space in MDS for 
a new macro. Store macro name in MDT
Scan parameters. For each par, push 
its name and the pair (Dlevel,i) in MDS
MENDSec.4.9 NestedMacroDe ﬁnition 147
Figure 4–6. The classical method for nested macro deﬁnitions (part I).
2.Opens up an area in the MDT for the new macro.
3.Brings in source lines to be stored in the MDT, as part of the new deﬁnition.
Each line is ﬁrst checked to see if it is a MACRO or aMEND.
4.If the current source line is MACRO , the line itself goes into the MDT and the
assembler enters the names of the parameters of the inner macro in stack P asa new, higher level.Just the names are entered, with no serial numbers.
This, again, is an important principle of the method.It distinguishes between
the parameters of level 1 and those of the higher levels, but it does not distinguishbetween the parameters of the diﬀerent higher levels.Again the idea is that, atmacro deﬁnition time we only handle the level 1, outer macro, so why bother toresolve parameter conﬂicts on higher levels at this time.Such conﬂicts will beresolved by the same method anytime an inner macro is deﬁned (becomes level 1).
5.If the current line is a MEND, the line itself again goes into the MDT and the
assembler removes the highest level of parameters from P.Thus after ﬁnding
no yes
yes no
165
7
7Break lines up into tokens.
Compare every token with
all param names in MDS,
 from to p to bottom
match
Store token
in MDTFetch the pair (l,i) 
associated with the 
matched name
Store (l,i) in MDT 
instead of tokenPop up all MDS entries
 for current Dlevel
Dlevel:= Dlevel+1
Dlevel=0
?
mode:=N148 Macros Ch. 4
Figure 4–6. The classical method for nested macro deﬁnitions (part II).
the lastMEND, stack P should be empty again, signifying a non-macro deﬁnition
mode.The assembler should then switch back to the original mode (either 1or 3).
6.If the source line is neither of the above, it is scanned, token by token, to de-
termine what tokens are parameters.Each token is compared with all elementson stack P, from top to bottom.There are three cases:
a: No match.The token is not a parameter of any macro and is not replaced
by anything.
b: The token matches a name in P that does not have a serial number at-
tached.The token is thus a parameter of an inner macro, and can beignored for now.We simply leave it alone, knowing that it will be re-placed by some serial number when the inner macro is eventually deﬁned(that will happen when some outer macro is eventually expanded).
c: The token matches a name in P that has a serial number attached.The to-
NE
DDED,DEN,E
mode
yes
outputmode
mode
6
6
77pass 0
Initialize
Dlevel:=0Elevel:=0
mode:=N
N,DE,DE
Read next
line from
source fileIncrement pointer
located at top of
MES. Use it to read
next line from MDT
eof
?
end of
pass 0MACRO?
ENDM?
macro name?2
43
5
88
1Sec.4.9 NestedMacroDe ﬁnition 149
Figure 4–7a. Revesz’s method for nested macro deﬁnitions (part I).
ken is thus a parameter of the currently deﬁned macro (the level 1 macro),
and is replaced by the serial number.
After comparing all the tokens of a source line, the line is stored in the MDT.
It is a part of the currently deﬁned macro.
The important point is that the formal parameters are replaced by serial num-
bers only for level 1, i.e., only for the outermost macro deﬁnition. For all othernested deﬁnitions, only the names of the parameters are placed on the stack, re-ﬂecting the fact that only level 1 is processed in macro deﬁnition mode.That levelends up being stored in the MDT with each of its parameters being replaced by aserial number.
On recognizing the name of a macro, which can happen either in mode 1
(normal) or 3 (expansion), the assembler enters mode 3, where it:
=0>1
=1
D,
DEEN
=1MACRO
ENDM
Dlevel
mode:=Nmode2
3
11Dlevelmode:=DE mode:=D
Dlevel:=
Dlevel+1
Push all
 params into stack P, but
 without #iAllocate space
 in MDT for 
new macro. Push 
each param, with 
#i attached, 
into P
Generate the 1st macro
line in MDT
‘name MACRO #1 #2 ..’Error! 
Unmatched
ENDMPlace      incurrent def
in MDTCopy line 
into current 
definition
in MDT
Dlevel:=0
mode:=NPop current
 level of 
params 
from P
Dlevel:=
Dlevel+1>1150 Macros Ch. 4
Figure 4–7b. Revesz’s method for nested macro deﬁnitions (part II).
7.Loads stack A with a new level containing the actual arguments.If the new
macro has no arguments, the new level is empty, but it should always be instack A as a level.
8.Inserts a new pointer in the MES, pointing to the ﬁrst line—in the MDT—of
the macro to be expanded.
9.Starts expanding the macro by bringing in individual lines from the MDT.
Each line is scanned and all serial numbers are replaced by arguments fromstack A.The line is then checked to distinguish three cases:
1macro name
6
74
For each token on source line, 
if token is #i, search stack A 
top to bottom. On finding a match, 
replace #i with argument from A.
For each token on source line, 
search stack P, top to bottom,
 for a pair (token,#i). 
If found, replace token with #imode:=E
Elevel:=Elevel+1
Push actual args, with
#i attached, into stack A
Push a new pointer into
MES, pointing to 1st line
of macro to be expandedSec.4.9 NestedMacroDe ﬁnition 151
Figure 4–7c. Revesz’s method for nested macro deﬁnitions (part III).
d: The line is MACRO , the assembler enters mode 4 (deﬁnition mode within
expansion mode) and follows rules 1–6 above.
e: The current line is MEND, the assembler again follows the rules above and
may decide, if this is the last MEND, to return from mode 4 back to mode
3.
f: For any other line, the line is written on the new source ﬁle as explained
earlier.
On recognizing the end of the macro (no more lines to expand), the assembler:
10.Removes the highest level from stack A.
11.Deletes the top pointer from the MES.
12.Checks the MES and stack A. There are three cases:
g: Neither is empty.There is an outer level of expansion, the assembler stays
in mode 3 and resumes the expansion as above.
h: Only one is empty.This should never happen and can only result from
a bug in the assembler itself.The assembler should issue a message like‘impossible error, inform a systems programmer’.
i: Both are empty.This is the end of the expansion.The assembler switches
to mode 1.
D,
DE=0
N=0 >0
E
=0>1
=1
DDEmode5
11
1Dlevel
Elevel
Dlevel
Elevel
>0Error!
illegal   
character
read while
in normal
modePop current
level of args 
from stack A
Pop top of MES
Elevel:=Elevel-1
mode:=E mode:=NDlevel:=Dlevel-1Copy    into current
definition in MDT>0152 Macros Ch. 4
Figure 4–7d. Revesz’s method for nested macro deﬁnitions (part IV).
The following example illustrates a macro L1whose deﬁnition is nested by L2
which, in turn, is nested by a level 3 macro, L3.
1L1 MACRO A,B,C,D L1 #1#2#3#4
2MOV A,B MOV #1#2
3CMP C,D CMP #3#4
4L2 MACRO E,F,D,C L2 MACRO E,F,D,C L2 #1#2#3#4
5MOV E,C MOV E,C MOV #1,#4
6CMP A,X CMP #1,X CMP M,X
7L3 MACRO A,E,C,G L3 MACRO A,E,C,G L3 MACRO A,E,C,G L3 MACRO #1#2#3#4
8MOV C,E MOV C,E MOV C,#1 MOV #3,W
9CMP A,G CMP A,G CMP A,G CMP #1,#4
10MEND L3 MEND L3 MEND L3 (end of macro)
Sec.4.9 NestedMacroDe ﬁnition 153
11ADD A,F ADD #1,F ADD M,#2
12SUB C,B SUB C,#2 SUB #4,N
13MEND L2 MEND L2 (end of macro)
14ADD E,F ADD E,F
15SUB G,B SUB G,#2
16MEND L1 (end of macro)
Source deﬁnition Deﬁnition of L1 Deﬁnition of L2 Deﬁnition of L3
When macro L1is deﬁned, in pass 0, the result is a 14 lines deﬁnition (lines
2–15) in the MDT.During the deﬁnition, stack P goes through several levels asbelow:
after
line 1 4 7 10 13 16
D # 4CGCD # 4
C # 3 DCDC # 3 empty
B # 2 FEEB # 2A # 1 EAFA # 1
D# 4C D# 4C# 3 D C# 3B# 2 F B# 2A# 1 E A# 1
D# 4C# 3B# 2A# 1
WhenL1is ﬁrst expanded with, say, arguments M,N,P,Q , it results in:
1.The 14 lines brought from the MDT and examined.Lines 2,3,14,15 are even-
tually written on the new source ﬁle, as: MOV M,N CMP P,Q ADD E,F SUB G,N .
2.Lines 4–13 become the 8-line deﬁnition of L2in the MDT as shown above.
Later, when L2is expanded, with arguments W,X,Y,Z , it results in:
1.Lines 5,6,11,12 written on the new source ﬁle as:
MOV W,Z CMP M,X ADD M,Y SUB Z,M .
2.Lines 7–10 stored in the MDT as the 2-line deﬁnition of L3.From that
point on, L3can also be expanded.
Figure 4–7 is a summary of this method, showing how to handle nested macro
deﬁnitions and expansions, as well as deﬁnition mode nested inside expansion mode.
154 Macros Ch. 4
4.9.3 A note
The T EX typesetting system, mentioned earlier, supports a powerful macro
facility that also allows for nested macro deﬁnitions.It is worth mentioning herebecause it uses an unconventional notation.To deﬁne a macro awith two parame-
ters, the user should say ‘ \def\a#1#2 {...#1...#2... }’.Each#prefers to one of
the parameters.To nest the deﬁnition of macro binsidea, a double ##notation
is used.Thus in the deﬁnition ‘ \def\a#1 {..#1..\def\b##1 {..##1..#1 }}’ the
notation ##1refers to the parameter of b, and#1, to that of macro a.
The rule is that each pair ##is reduced to one #.This way, macro deﬁnitions
can be nested to any depth.
Example:
\def\a#1 {‘#1’\def\b##1 {[#1,##1] \def\x####1 {(#1,##1,####1) }\x X }\b Y }
The deﬁnition of macro aconsists of:
Printinga’s parameter in quotes.
Deﬁning macro b.
Expanding bwith the argument Y.
Similarly, the deﬁnition of macro bincludes:
Printinga’s parameter and b’s parameter in square brackets.
Deﬁning macro xwith one parameter.
Expanding xwith the argument X.
Macroxsimply prints all three arguments, a’s,b’s and its own, in parentheses.
/
Exercise 4.17 What is the result of the expansion \a A?
The reader should convince himself that the rule above really allows for unlim-
ited nesting of macro deﬁnitions.
4.10 Summary of Pass 0
In order to concentrate all macro operations in one place, many assemblers
perform an additional pass, pass 0, mentioned before, in which all macros are deﬁnedand expanded.The result of pass 0 is a new source ﬁle that serves as the sourceinput for pass 1.To simplify the handling of macros, many assemblers require allmacros to be deﬁned at the beginning of the program.The last ENDMin that block of
macro deﬁnitions is followed by a source line that is not a MACRO , and this signals to
the assembler the end of macro deﬁnitions.From that point on, the assembler only
Sec.4.10 Summary of Pass 0 155
expects macro expansions and will ﬂag any macro deﬁnition as an error.Example :
BEGIN EX
A MACRO P,Q
..ENDM
M MACRO C,II
..ENDM
XD S 1 2 an array declaration
N MACRO
..ENDM..
The deﬁnition of macro Nwill be ﬂagged since it occurs too late in the source.
With this separation of macro deﬁnition and expansion, pass 0 is easy to im-
plement.In the normal mode such an assembler simply copies the source ﬁle intothe new source.Macro deﬁnitions only aﬀect the MDT, while macro expansionsare written onto the new source ﬁle.
Such an assembler, however, cannot support nested macro deﬁnitions.They
generate new macro deﬁnitions too late in pass 0.
An assembler that supports nested macro deﬁnitions cannot impose the re-
striction above, and can only require the user to deﬁne each macro before it isexpanded.
Having a separate pass 0 simpliﬁes pass 1.The ﬂow charts in his chapter prove
that pass 0 is at least as complicated as pass 1, so keeping them separate reducesthe total size and the complexity of the assembler.Combining pass 0 and pass 1,however, has the following advantages:
No new source ﬁle needed, saving both ﬁle space and assembly time.
Procedures—such as input procedures or procedures for checking the type of a
symbol—that are needed in both passes, only need to be implemented once.
All pass 1 facilities (such as EQUand other directives) are available during macro
expansion.This simpliﬁes the handling of conditional assembly.
156 Macros Ch. 4
4.11 Review Questions and Projects
1.The process of expanding a macro includes two main steps, binding the for-
mal paremeters to their actual arguments, and substituting each parameter in themacro’s body by its bound argument.Write a procedure, in pseudo-code, to imple-ment the two steps.Assume that nested macro deﬁnition is not allowed, but nestedmacro expansion is allowed.
2.The syntax of macro deﬁnition and expansion diﬀers from assembler to assem-
bler.Use several textbooks and assembler manuals to study diﬀerent conventionsof deﬁning macros and naming parameters.Summarize the resuts in a table of theform:
Syntax of Syntax of Maximum # Maximum #
macro def param-names of macros of params per macro
Assembler A
Assembler B
––
3.Continue the table of question 2 with columns for: Types of SETsymbols, Syntax
ofSETsymbol name, Syntax of sequence symbol name.
4.A macro named LODcan be used to redeﬁne the LODinstruction.An assembler
supporting this feature simply searches the MDT backwards.What is another wayof redeﬁning assembler instructions?
5.Review the block structure feature found in higher-level languages.What is the
main diﬀerence between this feature and the scope of parameters in a nested macrodeﬁnition?
6.What stacks are involved in nested macro deﬁnition and expansion? When (in
what passes) are these stacks used? Is it possible to use the memory occupied bythese stacks for something else?
7.What is a pass 0 directive? Make a list of all pass 0 directives mentioned in this
chapter .
8.Compare the two methods described in this chapter for MDT implementation,
the one with the MNT and the one without it.
9.Apply the two methods described in this chapter for handling nested macro
deﬁnition to the case:
Sec.4.11 Review Questionsand Projects 157
A MACRO
--
B MACRO
--ENDM B--
C MACRO
--ENDM C--ENDM A
The deﬁnitions of the two macros B,Care nested in the deﬁnition of A, but are
separate (not nested inside each other).
10.What is the main diﬀerence between the parameters of a macro and those of a
procedure?
11.How should a programmer decide whether to use a macro or a procedure in a
given situation?
4.11.1 Project 4–1
Modify project 3–1 to include macros with parameters.The macros should
also support unique label generation but should not be nested in any way.Noconditional assembly is necessary.
4.11.2Project 4–2
TheEQU,DCdirectives are very useful.In fact, they can be used, together with
theMACRO ,ENDMdirectives, to implement an assembler.The following macro:
ADD MACRO P1,P2,P3
P1 EQU *
BYTE 2ABYTE P2BYTE P3
LC SET LC+3
ENDM
may be used to assemble an ADDinstruction.The expansion ‘ ADD X,2,Y ’ would
158 Macros Ch. 4
result in:
X EQU * LabelXdeﬁned and set to the current LC
BYTE 2A OpCode of ADD
BYTE 2 Register 2
BYTE Y The value of Y(from the symbol table) is substituted
After writing such a macro for every instruction, source programs can easily be
assembled.Most instructions contain ﬁelds that are longer or shorter than one byte,so a data-generating directive is necessary, that would be more general than BYTE.
TheDCdirective, for example, could be modiﬁed such that ‘ DC 17(2,6) ’ would
generate the constant 17 = 1001
2as a 6-bit ﬁeld, starting at bit position 2 of the
current byte.The result is xx010001 where the xxﬁeld should be ﬁlled by the next
DC.
Your task: Select a simple assembler language, such as the one described in
project 1–1, and implement it by writing a full set of such macros.
...the church is founded and founded irremovably because founded, like
the world, macro macro and microcosm, upon the void
—James Joyce, Ulysses
...Then there are young men who dance around and get paid by the
women, they’re called ‘macros’ and aren’t much use to anyone ...
—No¨el Coward, To Step Aside, (1939)
Bostonians calmly die
—Anonymous, (An anagram of ‘conditional assembly’)
5. The Listing File
The listing ﬁle is the second output of the assembler. It is generated in pass 2,
and is eventually printed. To be useful, such a ﬁle should include, for each sourceline, a copy of the source (including comments) and the object codes, the value ofthe LCfor the instruction, and any error messages pertaining to the line.
In addition, the listing may, optionally, contain a cross reference table of all the
symbols used in the program. This is a list of all symbols, sorted alphabetically bysymbol name, with their values and attributes and, for each symbol, the LCvaluesof all the instructions using it. If a symbol is used a lot in the program, the crossreference for it may require more than one line of print. The cross reference can bean invaluable debugging tool and is generated by many assemblers. It contains allthe information in the symbol table and more.
It has already been mentioned, in chapter 1, that a one-pass assembler cannot
print the values of future symbols in the listing. Thus, for this type of assembler,the cross reference table is certainly important.
To implement the cross reference table, another column is added to the symbol
table, with a pointer to a linked list. Each node in this list contains the LCvalue foran instruction using that symbol. The lists are built in pass 2, while instructions areassembled. Each time an instruction uses a symbol, the symbol table is searched.On locating the symbol, its value is used in assembling the instruction, and anothernode is added to the list of that symbol.
160 The ListingFile Ch. 5
Because of the work involved in preparing the cross-reference information, and
because this information is important, the MASM assembler has a separate utility,CREF, to prepare the cross-reference listing.
The only use the assembler makes of comments is to write them on the listing
ﬁle. Therefore, each comment must be transferred from pass 1 to pass 2 in theintermediate ﬁle. A similar thing is true for macros. In principle, passes 1 and 2need to know nothing about macros. In practice, however, they have to be involvedin a limited way, because some macro information has to be included in the listing.The listing ﬁle should include all the source code of the macro deﬁnitions (except thedeﬁnitions of system macros). Since a macro may be expanded many times and theexpansions may be similar, listing the expansions is optional. All this informationmust be written, by pass 0, on the new source ﬁle. Pass 1, in turn, reads it, andwrites it on the intermediate ﬁle. Finally, pass 2 reads it oﬀ the intermediate ﬁleand writes it on the listing ﬁle, in a readable format.
Some source lines are directives that do not generate any object code, and an
interesting question is what to print in the object code ﬁeld when these lines arelisted. Each assembler may print something else, but the following examples aretypical.
‘A: EQU 1 ’. The operand ‘ 1’ should be printed in the object code ﬁeld, since
the operand of the EQUmay be an address expression (as in ‘ EQU B+G ’), and the
programmer should be able to see the value of that expression. The same thing istrue for other directives such as DS,ORG,...
/
Exercise 5.1 What should be printed in the object code ﬁeld when a macro deﬁ-
nition is listed?
‘Y: DC 11,2,‘$’ ’. The ﬁrst constant (11) should be printed. The complete list
of constants generated by the DCmay be too long but, if the programmer wants to
see it, a special directive such as PDC(print deﬁned constants) may be used.
Chapter 3 mentions several directives used to control the listing. They can
be used to print a title and a sub-title (including, perhaps, the date and time) onevery page, to suppress the listing or parts of it, to eject a page at any point in thelisting, and to control the listing of the cross-reference and of macros. In general,such directives are executed in pass 2 and are easy to implement.
5.1 A 6800 Example
The ﬁrst example is part of a listing produced by the 6800 assembler. It is
simple and easy to read.
TITLE OF PROGRAM 6800 ASSEMBLER PAGE 1
SUBTITLE VER 1.5 DEC. 10,1991
line LC Object Source
00001 NAME SOLVE
Sec.5.1 A 6800Example 161
00002 ************************
00003 * THIS PROGRAMS SOLVES...00004 * IT ALSO GENERATES THE ...00005 * AND, FINALLY, THE ...00006 ************************00007 *00008 0000 ORG 000009 *00010 * EXTERNAL PROCEDURES DEFINITION00011 *00012 E1D1 OUTCH EQU $E1D1 OUTPUT SINGLE CHAR.00013 E1AC INCH EQU $E1AC INPUT CHAR.00014 E07E PDATA1 EQU $E07E PRINT MESSAGE00015 *00016 * INTERNAL STORAGE00017 *00018 0000 0A DEFLT BYTE 10 DEFAULT IS DECIMAL00019 0001 00 BASE BYTE 0 BASE=DEFAULT00020 0002 00 ROTCNT BYTE 0 COUNT FOR ROTATE00021 0003 0000 INVAL WORD 0 VALUE OF INPUT00022 0005 0000 TMPVAL WORD 0 TEMP. INPUT00023 0007 00 INCNT BYTE 0 COUNT OF INPUT CHARS.00024 0008 00 LSTCHR BYTE 0 LAST CHAR BEFORE CR
TITLE OF PROGRAM 6800 ASSEMBLER PAGE 2
INITIALIZE VER 1.5 DEC. 10,1991
line LC Object Source
00025 0009 96 00 VALIN LDA A DEFLT START INPUT
00026 000B 97 01 STA A BASE00027 000D 7F 0003 CLR INVAL HIGH ORDER BYTE00028 0010 7F 0004 CLR INVAL+1 LOW ORDER BYTE00029 0013 BD 0231 JSR MSGIN WAIT FOR INPUT00030 0016 CE A018 LDX #BUFFER GET ADDRESS OF BUFF.00031 0019 A6 00 LDA A 0,X FIRST CHAR.00032 *00033 001B 81 42 CMP A #’B START OF ’BASE’?00034 001D 26 4D BNE PRCHK NO, LOOK FOR PREFIX00035 *00036 * SEE IF ATTEMPT TO CHANGE DEFAULT BASE00037 * MUST BE IN THE FORM:00038 * BASE XX, WHERE XX=2,8,10,1600039 *00040 001F C0 05 SUB B #5 MUST BE 6 OR 7 CHARS00041 0021 2F 47 BLE BASERR IF LE 5, ERROR00042 0023 D7 07 STA B INCNT STORE TO CHECK LATER00043 0025 08 INX POINT PAST ’ASE’
162 The ListingFile Ch. 5
00044 0026 08 INX
00045 0027 08 INX00046 0028 08 INX00047 0029 08 INX FINALLY, POINT TO IT00048 *
TITLE OF PROGRAM 6800 ASSEMBLER PAGE 3
INPUT MESSAGE VER 1.5 DEC. 10,1991
line LC Object Source
00049 002A A6 00 LDA A 0,X LOAD INDEXED AS USUAL
00050 002C C6 0A LDA B #10 USE VALID. CHECK00051 002E BD 021E JSR VALCK00052 0031 81 09 CMP A #9 HAS TO BE DECIMAL00053 0033 2E 35 BGT BASERR ELSE ERROR00054 0035 7A 0007 DEC INCNT WAS THAT LAST DIGIT00055 0038 27 1C BEQ BVALCK YES, CHECK BASE00056 003A 08 INX NO, POINT TO NEXT00057 *00058 003B 97 01 STA A BASE STORE DIGIT IN BASE00059 003D A6 00 LDA A 0,X00060 003F C6 0A LDA B #10
...
00083 0066 97 00 BASTOR STA A DEFLT FINALLY, REPLACE IT00084 0068 20 9F BRA VALIN READ INPUT AGAIN00085 *00086 006A 20 5C BASERR BRA ERROR BRANCH TO ERR ROUTINE00087 *00088 006C 81 25 PRCHK CMP A #’% IS IT BINARY?00089 006E 26 04 BNE OCPCK NO, CHECK IF OCTAL00090 0070 86 02 LDA A #2 LOAD 2 FOR BINARY
..
TITLE OF PROGRAM 6800 ASSEMBLER PAGE 5CHECK FOR PREFIX VER 1.5 DEC. 10,1991
line LC Object Source
.
.
00108 *00109 008A 97 01 PRINIT STA A BASE REPLACE BASE00110 008C 08 INX00111 008D 7A 0007 DEC INCNT
..
Sec.5.1 A 6800Example 163
.
00450 A06D 20444543 DECM FCC / DEC/00451 A071 04 BYTE 400452 A072 20484558 HEXM FCC / HEX/00453 A076 04 BYTE 400454 A077 0D0A0000 CRLFM BYTE $D,$A,0,0,4
A078 04
00455 *00456 A018 ORG $A01800457 A018 BUFFER RMB 20 INPUT BUFFER00458 *00459 A02C END
ERROR SUMMARY
0 ERROR(S) IN ASSEMBLY
BINARY SUMMARY
684 BYTES OUTPUT684 BYTES TO RAM0 BYTES TO ROM
TITLE OF PROGRAM 6800 ASSEMBLER PAGE 14
ERROR AND XREF VER 1.5 DEC. 10,1991
line LC Object Source
SYMBOL TABLE STATISTICS
69 ENTRIES 6.74 PERCENT FULL
CROSS-REFERENCE TABLE
24.90 PERCENT FULL
CROSS-REFERENCE LISTING
BASE 0001 ABS 17D 27 58 66 69 109 146 155 162 235 258 288 329
BASERR 006A ABS 41 53 63 73 82 87DBASTOR 0066 ABS 76 77 80 83D
...
VALLP 0224 ABS 370 372D 377VALOUT 0134 233D
END OF LISTING
Note the following:
The ﬁrst symbol in the cross-listing ( BASE) is used many times. The last symbol
(VALOUT ) is deﬁned on line 233 (its value is 0134) but is never used.
Each listing page was assumed to be 24 lines long. In reality, pages are longer, de-
pending on the paper size used by the printer. Many assemblers support a directiveto specify the number of lines on a listing page.
164 The ListingFile Ch. 5
The subtitle is diﬀerent on each of our pages. This is the eﬀect of the SUBTTL
directive, which itself is not listed.
The object code is simple and short. It occupies between one and three bytes
per source line and can therefore be easily included in the listing line. On othercomputers, the object code may be longer and may have very diﬀerent sizes for eachsource line. In such cases, the assembler may devote, say, 8 printing positions tothe object code per listing line and, if the object code is longer, print the rest on asecond, and even a third, line. This is the situation on the VAX computer (see nextexample) where each source line can generate between one and three 32-bit words.
Source line 00454 produces several constants. Its listing is, therefore, long, con-
sisting of two lines.
5.2 A VAX Example
The next example is a typical listing produced by Macro , the VAX assembler.
It was produced by the single command:
MACRO /LIST /CROSS REFERENCE=(ALL) /NOOBJECT TEST
which itself deserves a few words:
The/LIST option is self explainable. The default value of this parameter is
/NOLIST .
The/CROSSREFERENCE=(ALL) produces a lot of cross-reference information. In
practice this is rarely needed, and the default value of this option is/CROSS
REFERENCE=(SYMBOLS,MACROS) . The only important cross reference infor-
mation is that of symbols. It can point to unused symbols that are, perhaps, theresult of mistyping.
The default value of /NOOBJECT is, of course, /OBJECT . The object ﬁle is normally
the most important output.
The word TESTis the name of the source ﬁle (its full name is TEST.MAR ).
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 1
30-OCT-1991 18:38:08 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
0000 1 .title Fibonaccis
00000000 2 .psect cons noexe,nowrt
0001 0000 3 one: .word 10005 0002 4 five: .word 5
00000000 5 .psect code exe,wrt
0000 0000 6 .entry fib,0
0002 7 .macro move x,y,z0002 8 movw y,x0002 9 movw z,y0002 10 .endm move
00000000’EF 00000000’EF B0 0002 11 movw one,a
Sec.5.2 A VAX Example 165
00000002’EF 01 B0 000D 12 movw #1,b
00000006’EF B4 0014 13 clrw k
00000000 14 .psect data noexe,wrt
00000002 0000 15 a: .blkw 100000004 0002 16 b: .blkw 1
0000001A 17 .psect code exe,wrt
00000002’EF 00000006’EF B1 001A 18 loop: cmpw k,five
06 12 0025 19 bneq next
0000005C’EF 17 0027 20 jmp done
00000002’EF 00000000’EF A1 002D 21 next: addw3 a,b,c
00000004’EF 0038
003D 22 output c
%MACRO-E-UNRECSTMT, Unrecognized statement !
003D003D 23 .show me003D 24 move a,b,c
00000000’EF 00000002’EF B0 003D movw b,a00000002’EF 00000004’EF B0 0048 movw c,b
00530053 25 .noshow me
00000006’EF B6 0053 26 incw k
BE AF 17 0059 27 jmp loop
005C 28 done: $exit
s
00000004 29 .psect data noexe,wrt
00000006 0004 30 c: .blkw 100000008 0006 31 k: .blkw 1
0008 32 .end fib
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 2
Symbol table 30-OCT-1991 18:38:08 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
A 00000000 R 03
B 00000002 R 03C 00000004 R 03DONE 0000005C R 02FIB 00000000 RG 02FIVE 00000002 R 01K 00000006 R 03LOOP 0000001A R 02NEXT 0000002D R 02ONE 00000000 R 01SYS$EXIT ******** GX 02
+----------------+
! Psect synopsis !
+----------------+
PSECT name Allocation PSECT No. Attributes
166 The ListingFile Ch. 5
.ABS. 00000000 ( 0.) 00 (0.) NOPIC USR CON ABS LCL NOSHR NOEXE NORD NOWRT NOVEC BYTE
CONS 00000004 ( 4.) 01 (1.) NOPIC USR CON REL LCL NOSHR NOEXE RD NOWRT NOVEC BYTECODE 00000065 (101.) 02 (2.) NOPIC USR CON REL LCL NOSHR EXE RD WRT NOVEC BYTEDATA 00000008 ( 8.) 03 (3.) NOPIC USR CON REL LCL NOSHR NOEXE RD WRT NOVEC BYTE
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 3
Cross reference 30-OCT-1991 18:38 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
+------------------------+
! Symbol Cross Reference !
+------------------------+
SYMBOL VALUE DEFINITION REFERENCES...
A 00000000-R 15 (1) #-11 (1) #-21 (1) #-24 (1)
B 00000002-R 16 (1) #-12 (1) #-21 (1) #-24 (1)C 00000004-R 30 (1) #-21 (1) #-24 (1)DONE 0000005C-R 28 (1) 20 (1)FIB 00000000-R 6 (1)FIVE 00000002-R 4 (1) #-18 (1)K 00000006-R 31 (1) #-13 (1) #-18 (1) #-26 (1)LOOP 0000001A-R 18 (1) 27 (1)NEXT 0000002D-R 21 (1) #-19 (1)ONE 00000000-R 3 (1) #-11 (1)SYS$EXIT 00000000-XR 28 (1)
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 4
Cross reference 30-OCT-1991 18:38 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
+------------------------+
! Macros Cross Reference !
+------------------------+
MACRO
SIZEDEFINITION REFERENCES...
$EXITS 1 28 (1) 28 (1)
MOVE 1 7 (1) 24 (1)
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 5
Cross reference 30-OCT-1991 18:38 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
+------------------------+
! Opcode Cross Reference !
+------------------------+
OPCODEVALUE REFERENCES...
ADDW3 00A1 21 (1)
BNEQ 0012 19 (1)CALLS 00FB 28 (1)CLRW 00B4 13 (1)CMPW 00B1 18 (1)INCW 00B6 26 (1)JMP 0017 20 (1) 27 (1)
Sec.5.2 A VAX Example 167
MOVW 00B0 11 (1) 12 (1) 24 (1)
PUSHL 00DD 28 (1)
FIBONACCIS 30-OCT-1991 19:43:55 VAX MACRO V5.0-8 Page 6
Cross reference 30-OCT-1991 18:38 SYS$USER3:[VACSC0HN]TEST.MAR;1 (1)
+----------------------------+
! Directives Cross Reference !
+----------------------------+
DIRECTIVE REFERENCES...
.BLKW 15 (1) 16 (1) 30 (1) 31 (1)
.END 32 (1).ENDM 10 (1) 28 (1).ENTRY 6 (1).GLOBL 28 (1).MACRO 7 (1).NOSHOW 25 (1).PSECT 14 (1) 17 (1) 2 (1) 29 (1) 5 (1).SHOW 23 (1).TITLE 1 (1).WORD 3 (1) 4 (1)
+------------------------+
! Performance indicators !
+------------------------+
Phase
Page faults CPU Time Elapsed Time
Initialization 27 00:00:00.04 00:00:00.48
Command processing 459 00:00:00.07 00:00:00.70Pass 1 214 00:00:00.13 00:00:01.06Symbol table sort 0 00:00:00.00 00:00:00.00Pass 2 72 00:00:00.05 00:00:00.29Symbol table output 1 00:00:00.01 00:00:00.01Psect synopsis output 2 00:00:00.00 00:00:00.02Cross-reference output 4 00:00:00.02 00:00:00.02Assembler run totals 785 00:00:00.32 00:00:02.68
The working set limit was 1150 pages.
898 bytes (2 pages) of virtual memory were usedto buffer the intermediate code.There were 10 pages of symbol table space allocated to hold11 non-local and 0 local symbols.32 source lines were read in Pass 1,producing 0 object records in Pass 2.2 pages of virtual memory were used to define 2 macros.
168 The ListingFile Ch. 5
+--------------------------+
! Macro library statistics !
+--------------------------+
Macro library name Macros defined
SYS$COMMON:[SYSLIB]STARLET.MLB;2 1
5 GETS were required to define 1 macros.
There were 1 error, 0 warnings and 0 info. messages, on lines:
22 (1)
Several things are worth noting about this example:
The VAX instructions have several diﬀerent sizes, and this is apparent in the
listing. The instructions on lines 11, 12, 18 & 21 are long; the one on lines 19 ismuch shorter.
The macro deﬁnition on lines 7–10 only lists the source. No object code is listed.
The expansion, on line 24, is listed, because of the .show me directive on line 23.
/
Exercise 5.2 What directive nulliﬁes the eﬀect of .show me ?
The error message below line 22 means that the output command was not rec-
ognized by the assembler. This command is a system macro that should have beenloaded (by a special option on the command line) from the macro library. It wasintentionally not loaded, in order to illustrate this common error.
There are 3 sections. The conssection occupies lines 3–4. The codesection, lines
6–13 & 18–28. The datasection, lines 15–16 & 30–31. The Psect synopsis (part
of the extended cross-reference) shows the length and attributes of each section.
The symbol table is listed, as part of the cross-reference. All symbols are of type
R(relative), except FIB, which is relative global, and SYS$EXIT , which is global
external (note that its value is unknown).
The symbol cross-reference, as well as the macros-, opcodes-, and directives cross-
reference, are all generated when the extended cross-reference information is re-quired by the user. They all contain the same type of information.
ThePerformance indicators table shows the time spent on each phase of the
assembly. Note that pass 1 took 0.13 sec., and was thus slower than pass 2, whichonly required 0.05 sec.
Sec.5.3 A MASMExample 169
5.3 A MASM Example
The next example is a typical, short listing produced by MASM, the Microsoft
Macro Assembler for the IBM PC(actually, for the 80x86 & 80x88 microprocessors).This assembler is described in Ch. 8. The source ﬁle that produced this examplewas called ‘ a:prog.ASM ’, and is listed below. Note the two directives if1&if2.
They were planted in order to confuse the assembler and cause a phase error. Theif1deﬁnes label begin at the ‘mov al,xyz ’ instruction, whereas the if2deﬁnes the
same label right after that instruction. The assembler discovers the contradictionin pass 2, and issues a phase error. Phase errors are described in Ch. 1.
/
Exercise 5.3 What exactly does the assembler discover in pass 2?
title example
cgr group mycod, mydat
assume cs:cgr, ds:cgr
mydat segment public
if var lt 10
array db var
else
array db 10
endif
abc df 2mydat endsmycod segment public
if1
begin:
endifmov al,xyzif2
begin:
endifmov ax,2 eq 4add ax,dx
mycod endsmydat segment publicxyz db 3mydat ends
end begin
The command ‘ masm /Dvar=4 /d a:prog ’ speciﬁes ﬁle ‘ a:prog.asm ’ as the
source ﬁle, and invokes the two options \D&\d. The ﬁrst option assigns the value
4 to symbol var. The second one requests a pass-1 listing. All MASM options are
listed in Ch. 8.
The command results in two sets of listings. The ﬁrst set is the pass-1 listing,
in which the future symbol xyzis ﬂagged as undeﬁned:
170 The ListingFile Ch. 5
Microsoft (R) Macro Assembler Version 5.10 11/5/91 17:32:46
title example
cgr group mycod, mydat
assume cs:cgr, ds:cgr
0000 mydat segment public
if var lt 10
0000 04 array db var
endif
0001 020000000000 abc df 20007 mydat ends0000 mycod segment public
if1
0000 begin:
endif
0000 A0 0000 U mov al,xyza:prog.ASM(17): error A2009: Symbol not defined: XYZ0003 B8 0000 mov ax,2 eq 40006 03 C2 add ax,dx0008 mycod ends0007 mydat segment public0007 03 xyz db 30008 mydat ends
end begin
The second set is the ﬁnal, pass-2, listing, containing the phase error. Note how
array becomes a single byte loaded with the constant 4, and how the dfdirective
reserves 6 bytes. The data segment mydat is thus 7 bytes long, stretching from
address 0 to address 6. The next part of mydat deﬁnesxyzas the byte at address
7.
Microsoft (R) Macro Assembler Version 5.10 11/5/91 17:32:46example Page 1-1
title example
cgr group mycod, mydat
assume cs:cgr, ds:cgr
0000 mydat segment public
if var lt 10
0000 04 array db var
endif
0001 020000000000 abc df 20007 mydat ends0000 mycod segment public0000 A0 0007 R mov al,xyz
Sec.5.3 A MASMExample 171
if2
begin:
a:prog.ASM(19): error A2006: Phase error between passes
endif
0000 B8 0000 mov ax,2 eq 40003 03 C2 add ax,dx0005 mycod ends0007 mydat segment public0007 03 xyz db 30008 mydat ends
end begin
Next come the segment table, symbol table, and general analysis:
Microsoft (R) Macro Assembler Version 5.10 11/5/91 17:32:46example Symbols-1
Segments and Groups:
N a m e Length Align Combine Class
C G R. ............. GROUP
MYCOD . ........... 0005 PARA PUBLIC
MYDAT . ........... 0008 PARA PUBLIC
Symbols:
N a m e Type Value Attr
A B C. ............. L FWORD 0001 MYDAT
ARRAY . ............ L BYTE 0000 MYDAT
BEGIN . ............ L NEAR 0000 MYCOD
V A R. ............. TEXT 4
X Y Z. ............. L BYTE 0007 MYDAT
@CPU .............. TEXT 0101h
@FILENAME . . . . ....... TEXT a
prog
@VERSION . ........... TEXT 510
27 Source Lines
27 Total Lines13 Symbols
47906 + 395737 Bytes symbol space free
0 Warning Errors
1 Severe Errors
The cross reference below was generated by the special crefutility.
172 The ListingFile Ch. 5
Microsoft Cross-Reference Version 5.10 Tue Nov 05 17:33:37 1991
example
Symbol Cross-Reference (# definition, + modification) Cref-1
@CPU .............. 1 #
@VERSION . ........... 1 #
ABC............... 1 1 #
ARRAY.............. 7 #
BEGIN.............. 1 9 # 2 7
CGR............... 3 44
MYCOD.............. 3 1 3 #2 3
MYDAT.............. 3 5 # 1 2 2 4 # 2 6
VAR............... 6
XYZ............... 1 7 2 5 #
10 Symbols
5.4 An MPW Example
The last example is taken from the MPW assembler for the Macintosh computer
(see Ch. 8 for details about this assembler). The ﬁrst few lines of the source ﬁle arelisted below:
TITLE ’MPW Example’
MAIN
PRINT OFF
INCLUDE ’QuickEqu.a’INCLUDE ’ToolEqu.a’
INCLUDE ’SysEqu.a’INCLUDE ’Traps.a’
PRINT ON
DATitle
DC.B ’Free Mem (#Bytes)’ ; DA Name (& Window Title)
ALIGN 2 ; Word align
theWindow DC.W 322,10,338,500 ; window top,left,bottom,right
......
Note the ‘ PRINT OFF ’, ‘PRINT ON ’ directives. They suppress the listing of the
four INCLUDEd ﬁles. The main points worth noting in the listing itself are thediﬀerent instruction sizes, and the absence of tables and statistics at the end. Thislisting, in fact, resembles the one genereted by the old IBM 360 assembler.
Sec.5.4 An MPW Example 173
eighttt
MC680xx Assembler - Ver 3.10 MPW Example 06-Nov-91 Page
1
Copyright Apple Computer, Inc. 1984-1989
Loc F Object Code Addr M Source Statement
TITLE ’MPW Example’
00000 MAIN00000 PRINT ON00000 DATitle00000 1146726565204D DC.B ’Free Mem (#Bytes)’ ;Name & Window
Title
00012 0000 0012 ALIG N2;W o r d align
00012 0142 000A 0152 theWindow DC.W 322,10,338,500 ;windo top,lft,bot,rt0001A DAOpen0001A 48E7 0078 MOVEM.L A1-A4,-(SP) ; preserve A1-A40001E G 2849 MOVE.L A1,A4 ; MOVE DCE pointer to a reg0002000020 598F SUBQ.L #4,SP ; FUNCTION = GrafPtr00022 2F0F MOVE.L SP,-(SP) ; push a pointer to it00024 A874
GetPort ; push it on top of stack
00026 4AAC001E TST.L DC tlWindow(A4) ; do we have a window?0002A 662E 0005A BNE.S StdReturn ; If so, return, Else...0002C 42A7 CLR.L -(SP) ; FUNCTION = windowPtr0002E 42A7 CLR.L -(SP) ; allocate on the heap00030 487A FFE0 00012 PEA theWindow ; boundsRect00034 487A FFCA 00000 PEA DATitle ; title00038 4267 CLR.W -(SP) ; visible ﬂag FALSE0003A 3F3C0004 MOVE.W #noGrowDocProc,-(SP) ; window
proc
0003E 2F3CFFFF FFFF MOVE.L #-1,-(SP) ; window in front00044 3F3C0100 MOVE.W #$0100,-(SP) ; goAway box TRUE00048 42A7 CLR.L -(SP) ; refCon is 00004A A913
NewWindow
0004C0004CG 205F MOVE.L (SP)+,A00004E 2948 001E MOVE.L A0,DCtlWindow(A4) ; save windowPtr00052 316C0018 006C MOVE.W DC tlRefNum(A4),WindowKind(A0)0005800058 A11D
MaxMem
0005A0005A StdReturn
174 The ListingFile Ch. 5
0005A A873 SetPort ; old port on stack
0005C4C DF 1E00 MOVEM.L (SP)+,A1-A4 ; restore regs00060 END ; of Sample
Elapsed time: 4.93 seconds.Assembly complete - no errors found. 2768 lines.
Sec.5.5 Review Questionsand Projects 175
5.5 Review Questions and Projects
1.From among the directives covered in chapter 3, point out several that accept
expressions as their operands. When such directives are listed, the object code ﬁeldshould contain the value of the expression.
2.The intermediate ﬁle must now include new quantities, lines that are on the ﬁle
on their way to the listing ﬁle. They should be identiﬁed as such, so that pass 2does not try to process them. What is a good way of identifying such records?
5.5.1 Project 5–1
Extend project 4–1 by adding listing control directives EJECT ,LIST,TITLE ,
XREF. The main modiﬁcation is to the symbol table to support cross-reference listing
as explained above.
The programmer may require a human-readable listing of both source and
object code, preferably side by side
—P. Calingaert Program Translation Fundamentals (1988)
6. Special
Assembler Types
6.1 High-Level Assemblers
As the name implies, these are assemblers for high-level assembler languages.
Such languages are rare, there is no general agreement on how to deﬁne them, onwhat their main features should be, and on whether they are useful and shouldbe developed at all. Existing high-level assemblers diﬀer in many respects and, onlooking at several of them, two possible deﬁnitions emerge:
A high-level assembler language (HLA) is a program-ming language where each instruction is translatedinto a few machine instructions. The translator issomewhat more complex than an assembler, but muchsimpler than a compiler. Such a language should nothave features like the if,for, andcasecontrol struc-
tures, complex arithmetic, logical expressions, andmulti-dimensional arrays. It should consist of simpleinstructions, closely resembling traditional assemblerinstructions, and of a few simple data types.
178 SpecialAssembler Types Ch. 6
A high-level assembler language (HLA) is a language
that combines most of the features of higher-levellanguages (easy to use control structures, variables,scope, data types, blockstructure) with one impor-tant feature of assembler languages namely, machinedependence.
One may argue that the second deﬁnition deﬁnes a machine dependent higher-levellanguage rather than a high-level assembler language, the main reason being thedeﬁnition of assembler language, given in the introduction. The basis of this deﬁni-tion is the one-to-one correspondence between assembler- and machine instructions.The languages discussed here do not have such a one-to-one correspondence and, inthis respect, resemble more a higher-level language than an assembler language.
The best known examples of HLAs are the NEAT/3 for the NCR Century
computers [85,86], Wirth’s PL360 [61], a language designed speciﬁcally for the IBM360 computers, Bell and Wichmann’s PL516 [63], an Algol-like assembler languagefor the Honeywell DDP516 computer, and BABBAGE [87] a language speciﬁcallydesigned as a HLA for the GE 4000 family of minicomputers. NEAT/3 and BAB-BAGE are HLAs according to the ﬁrst deﬁnition above, while PL360 and PL516have been designed in the spirit of the second deﬁnition. Following is a short de-scription of the main features of those languages.
/
Exercise 6.1 The second deﬁnition above deﬁnes an HLA as a higher-level, ma-
chine dependent language. Is it also possible to design the logical contrast namely, alower-level (assembler), machine-independent language? What would be a possibleuse for such a language?
6.1.1 NEAT/3
This is an HLA implemented on the NCR Century computers, a family of
computers designed primarily for data processing. NEAT/3 was designed, in 1966–68, with two goals in mind:
1. To make it easy to write short to medium size programs, without having to go
through a COBOL compiler (a slow and complex process at that time).
2. To make it easy to write an eﬃcient COBOL compiler for the Century com-
puters.
The NCR literature does not mention the name ‘high-level assembler’, nor
does it mention the term ‘higher-level language’. It simply refers to NEAT/3 as aprogramming language, and to the translator, as the NEAT/3 compiler. However,on examining the language, it is easy to see that it does not have the type ofpowerful statements and control structures one expects to ﬁnd in a higher-levellanguage. The statements are simple, and resemble typical assembler instructions.This is why they are easy to translate, and this is why the NEAT/3 translator waseasier to write than a COBOL compiler. Most of the time, a NEAT/3 statement
Sec.6.1 High-Level Assemblers 179
is translated into one machine instruction. Only when conversion between data
types is necessary, the translator (we will call it a translator, not a compiler or anassembler) generates more machine instructions.
The main feature that makes NEAT/3 look like a higher-level language is the
data deﬁnitions. The way data items and ﬁles are declared in NEAT/3 closelyresembles COBOL. Concepts such as working storage area, constants area, datarecords divided into ﬁelds, and data types, are all borrowed from COBOL, whichmakes it easy to write a COBOL compiler in NEAT/3. Even editing masks (fordata to be printed) are supported and use the same characters ‘9’,‘Z’,‘$’,‘+’, ‘ −’,‘.’
as in COBOL.
The data types are: Characters (coded in USASI, not ASCII), signed & un-
signed decimal, signed & unsigned packed decimal, binary, and hex.
The following is an example of a record declared in NEAT/3:
Name
Code Location Length Type Picture
D SALESRED R 50
D STORECODE F 0 3 XD MANAGER F 3 8 XD DATE F 11 6 XD DAY F 11 2 XD MONTH F 13 2 XD YEAR F 15 2 XD GROCERY F 17 6 UD PRODUCE F 23 5 UD MEAT F 28 6 UD DAIRY F 34 5 UD MISC F 39 5 UD DAILYTOTAL F 44 6 U
Note the following:
1. The code ﬁeld can have values of: Rfor a record, Ffor a ﬁeld, and A, for an
area.
2. FieldDAYis located at the same position as DATE.T h u sDAYis a subﬁeld of
DATE(and, as a result, also MONTH ,YEAR) which is how a record becomes a tree
structure, same as in COBOL.
3. TheDat the beginning of each line stands for data declaration.
4. No ‘picture’ is shown in this example, but pictures are heavily used in NEAT/3
and are virtually identical to the COBOL picture clause.
5. The possible types are:
180 SpecialAssembler Types Ch. 6
Code Data Type
Xor blankCharacter
S Generated spaces
Z Generated zeros
U Unsigned decimal
D Signed decimal
B Binary
H Hex
P Signed packed decimal
K Unsigned packed decimal
E Editing mask
Next we examine some of the NEAT/3 instructions (or, as the NCR literature
calls them, statements). This is the area were one can really justify the name high-level assembler. Most of the instructions are simple, resemble typical assemblerinstructions, and are easy to translate. The main diﬀerence in translation is theautomatic conversion between data types, which NEAT/3 supports, but a typicalassembler does not.
/
Exercise 6.2 What are typical valid and invalid type conversions in languages
such as COBOL and NEAT/3?
1.Comparisons. The instruction ‘ COMP A,B ’ compares its two operands and
sets status ﬂags like any typical comparison in machine language. The onlydiﬀerence is that the operands can be of diﬀerent types, and the translatortakes care of type conversion.
2.Conditional Branches. The ‘BRE CALCTAX ’ instruction is executed by testing
the status ﬂags and branching to CALCTAX on ‘equal’. There are several such
branches, each translated into one machine instruction. They are the only wayto make decisions in NEAT/3, except for the simple IF described below.
3.Test and branch. Theif alphabetic (IFAL) instruction tests its ﬁrst operand
and branches to the second operand (a label) if the ﬁrst operand is alphabetic(of type character).
4.Moves. Those instructions workthe same as in COBOL. In the simplest case,
a move is translated into one machine instruction but, if it also involves typeconversion and editing, it is translated into several instructions.
5.End of execution ( FINISH ).This instruction is translated into machine in-
structions that close all open ﬁles and perform a software interrupt to theoperating system.
In summary, NEAT/3 justiﬁes the name high-level assembler language, but
also the name low-level programming language. Its translator may be called a high-level assembler but also a compiler. It seems to lie somewhere in between assemblerlanguage and COBOL.
Sec.6.1 High-Level Assemblers 181
6.1.2 PL360
The main justiﬁcation for this language, to use the developer’s own words [61],
is:
‘...PL360 was designed to improve the readability of
programs which must take into account speciﬁc char-acteristics and limitations of a particular computer.It represents an attempt to further the state of theart of programming by encouraging and even forcingthe programmer to improve his style ...Because of
its inherent simplicity, the language is particulaly wellsuited for tutorial purposes ...a tool that encourages
the programmer to write programs in a disciplined, lu-cid and readable style while still maintaining controlover the optimal use of speciﬁc machine characteris-tics...’.
The main low-level feature of the language is its heavy dependence on the
IBM360 architecture, allowing the programmer to use speciﬁc registers and machineinstructions. Its main high-level features are blockstructure, procedures, typedvariables, and the use of statements rather than instructions. There is also a gotostatement, which is rarely used.
Speciﬁcally, the following 9 points summarize the most important design fea-
tures of the language. The ﬁrst 6 are low level features, and the rest, high levelones.
1. Variables can be declared and their types are the types available on the machine
itself. For instance, an integer can be declared as a byte, a short integer, aninteger, or a long integer. Those types correspond to a byte, halfword, fullword,and doubleword in the machine. This makes it easy to assemble (compile?translate?) declarations, as each is directly translated into a DSdirective.
2. Only one-dimensional arrays can be declared, again making it easy to translate
an array declaration into a DSdirective. Also making it easy to generate an
index to an array. Accessing a multi-dimensional array like B[i,j] requires
the compiler to generate an index of the form i*n+j (or something similar).
This, however, is against the design philosophy of PL360, requiring simpletranslation.
/
Exercise 6.3 What if a multi-dimensional array is necessary?
3. The names ‘ R0..R15 ’,F0,F2,F4,F6are reserved to indicate the general purpose
and the ﬂoating-point registers of the 360 computer. Also names such as F45
are reserved to indicate pairs of registers (see example below). Also, the syn
construct (synonym) allows the programmer to use a meaningful name insteadofRi, and to make the two names equivalent.
182 SpecialAssembler Types Ch. 6
4. Expressions are simple, they use no parentheses, and are executed strictly from
left to right, with equal precedence for all operands (see example with R9be-
low). This also implies that no temporary storage is automatically used by thetranslator when an expression is evaluated; more in the spirit of an assemblerthan a compiler.
5. Machine instructions can easily be used, each is declared as a function in PL360.6. Functions and procedures can be declared, and can have parameters. A good
programming practice, however, is to pass parameters through registers, avoid-ing the complexities of call by name, value, or address.
7. The language does not allow the use of absolute addresses, and a program
cannot modify itself.
8. High-level control structures such as if-then-else ,case,for,o rwhile , can be
used.
9. Compound statements (sandwiched between a begin end pair) and blocks can
be used. A PL360 variable thus has scope (it can be local or global).
A program written in PL360 superﬁcially resembles an Algol 60 program. It
consists of statements, not instructions. It has the same control structures and blockstructure. Even variable declarations are very similar. However, on a closer look,one can easily see the common use of machine registers and of machine instructions.Some simple examples are shown in Fig. 6.1 below:
beginshortinteger z; A short integer is 16 bits (halfword)
array1000 real quant,price; Two arrays, 100 f-p values each.
integer n; A 32-bit variable (fullword).
array 132 byte line ; An array of 132 bytes.
integer B synline(R1); B is another name for the element
of array linepointed to by R1
longrealx,y,h; 64-bit (doubleword) f.p. variables.
F0=quant(R1)*price(R1); R1 is used as an index.
R9:=R8 and R7 shll 8o rR6; Left to right execution (see below).
F23:=F67++h; F23, F67 are pairs of f.p. registers,
for operations on long reals.
ifR0<10 then R1:=1 else SET(flags(2)); TheSETfunction is identical
to theSETmachine instruction.
whileR1<0 do
beginR0:=R0+1; F01:=F01*F01 end ;
forR2:=R1 step 4 until R0 do
begin
F23:=quant(R2)*price(R2);F01:=F01+F23;
end
;
end;
Figure 6.1
Sec.6.1 High-Level Assemblers 183
Assignments are executed from left to right without parentheses and with no
operator precedence. The example involving R9above is executed as:
R9:=R8; R9:=R9 and R7; R9:= R8 shll 8; R9:=R9 or R6;
Theshllkeyword means shift left logical. The ++notation means either a
logical (unsigned) integer addition or an unnormalized f.p. addition.
6.1.3 PL516
This language was designed and implemented [63] in 1969–1970, at the Na-
tional Physical Laboratory in England, as a high-level assembler language for asmall, 16-bit machine, the Honeywell DDP516. It was inﬂuenced by PL360 andwas an attempt to create a language that would be similar to Algol 60 and, at thesame time, would be machine dependent and would allow the direct use of machineinstructions. To quote from the introduction:
‘...It must be emphasized that the language is no sub-
stitute for Fortran or Algol 60, but rather a more conve-nient and ﬂexible system for writing long, machine-codeprograms. The main advantage over DAP, the assemblerfor the DDP-516, is that program texts are largely self-documenting due to their Algol-like structure ...’
The main features of PL516 are: variables (but no real variables), with scope;
type checking; expressions (but no temporary working storage); procedures (butnot more than one parameter per procedure and no call by name); compound state-ments; conditional statements; simple forloops; arrays (only one-dimensional); no
dynamic memory allocation; direct control of the machine registers; machine in-structions can be included in the code.
The following two short examples, taken from the user’s manual, give the ﬂavor
of the language:
1.
for
xsymbol ←176 do
ifmcode[xsymbol ]=ident then gotofound
elsecodesymbol IRS,0;
This is a loop, searching array mcode .IRSis a machine instruction (IncRement
in Store, by 1) and, in our example, it increments memory location 0, which alsohappens to be the X(index) register.
2.
accumulator
conditional procedure bsis;
begin
xsymbol ←accumulator ;
more: when cleftoptable[xsymbol ]=bs then
begin
codesymbol STX,addbs;
184 SpecialAssembler Types Ch. 6
exittrue
end;
whenaccumulator nonzero then
begin
x←incicleftoptable[xsymbol ]+x;
gotomore;
end
end;
This is a procedure bsisthat searches an array optable to ﬁnd the type of a
basic symbol (basic symbols are tokens read by the compiler from the source ﬁle,on paper tape). On ﬁnding a match in the array, variable addbs is set to the array
index by the machine instruction STX(storeXregister). The keyword accumulator
stands for the accumulator (the Aregister).
6.1.4 BABBAGE
This is a HLA designed speciﬁcally for the GEC4000 family of minicomputers
made in England. It is the only assembler available for the 4000, which makes itespecially interesting. The most important feature of the language is the syntax ofthe logical and arithmetic expressions, which makes it easy to assemble, not just theexpressions, but most of the statements in the language. BABBAGE expressionssuperﬁcially looklik e those of a higher-level language but are very diﬀerent becausethey use no operator precedence and no parentheses. This makes it easy to parseand translate such an exprsssion. Examples:
1.a+RX & 7*b=>c . where RXstands for register Xand ‘&’ is the logical and
operator. The expression is translated into:
LOD a (into the accumulator)
ADD X (index register)
AND #7MULT bSTA c (store acc in operand c)
2.+p=>q*n . The expression starts with an operator ‘ +’, so the translation
starts with an operation ( ADD).
ADD p
STA qMULT n
It is now easy to understand the meaning of the expression. Operand pis
added to the previous contents of the accumulator. The result is stored in operandq, and then the accumulator is multiplied by n, preparing it for the next operation.
There are If-Then-Else ,While ,&Repeat constructs but, because of the
use of simple expressions, they are greatly simpliﬁed. Examples:
Sec.6.1 High-Level Assemblers 185
IF a EQ b OR c EQ d THEN 0=>g . This is translated into:
LOD a
CMP bBZL 1LOD cCMP dBNZ L2
L1 LOD #0
STA g
L2 --
2.IF a EQ b THEN << 0=>a 1=>b >> . The symbols ‘ <<’,‘>>’ act as a ‘begin-
end’ pair to delimit compound statements. In our case, the compound statementis the two simple expressions setting operands a,bto 0,1 respectively. This is
translated into:
LOD a
CMP bBNZ L1LOD #0STA aLOD #1STA b
L1 --
One-dimensional arrays can be declared, used in expressions, and easily trans-
lated. Examples:
VECTOR[0,3] OF BYTE dv=‘ABCD’VECTOR[1,4] OF HALFWORD v=(8,11,32,0)
dv[i+2]*3=>v[i] . This exprssion, involving arrays dv&v, is translated into:
LODX i load the index reg.
ADDX #2LOD RX,dv use index mode
MULT #3LDX iSTA RX,v
Records can be declared and used in a way very similar to Pascal records.
Pointers can be set to combine records into large data structures.
The above description is incomplete but it shows the main characteristics of
the language namely, it combines higher-level language features with simple syntaxand heavy machine dependence. BABBAGE is therefore a HLA in the sense of bothdeﬁnitions given in this section.
186 SpecialAssembler Types Ch. 6
6.2 Summary
In the 1970s, while the 360/370 computers were in wide use, PL360 had gener-
ated interest among programmers, and had enjoyed a certain amount of use. Today(in the 1990s), however, that interest has virtually disappeared. However, thereseem to be language designers who believe in the concept of a high-level assemblerlanguage. As a result, we may perhaps see more interest in this approach in thefuture. More future programming languages may be combinations of the higher-level and assembler languages of today, providing the beneﬁts of both types. If thisproves true, we may see the demise of conventional assembler languages in favor ofsuch hybrids.
6.3 Meta Assemblers
A Meta-Assembler (MA), sometimes also called a universal assembler, is an
assembler that can assemble code for a number of diﬀerent computers. A conven-tional assembler can only handle source and object ocde for one computer; it isdedicated to that computer. In contrast, a MA running on computer K may be
able to assemble code for computers K,L,M and others. A MA is therefore also anexample of a cross assembler .
There are two types of MAs, restricted and general; and there are two ways to
design a MA, it can be generative or adaptive. A restricted MA can only assemblecode for a limited number of computers, normally the members of a computerfamily. Information about the instruction sets is built into the MA so it only hasto be given the name of a computer, followed by the source ﬁle. A general MA can,in principle, handle code for any computer. It does not have any instruction setbuilt-in, and has to be handed over, with each source ﬁle, a complete description ofthe source & object instructions.
A generative MA (which can be either restricted or general) is given either the
name of a computer or a description of an instruction set, and generates a dedicatedassembler. That assembler is then run in the usual way, translating source ﬁles intoobject ﬁles.
An adaptive MA (again, restricted or general) is given either the name of a
computer or a description of an instruction set, followed by a source ﬁle. It thenassembles the source and generates an object ﬁle.
It follows that a generative restricted MA has several assemblers built into it.
Its only job is to decide what assembler is currently needed, and to generate a copyof it. A general adaptive assembler, on the other hand, is a general program, ableto adapt its output to many diﬀerent situations, and is potentially very useful. Themain problem in using such a MA is to design the input. The input should includea description of the instruction set of the target computer, but should not be toolong or complex.
An interesting feature of MAs, really a restriction, is that they can assemble
programs for several computers, but the source ﬁles must conform to the syntax ofthe MA. In other words, one cannot simply take a program written for an existing
Sec.6.3 MetaAssemblers 187
assembler and assemble it on a MA without changes. Suppose that a MA Ycan
assemble programs for computer X(and other computers). A source ﬁle that runs
onXmay not be valid for Y, since Ymay require the source to be in a certain
format and to contain special commands.
The history of MAs starts with UNIVAC, a maker of early computers. The ﬁrst
MA worthy of its name was the UTMOST, introduced in 1962. It was a restricted,adaptive MA that ran on the UNIVAC III and could generate code for a few ofthe early UNIVAC models. It supported most of the features described below, suchas formats and procedures. It was followed by SLEUTH that ran on the UNIVAC1107 and could produce code for the UNIVAC 11xx family of computers. SLEUTHwas the ﬁrst MA to use functions.
Many computer manufacturers and research institutes have followed and im-
plemented many (perhaps around 50) MAs. Ferguson [24] is the ﬁrst full discussionof MAs, including bits of history. Skordalakis [48] is a comparative list of about30 MAs. Reference [49] is a well documented restricted MA for three CDC earlyfamilies of computers. The Compass assembler [14,30] for the CDC Cyber is a MAsince it assembles code for the central processor and for the peripheral processors.The ASM-86 [33–35] is a MA since it can handle code for 80x86 microprocessors.
An interesting example of a large, modern MA is MOPI(Macro Oriented Pro-
gram Interpreter) [7,95]. It is a general adaptive MA that has been developed byVOCS of Minneapolis, MN for any 8-, 16- or 32-bit microprocessors. It is a table-driven, two-pass relocatable MA, with an integrated linking loader and an externallinker. To assemble a program, the user has ﬁrst to prepare tables describing boththe source and machine instructions.
References [50-55,95] are a few examples of modern MAs. Their main features
are:
theFORMAT command.
The use of procedures and functions to describe machine instructions.
Library procedures and functions provided at assembly time.
TheFORMAT command: Before writing the source, the user must specify to the
MA the format of all instructions on the target computer. This is done by meansof theFORMAT commmand, which is a template, describing the format of a certain
instruction type and assigning it a name. Suppose that the machine language to begenerated by the MA has two types of instructions: Type SR(storage-register) with
ﬁelds: OpCode(8), R(4), Address(12), and type RR(register-register) with ﬁelds
OpCode(8), R(4), R(4). The commands:‘ RR FORMAT 8,4,4 ’‘SR FORMAT 8,4,12 ’
deﬁne the two instruction formats with their respective ﬁelds, and with names RR
andSRrespectively. Later, the source ﬁle may contain lines such as:
RR AR,R4,R6
RR SR,R4,R‘SYM+1’SR LD,R4,ABC
188 SpecialAssembler Types Ch. 6
The ﬁrst instruction is easy to assemble. The MA only needs an OpCode table.
The second and third instructions require the value of symbols that should be inthe symbol table. SYMshould be an absolute symbol, and ABC, a relative one. The
MA should ﬁrst evaluate the expression ‘ SYM+1 ’, and then assemble the instructions
in the usual way.
/
Exercise 6.4 What does the following line mean, if anything: RR X’R R4,R6 ?
Procedures and Functions: A procedure can be deﬁned, which describes an
instruction, or even more than one instruction, in terms of a parameter or severalparameters. The SRinstruction LD, mentioned earlier, may be described by the
procedure:
PROC LD,Q
SR $A8,Q(1),Q(2)
ENDP
This is similar to a macro. The procedure name is LD, it has one (compound)
parameter Q. It generates a type SRinstruction with the OpCode A816, followed
by the two components of the parameter Q. A typical call could be ‘ LD,(R4,ABC) ’,
which is very similar to the way the LDinstruction is normally written.
In a similar way, a function may be deﬁned, to calculate and return a certain
result. The INCfunction below assigns a value to a symbol, a value that depends
on the LC.
FUNC INC,Q,P
Q EQU LC+P
ENDF Q
TheENDFspeciﬁes that the result of the function is Q. When such a function is used,
as, for example, in: ‘ ...INC S,68 ...’, it generates ‘ S EQU LC+68 ’ and returns the
value ofS, which can be used on the same line.
Library Routines: A good assembler should have accesss to a library of routines,
and should be able to search the library and add routines to the program beingassembled. With a MA, the problem is that there may be several libraries, eachwith a diﬀerent format. A good MA can therefore accept a special command withthe name of a speciﬁc library and information on how to search it and read routinesfrom it.
Directives: Most directives are independent of the speciﬁc source language
used, making it easy to execute them by a MA. The most important exceptions arethe data generating directives. They are machine dependent since computers usediﬀerent types of data. The size of numbers, the character codes, the method used torepresent signed numbers, all those depend on the architecture of the computer, andmay be very diﬀerent for diﬀerent computers. However, computers use a relativelysmall number of data types, which simpliﬁes the taskof executing those directives.
Sec.6.3 MetaAssemblers 189
Once the MA receives speciﬁcations such as: word size, 2’s complement or 1’s
complement, how many bits in the fraction and exponent parts of a ﬂoating pointnumber, ASCII or EBCDIC, it can execute the data generating directives.
6.4 Disassemblers
Practically speaking, a disassembler is the opposite of an assembler. It trans-
lates in the opposite direction, from machine code to assembler language. Becauseof the nature of assembler language, a disassembler is a relatively simple program.Since each assembler instruction generates one machine instruction, the oppositetranslation can be done with relative ease.
The disassembler goes through the following steps:
It reads the next machine instruction from the source ﬁle.
It identiﬁes the OpCode. If the OpCode has ﬁxed length, this is very easy. Oth-
erwise, the disassembler has to perform several tests starting with the ﬁrst few bitsof the machine instruction.
Once the OpCode has been identiﬁed, an OpCode table, similar to the one used
by the assembler, is searched. The table provides the mnemonic, the number ofoperands, and other information.
Once the number of operands is known, the disassembler scans each operand in
the machine instruction to determine the addressing modes, registers, and addressesused by each.
After obtaining all this information, the original assembler instruction is known
and can be printed or written on a ﬁle.
The simple steps described above are not suﬃcient to disassemble machine
code. To end up with a correct, readable, assembler program, the disassembler hasto handle the following problems
The symbol names used in the original program cannot be ﬁgured out by the
disassembler. Thus an instruction such as ‘ JMP ABC ’ may be disassembled to read
‘JMP A0001 ’. When the disassembler ﬁnds an instruction with an address operand,
it assumes that the original instruction has used a symbol, not an absolute address,and it generates a unique symbol name such as Adddd whereddddare digits. The
resulting disassembled program is technically identical to the original one, but maybe harder to read since meaningful symbol names are important.
A similar problem exists with regard to macros. Some instructions in the object
code come from the expansion of macros while others come from the original pro-gram. When the object code is disassembled, it is impossible to tell whether theoriginal program has used macros and, if yes, which ones. The disassembled sourcecan therefore have no macros.
The same thing is true for any feature that is completely handled by the assem-
bler.EQUsymbols, for instance, are transparent to the disassembler and cannot be
reﬂected in the listing generated by it. Thus when something like:
190 SpecialAssembler Types Ch. 6
REG EQU 5
CMP REG, ...
is assembled and then disassembled, the following is generated
CMP 5, ...
A program in machine language is a set of numbers, some of which are machine
instructions and others, data items. When the disassembler looks at a number, ithas no way to tell whether the number is a machine instruction or a piece of data.As a result, the disassembler tries to interpret each number in the object code intwo ways, as an instruction and as (character) data. Both interpretations shouldbe output, side by side.
Most computers have variable-length instructions. If the disassembler disassem-
bles object code in memory, it should be given the right start address. Otherwise,it may start in the middle of an instruction. The following two examples illustratethis point:
Example: A piece of code for the 6502 microprocessor is given.
Address
Contents LabelOperation Operand
.
.
F944 8A TXAF945 4C DA FD JMP SUB1F948 A2 03 LDX #$3F94A A9 A0 LDA #$A0F94C 20 ED FD JSR SUB2
..
If a disassembler is given F948as a start address, it will disassemble the code
properly, starting at the LDXinstruction. If, however, it is given F947 as a start
address, it will consider that address the ﬁrst address of an instruction and willcome up with:
Address
Contents LabelOperation Operand
F947 FD A2 03 SBC $03A2,X
F94A A9 A0 LDA #$A0
..
Since the contents of locations F947–F949 happens to be the OpCode of the SBC
instruction. The same disassembler, given address F949 as a start address will
produce -
Sec.6.4 Disassemblers 191
Address Contents LabelOperation Operand
F949 03 ???
F94A A9 A0 LDA #$A0
..
Since the contents of address F949is not the OpCode of any 6502 instruction.
Example: PC DOS, the operating system of the IBM PC, has a simple debug-
ger, called DEBUG , that can disassemble 80x86 machine code. The three examples
below show the results of disassembling code starting from address 0 of a certainmemory segment (the segment number is irrelevant and has been omitted).
0000 CD20 INT 20
0002 C0 DBC00003 9F LAHF0004 009AEEFE ADD [BP+SI+FEEE],BL0008 1DF0F4 SBB AX,F4F0000B 02BA102F ADD BH,[BP+SI+2F10]000F 03BA10BC ADD DI,[BP+SI+BC10]0013 02BA10FC ADD BH,[BP+SI+FC10]0017 0C01 OR AL,010019 0301 ADD AX,[BX+DI]001B0002 ADD [B P+SI],AL001D FFFF ??? DI001F FFFF ??? DI
WhenDEBUG is directed to start disassembling from address 1, the bytes ‘ 20 C0 ’,
that were interpreted as parts of two instructions, now constitute an ‘ ADD AL,AL ’
instruction. The ﬁrst few lines are diﬀerent, but the rest is the same
0001 20C0 AND AL,AL
0003 9F LAHF0004 009AEEFE ADD [BP+SI+FEEE],BL0008 1DF0F4 SBB AX,F4F0000B.....
A similar result is obtained when disassembling from address 2. The ﬁrst byte
isC0and, since no instruction can start with this value, the disassembler considers
it to be data. It generates a ‘ DBC0 ’ directive, and assumes that the next byte ( 9F)
starts the next instruction.
0002 C0 DBC0
0003 9F LAHF
192 SpecialAssembler Types Ch. 6
0004 009AEEFE ADD [BP+SI+FEEE],BL
0008 1DF0F4 SBB AX,F4F0000B.....
As a result, it is important to start the disassembler properly. The user must
specify the location, in the source ﬁle, of the ﬁrst executable instruction. Thedisassembler starts at this point and tries to interpret the contents as an OpCode.If it is the OpCode of an instruction, the instruction’s size is determined, the entireinstruction is read from the source, and it is then disassembled. In the examplesabove, instructions were 1, 2, or 3 bytes long. If the ﬁrst address does not containthe OpCode of any instruction, the disassembler considers it data and generatesa directive (perhaps accompanied by a ???). It then starts afresh at the next
address. In addition, each byte read by the disassembler should also be interpretedas a character (in ASCII or whatever code is used by the computer) and printed.This way the user may decide whether certain disassembled items are instructionsor data.
Example:
Address
Contents LabelOperation Operand ASCII
F952 A8 TAY (
F953 C8 INY HF954 AD B1 B2 LDA $B2B1 -12F957 A9 AA LDA #$AA )*F959 B9 AF D8 LDA $D8AF,Y 9/XF95C BD BB B5 LDA $B5BB,X =4;
..
Disassembling addresses F952-F95C produces valid instructions, but the same
memory locations can also be interpreted as containing the character string (H-
12)*9/X=4; and only the user can decide how to interpret the results.
Such a simple approach to disassembly is easy to implement, results in a fast
disassembler, and produces output that is usually easy to read and interpret. Asimple disassembler was built into the Apple II computer and is brieﬂy describedin reference [40] (p. 59).
Examples of modern disassemblers are:
‘Sourcer’, a disassembler for the 80x86 microprocessors (reference [96]). It can
also disassemble 8087 & 80287 commands.
CodeView , part of the Microsoft development system for the 80x86 & 80x88 mi-
croprocessors, is a sophisticated debugger that can also disassemble code.
Sec.6.5 CrossAssemblers 193
6.5 Cross Assemblers
A cross assembler (CA) is an assembler that runs on computer A, assembling
programs for computer B.Ais called the source computer and B, the target com-
puter. As a result, any meta assembler is also a CA. There is nothing special abouta CA that deserves detailed discussion. In fact, the most interesting thing aboutCAs is the reasons for their existence. Here are the main ones:
The early minicomputers (made in the early to mid 1960s) were slow and had
even slower I/O devices (mostly punched paper tape and teletype terminals). Itmade sense to assemble a program on a mainframe, where both the editor and theCA could use fast magnetic tapes or disks, and then to transfer the object ﬁle, onpaper tape, to the minicomputer for execution.
Some of those early minicomputers were designed for small application programs.
They had small memories or limited instruction sets that made it impractical torun an assembler. For such computers, a CA was a practical solution.
The same reasons applied to the early microprocessors of the mid to late 1970s.
When a new computer is developed, a CA is normally used to implement the ﬁrst
assembler (and perhaps, other software).
The main problems in the implementation of a CA are:
If the CA is to be one-pass, it cannot load the object program directly in the
memory of the target computer. It has to load it in the memory of the sourcecomputer, resolve all forward references, and generate an absolute object ﬁle. Theobject ﬁle is eventually downloaded to the target computer.
A diﬀerence in word size between the source and target computers presents a
problem since the CA has to generate instructions and constants for the targetcomputer, but it can only use facilities available on the source computer. Theresult may be an extensive use of bit-manipulating instructions to operate on partsof words.
Lamb [89] has a short list of CAs available for some minicomputers.
194 SpecialAssembler Types Ch. 6
6.6 Review Questions and Projects
1.Review your knowledge of a COBOL record. The data structure called record
in COBOL is a tree, even though COBOL texts never mention the word. Use aCOBOL text to ﬁnd out how a record is declared and why it is a tree.
2.In the 6502 disassembler example given in the text, disassemble the code starting
at address F955.
3.Go over the two deﬁnitions of HLA given in the text to convince yourself that,
of the four examples of HLAs given, BABBAGE is the one that satisﬁes parts ofboth deﬁnitions.
4.Why is it easy to assemble data declarations in PL360?
5.Use an Algol 60 text to make sure you understand the diﬀerences between a
compound statement and a program block.
6.Write a 2 ×2 table where the rows are labeled ‘restricted’ and ‘general’ and
the columns are labeled ‘generative’ and ‘adaptive’. Each of the 4 table entriescorresponds to a type of MA. Summarize the properties of those four types in thetable.
7.When a word in memory is disassembled, its contents is interpreted by the
disassembler as both an instruction and a character string. However, it can also bea numeric constant. Why doesn’t the disassembler try to interpret each word inthree ways?
6.6.1 Project 6–1
Write a disassembler for the assembler described in project 1–1.
Clean Up Windows
Empty TrashErase DiskRestartShut Down
—Items of ‘SPECIAL’ menu Macintosh computer, 1990.
7. Loaders
To better understand loaders, some material from previous chapters should be
reviewed. The following topics are particularly recommended before starting thischapter:
The principles of operation of one pass and two pass assemblers (Ch. 1).
The concepts of absolute and relocatable object ﬁles (Ch. 1).
TheEXTRN &ENTRY directives (Ch. 3).
These topics discuss three of the four main tasks of a loader namely, loading,
relocation, and linking. The fourth task is memory allocation (ﬁnding room inmemory for the program). A loader therefore does more than its name implies. Aloader performing all four tasks is called a linking loader. (however, some authorscall it a relocating loader. Perhaps the best name would be a general loader.)A loader that does everything except loading is called a linker (in the UNIVAC
literature, it is called a collector , Burroughs calls it a binder and IBM, a linkage
editor ). An absolute loader is one that supports neither relocation nor linking.
As a result, loaders come in many varieties, from very simple to very complex,
and range in size from very small (a few tens of instructions for a bootstrap loader)to large (thousands of instructions). A few good references for loaders are [1, 3, 46,64, 82].
Neither assemblers nor loaders are user programs. They are a part of the
operating system (OS). However, the loader can be intimately tied up with the rest
196 Loaders Ch. 7
of the operating system (because of its memory allocation task), while the assembler
is more a stand-alone program, having little to do with the rest of the OS.
Most of this chapter is devoted to linking loaders, but it starts with two short
sections describing assemble-go loaders and absolute loaders. It ends with a numberof sections devoted to special features of loaders and to special types of loaders.
Before we start, here is a comment on the word ‘relocate’. Loaders do not
relocate a program in the sense that they do not move it in memory from onearea to another. The loader may reload the same program in diﬀerent memory
areas but, once loaded, the program normally is not relocated. There are someexceptions where a program is relocated, at run time, to another memory area but,in general, the term ‘relocate’ is a misnomer.
/
Exercise 7.1 If it is a misnomer, why do we use it?
7.1 Assemble-Go Loaders
Such a loader is just a part of the one-pass assembler; it is not an independent
program. The one pass assembler loads each object instruction in memory as it isbeing generated. At the end of the single pass, the entire program is loaded and, inthe absence of any assembler errors, the assembler starts execution of the program.This is done by jumping, or branching, to the ﬁrst instruction of the program. Theuser can specify a diﬀerent start address by means of the ENDdirective (Ch. 3), and,
in such a case, the assembler will branch to that address.
This method of loading is fast and simple but has several important limitations:
The assembler has to reside in memory with the object program. This may not
constitute a problem in today’s computers with large memories, but is was a severelimitation in the past, and may still be on a small, personal computer.
The assembler has to determine where to locate the program in memory. Most
one pass assemblers are used on small computers, where there is only one programin memory at any time (a single-user computer) and all programs always start atthe same address. Typically the user program is loaded in lower memory locations,the assembler itself is loaded high in memory (ﬁgure 7–1a), and the area occupiedby the assembler can be used by the program for data storage at run time (ﬁgure7–1b). Figure 7–1c depicts a typical memory layout using a COMMON block high in
memory. The COMMON feature is discussed in chapters 1 and 3.
A one pass assembler used in a large, multi-user computer, has to ask the OS
for an available area in memory, suﬃciently large for the program. It has to havean idea of the program’s size before it starts, and an estimate is normally suppliedby the user.
/
Exercise 7.2 How can the user estimate the size of a new program?
The following two points show that a one pass assembly-load operation in a
large computer has serious disadvantages. As a result, it is used in practice only insingle-user computers.
Assembler
data
area
user program
bunused
user program
aCOMMON
unused
cuser programdata
areaSec.7.1 Assemble-GoLoaders 197
Figure 7–1. Three memory conﬁgurations involving assemblers.
Each time the program is to be executed, it has to be reassembled and reloaded.
This is only practical in situations where a program does not have to be executed ona regular basis. For a production program, that is run on a regular basis, perhapsmany times every day, such a way of operation is wasteful and impractical.
There is no way to link programs that are separately assembled. Separate assem-
bly is very common in two situations: when large programs are being developed,and when parts of a program are written in diﬀerent languages. Large programs areoften divided into control sections, each to be developed by a diﬀerent programmeror a team of programmers.
A one-pass assembler is therefore restricted to relatively small programs, that
can be written and assembled as one unit (but see the discussion below on the useof library routines).
The use of library routines is very common. A one pass assembler can use library
routines, but only in a limited way. Each library routine must be absolute, i.e., itwill run only if loaded at a certain, ﬁxed, address. A program may invoke a libraryroutine, say SQRT, by an instruction such as ‘ CALL SQRT ’. If label SQRTis not deﬁned
in the program, the assembler will search the library. On ﬁnding the SQRTroutine,
it will be loaded in its ﬁxed area and the area will be marked as occupied. Theone-pass assembler will attempt to load the program in the memory area precedingthe routine and, if this is impossible, will issue a load-time error message. It willnot attempt to skip that area and continue loading past it (ﬁgure 7–2b). Such anoperation will require placing a JMPinstruction to skip over the routine’s area at
run-time (ﬁgure 7–2c), but assemblers, designed for a one-to-one translation, do notautomatically place instructions in the program.
Three exceptions to the rule above are worth mentioning:
Theforcing upper concept—mentioned in chapter 1—where the assembler auto-
matically inserts NOPinstructions into the unused part of a word.
unused
user programSQRT routine
JMP
ab cunusedunused
unused
user programuser program user program
user programSQRT routine SQRT routine198 Loaders Ch. 7
Instructions in the relative mode. In order to assemble such an instruction, the
assembler has to generate a displacement whose size depends on the distance be-tween the instruction and its operand. If the operand follows the instruction, thedistance is unknown in pass 1, and the assembler has to guess it and reserve roomfor the displacement in pass 1. If the assembler has reserved too much room forthe displacement, it pads it later, in pass 2, with NOPinstructions. This feature is
discussed in Ch. 8, in connection with the MASM assembler.
TheALIGN directive on the TASM assembler increments the LC to the speciﬁed
p o w e ro f2 .T h u s‘ ALIGN 8 ’ will increment the LC to the nearest multiple of 8, and
will insert as many NOPinstructions as necessary to pad up the empty bytes created.
Figure 7–2.
a. Program and SQRT routine loaded in memory.
b. Larger user program loaded in two parts.
c. First part of program JMPs to the second part, over the SQRT routine.
The discussion above illustrates the limitations of this type of loader. They are
the reasons why most loaders are of the relocating type. Only a few are absoluteloaders (see below) or are part of the assembler.
7.2 Absolute Loaders
An absolute loader is the next step in the hierarchy of loaders. It can load
an absolute object ﬁle generated by a one-pass assembler. (Note that some linkageeditors also generate an absolute object ﬁle.) This partly solves some of the problemsmentioned above. Still, such a loader is limited in what it can do.
An absolute object ﬁle consists of three parts:
The start address of the program. This is where the loader should start loading
the program.
Sec.7.2 AbsoluteLoaders 199
The object instructions.
The address of the ﬁrst executable instruction. This is placed in the object ﬁle
by the assembler in response to the ENDdirective. It is either the address speciﬁed
by theENDor, in the absence of such an address, is identical to the ﬁrst address of
the program.
The loader reads the ﬁrst item and loads the rest of the object ﬁle into successive
memory locations. Its last step is to read item 3 (the address of the ﬁrst executableinstruction) from the object ﬁle, and to branch to that address, in order to startexecution of the program.
Library routines are handled by an absolute loader in the same way as by an
assemble-go system.
It turns out that even a one-pass assembler can, under certain conditions,
generate code that will run when loaded in any memory area. This code is calledposition independent and is generated when certain addressing modes are used, or
when the hardware uses base registers.
Addressing modes are described in appendix A. Modes such as direct, immedi-
ate, relative, stack, and a few others, generate code that is position independent. Aprogram using only such modes can be loaded and executed starting at any addressin memory, and no relocation is necessary.
The use of base registers is not that common but, since they are one of the
few ways for generating position independent code, they are also described in ap-pendix A.
7.3 Linking Loaders
These are full-feature, general loaders that support the four tasks mentioned
earlier. Such a loader can load several object ﬁles, relocating each, and linking theminto one executable program. The loader, of course, has access neither to the sourceﬁle nor to the symbol table. This is why the individual object ﬁles must contain allthe information needed by the loader.
A word on terminology. In IBM terminology a load module is an absolute object
ﬁle (or something very similar to it), and an object module is a relocatable object
ﬁle. Those terms are discussed in detail in point 7 below.
The following is a summary of the main steps performed by such a loader:1. It reads, from the standard input device, the names of all the object ﬁles to
be loaded. Some may be library routines.
2. It locates all the object ﬁles, opens each and reads the ﬁrst record. This
record (see ﬁgure 7–3b) is a loader directive containing the size of the programwritten in that ﬁle. The loader then adds the individual sizes to compute the totalsize of the program. With the OS help, the loader then locates an available memoryarea large enough to acommodate the program.
200 Loaders Ch. 7
/
Exercise 7.3 What if such an area cannot be found?
3. The next step is to read the next couple of items from the ﬁrst object ﬁle.
These are loader directives, each corresponding to a special symbol (EXTRN orENTRY). This information is loaded in memory in a special symbol table (SST) tobe used later for linking.
4. Step 3 is repeated for all remaining object ﬁles. After reading all the special
symbol information from all the object ﬁles, the loader scans the SST, mergingitems as described below. This process converts the SST into a global externalsymbol table (GEST). If no errors are discovered during this process, the GEST isready and the loader uses it later to perform linking.
5. The loader then reads the rest of the ﬁrst object ﬁle and loads it, relocating
instructions when necessary. All loader directives found in the ﬁle are executed.Any item requiring special relocation is handled as soon as it is read oﬀ the ﬁle,using information in the GEST. Some of those items may require loading routinesoﬀ libraries (see later in this chapter).
6. Step 5 is repeated for all remaining object ﬁles. They are read and loaded
in the order in which their names were read in step 1.
7. The loader generates three outputs. The main output is the loaded program.
It is loaded in memory as one executable module where one cannot tell if instructionscame from diﬀerent object ﬁles. In a computer where virtual memory is used, theprogram is physically divided into pages (or logically divided into segments) whichare loaded in diﬀerent areas of memory. In such a case, the program does not occupya contiguous memory area. Nevertheless, it is considered a single module and it getsexecuted as one unit. Pages and segments are described in any Operating Systemsor Systems Programming text.
The second (optional) output of the loader is a listing ﬁle with error messages,
if any, and a memory map. The memory map contains, for each program, its name,start address, and size. The name is speciﬁed by the user in a special directive(IDENT orTITLE ) or, in the absence of such a directive, it is the name of the object
ﬁle.
The third loader output is also optional and is a single object ﬁle for the entire
program. This ﬁle includes all the individual programs after linking, so it does notinclude any linking information, but includes relocation bits. It is called a load
module . Such a ﬁle can later be loaded by a relocating loader without having to
do any linking, which speeds up the loading. Note that a load module is the mainoutput of a linkage editor (see below).
The reason for this output is that, in a production environment—where pro-
grams are loaded and executed frequently, but rarely need to be reassembled (orrecompiled)—fast load becomes important. In such an environment it makes senseto use two types of loaders. The ﬁrst is a linker or a linkage editor, which performsjust linking and produces a load module. The second is a simple relocating loaderthat reads and loads a load module, performing just the three tasks of memory
Sec.7.3 LinkingLoaders 201
allocation, loading, and relocation. By eliminating linking, the relocating loader
works fast.
On the other hand, when programs are being developed and tested, they have
to be reassembled or recompiled very often. In such a case it makes more sense touse a full-feature loader, which performs all four tasks. Using two loaders wouldbe slower since most runs would involve a new version of the program and wouldnecessitate executing both loaders.
Linking can be done at a number of diﬀerent stages. (reference [3] lists seven
possibilities). It turns out that late linking allows for more ﬂexibility. The latestpossible moment to do the linking is at run time. This is the dynamic linking fea-
ture discussed later in this chapter. Consider an instruction that requires linking,something like a ‘ CALL LB ’ instruction, which calls a library routine LB. This in-
struction is loaded but is not always executed. (Recall that, each time a programis run, diﬀerent instructions are executed.) Doing the linking at run time has theadvantage that, if the ‘ CALL LB ’ instruction is not executed, the library routine does
not have to be loaded.
Of course there is a tradeoﬀ. Run time linking requires some of the loader
routines to reside in memory with the program.
Figure 7–3a is an overall view of the diﬀerent ﬁles that are involved with a
typical loader. Figure 7–3b is a schematic layout of a typical relocatable object ﬁle.
The two processes of relocation and linking have already been mentioned—
relocation in chapter 1 and linking, in chapter 3 (see the EXTRN, ENTRY direc-tives). In the present chapter, those processes will be described in detail, togetherwith their special problems and limitations.
The following program will serve to illustrate the operations of a general loader.
It is written in a simple, hypothetical, assembler language, and has no meaning otherthan to illustrate relocation, linking, and loader directives. It consists of two objectﬁles, the ﬁrst is a main program called NOMand the second, a program called SUB
containing a procedure LBand some data.
op 2nd 3rd object id
LC
SourcecodeRbytebyterecord bits
ﬁrst loader directive 11111001 11 size=25
0IDENT NOM 00100011 11
01001110 11 N01001111 11 O01001101 11 M
special symbols 10100011 11 Extrn length=3
start here 00000001 11 index=1
01001100 11 L01000010 11 B10100010 11 Extrn length=2
00000010 11 index=2
main
outputsecondary
outputthird outputloaderobj.
file
program-size directive
special symbol information
object
instructionsid
bitslib.
fileobj.
file
obj.
filecommands &
names of all
object files
a single exec utable
module in memorymemory map &
error messagesinitial input202 Loaders Ch. 7
Figure 7–3.
a. The Files Associated with a Loader
b. Layout of a Relocatable Object File.
01011001 11 Y
10000010 11 Entry. length=2
01000011 11 C01000100 11 D
0EXTRN LB,Y
0ENTRY CD
0Z DS 5 01000101 11
5ST LOD R5,15 1 5 00 15 00001101 00
00000000 0000001111 00
8CD COMP R5 2 5 00010101 00
Sec.7.3 LinkingLoaders 203
9LSHFT R5,4 3 5 04 00000100 00
00100000 00
11 CALL LB 4 0 01 00100000 00
00000001 10
13 BEQ R4,X 5 4 17 00101100 01
00010001 00
15 CALL LB 4 0 01 00100000 00
00000001 10
17X LOD R5,Y 1 5 00 02 00001101 00
00000000 0000000010 10
20 HLT 6 0 00110000 00
21 DC 1,’$’,X,LB 00000001 00
00100100 00 ASCII code of $
00010001 0100000001 10
25 END ST 11000101 11 Start exec. @5
eof on object ﬁle
The second object ﬁle (SUB) contains procedure LB.
op 2nd 3rd object id
LC
Source codeRbytebyterecord bits
11101000 11 size=8
0 IDENT SUB 00100011 11 Ident, length=3
01010011 11 S01010101 11 U01000010 11 B10000011 11 Entry. length=3
00000000 11 Value=0 (rel.)
01001100 11 L01000010 11 B10000010 11 Entry. length=2
00000111 11 Value=7 (rel.)
01011001 11 Y
0 ENTRY LB,Y
0LB ADD R1,X 7 1 05 00111001 00
00000101 01
2 ADD R1,5 7 1 05 00111001 00
00000101 00
4 RET 8 0 01000000 00
5X DS 2 01000010 11
7Y DC 2 01100010 11
8 END no loader directive generated
eof
Note the following:
204 Loaders Ch. 7
1. The ﬁnal value of the LC in each program (the value printed to the left of
theENDdirective) is the size of the program. It becomes known at the end of pass
1, and is the ﬁrst item to go on the object ﬁle, at the start of pass 2. The loaderreads it and uses it to determine the memory area (and thus the start address) ofthe program.
2. Symbol CDis declared as ENTRY in one program but is never declared as an
EXTRN in any other program. This is an unusual situation created either by an error
(the programmer has forgot to declare CDas anEXTRN in another program) or by
a change in the original design of the program ( CDwas supposed to be an EXTRN
in another program, plans were changed, CDhas become just a regular symbol, but
the prgrammer forgot to delete the declaration ENTRY CD ).
The loader should detect this and indicate a warning (‘unmatched entry CD’).
This is not necessarily an error but may provide a hint to the programmer thatsomething in the program needs to be corrected.
The opposite case—that of an unmatched EXTRN —is diﬀerent. If a symbol
is declared EXTRN (and is also used by the declaring program) then it should be
declared as an ENTRY in another program. A failure to do so is an error, since the
loader would not be able to link the two programs. However, such a case may meanthat the symbol is the name of a library routine and is declared as an ENTRY in
the library. This is discussed in point 8 below and also in the section on libraryroutines.
3. Each line in the example object ﬁles is 8 bits long plus 2 identiﬁcation
bits. They identify the line as either an absolute item (00), a relocatable item (01),
something that requires special relocation (10), or as a loader directive (11). Eachline thus becomes 8 + 2 = 10 bits long, of which only 8 bits actually get loaded inmemory. In certain computers, the operating system makes it hard, or ineﬃcient,to output lines with sizes which are not multiples of 8. In such a case the assemblermay write all the idbits, packed four pairs to a byte, at the end of the object ﬁle.
The loader would have to read this information ﬁrst, reopen the object ﬁle, andstart loading. This is the reason why many loaders perform two passes over eachobject ﬁle.
4. In this example, we limit ourselves to two idbits and thus can have only
four types of records on the object ﬁle. Speciﬁcally, we can have just one type ofspecial relocation (identiﬁed by 10). Ideally, it would be desirable to have two typesof special relocation, absolute and relative. In such a case one could write:
ENTRY AB
.
AB EQU 7
in one program and:
EXTRN AB
.CALL AB
Sec.7.3 LinkingLoaders 205
in another. This would be an example of a special symbol ABthat is also absolute.
TheCALLinstruction would have to go on the object ﬁle with a type of ‘absolute
special relocation’. In such a case we would end up with ﬁve diﬀerent types on theobject ﬁle, requiring three idbits. In practice, however, absolute special relocation
is not important and is never used. The ‘ CALL AB ’ in the example above really
means ‘CALL 7 ’ and should preferably be written as such.
5. The two programs, NOM,SUBare assembled separately and, therefore, the
twoXlabels are diﬀerent. Each is local to its program, is put in the symbol table in
pass 1 and, at the end of pass 2, disappears together with all other local symbols.Only special symbols (types extandent) are preserved and are written on the object
ﬁle as loader directives.
6. The two instructions ‘ ADD R1,X ’, ‘ADD R1,5 ’ are assembled into identical
object instructions. The only diﬀerence between them is the idbits that identify
the ﬁrst as relative (since Xhas a value of 5 relative to the start of program SUB)
and the second, as absolute (it uses location 5 even though that location may beoutside the program’s area). In computers where memory is protected by hardware,execution of the second instruction may cause a run-time error message.
The two instructions ‘ LOD R5,15 ’, ‘LSHFT R5,4 ’ (left shift 4 positions) are
absolute but use diﬀerent absolute quantities. The 15 in the ﬁrst instruction isused as an address, and may cause a run-time error if the address is outside theprogram’s area. The 4 in the second one is used as the amount of the shift.
7. The loader directives are usualy short (one byte) but some, like IDENT ,
EXTRN ,ENTRY , have variable size. The size is indicated in the ﬁrst byte of the
directive.
The example uses ﬁve types of loader directives (but see a sixth type ‘modify’
below):
a.Program size. ‘ 111xxxxx ’ where ‘xxxxx ’ is the program size. This limits the
maximum size to 31 but this is a simple example. In a real loader, the directivesare diﬀerent and allow for much larger parameters.
b.Start execution at. 110xxxxx . Directs the loader to start execution at
address ‘xxxxx ’.
c.EXTRN .‘10100xxx ’. The following xxxbytes contain the index of the external
symbol and its name, one character per byte.
d.ENTRY .‘10000xxx ’. The next byte is the value of the entry point. The
remaining bytes contain the name.
e.IDENT .‘00100xxx ’. The following xxxbytes contain the name of the pro-
gram.
8. The two ENDdirectives are treated by the assembler diﬀerently. The ﬁrst
has a symbol (ST) in the operand ﬁeld, indicating the point where execution shouldstart. It results in a loader directive (code 110above). The second has nothing in
the operand ﬁeld and does not generate any loader directive. It signals the end of
206 Loaders Ch. 7
assembly and the assembler, in response, completes pass 2 by writing the special
symbols from the symbol table on the object ﬁle (as loader directives, codes ‘ 101’,
‘100’, of variable size), followed by an end of ﬁle (eof). It is the programmer’s
responsibility to make sure that only one source ﬁle in the entire program has astart address in the operand ﬁeld of the ENDdirective. The loader expects only one
such address and issues an error messages on reading the second (and subsequent)ones.
/
Exercise 7.4 What if the loader does not ﬁnd any code ‘ 110’ directives?
Using the example, it is easy to see how the loader works. It reads the names
of the object ﬁles either from the command line (the keyboard command used toinvoke the loader) or from a special command ﬁle. It opens the two object ﬁles,reads the ﬁrst directive from each, adds the two program sizes (27 + 8 = 35) andlocates an available memory area of size ≥35. If that area starts, say, at address 64,
then 64 becomes the ﬁrst relocation term . The loader reads the object ﬁles in the
order in which their names are speciﬁed. Assuming that it starts with ﬁle SUB, the
other relocation terms can now also be calculated. In our case, there is one moresuch term, namely 64 + 8 = 72. In general, each relocation term equals the sum ofits predecessor and the length of the previous program.
At this point, the loader can print the memory map which, in our case, is:
Program
Start Length
SUB 64 8
NOM 72 27
/
Exercise 7.5 What other information can the loader include in the memory map?
Next the loader reads the directives for the ENTRY symbols from the ﬁrst ﬁle.
It stores the special symbol information in the SST after relocating their values(point 4 above shows that special symbols are always relative). Thus LBgets a
value of 0 + 64 = 64 and Y, a value of 7 + 64 = 71.
The loader repeats this for the next object ﬁle. It reads the special symbol
directives from that ﬁle into the SST.
The second ﬁle contains three special symbols LB,Y,CD. They are entered
into the symbol table with CD—anENTRY —relocated by 72. Its value becomes
8 + 72 = 80. Symbols LB,Yare of type EXTRN and their values are still unknown.
They are entered, each with its index, instead of a value. The SST now contains:
prog
name value index type
SUB LB 64 ent
" Y 71 ent
NOM LB - 1 ext" Y - 2 ext"C D8 0 en t
Sec.7.3 LinkingLoaders 207
Note that the program name goes in the SST with each symbol. It is later used to
perform the linking.
After reading all the special symbol information from all the object ﬁles, the
loader proceeds to merge symbols in the SST. It scans the SST looking for symbolsof type ext. For each such symbol, the loader searches the SST for the corresponding
entsymbol. On ﬁnding it, the value of the entsymbol is stored in the entry for the
extsymbol, and the entry for the entsymbol is deleted.
This process results in the following table
prog
name value index type
NOM LB 64 1 ext
" Y 71 2 ext"C D8 0 en t
which is now called a GEST.
Notice that, ideally, a GEST should only have exttype symbols. In our example
oneentsymbol remained in the GEST because the declaration ‘ EXTRN CD ’ did not
appear in any program. This case has already been dealt with earlier in this chapterand it results in a loader warning.
There could also be the case where, for a certain extentry, the loader cannot
ﬁnd the corresponding ententry. This may mean one of two things: either the
programmer has forgot to declare an entry point, or the missing entry is the nameof a library routine.
When a library routine is needed in a program, the prgrammer can simply write
‘CALL xx ’ and declare ‘ EXTRN xx ’ (where xxstands for the name of the routine).
The loader, in such a case, searches the library for such an entry. If it ﬁnds one,it loads the routine into memory and it becomes part of the program. If not, theloader considers this case a fatal error. It issues an error message and will notexecute the program. Library routines are discussed later in this chapter.
/
Exercise 7.6 What if there are two entsymbols in the SST, with the same name
but from diﬀerent programs, both matching the same extsymbol ?
If the user has asked to see the GEST, this is the time for the loader to print
it. This is also the reason why the symbol names are retained in the table. We willsee that they are not used in the actual linking.
In the absence of errors, the loader is now ready to load the object ﬁles. It starts
with the ﬁrst object ﬁle, SUB, reads instructions, and loads them into consecutive
locations starting from location 64. Since there are 8 bytes in that ﬁle, the last onewill be loaded in location 71. Each byte with idbits 01 will get relocated by adding
the ﬁrst relocation term, 64, to it. The result in memory will be:
208 Loaders Ch. 7
64 00111001
65 0100010166 0011100167 0000010168 0100000069reserved for
70array X
71 00000010
There are no linking problems in this program since it does not use any EXTRN
symbols. Notice that none of the records on the object ﬁle has id= 10.
On reading the eof, the loader switches to the next object ﬁle ( NOM) and starts
using the next relocation term (72). This ﬁle is loaded in the same way as theprevious one, and ends up occupying locations 72–96. The only problem in loadingthe second ﬁle are the items with idbits of 10. Each of them contains an index
rather than the value of a symbol.
To ﬁnd the value of such a symbol, the loader searches the GEST for the name
of the program ( NOM) and the speciﬁc index. On ﬁnding the entry, the value becomes
available. The ﬁrst such line in our example is ‘ CALL LB ’. It is read from the object
ﬁle with id= 10 which means that the corresponding byte (= 00000001 ) is an index,
not a value. The loader searches the GEST for an entry with program= NOMand
index=1. On ﬁnding it, the loader uses the ‘value’ ﬁeld, which has already beenrelocated, to complete the instruction. It is loaded, in locations 83–84 as the twobytes00100000 01000000 . The ﬁrst being the OpCode (=4) and the second, the
value (=64) of symbol LB.
/
Exercise 7.7 What if such a search in the GEST fails?
The result of loading the second object ﬁle is:
72reserved 84 01000000 LB
73 85 00101100 BEQ74for 86 01011001 X=17+72=89
75 87 00100000 CALL76array Z 88 01000000 LB
77 00001101 LOD 89 00001101 LOD78 00000000 90 0000000079 00001111 15 91 01000111 Y80 00010101 COMP 92 00110000 HLT81 00000100 LSHFT 93 00000001 constants
82 00100000 94 00100100 $83 00100000 CALL 95 01011001 X
96 01000000 LB
Sec.7.4 The ModifyLoaderDirective 209
7.4 The Modify Loader Directive
In our simple version of special relocation the value of the external symbol
is eventually stored in the instruction, replacing the index. Sometimes, however,it is necessary to do more than a replacement. It may be necessary to add thevalue of the symbol to the instruction, to subtract it, or to logically OR it with theinstruction or with part of it. All this can easily be achieved by introducing a newloader directive, the ‘modify’ directive, whose format is:
directive index skip ﬁeld modiﬁc. address
code code
size in bits: 3 5 4 4 2 6 =3 bytes long
The directive code in our example will be 011. The ‘index’ is as before, and the
‘modiﬁcation code’ can take the four values: replace (00), add (01), subtract (10),logical OR (11). The ‘address’ ﬁeld speciﬁes the byte in the current object ﬁle tobe modiﬁed, and the ‘skip’ & ‘ﬁeld’ ﬁelds specify the exact ﬁeld in the byte to bemodiﬁed. The case skip=4, ﬁeld=3 speciﬁes ﬁeld yyyin byte ‘xxxxyyyz ’. In the
example above, the special relocation of the bytes at addresses 12 & 19 can now beachieved by the two ‘modify’ directives:
011 00001 0000 1000 00 001100 011 00010 0000 1000 00 010011
Note that the instruction itself does not need to contain the index of the ex-
ternal symbol any more. Also the idbits can simply be 00, and there is no need
for the special relocation idof 10. The loader loads the instruction in memory
without any modiﬁcation and, when it ﬁnds the ‘modify’ directive later, it modiﬁesthe instruction in memory . The ‘modify’ directive only needs to appear in the same
object ﬁle and should not precede the instruction to be modiﬁed.
This loader directive adds power to the assembler language. It is now possible
to write something like ‘ DC Y-LB ’ and the assembler would produce a constant
of all zeros and two ‘modify’ directives, one to replace Y(or to add it) and the
other, to subtract LB. An address expression such as ‘ Y-LB’ involves two relative
quantities (that can be external) and, as explained in chapter 1, is itself absolute.However, to make it meaningful, we always require that all external symbols usedin the expression be declared (as entry) in one program. If they are declared in twodiﬀerent programs, then the diﬀerence between them, even though still absolute, istotally unpredictable and therefore useless.
The ‘modify’ can be used for both linking and relocation. Normally it is a waste
to use it for relocation, since relocation only requires a bit or two per instruction.However, on a computer where the relative mode is heavily used, relatively fewinstructions need relocation, and the ‘modify’ may be used instead of relocationbits.
0
1
237
5
7
78
88210 Loaders Ch. 7
/
Exercise 7.8 Given the following code.
LC
-
EXTRN M,N-
12 B JMP -
-
25 A SUB -
-
- X EQU A-B+M-N62 Y DC A-B+M-N
How does the assembler execute the directives EQU,DC?
The ‘modify’ can be designed to ﬁt a particular instruction set. On the Signetics
2650 microprocessor [13], addresses may only appear in instructions in one of fourplaces, as shown in Fig. 7–4.
Figure 7–4. The modify Directive.
As a result, a ‘modify’ needs to specify only the address of the ﬁrst byte of
the instruction and a number in the range 0–3 (the ‘case’ ﬁeld below). A possibleformat is:
directive index case modiﬁc. address
code code
3 5 2 2 12 =3 bytes
main output
secondary
outputloaderobj.
filelib.
fileobj.
file
commands &
names of all
object files
memory map &
error messagesinitial inputload
module
Reloc.Loader
a single
executable
module
in memorySec.7.5 LinkageEditors 211
7.5Linkage Editors
The relocating loader discussed above performs all the 4 loader tasks and, in
the simple case described here, does it in a single pass. This kind of operation,however, is not the only one possible, nor is it always the best approach. Anotheroption is a linkage editor , that has brieﬂy been mentioned before, and that can be
used either instead of, or in addition to, the relocating loader. A linkage editorreads the object ﬁles, performs all the linking and some relocation, and writes theresult on another ﬁle, called a load module or anexecutable image . To load the load
module, all that is required is a simple relocating loader, performing very simplerelocation and no linking. This adds one step to the assemble-load-run sequence,but has the advantage that the load module is easy to load. A production program,loaded and executed many times each day, could beneﬁt from a linkage editor. Onthe other hand, testing and debugging a program typically requires to reassemble itafter almost every execution. In such a case, it is convenient to have as few steps aspossible between assembling and execution, so a linkage editor should not be used.Figure 7–5 is a block diagram of the ﬁles and steps involved with a linkage editor.
Figure 7–5. A Linkage Editor.
The linkage editor performs linking and also relocates all the programs (or all
the control sections) relative to the start of the ﬁrst program. The load moduletherefore contains one stream of instructions and is easy to load. To load it, therelocating loader only needs to add the start address to all the relocatable instruc-tions. It has no linking to do, and thus no GEST to maintain. It treats the programas one unit and thus does not have to update the relocation term.
If the start address of the program is known in advance, the linking editor
can relocate all the object ﬁles relative to that start address, and produce a loadmodule that can only be loaded starting at that address. Such a load module is, ofcourse, an absolute object ﬁle, and can easily be loaded later, by an absolute loader,without any relocation. This is commonly done on modern personal computers andworkstations.
212 Loaders Ch. 7
7.6 Dymanic Linking
In an absolute object ﬁle, linking is done at a very early stage, when the
program is written. A linkage editor performs linking when the load module isprepared. A relocating loader performs the linking at load time. Dynamic linking
postpones the linking to the last possible moment, when the instruction requiringlinking is executed. This clearly requires overhead and is slow. However, it has theadvantage that unnecessary routines do not get loaded and thus don’t occupy spacein memory. In fact, the program may not even know the names of the routinesnecessary for any speciﬁc run. The names themselves may be supplied by theuser, at run time. Binding is the process of assigning a value to a parameter or
to a variable, and dynamic linking is an example of late binding. In general, latebinding is more ﬂexible but slower. The concepts of binding and binding time arediscussed in [83].
Another example that can beneﬁt from dynamic linking is a program that has
many procedures but, in any given execution, uses only a few of them. Data, inputat run time, determines what procedures should be called. A traditional loader,loading all the procedures with the main program, may end up requiring morememory than is available.
A common way of implementing dynamic linking is to have a loader routine,
called the dynamic loader (DL), resident in memory at run time. Whenever a newprocedure (which we will call P), should be called, the DL is called to locate P, loadand execute it. The DL is part of the operating system and thus cannot be calledby the user program. To communicate with the OS, the program has to generate aninterrupt (a software interrupt). Thus, instead of a call to P, the program generatesan interrupt to activate the DL. It also sends the name P as a parameter. TheDL searches its tables to see if procedure P has already been loaded. If not, theDL locates and loads it. In any case, the DL calls and invokes P. Procedure Pgets executed and returns to the DL. The DL then restarts the user program. It isimportant that P return to the DL and not directly to the user program because theDL needs to know which routine is executing. The DL may later decide to releasethe memory used by P, and use it for some other routine. The entire process issummarized in ﬁgure 7–6.
Since the assembler exists to help the programmer as much as possible, it should
make the entire process invisible to the programmer. The programmer thereforewrites:
EXTRN P
...CALL P
and the assembler assembles the CALLinstruction into a software interrupt instruc-
tion (called SVC,BREAK or some other name). Dynamic loading is therefore not just
a loader feature; the assembler is also involved.
soft.
inter.
DLOSuserunused
P
soft.
inter.
DLOSuserunused
P
soft.
inter.
DLOSuserunused
soft.
inter.
DLOSuserunused
soft.
inter.
DLOSuserunused
PSec.7.7 LoaderControl 213
Figure 7–6. Dynamic Linking.
a. Initially.
b. A software interrupt instruction invokes the DL in the OS area.c. The DL loads and calls procedure P.d. Procedure P executes and returns to the DL.e. The DL restarts the program at the point following the software interrupt.
7.7 Loader Control
It is important to allow the user/operator to control the loader at load time.
It should be possible to include user-generated loader directives in the object ﬁle,to override and modify other loader features and conventions, and even to updatethe list of object ﬁles during load time. As a result, loaders accept directives andcommands (options) in addition to those in the object ﬁles. The options are nor-mally included in the command line types at the keyboard. They may also be readfrom a special command ﬁle, input by the loader when it starts. Alternatively,the commands may be written in the source program, read by the assembler andconverted into loader directives.
We will consider the commands to be assembler directives, translated by the
assembler into loader directives. However, they can be sent to the loader by any ofthe methods described above.
TheORGdirective has already been discussed in chapter 3. It is converted by
the assembler into a loader directive and serves to specify a start address for theprogram, overriding any normal loader selection of the start address.
214 Loaders Ch. 7
Normally, when the loader detects errors, it does not start execution. It is
possible to override this and instruct the loader to execute the program in thepresence of certain errors. This may make sense if certain external symbols remainunresolved, but the programmer knows that this particular run will not use theirvalues.
To change the list of object ﬁles to be loaded, the loader accepts INCLUDE and
DELETE commands. The INCLUDE command has the general form
INCLUDE ﬁle name,device name
It speciﬁes an object ﬁle, perhaps a library routine, to be included in the load. TheDELETE command tells the loader that a certain object ﬁle should be deleted from
the list of object ﬁles to be loaded.
The ‘CHANGE old name,new name’ command instructs the loader to change, in
the GEST, the name of an external symbol. This command is used when the userdecides to change a certain routine after the program has been assembled. Imaginea program with a ‘ CALL COS ’ instruction, calling a routine COSin object ﬁle (or
library ﬁle) MATH. The user has decided to use another routine COS1, located in ﬁle
NEW. The following loader commands may be necessary:
DELETE MATHINCLUDE NEWCHANGE COS,COS1
Other loader commands are mentioned in the following sections, in connection
with library search, overlays, and other loader features.
7.8 Library Routines
The use of library routines is very common. Many assemblers and compilers
come with large sets of routines, mostly mathematical and statistical, that caneasily be used by mentioning their names in a program. With an assembler, it isnot enough to write ‘ CALL SIN ’ even if the programmer knows that SINis a library
routine.SINmust also be declared as external. This feature is easy for the loader to
handle. Every time an instruction needs special relocation, the loader searches theGEST. If the symbol is found but has no value, the loader does not issue an errorbut assumes that the symbol is the name of a library routine. The loader searchesthe library and, on ﬁnding the routine, it is loaded as any other object ﬁle. This, ofcourse, implies that library routines must exist in the library in the form of objectﬁles.
/
Exercise 7.9 Library routines are in the form of object ﬁles. Can such a routine
be an absolute object ﬁle?
When such a routine is loaded, it may call other routines, which means more
library searches but no special complications for the loader. If a library search fails,the loader issues an error message and will not execute the program.
Sec.7.8 Library Routines 215
/
Exercise 7.10 What kind of message?
Since this feature is used a lot, a quick library search is important. The library
is typically a disk where each ﬁle constitues one routine, and a library search meanssearching the directory of the disk, a common OS operation. Many OSs even keeplibrary directories permanently in memory, thereby speeding up the search. If thereis more than one library, they should all be available at load time, ready to beaccessed by the loader. Otherwise, the loader has to stop and ask for a library tobe mounted.
The command ‘ LIBRARY name’ instructs the loader to load all the routines in
a certain library. It is similar to the INCLUDE command mentioned above but it
explicitly tells the loader that the ﬁle to be included is a library and should only besearched when an undeﬁned external symbols is found.
Many libraries are stored on single ﬁles. A single ﬁle includes all the routines of
a certain library and, on ﬁnding the name of a routine in this ﬁle, the loader loadsthe entire ﬁle. This, of course, has the disadvantage that memory space is taken forroutines that may never be used. However, if the program eventually needs severalroutines from that ﬁle, the entire load is speeded up.
Another advantage of this feature is that a programmer can override a library
routine. If the programmer decides to use a special version of SIN, he only needs
to code that version and supply it to the loader on a separate object ﬁle, with itsname declared as an entry point. This would result in a GEST where the externalsymbol is deﬁned, and the loader would not search the library.
Since a library search is initiated by an undeﬁned external symbol, one can
easily use libraries of data, not just routines. Even directives such as ‘ ZD CY ’,
whereYis declared ‘external’, would cause the loading of a library ‘routine’ which,
in this case, would probably be a block of data.
If a certain test run is not going to call routine ABC, the user can speed up
the loading by issuing the command ‘ NOCALL ABC ’. This loader command tells
the loader not to search any library for routine ABCeven ifABCis an unresolved
external symbol. The ‘ NOCALL ALL ’ command means no automatic library search
at all. This command should be used carefully since it means that any unresolvedexternal references would lead to a loader error.
7.9 Overlays
Many modern computers use virtual memories that make it possible to run
programs larger than the physical memory. Either one program or several programscan be executed even if the total size is greater than the entire memory available.When a computer does not use virtual memory, running a large program becomes aproblem. One solution is overlays (orchaining ), which will be discussed here since
its implementation involves the loader.
Overlays are based on the fact that many programs can be broken into logical
parts such that only one part is needed in memory at any time. The program is
216 Loaders Ch. 7
divided, by the programmer, into a main part (the overlay root), that resides in
memory during the entire execution, and several overlays (links or segments) thatcan be called, one at a time, by the root, loaded and executed. All the links sharethe same memory area whose size should be the maximum size of the links. A linkmay contain one program or several programs, linked in the usual way. At anygiven time, only the root and one link are active (but see the discussion of sublinksand tree structure below). Two features are needed to implement overlays:
A directive declaring the start of each overlay. Those directives are recognized by
the assembler which, in turn, prepares a separate object ﬁle for each overlay.
A special ‘ CALL OVERLAY ’ instruction to load an overlay (a link) at run time.
Such an instruction calls a special loader routine, the overlay manager, resident inmemory with the main program, which loads the speciﬁc overlay from the object ﬁleinto the shared memory area. The last executable instruction in the overlay mustbe areturn . It should return to the calling program, which is typically the main
part, but could also be another overlay. Such a return works either by popping thereturn address fron the stack, or by generating a software interrupt, that transferscontrol to the overlay manager in the OS.
A typical directive declaring an overlay is ‘ OVERLAY n ’ (or ‘LINK n ’) wherenis
the overlay number. Each such directive directs the assembler to ﬁnish the previousassembly, write an object ﬁle for the current overlay, and start a new assembly forthe next overlay. The ENDdirective terminates the last link. The result is a number
of object ﬁles, the ﬁrst of which is a regular one, containing the main program. Allthe rest are special, each containing a loader directive declaring it to be an overlayand specifying the number of the overlay.
The loader receives the names of all the object ﬁles, it loads the ﬁrst one but,
upon opening the other ones, ﬁnds that they are overlays. As a result, the otherobject ﬁles are not loaded but are left open, accessible to the loader. The loaderuses the maximum size of those ﬁles as the size of the shared memory area andloads, following the main program, a routine that can locate and load an overlay.At run time, each ‘ CALL OVERLAY[n] ’ (or ‘CALL LINK ’) instruction, invokes that
routine which loads the overlay, on top of the previous one, into the shared area.As far as relocating the diﬀerent overlays, there are two possibilities: The ﬁrst oneis to relocate each overlay while it is loaded. The other possibility is to preparea pre-relocated (absolute) version of each overlay and load the absolute versions.This requires more load time work but speeds up loading the overlays at run time.Generally, an overlay is a large part of the program and is not loaded many times.In such a case, the ﬁrst alternative, of relocating the overlay each time it is loaded,seems a better choice.
In general, each overlay may be very large, and sub-overlays can be declared.
The result is a program organized as a tree where each branch corresponds to anoverlay, each smaller branch, to a sub-overlay, etc. Figure 7–7 is an example of sucha tree.
The table below assumes certain sizes for the diﬀerent links and a start address
A
JE F G H IB C DSec.7.9 Overlays 217
Figure 7–7. An Overlay Tree.
of 0 for the root A. It then shows the start addresses of each link and the total size
of the program when that link is loaded.
total
name size start size
A 1000 0 1000B 500 1000 1500E 350 1500 1850F 700 1500 2200G 100 1500 1600C 200 1000 1200D 250 1000 1250H 100 1250 1350J 200 1350 1550I 250 1250 1500
LinksB,C,Dall start at the same address. Also E,F,Gstart at address 1500
and , similarly, H,Istart at 1250. The combined size of all the links is 3350, but the
maximum amount of memory needed is only 2200 locations (when link Dis loaded).
In keeping with tradition, we say that the root is the lowest level in the tree.
The main rule concerning the layout of links in memory is: if link Xis loaded in
memory, all other links lower than X, that connect Xto the root, must also be loaded
at the same time. This rule implies that, when Xcalls a lower link, that link should
be active. If it is not, the loader should issue an error. When Xcalls a link on the
same level as itself, it is always an error. When Xcalls a link higher than itself, it
must be exactly one level higher, and it must be a son of Xin the tree.
To implement such a tree overlay structure the programmer should deﬁne the
structure in advance, to make it possible for the loader to check and verify everycall to a link and every return. To deﬁne the tree, the programmer must start eachoverlay with an OVERLAY command specifying the name of the overlay and the name
218 Loaders Ch. 7
of its parent. The general format is OVERLAY name, parent . In the above example
the loader sees the following commands
id pair
OVERLAY A,-- (0,0) The root is always (0,0)
OVERLAY B,A (1,0) The parent is A, so B’s level is 1
OVERLAY E,B (2,0) The serial numbers start at 0
OVERLAY F,B (2,1) Level 2 has 5 overlays, numbered
OVERLAY G,B (2,2) 0 thru 4
OVERLAY C,A (1,1)
OVERLAY D,A (1,2)
OVERLAY H,D (2,3)
OVERLAY J,H (3,0) Level 3 has only one overlay
OVERLAY I,D (2,4)
that identify the tree structure. Note that this identiﬁcation is not unique. Switch-
ing the declarations for overlays E,Fwould make no diﬀerence for the loader al-
though, in principle, it would declare a diﬀerent tree. The loader assigns idnumbers
to the overlays based on their place in the tree. Each idis a pair ( level,serial ) where
‘level’ is one greater than the level of the parent, and the serial number is unique inthe level. The idpairs are shown in the list above. To control overlay loading, the
loader maintains one table, the overlay table (OT), containing the name, idpair,
and status of each overlay. The OT is used to decide whether an overlay call is validand where to load the next overlay. The OT starts with just the root active:
A 0,0 a
B 1,0 - E 2,0 - F 2,1 - G 2,2 -
C 1,1 - D 1,2 - H 2,3 - J 3,0 - I 2,4 -
A status of ‘ a’ means active and a status of ‘ -’ means not loaded. Suppose that a
while later overlays D,Hare loaded. The OT should be updated to:
A 0,0 a B 1,0 - E 2,0 - F 2,1 - G 2,2 -
C 1,1 - D 1,2 a H 2,3 a J 3,0 - I 2,4 -
To see how the OT is used to manage overlay loading and deleting, consider the
case where overlays A,D,Hare active. From ﬁgure 7–7 it is obvious that the only
overlay that can be loaded at this point is J. The rule in such a case is: Only the
highest-level active overlay can issue an overlay-call instruction.
Similarly, the only overlay that can be deleted, by a RETinstruction, is H,
implying that only the highest-level active overlay can issue a RET. The main step
in deleting an overlay is to change its status in the OT from ato-.
One more rule is needed, to determine what overlays can be called at any time.
To understand this rule, let’s examine the case where overlays A,Dare active. Again,
ﬁgure 7–7 shows that either HorIcan be called, which suggests the rule: When
overlayX, with level xl, callsYthen:
1. the level of Ymust bexl+1.
2. When scanning the OT, from left to right, starting with X,Ymust be found
before reaching an entry with a level ≤xl(or before reaching the end of the table).
Sec.7.9 Overlays 219
/
Exercise 7.11 The serial numbers of the overlays in the OT do not seem to be
necessary. What are they used for?
7.10 Multiple Location Counters
This feature has been mentioned in chapter 1 since it also involves the as-
sembler. This section describes how the loader supports this feature. The mainconcept involved is multiple passes. The loader has to read the object ﬁle once foreach location counter. In order to execute the USEdirective, the assembler switches
to a diﬀerent location counter (in pass 1) and also generates a ‘use’ loader directive(in pass 2) and writes it on the object ﬁle. The example from chapter 1 will be usedto illustrate the way the loader handles multiple location counters.
section useloader
size
directive
. main 0
. (1) 80
.
USE DATA DATA 0
.. (2) 24
.
USE * main 80
.. (3) 30
.
USE BETA BETA 0
.. (4) 45
.
USE DATA DATA 24
.. (5) 75
.
USE blank main 110
.. (6) 15
.
USE GAMMA GAMMA 0
.. (7) 10
.
END
We have already seen that, at load time, the diﬀerent sections are loaded in
the order MAIN,DATA,BETA,GAMMA or 1,3,6,2,5,4,7. When the loader sees the ﬁrst
‘use’ loader directive, at the beginning of the object ﬁle, it loads the ﬁrst section
220 Loaders Ch. 7
and reads the rest of the ﬁle, looking for more uses of the same section. It ﬁnds two
more (3 & 6) and loads them. In the second pass, it starts with section DATA(2)
and reads the rest of the ﬁle to ﬁnd and load the remaining part of that section (5).Pass 3 loads the single BETAsection (4) and pass 4, the single GAMMA section (7).
This is a simple process involving one simple data structure, a list of the ‘use’
directives. In the ﬁrst pass, while loading all the sections of the ﬁrst locationcounter, the loader reads all the ‘use’ directives and stores them in a list. Beforeeach pass, the loader ﬁnds the ﬁrst remaining item on that list and thus knows whatLC to load in that pass. Each time a section is found in the object ﬁle and loaded,the loader deletes the corresponding item from the list. When the list is empty, theloader is ﬁnished.
The ‘use’ loader directive contains the name and current value of the LC to be
used in the following section. The loader compares that information to the currentload address, which constitutes a good check of the integrity of the object ﬁle (seereview question 7–7).
7.11 Bootstrap Loaders
They answer the obvious question: how to start the computer for the ﬁrst
time. Imagine a brand new computer, delivered with a blank memory. A loaderis needed to load the ﬁrst program but, since the loader is itself a program, howdoes one load the loader? The problem pops up each time the computer’s memorybecomes blank. There are two solutions, both based on the concept of a bootstrap
loader .
The ﬁrst solution is to have switches on the computer console where the operator
can manually enter a small loader. The loader constitutes just a few machineinstructions that are assembled by hand and entered, through the switches, intomemory. This small loader then loads the main loader which, in turn, loads the OSand user programs. This is the bootstrap process . This approach was very popular in
the past, when core memories were used. Core memory is non-volatile, which means
that once the bootstrap loader was loaded from the console, it stayed in memoryfor a long time. It could only be erased if a user program needed all the availablememory, or if such a program overﬂowed and there was no memory protection.
The second solution is to have a bootstrap loader in ROM. This has been the
common approach since the mid 1970s, when semiconductor memories came intowide use. Those memories are typically volatile but ROM isn’t. A bootstrap loaderin ROM can never be erased and is always available. Such a loader is the basisfor any turnkey computer system, where the user only has to switch the computeron, and the OS is automatically loaded, followed by a user program. The onlyrestriction is that the memory locations occupied by ROM can never be used byuser programs. Since the bootstrap loader is small, this restriction is a small priceto pay for such a convenience.
/
Exercise 7.12 How can one remove the restriction above?
Sec.7.11 Bootstrap Loaders 221
Typically, the bootstrap ROM contains a very small loader that reads a ﬁxed-
size record from an I/O device (the device can be speciﬁed by the operator) intoa predetermined memory area, then jumps to the start of that area. The recordshould contain a small loader (the second one in the bootstrap process) which, inturn, can load the main loader (the third one so far). The main loader is then usedto load the rest of the OS. The advantage—the ﬁxed length record can easily bemodiﬁed if the OS is updated.
7.12 An N+1 address Assembler-Loader
Several ﬁrst-generation computers had most (or even all) of their storage on a
magnetic drum . In such a computer, loading a program meant writing the object
code on the drum, ready for execution. The best way to position instructions on thedrum is to consider the execution time of each instruction. If a certain instruction isfetched from address xon the drum, and if it takes time yto execute the instruction,
than one can easily calculate the drum address that would be under the read/writehead when the instruction is completed. That drum address is, of course, the idealposition for loading the next instruction. Loading it anywhere else on the drumwould cause a delay in fetching it, since the control unit would have to wait forthe slow drum to bring that instruction under the r/w head. Such computers arecalled n+1address machines , since each instruction should contain, in addition to
itsnoperands, also the drum address of its successor. If the instructions contain
addresses of operands, each opearnd also has an ideal drum address, depending onthe time interval between the moment the instruction is fetched and the momenteach operand is needed.
Today, with inexpensive random-accesss memories, instructions are loaded se-
quentially and the concept of n+1 addresses has only historic value. Examplesof such computers are the Bendix G15, the ACE computer, designed and built in1946 at the National Physical Laboratory in England, and the IBM 650. Thosecomputers were 1+1 address machines.
The 650 [88, 98] was a decimal computer . It had a drum with a total capacity
of 2000 locations, each a word with a capacity of 10 decimal digits. The words wererecorded on the drum on 40 bands, each a circular track with 50 words. Addresses
ranged from 0000 through 1999 where each band had 50 consecutive addresses.The drum had a separate read/write head for each band but the processor coulduse only one head at any time. As a result if, at a certain point in time, the r/whead was above location 0003, the processor could read either that location or anyof locations 0053, 0103, 0153, ...0653,..., 1953 at that time.
The computer had no random accesss memory, but it had additional hardware
that could be accessed by the machine instructions, using special, 800x addresses.Ten Console switches could be read as address 8000, a temporary register called thedistributor had address 8001, and a 20-digit accumulator had addresses 8002 (for
the lower 10 digits) and 8003 (for the upper 10 digits). Each instruction was 10digits long, with the format:
222 Loaders Ch. 7
OpCode Operand Next Instr.
24 4
Example: An AU(Add Upper) instruction. Ideally, the operand of this instruc-
tion should be 3 locations away from it. The next instruction should be 4 locationsaway from the operand. As a result, if the AUhappened to be loaded at drum
address 0036, it could be assembled into 10 0039 0043 or, in general, into 10 xx39
yy43.
The SOAP assembler, mentioned in the introduction, for the 650 computer,
had a table (stored, of course, on the drum) containing the execution times of allthe instructions, and the ideal separation between each instruction and its operand.It would read the source lines from punched cards, eight instructions per 80-columncard, assemble each and load it on the drum with the address of its successor. Ithad a 2000-digit table, maintained on 200 drum locations, specifying those drumaddresses that have already been loaded with instructions and data. If the nextinstruction had to go into, say, address 0020, and the table indicated that 20 isalready occupied, the assembler would try locations 21, 22, ...until it found an
available location on the drum. Thus SOAP was a combined assembler-loader forthe 650, a 1+1 address computer. Below is an example of a SOAP program (actually,a section of a larger program).
Source Object
Label Mnem oper- Next Loc. Op oper- Next
and instr. code and instr.
RAU LSD 0001 60 0002 0007SRT 0004 0007 30 0004 0017MPY SY001 0017 19 0022 0023
00 0000 0240 0022 00 0000 0240
SY001 STL TY005 0023 20 0028 0033
SRT 0008 0033 30 0008 0043MPY SY002 0043 19 0048 0049
00 0000 0012 0048 00 0000 0012
SY002 AL0 TY005 0049 15 0028 0034
SL0 8002 0034 16 8002 0044SRT 0008 0044 30 0008 0054AUP 8001 0054 10 8001 0064STU RSLT 0064 21 0003 0008
Note the following:
Sec.7.12 An N+1 addressAssembler-Loader 223
The ﬁrst MPYinstruction multiplies (the acc) by 240 . The constant itself is stored,
as part of a NOPinstruction, in the word that follows the MPY(drum location 0022).
The same thing is true of the second MPY, which uses the constant 12.
SymbolTY005 has a value of 0028 and is deﬁned outside this section of the pro-
gram. Addresses 8001, 8002 have been explained earlier.
224 Loaders Ch. 7
7.13 Review Questions and Projects
1.Below there is a simple program and four address expressions. Identify the type
of each of the seven labels A-Gin the program, explain how to evaluate each of the
expressions, and indicate the type of the result.
ENTRY A,B
EXTRN C,G address expressions
D EQU 1 a. E-F+D
. b. C-E
B- - c. A-B
. d. D+G-C
E- -A- -
.
F- -
.END
2.Compare and contrast overlays and dynamic linking.
3.An undeﬁned external symbols is normally interpreted as the name of a library
routine, causing the loader to search the library. What are the advantages anddisadvantages of this interpretation?
4.What are the advantages and disadvantages of writing a loader in a higher-level
language?
5.A user program cannot invoke an operating system routine by calling it. It
has to artiﬁcially generate an interrupt to invoke the system routine. Why? Mostoperating systems texts provide a clear answer. Find it!
6.There are many types of loaders and many have more than one name. Several of
the names mentioned here are: Relocating Loader, Linking Loader, Linkage Editor,Linker, Binder, Absolute Loader, Bootstrap Loader, Assemble-Go Loaders. Usingthe references mentioned earlier in this chapter, make a list of all diﬀerent loadertypes, each with all its names.
7.The USE loader directive has the name and current value of the next LC to be
used. How does the loader use both items to check the integrity of the object ﬁle?
8.Refer to ﬁgure 7–7
a. Add two more overlays, K,L, as children of F.
b. Update the OT to include K,L.
c. Assuming that A,B,Fare active and FcallsG(an error). Show how the OT is
scanned according to the rules in this chapter, and the error discovered.
9.Redesign the MODIFY loader directive to ﬁt the instruction set of a computer
of your choice.
Sec.7.13 Review Questionsand Projects 225
7.13.1 Project 7–1
Write a simple assembler-loader to support a 1+1 address binary architecture
similar to that of the IBM 650. Our hypothetical computer has a 16-bit accumulatorand a drum with 4 bands, each a circular track with 16 locations numbered 0–15.An instruction or a number can be loaded into each location. This, of course, is avery small drum, much smaller than the one on the 650. However, the importantdiﬀerence between the drums is not the size but the fact that the 650 was a decimalcomputer, and so its drum size (2000) was an round decimal number. Ours is abinary computer and thus our drum size (64) is an integer power of 2.
Any location on the drum has an address of the form (b,l) and the LC should
also have two parts, a band and a location, which are 2 and 4 bits long, respectively.You should simulate the drum in a 4 ×16 array of 16-bit integers. The instructions
are, of course, very simple and all have the same format and size. The format is:
OpCode
Operand next instr.
size: 4 2+4 2+4 =16 bits
The number 16 is a good choice both for a decimal and for a binary computer.
Binary computers use 16-bit words because they equal two bytes. A decimal com-puter uses 4-bit digits. Therefore, each drum location on such a computer is a fewdigits long, 16 bits implying 4 digits.
We start with just a few instructions but, since there is room for an instruction
set of up to 16 instructions, you might want to add more instructions of your owndesign.
Mnemonic
Operand Next
fetch Instr. Note
ADD 45
LOD 21
STO 21
COM 43 1
BPL 33 2
HLT --
Notes:
1. it does not matter what COMdoes. It could be ‘compare’, ‘complement’, or
anything else.
2. If the acc is ≥0 then go to the next instruction, else go to to the instruction
whose address is in the operand fetch ﬁeld.
The operand-fetch column indicates the distance, on the drum, between an
instruction and its operand. The next intruction column indicates the distance be-tween the operand and the next instruction. There should also be the directives END,
DC,DS. Each instruction may have, in addition to its operand, a symbol indicating
226 Loaders Ch. 7
its successor, thus a JMPinstruction is not necessary. Example:
LOD A,X
..
X ADD B
TheLODinstruction is assembled with the address of the ADDas its successor.
Before implementing the assembler-loader, it is necessary to understand the
way our drum operates. We will consider three cases, each to be implementedseparately.
Case 1. The drum has just one head which starts at band 0, location 0 and
advances to the next address in each clock cycle. The address following (0,15) is(1,0) which means that, when the head reaches the end of a band, it automaticallymoves to the start of the next band. In such a case, when an instruction is loadedat address (x,13) and its execution time is 4, the ideal location for its successoris (x+1,1). If this location is occupied, the assembler should advance and testsuccessive locations until it ﬁnds an empty one. We will assume, for the sake ofsimplicity, that our test programs are short and can never overﬂow the drum.
/
Exercise 7.13 How do you know if a drum location is occupied?
Case 2. As before, the only diﬀerence being that address (x,15) is followed by
(x,0). We assume that the head does not automatically move from band to bandand, as a result, the program has to specify a head move. This is done simply byspecifying another band as the address of the operand or of the next instruction.Assume that an instruction at address (x,13) takes 4 units to execute. The idealaddress of the next instruction is therefore (x,1) but, if this address is occupied,it is better to load the next instruction in address (y,1) than in address (x,2). Weassume here that it is faster for the head to move to any band y than to wait in thesame band until the drum rotates to the next location.
Case 3. Similar to the 650 computer. Our drum now has 4 heads, one for
each band, positioned such that when one is above address (0,5) the other onesare above addresses (1,5), (2,5), (3,5). Only one head can be read at any time.If something should be placed in location (0,5) and that location is occupied, theassembler should try locations (1,5), (2,5), (3,5), then (0,6), etc.
Your task is to write an assembler-loader to assemble and load several test
programs into such a drum. It is interesting to note that such an assembler has noproblem with future symbols and thus does not need two passes. The assembler hasa symbol table (located, of course, on the drum) where each label is stored with itsvalue (a drum address). A situation such as
LOD A,X
..
X ADD B
Sec.7.13 Review Questionsand Projects 227
can be easily handled even though Xis a future symbol. On reading the ﬁrst line
from the source, the assembler searches the symbol table and, if it does not ﬁndX, assumes that Xis a future symbol. Since this is an unconditional jump, the ADD
instruction is the successor of the LODand thus the assembler determines its address
(x,y)—which is also the value of X—from the third column of the OpCode table.
The address of the ADDis known, even though it has not been read from the source
yet. The assembler then stores Xin the symbol table, which amounts to reserving
address (x,y). Later, when the ADDis read from the source, the assembler ﬁnds Xin
the symbol table. This also means that, before storing any instruction in address(x,y), the assembler should verify that the address is not reserved for any futureinstruction.
A conditional branch poses another problem. In a case like
BPL B
SUB.
B ADD
the assembler uses the OpCode table to ﬁnd out where to place the SUBandADD
instructions. The relevant entry is ‘ BPL 3 5 ’, which means that the SUBinstruction
should be placed 3 locations from the BPL, and the ADD, 5 locations from the SUB.
There is no need, of course, to actually simulate the execution of the test
programs. Rather, you should gather information on the way the program is loaded.The most important items to be evaluated are:
The number of preoccupied drum locations encountered while assembling and
loading instructions.
The total execution time lost because of instructions placed in less than ideal
drum addresses.
The same thing for operands. Note that the DC,DSdirectives specify constants
and arrays as part of the test program. Those should, of course, be placed on thedrum, but where? In a case such as
LOD A
.ADD A.
AD C 5
the assembler places Aon the drum when it encounters the ﬁrst usage of A(theLOD
instruction). This means that the ADDinstruction will have its operand placed unfa-
vorably and, as a result, would execute slowly. When a DSdirective is encountered,
the assembler should place the array wherever it ﬁnds room on the drum. Thisimplies that any instruction using the array as its operand would execute slowly.
228 Loaders Ch. 7
I should not dare to be so sad
So many years again—
A load is ﬁrst impossible
when we have put it down
—Emily Dickinson, I should not dare to be so sad, (1871)
I had to load up very carefully.
—Alan Harrington The white Rainbow, 1981
8. A Survey of Some
Modern Assemblers
Four modern assemblers are reviewed in this chapter, and their main features
described. They are all two-pass, sophisticated macro assemblers, and each is partof a complete development system including a debugger, loader and compilers. Theyare:
The Microsoft Macro Assembler (MASM) for the Intel 80x86 & 80x88 micropro-
cessors.
The Borland Turbo Assembler (TASM) for the same processors.
The VAX Macro assembler.
The MPW assembler for the Macintosh computer.
They all support many directives and advanced features. In principle they work
just like the older assemblers, but in practice they diﬀer in a number of points, themost notable of which are:
The way expressions are evaluated. Older assemblers normally calculate an ex-
pression such as 3 + 2 ∗4 strictly from left to right, and will end up with 20. The
assemblers described here use the normal operator precedence, and will produce 11as the value of this expression.
230 A Survey of SomeModern Assemblers Ch. 8
The structure of the MDT. Older assemblers typically require macros to be
uniquely deﬁned. Some allow multiple deﬁnitions of the same macro, and thensearch the MDT backwards, so they always ﬁnd the most recent deﬁnition. Theassemblers described here behave diﬀerently in this respect. Thay actually makeit possible to delete a macro from the MDT, thereby freeing up space for newdeﬁnitions.
Deleting a macro is done by changing its deﬁnition to the null string. This is
fast since there is no need to change any pointers. When a macro is redeﬁned, itsold deﬁnition is eﬀectively deleted by changing it to the null string. This opens upspace in the MDT, space that can be used for another macro, of the same size orsmaller. After many deﬁnitions and deletions, the MDT can become fragmented;there may be a lot of free space available in it, but only in small chunks. A reallysophisticated assembler may be able to compact the MDT at such a point. Thisrequires moving macro deﬁnitions around and changing pointers. In these days oflarge memories, such a thing hardly seems worth the eﬀort.
8.1 The Microsoft Macro Assembler (MASM)
This assembler (Ref. 102) is the standard by which all other assemblers for the
IBM PC are measured. It has gone through several versions, adding features andshedding bugs in the process. It is part of a sophisticated development system thatconsists of an editor, a cross-reference generator, a librarian, a linker, a debugger(CodeView), and several compilers.
8.1.1 The 80x86 & 80x88 microprocessors
MASM is actually an assembler for the Intel 80x86 and 80x88 family of mi-
croprocessors, including the 80x87 coprocessors. Before delving into the details ofMASM, a few words about this important family are in order.
The 8086 was developed by Intel as a 16-bit microprocessor. It was very suc-
cessful and led to the development of other, 16- and 32-bit microprocessors. Becauseof the huge investment in software development, all those microprocessors were de-veloped as a family, which means that they had to be upward compatible with the8086. The 8086 can address a megabyte of memory, and was designed for a single-user environment (we say that it runs in real mode only). No memory protection
exists.
The 8088 diﬀers from the 8086 in that it has an 8-bit data bus. It moves a
16-bit word in two halves, and is therefore somewhat slower than the 8086.
The 80186 has a few additional instructions and runs faster than the 8086.
There is also an 80188.
The 80286 is faster than the 80186, can address 16 megabytes (2
24), and was
designed for a multi-user environment. It is possible to load several user programsin memory, and switch the processor between them. The 80286 supports memoryprotection and privileged instructions, and can run in either real mode or protected
mode (multi-user). The older IBM PC, XT & AT computers can only run in real
Sec.8.1 The MicrosoftMacroAssembler (MASM) 231
mode. The newer PS/2 computers can run in protected mode. There are no 80288
or 80388 processors.
The 80386 has 32-bit registers, and can be used as either a 16-bit or a 32-bit
processor. It can address up to 4 gigabyte (232) of memory. It supports virtual
memory, multiple processes, and additional instructions to handle its new features.It is also faster than the 80286.
The 8087, 80287 & 80387 coprocessors can all operate on ﬂoating-point, dec-
imal, and large integers. They can perform arithmetic operations, and computeseveral common functions, such as sine & logarithm. The main diﬀerence betweenthem is that the 80287 can also function in the protected mode, and the 80387, inaddition, supports several new operations.
One important feature of all members of the family is the way they address
memory. They create 16-bit addresses (except the 80386, which creates 32-bit ones),so they can directly address only 64Kbytes of memory. A larger memory has to bedivided into several 64Kbyte segments. In such a memory, a physical address hasthe form segment:oﬀset , where the segment part comes from one of the segment
registers and the oﬀset part comes from the instruction. Addresses now have to be
mapped, i.e., the ﬁnal (physical) address has to be computed from the two parts.The mapping details are important to the assembly language programmer, and anyassembler for this family should support directives to handle segments. It shouldbe noted that segments have a lot of overlap, and are thus a source of confusion.Ref. 57 is a good source of information on 80x86 memory segmentation.
Now back to MASM. An important MASM feature is the ability to maintain
a library of pre-assembled programs. These can easily be located by the librarian,and loaded and linked with any new program.
8.1.2 MASM options
MASM is invoked by the MASMcommand, which speciﬁes the names of all ﬁles
involved (source, object, listing, and cross reference) and can select many options.Following is a list of some interesting or unusual options.
Many options are available for the command line, so the /Hoption helps the user
by displaying them all on the screen. The result of the command ‘ masm /h ... ’ is:
Usage: masm /options source(.asm),[out(.obj)],[list(.lst)],[cref(.crf)][;]
/a Alphabetize segments
/c Generate cross-reference/d Generate pass 1 listing/D<sym>[=<val>] Define symbol/e Emulate floating point instructions and IEEE format/I<path> Search directory for include files/l[a] Generate listing, a-list all/M
{lxu}Preserve case of labels: l-All, x-Globals, u-Uppercase Globals
/n Suppress symbol tables in listing/p Check for pure code
232 A Survey of SomeModern Assemblers Ch. 8
/s Order segments sequentially
/t Suppress messages for successful assembly/v Display extra source statistics/w
{012}Set warning level: 0-None, 1-Serious, 2-Advisory
/X List false conditionals/z Display source line for each error message/Zi Generate symbolic information for CodeView/Zd Generate line-number information
A pass-1 listing can be created by the /doption. Since pass 1 does not handle
future symbols, the listing will ﬂag those symbols as undeﬁned, in addition to otherpass 1 errors. Chapter 5 features a sample MASM listing with the pass-1 errorsshown.
/
Exercise 8.1 What exactly does the /doption mean?
A pass 1-listing can be useful for locating phase errors. Those are errors stem-
ming from pass 1 assumptions that turn out to be wrong in pass 2. They arediscussed in Ch. 1.
The same letter, /D(upper case), is another option, used to deﬁne symbols and
assign them values. The symbol may then aﬀect the results of the assembly. A typ-ical example is the command ‘ MASM /Dwidth /Dopt=5 ...’. It creates the symbols
width (with a null value) and opt(with a value of 5). The source code may include
conditional assembly directives to test the values of those symbols, and assemblethe program diﬀerently. The ﬁrst of the two tests below:
ifdef width
page 60,130endif....if opt LT 10
optvdb opt
else
optvdb 10
endif
will check symbol width and, since it is deﬁned (on the command line), will execute
the ‘page 60,130 ’ directive, limiting the height of a listing page to 60 lines and its
width, to 130 characters. The second ifwill execute the ‘ optvdb opt ’ directive
and skip the ‘ optvdb 10 ’. This is an typical example of late binding.
The/MUoption tells MASM to convert all names read from the source ﬁle to
upper case. The /MLoption means MASM is to be case sensitive (names such as
segment &Segment should be considered diﬀerent). The /MXoption directs MASM
to make only public and external names case sensitive.
Sec.8.1 The MicrosoftMacroAssembler (MASM) 233
The/V(forverbose ) and/T(forterse) options control the amount of listing
produced.
The/Woption restricts the assembler to report only the more serious warnings.
Warnings are issued for ambiguous, ineﬃcient, or unclear instructions that are notillegal and can be assembled.
8.1.3 MASM listing
The listing produced by MASM contains the source and object codes, the LC
values, and the source ﬁle line numbers. The line numbers are used by the debuggerto direct the user to oﬀending lines. In addition, certain tables can optionally belisted, giving information about the macros, the structures and records, and thegroups and segments used in the program. In addition to that, things such as thesymbol table, pass-1 listing, and assembly statistics, can also be listed. A specialutility,CREF, can be used to generate the cross reference information. Chapter 5
contains examples of MASM’s pass 1 & pass 2 listings, and a cross-reference.
8.1.4 MASM source line format
The only thing unusual about the source line format in MASM is that only
labels of instructions need to terminate with a ‘:’. Labels of directives don’t requirea ‘:’. Lines are written in free format and may start in column 1 even if there is nolabel.
8.1.5 MASM directives
MASM supports more than 50 directives. Some directive names must start
with a period, but there does not seem to be any consistency. A few of the moreinteresting or unusual ones are described here.
TheDF(Deﬁne Far) directive allocates 6 bytes in memory. It is normally used on
the 80386 to store a pointer.
A question mark ‘ ?’ is used to indicate a zero-value, and the notation ‘ (?)’
indicates undeﬁned value. Thus ‘ x db ?,?,? ’ allocates 3 bytes with zeros, while
‘y db 3 dup(?) ’ allocates 3 undeﬁned bytes.
Thepublic directive declares symbols to be entry points. In most assemblers
this directive is called entry . Thecommdirective declares symbols to be communal
(both an external and an entry point). Such a thing is normally done when avariable should be shared by several modules. The variable is declared communal(typically with other such variables) in a module which then becomes an include
ﬁle. The ﬁle is included in all the other modules. An alternative is to declare sucha variable public in one source module and external in all the other ones.
The two directives if1andif2, evaluate to true in pass 1 and pass 2, respectively
(see example in Ch. 5).
Theifdef directive evaluates to true if its operand is a deﬁned name (if it appears
in the symbol table). A future symbol is undeﬁned in pass 1, but there are no future
234 A Survey of SomeModern Assemblers Ch. 8
symbols in pass 2. Any undeﬁned symbol in pass 2 is really undeﬁned (an error).
A similar directive, .errndef , performs the same test and also generates an error
if the symbol is undeﬁned.
The equal sign ‘ =’ is used for redeﬁnable symbols (many assemblers use SETfor
the same purpose). Thus ‘ x=0’ can be followed by ‘ x=x+1 ’. Theequdirective is
used, as usual, for symbols that should be uniquely deﬁned. Note that on MASM,such symbols can have character strings as well as numeric, values.
The words short ,near&farare directives but, since they are used diﬀerently
from other directives, they are called operators . An instruction using the relative
mode has an oﬀset ﬁeld for the relative address. On the 80x86 microprocessors,
such an instruction has three versions—with oﬀsets of 1-, 2-, and 4 bytes—calledshort ,near andfar, respectively. When such an instruction refers to a future
symbol, the assembler does not know which of the 3 versions to use, and how muchroom to reserve for the instruction in pass 1. The user may help the assembler byusing one of the operators above. Thus if destis a future symbol, the instruction
‘jmp near dest ’ would be assembled with a 2-byte oﬀset. A short means an 1-byte
oﬀset, and a far—a 4-byte one.
When no operator is speciﬁed, the assembler reserves room (in pass 1) for a
nearoﬀset. If this turns out to be too much (only 1 byte is needed), the extra byte
is padded with a nopinstruction. If, on the other hand, 2 bytes turn out not to
be enough (the destination is far), a phase error is generated by pass 2, and the
program has to be reassembled.
8.1.6 MASM expressions
MASM can handle expressions with many operators. Operands must be ab-
solute, except that the binary ‘ +’ operator can operate on one absolute and one
relative operand, and the binary ‘ -’ operator can, in addition to that, be used to
subtract two relative operands (but only if they are located in the same segment).
Indexing is denoted by square brackets, and there can be several of them in
the same expression. Thus ‘ movah,array[bx][di] ’ is valid.
Expressions can be shifted by the shl&shroperators. They are not the
80x86 shift instructions (even though they have the same name), and are executedat assembly time. A typical example is ‘ movax,01010001b shl 3 ’ which moves
the binary number ‘ 01010001000 ’ into register ax.
Thenot,and,or&xorlogical operators can be used in expressions, and are
thus executed at assembly time. Again, they should not be confused with the 80x86instructions (which happen to have the same names).
Relational operators are allowed. The instruction ‘ movax,2 eq 4 ’ moves the
value zero (false) to ax(a value of −1 corresponds to true).
A ‘$’ is used for the LC value. Thus the following is very common:
Sec.8.1 The MicrosoftMacroAssembler (MASM) 235
labelA db "a long string whose size "
db " needs to be known."
labelB equ $-labelA
and equates the value of labelB with the length of the string.
The normal is operator precedence is used, and parentheses can be employed
to modify it. There is also strong typing for operands. The seemingly innocentinstruction ‘ movax,sors[1] ’ can cause a warning if symbol sors is deﬁnd as a
byte (‘sors db 123 ’). This is because axis a register, and thus of type word.
The instruction will be assembled and will move the two bytes starting at sorsto
registerax. This may or may not be what the user wants, and it is an example of
a confusing instruction.
8.1.7 MASM macros
As can be expected, MASM supports an extensive macro facility. Macros can
have many parameters (as many as will ﬁt on one line), both macro expansionsand macro deﬁnitions can be nested, and an extensive set of conditional assemblydirectives permits recursive macros. Macros can be redeﬁned and even deleted(with the purge directive) from the MDT, to make room for new deﬁnitions. An
interesting point is that a macro can purge itself, but the purge command must be
the last line of the macro.
In addition to macros, powerful directives such as irpcan be used to create
copies of blocks of code (repeat blocks) that depend on parameters. A commonexample is:
FiveInts label byte
irp p,<0,1,2,3,4>db 5 dup(p)endm
which also demonstrates the use of the label directive.
8.2 The Borland Turbo Assembler (TASM)
The Borland Turbo Assembler (referred to as TASM) is an example of a fast,
sophisticated, multi-pass assembler for the Intel 80x86, 80x88 family of 16-bit mi-croprocessors. It is described in reference [99]. Perhaps its most interesting featureis that it is multi-pass, but can be limited by the user to a certain, maximum,number of passes. It is shown below that certain forward references require threepasses to generate optimum code. If TASM is limited to just one- or two-passes, itworks faster but may generate less than optimal results.
Other important features of TASM are: high speed (close to 50000 lines per
minute is claimed by Borland literature on fast IBM PS/2 models); support of mem-ory segmentation; support of structures, records, and unions; local labels; supportfor Turbo debugger, and a full macro facility.
236 A Survey of SomeModern Assemblers Ch. 8
TASM is invoked with the TASMcommand where the user can specify certain
options. Among them is the maximum number of passes. Thus the command‘TASM \m1 test ’ invokes the assembler, limits the number of passes to 1, and sup-
plies the name of the input ﬁle ‘ test.asm ’. This makes sense if fast assembly is
important, and the user knows that there will be no complex forward references.
8.2.1 Special TASM features
Below is a summary of some of the special or unusual features of TASM.
Source ﬁle format: Source lines have a free format, a backslash ‘ \’ indicates that
there will be a continuation line, and a ‘;’ precedes a comment. An interestingaspect of the source line format is the labels. A label appearing on a line by itselfmust terminate with a ‘:’. The same is true for a label that labels an instruction.However, when a directive is labeled, no ‘:’ is needed. Thus the following lines areall valid:
StartLongLoop:
add ax,dx
l: jmp done
Token dw 1
This makes it somewhat easier to write the program, but makes it harder for the
assembler to recognize labels.
No special syntax is used on the source lines for the immediate mode. The int
instruction (which causes an artiﬁcial interrupt) does not use the immediate mode,so ‘int 21h ’ causes an interrupt to address 21
16. Themovinstruction, on the other
hand, uses the immediate mode, so ‘ movcx,100 ’ moves the decimal constant 100
to register cx. Because of the way memory is organized into segments, there is no
absolute mode on the 80x86 microprocessors. It is possible to reach any absoluteaddress by selecting the segment where the address is located.
Expressions. TASM supports expressions with nested parentheses, and logical and
relational operators. There is operator precedence, and there are many operators.
Extended call. TASM has been written by Borland International, a company
known for its Turbo compilers. As a result, the TASM callinstruction has been
extended to allow easy interface with Turbo Pascal and Turbo C. A callinstruction
can specify any of these languages, and arguments will be passed in a consistentmanner.
Extended pushandpop. These instructions have been extended to allow for more
than one operand. Thus things such as ‘ push cx dx ’, ‘pop dx cx ’ will each handle
two registers.
Predeﬁned variables. The following names can be used to get useful informa-
tion about the current assembly run. ??date, ??time, ??filename, ??version .
They are self explainable.
Sec.8.2 The Borland Turbo Assembler (TASM) 237
8.2.2 TASM local labels
The concept of a local label has been discussed in Ch. 1. In TASM, a local
label should start with @@and its scope is limited by any regular label. Thus in the
code section:a: add ax,dx
@@dest inc bx
..add ax,dxjz @@destand al,dl
l: jmp done
..
@@dest adc dx,bx
thejzwill jump to the incinstruction and not to the adc. There is a nolocals
directive to disable local labels. Also, when TASM is used in MASM mode, locallabels are disabled (since MASM does not support them) and can be explicitlyenabled by the locals directive.
8.2.3 Automatic jump-sizing
The conditional jump instructions on the 8086 microprocessor have a 1-byte
relative jump address. As a result, such an instruction is very short (only two byteslong), but can jump only within the range of 256 bytes centered on itself. Thuswhen a ‘jz dest ’ is necessary, and dest is out of range, the programmer has to
replace it with:
dest: ..
....jnz tmpjmp dest
tmp: ..
..
(The opposite of jz, followed by a jmp.) Thejmpinstruction is 3-bytes long and can
jump anywhere. The problem is that the programmer cannot always tell beforehandwhat the exact jump distance is and whether such a construct is necessary. Thealternatives in such a case are:
1. Write the conditional jump as above, perhaps wasting 3 bytes and the time
required to execute the jmp.
2. Write just the conditional jump and wait for an error message from the
assembler. This has the disadvantage that, after adding some instructions to aworking program, the distance between the conditional jump instruction and itsdestination may suddenly become too large, causing an unexpected error message(relative jump out of range).
3. Use the jumps directive. When this directive is in force (its eﬀect can be
nulliﬁed by the nojumps directive), TASM will check each conditional jump and,
238 A Survey of SomeModern Assemblers Ch. 8
if it is out of range, will automatically replace it by its opposite conditional jump,
followed by a jmp.
This is an attractive alternative and an example of a powerful directive. It is
called automatic jump-sizing. It works perfectly for conditional jumps backward,but cannot always work for forward jumps. The reason is that TASM is sometimeslimited, by the user, to just one pass. Obviously, a one-pass assembler cannot tellthe jump distance for a forward jump. In the case of a forward jump, the best thatTASM can do is to reserve 5 bytes and wait until it reaches the destination of thejump. At that point it either creates the construct above (if the range is too large)or it creates the necessary conditional jump, followed by three nopinstructions.
Even a two-pass assembler cannot handle such a case. Recall that the ﬁrst pass
has to do all the memory allocation and assign LC values to all instructions. Whenthe ﬁrst pass gets to a forward jump instruction, the jump distance is unknown.Therefore, the best that a two-pass assembler can do is to allocate 5 bytes, incrementthe LC by 5, and continue.
It requires at least three passes to always handle automatic jump-sizing without
creating unnecessary nopinstructions. The ﬁrst pass assigns tentative LC values,
just to determine all the jump distances. The second pass knows the jump distances,so it knows whether to allocate 2- or 5 bytes to each conditional jump. The secondpass thus assigns the ﬁnal LC values. The third pass does the actual assembly. (Iftwo or more jump ranges overlap, more than three passes may be necessary, andthe entire process may become very complicated.)
The result is that, while a program is being debugged, it makes sense to limit
TASM to one or two passes, for fast assembly. When a program is considered readyfor production runs, it should be assembled once, allowing several passes, to end upwith optimized code.
As an alternative, jumps ,nojumps pairs may be used to enable automatic
jump-sizing in certain parts of the program and disable it in other, more critical,parts.
8.2.4 Forward references to code and data
The forward referencing problem in TASM is general and not limited to con-
ditional jumps. The unconditional jmpinstruction, e.g., has several varieties. The
‘jmp short ’ with a 1-byte opcode and a 1-byte oﬀset; the ‘ jmp near ’ with a 1-byte
opcode and a 2-byte address, and the ‘ jmp far ’ with a 1-byte opcode and a 4-byte
oﬀset, If TASM is limited to one- or two passes, then it reserves three bytes for eachjmp. Eventually these bytes are either ﬁlled with a ‘ jmp near ’ or with a jmp short
followed by a nop. If it turns out that a ‘ jmp far ’ is needed, an error results and
reassembly is necessary.
The user can help TASM create better code if he can estimate the distances
involved. The user can always write ‘ jmp short x ’o r‘jmp far y ’, which will
create the speciﬁed version of jmp.
Sec.8.2 The Borland Turbo Assembler (TASM) 239
A similar problem exists with other instructions. The movinstruction, e.g.,
has a 4-byte version that can hold a full address, and a 2-byte version that canhold a small constant. When TASM reads a source line such as ‘ movbl,abc ’, and
ﬁnds that abchasn’t been deﬁned yet, it assembles the movas a 4-byte instruction,
assuming that abcwill turn out to be a normal label. If abcturns out to be a
constant (e.g., ‘ abc equ 5 ’), then the short version of movis created, followed by
twonopinstructions.
8.2.5 Conclusions:
The programmer should develop a style that minimizes forward references. Ar-
rays and other variables should be declared at the start of the program. Also,subprograms should precede the main program.
While the program is in the debugging stages, the programmer should allow for
one- or two passes, and be prepared for less than optimum code generated. Whenthe program is deemed clean of bugs, it should be assembled one more time, allowingfor more passes. The resulting code should be optimum.
8.2.6 TASM macros
TASM supports a sophisticated macro facility, including:
Conditional assembly (there are if, else, endif andexitdirectives, as well as
a few more, just for this purpose).
Local labels (a label deﬁned as local in a certain macro will be assigned a local
name of the form ??0001 ,??0002 , etc.).
Nested macro expansions and deﬁnitions.
8.2.7 The Ideal mode
TASM was designed as a competitor to the MASM assembler. It has a very
high degree of compatibility and can assemble almost all MASM programs withoutany changes. However, to successfully compete with MASM, TASM has powerfulfeatures that are grouped under the name ideal mode . A program can use either
the MASM mode or the ideal mode and can even switch between the two by meansof theideal andmasmdirectives. Here are a few examples of ideal mode features:
A cleaner syntax. An example is the MASM instruction ‘ movax,[bx][si] ’
which uses ‘ bx+si ’ as an index. In the ideal mode, the same instruction is written
‘movax,[bx+si] ’.
Powerful operators. The high operator is usually used to select the high-order
byte of a word or a constant. In the ideal mode, it can also select the high part ofan index. Thus saying ‘ moval,high abc ’ moves the high-order byte of the word
at address abcto register al, whereas ‘ moval,[high abc] ’ moves the high-order
part of the address abcto the same register.
Simpler directive names. The MASM directive .radix , e.g., is named radix in
the ideal mode.
240 A Survey of SomeModern Assemblers Ch. 8
8.2.8 TASM directives
Most directives are not explicitly identiﬁed as such to TASM, but some have to
start with a period. Here are some interesting and unusual directives and notationsupported by TASM:
Theunion directive allows two variables to share the same memory area. It is
similar to the union statement in the C programming language. The ﬁrst step is
to deﬁne a data type such as debit by:
debit union
small db ?large dw ?debit ends
The next step is to declare an actual variable of type debit by, e.g.:
‘joe@debt debit <?,?> ’. When this is done, ‘ joe@debt ’ becomes a word in mem-
ory shared by the two variables ‘ joe@debt.small ’ (a byte) and ‘ joe@debt.large ’
(a word).
The ‘?’ symbol indicates an uninitialized memory location. Thus ‘ abc dw 10 ’
preloads the word at address abcwith the constant 10, while ‘ xyz dw ? ’ just re-
serves one word at xyz. An example is the directive ‘ ghk dw 20 dup (?) ’ which
duplicates ‘ dw (?) ’ 20 times, and results in an array ghkof 20 uninitialized words.
Thealign directive increments the LC to the speciﬁed power of 2. Thus ‘ align 8 ’
will increment the LC to the nearest multiple of 8, and will insert as many nop
instructions as necessary to pad up the empty bytes created.
8.3 The VAX Macro Assembler
This is a powerful, two-pass, macro assembler (Ref. 100) for the VAX assembler
language (also called Macro language). The name Macro now becomes ambigu-
ous; it leads to statements such as: “ ...and I got two errors in my ABCmacro in my
Macro program just assembled by VAX Macro assembler.” To reduce ambiguity,
the notation Macro is used here for the assembler (and the language).
8.3.1 Special Macro features
The command line options: The assembler is invoked by the macro command.
Many options may be speciﬁed on the line, the most interesting (not necessarilyimportant) of which are:
addrsize size. This sets the addresses displayed in the listing ﬁle to sizedigits
(typically 4 or 5).
check . No object ﬁle is generated. The assembler does a syntax check only.
fontfontname, fontsize . Sets the font used in the listing ﬁle to the one speciﬁed.
print noobj . Creates a short listing (which does not include the object code).
Sec.8.3 The VAX MacroAssembler 241
w. Suppress warning messages. The wboption suppresses branch warning mes-
sages only.
The source line format: Labels end with a ‘ :’. Labels deﬁned by Digital Equip-
ment Corp. (the manufacturer of the VAX computers) start with a ‘ $’. A label
can also end with a ‘ ::’, which declares it external. There is also an .extrn di-
rective that serves the same purpose. Comments start with a ‘ ;’. A hyphen typed
as the last non-space character before the comment indicates that there will be acontinuation line.
Special characters used by Macro are:
An equal sign ‘ =’ is the equate operator ( EQUon most assemblers). The notation
‘abc==12 ’ assigns the value 12 to abcand also declares abcan external symbol.
The at-sign ‘ @’ indicates a deferred (indirect) mode; square brackets ‘ []’ indicate
the index mode.
The logical AND, OR and exclusive OR operations are indicated by a ‘ &’‘!’, and
‘\’, respectively.
The circumﬂex ‘ ^’ indicates a unary operator, and is also used as a macro delimiter
argument.
The angle brackets ‘ <>’ indicate argument or expression grouping.
The percent sign ‘ %’ indicates a macro string operator.
Examples are:1. The expression ‘ #^M<R1,R3,R6> ’ means “an immediate operand which is a
register mask (the unary operator M) for registers 1, 3 and 6.”
2.^C^XFF . This indicates the complement of the hexadecimal value FF(or,
more precisely, the 32-bit hex value ‘ 000000FF ’). The result is the 32-bit hex value
‘FFFFFF00 ’.
8.3.2 Data types
This is an important concept on the VAX, and has to be constantly kept
in mind when writing an assembler program. The VAX hardware supports datatypes of diﬀerent sizes. Bytes, words (2 bytes), longwords (4 bytes), quadwords (8bytes), and octawords (16 bytes). There are also 4 diﬀerent formats of ﬂoating pointnumbers. Most instructions have special versions to handle these types (or someof them), and the programmer has to be careful to specify the right data type ininstructions. There are, e.g., the following instructions to move data: movb, movw,
movl, movq andmovo.
242 A Survey of SomeModern Assemblers Ch. 8
8.3.3 Local labels
They are supported and have the format ‘ nn$’ where ‘nn’ is a 16-bit number.
Local labels are only valid in their block, and the block can be terminated by:
A user-deﬁned label.
The.psect directive. This directive is used to divide the program up into blocks
with diﬀerent accesss codes that may be loaded into separate memory areas.
The.enable .disable directives. They are used, among other things, to deﬁne
local blocks overriding user-deﬁned labels and .psect directives.
8.3.4Macro directives
All directives start with a period. Macro supports more than 80 directives!
They are classiﬁed into 19 categories, eight of which are directives for handlingmacros. Some interesting or unusual directives are:
.debug —Any symbols declared with this directive are made known to the VAX
debugger. In an interactive session, the user can refer to those symbols by name,in order to get their current values from the debugger.
.default —The directive ‘ .default displacement,word ’ means that any in-
struction using the relative or relative deferred modes and a future symbol, willbe allocated a word for the displacement. This is a general problem and is not spe-ciﬁc to the VAX. Without this directive, pass 1 of the assembler does not know howlarge the relative distance (the displacement) is going to be, so it has to allocatethe largest size.
.enable —This directive can enable certain options. An example is:
‘.enable local block,global ’. This starts a block of local labels, and also spec-
iﬁes that all undeﬁned symbols should be considered external. (If such a symbolturns out to be undeﬁned, the linker will complain.)
.mdelete —Deletes a macro deﬁnition from the MDT, freeing memory for new
deﬁnitions.
Sec.8.3 The VAX MacroAssembler 243
8.3.5 Macros
The VAX Macro assembler supports an extensive macro facility. Macros can
have local labels, and can use both positional and keyword arguments. There areextensive string-manipulation functions that can handle string arguments. Nestedmacros are allowed, and the following short example is a useful application of nestedmacro deﬁnition:
.macro for reg,from,to,?lab
movl #’from,r’reg
lab:
.macro endforincl r’regcmpl r’reg,#’toblss lab.endm endfor.endm for
It can be used to implement the high-level construct for
in asembler. Macro for
generates a movinstruction, declares label lab, and them deﬁnes macro endfor .
That macro incremenst the loop counter, compares it to the ﬁnal value and, ifnecessary, branches back to the same label. Note the notation ?labwhich means
thatlabis a local label.
8.3.6 Addressing modes
The VAX computer has 24 addressing modes, and Macro uses a special no-
tation to select them. Table 8–1 is a summary of all the VAX addressing modes.Of special interest is the assembler syntax used. It ranges from simple (the regis-ter mode and relative mode have the simplest syntax) to complex (the longworddisplacement deferred mode, with the syntax @L^dis(Rn) is perhaps the most com-
plex).
8.4The Macintosh MPW Assembler
The Macintosh Programmer’s Workshop (MPW) is a powerful development
environment for the Macintosh computer. It consists of an editor, assembler, linker,debugger, several compilers, a resource editor and compiler, and various utilities.
The MPW assembler [103] is a powerful, 2-pass, modern assembler, supporting
many directives. It can assemble code for the 680x0 microprocessors and for the68881 ﬂoating-point coprocessor, and the 68851 paged memory management unit(PMMU). Its main features are:
Powerful macros (closely resembling the macro facility of the IBM 360, 370 as-
semblers). Both positional and keyword parameters are supported. Also supportedare nested macros, conditional assembly and SETsymbols (whose values can be nu-
meric, characters, strings, or arrays). Macros are deﬁned and expanded in pass 1.There is no separate pass 0.
244 A Survey of SomeModern Assemblers Ch. 8
Index
ModeSyntax Name Eﬀective Address base?
General register addressing
0–3S^#N Short literal None. Operand is N N
4b[Rn] Index c(b+s ·Rn) N
5Rn Register None. Operand is in Rn N
6(Rn) Register deferred c(Rn) Y
7-(Rn) Autodecrement Rn ←Rn-s, EA=c(Rn) ?
8(Rn)+ Autoincrement EA=c(Rn), Rn ←Rn+s ?
9@(Rn)+ Autoincrement deferred EA=c(c(Rn)), Rn ←Rn+4 ?
AB^D(Rn) Byte displacement c(Rn+D) Y
B@B^D(Rn) Byte displacement deferred c(c(Rn+D)) Y
CW^D(Rn) Word displacement c(Rn+D) Y
D@W^D(Rn) Word displacement deferred c(c(Rn+D)) Y
EL^D(Rn) Longword displacement c(Rn+D) Y
F@L^D(Rn) Longword displacement deferred c(c(Rn+D)) Y
Program counter addressing
8I^#N Immediate None. Operand is N Y
9@#A Absolute A Y
AB^A Byte relative A=c(PC+D) Y
B@B^A Byte relative deferred c(A)=c(c(PC+D)) Y
CW^A Word relative A=c(PC+D) Y
D@W^A Word relative deferred c(A)=c(c(PC+D)) Y
EL^A Longword relative A=c(PC+D) Y
F@L^A Longword relative deferred c(A)=c(c(PC+D)) Y
Notes:
The operand is the contents of the EA, except where there is no EA
N Absolute (literal number)c(...) “contents of mem loc. ...”b Index mode base addresss operand size, dependent on operation context:
s=1,2,4,8,16 according as the operation is a byte, word, ...octaword
? Yes, provided that Rn is not the index registerD Displacement. If byte or word, sign is extended to a longwordA Memory address
Table 8–1. Summary of the VAX Addressing Modes
Either one or several object ﬁles can be created.
Code & data modules are generated.
Templates can be deﬁned, that are similar to Pascal records.
Sec.8.4 The MacintoshMPWAssembler 245
Local labels, both inside and outside macros, can be used.
Optimized instruction selection (an option).
Easy interface to the Macintosh toolbox routines.
Three types of strings are supported: Pascal-formatted, C-formatted, and ﬁxed-
length.
8.4.1 Modules
Pass 1 creates three symbol tables: A global one—for symbols deﬁned outside
any code or data modules; a macro symbol table—for macro symbols and macrodeﬁnitions (this is the MDT); and a local symbol table—for symbols deﬁned insidecode or data modules.
The program is divided into modules that are assembled separately and ap-
pended to the object ﬁle. Each module is a contiguous piece of instructions or dataand, ideally, should be small enough to ﬁt entirely in memory. Labels declared inthe module can either be local (to the module) or global. They can also be exportedto other object ﬁles (meaning they can be external) or imported from other objectﬁles. The words IMPORT ,EXPORT are directives.
Pass 1 translates a module, as it is being read, into postﬁx notation, and stores
this in memory, with its local symbol table. (If the postﬁx module is too big, partof it is written on a disk, but this increases the assembly time considerably.) Pass 2assembles the postﬁx from memory and appends the results to the object ﬁle. Thelocal symbol table is then erased.
The linker can read several object ﬁles, each with several modules. It groups all
the data modules together and all the code modules together. They end up beingloaded in memory as two separate units.
A module must start with one of the directives PROC,FUNC,MAINorRECORD .I t
must end with one of ENDP,ENDF,ENDMorENDR.
Local labels are called @-labels. They must start with an ‘@’.
8.4.2 Listing ﬁle
A listing ﬁle can be created and, if the user selects this option, the assembler
uses a temporary ﬁle, the scratch ﬁle, to help create the listing.
During assembly, warnings and error messages appear in an active window,
called the diagnostic output window. Optionally, a progress report can also bedisplayed. The diagnostic output window can later be saved to a ﬁle if necessary.
Source ﬁles have a suﬃx of .a, object ﬁles, a suﬃx of .o, and listing ﬁles, a
suﬃx of.lst.
246 A Survey of SomeModern Assemblers Ch. 8
8.4.3 Segments
There is also the concept of segments. They are diﬀerent from segments on the
80x86 microprocessors. A 680x0 program can be divided into segments that sharethe same memory area. This way a large program, exceeding the entire memoryavailable, can run one segment at a time. The SEGdirective is used to deﬁne
segments.
Source line format. A label must either start at position 1, or be terminated
with a ‘:’. A statement without a label must start at position 2 or later. Comments
are preceded by a ‘ ;’. Fields are separated by a space or tab. Many mnemonics
must specify the data type of the operands. Valid types are:Speciﬁer
Type Size
B Byte 8 bits
W Word 16 bitsL Long word 32 bitsS Short 8-bit signed offset (in the range of
−128...+ 127)
D Double long word 64 bits. For use with 68851 onlyS Single precision 32-bit IEEE floating-point format. For 68881 onlyD Double precision 64-bit as aboveX Extended 96-bit as aboveP Packed BCD 96-bit packed characters for f.p. strings.
For 68881 only
Table 8–2. 680x0 Data Types
8.4.4 Expressions & literals
Expressions are permitted and may be absolute or relative. Many operators
are valid and operator precedence is used. Parentheses may be nested to a depthof 20.
Literals. Two important 680x0 instructions, PEAandLEAdo not operate in
the immediate mode. Since these instructions are used for passing parameters toprocedures, it is desirable to use them in this mode. For this reason the MPWassembler allows literals to be used with these instruction. The user simply says‘PEA #5.W ’ and the assembler prepares the literal 5 (as a word) in a literal pool,
and assembles the instruction with the address of the 5 as the operand. Literals aredescribed in Ch. 1.
8.4.5 Directives
As usual, we mention a few interesting directives.
TheEXPORT directive declares a label as global (external) in all the object ﬁles
loaded. The IMPORT directive declares a label as an entry point to all object ﬁles in
a load. The ENTRY directive is more limited. It declares a label as an entry point
to all the modules of the same object ﬁle.
Sec.8.4 The MacintoshMPWAssembler 247
TheMACHINE directive must come with one of the following operands: MC68000 ,
MC68010 ,MC68020 ,MC68030 . It identiﬁes the speciﬁc 680x0 microprocessor used to
the assembler.
TheSTRING directive should have one of the operands ASIS,PASCAL ,C. It tells
the assembler how to prepare character strings.
TheBRANCH &FORWARD directives tell the assembler what size to reserve for the
displacements of certain instructions if they refer to a future symbol. The BRANCH
directive relates to branch instructions. Its operand can be one of S, B, W, L . The
FORWARD directive relates to instructions in modes 6 and 7. Its operand can be one
ofW,L.
There is an OPTdirective to tell the assembler what level of optimization is de-
sired. The operand is one of ALL, NONE, NOCLR . An example of optimization is
the ‘SUBA An,An ’ instruction. It clears register An, but a ‘MOV #0,An ’ instruction is
faster. The assembler substitutes it if optimization is required. On certain modelsof 680x0, the ‘ CLR An ’ is even better but, on other models, it does not produce
identical results. The NOCLR parameter means to optimize but not to substitute
CLR ... for ‘MOV #0,... ’
Then he surveyed us in a lordly way ...
—Alan Harrington The Revelations of Dr. Modesto, 1955
References
1. Barron, D. W., Assemblers and Loaders ,3rded., New York, N.Y.: American
Elsevier 1968.
2. Kent, W., Assembler Language Macroprogramming , ACM Computing Surveys
1,4(Dec. 1969) 183–196.
3. Presser, L., and J. R. White, Linkers and Loaders , ACM Computing Surveys
4,3(Sep. 1972) 149–167.
4. Wilkes, M. V., D. J. Wheeler, and S. Gill, The Preparation of Programs for an
Electronic Digital Computer . Reading, MA.: Addison-Wesley, 1951.
5. Z80ASM Ver. 1.05 from SLR Systems, Butler, PA. 1984.6. ASMZ80 Ver 3.6C from Relational Memory Systems, San Jose, CA. 1984.7. MOPI Ver.2.0 from Voice Operated Computer Systems, Minneapolis, Minn. 1984.8. Wilkes, M. V., The EDSAC , MTAC 4,(1950) p. 61. Also reprinted in Randall,
B.,The Origins of Digital Computers , Springer Verlag, Berlin, 1982.
9. Melcher, W. P., SHARE Assembler UASAP 3-7 . SHARE distribution 564, 1958.
10. Goldﬁnger R., The IBM Type 705 Autocoder . Proc. East Joint Comp. Conf.,
San Francisco, 1956.
11. Knuth, D. E., Von Neumann’s First Computer Program , Computing Surveys
2,4(Dec. 1970) 247–260.
12.IBM 7040 & 7044 Data Processing Systems, Student Text . IBM Form No. C22-
6732.
250 References
13.Signetics 2650 Microprocessor Manual . Sunnyvale, CA.: Signetics Corp., 1977.
14. Grishman, Ralph, Assembly Language Programming for the Control Data 6000
and the Cyber 70 Series . New York, NY.: Algorithmics Press, 1974.
15. Langsam Y., M. J. Augenstein and A. M. Tenenbaum, Data Structures for
Personal Computers , Englewood Cliﬀs, NJ.: Prentice-Hall, 1985.
16. Morris, R., Scatter Storage Techniques , Comm. ACM 11,(1)p. 38, (Jan. 1968).
17. Hopgood, F. R. A., A solution to the Table Overﬂow Problem for Hash Tables ,
Comp. Bull. 11, p. 297 (1968).
18. Aho, A. V., J. E. Hopcroft and J. D. Ullman, Data Structures and Algorithms ,
Reading, Mass.: Addison-Wesley, 1983.
19. Brown, P. J., A Survey of Macro Processors , Ann. Rev. in Aut. Prog. Vol. 6.
Oxford & New York, NY.: Pergamon Press, 1966, pp. 37–88.
20. Campbell-Kelly, M., An Introduction to Macros , New York, NY.: American
Elsevier, 1973.
21. Cole, A. J., Macro Processors , Cambridge: Cambridge University Press, 1976.
22. McIlroy, M. D., Macro Instruction Extensions of Compiler Languages ,i n
Comm. ACM 3,(4), p. 214 (1960).
23. Graham, M. L., P. Z. Ingerman, An Assembly Language for Reprogramming ,
Comm. ACM 8,(12) p. 769, (1965).
24. Ferguson, D. E., The Evolution of the Meta-Assembly Program , Comm. ACM
9, p. 190 (1966).
25. Freeman, D.N., Macro Language Design for System/360 , IBM Sys. J. 5, (1966)6–
77.
26.IBM System/360 Operating System Assembler Language , IBM Form No. GC28-
6514.
27.IBM System/360 OS/VS and DOS/VS Assembler Language , IBM Form No.
GC33-4010.
28. Wegner, P., Programming Languages, Information Structures, and Machine Or-
ganization . New York, NY.: McGraw-Hill 1968.
29. Patterson, D. E., Reduced Instruction Set Computers , Comm. ACM 28(1)8–20,
Jan. 1985.
30.CDC COMPASS Version 3 Reference Manual , #60492600.
31.SUN Microsystems Assembler Language Reference Manual , part #800-1179.
32.PDP-11 Macro-11 Language Reference Manual , Order #AA-5075B-TC.
33. Gorsline, G. W., 16-Bit Modern Microcomputers , Englewood Cliﬀs, NJ.:
Prentice-Hall 1985.
34.An Introduction to ASM 86 , Intel Corp., Order #121689, 1981.
35.ASM 86 Language Reference Manual , Intel Corp., Order #121703.
36. Knuth, D. E., The T EXBook, Reading , Reading, MA.: Addison-Wesley, 1984.
37.IBM PC Macro Assembler , IBM #6172234.
References 251
38. Rector, R., G. Alexy, The 8086 Book , Berkeley, CA.: Osborne/McGraw-Hill,
1980.
39.NOVA Computer Assembler Manual , Data General Corp. #093-000017.
40.Apple II Reference Manual , Apple Corp. Product #A2L0001A.
41. Donovan, J. and S. Madnick, Operating Systems , New York, NY.: McGraw-Hill,
1974.
42.The Random House Dictionary of the English Language , New York, NY.: Ran-
dom House, 1970.
43. Ralston, A. (ed.), Encyclopedia of Computer Science & Engineering , Van Nos-
trand, 1985.
44. Barron, D. W., Assemblers , ibid, pp. 124–132.
45. Brown P. J., Macroinstructions , ibid pp. 904–906.
46. Barron, D. W., Loaders , ibid pp. 874–876. Linkage Editors , pp. 851–852.
47. Conway, M. E., UNISAP, Symbolic Assembly Program for UNIVAC I and UNI-
VAC II , The Computer Center,Case Institute of Technology, Cleveland, 1958.
48. Skordalakis, E., Meta-Assemblers , IEEE Micro, 3(2)6–16 (April 1983).
49.CDC 3170/3300/3500 Computer Systems, META/MASTERR eference Manual ,
Pub. No. 60236400, Control Data Corp 1968.
50. Yackle, B. E., An Assembler For All Microprocessors , Hewlett-Packard J.,
Oct. 1980, pp. 28–30.
51. Heath, J. R. and S. M. Patel, How To Write a Universal Cross-Assembler , IEEE
Micro, 1(3)45–66 (Aug. 1981).
52. Mezzalana, M., et. al., DEFASM: A Microprogram Meta-Assembler With Se-
mantic Capability , IEEE Proc. 128E(4)133–142 (1981).
53. Habib, S., and X. L. Yang, The Use of a Meta-Assembler to Design an M-code
Inrterpreter on AMD2900 chips , ACM SigMicro Newsletter, 12(4)38–50, 1981.
54. Gill, C. F., and M. T. Holden, On the Evolution of an Adaptive Support System ,
AIAA/ NASA/ IEEE/ ACM Comp. in Aerospace Conf., Los Angeles, 1977 (AIAAPaper No. 77-1420).
55. Holden, M. T., The B-1 Support Software System for Development and Mainte-
nance of Operational Flight Software , Proc. NAECON 76 Conf., 1976, pp. 250–262.
56. Boehm, E. M., and T. B. Steel, The SHARE 709 System, Machine Implemen-
tation and Symbolic Programming ,J .A C M 6,2,134–140 (Apr. 1959).
57. Norton, Peter & John Socha, Peter Norton’s Assembly Language Book for the
IBM PC , New York, NY.: Brady, 1986.
58. Mealy, G. H., A Generalized Assembly System , in Rosen S., Programming Sys-
tems and Languages , New York, NY.: McGraw-Hill, 1969, pp. 535–559.
59. McCarthy, J. et. al., The Linking Segment Subprogram Language and Linking
Loader , ibid pp. 572–581.
252 References
60. Greenwald, I. D., Handling of Macro Instructions , Comm. ACM 2,11,21–
23(1959).
61. Wirth, N., PL360, A Programming Language for the 360 Computers, J. ACM
15,(1),37–75(Jan. 1968).
62. Barnett, M., Macro Directive Approach to High-Speed Computing , Solid State
Physics Research Group, MIT, Cambridge, Mass.: 1959.
63. Bell, D. A., and B. A. Wichmann, An Algol-Like Assembly Language for a Small
Computer , Soft. Prac. & Exp. 1(1)61–73(1971).
64. Calingaert, P., Program Translation Fundamentals , Rockville, MD.: Computer
Science Press, 1987.
65.IBM 7090 Data Processing System, Reference Manual , IBM Form No. A22-6528.
66. Saxon, J. A., Programming the IBM7090 , Englewood Cliﬀs, NJ.: Prentice-Hall,
1963.
67. Wagner, R., Assembly Lines , N. Hollywood, CA.: Softalk Publ., 1982.
68. Kane, G., 68000 Microprocessor Handbook , Berkeley, CA.: Osborne/McGraw-
Hill, 1981.
69.Introduction to the 80386 . Intel Corp. Order No. 231252-001.
70. Leventhal, L. A., 6502 Assembly Language Programming , Berkeley, CA.:
Osborne/McGraw- Hill, 1979.
71.Introduction to Programming, PDP-8 . Maynard, Mass.: Digital Equipment
Corp. 1968.
72.How to use the Nova Computers , Southboro, Mass.: Data General Corp. 1970.
73. Eckhouse, R. H., Minicomputer Systems: Organization and Programming (PDP-
11), Englewood cliﬀs, Prentice-Hall, 1975.
74.Intel 8080 Microcomputer Systems User’s Manual , Santa Clara, CA.: Intel Corp.
Order No. 98-153C, 1975.
75.M6800 Microprocessor Programming Manual , Phoenix, AZ.: Motorola, 1975.
76. Barden, W., The Z-80 Microcomputer Handbook , Indianapolis, IN.: Howard
Sams, 1978.
77. Pressman, M. H., Assembly Language Programming for the VAX-11 , Mayﬁeld
Publ. 1985.
78. Struble, G., Assembler Language Programming , Reading, MA.: Addison-Wesley,
1975.
79.A Pocket Guide to the HP2100 Computer , Cupertino, CA.: Hewlett-Packard,
Publ. #5951-4423, 1972. pp.2–12.
80. Donovan, J., Systems Programming , New Yor,k NY.: McGraw-Hill, 1972.
81. Revesz, G., A Note on Macro Generation , Soft. Pract. & Exp. 15(5),423–
426(May 1985).
82. Beck, L. L., System Software , Reading, Mass.: Addison-Wesley, 1985.
References 253
83. Pratt, T. W., Programming Languages, Design & Implementation , Englewood
Cliﬀs, NJ.: Prentice-Hall, 1975. p. 36.
84. Knuth, D. E., The Art of Computer Programming, vol. I , Reading, Mass.:
Addison-Wesley, 1973.
85.NCRCentury NEAT/3 R ef. Manual , Dayton, OH.: NCR Corp., Binder #0210,
1968.
86.NCRCentury NEAT/3 Programming Text , Dayton, OH.: NCR Corp., Binder
#0274, 1968.
87.User Software Handbook, BABBAGE for OS4000 , GE Computers Corp., Bore-
hamwood, GB, issue 2, Manual Ref. DD1387, Jan. 1982.
88.650 Magnetic Drum Data Processing Machine, Manual of Operation , IBM Form
No. 22-6060.
89. Lamb, V. S., All About Cross-Assemblers , Datamation, 19(7),July 1973, pp.
77–79.
90. Feingold, C., Fundamentals of COBOL Programming , Dubuque, IA.: Wm. C.
Brown, 1969.
91. Coulouris, G. F., A Machine Independent Assembly Language for Systems Pro-
grams , Annual Review in Automatic Programming, 6, 1969, 99–104.
92. Dellert, G. T., A Use of Macros in Translation of Symbolic Assembly Language
of One Computer to Another , Comm. ACM 8(12)742-748(Dec. 1965).
93. Organick, E. I., and J. A. Hinds, Interpreting Machines: Architecture and Pro-
gramming of the B1700/1800 Series , Elsevier, North-Holland, 1978.
94. Huﬀman, D., A Method for the Construction of Minimum Redundance Codes ,
Proc. IRE 40, 1952.
95. Fitz, R. M., and L. C. Crockett, Universal Assembly Language , Blue Ridge
Summit, PA.: TAB Books, 1986.
96. BYTE magazine, Feb. 1989 issue, p. 104.97. Lavington, S., Early British Computers , Bedford, MA.: Digital Press, 1980.
98. Laurie, E. J., Computers and How They Work , South-Western Pub., 1963.
99. Borland Turbo Assembler 2.0 User’s Guide and Reference Guide, Borland In-
ternational Inc, 1990.
100. VAX Macro & Instruction Set Reference Manual. Order #AA-Z700A-TE,
Digital Equipment Corp., Maynard, Mass. , 1984.
101. Flores Ivan Assemblers and BAL , Englewood Cliﬀs, NJ.: Prentice-Hall, 1971.
102.Microsoft Macro Assembler 5.1 Programmer’s Guide , Microsoft Corp., 1987.
103.MPW Assembler Reference Manual, ver. 1.0 , APDA #KMBMPA, 1987.
Reference number in brackets, each reference in a separate set of
brackets. Number of reference in boldface type.
—Ellen Swanson, Mathematics into Type (1979)
A. Addressing Modes
A.1 Introduction
One of the main tasks in designing a new computer is to design its instruction
set. Machine language is often called low level which means, among other things,
that every hardware feature should have a machine instruction to control or to useit. The instruction set of a computer thus reﬂects its architecture. This fact has longbeen recognized and even serves as the basis for deﬁning the concept of computerarchitecture [29]. Designing the instruction set of a new computer is, therefore, animportant task involving many considerations. One important design criterion isthat instructions should be short. This is important because instructions have tobe fetched from memory before they can be executed. A long instruction may haveto be stored in two or even three words in memory, and thus takes two or threetimes longer to fetch than a short instruction.
The size of an instruction is determined by the size of the individual ﬁelds that
make up the instruction. Of those ﬁelds, the operand ﬁeld is by far the largest. To
get an idea of the sizes involved, let’s look at typical ﬁelds in a simple machine in-struction. The OpCode is typically 7–8 bits long, allowing for 128–256 instructions.In modern computers, the OpCode has variable size, averaging 6–8 bits. A register
ﬁeld is typically 3–6 bits long, reﬂecting the fact that most computers have between8 and 64 registers. (Some computers have more registers, but an instruction onsuch a computer can only access a register from a certain group.) In contrast to
Sec.A.1 Introduction 255
those short ﬁelds, the ‘operand’ ﬁeld should contain an address and thus could be
quite long.
/
Exercise A.1 How can one minimize the size of the OpCode ﬁeld?
Up until the mid 1970s, memories were expensive, and computers supported
small memories. A typical size memory in a second generation computer was 16 k–
32kwords, and in an early third generation one, 32 k–64kwords. Today, however,
with much lower hardware prices, modern computers can access much larger memo-ries. Most of the early microprocessors could address 64 kwords and most of todays
microprocessors can address between 1 Mand 32 Mwords (normally 8- or 16-bit
words). As a result, those computers must handle long addresses. Since 1 M(1
mega) is deﬁned as 1024 k= 1024 ×2
10=220, an address in a 1M memory is 20 bits
long. In a 32 Mmemory, an address is 25 bits long, since 32 M=25×220=225.
The 68000 microprocessor [68] generates 24-bit addresses. The 80386 microproces-sor [69] generates 32-bit addresses, and can thus physically address 4 giga bytes (itsvirtual address space is 64 tera bytes, = 2
46). Computers that are on the drawing
boards right now could require much longer addresses.
Let’s therefore assume a range of 20–24 bits for a typical address size, which
results in the following representative instruction formats:
OpCode Reg Operand OpCode Reg1 Reg2 Operand
6-8 3-6 20-24 6-8 3-6 3-6 20-24
The operand ﬁeld takes up about 60–70% of the total instruction size, and is thus
the main contributor to long instructions. A good instruction design should resultin much shorter operands, and this is achieved by the use of addressing modes .
/An addressing mode is a function, or a rule of calculation, used to calculate the
address. In an instruction set that uses addressing modes, an instruction normallydoes not contain the full address (which we will call the eﬀective address or EA),
but rather a short number, called a displacement or anoﬀset, and the mode. The
mode ﬁeld is 3–4 bits long, and the result is the following typical format:
OpCode Reg Mode Displacement
6-8 3-6 3-4 8-10
The operand (the mode and displacement ﬁelds) is now 11–14 bits long. It is still
the largest ﬁeld in the instruction, making up 50–55% of the instruction size, butis considerably shorter. Many instructions do not need an address operand and,therefore, do not use a mode either. Adding a mode ﬁeld, therefore, does notincrease the size of those instructions.
There is, of course, a trade oﬀ. If an instruction uses a mode, the EA has
to be calculated before the instruction can be executed, which takes time. Thiscalculation is done by the hardware, though, so it is fast.
Since the mode is a function, it is possible to write: EA = f
m(displacement ,...)
which implies that the EA is calculated by applying a function fto the displacement
256 AddressingModes Append.A
(and to other arguments), and that the function itself depends on the mode m.S o
for diﬀerent modes we have diﬀerent functions, diﬀerent ways of calculating theEA. We will see that those functions depend on things like the PC, index registers,and the contents of memory locations. The notation EA = f
m(displacement ,...)
therefore illustrates the nature of addressing modes.
Before looking at speciﬁc modes, it is important to mention the second property
of addressing modes. They serve to make the machine instructions more powerful.We will see examples where a single instruction, using a powerful mode, can do thework of several instructions.
A.2 Examples of Modes
We will start by describing the main addressing modes, and follow by a brief
discussion of less important ones.
/The ﬁve main addressing modes, found on all modern computers and many old
ones, are: direct, relative, immediate, index, and indirect.
A.2.1 The Direct mode
When an instruction uses a small address, an address that ﬁts in the displace-
ment ﬁeld, there is no need for any calculations and the EA is simply the displace-ment. This is the direct mode . It is a simple mode and, in the form described here,
used only by absolute assemblers. A typical example is:
LC
Obj. Code
0.
.
19A. .
.. Opc m dis
xxMUL A xxx 0 19
Since the value of Ais a small number, the assembler uses the direct mode
for theMULinstruction. It should again be emphasized that the assembler does not
need to know what the MULinstruction is, how it works, or even the precise meaning
of the direct mode. It follows a simple rule that says: if the value of the symbol is <
the maximum value of the displacement ﬁeld, put the symbol in the displacementﬁeld and set the mode ﬁeld to 0 (or whatever the code for direct mode is). This,however, implies that the instruction cannot be relocated by the loader. Assumingthat the loader decides to load the program starting at address 1000, it would wantto relocate the displacement ﬁeld to 1019, which may be too large. This mode isthus not useful in a relocatable assembler but, as we will see later, certain versionsof it are.
/
Exercise A.2 What ifAis a future symbol. Does that generate a problem for the
assembler?
Sec.A.2 Examplesof Modes 257
A.2.2 The Relative mode
Here, the displacement ﬁeld is called oﬀset, and is set to the distance between
the instruction and its operand. This is a useful mode that is sometimes automati-cally selected by the assembler, and not explicitly speciﬁed by the programmer. Italso results in an instruction that does not need relocation.
Using the concept of a function mentioned earlier, we can write the deﬁnition
of this mode as EA=oﬀset+PC. This means that, at run time, before the instruc-tion can be executed, the hardware has to add the oﬀset and the PC to obtain theeﬀective address. The hardware can easily do that, but how does the assemblerﬁgure out the oﬀset in the ﬁrst place? The expression above can be written as‘disp=EA-PC’ and, since the PC always points to the next instruction,‘disp=EA-(LC+size of current instr.)=EA-LC-size of current instr.’In the second pass, the LC contains the address of the current instruction, so‘LC+size’ equals the address of the next one. Since the EA is simply the valueof the symbol used by the instruction, the assembler can calculate the oﬀset and, ifit ﬁts in the displacement ﬁeld, store it there and use the relative mode. Example:
LC
Obj. Code
0.
.
19A- -
.. Opc m dis
57JMP A xxx 1 -39 =19-57-1
Note that the oﬀset is negative. A little thinking shows that this is always the case
if the operand precedes the instruction. Thus, in this mode, the oﬀset is a signed
number. Since the sign uses one of the oﬀset bits, the maximum value of a signedoﬀset is only half that of an unsigned one. An unsigned 8-bit oﬀset, for instance,has the range 0 ...255, and a signed one, the range −128...+ 127. The ranges are
the same size, but the maximum values aren’t.
The example above also shows the absolute aspect of this mode. The oﬀset is
essentially the distance between the operand and the instruction, and this distancedoes not depend on the start address of the program. We say that this modegenerates position independent code , and an instruction using it should always have
a relocation bit of 0.
A.2.3 The Immediate mode
This mode is used when the instruction needs the value of a constant, not
the contents of a memory location. An ADDinstruction is sometimes written as
‘ADD R3,XY ’ and adds the contents of location XYto register 3. If, however, the
programmer wants to add 67 to register 3, the same instruction can be used in theimmediate mode by saying ‘ ADD R3,#67 ’. The number sign ‘#’ is normally used
to indicate the immediate mode. Assuming that the code of this mode is 2, the
258 AddressingModes Append.A
instruction above would be assembled something like this:
Opc reg m disp
xxx 3 2 67
The immediate quantity (the number to be used by the instruction) should be small
enough to ﬁt in the displacement ﬁeld. This mode always generates an absoluteinstruction and is diﬀerent from all the other modes because it does not use anyEA. We say that, in this mode, the operand is in the instruction.
It has been mentioned in chapter 1 that this mode is rarely found in old com-
puters. Assemblers on those computers had to compensate for the lack of this modeby supporting literals . Today, however, literals are less useful since all new com-
puters support the immediate mode. In fact, some modern computers (notablythe VAX[DEC!VAX] and 68000) have several versions of this mode, for diﬀerentmaximum sizes of the immediate operand.
A.2.4 The Index mode
This mode has been developed to simplify loops. It uses the concept of an index
register which, on some computers, is a special register, but normally can be any
general purpose register. The EA function in this mode is: EA=disp+Index. Thesource instruction has to specify this mode explicitly, for example: ‘ LOD R1,0(R5) ’.
The displacement is 0 and R5is used as the index register. Before the loop starts,
R5should be set to some value, most likely the beginning address of the array.
Each time through the loop, R5should be incremented, to point to the next array
element. The entire loop may look similar to:
LOD R5,M Load the start address of the array
LUP LOD R1,0(R5) Load the next array element into R1
..INC R5 Update the index register
CMP R5,#LEN Compare with the array size ( LENis an absolute symbol)
BLTLUP Branch on Less Than
..
LEN EQU 25 LEN is the array size
ARY DS LEN ARY is the array itself
M DC ARY Location Mcontains the value of symbol ARY
/
Exercise A.3 What instruction can be used instead of LOD R5,M above, to load
the value of ARY.
This mode can also be used a little diﬀerently, as in ‘ LOD R1,ARY(R5) ’ where
ARYis the start address of the array and R5is initialized to 0. In this case, the index
register really contains the index of the current array element used. This form canbe used if the value of ARYﬁts in the displacement ﬁeld.
On the Intel 8086, certain instructions can use two index registers. Thus
‘mov ah,ary[bx][di] ’ is valid.
Sec.A.2 Examplesof Modes 259
A.2.5 The Indirect mode
This is a more complex mode, requiring the hardware to work harder in order
to calculate the EA. The rule of calculation is: EA=Mem(disp.) meaning, thehardware should fetch the contents of the memory location whose address is ‘disp.’,and that contents is the EA. Obviously this mode is slower than the former onessince it involves a memory read. The EA has to be read from memory beforeexecution can start. A simple example is:
LC
Obj. Code
. Opcmdisp
24 JMP @TO xxx 3 124
..
124 TO DC 11387
.
The EA is 11387 and could, in principle, be any address. Notice that the DC
directive itself generates the constant 11387 on the object ﬁle with a relocation bitof 0. However, A directive of the form ‘ TO: DC AB ’ would generate the value of AB
on the object ﬁle as a relocatable quantity (assuming, of course, that ABis a relative
symbol). The value of TOis called the indirect address and, in the simplest version
of the indirect mode, it has to be small enough to ﬁt in the displacement ﬁeld. Thisis one reason why several versions of this mode exist (see below).
What is this mode good for? As this is a discussion of assemblers, and not of
assembly language programming, a complete answer cannot be given here. We willjust show a typical use of this mode namely, a return from a procedure. When aprocedure is called, the return address has to be saved. Most computers save thereturn address in either the stack, in one of the registers, or in the ﬁrst word of theprocedure (in which case the ﬁrst executable instruction of the procedure shouldbe stored in the second word). If the latter method is used, a return from theprocedure is a jump to the memory location whose address is contained in the ﬁrstword of the proceudre. This is therefore a classical, simple example of the use ofthe indirect mode. If the procedure name is P, then an instruction such as ‘ JMP @P ’
(where ‘@’ speciﬁes the indirect mode) can easily accomplish the job.
Incidentally, if the return address is saved in the stack, a special instruction,
such asRET, is necessary to return from the procedure. Such an instruction should
jump to the memory location whose address is contained in the top of the stack, andalso remove that address from the stack. Thus a RETinstruction uses a combination
of the indirect and stack modes.
Other common extensions of the indirect mode combine it with either the
relative or the index modes. The JMPinstruction above could be assembled as
‘x x x39 9 ’ since the value of TOrelative to the JMPinstruction is 124 −24−1 = 99.
This discussion assumes that the size of the JMPinstruction is one word and that
mode 3 is the combination indirect-relative. A combination indirect-index can also
260 AddressingModes Append.A
be used and, in fact, the 6502 microprocessor uses two such combinations, a pre-
indexed indirect (that can only be used with index register X), and a post-indexed
one (that can only be used with index register Y). Their deﬁnitions are:
Pre-indexed indirect: EA=Mem(disp+X)Post-indexed indirect: EA=Mem(disp)+YIn the former version, the indexing (disp+ X) is done ﬁrst and the indirect
operation (the memory read), later. In the latter version, the indirect is done ﬁrstand the indexing (...+ Y), later. Leventhal [70] illustrates the use of those modes.
The two instructions ‘ LDA ($80,X) ’&‘LDA ($80),Y ’ are typical examples. The
‘$’ stands for hexadecimal and the parentheses ‘()’ imply the indirect mode. It isinteresting to note that, in order to keep the instructions short, there is no separatemode ﬁeld in the 6502, and the mode is implied in the OpCode. Thus an instructionmay have several OpCodes, one for each valid mode. The two instructions abovehave OpCodes of A1,B1respectively.
A.2.6 Multilevel or cascaded indirect
This is a rare version of the basic indirect mode. It is suitable for a computer
with, e.g., 16-bit words and 15-bit addresses (or N-bit words and N−1-bit ad-
dresses). The extra bit in such a word serves as a ﬂag. If it is 1, another level ofindirect is required. The original instruction contains an indirect address, and thehardware examines the contents of that address. If the ﬂag is 1, the hardware usesthe contents as another indirect address. This process continues until the hardwaregets to a memory location where the ﬂag is zero. The contents of that location isthe EA. The HP1000 and 2100 minicomputers [79] are good examples.
/
Exercise A.4 How can the programmer generate both an address and a ﬂag in a
memory word?
A.2.7 Other addressing modes
Computers use many other modes, some simpler and others, more powerful
than the basic modes described so far. We will mention a few other modes, nottrying to provide a complete list but merely to show the possibilities.
A.2.8 Zero Page mode
This is a diﬀerent name for the direct mode described earlier. If the displace-
ment ﬁeld is Nbits long, the (unsigned) displacement can have 2 Nvalues. Memory
may be divided into pages, each 2 Nwords long, and page zero—the ﬁrst memory
page—is special in the sense that any instruction accessing it may be assembled inthe direct mode. Hence the name zero page mode . Good examples are the 6502
microprocessor [70] and the PDP-8 minicomputer [71].
Sec.A.2 Examplesof Modes 261
A.2.9 Current Page Direct mode
The PDP-8 was a 12-bit minicomputer. It also has 12-bit addresses and thus
a4kword memory. The memory is divided into pages, each 128 words long. The
ﬁrst memory page, addresses 0–127, is called base page. Many instructions havethe format:
OpCode m disp
4 1 7 =12 bit long.
If m=0, the direct mode is used and EA=displacement. This is zero page adressing.
However, if m=1, the EA becomes the logical OR of the 5 most signiﬁcant bits ofthe PC and the 7 bits of the displacement, pppppddddddd . The displacement is thus
the address in the current page, and the mode is called current page direct mode .
A.2.10 Implicit or Implied mode
This is the simple case where the instruction has no operands, and is not
using any mode. Instructions such as HLTorTAY(transfer AtoY) are good exam-
ples. Those instructions do not use any modes but many times the manufacturers’literature refers to them as using the implicit orimplied mode.
A.2.11 Accumulator mode
Similar to the previous case. In a computer with a single working register,
theaccumulator , many instructions implicitly use the accumulator. They don’t
have a mode ﬁeld and should perhaps be considered as having no mode. Howeversome textbooks and manufacturers’ manuals refer to them as using the accumulator
mode.
A.2.12 Stack mode
In a computer with a stack, some instructions use the stack and should update
the stack pointer. Such instructions are said to use the stack mode , even though
they need not have a separate mode ﬁeld. The use of the stack is implied in theOpCode. Examples are POP&PUSH. The ﬁrst pops a data item from the stack
and then updates the stack pointer (say, by incrementing it); the second updatesthe stack pointer (by decrementing it) and then pushes the new data item into thestack.
A.2.13 Stack Relative mode
A combination of the relative and stack modes. In this mode, EA=disp.+SP
where SP is the stack pointer, a register that always points to the top of the stack.This mode allows access to any stack element, not just the one at the top.
/
Exercise A.5 A stack is a LIFO data structure, which implies using the top ele-
ment. What could be a reason for accessing a stack element other than the top?
262 AddressingModes Append.A
A.2.14 Register mode
The instruction speciﬁes a register that contains the operand. This mode does
not use an EA and there is no memory accesss.
A.2.15 Register Indirect mode
The register contains the EA. It is thus a pointer to the operand in memory.
A.2.16 Auto Increment/Decrement mode
This is a powerful version of the index mode. In addition to calculating the EA
by using the index register, the hardware increments or decrements the register.This is an example of another property of addressing modes, their power. ThePDP-11 instruction ‘ CLR (R5)+ ’ means: use R5as an index (it contains the EA,
which means it points to the operand in memory), execute the instruction (clearthe operand, a memory word) and, ﬁnally, increment the index register so that itpoints to the next word in memory. This is clearly a powerful mode since, withoutit, another instruction would be needed, to increment the register. Similarly, theinstruction ‘ INC -(R5) ’ starts by ﬁrst decrementing the index register, then using
it as an index, pointing to the memory word that is to be INCremented.
On the PDP-11, memory is physically divided into bytes and a memory word
is two consecutive bytes. The instructions above operate on a word and, therefore,the index is updated by 2, not by 1, so it points to the next (previous) word. In aninstruction such as CLRB(clear a byte) the register would be updated by 1. On the
VAX computer there are also longwords, quadwords, and octawords, complicatingthis mode even more.
On the Nova [39,72] memory locations 16–31 are special. Locations 16–23 are
auto increment and locations 24–31, auto decrement. When any of those locationsis speciﬁed by an indirect instruction, the computer ﬁrst increments (decrements)that location, then uses it to calculate the eﬀective address.
Figure A–1 is a graphic represenatation of 11 of the modes discussed here.
A.3 Base Registers
This is an important concept in addressing. It implements a mode that can
be called Base Relative Mode. A computer that supports this feature has a baseregister and special hardware to calculate the EA. The base register can be a specialregister or it can be any general purpose register. The IBM360, the most commonexample of the use of base addressing, uses the latter scheme (except that registerR0cannot be used as a base).
The base register is set to point to the start address of the program. Any
instruction addressing memory should thus contain a displacement which is theaddress of the operand relative to the start of the program. The example given
Instruction
registersIndirect
IndexedDirect Relative
ImmediatePCInstruction
Instruction
Instructiondispdisp
disp
dispOperand
memoryOperand
memory
Operand
memoryindirect 
address
Operand
memoryinstruction
Operand
memory+
+Sec.A.3 BaseRegisters 263
Figure A–1. CommonAddressin g Modes (part 1).
above for the relative mode will be used to illustrate base registers.
LC Obj. Code
0.
.
19 A ..
. Opcdis
57 JMP A xxx 19
TheJMPinstruction is assembled with a displacement of 19, which is the value of
symbolArelative to the start of the program. The loader loads the program starting
Instruction
Base RelativeRegister IndirectRegisterIndirect Pre-Indexed Indirect Post-Indexed
Stack Relativeindirect 
address
Operand
memoryInstruction
disp
+
registersindirect 
address
Operand
memoryregistersInstruction
disp
+
registersoperandregInstruction
registersaddressreg
Operand
memory
SPInstruction
disp
Operand
stack+top
Operand
memorybase
Instructiondisp+start of
program264 AddressingModes Append.A
Figure A–1. CommonAddressin g Modes (part 2).
at, say, address 1000. No relocation is necessary, and the JMPinstruction is loaded
in memory as xxx19 . The instruction labeled Ais loaded into location 1019. At run
time, the base register should contain 1000 and, every time an address is generatedby the program, the hardware calculates the EA by adding disp.+base. In our case,EA=19+1000=1019.
There is one problem associated with this feature, it is the case where the value
of a symbol is too large to ﬁt in the displacement ﬁeld . A simple example is shownin the table below.
A general solution is to switch to another base register, one containing an
address closer to the value of symbol A. The user can select, say, register 4, load it
Sec.A.3 BaseRegisters 265
LC Obj. Code
0.
. Opcdis
57 JMP A xxx 1234 too large!
.
1234 A --
with address 1200 and tell the assembler to assemble the JMPinstruction using R4
as the base register. The assembler would then generate a displacement of 34. Adirective is necessary for this purpose and, in the case of the IBM360, the directiveis called USING .T h u sUSING 1200,4 would do the job. Notice that the directive
cannot load the value 1200 in register 4.
/
Exercise A.6 Why not?
TheUSING directive is just a promise. It’s like promising the assembler “at run
time, register 4 will contain 1200”. The actual loading of R4must be done by an
instruction executed at run time. The user has, of course, to write that instructionin the program. Struble [78] is a good reference for 360 programming and for baseregisters.
A.4 General Remarks
The simple picture presented earlier in this chapter, of an instruction with a
short displacement ﬁeld, is not always correct. It is a good vehicle for illustratingaddressing modes but it has one drawback, an instruction with a displacement ﬁeldcannot be relocated. Relocating means adding the start address of the program, andthat address may be any address in memory. This means that, after the relocation,the instruction should be able to hold any memory address, and this is impossibleto do with a short displacement ﬁeld.
As a result, computer designers always look for new, ﬂexible ways to design
instruction sets where instructions are as short as possible and, at the same time,can be relocated. The base registers described above are one solution. They resultin short instructions that do not require relocation. Both the assembler and theloader are simpliﬁed—since they don’t have to handle relocation bits—but the priceis slower execution, since each address generated at run time has to be relocated bythe hardware.
Another common solution is to have the instruction size depend on the mode,
such that the same instruction can be short, if it is used in an absolute mode orlong, if it is used in a relative mode, where it should be relocated. This is the casein the PDP-11 computer [73] where an instruction is normally one word (16 bits)long but has a second word added if an operand uses one of the relative modes, andeven a third word, if both operands use such a mode.
Yet another solution is to use pages and/or segments. Those methods are
described in any text on operating systems [41] or systems programming [80].
266 AddressingModes Append.A
It is interesting to follow the historical development of addressing modes. The
IBM7090 [65,66] had 4 modes. The IBM360 [26,78], 5 years later, had the samenumber. The CDC6600 [14,30], a powerful, third generation computer, had just 5modes.
However, starting with the 8-bit microprocessors around 1975, we see an ex-
plosion of addressing modes, brought about because of the drop in hardware prices.The Intel 8080 microprocessor [74] has 8 modes. The Motorola 6800 microprocessor[75], 7 modes. The MOS Technology 6502 microprocessor [70], 11 modes. The ZilogZ-80 microprocessor [76], 10 modes. The Motorola 68000 microprocessor [68], 14modes, and the VAX-11 [77], 24 modes.
This shows that computer designers recognize the power behind addressing
modes and, given the chance, use them more and more in computers of all typesand sizes.
Sec.A.5 Review Questions 267
A.5Review Questions
1.Study the addressing modes of the PDP-11 and the VAX computers. This is an
excellent review of all the important modes.
2.What modes require the displacement to be signed?
3.If register 3 has been declared a base register (by ‘ USING 3 ’) how can the
programmer declare it later as a regular register?
4.Many computers support two unconditional jump instructions, a JMPand a
BRAnch. What could be the diﬀerence between them? (Hint: It has to do with
addressing modes.)
5.TheSKP(skip) instruction has no operands and therefore uses the implicit mode
mentioned above. What kind of an instruction is it? where does it skip to?
6.Review your knowledge of signed binary numbers and the two’s complement
method. Speciﬁcally, why can an 8-bit two’s complement number have a value of−128 but not of +128?
7.Regarding stacks, if the stack pointer points to the top of the stack, and it
should be updated to point to the next available location in the stack, should itbe incremented or decremented? Also, is it possible to use a stack where the stackpointer points to the next available location, instead of to the top?
Every mode of life has its conveniences.
—Samuel Johnson, The Idler (1758)
B. Hexadecimal
Numbers
Computers use binary numbers, not hexadecimal ones. Hexadecimal numbers
are used by authors for one reason; they are shorter than binary. Binary numbersuse just zeros and ones, and thus tend to be long. It turns out that hexadecimalnumbers are exactly one-fourth the size of binary numbers, and are therefore moremanageable and easier to read.
Hexadecimal numbers are based on the number 16. This means that, in the
numberdcba, the digit bhas a value of 16 b,chas a value of 16
2c&dhas a value
of 163d=4096d. Hexadecimal numbers require 16 diﬀerent digits (much as decimal
numbers require ten digits, and binary numbers, two). The 16 hexadecimal digitsare0-9,A,B,C,D,E,F , whereA(hex) = 10(dec) and F16 = 15
10. Other examples of
hex numbers are:
1016=1 6×1+0=16 10; 100 16=1 62×1+0+0=256 10;FF16=1 6×15+15 =
25510.
Since the hexadecimal digits have values between 0 and 15, each is equivalent
to exactly four bits. A four bit number can have values that range from 0000 = 0to 1111 = 15. This makes conversion between binary and hexadecimal numbersparticularly easy. To convert the binary number 0011111 to hex, one should:
Sec.B HexadecimalNumbers 269
Divide the bits into groups of four, going from right to left. For our example we
get 001 1111 (the leftmost group may be shorter than 4).
Convert each group into one hex digit. Our example becomes 1F.
Note that a few zeros may have to be added to the leftmost group. Conversion
in the opposite direction is as easy.
/
Exercise B.1 Convert 70 F16to binary.
The hex numbering system is popular because of the easy conversion and be-
cause most computers have a word length divisible by eight, implying that thecontents of a word can be written as an even number of hex digits.
270 HexadecimalNumbers Append.B
B.1 Review Questions
1.Conversion between hex and binary is easy because each hex digit is equivalent
to exactly 4 bits. Conversion between decimal and binary is not that easy, because adecimal digit is not exactly equivalent to 4 bits. Some 4-bit values are greater than9 and thus do not correspond to a decimal digit. Study and implement decimal–binary conversion.
2.The numbers 2, 10, 16 are the bases for the binary, decimal and hex numbering
systems. Can the number 3 be the base for a numbering system (ternary numbers)?What numbers can serve as a base for a numbering system?
<
hex digit >:==<digit>|A|B|...|F.
—BNF deﬁnition of hex digit
C. Answers to Exercises
I.1:Suppressing the listing ﬁle makes sense if a listing exists from a previous as-
sembly. Also, if a printer is not immediately available, the user may want to savethe listing ﬁle and to print it later.
1.1:In many higher-level languages a semicolon is used to indicate the end of a
statement, so it seems a good choice to indicate the end of an instruction. Also, wewill see that many other characters already have special meaning to the assembler.
1.2:The ‘F’ indicates a ﬂoating-point operation, so this is a ﬂoating-point add.
1.3:The number of registers should be of the form 2
k. This implies that a register
number is kbits long, and ﬁts in a k-bit ﬁeld in the instruction. A choice of
20 registers would mean a 5-bit register number—and thus a 5-bit ﬁeld in manyinstructions—but that ﬁeld would not be fully utilized since with 5 bits it is possibleto indicate 32 registers.
1.4:To indicate an index register and a base register. Appendix A contains more
information on indexing and base addressing.
1.5:An addressing mode should be used to assemble the instruction. Addressing
modes are discussed in appendix A.
1.6:The symbol is simply undeﬁned, an error situation discussed, among other
errors, at the end of chapter 1.
272 Answers to Exercises Append.C
1.7:Certain characters, such as ‘–’, ‘ ’ allow for a natural division of the name
into easy-to-read components. Other characters, such as ‘$’,‘=’ make labels moredescriptive. Examples: NO
OFFONTS is more readable than NoOfFonts .REG=DATA
is more descriptive than RegEqData .
1.8:
a.type
address=0..4096; an address in a 4k memory
node=record
info: address;next: ^nodeend;
list=^node; the type ‘list’ is a pointer to the beginning of such a list
b.const
lim=500; max =1000; some suitable constants
type
list=o..lim; type ‘list’ is the index of the ﬁrst list element in array house
var
house: array [1..lim] of 0..max; lists of pointers are housed here
house2: array [1..lim] of 0..lim; pointers pointing to
the next element inside each list, are housed here.
1.9:Using logical operations and, perhaps, shifts to mask the rest of the instruction.
1.10: Using either the POSor the ‘DS 0’ directives. Both are described in chapter
3.
1.11: A branch instruction. Any instruction following a branch must be forced into
position 0 of the next word, even if it is not labeled. The reason is that the onlyway to execute such an instruction is to branch to it, and to make it possible tobranch to it, it must be located in position 0.
1.12: Yes, it is valid, its value is −11 and its type, absolute. It simply represents
a negative distance.
1.13: External symbols are described in chapter 3, and the way they are handled,
by the loader, in chapter 7. In the above example, the assembler calculates as muchof the expression as it can ( A-B) and generates two modify loader directives (see
chapter 7), one to add the value of Kand the other, to subtract L, both executed at
load time.
1.14: Address 24, because of the phrasing above ...with the name ‘1’ and a value
≥17...
1.15: ‘JMP * ’ means jump to the current instruction. Such an instruction jumps
to itself and thus causes an inﬁnite loop. In the early microprocessors, this was a
Append.C Answers to Exercises 273
common way to end the program, since many of those microprocessors did not have
aHLTinstruction.
‘JMP *-* ’ means jump to location 0. However, since the LC symbol ‘*’ is relative,
the expression *-*isrel−reland is therefore absolute. The instruction would
jump to location 0 absolute, not to the ﬁrst location in the program.
Note. Knuth [84] mentions another reason for those instructions. See exercise 2
in his section 1.3.2.
1.16: Because the USEis supposed to have the name, not the value, of a LC, in its
operand ﬁeld.
1.17: Yes. The only problem is that the loader needs to be told where to start
the execution of the entire program. This, however, is speciﬁed in the ENDdirective
(see chapter 3) and is a standard feature, used even where no multiple LCs aresupported.
1.18: It is identical to :
JMP TMP
..
TMP DC *
The computer will branch to the location labeled TMPbut that location contains an
address, not an instruction. The likely result will be an interrupt (invalid OpCode).
1.19:
Object Code
LC
Label Source OpCode Op
0 INP 00000111
1 STO 50 00000010 00110010
3 INP 00000111
4 STO 51 00000010 00110011
6 BZE X 00000100 00001101
8 ADD 50 00000011 00110010
10 OUT 00001000
11 BRA Y 00000110 00010001
13 X LOD 50 00000001 00110010
15 ADD 50 00000011 00110010
17 Y STO 52 00000010 00110100
19 HLT 00000000
1.20: Add either addressing modes or more registers. With 4 unused bits we can
have 2 bits specify one of 4 addressing modes, and the other 2 bits, one of 4 general-purpose registers. Alternatively, we can use 3 bits to specify 8 modes, and the fourthbit (if one is available) to select one of two index registers. These are special purposeregisters, used to hold an address, not an operand. The arithmetic operations wouldstill be performed in the Acc.
274 Answers to Exercises Append.C
1.21: Invalid mnemonic, invalid label (not a single letter), multiply-deﬁned la-
bel, and invalid operand (syntactically wrong, such as ‘ STO : ’, undeﬁned symbol,
operand greater than maximum address).
1.22: It makes it easier for the assembler to distinguish a symbol from a constant
in the operand ﬁeld. In an instruction such as ‘ ADD R1,1A ’, the assembler has to
scan the entire name of the symbol 1Ato verify that it is a symbol. The restriction
to a letter allows the assembler to scan an instruction such as ‘ ADD R1,A1 ’ and,
immediately after scanning the ﬁrst character of the symbol name, decide that theinstruction uses a symbol. This simpliﬁes the lexical analysis phase of the assembler.
1.23: There is no point in writing 5000 unnecessary records on the object ﬁle. The
assembler places a special code (a loader directiveloader directives) in the objectﬁle, instructing the loader to reserve as many locations as necessary.
1.24: In the relative mode, the Op ﬁeld is essentially the distance between the
instruction and its operand. If that distance does not ﬁt in six bits, the relativemode cannot be used. In other words, this mode can only be used if the instructionis not too far away from its operand. See appendix A for more details.
2.1:It depends on the characters allowed. The ASCII codes of the characters ‘ <’,
‘=’, ‘>’, ‘?’, ‘@’ immediately precede the code of ‘A’. Similarly, the codes of ‘[’, ‘ \’,
‘]’ immediately follow ‘Z’ in the ASCII sequence. If those codes are used, then it isstill easy to use buckets. Given the ﬁrst character of a symbol name, we only needto subtract from it the ASCII code of the ﬁrst of the allowed characters, say ‘ <’, to
get the bucket number. If other characters are allowed, then buckets may not be agood data structure for the symbol table.
3.1:It adds more work to the programmer and doesn’t speed up the identiﬁcation
by much. Even if the assembler identiﬁes a source line as a directive by the period, itstill needs to search some table to ﬁnd the start address of the routine that executesit.
3.2:The relations e≤b,c>e,0<b ,e ,c ≤80 should hold.
3.3:To generate a backup ﬁle of the source on punched cards.
3.4:See chapter 7.
3.5:In both passes. It is executed by selecting one of four built-in conversion
routines. That routine is used until the next BASEis found.
3.6:a. Place a JMPorSKIPinstruction to skip over the data.
b. Use another LC to eventually relocate the data block elsewhere.
c. Fill up the data area with instructions at run time.
3.7:a. To make BSSandBESreally diﬀerent. Compare this diﬀerence to the
diﬀerence between the auto-increment and the auto-decrement modes discussed inappendix A.
Append.C Answers to Exercises 275
b. TheBESdirective was useful on old computers with subtractive index registers
where most loops went backwards.
3.8:To produce a forcing upper of the next source line. This is common on com-
puters with a large word size, such as the CDC Cyber and the Cray computers.The concept of forcing upper is discussed in chapter 1. Also, the IBM 360 useshalfwords, fullwords, and doublewords in memory. The directive ‘ DS 0D ’ (reserve 0
double words) on those computers is used to force the LC to the start of the nextdoubleword.
3.9:The most common use for ORGis to specify a start address for the program
in a computer without an operating system. On such a machine, the user mayselect a start address and may want to load diﬀerent programs starting at diﬀerentaddresses. In such a case, the ﬁrst source line is an ORGand is the only ORGin the
program.
3.10: The reason is that instructions are assembled in pass 2, where all the symbols
are already in the symbol table; certain directives, however, are executed in pass 1,where future symbols have not been found yet. Thus pass 1 directives cannot usefuture symbols.
3.11: The simplest way is to add another pass. The directive ‘ A EQU B+1 ’ can be
handled in three passes. In the ﬁrst pass, label Acannot be deﬁned, since label B
is not yet in the symbol table. However, later in the same pass, Bis found and is
stored in the symbol table. In the second pass label Acan be deﬁned and, in the
third pass, the program can be assembled. This, of course, is not a general solution,since it is possible to nest future symbols very deep. Imagine something like:
A EQU B
-
B EQU C
-
C EQU D
--
D-
Such a program requires four passes just to collect all the symbol deﬁnitions, fol-
lowed by another pass to assemble instructions. Generally one could design a per-
colative assembler that would perform as many passes as necessary, until no more
future symbols remain. This may be a nice theoretical concept but its practicalvalue is nil. Cases such as ‘ A EQU B ’, whereBis a future symbol, are not important
and can be considered invalid.
3.12: It is executed in pass 1 since it aﬀects the symbol table. It is executed by
evaluating and comparing the expressions in the operand ﬁeld. This is anotherexample of a powerful directive.
276 Answers to Exercises Append.C
3.13: Themodify loader directive, discussed in chapter 7, can be generated by the
assembler to instruct the loader to modify any item loaded, in any way, instead ofjust storing in it the value of an external symbol.
3.14: Because the BSSZ generates Data. The BSS(orDS) directive only reserves
storage, so it is one of the Block Control directives.
4.1:Either make the label a parameter, use local labels (see chapter 1), or use
automatic label generation (see Ch. 4).
4.2:Generally not. In the above example it makes no sense for the assembler to
substitute XforBsince it does not know if this is what the programmer wants. How-
ever, there are two cases where double substitution (or even multiple substitution)makes sense. The ﬁrst is where an argument is the name of a macro. The secondis the case of an assembler where parameters are identiﬁed syntactically, with an‘&’ or some other character. The ﬁrst case is called nested macro expansion and isdiscussed later in this chapter. The second case occurs in the IBM360 where param-eters must start with an ‘&’ and are therefore easy to identify. The 360 assemblerperforms multiple substitution until no ‘&’ are left in the source line.
4.3:It depends on the MDTorganization and on the size of the data structures
used for binding. Typically, the maximum number of parameters ranges between afew tens and a few hundreds.
4.4:If the last argument is null, it should be preceded by a comma. A missing last
comma indicates a missing argument.
4.5:Add another pass (pass −1?) to collect all macro deﬁnitions and store them
in the MDT. Pass 0 would now be concerned only with macro expansions.
4.6:Nested macro deﬁnition. In such a case, each expansion of certain macros
causes another macro deﬁnition to be stored in the MDT, and space in the MDTmay be exhausted very rapidly.
4.7:All three parameters are bound to the same argument and are therefore sub-
stituted by the same string.
4.8:To retain the last binding and use default values. Thus P2is ﬁrst bound to
MANand then to DAN. SinceP3is not bound to any argument, it should get a default
value.
4.9:The macro processor would continue scanning the source, reading and assign-
ing more and more text to the second argument, until one of the following happens:
1. It ﬁnds a period-space combination somewhere in the source. This would termi-
nate the scan and would bound the second parameter to a (long) argument.
2. It gets to the end of the source and realizes that something went wrong.
3. It ﬁnds a character (rather, a token) in a context that’s invalid inside a macro
argument. In the case of T EX, such a token could be the start of a new paragraph.
Append.C Answers to Exercises 277
In cases 2, 3 the macro processor would issue a ‘run away argument’ error message,
and either terminate the macro expansion or give the user a chance to correct thesource ﬁle interactively.
4.10: The diﬀerence is in scope. Attributes of macro arguments exist only while
the macro is expanded. Attributes of a symbol exist while the symbol is stored inthe symbol table.
4.11: The programmer probably meant a default value of null for parameter M2.
However, depending on the syntax rules of the assembler, this may also be consid-ered an error.
4.12: It should be, since it alerts the reader to the fact that some of the listing is
suppressed.
4.13: Because it allows the implementation of recursive macros.
4.14: Yes, many assemblers support simple expressions in the AIFdirective.
4.15: A constant, a SETsymbol, or a macro argument.
4.16: No, one ‘ ENDM X ’ is enough. It signals to the assembler the end of macro X
and all its inner deﬁnitions.
4.17: The string ‘A’[AY](AYX) .
5.1:Nothing, since the assembler does not process the macro lines at deﬁnition
time.
5.2:.show me . Note that mestands for ‘Macro Expansion’. Therefore, there are
no directives such as .show you or.noshow you . (Both.show and.noshow are
described in Ch. 4.)
5.3:It ﬁnds the new deﬁnition of ‘ begin ’, and discovers that it is diﬀerent from
the one already in the symbol table.
6.1:Yes. See Coulouris, Ref. [91].
6.2:Refer to the codes in the table; some valid conversions are -
B→D, K→B, D→P, D→K, K→D.
Invalid ones are -
X→D, H→E, E→B.
Also see any COBOL text, e.g. [90], for a complete list of COBOL type conversions.
6.3:If something like A[5,3] is needed, the programmer may either declare three
arraysA1[5] ,A2[5] ,A3[5] , or one large array A[15] . The operation ‘ A[3,2]:=0; ’
can then be written either as ‘ A2[3]:=0; ’o r‘A[i]:=0; ’ where ‘i:=3+5*(2-1); ’.
6.4:Xis a parameter that should be in the symbol table. Its value should be a
string, such as ‘A’ or ‘S’. The parameter is then replaced by its value and the result
278 Answers to Exercises Append.C
is a string such as ARorSR, that can be assembled. This is similar to substituting
parameters in a macro.
7.1:Tradition and/or laziness.
7.2:If the original estimate is too low, the program won’t be loaded. If it is too
high, the user may pay too much for memory use. So the user uses either experienceor bitter experience.
7.3:The loader issues an error message, advising the user to try again later or, if
the program is bigger than the entire memory, to reduce the program size. Thereare several methods to let a large program execute in a smaller memory. One isthe use of overlays . Overlays are an assembler-loader feature and are discussed
elsewhere in this chapter. Another method is the use of virtual memory , with pages
and/or segments. The topic of virtual memories is outside the scope of this bookand is discussed in OS texts.
7.4:It starts execution at the ﬁrst load address (the ﬁrst address of the ﬁrst object
ﬁle) and issues a suitable comment.
7.5:The type of the program (such as procedure, data block, library routine) if
this is available.
7.6:This is certainly an error. The loader cannot match the extsymbol to any of
the two.
7.7:Let’s assume that the loader has found an item in object ﬁle NOMwithid=1 0
and index=3, this item is not in the GESTand the loader will fail to ﬁnd it. Such acase should not happen since, after all, the object ﬁles are prepared by the assembler,and the assembler will not prepare an item with index=3 unless it has at least threeEXTRN symbols in the program. Such symbols would be assigned indexes 1, 2, 3,
and would be written, on the object ﬁle, as loader directives. If such a case doeshappen, it means either a bug in the assembler or the loader, or that the object ﬁlehas been corrupted. Perhaps it has been modiﬁed or damaged before loading. Thisis another possible loader error message.
7.8:TheA-Bpart equals absolute 13, and can be calculated in pass 1 since neither
AnorBis a future symbol. The values of M,N, however, are unknown in pass 1 (in
fact, unknown even in pass 2). The EQUhas to assign a value to label Xin pass 1. It
therefore cannot be executed. The assembler would issue an error message ‘Invalidoperand in EQU’. TheDC, however, simply assigns to label Y, in pass 1, the value
of the LC (=62) and, in pass 2, does not have to fully calculate the value of theconstant. It generates the constant 25 −12 = 13 = 00001101
2and writes it on the
object ﬁle with an idof 00. Then it generates two ‘modify’ loader directives, one
to add the value of Mand the other, to subtract N.
011 00001 0000 1000 01 111110 we assume an index of 1 for M
011 00010 0000 1000 10 111110 and index 2 for N
7.9:Yes, but then it can be used only by an absolute loader.
Append.C Answers to Exercises 279
7.10: ‘Undeﬁned External Symbol’. The loader cannot tell if a library routine is
really missing or if the name is that of a bad external symbol.
7.11: It is possible to generalize the concept of overlay load and delete, such that
any overlay can call any other one, and there is no RETurn. Let’s assume that Aand
Dare active and DcallsB. In such a case, Dand all its active descendants are deleted
automatically and Bis loaded. Even more, if DcallsE, thenDand its descendants
are deleted as before, and both overlays BandEare loaded.
7.12: There are two ways.
1.The bootstrap ROM is a separate memory, and is copied into main memory as
the ﬁrst step in a bootstrap.
2.The boostrap ROM can be switched in and out of the address space. Let’s
assume that the bootstrap ROM occupies addresses xxx-yyy in the address space.
It is possible, although probably not worth it, to have a small RAM with the sameaddress range, and a multiplexor that can switch either the RAM or the ROM intothe address space. When the computer is reset, the multiplexor should switch inthe ROM, ready for the next bootstrap. When the bootstrap loader is executed,its last instruction should be to switch back the RAM, so address range xxx-yyy
could be used by application programs.
7.13: As explained in chapter 7, the assembler should maintain a table (perhaps a
packed array) with 64 boolean values, each for a drum location, identifying its stateas either free or occupied.
8.1:It directs MASM to create a pass-1 listing in addition to, not instead of, the
usual, pass-2, listing.
A.1: By designing variable-length OpCodes. Most texts on computer organization
explain the method, which is based on assigning short OpCodes to long instructions,and long OpCodes, to short instructions. Another, intriguing, possibility is to assignthe short OpCodes to commonly used instructions. Such a method is used on theB1700 computers and is discussed by Organick [93]. An interesting theoreticalpossibility is to use the Huﬀman method [94] to determine the shortest possibleOpCodes based on the frequency of use of each instruction.
A.2: Yes. The instruction is only assembled in pass 2 and, at that time, the values
of all symbols are in the symbol table. However, in pass 1 the assembler has todetermine the size of each instruction, and that size may depend on the mode. Ifthe mode cannot be determined because of a future symbol, the assembler selectsthe mode with the largest size.
A.3: A good choice is ‘ LOD R5,#ARY ’. This instruction uses the immediate mode.
A.4: A computer using cascaded indirect should have a special directive for this
purpose.
A.5: Many stack operations use the one or two elements on top of the stack as
their operands. Such an operation removes the operands from the stack and pushes
280 Answers to Exercises Append.C
the result into the stack. If the programmer wants to use the same operands in
the future, they should be left in the stack. An easy way to accomplish this is togenerate their copies before excecuting a stack instruction. Example:
LOD 1 loads the element right below the top.
1.PUSH it becomes the new top.
LOD 1 loads the element right below the new top (the old top).
2.PUSH it becomes the new top.
3.ADD adds the two elements on the top and removes them.
The reader should try to ﬁgure out the successive states of the stack at the 3 labeled
instructions above.
A.6: Because it is a directive, executed at assembly time. Assembler directives
cannot load registers at run time.
B.1: 70F16= 0111 0000 1111 2.
If you can’t solve a problem,
you can always look up the answer.
But please, try ﬁrst to solve it by yourself;
then you’ll learn more and you’ll learn faster.
—Donald E. Knuth The METAFONTbook (1986)
Index
Page numbers in boldface indicate the most deﬁnitive source of information about an item.
* directive, 84
= directive, 81
2650 microprocessor, 15, 2106502 microprocessor, 190, 260, 266
disassembler for, 194
6800 microprocessor, 160, 26668000 microprocessor, 44, 81, 255, 266
680x0 microprocessors, xii, 243, 258
68851 paged memory management unit,
243
68881 ﬂoating-point coprocessor, 243
80386 microprocessor, 255
8080 microprocessor, 2668086 microprocessor, 237
80x86 microprocessors, xii, 2, 47, 48, 76,
85, 98, 169, 187, 191, 229, 230, 235,
246, 258
absolute mode, 236disassembler for, 192memory addressing, 42, 231
80x87 coprocessors, 230, 23180x88 microprocessors, 85, 169, 229, 230,
235
disassembler for, 192
ABS directive, 77
absolute assembly, 73
absolute instructions, 54
absolute loader, 12, 195, 196, 198, 199,
211, 224
absolute object ﬁle, 12, 30, 77, 198, 199,
211, 212, 214
absolute special relocation, 205
absolute symbol, 36, 53, 135, 138
accumulator, 261
accumulator mode, 261
ACE computer, 221
actual arguments stack, 146
address expressions, 35
address symbols, 138
addressing modes, 189, 199, 254–262, 265,
266, 267; see also mode, 267
current page direct, 261
282 Index
accumulator, 261
autodecrement, 262autoincrement, 262base relative, 262cascaded indirect, 260, 279current page direct, 261direct, 256, 260, 261immediate, 256, 257implicit, 261, 267implied, 261index, 256, 258, 259indirect, 256, 259, 260indirect index, 259indirect relative, 259multilevel indirect, 260post-index indirect, 260pre-index indirect, 260
register, 262
register indirect, 262relative, 256, 257, 259, 261stack, 259, 261stack relative, 261zero page, 260, 261
AGO directive, 138Aho, A., 65AIF directive, 137, 277Algol 60, 182, 183, 194anonymous software designer at NCR, 10ANOP directive, 138APL, 4Apple II computer, 87, 192architecture of computers, 2, 254ASCII, 78, 94, 179, 189, 192ASCII directive, 93ASCIIZ directive, 94ASM 86 assembler, 95, 97ASM 86 meta assembler, 187assemble-go, 2, 3, 199, 224
assemble-go loaders, 196assembler
deﬁnition of, 1
comment, 160
cooperationwith loader, 29cross, 11, 186, 193
directives, 3, 69
errors, 46, 159
fatal, 22, 46general, 47label, 46operand, 46operation, 46
phase errors, 47
warnings, 46
expressions, 35
absolute, 35
operator precedence, 35
relative, 35
high-level, xiii, 177, 178, 180, 183–186
high-level language, 177, 180
IBM360, 137inputs & outputs of, 2
instruction format, 49
its size, 5language, deﬁnition of, 1, 178
meta, xiii, 8, 11, 186, 189, 193
mode, 121
macro deﬁnition, 113, 121, 141–143,
148, 149
macro expansion, 113, 121, 130, 142,
143
MPW, 137one and a half passes, 30, 32
one pass, xii, 3, 11, 13, 19, 23, 24, 30,
31, 36, 38, 59, 195–199
linked lists, 25listing incomplete instructions, 25
operationof, 26
originof n ame, 2pass 0 & 1 combined, 111
percolative, 275
primitive, xiprocedures in, 40
punched card based, 74, 79
reasonfor studyin g, 2
resident, 11
source ﬁle
blank lines, 14
source instructions, 13
source line
comments, 13
ﬁelds, 13
format, 52long, 75
special types, 177
two passes, xii, 4, 11, 13, 19, 20, 22, 23,
30, 36, 59, 195
limitations of, 238
types of, 31, 36
universal, 186
Index 283
assembler errors, 46, 237, 238
fatal, 22, 46general, 47label, 46operand, 46operation, 46pass 1 errors, 232
phase errors, 47, 48, 232
undeﬁned symbol, 234warnings, 46, 233
assembler expressions
operator precedence in, 229
assembler language, 4assembling instructions, 18associating macro parameters with argu-
ments, 124
ASSUME directive, 85attributes of macro arguments, 125Autocoder, seeIBM702–705 assembler
autodecrement memory locations, 262autodecrement mode, 262
autoincrement memory locations, 262
autoincrement mode, 45, 262automatic jump-sizing in TASM, 237, 238automatic label generation, 127
BABBAGE language, xiii, 178, 184, 185,
194
arrays, 185expressions, 184records, 185
backward search of MDT, 143, 156bad symbols, 21BASE directive, 77base register, 89, 199, 262, 264, 265, 267
base relative mode, 262
BASIC, 4BEGIN directive, 79Bendix
G15, 221
binary numbers, 268binary search, 60, 66bin ary tree inanarray, 66
binder (linker loader), 195, 224
binding, 156, 212binding time, 212bit operations, 31block structure, 156, 178, 181block structured language, 144BNF deﬁnition, 270bootstrap loader, xiii, 12, 195, 220, 224
bootstrap process, 220bootstrap ROM, 279Borland International, 236Borland turbo assembler, seeTASM
Bostonians (anagram), 158BRANCH directive, 247
BSSZ directive, 94
Burroughs, 195
B1700, 279
BYTE directive, 80
C programming language, 240
Calingaert, P., 175
Cambridge University, 7cascaded indirect mode, 96, 260, 279CDC
6000, 76
6600, 2667600, 76Cyber, 15, 33, 76, 187, 275display code, 78
early computers, 187
chained MDT, 122chaining overlays, 215CHANGE loader command, 214COBOL, 178–180, 277
records in, 194
CODE directive, 78CodeView debugger, 230COL directive, 78Coleridge, S. T., 67
collector (linker loader), 195
COM ﬁles onthe IBM PC, 32COMM directive, 79, 108commen t, inanin struction , 14COMMON directive, 196
Compass assembler, 187
complete binary tree, 66compound macro arguments, 116computer architecture, 2, 254CON directive, 94
conditional assembly, xii, 8, 69, 121, 126,
133,134, 137, 140, 155, 243
constant types, 94continuation lines, 75control section, 138, 197
Conway, M. E., 8, 37
cooperationbetweenassembler an d loader,
29
core memories, 220
284 Index
Coulouris, G. F., 277
Coward, N., 158CP/M, xiiCray, 275
computers, 33
CREF, 160
cross assembler, 11, 186, 193
forward references, 193
object ﬁle, 193
source computer, 193target computer, 193
cross reference information, 159
cross reference table, 159CSECT directive, 91
current page direct mode, 261
DATA (or DC) directive, 94
data structures for OpCode table, 49data types, 177, 178
DB directive, 191
DC directive, 94, 157, 160, 227, 259
DEBUG, (IBM PC debugger), 191
DEC, 241
PDP-11, 39, 81, 262, 265, 267PDP-8, 260, 261
VAX, 2, 44, 91, 125, 126, 128, 164, 168,
241, 262, 266, 267
addressing modes, 243, 244
literal mode, 44
DEC directive, 96
decimal computer, 221DECMIC directive, 99
DEF directive, 95
deﬁnition level counter, 141
DELETE loader command, 214delimited string, 100
delimiting macro parameters, 125
Dellert, G. T., 109
DF directive onMASM, 233
DG Nova minicomputer, 262direct mode, 256, 260, 261
directives, xii, 3, 8, 69,7 2
(?), 233*, 84
=, 81, 234
?, 233, 240ABS, 77
AGO, 138
AIF, 99, 135, 137, 277ALIGN, 198, 240ANOP, 138
ASCII, 93ASCIIZ, 94ASSUME, 85BASE, 77BCD, 95BEGIN, 79BES, 80BRANCH, 247BSS, 80BSSZ, 94BYTE, 80CODE, 78COL, 78COMM, 79, 108
COMM (onMASM), 233
COMMENT, 14COMMON, 196CON, 94CSECT, 42, 91DATA (or DC), 94DB, 95, 191
DC, 43, 45, 53, 94, 157, 160, 227, 259
DD, 95DEBUG, 242DEC, 95, 96DECMIC, 99DEF, 95
DEFAULT, 242
DF (onMASM), 233DIS, 95DISABLE, 92, 242DQ, 95DROP, 89, 90DS, 37, 39, 45, 53, 80, 160, 227, 272
DT, 95
DUP, 99, 104, 108DW, 95ECHO, 104EJECT, 101ENABLE, 242
END, 74, 91, 113, 196, 199, 204, 205, 216,
273
ENDbold, 74ENDC, 137ENDD, 105, 108
ENDF, 245
ENDM, 110, 112, 113, 157, 245
ENDP, 245ENDR, 245
Index 285
ENDS, 85
ENTRY, 32, 42, 73, 90, 93, 108, 195,
200, 201, 204, 205, 233, 246
EQU, 36, 82, 86, 134, 135, 155, 157, 160,
189, 234
ERR, 100
ERRNDEF, 234
ERRxx, 101EVEN, 81EXIT, 137EXPORT, 245, 246
EXTRN, 32, 42, 73, 90, 92, 108, 195,
200, 201, 204, 205
FORWARD, 247FUNC, 245GROUP, 86
HEAD, 108
HERE, 103ICTL, 74IDENT, 73, 200, 205
IF-ELSE-ENDIF, 127, 137
IF1, 137, 169
IF2, 137, 169IFDEF, 233IFF, 137IFT, 137
IIF, 129, 136
IMPORT, 245, 246INCLUDE, 75IRP, 108, 128, 235
LABEL, 235
LCC, 77, 108
LIMIT, 81LIST,102, 108, 129
listing ﬁle, 3LIT, 96
LITORG, 43, 44, 96, 97
loader, 32, 54, 73, 77, 83, 86
modify, 95, 272, 276
LONG, 80
MACHINE, 76, 247
MACRO, 109, 110, 112, 113, 147, 157
MAIN, 245MAX, 88MAX and MIN, 88
MDELETE, 242
MEND, 147, 148MICCNT, 88, 134MICRO, 100MIN, 88NARG, 126
NCHR, 127NOLIST, 102, 129NOSHOW, 129, 277OCT, 95OCTMIC, 100ODD, 81OPDEF, 105, 108OPSYN, 106–108OPT, 247ORG, 81, 160, 213
%OUT, 103OVERLAY, 83p286, 76PACKED, 97pass 0, 113, 121, 123, 131, 134, 135, 156
pass 1, 275
PDC, 102, 160
POS, 83, 272PPU, 76PRINT, 129PRINT ON/OFF, 172PROC, 245PSECT, 42, 91, 242PUBLIC (onMASM), 233PUNCH, 75PURGDEF, 106, 108PURGE, 235QUAL, 78RECORD, 97, 245REMOVE, 123REPRO, 75RMT, 103SBTTL, 102, 108SEG, 246SEGMENT, 85SET, 89, 99, 134, 234
SHOW, 129, 168, 277SPACE, 102STOPDUP, 99, 105, 108STRING, 247
STRUC, 98, 108
SUBTTL, 164TITLE, 73, 102, 108, 200UNION, 240USE, 39–41, 84, 219USING, 89, 265VFD, 99WORD, 80XREF, 103
286 Index
directives in Macro , 242
directives ina meta assembler, 188DIS directive, 95DISABLE directive, 92disassembled object code, 189disassembled source code, 189disassembler, xiii, 11, 189, 190, 192, 194
6502, 194
disks, 193displacement, 255, 260–262, 265Dlevel counter, 144, 146
double substitution, 115
double-operand instruction, 13DROP directive, 89, 90drum memory, 7, 221DS directive, 39, 80, 160, 227
DUP directive, 104, 108dynamic linking, 201, 212, 224
dynamic loader (DL), 212dynamic loading, xiii, 212
dynamic OpCode table, 108
EA, 255–260, 262
EBCDIC, 78, 189
Ecclesiastes, 6
ECHO directive, 104editing a macro, 118EDSAC, 7
assembler, 7memory, 7
eﬀective address, seeEA
EJECT directive, 101
Elevel counter, 146
Ellizey, R. S., 108END directive, 74, 91, 113, 196, 199, 204,
205, 216
END loader directive, 205end of ﬁle, 206ENDC directive, 137ENDD directive, 105, 108ENDF directive, 245
ENDM directive, 110, 112, 113, 157, 245
ENDP directive, 245ENDR directive, 245ENTRY directive, 42, 90, 93, 108, 195,
200, 201, 204, 205, 246
ENTRY loader directive, 205entry point, 42
forgottendeclarationof, 207EQU directive, 86, 134, 135, 155, 157, 160,
189
EQU symbol, 137
ERR directive, 100
ERRxx directive, 101
EVEN directive, 81EXE ﬁles onthe IBM PC, 32
executable image, 211
executable module, 91, 200
EXIT directive, 137
EXPORT directive, 245, 246external linker, 187external symbols, 36, 42, 209, 215, 224,
278, 279
EXTRN directive, 42, 90, 91, 92, 108, 195,
200, 201, 204, 205
EXTRN loader directive, 205
factorial, 136
Ferguson, D. E., 8, 187ﬁrst executable instruction, 74, 199
ﬁrst source line, 74
ﬁrst-generation computers, 221
ﬂoating point hardware, 8
ﬂoating point numbers, 241
forcing upper, 33, 83, 197, 275
Ford, H., 57
formal parameters stack, 146
format of an assembler instruction, 49Fortran, xi, 79, 80
COMMON statement, 41, 79, 139
FORWARD directive, 247
FUNC directive, 245
fun ctionina meta assembler, 188
future symbol problem, 18, 19
future symbols, 18, 19, 24, 31, 36, 38, 43,
45, 159, 226, 234, 275, 278, 279
GAS, seeIBM7090 assembler
GEC 4000 computer, xiii, 178, 184
general loader, 195
GEST, 200, 207, 208, 211, 214, 215, 278
giga (
230), 255
global external symbol table, seeGEST
global macro parameters, 144
Goldﬁnger, R., 8
Grishman, R., xiii
GROUP directive, 86
Harrington, A., 228, 247
hash function
properties of, 63
Index 287
hash table, 106
closed, 63
inserting, 63
collisions, 64
solutions, 64
hashing, 63open, 63, 65
buckets, 65
principle of, 65
overﬂow, 65rehashing, 65searching, 63
hashing algorithms, 67
HEAD directive, 108
HERE directive, 103hexadecimal numbers, 268high-level assembler, xiii, 12, 177
high-level assembler language, 177, 180
deﬁnition, 177
higher-level languages, xi, xii, 4, 156, 178,
271
historical development of assem. and load-
ers, 10
Honeywell
DDP516, 178, 183
Hopgood, F. R. A., 65HP
1000, 95, 260
2100, 95, 260
Huﬀmanmethod, 279
IBM, 195, 199
650 assembler (SOAP), 7, 2227000 assembler (SCAT), 8702–705 assembler (Autocoder), 8702–705 computers, 8
704 assembler (UASAP-1), 8
704-709-7090, 87040 assembler (IBMAP), 147090 assembler (GAS), 87090 assembler (IBMAP), 48
7090/7094, 31, 32
360, 16, 42, 89, 91, 96, 172, 178, 181, 186,
262, 265, 266, 275, 276
assembler, 112, 125, 137, 243macros, 140
370, 89650, 221, 225, 226
7040, xi
7090, 266AT, 230
PC, 32, 137, 169, 191, 230PS/2, 231, 235users’ organization, 8XT, 230
IBMAP, seeIBM7040 assembler
ICTL directive, 74id bits onthe object ﬁle, seeidentiﬁcation
bits
ideal mode of TASM, 239IDENT directive, 73, 200, 205
IDENT loader directive, 205identiﬁcation bits, 73, 87, 91, 204
IF-ELSE-ENDIF directive, 127, 137
IF1 directive, 137, 169IF2 directive, 137, 169IFF directive, 137IFT directive, 137IIF directive, 129, 136immediate mode, 43–45, 246, 256, 257
implicit mode, 261, 267
implied mode, 261IMPORT directive, 245, 246INCLUDE directive, 75INCLUDE loader command, 214, 215including a source ﬁle, 75
index deferred mode (on the PDP-11), 20
index mode, 256, 258, 259, 262
onthe PDP-11, 20
index register, 8, 258, 262indexing, 260indirect address, 259, 260indirect addressing, 96
indirect mode, 256, 259, 260
indirect-index mode, 259indirect-relative mode, 259Initial Orders, seeEDSAC assembler
instruction
absolute, 29, 54
padding with NOP,3 3
redeﬁne, 105relative, 54relocatable, 29, 32relocating, 31type, 30variable size, 51, 53
instruction set
designof, 33, 254
Intel, 47, 85, 95, 229, 230, 235, 258, 266intermediate ﬁle, 20, 96, 97, 116, 160, 175
288 Index
interpreter, 4
interpretive languages, 4
interrupt, 224
invalid OpCode, 83
invalid labels, 21
invalid OpCode interrupt, 83
IRP directive, 108, 128
Johnson, S., 267
Joyce, J., 158
Knuth, D. E., 109, 273, 280label, 13, 46
invalid, 21local,36, 37, 38, 237
name convention, 52
Lamb, V. S., 193
language
higher-level, seehigher-level languages
machine, 1
machine-independent, 2
machine-oriented, 1
late binding, 212, 232
LC, 3, 17, 18, 20, 24, 25, 32, 33, 38, 39,
41, 43–45, 49, 50, 53, 116, 121, 136,
159, 198, 204, 220, 224, 225, 233, 234,
238, 240, 257, 273
//, 41, 84
directives aﬀecting it, 71
multiple, 39–43, 49, 84, 85
name, 79
updating in pass 1, 20
LCC directive, 77, 108
Leventhal, L., 260
lexicographic order, 61
LIBRARY loader command, 215
library routine, 199–201, 204, 207, 214,
215, 224, 278, 279
ina meta assembler, 188
library search, 214, 215
LIFO, 132, 261
LIMIT directive, 81
linear array, 61
linkage editor, 12, 195, 198, 200, 211, 212,
224
linked list, 61, 65, 159
linker, 195, 200, 224
external, 187linking, 4, 201, 212
dynamic, 201, 212, 224
runtime, 201
linking editor, 211
linking loader, 12, 187, 195, 199, 224
links in overlays, 216LIST directive, 102, 108, 129
listing ﬁle, xiii, 3, 21, 69, 159, 160, 175,
245
cross reference, 3directives, 3
listing of macros, 116
listing of pass-1, 101, 232, 279
LIT directive, 96literal table, 43, 44, 96, 97
literals, 43, 44, 97, 258
LITORG directive, 96, 97
load module, 199, 200, 211, 212
loader, xii, xiii, 29, 31, 195, 256
absolute, 12, 195, 196, 198, 199, 224
assemble-go, 196
bootstrap, xiii, 12, 195, 220, 224
command ﬁle, 213commands, 213
control, 213
cooperationwith assembler, 29dynamic, 212error messages, 200, 278, 279
errors, 214
general, 195linker, 195linking, 12, 187, 195, 199, 224
listing ﬁle, 200
outputs, 200
passes of, 31, 40, 204relocating, 12, 195, 200, 211, 224tasks, 195
loader commands
CHANGE, 214DELETE, 214INCLUDE, 214, 215
LIBRARY, 215
NOCALL, 215
Index 289
loader directives, 3, 30, 32, 54, 73, 77, 79,
82, 83, 86, 200, 201, 213, 274
END, 205ENTRY, 205EXTRN, 205IDENT, 205identifying, 204MODIFY, 95, 205, 209, 210, 224
overlay, 216program size, 199, 205size of, 205special symbols, 205, 206start executionat, 205types, 205USE, 219, 220, 224
loading, 4
dynamic, 212
local labels, xii, 8, 36, 37, 38, 52, 127, 239,
245
in
Macro , 242
inTASM, 237
locationcoun ter, seeLC
LONG directive, 80
MACHINE directive, 76, 247
machine instruction, 3, 22, 26, 30, 36
displacement ﬁeld, 26mode ﬁeld, 26
machine language, 1, 190, 254machine-independent languages, 2machine-oriented language, 1Macintosh computer, 43, 127, 128, 137,
172, 194, 229
toolbox routines, 245
Macintosh Programmer’s Workshop, see
MPW
macro, xii, 69, 109, 189
actual arguments, 114arguments
count attribute, 126integer attribute, 126length attribute, 126number attribute, 126
scaling attribute, 126
type attribute, 126
associating parameters with arguments,
124
attributes of arguments, 125binding arguments, 114compound arguments, 116deﬁnition, 109, 110, 111, 116, 155, 160
nested, 122, 130, 141, 143, 144, 146,
154, 155, 276
runaway, 113
editing, 118
expansion, 110, 111, 113, 115, 121, 155
listing, 160nested, 130, 132, 146, 276recursive, 134
factorial, 136
global parameters, 144
inTASM, 239listing, 116, 160local labels, 127multiply-deﬁned, 122
nested, 121, 130, 243
onIBM 360, 140onMPW assembler, 243parameters, 114
delimiting, 125
double substitution, 115keyword, 243multiple substitution, 276positional, 243
recursive, 133, 134
removing from MDT, 123serial number replacing parameters, 144system, 122, 123tokens, 118
macro assembler, 11
macro deﬁnition mode, 113, 121, 141–143,
148, 149
macro deﬁnition stack, seeMDS
macro deﬁnition table, seeMDT
macro deﬁnition time, 147
MACRO directive, 110, 112, 113, 147, 157
macro expansion mode, 113, 121, 142, 143
macro expansion stack, seeMES
macro name table, seeMNT
Macro (VAX assembler), 2, 42, 81, 92,
125, 126, 128, 129, 164, 229, 240
addressing modes of, 243data types in, 241directives, 242local labels in, 242
macros in, 243
source line format in, 241special characters in, 241
Macroeconomics, 109Macrograph, 109
290 Index
Macronesia, 109
magnetic drum, 221magnetic tapes, 193MAIN directive, 245
MakeIndex , xiii
MASM, 2, 3, 48, 101, 137, 160, 169, 198,
229,230, 231, 232, 234, 237, 239, 279
assembler options, 231directives, 233expressions, 234
listing, 233
macros, 235source line format, 233
MAX and MIN directive, 88MAX directive, 88
McIlroy, M. D., 8
MDS, 144MDT, 5, 113, 114, 116, 118, 119, 121, 122,
123, 130–132, 138, 142–147, 149, 150,153, 155, 156, 235, 276
backward search, 122, 143, 156, 230
chained, 122
compacting it, 230deleting from, 230, 242eﬃcient search, 122
mega (
220), 255
memory allocation, 195
memory map, 73, 200, 206
memory page, 261memory protection, 205MEND directive, 147, 148
MES,132, 133, 138, 146, 150, 151
meta assembler, xiii, 8, 11, 186, 189, 193
adaptive, 186ASM-86, 187directives in, 188
function in, 188
general, 186general adaptive, 186generative, 186
generative restricted, 186
library routines, 188MOPI, 187procedure in, 188restricted, 186
SLEUTH, 187
UTMOST, 187
MICCNT directive, 88, 134micro, 88, 100micro assembler, 12MICRO directive, 100
micro substitution, 100
microinstructions, 12
Microsoft, 48, 101Microsoft macro assembler, seeMASM
MIN directive, 88
mnemonic, 13, 20, 46, 189
MNT, 122, 123, 156
mode
autoincrement, 45
immediate, 43–45indirect, 96
cascaded, 96
register, 44
relative, 48
short immediate, 44
MODIFY loader directive, 205, 209, 210,
224
modules inMPW assembler, 245
MOPI meta assembler, 187
Morley, C., xiii
Morris, R., 64MPW, 243
MPW assembler, 43, 128, 137, 172, 229,
243
diagnostic output window, 245directives, 246
expressions, 246
listing ﬁle, 245literals, 246local labels, 127, 245
macros, 243
modules, 245postﬁx notation, 245
strings, 245
multilevel indirect mode, 260
multiple locationcoun ters, xii, 39, 40–43,
49, 84, 85, 219
multiple substitution, 276multiplexor, 279multiply-deﬁned labels, 21
multiply-deﬁned macro, 122
n+1 address computers, 221
NARG directive, 126
National Physical Laboratory, xiii, 183,
221
NCHR directive, 127
NCR, 178
century, 178
Index 291
NEAT/3, 10, 178–180
compiler, 178
constants area, 179
data records, 179data types, 179editing masks, 179instructions, 180working storage area, 179
nested expansion pointers stack, 146
nested macro deﬁnition, 122, 130, 141,
143, 144, 146, 154, 155, 276
nested macro expansion, 130, 132, 146,
276
nested macros, 121, 130
new source ﬁle, 121, 131, 136, 138, 151,
153, 154, 160
NOCALL loader command, 215NOLIST directive, 102, 129NOSHOW directive, 129, 277
null string, 123
Nutt, Roy, 8
Oak Ridge National Labs, xiii
object code, 30, 69
disassembled, 189
listing, 164
object ﬁle, 3, 17, 21, 30, 43, 54, 200, 220,
245
absolute, 19, 23, 26, 28, 30, 77, 195, 198,
199, 211, 212, 214
id bits, 73, 87
integrity of, 220, 224
relocatable, 19, 23, 28, 29–32, 73, 195,
199, 201
object module, 199
OCTMIC directive, 100
ODD directive, 81oﬀset, 48, 85, 255, 257one pass assembler, seeassembler, one pass
one pass assembly-load, 196
one pass linking loader, xiiione-and-a-half pass assembler, 8, 30, 32OpCode, 16
variable size, 279
OpCode table, 16, 20, 69, 106–108, 123,
189, 227
data structures for, 49dynamic, 108
OPDEF directive, 105, 108operating system, 122, 195, 204operator precedence, 235
OPSYN directive, 106–108
OPT directive, 247
ORG directive, 81, 160, 213
Organick, E., 279
OT, 218, 224
%OUT directive, 103
overlay, xiii, 215, 216, 218, 224, 278, 279
call instruction, 218chaining, 215
links, 216
root, 216
sublinks, 216
tree, 217
OVERLAY directive, 83
overlay loader directive, 216
overlay table, seeOT
p286 directive, 76
PACKED directive, 97
page zero, 260
pages, 200, 265, 278parameters inmacros, 114
parameters insubroutin es, 114
Pascal, 98, 185, 244
record, 108
pass -1, 276pass 0, 35, 110, 115, 116, 121, 122, 123,
127, 130, 132, 134–136, 138, 144, 155,160, 243, 276
directives, 113, 121, 123, 131, 132, 134,
135, 156
summary of, 154
pass 1, 20, 36, 47, 115, 116, 121, 134, 136,
138, 154, 155, 160, 168, 204, 205, 219,
234, 243, 245, 275, 278, 279
directives, 275errors, 232instruction size, 20listing, 3, 101, 232, 279
local labels in, 37operationof, 20
pass 2, 20, 36, 47, 116, 134, 138, 159, 160,
168, 169, 175, 204–206, 219, 278, 279
PC, 45, 256, 257, 261
PC DOS, 191
PDC directive, 102, 160
percolative assembler, 275
peripheral processor (PPU), 76phase errors, 47, 48, 169, 170, 232
292 Index
PL360, 178, 181, 183, 186, 194
compound statements, 182expressions, 182functions and procedures, 182
goto statement, 181
machine instructions, 182programs, 182scope of variables, 182variables, 182
PL516, xiii, 178, 183
POS directive, 83positioncoun ter, 33, 83
position independent code, 199, 257post-index indirect mode, 260postﬁx n otationinMPW assembler, 245
PPU directive, 76
pre-index indirect mode, 260PRINT directive, 129PRINT ON/OFF directive, 172problem-oriented languages, 2
PROC directive, 245
procedure, 109, 157, 181, 259
external, 4ina meta assembler, 188inassembler lan guage, 40
program name, 200, 207
PSECT directive, 42, 91pseudo instructions, seedirectives
PUNCH directive, 75punched card, 74, 79, 222punched paper tape, 193
PURGDEF directive, 106, 108
QUAL directive, 78reasonfor studyin g assemblers, 2
RECORD directive, 97, 245record inCOBOL, 194recursive macro, 133, 134, 136, 277
redeﬁne machine instructions, 105
register indirect mode, 262register mode, 44, 262
relationals, 137relative mode, 48, 209, 256, 257, 259, 261
displacement size in
Macro , 242
relative symbol, 36relocatable constants, 54relocatable instructions, 54, 211relocatable object ﬁle, 8, 12, 29, 30, 73,
199, 201relocatable symbol, 53
relocating instructions, 30
relocating loader, 12, 195, 200, 201, 211,
212, 224
relocation, 4, 201, 265relocationbit, 30, 36, 53, 73, 87, 92, 200,
257, 259
used as id, 32
relocationterm, 206, 208, 211
REMOVE directive, 123removing a macro from the MDT, 123,
230, 235, 242
Renwick, W., 7
repeat-duplicate (IRP), 128REPRO directive, 75reprogramming, 109resident assembler, 11
returnaddress, 259
Revesz, G., 144, 146RMT directive, 103routine library, 2
runaway argumen t, 277run away deﬁnition, 113
run time linking, 201
SBTTL directive, 102, 108
SCAT, seeIBM7000 assembler
scope of parameters, 156
scope of variables, 178sections of a program, 40SEG directive, 246segment, 85
address, 85
grouping, 86registers, 86
SEGMENT directive, 85segments, 200, 216, 265, 278
onthe 80x86, 47
semiconductor memories, 220separate assembly, 74, 90, 197sequence symbols, 121, 137, 138, 156
serial number replacing macro parameters,
144
SET directive, 89, 134
SET symbol, 121, 134, 135, 137, 138, 156,
243
SHARE, the IBM users’ organization, 8
short immediate mode, 44
SHOW directive, 129, 168, 277
Signetics, 15, 210size of an instruction, 20
Index 293
Skordalakis, E., 187
SLEUTH meta assembler, 187
SOAP, seeIBM650 assembler
software interrupt, 212, 216
source code, disassembled, 189
source ﬁle, 3, 13, 75, 111, 142, 199
backup, 274
source line, 3, 13
format of, 52
SPACE directive, 102special entries, 92
special relocation, 32, 54, 73, 200, 204
special symbol information, 206, 207
special symbol table, seeSST
special symbols, 205SST, 92, 93, 200, 206, 207
stack, 259stack mode, 259, 261
stack operations, 279
stack pointer, 261, 267
stack relative mode, 261
start address inEND directive, 205
STOPDUP directive, 105, 108
STRING directive, 247strings, 99
Struble, G. W., 265
STRUC directive, 98, 108students, of the author, xiisub-overlays, 216
sub-title inlistin g ﬁle, 160
sublinks in overlays, 216subroutine, 109
call, 110
parameters, 114
substring, 100
subtitle inlistin g ﬁle, 164
subtractive index registers, 275
SUBTTL directive, 164Swanson, E., 253
symbol
absolute, 36, 53, 138
attributes, 45, 159
EQU, 137
external, 36, 42, 91, 209, 215, 224, 278,
279
future, 18, 24, 31, 36, 38, 43, 45, 226,
234, 278
in an instruction, 13
length attribute, 45
relative, 36, 53sequence, 137
SET, 121, 134, 135, 137, 138, 156, 243
special, 205
type, 87value of, 159
symbol deﬁnition, 18symbol table, xii, 2, 5, 17, 18, 21, 24, 25,
32, 38, 43, 45, 59, 69, 93, 113, 116, 121,
136, 137, 159, 199, 205, 226, 227, 275,277
binary search tree, 59, 62
inserting, 62
global, 245
hash table, 59, 63linear array, 59, 60
inserting, 60searching, 60
linked lists, 59, 61
inserting, 61searching, 61
local, 245
macro, 245organization of, 59
sorted, 59, 60special entries, 92temporary, 121, 134, 136
system macros, 122, 123
TASM, 198, 229, 235, 236, 237, 239
automatic jump-sizing in, 237compatibility with MASM, 239directives, 240
expressions in, 236
extended push and pop, 236extended subroutine call in, 236forward references in, 238ideal mode of, 239
local labels in, 237
macros in, 239predeﬁned variables of, 236source lines format, 236unusual features of, 236
teletype terminals, 193
template, 97temporary symbol table, 134, 136tera (
240), 255
ternary numbers, 270
TEX, 125
nested macro deﬁnitions, 154
TITLE directive, 73, 102, 108, 200
title inlistin g ﬁle, 160
294 Index
tokens (in macros), 118
Tolliver, J., xiiitree data structure, 194
tree overlay, 217
tree structure, 216, 218turbo assembler, seeTASM
turbo C, 236
turbo debugger, 235turbo Pascal, 236
two pass assembler, seeassembler, two
passes
two’s complement, 267type of a symbol, 87
typed variables, 181
UASAP-1, seeIBM704 assembler
unconditional jump, 267
UNISAP, seeUNIVAC assembler
United Aircraft Corp., 8UNIVAC, 187, 195
1107, 187
I & II assembler (UNISAP), 8, 32, 37
UNIVAC III, 187universal assembler, 186unresolved references, 13, 18, 49, 57
USASI, 179
USE directive, 84, 219USE loader directive, 219, 220, 224
USING directive, 89, 265UTMOST meta assembler, 187
variable length instructions, 51, 53
variable-length OpCodes, 279variables
scope of, 178
VAX assembler, see
Macro
VAX computer, seeDEC
VFD directive, 99virtual memory, 200, 215, 278VOCS, 187von Neumann, John, 32
Warnock, J., 10
Webster (dictionary), 109Wichmann, B. A., xiiiWilkes, Maurice, 7Wirth, Niklaus, 8, 178WORD directive, 80
XREF directive, 103Z-80 microprocessor, 266
Z-80, assemblers for, xiizero page mode, 260, 261zero-operand instructions, 49
Indexing requires decision making of a far higher order than computers
are yet capable of.
—The Chicago Manual of Style, 13th ed. (1982)

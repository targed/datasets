Clojure In Small Pieces
Rich Hickey
Juozas Baliuka Eric Bruneton Chas Emerick
Tom Faulhaber Stephen C. Gilardi Daniel Solano Gmez
Christophe Grand Stuart Halloway Mike Hinchey
Shawn Hoover Chris Houser Rajendra Inamdar
Eugene Kuleshov Robert Lachlan J. McConnell
Chris Nokleberg Allen Rohner Michel Salim
Jason Sankey Stuart Sierra Frantisek Sodomka
Vishal Vishnoi Jean Niklas L´ orange Kyle Kingsbury
Kai Wu
Timothy Daly (Editor)
Based on Version 1.3.0-alpha4
November 14, 2013
Contents
Preface: Why Literate Programming i
Steps to build Clojure . . . . . . . . . . . . . . . . . . . . . . . . . i
Steps to change Clojure . . . . . . . . . . . . . . . . . . . . . . . . i
Why Bother? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ii
1 From The Ground Up (Kyle Kingsbury) 1
1.1 Clojure from the ground up . . . . . . . . . . . . . . . . . . . 1
1.1.1 Getting set up . . . . . . . . . . . . . . . . . . . . . . 1
1.1.2 The structure of programs . . . . . . . . . . . . . . . . 2
1.1.3 Review . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Clojure from the ground up: basic types . . . . . . . . . . . . 6
1.2.1 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2.2 Integers . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.2.3 Fractional numbers . . . . . . . . . . . . . . . . . . . . 9
1.2.4 Mathematical operations . . . . . . . . . . . . . . . . 9
1.2.5 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.2.6 Booleans and logic . . . . . . . . . . . . . . . . . . . . 13
1.2.7 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.2.8 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.2.9 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.2.10 Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.2.11 Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.2.12 Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.2.13 Putting it all together . . . . . . . . . . . . . . . . . . 20
2 From ideas to implementation 23
2.1 Starting from Java . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2 Extends and Implements . . . . . . . . . . . . . . . . . . . . . 23
2.3 Understanding Persistent Vectors (Jean Lorange) . . . . . . . 2 3
2.3.1 Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.3.2 Popping . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.3.3 O(1) != O(log n) . . . . . . . . . . . . . . . . . . . . . 31
2.3.4 Persistence . . . . . . . . . . . . . . . . . . . . . . . . 32
2.4 Red Black Trees . . . . . . . . . . . . . . . . . . . . . . . . . 39
i
ii CONTENTS
2.4.1 Persistence . . . . . . . . . . . . . . . . . . . . . . . . 39
2.4.2 Persistent Red Black Trees . . . . . . . . . . . . . . . 39
2.4.3 Node Structure . . . . . . . . . . . . . . . . . . . . . . 40
2.4.4 The Black Node implementation . . . . . . . . . . . . 42
2.4.5 Constructing a Black Node . . . . . . . . . . . . . . . 45
2.4.6 The Red Node implementation . . . . . . . . . . . . . 46
2.4.7 Constructing a Red Node . . . . . . . . . . . . . . . . 49
2.4.8 Okasaki’s balance cases . . . . . . . . . . . . . . . . . 50
2.4.9 Deleting a Node . . . . . . . . . . . . . . . . . . . . . 52
2.4.10 Clojure’s balance cases . . . . . . . . . . . . . . . . . . 53
2.4.11 Replacing a Node . . . . . . . . . . . . . . . . . . . . . 55
2.5 Immutable Data Structures . . . . . . . . . . . . . . . . . . . 55
2.6 Bit-Partitioned Hash Tries . . . . . . . . . . . . . . . . . . . . 55
2.6.1 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.6.2 Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.6.3 Hashmaps . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.6.4 Seqs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
2.7 Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
2.8 Java Interoperability . . . . . . . . . . . . . . . . . . . . . . . 62
2.8.1 Language primitives . . . . . . . . . . . . . . . . . . . 62
2.8.2 Clojure calling Java . . . . . . . . . . . . . . . . . . . 64
2.9 Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.10 Argument Deconstruction . . . . . . . . . . . . . . . . . . . . 65
2.11 The Read-Eval-Print Loop . . . . . . . . . . . . . . . . . . . . 65
2.12 Special Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.13 Reader Macros . . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.14 Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
2.15 Dynamic Comopilation . . . . . . . . . . . . . . . . . . . . . . 66
2.16 Ahead-Of-Time Comopilation . . . . . . . . . . . . . . . . . . 66
2.17 Lazy Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.18 Metadata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.19 Concurrency . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.20 Identity and State . . . . . . . . . . . . . . . . . . . . . . . . 66
2.21 Software Transactional Memory . . . . . . . . . . . . . . . . . 67
2.22 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.23 The Lisp Reader . . . . . . . . . . . . . . . . . . . . . . . . . 69
2.23.1 Reader Syntax Macros . . . . . . . . . . . . . . . . . . 71
2.23.2 The String reader macro . . . . . . . . . . . . . . . . . 72
2.23.3 The Comment reader macro . . . . . . . . . . . . . . . 74
2.23.4 The Wrapping reader macro . . . . . . . . . . . . . . . 74
2.23.5 The Meta reader macro . . . . . . . . . . . . . . . . . 75
2.23.6 The SyntaxQuote reader macro . . . . . . . . . . . . . 76
2.23.7 The Unquote reader macro . . . . . . . . . . . . . . . 79
2.23.8 The List reader macro . . . . . . . . . . . . . . . . . . 80
2.23.9 The Unmatched Delimiter reader macro . . . . . . . . 80
2.23.10The Vector reader macro . . . . . . . . . . . . . . . . 80
CONTENTS iii
2.23.11The Map reader macro . . . . . . . . . . . . . . . . . . 81
2.23.12The Character reader macro . . . . . . . . . . . . . . 81
2.23.13The Arg reader macro . . . . . . . . . . . . . . . . . . 82
2.24 Reader Dispatch Macros . . . . . . . . . . . . . . . . . . . . . 83
2.24.1 The Var reader macro . . . . . . . . . . . . . . . . . . 84
2.24.2 The Regular Expression reader macro . . . . . . . . . 85
2.24.3 The Function reader macro . . . . . . . . . . . . . . . 86
2.24.4 The Set reader macro . . . . . . . . . . . . . . . . . . 87
2.24.5 The Eval reader macro . . . . . . . . . . . . . . . . . . 87
2.24.6 The Unreadable reader macro . . . . . . . . . . . . . . 89
2.24.7 The Discard reader macro . . . . . . . . . . . . . . . . 89
2.25 Vars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
2.26 Transients . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
2.27 Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
2.28 Refs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
2.29 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
2.30 Promise and Deliver . . . . . . . . . . . . . . . . . . . . . . . 94
2.31 Futures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
2.32 MultiMethods . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
2.33 Deftype . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
2.34 Defrecord . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
2.35 Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
2.36 Prototypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
2.37 Genclass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
2.37.1 Overriding protected methods . . . . . . . . . . . . . . 102
2.38 Proxies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
2.39 Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
2.40 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
2.41 Generating Java Classes . . . . . . . . . . . . . . . . . . . . . 105
2.42 Type Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
2.43 Native Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . 105
3 Writing Idiomatic Clojure 107
4 The Ants Demo (Kai Wu) 109
4.1 The Simulation World . . . . . . . . . . . . . . . . . . . . . . 109
4.1.1 Initial setup of constants/magic-numbers . . . . . . . 109
4.1.2 The board: ready to mutate via transactions . . . . . 110
4.1.3 Ants as agents - doing asynchronous uncoordinated changes 112
4.1.4 Setting up the home, and ants . . . . . . . . . . . . . 113
4.1.5 Orientation and moving around the world . . . . . . . 115
4.1.6 Ant-agent behavior functions . . . . . . . . . . . . . . 116
4.1.7 World behavior: pheromone evaporation . . . . . . . . 124
4.2 The UI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.2.1 Using the Java AWT . . . . . . . . . . . . . . . . . . . 125
4.2.2 Functions to render the board and the ants . . . . . . 126
iv CONTENTS
4.2.3 Setting the scene, then updating it continually . . . . 128
4.3 Running the Program . . . . . . . . . . . . . . . . . . . . . . 130
4.3.1 Running the simulator . . . . . . . . . . . . . . . . . . 130
5 Parallel Processing 133
5.1 Natural Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.2 Steele’s parallel ideas . . . . . . . . . . . . . . . . . . . . . . . 133
5.3 Sequential mapreduce . . . . . . . . . . . . . . . . . . . . . . 137
5.3.1 Parallel mapreduce . . . . . . . . . . . . . . . . . . . . 139
5.4 MPI Message Passing . . . . . . . . . . . . . . . . . . . . . . 141
5.4.1 The N-colony Ant Demo . . . . . . . . . . . . . . . . . 141
5.5 MapReduce . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6 The ant build sequence 143
6.1 ant.build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
6.2 The Execution . . . . . . . . . . . . . . . . . . . . . . . . . . 149
7 jvm/clojure/asm/ 163
7.1 AnnotationVisitor.java . . . . . . . . . . . . . . . . . . . . . . 163
7.2 AnnotationWriter.java . . . . . . . . . . . . . . . . . . . . . . 165
7.3 Attribute.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7.4 ByteVector.java . . . . . . . . . . . . . . . . . . . . . . . . . . 176
7.5 ClassAdapter.java . . . . . . . . . . . . . . . . . . . . . . . . 183
7.6 ClassReader.java . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.7 ClassVisitor.java . . . . . . . . . . . . . . . . . . . . . . . . . 229
7.8 ClassWriter.java . . . . . . . . . . . . . . . . . . . . . . . . . 233
7.9 Edge.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
7.10 FieldVisitor.java . . . . . . . . . . . . . . . . . . . . . . . . . 263
7.11 FieldWriter.java . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.12 Frame.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
7.13 Handler.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
7.14 Item.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
7.15 Label.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
7.16 MethodAdapter.java . . . . . . . . . . . . . . . . . . . . . . . 314
7.17 MethodVisitor.java . . . . . . . . . . . . . . . . . . . . . . . . 317
7.18 MethodWriter.java . . . . . . . . . . . . . . . . . . . . . . . . 326
7.19 Opcodes.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 387
7.20 Type.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
8 jvm/clojure/asm/commons 413
8.1 AdviceAdapter.java . . . . . . . . . . . . . . . . . . . . . . . . 413
8.2 AnalyzerAdapter.java . . . . . . . . . . . . . . . . . . . . . . 426
8.3 CodeSizeEvaluator.java . . . . . . . . . . . . . . . . . . . . . 445
8.4 EmptyVisitor.java . . . . . . . . . . . . . . . . . . . . . . . . 449
8.5 GeneratorAdapter.java . . . . . . . . . . . . . . . . . . . . . . 453
8.6 LocalVariablesSorter.java . . . . . . . . . . . . . . . . . . . . 484
CONTENTS v
8.7 Method.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
8.8 SerialVersionUIDAdder.java . . . . . . . . . . . . . . . . . . . 496
8.9 StaticInitMerger.java . . . . . . . . . . . . . . . . . . . . . . . 506
8.10 TableSwitchGenerator.java . . . . . . . . . . . . . . . . . . . 508
9 jvm/clojure/lang/ 509
9.1 AFn.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
9.2 AFunction.java . . . . . . . . . . . . . . . . . . . . . . . . . . 519
9.3 Agent.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520
9.4 AMapEntry.java . . . . . . . . . . . . . . . . . . . . . . . . . 527
9.5 APersistentMap.java . . . . . . . . . . . . . . . . . . . . . . . 530
9.6 APersistentSet.java . . . . . . . . . . . . . . . . . . . . . . . . 538
9.7 APersistentVector.java . . . . . . . . . . . . . . . . . . . . . . 541
9.8 AReference.java . . . . . . . . . . . . . . . . . . . . . . . . . . 552
9.9 ARef.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
9.10 ArityException.java . . . . . . . . . . . . . . . . . . . . . . . 556
9.11 ArrayChunk.java . . . . . . . . . . . . . . . . . . . . . . . . . 556
9.12 ArraySeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 558
9.13 ASeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
9.14 Associative.java . . . . . . . . . . . . . . . . . . . . . . . . . . 576
9.15 Atom.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
9.16 ATransientMap.java . . . . . . . . . . . . . . . . . . . . . . . 579
9.17 ATransientSet.java . . . . . . . . . . . . . . . . . . . . . . . . 581
9.18 BigInt.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582
9.19 Binding.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
9.20 Box.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
9.21 ChunkBuﬀer.java . . . . . . . . . . . . . . . . . . . . . . . . . 586
9.22 ChunkedCons.java . . . . . . . . . . . . . . . . . . . . . . . . 586
9.23 Compile.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 588
9.24 Compiler.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 590
9.25 Cons.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 766
9.26 Counted.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 768
9.27 Delay.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 768
9.28 DynamicClassLoader.java . . . . . . . . . . . . . . . . . . . . 769
9.29 EnumerationSeq.java . . . . . . . . . . . . . . . . . . . . . . . 770
9.30 Fn.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
9.31 IChunk.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
9.32 IChunkedSeq.java . . . . . . . . . . . . . . . . . . . . . . . . . 773
9.33 IDeref.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 773
9.34 IEditableCollection.java . . . . . . . . . . . . . . . . . . . . . 774
9.35 IFn.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 774
9.36 IKeywordLookup.java . . . . . . . . . . . . . . . . . . . . . . 796
9.37 ILookup.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 797
9.38 ILookupSite.java . . . . . . . . . . . . . . . . . . . . . . . . . 797
9.39 ILookupThunk.java . . . . . . . . . . . . . . . . . . . . . . . . 798
9.40 IMapEntry.java . . . . . . . . . . . . . . . . . . . . . . . . . . 798
vi CONTENTS
9.41 IMeta.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
9.42 Indexed.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
9.43 IndexedSeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . 799
9.44 IObj.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800
9.45 IPersistentCollection.java . . . . . . . . . . . . . . . . . . . . 800
9.46 IPersistentList.java . . . . . . . . . . . . . . . . . . . . . . . . 801
9.47 IPersistentMap.java . . . . . . . . . . . . . . . . . . . . . . . 801
9.48 IPersistentSet.java . . . . . . . . . . . . . . . . . . . . . . . . 802
9.49 IPersistentStack.java . . . . . . . . . . . . . . . . . . . . . . . 802
9.50 IPersistentVector.java . . . . . . . . . . . . . . . . . . . . . . 802
9.51 IPromiseImpl.java . . . . . . . . . . . . . . . . . . . . . . . . 803
9.52 IProxy.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 803
9.53 IReduce.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 804
9.54 IReference.java . . . . . . . . . . . . . . . . . . . . . . . . . . 804
9.55 IRef.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
9.56 ISeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
9.57 IteratorSeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . 806
9.58 ITransientAssociative.java . . . . . . . . . . . . . . . . . . . . 807
9.59 ITransientCollection.java . . . . . . . . . . . . . . . . . . . . . 808
9.60 ITransientMap.java . . . . . . . . . . . . . . . . . . . . . . . . 808
9.61 ITransientSet.java . . . . . . . . . . . . . . . . . . . . . . . . 809
9.62 ITransientVector.java . . . . . . . . . . . . . . . . . . . . . . . 809
9.63 Keyword.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 810
9.64 KeywordLookupSite.java . . . . . . . . . . . . . . . . . . . . . 816
9.65 LazilyPersistentVector.java . . . . . . . . . . . . . . . . . . . 817
9.66 LazySeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 818
9.67 LineNumberingPushbackReader.java . . . . . . . . . . . . . . 823
9.68 LispReader.java . . . . . . . . . . . . . . . . . . . . . . . . . . 825
9.69 LockingTransaction.java . . . . . . . . . . . . . . . . . . . . . 836
9.70 MapEntry.java . . . . . . . . . . . . . . . . . . . . . . . . . . 850
9.71 MapEquivalence.java . . . . . . . . . . . . . . . . . . . . . . . 850
9.72 MethodImplCache.java . . . . . . . . . . . . . . . . . . . . . . 851
9.73 MultiFn.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 852
9.74 Named.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 861
9.75 Namespace.java . . . . . . . . . . . . . . . . . . . . . . . . . . 861
9.76 Numbers.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 867
9.77 Obj.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 947
9.78 PersistentArrayMap.java . . . . . . . . . . . . . . . . . . . . . 948
9.79 PersistentHashMap.java . . . . . . . . . . . . . . . . . . . . . 955
9.80 PersistentHashSet.java . . . . . . . . . . . . . . . . . . . . . . 980
9.81 PersistentList.java . . . . . . . . . . . . . . . . . . . . . . . . 982
9.82 PersistentQueue.java . . . . . . . . . . . . . . . . . . . . . . . 989
9.83 PersistentStructMap.java . . . . . . . . . . . . . . . . . . . . 995
9.84 PersistentTreeMap.java . . . . . . . . . . . . . . . . . . . . . 1000
9.85 PersistentTreeSet.java . . . . . . . . . . . . . . . . . . . . . . 1012
9.86 PersistentVector.java . . . . . . . . . . . . . . . . . . . . . . . 1014
CONTENTS vii
9.87 ProxyHandler.java . . . . . . . . . . . . . . . . . . . . . . . . 1030
9.88 Range.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1031
9.89 Ratio.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1033
9.90 Ref.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1034
9.91 Reﬂector.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 1044
9.92 Repl.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1054
9.93 RestFn.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1055
9.94 Reversible.java . . . . . . . . . . . . . . . . . . . . . . . . . . 1094
9.95 RT.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1094
9.96 Script.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1138
9.97 SeqEnumeration.java . . . . . . . . . . . . . . . . . . . . . . . 1138
9.98 SeqIterator.java . . . . . . . . . . . . . . . . . . . . . . . . . . 1139
9.99 Seqable.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1140
9.100Sequential.java . . . . . . . . . . . . . . . . . . . . . . . . . . 1140
9.101Settable.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 1140
9.102Sorted.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1141
9.103StringSeq.java . . . . . . . . . . . . . . . . . . . . . . . . . . . 1141
9.104Symbol.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1143
9.105TransactionalHashMap.java . . . . . . . . . . . . . . . . . . . 1145
9.106Util.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1149
9.107Var.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1152
9.108XMLHandler.java . . . . . . . . . . . . . . . . . . . . . . . . . 1164
10 jvm/clojure 1167
10.1 main.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1167
11 clj/clojure/ 1169
11.1 core.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1169
11.2 protocols.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1296
11.3 core˙deftype.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1298
11.4 core˙print.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1315
11.5 core˙proxy.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1323
11.6 data.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1332
11.7 genclass.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1334
11.8 gvec.clj. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1351
11.9 inspector.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1361
11.10browse.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1365
11.11browse˙ui.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1366
11.12io.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1367
11.13javadoc.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1376
11.14shell.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1378
11.15main.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1381
11.16parallel.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1389
11.17cl˙format.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1394
11.18column˙writer.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1436
11.19dispatch.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1438
viii CONTENTS
11.20pprint˙base.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1448
11.21pretty˙writer.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1456
11.22print˙table.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1467
11.23utilities.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1467
11.24pprint.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1470
11.24.1java.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1471
11.25reﬂect.clj. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1476
11.26repl.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1479
11.27set.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1485
11.28stacktrace.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1489
11.29string.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1490
11.30template.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1496
11.31junit.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1497
11.32tap.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1501
11.33test.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1503
11.34version.properties . . . . . . . . . . . . . . . . . . . . . . . . . 1519
11.35walk.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1519
11.36xml.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1522
11.37zip.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1524
11.38pom-template.xml . . . . . . . . . . . . . . . . . . . . . . . . 1531
12 test/clojure 1533
12.1 test/test˙clojure.clj . . . . . . . . . . . . . . . . . . . . . . . . 1533
12.2 test/test˙helper.clj . . . . . . . . . . . . . . . . . . . . . . . . 1535
12.3 test/agents.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1537
12.4 test/annotations.clj . . . . . . . . . . . . . . . . . . . . . . . . 1541
12.5 test/atoms.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1541
12.6 test/clojure˙set.clj . . . . . . . . . . . . . . . . . . . . . . . . 1542
12.7 test/clojure˙xml.clj . . . . . . . . . . . . . . . . . . . . . . . . 1546
12.8 test/clojure˙zip.clj . . . . . . . . . . . . . . . . . . . . . . . . 1547
12.9 test/compilation.clj . . . . . . . . . . . . . . . . . . . . . . . . 1548
12.10test/control.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1550
12.11test/data.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1556
12.12test/data˙structures.clj . . . . . . . . . . . . . . . . . . . . . . 1557
12.13test/def.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1574
12.14test/errors.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1575
12.15test/evaluation.clj . . . . . . . . . . . . . . . . . . . . . . . . 1576
12.16test/for.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1580
12.17test/genclass.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1583
12.18test/java˙interop.clj . . . . . . . . . . . . . . . . . . . . . . . . 1585
12.19test/keywords.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1594
12.20test/logic.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1594
12.21test/macros.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1599
12.22test/main.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1599
12.23test/metadata.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1600
12.24test/multimethods.clj . . . . . . . . . . . . . . . . . . . . . . 1602
CONTENTS ix
12.25test/ns˙libs.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1605
12.26test/numbers.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1607
12.27test/other˙functions.clj . . . . . . . . . . . . . . . . . . . . . . 1618
12.28test/parallel.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1620
12.29test/pprint.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1621
12.30test/predicates.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1621
12.31test/printer.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1624
12.32test/protocols.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1626
12.33test/reader.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1633
12.34test/reﬂect.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1640
12.35test/refs.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1640
12.36test/repl.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1641
12.37test/rt.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1642
12.38test/sequences.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1644
12.39test/serialization.clj . . . . . . . . . . . . . . . . . . . . . . . 1668
12.40test/special.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1671
12.41test/string.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1672
12.42test/test.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1674
12.43test/test˙ﬁxtures.clj . . . . . . . . . . . . . . . . . . . . . . . . 1677
12.44test/transients.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1678
12.45test/vars.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1678
12.46test/vectors.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1680
12.47test/java˙5.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . 1686
12.48test/java˙6˙and˙later.clj . . . . . . . . . . . . . . . . . . . . . . 1688
12.49test/examples.clj . . . . . . . . . . . . . . . . . . . . . . . . . 1690
12.50test/io.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1691
12.51test/javadoc.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1696
12.52test/shell.clj . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1696
12.53test/test˙cl˙format.clj . . . . . . . . . . . . . . . . . . . . . . . 1697
12.54test1/test˙helper.clj . . . . . . . . . . . . . . . . . . . . . . . . 1714
12.55test/test˙pretty.clj . . . . . . . . . . . . . . . . . . . . . . . . 1715
12.56test1/examples.clj . . . . . . . . . . . . . . . . . . . . . . . . 1721
12.57test/more˙examples.clj . . . . . . . . . . . . . . . . . . . . . . 1722
12.58test/example.clj . . . . . . . . . . . . . . . . . . . . . . . . . . 1722
A External Java References 1723
B Copyright and Licenses 1725
C Building Clojure from this document 1733
C.1 The basic idea . . . . . . . . . . . . . . . . . . . . . . . . . . 1733
C.2 The tangle function in C . . . . . . . . . . . . . . . . . . . . . 1733
C.3 Makeﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1737
C.4 The tangle function in Clojure . . . . . . . . . . . . . . . . . 1744
C.4.1 Author and License . . . . . . . . . . . . . . . . . . . 1744
C.4.2 Abstract and Use Cases . . . . . . . . . . . . . . . . . 1744
x CONTENTS
C.4.3 The Latex Support Code . . . . . . . . . . . . . . . . 1746
C.4.4 Imports . . . . . . . . . . . . . . . . . . . . . . . . . . 1747
C.4.5 The Tangle Command . . . . . . . . . . . . . . . . . . 1748
C.4.6 The say function . . . . . . . . . . . . . . . . . . . . . 1748
C.4.7 The read-ﬁle function . . . . . . . . . . . . . . . . . . 1748
C.4.8 The ischunk function . . . . . . . . . . . . . . . . . . . 1749
C.4.9 The haschunks function . . . . . . . . . . . . . . . . . 1750
C.4.10 The expand function . . . . . . . . . . . . . . . . . . . 1751
C.4.11 The tangle function . . . . . . . . . . . . . . . . . . . 1751
Bibliography 1753
Index 1755
CONTENTS xi
Foreword
Rich Hickey invented Clojure. This is a fork of the project to experim ent with
literate programming as a development and documentation technolo gy.
Every eﬀort is made to give credit for any and all contributions.
Clojure is a break with the past traditions of Lisp. This literate fork is a
break with the past traditions of code development. As such it is inte nded as
an experiment, not a replacement or competition with the oﬃcial ver sion of
Clojure.
Most programmers are still locked into the idea of making a program o ut of a
large pile of tiny ﬁles containing pieces of programs. They do not realiz e that
this organization was forced by the fact that machines like the PDP 1 1 only
had 8k of memory and a limit of 4k buﬀers in the editor. Thus there was a lot
of machinery built up, such as overlay linkers, to try to reconstruc t the whole
program.
The time has come to move into a more rational means of creating and main-
taining programs. Knuth suggested we write programs like we write lit erature,
with the idea that we are trying to communicate the ideas to other pe ople. The
fact that the machine can also run the programs is a useful side-eﬀ ect but not
important.
Very few people have seen a literate program so this is intended as a c omplete
working example, published in book form. The intent is that you can sit and
read this book like any other novel. At the end of it you will be familiar wit h
the ideas and how those ideas are actually expressed in the code.
Ifprogrammerscanreaditandunderstanditthentheycanmainta inandmodify
it. The ideas will have been communicated. The code will be changed to match
changes in the idea. We will all beneﬁt.
I’ve tried to make it as simple as possible. Try it once, you might like it.
Tim Daly
December 28, 2010 ((iHy))
CONTENTS i
Preface: Why Literate Programming
This is a literate program, inspired by Donald Knuth [Knu84]. It is intend ed
to be read like a novel from cover to cover. The ideas are expresse d clearly but
they are grounded in the actual source code.
The code in this documment is the executable source. The appendix g ives the
procedure for building a running system from the enclosed sources .
Steps to build Clojure
Step 1
Basically you need the C program [1733] tangle.c which you can clip using a
text editor and save it as tangle.c.
Step 2
Compile tangle.c to create a function called tangle.
gcc -o tangle tangle.c
Step 3Run tangle to extract the [1737] Makeﬁle from this document.
tangle clojure.pamphlet Makefile >Makefile
Step 4
make
This will
•create a new subdirectory called “tpd” containing all of the source code
•test Clojure
•create a running copy of Clojure
•create the pdf
•start a Clojure REPL
Steps to change Clojure
If you make changes to this document and want the new changes ju st type:
rm -rf tpd
tangle clojure.pamphlet Makefile >Makefile
make
or you can combine them into one line:
rm -rf tpd && tangle clojure.pamphlet Makefile >Makefile && make
ii CONTENTS
This will destroy the old source, extract the Makeﬁle, and rebuild th e system.
On a fast processor this takes about a minute.
Resist the urge to edit the ﬁles in the tpd directory. They are only th ere for the
compiler. Edit this ﬁle directly.
You can change where Clojure is built. In the [1737] Makeﬁle there is a line
which deﬁnes the root of the directory build. You can change this or override
it on the command line to build Clojure elsewhere.
WHERE=tpd
To build a second copy of Clojure, or to work in some other directory , just type
make WHERE=newplace
Why Bother?
Why bother with such a diﬃcult method of programming? Because wor thwhile
programs should “live”.
Programs “live” because people maintain them. Maintaining and modify ing
code correctly requires that you understand why the program is w ritten as it
is, what the key ideas that make the program work, and why certain , not very
obvious, pieces of code exist. Programmers almost never write this information
down anywhere. Great ideas are invented, the code is written, a ma n page of
documentation is created, and the job is done.
Well, almost. What does is mean for a program to “live”? How does a pro gram
survive once the original developers leave the project? There are many sources
of information but almost no source of knowledge. New programmer s don’t
know what the “elders” know. In order to “live” and continue to gro w there
has to be a way to transmit this knowledge.
Literate programming is Knuth’s proposed idea for moving from the w orld of
ideas to the world of information. This is not simply another document ation
format. This is meant to be Literature . The ideas are presented, the impli-
cations are explored, the tradeoﬀs are discussed, and the code is “motivated”,
like characters in a novel.
You are encouraged to write or rewrite sections of this document t o improve the
communication with the readers.
“But I have to learn latex!”. Well, for this document you do. But L ATEXis
just more than a document markup language like HTML and it is no hard er
to learn. It gives you the added advantage that you have a real lan guage for
publishing real documents. Most books are typeset with this techn ology and
a lot of conferences and Journals require it. If you can learn Clojur e, you can
learn L ATEX. If you’re a programmer you will always need to continue to learn,
at least until you retire into management.
CONTENTS iii
Having used literate programming for years I have collected some ke y quotes
that might stimulate your interest.
I believe that the time is ripe for signiﬁcantly better documentation o f pro-
grams,and thatwe canbest achievethis byconsideringprogramst obe works
of literature. Hence, my title “Literate Programming”. Let us chan ge our
traditional attitude to the construction of programs. Instead o f imagining
that our main task is to instruct a computer what to do, let us conce ntrate
on explaining to human beings what we want a computer to do.
–Donald Knuth “Literate Programming (1984)”
Step away from the machine. Literate programming has nothing to d o with
tools or style. It has very little to do with programming. One of the ha rd
transitions to literate programming is “literate thinking”.
–Timothy Daly in Lambda the Ultimate (2010)
The eﬀect of this simple shift of emphasis can be so profound as to ch ange
one’s whole approach to programming. Under the literate programm ing
paradigm, the central activity of programming becomes that of co nveying
meaning to other intelligent beings rather than merely convincing the com-
puter to behave in a particular way. It is the diﬀerence between per forming
and exposing a magic trick.
–Ross Williams, FunnelWeb Tutorial Manual
Another thing I’ve been enjoying lately is literate programming. Amaz ingly
it turns out to be faster to write a literate programthan an ordinar yprogram
because debugging takes almost no time.
–Bill Hart, SAGE Mailing list, May 3, 2010
The conversation is much more direct if the Design Concept per se, r ather
than derivative representatives or partial details, is the focus.
–Fred Brooks, “The Design of Design”
We are banning the old notion of literate programming that I used whe n
developing T EX82 because documentation has proven to be too much of a
pain.
–Donald Knuth TUG 2010
iv CONTENTS
Once upon a time I took great care to ensure that T EX82 would be truly
archival so that results obtainable today would produce the same o utput 50
years from now but that was manifestly foolish. Let’s face it, who is g oing
to care one whit for what I do today after even 5 years have elapse d, let
alone 50. Life is too short to re-read anything anymore in the intern et age.
Nothing over 30 months old is trustworthy or interesting.
–Donald Knuth TUG 2010
Chapter 1
From The Ground Up
(Kyle Kingsbury)
This is quoted from Kingbury. [King13]
1.1 Clojure from the ground up
1.1.1 Getting set up
When you have a JDK, youll need Leiningen, the Clojure build tool. If y oure on
a Linux or OS X computer, these instructions should get you going rig ht away.
If youre on Windows, see the Leiningen page for an installer. If you g et stuck,
you might want to start with a primer on command line basics.
mkdir -p ~/bin
cd ~/bin
wget https://raw.github.com/technomancy/leiningen/st able/bin/lein
chmod a+x lein
Leiningen automatically handles installing Clojure, ﬁnding libraries from the
internet, and building and running your programs. Well create a new Leiningen
project to play around in:
cd
lein new scratch
Thiscreatesanewdirectoryinyourhomedir,calledscratch. Ifyou seecommand
notfoundinstead, itmeansthedirectory /binisntregisteredwithy ourterminal
as a place to search for programs. To ﬁx this, add the line
1
2 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
export PATH="$PATH":~/bin
to the ﬁle .bash˙proﬁle in your home directory, then run
source ~/.bash_profile.
Re-running
lein new scratch
should work.
Lets enter that directory, and start using Clojure itself:
cd scratch
lein repl
1.1.2 The structure of programs
boa$ lein repl
which responds with
nREPL server started on port 45413
REPL-y 0.2.0
Clojure 1.5.1
Docs: (doc function-name-here)
(find-doc "part-of-name-here")
Source: (source function-name-here)
Javadoc: (javadoc java-object-or-class-here)
Exit: Control+D or (exit) or (quit)
user=>
This is an interactive Clojure environment called a REPL, for Read, Ex ecute,
Print Loop. Its going to read a program we enter, run that progra m, and print
the results. REPLs give you quick feedback, so theyre a great way to explore a
program interactively, run tests, and prototype new ideas.
Lets write a simple program. The simplest, in fact. Type nil, and hit ent er.
user=> nil
nil
nilis the most basic value in Clojure. It represents emptiness, nothing -doing,
not-a-thing. The absence of information.
user=> true
true
user=> false
false
1.1. CLOJURE FROM THE GROUND UP 3
trueandfalseare a pair of special values called Booleans. They mean exactly
what you think: whether a statement is true or false. true, false, and nil form
the three poles of the Lisp logical system.
user=> 0
0
This is the number zero. Its numeric friends are 1, -47, 1.2e-4, 1/3 , and so
on. We might also talk about strings, which are chunks of text surro unded by
double quotes:
user=> "hi there!"
"hi there!"
nil, true, 0, and ”hi there!” are all diﬀerent types of values; the no uns of pro-
gramming. Just as one could say House. in English, we can write a prog ram
like ”hello, world” and it evaluates to itself: the string ”hello world”. Bu t most
sentences arent just about stating the existence of a thing; the y involve action.
We need verbs.
user=> inc
#<core$inc clojure.core$inc@6f7ef41c>
This is a verb called incshort for increment. Speciﬁcally, inc is a symbol which
points to a verb: #<core$inc clojure.core$inc@6f7ef41c> just like the word run
is a name for the concept of running.
Theres a key distinction herethat a signiﬁer, a reference, a label, is not the same
as the signiﬁed, the referent, the concept itself. If you write the word run on
paper, the ink means nothing by itself. Its just a symbol. But in the m ind of a
reader, that symbol takes on meaning; the idea of running.
Unlike the number 0, or the string hi, symbols are references to oth er values.
when Clojure evaluates a symbol, it looks up that symbols meaning. Lo ok up
inc, and you get #<core$inc clojure.core$inc@6f7ef41c> .
Can we refer to the symbol itself, without looking up its meaning?
user=> ’inc
inc
Yes. The single quote ’ escapes an expression. It says Rather tha n evaluating
this text, simply return the text itself, unchanged. Quote a symbo l, get a
symbol. Quote a number, get a number. Quote anything, and get it b ack
exactly as it came in.
user=> ’123
4 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
123
user=> ’"foo"
"foo"
user=> ’(1 2 3)
(1 2 3)
A new kind of value, surrounded by parentheses: the list. LISP orig inally stood
for LISt Processing, and lists are still at the core of the language. This list
contains three elements: the numbers 1, 2, and 3. Lists can conta in anything:
numbers, strings, even other lists:
user=> ’(nil "hi")
(nil "hi")
A list containing two elements: the number 1, and a second list. That lis t
contains two elements: the number 2, and another list. That list con tains two
elements: 3, and an empty list.
user=> ’(1 (2 (3 ())))
(1 (2 (3)))
You could think of this structure as a treewhich is a provocative idea , because
languages are like trees too: sentences are comprised of clauses, which can be
nested, and each clause may have subjects modiﬁed by adjectives , and verbs
modiﬁed by adverbs, and so on. ”Lindsay, my best friend, took the dog which
we found together at the pound on fourth street, for a walk with h er mother
Michelle.
Took
Lindsay
my best friend
the dog
which we found together
at the pound
on fourth street
for a walk
with her mother
Michelle
But lets try something simpler. Something we know how to talk about. Incre-
ment the number zero. As a tree:
Increment
the number zero
We have a symbol for incrementing, and we know how to write the num ber zero.
Lets combine them in a list:
1.1. CLOJURE FROM THE GROUND UP 5
clj=> ’(inc 0)
(inc 0)
A basic sentence. Remember, since its quoted, were talking about t he tree,
the text, the expression, by itself. Absent interpretation. If we remove the
single-quote, Clojure will interpret the expression:
user=> (inc 0)
1
Incrementing zero yields one. And if we wanted to increment that va lue? In-
crement increment the number zero
user=> (inc (inc 0))
2
A sentence in Lisp is a list. It starts with a verb, and is followed by zero or
more objects for that verb to act on. Each part of the list can itse lf be another
list, in which case that nested list is evaluated ﬁrst, just like a nested clause in
a sentence. When we type
(inc (inc 0))
Clojure ﬁrst looks up the meanings for the symbols in the code:
(#<core$inc clojure.core$inc@6f7ef41c>
(#<core$inc clojure.core$inc@6f7ef41c>
0))
Then evaluates the innermost list (inc 0), which becomes the number 1:
(#<core$inc clojure.core$inc@6f7ef41c>
1)
Finally, it evaluates the outer list, incrementing the number 1:
2
Every list starts with a verb. Parts of a list are evaluated from left t o right.
Innermost lists are evaluated before outer lists.
(+ 1 (- 5 2) (+ 3 4))
(+ 1 3 (+ 3 4))
(+ 1 3 7)
11
6 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
Thats it.
The entire grammar of Lisp: the structure for every expression in the language.
We transform expressions by substituting meanings for symbols, a nd obtain
some result. This is the core of the Lambda Calculus, and it is the theo retical
basis for almost all computer languages. Ruby, Javascript, C, Has kell; all lan-
guages express the text of their programs in diﬀerent ways, but in ternally all
construct a tree of expressions. Lisp simply makes it explicit.
1.1.3 Review
We started by learninga few basic nouns: numbers like 5, strings like ” cat”, and
symbols like inc and +. We saw how quoting makes the diﬀerence betwee n an
expression itself and the thing it evaluates to. We discovered symbo ls as names
for other values, just like how words represent concepts in any ot her language.
Finally, we combined lists to make trees, and used those trees to rep resent a
program.
With these basic elements of syntax in place, its time to expand our vo cabu-
lary with new verbs and nouns; learning to represent more complex v alues and
transform them in diﬀerent ways.
1.2 Clojure from the ground up: basic types
Weve learned the basics of Clojures syntax and evaluation model. No w well
take a tour of the basic nouns in the language.
1.2.1 Types
Weve seen a few diﬀerent values alreadyfor instance, nil, true, fals e, 1, 2.34, and
”meow”. Clearly all these things are diﬀerent values, but some of th em seem
more alike than others.
For instance, 1 and 2 are very similar numbers; both can be added, d ivided,
multiplied, and subtracted. 2.34 is also a number, and acts very much like 1
and 2, but its not quite the same. Its got decimal points. Its not an integer.
And clearly true is not very much like a number. What is true plus one? O r
false divided by 5.3? These questions are poorly deﬁned.
We say that a type is a group of values which work in the same way. Its a
property that some values share, which allows us to organize the wo rld into sets
of similar things. 1 + 1 and 1 + 2 use the same addition, which adds toget her
integers. Types also help us verify that a program makes sense: th at you can
only add together numbers, instead of adding numbers to porcupin es.
Types can overlapand intersect eachother. Cats areanimals, and cats arefuzzy
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 7
too. You could say that a cat is a member (or sometimes instance), o f the fuzzy
and animal types. But there are fuzzy things like moss which arent a nimals,
and animals like alligators that arent fuzzy in the slightest.
Other types completely subsume one another. All tabbies are hous ecats, and
all housecats are felidae, and all felidae are animals. Everything whic h is true of
an animal is automatically true of a housecat. Hierarchical types ma ke it easier
to write programs which dont need to know all the speciﬁcs of every value; and
conversely, to create new types in terms of others. But they can also get in the
way of the programmer, because not every useful classiﬁcation ( like fuzziness) is
purely hierarchical. Expressing overlapping types in a hierarchy can be tricky.
Every language has a type system; a particular way of organizing no uns into
types, ﬁguring out which verbs make sense on which types, and rela ting types
to one another. Some languages are strict, and others more relax ed. Some
emphasize hierarchy, and others a more ad-hoc view of the world. W e call
Clojures type system strong in that operations on improper types are simply
not allowed: the program will explode if asked to subtract a dandelion . We
also say that Clojures types are dynamic because they are enforc ed when the
program is run, instead of when the program is ﬁrst read by the com puter.
Well learnmore about the formal relationshipsbetween types later , but fornow,
keep this in the back of your head. Itll start to hook in to other con cepts later.
1.2.2 Integers
Lets ﬁnd the type of the number 3:
user=> (type 3)
java.lang.Long
So 3 is a java.lang.Long, or a Long, for short. Because Clojure is built on top
of Java, many of its types are plain old Java types.
Longs, internally, are represented as a group of sixty-four binar y digits (ones
and zeroes), written downin aparticularpattern called signed twos complement
representation. You dont need to worry about the speciﬁcsther e are only two
things to remember about longs. First, longs use one bit to store th e sign:
whether the number is positive or negative. Second, the other 63 b its store the
size of the number. That means the biggest number you can repres ent with a
long is 263 - 1 (the minus one is because of the number 0), and the sma llest
long is -263.
How big is 263 - 1?
user=> Long/MAX_VALUE
9223372036854775807
8 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
Thats a reasonably big number. Most of the time, you wont need any thing
bigger, but what if you did? What happens if you add one to the bigges t Long?
user=> (inc Long/MAX_VALUE)
ArithmeticException integer overflow clojure.lang.Numb ers.throwIntOverflow
(Numbers.java:1388)
An error occurs! This is Clojure telling us that something went wrong . The
type of error was an ArithmeticException, and its message was inte ger overﬂow,
meaning this type of number cant hold a number that big. The error c ame from
a speciﬁc place in the source code of the program: Numbers.java, o n line 1388.
Thats a part of the Clojure source code. Later, well learn more ab out how to
unravel error messages and ﬁnd out what went wrong.
The important thing is that Clojurestype system protected us fro m doingsome-
thing dangerous; instead of returning a corrupt value, it aborted evaluation and
returned an error.
If you do need to talk about really big numbers, you can use a BigInt: an
arbitrary-precision integer. Lets convert the biggest Long into a BigInt, then
increment it:
user=> (inc (bigint Long/MAX_VALUE)) 922337203685477580 8N
Notice the N at the end? Thats how Clojure writes arbitrary-precis ionintegers.
user=> (type 5N)
clojure.lang.BigInt
There are also smaller numbers.
user=> (type (int 0))
java.lang.Integer
user=> (type (short 0))
java.lang.Short
user=> (type (byte 0))
java.lang.Byte
Integers are half the size of Longs; they store values in 32 bits. Sh orts are 16
bits, and Bytes are 8. That means their biggest values are 231−1, 215−1, and
27−1, respectively.
user=> Integer/MAX_VALUE
2147483647
user=> Short/MAX_VALUE
32767
user=> Byte/MAX_VALUE
127
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 9
1.2.3 Fractional numbers
To represent numbers between integers, we often use ﬂoating-p oint numbers,
which can represent small numbers with ﬁne precision, and large num bers with
coarseprecision. Floatsuse 32bits, and Doubles use 64. Doubles ar ethe default
in Clojure.
user=> (type 1.23)
java.lang.Double
user=> (type (float 1.23))
java.lang.Float
Floating point math is complicated, and we wont get boggeddown in the details
just yet. The important thing to know is ﬂoats and doubles are appr oximations.
There are limits to their correctness:
user=> 0.99999999999999999
1.0
To represent fractions exactly, we can use the ratio type:
user=> (type 1/3)
clojure.lang.Ratio
1.2.4 Mathematical operations
The exact behavior of mathematical operations in Clojure depends on their
types. In general, though, Clojure aims to preserve information. Adding two
longs returns a long; adding a double and a long returns a double.
user=> (+ 1 2)
3
user=> (+ 1 2.0)
3.0
3 and 3.0 are not the same number; one is a long, and the other a doub le. But
for most purposes, theyre equivalent, and Clojure will tell you so:
user=> (= 3 3.0)
false
user=> (== 3 3.0)
true
=asks whether all the things that follow are equal. Since ﬂoats are ap proxi-
mations, =considers them diﬀerent from integers. ==also compares things,
10 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
but a little more loosely: it considers integers equivalent to their ﬂoat ing-point
representations.
We can also subtract with -, multiply with *, and divide with /.
user=> (- 3 1)
2
user=> (* 1.5 3)
4.5
user=> (/ 1 2)
1/2
Putting the verb ﬁrst in each list allows us to add or multiply more than o ne
number in the same step:
user=> (+ 1 2 3)
6
user=> (* 2 3 1/5)
6/5
Subtraction with more than 2 numbers subtracts all later numbers from the
ﬁrst. Division divides the ﬁrst number by all the rest.
user=> (- 5 1 1 1)
2
user=> (/ 24 2 3)
4
By extension, we can deﬁne useful interpretations for numeric op erations with
just a single number:
user=> (+ 2)
2
user=> (- 2)
-2
user=> (* 4)
4
user=> (/ 4)
1/4
We can also add or multiply a list of no numbers at all, obtaining the addi-
tive and multiplicative identities, respectively. This might seem odd, es pecially
coming from other languages, but well see later that these genera lizations make
it easier to reason about higher-level numeric operations.
user=> (+)
0
user=> (*)
1
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 11
Often, we want to ask which number is bigger, or if one number falls be tween
two others. <= means less than or equal to, and assertsthat all following values
are in order from smallest to biggest.
user=> (<= 1 2 3)
true
user=> (<= 1 3 2)
false
<means strictly less than, and works just like <=, except that no two values
may be equal.
user=> (<= 1 1 2)
true
user=> (< 1 1 2)
false
Their friends >and>= mean greater than and greater than or equal to, re-
spectively, and assert that numbers are in descending order.
user=> (> 3 2 1)
true
user=> (> 1 2 3)
false
Also commonly used are inc and dec, which add and subtract one to a n umber,
respectively:
user=> (inc 5)
6
user=> (dec 5)
4
One ﬁnal note: equality tests can take more than 2 numbers as well.
user=> (= 2 2 2)
true
user=> (= 2 2 3)
false
1.2.5 Strings
We saw that strings are text, surrounded by double quotes, like ”f oo”. Strings
in Clojure are, like Longs, Doubles, and company, backed by a Java t ype:
user=> (type "cat")
java.lang.String
12 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
We can make almost anything into a string with str. Strings, symbols, numbers,
booleans; everyvalueinClojurehasastringrepresentation. Note thatnilsstring
representation is ””; an empty string.
user=> (str "cat")
"cat"
user=> (str ’cat)
"cat"
user=> (str 1)
"1"
user=> (str true)
"true"
user=> (str ’(1 2 3))
"(1 2 3)"
user=> (str nil)
""
str can also combine things together into a single string, which we call concate-
nation.
user=> (str "meow " 3 " times")
"meow 3 times"
To look for patterns in text, we can use a regular expression, which is a tiny
language for describing particular arrangements of text. re-ﬁnd and re-matches
look for occurrences of a regular expression in a string. To ﬁnd a ca t:
user=> (re-find #"cat" "mystic cat mouse")
"cat"
user=> (re-find #"cat" "only dogs here")
nil
That#"..."is Clojures way of writing a regular expression.
With re-matches, you can extract particular parts of a string whic h match an
expression. Here we ﬁnd two strings, separated by a :. The parentheses mean
that the regular expression should capture that part of the matc h. We get
back a list containing the part of the string that matched the ﬁrst p arentheses,
followed by the part that matched the second parentheses.
user=> (rest (re-matches #"(.+):(.+)" "mouse:treat"))
("mouse" "treat")
Regular expressions are a powerful tool for searching and match ing text, es-
pecially when working with data ﬁles. Since regexes work the same in mo st
languages, you can use any guide online to learn more. Its not somet hing you
have to master right away; just learn speciﬁc tricks as you ﬁnd you need them.
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 13
1.2.6 Booleans and logic
Everything in Clojure has a sort of charge, a truth value, sometime s called
truthiness. true is positive and false is negative. nil is negative, too .
user=> (boolean true)
true
user=> (boolean false)
false
user=> (boolean nil)
false
Every other value in Clojure is positive.
user=> (boolean 0)
true
user=> (boolean 1)
true
user=> (boolean "hi there")
true
user=> (boolean str)
true
If youre coming from a C-inspired language, where 0 is considered fa lse, this
might be a bit surprising. Likewise, in much of POSIX, 0 is considered su ccess
and nonzerovalues are failures. Lisp allowsno suchconfusion: the o nly negative
values are false and nil.
We can reason about truth values using and,or, andnot.andreturns the
ﬁrst negative value, or the last value if all are truthy.
user=> (and true false true)
false
user=> (and true true true)
true
user=> (and 1 2 3)
3
Similarly, orreturns the ﬁrst positive value.
user=> (or false 2 3)
2
user=> (or false nil)
nil
Andnotinverts the logical sense of a value:
14 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
user=> (not 2)
false
user=> (not nil)
true
Well learn more about Boolean logic when we start talking about contr ol ﬂow;
the way we alter evaluation of a program and express ideas like if Im a c at, then
meow incessantly.
1.2.7 Symbols
We saw symbols in the previous chapter; theyre bare strings of cha racters, like
foo or +.
user=> (class ’str)
clojure.lang.Symbol
Every symbol actually has two names: one, a short name, is used to refer
to things locally. Another is the fully qualiﬁed name, which is used to ref er
unambiguously to a symbol from anywhere. If I were a symbol, my na me would
be Kyle, and my full name Kyle Kingsbury.
Symbol names are separated with a /. For instance, the symbol str actually
comes from a family called clojure.core, which means that its full name is clo-
jure.core/str
user=> (= str clojure.core/str)
true
user=> (name ’clojure.core/str)
"str"
When we talkedabout the maximum sizeofan integer, that wasafully- qualiﬁed
symbol, too.
user=> (type ’Integer/MAX_VALUE)
clojure.lang.Symbol
The job of symbols is to refer to things, to point to other values. Wh en eval-
uating a program, symbols are looked up and replaced by their corre sponding
values. Thats not the only use of symbols, but its the most common.
1.2.8 Keywords
Closely related to symbols and strings are keywords, which begin with a:.
Keywords are like strings in that theyre made up of text, but are sp eciﬁcally
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 15
intended for use as labels or identiﬁers. These arent labels in the sen se of
symbols: keywords arent replaced by any other value. Theyre jus t names, by
themselves.
user=> (type :cat)
clojure.lang.Keyword
user=> (str :cat)
":cat"
user=> (name :cat)
"cat"
Aslabels,keywordsaremostusefulwhenpairedwithothervaluesin acollection,
like a map. Well come back to keywords shortly.
1.2.9 Lists
A collection is a group of values. Its a container which provides some s tructure,
some framework, for the things that it holds. We say that a collectio n con-
tains elements, or members. We saw one kind of collectiona listin the pr evious
chapter.
user=> ’(1 2 3)
(1 2 3)
user=> (type ’(1 2 3))
clojure.lang.PersistentList
Remember, we quote lists with a ’to prevent them from being evaluated. You
can also construct a list using list:
user=> (list 1 2 3)
(1 2 3)
Lists are comparable just like every other value:
user=> (= (list 1 2) (list 1 2))
true
You can modify a list by conjoining an element onto it:
user=> (conj ’(1 2 3) 4)
(4 1 2 3)
We added 4 to the listbut it appeared at the front. Why? Internally, lists are
stored as a chain of values: each link in the chain is a tiny box which holds the
value and a connection to the next link. This data structure, called a linked
list, oﬀers immediate access to the ﬁrst element.
16 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
user=> (first (list 1 2 3))
1
But getting to the second element requires an extra hop down the c hain
user=> (second (list 1 2 3))
2
and the third element a hop after that, and so on.
user=> (nth (list 1 2 3) 2)
3
nthgets the element of an ordered collection at a particular index. The ﬁ rst
element is index 0, the second is index 1, and so on.
This means that lists are well-suited for small collections, or collection s which
are read in linear order, but are slow when you want to get arbitrary elements
from later in the list. For fast access to every element, we use a vec tor.
1.2.10 Vectors
Vectors are surrounded by square brackets, just like lists are su rrounded by
parentheses. Because vectors arent evaluated like lists are, the res no need to
quote them:
user=> [1 2 3]
[1 2 3]
user=> (type [1 2 3])
clojure.lang.PersistentVector
You can also create vectors with vector, or change other struct ures into vectors
with vec:
user=> (vector 1 2 3)
[1 2 3]
user=> (vec (list 1 2 3))
[1 2 3]
conjon a vector adds to the end, not the start:
user=> (conj [1 2 3] 4) [1 2 3 4]
Our friends ﬁrst,second, andnthworkhere too; but unlike lists, nth is fast on
vectors. Thats because internally, vectors are represented as a very broad tree
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 17
of elements, where each part of the tree branches into 32 smaller t rees. Even
very large vectors are only a few layers deep, which means getting t o elements
only takes a few hops.
Inadditiontoﬁrst, youlloftenwanttogettheremainingelementsin acollection.
There are two ways to do this:
user=> (rest [1 2 3])
(2 3)
user=> (next [1 2 3])
(2 3)
restandnextboth return everything but the ﬁrst element. They diﬀer only
by what happens when there are no remaining elements:
user=> (rest [1])
()
user=> (next [1])
nil
restreturns logical true,nextreturns logical false. Each has their uses, but
in almost every case theyre equivalentI interchange them freely.
We can get the ﬁnal element of any collection with last:
user=> (last [1 2 3])
3
And ﬁgure out how big the vector is with count:
user=> (count [1 2 3])
3
Because vectors are intended for looking up elements by index, we c an also use
them directly as verbs:
user=> ([:a :b :c] 1)
:b
So we took the vector containing three keywords, and asked What s the element
at index 1? Index 1 is the second element, so this evaluates to :b.
Finally, note that vectors and lists containing the same elements are considered
equal in Clojure:
user=> (= ’(1 2 3) [1 2 3])
true
In almost all contexts, you can consider vectors, lists, and other sequences as
interchangeable. They only diﬀer in their performance characteris tics, and in a
few data-structure-speciﬁc operations.
18 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
1.2.11 Sets
Sometimes you want an unordered collection of values; especially whe n you plan
to ask questions like does the collection have the number 3 in it? Clojur e, like
most languages, calls these collections sets.
user=> #{:a :b :c}
#{:a :c :b}
Sets are surrounded by #{...}. Notice that though we gave the elements :a, :b,
and :c, they came out in a diﬀerent order. In general, the order of s ets can shift
at any time. If you want a particular order, you can ask for it as a list or vector:
user=> (vec #{:a :b :c})
[:a :c :b]
Or ask for the elements in sorted order:
user=> (sort #{:a :b :c})
(:a :b :c)
conj on a set adds an element:
user=> (conj #{:a :b :c} :d)
#{:a :c :b :d}
user=> (conj #{:a :b :c} :a)
#{:a :c :b}
Sets never contain an element more than once, so conjing an elemen t which is
already present does nothing. Conversely, one removes elements with disj:
user=> (disj #{"hornet" "hummingbird"} "hummingbird")
#{"hornet"}
The most common operation with a set is to check whether something is inside
it. For this we use contains?.
user=> (contains? #{1 2 3} 3)
true
user=> (contains? #{1 2 3} 5)
false
Likevectors,youcanusethesetitselfasaverb. Unlikecontains?, thisexpression
returns the element itself (if it was present), or nil.
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 19
user=> (#{1 2 3} 3)
3
user=> (#{1 2 3} 4)
nil
You can make a set out of any other collection with set.
user=> (set [:a :b :c])
#{:a :c :b}
1.2.12 Maps
The last collection on our tour is the map: a data structure which ass ociates
keys with values. In a dictionary, the keys are words and the deﬁnit ions are
the values. In a library, keys are call signs, and the books are value s. Maps
are indexes for looking things up, and for representing diﬀerent pie ces of named
information together.
user=> {:name "spook" :weight 2 :color "black"}
{:weight 2, :name "spook", :color "black"}
Maps are surrounded by braces {...}, ﬁlled by alternating keys and values. In
this map, the three keys are :name, :color, and :weight, and their valu es are
”spook”, ”black”, and 2, respectively. We can look up the corresp onding value
for a key with get:
user=> (get {"cat" "meow" "dog" "woof"} "cat")
"meow"
user=> (get {:a 1 :b 2} :c)
nil
getcan also take a default value to return instead of nil, if the key doesn t exist
in that map.
user=> (get {:glinda :good} :wicked :not-here)
:not-here
Since lookups are so important for maps, we can use a map as a verb d irectly:
user=> ({"amlodipine" 12 "ibuprofin" 50} "ibuprofin")
50
And conversely, keywords can also be used as verbs, which look the mselves up
in maps:
20 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
user=> (:raccoon {:weasel "queen" :raccoon "king"})
"king"
You can add a value for a given key to a map with assoc.
user=> (assoc {:bolts 1088} :camshafts 3)
{:camshafts 3 :bolts 1088}
user=> (assoc {:camshafts 3} :camshafts 2)
{:camshafts 2}
assocadds keys if they arent present, and replaces values if theyre alre ady
there. If you associate a value onto nil, it creates a new map.
user=> (assoc nil 5 2)
{5 2}
You can combine maps together using merge, which yields a map containing
all the elements of all given maps, preferring the values from later o nes.
user=> (merge {:a 1 :b 2} {:b 3 :c 4})
{:c 4, :a 1, :b 3}
Finally, to remove a value, use dissoc.
user=> (dissoc {:potatoes 5 :mushrooms 2} :mushrooms)
{:potatoes 5}
1.2.13 Putting it all together
All these collections and types can be combined freely. As software engineers,
we model the world by creating a particular representation of the p roblem in
the program. Having a rich set of values at our disposal allows us to t alk about
complex problems. We might describe a person:
{:name "Amelia Earhart"
:birth 1897
:death 1939
:awards {"US" #{"Distinguished Flying Cross"
"National Women’s Hall of Fame"}
"World" #{"Altitude record for Autogyro"
"First to cross Atlantic twice"}}}
Or a recipe:
1.2. CLOJURE FROM THE GROUND UP: BASIC TYPES 21
{:title "Chocolate chip cookies"
:ingredients {"flour" [(+ 2 1/4) :cup]
"baking soda" [1 :teaspoon]
"salt" [1 :teaspoon]
"butter" [1 :cup]
"sugar" [3/4 :cup]
"brown sugar" [3/4 :cup]
"vanilla" [1 :teaspoon]
"eggs" 2
"chocolate chips" [12 :ounce]}
Or the Gini coeﬃcients of nations, as measured over time:
{"Afghanistan" {2008 27.8}
"Indonesia" {2008 34.1 2010 35.6 2011 38.1}
"Uruguay" {2008 46.3 2009 46.3 2010 45.3}}
In Clojure, we compose data structures to form more complex valu es; to talk
about bigger ideas. We use operations like ﬁrst,nth,get, andcontains? to
extract speciﬁc information from these structures, and modify t hem using conj,
disj,assoc,dissoc, and so on.
We started this chapter with a discussion of types: groups of similar objects
which obey the same rules. We learned that bigints, longs, ints, shor ts, and
bytes are all integers, that doubles and ﬂoats are approximations to decimal
numbers, and that ratios represent fractions exactly. We learne d the diﬀerences
between strings for text, symbols as references, and keywords as short labels.
Finally, we learned how to compose, alter, and inspect collections of e lements.
Armed with the basic nouns of Clojure, were ready to write a broad a rray of
programs.
Id like to conclude this tour with one last type of value. Weve inspecte d dozens
of types so farbut what what happens when you turn the camera o n itself?
user=> (type type)
clojure.core$type
What is this type thing, exactly? What are these verbs weve been lea rning,
and where do they come from? This is the central question of chapt er three:
functions.
22 CHAPTER 1. FROM THE GROUND UP (KYLE KINGSBURY)
Chapter 2
From ideas to
implementation
2.1 Starting from Java
2.2 Extends and Implements
2.3 Understanding Persistent Vectors (Jean Lo-
range)
This is quoted from L´ orange [L13].
You may or may not heard about Clojure’s persistent vectors. It is a data
structure invented by Rich Hickey (inﬂuenced by Phil Bagwell’s paper on Ideal
Hash Trees) for Clojure, which givespractically O(1) runtime for ins ert, update,
lookups and subvec. As they are persistent, every modiﬁcation cr eates a new
vector instead of changing the old one.
So, how do they work? I’ll try to explain them through a series of blog posts, in
which we look at manageable parts each time. It will be a detailed explan ation,
with all the diﬀerent oddities around the implementation as well. Conse quently,
this blog series may not be the perfect ﬁt for people who want a ”sum mary” on
how persistent vectors work.
For today, we’ll have a look at a naive ﬁrst attempt, and will cover up dates,
insertion and popping (removal at the end).
Notethat this blogpostdoesnot representhowPersistentVecto risimplemented:
There are some speed optimizations, solutions for transients and o ther details
which we will cover later. However, this serves as a basis for unders tanding how
23
24 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
they work, and the general idea behind the vector implementation.
The Basic Idea
Mutable vectors and ArrayLists are generally just arrays which gr ows and
shrinks when needed. This works great when you want mutability, bu t is a
big problem when you want persistence. You get slow modiﬁcation ope rations
because you’ll have to copy the whole array all the time, and it will use a lot of
memory. It would be ideal to somehow avoid redundancy as much as p ossible
without losing performance when looking up values, along with fast op erations.
That is exactly what Clojure’s persistent vector does, and it is done through
balanced, ordered trees.
The idea is to implement a structure which is similar to a binary tree. The
only diﬀerence is that the interior nodes in the tree have a referenc e to at most
two subnodes, and does not contain any elements themselves. The leaf nodes
contain at most two elements. The elements are in order, which mean s that the
ﬁrst element is the ﬁrst element in the leftmost leaf, and the last elem ent is the
rightmost element in the rightmost leaf. For now, we require that all leaf nodes
are at the same depth. As an example, take a look at the tree below: It has the
integers 0 to 8 in it, where 0 is the ﬁrst element and 8 the last. The num ber 9
is the vector size:
0 1 2 3 4 5 6 7 89 vector size
vector pointer
node
leaf node
element
Visualization of a vector with 9 elements in it.
If we wanted to add a new element to the end of this vector and we we re in the
mutable world, we would insert 9 in the rightmost leaf node:
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 25
10
0 1 2 3 4 5 6 7 8 9
Visualization of a vector with 10 elements in it.
But here’s the issue: We cannot do that if we want to be persistent. And this
would obviously not work if we wanted to update an element! We would n eed
to copy the whole structure, or at least parts of it.
To minimize copying while retaining full persistence, we perform path c opying:
We copy all nodes on the path down to the value we’re about to updat e or
insert, and replace the value with the new one when we’re at the bott om. A
result of multiple insertions is shown below. Here, the vector with 7 ele ments
share structure with a vector with 10 elements:
012 3 4 5 6 67
78 910
A visualization of two vectors, which use structural sharin g.
The pink coloured nodes and edges are shared between the vector s, whereas the
brown and blue are separate. Other vectors not visualized may also share nodes
with these vectors. Update
The easiest ”modiﬁcation” operator to understand would be updat es/replacing
values in a vector, so we will explain how updating works ﬁrst. In Cloju re,
that’s an assoc modiﬁcation, or an update-in.
To update an element, we would have to walk the tree down to the leaf node
where the element is place. While we walk down, we copy the nodes on ou r path
to ensure persistence. When we’ve gotten down to the leaf node, w e copy it and
26 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
replace the value we wanted to replace with the new value. We then re turn the
new vector with the modiﬁed path.
Asanexample, let’sassumeweperformanassoconthevectorwith t heelements
from 0 to 8, like this:
(def brown [0 1 2 3 4 5 6 7 8])
(def blue (assoc brown 5 ’beef))
The internal structures, where the blue one has the copied path, is shown below:
9
0 1 2 3 4 5 4beef 6789
Two vectors, where we’ve updated a value.
Given that we have a way to know which node to go down, this seems ea sy
enough. We’ll go through how we ﬁnd the path to a speciﬁc index in a lat er
part of this series.
2.3.1 Insertion
Insertion is not too much diﬀerent from an update, except that we have some
edge cases where we have to generate nodes in order to ﬁt in a value . We
essentially have three cases:
There is room for a new value in the rightmost leaf node. There is spac e in
the root, but not in the rightmost leaf node. There is not enough sp ace in the
current root.
We’ll go through them all, as their solutions are not that diﬃcult to gra sp.
Just Like Assoc
Whenever there is enough space in the rightmost leaf node, we can j ust do as we
do when we perform an assoc: We just copy the path, and at the ne wly created
leaf node, we put in the value to the right of the rightmost element.
As an example, here’s how we would do (conj [0 1 2 3 4] 5), and the inter nal
structures from doing so. black is the old:
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 27
5 6
0 1 2 3 4 4 5
Insertion with enough space in the leaf node.
That’s it. There’s no magic, just path copying and insertion in the leaf node.
Generate Nodes When You Need Them
So, what do we do when there’s not enough space in the leftmost leaf node?
Luckily, we’ll never end up in a position where we ﬁnd out that we’re in th e
wrong leaf node: We will always take the right path down to the leaf no de.
Instead, we will realize that the node we’re trying to go down to does n’t yet
exist (the pointer is null). When a node doesn’t exist, we generate on e and set
that one as the ”copied” node.
12 13
0 1 2 3 45678 9 abc
Insertion where we generate new nodes instead of copying.
In the ﬁgure above, the black nodes represent original nodes.
Root Overﬂow
The last case is the root overﬂow case. This happens when there isn ’t more
space in the tree with the current root node.
It’s not that diﬃcult to understand how we would solve this: We make a new
root node, and set the old root as the ﬁrst child of the new root. Fr om there
on, we perform the node generating, just as we did in the previous s olution.
28 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
9
8
0 1 2 3 4 5 6 7 8
Insertion where we generate a new root.
One thing is to solve the problem, but detecting when it happens is also im-
portant. Luckily, this is also rather easy. When we have a two-way b ranching
vector, this happens when the old vector’s size is a power of two. Ge nerally
speaking, an n-way branching vector will have an overﬂow when the size is a
power of n.
2.3.2 Popping
The solutions for popping (removing the last element) isn’t that diﬃcu lt to
grasp either. Popping similar to inserting in that there are three cas es:
The rightmost leaf node contains more than one element. The rightm ost leaf
node contains exactly one element (zero after popping). The root node contains
exactly one element after popping.
Essentially, these are all ways of reverting 1, 2 and 3 in the previous section,
neither of which are extremely complex.
Dissoc to the Rescue
Again, wehaveacasewherewecanjustdoaswedowhenweupdatea structure:
We copy the path down to the rightmost leaf node, and remove the r ightmost
element in the copied leaf node. As long as there is at least one element left in
the new leaf node, we don’t have to do any magic.
6
0 1 2 3 4 5 45
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 29
Popping a value from a vector with more than one element in the
rightmost leaf node.
Keep in mind that popping multiple times on a vector will not yield identical
vectors: They are equal, but they don’t share the root. For insta nce,
(def brown [0 1 2 3 4 5])
(def blue (pop brown))
(def green (pop brown))
will result in the following internal structure.
6
0 1 2 3 4 5 45 4
5
Performing pops on the same vector.
Removing Empty Nodes
Whenever we have a leaf node with only a single node, we have a diﬀeren t case.
We would like to avoid empty nodes in our tree at all cost. Therefore, whenever
we have an empty node, instead of returning it, we return null inste ad. The
parent node will then contain a null pointer, instead of a pointer to a n empty
node:
0 1 2 3 4 566 7
Popping and removing a leaf node.
Here, the brown vector is the original, whereas the blue one is the po pped one.
Unfortunately, it is not as easy as to just remove leaf nodes. You s ee, if we
return a null pointer to a node, which originally only had one child, we mu st
convertthat one into anull pointer which wesend back: The results ofemptying
30 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
a node propagates upwards. This is a bit tricky to get right, but ess entially it
worksby looking at the new child, check if it is null and is supposed to be placed
at index 0, and return null if that’s the case.
If this was implemented in Clojure, it may look something like this recurs ive
function:
(defn node-pop [idx depth cur-node]
(let [sub-idx (calculate-subindex idx depth)]
(if (leaf-node? depth)
(if (== sub-idx 0)
nil
(copy-and-remove cur-node sub-idx))
; not leaf node
(let [child (node-pop idx (- depth 1)
(child-at cur-node sub-idx))]
(if (nil? child)
(if (== sub-idx 0)
nil
(copy-and-remove cur-node sub-idx))
(copy-and-replace cur-node sub-idx child))))))
When such a function has been implemented, node removal has been taken care
of completely. As an example, see the graph below. Here, the poppe d (blue)
vector has removed two nodes: The leaf node containing c and its pa rent.
0 1 23 4 56 7 8 9 10 11 1213 12
Popping and removing multiple nodes.
Root Killing
Wehavenowcoveredallcases,exceptforone. Withthecurrentim plementation,
we would get the following result if we popped a vector with nine element s:
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 31
0 1 2 3 4 5 6 7 88 9
Popping with bad root handling.
That’s right, we’d have a root with a single pointer to a child node. Pret ty
useless, as we would always move down into the child when we lookup or a ssoc
values, and inserting values would create a new root. What we would lik e to do
is to get rid of it.
This is possibly the easiest thing in this blogpost to actually do: After w e have
ﬁnished popping, check if the root node contains only a single child (ch eck that
the second child is null, for instance). If that’s the case, and the ro ot node is
not a leaf node, we can just replace the root node with its child.
The result is, as expected, a new vector (blue) with the ﬁrst child of the original
vector’s root node as root:
0 1 2 3 4 5 6 7 89
8
Popping with proper root handling.
2.3.3 O(1) != O(log n)
Some people out there are probably wondering how this can be said to be O(1)
at all. In fact, with only two children per node, this is O(log2 n), which is
(relatively) far from O(1).
However, no one has said that we have to only havetwo children per n ode (often
referred to as the branching factor). Clojure has 32 per node, w hich in result
turns into very shallow trees. In fact, the trees will be at most 6 no des deep if
you have less than 1 billion elements in the vector. You need about 35 b illion
elements to get up to a depth of 8 nodes. At that point, I would believ e memory
consumption is a more serious issue.
32 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
To actually see the diﬀerence: Here is a 4-way branching tree with 14 elements,
which only is 2 levels deep. If you scroll up a bit, you’ll see a ﬁgure with t wo
vectors containing 13 and 12 elements, respectively. With two-way branching,
this is already 4 levels deep, double the height as this one.
0 1 2 3 4 5 6 7 8 9 abcd14
A 4-way branching vector.
As a result of the incredibly shallow trees, we tend to call modiﬁcation s and
lookup of Clojure vectors to be ”eﬀectively” constant time, althou gh they in
theory are O(log32 n). People with basic knowledge in big O notation kn ow
that this is exactly the same as O(log n), but for marketing reasons people like
to add in the constant factor.
To understand how we pick the right branch, I think it’s good to give t he proper
name of the structure and explain why it is named that. It sounds a b it weird
to explain branching through the name of a data structure, but it m akes sense
when you consider that such a name may describe how it works. Namin g
A more formal name for Clojure’s persistent vector structure is p ersistent bit-
partitionedvectortrie. WhatIexplainedinthepreviouspostwasho wpersistent
digit-partitioned vector tries work. Don’t worry, a bit-partitioned one is just an
optimized digit-partitioned trie, and in the previous post there is not hing diﬀer-
ent about them. In this one, there is a small diﬀerence related to pe rformance.
It has otherwise no practical diﬀerences.
I guess many of you don’t know all of those words I mentioned in the a bove
paragraph, so let’s describe them, one by one.
2.3.4 Persistence
In the last post, I used the word persistent. I said we want to be ”p ersistent”,
but didn’t really explain what persistence itself really means.
A persistent data structure doesn’t modify itself: Strictly speakin g they don’t
have to be immutable internally, just have to be perceived as such. W henever
you do ”updates”, ”inserts” and ”removals” on a persistent data structure, you
get a new data structure back. The old version will always be consist ent, and
whenever given some input in, it will always spit out the same output.
When we talk about a fully persistent data structure, all versions o f a structure
should be updateable, meaning that all possible operations you can d o on a
version can be performed on another. In early ”functional data s tructure” time,
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 33
it was common to ”cheat” with the structures and make the older ve rsions
”decay” over time by mutating the internals, making them slower and slower
compared to the newer versions. However, Rich Hickey decided tha t all the
versions of Clojure’s persistent structures should have the same performance
guarantees, regardless of which version of the structure you ar e using.
Vector
A vector is a one-dimensional growable array. C++’s std::vector and Java’s
java.util.ArrayList are examples of mutable implementations. There’s not much
more to it than that, really. A vector trie is a trie which represents a vector. It
doesn’t have to be persistent, but in our case, it is.
Trie
Triesareaspeciﬁctypeoftrees,andIthinkit’sbesttoshowtheac tualdiﬀerence
by explaining the more known trees ﬁrst.
In RB-trees and most other binary trees, mappings or elements ar e contained
in the interior nodes. Picking the right branch is done by comparing th e ele-
ment/key at the current node: If the element is lower than the nod e element,
we branch left, and if it is higher, we branch right. Leaves are usually null
pointers/nil, and doesn’t contain anything.
13
8 17
1 11 15 25
6 22 27nil
nil nilnil nil nil nil
nil nil nil nil
A RB-tree
The RB-tree above is taken from Wikipedia’s article on RB-trees. I’m n ot going
to explain how those work in detail, but let us take a tiny example on how we
check if 22 is contained in the RB-tree:
We start at the root, 13, and compare it with 22.
As 13 < 22, we go right.
The new node has 17 in it, and compare it with 22.
As 17 < 22, we still go right.
The next node we’ve walked into is 25.
As 25 > 22, we go left.
The next node is 22, so we know that 22 is contained in the tree.
If you want a good explanation on how RB-trees work, I would recom mend
Julienne Walker’s Red Black Tree Tutorial.
34 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
A trie, on the other hand, has all the values stored in its leaves. Pick ing the
right branch is done by using parts of the key as a lookup. Conseque ntly, a trie
may have more than two branches. In our case, we may have as man y as 32!
a b
a c a b
5 7 8 3
A trie
An example of a general trie is illustrated in the ﬁgure above. That sp eciﬁc trie
is a map: It takes a string of length two, and returns an integer rep resented by
that string if it exists in the trie. ac has the value 7, whereas ba has t he value
8. Here’s how the trie works:
For strings, we split the string into characters. We then take the ﬁ rst character,
ﬁnd the edge represented by this value, and walk down that edge. I f there is
no edge for that value, we stop, as it is not contained in the trie. If n ot, we
continue with the second character, and so on. Finally, when we are done, we
return the value if it exists.
As an example, consider ac. We do as follows:
We split ac up into [a, c], and start at the root node.
We check if there is an edge in the node for a,
and there is: We follow it.
We check if there is an edge in the node for c,
and there is. We follow that as well.
We have no more characters left, which means the current node contains
our value, 7. We therefore return 7.
Clojure’s Persistent Vector is a trie where the indices of elements ar e used as
keys. But, as you may guess, we must split up the index integers in so me way.
To split up integers, we either use digit partitioning or its faster sibling , bit
partitioning.
Digit Partitioning
Digit partitioning means that we split up the key into digits, which we the n use
as a basis for populating a trie. For instance, we can split up the key 9 128 to
[9, 1, 2, 8], and put an element into a trie based on that. We may have t o pad
with zeroes at the front of the list, if the depth of the trie is larger t han the size
of the list.
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 35
We can also use whatever base we would like, not just base 10. We wou ld then
have to convert the key to the base we wanted to use, and use the digits from
the conversion. As an example, consider 9128 yet again. 9128 is 354 20 in base
7, so we would have to use the list [3, 5, 4, 2, 0] for lookup/insertion in the trie.
9457
0123456
0123456
0123456
0123456
0123456
3 5 4 2 0 Digit
Visualization of the 35420 lookup.
The trie (laying sideways, without the edges and nodes we’renot walk ing)above
shows how we traverse a digit-partitioned trie: We pick the most sign iﬁcant
digit, in this case 3, and walk that speciﬁc branch. We continue with th e second
most signiﬁcant digit in the same manner, until we have no digits left. W hen
we’ve walked the last branch, the object we’re standing with the ﬁrs t object in
the rightmost array in this case is the object we wanted to look up.
Implementing such a lookup scheme is not too hard, if you know how to ﬁnd the
digits. Here’s a Java version where everything not related to lookup is stripped
away:
public class DigitTrie {
public static final int RADIX = 7;
// Array of objects. Can itself contain an array of objects.
Object[] root;
// The maximal size/length of a child node (1 if leaf node)
int rDepth; // equivalent to RADIX ** (depth - 1)
public Object lookup(int key) {
Object[] node = this.root;
// perform branching on internal nodes here
for (int size = this.rDepth; size > 1; size /= RADIX) {
node = (Object[]) node[(key / size) % RADIX];
// If node may not exist, check if it is null here
}
// Last element is the value we want to lookup, return it.
36 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
return node[key % RADIX];
}
}
The rDepth value represents the maximal size of a child of the root n ode: A
number with n digits will have n to the power of RADIX possible values, a nd
we must be able to put them all in the trie without having collisions.
In the for loop within the lookup method, the value size represents t he maximal
size a child of the current node can have. For each child we go over, t hat size is
decremented by the branching factor, i.e. the radix or base of the digit trie.
The reason we’re performing a modulo operation on the result is to ign ore the
more signiﬁcant digits digits we’ve branched on earlier. We could poten tially
remove the higher digit from the key every time we branch into a child, but the
code would be a tiny bit more complicated in that case. Bit Partitioning
Digit-partitioned tries would generally have to do a couple of integer d ivisions
and modulo operations. Doing this is on every branch we must take is a bit
time consuming. We would therefore like to speed this part up if it is pos sible.
So, as you may guess, bit-partitioned tries are a subset of the digit -partitioned
tries. All digit-partitioned tries in a base which is a power of two (2, 4, 8, 16,
32, etc) can be turned into bit-partitioned ones. With some knowled ge of bit
manipulation, we can remove those costly arithmetic operations.
Conceptually, it works in the same way as digit partitioning does. Howe ver,
instead of splitting the key into digits, we split it into chunks of bits with some
predeﬁned size. For 32-way branching tries, we need 5 bits in each p art, and for
4-way branching tries, we need 2. In general, we need as many bits a s the size
of our exponent.
So, why is this faster? By using bit tricks, we can get rid ofboth integ er division
and modulo. If power is two to the power of n, we can use that
x / power == x >>> n and
x % power == x & (power - 1).
These formulas are just identities related to how integers are repr esented inter-
nally, namely as sequences of bits.
If we use this result and combine it with the previous implementation, w e end
up with the following code:
public class BitTrie {
public static final int BITS = 5,
WIDTH = 1 << BITS, // 2^5 = 32
MASK = WIDTH - 1; // 31, or 0x1f
// Array of objects. Can itself contain an array of objects.
Object[] root;
2.3. UNDERSTANDING PERSISTENT VECTORS (JEAN LORANGE) 37
// BITS times (the depth of this trie minus one).
int shift;
public Object lookup(int key) {
Object[] node = this.root;
// perform branching on internal nodes here
for (int level = this.shift; level > 0; level -= BITS) {
node = (Object[]) node[(key >>> level) & MASK];
// If node may not exist, check if it is null here
}
// Last element is the value we want to lookup, return it.
return node[key & MASK];
}
}
This is more or less exactly what Clojure’s implementation is doing! See t hese
lines of the Clojure code to verify it; The only diﬀerence is that it perf orms
boundary checks and a tail check as well.
The important thing to note here is that we’ve not only changed the o perators,
but we’ve also replaced the rDepth value with a shift value. Instead o f storing
the whole value, we’re only storing the exponent. This makes us able t o use
bitshifting on the key, which we use in the (key ¿¿¿ level) part. The ot her
parts should be fairly straightforward to understand, given that one knows bit
operationswell. However,let’stakeanexamplefortheonesunfamilia rwithsuch
tricks. The explanation is quite thorough, so feel to skip parts you understand.
Say we have only have 2 bit partitioning (4-way branching) instead of 5 bits
(32-way) for visualization purposes. If we want to look up a value in a trie with
887 elements, we would have a shift equal to 8: All the children of the root node
can contain at most 1 ¡¡ 8 == 256 elements each. The width and mask is a lso
changed by the bit count: The mask will here be 3 instead of 31.
887
0123
0123
0123
0123
0123
8 6 4 2 0
2 1 3 0 2
10 01 11 00 10level
index
0...0
Visualization of the 626 lookup.
Say we want to look up the contents of the element with key 626. 626 in its
38 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
binary representation is 0000 0010 0111 0010. Following the algorith m, step by
step, both written above and within Clojure’s source code, we would have to do
the following:
node is set up to be the root note, and level is set up to be 8.
As level is over 0, we start the for loop.
We perform the operation key >>> level first. In this case,
this is 636 >>> 8, which cuts away the first 8 bits: We’re left
with 0000 0010 or 2 in decimal.
We perform the masking: (key >>> level) & MASK == 2 & 3. The
masking sets all the bits except the first two to zero. This
yields no difference here: We still have 2.
We replace the current node with its child at index 2.
We decrement level by 2, and set it to 6.
As level is over 0, we continue the for loop.
We again perform the operation key >>> level == 636 >>> 6. This
cuts away the last 6 bits, and we’re left with 0000 0010 01,
or 9 in decimal.
We perform the masking: (key >>> level) & MASK == 9 & 3,
or 1001 & 0011 in binary. This shaves off the top 10,
and we’re left with 01, or 1 in decimal.
We replace the current node with its child at index 1.
We decrement level by 2, and set it to 4.
As level is over 0, we continue the for loop
Same trick here again. 636 >>> 4 leaves us with the bits 0010 01 11.
The mask sets all but the 2 first bits to zero, and we’re left wi th 11.
We replace the current node with its child at index 0b11 == 3.
We decrement level by 2, and set it to 2.
As level is over 0, we continue the for loop
636 >>> 2 leaves us with 0010 0111 00.
The 2 first bits are 0b00 == 0.
We replace node with its first child, the one at index 0.
We decrement level by 2, and set it to 0.
As level is (finally) not over 0, we jump over the for loop.
We mask key with the mask, and get back the bits 10.
We return the contents at index 2 from node.
That is almost every single machine instruction you would have to perf orm to
lookup a value in a Clojure vector, with a depth of 5. Such a vector wo uld
contain between 1 and 33 million elements. The fact that the shifts an d masks
are some of the most eﬃcient operations on a modern CPU makes the whole
deal even better. From a performance perspective, the only ”pa in point” left
on lookups are the cache misses. For Clojure, that is handled prett y well by the
JVM itself.
And that’s how you do lookups in tries and in Clojure’s vector implement ation.
I would guess the bit operations are the hardest one to grok, ever ything else
is actually very straightforward. You just need a rough understa nding on how
tries work, and that’s it!
2.4. RED BLACK TREES 39
2.4 Red Black Trees
There is a special kind of binary search tree called a red-black tree. It has the
property that the longest path from the root to any leaf is no more than twice
as long as the shortest path from the root to any other leaf.
In order to guarantee this property we construct a tree such th at no two con-
nected nodes are red. The longest possible path will alternate red a nd black
nodes. The shortest path will be all black. Thus, the two paths will d iﬀer by at
most twice the length.
There are various rules deﬁned (see Okasaki [Oka98] p25 and Wikipe dia [Wiki]).
The Clojure implementation follows the Okasaki model, which we will use as
our background. Okasaki gives two rules that are always true in a p roperly
formed tree:
•No red node has a red child
•Every path from the root to an empty node contains the same numb er of
black nodes.
2.4.1 Persistence
Driscoll deﬁnes a persistent data structure as one that supports mutliple ver-
sions. A data structure that allows only a single version at a time is calle d
ephemeral [DSST89].
The basic technique of creating a persistent data structure is to m ake copies.
Howeverthis is expensive in time and space. Driscoll shows that data structures
can be deﬁned using linksbetween nodeswhere the nodes carry information
and the links connect the nodes. In such structures it is possible to only copy
nodes that are changed and update the links. Using this technique d oes not
modifythe olddatastructuresothelinkscanshareportionsofthe oldstructure.
Since the old structure is not changed it is also available at the same tim e as
the new structure, albeit with diﬀerent root nodes.
2.4.2 Persistent Red Black Trees
Okasaki has combined these two ideas to create Persistent Red Bla ck Trees.
Each modiﬁcation of the tree is done by making copies of changed nod es but
maintaining the red-black tree properties in the copy.
Since Clojure uses these persistent trees the actual tree is new c opy, not a
modiﬁed tree. We will now look into the details of how this is done.
40 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
2.4.3 Node Structure
First we haveto mirrorDriscoll’s concept ofa Node. This is createdin the code
with a new Java abstract class called Node. Okasaki requires that a node have
4 pieces of information, described as T (Color, left, this, right) . Thus
we ﬁnd that Nodes have the ability to manipulate their left and right me mbers.
Thus, for the left member we ﬁnd:
•left– to return the left Node
•addLeft– to add a left Node
•removeLeft – to remove a left Node
and for the right member we ﬁnd:
•left– to return the right Node
•addLeft– to add a right Node
•removeLeft – to remove a right Node
We have functions to set the color, blackenandredden. We can ask this node
for itskeyandval
Since every node has to maintain the Red-Black balance we have two m ethods,
balanceLeft andbalanceRight . Note that these methods always return a black
node as the root of the red-black tree is always black.
We also have a method to replace this node, the replacemethod.
Some of the methods are abstract which means that any class that implements
a Node has to implement the following methods:
•Node addLeft(Node ins);
•Node addRight(Node ins);
•Node removeLeft(Node del);
•Node removeRight(Node del);
•Node blacken();
•Node redden();
•Node replace(Object key, Object val, Node left, Node right);
Since the data structure is persistent we need to copy rather tha n modify the
structure. Each implementation of this abstract class has to hand le the details.
Node assumes that it will return a Black node from its balance operat ions.
Nodes in a Clojure PersistentTreeMap have one of 8 possible subtyp es of Node:
•Black - a black leaf node with a null value
•BlackVal - a black leaf node with a value
•BlackBranch - a black interior node with children and a null value
2.4. RED BLACK TREES 41
•BlackBranchVal - a black interior node with children and a value
•Red - a red leaf node with a null value
•RedVal - a red leaf node with a value
•RedBranch - a red interior node with children and a null value
•RedBranchVal - a red interior node with children and a value
(AMapEntry [527])
— PersistentTreeMap Node Class —
static abstract class Node extends AMapEntry{
final Object key;
Node(Object key){
this.key = key;
}
public Object key(){
return key;
}
public Object val(){
return null;
}
public Object getKey(){
return key();
}
public Object getValue(){
return val();
}
Node left(){
return null;
}
Node right(){
return null;
}
abstract Node addLeft(Node ins);
abstract Node addRight(Node ins);
abstract Node removeLeft(Node del);
abstract Node removeRight(Node del);
abstract Node blacken();
42 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
abstract Node redden();
Node balanceLeft(Node parent){
return black(parent.key, parent.val(), this, parent.rig ht());
}
Node balanceRight(Node parent){
return black(parent.key, parent.val(), parent.left(), t his);
}
abstract Node replace(Object key, Object val,
Node left, Node right);
}
———-
2.4.4 The Black Node implementation
Since the Node class is abstract it has to have certain methods implem ented in
the extending class.
We have two types of implementations, one for Red nodes and one fo r Black
nodes. Lets look at the Black node class. This is broken out into a set of
subclasses and we will drill down the chain for implemention Black nodes .
The class Blackextends node and implements the abstract methods of Node.
This basically involves making sure that the subtrees maintain their ba lance
under the operations of adding and deleting the subtrees.
Black nodes assume they are black but they implement a method to ch ange
their color. Since it is a copy operation it returns a new Red node as th e result
ofredden.
Black nodes are the default color for a node so the Black class does n ot have to
do anything special for color.
There are 4 possible Black node types
•Black - a black leaf node with a null value
•BlackVal - a black leaf node with a value
•BlackBranch - a black interior node with children and a null value
•BlackBranchVal - a black interior node with children and a value
A Black node is a leaf node with a null value. This is constructed by Pers is-
tentTreeMap’s [45] black method.
(Node [41])
— PersistentTreeMap Black Class —
2.4. RED BLACK TREES 43
static class Black extends Node{
public Black(Object key){
super(key);
}
Node addLeft(Node ins){
return ins.balanceLeft(this);
}
Node addRight(Node ins){
return ins.balanceRight(this);
}
Node removeLeft(Node del){
return balanceLeftDel(key, val(), del, right());
}
Node removeRight(Node del){
return balanceRightDel(key, val(), left(), del);
}
Node blacken(){
return this;
}
Node redden(){
return new Red(key);
}
Node replace(Object key, Object val, Node left, Node right) {
return black(key, val, left, right);
}
}
———-
A BlackVal node is a leaf node with a value. This is constructed by Pers istent-
TreeMap’s [45] black method.
(Black [42])
— PersistentTreeMap BlackVal Class —
static class BlackVal extends Black{
final Object val;
public BlackVal(Object key, Object val){
super(key);
this.val = val;
44 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
}
public Object val(){
return val;
}
Node redden(){
return new RedVal(key, val);
}
}
———-
Interior nodes of Clojure’s Red Black trees can have a value. A Black Branch
node is a leaf node with a null value and children, one of which could poss ibly
be null. This is constructed by PersistentTreeMap’s [45] black metho d.
(Black [42])
— PersistentTreeMap BlackBranch Class —
static class BlackBranch extends Black{
final Node left;
final Node right;
public BlackBranch(Object key, Node left, Node right){
super(key);
this.left = left;
this.right = right;
}
public Node left(){
return left;
}
public Node right(){
return right;
}
Node redden(){
return new RedBranch(key, left, right);
}
}
———-
A BlackBranchVal node is a leaf node with a value and children, one of w hich
2.4. RED BLACK TREES 45
could possibly be null. This is constructed by PersistentTreeMap’s [45 ] black
method.
(BlackBranch [44])
— PersistentTreeMap BlackBranchVal Class —
static class BlackBranchVal extends BlackBranch{
final Object val;
public BlackBranchVal(Object key, Object val,
Node left, Node right){
super(key, left, right);
this.val = val;
}
public Object val(){
return val;
}
Node redden(){
return new RedBranchVal(key, val, left, right);
}
}
———-
2.4.5 Constructing a Black Node
We can construct a new black node given 4 parameters:
•key – the TreeMap key
•val – the value stored in the TreeMap for this key
•left – a Node, possibly null
•right – a Node, possibly null
If both of the children are null we must be constructing a leaf node. If the value
is null we need only construct a naked Blacknode, otherwise we construct a
BlackVal node and store both the key and the value.
If either of the children exist but have no value for this node then co nstruct a
BlackBranch internal tree node pointing at the children.
If we have all four parameters then we have an internal node that also has a
value associated with it. Save the value and the children in a BlackBranchVal
node.
— PersistentTreeMap black method —
46 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
static Black black(Object key, Object val, Node left, Node r ight){
if(left == null && right == null)
{
if(val == null)
return new Black(key);
return new BlackVal(key, val);
}
if(val == null)
return new BlackBranch(key, left, right);
return new BlackBranchVal(key, val, left, right);
}
———-
2.4.6 The Red Node implementation
The Red Node class diﬀers from the Black node in many ways. In partic u-
lar, most of the operations return a new Red object whereas the B lack node
implementation balances the subtrees.
Black nodes are the default color for a node so the Red class has to r eturn Red
nodes for most operations.
There are 4 possible Red node types
•Red - a black leaf node with a null value
•RedVal - a black leaf node with a value
•RedBranch - a black interior node with children and a null value
•RedBranchVal - a black interior node with children and a value
A Red node is a leaf node with a null value. This is constructed by Persis tent-
TreeMap’s [50] red method.
(Node [41])
— PersistentTreeMap Red Class —
static class Red extends Node{
public Red(Object key){
super(key);
}
Node addLeft(Node ins){
return red(key, val(), ins, right());
}
Node addRight(Node ins){
return red(key, val(), left(), ins);
}
2.4. RED BLACK TREES 47
Node removeLeft(Node del){
return red(key, val(), del, right());
}
Node removeRight(Node del){
return red(key, val(), left(), del);
}
Node blacken(){
return new Black(key);
}
Node redden(){
throw new UnsupportedOperationException("Invariant vio lation");
}
Node replace(Object key, Object val, Node left, Node right) {
return red(key, val, left, right);
}
}
———-
A RedVal node is a leaf node with a value. This is constructed by Persis tent-
TreeMap’s [50] red method.
(Red [46])
— PersistentTreeMap RedVal Class —
static class RedVal extends Red{
final Object val;
public RedVal(Object key, Object val){
super(key);
this.val = val;
}
public Object val(){
return val;
}
Node blacken(){
return new BlackVal(key, val);
}
}
———-
48 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
Interior nodes of Clojure’s Red Black trees can have a value. A RedB ranch
node is a leaf node with a null value and children, one of which could poss ibly
be null. This is constructed by PersistentTreeMap’s [50] red method .
(Red [46])
— PersistentTreeMap RedBranch Class —
static class RedBranch extends Red{
final Node left;
final Node right;
public RedBranch(Object key, Node left, Node right){
super(key);
this.left = left;
this.right = right;
}
public Node left(){
return left;
}
public Node right(){
return right;
}
Node balanceLeft(Node parent){
if(left instanceof Red)
return red(key, val(), left.blacken(),
black(parent.key, parent.val(),
right, parent.right()));
else if(right instanceof Red)
return red(right.key, right.val(),
black(key, val(), left, right.left()),
black(parent.key, parent.val(),
right.right(), parent.right()));
else
return super.balanceLeft(parent);
}
Node balanceRight(Node parent){
if(right instanceof Red)
return red(key, val(),
black(parent.key, parent.val(),
parent.left(), left),
right.blacken());
else if(left instanceof Red)
return red(left.key, left.val(),
black(parent.key, parent.val(),
2.4. RED BLACK TREES 49
parent.left(), left.left()),
black(key, val(), left.right(), right));
else
return super.balanceRight(parent);
}
Node blacken(){
return new BlackBranch(key, left, right);
}
}
———-
A RedBranchVal node is a leaf node with a value and children, one of wh ich
could possibly be null. This is constructed by PersistentTreeMap’s [50 ] red
method.
(RedBranch [48])
— PersistentTreeMap RedBranchVal Class —
static class RedBranchVal extends RedBranch{
final Object val;
public RedBranchVal(Object key, Object val, Node left, Nod e right){
super(key, left, right);
this.val = val;
}
public Object val(){
return val;
}
Node blacken(){
return new BlackBranchVal(key, val, left, right);
}
}
———-
2.4.7 Constructing a Red Node
We can construct a new red node given 4 parameters:
•key – the TreeMap key
•val – the value stored in the TreeMap for this key
•left – a Node, possibly null
•right – a Node, possibly null
50 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
If both of the children are null we must be constructing a leaf node. If the
value is null we need only construct a naked Rednode, otherwise we construct
aRedValnode and store both the key and the value.
If either of the children exist but have no value for this node then co nstruct a
RedBranch internal tree node pointing at the children.
If we have all four parameters then we have an internal node that also has a
value associated with it. Save the value and the children in a RedBranchVal
node.
— PersistentTreeMap red method —
static Red red(Object key, Object val, Node left, Node right ){
if(left == null && right == null)
{
if(val == null)
return new Red(key);
return new RedVal(key, val);
}
if(val == null)
return new RedBranch(key, left, right);
return new RedBranchVal(key, val, left, right);
}
———-
2.4.8 Okasaki’s balance cases
Okasaki distinguishes 4 cases of balancing. It turns out that all fo ur cases
balance to the same tree, which is hardly a surprise given the constr aints on the
red-black alternation.
ML[Wiki1,Har05]isafunctionalprogramminglanguageandisusedbyO kasaki
to express his tree transformations.
Each case shows the ML code and the associated diagram. The ML co de rep-
resents a node as a 4-tuple of type T. Thus we see a node as
Type ( Color, leftnode, thisnode, rightnode )
so we can read the ﬁrst case as:
Node ( Black,
Node ( Red ,
Node ( Red, Node a, Node X, Node b ),
Node Y,
Node c
)
2.4. RED BLACK TREES 51
Node Z
Node d
)
Case 1: (B,T (R,T (R,a,x,b),y,c),z,d) = T (R,T (B,a,x,b),y,T (B,c,z,d))
Z
Y
X
abcd=>Y
X
abZ
cd
Case 2: (B, T (R,a,x,T (R,b,y,c)),z,d) = T (R,T (B,a,x,b),y,T (B,c,z,d))
Z
X
aY
bcd=>Y
X
abZ
cd
52 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
Case 3: (B,a,x,T (R,T (R,b,y,c),z,d)) = T (R,T (B,a,x,b),y,T (B,c,z,d))
X
aZ
Y
bcd=>Y
X
abZ
cd
Case 4: (B,a,x,T (R,b,y,T (R,c,z,d))) = T (R,T (B,a,x,b),y,T (B,c,z,d))
X
aY
bA
cd=>Y
X
abZ
cd
2.4.9 Deleting a Node
Here we are being asked to remove the Node del. This request is either a call to
a black node’s [42] removeRight method or PersistentTreeMap’s [1000] remove
method.
— PersistentTreeMap balanceRightDel method —
static Node balanceRightDel(Object key, Object val,
2.4. RED BLACK TREES 53
Node left, Node del){
if(del instanceof Red)
return red(key, val, left, del.blacken());
else if(left instanceof Black)
return leftBalance(key, val, left.redden(), del);
else if(left instanceof Red && left.right() instanceof Bla ck)
return red(left.right().key, left.right().val(),
leftBalance(left.key, left.val(),
left.left().redden(),
left.right().left()),
black(key, val, left.right().right(), del));
else
throw new UnsupportedOperationException("Invariant vio lation");
}
———-
— PersistentTreeMap balanceLeftDel method —
static Node balanceLeftDel(Object key, Object val,
Node del, Node right){
if(del instanceof Red)
return red(key, val, del.blacken(), right);
else if(right instanceof Black)
return rightBalance(key, val, del, right.redden());
else if(right instanceof Red && right.left() instanceof Bl ack)
return red(right.left().key, right.left().val(),
black(key, val, del, right.left().left()),
rightBalance(right.key, right.val(),
right.left().right(),
right.right().redden()));
else
throw new UnsupportedOperationException("Invariant vio lation");
}
———-
2.4.10 Clojure’s balance cases
We ﬁnd the leftBalance handling the case where a red node has a red node as
its left child. There are three cases.
Case 1: The left child of a red node is red. We return new nodes X, Y, a nd Z
where
•X – Node ( Red,
•Y
•Z – Node ( Black,
54 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
A
B/Bullet=>X
ZZ
Case 2: The right child of a red node is red. We rewrite that as:
N
/BulletB=>new
ZZ
Case 3: Both children of a red node are black. Rewrite the node black .
N
BC=>A
BC
— PersistentTreeMap leftBalance method —
static Node leftBalance(Object key, Object val,
Node ins, Node right){
if(ins instanceof Red && ins.left() instanceof Red)
return red(ins.key, ins.val(),
ins.left().blacken(),
black(key, val, ins.right(), right));
else if(ins instanceof Red && ins.right() instanceof Red)
return red(ins.right().key, ins.right().val(),
black(ins.key, ins.val(),
ins.left(), ins.right().left()),
black(key, val, ins.right().right(), right));
else
return black(key, val, ins, right);
}
———-
— PersistentTreeMap rightBalance method —
2.5. IMMUTABLE DATA STRUCTURES 55
static Node rightBalance(Object key, Object val, Node left , Node ins){
if(ins instanceof Red && ins.right() instanceof Red)
return red(ins.key, ins.val(),
black(key, val, left, ins.left()),
ins.right().blacken());
else if(ins instanceof Red && ins.left() instanceof Red)
return red(ins.left().key, ins.left().val(),
black(key, val, left, ins.left().left()),
black(ins.key, ins.val(),
ins.left().right(), ins.right()));
else
return black(key, val, left, ins);
}
———-
2.4.11 Replacing a Node
— PersistentTreeMap replace method —
Node replace(Node t, Object key, Object val){
int c = doCompare(key, t.key);
return t.replace(t.key,
c == 0 ? val : t.val(),
c < 0 ? replace(t.left(), key, val) : t.left(),
c > 0 ? replace(t.right(), key, val) : t.right());
}
———-
[1000] PersistentTreeMap implements several subclasses to supp ort the interop-
erability with the rest of Clojure. These will not be explained here. Re fer to the
othersectionsofthisdocumentformoredetails. Inparticular,se e[103]Iterators
for methods of iterating across keys and values. See [60] Seqs for information
about manipulating sequences over tree maps.
2.5 Immutable Data Structures
2.6 Bit-Partitioned Hash Tries
A trie is a data structure that exploits the fact that a preﬁx or suﬃ x has some
regular pattern[Bag00]. For instance, credit card numbers have a ﬁxed format.
We can look at the set of 16 digit credit card numbers which have the p attern
AAAA-BBBB-CCCC-DDDD. Given this sequence of 4 digit ﬁelds we can c reate
a trie data structure for fast lookup.
56 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
If we created a tree structure where the ﬁrst level of lookup was the ﬁrst 4
digits AAAA we would have a maximum of 9999 possible ﬁrst level branch es.
If the second layer of the tree were based on BBBB then it would also have a
branching factor of 9999. We eventually get a tree at most 4 layers deep that
handle all 1016 possible values.
Alternatively we can reduce the fan-out by choosing 2 digits, so AA g ives a
fan-out of 99 and this happens at each level. Now the tree is 8 layers deep in
order to contain all possible nodes.
Clojure has chosen a strategy based a bit pattern. So if we look at t he bits in
groups of ﬁve we get this kind of a trie:
2.6. BIT-PARTITIONED HASH TRIES 57
GGFFFFFEEEEEDDDDDCCCCCBBBBBAAAAA
A
B
xxB
C
xD
xxxx B
xC
xxC
xxxxx
Notice that the trie has a fan-out of 25or 32 at each level except the last. To
contain all possible 32 bit values requires a trie of at most depth 7. Th is means
that a lookup will take at most 7 possible fetches. For any reasonab le set of
numbers this is a near constant time lookup.
One advantage of this scheme is the ability to mask out a subset of th e word,
fully right-shift the bits, anduse the resultingnumber asan index int o the array.
Any masked oﬀ value has to be between 0 and 31 because the mask is 5 bits
wide.
The 5 bit mask function is part of [969] PersistentHashMap. Given a number of
bits to shift right (a multiple of 5 appears to be used everywhere) th is routine
returns a number between 0 and 31.
— PersistentHashMap mask method —
static int mask(int hash, int shift){
//return ((hash << shift) >>> 27);// & 0x01f;
return (hash >>> shift) & 0x01f;
}
———-
This is used in the ArrayNode class. For instance, the ﬁndmethod
58 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
•uses mask to get an index from 5 bits
•uses that value to index into an array
•if that entry is not set we didn’t ﬁnd it
•shift 5 more bits right and search again.
— ArrayNode ﬁnd Object method —
public Object find(int shift, int hash, Object key,
Object notFound){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null)
return notFound;
return node.find(shift + 5, hash, key, notFound);
}
———-
Note that ArrayNode is a container class so it is actually recursively c alling the
ﬁndmethod on whatever was found in that container slot. It might be an ything
that implements the INode interface: (Serializable [1723])
— PersistentHashMap INode interface —
static interface INode extends Serializable {
INode assoc(int shift, int hash, Object key,
Object val, Box addedLeaf);
INode without(int shift, int hash, Object key);
IMapEntry find(int shift, int hash, Object key);
Object find(int shift, int hash, Object key, Object notFoun d);
ISeq nodeSeq();
INode assoc(AtomicReference<Thread> edit, int shift, int hash,
Object key, Object val, Box addedLeaf);
INode without(AtomicReference<Thread> edit, int shift, i nt hash,
Object key, Box removedLeaf);
}
———-
There are 3 classes that implement INode.
•[955] ArrayNode
2.6. BIT-PARTITIONED HASH TRIES 59
•[959] BitmapIndexedNode
•[965] HashCollisionNode
2.6.1 Lists
2.6.2 Vectors
2.6.3 Hashmaps
Maps are associationsof keywordsand data. Hashmaps are untyp ed data struc-
tures, as opposed to Records which carry their type.
>(def tim {:fname ”Tim”
:lname ”Daly”
:address {:street ”Long Ridge Road”
:city ”Pittsburgh”
:state ”PA”
:zip 15022 }})
#’user/tim
We can look up by keyword since keywords are
>(:lname tim)
”Daly”
We can nest access using the “thread ﬁrst” operator which threa ds arbitrary
pieces of code (as opposed to “..” which threads Java classes).
>(->tim :address :city)
”Pittsburgh”
We can create a new object with a change to a ﬁeld.
>(assoc tim :fname “Timothy”)
{:lname ”Daly”,
:address {:state ”PA”,
:city ”Pittsburgh”,
:street ”Long Ridge Road”,
:zip 15022 },
:fname ”Timothy” }
Theupdate-in function threads into a nested data structure and then applies
a function, in this case the incfunction. This reduces the need to create inter-
mediate classes.
60 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
>(update-in tim [:address :zip] inc)
{:lname ”Daly”,
:address {:state ”PA”,
:city ”Pittsburgh”,
:street ”Long Ridge Road”,
:zip 15023 },
:fname ”Tim” }
2.6.4 Seqs
(ASeq [571])
— PersistentTreeMap Seq Class —
static public class Seq extends ASeq{
final ISeq stack;
final boolean asc;
final int cnt;
public Seq(ISeq stack, boolean asc){
this.stack = stack;
this.asc = asc;
this.cnt = -1;
}
public Seq(ISeq stack, boolean asc, int cnt){
this.stack = stack;
this.asc = asc;
this.cnt = cnt;
}
Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt) {
super(meta);
this.stack = stack;
this.asc = asc;
this.cnt = cnt;
}
static Seq create(Node t, boolean asc, int cnt){
return new Seq(push(t, null, asc), asc, cnt);
}
static ISeq push(Node t, ISeq stack, boolean asc){
while(t != null)
{
stack = RT.cons(t, stack);
t = asc ? t.left() : t.right();
}
return stack;
2.7. RECORDS 61
}
public Object first(){
return stack.first();
}
public ISeq next(){
Node t = (Node) stack.first();
ISeq nextstack =
push(asc ? t.right() : t.left(), stack.next(), asc);
if(nextstack != null)
{
return new Seq(nextstack, asc, cnt - 1);
}
return null;
}
public int count(){
if(cnt < 0)
return super.count();
return cnt;
}
public Obj withMeta(IPersistentMap meta){
return new Seq(meta, stack, asc, cnt);
}
}
———-
2.7 Records
Records carry their type, in this case “Person”, as opposed to ha shmaps which
are untyped data structures.
>(defrecord Person [fname lname address])
user.Person
and in this case “Address”
>(defrecord Address [street city state zip])
user.Address
We can create a Var reference to a new record and set the addres s ﬁeld to be a
new Address record.
62 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
>(def tim
(Person. ”Tim” ”Daly”
(Address. ”Long Ridge Road” ”Pittsburgh” ”PA” 15022)))
#’user/tim
Record ﬁeld names are functions so we can use them as accessors.
>(:lname tim)
”Daly”
And we can access them with the ”thread ﬁrst” operator which thr eads through
the set of accessors and then applies the function, in this case, th eincfunction.
This issimilarto the “..” operatorexcept that it appliesto anykind ofop erator,
not just Java operators.
>(->tim :address :city)
”Pittsburgh”
>(assoc tim :fname ”Timothy”)
#:user.Person {:fname ”Timothy”,
:lname ”Daly”,
:address #:user.Address {
:street ”Long Ridge Road”,
:city ”Pittsburgh”,
:state ”PA”,
:zip 15022 }
>(update-in tim [:address :zip] inc)
#:user.Person {:fname ”Tim”,
:lname ”Daly”,
:address #:user.Address {
:street ”Long Ridge Road”,
:city ”Pittsburgh”,
:state ”PA”,
:zip 15023 }
2.8 Java Interoperability
2.8.1 Language primitives
Atomic data types [Hal11]
2.8. JAVA INTEROPERABILITY 63
type Clojure Java
string ”foo” String
character \f Character
regular expression #"fo*" Pattern
integer 42 Long
big integer 42N BigInteger
double 3.14159 Double
big decimal 3.141519M BigDecimal
boolean true Boolean
nil nil null
ratio 22/7 N/A
symbol foo N/A
keyword :foo ::foo N/A
Data literals
These data structures can contain anything of any type.
type property example
list singly-linked, insert at front (1 2 3)
vector indexed, insert at rear [1 2 3]
map key-value pairs {:a 10 :b 20}
set key #{1 2 3}
People make claims that Lisp has no syntax ...A more accurate thing to say
is that Lisp has the syntax of its data structures and that syntax has been
built upon to write code.
–Stuart Halloway “Clojure-Java Interp (Jan 19, 2011)”
Function Calling
(println "Hello Wikileaks")
This is a list data structure with a ﬁrst element of a Symbol and a seco nd
element of a String. The ﬁrst element is the function to be called and t he
second element is the argument to that function.
Function Deﬁnition
(defn funname
"documentation string of the function"
[vector of arguments]
(function arg1 ... argN))
This is a list data structure with the elements:
64 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
•defn, a Symbol, used as a function to deﬁne a function
•funname, a Symbol, used as the name of the new function
•docstring, a String, used to document the function
•argvec, a Vector of arguments to the new function
•function, a Symbol, used as the name of some other function to call
•arg1...argN, a list of arguments to the function
For example,
>(defn say ”says the name and age” [name age] (str name ” ” age))
#’user/say
Thedefn function createsthe newfunction called”say”whichtake s2arguments
and returns a string with the two arguments separated by a space as in:
>(say ”Tim” 24)
”Tim 24”
You can add meta information to your programs to improve the perf ormance or
simplify the runtime lookup of classes. The syntax for metadata is a S ymbol or
hashmap preﬁxed by a caret ^. For example, the say function returns a String
so we could write
(defn ^String say
"says the name and age"
[name age]
(str name " " age))
If the item after the caret is a single Symbol it is expanded into a hash map with
the keyword :tag and the Symbol. In our case, this is {:tag String}
2.8.2 Clojure calling Java
Java “new” in Clojure
new MyClass("arg1")
becomes
(MyClass. "arg1")
Accessing a Java static member
Math.PI
becomes
2.9. RECURSION 65
Math/PI
Accessing instance members
SinceClojureshifts the focus fromthe objectto the function wec all, the Clojure
syntaxfavorsputtingthefunctionattheheadofthelist, theso- called“function”
position.
rnd.nextInt()
becomes
(.nextInt rnd)
Chaining function calls
person.getAddress().getZip()
becomes
(.. person getAddress getZip)
Thedotomacro uses the ﬁrst form to create an object upon which subsequ ent
method calls can be applied in series.
(doto (JFrame. "argument")
(.add (proxy [JPanel] []))
(.setSize 640 480)
(.setVisible true))
2.9 Recursion
2.10 Argument Deconstruction
2.11 The Read-Eval-Print Loop
2.12 Special Forms
2.13 Reader Macros
2.14 Namespaces
Namespaces map to java packages.
66 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
2.15 Dynamic Comopilation
2.16 Ahead-Of-Time Comopilation
2.17 Lazy Evaluation
2.18 Metadata
2.19 Concurrency
2.20 Identity and State
Identity is a logical entity associated with a series of causally related values,
called states, over time. Identity is not a name but can be named (e.g . my
“Mom” is not your mom). Identity can be a composite object (e.g. th e New
York Yankees). Programs that are processes need identity. [Hic1 0]
State is the value of an identity at a given time. Variables are not suﬃc ient to
refertoastatebecausestatecouldbecomposite. Thisleadstoas ituationwhere,
at a given time, the variable does not refer to a properly formed sta te but refers
to inconsistent composite information. There is a lack of time coordin ation.
In order to properly capture state we need to incorporate some n otion of time.
Once we have time as a marker we can talk about state at a particular time.
Since Clojure deals with immutable objects that implies that a changed state
must be a diﬀerent object since things don’t change in place.
Since state is a combination of information and time it is possible for mult iple
observers to query the state. Each will see a consistent view of th e information
(the value) based on the time of the observation.
Clojure manages state by creating an intermediate object called a r eference.
The reference object has atomic semantics. Changing a referenc e happens as
an all-or-nothing event. References are essentially a pointer to a s tateful object.
The referencepoints atthe currentstate. When a newstate isbe ing constructed
as a function of the old state there is no way to reference it until th e function
completes. At that time the reference is atomically updated and the new state
can be observed as a wholly-formed object. This becomes the new s tate which
is a function of the current time and the new information. Observer s of the
prior state will still see the old state unchanged.
There are four kinds of reference objects in Clojure which we will dis cuss in
detail below. These are vars,atoms,refs, andagents.
2.21. SOFTWARE TRANSACTIONAL MEMORY 67
2.21 Software Transactional Memory
2.22 Symbols
Internally, a Clojure Symbol contains four pieces of data
•nsan interned string of the namespace for this symbol
•namea interned string for this symbol name
•hasha hash of the name and the namespace
•metameta data associated with this Symbol
— Symbol private data —
//these must be interned strings!
final String ns;
final String name;
final int hash;
final IPersistentMap _meta;
———-
Java’s String class has an internmethod [Ora11] which returns a canonical
representationforthe string object. The String classmaintains a pool ofstrings.
WhenString’s internmethod isinvokedthepoolissearchedforan equalsmatch.
If the searchsucceeds then a reference to the stored string is r eturned, otherwise
the new string is added to the pool and a reference to this String ob ject is
returned. Thus, the String nameof a Symbol is a unique reference.
As pointed out in [Web11], Clojure creates a new Symbol for each oc curence it
reads. The Symbols are not unique despite having equal names:
node2: clj
Clojure 1.3.0-alpha4
user=> (identical? ’a ’a)
false
user=> (= ’a ’a)
true
user=> (identical? (clojure.lang.Symbol/intern "a")
(clojure.lang.Symbol/intern "a"))
false
— Symbol intern method —
static public Symbol intern(String nsname){
int i = nsname.lastIndexOf(’/’);
68 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
if(i == -1 || nsname.equals("/"))
return new Symbol(null, nsname.intern());
else
return
new Symbol(nsname.substring(0, i).intern(),
nsname.substring(i + 1).intern());
}
———-
A new Symbol is automatically prepended with its namespace.
user=> (def a 1)
#’user/a
— Symbol intern method 2 —
static public Symbol intern(String ns, String name){
return new Symbol(ns == null ? null : ns.intern(), name.inte rn());
}
———-
Since the namespace was null the current namespace userwas used. We can
see this from the toString result.
— Symbol method toString —
public String toString(){
if(ns != null)
return ns + "/" + name;
return name;
}
———-
Since Symbols optionally include a namespace user/a, which includes a names-
pace, and awhich does not include a namespace, are diﬀerent symbols but they
name the same variable.
user=> (= ’user/a ’a)
false
user=> (def a 1)
#’user/a
user=> user/a
1
2.23. THE LISP READER 69
user=> (def user/a 2)
#’user/a
user=> a
2
— Symbol method equals —
public boolean equals(Object o){
if(this == o)
return true;
if(!(o instanceof Symbol))
return false;
Symbol symbol = (Symbol) o;
//identity compares intended, names are interned
return name == symbol.name && ns == symbol.ns;
}
———-
2.23 The Lisp Reader
When the LispReader read function is invoked it reads each charact er as an
integer. The read function is parsing S-expressions so it skips white space and
fails if it does not get a complete S-expression. Numbers are handled specially
by the reader.
— LispReader read method —
static public Object read(PushbackReader r,
boolean eofIsError,
Object eofValue,
boolean isRecursive)
throws Exception{
try
{
for(; ;)
{
int ch = r.read();
while(isWhitespace(ch))
ch = r.read();
if(ch == -1)
70 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
{
if(eofIsError)
throw new Exception("EOF while reading");
return eofValue;
}
if(Character.isDigit(ch))
{
Object n = readNumber(r, (char) ch);
if(RT.suppressRead())
return null;
return n;
}
IFn macroFn = getMacro(ch);
if(macroFn != null)
{
Object ret = macroFn.invoke(r, (char) ch);
if(RT.suppressRead())
return null;
//no op macros return the reader
if(ret == r)
continue;
return ret;
}
if(ch == ’+’ || ch == ’-’)
{
int ch2 = r.read();
if(Character.isDigit(ch2))
{
unread(r, ch2);
Object n = readNumber(r, (char) ch);
if(RT.suppressRead())
return null;
return n;
}
unread(r, ch2);
}
String token = readToken(r, (char) ch);
if(RT.suppressRead())
return null;
return interpretToken(token);
}
}
catch(Exception e)
{
if(isRecursive || !(r instanceof LineNumberingPushbackR eader))
throw e;
2.23. THE LISP READER 71
LineNumberingPushbackReader rdr =
(LineNumberingPushbackReader) r;
//throw new Exception(String.format("ReaderError:(%d, 1) %s",
// rdr.getLineNumber(), e.getMessage()), e);
throw new ReaderException(rdr.getLineNumber(), e);
}
}
———-
2.23.1 Reader Syntax Macros
Almost every special character is handled by looking up the special f unction
associated with that character in the macrosarray:
— LispReader macros statement —
static IFn[] macros = new IFn[256];
———-
The default values are speciﬁed in the syntax macro table. These ar e all class
objects that implement the [774] IFn interface which requires that they have an
invokemethod.
For the special case of the #characterthere is a separatetable, the [84] Dispatch
MacroTable which readsthe next characterand calls anotherdispa tch function.
All of the special characters get their meaning from these tables.
By default the special syntax characters are
•"a [72] StringReader
•;a [74] CommentReader
•’a [74] WrappingReader(QUOTE)
•@a [74] WrappingReader(DEREF)
•^a [75] MetaReader
•‘a [76] SyntaxQuoteReader
•~a [79] UnquoteReader
•(a [80] ListReader
•)a [80] UnmatchedDelimiterReader
•[a [80] VectorReader
•]a [80] UnmatchedDelimiterReader
•{a [81] MapReader
•}a [80] UnmatchedDelimiterReader
•\a [81] CharacterReader
•%a [82] ArgReader
72 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
•#a [83] DispatchReader
— LispReader Syntax Macro Table —
macros[’"’] = new StringReader();
macros[’;’] = new CommentReader();
macros[’\’’] = new WrappingReader(QUOTE);
macros[’@’] = new WrappingReader(DEREF);//new DerefRead er();
macros[’^’] = new MetaReader();
macros[’‘’] = new SyntaxQuoteReader();
macros[’~’] = new UnquoteReader();
macros[’(’] = new ListReader();
macros[’)’] = new UnmatchedDelimiterReader();
macros[’[’] = new VectorReader();
macros[’]’] = new UnmatchedDelimiterReader();
macros[’{’] = new MapReader();
macros[’}’] = new UnmatchedDelimiterReader();
// macros[’|’] = new ArgVectorReader();
macros[’\\’] = new CharacterReader();
macros[’%’] = new ArgReader();
\getchunk{LispReader sharpsign macro statement}
———-
2.23.2 The String reader macro
(AFn [509])
— LispReader StringReader class —
public static class StringReader extends AFn{
public Object invoke(Object reader, Object doublequote)
throws Exception{
StringBuilder sb = new StringBuilder();
Reader r = (Reader) reader;
for(int ch = r.read(); ch != ’"’; ch = r.read())
{
if(ch == -1)
throw new Exception("EOF while reading string");
if(ch == ’\\’) //escape
{
ch = r.read();
if(ch == -1)
throw new Exception("EOF while reading string");
switch(ch)
{
case ’t’:
2.23. THE LISP READER 73
ch = ’\t’;
break;
case ’r’:
ch = ’\r’;
break;
case ’n’:
ch = ’\n’;
break;
case ’\\’:
break;
case ’"’:
break;
case ’b’:
ch = ’\b’;
break;
case ’f’:
ch = ’\f’;
break;
case ’u’:
{
ch = r.read();
if (Character.digit(ch, 16) == -1)
throw new Exception(
"Invalid unicode escape: \\u" + (char) ch);
ch =
readUnicodeChar((PushbackReader) r,ch,16,4,true);
break;
}
default:
{
if(Character.isDigit(ch))
{
ch =
readUnicodeChar(
(PushbackReader) r,ch,8,3,false);
if(ch > 0377)
throw new Exception(
"Octal escape sequence must be in range [0, 377].");
}
else
throw new Exception(
"Unsupported escape character: \\" + (char) ch);
}
}
}
sb.append((char) ch);
}
return sb.toString();
}
}
74 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
———-
2.23.3 The Comment reader macro
(AFn [509])
— LispReader CommentReader class —
public static class CommentReader extends AFn{
public Object invoke(Object reader, Object semicolon)
throws Exception{
Reader r = (Reader) reader;
int ch;
do
{
ch = r.read();
} while(ch != -1 && ch != ’\n’ && ch != ’\r’);
return r;
}
}
———-
2.23.4 The Wrapping reader macro
(AFn [509])
— LispReader WrappingReader class —
public static class WrappingReader extends AFn{
final Symbol sym;
public WrappingReader(Symbol sym){
this.sym = sym;
}
public Object invoke(Object reader, Object quote)
throws Exception{
PushbackReader r = (PushbackReader) reader;
Object o = read(r, true, null, true);
return RT.list(sym, o);
}
}
———-
2.23. THE LISP READER 75
2.23.5 The Meta reader macro
(AFn [509])
— LispReader MetaReader class —
public static class MetaReader extends AFn{
public Object invoke(Object reader, Object caret)
throws Exception{
PushbackReader r = (PushbackReader) reader;
int line = -1;
if(r instanceof LineNumberingPushbackReader)
line = ((LineNumberingPushbackReader) r).getLineNumber ();
Object meta = read(r, true, null, true);
if(meta instanceof Symbol || meta instanceof String)
meta = RT.map(RT.TAG_KEY, meta);
else if (meta instanceof Keyword)
meta = RT.map(meta, RT.T);
else if(!(meta instanceof IPersistentMap))
throw new IllegalArgumentException(
"Metadata must be Symbol,Keyword,String or Map");
Object o = read(r, true, null, true);
if(o instanceof IMeta)
{
if(line != -1 && o instanceof ISeq)
meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line) ;
if(o instanceof IReference)
{
((IReference)o).resetMeta((IPersistentMap) meta);
return o;
}
Object ometa = RT.meta(o);
for(ISeq s = RT.seq(meta); s != null; s = s.next()) {
IMapEntry kv = (IMapEntry) s.first();
ometa = RT.assoc(ometa, kv.getKey(), kv.getValue());
}
return ((IObj) o).withMeta((IPersistentMap) ometa);
}
else
throw new IllegalArgumentException(
"Metadata can only be applied to IMetas");
}
}
———-
76 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
2.23.6 The SyntaxQuote reader macro
(AFn [509])
— LispReader SyntaxQuoteReader class —
public static class SyntaxQuoteReader extends AFn{
public Object invoke(Object reader, Object backquote)
throws Exception{
PushbackReader r = (PushbackReader) reader;
try
{
Var.pushThreadBindings(
RT.map(GENSYM_ENV, PersistentHashMap.EMPTY));
Object form = read(r, true, null, true);
return syntaxQuote(form);
}
finally
{
Var.popThreadBindings();
}
}
static Object syntaxQuote(Object form) throws Exception{
Object ret;
if(Compiler.isSpecial(form))
ret = RT.list(Compiler.QUOTE, form);
else if(form instanceof Symbol)
{
Symbol sym = (Symbol) form;
if(sym.ns == null && sym.name.endsWith("#"))
{
IPersistentMap gmap =
(IPersistentMap) GENSYM_ENV.deref();
if(gmap == null)
throw new IllegalStateException(
"Gensym literal not in syntax-quote");
Symbol gs = (Symbol) gmap.valAt(sym);
if(gs == null)
GENSYM_ENV.set(
gmap.assoc(sym,
gs = Symbol.intern(null,
sym.name.substring(0, sym.name.length() - 1)
+ "__" + RT.nextID() + "__auto__")));
sym = gs;
}
else if(sym.ns == null && sym.name.endsWith("."))
{
Symbol csym =
Symbol.intern(null,
2.23. THE LISP READER 77
sym.name.substring(0, sym.name.length() - 1));
csym = Compiler.resolveSymbol(csym);
sym = Symbol.intern(null, csym.name.concat("."));
}
else if(sym.ns == null && sym.name.startsWith("."))
{
// Simply quote method names.
}
else
{
Object maybeClass = null;
if(sym.ns != null)
maybeClass = Compiler.currentNS().getMapping(
Symbol.intern(null, sym.ns));
if(maybeClass instanceof Class)
{
// Classname/foo ->
// package.qualified.Classname/foo
sym = Symbol.intern(
((Class)maybeClass).getName(), sym.name);
}
else
sym = Compiler.resolveSymbol(sym);
}
ret = RT.list(Compiler.QUOTE, sym);
}
else if(isUnquote(form))
return RT.second(form);
else if(isUnquoteSplicing(form))
throw new IllegalStateException("splice not in list");
else if(form instanceof IPersistentCollection)
{
if(form instanceof IPersistentMap)
{
IPersistentVector keyvals = flattenMap(form);
ret = RT.list(APPLY, HASHMAP,
RT.list(SEQ,
RT.cons(CONCAT, sqExpandList(keyvals.seq()))));
}
else if(form instanceof IPersistentVector)
{
ret = RT.list(APPLY, VECTOR,
RT.list(SEQ,
RT.cons(CONCAT,
sqExpandList(
((IPersistentVector) form).seq()))));
}
else if(form instanceof IPersistentSet)
{
ret = RT.list(APPLY, HASHSET,
78 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
RT.list(SEQ,
RT.cons(CONCAT,
sqExpandList(
((IPersistentSet) form).seq()))));
}
else if(form instanceof ISeq ||
form instanceof IPersistentList)
{
ISeq seq = RT.seq(form);
if(seq == null)
ret = RT.cons(LIST,null);
else
ret =
RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq)));
}
else
throw new UnsupportedOperationException(
"Unknown Collection type");
}
else if(form instanceof Keyword
|| form instanceof Number
|| form instanceof Character
|| form instanceof String)
ret = form;
else
ret = RT.list(Compiler.QUOTE, form);
if(form instanceof IObj && RT.meta(form) != null)
{
//filter line numbers
IPersistentMap newMeta =
((IObj) form).meta().without(RT.LINE_KEY);
if(newMeta.count() > 0)
return
RT.list(WITH_META, ret,
syntaxQuote(((IObj) form).meta()));
}
return ret;
}
private static ISeq sqExpandList(ISeq seq) throws Excepti on{
PersistentVector ret = PersistentVector.EMPTY;
for(; seq != null; seq = seq.next())
{
Object item = seq.first();
if(isUnquote(item))
ret = ret.cons(RT.list(LIST, RT.second(item)));
else if(isUnquoteSplicing(item))
ret = ret.cons(RT.second(item));
else
2.23. THE LISP READER 79
ret = ret.cons(RT.list(LIST, syntaxQuote(item)));
}
return ret.seq();
}
private static IPersistentVector flattenMap(Object form ){
IPersistentVector keyvals = PersistentVector.EMPTY;
for(ISeq s = RT.seq(form); s != null; s = s.next())
{
IMapEntry e = (IMapEntry) s.first();
keyvals = (IPersistentVector) keyvals.cons(e.key());
keyvals = (IPersistentVector) keyvals.cons(e.val());
}
return keyvals;
}
}
———-
2.23.7 The Unquote reader macro
(AFn [509])
— LispReader UnquoteReader class —
static class UnquoteReader extends AFn{
public Object invoke(Object reader, Object comma) throws E xception{
PushbackReader r = (PushbackReader) reader;
int ch = r.read();
if(ch == -1)
throw new Exception("EOF while reading character");
if(ch == ’@’)
{
Object o = read(r, true, null, true);
return RT.list(UNQUOTE_SPLICING, o);
}
else
{
unread(r, ch);
Object o = read(r, true, null, true);
return RT.list(UNQUOTE, o);
}
}
}
———-
80 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
2.23.8 The List reader macro
(AFn [509])
— LispReader ListReader class —
public static class ListReader extends AFn{
public Object invoke(Object reader, Object leftparen)
throws Exception{
PushbackReader r = (PushbackReader) reader;
int line = -1;
if(r instanceof LineNumberingPushbackReader)
line = ((LineNumberingPushbackReader) r).getLineNumber ();
List list = readDelimitedList(’)’, r, true);
if(list.isEmpty())
return PersistentList.EMPTY;
IObj s = (IObj) PersistentList.create(list);
// IObj s = (IObj) RT.seq(list);
if(line != -1)
return s.withMeta(RT.map(RT.LINE_KEY, line));
else
return s;
}
}
———-
2.23.9 The Unmatched Delimiter reader macro
(AFn [509])
— LispReader UnmatchedDelimiterReader class —
public static class UnmatchedDelimiterReader extends AFn {
public Object invoke(Object reader, Object rightdelim)
throws Exception{
throw new Exception("Unmatched delimiter: " + rightdelim) ;
}
}
———-
2.23.10 The Vector reader macro
(AFn [509])
— LispReader VectorReader class —
2.23. THE LISP READER 81
public static class VectorReader extends AFn{
public Object invoke(Object reader, Object leftparen)
throws Exception{
PushbackReader r = (PushbackReader) reader;
return LazilyPersistentVector
.create(readDelimitedList(’]’, r, true));
}
}
———-
2.23.11 The Map reader macro
(AFn [509])
— LispReader MapReader class —
public static class MapReader extends AFn{
public Object invoke(Object reader, Object leftparen)
throws Exception{
PushbackReader r = (PushbackReader) reader;
return RT.map(readDelimitedList(’}’, r, true).toArray( ));
}
}
———-
2.23.12 The Character reader macro
(AFn [509])
— LispReader CharacterReader class —
public static class CharacterReader extends AFn{
public Object invoke(Object reader, Object backslash)
throws Exception{
PushbackReader r = (PushbackReader) reader;
int ch = r.read();
if(ch == -1)
throw new Exception("EOF while reading character");
String token = readToken(r, (char) ch);
if(token.length() == 1)
return Character.valueOf(token.charAt(0));
else if(token.equals("newline"))
return ’\n’;
else if(token.equals("space"))
return ’ ’;
82 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
else if(token.equals("tab"))
return ’\t’;
else if(token.equals("backspace"))
return ’\b’;
else if(token.equals("formfeed"))
return ’\f’;
else if(token.equals("return"))
return ’\r’;
else if(token.startsWith("u"))
{
char c = (char) readUnicodeChar(token, 1, 4, 16);
if(c >= ’\uD800’ && c <= ’\uDFFF’) // surrogate code unit?
throw new Exception(
"Invalid character constant: \\u" +
Integer.toString(c, 16));
return c;
}
else if(token.startsWith("o"))
{
int len = token.length() - 1;
if(len > 3)
throw new Exception(
"Invalid octal escape sequence length: " + len);
int uc = readUnicodeChar(token, 1, len, 8);
if(uc > 0377)
throw new Exception(
"Octal escape sequence must be in range [0, 377].");
return (char) uc;
}
throw new Exception("Unsupported character: \\" + token);
}
}
———-
2.23.13 The Arg reader macro
(AFn [509])
— LispReader ArgReader class —
static class ArgReader extends AFn{
public Object invoke(Object reader, Object pct) throws Exc eption{
PushbackReader r = (PushbackReader) reader;
if(ARG_ENV.deref() == null)
{
return interpretToken(readToken(r, ’%’));
}
int ch = r.read();
2.24. READER DISPATCH MACROS 83
unread(r, ch);
//% alone is first arg
if(ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch) )
{
return registerArg(1);
}
Object n = read(r, true, null, true);
if(n.equals(Compiler._AMP_))
return registerArg(-1);
if(!(n instanceof Number))
throw new IllegalStateException(
"arg literal must be %, %& or %integer");
return registerArg(((Number) n).intValue());
}
}
———-
2.24 Reader Dispatch Macros
The [825] LispReader read function, when it encounters a #character indexes
into the [72] Syntax Macro Table to ﬁnd an entry initialized to a [83] Dis -
patchReader object.
— LispReader sharpsign macro statement —
macros[’#’] = new DispatchReader();
———-
A DispatchReader reads the next character and uses it as an index into the [84]
dispatchMacrosarray. The readerfunction associatedwith the m acrocharacter,
in this case, is a [85] VarReader. This gets assigned to fnand then calls the
invokemethod of the [85] VarReader class.
(AFn [509])
— LispReader DispatchReader class —
public static class DispatchReader extends AFn{
public Object invoke(Object reader, Object hash)
throws Exception{
int ch = ((Reader) reader).read();
if(ch == -1)
throw new Exception("EOF while reading character");
IFn fn = dispatchMacros[ch];
if(fn == null)
throw new Exception(
84 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
String.format("No dispatch macro for: %c", (char) ch));
return fn.invoke(reader, ch);
}
}
———-
The dispatchMacros array is deﬁned to be an array of IFn objects . The [774]
IFn interface requires that all implementations have to have an invokemethod,
which VarReader has.
— LispReader dispatchMacros statement —
static IFn[] dispatchMacros = new IFn[256];
———-
By default the special dispatch characters are:
•^a [75] MetaReader, for attaching meta information to objects
•’a [85] VarReader, returns a Var object
•"a [85] RegexReader, returns a regular expression
•(a [86] FnReader, returns a function object
•{a [87] SetReader, returns a set object
•=a [87] EvalReader, returns an evaled object
•!a [74] CommentReader, returns a commented object
•<a [89] UnreadableReader, returns an unreadable object
•_a [89] DiscardReader, returns a discarded object
These are all deﬁned in this table and they are explained in the following sec-
tions.
— LispReader Dispatch Macro Table —
dispatchMacros[’^’] = new MetaReader();
\getchunk{LispReader dispatchMacros VarReader statemen t}
dispatchMacros[’"’] = new RegexReader();
dispatchMacros[’(’] = new FnReader();
dispatchMacros[’{’] = new SetReader();
dispatchMacros[’=’] = new EvalReader();
dispatchMacros[’!’] = new CommentReader();
dispatchMacros[’<’] = new UnreadableReader();
dispatchMacros[’_’] = new DiscardReader();
———-
2.24.1 The Var reader macro
Vars have a special reader macro #’so that the input form #’fooexpands into
(var foo). The Symbol foo must be a Var and the Var object itself, not its value,
2.24. READER DISPATCH MACROS 85
is returned.
The single-quote ( ’) array entry contains a [85] VarReader function.
— LispReader dispatchMacros VarReader statement —
dispatchMacros[’\’’] = new VarReader();
———-
The VarReader invokemethod reads the next object and returns the Var refer-
ence. (AFn [509])
— LispReader VarReader class —
public static class VarReader extends AFn{
public Object invoke(Object reader, Object quote)
throws Exception{
PushbackReader r = (PushbackReader) reader;
Object o = read(r, true, null, true);
// if(o instanceof Symbol)
// {
// Object v =
// Compiler.maybeResolveIn(Compiler.currentNS(),
// (Symbol) o);
// if(v instanceof Var)
// return v;
// }
return RT.list(THE_VAR, o);
}
}
———-
The#’macro is useful for naming functions or variables in another namesp ace.
You can call function across namespaces by writing
(#’mynamespace/functionname ...)
2.24.2 The Regular Expression reader macro
(AFn [509])
— LispReader RegexReader class —
public static class RegexReader extends AFn{
static StringReader stringrdr = new StringReader();
public Object invoke(Object reader, Object doublequote)
throws Exception{
StringBuilder sb = new StringBuilder();
Reader r = (Reader) reader;
86 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
for(int ch = r.read(); ch != ’"’; ch = r.read())
{
if(ch == -1)
throw new Exception("EOF while reading regex");
sb.append( (char) ch );
if(ch == ’\\’) //escape
{
ch = r.read();
if(ch == -1)
throw new Exception("EOF while reading regex");
sb.append( (char) ch ) ;
}
}
return Pattern.compile(sb.toString());
}
}
———-
2.24.3 The Function reader macro
(AFn [509])
— LispReader FnReader class —
public static class FnReader extends AFn{
public Object invoke(Object reader, Object lparen)
throws Exception{
PushbackReader r = (PushbackReader) reader;
if(ARG_ENV.deref() != null)
throw new IllegalStateException(
"Nested #()s are not allowed");
try
{
Var.pushThreadBindings(
RT.map(ARG_ENV, PersistentTreeMap.EMPTY));
r.unread(’(’);
Object form = read(r, true, null, true);
PersistentVector args = PersistentVector.EMPTY;
PersistentTreeMap argsyms =
(PersistentTreeMap) ARG_ENV.deref();
ISeq rargs = argsyms.rseq();
if(rargs != null)
{
int higharg =
(Integer) ((Map.Entry) rargs.first()).getKey();
if(higharg > 0)
{
for(int i = 1; i <= higharg; ++i)
2.24. READER DISPATCH MACROS 87
{
Object sym = argsyms.valAt(i);
if(sym == null)
sym = garg(i);
args = args.cons(sym);
}
}
Object restsym = argsyms.valAt(-1);
if(restsym != null)
{
args = args.cons(Compiler._AMP_);
args = args.cons(restsym);
}
}
return RT.list(Compiler.FN, args, form);
}
finally
{
Var.popThreadBindings();
}
}
}
———-
2.24.4 The Set reader macro
(AFn [509])
— LispReader SetReader class —
public static class SetReader extends AFn{
public Object invoke(Object reader, Object leftbracket)
throws Exception{
PushbackReader r = (PushbackReader) reader;
return PersistentHashSet
.createWithCheck(readDelimitedList(’}’, r, true));
}
}
———-
2.24.5 The Eval reader macro
(AFn [509])
— LispReader EvalReader class —
public static class EvalReader extends AFn{
88 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
public Object invoke(Object reader, Object eq) throws Exce ption{
if (!RT.booleanCast(RT.READEVAL.deref()))
{
throw new Exception(
"EvalReader not allowed when *read-eval* is false.");
}
PushbackReader r = (PushbackReader) reader;
Object o = read(r, true, null, true);
if(o instanceof Symbol)
{
return RT.classForName(o.toString());
}
else if(o instanceof IPersistentList)
{
Symbol fs = (Symbol) RT.first(o);
if(fs.equals(THE_VAR))
{
Symbol vs = (Symbol) RT.second(o);
//Compiler.resolve((Symbol) RT.second(o),true);
return RT.var(vs.ns, vs.name);
}
if(fs.name.endsWith("."))
{
Object[] args = RT.toArray(RT.next(o));
return
Reflector.invokeConstructor(
RT.classForName(
fs.name.substring(0, fs.name.length() - 1)),
args);
}
if(Compiler.namesStaticMember(fs))
{
Object[] args = RT.toArray(RT.next(o));
return
Reflector.invokeStaticMethod(
fs.ns, fs.name, args);
}
Object v =
Compiler.maybeResolveIn(Compiler.currentNS(), fs);
if(v instanceof Var)
{
return ((IFn) v).applyTo(RT.next(o));
}
throw new Exception("Can’t resolve " + fs);
}
else
throw new IllegalArgumentException("Unsupported #= form ");
}
}
2.25. VARS 89
———-
2.24.6 The Unreadable reader macro
(AFn [509])
— LispReader UnreadableReader class —
public static class UnreadableReader extends AFn{
public Object invoke(Object reader, Object leftangle)
throws Exception{
throw new Exception("Unreadable form");
}
}
———-
2.24.7 The Discard reader macro
(AFn [509])
— LispReader DiscardReader class —
public static class DiscardReader extends AFn{
public Object invoke(Object reader, Object underscore)
throws Exception{
PushbackReader r = (PushbackReader) reader;
read(r, true, null, true);
return r;
}
}
———-
2.25 Vars
2.26 Transients
Transients are intended to make your code faster. Transients ign ore structural
sharing so time and space is saved. The underlying data structure is diﬀerent.
For example, we thread a persistent map through some association s.
— transients example —
(-> {} (assoc :a 1) (assoc :b 2) (assoc :c 3))
90 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
———-
which results in the persistent map
— transients example —
{:c 3, :b 2, :a 1}
———-
Atransient version is similar but transients are not mutable.
— transients example —
(-> (transient {}) (assoc! :a 1) (assoc! :b 2) (assoc! :c 3) pe rsistent!)
———-
— defn transient —
(defn transient
"Alpha - subject to change.
Returns a new, transient version of the collection, in const ant time."
{:added "1.1"
:static true}
[^clojure.lang.IEditableCollection coll]
(.asTransient coll))
———-
The diﬀerence is that the transient call makes the persistent map is transformed
to a transient map. The assoc!call operates similar to assoc. The persistent!
call transforms the result to a persistent map.
There are several function that operate on transients, persistent! ,conj!,as-
soc!,dissoc!,pop!, anddisj!.
— defn persistent! —
(defn persistent!
"Alpha - subject to change.
Returns a new, persistent version of the transient collecti on, in
constant time. The transient collection cannot be used afte r this
call, any such use will throw an exception."
{:added "1.1"
:static true}
[^clojure.lang.ITransientCollection coll]
(.persistent coll))
2.26. TRANSIENTS 91
———-
— defn conj! —
(defn conj!
"Alpha - subject to change.
Adds x to the transient collection, and return coll. The ’add ition’
may happen at different ’places’ depending on the concrete t ype."
{:added "1.1"
:static true}
[^clojure.lang.ITransientCollection coll x]
(.conj coll x))
———-
— defn assoc! —
(defn assoc!
"Alpha - subject to change.
When applied to a transient map, adds mapping of key(s) to
val(s). When applied to a transient vector, sets the val at in dex.
Note - index must be <= (count vector). Returns coll."
{:added "1.1"
:static true}
([^clojure.lang.ITransientAssociative coll key val]
(.assoc coll key val))
([^clojure.lang.ITransientAssociative coll key val & kvs ]
(let [ret (.assoc coll key val)]
(if kvs
(recur ret (first kvs) (second kvs) (nnext kvs))
ret))))
———-
— defn dissoc! —
(defn dissoc!
"Alpha - subject to change.
Returns a transient map that doesn’t contain a mapping for ke y(s)."
{:added "1.1"
:static true}
([^clojure.lang.ITransientMap map key] (.without map key ))
([^clojure.lang.ITransientMap map key & ks]
(let [ret (.without map key)]
(if ks
92 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
(recur ret (first ks) (next ks))
ret))))
———-
— defn pop! —
(defn pop!
"Alpha - subject to change.
Removes the last item from a transient vector. If
the collection is empty, throws an exception. Returns coll"
{:added "1.1"
:static true}
[^clojure.lang.ITransientVector coll]
(.pop coll))
———-
— defn disj! —
(defn disj!
"Alpha - subject to change.
disj[oin]. Returns a transient set of the same (hashed/sort ed) type,
that does not contain key(s)."
{:added "1.1"
:static true}
([set] set)
([^clojure.lang.ITransientSet set key]
(. set (disjoin key)))
([set key & ks]
(let [ret (disj set key)]
(if ks
(recur ret (first ks) (next ks))
ret))))
———-
The imperative style will not work everywhere. For instance,
— transients example —
(let [a (transient {})]
(dotimes [i 20] (assoc! a i i))
(persistent! a))
———-
2.26. TRANSIENTS 93
returns with the broken result
— transients example —
(0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7}
———-
which is only the ﬁrst 8 values of the map.
However, if it is done in a recursive style, as in
— transients example —
(persistent!
(reduce (fn[m v] (assoc! m v v))
(transient {})
(range 1 21)))
———-
yields all twenty pairs.
— transients example —
(0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7, 8 8, 9 9, 10 10, 11 11, 12 12,
13 13, 14 14, 15 15, 16 16, 17 17, 18 18, 19 19, 20 20)
———-
Transients can only be modiﬁed by the thread that creates them. A ttemping to
access them will throw a java.util.concurrent.ExecutionException
— transients example —
@(let [c (transient [])] (future (conj! c :a)))
———-
It is also not possible to modify a Transient after the call to persistent! will
throw a java.lang.IllegalAccessError exception. So this will not work:
— transients example —
(let [c (transient #{})] (persistent! c) (conj! c :a))
———-
Transients do not work on every data structure. Lists, sets, an d maps all throw
ajava.lang.ClassCastException
— transients example —
(transient ’())
(transient (sorted-set))
(transient (sorted-map))
94 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
———-
The Transient data structure must support clojure.lang.IEditableCollection .
2.27 Atoms
2.28 Refs
2.29 Agents
2.30 Promise and Deliver
A Promise is a mechanism for storing data and reading this data acros s threads.
Thepromise function creates a promise that can be stored as in:
— promise example —
(def prom (promise))
———-
— defn promise —
(defn promise
"Alpha - subject to change.
Returns a promise object that can be read with deref/@, and se t,
once only, with deliver. Calls to deref/@ prior to delivery w ill
block. All subsequent derefs will return the same delivered value
without blocking."
{:added "1.1"
:static true}
[]
(let [d (java.util.concurrent.CountDownLatch. 1)
v (atom nil)]
(reify
clojure.lang.IDeref
(deref [_] (.await d) @v)
clojure.lang.IPromiseImpl
(hasValue [this]
(= 0 (.getCount d)))
clojure.lang.IFn
(invoke [this x]
(locking d
(if (pos? (.getCount d))
(do (reset! v x)
2.30. PROMISE AND DELIVER 95
(.countDown d)
this)
(throw (IllegalStateException.
"Multiple deliver calls to a promise"))))))))
———-
To fulﬁll a promise we use the deliverfunction. So we would use
— promise example —
(deliver prom 1)
———-
— defn deliver —
(defn deliver
"Alpha - subject to change.
Delivers the supplied value to the promise, releasing any pe nding
derefs. A subsequent call to deliver on a promise will throw a n
exception."
{:added "1.1"
:static true}
[promise val] (promise val))
———-
dereference @ promise To see the delivered value we deference the variable.
— promise example —
@prom
———-
Note that dereferencing a promise before the value is delivered will b lock the
current thread. So you can have a future deliver on the promise fr om another
thread and wait on the result.
— promise example —
(do (future
(Thread/sleep 5000)
(deliver prom 1))
@prom)
———-
IllegalStateExceptionIllegalStateExceptionpromiseAttempingtod eliveravalue
more than once will throw a java.lang.IllegalStateException
96 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
2.31 Futures
Futures are a mechanism for executing a function in a diﬀerent thre ad and
retrieving the results later.
Futures are useful for long running tasks that should not block, s uch as a UI
thread, communicating across networks, or a task that has a side -eﬀect that
does not aﬀect the main computation, such as displaying an image or p rinting.
For example,
— future example —
(do
(future
(Thread/sleep 3000)
(sendToPrinter "resume.pdf"))
(messages/plain-message "file being printed"))
———-
A future can return a value. We deﬁne a var that will hold the value of a future
as in:
— defn future-call —
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; futures (needs proxy); ;;;;;;;;;;;;;;;;;
(defn future-call
"Takes a function of no args and yields a future object that wi ll
invoke the function in another thread, and will cache the res ult and
return it on all subsequent calls to deref/@. If the computat ion has
not yet finished, calls to deref/@ will block."
{:added "1.1"
:static true}
[f]
(let [f (binding-conveyor-fn f)
fut (.submit clojure.lang.Agent/soloExecutor ^Callable f)]
(reify
clojure.lang.IDeref
(deref [_] (.get fut))
java.util.concurrent.Future
(get [_] (.get fut))
(get [_ timeout unit] (.get fut timeout unit))
(isCancelled [_] (.isCancelled fut))
(isDone [_] (.isDone fut))
(cancel [_ interrupt?] (.cancel fut interrupt?)))))
———-
— defmacro future —
2.31. FUTURES 97
(defmacro future
"Takes a body of expressions and yields a future object that w ill
invoke the body in another thread, and will cache the result a nd
return it on all subsequent calls to deref/@. If the computat ion has
not yet finished, calls to deref/@ will block."
{:added "1.1"}
[& body] ‘(future-call (^{:once true} fn* [] ~@body)))
———-
— future var —
(def result
(future
(Thread/sleep 3000)
"The future has arrived"))
———-
dereference @ future We can get the value of this var using the der eference
operator ”@”.
— future dereference —
@result
———-
CancellationException CancellationException future If we derefer ence the var
before the future completes then the dereference blocks until t he result is avail-
able. The result retains its value so a second dereference will retur n immedi-
ately. If the future is cancelled (see below), then the dereferenc e will throw a
—java.util.concurrent.CancellationException—.
future? We can test if a var is a future with the future? predicate.
— future dereference —
(future? result) ==> true
———-
— defn future? —
(defn future?
"Returns true if x is a future"
{:added "1.1"
:static true}
[x] (instance? java.util.concurrent.Future x))
98 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
———-
future-done? We can test if the future has completed witht he future-done?
predicate.
— future done —
(future-done? result) ==> true
———-
— defn future-done? —
(defn future-done?
"Returns true if future f is done"
{:added "1.1"
:static true}
[^java.util.concurrent.Future f] (.isDone f))
———-
A pending future can be cancelled with the future-cancel function
— future cancel —
(future-cancel result) ==> true
———-
which, if it successfully cancels the future returns true.
— defn future-cancel —
(defn future-cancel
"Cancels the future, if possible."
{:added "1.1"
:static true}
[^java.util.concurrent.Future f] (.cancel f true))
———-
We can test if the future was cancelled with the future-cancelled? function
— future cancelled —
(future-cancelled? result) ==> true
———-
2.32. MULTIMETHODS 99
which, if the future was cancelled, will return true.
— defn future-cancelled? —
(defn future-cancelled?
"Returns true if future f is cancelled"
{:added "1.1"
:static true}
[^java.util.concurrent.Future f] (.isCancelled f))
———-
2.32 MultiMethods
2.33 Deftype
2.34 Defrecord
Deﬁne a record object with slots named :a, :b, and :c
>(defrecord Foo [a b c])
user.Foo
This makes a Java class Fooin the Java package user.
Make a Var reference to a our new record object.
>(def f (Foo. 1 2 3))
#:user.Foo {:a 1, :b 2, :c 3 }
Access the value of the :b slot in the record instance f
>(:b f)
2
or
>(.b f)
2
What is the Var f actually pointing to? It points to a class object.
>(class f)
user.Foo
100 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
We can apply normal functions to the query information about the c lass of f.
>(supers (class f))
#{clojure.lang.ILookup
java.lang.Object
java.util.Map
clojure.lang.Seqable
clojure.lang.IKeywordLookup
java.lang.Iterable
clojure.lang.IMeta
clojure.lang.IPersistentCollection
clojure.lang.IPersistentMap
clojure.lang.Counted
clojure.lang.IObj
java.io.Serializable
clojure.lang.Associative }
We see that the Var f references a record class which has a number of interesting
properties. In particular, given this record we know many things ab out its
properties.
•[797] ILookup
•Object Since records are Java Objects they can be compared with the
defaultequalsmethod and can be stored in containers or passed as ar-
guments.
•Map Since records implement Map they provide three collection views, as
a set of keys, as a set of values, and as a set of key-value mappings .
•[1140] Seqable
•[796] IKeywordLookup
•Iterable Since records are Iterable they implement an iterator method
that allows them to be the target of a foreach statement.
•[799] IMeta
•[800] IPersistentCollection
•[801] IPersistentMap
•[768] Counted
•[800] IObj
•SerializableSince recordsareSerializablethe implement writeObject and
readObject methods that make it possible to stream the state of the
object out and recreate it by reading it back.
•[576] Associative
2.35. PROTOCOLS 101
2.35 Protocols
>(defprotocol coerce
”coerce between things”
(as-ﬁle [x] ”Coerce argument to a ﬁle”)
(as-url [x] ”Coerce argument to a URL”))
coerce
Defprotocol deﬁnes a named set of generic functions which dispat ch on the type
of the ﬁrst argument. The functions are deﬁned in the same names pace (and
thus the same Java package) as the protocol.
Similar to Java interfaces but are functions, not associated with cla sses. In this
example, we mimic the Java idioms. A record is like class and coerce is like a n
interface so we are saying that the class Nameimplements the as-file method
of interface coerce.
Extending inline
>(defrecord Name [n]
coerce
(as-ﬁle [˙] (File. n)))
user.Name
>(def n (Name. ”johndoe”))
#’user/n
>(as-ﬁle n)
#¡File johndoe¿
Extending protocol to classes that already exist
Protocols can implement methods without classes by associating the m with
types of their ﬁrst argument. So we extend the coerceprotocol to work with
nilarguments and Stringarguments.
>(extend-protocol coerce
nil
(as-ﬁle [˙] nil)
(as-url [˙] nil)
String
(as-ﬁle [s] (File. s))
(as-url [s] (URL. s)))
nil
102 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
>(as-ﬁle ”data.txt”)
#File data.txt
Extending existing classes to add protocols
>(defprotocol MyNewProtocol (myNewFunction [x] ”answer”))
MyNewProtocol
>(extend-type String
coerce
(as-ﬁle [s] (File. s))
(as-url [s] (URL. s))
MyNewProtocol
(myNewMethod [x] (str ”answer: ” x)))
nil
>(myNewFunction ”test”)
”answer”
>(extend-type Long MyNewProtocol (myNewFunction [x] (+ x 1)))
nil
>(myNewFunction 1)
2
2.36 Prototypes
2.37 Genclass
2.37.1 Overriding protected methods
In order to override a protected method and call the superclass y ou need to
make the protected method available under an alternate name. For examle, to
extend Java class Foo with fooMethod(bar) you would use
(ns.com.example.subclass-of-Foo
(:gen-class :extends com.example.Foo
:exposes-methods {fooMethod fooSuperMethod}))
(defn -fooMethod [this parameter]
(fooSuperMethod this parameter))
2.38. PROXIES 103
2.38 Proxies
2.39 Macros
2.40 Iterators
(Iterator [1723])
— PersistentTreeMap NodeIterator Class —
static public class NodeIterator implements Iterator{
Stack stack = new Stack();
boolean asc;
NodeIterator(Node t, boolean asc){
this.asc = asc;
push(t);
}
void push(Node t){
while(t != null)
{
stack.push(t);
t = asc ? t.left() : t.right();
}
}
public boolean hasNext(){
return !stack.isEmpty();
}
public Object next(){
Node t = (Node) stack.pop();
push(asc ? t.right() : t.left());
return t;
}
public void remove(){
throw new UnsupportedOperationException();
}
}
———-
(Iterator [1723])
— PersistentTreeMap KeyIterator Class —
static class KeyIterator implements Iterator{
104 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
NodeIterator it;
KeyIterator(NodeIterator it){
this.it = it;
}
public boolean hasNext(){
return it.hasNext();
}
public Object next(){
return ((Node) it.next()).key;
}
public void remove(){
throw new UnsupportedOperationException();
}
}
———-
(Iterator [1723])
— PersistentTreeMap ValIterator Class —
static class ValIterator implements Iterator{
NodeIterator it;
ValIterator(NodeIterator it){
this.it = it;
}
public boolean hasNext(){
return it.hasNext();
}
public Object next(){
return ((Node) it.next()).val();
}
public void remove(){
throw new UnsupportedOperationException();
}
}
———-
2.41. GENERATING JAVA CLASSES 105
2.41 Generating Java Classes
2.42 Type Hints
2.43 Native Arithmetic
106 CHAPTER 2. FROM IDEAS TO IMPLEMENTATION
Chapter 3
Writing Idiomatic Clojure
107
108 CHAPTER 3. WRITING IDIOMATIC CLOJURE
Chapter 4
The Ants Demo (Kai Wu)
This is adapted from Wu [1]
4.1 The Simulation World
Theﬁrst partof ants.clj sets up the simulationworld, wherewe’llbe introduced
to some of Clojure’s powers.
4.1.1 Initial setup of constants/magic-numbers
After the copyright notice, the initial setup code of ants.clj is easy to under-
stand (for coders at least), even if you’ve never dealt with Lisp bef ore. We see
parameters (aka constants and magic numbers) being deﬁned for later use using
Clojure’s special form: defcreates a var (a mutable storage location) which
connects a symbol to a value in the current namespace .
— sim-world-setup —
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ant sim ;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (c) Rich Hickey. All rights reserved.
;;
;; The use and distribution terms for this software are cover ed by the
;; Common Public License 1.0 (http://opensource.org/lice nses/cpl.php)
;; which can be found in the file CPL.TXT at the root of this dis tribution.
;; By using this software in any fashion, you are agreeing to b e bound by
;; the terms of this license.
;;
;; You must not remove this notice, or any other, from this sof tware.
109
110 CHAPTER 4. THE ANTS DEMO (KAI WU)
;; Set dimensions of the world, as a square 2-D board:
(def dim 80)
;; Number of ants = nants-sqrt^2
(def nants-sqrt 7)
;; Number of places with food:
(def food-places 35)
;; Range of amount of food at a place:
(def food-range 100)
;; Scale factor for pheromone drawing:
(def pher-scale 20.0)
;; Scale factor for food drawing:
(def food-scale 30.0)
;; Evaporation rate:
(def evap-rate 0.99)
(def animation-sleep-ms 100)
(def ant-sleep-ms 40)
(def evap-sleep-ms 1000)
(def running true)
———-
4.1.2 The board: ready to mutate via transactions
Things get more interesting once the actual simulation environment needs deﬁn-
ing:
— cell —
(defstruct cell :food :pher) ; May also have :ant and :home va lues
———-
First, a call to defstruct (like a hashmap or dictionary in other languages)
deﬁnes a baseline cell.
•defstruct islikeaverylightweightclassorconstructor/templatefunction,
and conveniently wraps Clojure’s create-struct .
•Here, acellhastwokeystostart, :foodand:pher, toindicatethepresence
of food and pheromones. A cell may also have keys of :antand:home,
depending on whether an ant and/or the home-colony is present.
Next, the worldfunction creates the 2-dimensional ”board” of cells (here, a
square of 80x80 cells), represented as vectors (rows or the ver tical y-dimension)
of a vector (the horizontal x-dimension columns in one row):
— sim-world-board-creation —
4.1. THE SIMULATION WORLD 111
;; World is a 2d vector of refs to cells
(def world
(apply vector
(map (fn [_]
(apply vector
(map (fn [_]
(ref (struct cell 0 0)))
(range dim))))
(range dim))))
———-
Reading the above:
•Start with the innermost mapcall, which uses an anonymous function to
create one column of 80 cells, per (range dim) . Thestructreturns a
new structmap instance using the earlier cell as the basis, initializing t he
:foodand:phervalues to zero.
•But notice that structis wrapped with a transactional ref , and here’s
the ﬁrst glimpse of Clojure’s concurrency powers. With each cell be ing
stateful (possibly time-varying values of :food,:pher,:ant, and:home
values) and with multiple threadsupdating the boardand board eleme nts,
we’d typically think of using locks on each cell when updating its state.
But in Clojurewith its software transactional memory (STM), wejust
usereffor safe references to mutable collections (here, a struct) - all
changes to a cell will then be atomic, consistent, and isolated!1Like
using an RDBMS, you don’t need to manually manage concurrency.
•Once you understand the innermost (ref (struct cell 0 0 )) map call,
the rest of (def world...) is straightforward: applyusesvectoras a
constructor function with the mapfunction producing the vector’s argu-
ments, creating a “column” in the 2-D board.
•Then the pattern is repeated in the outermost (apply vector (map...))
call, creating all the columns of the 2-D board.
•Note that as deﬁned, each vector in world(again, a 2-D vector of vectors)
corresponds to an x-position, and of course, within that vector a re the y-
positions (here, a total of 80 cells).
Theplacefunction is a selector function (think of “place” as the noun, not th e
verb) returning particular cells in the 2-D world. Once we have a cell, w e can
then mutate it to represent ants, food, and pheromones (or the ir absence):
— place —
1STM is like a memory-only SQL database, thus the last propert y of being
durable/persistent won’t be satisﬁed.
112 CHAPTER 4. THE ANTS DEMO (KAI WU)
(defn place [x y]
(-> world (nth x) (nth y)))
———-
•placetakes a single vector argument (having two elements x and y), then
applies the thrush operator (the arrow-like −>) on the world object, ﬁrst
selecting the “column” (nth x) on world, then the “row” (nth y) on that
column.
Aside: the thrush operator
The thrush operator helps make code more concise, and arguably c learer: in-
stead of reading code “inside-out” to mentally evaluate it, we can re ad it left-
to-right.2Consider how the equivalent placefunction would look without
thrushing:
(defn place-verbose [[x y]]
(nth (nth world x) y))
4.1.3 Ants as agents - doing asynchronous uncoordinated
changes
Next we’ll consider the “active things” in ants.clj, the ants themselves. As
before, we start with defstruct , deﬁning an ant as having only one required
key, its direction. (An ant may temporarily have another key, :food.)
— ants-deﬁned —
(defstruct ant :dir) ; Always has dir heading; may also have : food
(defn create-ant
"Create an ant at given location, returning an ant agent on th e location."
[location direction]
(sync nil
(let [the-place (place location)
the-ant (struct ant direction)]
(alter the-place assoc :ant the-ant)
(agent location))))
———-
2Apparently Clojure’s thrush is not quite a true thrush, see M ichael Fogus’ article at
blog.fogus.me/2010/09/28/thrush-in-clojure-redux
4.1. THE SIMULATION WORLD 113
To explain the above constructor function for ants, create-ant :
•Takes two arguments, location anddirection .location will be a vector
[x y], and as we saw, passed on to the place function as an argument;
direction is a number from 0-7 inclusive corresponding to one of the
eight cardinal directions.
•More concurrency support: the sync function takes a ﬂags argument
(as of Clojure 1.3, it’s still ignored so just pass nil), and then a list of
expressions that will be executed together atomically (all or nothin g) as
a transaction.
•Thelet special form binds pairs of symbols and expressions in its ar-
guments vector, providing local, lexical bindings within the scope of t he
body following.
•syncwill ensurethat anymutations ofrefs usingthe alter function will
be atomic. Previously we had used refaround each cell, so in the above
code where the-place is such a ref-wrapped cell, altertakesthe-place
refas its ﬁrst argument, then assocasthe function to be apply’ed on the-
place, tying a new ant instance to it (remember that as a cell, the-place
is sure to have :foodand:pherkey-values already, now we add :ant).
Like the thrush operator earlier, the syntax of alterenables convenient
left-to-right reading.
•Finally, the agent function . What are Clojure agents? To quote the
docs,
Agents provide shared access to mutable state. They allow non-
blocking (asynchronous as opposed to synchronous atoms) and
independent change of individual locations (unlike coordinated
change of multiple locations through refs).
Clojure’s agentfunction takes one required argument of state, returning an
agent object with initial value of that given state. Here, as the last line of
create-ant ,agenteﬀectively returns the ant object at its starting location.
Ants as agents make sense: we expect them to move around indepe ndently (i.e.
asynchronously) in the simulation world.
4.1.4 Setting up the home, and ants
Thehomeofthe antsisnotasinglecellonthe world-board,but asqu areofcells,
with its top-left corner oﬀset from the origin (0, 0). Its sides are p roportional
to the number of ants because the home square will initially contain all the ants
- one ant per cell - before the simulation runs. We can see these two aspects of
the home-square in the two defcalls forhome-oﬀset andhome-range below.
114 CHAPTER 4. THE ANTS DEMO (KAI WU)
— home-setup —
(def home-offset (/ dim 4))
(def home-range (range home-offset (+ nants-sqrt home-off set)))
(defn setup
"Places initial food and ants, returns seq of ant agents."
[]
(sync nil
(dotimes [i food-places]
(let [p (place [(rand-int dim) (rand-int dim)])]
(alter p assoc :food (rand-int food-range))))
(doall
(for [x home-range y home-range]
(do
(alter (place [x y]) assoc :home true)
(create-ant [x y] (rand-int 8)))))))
———-
Thesetupfunction’s docstring tells us what it’s doing, so on to the details:
•setuptakes no arguments.
•As we saw before in create-ant , thesyncfunction wraps a sequence of
expressions that together should be executed atomically, all-or-n othing.
•Setup initial food: The dotimes function takes two arguments, the ﬁrst
a vector [name n] withnbeing the number of times that the body
(the second argument) will be repeatedly executed, usually for its side-
eﬀects/mutations.
–Here, the unused name iis bound to the integers from 0 to 34, since
we had speciﬁed food-places as 35 initially.
–Thebodyis clear enough: bind pto the randomly chosen place on
theworld-board(usingthe rand-int functionfor(x, y). Thealready-
seenalterfunction modiﬁes that pto have a random amount of food
value.
•Placing the ants in their starting positions: The doallfunction forces
immediate evaluation of a lazy sequence - in this case the lazy sequenc e
produced by the forfunction.
–Here,the forfunction’sﬁrstargumentis: twobinding-form/collection-
expr pairs for every x and y position within the square of the ants’
home.
4.1. THE SIMULATION WORLD 115
–Theforfunction’s second argument is the body-expression, here
wrapped in the dospecial form which ensures order of evaluation
(usually, of expressions having side-eﬀects): designate the place as a
home position, then create an ant on that place with a random initial
direction.
In sum, the setupfunction shows how to deal with state and its mutation in
Clojure: we started with a 2-D world-board of places (cells) as Cloju re refs;
then we modify/mutate each place using alter. We can use various looping
functions such as dotimes anddoallto process a batch of state-mutations (of
the world-board) atomically and consistently.
4.1.5 Orientation and moving around the world
Next, consider facing/orientationand moving to another place in th e 2-D world.
Three functions below, followed by explanations:
— world-wrapping —
(defn bound
"Returns given n, wrapped into range 0-b"
[b n]
(let [n (rem n b)]
(if (neg? n)
(+ n b)
n)))
;; Directions are 0-7, starting at north and going clockwise . These are
;; the 2-D deltas in order to move one step in a given direction .
(def direction-delta {0 [0 -1]
1 [1 -1]
2 [1 0]
3 [1 1]
4 [0 1]
5 [-1 1]
6 [-1 0]
7 [-1 -1]})
(defn delta-location
"Returns the location one step in the given direction. Note t he
world is a torus."
[[x y] direction]
(let [[dx dy] (direction-delta (bound 8 direction))]
[(bound dim (+ x dx)) (bound dim (+ y dy))]))
———-
116 CHAPTER 4. THE ANTS DEMO (KAI WU)
Withthe2-Dworldboard, wehavethe8cardinaldirections(North, North-East,
East, etc.), and board edges that wrap-around to the opposite s ide - like the old
arcadegamesof the 1980’s, e.g. Pac-Man andAsteroids . The functions bound
anddelta-location help enforce these world-behaviors, while the deﬁnition of
direction-delta maps a movement in a cardinal direction to the corresponding
change in x and y. A few comments on each:
•Theboundfunction using the built-in rem(i.e. remainder) function is
straightforward. Observe how boundis used in delta-location to ensure
wrap-around behavior in: 1) cardinal directions; 2) the world-boa rd, at
its edges given by dim.
•direction-delta maps the eight cardinal directions (0 is North) to the
correspondingchangesin [x y]. Note the syntax: it’s an array-mapliteral,
where the order of insertion of key-value pairs (here, keys 0-7) w ill be
preserved.
•delta-location takes the current [x y]location and a direction, returning
the new corresponding location on the world-board.
4.1.6 Ant-agent behavior functions
In Hickey’s simulation, ants need to move (rotation and translation) , pick up
and drop-oﬀ food, and make rudimentary decisions.
Ant movements
Our ants need two behaviors to get around their world: turning (or changing
the direction they “face”), and stepping forward. Let’s deal with turning ﬁrst:
— ant-agent-turn —
;ant agent functions
; An ant agent tracks the location of an ant, and controls the
; behavior of the ant at that location.
(defn turn
"Turns the ant at the location by the given amount."
[loc amt]
(dosync
(let [p (place loc)
ant (:ant @p)]
(alter p assoc :ant (assoc ant :dir (bound 8 (+ (:dir ant) amt) )))))
loc)
4.1. THE SIMULATION WORLD 117
———-
Theturnfunction takes two arguments, location and the amount of turn.
What’s interesting is the usage of the dosyncfunction, which ensures the ant’s
turn - the changes of state within the assocfunction calls - is all-or-nothing.
Theantgets anewdirectionper the innermost assoc, then the outermost assoc
updates the placewith the updated ant.
Now for actual movement to a new place:
— ant-agent-move —
(defn move
"Moves the ant in the direction it is heading. Must be called i n a
transaction that has verified the way is clear."
[startloc]
(let [oldp (place startloc)
ant (:ant @oldp)
newloc (delta-location startloc (:dir ant))
newp (place newloc)]
;; move the ant
(alter newp assoc :ant ant)
(alter oldp dissoc :ant)
;; leave pheromone trail
(when-not (:home @oldp)
(alter oldp assoc :pher (inc (:pher @oldp))))
newloc))
———-
Themovefunction changesstate of both the ant and board, thus the doc- string
notethat itmust be calledinatransaction. The codeisself-explanat ory,though
if “pheromone” is a new term to you, you’ll want to learn about a domin ant
form of chemical communication on Earth. Whenever our artiﬁcial a nt is not
within its home, it will “secrete” pheromone ( incthe:phervalue by 1) at the
place it just left, making it easier (more likely) for it and other ants to travel
between home and food locations in the future (instead of doing a co mpletely
random walk).
Ants and food
When an ant ﬁnds food, it “picks up” one unit of it; when it returns ho me with
a food unit, it will “drop” its food there. These two interactions (ea ch having
two steps) change the board, and as with the movefunction, they need to occur
atomically (all-or-nothing) to ensure the world is in a consistent stat e.
— ant-agent-food —
118 CHAPTER 4. THE ANTS DEMO (KAI WU)
(defn take-food [loc]
"Takes one food from current location. Must be called in a
transaction that has verified there is food available."
(let [p (place loc)
ant (:ant @p)]
(alter p assoc
:food (dec (:food @p))
:ant (assoc ant :food true))
loc))
(defn drop-food [loc]
"Drops food at current location. Must be called in a
transaction that has verified the ant has food."
(let [p (place loc)
ant (:ant @p)]
(alter p assoc
:food (inc (:food @p))
:ant (dissoc ant :food))
loc))
———-
Notice how similar the structure is for the two functions above; pos sibly they’re
candidates for macro refactoring.
Ant judgment
Our ants need some decision-making for their overall task of ﬁnding food and
bringing it home. As we’ll see shortly, an ant’s behavior is based on two states,
either:
1. The ant does not have food, and is looking for it. In this mode, it we ighs
the three map locations ahead of it (ahead, ahead-left, ahead-rig ht) by the
presence of either food or pheromone.
2. The ant has food, and needs to bring it to the home box/location. Now
it weighs which of the three ahead-positions to take by the presenc e of
pheromone, or home.
So we need functions to express preference of the next location f or an ant. The
functions rank-by andwrandhelp with that.
— ant-agent-judgment-1 —
(defn rank-by
"Returns a map of xs to their 1-based rank when sorted by keyfn ."
[keyfn xs]
4.1. THE SIMULATION WORLD 119
(let [sorted (sort-by (comp float keyfn) xs)]
(reduce (fn [ret i] (assoc ret (nth sorted i) (inc i)))
{} (range (count sorted)))))
———-
Therank-by function gives weights to where an ant will move next in the
simulation world. It takes two arguments, keyfnandxs- but what do those
args look like, and where is rank-by used? In the behave function below;
you’ll see that the keyfnchecks for the presence of :food,:pher, or:home
- in the three cells (board locations) of the xsvector of [ahead ahead-left
ahead-right] .3
•The(sort-by keyfn coll) function returns a sorted sequence of items in
coll, ordered by comparing (keyfn item) . Here, for the localvalue sorted,
itwillbe ascendingorderofcells/places,bytheir:food/:home/:pherv alues
- each of those is valuable to an ant depending on whether it’s looking f or
food, or bringing it home.
•The(reduce f initial-val coll) functionn in its 3-arguments form here
hasits1stargument fasafunctiontakingtwoarguments,thecurrent/initial-
val value and the next/ﬁrst item from coll. In this case, it will “build-
up” a map from the local sorted value, with the keys being the ranke d
cells/places, and the values being integers 1, 2 and 3. To get a sense of
what’s going on, try this on your Clojure REPL:
(let [sorted [0 0.7 1.0]]
(reduce (fn [ret i] (assoc ret (nth sorted i) (inc i)))
{}
(range (count sorted))))
;; You should see {1.0 3, 0.7 2, 0 1}
;;
;; Within the behave function below, the return value might b e
;; like {<cell-ahead-left> 3, <cell-ahead-right> 2, <cell -ahead> 1}
;; or similar.
Next: The wrandfunction helps with the larger task of randomizing which
location/cell the ant moves to next in a weighted manner; i.e. the “dic e” are
loaded with rank-by , then “rolled” here:
— ant-agent-judgment-2 —
3Remember that :food,:pher, and:homeare mutually exclusive in a cell. When an ant
wants to go home with food, and the home cell(s) is ahead of it, it will always go home, there
won’t be competing :pherpresence.
120 CHAPTER 4. THE ANTS DEMO (KAI WU)
(defn wrand
"Given a vector of slice sizes, returns the index of a slice gi ven a
random spin of a roulette wheel with compartments proportio nal to
slices."
[slices]
(let [total (reduce + slices)
r (rand total)]
(loop [i 0 sum 0]
(if (< r (+ (slices i) sum))
i
(recur (inc i) (+ (slices i) sum))))))
———-
How iswrandused? Like rank-by , look in the behave function: its single
argument of slices is a vector of 3 integers (from rank-by above), corresponding
totherelativedesirabilityofthe3cellsaheadoftheant. Soiftheslice sargument
looked like [0 3 1], that would correspond to zero probability of moving ahead,
and 3/4 chance moving to the ahead-left cell over the ahead-right cell.
•Theletvaluetotalusesreduceto set the upper bound on the random
number; loosely like setting the maximum number of faces on the die to
be rolled (albeit that some die numbers are geometrically impossible).
•Therandfunction returns a random ﬂoating point number from 0 (inclu-
sive) to n (exclusive).
•Here’stheonlyloopingconstructintheentireantsprogram: it’sana logous
to checking which compartment of the roulette wheel the ball fell in . The
ifchecks if r”fell into” the current pocket - the size of which is given by
(slices i) . If yes, return the index corresponding to that pocket; if not,
check the next pocket/slice.
Tying it all together: the behave function for ants
Thebehave function below is the largest one, so it helps to keep in mind its
main parts while diving into details:
1.letvalues - help with readability.
2.Thread/sleep - helps slow down ants in the UI display.
3.dosync - ensures ants behavior is transactional, all-or-nothing.
4.ifbranch: main logic for an ant, if ant has :foodtake it home, otherwise
look for food.
4.1. THE SIMULATION WORLD 121
Also, consider the context of how behave is ﬁrst used: within the main invo-
cation at the end, there’s the expression:
(dorun (map #(send-off % behave) ants))
So thebehave function is called on every ant agent via the send-oﬀ function,
which is how Clojure dispatches potentially blocking actions to agents . And
there certainly are potentially blocking actions when using behave, since ants
may try to move into the same cell, try to acquire the same food, etc .
— ant-agent-behave —
(defn behave
"The main function for the ant agent."
[loc]
(let [p (place loc)
ant (:ant @p)
ahead (place (delta-location loc (:dir ant)))
ahead-left (place (delta-location loc (dec (:dir ant))))
ahead-right (place (delta-location loc (inc (:dir ant))))
places [ahead ahead-left ahead-right]]
;; Old way of Java interop: (. Thread (sleep ant-sleep-ms))
;; New idiomatic way is,
(Thread/sleep ant-sleep-ms)
(dosync
(when running
(send-off *agent* #’behave))
(if (:food ant)
;; Then take food home:
(cond
(:home @p)
(-> loc drop-food (turn 4))
(and (:home @ahead) (not (:ant @ahead)))
(move loc)
:else
(let [ranks (merge-with +
(rank-by (comp #(if (:home %) 1 0) deref) places)
(rank-by (comp :pher deref) places))]
(([move #(turn % -1) #(turn % 1)]
(wrand [(if (:ant @ahead) 0 (ranks ahead))
(ranks ahead-left) (ranks ahead-right)]))
loc)))
;; No food, go foraging:
(cond
(and (pos? (:food @p)) (not (:home @p)))
(-> loc take-food (turn 4))
(and (pos? (:food @ahead)) (not (:home @ahead)) (not (:ant @ ahead)))
(move loc)
122 CHAPTER 4. THE ANTS DEMO (KAI WU)
:else
(let [ranks (merge-with +
(rank-by (comp :food deref) places)
(rank-by (comp :pher deref) places))]
(([move #(turn % -1) #(turn % 1)]
(wrand [(if (:ant @ahead) 0 (ranks ahead))
(ranks ahead-left) (ranks ahead-right)]))
loc)))))))
———-
Theletvalues
Theletvalues: quitestraightforward,justnotethetwistinhow behavereceives
a cell/location as its argument, not an ant (which an OO-centric desig n might
expect).
The only JVM/concurrency leakage: Thread/sleep
The
(. Thread (sleep ant-sleep-ms))
or
(Thread/sleep ant-sleep-ms)
call is our ﬁrst encounter with Clojure’s Java Interop .
•The ﬁrst version uses the dotspecial form and in particular, the
(. Classname-symbol (method-symbol args*))
format, with Thread as the Classname-symbol, and sleepasthe method-
symbol.
•However,outsideofmacros,theidiomaticformforaccessingmeth odmem-
bers is the second form,
(Classname/staticMethod args*)
•Beyond syntax, the point of this expression is to slow down an ant (o ne
ant-agent per thread) between their movements, so you can see in the UI
what they’re doing, and they’ll appear more realistic.
But more interesting still: in this highly concurrent program, the sleepexpres-
sion is about the *only explicit reference to threads* in the entire co de, i.e. one
of the very few “leaky abstractions” hinting at Clojure’s use of und erlying JVM
4.1. THE SIMULATION WORLD 123
concurrency constructs. Besides this call, there are no locks, an d no explicit
thread allocations.
The main dosync call
Next, let’s look at what’s going on within the dosync transaction.
Repeating asynchronously, without looping
The ﬁrst expression is:
(when running (send-off *agent* #’behave))
Initially this mayseem strange; aren’t wein the behavefunction because send-
oﬀalreadycalled it before enteringit? Won’t this just loop uselessly, not hitting
the core ifcode below? Not quite:
•Instead,send-oﬀ addsanotherexecutionof behavetothecurrentagent’s
*queue* of work/functions, and immediately returns.
–The current agent is referenced by the asterisk-surrounded *a gent*
which Clojure dynamically binds to the current active agent on a
thread-local basis.
•Thus after ﬁnishing this call of behave the ant will do another action
(execute behaveagain), and another, and so on. No explicit looping, just
*queue and repeat*.
Also, note the #’sharp-quote, before behave; this is a Clojure Var, one of
Clojure’s mutable reference types. It’s just syntactic sugar for (var behave) .
Invoking a Var referring to a function is the same as invoking the fun ction
itself...so why bother with it? I don’t know; here’s what I could ﬁnd:
•Besides Clojure docs, this SO thread also suggests there’s no diﬀer ence,
“Apply a varis the same as applying the value store in the var.”
•Maybe the #’preﬁx on behave causes the current thread’s value of
the function (with the current ant/location) to be sent to the que ue?
NO/unlikely. If it was mean to be a dynamic var, it would have asterisks
around it like *agent* .
•Another possibility is that the #’maintains a runtime look-up so that
behave can be redeﬁned on a running simulation while developing.
Why use send-oﬀ instead of send?
•send vs. send-oﬀ- sendusesthreadpoolofﬁxedsizewhich haslowswitch-
ing overhead but blocking can dry up the threadpool. By contrast, send-
oﬀuses a dynamic threadpool and blocking is tolerated - and that’s the
right approach here as ant contention for the same location/food can cer-
tainly cause (temporary) blocking.
124 CHAPTER 4. THE ANTS DEMO (KAI WU)
Determining what the ant does next
Finally, the ant’s logic for what to do next is in the large ifexpression. The
code looks dense but at the top level it’s just a binary choice:
•If the ant has food, take it home; the condspeciﬁes 3 sub-cases:
1. At a home cell, drop the food and turn around 180 degrees, to ex it
home for more food.
2. If a home cell is ahead, move to it.
3. Otherwise, do a ranking of cells ahead ( placeshas the cells ahead,
ahead-left ,ahead-right ) perpresenceofpheromones,orhome, and
then randomly select from those 3 cells per their ranking/weighting.
4.1.7 World behavior: pheromone evaporation
— evaporate —
(defn evaporate
"Causes all the pheromones to evaporate a bit."
[]
(dorun
(for [x (range dim) y (range dim)]
(dosync
(let [p (place [x y])]
(alter p assoc :pher (* evap-rate (:pher @p))))))))
———-
For a bit of realism and a cleaner UI/visual, it’s useful to have the ant s’
pheromones diminish and evaporate from the world over time. The evapo-
ratefunction fulﬁlls that requirement:
•It takes no arguments, it will work over the entire world/board of c ells,
accessed via the tuples of xandy.
•Thedorunfunction takes a lazy collection/sequence(here, that of the for
expression) and forces the realization of that collection for its side eﬀects,
discarding any returned values.
–It’s unlike the similarly-named doallwhere we do care about the
values.
–And it’s unlike doseq, which is like Clojure’s forbut runs immedi-
ately and does not collect the results.
4.2. THE UI 125
•dosyncis used as before, for lock-free updating of a placecell. Here, the
desired side-eﬀect/“mutation” is to update the :phervalue at the place
cell with a lower number.
We’ll see shortly that evaporate will run every second, a process that (like the
ants) will be handled asynchronously using a Clojure agent.
4.2 The UI
The user interface for the ants relies heavily on Clojure’s Java inter -operation
capabilities. But as we’ll see, it’s more than just wrapping calls to Java .
4.2.1 Using the Java AWT
— clojureUI —
;;;;;;;;;;;;;;;;;;;;;;;; UI ;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;
(import
’(java.awt Color Graphics Dimension)
’(java.awt.image BufferedImage)
’(javax.swing JPanel JFrame))
———-
Theimportpulls in classes from Java’sAbstract Window Toolkit (AWT) pack-
age,andfromtheJavaSwingpackage. Assumingunfamiliaritywith Ja vaSwing,
let’s describe the classes used:
•TheColorclass encapsulates a color in the standard RGB color space.
In the code below, its usage as a constructor for a color instance f ollows
several arities:
–4 integer arguments: r, g, b, and a for the alpha/transparency ( 0
transparent, 255 opaque)
–3 integer arguments: r g b
–1 argument: not a constructor call, but an access of a predeﬁned
staticColorﬁeld by name, returning the color in the RGB color
space.
•TheGraphics class is an abstract base class for all graphics contexts, i.e.
aGraphics instance holds the current state data needed for rendering
it: theComponent object on which to draw, the current clip, color, and
126 CHAPTER 4. THE ANTS DEMO (KAI WU)
font, etc. Below, we’llseethat the Clojurefunctions that takea Graphics
instance as an argument:
– ﬁll-cell
– render-ant
– render-place
– render
...all do some kind of rendering/drawing.
•TheDimension class encapsulates the integer width and height ofa com-
ponent. This class is used just once below, in setting the size of the p anel
of the UI.
•BuﬀeredImage class is needed for raster image data; below, the render
function uses it to paint the background panel.
•TheJPanelclass is the generic “lightweight” UI container in Java Swing
(seems like the divelement in HTML). Below, it’s used just once for the
main display.
•TheJFrame class creates a top-level window (w/ title and border) in
Swing; it’s used just once below for the main ants UI window.
4.2.2 Functions to render the board and the ants
Each discrete cell on the world board is a square matrix of pixels; with an odd
number of pixels chosen, we can have a central position:
— UI-scale —
;pixels per world cell
(def scale 5)
———-
Bydefault, cellsareempty; drawingcellshavingfoodorant-deposit edpheromones
is done by ﬁlling with symbolic colors - here by running the Java methods set-
ColorandﬁllRect:
— UI-ﬁll-cell —
(defn fill-cell [#^Graphics g x y c]
(doto g
(.setColor c)
(.fillRect (* x scale) (* y scale) scale scale)))
4.2. THE UI 127
———-
Note the use of the dotofunction here and in many places below: in Java, pro-
cedural mutation of a newly constructed instance is common for init ialization.
Clojure’s dotofunction is meant to be more concise in specifying the target
object just once, and then methods/setters acting on it and the n returning it,
implicitly.
Drawing an ant: the graphical appearance of an ant is just a (5-pix el long) line
pointing in one of the 8 cardinal directions, of two diﬀerent colors (h aving food
or not):
— UI-render-ant —
(defn render-ant [ant #^Graphics g x y]
(let [black (. (new Color 0 0 0 255) (getRGB))
gray (. (new Color 100 100 100 255) (getRGB))
red (. (new Color 255 0 0 255) (getRGB))
[hx hy tx ty] ({0 [2 0 2 4] ; Up/North pointing
1 [4 0 0 4]
2 [4 2 0 2]
3 [4 4 0 0]
4 [2 4 2 0] ; Down/South
5 [0 4 4 0]
6 [0 2 4 2]
7 [0 0 4 4]}
(:dir ant))]
(doto g
(.setColor (if (:food ant)
(new Color 255 0 0 255)
(new Color 0 0 0 255)))
(.drawLine (+ hx (* x scale)) (+ hy (* y scale))
(+ tx (* x scale)) (+ ty (* y scale))))))
———-
Note the cleverly concise destructuring for the start and end dra wing coordi-
nates, needed in AWT’s drawLine method.
If a cell in the ants’ world is not empty, it has one or more of three th ings
present: pheromone, food, or an ant. The render-place function updates the
cell’s appearance accordingly:
— UI-render-place —
(defn render-place [g p x y]
(when (pos? (:pher p))
(fill-cell g x y (new Color 0 255 0
(int (min 255 (* 255 (/ (:pher p) pher-scale)))))))
(when (pos? (:food p))
(fill-cell g x y (new Color 255 0 0
(int (min 255 (* 255 (/ (:food p) food-scale)))))))
128 CHAPTER 4. THE ANTS DEMO (KAI WU)
(when (:ant p)
(render-ant (:ant p) g x y)))
———-
Finally,the renderfunctiontieseverythingtogether: initializingtheUI/window
appearance by applying render place to every cell, and also drawing the home
space of the ants. Note the heavy usage of the dot special form: the UI code
relies heavily on Java, though Clojure’s foranddotohelp us avoid Java boil-
erplate and stay concise:
— UI-render —
(defn render [g]
(let [v (dosync (apply vector (for [x (range dim) y (range dim )]
@(place [x y]))))
img (new BufferedImage (* scale dim) (* scale dim)
(. BufferedImage TYPE_INT_ARGB))
bg (. img (getGraphics))]
;; First paint everything white, on the bg instance:
(doto bg
(.setColor (. Color white))
(.fillRect 0 0 (. img (getWidth)) (. img (getHeight))))
(dorun
(for [x (range dim) y (range dim)]
(render-place bg (v (+ (* x dim) y)) x y)))
;; Draw the home space of the ants:
(doto bg
(.setColor (. Color blue))
(.drawRect (* scale home-offset) (* scale home-offset)
(* scale nants-sqrt) (* scale nants-sqrt)))
(. g (drawImage img 0 0 nil))
(. bg (dispose)))) ; Finished using Graphics object, releas e it.
———-
4.2.3 Setting the scene, then updating it continually
Almostreadytobeginoursimulation; weneedtosetupsomeadditiona lelements
per AWT conventions: the main UI panelwhere visual changes take place, the
top-level window frame, and an animator agent that continually updates the
visual elements:
— UI-panel —
(def panel (doto
(proxy [JPanel] [] (paint [g] (render g)))
(.setPreferredSize (new Dimension
4.2. THE UI 129
(* scale dim)
(* scale dim)))))
(def frame (doto (new JFrame) (.add panel) .pack .show))
———-
Animation, panel-by-panel
Now for bringing the static starting “picture” to life - like the cartoo ns of old,
theanimation function will “draw” the next state of the main panel displaying
the ants. Below, Hickey uses the queue-itself-then-run, again-a nd-again code
pattern we’ve seen before (above, in updating an ant’s state):
— UI-animation —
(def animator (agent nil))
(defn animation [x]
(when running
(send-off *agent* #’animation))
(. panel (repaint))
(. Thread (sleep animation-sleep-ms))
nil)
———-
Finally, we need another agent to handle one more time-track of cha nges: evap-
oration, using the evaporate function deﬁned above.
— UI-evaporation —
(def evaporator (agent nil))
(defn evaporation [x]
(when running
(send-off *agent* #’evaporation))
(evaporate)
(. Thread (sleep evap-sleep-ms))
nil)
———-
130 CHAPTER 4. THE ANTS DEMO (KAI WU)
4.3 Running the Program
4.3.1 Running the simulator
At the REPL, you can enter the entire doexpression below, or try each line
within it separately:
— runtheprogram —
(do
(load-file "./literate-ants.clj")
(def ants (setup))
(send-off animator animation)
(dorun (map #(send-off % behave) ants))
(send-off evaporator evaporation))
———-
Either way you’ll see a new window appear with a white background, blu e
square representing the ants’ home, red squares of food, black or red (w/ food)
moving lines representing each ant, and green squares for pherom ones in various
concentrations. A lot happening concurrently, with no locks, and b eautifully
concise code - welcome to Clojure!
— The Ants Demo —
\getchunk{sim-world-setup}
\getchunk{cell}
\getchunk{sim-world-board-creation}
\getchunk{place}
\getchunk{ants-defined}
\getchunk{home-setup}
\getchunk{world-wrapping}
\getchunk{ant-agent-judgment-2}
\getchunk{ant-agent-turn}
\getchunk{ant-agent-move}
\getchunk{ant-agent-food}
\getchunk{ant-agent-judgment-1}
\getchunk{ant-agent-behave}
\getchunk{evaporate}
\getchunk{clojureUI}
\getchunk{UI-scale}
\getchunk{UI-fill-cell}
\getchunk{UI-render-ant}
\getchunk{UI-render-place}
\getchunk{UI-render}
\getchunk{UI-panel}
\getchunk{UI-animation}
\getchunk{UI-evaporation}
4.3. RUNNING THE PROGRAM 131
\getchunk{runtheprogram}
———-
132 CHAPTER 4. THE ANTS DEMO (KAI WU)
Chapter 5
Parallel Processing
5.1 Natural Graphs
Could we do massively parallel work in “native” lisp (i.e. not just a swig co ver
for MPI). Could we develop a lisp graph data structure that was des igned to be
run in parallel with multiple processes (aka closures, continuations) “owning”
subgraphs and using the subgraph edges leaving their “clades” as n atural com-
munication paths? That way we could develop a “natural map” from t he graph
to the available resources.
It raises interesting questions, such as how to dynamically allocate t he graph
map to nodes transparently, similar to the way garbage collection is n ow trans-
parent. This would allow Lisp programs to be written against the grap h and
run in parallel without knowing about parallel issues. The immutable da ta
structures and STM would help with the coordination and state issue s.
The combination of a processor and a subgraph is called a “clade”, sim ilar to
the idea of calling a processor and a program a “process”.
5.2 Steele’s parallel ideas
From Steele [Ste09] we ﬁnd the following ideas:
•eﬀective parallelism uses trees
•associative combining operators are good
•mapreduce is good
•catamorphisms are good
•there are systematic strategies for parallizing sequential code
•we must lose the accumulator paradigm
•we must emphasize divide and conquer
133
134 CHAPTER 5. PARALLEL PROCESSING
Contrast good sequential code and good parallel code
•good sequential code minimizes total number of operations
–clever tricks to reuse previously computed results
–good parallel code often performs redundant operations to redu ce
communication
•good sequential algorithms minimize space usage
–clever tricks to reuse storage
–good parallel code often requires extra space to permit temporal de-
coupling
•sequential idioms stress linear problem decomposition
–process on thing at a time and accumulate results
–good parallel code usually requires multiway problem
•linearly linked lists are inherently sequential
–compare peano arithmetic: 5 = ((((0+1)+1)+1)+1)+1
–binary arithmetic is much more eﬃcient than unayr
•we need a multiway decomposition paradigm
length [ ] = 0
length [a] = 1
length (a++b) = (length a) + (length b)
This is just a summation problem: adding up a bunch of 1’s!
Total work: Θ( n)
Delay: Ω( log n),O(n) depending on how a++b is split even worse if splitting
has worse than constant cost
Thoughts
What you want to do versus how you want to do it.
Give the compiler wiggle room. The wiggle room concept is based on the id ea
that certain mathematical properties allow the compiler to rewrite a computa-
tion into a parallel form. So the idea of associativity, which allows term s of an
expression to be grouped in arbitrary ways without aﬀecting the co mputation
allows us to rewrite
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8
as
((1 + 2) + (3 + 4)) + ((5 + 6) + (7 + 8))
which then allows the compiler to add the subterms and then add their results.
Steele identiﬁes several mathematical properties that the compile r can exploit:
5.2. STEELE’S PARALLEL IDEAS 135
•associativity
•commutativity
What are the parallel operators. Which of these parallel operator s are thinking
vs implementation.
Could the add tree be log 32 since add can be multi-arg? Is there a map ping
from persistent trees to parallel code?
Clojure could partition tasks based on log32. A better, more ﬁne gr ained alter-
native is to use [55] bit-partitioning to split tasks based on the size of the task
and the number of processors. That is,
(partition chunksize processors)
Concatenation lists give wiggle room. That is,
•<>is the empty list
•<23>is a singleton list
•< a || b > is a concatenation of a and b
so
<<23 || 47> || <18 || 11>>
||
||
23 47||
18 11
but the same list could be:
<<<23 || 47> || 18> || 11>
136 CHAPTER 5. PARALLEL PROCESSING
||
||
||
23 471811
or
<<23 || <47 || <>>> || <18 || <<> || 11>>>
||
||
23 ||
47 /||
18 ||
/11
or
<23 || <47 || <18 || <11 || <>>>>>
5.3. SEQUENTIAL MAPREDUCE 137
||
23 ||
47 ||
18 ||
11 /
5.3 Sequential mapreduce
For the list form Steele deﬁnes three operators, map, reduce, an d mapreduce.
They are:
— Steele map —
(define (map f xs) ; linear in (length xs)
(cond ((null? xs) ’())
(else (cons (f (car xs)) (map f (cdr xs))))))
———-
so, for example,
(map (λ(x) (* x x)) ’(1 2 3)) ⇒(1 4 9)
— Steele reduce —
(define (reduce g id xs) ; linear in (length xs)
(cond ((null? xs) id)
(else (g (car xs) (reduce g id (cdr xs))))))
———-
so, for example,
138 CHAPTER 5. PARALLEL PROCESSING
(reduce + 0 ’(1 4 9)) ⇒14
— Steele mapreduce —
(define (mapreduce f g id xs) ; linear in (length xs)
(ocnd ((null? xs) id)
(else (g (f (car xs)) (mapreduce f g id (cdr xs))))))
———-
so, for example,
(mapreduce ( λ(x) (* x x)) + 0 ’(1 2 3)) Rightarrow 14
— Steele length —
(define (length xs) ; linear in (length xs)
(mapreduce (lambda (q) 1) + 0 xs))
———-
Using structural recursion, we can deﬁne ﬁlter as:
— Steele ﬁlter —
(define (filter p xs) ; linear in (length xs)
(cond ((null? xs) ’())
((p (car xs)) (cons p (filter p (cdr xs))))
(else (filter p (cdr x)))))
———-
Alternatively we could map the predicate down the list:
— Steele ﬁlter 2 —
(define (filter p xs) ; linear in (length xs)??
(apply append
(map (lambda (x) (if (p x) (list x) ’())) xs)))
———-
Or, by using mapreduce
— Steele ﬁlter 3 —
(define (filter p xs) ; linear in (length xs)!!
(mapreduce (lambda (x) (if (p x) (list x) ’()))
append ’() xs)) ; each call to append is constant time
———-
The reverse function could be deﬁned structurally as:
— Steele reverse 1 —
5.3. SEQUENTIAL MAPREDUCE 139
(define (reverse xs) ; quadratic in (length xs)
(cond ((null? xs) ’())
(else (addright (reverse (cdr xs)) (car xs)))))
———-
Or we could deﬁne a new function, revappend, by using the accumula tor trick
to reduce the time complexity from quadratic to linear.
— Steele revappend —
(define (revappend xs ys) ; linear in (length xs)
(cond ((null? xs) ys)
(else (revappend (cdr xs) (cons (car xs) ys)))))
———-
and use it to deﬁne reverse:
— Steele reverse 2 —
(define (reverse xs) ; linear in (length xs)
(revappend xs ’()))
———-
5.3.1 Parallel mapreduce
— Steele parallel mapreduce —
(define (mapreduce f g id xs) ; logarithmic in (length xs)??
(ocnd ((null? xs) id)
((singleton? xs) (f (item xs)))
(else (split xs (lambda (ys zs)
(g (mapreduce f g id ys) ; opportunity for
(mapreduce f g id zs))))))) ; parallelism
———-
— Steele parallel map —
(define (map f xs)
(mapreduce (lambda (x) (list (f x))) append ’() xs)) ; or conc
———-
— Steele parallel reduce —
140 CHAPTER 5. PARALLEL PROCESSING
(define (reduce g id xs)
(mapreduce (lambda (x) x) g id xs))
———-
— Steele parallel length —
(define (length xs) ; logarithmic in (length xs)??
(mapreduce (lambda (q) 1) + 0 xs))
———-
— Steele parallel ﬁlter —
(define (filter p xs) ; logarithmic in (length xs)??
(mapreduce (lambda (x) (if (p x) (list x) ’()))
append ’() xs))
———-
— Steele parallel reverse —
(define (reverse xs) ; logarithmic in (length xs)??
(mapreduce list (lambda (ys zx) (append zs ys)) ’() xs))
———-
•for ﬁlter, unlike summation, we rely on maintaining the original order o f
the elements in the input list. Thus ||and + are associative, but only +
is commutative.
•do not confuse the orderingof elements in the result list (which is a sp atial
order) with the order in which they are computed (which is a tempora l
order)
•sequential programming often ties spatial order to temporal ord er
•it is incorrect to say that since I don’t pay attention to the order in w hich
things are done then we require commutativity. But commutativity h as
to do with the spatial ordering in the result, not the temporal orde r in
which they are computed.
Steele deﬁnes “Conjugate Transforms” which, instead of mapping input items
directly to the output data type T:
•map inputs (maybe by way of T) to a richer data type U
5.4. MPI MESSAGE PASSING 141
•perform the computation in this richer space U (chosen to make com pu-
tation simpler or faster)
•ﬁnally, project the result from U back into T
Thought: he is just wrapping T with a structure for side information
Thought: much eﬀort needs to be placed on the combining operator
5.4 MPI Message Passing
5.4.1 The N-colony Ant Demo
5.5 MapReduce
142 CHAPTER 5. PARALLEL PROCESSING
Chapter 6
The ant build sequence
6.1 ant.build
— build.xml —
<project name="clojure" default="all" xmlns:mvn="urn:m aven-artifact-ant">
<description>
Build with "ant jar" and then start the
REPL with: "java -cp clojure.jar clojure.main".
You will need to install the Maven Ant
Tasks to ${ant.home}/lib in order to execute
the nightly-build or stable-build targets.
</description>
<property name="src" location="src"/>
<property name="test" location="test"/>
<property name="jsrc" location="${src}/jvm"/>
<property name="cljsrc" location="${src}/clj"/>
<property name="build" location="classes"/>
<property name="test-classes" location="test-classes" />
<property name="dist" location="dist"/>
<!-- override this with
-Ddeployment.url=scp://build.clojure.org/srv/test-d eploy
to test a deployment -->
<property name="deployment.url"
value="scp://build.clojure.org/srv/www/releases"/>
<target name="debug">
<echo message="${deployment.url}"/>
</target>
143
144 CHAPTER 6. THE ANT BUILD SEQUENCE
<!-- version related properties -->
<property file="${cljsrc}/clojure/version.properties "/>
<!-- ensures all version properties are present -->
<fail unless="clojure.version.major"/>
<fail unless="clojure.version.minor"/>
<fail unless="clojure.version.interim"/>
<condition property="clojure.version.incremental.lab el"
value=".${clojure.version.incremental}"
else="">
<length string="${clojure.version.incremental}"
when="greater" length="0" />
</condition>
<condition property="clojure.version.qualifier.label "
value="-${clojure.version.qualifier}"
else="">
<length string="${clojure.version.qualifier}" when="g reater"
length="0" />
</condition>
<condition property="clojure.version.interim.label"
value="-SNAPSHOT"
else="">
<!-- We place -SNAPSHOT whenever interim is not set to false, not
only if interim is set to true (this is less typo prone in the
worst case -->
<not><equals arg1="${clojure.version.interim}" arg2=" false"
trim="true"/></not>
</condition>
<property name="cvm" value="${clojure.version.major}" />
<property name="cvm1" value="${clojure.version.minor} "/>
<property name="cvil" value="${clojure.version.increm ental.label}"/>
<property name="cvql" value="${clojure.version.qualif ier.label}"/>
<property name="cvil1" value="${clojure.version.inter im.label}"/>
<property name="clojure.version.label"
value="${cvm}.${cvm1}${cvil}${cvql}${cvil}"/>
<!-- general filterset for use when clojure version must be c opied -->
<filterset id="clojure-version-filterset">
<filter token="clojure-version" value="${clojure.vers ion.label}"/>
</filterset>
<property name="clojure_noversion_jar" location="cloj ure.jar"/>
<property name="slim_noversion_jar" location="clojure -slim.jar"/>
<property name="src_noversion_jar" location="clojure- sources.jar"/>
<property name="clojure_jar"
location="clojure-${clojure.version.label}.jar"/>
<property name="slim_jar"
location="clojure-slim-${clojure.version.label}.jar "/>
<property name="src_jar"
6.1. ANT.BUILD 145
location="clojure-sources-${clojure.version.label}. jar"/>
<!-- These make sense for building on tapestry.formos.com - ->
<property name="snapshot.repo.dir"
location="/var/www/maven-snapshot-repository"/>
<property name="stable.repo.dir" location="/var/www/m aven-repository"/>
<target name="init" depends="clean">
<tstamp/>
<mkdir dir="${build}"/>
<antcall target="init-version"/>
</target>
<target name="init-version">
<copy file="pom-template.xml"
tofile="pom.xml">
<filterset refid="clojure-version-filterset"/>
</copy>
<!--prevents users from modifying accidentally the genera ted
pom.xml works only on linux.-->
<chmod file="pom.xml" perm="ugo-w"/>
</target>
<target name="compile-java" depends="init"
description="Compile Java sources.">
<javac srcdir="${jsrc}" destdir="${build}" includeJava Runtime="yes"
debug="true" target="1.5"/>
</target>
<target name="compile-clojure" depends="compile-java"
description="Compile Clojure sources.">
<java classname="clojure.lang.Compile"
classpath="${build}:${cljsrc}"
failonerror="true"
fork="true">
<sysproperty key="clojure.compile.path" value="${buil d}"/>
<!-- <sysproperty key="clojure.compile.warn-on-reflec tion"
value="true"/> -->
<arg value="clojure.core"/>
<arg value="clojure.core.protocols"/>
<arg value="clojure.main"/>
<arg value="clojure.set"/>
<arg value="clojure.xml"/>
<arg value="clojure.zip"/>
<arg value="clojure.inspector"/>
<arg value="clojure.walk"/>
<arg value="clojure.stacktrace"/>
<arg value="clojure.template"/>
<arg value="clojure.test"/>
146 CHAPTER 6. THE ANT BUILD SEQUENCE
<arg value="clojure.test.tap"/>
<arg value="clojure.test.junit"/>
<arg value="clojure.pprint"/>
<arg value="clojure.java.io"/>
<arg value="clojure.repl"/>
<arg value="clojure.java.browse"/>
<arg value="clojure.java.javadoc"/>
<arg value="clojure.java.shell"/>
<arg value="clojure.java.browse-ui"/>
<arg value="clojure.string"/>
<arg value="clojure.data"/>
<arg value="clojure.reflect"/>
</java>
</target>
<target name="build"
description="Build Clojure (compilation only, no tests). "
depends="compile-java, compile-clojure"/>
<target name="compile-tests"
description="Compile the subset of tests that require comp ilation.">
<delete dir="${test-classes}"/>
<mkdir dir="${test-classes}"/>
<java classname="clojure.lang.Compile"
classpath="${test-classes}:${test}:${build}:${cljsr c}"
failonerror="true">
<sysproperty key="clojure.compile.path" value="${test -classes}"/>
<arg value="clojure.test-clojure.protocols.examples" />
<arg value="clojure.test-clojure.genclass.examples"/ >
</java>
</target>
<target name="test"
description="Run clojure tests without recompiling cloju re."
depends="compile-tests">
<java classname="clojure.main" failonerror="true">
<classpath>
<path location="${test-classes}"/>
<path location="${test}"/>
<path location="${build}"/>
<path location="${cljsrc}"/>
</classpath>
<arg value="-e"/>
<arg value=
"(require ’(clojure [test-clojure :as main])) (main/run- ant)"/>
</java>
</target>
<target name="clojure-jar" depends="build"
description="Create clojure jar file.">
6.1. ANT.BUILD 147
<jar jarfile="${clojure_jar}" basedir="${build}">
<fileset dir="${cljsrc}">
<include name="**/*.clj"/>
<include name="clojure/version.properties"/>
</fileset>
<manifest>
<attribute name="Main-Class" value="clojure.main"/>
<attribute name="Class-Path" value="."/>
</manifest>
</jar>
<copy file="${clojure_jar}" tofile="${clojure_noversi on_jar}" />
</target>
<target name="clojure-jar-slim" depends="build"
description=
"Create clojure-slim jar file (omits compiled Clojure code ).">
<jar jarfile="${slim_jar}">
<fileset dir="${build}" includes="clojure/asm/**"/>
<fileset dir="${build}" includes="clojure/lang/**"/>
<fileset dir="${build}" includes="clojure/main.class" />
<fileset dir="${cljsrc}">
<include name="**/*.clj"/>
<include name="clojure/version.properties"/>
</fileset>
<manifest>
<attribute name="Main-Class" value="clojure.main"/>
<attribute name="Class-Path" value="."/>
</manifest>
</jar>
<copy file="${slim_jar}" tofile="${slim_noversion_jar }" />
</target>
<target name="clojure-jar-sources" depends="build"
description="Create a JAR of Java sources.">
<jar jarfile="${src_jar}" basedir="${jsrc}" includes=" **/*">
<fileset dir="${cljsrc}"
includes="clojure/version.properties"/>
</jar>
<copy file="${src_jar}" tofile="${src_noversion_jar}" />
</target>
<target name="all"
depends=
"build,test,clojure-jar,clojure-jar-slim,clojure-ja r-sources"/>
<target name="clean"
description="Remove autogenerated files and directories .">
<delete dir="${build}"/>
<delete dir="${test-classes}"/>
<delete dir="${dist}"/>
148 CHAPTER 6. THE ANT BUILD SEQUENCE
<delete file="pom.xml"/>
<delete verbose="true">
<fileset dir="${basedir}" includes="*.jar"/>
<fileset dir="${basedir}" includes="*.zip"/>
</delete>
</target>
<target name="setup-maven">
<typedef resource="org/apache/maven/artifact/ant/ant lib.xml"
uri="urn:maven-artifact-ant"/>
</target>
<target name="nightly-build" depends="ci-build"
description="Build and deploy to nightly (snapshot) repos itory.">
<sequential>
<typedef resource="org/apache/maven/artifact/ant/ant lib.xml"
uri="urn:maven-artifact-ant"/>
<mvn:deploy file="${clojure_jar}">
<pom file="pom.xml"/>
<attach file="${src_jar}" classifier="sources"/>
<attach file="${slim_jar}" classifier="slim"/>
<remoteRepository url="file:${snapshot.repo.dir}"/>
</mvn:deploy>
</sequential>
</target>
<target name="release" depends="ci-build,dist"
description="Build and deploy to remote stable repository .">
<sequential>
<typedef resource="org/apache/maven/artifact/ant/ant lib.xml"
uri="urn:maven-artifact-ant"/>
<mvn:install-provider artifactId="wagon-ssh" version= "1.0-beta-2"/>
<echo message="Deploying to ${deployment.url}"/>
<mvn:deploy file="${clojure_jar}">
<pom file="pom.xml"/>
<attach file="${src_jar}" classifier="sources"/>
<attach file="${slim_jar}" classifier="slim"/>
<remoteRepository url="${deployment.url}">
<authentication username="root"
privateKey="${user.home}/.ssh/id_rsa"/>
</remoteRepository>
</mvn:deploy>
</sequential>
</target>
<target name="ci-build" depends="clean,all,setup-mave n"
description=
"Continous integration build, installed to local reposito ry.">
<mvn:install file="${clojure_jar}">
<pom file="pom.xml"/>
6.2. THE EXECUTION 149
<attach file="${src_jar}" classifier="sources"/>
<attach file="${slim_jar}" classifier="slim"/>
</mvn:install>
</target>
<target name="dist" depends="clean,clojure-jar"
description="Build distribution ZIP file.">
<property name="distdir"
value="${dist}/clojure-${clojure.version.label}"/>
<mkdir dir="${distdir}"/>
<copy todir="${distdir}" includeEmptyDirs="false">
<fileset dir="${basedir}">
<exclude name="pom.xml"/>
<exclude name="**/.git/**"/>
<exclude name="**/*.class"/>
<exclude name="**/*.iml"/>
<exclude name="**/*.ipr"/>
<exclude name="**/*.iws"/>
<exclude name="**/*.jar"/>
</fileset>
</copy>
<copy file="${clojure_noversion_jar}" todir="${distdi r}"/>
<zip basedir="${dist}"
destfile="clojure-${clojure.version.label}.zip"/>
</target>
</project>
———-
6.2 The Execution
ant -v build
Apache Ant version 1.7.1 compiled on November 10 2008
Buildfile: build.xml
Detected Java version: 1.6 in: /usr/lib/jvm/java-6-sun-1 .6.0.13/jre
Detected OS: Linux
parsing buildfile BASE/build.xml
with URI = file:BASE/build.xml
Project base dir set to: BASE
[antlib:org.apache.tools.ant] Could not load definition s from resource
org/apache/tools/ant/antlib.xml. It could not be found.
[property] Loading BASE/src/clj/clojure/version.prope rties
Build sequence for target(s) ‘build’ is
[clean, init, compile-java, compile-clojure, build]
Complete build sequence is
[clean, init, compile-java, compile-clojure, build, setu p-maven,
init-version, compile-tests, test, clojure-jar, clojure -jar-slim,
clojure-jar-sources, all, ci-build, nightly-build, debu g, dist,
150 CHAPTER 6. THE ANT BUILD SEQUENCE
release, ]
clean:
[delete] Could not find file BASE/pom.xml to delete.
init:
[mkdir] Created dir: BASE/classes
Project base dir set to: BASE
[antcall] calling target(s) [init-version] in build file
BASE/build.xml
parsing buildfile BASE/build.xml with
URI = file:BASE/build.xml
Project base dir set to: BASE
Override ignored for property "src"
Override ignored for property "test"
Override ignored for property "jsrc"
Override ignored for property "cljsrc"
Override ignored for property "build"
Override ignored for property "test-classes"
Override ignored for property "dist"
Override ignored for property "deployment.url"
[property] Loading BASE/src/clj/clojure/version.prope rties
Override ignored for property "clojure.version.qualifie r"
Override ignored for property "clojure.version.major"
Override ignored for property "clojure.version.interim"
Override ignored for property "clojure.version.incremen tal"
Override ignored for property "clojure.version.minor"
Override ignored for property "clojure.version.incremen tal.label"
Override ignored for property "clojure.version.qualifie r.label"
Override ignored for property "clojure.version.interim. label"
Override ignored for property "clojure.version.label"
Override ignored for property "clojure_noversion_jar"
Override ignored for property "slim_noversion_jar"
Override ignored for property "src_noversion_jar"
Override ignored for property "clojure_jar"
Override ignored for property "slim_jar"
Override ignored for property "src_jar"
Override ignored for property "snapshot.repo.dir"
Override ignored for property "stable.repo.dir"
Build sequence for target(s) ‘init-version’ is [init-vers ion]
Complete build sequence is
[init-version, setup-maven, clean, init, compile-java,
compile-clojure, build, compile-tests, test, clojure-ja r,
clojure-jar-slim, clojure-jar-sources, all, ci-build,
nightly-build, debug, dist, release, ]
[antcall] Entering BASE/build.xml...
Build sequence for target(s) ‘init-version’ is [init-vers ion]
Complete build sequence is
[init-version, setup-maven, clean, init, compile-java,
compile-clojure, build, compile-tests, test, clojure-ja r,
6.2. THE EXECUTION 151
clojure-jar-slim, clojure-jar-sources, all, ci-build,
nightly-build, debug, dist, release, ]
init-version:
[copy] Copying 1 file to BASE
[copy] Copying BASE/pom-template.xml to BASE/pom.xml
Replacing: @clojure-version@ -> 1.3.0-master-SNAPSHOT
[chmod] Current OS is Linux
[chmod] Executing ’chmod’ with arguments:
[chmod] ’ugo-w’
[chmod] ’BASE/pom.xml’
[chmod]
[chmod] The ’ characters around the executable and argument s are
[chmod] not part of the command.
[chmod] Applied chmod to 1 file and 0 directories.
[antcall] Exiting BASE/build.xml.
compile-java:
[javac] clojure/asm/AnnotationVisitor.java added as
clojure/asm/AnnotationVisitor.class doesn’t exist.
[javac] clojure/asm/AnnotationWriter.java added as
clojure/asm/AnnotationWriter.class doesn’t exist.
[javac] clojure/asm/Attribute.java added as
clojure/asm/Attribute.class doesn’t exist.
[javac] clojure/asm/ByteVector.java added as
clojure/asm/ByteVector.class doesn’t exist.
[javac] clojure/asm/ClassAdapter.java added as
clojure/asm/ClassAdapter.class doesn’t exist.
[javac] clojure/asm/ClassReader.java added as
clojure/asm/ClassReader.class doesn’t exist.
[javac] clojure/asm/ClassVisitor.java added as
clojure/asm/ClassVisitor.class doesn’t exist.
[javac] clojure/asm/ClassWriter.java added as
clojure/asm/ClassWriter.class doesn’t exist.
[javac] clojure/asm/Edge.java added as
clojure/asm/Edge.class doesn’t exist.
[javac] clojure/asm/FieldVisitor.java added as
clojure/asm/FieldVisitor.class doesn’t exist.
[javac] clojure/asm/FieldWriter.java added as
clojure/asm/FieldWriter.class doesn’t exist.
[javac] clojure/asm/Frame.java added as
clojure/asm/Frame.class doesn’t exist.
[javac] clojure/asm/Handler.java added as
clojure/asm/Handler.class doesn’t exist.
[javac] clojure/asm/Item.java added as
clojure/asm/Item.class doesn’t exist.
[javac] clojure/asm/Label.java added as
clojure/asm/Label.class doesn’t exist.
[javac] clojure/asm/MethodAdapter.java added as
clojure/asm/MethodAdapter.class doesn’t exist.
152 CHAPTER 6. THE ANT BUILD SEQUENCE
[javac] clojure/asm/MethodVisitor.java added as
clojure/asm/MethodVisitor.class doesn’t exist.
[javac] clojure/asm/MethodWriter.java added as
clojure/asm/MethodWriter.class doesn’t exist.
[javac] clojure/asm/Opcodes.java added as
clojure/asm/Opcodes.class doesn’t exist.
[javac] clojure/asm/Type.java added as
clojure/asm/Type.class doesn’t exist.
[javac] clojure/asm/commons/AdviceAdapter.java added a s
clojure/asm/commons/AdviceAdapter.class doesn’t exist .
[javac] clojure/asm/commons/AnalyzerAdapter.java adde d as
clojure/asm/commons/AnalyzerAdapter.class doesn’t exi st.
[javac] clojure/asm/commons/CodeSizeEvaluator.java ad ded as
clojure/asm/commons/CodeSizeEvaluator.class doesn’t e xist.
[javac] clojure/asm/commons/EmptyVisitor.java added as
clojure/asm/commons/EmptyVisitor.class doesn’t exist.
[javac] clojure/asm/commons/GeneratorAdapter.java add ed as
clojure/asm/commons/GeneratorAdapter.class doesn’t ex ist.
[javac] clojure/asm/commons/LocalVariablesSorter.jav a added as
clojure/asm/commons/LocalVariablesSorter.class doesn ’t exist.
[javac] clojure/asm/commons/Method.java added as
clojure/asm/commons/Method.class doesn’t exist.
[javac] clojure/asm/commons/SerialVersionUIDAdder.ja va added as
clojure/asm/commons/SerialVersionUIDAdder.class
doesn’t exist.
[javac] clojure/asm/commons/StaticInitMerger.java add ed as
clojure/asm/commons/StaticInitMerger.class doesn’t ex ist.
[javac] clojure/asm/commons/TableSwitchGenerator.jav a added as
clojure/asm/commons/TableSwitchGenerator.class doesn ’t exist.
[javac] BASE/src/jvm/clojure/asm/commons/package.htm l
skipped - don’t know how to handle it
[javac] BASE/src/jvm/clojure/asm/package.html
skipped - don’t know how to handle it
[javac] clojure/lang/AFn.java added as
clojure/lang/AFn.class doesn’t exist.
[javac] clojure/lang/AFunction.java added as
clojure/lang/AFunction.class doesn’t exist.
[javac] clojure/lang/AMapEntry.java added as
clojure/lang/AMapEntry.class doesn’t exist.
[javac] clojure/lang/APersistentMap.java added as
clojure/lang/APersistentMap.class doesn’t exist.
[javac] clojure/lang/APersistentSet.java added as
clojure/lang/APersistentSet.class doesn’t exist.
[javac] clojure/lang/APersistentVector.java added as
clojure/lang/APersistentVector.class doesn’t exist.
[javac] clojure/lang/ARef.java added as
clojure/lang/ARef.class doesn’t exist.
[javac] clojure/lang/AReference.java added as
clojure/lang/AReference.class doesn’t exist.
[javac] clojure/lang/ASeq.java added as
6.2. THE EXECUTION 153
clojure/lang/ASeq.class doesn’t exist.
[javac] clojure/lang/ATransientMap.java added as
clojure/lang/ATransientMap.class doesn’t exist.
[javac] clojure/lang/ATransientSet.java added as
clojure/lang/ATransientSet.class doesn’t exist.
[javac] clojure/lang/Agent.java added as
clojure/lang/Agent.class doesn’t exist.
[javac] clojure/lang/ArityException.java added as
clojure/lang/ArityException.class doesn’t exist.
[javac] clojure/lang/ArrayChunk.java added as
clojure/lang/ArrayChunk.class doesn’t exist.
[javac] clojure/lang/ArraySeq.java added as
clojure/lang/ArraySeq.class doesn’t exist.
[javac] clojure/lang/Associative.java added as
clojure/lang/Associative.class doesn’t exist.
[javac] clojure/lang/Atom.java added as
clojure/lang/Atom.class doesn’t exist.
[javac] clojure/lang/BigInt.java added as
clojure/lang/BigInt.class doesn’t exist.
[javac] clojure/lang/Binding.java added as
clojure/lang/Binding.class doesn’t exist.
[javac] clojure/lang/Box.java added as
clojure/lang/Box.class doesn’t exist.
[javac] clojure/lang/ChunkBuffer.java added as
clojure/lang/ChunkBuffer.class doesn’t exist.
[javac] clojure/lang/ChunkedCons.java added as
clojure/lang/ChunkedCons.class doesn’t exist.
[javac] clojure/lang/Compile.java added as
clojure/lang/Compile.class doesn’t exist.
[javac] clojure/lang/Compiler.java added as
clojure/lang/Compiler.class doesn’t exist.
[javac] clojure/lang/Cons.java added as
clojure/lang/Cons.class doesn’t exist.
[javac] clojure/lang/Counted.java added as
clojure/lang/Counted.class doesn’t exist.
[javac] clojure/lang/Delay.java added as
clojure/lang/Delay.class doesn’t exist.
[javac] clojure/lang/DynamicClassLoader.java added as
clojure/lang/DynamicClassLoader.class doesn’t exist.
[javac] clojure/lang/EnumerationSeq.java added as
clojure/lang/EnumerationSeq.class doesn’t exist.
[javac] clojure/lang/Fn.java added as
clojure/lang/Fn.class doesn’t exist.
[javac] clojure/lang/IChunk.java added as
clojure/lang/IChunk.class doesn’t exist.
[javac] clojure/lang/IChunkedSeq.java added as
clojure/lang/IChunkedSeq.class doesn’t exist.
[javac] clojure/lang/IDeref.java added as
clojure/lang/IDeref.class doesn’t exist.
[javac] clojure/lang/IEditableCollection.java added as
154 CHAPTER 6. THE ANT BUILD SEQUENCE
clojure/lang/IEditableCollection.class doesn’t exist.
[javac] clojure/lang/IFn.java added as
clojure/lang/IFn.class doesn’t exist.
[javac] clojure/lang/IKeywordLookup.java added as
clojure/lang/IKeywordLookup.class doesn’t exist.
[javac] clojure/lang/ILookup.java added as
clojure/lang/ILookup.class doesn’t exist.
[javac] clojure/lang/ILookupSite.java added as
clojure/lang/ILookupSite.class doesn’t exist.
[javac] clojure/lang/ILookupThunk.java added as
clojure/lang/ILookupThunk.class doesn’t exist.
[javac] clojure/lang/IMapEntry.java added as
clojure/lang/IMapEntry.class doesn’t exist.
[javac] clojure/lang/IMeta.java added as
clojure/lang/IMeta.class doesn’t exist.
[javac] clojure/lang/IObj.java added as
clojure/lang/IObj.class doesn’t exist.
[javac] clojure/lang/IPersistentCollection.java added as
clojure/lang/IPersistentCollection.class doesn’t exis t.
[javac] clojure/lang/IPersistentList.java added as
clojure/lang/IPersistentList.class doesn’t exist.
[javac] clojure/lang/IPersistentMap.java added as
clojure/lang/IPersistentMap.class doesn’t exist.
[javac] clojure/lang/IPersistentSet.java added as
clojure/lang/IPersistentSet.class doesn’t exist.
[javac] clojure/lang/IPersistentStack.java added as
clojure/lang/IPersistentStack.class doesn’t exist.
[javac] clojure/lang/IPersistentVector.java added as
clojure/lang/IPersistentVector.class doesn’t exist.
[javac] clojure/lang/IPromiseImpl.java added as
clojure/lang/IPromiseImpl.class doesn’t exist.
[javac] clojure/lang/IProxy.java added as
clojure/lang/IProxy.class doesn’t exist.
[javac] clojure/lang/IReduce.java added as
clojure/lang/IReduce.class doesn’t exist.
[javac] clojure/lang/IRef.java added as
clojure/lang/IRef.class doesn’t exist.
[javac] clojure/lang/IReference.java added as
clojure/lang/IReference.class doesn’t exist.
[javac] clojure/lang/ISeq.java added as
clojure/lang/ISeq.class doesn’t exist.
[javac] clojure/lang/ITransientAssociative.java added as
clojure/lang/ITransientAssociative.class doesn’t exis t.
[javac] clojure/lang/ITransientCollection.java added a s
clojure/lang/ITransientCollection.class doesn’t exist .
[javac] clojure/lang/ITransientMap.java added as
clojure/lang/ITransientMap.class doesn’t exist.
[javac] clojure/lang/ITransientSet.java added as
clojure/lang/ITransientSet.class doesn’t exist.
[javac] clojure/lang/ITransientVector.java added as
6.2. THE EXECUTION 155
clojure/lang/ITransientVector.class doesn’t exist.
[javac] clojure/lang/Indexed.java added as
clojure/lang/Indexed.class doesn’t exist.
[javac] clojure/lang/IndexedSeq.java added as
clojure/lang/IndexedSeq.class doesn’t exist.
[javac] clojure/lang/IteratorSeq.java added as
clojure/lang/IteratorSeq.class doesn’t exist.
[javac] clojure/lang/Keyword.java added as
clojure/lang/Keyword.class doesn’t exist.
[javac] clojure/lang/KeywordLookupSite.java added as
clojure/lang/KeywordLookupSite.class doesn’t exist.
[javac] clojure/lang/LazilyPersistentVector.java adde d as
clojure/lang/LazilyPersistentVector.class doesn’t exi st.
[javac] clojure/lang/LazySeq.java added as
clojure/lang/LazySeq.class doesn’t exist.
[javac] clojure/lang/LineNumberingPushbackReader.jav a added as
clojure/lang/LineNumberingPushbackReader.class doesn ’t exist.
[javac] clojure/lang/LispReader.java added as
clojure/lang/LispReader.class doesn’t exist.
[javac] clojure/lang/LockingTransaction.java added as
clojure/lang/LockingTransaction.class doesn’t exist.
[javac] clojure/lang/MapEntry.java added as
clojure/lang/MapEntry.class doesn’t exist.
[javac] clojure/lang/MapEquivalence.java added as
clojure/lang/MapEquivalence.class doesn’t exist.
[javac] clojure/lang/MethodImplCache.java added as
clojure/lang/MethodImplCache.class doesn’t exist.
[javac] clojure/lang/MultiFn.java added as
clojure/lang/MultiFn.class doesn’t exist.
[javac] clojure/lang/Named.java added as
clojure/lang/Named.class doesn’t exist.
[javac] clojure/lang/Namespace.java added as
clojure/lang/Namespace.class doesn’t exist.
[javac] clojure/lang/Numbers.java added as
clojure/lang/Numbers.class doesn’t exist.
[javac] clojure/lang/Obj.java added as
clojure/lang/Obj.class doesn’t exist.
[javac] clojure/lang/PersistentArrayMap.java added as
clojure/lang/PersistentArrayMap.class doesn’t exist.
[javac] clojure/lang/PersistentHashMap.java added as
clojure/lang/PersistentHashMap.class doesn’t exist.
[javac] clojure/lang/PersistentHashSet.java added as
clojure/lang/PersistentHashSet.class doesn’t exist.
[javac] clojure/lang/PersistentList.java added as
clojure/lang/PersistentList.class doesn’t exist.
[javac] clojure/lang/PersistentQueue.java added as
clojure/lang/PersistentQueue.class doesn’t exist.
[javac] clojure/lang/PersistentStructMap.java added as
clojure/lang/PersistentStructMap.class doesn’t exist.
[javac] clojure/lang/PersistentTreeMap.java added as
156 CHAPTER 6. THE ANT BUILD SEQUENCE
clojure/lang/PersistentTreeMap.class doesn’t exist.
[javac] clojure/lang/PersistentTreeSet.java added as
clojure/lang/PersistentTreeSet.class doesn’t exist.
[javac] clojure/lang/PersistentVector.java added as
clojure/lang/PersistentVector.class doesn’t exist.
[javac] clojure/lang/ProxyHandler.java added as
clojure/lang/ProxyHandler.class doesn’t exist.
[javac] clojure/lang/RT.java added as
clojure/lang/RT.class doesn’t exist.
[javac] clojure/lang/Range.java added as
clojure/lang/Range.class doesn’t exist.
[javac] clojure/lang/Ratio.java added as
clojure/lang/Ratio.class doesn’t exist.
[javac] clojure/lang/Ref.java added as
clojure/lang/Ref.class doesn’t exist.
[javac] clojure/lang/Reflector.java added as
clojure/lang/Reflector.class doesn’t exist.
[javac] clojure/lang/Repl.java added as
clojure/lang/Repl.class doesn’t exist.
[javac] clojure/lang/RestFn.java added as
clojure/lang/RestFn.class doesn’t exist.
[javac] clojure/lang/Reversible.java added as
clojure/lang/Reversible.class doesn’t exist.
[javac] clojure/lang/Script.java added as
clojure/lang/Script.class doesn’t exist.
[javac] clojure/lang/SeqEnumeration.java added as
clojure/lang/SeqEnumeration.class doesn’t exist.
[javac] clojure/lang/SeqIterator.java added as
clojure/lang/SeqIterator.class doesn’t exist.
[javac] clojure/lang/Seqable.java added as
clojure/lang/Seqable.class doesn’t exist.
[javac] clojure/lang/Sequential.java added as
clojure/lang/Sequential.class doesn’t exist.
[javac] clojure/lang/Settable.java added as
clojure/lang/Settable.class doesn’t exist.
[javac] clojure/lang/Sorted.java added as
clojure/lang/Sorted.class doesn’t exist.
[javac] clojure/lang/StringSeq.java added as
clojure/lang/StringSeq.class doesn’t exist.
[javac] clojure/lang/Symbol.java added as
clojure/lang/Symbol.class doesn’t exist.
[javac] clojure/lang/TransactionalHashMap.java added a s
clojure/lang/TransactionalHashMap.class doesn’t exist .
[javac] clojure/lang/Util.java added as
clojure/lang/Util.class doesn’t exist.
[javac] clojure/lang/Var.java added as
clojure/lang/Var.class doesn’t exist.
[javac] clojure/lang/XMLHandler.java added as
clojure/lang/XMLHandler.class doesn’t exist.
[javac] clojure/main.java added as
6.2. THE EXECUTION 157
clojure/main.class doesn’t exist.
[javac] Compiling 139 source files to BASE/classes
[javac] Using modern compiler
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/jre/li b/rt.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/Classes/jc e.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/Classes/js se.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/co re.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/gr aphics.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/se curity.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/se rver.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/xm l.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/Classes/cl asses.jar from path
as it doesn’t exist
dropping /usr/lib/jvm/java-6-sun-1.6.0.13/Classes/ui .jar from path
as it doesn’t exist
[javac] Compilation arguments:
[javac] ’-d’
[javac] ’BASE/classes’
[javac] ’-classpath’
[javac] ’BASE/classes:
/usr/share/ant/lib/ant-launcher.jar:
/usr/share/java/xmlParserAPIs.jar:
/usr/share/java/xercesImpl.jar:
/usr/share/ant/lib/ant-antlr.jar:
/usr/share/ant/lib/velocity.jar:
/usr/share/ant/lib/ant.jar:
/usr/share/ant/lib/commons-collections.jar:
/usr/share/ant/lib/werken.xpath.jar:
/usr/share/ant/lib/ant-jsch.jar:
/usr/share/ant/lib/ant-apache-regexp.jar:
/usr/share/ant/lib/jsch.jar:
/usr/share/ant/lib/ant-apache-oro.jar:
/usr/share/ant/lib/ant-jdepend.jar:
/usr/share/ant/lib/bcel.jar:
/usr/share/ant/lib/ant-jmf.jar:
/usr/share/ant/lib/ant-javamail.jar:
/usr/share/ant/lib/ant-commons-net.jar:
/usr/share/ant/lib/jdom0.jar:
/usr/share/ant/lib/ant-apache-bsf.jar:
/usr/share/ant/lib/ant-swing.jar:
/usr/share/ant/lib/logkit.jar:
/usr/share/ant/lib/ant-commons-logging.jar:
158 CHAPTER 6. THE ANT BUILD SEQUENCE
/usr/share/ant/lib/ant-apache-log4j.jar:
/usr/share/ant/lib/ant-apache-resolver.jar:
/usr/share/ant/lib/ant-trax.jar:
/usr/share/ant/lib/ant-apache-bcel.jar:
/usr/share/ant/lib/ant-junit.jar:
/usr/share/ant/lib/ant-nodeps.jar:
/usr/lib/jvm/java-6-sun-1.6.0.13/lib/tools.jar:
/usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/rt.jar:
/usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/jce.jar:
/usr/lib/jvm/java-6-sun-1.6.0.13/jre/lib/jsse.jar’
[javac] ’-sourcepath’
[javac] ’BASE/src/jvm’
[javac] ’-target’
[javac] ’1.5’
[javac] ’-g’
[javac]
[javac] The ’ characters around the executable and argument s are
[javac] not part of the command.
[javac] Files to be compiled:
BASE/src/jvm/clojure/asm/AnnotationVisitor.java
BASE/src/jvm/clojure/asm/AnnotationWriter.java
BASE/src/jvm/clojure/asm/Attribute.java
BASE/src/jvm/clojure/asm/ByteVector.java
BASE/src/jvm/clojure/asm/ClassAdapter.java
BASE/src/jvm/clojure/asm/ClassReader.java
BASE/src/jvm/clojure/asm/ClassVisitor.java
BASE/src/jvm/clojure/asm/ClassWriter.java
BASE/src/jvm/clojure/asm/Edge.java
BASE/src/jvm/clojure/asm/FieldVisitor.java
BASE/src/jvm/clojure/asm/FieldWriter.java
BASE/src/jvm/clojure/asm/Frame.java
BASE/src/jvm/clojure/asm/Handler.java
BASE/src/jvm/clojure/asm/Item.java
BASE/src/jvm/clojure/asm/Label.java
BASE/src/jvm/clojure/asm/MethodAdapter.java
BASE/src/jvm/clojure/asm/MethodVisitor.java
BASE/src/jvm/clojure/asm/MethodWriter.java
BASE/src/jvm/clojure/asm/Opcodes.java
BASE/src/jvm/clojure/asm/Type.java
BASE/src/jvm/clojure/asm/commons/AdviceAdapter.java
BASE/src/jvm/clojure/asm/commons/AnalyzerAdapter.ja va
BASE/src/jvm/clojure/asm/commons/CodeSizeEvaluator. java
BASE/src/jvm/clojure/asm/commons/EmptyVisitor.java
BASE/src/jvm/clojure/asm/commons/GeneratorAdapter.j ava
BASE/src/jvm/clojure/asm/commons/LocalVariablesSort er.java
BASE/src/jvm/clojure/asm/commons/Method.java
BASE/src/jvm/clojure/asm/commons/SerialVersionUIDAd der.java
BASE/src/jvm/clojure/asm/commons/StaticInitMerger.j ava
BASE/src/jvm/clojure/asm/commons/TableSwitchGenerat or.java
BASE/src/jvm/clojure/lang/AFn.java
6.2. THE EXECUTION 159
BASE/src/jvm/clojure/lang/AFunction.java
BASE/src/jvm/clojure/lang/AMapEntry.java
BASE/src/jvm/clojure/lang/APersistentMap.java
BASE/src/jvm/clojure/lang/APersistentSet.java
BASE/src/jvm/clojure/lang/APersistentVector.java
BASE/src/jvm/clojure/lang/ARef.java
BASE/src/jvm/clojure/lang/AReference.java
BASE/src/jvm/clojure/lang/ASeq.java
BASE/src/jvm/clojure/lang/ATransientMap.java
BASE/src/jvm/clojure/lang/ATransientSet.java
BASE/src/jvm/clojure/lang/Agent.java
BASE/src/jvm/clojure/lang/ArityException.java
BASE/src/jvm/clojure/lang/ArrayChunk.java
BASE/src/jvm/clojure/lang/ArraySeq.java
BASE/src/jvm/clojure/lang/Associative.java
BASE/src/jvm/clojure/lang/Atom.java
BASE/src/jvm/clojure/lang/BigInt.java
BASE/src/jvm/clojure/lang/Binding.java
BASE/src/jvm/clojure/lang/Box.java
BASE/src/jvm/clojure/lang/ChunkBuffer.java
BASE/src/jvm/clojure/lang/ChunkedCons.java
BASE/src/jvm/clojure/lang/Compile.java
BASE/src/jvm/clojure/lang/Compiler.java
BASE/src/jvm/clojure/lang/Cons.java
BASE/src/jvm/clojure/lang/Counted.java
BASE/src/jvm/clojure/lang/Delay.java
BASE/src/jvm/clojure/lang/DynamicClassLoader.java
BASE/src/jvm/clojure/lang/EnumerationSeq.java
BASE/src/jvm/clojure/lang/Fn.java
BASE/src/jvm/clojure/lang/IChunk.java
BASE/src/jvm/clojure/lang/IChunkedSeq.java
BASE/src/jvm/clojure/lang/IDeref.java
BASE/src/jvm/clojure/lang/IEditableCollection.java
BASE/src/jvm/clojure/lang/IFn.java
BASE/src/jvm/clojure/lang/IKeywordLookup.java
BASE/src/jvm/clojure/lang/ILookup.java
BASE/src/jvm/clojure/lang/ILookupSite.java
BASE/src/jvm/clojure/lang/ILookupThunk.java
BASE/src/jvm/clojure/lang/IMapEntry.java
BASE/src/jvm/clojure/lang/IMeta.java
BASE/src/jvm/clojure/lang/IObj.java
BASE/src/jvm/clojure/lang/IPersistentCollection.jav a
BASE/src/jvm/clojure/lang/IPersistentList.java
BASE/src/jvm/clojure/lang/IPersistentMap.java
BASE/src/jvm/clojure/lang/IPersistentSet.java
BASE/src/jvm/clojure/lang/IPersistentStack.java
BASE/src/jvm/clojure/lang/IPersistentVector.java
BASE/src/jvm/clojure/lang/IPromiseImpl.java
BASE/src/jvm/clojure/lang/IProxy.java
BASE/src/jvm/clojure/lang/IReduce.java
160 CHAPTER 6. THE ANT BUILD SEQUENCE
BASE/src/jvm/clojure/lang/IRef.java
BASE/src/jvm/clojure/lang/IReference.java
BASE/src/jvm/clojure/lang/ISeq.java
BASE/src/jvm/clojure/lang/ITransientAssociative.jav a
BASE/src/jvm/clojure/lang/ITransientCollection.java
BASE/src/jvm/clojure/lang/ITransientMap.java
BASE/src/jvm/clojure/lang/ITransientSet.java
BASE/src/jvm/clojure/lang/ITransientVector.java
BASE/src/jvm/clojure/lang/Indexed.java
BASE/src/jvm/clojure/lang/IndexedSeq.java
BASE/src/jvm/clojure/lang/IteratorSeq.java
BASE/src/jvm/clojure/lang/Keyword.java
BASE/src/jvm/clojure/lang/KeywordLookupSite.java
BASE/src/jvm/clojure/lang/LazilyPersistentVector.ja va
BASE/src/jvm/clojure/lang/LazySeq.java
BASE/src/jvm/clojure/lang/LineNumberingPushbackRead er.java
BASE/src/jvm/clojure/lang/LispReader.java
BASE/src/jvm/clojure/lang/LockingTransaction.java
BASE/src/jvm/clojure/lang/MapEntry.java
BASE/src/jvm/clojure/lang/MapEquivalence.java
BASE/src/jvm/clojure/lang/MethodImplCache.java
BASE/src/jvm/clojure/lang/MultiFn.java
BASE/src/jvm/clojure/lang/Named.java
BASE/src/jvm/clojure/lang/Namespace.java
BASE/src/jvm/clojure/lang/Numbers.java
BASE/src/jvm/clojure/lang/Obj.java
BASE/src/jvm/clojure/lang/PersistentArrayMap.java
BASE/src/jvm/clojure/lang/PersistentHashMap.java
BASE/src/jvm/clojure/lang/PersistentHashSet.java
BASE/src/jvm/clojure/lang/PersistentList.java
BASE/src/jvm/clojure/lang/PersistentQueue.java
BASE/src/jvm/clojure/lang/PersistentStructMap.java
BASE/src/jvm/clojure/lang/PersistentTreeMap.java
BASE/src/jvm/clojure/lang/PersistentTreeSet.java
BASE/src/jvm/clojure/lang/PersistentVector.java
BASE/src/jvm/clojure/lang/ProxyHandler.java
BASE/src/jvm/clojure/lang/RT.java
BASE/src/jvm/clojure/lang/Range.java
BASE/src/jvm/clojure/lang/Ratio.java
BASE/src/jvm/clojure/lang/Ref.java
BASE/src/jvm/clojure/lang/Reflector.java
BASE/src/jvm/clojure/lang/Repl.java
BASE/src/jvm/clojure/lang/RestFn.java
BASE/src/jvm/clojure/lang/Reversible.java
BASE/src/jvm/clojure/lang/Script.java
BASE/src/jvm/clojure/lang/SeqEnumeration.java
BASE/src/jvm/clojure/lang/SeqIterator.java
BASE/src/jvm/clojure/lang/Seqable.java
BASE/src/jvm/clojure/lang/Sequential.java
BASE/src/jvm/clojure/lang/Settable.java
6.2. THE EXECUTION 161
BASE/src/jvm/clojure/lang/Sorted.java
BASE/src/jvm/clojure/lang/StringSeq.java
BASE/src/jvm/clojure/lang/Symbol.java
BASE/src/jvm/clojure/lang/TransactionalHashMap.java
BASE/src/jvm/clojure/lang/Util.java
BASE/src/jvm/clojure/lang/Var.java
BASE/src/jvm/clojure/lang/XMLHandler.java
BASE/src/jvm/clojure/main.java
[javac] Note: Some input files use unchecked or unsafe opera tions.
[javac] Note: Recompile with -Xlint:unchecked for details .
compile-clojure:
[java] Executing ’/usr/lib/jvm/java-6-sun-1.6.0.13/jr e/bin/java’
with arguments:
[java] ’-Dclojure.compile.path=BASE/classes’
[java] ’-classpath’
[java] ’BASE/classes:BASE/src/clj’
[java] ’clojure.lang.Compile’
[java] ’clojure.core’
[java] ’clojure.core.protocols’
[java] ’clojure.main’
[java] ’clojure.set’
[java] ’clojure.xml’
[java] ’clojure.zip’
[java] ’clojure.inspector’
[java] ’clojure.walk’
[java] ’clojure.stacktrace’
[java] ’clojure.template’
[java] ’clojure.test’
[java] ’clojure.test.tap’
[java] ’clojure.test.junit’
[java] ’clojure.pprint’
[java] ’clojure.java.io’
[java] ’clojure.repl’
[java] ’clojure.java.browse’
[java] ’clojure.java.javadoc’
[java] ’clojure.java.shell’
[java] ’clojure.java.browse-ui’
[java] ’clojure.string’
[java] ’clojure.data’
[java] ’clojure.reflect’
[java]
[java] The ’ characters around the executable and arguments are
[java] not part of the command.
[java] Compiling clojure.core to BASE/classes
[java] Compiling clojure.core.protocols to BASE/classes
[java] Compiling clojure.main to BASE/classes
[java] Compiling clojure.set to BASE/classes
[java] Compiling clojure.xml to BASE/classes
[java] Compiling clojure.zip to BASE/classes
162 CHAPTER 6. THE ANT BUILD SEQUENCE
[java] Compiling clojure.inspector to BASE/classes
[java] Compiling clojure.walk to BASE/classes
[java] Compiling clojure.stacktrace to BASE/classes
[java] Compiling clojure.template to BASE/classes
[java] Compiling clojure.test to BASE/classes
[java] Compiling clojure.test.tap to BASE/classes
[java] Compiling clojure.test.junit to BASE/classes
[java] Compiling clojure.pprint to BASE/classes
[java] Compiling clojure.java.io to BASE/classes
[java] Compiling clojure.repl to BASE/classes
[java] Compiling clojure.java.browse to BASE/classes
[java] Compiling clojure.java.javadoc to BASE/classes
[java] Compiling clojure.java.shell to BASE/classes
[java] Compiling clojure.java.browse-ui to BASE/classes
[java] Compiling clojure.string to BASE/classes
[java] Compiling clojure.data to BASE/classes
[java] Compiling clojure.reflect to BASE/classes
build:
BUILD SUCCESSFUL
Total time: 33 seconds
Chapter 7
jvm/clojure/asm/
7.1 AnnotationVisitor.java
— AnnotationVisitor.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A visitor to visit a Java annotation. The methods of this int erface
* must be called in the following order: (<tt>visit<tt> |
* <tt>visitEnum<tt> | <tt>visitAnnotation<tt> | <tt>visi tArray<tt>)*
* <tt>visitEnd<tt>.
*
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
public interface AnnotationVisitor{
/**
* Visits a primitive value of the annotation.
*
* @param name the value name.
* @param value the actual value, whose type must be {@link Byt e},
* {@link Boolean}, {@link Character}, {@link Short},
* {@link Integer}, {@link Long}, {@link Float},
* {@link Double}, {@link String} or {@link Type}. This
* value can also be an array of byte, boolean, short,
* char, int, long, float or double values (this is
* equivalent to using {@link #visitArray visitArray}
* and visiting each array element in turn, but is more
* convenient).
163
164 CHAPTER 7. JVM/CLOJURE/ASM/
*/
void visit(String name, Object value);
/**
* Visits an enumeration value of the annotation.
*
* @param name the value name.
* @param desc the class descriptor of the enumeration class.
* @param value the actual enumeration value.
*/
void visitEnum(String name, String desc, String value);
/**
* Visits a nested annotation value of the annotation.
*
* @param name the value name.
* @param desc the class descriptor of the nested annotation c lass.
* @return a visitor to visit the actual nested annotation val ue, or
* <tt>null</tt> if this visitor is not interested in visitin g
* this nested annotation. <i>The nested annotation value mu st be
* fully visited before calling other methods on this annotat ion
* visitor</i>.
*/
AnnotationVisitor visitAnnotation(String name, String d esc);
/**
* Visits an array value of the annotation. Note that arrays of primitive
* types (such as byte, boolean, short, char, int, long, float or double)
* can be passed as value to {@link #visit visit}. This is what
* {@link ClassReader} does.
*
* @param name the value name.
* @return a visitor to visit the actual array value elements, or
* <tt>null</tt> if this visitor is not interested in visitin g
* these values. The ’name’ parameters passed to the methods o f
* this visitor are ignored. <i>All the array values must be
* visited before calling other methods on this annotation
* visitor</i>.
*/
AnnotationVisitor visitArray(String name);
/**
* Visits the end of the annotation.
*/
void visitEnd();
}
———-
7.2. ANNOTATIONWRITER.JAVA 165
7.2 AnnotationWriter.java
(AnnotationVisitor [163])
— AnnotationWriter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* An {@link AnnotationVisitor} that generates annotations in
* bytecode form.
*
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
final class AnnotationWriter implements AnnotationVisit or{
/**
* The class writer to which this annotation must be added.
*/
private final ClassWriter cw;
/**
* The number of values in this annotation.
*/
private int size;
/**
* <tt>true<tt> if values are named, <tt>false</tt> otherwi se. Annotation
* writers used for annotation default and annotation arrays use unnamed
* values.
*/
private final boolean named;
/**
* The annotation values in bytecode form. This byte vector on ly contains
* the values themselves, i.e. the number of values must be sto red as a
* unsigned short just before these bytes.
*/
private final ByteVector bv;
/**
* The byte vector to be used to store the number of values of thi s
* annotation. See {@link #bv}.
*/
private final ByteVector parent;
/**
* Where the number of values of this annotation must be stored in
166 CHAPTER 7. JVM/CLOJURE/ASM/
* {@link #parent}.
*/
private final int offset;
/**
* Next annotation writer. This field is used to store annotat ion lists.
*/
AnnotationWriter next;
/**
* Previous annotation writer. This field is used to store ann otation
* lists.
*/
AnnotationWriter prev;
// ------------------------------------------------- ------------------
// Constructor
// ------------------------------------------------- ------------------
/**
* Constructs a new {@link AnnotationWriter}.
*
* @param cw the class writer to which this annotation must be a dded.
* @param named <tt>true<tt> if values are named,
* <tt>false</tt> otherwise.
* @param bv where the annotation values must be stored.
* @param parent where the number of annotation values must be stored.
* @param offset where in <tt>parent</tt> the number of annot ation values
* must be stored.
*/
AnnotationWriter(
final ClassWriter cw,
final boolean named,
final ByteVector bv,
final ByteVector parent,
final int offset){
this.cw = cw;
this.named = named;
this.bv = bv;
this.parent = parent;
this.offset = offset;
}
// ------------------------------------------------- ------------------
// Implementation of the AnnotationVisitor interface
// ------------------------------------------------- ------------------
public void visit(final String name, final Object value){
++size;
if(named)
7.2. ANNOTATIONWRITER.JAVA 167
{
bv.putShort(cw.newUTF8(name));
}
if(value instanceof String)
{
bv.put12(’s’, cw.newUTF8((String) value));
}
else if(value instanceof Byte)
{
bv.put12(’B’, cw.newInteger(((Byte) value).byteValue( )).index);
}
else if(value instanceof Boolean)
{
int v = ((Boolean) value).booleanValue() ? 1 : 0;
bv.put12(’Z’, cw.newInteger(v).index);
}
else if(value instanceof Character)
{
bv.put12(’C’,
cw.newInteger(((Character) value).charValue()).index );
}
else if(value instanceof Short)
{
bv.put12(’S’, cw.newInteger(((Short) value).shortValu e()).index);
}
else if(value instanceof Type)
{
bv.put12(’c’, cw.newUTF8(((Type) value).getDescriptor ()));
}
else if(value instanceof byte[])
{
byte[] v = (byte[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’B’, cw.newInteger(v[i]).index);
}
}
else if(value instanceof boolean[])
{
boolean[] v = (boolean[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’Z’, cw.newInteger(v[i] ? 1 : 0).index);
}
}
else if(value instanceof short[])
{
short[] v = (short[]) value;
168 CHAPTER 7. JVM/CLOJURE/ASM/
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’S’, cw.newInteger(v[i]).index);
}
}
else if(value instanceof char[])
{
char[] v = (char[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’C’, cw.newInteger(v[i]).index);
}
}
else if(value instanceof int[])
{
int[] v = (int[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’I’, cw.newInteger(v[i]).index);
}
}
else if(value instanceof long[])
{
long[] v = (long[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’J’, cw.newLong(v[i]).index);
}
}
else if(value instanceof float[])
{
float[] v = (float[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’F’, cw.newFloat(v[i]).index);
}
}
else if(value instanceof double[])
{
double[] v = (double[]) value;
bv.put12(’[’, v.length);
for(int i = 0; i < v.length; i++)
{
bv.put12(’D’, cw.newDouble(v[i]).index);
}
7.2. ANNOTATIONWRITER.JAVA 169
}
else
{
Item i = cw.newConstItem(value);
bv.put12(".s.IFJDCS".charAt(i.type), i.index);
}
}
public void visitEnum(
final String name,
final String desc,
final String value){
++size;
if(named)
{
bv.putShort(cw.newUTF8(name));
}
bv.put12(’e’, cw.newUTF8(desc)).putShort(cw.newUTF8( value));
}
public AnnotationVisitor visitAnnotation(
final String name,
final String desc){
++size;
if(named)
{
bv.putShort(cw.newUTF8(name));
}
// write tag and type, and reserve space for values count
bv.put12(’@’, cw.newUTF8(desc)).putShort(0);
return new AnnotationWriter(cw, true, bv, bv, bv.length - 2 );
}
public AnnotationVisitor visitArray(final String name){
++size;
if(named)
{
bv.putShort(cw.newUTF8(name));
}
// write tag, and reserve space for array size
bv.put12(’[’, 0);
return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);
}
public void visitEnd(){
if(parent != null)
{
byte[] data = parent.data;
data[offset] = (byte) (size >>> 8);
data[offset + 1] = (byte) size;
170 CHAPTER 7. JVM/CLOJURE/ASM/
}
}
// ------------------------------------------------- ------------------
// Utility methods
// ------------------------------------------------- ------------------
/**
* Returns the size of this annotation writer list.
*
* @return the size of this annotation writer list.
*/
int getSize(){
int size = 0;
AnnotationWriter aw = this;
while(aw != null)
{
size += aw.bv.length;
aw = aw.next;
}
return size;
}
/**
* Puts the annotations of this annotation writer list into th e given
* byte vector.
*
* @param out where the annotations must be put.
*/
void put(final ByteVector out){
int n = 0;
int size = 2;
AnnotationWriter aw = this;
AnnotationWriter last = null;
while(aw != null)
{
++n;
size += aw.bv.length;
aw.visitEnd(); // in case user forgot to call visitEnd
aw.prev = last;
last = aw;
aw = aw.next;
}
out.putInt(size);
out.putShort(n);
aw = last;
while(aw != null)
{
out.putByteArray(aw.bv.data, 0, aw.bv.length);
aw = aw.prev;
7.3. ATTRIBUTE.JAVA 171
}
}
/**
* Puts the given annotation lists into the given byte vector.
*
* @param panns an array of annotation writer lists.
* @param out where the annotations must be put.
*/
static void put(final AnnotationWriter[] panns, final Byt eVector out){
int size = 1 + 2 * panns.length;
for(int i = 0; i < panns.length; ++i)
{
size += panns[i] == null ? 0 : panns[i].getSize();
}
out.putInt(size).putByte(panns.length);
for(int i = 0; i < panns.length; ++i)
{
AnnotationWriter aw = panns[i];
AnnotationWriter last = null;
int n = 0;
while(aw != null)
{
++n;
aw.visitEnd(); // in case user forgot to call visitEnd
aw.prev = last;
last = aw;
aw = aw.next;
}
out.putShort(n);
aw = last;
while(aw != null)
{
out.putByteArray(aw.bv.data, 0, aw.bv.length);
aw = aw.prev;
}
}
}
}
———-
7.3 Attribute.java
— Attribute.java —
\getchunk{France Telecom Copyright}
172 CHAPTER 7. JVM/CLOJURE/ASM/
package clojure.asm;
/**
* A non standard class, field, method or code attribute.
*
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
public class Attribute{
/**
* The type of this attribute.
*/
public final String type;
/**
* The raw value of this attribute, used only for unknown attri butes.
*/
byte[] value;
/**
* The next attribute in this attribute list. May be <tt>null< /tt>.
*/
Attribute next;
/**
* Constructs a new empty attribute.
*
* @param type the type of the attribute.
*/
protected Attribute(final String type){
this.type = type;
}
/**
* Returns <tt>true</tt> if this type of attribute is unknown .
* The default implementation of this method always returns
* <tt>true</tt>.
*
* @return <tt>true</tt> if this type of attribute is unknown .
*/
public boolean isUnknown(){
return true;
}
/**
* Returns <tt>true</tt> if this type of attribute is a code at tribute.
*
* @return <tt>true</tt> if this type of attribute is a code at tribute.
*/
7.3. ATTRIBUTE.JAVA 173
public boolean isCodeAttribute(){
return false;
}
/**
* Returns the labels corresponding to this attribute.
*
* @return the labels corresponding to this attribute, or
* <tt>null</tt> if this attribute is not a code attribute
* that contains labels.
*/
protected Label[] getLabels(){
return null;
}
/**
* Reads a {@link #type type} attribute. This method must retu rn
* <i>new</i> {@link Attribute} object, of type {@link #type type},
* corresponding to the <tt>len</tt> bytes starting at the gi ven offset,
* in the given class reader.
*
* @param cr the class that contains the attribute to be read.
* @param off index of the first byte of the attribute’s conten t
* in {@link ClassReader#b cr.b}. The 6 attribute header
* bytes, containing the type and the length of the
* attribute, are not taken into account
* here.
* @param len the length of the attribute’s content.
* @param buf buffer to be used to call
* {@link ClassReader#readUTF8 readUTF8},
* {@link ClassReader#readClass(int,char[]) readClass} o r
* {@link ClassReader#readConst readConst}.
* @param codeOff index of the first byte of code’s attribute c ontent in
* {@link ClassReader#b cr.b}, or -1 if the attribute to
* be read is not a code attribute. The 6 attribute header
* bytes, containing the type and the length of the
* attribute, are not taken into account here.
* @param labels the labels of the method’s code, or <tt>null< /tt>
* if the attribute to be read is not a code attribute.
* @return a <i>new</i> {@link Attribute} object correspond ing to the
* given bytes.
*/
protected Attribute read(
final ClassReader cr,
final int off,
final int len,
final char[] buf,
final int codeOff,
final Label[] labels){
Attribute attr = new Attribute(type);
174 CHAPTER 7. JVM/CLOJURE/ASM/
attr.value = new byte[len];
System.arraycopy(cr.b, off, attr.value, 0, len);
return attr;
}
/**
* Returns the byte array form of this attribute.
*
* @param cw the class to which this attribute must be added.
* This parameter can be used to add to the constant
* pool of this class the items that corresponds to
* this attribute.
* @param code the bytecode of the method corresponding to thi s code
* attribute, or <tt>null</tt> if this attribute is not
* a code attributes.
* @param len the length of the bytecode of the method
* corresponding to this code attribute, or
* <tt>null</tt> if this attribute is not a code
* attribute.
* @param maxStack the maximum stack size of the method corres ponding to
* this code attribute, or -1 if this attribute is not
* a code attribute.
* @param maxLocals the maximum number of local variables of t he method
* corresponding to this code attribute, or -1 if this
* attribute is not a code attribute.
* @return the byte array form of this attribute.
*/
protected ByteVector write(
final ClassWriter cw,
final byte[] code,
final int len,
final int maxStack,
final int maxLocals){
ByteVector v = new ByteVector();
v.data = value;
v.length = value.length;
return v;
}
/**
* Returns the length of the attribute list that begins with th is
* attribute.
*
* @return the length of the attribute list that begins with th is
* attribute.
*/
final int getCount(){
int count = 0;
Attribute attr = this;
while(attr != null)
7.3. ATTRIBUTE.JAVA 175
{
count += 1;
attr = attr.next;
}
return count;
}
/**
* Returns the size of all the attributes in this attribute lis t.
*
* @param cw the class writer to be used to convert the attribut es
* into byte arrays, with the {@link #write write}
* method.
* @param code the bytecode of the method corresponding to the se
* code attributes, or <tt>null</tt> if these
* attributes are not code attributes.
* @param len the length of the bytecode of the method
* corresponding to these code attributes, or
* <tt>null</tt> if these attributes are not code
* attributes.
* @param maxStack the maximum stack size of the method corres ponding to
* these code attributes, or -1 if these attributes are
* not code attributes.
* @param maxLocals the maximum number of local variables of t he method
* corresponding to these code attributes, or -1 if
* these attributes are not code attributes.
* @return the size of all the attributes in this attribute lis t.
* This size includes the size of the attribute headers.
*/
final int getSize(
final ClassWriter cw,
final byte[] code,
final int len,
final int maxStack,
final int maxLocals){
Attribute attr = this;
int size = 0;
while(attr != null)
{
cw.newUTF8(attr.type);
size +=
attr.write(cw,code,len,maxStack,maxLocals).length + 6 ;
attr = attr.next;
}
return size;
}
/**
* Writes all the attributes of this attribute list in the give n byte
* vector.
176 CHAPTER 7. JVM/CLOJURE/ASM/
*
* @param cw the class writer to be used to convert the attribut es
* into byte arrays, with the {@link #write write}
* method.
* @param code the bytecode of the method corresponding to the se
* code attributes, or <tt>null</tt> if these attributes
* are not code attributes.
* @param len the length of the bytecode of the method
* corresponding to these code attributes, or
* <tt>null</tt> if these attributes are not code
* attributes.
* @param maxStack the maximum stack size of the method corres ponding to
* these code attributes, or -1 if these attributes are
* not code attributes.
* @param maxLocals the maximum number of local variables of t he method
* corresponding to these code attributes, or -1 if
* these attributes are not code attributes.
* @param out where the attributes must be written.
*/
final void put(
final ClassWriter cw,
final byte[] code,
final int len,
final int maxStack,
final int maxLocals,
final ByteVector out){
Attribute attr = this;
while(attr != null)
{
ByteVector b = attr.write(cw, code, len, maxStack, maxLoca ls);
out.putShort(cw.newUTF8(attr.type)).putInt(b.length );
out.putByteArray(b.data, 0, b.length);
attr = attr.next;
}
}
}
———-
7.4 ByteVector.java
— ByteVector.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
7.4. BYTEVECTOR.JAVA 177
* A dynamically extensible vector of bytes. This class is rou ghly
* equivalent to a DataOutputStream on top of a ByteArrayOutp utStream,
* but is more efficient.
*
* @author Eric Bruneton
*/
public class ByteVector{
/**
* The content of this vector.
*/
byte[] data;
/**
* Actual number of bytes in this vector.
*/
int length;
/**
* Constructs a new {@link ByteVector ByteVector} with a defa ult initial
* size.
*/
public ByteVector(){
data = new byte[64];
}
/**
* Constructs a new {@link ByteVector ByteVector} with the gi ven initial
* size.
*
* @param initialSize the initial size of the byte vector to be
* constructed.
*/
public ByteVector(final int initialSize){
data = new byte[initialSize];
}
/**
* Puts a byte into this byte vector. The byte vector is automat ically
* enlarged if necessary.
*
* @param b a byte.
* @return this byte vector.
*/
public ByteVector putByte(final int b){
int length = this.length;
if(length + 1 > data.length)
{
enlarge(1);
}
178 CHAPTER 7. JVM/CLOJURE/ASM/
data[length++] = (byte) b;
this.length = length;
return this;
}
/**
* Puts two bytes into this byte vector. The byte vector is auto matically
* enlarged if necessary.
*
* @param b1 a byte.
* @param b2 another byte.
* @return this byte vector.
*/
ByteVector put11(final int b1, final int b2){
int length = this.length;
if(length + 2 > data.length)
{
enlarge(2);
}
byte[] data = this.data;
data[length++] = (byte) b1;
data[length++] = (byte) b2;
this.length = length;
return this;
}
/**
* Puts a short into this byte vector. The byte vector is automa tically
* enlarged if necessary.
*
* @param s a short.
* @return this byte vector.
*/
public ByteVector putShort(final int s){
int length = this.length;
if(length + 2 > data.length)
{
enlarge(2);
}
byte[] data = this.data;
data[length++] = (byte) (s >>> 8);
data[length++] = (byte) s;
this.length = length;
return this;
}
/**
* Puts a byte and a short into this byte vector. The byte vector is
* automatically enlarged if necessary.
*
7.4. BYTEVECTOR.JAVA 179
* @param b a byte.
* @param s a short.
* @return this byte vector.
*/
ByteVector put12(final int b, final int s){
int length = this.length;
if(length + 3 > data.length)
{
enlarge(3);
}
byte[] data = this.data;
data[length++] = (byte) b;
data[length++] = (byte) (s >>> 8);
data[length++] = (byte) s;
this.length = length;
return this;
}
/**
* Puts an int into this byte vector. The byte vector is automat ically
* enlarged if necessary.
*
* @param i an int.
* @return this byte vector.
*/
public ByteVector putInt(final int i){
int length = this.length;
if(length + 4 > data.length)
{
enlarge(4);
}
byte[] data = this.data;
data[length++] = (byte) (i >>> 24);
data[length++] = (byte) (i >>> 16);
data[length++] = (byte) (i >>> 8);
data[length++] = (byte) i;
this.length = length;
return this;
}
/**
* Puts a long into this byte vector. The byte vector is automat ically
* enlarged if necessary.
*
* @param l a long.
* @return this byte vector.
*/
public ByteVector putLong(final long l){
int length = this.length;
if(length + 8 > data.length)
180 CHAPTER 7. JVM/CLOJURE/ASM/
{
enlarge(8);
}
byte[] data = this.data;
int i = (int) (l >>> 32);
data[length++] = (byte) (i >>> 24);
data[length++] = (byte) (i >>> 16);
data[length++] = (byte) (i >>> 8);
data[length++] = (byte) i;
i = (int) l;
data[length++] = (byte) (i >>> 24);
data[length++] = (byte) (i >>> 16);
data[length++] = (byte) (i >>> 8);
data[length++] = (byte) i;
this.length = length;
return this;
}
/**
* Puts an UTF8 string into this byte vector. The byte vector is
* automatically enlarged if necessary.
*
* @param s a String.
* @return this byte vector.
*/
public ByteVector putUTF8(final String s){
int charLength = s.length();
if(length + 2 + charLength > data.length)
{
enlarge(2 + charLength);
}
int len = length;
byte[] data = this.data;
// optimistic algorithm: instead of computing the byte leng th
// and then serializing the string (which requires two loops ),
// we assume the byte length is equal to char length (which is
// the most frequent case), and we start serializing the stri ng
// right away. During the serialization, if we find that this
// assumption is wrong, we continue with the general method.
data[len++] = (byte) (charLength >>> 8);
data[len++] = (byte) charLength;
for(int i = 0; i < charLength; ++i)
{
char c = s.charAt(i);
if(c >= ’\001’ && c <= ’\177’)
{
data[len++] = (byte) c;
}
else
{
7.4. BYTEVECTOR.JAVA 181
int byteLength = i;
for(int j = i; j < charLength; ++j)
{
c = s.charAt(j);
if(c >= ’\001’ && c <= ’\177’)
{
byteLength++;
}
else if(c > ’\u07FF’)
{
byteLength += 3;
}
else
{
byteLength += 2;
}
}
data[length] = (byte) (byteLength >>> 8);
data[length + 1] = (byte) byteLength;
if(length + 2 + byteLength > data.length)
{
length = len;
enlarge(2 + byteLength);
data = this.data;
}
for(int j = i; j < charLength; ++j)
{
c = s.charAt(j);
if(c >= ’\001’ && c <= ’\177’)
{
data[len++] = (byte) c;
}
else if(c > ’\u07FF’)
{
data[len++] =
(byte) (0xE0 | c >> 12 & 0xF);
data[len++] =
(byte) (0x80 | c >> 6 & 0x3F);
data[len++] =
(byte) (0x80 | c & 0x3F);
}
else
{
data[len++] =
(byte) (0xC0 | c >> 6 & 0x1F);
data[len++] =
(byte) (0x80 | c & 0x3F);
}
}
break;
182 CHAPTER 7. JVM/CLOJURE/ASM/
}
}
length = len;
return this;
}
/**
* Puts an array of bytes into this byte vector. The byte vector is
* automatically enlarged if necessary.
*
* @param b an array of bytes. May be <tt>null</tt> to put <tt>l en</tt>
* null bytes into this byte vector.
* @param off index of the fist byte of b that must be copied.
* @param len number of bytes of b that must be copied.
* @return this byte vector.
*/
public ByteVector putByteArray(final byte[] b, final int o ff,
final int len){
if(length + len > data.length)
{
enlarge(len);
}
if(b != null)
{
System.arraycopy(b, off, data, length, len);
}
length += len;
return this;
}
/**
* Enlarge this byte vector so that it can receive n more bytes.
*
* @param size number of additional bytes that this byte vecto r should be
* able to receive.
*/
private void enlarge(final int size){
int length1 = 2 * data.length;
int length2 = length + size;
byte[] newData = new byte[length1 > length2 ? length1 : lengt h2];
System.arraycopy(data, 0, newData, 0, length);
data = newData;
}
}
———-
7.5. CLASSADAPTER.JAVA 183
7.5 ClassAdapter.java
(ClassVisitor [229])
— ClassAdapter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* An empty {@link ClassVisitor} that delegates to another
* {@link ClassVisitor}. This class can be used as a super clas s to
* quickly implement usefull class adapter classes, just by o verriding
* the necessary methods.
*
* @author Eric Bruneton
*/
public class ClassAdapter implements ClassVisitor{
/**
* The {@link ClassVisitor} to which this adapter delegates c alls.
*/
protected ClassVisitor cv;
/**
* Constructs a new {@link ClassAdapter} object.
*
* @param cv the class visitor to which this adapter must deleg ate calls.
*/
public ClassAdapter(final ClassVisitor cv){
this.cv = cv;
}
public void visit(
final int version,
final int access,
final String name,
final String signature,
final String superName,
final String[] interfaces){
cv.visit(version, access, name, signature, superName, in terfaces);
}
public void visitSource(final String source, final String debug){
cv.visitSource(source, debug);
}
public void visitOuterClass(
final String owner,
final String name,
184 CHAPTER 7. JVM/CLOJURE/ASM/
final String desc){
cv.visitOuterClass(owner, name, desc);
}
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
return cv.visitAnnotation(desc, visible);
}
public void visitAttribute(final Attribute attr){
cv.visitAttribute(attr);
}
public void visitInnerClass(
final String name,
final String outerName,
final String innerName,
final int access){
cv.visitInnerClass(name, outerName, innerName, access) ;
}
public FieldVisitor visitField(
final int access,
final String name,
final String desc,
final String signature,
final Object value){
return cv.visitField(access, name, desc, signature, valu e);
}
public MethodVisitor visitMethod(
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions){
return cv.visitMethod(access, name, desc, signature, exc eptions);
}
public void visitEnd(){
cv.visitEnd();
}
}
———-
7.6. CLASSREADER.JAVA 185
7.6 ClassReader.java
— ClassReader.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
import java.io.InputStream;
import java.io.IOException;
/**
* A Java class parser to make a {@link ClassVisitor} visit an
* existing class. This class parses a byte array conforming t o
* the Java class file format and calls the appropriate visit
* methods of a given class visitor for each field, method and
* bytecode instruction encountered.
*
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
public class ClassReader{
/**
* Flag to skip method code. If this class is set <code>CODE</c ode>
* attribute won’t be visited. This can be used, for example, t o retrieve
* annotations for methods and method parameters.
*/
public final static int SKIP_CODE = 1;
/**
* Flag to skip the debug information in the class. If this flag is set
* the debug information of the class is not visited, i.e. the
* {@link MethodVisitor#visitLocalVariable visitLocalVa riable} and
* {@link MethodVisitor#visitLineNumber visitLineNumber } methods
* will not be called.
*/
public final static int SKIP_DEBUG = 2;
/**
* Flag to skip the stack map frames in the class. If this flag is set
* the stack map frames of the class is not visited, i.e. the
* {@link MethodVisitor#visitFrame visitFrame} method wil l not be called.
* This flag is useful when the {@link ClassWriter#COMPUTE_F RAMES} option
* is used: it avoids visiting frames that will be ignored and
* recomputed from scratch in the class writer.
*/
public final static int SKIP_FRAMES = 4;
186 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Flag to expand the stack map frames. By default stack map fra mes are
* visited in their original format (i.e. "expanded" for clas ses whose
* version is less than V1_6, and "compressed" for the other cl asses).
* If this flag is set, stack map frames are always visited in
* expanded format (this option adds a decompression/recomp ression
* step in ClassReader and ClassWriter which degrades perfor mances
* quite a lot).
*/
public final static int EXPAND_FRAMES = 8;
/**
* The class to be parsed. <i>The content of this array must not be
* modified. This field is intended for {@link Attribute} sub classes,
* and is normally not needed by class generators or adapters. </i>
*/
public final byte[] b;
/**
* The start index of each constant pool item in {@link #b b}, pl us one.
* The one byte offset skips the constant pool item tag that ind icates
* its type.
*/
private final int[] items;
/**
* The String objects corresponding to the CONSTANT_Utf8 ite ms.
* This cache avoids multiple parsing of a given CONSTANT_Utf 8
* constant pool item, which GREATLY improves performances ( by a
* factor 2 to 3). This caching strategy could be extended to al l
* constant pool items, but its benefit would not be so great fo r
* these items (because they are much less expensive to parse t han
* CONSTANT_Utf8 items).
*/
private final String[] strings;
/**
* Maximum length of the strings contained in the constant poo l of the
* class.
*/
private final int maxStringLength;
/**
* Start index of the class header information (access, name. ..) in
* {@link #b b}.
*/
public final int header;
// ------------------------------------------------- ------------------
// Constructors
7.6. CLASSREADER.JAVA 187
// ------------------------------------------------- -----------------
/**
* Constructs a new {@link ClassReader} object.
*
* @param b the bytecode of the class to be read.
*/
public ClassReader(final byte[] b){
this(b, 0, b.length);
}
/**
* Constructs a new {@link ClassReader} object.
*
* @param b the bytecode of the class to be read.
* @param off the start offset of the class data.
* @param len the length of the class data.
*/
public ClassReader(final byte[] b, final int off, final int len){
this.b = b;
// parses the constant pool
items = new int[readUnsignedShort(off + 8)];
int n = items.length;
strings = new String[n];
int max = 0;
int index = off + 10;
for(int i = 1; i < n; ++i)
{
items[i] = index + 1;
int size;
switch(b[index])
{
case ClassWriter.FIELD:
case ClassWriter.METH:
case ClassWriter.IMETH:
case ClassWriter.INT:
case ClassWriter.FLOAT:
case ClassWriter.NAME_TYPE:
size = 5;
break;
case ClassWriter.LONG:
case ClassWriter.DOUBLE:
size = 9;
++i;
break;
case ClassWriter.UTF8:
size = 3 + readUnsignedShort(index + 1);
if(size > max)
{
max = size;
188 CHAPTER 7. JVM/CLOJURE/ASM/
}
break;
// case ClassWriter.CLASS:
// case ClassWriter.STR:
default:
size = 3;
break;
}
index += size;
}
maxStringLength = max;
// the class header information starts just after the consta nt pool
header = index;
}
/**
* Returns the class’s access flags (see {@link Opcodes}). Th is value may
* not reflect Deprecated and Synthetic flags when bytecode i s before 1.5
* and those flags are represented by attributes.
*
* @return the class access flags
* @see ClassVisitor#visit(int,int,String,String,Strin g,String[])
*/
public int getAccess(){
return readUnsignedShort(header);
}
/**
* Returns the internal name of the class (see
* {@link Type#getInternalName() getInternalName}).
*
* @return the internal class name
* @see ClassVisitor#visit(int,int,String,String,Strin g,String[])
*/
public String getClassName(){
return readClass(header + 2, new char[maxStringLength]);
}
/**
* Returns the internal of name of the super class (see
* {@link Type#getInternalName() getInternalName}). For i nterfaces, the
* super class is {@link Object}.
*
* @return the internal name of super class, or <tt>null</tt> for
* {@link Object} class.
* @see ClassVisitor#visit(int,int,String,String,Strin g,String[])
*/
public String getSuperName(){
int n = items[readUnsignedShort(header + 4)];
return n == 0 ? null : readUTF8(n, new char[maxStringLength] );
7.6. CLASSREADER.JAVA 189
}
/**
* Returns the internal names of the class’s interfaces (see
* {@link Type#getInternalName() getInternalName}).
*
* @return the array of internal names for all implemented int erfaces or
* <tt>null</tt>.
* @see ClassVisitor#visit(int,int,String,String,Strin g,String[])
*/
public String[] getInterfaces(){
int index = header + 6;
int n = readUnsignedShort(index);
String[] interfaces = new String[n];
if(n > 0)
{
char[] buf = new char[maxStringLength];
for(int i = 0; i < n; ++i)
{
index += 2;
interfaces[i] = readClass(index, buf);
}
}
return interfaces;
}
/**
* Copies the constant pool data into the given {@link ClassWr iter}.
* Should be called before the {@link #accept(ClassVisitor, int)} method.
*
* @param classWriter the {@link ClassWriter} to copy consta nt pool into.
*/
void copyPool(final ClassWriter classWriter){
char[] buf = new char[maxStringLength];
int ll = items.length;
Item[] items2 = new Item[ll];
for(int i = 1; i < ll; i++)
{
int index = items[i];
int tag = b[index - 1];
Item item = new Item(i);
int nameType;
switch(tag)
{
case ClassWriter.FIELD:
case ClassWriter.METH:
case ClassWriter.IMETH:
nameType = items[readUnsignedShort(index + 2)];
item.set(tag,
readClass(index, buf),
190 CHAPTER 7. JVM/CLOJURE/ASM/
readUTF8(nameType, buf),
readUTF8(nameType + 2, buf));
break;
case ClassWriter.INT:
item.set(readInt(index));
break;
case ClassWriter.FLOAT:
item.set(Float.intBitsToFloat(readInt(index)));
break;
case ClassWriter.NAME_TYPE:
item.set(tag,
readUTF8(index, buf),
readUTF8(index + 2, buf),
null);
break;
case ClassWriter.LONG:
item.set(readLong(index));
++i;
break;
case ClassWriter.DOUBLE:
item.set(Double.longBitsToDouble(readLong(index)));
++i;
break;
case ClassWriter.UTF8:
{
String s = strings[i];
if(s == null)
{
index = items[i];
s = strings[i] = readUTF(index + 2,
readUnsignedShort(index),
buf);
}
item.set(tag, s, null, null);
}
break;
// case ClassWriter.STR:
// case ClassWriter.CLASS:
default:
item.set(tag, readUTF8(index, buf), null, null);
break;
}
7.6. CLASSREADER.JAVA 191
int index2 = item.hashCode % items2.length;
item.next = items2[index2];
items2[index2] = item;
}
int off = items[1] - 1;
classWriter.pool.putByteArray(b, off, header - off);
classWriter.items = items2;
classWriter.threshold = (int) (0.75d * ll);
classWriter.index = ll;
}
/**
* Constructs a new {@link ClassReader} object.
*
* @param is an input stream from which to read the class.
* @throws IOException if a problem occurs during reading.
*/
public ClassReader(final InputStream is) throws IOExcept ion{
this(readClass(is));
}
/**
* Constructs a new {@link ClassReader} object.
*
* @param name the fully qualified name of the class to be read.
* @throws IOException if an exception occurs during reading .
*/
public ClassReader(final String name) throws IOException {
this(ClassLoader.getSystemResourceAsStream(name.rep lace(’.’, ’/’)
+ ".class"));
}
/**
* Reads the bytecode of a class.
*
* @param is an input stream from which to read the class.
* @return the bytecode read from the given input stream.
* @throws IOException if a problem occurs during reading.
*/
private static byte[] readClass(final InputStream is) thr ows IOException{
if(is == null)
{
throw new IOException("Class not found");
}
byte[] b = new byte[is.available()];
int len = 0;
while(true)
{
int n = is.read(b, len, b.length - len);
192 CHAPTER 7. JVM/CLOJURE/ASM/
if(n == -1)
{
if(len < b.length)
{
byte[] c = new byte[len];
System.arraycopy(b, 0, c, 0, len);
b = c;
}
return b;
}
len += n;
if(len == b.length)
{
byte[] c = new byte[b.length + 1000];
System.arraycopy(b, 0, c, 0, len);
b = c;
}
}
}
// ------------------------------------------------- ------------------
// Public methods
// ------------------------------------------------- ------------------
/**
* Makes the given visitor visit the Java class of this
* {@link ClassReader}. This class is the one specified in the
* constructor (see {@link #ClassReader(byte[]) ClassRead er}).
*
* @param classVisitor the visitor that must visit this class .
* @param flags option flags that can be used to modify
* the default behavior of this class. See
* {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}.
*/
public void accept(final ClassVisitor classVisitor, fina l int flags){
accept(classVisitor, new Attribute[0], flags);
}
/**
* Makes the given visitor visit the Java class of this
* {@link ClassReader}. This class is the one specified in the
* constructor (see {@link #ClassReader(byte[]) ClassRead er}).
*
* @param classVisitor the visitor that must visit this class .
* @param attrs prototypes of the attributes that must be pars ed
* during the visit of the class. Any attribute whose
* type is not equal to the type of one the
* prototypes will not be parsed: its byte array
* value will be passed unchanged to the ClassWriter.
* <i>This may corrupt it if this value contains
7.6. CLASSREADER.JAVA 193
* references to the constant pool, or has syntactic
* or semantic links with a class element that has
* been transformed by a class adapter between the
* reader and the writer</i>.
* @param flags option flags that can be used to modify the
* default behavior of this class. See
* {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}.
*/
public void accept(
final ClassVisitor classVisitor,
final Attribute[] attrs,
final int flags){
byte[] b = this.b; // the bytecode array
char[] c = new char[maxStringLength]; // buffer used to read strings
int i, j, k; // loop variables
int u, v, w; // indexes in b
Attribute attr;
int access;
String name;
String desc;
String attrName;
String signature;
int anns = 0;
int ianns = 0;
Attribute cattrs = null;
// visits the header
u = header;
access = readUnsignedShort(u);
name = readClass(u + 2, c);
v = items[readUnsignedShort(u + 4)];
String superClassName = v == 0 ? null : readUTF8(v, c);
String[] implementedItfs = new String[readUnsignedShort (u + 6)];
w = 0;
u += 8;
for(i = 0; i < implementedItfs.length; ++i)
{
implementedItfs[i] = readClass(u, c);
u += 2;
}
boolean skipCode = (flags & SKIP_CODE) != 0;
boolean skipDebug = (flags & SKIP_DEBUG) != 0;
boolean unzip = (flags & EXPAND_FRAMES) != 0;
// skips fields and methods
v = u;
i = readUnsignedShort(v);
v += 2;
194 CHAPTER 7. JVM/CLOJURE/ASM/
for(; i > 0; --i)
{
j = readUnsignedShort(v + 6);
v += 8;
for(; j > 0; --j)
{
v += 6 + readInt(v + 2);
}
}
i = readUnsignedShort(v);
v += 2;
for(; i > 0; --i)
{
j = readUnsignedShort(v + 6);
v += 8;
for(; j > 0; --j)
{
v += 6 + readInt(v + 2);
}
}
// reads the class’s attributes
signature = null;
String sourceFile = null;
String sourceDebug = null;
String enclosingOwner = null;
String enclosingName = null;
String enclosingDesc = null;
i = readUnsignedShort(v);
v += 2;
for(; i > 0; --i)
{
attrName = readUTF8(v, c);
// tests are sorted in decreasing frequency order
// (based on frequencies observed on typical classes)
if(attrName.equals("SourceFile"))
{
sourceFile = readUTF8(v + 6, c);
}
else if(attrName.equals("InnerClasses"))
{
w = v + 6;
}
else if(attrName.equals("EnclosingMethod"))
{
enclosingOwner = readClass(v + 6, c);
int item = readUnsignedShort(v + 8);
if(item != 0)
{
enclosingName = readUTF8(items[item], c);
7.6. CLASSREADER.JAVA 195
enclosingDesc = readUTF8(items[item] + 2, c);
}
}
else if(attrName.equals("Signature"))
{
signature = readUTF8(v + 6, c);
}
else if(attrName.equals("RuntimeVisibleAnnotations") )
{
anns = v + 6;
}
else if(attrName.equals("Deprecated"))
{
access |= Opcodes.ACC_DEPRECATED;
}
else if(attrName.equals("Synthetic"))
{
access |= Opcodes.ACC_SYNTHETIC;
}
else if(attrName.equals("SourceDebugExtension"))
{
int len = readInt(v + 2);
sourceDebug = readUTF(v + 6, len, new char[len]);
}
else if(attrName.equals("RuntimeInvisibleAnnotations "))
{
ianns = v + 6;
}
else
{
attr = readAttribute(attrs,
attrName,
v + 6,
readInt(v + 2),
c,
-1,
null);
if(attr != null)
{
attr.next = cattrs;
cattrs = attr;
}
}
v += 6 + readInt(v + 2);
}
// calls the visit method
classVisitor.visit(readInt(4),
access,
name,
signature,
196 CHAPTER 7. JVM/CLOJURE/ASM/
superClassName,
implementedItfs);
// calls the visitSource method
if(!skipDebug && (sourceFile != null || sourceDebug != null ))
{
classVisitor.visitSource(sourceFile, sourceDebug);
}
// calls the visitOuterClass method
if(enclosingOwner != null)
{
classVisitor.visitOuterClass(enclosingOwner,
enclosingName,
enclosingDesc);
}
// visits the class annotations
for(i = 1; i >= 0; --i)
{
v = i == 0 ? ianns : anns;
if(v != 0)
{
j = readUnsignedShort(v);
v += 2;
for(; j > 0; --j)
{
v = readAnnotationValues(v + 2, c, true,
classVisitor.visitAnnotation(readUTF8(v, c), i != 0));
}
}
}
// visits the class attributes
while(cattrs != null)
{
attr = cattrs.next;
cattrs.next = null;
classVisitor.visitAttribute(cattrs);
cattrs = attr;
}
// calls the visitInnerClass method
if(w != 0)
{
i = readUnsignedShort(w);
w += 2;
for(; i > 0; --i)
{
classVisitor.visitInnerClass(
7.6. CLASSREADER.JAVA 197
readUnsignedShort(w) == 0
? null
: readClass(w, c), readUnsignedShort(w + 2) == 0
? null
: readClass(w + 2, c), readUnsignedShort(w + 4) == 0
? null
: readUTF8(w + 4, c),
readUnsignedShort(w + 6));
w += 8;
}
}
// visits the fields
i = readUnsignedShort(u);
u += 2;
for(; i > 0; --i)
{
access = readUnsignedShort(u);
name = readUTF8(u + 2, c);
desc = readUTF8(u + 4, c);
// visits the field’s attributes and looks for a ConstantVal ue
// attribute
int fieldValueItem = 0;
signature = null;
anns = 0;
ianns = 0;
cattrs = null;
j = readUnsignedShort(u + 6);
u += 8;
for(; j > 0; --j)
{
attrName = readUTF8(u, c);
// tests are sorted in decreasing frequency order
// (based on frequencies observed on typical classes)
if(attrName.equals("ConstantValue"))
{
fieldValueItem = readUnsignedShort(u + 6);
}
else if(attrName.equals("Signature"))
{
signature = readUTF8(u + 6, c);
}
else if(attrName.equals("Deprecated"))
{
access |= Opcodes.ACC_DEPRECATED;
}
else if(attrName.equals("Synthetic"))
{
access |= Opcodes.ACC_SYNTHETIC;
198 CHAPTER 7. JVM/CLOJURE/ASM/
}
else if(attrName.equals("RuntimeVisibleAnnotations") )
{
anns = u + 6;
}
else if(attrName.equals("RuntimeInvisibleAnnotations "))
{
ianns = u + 6;
}
else
{
attr = readAttribute(attrs,
attrName,
u + 6,
readInt(u + 2),
c,
-1,
null);
if(attr != null)
{
attr.next = cattrs;
cattrs = attr;
}
}
u += 6 + readInt(u + 2);
}
// visits the field
FieldVisitor fv =
classVisitor.visitField(access, name, desc, signature,
fieldValueItem == 0 ? null : readConst(fieldValueItem, c)) ;
// visits the field annotations and attributes
if(fv != null)
{
for(j = 1; j >= 0; --j)
{
v = j == 0 ? ianns : anns;
if(v != 0)
{
k = readUnsignedShort(v);
v += 2;
for(; k > 0; --k)
{
v = readAnnotationValues(v + 2, c, true,
fv.visitAnnotation(readUTF8(v, c), j != 0));
}
}
}
while(cattrs != null)
{
attr = cattrs.next;
7.6. CLASSREADER.JAVA 199
cattrs.next = null;
fv.visitAttribute(cattrs);
cattrs = attr;
}
fv.visitEnd();
}
}
// visits the methods
i = readUnsignedShort(u);
u += 2;
for(; i > 0; --i)
{
int u0 = u + 6;
access = readUnsignedShort(u);
name = readUTF8(u + 2, c);
desc = readUTF8(u + 4, c);
signature = null;
anns = 0;
ianns = 0;
int dann = 0;
int mpanns = 0;
int impanns = 0;
cattrs = null;
v = 0;
w = 0;
// looks for Code and Exceptions attributes
j = readUnsignedShort(u + 6);
u += 8;
for(; j > 0; --j)
{
attrName = readUTF8(u, c);
int attrSize = readInt(u + 2);
u += 6;
// tests are sorted in decreasing frequency order
// (based on frequencies observed on typical classes)
if(attrName.equals("Code"))
{
if(!skipCode)
{
v = u;
}
}
else if(attrName.equals("Exceptions"))
{
w = u;
}
else if(attrName.equals("Signature"))
{
200 CHAPTER 7. JVM/CLOJURE/ASM/
signature = readUTF8(u, c);
}
else if(attrName.equals("Deprecated"))
{
access |= Opcodes.ACC_DEPRECATED;
}
else if(attrName.equals("RuntimeVisibleAnnotations") )
{
anns = u;
}
else if(attrName.equals("AnnotationDefault"))
{
dann = u;
}
else if(attrName.equals("Synthetic"))
{
access |= Opcodes.ACC_SYNTHETIC;
}
else if(attrName.equals("RuntimeInvisibleAnnotations "))
{
ianns = u;
}
else if(attrName.equals(
"RuntimeVisibleParameterAnnotations"))
{
mpanns = u;
}
else if(attrName.equals(
"RuntimeInvisibleParameterAnnotations"))
{
impanns = u;
}
else
{
attr = readAttribute(attrs,
attrName,
u,
attrSize,
c,
-1,
null);
if(attr != null)
{
attr.next = cattrs;
cattrs = attr;
}
}
u += attrSize;
}
// reads declared exceptions
7.6. CLASSREADER.JAVA 201
String[] exceptions;
if(w == 0)
{
exceptions = null;
}
else
{
exceptions = new String[readUnsignedShort(w)];
w += 2;
for(j = 0; j < exceptions.length; ++j)
{
exceptions[j] = readClass(w, c);
w += 2;
}
}
// visits the method’s code, if any
MethodVisitor mv = classVisitor.visitMethod(access,
name,
desc,
signature,
exceptions);
if(mv != null)
{
/*
* if the returned MethodVisitor is in fact a MethodWriter, it
* means there is no method adapter between the reader and the
* writer. If, in addition, the writer’s constant pool was
* copied from this reader (mw.cw.cr == this), and the
* signature and exceptions of the method have not been
* changed, then it is possible to skip all visit events and
* just copy the original code of the method to the writer
* (the access, name and descriptor can have been changed,
* this is not important since they are not copied as is from
* the reader).
*/
if(mv instanceof MethodWriter)
{
MethodWriter mw = (MethodWriter) mv;
if(mw.cw.cr == this)
{
if(signature == mw.signature)
{
boolean sameExceptions = false;
if(exceptions == null)
{
sameExceptions = mw.exceptionCount == 0;
}
else
202 CHAPTER 7. JVM/CLOJURE/ASM/
{
if(exceptions.length == mw.exceptionCount)
{
sameExceptions = true;
for(j = exceptions.length - 1; j >= 0; --j)
{
w -= 2;
if(mw.exceptions[j] !=
readUnsignedShort(w))
{
sameExceptions = false;
break;
}
}
}
}
if(sameExceptions)
{
/*
* we do not copy directly the code into
* MethodWriter to save a byte array copy
* operation. The real copy will be done in
* ClassWriter.toByteArray().
*/
mw.classReaderOffset = u0;
mw.classReaderLength = u - u0;
continue;
}
}
}
}
if(dann != 0)
{
AnnotationVisitor dv = mv.visitAnnotationDefault();
readAnnotationValue(dann, c, null, dv);
if(dv != null)
{
dv.visitEnd();
}
}
for(j = 1; j >= 0; --j)
{
w = j == 0 ? ianns : anns;
if(w != 0)
{
k = readUnsignedShort(w);
w += 2;
for(; k > 0; --k)
{
7.6. CLASSREADER.JAVA 203
w = readAnnotationValues(w + 2, c, true,
mv.visitAnnotation(readUTF8(w, c), j != 0));
}
}
}
if(mpanns != 0)
{
readParameterAnnotations(mpanns, c, true, mv);
}
if(impanns != 0)
{
readParameterAnnotations(impanns, c, false, mv);
}
while(cattrs != null)
{
attr = cattrs.next;
cattrs.next = null;
mv.visitAttribute(cattrs);
cattrs = attr;
}
}
if(mv != null && v != 0)
{
int maxStack = readUnsignedShort(v);
int maxLocals = readUnsignedShort(v + 2);
int codeLength = readInt(v + 4);
v += 8;
int codeStart = v;
int codeEnd = v + codeLength;
mv.visitCode();
// 1st phase: finds the labels
int label;
Label[] labels = new Label[codeLength + 1];
while(v < codeEnd)
{
int opcode = b[v] & 0xFF;
switch(ClassWriter.TYPE[opcode])
{
case ClassWriter.NOARG_INSN:
case ClassWriter.IMPLVAR_INSN:
v += 1;
break;
case ClassWriter.LABEL_INSN:
label = v - codeStart + readShort(v + 1);
if(labels[label] == null)
{
204 CHAPTER 7. JVM/CLOJURE/ASM/
labels[label] = new Label();
}
v += 3;
break;
case ClassWriter.LABELW_INSN:
label = v - codeStart + readInt(v + 1);
if(labels[label] == null)
{
labels[label] = new Label();
}
v += 5;
break;
case ClassWriter.WIDE_INSN:
opcode = b[v + 1] & 0xFF;
if(opcode == Opcodes.IINC)
{
v += 6;
}
else
{
v += 4;
}
break;
case ClassWriter.TABL_INSN:
// skips 0 to 3 padding bytes
w = v - codeStart;
v = v + 4 - (w & 3);
// reads instruction
label = w + readInt(v);
if(labels[label] == null)
{
labels[label] = new Label();
}
j = readInt(v + 8) - readInt(v + 4) + 1;
v += 12;
for(; j > 0; --j)
{
label = w + readInt(v);
v += 4;
if(labels[label] == null)
{
labels[label] = new Label();
}
}
break;
case ClassWriter.LOOK_INSN:
// skips 0 to 3 padding bytes
w = v - codeStart;
v = v + 4 - (w & 3);
// reads instruction
7.6. CLASSREADER.JAVA 205
label = w + readInt(v);
if(labels[label] == null)
{
labels[label] = new Label();
}
j = readInt(v + 4);
v += 8;
for(; j > 0; --j)
{
label = w + readInt(v + 4);
v += 8;
if(labels[label] == null)
{
labels[label] = new Label();
}
}
break;
case ClassWriter.VAR_INSN:
case ClassWriter.SBYTE_INSN:
case ClassWriter.LDC_INSN:
v += 2;
break;
case ClassWriter.SHORT_INSN:
case ClassWriter.LDCW_INSN:
case ClassWriter.FIELDORMETH_INSN:
case ClassWriter.TYPE_INSN:
case ClassWriter.IINC_INSN:
v += 3;
break;
case ClassWriter.ITFMETH_INSN:
v += 5;
break;
// case MANA_INSN:
default:
v += 4;
break;
}
}
// parses the try catch entries
j = readUnsignedShort(v);
v += 2;
for(; j > 0; --j)
{
label = readUnsignedShort(v);
Label start = labels[label];
if(start == null)
{
labels[label] = start = new Label();
}
label = readUnsignedShort(v + 2);
206 CHAPTER 7. JVM/CLOJURE/ASM/
Label end = labels[label];
if(end == null)
{
labels[label] = end = new Label();
}
label = readUnsignedShort(v + 4);
Label handler = labels[label];
if(handler == null)
{
labels[label] = handler = new Label();
}
int type = readUnsignedShort(v + 6);
if(type == 0)
{
mv.visitTryCatchBlock(start, end, handler, null);
}
else
{
mv.visitTryCatchBlock(start,
end,
handler,
readUTF8(items[type], c));
}
v += 8;
}
// parses the local variable, line number tables, and code
// attributes
int varTable = 0;
int varTypeTable = 0;
int stackMap = 0;
int frameCount = 0;
int frameMode = 0;
int frameOffset = 0;
int frameLocalCount = 0;
int frameLocalDiff = 0;
int frameStackCount = 0;
Object[] frameLocal = null;
Object[] frameStack = null;
boolean zip = true;
cattrs = null;
j = readUnsignedShort(v);
v += 2;
for(; j > 0; --j)
{
attrName = readUTF8(v, c);
if(attrName.equals("LocalVariableTable"))
{
if(!skipDebug)
{
varTable = v + 6;
7.6. CLASSREADER.JAVA 207
k = readUnsignedShort(v + 6);
w = v + 8;
for(; k > 0; --k)
{
label = readUnsignedShort(w);
if(labels[label] == null)
{
labels[label] = new Label(true);
}
label += readUnsignedShort(w + 2);
if(labels[label] == null)
{
labels[label] = new Label(true);
}
w += 10;
}
}
}
else if(attrName.equals("LocalVariableTypeTable"))
{
varTypeTable = v + 6;
}
else if(attrName.equals("LineNumberTable"))
{
if(!skipDebug)
{
k = readUnsignedShort(v + 6);
w = v + 8;
for(; k > 0; --k)
{
label = readUnsignedShort(w);
if(labels[label] == null)
{
labels[label] = new Label(true);
}
labels[label].line=readUnsignedShort(w + 2);
w += 4;
}
}
}
else if(attrName.equals("StackMapTable"))
{
if((flags & SKIP_FRAMES) == 0)
{
stackMap = v + 8;
frameCount = readUnsignedShort(v + 6);
}
/*
* here we do not extract the labels corresponding to
* the attribute content. This would require a full
208 CHAPTER 7. JVM/CLOJURE/ASM/
* parsing of the attribute, which would need to be
* repeated in the second phase (see below). Instead the
* content of the attribute is read one frame at a time
* (i.e. after a frame has been visited, the next frame
* is read), and the labels it contains are also
* extracted one frame at a time. Thanks to the ordering
* of frames, having only a "one frame lookahead" is not
* a problem, i.e. it is not possible to see an offset
* smaller than the offset of the current insn and for
* which no Label exist.
*/
// TODO true for frame offsets,
// but for UNINITIALIZED type offsets?
}
else if(attrName.equals("StackMap"))
{
if((flags & SKIP_FRAMES) == 0)
{
stackMap = v + 8;
frameCount = readUnsignedShort(v + 6);
zip = false;
}
/*
* IMPORTANT! here we assume that the frames are
* ordered, as in the StackMapTable attribute,
* although this is not guaranteed by the
* attribute format.
*/
}
else
{
for(k = 0; k < attrs.length; ++k)
{
if(attrs[k].type.equals(attrName))
{
attr = attrs[k].read(this,
v + 6,
readInt(v + 2),
c,
codeStart - 8,
labels);
if(attr != null)
{
attr.next = cattrs;
cattrs = attr;
}
}
}
}
v += 6 + readInt(v + 2);
7.6. CLASSREADER.JAVA 209
}
// 2nd phase: visits each instruction
if(stackMap != 0)
{
// creates the very first (implicit) frame from the
// method descriptor
frameLocal = new Object[maxLocals];
frameStack = new Object[maxStack];
if(unzip)
{
int local = 0;
if((access & Opcodes.ACC_STATIC) == 0)
{
if(name.equals("<init>"))
{
frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;
}
else
{
frameLocal[local++] = readClass(header + 2, c);
}
}
j = 1;
loop:
while(true)
{
k = j;
switch(desc.charAt(j++))
{
case’Z’:
case’C’:
case’B’:
case’S’:
case’I’:
frameLocal[local++] = Opcodes.INTEGER;
break;
case’F’:
frameLocal[local++] = Opcodes.FLOAT;
break;
case’J’:
frameLocal[local++] = Opcodes.LONG;
break;
case’D’:
frameLocal[local++] = Opcodes.DOUBLE;
break;
case’[’:
while(desc.charAt(j) == ’[’)
{
++j;
210 CHAPTER 7. JVM/CLOJURE/ASM/
}
if(desc.charAt(j) == ’L’)
{
++j;
while(desc.charAt(j) != ’;’)
{
++j;
}
}
frameLocal[local++] =
desc.substring(k, ++j);
break;
case’L’:
while(desc.charAt(j) != ’;’)
{
++j;
}
frameLocal[local++] =
desc.substring(k + 1, j++);
break;
default:
break loop;
}
}
frameLocalCount = local;
}
/*
* for the first explicit frame the offset is not
* offset_delta + 1 but only offset_delta; setting the
* implicit frame offset to -1 allow the use of the
* "offset_delta + 1" rule in all cases
*/
frameOffset = -1;
}
v = codeStart;
Label l;
while(v < codeEnd)
{
w = v - codeStart;
l = labels[w];
if(l != null)
{
mv.visitLabel(l);
if(!skipDebug && l.line > 0)
{
mv.visitLineNumber(l.line, l);
}
}
7.6. CLASSREADER.JAVA 211
while(frameLocal != null
&& (frameOffset == w || frameOffset == -1))
{
// if there is a frame for this offset,
// makes the visitor visit it,
// and reads the next frame if there is one.
if(!zip || unzip)
{
mv.visitFrame(Opcodes.F_NEW,
frameLocalCount,
frameLocal,
frameStackCount,
frameStack);
}
else if(frameOffset != -1)
{
mv.visitFrame(frameMode,
frameLocalDiff,
frameLocal,
frameStackCount,
frameStack);
}
if(frameCount > 0)
{
int tag, delta, n;
if(zip)
{
tag = b[stackMap++] & 0xFF;
}
else
{
tag = MethodWriter.FULL_FRAME;
frameOffset = -1;
}
frameLocalDiff = 0;
if(tag <
MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME)
{
delta = tag;
frameMode = Opcodes.F_SAME;
frameStackCount = 0;
}
else if(tag < MethodWriter.RESERVED)
{
delta = tag
- MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;
stackMap = readFrameType(frameStack,
0,
stackMap,
212 CHAPTER 7. JVM/CLOJURE/ASM/
c,
labels);
frameMode = Opcodes.F_SAME1;
frameStackCount = 1;
}
else
{
delta = readUnsignedShort(stackMap);
stackMap += 2;
if(tag ==
MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDE D)
{
stackMap = readFrameType(frameStack,
0,
stackMap,
c,
labels);
frameMode = Opcodes.F_SAME1;
frameStackCount = 1;
}
else if(tag >= MethodWriter.CHOP_FRAME &&
tag < MethodWriter.SAME_FRAME_EXTENDED)
{
frameMode = Opcodes.F_CHOP;
frameLocalDiff =
MethodWriter.SAME_FRAME_EXTENDED
- tag;
frameLocalCount -= frameLocalDiff;
frameStackCount = 0;
}
else if(tag ==
MethodWriter.SAME_FRAME_EXTENDED)
{
frameMode = Opcodes.F_SAME;
frameStackCount = 0;
}
else if(tag < MethodWriter.FULL_FRAME)
{
j = unzip ? frameLocalCount : 0;
for(k = tag
- MethodWriter.SAME_FRAME_EXTENDED;
k > 0; k--)
{
stackMap = readFrameType(frameLocal,
j++,
stackMap,
c,
labels);
}
frameMode = Opcodes.F_APPEND;
7.6. CLASSREADER.JAVA 213
frameLocalDiff = tag
- MethodWriter.SAME_FRAME_EXTENDED;
frameLocalCount += frameLocalDiff;
frameStackCount = 0;
}
else
{ // if (tag == FULL_FRAME) {
frameMode = Opcodes.F_FULL;
n = frameLocalDiff
= frameLocalCount
= readUnsignedShort(stackMap);
stackMap += 2;
for(j = 0; n > 0; n--)
{
stackMap = readFrameType(frameLocal,
j++,
stackMap,
c,
labels);
}
n = frameStackCount
= readUnsignedShort(stackMap);
stackMap += 2;
for(j = 0; n > 0; n--)
{
stackMap = readFrameType(frameStack,
j++,
stackMap,
c,
labels);
}
}
}
frameOffset += delta + 1;
if(labels[frameOffset] == null)
{
labels[frameOffset] = new Label();
}
--frameCount;
}
else
{
frameLocal = null;
}
}
int opcode = b[v] & 0xFF;
switch(ClassWriter.TYPE[opcode])
{
214 CHAPTER 7. JVM/CLOJURE/ASM/
case ClassWriter.NOARG_INSN:
mv.visitInsn(opcode);
v += 1;
break;
case ClassWriter.IMPLVAR_INSN:
if(opcode > Opcodes.ISTORE)
{
opcode -= 59; // ISTORE_0
mv.visitVarInsn(
Opcodes.ISTORE + (opcode >> 2),
opcode & 0x3);
}
else
{
opcode -= 26; // ILOAD_0
mv.visitVarInsn(
Opcodes.ILOAD + (opcode >> 2),
opcode & 0x3);
}
v += 1;
break;
case ClassWriter.LABEL_INSN:
mv.visitJumpInsn(opcode,
labels[w + readShort(v + 1)]);
v += 3;
break;
case ClassWriter.LABELW_INSN:
mv.visitJumpInsn(opcode - 33,
labels[w + readInt(v + 1)]);
v += 5;
break;
case ClassWriter.WIDE_INSN:
opcode = b[v + 1] & 0xFF;
if(opcode == Opcodes.IINC)
{
mv.visitIincInsn(readUnsignedShort(v + 2),
readShort(v + 4));
v += 6;
}
else
{
mv.visitVarInsn(opcode,
readUnsignedShort(v + 2));
v += 4;
}
break;
case ClassWriter.TABL_INSN:
// skips 0 to 3 padding bytes
v = v + 4 - (w & 3);
// reads instruction
7.6. CLASSREADER.JAVA 215
label = w + readInt(v);
int min = readInt(v + 4);
int max = readInt(v + 8);
v += 12;
Label[] table = new Label[max - min + 1];
for(j = 0; j < table.length; ++j)
{
table[j] = labels[w + readInt(v)];
v += 4;
}
mv.visitTableSwitchInsn(min,
max,
labels[label],
table);
break;
case ClassWriter.LOOK_INSN:
// skips 0 to 3 padding bytes
v = v + 4 - (w & 3);
// reads instruction
label = w + readInt(v);
j = readInt(v + 4);
v += 8;
int[] keys = new int[j];
Label[] values = new Label[j];
for(j = 0; j < keys.length; ++j)
{
keys[j] = readInt(v);
values[j] = labels[w + readInt(v + 4)];
v += 8;
}
mv.visitLookupSwitchInsn(labels[label],
keys,
values);
break;
case ClassWriter.VAR_INSN:
mv.visitVarInsn(opcode, b[v + 1] & 0xFF);
v += 2;
break;
case ClassWriter.SBYTE_INSN:
mv.visitIntInsn(opcode, b[v + 1]);
v += 2;
break;
case ClassWriter.SHORT_INSN:
mv.visitIntInsn(opcode, readShort(v + 1));
v += 3;
break;
case ClassWriter.LDC_INSN:
mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));
v += 2;
break;
216 CHAPTER 7. JVM/CLOJURE/ASM/
case ClassWriter.LDCW_INSN:
mv.visitLdcInsn(
readConst(readUnsignedShort(v + 1), c));
v += 3;
break;
case ClassWriter.FIELDORMETH_INSN:
case ClassWriter.ITFMETH_INSN:
int cpIndex = items[readUnsignedShort(v + 1)];
String iowner = readClass(cpIndex, c);
cpIndex = items[readUnsignedShort(cpIndex + 2)];
String iname = readUTF8(cpIndex, c);
String idesc = readUTF8(cpIndex + 2, c);
if(opcode < Opcodes.INVOKEVIRTUAL)
{
mv.visitFieldInsn(opcode,iowner,iname,idesc);
}
else
{
mv.visitMethodInsn(opcode,iowner,iname,idesc);
}
if(opcode == Opcodes.INVOKEINTERFACE)
{
v += 5;
}
else
{
v += 3;
}
break;
case ClassWriter.TYPE_INSN:
mv.visitTypeInsn(opcode, readClass(v + 1, c));
v += 3;
break;
case ClassWriter.IINC_INSN:
mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);
v += 3;
break;
// case MANA_INSN:
default:
mv.visitMultiANewArrayInsn(readClass(v + 1, c),
b[v + 3] & 0xFF);
v += 4;
break;
}
}
l = labels[codeEnd - codeStart];
if(l != null)
{
mv.visitLabel(l);
}
7.6. CLASSREADER.JAVA 217
// visits the local variable tables
if(!skipDebug && varTable != 0)
{
int[] typeTable = null;
if(varTypeTable != 0)
{
k = readUnsignedShort(varTypeTable) * 3;
w = varTypeTable + 2;
typeTable = new int[k];
while(k > 0)
{
typeTable[--k]= w + 6; // signature
typeTable[--k]= readUnsignedShort(w + 8); //index
typeTable[--k]= readUnsignedShort(w); // start
w += 10;
}
}
k = readUnsignedShort(varTable);
w = varTable + 2;
for(; k > 0; --k)
{
int start = readUnsignedShort(w);
int length = readUnsignedShort(w + 2);
int index = readUnsignedShort(w + 8);
String vsignature = null;
if(typeTable != null)
{
for(int a = 0; a < typeTable.length; a += 3)
{
if(typeTable[a] == start
&& typeTable[a + 1] == index)
{
vsignature=readUTF8(typeTable[a + 2], c);
break;
}
}
}
mv.visitLocalVariable(readUTF8(w + 4, c),
readUTF8(w + 6, c),
vsignature,
labels[start],
labels[start + length],
index);
w += 10;
}
}
// visits the other attributes
while(cattrs != null)
{
attr = cattrs.next;
218 CHAPTER 7. JVM/CLOJURE/ASM/
cattrs.next = null;
mv.visitAttribute(cattrs);
cattrs = attr;
}
// visits the max stack and max locals values
mv.visitMaxs(maxStack, maxLocals);
}
if(mv != null)
{
mv.visitEnd();
}
}
// visits the end of the class
classVisitor.visitEnd();
}
/**
* Reads parameter annotations and makes the given visitor vi sit them.
*
* @param v start offset in {@link #b b} of the annotations to
* be read.
* @param buf buffer to be used to call {@link #readUTF8 readUT F8},
* {@link #readClass(int,char[]) readClass} or
* {@link #readConst readConst}.
* @param visible <tt>true</tt> if the annotations to be read are visible
* at runtime.
* @param mv the visitor that must visit the annotations.
*/
private void readParameterAnnotations(
int v,
final char[] buf,
final boolean visible,
final MethodVisitor mv){
int n = b[v++] & 0xFF;
for(int i = 0; i < n; ++i)
{
int j = readUnsignedShort(v);
v += 2;
for(; j > 0; --j)
{
v = readAnnotationValues(v + 2, buf, true,
mv.visitParameterAnnotation(i,readUTF8(v, buf),visib le));
}
}
}
/**
* Reads the values of an annotation and makes the given visito r
7.6. CLASSREADER.JAVA 219
* visit them.
*
* @param v the start offset in {@link #b b} of the values to be
* read (including the unsigned short that gives the
* number of values).
* @param buf buffer to be used to call {@link #readUTF8 readUT F8},
* {@link #readClass(int,char[]) readClass} or
* {@link #readConst readConst}.
* @param named if the annotation values are named or not.
* @param av the visitor that must visit the values.
* @return the end offset of the annotation values.
*/
private int readAnnotationValues(
int v,
final char[] buf,
final boolean named,
final AnnotationVisitor av){
int i = readUnsignedShort(v);
v += 2;
if(named)
{
for(; i > 0; --i)
{
v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);
}
}
else
{
for(; i > 0; --i)
{
v = readAnnotationValue(v, buf, null, av);
}
}
if(av != null)
{
av.visitEnd();
}
return v;
}
/**
* Reads a value of an annotation and makes the given visitor vi sit it.
*
* @param v the start offset in {@link #b b} of the value to be
* read (<i>not including the value name constant pool
* index</i>).
* @param buf buffer to be used to call {@link #readUTF8 readUT F8},
* {@link #readClass(int,char[]) readClass} or
* {@link #readConst readConst}.
* @param name the name of the value to be read.
220 CHAPTER 7. JVM/CLOJURE/ASM/
* @param av the visitor that must visit the value.
* @return the end offset of the annotation value.
*/
private int readAnnotationValue(
int v,
final char[] buf,
final String name,
final AnnotationVisitor av){
int i;
if(av == null)
{
switch(b[v] & 0xFF)
{
case’e’: // enum_const_value
return v + 5;
case’@’: // annotation_value
return readAnnotationValues(v + 3, buf, true, null);
case’[’: // array_value
return readAnnotationValues(v + 1, buf, false, null);
default:
return v + 3;
}
}
switch(b[v++] & 0xFF)
{
case’I’: // pointer to CONSTANT_Integer
case’J’: // pointer to CONSTANT_Long
case’F’: // pointer to CONSTANT_Float
case’D’: // pointer to CONSTANT_Double
av.visit(name, readConst(readUnsignedShort(v), buf));
v += 2;
break;
case’B’: // pointer to CONSTANT_Byte
av.visit(name,
new Byte((byte)
readInt(items[readUnsignedShort(v)])));
v += 2;
break;
case’Z’: // pointer to CONSTANT_Boolean
av.visit(name, readInt(items[readUnsignedShort(v)]) = = 0
? Boolean.FALSE
: Boolean.TRUE);
v += 2;
break;
case’S’: // pointer to CONSTANT_Short
av.visit(name,
new Short((short)
readInt(items[readUnsignedShort(v)])));
v += 2;
break;
7.6. CLASSREADER.JAVA 221
case’C’: // pointer to CONSTANT_Char
av.visit(name,
new Character((char)
readInt(items[readUnsignedShort(v)])));
v += 2;
break;
case’s’: // pointer to CONSTANT_Utf8
av.visit(name, readUTF8(v, buf));
v += 2;
break;
case’e’: // enum_const_value
av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf) );
v += 4;
break;
case’c’: // class_info
av.visit(name, Type.getType(readUTF8(v, buf)));
v += 2;
break;
case’@’: // annotation_value
v = readAnnotationValues(v + 2, buf, true,
av.visitAnnotation(name, readUTF8(v, buf)));
break;
case’[’: // array_value
int size = readUnsignedShort(v);
v += 2;
if(size == 0)
{
return readAnnotationValues(v - 2,
buf,
false,
av.visitArray(name));
}
switch(this.b[v++] & 0xFF)
{
case’B’:
byte[] bv = new byte[size];
for(i = 0; i < size; i++)
{
bv[i] =
(byte) readInt(items[readUnsignedShort(v)]);
v += 3;
}
av.visit(name, bv);
--v;
break;
case’Z’:
boolean[] zv = new boolean[size];
for(i = 0; i < size; i++)
{
zv[i] =
222 CHAPTER 7. JVM/CLOJURE/ASM/
readInt(items[readUnsignedShort(v)]) != 0;
v += 3;
}
av.visit(name, zv);
--v;
break;
case’S’:
short[] sv = new short[size];
for(i = 0; i < size; i++)
{
sv[i] =
(short) readInt(items[readUnsignedShort(v)]);
v += 3;
}
av.visit(name, sv);
--v;
break;
case’C’:
char[] cv = new char[size];
for(i = 0; i < size; i++)
{
cv[i] =
(char) readInt(items[readUnsignedShort(v)]);
v += 3;
}
av.visit(name, cv);
--v;
break;
case’I’:
int[] iv = new int[size];
for(i = 0; i < size; i++)
{
iv[i] = readInt(items[readUnsignedShort(v)]);
v += 3;
}
av.visit(name, iv);
--v;
break;
case’J’:
long[] lv = new long[size];
for(i = 0; i < size; i++)
{
lv[i] = readLong(items[readUnsignedShort(v)]);
v += 3;
}
av.visit(name, lv);
--v;
break;
case’F’:
float[] fv = new float[size];
7.6. CLASSREADER.JAVA 223
for(i = 0; i < size; i++)
{
fv[i] =
Float.intBitsToFloat(
readInt(items[readUnsignedShort(v)]));
v += 3;
}
av.visit(name, fv);
--v;
break;
case’D’:
double[] dv = new double[size];
for(i = 0; i < size; i++)
{
dv[i] =
Double.longBitsToDouble(
readLong(items[readUnsignedShort(v)]));
v += 3;
}
av.visit(name, dv);
--v;
break;
default:
v = readAnnotationValues(v - 3,
buf,
false,
av.visitArray(name));
}
}
return v;
}
private int readFrameType(
final Object[] frame,
final int index,
int v,
final char[] buf,
final Label[] labels){
int type = b[v++] & 0xFF;
switch(type)
{
case 0:
frame[index] = Opcodes.TOP;
break;
case 1:
frame[index] = Opcodes.INTEGER;
break;
case 2:
frame[index] = Opcodes.FLOAT;
break;
224 CHAPTER 7. JVM/CLOJURE/ASM/
case 3:
frame[index] = Opcodes.DOUBLE;
break;
case 4:
frame[index] = Opcodes.LONG;
break;
case 5:
frame[index] = Opcodes.NULL;
break;
case 6:
frame[index] = Opcodes.UNINITIALIZED_THIS;
break;
case 7: // Object
frame[index] = readClass(v, buf);
v += 2;
break;
default: // Uninitialized
int offset = readUnsignedShort(v);
if(labels[offset] == null)
{
labels[offset] = new Label();
}
frame[index] = labels[offset];
v += 2;
}
return v;
}
/**
* Reads an attribute in {@link #b b}.
*
* @param attrs prototypes of the attributes that must be pars ed during
* the visit of the class. Any attribute whose type is not
* equal to the type of one the prototypes is ignored
* (i.e. an empty {@link Attribute} instance is returned).
* @param type the type of the attribute.
* @param off index of the first byte of the attribute’s conten t in
* {@link #b b}. The 6 attribute header bytes, containing
* the type and the length of the attribute, are not taken
* into account here (they have already been read).
* @param len the length of the attribute’s content.
* @param buf buffer to be used to call {@link #readUTF8 readUT F8},
* {@link #readClass(int,char[]) readClass} or
* {@link #readConst readConst}.
* @param codeOff index of the first byte of code’s attribute c ontent in
* {@link #b b}, or -1 if the attribute to be read is not
* a code attribute. The 6 attribute header bytes,
* containing the type and the length of the attribute,
* are not taken into account here.
* @param labels the labels of the method’s code, or <tt>null< /tt> if
7.6. CLASSREADER.JAVA 225
* the attribute to be read is not a code attribute.
* @return the attribute that has been read, or <tt>null</tt> to skip
* this attribute.
*/
private Attribute readAttribute(
final Attribute[] attrs,
final String type,
final int off,
final int len,
final char[] buf,
final int codeOff,
final Label[] labels){
for(int i = 0; i < attrs.length; ++i)
{
if(attrs[i].type.equals(type))
{
return attrs[i].read(this, off, len, buf, codeOff, labels );
}
}
return new Attribute(type).read(this, off, len, null, -1, null);
}
// ------------------------------------------------- ------------------
// Utility methods: low level parsing
// ------------------------------------------------- ------------------
/**
* Returns the start index of the constant pool item in {@link # b b},
* plus one. <i>This method is intended for {@link Attribute} sub
* classes, and is normally not needed by class generators or
* adapters.</i>
*
* @param item the index a constant pool item.
* @return the start index of the constant pool item in {@link # b b},
* plus one.
*/
public int getItem(final int item){
return items[item];
}
/**
* Reads a byte value in {@link #b b}. <i>This method is intende d for
* {@link Attribute} sub classes, and is normally not needed b y class
* generators or adapters.</i>
*
* @param index the start index of the value to be read in {@link #b b}.
* @return the read value.
*/
public int readByte(final int index){
return b[index] & 0xFF;
226 CHAPTER 7. JVM/CLOJURE/ASM/
}
/**
* Reads an unsigned short value in {@link #b b}. <i>This metho d is
* intended for {@link Attribute} sub classes, and is normall y not
* needed by class generators or adapters.</i>
*
* @param index the start index of the value to be read in {@link #b b}.
* @return the read value.
*/
public int readUnsignedShort(final int index){
byte[] b = this.b;
return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
}
/**
* Reads a signed short value in {@link #b b}. <i>This method is intended
* for {@link Attribute} sub classes, and is normally not need ed by class
* generators or adapters.</i>
*
* @param index the start index of the value to be read in {@link #b b}.
* @return the read value.
*/
public short readShort(final int index){
byte[] b = this.b;
return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF ));
}
/**
* Reads a signed int value in {@link #b b}. <i>This method is in tended
* for {@link Attribute} sub classes, and is normally not need ed by
* class generators or adapters.</i>
*
* @param index the start index of the value to be read in {@link #b b}.
* @return the read value.
*/
public int readInt(final int index){
byte[] b = this.b;
return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
| ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
}
/**
* Reads a signed long value in {@link #b b}. <i>This method is i ntended
* for {@link Attribute} sub classes, and is normally not need ed by class
* generators or adapters.</i>
*
* @param index the start index of the value to be read in {@link #b b}.
* @return the read value.
*/
7.6. CLASSREADER.JAVA 227
public long readLong(final int index){
long l1 = readInt(index);
long l0 = readInt(index + 4) & 0xFFFFFFFFL;
return (l1 << 32) | l0;
}
/**
* Reads an UTF8 string constant pool item in {@link #b b}. <i>T his
* method is intended for {@link Attribute} sub classes, and i s normally
* not needed by class generators or adapters.</i>
*
* @param index the start index of an unsigned short value in
* {@link #b b}, whose value is the index of an UTF8
* constant pool item.
* @param buf buffer to be used to read the item. This buffer mus t be
* sufficiently large. It is not automatically resized.
* @return the String corresponding to the specified UTF8 ite m.
*/
public String readUTF8(int index, final char[] buf){
int item = readUnsignedShort(index);
String s = strings[item];
if(s != null)
{
return s;
}
index = items[item];
return strings[item] =
readUTF(index + 2, readUnsignedShort(index), buf);
}
/**
* Reads UTF8 string in {@link #b b}.
*
* @param index start offset of the UTF8 string to be read.
* @param utfLen length of the UTF8 string to be read.
* @param buf buffer to be used to read the string. This buffer m ust
* be sufficiently large. It is not automatically resized.
* @return the String corresponding to the specified UTF8 str ing.
*/
private String readUTF(int index, final int utfLen, final c har[] buf){
int endIndex = index + utfLen;
byte[] b = this.b;
int strLen = 0;
int c, d, e;
while(index < endIndex)
{
c = b[index++] & 0xFF;
switch(c >> 4)
{
case 0:
228 CHAPTER 7. JVM/CLOJURE/ASM/
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
// 0xxxxxxx
buf[strLen++] = (char) c;
break;
case 12:
case 13:
// 110x xxxx 10xx xxxx
d = b[index++];
buf[strLen++] = (char) (((c & 0x1F) << 6) | (d & 0x3F));
break;
default:
// 1110 xxxx 10xx xxxx 10xx xxxx
d = b[index++];
e = b[index++];
buf[strLen++] =
(char) (((c & 0x0F) << 12)
| ((d & 0x3F) << 6) | (e & 0x3F));
break;
}
}
return new String(buf, 0, strLen);
}
/**
* Reads a class constant pool item in {@link #b b}. <i>This met hod
* is intended for {@link Attribute} sub classes, and is norma lly not
* needed by class generators or adapters.</i>
*
* @param index the start index of an unsigned short value in
* {@link #b b}, whose value is the index of a class
* constant pool item.
* @param buf buffer to be used to read the item. This buffer mus t be
* sufficiently large. It is not automatically resized.
* @return the String corresponding to the specified class it em.
*/
public String readClass(final int index, final char[] buf) {
// computes the start index of the CONSTANT_Class item in b
// and reads the CONSTANT_Utf8 item designated by
// the first two bytes of this CONSTANT_Class item
return readUTF8(items[readUnsignedShort(index)], buf) ;
}
/**
* Reads a numeric or string constant pool item in {@link #b b}.
7.7. CLASSVISITOR.JAVA 229
* <i>This method is intended for {@link Attribute} sub class es,
* and is normally not needed by class generators or adapters. </i>
*
* @param item the index of a constant pool item.
* @param buf buffer to be used to read the item. This buffer mus t be
* sufficiently large. It is not automatically resized.
* @return the {@link Integer}, {@link Float}, {@link Long},
* {@link Double}, {@link String} or {@link Type} correspond ing
* to the given constant pool item.
*/
public Object readConst(final int item, final char[] buf){
int index = items[item];
switch(b[index - 1])
{
case ClassWriter.INT:
return new Integer(readInt(index));
case ClassWriter.FLOAT:
return new Float(Float.intBitsToFloat(readInt(index)) );
case ClassWriter.LONG:
return new Long(readLong(index));
case ClassWriter.DOUBLE:
return new Double(Double.longBitsToDouble(readLong(in dex)));
case ClassWriter.CLASS:
String s = readUTF8(index, buf);
return s.charAt(0) == ’[’
? Type.getType(s)
: Type.getObjectType(s);
// case ClassWriter.STR:
default:
return readUTF8(index, buf);
}
}
}
———-
7.7 ClassVisitor.java
— ClassVisitor.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A visitor to visit a Java class. The methods of this interfac e
* must be called in the following order: <tt>visit</tt>
* [ <tt>visitSource</tt> ] [ <tt>visitOuterClass</tt> ]
230 CHAPTER 7. JVM/CLOJURE/ASM/
* ( <tt>visitAnnotation</tt> | <tt>visitAttribute</tt> ) *
* (<tt>visitInnerClass</tt> | <tt>visitField</tt> |
* <tt>visitMethod</tt> )* <tt>visitEnd</tt>.
*
* @author Eric Bruneton
*/
public interface ClassVisitor{
/**
* Visits the header of the class.
*
* @param version the class version.
* @param access the class’s access flags (see {@link Opcodes }). This
* parameter also indicates if the class is deprecated.
* @param name the internal name of the class (see
* {@link Type#getInternalName() getInternalName}).
* @param signature the signature of this class. May be <tt>nu ll</tt> if
* the class is not a generic one, and does not extend
* or implement generic classes or interfaces.
* @param superName the internal of name of the super class (se e
* {@link Type#getInternalName() getInternalName}).
* For interfaces, the super class is {@link Object}.
* May be <tt>null</tt>, but only for the
* {@link Object} class.
* @param interfaces the internal names of the class’s interf aces (see
* {@link Type#getInternalName() getInternalName}).
* May be <tt>null</tt>.
*/
void visit(
int version,
int access,
String name,
String signature,
String superName,
String[] interfaces);
/**
* Visits the source of the class.
*
* @param source the name of the source file from which the clas s was
* compiled. May be <tt>null</tt>.
* @param debug additional debug information to compute the
* correspondance between source and compiled elements of
* the class. May be <tt>null</tt>.
*/
void visitSource(String source, String debug);
/**
* Visits the enclosing class of the class. This method must be called
* only if the class has an enclosing class.
7.7. CLASSVISITOR.JAVA 231
*
* @param owner internal name of the enclosing class of the cla ss.
* @param name the name of the method that contains the class, o r
* <tt>null</tt> if the class is not enclosed in a method
* of its enclosing class.
* @param desc the descriptor of the method that contains the c lass, or
* <tt>null</tt> if the class is not enclosed in a method of
* its enclosing class.
*/
void visitOuterClass(String owner, String name, String de sc);
/**
* Visits an annotation of the class.
*
* @param desc the class descriptor of the annotation class.
* @param visible <tt>true</tt> if the annotation is visible at runtime.
* @return a visitor to visit the annotation values, or <tt>nu ll</tt> if
* this visitor is not interested in visiting this annotation .
*/
AnnotationVisitor visitAnnotation(String desc, boolean visible);
/**
* Visits a non standard attribute of the class.
*
* @param attr an attribute.
*/
void visitAttribute(Attribute attr);
/**
* Visits information about an inner class. This inner class i s not
* necessarily a member of the class being visited.
*
* @param name the internal name of an inner class (see
* {@link Type#getInternalName() getInternalName}).
* @param outerName the internal name of the class to which the inner
* class belongs (see {@link Type#getInternalName()
* getInternalName}). May be <tt>null</tt> for not
* member classes.
* @param innerName the (simple) name of the inner class insid e its
* enclosing class. May be <tt>null</tt> for anonymous
* inner classes.
* @param access the access flags of the inner class as origina lly
* declared in the enclosing class.
*/
void visitInnerClass(
String name,
String outerName,
String innerName,
int access);
232 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Visits a field of the class.
*
* @param access the field’s access flags (see {@link Opcodes }).
* This parameter also indicates if the field is
* synthetic and/or deprecated.
* @param name the field’s name.
* @param desc the field’s descriptor (see {@link Type Type}) .
* @param signature the field’s signature. May be <tt>null</ tt> if the
* field’s type does not use generic types.
* @param value the field’s initial value. This parameter, wh ich may
* be <tt>null</tt> if the field does not have an
* initial value, must be an {@link Integer}, a
* {@link Float}, a {@link Long}, a {@link Double} or
* a {@link String} (for <tt>int</tt>, <tt>float</tt>,
* <tt>long</tt> or <tt>String</tt> fields
* respectively). <i>This parameter is only used for
* static fields</i>. Its value is ignored for non
* static fields, which must be initialized through
* bytecode instructions in constructors or methods.
* @return a visitor to visit field annotations and attribute s, or
* <tt>null</tt> if this class visitor is not interested in
* visiting these annotations and attributes.
*/
FieldVisitor visitField(
int access,
String name,
String desc,
String signature,
Object value);
/**
* Visits a method of the class. This method <i>must</i> retur n a new
* {@link MethodVisitor} instance (or <tt>null</tt>) each t ime it is
* called, i.e., it should not return a previously returned vi sitor.
*
* @param access the method’s access flags (see {@link Opcode s}).
* This parameter also indicates if the method is
* synthetic and/or deprecated.
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type Type} ).
* @param signature the method’s signature. May be <tt>null< /tt> if the
* method parameters, return type and exceptions do not
* use generic types.
* @param exceptions the internal names of the method’s excep tion classes
* (see
* {@link Type#getInternalName() getInternalName}).
* May be <tt>null</tt>.
* @return an object to visit the byte code of the method, or
* <tt>null</tt> if this class visitor is not interested in
7.8. CLASSWRITER.JAVA 233
* visiting the code of this method.
*/
MethodVisitor visitMethod(
int access,
String name,
String desc,
String signature,
String[] exceptions);
/**
* Visits the end of the class. This method, which is the last on e to be
* called, is used to inform the visitor that all the fields and methods
* of the class have been visited.
*/
void visitEnd();
}
———-
7.8 ClassWriter.java
(ClassVisitor [229])
— ClassWriter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A {@link ClassVisitor} that generates classes in bytecode form.
* More precisely this visitor generates a byte array conform ing to
* the Java class file format. It can be used alone, to generate a
* Java class "from scratch", or with one or more
* {@link ClassReader ClassReader} and adapter class visito r
* to generate a modified class from one or more existing Java c lasses.
*
* @author Eric Bruneton
*/
public class ClassWriter implements ClassVisitor{
/**
* Flag to automatically compute the maximum stack size and th e
* maximum number of local variables of methods. If this flag i s set,
* then the arguments of the {@link MethodVisitor#visitMaxs visitMaxs}
* method of the {@link MethodVisitor} returned by the
* {@link #visitMethod visitMethod} method will be ignored, and
* computed automatically from the signature and the bytecod e of
* each method.
*
234 CHAPTER 7. JVM/CLOJURE/ASM/
* @see #ClassWriter(int)
*/
public final static int COMPUTE_MAXS = 1;
/**
* Flag to automatically compute the stack map frames of metho ds from
* scratch. If this flag is set, then the calls to the
* {@link MethodVisitor#visitFrame} method are ignored, an d the stack map
* frames are recomputed from the methods bytecode. The argum ents of the
* {@link MethodVisitor#visitMaxs visitMaxs} method are al so ignored and
* recomputed from the bytecode. In other words, computeFram es implies
* computeMaxs.
*
* @see #ClassWriter(int)
*/
public final static int COMPUTE_FRAMES = 2;
/**
* The type of instructions without any argument.
*/
final static int NOARG_INSN = 0;
/**
* The type of instructions with an signed byte argument.
*/
final static int SBYTE_INSN = 1;
/**
* The type of instructions with an signed short argument.
*/
final static int SHORT_INSN = 2;
/**
* The type of instructions with a local variable index argume nt.
*/
final static int VAR_INSN = 3;
/**
* The type of instructions with an implicit local variable in dex
* argument.
*/
final static int IMPLVAR_INSN = 4;
/**
* The type of instructions with a type descriptor argument.
*/
final static int TYPE_INSN = 5;
/**
* The type of field and method invocations instructions.
7.8. CLASSWRITER.JAVA 235
*/
final static int FIELDORMETH_INSN = 6;
/**
* The type of the INVOKEINTERFACE instruction.
*/
final static int ITFMETH_INSN = 7;
/**
* The type of instructions with a 2 bytes bytecode offset labe l.
*/
final static int LABEL_INSN = 8;
/**
* The type of instructions with a 4 bytes bytecode offset labe l.
*/
final static int LABELW_INSN = 9;
/**
* The type of the LDC instruction.
*/
final static int LDC_INSN = 10;
/**
* The type of the LDC_W and LDC2_W instructions.
*/
final static int LDCW_INSN = 11;
/**
* The type of the IINC instruction.
*/
final static int IINC_INSN = 12;
/**
* The type of the TABLESWITCH instruction.
*/
final static int TABL_INSN = 13;
/**
* The type of the LOOKUPSWITCH instruction.
*/
final static int LOOK_INSN = 14;
/**
* The type of the MULTIANEWARRAY instruction.
*/
final static int MANA_INSN = 15;
/**
* The type of the WIDE instruction.
236 CHAPTER 7. JVM/CLOJURE/ASM/
*/
final static int WIDE_INSN = 16;
/**
* The instruction types of all JVM opcodes.
*/
static byte[] TYPE;
/**
* The type of CONSTANT_Class constant pool items.
*/
final static int CLASS = 7;
/**
* The type of CONSTANT_Fieldref constant pool items.
*/
final static int FIELD = 9;
/**
* The type of CONSTANT_Methodref constant pool items.
*/
final static int METH = 10;
/**
* The type of CONSTANT_InterfaceMethodref constant pool it ems.
*/
final static int IMETH = 11;
/**
* The type of CONSTANT_String constant pool items.
*/
final static int STR = 8;
/**
* The type of CONSTANT_Integer constant pool items.
*/
final static int INT = 3;
/**
* The type of CONSTANT_Float constant pool items.
*/
final static int FLOAT = 4;
/**
* The type of CONSTANT_Long constant pool items.
*/
final static int LONG = 5;
/**
* The type of CONSTANT_Double constant pool items.
7.8. CLASSWRITER.JAVA 237
*/
final static int DOUBLE = 6;
/**
* The type of CONSTANT_NameAndType constant pool items.
*/
final static int NAME_TYPE = 12;
/**
* The type of CONSTANT_Utf8 constant pool items.
*/
final static int UTF8 = 1;
/**
* Normal type Item stored in the ClassWriter
* {@link ClassWriter#typeTable}, instead of the constant p ool,
* in order to avoid clashes with normal constant pool items in
* the ClassWriter constant pool’s hash table.
*/
final static int TYPE_NORMAL = 13;
/**
* Uninitialized type Item stored in the ClassWriter
* {@link ClassWriter#typeTable}, instead of the constant p ool, in
* order to avoid clashes with normal constant pool items in th e
* ClassWriter constant pool’s hash table.
*/
final static int TYPE_UNINIT = 14;
/**
* Merged type Item stored in the ClassWriter
* {@link ClassWriter#typeTable}, instead of the constant p ool, in
* order to avoid clashes with normal constant pool items in th e
* ClassWriter constant pool’s hash table.
*/
final static int TYPE_MERGED = 15;
/**
* The class reader from which this class writer was construct ed, if any.
*/
ClassReader cr;
/**
* Minor and major version numbers of the class to be generated .
*/
int version;
/**
* Index of the next item to be added in the constant pool.
*/
238 CHAPTER 7. JVM/CLOJURE/ASM/
int index;
/**
* The constant pool of this class.
*/
ByteVector pool;
/**
* The constant pool’s hash table data.
*/
Item[] items;
/**
* The threshold of the constant pool’s hash table.
*/
int threshold;
/**
* A reusable key used to look for items in the {@link #items} ha sh
* table.
*/
Item key;
/**
* A reusable key used to look for items in the {@link #items} ha sh
* table.
*/
Item key2;
/**
* A reusable key used to look for items in the {@link #items} ha sh
* table.
*/
Item key3;
/**
* A type table used to temporarily store internal names that w ill
* not necessarily be stored in the constant pool. This type ta ble
* is used by the control flow and data flow analysis algorithm
* used to compute stack map frames from scratch. This array
* associates to each index <tt>i</tt> the Item whose index is
* <tt>i</tt>. All Item objects stored in this array are also s tored
* in the {@link #items} hash table. These two arrays allow to r etrieve
* an Item from its index or, conversly, to get the index of an It em
* from its value. Each Item stores an internal name in its
* {@link Item#strVal1} field.
*/
Item[] typeTable;
/**
7.8. CLASSWRITER.JAVA 239
* Number of elements in the {@link #typeTable} array.
*/
private short typeCount; // TODO int?
/**
* The access flags of this class.
*/
private int access;
/**
* The constant pool item that contains the internal name of th is
* class.
*/
private int name;
/**
* The internal name of this class.
*/
String thisName;
/**
* The constant pool item that contains the signature of this c lass.
*/
private int signature;
/**
* The constant pool item that contains the internal name of th e super
* class of this class.
*/
private int superName;
/**
* Number of interfaces implemented or extended by this class or
* interface.
*/
private int interfaceCount;
/**
* The interfaces implemented or extended by this class or int erface.
* More precisely, this array contains the indexes of the cons tant
* pool items that contain the internal names of these interfa ces.
*/
private int[] interfaces;
/**
* The index of the constant pool item that contains the name of the
* source file from which this class was compiled.
*/
private int sourceFile;
240 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* The SourceDebug attribute of this class.
*/
private ByteVector sourceDebug;
/**
* The constant pool item that contains the name of the enclosi ng class
* of this class.
*/
private int enclosingMethodOwner;
/**
* The constant pool item that contains the name and descripto r of the
* enclosing method of this class.
*/
private int enclosingMethod;
/**
* The runtime visible annotations of this class.
*/
private AnnotationWriter anns;
/**
* The runtime invisible annotations of this class.
*/
private AnnotationWriter ianns;
/**
* The non standard attributes of this class.
*/
private Attribute attrs;
/**
* The number of entries in the InnerClasses attribute.
*/
private int innerClassesCount;
/**
* The InnerClasses attribute.
*/
private ByteVector innerClasses;
/**
* The fields of this class. These fields are stored in a linked list
* of {@link FieldWriter} objects, linked to each other by the ir
* {@link FieldWriter#next} field. This field stores the fir st element
* of this list.
*/
FieldWriter firstField;
7.8. CLASSWRITER.JAVA 241
/**
* The fields of this class. These fields are stored in a linked list
* of {@link FieldWriter} objects, linked to each other by the ir
* {@link FieldWriter#next} field. This field stores the las t element
* of this list.
*/
FieldWriter lastField;
/**
* The methods of this class. These methods are stored in a link ed list
* of {@link MethodWriter} objects, linked to each other by th eir
* {@link MethodWriter#next} field. This field stores the fi rst element
* of this list.
*/
MethodWriter firstMethod;
/**
* The methods of this class. These methods are stored in a link ed list
* of {@link MethodWriter} objects, linked to each other by th eir
* {@link MethodWriter#next} field. This field stores the la st element
* of this list.
*/
MethodWriter lastMethod;
/**
* <tt>true</tt> if the maximum stack size and number of local variables
* must be automatically computed.
*/
private boolean computeMaxs;
/**
* <tt>true</tt> if the stack map frames must be recomputed fr om scratch.
*/
private boolean computeFrames;
/**
* <tt>true</tt> if the stack map tables of this class are inva lid. The
* {@link MethodWriter#resizeInstructions} method cannot transform
* existing stack map tables, and so produces potentially inv alid
* classes when it is executed. In this case the class is reread
* and rewritten with the {@link #COMPUTE_FRAMES} option (th e
* resizeInstructions method can resize stack map tables whe n this
* option is used).
*/
boolean invalidFrames;
// ------------------------------------------------- ------------------
// Static initializer
// ------------------------------------------------- ------------------
242 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Computes the instruction types of JVM opcodes.
*/
static
{
int i;
byte[] b = new byte[220];
String s =
"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAA AAAADD"
+ "DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAA"
+ "AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIII IIIIIDNOAA"
+ "AAAAGGGGGGGHAFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII";
for(i = 0; i < b.length; ++i)
{
b[i] = (byte) (s.charAt(i) - ’A’);
}
TYPE = b;
// code to generate the above string
//
// // SBYTE_INSN instructions
// b[Constants.NEWARRAY] = SBYTE_INSN;
// b[Constants.BIPUSH] = SBYTE_INSN;
//
// // SHORT_INSN instructions
// b[Constants.SIPUSH] = SHORT_INSN;
//
// // (IMPL)VAR_INSN instructions
// b[Constants.RET] = VAR_INSN;
// for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {
// b[i] = VAR_INSN;
// }
// for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {
// b[i] = VAR_INSN;
// }
// for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3
// b[i] = IMPLVAR_INSN;
// }
// for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3
// b[i] = IMPLVAR_INSN;
// }
//
// // TYPE_INSN instructions
// b[Constants.NEW] = TYPE_INSN;
// b[Constants.ANEWARRAY] = TYPE_INSN;
// b[Constants.CHECKCAST] = TYPE_INSN;
// b[Constants.INSTANCEOF] = TYPE_INSN;
//
// // (Set)FIELDORMETH_INSN instructions
// for (i = Constants.GETSTATIC; i <= Constants.INVOKESTAT IC; ++i) {
7.8. CLASSWRITER.JAVA 243
// b[i] = FIELDORMETH_INSN;
// }
// b[Constants.INVOKEINTERFACE] = ITFMETH_INSN;
//
// // LABEL(W)_INSN instructions
// for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {
// b[i] = LABEL_INSN;
// }
// b[Constants.IFNULL] = LABEL_INSN;
// b[Constants.IFNONNULL] = LABEL_INSN;
// b[200] = LABELW_INSN; // GOTO_W
// b[201] = LABELW_INSN; // JSR_W
// // temporary opcodes used internally by ASM - see Label and
// MethodWriter
// for (i = 202; i < 220; ++i) {
// b[i] = LABEL_INSN;
// }
//
// // LDC(_W) instructions
// b[Constants.LDC] = LDC_INSN;
// b[19] = LDCW_INSN; // LDC_W
// b[20] = LDCW_INSN; // LDC2_W
//
// // special instructions
// b[Constants.IINC] = IINC_INSN;
// b[Constants.TABLESWITCH] = TABL_INSN;
// b[Constants.LOOKUPSWITCH] = LOOK_INSN;
// b[Constants.MULTIANEWARRAY] = MANA_INSN;
// b[196] = WIDE_INSN; // WIDE
//
// for (i = 0; i < b.length; ++i) {
// System.err.print((char)(’A’ + b[i]));
// }
// System.err.println();
}
// ------------------------------------------------- ------------------
// Constructor
// ------------------------------------------------- ------------------
/**
* Constructs a new {@link ClassWriter} object.
*
* @param flags option flags that can be used to modify the defa ult
* behavior of this class. See {@link #COMPUTE_MAXS},
* {@link #COMPUTE_FRAMES}.
*/
public ClassWriter(final int flags){
index = 1;
pool = new ByteVector();
244 CHAPTER 7. JVM/CLOJURE/ASM/
items = new Item[256];
threshold = (int) (0.75d * items.length);
key = new Item();
key2 = new Item();
key3 = new Item();
this.computeMaxs = (flags & COMPUTE_MAXS) != 0;
this.computeFrames = (flags & COMPUTE_FRAMES) != 0;
}
/**
* Constructs a new {@link ClassWriter} object and enables op timizations
* for "mostly add" bytecode transformations. These optimiz ations are
* the following:
* <p/>
* <ul> <li>The constant pool from the original class is copie d as is
* in the new class, which saves time. New constant pool entrie s will
* be added at the end if necessary, but unused constant pool en tries
* <i>won’t be removed</i>.</li> <li>Methods that are not tr ansformed
* are copied as is in the new class, directly from the original class
* bytecode (i.e. without emitting visit events for all the me thod
* instructions), which saves a <i>lot</i> of time. Untransf ormed
* methods are detected by the fact that the {@link ClassReade r}
* receives {@link MethodVisitor} objects that come from a
* {@link ClassWriter} (and not from a custom {@link ClassAda pter}
* or any other {@link ClassVisitor} instance).</li> </ul>
*
* @param classReader the {@link ClassReader} used to read th e original
* class. It will be used to copy the entire
* constant pool from the original class and also
* to copy other fragments of original bytecode
* where applicable.
* @param flags option flags that can be used to modify the
* default behavior of this class. See
* {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
*/
public ClassWriter(final ClassReader classReader, final int flags){
this(flags);
classReader.copyPool(this);
this.cr = classReader;
}
// ------------------------------------------------- ------------------
// Implementation of the ClassVisitor interface
// ------------------------------------------------- ------------------
public void visit(
final int version,
final int access,
final String name,
final String signature,
7.8. CLASSWRITER.JAVA 245
final String superName,
final String[] interfaces){
this.version = version;
this.access = access;
this.name = newClass(name);
thisName = name;
if(signature != null)
{
this.signature = newUTF8(signature);
}
this.superName = superName == null ? 0 : newClass(superName );
if(interfaces != null && interfaces.length > 0)
{
interfaceCount = interfaces.length;
this.interfaces = new int[interfaceCount];
for(int i = 0; i < interfaceCount; ++i)
{
this.interfaces[i] = newClass(interfaces[i]);
}
}
}
public void visitSource(final String file, final String de bug){
if(file != null)
{
sourceFile = newUTF8(file);
}
if(debug != null)
{
sourceDebug = new ByteVector().putUTF8(debug);
}
}
public void visitOuterClass(
final String owner,
final String name,
final String desc){
enclosingMethodOwner = newClass(owner);
if(name != null && desc != null)
{
enclosingMethod = newNameType(name, desc);
}
}
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
ByteVector bv = new ByteVector();
// write type, and reserve space for values count
bv.putShort(newUTF8(desc)).putShort(0);
246 CHAPTER 7. JVM/CLOJURE/ASM/
AnnotationWriter aw = new AnnotationWriter(this, true, bv , bv, 2);
if(visible)
{
aw.next = anns;
anns = aw;
}
else
{
aw.next = ianns;
ianns = aw;
}
return aw;
}
public void visitAttribute(final Attribute attr){
attr.next = attrs;
attrs = attr;
}
public void visitInnerClass(
final String name,
final String outerName,
final String innerName,
final int access){
if(innerClasses == null)
{
innerClasses = new ByteVector();
}
++innerClassesCount;
innerClasses.putShort(name == null ? 0 : newClass(name));
innerClasses.putShort(outerName == null ? 0 : newClass(ou terName));
innerClasses.putShort(innerName == null ? 0 : newUTF8(inn erName));
innerClasses.putShort(access);
}
public FieldVisitor visitField(
final int access,
final String name,
final String desc,
final String signature,
final Object value){
return new FieldWriter(this, access, name, desc, signatur e, value);
}
public MethodVisitor visitMethod(
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions){
7.8. CLASSWRITER.JAVA 247
return new MethodWriter(this,
access,
name,
desc,
signature,
exceptions,
computeMaxs,
computeFrames);
}
public void visitEnd(){
}
// ------------------------------------------------- ------------------
// Other public methods
// ------------------------------------------------- ------------------
/**
* Returns the bytecode of the class that was build with this cl ass
* writer.
*
* @return the bytecode of the class that was build with this cl ass
* writer.
*/
public byte[] toByteArray(){
// computes the real size of the bytecode of this class
int size = 24 + 2 * interfaceCount;
int nbFields = 0;
FieldWriter fb = firstField;
while(fb != null)
{
++nbFields;
size += fb.getSize();
fb = fb.next;
}
int nbMethods = 0;
MethodWriter mb = firstMethod;
while(mb != null)
{
++nbMethods;
size += mb.getSize();
mb = mb.next;
}
int attributeCount = 0;
if(signature != 0)
{
++attributeCount;
size += 8;
newUTF8("Signature");
}
248 CHAPTER 7. JVM/CLOJURE/ASM/
if(sourceFile != 0)
{
++attributeCount;
size += 8;
newUTF8("SourceFile");
}
if(sourceDebug != null)
{
++attributeCount;
size += sourceDebug.length + 4;
newUTF8("SourceDebugExtension");
}
if(enclosingMethodOwner != 0)
{
++attributeCount;
size += 10;
newUTF8("EnclosingMethod");
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
++attributeCount;
size += 6;
newUTF8("Deprecated");
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (version & 0xffff) < Opcodes.V1_5)
{
++attributeCount;
size += 6;
newUTF8("Synthetic");
}
if(innerClasses != null)
{
++attributeCount;
size += 8 + innerClasses.length;
newUTF8("InnerClasses");
}
if(anns != null)
{
++attributeCount;
size += 8 + anns.getSize();
newUTF8("RuntimeVisibleAnnotations");
}
if(ianns != null)
{
++attributeCount;
size += 8 + ianns.getSize();
newUTF8("RuntimeInvisibleAnnotations");
}
if(attrs != null)
7.8. CLASSWRITER.JAVA 249
{
attributeCount += attrs.getCount();
size += attrs.getSize(this, null, 0, -1, -1);
}
size += pool.length;
// allocates a byte vector of this size, in order to
// avoid unnecessary arraycopy operations in the
// ByteVector.enlarge() method
ByteVector out = new ByteVector(size);
out.putInt(0xCAFEBABE).putInt(version);
out.putShort(index).putByteArray(pool.data, 0, pool.l ength);
out.putShort(access).putShort(name).putShort(superN ame);
out.putShort(interfaceCount);
for(int i = 0; i < interfaceCount; ++i)
{
out.putShort(interfaces[i]);
}
out.putShort(nbFields);
fb = firstField;
while(fb != null)
{
fb.put(out);
fb = fb.next;
}
out.putShort(nbMethods);
mb = firstMethod;
while(mb != null)
{
mb.put(out);
mb = mb.next;
}
out.putShort(attributeCount);
if(signature != 0)
{
out.putShort(newUTF8("Signature"))
.putInt(2)
.putShort(signature);
}
if(sourceFile != 0)
{
out.putShort(newUTF8("SourceFile"))
.putInt(2)
.putShort(sourceFile);
}
if(sourceDebug != null)
{
int len = sourceDebug.length - 2;
out.putShort(newUTF8("SourceDebugExtension"))
.putInt(len);
out.putByteArray(sourceDebug.data, 2, len);
250 CHAPTER 7. JVM/CLOJURE/ASM/
}
if(enclosingMethodOwner != 0)
{
out.putShort(newUTF8("EnclosingMethod"))
.putInt(4);
out.putShort(enclosingMethodOwner)
.putShort(enclosingMethod);
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
out.putShort(newUTF8("Deprecated")).putInt(0);
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (version & 0xffff) < Opcodes.V1_5)
{
out.putShort(newUTF8("Synthetic")).putInt(0);
}
if(innerClasses != null)
{
out.putShort(newUTF8("InnerClasses"));
out.putInt(innerClasses.length + 2)
.putShort(innerClassesCount);
out.putByteArray(innerClasses.data,
0,innerClasses.length);
}
if(anns != null)
{
out.putShort(newUTF8("RuntimeVisibleAnnotations"));
anns.put(out);
}
if(ianns != null)
{
out.putShort(newUTF8("RuntimeInvisibleAnnotations") );
ianns.put(out);
}
if(attrs != null)
{
attrs.put(this, null, 0, -1, -1, out);
}
if(invalidFrames)
{
ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);
new ClassReader(out.data).accept(cw, ClassReader.SKIP _FRAMES);
return cw.toByteArray();
}
return out.data;
}
// ------------------------------------------------- ------------------
// Utility methods: constant pool management
7.8. CLASSWRITER.JAVA 251
// ------------------------------------------------- ------------------
/**
* Adds a number or string constant to the constant pool of the c lass
* being build. Does nothing if the constant pool already cont ains
* a similar item.
*
* @param cst the value of the constant to be added to the consta nt
* pool. This parameter must be an {@link Integer},
* a {@link Float}, a {@link Long}, a {@link Double},
* a {@link String} or a {@link Type}.
* @return a new or already existing constant item with the giv en value.
*/
Item newConstItem(final Object cst){
if(cst instanceof Integer)
{
int val = ((Integer) cst).intValue();
return newInteger(val);
}
else if(cst instanceof Byte)
{
int val = ((Byte) cst).intValue();
return newInteger(val);
}
else if(cst instanceof Character)
{
int val = ((Character) cst).charValue();
return newInteger(val);
}
else if(cst instanceof Short)
{
int val = ((Short) cst).intValue();
return newInteger(val);
}
else if(cst instanceof Boolean)
{
int val = ((Boolean) cst).booleanValue() ? 1 : 0;
return newInteger(val);
}
else if(cst instanceof Float)
{
float val = ((Float) cst).floatValue();
return newFloat(val);
}
else if(cst instanceof Long)
{
long val = ((Long) cst).longValue();
return newLong(val);
}
else if(cst instanceof Double)
252 CHAPTER 7. JVM/CLOJURE/ASM/
{
double val = ((Double) cst).doubleValue();
return newDouble(val);
}
else if(cst instanceof String)
{
return newString((String) cst);
}
else if(cst instanceof Type)
{
Type t = (Type) cst;
return newClassItem(t.getSort() == Type.OBJECT
? t.getInternalName()
: t.getDescriptor());
}
else
{
throw new IllegalArgumentException("value " + cst);
}
}
/**
* Adds a number or string constant to the constant pool of the c lass
* being build. Does nothing if the constant pool already cont ains a
* similar item. <i>This method is intended for {@link Attrib ute}
* sub classes, and is normally not needed by class generators or
* adapters.</i>
*
* @param cst the value of the constant to be added to the consta nt pool.
* This parameter must be an {@link Integer}, a {@link Float},
* a {@link Long}, a {@link Double} or a {@link String}.
* @return the index of a new or already existing constant item with the
* given value.
*/
public int newConst(final Object cst){
return newConstItem(cst).index;
}
/**
* Adds an UTF8 string to the constant pool of the class being bu ild.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and
* is normally not needed by class generators or adapters.</i >
*
* @param value the String value.
* @return the index of a new or already existing UTF8 item.
*/
public int newUTF8(final String value){
key.set(UTF8, value, null, null);
Item result = get(key);
7.8. CLASSWRITER.JAVA 253
if(result == null)
{
pool.putByte(UTF8).putUTF8(value);
result = new Item(index++, key);
put(result);
}
return result.index;
}
/**
* Adds a class reference to the constant pool of the class bein g build.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and is
* normally not needed by class generators or adapters.</i>
*
* @param value the internal name of the class.
* @return a new or already existing class reference item.
*/
Item newClassItem(final String value){
key2.set(CLASS, value, null, null);
Item result = get(key2);
if(result == null)
{
pool.put12(CLASS, newUTF8(value));
result = new Item(index++, key2);
put(result);
}
return result;
}
/**
* Adds a class reference to the constant pool of the class bein g build.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and is
* normally not needed by class generators or adapters.</i>
*
* @param value the internal name of the class.
* @return the index of a new or already existing class referen ce item.
*/
public int newClass(final String value){
return newClassItem(value).index;
}
/**
* Adds a field reference to the constant pool of the class bein g build.
* Does nothing if the constant pool already contains a simila r item.
*
* @param owner the internal name of the field’s owner class.
* @param name the field’s name.
* @param desc the field’s descriptor.
254 CHAPTER 7. JVM/CLOJURE/ASM/
* @return a new or already existing field reference item.
*/
Item newFieldItem(final String owner,
final String name,
final String desc){
key3.set(FIELD, owner, name, desc);
Item result = get(key3);
if(result == null)
{
put122(FIELD, newClass(owner), newNameType(name, desc) );
result = new Item(index++, key3);
put(result);
}
return result;
}
/**
* Adds a field reference to the constant pool of the class bein g build.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and is
* normally not needed by class generators or adapters.</i>
*
* @param owner the internal name of the field’s owner class.
* @param name the field’s name.
* @param desc the field’s descriptor.
* @return the index of a new or already existing field referen ce item.
*/
public int newField(final String owner,
final String name,
final String desc){
return newFieldItem(owner, name, desc).index;
}
/**
* Adds a method reference to the constant pool of the class bei ng build.
* Does nothing if the constant pool already contains a simila r item.
*
* @param owner the internal name of the method’s owner class.
* @param name the method’s name.
* @param desc the method’s descriptor.
* @param itf <tt>true</tt> if <tt>owner</tt> is an interfac e.
* @return a new or already existing method reference item.
*/
Item newMethodItem(
final String owner,
final String name,
final String desc,
final boolean itf){
int type = itf ? IMETH : METH;
key3.set(type, owner, name, desc);
7.8. CLASSWRITER.JAVA 255
Item result = get(key3);
if(result == null)
{
put122(type, newClass(owner), newNameType(name, desc)) ;
result = new Item(index++, key3);
put(result);
}
return result;
}
/**
* Adds a method reference to the constant pool of the class bei ng build.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and is
* normally not needed by class generators or adapters.</i>
*
* @param owner the internal name of the method’s owner class.
* @param name the method’s name.
* @param desc the method’s descriptor.
* @param itf <tt>true</tt> if <tt>owner</tt> is an interfac e.
* @return the index of a new or already existing method refere nce item.
*/
public int newMethod(
final String owner,
final String name,
final String desc,
final boolean itf){
return newMethodItem(owner, name, desc, itf).index;
}
/**
* Adds an integer to the constant pool of the class being build . Does
* nothing if the constant pool already contains a similar ite m.
*
* @param value the int value.
* @return a new or already existing int item.
*/
Item newInteger(final int value){
key.set(value);
Item result = get(key);
if(result == null)
{
pool.putByte(INT).putInt(value);
result = new Item(index++, key);
put(result);
}
return result;
}
/**
256 CHAPTER 7. JVM/CLOJURE/ASM/
* Adds a float to the constant pool of the class being build. Do es
* nothing if the constant pool already contains a similar ite m.
*
* @param value the float value.
* @return a new or already existing float item.
*/
Item newFloat(final float value){
key.set(value);
Item result = get(key);
if(result == null)
{
pool.putByte(FLOAT).putInt(key.intVal);
result = new Item(index++, key);
put(result);
}
return result;
}
/**
* Adds a long to the constant pool of the class being build. Doe s
* nothing if the constant pool already contains a similar ite m.
*
* @param value the long value.
* @return a new or already existing long item.
*/
Item newLong(final long value){
key.set(value);
Item result = get(key);
if(result == null)
{
pool.putByte(LONG).putLong(value);
result = new Item(index, key);
put(result);
index += 2;
}
return result;
}
/**
* Adds a double to the constant pool of the class being build. D oes
* nothing if the constant pool already contains a similar ite m.
*
* @param value the double value.
* @return a new or already existing double item.
*/
Item newDouble(final double value){
key.set(value);
Item result = get(key);
if(result == null)
{
7.8. CLASSWRITER.JAVA 257
pool.putByte(DOUBLE).putLong(key.longVal);
result = new Item(index, key);
put(result);
index += 2;
}
return result;
}
/**
* Adds a string to the constant pool of the class being build. D oes
* nothing if the constant pool already contains a similar ite m.
*
* @param value the String value.
* @return a new or already existing string item.
*/
private Item newString(final String value){
key2.set(STR, value, null, null);
Item result = get(key2);
if(result == null)
{
pool.put12(STR, newUTF8(value));
result = new Item(index++, key2);
put(result);
}
return result;
}
/**
* Adds a name and type to the constant pool of the class being bu ild.
* Does nothing if the constant pool already contains a simila r item.
* <i>This method is intended for {@link Attribute} sub class es, and
* is normally not needed by class generators or adapters.</i >
*
* @param name a name.
* @param desc a type descriptor.
* @return the index of a new or already existing name and type i tem.
*/
public int newNameType(final String name, final String des c){
key2.set(NAME_TYPE, name, desc, null);
Item result = get(key2);
if(result == null)
{
put122(NAME_TYPE, newUTF8(name), newUTF8(desc));
result = new Item(index++, key2);
put(result);
}
return result.index;
}
/**
258 CHAPTER 7. JVM/CLOJURE/ASM/
* Adds the given internal name to {@link #typeTable} and retu rns its
* index. Does nothing if the type table already contains this internal
* name.
*
* @param type the internal name to be added to the type table.
* @return the index of this internal name in the type table.
*/
int addType(final String type){
key.set(TYPE_NORMAL, type, null, null);
Item result = get(key);
if(result == null)
{
result = addType(key);
}
return result.index;
}
/**
* Adds the given "uninitialized" type to {@link #typeTable} and returns
* its index. This method is used for UNINITIALIZED types, mad e of an
* internal name and a bytecode offset.
*
* @param type the internal name to be added to the type table.
* @param offset the bytecode offset of the NEW instruction th at created
* this UNINITIALIZED type value.
* @return the index of this internal name in the type table.
*/
int addUninitializedType(final String type, final int off set){
key.type = TYPE_UNINIT;
key.intVal = offset;
key.strVal1 = type;
key.hashCode =
0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);
Item result = get(key);
if(result == null)
{
result = addType(key);
}
return result.index;
}
/**
* Adds the given Item to {@link #typeTable}.
*
* @param item the value to be added to the type table.
* @return the added Item, which a new Item instance with the sa me
* value as the given Item.
*/
private Item addType(final Item item){
++typeCount;
7.8. CLASSWRITER.JAVA 259
Item result = new Item(typeCount, key);
put(result);
if(typeTable == null)
{
typeTable = new Item[16];
}
if(typeCount == typeTable.length)
{
Item[] newTable = new Item[2 * typeTable.length];
System.arraycopy(typeTable, 0,
newTable, 0, typeTable.length);
typeTable = newTable;
}
typeTable[typeCount] = result;
return result;
}
/**
* Returns the index of the common super type of the two given ty pes.
* This method calls {@link #getCommonSuperClass} and cache s the result
* in the {@link #items} hash table to speedup future calls wit h the
* same parameters.
*
* @param type1 index of an internal name in {@link #typeTable }.
* @param type2 index of an internal name in {@link #typeTable }.
* @return the index of the common super type of the two given ty pes.
*/
int getMergedType(final int type1, final int type2){
key2.type = TYPE_MERGED;
key2.longVal = type1 | (((long) type2) << 32);
key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);
Item result = get(key2);
if(result == null)
{
String t = typeTable[type1].strVal1;
String u = typeTable[type2].strVal1;
key2.intVal = addType(getCommonSuperClass(t, u));
result = new Item((short) 0, key2);
put(result);
}
return result.intVal;
}
/**
* Returns the common super type of the two given types. The def ault
* implementation of this method <i>loads<i> the two given cl asses
* and uses the java.lang.Class methods to find the common sup er class.
* It can be overriden to compute this common super type in othe r ways,
* in particular without actually loading any class, or to tak e into
* account the class that is currently being generated by this
260 CHAPTER 7. JVM/CLOJURE/ASM/
* ClassWriter, which can of course not be loaded since it is un der
* construction.
*
* @param type1 the internal name of a class.
* @param type2 the internal name of another class.
* @return the internal name of the common super class of the tw o given
* classes.
*/
protected String getCommonSuperClass(final String type1 ,
final String type2){
Class c, d;
try
{
c = Class.forName(type1.replace(’/’, ’.’));
d = Class.forName(type2.replace(’/’, ’.’));
}
catch(ClassNotFoundException e)
{
throw new RuntimeException(e);
}
if(c.isAssignableFrom(d))
{
return type1;
}
if(d.isAssignableFrom(c))
{
return type2;
}
if(c.isInterface() || d.isInterface())
{
return "java/lang/Object";
}
else
{
do
{
c = c.getSuperclass();
} while(!c.isAssignableFrom(d));
return c.getName().replace(’.’, ’/’);
}
}
/**
* Returns the constant pool’s hash table item which is equal t o the
* given item.
*
* @param key a constant pool item.
* @return the constant pool’s hash table item which is equal t o the
* given item, or <tt>null</tt> if there is no such item.
*/
7.8. CLASSWRITER.JAVA 261
private Item get(final Item key){
Item i = items[key.hashCode % items.length];
while(i != null && !key.isEqualTo(i))
{
i = i.next;
}
return i;
}
/**
* Puts the given item in the constant pool’s hash table. The ha sh
* table <i>must</i> not already contains this item.
*
* @param i the item to be added to the constant pool’s hash tabl e.
*/
private void put(final Item i){
if(index > threshold)
{
int ll = items.length;
int nl = ll * 2 + 1;
Item[] newItems = new Item[nl];
for(int l = ll - 1; l >= 0; --l)
{
Item j = items[l];
while(j != null)
{
int index = j.hashCode % newItems.length;
Item k = j.next;
j.next = newItems[index];
newItems[index] = j;
j = k;
}
}
items = newItems;
threshold = (int) (nl * 0.75);
}
int index = i.hashCode % items.length;
i.next = items[index];
items[index] = i;
}
/**
* Puts one byte and two shorts into the constant pool.
*
* @param b a byte.
* @param s1 a short.
* @param s2 another short.
*/
private void put122(final int b, final int s1, final int s2){
pool.put12(b, s1).putShort(s2);
262 CHAPTER 7. JVM/CLOJURE/ASM/
}
}
———-
7.9 Edge.java
— Edge.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* An edge in the control flow graph of a method body. See
* {@link Label Label}.
*
* @author Eric Bruneton
*/
class Edge{
/**
* Denotes a normal control flow graph edge.
*/
final static int NORMAL = 0;
/**
* Denotes a control flow graph edge corresponding to an excep tion
* handler. More precisely any {@link Edge} whose {@link #inf o} is
* strictly positive corresponds to an exception handler. Th e actual
* value of {@link #info} is the index, in the {@link ClassWrit er}
* type table, of the exception that is catched.
*/
final static int EXCEPTION = 0x7FFFFFFF;
/**
* Information about this control flow graph edge. If
* {@link ClassWriter#COMPUTE_MAXS} is used this field is th e
* (relative) stack size in the basic block from which this edg e
* originates. This size is equal to the stack size at the "jump "
* instruction to which this edge corresponds, relatively to the
* stack size at the beginning of the originating basic block.
* If {@link ClassWriter#COMPUTE_FRAMES} is used, this fiel d is
* the kind of this control flow graph edge (i.e. NORMAL or EXCE PTION).
*/
int info;
/**
7.10. FIELDVISITOR.JAVA 263
* The successor block of the basic block from which this edge
* originates.
*/
Label successor;
/**
* The next edge in the list of successors of the originating ba sic
* block. See {@link Label#successors successors}.
*/
Edge next;
}
———-
7.10 FieldVisitor.java
— FieldVisitor.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A visitor to visit a Java field. The methods of this interfac e
* must be called in the following order: ( <tt>visitAnnotati on</tt> |
* <tt>visitAttribute</tt> )* <tt>visitEnd</tt>.
*
* @author Eric Bruneton
*/
public interface FieldVisitor{
/**
* Visits an annotation of the field.
*
* @param desc the class descriptor of the annotation class.
* @param visible <tt>true</tt> if the annotation is visible at runtime.
* @return a visitor to visit the annotation values, or <tt>nu ll</tt> if
* this visitor is not interested in visiting this annotation .
*/
AnnotationVisitor visitAnnotation(String desc, boolean visible);
/**
* Visits a non standard attribute of the field.
*
* @param attr an attribute.
*/
void visitAttribute(Attribute attr);
264 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Visits the end of the field. This method, which is the last on e to be
* called, is used to inform the visitor that all the annotatio ns and
* attributes of the field have been visited.
*/
void visitEnd();
}
———-
7.11 FieldWriter.java
(FieldVisitor [263])
— FieldWriter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* An {@link FieldVisitor} that generates Java fields in byte code form.
*
* @author Eric Bruneton
*/
final class FieldWriter implements FieldVisitor{
/**
* Next field writer (see {@link ClassWriter#firstField fir stField}).
*/
FieldWriter next;
/**
* The class writer to which this field must be added.
*/
private ClassWriter cw;
/**
* Access flags of this field.
*/
private int access;
/**
* The index of the constant pool item that contains the name of this
* method.
*/
private int name;
/**
* The index of the constant pool item that contains the descri ptor of
7.11. FIELDWRITER.JAVA 265
* this field.
*/
private int desc;
/**
* The index of the constant pool item that contains the signat ure of
* this field.
*/
private int signature;
/**
* The index of the constant pool item that contains the consta nt value
* of this field.
*/
private int value;
/**
* The runtime visible annotations of this field. May be <tt>n ull</tt>.
*/
private AnnotationWriter anns;
/**
* The runtime invisible annotations of this field. May be <tt >null</tt>.
*/
private AnnotationWriter ianns;
/**
* The non standard attributes of this field. May be <tt>null< /tt>.
*/
private Attribute attrs;
// ------------------------------------------------- ------------------
// Constructor
// ------------------------------------------------- ------------------
/**
* Constructs a new {@link FieldWriter}.
*
* @param cw the class writer to which this field must be added.
* @param access the field’s access flags (see {@link Opcodes }).
* @param name the field’s name.
* @param desc the field’s descriptor (see {@link Type}).
* @param signature the field’s signature. May be <tt>null</ tt>.
* @param value the field’s constant value. May be <tt>null</ tt>.
*/
protected FieldWriter(
final ClassWriter cw,
final int access,
final String name,
final String desc,
266 CHAPTER 7. JVM/CLOJURE/ASM/
final String signature,
final Object value){
if(cw.firstField == null)
{
cw.firstField = this;
}
else
{
cw.lastField.next = this;
}
cw.lastField = this;
this.cw = cw;
this.access = access;
this.name = cw.newUTF8(name);
this.desc = cw.newUTF8(desc);
if(signature != null)
{
this.signature = cw.newUTF8(signature);
}
if(value != null)
{
this.value = cw.newConstItem(value).index;
}
}
// ------------------------------------------------- ------------------
// Implementation of the FieldVisitor interface
// ------------------------------------------------- ------------------
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
ByteVector bv = new ByteVector();
// write type, and reserve space for values count
bv.putShort(cw.newUTF8(desc)).putShort(0);
AnnotationWriter aw = new AnnotationWriter(cw, true, bv, b v, 2);
if(visible)
{
aw.next = anns;
anns = aw;
}
else
{
aw.next = ianns;
ianns = aw;
}
return aw;
}
public void visitAttribute(final Attribute attr){
7.11. FIELDWRITER.JAVA 267
attr.next = attrs;
attrs = attr;
}
public void visitEnd(){
}
// ------------------------------------------------- ------------------
// Utility methods
// ------------------------------------------------- ------------------
/**
* Returns the size of this field.
*
* @return the size of this field.
*/
int getSize(){
int size = 8;
if(value != 0)
{
cw.newUTF8("ConstantValue");
size += 8;
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
cw.newUTF8("Synthetic");
size += 6;
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
cw.newUTF8("Deprecated");
size += 6;
}
if(signature != 0)
{
cw.newUTF8("Signature");
size += 8;
}
if(anns != null)
{
cw.newUTF8("RuntimeVisibleAnnotations");
size += 8 + anns.getSize();
}
if(ianns != null)
{
cw.newUTF8("RuntimeInvisibleAnnotations");
size += 8 + ianns.getSize();
}
if(attrs != null)
268 CHAPTER 7. JVM/CLOJURE/ASM/
{
size += attrs.getSize(cw, null, 0, -1, -1);
}
return size;
}
/**
* Puts the content of this field into the given byte vector.
*
* @param out where the content of this field must be put.
*/
void put(final ByteVector out){
out.putShort(access).putShort(name).putShort(desc);
int attributeCount = 0;
if(value != 0)
{
++attributeCount;
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
++attributeCount;
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
++attributeCount;
}
if(signature != 0)
{
++attributeCount;
}
if(anns != null)
{
++attributeCount;
}
if(ianns != null)
{
++attributeCount;
}
if(attrs != null)
{
attributeCount += attrs.getCount();
}
out.putShort(attributeCount);
if(value != 0)
{
out.putShort(cw.newUTF8("ConstantValue"));
out.putInt(2).putShort(value);
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
7.12. FRAME.JAVA 269
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
out.putShort(cw.newUTF8("Synthetic")).putInt(0);
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
out.putShort(cw.newUTF8("Deprecated")).putInt(0);
}
if(signature != 0)
{
out.putShort(cw.newUTF8("Signature"));
out.putInt(2).putShort(signature);
}
if(anns != null)
{
out.putShort(cw.newUTF8("RuntimeVisibleAnnotations" ));
anns.put(out);
}
if(ianns != null)
{
out.putShort(cw.newUTF8("RuntimeInvisibleAnnotation s"));
ianns.put(out);
}
if(attrs != null)
{
attrs.put(cw, null, 0, -1, -1, out);
}
}
}
———-
7.12 Frame.java
— Frame.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* Information about the input and output stack map frames of a basic
* block.
*
* @author Eric Bruneton
*/
final class Frame{
270 CHAPTER 7. JVM/CLOJURE/ASM/
/*
* Frames are computed in a two steps process: during the visit
* of each instruction, the state of the frame at the end of
* current basic block is updated by simulating the action of
* the instruction on the previous state of this so called
* "output frame". In visitMaxs, a fix point algorithm is used
* to compute the "input frame" of each basic block, i.e. the
* stack mapframe at the begining of the basic block, starting
* from the input frameof the first basic block (which is
* computed from the method descriptor),and by using the
* previously computed output frames to compute the input
* state of the other blocks.
*
* All output and input frames are stored as arrays of
* integers. Reference and array types are represented by an
* index into a type table (which is not the same as the constant
* pool of the class, in order to avoid adding unnecessary
* constants in the pool - not all computed frames will end up
* being stored in the stack map table). This allows very fast
* type comparisons.
*
* Output stack map frames are computed relatively to the inpu t
* frame of the basic block, which is not yet known when output
* frames are computed. It is therefore necessary to be able to
* represent abstract types such as "the type at position x in
* the input frame locals" or "the type at position x from the
* top of the input frame stack" or even "the type at position
* x in the input frame, with y more (or less) array dimensions" .
* This explains the rather complicated type format used in
* output frames.
*
* This format is the following: DIM KIND VALUE (4, 4 and 24
* bits). DIM is a signed number of array dimensions (from -8 to
* 7). KIND is either BASE, LOCAL or STACK. BASE is used for
* types that are not relative to the input frame. LOCAL is used
* for types that are relative to the input local variable type s.
* STACK is used for types that are relative to the input stack
* types. VALUE depends on KIND. For LOCAL types, it is an index
* in the input local variable types. For STACK types, it is a
* position relatively to the top of input frame stack. For BAS E
* types, it is either one of the constants defined in
* FrameVisitor, or for OBJECT and UNINITIALIZED types, a tag
* and an index in the type table.
*
* Output frames can contain types of any kind and with a
* positive or negative dimension (and even unassigned types ,
* represented by 0 - which does not correspond to any valid
* type value). Input frames can only contain BASE types of
* positive or null dimension. In all cases the type table
* contains only internal type names (array type descriptors
7.12. FRAME.JAVA 271
* are forbidden - dimensions must be represented through the
* DIM field).
*
* The LONG and DOUBLE types are always represented by using
* two slots (LONG + TOP or DOUBLE + TOP), for local variable
* types as well as in the operand stack. This is necessary to
* be able to simulate DUPx_y instructions, whose effect woul d
* be dependent on the actual type values if types were always
* represented by a single slot in the stack (and this is not
* possible, since actual type values are not always known -
* cf LOCAL and STACK type kinds).
*/
/**
* Mask to get the dimension of a frame type. This dimension is a signed
* integer between -8 and 7.
*/
final static int DIM = 0xF0000000;
/**
* Constant to be added to a type to get a type with one more dimen sion.
*/
final static int ARRAY_OF = 0x10000000;
/**
* Constant to be added to a type to get a type with one less dimen sion.
*/
final static int ELEMENT_OF = 0xF0000000;
/**
* Mask to get the kind of a frame type.
*
* @see #BASE
* @see #LOCAL
* @see #STACK
*/
final static int KIND = 0xF000000;
/**
* Mask to get the value of a frame type.
*/
final static int VALUE = 0xFFFFFF;
/**
* Mask to get the kind of base types.
*/
final static int BASE_KIND = 0xFF00000;
/**
* Mask to get the value of base types.
272 CHAPTER 7. JVM/CLOJURE/ASM/
*/
final static int BASE_VALUE = 0xFFFFF;
/**
* Kind of the types that are not relative to an input stack map f rame.
*/
final static int BASE = 0x1000000;
/**
* Base kind of the base reference types. The BASE_VALUE of suc h types
* is an index into the type table.
*/
final static int OBJECT = BASE | 0x700000;
/**
* Base kind of the uninitialized base types. The BASE_VALUE o f such
* types in an index into the type table (the Item at that index
* contains both an instruction offset and an internal class n ame).
*/
final static int UNINITIALIZED = BASE | 0x800000;
/**
* Kind of the types that are relative to the local variable typ es of
* an input stack map frame. The value of such types is a local
* variable index.
*/
private final static int LOCAL = 0x2000000;
/**
* Kind of the the types that are relative to the stack of an inpu t
* stack map frame. The value of such types is a position relati vely
* to the top of this stack.
*/
private final static int STACK = 0x3000000;
/**
* The TOP type. This is a BASE type.
*/
final static int TOP = BASE | 0;
/**
* The BOOLEAN type. This is a BASE type mainly used for array ty pes.
*/
final static int BOOLEAN = BASE | 9;
/**
* The BYTE type. This is a BASE type mainly used for array types .
*/
final static int BYTE = BASE | 10;
7.12. FRAME.JAVA 273
/**
* The CHAR type. This is a BASE type mainly used for array types .
*/
final static int CHAR = BASE | 11;
/**
* The SHORT type. This is a BASE type mainly used for array type s.
*/
final static int SHORT = BASE | 12;
/**
* The INTEGER type. This is a BASE type.
*/
final static int INTEGER = BASE | 1;
/**
* The FLOAT type. This is a BASE type.
*/
final static int FLOAT = BASE | 2;
/**
* The DOUBLE type. This is a BASE type.
*/
final static int DOUBLE = BASE | 3;
/**
* The LONG type. This is a BASE type.
*/
final static int LONG = BASE | 4;
/**
* The NULL type. This is a BASE type.
*/
final static int NULL = BASE | 5;
/**
* The UNINITIALIZED_THIS type. This is a BASE type.
*/
final static int UNINITIALIZED_THIS = BASE | 6;
/**
* The stack size variation corresponding to each JVM instruc tion.
* This stack variation is equal to the size of the values produ ced
* by an instruction, minus the size of the values consumed by t his
* instruction.
*/
final static int[] SIZE;
/**
* Computes the stack size variation corresponding to each JV M
274 CHAPTER 7. JVM/CLOJURE/ASM/
* instruction.
*/
static
{
int i;
int[] b = new int[202];
String s =
"EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDE DDDDD"
+ "CDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDC DCDCDCDCD"
+ "CDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCC CCCCCEFED"
+ "DDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE";
for(i = 0; i < b.length; ++i)
{
b[i] = s.charAt(i) - ’E’;
}
SIZE = b;
// code to generate the above string
//
// int NA = 0; // not applicable (unused opcode or variable
// size opcode)
//
// b = new int[] {
// 0, //NOP, // visitInsn
// 1, //ACONST_NULL, // -
// 1, //ICONST_M1, // -
// 1, //ICONST_0, // -
// 1, //ICONST_1, // -
// 1, //ICONST_2, // -
// 1, //ICONST_3, // -
// 1, //ICONST_4, // -
// 1, //ICONST_5, // -
// 2, //LCONST_0, // -
// 2, //LCONST_1, // -
// 1, //FCONST_0, // -
// 1, //FCONST_1, // -
// 1, //FCONST_2, // -
// 2, //DCONST_0, // -
// 2, //DCONST_1, // -
// 1, //BIPUSH, // visitIntInsn
// 1, //SIPUSH, // -
// 1, //LDC, // visitLdcInsn
// NA, //LDC_W, // -
// NA, //LDC2_W, // -
// 1, //ILOAD, // visitVarInsn
// 2, //LLOAD, // -
// 1, //FLOAD, // -
// 2, //DLOAD, // -
// 1, //ALOAD, // -
// NA, //ILOAD_0, // -
7.12. FRAME.JAVA 275
// NA, //ILOAD_1, // -
// NA, //ILOAD_2, // -
// NA, //ILOAD_3, // -
// NA, //LLOAD_0, // -
// NA, //LLOAD_1, // -
// NA, //LLOAD_2, // -
// NA, //LLOAD_3, // -
// NA, //FLOAD_0, // -
// NA, //FLOAD_1, // -
// NA, //FLOAD_2, // -
// NA, //FLOAD_3, // -
// NA, //DLOAD_0, // -
// NA, //DLOAD_1, // -
// NA, //DLOAD_2, // -
// NA, //DLOAD_3, // -
// NA, //ALOAD_0, // -
// NA, //ALOAD_1, // -
// NA, //ALOAD_2, // -
// NA, //ALOAD_3, // -
// -1, //IALOAD, // visitInsn
// 0, //LALOAD, // -
// -1, //FALOAD, // -
// 0, //DALOAD, // -
// -1, //AALOAD, // -
// -1, //BALOAD, // -
// -1, //CALOAD, // -
// -1, //SALOAD, // -
// -1, //ISTORE, // visitVarInsn
// -2, //LSTORE, // -
// -1, //FSTORE, // -
// -2, //DSTORE, // -
// -1, //ASTORE, // -
// NA, //ISTORE_0, // -
// NA, //ISTORE_1, // -
// NA, //ISTORE_2, // -
// NA, //ISTORE_3, // -
// NA, //LSTORE_0, // -
// NA, //LSTORE_1, // -
// NA, //LSTORE_2, // -
// NA, //LSTORE_3, // -
// NA, //FSTORE_0, // -
// NA, //FSTORE_1, // -
// NA, //FSTORE_2, // -
// NA, //FSTORE_3, // -
// NA, //DSTORE_0, // -
// NA, //DSTORE_1, // -
// NA, //DSTORE_2, // -
// NA, //DSTORE_3, // -
// NA, //ASTORE_0, // -
// NA, //ASTORE_1, // -
276 CHAPTER 7. JVM/CLOJURE/ASM/
// NA, //ASTORE_2, // -
// NA, //ASTORE_3, // -
// -3, //IASTORE, // visitInsn
// -4, //LASTORE, // -
// -3, //FASTORE, // -
// -4, //DASTORE, // -
// -3, //AASTORE, // -
// -3, //BASTORE, // -
// -3, //CASTORE, // -
// -3, //SASTORE, // -
// -1, //POP, // -
// -2, //POP2, // -
// 1, //DUP, // -
// 1, //DUP_X1, // -
// 1, //DUP_X2, // -
// 2, //DUP2, // -
// 2, //DUP2_X1, // -
// 2, //DUP2_X2, // -
// 0, //SWAP, // -
// -1, //IADD, // -
// -2, //LADD, // -
// -1, //FADD, // -
// -2, //DADD, // -
// -1, //ISUB, // -
// -2, //LSUB, // -
// -1, //FSUB, // -
// -2, //DSUB, // -
// -1, //IMUL, // -
// -2, //LMUL, // -
// -1, //FMUL, // -
// -2, //DMUL, // -
// -1, //IDIV, // -
// -2, //LDIV, // -
// -1, //FDIV, // -
// -2, //DDIV, // -
// -1, //IREM, // -
// -2, //LREM, // -
// -1, //FREM, // -
// -2, //DREM, // -
// 0, //INEG, // -
// 0, //LNEG, // -
// 0, //FNEG, // -
// 0, //DNEG, // -
// -1, //ISHL, // -
// -1, //LSHL, // -
// -1, //ISHR, // -
// -1, //LSHR, // -
// -1, //IUSHR, // -
// -1, //LUSHR, // -
// -1, //IAND, // -
7.12. FRAME.JAVA 277
// -2, //LAND, // -
// -1, //IOR, // -
// -2, //LOR, // -
// -1, //IXOR, // -
// -2, //LXOR, // -
// 0, //IINC, // visitIincInsn
// 1, //I2L, // visitInsn
// 0, //I2F, // -
// 1, //I2D, // -
// -1, //L2I, // -
// -1, //L2F, // -
// 0, //L2D, // -
// 0, //F2I, // -
// 1, //F2L, // -
// 1, //F2D, // -
// -1, //D2I, // -
// 0, //D2L, // -
// -1, //D2F, // -
// 0, //I2B, // -
// 0, //I2C, // -
// 0, //I2S, // -
// -3, //LCMP, // -
// -1, //FCMPL, // -
// -1, //FCMPG, // -
// -3, //DCMPL, // -
// -3, //DCMPG, // -
// -1, //IFEQ, // visitJumpInsn
// -1, //IFNE, // -
// -1, //IFLT, // -
// -1, //IFGE, // -
// -1, //IFGT, // -
// -1, //IFLE, // -
// -2, //IF_ICMPEQ, // -
// -2, //IF_ICMPNE, // -
// -2, //IF_ICMPLT, // -
// -2, //IF_ICMPGE, // -
// -2, //IF_ICMPGT, // -
// -2, //IF_ICMPLE, // -
// -2, //IF_ACMPEQ, // -
// -2, //IF_ACMPNE, // -
// 0, //GOTO, // -
// 1, //JSR, // -
// 0, //RET, // visitVarInsn
// -1, //TABLESWITCH, // visiTableSwitchInsn
// -1, //LOOKUPSWITCH, // visitLookupSwitch
// -1, //IRETURN, // visitInsn
// -2, //LRETURN, // -
// -1, //FRETURN, // -
// -2, //DRETURN, // -
// -1, //ARETURN, // -
278 CHAPTER 7. JVM/CLOJURE/ASM/
// 0, //RETURN, // -
// NA, //GETSTATIC, // visitFieldInsn
// NA, //PUTSTATIC, // -
// NA, //GETFIELD, // -
// NA, //PUTFIELD, // -
// NA, //INVOKEVIRTUAL, // visitMethodInsn
// NA, //INVOKESPECIAL, // -
// NA, //INVOKESTATIC, // -
// NA, //INVOKEINTERFACE, // -
// NA, //UNUSED, // NOT VISITED
// 1, //NEW, // visitTypeInsn
// 0, //NEWARRAY, // visitIntInsn
// 0, //ANEWARRAY, // visitTypeInsn
// 0, //ARRAYLENGTH, // visitInsn
// NA, //ATHROW, // -
// 0, //CHECKCAST, // visitTypeInsn
// 0, //INSTANCEOF, // -
// -1, //MONITORENTER, // visitInsn
// -1, //MONITOREXIT, // -
// NA, //WIDE, // NOT VISITED
// NA, //MULTIANEWARRAY, // visitMultiANewArrayInsn
// -1, //IFNULL, // visitJumpInsn
// -1, //IFNONNULL, // -
// NA, //GOTO_W, // -
// NA, //JSR_W, // -
// };
// for (i = 0; i < b.length; ++i) {
// System.err.print((char)(’E’ + b[i]));
// }
// System.err.println();
}
/**
* The label (i.e. basic block) to which these input and output stack map
* frames correspond.
*/
Label owner;
/**
* The input stack map frame locals.
*/
int[] inputLocals;
/**
* The input stack map frame stack.
*/
int[] inputStack;
/**
* The output stack map frame locals.
7.12. FRAME.JAVA 279
*/
private int[] outputLocals;
/**
* The output stack map frame stack.
*/
private int[] outputStack;
/**
* Relative size of the output stack. The exact semantics of th is field
* depends on the algorithm that is used.
* <p/>
* When only the maximum stack size is computed, this field is t he size
* of the output stack relatively to the top of the input stack.
* <p/>
* When the stack map frames are completely computed, this fie ld is the
* actual number of types in {@link #outputStack}.
*/
private int outputStackTop;
/**
* Number of types that are initialized in the basic block.
*
* @see #initializations
*/
private int initializationCount;
/**
* The types that are initialized in the basic block. A constru ctor
* invocation on an UNINITIALIZED or UNINITIALIZED_THIS typ e must
* replace <i>every occurence</i> of this type in the local va riables
* and in the operand stack. This cannot be done during the firs t
* phase of the algorithm since, during this phase, the local v ariables
* and the operand stack are not completely computed. It is the refore
* necessary to store the types on which constructors are invo ked in
* the basic block, in order to do this replacement during the s econd
* phase of the algorithm, where the frames are fully computed . Note
* that this array can contain types that are relative to input locals
* or to the input stack (see below for the description of the
* algorithm).
*/
private int[] initializations;
/**
* Returns the output frame local variable type at the given in dex.
*
* @param local the index of the local that must be returned.
* @return the output frame local variable type at the given in dex.
*/
private int get(final int local){
280 CHAPTER 7. JVM/CLOJURE/ASM/
if(outputLocals == null || local >= outputLocals.length)
{
// this local has never been assigned in this basic block,
// so it is still equal to its value in the input frame
return LOCAL | local;
}
else
{
int type = outputLocals[local];
if(type == 0)
{
// this local has never been assigned in this
// basic block, so it is still equal to its value
// in the input frame
type = outputLocals[local] = LOCAL | local;
}
return type;
}
}
/**
* Sets the output frame local variable type at the given index .
*
* @param local the index of the local that must be set.
* @param type the value of the local that must be set.
*/
private void set(final int local, final int type){
// creates and/or resizes the output local variables
// array if necessary
if(outputLocals == null)
{
outputLocals = new int[10];
}
int n = outputLocals.length;
if(local >= n)
{
int[] t = new int[Math.max(local + 1, 2 * n)];
System.arraycopy(outputLocals, 0, t, 0, n);
outputLocals = t;
}
// sets the local variable
outputLocals[local] = type;
}
/**
* Pushes a new type onto the output frame stack.
*
* @param type the type that must be pushed.
*/
private void push(final int type){
7.12. FRAME.JAVA 281
// creates and/or resizes the output stack array if necessar y
if(outputStack == null)
{
outputStack = new int[10];
}
int n = outputStack.length;
if(outputStackTop >= n)
{
int[] t = new int[Math.max(outputStackTop + 1, 2 * n)];
System.arraycopy(outputStack, 0, t, 0, n);
outputStack = t;
}
// pushes the type on the output stack
outputStack[outputStackTop++] = type;
// updates the maximun height reached by the output stack, if needed
int top = owner.inputStackTop + outputStackTop;
if(top > owner.outputStackMax)
{
owner.outputStackMax = top;
}
}
/**
* Pushes a new type onto the output frame stack.
*
* @param cw the ClassWriter to which this label belongs.
* @param desc the descriptor of the type to be pushed. Can also be a
* method descriptor (in this case this method pushes its
* return type onto the output frame stack).
*/
private void push(final ClassWriter cw, final String desc) {
int type = type(cw, desc);
if(type != 0)
{
push(type);
if(type == LONG || type == DOUBLE)
{
push(TOP);
}
}
}
/**
* Returns the int encoding of the given type.
*
* @param cw the ClassWriter to which this label belongs.
* @param desc a type descriptor.
* @return the int encoding of the given type.
*/
private int type(final ClassWriter cw, final String desc){
282 CHAPTER 7. JVM/CLOJURE/ASM/
String t;
int index = desc.charAt(0) == ’(’ ? desc.indexOf(’)’) + 1 : 0;
switch(desc.charAt(index))
{
case’V’:
return 0;
case’Z’:
case’C’:
case’B’:
case’S’:
case’I’:
return INTEGER;
case’F’:
return FLOAT;
case’J’:
return LONG;
case’D’:
return DOUBLE;
case’L’:
// stores the internal name, not the descriptor!
t = desc.substring(index + 1, desc.length() - 1);
return OBJECT | cw.addType(t);
// case ’[’:
default:
// extracts the dimensions and the element type
int data;
int dims = index + 1;
while(desc.charAt(dims) == ’[’)
{
++dims;
}
switch(desc.charAt(dims))
{
case’Z’:
data = BOOLEAN;
break;
case’C’:
data = CHAR;
break;
case’B’:
data = BYTE;
break;
case’S’:
data = SHORT;
break;
case’I’:
data = INTEGER;
break;
case’F’:
data = FLOAT;
7.12. FRAME.JAVA 283
break;
case’J’:
data = LONG;
break;
case’D’:
data = DOUBLE;
break;
// case ’L’:
default:
// stores the internal name, not the descriptor
t = desc.substring(dims + 1, desc.length() - 1);
data = OBJECT | cw.addType(t);
}
return (dims - index) << 28 | data;
}
}
/**
* Pops a type from the output frame stack and returns its value .
*
* @return the type that has been popped from the output frame s tack.
*/
private int pop(){
if(outputStackTop > 0)
{
return outputStack[--outputStackTop];
}
else
{
// if the output frame stack is empty, pops from the input stac k
return STACK | -(--owner.inputStackTop);
}
}
/**
* Pops the given number of types from the output frame stack.
*
* @param elements the number of types that must be popped.
*/
private void pop(final int elements){
if(outputStackTop >= elements)
{
outputStackTop -= elements;
}
else
{
// if the number of elements to be popped is greater than the
// number of elements in the output stack, clear it, and pops
// the remaining elements from the input stack.
owner.inputStackTop -= elements - outputStackTop;
284 CHAPTER 7. JVM/CLOJURE/ASM/
outputStackTop = 0;
}
}
/**
* Pops a type from the output frame stack.
*
* @param desc the descriptor of the type to be popped. Can also be a
* method descriptor (in this case this method pops the
* types corresponding to the method arguments).
*/
private void pop(final String desc){
char c = desc.charAt(0);
if(c == ’(’)
{
pop((MethodWriter.getArgumentsAndReturnSizes(desc) > > 2) - 1);
}
else if(c == ’J’ || c == ’D’)
{
pop(2);
}
else
{
pop(1);
}
}
/**
* Adds a new type to the list of types on which a constructor is
* invoked in the basic block.
*
* @param var a type on a which a constructor is invoked.
*/
private void init(final int var){
// creates and/or resizes the initializations array if nece ssary
if(initializations == null)
{
initializations = new int[2];
}
int n = initializations.length;
if(initializationCount >= n)
{
int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
System.arraycopy(initializations, 0, t, 0, n);
initializations = t;
}
// stores the type to be initialized
initializations[initializationCount++] = var;
}
7.12. FRAME.JAVA 285
/**
* Replaces the given type with the appropriate type if it is on e of
* the types on which a constructor is invoked in the basic bloc k.
*
* @param cw the ClassWriter to which this label belongs.
* @param t a type
* @return t or, if t is one of the types on which a constructor is
* invoked in the basic block, the type corresponding to this
* constructor.
*/
private int init(final ClassWriter cw, final int t){
int s;
if(t == UNINITIALIZED_THIS)
{
s = OBJECT | cw.addType(cw.thisName);
}
else if((t & (DIM | BASE_KIND)) == UNINITIALIZED)
{
String type = cw.typeTable[t & BASE_VALUE].strVal1;
s = OBJECT | cw.addType(type);
}
else
{
return t;
}
for(int j = 0; j < initializationCount; ++j)
{
int u = initializations[j];
int dim = u & DIM;
int kind = u & KIND;
if(kind == LOCAL)
{
u = dim + inputLocals[u & VALUE];
}
else if(kind == STACK)
{
u = dim + inputStack[inputStack.length - (u & VALUE)];
}
if(t == u)
{
return s;
}
}
return t;
}
/**
* Initializes the input frame of the first basic block from th e method
* descriptor.
*
286 CHAPTER 7. JVM/CLOJURE/ASM/
* @param cw the ClassWriter to which this label belongs.
* @param access the access flags of the method to which this
* label belongs.
* @param args the formal parameter types of this method.
* @param maxLocals the maximum number of local variables of t his method.
*/
void initInputFrame(
final ClassWriter cw,
final int access,
final Type[] args,
final int maxLocals){
inputLocals = new int[maxLocals];
inputStack = new int[0];
int i = 0;
if((access & Opcodes.ACC_STATIC) == 0)
{
if((access & MethodWriter.ACC_CONSTRUCTOR) == 0)
{
inputLocals[i++] = OBJECT | cw.addType(cw.thisName);
}
else
{
inputLocals[i++] = UNINITIALIZED_THIS;
}
}
for(int j = 0; j < args.length; ++j)
{
int t = type(cw, args[j].getDescriptor());
inputLocals[i++] = t;
if(t == LONG || t == DOUBLE)
{
inputLocals[i++] = TOP;
}
}
while(i < maxLocals)
{
inputLocals[i++] = TOP;
}
}
/**
* Simulates the action of the given instruction on the output stack
* frame.
*
* @param opcode the opcode of the instruction.
* @param arg the operand of the instruction, if any.
* @param cw the class writer to which this label belongs.
* @param item the operand of the instructions, if any.
*/
void execute(
7.12. FRAME.JAVA 287
final int opcode,
final int arg,
final ClassWriter cw,
final Item item){
int t1, t2, t3, t4;
switch(opcode)
{
case Opcodes.NOP:
case Opcodes.INEG:
case Opcodes.LNEG:
case Opcodes.FNEG:
case Opcodes.DNEG:
case Opcodes.I2B:
case Opcodes.I2C:
case Opcodes.I2S:
case Opcodes.GOTO:
case Opcodes.RETURN:
break;
case Opcodes.ACONST_NULL:
push(NULL);
break;
case Opcodes.ICONST_M1:
case Opcodes.ICONST_0:
case Opcodes.ICONST_1:
case Opcodes.ICONST_2:
case Opcodes.ICONST_3:
case Opcodes.ICONST_4:
case Opcodes.ICONST_5:
case Opcodes.BIPUSH:
case Opcodes.SIPUSH:
case Opcodes.ILOAD:
push(INTEGER);
break;
case Opcodes.LCONST_0:
case Opcodes.LCONST_1:
case Opcodes.LLOAD:
push(LONG);
push(TOP);
break;
case Opcodes.FCONST_0:
case Opcodes.FCONST_1:
case Opcodes.FCONST_2:
case Opcodes.FLOAD:
push(FLOAT);
break;
case Opcodes.DCONST_0:
case Opcodes.DCONST_1:
case Opcodes.DLOAD:
push(DOUBLE);
push(TOP);
288 CHAPTER 7. JVM/CLOJURE/ASM/
break;
case Opcodes.LDC:
switch(item.type)
{
case ClassWriter.INT:
push(INTEGER);
break;
case ClassWriter.LONG:
push(LONG);
push(TOP);
break;
case ClassWriter.FLOAT:
push(FLOAT);
break;
case ClassWriter.DOUBLE:
push(DOUBLE);
push(TOP);
break;
case ClassWriter.CLASS:
push(OBJECT | cw.addType("java/lang/Class"));
break;
// case ClassWriter.STR:
default:
push(OBJECT | cw.addType("java/lang/String"));
}
break;
case Opcodes.ALOAD:
push(get(arg));
break;
case Opcodes.IALOAD:
case Opcodes.BALOAD:
case Opcodes.CALOAD:
case Opcodes.SALOAD:
pop(2);
push(INTEGER);
break;
case Opcodes.LALOAD:
case Opcodes.D2L:
pop(2);
push(LONG);
push(TOP);
break;
case Opcodes.FALOAD:
pop(2);
push(FLOAT);
break;
case Opcodes.DALOAD:
case Opcodes.L2D:
pop(2);
push(DOUBLE);
7.12. FRAME.JAVA 289
push(TOP);
break;
case Opcodes.AALOAD:
pop(1);
t1 = pop();
push(ELEMENT_OF + t1);
break;
case Opcodes.ISTORE:
case Opcodes.FSTORE:
case Opcodes.ASTORE:
t1 = pop();
set(arg, t1);
if(arg > 0)
{
t2 = get(arg - 1);
// if t2 is of kind STACK or LOCAL we cannot know
// its size!
if(t2 == LONG || t2 == DOUBLE)
{
set(arg - 1, TOP);
}
}
break;
case Opcodes.LSTORE:
case Opcodes.DSTORE:
pop(1);
t1 = pop();
set(arg, t1);
set(arg + 1, TOP);
if(arg > 0)
{
t2 = get(arg - 1);
// if t2 is of kind STACK or LOCAL we cannot know
// its size!
if(t2 == LONG || t2 == DOUBLE)
{
set(arg - 1, TOP);
}
}
break;
case Opcodes.IASTORE:
case Opcodes.BASTORE:
case Opcodes.CASTORE:
case Opcodes.SASTORE:
case Opcodes.FASTORE:
case Opcodes.AASTORE:
pop(3);
break;
case Opcodes.LASTORE:
case Opcodes.DASTORE:
290 CHAPTER 7. JVM/CLOJURE/ASM/
pop(4);
break;
case Opcodes.POP:
case Opcodes.IFEQ:
case Opcodes.IFNE:
case Opcodes.IFLT:
case Opcodes.IFGE:
case Opcodes.IFGT:
case Opcodes.IFLE:
case Opcodes.IRETURN:
case Opcodes.FRETURN:
case Opcodes.ARETURN:
case Opcodes.TABLESWITCH:
case Opcodes.LOOKUPSWITCH:
case Opcodes.ATHROW:
case Opcodes.MONITORENTER:
case Opcodes.MONITOREXIT:
case Opcodes.IFNULL:
case Opcodes.IFNONNULL:
pop(1);
break;
case Opcodes.POP2:
case Opcodes.IF_ICMPEQ:
case Opcodes.IF_ICMPNE:
case Opcodes.IF_ICMPLT:
case Opcodes.IF_ICMPGE:
case Opcodes.IF_ICMPGT:
case Opcodes.IF_ICMPLE:
case Opcodes.IF_ACMPEQ:
case Opcodes.IF_ACMPNE:
case Opcodes.LRETURN:
case Opcodes.DRETURN:
pop(2);
break;
case Opcodes.DUP:
t1 = pop();
push(t1);
push(t1);
break;
case Opcodes.DUP_X1:
t1 = pop();
t2 = pop();
push(t1);
push(t2);
push(t1);
break;
case Opcodes.DUP_X2:
t1 = pop();
t2 = pop();
t3 = pop();
7.12. FRAME.JAVA 291
push(t1);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.DUP2:
t1 = pop();
t2 = pop();
push(t2);
push(t1);
push(t2);
push(t1);
break;
case Opcodes.DUP2_X1:
t1 = pop();
t2 = pop();
t3 = pop();
push(t2);
push(t1);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.DUP2_X2:
t1 = pop();
t2 = pop();
t3 = pop();
t4 = pop();
push(t2);
push(t1);
push(t4);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.SWAP:
t1 = pop();
t2 = pop();
push(t1);
push(t2);
break;
case Opcodes.IADD:
case Opcodes.ISUB:
case Opcodes.IMUL:
case Opcodes.IDIV:
case Opcodes.IREM:
case Opcodes.IAND:
case Opcodes.IOR:
case Opcodes.IXOR:
case Opcodes.ISHL:
292 CHAPTER 7. JVM/CLOJURE/ASM/
case Opcodes.ISHR:
case Opcodes.IUSHR:
case Opcodes.L2I:
case Opcodes.D2I:
case Opcodes.FCMPL:
case Opcodes.FCMPG:
pop(2);
push(INTEGER);
break;
case Opcodes.LADD:
case Opcodes.LSUB:
case Opcodes.LMUL:
case Opcodes.LDIV:
case Opcodes.LREM:
case Opcodes.LAND:
case Opcodes.LOR:
case Opcodes.LXOR:
pop(4);
push(LONG);
push(TOP);
break;
case Opcodes.FADD:
case Opcodes.FSUB:
case Opcodes.FMUL:
case Opcodes.FDIV:
case Opcodes.FREM:
case Opcodes.L2F:
case Opcodes.D2F:
pop(2);
push(FLOAT);
break;
case Opcodes.DADD:
case Opcodes.DSUB:
case Opcodes.DMUL:
case Opcodes.DDIV:
case Opcodes.DREM:
pop(4);
push(DOUBLE);
push(TOP);
break;
case Opcodes.LSHL:
case Opcodes.LSHR:
case Opcodes.LUSHR:
pop(3);
push(LONG);
push(TOP);
break;
case Opcodes.IINC:
set(arg, INTEGER);
break;
7.12. FRAME.JAVA 293
case Opcodes.I2L:
case Opcodes.F2L:
pop(1);
push(LONG);
push(TOP);
break;
case Opcodes.I2F:
pop(1);
push(FLOAT);
break;
case Opcodes.I2D:
case Opcodes.F2D:
pop(1);
push(DOUBLE);
push(TOP);
break;
case Opcodes.F2I:
case Opcodes.ARRAYLENGTH:
case Opcodes.INSTANCEOF:
pop(1);
push(INTEGER);
break;
case Opcodes.LCMP:
case Opcodes.DCMPL:
case Opcodes.DCMPG:
pop(4);
push(INTEGER);
break;
case Opcodes.JSR:
case Opcodes.RET:
throw new RuntimeException(
"JSR/RET are not supported with computeFrames option");
case Opcodes.GETSTATIC:
push(cw, item.strVal3);
break;
case Opcodes.PUTSTATIC:
pop(item.strVal3);
break;
case Opcodes.GETFIELD:
pop(1);
push(cw, item.strVal3);
break;
case Opcodes.PUTFIELD:
pop(item.strVal3);
pop();
break;
case Opcodes.INVOKEVIRTUAL:
case Opcodes.INVOKESPECIAL:
case Opcodes.INVOKESTATIC:
case Opcodes.INVOKEINTERFACE:
294 CHAPTER 7. JVM/CLOJURE/ASM/
pop(item.strVal3);
if(opcode != Opcodes.INVOKESTATIC)
{
t1 = pop();
if(opcode == Opcodes.INVOKESPECIAL
&& item.strVal2.charAt(0) == ’<’)
{
init(t1);
}
}
push(cw, item.strVal3);
break;
case Opcodes.NEW:
push(UNINITIALIZED |
cw.addUninitializedType(item.strVal1, arg));
break;
case Opcodes.NEWARRAY:
pop();
switch(arg)
{
case Opcodes.T_BOOLEAN:
push(ARRAY_OF | BOOLEAN);
break;
case Opcodes.T_CHAR:
push(ARRAY_OF | CHAR);
break;
case Opcodes.T_BYTE:
push(ARRAY_OF | BYTE);
break;
case Opcodes.T_SHORT:
push(ARRAY_OF | SHORT);
break;
case Opcodes.T_INT:
push(ARRAY_OF | INTEGER);
break;
case Opcodes.T_FLOAT:
push(ARRAY_OF | FLOAT);
break;
case Opcodes.T_DOUBLE:
push(ARRAY_OF | DOUBLE);
break;
// case Opcodes.T_LONG:
default:
push(ARRAY_OF | LONG);
break;
}
break;
case Opcodes.ANEWARRAY:
String s = item.strVal1;
pop();
7.12. FRAME.JAVA 295
if(s.charAt(0) == ’[’)
{
push(cw, "[" + s);
}
else
{
push(ARRAY_OF | OBJECT | cw.addType(s));
}
break;
case Opcodes.CHECKCAST:
s = item.strVal1;
pop();
if(s.charAt(0) == ’[’)
{
push(cw, s);
}
else
{
push(OBJECT | cw.addType(s));
}
break;
// case Opcodes.MULTIANEWARRAY:
default:
pop(arg);
push(cw, item.strVal1);
break;
}
}
/**
* Merges the input frame of the given basic block with the inpu t and
* output frames of this basic block. Returns <tt>true</tt> i f the
* input frame of the given label has been changed by this opera tion.
*
* @param cw the ClassWriter to which this label belongs.
* @param frame the basic block whose input frame must be updat ed.
* @param edge the kind of the {@link Edge} between this label a nd
* ’label’. See {@link Edge#info}.
* @return <tt>true</tt> if the input frame of the given label has been
* changed by this operation.
*/
boolean merge(final ClassWriter cw, final Frame frame, fin al int edge){
boolean changed = false;
int i, s, dim, kind, t;
int nLocal = inputLocals.length;
int nStack = inputStack.length;
if(frame.inputLocals == null)
{
frame.inputLocals = new int[nLocal];
296 CHAPTER 7. JVM/CLOJURE/ASM/
changed = true;
}
for(i = 0; i < nLocal; ++i)
{
if(outputLocals != null && i < outputLocals.length)
{
s = outputLocals[i];
if(s == 0)
{
t = inputLocals[i];
}
else
{
dim = s & DIM;
kind = s & KIND;
if(kind == LOCAL)
{
t = dim + inputLocals[s & VALUE];
}
else if(kind == STACK)
{
t = dim + inputStack[nStack - (s & VALUE)];
}
else
{
t = s;
}
}
}
else
{
t = inputLocals[i];
}
if(initializations != null)
{
t = init(cw, t);
}
changed |= merge(cw, t, frame.inputLocals, i);
}
if(edge > 0)
{
for(i = 0; i < nLocal; ++i)
{
t = inputLocals[i];
changed |= merge(cw, t, frame.inputLocals, i);
}
if(frame.inputStack == null)
{
7.12. FRAME.JAVA 297
frame.inputStack = new int[1];
changed = true;
}
changed |= merge(cw, edge, frame.inputStack, 0);
return changed;
}
int nInputStack = inputStack.length + owner.inputStackTo p;
if(frame.inputStack == null)
{
frame.inputStack = new int[nInputStack + outputStackTop] ;
changed = true;
}
for(i = 0; i < nInputStack; ++i)
{
t = inputStack[i];
if(initializations != null)
{
t = init(cw, t);
}
changed |= merge(cw, t, frame.inputStack, i);
}
for(i = 0; i < outputStackTop; ++i)
{
s = outputStack[i];
dim = s & DIM;
kind = s & KIND;
if(kind == LOCAL)
{
t = dim + inputLocals[s & VALUE];
}
else if(kind == STACK)
{
t = dim + inputStack[nStack - (s & VALUE)];
}
else
{
t = s;
}
if(initializations != null)
{
t = init(cw, t);
}
changed |= merge(cw, t, frame.inputStack, nInputStack + i) ;
}
return changed;
}
/**
298 CHAPTER 7. JVM/CLOJURE/ASM/
* Merges the type at the given index in the given type array wit h
* the given type. Returns <tt>true</tt> if the type array has been
* modified by this operation.
*
* @param cw the ClassWriter to which this label belongs.
* @param t the type with which the type array element must be
* merged.
* @param types an array of types.
* @param index the index of the type that must be merged in ’typ es’.
* @return <tt>true</tt> if the type array has been modified b y this
* operation.
*/
private boolean merge(
final ClassWriter cw,
int t,
final int[] types,
final int index){
int u = types[index];
if(u == t)
{
// if the types are equal, merge(u,t)=u, so there is no change
return false;
}
if((t & ~DIM) == NULL)
{
if(u == NULL)
{
return false;
}
t = NULL;
}
if(u == 0)
{
// if types[index] has never been assigned, merge(u,t)=t
types[index] = t;
return true;
}
int v;
if((u & BASE_KIND) == OBJECT || (u & DIM) != 0)
{
// if u is a reference type of any dimension
if(t == NULL)
{
// if t is the NULL type, merge(u,t)=u, so there is no change
return false;
}
else if((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND)))
{
if((u & BASE_KIND) == OBJECT)
{
7.12. FRAME.JAVA 299
// if t is also a reference type, and if u and t have
// the same dimension merge(u,t) = dim(t) | common parent
// of the element types of u and t
v = (t & DIM) | OBJECT
| cw.getMergedType(t & BASE_VALUE, u & BASE_VALUE);
}
else
{
// if u and t are array types, but not with the same
// element type, merge(u,t)=java/lang/Object
v = OBJECT | cw.addType("java/lang/Object");
}
}
else if((t & BASE_KIND) == OBJECT || (t & DIM) != 0)
{
// if t is any other reference or array type,
// merge(u,t)=java/lang/Object
v = OBJECT | cw.addType("java/lang/Object");
}
else
{
// if t is any other type, merge(u,t)=TOP
v = TOP;
}
}
else if(u == NULL)
{
// if u is the NULL type, merge(u,t)=t,
// or TOP if t is not a reference type
v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;
}
else
{
// if u is any other type, merge(u,t)=TOP whatever t
v = TOP;
}
if(u != v)
{
types[index] = v;
return true;
}
return false;
}
}
———-
300 CHAPTER 7. JVM/CLOJURE/ASM/
7.13 Handler.java
— Handler.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* Information about an exception handler block.
*
* @author Eric Bruneton
*/
class Handler{
/**
* Beginning of the exception handler’s scope (inclusive).
*/
Label start;
/**
* End of the exception handler’s scope (exclusive).
*/
Label end;
/**
* Beginning of the exception handler’s code.
*/
Label handler;
/**
* Internal name of the type of exceptions handled by this hand ler, or
* <tt>null</tt> to catch any exceptions.
*/
String desc;
/**
* Constant pool index of the internal name of the type of excep tions
* handled by this handler, or 0 to catch any exceptions.
*/
int type;
/**
* Next exception handler block info.
*/
Handler next;
}
———-
7.14. ITEM.JAVA 301
7.14 Item.java
— Item.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A constant pool item. Constant pool items can be created wit h the
* ’newXXX’ methods in the {@link ClassWriter} class.
*
* @author Eric Bruneton
*/
final class Item{
/**
* Index of this item in the constant pool.
*/
int index;
/**
* Type of this constant pool item. A single class is used to rep resent
* all constant pool item types, in order to minimize the bytec ode size
* of this package. The value of this field is one of
* {@link ClassWriter#INT},
* {@link ClassWriter#LONG}, {@link ClassWriter#FLOAT},
* {@link ClassWriter#DOUBLE}, {@link ClassWriter#UTF8},
* {@link ClassWriter#STR}, {@link ClassWriter#CLASS},
* {@link ClassWriter#NAME_TYPE}, {@link ClassWriter#FIE LD},
* {@link ClassWriter#METH}, {@link ClassWriter#IMETH}.
* <p/>
* Special Item types are used for Items that are stored in the
* ClassWriter {@link ClassWriter#typeTable}, instead of t he constant
* pool, in order to avoid clashes with normal constant pool it ems in
* the ClassWriter constant pool’s hash table. These special item types
* are {@link ClassWriter#TYPE_NORMAL}, {@link ClassWrite r#TYPE_UNINIT}
* and {@link ClassWriter#TYPE_MERGED}.
*/
int type;
/**
* Value of this item, for an integer item.
*/
int intVal;
/**
* Value of this item, for a long item.
*/
302 CHAPTER 7. JVM/CLOJURE/ASM/
long longVal;
/**
* First part of the value of this item, for items that do not hol d a
* primitive value.
*/
String strVal1;
/**
* Second part of the value of this item, for items that do not ho ld a
* primitive value.
*/
String strVal2;
/**
* Third part of the value of this item, for items that do not hol d a
* primitive value.
*/
String strVal3;
/**
* The hash code value of this constant pool item.
*/
int hashCode;
/**
* Link to another constant pool item, used for collision list s in the
* constant pool’s hash table.
*/
Item next;
/**
* Constructs an uninitialized {@link Item}.
*/
Item(){
}
/**
* Constructs an uninitialized {@link Item} for constant poo l element at
* given position.
*
* @param index index of the item to be constructed.
*/
Item(final int index){
this.index = index;
}
/**
* Constructs a copy of the given item.
*
7.14. ITEM.JAVA 303
* @param index index of the item to be constructed.
* @param i the item that must be copied into the item to be
* constructed.
*/
Item(final int index, final Item i){
this.index = index;
type = i.type;
intVal = i.intVal;
longVal = i.longVal;
strVal1 = i.strVal1;
strVal2 = i.strVal2;
strVal3 = i.strVal3;
hashCode = i.hashCode;
}
/**
* Sets this item to an integer item.
*
* @param intVal the value of this item.
*/
void set(final int intVal){
this.type = ClassWriter.INT;
this.intVal = intVal;
this.hashCode = 0x7FFFFFFF & (type + intVal);
}
/**
* Sets this item to a long item.
*
* @param longVal the value of this item.
*/
void set(final long longVal){
this.type = ClassWriter.LONG;
this.longVal = longVal;
this.hashCode = 0x7FFFFFFF & (type + (int) longVal);
}
/**
* Sets this item to a float item.
*
* @param floatVal the value of this item.
*/
void set(final float floatVal){
this.type = ClassWriter.FLOAT;
this.intVal = Float.floatToRawIntBits(floatVal);
this.hashCode = 0x7FFFFFFF & (type + (int) floatVal);
}
/**
* Sets this item to a double item.
304 CHAPTER 7. JVM/CLOJURE/ASM/
*
* @param doubleVal the value of this item.
*/
void set(final double doubleVal){
this.type = ClassWriter.DOUBLE;
this.longVal = Double.doubleToRawLongBits(doubleVal);
this.hashCode = 0x7FFFFFFF & (type + (int) doubleVal);
}
/**
* Sets this item to an item that do not hold a primitive value.
*
* @param type the type of this item.
* @param strVal1 first part of the value of this item.
* @param strVal2 second part of the value of this item.
* @param strVal3 third part of the value of this item.
*/
void set(
final int type,
final String strVal1,
final String strVal2,
final String strVal3){
this.type = type;
this.strVal1 = strVal1;
this.strVal2 = strVal2;
this.strVal3 = strVal3;
switch(type)
{
case ClassWriter.UTF8:
case ClassWriter.STR:
case ClassWriter.CLASS:
case ClassWriter.TYPE_NORMAL:
hashCode = 0x7FFFFFFF & (type + strVal1.hashCode());
return;
case ClassWriter.NAME_TYPE:
hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()
* strVal2.hashCode());
return;
// ClassWriter.FIELD:
// ClassWriter.METH:
// ClassWriter.IMETH:
default:
hashCode = 0x7FFFFFFF &
(type + strVal1.hashCode()
* strVal2.hashCode() * strVal3.hashCode());
}
}
/**
* Indicates if the given item is equal to this one.
7.15. LABEL.JAVA 305
*
* @param i the item to be compared to this one.
* @return <tt>true</tt> if the given item if equal to this one ,
* <tt>false</tt> otherwise.
*/
boolean isEqualTo(final Item i){
if(i.type == type)
{
switch(type)
{
case ClassWriter.INT:
case ClassWriter.FLOAT:
return i.intVal == intVal;
case ClassWriter.TYPE_MERGED:
case ClassWriter.LONG:
case ClassWriter.DOUBLE:
return i.longVal == longVal;
case ClassWriter.UTF8:
case ClassWriter.STR:
case ClassWriter.CLASS:
case ClassWriter.TYPE_NORMAL:
return i.strVal1.equals(strVal1);
case ClassWriter.TYPE_UNINIT:
return i.intVal == intVal && i.strVal1.equals(strVal1);
case ClassWriter.NAME_TYPE:
return i.strVal1.equals(strVal1)
&& i.strVal2.equals(strVal2);
// ClassWriter.FIELD:
// ClassWriter.METH:
// ClassWriter.IMETH:
default:
return i.strVal1.equals(strVal1)
&& i.strVal2.equals(strVal2)
&& i.strVal3.equals(strVal3);
}
}
return false;
}
}
———-
7.15 Label.java
— Label.java —
\getchunk{France Telecom Copyright}
306 CHAPTER 7. JVM/CLOJURE/ASM/
package clojure.asm;
/**
* A label represents a position in the bytecode of a method. La bels
* are used for jump, goto, and switch instructions, and for tr y
* catch blocks.
*
* @author Eric Bruneton
*/
public class Label{
/**
* Indicates if this label is only used for debug attributes. S uch a
* label is not the start of a basic block, the target of a jump
* instruction, or an exception handler. It can be safely igno red
* in control flow graph analysis algorithms (for optimizati on
* purposes).
*/
final static int DEBUG = 1;
/**
* Indicates if the position of this label is known.
*/
final static int RESOLVED = 2;
/**
* Indicates if this label has been updated, after instructio n resizing.
*/
final static int RESIZED = 4;
/**
* Indicates if this basic block has been pushed in the basic bl ock
* stack. See {@link MethodWriter#visitMaxs visitMaxs}.
*/
final static int PUSHED = 8;
/**
* Indicates if this label is the target of a jump instruction, or
* the start of an exception handler.
*/
final static int TARGET = 16;
/**
* Indicates if a stack map frame must be stored for this label.
*/
final static int STORE = 32;
/**
* Indicates if this label corresponds to a reachable basic bl ock.
*/
7.15. LABEL.JAVA 307
final static int REACHABLE = 64;
/**
* Indicates if this basic block ends with a JSR instruction.
*/
final static int JSR = 128;
/**
* Indicates if this basic block ends with a RET instruction.
*/
final static int RET = 256;
/**
* Field used to associate user information to a label.
*/
public Object info;
/**
* Flags that indicate the status of this label.
*
* @see #DEBUG
* @see #RESOLVED
* @see #RESIZED
* @see #PUSHED
* @see #TARGET
* @see #STORE
* @see #REACHABLE
* @see #JSR
* @see #RET
*/
int status;
/**
* The line number corresponding to this label, if known.
*/
int line;
/**
* The position of this label in the code, if known.
*/
int position;
/**
* Number of forward references to this label, times two.
*/
private int referenceCount;
/**
* Informations about forward references. Each forward refe rence is
* described by two consecutive integers in this array: the fi rst one
308 CHAPTER 7. JVM/CLOJURE/ASM/
* is the position of the first byte of the bytecode instructio n that
* contains the forward reference, while the second is the pos ition
* of the first byte of the forward reference itself. In fact th e
* sign of the first integer indicates if this reference uses 2 or 4
* bytes, and its absolute value gives the position of the byte code
* instruction.
*/
private int[] srcAndRefPositions;
// ------------------------------------------------- ------------------
/*
* Fields for the control flow and data flow graph analysis alg orithms
* (used to compute the maximum stack size or the stack map fram es).
* A control flow graph contains one node per "basic block", an d one
* edge per "jump" from one basic block to another. Each node (i .e.,
* each basic block) is represented by the Label object that
* corresponds to the first instruction of this basic block. E ach node
* also stores the list of its successors in the graph, as a link ed
* list of Edge objects.
*
* The control flow analysis algorithms used to compute the ma ximum
* stack size or the stack map frames are similar and use two ste ps.
* The first step, during the visit of each instruction, build s
* information about the state of the local variables and the o perand
* stack at the end of each basic block, called the "output fram e",
* <i>relatively</i> to the frame state at the beginning of th e basic
* block, which is called the "input frame", and which is <i>un known</i>
* during this step. The second step, in
* {@link MethodWriter#visitMaxs}, is a fix point algorithm that
* icomputes information about the input frame of each basic b lock,
* from the nput state of the first basic block (known from the
* method signature), and by the using the previously compute d
* relative output frames.
*
* The algorithm used to compute the maximum stack size only co mputes
* the relative output and absolute input stack heights, whil e the
* algorithm used to compute stack map frames computes relati ve
* output frames and absolute input frames.
*/
/**
* Start of the output stack relatively to the input stack. The exact
* semantics of this field depends on the algorithm that is use d.
* <p/>
* When only the maximum stack size is computed, this field is t he
* number of elements in the input stack.
* <p/>
* When the stack map frames are completely computed, this fie ld is
* the offset of the first output stack element relatively to t he top
7.15. LABEL.JAVA 309
* of the input stack. This offset is always negative or null. A
* null offset means that the output stack must be appended to t he
* input stack. A -n offset means that the first n output stack
* elements must replace the top n input stack elements, and th at
* the other elements must be appended to the input stack.
*/
int inputStackTop;
/**
* Maximum height reached by the output stack, relatively to t he top
* of the input stack. This maximum is always positive or null.
*/
int outputStackMax;
/**
* Information about the input and output stack map frames of t his
* basic block. This field is only used when
* {@link ClassWriter#COMPUTE_FRAMES} option is used.
*/
Frame frame;
/**
* The successor of this label, in the order they are visited. T his
* linked list does not include labels used for debug info only . If
* {@link ClassWriter#COMPUTE_FRAMES} option is used then, in addition,
* it does not contain successive labels that denote the same
* bytecode position (in this case only the first label appear s in
* this list).
*/
Label successor;
/**
* The successors of this node in the control flow graph. These
* successors are stored in a linked list of {@link Edge Edge}
* objects, linked to each other by their {@link Edge#next} fi eld.
*/
Edge successors;
/**
* The next basic block in the basic block stack. This stack is u sed
* in the main loop of the fix point algorithm used in the second step
* of the control flow analysis algorithms.
*
* @see MethodWriter#visitMaxs
*/
Label next;
// ------------------------------------------------- ------------------
// Constructor
// ------------------------------------------------- ------------------
310 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Constructs a new label.
*/
public Label(){
}
/**
* Constructs a new label.
*
* @param debug if this label is only used for debug attributes .
*/
Label(final boolean debug){
this.status = debug ? DEBUG : 0;
}
// ------------------------------------------------- ------------------
// Methods to compute offsets and to manage forward referenc es
// ------------------------------------------------- ------------------
/**
* Returns the offset corresponding to this label. This offse t is
* computed from the start of the method’s bytecode. <i>This m ethod
* is intended for {@link Attribute} sub classes, and is norma lly
* not needed by class generators or adapters.</i>
*
* @return the offset corresponding to this label.
* @throws IllegalStateException if this label is not resolv ed yet.
*/
public int getOffset(){
if((status & RESOLVED) == 0)
{
throw new IllegalStateException(
"Label offset position has not been resolved yet");
}
return position;
}
/**
* Puts a reference to this label in the bytecode of a method. If the
* position of the label is known, the offset is computed and wr itten
* directly. Otherwise, a null offset is written and a new forw ard
* reference is declared for this label.
*
* @param owner the code writer that calls this method.
* @param out the bytecode of the method.
* @param source the position of first byte of the bytecode
* instruction that contains this label.
* @param wideOffset <tt>true</tt> if the reference must be s tored in 4
* bytes, or <tt>false</tt> if it must be stored with 2
7.15. LABEL.JAVA 311
* bytes.
* @throws IllegalArgumentException if this label has not be en created by
* the given code writer.
*/
void put(
final MethodWriter owner,
final ByteVector out,
final int source,
final boolean wideOffset){
if((status & RESOLVED) != 0)
{
if(wideOffset)
{
out.putInt(position - source);
}
else
{
out.putShort(position - source);
}
}
else
{
if(wideOffset)
{
addReference(-1 - source, out.length);
out.putInt(-1);
}
else
{
addReference(source, out.length);
out.putShort(-1);
}
}
}
/**
* Adds a forward reference to this label. This method must be c alled
* only for a true forward reference, i.e. only if this label is not
* resolved yet. For backward references, the offset of the re ference
* can be, and must be, computed and stored directly.
*
* @param sourcePosition the position of the referencing ins truction.
* This position will be used to compute the
* offset of this forward reference.
* @param referencePosition the position where the offset fo r this
* forward reference must be stored.
*/
private void addReference(
final int sourcePosition,
final int referencePosition){
312 CHAPTER 7. JVM/CLOJURE/ASM/
if(srcAndRefPositions == null)
{
srcAndRefPositions = new int[6];
}
if(referenceCount >= srcAndRefPositions.length)
{
int[] a = new int[srcAndRefPositions.length + 6];
System.arraycopy(srcAndRefPositions,
0,
a,
0,
srcAndRefPositions.length);
srcAndRefPositions = a;
}
srcAndRefPositions[referenceCount++] = sourcePosition ;
srcAndRefPositions[referenceCount++] = referencePosit ion;
}
/**
* Resolves all forward references to this label. This method must be
* called when this label is added to the bytecode of the method ,
* i.e. when its position becomes known. This method fills in t he
* blanks that where left in the bytecode by each forward refer ence
* previously added to this label.
*
* @param owner the code writer that calls this method.
* @param position the position of this label in the bytecode.
* @param data the bytecode of the method.
* @return <tt>true</tt> if a blank that was left for this labe l was
* to small to store the offset. In such a case the
* corresponding jump instruction is replaced with a pseudo
* instruction (using unused opcodes) using an unsigned two
* bytes offset. These pseudo instructions will need to be
* replaced with true instructions with wider offsets (4 byte s
* instead of 2). This is done in
* {@link MethodWriter#resizeInstructions}.
* @throws IllegalArgumentException if this label has alrea dy been
* resolved, or if it has not been
created by the given code writer.
*/
boolean resolve(
final MethodWriter owner,
final int position,
final byte[] data){
boolean needUpdate = false;
this.status |= RESOLVED;
this.position = position;
int i = 0;
while(i < referenceCount)
{
7.15. LABEL.JAVA 313
int source = srcAndRefPositions[i++];
int reference = srcAndRefPositions[i++];
int offset;
if(source >= 0)
{
offset = position - source;
if(offset < Short.MIN_VALUE || offset > Short.MAX_VALUE)
{
/*
* changes the opcode of the jump instruction, in order
* to be able to find it later (see resizeInstructions
* in MethodWriter). These temporary opcodes are similar
* to jump instruction opcodes, except that the 2 bytes
* offset is unsigned (and can therefore represent
* values from 0 to 65535, which is sufficient since
* the size of a method is limited to 65535 bytes).
*/
int opcode = data[reference - 1] & 0xFF;
if(opcode <= Opcodes.JSR)
{
// changes IFEQ ... JSR to opcodes 202 to 217
data[reference - 1] = (byte) (opcode + 49);
}
else
{
// changes IFNULL and IFNONNULL to opcodes 218
// and 219
data[reference - 1] = (byte) (opcode + 20);
}
needUpdate = true;
}
data[reference++] = (byte) (offset >>> 8);
data[reference] = (byte) offset;
}
else
{
offset = position + source + 1;
data[reference++] = (byte) (offset >>> 24);
data[reference++] = (byte) (offset >>> 16);
data[reference++] = (byte) (offset >>> 8);
data[reference] = (byte) offset;
}
}
return needUpdate;
}
/**
* Returns the first label of the series to which this label bel ongs.
* For an isolated label or for the first label in a series of
* successive labels, this method returns the label itself. F or other
314 CHAPTER 7. JVM/CLOJURE/ASM/
* labels it returns the first label of the series.
*
* @return the first label of the series to which this label bel ongs.
*/
Label getFirst(){
return frame == null ? this : frame.owner;
}
// ------------------------------------------------- ------------------
// Overriden Object methods
// ------------------------------------------------- ------------------
/**
* Returns a string representation of this label.
*
* @return a string representation of this label.
*/
public String toString(){
return "L" + System.identityHashCode(this);
}
}
———-
7.16 MethodAdapter.java
(MethodVisitor [317])
— MethodAdapter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* An empty {@link MethodVisitor} that delegates to another
* {@link MethodVisitor}. This class can be used as a super cla ss to
* quickly implement usefull method adapter classes, just by overriding
* the necessary methods.
*
* @author Eric Bruneton
*/
public class MethodAdapter implements MethodVisitor{
/**
* The {@link MethodVisitor} to which this adapter delegates calls.
*/
protected MethodVisitor mv;
/**
7.16. METHODADAPTER.JAVA 315
* Constructs a new {@link MethodAdapter} object.
*
* @param mv the code visitor to which this adapter must delega te calls.
*/
public MethodAdapter(final MethodVisitor mv){
this.mv = mv;
}
public AnnotationVisitor visitAnnotationDefault(){
return mv.visitAnnotationDefault();
}
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
return mv.visitAnnotation(desc, visible);
}
public AnnotationVisitor visitParameterAnnotation(
final int parameter,
final String desc,
final boolean visible){
return mv.visitParameterAnnotation(parameter, desc, vi sible);
}
public void visitAttribute(final Attribute attr){
mv.visitAttribute(attr);
}
public void visitCode(){
mv.visitCode();
}
public void visitFrame(
final int type,
final int nLocal,
final Object[] local,
final int nStack,
final Object[] stack){
mv.visitFrame(type, nLocal, local, nStack, stack);
}
public void visitInsn(final int opcode){
mv.visitInsn(opcode);
}
public void visitIntInsn(final int opcode, final int opera nd){
mv.visitIntInsn(opcode, operand);
}
316 CHAPTER 7. JVM/CLOJURE/ASM/
public void visitVarInsn(final int opcode, final int var){
mv.visitVarInsn(opcode, var);
}
public void visitTypeInsn(final int opcode, final String d esc){
mv.visitTypeInsn(opcode, desc);
}
public void visitFieldInsn(
final int opcode,
final String owner,
final String name,
final String desc){
mv.visitFieldInsn(opcode, owner, name, desc);
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
mv.visitMethodInsn(opcode, owner, name, desc);
}
public void visitJumpInsn(final int opcode, final Label la bel){
mv.visitJumpInsn(opcode, label);
}
public void visitLabel(final Label label){
mv.visitLabel(label);
}
public void visitLdcInsn(final Object cst){
mv.visitLdcInsn(cst);
}
public void visitIincInsn(final int var, final int increme nt){
mv.visitIincInsn(var, increment);
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label labels[]){
mv.visitTableSwitchInsn(min, max, dflt, labels);
}
public void visitLookupSwitchInsn(
final Label dflt,
7.17. METHODVISITOR.JAVA 317
final int keys[],
final Label labels[]){
mv.visitLookupSwitchInsn(dflt, keys, labels);
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
mv.visitMultiANewArrayInsn(desc, dims);
}
public void visitTryCatchBlock(
final Label start,
final Label end,
final Label handler,
final String type){
mv.visitTryCatchBlock(start, end, handler, type);
}
public void visitLocalVariable(
final String name,
final String desc,
final String signature,
final Label start,
final Label end,
final int index){
mv.visitLocalVariable(name, desc, signature, start, end , index);
}
public void visitLineNumber(final int line, final Label st art){
mv.visitLineNumber(line, start);
}
public void visitMaxs(final int maxStack, final int maxLoc als){
mv.visitMaxs(maxStack, maxLocals);
}
public void visitEnd(){
mv.visitEnd();
}
}
———-
7.17 MethodVisitor.java
— MethodVisitor.java —
\getchunk{France Telecom Copyright}
318 CHAPTER 7. JVM/CLOJURE/ASM/
package clojure.asm;
/**
* A visitor to visit a Java method. The methods of this interfa ce must
* be called in the following order:
* [ <tt>visitAnnotationDefault</tt> ] ( * <tt>visitAnnota tion</tt> |
* <tt>visitParameterAnnotation</tt> | * <tt>visitAttrib ute</tt> )*
* [ <tt>visitCode</tt> ( <tt>visitFrame</tt> |
* <tt>visit</tt><i>X</i>Insn</tt> | <tt>visitLabel</tt > |
* <tt>visitTryCatchBlock</tt> | * <tt>visitLocalVariabl e</tt> |
* <tt>visitLineNumber</tt>)* <tt>visitMaxs</tt> ]
* <tt>visitEnd</tt>. In addition, the <tt>visit</tt><i>X </i>Insn</tt>
* and <tt>visitLabel</tt> methods must be called in the sequ ential
* order of the bytecode instructions of the visited code,
* <tt>visitTryCatchBlock</tt> must be called <i>before</ i> the
* labels passed as arguments have been visited, and the
* <tt>visitLocalVariable</tt> and <tt>visitLineNumber< /tt> methods
* must be called <i>after</i> the labels passed as arguments have
* been visited.
*
* @author Eric Bruneton
*/
public interface MethodVisitor{
// ------------------------------------------------- -------------------
// Annotations and non standard attributes
// ------------------------------------------------- -------------------
/**
* Visits the default value of this annotation interface meth od.
*
* @return a visitor to the visit the actual default value of th is
* annotation interface method, or <tt>null</tt> if this
* visitor is not interested in visiting this default value.
* The ’name’ parameters passed to the methods of this
* annotation visitor are ignored. Moreover, exacly one visi t
* method must be called on this annotation visitor, followed
* by visitEnd.
*/
AnnotationVisitor visitAnnotationDefault();
/**
* Visits an annotation of this method.
*
* @param desc the class descriptor of the annotation class.
* @param visible <tt>true</tt> if the annotation is visible at runtime.
* @return a visitor to visit the annotation values, or <tt>nu ll</tt> if
* this visitor is not interested in visiting this annotation .
*/
AnnotationVisitor visitAnnotation(String desc, boolean visible);
7.17. METHODVISITOR.JAVA 319
/**
* Visits an annotation of a parameter this method.
*
* @param parameter the parameter index.
* @param desc the class descriptor of the annotation class.
* @param visible <tt>true</tt> if the annotation is visible at
* runtime.
* @return a visitor to visit the annotation values, or <tt>nu ll</tt>
* if this visitor is not interested in visiting this annotati on.
*/
AnnotationVisitor visitParameterAnnotation(
int parameter,
String desc,
boolean visible);
/**
* Visits a non standard attribute of this method.
*
* @param attr an attribute.
*/
void visitAttribute(Attribute attr);
/**
* Starts the visit of the method’s code, if any (i.e. non abstr act
* method).
*/
void visitCode();
/**
* Visits the current state of the local variables and operand stack
* elements. This method must(*) be called <i>just before</i > any
* instruction <b>i</b> that follows an unconditionnal bran ch
* instruction such as GOTO or THROW, that is the target of a jum p
* instruction, or that starts an exception handler block. Th e visited
* types must describe the values of the local variables and of the
* operand stack elements <i>just before</i> <b>i</b> is exe cuted.
* <br> <br> (*) this is mandatory only for classes whose versi on
* is greater than or equal to {@link Opcodes#V1_6 V1_6}. <br> <br>
* Packed frames are basically "deltas" from the state of the
* previous frame (very first frame is implicitly defined by t he
* method’s parameters and access flags): <ul> <li>
* {@link Opcodes#F_SAME} representing frame with exactly t he same
* locals as the previous frame and with the empty stack.</li>
* <li>{@link Opcodes#F_SAME1}
* representing frame with exactly the same locals as the prev ious
* frame and with single value on the stack (<code>nStack</co de> is 1
* and <code>stack[0]</code> contains value for the type of t he
* stack item).</li> <li>{@link Opcodes#F_APPEND} represe nting frame
* with current locals are the same as the locals in the previou s
320 CHAPTER 7. JVM/CLOJURE/ASM/
* frame, except that additional locals are defined
* (<code>nLocal</code> is 1, 2 or 3 and * <code>local</code> elements
* contains values representing added types).</li>
* <li>{@link Opcodes#F_CHOP} representing frame with curr ent locals
* are the same as the locals in the previous frame, except that the
* last 1-3 locals are absent and with the empty stack
* (<code>nLocals</code> is 1, 2 or 3). </li> <li>
* {@link Opcodes#F_FULL} representing complete frame
* data.</li> </li> </ul>
*
* @param type the type of this stack map frame. Must be
* {@link Opcodes#F_NEW} for expanded frames, or
* {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
* {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
* {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1}
* for compressed frames.
* @param nLocal the number of local variables in the visited f rame.
* @param local the local variable types in this frame. This ar ray must
* not be modified. Primitive types are represented by
* {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
* {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
* {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
* {@link Opcodes#UNINITIALIZED_THIS} (long and double are
* represented by a single element). Reference types are
* represented by String objects (representing internal
* names, or type descriptors for array types), and
* uninitialized types by Label objects (this label
* designates the NEW instruction that created this
* uninitialized value).
* @param nStack the number of operand stack elements in the vi sited
* frame.
* @param stack the operand stack types in this frame. This arr ay must
* not be modified. Its content has the same format as
* the "local" array.
*/
void visitFrame(
int type,
int nLocal,
Object[] local,
int nStack,
Object[] stack);
// ------------------------------------------------- -------------------
// Normal instructions
// ------------------------------------------------- -------------------
/**
* Visits a zero operand instruction.
*
* @param opcode the opcode of the instruction to be visited. T his
7.17. METHODVISITOR.JAVA 321
* opcode is either NOP, ACONST_NULL, ICONST_M1, ICONST_0,
* ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
* LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2,
* DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD,
* DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE,
* LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE,
* SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1,
* DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB,
* DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV,
* IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL,
* LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR,
* IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L,
* F2D, D2I, D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG,
* DCMPL, DCMPG, IRETURN, LRETURN, FRETURN, DRETURN,
* ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER,
* or MONITOREXIT.
*/
void visitInsn(int opcode);
/**
* Visits an instruction with a single int operand.
*
* @param opcode the opcode of the instruction to be visited. T his
* opcode is either BIPUSH, SIPUSH or NEWARRAY.
* @param operand the operand of the instruction to be visited .<br> When
* opcode is BIPUSH, operand value should be between
* Byte.MIN_VALUE and Byte.MAX_VALUE.<br> When opcode
* is SIPUSH, operand value should be between
* Short.MIN_VALUE and Short.MAX_VALUE.<br> When opcode
* is NEWARRAY, operand value should be one of
* {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
* {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
* {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
* {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
*/
void visitIntInsn(int opcode, int operand);
/**
* Visits a local variable instruction. A local variable inst ruction is
* an instruction that loads or stores the value of a local vari able.
*
* @param opcode the opcode of the local variable instruction to be
* visited. This opcode is either ILOAD, LLOAD, FLOAD,
* DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE
* or RET.
* @param var the operand of the instruction to be visited. Thi s
* operand is the index of a local variable.
*/
void visitVarInsn(int opcode, int var);
322 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Visits a type instruction. A type instruction is an instruc tion that
* takes a type descriptor as parameter.
*
* @param opcode the opcode of the type instruction to be visit ed.
* This opcode is either NEW, ANEWARRAY, CHECKCAST or
* INSTANCEOF.
* @param desc the operand of the instruction to be visited. Th is
* operand is must be a fully qualified class name in
* internal form, or the type descriptor of an array
* type (see {@link Type Type}).
*/
void visitTypeInsn(int opcode, String desc);
/**
* Visits a field instruction. A field instruction is an instr uction
* that loads or stores the value of a field of an object.
*
* @param opcode the opcode of the type instruction to be visit ed.
* This opcode is either GETSTATIC, PUTSTATIC, GETFIELD
* or PUTFIELD.
* @param owner the internal name of the field’s owner class (s ee {@link
* Type#getInternalName() getInternalName}).
* @param name the field’s name.
* @param desc the field’s descriptor (see {@link Type Type}) .
*/
void visitFieldInsn(int opcode, String owner, String name , String desc);
/**
* Visits a method instruction. A method instruction is an ins truction
* that invokes a method.
*
* @param opcode the opcode of the type instruction to be visit ed.
* This opcode is either INVOKEVIRTUAL, INVOKESPECIAL,
* INVOKESTATIC or INVOKEINTERFACE.
* @param owner the internal name of the method’s owner class ( see
* {@link Type#getInternalName() getInternalName}).
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type Type} ).
*/
void visitMethodInsn(int opcode, String owner, String nam e, String desc);
/**
* Visits a jump instruction. A jump instruction is an instruc tion that
* may jump to another instruction.
*
* @param opcode the opcode of the type instruction to be visit ed. This
* opcode is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE,
* IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
* IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or
7.17. METHODVISITOR.JAVA 323
* IFNONNULL.
* @param label the operand of the instruction to be visited. T his
* operand is a label that designates the instruction
* to which the jump instruction may jump.
*/
void visitJumpInsn(int opcode, Label label);
/**
* Visits a label. A label designates the instruction that wil l be
* visited just after it.
*
* @param label a {@link Label Label} object.
*/
void visitLabel(Label label);
// ------------------------------------------------- -------------------
// Special instructions
// ------------------------------------------------- -------------------
/**
* Visits a LDC instruction.
*
* @param cst the constant to be loaded on the stack. This param eter
* must be a non null {@link Integer}, a {@link Float},
* a {@link Long}, a {@link Double} a {@link String} (or
* a {@link Type} for <tt>.class</tt> constants, for classes
* whose version is 49.0 or more).
*/
void visitLdcInsn(Object cst);
/**
* Visits an IINC instruction.
*
* @param var index of the local variable to be incremented.
* @param increment amount to increment the local variable by .
*/
void visitIincInsn(int var, int increment);
/**
* Visits a TABLESWITCH instruction.
*
* @param min the minimum key value.
* @param max the maximum key value.
* @param dflt beginning of the default handler block.
* @param labels beginnings of the handler blocks. <tt>label s[i]</tt>
* is the beginning of the handler block for the
* <tt>min + i</tt> key.
*/
void visitTableSwitchInsn(int min, int max, Label dflt, La bel labels[]);
324 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Visits a LOOKUPSWITCH instruction.
*
* @param dflt beginning of the default handler block.
* @param keys the values of the keys.
* @param labels beginnings of the handler blocks. <tt>label s[i]</tt>
* is the beginning of the handler block for the
* <tt>keys[i]</tt> key.
*/
void visitLookupSwitchInsn(Label dflt, int keys[], Label labels[]);
/**
* Visits a MULTIANEWARRAY instruction.
*
* @param desc an array type descriptor (see {@link Type Type} ).
* @param dims number of dimensions of the array to allocate.
*/
void visitMultiANewArrayInsn(String desc, int dims);
// ------------------------------------------------- --------------
// Exceptions table entries, debug information, max stack a nd max
// locals
// ------------------------------------------------- --------------
/**
* Visits a try catch block.
*
* @param start beginning of the exception handler’s scope (i nclusive).
* @param end end of the exception handler’s scope (exclusive ).
* @param handler beginning of the exception handler’s code.
* @param type internal name of the type of exceptions handled by the
* handler, or <tt>null</tt> to catch any exceptions
* (for "finally" blocks).
* @throws IllegalArgumentException if one of the labels has already
* been visited by this visitor (by the
* {@link #visitLabel visitLabel} method).
*/
void visitTryCatchBlock(Label start,
Label end,
Label handler,
String type);
/**
* Visits a local variable declaration.
*
* @param name the name of a local variable.
* @param desc the type descriptor of this local variable.
* @param signature the type signature of this local variable . May be
* <tt>null</tt> if the local variable type does not
* use generic types.
7.17. METHODVISITOR.JAVA 325
* @param start the first instruction corresponding to the sc ope of
* this local variable (inclusive).
* @param end the last instruction corresponding to the scope of
* this local variable (exclusive).
* @param index the local variable’s index.
* @throws IllegalArgumentException if one of the labels has not already
* been visited by this visitor (by the
* {@link #visitLabel visitLabel} method).
*/
void visitLocalVariable(
String name,
String desc,
String signature,
Label start,
Label end,
int index);
/**
* Visits a line number declaration.
*
* @param line a line number. This number refers to the source f ile
* from which the class was compiled.
* @param start the first instruction corresponding to this l ine number.
* @throws IllegalArgumentException if <tt>start</tt> has not already
* been visited by this visitor (by the
* {@link #visitLabel visitLabel} method).
*/
void visitLineNumber(int line, Label start);
/**
* Visits the maximum stack size and the maximum number of loca l
* variables of the method.
*
* @param maxStack maximum stack size of the method.
* @param maxLocals maximum number of local variables for the method.
*/
void visitMaxs(int maxStack, int maxLocals);
/**
* Visits the end of the method. This method, which is the last o ne to
* be called, is used to inform the visitor that all the annotat ions and
* attributes of the method have been visited.
*/
void visitEnd();
}
———-
326 CHAPTER 7. JVM/CLOJURE/ASM/
7.18 MethodWriter.java
(MethodVisitor [317])
— MethodWriter.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* A {@link MethodVisitor} that generates methods in bytecod e form.
* Each visit method of this class appends the bytecode corres ponding
* to the visited instruction to a byte vector, in the order the se
* methods are called.
*
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
class MethodWriter implements MethodVisitor{
/**
* Pseudo access flag used to denote constructors.
*/
final static int ACC_CONSTRUCTOR = 262144;
/**
* Frame has exactly the same locals as the previous stack map f rame
* and number of stack items is zero.
*/
final static int SAME_FRAME = 0; // to 63 (0-3f)
/**
* Frame has exactly the same locals as the previous stack map f rame
* and number of stack items is 1
*/
final static int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // t o 127 (40-7f)
/**
* Reserved for future use
*/
final static int RESERVED = 128;
/**
* Frame has exactly the same locals as the previous stack map f rame
* and number of stack items is 1. Offset is bigger then 63;
*/
final static int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTEND ED = 247; // f7
/**
* Frame where current locals are the same as the locals in the p revious
7.18. METHODWRITER.JAVA 327
* frame, except that the k last locals are absent. The value of k is
* given by the formula 251-frame_type.
*/
final static int CHOP_FRAME = 248; // to 250 (f8-fA)
/**
* Frame has exactly the same locals as the previous stack map f rame
* and number of stack items is zero. Offset is bigger then 63;
*/
final static int SAME_FRAME_EXTENDED = 251; // fb
/**
* Frame where current locals are the same as the locals in the
* previous frame, except that k additional locals are define d.
* The value of k is given by the formula frame_type-251.
*/
final static int APPEND_FRAME = 252; // to 254 // fc-fe
/**
* Full frame
*/
final static int FULL_FRAME = 255; // ff
/**
* Indicates that the stack map frames must be recomputed from scratch.
* In this case the maximum stack size and number of local varia bles
* is also recomputed from scratch.
*
* @see #compute
*/
private final static int FRAMES = 0;
/**
* Indicates that the maximum stack size and number of local va riables
* must be automatically computed.
*
* @see #compute
*/
private final static int MAXS = 1;
/**
* Indicates that nothing must be automatically computed.
*
* @see #compute
*/
private final static int NOTHING = 2;
/**
* Next method writer (see {@link ClassWriter#firstMethod f irstMethod}).
*/
328 CHAPTER 7. JVM/CLOJURE/ASM/
MethodWriter next;
/**
* The class writer to which this method must be added.
*/
ClassWriter cw;
/**
* Access flags of this method.
*/
private int access;
/**
* The index of the constant pool item that contains the name of this
* method.
*/
private int name;
/**
* The index of the constant pool item that contains the descri ptor
* of this method.
*/
private int desc;
/**
* The descriptor of this method.
*/
private String descriptor;
/**
* The signature of this method.
*/
String signature;
/**
* If not zero, indicates that the code of this method must be co pied
* from the ClassReader associated to this writer in
* <code>cw.cr</code>. More precisely, this field gives the index of
* the first byte to copied from <code>cw.cr.b</code>.
*/
int classReaderOffset;
/**
* If not zero, indicates that the code of this method must be
* copied from the ClassReader associated to this writer in
* <code>cw.cr</code>. More precisely, this field gives the number
* of bytes to copied from <code>cw.cr.b</code>.
*/
int classReaderLength;
7.18. METHODWRITER.JAVA 329
/**
* Number of exceptions that can be thrown by this method.
*/
int exceptionCount;
/**
* The exceptions that can be thrown by this method. More preci sely,
* this array contains the indexes of the constant pool items t hat
* contain the internal names of these exception classes.
*/
int[] exceptions;
/**
* The annotation default attribute of this method. May be
* <tt>null</tt>.
*/
private ByteVector annd;
/**
* The runtime visible annotations of this method. May be
* <tt>null</tt>.
*/
private AnnotationWriter anns;
/**
* The runtime invisible annotations of this method. May be
* <tt>null</tt>.
*/
private AnnotationWriter ianns;
/**
* The runtime visible parameter annotations of this method. May be
* <tt>null</tt>.
*/
private AnnotationWriter[] panns;
/**
* The runtime invisible parameter annotations of this metho d. May be
* <tt>null</tt>.
*/
private AnnotationWriter[] ipanns;
/**
* The non standard attributes of the method.
*/
private Attribute attrs;
/**
* The bytecode of this method.
*/
330 CHAPTER 7. JVM/CLOJURE/ASM/
private ByteVector code = new ByteVector();
/**
* Maximum stack size of this method.
*/
private int maxStack;
/**
* Maximum number of local variables for this method.
*/
private int maxLocals;
/**
* Number of stack map frames in the StackMapTable attribute.
*/
private int frameCount;
/**
* The StackMapTable attribute.
*/
private ByteVector stackMap;
/**
* The offset of the last frame that was written in the StackMap Table
* attribute.
*/
private int previousFrameOffset;
/**
* The last frame that was written in the StackMapTable attrib ute.
*
* @see #frame
*/
private int[] previousFrame;
/**
* Index of the next element to be added in {@link #frame}.
*/
private int frameIndex;
/**
* The current stack map frame. The first element contains the offset
* of the instruction to which the frame corresponds, the seco nd
* element is the number of locals and the third one is the numbe r
* of stack elements. The local variables start at index 3 and a re
* followed by the operand stack values. In summary frame[0] = offset,
* frame[1] = nLocal, frame[2] = nStack, frame[3] = nLocal. Al l types
* are encoded as integers, with the same format as the one used in
* {@link Label}, but limited to BASE types.
*/
7.18. METHODWRITER.JAVA 331
private int[] frame;
/**
* Number of elements in the exception handler list.
*/
private int handlerCount;
/**
* The first element in the exception handler list.
*/
private Handler firstHandler;
/**
* The last element in the exception handler list.
*/
private Handler lastHandler;
/**
* Number of entries in the LocalVariableTable attribute.
*/
private int localVarCount;
/**
* The LocalVariableTable attribute.
*/
private ByteVector localVar;
/**
* Number of entries in the LocalVariableTypeTable attribut e.
*/
private int localVarTypeCount;
/**
* The LocalVariableTypeTable attribute.
*/
private ByteVector localVarType;
/**
* Number of entries in the LineNumberTable attribute.
*/
private int lineNumberCount;
/**
* The LineNumberTable attribute.
*/
private ByteVector lineNumber;
/**
* The non standard attributes of the method’s code.
*/
332 CHAPTER 7. JVM/CLOJURE/ASM/
private Attribute cattrs;
/**
* Indicates if some jump instructions are too small and need t o be
* resized.
*/
private boolean resize;
/**
* Indicates if the instructions contain at least one JSR inst ruction.
*/
private boolean jsr;
// ------------------------------------------------- ------------------
/*
* Fields for the control flow graph analysis algorithm (used to
* compute the maximum stack size). A control flow graph conta ins
* one node per "basic block", and one edge per "jump" from one b asic
* block to another. Each node (i.e., each basic block) is repr esented
* by the Label object that corresponds to the first instructi on of
* this basic block. Each node also stores the list of its succe ssors
* in the graph, as a linked list of Edge objects.
*/
/**
* Indicates what must be automatically computed.
*
* @see FRAMES
* @see MAXS
* @see NOTHING
*/
private int compute;
/**
* A list of labels. This list is the list of basic blocks in the
* method, i.e. a list of Label objects linked to each other by t heir
* {@link Label#successor} field, in the order they are visit ed by
* {@link visitLabel}, and starting with the first basic bloc k.
*/
private Label labels;
/**
* The previous basic block.
*/
private Label previousBlock;
/**
* The current basic block.
*/
7.18. METHODWRITER.JAVA 333
private Label currentBlock;
/**
* The (relative) stack size after the last visited instructi on. This
* size is relative to the beginning of the current basic block , i.e.,
* the true stack size after the last visited instruction is eq ual to
* the {@link Label#inputStackTop beginStackSize} of the cu rrent basic
* block plus <tt>stackSize</tt>.
*/
private int stackSize;
/**
* The (relative) maximum stack size after the last visited in struction.
* This size is relative to the beginning of the current basic b lock,
* i.e., the true maximum stack size after the last visited ins truction
* is equal to the {@link Label#inputStackTop beginStackSiz e} of the
* current basic block plus <tt>stackSize</tt>.
*/
private int maxStackSize;
// ------------------------------------------------- ------------------
// Constructor
// ------------------------------------------------- ------------------
/**
* Constructs a new {@link MethodWriter}.
*
* @param cw the class writer in which the method must be
* added.
* @param access the method’s access flags (see {@link Opcode s}).
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type}).
* @param signature the method’s signature. May be <tt>null< /tt>.
* @param exceptions the internal names of the method’s excep tions.
* May be <tt>null</tt>.
* @param computeMaxs <tt>true</tt> if the maximum stack siz e and
* number of local variables must be automatically
* computed.
* @param computeFrames <tt>true</tt> if the stack map table s must be
* recomputed from scratch.
*/
MethodWriter(
final ClassWriter cw,
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions,
final boolean computeMaxs,
final boolean computeFrames){
334 CHAPTER 7. JVM/CLOJURE/ASM/
if(cw.firstMethod == null)
{
cw.firstMethod = this;
}
else
{
cw.lastMethod.next = this;
}
cw.lastMethod = this;
this.cw = cw;
this.access = access;
this.name = cw.newUTF8(name);
this.desc = cw.newUTF8(desc);
this.descriptor = desc;
this.signature = signature;
if(exceptions != null && exceptions.length > 0)
{
exceptionCount = exceptions.length;
this.exceptions = new int[exceptionCount];
for(int i = 0; i < exceptionCount; ++i)
{
this.exceptions[i] = cw.newClass(exceptions[i]);
}
}
this.compute =
computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);
if(computeMaxs || computeFrames)
{
if(computeFrames && name.equals("<init>"))
{
this.access |= ACC_CONSTRUCTOR;
}
// updates maxLocals
int size = getArgumentsAndReturnSizes(descriptor) >> 2;
if((access & Opcodes.ACC_STATIC) != 0)
{
--size;
}
maxLocals = size;
// creates and visits the label for the first basic block
labels = new Label();
labels.status |= Label.PUSHED;
visitLabel(labels);
}
}
// ------------------------------------------------- ------------------
// Implementation of the MethodVisitor interface
// ------------------------------------------------- ------------------
7.18. METHODWRITER.JAVA 335
public AnnotationVisitor visitAnnotationDefault(){
annd = new ByteVector();
return new AnnotationWriter(cw, false, annd, null, 0);
}
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
ByteVector bv = new ByteVector();
// write type, and reserve space for values count
bv.putShort(cw.newUTF8(desc)).putShort(0);
AnnotationWriter aw = new AnnotationWriter(cw, true, bv, b v, 2);
if(visible)
{
aw.next = anns;
anns = aw;
}
else
{
aw.next = ianns;
ianns = aw;
}
return aw;
}
public AnnotationVisitor visitParameterAnnotation(
final int parameter,
final String desc,
final boolean visible){
ByteVector bv = new ByteVector();
// write type, and reserve space for values count
bv.putShort(cw.newUTF8(desc)).putShort(0);
AnnotationWriter aw = new AnnotationWriter(cw, true, bv, b v, 2);
if(visible)
{
if(panns == null)
{
panns =
new AnnotationWriter[
Type.getArgumentTypes(descriptor).length];
}
aw.next = panns[parameter];
panns[parameter] = aw;
}
else
{
if(ipanns == null)
{
ipanns =
new AnnotationWriter[
336 CHAPTER 7. JVM/CLOJURE/ASM/
Type.getArgumentTypes(descriptor).length];
}
aw.next = ipanns[parameter];
ipanns[parameter] = aw;
}
return aw;
}
public void visitAttribute(final Attribute attr){
if(attr.isCodeAttribute())
{
attr.next = cattrs;
cattrs = attr;
}
else
{
attr.next = attrs;
attrs = attr;
}
}
public void visitCode(){
}
public void visitFrame(
final int type,
final int nLocal,
final Object[] local,
final int nStack,
final Object[] stack){
if(compute == FRAMES)
{
return;
}
if(type == Opcodes.F_NEW)
{
startFrame(code.length, nLocal, nStack);
for(int i = 0; i < nLocal; ++i)
{
if(local[i] instanceof String)
{
frame[frameIndex++] = Frame.OBJECT
| cw.addType((String) local[i]);
}
else if(local[i] instanceof Integer)
{
frame[frameIndex++] = ((Integer) local[i]).intValue();
}
else
7.18. METHODWRITER.JAVA 337
{
frame[frameIndex++] =
Frame.UNINITIALIZED
| cw.addUninitializedType("",
((Label) local[i]).position);
}
}
for(int i = 0; i < nStack; ++i)
{
if(stack[i] instanceof String)
{
frame[frameIndex++] = Frame.OBJECT
| cw.addType((String) stack[i]);
}
else if(stack[i] instanceof Integer)
{
frame[frameIndex++] = ((Integer) stack[i]).intValue();
}
else
{
frame[frameIndex++] =
Frame.UNINITIALIZED
| cw.addUninitializedType("",
((Label) stack[i]).position);
}
}
endFrame();
}
else
{
int delta;
if(stackMap == null)
{
stackMap = new ByteVector();
delta = code.length;
}
else
{
delta = code.length - previousFrameOffset - 1;
}
switch(type)
{
case Opcodes.F_FULL:
stackMap.putByte(FULL_FRAME)
.putShort(delta)
.putShort(nLocal);
for(int i = 0; i < nLocal; ++i)
{
writeFrameType(local[i]);
338 CHAPTER 7. JVM/CLOJURE/ASM/
}
stackMap.putShort(nStack);
for(int i = 0; i < nStack; ++i)
{
writeFrameType(stack[i]);
}
break;
case Opcodes.F_APPEND:
stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)
.putShort(delta);
for(int i = 0; i < nLocal; ++i)
{
writeFrameType(local[i]);
}
break;
case Opcodes.F_CHOP:
stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)
.putShort(delta);
break;
case Opcodes.F_SAME:
if(delta < 64)
{
stackMap.putByte(delta);
}
else
{
stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delt a);
}
break;
case Opcodes.F_SAME1:
if(delta < 64)
{
stackMap.putByte(
SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
}
else
{
stackMap.putByte(
SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
.putShort(delta);
}
writeFrameType(stack[0]);
break;
}
previousFrameOffset = code.length;
++frameCount;
}
}
7.18. METHODWRITER.JAVA 339
public void visitInsn(final int opcode){
// adds the instruction to the bytecode of the method
code.putByte(opcode);
// update currentBlock
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, 0, null, null);
}
else
{
// updates current and max stack sizes
int size = stackSize + Frame.SIZE[opcode];
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
// if opcode == ATHROW or xRETURN, ends current
// block (no successor)
if((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN )
|| opcode == Opcodes.ATHROW)
{
noSuccessor();
}
}
}
public void visitIntInsn(final int opcode, final int opera nd){
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, operand, null, null );
}
else if(opcode != Opcodes.NEWARRAY)
{
// updates current and max stack sizes only for NEWARRAY
// (stack size variation = 0 for BIPUSH or SIPUSH)
int size = stackSize + 1;
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
340 CHAPTER 7. JVM/CLOJURE/ASM/
}
// adds the instruction to the bytecode of the method
if(opcode == Opcodes.SIPUSH)
{
code.put12(opcode, operand);
}
else
{ // BIPUSH or NEWARRAY
code.put11(opcode, operand);
}
}
public void visitVarInsn(final int opcode, final int var){
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, var, null, null);
}
else
{
// updates current and max stack sizes
if(opcode == Opcodes.RET)
{
// no stack change, but end of current block
// (no successor)
currentBlock.status |= Label.RET;
// save ’stackSize’ here for future use
// (see {@link #findSubroutineSuccessors})
currentBlock.inputStackTop = stackSize;
noSuccessor();
}
else
{ // xLOAD or xSTORE
int size = stackSize + Frame.SIZE[opcode];
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
}
}
if(compute != NOTHING)
{
// updates max locals
int n;
if(opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD
|| opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)
7.18. METHODWRITER.JAVA 341
{
n = var + 2;
}
else
{
n = var + 1;
}
if(n > maxLocals)
{
maxLocals = n;
}
}
// adds the instruction to the bytecode of the method
if(var < 4 && opcode != Opcodes.RET)
{
int opt;
if(opcode < Opcodes.ISTORE)
{
/* ILOAD_0 */
opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;
}
else
{
/* ISTORE_0 */
opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;
}
code.putByte(opt);
}
else if(var >= 256)
{
code.putByte(196 /* WIDE */).put12(opcode, var);
}
else
{
code.put11(opcode, var);
}
if(opcode >= Opcodes.ISTORE && compute == FRAMES && handler Count > 0)
{
visitLabel(new Label());
}
}
public void visitTypeInsn(final int opcode, final String d esc){
Item i = cw.newClassItem(desc);
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, code.length, cw, i) ;
342 CHAPTER 7. JVM/CLOJURE/ASM/
}
else if(opcode == Opcodes.NEW)
{
// updates current and max stack sizes only if opcode == NEW
// (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
int size = stackSize + 1;
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
}
// adds the instruction to the bytecode of the method
code.put12(opcode, i.index);
}
public void visitFieldInsn(
final int opcode,
final String owner,
final String name,
final String desc){
Item i = cw.newFieldItem(owner, name, desc);
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, 0, cw, i);
}
else
{
int size;
// computes the stack size variation
char c = desc.charAt(0);
switch(opcode)
{
case Opcodes.GETSTATIC:
size = stackSize + (c == ’D’ || c == ’J’ ? 2 : 1);
break;
case Opcodes.PUTSTATIC:
size = stackSize + (c == ’D’ || c == ’J’ ? -2 : -1);
break;
case Opcodes.GETFIELD:
size = stackSize + (c == ’D’ || c == ’J’ ? 1 : 0);
break;
// case Constants.PUTFIELD:
default:
size = stackSize + (c == ’D’ || c == ’J’ ? -3 : -2);
break;
7.18. METHODWRITER.JAVA 343
}
// updates current and max stack sizes
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
}
// adds the instruction to the bytecode of the method
code.put12(opcode, i.index);
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
boolean itf = opcode == Opcodes.INVOKEINTERFACE;
Item i = cw.newMethodItem(owner, name, desc, itf);
int argSize = i.intVal;
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, 0, cw, i);
}
else
{
/*
* computes the stack size variation. In order not to
* recompute several times this variation for the same
* Item, we use the intVal field of this item to store
* this variation, once it has been computed. More
* precisely this intVal field stores the sizes of the
* arguments and of the return value corresponding to desc.
*/
if(argSize == 0)
{
// the above sizes have not been computed yet,
// so we compute them...
argSize = getArgumentsAndReturnSizes(desc);
// ... and we save them in order
// not to recompute them in the future
i.intVal = argSize;
}
int size;
if(opcode == Opcodes.INVOKESTATIC)
{
344 CHAPTER 7. JVM/CLOJURE/ASM/
size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;
}
else
{
size = stackSize - (argSize >> 2) + (argSize & 0x03);
}
// updates current and max stack sizes
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
}
// adds the instruction to the bytecode of the method
if(itf)
{
if(argSize == 0)
{
argSize = getArgumentsAndReturnSizes(desc);
i.intVal = argSize;
}
code.put12(Opcodes.INVOKEINTERFACE, i.index)
.put11(argSize >> 2, 0);
}
else
{
code.put12(opcode, i.index);
}
}
public void visitJumpInsn(final int opcode, final Label la bel){
Label nextInsn = null;
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(opcode, 0, null, null);
// ’label’ is the target of a jump instruction
label.getFirst().status |= Label.TARGET;
// adds ’label’ as a successor of this basic block
addSuccessor(Edge.NORMAL, label);
if(opcode != Opcodes.GOTO)
{
// creates a Label for the next basic block
nextInsn = new Label();
}
}
else
7.18. METHODWRITER.JAVA 345
{
if(opcode == Opcodes.JSR)
{
jsr = true;
currentBlock.status |= Label.JSR;
addSuccessor(stackSize + 1, label);
// creates a Label for the next basic block
nextInsn = new Label();
/*
* note that, by construction in this method, a JSR block
* has at least two successors in the control flow graph:
* the first one leads the next instruction after the
* JSR, while the second one leads to the JSR target.
*/
}
else
{
// updates current stack size (max stack size unchanged
// because stack size variation always negative in this
// case)
stackSize += Frame.SIZE[opcode];
addSuccessor(stackSize, label);
}
}
}
// adds the instruction to the bytecode of the method
if((label.status & Label.RESOLVED) != 0
&& label.position - code.length < Short.MIN_VALUE)
{
/*
* case of a backward jump with an offset < -32768. In this case
* we automatically replace GOTO with GOTO_W, JSR with JSR_W
* and IFxxx <l> with IFNOTxxx <l’> GOTO_W <l>, where IFNOTxxx
* is the "opposite" opcode of IFxxx (i.e., IFNE for IFEQ) and
* where <l’> designates the instruction just after the GOTO_ W.
*/
if(opcode == Opcodes.GOTO)
{
code.putByte(200); // GOTO_W
}
else if(opcode == Opcodes.JSR)
{
code.putByte(201); // JSR_W
}
else
{
// if the IF instruction is transformed into IFNOT GOTO_W the
// next instruction becomes the target of the IFNOT
// instruction
if(nextInsn != null)
346 CHAPTER 7. JVM/CLOJURE/ASM/
{
nextInsn.status |= Label.TARGET;
}
code.putByte(opcode <= 166
? ((opcode + 1) ^ 1) - 1
: opcode ^ 1);
code.putShort(8); // jump offset
code.putByte(200); // GOTO_W
}
label.put(this, code, code.length - 1, true);
}
else
{
/*
* case of a backward jump with an offset >= -32768, or of a
* forward jump with, of course, an unknown offset. In these
* cases we store the offset in 2 bytes (which will be
* increased in resizeInstructions, if needed).
*/
code.putByte(opcode);
label.put(this, code, code.length - 1, false);
}
if(currentBlock != null)
{
if(nextInsn != null)
{
// if the jump instruction is not a GOTO, the next
// instruction is also a successor of this instruction.
// Calling visitLabel adds the label of this next
// instruction as a successor of the current block,
// and starts a new basic block
visitLabel(nextInsn);
}
if(opcode == Opcodes.GOTO)
{
noSuccessor();
}
}
}
public void visitLabel(final Label label){
// resolves previous forward references to label, if any
resize |= label.resolve(this, code.length, code.data);
// updates currentBlock
if((label.status & Label.DEBUG) != 0)
{
return;
}
if(compute == FRAMES)
{
7.18. METHODWRITER.JAVA 347
if(currentBlock != null)
{
if(label.position == currentBlock.position)
{
// successive labels, do not start a new basic block
currentBlock.status |= (label.status & Label.TARGET);
label.frame = currentBlock.frame;
return;
}
// ends current block (with one new successor)
addSuccessor(Edge.NORMAL, label);
}
// begins a new current block
currentBlock = label;
if(label.frame == null)
{
label.frame = new Frame();
label.frame.owner = label;
}
// updates the basic block list
if(previousBlock != null)
{
if(label.position == previousBlock.position)
{
previousBlock.status |= (label.status & Label.TARGET);
label.frame = previousBlock.frame;
currentBlock = previousBlock;
return;
}
previousBlock.successor = label;
}
previousBlock = label;
}
else if(compute == MAXS)
{
if(currentBlock != null)
{
// ends current block (with one new successor)
currentBlock.outputStackMax = maxStackSize;
addSuccessor(stackSize, label);
}
// begins a new current block
currentBlock = label;
// resets the relative current and max stack sizes
stackSize = 0;
maxStackSize = 0;
// updates the basic block list
if(previousBlock != null)
{
previousBlock.successor = label;
348 CHAPTER 7. JVM/CLOJURE/ASM/
}
previousBlock = label;
}
}
public void visitLdcInsn(final Object cst){
Item i = cw.newConstItem(cst);
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);
}
else
{
int size;
// computes the stack size variation
if(i.type == ClassWriter.LONG ||
i.type == ClassWriter.DOUBLE)
{
size = stackSize + 2;
}
else
{
size = stackSize + 1;
}
// updates current and max stack sizes
if(size > maxStackSize)
{
maxStackSize = size;
}
stackSize = size;
}
}
// adds the instruction to the bytecode of the method
int index = i.index;
if(i.type == ClassWriter.LONG || i.type == ClassWriter.DO UBLE)
{
code.put12(20 /* LDC2_W */, index);
}
else if(index >= 256)
{
code.put12(19 /* LDC_W */, index);
}
else
{
code.put11(Opcodes.LDC, index);
}
}
7.18. METHODWRITER.JAVA 349
public void visitIincInsn(final int var, final int increme nt){
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame.execute(Opcodes.IINC, var, null, nu ll);
}
}
if(compute != NOTHING)
{
// updates max locals
int n = var + 1;
if(n > maxLocals)
{
maxLocals = n;
}
}
// adds the instruction to the bytecode of the method
if((var > 255) || (increment > 127) || (increment < -128))
{
code.putByte(196 /* WIDE */)
.put12(Opcodes.IINC, var)
.putShort(increment);
}
else
{
code.putByte(Opcodes.IINC).put11(var, increment);
}
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label labels[]){
// adds the instruction to the bytecode of the method
int source = code.length;
code.putByte(Opcodes.TABLESWITCH);
code.length += (4 - code.length % 4) % 4;
dflt.put(this, code, source, true);
code.putInt(min).putInt(max);
for(int i = 0; i < labels.length; ++i)
{
labels[i].put(this, code, source, true);
}
// updates currentBlock
visitSwitchInsn(dflt, labels);
}
350 CHAPTER 7. JVM/CLOJURE/ASM/
public void visitLookupSwitchInsn(
final Label dflt,
final int keys[],
final Label labels[]){
// adds the instruction to the bytecode of the method
int source = code.length;
code.putByte(Opcodes.LOOKUPSWITCH);
code.length += (4 - code.length % 4) % 4;
dflt.put(this, code, source, true);
code.putInt(labels.length);
for(int i = 0; i < labels.length; ++i)
{
code.putInt(keys[i]);
labels[i].put(this, code, source, true);
}
// updates currentBlock
visitSwitchInsn(dflt, labels);
}
private void visitSwitchInsn(final Label dflt, final Labe l[] labels){
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame
.execute(Opcodes.LOOKUPSWITCH, 0, null, null);
// adds current block successors
addSuccessor(Edge.NORMAL, dflt);
dflt.getFirst().status |= Label.TARGET;
for(int i = 0; i < labels.length; ++i)
{
addSuccessor(Edge.NORMAL, labels[i]);
labels[i].getFirst().status |= Label.TARGET;
}
}
else
{
// updates current stack size (max stack size unchanged)
--stackSize;
// adds current block successors
addSuccessor(stackSize, dflt);
for(int i = 0; i < labels.length; ++i)
{
addSuccessor(stackSize, labels[i]);
}
}
// ends current block
noSuccessor();
}
7.18. METHODWRITER.JAVA 351
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
Item i = cw.newClassItem(desc);
// Label currentBlock = this.currentBlock;
if(currentBlock != null)
{
if(compute == FRAMES)
{
currentBlock.frame
.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);
}
else
{
// updates current stack size (max stack size unchanged
// because stack size variation always negative or null)
stackSize += 1 - dims;
}
}
// adds the instruction to the bytecode of the method
code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte( dims);
}
public void visitTryCatchBlock(
final Label start,
final Label end,
final Label handler,
final String type){
++handlerCount;
Handler h = new Handler();
h.start = start;
h.end = end;
h.handler = handler;
h.desc = type;
h.type = type != null ? cw.newClass(type) : 0;
if(lastHandler == null)
{
firstHandler = h;
}
else
{
lastHandler.next = h;
}
lastHandler = h;
}
public void visitLocalVariable(
final String name,
final String desc,
final String signature,
352 CHAPTER 7. JVM/CLOJURE/ASM/
final Label start,
final Label end,
final int index){
if(signature != null)
{
if(localVarType == null)
{
localVarType = new ByteVector();
}
++localVarTypeCount;
localVarType.putShort(start.position)
.putShort(end.position - start.position)
.putShort(cw.newUTF8(name))
.putShort(cw.newUTF8(signature))
.putShort(index);
}
if(localVar == null)
{
localVar = new ByteVector();
}
++localVarCount;
localVar.putShort(start.position)
.putShort(end.position - start.position)
.putShort(cw.newUTF8(name))
.putShort(cw.newUTF8(desc))
.putShort(index);
if(compute != NOTHING)
{
// updates max locals
char c = desc.charAt(0);
int n = index + (c == ’J’ || c == ’D’ ? 2 : 1);
if(n > maxLocals)
{
maxLocals = n;
}
}
}
public void visitLineNumber(final int line, final Label st art){
if(lineNumber == null)
{
lineNumber = new ByteVector();
}
++lineNumberCount;
lineNumber.putShort(start.position);
lineNumber.putShort(line);
}
public void visitMaxs(final int maxStack, final int maxLoc als){
if(compute == FRAMES)
7.18. METHODWRITER.JAVA 353
{
// completes the control flow graph with exception handler b locks
Handler handler = firstHandler;
while(handler != null)
{
Label l = handler.start.getFirst();
Label h = handler.handler.getFirst();
Label e = handler.end.getFirst();
// computes the kind of the edges to ’h’
String t = handler.desc == null
? "java/lang/Throwable"
: handler.desc;
int kind = Frame.OBJECT | cw.addType(t);
// h is an exception handler
h.status |= Label.TARGET;
// adds ’h’ as a successor of labels between ’start’
// and ’end’
while(l != e)
{
// creates an edge to ’h’
Edge b = new Edge();
b.info = kind;
b.successor = h;
// adds it to the successors of ’l’
b.next = l.successors;
l.successors = b;
// goes to the next label
l = l.successor;
}
handler = handler.next;
}
// creates and visits the first (implicit) frame
Frame f = labels.frame;
Type[] args = Type.getArgumentTypes(descriptor);
f.initInputFrame(cw, access, args, this.maxLocals);
visitFrame(f);
/*
* fix point algorithm: mark the first basic block as ’changed ’
* (i.e. put it in the ’changed’ list) and, while there are
* changed basic blocks, choose one, mark it as unchanged,
* and update its successors (which can be changed in the
* process).
*/
int max = 0;
Label changed = labels;
while(changed != null)
{
// removes a basic block from the list of changed basic
354 CHAPTER 7. JVM/CLOJURE/ASM/
// blocks
Label l = changed;
changed = changed.next;
l.next = null;
f = l.frame;
// a reacheable jump target must be stored in the stack map
if((l.status & Label.TARGET) != 0)
{
l.status |= Label.STORE;
}
// all visited labels are reacheable, by definition
l.status |= Label.REACHABLE;
// updates the (absolute) maximum stack size
int blockMax = f.inputStack.length + l.outputStackMax;
if(blockMax > max)
{
max = blockMax;
}
// updates the successors of the current basic block
Edge e = l.successors;
while(e != null)
{
Label n = e.successor.getFirst();
boolean change = f.merge(cw, n.frame, e.info);
if(change && n.next == null)
{
// if n has changed and is not already in the
// ’changed’ list, adds it to this list
n.next = changed;
changed = n;
}
e = e.next;
}
}
this.maxStack = max;
// visits all the frames that must be stored in the stack map
Label l = labels;
while(l != null)
{
f = l.frame;
if((l.status & Label.STORE) != 0)
{
visitFrame(f);
}
if((l.status & Label.REACHABLE) == 0)
{
// finds start and end of dead basic block
Label k = l.successor;
int start = l.position;
7.18. METHODWRITER.JAVA 355
int end = (k == null ? code.length : k.position) - 1;
// if non empty basic block
if(end >= start)
{
// replaces instructions with NOP ... NOP ATHROW
for(int i = start; i < end; ++i)
{
code.data[i] = Opcodes.NOP;
}
code.data[end] = (byte) Opcodes.ATHROW;
// emits a frame for this unreachable block
startFrame(start, 0, 1);
frame[frameIndex++] =
Frame.OBJECT
| cw.addType("java/lang/Throwable");
endFrame();
}
}
l = l.successor;
}
}
else if(compute == MAXS)
{
// completes the control flow graph with exception handler b locks
Handler handler = firstHandler;
while(handler != null)
{
Label l = handler.start;
Label h = handler.handler;
Label e = handler.end;
// adds ’h’ as a successor of labels between ’start’
// and ’end’
while(l != e)
{
// creates an edge to ’h’
Edge b = new Edge();
b.info = Edge.EXCEPTION;
b.successor = h;
// adds it to the successors of ’l’
if((l.status & Label.JSR) != 0)
{
// if l is a JSR block, adds b after the first two
// edges to preserve the hypothesis about JSR block
// successors order (see {@link #visitJumpInsn})
b.next = l.successors.next.next;
l.successors.next.next = b;
}
else
{
b.next = l.successors;
356 CHAPTER 7. JVM/CLOJURE/ASM/
l.successors = b;
}
// goes to the next label
l = l.successor;
}
handler = handler.next;
}
if(jsr)
{
// completes the control flow graph with the RET successors
/*
* first step: finds the subroutines. This step determines,
* for each basic block, to which subroutine(s) it belongs,
* and stores this set as a bit set in the
* {@link Label#status} field. Subroutines are numbered
* with powers of two, from 0x1000 to 0x80000000 (so there
* must be at most 20 subroutines in a method).
*/
// finds the basic blocks that belong to the "main"
// subroutine
int id = 0x1000;
findSubroutine(labels, id);
// finds the basic blocks that belong to the real subroutines
Label l = labels;
while(l != null)
{
if((l.status & Label.JSR) != 0)
{
// the subroutine is defined by l’s TARGET, not by l
Label subroutine = l.successors.next.successor;
// if this subroutine does not have an id yet...
if((subroutine.status & ~0xFFF) == 0)
{
// ...assigns it a new id and finds its
// basic blocks
id = id << 1;
findSubroutine(subroutine, id);
}
}
l = l.successor;
}
// second step: finds the successors of RET blocks
findSubroutineSuccessors(0x1000, new Label[10], 0);
}
/*
* control flow analysis algorithm: while the block stack is n ot
* empty, pop a block from this stack, update the max stack size ,
* compute the true (non relative) begin stack size of the
7.18. METHODWRITER.JAVA 357
* successors of this block, and push these successors onto th e
* stack (unless they have already been pushed onto the stack) .
* Note: by hypothesis, the {@link Label#inputStackTop} of t he
* blocks in the block stack are the true (non relative)
* beginning stack sizes of these blocks.
*/
int max = 0;
Label stack = labels;
while(stack != null)
{
// pops a block from the stack
Label l = stack;
stack = stack.next;
// computes the true (non relative) max stack size of this
// block
int start = l.inputStackTop;
int blockMax = start + l.outputStackMax;
// updates the global max stack size
if(blockMax > max)
{
max = blockMax;
}
// analyses the successors of the block
Edge b = l.successors;
if((l.status & Label.JSR) != 0)
{
// ignores the first edge of JSR blocks
// (virtual successor)
b = b.next;
}
while(b != null)
{
l = b.successor;
// if this successor has not already been pushed...
if((l.status & Label.PUSHED) == 0)
{
// computes its true beginning stack size...
l.inputStackTop = b.info == Edge.EXCEPTION
? 1 : start + b.info;
// ...and pushes it onto the stack
l.status |= Label.PUSHED;
l.next = stack;
stack = l;
}
b = b.next;
}
}
this.maxStack = max;
}
else
358 CHAPTER 7. JVM/CLOJURE/ASM/
{
this.maxStack = maxStack;
this.maxLocals = maxLocals;
}
}
public void visitEnd(){
}
// ------------------------------------------------- ------------------
// Utility methods: control flow analysis algorithm
// ------------------------------------------------- ------------------
/**
* Computes the size of the arguments and of the return value of a
* method.
*
* @param desc the descriptor of a method.
* @return the size of the arguments of the method (plus one for the
* implicit this argument), argSize, and the size of its retur n
* value, retSize, packed into a single int i =
* <tt>(argSize << 2) | retSize</tt> (argSize is therefore eq ual
* to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).
*/
static int getArgumentsAndReturnSizes(final String desc ){
int n = 1;
int c = 1;
while(true)
{
char car = desc.charAt(c++);
if(car == ’)’)
{
car = desc.charAt(c);
return n << 2
| (car == ’V’ ? 0 : (car == ’D’ || car == ’J’ ? 2 : 1));
}
else if(car == ’L’)
{
while(desc.charAt(c++) != ’;’)
{
}
n += 1;
}
else if(car == ’[’)
{
while((car = desc.charAt(c)) == ’[’)
{
++c;
}
if(car == ’D’ || car == ’J’)
7.18. METHODWRITER.JAVA 359
{
n -= 1;
}
}
else if(car == ’D’ || car == ’J’)
{
n += 2;
}
else
{
n += 1;
}
}
}
/**
* Adds a successor to the {@link #currentBlock currentBlock } block.
*
* @param info information about the control flow edge to be ad ded.
* @param successor the successor block to be added to the curr ent block.
*/
private void addSuccessor(final int info, final Label succ essor){
// creates and initializes an Edge object...
Edge b = new Edge();
b.info = info;
b.successor = successor;
// ...and adds it to the successor list of the currentBlock bl ock
b.next = currentBlock.successors;
currentBlock.successors = b;
}
/**
* Ends the current basic block. This method must be used in the case
* where the current basic block does not have any successor.
*/
private void noSuccessor(){
if(compute == FRAMES)
{
Label l = new Label();
l.frame = new Frame();
l.frame.owner = l;
l.resolve(this, code.length, code.data);
previousBlock.successor = l;
previousBlock = l;
}
else
{
currentBlock.outputStackMax = maxStackSize;
}
currentBlock = null;
360 CHAPTER 7. JVM/CLOJURE/ASM/
}
/**
* Finds the basic blocks that belong to a given subroutine, an d marks
* these blocks as belonging to this subroutine (by using
* {@link Label#status} as a bit set (see {@link #visitMaxs}) . This
* recursive method follows the control flow graph to find all the
* blocks that are reachable from the given block WITHOUT foll owing
* any JSR target.
*
* @param block a block that belongs to the subroutine
* @param id the id of this subroutine
*/
private void findSubroutine(final Label block, final int i d){
// if ’block’ is already marked as belonging to subroutine ’i d’,
// returns
if((block.status & id) != 0)
{
return;
}
// marks ’block’ as belonging to subroutine ’id’
block.status |= id;
// calls this method recursively on each successor, except
// JSR targets
Edge e = block.successors;
while(e != null)
{
// if ’block’ is a JSR block, then ’block.successors.next’
// leads to the JSR target (see {@link #visitJumpInsn}) and
// must therefore not be followed
if((block.status & Label.JSR) == 0 || e != block.successors .next)
{
findSubroutine(e.successor, id);
}
e = e.next;
}
}
/**
* Finds the successors of the RET blocks of the specified subr outine,
* and of any nested subroutine it calls.
*
* @param id id of the subroutine whose RET block successors mu st
* be found.
* @param JSRs the JSR blocks that were followed to reach this
* subroutine.
* @param nJSRs number of JSR blocks in the JSRs array.
*/
private void findSubroutineSuccessors(
final int id,
7.18. METHODWRITER.JAVA 361
final Label[] JSRs,
final int nJSRs){
// iterates over all the basic blocks...
Label l = labels;
while(l != null)
{
// for those that belong to subroutine ’id’...
if((l.status & id) != 0)
{
if((l.status & Label.JSR) != 0)
{
// finds the subroutine to which ’l’ leads by
// following the second edge of l.successors (see
// {@link #visitJumpInsn})
int nId = l.successors.next.successor.status & ~0xFFF;
if(nId != id)
{
// calls this method recursively with l pushed onto
// the JSRs stack to find the successors of the RET
// blocks of this nested subroutine ’nId’
JSRs[nJSRs] = l;
findSubroutineSuccessors(nId, JSRs, nJSRs + 1);
}
}
else if((l.status & Label.RET) != 0)
{
/*
* finds the JSR block in the JSRs stack that corresponds
* to this RET block, and updates the successors of this
* RET block accordingly. This corresponding JSR is the
* one that leads to the subroutine to which the RET
* block belongs. But the RET block can belong to
* several subroutines (if a nested subroutine returns
* to its parent subroutine implicitely, without a RET).
* So, in fact, the JSR that corresponds to this RET is
* the first block in the JSRs stack, starting from the
* bottom of the stack, that leads to a subroutine to
* which the RET block belongs.
*/
for(int i = 0; i < nJSRs; ++i)
{
int JSRstatus =
JSRs[i].successors.next.successor.status;
if(((JSRstatus & ~0xFFF) &
(l.status & ~0xFFF)) != 0)
{
Edge e = new Edge();
e.info = l.inputStackTop;
e.successor = JSRs[i].successors.successor;
e.next = l.successors;
362 CHAPTER 7. JVM/CLOJURE/ASM/
l.successors = e;
break;
}
}
}
}
l = l.successor;
}
}
// ------------------------------------------------- ------------------
// Utility methods: stack map frames
// ------------------------------------------------- ------------------
/**
* Visits a frame that has been computed from scratch.
*
* @param f the frame that must be visited.
*/
private void visitFrame(final Frame f){
int i, t;
int nTop = 0;
int nLocal = 0;
int nStack = 0;
int[] locals = f.inputLocals;
int[] stacks = f.inputStack;
// computes the number of locals (ignores TOP types that are j ust
// after a LONG or a DOUBLE, and all trailing TOP types)
for(i = 0; i < locals.length; ++i)
{
t = locals[i];
if(t == Frame.TOP)
{
++nTop;
}
else
{
nLocal += nTop + 1;
nTop = 0;
}
if(t == Frame.LONG || t == Frame.DOUBLE)
{
++i;
}
}
// computes the stack size (ignores TOP types that are just af ter
// a LONG or a DOUBLE)
for(i = 0; i < stacks.length; ++i)
{
t = stacks[i];
7.18. METHODWRITER.JAVA 363
++nStack;
if(t == Frame.LONG || t == Frame.DOUBLE)
{
++i;
}
}
// visits the frame and its content
startFrame(f.owner.position, nLocal, nStack);
for(i = 0; nLocal > 0; ++i, --nLocal)
{
t = locals[i];
frame[frameIndex++] = t;
if(t == Frame.LONG || t == Frame.DOUBLE)
{
++i;
}
}
for(i = 0; i < stacks.length; ++i)
{
t = stacks[i];
frame[frameIndex++] = t;
if(t == Frame.LONG || t == Frame.DOUBLE)
{
++i;
}
}
endFrame();
}
/**
* Starts the visit of a stack map frame.
*
* @param offset the offset of the instruction to which the fra me
* corresponds.
* @param nLocal the number of local variables in the frame.
* @param nStack the number of stack elements in the frame.
*/
private void startFrame(final int offset,
final int nLocal,
final int nStack){
int n = 3 + nLocal + nStack;
if(frame == null || frame.length < n)
{
frame = new int[n];
}
frame[0] = offset;
frame[1] = nLocal;
frame[2] = nStack;
frameIndex = 3;
}
364 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Checks if the visit of the current frame {@link #frame} is fi nished,
* and if yes, write it in the StackMapTable attribute.
*/
private void endFrame(){
if(previousFrame != null)
{ // do not write the first frame
if(stackMap == null)
{
stackMap = new ByteVector();
}
writeFrame();
++frameCount;
}
previousFrame = frame;
frame = null;
}
/**
* Compress and writes the current frame {@link #frame} in the
* StackMapTable attribute.
*/
private void writeFrame(){
int clocalsSize = frame[1];
int cstackSize = frame[2];
if((cw.version & 0xFFFF) < Opcodes.V1_6)
{
stackMap.putShort(frame[0]).putShort(clocalsSize);
writeFrameTypes(3, 3 + clocalsSize);
stackMap.putShort(cstackSize);
writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackS ize);
return;
}
int localsSize = previousFrame[1];
int type = FULL_FRAME;
int k = 0;
int delta;
if(frameCount == 0)
{
delta = frame[0];
}
else
{
delta = frame[0] - previousFrame[0] - 1;
}
if(cstackSize == 0)
{
k = clocalsSize - localsSize;
switch(k)
7.18. METHODWRITER.JAVA 365
{
case-3:
case-2:
case-1:
type = CHOP_FRAME;
localsSize = clocalsSize;
break;
case 0:
type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;
break;
case 1:
case 2:
case 3:
type = APPEND_FRAME;
break;
}
}
else if(clocalsSize == localsSize && cstackSize == 1)
{
type = delta < 63
? SAME_LOCALS_1_STACK_ITEM_FRAME
: SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
}
if(type != FULL_FRAME)
{
// verify if locals are the same
int l = 3;
for(int j = 0; j < localsSize; j++)
{
if(frame[l] != previousFrame[l])
{
type = FULL_FRAME;
break;
}
l++;
}
}
switch(type)
{
case SAME_FRAME:
stackMap.putByte(delta);
break;
case SAME_LOCALS_1_STACK_ITEM_FRAME:
stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + del ta);
writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
break;
case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXT ENDED)
.putShort(delta);
writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
366 CHAPTER 7. JVM/CLOJURE/ASM/
break;
case SAME_FRAME_EXTENDED:
stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delt a);
break;
case CHOP_FRAME:
stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(de lta);
break;
case APPEND_FRAME:
stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(de lta);
writeFrameTypes(3 + localsSize, 3 + clocalsSize);
break;
// case FULL_FRAME:
default:
stackMap.putByte(FULL_FRAME)
.putShort(delta)
.putShort(clocalsSize);
writeFrameTypes(3, 3 + clocalsSize);
stackMap.putShort(cstackSize);
writeFrameTypes(3+clocalsSize, 3+clocalsSize+cstackS ize);
}
}
/**
* Writes some types of the current frame {@link #frame} into t he
* StackMapTableAttribute. This method converts types from the format
* used in {@link Label} to the format used in StackMapTable at tributes.
* In particular, it converts type table indexes to constant p ool
* indexes.
*
* @param start index of the first type in {@link #frame} to wri te.
* @param end index of last type in {@link #frame} to write
* (exclusive).
*/
private void writeFrameTypes(final int start, final int en d){
for(int i = start; i < end; ++i)
{
int t = frame[i];
int d = t & Frame.DIM;
if(d == 0)
{
int v = t & Frame.BASE_VALUE;
switch(t & Frame.BASE_KIND)
{
case Frame.OBJECT:
stackMap.putByte(7)
.putShort(cw.newClass(cw.typeTable[v].strVal1));
break;
case Frame.UNINITIALIZED:
stackMap.putByte(8).putShort(cw.typeTable[v].intVal );
break;
7.18. METHODWRITER.JAVA 367
default:
stackMap.putByte(v);
}
}
else
{
StringBuffer buf = new StringBuffer();
d >>= 28;
while(d-- > 0)
{
buf.append(’[’);
}
if((t & Frame.BASE_KIND) == Frame.OBJECT)
{
buf.append(’L’);
buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1 );
buf.append(’;’);
}
else
{
switch(t & 0xF)
{
case 1:
buf.append(’I’);
break;
case 2:
buf.append(’F’);
break;
case 3:
buf.append(’D’);
break;
case 9:
buf.append(’Z’);
break;
case 10:
buf.append(’B’);
break;
case 11:
buf.append(’C’);
break;
case 12:
buf.append(’S’);
break;
default:
buf.append(’J’);
}
}
stackMap.putByte(7).putShort(cw.newClass(buf.toStri ng()));
}
}
368 CHAPTER 7. JVM/CLOJURE/ASM/
}
private void writeFrameType(final Object type){
if(type instanceof String)
{
stackMap.putByte(7).putShort(cw.newClass((String) ty pe));
}
else if(type instanceof Integer)
{
stackMap.putByte(((Integer) type).intValue());
}
else
{
stackMap.putByte(8).putShort(((Label) type).position );
}
}
// ------------------------------------------------- ------------------
// Utility methods: dump bytecode array
// ------------------------------------------------- ------------------
/**
* Returns the size of the bytecode of this method.
*
* @return the size of the bytecode of this method.
*/
final int getSize(){
if(classReaderOffset != 0)
{
return 6 + classReaderLength;
}
if(resize)
{
// replaces the temporary jump opcodes introduced by
// Label.resolve.
resizeInstructions();
}
int size = 8;
if(code.length > 0)
{
cw.newUTF8("Code");
size += 18 + code.length + 8 * handlerCount;
if(localVar != null)
{
cw.newUTF8("LocalVariableTable");
size += 8 + localVar.length;
}
if(localVarType != null)
{
cw.newUTF8("LocalVariableTypeTable");
7.18. METHODWRITER.JAVA 369
size += 8 + localVarType.length;
}
if(lineNumber != null)
{
cw.newUTF8("LineNumberTable");
size += 8 + lineNumber.length;
}
if(stackMap != null)
{
boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
cw.newUTF8(zip ? "StackMapTable" : "StackMap");
size += 8 + stackMap.length;
}
if(cattrs != null)
{
size += cattrs.getSize(cw,
code.data,
code.length,
maxStack,
maxLocals);
}
}
if(exceptionCount > 0)
{
cw.newUTF8("Exceptions");
size += 8 + 2 * exceptionCount;
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
cw.newUTF8("Synthetic");
size += 6;
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
cw.newUTF8("Deprecated");
size += 6;
}
if(signature != null)
{
cw.newUTF8("Signature");
cw.newUTF8(signature);
size += 8;
}
if(annd != null)
{
cw.newUTF8("AnnotationDefault");
size += 6 + annd.length;
}
if(anns != null)
370 CHAPTER 7. JVM/CLOJURE/ASM/
{
cw.newUTF8("RuntimeVisibleAnnotations");
size += 8 + anns.getSize();
}
if(ianns != null)
{
cw.newUTF8("RuntimeInvisibleAnnotations");
size += 8 + ianns.getSize();
}
if(panns != null)
{
cw.newUTF8("RuntimeVisibleParameterAnnotations");
size += 7 + 2 * panns.length;
for(int i = panns.length - 1; i >= 0; --i)
{
size += panns[i] == null ? 0 : panns[i].getSize();
}
}
if(ipanns != null)
{
cw.newUTF8("RuntimeInvisibleParameterAnnotations");
size += 7 + 2 * ipanns.length;
for(int i = ipanns.length - 1; i >= 0; --i)
{
size += ipanns[i] == null ? 0 : ipanns[i].getSize();
}
}
if(attrs != null)
{
size += attrs.getSize(cw, null, 0, -1, -1);
}
return size;
}
/**
* Puts the bytecode of this method in the given byte vector.
*
* @param out the byte vector into which the bytecode of this me thod must
* be copied.
*/
final void put(final ByteVector out){
out.putShort(access).putShort(name).putShort(desc);
if(classReaderOffset != 0)
{
out.putByteArray(cw.cr.b, classReaderOffset, classRea derLength);
return;
}
int attributeCount = 0;
if(code.length > 0)
{
7.18. METHODWRITER.JAVA 371
++attributeCount;
}
if(exceptionCount > 0)
{
++attributeCount;
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
++attributeCount;
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
++attributeCount;
}
if(signature != null)
{
++attributeCount;
}
if(annd != null)
{
++attributeCount;
}
if(anns != null)
{
++attributeCount;
}
if(ianns != null)
{
++attributeCount;
}
if(panns != null)
{
++attributeCount;
}
if(ipanns != null)
{
++attributeCount;
}
if(attrs != null)
{
attributeCount += attrs.getCount();
}
out.putShort(attributeCount);
if(code.length > 0)
{
int size = 12 + code.length + 8 * handlerCount;
if(localVar != null)
{
size += 8 + localVar.length;
372 CHAPTER 7. JVM/CLOJURE/ASM/
}
if(localVarType != null)
{
size += 8 + localVarType.length;
}
if(lineNumber != null)
{
size += 8 + lineNumber.length;
}
if(stackMap != null)
{
size += 8 + stackMap.length;
}
if(cattrs != null)
{
size += cattrs.getSize(cw,
code.data,
code.length,
maxStack,
maxLocals);
}
out.putShort(cw.newUTF8("Code")).putInt(size);
out.putShort(maxStack).putShort(maxLocals);
out.putInt(code.length).putByteArray(code.data, 0, co de.length);
out.putShort(handlerCount);
if(handlerCount > 0)
{
Handler h = firstHandler;
while(h != null)
{
out.putShort(h.start.position)
.putShort(h.end.position)
.putShort(h.handler.position)
.putShort(h.type);
h = h.next;
}
}
attributeCount = 0;
if(localVar != null)
{
++attributeCount;
}
if(localVarType != null)
{
++attributeCount;
}
if(lineNumber != null)
{
++attributeCount;
}
7.18. METHODWRITER.JAVA 373
if(stackMap != null)
{
++attributeCount;
}
if(cattrs != null)
{
attributeCount += cattrs.getCount();
}
out.putShort(attributeCount);
if(localVar != null)
{
out.putShort(cw.newUTF8("LocalVariableTable"));
out.putInt(localVar.length + 2).putShort(localVarCoun t);
out.putByteArray(localVar.data, 0, localVar.length);
}
if(localVarType != null)
{
out.putShort(cw.newUTF8("LocalVariableTypeTable"));
out.putInt(localVarType.length + 2)
.putShort(localVarTypeCount);
out.putByteArray(localVarType.data, 0, localVarType.l ength);
}
if(lineNumber != null)
{
out.putShort(cw.newUTF8("LineNumberTable"));
out.putInt(lineNumber.length + 2).putShort(lineNumber Count);
out.putByteArray(lineNumber.data, 0, lineNumber.lengt h);
}
if(stackMap != null)
{
boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
out.putShort(cw.newUTF8(zip ? "StackMapTable" : "StackM ap"));
out.putInt(stackMap.length + 2).putShort(frameCount);
out.putByteArray(stackMap.data, 0, stackMap.length);
}
if(cattrs != null)
{
cattrs.put(cw, code.data, code.length,
maxLocals, maxStack, out);
}
}
if(exceptionCount > 0)
{
out.putShort(cw.newUTF8("Exceptions"))
.putInt(2 * exceptionCount + 2);
out.putShort(exceptionCount);
for(int i = 0; i < exceptionCount; ++i)
{
out.putShort(exceptions[i]);
}
374 CHAPTER 7. JVM/CLOJURE/ASM/
}
if((access & Opcodes.ACC_SYNTHETIC) != 0
&& (cw.version & 0xffff) < Opcodes.V1_5)
{
out.putShort(cw.newUTF8("Synthetic")).putInt(0);
}
if((access & Opcodes.ACC_DEPRECATED) != 0)
{
out.putShort(cw.newUTF8("Deprecated")).putInt(0);
}
if(signature != null)
{
out.putShort(cw.newUTF8("Signature"))
.putInt(2)
.putShort(cw.newUTF8(signature));
}
if(annd != null)
{
out.putShort(cw.newUTF8("AnnotationDefault"));
out.putInt(annd.length);
out.putByteArray(annd.data, 0, annd.length);
}
if(anns != null)
{
out.putShort(cw.newUTF8("RuntimeVisibleAnnotations" ));
anns.put(out);
}
if(ianns != null)
{
out.putShort(cw.newUTF8("RuntimeInvisibleAnnotation s"));
ianns.put(out);
}
if(panns != null)
{
out.putShort(cw.newUTF8("RuntimeVisibleParameterAnn otations"));
AnnotationWriter.put(panns, out);
}
if(ipanns != null)
{
out.putShort(cw.newUTF8("RuntimeInvisibleParameterA nnotations"));
AnnotationWriter.put(ipanns, out);
}
if(attrs != null)
{
attrs.put(cw, null, 0, -1, -1, out);
}
}
// ------------------------------------------------- ------------------
// Utility methods: instruction resizing (used to handle GO TO_W and
7.18. METHODWRITER.JAVA 375
// JSR_W)
// ------------------------------------------------- -----------------
/**
* Resizes and replaces the temporary instructions inserted by
* {@link Label#resolve} for wide forward jumps, while keepi ng jump
* offsets and instruction addresses consistent. This may re quire to
* resize other existing instructions, or even to introduce n ew
* instructions: for example, increasing the size of an instr uction
* by 2 at the middle of a method can increases the offset of an
* IFEQ instruction from 32766 to 32768, in which case IFEQ 327 66
* must be replaced with IFNEQ 8 GOTO_W 32765. This, in turn, ma y
* require to increase the size of another jump instruction, a nd so
* on... All these operations are handled automatically by th is
* method. <p> <i>This method must be called after all the meth od
* that is being built has been visited</i>. In particular, th e
* {@link Label Label} objects used to construct the method ar e no
* longer valid after this method has been called.
*/
private void resizeInstructions(){
byte[] b = code.data; // bytecode of the method
int u, v, label; // indexes in b
int i, j; // loop indexes
/*
* 1st step: As explained above, resizing an instruction may r equire
* to resize another one, which may require to resize yet anoth er
* one, and so on. The first step of the algorithm consists in
* finding all the instructions that need to be resized, witho ut
* modifying the code. This is done by the following "fix point "
* algorithm:
*
* Parse the code to find the jump instructions whose offset wi ll
* need more than 2 bytes to be stored (the future offset is
* computed from the current offset and from the number of byte s
* that will be inserted or removed between the source and targ et
* instructions). For each such instruction, adds an entry in (a
* copy of) the indexes and sizes arrays (if this has not alread y
* been done in a previous iteration!).
*
* If at least one entry has been added during the previous step , go
* back to the beginning, otherwise stop.
*
* In fact the real algorithm is complicated by the fact that th e
* size of TABLESWITCH and LOOKUPSWITCH instructions depend s on their
* position in the bytecode (because of padding). In order to e nsure
* the convergence of the algorithm, the number of bytes to be a dded
* or removed from these instructions is over estimated durin g the
* previous loop, and computed exactly only after the loop is
* finished (this requires another pass to parse the bytecode of
* the method).
376 CHAPTER 7. JVM/CLOJURE/ASM/
*/
int[] allIndexes = new int[0]; // copy of indexes
int[] allSizes = new int[0]; // copy of sizes
boolean[] resize; // instructions to be resized
int newOffset; // future offset of a jump instruction
resize = new boolean[code.length];
// 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
int state = 3;
do
{
if(state == 3)
{
state = 2;
}
u = 0;
while(u < b.length)
{
int opcode = b[u] & 0xFF; // opcode of current instruction
int insert = 0; // bytes to be added after this instruction
switch(ClassWriter.TYPE[opcode])
{
case ClassWriter.NOARG_INSN:
case ClassWriter.IMPLVAR_INSN:
u += 1;
break;
case ClassWriter.LABEL_INSN:
if(opcode > 201)
{
// converts temporary opcodes 202 to 217, 218 and
// 219 to IFEQ ... JSR (inclusive), IFNULL and
// IFNONNULL
opcode =
opcode < 218 ? opcode - 49 : opcode - 20;
label = u + readUnsignedShort(b, u + 1);
}
else
{
label = u + readShort(b, u + 1);
}
newOffset =
getNewOffset(allIndexes, allSizes, u, label);
if(newOffset < Short.MIN_VALUE
|| newOffset > Short.MAX_VALUE)
{
if(!resize[u])
{
if(opcode == Opcodes.GOTO
7.18. METHODWRITER.JAVA 377
|| opcode == Opcodes.JSR)
{
// two additional bytes will be required to
// replace this GOTO or JSR instruction with
// a GOTO_W or a JSR_W
insert = 2;
}
else
{
// five additional bytes will be required to
// replace this IFxxx <l> instruction with
// IFNOTxxx <l’> GOTO_W <l>, where IFNOTxxx
// is the "opposite" opcode of IFxxx (i.e.,
// IFNE for IFEQ) and where <l’> designates
// the instruction just after the GOTO_W.
insert = 5;
}
resize[u] = true;
}
}
u += 3;
break;
case ClassWriter.LABELW_INSN:
u += 5;
break;
case ClassWriter.TABL_INSN:
if(state == 1)
{
// true number of bytes to be added (or removed)
// from this instruction = (future number of
// padding bytes - current number of padding
// byte) - previously over estimated variation =
// = ((3 - newOffset%4) - (3 - u%4)) - u%4
// = (-newOffset%4 + u%4) - u%4
// = -(newOffset & 3)
newOffset =
getNewOffset(allIndexes, allSizes, 0, u);
insert = -(newOffset & 3);
}
else if(!resize[u])
{
// over estimation of the number of bytes to be
// added to this instruction = 3 - current number
// of padding bytes = 3 - (3 - u%4) = u%4 = u & 3
insert = u & 3;
resize[u] = true;
}
// skips instruction
u = u + 4 - (u & 3);
u += 4*(readInt(b,u+8) - readInt(b,u+4)+1)+12;
378 CHAPTER 7. JVM/CLOJURE/ASM/
break;
case ClassWriter.LOOK_INSN:
if(state == 1)
{
// like TABL_INSN
newOffset =
getNewOffset(allIndexes, allSizes, 0, u);
insert = -(newOffset & 3);
}
else if(!resize[u])
{
// like TABL_INSN
insert = u & 3;
resize[u] = true;
}
// skips instruction
u = u + 4 - (u & 3);
u += 8 * readInt(b, u + 4) + 8;
break;
case ClassWriter.WIDE_INSN:
opcode = b[u + 1] & 0xFF;
if(opcode == Opcodes.IINC)
{
u += 6;
}
else
{
u += 4;
}
break;
case ClassWriter.VAR_INSN:
case ClassWriter.SBYTE_INSN:
case ClassWriter.LDC_INSN:
u += 2;
break;
case ClassWriter.SHORT_INSN:
case ClassWriter.LDCW_INSN:
case ClassWriter.FIELDORMETH_INSN:
case ClassWriter.TYPE_INSN:
case ClassWriter.IINC_INSN:
u += 3;
break;
case ClassWriter.ITFMETH_INSN:
u += 5;
break;
// case ClassWriter.MANA_INSN:
default:
u += 4;
break;
}
7.18. METHODWRITER.JAVA 379
if(insert != 0)
{
// adds a new (u, insert) entry in the allIndexes and
// allSizes arrays
int[] newIndexes = new int[allIndexes.length + 1];
int[] newSizes = new int[allSizes.length + 1];
System.arraycopy(allIndexes,
0,
newIndexes,
0,
allIndexes.length);
System.arraycopy(allSizes,0,newSizes,0,allSizes.len gth);
newIndexes[allIndexes.length] = u;
newSizes[allSizes.length] = insert;
allIndexes = newIndexes;
allSizes = newSizes;
if(insert > 0)
{
state = 3;
}
}
}
if(state < 3)
{
--state;
}
} while(state != 0);
// 2nd step:
// copies the bytecode of the method into a new bytevector, up dates
// the offsets, and inserts (or removes) bytes as requested.
ByteVector newCode = new ByteVector(code.length);
u = 0;
while(u < code.length)
{
int opcode = b[u] & 0xFF;
switch(ClassWriter.TYPE[opcode])
{
case ClassWriter.NOARG_INSN:
case ClassWriter.IMPLVAR_INSN:
newCode.putByte(opcode);
u += 1;
break;
case ClassWriter.LABEL_INSN:
if(opcode > 201)
{
// changes temporary opcodes 202 to 217 (inclusive),
// 218 and 219 to IFEQ ... JSR (inclusive), IFNULL
380 CHAPTER 7. JVM/CLOJURE/ASM/
// and IFNONNULL
opcode = opcode < 218 ? opcode - 49 : opcode - 20;
label = u + readUnsignedShort(b, u + 1);
}
else
{
label = u + readShort(b, u + 1);
}
newOffset = getNewOffset(allIndexes, allSizes, u, label) ;
if(resize[u])
{
// replaces GOTO with GOTO_W, JSR with JSR_W and
// IFxxx <l> with IFNOTxxx <l’> GOTO_W <l>, where
// IFNOTxxx is the "opposite" opcode of IFxxx
// (i.e., IFNE for IFEQ) and where <l’> designates
// the instruction just after the GOTO_W.
if(opcode == Opcodes.GOTO)
{
newCode.putByte(200); // GOTO_W
}
else if(opcode == Opcodes.JSR)
{
newCode.putByte(201); // JSR_W
}
else
{
newCode.putByte(opcode <= 166
? ((opcode + 1) ^ 1) - 1
: opcode ^ 1);
newCode.putShort(8); // jump offset
newCode.putByte(200); // GOTO_W
// newOffset now computed from start of GOTO_W
newOffset -= 3;
}
newCode.putInt(newOffset);
}
else
{
newCode.putByte(opcode);
newCode.putShort(newOffset);
}
u += 3;
break;
case ClassWriter.LABELW_INSN:
label = u + readInt(b, u + 1);
newOffset = getNewOffset(allIndexes, allSizes, u, label) ;
newCode.putByte(opcode);
newCode.putInt(newOffset);
u += 5;
break;
7.18. METHODWRITER.JAVA 381
case ClassWriter.TABL_INSN:
// skips 0 to 3 padding bytes
v = u;
u = u + 4 - (v & 3);
// reads and copies instruction
newCode.putByte(Opcodes.TABLESWITCH);
newCode.length += (4 - newCode.length % 4) % 4;
label = v + readInt(b, u);
u += 4;
newOffset = getNewOffset(allIndexes, allSizes, v, label) ;
newCode.putInt(newOffset);
j = readInt(b, u);
u += 4;
newCode.putInt(j);
j = readInt(b, u) - j + 1;
u += 4;
newCode.putInt(readInt(b, u - 4));
for(; j > 0; --j)
{
label = v + readInt(b, u);
u += 4;
newOffset =
getNewOffset(allIndexes, allSizes, v, label);
newCode.putInt(newOffset);
}
break;
case ClassWriter.LOOK_INSN:
// skips 0 to 3 padding bytes
v = u;
u = u + 4 - (v & 3);
// reads and copies instruction
newCode.putByte(Opcodes.LOOKUPSWITCH);
newCode.length += (4 - newCode.length % 4) % 4;
label = v + readInt(b, u);
u += 4;
newOffset = getNewOffset(allIndexes, allSizes, v, label) ;
newCode.putInt(newOffset);
j = readInt(b, u);
u += 4;
newCode.putInt(j);
for(; j > 0; --j)
{
newCode.putInt(readInt(b, u));
u += 4;
label = v + readInt(b, u);
u += 4;
newOffset =
getNewOffset(allIndexes, allSizes, v, label);
newCode.putInt(newOffset);
}
382 CHAPTER 7. JVM/CLOJURE/ASM/
break;
case ClassWriter.WIDE_INSN:
opcode = b[u + 1] & 0xFF;
if(opcode == Opcodes.IINC)
{
newCode.putByteArray(b, u, 6);
u += 6;
}
else
{
newCode.putByteArray(b, u, 4);
u += 4;
}
break;
case ClassWriter.VAR_INSN:
case ClassWriter.SBYTE_INSN:
case ClassWriter.LDC_INSN:
newCode.putByteArray(b, u, 2);
u += 2;
break;
case ClassWriter.SHORT_INSN:
case ClassWriter.LDCW_INSN:
case ClassWriter.FIELDORMETH_INSN:
case ClassWriter.TYPE_INSN:
case ClassWriter.IINC_INSN:
newCode.putByteArray(b, u, 3);
u += 3;
break;
case ClassWriter.ITFMETH_INSN:
newCode.putByteArray(b, u, 5);
u += 5;
break;
// case MANA_INSN:
default:
newCode.putByteArray(b, u, 4);
u += 4;
break;
}
}
// recomputes the stack map frames
if(frameCount > 0)
{
if(compute == FRAMES)
{
frameCount = 0;
stackMap = null;
previousFrame = null;
frame = null;
Frame f = new Frame();
7.18. METHODWRITER.JAVA 383
f.owner = labels;
Type[] args = Type.getArgumentTypes(descriptor);
f.initInputFrame(cw, access, args, maxLocals);
visitFrame(f);
Label l = labels;
while(l != null)
{
/*
* here we need the original label position. getNewOffset
* must therefore never have been called for this label.
*/
u = l.position - 3;
if((l.status & Label.STORE) != 0 ||
(u >= 0 && resize[u]))
{
getNewOffset(allIndexes, allSizes, l);
// TODO update offsets in UNINITIALIZED values
visitFrame(l.frame);
}
l = l.successor;
}
}
else
{
/*
* Resizing an existing stack map frame table is really
* hard. Not only the table must be parsed to update the
* offets, but new frames may be needed for jump
* instructions that were inserted by this method. And
* updating the offsets or inserting frames can change
* the format of the following frames, in case of packed
* frames. In practice the whole table must be recomputed.
* For this the frames are marked as potentially invalid.
* This will cause the whole class to be reread and
* rewritten with the COMPUTE_FRAMES option (see the
* ClassWriter.toByteArray method). This is not very
* efficient but is much easier and requires much less
* code than any other method I can think of.
*/
cw.invalidFrames = true;
}
}
// updates the exception handler block labels
Handler h = firstHandler;
while(h != null)
{
getNewOffset(allIndexes, allSizes, h.start);
getNewOffset(allIndexes, allSizes, h.end);
getNewOffset(allIndexes, allSizes, h.handler);
h = h.next;
384 CHAPTER 7. JVM/CLOJURE/ASM/
}
// updates the instructions addresses in the
// local var and line number tables
for(i = 0; i < 2; ++i)
{
ByteVector bv = i == 0 ? localVar : localVarType;
if(bv != null)
{
b = bv.data;
u = 0;
while(u < bv.length)
{
label = readUnsignedShort(b, u);
newOffset = getNewOffset(allIndexes, allSizes, 0, label) ;
writeShort(b, u, newOffset);
label += readUnsignedShort(b, u + 2);
newOffset = getNewOffset(allIndexes, allSizes, 0, label)
- newOffset;
writeShort(b, u + 2, newOffset);
u += 10;
}
}
}
if(lineNumber != null)
{
b = lineNumber.data;
u = 0;
while(u < lineNumber.length)
{
writeShort(b, u, getNewOffset(allIndexes,
allSizes,
0,
readUnsignedShort(b, u)));
u += 4;
}
}
// updates the labels of the other attributes
Attribute attr = cattrs;
while(attr != null)
{
Label[] labels = attr.getLabels();
if(labels != null)
{
for(i = labels.length - 1; i >= 0; --i)
{
getNewOffset(allIndexes, allSizes, labels[i]);
}
}
attr = attr.next;
}
7.18. METHODWRITER.JAVA 385
// replaces old bytecodes with new ones
code = newCode;
}
/**
* Reads an unsigned short value in the given byte array.
*
* @param b a byte array.
* @param index the start index of the value to be read.
* @return the read value.
*/
static int readUnsignedShort(final byte[] b, final int ind ex){
return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
}
/**
* Reads a signed short value in the given byte array.
*
* @param b a byte array.
* @param index the start index of the value to be read.
* @return the read value.
*/
static short readShort(final byte[] b, final int index){
return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF ));
}
/**
* Reads a signed int value in the given byte array.
*
* @param b a byte array.
* @param index the start index of the value to be read.
* @return the read value.
*/
static int readInt(final byte[] b, final int index){
return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
| ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
}
/**
* Writes a short value in the given byte array.
*
* @param b a byte array.
* @param index where the first byte of the short value must be w ritten.
* @param s the value to be written in the given byte array.
*/
static void writeShort(final byte[] b, final int index, fin al int s){
b[index] = (byte) (s >>> 8);
b[index + 1] = (byte) s;
}
386 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Computes the future value of a bytecode offset. <p> Note: it is
* possible to have several entries for the same instruction i n the
* <tt>indexes</tt> and <tt>sizes</tt>: two entries (index =a,size=b)
* and (index=a,size=b’) are equivalent to a single entry
* (index=a,size=b+b’).
*
* @param indexes current positions of the instructions to be resized.
* Each instruction must be designated by the index of
* its <i>last</i> byte, plus one (or, in other words, by
* the index of the <i>first</i> byte of the <i>next</i>
* instruction).
* @param sizes the number of bytes to be <i>added</i> to the ab ove
* instructions. More precisely, for each
* i < <tt>len</tt>, <tt>sizes</tt>[i] bytes will be
* added at the end of the instruction designated by
* <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is
* negative, the <i>last</i> |<tt>sizes[i]</tt>|
* bytes of the instruction will be removed (the
* instruction size <i>must not</i> become negative or
* null).
* @param begin index of the first byte of the source instructi on.
* @param end index of the first byte of the target instruction .
* @return the future value of the given bytecode offset.
*/
static int getNewOffset(
final int[] indexes,
final int[] sizes,
final int begin,
final int end){
int offset = end - begin;
for(int i = 0; i < indexes.length; ++i)
{
if(begin < indexes[i] && indexes[i] <= end)
{
// forward jump
offset += sizes[i];
}
else if(end < indexes[i] && indexes[i] <= begin)
{
// backward jump
offset -= sizes[i];
}
}
return offset;
}
/**
* Updates the offset of the given label.
7.19. OPCODES.JAVA 387
*
* @param indexes current positions of the instructions to be resized.
* Each instruction must be designated by the index of
* its <i>last</i> byte, plus one (or, in other words,
* by the index of the <i>first</i> byte of the
* <i>next</i> instruction).
* @param sizes the number of bytes to be <i>added</i> to the ab ove
* instructions. More precisely, for each
* i < <tt>len</tt>, <tt>sizes</tt>[i] bytes will be
* added at the end of the instruction designated by
* <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is
* negative, the <i>last</i> | <tt>sizes[i]</tt>|
* bytes of the instruction will be removed (the
* instruction size <i>must not</i> become negative
* or null).
* @param label the label whose offset must be updated.
*/
static void getNewOffset(
final int[] indexes,
final int[] sizes,
final Label label){
if((label.status & Label.RESIZED) == 0)
{
label.position = getNewOffset(indexes, sizes, 0, label.p osition);
label.status |= Label.RESIZED;
}
}
}
———-
7.19 Opcodes.java
— Opcodes.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
/**
* Defines the JVM opcodes, access flags and array type codes. This
* interface does not define all the JVM opcodes because some o pcodes
* are automatically handled. For example, the xLOAD and xSTO RE opcodes
* are automatically replaced by xLOAD_n and xSTORE_n opcode s when
* possible. The xLOAD_n and xSTORE_n opcodes are therefore n ot
* defined in this interface. Likewise for LDC, automaticall y replaced
* by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W.
*
388 CHAPTER 7. JVM/CLOJURE/ASM/
* @author Eric Bruneton
* @author Eugene Kuleshov
*/
public interface Opcodes{
// versions
int V1_1 = 3 << 16 | 45;
int V1_2 = 0 << 16 | 46;
int V1_3 = 0 << 16 | 47;
int V1_4 = 0 << 16 | 48;
int V1_5 = 0 << 16 | 49;
int V1_6 = 0 << 16 | 50;
// access flags
int ACC_PUBLIC = 0x0001; // class, field, method
int ACC_PRIVATE = 0x0002; // class, field, method
int ACC_PROTECTED = 0x0004; // class, field, method
int ACC_STATIC = 0x0008; // field, method
int ACC_FINAL = 0x0010; // class, field, method
int ACC_SUPER = 0x0020; // class
int ACC_SYNCHRONIZED = 0x0020; // method
int ACC_VOLATILE = 0x0040; // field
int ACC_BRIDGE = 0x0040; // method
int ACC_VARARGS = 0x0080; // method
int ACC_TRANSIENT = 0x0080; // field
int ACC_NATIVE = 0x0100; // method
int ACC_INTERFACE = 0x0200; // class
int ACC_ABSTRACT = 0x0400; // class, method
int ACC_STRICT = 0x0800; // method
int ACC_SYNTHETIC = 0x1000; // class, field, method
int ACC_ANNOTATION = 0x2000; // class
int ACC_ENUM = 0x4000; // class(?) field inner
// ASM specific pseudo access flags
int ACC_DEPRECATED = 131072; // class, field, method
// types for NEWARRAY
int T_BOOLEAN = 4;
int T_CHAR = 5;
int T_FLOAT = 6;
int T_DOUBLE = 7;
int T_BYTE = 8;
int T_SHORT = 9;
int T_INT = 10;
int T_LONG = 11;
7.19. OPCODES.JAVA 389
// stack map frame types
/**
* Represents an expanded frame. See {@link ClassReader#EXP AND_FRAMES}.
*/
int F_NEW = -1;
/**
* Represents a compressed frame with complete frame data.
*/
int F_FULL = 0;
/**
* Represents a compressed frame where locals are the same as t he
* locals in the previous frame, except that additional 1-3 lo cals
* are defined, and with an empty stack.
*/
int F_APPEND = 1;
/**
* Represents a compressed frame where locals are the same as t he
* locals in the previous frame, except that the last 1-3 local s are
* absent and with an empty stack.
*/
int F_CHOP = 2;
/**
* Represents a compressed frame with exactly the same locals as the
* previous frame and with an empty stack.
*/
int F_SAME = 3;
/**
* Represents a compressed frame with exactly the same locals as the
* previous frame and with a single value on the stack.
*/
int F_SAME1 = 4;
Integer TOP = new Integer(0);
Integer INTEGER = new Integer(1);
Integer FLOAT = new Integer(2);
Integer DOUBLE = new Integer(3);
Integer LONG = new Integer(4);
Integer NULL = new Integer(5);
Integer UNINITIALIZED_THIS = new Integer(6);
// opcodes // visit method (- = idem)
int NOP = 0; // visitInsn
int ACONST_NULL = 1; // -
390 CHAPTER 7. JVM/CLOJURE/ASM/
int ICONST_M1 = 2; // -
int ICONST_0 = 3; // -
int ICONST_1 = 4; // -
int ICONST_2 = 5; // -
int ICONST_3 = 6; // -
int ICONST_4 = 7; // -
int ICONST_5 = 8; // -
int LCONST_0 = 9; // -
int LCONST_1 = 10; // -
int FCONST_0 = 11; // -
int FCONST_1 = 12; // -
int FCONST_2 = 13; // -
int DCONST_0 = 14; // -
int DCONST_1 = 15; // -
int BIPUSH = 16; // visitIntInsn
int SIPUSH = 17; // -
int LDC = 18; // visitLdcInsn
// int LDC_W = 19; // -
// int LDC2_W = 20; // -
int ILOAD = 21; // visitVarInsn
int LLOAD = 22; // -
int FLOAD = 23; // -
int DLOAD = 24; // -
int ALOAD = 25; // -
// int ILOAD_0 = 26; // -
// int ILOAD_1 = 27; // -
// int ILOAD_2 = 28; // -
// int ILOAD_3 = 29; // -
// int LLOAD_0 = 30; // -
// int LLOAD_1 = 31; // -
// int LLOAD_2 = 32; // -
// int LLOAD_3 = 33; // -
// int FLOAD_0 = 34; // -
// int FLOAD_1 = 35; // -
// int FLOAD_2 = 36; // -
// int FLOAD_3 = 37; // -
// int DLOAD_0 = 38; // -
// int DLOAD_1 = 39; // -
// int DLOAD_2 = 40; // -
// int DLOAD_3 = 41; // -
// int ALOAD_0 = 42; // -
// int ALOAD_1 = 43; // -
// int ALOAD_2 = 44; // -
// int ALOAD_3 = 45; // -
int IALOAD = 46; // visitInsn
int LALOAD = 47; // -
int FALOAD = 48; // -
int DALOAD = 49; // -
int AALOAD = 50; // -
int BALOAD = 51; // -
7.19. OPCODES.JAVA 391
int CALOAD = 52; // -
int SALOAD = 53; // -
int ISTORE = 54; // visitVarInsn
int LSTORE = 55; // -
int FSTORE = 56; // -
int DSTORE = 57; // -
int ASTORE = 58; // -
// int ISTORE_0 = 59; // -
// int ISTORE_1 = 60; // -
// int ISTORE_2 = 61; // -
// int ISTORE_3 = 62; // -
// int LSTORE_0 = 63; // -
// int LSTORE_1 = 64; // -
// int LSTORE_2 = 65; // -
// int LSTORE_3 = 66; // -
// int FSTORE_0 = 67; // -
// int FSTORE_1 = 68; // -
// int FSTORE_2 = 69; // -
// int FSTORE_3 = 70; // -
// int DSTORE_0 = 71; // -
// int DSTORE_1 = 72; // -
// int DSTORE_2 = 73; // -
// int DSTORE_3 = 74; // -
// int ASTORE_0 = 75; // -
// int ASTORE_1 = 76; // -
// int ASTORE_2 = 77; // -
// int ASTORE_3 = 78; // -
int IASTORE = 79; // visitInsn
int LASTORE = 80; // -
int FASTORE = 81; // -
int DASTORE = 82; // -
int AASTORE = 83; // -
int BASTORE = 84; // -
int CASTORE = 85; // -
int SASTORE = 86; // -
int POP = 87; // -
int POP2 = 88; // -
int DUP = 89; // -
int DUP_X1 = 90; // -
int DUP_X2 = 91; // -
int DUP2 = 92; // -
int DUP2_X1 = 93; // -
int DUP2_X2 = 94; // -
int SWAP = 95; // -
int IADD = 96; // -
int LADD = 97; // -
int FADD = 98; // -
int DADD = 99; // -
int ISUB = 100; // -
int LSUB = 101; // -
392 CHAPTER 7. JVM/CLOJURE/ASM/
int FSUB = 102; // -
int DSUB = 103; // -
int IMUL = 104; // -
int LMUL = 105; // -
int FMUL = 106; // -
int DMUL = 107; // -
int IDIV = 108; // -
int LDIV = 109; // -
int FDIV = 110; // -
int DDIV = 111; // -
int IREM = 112; // -
int LREM = 113; // -
int FREM = 114; // -
int DREM = 115; // -
int INEG = 116; // -
int LNEG = 117; // -
int FNEG = 118; // -
int DNEG = 119; // -
int ISHL = 120; // -
int LSHL = 121; // -
int ISHR = 122; // -
int LSHR = 123; // -
int IUSHR = 124; // -
int LUSHR = 125; // -
int IAND = 126; // -
int LAND = 127; // -
int IOR = 128; // -
int LOR = 129; // -
int IXOR = 130; // -
int LXOR = 131; // -
int IINC = 132; // visitIincInsn
int I2L = 133; // visitInsn
int I2F = 134; // -
int I2D = 135; // -
int L2I = 136; // -
int L2F = 137; // -
int L2D = 138; // -
int F2I = 139; // -
int F2L = 140; // -
int F2D = 141; // -
int D2I = 142; // -
int D2L = 143; // -
int D2F = 144; // -
int I2B = 145; // -
int I2C = 146; // -
int I2S = 147; // -
int LCMP = 148; // -
int FCMPL = 149; // -
int FCMPG = 150; // -
int DCMPL = 151; // -
7.19. OPCODES.JAVA 393
int DCMPG = 152; // -
int IFEQ = 153; // visitJumpInsn
int IFNE = 154; // -
int IFLT = 155; // -
int IFGE = 156; // -
int IFGT = 157; // -
int IFLE = 158; // -
int IF_ICMPEQ = 159; // -
int IF_ICMPNE = 160; // -
int IF_ICMPLT = 161; // -
int IF_ICMPGE = 162; // -
int IF_ICMPGT = 163; // -
int IF_ICMPLE = 164; // -
int IF_ACMPEQ = 165; // -
int IF_ACMPNE = 166; // -
int GOTO = 167; // -
int JSR = 168; // -
int RET = 169; // visitVarInsn
int TABLESWITCH = 170; // visiTableSwitchInsn
int LOOKUPSWITCH = 171; // visitLookupSwitch
int IRETURN = 172; // visitInsn
int LRETURN = 173; // -
int FRETURN = 174; // -
int DRETURN = 175; // -
int ARETURN = 176; // -
int RETURN = 177; // -
int GETSTATIC = 178; // visitFieldInsn
int PUTSTATIC = 179; // -
int GETFIELD = 180; // -
int PUTFIELD = 181; // -
int INVOKEVIRTUAL = 182; // visitMethodInsn
int INVOKESPECIAL = 183; // -
int INVOKESTATIC = 184; // -
int INVOKEINTERFACE = 185; // -
// int UNUSED = 186; // NOT VISITED
int NEW = 187; // visitTypeInsn
int NEWARRAY = 188; // visitIntInsn
int ANEWARRAY = 189; // visitTypeInsn
int ARRAYLENGTH = 190; // visitInsn
int ATHROW = 191; // -
int CHECKCAST = 192; // visitTypeInsn
int INSTANCEOF = 193; // -
int MONITORENTER = 194; // visitInsn
int MONITOREXIT = 195; // -
// int WIDE = 196; // NOT VISITED
int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn
int IFNULL = 198; // visitJumpInsn
int IFNONNULL = 199; // -
// int GOTO_W = 200; // -
// int JSR_W = 201; // -
394 CHAPTER 7. JVM/CLOJURE/ASM/
}
———-
7.20 Type.java
— Type.java —
\getchunk{France Telecom Copyright}
package clojure.asm;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
/**
* A Java type. This class can be used to make it easier to manipu late
* type and method descriptors.
*
* @author Eric Bruneton
* @author Chris Nokleberg
*/
public class Type{
/**
* The sort of the <tt>void</tt> type. See {@link #getSort get Sort}.
*/
public final static int VOID = 0;
/**
* The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.
*/
public final static int BOOLEAN = 1;
/**
* The sort of the <tt>char</tt> type. See {@link #getSort get Sort}.
*/
public final static int CHAR = 2;
/**
* The sort of the <tt>byte</tt> type. See {@link #getSort get Sort}.
*/
public final static int BYTE = 3;
/**
* The sort of the <tt>short</tt> type. See {@link #getSort ge tSort}.
*/
public final static int SHORT = 4;
7.20. TYPE.JAVA 395
/**
* The sort of the <tt>int</tt> type. See {@link #getSort getS ort}.
*/
public final static int INT = 5;
/**
* The sort of the <tt>float</tt> type. See {@link #getSort ge tSort}.
*/
public final static int FLOAT = 6;
/**
* The sort of the <tt>long</tt> type. See {@link #getSort get Sort}.
*/
public final static int LONG = 7;
/**
* The sort of the <tt>double</tt> type. See {@link #getSort g etSort}.
*/
public final static int DOUBLE = 8;
/**
* The sort of array reference types. See {@link #getSort getS ort}.
*/
public final static int ARRAY = 9;
/**
* The sort of object reference type. See {@link #getSort getS ort}.
*/
public final static int OBJECT = 10;
/**
* The <tt>void</tt> type.
*/
public final static Type VOID_TYPE = new Type(VOID);
/**
* The <tt>boolean</tt> type.
*/
public final static Type BOOLEAN_TYPE = new Type(BOOLEAN);
/**
* The <tt>char</tt> type.
*/
public final static Type CHAR_TYPE = new Type(CHAR);
/**
* The <tt>byte</tt> type.
*/
public final static Type BYTE_TYPE = new Type(BYTE);
396 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* The <tt>short</tt> type.
*/
public final static Type SHORT_TYPE = new Type(SHORT);
/**
* The <tt>int</tt> type.
*/
public final static Type INT_TYPE = new Type(INT);
/**
* The <tt>float</tt> type.
*/
public final static Type FLOAT_TYPE = new Type(FLOAT);
/**
* The <tt>long</tt> type.
*/
public final static Type LONG_TYPE = new Type(LONG);
/**
* The <tt>double</tt> type.
*/
public final static Type DOUBLE_TYPE = new Type(DOUBLE);
// ------------------------------------------------- ------------------
// Fields
// ------------------------------------------------- ------------------
/**
* The sort of this Java type.
*/
private final int sort;
/**
* A buffer containing the descriptor of this Java type. This f ield
* is only used for reference types.
*/
private char[] buf;
/**
* The offset of the descriptor of this Java type in {@link #buf buf}.
* This field is only used for reference types.
*/
private int off;
/**
* The length of the descriptor of this Java type.
*/
7.20. TYPE.JAVA 397
private int len;
// ------------------------------------------------- ------------------
// Constructors
// ------------------------------------------------- ------------------
/**
* Constructs a primitive type.
*
* @param sort the sort of the primitive type to be constructed .
*/
private Type(final int sort){
this.sort = sort;
this.len = 1;
}
/**
* Constructs a reference type.
*
* @param sort the sort of the reference type to be constructed .
* @param buf a buffer containing the descriptor of the previo us type.
* @param off the offset of this descriptor in the previous buf fer.
* @param len the length of this descriptor.
*/
private Type(final int sort,
final char[] buf,
final int off,
final int len){
this.sort = sort;
this.buf = buf;
this.off = off;
this.len = len;
}
/**
* Returns the Java type corresponding to the given type descr iptor.
*
* @param typeDescriptor a type descriptor.
* @return the Java type corresponding to the given type descr iptor.
*/
public static Type getType(final String typeDescriptor){
return getType(typeDescriptor.toCharArray(), 0);
}
/**
* Returns the Java type corresponding to the given class.
*
* @param c a class.
* @return the Java type corresponding to the given class.
*/
398 CHAPTER 7. JVM/CLOJURE/ASM/
public static Type getType(final Class c){
if(c.isPrimitive())
{
if(c == Integer.TYPE)
{
return INT_TYPE;
}
else if(c == Void.TYPE)
{
return VOID_TYPE;
}
else if(c == Boolean.TYPE)
{
return BOOLEAN_TYPE;
}
else if(c == Byte.TYPE)
{
return BYTE_TYPE;
}
else if(c == Character.TYPE)
{
return CHAR_TYPE;
}
else if(c == Short.TYPE)
{
return SHORT_TYPE;
}
else if(c == Double.TYPE)
{
return DOUBLE_TYPE;
}
else if(c == Float.TYPE)
{
return FLOAT_TYPE;
}
else /* if (c == Long.TYPE) */
{
return LONG_TYPE;
}
}
else
{
return getType(getDescriptor(c));
}
}
/**
* Returns the {@link Type#OBJECT} type for the given interna l class
* name. This is a shortcut method for
* <code>Type.getType("L"+name+";")</code>.
7.20. TYPE.JAVA 399
* <i>Note that opposed to {@link Type#getType(String)}, th is method
* takes internal class names and not class descriptor.</i>
*
* @param name an internal class name.
* @return the the {@link Type#OBJECT} type for the given clas s name.
*/
public static Type getObjectType(String name){
int l = name.length();
char[] buf = new char[l + 2];
buf[0] = ’L’;
buf[l + 1] = ’;’;
name.getChars(0, l, buf, 1);
return new Type(OBJECT, buf, 0, l + 2);
}
/**
* Returns the Java types corresponding to the argument types of the
* given method descriptor.
*
* @param methodDescriptor a method descriptor.
* @return the Java types corresponding to the argument types of the
* given method descriptor.
*/
public static Type[] getArgumentTypes(final String metho dDescriptor){
char[] buf = methodDescriptor.toCharArray();
int off = 1;
int size = 0;
while(true)
{
char car = buf[off++];
if(car == ’)’)
{
break;
}
else if(car == ’L’)
{
while(buf[off++] != ’;’)
{
}
++size;
}
else if(car != ’[’)
{
++size;
}
}
Type[] args = new Type[size];
off = 1;
size = 0;
while(buf[off] != ’)’)
400 CHAPTER 7. JVM/CLOJURE/ASM/
{
args[size] = getType(buf, off);
off += args[size].len;
size += 1;
}
return args;
}
/**
* Returns the Java types corresponding to the argument types of the
* given method.
*
* @param method a method.
* @return the Java types corresponding to the argument types of the
* given method.
*/
public static Type[] getArgumentTypes(final Method metho d){
Class[] classes = method.getParameterTypes();
Type[] types = new Type[classes.length];
for(int i = classes.length - 1; i >= 0; --i)
{
types[i] = getType(classes[i]);
}
return types;
}
/**
* Returns the Java type corresponding to the return type of th e given
* method descriptor.
*
* @param methodDescriptor a method descriptor.
* @return the Java type corresponding to the return type of th e given
* method descriptor.
*/
public static Type getReturnType(final String methodDesc riptor){
char[] buf = methodDescriptor.toCharArray();
return getType(buf, methodDescriptor.indexOf(’)’) + 1);
}
/**
* Returns the Java type corresponding to the return type of th e given
* method.
*
* @param method a method.
* @return the Java type corresponding to the return type of th e given
* method.
*/
public static Type getReturnType(final Method method){
return getType(method.getReturnType());
}
7.20. TYPE.JAVA 401
/**
* Returns the Java type corresponding to the given type descr iptor.
*
* @param buf a buffer containing a type descriptor.
* @param off the offset of this descriptor in the previous buf fer.
* @return the Java type corresponding to the given type descr iptor.
*/
private static Type getType(final char[] buf, final int off ){
int len;
switch(buf[off])
{
case’V’:
return VOID_TYPE;
case’Z’:
return BOOLEAN_TYPE;
case’C’:
return CHAR_TYPE;
case’B’:
return BYTE_TYPE;
case’S’:
return SHORT_TYPE;
case’I’:
return INT_TYPE;
case’F’:
return FLOAT_TYPE;
case’J’:
return LONG_TYPE;
case’D’:
return DOUBLE_TYPE;
case’[’:
len = 1;
while(buf[off + len] == ’[’)
{
++len;
}
if(buf[off + len] == ’L’)
{
++len;
while(buf[off + len] != ’;’)
{
++len;
}
}
return new Type(ARRAY, buf, off, len + 1);
// case ’L’:
default:
len = 1;
while(buf[off + len] != ’;’)
{
402 CHAPTER 7. JVM/CLOJURE/ASM/
++len;
}
return new Type(OBJECT, buf, off, len + 1);
}
}
// ------------------------------------------------- ------------------
// Accessors
// ------------------------------------------------- ------------------
/**
* Returns the sort of this Java type.
*
* @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},
* {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHOR T},
* {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG} ,
* {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or
* {@link #OBJECT OBJECT}.
*/
public int getSort(){
return sort;
}
/**
* Returns the number of dimensions of this array type. This me thod
* should only be used for an array type.
*
* @return the number of dimensions of this array type.
*/
public int getDimensions(){
int i = 1;
while(buf[off + i] == ’[’)
{
++i;
}
return i;
}
/**
* Returns the type of the elements of this array type. This met hod
* should only be used for an array type.
*
* @return Returns the type of the elements of this array type.
*/
public Type getElementType(){
return getType(buf, off + getDimensions());
}
/**
* Returns the name of the class corresponding to this type.
7.20. TYPE.JAVA 403
*
* @return the fully qualified name of the class correspondin g to
* this type.
*/
public String getClassName(){
switch(sort)
{
case VOID:
return "void";
case BOOLEAN:
return "boolean";
case CHAR:
return "char";
case BYTE:
return "byte";
case SHORT:
return "short";
case INT:
return "int";
case FLOAT:
return "float";
case LONG:
return "long";
case DOUBLE:
return "double";
case ARRAY:
StringBuffer b =
new StringBuffer(getElementType().getClassName());
for(int i = getDimensions(); i > 0; --i)
{
b.append("[]");
}
return b.toString();
// case OBJECT:
default:
return new String(buf, off + 1, len - 2).replace(’/’, ’.’);
}
}
/**
* Returns the internal name of the class corresponding to thi s object
* type. The internal name of a class is its fully qualified nam e,
* where ’.’ are replaced by ’/’. This method should only be use d for
* an object type.
*
* @return the internal name of the class corresponding to thi s object
* type.
*/
public String getInternalName(){
return new String(buf, off + 1, len - 2);
404 CHAPTER 7. JVM/CLOJURE/ASM/
}
// ------------------------------------------------- ------------------
// Conversion to type descriptors
// ------------------------------------------------- ------------------
/**
* Returns the descriptor corresponding to this Java type.
*
* @return the descriptor corresponding to this Java type.
*/
public String getDescriptor(){
StringBuffer buf = new StringBuffer();
getDescriptor(buf);
return buf.toString();
}
/**
* Returns the descriptor corresponding to the given argumen t and return
* types.
*
* @param returnType the return type of the method.
* @param argumentTypes the argument types of the method.
* @return the descriptor corresponding to the given argumen t and return
* types.
*/
public static String getMethodDescriptor(
final Type returnType,
final Type[] argumentTypes){
StringBuffer buf = new StringBuffer();
buf.append(’(’);
for(int i = 0; i < argumentTypes.length; ++i)
{
argumentTypes[i].getDescriptor(buf);
}
buf.append(’)’);
returnType.getDescriptor(buf);
return buf.toString();
}
/**
* Appends the descriptor corresponding to this Java type to t he given
* string buffer.
*
* @param buf the string buffer to which the descriptor must be appended.
*/
private void getDescriptor(final StringBuffer buf){
switch(sort)
{
case VOID:
7.20. TYPE.JAVA 405
buf.append(’V’);
return;
case BOOLEAN:
buf.append(’Z’);
return;
case CHAR:
buf.append(’C’);
return;
case BYTE:
buf.append(’B’);
return;
case SHORT:
buf.append(’S’);
return;
case INT:
buf.append(’I’);
return;
case FLOAT:
buf.append(’F’);
return;
case LONG:
buf.append(’J’);
return;
case DOUBLE:
buf.append(’D’);
return;
// case ARRAY:
// case OBJECT:
default:
buf.append(this.buf, off, len);
}
}
// ------------------------------------------------- ------------------
// Direct conversion from classes to type descriptors,
// without intermediate Type objects
// ------------------------------------------------- ------------------
/**
* Returns the internal name of the given class. The internal n ame of a
* class is its fully qualified name, where ’.’ are replaced by ’/’.
*
* @param c an object class.
* @return the internal name of the given class.
*/
public static String getInternalName(final Class c){
return c.getName().replace(’.’, ’/’);
}
/**
406 CHAPTER 7. JVM/CLOJURE/ASM/
* Returns the descriptor corresponding to the given Java typ e.
*
* @param c an object class, a primitive class or an array class .
* @return the descriptor corresponding to the given class.
*/
public static String getDescriptor(final Class c){
StringBuffer buf = new StringBuffer();
getDescriptor(buf, c);
return buf.toString();
}
/**
* Returns the descriptor corresponding to the given constru ctor.
*
* @param c a {@link Constructor Constructor} object.
* @return the descriptor of the given constructor.
*/
public static String getConstructorDescriptor(final Con structor c){
Class[] parameters = c.getParameterTypes();
StringBuffer buf = new StringBuffer();
buf.append(’(’);
for(int i = 0; i < parameters.length; ++i)
{
getDescriptor(buf, parameters[i]);
}
return buf.append(")V").toString();
}
/**
* Returns the descriptor corresponding to the given method.
*
* @param m a {@link Method Method} object.
* @return the descriptor of the given method.
*/
public static String getMethodDescriptor(final Method m) {
Class[] parameters = m.getParameterTypes();
StringBuffer buf = new StringBuffer();
buf.append(’(’);
for(int i = 0; i < parameters.length; ++i)
{
getDescriptor(buf, parameters[i]);
}
buf.append(’)’);
getDescriptor(buf, m.getReturnType());
return buf.toString();
}
/**
* Appends the descriptor of the given class to the given strin g buffer.
*
7.20. TYPE.JAVA 407
* @param buf the string buffer to which the descriptor must be appended.
* @param c the class whose descriptor must be computed.
*/
private static void getDescriptor(final StringBuffer buf , final Class c){
Class d = c;
while(true)
{
if(d.isPrimitive())
{
char car;
if(d == Integer.TYPE)
{
car = ’I’;
}
else if(d == Void.TYPE)
{
car = ’V’;
}
else if(d == Boolean.TYPE)
{
car = ’Z’;
}
else if(d == Byte.TYPE)
{
car = ’B’;
}
else if(d == Character.TYPE)
{
car = ’C’;
}
else if(d == Short.TYPE)
{
car = ’S’;
}
else if(d == Double.TYPE)
{
car = ’D’;
}
else if(d == Float.TYPE)
{
car = ’F’;
}
else /* if (d == Long.TYPE) */
{
car = ’J’;
}
buf.append(car);
return;
}
else if(d.isArray())
408 CHAPTER 7. JVM/CLOJURE/ASM/
{
buf.append(’[’);
d = d.getComponentType();
}
else
{
buf.append(’L’);
String name = d.getName();
int len = name.length();
for(int i = 0; i < len; ++i)
{
char car = name.charAt(i);
buf.append(car == ’.’ ? ’/’ : car);
}
buf.append(’;’);
return;
}
}
}
// ------------------------------------------------- ------------------
// Corresponding size and opcodes
// ------------------------------------------------- ------------------
/**
* Returns the size of values of this type.
*
* @return the size of values of this type, i.e., 2 for <tt>long </tt> and
* <tt>double</tt>, and 1 otherwise.
*/
public int getSize(){
return sort == LONG || sort == DOUBLE ? 2 : 1;
}
/**
* Returns a JVM instruction opcode adapted to this Java type.
*
* @param opcode a JVM instruction opcode. This opcode must be one of
* ILOAD, ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL,
* IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR,
* IXOR and IRETURN.
* @return an opcode that is similar to the given opcode, but ad apted to
* this Java type. For example, if this type is <tt>float</tt>
* and <tt>opcode</tt> is IRETURN, this method returns FRETU RN.
*/
public int getOpcode(final int opcode){
if(opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE)
{
switch(sort)
{
7.20. TYPE.JAVA 409
case BOOLEAN:
case BYTE:
return opcode + 5;
case CHAR:
return opcode + 6;
case SHORT:
return opcode + 7;
case INT:
return opcode;
case FLOAT:
return opcode + 2;
case LONG:
return opcode + 1;
case DOUBLE:
return opcode + 3;
// case ARRAY:
// case OBJECT:
default:
return opcode + 4;
}
}
else
{
switch(sort)
{
case VOID:
return opcode + 5;
case BOOLEAN:
case CHAR:
case BYTE:
case SHORT:
case INT:
return opcode;
case FLOAT:
return opcode + 2;
case LONG:
return opcode + 1;
case DOUBLE:
return opcode + 3;
// case ARRAY:
// case OBJECT:
default:
return opcode + 4;
}
}
}
// ------------------------------------------------- ------------------
// Equals, hashCode and toString
// ------------------------------------------------- ------------------
410 CHAPTER 7. JVM/CLOJURE/ASM/
/**
* Tests if the given object is equal to this type.
*
* @param o the object to be compared to this type.
* @return <tt>true</tt> if the given object is equal to this t ype.
*/
public boolean equals(final Object o){
if(this == o)
{
return true;
}
if(!(o instanceof Type))
{
return false;
}
Type t = (Type) o;
if(sort != t.sort)
{
return false;
}
if(sort == Type.OBJECT || sort == Type.ARRAY)
{
if(len != t.len)
{
return false;
}
for(int i = off, j = t.off, end = i + len; i < end; i++, j++)
{
if(buf[i] != t.buf[j])
{
return false;
}
}
}
return true;
}
/**
* Returns a hash code value for this type.
*
* @return a hash code value for this type.
*/
public int hashCode(){
int hc = 13 * sort;
if(sort == Type.OBJECT || sort == Type.ARRAY)
{
for(int i = off, end = i + len; i < end; i++)
{
hc = 17 * (hc + buf[i]);
7.20. TYPE.JAVA 411
}
}
return hc;
}
/**
* Returns a string representation of this type.
*
* @return the descriptor of this type.
*/
public String toString(){
return getDescriptor();
}
}
———-
412 CHAPTER 7. JVM/CLOJURE/ASM/
Chapter 8
jvm/clojure/asm/commons
8.1 AdviceAdapter.java
(Opcodes [387]) (GeneratorAdapter [453])
— AdviceAdapter.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import java.util.ArrayList;
import java.util.HashMap;
import clojure.asm.Label;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
import clojure.asm.Type;
/**
* A {@link clojure.asm.MethodAdapter} to insert before, af ter and around
* advices in methods and constructors. <p> The behavior for c onstructors
* is like this: <ol>
* <p/>
* <li>as long as the INVOKESPECIAL for the object initializa tion has
* not been reached, every bytecode instruction is dispatche d in the
* ctor code visitor</li>
* <p/>
* <li>when this one is reached, it is only added in the ctor cod e
* visitor and a JP invoke is added</li>
* <p/>
* <li>after that, only the other code visitor receives the
* instructions</li>
* <p/>
* </ol>
413
414 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
*
* @author Eugene Kuleshov
* @author Eric Bruneton
*/
public abstract class AdviceAdapter
extends GeneratorAdapter implements Opcodes{
private static final Object THIS = new Object();
private static final Object OTHER = new Object();
protected int methodAccess;
protected String methodDesc;
private boolean constructor;
private boolean superInitialized;
private ArrayList stackFrame;
private HashMap branches;
/**
* Creates a new {@link AdviceAdapter}.
*
* @param mv the method visitor to which this adapter delegate s
* calls.
* @param access the method’s access flags (see {@link Opcode s}).
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type Type} ).
*/
public AdviceAdapter(
final MethodVisitor mv,
final int access,
final String name,
final String desc){
super(mv, access, name, desc);
methodAccess = access;
methodDesc = desc;
constructor = "<init>".equals(name);
}
public void visitCode(){
mv.visitCode();
if(!constructor)
{
superInitialized = true;
onMethodEnter();
}
else
{
stackFrame = new ArrayList();
branches = new HashMap();
}
8.1. ADVICEADAPTER.JAVA 415
}
public void visitLabel(final Label label){
mv.visitLabel(label);
if(constructor && branches != null)
{
ArrayList frame = (ArrayList) branches.get(label);
if(frame != null)
{
stackFrame = frame;
branches.remove(label);
}
}
}
public void visitInsn(final int opcode){
if(constructor)
{
switch(opcode)
{
case RETURN: // empty stack
onMethodExit(opcode);
break;
case IRETURN: // 1 before n/a after
case FRETURN: // 1 before n/a after
case ARETURN: // 1 before n/a after
case ATHROW: // 1 before n/a after
popValue();
popValue();
onMethodExit(opcode);
break;
case LRETURN: // 2 before n/a after
case DRETURN: // 2 before n/a after
popValue();
popValue();
onMethodExit(opcode);
break;
case NOP:
case LALOAD: // remove 2 add 2
case DALOAD: // remove 2 add 2
case LNEG:
case DNEG:
case FNEG:
case INEG:
case L2D:
case D2L:
416 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
case F2I:
case I2B:
case I2C:
case I2S:
case I2F:
case Opcodes.ARRAYLENGTH:
break;
case ACONST_NULL:
case ICONST_M1:
case ICONST_0:
case ICONST_1:
case ICONST_2:
case ICONST_3:
case ICONST_4:
case ICONST_5:
case FCONST_0:
case FCONST_1:
case FCONST_2:
case F2L: // 1 before 2 after
case F2D:
case I2L:
case I2D:
pushValue(OTHER);
break;
case LCONST_0:
case LCONST_1:
case DCONST_0:
case DCONST_1:
pushValue(OTHER);
pushValue(OTHER);
break;
case IALOAD: // remove 2 add 1
case FALOAD: // remove 2 add 1
case AALOAD: // remove 2 add 1
case BALOAD: // remove 2 add 1
case CALOAD: // remove 2 add 1
case SALOAD: // remove 2 add 1
case POP:
case IADD:
case FADD:
case ISUB:
case LSHL: // 3 before 2 after
case LSHR: // 3 before 2 after
case LUSHR: // 3 before 2 after
case L2I: // 2 before 1 after
case L2F: // 2 before 1 after
case D2I: // 2 before 1 after
8.1. ADVICEADAPTER.JAVA 417
case D2F: // 2 before 1 after
case FSUB:
case FMUL:
case FDIV:
case FREM:
case FCMPL: // 2 before 1 after
case FCMPG: // 2 before 1 after
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
case IAND:
case IOR:
case IXOR:
case MONITORENTER:
case MONITOREXIT:
popValue();
break;
case POP2:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LADD:
case LAND:
case LOR:
case LXOR:
case DADD:
case DMUL:
case DSUB:
case DDIV:
case DREM:
popValue();
popValue();
break;
case IASTORE:
case FASTORE:
case AASTORE:
case BASTORE:
case CASTORE:
case SASTORE:
case LCMP: // 4 before 1 after
case DCMPL:
case DCMPG:
popValue();
popValue();
418 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
popValue();
break;
case LASTORE:
case DASTORE:
popValue();
popValue();
popValue();
popValue();
break;
case DUP:
pushValue(peekValue());
break;
case DUP_X1:
// TODO optimize this
{
Object o1 = popValue();
Object o2 = popValue();
pushValue(o1);
pushValue(o2);
pushValue(o1);
}
break;
case DUP_X2:
// TODO optimize this
{
Object o1 = popValue();
Object o2 = popValue();
Object o3 = popValue();
pushValue(o1);
pushValue(o3);
pushValue(o2);
pushValue(o1);
}
break;
case DUP2:
// TODO optimize this
{
Object o1 = popValue();
Object o2 = popValue();
pushValue(o2);
pushValue(o1);
pushValue(o2);
pushValue(o1);
}
break;
8.1. ADVICEADAPTER.JAVA 419
case DUP2_X1:
// TODO optimize this
{
Object o1 = popValue();
Object o2 = popValue();
Object o3 = popValue();
pushValue(o2);
pushValue(o1);
pushValue(o3);
pushValue(o2);
pushValue(o1);
}
break;
case DUP2_X2:
// TODO optimize this
{
Object o1 = popValue();
Object o2 = popValue();
Object o3 = popValue();
Object o4 = popValue();
pushValue(o2);
pushValue(o1);
pushValue(o4);
pushValue(o3);
pushValue(o2);
pushValue(o1);
}
break;
case SWAP:
{
Object o1 = popValue();
Object o2 = popValue();
pushValue(o1);
pushValue(o2);
}
break;
}
}
else
{
switch(opcode)
{
case RETURN:
case IRETURN:
case FRETURN:
case ARETURN:
case LRETURN:
420 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
case DRETURN:
case ATHROW:
onMethodExit(opcode);
break;
}
}
mv.visitInsn(opcode);
}
public void visitVarInsn(final int opcode, final int var){
super.visitVarInsn(opcode, var);
if(constructor)
{
switch(opcode)
{
case ILOAD:
case FLOAD:
pushValue(OTHER);
break;
case LLOAD:
case DLOAD:
pushValue(OTHER);
pushValue(OTHER);
break;
case ALOAD:
pushValue(var == 0 ? THIS : OTHER);
break;
case ASTORE:
case ISTORE:
case FSTORE:
popValue();
break;
case LSTORE:
case DSTORE:
popValue();
popValue();
break;
}
}
}
public void visitFieldInsn(
final int opcode,
final String owner,
final String name,
final String desc){
mv.visitFieldInsn(opcode, owner, name, desc);
if(constructor)
8.1. ADVICEADAPTER.JAVA 421
{
char c = desc.charAt(0);
boolean longOrDouble = c == ’J’ || c == ’D’;
switch(opcode)
{
case GETSTATIC:
pushValue(OTHER);
if(longOrDouble)
{
pushValue(OTHER);
}
break;
case PUTSTATIC:
popValue();
if(longOrDouble)
{
popValue();
}
break;
case PUTFIELD:
popValue();
if(longOrDouble)
{
popValue();
popValue();
}
break;
// case GETFIELD:
default:
if(longOrDouble)
{
pushValue(OTHER);
}
}
}
}
public void visitIntInsn(final int opcode, final int opera nd){
mv.visitIntInsn(opcode, operand);
if(constructor && opcode != NEWARRAY)
{
pushValue(OTHER);
}
}
public void visitLdcInsn(final Object cst){
mv.visitLdcInsn(cst);
if(constructor)
422 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
{
pushValue(OTHER);
if(cst instanceof Double || cst instanceof Long)
{
pushValue(OTHER);
}
}
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
mv.visitMultiANewArrayInsn(desc, dims);
if(constructor)
{
for(int i = 0; i < dims; i++)
{
popValue();
}
pushValue(OTHER);
}
}
public void visitTypeInsn(final int opcode, final String n ame){
mv.visitTypeInsn(opcode, name);
// ANEWARRAY, CHECKCAST or INSTANCEOF don’t change stack
if(constructor && opcode == NEW)
{
pushValue(OTHER);
}
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
mv.visitMethodInsn(opcode, owner, name, desc);
if(constructor)
{
Type[] types = Type.getArgumentTypes(desc);
for(int i = 0; i < types.length; i++)
{
popValue();
if(types[i].getSize() == 2)
{
popValue();
}
}
8.1. ADVICEADAPTER.JAVA 423
switch(opcode)
{
// case INVOKESTATIC:
// break;
case INVOKEINTERFACE:
case INVOKEVIRTUAL:
popValue(); // objectref
break;
case INVOKESPECIAL:
Object type = popValue(); // objectref
if(type == THIS && !superInitialized)
{
onMethodEnter();
superInitialized = true;
// once super has been initialized it is no longer
// necessary to keep track of stack state
constructor = false;
}
break;
}
Type returnType = Type.getReturnType(desc);
if(returnType != Type.VOID_TYPE)
{
pushValue(OTHER);
if(returnType.getSize() == 2)
{
pushValue(OTHER);
}
}
}
}
public void visitJumpInsn(final int opcode, final Label la bel){
mv.visitJumpInsn(opcode, label);
if(constructor)
{
switch(opcode)
{
case IFEQ:
case IFNE:
case IFLT:
case IFGE:
case IFGT:
case IFLE:
case IFNULL:
case IFNONNULL:
424 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
popValue();
break;
case IF_ICMPEQ:
case IF_ICMPNE:
case IF_ICMPLT:
case IF_ICMPGE:
case IF_ICMPGT:
case IF_ICMPLE:
case IF_ACMPEQ:
case IF_ACMPNE:
popValue();
popValue();
break;
case JSR:
pushValue(OTHER);
break;
}
addBranch(label);
}
}
public void visitLookupSwitchInsn(
final Label dflt,
final int[] keys,
final Label[] labels){
mv.visitLookupSwitchInsn(dflt, keys, labels);
if(constructor)
{
popValue();
addBranches(dflt, labels);
}
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label[] labels){
mv.visitTableSwitchInsn(min, max, dflt, labels);
if(constructor)
{
popValue();
addBranches(dflt, labels);
}
}
8.1. ADVICEADAPTER.JAVA 425
private void addBranches(final Label dflt, final Label[] l abels){
addBranch(dflt);
for(int i = 0; i < labels.length; i++)
{
addBranch(labels[i]);
}
}
private void addBranch(final Label label){
if(branches.containsKey(label))
{
return;
}
ArrayList frame = new ArrayList();
frame.addAll(stackFrame);
branches.put(label, frame);
}
private Object popValue(){
return stackFrame.remove(stackFrame.size() - 1);
}
private Object peekValue(){
return stackFrame.get(stackFrame.size() - 1);
}
private void pushValue(final Object o){
stackFrame.add(o);
}
/**
* Called at the beginning of the method or after super class cl ass
* call in the constructor. <br><br>
* <p/>
* <i>Custom code can use or change all the local variables, bu t
* should not change state of the stack.</i>
*/
protected abstract void onMethodEnter();
/**
* Called before explicit exit from the method using either re turn
* or throw. Top element on the stack contains the return value or
* exception instance.
* For example:
* <p/>
* <pre>
* public void onMethodExit(int opcode) {
* if(opcode==RETURN) {
* visitInsn(ACONST_NULL);
* } else if(opcode==ARETURN || opcode==ATHROW) {
426 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* dup();
* } else {
* if(opcode==LRETURN || opcode==DRETURN) {
* dup2();
* } else {
* dup();
* }
* box(Type.getReturnType(this.methodDesc));
* }
* visitIntInsn(SIPUSH, opcode);
* visitMethodInsn(INVOKESTATIC, owner, "onExit",
"(Ljava/lang/Object;I)V");
* }
* <p/>
* // an actual call back method
* public static void onExit(int opcode, Object param) {
* ...
* </pre>
* <p/>
* <br><br>
* <p/>
* <i>Custom code can use or change all the local variables, bu t should
* not change state of the stack.</i>
*
* @param opcode one of the RETURN, IRETURN, FRETURN, ARETURN , LRETURN,
* DRETURN or ATHROW
*/
protected abstract void onMethodExit(int opcode);
// TODO onException, onMethodCall
}
———-
8.2 AnalyzerAdapter.java
(MethodAdapter [314])
— AnalyzerAdapter.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
8.2. ANALYZERADAPTER.JAVA 427
import clojure.asm.Label;
import clojure.asm.MethodAdapter;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
import clojure.asm.Type;
/**
* A {@link MethodAdapter} that keeps track of stack map frame changes
* between
* {@link #visitFrame(int,int,Object[],int,Object[]) vi sitFrame} calls.
* This adapter must be used with the
* {@link clojure.asm.ClassReader#EXPAND_FRAMES} option . Each
* visit<i>XXX</i> instruction delegates to the next visito r in the
* chain, if any, and then simulates the effect of this instruc tion
* on the stack map frame, represented by {@link #locals} and
* {@link #stack}. The next visitor in the chain can get the sta te
* of the stack map frame <i>before</i> each instruction by re ading
* the value of these fields in its visit<i>XXX</i> methods (t his
* requires a reference to the AnalyzerAdapter that is before it
* in the chain).
*
* @author Eric Bruneton
*/
public class AnalyzerAdapter extends MethodAdapter{
/**
* <code>List</code> of the local variable slots for current execution
* frame. Primitive types are represented by {@link Opcodes# TOP},
* {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
* {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
* {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented
* by a two elements, the second one being TOP). Reference type s are
* represented by String objects (representing internal nam es, or type
* descriptors for array types), and uninitialized types by L abel
* objects (this label designates the NEW instruction that cr eated
* this uninitialized value). This field is <tt>null</tt> fo r
* unreacheable instructions.
*/
public List locals;
/**
* <code>List</code> of the operand stack slots for current e xecution
* frame. Primitive types are represented by {@link Opcodes# TOP},
* {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
* {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
* {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented
* by a two elements, the second one being TOP). Reference type s are
* represented by String objects (representing internal nam es, or type
* descriptors for array types), and uninitialized types by L abel
* objects (this label designates the NEW instruction that cr eated this
428 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* uninitialized value). This field is <tt>null</tt> for unr eacheable
* instructions.
*/
public List stack;
/**
* The labels that designate the next instruction to be visite d. May be
* <tt>null</tt>.
*/
private List labels;
/**
* Information about uninitialized types in the current exec ution frame.
* This map associates internal names to Label objects. Each l abel
* designates a NEW instruction that created the currently un initialized
* types, and the associated internal name represents the NEW operand,
* i.e. the final, initialized type value.
*/
private Map uninitializedTypes;
/**
* The maximum stack size of this method.
*/
private int maxStack;
/**
* The maximum number of local variables of this method.
*/
private int maxLocals;
/**
* Creates a new {@link AnalyzerAdapter}.
*
* @param owner the owner’s class name.
* @param access the method’s access flags (see {@link Opcode s}).
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type Type} ).
* @param mv the method visitor to which this adapter delegate s
* calls. May be <tt>null</tt>.
*/
public AnalyzerAdapter(
final String owner,
final int access,
final String name,
final String desc,
final MethodVisitor mv){
super(mv);
locals = new ArrayList();
stack = new ArrayList();
uninitializedTypes = new HashMap();
8.2. ANALYZERADAPTER.JAVA 429
if((access & Opcodes.ACC_STATIC) == 0)
{
if(name.equals("<init>"))
{
locals.add(Opcodes.UNINITIALIZED_THIS);
}
else
{
locals.add(owner);
}
}
Type[] types = Type.getArgumentTypes(desc);
for(int i = 0; i < types.length; ++i)
{
Type type = types[i];
switch(type.getSort())
{
case Type.BOOLEAN:
case Type.CHAR:
case Type.BYTE:
case Type.SHORT:
case Type.INT:
locals.add(Opcodes.INTEGER);
break;
case Type.FLOAT:
locals.add(Opcodes.FLOAT);
break;
case Type.LONG:
locals.add(Opcodes.LONG);
locals.add(Opcodes.TOP);
break;
case Type.DOUBLE:
locals.add(Opcodes.DOUBLE);
locals.add(Opcodes.TOP);
break;
case Type.ARRAY:
locals.add(types[i].getDescriptor());
break;
// case Type.OBJECT:
default:
locals.add(types[i].getInternalName());
}
}
}
public void visitFrame(
final int type,
final int nLocal,
final Object[] local,
430 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
final int nStack,
final Object[] stack){
if(type != Opcodes.F_NEW)
{ // uncompressed frame
throw new IllegalStateException(
"ClassReader.accept() should be called with EXPAND_FRAME S flag");
}
if(mv != null)
{
mv.visitFrame(type, nLocal, local, nStack, stack);
}
if(this.locals != null)
{
this.locals.clear();
this.stack.clear();
}
else
{
this.locals = new ArrayList();
this.stack = new ArrayList();
}
visitFrameTypes(nLocal, local, this.locals);
visitFrameTypes(nStack, stack, this.stack);
maxStack = Math.max(maxStack, this.stack.size());
}
private void visitFrameTypes(
final int n,
final Object[] types,
final List result){
for(int i = 0; i < n; ++i)
{
Object type = types[i];
result.add(type);
if(type == Opcodes.LONG || type == Opcodes.DOUBLE)
{
result.add(Opcodes.TOP);
}
}
}
public void visitInsn(final int opcode){
if(mv != null)
{
mv.visitInsn(opcode);
}
execute(opcode, 0, null);
if((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN )
8.2. ANALYZERADAPTER.JAVA 431
|| opcode == Opcodes.ATHROW)
{
this.locals = null;
this.stack = null;
}
}
public void visitIntInsn(final int opcode, final int opera nd){
if(mv != null)
{
mv.visitIntInsn(opcode, operand);
}
execute(opcode, operand, null);
}
public void visitVarInsn(final int opcode, final int var){
if(mv != null)
{
mv.visitVarInsn(opcode, var);
}
execute(opcode, var, null);
}
public void visitTypeInsn(final int opcode, final String d esc){
if(opcode == Opcodes.NEW)
{
if(labels == null)
{
Label l = new Label();
labels = new ArrayList(3);
labels.add(l);
if(mv != null)
{
mv.visitLabel(l);
}
}
for(int i = 0; i < labels.size(); ++i)
{
uninitializedTypes.put(labels.get(i), desc);
}
}
if(mv != null)
{
mv.visitTypeInsn(opcode, desc);
}
execute(opcode, 0, desc);
}
public void visitFieldInsn(
final int opcode,
432 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
final String owner,
final String name,
final String desc){
if(mv != null)
{
mv.visitFieldInsn(opcode, owner, name, desc);
}
execute(opcode, 0, desc);
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
if(mv != null)
{
mv.visitMethodInsn(opcode, owner, name, desc);
}
pop(desc);
if(opcode != Opcodes.INVOKESTATIC)
{
Object t = pop();
if(opcode == Opcodes.INVOKESPECIAL && name.charAt(0) == ’ <’)
{
Object u;
if(t == Opcodes.UNINITIALIZED_THIS)
{
u = owner;
}
else
{
u = uninitializedTypes.get(t);
}
for(int i = 0; i < locals.size(); ++i)
{
if(locals.get(i) == t)
{
locals.set(i, u);
}
}
for(int i = 0; i < stack.size(); ++i)
{
if(stack.get(i) == t)
{
stack.set(i, u);
}
}
}
}
8.2. ANALYZERADAPTER.JAVA 433
pushDesc(desc);
labels = null;
}
public void visitJumpInsn(final int opcode, final Label la bel){
if(mv != null)
{
mv.visitJumpInsn(opcode, label);
}
execute(opcode, 0, null);
if(opcode == Opcodes.GOTO)
{
this.locals = null;
this.stack = null;
}
}
public void visitLabel(final Label label){
if(mv != null)
{
mv.visitLabel(label);
}
if(labels == null)
{
labels = new ArrayList(3);
}
labels.add(label);
}
public void visitLdcInsn(final Object cst){
if(mv != null)
{
mv.visitLdcInsn(cst);
}
if(cst instanceof Integer)
{
push(Opcodes.INTEGER);
}
else if(cst instanceof Long)
{
push(Opcodes.LONG);
push(Opcodes.TOP);
}
else if(cst instanceof Float)
{
push(Opcodes.FLOAT);
}
else if(cst instanceof Double)
{
push(Opcodes.DOUBLE);
434 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
push(Opcodes.TOP);
}
else if(cst instanceof String)
{
push("java/lang/String");
}
else if(cst instanceof Type)
{
push("java/lang/Class");
}
else
{
throw new IllegalArgumentException();
}
labels = null;
}
public void visitIincInsn(final int var, final int increme nt){
if(mv != null)
{
mv.visitIincInsn(var, increment);
}
execute(Opcodes.IINC, var, null);
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label labels[]){
if(mv != null)
{
mv.visitTableSwitchInsn(min, max, dflt, labels);
}
execute(Opcodes.TABLESWITCH, 0, null);
this.locals = null;
this.stack = null;
}
public void visitLookupSwitchInsn(
final Label dflt,
final int keys[],
final Label labels[]){
if(mv != null)
{
mv.visitLookupSwitchInsn(dflt, keys, labels);
}
execute(Opcodes.LOOKUPSWITCH, 0, null);
this.locals = null;
this.stack = null;
8.2. ANALYZERADAPTER.JAVA 435
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
if(mv != null)
{
mv.visitMultiANewArrayInsn(desc, dims);
}
execute(Opcodes.MULTIANEWARRAY, dims, desc);
}
public void visitMaxs(final int maxStack, final int maxLoc als){
if(mv != null)
{
this.maxStack = Math.max(this.maxStack, maxStack);
this.maxLocals = Math.max(this.maxLocals, maxLocals);
mv.visitMaxs(this.maxStack, this.maxLocals);
}
}
// ------------------------------------------------- ------------------
private Object get(final int local){
maxLocals = Math.max(maxLocals, local);
return local < locals.size() ? locals.get(local) : Opcodes .TOP;
}
private void set(final int local, final Object type){
maxLocals = Math.max(maxLocals, local);
while(local >= locals.size())
{
locals.add(Opcodes.TOP);
}
locals.set(local, type);
}
private void push(final Object type){
stack.add(type);
maxStack = Math.max(maxStack, stack.size());
}
private void pushDesc(final String desc){
int index = desc.charAt(0) == ’(’ ? desc.indexOf(’)’) + 1 : 0;
switch(desc.charAt(index))
{
case’V’:
return;
case’Z’:
case’C’:
case’B’:
case’S’:
436 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
case’I’:
push(Opcodes.INTEGER);
return;
case’F’:
push(Opcodes.FLOAT);
return;
case’J’:
push(Opcodes.LONG);
push(Opcodes.TOP);
return;
case’D’:
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
return;
case’[’:
if(index == 0)
{
push(desc);
}
else
{
push(desc.substring(index, desc.length()));
}
break;
// case ’L’:
default:
if(index == 0)
{
push(desc.substring(1, desc.length() - 1));
}
else
{
push(desc.substring(index + 1, desc.length() - 1));
}
return;
}
}
private Object pop(){
return stack.remove(stack.size() - 1);
}
private void pop(final int n){
int size = stack.size();
int end = size - n;
for(int i = size - 1; i >= end; --i)
{
stack.remove(i);
}
}
8.2. ANALYZERADAPTER.JAVA 437
private void pop(final String desc){
char c = desc.charAt(0);
if(c == ’(’)
{
int n = 0;
Type[] types = Type.getArgumentTypes(desc);
for(int i = 0; i < types.length; ++i)
{
n += types[i].getSize();
}
pop(n);
}
else if(c == ’J’ || c == ’D’)
{
pop(2);
}
else
{
pop(1);
}
}
private void execute(final int opcode,
final int iarg,
final String sarg){
if(this.locals == null)
{
return;
}
Object t1, t2, t3, t4;
switch(opcode)
{
case Opcodes.NOP:
case Opcodes.INEG:
case Opcodes.LNEG:
case Opcodes.FNEG:
case Opcodes.DNEG:
case Opcodes.I2B:
case Opcodes.I2C:
case Opcodes.I2S:
case Opcodes.GOTO:
case Opcodes.RETURN:
break;
case Opcodes.ACONST_NULL:
push(Opcodes.NULL);
break;
case Opcodes.ICONST_M1:
case Opcodes.ICONST_0:
case Opcodes.ICONST_1:
438 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
case Opcodes.ICONST_2:
case Opcodes.ICONST_3:
case Opcodes.ICONST_4:
case Opcodes.ICONST_5:
case Opcodes.BIPUSH:
case Opcodes.SIPUSH:
push(Opcodes.INTEGER);
break;
case Opcodes.LCONST_0:
case Opcodes.LCONST_1:
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.FCONST_0:
case Opcodes.FCONST_1:
case Opcodes.FCONST_2:
push(Opcodes.FLOAT);
break;
case Opcodes.DCONST_0:
case Opcodes.DCONST_1:
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.ILOAD:
case Opcodes.FLOAD:
case Opcodes.ALOAD:
push(get(iarg));
break;
case Opcodes.LLOAD:
case Opcodes.DLOAD:
push(get(iarg));
push(Opcodes.TOP);
break;
case Opcodes.IALOAD:
case Opcodes.BALOAD:
case Opcodes.CALOAD:
case Opcodes.SALOAD:
pop(2);
push(Opcodes.INTEGER);
break;
case Opcodes.LALOAD:
case Opcodes.D2L:
pop(2);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.FALOAD:
pop(2);
push(Opcodes.FLOAT);
break;
8.2. ANALYZERADAPTER.JAVA 439
case Opcodes.DALOAD:
case Opcodes.L2D:
pop(2);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.AALOAD:
pop(1);
t1 = pop();
pushDesc(((String) t1).substring(1));
break;
case Opcodes.ISTORE:
case Opcodes.FSTORE:
case Opcodes.ASTORE:
t1 = pop();
set(iarg, t1);
if(iarg > 0)
{
t2 = get(iarg - 1);
if(t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE)
{
set(iarg - 1, Opcodes.TOP);
}
}
break;
case Opcodes.LSTORE:
case Opcodes.DSTORE:
pop(1);
t1 = pop();
set(iarg, t1);
set(iarg + 1, Opcodes.TOP);
if(iarg > 0)
{
t2 = get(iarg - 1);
if(t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE)
{
set(iarg - 1, Opcodes.TOP);
}
}
break;
case Opcodes.IASTORE:
case Opcodes.BASTORE:
case Opcodes.CASTORE:
case Opcodes.SASTORE:
case Opcodes.FASTORE:
case Opcodes.AASTORE:
pop(3);
break;
case Opcodes.LASTORE:
case Opcodes.DASTORE:
440 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
pop(4);
break;
case Opcodes.POP:
case Opcodes.IFEQ:
case Opcodes.IFNE:
case Opcodes.IFLT:
case Opcodes.IFGE:
case Opcodes.IFGT:
case Opcodes.IFLE:
case Opcodes.IRETURN:
case Opcodes.FRETURN:
case Opcodes.ARETURN:
case Opcodes.TABLESWITCH:
case Opcodes.LOOKUPSWITCH:
case Opcodes.ATHROW:
case Opcodes.MONITORENTER:
case Opcodes.MONITOREXIT:
case Opcodes.IFNULL:
case Opcodes.IFNONNULL:
pop(1);
break;
case Opcodes.POP2:
case Opcodes.IF_ICMPEQ:
case Opcodes.IF_ICMPNE:
case Opcodes.IF_ICMPLT:
case Opcodes.IF_ICMPGE:
case Opcodes.IF_ICMPGT:
case Opcodes.IF_ICMPLE:
case Opcodes.IF_ACMPEQ:
case Opcodes.IF_ACMPNE:
case Opcodes.LRETURN:
case Opcodes.DRETURN:
pop(2);
break;
case Opcodes.DUP:
t1 = pop();
push(t1);
push(t1);
break;
case Opcodes.DUP_X1:
t1 = pop();
t2 = pop();
push(t1);
push(t2);
push(t1);
break;
case Opcodes.DUP_X2:
t1 = pop();
t2 = pop();
t3 = pop();
8.2. ANALYZERADAPTER.JAVA 441
push(t1);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.DUP2:
t1 = pop();
t2 = pop();
push(t2);
push(t1);
push(t2);
push(t1);
break;
case Opcodes.DUP2_X1:
t1 = pop();
t2 = pop();
t3 = pop();
push(t2);
push(t1);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.DUP2_X2:
t1 = pop();
t2 = pop();
t3 = pop();
t4 = pop();
push(t2);
push(t1);
push(t4);
push(t3);
push(t2);
push(t1);
break;
case Opcodes.SWAP:
t1 = pop();
t2 = pop();
push(t1);
push(t2);
break;
case Opcodes.IADD:
case Opcodes.ISUB:
case Opcodes.IMUL:
case Opcodes.IDIV:
case Opcodes.IREM:
case Opcodes.IAND:
case Opcodes.IOR:
case Opcodes.IXOR:
case Opcodes.ISHL:
442 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
case Opcodes.ISHR:
case Opcodes.IUSHR:
case Opcodes.L2I:
case Opcodes.D2I:
case Opcodes.FCMPL:
case Opcodes.FCMPG:
pop(2);
push(Opcodes.INTEGER);
break;
case Opcodes.LADD:
case Opcodes.LSUB:
case Opcodes.LMUL:
case Opcodes.LDIV:
case Opcodes.LREM:
case Opcodes.LAND:
case Opcodes.LOR:
case Opcodes.LXOR:
pop(4);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.FADD:
case Opcodes.FSUB:
case Opcodes.FMUL:
case Opcodes.FDIV:
case Opcodes.FREM:
case Opcodes.L2F:
case Opcodes.D2F:
pop(2);
push(Opcodes.FLOAT);
break;
case Opcodes.DADD:
case Opcodes.DSUB:
case Opcodes.DMUL:
case Opcodes.DDIV:
case Opcodes.DREM:
pop(4);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.LSHL:
case Opcodes.LSHR:
case Opcodes.LUSHR:
pop(3);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.IINC:
set(iarg, Opcodes.INTEGER);
break;
8.2. ANALYZERADAPTER.JAVA 443
case Opcodes.I2L:
case Opcodes.F2L:
pop(1);
push(Opcodes.LONG);
push(Opcodes.TOP);
break;
case Opcodes.I2F:
pop(1);
push(Opcodes.FLOAT);
break;
case Opcodes.I2D:
case Opcodes.F2D:
pop(1);
push(Opcodes.DOUBLE);
push(Opcodes.TOP);
break;
case Opcodes.F2I:
case Opcodes.ARRAYLENGTH:
case Opcodes.INSTANCEOF:
pop(1);
push(Opcodes.INTEGER);
break;
case Opcodes.LCMP:
case Opcodes.DCMPL:
case Opcodes.DCMPG:
pop(4);
push(Opcodes.INTEGER);
break;
case Opcodes.JSR:
case Opcodes.RET:
throw new RuntimeException("JSR/RET are not supported");
case Opcodes.GETSTATIC:
pushDesc(sarg);
break;
case Opcodes.PUTSTATIC:
pop(sarg);
break;
case Opcodes.GETFIELD:
pop(1);
pushDesc(sarg);
break;
case Opcodes.PUTFIELD:
pop(sarg);
pop();
break;
case Opcodes.NEW:
push(labels.get(0));
break;
case Opcodes.NEWARRAY:
pop();
444 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
switch(iarg)
{
case Opcodes.T_BOOLEAN:
pushDesc("[Z");
break;
case Opcodes.T_CHAR:
pushDesc("[C");
break;
case Opcodes.T_BYTE:
pushDesc("[B");
break;
case Opcodes.T_SHORT:
pushDesc("[S");
break;
case Opcodes.T_INT:
pushDesc("[I");
break;
case Opcodes.T_FLOAT:
pushDesc("[F");
break;
case Opcodes.T_DOUBLE:
pushDesc("[D");
break;
// case Opcodes.T_LONG:
default:
pushDesc("[J");
break;
}
break;
case Opcodes.ANEWARRAY:
pop();
if(sarg.charAt(0) == ’[’)
{
pushDesc("[" + sarg);
}
else
{
pushDesc("[L" + sarg + ";");
}
break;
case Opcodes.CHECKCAST:
pop();
if(sarg.charAt(0) == ’[’)
{
pushDesc(sarg);
}
else
{
push(sarg);
}
8.3. CODESIZEEVALUATOR.JAVA 445
break;
// case Opcodes.MULTIANEWARRAY:
default:
pop(iarg);
pushDesc(sarg);
break;
}
labels = null;
}
}
———-
8.3 CodeSizeEvaluator.java
(MethodAdapter [314]) (Opcodes [387])
— CodeSizeEvaluator.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import clojure.asm.Label;
import clojure.asm.MethodAdapter;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
/**
* A {@link MethodAdapter} that can be used to approximate met hod size.
*
* @author Eugene Kuleshov
*/
public class CodeSizeEvaluator extends MethodAdapter imp lements Opcodes{
private int minSize;
private int maxSize;
public CodeSizeEvaluator(final MethodVisitor mv){
super(mv);
}
public int getMinSize(){
return this.minSize;
}
public int getMaxSize(){
return this.maxSize;
}
446 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
public void visitInsn(final int opcode){
minSize += 1;
maxSize += 1;
if(mv != null)
{
mv.visitInsn(opcode);
}
}
public void visitIntInsn(final int opcode, final int opera nd){
if(opcode == SIPUSH)
{
minSize += 3;
maxSize += 3;
}
else
{
minSize += 2;
maxSize += 2;
}
if(mv != null)
{
mv.visitIntInsn(opcode, operand);
}
}
public void visitVarInsn(final int opcode, final int var){
if(var < 4 && opcode != Opcodes.RET)
{
minSize += 1;
maxSize += 1;
}
else if(var >= 256)
{
minSize += 4;
maxSize += 4;
}
else
{
minSize += 2;
maxSize += 2;
}
if(mv != null)
{
mv.visitVarInsn(opcode, var);
}
}
public void visitTypeInsn(final int opcode, final String d esc){
8.3. CODESIZEEVALUATOR.JAVA 447
minSize += 3;
maxSize += 3;
if(mv != null)
{
mv.visitTypeInsn(opcode, desc);
}
}
public void visitFieldInsn(
final int opcode,
final String owner,
final String name,
final String desc){
minSize += 3;
maxSize += 3;
if(mv != null)
{
mv.visitFieldInsn(opcode, owner, name, desc);
}
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
if(opcode == INVOKEINTERFACE)
{
minSize += 5;
maxSize += 5;
}
else
{
minSize += 3;
maxSize += 3;
}
if(mv != null)
{
mv.visitMethodInsn(opcode, owner, name, desc);
}
}
public void visitJumpInsn(final int opcode, final Label la bel){
minSize += 3;
if(opcode == GOTO || opcode == JSR)
{
maxSize += 5;
}
else
{
448 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
maxSize += 8;
}
if(mv != null)
{
mv.visitJumpInsn(opcode, label);
}
}
public void visitLdcInsn(final Object cst){
if(cst instanceof Long || cst instanceof Double)
{
minSize += 3;
maxSize += 3;
}
else
{
minSize += 2;
maxSize += 3;
}
if(mv != null)
{
mv.visitLdcInsn(cst);
}
}
public void visitIincInsn(final int var, final int increme nt){
if(var > 255 || increment > 127 || increment < -128)
{
minSize += 6;
maxSize += 6;
}
else
{
minSize += 3;
maxSize += 3;
}
if(mv != null)
{
mv.visitIincInsn(var, increment);
}
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label[] labels){
minSize += 13 + labels.length * 4;
maxSize += 16 + labels.length * 4;
if(mv != null)
8.4. EMPTYVISITOR.JAVA 449
{
mv.visitTableSwitchInsn(min, max, dflt, labels);
}
}
public void visitLookupSwitchInsn(
final Label dflt,
final int[] keys,
final Label[] labels){
minSize += 9 + keys.length * 8;
maxSize += 12 + keys.length * 8;
if(mv != null)
{
mv.visitLookupSwitchInsn(dflt, keys, labels);
}
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
minSize += 4;
maxSize += 4;
if(mv != null)
{
mv.visitMultiANewArrayInsn(desc, dims);
}
}
}
———-
8.4 EmptyVisitor.java
(ClassVisitor [229]) (FieldVisitor [263]) (MethodVisitor [317]) (Annotat ionVis-
itor [163])
— EmptyVisitor.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import clojure.asm.AnnotationVisitor;
import clojure.asm.Attribute;
import clojure.asm.ClassVisitor;
import clojure.asm.FieldVisitor;
import clojure.asm.Label;
import clojure.asm.MethodVisitor;
/**
* An empty implementation of the ASM visitor interfaces.
*
450 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* @author Eric Bruneton
*/
public class EmptyVisitor implements
ClassVisitor,
FieldVisitor,
MethodVisitor,
AnnotationVisitor{
public void visit(
final int version,
final int access,
final String name,
final String signature,
final String superName,
final String[] interfaces){
}
public void visitSource(final String source, final String debug){
}
public void visitOuterClass(
final String owner,
final String name,
final String desc){
}
public AnnotationVisitor visitAnnotation(
final String desc,
final boolean visible){
return this;
}
public void visitAttribute(final Attribute attr){
}
public void visitInnerClass(
final String name,
final String outerName,
final String innerName,
final int access){
}
public FieldVisitor visitField(
final int access,
final String name,
final String desc,
final String signature,
final Object value){
return this;
}
8.4. EMPTYVISITOR.JAVA 451
public MethodVisitor visitMethod(
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions){
return this;
}
public void visitEnd(){
}
public AnnotationVisitor visitAnnotationDefault(){
return this;
}
public AnnotationVisitor visitParameterAnnotation(
final int parameter,
final String desc,
final boolean visible){
return this;
}
public void visitCode(){
}
public void visitFrame(
final int type,
final int nLocal,
final Object[] local,
final int nStack,
final Object[] stack){
}
public void visitInsn(final int opcode){
}
public void visitIntInsn(final int opcode, final int opera nd){
}
public void visitVarInsn(final int opcode, final int var){
}
public void visitTypeInsn(final int opcode, final String d esc){
}
public void visitFieldInsn(
final int opcode,
final String owner,
452 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
final String name,
final String desc){
}
public void visitMethodInsn(
final int opcode,
final String owner,
final String name,
final String desc){
}
public void visitJumpInsn(final int opcode, final Label la bel){
}
public void visitLabel(final Label label){
}
public void visitLdcInsn(final Object cst){
}
public void visitIincInsn(final int var, final int increme nt){
}
public void visitTableSwitchInsn(
final int min,
final int max,
final Label dflt,
final Label labels[]){
}
public void visitLookupSwitchInsn(
final Label dflt,
final int keys[],
final Label labels[]){
}
public void visitMultiANewArrayInsn(final String desc, f inal int dims){
}
public void visitTryCatchBlock(
final Label start,
final Label end,
final Label handler,
final String type){
}
public void visitLocalVariable(
final String name,
final String desc,
final String signature,
8.5. GENERATORADAPTER.JAVA 453
final Label start,
final Label end,
final int index){
}
public void visitLineNumber(final int line, final Label st art){
}
public void visitMaxs(final int maxStack, final int maxLoc als){
}
public void visit(final String name, final Object value){
}
public void visitEnum(
final String name,
final String desc,
final String value){
}
public AnnotationVisitor visitAnnotation(
final String name,
final String desc){
return this;
}
public AnnotationVisitor visitArray(final String name){
return this;
}
}
———-
8.5 GeneratorAdapter.java
(LocalVariablesSorter [484])
— GeneratorAdapter.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import clojure.asm.ClassVisitor;
import clojure.asm.Label;
import clojure.asm.MethodVisitor;
454 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
import clojure.asm.Opcodes;
import clojure.asm.Type;
/**
* A {@link clojure.asm.MethodAdapter} with convenient met hods to
* generate code. For example, using this adapter, the class b elow
* <p/>
* <pre>
* public class Example {
* public static void main(String[] args) {
* System.out.println(&quot;Hello world!&quot;);
* }
* }
* </pre>
* <p/>
* can be generated as follows:
* <p/>
* <pre>
* ClassWriter cw = new ClassWriter(true);
* cw.visit(V1_1, ACC_PUBLIC, &quot;Example&quot;, null,
* &quot;java/lang/Object&quot;, null);
* <p/>
* Method m = Method.getMethod(&quot;void &lt;init&gt; ()& quot;);
* GeneratorAdapter mg =
* new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);
* mg.loadThis();
* mg.invokeConstructor(Type.getType(Object.class), m) ;
* mg.returnValue();
* mg.endMethod();
* <p/>
* m = Method.getMethod(&quot;void main (String[])&quot;) ;
* mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, nul l, null, cw);
* mg.getStatic(Type.getType(System.class), &quot;out& quot;,
* Type.getType(PrintStream.class));
* mg.push(&quot;Hello world!&quot;);
* mg.invokeVirtual(Type.getType(PrintStream.class),
* Method.getMethod(&quot;void println (String)&quot;)) ;
* mg.returnValue();
* mg.endMethod();
* <p/>
* cw.visitEnd();
* </pre>
*
* @author Juozas Baliuka
* @author Chris Nokleberg
* @author Eric Bruneton
*/
public class GeneratorAdapter extends LocalVariablesSor ter{
private final static Type BYTE_TYPE =
8.5. GENERATORADAPTER.JAVA 455
Type.getObjectType("java/lang/Byte");
private final static Type BOOLEAN_TYPE =
Type.getObjectType("java/lang/Boolean");
private final static Type SHORT_TYPE =
Type.getObjectType("java/lang/Short");
private final static Type CHARACTER_TYPE =
Type.getObjectType("java/lang/Character");
private final static Type INTEGER_TYPE =
Type.getObjectType("java/lang/Integer");
private final static Type FLOAT_TYPE =
Type.getObjectType("java/lang/Float");
private final static Type LONG_TYPE =
Type.getObjectType("java/lang/Long");
private final static Type DOUBLE_TYPE =
Type.getObjectType("java/lang/Double");
private final static Type NUMBER_TYPE =
Type.getObjectType("java/lang/Number");
private final static Type OBJECT_TYPE =
Type.getObjectType("java/lang/Object");
private final static Method BOOLEAN_VALUE =
Method.getMethod("boolean booleanValue()");
private final static Method CHAR_VALUE =
Method.getMethod("char charValue()");
private final static Method INT_VALUE =
Method.getMethod("int intValue()");
private final static Method FLOAT_VALUE =
Method.getMethod("float floatValue()");
private final static Method LONG_VALUE =
Method.getMethod("long longValue()");
private final static Method DOUBLE_VALUE =
Method.getMethod("double doubleValue()");
/**
* Constant for the {@link #math math} method.
*/
456 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
public final static int ADD = Opcodes.IADD;
/**
* Constant for the {@link #math math} method.
*/
public final static int SUB = Opcodes.ISUB;
/**
* Constant for the {@link #math math} method.
*/
public final static int MUL = Opcodes.IMUL;
/**
* Constant for the {@link #math math} method.
*/
public final static int DIV = Opcodes.IDIV;
/**
* Constant for the {@link #math math} method.
*/
public final static int REM = Opcodes.IREM;
/**
* Constant for the {@link #math math} method.
*/
public final static int NEG = Opcodes.INEG;
/**
* Constant for the {@link #math math} method.
*/
public final static int SHL = Opcodes.ISHL;
/**
* Constant for the {@link #math math} method.
*/
public final static int SHR = Opcodes.ISHR;
/**
* Constant for the {@link #math math} method.
*/
public final static int USHR = Opcodes.IUSHR;
/**
* Constant for the {@link #math math} method.
*/
public final static int AND = Opcodes.IAND;
/**
* Constant for the {@link #math math} method.
*/
8.5. GENERATORADAPTER.JAVA 457
public final static int OR = Opcodes.IOR;
/**
* Constant for the {@link #math math} method.
*/
public final static int XOR = Opcodes.IXOR;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int EQ = Opcodes.IFEQ;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int NE = Opcodes.IFNE;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int LT = Opcodes.IFLT;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int GE = Opcodes.IFGE;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int GT = Opcodes.IFGT;
/**
* Constant for the {@link #ifCmp ifCmp} method.
*/
public final static int LE = Opcodes.IFLE;
/**
* Access flags of the method visited by this adapter.
*/
private final int access;
/**
* Return type of the method visited by this adapter.
*/
private final Type returnType;
/**
* Argument types of the method visited by this adapter.
*/
458 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
private final Type[] argumentTypes;
/**
* Types of the local variables of the method visited by this ad apter.
*/
private final List localTypes = new ArrayList();
/**
* Creates a new {@link GeneratorAdapter}.
*
* @param mv the method visitor to which this adapter delegate s
* calls.
* @param access the method’s access flags (see {@link Opcode s}).
* @param name the method’s name.
* @param desc the method’s descriptor (see {@link Type Type} ).
*/
public GeneratorAdapter(
final MethodVisitor mv,
final int access,
final String name,
final String desc){
super(access, desc, mv);
this.access = access;
this.returnType = Type.getReturnType(desc);
this.argumentTypes = Type.getArgumentTypes(desc);
}
/**
* Creates a new {@link GeneratorAdapter}.
*
* @param access access flags of the adapted method.
* @param method the adapted method.
* @param mv the method visitor to which this adapter delegate s
* calls.
*/
public GeneratorAdapter(
final int access,
final Method method,
final MethodVisitor mv){
super(access, method.getDescriptor(), mv);
this.access = access;
this.returnType = method.getReturnType();
this.argumentTypes = method.getArgumentTypes();
}
/**
* Creates a new {@link GeneratorAdapter}.
*
* @param access access flags of the adapted method.
* @param method the adapted method.
8.5. GENERATORADAPTER.JAVA 459
* @param signature the signature of the adapted method (may b e
* <tt>null</tt>).
* @param exceptions the exceptions thrown by the adapted met hod
* (may be <tt>null</tt>).
* @param cv the class visitor to which this adapter delegates
* calls.
*/
public GeneratorAdapter(
final int access,
final Method method,
final String signature,
final Type[] exceptions,
final ClassVisitor cv){
this(access, method, cv.visitMethod(access,
method.getName(),
method.getDescriptor(),
signature,
getInternalNames(exceptions)));
}
/**
* Returns the internal names of the given types.
*
* @param types a set of types.
* @return the internal names of the given types.
*/
private static String[] getInternalNames(final Type[] ty pes){
if(types == null)
{
return null;
}
String[] names = new String[types.length];
for(int i = 0; i < names.length; ++i)
{
names[i] = types[i].getInternalName();
}
return names;
}
// ------------------------------------------------- ------------------
// Instructions to push constants on the stack
// ------------------------------------------------- ------------------
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final boolean value){
push(value ? 1 : 0);
460 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final int value){
if(value >= -1 && value <= 5)
{
mv.visitInsn(Opcodes.ICONST_0 + value);
}
else if(value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE )
{
mv.visitIntInsn(Opcodes.BIPUSH, value);
}
else if(value >= Short.MIN_VALUE && value <= Short.MAX_VAL UE)
{
mv.visitIntInsn(Opcodes.SIPUSH, value);
}
else
{
mv.visitLdcInsn(new Integer(value));
}
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final long value){
if(value == 0L || value == 1L)
{
mv.visitInsn(Opcodes.LCONST_0 + (int) value);
}
else
{
mv.visitLdcInsn(new Long(value));
}
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final float value){
int bits = Float.floatToIntBits(value);
if(bits == 0L || bits == 0x3f800000 || bits == 0x40000000)
8.5. GENERATORADAPTER.JAVA 461
{ // 0..2
mv.visitInsn(Opcodes.FCONST_0 + (int) value);
}
else
{
mv.visitLdcInsn(new Float(value));
}
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final double value){
long bits = Double.doubleToLongBits(value);
if(bits == 0L || bits == 0x3ff0000000000000L)
{ // +0.0d and 1.0d
mv.visitInsn(Opcodes.DCONST_0 + (int) value);
}
else
{
mv.visitLdcInsn(new Double(value));
}
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack. May be
* <tt>null</tt>.
*/
public void push(final String value){
if(value == null)
{
mv.visitInsn(Opcodes.ACONST_NULL);
}
else
{
mv.visitLdcInsn(value);
}
}
/**
* Generates the instruction to push the given value on the sta ck.
*
* @param value the value to be pushed on the stack.
*/
public void push(final Type value){
if(value == null)
462 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
{
mv.visitInsn(Opcodes.ACONST_NULL);
}
else
{
mv.visitLdcInsn(value);
}
}
// ------------------------------------------------- ------------------
// Instructions to load and store method arguments
// ------------------------------------------------- -----------------
/**
* Returns the index of the given method argument in the frame’ s local
* variables array.
*
* @param arg the index of a method argument.
* @return the index of the given method argument in the frame’ s local
* variables array.
*/
private int getArgIndex(final int arg){
int index = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;
for(int i = 0; i < arg; i++)
{
index += argumentTypes[i].getSize();
}
return index;
}
/**
* Generates the instruction to push a local variable on the st ack.
*
* @param type the type of the local variable to be loaded.
* @param index an index in the frame’s local variables array.
*/
private void loadInsn(final Type type, final int index){
mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index );
}
/**
* Generates the instruction to store the top stack value in a l ocal
* variable.
*
* @param type the type of the local variable to be stored.
* @param index an index in the frame’s local variables array.
*/
private void storeInsn(final Type type, final int index){
mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), inde x);
}
8.5. GENERATORADAPTER.JAVA 463
/**
* Generates the instruction to load ’this’ on the stack.
*/
public void loadThis(){
if((access & Opcodes.ACC_STATIC) != 0)
{
throw new IllegalStateException(
"no ’this’ pointer within static method");
}
mv.visitVarInsn(Opcodes.ALOAD, 0);
}
/**
* Generates the instruction to load the given method argumen t
* on the stack.
*
* @param arg the index of a method argument.
*/
public void loadArg(final int arg){
loadInsn(argumentTypes[arg], getArgIndex(arg));
}
/**
* Generates the instructions to load the given method argume nts
* on the stack.
*
* @param arg the index of the first method argument to be loade d.
* @param count the number of method arguments to be loaded.
*/
public void loadArgs(final int arg, final int count){
int index = getArgIndex(arg);
for(int i = 0; i < count; ++i)
{
Type t = argumentTypes[arg + i];
loadInsn(t, index);
index += t.getSize();
}
}
/**
* Generates the instructions to load all the method argument s
* on the stack.
*/
public void loadArgs(){
loadArgs(0, argumentTypes.length);
}
/**
* Generates the instructions to load all the method argument s
464 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* on the stack, as a single object array.
*/
public void loadArgArray(){
push(argumentTypes.length);
newArray(OBJECT_TYPE);
for(int i = 0; i < argumentTypes.length; i++)
{
dup();
push(i);
loadArg(i);
box(argumentTypes[i]);
arrayStore(OBJECT_TYPE);
}
}
/**
* Generates the instruction to store the top stack value in th e given
* method argument.
*
* @param arg the index of a method argument.
*/
public void storeArg(final int arg){
storeInsn(argumentTypes[arg], getArgIndex(arg));
}
// ------------------------------------------------- ------------------
// Instructions to load and store local variables
// ------------------------------------------------- ------------------
/**
* Returns the type of the given local variable.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
* @return the type of the given local variable.
*/
public Type getLocalType(final int local){
return (Type) localTypes.get(local - firstLocal);
}
protected void setLocalType(final int local, final Type ty pe){
int index = local - firstLocal;
while(localTypes.size() < index + 1)
{
localTypes.add(null);
}
localTypes.set(index, type);
}
/**
8.5. GENERATORADAPTER.JAVA 465
* Generates the instruction to load the given local variable
* on the stack.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
*/
public void loadLocal(final int local){
loadInsn(getLocalType(local), local);
}
/**
* Generates the instruction to load the given local variable
* on the stack.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
* @param type the type of this local variable.
*/
public void loadLocal(final int local, final Type type){
setLocalType(local, type);
loadInsn(type, local);
}
/**
* Generates the instruction to store the top stack value in th e given
* local variable.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
*/
public void storeLocal(final int local){
storeInsn(getLocalType(local), local);
}
/**
* Generates the instruction to store the top stack value in th e given
* local variable.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
* @param type the type of this local variable.
*/
public void storeLocal(final int local, final Type type){
setLocalType(local, type);
storeInsn(type, local);
}
/**
* Generates the instruction to load an element from an array.
*
466 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* @param type the type of the array element to be loaded.
*/
public void arrayLoad(final Type type){
mv.visitInsn(type.getOpcode(Opcodes.IALOAD));
}
/**
* Generates the instruction to store an element in an array.
*
* @param type the type of the array element to be stored.
*/
public void arrayStore(final Type type){
mv.visitInsn(type.getOpcode(Opcodes.IASTORE));
}
// ------------------------------------------------- ------------------
// Instructions to manage the stack
// ------------------------------------------------- ------------------
/**
* Generates a POP instruction.
*/
public void pop(){
mv.visitInsn(Opcodes.POP);
}
/**
* Generates a POP2 instruction.
*/
public void pop2(){
mv.visitInsn(Opcodes.POP2);
}
/**
* Generates a DUP instruction.
*/
public void dup(){
mv.visitInsn(Opcodes.DUP);
}
/**
* Generates a DUP2 instruction.
*/
public void dup2(){
mv.visitInsn(Opcodes.DUP2);
}
/**
* Generates a DUP_X1 instruction.
*/
8.5. GENERATORADAPTER.JAVA 467
public void dupX1(){
mv.visitInsn(Opcodes.DUP_X1);
}
/**
* Generates a DUP_X2 instruction.
*/
public void dupX2(){
mv.visitInsn(Opcodes.DUP_X2);
}
/**
* Generates a DUP2_X1 instruction.
*/
public void dup2X1(){
mv.visitInsn(Opcodes.DUP2_X1);
}
/**
* Generates a DUP2_X2 instruction.
*/
public void dup2X2(){
mv.visitInsn(Opcodes.DUP2_X2);
}
/**
* Generates a SWAP instruction.
*/
public void swap(){
mv.visitInsn(Opcodes.SWAP);
}
/**
* Generates the instructions to swap the top two stack values .
*
* @param prev type of the top - 1 stack value.
* @param type type of the top stack value.
*/
public void swap(final Type prev, final Type type){
if(type.getSize() == 1)
{
if(prev.getSize() == 1)
{
swap(); // same as dupX1(), pop();
}
else
{
dupX2();
pop();
}
468 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
}
else
{
if(prev.getSize() == 1)
{
dup2X1();
pop2();
}
else
{
dup2X2();
pop2();
}
}
}
// ------------------------------------------------- ------------------
// Instructions to do mathematical and logical operations
// ------------------------------------------------- ------------------
/**
* Generates the instruction to do the specified mathematica l or logical
* operation.
*
* @param op a mathematical or logical operation. Must be one o f ADD,
* SUB, MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.
* @param type the type of the operand(s) for this operation.
*/
public void math(final int op, final Type type){
mv.visitInsn(type.getOpcode(op));
}
/**
* Generates the instructions to compute the bitwise negatio n of the top
* stack value.
*/
public void not(){
mv.visitInsn(Opcodes.ICONST_1);
mv.visitInsn(Opcodes.IXOR);
}
/**
* Generates the instruction to increment the given local var iable.
*
* @param local the local variable to be incremented.
* @param amount the amount by which the local variable must be
* incremented.
*/
public void iinc(final int local, final int amount){
mv.visitIincInsn(local, amount);
8.5. GENERATORADAPTER.JAVA 469
}
/**
* Generates the instructions to cast a numerical value from o ne type to
* another.
*
* @param from the type of the top stack value
* @param to the type into which this value must be cast.
*/
public void cast(final Type from, final Type to){
if(from != to)
{
if(from == Type.DOUBLE_TYPE)
{
if(to == Type.FLOAT_TYPE)
{
mv.visitInsn(Opcodes.D2F);
}
else if(to == Type.LONG_TYPE)
{
mv.visitInsn(Opcodes.D2L);
}
else
{
mv.visitInsn(Opcodes.D2I);
cast(Type.INT_TYPE, to);
}
}
else if(from == Type.FLOAT_TYPE)
{
if(to == Type.DOUBLE_TYPE)
{
mv.visitInsn(Opcodes.F2D);
}
else if(to == Type.LONG_TYPE)
{
mv.visitInsn(Opcodes.F2L);
}
else
{
mv.visitInsn(Opcodes.F2I);
cast(Type.INT_TYPE, to);
}
}
else if(from == Type.LONG_TYPE)
{
if(to == Type.DOUBLE_TYPE)
{
mv.visitInsn(Opcodes.L2D);
}
470 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
else if(to == Type.FLOAT_TYPE)
{
mv.visitInsn(Opcodes.L2F);
}
else
{
mv.visitInsn(Opcodes.L2I);
cast(Type.INT_TYPE, to);
}
}
else
{
if(to == Type.BYTE_TYPE)
{
mv.visitInsn(Opcodes.I2B);
}
else if(to == Type.CHAR_TYPE)
{
mv.visitInsn(Opcodes.I2C);
}
else if(to == Type.DOUBLE_TYPE)
{
mv.visitInsn(Opcodes.I2D);
}
else if(to == Type.FLOAT_TYPE)
{
mv.visitInsn(Opcodes.I2F);
}
else if(to == Type.LONG_TYPE)
{
mv.visitInsn(Opcodes.I2L);
}
else if(to == Type.SHORT_TYPE)
{
mv.visitInsn(Opcodes.I2S);
}
}
}
}
// ------------------------------------------------- ------------------
// Instructions to do boxing and unboxing operations
// ------------------------------------------------- ------------------
/**
* Generates the instructions to box the top stack value. This value is
* replaced by its boxed equivalent on top of the stack.
*
* @param type the type of the top stack value.
*/
8.5. GENERATORADAPTER.JAVA 471
public void box(final Type type){
if(type.getSort() == Type.OBJECT || type.getSort() == Typ e.ARRAY)
{
return;
}
if(type == Type.VOID_TYPE)
{
push((String) null);
}
else
{
Type boxed = type;
switch(type.getSort())
{
case Type.BYTE:
boxed = BYTE_TYPE;
break;
case Type.BOOLEAN:
boxed = BOOLEAN_TYPE;
break;
case Type.SHORT:
boxed = SHORT_TYPE;
break;
case Type.CHAR:
boxed = CHARACTER_TYPE;
break;
case Type.INT:
boxed = INTEGER_TYPE;
break;
case Type.FLOAT:
boxed = FLOAT_TYPE;
break;
case Type.LONG:
boxed = LONG_TYPE;
break;
case Type.DOUBLE:
boxed = DOUBLE_TYPE;
break;
}
newInstance(boxed);
if(type.getSize() == 2)
{
// Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o
dupX2();
dupX2();
pop();
}
else
{
// p -> po -> opo -> oop -> o
472 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
dupX1();
swap();
}
invokeConstructor(boxed, new Method("<init>",
Type.VOID_TYPE,
new Type[]{type}));
}
}
/**
* Generates the instructions to unbox the top stack value. Th is value is
* replaced by its unboxed equivalent on top of the stack.
*
* @param type the type of the top stack value.
*/
public void unbox(final Type type){
Type t = NUMBER_TYPE;
Method sig = null;
switch(type.getSort())
{
case Type.VOID:
return;
case Type.CHAR:
t = CHARACTER_TYPE;
sig = CHAR_VALUE;
break;
case Type.BOOLEAN:
t = BOOLEAN_TYPE;
sig = BOOLEAN_VALUE;
break;
case Type.DOUBLE:
sig = DOUBLE_VALUE;
break;
case Type.FLOAT:
sig = FLOAT_VALUE;
break;
case Type.LONG:
sig = LONG_VALUE;
break;
case Type.INT:
case Type.SHORT:
case Type.BYTE:
sig = INT_VALUE;
}
if(sig == null)
{
checkCast(type);
}
else
{
8.5. GENERATORADAPTER.JAVA 473
checkCast(t);
invokeVirtual(t, sig);
}
}
// ------------------------------------------------- ------------------
// Instructions to jump to other instructions
// ------------------------------------------------- ------------------
/**
* Creates a new {@link Label}.
*
* @return a new {@link Label}.
*/
public Label newLabel(){
return new Label();
}
/**
* Marks the current code position with the given label.
*
* @param label a label.
*/
public void mark(final Label label){
mv.visitLabel(label);
}
/**
* Marks the current code position with a new label.
*
* @return the label that was created to mark the current code p osition.
*/
public Label mark(){
Label label = new Label();
mv.visitLabel(label);
return label;
}
/**
* Generates the instructions to jump to a label based on the
* comparison of the top two stack values.
*
* @param type the type of the top two stack values.
* @param mode how these values must be compared. One of EQ, NE, LT,
* GE, GT, LE.
* @param label where to jump if the comparison result is <tt>t rue</tt>.
*/
public void ifCmp(final Type type, final int mode, final Lab el label){
int intOp = -1;
switch(type.getSort())
474 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
{
case Type.LONG:
mv.visitInsn(Opcodes.LCMP);
break;
case Type.DOUBLE:
mv.visitInsn(Opcodes.DCMPG);
break;
case Type.FLOAT:
mv.visitInsn(Opcodes.FCMPG);
break;
case Type.ARRAY:
case Type.OBJECT:
switch(mode)
{
case EQ:
mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);
return;
case NE:
mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);
return;
}
throw new IllegalArgumentException("Bad comparison for t ype "
+ type);
default:
switch(mode)
{
case EQ:
intOp = Opcodes.IF_ICMPEQ;
break;
case NE:
intOp = Opcodes.IF_ICMPNE;
break;
case GE:
intOp = Opcodes.IF_ICMPGE;
break;
case LT:
intOp = Opcodes.IF_ICMPLT;
break;
case LE:
intOp = Opcodes.IF_ICMPLE;
break;
case GT:
intOp = Opcodes.IF_ICMPGT;
break;
}
mv.visitJumpInsn(intOp, label);
return;
}
int jumpMode = mode;
switch(mode)
8.5. GENERATORADAPTER.JAVA 475
{
case GE:
jumpMode = LT;
break;
case LE:
jumpMode = GT;
break;
}
mv.visitJumpInsn(jumpMode, label);
}
/**
* Generates the instructions to jump to a label based on the
* comparison of the top two integer stack values.
*
* @param mode how these values must be compared. One of EQ, NE, LT,
* GE, GT, LE.
* @param label where to jump if the comparison result is <tt>t rue</tt>.
*/
public void ifICmp(final int mode, final Label label){
ifCmp(Type.INT_TYPE, mode, label);
}
/**
* Generates the instructions to jump to a label based on the
* comparison of the top integer stack value with zero.
*
* @param mode how these values must be compared. One of EQ, NE, LT,
* GE, GT, LE.
* @param label where to jump if the comparison result is <tt>t rue</tt>.
*/
public void ifZCmp(final int mode, final Label label){
mv.visitJumpInsn(mode, label);
}
/**
* Generates the instruction to jump to the given label if the t op stack
* value is null.
*
* @param label where to jump if the condition is <tt>true</tt >.
*/
public void ifNull(final Label label){
mv.visitJumpInsn(Opcodes.IFNULL, label);
}
/**
* Generates the instruction to jump to the given label if the t op stack
* value is not null.
*
* @param label where to jump if the condition is <tt>true</tt >.
476 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
*/
public void ifNonNull(final Label label){
mv.visitJumpInsn(Opcodes.IFNONNULL, label);
}
/**
* Generates the instruction to jump to the given label.
*
* @param label where to jump if the condition is <tt>true</tt >.
*/
public void goTo(final Label label){
mv.visitJumpInsn(Opcodes.GOTO, label);
}
/**
* Generates a RET instruction.
*
* @param local a local variable identifier, as returned by
* {@link LocalVariablesSorter#newLocal(Type) newLocal( )}.
*/
public void ret(final int local){
mv.visitVarInsn(Opcodes.RET, local);
}
/**
* Generates the instructions for a switch statement.
*
* @param keys the switch case keys.
* @param generator a generator to generate the code for the sw itch
* cases.
*/
public void tableSwitch(
final int[] keys,
final TableSwitchGenerator generator){
float density;
if(keys.length == 0)
{
density = 0;
}
else
{
density = (float) keys.length
/ (keys[keys.length - 1] - keys[0] + 1);
}
tableSwitch(keys, generator, density >= 0.5f);
}
/**
* Generates the instructions for a switch statement.
*
8.5. GENERATORADAPTER.JAVA 477
* @param keys the switch case keys.
* @param generator a generator to generate the code for the sw itch
* cases.
* @param useTable <tt>true</tt> to use a TABLESWITCH instru ction, or
* <tt>false</tt> to use a LOOKUPSWITCH instruction.
*/
public void tableSwitch(
final int[] keys,
final TableSwitchGenerator generator,
final boolean useTable){
for(int i = 1; i < keys.length; ++i)
{
if(keys[i] < keys[i - 1])
{
throw new IllegalArgumentException(
"keys must be sorted ascending");
}
}
Label def = newLabel();
Label end = newLabel();
if(keys.length > 0)
{
int len = keys.length;
int min = keys[0];
int max = keys[len - 1];
int range = max - min + 1;
if(useTable)
{
Label[] labels = new Label[range];
Arrays.fill(labels, def);
for(int i = 0; i < len; ++i)
{
labels[keys[i] - min] = newLabel();
}
mv.visitTableSwitchInsn(min, max, def, labels);
for(int i = 0; i < range; ++i)
{
Label label = labels[i];
if(label != def)
{
mark(label);
generator.generateCase(i + min, end);
}
}
}
else
{
Label[] labels = new Label[len];
for(int i = 0; i < len; ++i)
{
478 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
labels[i] = newLabel();
}
mv.visitLookupSwitchInsn(def, keys, labels);
for(int i = 0; i < len; ++i)
{
mark(labels[i]);
generator.generateCase(keys[i], end);
}
}
}
mark(def);
generator.generateDefault();
mark(end);
}
/**
* Generates the instruction to return the top stack value to t he caller.
*/
public void returnValue(){
mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) ;
}
// ------------------------------------------------- ------------------
// Instructions to load and store fields
// ------------------------------------------------- ------------------
/**
* Generates a get field or set field instruction.
*
* @param opcode the instruction’s opcode.
* @param ownerType the class in which the field is defined.
* @param name the name of the field.
* @param fieldType the type of the field.
*/
private void fieldInsn(
final int opcode,
final Type ownerType,
final String name,
final Type fieldType){
mv.visitFieldInsn(opcode,
ownerType.getInternalName(),
name,
fieldType.getDescriptor());
}
/**
* Generates the instruction to push the value of a static fiel d on the
* stack.
*
* @param owner the class in which the field is defined.
8.5. GENERATORADAPTER.JAVA 479
* @param name the name of the field.
* @param type the type of the field.
*/
public void getStatic(final Type owner,
final String name,
final Type type){
fieldInsn(Opcodes.GETSTATIC, owner, name, type);
}
/**
* Generates the instruction to store the top stack value
* in a static field.
*
* @param owner the class in which the field is defined.
* @param name the name of the field.
* @param type the type of the field.
*/
public void putStatic(final Type owner,
final String name,
final Type type){
fieldInsn(Opcodes.PUTSTATIC, owner, name, type);
}
/**
* Generates the instruction to push the value of a non static f ield
* on the stack.
*
* @param owner the class in which the field is defined.
* @param name the name of the field.
* @param type the type of the field.
*/
public void getField(final Type owner,
final String name,
final Type type){
fieldInsn(Opcodes.GETFIELD, owner, name, type);
}
/**
* Generates the instruction to store the top stack value in a
* non static field.
*
* @param owner the class in which the field is defined.
* @param name the name of the field.
* @param type the type of the field.
*/
public void putField(final Type owner,
final String name,
final Type type){
fieldInsn(Opcodes.PUTFIELD, owner, name, type);
}
480 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
// ------------------------------------------------- ------------------
// Instructions to invoke methods
// ------------------------------------------------- ------------------
/**
* Generates an invoke method instruction.
*
* @param opcode the instruction’s opcode.
* @param type the class in which the method is defined.
* @param method the method to be invoked.
*/
private void invokeInsn(
final int opcode,
final Type type,
final Method method){
String owner = type.getSort() == Type.ARRAY
? type.getDescriptor()
: type.getInternalName();
mv.visitMethodInsn(opcode,
owner,
method.getName(),
method.getDescriptor());
}
/**
* Generates the instruction to invoke a normal method.
*
* @param owner the class in which the method is defined.
* @param method the method to be invoked.
*/
public void invokeVirtual(final Type owner, final Method m ethod){
invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method);
}
/**
* Generates the instruction to invoke a constructor.
*
* @param type the class in which the constructor is defined.
* @param method the constructor to be invoked.
*/
public void invokeConstructor(final Type type, final Meth od method){
invokeInsn(Opcodes.INVOKESPECIAL, type, method);
}
/**
* Generates the instruction to invoke a static method.
*
* @param owner the class in which the method is defined.
* @param method the method to be invoked.
8.5. GENERATORADAPTER.JAVA 481
*/
public void invokeStatic(final Type owner, final Method me thod){
invokeInsn(Opcodes.INVOKESTATIC, owner, method);
}
/**
* Generates the instruction to invoke an interface method.
*
* @param owner the class in which the method is defined.
* @param method the method to be invoked.
*/
public void invokeInterface(final Type owner, final Metho d method){
invokeInsn(Opcodes.INVOKEINTERFACE, owner, method);
}
// ------------------------------------------------- ------------------
// Instructions to create objects and arrays
// ------------------------------------------------- ------------------
/**
* Generates a type dependent instruction.
*
* @param opcode the instruction’s opcode.
* @param type the instruction’s operand.
*/
private void typeInsn(final int opcode, final Type type){
String desc;
if(type.getSort() == Type.ARRAY)
{
desc = type.getDescriptor();
}
else
{
desc = type.getInternalName();
}
mv.visitTypeInsn(opcode, desc);
}
/**
* Generates the instruction to create a new object.
*
* @param type the class of the object to be created.
*/
public void newInstance(final Type type){
typeInsn(Opcodes.NEW, type);
}
/**
* Generates the instruction to create a new array.
*
482 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* @param type the type of the array elements.
*/
public void newArray(final Type type){
int typ;
switch(type.getSort())
{
case Type.BOOLEAN:
typ = Opcodes.T_BOOLEAN;
break;
case Type.CHAR:
typ = Opcodes.T_CHAR;
break;
case Type.BYTE:
typ = Opcodes.T_BYTE;
break;
case Type.SHORT:
typ = Opcodes.T_SHORT;
break;
case Type.INT:
typ = Opcodes.T_INT;
break;
case Type.FLOAT:
typ = Opcodes.T_FLOAT;
break;
case Type.LONG:
typ = Opcodes.T_LONG;
break;
case Type.DOUBLE:
typ = Opcodes.T_DOUBLE;
break;
default:
typeInsn(Opcodes.ANEWARRAY, type);
return;
}
mv.visitIntInsn(Opcodes.NEWARRAY, typ);
}
// ------------------------------------------------- ------------------
// Miscelaneous instructions
// ------------------------------------------------- ------------------
/**
* Generates the instruction to compute the length of an array .
*/
public void arrayLength(){
mv.visitInsn(Opcodes.ARRAYLENGTH);
}
/**
* Generates the instruction to throw an exception.
8.5. GENERATORADAPTER.JAVA 483
*/
public void throwException(){
mv.visitInsn(Opcodes.ATHROW);
}
/**
* Generates the instructions to create and throw an exceptio n. The
* exception class must have a constructor with a single Strin g argument.
*
* @param type the class of the exception to be thrown.
* @param msg the detailed message of the exception.
*/
public void throwException(final Type type, final String m sg){
newInstance(type);
dup();
push(msg);
invokeConstructor(type, Method.getMethod("void <init> (String)"));
throwException();
}
/**
* Generates the instruction to check that the top stack value is of the
* given type.
*
* @param type a class or interface type.
*/
public void checkCast(final Type type){
if(!type.equals(OBJECT_TYPE))
{
typeInsn(Opcodes.CHECKCAST, type);
}
}
/**
* Generates the instruction to test if the top stack value is
* of the given type.
*
* @param type a class or interface type.
*/
public void instanceOf(final Type type){
typeInsn(Opcodes.INSTANCEOF, type);
}
/**
* Generates the instruction to get the monitor of the top stac k value.
*/
public void monitorEnter(){
mv.visitInsn(Opcodes.MONITORENTER);
}
484 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
/**
* Generates the instruction to release the monitor of
* the top stack value.
*/
public void monitorExit(){
mv.visitInsn(Opcodes.MONITOREXIT);
}
// ------------------------------------------------- ------------------
// Non instructions
// ------------------------------------------------- ------------------
/**
* Marks the end of the visited method.
*/
public void endMethod(){
if((access & Opcodes.ACC_ABSTRACT) == 0)
{
mv.visitMaxs(0, 0);
}
mv.visitEnd();
}
/**
* Marks the start of an exception handler.
*
* @param start beginning of the exception handler’s scope
* (inclusive).
* @param end end of the exception handler’s scope (exclusive ).
* @param exception internal name of the type of exceptions ha ndled
* by the handler.
*/
public void catchException(
final Label start,
final Label end,
final Type exception){
mv.visitTryCatchBlock(start, end, mark(),
exception.getInternalName());
}
}
———-
8.6 LocalVariablesSorter.java
(MethodAdapter [314])
— LocalVariablesSorter.java —
8.6. LOCALVARIABLESSORTER.JAVA 485
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import clojure.asm.Label;
import clojure.asm.MethodAdapter;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
import clojure.asm.Type;
/**
* A {@link MethodAdapter} that renumbers local variables in their
* order of appearance. This adapter allows one to easily add n ew
* local variables to a method. It may be used by inheriting fro m
* this class, but the preferred way of using it is via delegati on:
* the next visitor in the chain can indeed add new locals when n eeded
* by calling {@link #newLocal} on this adapter (this require s a
* reference back to this {@link LocalVariablesSorter}).
*
* @author Chris Nokleberg
* @author Eugene Kuleshov
* @author Eric Bruneton
*/
public class LocalVariablesSorter extends MethodAdapter {
private final static Type OBJECT_TYPE =
Type.getObjectType("java/lang/Object");
/**
* Mapping from old to new local variable indexes. A local vari able
* at index i of size 1 is remapped to ’mapping[2*i]’, while a lo cal
* variable at index i of size 2 is remapped to ’mapping[2*i+1] ’.
*/
private int[] mapping = new int[40];
/**
* Array used to store stack map local variable types after rem apping.
*/
private Object[] newLocals = new Object[20];
/**
* Index of the first local variable, after formal parameters .
*/
protected final int firstLocal;
/**
* Index of the next local variable to be created by {@link #new Local}.
*/
protected int nextLocal;
/**
486 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* Indicates if at least one local variable has moved due to rem apping.
*/
private boolean changed;
/**
* Creates a new {@link LocalVariablesSorter}.
*
* @param access access flags of the adapted method.
* @param desc the method’s descriptor (see {@link Type Type} ).
* @param mv the method visitor to which this adapter delegate s
* calls.
*/
public LocalVariablesSorter(
final int access,
final String desc,
final MethodVisitor mv){
super(mv);
Type[] args = Type.getArgumentTypes(desc);
nextLocal = (Opcodes.ACC_STATIC & access) != 0 ? 0 : 1;
for(int i = 0; i < args.length; i++)
{
nextLocal += args[i].getSize();
}
firstLocal = nextLocal;
}
public void visitVarInsn(final int opcode, final int var){
Type type;
switch(opcode)
{
case Opcodes.LLOAD:
case Opcodes.LSTORE:
type = Type.LONG_TYPE;
break;
case Opcodes.DLOAD:
case Opcodes.DSTORE:
type = Type.DOUBLE_TYPE;
break;
case Opcodes.FLOAD:
case Opcodes.FSTORE:
type = Type.FLOAT_TYPE;
break;
case Opcodes.ILOAD:
case Opcodes.ISTORE:
type = Type.INT_TYPE;
break;
8.6. LOCALVARIABLESSORTER.JAVA 487
case Opcodes.ALOAD:
case Opcodes.ASTORE:
type = OBJECT_TYPE;
break;
// case RET:
default:
type = Type.VOID_TYPE;
}
mv.visitVarInsn(opcode, remap(var, type));
}
public void visitIincInsn(final int var, final int increme nt){
mv.visitIincInsn(remap(var, Type.INT_TYPE), increment );
}
public void visitMaxs(final int maxStack, final int maxLoc als){
mv.visitMaxs(maxStack, nextLocal);
}
public void visitLocalVariable(
final String name,
final String desc,
final String signature,
final Label start,
final Label end,
final int index){
int size = "J".equals(desc) || "D".equals(desc) ? 2 : 1;
int newIndex = remap(index, size);
mv.visitLocalVariable(name, desc, signature, start, end , newIndex);
}
public void visitFrame(
final int type,
final int nLocal,
final Object[] local,
final int nStack,
final Object[] stack){
if(type != Opcodes.F_NEW)
{ // uncompressed frame
throw new IllegalStateException(
"ClassReader.accept() should be called with EXPAND_FRAME S flag");
}
if(!changed)
{ // optimization for the case where mapping = identity
mv.visitFrame(type, nLocal, local, nStack, stack);
return;
}
488 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
// creates a copy of newLocals
Object[] oldLocals = new Object[newLocals.length];
System.arraycopy(newLocals, 0, oldLocals, 0, oldLocals. length);
// copies types from ’local’ to ’newLocals’
// ’newLocals’ already contains the variables added with ’n ewLocal’
int index = 0; // old local variable index
int number = 0; // old local variable number
for(; number < nLocal; ++number)
{
Object t = local[number];
int size = t == Opcodes.LONG ||
t == Opcodes.DOUBLE ? 2 : 1;
if(t != Opcodes.TOP)
{
setFrameLocal(remap(index, size), t);
}
index += size;
}
// removes TOP after long and double types as well as trailing TOPs
index = 0;
number = 0;
for(int i = 0; index < newLocals.length; ++i)
{
Object t = newLocals[index++];
if(t != null && t != Opcodes.TOP)
{
newLocals[i] = t;
number = i + 1;
if(t == Opcodes.LONG || t == Opcodes.DOUBLE)
{
index += 1;
}
}
else
{
newLocals[i] = Opcodes.TOP;
}
}
// visits remapped frame
mv.visitFrame(type, number, newLocals, nStack, stack);
// restores original value of ’newLocals’
newLocals = oldLocals;
}
8.6. LOCALVARIABLESSORTER.JAVA 489
// -------------
/**
* Creates a new local variable of the given type.
*
* @param type the type of the local variable to be created.
* @return the identifier of the newly created local variable .
*/
public int newLocal(final Type type){
Object t;
switch(type.getSort())
{
case Type.BOOLEAN:
case Type.CHAR:
case Type.BYTE:
case Type.SHORT:
case Type.INT:
t = Opcodes.INTEGER;
break;
case Type.FLOAT:
t = Opcodes.FLOAT;
break;
case Type.LONG:
t = Opcodes.LONG;
break;
case Type.DOUBLE:
t = Opcodes.DOUBLE;
break;
case Type.ARRAY:
t = type.getDescriptor();
break;
// case Type.OBJECT:
default:
t = type.getInternalName();
break;
}
int local = nextLocal;
setLocalType(local, type);
setFrameLocal(local, t);
nextLocal += type.getSize();
return local;
}
/**
* Sets the current type of the given local variable. The defau lt
* implementation of this method does nothing.
*
* @param local a local variable identifier, as returned by
* {@link #newLocal newLocal()}.
* @param type the type of the value being stored in the local
490 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* variable
*/
protected void setLocalType(final int local, final Type ty pe){
}
private void setFrameLocal(final int local, final Object t ype){
int l = newLocals.length;
if(local >= l)
{
Object[] a = new Object[Math.max(2 * l, local + 1)];
System.arraycopy(newLocals, 0, a, 0, l);
newLocals = a;
}
newLocals[local] = type;
}
private int remap(final int var, final Type type){
if(var < firstLocal)
{
return var;
}
int key = 2 * var + type.getSize() - 1;
int size = mapping.length;
if(key >= size)
{
int[] newMapping = new int[Math.max(2 * size, key + 1)];
System.arraycopy(mapping, 0, newMapping, 0, size);
mapping = newMapping;
}
int value = mapping[key];
if(value == 0)
{
value = nextLocal + 1;
mapping[key] = value;
setLocalType(nextLocal, type);
nextLocal += type.getSize();
}
if(value - 1 != var)
{
changed = true;
}
return value - 1;
}
private int remap(final int var, final int size){
if(var < firstLocal || !changed)
{
return var;
}
int key = 2 * var + size - 1;
8.7. METHOD.JAVA 491
int value = key < mapping.length ? mapping[key] : 0;
if(value == 0)
{
throw new
IllegalStateException("Unknown local variable " + var);
}
return value - 1;
}
}
———-
8.7 Method.java
— Method.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import java.util.HashMap;
import java.util.Map;
import clojure.asm.Type;
/**
* A named method descriptor.
*
* @author Juozas Baliuka
* @author Chris Nokleberg
* @author Eric Bruneton
*/
public class Method{
/**
* The method name.
*/
private final String name;
/**
* The method descriptor.
*/
private final String desc;
/**
* Maps primitive Java type names to their descriptors.
*/
private final static Map DESCRIPTORS;
492 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
static
{
DESCRIPTORS = new HashMap();
DESCRIPTORS.put("void", "V");
DESCRIPTORS.put("byte", "B");
DESCRIPTORS.put("char", "C");
DESCRIPTORS.put("double", "D");
DESCRIPTORS.put("float", "F");
DESCRIPTORS.put("int", "I");
DESCRIPTORS.put("long", "J");
DESCRIPTORS.put("short", "S");
DESCRIPTORS.put("boolean", "Z");
}
/**
* Creates a new {@link Method}.
*
* @param name the method’s name.
* @param desc the method’s descriptor.
*/
public Method(final String name, final String desc){
this.name = name;
this.desc = desc;
}
/**
* Creates a new {@link Method}.
*
* @param name the method’s name.
* @param returnType the method’s return type.
* @param argumentTypes the method’s argument types.
*/
public Method(
final String name,
final Type returnType,
final Type[] argumentTypes){
this(name, Type.getMethodDescriptor(returnType, argum entTypes));
}
/**
* Returns a {@link Method} corresponding to the given Java me thod
* declaration.
*
* @param method a Java method declaration, without argument names, of
* the form
* "returnType name (argumentType1, ... argumentTypeN)",
* where the types are in plain Java (e.g. "int", "float",
* "java.util.List", ...). Classes of the
* java.lang package can be specified by their
8.7. METHOD.JAVA 493
* unqualified name; all other classes names must be
* fully qualified.
* @return a {@link Method} corresponding to the given Java me thod
* declaration.
* @throws IllegalArgumentException if <code>method</cod e> could not get
* parsed.
*/
public static Method getMethod(final String method)
throws IllegalArgumentException{
return getMethod(method, false);
}
/**
* Returns a {@link Method} corresponding to the given Java me thod
* declaration.
*
* @param method a Java method declaration, without argument
* names, of the form
* "returnType name (argumentType1,...argumentTypeN)",
* where the types are in plain Java (e.g. "int",
* "float", "java.util.List", ...). Classes of the
* java.lang package may be specified by their
* unqualified name, depending on the
* defaultPackage argument; all other classes
* names must be fully qualified.
* @param defaultPackage true if unqualified class names bel ong to the
* default package, or false if they correspond
* to java.lang classes. For instance "Object"
* means "Object" if this option is true, or
* "java.lang.Object" otherwise.
* @return a {@link Method} corresponding to the given Java me thod
* declaration.
* @throws IllegalArgumentException if <code>method</cod e> could not get
* parsed.
*/
public static Method getMethod(
final String method,
final boolean defaultPackage) throws IllegalArgumentExc eption{
int space = method.indexOf(’ ’);
int start = method.indexOf(’(’, space) + 1;
int end = method.indexOf(’)’, start);
if(space == -1 || start == -1 || end == -1)
{
throw new IllegalArgumentException();
}
// TODO: Check validity of returnType, methodName and argum ents.
String returnType = method.substring(0, space);
String methodName = method.substring(space + 1, start - 1). trim();
StringBuffer sb = new StringBuffer();
sb.append(’(’);
494 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
int p;
do
{
String s;
p = method.indexOf(’,’, start);
if(p == -1)
{
s = map(method.substring(start, end).trim(), defaultPac kage);
}
else
{
s = map(method.substring(start, p).trim(), defaultPacka ge);
start = p + 1;
}
sb.append(s);
} while(p != -1);
sb.append(’)’);
sb.append(map(returnType, defaultPackage));
return new Method(methodName, sb.toString());
}
private static String map(final String type,
final boolean defaultPackage){
if(type.equals(""))
{
return type;
}
StringBuffer sb = new StringBuffer();
int index = 0;
while((index = type.indexOf("[]", index) + 1) > 0)
{
sb.append(’[’);
}
String t = type.substring(0, type.length() - sb.length() * 2);
String desc = (String) DESCRIPTORS.get(t);
if(desc != null)
{
sb.append(desc);
}
else
{
sb.append(’L’);
if(t.indexOf(’.’) < 0)
{
if(!defaultPackage)
{
sb.append("java/lang/");
}
8.7. METHOD.JAVA 495
sb.append(t);
}
else
{
sb.append(t.replace(’.’, ’/’));
}
sb.append(’;’);
}
return sb.toString();
}
/**
* Returns the name of the method described by this object.
*
* @return the name of the method described by this object.
*/
public String getName(){
return name;
}
/**
* Returns the descriptor of the method described by this obje ct.
*
* @return the descriptor of the method described by this obje ct.
*/
public String getDescriptor(){
return desc;
}
/**
* Returns the return type of the method described by this obje ct.
*
* @return the return type of the method described by this obje ct.
*/
public Type getReturnType(){
return Type.getReturnType(desc);
}
/**
* Returns the argument types of the method described by this o bject.
*
* @return the argument types of the method described by this o bject.
*/
public Type[] getArgumentTypes(){
return Type.getArgumentTypes(desc);
}
public String toString(){
return name + desc;
}
496 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
public boolean equals(final Object o){
if(!(o instanceof Method))
{
return false;
}
Method other = (Method) o;
return name.equals(other.name) && desc.equals(other.de sc);
}
public int hashCode(){
return name.hashCode() ^ desc.hashCode();
}
}
———-
8.8 SerialVersionUIDAdder.java
(ClassAdapter [183])
— SerialVersionUIDAdder.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import clojure.asm.ClassAdapter;
import clojure.asm.ClassVisitor;
import clojure.asm.FieldVisitor;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
/**
* A {@link ClassAdapter} that adds a serial version unique id entifier
* to a class if missing. Here is typical usage of this class:
* <p/>
* <pre>
* ClassWriter cw = new ClassWriter(...);
* ClassVisitor sv = new SerialVersionUIDAdder(cw);
* ClassVisitor ca = new MyClassAdapter(sv);
* new ClassReader(orginalClass).accept(ca, false);
8.8. SERIALVERSIONUIDADDER.JAVA 497
* </pre>
* <p/>
* The SVUID algorithm can be found on the java.sun.com websit e under
* "j2se/1.4.2/docs/guide/serialization/spec/class.ht ml"
* <p/>
* <pre>
* The serialVersionUID is computed using the signature of a s tream of
* bytes that reflect the class definition. The National Inst itute of
* Standards and Technology (NIST) Secure Hash Algorithm (SH A-1) is
* used to compute a signature for the stream. The first two 32- bit
* quantities are used to form a 64-bit hash. A
* java.lang.DataOutputStream is used to convert primitive data types
* to a sequence of bytes. The values input to the stream are def ined
* by the Java Virtual Machine (VM) specification for classes .
* <p/>
* The sequence of items in the stream is as follows:
* <p/>
* 1. The class name written using UTF encoding.
* 2. The class modifiers written as a 32-bit integer.
* 3. The name of each interface sorted by name written using UT F
* encoding.
* 4. For each field of the class sorted by field name (except
* private static and private transient fields):
* 1. The name of the field in UTF encoding.
* 2. The modifiers of the field written as a 32-bit integer.
* 3. The descriptor of the field in UTF encoding
* 5. If a class initializer exists, write out the following:
* 1. The name of the method, &lt;clinit&gt;, in UTF encoding.
* 2. The modifier of the method, java.lang.reflect.Modifie r.STATIC,
* written as a 32-bit integer.
* 3. The descriptor of the method, ()V, in UTF encoding.
* 6. For each non-private constructor sorted by method name a nd
* signature:
* 1. The name of the method, &lt;init&gt;, in UTF encoding.
* 2. The modifiers of the method written as a 32-bit integer.
* 3. The descriptor of the method in UTF encoding.
* 7. For each non-private method sorted by method name and sig nature:
* 1. The name of the method in UTF encoding.
* 2. The modifiers of the method written as a 32-bit integer.
* 3. The descriptor of the method in UTF encoding.
* 8. The SHA-1 algorithm is executed on the stream of bytes pro duced by
* DataOutputStream and produces five 32-bit values sha[0.. 4].
* <p/>
* 9. The hash value is assembled from the first and second 32-b it
* values of the SHA-1 message digest. If the result of the mess age
* digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of
* five int values named sha, the hash value would be computed a s
* follows:
* <p/>
* long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) |
498 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8 |
* ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 |
* ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 24 |
* ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 |
* ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 40 |
* ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 |
* ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;
* </pre>
*
* @author Rajendra Inamdar, Vishal Vishnoi
*/
public class SerialVersionUIDAdder extends ClassAdapter {
/**
* Flag that indicates if we need to compute SVUID.
*/
protected boolean computeSVUID;
/**
* Set to true if the class already has SVUID.
*/
protected boolean hasSVUID;
/**
* Classes access flags.
*/
protected int access;
/**
* Internal name of the class
*/
protected String name;
/**
* Interfaces implemented by the class.
*/
protected String[] interfaces;
/**
* Collection of fields. (except private static and private t ransient
* fields)
*/
protected Collection svuidFields;
/**
* Set to true if the class has static initializer.
*/
protected boolean hasStaticInitializer;
/**
8.8. SERIALVERSIONUIDADDER.JAVA 499
* Collection of non-private constructors.
*/
protected Collection svuidConstructors;
/**
* Collection of non-private methods.
*/
protected Collection svuidMethods;
/**
* Creates a new {@link SerialVersionUIDAdder}.
*
* @param cv a {@link ClassVisitor} to which this visitor will delegate
* calls.
*/
public SerialVersionUIDAdder(final ClassVisitor cv){
super(cv);
svuidFields = new ArrayList();
svuidConstructors = new ArrayList();
svuidMethods = new ArrayList();
}
// ------------------------------------------------- ------------------
// Overriden methods
// ------------------------------------------------- ------------------
/*
* Visit class header and get class name, access , and interfac es
* informatoin (step 1,2, and 3) for SVUID computation.
*/
public void visit(
final int version,
final int access,
final String name,
final String signature,
final String superName,
final String[] interfaces){
computeSVUID = (access & Opcodes.ACC_INTERFACE) == 0;
if(computeSVUID)
{
this.name = name;
this.access = access;
this.interfaces = interfaces;
}
super.visit(version, access, name, signature, superName , interfaces);
}
500 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
/*
* Visit the methods and get constructor and method informati on
* (step 5 and 7). Also determince if there is a class initializ er
* (step 6).
*/
public MethodVisitor visitMethod(
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions){
if(computeSVUID)
{
if(name.equals("<clinit>"))
{
hasStaticInitializer = true;
}
/*
* Remembers non private constructors and methods for SVUID
* computation For constructor and method modifiers, only th e
* ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,
* ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and
* ACC_STRICT flags are used.
*/
int mods = access
& (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
| Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
| Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED
| Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT
| Opcodes.ACC_STRICT);
// all non private methods
if((access & Opcodes.ACC_PRIVATE) == 0)
{
if(name.equals("<init>"))
{
svuidConstructors.add(new Item(name, mods, desc));
}
else if(!name.equals("<clinit>"))
{
svuidMethods.add(new Item(name, mods, desc));
}
}
}
return cv.visitMethod(access, name, desc, signature, exc eptions);
}
/*
* Gets class field information for step 4 of the alogrithm. Al so
8.8. SERIALVERSIONUIDADDER.JAVA 501
* determines if the class already has a SVUID.
*/
public FieldVisitor visitField(
final int access,
final String name,
final String desc,
final String signature,
final Object value){
if(computeSVUID)
{
if(name.equals("serialVersionUID"))
{
// since the class already has SVUID, we won’t be
// computing it.
computeSVUID = false;
hasSVUID = true;
}
/*
* Remember field for SVUID computation For field modifiers, only
* the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC ,
* ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are use d when
* computing serialVersionUID values.
*/
int mods = access
& (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
| Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
| Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE
| Opcodes.ACC_TRANSIENT);
if((access & Opcodes.ACC_PRIVATE) == 0
|| (access & (Opcodes.ACC_STATIC |
Opcodes.ACC_TRANSIENT)) == 0)
{
svuidFields.add(new Item(name, mods, desc));
}
}
return super.visitField(access, name, desc, signature, v alue);
}
/*
* Add the SVUID if class doesn’t have one
*/
public void visitEnd(){
// compute SVUID and add it to the class
if(computeSVUID && !hasSVUID)
{
try
{
cv.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC,
502 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
"serialVersionUID",
"J",
null,
new Long(computeSVUID()));
}
catch(Throwable e)
{
throw new RuntimeException("Error while computing SVUID f or "
+ name, e);
}
}
super.visitEnd();
}
// ------------------------------------------------- ------------------
// Utility methods
// ------------------------------------------------- ------------------
/**
* Returns the value of SVUID if the class doesn’t have one alre ady.
* Please note that 0 is returned if the class already has SVUID , thus
* use <code>isHasSVUID</code> to determine if the class alr eady had
* an SVUID.
*
* @return Returns the serial version UID
* @throws IOException
*/
protected long computeSVUID() throws IOException{
ByteArrayOutputStream bos = null;
DataOutputStream dos = null;
long svuid = 0;
try
{
bos = new ByteArrayOutputStream();
dos = new DataOutputStream(bos);
/*
* 1. The class name written using UTF encoding.
*/
dos.writeUTF(name.replace(’/’, ’.’));
/*
* 2. The class modifiers written as a 32-bit integer.
*/
dos.writeInt(access
& (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL
| Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));
8.8. SERIALVERSIONUIDADDER.JAVA 503
/*
* 3. The name of each interface sorted by name written using UT F
* encoding.
*/
Arrays.sort(interfaces);
for(int i = 0; i < interfaces.length; i++)
{
dos.writeUTF(interfaces[i].replace(’/’, ’.’));
}
/*
* 4. For each field of the class sorted by field name (except
* private static and private transient fields):
*
* 1. The name of the field in UTF encoding. 2. The modifiers
* of the field written as a 32-bit integer. 3. The descriptor
* of the field in UTF encoding
*
* Note that field signatutes are not dot separated. Method an d
* constructor signatures are dot separated. Go figure...
*/
writeItems(svuidFields, dos, false);
/*
* 5. If a class initializer exists, write out the following: 1 .
* The name of the method, <clinit>, in UTF encoding. 2. The
* modifier of the method, java.lang.reflect.Modifier.STA TIC,
* written as a 32-bit integer. 3. The descriptor of the method ,
* ()V, in UTF encoding.
*/
if(hasStaticInitializer)
{
dos.writeUTF("<clinit>");
dos.writeInt(Opcodes.ACC_STATIC);
dos.writeUTF("()V");
} // if..
/*
* 6. For each non-private constructor sorted by method name
* and signature: 1. The name of the method, <init>, in UTF
* encoding. 2. The modifiers of the method written as a
* 32-bit integer. 3. The descriptor of the method in UTF
* encoding.
*/
writeItems(svuidConstructors, dos, true);
/*
* 7. For each non-private method sorted by method name and
* signature: 1. The name of the method in UTF encoding. 2. The
* modifiers of the method written as a 32-bit integer. 3. The
504 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
* descriptor of the method in UTF encoding.
*/
writeItems(svuidMethods, dos, true);
dos.flush();
/*
* 8. The SHA-1 algorithm is executed on the stream of bytes
* produced by DataOutputStream and produces five 32-bit val ues
* sha[0..4].
*/
byte[] hashBytes = computeSHAdigest(bos.toByteArray()) ;
/*
* 9. The hash value is assembled from the first and second
* 32-bit values of the SHA-1 message digest. If the result
* of the message digest, the five 32-bit words H0 H1 H2 H3 H4,
* is in an array of five int values named sha, the hash value
* would be computed as follows:
*
* long hash = ((sha[0] >>> 24) & 0xFF) |
* ((sha[0] >>> 16) & 0xFF) << 8 |
* ((sha[0] >>> 8) & 0xFF) << 16 |
* ((sha[0] >>> 0) & 0xFF) << 24 |
* ((sha[1] >>> 24) & 0xFF) << 32 |
* ((sha[1] >>> 16) & 0xFF) << 40 |
* ((sha[1] >>> 8) & 0xFF) << 48 |
* ((sha[1] >>> 0) & 0xFF) << 56;
*/
for(int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--)
{
svuid = (svuid << 8) | (hashBytes[i] & 0xFF);
}
}
finally
{
// close the stream (if open)
if(dos != null)
{
dos.close();
}
}
return svuid;
}
/**
* Returns the SHA-1 message digest of the given value.
*
* @param value the value whose SHA message digest must be comp uted.
8.8. SERIALVERSIONUIDADDER.JAVA 505
* @return the SHA-1 message digest of the given value.
*/
protected byte[] computeSHAdigest(final byte[] value){
try
{
return MessageDigest.getInstance("SHA").digest(value );
}
catch(Exception e)
{
throw new UnsupportedOperationException(e);
}
}
/**
* Sorts the items in the collection and writes it to the data ou tput
* stream
*
* @param itemCollection collection of items
* @param dos a <code>DataOutputStream</code> value
* @param dotted a <code>boolean</code> value
* @throws IOException if an error occurs
*/
private void writeItems(
final Collection itemCollection,
final DataOutputStream dos,
final boolean dotted) throws IOException{
int size = itemCollection.size();
Item items[] = (Item[]) itemCollection.toArray(new Item[ size]);
Arrays.sort(items);
for(int i = 0; i < size; i++)
{
dos.writeUTF(items[i].name);
dos.writeInt(items[i].access);
dos.writeUTF(dotted
? items[i].desc.replace(’/’, ’.’)
: items[i].desc);
}
}
// ------------------------------------------------- ------------------
// Inner classes
// ------------------------------------------------- ------------------
static class Item implements Comparable{
String name;
int access;
String desc;
506 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
Item(final String name, final int access, final String desc ){
this.name = name;
this.access = access;
this.desc = desc;
}
public int compareTo(final Object o){
Item other = (Item) o;
int retVal = name.compareTo(other.name);
if(retVal == 0)
{
retVal = desc.compareTo(other.desc);
}
return retVal;
}
}
}
———-
8.9 StaticInitMerger.java
(ClassAdapter [183])
— StaticInitMerger.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import clojure.asm.ClassAdapter;
import clojure.asm.ClassVisitor;
import clojure.asm.MethodVisitor;
import clojure.asm.Opcodes;
/**
* A {@link ClassAdapter} that merges clinit methods into a si ngle one.
*
* @author Eric Bruneton
*/
public class StaticInitMerger extends ClassAdapter{
private String name;
private MethodVisitor clinit;
private String prefix;
private int counter;
8.9. STATICINITMERGER.JAVA 507
public StaticInitMerger(final String prefix, final Class Visitor cv){
super(cv);
this.prefix = prefix;
}
public void visit(
final int version,
final int access,
final String name,
final String signature,
final String superName,
final String[] interfaces){
cv.visit(version, access, name, signature, superName, in terfaces);
this.name = name;
}
public MethodVisitor visitMethod(
final int access,
final String name,
final String desc,
final String signature,
final String[] exceptions){
MethodVisitor mv;
if(name.equals("<clinit>"))
{
int a = Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC;
String n = prefix + counter++;
mv = cv.visitMethod(a, n, desc, signature, exceptions);
if(clinit == null)
{
clinit = cv.visitMethod(a, name, desc, null, null);
}
clinit.visitMethodInsn(Opcodes.INVOKESTATIC, this.na me, n, desc);
}
else
{
mv = cv.visitMethod(access, name, desc, signature, except ions);
}
return mv;
}
public void visitEnd(){
if(clinit != null)
{
clinit.visitInsn(Opcodes.RETURN);
clinit.visitMaxs(0, 0);
}
cv.visitEnd();
508 CHAPTER 8. JVM/CLOJURE/ASM/COMMONS
}
}
———-
8.10 TableSwitchGenerator.java
— TableSwitchGenerator.java —
\getchunk{France Telecom Copyright}
package clojure.asm.commons;
import clojure.asm.Label;
/**
* A code generator for switch statements.
*
* @author Juozas Baliuka
* @author Chris Nokleberg
* @author Eric Bruneton
*/
public interface TableSwitchGenerator{
/**
* Generates the code for a switch case.
*
* @param key the switch case key.
* @param end a label that corresponds to the end of the switch
* statement.
*/
void generateCase(int key, Label end);
/**
* Generates the code for the default switch case.
*/
void generateDefault();
}
———-
Chapter 9
jvm/clojure/lang/
9.1 AFn.java
(IFn [774])
— AFn.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 25, 2006 4:05:37 PM */
package clojure.lang;
public abstract class AFn implements IFn {
public Object call() throws Exception{
return invoke();
}
public void run(){
try
{
invoke();
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
public Object invoke()
509
510 CHAPTER 9. JVM/CLOJURE/LANG/
throws Exception{
return throwArity(0);
}
public Object invoke(Object arg1)
throws Exception{
return throwArity(1);
}
public Object invoke(Object arg1, Object arg2)
throws Exception{
return throwArity(2);
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
return throwArity(3);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
return throwArity(4);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
return throwArity(5);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
return throwArity(6);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
return throwArity(7);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8) throws Exception{
return throwArity(8);
}
9.1. AFN.JAVA 511
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
return throwArity(9);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception{
return throwArity(10);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
return throwArity(11);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
return throwArity(12);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
return throwArity(13);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
return throwArity(14);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
512 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
return throwArity(15);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
return throwArity(16);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
return throwArity(17);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
throws Exception{
return throwArity(18);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
return throwArity(19);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
9.1. AFN.JAVA 513
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
return throwArity(20);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
throws Exception{
return throwArity(21);
}
public Object applyTo(ISeq arglist) throws Exception{
return applyToHelper(this, Util.ret1(arglist,arglist = null));
}
static public Object applyToHelper(IFn ifn, ISeq arglist)
throws Exception{
switch(RT.boundedLength(arglist, 20))
{
case 0:
arglist = null;
return ifn.invoke();
case 1:
Object a1 = arglist.first();
arglist = null;
return ifn.invoke(a1);
case 2:
return ifn.invoke(arglist.first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 3:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 4:
return ifn.invoke(arglist.first()
514 CHAPTER 9. JVM/CLOJURE/LANG/
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 5:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 6:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 7:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 8:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 9:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
9.1. AFN.JAVA 515
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 10:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 11:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 12:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 13:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
516 CHAPTER 9. JVM/CLOJURE/LANG/
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 14:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 15:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 16:
return ifn.invoke(arglist.first()
9.1. AFN.JAVA 517
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 17:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 18:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
518 CHAPTER 9. JVM/CLOJURE/LANG/
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 19:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
case 20:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
9.2. AFUNCTION.JAVA 519
, Util.ret1(
(arglist = arglist.next()).first(),arglist = null)
);
default:
return ifn.invoke(arglist.first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, (arglist = arglist.next()).first()
, RT.seqToArray(
Util.ret1(arglist.next(),arglist = null)));
}
}
public Object throwArity(int n){
String name = getClass().getSimpleName();
int suffix = name.lastIndexOf("__");
throw new ArityException(n,
(suffix == -1
? name
: name.substring(0, suffix)).replace(’_’, ’-’));
}
}
———-
9.2 AFunction.java
(AFn [509]) (IObj [800]) (Comparator [1723]) (Fn [772]) (Serializable [17 23])
— AFunction.java —
/*
\getchunk{Clojure Copyright}
520 CHAPTER 9. JVM/CLOJURE/LANG/
*/
/* rich Dec 16, 2008 */
package clojure.lang;
import java.io.Serializable;
import java.util.Comparator;
public abstract class AFunction
extends AFn
implements IObj, Comparator, Fn, Serializable {
public volatile MethodImplCache __methodImplCache;
public int compare(Object o1, Object o2){
try
{
Object o = invoke(o1, o2);
if(o instanceof Boolean)
{
if(RT.booleanCast(o))
return -1;
return RT.booleanCast(invoke(o2,o1))? 1 : 0;
}
Number n = (Number) o;
return n.intValue();
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
}
———-
9.3 Agent.java
(ARef [553])
— Agent.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 17, 2007 */
9.3. AGENT.JAVA 521
package clojure.lang;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
public class Agent extends ARef {
static class ActionQueue {
public final IPersistentStack q;
public final Throwable error; // non-null indicates fail st ate
static final ActionQueue EMPTY =
new ActionQueue(PersistentQueue.EMPTY, null);
public ActionQueue( IPersistentStack q, Throwable error )
{
this.q = q;
this.error = error;
}
}
static final Keyword CONTINUE = Keyword.intern(null, "con tinue");
static final Keyword FAIL = Keyword.intern(null, "fail");
volatile Object state;
AtomicReference<ActionQueue> aq =
new AtomicReference<ActionQueue>(ActionQueue.EMPTY);
volatile Keyword errorMode = CONTINUE;
volatile IFn errorHandler = null;
final private static AtomicLong sendThreadPoolCounter =
new AtomicLong(0);
final private static AtomicLong sendOffThreadPoolCounte r =
new AtomicLong(0);
final public static ExecutorService pooledExecutor =
Executors.newFixedThreadPool(
2 + Runtime.getRuntime().availableProcessors(),
createThreadFactory("clojure-agent-send-pool-%d",
sendThreadPoolCounter));
final public static ExecutorService soloExecutor =
Executors.newCachedThreadPool(
createThreadFactory("clojure-agent-send-off-pool-%d ",
sendOffThreadPoolCounter));
522 CHAPTER 9. JVM/CLOJURE/LANG/
final static ThreadLocal<IPersistentVector> nested =
new ThreadLocal<IPersistentVector>();
private static ThreadFactory
createThreadFactory(final String format,
final AtomicLong threadPoolCounter) {
return new ThreadFactory() {
public Thread newThread(Runnable runnable) {
Thread thread = new Thread(runnable);
thread.setName(String.format(format,
threadPoolCounter.getAndIncrement()));
return thread;
}
};
}
public static void shutdown(){
soloExecutor.shutdown();
pooledExecutor.shutdown();
}
static class Action implements Runnable{
final Agent agent;
final IFn fn;
final ISeq args;
final boolean solo;
public Action(Agent agent, IFn fn, ISeq args, boolean solo) {
this.agent = agent;
this.args = args;
this.fn = fn;
this.solo = solo;
}
void execute(){
try
{
if(solo)
soloExecutor.execute(this);
else
pooledExecutor.execute(this);
}
catch(Throwable error)
{
if(agent.errorHandler != null)
{
try
{
agent.errorHandler.invoke(agent, error);
9.3. AGENT.JAVA 523
}
catch(Throwable e) {} // ignore errorHandler errors
}
}
}
static void doRun(Action action){
try
{
nested.set(PersistentVector.EMPTY);
Throwable error = null;
try
{
Object oldval = action.agent.state;
Object newval =
action.fn.applyTo(
RT.cons(action.agent.state, action.args));
action.agent.setState(newval);
action.agent.notifyWatches(oldval,newval);
}
catch(Throwable e)
{
error = e;
}
if(error == null)
{
releasePendingSends();
}
else
{
nested.set(null); // allow errorHandler to send
if(action.agent.errorHandler != null)
{
try
{
action.agent.errorHandler.invoke(action.agent,
error);
}
catch(Throwable e) {} // ignore errorHandler errors
}
if(action.agent.errorMode == CONTINUE)
{
error = null;
}
}
boolean popped = false;
ActionQueue next = null;
524 CHAPTER 9. JVM/CLOJURE/LANG/
while(!popped)
{
ActionQueue prior = action.agent.aq.get();
next = new ActionQueue(prior.q.pop(), error);
popped = action.agent.aq.compareAndSet(prior, next);
}
if(error == null && next.q.count() > 0)
((Action) next.q.peek()).execute();
}
finally
{
nested.set(null);
}
}
public void run(){
doRun(this);
}
}
public Agent(Object state) throws Exception{
this(state,null);
}
public Agent(Object state, IPersistentMap meta) throws Ex ception {
super(meta);
setState(state);
}
boolean setState(Object newState) throws Exception{
validate(newState);
boolean ret = state != newState;
state = newState;
return ret;
}
public Object deref() throws Exception{
return state;
}
public Throwable getError(){
return aq.get().error;
}
public void setErrorMode(Keyword k){
errorMode = k;
}
public Keyword getErrorMode(){
9.3. AGENT.JAVA 525
return errorMode;
}
public void setErrorHandler(IFn f){
errorHandler = f;
}
public IFn getErrorHandler(){
return errorHandler;
}
synchronized public Object restart(Object newState,
boolean clearActions){
if(getError() == null)
{
throw new RuntimeException("Agent does not need a restart" );
}
validate(newState);
state = newState;
if(clearActions)
aq.set(ActionQueue.EMPTY);
else
{
boolean restarted = false;
ActionQueue prior = null;
while(!restarted)
{
prior = aq.get();
restarted =
aq.compareAndSet(prior, new ActionQueue(prior.q, null) );
}
if(prior.q.count() > 0)
((Action) prior.q.peek()).execute();
}
return newState;
}
public Object dispatch(IFn fn, ISeq args, boolean solo) {
Throwable error = getError();
if(error != null)
{
throw new RuntimeException("Agent is failed, needs restar t",
error);
}
Action action = new Action(this, fn, args, solo);
dispatchAction(action);
526 CHAPTER 9. JVM/CLOJURE/LANG/
return this;
}
static void dispatchAction(Action action){
LockingTransaction trans = LockingTransaction.getRunni ng();
if(trans != null)
trans.enqueue(action);
else if(nested.get() != null)
{
nested.set(nested.get().cons(action));
}
else
action.agent.enqueue(action);
}
void enqueue(Action action){
boolean queued = false;
ActionQueue prior = null;
while(!queued)
{
prior = aq.get();
queued =
aq.compareAndSet(prior,
new ActionQueue((IPersistentStack)prior.q.cons(actio n),
prior.error));
}
if(prior.q.count() == 0 && prior.error == null)
action.execute();
}
public int getQueueCount(){
return aq.get().q.count();
}
static public int releasePendingSends(){
IPersistentVector sends = nested.get();
if(sends == null)
return 0;
for(int i=0;i<sends.count();i++)
{
Action a = (Action) sends.valAt(i);
a.agent.enqueue(a);
}
nested.set(PersistentVector.EMPTY);
return sends.count();
}
}
———-
9.4. AMAPENTRY.JAVA 527
9.4 AMapEntry.java
(APersistentVector [541]) (IMapEntry [798])
— AMapEntry.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 1, 2008 */
package clojure.lang;
import java.io.StringWriter;
public abstract class AMapEntry
extends APersistentVector implements IMapEntry{
public Object nth(int i){
if(i == 0)
return key();
else if(i == 1)
return val();
else
throw new IndexOutOfBoundsException();
}
private IPersistentVector asVector(){
return LazilyPersistentVector.createOwning(key(), val ());
}
public IPersistentVector assocN(int i, Object val){
return asVector().assocN(i, val);
}
public int count(){
return 2;
}
public ISeq seq(){
return asVector().seq();
}
public IPersistentVector cons(Object o){
return asVector().cons(o);
}
public IPersistentCollection empty(){
return null;
}
528 CHAPTER 9. JVM/CLOJURE/LANG/
public IPersistentStack pop(){
return LazilyPersistentVector.createOwning(key());
}
public Object setValue(Object value){
throw new UnsupportedOperationException();
}
/*
public boolean equals(Object obj){
return APersistentVector.doEquals(this, obj);
}
public int hashCode(){
//must match logic in APersistentVector
return 31 * (31 + Util.hash(key())) + Util.hash(val());
// return Util.hashCombine(
Util.hashCombine(0, Util.hash(key())), Util.hash(val( )));
}
public String toString(){
StringWriter sw = new StringWriter();
try
{
RT.print(this, sw);
}
catch(Exception e)
{
//checked exceptions stink!
throw new RuntimeException(e);
}
return sw.toString();
}
public int length(){
return 2;
}
public Object nth(int i){
if(i == 0)
return key();
else if(i == 1)
return val();
else
throw new IndexOutOfBoundsException();
}
private IPersistentVector asVector(){
9.4. AMAPENTRY.JAVA 529
return LazilyPersistentVector.createOwning(key(), val ());
}
public IPersistentVector assocN(int i, Object val){
return asVector().assocN(i, val);
}
public int count(){
return 2;
}
public ISeq seq(){
return asVector().seq();
}
public IPersistentVector cons(Object o){
return asVector().cons(o);
}
public boolean containsKey(Object key){
return asVector().containsKey(key);
}
public IMapEntry entryAt(Object key){
return asVector().entryAt(key);
}
public Associative assoc(Object key, Object val){
return asVector().assoc(key, val);
}
public Object valAt(Object key){
return asVector().valAt(key);
}
public Object valAt(Object key, Object notFound){
return asVector().valAt(key, notFound);
}
public Object peek(){
return val();
}
public ISeq rseq() throws Exception{
return asVector().rseq();
}
*/
}
530 CHAPTER 9. JVM/CLOJURE/LANG/
———-
9.5 APersistentMap.java
(AFn [509]) (IPersistentMap [801]) (Map [1723]) (Iterable [1723]) (S erializable
[1723]) (MapEquivalence [850])
— APersistentMap.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.Serializable;
import java.util.*;
public abstract class APersistentMap
extends AFn
implements IPersistentMap, Map, Iterable, Serializable,
MapEquivalence {
int _hash = -1;
public String toString(){
return RT.printString(this);
}
public IPersistentCollection cons(Object o){
if(o instanceof Map.Entry)
{
Map.Entry e = (Map.Entry) o;
return assoc(e.getKey(), e.getValue());
}
else if(o instanceof IPersistentVector)
{
IPersistentVector v = (IPersistentVector) o;
if(v.count() != 2)
throw new IllegalArgumentException(
"Vector arg to map conj must be a pair");
return assoc(v.nth(0), v.nth(1));
}
IPersistentMap ret = this;
for(ISeq es = RT.seq(o); es != null; es = es.next())
{
Map.Entry e = (Map.Entry) es.first();
ret = ret.assoc(e.getKey(), e.getValue());
}
9.5. APERSISTENTMAP.JAVA 531
return ret;
}
public boolean equals(Object obj){
return mapEquals(this, obj);
}
static public boolean mapEquals(IPersistentMap m1, Objec t obj){
if(m1 == obj) return true;
if(!(obj instanceof Map))
return false;
Map m = (Map) obj;
if(m.size() != m1.count() || m.hashCode() != m1.hashCode( ))
return false;
for(ISeq s = m1.seq(); s != null; s = s.next())
{
Map.Entry e = (Map.Entry) s.first();
boolean found = m.containsKey(e.getKey());
if(!found ||
!Util.equals(e.getValue(), m.get(e.getKey())))
return false;
}
return true;
}
public boolean equiv(Object obj){
if(!(obj instanceof Map))
return false;
if(obj instanceof IPersistentMap &&
!(obj instanceof MapEquivalence))
return false;
Map m = (Map) obj;
if(m.size() != size())
return false;
for(ISeq s = seq(); s != null; s = s.next())
{
Map.Entry e = (Map.Entry) s.first();
boolean found = m.containsKey(e.getKey());
if(!found ||
!Util.equiv(e.getValue(), m.get(e.getKey())))
return false;
}
532 CHAPTER 9. JVM/CLOJURE/LANG/
return true;
}
public int hashCode(){
if(_hash == -1)
{
this._hash = mapHash(this);
}
return _hash;
}
static public int mapHash(IPersistentMap m){
int hash = 0;
for(ISeq s = m.seq(); s != null; s = s.next())
{
Map.Entry e = (Map.Entry) s.first();
hash += (e.getKey() == null ? 0 :
e.getKey().hashCode()) ^
(e.getValue() == null ? 0 : e.getValue().hashCode());
}
return hash;
}
static public class KeySeq extends ASeq{
ISeq seq;
static public KeySeq create(ISeq seq){
if(seq == null)
return null;
return new KeySeq(seq);
}
private KeySeq(ISeq seq){
this.seq = seq;
}
private KeySeq(IPersistentMap meta, ISeq seq){
super(meta);
this.seq = seq;
}
public Object first(){
return ((Map.Entry) seq.first()).getKey();
}
public ISeq next(){
return create(seq.next());
}
public KeySeq withMeta(IPersistentMap meta){
9.5. APERSISTENTMAP.JAVA 533
return new KeySeq(meta, seq);
}
}
static public class ValSeq extends ASeq{
ISeq seq;
static public ValSeq create(ISeq seq){
if(seq == null)
return null;
return new ValSeq(seq);
}
private ValSeq(ISeq seq){
this.seq = seq;
}
private ValSeq(IPersistentMap meta, ISeq seq){
super(meta);
this.seq = seq;
}
public Object first(){
return ((Map.Entry) seq.first()).getValue();
}
public ISeq next(){
return create(seq.next());
}
public ValSeq withMeta(IPersistentMap meta){
return new ValSeq(meta, seq);
}
}
public Object invoke(Object arg1) throws Exception{
return valAt(arg1);
}
public Object invoke(Object arg1, Object notFound) throws Exception{
return valAt(arg1, notFound);
}
// java.util.Map implementation
public void clear(){
throw new UnsupportedOperationException();
}
534 CHAPTER 9. JVM/CLOJURE/LANG/
public boolean containsValue(Object value){
return values().contains(value);
}
public Set entrySet(){
return new AbstractSet(){
public Iterator iterator(){
return APersistentMap.this.iterator();
}
public int size(){
return count();
}
public int hashCode(){
return APersistentMap.this.hashCode();
}
public boolean contains(Object o){
if(o instanceof Entry)
{
Entry e = (Entry) o;
Entry found = entryAt(e.getKey());
if(found != null &&
Util.equals(found.getValue(), e.getValue()))
return true;
}
return false;
}
};
}
public Object get(Object key){
return valAt(key);
}
public boolean isEmpty(){
return count() == 0;
}
public Set keySet(){
return new AbstractSet(){
public Iterator iterator(){
final Iterator mi = APersistentMap.this.iterator();
return new Iterator(){
9.5. APERSISTENTMAP.JAVA 535
public boolean hasNext(){
return mi.hasNext();
}
public Object next(){
Entry e = (Entry) mi.next();
return e.getKey();
}
public void remove(){
throw new UnsupportedOperationException();
}
};
}
public int size(){
return count();
}
public boolean contains(Object o){
return APersistentMap.this.containsKey(o);
}
};
}
public Object put(Object key, Object value){
throw new UnsupportedOperationException();
}
public void putAll(Map t){
throw new UnsupportedOperationException();
}
public Object remove(Object key){
throw new UnsupportedOperationException();
}
public int size(){
return count();
}
public Collection values(){
return new AbstractCollection(){
public Iterator iterator(){
final Iterator mi = APersistentMap.this.iterator();
return new Iterator(){
536 CHAPTER 9. JVM/CLOJURE/LANG/
public boolean hasNext(){
return mi.hasNext();
}
public Object next(){
Entry e = (Entry) mi.next();
return e.getValue();
}
public void remove(){
throw new UnsupportedOperationException();
}
};
}
public int size(){
return count();
}
};
}
/*
// java.util.Collection implementation
public Object[] toArray(){
return RT.seqToArray(seq());
}
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
9.5. APERSISTENTMAP.JAVA 537
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(!contains(o))
return false;
}
return true;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.rest())
{
a[i] = s.first();
}
if(a.length > count())
a[count()] = null;
return a;
}
else
return toArray();
}
public int size(){
return count();
}
public boolean isEmpty(){
return count() == 0;
}
public boolean contains(Object o){
if(o instanceof Map.Entry)
{
Map.Entry e = (Map.Entry) o;
Map.Entry v = entryAt(e.getKey());
return (v != null && Util.equal(v.getValue(), e.getValue( )));
}
return false;
}
*/
}
———-
538 CHAPTER 9. JVM/CLOJURE/LANG/
9.6 APersistentSet.java
(AFn [509]) (IPersistentSet [802]) (Collection [1723]) (Set [1723]) (S erializable
[1723])
— APersistentSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;
public abstract class APersistentSet
extends AFn
implements IPersistentSet, Collection, Set, Serializabl e {
int _hash = -1;
final IPersistentMap impl;
protected APersistentSet(IPersistentMap impl){
this.impl = impl;
}
public String toString(){
return RT.printString(this);
}
public boolean contains(Object key){
return impl.containsKey(key);
}
public Object get(Object key){
return impl.valAt(key);
}
public int count(){
return impl.count();
}
public ISeq seq(){
return RT.keys(impl);
}
public Object invoke(Object arg1) throws Exception{
9.6. APERSISTENTSET.JAVA 539
return get(arg1);
}
public boolean equals(Object obj){
if(this == obj) return true;
if(!(obj instanceof Set))
return false;
Set m = (Set) obj;
if(m.size() != count() || m.hashCode() != hashCode())
return false;
for(Object aM : m)
{
if(!contains(aM))
return false;
}
// for(ISeq s = seq(); s != null; s = s.rest())
// {
// if(!m.contains(s.first()))
// return false;
// }
return true;
}
public boolean equiv(Object o){
return equals(o);
}
public int hashCode(){
if(_hash == -1)
{
//int hash = count();
int hash = 0;
for(ISeq s = seq(); s != null; s = s.next())
{
Object e = s.first();
// hash = Util.hashCombine(hash, Util.hash(e));
hash += Util.hash(e);
}
this._hash = hash;
}
return _hash;
}
public Object[] toArray(){
return RT.seqToArray(seq());
}
540 CHAPTER 9. JVM/CLOJURE/LANG/
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(!contains(o))
return false;
}
return true;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.next())
{
a[i] = s.first();
}
if(a.length > count())
a[count()] = null;
return a;
}
else
return toArray();
}
public int size(){
9.7. APERSISTENTVECTOR.JAVA 541
return count();
}
public boolean isEmpty(){
return count() == 0;
}
public Iterator iterator(){
return new SeqIterator(seq());
}
}
———-
9.7 APersistentVector.java
(AFn [509]) (IPersistentVector[802]) (Iterable [1723]) (List [1723 ]) (RandomAc-
cess [1723]) (Comparable [1723]) (Serializable [1723])
— APersistentVector.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 18, 2007 */
package clojure.lang;
import java.io.Serializable;
import java.util.*;
public abstract class APersistentVector
extends AFn
implements IPersistentVector, Iterable, List, RandomAcc ess,
Comparable, Serializable {
int _hash = -1;
public String toString(){
return RT.printString(this);
}
public ISeq seq(){
if(count() > 0)
return new Seq(this, 0);
return null;
}
public ISeq rseq(){
542 CHAPTER 9. JVM/CLOJURE/LANG/
if(count() > 0)
return new RSeq(this, count() - 1);
return null;
}
static boolean doEquals(IPersistentVector v, Object obj) {
if(v == obj) return true;
if(obj instanceof List || obj instanceof IPersistentVecto r)
{
Collection ma = (Collection) obj;
if(ma.size() != v.count() || ma.hashCode() != v.hashCode( ))
return false;
for(Iterator i1 = ((List) v).iterator(), i2 = ma.iterator( );
i1.hasNext();)
{
if(!Util.equals(i1.next(), i2.next()))
return false;
}
return true;
}
// if(obj instanceof IPersistentVector)
// {
// IPersistentVector ma = (IPersistentVector) obj;
// if(ma.count() != v.count() || ma.hashCode() != v.hashCo de())
// return false;
// for(int i = 0; i < v.count(); i++)
// {
// if(!Util.equal(v.nth(i), ma.nth(i)))
// return false;
// }
// }
else
{
if(!(obj instanceof Sequential))
return false;
ISeq ms = RT.seq(obj);
for(int i = 0; i < v.count(); i++, ms = ms.next())
{
if(ms == null || !Util.equals(v.nth(i), ms.first()))
return false;
}
if(ms != null)
return false;
}
return true;
}
static boolean doEquiv(IPersistentVector v, Object obj){
9.7. APERSISTENTVECTOR.JAVA 543
if(obj instanceof List || obj instanceof IPersistentVecto r)
{
Collection ma = (Collection) obj;
if(ma.size() != v.count())
return false;
for(Iterator i1 = ((List) v).iterator(), i2 = ma.iterator( );
i1.hasNext();)
{
if(!Util.equiv(i1.next(), i2.next()))
return false;
}
return true;
}
// if(obj instanceof IPersistentVector)
// {
// IPersistentVector ma = (IPersistentVector) obj;
// if(ma.count() != v.count() || ma.hashCode() != v.hashCo de())
// return false;
// for(int i = 0; i < v.count(); i++)
// {
// if(!Util.equal(v.nth(i), ma.nth(i)))
// return false;
// }
// }
else
{
if(!(obj instanceof Sequential))
return false;
ISeq ms = RT.seq(obj);
for(int i = 0; i < v.count(); i++, ms = ms.next())
{
if(ms == null || !Util.equiv(v.nth(i), ms.first()))
return false;
}
if(ms != null)
return false;
}
return true;
}
public boolean equals(Object obj){
return doEquals(this, obj);
}
public boolean equiv(Object obj){
return doEquiv(this, obj);
}
544 CHAPTER 9. JVM/CLOJURE/LANG/
public int hashCode(){
if(_hash == -1)
{
int hash = 1;
Iterator i = iterator();
while(i.hasNext())
{
Object obj = i.next();
hash = 31 * hash + (obj == null ? 0 : obj.hashCode());
}
// int hash = 0;
// for(int i = 0; i < count(); i++)
// {
// hash = Util.hashCombine(hash, Util.hash(nth(i)));
// }
this._hash = hash;
}
return _hash;
}
public Object get(int index){
return nth(index);
}
public Object nth(int i, Object notFound){
if(i >= 0 && i < count())
return nth(i);
return notFound;
}
public Object remove(int i){
throw new UnsupportedOperationException();
}
public int indexOf(Object o){
for(int i = 0; i < count(); i++)
if(Util.equiv(nth(i), o))
return i;
return -1;
}
public int lastIndexOf(Object o){
for(int i = count() - 1; i >= 0; i--)
if(Util.equiv(nth(i), o))
return i;
return -1;
}
public ListIterator listIterator(){
return listIterator(0);
9.7. APERSISTENTVECTOR.JAVA 545
}
public ListIterator listIterator(final int index){
return new ListIterator(){
int nexti = index;
public boolean hasNext(){
return nexti < count();
}
public Object next(){
return nth(nexti++);
}
public boolean hasPrevious(){
return nexti > 0;
}
public Object previous(){
return nth(--nexti);
}
public int nextIndex(){
return nexti;
}
public int previousIndex(){
return nexti - 1;
}
public void remove(){
throw new UnsupportedOperationException();
}
public void set(Object o){
throw new UnsupportedOperationException();
}
public void add(Object o){
throw new UnsupportedOperationException();
}
};
}
public List subList(int fromIndex, int toIndex){
return (List) RT.subvec(this, fromIndex, toIndex);
}
public Object set(int i, Object o){
546 CHAPTER 9. JVM/CLOJURE/LANG/
throw new UnsupportedOperationException();
}
public void add(int i, Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(int i, Collection c){
throw new UnsupportedOperationException();
}
public Object invoke(Object arg1) throws Exception{
if(Util.isInteger(arg1))
return nth(((Number) arg1).intValue());
throw new IllegalArgumentException("Key must be integer" );
}
public Iterator iterator(){
//todo - something more efficient
return new Iterator(){
int i = 0;
public boolean hasNext(){
return i < count();
}
public Object next(){
return nth(i++);
}
public void remove(){
throw new UnsupportedOperationException();
}
};
}
public Object peek(){
if(count() > 0)
return nth(count() - 1);
return null;
}
public boolean containsKey(Object key){
if(!(Util.isInteger(key)))
return false;
int i = ((Number) key).intValue();
return i >= 0 && i < count();
}
9.7. APERSISTENTVECTOR.JAVA 547
public IMapEntry entryAt(Object key){
if(Util.isInteger(key))
{
int i = ((Number) key).intValue();
if(i >= 0 && i < count())
return new MapEntry(key, nth(i));
}
return null;
}
public IPersistentVector assoc(Object key, Object val){
if(Util.isInteger(key))
{
int i = ((Number) key).intValue();
return assocN(i, val);
}
throw new IllegalArgumentException("Key must be integer" );
}
public Object valAt(Object key, Object notFound){
if(Util.isInteger(key))
{
int i = ((Number) key).intValue();
if(i >= 0 && i < count())
return nth(i);
}
return notFound;
}
public Object valAt(Object key){
return valAt(key, null);
}
// java.util.Collection implementation
public Object[] toArray(){
return RT.seqToArray(seq());
}
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
548 CHAPTER 9. JVM/CLOJURE/LANG/
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(!contains(o))
return false;
}
return true;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.next())
{
a[i] = s.first();
}
if(a.length > count())
a[count()] = null;
return a;
}
else
return toArray();
}
public int size(){
return count();
}
public boolean isEmpty(){
return count() == 0;
}
public boolean contains(Object o){
for(ISeq s = seq(); s != null; s = s.next())
{
if(Util.equiv(s.first(), o))
9.7. APERSISTENTVECTOR.JAVA 549
return true;
}
return false;
}
public int length(){
return count();
}
public int compareTo(Object o){
IPersistentVector v = (IPersistentVector) o;
if(count() < v.count())
return -1;
else if(count() > v.count())
return 1;
for(int i = 0; i < count(); i++)
{
int c = Util.compare(nth(i),v.nth(i));
if(c != 0)
return c;
}
return 0;
}
static class Seq extends ASeq implements IndexedSeq, IRedu ce{
//todo - something more efficient
final IPersistentVector v;
final int i;
public Seq(IPersistentVector v, int i){
this.v = v;
this.i = i;
}
Seq(IPersistentMap meta, IPersistentVector v, int i){
super(meta);
this.v = v;
this.i = i;
}
public Object first(){
return v.nth(i);
}
public ISeq next(){
if(i + 1 < v.count())
return new APersistentVector.Seq(v, i + 1);
return null;
}
550 CHAPTER 9. JVM/CLOJURE/LANG/
public int index(){
return i;
}
public int count(){
return v.count() - i;
}
public APersistentVector.Seq withMeta(IPersistentMap m eta){
return new APersistentVector.Seq(meta, v, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = v.nth(i);
for(int x = i + 1; x < v.count(); x++)
ret = f.invoke(ret, v.nth(x));
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, v.nth(i));
for(int x = i + 1; x < v.count(); x++)
ret = f.invoke(ret, v.nth(x));
return ret;
}
}
public static class RSeq extends ASeq implements IndexedSe q, Counted{
final IPersistentVector v;
final int i;
public RSeq(IPersistentVector vector, int i){
this.v = vector;
this.i = i;
}
RSeq(IPersistentMap meta, IPersistentVector v, int i){
super(meta);
this.v = v;
this.i = i;
}
public Object first(){
return v.nth(i);
}
public ISeq next(){
if(i > 0)
return new APersistentVector.RSeq(v, i - 1);
9.7. APERSISTENTVECTOR.JAVA 551
return null;
}
public int index(){
return i;
}
public int count(){
return i + 1;
}
public APersistentVector.RSeq withMeta(IPersistentMap meta){
return new APersistentVector.RSeq(meta, v, i);
}
}
static class SubVector extends APersistentVector impleme nts IObj{
final IPersistentVector v;
final int start;
final int end;
final IPersistentMap _meta;
public SubVector(IPersistentMap meta,
IPersistentVector v,
int start,
int end){
this._meta = meta;
if(v instanceof APersistentVector.SubVector)
{
APersistentVector.SubVector sv =
(APersistentVector.SubVector) v;
start += sv.start;
end += sv.start;
v = sv.v;
}
this.v = v;
this.start = start;
this.end = end;
}
public Object nth(int i){
if(start + i >= end)
throw new IndexOutOfBoundsException();
return v.nth(start + i);
}
public IPersistentVector assocN(int i, Object val){
552 CHAPTER 9. JVM/CLOJURE/LANG/
if(start + i > end)
throw new IndexOutOfBoundsException();
else if(start + i == end)
return cons(val);
return
new SubVector(_meta, v.assocN(start + i, val), start, end) ;
}
public int count(){
return end - start;
}
public IPersistentVector cons(Object o){
return new SubVector(_meta, v.assocN(end, o), start, end + 1);
}
public IPersistentCollection empty(){
return PersistentVector.EMPTY.withMeta(meta());
}
public IPersistentStack pop(){
if(end - 1 == start)
{
return PersistentVector.EMPTY;
}
return new SubVector(_meta, v, start, end - 1);
}
public SubVector withMeta(IPersistentMap meta){
if(meta == _meta)
return this;
return new SubVector(meta, v, start, end);
}
public IPersistentMap meta(){
return _meta;
}
}
}
———-
9.8 AReference.java
(IReference [804])
— AReference.java —
/*
9.9. AREF.JAVA 553
\getchunk{Clojure Copyright}
*/
/* rich Dec 31, 2008 */
package clojure.lang;
public class AReference implements IReference {
private IPersistentMap _meta;
public AReference() {
this(null);
}
public AReference(IPersistentMap meta) {
_meta = meta;
}
synchronized public IPersistentMap meta() {
return _meta;
}
synchronized public IPersistentMap alterMeta(IFn alter, ISeq args)
throws Exception {
_meta = (IPersistentMap) alter.applyTo(new Cons(_meta, a rgs));
return _meta;
}
synchronized public IPersistentMap resetMeta(IPersiste ntMap m) {
_meta = m;
return m;
}
}
———-
9.9 ARef.java
(AReference [552]) (IRef [805])
— ARef.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 1, 2009 */
package clojure.lang;
554 CHAPTER 9. JVM/CLOJURE/LANG/
import java.util.Map;
public abstract class ARef extends AReference implements I Ref{
protected volatile IFn validator = null;
private volatile IPersistentMap watches = PersistentHash Map.EMPTY;
public ARef(){
super();
}
public ARef(IPersistentMap meta){
super(meta);
}
void validate(IFn vf, Object val){
try
{
if(vf != null && !RT.booleanCast(vf.invoke(val)))
throw new IllegalStateException("Invalid reference stat e");
}
catch(RuntimeException re)
{
throw re;
}
catch(Exception e)
{
throw new IllegalStateException("Invalid reference stat e", e);
}
}
void validate(Object val){
validate(validator, val);
}
public void setValidator(IFn vf){
try
{
validate(vf, deref());
}
catch(Exception e)
{
throw new RuntimeException(e);
}
validator = vf;
}
public IFn getValidator(){
return validator;
}
9.9. AREF.JAVA 555
public IPersistentMap getWatches(){
return watches;
}
synchronized public IRef addWatch(Object key, IFn callbac k){
watches = watches.assoc(key, callback);
return this;
}
synchronized public IRef removeWatch(Object key){
try
{
watches = watches.without(key);
}
catch(Exception e)
{
throw new RuntimeException(e);
}
return this;
}
public void notifyWatches(Object oldval, Object newval){
IPersistentMap ws = watches;
if(ws.count() > 0)
{
for(ISeq s = ws.seq(); s != null; s = s.next())
{
Map.Entry e = (Map.Entry) s.first();
IFn fn = (IFn) e.getValue();
try
{
if(fn != null)
fn.invoke(e.getKey(), this, oldval, newval);
}
catch(Exception e1)
{
throw new RuntimeException(e1);
}
}
}
}
}
———-
556 CHAPTER 9. JVM/CLOJURE/LANG/
9.10 ArityException.java
(IllegalArgumentException [1723])
— ArityException.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
/**
* @since 1.3
*/
public class ArityException extends IllegalArgumentExce ption {
final public int actual;
final public String name;
public ArityException(int actual, String name) {
this(actual, name, null);
}
public ArityException(int actual, String name, Throwable cause) {
super("Wrong number of args (" + actual +
") passed to: " + name, cause);
this.actual = actual;
this.name = name;
}
}
———-
9.11 ArrayChunk.java
(IChunk [772]) (Serializable [1723])
— ArrayChunk.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 24, 2009 */
package clojure.lang;
import java.io.Serializable;
9.11. ARRAYCHUNK.JAVA 557
public final class ArrayChunk implements IChunk, Serializ able {
final Object[] array;
final int off;
final int end;
public ArrayChunk(Object[] array){
this(array, 0, array.length);
}
public ArrayChunk(Object[] array, int off){
this(array, off, array.length);
}
public ArrayChunk(Object[] array, int off, int end){
this.array = array;
this.off = off;
this.end = end;
}
public Object nth(int i){
return array[off + i];
}
public Object nth(int i, Object notFound){
if(i >= 0 && i < count())
return nth(i);
return notFound;
}
public int count(){
return end - off;
}
public IChunk dropFirst(){
if(off==end)
throw new IllegalStateException("dropFirst of empty chun k");
return new ArrayChunk(array, off + 1, end);
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[off]);
for(int x = off + 1; x < end; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
}
———-
558 CHAPTER 9. JVM/CLOJURE/LANG/
9.12 ArraySeq.java
(ASeq [571]) (IndexedSeq [799]) (IReduce [804])
— ArraySeq.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jun 19, 2006 */
package clojure.lang;
import java.lang.reflect.Array;
public class ArraySeq extends ASeq implements IndexedSeq, IReduce{
public final Object array;
final int i;
final Object[] oa;
final Class ct;
//ISeq _rest;
static public ArraySeq create(){
return null;
}
static public ArraySeq create(Object... array){
if(array == null || array.length == 0)
return null;
return new ArraySeq(array, 0);
}
static ISeq createFromObject(Object array){
if(array == null || Array.getLength(array) == 0)
return null;
Class aclass = array.getClass();
if(aclass == int[].class)
return new ArraySeq_int(null, (int[]) array, 0);
if(aclass == float[].class)
return new ArraySeq_float(null, (float[]) array, 0);
if(aclass == double[].class)
return new ArraySeq_double(null, (double[]) array, 0);
if(aclass == long[].class)
return new ArraySeq_long(null, (long[]) array, 0);
if(aclass == byte[].class)
return new ArraySeq_byte(null, (byte[]) array, 0);
if(aclass == char[].class)
return new ArraySeq_char(null, (char[]) array, 0);
if(aclass == boolean[].class)
return new ArraySeq_boolean(null, (boolean[]) array, 0);
9.12. ARRAYSEQ.JAVA 559
return new ArraySeq(array, 0);
}
ArraySeq(Object array, int i){
this.array = array;
this.ct = array.getClass().getComponentType();
this.i = i;
this.oa = (Object[]) (array instanceof Object[] ? array : nu ll);
// this._rest = this;
}
ArraySeq(IPersistentMap meta, Object array, int i){
super(meta);
this.array = array;
this.ct = array.getClass().getComponentType();
this.i = i;
this.oa = (Object[]) (array instanceof Object[] ? array : nu ll);
}
public Object first(){
if(oa != null)
return oa[i];
return Reflector.prepRet(ct, Array.get(array, i));
}
public ISeq next(){
if(oa != null)
{
if(i + 1 < oa.length)
return new ArraySeq(array, i + 1);
}
else
{
if(i + 1 < Array.getLength(array))
return new ArraySeq(array, i + 1);
}
return null;
}
public int count(){
if(oa != null)
return oa.length - i;
return Array.getLength(array) - i;
}
public int index(){
return i;
}
public ArraySeq withMeta(IPersistentMap meta){
560 CHAPTER 9. JVM/CLOJURE/LANG/
return new ArraySeq(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
if(oa != null)
{
Object ret = oa[i];
for(int x = i + 1; x < oa.length; x++)
ret = f.invoke(ret, oa[x]);
return ret;
}
Object ret = Reflector.prepRet(ct, Array.get(array, i));
for(int x = i + 1; x < Array.getLength(array); x++)
ret = f.invoke(ret, Reflector.prepRet(ct, Array.get(arr ay, x)));
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
if(oa != null)
{
Object ret = f.invoke(start, oa[i]);
for(int x = i + 1; x < oa.length; x++)
ret = f.invoke(ret, oa[x]);
return ret;
}
Object ret =
f.invoke(start, Reflector.prepRet(ct, Array.get(array , i)));
for(int x = i + 1; x < Array.getLength(array); x++)
ret = f.invoke(ret, Reflector.prepRet(ct, Array.get(arr ay, x)));
return ret;
}
public int indexOf(Object o) {
if (oa != null) {
for (int j = i; j < oa.length; j++)
if (Util.equals(o, oa[j])) return j - i;
} else {
int n = Array.getLength(array);
for (int j = i; j < n; j++)
if (Util.equals(o,
Reflector.prepRet(ct, Array.get(array, j))))
return j - i;
}
return -1;
}
public int lastIndexOf(Object o) {
if (oa != null) {
if (o == null) {
9.12. ARRAYSEQ.JAVA 561
for (int j = oa.length - 1 ; j >= i; j--)
if (oa[j] == null) return j - i;
} else {
for (int j = oa.length - 1 ; j >= i; j--)
if (o.equals(oa[j])) return j - i;
}
} else {
if (o == null) {
for (int j = Array.getLength(array) - 1 ; j >= i; j--)
if (Reflector.prepRet(ct,
Array.get(array, j)) == null) return j - i;
} else {
for (int j = Array.getLength(array) - 1 ; j >= i; j--)
if (o.equals(Reflector.prepRet(ct,
Array.get(array, j)))) return j - i;
}
}
return -1;
}
//// specialized primitive versions ////
static public class ArraySeq_int
extends ASeq implements IndexedSeq, IReduce{
public final int[] array;
final int i;
ArraySeq_int(IPersistentMap meta, int[] array, int i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return array[i];
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_int(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
562 CHAPTER 9. JVM/CLOJURE/LANG/
public ArraySeq_int withMeta(IPersistentMap meta){
return new ArraySeq_int(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = array[i];
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public int indexOf(Object o) {
if (o instanceof Number) {
int k = ((Number) o).intValue();
for (int j = i; j < array.length; j++)
if (k == array[j]) return j - i;
}
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Number) {
int k = ((Number) o).intValue();
for (int j = array.length - 1; j >= i; j--)
if (k == array[j]) return j - i;
}
return -1;
}
}
static public class ArraySeq_float
extends ASeq implements IndexedSeq, IReduce{
public final float[] array;
final int i;
ArraySeq_float(IPersistentMap meta, float[] array, int i ){
super(meta);
this.array = array;
this.i = i;
9.12. ARRAYSEQ.JAVA 563
}
public Object first(){
return Numbers.num(array[i]);
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_float(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
public ArraySeq_float withMeta(IPersistentMap meta){
return new ArraySeq_float(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = Numbers.num(array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, Numbers.num(array[x]));
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, Numbers.num(array[i]));
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, Numbers.num(array[x]));
return ret;
}
public int indexOf(Object o) {
if (o instanceof Number) {
float f = ((Number) o).floatValue();
for (int j = i; j < array.length; j++)
if (f == array[j]) return j - i;
}
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Number) {
float f = ((Number) o).floatValue();
564 CHAPTER 9. JVM/CLOJURE/LANG/
for (int j = array.length - 1; j >= i; j--)
if (f == array[j]) return j - i;
}
return -1;
}
}
static public class ArraySeq_double
extends ASeq implements IndexedSeq, IReduce{
public final double[] array;
final int i;
ArraySeq_double(IPersistentMap meta, double[] array, in t i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return array[i];
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_double(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
public ArraySeq_double withMeta(IPersistentMap meta){
return new ArraySeq_double(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = array[i];
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[i]);
for(int x = i + 1; x < array.length; x++)
9.12. ARRAYSEQ.JAVA 565
ret = f.invoke(ret, array[x]);
return ret;
}
public int indexOf(Object o) {
if (o instanceof Number) {
double d = ((Number) o).doubleValue();
for (int j = i; j < array.length; j++)
if (d == array[j]) return j - i;
}
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Number) {
double d = ((Number) o).doubleValue();
for (int j = array.length - 1; j >= i; j--)
if (d == array[j]) return j - i;
}
return -1;
}
}
static public class ArraySeq_long
extends ASeq implements IndexedSeq, IReduce{
public final long[] array;
final int i;
ArraySeq_long(IPersistentMap meta, long[] array, int i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return Numbers.num(array[i]);
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_long(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
566 CHAPTER 9. JVM/CLOJURE/LANG/
public int index(){
return i;
}
public ArraySeq_long withMeta(IPersistentMap meta){
return new ArraySeq_long(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = Numbers.num(array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, Numbers.num(array[x]));
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, Numbers.num(array[i]));
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, Numbers.num(array[x]));
return ret;
}
public int indexOf(Object o) {
if (o instanceof Number) {
long l = ((Number) o).longValue();
for (int j = i; j < array.length; j++)
if (l == array[j]) return j - i;
}
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Number) {
long l = ((Number) o).longValue();
for (int j = array.length - 1; j >= i; j--)
if (l == array[j]) return j - i;
}
return -1;
}
}
static public class ArraySeq_byte
extends ASeq implements IndexedSeq, IReduce{
public final byte[] array;
final int i;
ArraySeq_byte(IPersistentMap meta, byte[] array, int i){
super(meta);
9.12. ARRAYSEQ.JAVA 567
this.array = array;
this.i = i;
}
public Object first(){
return array[i];
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_byte(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
public ArraySeq_byte withMeta(IPersistentMap meta){
return new ArraySeq_byte(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = array[i];
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public int indexOf(Object o) {
if (o instanceof Byte) {
byte b = ((Byte) o).byteValue();
for (int j = i; j < array.length; j++)
if (b == array[j]) return j - i;
}
if (o == null) {
return -1;
}
for (int j = i; j < array.length; j++)
568 CHAPTER 9. JVM/CLOJURE/LANG/
if (o.equals(array[j])) return j - i;
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Byte) {
byte b = ((Byte) o).byteValue();
for (int j = array.length - 1; j >= i; j--)
if (b == array[j]) return j - i;
}
if (o == null) {
return -1;
}
for (int j = array.length - 1; j >= i; j--)
if (o.equals(array[j])) return j - i;
return -1;
}
}
static public class ArraySeq_char
extends ASeq implements IndexedSeq, IReduce{
public final char[] array;
final int i;
ArraySeq_char(IPersistentMap meta, char[] array, int i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return array[i];
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_char(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
public ArraySeq_char withMeta(IPersistentMap meta){
return new ArraySeq_char(meta, array, i);
9.12. ARRAYSEQ.JAVA 569
}
public Object reduce(IFn f) throws Exception{
Object ret = array[i];
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public int indexOf(Object o) {
if (o instanceof Character) {
char c = ((Character) o).charValue();
for (int j = i; j < array.length; j++)
if (c == array[j]) return j - i;
}
if (o == null) {
return -1;
}
for (int j = i; j < array.length; j++)
if (o.equals(array[j])) return j - i;
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Character) {
char c = ((Character) o).charValue();
for (int j = array.length - 1; j >= i; j--)
if (c == array[j]) return j - i;
}
if (o == null) {
return -1;
}
for (int j = array.length - 1; j >= i; j--)
if (o.equals(array[j])) return j - i;
return -1;
}
}
static public class ArraySeq_boolean
extends ASeq implements IndexedSeq, IReduce{
public final boolean[] array;
final int i;
570 CHAPTER 9. JVM/CLOJURE/LANG/
ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return array[i];
}
public ISeq next(){
if(i + 1 < array.length)
return new ArraySeq_boolean(meta(), array, i + 1);
return null;
}
public int count(){
return array.length - i;
}
public int index(){
return i;
}
public ArraySeq_boolean withMeta(IPersistentMap meta){
return new ArraySeq_boolean(meta, array, i);
}
public Object reduce(IFn f) throws Exception{
Object ret = array[i];
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, array[i]);
for(int x = i + 1; x < array.length; x++)
ret = f.invoke(ret, array[x]);
return ret;
}
public int indexOf(Object o) {
if (o instanceof Boolean) {
boolean b = ((Boolean) o).booleanValue();
for (int j = i; j < array.length; j++)
if (b == array[j]) return j - i;
}
if (o == null) {
return -1;
9.13. ASEQ.JAVA 571
}
for (int j = i; j < array.length; j++)
if (o.equals(array[j])) return j - i;
return -1;
}
public int lastIndexOf(Object o) {
if (o instanceof Boolean) {
boolean b = ((Boolean) o).booleanValue();
for (int j = array.length - 1; j >= i; j--)
if (b == array[j]) return j - i;
}
if (o == null) {
return -1;
}
for (int j = array.length - 1; j >= i; j--)
if (o.equals(array[j])) return j - i;
return -1;
}
}
}
———-
9.13 ASeq.java
(Obj [947]) (ISeq [805]) (List [1723]) (Serializable [1723])
— ASeq.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.Serializable;
import java.util.*;
public abstract class ASeq
extends Obj implements ISeq, List, Serializable {
transient int _hash = -1;
public String toString(){
return RT.printString(this);
}
public IPersistentCollection empty(){
return PersistentList.EMPTY;
572 CHAPTER 9. JVM/CLOJURE/LANG/
}
protected ASeq(IPersistentMap meta){
super(meta);
}
protected ASeq(){
}
public boolean equiv(Object obj){
if(!(obj instanceof Sequential || obj instanceof List))
return false;
ISeq ms = RT.seq(obj);
for(ISeq s = seq(); s != null; s = s.next(), ms = ms.next())
{
if(ms == null || !Util.equiv(s.first(), ms.first()))
return false;
}
return ms == null;
}
public boolean equals(Object obj){
if(this == obj) return true;
if(!(obj instanceof Sequential || obj instanceof List))
return false;
ISeq ms = RT.seq(obj);
for(ISeq s = seq(); s != null; s = s.next(), ms = ms.next())
{
if(ms == null || !Util.equals(s.first(), ms.first()))
return false;
}
return ms == null;
}
public int hashCode(){
if(_hash == -1)
{
int hash = 1;
for(ISeq s = seq(); s != null; s = s.next())
{
hash = 31 * hash + (s.first() == null
? 0 : s.first().hashCode());
}
this._hash = hash;
}
return _hash;
9.13. ASEQ.JAVA 573
}
//public Object reduce(IFn f) throws Exception{
// Object ret = first();
// for(ISeq s = rest(); s != null; s = s.rest())
// ret = f.invoke(ret, s.first());
// return ret;
//}
//
//public Object reduce(IFn f, Object start) throws Excepti on{
// Object ret = f.invoke(start, first());
// for(ISeq s = rest(); s != null; s = s.rest())
// ret = f.invoke(ret, s.first());
// return ret;
//}
//public Object peek(){
// return first();
//}
//
//public IPersistentList pop(){
// return rest();
//}
public int count(){
int i = 1;
for(ISeq s = next(); s != null; s = s.next(), i++)
if(s instanceof Counted)
return i + s.count();
return i;
}
final public ISeq seq(){
return this;
}
public ISeq cons(Object o){
return new Cons(o, this);
}
public ISeq more(){
ISeq s = next();
if(s == null)
return PersistentList.EMPTY;
return s;
}
//final public ISeq rest(){
// Seqable m = more();
574 CHAPTER 9. JVM/CLOJURE/LANG/
// if(m == null)
// return null;
// return m.seq();
//}
// java.util.Collection implementation
public Object[] toArray(){
return RT.seqToArray(seq());
}
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(!contains(o))
return false;
}
return true;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.next())
{
9.13. ASEQ.JAVA 575
a[i] = s.first();
}
if(a.length > count())
a[count()] = null;
return a;
}
else
return toArray();
}
public int size(){
return count();
}
public boolean isEmpty(){
return seq() == null;
}
public boolean contains(Object o){
for(ISeq s = seq(); s != null; s = s.next())
{
if(Util.equiv(s.first(), o))
return true;
}
return false;
}
public Iterator iterator(){
return new SeqIterator(this);
}
//////////// List stuff /////////////////
private List reify(){
return Collections.unmodifiableList(new ArrayList(thi s));
}
public List subList(int fromIndex, int toIndex){
return reify().subList(fromIndex, toIndex);
}
public Object set(int index, Object element){
throw new UnsupportedOperationException();
}
public Object remove(int index){
throw new UnsupportedOperationException();
}
576 CHAPTER 9. JVM/CLOJURE/LANG/
public int indexOf(Object o){
ISeq s = seq();
for(int i = 0; s != null; s = s.next(), i++)
{
if(Util.equiv(s.first(), o))
return i;
}
return -1;
}
public int lastIndexOf(Object o){
return reify().lastIndexOf(o);
}
public ListIterator listIterator(){
return reify().listIterator();
}
public ListIterator listIterator(int index){
return reify().listIterator(index);
}
public Object get(int index){
return RT.nth(this, index);
}
public void add(int index, Object element){
throw new UnsupportedOperationException();
}
public boolean addAll(int index, Collection c){
throw new UnsupportedOperationException();
}
}
———-
9.14 Associative.java
(IPersistentCollection [800]) (ILookup [797])
— Associative.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
9.15. ATOM.JAVA 577
public interface Associative extends IPersistentCollect ion, ILookup{
boolean containsKey(Object key);
IMapEntry entryAt(Object key);
Associative assoc(Object key, Object val);
}
———-
9.15 Atom.java
(ARef [553])
— Atom.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 1, 2009 */
package clojure.lang;
import java.util.concurrent.atomic.AtomicReference;
final public class Atom extends ARef{
final AtomicReference state;
public Atom(Object state){
this.state = new AtomicReference(state);
}
public Atom(Object state, IPersistentMap meta){
super(meta);
this.state = new AtomicReference(state);
}
public Object deref(){
return state.get();
}
public Object swap(IFn f) throws Exception{
for(; ;)
{
Object v = deref();
Object newv = f.invoke(v);
validate(newv);
if(state.compareAndSet(v, newv))
578 CHAPTER 9. JVM/CLOJURE/LANG/
{
notifyWatches(v, newv);
return newv;
}
}
}
public Object swap(IFn f, Object arg) throws Exception{
for(; ;)
{
Object v = deref();
Object newv = f.invoke(v, arg);
validate(newv);
if(state.compareAndSet(v, newv))
{
notifyWatches(v, newv);
return newv;
}
}
}
public Object swap(IFn f, Object arg1, Object arg2) throws E xception{
for(; ;)
{
Object v = deref();
Object newv = f.invoke(v, arg1, arg2);
validate(newv);
if(state.compareAndSet(v, newv))
{
notifyWatches(v, newv);
return newv;
}
}
}
public Object swap(IFn f, Object x, Object y, ISeq args)
throws Exception{
for(; ;)
{
Object v = deref();
Object newv = f.applyTo(RT.listStar(v, x, y, args));
validate(newv);
if(state.compareAndSet(v, newv))
{
notifyWatches(v, newv);
return newv;
}
}
}
9.16. ATRANSIENTMAP.JAVA 579
public boolean compareAndSet(Object oldv, Object newv){
validate(newv);
boolean ret = state.compareAndSet(oldv, newv);
if(ret)
notifyWatches(oldv, newv);
return ret;
}
public Object reset(Object newval){
Object oldval = state.get();
validate(newval);
state.set(newval);
notifyWatches(oldval, newval);
return newval;
}
}
———-
9.16 ATransientMap.java
(AFn [509]) (ITransientMap [808])
— ATransientMap.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.util.Map;
import clojure.lang.PersistentHashMap.INode;
abstract class ATransientMap extends AFn implements ITran sientMap {
abstract void ensureEditable();
abstract ITransientMap doAssoc(Object key, Object val);
abstract ITransientMap doWithout(Object key);
abstract Object doValAt(Object key, Object notFound);
abstract int doCount();
abstract IPersistentMap doPersistent();
public ITransientMap conj(Object o) {
ensureEditable();
if(o instanceof Map.Entry)
{
Map.Entry e = (Map.Entry) o;
return assoc(e.getKey(), e.getValue());
580 CHAPTER 9. JVM/CLOJURE/LANG/
}
else if(o instanceof IPersistentVector)
{
IPersistentVector v = (IPersistentVector) o;
if(v.count() != 2)
throw new IllegalArgumentException(
"Vector arg to map conj must be a pair");
return assoc(v.nth(0), v.nth(1));
}
ITransientMap ret = this;
for(ISeq es = RT.seq(o); es != null; es = es.next())
{
Map.Entry e = (Map.Entry) es.first();
ret = ret.assoc(e.getKey(), e.getValue());
}
return ret;
}
public final Object invoke(Object arg1) throws Exception{
return valAt(arg1);
}
public final Object invoke(Object arg1, Object notFound)
throws Exception{
return valAt(arg1, notFound);
}
public final Object valAt(Object key) {
return valAt(key, null);
}
public final ITransientMap assoc(Object key, Object val) {
ensureEditable();
return doAssoc(key, val);
}
public final ITransientMap without(Object key) {
ensureEditable();
return doWithout(key);
}
public final IPersistentMap persistent() {
ensureEditable();
return doPersistent();
}
public final Object valAt(Object key, Object notFound) {
ensureEditable();
return doValAt(key, notFound);
9.17. ATRANSIENTSET.JAVA 581
}
public final int count() {
ensureEditable();
return doCount();
}
}
———-
9.17 ATransientSet.java
(AFn [509]) (ITransientSet [809])
— ATransientSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
public abstract class ATransientSet
extends AFn implements ITransientSet{
ITransientMap impl;
ATransientSet(ITransientMap impl) {
this.impl = impl;
}
public int count() {
return impl.count();
}
public ITransientSet conj(Object val) {
ITransientMap m = impl.assoc(val, val);
if (m != impl) this.impl = m;
return this;
}
public boolean contains(Object key) {
return this != impl.valAt(key, this);
}
public ITransientSet disjoin(Object key) throws Exceptio n {
ITransientMap m = impl.without(key);
if (m != impl) this.impl = m;
return this;
582 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Object get(Object key) {
return impl.valAt(key);
}
public Object invoke(Object key, Object notFound) throws E xception {
return impl.valAt(key, notFound);
}
public Object invoke(Object key) throws Exception {
return impl.valAt(key);
}
}
———-
9.18 BigInt.java
(Number [1723])
— BigInt.java —
/*
\getchunk{Clojure Copyright}
*/
/* chouser Jun 23, 2010 */
package clojure.lang;
import java.math.BigInteger;
public final class BigInt extends Number{
final public long lpart;
final public BigInteger bipart;
final public static BigInt ZERO = new BigInt(0,null);
final public static BigInt ONE = new BigInt(1,null);
//must follow Long
public int hashCode(){
if(bipart == null)
return (int) (this.lpart ^ (this.lpart >>> 32));
return bipart.hashCode();
}
9.18. BIGINT.JAVA 583
public boolean equals(Object obj){
if(this == obj)
return true;
if(obj instanceof BigInt)
{
BigInt o = (BigInt) obj;
if(bipart == null)
return o.bipart == null && this.lpart == o.lpart;
return o.bipart != null && this.bipart.equals(o.bipart);
}
return false;
}
private BigInt(long lpart, BigInteger bipart){
this.lpart = lpart;
this.bipart = bipart;
}
public static BigInt fromBigInteger(BigInteger val){
if(val.bitLength() < 64)
return new BigInt(val.longValue(), null);
else
return new BigInt(0, val);
}
public static BigInt fromLong(long val){
return new BigInt(val, null);
}
public BigInteger toBigInteger(){
if(bipart == null)
return BigInteger.valueOf(lpart);
else
return bipart;
}
///// java.lang.Number:
public int intValue(){
if(bipart == null)
return (int) lpart;
else
return bipart.intValue();
}
public long longValue(){
if(bipart == null)
return lpart;
else
return bipart.longValue();
584 CHAPTER 9. JVM/CLOJURE/LANG/
}
public float floatValue(){
if(bipart == null)
return lpart;
else
return bipart.floatValue();
}
public double doubleValue(){
if(bipart == null)
return lpart;
else
return bipart.doubleValue();
}
public byte byteValue(){
if(bipart == null)
return (byte) lpart;
else
return bipart.byteValue();
}
public short shortValue(){
if(bipart == null)
return (short) lpart;
else
return bipart.shortValue();
}
public static BigInt valueOf(long val){
return new BigInt(val, null);
}
public String toString(){
if(bipart == null)
return String.valueOf(lpart);
return bipart.toString();
}
public int bitLength(){
return toBigInteger().bitLength();
}
}
———-
9.19. BINDING.JAVA 585
9.19 Binding.java
— Binding.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public class Binding<T>{
public T val;
public final Binding rest;
public Binding(T val){
this.val = val;
this.rest = null;
}
public Binding(T val, Binding rest){
this.val = val;
this.rest = rest;
}
}
———-
9.20 Box.java
— Box.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 27, 2006 8:40:19 PM */
package clojure.lang;
public class Box{
public Object val;
public Box(Object val){
this.val = val;
}
}
586 CHAPTER 9. JVM/CLOJURE/LANG/
———-
9.21 ChunkBuﬀer.java
(Counted [768])
— ChunkBuﬀer.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 26, 2009 */
package clojure.lang;
final public class ChunkBuffer implements Counted{
Object[] buffer;
int end;
public ChunkBuffer(int capacity){
buffer = new Object[capacity];
end = 0;
}
public void add(Object o){
buffer[end++] = o;
}
public IChunk chunk(){
ArrayChunk ret = new ArrayChunk(buffer, 0, end);
buffer = null;
return ret;
}
public int count(){
return end;
}
}
———-
9.22 ChunkedCons.java
(ASeq [571]) (IChunkedSeq [773])
— ChunkedCons.java —
/*
9.22. CHUNKEDCONS.JAVA 587
\getchunk{Clojure Copyright}
*/
/* rich May 25, 2009 */
package clojure.lang;
final public class ChunkedCons extends ASeq implements ICh unkedSeq{
final IChunk chunk;
final ISeq _more;
ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more ){
super(meta);
this.chunk = chunk;
this._more = more;
}
public ChunkedCons(IChunk chunk, ISeq more){
this(null,chunk, more);
}
public Obj withMeta(IPersistentMap meta){
if(meta != _meta)
return new ChunkedCons(meta, chunk, _more);
return this;
}
public Object first(){
return chunk.nth(0);
}
public ISeq next(){
if(chunk.count() > 1)
return new ChunkedCons(chunk.dropFirst(), _more);
return chunkedNext();
}
public ISeq more(){
if(chunk.count() > 1)
return new ChunkedCons(chunk.dropFirst(), _more);
if(_more == null)
return PersistentList.EMPTY;
return _more;
}
public IChunk chunkedFirst(){
return chunk;
}
public ISeq chunkedNext(){
588 CHAPTER 9. JVM/CLOJURE/LANG/
return chunkedMore().seq();
}
public ISeq chunkedMore(){
if(_more == null)
return PersistentList.EMPTY;
return _more;
}
}
———-
9.23 Compile.java
— Compile.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.IOException;
// Compiles libs and generates class files stored within the directory
// named by the Java System property "clojure.compile.path ". Arguments
// are strings naming the libs to be compiled. The libs and com pile-path
// must all be within CLASSPATH.
public class Compile{
private static final String PATH_PROP =
"clojure.compile.path";
private static final String REFLECTION_WARNING_PROP =
"clojure.compile.warn-on-reflection";
private static final Var compile_path =
RT.var("clojure.core", "*compile-path*");
private static final Var compile =
RT.var("clojure.core", "compile");
private static final Var warn_on_reflection =
RT.var("clojure.core", "*warn-on-reflection*");
public static void main(String[] args) throws Exception{
OutputStreamWriter out = (OutputStreamWriter) RT.OUT.de ref();
PrintWriter err = RT.errPrintWriter();
9.23. COMPILE.JAVA 589
String path = System.getProperty(PATH_PROP);
int count = args.length;
if(path == null)
{
err.println("ERROR: Must set system property " + PATH_PROP +
"\nto the location for compiled .class files." +
"\nThis directory must also be on your CLASSPATH.");
System.exit(1);
}
boolean warnOnReflection =
System.getProperty(REFLECTION_WARNING_PROP, "false") .equals("true");
try
{
Var.pushThreadBindings(
RT.map(compile_path,
path,
warn_on_reflection,
warnOnReflection));
for(String lib : args)
{
out.write("Compiling " + lib + " to " + path + "\n");
out.flush();
compile.invoke(Symbol.intern(lib));
}
}
finally
{
Var.popThreadBindings();
try
{
out.flush();
out.close();
}
catch(IOException e)
{
e.printStackTrace(err);
}
}
}
}
———-
590 CHAPTER 9. JVM/CLOJURE/LANG/
9.24 Compiler.java
(Opcodes [387])
— Compiler.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Aug 21, 2007 */
package clojure.lang;
//*
import clojure.asm.*;
import clojure.asm.commons.Method;
import clojure.asm.commons.GeneratorAdapter;
//*/
/*
import org.objectweb.asm.*;
import org.objectweb.asm.commons.Method;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.util.TraceClassVisitor;
import org.objectweb.asm.util.CheckClassAdapter;
//*/
import java.io.*;
import java.util.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
public class Compiler implements Opcodes{
static final Symbol DEF = Symbol.intern("def");
static final Symbol LOOP = Symbol.intern("loop*");
static final Symbol RECUR = Symbol.intern("recur");
static final Symbol IF = Symbol.intern("if");
static final Symbol LET = Symbol.intern("let*");
static final Symbol LETFN = Symbol.intern("letfn*");
static final Symbol DO = Symbol.intern("do");
static final Symbol FN = Symbol.intern("fn*");
static final Symbol QUOTE = Symbol.intern("quote");
static final Symbol THE_VAR = Symbol.intern("var");
static final Symbol DOT = Symbol.intern(".");
static final Symbol ASSIGN = Symbol.intern("set!");
//static final Symbol TRY_FINALLY = Symbol.intern("try-f inally");
static final Symbol TRY = Symbol.intern("try");
static final Symbol CATCH = Symbol.intern("catch");
9.24. COMPILER.JAVA 591
static final Symbol FINALLY = Symbol.intern("finally");
static final Symbol THROW = Symbol.intern("throw");
static final Symbol MONITOR_ENTER = Symbol.intern("monit or-enter");
static final Symbol MONITOR_EXIT = Symbol.intern("monito r-exit");
static final Symbol IMPORT = Symbol.intern("clojure.core ", "import*");
//static final Symbol INSTANCE = Symbol.intern("instance ?");
static final Symbol DEFTYPE = Symbol.intern("deftype*");
static final Symbol CASE = Symbol.intern("case*");
//static final Symbol THISFN = Symbol.intern("thisfn");
static final Symbol CLASS = Symbol.intern("Class");
static final Symbol NEW = Symbol.intern("new");
static final Symbol THIS = Symbol.intern("this");
static final Symbol REIFY = Symbol.intern("reify*");
//static final Symbol UNQUOTE = Symbol.intern("unquote") ;
//static final Symbol UNQUOTE_SPLICING =
// Symbol.intern("unquote-splicing");
//static final Symbol SYNTAX_QUOTE =
// Symbol.intern("clojure.core", "syntax-quote");
static final Symbol LIST = Symbol.intern("clojure.core", "list");
static final Symbol HASHMAP = Symbol.intern("clojure.cor e", "hash-map");
static final Symbol VECTOR = Symbol.intern("clojure.core ", "vector");
static final Symbol IDENTITY = Symbol.intern("clojure.co re", "identity");
static final Symbol _AMP_ = Symbol.intern("&");
static final Symbol ISEQ = Symbol.intern("clojure.lang.I Seq");
static final Keyword inlineKey = Keyword.intern(null, "in line");
static final Keyword inlineAritiesKey =
Keyword.intern(null, "inline-arities");
static final Keyword staticKey = Keyword.intern(null, "st atic");
static final Keyword arglistsKey = Keyword.intern(null, " arglists");
static final Symbol INVOKE_STATIC = Symbol.intern("invok eStatic");
static final Keyword volatileKey = Keyword.intern(null, " volatile");
static final Keyword implementsKey = Keyword.intern(null , "implements");
static final String COMPILE_STUB_PREFIX = "compile__stub ";
static final Keyword protocolKey = Keyword.intern(null, " protocol");
static final Keyword onKey = Keyword.intern(null, "on");
static Keyword dynamicKey = Keyword.intern("dynamic");
static final Symbol NS = Symbol.intern("ns");
static final Symbol IN_NS = Symbol.intern("in-ns");
//static final Symbol IMPORT = Symbol.intern("import");
//static final Symbol USE = Symbol.intern("use");
//static final Symbol IFN = Symbol.intern("clojure.lang" , "IFn");
592 CHAPTER 9. JVM/CLOJURE/LANG/
static final public IPersistentMap specials = PersistentH ashMap.create(
DEF, new DefExpr.Parser(),
LOOP, new LetExpr.Parser(),
RECUR, new RecurExpr.Parser(),
IF, new IfExpr.Parser(),
CASE, new CaseExpr.Parser(),
LET, new LetExpr.Parser(),
LETFN, new LetFnExpr.Parser(),
DO, new BodyExpr.Parser(),
FN, null,
QUOTE, new ConstantExpr.Parser(),
THE_VAR, new TheVarExpr.Parser(),
IMPORT, new ImportExpr.Parser(),
DOT, new HostExpr.Parser(),
ASSIGN, new AssignExpr.Parser(),
DEFTYPE, new NewInstanceExpr.DeftypeParser(),
REIFY, new NewInstanceExpr.ReifyParser(),
// TRY_FINALLY, new TryFinallyExpr.Parser(),
TRY, new TryExpr.Parser(),
THROW, new ThrowExpr.Parser(),
MONITOR_ENTER, new MonitorEnterExpr.Parser(),
MONITOR_EXIT, new MonitorExitExpr.Parser(),
// INSTANCE, new InstanceExpr.Parser(),
// IDENTICAL, new IdenticalExpr.Parser(),
//THISFN, null,
CATCH, null,
FINALLY, null,
// CLASS, new ClassExpr.Parser(),
NEW, new NewExpr.Parser(),
// UNQUOTE, null,
// UNQUOTE_SPLICING, null,
// SYNTAX_QUOTE, null,
_AMP_, null
);
private static final int MAX_POSITIONAL_ARITY = 20;
private static final Type OBJECT_TYPE;
private static final Type KEYWORD_TYPE = Type.getType(Key word.class);
private static final Type VAR_TYPE = Type.getType(Var.cla ss);
private static final Type SYMBOL_TYPE = Type.getType(Symb ol.class);
//private static final Type NUM_TYPE = Type.getType(Num.c lass);
private static final Type IFN_TYPE = Type.getType(IFn.cla ss);
private static final Type AFUNCTION_TYPE = Type.getType(A Function.class);
private static final Type RT_TYPE = Type.getType(RT.class );
private static final Type NUMBERS_TYPE = Type.getType(Num bers.class);
final static Type CLASS_TYPE = Type.getType(Class.class) ;
final static Type NS_TYPE = Type.getType(Namespace.class );
final static Type UTIL_TYPE = Type.getType(Util.class);
final static Type REFLECTOR_TYPE = Type.getType(Reflecto r.class);
final static Type THROWABLE_TYPE = Type.getType(Throwabl e.class);
9.24. COMPILER.JAVA 593
final static Type BOOLEAN_OBJECT_TYPE = Type.getType(Boo lean.class);
final static Type IPERSISTENTMAP_TYPE =
Type.getType(IPersistentMap.class);
final static Type IOBJ_TYPE = Type.getType(IObj.class);
private static final Type[][] ARG_TYPES;
private static final Type[] EXCEPTION_TYPES =
{Type.getType(Exception.class)};
static
{
OBJECT_TYPE = Type.getType(Object.class);
ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][];
for(int i = 0; i <= MAX_POSITIONAL_ARITY; ++i)
{
Type[] a = new Type[i];
for(int j = 0; j < i; j++)
a[j] = OBJECT_TYPE;
ARG_TYPES[i] = a;
}
Type[] a = new Type[MAX_POSITIONAL_ARITY + 1];
for(int j = 0; j < MAX_POSITIONAL_ARITY; j++)
a[j] = OBJECT_TYPE;
a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/O bject;");
ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a;
}
//symbol->localbinding
static final public Var LOCAL_ENV = Var.create(null).setD ynamic();
//vector<localbinding>
static final public Var LOOP_LOCALS = Var.create().setDyn amic();
//Label
static final public Var LOOP_LABEL = Var.create().setDyna mic();
//vector<object>
static final public Var CONSTANTS = Var.create().setDynam ic();
//IdentityHashMap
static final public Var CONSTANT_IDS = Var.create().setDy namic();
//vector<keyword>
static final public Var KEYWORD_CALLSITES = Var.create(). setDynamic();
//vector<var>
static final public Var PROTOCOL_CALLSITES = Var.create() .setDynamic();
594 CHAPTER 9. JVM/CLOJURE/LANG/
//set<var>
static final public Var VAR_CALLSITES = Var.create().setD ynamic();
//keyword->constid
static final public Var KEYWORDS = Var.create().setDynami c();
//var->constid
static final public Var VARS = Var.create().setDynamic();
//FnFrame
static final public Var METHOD = Var.create(null).setDyna mic();
//null or not
static final public Var IN_CATCH_FINALLY = Var.create(nul l).setDynamic();
static final public Var NO_RECUR = Var.create(null).setDy namic();
//DynamicClassLoader
static final public Var LOADER = Var.create().setDynamic( );
//String
static final public Var SOURCE =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("*source-path*"), "NO_SOURCE_FILE").se tDynamic();
//String
static final public Var SOURCE_PATH =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynami c();
//String
static final public Var COMPILE_PATH =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("*compile-path*"), null).setDynamic();
//boolean
static final public Var COMPILE_FILES =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("*compile-files*"), Boolean.FALSE).set Dynamic();
static final public Var INSTANCE =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("instance?"));
static final public Var ADD_ANNOTATIONS =
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("add-annotations"));
//boolean
static final public Var UNCHECKED_MATH =
9.24. COMPILER.JAVA 595
Var.intern(Namespace.findOrCreate(Symbol.intern("cl ojure.core")),
Symbol.intern("*unchecked-math*"), Boolean.FALSE).se tDynamic();
//Integer
static final public Var LINE = Var.create(0).setDynamic() ;
//Integer
static final public Var LINE_BEFORE = Var.create(0).setDy namic();
static final public Var LINE_AFTER = Var.create(0).setDyn amic();
//Integer
static final public Var NEXT_LOCAL_NUM = Var.create(0).se tDynamic();
//Integer
static final public Var RET_LOCAL_NUM = Var.create().setD ynamic();
static final public Var COMPILE_STUB_SYM =
Var.create(null).setDynamic();
static final public Var COMPILE_STUB_CLASS =
Var.create(null).setDynamic();
//PathNode chain
static final public Var CLEAR_PATH = Var.create(null).set Dynamic();
//tail of PathNode chain
static final public Var CLEAR_ROOT = Var.create(null).set Dynamic();
//LocalBinding -> Set<LocalBindingExpr>
static final public Var CLEAR_SITES = Var.create(null).se tDynamic();
public enum C{
STATEMENT, //value ignored
EXPRESSION, //value required
RETURN, //tail position relative to enclosing recur frame
EVAL
}
interface Expr{
Object eval() throws Exception;
void emit(C context, ObjExpr objx, GeneratorAdapter gen);
boolean hasJavaClass() throws Exception;
Class getJavaClass() throws Exception;
}
public static abstract class UntypedExpr implements Expr{
596 CHAPTER 9. JVM/CLOJURE/LANG/
public Class getJavaClass(){
throw new IllegalArgumentException("Has no Java class");
}
public boolean hasJavaClass(){
return false;
}
}
interface IParser{
Expr parse(C context, Object form) throws Exception;
}
static boolean isSpecial(Object sym){
return specials.containsKey(sym);
}
static Symbol resolveSymbol(Symbol sym){
//already qualified or classname?
if(sym.name.indexOf(’.’) > 0)
return sym;
if(sym.ns != null)
{
Namespace ns = namespaceFor(sym);
if(ns == null || ns.name.name == sym.ns)
return sym;
return Symbol.intern(ns.name.name, sym.name);
}
Object o = currentNS().getMapping(sym);
if(o == null)
return Symbol.intern(currentNS().name.name, sym.name) ;
else if(o instanceof Class)
return Symbol.intern(null, ((Class) o).getName());
else if(o instanceof Var)
{
Var v = (Var) o;
return Symbol.intern(v.ns.name.name, v.sym.name);
}
return null;
}
static class DefExpr implements Expr{
public final Var var;
public final Expr init;
public final Expr meta;
public final boolean initProvided;
public final boolean isDynamic;
public final String source;
9.24. COMPILER.JAVA 597
public final int line;
final static Method bindRootMethod =
Method.getMethod("void bindRoot(Object)");
final static Method setTagMethod =
Method.getMethod("void setTag(clojure.lang.Symbol)") ;
final static Method setMetaMethod =
Method.getMethod("void setMeta(clojure.lang.IPersist entMap)");
final static Method setDynamicMethod =
Method.getMethod("clojure.lang.Var setDynamic(boolea n)");
final static Method symintern =
Method.getMethod("clojure.lang.Symbol intern(String, String)");
public DefExpr(String source, int line, Var var, Expr init,
Expr meta, boolean initProvided, boolean isDynamic){
this.source = source;
this.line = line;
this.var = var;
this.init = init;
this.meta = meta;
this.isDynamic = isDynamic;
this.initProvided = initProvided;
}
private boolean includesExplicitMetadata(MapExpr expr) {
for(int i=0; i < expr.keyvals.count(); i += 2)
{
Keyword k = ((KeywordExpr) expr.keyvals.nth(i)).k;
if ((k != RT.FILE_KEY) &&
(k != RT.DECLARED_KEY) &&
(k != RT.LINE_KEY))
return true;
}
return false;
}
public Object eval() throws Exception{
try
{
if(initProvided)
{
// if(init instanceof FnExpr &&
// ((FnExpr) init).closes.count()==0)
// var.bindRoot(new FnLoaderThunk((FnExpr) init,var));
// else
var.bindRoot(init.eval());
}
if(meta != null)
{
IPersistentMap metaMap = (IPersistentMap) meta.eval();
//includesExplicitMetadata((MapExpr) meta))
598 CHAPTER 9. JVM/CLOJURE/LANG/
if (initProvided || true)
var.setMeta((IPersistentMap) meta.eval());
}
return var.setDynamic(isDynamic);
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(source, line, e);
else
throw (CompilerException) e;
}
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
objx.emitVar(gen, var);
if(isDynamic)
{
gen.push(isDynamic);
gen.invokeVirtual(VAR_TYPE, setDynamicMethod);
}
if(meta != null)
{
//includesExplicitMetadata((MapExpr) meta))
if (initProvided || true)
{
gen.dup();
meta.emit(C.EXPRESSION, objx, gen);
gen.checkCast(IPERSISTENTMAP_TYPE);
gen.invokeVirtual(VAR_TYPE, setMetaMethod);
}
}
if(initProvided)
{
gen.dup();
init.emit(C.EXPRESSION, objx, gen);
gen.invokeVirtual(VAR_TYPE, bindRootMethod);
}
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass(){
return Var.class;
}
9.24. COMPILER.JAVA 599
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
//(def x) or (def x initexpr) or (def x "docstring" initexpr)
String docstring = null;
if(RT.count(form) == 4 &&
(RT.third(form) instanceof String)) {
docstring = (String) RT.third(form);
form = RT.list(RT.first(form),
RT.second(form),
RT.fourth(form));
}
if(RT.count(form) > 3)
throw new Exception("Too many arguments to def");
else if(RT.count(form) < 2)
throw new Exception("Too few arguments to def");
else if(!(RT.second(form) instanceof Symbol))
throw new Exception(
"First argument to def must be a Symbol");
Symbol sym = (Symbol) RT.second(form);
Var v = lookupVar(sym, true);
if(v == null)
throw new Exception(
"Can’t refer to qualified var that doesn’t exist");
if(!v.ns.equals(currentNS()))
{
if(sym.ns == null)
v = currentNS().intern(sym);
// throw new Exception(
// "Name conflict, can’t def " + sym +
// " because namespace: " + currentNS().name +
// " refers to:" + v);
else
throw new Exception(
"Can’t create defs outside of current ns");
}
IPersistentMap mm = sym.meta();
boolean isDynamic = RT.booleanCast(RT.get(mm,dynamicKe y));
if(!isDynamic &&
sym.name.startsWith("*") &&
sym.name.endsWith("*") &&
sym.name.length() > 1)
{
RT.errPrintWriter().format(
"Var %s not marked :dynamic true, setting to "+
":dynamic. You should fix this before next release!\n",
sym);
isDynamic = true;
mm = (IPersistentMap) RT.assoc(mm,dynamicKey, RT.T);
}
600 CHAPTER 9. JVM/CLOJURE/LANG/
if(RT.booleanCast(RT.get(mm, arglistsKey)))
{
IPersistentMap vm = v.meta();
//vm = (IPersistentMap) RT.assoc(vm,staticKey,RT.T);
//drop quote
vm = (IPersistentMap)
RT.assoc(vm,arglistsKey,
RT.second(mm.valAt(arglistsKey)));
v.setMeta(vm);
}
Object source_path = SOURCE_PATH.get();
source_path = source_path ==
null ? "NO_SOURCE_FILE" : source_path;
mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get ())
.assoc(RT.FILE_KEY, source_path);
if (docstring != null)
mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring );
Expr meta =
analyze(context == C.EVAL ? context : C.EXPRESSION, mm);
return new DefExpr((String) SOURCE.deref(),
(Integer) LINE.deref(),
v, analyze(
context == C.EVAL ?
context : C.EXPRESSION,
RT.third(form),
v.sym.name),
meta, RT.count(form) == 3, isDynamic);
}
}
}
public static class AssignExpr implements Expr{
public final AssignableExpr target;
public final Expr val;
public AssignExpr(AssignableExpr target, Expr val){
this.target = target;
this.val = val;
}
public Object eval() throws Exception{
return target.evalAssign(val);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
target.emitAssign(context, objx, gen, val);
}
public boolean hasJavaClass() throws Exception{
return val.hasJavaClass();
9.24. COMPILER.JAVA 601
}
public Class getJavaClass() throws Exception{
return val.getJavaClass();
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
if(RT.length(form) != 3)
throw new IllegalArgumentException(
"Malformed assignment, expecting (set! target val)");
Expr target = analyze(C.EXPRESSION, RT.second(form));
if(!(target instanceof AssignableExpr))
throw new IllegalArgumentException(
"Invalid assignment target");
return new AssignExpr((AssignableExpr) target,
analyze(C.EXPRESSION,
RT.third(form)));
}
}
}
public static class VarExpr implements Expr, AssignableEx pr{
public final Var var;
public final Object tag;
final static Method getMethod =
Method.getMethod("Object get()");
final static Method setMethod =
Method.getMethod("Object set(Object)");
public VarExpr(Var var, Symbol tag){
this.var = var;
this.tag = tag != null ? tag : var.getTag();
}
public Object eval() throws Exception{
return var.deref();
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
objx.emitVarValue(gen,var);
if(context == C.STATEMENT)
{
gen.pop();
}
}
public boolean hasJavaClass(){
return tag != null;
602 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Class getJavaClass() throws Exception{
return HostExpr.tagToClass(tag);
}
public Object evalAssign(Expr val) throws Exception{
return var.set(val.eval());
}
public void emitAssign(C context, ObjExpr objx, Generator Adapter gen,
Expr val){
objx.emitVar(gen, var);
val.emit(C.EXPRESSION, objx, gen);
gen.invokeVirtual(VAR_TYPE, setMethod);
if(context == C.STATEMENT)
gen.pop();
}
}
public static class TheVarExpr implements Expr{
public final Var var;
public TheVarExpr(Var var){
this.var = var;
}
public Object eval() throws Exception{
return var;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
objx.emitVar(gen, var);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws ClassNotFoundExcepti on{
return Var.class;
}
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
Symbol sym = (Symbol) RT.second(form);
Var v = lookupVar(sym, false);
if(v != null)
9.24. COMPILER.JAVA 603
return new TheVarExpr(v);
throw new Exception("Unable to resolve var: " + sym +
" in this context");
}
}
}
public static class KeywordExpr extends LiteralExpr{
public final Keyword k;
public KeywordExpr(Keyword k){
this.k = k;
}
Object val(){
return k;
}
public Object eval() {
return k;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
objx.emitKeyword(gen, k);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws ClassNotFoundExcepti on{
return Keyword.class;
}
}
public static class ImportExpr implements Expr{
public final String c;
final static Method forNameMethod =
Method.getMethod("Class forName(String)");
final static Method importClassMethod =
Method.getMethod("Class importClass(Class)");
final static Method derefMethod =
Method.getMethod("Object deref()");
public ImportExpr(String c){
this.c = c;
}
604 CHAPTER 9. JVM/CLOJURE/LANG/
public Object eval() throws Exception{
Namespace ns = (Namespace) RT.CURRENT_NS.deref();
ns.importClass(RT.classForName(c));
return null;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.getStatic(RT_TYPE,"CURRENT_NS",VAR_TYPE);
gen.invokeVirtual(VAR_TYPE, derefMethod);
gen.checkCast(NS_TYPE);
gen.push(c);
gen.invokeStatic(CLASS_TYPE, forNameMethod);
gen.invokeVirtual(NS_TYPE, importClassMethod);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return false;
}
public Class getJavaClass() throws ClassNotFoundExcepti on{
throw
new IllegalArgumentException("ImportExpr has no Java cla ss");
}
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
return new ImportExpr((String) RT.second(form));
}
}
}
public static abstract class LiteralExpr implements Expr{
abstract Object val();
public Object eval(){
return val();
}
}
static interface AssignableExpr{
Object evalAssign(Expr val) throws Exception;
void emitAssign(C context,
ObjExpr objx,
GeneratorAdapter gen,
Expr val);
}
9.24. COMPILER.JAVA 605
static public interface MaybePrimitiveExpr extends Expr{
public boolean canEmitPrimitive();
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen);
}
static public abstract class HostExpr
implements Expr, MaybePrimitiveExpr{
final static Type BOOLEAN_TYPE = Type.getType(Boolean.cl ass);
final static Type CHAR_TYPE = Type.getType(Character.cla ss);
final static Type INTEGER_TYPE = Type.getType(Integer.cl ass);
final static Type LONG_TYPE = Type.getType(Long.class);
final static Type FLOAT_TYPE = Type.getType(Float.class) ;
final static Type DOUBLE_TYPE = Type.getType(Double.clas s);
final static Type SHORT_TYPE = Type.getType(Short.class) ;
final static Type BYTE_TYPE = Type.getType(Byte.class);
final static Type NUMBER_TYPE = Type.getType(Number.clas s);
final static Method charValueMethod =
Method.getMethod("char charValue()");
final static Method booleanValueMethod =
Method.getMethod("boolean booleanValue()");
final static Method charValueOfMethod =
Method.getMethod("Character valueOf(char)");
final static Method intValueOfMethod =
Method.getMethod("Integer valueOf(int)");
final static Method longValueOfMethod =
Method.getMethod("Long valueOf(long)");
final static Method floatValueOfMethod =
Method.getMethod("Float valueOf(float)");
final static Method doubleValueOfMethod =
Method.getMethod("Double valueOf(double)");
final static Method shortValueOfMethod =
Method.getMethod("Short valueOf(short)");
final static Method byteValueOfMethod =
Method.getMethod("Byte valueOf(byte)");
final static Method intValueMethod =
Method.getMethod("int intValue()");
final static Method longValueMethod =
Method.getMethod("long longValue()");
final static Method floatValueMethod =
Method.getMethod("float floatValue()");
final static Method doubleValueMethod =
Method.getMethod("double doubleValue()");
final static Method byteValueMethod =
Method.getMethod("byte byteValue()");
606 CHAPTER 9. JVM/CLOJURE/LANG/
final static Method shortValueMethod =
Method.getMethod("short shortValue()");
final static Method fromIntMethod =
Method.getMethod("clojure.lang.Num from(int)");
final static Method fromLongMethod =
Method.getMethod("clojure.lang.Num from(long)");
final static Method fromDoubleMethod =
Method.getMethod("clojure.lang.Num from(double)");
//*
public static void emitBoxReturn(ObjExpr objx,
GeneratorAdapter gen,
Class returnType){
if(returnType.isPrimitive())
{
if(returnType == boolean.class)
{
Label falseLabel = gen.newLabel();
Label endLabel = gen.newLabel();
gen.ifZCmp(GeneratorAdapter.EQ, falseLabel);
gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE",
BOOLEAN_OBJECT_TYPE);
gen.goTo(endLabel);
gen.mark(falseLabel);
gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE",
BOOLEAN_OBJECT_TYPE);
// NIL_EXPR.emit(C.EXPRESSION, fn, gen);
gen.mark(endLabel);
}
else if(returnType == void.class)
{
NIL_EXPR.emit(C.EXPRESSION, objx, gen);
}
else if(returnType == char.class)
{
gen.invokeStatic(CHAR_TYPE, charValueOfMethod);
}
else
{
if(returnType == int.class)
{
gen.visitInsn(I2L);
gen.invokeStatic(NUMBERS_TYPE,
Method.getMethod("Number num(long)"));
}
else if(returnType == float.class)
{
gen.visitInsn(F2D);
9.24. COMPILER.JAVA 607
gen.invokeStatic(DOUBLE_TYPE,
doubleValueOfMethod);
}
else if(returnType == double.class)
gen.invokeStatic(DOUBLE_TYPE,
doubleValueOfMethod);
else if(returnType == long.class)
gen.invokeStatic(NUMBERS_TYPE,
Method.getMethod("Number num(long)"));
else if(returnType == byte.class)
gen.invokeStatic(BYTE_TYPE,
byteValueOfMethod);
else if(returnType == short.class)
gen.invokeStatic(SHORT_TYPE,
shortValueOfMethod);
}
}
}
//*/
public static void emitUnboxArg(ObjExpr objx,
GeneratorAdapter gen,
Class paramType){
if(paramType.isPrimitive())
{
if(paramType == boolean.class)
{
gen.checkCast(BOOLEAN_TYPE);
gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod);
// Label falseLabel = gen.newLabel();
// Label endLabel = gen.newLabel();
// gen.ifNull(falseLabel);
// gen.push(1);
// gen.goTo(endLabel);
// gen.mark(falseLabel);
// gen.push(0);
// gen.mark(endLabel);
}
else if(paramType == char.class)
{
gen.checkCast(CHAR_TYPE);
gen.invokeVirtual(CHAR_TYPE, charValueMethod);
}
else
{
Method m = null;
gen.checkCast(NUMBER_TYPE);
if(RT.booleanCast(UNCHECKED_MATH.deref()))
{
if(paramType == int.class)
608 CHAPTER 9. JVM/CLOJURE/LANG/
m = Method.getMethod(
"int uncheckedIntCast(Object)");
else if(paramType == float.class)
m = Method.getMethod(
"float uncheckedFloatCast(Object)");
else if(paramType == double.class)
m = Method.getMethod(
"double uncheckedDoubleCast(Object)");
else if(paramType == long.class)
m = Method.getMethod(
"long uncheckedLongCast(Object)");
else if(paramType == byte.class)
m = Method.getMethod(
"byte uncheckedByteCast(Object)");
else if(paramType == short.class)
m = Method.getMethod(
"short uncheckedShortCast(Object)");
}
else
{
if(paramType == int.class)
m = Method.getMethod("int intCast(Object)");
else if(paramType == float.class)
m = Method.getMethod("float floatCast(Object)");
else if(paramType == double.class)
m = Method.getMethod("double doubleCast(Object)");
else if(paramType == long.class)
m = Method.getMethod("long longCast(Object)");
else if(paramType == byte.class)
m = Method.getMethod("byte byteCast(Object)");
else if(paramType == short.class)
m = Method.getMethod("short shortCast(Object)");
}
gen.invokeStatic(RT_TYPE, m);
}
}
else
{
gen.checkCast(Type.getType(paramType));
}
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
//(. x fieldname-sym) or
//(. x 0-ary-method)
// (. x methodname-sym args+)
// (. x (methodname-sym args?))
if(RT.length(form) < 3)
9.24. COMPILER.JAVA 609
throw new IllegalArgumentException(
"Malformed member expression, expecting (. target member . ..)");
//determine static or instance
//static target must be symbol, either
// fully.qualified.Classname or Classname that has
// been imported
int line = (Integer) LINE.deref();
String source = (String) SOURCE.deref();
Class c = maybeClass(RT.second(form), false);
//at this point c will be non-null if static
Expr instance = null;
if(c == null)
instance =
analyze(context == C.EVAL ? context
: C.EXPRESSION, RT.second(form));
boolean maybeField = RT.length(form) == 3 &&
(RT.third(form) instanceof Symbol ||
RT.third(form) instanceof Keyword);
if(maybeField && !(RT.third(form) instanceof Keyword))
{
Symbol sym = (Symbol) RT.third(form);
if(c != null)
maybeField =
Reflector.getMethods(c, 0, munge(sym.name), true)
.size() == 0;
else if(instance != null &&
instance.hasJavaClass() &&
instance.getJavaClass() != null)
maybeField =
Reflector.getMethods(instance.getJavaClass(), 0,
munge(sym.name), false).size() == 0;
}
if(maybeField) //field
{
Symbol sym = (RT.third(form) instanceof Keyword)?
((Keyword)RT.third(form)).sym
:(Symbol) RT.third(form);
Symbol tag = tagOf(form);
if(c != null) {
return
new StaticFieldExpr(line, c, munge(sym.name), tag);
} else
return
new InstanceFieldExpr(line, instance,
munge(sym.name), tag);
}
else
{
ISeq call = (ISeq)
((RT.third(form) instanceof ISeq)
610 CHAPTER 9. JVM/CLOJURE/LANG/
? RT.third(form)
: RT.next(RT.next(form)));
if(!(RT.first(call) instanceof Symbol))
throw new IllegalArgumentException(
"Malformed member expression");
Symbol sym = (Symbol) RT.first(call);
Symbol tag = tagOf(form);
PersistentVector args = PersistentVector.EMPTY;
for(ISeq s = RT.next(call); s != null; s = s.next())
args =
args.cons(analyze(context == C.EVAL
? context
: C.EXPRESSION, s.first()));
if(c != null)
return
new StaticMethodExpr(source, line, tag, c,
munge(sym.name), args);
else
return
new InstanceMethodExpr(source, line, tag,
instance,
munge(sym.name), args);
}
}
}
private static Class maybeClass(Object form, boolean stri ngOk)
throws Exception{
if(form instanceof Class)
return (Class) form;
Class c = null;
if(form instanceof Symbol)
{
Symbol sym = (Symbol) form;
if(sym.ns == null) //if ns-qualified can’t be classname
{
if(Util.equals(sym,COMPILE_STUB_SYM.get()))
return (Class) COMPILE_STUB_CLASS.get();
if(sym.name.indexOf(’.’) > 0 ||
sym.name.charAt(0) == ’[’)
c = RT.classForName(sym.name);
else
{
Object o = currentNS().getMapping(sym);
if(o instanceof Class)
c = (Class) o;
else
{
try{
c = RT.classForName(sym.name);
9.24. COMPILER.JAVA 611
}
catch(Exception e){
//aargh
}
}
}
}
}
else if(stringOk && form instanceof String)
c = RT.classForName((String) form);
return c;
}
/*
private static String maybeClassName(Object form, boolea n stringOk){
String className = null;
if(form instanceof Symbol)
{
Symbol sym = (Symbol) form;
if(sym.ns == null) //if ns-qualified can’t be classname
{
if(sym.name.indexOf(’.’) > 0 ||
sym.name.charAt(0) == ’[’)
className = sym.name;
else
{
IPersistentMap imports =
(IPersistentMap)
((Var) RT.NS_IMPORTS.get()).get();
className = (String) imports.valAt(sym);
}
}
}
else if(stringOk && form instanceof String)
className = (String) form;
return className;
}
*/
static Class tagToClass(Object tag) throws Exception{
Class c = maybeClass(tag, true);
if(tag instanceof Symbol)
{
Symbol sym = (Symbol) tag;
if(sym.ns == null) //if ns-qualified can’t be classname
{
if(sym.name.equals("objects"))
c = Object[].class;
else if(sym.name.equals("ints"))
c = int[].class;
else if(sym.name.equals("longs"))
612 CHAPTER 9. JVM/CLOJURE/LANG/
c = long[].class;
else if(sym.name.equals("floats"))
c = float[].class;
else if(sym.name.equals("doubles"))
c = double[].class;
else if(sym.name.equals("chars"))
c = char[].class;
else if(sym.name.equals("shorts"))
c = short[].class;
else if(sym.name.equals("bytes"))
c = byte[].class;
else if(sym.name.equals("booleans"))
c = boolean[].class;
}
}
if(c != null)
return c;
throw new IllegalArgumentException(
"Unable to resolve classname: " + tag);
}
}
static abstract class FieldExpr extends HostExpr{
}
static class InstanceFieldExpr extends FieldExpr
implements AssignableExpr{
public final Expr target;
public final Class targetClass;
public final java.lang.reflect.Field field;
public final String fieldName;
public final int line;
public final Symbol tag;
final static Method invokeNoArgInstanceMember =
Method.getMethod(
"Object invokeNoArgInstanceMember(Object,String)");
final static Method setInstanceFieldMethod =
Method.getMethod(
"Object setInstanceField(Object,String,Object)");
public InstanceFieldExpr(int line,
Expr target,
String fieldName,
Symbol tag) throws Exception{
this.target = target;
this.targetClass =
target.hasJavaClass() ? target.getJavaClass() : null;
this.field =
targetClass != null
9.24. COMPILER.JAVA 613
? Reflector.getField(targetClass, fieldName, false)
: null;
this.fieldName = fieldName;
this.line = line;
this.tag = tag;
if(field == null &&
RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
{
RT.errPrintWriter()
.format("Reflection warning, %s:%d - "+
"reference to field %s can’t be resolved.\n",
SOURCE_PATH.deref(), line, fieldName);
}
}
public Object eval() throws Exception{
return
Reflector.invokeNoArgInstanceMember(target.eval(), f ieldName);
}
public boolean canEmitPrimitive(){
return targetClass != null && field != null &&
Util.isPrimitive(field.getType());
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
gen.visitLineNumber(line, gen.mark());
if(targetClass != null && field != null)
{
target.emit(C.EXPRESSION, objx, gen);
gen.checkCast(getType(targetClass));
gen.getField(getType(targetClass), fieldName,
Type.getType(field.getType()));
}
else
throw new UnsupportedOperationException(
"Unboxed emit of unknown member");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.visitLineNumber(line, gen.mark());
if(targetClass != null && field != null)
{
target.emit(C.EXPRESSION, objx, gen);
gen.checkCast(getType(targetClass));
gen.getField(getType(targetClass), fieldName,
Type.getType(field.getType()));
//if(context != C.STATEMENT)
614 CHAPTER 9. JVM/CLOJURE/LANG/
HostExpr.emitBoxReturn(objx, gen, field.getType());
if(context == C.STATEMENT)
{
gen.pop();
}
}
else
{
target.emit(C.EXPRESSION, objx, gen);
gen.push(fieldName);
gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstance Member);
if(context == C.STATEMENT)
gen.pop();
}
}
public boolean hasJavaClass() throws Exception{
return field != null || tag != null;
}
public Class getJavaClass() throws Exception{
return tag != null ? HostExpr.tagToClass(tag) : field.getT ype();
}
public Object evalAssign(Expr val) throws Exception{
return
Reflector.setInstanceField(target.eval(),
fieldName,
val.eval());
}
public void emitAssign(C context,
ObjExpr objx,
GeneratorAdapter gen,
Expr val){
gen.visitLineNumber(line, gen.mark());
if(targetClass != null && field != null)
{
target.emit(C.EXPRESSION, objx, gen);
gen.checkCast(Type.getType(targetClass));
val.emit(C.EXPRESSION, objx, gen);
gen.dupX1();
HostExpr.emitUnboxArg(objx, gen, field.getType());
gen.putField(Type.getType(targetClass), fieldName,
Type.getType(field.getType()));
}
else
{
target.emit(C.EXPRESSION, objx, gen);
gen.push(fieldName);
9.24. COMPILER.JAVA 615
val.emit(C.EXPRESSION, objx, gen);
gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMet hod);
}
if(context == C.STATEMENT)
gen.pop();
}
}
static class StaticFieldExpr extends FieldExpr implement s AssignableExpr{
//final String className;
public final String fieldName;
public final Class c;
public final java.lang.reflect.Field field;
public final Symbol tag;
// final static Method getStaticFieldMethod =
// Method.getMethod("Object getStaticField(String,Str ing)");
// final static Method setStaticFieldMethod =
// Method.getMethod("Object setStaticField(String,Str ing,Object)");
final int line;
public StaticFieldExpr(int line,
Class c,
String fieldName,
Symbol tag) throws Exception{
//this.className = className;
this.fieldName = fieldName;
this.line = line;
//c = Class.forName(className);
this.c = c;
field = c.getField(fieldName);
this.tag = tag;
}
public Object eval() throws Exception{
return Reflector.getStaticField(c, fieldName);
}
public boolean canEmitPrimitive(){
return Util.isPrimitive(field.getType());
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
gen.visitLineNumber(line, gen.mark());
gen.getStatic(Type.getType(c), fieldName,
Type.getType(field.getType()));
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
616 CHAPTER 9. JVM/CLOJURE/LANG/
gen.visitLineNumber(line, gen.mark());
gen.getStatic(Type.getType(c), fieldName,
Type.getType(field.getType()));
//if(context != C.STATEMENT)
HostExpr.emitBoxReturn(objx, gen, field.getType());
if(context == C.STATEMENT)
{
gen.pop();
}
// gen.push(className);
// gen.push(fieldName);
// gen.invokeStatic(REFLECTOR_TYPE, getStaticFieldMet hod);
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws Exception{
//Class c = Class.forName(className);
//java.lang.reflect.Field field = c.getField(fieldName );
return tag != null ? HostExpr.tagToClass(tag) : field.getT ype();
}
public Object evalAssign(Expr val) throws Exception{
return Reflector.setStaticField(c, fieldName, val.eval ());
}
public void emitAssign(C context, ObjExpr objx, Generator Adapter gen,
Expr val){
gen.visitLineNumber(line, gen.mark());
val.emit(C.EXPRESSION, objx, gen);
gen.dup();
HostExpr.emitUnboxArg(objx, gen, field.getType());
gen.putStatic(Type.getType(c),
fieldName, Type.getType(field.getType()));
if(context == C.STATEMENT)
gen.pop();
}
}
static Class maybePrimitiveType(Expr e){
try
{
if(e instanceof MaybePrimitiveExpr &&
e.hasJavaClass() &&
((MaybePrimitiveExpr)e).canEmitPrimitive())
9.24. COMPILER.JAVA 617
{
Class c = e.getJavaClass();
if(Util.isPrimitive(c))
return c;
}
}
catch(Exception ex)
{
throw new RuntimeException(ex);
}
return null;
}
static abstract class MethodExpr extends HostExpr{
static void emitArgsAsArray(IPersistentVector args,
ObjExpr objx,
GeneratorAdapter gen){
gen.push(args.count());
gen.newArray(OBJECT_TYPE);
for(int i = 0; i < args.count(); i++)
{
gen.dup();
gen.push(i);
((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen);
gen.arrayStore(OBJECT_TYPE);
}
}
public static void emitTypedArgs(ObjExpr objx,
GeneratorAdapter gen,
Class[] parameterTypes,
IPersistentVector args){
for(int i = 0; i < parameterTypes.length; i++)
{
Expr e = (Expr) args.nth(i);
try
{
final Class primc = maybePrimitiveType(e);
if(primc == parameterTypes[i])
{
final MaybePrimitiveExpr pe =
(MaybePrimitiveExpr) e;
pe.emitUnboxed(C.EXPRESSION, objx, gen);
}
else if(primc == int.class &&
parameterTypes[i] == long.class)
{
final MaybePrimitiveExpr pe =
(MaybePrimitiveExpr) e;
pe.emitUnboxed(C.EXPRESSION, objx, gen);
618 CHAPTER 9. JVM/CLOJURE/LANG/
gen.visitInsn(I2L);
}
else if(primc == long.class &&
parameterTypes[i] == int.class)
{
final MaybePrimitiveExpr pe =
(MaybePrimitiveExpr) e;
pe.emitUnboxed(C.EXPRESSION, objx, gen);
if(RT.booleanCast(UNCHECKED_MATH.deref()))
gen.invokeStatic(RT_TYPE,
Method.getMethod("int uncheckedIntCast(long)"));
else
gen.invokeStatic(RT_TYPE,
Method.getMethod("int intCast(long)"));
}
else if(primc == float.class &&
parameterTypes[i] == double.class)
{
final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e;
pe.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitInsn(F2D);
}
else if(primc == double.class &&
parameterTypes[i] == float.class)
{
final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e;
pe.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitInsn(D2F);
}
else
{
e.emit(C.EXPRESSION, objx, gen);
HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]);
}
}
catch(Exception e1)
{
e1.printStackTrace(RT.errPrintWriter());
}
}
}
}
static class InstanceMethodExpr extends MethodExpr{
public final Expr target;
public final String methodName;
public final IPersistentVector args;
public final String source;
public final int line;
9.24. COMPILER.JAVA 619
public final Symbol tag;
public final java.lang.reflect.Method method;
final static Method invokeInstanceMethodMethod =
Method.getMethod(
"Object invokeInstanceMethod(Object,String,Object[]) ");
public InstanceMethodExpr(String source,
int line,
Symbol tag,
Expr target,
String methodName,
IPersistentVector args)
throws Exception{
this.source = source;
this.line = line;
this.args = args;
this.methodName = methodName;
this.target = target;
this.tag = tag;
if(target.hasJavaClass() && target.getJavaClass() != nu ll)
{
List methods =
Reflector.getMethods(target.getJavaClass(),
args.count(), methodName, false);
if(methods.isEmpty())
method = null;
//throw new IllegalArgumentException(
// "No matching method found");
else
{
int methodidx = 0;
if(methods.size() > 1)
{
ArrayList<Class[]> params = new ArrayList();
ArrayList<Class> rets = new ArrayList();
for(int i = 0; i < methods.size(); i++)
{
java.lang.reflect.Method m =
(java.lang.reflect.Method) methods.get(i);
params.add(m.getParameterTypes());
rets.add(m.getReturnType());
}
methodidx =
getMatchingParams(methodName, params, args, rets);
}
java.lang.reflect.Method m =
(java.lang.reflect.Method)
(methodidx >= 0
620 CHAPTER 9. JVM/CLOJURE/LANG/
? methods.get(methodidx)
: null);
if(m != null &&
!Modifier.isPublic(m.getDeclaringClass()
.getModifiers()))
{
//public method of non-public class, try to find
// it in hierarchy
m = Reflector.getAsMethodOfPublicBase(
m.getDeclaringClass(), m);
}
method = m;
}
}
else
method = null;
if(method == null &&
RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
{
RT.errPrintWriter()
.format(
"Reflection warning, %s:%d - call to %s can’t be resolved.\n ",
SOURCE_PATH.deref(), line, methodName);
}
}
public Object eval() throws Exception{
try
{
Object targetval = target.eval();
Object[] argvals = new Object[args.count()];
for(int i = 0; i < args.count(); i++)
argvals[i] = ((Expr) args.nth(i)).eval();
if(method != null)
{
LinkedList ms = new LinkedList();
ms.add(method);
return Reflector.invokeMatchingMethod(methodName, ms,
targetval,
argvals);
}
return Reflector.invokeInstanceMethod(targetval,
methodName,
argvals);
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(source, line, e);
9.24. COMPILER.JAVA 621
else
throw (CompilerException) e;
}
}
public boolean canEmitPrimitive(){
return method != null &&
Util.isPrimitive(method.getReturnType());
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
gen.visitLineNumber(line, gen.mark());
if(method != null)
{
Type type = Type.getType(method.getDeclaringClass());
target.emit(C.EXPRESSION, objx, gen);
//if(!method.getDeclaringClass().isInterface())
gen.checkCast(type);
MethodExpr.emitTypedArgs(objx, gen,
method.getParameterTypes(), args);
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
Method m = new Method(methodName,
Type.getReturnType(method),
Type.getArgumentTypes(method));
if(method.getDeclaringClass().isInterface())
gen.invokeInterface(type, m);
else
gen.invokeVirtual(type, m);
}
else
throw new UnsupportedOperationException(
"Unboxed emit of unknown member");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.visitLineNumber(line, gen.mark());
if(method != null)
{
Type type = Type.getType(method.getDeclaringClass());
target.emit(C.EXPRESSION, objx, gen);
//if(!method.getDeclaringClass().isInterface())
gen.checkCast(type);
MethodExpr.emitTypedArgs(objx, gen,
method.getParameterTypes(), args);
622 CHAPTER 9. JVM/CLOJURE/LANG/
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
Method m = new Method(methodName,
Type.getReturnType(method),
Type.getArgumentTypes(method));
if(method.getDeclaringClass().isInterface())
gen.invokeInterface(type, m);
else
gen.invokeVirtual(type, m);
//if(context != C.STATEMENT ||
// method.getReturnType() == Void.TYPE)
HostExpr.emitBoxReturn(objx, gen, method.getReturnTyp e());
}
else
{
target.emit(C.EXPRESSION, objx, gen);
gen.push(methodName);
emitArgsAsArray(args, objx, gen);
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMetho dMethod);
}
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return method != null || tag != null;
}
public Class getJavaClass() throws Exception{
return tag != null
? HostExpr.tagToClass(tag)
: method.getReturnType();
}
}
static class StaticMethodExpr extends MethodExpr{
//final String className;
public final Class c;
public final String methodName;
public final IPersistentVector args;
public final String source;
9.24. COMPILER.JAVA 623
public final int line;
public final java.lang.reflect.Method method;
public final Symbol tag;
final static Method forNameMethod =
Method.getMethod("Class forName(String)");
final static Method invokeStaticMethodMethod =
Method.getMethod(
"Object invokeStaticMethod(Class,String,Object[])");
public StaticMethodExpr(String source, int line, Symbol t ag,
Class c, String methodName,
IPersistentVector args)
throws Exception{
this.c = c;
this.methodName = methodName;
this.args = args;
this.source = source;
this.line = line;
this.tag = tag;
List methods =
Reflector.getMethods(c, args.count(), methodName, true );
if(methods.isEmpty())
throw new IllegalArgumentException(
"No matching method: " + methodName);
int methodidx = 0;
if(methods.size() > 1)
{
ArrayList<Class[]> params = new ArrayList();
ArrayList<Class> rets = new ArrayList();
for(int i = 0; i < methods.size(); i++)
{
java.lang.reflect.Method m =
(java.lang.reflect.Method) methods.get(i);
params.add(m.getParameterTypes());
rets.add(m.getReturnType());
}
methodidx =
getMatchingParams(methodName, params, args, rets);
}
method = (java.lang.reflect.Method)
(methodidx >= 0 ? methods.get(methodidx) : null);
if(method == null &&
RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
{
RT.errPrintWriter()
.format(
"Reflection warning, %s:%d - call to %s can’t be resolved.\n ",
624 CHAPTER 9. JVM/CLOJURE/LANG/
SOURCE_PATH.deref(), line, methodName);
}
}
public Object eval() throws Exception{
try
{
Object[] argvals = new Object[args.count()];
for(int i = 0; i < args.count(); i++)
argvals[i] = ((Expr) args.nth(i)).eval();
if(method != null)
{
LinkedList ms = new LinkedList();
ms.add(method);
return Reflector.invokeMatchingMethod(methodName, ms,
null, argvals);
}
return Reflector.invokeStaticMethod(c, methodName, arg vals);
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(source, line, e);
else
throw (CompilerException) e;
}
}
public boolean canEmitPrimitive(){
return method != null &&
Util.isPrimitive(method.getReturnType());
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
gen.visitLineNumber(line, gen.mark());
if(method != null)
{
MethodExpr.emitTypedArgs(objx, gen,
method.getParameterTypes(),
args);
//Type type =
// Type.getObjectType(className.replace(’.’, ’/’));
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
Type type = Type.getType(c);
9.24. COMPILER.JAVA 625
Method m = new Method(methodName,
Type.getReturnType(method),
Type.getArgumentTypes(method));
gen.invokeStatic(type, m);
}
else
throw new UnsupportedOperationException(
"Unboxed emit of unknown member");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.visitLineNumber(line, gen.mark());
if(method != null)
{
MethodExpr.emitTypedArgs(objx, gen,
method.getParameterTypes(),
args);
//Type type =
// Type.getObjectType(className.replace(’.’, ’/’));
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
Type type = Type.getType(c);
Method m = new Method(methodName,
Type.getReturnType(method),
Type.getArgumentTypes(method));
gen.invokeStatic(type, m);
//if(context != C.STATEMENT ||
// method.getReturnType() == Void.TYPE)
Class retClass = method.getReturnType();
if(context == C.STATEMENT)
{
if(retClass == long.class || retClass == double.class)
gen.pop2();
else if(retClass != void.class)
gen.pop();
}
else
{
HostExpr.emitBoxReturn(objx, gen,
method.getReturnType());
}
}
else
{
gen.push(c.getName());
gen.invokeStatic(CLASS_TYPE, forNameMethod);
gen.push(methodName);
626 CHAPTER 9. JVM/CLOJURE/LANG/
emitArgsAsArray(args, objx, gen);
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodM ethod);
if(context == C.STATEMENT)
gen.pop();
}
}
public boolean hasJavaClass(){
return method != null || tag != null;
}
public Class getJavaClass() throws Exception{
return tag != null
? HostExpr.tagToClass(tag)
: method.getReturnType();
}
}
static class UnresolvedVarExpr implements Expr{
public final Symbol symbol;
public UnresolvedVarExpr(Symbol symbol){
this.symbol = symbol;
}
public boolean hasJavaClass(){
return false;
}
public Class getJavaClass() throws Exception{
throw new IllegalArgumentException(
"UnresolvedVarExpr has no Java class");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
}
public Object eval() throws Exception{
throw new IllegalArgumentException(
"UnresolvedVarExpr cannot be evalled");
}
}
static class NumberExpr extends LiteralExpr
implements MaybePrimitiveExpr{
9.24. COMPILER.JAVA 627
final Number n;
public final int id;
public NumberExpr(Number n){
this.n = n;
this.id = registerConstant(n);
}
Object val(){
return n;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
if(context != C.STATEMENT)
{
objx.emitConstant(gen, id);
// emitUnboxed(context,objx,gen);
// HostExpr.emitBoxReturn(objx,gen,getJavaClass());
}
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass(){
if(n instanceof Integer)
return long.class;
else if(n instanceof Double)
return double.class;
else if(n instanceof Long)
return long.class;
else
throw new IllegalStateException(
"Unsupported Number type: " + n.getClass().getName());
}
public boolean canEmitPrimitive(){
return true;
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
if(n instanceof Integer)
gen.push(n.longValue());
else if(n instanceof Double)
gen.push(n.doubleValue());
else if(n instanceof Long)
gen.push(n.longValue());
628 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public Expr parse(Number form){
if(form instanceof Integer
|| form instanceof Double
|| form instanceof Long)
return new NumberExpr(form);
else
return new ConstantExpr(form);
}
}
static class ConstantExpr extends LiteralExpr{
//stuff quoted vals in classloader at compile time, pull out
//at runtime this won’t work for static compilation...
public final Object v;
public final int id;
public ConstantExpr(Object v){
this.v = v;
this.id = registerConstant(v);
// this.id = RT.nextID();
// DynamicClassLoader loader = (DynamicClassLoader) LOAD ER.get();
// loader.registerQuotedVal(id, v);
}
Object val(){
return v;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
objx.emitConstant(gen, id);
if(context == C.STATEMENT)
{
gen.pop();
// gen.loadThis();
// gen.invokeVirtual(OBJECT_TYPE, getClassMethod);
// gen.invokeVirtual(CLASS_TYPE, getClassLoaderMethod );
// gen.checkCast(DYNAMIC_CLASSLOADER_TYPE);
// gen.push(id);
// gen.invokeVirtual(DYNAMIC_CLASSLOADER_TYPE,
// getQuotedValMethod);
}
}
public boolean hasJavaClass(){
return Modifier.isPublic(v.getClass().getModifiers() );
//return false;
}
9.24. COMPILER.JAVA 629
public Class getJavaClass() throws Exception{
return v.getClass();
//throw new IllegalArgumentException("Has no Java class" );
}
static class Parser implements IParser{
public Expr parse(C context, Object form){
Object v = RT.second(form);
if(v == null)
return NIL_EXPR;
// Class fclass = v.getClass();
// if(fclass == Keyword.class)
// return registerKeyword((Keyword) v);
// else if(v instanceof Num)
// return new NumExpr((Num) v);
// else if(fclass == String.class)
// return new StringExpr((String) v);
// else if(fclass == Character.class)
// return new CharExpr((Character) v);
// else if(v instanceof IPersistentCollection &&
// ((IPersistentCollection) v).count() == 0)
// return new EmptyExpr(v);
else
return new ConstantExpr(v);
}
}
}
static class NilExpr extends LiteralExpr{
Object val(){
return null;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.visitInsn(Opcodes.ACONST_NULL);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws Exception{
return null;
}
}
final static NilExpr NIL_EXPR = new NilExpr();
630 CHAPTER 9. JVM/CLOJURE/LANG/
static class BooleanExpr extends LiteralExpr{
public final boolean val;
public BooleanExpr(boolean val){
this.val = val;
}
Object val(){
return val ? RT.T : RT.F;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
if(val)
gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE",
BOOLEAN_OBJECT_TYPE);
else
gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE",
BOOLEAN_OBJECT_TYPE);
if(context == C.STATEMENT)
{
gen.pop();
}
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws Exception{
return Boolean.class;
}
}
final static BooleanExpr TRUE_EXPR = new BooleanExpr(true );
final static BooleanExpr FALSE_EXPR = new BooleanExpr(fal se);
static class StringExpr extends LiteralExpr{
public final String str;
public StringExpr(String str){
this.str = str;
}
Object val(){
return str;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
9.24. COMPILER.JAVA 631
if(context != C.STATEMENT)
gen.push(str);
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws Exception{
return String.class;
}
}
static class MonitorEnterExpr extends UntypedExpr{
final Expr target;
public MonitorEnterExpr(Expr target){
this.target = target;
}
public Object eval() throws Exception{
throw
new UnsupportedOperationException("Can’t eval monitor- enter");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
target.emit(C.EXPRESSION, objx, gen);
gen.monitorEnter();
NIL_EXPR.emit(context, objx, gen);
}
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
return
new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second( form)));
}
}
}
static class MonitorExitExpr extends UntypedExpr{
final Expr target;
public MonitorExitExpr(Expr target){
this.target = target;
}
public Object eval() throws Exception{
throw
new UnsupportedOperationException("Can’t eval monitor- exit");
632 CHAPTER 9. JVM/CLOJURE/LANG/
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
target.emit(C.EXPRESSION, objx, gen);
gen.monitorExit();
NIL_EXPR.emit(context, objx, gen);
}
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
return
new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(f orm)));
}
}
}
public static class TryExpr implements Expr{
public final Expr tryExpr;
public final Expr finallyExpr;
public final PersistentVector catchExprs;
public final int retLocal;
public final int finallyLocal;
public static class CatchClause{
//final String className;
public final Class c;
public final LocalBinding lb;
public final Expr handler;
Label label;
Label endLabel;
public CatchClause(Class c, LocalBinding lb, Expr handler ){
this.c = c;
this.lb = lb;
this.handler = handler;
}
}
public TryExpr(Expr tryExpr,
PersistentVector catchExprs,
Expr finallyExpr,
int retLocal,
int finallyLocal){
this.tryExpr = tryExpr;
this.catchExprs = catchExprs;
this.finallyExpr = finallyExpr;
this.retLocal = retLocal;
this.finallyLocal = finallyLocal;
9.24. COMPILER.JAVA 633
}
public Object eval() throws Exception{
throw new UnsupportedOperationException("Can’t eval try ");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
Label startTry = gen.newLabel();
Label endTry = gen.newLabel();
Label end = gen.newLabel();
Label ret = gen.newLabel();
Label finallyLabel = gen.newLabel();
for(int i = 0; i < catchExprs.count(); i++)
{
CatchClause clause = (CatchClause) catchExprs.nth(i);
clause.label = gen.newLabel();
clause.endLabel = gen.newLabel();
}
gen.mark(startTry);
tryExpr.emit(context, objx, gen);
if(context != C.STATEMENT)
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTO RE),
retLocal);
gen.mark(endTry);
if(finallyExpr != null)
finallyExpr.emit(C.STATEMENT, objx, gen);
gen.goTo(ret);
for(int i = 0; i < catchExprs.count(); i++)
{
CatchClause clause = (CatchClause) catchExprs.nth(i);
gen.mark(clause.label);
//exception should be on stack
//put in clause local
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTO RE),
clause.lb.idx);
clause.handler.emit(context, objx, gen);
if(context != C.STATEMENT)
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTO RE),
retLocal);
gen.mark(clause.endLabel);
if(finallyExpr != null)
finallyExpr.emit(C.STATEMENT, objx, gen);
gen.goTo(ret);
}
if(finallyExpr != null)
{
gen.mark(finallyLabel);
634 CHAPTER 9. JVM/CLOJURE/LANG/
//exception should be on stack
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTO RE),
finallyLocal);
finallyExpr.emit(C.STATEMENT, objx, gen);
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOA D),
finallyLocal);
gen.throwException();
}
gen.mark(ret);
if(context != C.STATEMENT)
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOA D),
retLocal);
gen.mark(end);
for(int i = 0; i < catchExprs.count(); i++)
{
CatchClause clause = (CatchClause) catchExprs.nth(i);
gen.visitTryCatchBlock(startTry, endTry, clause.label ,
clause.c.getName()
.replace(’.’, ’/’));
}
if(finallyExpr != null)
{
gen.visitTryCatchBlock(startTry, endTry,
finallyLabel, null);
for(int i = 0; i < catchExprs.count(); i++)
{
CatchClause clause = (CatchClause) catchExprs.nth(i);
gen.visitTryCatchBlock(clause.label,
clause.endLabel,
finallyLabel, null);
}
}
for(int i = 0; i < catchExprs.count(); i++)
{
CatchClause clause = (CatchClause) catchExprs.nth(i);
gen.visitLocalVariable(clause.lb.name,
"Ljava/lang/Object;", null,
clause.label, clause.endLabel,
clause.lb.idx);
}
}
public boolean hasJavaClass() throws Exception{
return tryExpr.hasJavaClass();
}
public Class getJavaClass() throws Exception{
return tryExpr.getJavaClass();
}
9.24. COMPILER.JAVA 635
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
// if(context == C.EVAL || context == C.EXPRESSION)
if(context != C.RETURN)
return analyze(context,
RT.list(
RT.list(FN,
PersistentVector.EMPTY, form)));
//(try try-expr* catch-expr* finally-expr?)
//catch-expr: (catch class sym expr*)
//finally-expr: (finally expr*)
PersistentVector body = PersistentVector.EMPTY;
PersistentVector catches = PersistentVector.EMPTY;
Expr bodyExpr = null;
Expr finallyExpr = null;
boolean caught = false;
int retLocal = getAndIncLocalNum();
int finallyLocal = getAndIncLocalNum();
for(ISeq fs = form.next(); fs != null; fs = fs.next())
{
Object f = fs.first();
Object op =
(f instanceof ISeq) ? ((ISeq) f).first() : null;
if(!Util.equals(op, CATCH) &&
!Util.equals(op, FINALLY))
{
if(caught)
throw new Exception(
"Only catch or finally clause can follow catch in try express ion");
body = body.cons(f);
}
else
{
if(bodyExpr == null)
try {
Var.pushThreadBindings(RT.map(NO_RECUR, true));
bodyExpr =
(new BodyExpr.Parser())
.parse(context, RT.seq(body));
} finally {
Var.popThreadBindings();
}
if(Util.equals(op, CATCH))
{
Class c =
636 CHAPTER 9. JVM/CLOJURE/LANG/
HostExpr.maybeClass(RT.second(f), false);
if(c == null)
throw new IllegalArgumentException(
"Unable to resolve classname: " +
RT.second(f));
if(!(RT.third(f) instanceof Symbol))
throw new IllegalArgumentException(
"Bad binding form, expected symbol, got: "
+ RT.third(f));
Symbol sym = (Symbol) RT.third(f);
if(sym.getNamespace() != null)
throw new Exception(
"Can’t bind qualified name:" + sym);
IPersistentMap dynamicBindings =
RT.map(LOCAL_ENV, LOCAL_ENV.deref(),
NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(),
IN_CATCH_FINALLY, RT.T);
try
{
Var.pushThreadBindings(dynamicBindings);
LocalBinding lb =
registerLocal(sym,
(Symbol)
(RT.second(f) instanceof Symbol
? RT.second(f)
: null),
null,false);
Expr handler =
(new BodyExpr.Parser())
.parse(context,
RT.next(RT.next(RT.next(f))));
catches =
catches.cons(
new CatchClause(c, lb, handler));
}
finally
{
Var.popThreadBindings();
}
caught = true;
}
else //finally
{
if(fs.next() != null)
throw new Exception(
"finally clause must be last in try expression");
try
{
Var.pushThreadBindings(
9.24. COMPILER.JAVA 637
RT.map(IN_CATCH_FINALLY, RT.T));
finallyExpr =
(new BodyExpr.Parser())
.parse(C.STATEMENT, RT.next(f));
}
finally
{
Var.popThreadBindings();
}
}
}
}
if(bodyExpr == null) {
try
{
Var.pushThreadBindings(
RT.map(NO_RECUR, true));
bodyExpr =
(new BodyExpr.Parser())
.parse(context, RT.seq(body));
}
finally
{
Var.popThreadBindings();
}
}
return new TryExpr(bodyExpr, catches, finallyExpr, retLo cal,
finallyLocal);
}
}
}
//static class TryFinallyExpr implements Expr{
// final Expr tryExpr;
// final Expr finallyExpr;
//
//
// public TryFinallyExpr(Expr tryExpr, Expr finallyExpr) {
// this.tryExpr = tryExpr;
// this.finallyExpr = finallyExpr;
// }
//
// public Object eval() throws Exception{
// throw new UnsupportedOperationException("Can’t eval t ry");
// }
//
// public void emit(C context, FnExpr fn, GeneratorAdapter gen){
// Label startTry = gen.newLabel();
// Label endTry = gen.newLabel();
638 CHAPTER 9. JVM/CLOJURE/LANG/
// Label end = gen.newLabel();
// Label finallyLabel = gen.newLabel();
// gen.visitTryCatchBlock(startTry, endTry, finallyLab el, null);
// gen.mark(startTry);
// tryExpr.emit(context, fn, gen);
// gen.mark(endTry);
// finallyExpr.emit(C.STATEMENT, fn, gen);
// gen.goTo(end);
// gen.mark(finallyLabel);
// //exception should be on stack
// finallyExpr.emit(C.STATEMENT, fn, gen);
// gen.throwException();
// gen.mark(end);
// }
//
// public boolean hasJavaClass() throws Exception{
// return tryExpr.hasJavaClass();
// }
//
// public Class getJavaClass() throws Exception{
// return tryExpr.getJavaClass();
// }
//
// static class Parser implements IParser{
// public Expr parse(C context, Object frm) throws Exceptio n{
// ISeq form = (ISeq) frm;
// //(try-finally try-expr finally-expr)
// if(form.count() != 3)
// throw new IllegalArgumentException(
// "Wrong number of arguments, expecting: "+
// "(try-finally try-expr finally-expr) ");
//
// if(context == C.EVAL || context == C.EXPRESSION)
// return analyze(context,
// RT.list(
// RT.list(FN,
// PersistentVector.EMPTY,
// form)));
//
// return
// new TryFinallyExpr(analyze(context, RT.second(form) ),
// analyze(C.STATEMENT, RT.third(form)));
// }
// }
//}
static class ThrowExpr extends UntypedExpr{
public final Expr excExpr;
public ThrowExpr(Expr excExpr){
9.24. COMPILER.JAVA 639
this.excExpr = excExpr;
}
public Object eval() throws Exception{
throw new Exception("Can’t eval throw");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
excExpr.emit(C.EXPRESSION, objx, gen);
gen.checkCast(THROWABLE_TYPE);
gen.throwException();
}
static class Parser implements IParser{
public Expr parse(C context, Object form) throws Exception {
if(context == C.EVAL)
return
analyze(context,
RT.list(
RT.list(FN, PersistentVector.EMPTY, form)));
return new ThrowExpr(analyze(C.EXPRESSION, RT.second(f orm)));
}
}
}
static public boolean subsumes(Class[] c1, Class[] c2){
//presumes matching lengths
Boolean better = false;
for(int i = 0; i < c1.length; i++)
{
if(c1[i] != c2[i])
// || c2[i].isPrimitive() && c1[i] == Object.class))
{
if(!c1[i].isPrimitive() && c2[i].isPrimitive()
//|| Number.class.isAssignableFrom(c1[i]) &&
// c2[i].isPrimitive()
||
c2[i].isAssignableFrom(c1[i]))
better = true;
else
return false;
}
}
return better;
}
static int getMatchingParams(String methodName,
ArrayList<Class[]> paramlists,
640 CHAPTER 9. JVM/CLOJURE/LANG/
IPersistentVector argexprs,
List<Class> rets)
throws Exception{
//presumes matching lengths
int matchIdx = -1;
boolean tied = false;
boolean foundExact = false;
for(int i = 0; i < paramlists.size(); i++)
{
boolean match = true;
ISeq aseq = argexprs.seq();
int exact = 0;
for(int p = 0; match &&
p < argexprs.count() &&
aseq != null;
++p, aseq = aseq.next())
{
Expr arg = (Expr) aseq.first();
Class aclass =
arg.hasJavaClass() ? arg.getJavaClass() : Object.class;
Class pclass = paramlists.get(i)[p];
if(arg.hasJavaClass() && aclass == pclass)
exact++;
else
match = Reflector.paramArgTypeMatch(pclass, aclass);
}
if(exact == argexprs.count())
{
if(!foundExact ||
matchIdx == -1 ||
rets.get(matchIdx).isAssignableFrom(rets.get(i)))
matchIdx = i;
foundExact = true;
}
else if(match && !foundExact)
{
if(matchIdx == -1)
matchIdx = i;
else
{
if(subsumes(paramlists.get(i), paramlists.get(matchI dx)))
{
matchIdx = i;
tied = false;
}
else if(Arrays.equals(paramlists.get(matchIdx),
paramlists.get(i)))
{
if(rets.get(matchIdx).isAssignableFrom(rets.get(i)) )
matchIdx = i;
9.24. COMPILER.JAVA 641
}
else if(!(subsumes(paramlists.get(matchIdx),
paramlists.get(i))))
tied = true;
}
}
}
if(tied)
throw new IllegalArgumentException(
"More than one matching method found: " + methodName);
return matchIdx;
}
public static class NewExpr implements Expr{
public final IPersistentVector args;
public final Constructor ctor;
public final Class c;
final static Method invokeConstructorMethod =
Method.getMethod("Object invokeConstructor(Class,Obj ect[])");
// final static Method forNameMethod =
// Method.getMethod("Class classForName(String)");
final static Method forNameMethod =
Method.getMethod("Class forName(String)");
public NewExpr(Class c, IPersistentVector args, int line)
throws Exception{
this.args = args;
this.c = c;
Constructor[] allctors = c.getConstructors();
ArrayList ctors = new ArrayList();
ArrayList<Class[]> params = new ArrayList();
ArrayList<Class> rets = new ArrayList();
for(int i = 0; i < allctors.length; i++)
{
Constructor ctor = allctors[i];
if(ctor.getParameterTypes().length == args.count())
{
ctors.add(ctor);
params.add(ctor.getParameterTypes());
rets.add(c);
}
}
if(ctors.isEmpty())
throw new IllegalArgumentException(
"No matching ctor found for " + c);
int ctoridx = 0;
if(ctors.size() > 1)
642 CHAPTER 9. JVM/CLOJURE/LANG/
{
ctoridx = getMatchingParams(c.getName(), params, args, r ets);
}
this.ctor =
ctoridx >= 0 ? (Constructor) ctors.get(ctoridx) : null;
if(ctor == null &&
RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
{
RT.errPrintWriter()
.format(
"Reflection warning, %s:%d - call to %s ctor can’t be resolve d.\n",
SOURCE_PATH.deref(), line, c.getName());
}
}
public Object eval() throws Exception{
Object[] argvals = new Object[args.count()];
for(int i = 0; i < args.count(); i++)
argvals[i] = ((Expr) args.nth(i)).eval();
if(this.ctor != null)
{
return
ctor.newInstance(
Reflector.boxArgs(ctor.getParameterTypes(), argvals) );
}
return Reflector.invokeConstructor(c, argvals);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
if(this.ctor != null)
{
Type type = getType(c);
gen.newInstance(type);
gen.dup();
MethodExpr.emitTypedArgs(objx, gen, ctor.
getParameterTypes(), args);
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
gen.invokeConstructor(type,
new Method("<init>",
Type.getConstructorDescriptor(ctor)));
}
else
{
gen.push(destubClassName(c.getName()));
gen.invokeStatic(CLASS_TYPE, forNameMethod);
9.24. COMPILER.JAVA 643
MethodExpr.emitArgsAsArray(args, objx, gen);
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMe thod);
}
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass(){
return true;
}
public Class getJavaClass() throws Exception{
return c;
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
int line = (Integer) LINE.deref();
ISeq form = (ISeq) frm;
//(new Classname args...)
if(form.count() < 2)
throw new Exception(
"wrong number of arguments, expecting: (new Classname args ...)");
Class c = HostExpr.maybeClass(RT.second(form), false);
if(c == null)
throw new IllegalArgumentException(
"Unable to resolve classname: " + RT.second(form));
PersistentVector args = PersistentVector.EMPTY;
for(ISeq s = RT.next(RT.next(form)); s != null; s = s.next() )
args =
args.cons(analyze(context == C.EVAL
? context
: C.EXPRESSION, s.first()));
return new NewExpr(c, args, line);
}
}
}
public static class MetaExpr implements Expr{
public final Expr expr;
public final Expr meta;
final static Type IOBJ_TYPE = Type.getType(IObj.class);
final static Method withMetaMethod =
Method.getMethod(
644 CHAPTER 9. JVM/CLOJURE/LANG/
"clojure.lang.IObj withMeta(clojure.lang.IPersistent Map)");
public MetaExpr(Expr expr, Expr meta){
this.expr = expr;
this.meta = meta;
}
public Object eval() throws Exception{
return ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval());
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
expr.emit(C.EXPRESSION, objx, gen);
gen.checkCast(IOBJ_TYPE);
meta.emit(C.EXPRESSION, objx, gen);
gen.checkCast(IPERSISTENTMAP_TYPE);
gen.invokeInterface(IOBJ_TYPE, withMetaMethod);
if(context == C.STATEMENT)
{
gen.pop();
}
}
public boolean hasJavaClass() throws Exception{
return expr.hasJavaClass();
}
public Class getJavaClass() throws Exception{
return expr.getJavaClass();
}
}
public static class IfExpr implements Expr, MaybePrimitiv eExpr{
public final Expr testExpr;
public final Expr thenExpr;
public final Expr elseExpr;
public final int line;
public IfExpr(int line, Expr testExpr, Expr thenExpr, Expr elseExpr){
this.testExpr = testExpr;
this.thenExpr = thenExpr;
this.elseExpr = elseExpr;
this.line = line;
}
public Object eval() throws Exception{
Object t = testExpr.eval();
if(t != null && t != Boolean.FALSE)
9.24. COMPILER.JAVA 645
return thenExpr.eval();
return elseExpr.eval();
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
doEmit(context, objx, gen,false);
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
doEmit(context, objx, gen, true);
}
public void doEmit(C context,
ObjExpr objx,
GeneratorAdapter gen,
boolean emitUnboxed){
Label nullLabel = gen.newLabel();
Label falseLabel = gen.newLabel();
Label endLabel = gen.newLabel();
gen.visitLineNumber(line, gen.mark());
try
{
if(maybePrimitiveType(testExpr) == boolean.class)
{
((MaybePrimitiveExpr) testExpr)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.ifZCmp(gen.EQ, falseLabel);
}
else
{
testExpr.emit(C.EXPRESSION, objx, gen);
gen.dup();
gen.ifNull(nullLabel);
gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE",
BOOLEAN_OBJECT_TYPE);
gen.visitJumpInsn(IF_ACMPEQ, falseLabel);
}
}
catch(Exception e)
{
throw new RuntimeException(e);
}
if(emitUnboxed)
((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen);
else
thenExpr.emit(context, objx, gen);
646 CHAPTER 9. JVM/CLOJURE/LANG/
gen.goTo(endLabel);
gen.mark(nullLabel);
gen.pop();
gen.mark(falseLabel);
if(emitUnboxed)
((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen);
else
elseExpr.emit(context, objx, gen);
gen.mark(endLabel);
}
public boolean hasJavaClass() throws Exception{
return thenExpr.hasJavaClass()
&& elseExpr.hasJavaClass()
&&
(thenExpr.getJavaClass() == elseExpr.getJavaClass()
|| (thenExpr.getJavaClass() == null
&& !elseExpr.getJavaClass().isPrimitive())
|| (elseExpr.getJavaClass() == null
&& !thenExpr.getJavaClass().isPrimitive()));
}
public boolean canEmitPrimitive(){
try
{
return thenExpr instanceof MaybePrimitiveExpr
&& elseExpr instanceof MaybePrimitiveExpr
&& thenExpr.getJavaClass() == elseExpr.getJavaClass()
&& ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
&& ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive() ;
}
catch(Exception e)
{
return false;
}
}
public Class getJavaClass() throws Exception{
Class thenClass = thenExpr.getJavaClass();
if(thenClass != null)
return thenClass;
return elseExpr.getJavaClass();
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
//(if test then) or (if test then else)
if(form.count() > 4)
throw new Exception("Too many arguments to if");
9.24. COMPILER.JAVA 647
else if(form.count() < 3)
throw new Exception("Too few arguments to if");
PathNode branch =
new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.ge t());
Expr testexpr =
analyze(context == C.EVAL
? context
: C.EXPRESSION, RT.second(form));
Expr thenexpr, elseexpr;
try {
Var.pushThreadBindings(
RT.map(CLEAR_PATH,
new PathNode(PATHTYPE.PATH,branch)));
thenexpr = analyze(context, RT.third(form));
}
finally{
Var.popThreadBindings();
}
try {
Var.pushThreadBindings(
RT.map(CLEAR_PATH,
new PathNode(PATHTYPE.PATH,branch)));
elseexpr = analyze(context, RT.fourth(form));
}
finally{
Var.popThreadBindings();
}
return new IfExpr((Integer) LINE.deref(),
testexpr,
thenexpr,
elseexpr);
}
}
}
static final public IPersistentMap CHAR_MAP =
PersistentHashMap.create(’-’, "_",
// ’.’, "_DOT_",
’:’, "_COLON_",
’+’, "_PLUS_",
’>’, "_GT_",
’<’, "_LT_",
’=’, "_EQ_",
’~’, "_TILDE_",
’!’, "_BANG_",
’@’, "_CIRCA_",
’#’, "_SHARP_",
’$’, "_DOLLARSIGN_",
’%’, "_PERCENT_",
’^’, "_CARET_",
648 CHAPTER 9. JVM/CLOJURE/LANG/
’&’, "_AMPERSAND_",
’*’, "_STAR_",
’|’, "_BAR_",
’{’, "_LBRACE_",
’}’, "_RBRACE_",
’[’, "_LBRACK_",
’]’, "_RBRACK_",
’/’, "_SLASH_",
’\\’, "_BSLASH_",
’?’, "_QMARK_");
static public String munge(String name){
StringBuilder sb = new StringBuilder();
for(char c : name.toCharArray())
{
String sub = (String) CHAR_MAP.valAt(c);
if(sub != null)
sb.append(sub);
else
sb.append(c);
}
return sb.toString();
}
public static class EmptyExpr implements Expr{
public final Object coll;
final static Type HASHMAP_TYPE =
Type.getType(PersistentArrayMap.class);
final static Type HASHSET_TYPE =
Type.getType(PersistentHashSet.class);
final static Type VECTOR_TYPE =
Type.getType(PersistentVector.class);
final static Type LIST_TYPE =
Type.getType(PersistentList.class);
final static Type EMPTY_LIST_TYPE =
Type.getType(PersistentList.EmptyList.class);
public EmptyExpr(Object coll){
this.coll = coll;
}
public Object eval() throws Exception{
return coll;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
if(coll instanceof IPersistentList)
gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE);
else if(coll instanceof IPersistentVector)
9.24. COMPILER.JAVA 649
gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE);
else if(coll instanceof IPersistentMap)
gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE);
else if(coll instanceof IPersistentSet)
gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE);
else
throw new UnsupportedOperationException(
"Unknown Collection type");
if(context == C.STATEMENT)
{
gen.pop();
}
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
if(coll instanceof IPersistentList)
return IPersistentList.class;
else if(coll instanceof IPersistentVector)
return IPersistentVector.class;
else if(coll instanceof IPersistentMap)
return IPersistentMap.class;
else if(coll instanceof IPersistentSet)
return IPersistentSet.class;
else
throw new UnsupportedOperationException(
"Unknown Collection type");
}
}
public static class ListExpr implements Expr{
public final IPersistentVector args;
final static Method arrayToListMethod =
Method.getMethod("clojure.lang.ISeq arrayToList(Obje ct[])");
public ListExpr(IPersistentVector args){
this.args = args;
}
public Object eval() throws Exception{
IPersistentVector ret = PersistentVector.EMPTY;
for(int i = 0; i < args.count(); i++)
ret =
(IPersistentVector) ret.cons(((Expr) args.nth(i)).eva l());
return ret.seq();
}
650 CHAPTER 9. JVM/CLOJURE/LANG/
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
MethodExpr.emitArgsAsArray(args, objx, gen);
gen.invokeStatic(RT_TYPE, arrayToListMethod);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return IPersistentList.class;
}
}
public static class MapExpr implements Expr{
public final IPersistentVector keyvals;
final static Method mapMethod =
Method.getMethod("clojure.lang.IPersistentMap map(Ob ject[])");
public MapExpr(IPersistentVector keyvals){
this.keyvals = keyvals;
}
public Object eval() throws Exception{
Object[] ret = new Object[keyvals.count()];
for(int i = 0; i < keyvals.count(); i++)
ret[i] = ((Expr) keyvals.nth(i)).eval();
return RT.map(ret);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
MethodExpr.emitArgsAsArray(keyvals, objx, gen);
gen.invokeStatic(RT_TYPE, mapMethod);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return IPersistentMap.class;
}
9.24. COMPILER.JAVA 651
static public Expr parse(C context, IPersistentMap form)
throws Exception{
IPersistentVector keyvals = PersistentVector.EMPTY;
boolean constant = true;
for(ISeq s = RT.seq(form); s != null; s = s.next())
{
IMapEntry e = (IMapEntry) s.first();
Expr k =
analyze(context == C.EVAL
? context
: C.EXPRESSION, e.key());
Expr v =
analyze(context == C.EVAL
? context
: C.EXPRESSION, e.val());
keyvals = (IPersistentVector) keyvals.cons(k);
keyvals = (IPersistentVector) keyvals.cons(v);
if(!(k instanceof LiteralExpr && v instanceof LiteralExpr ))
constant = false;
}
Expr ret = new MapExpr(keyvals);
if(form instanceof IObj && ((IObj) form).meta() != null)
return new MetaExpr(ret, MapExpr
.parse(context == C.EVAL
? context
: C.EXPRESSION, ((IObj) form).meta()));
else if(constant)
{
IPersistentMap m = PersistentHashMap.EMPTY;
for(int i=0;i<keyvals.length();i+= 2)
{
m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(),
((LiteralExpr)keyvals.nth(i+1)).val());
}
// System.err.println("Constant: " + m);
return new ConstantExpr(m);
}
else
return ret;
}
}
public static class SetExpr implements Expr{
public final IPersistentVector keys;
final static Method setMethod =
Method.getMethod("clojure.lang.IPersistentSet set(Ob ject[])");
652 CHAPTER 9. JVM/CLOJURE/LANG/
public SetExpr(IPersistentVector keys){
this.keys = keys;
}
public Object eval() throws Exception{
Object[] ret = new Object[keys.count()];
for(int i = 0; i < keys.count(); i++)
ret[i] = ((Expr) keys.nth(i)).eval();
return RT.set(ret);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
MethodExpr.emitArgsAsArray(keys, objx, gen);
gen.invokeStatic(RT_TYPE, setMethod);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return IPersistentSet.class;
}
static public Expr parse(C context, IPersistentSet form)
throws Exception{
IPersistentVector keys = PersistentVector.EMPTY;
boolean constant = true;
for(ISeq s = RT.seq(form); s != null; s = s.next())
{
Object e = s.first();
Expr expr = analyze(context == C.EVAL
? context
: C.EXPRESSION, e);
keys = (IPersistentVector) keys.cons(expr);
if(!(expr instanceof LiteralExpr))
constant = false;
}
Expr ret = new SetExpr(keys);
if(form instanceof IObj && ((IObj) form).meta() != null)
return new MetaExpr(ret, MapExpr
.parse(context == C.EVAL
? context
: C.EXPRESSION, ((IObj) form).meta()));
else if(constant)
{
9.24. COMPILER.JAVA 653
IPersistentSet set = PersistentHashSet.EMPTY;
for(int i=0;i<keys.count();i++)
{
LiteralExpr ve = (LiteralExpr)keys.nth(i);
set = (IPersistentSet)set.cons(ve.val());
}
// System.err.println("Constant: " + set);
return new ConstantExpr(set);
}
else
return ret;
}
}
public static class VectorExpr implements Expr{
public final IPersistentVector args;
final static Method vectorMethod =
Method.getMethod(
"clojure.lang.IPersistentVector vector(Object[])");
public VectorExpr(IPersistentVector args){
this.args = args;
}
public Object eval() throws Exception{
IPersistentVector ret = PersistentVector.EMPTY;
for(int i = 0; i < args.count(); i++)
ret =
(IPersistentVector) ret.cons(((Expr) args.nth(i)).eva l());
return ret;
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
MethodExpr.emitArgsAsArray(args, objx, gen);
gen.invokeStatic(RT_TYPE, vectorMethod);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return IPersistentVector.class;
}
static public Expr parse(C context, IPersistentVector for m)
throws Exception{
654 CHAPTER 9. JVM/CLOJURE/LANG/
boolean constant = true;
IPersistentVector args = PersistentVector.EMPTY;
for(int i = 0; i < form.count(); i++)
{
Expr v = analyze(context == C.EVAL
? context
: C.EXPRESSION, form.nth(i));
args = (IPersistentVector) args.cons(v);
if(!(v instanceof LiteralExpr))
constant = false;
}
Expr ret = new VectorExpr(args);
if(form instanceof IObj && ((IObj) form).meta() != null)
return new MetaExpr(ret, MapExpr
.parse(context == C.EVAL
? context
: C.EXPRESSION, ((IObj) form).meta()));
else if (constant)
{
PersistentVector rv = PersistentVector.EMPTY;
for(int i =0;i<args.count();i++)
{
LiteralExpr ve = (LiteralExpr)args.nth(i);
rv = rv.cons(ve.val());
}
// System.err.println("Constant: " + rv);
return new ConstantExpr(rv);
}
else
return ret;
}
}
static class KeywordInvokeExpr implements Expr{
public final KeywordExpr kw;
public final Object tag;
public final Expr target;
public final int line;
public final int siteIndex;
public final String source;
static Type ILOOKUP_TYPE = Type.getType(ILookup.class);
public KeywordInvokeExpr(String source, int line, Symbol tag,
KeywordExpr kw, Expr target){
this.source = source;
this.kw = kw;
this.target = target;
this.line = line;
9.24. COMPILER.JAVA 655
this.tag = tag;
this.siteIndex = registerKeywordCallsite(kw.k);
}
public Object eval() throws Exception{
try
{
return kw.k.invoke(target.eval());
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(source, line, e);
else
throw (CompilerException) e;
}
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
Label endLabel = gen.newLabel();
Label faultLabel = gen.newLabel();
gen.visitLineNumber(line, gen.mark());
gen.getStatic(objx.objtype,
objx.thunkNameStatic(siteIndex),
ObjExpr.ILOOKUP_THUNK_TYPE);
gen.dup(); //thunk, thunk
target.emit(C.EXPRESSION, objx, gen); //thunk,thunk,ta rget
gen.dupX2(); //target,thunk,thunk,target
gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE,
Method.getMethod("Object get(Object)"));
//target,thunk,result
gen.dupX2(); //result,target,thunk,result
gen.visitJumpInsn(IF_ACMPEQ, faultLabel); //result,ta rget
gen.pop(); //result
gen.goTo(endLabel);
gen.mark(faultLabel); //result,target
gen.swap(); //target,result
gen.pop(); //target
gen.dup(); //target,target
gen.getStatic(objx.objtype,
objx.siteNameStatic(siteIndex),
ObjExpr.KEYWORD_LOOKUPSITE_TYPE);
//target,target,site
gen.swap(); //target,site,target
gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE,
Method.getMethod("clojure.lang.ILookupThunk fault(Ob ject)"));
//target,new-thunk
gen.dup(); //target,new-thunk,new-thunk
656 CHAPTER 9. JVM/CLOJURE/LANG/
gen.putStatic(objx.objtype,
objx.thunkNameStatic(siteIndex),
ObjExpr.ILOOKUP_THUNK_TYPE); //target,new-thunk
gen.swap(); //new-thunk,target
gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE,
Method.getMethod("Object get(Object)"));
//result
gen.mark(endLabel);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return tag != null;
}
public Class getJavaClass() throws Exception{
return HostExpr.tagToClass(tag);
}
}
//static class KeywordSiteInvokeExpr implements Expr{
// public final Expr site;
// public final Object tag;
// public final Expr target;
// public final int line;
// public final String source;
//
// public KeywordSiteInvokeExpr(String source, int line,
// Symbol tag, Expr site, Expr target){
// this.source = source;
// this.site = site;
// this.target = target;
// this.line = line;
// this.tag = tag;
// }
//
// public Object eval() throws Exception{
// try
// {
// KeywordCallSite s = (KeywordCallSite) site.eval();
// return s.thunk.invoke(s,target.eval());
// }
// catch(Throwable e)
// {
// if(!(e instanceof CompilerException))
// throw new CompilerException(source, line, e);
// else
// throw (CompilerException) e;
9.24. COMPILER.JAVA 657
// }
// }
//
// public void emit(C context, ObjExpr objx, GeneratorAdap ter gen){
// gen.visitLineNumber(line, gen.mark());
// site.emit(C.EXPRESSION, objx, gen);
// gen.dup();
// gen.getField(Type.getType(KeywordCallSite.class),
// "thunk",IFN_TYPE);
// gen.swap();
// target.emit(C.EXPRESSION, objx, gen);
//
// gen.invokeInterface(IFN_TYPE,
// new Method("invoke", OBJECT_TYPE, ARG_TYPES[2]));
// if(context == C.STATEMENT)
// gen.pop();
// }
//
// public boolean hasJavaClass() throws Exception{
// return tag != null;
// }
//
// public Class getJavaClass() throws Exception{
// return HostExpr.tagToClass(tag);
// }
//
//}
public static class InstanceOfExpr
implements Expr, MaybePrimitiveExpr{
Expr expr;
Class c;
public InstanceOfExpr(Class c, Expr expr){
this.expr = expr;
this.c = c;
}
public Object eval() throws Exception{
if(c.isInstance(expr.eval()))
return RT.T;
return RT.F;
}
public boolean canEmitPrimitive(){
return true;
}
public void emitUnboxed(C context,
ObjExpr objx,
658 CHAPTER 9. JVM/CLOJURE/LANG/
GeneratorAdapter gen){
expr.emit(C.EXPRESSION, objx, gen);
gen.instanceOf(getType(c));
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
emitUnboxed(context,objx,gen);
HostExpr.emitBoxReturn(objx,gen,Boolean.TYPE);
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return Boolean.TYPE;
}
}
static class StaticInvokeExpr implements Expr, MaybePrim itiveExpr{
public final Type target;
public final Class retClass;
public final Class[] paramclasses;
public final Type[] paramtypes;
public final IPersistentVector args;
public final boolean variadic;
public final Symbol tag;
StaticInvokeExpr(Type target,
Class retClass,
Class[] paramclasses,
Type[] paramtypes,
boolean variadic,
IPersistentVector args,Symbol tag){
this.target = target;
this.retClass = retClass;
this.paramclasses = paramclasses;
this.paramtypes = paramtypes;
this.args = args;
this.variadic = variadic;
this.tag = tag;
}
public Object eval() throws Exception{
throw new UnsupportedOperationException(
"Can’t eval StaticInvokeExpr");
}
9.24. COMPILER.JAVA 659
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
emitUnboxed(context, objx, gen);
if(context != C.STATEMENT)
HostExpr.emitBoxReturn(objx,gen,retClass);
if(context == C.STATEMENT)
{
if(retClass == long.class || retClass == double.class)
gen.pop2();
else
gen.pop();
}
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return tag != null ? HostExpr.tagToClass(tag) : retClass;
}
public boolean canEmitPrimitive(){
return retClass.isPrimitive();
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
Method ms =
new Method("invokeStatic", getReturnType(), paramtypes );
if(variadic)
{
for(int i = 0; i < paramclasses.length - 1; i++)
{
Expr e = (Expr) args.nth(i);
try
{
if(maybePrimitiveType(e) == paramclasses[i])
{
((MaybePrimitiveExpr) e)
.emitUnboxed(C.EXPRESSION, objx, gen);
}
else
{
e.emit(C.EXPRESSION, objx, gen);
HostExpr.emitUnboxArg(objx, gen,
paramclasses[i]);
}
}
660 CHAPTER 9. JVM/CLOJURE/LANG/
catch(Exception ex)
{
throw new RuntimeException(ex);
}
}
IPersistentVector restArgs =
RT.subvec(args,paramclasses.length - 1,args.count());
MethodExpr.emitArgsAsArray(restArgs,objx,gen);
gen.invokeStatic(Type.getType(ArraySeq.class),
Method.getMethod(
"clojure.lang.ArraySeq create(Object[])"));
}
else
MethodExpr.emitTypedArgs(objx, gen, paramclasses, args );
gen.invokeStatic(target, ms);
}
private Type getReturnType(){
return Type.getType(retClass);
}
public static Expr parse(Var v, ISeq args, Symbol tag)
throws Exception{
IPersistentCollection paramlists =
(IPersistentCollection) RT.get(v.meta(), arglistsKey) ;
if(paramlists == null)
throw new IllegalStateException(
"Can’t call static fn with no arglists: " + v);
IPersistentVector paramlist = null;
int argcount = RT.count(args);
boolean variadic = false;
for(ISeq aseq =
RT.seq(paramlists); aseq != null; aseq = aseq.next())
{
if(!(aseq.first() instanceof IPersistentVector))
throw new IllegalStateException(
"Expected vector arglist, had: " + aseq.first());
IPersistentVector alist = (IPersistentVector) aseq.firs t();
if(alist.count() > 1
&& alist.nth(alist.count() - 2).equals(_AMP_))
{
if(argcount >= alist.count() - 2)
{
paramlist = alist;
variadic = true;
}
}
else if(alist.count() == argcount)
{
9.24. COMPILER.JAVA 661
paramlist = alist;
variadic = false;
break;
}
}
if(paramlist == null)
throw new IllegalArgumentException(
"Invalid arity - can’t call: " + v + " with " +
argcount + " args");
Class retClass = tagClass(tagOf(paramlist));
ArrayList<Class> paramClasses = new ArrayList();
ArrayList<Type> paramTypes = new ArrayList();
if(variadic)
{
for(int i = 0; i < paramlist.count()-2;i++)
{
Class pc = tagClass(tagOf(paramlist.nth(i)));
paramClasses.add(pc);
paramTypes.add(Type.getType(pc));
}
paramClasses.add(ISeq.class);
paramTypes.add(Type.getType(ISeq.class));
}
else
{
for(int i = 0; i < argcount;i++)
{
Class pc = tagClass(tagOf(paramlist.nth(i)));
paramClasses.add(pc);
paramTypes.add(Type.getType(pc));
}
}
String cname =
v.ns.name.name.replace(’.’, ’/’).replace(’-’,’_’) +
"$" + munge(v.sym.name);
Type target = Type.getObjectType(cname);
PersistentVector argv = PersistentVector.EMPTY;
for(ISeq s = RT.seq(args); s != null; s = s.next())
argv = argv.cons(analyze(C.EXPRESSION, s.first()));
return
new StaticInvokeExpr(target,
retClass,
paramClasses
662 CHAPTER 9. JVM/CLOJURE/LANG/
.toArray(new Class[paramClasses.size()]),
paramTypes
.toArray(new Type[paramTypes.size()]),
variadic, argv, tag);
}
}
static class InvokeExpr implements Expr{
public final Expr fexpr;
public final Object tag;
public final IPersistentVector args;
public final int line;
public final String source;
public boolean isProtocol = false;
public boolean isDirect = false;
public int siteIndex = -1;
public Class protocolOn;
public java.lang.reflect.Method onMethod;
static Keyword onKey = Keyword.intern("on");
static Keyword methodMapKey = Keyword.intern("method-ma p");
public InvokeExpr(String source,
int line,
Symbol tag,
Expr fexpr,
IPersistentVector args) throws Exception{
this.source = source;
this.fexpr = fexpr;
this.args = args;
this.line = line;
if(fexpr instanceof VarExpr)
{
Var fvar = ((VarExpr)fexpr).var;
Var pvar = (Var)RT.get(fvar.meta(), protocolKey);
if(pvar != null && PROTOCOL_CALLSITES.isBound())
{
this.isProtocol = true;
this.siteIndex =
registerProtocolCallsite(((VarExpr)fexpr).var);
Object pon = RT.get(pvar.get(), onKey);
this.protocolOn = HostExpr.maybeClass(pon,false);
if(this.protocolOn != null)
{
IPersistentMap mmap =
(IPersistentMap) RT.get(pvar.get(), methodMapKey);
Keyword mmapVal =
(Keyword) mmap.valAt(Keyword.intern(fvar.sym));
if (mmapVal == null) {
throw new IllegalArgumentException(
"No method of interface: " +
9.24. COMPILER.JAVA 663
protocolOn.getName() +
" found for function: " +
fvar.sym + " of protocol: " +
pvar.sym +
" (The protocol method may have been defined before and remov ed.)");
}
String mname = munge(mmapVal.sym.toString());
List methods =
Reflector.getMethods(protocolOn, args.count() - 1,
mname, false);
if(methods.size() != 1)
throw new IllegalArgumentException(
"No single method: " + mname +
" of interface: " +
protocolOn.getName() +
" found for function: " + fvar.sym +
" of protocol: " + pvar.sym);
this.onMethod =
(java.lang.reflect.Method) methods.get(0);
}
}
}
this.tag = tag != null
? tag
: (fexpr instanceof VarExpr
? ((VarExpr) fexpr).tag
: null);
}
public Object eval() throws Exception{
try
{
IFn fn = (IFn) fexpr.eval();
PersistentVector argvs = PersistentVector.EMPTY;
for(int i = 0; i < args.count(); i++)
argvs = argvs.cons(((Expr) args.nth(i)).eval());
return fn.applyTo(RT.seq(argvs));
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(source, line, e);
else
throw (CompilerException) e;
}
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
gen.visitLineNumber(line, gen.mark());
if(isProtocol)
664 CHAPTER 9. JVM/CLOJURE/LANG/
{
emitProto(context,objx,gen);
}
else
{
fexpr.emit(C.EXPRESSION, objx, gen);
gen.checkCast(IFN_TYPE);
emitArgsAndCall(0, context,objx,gen);
}
if(context == C.STATEMENT)
gen.pop();
}
public void emitProto(C context, ObjExpr objx, GeneratorA dapter gen){
Label onLabel = gen.newLabel();
Label callLabel = gen.newLabel();
Label endLabel = gen.newLabel();
Var v = ((VarExpr)fexpr).var;
Expr e = (Expr) args.nth(0);
e.emit(C.EXPRESSION, objx, gen);
gen.dup(); //target, target
gen.invokeStatic(UTIL_TYPE,
Method.getMethod("Class classOf(Object)"));
//target,class
gen.loadThis();
gen.getField(objx.objtype,
objx.cachedClassName(siteIndex),
CLASS_TYPE); //target,class,cached-class
gen.visitJumpInsn(IF_ACMPEQ, callLabel); //target
if(protocolOn != null)
{
gen.dup(); //target, target
gen.instanceOf(Type.getType(protocolOn));
gen.ifZCmp(GeneratorAdapter.NE, onLabel);
}
gen.dup(); //target, target
gen.invokeStatic(UTIL_TYPE,
Method.getMethod("Class classOf(Object)"));
//target,class
gen.loadThis();
gen.swap();
gen.putField(objx.objtype,
objx.cachedClassName(siteIndex),
CLASS_TYPE); //target
gen.mark(callLabel); //target
9.24. COMPILER.JAVA 665
objx.emitVar(gen, v);
gen.invokeVirtual(VAR_TYPE,
Method.getMethod("Object getRawRoot()"));
//target, proto-fn
gen.swap();
emitArgsAndCall(1, context,objx,gen);
gen.goTo(endLabel);
gen.mark(onLabel); //target
if(protocolOn != null)
{
MethodExpr.emitTypedArgs(objx, gen,
onMethod.getParameterTypes(),
RT.subvec(args,1,args.count()));
if(context == C.RETURN)
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
Method m = new Method(onMethod.getName(),
Type.getReturnType(onMethod),
Type.getArgumentTypes(onMethod));
gen.invokeInterface(Type.getType(protocolOn), m);
HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnT ype());
}
gen.mark(endLabel);
}
void emitArgsAndCall(int firstArgToEmit,
C context,
ObjExpr objx,
GeneratorAdapter gen){
for(int i = firstArgToEmit;
i < Math.min(MAX_POSITIONAL_ARITY, args.count());
i++)
{
Expr e = (Expr) args.nth(i);
e.emit(C.EXPRESSION, objx, gen);
}
if(args.count() > MAX_POSITIONAL_ARITY)
{
PersistentVector restArgs = PersistentVector.EMPTY;
for(int i = MAX_POSITIONAL_ARITY; i < args.count(); i++)
{
restArgs = restArgs.cons(args.nth(i));
}
MethodExpr.emitArgsAsArray(restArgs, objx, gen);
}
if(context == C.RETURN)
666 CHAPTER 9. JVM/CLOJURE/LANG/
{
ObjMethod method = (ObjMethod) METHOD.deref();
method.emitClearLocals(gen);
}
gen.invokeInterface(
IFN_TYPE,
new Method("invoke",
OBJECT_TYPE,
ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1,
args.count())]));
}
public boolean hasJavaClass() throws Exception{
return tag != null;
}
public Class getJavaClass() throws Exception{
return HostExpr.tagToClass(tag);
}
static public Expr parse(C context, ISeq form) throws Excep tion{
if(context != C.EVAL)
context = C.EXPRESSION;
Expr fexpr = analyze(context, form.first());
if(fexpr instanceof VarExpr &&
((VarExpr)fexpr).var.equals(INSTANCE))
{
if(RT.second(form) instanceof Symbol)
{
Class c = HostExpr.maybeClass(RT.second(form),false);
if(c != null)
return
new InstanceOfExpr(c,
analyze(context, RT.third(form)));
}
}
// if(fexpr instanceof VarExpr && context != C.EVAL)
// {
// Var v = ((VarExpr)fexpr).var;
// if(RT.booleanCast(RT.get(RT.meta(v),staticKey)))
// {
// return StaticInvokeExpr.parse(v, RT.next(form),
// tagOf(form));
// }
// }
if(fexpr instanceof VarExpr && context != C.EVAL)
{
9.24. COMPILER.JAVA 667
Var v = ((VarExpr)fexpr).var;
Object arglists = RT.get(RT.meta(v), arglistsKey);
int arity = RT.count(form.next());
for(ISeq s = RT.seq(arglists); s != null; s = s.next())
{
IPersistentVector args = (IPersistentVector) s.first();
if(args.count() == arity)
{
String primc = FnMethod.primInterface(args);
if(primc != null)
return
analyze(context,
RT.listStar(Symbol.intern(".invokePrim"),
((Symbol) form.first())
.withMeta(
RT.map(
RT.TAG_KEY, Symbol.intern(primc))),
form.next()));
break;
}
}
}
if(fexpr instanceof KeywordExpr &&
RT.count(form) == 2 &&
KEYWORD_CALLSITES.isBound())
{
// fexpr =
// new ConstantExpr(
// new KeywordCallSite(((KeywordExpr)fexpr).k));
Expr target = analyze(context, RT.second(form));
return
new KeywordInvokeExpr((String) SOURCE.deref(),
(Integer) LINE.deref(), tagOf(form),
(KeywordExpr) fexpr, target);
}
PersistentVector args = PersistentVector.EMPTY;
for(ISeq s = RT.seq(form.next()); s != null; s = s.next())
{
args = args.cons(analyze(context, s.first()));
}
// if(args.count() > MAX_POSITIONAL_ARITY)
// throw new IllegalArgumentException(
// String.format(
// "No more than %d args supported", MAX_POSITIONAL_ARITY) );
return new InvokeExpr((String) SOURCE.deref(),
(Integer) LINE.deref(),
tagOf(form),
fexpr,
668 CHAPTER 9. JVM/CLOJURE/LANG/
args);
}
}
static class SourceDebugExtensionAttribute extends Attr ibute{
public SourceDebugExtensionAttribute(){
super("SourceDebugExtension");
}
void writeSMAP(ClassWriter cw, String smap){
ByteVector bv = write(cw, null, -1, -1, -1);
bv.putUTF8(smap);
}
}
static public class FnExpr extends ObjExpr{
final static Type aFnType = Type.getType(AFunction.class );
final static Type restFnType = Type.getType(RestFn.class );
//if there is a variadic overload (there can only be one)
// it is stored here
FnMethod variadicMethod = null;
IPersistentCollection methods;
// String superName = null;
public FnExpr(Object tag){
super(tag);
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return AFunction.class;
}
protected void emitMethods(ClassVisitor cv){
//override of invoke/doInvoke for each method
for(ISeq s = RT.seq(methods); s != null; s = s.next())
{
ObjMethod method = (ObjMethod) s.first();
method.emit(this, cv);
}
if(isVariadic())
{
GeneratorAdapter gen =
new GeneratorAdapter(
ACC_PUBLIC,
Method.getMethod("int getRequiredArity()"),
9.24. COMPILER.JAVA 669
null,
null,
cv);
gen.visitCode();
gen.push(variadicMethod.reqParms.count());
gen.returnValue();
gen.endMethod();
}
}
static Expr parse(C context, ISeq form, String name)
throws Exception{
ISeq origForm = form;
FnExpr fn = new FnExpr(tagOf(form));
fn.src = form;
ObjMethod enclosingMethod = (ObjMethod) METHOD.deref();
if(((IMeta) form.first()).meta() != null)
{
fn.onceOnly =
RT.booleanCast(RT.get(RT.meta(form.first()),
Keyword.intern(null, "once")));
// fn.superName = (String) RT.get(RT.meta(form.first()) ,
// Keyword.intern(null,
// "super-name"));
}
//fn.thisName = name;
String basename = enclosingMethod != null ?
(enclosingMethod.objx.name + "$")
: //"clojure.fns." +
(munge(currentNS().name.name) + "$");
if(RT.second(form) instanceof Symbol)
name = ((Symbol) RT.second(form)).name;
String simpleName = name != null ?
(munge(name).replace(".", "_DOT_")
+ (enclosingMethod != null
? "__" + RT.nextID()
: ""))
: ("fn"
+ "__" + RT.nextID());
fn.name = basename + simpleName;
fn.internalName = fn.name.replace(’.’, ’/’);
fn.objtype = Type.getObjectType(fn.internalName);
ArrayList<String> prims = new ArrayList();
try
{
Var.pushThreadBindings(
RT.map(CONSTANTS, PersistentVector.EMPTY,
CONSTANT_IDS, new IdentityHashMap(),
KEYWORDS, PersistentHashMap.EMPTY,
VARS, PersistentHashMap.EMPTY,
670 CHAPTER 9. JVM/CLOJURE/LANG/
KEYWORD_CALLSITES, PersistentVector.EMPTY,
PROTOCOL_CALLSITES, PersistentVector.EMPTY,
VAR_CALLSITES, emptyVarCallSites(),
NO_RECUR, null
));
//arglist might be preceded by symbol naming this fn
if(RT.second(form) instanceof Symbol)
{
Symbol nm = (Symbol) RT.second(form);
fn.thisName = nm.name;
//RT.booleanCast(RT.get(nm.meta(), staticKey));
fn.isStatic = false;
form = RT.cons(FN, RT.next(RT.next(form)));
}
//now (fn [args] body...) or
// (fn ([args] body...) ([args2] body2...) ...)
//turn former into latter
if(RT.second(form) instanceof IPersistentVector)
form = RT.list(FN, RT.next(form));
fn.line = (Integer) LINE.deref();
FnMethod[] methodArray =
new FnMethod[MAX_POSITIONAL_ARITY + 1];
FnMethod variadicMethod = null;
for(ISeq s = RT.next(form); s != null; s = RT.next(s))
{
FnMethod f =
FnMethod.parse(fn, (ISeq) RT.first(s), fn.isStatic);
if(f.isVariadic())
{
if(variadicMethod == null)
variadicMethod = f;
else
throw new Exception(
"Can’t have more than 1 variadic overload");
}
else if(methodArray[f.reqParms.count()] == null)
methodArray[f.reqParms.count()] = f;
else
throw new Exception(
"Can’t have 2 overloads with same arity");
if(f.prim != null)
prims.add(f.prim);
}
if(variadicMethod != null)
{
for(int i = variadicMethod.reqParms.count() + 1;
i <= MAX_POSITIONAL_ARITY;
i++)
9.24. COMPILER.JAVA 671
if(methodArray[i] != null)
throw new Exception(
"Can’t have fixed arity function with more params "+
"than variadic function");
}
if(fn.isStatic && fn.closes.count() > 0)
throw new IllegalArgumentException(
"static fns can’t be closures");
IPersistentCollection methods = null;
for(int i = 0; i < methodArray.length; i++)
if(methodArray[i] != null)
methods = RT.conj(methods, methodArray[i]);
if(variadicMethod != null)
methods = RT.conj(methods, variadicMethod);
fn.methods = methods;
fn.variadicMethod = variadicMethod;
fn.keywords = (IPersistentMap) KEYWORDS.deref();
fn.vars = (IPersistentMap) VARS.deref();
fn.constants = (PersistentVector) CONSTANTS.deref();
fn.keywordCallsites =
(IPersistentVector) KEYWORD_CALLSITES.deref();
fn.protocolCallsites =
(IPersistentVector) PROTOCOL_CALLSITES.deref();
fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref ();
fn.constantsID = RT.nextID();
// DynamicClassLoader loader =
// (DynamicClassLoader) LOADER.get();
// loader.registerConstants(fn.constantsID,
// fn.constants.toArray());
}
finally
{
Var.popThreadBindings();
}
fn.compile(fn.isVariadic()
? "clojure/lang/RestFn"
: "clojure/lang/AFunction",
(prims.size() == 0)?
null
:prims.toArray(new String[prims.size()]),
fn.onceOnly);
fn.getCompiledClass();
if(origForm instanceof IObj && ((IObj) origForm).meta() ! = null)
return new MetaExpr(fn, MapExpr
.parse(context == C.EVAL
? context
672 CHAPTER 9. JVM/CLOJURE/LANG/
: C.EXPRESSION, ((IObj) origForm).meta()));
else
return fn;
}
public final ObjMethod variadicMethod(){
return variadicMethod;
}
boolean isVariadic(){
return variadicMethod != null;
}
public final IPersistentCollection methods(){
return methods;
}
}
static public class ObjExpr implements Expr{
static final String CONST_PREFIX = "const__";
String name;
//String simpleName;
String internalName;
String thisName;
Type objtype;
public final Object tag;
//localbinding->itself
IPersistentMap closes = PersistentHashMap.EMPTY;
//localbndingexprs
IPersistentVector closesExprs = PersistentVector.EMPTY ;
//symbols
IPersistentSet volatiles = PersistentHashSet.EMPTY;
//symbol->lb
IPersistentMap fields = null;
//Keyword->KeywordExpr
IPersistentMap keywords = PersistentHashMap.EMPTY;
IPersistentMap vars = PersistentHashMap.EMPTY;
Class compiledClass;
int line;
PersistentVector constants;
int constantsID;
int altCtorDrops = 0;
IPersistentVector keywordCallsites;
IPersistentVector protocolCallsites;
IPersistentSet varCallsites;
boolean onceOnly = false;
9.24. COMPILER.JAVA 673
Object src;
final static Method voidctor = Method.getMethod("void <in it>()");
protected IPersistentMap classMeta;
protected boolean isStatic;
public final String name(){
return name;
}
// public final String simpleName(){
// return simpleName;
// }
public final String internalName(){
return internalName;
}
public final String thisName(){
return thisName;
}
public final Type objtype(){
return objtype;
}
public final IPersistentMap closes(){
return closes;
}
public final IPersistentMap keywords(){
return keywords;
}
public final IPersistentMap vars(){
return vars;
}
public final Class compiledClass(){
return compiledClass;
}
public final int line(){
return line;
}
public final PersistentVector constants(){
return constants;
}
674 CHAPTER 9. JVM/CLOJURE/LANG/
public final int constantsID(){
return constantsID;
}
final static Method kwintern =
Method.getMethod("clojure.lang.Keyword intern(String , String)");
final static Method symintern =
Method.getMethod("clojure.lang.Symbol intern(String) ");
final static Method varintern =
Method.getMethod(
"clojure.lang.Var intern(clojure.lang.Symbol, clojure .lang.Symbol)");
final static Type DYNAMIC_CLASSLOADER_TYPE =
Type.getType(DynamicClassLoader.class);
final static Method getClassMethod =
Method.getMethod("Class getClass()");
final static Method getClassLoaderMethod =
Method.getMethod("ClassLoader getClassLoader()");
final static Method getConstantsMethod =
Method.getMethod("Object[] getConstants(int)");
final static Method readStringMethod =
Method.getMethod("Object readString(String)");
final static Type ILOOKUP_SITE_TYPE =
Type.getType(ILookupSite.class);
final static Type ILOOKUP_THUNK_TYPE =
Type.getType(ILookupThunk.class);
final static Type KEYWORD_LOOKUPSITE_TYPE =
Type.getType(KeywordLookupSite.class);
private DynamicClassLoader loader;
private byte[] bytecode;
public ObjExpr(Object tag){
this.tag = tag;
}
static String trimGenID(String name){
int i = name.lastIndexOf("__");
return i==-1?name:name.substring(0,i);
}
Type[] ctorTypes(){
IPersistentVector tv =
isDeftype()
? PersistentVector.EMPTY
: RT.vector(IPERSISTENTMAP_TYPE);
for(ISeq s = RT.keys(closes); s != null; s = s.next())
9.24. COMPILER.JAVA 675
{
LocalBinding lb = (LocalBinding) s.first();
if(lb.getPrimitiveType() != null)
tv = tv.cons(Type.getType(lb.getPrimitiveType()));
else
tv = tv.cons(OBJECT_TYPE);
}
Type[] ret = new Type[tv.count()];
for(int i = 0; i < tv.count(); i++)
ret[i] = (Type) tv.nth(i);
return ret;
}
void compile(String superName,
String[] interfaceNames,
boolean oneTimeUse)
throws Exception{
//create bytecode for a class
//with name current_ns.defname[$letname]+
//anonymous fns get names fn__id
//derived from AFn/RestFn
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MA XS);
// ClassWriter cw = new ClassWriter(0);
ClassVisitor cv = cw;
// ClassVisitor cv =
// new TraceClassVisitor(new CheckClassAdapter(cw),
// new PrintWriter(System.out));
// ClassVisitor cv =
// new TraceClassVisitor(cw, new PrintWriter(System.out ));
cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL,
internalName, null,superName,interfaceNames);
// superName != null ? superName :
// (isVariadic()
// ? "clojure/lang/RestFn"
// : "clojure/lang/AFunction"), null);
String source = (String) SOURCE.deref();
int lineBefore = (Integer) LINE_BEFORE.deref();
int lineAfter = (Integer) LINE_AFTER.deref() + 1;
if(source != null && SOURCE_PATH.deref() != null)
{
//cv.visitSource(source, null);
String smap = "SMAP\n" +
((source.lastIndexOf(’.’) > 0) ?
source.substring(0, source.lastIndexOf(’.’))
:source)
// : simpleName)
+ ".java\n" +
"Clojure\n" +
"*S Clojure\n" +
676 CHAPTER 9. JVM/CLOJURE/LANG/
"*F\n" +
"+ 1 " + source + "\n" +
(String) SOURCE_PATH.deref() + "\n" +
"*L\n" +
String.format("%d#1,%d:%d\n", lineBefore,
lineAfter - lineBefore, lineBefore) +
"*E";
cv.visitSource(source, smap);
}
addAnnotation(cv, classMeta);
//static fields for constants
for(int i = 0; i < constants.count(); i++)
{
cv.visitField(ACC_PUBLIC + ACC_FINAL
+ ACC_STATIC,
constantName(i),
constantType(i).getDescriptor(),
null, null);
}
//static fields for lookup sites
for(int i = 0; i < keywordCallsites.count(); i++)
{
cv.visitField(ACC_FINAL
+ ACC_STATIC,
siteNameStatic(i),
KEYWORD_LOOKUPSITE_TYPE.getDescriptor(),
null, null);
cv.visitField(ACC_STATIC,
thunkNameStatic(i),
ILOOKUP_THUNK_TYPE.getDescriptor(),
null, null);
}
// for(int i=0;i<varCallsites.count();i++)
// {
// cv.visitField(ACC_PRIVATE + ACC_STATIC + ACC_FINAL
// , varCallsiteName(i),
// IFN_TYPE.getDescriptor(), null, null);
// }
//static init for constants, keywords and vars
GeneratorAdapter clinitgen =
new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
Method.getMethod("void <clinit> ()"),
null,
null,
cv);
clinitgen.visitCode();
clinitgen.visitLineNumber(line, clinitgen.mark());
9.24. COMPILER.JAVA 677
if(constants.count() > 0)
{
emitConstants(clinitgen);
}
if(keywordCallsites.count() > 0)
emitKeywordCallsites(clinitgen);
/*
for(int i=0;i<varCallsites.count();i++)
{
Label skipLabel = clinitgen.newLabel();
Label endLabel = clinitgen.newLabel();
Var var = (Var) varCallsites.nth(i);
clinitgen.push(var.ns.name.toString());
clinitgen.push(var.sym.toString());
clinitgen.invokeStatic(RT_TYPE,
Method.getMethod("clojure.lang.Var var(String,String )"));
clinitgen.dup();
clinitgen.invokeVirtual(VAR_TYPE,
Method.getMethod("boolean hasRoot()"));
clinitgen.ifZCmp(GeneratorAdapter.EQ,skipLabel);
clinitgen.invokeVirtual(VAR_TYPE,
Method.getMethod("Object getRoot()"));
clinitgen.dup();
clinitgen.instanceOf(AFUNCTION_TYPE);
clinitgen.ifZCmp(GeneratorAdapter.EQ,skipLabel);
clinitgen.checkCast(IFN_TYPE);
clinitgen.putStatic(objtype, varCallsiteName(i), IFN_ TYPE);
clinitgen.goTo(endLabel);
clinitgen.mark(skipLabel);
clinitgen.pop();
clinitgen.mark(endLabel);
}
*/
clinitgen.returnValue();
clinitgen.endMethod();
if(!isDeftype())
{
cv.visitField(ACC_FINAL, "__meta",
IPERSISTENTMAP_TYPE.getDescriptor(), null, null);
}
//instance fields for closed-overs
for(ISeq s = RT.keys(closes); s != null; s = s.next())
{
678 CHAPTER 9. JVM/CLOJURE/LANG/
LocalBinding lb = (LocalBinding) s.first();
if(isDeftype())
{
int access = isVolatile(lb) ? ACC_VOLATILE :
isMutable(lb) ? 0 :
(ACC_PUBLIC + ACC_FINAL);
FieldVisitor fv;
if(lb.getPrimitiveType() != null)
fv = cv.visitField(access,
lb.name,
Type.getType(lb.getPrimitiveType())
.getDescriptor(),
null, null);
else
//todo - when closed-overs are fields, use more
// specific types here and in ctor and emitLocal?
fv = cv.visitField(access,
lb.name,
OBJECT_TYPE.getDescriptor(), null, null);
addAnnotation(fv, RT.meta(lb.sym));
}
else
{
//todo - only enable this non-private+writability
// for letfns where we need it
if(lb.getPrimitiveType() != null)
cv.visitField(0 + (isVolatile(lb)
? ACC_VOLATILE
: 0),
lb.name,
Type.getType(lb.getPrimitiveType())
.getDescriptor(),
null, null);
else
cv.visitField(0 //+ (oneTimeUse ? 0 : ACC_FINAL)
, lb.name,
OBJECT_TYPE.getDescriptor(), null, null);
}
}
//instance fields for callsites and thunks
for(int i=0;i<protocolCallsites.count();i++)
{
cv.visitField(ACC_PRIVATE, cachedClassName(i),
CLASS_TYPE.getDescriptor(), null, null);
cv.visitField(ACC_PRIVATE, cachedProtoFnName(i),
AFUNCTION_TYPE.getDescriptor(), null, null);
cv.visitField(ACC_PRIVATE, cachedProtoImplName(i),
IFN_TYPE.getDescriptor(), null, null);
}
9.24. COMPILER.JAVA 679
//ctor that takes closed-overs and inits base + fields
Method m = new Method("<init>", Type.VOID_TYPE, ctorTypes ());
GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUB LIC,
m,
null,
null,
cv);
Label start = ctorgen.newLabel();
Label end = ctorgen.newLabel();
ctorgen.visitCode();
ctorgen.visitLineNumber(line, ctorgen.mark());
ctorgen.visitLabel(start);
ctorgen.loadThis();
// if(superName != null)
ctorgen.invokeConstructor(Type.getObjectType(superN ame),
voidctor);
// else if(isVariadic()) //RestFn ctor takes reqArity arg
// {
// ctorgen.push(variadicMethod.reqParms.count());
// ctorgen.invokeConstructor(restFnType, restfnctor);
// }
// else
// ctorgen.invokeConstructor(aFnType, voidctor);
// if(vars.count() > 0)
// {
// ctorgen.loadThis();
// ctorgen.getStatic(VAR_TYPE,"rev",Type.INT_TYPE);
// ctorgen.push(-1);
// ctorgen.visitInsn(Opcodes.IADD);
// ctorgen.putField(objtype, "__varrev__", Type.INT_TY PE);
// }
if(!isDeftype())
{
ctorgen.loadThis();
ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE
.getOpcode(Opcodes.ILOAD), 1);
ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TY PE);
}
int a = isDeftype()?1:2;
for(ISeq s = RT.keys(closes); s != null; s = s.next(), ++a)
{
LocalBinding lb = (LocalBinding) s.first();
ctorgen.loadThis();
Class primc = lb.getPrimitiveType();
if(primc != null)
{
680 CHAPTER 9. JVM/CLOJURE/LANG/
ctorgen.visitVarInsn(
Type.getType(primc).getOpcode(Opcodes.ILOAD), a);
ctorgen.putField(objtype, lb.name, Type.getType(primc ));
if(primc == Long.TYPE || primc == Double.TYPE)
++a;
}
else
{
ctorgen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a);
ctorgen.putField(objtype, lb.name, OBJECT_TYPE);
}
closesExprs =
closesExprs.cons(new LocalBindingExpr(lb, null));
}
ctorgen.visitLabel(end);
ctorgen.returnValue();
ctorgen.endMethod();
if(altCtorDrops > 0)
{
//ctor that takes closed-overs and inits base + fields
Type[] ctorTypes = ctorTypes();
Type[] altCtorTypes =
new Type[ctorTypes.length-altCtorDrops];
for(int i=0;i<altCtorTypes.length;i++)
altCtorTypes[i] = ctorTypes[i];
Method alt =
new Method("<init>", Type.VOID_TYPE, altCtorTypes);
ctorgen = new GeneratorAdapter(ACC_PUBLIC,
alt,
null,
null,
cv);
ctorgen.visitCode();
ctorgen.loadThis();
ctorgen.loadArgs();
for(int i=0;i<altCtorDrops;i++)
ctorgen.visitInsn(Opcodes.ACONST_NULL);
ctorgen.invokeConstructor(objtype,
new Method("<init>",
Type.VOID_TYPE, ctorTypes));
ctorgen.returnValue();
ctorgen.endMethod();
9.24. COMPILER.JAVA 681
}
if(!isDeftype())
{
//ctor that takes closed-overs but not meta
Type[] ctorTypes = ctorTypes();
Type[] noMetaCtorTypes = new Type[ctorTypes.length-1];
for(int i=1;i<ctorTypes.length;i++)
noMetaCtorTypes[i-1] = ctorTypes[i];
Method alt = new Method("<init>",
Type.VOID_TYPE,
noMetaCtorTypes);
ctorgen = new GeneratorAdapter(ACC_PUBLIC,
alt,
null,
null,
cv);
ctorgen.visitCode();
ctorgen.loadThis();
ctorgen.visitInsn(Opcodes.ACONST_NULL); //null meta
ctorgen.loadArgs();
ctorgen.invokeConstructor(objtype,
new Method("<init>",
Type.VOID_TYPE, ctorTypes));
ctorgen.returnValue();
ctorgen.endMethod();
//meta()
Method meth =
Method.getMethod("clojure.lang.IPersistentMap meta() ");
GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
meth,
null,
null,
cv);
gen.visitCode();
gen.loadThis();
gen.getField(objtype,"__meta",IPERSISTENTMAP_TYPE);
gen.returnValue();
gen.endMethod();
//withMeta()
meth =
Method.getMethod(
"clojure.lang.IObj withMeta(clojure.lang.IPersistent Map)");
gen = new GeneratorAdapter(ACC_PUBLIC,
682 CHAPTER 9. JVM/CLOJURE/LANG/
meth,
null,
null,
cv);
gen.visitCode();
gen.newInstance(objtype);
gen.dup();
gen.loadArg(0);
for(ISeq s = RT.keys(closes); s != null; s = s.next(), ++a)
{
LocalBinding lb = (LocalBinding) s.first();
gen.loadThis();
Class primc = lb.getPrimitiveType();
if(primc != null)
{
gen.getField(objtype, lb.name, Type.getType(primc));
}
else
{
gen.getField(objtype, lb.name, OBJECT_TYPE);
}
}
gen.invokeConstructor(objtype,
new Method("<init>",
Type.VOID_TYPE, ctorTypes));
gen.returnValue();
gen.endMethod();
}
emitMethods(cv);
if(keywordCallsites.count() > 0)
{
Method meth =
Method.getMethod(
"void swapThunk(int,clojure.lang.ILookupThunk)");
GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
meth,
null,
null,
cv);
gen.visitCode();
Label endLabel = gen.newLabel();
Label[] labels = new Label[keywordCallsites.count()];
for(int i = 0; i < keywordCallsites.count();i++)
{
9.24. COMPILER.JAVA 683
labels[i] = gen.newLabel();
}
gen.loadArg(0);
gen.visitTableSwitchInsn(0,keywordCallsites.count() -1,
endLabel,labels);
for(int i = 0; i < keywordCallsites.count();i++)
{
gen.mark(labels[i]);
// gen.loadThis();
gen.loadArg(1);
gen.putStatic(objtype,
thunkNameStatic(i),ILOOKUP_THUNK_TYPE);
gen.goTo(endLabel);
}
gen.mark(endLabel);
gen.returnValue();
gen.endMethod();
}
//end of class
cv.visitEnd();
bytecode = cw.toByteArray();
if(RT.booleanCast(COMPILE_FILES.deref()))
writeClassFile(internalName, bytecode);
// else
// getCompiledClass();
}
private void emitKeywordCallsites(GeneratorAdapter cli nitgen){
for(int i=0;i<keywordCallsites.count();i++)
{
Keyword k = (Keyword) keywordCallsites.nth(i);
clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE);
clinitgen.dup();
emitValue(k,clinitgen);
clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE ,
Method.getMethod("void <init>(clojure.lang.Keyword)" ));
clinitgen.dup();
clinitgen.putStatic(objtype, siteNameStatic(i),
KEYWORD_LOOKUPSITE_TYPE);
clinitgen.putStatic(objtype, thunkNameStatic(i),
ILOOKUP_THUNK_TYPE);
}
}
protected void emitMethods(ClassVisitor gen){
684 CHAPTER 9. JVM/CLOJURE/LANG/
}
void emitListAsObjectArray(Object value, GeneratorAdap ter gen){
gen.push(((List) value).size());
gen.newArray(OBJECT_TYPE);
int i = 0;
for(Iterator it = ((List) value).iterator(); it.hasNext( ); i++)
{
gen.dup();
gen.push(i);
emitValue(it.next(), gen);
gen.arrayStore(OBJECT_TYPE);
}
}
void emitValue(Object value, GeneratorAdapter gen){
boolean partial = true;
//System.out.println(value.getClass().toString());
if(value instanceof String)
{
gen.push((String) value);
}
else if(value instanceof Integer)
{
gen.push(((Integer) value).intValue());
gen.invokeStatic(Type.getType(Integer.class),
Method.getMethod("Integer valueOf(int)"));
}
else if(value instanceof Long)
{
gen.push(((Long) value).longValue());
gen.invokeStatic(Type.getType(Long.class),
Method.getMethod("Long valueOf(long)"));
}
else if(value instanceof Double)
{
gen.push(((Double) value).doubleValue());
gen.invokeStatic(Type.getType(Double.class),
Method.getMethod("Double valueOf(double)"));
}
else if(value instanceof Character)
{
gen.push(((Character) value).charValue());
gen.invokeStatic(Type.getType(Character.class),
Method.getMethod("Character valueOf(char)"));
}
else if(value instanceof Class)
{
Class cc = (Class)value;
9.24. COMPILER.JAVA 685
if(cc.isPrimitive())
{
Type bt;
if ( cc == boolean.class )
bt = Type.getType(Boolean.class);
else if ( cc == byte.class )
bt = Type.getType(Byte.class);
else if ( cc == char.class )
bt = Type.getType(Character.class);
else if ( cc == double.class )
bt = Type.getType(Double.class);
else if ( cc == float.class )
bt = Type.getType(Float.class);
else if ( cc == int.class )
bt = Type.getType(Integer.class);
else if ( cc == long.class )
bt = Type.getType(Long.class);
else if ( cc == short.class )
bt = Type.getType(Short.class);
else throw new RuntimeException(
"Can’t embed unknown primitive in code: " + value);
gen.getStatic( bt, "TYPE", Type.getType(Class.class) );
}
else
{
gen.push(destubClassName(cc.getName()));
gen.invokeStatic(Type.getType(Class.class),
Method.getMethod("Class forName(String)"));
}
}
else if(value instanceof Symbol)
{
gen.push(((Symbol) value).ns);
gen.push(((Symbol) value).name);
gen.invokeStatic(Type.getType(Symbol.class),
Method.getMethod(
"clojure.lang.Symbol intern(String,String)"));
}
else if(value instanceof Keyword)
{
emitValue(((Keyword) value).sym, gen);
gen.invokeStatic(Type.getType(Keyword.class),
Method.getMethod(
"clojure.lang.Keyword intern(clojure.lang.Symbol)")) ;
}
// else if(value instanceof KeywordCallSite)
// {
// emitValue(((KeywordCallSite) value).k.sym, gen);
// gen.invokeStatic(Type.getType(KeywordCallSite.cla ss),
// Method.getMethod(
686 CHAPTER 9. JVM/CLOJURE/LANG/
// "clojure.lang.KeywordCallSite create(clojure.lang. Symbol)"));
// }
else if(value instanceof Var)
{
Var var = (Var) value;
gen.push(var.ns.name.toString());
gen.push(var.sym.toString());
gen.invokeStatic(RT_TYPE,
Method.getMethod("clojure.lang.Var var(String,String )"));
}
else if(value instanceof IPersistentMap)
{
List entries = new ArrayList();
for(Map.Entry entry :
(Set<Map.Entry>) ((Map) value).entrySet())
{
entries.add(entry.getKey());
entries.add(entry.getValue());
}
emitListAsObjectArray(entries, gen);
gen.invokeStatic(RT_TYPE,
Method.getMethod(
"clojure.lang.IPersistentMap map(Object[])"));
}
else if(value instanceof IPersistentVector)
{
emitListAsObjectArray(value, gen);
gen.invokeStatic(RT_TYPE, Method.getMethod(
"clojure.lang.IPersistentVector vector(Object[])"));
}
else if(value instanceof ISeq ||
value instanceof IPersistentList)
{
emitListAsObjectArray(value, gen);
gen.invokeStatic(Type.getType(java.util.Arrays.clas s),
Method.getMethod("java.util.List asList(Object[])")) ;
gen.invokeStatic(Type.getType(PersistentList.class) ,
Method.getMethod(
"clojure.lang.IPersistentList create(java.util.List) "));
}
else
{
String cs = null;
try
{
cs = RT.printString(value);
//System.out.println(
// "WARNING SLOW CODE: " + value.getClass() +
// " -> " + cs);
}
9.24. COMPILER.JAVA 687
catch(Exception e)
{
throw new RuntimeException(
"Can’t embed object in code, maybe print-dup not defined: " +
value);
}
if(cs.length() == 0)
throw new RuntimeException(
"Can’t embed unreadable object in code: " + value);
if(cs.startsWith("#<"))
throw new RuntimeException(
"Can’t embed unreadable object in code: " + cs);
gen.push(cs);
gen.invokeStatic(RT_TYPE, readStringMethod);
partial = false;
}
if(partial)
{
if(value instanceof IObj &&
RT.count(((IObj) value).meta()) > 0)
{
gen.checkCast(IOBJ_TYPE);
emitValue(((IObj) value).meta(), gen);
gen.checkCast(IPERSISTENTMAP_TYPE);
gen.invokeInterface(IOBJ_TYPE,
Method.getMethod(
"clojure.lang.IObj withMeta(clojure.lang.IPersistent Map)"));
}
}
}
void emitConstants(GeneratorAdapter clinitgen){
try
{
Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T));
for(int i = 0; i < constants.count(); i++)
{
emitValue(constants.nth(i), clinitgen);
clinitgen.checkCast(constantType(i));
clinitgen.putStatic(objtype, constantName(i),
constantType(i));
}
}
finally
{
688 CHAPTER 9. JVM/CLOJURE/LANG/
Var.popThreadBindings();
}
}
boolean isMutable(LocalBinding lb){
return isVolatile(lb) ||
RT.booleanCast(RT.contains(fields, lb.sym)) &&
RT.booleanCast(RT.get(lb.sym.meta(),
Keyword.intern("unsynchronized-mutable")));
}
boolean isVolatile(LocalBinding lb){
return RT.booleanCast(RT.contains(fields, lb.sym)) &&
RT.booleanCast(RT.get(lb.sym.meta(),
Keyword.intern("volatile-mutable")));
}
boolean isDeftype(){
return fields != null;
}
void emitClearCloses(GeneratorAdapter gen){
// int a = 1;
// for(ISeq s = RT.keys(closes); s != null; s = s.next(), ++a)
// {
// LocalBinding lb = (LocalBinding) s.first();
// Class primc = lb.getPrimitiveType();
// if(primc == null)
// {
// gen.loadThis();
// gen.visitInsn(Opcodes.ACONST_NULL);
// gen.putField(objtype, lb.name, OBJECT_TYPE);
// }
// }
}
synchronized Class getCompiledClass(){
if(compiledClass == null)
try
{
// if(RT.booleanCast(COMPILE_FILES.deref()))
// compiledClass =
// RT.classForName(name);//loader.defineClass(name, b ytecode);
// else
{
loader = (DynamicClassLoader) LOADER.deref();
compiledClass =
loader.defineClass(name, bytecode, src);
}
}
9.24. COMPILER.JAVA 689
catch(Exception e)
{
throw new RuntimeException(e);
}
return compiledClass;
}
public Object eval() throws Exception{
if(isDeftype())
return null;
return getCompiledClass().newInstance();
}
public void emitLetFnInits(GeneratorAdapter gen,
ObjExpr objx,
IPersistentSet letFnLocals){
//objx arg is enclosing objx, not this
gen.checkCast(objtype);
for(ISeq s = RT.keys(closes); s != null; s = s.next())
{
LocalBinding lb = (LocalBinding) s.first();
if(letFnLocals.contains(lb))
{
Class primc = lb.getPrimitiveType();
gen.dup();
if(primc != null)
{
objx.emitUnboxedLocal(gen, lb);
gen.putField(objtype, lb.name, Type.getType(primc));
}
else
{
objx.emitLocal(gen, lb, false);
gen.putField(objtype, lb.name, OBJECT_TYPE);
}
}
}
gen.pop();
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
//emitting a Fn means constructing an instance, feeding
// closed-overs from enclosing scope, if any
//objx arg is enclosing objx, not this
// getCompiledClass();
if(isDeftype())
{
gen.visitInsn(Opcodes.ACONST_NULL);
690 CHAPTER 9. JVM/CLOJURE/LANG/
}
else
{
gen.newInstance(objtype);
gen.dup();
gen.visitInsn(Opcodes.ACONST_NULL);
for(ISeq s = RT.seq(closesExprs); s != null; s = s.next())
{
LocalBindingExpr lbe = (LocalBindingExpr) s.first();
LocalBinding lb = lbe.b;
if(lb.getPrimitiveType() != null)
objx.emitUnboxedLocal(gen, lb);
else
objx.emitLocal(gen, lb, lbe.shouldClear);
}
gen.invokeConstructor(objtype,
new Method("<init>", Type.VOID_TYPE, ctorTypes()));
}
if(context == C.STATEMENT)
gen.pop();
}
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return (compiledClass != null) ? compiledClass
: (tag != null) ? HostExpr.tagToClass(tag)
: IFn.class;
}
public void emitAssignLocal(GeneratorAdapter gen,
LocalBinding lb,
Expr val){
if(!isMutable(lb))
throw new IllegalArgumentException(
"Cannot assign to non-mutable: " + lb.name);
Class primc = lb.getPrimitiveType();
gen.loadThis();
if(primc != null)
{
if(!(val instanceof MaybePrimitiveExpr &&
((MaybePrimitiveExpr) val).canEmitPrimitive()))
throw new IllegalArgumentException(
"Must assign primitive to primitive mutable: " +
lb.name);
MaybePrimitiveExpr me = (MaybePrimitiveExpr) val;
me.emitUnboxed(C.EXPRESSION, this, gen);
gen.putField(objtype, lb.name, Type.getType(primc));
9.24. COMPILER.JAVA 691
}
else
{
val.emit(C.EXPRESSION, this, gen);
gen.putField(objtype, lb.name, OBJECT_TYPE);
}
}
private void emitLocal(GeneratorAdapter gen,
LocalBinding lb,
boolean clear){
if(closes.containsKey(lb))
{
Class primc = lb.getPrimitiveType();
gen.loadThis();
if(primc != null)
{
gen.getField(objtype, lb.name, Type.getType(primc));
HostExpr.emitBoxReturn(this, gen, primc);
}
else
{
gen.getField(objtype, lb.name, OBJECT_TYPE);
if(onceOnly && clear && lb.canBeCleared)
{
gen.loadThis();
gen.visitInsn(Opcodes.ACONST_NULL);
gen.putField(objtype, lb.name, OBJECT_TYPE);
}
}
}
else
{
int argoff = isStatic?0:1;
Class primc = lb.getPrimitiveType();
// String rep =
// lb.sym.name + " " +
// lb.toString().substring(
// lb.toString().lastIndexOf(’@’));
if(lb.isArg)
{
gen.loadArg(lb.idx-argoff);
if(primc != null)
HostExpr.emitBoxReturn(this, gen, primc);
else
{
if(clear && lb.canBeCleared)
{
// System.out.println("clear: " + rep);
gen.visitInsn(Opcodes.ACONST_NULL);
692 CHAPTER 9. JVM/CLOJURE/LANG/
gen.storeArg(lb.idx - argoff);
}
else
{
// System.out.println("use: " + rep);
}
}
}
else
{
if(primc != null)
{
gen.visitVarInsn(Type.getType(primc)
.getOpcode(Opcodes.ILOAD),
lb.idx);
HostExpr.emitBoxReturn(this, gen, primc);
}
else
{
gen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ILOAD),
lb.idx);
if(clear && lb.canBeCleared)
{
// System.out.println("clear: " + rep);
gen.visitInsn(Opcodes.ACONST_NULL);
gen.visitVarInsn(OBJECT_TYPE
.getOpcode(Opcodes.ISTORE),
lb.idx);
}
else
{
// System.out.println("use: " + rep);
}
}
}
}
}
private void emitUnboxedLocal(GeneratorAdapter gen, Loc alBinding lb){
int argoff = isStatic?0:1;
Class primc = lb.getPrimitiveType();
if(closes.containsKey(lb))
{
gen.loadThis();
gen.getField(objtype, lb.name, Type.getType(primc));
}
else if(lb.isArg)
gen.loadArg(lb.idx-argoff);
else
9.24. COMPILER.JAVA 693
gen.visitVarInsn(
Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx );
}
public void emitVar(GeneratorAdapter gen, Var var){
Integer i = (Integer) vars.valAt(var);
emitConstant(gen, i);
//gen.getStatic(fntype, munge(var.sym.toString()), VA R_TYPE);
}
final static Method varGetMethod =
Method.getMethod("Object get()");
final static Method varGetRawMethod =
Method.getMethod("Object getRawRoot()");
public void emitVarValue(GeneratorAdapter gen, Var v){
Integer i = (Integer) vars.valAt(v);
if(!v.isDynamic())
{
emitConstant(gen, i);
gen.invokeVirtual(VAR_TYPE, varGetRawMethod);
}
else
{
emitConstant(gen, i);
gen.invokeVirtual(VAR_TYPE, varGetMethod);
}
}
public void emitKeyword(GeneratorAdapter gen, Keyword k) {
Integer i = (Integer) keywords.valAt(k);
emitConstant(gen, i);
// gen.getStatic(fntype, munge(k.sym.toString()), KEYW ORD_TYPE);
}
public void emitConstant(GeneratorAdapter gen, int id){
gen.getStatic(objtype, constantName(id), constantType (id));
}
String constantName(int id){
return CONST_PREFIX + id;
}
String siteName(int n){
return "__site__" + n;
}
String siteNameStatic(int n){
return siteName(n) + "__";
694 CHAPTER 9. JVM/CLOJURE/LANG/
}
String thunkName(int n){
return "__thunk__" + n;
}
String cachedClassName(int n){
return "__cached_class__" + n;
}
String cachedVarName(int n){
return "__cached_var__" + n;
}
String cachedProtoFnName(int n){
return "__cached_proto_fn__" + n;
}
String cachedProtoImplName(int n){
return "__cached_proto_impl__" + n;
}
String varCallsiteName(int n){
return "__var__callsite__" + n;
}
String thunkNameStatic(int n){
return thunkName(n) + "__";
}
Type constantType(int id){
Object o = constants.nth(id);
Class c = o.getClass();
if(Modifier.isPublic(c.getModifiers()))
{
//can’t emit derived fn types due to visibility
if(LazySeq.class.isAssignableFrom(c))
return Type.getType(ISeq.class);
else if(c == Keyword.class)
return Type.getType(Keyword.class);
// else if(c == KeywordCallSite.class)
// return Type.getType(KeywordCallSite.class);
else if(RestFn.class.isAssignableFrom(c))
return Type.getType(RestFn.class);
else if(AFn.class.isAssignableFrom(c))
return Type.getType(AFn.class);
else if(c == Var.class)
return Type.getType(Var.class);
else if(c == String.class)
return Type.getType(String.class);
9.24. COMPILER.JAVA 695
// return Type.getType(c);
}
return OBJECT_TYPE;
}
}
enum PATHTYPE {
PATH, BRANCH;
}
static class PathNode{
final PATHTYPE type;
final PathNode parent;
PathNode(PATHTYPE type, PathNode parent) {
this.type = type;
this.parent = parent;
}
}
static PathNode clearPathRoot(){
return (PathNode) CLEAR_ROOT.get();
}
enum PSTATE{
REQ, REST, DONE
}
public static class FnMethod extends ObjMethod{
//localbinding->localbinding
PersistentVector reqParms = PersistentVector.EMPTY;
LocalBinding restParm = null;
Type[] argtypes;
Class[] argclasses;
Class retClass;
String prim ;
public FnMethod(ObjExpr objx, ObjMethod parent){
super(objx, parent);
}
static public char classChar(Object x){
Class c = null;
if(x instanceof Class)
c = (Class) x;
else if(x instanceof Symbol)
c = primClass((Symbol) x);
if(c == null || !c.isPrimitive())
696 CHAPTER 9. JVM/CLOJURE/LANG/
return ’O’;
if(c == long.class)
return ’L’;
if(c == double.class)
return ’D’;
throw new IllegalArgumentException(
"Only long and double primitives are supported");
}
static public String primInterface(IPersistentVector ar glist)
throws Exception{
StringBuilder sb = new StringBuilder();
for(int i=0;i<arglist.count();i++)
sb.append(classChar(tagOf(arglist.nth(i))));
sb.append(classChar(tagOf(arglist)));
String ret = sb.toString();
boolean prim = ret.contains("L") || ret.contains("D");
if(prim && arglist.count() > 4)
throw new IllegalArgumentException(
"fns taking primitives support only 4 or fewer args");
if(prim)
return "clojure.lang.IFn$" + ret;
return null;
}
static FnMethod parse(ObjExpr objx,
ISeq form,
boolean isStatic)
throws Exception{
//([args] body...)
IPersistentVector parms = (IPersistentVector) RT.first( form);
ISeq body = RT.next(form);
try
{
FnMethod method =
new FnMethod(objx, (ObjMethod) METHOD.deref());
method.line = (Integer) LINE.deref();
//register as the current method and set up a new env frame
PathNode pnode = (PathNode) CLEAR_PATH.get();
if(pnode == null)
pnode = new PathNode(PATHTYPE.PATH,null);
Var.pushThreadBindings(
RT.map(
METHOD, method,
LOCAL_ENV, LOCAL_ENV.deref(),
LOOP_LOCALS, null,
NEXT_LOCAL_NUM, 0
,CLEAR_PATH, pnode
,CLEAR_ROOT, pnode
,CLEAR_SITES, PersistentHashMap.EMPTY
9.24. COMPILER.JAVA 697
));
method.prim = primInterface(parms);
if(method.prim != null)
method.prim = method.prim.replace(’.’, ’/’);
method.retClass = tagClass(tagOf(parms));
if(method.retClass.isPrimitive() &&
!(method.retClass == double.class ||
method.retClass == long.class))
throw new IllegalArgumentException(
"Only long and double primitives are supported");
//register ’this’ as local 0
//registerLocal(THISFN, null, null);
if(!isStatic)
{
if(objx.thisName != null)
registerLocal(Symbol.intern(objx.thisName),
null, null,false);
else
getAndIncLocalNum();
}
PSTATE state = PSTATE.REQ;
PersistentVector argLocals = PersistentVector.EMPTY;
ArrayList<Type> argtypes = new ArrayList();
ArrayList<Class> argclasses = new ArrayList();
for(int i = 0; i < parms.count(); i++)
{
if(!(parms.nth(i) instanceof Symbol))
throw new IllegalArgumentException(
"fn params must be Symbols");
Symbol p = (Symbol) parms.nth(i);
if(p.getNamespace() != null)
throw new Exception(
"Can’t use qualified name as parameter: " + p);
if(p.equals(_AMP_))
{
// if(isStatic)
// throw new Exception(
// "Variadic fns cannot be static");
if(state == PSTATE.REQ)
state = PSTATE.REST;
else
throw new Exception("Invalid parameter list");
}
else
{
Class pc = primClass(tagClass(tagOf(p)));
698 CHAPTER 9. JVM/CLOJURE/LANG/
// if(pc.isPrimitive() && !isStatic)
// {
// pc = Object.class;
// p = (Symbol)
// ((IObj) p)
// .withMeta(
// (IPersistentMap) RT.assoc(
// RT.meta(p), RT.TAG_KEY, null));
// }
// throw new Exception(
// "Non-static fn can’t have primitive parameter: " + p);
if(pc.isPrimitive() &&
!(pc == double.class || pc == long.class))
throw new IllegalArgumentException(
"Only long and double primitives are supported: " + p);
if(state == PSTATE.REST && tagOf(p) != null)
throw new Exception(
"& arg cannot have type hint");
if(state == PSTATE.REST && method.prim != null)
throw new Exception(
"fns taking primitives cannot be variadic");
if(state == PSTATE.REST)
pc = ISeq.class;
argtypes.add(Type.getType(pc));
argclasses.add(pc);
LocalBinding lb =
pc.isPrimitive()
? registerLocal(p, null,
new MethodParamExpr(pc), true)
: registerLocal(p, state == PSTATE.REST
? ISEQ
: tagOf(p), null, true);
argLocals = argLocals.cons(lb);
switch(state)
{
case REQ:
method.reqParms = method.reqParms.cons(lb);
break;
case REST:
method.restParm = lb;
state = PSTATE.DONE;
break;
default:
throw new Exception("Unexpected parameter");
}
}
}
9.24. COMPILER.JAVA 699
if(method.reqParms.count() > MAX_POSITIONAL_ARITY)
throw new Exception("Can’t specify more than " +
MAX_POSITIONAL_ARITY + " params");
LOOP_LOCALS.set(argLocals);
method.argLocals = argLocals;
// if(isStatic)
if(method.prim != null)
{
method.argtypes =
argtypes.toArray(new Type[argtypes.size()]);
method.argclasses =
argclasses.toArray(new Class[argtypes.size()]);
for(int i = 0; i < method.argclasses.length; i++)
{
if(method.argclasses[i] == long.class ||
method.argclasses[i] == double.class)
getAndIncLocalNum();
}
}
method.body = (new BodyExpr.Parser()).parse(C.RETURN, b ody);
return method;
}
finally
{
Var.popThreadBindings();
}
}
public void emit(ObjExpr fn, ClassVisitor cv){
if(prim != null)
doEmitPrim(fn, cv);
else if(fn.isStatic)
doEmitStatic(fn,cv);
else
doEmit(fn,cv);
}
public void doEmitStatic(ObjExpr fn, ClassVisitor cv){
Method ms =
new Method("invokeStatic", getReturnType(), argtypes);
GeneratorAdapter gen =
new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
ms,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
Label loopLabel = gen.mark();
700 CHAPTER 9. JVM/CLOJURE/LANG/
gen.visitLineNumber(line, loopLabel);
try
{
Var.pushThreadBindings(
RT.map(LOOP_LABEL, loopLabel, METHOD, this));
emitBody(objx, gen, retClass, body);
Label end = gen.mark();
for(ISeq lbs = argLocals.seq();
lbs != null;
lbs = lbs.next())
{
LocalBinding lb = (LocalBinding) lbs.first();
gen.visitLocalVariable(lb.name,
argtypes[lb.idx].getDescriptor(), null,
loopLabel, end, lb.idx);
}
}
catch(Exception e)
{
throw new RuntimeException(e);
}
finally
{
Var.popThreadBindings();
}
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
//generate the regular invoke, calling the static method
Method m =
new Method(getMethodName(), OBJECT_TYPE, getArgTypes() );
gen = new GeneratorAdapter(ACC_PUBLIC,
m,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
for(int i = 0; i < argtypes.length; i++)
{
gen.loadArg(i);
HostExpr.emitUnboxArg(fn, gen, argclasses[i]);
}
gen.invokeStatic(objx.objtype, ms);
gen.box(getReturnType());
9.24. COMPILER.JAVA 701
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
}
public void doEmitPrim(ObjExpr fn, ClassVisitor cv){
Method ms =
new Method("invokePrim", getReturnType(), argtypes);
GeneratorAdapter gen =
new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
ms,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
Label loopLabel = gen.mark();
gen.visitLineNumber(line, loopLabel);
try
{
Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel,
METHOD, this));
emitBody(objx, gen, retClass, body);
Label end = gen.mark();
gen.visitLocalVariable("this",
"Ljava/lang/Object;", null,
loopLabel, end, 0);
for(ISeq lbs = argLocals.seq();
lbs != null;
lbs = lbs.next())
{
LocalBinding lb = (LocalBinding) lbs.first();
gen.visitLocalVariable(lb.name,
argtypes[lb.idx-1].getDescriptor(), null,
loopLabel, end, lb.idx);
}
}
catch(Exception e)
{
throw new RuntimeException(e);
}
finally
{
Var.popThreadBindings();
}
702 CHAPTER 9. JVM/CLOJURE/LANG/
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
//generate the regular invoke, calling the prim method
Method m =
new Method(getMethodName(), OBJECT_TYPE, getArgTypes() );
gen = new GeneratorAdapter(ACC_PUBLIC,
m,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
gen.loadThis();
for(int i = 0; i < argtypes.length; i++)
{
gen.loadArg(i);
HostExpr.emitUnboxArg(fn, gen, argclasses[i]);
}
gen.invokeInterface(Type.getType("L"+prim+";"), ms);
gen.box(getReturnType());
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
}
public void doEmit(ObjExpr fn, ClassVisitor cv){
Method m =
new Method(getMethodName(), getReturnType(), getArgTyp es());
GeneratorAdapter gen =
new GeneratorAdapter(ACC_PUBLIC,
m,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
Label loopLabel = gen.mark();
gen.visitLineNumber(line, loopLabel);
try
{
Var.pushThreadBindings(
RT.map(LOOP_LABEL, loopLabel, METHOD, this));
9.24. COMPILER.JAVA 703
body.emit(C.RETURN, fn, gen);
Label end = gen.mark();
gen.visitLocalVariable("this", "Ljava/lang/Object;",
null, loopLabel, end, 0);
for(ISeq lbs = argLocals.seq();
lbs != null;
lbs = lbs.next())
{
LocalBinding lb = (LocalBinding) lbs.first();
gen.visitLocalVariable(lb.name, "Ljava/lang/Object;" ,
null, loopLabel, end, lb.idx);
}
}
finally
{
Var.popThreadBindings();
}
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
}
public final PersistentVector reqParms(){
return reqParms;
}
public final LocalBinding restParm(){
return restParm;
}
boolean isVariadic(){
return restParm != null;
}
int numParams(){
return reqParms.count() + (isVariadic() ? 1 : 0);
}
String getMethodName(){
return isVariadic()?"doInvoke":"invoke";
}
Type getReturnType(){
if(prim != null) //objx.isStatic)
return Type.getType(retClass);
704 CHAPTER 9. JVM/CLOJURE/LANG/
return OBJECT_TYPE;
}
Type[] getArgTypes(){
if(isVariadic() && reqParms.count() == MAX_POSITIONAL_A RITY)
{
Type[] ret = new Type[MAX_POSITIONAL_ARITY + 1];
for(int i = 0;i<MAX_POSITIONAL_ARITY + 1;i++)
ret[i] = OBJECT_TYPE;
return ret;
}
return ARG_TYPES[numParams()];
}
void emitClearLocals(GeneratorAdapter gen){
// for(int i = 1; i < numParams() + 1; i++)
// {
// if(!localsUsedInCatchFinally.contains(i))
// {
// gen.visitInsn(Opcodes.ACONST_NULL);
// gen.visitVarInsn(
// OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i);
// }
// }
// for(int i = numParams() + 1; i < maxLocal + 1; i++)
// {
// if(!localsUsedInCatchFinally.contains(i))
// {
// LocalBinding b =
// (LocalBinding) RT.get(indexlocals, i);
// if(b == null || maybePrimitiveType(b.init) == null)
// {
// gen.visitInsn(Opcodes.ACONST_NULL);
// gen.visitVarInsn(
// OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i);
// }
// }
// }
// if(((FnExpr)objx).onceOnly)
// {
// objx.emitClearCloses(gen);
// }
}
}
abstract public static class ObjMethod{
//when closures are defined inside other closures, the clos ed
//over locals need to be propagated to the enclosing objx
public final ObjMethod parent;
//localbinding->localbinding
9.24. COMPILER.JAVA 705
IPersistentMap locals = null;
//num->localbinding
IPersistentMap indexlocals = null;
Expr body = null;
ObjExpr objx;
PersistentVector argLocals;
int maxLocal = 0;
int line;
PersistentHashSet localsUsedInCatchFinally =
PersistentHashSet.EMPTY;
protected IPersistentMap methodMeta;
public final IPersistentMap locals(){
return locals;
}
public final Expr body(){
return body;
}
public final ObjExpr objx(){
return objx;
}
public final PersistentVector argLocals(){
return argLocals;
}
public final int maxLocal(){
return maxLocal;
}
public final int line(){
return line;
}
public ObjMethod(ObjExpr objx, ObjMethod parent){
this.parent = parent;
this.objx = objx;
}
static void emitBody(ObjExpr objx,
GeneratorAdapter gen,
Class retClass,
Expr body)
throws Exception{
MaybePrimitiveExpr be = (MaybePrimitiveExpr) body;
if(Util.isPrimitive(retClass) && be.canEmitPrimitive( ))
{
706 CHAPTER 9. JVM/CLOJURE/LANG/
Class bc = maybePrimitiveType(be);
if(bc == retClass)
be.emitUnboxed(C.RETURN, objx, gen);
else if(retClass == long.class && bc == int.class)
{
be.emitUnboxed(C.RETURN, objx, gen);
gen.visitInsn(I2L);
}
else if(retClass == double.class && bc == float.class)
{
be.emitUnboxed(C.RETURN, objx, gen);
gen.visitInsn(F2D);
}
else if(retClass == int.class && bc == long.class)
{
be.emitUnboxed(C.RETURN, objx, gen);
gen.invokeStatic(RT_TYPE,
Method.getMethod("int intCast(long)"));
}
else if(retClass == float.class && bc == double.class)
{
be.emitUnboxed(C.RETURN, objx, gen);
gen.visitInsn(D2F);
}
else
throw new IllegalArgumentException(
"Mismatched primitive return, expected: "
+ retClass + ", had: " + be.getJavaClass());
}
else
{
body.emit(C.RETURN, objx, gen);
if(retClass == void.class)
{
gen.pop();
}
else
gen.unbox(Type.getType(retClass));
}
}
abstract int numParams();
abstract String getMethodName();
abstract Type getReturnType();
abstract Type[] getArgTypes();
public void emit(ObjExpr fn, ClassVisitor cv){
Method m =
new Method(getMethodName(), getReturnType(), getArgTyp es());
GeneratorAdapter gen =
9.24. COMPILER.JAVA 707
new GeneratorAdapter(ACC_PUBLIC,
m,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
Label loopLabel = gen.mark();
gen.visitLineNumber(line, loopLabel);
try
{
Var.pushThreadBindings(
RT.map(LOOP_LABEL, loopLabel, METHOD, this));
body.emit(C.RETURN, fn, gen);
Label end = gen.mark();
gen.visitLocalVariable("this", "Ljava/lang/Object;",
null, loopLabel, end, 0);
for(ISeq lbs = argLocals.seq();
lbs != null;
lbs = lbs.next())
{
LocalBinding lb = (LocalBinding) lbs.first();
gen.visitLocalVariable(lb.name, "Ljava/lang/Object;" ,
null, loopLabel, end, lb.idx);
}
}
finally
{
Var.popThreadBindings();
}
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
}
void emitClearLocals(GeneratorAdapter gen){
}
void emitClearLocalsOld(GeneratorAdapter gen){
for(int i=0;i<argLocals.count();i++)
{
LocalBinding lb = (LocalBinding) argLocals.nth(i);
if(!localsUsedInCatchFinally.contains(lb.idx) &&
lb.getPrimitiveType() == null)
{
gen.visitInsn(Opcodes.ACONST_NULL);
gen.storeArg(lb.idx - 1);
708 CHAPTER 9. JVM/CLOJURE/LANG/
}
}
// for(int i = 1; i < numParams() + 1; i++)
// {
// if(!localsUsedInCatchFinally.contains(i))
// {
// gen.visitInsn(Opcodes.ACONST_NULL);
// gen.visitVarInsn(
// OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i);
// }
// }
for(int i = numParams() + 1; i < maxLocal + 1; i++)
{
if(!localsUsedInCatchFinally.contains(i))
{
LocalBinding b = (LocalBinding) RT.get(indexlocals, i);
if(b == null || maybePrimitiveType(b.init) == null)
{
gen.visitInsn(Opcodes.ACONST_NULL);
gen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i);
}
}
}
}
}
public static class LocalBinding{
public final Symbol sym;
public final Symbol tag;
public Expr init;
public final int idx;
public final String name;
public final boolean isArg;
public final PathNode clearPathRoot;
public boolean canBeCleared = true;
public boolean recurMistmatch = false;
public LocalBinding(int num, Symbol sym, Symbol tag, Expr i nit,
boolean isArg,PathNode clearPathRoot)
throws Exception{
if(maybePrimitiveType(init) != null && tag != null)
throw new UnsupportedOperationException(
"Can’t type hint a local with a primitive initializer");
this.idx = num;
this.sym = sym;
this.tag = tag;
this.init = init;
this.isArg = isArg;
9.24. COMPILER.JAVA 709
this.clearPathRoot = clearPathRoot;
name = munge(sym.name);
}
public boolean hasJavaClass() throws Exception{
if(init != null && init.hasJavaClass()
&& Util.isPrimitive(init.getJavaClass())
&& !(init instanceof MaybePrimitiveExpr))
return false;
return tag != null
|| (init != null && init.hasJavaClass());
}
public Class getJavaClass() throws Exception{
return tag != null ? HostExpr.tagToClass(tag)
: init.getJavaClass();
}
public Class getPrimitiveType(){
return maybePrimitiveType(init);
}
}
public static class LocalBindingExpr
implements Expr, MaybePrimitiveExpr, AssignableExpr{
public final LocalBinding b;
public final Symbol tag;
public final PathNode clearPath;
public final PathNode clearRoot;
public boolean shouldClear = false;
public LocalBindingExpr(LocalBinding b, Symbol tag)
throws Exception{
if(b.getPrimitiveType() != null && tag != null)
throw new UnsupportedOperationException(
"Can’t type hint a primitive local");
this.b = b;
this.tag = tag;
this.clearPath = (PathNode)CLEAR_PATH.get();
this.clearRoot = (PathNode)CLEAR_ROOT.get();
IPersistentCollection sites =
(IPersistentCollection) RT.get(CLEAR_SITES.get(),b);
if(b.idx > 0)
{
// Object dummy;
710 CHAPTER 9. JVM/CLOJURE/LANG/
if(sites != null)
{
for(ISeq s = sites.seq();s!=null;s = s.next())
{
LocalBindingExpr o = (LocalBindingExpr) s.first();
PathNode common = commonPath(clearPath,o.clearPath);
if(common != null && common.type == PATHTYPE.PATH)
o.shouldClear = false;
// else
// dummy = null;
}
}
if(clearRoot == b.clearPathRoot)
{
this.shouldClear = true;
sites = RT.conj(sites,this);
CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites) );
}
// else
// dummy = null;
}
}
public Object eval() throws Exception{
throw new UnsupportedOperationException("Can’t eval loc als");
}
public boolean canEmitPrimitive(){
return b.getPrimitiveType() != null;
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
objx.emitUnboxedLocal(gen, b);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
if(context != C.STATEMENT)
objx.emitLocal(gen, b, shouldClear);
}
public Object evalAssign(Expr val) throws Exception{
throw new UnsupportedOperationException("Can’t eval loc als");
}
public void emitAssign(C context,
ObjExpr objx,
GeneratorAdapter gen,
9.24. COMPILER.JAVA 711
Expr val){
objx.emitAssignLocal(gen, b,val);
if(context != C.STATEMENT)
objx.emitLocal(gen, b, false);
}
public boolean hasJavaClass() throws Exception{
return tag != null || b.hasJavaClass();
}
public Class getJavaClass() throws Exception{
if(tag != null)
return HostExpr.tagToClass(tag);
return b.getJavaClass();
}
}
public static class BodyExpr implements Expr, MaybePrimit iveExpr{
PersistentVector exprs;
public final PersistentVector exprs(){
return exprs;
}
public BodyExpr(PersistentVector exprs){
this.exprs = exprs;
}
static class Parser implements IParser{
public Expr parse(C context, Object frms) throws Exception {
ISeq forms = (ISeq) frms;
if(Util.equals(RT.first(forms), DO))
forms = RT.next(forms);
PersistentVector exprs = PersistentVector.EMPTY;
for(; forms != null; forms = forms.next())
{
Expr e = (context != C.EVAL &&
(context == C.STATEMENT ||
forms.next() != null)) ?
analyze(C.STATEMENT, forms.first())
: analyze(context, forms.first());
exprs = exprs.cons(e);
}
if(exprs.count() == 0)
exprs = exprs.cons(NIL_EXPR);
return new BodyExpr(exprs);
}
}
712 CHAPTER 9. JVM/CLOJURE/LANG/
public Object eval() throws Exception{
Object ret = null;
for(Object o : exprs)
{
Expr e = (Expr) o;
ret = e.eval();
}
return ret;
}
public boolean canEmitPrimitive(){
return lastExpr() instanceof MaybePrimitiveExpr &&
((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive() ;
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
for(int i = 0; i < exprs.count() - 1; i++)
{
Expr e = (Expr) exprs.nth(i);
e.emit(C.STATEMENT, objx, gen);
}
MaybePrimitiveExpr last =
(MaybePrimitiveExpr) exprs.nth(exprs.count() - 1);
last.emitUnboxed(context, objx, gen);
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
for(int i = 0; i < exprs.count() - 1; i++)
{
Expr e = (Expr) exprs.nth(i);
e.emit(C.STATEMENT, objx, gen);
}
Expr last = (Expr) exprs.nth(exprs.count() - 1);
last.emit(context, objx, gen);
}
public boolean hasJavaClass() throws Exception{
return lastExpr().hasJavaClass();
}
public Class getJavaClass() throws Exception{
return lastExpr().getJavaClass();
}
private Expr lastExpr(){
return (Expr) exprs.nth(exprs.count() - 1);
}
9.24. COMPILER.JAVA 713
}
public static class BindingInit{
LocalBinding binding;
Expr init;
public final LocalBinding binding(){
return binding;
}
public final Expr init(){
return init;
}
public BindingInit(LocalBinding binding, Expr init){
this.binding = binding;
this.init = init;
}
}
public static class LetFnExpr implements Expr{
public final PersistentVector bindingInits;
public final Expr body;
public LetFnExpr(PersistentVector bindingInits, Expr bo dy){
this.bindingInits = bindingInits;
this.body = body;
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
//(letfns* [var (fn [args] body) ...] body...)
if(!(RT.second(form) instanceof IPersistentVector))
throw new IllegalArgumentException(
"Bad binding form, expected vector");
IPersistentVector bindings =
(IPersistentVector) RT.second(form);
if((bindings.count() % 2) != 0)
throw new IllegalArgumentException(
"Bad binding form, expected matched symbol expression pair s");
ISeq body = RT.next(RT.next(form));
if(context == C.EVAL)
return
analyze(context,
RT.list(
RT.list(FN, PersistentVector.EMPTY,
714 CHAPTER 9. JVM/CLOJURE/LANG/
form)));
IPersistentMap dynamicBindings =
RT.map(LOCAL_ENV, LOCAL_ENV.deref(),
NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref());
try
{
Var.pushThreadBindings(dynamicBindings);
//pre-seed env (like Lisp labels)
PersistentVector lbs = PersistentVector.EMPTY;
for(int i = 0; i < bindings.count(); i += 2)
{
if(!(bindings.nth(i) instanceof Symbol))
throw new IllegalArgumentException(
"Bad binding form, expected symbol, got: " +
bindings.nth(i));
Symbol sym = (Symbol) bindings.nth(i);
if(sym.getNamespace() != null)
throw new Exception(
"Can’t let qualified name: " + sym);
LocalBinding lb =
registerLocal(sym, tagOf(sym), null,false);
lb.canBeCleared = false;
lbs = lbs.cons(lb);
}
PersistentVector bindingInits = PersistentVector.EMPTY ;
for(int i = 0; i < bindings.count(); i += 2)
{
Symbol sym = (Symbol) bindings.nth(i);
Expr init =
analyze(C.EXPRESSION, bindings.nth(i + 1),
sym.name);
LocalBinding lb = (LocalBinding) lbs.nth(i / 2);
lb.init = init;
BindingInit bi = new BindingInit(lb, init);
bindingInits = bindingInits.cons(bi);
}
return
new LetFnExpr(bindingInits,
(new BodyExpr.Parser())
.parse(context, body));
}
finally
{
Var.popThreadBindings();
}
}
}
9.24. COMPILER.JAVA 715
public Object eval() throws Exception{
throw new UnsupportedOperationException("Can’t eval let fns");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
for(int i = 0; i < bindingInits.count(); i++)
{
BindingInit bi = (BindingInit) bindingInits.nth(i);
gen.visitInsn(Opcodes.ACONST_NULL);
gen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.id x);
}
IPersistentSet lbset = PersistentHashSet.EMPTY;
for(int i = 0; i < bindingInits.count(); i++)
{
BindingInit bi = (BindingInit) bindingInits.nth(i);
lbset = (IPersistentSet) lbset.cons(bi.binding);
bi.init.emit(C.EXPRESSION, objx, gen);
gen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.id x);
}
for(int i = 0; i < bindingInits.count(); i++)
{
BindingInit bi = (BindingInit) bindingInits.nth(i);
ObjExpr fe = (ObjExpr) bi.init;
gen.visitVarInsn(
OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx );
fe.emitLetFnInits(gen, objx, lbset);
}
Label loopLabel = gen.mark();
body.emit(context, objx, gen);
Label end = gen.mark();
// gen.visitLocalVariable("this", "Ljava/lang/Object; ",
// null, loopLabel, end, 0);
for(ISeq bis = bindingInits.seq(); bis != null; bis = bis.ne xt())
{
BindingInit bi = (BindingInit) bis.first();
String lname = bi.binding.name;
if(lname.endsWith("__auto__"))
lname += RT.nextID();
Class primc = maybePrimitiveType(bi.init);
if(primc != null)
gen.visitLocalVariable(lname,
716 CHAPTER 9. JVM/CLOJURE/LANG/
Type.getDescriptor(primc),
null, loopLabel, end,
bi.binding.idx);
else
gen.visitLocalVariable(lname, "Ljava/lang/Object;",
null, loopLabel, end,
bi.binding.idx);
}
}
public boolean hasJavaClass() throws Exception{
return body.hasJavaClass();
}
public Class getJavaClass() throws Exception{
return body.getJavaClass();
}
}
public static class LetExpr implements Expr, MaybePrimiti veExpr{
public final PersistentVector bindingInits;
public final Expr body;
public final boolean isLoop;
public LetExpr(PersistentVector bindingInits,
Expr body,
boolean isLoop){
this.bindingInits = bindingInits;
this.body = body;
this.isLoop = isLoop;
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
//(let [var val var2 val2 ...] body...)
boolean isLoop = RT.first(form).equals(LOOP);
if(!(RT.second(form) instanceof IPersistentVector))
throw new IllegalArgumentException(
"Bad binding form, expected vector");
IPersistentVector bindings =
(IPersistentVector) RT.second(form);
if((bindings.count() % 2) != 0)
throw new IllegalArgumentException(
"Bad binding form, expected matched symbol expression pair s");
ISeq body = RT.next(RT.next(form));
if(context == C.EVAL
9.24. COMPILER.JAVA 717
|| (context == C.EXPRESSION && isLoop))
return
analyze(context,
RT.list(RT.list(FN, PersistentVector.EMPTY,
form)));
ObjMethod method = (ObjMethod) METHOD.deref();
IPersistentMap backupMethodLocals = method.locals;
IPersistentMap backupMethodIndexLocals =
method.indexlocals;
PersistentVector recurMismatches = null;
// we might repeat once if a loop with a recurMistmatch,
// return breaks
while(true){
IPersistentMap dynamicBindings =
RT.map(LOCAL_ENV, LOCAL_ENV.deref(),
NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref());
method.locals = backupMethodLocals;
method.indexlocals = backupMethodIndexLocals;
if(isLoop)
dynamicBindings =
dynamicBindings.assoc(LOOP_LOCALS, null);
try
{
Var.pushThreadBindings(dynamicBindings);
PersistentVector bindingInits =
PersistentVector.EMPTY;
PersistentVector loopLocals =
PersistentVector.EMPTY;
for(int i = 0; i < bindings.count(); i += 2)
{
if(!(bindings.nth(i) instanceof Symbol))
throw new IllegalArgumentException(
"Bad binding form, expected symbol, got: "
+ bindings.nth(i));
Symbol sym = (Symbol) bindings.nth(i);
if(sym.getNamespace() != null)
throw new Exception(
"Can’t let qualified name: " + sym);
Expr init =
analyze(C.EXPRESSION, bindings.nth(i + 1),
sym.name);
if(isLoop)
{
if(recurMismatches != null &&
((LocalBinding)recurMismatches
718 CHAPTER 9. JVM/CLOJURE/LANG/
.nth(i/2)).recurMistmatch)
{
init =
new StaticMethodExpr("", 0, null,
RT.class, "box",
RT.vector(init));
if(RT.booleanCast(
RT.WARN_ON_REFLECTION.deref()))
RT.errPrintWriter().println(
"Auto-boxing loop arg: " + sym);
}
else if(maybePrimitiveType(init)==int.class)
init =
new StaticMethodExpr("", 0, null,
RT.class,
"longCast",
RT.vector(init));
else if(maybePrimitiveType(init) ==
float.class)
init =
new StaticMethodExpr("", 0, null,
RT.class,
"doubleCast",
RT.vector(init));
}
//sequential enhancement of env (like Lisp let*)
LocalBinding lb =
registerLocal(sym, tagOf(sym), init,false);
BindingInit bi = new BindingInit(lb, init);
bindingInits = bindingInits.cons(bi);
if(isLoop)
loopLocals = loopLocals.cons(lb);
}
if(isLoop)
LOOP_LOCALS.set(loopLocals);
Expr bodyExpr;
try {
if(isLoop)
{
PathNode root =
new PathNode(PATHTYPE.PATH,
(PathNode) CLEAR_PATH.get());
Var.pushThreadBindings(
RT.map(CLEAR_PATH,
new PathNode(PATHTYPE.PATH,root),
CLEAR_ROOT,
new PathNode(PATHTYPE.PATH,root),
NO_RECUR, null));
9.24. COMPILER.JAVA 719
}
bodyExpr =
(new BodyExpr.Parser())
.parse(isLoop
? C.RETURN
: context, body);
}
finally{
if(isLoop)
{
Var.popThreadBindings();
recurMismatches = null;
for(int i = 0;i< loopLocals.count();i++)
{
LocalBinding lb =
(LocalBinding) loopLocals.nth(i);
if(lb.recurMistmatch)
recurMismatches = loopLocals;
}
}
}
if(recurMismatches == null)
return
new LetExpr(bindingInits, bodyExpr, isLoop);
}
finally
{
Var.popThreadBindings();
}
}
}
}
public Object eval() throws Exception{
throw new UnsupportedOperationException(
"Can’t eval let/loop");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
doEmit(context, objx, gen, false);
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
doEmit(context, objx, gen, true);
}
public void doEmit(C context,
720 CHAPTER 9. JVM/CLOJURE/LANG/
ObjExpr objx,
GeneratorAdapter gen,
boolean emitUnboxed){
for(int i = 0; i < bindingInits.count(); i++)
{
BindingInit bi = (BindingInit) bindingInits.nth(i);
Class primc = maybePrimitiveType(bi.init);
if(primc != null)
{
((MaybePrimitiveExpr) bi.init)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitVarInsn(
Type.getType(primc)
.getOpcode(Opcodes.ISTORE),
bi.binding.idx);
}
else
{
bi.init.emit(C.EXPRESSION, objx, gen);
gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTO RE),
bi.binding.idx);
}
}
Label loopLabel = gen.mark();
if(isLoop)
{
try
{
Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel) );
if(emitUnboxed)
((MaybePrimitiveExpr)body)
.emitUnboxed(context, objx, gen);
else
body.emit(context, objx, gen);
}
finally
{
Var.popThreadBindings();
}
}
else
{
if(emitUnboxed)
((MaybePrimitiveExpr)body)
.emitUnboxed(context, objx, gen);
else
body.emit(context, objx, gen);
}
Label end = gen.mark();
// gen.visitLocalVariable("this", "Ljava/lang/Object; ",
9.24. COMPILER.JAVA 721
// null, loopLabel, end, 0);
for(ISeq bis = bindingInits.seq();
bis != null;
bis = bis.next())
{
BindingInit bi = (BindingInit) bis.first();
String lname = bi.binding.name;
if(lname.endsWith("__auto__"))
lname += RT.nextID();
Class primc = maybePrimitiveType(bi.init);
if(primc != null)
gen.visitLocalVariable(lname,
Type.getDescriptor(primc),
null, loopLabel, end,
bi.binding.idx);
else
gen.visitLocalVariable(lname, "Ljava/lang/Object;",
null, loopLabel, end,
bi.binding.idx);
}
}
public boolean hasJavaClass() throws Exception{
return body.hasJavaClass();
}
public Class getJavaClass() throws Exception{
return body.getJavaClass();
}
public boolean canEmitPrimitive(){
return body instanceof MaybePrimitiveExpr &&
((MaybePrimitiveExpr)body).canEmitPrimitive();
}
}
public static class RecurExpr implements Expr{
public final IPersistentVector args;
public final IPersistentVector loopLocals;
final int line;
final String source;
public RecurExpr(IPersistentVector loopLocals,
IPersistentVector args, int line, String source){
this.loopLocals = loopLocals;
this.args = args;
this.line = line;
this.source = source;
722 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Object eval() throws Exception{
throw new UnsupportedOperationException("Can’t eval rec ur");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
Label loopLabel = (Label) LOOP_LABEL.deref();
if(loopLabel == null)
throw new IllegalStateException();
for(int i = 0; i < loopLocals.count(); i++)
{
LocalBinding lb = (LocalBinding) loopLocals.nth(i);
Expr arg = (Expr) args.nth(i);
if(lb.getPrimitiveType() != null)
{
Class primc = lb.getPrimitiveType();
try
{
final Class pc = maybePrimitiveType(arg);
if(pc == primc)
((MaybePrimitiveExpr) arg)
.emitUnboxed(C.EXPRESSION, objx, gen);
else if(primc == long.class && pc == int.class)
{
((MaybePrimitiveExpr) arg)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitInsn(I2L);
}
else if(primc == double.class && pc == float.class)
{
((MaybePrimitiveExpr) arg)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitInsn(F2D);
}
else if(primc == int.class && pc == long.class)
{
((MaybePrimitiveExpr) arg)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.invokeStatic(RT_TYPE,
Method.getMethod("int intCast(long)"));
}
else if(primc == float.class && pc == double.class)
{
((MaybePrimitiveExpr) arg)
.emitUnboxed(C.EXPRESSION, objx, gen);
gen.visitInsn(D2F);
}
else
{
9.24. COMPILER.JAVA 723
//RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
// if(true)
throw new IllegalArgumentException
// RT.errPrintWriter().println
(//source + ":" + line +
" recur arg for primitive local: " +
lb.name +
" is not matching primitive, had: " +
(arg.hasJavaClass()
? arg.getJavaClass().getName()
:"Object") +
", needed: " +
primc.getName());
// arg.emit(C.EXPRESSION, objx, gen);
// HostExpr.emitUnboxArg(objx,gen,primc);
}
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
else
{
arg.emit(C.EXPRESSION, objx, gen);
}
}
for(int i = loopLocals.count() - 1; i >= 0; i--)
{
LocalBinding lb = (LocalBinding) loopLocals.nth(i);
Class primc = lb.getPrimitiveType();
if(lb.isArg)
gen.storeArg(lb.idx-(objx.isStatic?0:1));
else
{
if(primc != null)
gen.visitVarInsn(
Type.getType(primc)
.getOpcode(Opcodes.ISTORE), lb.idx);
else
gen.visitVarInsn(
OBJECT_TYPE
.getOpcode(Opcodes.ISTORE), lb.idx);
}
}
gen.goTo(loopLabel);
}
724 CHAPTER 9. JVM/CLOJURE/LANG/
public boolean hasJavaClass() throws Exception{
return true;
}
public Class getJavaClass() throws Exception{
return null;
}
static class Parser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
int line = (Integer) LINE.deref();
String source = (String) SOURCE.deref();
ISeq form = (ISeq) frm;
IPersistentVector loopLocals =
(IPersistentVector) LOOP_LOCALS.deref();
if(context != C.RETURN || loopLocals == null)
throw new UnsupportedOperationException(
"Can only recur from tail position");
if(IN_CATCH_FINALLY.deref() != null)
throw new UnsupportedOperationException(
"Cannot recur from catch/finally");
if(NO_RECUR.deref() != null)
throw new UnsupportedOperationException(
"Cannot recur across try");
PersistentVector args = PersistentVector.EMPTY;
for(ISeq s = RT.seq(form.next()); s != null; s = s.next())
{
args = args.cons(analyze(C.EXPRESSION, s.first()));
}
if(args.count() != loopLocals.count())
throw new IllegalArgumentException(
String.format(
"Mismatched argument count to recur, expected: %d args, got : %d",
loopLocals.count(), args.count()));
for(int i = 0;i< loopLocals.count();i++)
{
LocalBinding lb = (LocalBinding) loopLocals.nth(i);
Class primc = lb.getPrimitiveType();
if(primc != null)
{
boolean mismatch = false;
final Class pc =
maybePrimitiveType((Expr) args.nth(i));
if(primc == long.class)
{
if(!(pc == long.class
|| pc == int.class
|| pc == short.class
|| pc == char.class
9.24. COMPILER.JAVA 725
|| pc == byte.class))
mismatch = true;
}
else if(primc == double.class)
{
if(!(pc == double.class
|| pc == float.class))
mismatch = true;
}
if(mismatch)
{
lb.recurMistmatch = true;
if(RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
RT.errPrintWriter().println
(source + ":" + line +
" recur arg for primitive local: " +
lb.name +
" is not matching primitive, had: " +
(pc != null ? pc.getName():"Object") +
", needed: " +
primc.getName());
}
}
}
return new RecurExpr(loopLocals, args, line, source);
}
}
}
private static LocalBinding registerLocal(Symbol sym,
Symbol tag,
Expr init,
boolean isArg)
throws Exception{
int num = getAndIncLocalNum();
LocalBinding b =
new LocalBinding(num, sym, tag, init, isArg, clearPathRoo t());
IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.d eref();
LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b));
ObjMethod method = (ObjMethod) METHOD.deref();
method.locals = (IPersistentMap) RT.assoc(method.local s, b, b);
method.indexlocals =
(IPersistentMap) RT.assoc(method.indexlocals, num, b);
return b;
}
private static int getAndIncLocalNum(){
int num = ((Number) NEXT_LOCAL_NUM.deref()).intValue();
ObjMethod m = (ObjMethod) METHOD.deref();
if(num > m.maxLocal)
726 CHAPTER 9. JVM/CLOJURE/LANG/
m.maxLocal = num;
NEXT_LOCAL_NUM.set(num + 1);
return num;
}
public static Expr analyze(C context, Object form) throws E xception{
return analyze(context, form, null);
}
private static Expr analyze(C context,
Object form,
String name)
throws Exception{
//todo symbol macro expansion?
try
{
if(form instanceof LazySeq)
{
form = RT.seq(form);
if(form == null)
form = PersistentList.EMPTY;
}
if(form == null)
return NIL_EXPR;
else if(form == Boolean.TRUE)
return TRUE_EXPR;
else if(form == Boolean.FALSE)
return FALSE_EXPR;
Class fclass = form.getClass();
if(fclass == Symbol.class)
return analyzeSymbol((Symbol) form);
else if(fclass == Keyword.class)
return registerKeyword((Keyword) form);
else if(form instanceof Number)
return NumberExpr.parse((Number) form);
else if(fclass == String.class)
return new StringExpr(((String) form).intern());
// else if(fclass == Character.class)
// return new CharExpr((Character) form);
else if(form instanceof IPersistentCollection &&
((IPersistentCollection) form).count() == 0)
{
Expr ret = new EmptyExpr(form);
if(RT.meta(form) != null)
ret = new MetaExpr(ret, MapExpr
.parse(context == C.EVAL
? context
: C.EXPRESSION,
((IObj) form).meta()));
return ret;
9.24. COMPILER.JAVA 727
}
else if(form instanceof ISeq)
return analyzeSeq(context, (ISeq) form, name);
else if(form instanceof IPersistentVector)
return VectorExpr.parse(context,
(IPersistentVector) form);
else if(form instanceof IPersistentMap)
return MapExpr.parse(context, (IPersistentMap) form);
else if(form instanceof IPersistentSet)
return SetExpr.parse(context, (IPersistentSet) form);
// else
//throw new UnsupportedOperationException();
return new ConstantExpr(form);
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(
(String) SOURCE_PATH.deref(), (Integer) LINE.deref(), e );
else
throw (CompilerException) e;
}
}
static public class CompilerException extends Exception{
final public String source;
public CompilerException(String source, int line, Throwa ble cause){
super(errorMsg(source, line, cause.toString()), cause) ;
this.source = source;
}
public String toString(){
return getMessage();
}
}
static public Var isMacro(Object op) throws Exception{
//no local macros for now
if(op instanceof Symbol && referenceLocal((Symbol) op) != null)
return null;
if(op instanceof Symbol || op instanceof Var)
{
Var v = (op instanceof Var)
? (Var) op
: lookupVar((Symbol) op, false);
if(v != null && v.isMacro())
{
if(v.ns != currentNS() && !v.isPublic())
728 CHAPTER 9. JVM/CLOJURE/LANG/
throw new IllegalStateException(
"var: " + v + " is not public");
return v;
}
}
return null;
}
static public IFn isInline(Object op, int arity) throws Exc eption{
//no local inlines for now
if(op instanceof Symbol && referenceLocal((Symbol) op) != null)
return null;
if(op instanceof Symbol || op instanceof Var)
{
Var v = (op instanceof Var)
? (Var) op
: lookupVar((Symbol) op, false);
if(v != null)
{
if(v.ns != currentNS() && !v.isPublic())
throw new IllegalStateException(
"var: " + v + " is not public");
IFn ret = (IFn) RT.get(v.meta(), inlineKey);
if(ret != null)
{
IFn arityPred = (IFn) RT.get(v.meta(), inlineAritiesKey) ;
if(arityPred == null ||
RT.booleanCast(arityPred.invoke(arity)))
return ret;
}
}
}
return null;
}
public static boolean namesStaticMember(Symbol sym){
return sym.ns != null && namespaceFor(sym) == null;
}
public static Object preserveTag(ISeq src, Object dst) {
Symbol tag = tagOf(src);
if (tag != null && dst instanceof IObj) {
IPersistentMap meta = RT.meta(dst);
return ((IObj) dst)
.withMeta(
(IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag));
}
return dst;
}
9.24. COMPILER.JAVA 729
public static Object macroexpand1(Object x) throws Except ion{
if(x instanceof ISeq)
{
ISeq form = (ISeq) x;
Object op = RT.first(form);
if(isSpecial(op))
return x;
//macro expansion
Var v = isMacro(op);
if(v != null)
{
try
{
return
v.applyTo(
RT.cons(
form,
RT.cons(LOCAL_ENV.get(),form.next())));
}
catch(ArityException e)
{
// hide the 2 extra params for a macro
throw new ArityException(e.actual - 2, e.name);
}
}
else
{
if(op instanceof Symbol)
{
Symbol sym = (Symbol) op;
String sname = sym.name;
//(.substring s 2 5) => (. s substring 2 5)
if(sym.name.charAt(0) == ’.’)
{
if(RT.length(form) < 2)
throw new IllegalArgumentException(
"Malformed member expression, expecting (.member target . ..)");
Symbol meth = Symbol.intern(sname.substring(1));
Object target = RT.second(form);
if(HostExpr.maybeClass(target, false) != null)
{
target =
((IObj)RT.list(IDENTITY, target))
.withMeta(RT.map(RT.TAG_KEY,CLASS));
}
return
preserveTag(form,
RT.listStar(DOT,
target,
meth,
730 CHAPTER 9. JVM/CLOJURE/LANG/
form.next().next()));
}
else if(namesStaticMember(sym))
{
Symbol target = Symbol.intern(sym.ns);
Class c = HostExpr.maybeClass(target, false);
if(c != null)
{
Symbol meth = Symbol.intern(sym.name);
return
preserveTag(form,
RT.listStar(DOT,
target,
meth,
form.next()));
}
}
else
{
//(s.substring 2 5) => (. s substring 2 5)
//also (package.class.name ...) (. package.class name ... )
int idx = sname.lastIndexOf(’.’);
// if(idx > 0 && idx < sname.length() - 1)
// {
// Symbol target = Symbol.intern(sname.substring(0, idx) );
// Symbol meth = Symbol.intern(sname.substring(idx + 1));
// return RT.listStar(DOT, target, meth, form.rest());
// }
//(StringBuilder. "foo") => (new StringBuilder "foo")
//else
if(idx == sname.length() - 1)
return
RT.listStar(NEW,
Symbol.intern(sname.substring(0, idx)),
form.next());
}
}
}
}
return x;
}
static Object macroexpand(Object form) throws Exception{
Object exf = macroexpand1(form);
if(exf != form)
return macroexpand(exf);
return form;
}
private static Expr analyzeSeq(C context,
9.24. COMPILER.JAVA 731
ISeq form,
String name)
throws Exception{
Integer line = (Integer) LINE.deref();
if(RT.meta(form) != null && RT.meta(form).containsKey(R T.LINE_KEY))
line = (Integer) RT.meta(form).valAt(RT.LINE_KEY);
Var.pushThreadBindings(
RT.map(LINE, line));
try
{
Object me = macroexpand1(form);
if(me != form)
return analyze(context, me, name);
Object op = RT.first(form);
if(op == null)
throw new IllegalArgumentException("Can’t call nil");
IFn inline = isInline(op, RT.count(RT.next(form)));
if(inline != null)
return
analyze(context,
preserveTag(form, inline.applyTo(RT.next(form))));
IParser p;
if(op.equals(FN))
return FnExpr.parse(context, form, name);
else if((p = (IParser) specials.valAt(op)) != null)
return p.parse(context, form);
else
return InvokeExpr.parse(context, form);
}
catch(Throwable e)
{
if(!(e instanceof CompilerException))
throw new CompilerException(
(String) SOURCE_PATH.deref(), (Integer) LINE.deref(), e );
else
throw (CompilerException) e;
}
finally
{
Var.popThreadBindings();
}
}
static String errorMsg(String source, int line, String s){
return String.format("%s, compiling:(%s:%d)", s, source , line);
}
public static Object eval(Object form) throws Exception{
return eval(form, true);
732 CHAPTER 9. JVM/CLOJURE/LANG/
}
public static Object eval(Object form, boolean freshLoade r)
throws Exception{
boolean createdLoader = false;
if(true)//!LOADER.isBound())
{
Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLo ader()));
createdLoader = true;
}
try
{
Integer line = (Integer) LINE.deref();
if(RT.meta(form) != null &&
RT.meta(form).containsKey(RT.LINE_KEY))
line = (Integer) RT.meta(form).valAt(RT.LINE_KEY);
Var.pushThreadBindings(RT.map(LINE, line));
try
{
form = macroexpand(form);
if(form instanceof IPersistentCollection &&
Util.equals(RT.first(form), DO))
{
ISeq s = RT.next(form);
for(; RT.next(s) != null; s = RT.next(s))
eval(RT.first(s), false);
return eval(RT.first(s), false);
}
else if(form instanceof IPersistentCollection
&& !(RT.first(form) instanceof Symbol
&& ((Symbol) RT.first(form)).name
.startsWith("def")))
{
ObjExpr fexpr =
(ObjExpr) analyze(C.EXPRESSION,
RT.list(FN, PersistentVector.EMPTY, form),
"eval" + RT.nextID());
IFn fn = (IFn) fexpr.eval();
return fn.invoke();
}
else
{
Expr expr = analyze(C.EVAL, form);
return expr.eval();
}
}
catch(Throwable e)
{
if(!(e instanceof Exception))
throw new RuntimeException(e);
9.24. COMPILER.JAVA 733
throw (Exception)e;
}
finally
{
Var.popThreadBindings();
}
}
finally
{
if(createdLoader)
Var.popThreadBindings();
}
}
private static int registerConstant(Object o){
if(!CONSTANTS.isBound())
return -1;
PersistentVector v = (PersistentVector) CONSTANTS.deref ();
IdentityHashMap<Object,Integer> ids =
(IdentityHashMap<Object,Integer>) CONSTANT_IDS.deref ();
Integer i = ids.get(o);
if(i != null)
return i;
CONSTANTS.set(RT.conj(v, o));
ids.put(o, v.count());
return v.count();
}
private static KeywordExpr registerKeyword(Keyword keyw ord){
if(!KEYWORDS.isBound())
return new KeywordExpr(keyword);
IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS. deref();
Object id = RT.get(keywordsMap, keyword);
if(id == null)
{
KEYWORDS.set(RT.assoc(keywordsMap,
keyword,
registerConstant(keyword)));
}
return new KeywordExpr(keyword);
// KeywordExpr ke = (KeywordExpr) RT.get(keywordsMap, key word);
// if(ke == null)
// KEYWORDS.set(
// RT.assoc(keywordsMap, keyword,
// ke = new KeywordExpr(keyword)));
// return ke;
}
734 CHAPTER 9. JVM/CLOJURE/LANG/
private static int registerKeywordCallsite(Keyword keyw ord){
if(!KEYWORD_CALLSITES.isBound())
throw new IllegalAccessError("KEYWORD_CALLSITES is not b ound");
IPersistentVector keywordCallsites =
(IPersistentVector) KEYWORD_CALLSITES.deref();
keywordCallsites = keywordCallsites.cons(keyword);
KEYWORD_CALLSITES.set(keywordCallsites);
return keywordCallsites.count()-1;
}
private static int registerProtocolCallsite(Var v){
if(!PROTOCOL_CALLSITES.isBound())
throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound");
IPersistentVector protocolCallsites =
(IPersistentVector) PROTOCOL_CALLSITES.deref();
protocolCallsites = protocolCallsites.cons(v);
PROTOCOL_CALLSITES.set(protocolCallsites);
return protocolCallsites.count()-1;
}
private static void registerVarCallsite(Var v){
if(!VAR_CALLSITES.isBound())
throw new IllegalAccessError("VAR_CALLSITES is not bound ");
IPersistentCollection varCallsites =
(IPersistentCollection) VAR_CALLSITES.deref();
varCallsites = varCallsites.cons(v);
VAR_CALLSITES.set(varCallsites);
// return varCallsites.count()-1;
}
static ISeq fwdPath(PathNode p1){
ISeq ret = null;
for(;p1 != null;p1 = p1.parent)
ret = RT.cons(p1,ret);
return ret;
}
static PathNode commonPath(PathNode n1, PathNode n2){
ISeq xp = fwdPath(n1);
ISeq yp = fwdPath(n2);
if(RT.first(xp) != RT.first(yp))
return null;
while(RT.second(xp) != null && RT.second(xp) == RT.second (yp))
{
9.24. COMPILER.JAVA 735
xp = xp.next();
yp = yp.next();
}
return (PathNode) RT.first(xp);
}
static void addAnnotation(Object visitor, IPersistentMa p meta){
try{
if(meta != null && ADD_ANNOTATIONS.isBound())
ADD_ANNOTATIONS.invoke(visitor, meta);
}
catch (Exception e)
{
throw new RuntimeException(e);
}
}
static void addParameterAnnotation(Object visitor,
IPersistentMap meta,
int i){
try{
if(meta != null && ADD_ANNOTATIONS.isBound())
ADD_ANNOTATIONS.invoke(visitor, meta, i);
}
catch (Exception e)
{
throw new RuntimeException(e);
}
}
private static Expr analyzeSymbol(Symbol sym) throws Exce ption{
Symbol tag = tagOf(sym);
if(sym.ns == null) //ns-qualified syms are always Vars
{
LocalBinding b = referenceLocal(sym);
if(b != null)
{
return new LocalBindingExpr(b, tag);
}
}
else
{
if(namespaceFor(sym) == null)
{
Symbol nsSym = Symbol.intern(sym.ns);
Class c = HostExpr.maybeClass(nsSym, false);
if(c != null)
{
if(Reflector.getField(c, sym.name, true) != null)
return new StaticFieldExpr(
736 CHAPTER 9. JVM/CLOJURE/LANG/
(Integer) LINE.deref(), c, sym.name, tag);
throw new Exception(
"Unable to find static field: " + sym.name + " in " + c);
}
}
}
//Var v = lookupVar(sym, false);
// Var v = lookupVar(sym, false);
// if(v != null)
// return new VarExpr(v, tag);
Object o = resolve(sym);
if(o instanceof Var)
{
Var v = (Var) o;
if(isMacro(v) != null)
throw new Exception("Can’t take value of a macro: " + v);
registerVar(v);
return new VarExpr(v, tag);
}
else if(o instanceof Class)
return new ConstantExpr(o);
else if(o instanceof Symbol)
return new UnresolvedVarExpr((Symbol) o);
throw new Exception(
"Unable to resolve symbol: " + sym + " in this context");
}
static String destubClassName(String className){
//skip over prefix + ’.’ or ’/’
if(className.startsWith(COMPILE_STUB_PREFIX))
return className.substring(COMPILE_STUB_PREFIX.lengt h()+1);
return className;
}
static Type getType(Class c){
String descriptor = Type.getType(c).getDescriptor();
if(descriptor.startsWith("L"))
descriptor = "L" + destubClassName(descriptor.substring (1));
return Type.getType(descriptor);
}
static Object resolve(Symbol sym, boolean allowPrivate)
throws Exception{
return resolveIn(currentNS(), sym, allowPrivate);
}
static Object resolve(Symbol sym) throws Exception{
return resolveIn(currentNS(), sym, false);
9.24. COMPILER.JAVA 737
}
static Namespace namespaceFor(Symbol sym){
return namespaceFor(currentNS(), sym);
}
static Namespace namespaceFor(Namespace inns, Symbol sym ){
//note, presumes non-nil sym.ns
// first check against currentNS’ aliases...
Symbol nsSym = Symbol.intern(sym.ns);
Namespace ns = inns.lookupAlias(nsSym);
if(ns == null)
{
// ...otherwise check the Namespaces map.
ns = Namespace.find(nsSym);
}
return ns;
}
static public Object resolveIn(Namespace n,
Symbol sym,
boolean allowPrivate)
throws Exception{
//note - ns-qualified vars must already exist
if(sym.ns != null)
{
Namespace ns = namespaceFor(n, sym);
if(ns == null)
throw new Exception("No such namespace: " + sym.ns);
Var v = ns.findInternedVar(Symbol.intern(sym.name));
if(v == null)
throw new Exception("No such var: " + sym);
else if(v.ns != currentNS() && !v.isPublic() && !allowPriv ate)
throw new IllegalStateException(
"var: " + sym + " is not public");
return v;
}
else if(sym.name.indexOf(’.’) > 0 || sym.name.charAt(0) = = ’[’)
{
return RT.classForName(sym.name);
}
else if(sym.equals(NS))
return RT.NS_VAR;
else if(sym.equals(IN_NS))
return RT.IN_NS_VAR;
else
{
if(Util.equals(sym, COMPILE_STUB_SYM.get()))
return COMPILE_STUB_CLASS.get();
738 CHAPTER 9. JVM/CLOJURE/LANG/
Object o = n.getMapping(sym);
if(o == null)
{
if(RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()) )
{
return sym;
}
else
{
throw new Exception(
"Unable to resolve symbol: " + sym +
" in this context");
}
}
return o;
}
}
static public Object maybeResolveIn(Namespace n, Symbol s ym)
throws Exception{
//note - ns-qualified vars must already exist
if(sym.ns != null)
{
Namespace ns = namespaceFor(n, sym);
if(ns == null)
return null;
Var v = ns.findInternedVar(Symbol.intern(sym.name));
if(v == null)
return null;
return v;
}
else if(sym.name.indexOf(’.’) > 0 && !sym.name.endsWith( ".")
|| sym.name.charAt(0) == ’[’)
{
return RT.classForName(sym.name);
}
else if(sym.equals(NS))
return RT.NS_VAR;
else if(sym.equals(IN_NS))
return RT.IN_NS_VAR;
else
{
Object o = n.getMapping(sym);
return o;
}
}
static Var lookupVar(Symbol sym, boolean internNew) throw s Exception{
9.24. COMPILER.JAVA 739
Var var = null;
//note - ns-qualified vars in other namespaces must already exist
if(sym.ns != null)
{
Namespace ns = namespaceFor(sym);
if(ns == null)
return null;
//throw new Exception("No such namespace: " + sym.ns);
Symbol name = Symbol.intern(sym.name);
if(internNew && ns == currentNS())
var = currentNS().intern(name);
else
var = ns.findInternedVar(name);
}
else if(sym.equals(NS))
var = RT.NS_VAR;
else if(sym.equals(IN_NS))
var = RT.IN_NS_VAR;
else
{
//is it mapped?
Object o = currentNS().getMapping(sym);
if(o == null)
{
//introduce a new var in the current ns
if(internNew)
var = currentNS().intern(Symbol.intern(sym.name));
}
else if(o instanceof Var)
{
var = (Var) o;
}
else
{
throw new Exception(
"Expecting var, but " + sym + " is mapped to " + o);
}
}
if(var != null)
registerVar(var);
return var;
}
private static void registerVar(Var var) throws Exception {
if(!VARS.isBound())
return;
IPersistentMap varsMap = (IPersistentMap) VARS.deref();
Object id = RT.get(varsMap, var);
if(id == null)
740 CHAPTER 9. JVM/CLOJURE/LANG/
{
VARS.set(RT.assoc(varsMap, var, registerConstant(var) ));
}
// if(varsMap != null && RT.get(varsMap, var) == null)
// VARS.set(RT.assoc(varsMap, var, var));
}
static Namespace currentNS(){
return (Namespace) RT.CURRENT_NS.deref();
}
static void closeOver(LocalBinding b, ObjMethod method){
if(b != null && method != null)
{
if(RT.get(method.locals, b) == null)
{
method.objx.closes =
(IPersistentMap) RT.assoc(method.objx.closes, b, b);
closeOver(b, method.parent);
}
else if(IN_CATCH_FINALLY.deref() != null)
{
method.localsUsedInCatchFinally =
(PersistentHashSet)
method.localsUsedInCatchFinally.cons(b.idx);
}
}
}
static LocalBinding referenceLocal(Symbol sym) throws Ex ception{
if(!LOCAL_ENV.isBound())
return null;
LocalBinding b = (LocalBinding) RT.get(LOCAL_ENV.deref( ), sym);
if(b != null)
{
ObjMethod method = (ObjMethod) METHOD.deref();
closeOver(b, method);
}
return b;
}
private static Symbol tagOf(Object o){
Object tag = RT.get(RT.meta(o), RT.TAG_KEY);
if(tag instanceof Symbol)
return (Symbol) tag;
else if(tag instanceof String)
return Symbol.intern(null, (String) tag);
return null;
}
9.24. COMPILER.JAVA 741
public static Object loadFile(String file) throws Excepti on{
// File fo = new File(file);
// if(!fo.exists())
// return null;
FileInputStream f = new FileInputStream(file);
try
{
return load(new InputStreamReader(f, RT.UTF8),
new File(file).getAbsolutePath(),
(new File(file)).getName());
}
finally
{
f.close();
}
}
public static Object load(Reader rdr) throws Exception{
return load(rdr, null, "NO_SOURCE_FILE");
}
public static Object load(Reader rdr,
String sourcePath,
String sourceName)
throws Exception{
Object EOF = new Object();
Object ret = null;
LineNumberingPushbackReader pushbackReader =
(rdr instanceof LineNumberingPushbackReader)
? (LineNumberingPushbackReader) rdr
: new LineNumberingPushbackReader(rdr);
Var.pushThreadBindings(
RT.map(LOADER, RT.makeClassLoader(),
SOURCE_PATH, sourcePath,
SOURCE, sourceName,
METHOD, null,
LOCAL_ENV, null,
LOOP_LOCALS, null,
NEXT_LOCAL_NUM, 0,
RT.CURRENT_NS, RT.CURRENT_NS.deref(),
LINE_BEFORE, pushbackReader.getLineNumber(),
LINE_AFTER, pushbackReader.getLineNumber()
,UNCHECKED_MATH, UNCHECKED_MATH.deref()
,RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref( )
));
try
{
742 CHAPTER 9. JVM/CLOJURE/LANG/
for(Object r =
LispReader.read(pushbackReader, false, EOF, false); r != EOF;
r = LispReader.read(pushbackReader, false, EOF, false))
{
LINE_AFTER.set(pushbackReader.getLineNumber());
ret = eval(r,false);
LINE_BEFORE.set(pushbackReader.getLineNumber());
}
}
catch(LispReader.ReaderException e)
{
throw new CompilerException(sourcePath, e.line, e.getCa use());
}
finally
{
Var.popThreadBindings();
}
return ret;
}
static public void writeClassFile(String internalName,
byte[] bytecode)
throws Exception{
String genPath = (String) COMPILE_PATH.deref();
if(genPath == null)
throw new Exception("*compile-path* not set");
String[] dirs = internalName.split("/");
String p = genPath;
for(int i = 0; i < dirs.length - 1; i++)
{
p += File.separator + dirs[i];
(new File(p)).mkdir();
}
String path = genPath + File.separator + internalName + ".cl ass";
File cf = new File(path);
cf.createNewFile();
FileOutputStream cfs = new FileOutputStream(cf);
try
{
cfs.write(bytecode);
cfs.flush();
cfs.getFD().sync();
}
finally
{
cfs.close();
}
}
public static void pushNS(){
9.24. COMPILER.JAVA 743
Var.pushThreadBindings(
PersistentHashMap.create(
Var.intern(
Symbol.intern("clojure.core"),
Symbol.intern("*ns*")).setDynamic(), null));
}
public static ILookupThunk getLookupThunk(Object target , Keyword k){
//To change body of created methods use File | Settings | File Templates.
return null;
}
static void compile1(GeneratorAdapter gen,
ObjExpr objx,
Object form)
throws Exception{
Integer line = (Integer) LINE.deref();
if(RT.meta(form) != null && RT.meta(form).containsKey(R T.LINE_KEY))
line = (Integer) RT.meta(form).valAt(RT.LINE_KEY);
Var.pushThreadBindings(
RT.map(LINE, line
,LOADER, RT.makeClassLoader()
));
try
{
form = macroexpand(form);
if(form instanceof IPersistentCollection &&
Util.equals(RT.first(form), DO))
{
for(ISeq s = RT.next(form); s != null; s = RT.next(s))
{
compile1(gen, objx, RT.first(s));
}
}
else
{
Expr expr = analyze(C.EVAL, form);
objx.keywords = (IPersistentMap) KEYWORDS.deref();
objx.vars = (IPersistentMap) VARS.deref();
objx.constants = (PersistentVector) CONSTANTS.deref();
expr.emit(C.EXPRESSION, objx, gen);
expr.eval();
}
}
finally
{
Var.popThreadBindings();
}
}
744 CHAPTER 9. JVM/CLOJURE/LANG/
public static Object compile(Reader rdr,
String sourcePath,
String sourceName)
throws Exception{
if(COMPILE_PATH.deref() == null)
throw new Exception("*compile-path* not set");
Object EOF = new Object();
Object ret = null;
LineNumberingPushbackReader pushbackReader =
(rdr instanceof LineNumberingPushbackReader)
? (LineNumberingPushbackReader) rdr
: new LineNumberingPushbackReader(rdr);
Var.pushThreadBindings(
RT.map(SOURCE_PATH, sourcePath,
SOURCE, sourceName,
METHOD, null,
LOCAL_ENV, null,
LOOP_LOCALS, null,
NEXT_LOCAL_NUM, 0,
RT.CURRENT_NS, RT.CURRENT_NS.deref(),
LINE_BEFORE, pushbackReader.getLineNumber(),
LINE_AFTER, pushbackReader.getLineNumber(),
CONSTANTS, PersistentVector.EMPTY,
CONSTANT_IDS, new IdentityHashMap(),
KEYWORDS, PersistentHashMap.EMPTY,
VARS, PersistentHashMap.EMPTY
,UNCHECKED_MATH, UNCHECKED_MATH.deref()
,RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref( )
// ,LOADER, RT.makeClassLoader()
));
try
{
//generate loader class
ObjExpr objx = new ObjExpr(null);
objx.internalName =
sourcePath.replace(File.separator, "/")
.substring(0, sourcePath.lastIndexOf(’.’))
+ RT.LOADER_SUFFIX;
objx.objtype = Type.getObjectType(objx.internalName);
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MA XS);
ClassVisitor cv = cw;
cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER,
objx.internalName, null,
"java/lang/Object", null);
//static load method
GeneratorAdapter gen =
9.24. COMPILER.JAVA 745
new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
Method.getMethod("void load ()"),
null,
null,
cv);
gen.visitCode();
for(Object r =
LispReader.read(pushbackReader, false, EOF, false);
r != EOF;
r = LispReader.read(pushbackReader, false, EOF, false))
{
LINE_AFTER.set(pushbackReader.getLineNumber());
compile1(gen, objx, r);
LINE_BEFORE.set(pushbackReader.getLineNumber());
}
//end of load
gen.returnValue();
gen.endMethod();
//static fields for constants
for(int i = 0; i < objx.constants.count(); i++)
{
cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
objx.constantName(i),
objx.constantType(i).getDescriptor(),
null, null);
}
final int INITS_PER = 100;
int numInits = objx.constants.count() / INITS_PER;
if(objx.constants.count() % INITS_PER != 0)
++numInits;
for(int n = 0;n<numInits;n++)
{
GeneratorAdapter clinitgen =
new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
Method.getMethod("void __init" + n + "()"),
null,
null,
cv);
clinitgen.visitCode();
try
{
Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T));
for(int i = n*INITS_PER;
i < objx.constants.count() &&
i < (n+1)*INITS_PER;
746 CHAPTER 9. JVM/CLOJURE/LANG/
i++)
{
objx.emitValue(objx.constants.nth(i), clinitgen);
clinitgen.checkCast(objx.constantType(i));
clinitgen.putStatic(
objx.objtype,
objx.constantName(i),
objx.constantType(i));
}
}
finally
{
Var.popThreadBindings();
}
clinitgen.returnValue();
clinitgen.endMethod();
}
//static init for constants, keywords and vars
GeneratorAdapter clinitgen =
new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
Method.getMethod("void <clinit> ()"),
null,
null,
cv);
clinitgen.visitCode();
Label startTry = clinitgen.newLabel();
Label endTry = clinitgen.newLabel();
Label end = clinitgen.newLabel();
Label finallyLabel = clinitgen.newLabel();
// if(objx.constants.count() > 0)
// {
// objx.emitConstants(clinitgen);
// }
for(int n = 0;n<numInits;n++)
clinitgen.invokeStatic(
objx.objtype,
Method.getMethod("void __init" + n + "()"));
clinitgen.invokeStatic(Type.getType(Compiler.class) ,
Method.getMethod("void pushNS()"));
clinitgen.mark(startTry);
clinitgen.invokeStatic(objx.objtype,
Method.getMethod("void load()"));
clinitgen.mark(endTry);
clinitgen.invokeStatic(VAR_TYPE,
Method.getMethod("void popThreadBindings()"));
clinitgen.goTo(end);
9.24. COMPILER.JAVA 747
clinitgen.mark(finallyLabel);
//exception should be on stack
clinitgen.invokeStatic(VAR_TYPE,
Method.getMethod("void popThreadBindings()"));
clinitgen.throwException();
clinitgen.mark(end);
clinitgen.visitTryCatchBlock(startTry, endTry,
finallyLabel, null);
//end of static init
clinitgen.returnValue();
clinitgen.endMethod();
//end of class
cv.visitEnd();
writeClassFile(objx.internalName, cw.toByteArray());
}
catch(LispReader.ReaderException e)
{
throw new CompilerException(sourcePath, e.line, e.getCa use());
}
finally
{
Var.popThreadBindings();
}
return ret;
}
static public class NewInstanceExpr extends ObjExpr{
//IPersistentMap optionsMap = PersistentArrayMap.EMPTY ;
IPersistentCollection methods;
Map<IPersistentVector,java.lang.reflect.Method> mmap ;
Map<IPersistentVector,Set<Class>> covariants;
public NewInstanceExpr(Object tag){
super(tag);
}
static class DeftypeParser implements IParser{
public Expr parse(C context, final Object frm) throws Excep tion{
ISeq rform = (ISeq) frm;
//(deftype* tagname classname [fields]
// :implements [interfaces] :tag tagname methods*)
rform = RT.next(rform);
String tagname = ((Symbol) rform.first()).toString();
rform = rform.next();
Symbol classname = (Symbol) rform.first();
748 CHAPTER 9. JVM/CLOJURE/LANG/
rform = rform.next();
IPersistentVector fields = (IPersistentVector) rform.fi rst();
rform = rform.next();
IPersistentMap opts = PersistentHashMap.EMPTY;
while(rform != null && rform.first() instanceof Keyword)
{
opts = opts.assoc(rform.first(), RT.second(rform));
rform = rform.next().next();
}
ObjExpr ret =
build((IPersistentVector)RT.get(opts,implementsKey,
PersistentVector.EMPTY),fields,null,tagname,
classname, (Symbol) RT.get(opts,RT.TAG_KEY),
rform, frm);
return ret;
}
}
static class ReifyParser implements IParser{
public Expr parse(C context, Object frm) throws Exception{
//(reify this-name? [interfaces] (method-name [args] bod y)*)
ISeq form = (ISeq) frm;
ObjMethod enclosingMethod = (ObjMethod) METHOD.deref();
String basename = enclosingMethod != null ?
(trimGenID(enclosingMethod.objx.name) + "$")
: (munge(currentNS().name.name) + "$");
String simpleName = "reify__" + RT.nextID();
String classname = basename + simpleName;
ISeq rform = RT.next(form);
IPersistentVector interfaces =
((IPersistentVector) RT.first(rform))
.cons(Symbol.intern("clojure.lang.IObj"));
rform = RT.next(rform);
ObjExpr ret =
build(interfaces, null, null, classname,
Symbol.intern(classname), null, rform, frm);
if(frm instanceof IObj && ((IObj) frm).meta() != null)
return new MetaExpr(ret, MapExpr
.parse(context == C.EVAL
? context
: C.EXPRESSION, ((IObj) frm).meta()));
else
return ret;
9.24. COMPILER.JAVA 749
}
}
static ObjExpr build(IPersistentVector interfaceSyms,
IPersistentVector fieldSyms,
Symbol thisSym,
String tagName, Symbol className,
Symbol typeTag, ISeq methodForms, Object frm)
throws Exception{
NewInstanceExpr ret = new NewInstanceExpr(null);
ret.src = frm;
ret.name = className.toString();
ret.classMeta = RT.meta(className);
ret.internalName = ret.name.replace(’.’, ’/’);
ret.objtype = Type.getObjectType(ret.internalName);
if(thisSym != null)
ret.thisName = thisSym.name;
if(fieldSyms != null)
{
IPersistentMap fmap = PersistentHashMap.EMPTY;
Object[] closesvec = new Object[2 * fieldSyms.count()];
for(int i=0;i<fieldSyms.count();i++)
{
Symbol sym = (Symbol) fieldSyms.nth(i);
LocalBinding lb = new LocalBinding(-1, sym, null,
new MethodParamExpr(tagClass(tagOf(sym))),
false,null);
fmap = fmap.assoc(sym, lb);
closesvec[i*2] = lb;
closesvec[i*2 + 1] = lb;
}
//todo - inject __meta et al into closes - when?
//use array map to preserve ctor order
ret.closes = new PersistentArrayMap(closesvec);
ret.fields = fmap;
for(int i=fieldSyms.count()-1;i >= 0 &&
((Symbol)fieldSyms.nth(i)).name.startsWith("__");-- i)
ret.altCtorDrops++;
}
//todo - set up volatiles
// ret.volatiles =
// PersistentHashSet.create(
// RT.seq(RT.get(ret.optionsMap, volatileKey)));
PersistentVector interfaces = PersistentVector.EMPTY;
for(ISeq s = RT.seq(interfaceSyms);s!=null;s = s.next())
750 CHAPTER 9. JVM/CLOJURE/LANG/
{
Class c = (Class) resolve((Symbol) s.first());
if(!c.isInterface())
throw new IllegalArgumentException(
"only interfaces are supported, had: " + c.getName());
interfaces = interfaces.cons(c);
}
Class superClass = Object.class;
Map[] mc = gatherMethods(superClass,RT.seq(interfaces) );
Map overrideables = mc[0];
Map covariants = mc[1];
ret.mmap = overrideables;
ret.covariants = covariants;
String[] inames = interfaceNames(interfaces);
Class stub = compileStub(slashname(superClass),ret, ina mes, frm);
Symbol thistag = Symbol.intern(null,stub.getName());
try
{
Var.pushThreadBindings(
RT.map(CONSTANTS, PersistentVector.EMPTY,
CONSTANT_IDS, new IdentityHashMap(),
KEYWORDS, PersistentHashMap.EMPTY,
VARS, PersistentHashMap.EMPTY,
KEYWORD_CALLSITES, PersistentVector.EMPTY,
PROTOCOL_CALLSITES, PersistentVector.EMPTY,
VAR_CALLSITES, emptyVarCallSites(),
NO_RECUR, null));
if(ret.isDeftype())
{
Var.pushThreadBindings(RT.map(METHOD, null,
LOCAL_ENV, ret.fields
, COMPILE_STUB_SYM, Symbol.intern(null, tagName)
, COMPILE_STUB_CLASS, stub));
}
//now (methodname [args] body)*
ret.line = (Integer) LINE.deref();
IPersistentCollection methods = null;
for(ISeq s = methodForms; s != null; s = RT.next(s))
{
NewInstanceMethod m =
NewInstanceMethod.parse(ret, (ISeq) RT.first(s),
thistag, overrideables);
methods = RT.conj(methods, m);
}
9.24. COMPILER.JAVA 751
ret.methods = methods;
ret.keywords = (IPersistentMap) KEYWORDS.deref();
ret.vars = (IPersistentMap) VARS.deref();
ret.constants = (PersistentVector) CONSTANTS.deref();
ret.constantsID = RT.nextID();
ret.keywordCallsites =
(IPersistentVector) KEYWORD_CALLSITES.deref();
ret.protocolCallsites =
(IPersistentVector) PROTOCOL_CALLSITES.deref();
ret.varCallsites = (IPersistentSet) VAR_CALLSITES.dere f();
}
finally
{
if(ret.isDeftype())
Var.popThreadBindings();
Var.popThreadBindings();
}
ret.compile(slashname(superClass),inames,false);
ret.getCompiledClass();
return ret;
}
/***
* Current host interop uses reflection, which requires
* pre-existing classes. Work around this by:
* Generate a stub class that has the same interfaces and field s
* as the class we are generating.
* Use it as a type hint for this, and bind the simple name of
* the class to this stub (in resolve etc)
* Unmunge the name (using a magic prefix) on any code gen
* for classes
*/
static Class compileStub(String superName,
NewInstanceExpr ret,
String[] interfaceNames,
Object frm){
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MA XS);
ClassVisitor cv = cw;
cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER,
COMPILE_STUB_PREFIX + "/" + ret.internalName,
null,superName,interfaceNames);
//instance fields for closed-overs
for(ISeq s = RT.keys(ret.closes); s != null; s = s.next())
{
LocalBinding lb = (LocalBinding) s.first();
int access =
ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :
ret.isMutable(lb) ? 0 :
752 CHAPTER 9. JVM/CLOJURE/LANG/
ACC_FINAL);
if(lb.getPrimitiveType() != null)
cv.visitField(access,
lb.name,
Type.getType(lb.getPrimitiveType())
.getDescriptor(),
null, null);
else
//todo - when closed-overs are fields, use more specific
// types here and in ctor and emitLocal?
cv.visitField(access,
lb.name, OBJECT_TYPE.getDescriptor(), null, null);
}
//ctor that takes closed-overs and does nothing
Method m = new Method("<init>",
Type.VOID_TYPE, ret.ctorTypes());
GeneratorAdapter ctorgen =
new GeneratorAdapter(ACC_PUBLIC,
m,
null,
null,
cv);
ctorgen.visitCode();
ctorgen.loadThis();
ctorgen.invokeConstructor(Type.getObjectType(superN ame),
voidctor);
ctorgen.returnValue();
ctorgen.endMethod();
if(ret.altCtorDrops > 0)
{
Type[] ctorTypes = ret.ctorTypes();
Type[] altCtorTypes =
new Type[ctorTypes.length-ret.altCtorDrops];
for(int i=0;i<altCtorTypes.length;i++)
altCtorTypes[i] = ctorTypes[i];
Method alt = new Method("<init>",
Type.VOID_TYPE, altCtorTypes);
ctorgen = new GeneratorAdapter(ACC_PUBLIC,
alt,
null,
null,
cv);
ctorgen.visitCode();
ctorgen.loadThis();
ctorgen.loadArgs();
for(int i=0;i<ret.altCtorDrops;i++)
ctorgen.visitInsn(Opcodes.ACONST_NULL);
9.24. COMPILER.JAVA 753
ctorgen.invokeConstructor(
Type.getObjectType(
COMPILE_STUB_PREFIX + "/" + ret.internalName),
new Method("<init>", Type.VOID_TYPE, ctorTypes));
ctorgen.returnValue();
ctorgen.endMethod();
}
//end of class
cv.visitEnd();
byte[] bytecode = cw.toByteArray();
DynamicClassLoader loader = (DynamicClassLoader) LOADER .deref();
return loader.defineClass(
COMPILE_STUB_PREFIX + "." + ret.name,
bytecode, frm);
}
static String[] interfaceNames(IPersistentVector inter faces){
int icnt = interfaces.count();
String[] inames = icnt > 0 ? new String[icnt] : null;
for(int i=0;i<icnt;i++)
inames[i] = slashname((Class) interfaces.nth(i));
return inames;
}
static String slashname(Class c){
return c.getName().replace(’.’, ’/’);
}
protected void emitMethods(ClassVisitor cv){
for(ISeq s = RT.seq(methods); s != null; s = s.next())
{
ObjMethod method = (ObjMethod) s.first();
method.emit(this, cv);
}
//emit bridge methods
for(Map.Entry<IPersistentVector,Set<Class>> e
: covariants.entrySet())
{
java.lang.reflect.Method m = mmap.get(e.getKey());
Class[] params = m.getParameterTypes();
Type[] argTypes = new Type[params.length];
for(int i = 0; i < params.length; i++)
{
argTypes[i] = Type.getType(params[i]);
}
754 CHAPTER 9. JVM/CLOJURE/LANG/
Method target =
new Method(m.getName(),
Type.getType(m.getReturnType()),
argTypes);
for(Class retType : e.getValue())
{
Method meth =
new Method(m.getName(),
Type.getType(retType),
argTypes);
GeneratorAdapter gen =
new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE,
meth,
null,
//todo don’t hardwire this
EXCEPTION_TYPES,
cv);
gen.visitCode();
gen.loadThis();
gen.loadArgs();
gen.invokeInterface(
Type.getType(m.getDeclaringClass()),target);
gen.returnValue();
gen.endMethod();
}
}
}
static public IPersistentVector msig(java.lang.reflect .Method m){
return
RT.vector(m.getName(),
RT.seq(m.getParameterTypes()),
m.getReturnType());
}
static void considerMethod(java.lang.reflect.Method m, Map mm){
IPersistentVector mk = msig(m);
int mods = m.getModifiers();
if(!(mm.containsKey(mk)
|| !(Modifier.isPublic(mods) || Modifier.isProtected(m ods))
|| Modifier.isStatic(mods)
|| Modifier.isFinal(mods)))
{
mm.put(mk, m);
}
}
9.24. COMPILER.JAVA 755
static void gatherMethods(Class c, Map mm){
for(; c != null; c = c.getSuperclass())
{
for(java.lang.reflect.Method m : c.getDeclaredMethods( ))
considerMethod(m, mm);
for(java.lang.reflect.Method m : c.getMethods())
considerMethod(m, mm);
}
}
static public Map[] gatherMethods(Class sc, ISeq interfac es){
Map allm = new HashMap();
gatherMethods(sc, allm);
for(; interfaces != null; interfaces = interfaces.next())
gatherMethods((Class) interfaces.first(), allm);
Map<IPersistentVector,java.lang.reflect.Method> mm =
new HashMap<IPersistentVector,java.lang.reflect.Meth od>();
Map<IPersistentVector,Set<Class>> covariants =
new HashMap<IPersistentVector,Set<Class>>();
for(Object o : allm.entrySet())
{
Map.Entry e = (Map.Entry) o;
IPersistentVector mk = (IPersistentVector) e.getKey();
mk = (IPersistentVector) mk.pop();
java.lang.reflect.Method m =
(java.lang.reflect.Method) e.getValue();
if(mm.containsKey(mk)) //covariant return
{
Set<Class> cvs = covariants.get(mk);
if(cvs == null)
{
cvs = new HashSet<Class>();
covariants.put(mk,cvs);
}
java.lang.reflect.Method om = mm.get(mk);
if(om.getReturnType()
.isAssignableFrom(m.getReturnType()))
{
cvs.add(om.getReturnType());
mm.put(mk, m);
}
else
cvs.add(m.getReturnType());
}
else
mm.put(mk, m);
}
return new Map[]{mm,covariants};
756 CHAPTER 9. JVM/CLOJURE/LANG/
}
}
public static class NewInstanceMethod extends ObjMethod{
String name;
Type[] argTypes;
Type retType;
Class retClass;
Class[] exclasses;
static Symbol dummyThis =
Symbol.intern(null,"dummy_this_dlskjsdfower");
private IPersistentVector parms;
public NewInstanceMethod(ObjExpr objx, ObjMethod parent ){
super(objx, parent);
}
int numParams(){
return argLocals.count();
}
String getMethodName(){
return name;
}
Type getReturnType(){
return retType;
}
Type[] getArgTypes(){
return argTypes;
}
static public IPersistentVector msig(String name,
Class[] paramTypes){
return RT.vector(name,RT.seq(paramTypes));
}
static NewInstanceMethod parse(ObjExpr objx, ISeq form,
Symbol thistag,
Map overrideables)
throws Exception{
//(methodname [this-name args*] body...)
//this-name might be nil
NewInstanceMethod method =
new NewInstanceMethod(objx, (ObjMethod) METHOD.deref() );
Symbol dotname = (Symbol)RT.first(form);
9.24. COMPILER.JAVA 757
Symbol name =
(Symbol) Symbol.intern(null,
munge(dotname.name))
.withMeta(RT.meta(dotname));
IPersistentVector parms = (IPersistentVector) RT.second (form);
if(parms.count() == 0)
{
throw new IllegalArgumentException(
"Must supply at least one argument for ’this’ in: " + dotname) ;
}
Symbol thisName = (Symbol) parms.nth(0);
parms = RT.subvec(parms,1,parms.count());
ISeq body = RT.next(RT.next(form));
try
{
method.line = (Integer) LINE.deref();
//register as the current method and set up a new env frame
PathNode pnode =
new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get( ));
Var.pushThreadBindings(
RT.map(
METHOD, method,
LOCAL_ENV, LOCAL_ENV.deref(),
LOOP_LOCALS, null,
NEXT_LOCAL_NUM, 0
,CLEAR_PATH, pnode
,CLEAR_ROOT, pnode
,CLEAR_SITES, PersistentHashMap.EMPTY
));
//register ’this’ as local 0
if(thisName != null)
registerLocal((thisName == null)
? dummyThis
: thisName,thistag, null,false);
else
getAndIncLocalNum();
PersistentVector argLocals = PersistentVector.EMPTY;
method.retClass = tagClass(tagOf(name));
method.argTypes = new Type[parms.count()];
boolean hinted = tagOf(name) != null;
Class[] pclasses = new Class[parms.count()];
Symbol[] psyms = new Symbol[parms.count()];
for(int i = 0; i < parms.count(); i++)
{
if(!(parms.nth(i) instanceof Symbol))
throw new IllegalArgumentException(
"params must be Symbols");
758 CHAPTER 9. JVM/CLOJURE/LANG/
Symbol p = (Symbol) parms.nth(i);
Object tag = tagOf(p);
if(tag != null)
hinted = true;
if(p.getNamespace() != null)
p = Symbol.intern(p.name);
Class pclass = tagClass(tag);
pclasses[i] = pclass;
psyms[i] = p;
}
Map matches =
findMethodsWithNameAndArity(name.name,
parms.count(),
overrideables);
Object mk = msig(name.name, pclasses);
java.lang.reflect.Method m = null;
if(matches.size() > 0)
{
//multiple methods
if(matches.size() > 1)
{
//must be hinted and match one method
if(!hinted)
throw new IllegalArgumentException(
"Must hint overloaded method: " + name.name);
m = (java.lang.reflect.Method) matches.get(mk);
if(m == null)
throw new IllegalArgumentException(
"Can’t find matching overloaded method: " + name.name);
if(m.getReturnType() != method.retClass)
throw new IllegalArgumentException(
"Mismatched return type: " + name.name +
", expected: " + m.getReturnType().getName() +
", had: " + method.retClass.getName());
}
else //one match
{
//if hinted, validate match,
if(hinted)
{
m = (java.lang.reflect.Method) matches.get(mk);
if(m == null)
throw new IllegalArgumentException(
"Can’t find matching method: " + name.name +
", leave off hints for auto match.");
if(m.getReturnType() != method.retClass)
throw new IllegalArgumentException(
"Mismatched return type: " + name.name +
", expected: " +
m.getReturnType().getName() +
9.24. COMPILER.JAVA 759
", had: " + method.retClass.getName());
}
else //adopt found method sig
{
m = (java.lang.reflect.Method)
matches.values().iterator().next();
method.retClass = m.getReturnType();
pclasses = m.getParameterTypes();
}
}
}
// else if(findMethodsWithName(name.name,allmethods). size()>0)
// throw new IllegalArgumentException(
// "Can’t override/overload method: " + name.name);
else
throw new IllegalArgumentException(
"Can’t define method not in interfaces: " + name.name);
//else
//validate unque name+arity among additional methods
method.retType = Type.getType(method.retClass);
method.exclasses = m.getExceptionTypes();
for(int i = 0; i < parms.count(); i++)
{
LocalBinding lb =
registerLocal(psyms[i],
null,
new MethodParamExpr(pclasses[i]),true);
argLocals = argLocals.assocN(i,lb);
method.argTypes[i] = Type.getType(pclasses[i]);
}
for(int i = 0; i < parms.count(); i++)
{
if(pclasses[i] == long.class ||
pclasses[i] == double.class)
getAndIncLocalNum();
}
LOOP_LOCALS.set(argLocals);
method.name = name.name;
method.methodMeta = RT.meta(name);
method.parms = parms;
method.argLocals = argLocals;
method.body = (new BodyExpr.Parser()).parse(C.RETURN, b ody);
return method;
}
finally
{
Var.popThreadBindings();
760 CHAPTER 9. JVM/CLOJURE/LANG/
}
}
private static Map findMethodsWithNameAndArity(String n ame,
int arity,
Map mm){
Map ret = new HashMap();
for(Object o : mm.entrySet())
{
Map.Entry e = (Map.Entry) o;
java.lang.reflect.Method m =
(java.lang.reflect.Method) e.getValue();
if(name.equals(m.getName()) &&
m.getParameterTypes().length == arity)
ret.put(e.getKey(), e.getValue());
}
return ret;
}
private static Map findMethodsWithName(String name, Map m m){
Map ret = new HashMap();
for(Object o : mm.entrySet())
{
Map.Entry e = (Map.Entry) o;
java.lang.reflect.Method m =
(java.lang.reflect.Method) e.getValue();
if(name.equals(m.getName()))
ret.put(e.getKey(), e.getValue());
}
return ret;
}
public void emit(ObjExpr obj, ClassVisitor cv){
Method m =
new Method(getMethodName(), getReturnType(), getArgTyp es());
Type[] extypes = null;
if(exclasses.length > 0)
{
extypes = new Type[exclasses.length];
for(int i=0;i<exclasses.length;i++)
extypes[i] = Type.getType(exclasses[i]);
}
GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
m,
null,
extypes,
cv);
addAnnotation(gen,methodMeta);
for(int i = 0; i < parms.count(); i++)
9.24. COMPILER.JAVA 761
{
IPersistentMap meta = RT.meta(parms.nth(i));
addParameterAnnotation(gen, meta, i);
}
gen.visitCode();
Label loopLabel = gen.mark();
gen.visitLineNumber(line, loopLabel);
try
{
Var.pushThreadBindings(
RT.map(LOOP_LABEL, loopLabel, METHOD, this));
emitBody(objx, gen, retClass, body);
Label end = gen.mark();
gen.visitLocalVariable("this",
obj.objtype.getDescriptor(),
null, loopLabel, end, 0);
for(ISeq lbs = argLocals.seq();
lbs != null;
lbs = lbs.next())
{
LocalBinding lb = (LocalBinding) lbs.first();
gen.visitLocalVariable(lb.name,
argTypes[lb.idx-1]
.getDescriptor(),
null,
loopLabel, end, lb.idx);
}
}
catch(Exception e)
{
throw new RuntimeException(e);
}
finally
{
Var.popThreadBindings();
}
gen.returnValue();
//gen.visitMaxs(1, 1);
gen.endMethod();
}
}
static Class primClass(Symbol sym){
if(sym == null)
return null;
Class c = null;
762 CHAPTER 9. JVM/CLOJURE/LANG/
if(sym.name.equals("int"))
c = int.class;
else if(sym.name.equals("long"))
c = long.class;
else if(sym.name.equals("float"))
c = float.class;
else if(sym.name.equals("double"))
c = double.class;
else if(sym.name.equals("char"))
c = char.class;
else if(sym.name.equals("short"))
c = short.class;
else if(sym.name.equals("byte"))
c = byte.class;
else if(sym.name.equals("boolean"))
c = boolean.class;
else if(sym.name.equals("void"))
c = void.class;
return c;
}
static Class tagClass(Object tag) throws Exception{
if(tag == null)
return Object.class;
Class c = null;
if(tag instanceof Symbol)
c = primClass((Symbol) tag);
if(c == null)
c = HostExpr.tagToClass(tag);
return c;
}
static Class primClass(Class c){
return c.isPrimitive()?c:Object.class;
}
static public class MethodParamExpr
implements Expr, MaybePrimitiveExpr{
final Class c;
public MethodParamExpr(Class c){
this.c = c;
}
public Object eval() throws Exception{
throw new Exception("Can’t eval");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
throw new RuntimeException("Can’t emit");
9.24. COMPILER.JAVA 763
}
public boolean hasJavaClass() throws Exception{
return c != null;
}
public Class getJavaClass() throws Exception{
return c;
}
public boolean canEmitPrimitive(){
return Util.isPrimitive(c);
}
public void emitUnboxed(C context,
ObjExpr objx,
GeneratorAdapter gen){
throw new RuntimeException("Can’t emit");
}
}
public static class CaseExpr extends UntypedExpr{
public final LocalBindingExpr expr;
public final int shift, mask, low, high;
public final Expr defaultExpr;
public final HashMap<Integer,Expr> tests;
public final HashMap<Integer,Expr> thens;
public final boolean allKeywords;
public final int line;
final static Method hashMethod =
Method.getMethod("int hash(Object)");
final static Method hashCodeMethod =
Method.getMethod("int hashCode()");
final static Method equalsMethod =
Method.getMethod("boolean equals(Object, Object)");
public CaseExpr(int line, LocalBindingExpr expr, int shif t,
int mask, int low, int high, Expr defaultExpr,
HashMap<Integer,Expr> tests,
HashMap<Integer,Expr> thens,
boolean allKeywords){
this.expr = expr;
this.shift = shift;
this.mask = mask;
this.low = low;
this.high = high;
this.defaultExpr = defaultExpr;
764 CHAPTER 9. JVM/CLOJURE/LANG/
this.tests = tests;
this.thens = thens;
this.line = line;
this.allKeywords = allKeywords;
}
public Object eval() throws Exception{
throw new UnsupportedOperationException("Can’t eval cas e");
}
public void emit(C context, ObjExpr objx, GeneratorAdapte r gen){
Label defaultLabel = gen.newLabel();
Label endLabel = gen.newLabel();
HashMap<Integer,Label> labels = new HashMap();
for(Integer i : tests.keySet())
{
labels.put(i, gen.newLabel());
}
Label[] la = new Label[(high-low)+1];
for(int i=low;i<=high;i++)
{
la[i-low] = labels.containsKey(i)
? labels.get(i)
: defaultLabel;
}
gen.visitLineNumber(line, gen.mark());
expr.emit(C.EXPRESSION, objx, gen);
gen.invokeStatic(UTIL_TYPE,hashMethod);
gen.push(shift);
gen.visitInsn(ISHR);
gen.push(mask);
gen.visitInsn(IAND);
gen.visitTableSwitchInsn(low, high, defaultLabel, la);
for(Integer i : labels.keySet())
{
gen.mark(labels.get(i));
expr.emit(C.EXPRESSION, objx, gen);
tests.get(i).emit(C.EXPRESSION, objx, gen);
if(allKeywords)
{
gen.visitJumpInsn(IF_ACMPNE, defaultLabel);
}
else
{
gen.invokeStatic(UTIL_TYPE, equalsMethod);
9.24. COMPILER.JAVA 765
gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel);
}
thens.get(i).emit(C.EXPRESSION,objx,gen);
gen.goTo(endLabel);
}
gen.mark(defaultLabel);
defaultExpr.emit(C.EXPRESSION, objx, gen);
gen.mark(endLabel);
if(context == C.STATEMENT)
gen.pop();
}
static class Parser implements IParser{
//(case* expr shift mask low high default
// map<minhash, [test then]> identity?)
//prepared by case macro and presumed correct
//case macro binds actual expr in let so expr is always a local ,
//no need to worry about multiple evaluation
public Expr parse(C context, Object frm) throws Exception{
ISeq form = (ISeq) frm;
if(context == C.EVAL)
return
analyze(context,
RT.list(
RT.list(FN, PersistentVector.EMPTY, form)));
PersistentVector args = PersistentVector.create(form.n ext());
HashMap<Integer,Expr> tests = new HashMap();
HashMap<Integer,Expr> thens = new HashMap();
LocalBindingExpr testexpr =
(LocalBindingExpr) analyze(C.EXPRESSION, args.nth(0)) ;
testexpr.shouldClear = false;
PathNode branch =
new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.ge t());
for(Object o : ((Map)args.nth(6)).entrySet())
{
Map.Entry e = (Map.Entry) o;
Integer minhash = ((Number)e.getKey()).intValue();
MapEntry me = (MapEntry) e.getValue();
Expr testExpr = new ConstantExpr(me.getKey());
tests.put(minhash, testExpr);
Expr thenExpr;
try {
Var.pushThreadBindings(
RT.map(CLEAR_PATH,
new PathNode(PATHTYPE.PATH,branch)));
thenExpr = analyze(context, me.getValue());
}
766 CHAPTER 9. JVM/CLOJURE/LANG/
finally{
Var.popThreadBindings();
}
thens.put(minhash, thenExpr);
}
Expr defaultExpr;
try {
Var.pushThreadBindings(
RT.map(CLEAR_PATH,
new PathNode(PATHTYPE.PATH,branch)));
defaultExpr = analyze(context, args.nth(5));
}
finally{
Var.popThreadBindings();
}
return new CaseExpr(((Number)LINE.deref()).intValue() ,
testexpr,
((Number)args.nth(1)).intValue(),
((Number)args.nth(2)).intValue(),
((Number)args.nth(3)).intValue(),
((Number)args.nth(4)).intValue(),
defaultExpr,
tests,thens,args.nth(7) != RT.F);
}
}
}
static IPersistentCollection emptyVarCallSites(){
return PersistentHashSet.EMPTY;}
}
———-
9.25 Cons.java
(ASeq [571]) (Serializable [1723])
— Cons.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 25, 2006 11:01:29 AM */
package clojure.lang;
9.25. CONS.JAVA 767
import java.io.Serializable;
final public class Cons extends ASeq implements Serializab le {
private final Object _first;
private final ISeq _more;
public Cons(Object first, ISeq _more){
this._first = first;
this._more = _more;
}
public Cons(IPersistentMap meta, Object _first, ISeq _mor e){
super(meta);
this._first = _first;
this._more = _more;
}
public Object first(){
return _first;
}
public ISeq next(){
return more().seq();
}
public ISeq more(){
if(_more == null)
return PersistentList.EMPTY;
return _more;
}
public int count(){
return 1 + RT.count(_more);
}
public Cons withMeta(IPersistentMap meta){
return new Cons(meta, _first, _more);
}
}
———-
768 CHAPTER 9. JVM/CLOJURE/LANG/
9.26 Counted.java
— Counted.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
/* A class that implements Counted promises that it is a colle ction
* that implement a constant-time count() */
public interface Counted {
int count();
}
———-
9.27 Delay.java
(IDeref [773])
— Delay.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jun 28, 2007 */
package clojure.lang;
public class Delay implements IDeref{
Object val;
IFn fn;
public Delay(IFn fn){
this.fn = fn;
this.val = null;
}
static public Object force(Object x) throws Exception{
return (x instanceof Delay) ?
((Delay) x).deref()
: x;
}
synchronized public Object deref() throws Exception{
9.28. DYNAMICCLASSLOADER.JAVA 769
if(fn != null)
{
val = fn.invoke();
fn = null;
}
return val;
}
}
———-
9.28 DynamicClassLoader.java
(URLClassLoader [1723])
— DynamicClassLoader.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Aug 21, 2007 */
package clojure.lang;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.net.URLClassLoader;
import java.net.URL;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
public class DynamicClassLoader extends URLClassLoader{
HashMap<Integer, Object[]> constantVals =
new HashMap<Integer, Object[]>();
static ConcurrentHashMap<String, SoftReference<Class> >classCache =
new ConcurrentHashMap<String, SoftReference<Class> >() ;
static final URL[] EMPTY_URLS = new URL[]{};
static final ReferenceQueue rq = new ReferenceQueue();
public DynamicClassLoader(){
//pseudo test in lieu of hasContextClassLoader()
super(EMPTY_URLS,
(Thread.currentThread().getContextClassLoader() == nu ll ||
Thread.currentThread().getContextClassLoader() ==
ClassLoader.getSystemClassLoader())
? Compiler.class.getClassLoader()
770 CHAPTER 9. JVM/CLOJURE/LANG/
: Thread.currentThread().getContextClassLoader());
}
public DynamicClassLoader(ClassLoader parent){
super(EMPTY_URLS,parent);
}
public Class defineClass(String name, byte[] bytes, Objec t srcForm){
Util.clearCache(rq, classCache);
Class c = defineClass(name, bytes, 0, bytes.length);
classCache.put(name, new SoftReference(c,rq));
return c;
}
protected Class<?> findClass(String name)
throws ClassNotFoundException{
SoftReference<Class> cr = classCache.get(name);
if(cr != null)
{
Class c = cr.get();
if(c != null)
return c;
else
classCache.remove(name, cr);
}
return super.findClass(name);
}
public void registerConstants(int id, Object[] val){
constantVals.put(id, val);
}
public Object[] getConstants(int id){
return constantVals.get(id);
}
public void addURL(URL url){
super.addURL(url);
}
}
———-
9.29 EnumerationSeq.java
(ASeq [571])
— EnumerationSeq.java —
9.29. ENUMERATIONSEQ.JAVA 771
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
import java.io.IOException;
import java.io.NotSerializableException;
import java.util.Enumeration;
public class EnumerationSeq extends ASeq{
final Enumeration iter;
final State state;
static class State{
volatile Object val;
volatile Object _rest;
}
public static EnumerationSeq create(Enumeration iter){
if(iter.hasMoreElements())
return new EnumerationSeq(iter);
return null;
}
EnumerationSeq(Enumeration iter){
this.iter = iter;
state = new State();
this.state.val = state;
this.state._rest = state;
}
EnumerationSeq(IPersistentMap meta, Enumeration iter, S tate state){
super(meta);
this.iter = iter;
this.state = state;
}
public Object first(){
if(state.val == state)
synchronized(state)
{
if(state.val == state)
state.val = iter.nextElement();
}
return state.val;
}
public ISeq next(){
772 CHAPTER 9. JVM/CLOJURE/LANG/
if(state._rest == state)
synchronized(state)
{
if(state._rest == state)
{
first();
state._rest = create(iter);
}
}
return (ISeq) state._rest;
}
public EnumerationSeq withMeta(IPersistentMap meta){
return new EnumerationSeq(meta, iter, state);
}
private void writeObject (java.io.ObjectOutputStream ou t)
throws IOException {
throw new NotSerializableException(getClass().getName ());
}
}
———-
9.30 Fn.java
— Fn.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 25, 2008 */
package clojure.lang;
public interface Fn{
}
———-
9.31 IChunk.java
(Indexed [799])
— IChunk.java —
9.32. ICHUNKEDSEQ.JAVA 773
/*
\getchunk{Clojure Copyright}
*/
/* rich Jun 18, 2009 */
package clojure.lang;
public interface IChunk extends Indexed{
IChunk dropFirst();
Object reduce(IFn f, Object start) throws Exception;
}
———-
9.32 IChunkedSeq.java
(ISeq [805])
— IChunkedSeq.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 24, 2009 */
package clojure.lang;
public interface IChunkedSeq extends ISeq{
IChunk chunkedFirst() throws Exception;
ISeq chunkedNext() throws Exception;
ISeq chunkedMore() throws Exception;
}
———-
9.33 IDeref.java
— IDeref.java —
/*
774 CHAPTER 9. JVM/CLOJURE/LANG/
\getchunk{Clojure Copyright}
*/
/* rich Feb 9, 2009 */
package clojure.lang;
public interface IDeref{
Object deref() throws Exception;
}
———-
9.34 IEditableCollection.java
— IEditableCollection.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 17, 2009 */
package clojure.lang;
public interface IEditableCollection{
ITransientCollection asTransient();
}
———-
9.35 IFn.java
(Callable [1723]) (Runnable [1723])
— IFn.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 25, 2006 3:54:03 PM */
package clojure.lang;
import java.util.concurrent.Callable;
public interface IFn extends Callable, Runnable{
9.35. IFN.JAVA 775
public Object invoke()
throws Exception;
public Object invoke(Object arg1)
throws Exception;
public Object invoke(Object arg1, Object arg2)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception;
776 CHAPTER 9. JVM/CLOJURE/LANG/
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
9.35. IFN.JAVA 777
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception;
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
throws Exception;
public Object applyTo(ISeq arglist) throws Exception;
static public interface
L{long invokePrim();}
static public interface
D{double invokePrim();}
static public interface
OL{long invokePrim(Object arg0);}
static public interface
OD{double invokePrim(Object arg0);}
static public interface
LO{Object invokePrim(long arg0);}
static public interface
LL{long invokePrim(long arg0);}
static public interface
LD{double invokePrim(long arg0);}
static public interface
DO{Object invokePrim(double arg0);}
static public interface
DL{long invokePrim(double arg0);}
static public interface
778 CHAPTER 9. JVM/CLOJURE/LANG/
DD{double invokePrim(double arg0);}
static public interface
OOL{long invokePrim(Object arg0, Object arg1);}
static public interface
OOD{double invokePrim(Object arg0, Object arg1);}
static public interface
OLO{Object invokePrim(Object arg0, long arg1);}
static public interface
OLL{long invokePrim(Object arg0, long arg1);}
static public interface
OLD{double invokePrim(Object arg0, long arg1);}
static public interface
ODO{Object invokePrim(Object arg0, double arg1);}
static public interface
ODL{long invokePrim(Object arg0, double arg1);}
static public interface
ODD{double invokePrim(Object arg0, double arg1);}
static public interface
LOO{Object invokePrim(long arg0, Object arg1);}
static public interface
LOL{long invokePrim(long arg0, Object arg1);}
static public interface
LOD{double invokePrim(long arg0, Object arg1);}
static public interface
LLO{Object invokePrim(long arg0, long arg1);}
static public interface
LLL{long invokePrim(long arg0, long arg1);}
static public interface
LLD{double invokePrim(long arg0, long arg1);}
static public interface
LDO{Object invokePrim(long arg0, double arg1);}
static public interface
LDL{long invokePrim(long arg0, double arg1);}
static public interface
LDD{double invokePrim(long arg0, double arg1);}
static public interface
DOO{Object invokePrim(double arg0, Object arg1);}
static public interface
DOL{long invokePrim(double arg0, Object arg1);}
static public interface
DOD{double invokePrim(double arg0, Object arg1);}
static public interface
DLO{Object invokePrim(double arg0, long arg1);}
static public interface
DLL{long invokePrim(double arg0, long arg1);}
static public interface
DLD{double invokePrim(double arg0, long arg1);}
static public interface
DDO{Object invokePrim(double arg0, double arg1);}
static public interface
9.35. IFN.JAVA 779
DDL{long invokePrim(double arg0, double arg1);}
static public interface
DDD{double invokePrim(double arg0, double arg1);}
static public interface
OOOL{long invokePrim(Object arg0, Object arg1, Object arg 2);}
static public interface
OOOD{double invokePrim(Object arg0, Object arg1, Object a rg2);}
static public interface
OOLO{Object invokePrim(Object arg0, Object arg1, long arg 2);}
static public interface
OOLL{long invokePrim(Object arg0, Object arg1, long arg2) ;}
static public interface
OOLD{double invokePrim(Object arg0, Object arg1, long arg 2);}
static public interface
OODO{Object invokePrim(Object arg0, Object arg1, double a rg2);}
static public interface
OODL{long invokePrim(Object arg0, Object arg1, double arg 2);}
static public interface
OODD{double invokePrim(Object arg0, Object arg1, double a rg2);}
static public interface
OLOO{Object invokePrim(Object arg0, long arg1, Object arg 2);}
static public interface
OLOL{long invokePrim(Object arg0, long arg1, Object arg2) ;}
static public interface
OLOD{double invokePrim(Object arg0, long arg1, Object arg 2);}
static public interface
OLLO{Object invokePrim(Object arg0, long arg1, long arg2) ;}
static public interface
OLLL{long invokePrim(Object arg0, long arg1, long arg2);}
static public interface
OLLD{double invokePrim(Object arg0, long arg1, long arg2) ;}
static public interface
OLDO{Object invokePrim(Object arg0, long arg1, double arg 2);}
static public interface
OLDL{long invokePrim(Object arg0, long arg1, double arg2) ;}
static public interface
OLDD{double invokePrim(Object arg0, long arg1, double arg 2);}
static public interface
ODOO{Object invokePrim(Object arg0, double arg1, Object a rg2);}
static public interface
ODOL{long invokePrim(Object arg0, double arg1, Object arg 2);}
static public interface
ODOD{double invokePrim(Object arg0, double arg1, Object a rg2);}
static public interface
ODLO{Object invokePrim(Object arg0, double arg1, long arg 2);}
static public interface
ODLL{long invokePrim(Object arg0, double arg1, long arg2) ;}
static public interface
ODLD{double invokePrim(Object arg0, double arg1, long arg 2);}
static public interface
780 CHAPTER 9. JVM/CLOJURE/LANG/
ODDO{Object invokePrim(Object arg0, double arg1, double a rg2);}
static public interface
ODDL{long invokePrim(Object arg0, double arg1, double arg 2);}
static public interface
ODDD{double invokePrim(Object arg0, double arg1, double a rg2);}
static public interface
LOOO{Object invokePrim(long arg0, Object arg1, Object arg 2);}
static public interface
LOOL{long invokePrim(long arg0, Object arg1, Object arg2) ;}
static public interface
LOOD{double invokePrim(long arg0, Object arg1, Object arg 2);}
static public interface
LOLO{Object invokePrim(long arg0, Object arg1, long arg2) ;}
static public interface
LOLL{long invokePrim(long arg0, Object arg1, long arg2);}
static public interface
LOLD{double invokePrim(long arg0, Object arg1, long arg2) ;}
static public interface
LODO{Object invokePrim(long arg0, Object arg1, double arg 2);}
static public interface
LODL{long invokePrim(long arg0, Object arg1, double arg2) ;}
static public interface
LODD{double invokePrim(long arg0, Object arg1, double arg 2);}
static public interface
LLOO{Object invokePrim(long arg0, long arg1, Object arg2) ;}
static public interface
LLOL{long invokePrim(long arg0, long arg1, Object arg2);}
static public interface
LLOD{double invokePrim(long arg0, long arg1, Object arg2) ;}
static public interface
LLLO{Object invokePrim(long arg0, long arg1, long arg2);}
static public interface
LLLL{long invokePrim(long arg0, long arg1, long arg2);}
static public interface
LLLD{double invokePrim(long arg0, long arg1, long arg2);}
static public interface
LLDO{Object invokePrim(long arg0, long arg1, double arg2) ;}
static public interface
LLDL{long invokePrim(long arg0, long arg1, double arg2);}
static public interface
LLDD{double invokePrim(long arg0, long arg1, double arg2) ;}
static public interface
LDOO{Object invokePrim(long arg0, double arg1, Object arg 2);}
static public interface
LDOL{long invokePrim(long arg0, double arg1, Object arg2) ;}
static public interface
LDOD{double invokePrim(long arg0, double arg1, Object arg 2);}
static public interface
LDLO{Object invokePrim(long arg0, double arg1, long arg2) ;}
static public interface
9.35. IFN.JAVA 781
LDLL{long invokePrim(long arg0, double arg1, long arg2);}
static public interface
LDLD{double invokePrim(long arg0, double arg1, long arg2) ;}
static public interface
LDDO{Object invokePrim(long arg0, double arg1, double arg 2);}
static public interface
LDDL{long invokePrim(long arg0, double arg1, double arg2) ;}
static public interface
LDDD{double invokePrim(long arg0, double arg1, double arg 2);}
static public interface
DOOO{Object invokePrim(double arg0, Object arg1, Object a rg2);}
static public interface
DOOL{long invokePrim(double arg0, Object arg1, Object arg 2);}
static public interface
DOOD{double invokePrim(double arg0, Object arg1, Object a rg2);}
static public interface
DOLO{Object invokePrim(double arg0, Object arg1, long arg 2);}
static public interface
DOLL{long invokePrim(double arg0, Object arg1, long arg2) ;}
static public interface
DOLD{double invokePrim(double arg0, Object arg1, long arg 2);}
static public interface
DODO{Object invokePrim(double arg0, Object arg1, double a rg2);}
static public interface
DODL{long invokePrim(double arg0, Object arg1, double arg 2);}
static public interface
DODD{double invokePrim(double arg0, Object arg1, double a rg2);}
static public interface
DLOO{Object invokePrim(double arg0, long arg1, Object arg 2);}
static public interface
DLOL{long invokePrim(double arg0, long arg1, Object arg2) ;}
static public interface
DLOD{double invokePrim(double arg0, long arg1, Object arg 2);}
static public interface
DLLO{Object invokePrim(double arg0, long arg1, long arg2) ;}
static public interface
DLLL{long invokePrim(double arg0, long arg1, long arg2);}
static public interface
DLLD{double invokePrim(double arg0, long arg1, long arg2) ;}
static public interface
DLDO{Object invokePrim(double arg0, long arg1, double arg 2);}
static public interface
DLDL{long invokePrim(double arg0, long arg1, double arg2) ;}
static public interface
DLDD{double invokePrim(double arg0, long arg1, double arg 2);}
static public interface
DDOO{Object invokePrim(double arg0, double arg1, Object a rg2);}
static public interface
DDOL{long invokePrim(double arg0, double arg1, Object arg 2);}
static public interface
782 CHAPTER 9. JVM/CLOJURE/LANG/
DDOD{double invokePrim(double arg0, double arg1, Object a rg2);}
static public interface
DDLO{Object invokePrim(double arg0, double arg1, long arg 2);}
static public interface
DDLL{long invokePrim(double arg0, double arg1, long arg2) ;}
static public interface
DDLD{double invokePrim(double arg0, double arg1, long arg 2);}
static public interface
DDDO{Object invokePrim(double arg0, double arg1, double a rg2);}
static public interface
DDDL{long invokePrim(double arg0, double arg1, double arg 2);}
static public interface
DDDD{double invokePrim(double arg0, double arg1, double a rg2);}
static public interface
OOOOL{long invokePrim(Object arg0, Object arg1, Object ar g2,
Object arg3);}
static public interface
OOOOD{double invokePrim(Object arg0, Object arg1, Object arg2,
Object arg3);}
static public interface
OOOLO{Object invokePrim(Object arg0, Object arg1, Object arg2,
long arg3);}
static public interface
OOOLL{long invokePrim(Object arg0, Object arg1, Object ar g2,
long arg3);}
static public interface
OOOLD{double invokePrim(Object arg0, Object arg1, Object arg2,
long arg3);}
static public interface
OOODO{Object invokePrim(Object arg0, Object arg1, Object arg2,
double arg3);}
static public interface
OOODL{long invokePrim(Object arg0, Object arg1, Object ar g2,
double arg3);}
static public interface
OOODD{double invokePrim(Object arg0, Object arg1, Object arg2,
double arg3);}
static public interface
OOLOO{Object invokePrim(Object arg0, Object arg1, long ar g2,
Object arg3);}
static public interface
OOLOL{long invokePrim(Object arg0, Object arg1, long arg2 ,
Object arg3);}
static public interface
OOLOD{double invokePrim(Object arg0, Object arg1, long ar g2,
Object arg3);}
static public interface
OOLLO{Object invokePrim(Object arg0, Object arg1, long ar g2,
long arg3);}
static public interface
9.35. IFN.JAVA 783
OOLLL{long invokePrim(Object arg0, Object arg1, long arg2 ,
long arg3);}
static public interface
OOLLD{double invokePrim(Object arg0, Object arg1, long ar g2,
long arg3);}
static public interface
OOLDO{Object invokePrim(Object arg0, Object arg1, long ar g2,
double arg3);}
static public interface
OOLDL{long invokePrim(Object arg0, Object arg1, long arg2 ,
double arg3);}
static public interface
OOLDD{double invokePrim(Object arg0, Object arg1, long ar g2,
double arg3);}
static public interface
OODOO{Object invokePrim(Object arg0, Object arg1, double arg2,
Object arg3);}
static public interface
OODOL{long invokePrim(Object arg0, Object arg1, double ar g2,
Object arg3);}
static public interface
OODOD{double invokePrim(Object arg0, Object arg1, double arg2,
Object arg3);}
static public interface
OODLO{Object invokePrim(Object arg0, Object arg1, double arg2,
long arg3);}
static public interface
OODLL{long invokePrim(Object arg0, Object arg1, double ar g2,
long arg3);}
static public interface
OODLD{double invokePrim(Object arg0, Object arg1, double arg2,
long arg3);}
static public interface
OODDO{Object invokePrim(Object arg0, Object arg1, double arg2,
double arg3);}
static public interface
OODDL{long invokePrim(Object arg0, Object arg1, double ar g2,
double arg3);}
static public interface
OODDD{double invokePrim(Object arg0, Object arg1, double arg2,
double arg3);}
static public interface
OLOOO{Object invokePrim(Object arg0, long arg1, Object ar g2,
Object arg3);}
static public interface
OLOOL{long invokePrim(Object arg0, long arg1, Object arg2 ,
Object arg3);}
static public interface
OLOOD{double invokePrim(Object arg0, long arg1, Object ar g2,
Object arg3);}
784 CHAPTER 9. JVM/CLOJURE/LANG/
static public interface
OLOLO{Object invokePrim(Object arg0, long arg1, Object ar g2,
long arg3);}
static public interface
OLOLL{long invokePrim(Object arg0, long arg1, Object arg2 ,
long arg3);}
static public interface
OLOLD{double invokePrim(Object arg0, long arg1, Object ar g2,
long arg3);}
static public interface
OLODO{Object invokePrim(Object arg0, long arg1, Object ar g2,
double arg3);}
static public interface
OLODL{long invokePrim(Object arg0, long arg1, Object arg2 ,
double arg3);}
static public interface
OLODD{double invokePrim(Object arg0, long arg1, Object ar g2,
double arg3);}
static public interface
OLLOO{Object invokePrim(Object arg0, long arg1, long arg2 ,
Object arg3);}
static public interface
OLLOL{long invokePrim(Object arg0, long arg1, long arg2,
Object arg3);}
static public interface
OLLOD{double invokePrim(Object arg0, long arg1, long arg2 ,
Object arg3);}
static public interface
OLLLO{Object invokePrim(Object arg0, long arg1, long arg2 ,
long arg3);}
static public interface
OLLLL{long invokePrim(Object arg0, long arg1, long arg2,
long arg3);}
static public interface
OLLLD{double invokePrim(Object arg0, long arg1, long arg2 ,
long arg3);}
static public interface
OLLDO{Object invokePrim(Object arg0, long arg1, long arg2 ,
double arg3);}
static public interface
OLLDL{long invokePrim(Object arg0, long arg1, long arg2,
double arg3);}
static public interface
OLLDD{double invokePrim(Object arg0, long arg1, long arg2 ,
double arg3);}
static public interface
OLDOO{Object invokePrim(Object arg0, long arg1, double ar g2,
Object arg3);}
static public interface
OLDOL{long invokePrim(Object arg0, long arg1, double arg2 ,
9.35. IFN.JAVA 785
Object arg3);}
static public interface
OLDOD{double invokePrim(Object arg0, long arg1, double ar g2,
Object arg3);}
static public interface
OLDLO{Object invokePrim(Object arg0, long arg1, double ar g2,
long arg3);}
static public interface
OLDLL{long invokePrim(Object arg0, long arg1, double arg2 ,
long arg3);}
static public interface
OLDLD{double invokePrim(Object arg0, long arg1, double ar g2,
long arg3);}
static public interface
OLDDO{Object invokePrim(Object arg0, long arg1, double ar g2,
double arg3);}
static public interface
OLDDL{long invokePrim(Object arg0, long arg1, double arg2 ,
double arg3);}
static public interface
OLDDD{double invokePrim(Object arg0, long arg1, double ar g2,
double arg3);}
static public interface
ODOOO{Object invokePrim(Object arg0, double arg1, Object arg2,
Object arg3);}
static public interface
ODOOL{long invokePrim(Object arg0, double arg1, Object ar g2,
Object arg3);}
static public interface
ODOOD{double invokePrim(Object arg0, double arg1, Object arg2,
Object arg3);}
static public interface
ODOLO{Object invokePrim(Object arg0, double arg1, Object arg2,
long arg3);}
static public interface
ODOLL{long invokePrim(Object arg0, double arg1, Object ar g2,
long arg3);}
static public interface
ODOLD{double invokePrim(Object arg0, double arg1, Object arg2,
long arg3);}
static public interface
ODODO{Object invokePrim(Object arg0, double arg1, Object arg2,
double arg3);}
static public interface
ODODL{long invokePrim(Object arg0, double arg1, Object ar g2,
double arg3);}
static public interface
ODODD{double invokePrim(Object arg0, double arg1, Object arg2,
double arg3);}
static public interface
786 CHAPTER 9. JVM/CLOJURE/LANG/
ODLOO{Object invokePrim(Object arg0, double arg1, long ar g2,
Object arg3);}
static public interface
ODLOL{long invokePrim(Object arg0, double arg1, long arg2 ,
Object arg3);}
static public interface
ODLOD{double invokePrim(Object arg0, double arg1, long ar g2,
Object arg3);}
static public interface
ODLLO{Object invokePrim(Object arg0, double arg1, long ar g2,
long arg3);}
static public interface
ODLLL{long invokePrim(Object arg0, double arg1, long arg2 ,
long arg3);}
static public interface
ODLLD{double invokePrim(Object arg0, double arg1, long ar g2,
long arg3);}
static public interface
ODLDO{Object invokePrim(Object arg0, double arg1, long ar g2,
double arg3);}
static public interface
ODLDL{long invokePrim(Object arg0, double arg1, long arg2 ,
double arg3);}
static public interface
ODLDD{double invokePrim(Object arg0, double arg1, long ar g2,
double arg3);}
static public interface
ODDOO{Object invokePrim(Object arg0, double arg1, double arg2,
Object arg3);}
static public interface
ODDOL{long invokePrim(Object arg0, double arg1, double ar g2,
Object arg3);}
static public interface
ODDOD{double invokePrim(Object arg0, double arg1, double arg2,
Object arg3);}
static public interface
ODDLO{Object invokePrim(Object arg0, double arg1, double arg2,
long arg3);}
static public interface
ODDLL{long invokePrim(Object arg0, double arg1, double ar g2,
long arg3);}
static public interface
ODDLD{double invokePrim(Object arg0, double arg1, double arg2,
long arg3);}
static public interface
ODDDO{Object invokePrim(Object arg0, double arg1, double arg2,
double arg3);}
static public interface
ODDDL{long invokePrim(Object arg0, double arg1, double ar g2,
double arg3);}
9.35. IFN.JAVA 787
static public interface
ODDDD{double invokePrim(Object arg0, double arg1, double arg2,
double arg3);}
static public interface
LOOOO{Object invokePrim(long arg0, Object arg1, Object ar g2,
Object arg3);}
static public interface
LOOOL{long invokePrim(long arg0, Object arg1, Object arg2 ,
Object arg3);}
static public interface
LOOOD{double invokePrim(long arg0, Object arg1, Object ar g2,
Object arg3);}
static public interface
LOOLO{Object invokePrim(long arg0, Object arg1, Object ar g2,
long arg3);}
static public interface
LOOLL{long invokePrim(long arg0, Object arg1, Object arg2 ,
long arg3);}
static public interface
LOOLD{double invokePrim(long arg0, Object arg1, Object ar g2,
long arg3);}
static public interface
LOODO{Object invokePrim(long arg0, Object arg1, Object ar g2,
double arg3);}
static public interface
LOODL{long invokePrim(long arg0, Object arg1, Object arg2 ,
double arg3);}
static public interface
LOODD{double invokePrim(long arg0, Object arg1, Object ar g2,
double arg3);}
static public interface
LOLOO{Object invokePrim(long arg0, Object arg1, long arg2 ,
Object arg3);}
static public interface
LOLOL{long invokePrim(long arg0, Object arg1, long arg2,
Object arg3);}
static public interface
LOLOD{double invokePrim(long arg0, Object arg1, long arg2 ,
Object arg3);}
static public interface
LOLLO{Object invokePrim(long arg0, Object arg1, long arg2 ,
long arg3);}
static public interface
LOLLL{long invokePrim(long arg0, Object arg1, long arg2,
long arg3);}
static public interface
LOLLD{double invokePrim(long arg0, Object arg1, long arg2 ,
long arg3);}
static public interface
LOLDO{Object invokePrim(long arg0, Object arg1, long arg2 ,
788 CHAPTER 9. JVM/CLOJURE/LANG/
double arg3);}
static public interface
LOLDL{long invokePrim(long arg0, Object arg1, long arg2,
double arg3);}
static public interface
LOLDD{double invokePrim(long arg0, Object arg1, long arg2 ,
double arg3);}
static public interface
LODOO{Object invokePrim(long arg0, Object arg1, double ar g2,
Object arg3);}
static public interface
LODOL{long invokePrim(long arg0, Object arg1, double arg2 ,
Object arg3);}
static public interface
LODOD{double invokePrim(long arg0, Object arg1, double ar g2,
Object arg3);}
static public interface
LODLO{Object invokePrim(long arg0, Object arg1, double ar g2,
long arg3);}
static public interface
LODLL{long invokePrim(long arg0, Object arg1, double arg2 ,
long arg3);}
static public interface
LODLD{double invokePrim(long arg0, Object arg1, double ar g2,
long arg3);}
static public interface
LODDO{Object invokePrim(long arg0, Object arg1, double ar g2,
double arg3);}
static public interface
LODDL{long invokePrim(long arg0, Object arg1, double arg2 ,
double arg3);}
static public interface
LODDD{double invokePrim(long arg0, Object arg1, double ar g2,
double arg3);}
static public interface
LLOOO{Object invokePrim(long arg0, long arg1, Object arg2 ,
Object arg3);}
static public interface
LLOOL{long invokePrim(long arg0, long arg1, Object arg2,
Object arg3);}
static public interface
LLOOD{double invokePrim(long arg0, long arg1, Object arg2 ,
Object arg3);}
static public interface
LLOLO{Object invokePrim(long arg0, long arg1, Object arg2 ,
long arg3);}
static public interface
LLOLL{long invokePrim(long arg0, long arg1, Object arg2,
long arg3);}
static public interface
9.35. IFN.JAVA 789
LLOLD{double invokePrim(long arg0, long arg1, Object arg2 ,
long arg3);}
static public interface
LLODO{Object invokePrim(long arg0, long arg1, Object arg2 ,
double arg3);}
static public interface
LLODL{long invokePrim(long arg0, long arg1, Object arg2,
double arg3);}
static public interface
LLODD{double invokePrim(long arg0, long arg1, Object arg2 ,
double arg3);}
static public interface
LLLOO{Object invokePrim(long arg0, long arg1, long arg2,
Object arg3);}
static public interface
LLLOL{long invokePrim(long arg0, long arg1, long arg2,
Object arg3);}
static public interface
LLLOD{double invokePrim(long arg0, long arg1, long arg2,
Object arg3);}
static public interface
LLLLO{Object invokePrim(long arg0, long arg1, long arg2,
long arg3);}
static public interface
LLLLL{long invokePrim(long arg0, long arg1, long arg2,
long arg3);}
static public interface
LLLLD{double invokePrim(long arg0, long arg1, long arg2,
long arg3);}
static public interface
LLLDO{Object invokePrim(long arg0, long arg1, long arg2,
double arg3);}
static public interface
LLLDL{long invokePrim(long arg0, long arg1, long arg2,
double arg3);}
static public interface
LLLDD{double invokePrim(long arg0, long arg1, long arg2,
double arg3);}
static public interface
LLDOO{Object invokePrim(long arg0, long arg1, double arg2 ,
Object arg3);}
static public interface
LLDOL{long invokePrim(long arg0, long arg1, double arg2,
Object arg3);}
static public interface
LLDOD{double invokePrim(long arg0, long arg1, double arg2 ,
Object arg3);}
static public interface
LLDLO{Object invokePrim(long arg0, long arg1, double arg2 ,
long arg3);}
790 CHAPTER 9. JVM/CLOJURE/LANG/
static public interface
LLDLL{long invokePrim(long arg0, long arg1, double arg2,
long arg3);}
static public interface
LLDLD{double invokePrim(long arg0, long arg1, double arg2 ,
long arg3);}
static public interface
LLDDO{Object invokePrim(long arg0, long arg1, double arg2 ,
double arg3);}
static public interface
LLDDL{long invokePrim(long arg0, long arg1, double arg2,
double arg3);}
static public interface
LLDDD{double invokePrim(long arg0, long arg1, double arg2 ,
double arg3);}
static public interface
LDOOO{Object invokePrim(long arg0, double arg1, Object ar g2,
Object arg3);}
static public interface
LDOOL{long invokePrim(long arg0, double arg1, Object arg2 ,
Object arg3);}
static public interface
LDOOD{double invokePrim(long arg0, double arg1, Object ar g2,
Object arg3);}
static public interface
LDOLO{Object invokePrim(long arg0, double arg1, Object ar g2,
long arg3);}
static public interface
LDOLL{long invokePrim(long arg0, double arg1, Object arg2 ,
long arg3);}
static public interface
LDOLD{double invokePrim(long arg0, double arg1, Object ar g2,
long arg3);}
static public interface
LDODO{Object invokePrim(long arg0, double arg1, Object ar g2,
double arg3);}
static public interface
LDODL{long invokePrim(long arg0, double arg1, Object arg2 ,
double arg3);}
static public interface
LDODD{double invokePrim(long arg0, double arg1, Object ar g2,
double arg3);}
static public interface
LDLOO{Object invokePrim(long arg0, double arg1, long arg2 ,
Object arg3);}
static public interface
LDLOL{long invokePrim(long arg0, double arg1, long arg2,
Object arg3);}
static public interface
LDLOD{double invokePrim(long arg0, double arg1, long arg2 ,
9.35. IFN.JAVA 791
Object arg3);}
static public interface
LDLLO{Object invokePrim(long arg0, double arg1, long arg2 ,
long arg3);}
static public interface
LDLLL{long invokePrim(long arg0, double arg1, long arg2,
long arg3);}
static public interface
LDLLD{double invokePrim(long arg0, double arg1, long arg2 ,
long arg3);}
static public interface
LDLDO{Object invokePrim(long arg0, double arg1, long arg2 ,
double arg3);}
static public interface
LDLDL{long invokePrim(long arg0, double arg1, long arg2,
double arg3);}
static public interface
LDLDD{double invokePrim(long arg0, double arg1, long arg2 ,
double arg3);}
static public interface
LDDOO{Object invokePrim(long arg0, double arg1, double ar g2,
Object arg3);}
static public interface
LDDOL{long invokePrim(long arg0, double arg1, double arg2 ,
Object arg3);}
static public interface
LDDOD{double invokePrim(long arg0, double arg1, double ar g2,
Object arg3);}
static public interface
LDDLO{Object invokePrim(long arg0, double arg1, double ar g2,
long arg3);}
static public interface
LDDLL{long invokePrim(long arg0, double arg1, double arg2 ,
long arg3);}
static public interface
LDDLD{double invokePrim(long arg0, double arg1, double ar g2,
long arg3);}
static public interface
LDDDO{Object invokePrim(long arg0, double arg1, double ar g2,
double arg3);}
static public interface
LDDDL{long invokePrim(long arg0, double arg1, double arg2 ,
double arg3);}
static public interface
LDDDD{double invokePrim(long arg0, double arg1, double ar g2,
double arg3);}
static public interface
DOOOO{Object invokePrim(double arg0, Object arg1, Object arg2,
Object arg3);}
static public interface
792 CHAPTER 9. JVM/CLOJURE/LANG/
DOOOL{long invokePrim(double arg0, Object arg1, Object ar g2,
Object arg3);}
static public interface
DOOOD{double invokePrim(double arg0, Object arg1, Object arg2,
Object arg3);}
static public interface
DOOLO{Object invokePrim(double arg0, Object arg1, Object arg2,
long arg3);}
static public interface
DOOLL{long invokePrim(double arg0, Object arg1, Object ar g2,
long arg3);}
static public interface
DOOLD{double invokePrim(double arg0, Object arg1, Object arg2,
long arg3);}
static public interface
DOODO{Object invokePrim(double arg0, Object arg1, Object arg2,
double arg3);}
static public interface
DOODL{long invokePrim(double arg0, Object arg1, Object ar g2,
double arg3);}
static public interface
DOODD{double invokePrim(double arg0, Object arg1, Object arg2,
double arg3);}
static public interface
DOLOO{Object invokePrim(double arg0, Object arg1, long ar g2,
Object arg3);}
static public interface
DOLOL{long invokePrim(double arg0, Object arg1, long arg2 ,
Object arg3);}
static public interface
DOLOD{double invokePrim(double arg0, Object arg1, long ar g2,
Object arg3);}
static public interface
DOLLO{Object invokePrim(double arg0, Object arg1, long ar g2,
long arg3);}
static public interface
DOLLL{long invokePrim(double arg0, Object arg1, long arg2 ,
long arg3);}
static public interface
DOLLD{double invokePrim(double arg0, Object arg1, long ar g2,
long arg3);}
static public interface
DOLDO{Object invokePrim(double arg0, Object arg1, long ar g2,
double arg3);}
static public interface
DOLDL{long invokePrim(double arg0, Object arg1, long arg2 ,
double arg3);}
static public interface
DOLDD{double invokePrim(double arg0, Object arg1, long ar g2,
double arg3);}
9.35. IFN.JAVA 793
static public interface
DODOO{Object invokePrim(double arg0, Object arg1, double arg2,
Object arg3);}
static public interface
DODOL{long invokePrim(double arg0, Object arg1, double ar g2,
Object arg3);}
static public interface
DODOD{double invokePrim(double arg0, Object arg1, double arg2,
Object arg3);}
static public interface
DODLO{Object invokePrim(double arg0, Object arg1, double arg2,
long arg3);}
static public interface
DODLL{long invokePrim(double arg0, Object arg1, double ar g2,
long arg3);}
static public interface
DODLD{double invokePrim(double arg0, Object arg1, double arg2,
long arg3);}
static public interface
DODDO{Object invokePrim(double arg0, Object arg1, double arg2,
double arg3);}
static public interface
DODDL{long invokePrim(double arg0, Object arg1, double ar g2,
double arg3);}
static public interface
DODDD{double invokePrim(double arg0, Object arg1, double arg2,
double arg3);}
static public interface
DLOOO{Object invokePrim(double arg0, long arg1, Object ar g2,
Object arg3);}
static public interface
DLOOL{long invokePrim(double arg0, long arg1, Object arg2 ,
Object arg3);}
static public interface
DLOOD{double invokePrim(double arg0, long arg1, Object ar g2,
Object arg3);}
static public interface
DLOLO{Object invokePrim(double arg0, long arg1, Object ar g2,
long arg3);}
static public interface
DLOLL{long invokePrim(double arg0, long arg1, Object arg2 ,
long arg3);}
static public interface
DLOLD{double invokePrim(double arg0, long arg1, Object ar g2,
long arg3);}
static public interface
DLODO{Object invokePrim(double arg0, long arg1, Object ar g2,
double arg3);}
static public interface
DLODL{long invokePrim(double arg0, long arg1, Object arg2 ,
794 CHAPTER 9. JVM/CLOJURE/LANG/
double arg3);}
static public interface
DLODD{double invokePrim(double arg0, long arg1, Object ar g2,
double arg3);}
static public interface
DLLOO{Object invokePrim(double arg0, long arg1, long arg2 ,
Object arg3);}
static public interface
DLLOL{long invokePrim(double arg0, long arg1, long arg2,
Object arg3);}
static public interface
DLLOD{double invokePrim(double arg0, long arg1, long arg2 ,
Object arg3);}
static public interface
DLLLO{Object invokePrim(double arg0, long arg1, long arg2 ,
long arg3);}
static public interface
DLLLL{long invokePrim(double arg0, long arg1, long arg2,
long arg3);}
static public interface
DLLLD{double invokePrim(double arg0, long arg1, long arg2 ,
long arg3);}
static public interface
DLLDO{Object invokePrim(double arg0, long arg1, long arg2 ,
double arg3);}
static public interface
DLLDL{long invokePrim(double arg0, long arg1, long arg2,
double arg3);}
static public interface
DLLDD{double invokePrim(double arg0, long arg1, long arg2 ,
double arg3);}
static public interface
DLDOO{Object invokePrim(double arg0, long arg1, double ar g2,
Object arg3);}
static public interface
DLDOL{long invokePrim(double arg0, long arg1, double arg2 ,
Object arg3);}
static public interface
DLDOD{double invokePrim(double arg0, long arg1, double ar g2,
Object arg3);}
static public interface
DLDLO{Object invokePrim(double arg0, long arg1, double ar g2,
long arg3);}
static public interface
DLDLL{long invokePrim(double arg0, long arg1, double arg2 ,
long arg3);}
static public interface
DLDLD{double invokePrim(double arg0, long arg1, double ar g2,
long arg3);}
static public interface
9.35. IFN.JAVA 795
DLDDO{Object invokePrim(double arg0, long arg1, double ar g2,
double arg3);}
static public interface
DLDDL{long invokePrim(double arg0, long arg1, double arg2 ,
double arg3);}
static public interface
DLDDD{double invokePrim(double arg0, long arg1, double ar g2,
double arg3);}
static public interface
DDOOO{Object invokePrim(double arg0, double arg1, Object arg2,
Object arg3);}
static public interface
DDOOL{long invokePrim(double arg0, double arg1, Object ar g2,
Object arg3);}
static public interface
DDOOD{double invokePrim(double arg0, double arg1, Object arg2,
Object arg3);}
static public interface
DDOLO{Object invokePrim(double arg0, double arg1, Object arg2,
long arg3);}
static public interface
DDOLL{long invokePrim(double arg0, double arg1, Object ar g2,
long arg3);}
static public interface
DDOLD{double invokePrim(double arg0, double arg1, Object arg2,
long arg3);}
static public interface
DDODO{Object invokePrim(double arg0, double arg1, Object arg2,
double arg3);}
static public interface
DDODL{long invokePrim(double arg0, double arg1, Object ar g2,
double arg3);}
static public interface
DDODD{double invokePrim(double arg0, double arg1, Object arg2,
double arg3);}
static public interface
DDLOO{Object invokePrim(double arg0, double arg1, long ar g2,
Object arg3);}
static public interface
DDLOL{long invokePrim(double arg0, double arg1, long arg2 ,
Object arg3);}
static public interface
DDLOD{double invokePrim(double arg0, double arg1, long ar g2,
Object arg3);}
static public interface
DDLLO{Object invokePrim(double arg0, double arg1, long ar g2,
long arg3);}
static public interface
DDLLL{long invokePrim(double arg0, double arg1, long arg2 ,
long arg3);}
796 CHAPTER 9. JVM/CLOJURE/LANG/
static public interface
DDLLD{double invokePrim(double arg0, double arg1, long ar g2,
long arg3);}
static public interface
DDLDO{Object invokePrim(double arg0, double arg1, long ar g2,
double arg3);}
static public interface
DDLDL{long invokePrim(double arg0, double arg1, long arg2 ,
double arg3);}
static public interface
DDLDD{double invokePrim(double arg0, double arg1, long ar g2,
double arg3);}
static public interface
DDDOO{Object invokePrim(double arg0, double arg1, double arg2,
Object arg3);}
static public interface
DDDOL{long invokePrim(double arg0, double arg1, double ar g2,
Object arg3);}
static public interface
DDDOD{double invokePrim(double arg0, double arg1, double arg2,
Object arg3);}
static public interface
DDDLO{Object invokePrim(double arg0, double arg1, double arg2,
long arg3);}
static public interface
DDDLL{long invokePrim(double arg0, double arg1, double ar g2,
long arg3);}
static public interface
DDDLD{double invokePrim(double arg0, double arg1, double arg2,
long arg3);}
static public interface
DDDDO{Object invokePrim(double arg0, double arg1, double arg2,
double arg3);}
static public interface
DDDDL{long invokePrim(double arg0, double arg1, double ar g2,
double arg3);}
static public interface
DDDDD{double invokePrim(double arg0, double arg1, double arg2,
double arg3);}
}
———-
9.36 IKeywordLookup.java
— IKeywordLookup.java —
9.37. ILOOKUP.JAVA 797
/*
getchunk{Clojure Copyright}
*/
/* rich Oct 31, 2009 */
package clojure.lang;
public interface IKeywordLookup{
ILookupThunk getLookupThunk(Keyword k);
}
———-
9.37 ILookup.java
— ILookup.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Aug 2, 2009 */
package clojure.lang;
public interface ILookup{
Object valAt(Object key);
Object valAt(Object key, Object notFound);
}
———-
9.38 ILookupSite.java
— ILookupSite.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 2, 2009 */
package clojure.lang;
public interface ILookupSite{
798 CHAPTER 9. JVM/CLOJURE/LANG/
ILookupThunk fault(Object target);
}
———-
9.39 ILookupThunk.java
— ILookupThunk.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 2, 2009 */
package clojure.lang;
public interface ILookupThunk{
Object get(Object target);
}
———-
9.40 IMapEntry.java
(Map.Entry [1723])
— IMapEntry.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.util.Map;
public interface IMapEntry extends Map.Entry{
Object key();
Object val();
}
———-
9.41. IMETA.JAVA 799
9.41 IMeta.java
— IMeta.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 31, 2008 */
package clojure.lang;
public interface IMeta {
IPersistentMap meta();
}
———-
9.42 Indexed.java
(Counted [768])
— Indexed.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 24, 2009 */
package clojure.lang;
public interface Indexed extends Counted{
Object nth(int i);
Object nth(int i, Object notFound);
}
———-
9.43 IndexedSeq.java
(ISeq [805]) (Counted [768])
— IndexedSeq.java —
/*
\getchunk{Clojure Copyright}
800 CHAPTER 9. JVM/CLOJURE/LANG/
*/
package clojure.lang;
public interface IndexedSeq extends ISeq, Counted{
public int index();
}
———-
9.44 IObj.java
(IMeta [799])
— IObj.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IObj extends IMeta {
public IObj withMeta(IPersistentMap meta);
}
———-
9.45 IPersistentCollection.java
(Seqable [1140])
— IPersistentCollection.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IPersistentCollection extends Seqable {
int count();
IPersistentCollection cons(Object o);
IPersistentCollection empty();
9.46. IPERSISTENTLIST.JAVA 801
boolean equiv(Object o);
}
———-
9.46 IPersistentList.java
(Sequential [1140]) (IPersistentStack [802])
— IPersistentList.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IPersistentList extends Sequential, IPe rsistentStack{
}
———-
9.47 IPersistentMap.java
(Iterable [1723]) (Associative [576]) (Counted [768])
— IPersistentMap.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IPersistentMap extends Iterable, Associ ative, Counted{
IPersistentMap assoc(Object key, Object val);
IPersistentMap assocEx(Object key, Object val) throws Exc eption;
IPersistentMap without(Object key) throws Exception;
}
———-
802 CHAPTER 9. JVM/CLOJURE/LANG/
9.48 IPersistentSet.java
(IPersistentCollection [800]) (Counted [768])
— IPersistentSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
public interface IPersistentSet extends IPersistentColl ection, Counted{
public IPersistentSet disjoin(Object key) throws Excepti on;
public boolean contains(Object key);
public Object get(Object key);
}
———-
9.49 IPersistentStack.java
(IPersistentCollection [800])
— IPersistentStack.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Sep 19, 2007 */
package clojure.lang;
public interface IPersistentStack extends IPersistentCo llection{
Object peek();
IPersistentStack pop();
}
———-
9.50 IPersistentVector.java
(Associative [576]) (Sequential [1140]) (Reversible [1094]) (Indexed [799]) (IPer-
sistentStack [802])
— IPersistentVector.java —
9.51. IPROMISEIMPL.JAVA 803
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IPersistentVector
extends Associative, Sequential, IPersistentStack,
Reversible, Indexed{
int length();
IPersistentVector assocN(int i, Object val);
IPersistentVector cons(Object o);
}
———-
9.51 IPromiseImpl.java
— IPromiseImpl.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface IPromiseImpl {
boolean hasValue();
}
———-
9.52 IProxy.java
— IProxy.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Feb 27, 2008 */
package clojure.lang;
804 CHAPTER 9. JVM/CLOJURE/LANG/
public interface IProxy{
public void __initClojureFnMappings(IPersistentMap m);
public void __updateClojureFnMappings(IPersistentMap m );
public IPersistentMap __getClojureFnMappings();
}
———-
9.53 IReduce.java
— IReduce.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jun 11, 2008 */
package clojure.lang;
public interface IReduce{
Object reduce(IFn f) throws Exception;
Object reduce(IFn f, Object start) throws Exception;
}
———-
9.54 IReference.java
(IMeta [799])
— IReference.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 31, 2008 */
package clojure.lang;
public interface IReference extends IMeta {
IPersistentMap alterMeta(IFn alter, ISeq args) throws Exc eption;
IPersistentMap resetMeta(IPersistentMap m);
}
9.55. IREF.JAVA 805
———-
9.55 IRef.java
(IDeref [773])
— IRef.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 18, 2007 */
package clojure.lang;
public interface IRef extends IDeref{
void setValidator(IFn vf);
IFn getValidator();
IPersistentMap getWatches();
IRef addWatch(Object key, IFn callback);
IRef removeWatch(Object key);
}
———-
9.56 ISeq.java
(IPersistentCollection [800]) (Sequential [1140])
— ISeq.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
/**
* A persistent, functional, sequence interface
* <p/>
* ISeqs are immutable values, i.e. neither first(), nor rest () changes
* or invalidates the ISeq
*/
806 CHAPTER 9. JVM/CLOJURE/LANG/
public interface ISeq extends IPersistentCollection, Seq uential{
Object first();
ISeq next();
ISeq more();
ISeq cons(Object o);
}
———-
9.57 IteratorSeq.java
(ASeq [571])
— IteratorSeq.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.IOException;
import java.io.NotSerializableException;
import java.util.Iterator;
public class IteratorSeq extends ASeq{
final Iterator iter;
final State state;
static class State{
volatile Object val;
volatile Object _rest;
}
public static IteratorSeq create(Iterator iter){
if(iter.hasNext())
return new IteratorSeq(iter);
return null;
}
IteratorSeq(Iterator iter){
this.iter = iter;
state = new State();
this.state.val = state;
this.state._rest = state;
9.58. ITRANSIENTASSOCIATIVE.JAVA 807
}
IteratorSeq(IPersistentMap meta, Iterator iter, State st ate){
super(meta);
this.iter = iter;
this.state = state;
}
public Object first(){
if(state.val == state)
synchronized(state)
{
if(state.val == state)
state.val = iter.next();
}
return state.val;
}
public ISeq next(){
if(state._rest == state)
synchronized(state)
{
if(state._rest == state)
{
first();
state._rest = create(iter);
}
}
return (ISeq) state._rest;
}
public IteratorSeq withMeta(IPersistentMap meta){
return new IteratorSeq(meta, iter, state);
}
private void writeObject (java.io.ObjectOutputStream ou t)
throws IOException {
throw new NotSerializableException(getClass().getName ());
}
}
———-
9.58 ITransientAssociative.java
(ITransientCollection [808]) (ILookup [797])
— ITransientAssociative.java —
808 CHAPTER 9. JVM/CLOJURE/LANG/
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 17, 2009 */
package clojure.lang;
public interface ITransientAssociative
extends ITransientCollection, ILookup{
ITransientAssociative assoc(Object key, Object val);
}
———-
9.59 ITransientCollection.java
— ITransientCollection.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 17, 2009 */
package clojure.lang;
public interface ITransientCollection{
ITransientCollection conj(Object val);
IPersistentCollection persistent();
}
———-
9.60 ITransientMap.java
(ITransientAssociative [807]) (Counted [768])
— ITransientMap.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 17, 2009 */
9.61. ITRANSIENTSET.JAVA 809
package clojure.lang;
public interface ITransientMap extends ITransientAssoci ative, Counted{
ITransientMap assoc(Object key, Object val);
ITransientMap without(Object key);
IPersistentMap persistent();
}
———-
9.61 ITransientSet.java
(ITransientCollection [808]) (Counted [768])
— ITransientSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
public interface ITransientSet extends ITransientCollec tion, Counted{
public ITransientSet disjoin(Object key) throws Exceptio n;
public boolean contains(Object key);
public Object get(Object key);
}
———-
9.62 ITransientVector.java
(ITransientAssociative [807]) (Indexed [799])
— ITransientVector.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 17, 2009 */
package clojure.lang;
public interface ITransientVector extends ITransientAss ociative, Indexed{
810 CHAPTER 9. JVM/CLOJURE/LANG/
ITransientVector assocN(int i, Object val);
ITransientVector pop();
}
———-
9.63 Keyword.java
(IFn [774]) (Comparable [1723]) (Named [861]) (Serializable [1723])
— Keyword.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 29, 2006 10:39:05 AM */
package clojure.lang;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
public final class Keyword
implements IFn, Comparable, Named, Serializable {
private static ConcurrentHashMap<Symbol, SoftReference <Keyword>> table =
new ConcurrentHashMap();
static final ReferenceQueue rq = new ReferenceQueue();
public final Symbol sym;
final int hash;
public static Keyword intern(Symbol sym){
if(sym.meta() != null)
sym = (Symbol) sym.withMeta(null);
Util.clearCache(rq, table);
Keyword k = new Keyword(sym);
SoftReference<Keyword> existingRef =
table.putIfAbsent(sym, new SoftReference<Keyword>(k,r q));
if(existingRef == null)
return k;
Keyword existingk = existingRef.get();
if(existingk != null)
return existingk;
9.63. KEYWORD.JAVA 811
//entry died in the interim, do over
table.remove(sym, existingRef);
return intern(sym);
}
public static Keyword intern(String ns, String name){
return intern(Symbol.intern(ns, name));
}
public static Keyword intern(String nsname){
return intern(Symbol.intern(nsname));
}
private Keyword(Symbol sym){
this.sym = sym;
hash = sym.hashCode() + 0x9e3779b9;
}
public static Keyword find(Symbol sym){
SoftReference<Keyword> ref = table.get(sym);
if (ref != null)
return ref.get();
else
return null;
}
public static Keyword find(String ns, String name){
return find(Symbol.intern(ns, name));
}
public static Keyword find(String nsname){
return find(Symbol.intern(nsname));
}
public final int hashCode(){
return hash;
}
public String toString(){
return ":" + sym;
}
public Object throwArity(){
throw new IllegalArgumentException(
"Wrong number of args passed to keyword: " + toString());
}
public Object call() throws Exception{
return throwArity();
}
812 CHAPTER 9. JVM/CLOJURE/LANG/
public void run(){
throw new UnsupportedOperationException();
}
public Object invoke() throws Exception{
return throwArity();
}
public int compareTo(Object o){
return sym.compareTo(((Keyword) o).sym);
}
public String getNamespace(){
return sym.getNamespace();
}
public String getName(){
return sym.getName();
}
private Object readResolve() throws ObjectStreamExcepti on{
return intern(sym);
}
/**
* Indexer implements IFn for attr access
*
* @param obj - must be IPersistentMap
* @return the value at the key or nil if not found
* @throws Exception
*/
final public Object invoke(Object obj) throws Exception{
if(obj instanceof ILookup)
return ((ILookup)obj).valAt(this);
return RT.get(obj, this);
}
final public Object invoke(Object obj, Object notFound)
throws Exception{
if(obj instanceof ILookup)
return ((ILookup)obj).valAt(this,notFound);
return RT.get(obj, this, notFound);
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
return throwArity();
}
9.63. KEYWORD.JAVA 813
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
814 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
return throwArity();
}
9.63. KEYWORD.JAVA 815
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
return throwArity();
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
816 CHAPTER 9. JVM/CLOJURE/LANG/
throws Exception{
return throwArity();
}
public Object applyTo(ISeq arglist) throws Exception{
return AFn.applyToHelper(this, arglist);
}
}
———-
9.64 KeywordLookupSite.java
(ILookupSite [797]) (ILookupThunk [798])
— KeywordLookupSite.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 2, 2009 */
package clojure.lang;
public final class KeywordLookupSite
implements ILookupSite, ILookupThunk{
final Keyword k;
public KeywordLookupSite(Keyword k){
this.k = k;
}
public ILookupThunk fault(Object target){
if(target instanceof IKeywordLookup)
{
return install(target);
}
else if(target instanceof ILookup)
{
return ilookupThunk(target.getClass());
}
return this;
}
public Object get(Object target){
9.65. LAZILYPERSISTENTVECTOR.JAVA 817
if(target instanceof IKeywordLookup || target instanceof ILookup)
return this;
return RT.get(target,k);
}
private ILookupThunk ilookupThunk(final Class c){
return new ILookupThunk(){
public Object get(Object target){
if(target != null && target.getClass() == c)
return ((ILookup) target).valAt(k);
return this;
}
};
}
private ILookupThunk install(Object target){
ILookupThunk t = ((IKeywordLookup)target).getLookupThu nk(k);
if(t != null)
return t;
return ilookupThunk(target.getClass());
}
}
———-
9.65 LazilyPersistentVector.java
— LazilyPersistentVector.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 14, 2008 */
package clojure.lang;
import java.util.Collection;
public class LazilyPersistentVector{
static public IPersistentVector createOwning(Object... items){
if(items.length == 0)
return PersistentVector.EMPTY;
else if(items.length <= 32)
return
new PersistentVector(items.length, 5,
818 CHAPTER 9. JVM/CLOJURE/LANG/
PersistentVector.EMPTY_NODE,items);
return PersistentVector.create(items);
}
static public IPersistentVector create(Collection coll) {
if(!(coll instanceof ISeq) && coll.size() <= 32)
return createOwning(coll.toArray());
return PersistentVector.create(RT.seq(coll));
}
}
———-
9.66 LazySeq.java
(Obj [947]) (ISeq [805]) (List [1723])
— LazySeq.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 31, 2009 */
package clojure.lang;
import java.util.*;
public final class LazySeq extends Obj implements ISeq, Lis t{
private IFn fn;
private Object sv;
private ISeq s;
public LazySeq(IFn fn){
this.fn = fn;
}
private LazySeq(IPersistentMap meta, ISeq s){
super(meta);
this.fn = null;
this.s = s;
}
public Obj withMeta(IPersistentMap meta){
return new LazySeq(meta, seq());
}
9.66. LAZYSEQ.JAVA 819
final synchronized Object sval(){
if(fn != null)
{
try
{
sv = fn.invoke();
fn = null;
}
catch(RuntimeException e)
{
throw e;
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
if(sv != null)
return sv;
return s;
}
final synchronized public ISeq seq(){
sval();
if(sv != null)
{
Object ls = sv;
sv = null;
while(ls instanceof LazySeq)
{
ls = ((LazySeq)ls).sval();
}
s = RT.seq(ls);
}
return s;
}
public int count(){
int c = 0;
for(ISeq s = seq(); s != null; s = s.next())
++c;
return c;
}
public Object first(){
seq();
if(s == null)
return null;
return s.first();
}
820 CHAPTER 9. JVM/CLOJURE/LANG/
public ISeq next(){
seq();
if(s == null)
return null;
return s.next();
}
public ISeq more(){
seq();
if(s == null)
return PersistentList.EMPTY;
return s.more();
}
public ISeq cons(Object o){
return RT.cons(o, seq());
}
public IPersistentCollection empty(){
return PersistentList.EMPTY;
}
public boolean equiv(Object o){
return equals(o);
}
public int hashCode(){
ISeq s = seq();
if(s == null)
return 1;
return Util.hash(seq());
}
public boolean equals(Object o){
ISeq s = seq();
if(s != null)
return s.equiv(o);
else
return (o instanceof Sequential ||
o instanceof List) &&
RT.seq(o) == null;
}
// java.util.Collection implementation
public Object[] toArray(){
return RT.seqToArray(seq());
}
9.66. LAZYSEQ.JAVA 821
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(!contains(o))
return false;
}
return true;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.next())
{
a[i] = s.first();
}
if(a.length > count())
a[count()] = null;
return a;
}
else
return toArray();
}
822 CHAPTER 9. JVM/CLOJURE/LANG/
public int size(){
return count();
}
public boolean isEmpty(){
return seq() == null;
}
public boolean contains(Object o){
for(ISeq s = seq(); s != null; s = s.next())
{
if(Util.equiv(s.first(), o))
return true;
}
return false;
}
public Iterator iterator(){
return new SeqIterator(seq());
}
//////////// List stuff /////////////////
private List reify(){
return new ArrayList(this);
}
public List subList(int fromIndex, int toIndex){
return reify().subList(fromIndex, toIndex);
}
public Object set(int index, Object element){
throw new UnsupportedOperationException();
}
public Object remove(int index){
throw new UnsupportedOperationException();
}
public int indexOf(Object o){
ISeq s = seq();
for(int i = 0; s != null; s = s.next(), i++)
{
if(Util.equiv(s.first(), o))
return i;
}
return -1;
}
public int lastIndexOf(Object o){
return reify().lastIndexOf(o);
9.67. LINENUMBERINGPUSHBACKREADER.JAVA 823
}
public ListIterator listIterator(){
return reify().listIterator();
}
public ListIterator listIterator(int index){
return reify().listIterator(index);
}
public Object get(int index){
return RT.nth(this, index);
}
public void add(int index, Object element){
throw new UnsupportedOperationException();
}
public boolean addAll(int index, Collection c){
throw new UnsupportedOperationException();
}
}
———-
9.67 LineNumberingPushbackReader.java
(PushbackReader [1723])
— LineNumberingPushbackReader.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.LineNumberReader;
import java.io.IOException;
public class LineNumberingPushbackReader extends Pushba ckReader{
// This class is a PushbackReader that wraps a LineNumberRea der. The code
// here to handle line terminators only mentions ’\n’ becaus e
// LineNumberReader collapses all occurrences of CR, LF, an d CRLF into a
824 CHAPTER 9. JVM/CLOJURE/LANG/
// single ’\n’.
private static final int newline = (int) ’\n’;
private boolean _atLineStart = true;
private boolean _prev;
public LineNumberingPushbackReader(Reader r){
super(new LineNumberReader(r));
}
public int getLineNumber(){
return ((LineNumberReader) in).getLineNumber() + 1;
}
public int read() throws IOException{
int c = super.read();
_prev = _atLineStart;
_atLineStart = (c == newline) || (c == -1);
return c;
}
public void unread(int c) throws IOException{
super.unread(c);
_atLineStart = _prev;
}
public String readLine() throws IOException{
int c = read();
String line;
switch (c) {
case -1:
line = null;
break;
case newline:
line = "";
break;
default:
String first = String.valueOf((char) c);
String rest = ((LineNumberReader)in).readLine();
line = (rest == null) ? first : first + rest;
_prev = false;
_atLineStart = true;
break;
}
return line;
}
public boolean atLineStart(){
return _atLineStart;
9.68. LISPREADER.JAVA 825
}
}
———-
9.68 LispReader.java
— LispReader.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.lang.*;
public class LispReader{
static final Symbol QUOTE = Symbol.intern("quote");
static final Symbol THE_VAR = Symbol.intern("var");
//static Symbol SYNTAX_QUOTE = Symbol.intern(null, "synt ax-quote");
static Symbol UNQUOTE = Symbol.intern("clojure.core", "u nquote");
static Symbol UNQUOTE_SPLICING =
Symbol.intern("clojure.core", "unquote-splicing");
static Symbol CONCAT = Symbol.intern("clojure.core", "co ncat");
static Symbol SEQ = Symbol.intern("clojure.core", "seq") ;
static Symbol LIST = Symbol.intern("clojure.core", "list ");
static Symbol APPLY = Symbol.intern("clojure.core", "app ly");
static Symbol HASHMAP = Symbol.intern("clojure.core", "h ash-map");
static Symbol HASHSET = Symbol.intern("clojure.core", "h ash-set");
static Symbol VECTOR = Symbol.intern("clojure.core", "ve ctor");
static Symbol WITH_META = Symbol.intern("clojure.core", "with-meta");
static Symbol META = Symbol.intern("clojure.core", "meta ");
static Symbol DEREF = Symbol.intern("clojure.core", "der ef");
//static Symbol DEREF_BANG = Symbol.intern("clojure.cor e", "deref!");
\getchunk{LispReader macros statement}
\getchunk{LispReader dispatchMacros statement}
//static Pattern symbolPat =
826 CHAPTER 9. JVM/CLOJURE/LANG/
// Pattern.compile("[:]?([\\D&&[^:/]][^:/]*/)?[\\D&& [^:/]][^:/]*");
static Pattern symbolPat =
Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][ ^/]*)");
//static Pattern varPat =
// Pattern.compile("([\\D&&[^:\\.]][^:\\.]*):([\\D&& [^:\\.]][^:\\.]*)");
//static Pattern intPat = Pattern.compile("[-+]?[0-9]+\ \.?");
static Pattern intPat =
Pattern.compile(
"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0( [0-7]+)"+
"|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");
static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+ )/([0-9]+)");
static Pattern floatPat =
Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]? [0-9]+)?)(M)?");
static final Symbol SLASH = Symbol.intern("/");
static final Symbol CLOJURE_SLASH = Symbol.intern("cloju re.core","/");
//static Pattern accessorPat = Pattern.compile("\\.[a-z A-Z_]\\w*");
//static Pattern instanceMemberPat =
// Pattern.compile("\\.([a-zA-Z_][\\w\\.]*)\\.([a-zA -Z_]\\w*)");
//static Pattern staticMemberPat =
// Pattern.compile("([a-zA-Z_][\\w\\.]*)\\.([a-zA-Z_ ]\\w*)");
//static Pattern classNamePat =
// Pattern.compile("([a-zA-Z_][\\w\\.]*)\\.");
//symbol->gensymbol
static Var GENSYM_ENV = Var.create(null).setDynamic();
//sorted-map num->gensymbol
static Var ARG_ENV = Var.create(null).setDynamic();
static
{
\getchunk{LispReader Syntax Macro Table}
\getchunk{LispReader Dispatch Macro Table}
}
static boolean isWhitespace(int ch){
return Character.isWhitespace(ch) || ch == ’,’;
}
static void unread(PushbackReader r, int ch) throws IOExce ption{
if(ch != -1)
r.unread(ch);
}
public static class ReaderException extends Exception{
final int line;
public ReaderException(int line, Throwable cause){
super(cause);
this.line = line;
9.68. LISPREADER.JAVA 827
}
}
\getchunk{LispReader read method}
static private String readToken(PushbackReader r, char in itch)
throws Exception{
StringBuilder sb = new StringBuilder();
sb.append(initch);
for(; ;)
{
int ch = r.read();
if(ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch) )
{
unread(r, ch);
return sb.toString();
}
sb.append((char) ch);
}
}
static private Object readNumber(PushbackReader r, char i nitch)
throws Exception{
StringBuilder sb = new StringBuilder();
sb.append(initch);
for(; ;)
{
int ch = r.read();
if(ch == -1 || isWhitespace(ch) || isMacro(ch))
{
unread(r, ch);
break;
}
sb.append((char) ch);
}
String s = sb.toString();
Object n = matchNumber(s);
if(n == null)
throw new NumberFormatException("Invalid number: " + s);
return n;
}
static private int readUnicodeChar(String token,
int offset,
int length,
int base)
throws Exception{
828 CHAPTER 9. JVM/CLOJURE/LANG/
if(token.length() != offset + length)
throw new IllegalArgumentException(
"Invalid unicode character: \\" + token);
int uc = 0;
for(int i = offset; i < offset + length; ++i)
{
int d = Character.digit(token.charAt(i), base);
if(d == -1)
throw new IllegalArgumentException(
"Invalid digit: " + (char) d);
uc = uc * base + d;
}
return (char) uc;
}
static private int readUnicodeChar(PushbackReader r,
int initch,
int base,
int length,
boolean exact)
throws Exception{
int uc = Character.digit(initch, base);
if(uc == -1)
throw new IllegalArgumentException("Invalid digit: " + in itch);
int i = 1;
for(; i < length; ++i)
{
int ch = r.read();
if(ch == -1 || isWhitespace(ch) || isMacro(ch))
{
unread(r, ch);
break;
}
int d = Character.digit(ch, base);
if(d == -1)
throw new IllegalArgumentException(
"Invalid digit: " + (char) ch);
uc = uc * base + d;
}
if(i != length && exact)
throw new IllegalArgumentException(
"Invalid character length: " + i + ", should be: " + length);
return uc;
}
static private Object interpretToken(String s) throws Exc eption{
if(s.equals("nil"))
{
return null;
}
9.68. LISPREADER.JAVA 829
else if(s.equals("true"))
{
return RT.T;
}
else if(s.equals("false"))
{
return RT.F;
}
else if(s.equals("/"))
{
return SLASH;
}
else if(s.equals("clojure.core//"))
{
return CLOJURE_SLASH;
}
Object ret = null;
ret = matchSymbol(s);
if(ret != null)
return ret;
throw new Exception("Invalid token: " + s);
}
private static Object matchSymbol(String s){
Matcher m = symbolPat.matcher(s);
if(m.matches())
{
int gc = m.groupCount();
String ns = m.group(1);
String name = m.group(2);
if(ns != null && ns.endsWith(":/")
|| name.endsWith(":")
|| s.indexOf("::", 1) != -1)
return null;
if(s.startsWith("::"))
{
Symbol ks = Symbol.intern(s.substring(2));
Namespace kns;
if(ks.ns != null)
kns = Compiler.namespaceFor(ks);
else
kns = Compiler.currentNS();
//auto-resolving keyword
if (kns != null)
return Keyword.intern(kns.name.name,ks.name);
else
return null;
830 CHAPTER 9. JVM/CLOJURE/LANG/
}
boolean isKeyword = s.charAt(0) == ’:’;
Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 : 0)) ;
if(isKeyword)
return Keyword.intern(sym);
return sym;
}
return null;
}
private static Object matchNumber(String s){
Matcher m = intPat.matcher(s);
if(m.matches())
{
if(m.group(2) != null)
{
if(m.group(8) != null)
return BigInt.ZERO;
return Numbers.num(0);
}
boolean negate = (m.group(1).equals("-"));
String n;
int radix = 10;
if((n = m.group(3)) != null)
radix = 10;
else if((n = m.group(4)) != null)
radix = 16;
else if((n = m.group(5)) != null)
radix = 8;
else if((n = m.group(7)) != null)
radix = Integer.parseInt(m.group(6));
if(n == null)
return null;
BigInteger bn = new BigInteger(n, radix);
if(negate)
bn = bn.negate();
if(m.group(8) != null)
return BigInt.fromBigInteger(bn);
return bn.bitLength() < 64 ?
Numbers.num(bn.longValue())
: BigInt.fromBigInteger(bn);
}
m = floatPat.matcher(s);
if(m.matches())
{
if(m.group(4) != null)
return new BigDecimal(m.group(1));
return Double.parseDouble(s);
}
9.68. LISPREADER.JAVA 831
m = ratioPat.matcher(s);
if(m.matches())
{
return
Numbers.divide(
Numbers.reduceBigInt(
BigInt.fromBigInteger(new BigInteger(m.group(1)))),
Numbers.reduceBigInt(
BigInt.fromBigInteger(new BigInteger(m.group(2)))));
}
return null;
}
static private IFn getMacro(int ch){
if(ch < macros.length)
return macros[ch];
return null;
}
static private boolean isMacro(int ch){
return (ch < macros.length && macros[ch] != null);
}
static private boolean isTerminatingMacro(int ch){
return (ch != ’#’ && ch != ’\’’ && isMacro(ch));
}
\getchunk{LispReader RegexReader class}
\getchunk{LispReader StringReader class}
\getchunk{LispReader CommentReader class}
\getchunk{LispReader DiscardReader class}
\getchunk{LispReader WrappingReader class}
public static class DeprecatedWrappingReader extends AFn {
final Symbol sym;
final String macro;
public DeprecatedWrappingReader(Symbol sym, String macr o){
this.sym = sym;
this.macro = macro;
}
public Object invoke(Object reader, Object quote)
throws Exception{
System.out.println("WARNING: reader macro " + macro +
" is deprecated; use " + sym.getName() +
832 CHAPTER 9. JVM/CLOJURE/LANG/
" instead");
PushbackReader r = (PushbackReader) reader;
Object o = read(r, true, null, true);
return RT.list(sym, o);
}
}
\getchunk{LispReader VarReader class}
/*
static class DerefReader extends AFn{
public Object invoke(Object reader, Object quote)
throws Exception{
PushbackReader r = (PushbackReader) reader;
int ch = r.read();
if(ch == -1)
throw new Exception("EOF while reading character");
if(ch == ’!’)
{
Object o = read(r, true, null, true);
return RT.list(DEREF_BANG, o);
}
else
{
r.unread(ch);
Object o = read(r, true, null, true);
return RT.list(DEREF, o);
}
}
}
*/
\getchunk{LispReader DispatchReader class}
static Symbol garg(int n){
return Symbol.intern(null,
(n == -1 ? "rest" : ("p" + n)) + "__" + RT.nextID() + "#");
}
\getchunk{LispReader FnReader class}
static Symbol registerArg(int n){
PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV .deref();
if(argsyms == null)
{
throw new IllegalStateException("arg literal not in #()") ;
}
9.68. LISPREADER.JAVA 833
Symbol ret = (Symbol) argsyms.valAt(n);
if(ret == null)
{
ret = garg(n);
ARG_ENV.set(argsyms.assoc(n, ret));
}
return ret;
}
\getchunk{LispReader ArgReader class}
\getchunk{LispReader MetaReader class}
\getchunk{LispReader SyntaxQuoteReader class}
static boolean isUnquoteSplicing(Object form){
return form instanceof ISeq &&
Util.equals(RT.first(form),UNQUOTE_SPLICING);
}
static boolean isUnquote(Object form){
return form instanceof ISeq && Util.equals(RT.first(form ),UNQUOTE);
}
\getchunk{LispReader UnquoteReader class}
\getchunk{LispReader CharacterReader class}
\getchunk{LispReader ListReader class}
static class CtorReader extends AFn{
static final Symbol cls = Symbol.intern("class");
public Object invoke(Object reader, Object leftangle)
throws Exception{
PushbackReader r = (PushbackReader) reader;
// #<class classname>
// #<classname args*>
// #<classname/staticMethod args*>
List list = readDelimitedList(’>’, r, true);
if(list.isEmpty())
throw new Exception(
"Must supply ’class’, classname or classname/staticMetho d");
Symbol s = (Symbol) list.get(0);
Object[] args = list.subList(1, list.size()).toArray();
if(s.equals(cls))
{
return RT.classForName(args[0].toString());
}
else if(s.ns != null) //static method
834 CHAPTER 9. JVM/CLOJURE/LANG/
{
String classname = s.ns;
String method = s.name;
return Reflector.invokeStaticMethod(classname, method , args);
}
else
{
return
Reflector.invokeConstructor(RT.classForName(s.name) , args);
}
}
}
\getchunk{LispReader EvalReader class}
//static class ArgVectorReader extends AFn{
// public Object invoke(Object reader, Object leftparen)
// throws Exception{
// PushbackReader r = (PushbackReader) reader;
// return ArgVector.create(readDelimitedList(’|’, r, tr ue));
// }
//
//}
\getchunk{LispReader VectorReader class}
\getchunk{LispReader MapReader class}
\getchunk{LispReader SetReader class}
\getchunk{LispReader UnmatchedDelimiterReader class}
\getchunk{LispReader UnreadableReader class}
public static List readDelimitedList(char delim,
PushbackReader r,
boolean isRecursive)
throws Exception{
final int firstline =
(r instanceof LineNumberingPushbackReader) ?
((LineNumberingPushbackReader) r).getLineNumber() : -1 ;
ArrayList a = new ArrayList();
for(; ;)
{
int ch = r.read();
while(isWhitespace(ch))
9.68. LISPREADER.JAVA 835
ch = r.read();
if(ch == -1)
{
if(firstline < 0)
throw new Exception("EOF while reading");
else
throw new Exception(
"EOF while reading, starting at line " + firstline);
}
if(ch == delim)
break;
IFn macroFn = getMacro(ch);
if(macroFn != null)
{
Object mret = macroFn.invoke(r, (char) ch);
//no op macros return the reader
if(mret != r)
a.add(mret);
}
else
{
unread(r, ch);
Object o = read(r, true, null, isRecursive);
if(o != r)
a.add(o);
}
}
return a;
}
/*
public static void main(String[] args)
throws Exception{
//RT.init();
PushbackReader rdr =
new PushbackReader( new java.io.StringReader( "(+ 21 21)" ) );
Object input = LispReader.read(rdr, false, new Object(), f alse );
System.out.println(Compiler.eval(input));
}
public static void main(String[] args){
LineNumberingPushbackReader r =
new LineNumberingPushbackReader(
new InputStreamReader(System.in));
836 CHAPTER 9. JVM/CLOJURE/LANG/
OutputStreamWriter w = new OutputStreamWriter(System.ou t);
Object ret = null;
try
{
for(; ;)
{
ret = LispReader.read(r, true, null, false);
RT.print(ret, w);
w.write(’\n’);
if(ret != null)
w.write(ret.getClass().toString());
w.write(’\n’);
w.flush();
}
}
catch(Exception e)
{
e.printStackTrace();
}
}
*/
}
———-
9.69 LockingTransaction.java
— LockingTransaction.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 26, 2007 */
package clojure.lang;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.CountDownLatch;
@SuppressWarnings({"SynchronizeOnNonFinalField"})
public class LockingTransaction{
9.69. LOCKINGTRANSACTION.JAVA 837
public static final int RETRY_LIMIT = 10000;
public static final int LOCK_WAIT_MSECS = 100;
public static final long BARGE_WAIT_NANOS = 10 * 1000000;
//public static int COMMUTE_RETRY_LIMIT = 10;
static final int RUNNING = 0;
static final int COMMITTING = 1;
static final int RETRY = 2;
static final int KILLED = 3;
static final int COMMITTED = 4;
final static ThreadLocal<LockingTransaction> transacti on =
new ThreadLocal<LockingTransaction>();
static class RetryEx extends Error{
}
static class AbortException extends Exception{
}
public static class Info{
final AtomicInteger status;
final long startPoint;
final CountDownLatch latch;
public Info(int status, long startPoint){
this.status = new AtomicInteger(status);
this.startPoint = startPoint;
this.latch = new CountDownLatch(1);
}
public boolean running(){
int s = status.get();
return s == RUNNING || s == COMMITTING;
}
}
static class CFn{
final IFn fn;
final ISeq args;
public CFn(IFn fn, ISeq args){
this.fn = fn;
this.args = args;
}
}
//total order on transactions
838 CHAPTER 9. JVM/CLOJURE/LANG/
//transactions will consume a point for init, for each retry ,
//and on commit if writing
final private static AtomicLong lastPoint = new AtomicLong ();
void getReadPoint(){
readPoint = lastPoint.incrementAndGet();
}
long getCommitPoint(){
return lastPoint.incrementAndGet();
}
void stop(int status){
if(info != null)
{
synchronized(info)
{
info.status.set(status);
info.latch.countDown();
}
info = null;
vals.clear();
sets.clear();
commutes.clear();
//actions.clear();
}
}
Info info;
long readPoint;
long startPoint;
long startTime;
final RetryEx retryex = new RetryEx();
final ArrayList<Agent.Action> actions = new ArrayList<Ag ent.Action>();
final HashMap<Ref, Object> vals = new HashMap<Ref, Object> ();
final HashSet<Ref> sets = new HashSet<Ref>();
final TreeMap<Ref, ArrayList<CFn>> commutes =
new TreeMap<Ref, ArrayList<CFn>>();
final HashSet<Ref> ensures = new HashSet<Ref>(); //all hol d readLock
void tryWriteLock(Ref ref){
try
{
if(!ref.lock
.writeLock()
.tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
throw retryex;
9.69. LOCKINGTRANSACTION.JAVA 839
}
catch(InterruptedException e)
{
throw retryex;
}
}
//returns the most recent val
Object lock(Ref ref){
//can’t upgrade readLock, so release it
releaseIfEnsured(ref);
boolean unlocked = true;
try
{
tryWriteLock(ref);
unlocked = false;
if(ref.tvals != null && ref.tvals.point > readPoint)
throw retryex;
Info refinfo = ref.tinfo;
//write lock conflict
if(refinfo != null && refinfo != info && refinfo.running())
{
if(!barge(refinfo))
{
ref.lock.writeLock().unlock();
unlocked = true;
return blockAndBail(refinfo);
}
}
ref.tinfo = info;
return ref.tvals == null ? null : ref.tvals.val;
}
finally
{
if(!unlocked)
ref.lock.writeLock().unlock();
}
}
private Object blockAndBail(Info refinfo){
//stop prior to blocking
stop(RETRY);
try
{
refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLIS ECONDS);
}
catch(InterruptedException e)
840 CHAPTER 9. JVM/CLOJURE/LANG/
{
//ignore
}
throw retryex;
}
private void releaseIfEnsured(Ref ref){
if(ensures.contains(ref))
{
ensures.remove(ref);
ref.lock.readLock().unlock();
}
}
void abort() throws AbortException{
stop(KILLED);
throw new AbortException();
}
private boolean bargeTimeElapsed(){
return System.nanoTime() - startTime > BARGE_WAIT_NANOS;
}
private boolean barge(Info refinfo){
boolean barged = false;
//if this transaction is older
// try to abort the other
if(bargeTimeElapsed() && startPoint < refinfo.startPoin t)
{
barged = refinfo.status.compareAndSet(RUNNING, KILLED) ;
if(barged)
refinfo.latch.countDown();
}
return barged;
}
static LockingTransaction getEx(){
LockingTransaction t = transaction.get();
if(t == null || t.info == null)
throw new IllegalStateException("No transaction running ");
return t;
}
static public boolean isRunning(){
return getRunning() != null;
}
static LockingTransaction getRunning(){
LockingTransaction t = transaction.get();
if(t == null || t.info == null)
9.69. LOCKINGTRANSACTION.JAVA 841
return null;
return t;
}
static public Object runInTransaction(Callable fn) throw s Exception{
LockingTransaction t = transaction.get();
if(t == null)
transaction.set(t = new LockingTransaction());
if(t.info != null)
return fn.call();
return t.run(fn);
}
static class Notify{
final public Ref ref;
final public Object oldval;
final public Object newval;
Notify(Ref ref, Object oldval, Object newval){
this.ref = ref;
this.oldval = oldval;
this.newval = newval;
}
}
Object run(Callable fn) throws Exception{
boolean done = false;
Object ret = null;
ArrayList<Ref> locked = new ArrayList<Ref>();
ArrayList<Notify> notify = new ArrayList<Notify>();
for(int i = 0; !done && i < RETRY_LIMIT; i++)
{
try
{
getReadPoint();
if(i == 0)
{
startPoint = readPoint;
startTime = System.nanoTime();
}
info = new Info(RUNNING, startPoint);
ret = fn.call();
//make sure no one has killed us before this point,
//and can’t from now on
if(info.status.compareAndSet(RUNNING, COMMITTING))
{
for(Map.Entry<Ref, ArrayList<CFn>> e
842 CHAPTER 9. JVM/CLOJURE/LANG/
: commutes.entrySet())
{
Ref ref = e.getKey();
if(sets.contains(ref)) continue;
boolean wasEnsured = ensures.contains(ref);
//can’t upgrade readLock, so release it
releaseIfEnsured(ref);
tryWriteLock(ref);
locked.add(ref);
if(wasEnsured && ref.tvals != null &&
ref.tvals.point > readPoint)
throw retryex;
Info refinfo = ref.tinfo;
if(refinfo != null &&
refinfo != info &&
refinfo.running())
{
if(!barge(refinfo))
throw retryex;
}
Object val =
ref.tvals == null ? null : ref.tvals.val;
vals.put(ref, val);
for(CFn f : e.getValue())
{
vals.put(ref,
f.fn.applyTo(
RT.cons(vals.get(ref), f.args)));
}
}
for(Ref ref : sets)
{
tryWriteLock(ref);
locked.add(ref);
}
//validate and enqueue notifications
for(Map.Entry<Ref, Object> e : vals.entrySet())
{
Ref ref = e.getKey();
ref.validate(ref.getValidator(), e.getValue());
}
//at this point, all values calced, all refs to
//be written locked
//no more client code to be called
long msecs = System.currentTimeMillis();
long commitPoint = getCommitPoint();
9.69. LOCKINGTRANSACTION.JAVA 843
for(Map.Entry<Ref, Object> e : vals.entrySet())
{
Ref ref = e.getKey();
Object oldval =
ref.tvals == null ? null : ref.tvals.val;
Object newval = e.getValue();
int hcount = ref.histCount();
if(ref.tvals == null)
{
ref.tvals =
new Ref.TVal(newval, commitPoint, msecs);
}
else if((ref.faults.get() > 0 &&
hcount < ref.maxHistory) ||
hcount < ref.minHistory)
{
ref.tvals =
new Ref.TVal(newval,
commitPoint,
msecs,
ref.tvals);
ref.faults.set(0);
}
else
{
ref.tvals = ref.tvals.next;
ref.tvals.val = newval;
ref.tvals.point = commitPoint;
ref.tvals.msecs = msecs;
}
if(ref.getWatches().count() > 0)
notify.add(new Notify(ref, oldval, newval));
}
done = true;
info.status.set(COMMITTED);
}
}
catch(RetryEx retry)
{
//eat this so we retry rather than fall out
}
finally
{
for(int k = locked.size() - 1; k >= 0; --k)
{
locked.get(k).lock.writeLock().unlock();
}
locked.clear();
844 CHAPTER 9. JVM/CLOJURE/LANG/
for(Ref r : ensures)
{
r.lock.readLock().unlock();
}
ensures.clear();
stop(done ? COMMITTED : RETRY);
try
{
if(done) //re-dispatch out of transaction
{
for(Notify n : notify)
{
n.ref.notifyWatches(n.oldval, n.newval);
}
for(Agent.Action action : actions)
{
Agent.dispatchAction(action);
}
}
}
finally
{
notify.clear();
actions.clear();
}
}
}
if(!done)
throw new Exception(
"Transaction failed after reaching retry limit");
return ret;
}
public void enqueue(Agent.Action action){
actions.add(action);
}
Object doGet(Ref ref){
if(!info.running())
throw retryex;
if(vals.containsKey(ref))
return vals.get(ref);
try
{
ref.lock.readLock().lock();
if(ref.tvals == null)
throw new IllegalStateException(
ref.toString() + " is unbound.");
Ref.TVal ver = ref.tvals;
do
9.69. LOCKINGTRANSACTION.JAVA 845
{
if(ver.point <= readPoint)
return ver.val;
} while((ver = ver.prior) != ref.tvals);
}
finally
{
ref.lock.readLock().unlock();
}
//no version of val precedes the read point
ref.faults.incrementAndGet();
throw retryex;
}
Object doSet(Ref ref, Object val){
if(!info.running())
throw retryex;
if(commutes.containsKey(ref))
throw new IllegalStateException("Can’t set after commute ");
if(!sets.contains(ref))
{
sets.add(ref);
lock(ref);
}
vals.put(ref, val);
return val;
}
void doEnsure(Ref ref){
if(!info.running())
throw retryex;
if(ensures.contains(ref))
return;
ref.lock.readLock().lock();
//someone completed a write after our snapshot
if(ref.tvals != null && ref.tvals.point > readPoint) {
ref.lock.readLock().unlock();
throw retryex;
}
Info refinfo = ref.tinfo;
//writer exists
if(refinfo != null && refinfo.running())
{
ref.lock.readLock().unlock();
if(refinfo != info) //not us, ensure is doomed
846 CHAPTER 9. JVM/CLOJURE/LANG/
{
blockAndBail(refinfo);
}
}
else
ensures.add(ref);
}
Object doCommute(Ref ref, IFn fn, ISeq args) throws Excepti on{
if(!info.running())
throw retryex;
if(!vals.containsKey(ref))
{
Object val = null;
try
{
ref.lock.readLock().lock();
val = ref.tvals == null ? null : ref.tvals.val;
}
finally
{
ref.lock.readLock().unlock();
}
vals.put(ref, val);
}
ArrayList<CFn> fns = commutes.get(ref);
if(fns == null)
commutes.put(ref, fns = new ArrayList<CFn>());
fns.add(new CFn(fn, args));
Object ret = fn.applyTo(RT.cons(vals.get(ref), args));
vals.put(ref, ret);
return ret;
}
/*
//for test
static CyclicBarrier barrier;
static ArrayList<Ref> items;
public static void main(String[] args){
try
{
if(args.length != 4)
System.err.println(
"Usage: LockingTransaction nthreads nitems niters ninsta nces");
int nthreads = Integer.parseInt(args[0]);
int nitems = Integer.parseInt(args[1]);
int niters = Integer.parseInt(args[2]);
int ninstances = Integer.parseInt(args[3]);
9.69. LOCKINGTRANSACTION.JAVA 847
if(items == null)
{
ArrayList<Ref> temp = new ArrayList(nitems);
for(int i = 0; i < nitems; i++)
temp.add(new Ref(0));
items = temp;
}
class Incr extends AFn{
public Object invoke(Object arg1) throws Exception{
Integer i = (Integer) arg1;
return i + 1;
}
public Obj withMeta(IPersistentMap meta){
throw new UnsupportedOperationException();
}
}
class Commuter extends AFn implements Callable{
int niters;
List<Ref> items;
Incr incr;
public Commuter(int niters, List<Ref> items){
this.niters = niters;
this.items = items;
this.incr = new Incr();
}
public Object call() throws Exception{
long nanos = 0;
for(int i = 0; i < niters; i++)
{
long start = System.nanoTime();
LockingTransaction.runInTransaction(this);
nanos += System.nanoTime() - start;
}
return nanos;
}
public Object invoke() throws Exception{
for(Ref tref : items)
{
LockingTransaction.getEx().doCommute(tref, incr);
}
return null;
}
848 CHAPTER 9. JVM/CLOJURE/LANG/
public Obj withMeta(IPersistentMap meta){
throw new UnsupportedOperationException();
}
}
class Incrementer extends AFn implements Callable{
int niters;
List<Ref> items;
public Incrementer(int niters, List<Ref> items){
this.niters = niters;
this.items = items;
}
public Object call() throws Exception{
long nanos = 0;
for(int i = 0; i < niters; i++)
{
long start = System.nanoTime();
LockingTransaction.runInTransaction(this);
nanos += System.nanoTime() - start;
}
return nanos;
}
public Object invoke() throws Exception{
for(Ref tref : items)
{
//Transaction.get().doTouch(tref);
// LockingTransaction t = LockingTransaction.getEx();
// int val = (Integer) t.doGet(tref);
// t.doSet(tref, val + 1);
int val = (Integer) tref.get();
tref.set(val + 1);
}
return null;
}
public Obj withMeta(IPersistentMap meta){
throw new UnsupportedOperationException();
}
}
ArrayList<Callable<Long>> tasks = new ArrayList(nthread s);
for(int i = 0; i < nthreads; i++)
{
9.69. LOCKINGTRANSACTION.JAVA 849
ArrayList<Ref> si;
synchronized(items)
{
si = (ArrayList<Ref>) items.clone();
}
Collections.shuffle(si);
tasks.add(new Incrementer(niters, si));
//tasks.add(new Commuter(niters, si));
}
ExecutorService e = Executors.newFixedThreadPool(nthre ads);
if(barrier == null)
barrier = new CyclicBarrier(ninstances);
System.out.println("waiting for other instances...");
barrier.await();
System.out.println("starting");
long start = System.nanoTime();
List<Future<Long>> results = e.invokeAll(tasks);
long estimatedTime = System.nanoTime() - start;
System.out.printf(
"nthreads: %d, nitems: %d, niters: %d, time: %d%n",
nthreads, nitems, niters, estimatedTime / 1000000);
e.shutdown();
for(Future<Long> result : results)
{
System.out.printf("%d, ", result.get() / 1000000);
}
System.out.println();
System.out.println("waiting for other instances...");
barrier.await();
synchronized(items)
{
for(Ref item : items)
{
System.out.printf("%d, ", (Integer) item.currentVal()) ;
}
}
System.out.println("\ndone");
System.out.flush();
}
catch(Exception ex)
{
ex.printStackTrace();
}
}
*/
}
———-
850 CHAPTER 9. JVM/CLOJURE/LANG/
9.70 MapEntry.java
(AMapEntry [527])
— MapEntry.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.util.Iterator;
public class MapEntry extends AMapEntry{
final Object _key;
final Object _val;
public MapEntry(Object key, Object val){
this._key = key;
this._val = val;
}
public Object key(){
return _key;
}
public Object val(){
return _val;
}
public Object getKey(){
return key();
}
public Object getValue(){
return val();
}
}
———-
9.71 MapEquivalence.java
— MapEquivalence.java —
/*
9.72. METHODIMPLCACHE.JAVA 851
\getchunk{Clojure Copyright}
*/
/* rich Aug 4, 2010 */
package clojure.lang;
//marker interface
public interface MapEquivalence{
}
———-
9.72 MethodImplCache.java
— MethodImplCache.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Nov 8, 2009 */
package clojure.lang;
public final class MethodImplCache{
static public class Entry{
final public Class c;
final public IFn fn;
public Entry(Class c, IFn fn){
this.c = c;
this.fn = fn;
}
}
public final IPersistentMap protocol;
public final Keyword methodk;
public final int shift;
public final int mask;
public final Object[] table; //[class, entry. class, entry ...]
Entry mre = null;
public MethodImplCache(IPersistentMap protocol, Keywor d methodk){
this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY);
}
852 CHAPTER 9. JVM/CLOJURE/LANG/
public MethodImplCache(IPersistentMap protocol,
Keyword methodk,
int shift,
int mask,
Object[] table){
this.protocol = protocol;
this.methodk = methodk;
this.shift = shift;
this.mask = mask;
this.table = table;
}
public IFn fnFor(Class c){
Entry last = mre;
if(last != null && last.c == c)
return last.fn;
return findFnFor(c);
}
IFn findFnFor(Class c){
int idx = ((Util.hash(c) >> shift) & mask) << 1;
if(idx < table.length && table[idx] == c)
{
Entry e = ((Entry) table[idx + 1]);
mre = e;
return e != null ? e.fn : null;
}
return null;
}
}
———-
9.73 MultiFn.java
(AFn [509])
— MultiFn.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Sep 13, 2007 */
package clojure.lang;
import java.util.Map;
9.73. MULTIFN.JAVA 853
public class MultiFn extends AFn{
final public IFn dispatchFn;
final public Object defaultDispatchVal;
final public IRef hierarchy;
final String name;
IPersistentMap methodTable;
IPersistentMap preferTable;
IPersistentMap methodCache;
Object cachedHierarchy;
static final Var assoc = RT.var("clojure.core", "assoc");
static final Var dissoc = RT.var("clojure.core", "dissoc" );
static final Var isa = RT.var("clojure.core", "isa?");
static final Var parents = RT.var("clojure.core", "parent s");
public MultiFn(String name,
IFn dispatchFn,
Object defaultDispatchVal,
IRef hierarchy) throws Exception{
this.name = name;
this.dispatchFn = dispatchFn;
this.defaultDispatchVal = defaultDispatchVal;
this.methodTable = PersistentHashMap.EMPTY;
this.methodCache = getMethodTable();
this.preferTable = PersistentHashMap.EMPTY;
this.hierarchy = hierarchy;
cachedHierarchy = null;
}
synchronized public MultiFn reset(){
methodTable = methodCache
= preferTable
= PersistentHashMap.EMPTY;
cachedHierarchy = null;
return this;
}
synchronized public MultiFn addMethod(Object dispatchVa l,
IFn method)
throws Exception{
methodTable = getMethodTable().assoc(dispatchVal, meth od);
resetCache();
return this;
}
synchronized public MultiFn removeMethod(Object dispatc hVal)
throws Exception{
methodTable = getMethodTable().without(dispatchVal);
resetCache();
854 CHAPTER 9. JVM/CLOJURE/LANG/
return this;
}
synchronized public MultiFn preferMethod(Object dispatc hValX,
Object dispatchValY)
throws Exception{
if(prefers(dispatchValY, dispatchValX))
throw new IllegalStateException(
String.format("Preference conflict in multimethod ’%s’: "+
" %s is already preferred to %s",
name, dispatchValY, dispatchValX));
preferTable =
getPreferTable().assoc(dispatchValX,
RT.conj((IPersistentCollection)
RT.get(getPreferTable(),
dispatchValX,
PersistentHashSet.EMPTY),
dispatchValY));
resetCache();
return this;
}
private boolean prefers(Object x, Object y) throws Excepti on{
IPersistentSet xprefs =
(IPersistentSet) getPreferTable().valAt(x);
if(xprefs != null && xprefs.contains(y))
return true;
for(ISeq ps = RT.seq(parents.invoke(y));
ps != null;
ps = ps.next())
{
if(prefers(x, ps.first()))
return true;
}
for(ISeq ps = RT.seq(parents.invoke(x));
ps != null;
ps = ps.next())
{
if(prefers(ps.first(), y))
return true;
}
return false;
}
private boolean isA(Object x, Object y) throws Exception{
return RT.booleanCast(isa.invoke(hierarchy.deref(), x , y));
}
private boolean dominates(Object x, Object y) throws Excep tion{
return prefers(x, y) || isA(x, y);
9.73. MULTIFN.JAVA 855
}
private IPersistentMap resetCache() throws Exception{
methodCache = getMethodTable();
cachedHierarchy = hierarchy.deref();
return methodCache;
}
synchronized public IFn getMethod(Object dispatchVal) th rows Exception{
if(cachedHierarchy != hierarchy.deref())
resetCache();
IFn targetFn = (IFn) methodCache.valAt(dispatchVal);
if(targetFn != null)
return targetFn;
targetFn = findAndCacheBestMethod(dispatchVal);
if(targetFn != null)
return targetFn;
targetFn = (IFn) getMethodTable().valAt(defaultDispatc hVal);
return targetFn;
}
private IFn getFn(Object dispatchVal) throws Exception{
IFn targetFn = getMethod(dispatchVal);
if(targetFn == null)
throw new IllegalArgumentException(
String.format("No method in multimethod ’%s’ "+
"for dispatch value: %s",
name, dispatchVal));
return targetFn;
}
private IFn findAndCacheBestMethod(Object dispatchVal)
throws Exception{
Map.Entry bestEntry = null;
for(Object o : getMethodTable())
{
Map.Entry e = (Map.Entry) o;
if(isA(dispatchVal, e.getKey()))
{
if(bestEntry == null ||
dominates(e.getKey(), bestEntry.getKey()))
bestEntry = e;
if(!dominates(bestEntry.getKey(), e.getKey()))
throw new IllegalArgumentException(
String.format(
"Multiple methods in multimethod ’%s’ match "+
"dispatch value: %s -> %s and %s, and "+
"neither is preferred",
name, dispatchVal, e.getKey(), bestEntry.getKey()));
}
856 CHAPTER 9. JVM/CLOJURE/LANG/
}
if(bestEntry == null)
return null;
//ensure basis has stayed stable throughout, else redo
if(cachedHierarchy == hierarchy.deref())
{
//place in cache
methodCache =
methodCache.assoc(dispatchVal, bestEntry.getValue()) ;
return (IFn) bestEntry.getValue();
}
else
{
resetCache();
return findAndCacheBestMethod(dispatchVal);
}
}
public Object invoke()
throws Exception{
return getFn(dispatchFn.invoke()).invoke();
}
public Object invoke(Object arg1)
throws Exception{
return getFn(dispatchFn.invoke(arg1)).invoke(arg1);
}
public Object invoke(Object arg1, Object arg2)
throws Exception{
return getFn(dispatchFn.invoke(arg1, arg2)).invoke(ar g1, arg2);
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
return getFn(dispatchFn.invoke(arg1, arg2, arg3))
.invoke(arg1, arg2, arg3);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4))
.invoke(arg1, arg2, arg3, arg4);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
return getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, a rg5))
9.73. MULTIFN.JAVA 857
.invoke(arg1, arg2, arg3, arg4, arg5);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10);
}
858 CHAPTER 9. JVM/CLOJURE/LANG/
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14);
}
9.73. MULTIFN.JAVA 859
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
860 CHAPTER 9. JVM/CLOJURE/LANG/
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
arg18);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
9.74. NAMED.JAVA 861
Object arg19, Object arg20, Object... args)
throws Exception{
return getFn(
dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20, args))
.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg 9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20, args);
}
public IPersistentMap getMethodTable() {
return methodTable;
}
public IPersistentMap getPreferTable() {
return preferTable;
}
}
———-
9.74 Named.java
— Named.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Sep 20, 2007 */
package clojure.lang;
public interface Named{
String getNamespace();
String getName();
}
———-
9.75 Namespace.java
(AReference [552]) (Serializable [1723])
— Namespace.java —
862 CHAPTER 9. JVM/CLOJURE/LANG/
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 23, 2008 */
package clojure.lang;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
public class Namespace extends AReference implements Seri alizable {
final public Symbol name;
transient final AtomicReference<IPersistentMap> mappin gs =
new AtomicReference<IPersistentMap>();
transient final AtomicReference<IPersistentMap> aliase s =
new AtomicReference<IPersistentMap>();
final static ConcurrentHashMap<Symbol, Namespace> names paces =
new ConcurrentHashMap<Symbol, Namespace>();
public String toString(){
return name.toString();
}
Namespace(Symbol name){
super(name.meta());
this.name = name;
mappings.set(RT.DEFAULT_IMPORTS);
aliases.set(RT.map());
}
public static ISeq all(){
return RT.seq(namespaces.values());
}
public Symbol getName(){
return name;
}
public IPersistentMap getMappings(){
return mappings.get();
}
public Var intern(Symbol sym){
if(sym.ns != null)
{
throw new IllegalArgumentException(
"Can’t intern namespace-qualified symbol");
9.75. NAMESPACE.JAVA 863
}
IPersistentMap map = getMappings();
Object o;
Var v = null;
while((o = map.valAt(sym)) == null)
{
if(v == null)
v = new Var(this, sym);
IPersistentMap newMap = map.assoc(sym, v);
mappings.compareAndSet(map, newMap);
map = getMappings();
}
if(o instanceof Var && ((Var) o).ns == this)
return (Var) o;
if(v == null)
v = new Var(this, sym);
warnOrFailOnReplace(sym, o, v);
while(!mappings.compareAndSet(map, map.assoc(sym, v)) )
map = getMappings();
return v;
}
private void warnOrFailOnReplace(Symbol sym, Object o, Ob ject v){
if (o instanceof Var)
{
Namespace ns = ((Var)o).ns;
if (ns == this)
return;
if (ns != RT.CLOJURE_NS)
throw new IllegalStateException(
sym + " already refers to: " + o +
" in namespace: " + name);
}
RT.errPrintWriter().println("WARNING: " + sym +
" already refers to: " + o + " in namespace: " + name
+ ", being replaced by: " + v);
}
Object reference(Symbol sym, Object val){
if(sym.ns != null)
{
throw new IllegalArgumentException(
"Can’t intern namespace-qualified symbol");
}
IPersistentMap map = getMappings();
864 CHAPTER 9. JVM/CLOJURE/LANG/
Object o;
while((o = map.valAt(sym)) == null)
{
IPersistentMap newMap = map.assoc(sym, val);
mappings.compareAndSet(map, newMap);
map = getMappings();
}
if(o == val)
return o;
warnOrFailOnReplace(sym, o, val);
while(!mappings.compareAndSet(map, map.assoc(sym, val )))
map = getMappings();
return val;
}
public static boolean
areDifferentInstancesOfSameClassName(Class cls1,
Class cls2) {
return (cls1 != cls2) && (cls1.getName().equals(cls2.get Name()));
}
Class referenceClass(Symbol sym, Class val){
if(sym.ns != null)
{
throw new IllegalArgumentException(
"Can’t intern namespace-qualified symbol");
}
IPersistentMap map = getMappings();
Class c = (Class) map.valAt(sym);
while((c == null) ||
(areDifferentInstancesOfSameClassName(c, val)))
{
IPersistentMap newMap = map.assoc(sym, val);
mappings.compareAndSet(map, newMap);
map = getMappings();
c = (Class) map.valAt(sym);
}
if(c == val)
return c;
throw new IllegalStateException(sym + " already refers to: " +
c + " in namespace: " + name);
}
public void unmap(Symbol sym) throws Exception{
if(sym.ns != null)
9.75. NAMESPACE.JAVA 865
{
throw new IllegalArgumentException(
"Can’t unintern namespace-qualified symbol");
}
IPersistentMap map = getMappings();
while(map.containsKey(sym))
{
IPersistentMap newMap = map.without(sym);
mappings.compareAndSet(map, newMap);
map = getMappings();
}
}
public Class importClass(Symbol sym, Class c){
return referenceClass(sym, c);
}
public Class importClass(Class c){
String n = c.getName();
return importClass(
Symbol.intern(n.substring(n.lastIndexOf(’.’) + 1)), c) ;
}
public Var refer(Symbol sym, Var var){
return (Var) reference(sym, var);
}
public static Namespace findOrCreate(Symbol name){
Namespace ns = namespaces.get(name);
if(ns != null)
return ns;
Namespace newns = new Namespace(name);
ns = namespaces.putIfAbsent(name, newns);
return ns == null ? newns : ns;
}
public static Namespace remove(Symbol name){
if(name.equals(RT.CLOJURE_NS.name))
throw new IllegalArgumentException(
"Cannot remove clojure namespace");
return namespaces.remove(name);
}
public static Namespace find(Symbol name){
return namespaces.get(name);
}
public Object getMapping(Symbol name){
866 CHAPTER 9. JVM/CLOJURE/LANG/
return mappings.get().valAt(name);
}
public Var findInternedVar(Symbol symbol){
Object o = mappings.get().valAt(symbol);
if(o != null && o instanceof Var && ((Var) o).ns == this)
return (Var) o;
return null;
}
public IPersistentMap getAliases(){
return aliases.get();
}
public Namespace lookupAlias(Symbol alias){
IPersistentMap map = getAliases();
return (Namespace) map.valAt(alias);
}
public void addAlias(Symbol alias, Namespace ns){
if (alias == null || ns == null)
throw new NullPointerException("Expecting Symbol + Names pace");
IPersistentMap map = getAliases();
while(!map.containsKey(alias))
{
IPersistentMap newMap = map.assoc(alias, ns);
aliases.compareAndSet(map, newMap);
map = getAliases();
}
// you can rebind an alias, but only to the
// initially-aliased namespace.
if(!map.valAt(alias).equals(ns))
throw new IllegalStateException(
"Alias " + alias + " already exists in namespace "
+ name + ", aliasing " + map.valAt(alias));
}
public void removeAlias(Symbol alias) throws Exception{
IPersistentMap map = getAliases();
while(map.containsKey(alias))
{
IPersistentMap newMap = map.without(alias);
aliases.compareAndSet(map, newMap);
map = getAliases();
}
}
private Object readResolve() throws ObjectStreamExcepti on {
// ensures that serialized namespaces are "deserialized" t o the
9.76. NUMBERS.JAVA 867
// namespace in the present runtime
return findOrCreate(name);
}
}
———-
9.76 Numbers.java
— Numbers.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 31, 2008 */
package clojure.lang;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.math.MathContext;
public class Numbers{
static interface Ops{
Ops combine(Ops y);
Ops opsWith(LongOps x);
Ops opsWith(DoubleOps x);
Ops opsWith(RatioOps x);
Ops opsWith(BigIntOps x);
Ops opsWith(BigDecimalOps x);
public boolean isZero(Number x);
public boolean isPos(Number x);
public boolean isNeg(Number x);
public Number add(Number x, Number y);
public Number addP(Number x, Number y);
public Number multiply(Number x, Number y);
868 CHAPTER 9. JVM/CLOJURE/LANG/
public Number multiplyP(Number x, Number y);
public Number divide(Number x, Number y);
public Number quotient(Number x, Number y);
public Number remainder(Number x, Number y);
public boolean equiv(Number x, Number y);
public boolean lt(Number x, Number y);
public Number negate(Number x);
public Number negateP(Number x);
public Number inc(Number x);
public Number incP(Number x);
public Number dec(Number x);
public Number decP(Number x);
}
static abstract class OpsP implements Ops{
public Number addP(Number x, Number y){
return add(x, y);
}
public Number multiplyP(Number x, Number y){
return multiply(x, y);
}
public Number negateP(Number x){
return negate(x);
}
public Number incP(Number x){
return inc(x);
}
public Number decP(Number x){
return dec(x);
}
}
static interface BitOps{
BitOps combine(BitOps y);
BitOps bitOpsWith(LongBitOps x);
BitOps bitOpsWith(BigIntBitOps x);
9.76. NUMBERS.JAVA 869
public Number not(Number x);
public Number and(Number x, Number y);
public Number or(Number x, Number y);
public Number xor(Number x, Number y);
public Number andNot(Number x, Number y);
public Number clearBit(Number x, int n);
public Number setBit(Number x, int n);
public Number flipBit(Number x, int n);
public boolean testBit(Number x, int n);
public Number shiftLeft(Number x, int n);
public Number shiftRight(Number x, int n);
}
static public boolean isZero(Object x){
return ops(x).isZero((Number)x);
}
static public boolean isPos(Object x){
return ops(x).isPos((Number)x);
}
static public boolean isNeg(Object x){
return ops(x).isNeg((Number)x);
}
static public Number minus(Object x){
return ops(x).negate((Number)x);
}
static public Number minusP(Object x){
return ops(x).negateP((Number)x);
}
static public Number inc(Object x){
return ops(x).inc((Number)x);
}
static public Number incP(Object x){
870 CHAPTER 9. JVM/CLOJURE/LANG/
return ops(x).incP((Number)x);
}
static public Number dec(Object x){
return ops(x).dec((Number)x);
}
static public Number decP(Object x){
return ops(x).decP((Number)x);
}
static public Number add(Object x, Object y){
return ops(x).combine(ops(y)).add((Number)x, (Number) y);
}
static public Number addP(Object x, Object y){
return ops(x).combine(ops(y)).addP((Number)x, (Number )y);
}
static public Number minus(Object x, Object y){
Ops yops = ops(y);
return ops(x).combine(yops).add((Number)x, yops.negat e((Number)y));
}
static public Number minusP(Object x, Object y){
Ops yops = ops(y);
return ops(x).combine(yops).addP((Number)x, yops.nega teP((Number)y));
}
static public Number multiply(Object x, Object y){
return ops(x).combine(ops(y)).multiply((Number)x, (Nu mber)y);
}
static public Number multiplyP(Object x, Object y){
return ops(x).combine(ops(y)).multiplyP((Number)x, (N umber)y);
}
static public Number divide(Object x, Object y){
Ops yops = ops(y);
if(yops.isZero((Number)y))
throw new ArithmeticException("Divide by zero");
return ops(x).combine(yops).divide((Number)x, (Number )y);
}
static public Number quotient(Object x, Object y){
Ops yops = ops(y);
if(yops.isZero((Number) y))
throw new ArithmeticException("Divide by zero");
return ops(x).combine(yops).quotient((Number)x, (Numb er)y);
}
9.76. NUMBERS.JAVA 871
static public Number remainder(Object x, Object y){
Ops yops = ops(y);
if(yops.isZero((Number) y))
throw new ArithmeticException("Divide by zero");
return ops(x).combine(yops).remainder((Number)x, (Num ber)y);
}
static public double quotient(double n, double d){
if(d == 0)
throw new ArithmeticException("Divide by zero");
double q = n / d;
if(q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
{
return (double)(long) q;
}
else
{ //bigint quotient
return new BigDecimal(q).toBigInteger().doubleValue() ;
}
}
static public double remainder(double n, double d){
if(d == 0)
throw new ArithmeticException("Divide by zero");
double q = n / d;
if(q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
{
return (n - ((long) q) * d);
}
else
{ //bigint quotient
Number bq = new BigDecimal(q).toBigInteger();
return (n - bq.doubleValue() * d);
}
}
static public boolean equiv(Object x, Object y){
return equiv((Number) x, (Number) y);
}
static public boolean equiv(Number x, Number y){
return ops(x).combine(ops(y)).equiv(x, y);
}
static public boolean equal(Number x, Number y){
return category(x) == category(y)
&& ops(x).combine(ops(y)).equiv(x, y);
872 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public boolean lt(Object x, Object y){
return ops(x).combine(ops(y)).lt((Number)x, (Number)y );
}
static public boolean lte(Object x, Object y){
return !ops(x).combine(ops(y)).lt((Number)y, (Number) x);
}
static public boolean gt(Object x, Object y){
return ops(x).combine(ops(y)).lt((Number)y, (Number)x );
}
static public boolean gte(Object x, Object y){
return !ops(x).combine(ops(y)).lt((Number)x, (Number) y);
}
static public int compare(Number x, Number y){
Ops ops = ops(x).combine(ops(y));
if(ops.lt(x, y))
return -1;
else if(ops.lt(y, x))
return 1;
return 0;
}
static BigInt toBigInt(Object x){
if(x instanceof BigInt)
return (BigInt) x;
if(x instanceof BigInteger)
return BigInt.fromBigInteger((BigInteger) x);
else
return BigInt.fromLong(((Number) x).longValue());
}
static BigInteger toBigInteger(Object x){
if(x instanceof BigInteger)
return (BigInteger) x;
else if(x instanceof BigInt)
return ((BigInt) x).toBigInteger();
else
return BigInteger.valueOf(((Number) x).longValue());
}
static BigDecimal toBigDecimal(Object x){
if(x instanceof BigDecimal)
return (BigDecimal) x;
else if(x instanceof BigInt)
{
9.76. NUMBERS.JAVA 873
BigInt bi = (BigInt) x;
if(bi.bipart == null)
return BigDecimal.valueOf(bi.lpart);
else
return new BigDecimal(bi.bipart);
}
else if(x instanceof BigInteger)
return new BigDecimal((BigInteger) x);
else if(x instanceof Double)
return new BigDecimal(((Number) x).doubleValue());
else if(x instanceof Float)
return new BigDecimal(((Number) x).doubleValue());
else if(x instanceof Ratio)
{
Ratio r = (Ratio)x;
return (BigDecimal)divide(new BigDecimal(r.numerator) ,
r.denominator);
}
else
return BigDecimal.valueOf(((Number) x).longValue());
}
static public Ratio toRatio(Object x){
if(x instanceof Ratio)
return (Ratio) x;
else if(x instanceof BigDecimal)
{
BigDecimal bx = (BigDecimal) x;
BigInteger bv = bx.unscaledValue();
int scale = bx.scale();
if(scale < 0)
return
new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)),
BigInteger.ONE);
else
return new Ratio(bv, BigInteger.TEN.pow(scale));
}
return new Ratio(toBigInteger(x), BigInteger.ONE);
}
static public Number rationalize(Number x){
if(x instanceof Float || x instanceof Double)
return rationalize(BigDecimal.valueOf(x.doubleValue( )));
else if(x instanceof BigDecimal)
{
BigDecimal bx = (BigDecimal) x;
BigInteger bv = bx.unscaledValue();
int scale = bx.scale();
if(scale < 0)
return
874 CHAPTER 9. JVM/CLOJURE/LANG/
BigInt.fromBigInteger(
bv.multiply(BigInteger.TEN.pow(-scale)));
else
return divide(bv, BigInteger.TEN.pow(scale));
}
return x;
}
//static Number box(int val){
// return Integer.valueOf(val);
//}
//static Number box(long val){
// return Long.valueOf(val);
//}
//
//static Double box(double val){
// return Double.valueOf(val);
//}
//
//static Double box(float val){
// return Double.valueOf((double) val);
//}
static public Number reduceBigInt(BigInt val){
if(val.bipart == null)
return num(val.lpart);
else
return val.bipart;
}
static public Number divide(BigInteger n, BigInteger d){
if(d.equals(BigInteger.ZERO))
throw new ArithmeticException("Divide by zero");
BigInteger gcd = n.gcd(d);
if(gcd.equals(BigInteger.ZERO))
return BigInt.ZERO;
n = n.divide(gcd);
d = d.divide(gcd);
if(d.equals(BigInteger.ONE))
return BigInt.fromBigInteger(n);
else if(d.equals(BigInteger.ONE.negate()))
return BigInt.fromBigInteger(n.negate());
return new Ratio((d.signum() < 0 ? n.negate() : n),
(d.signum() < 0 ? d.negate() : d));
}
static public Number not(Object x){
return bitOps(x).not((Number)x);
}
9.76. NUMBERS.JAVA 875
static public Number and(Object x, Object y){
return bitOps(x).combine(bitOps(y)).and((Number)x, (N umber)y);
}
static public Number or(Object x, Object y){
return bitOps(x).combine(bitOps(y)).or((Number)x, (Nu mber)y);
}
static public Number xor(Object x, Object y){
return bitOps(x).combine(bitOps(y)).xor((Number)x, (N umber)y);
}
static public Number andNot(Number x, Number y){
return bitOps(x).combine(bitOps(y)).andNot(x, y);
}
static public Number clearBit(Number x, int n){
if(n < 0)
throw new ArithmeticException("Negative bit index");
return bitOps(x).clearBit(x, n);
}
static public Number setBit(Number x, int n){
if(n < 0)
throw new ArithmeticException("Negative bit index");
return bitOps(x).setBit(x, n);
}
static public Number flipBit(Number x, int n){
if(n < 0)
throw new ArithmeticException("Negative bit index");
return bitOps(x).flipBit(x, n);
}
static public boolean testBit(Number x, int n){
if(n < 0)
throw new ArithmeticException("Negative bit index");
return bitOps(x).testBit(x, n);
}
static public Number shiftLeft(Object x, Object n){
return bitOps(x).shiftLeft((Number)x, ((Number)n).int Value());
}
static public int shiftLeftInt(int x, int n){
return x << n;
}
876 CHAPTER 9. JVM/CLOJURE/LANG/
static public long shiftLeft(long x, int n){
if(n < 0)
return shiftRight(x, -n);
return x << n;
}
static public Number shiftRight(Object x, Object n){
return bitOps(x).shiftRight((Number)x, ((Number)n).in tValue());
}
static public int shiftRightInt(int x, int n){
return x >> n;
}
static public long shiftRight(long x, int n){
if(n < 0)
return shiftLeft(x, -n);
return x >> n;
}
final static class LongOps implements Ops{
public Ops combine(Ops y){
return y.opsWith(this);
}
final public Ops opsWith(LongOps x){
return this;
}
final public Ops opsWith(DoubleOps x){
return DOUBLE_OPS;
}
final public Ops opsWith(RatioOps x){
return RATIO_OPS;
}
final public Ops opsWith(BigIntOps x){
return BIGINT_OPS;
}
final public Ops opsWith(BigDecimalOps x){
return BIGDECIMAL_OPS;
}
public boolean isZero(Number x){
return x.longValue() == 0;
}
public boolean isPos(Number x){
9.76. NUMBERS.JAVA 877
return x.longValue() > 0;
}
public boolean isNeg(Number x){
return x.longValue() < 0;
}
final public Number add(Number x, Number y){
return num(Numbers.add(x.longValue(),y.longValue())) ;
}
final public Number addP(Number x, Number y){
long lx = x.longValue(), ly = y.longValue();
long ret = lx + ly;
if ((ret ^ lx) < 0 && (ret ^ ly) < 0)
return BIGINT_OPS.add(x, y);
return num(ret);
}
final public Number multiply(Number x, Number y){
return num(Numbers.multiply(x.longValue(), y.longValu e()));
}
final public Number multiplyP(Number x, Number y){
long lx = x.longValue(), ly = y.longValue();
long ret = lx * ly;
if (ly != 0 && ret/ly != lx)
return BIGINT_OPS.multiply(x, y);
return num(ret);
}
static long gcd(long u, long v){
while(v != 0)
{
long r = u % v;
u = v;
v = r;
}
return u;
}
public Number divide(Number x, Number y){
long n = x.longValue();
long val = y.longValue();
long gcd = gcd(n, val);
if(gcd == 0)
return num(0);
n = n / gcd;
long d = val / gcd;
if(d == 1)
878 CHAPTER 9. JVM/CLOJURE/LANG/
return num(n);
if(d < 0)
{
n = -n;
d = -d;
}
return new Ratio(BigInteger.valueOf(n), BigInteger.val ueOf(d));
}
public Number quotient(Number x, Number y){
return num(x.longValue() / y.longValue());
}
public Number remainder(Number x, Number y){
return num(x.longValue() % y.longValue());
}
public boolean equiv(Number x, Number y){
return x.longValue() == y.longValue();
}
public boolean lt(Number x, Number y){
return x.longValue() < y.longValue();
}
//public Number subtract(Number x, Number y);
final public Number negate(Number x){
long val = x.longValue();
return num(Numbers.minus(val));
}
final public Number negateP(Number x){
long val = x.longValue();
if(val > Long.MIN_VALUE)
return num(-val);
return BigInt.fromBigInteger(BigInteger.valueOf(val) .negate());
}
public Number inc(Number x){
long val = x.longValue();
return num(Numbers.inc(val));
}
public Number incP(Number x){
long val = x.longValue();
if(val < Long.MAX_VALUE)
return num(val + 1);
return BIGINT_OPS.inc(x);
}
public Number dec(Number x){
9.76. NUMBERS.JAVA 879
long val = x.longValue();
return num(Numbers.dec(val));
}
public Number decP(Number x){
long val = x.longValue();
if(val > Long.MIN_VALUE)
return num(val - 1);
return BIGINT_OPS.dec(x);
}
}
final static class DoubleOps extends OpsP{
public Ops combine(Ops y){
return y.opsWith(this);
}
final public Ops opsWith(LongOps x){
return this;
}
final public Ops opsWith(DoubleOps x){
return this;
}
final public Ops opsWith(RatioOps x){
return this;
}
final public Ops opsWith(BigIntOps x){
return this;
}
final public Ops opsWith(BigDecimalOps x){
return this;
}
public boolean isZero(Number x){
return x.doubleValue() == 0;
}
public boolean isPos(Number x){
return x.doubleValue() > 0;
}
public boolean isNeg(Number x){
return x.doubleValue() < 0;
}
final public Number add(Number x, Number y){
880 CHAPTER 9. JVM/CLOJURE/LANG/
return Double.valueOf(x.doubleValue() + y.doubleValue( ));
}
final public Number multiply(Number x, Number y){
return Double.valueOf(x.doubleValue() * y.doubleValue( ));
}
public Number divide(Number x, Number y){
return Double.valueOf(x.doubleValue() / y.doubleValue( ));
}
public Number quotient(Number x, Number y){
return Numbers.quotient(x.doubleValue(), y.doubleValu e());
}
public Number remainder(Number x, Number y){
return Numbers.remainder(x.doubleValue(), y.doubleVal ue());
}
public boolean equiv(Number x, Number y){
return x.doubleValue() == y.doubleValue();
}
public boolean lt(Number x, Number y){
return x.doubleValue() < y.doubleValue();
}
//public Number subtract(Number x, Number y);
final public Number negate(Number x){
return Double.valueOf(-x.doubleValue());
}
public Number inc(Number x){
return Double.valueOf(x.doubleValue() + 1);
}
public Number dec(Number x){
return Double.valueOf(x.doubleValue() - 1);
}
}
final static class RatioOps extends OpsP{
public Ops combine(Ops y){
return y.opsWith(this);
}
final public Ops opsWith(LongOps x){
return this;
}
9.76. NUMBERS.JAVA 881
final public Ops opsWith(DoubleOps x){
return DOUBLE_OPS;
}
final public Ops opsWith(RatioOps x){
return this;
}
final public Ops opsWith(BigIntOps x){
return this;
}
final public Ops opsWith(BigDecimalOps x){
return BIGDECIMAL_OPS;
}
public boolean isZero(Number x){
Ratio r = (Ratio) x;
return r.numerator.signum() == 0;
}
public boolean isPos(Number x){
Ratio r = (Ratio) x;
return r.numerator.signum() > 0;
}
public boolean isNeg(Number x){
Ratio r = (Ratio) x;
return r.numerator.signum() < 0;
}
static Number normalizeRet(Number ret, Number x, Number y) {
// if(ret instanceof BigInteger &&
// !(x instanceof BigInteger ||
// y instanceof BigInteger))
// {
// return reduceBigInt((BigInteger) ret);
// }
return ret;
}
final public Number add(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
Number ret = divide(ry.numerator.multiply(rx.denominat or)
.add(rx.numerator.multiply(ry.denominator))
, ry.denominator.multiply(rx.denominator));
return normalizeRet(ret, x, y);
}
882 CHAPTER 9. JVM/CLOJURE/LANG/
final public Number multiply(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
Number ret = Numbers.divide(ry.numerator.multiply(rx.n umerator)
, ry.denominator.multiply(rx.denominator));
return normalizeRet(ret, x, y);
}
public Number divide(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
Number ret = Numbers.divide(ry.denominator.multiply(rx .numerator)
, ry.numerator.multiply(rx.denominator));
return normalizeRet(ret, x, y);
}
public Number quotient(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
BigInteger q = rx.numerator.multiply(ry.denominator).d ivide(
rx.denominator.multiply(ry.numerator));
return normalizeRet(BigInt.fromBigInteger(q), x, y);
}
public Number remainder(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
BigInteger q = rx.numerator.multiply(ry.denominator).d ivide(
rx.denominator.multiply(ry.numerator));
Number ret = Numbers.minus(x, Numbers.multiply(q, y));
return normalizeRet(ret, x, y);
}
public boolean equiv(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
return rx.numerator.equals(ry.numerator)
&& rx.denominator.equals(ry.denominator);
}
public boolean lt(Number x, Number y){
Ratio rx = toRatio(x);
Ratio ry = toRatio(y);
return Numbers.lt(
rx.numerator.multiply(ry.denominator),
ry.numerator.multiply(rx.denominator));
}
//public Number subtract(Number x, Number y);
final public Number negate(Number x){
9.76. NUMBERS.JAVA 883
Ratio r = (Ratio) x;
return new Ratio(r.numerator.negate(), r.denominator);
}
public Number inc(Number x){
return Numbers.add(x, 1);
}
public Number dec(Number x){
return Numbers.add(x, -1);
}
}
final static class BigIntOps extends OpsP{
public Ops combine(Ops y){
return y.opsWith(this);
}
final public Ops opsWith(LongOps x){
return this;
}
final public Ops opsWith(DoubleOps x){
return DOUBLE_OPS;
}
final public Ops opsWith(RatioOps x){
return RATIO_OPS;
}
final public Ops opsWith(BigIntOps x){
return this;
}
final public Ops opsWith(BigDecimalOps x){
return BIGDECIMAL_OPS;
}
public boolean isZero(Number x){
BigInt bx = toBigInt(x);
if(bx.bipart == null)
return bx.lpart == 0;
return bx.bipart.signum() == 0;
}
public boolean isPos(Number x){
BigInt bx = toBigInt(x);
if(bx.bipart == null)
return bx.lpart > 0;
884 CHAPTER 9. JVM/CLOJURE/LANG/
return bx.bipart.signum() > 0;
}
public boolean isNeg(Number x){
BigInt bx = toBigInt(x);
if(bx.bipart == null)
return bx.lpart < 0;
return bx.bipart.signum() < 0;
}
final public Number add(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).add(toBigInte ger(y)));
}
final public Number multiply(Number x, Number y){
return
BigInt.fromBigInteger(
toBigInteger(x).multiply(toBigInteger(y)));
}
public Number divide(Number x, Number y){
return Numbers.divide(toBigInteger(x), toBigInteger(y ));
}
public Number quotient(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).divide(toBigI nteger(y)));
}
public Number remainder(Number x, Number y){
return
BigInt.fromBigInteger(
toBigInteger(x).remainder(toBigInteger(y)));
}
public boolean equiv(Number x, Number y){
return toBigInt(x).equals(toBigInt(y));
}
public boolean lt(Number x, Number y){
return toBigInteger(x).compareTo(toBigInteger(y)) < 0;
}
//public Number subtract(Number x, Number y);
final public Number negate(Number x){
return BigInt.fromBigInteger(toBigInteger(x).negate( ));
}
public Number inc(Number x){
9.76. NUMBERS.JAVA 885
BigInteger bx = toBigInteger(x);
return BigInt.fromBigInteger(bx.add(BigInteger.ONE)) ;
}
public Number dec(Number x){
BigInteger bx = toBigInteger(x);
return BigInt.fromBigInteger(bx.subtract(BigInteger. ONE));
}
}
final static class BigDecimalOps extends OpsP{
final static Var MATH_CONTEXT = RT.MATH_CONTEXT;
public Ops combine(Ops y){
return y.opsWith(this);
}
final public Ops opsWith(LongOps x){
return this;
}
final public Ops opsWith(DoubleOps x){
return DOUBLE_OPS;
}
final public Ops opsWith(RatioOps x){
return this;
}
final public Ops opsWith(BigIntOps x){
return this;
}
final public Ops opsWith(BigDecimalOps x){
return this;
}
public boolean isZero(Number x){
BigDecimal bx = (BigDecimal) x;
return bx.signum() == 0;
}
public boolean isPos(Number x){
BigDecimal bx = (BigDecimal) x;
return bx.signum() > 0;
}
public boolean isNeg(Number x){
BigDecimal bx = (BigDecimal) x;
886 CHAPTER 9. JVM/CLOJURE/LANG/
return bx.signum() < 0;
}
final public Number add(Number x, Number y){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
return mc == null
? toBigDecimal(x).add(toBigDecimal(y))
: toBigDecimal(x).add(toBigDecimal(y), mc);
}
final public Number multiply(Number x, Number y){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
return mc == null
? toBigDecimal(x).multiply(toBigDecimal(y))
: toBigDecimal(x).multiply(toBigDecimal(y), mc);
}
public Number divide(Number x, Number y){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
return mc == null
? toBigDecimal(x).divide(toBigDecimal(y))
: toBigDecimal(x).divide(toBigDecimal(y), mc);
}
public Number quotient(Number x, Number y){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
return
mc == null
? toBigDecimal(x).divideToIntegralValue(toBigDecimal (y))
: toBigDecimal(x).divideToIntegralValue(toBigDecimal (y), mc);
}
public Number remainder(Number x, Number y){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
return mc == null
? toBigDecimal(x).remainder(toBigDecimal(y))
: toBigDecimal(x).remainder(toBigDecimal(y), mc);
}
public boolean equiv(Number x, Number y){
return toBigDecimal(x).equals(toBigDecimal(y));
}
public boolean lt(Number x, Number y){
return toBigDecimal(x).compareTo(toBigDecimal(y)) < 0;
}
//public Number subtract(Number x, Number y);
final public Number negate(Number x){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
9.76. NUMBERS.JAVA 887
return mc == null
? ((BigDecimal) x).negate()
: ((BigDecimal) x).negate(mc);
}
public Number inc(Number x){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
BigDecimal bx = (BigDecimal) x;
return mc == null
? bx.add(BigDecimal.ONE)
: bx.add(BigDecimal.ONE, mc);
}
public Number dec(Number x){
MathContext mc = (MathContext) MATH_CONTEXT.deref();
BigDecimal bx = (BigDecimal) x;
return mc == null
? bx.subtract(BigDecimal.ONE)
: bx.subtract(BigDecimal.ONE, mc);
}
}
final static class LongBitOps implements BitOps{
public BitOps combine(BitOps y){
return y.bitOpsWith(this);
}
final public BitOps bitOpsWith(LongBitOps x){
return this;
}
final public BitOps bitOpsWith(BigIntBitOps x){
return BIGINT_BITOPS;
}
public Number not(Number x){
return num(~x.longValue());
}
public Number and(Number x, Number y){
return num(x.longValue() & y.longValue());
}
public Number or(Number x, Number y){
return num(x.longValue() | y.longValue());
}
public Number xor(Number x, Number y){
return num(x.longValue() ^ y.longValue());
}
888 CHAPTER 9. JVM/CLOJURE/LANG/
public Number andNot(Number x, Number y){
return num(x.longValue() & ~y.longValue());
}
public Number clearBit(Number x, int n){
if(n < 63)
return (num(x.longValue() & ~(1L << n)));
else
return BigInt.fromBigInteger(toBigInteger(x).clearBi t(n));
}
public Number setBit(Number x, int n){
if(n < 63)
return num(x.longValue() | (1L << n));
else
return BigInt.fromBigInteger(toBigInteger(x).setBit( n));
}
public Number flipBit(Number x, int n){
if(n < 63)
return num(x.longValue() ^ (1L << n));
else
return BigInt.fromBigInteger(toBigInteger(x).flipBit (n));
}
public boolean testBit(Number x, int n){
if(n < 64)
return (x.longValue() & (1L << n)) != 0;
else
return toBigInteger(x).testBit(n);
}
public Number shiftLeft(Number x, int n){
if(n < 0)
return shiftRight(x, -n);
return num(Numbers.shiftLeft(x.longValue(), n));
}
public Number shiftRight(Number x, int n){
if(n < 0)
return shiftLeft(x, -n);
return num(x.longValue() >> n);
}
}
final static class BigIntBitOps implements BitOps{
public BitOps combine(BitOps y){
return y.bitOpsWith(this);
}
9.76. NUMBERS.JAVA 889
final public BitOps bitOpsWith(LongBitOps x){
return this;
}
final public BitOps bitOpsWith(BigIntBitOps x){
return this;
}
public Number not(Number x){
return BigInt.fromBigInteger(toBigInteger(x).not());
}
public Number and(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).and(toBigInte ger(y)));
}
public Number or(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).or(toBigInteg er(y)));
}
public Number xor(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).xor(toBigInte ger(y)));
}
public Number andNot(Number x, Number y){
return
BigInt.fromBigInteger(toBigInteger(x).andNot(toBigI nteger(y)));
}
public Number clearBit(Number x, int n){
return BigInt.fromBigInteger(toBigInteger(x).clearBi t(n));
}
public Number setBit(Number x, int n){
return BigInt.fromBigInteger(toBigInteger(x).setBit( n));
}
public Number flipBit(Number x, int n){
return BigInt.fromBigInteger(toBigInteger(x).flipBit (n));
}
public boolean testBit(Number x, int n){
return toBigInteger(x).testBit(n);
}
public Number shiftLeft(Number x, int n){
890 CHAPTER 9. JVM/CLOJURE/LANG/
return BigInt.fromBigInteger(toBigInteger(x).shiftLe ft(n));
}
public Number shiftRight(Number x, int n){
return BigInt.fromBigInteger(toBigInteger(x).shiftRi ght(n));
}
}
static final LongOps LONG_OPS = new LongOps();
static final DoubleOps DOUBLE_OPS = new DoubleOps();
static final RatioOps RATIO_OPS = new RatioOps();
static final BigIntOps BIGINT_OPS = new BigIntOps();
static final BigDecimalOps BIGDECIMAL_OPS = new BigDecima lOps();
static final LongBitOps LONG_BITOPS = new LongBitOps();
static final BigIntBitOps BIGINT_BITOPS = new BigIntBitOp s();
static public enum Category {INTEGER, FLOATING, DECIMAL, R ATIO};
static Ops ops(Object x){
Class xc = x.getClass();
if(xc == Integer.class)
return LONG_OPS;
else if(xc == Double.class)
return DOUBLE_OPS;
else if(xc == Long.class)
return LONG_OPS;
else if(xc == Float.class)
return DOUBLE_OPS;
else if(xc == BigInt.class)
return BIGINT_OPS;
else if(xc == BigInteger.class)
return BIGINT_OPS;
else if(xc == Ratio.class)
return RATIO_OPS;
else if(xc == BigDecimal.class)
return BIGDECIMAL_OPS;
else
return LONG_OPS;
}
static Category category(Object x){
Class xc = x.getClass();
if(xc == Integer.class)
return Category.INTEGER;
else if(xc == Double.class)
return Category.FLOATING;
else if(xc == Long.class)
9.76. NUMBERS.JAVA 891
return Category.INTEGER;
else if(xc == Float.class)
return Category.FLOATING;
else if(xc == BigInt.class)
return Category.INTEGER;
else if(xc == Ratio.class)
return Category.RATIO;
else if(xc == BigDecimal.class)
return Category.DECIMAL;
else
return Category.INTEGER;
}
static BitOps bitOps(Object x){
Class xc = x.getClass();
if(xc == Long.class)
return LONG_BITOPS;
else if(xc == Integer.class)
return LONG_BITOPS;
else if(xc == BigInt.class)
return BIGINT_BITOPS;
else if(xc == BigInteger.class)
return BIGINT_BITOPS;
else if(xc == Double.class ||
xc == Float.class ||
xc == BigDecimalOps.class ||
xc == Ratio.class)
throw new ArithmeticException(
"bit operation on non integer type: " + xc);
else
return LONG_BITOPS;
}
static public float[] float_array(int size, Object init){
float[] ret = new float[size];
if(init instanceof Number)
{
float f = ((Number) init).floatValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).floatValue();
}
return ret;
}
892 CHAPTER 9. JVM/CLOJURE/LANG/
static public float[] float_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new float[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
float[] ret = new float[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).floatValue();
return ret;
}
}
static public double[] double_array(int size, Object init ){
double[] ret = new double[size];
if(init instanceof Number)
{
double f = ((Number) init).doubleValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).doubleValue();
}
return ret;
}
static public double[] double_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new double[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
double[] ret = new double[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).doubleValue();
return ret;
}
}
static public int[] int_array(int size, Object init){
int[] ret = new int[size];
if(init instanceof Number)
{
9.76. NUMBERS.JAVA 893
int f = ((Number) init).intValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).intValue();
}
return ret;
}
static public int[] int_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new int[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
int[] ret = new int[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).intValue();
return ret;
}
}
static public long[] long_array(int size, Object init){
long[] ret = new long[size];
if(init instanceof Number)
{
long f = ((Number) init).longValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).longValue();
}
return ret;
}
static public long[] long_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new long[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
894 CHAPTER 9. JVM/CLOJURE/LANG/
int size = RT.count(s);
long[] ret = new long[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = ((Number) s.first()).longValue();
return ret;
}
}
static public short[] short_array(int size, Object init){
short[] ret = new short[size];
if(init instanceof Short)
{
short s = (Short) init;
for(int i = 0; i < ret.length; i++)
ret[i] = s;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Short) s.first();
}
return ret;
}
static public short[] short_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new short[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
short[] ret = new short[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Short) s.first();
return ret;
}
}
static public char[] char_array(int size, Object init){
char[] ret = new char[size];
if(init instanceof Character)
{
char c = (Character) init;
for(int i = 0; i < ret.length; i++)
ret[i] = c;
}
else
{
ISeq s = RT.seq(init);
9.76. NUMBERS.JAVA 895
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Character) s.first();
}
return ret;
}
static public char[] char_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new char[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
char[] ret = new char[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Character) s.first();
return ret;
}
}
static public byte[] byte_array(int size, Object init){
byte[] ret = new byte[size];
if(init instanceof Byte)
{
byte b = (Byte) init;
for(int i = 0; i < ret.length; i++)
ret[i] = b;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Byte) s.first();
}
return ret;
}
static public byte[] byte_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new byte[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
byte[] ret = new byte[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Byte)s.first();
return ret;
}
}
896 CHAPTER 9. JVM/CLOJURE/LANG/
static public boolean[] boolean_array(int size, Object in it){
boolean[] ret = new boolean[size];
if(init instanceof Boolean)
{
boolean b = (Boolean) init;
for(int i = 0; i < ret.length; i++)
ret[i] = b;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Boolean)s.first();
}
return ret;
}
static public boolean[] boolean_array(Object sizeOrSeq) {
if(sizeOrSeq instanceof Number)
return new boolean[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
boolean[] ret = new boolean[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = (Boolean)s.first();
return ret;
}
}
static public boolean[] booleans(Object array){
return (boolean[]) array;
}
static public byte[] bytes(Object array){
return (byte[]) array;
}
static public char[] chars(Object array){
return (char[]) array;
}
static public short[] shorts(Object array){
return (short[]) array;
}
static public float[] floats(Object array){
return (float[]) array;
9.76. NUMBERS.JAVA 897
}
static public double[] doubles(Object array){
return (double[]) array;
}
static public int[] ints(Object array){
return (int[]) array;
}
static public long[] longs(Object array){
return (long[]) array;
}
static public Number num(Object x){
return (Number) x;
}
static public Number num(float x){
return Double.valueOf(x);
}
static public Number num(double x){
return Double.valueOf(x);
}
static public double add(double x, double y){
return x + y;
}
static public double addP(double x, double y){
return x + y;
}
static public double minus(double x, double y){
return x - y;
}
static public double minusP(double x, double y){
return x - y;
}
static public double minus(double x){
return -x;
}
static public double minusP(double x){
return -x;
}
898 CHAPTER 9. JVM/CLOJURE/LANG/
static public double inc(double x){
return x + 1;
}
static public double incP(double x){
return x + 1;
}
static public double dec(double x){
return x - 1;
}
static public double decP(double x){
return x - 1;
}
static public double multiply(double x, double y){
return x * y;
}
static public double multiplyP(double x, double y){
return x * y;
}
static public double divide(double x, double y){
return x / y;
}
static public boolean equiv(double x, double y){
return x == y;
}
static public boolean lt(double x, double y){
return x < y;
}
static public boolean lte(double x, double y){
return x <= y;
}
static public boolean gt(double x, double y){
return x > y;
}
static public boolean gte(double x, double y){
return x >= y;
}
static public boolean isPos(double x){
return x > 0;
9.76. NUMBERS.JAVA 899
}
static public boolean isNeg(double x){
return x < 0;
}
static public boolean isZero(double x){
return x == 0;
}
static int throwIntOverflow(){
throw new ArithmeticException("integer overflow");
}
//static public Number num(int x){
// return Integer.valueOf(x);
//}
static public int unchecked_int_add(int x, int y){
return x + y;
}
static public int unchecked_int_subtract(int x, int y){
return x - y;
}
static public int unchecked_int_negate(int x){
return -x;
}
static public int unchecked_int_inc(int x){
return x + 1;
}
static public int unchecked_int_dec(int x){
return x - 1;
}
static public int unchecked_int_multiply(int x, int y){
return x * y;
}
//static public int add(int x, int y){
// int ret = x + y;
// if ((ret ^ x) < 0 && (ret ^ y) < 0)
// return throwIntOverflow();
// return ret;
//}
//static public int not(int x){
900 CHAPTER 9. JVM/CLOJURE/LANG/
// return ~x;
//}
static public long not(long x){
return ~x;
}
//static public int and(int x, int y){
// return x & y;
//}
static public long and(long x, long y){
return x & y;
}
//static public int or(int x, int y){
// return x | y;
//}
static public long or(long x, long y){
return x | y;
}
//static public int xor(int x, int y){
// return x ^ y;
//}
static public long xor(long x, long y){
return x ^ y;
}
//static public int minus(int x, int y){
// int ret = x - y;
// if (((ret ^ x) < 0 && (ret ^ ~y) < 0))
// return throwIntOverflow();
// return ret;
//}
//static public int minus(int x){
// if(x == Integer.MIN_VALUE)
// return throwIntOverflow();
// return -x;
//}
//static public int inc(int x){
// if(x == Integer.MAX_VALUE)
// return throwIntOverflow();
// return x + 1;
//}
//static public int dec(int x){
9.76. NUMBERS.JAVA 901
// if(x == Integer.MIN_VALUE)
// return throwIntOverflow();
// return x - 1;
//}
//static public int multiply(int x, int y){
// int ret = x * y;
// if (y != 0 && ret/y != x)
// return throwIntOverflow();
// return ret;
//}
static public int unchecked_int_divide(int x, int y){
return x / y;
}
static public int unchecked_int_remainder(int x, int y){
return x % y;
}
//static public boolean equiv(int x, int y){
// return x == y;
//}
//static public boolean lt(int x, int y){
// return x < y;
//}
//static public boolean lte(int x, int y){
// return x <= y;
//}
//static public boolean gt(int x, int y){
// return x > y;
//}
//static public boolean gte(int x, int y){
// return x >= y;
//}
//static public boolean isPos(int x){
// return x > 0;
//}
//static public boolean isNeg(int x){
// return x < 0;
//}
//static public boolean isZero(int x){
// return x == 0;
902 CHAPTER 9. JVM/CLOJURE/LANG/
//}
static public Number num(long x){
return Long.valueOf(x);
}
static public long
unchecked_add(long x, long y){return x + y;}
static public long
unchecked_minus(long x, long y){return x - y;}
static public long
unchecked_multiply(long x, long y){return x * y;}
static public long
unchecked_minus(long x){return -x;}
static public long
unchecked_inc(long x){return x + 1;}
static public long
unchecked_dec(long x){return x - 1;}
static public Number
unchecked_add(Object x, Object y){return add(x,y);}
static public Number
unchecked_minus(Object x, Object y){return minus(x,y);}
static public Number
unchecked_multiply(Object x, Object y){return multiply( x,y);}
static public Number
unchecked_minus(Object x){return minus(x);}
static public Number
unchecked_inc(Object x){return inc(x);}
static public Number
unchecked_dec(Object x){return dec(x);}
static public double
unchecked_add(double x, double y){return add(x,y);}
static public double
unchecked_minus(double x, double y){return minus(x,y);}
static public double
unchecked_multiply(double x, double y){return multiply( x,y);}
static public double
unchecked_minus(double x){return minus(x);}
static public double
unchecked_inc(double x){return inc(x);}
static public double
unchecked_dec(double x){return dec(x);}
static public double
unchecked_add(double x, Object y){return add(x,y);}
static public double
unchecked_minus(double x, Object y){return minus(x,y);}
static public double
9.76. NUMBERS.JAVA 903
unchecked_multiply(double x, Object y){return multiply( x,y);}
static public double
unchecked_add(Object x, double y){return add(x,y);}
static public double
unchecked_minus(Object x, double y){return minus(x,y);}
static public double
unchecked_multiply(Object x, double y){return multiply( x,y);}
static public double
unchecked_add(double x, long y){return add(x,y);}
static public double
unchecked_minus(double x, long y){return minus(x,y);}
static public double
unchecked_multiply(double x, long y){return multiply(x, y);}
static public double
unchecked_add(long x, double y){return add(x,y);}
static public double
unchecked_minus(long x, double y){return minus(x,y);}
static public double
unchecked_multiply(long x, double y){return multiply(x, y);}
static public Number
unchecked_add(long x, Object y){return add(x,y);}
static public Number
unchecked_minus(long x, Object y){return minus(x,y);}
static public Number
unchecked_multiply(long x, Object y){return multiply(x, y);}
static public Number
unchecked_add(Object x, long y){return add(x,y);}
static public Number
unchecked_minus(Object x, long y){return minus(x,y);}
static public Number
unchecked_multiply(Object x, long y){return multiply(x, y);}
static public Number
quotient(double x, Object y){return quotient((Object)x, y);}
static public Number
quotient(Object x, double y){return quotient(x,(Object) y);}
static public Number
quotient(long x, Object y){return quotient((Object)x,y) ;}
static public Number
quotient(Object x, long y){return quotient(x,(Object)y) ;}
static public double
quotient(double x, long y){return quotient(x,(double)y) ;}
static public double
quotient(long x, double y){return quotient((double)x,y) ;}
static public Number
remainder(double x, Object y){return remainder((Object) x,y);}
static public Number
904 CHAPTER 9. JVM/CLOJURE/LANG/
remainder(Object x, double y){return remainder(x,(Objec t)y);}
static public Number
remainder(long x, Object y){return remainder((Object)x, y);}
static public Number
remainder(Object x, long y){return remainder(x,(Object) y);}
static public double
remainder(double x, long y){return remainder(x,(double) y);}
static public double
remainder(long x, double y){return remainder((double)x, y);}
static public long add(long x, long y){
long ret = x + y;
if ((ret ^ x) < 0 && (ret ^ y) < 0)
return throwIntOverflow();
return ret;
}
static public Number addP(long x, long y){
long ret = x + y;
if ((ret ^ x) < 0 && (ret ^ y) < 0)
return addP((Number)x,(Number)y);
return num(ret);
}
static public long minus(long x, long y){
long ret = x - y;
if (((ret ^ x) < 0 && (ret ^ ~y) < 0))
return throwIntOverflow();
return ret;
}
static public Number minusP(long x, long y){
long ret = x - y;
if (((ret ^ x) < 0 && (ret ^ ~y) < 0))
return minusP((Number)x,(Number)y);
return num(ret);
}
static public long minus(long x){
if(x == Long.MIN_VALUE)
return throwIntOverflow();
return -x;
}
static public Number minusP(long x){
if(x == Long.MIN_VALUE)
return BigInt.fromBigInteger(BigInteger.valueOf(x).n egate());
return num(-x);
}
9.76. NUMBERS.JAVA 905
static public long inc(long x){
if(x == Long.MAX_VALUE)
return throwIntOverflow();
return x + 1;
}
static public Number incP(long x){
if(x == Long.MAX_VALUE)
return BIGINT_OPS.inc(x);
return num(x + 1);
}
static public long dec(long x){
if(x == Long.MIN_VALUE)
return throwIntOverflow();
return x - 1;
}
static public Number decP(long x){
if(x == Long.MIN_VALUE)
return BIGINT_OPS.dec(x);
return num(x - 1);
}
static public long multiply(long x, long y){
long ret = x * y;
if (y != 0 && ret/y != x)
return throwIntOverflow();
return ret;
}
static public Number multiplyP(long x, long y){
long ret = x * y;
if (y != 0 && ret/y != x)
return multiplyP((Number)x,(Number)y);
return num(ret);
}
static public long quotient(long x, long y){
return x / y;
}
static public long remainder(long x, long y){
return x % y;
}
static public boolean equiv(long x, long y){
return x == y;
}
906 CHAPTER 9. JVM/CLOJURE/LANG/
static public boolean lt(long x, long y){
return x < y;
}
static public boolean lte(long x, long y){
return x <= y;
}
static public boolean gt(long x, long y){
return x > y;
}
static public boolean gte(long x, long y){
return x >= y;
}
static public boolean isPos(long x){
return x > 0;
}
static public boolean isNeg(long x){
return x < 0;
}
static public boolean isZero(long x){
return x == 0;
}
/*
static public class F{
static public float add(float x, float y){
return x + y;
}
static public float subtract(float x, float y){
return x - y;
}
static public float negate(float x){
return -x;
}
static public float inc(float x){
return x + 1;
}
static public float dec(float x){
return x - 1;
}
9.76. NUMBERS.JAVA 907
static public float multiply(float x, float y){
return x * y;
}
static public float divide(float x, float y){
return x / y;
}
static public boolean equiv(float x, float y){
return x == y;
}
static public boolean lt(float x, float y){
return x < y;
}
static public boolean lte(float x, float y){
return x <= y;
}
static public boolean gt(float x, float y){
return x > y;
}
static public boolean gte(float x, float y){
return x >= y;
}
static public boolean pos(float x){
return x > 0;
}
static public boolean neg(float x){
return x < 0;
}
static public boolean zero(float x){
return x == 0;
}
static public float aget(float[] xs, int i){
return xs[i];
}
static public float aset(float[] xs, int i, float v){
xs[i] = v;
return v;
}
908 CHAPTER 9. JVM/CLOJURE/LANG/
static public int alength(float[] xs){
return xs.length;
}
static public float[] aclone(float[] xs){
return xs.clone();
}
static public float[] vec(int size, Object init){
float[] ret = new float[size];
if(init instanceof Number)
{
float f = ((Number) init).floatValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).floatValue();
}
return ret;
}
static public float[] vec(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new float[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = s.count();
float[] ret = new float[size];
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).intValue();
return ret;
}
}
static public float[] vsadd(float[] x, float y){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += y;
return xs;
}
static public float[] vssub(float[] x, float y){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
9.76. NUMBERS.JAVA 909
xs[i] -= y;
return xs;
}
static public float[] vsdiv(float[] x, float y){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= y;
return xs;
}
static public float[] vsmul(float[] x, float y){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= y;
return xs;
}
static public float[] svdiv(float y, float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = y / xs[i];
return xs;
}
static public float[] vsmuladd(float[] x, float y, float[] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + zs[i];
return xs;
}
static public float[] vsmulsub(float[] x, float y, float[] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - zs[i];
return xs;
}
static public float[] vsmulsadd(float[] x, float y, float z ){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + z;
return xs;
}
static public float[] vsmulssub(float[] x, float y, float z ){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - z;
910 CHAPTER 9. JVM/CLOJURE/LANG/
return xs;
}
static public float[] vabs(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.abs(xs[i]);
return xs;
}
static public float[] vnegabs(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -Math.abs(xs[i]);
return xs;
}
static public float[] vneg(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -xs[i];
return xs;
}
static public float[] vsqr(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= xs[i];
return xs;
}
static public float[] vsignedsqr(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= Math.abs(xs[i]);
return xs;
}
static public float[] vclip(float[] x, float low, float hig h){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
xs[i] = low;
else if(xs[i] > high)
xs[i] = high;
}
return xs;
}
9.76. NUMBERS.JAVA 911
static public IPersistentVector vclipcounts(float[] x,
float low,
float high){
final float[] xs = x.clone();
int lowc = 0;
int highc = 0;
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
{
++lowc;
xs[i] = low;
}
else if(xs[i] > high)
{
++highc;
xs[i] = high;
}
}
return RT.vector(xs, lowc, highc);
}
static public float[] vthresh(float[] x,
float thresh,
float otherwise){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < thresh)
xs[i] = otherwise;
}
return xs;
}
static public float[] vreverse(float[] x){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[xs.length - i - 1];
return xs;
}
static public float[] vrunningsum(float[] x){
final float[] xs = x.clone();
for(int i = 1; i < xs.length; i++)
xs[i] = xs[i - 1] + xs[i];
return xs;
}
static public float[] vsort(float[] x){
912 CHAPTER 9. JVM/CLOJURE/LANG/
final float[] xs = x.clone();
Arrays.sort(xs);
return xs;
}
static public float vdot(float[] xs, float[] ys){
float ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * ys[i];
return ret;
}
static public float vmax(float[] xs){
if(xs.length == 0)
return 0;
float ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.max(ret, xs[i]);
return ret;
}
static public float vmin(float[] xs){
if(xs.length == 0)
return 0;
float ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.min(ret, xs[i]);
return ret;
}
static public float vmean(float[] xs){
if(xs.length == 0)
return 0;
return vsum(xs) / xs.length;
}
static public double vrms(float[] xs){
if(xs.length == 0)
return 0;
float ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * xs[i];
return Math.sqrt(ret / xs.length);
}
static public float vsum(float[] xs){
float ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i];
return ret;
9.76. NUMBERS.JAVA 913
}
static public boolean vequiv(float[] xs, float[] ys){
return Arrays.equals(xs, ys);
}
static public float[] vadd(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += ys[i];
return xs;
}
static public float[] vsub(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] -= ys[i];
return xs;
}
static public float[] vaddmul(float[] x, float[] ys, float [] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * zs[i];
return xs;
}
static public float[] vsubmul(float[] x, float[] ys, float [] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * zs[i];
return xs;
}
static public float[] vaddsmul(float[] x, float[] ys, floa t z){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * z;
return xs;
}
static public float[] vsubsmul(float[] x, float[] ys, floa t z){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * z;
return xs;
}
static public float[] vmulsadd(float[] x, float[] ys, floa t z){
final float[] xs = x.clone();
914 CHAPTER 9. JVM/CLOJURE/LANG/
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + z;
return xs;
}
static public float[] vdiv(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= ys[i];
return xs;
}
static public float[] vmul(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= ys[i];
return xs;
}
static public float[] vmuladd(float[] x, float[] ys, float [] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + zs[i];
return xs;
}
static public float[] vmulsub(float[] x, float[] ys, float [] zs){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) - zs[i];
return xs;
}
static public float[] vmax(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.max(xs[i], ys[i]);
return xs;
}
static public float[] vmin(float[] x, float[] ys){
final float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.min(xs[i], ys[i]);
return xs;
}
static public float[] vmap(IFn fn, float[] x) throws Except ion{
float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
9.76. NUMBERS.JAVA 915
xs[i] = ((Number) fn.invoke(xs[i])).floatValue();
return xs;
}
static public float[] vmap(IFn fn,
float[] x,
float[] ys) throws Exception{
float[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i], ys[i])).floatValue() ;
return xs;
}
}
static public class D{
static public double add(double x, double y){
return x + y;
}
static public double subtract(double x, double y){
return x - y;
}
static public double negate(double x){
return -x;
}
static public double inc(double x){
return x + 1;
}
static public double dec(double x){
return x - 1;
}
static public double multiply(double x, double y){
return x * y;
}
static public double divide(double x, double y){
return x / y;
}
static public boolean equiv(double x, double y){
return x == y;
}
static public boolean lt(double x, double y){
return x < y;
916 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public boolean lte(double x, double y){
return x <= y;
}
static public boolean gt(double x, double y){
return x > y;
}
static public boolean gte(double x, double y){
return x >= y;
}
static public boolean pos(double x){
return x > 0;
}
static public boolean neg(double x){
return x < 0;
}
static public boolean zero(double x){
return x == 0;
}
static public double aget(double[] xs, int i){
return xs[i];
}
static public double aset(double[] xs, int i, double v){
xs[i] = v;
return v;
}
static public int alength(double[] xs){
return xs.length;
}
static public double[] aclone(double[] xs){
return xs.clone();
}
static public double[] vec(int size, Object init){
double[] ret = new double[size];
if(init instanceof Number)
{
double f = ((Number) init).doubleValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
9.76. NUMBERS.JAVA 917
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).doubleValue();
}
return ret;
}
static public double[] vec(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new double[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = s.count();
double[] ret = new double[size];
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).intValue();
return ret;
}
}
static public double[] vsadd(double[] x, double y){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += y;
return xs;
}
static public double[] vssub(double[] x, double y){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] -= y;
return xs;
}
static public double[] vsdiv(double[] x, double y){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= y;
return xs;
}
static public double[] vsmul(double[] x, double y){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= y;
return xs;
918 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public double[] svdiv(double y, double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = y / xs[i];
return xs;
}
static public double[] vsmuladd(double[] x, double y, doub le[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + zs[i];
return xs;
}
static public double[] vsmulsub(double[] x, double y, doub le[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - zs[i];
return xs;
}
static public double[] vsmulsadd(double[] x, double y, dou ble z){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + z;
return xs;
}
static public double[] vsmulssub(double[] x, double y, dou ble z){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - z;
return xs;
}
static public double[] vabs(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.abs(xs[i]);
return xs;
}
static public double[] vnegabs(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -Math.abs(xs[i]);
return xs;
}
9.76. NUMBERS.JAVA 919
static public double[] vneg(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -xs[i];
return xs;
}
static public double[] vsqr(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= xs[i];
return xs;
}
static public double[] vsignedsqr(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= Math.abs(xs[i]);
return xs;
}
static public double[] vclip(double[] x, double low, doubl e high){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
xs[i] = low;
else if(xs[i] > high)
xs[i] = high;
}
return xs;
}
static public IPersistentVector vclipcounts(double[] x,
double low,
double high){
final double[] xs = x.clone();
int lowc = 0;
int highc = 0;
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
{
++lowc;
xs[i] = low;
}
else if(xs[i] > high)
{
920 CHAPTER 9. JVM/CLOJURE/LANG/
++highc;
xs[i] = high;
}
}
return RT.vector(xs, lowc, highc);
}
static public double[] vthresh(double[] x,
double thresh,
double otherwise){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < thresh)
xs[i] = otherwise;
}
return xs;
}
static public double[] vreverse(double[] x){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[xs.length - i - 1];
return xs;
}
static public double[] vrunningsum(double[] x){
final double[] xs = x.clone();
for(int i = 1; i < xs.length; i++)
xs[i] = xs[i - 1] + xs[i];
return xs;
}
static public double[] vsort(double[] x){
final double[] xs = x.clone();
Arrays.sort(xs);
return xs;
}
static public double vdot(double[] xs, double[] ys){
double ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * ys[i];
return ret;
}
static public double vmax(double[] xs){
if(xs.length == 0)
return 0;
double ret = xs[0];
9.76. NUMBERS.JAVA 921
for(int i = 0; i < xs.length; i++)
ret = Math.max(ret, xs[i]);
return ret;
}
static public double vmin(double[] xs){
if(xs.length == 0)
return 0;
double ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.min(ret, xs[i]);
return ret;
}
static public double vmean(double[] xs){
if(xs.length == 0)
return 0;
return vsum(xs) / xs.length;
}
static public double vrms(double[] xs){
if(xs.length == 0)
return 0;
double ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * xs[i];
return Math.sqrt(ret / xs.length);
}
static public double vsum(double[] xs){
double ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i];
return ret;
}
static public boolean vequiv(double[] xs, double[] ys){
return Arrays.equals(xs, ys);
}
static public double[] vadd(double[] x, double[] ys){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += ys[i];
return xs;
}
static public double[] vsub(double[] x, double[] ys){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
922 CHAPTER 9. JVM/CLOJURE/LANG/
xs[i] -= ys[i];
return xs;
}
static public double[] vaddmul(double[] x,
double[] ys,
double[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * zs[i];
return xs;
}
static public double[] vsubmul(double[] x, double[] ys, do uble[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * zs[i];
return xs;
}
static public double[] vaddsmul(double[] x, double[] ys, d ouble z){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * z;
return xs;
}
static public double[] vsubsmul(double[] x, double[] ys, d ouble z){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * z;
return xs;
}
static public double[] vmulsadd(double[] x, double[] ys, d ouble z){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + z;
return xs;
}
static public double[] vdiv(double[] x, double[] ys){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= ys[i];
return xs;
}
static public double[] vmul(double[] x, double[] ys){
final double[] xs = x.clone();
9.76. NUMBERS.JAVA 923
for(int i = 0; i < xs.length; i++)
xs[i] *= ys[i];
return xs;
}
static public double[] vmuladd(double[] x, double[] ys, do uble[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + zs[i];
return xs;
}
static public double[] vmulsub(double[] x, double[] ys, do uble[] zs){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) - zs[i];
return xs;
}
static public double[] vmax(double[] x, double[] ys){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.max(xs[i], ys[i]);
return xs;
}
static public double[] vmin(double[] x, double[] ys){
final double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.min(xs[i], ys[i]);
return xs;
}
static public double[] vmap(IFn fn, double[] x) throws Exce ption{
double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i])).doubleValue();
return xs;
}
static public double[] vmap(IFn fn,
double[] x,
double[] ys) throws Exception{
double[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i], ys[i])).doubleValue( );
return xs;
}
}
924 CHAPTER 9. JVM/CLOJURE/LANG/
static public class I{
static public int add(int x, int y){
return x + y;
}
static public int subtract(int x, int y){
return x - y;
}
static public int negate(int x){
return -x;
}
static public int inc(int x){
return x + 1;
}
static public int dec(int x){
return x - 1;
}
static public int multiply(int x, int y){
return x * y;
}
static public int divide(int x, int y){
return x / y;
}
static public boolean equiv(int x, int y){
return x == y;
}
static public boolean lt(int x, int y){
return x < y;
}
static public boolean lte(int x, int y){
return x <= y;
}
static public boolean gt(int x, int y){
return x > y;
}
static public boolean gte(int x, int y){
return x >= y;
}
static public boolean pos(int x){
9.76. NUMBERS.JAVA 925
return x > 0;
}
static public boolean neg(int x){
return x < 0;
}
static public boolean zero(int x){
return x == 0;
}
static public int aget(int[] xs, int i){
return xs[i];
}
static public int aset(int[] xs, int i, int v){
xs[i] = v;
return v;
}
static public int alength(int[] xs){
return xs.length;
}
static public int[] aclone(int[] xs){
return xs.clone();
}
static public int[] vec(int size, Object init){
int[] ret = new int[size];
if(init instanceof Number)
{
int f = ((Number) init).intValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).intValue();
}
return ret;
}
static public int[] vec(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new int[((Number) sizeOrSeq).intValue()];
else
{
926 CHAPTER 9. JVM/CLOJURE/LANG/
ISeq s = RT.seq(sizeOrSeq);
int size = s.count();
int[] ret = new int[size];
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).intValue();
return ret;
}
}
static public int[] vsadd(int[] x, int y){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += y;
return xs;
}
static public int[] vssub(int[] x, int y){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] -= y;
return xs;
}
static public int[] vsdiv(int[] x, int y){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= y;
return xs;
}
static public int[] vsmul(int[] x, int y){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= y;
return xs;
}
static public int[] svdiv(int y, int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = y / xs[i];
return xs;
}
static public int[] vsmuladd(int[] x, int y, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + zs[i];
return xs;
}
9.76. NUMBERS.JAVA 927
static public int[] vsmulsub(int[] x, int y, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - zs[i];
return xs;
}
static public int[] vsmulsadd(int[] x, int y, int z){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + z;
return xs;
}
static public int[] vsmulssub(int[] x, int y, int z){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - z;
return xs;
}
static public int[] vabs(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.abs(xs[i]);
return xs;
}
static public int[] vnegabs(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -Math.abs(xs[i]);
return xs;
}
static public int[] vneg(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -xs[i];
return xs;
}
static public int[] vsqr(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= xs[i];
return xs;
}
928 CHAPTER 9. JVM/CLOJURE/LANG/
static public int[] vsignedsqr(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= Math.abs(xs[i]);
return xs;
}
static public int[] vclip(int[] x, int low, int high){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
xs[i] = low;
else if(xs[i] > high)
xs[i] = high;
}
return xs;
}
static public IPersistentVector vclipcounts(int[] x,
int low,
int high){
final int[] xs = x.clone();
int lowc = 0;
int highc = 0;
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
{
++lowc;
xs[i] = low;
}
else if(xs[i] > high)
{
++highc;
xs[i] = high;
}
}
return RT.vector(xs, lowc, highc);
}
static public int[] vthresh(int[] x, int thresh, int otherw ise){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < thresh)
xs[i] = otherwise;
}
return xs;
9.76. NUMBERS.JAVA 929
}
static public int[] vreverse(int[] x){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[xs.length - i - 1];
return xs;
}
static public int[] vrunningsum(int[] x){
final int[] xs = x.clone();
for(int i = 1; i < xs.length; i++)
xs[i] = xs[i - 1] + xs[i];
return xs;
}
static public int[] vsort(int[] x){
final int[] xs = x.clone();
Arrays.sort(xs);
return xs;
}
static public int vdot(int[] xs, int[] ys){
int ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * ys[i];
return ret;
}
static public int vmax(int[] xs){
if(xs.length == 0)
return 0;
int ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.max(ret, xs[i]);
return ret;
}
static public int vmin(int[] xs){
if(xs.length == 0)
return 0;
int ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.min(ret, xs[i]);
return ret;
}
static public double vmean(int[] xs){
if(xs.length == 0)
return 0;
930 CHAPTER 9. JVM/CLOJURE/LANG/
return vsum(xs) / (double) xs.length;
}
static public double vrms(int[] xs){
if(xs.length == 0)
return 0;
int ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * xs[i];
return Math.sqrt(ret / (double) xs.length);
}
static public int vsum(int[] xs){
int ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i];
return ret;
}
static public boolean vequiv(int[] xs, int[] ys){
return Arrays.equals(xs, ys);
}
static public int[] vadd(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += ys[i];
return xs;
}
static public int[] vsub(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] -= ys[i];
return xs;
}
static public int[] vaddmul(int[] x, int[] ys, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * zs[i];
return xs;
}
static public int[] vsubmul(int[] x, int[] ys, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * zs[i];
return xs;
}
9.76. NUMBERS.JAVA 931
static public int[] vaddsmul(int[] x, int[] ys, int z){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * z;
return xs;
}
static public int[] vsubsmul(int[] x, int[] ys, int z){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * z;
return xs;
}
static public int[] vmulsadd(int[] x, int[] ys, int z){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + z;
return xs;
}
static public int[] vdiv(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= ys[i];
return xs;
}
static public int[] vmul(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= ys[i];
return xs;
}
static public int[] vmuladd(int[] x, int[] ys, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + zs[i];
return xs;
}
static public int[] vmulsub(int[] x, int[] ys, int[] zs){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) - zs[i];
return xs;
}
932 CHAPTER 9. JVM/CLOJURE/LANG/
static public int[] vmax(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.max(xs[i], ys[i]);
return xs;
}
static public int[] vmin(int[] x, int[] ys){
final int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.min(xs[i], ys[i]);
return xs;
}
static public int[] vmap(IFn fn, int[] x) throws Exception{
int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i])).intValue();
return xs;
}
static public int[] vmap(IFn fn, int[] x, int[] ys) throws Ex ception{
int[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i], ys[i])).intValue();
return xs;
}
}
static public class L{
static public long add(long x, long y){
return x + y;
}
static public long subtract(long x, long y){
return x - y;
}
static public long negate(long x){
return -x;
}
static public long inc(long x){
return x + 1;
}
static public long dec(long x){
return x - 1;
}
9.76. NUMBERS.JAVA 933
static public long multiply(long x, long y){
return x * y;
}
static public long divide(long x, long y){
return x / y;
}
static public boolean equiv(long x, long y){
return x == y;
}
static public boolean lt(long x, long y){
return x < y;
}
static public boolean lte(long x, long y){
return x <= y;
}
static public boolean gt(long x, long y){
return x > y;
}
static public boolean gte(long x, long y){
return x >= y;
}
static public boolean pos(long x){
return x > 0;
}
static public boolean neg(long x){
return x < 0;
}
static public boolean zero(long x){
return x == 0;
}
static public long aget(long[] xs, int i){
return xs[i];
}
static public long aset(long[] xs, int i, long v){
xs[i] = v;
return v;
}
934 CHAPTER 9. JVM/CLOJURE/LANG/
static public int alength(long[] xs){
return xs.length;
}
static public long[] aclone(long[] xs){
return xs.clone();
}
static public long[] vec(int size, Object init){
long[] ret = new long[size];
if(init instanceof Number)
{
long f = ((Number) init).longValue();
for(int i = 0; i < ret.length; i++)
ret[i] = f;
}
else
{
ISeq s = RT.seq(init);
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).longValue();
}
return ret;
}
static public long[] vec(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new long[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = s.count();
long[] ret = new long[size];
for(int i = 0; i < size && s != null; i++, s = s.rest())
ret[i] = ((Number) s.first()).intValue();
return ret;
}
}
static public long[] vsadd(long[] x, long y){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += y;
return xs;
}
static public long[] vssub(long[] x, long y){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
9.76. NUMBERS.JAVA 935
xs[i] -= y;
return xs;
}
static public long[] vsdiv(long[] x, long y){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= y;
return xs;
}
static public long[] vsmul(long[] x, long y){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= y;
return xs;
}
static public long[] svdiv(long y, long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = y / xs[i];
return xs;
}
static public long[] vsmuladd(long[] x, long y, long[] zs){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + zs[i];
return xs;
}
static public long[] vsmulsub(long[] x, long y, long[] zs){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - zs[i];
return xs;
}
static public long[] vsmulsadd(long[] x, long y, long z){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y + z;
return xs;
}
static public long[] vsmulssub(long[] x, long y, long z){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[i] * y - z;
936 CHAPTER 9. JVM/CLOJURE/LANG/
return xs;
}
static public long[] vabs(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.abs(xs[i]);
return xs;
}
static public long[] vnegabs(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -Math.abs(xs[i]);
return xs;
}
static public long[] vneg(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = -xs[i];
return xs;
}
static public long[] vsqr(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= xs[i];
return xs;
}
static public long[] vsignedsqr(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= Math.abs(xs[i]);
return xs;
}
static public long[] vclip(long[] x, long low, long high){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
xs[i] = low;
else if(xs[i] > high)
xs[i] = high;
}
return xs;
}
9.76. NUMBERS.JAVA 937
static public IPersistentVector vclipcounts(long[] x,
long low,
long high){
final long[] xs = x.clone();
int lowc = 0;
int highc = 0;
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < low)
{
++lowc;
xs[i] = low;
}
else if(xs[i] > high)
{
++highc;
xs[i] = high;
}
}
return RT.vector(xs, lowc, highc);
}
static public long[] vthresh(long[] x, long thresh, long ot herwise){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
{
if(xs[i] < thresh)
xs[i] = otherwise;
}
return xs;
}
static public long[] vreverse(long[] x){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = xs[xs.length - i - 1];
return xs;
}
static public long[] vrunningsum(long[] x){
final long[] xs = x.clone();
for(int i = 1; i < xs.length; i++)
xs[i] = xs[i - 1] + xs[i];
return xs;
}
static public long[] vsort(long[] x){
final long[] xs = x.clone();
Arrays.sort(xs);
938 CHAPTER 9. JVM/CLOJURE/LANG/
return xs;
}
static public long vdot(long[] xs, long[] ys){
long ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * ys[i];
return ret;
}
static public long vmax(long[] xs){
if(xs.length == 0)
return 0;
long ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.max(ret, xs[i]);
return ret;
}
static public long vmin(long[] xs){
if(xs.length == 0)
return 0;
long ret = xs[0];
for(int i = 0; i < xs.length; i++)
ret = Math.min(ret, xs[i]);
return ret;
}
static public double vmean(long[] xs){
if(xs.length == 0)
return 0;
return vsum(xs) / (double) xs.length;
}
static public double vrms(long[] xs){
if(xs.length == 0)
return 0;
long ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i] * xs[i];
return Math.sqrt(ret / (double) xs.length);
}
static public long vsum(long[] xs){
long ret = 0;
for(int i = 0; i < xs.length; i++)
ret += xs[i];
return ret;
}
9.76. NUMBERS.JAVA 939
static public boolean vequiv(long[] xs, long[] ys){
return Arrays.equals(xs, ys);
}
static public long[] vadd(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] += ys[i];
return xs;
}
static public long[] vsub(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] -= ys[i];
return xs;
}
static public long[] vaddmul(long[] x, long[] ys, long[] zs ){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * zs[i];
return xs;
}
static public long[] vsubmul(long[] x, long[] ys, long[] zs ){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * zs[i];
return xs;
}
static public long[] vaddsmul(long[] x, long[] ys, long z){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] + ys[i]) * z;
return xs;
}
static public long[] vsubsmul(long[] x, long[] ys, long z){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] - ys[i]) * z;
return xs;
}
static public long[] vmulsadd(long[] x, long[] ys, long z){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + z;
940 CHAPTER 9. JVM/CLOJURE/LANG/
return xs;
}
static public long[] vdiv(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] /= ys[i];
return xs;
}
static public long[] vmul(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] *= ys[i];
return xs;
}
static public long[] vmuladd(long[] x, long[] ys, long[] zs ){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) + zs[i];
return xs;
}
static public long[] vmulsub(long[] x, long[] ys, long[] zs ){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = (xs[i] * ys[i]) - zs[i];
return xs;
}
static public long[] vmax(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.max(xs[i], ys[i]);
return xs;
}
static public long[] vmin(long[] x, long[] ys){
final long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = Math.min(xs[i], ys[i]);
return xs;
}
static public long[] vmap(IFn fn, long[] x) throws Exceptio n{
long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i])).longValue();
return xs;
9.76. NUMBERS.JAVA 941
}
static public long[] vmap(IFn fn, long[] x, long[] ys)
throws Exception{
long[] xs = x.clone();
for(int i = 0; i < xs.length; i++)
xs[i] = ((Number) fn.invoke(xs[i], ys[i])).longValue();
return xs;
}
}
*/
//overload resolution
//*
static public Number add(long x, Object y){
return add((Object)x,y);
}
static public Number add(Object x, long y){
return add(x,(Object)y);
}
static public Number addP(long x, Object y){
return addP((Object)x,y);
}
static public Number addP(Object x, long y){
return addP(x,(Object)y);
}
static public double add(double x, Object y){
return add(x,((Number)y).doubleValue());
}
static public double add(Object x, double y){
return add(((Number)x).doubleValue(),y);
}
static public double add(double x, long y){
return x + y;
}
static public double add(long x, double y){
return x + y;
}
static public double addP(double x, Object y){
942 CHAPTER 9. JVM/CLOJURE/LANG/
return addP(x,((Number)y).doubleValue());
}
static public double addP(Object x, double y){
return addP(((Number)x).doubleValue(),y);
}
static public double addP(double x, long y){
return x + y;
}
static public double addP(long x, double y){
return x + y;
}
static public Number minus(long x, Object y){
return minus((Object)x,y);
}
static public Number minus(Object x, long y){
return minus(x,(Object)y);
}
static public Number minusP(long x, Object y){
return minusP((Object)x,y);
}
static public Number minusP(Object x, long y){
return minusP(x,(Object)y);
}
static public double minus(double x, Object y){
return minus(x,((Number)y).doubleValue());
}
static public double minus(Object x, double y){
return minus(((Number)x).doubleValue(),y);
}
static public double minus(double x, long y){
return x - y;
}
static public double minus(long x, double y){
return x - y;
}
static public double minusP(double x, Object y){
return minus(x,((Number)y).doubleValue());
}
9.76. NUMBERS.JAVA 943
static public double minusP(Object x, double y){
return minus(((Number)x).doubleValue(),y);
}
static public double minusP(double x, long y){
return x - y;
}
static public double minusP(long x, double y){
return x - y;
}
static public Number multiply(long x, Object y){
return multiply((Object)x,y);
}
static public Number multiply(Object x, long y){
return multiply(x,(Object)y);
}
static public Number multiplyP(long x, Object y){
return multiplyP((Object)x,y);
}
static public Number multiplyP(Object x, long y){
return multiplyP(x,(Object)y);
}
static public double multiply(double x, Object y){
return multiply(x,((Number)y).doubleValue());
}
static public double multiply(Object x, double y){
return multiply(((Number)x).doubleValue(),y);
}
static public double multiply(double x, long y){
return x * y;
}
static public double multiply(long x, double y){
return x * y;
}
static public double multiplyP(double x, Object y){
return multiplyP(x,((Number)y).doubleValue());
}
static public double multiplyP(Object x, double y){
944 CHAPTER 9. JVM/CLOJURE/LANG/
return multiplyP(((Number)x).doubleValue(),y);
}
static public double multiplyP(double x, long y){
return x * y;
}
static public double multiplyP(long x, double y){
return x * y;
}
static public Number divide(long x, Object y){
return divide((Object)x,y);
}
static public Number divide(Object x, long y){
return divide(x,(Object)y);
}
static public double divide(double x, Object y){
return x / ((Number)y).doubleValue();
}
static public double divide(Object x, double y){
return ((Number)x).doubleValue() / y;
}
static public double divide(double x, long y){
return x / y;
}
static public double divide(long x, double y){
return x / y;
}
static public boolean lt(long x, Object y){
return lt((Object)x,y);
}
static public boolean lt(Object x, long y){
return lt(x,(Object)y);
}
static public boolean lt(double x, Object y){
return x < ((Number)y).doubleValue();
}
static public boolean lt(Object x, double y){
return ((Number)x).doubleValue() < y;
}
9.76. NUMBERS.JAVA 945
static public boolean lt(double x, long y){
return x < y;
}
static public boolean lt(long x, double y){
return x < y;
}
static public boolean lte(long x, Object y){
return lte((Object)x,y);
}
static public boolean lte(Object x, long y){
return lte(x,(Object)y);
}
static public boolean lte(double x, Object y){
return x <= ((Number)y).doubleValue();
}
static public boolean lte(Object x, double y){
return ((Number)x).doubleValue() <= y;
}
static public boolean lte(double x, long y){
return x <= y;
}
static public boolean lte(long x, double y){
return x <= y;
}
static public boolean gt(long x, Object y){
return gt((Object)x,y);
}
static public boolean gt(Object x, long y){
return gt(x,(Object)y);
}
static public boolean gt(double x, Object y){
return x > ((Number)y).doubleValue();
}
static public boolean gt(Object x, double y){
return ((Number)x).doubleValue() > y;
}
static public boolean gt(double x, long y){
946 CHAPTER 9. JVM/CLOJURE/LANG/
return x > y;
}
static public boolean gt(long x, double y){
return x > y;
}
static public boolean gte(long x, Object y){
return gte((Object)x,y);
}
static public boolean gte(Object x, long y){
return gte(x,(Object)y);
}
static public boolean gte(double x, Object y){
return x >= ((Number)y).doubleValue();
}
static public boolean gte(Object x, double y){
return ((Number)x).doubleValue() >= y;
}
static public boolean gte(double x, long y){
return x >= y;
}
static public boolean gte(long x, double y){
return x >= y;
}
static public boolean equiv(long x, Object y){
return equiv((Object)x,y);
}
static public boolean equiv(Object x, long y){
return equiv(x,(Object)y);
}
static public boolean equiv(double x, Object y){
return x == ((Number)y).doubleValue();
}
static public boolean equiv(Object x, double y){
return ((Number)x).doubleValue() == y;
}
static public boolean equiv(double x, long y){
return x == y;
}
9.77. OBJ.JAVA 947
static public boolean equiv(long x, double y){
return x == y;
}
}
———-
9.77 Obj.java
(IObj [800]) (Serializable [1723])
— Obj.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 25, 2006 3:44:58 PM */
package clojure.lang;
import java.io.Serializable;
public abstract class Obj implements IObj, Serializable {
final IPersistentMap _meta;
public Obj(IPersistentMap meta){
this._meta = meta;
}
public Obj(){
_meta = null;
}
final public IPersistentMap meta(){
return _meta;
}
abstract public Obj withMeta(IPersistentMap meta);
}
———-
948 CHAPTER 9. JVM/CLOJURE/LANG/
9.78 PersistentArrayMap.java
(IObj [800]) (IEditableCollection [774])
— PersistentArrayMap.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Map;
/**
* Simple implementation of persistent map on an array
* <p/>
* Note that instances of this class are constant values
* i.e. add/remove etc return new values
* <p/>
* Copies array on every change, so only appropriate for
* _very_small_ maps
* <p/>
* null keys and values are ok, but you won’t be able to distingu ish
* a null value via valAt - use contains/entryAt
*/
public class PersistentArrayMap
extends APersistentMap implements IObj, IEditableCollec tion {
final Object[] array;
static final int HASHTABLE_THRESHOLD = 16;
public static final PersistentArrayMap EMPTY = new Persist entArrayMap();
private final IPersistentMap _meta;
static public IPersistentMap create(Map other){
ITransientMap ret = EMPTY.asTransient();
for(Object o : other.entrySet())
{
Map.Entry e = (Entry) o;
ret = ret.assoc(e.getKey(), e.getValue());
}
return ret.persistent();
}
protected PersistentArrayMap(){
this.array = new Object[]{};
9.78. PERSISTENTARRAYMAP.JAVA 949
this._meta = null;
}
public PersistentArrayMap withMeta(IPersistentMap meta ){
return new PersistentArrayMap(meta, array);
}
PersistentArrayMap create(Object... init){
return new PersistentArrayMap(meta(), init);
}
IPersistentMap createHT(Object[] init){
return PersistentHashMap.create(meta(), init);
}
static public PersistentArrayMap createWithCheck(Objec t[] init){
for(int i=0;i< init.length;i += 2)
{
for(int j=i+2;j<init.length;j += 2)
{
if(equalKey(init[i],init[j]))
throw new IllegalArgumentException("Duplicate key: " + in it[i]);
}
}
return new PersistentArrayMap(init);
}
/**
* This ctor captures/aliases the passed array, so do not modi fy later
*
* @param init {key1,val1,key2,val2,...}
*/
public PersistentArrayMap(Object[] init){
this.array = init;
this._meta = null;
}
public PersistentArrayMap(IPersistentMap meta, Object[ ] init){
this._meta = meta;
this.array = init;
}
public int count(){
return array.length / 2;
}
public boolean containsKey(Object key){
return indexOf(key) >= 0;
}
950 CHAPTER 9. JVM/CLOJURE/LANG/
public IMapEntry entryAt(Object key){
int i = indexOf(key);
if(i >= 0)
return new MapEntry(array[i],array[i+1]);
return null;
}
public IPersistentMap assocEx(Object key, Object val) thr ows Exception{
int i = indexOf(key);
Object[] newArray;
if(i >= 0)
{
throw new Exception("Key already present");
}
else //didn’t have key, grow
{
if(array.length > HASHTABLE_THRESHOLD)
return createHT(array).assocEx(key, val);
newArray = new Object[array.length + 2];
if(array.length > 0)
System.arraycopy(array, 0, newArray, 2, array.length);
newArray[0] = key;
newArray[1] = val;
}
return create(newArray);
}
public IPersistentMap assoc(Object key, Object val){
int i = indexOf(key);
Object[] newArray;
if(i >= 0) //already have key, same-sized replacement
{
if(array[i + 1] == val) //no change, no op
return this;
newArray = array.clone();
newArray[i + 1] = val;
}
else //didn’t have key, grow
{
if(array.length > HASHTABLE_THRESHOLD)
return createHT(array).assoc(key, val);
newArray = new Object[array.length + 2];
if(array.length > 0)
System.arraycopy(array, 0, newArray, 2, array.length);
newArray[0] = key;
newArray[1] = val;
}
return create(newArray);
}
9.78. PERSISTENTARRAYMAP.JAVA 951
public IPersistentMap without(Object key){
int i = indexOf(key);
if(i >= 0) //have key, will remove
{
int newlen = array.length - 2;
if(newlen == 0)
return empty();
Object[] newArray = new Object[newlen];
for(int s = 0, d = 0; s < array.length; s += 2)
{
if(!equalKey(array[s], key)) //skip removal key
{
newArray[d] = array[s];
newArray[d + 1] = array[s + 1];
d += 2;
}
}
return create(newArray);
}
//don’t have key, no op
return this;
}
public IPersistentMap empty(){
return (IPersistentMap) EMPTY.withMeta(meta());
}
final public Object valAt(Object key, Object notFound){
int i = indexOf(key);
if(i >= 0)
return array[i + 1];
return notFound;
}
public Object valAt(Object key){
return valAt(key, null);
}
public int capacity(){
return count();
}
private int indexOf(Object key){
for(int i = 0; i < array.length; i += 2)
{
if(equalKey(array[i], key))
return i;
}
return -1;
}
952 CHAPTER 9. JVM/CLOJURE/LANG/
static boolean equalKey(Object k1, Object k2){
return Util.equiv(k1, k2);
}
public Iterator iterator(){
return new Iter(array);
}
public ISeq seq(){
if(array.length > 0)
return new Seq(array, 0);
return null;
}
public IPersistentMap meta(){
return _meta;
}
static class Seq extends ASeq implements Counted{
final Object[] array;
final int i;
Seq(Object[] array, int i){
this.array = array;
this.i = i;
}
public Seq(IPersistentMap meta, Object[] array, int i){
super(meta);
this.array = array;
this.i = i;
}
public Object first(){
return new MapEntry(array[i],array[i+1]);
}
public ISeq next(){
if(i + 2 < array.length)
return new Seq(array, i + 2);
return null;
}
public int count(){
return (array.length - i) / 2;
}
public Obj withMeta(IPersistentMap meta){
return new Seq(meta, array, i);
9.78. PERSISTENTARRAYMAP.JAVA 953
}
}
static class Iter implements Iterator{
Object[] array;
int i;
//for iterator
Iter(Object[] array){
this(array, -2);
}
//for entryAt
Iter(Object[] array, int i){
this.array = array;
this.i = i;
}
public boolean hasNext(){
return i < array.length - 2;
}
public Object next(){
i += 2;
return new MapEntry(array[i],array[i+1]);
}
public void remove(){
throw new UnsupportedOperationException();
}
}
public ITransientMap asTransient(){
return new TransientArrayMap(array);
}
static final class TransientArrayMap extends ATransientM ap {
int len;
final Object[] array;
Thread owner;
public TransientArrayMap(Object[] array){
this.owner = Thread.currentThread();
this.array =
new Object[Math.max(HASHTABLE_THRESHOLD, array.length )];
System.arraycopy(array, 0, this.array, 0, array.length) ;
this.len = array.length;
}
954 CHAPTER 9. JVM/CLOJURE/LANG/
private int indexOf(Object key){
for(int i = 0; i < len; i += 2)
{
if(equalKey(array[i], key))
return i;
}
return -1;
}
ITransientMap doAssoc(Object key, Object val){
int i = indexOf(key);
if(i >= 0) //already have key,
{
if(array[i + 1] != val) //no change, no op
array[i + 1] = val;
}
else //didn’t have key, grow
{
if(len >= array.length)
return
PersistentHashMap.create(array)
.asTransient()
.assoc(key, val);
array[len++] = key;
array[len++] = val;
}
return this;
}
ITransientMap doWithout(Object key) {
int i = indexOf(key);
if(i >= 0) //have key, will remove
{
if (len >= 2)
{
array[i] = array[len - 2];
array[i + 1] = array[len - 1];
}
len -= 2;
}
return this;
}
Object doValAt(Object key, Object notFound) {
int i = indexOf(key);
if (i >= 0)
return array[i + 1];
return notFound;
}
9.79. PERSISTENTHASHMAP.JAVA 955
int doCount() {
return len / 2;
}
IPersistentMap doPersistent(){
ensureEditable();
owner = null;
Object[] a = new Object[len];
System.arraycopy(array,0,a,0,len);
return new PersistentArrayMap(a);
}
void ensureEditable(){
if(owner == Thread.currentThread())
return;
if(owner != null)
throw new IllegalAccessError(
"Transient used by non-owner thread");
throw new IllegalAccessError(
"Transient used after persistent! call");
}
}
}
———-
9.79 PersistentHashMap.java
(INode [58])
— PersistentHashMap ArrayNode class —
final static class ArrayNode implements INode{
int count;
final INode[] array;
final AtomicReference<Thread> edit;
ArrayNode(AtomicReference<Thread> edit, int count, INod e[] array){
this.array = array;
this.edit = edit;
this.count = count;
}
public INode assoc(int shift, int hash, Object key,
Object val, Box addedLeaf){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null)
return
956 CHAPTER 9. JVM/CLOJURE/LANG/
new ArrayNode(null, count + 1,
cloneAndSet(array,
idx,
BitmapIndexedNode.EMPTY
.assoc(shift + 5,
hash,
key,
val,
addedLeaf)));
INode n = node.assoc(shift + 5, hash, key, val, addedLeaf);
if(n == node)
return this;
return new ArrayNode(null, count, cloneAndSet(array, idx , n));
}
public INode without(int shift, int hash, Object key){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null)
return this;
INode n = node.without(shift + 5, hash, key);
if(n == node)
return this;
if (n == null) {
if (count <= 8) // shrink
return pack(null, idx);
return
new ArrayNode(null, count - 1,
cloneAndSet(array, idx, n));
} else
return
new ArrayNode(null, count,
cloneAndSet(array, idx, n));
}
public IMapEntry find(int shift, int hash, Object key){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null)
return null;
return node.find(shift + 5, hash, key);
}
\getchunk{ArrayNode find Object method}
public ISeq nodeSeq(){
return Seq.create(array);
}
private ArrayNode ensureEditable(AtomicReference<Thre ad> edit){
9.79. PERSISTENTHASHMAP.JAVA 957
if(this.edit == edit)
return this;
return new ArrayNode(edit, count, this.array.clone());
}
private ArrayNode editAndSet(AtomicReference<Thread> e dit,
int i, INode n){
ArrayNode editable = ensureEditable(edit);
editable.array[i] = n;
return editable;
}
private INode pack(AtomicReference<Thread> edit, int idx ) {
Object[] newArray = new Object[2*(count - 1)];
int j = 1;
int bitmap = 0;
for(int i = 0; i < idx; i++)
if (array[i] != null) {
newArray[j] = array[i];
bitmap |= 1 << i;
j += 2;
}
for(int i = idx + 1; i < array.length; i++)
if (array[i] != null) {
newArray[j] = array[i];
bitmap |= 1 << i;
j += 2;
}
return new BitmapIndexedNode(edit, bitmap, newArray);
}
public INode assoc(AtomicReference<Thread> edit, int shi ft,
int hash, Object key, Object val,
Box addedLeaf){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null) {
ArrayNode editable =
editAndSet(edit, idx,
BitmapIndexedNode.EMPTY
.assoc(edit,
shift + 5,
hash,
key,
val,
addedLeaf));
editable.count++;
return editable;
}
958 CHAPTER 9. JVM/CLOJURE/LANG/
INode n = node.assoc(edit, shift + 5, hash, key, val, addedLe af);
if(n == node)
return this;
return editAndSet(edit, idx, n);
}
public INode without(AtomicReference<Thread> edit,
int shift,
int hash,
Object key,
Box removedLeaf){
int idx = mask(hash, shift);
INode node = array[idx];
if(node == null)
return this;
INode n = node.without(edit, shift + 5, hash, key, removedLe af);
if(n == node)
return this;
if(n == null) {
if (count <= 8) // shrink
return pack(edit, idx);
ArrayNode editable = editAndSet(edit, idx, n);
editable.count--;
return editable;
}
return editAndSet(edit, idx, n);
}
static class Seq extends ASeq {
final INode[] nodes;
final int i;
final ISeq s;
static ISeq create(INode[] nodes) {
return create(null, nodes, 0, null);
}
private static ISeq create(IPersistentMap meta,
INode[] nodes, int i, ISeq s) {
if (s != null)
return new Seq(meta, nodes, i, s);
for(int j = i; j < nodes.length; j++)
if (nodes[j] != null) {
ISeq ns = nodes[j].nodeSeq();
if (ns != null)
return new Seq(meta, nodes, j + 1, ns);
}
return null;
}
9.79. PERSISTENTHASHMAP.JAVA 959
private Seq(IPersistentMap meta, INode[] nodes, int i, ISe q s) {
super(meta);
this.nodes = nodes;
this.i = i;
this.s = s;
}
public Obj withMeta(IPersistentMap meta) {
return new Seq(meta, nodes, i, s);
}
public Object first() {
return s.first();
}
public ISeq next() {
return create(null, nodes, i, s.next());
}
}
}
———-
(INode [58])
— PersistentHashMap BitmapIndexedNode class —
final static class BitmapIndexedNode implements INode{
static final BitmapIndexedNode EMPTY =
new BitmapIndexedNode(null, 0, new Object[0]);
int bitmap;
Object[] array;
final AtomicReference<Thread> edit;
final int index(int bit){
return Integer.bitCount(bitmap & (bit - 1));
}
BitmapIndexedNode(AtomicReference<Thread> edit,
int bitmap, Object[] array){
this.bitmap = bitmap;
this.array = array;
this.edit = edit;
}
public INode assoc(int shift, int hash, Object key,
Object val, Box addedLeaf){
int bit = bitpos(hash, shift);
int idx = index(bit);
960 CHAPTER 9. JVM/CLOJURE/LANG/
if((bitmap & bit) != 0) {
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null) {
INode n = ((INode) valOrNode).assoc(shift + 5,
hash,
key,
val,
addedLeaf);
if(n == valOrNode)
return this;
return
new BitmapIndexedNode(null, bitmap,
cloneAndSet(array, 2*idx+1, n));
}
if(Util.equiv(key, keyOrNull)) {
if(val == valOrNode)
return this;
return
new BitmapIndexedNode(null, bitmap,
cloneAndSet(array,
2*idx+1,
val));
}
addedLeaf.val = addedLeaf;
return new BitmapIndexedNode(null, bitmap,
cloneAndSet(array,
2*idx, null,
2*idx+1, createNode(shift + 5,
keyOrNull,
valOrNode,
hash,
key,
val)));
} else {
int n = Integer.bitCount(bitmap);
if(n >= 16) {
INode[] nodes = new INode[32];
int jdx = mask(hash, shift);
nodes[jdx] = EMPTY.assoc(shift + 5,
hash,
key,
val,
addedLeaf);
int j = 0;
for(int i = 0; i < 32; i++)
if(((bitmap >>> i) & 1) != 0) {
if (array[j] == null)
nodes[i] = (INode) array[j+1];
else
9.79. PERSISTENTHASHMAP.JAVA 961
nodes[i] =
EMPTY.assoc(shift + 5,
Util.hash(array[j]),
array[j],
array[j+1],
addedLeaf);
j += 2;
}
return new ArrayNode(null, n + 1, nodes);
} else {
Object[] newArray = new Object[2*(n+1)];
System.arraycopy(array, 0, newArray, 0, 2*idx);
newArray[2*idx] = key;
addedLeaf.val = addedLeaf;
newArray[2*idx+1] = val;
System.arraycopy(array, 2*idx, newArray,
2*(idx+1), 2*(n-idx));
return
new BitmapIndexedNode(null, bitmap | bit, newArray);
}
}
}
public INode without(int shift, int hash, Object key){
int bit = bitpos(hash, shift);
if((bitmap & bit) == 0)
return this;
int idx = index(bit);
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null) {
INode n =
((INode) valOrNode).without(shift + 5, hash, key);
if (n == valOrNode)
return this;
if (n != null)
return
new BitmapIndexedNode(null, bitmap,
cloneAndSet(array, 2*idx+1, n));
if (bitmap == bit)
return null;
return
new BitmapIndexedNode(null, bitmap ^ bit,
removePair(array, idx));
}
if(Util.equiv(key, keyOrNull))
// TODO: collapse
return new BitmapIndexedNode(null,
bitmap ^ bit,
removePair(array, idx));
962 CHAPTER 9. JVM/CLOJURE/LANG/
return this;
}
public IMapEntry find(int shift, int hash, Object key){
int bit = bitpos(hash, shift);
if((bitmap & bit) == 0)
return null;
int idx = index(bit);
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null)
return ((INode) valOrNode).find(shift + 5, hash, key);
if(Util.equiv(key, keyOrNull))
return new MapEntry(keyOrNull, valOrNode);
return null;
}
public Object find(int shift, int hash,
Object key, Object notFound){
int bit = bitpos(hash, shift);
if((bitmap & bit) == 0)
return notFound;
int idx = index(bit);
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null)
return
((INode) valOrNode).find(shift + 5, hash, key, notFound);
if(Util.equiv(key, keyOrNull))
return valOrNode;
return notFound;
}
public ISeq nodeSeq(){
return NodeSeq.create(array);
}
private BitmapIndexedNode
ensureEditable(AtomicReference<Thread> edit){
if(this.edit == edit)
return this;
int n = Integer.bitCount(bitmap);
Object[] newArray =
new Object[n >= 0 ? 2*(n+1) : 4]; // make room for next assoc
System.arraycopy(array, 0, newArray, 0, 2*n);
return new BitmapIndexedNode(edit, bitmap, newArray);
}
private BitmapIndexedNode
editAndSet(AtomicReference<Thread> edit, int i, Object a ) {
9.79. PERSISTENTHASHMAP.JAVA 963
BitmapIndexedNode editable = ensureEditable(edit);
editable.array[i] = a;
return editable;
}
private BitmapIndexedNode
editAndSet(AtomicReference<Thread> edit, int i,
Object a, int j, Object b) {
BitmapIndexedNode editable = ensureEditable(edit);
editable.array[i] = a;
editable.array[j] = b;
return editable;
}
private BitmapIndexedNode
editAndRemovePair(AtomicReference<Thread> edit,
int bit, int i) {
if (bitmap == bit)
return null;
BitmapIndexedNode editable = ensureEditable(edit);
editable.bitmap ^= bit;
System.arraycopy(editable.array, 2*(i+1), editable.ar ray,
2*i, editable.array.length - 2*(i+1));
editable.array[editable.array.length - 2] = null;
editable.array[editable.array.length - 1] = null;
return editable;
}
public INode assoc(AtomicReference<Thread> edit, int shi ft,
int hash, Object key, Object val,
Box addedLeaf){
int bit = bitpos(hash, shift);
int idx = index(bit);
if((bitmap & bit) != 0) {
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null) {
INode n =
((INode) valOrNode).assoc(edit,
shift + 5,
hash,
key,
val,
addedLeaf);
if(n == valOrNode)
return this;
return editAndSet(edit, 2*idx+1, n);
}
if(Util.equiv(key, keyOrNull)) {
if(val == valOrNode)
964 CHAPTER 9. JVM/CLOJURE/LANG/
return this;
return editAndSet(edit, 2*idx+1, val);
}
addedLeaf.val = addedLeaf;
return editAndSet(edit, 2*idx, null, 2*idx+1,
createNode(edit, shift + 5, keyOrNull,
valOrNode, hash, key, val));
} else {
int n = Integer.bitCount(bitmap);
if(n*2 < array.length) {
addedLeaf.val = addedLeaf;
BitmapIndexedNode editable = ensureEditable(edit);
System.arraycopy(editable.array, 2*idx,
editable.array, 2*(idx+1),
2*(n-idx));
editable.array[2*idx] = key;
editable.array[2*idx+1] = val;
editable.bitmap |= bit;
return editable;
}
if(n >= 16) {
INode[] nodes = new INode[32];
int jdx = mask(hash, shift);
nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key,
val, addedLeaf);
int j = 0;
for(int i = 0; i < 32; i++)
if(((bitmap >>> i) & 1) != 0) {
if (array[j] == null)
nodes[i] = (INode) array[j+1];
else
nodes[i] =
EMPTY.assoc(edit,
shift + 5,
Util.hash(array[j]),
array[j],
array[j+1],
addedLeaf);
j += 2;
}
return new ArrayNode(edit, n + 1, nodes);
} else {
Object[] newArray = new Object[2*(n+4)];
System.arraycopy(array, 0, newArray, 0, 2*idx);
newArray[2*idx] = key;
addedLeaf.val = addedLeaf;
newArray[2*idx+1] = val;
System.arraycopy(array, 2*idx, newArray,
2*(idx+1), 2*(n-idx));
BitmapIndexedNode editable = ensureEditable(edit);
9.79. PERSISTENTHASHMAP.JAVA 965
editable.array = newArray;
editable.bitmap |= bit;
return editable;
}
}
}
public INode without(AtomicReference<Thread> edit, int s hift,
int hash, Object key, Box removedLeaf){
int bit = bitpos(hash, shift);
if((bitmap & bit) == 0)
return this;
int idx = index(bit);
Object keyOrNull = array[2*idx];
Object valOrNode = array[2*idx+1];
if(keyOrNull == null) {
INode n =
((INode) valOrNode).without(edit,
shift + 5,
hash,
key,
removedLeaf);
if (n == valOrNode)
return this;
if (n != null)
return editAndSet(edit, 2*idx+1, n);
if (bitmap == bit)
return null;
removedLeaf.val = removedLeaf;
return editAndRemovePair(edit, bit, idx);
}
if(Util.equiv(key, keyOrNull)) {
removedLeaf.val = removedLeaf;
// TODO: collapse
return editAndRemovePair(edit, bit, idx);
}
return this;
}
}
———-
(INode [58])
— PersistentHashMap HashCollisionNode class —
final static class HashCollisionNode implements INode{
final int hash;
int count;
Object[] array;
966 CHAPTER 9. JVM/CLOJURE/LANG/
final AtomicReference<Thread> edit;
HashCollisionNode(AtomicReference<Thread> edit, int ha sh,
int count, Object... array){
this.edit = edit;
this.hash = hash;
this.count = count;
this.array = array;
}
public INode assoc(int shift, int hash, Object key,
Object val, Box addedLeaf){
if(hash == this.hash) {
int idx = findIndex(key);
if(idx != -1) {
if(array[idx + 1] == val)
return this;
return
new HashCollisionNode(null, hash, count,
cloneAndSet(array,
idx + 1,
val));
}
Object[] newArray = new Object[array.length + 2];
System.arraycopy(array, 0, newArray, 0, array.length);
newArray[array.length] = key;
newArray[array.length + 1] = val;
addedLeaf.val = addedLeaf;
return
new HashCollisionNode(edit, hash, count + 1, newArray);
}
// nest it in a bitmap node
return
new BitmapIndexedNode(null, bitpos(this.hash, shift),
new Object[] {null, this})
.assoc(shift, hash, key, val, addedLeaf);
}
public INode without(int shift, int hash, Object key){
int idx = findIndex(key);
if(idx == -1)
return this;
if(count == 1)
return null;
return
new HashCollisionNode(null, hash, count - 1,
removePair(array, idx/2));
}
public IMapEntry find(int shift, int hash, Object key){
9.79. PERSISTENTHASHMAP.JAVA 967
int idx = findIndex(key);
if(idx < 0)
return null;
if(Util.equiv(key, array[idx]))
return new MapEntry(array[idx], array[idx+1]);
return null;
}
public Object find(int shift, int hash, Object key, Object n otFound){
int idx = findIndex(key);
if(idx < 0)
return notFound;
if(Util.equiv(key, array[idx]))
return array[idx+1];
return notFound;
}
public ISeq nodeSeq(){
return NodeSeq.create(array);
}
public int findIndex(Object key){
for(int i = 0; i < 2*count; i+=2)
{
if(Util.equiv(key, array[i]))
return i;
}
return -1;
}
private HashCollisionNode
ensureEditable(AtomicReference<Thread> edit){
if(this.edit == edit)
return this;
return new HashCollisionNode(edit, hash, count, array);
}
private HashCollisionNode
ensureEditable(AtomicReference<Thread> edit, int count ,
Object[] array){
if(this.edit == edit) {
this.array = array;
this.count = count;
return this;
}
return new HashCollisionNode(edit, hash, count, array);
}
private HashCollisionNode
editAndSet(AtomicReference<Thread> edit, int i, Object a ) {
968 CHAPTER 9. JVM/CLOJURE/LANG/
HashCollisionNode editable = ensureEditable(edit);
editable.array[i] = a;
return editable;
}
private HashCollisionNode
editAndSet(AtomicReference<Thread> edit, int i, Object a ,
int j, Object b) {
HashCollisionNode editable = ensureEditable(edit);
editable.array[i] = a;
editable.array[j] = b;
return editable;
}
public INode assoc(AtomicReference<Thread> edit, int shi ft,
int hash, Object key, Object val,
Box addedLeaf){
if(hash == this.hash) {
int idx = findIndex(key);
if(idx != -1) {
if(array[idx + 1] == val)
return this;
return editAndSet(edit, idx+1, val);
}
if (array.length > 2*count) {
addedLeaf.val = addedLeaf;
HashCollisionNode editable =
editAndSet(edit, 2*count, key, 2*count+1, val);
editable.count++;
return editable;
}
Object[] newArray = new Object[array.length + 2];
System.arraycopy(array, 0, newArray, 0, array.length);
newArray[array.length] = key;
newArray[array.length + 1] = val;
addedLeaf.val = addedLeaf;
return ensureEditable(edit, count + 1, newArray);
}
// nest it in a bitmap node
return
new BitmapIndexedNode(edit,
bitpos(this.hash, shift),
new Object[] {null, this, null, null})
.assoc(edit, shift, hash, key, val, addedLeaf);
}
public INode without(AtomicReference<Thread> edit, int s hift,
int hash, Object key, Box removedLeaf){
int idx = findIndex(key);
9.79. PERSISTENTHASHMAP.JAVA 969
if(idx == -1)
return this;
if(count == 1)
return null;
HashCollisionNode editable = ensureEditable(edit);
editable.array[idx] = editable.array[2*count-2];
editable.array[idx+1] = editable.array[2*count-1];
editable.array[2*count-2] = editable.array[2*count-1] = null;
editable.count--;
return editable;
}
}
———-
(IEditableCollection [774]) (IObj [800])
— PersistentHashMap.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
/*
A persistent rendition of Phil Bagwell’s Hash Array Mapped T rie
Uses path copying for persistence
HashCollision leaves vs. extended hashing
Node polymorphism vs. conditionals
No sub-tree pools or root-resizing
Any errors are my own
*/
public class PersistentHashMap
extends APersistentMap implements IEditableCollection, IObj {
final int count;
final INode root;
final boolean hasNull;
final Object nullValue;
final IPersistentMap _meta;
final public static PersistentHashMap EMPTY =
new PersistentHashMap(0, null, false, null);
970 CHAPTER 9. JVM/CLOJURE/LANG/
final private static Object NOT_FOUND = new Object();
static public IPersistentMap create(Map other){
ITransientMap ret = EMPTY.asTransient();
for(Object o : other.entrySet())
{
Map.Entry e = (Entry) o;
ret = ret.assoc(e.getKey(), e.getValue());
}
return ret.persistent();
}
/*
* @param init {key1,val1,key2,val2,...}
*/
public static PersistentHashMap create(Object... init){
ITransientMap ret = EMPTY.asTransient();
for(int i = 0; i < init.length; i += 2)
{
ret = ret.assoc(init[i], init[i + 1]);
}
return (PersistentHashMap) ret.persistent();
}
public static PersistentHashMap createWithCheck(Object ... init){
ITransientMap ret = EMPTY.asTransient();
for(int i = 0; i < init.length; i += 2)
{
ret = ret.assoc(init[i], init[i + 1]);
if(ret.count() != i/2 + 1)
throw new IllegalArgumentException(
"Duplicate key: " + init[i]);
}
return (PersistentHashMap) ret.persistent();
}
static public PersistentHashMap create(ISeq items){
ITransientMap ret = EMPTY.asTransient();
for(; items != null; items = items.next().next())
{
if(items.next() == null)
throw new IllegalArgumentException(String.format(
"No value supplied for key: %s", items.first()));
ret = ret.assoc(items.first(), RT.second(items));
}
return (PersistentHashMap) ret.persistent();
}
static public PersistentHashMap createWithCheck(ISeq it ems){
ITransientMap ret = EMPTY.asTransient();
9.79. PERSISTENTHASHMAP.JAVA 971
for(int i=0; items != null; items = items.next().next(), ++ i)
{
if(items.next() == null)
throw new IllegalArgumentException(String.format(
"No value supplied for key: %s", items.first()));
ret = ret.assoc(items.first(), RT.second(items));
if(ret.count() != i + 1)
throw new IllegalArgumentException(
"Duplicate key: " + items.first());
}
return (PersistentHashMap) ret.persistent();
}
/*
* @param init {key1,val1,key2,val2,...}
*/
public static PersistentHashMap create(IPersistentMap m eta,
Object... init){
return create(init).withMeta(meta);
}
PersistentHashMap(int count,
INode root,
boolean hasNull,
Object nullValue){
this.count = count;
this.root = root;
this.hasNull = hasNull;
this.nullValue = nullValue;
this._meta = null;
}
public PersistentHashMap(IPersistentMap meta,
int count,
INode root,
boolean hasNull,
Object nullValue){
this._meta = meta;
this.count = count;
this.root = root;
this.hasNull = hasNull;
this.nullValue = nullValue;
}
public boolean containsKey(Object key){
if(key == null)
return hasNull;
return (root != null)
? root.find(0, Util.hash(key), key, NOT_FOUND) != NOT_FOU ND
: false;
972 CHAPTER 9. JVM/CLOJURE/LANG/
}
public IMapEntry entryAt(Object key){
if(key == null)
return hasNull ? new MapEntry(null, nullValue) : null;
return (root != null) ? root.find(0, Util.hash(key), key) : null;
}
public IPersistentMap assoc(Object key, Object val){
if(key == null) {
if(hasNull && val == nullValue)
return this;
return new PersistentHashMap(meta(),
hasNull ? count : count + 1,
root, true, val);
}
Box addedLeaf = new Box(null);
INode newroot = (root == null ? BitmapIndexedNode.EMPTY : ro ot)
.assoc(0, Util.hash(key), key, val, addedLeaf);
if(newroot == root)
return this;
return new PersistentHashMap(meta(),
addedLeaf.val == null
? count
: count + 1,
newroot, hasNull, nullValue);
}
public Object valAt(Object key, Object notFound){
if(key == null)
return hasNull ? nullValue : notFound;
return root != null
? root.find(0, Util.hash(key), key, notFound)
: notFound;
}
public Object valAt(Object key){
return valAt(key, null);
}
public IPersistentMap assocEx(Object key, Object val) thr ows Exception{
if(containsKey(key))
throw new Exception("Key already present");
return assoc(key, val);
}
public IPersistentMap without(Object key){
if(key == null)
return
hasNull
9.79. PERSISTENTHASHMAP.JAVA 973
? new PersistentHashMap(meta(), count - 1, root, false, nul l)
: this;
if(root == null)
return this;
INode newroot = root.without(0, Util.hash(key), key);
if(newroot == root)
return this;
return
new PersistentHashMap(meta(), count - 1, newroot,
hasNull, nullValue);
}
public Iterator iterator(){
return new SeqIterator(seq());
}
public int count(){
return count;
}
public ISeq seq(){
ISeq s = root != null ? root.nodeSeq() : null;
return hasNull ? new Cons(new MapEntry(null, nullValue), s ) : s;
}
public IPersistentCollection empty(){
return EMPTY.withMeta(meta());
}
\getchunk{PersistentHashMap mask method}
public PersistentHashMap withMeta(IPersistentMap meta) {
return new PersistentHashMap(meta, count, root, hasNull, nullValue);
}
public TransientHashMap asTransient() {
return new TransientHashMap(this);
}
public IPersistentMap meta(){
return _meta;
}
static final class TransientHashMap extends ATransientMa p {
AtomicReference<Thread> edit;
INode root;
int count;
boolean hasNull;
Object nullValue;
final Box leafFlag = new Box(null);
974 CHAPTER 9. JVM/CLOJURE/LANG/
TransientHashMap(PersistentHashMap m) {
this(new AtomicReference<Thread>(Thread.currentThrea d()),
m.root, m.count, m.hasNull, m.nullValue);
}
TransientHashMap(AtomicReference<Thread> edit, INode r oot,
int count, boolean hasNull, Object nullValue) {
this.edit = edit;
this.root = root;
this.count = count;
this.hasNull = hasNull;
this.nullValue = nullValue;
}
ITransientMap doAssoc(Object key, Object val) {
if (key == null) {
if (this.nullValue != val)
this.nullValue = val;
if (!hasNull) {
this.count++;
this.hasNull = true;
}
return this;
}
// Box leafFlag = new Box(null);
leafFlag.val = null;
INode n = (root == null ? BitmapIndexedNode.EMPTY : root)
.assoc(edit, 0, Util.hash(key), key, val, leafFlag);
if (n != this.root)
this.root = n;
if(leafFlag.val != null) this.count++;
return this;
}
ITransientMap doWithout(Object key) {
if (key == null) {
if (!hasNull) return this;
hasNull = false;
nullValue = null;
this.count--;
return this;
}
if (root == null) return this;
// Box leafFlag = new Box(null);
leafFlag.val = null;
INode n = root.without(edit, 0, Util.hash(key), key, leafF lag);
if (n != root)
this.root = n;
9.79. PERSISTENTHASHMAP.JAVA 975
if(leafFlag.val != null) this.count--;
return this;
}
IPersistentMap doPersistent() {
edit.set(null);
return new PersistentHashMap(count, root, hasNull, nullV alue);
}
Object doValAt(Object key, Object notFound) {
if (key == null)
if (hasNull)
return nullValue;
else
return notFound;
if (root == null)
return null;
return root.find(0, Util.hash(key), key, notFound);
}
int doCount() {
return count;
}
void ensureEditable(){
Thread owner = edit.get();
if(owner == Thread.currentThread())
return;
if(owner != null)
throw new IllegalAccessError(
"Transient used by non-owner thread");
throw new IllegalAccessError(
"Transient used after persistent! call");
}
}
\getchunk{PersistentHashMap INode interface}
\getchunk{PersistentHashMap ArrayNode class}
\getchunk{PersistentHashMap BitmapIndexedNode class}
\getchunk{PersistentHashMap HashCollisionNode class}
/*
public static void main(String[] args){
try
{
ArrayList words = new ArrayList();
Scanner s = new Scanner(new File(args[0]));
976 CHAPTER 9. JVM/CLOJURE/LANG/
s.useDelimiter(Pattern.compile("\\W"));
while(s.hasNext())
{
String word = s.next();
words.add(word);
}
System.out.println("words: " + words.size());
IPersistentMap map = PersistentHashMap.EMPTY;
//IPersistentMap map = new PersistentTreeMap();
//Map ht = new Hashtable();
Map ht = new HashMap();
Random rand;
System.out.println("Building map");
long startTime = System.nanoTime();
for(Object word5 : words)
{
map = map.assoc(word5, word5);
}
rand = new Random(42);
IPersistentMap snapshotMap = map;
for(int i = 0; i < words.size() / 200; i++)
{
map = map.without(words.get(rand.nextInt(words.size() / 2)));
}
long estimatedTime = System.nanoTime() - startTime;
System.out.println("count = " + map.count() +
", time: " + estimatedTime / 1000000);
System.out.println("Building ht");
startTime = System.nanoTime();
for(Object word1 : words)
{
ht.put(word1, word1);
}
rand = new Random(42);
for(int i = 0; i < words.size() / 200; i++)
{
ht.remove(words.get(rand.nextInt(words.size() / 2)));
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("count = " + ht.size() +
", time: " + estimatedTime / 1000000);
System.out.println("map lookup");
startTime = System.nanoTime();
int c = 0;
for(Object word2 : words)
{
if(!map.contains(word2))
9.79. PERSISTENTHASHMAP.JAVA 977
++c;
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("notfound = " + c +
", time: " + estimatedTime / 1000000);
System.out.println("ht lookup");
startTime = System.nanoTime();
c = 0;
for(Object word3 : words)
{
if(!ht.containsKey(word3))
++c;
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("notfound = " + c +
", time: " + estimatedTime / 1000000);
System.out.println("snapshotMap lookup");
startTime = System.nanoTime();
c = 0;
for(Object word4 : words)
{
if(!snapshotMap.contains(word4))
++c;
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("notfound = " + c +
", time: " + estimatedTime / 1000000);
}
catch(FileNotFoundException e)
{
e.printStackTrace();
}
}
*/
private static INode[] cloneAndSet(INode[] array, int i, I Node a) {
INode[] clone = array.clone();
clone[i] = a;
return clone;
}
private static Object[] cloneAndSet(Object[] array, int i , Object a) {
Object[] clone = array.clone();
clone[i] = a;
return clone;
}
private static Object[] cloneAndSet(Object[] array, int i ,
Object a, int j, Object b) {
978 CHAPTER 9. JVM/CLOJURE/LANG/
Object[] clone = array.clone();
clone[i] = a;
clone[j] = b;
return clone;
}
private static Object[] removePair(Object[] array, int i) {
Object[] newArray = new Object[array.length - 2];
System.arraycopy(array, 0, newArray, 0, 2*i);
System.arraycopy(array, 2*(i+1), newArray,
2*i, newArray.length - 2*i);
return newArray;
}
private static INode createNode(int shift, Object key1, Ob ject val1,
int key2hash, Object key2,
Object val2) {
int key1hash = Util.hash(key1);
if(key1hash == key2hash)
return
new HashCollisionNode(null, key1hash, 2,
new Object[] {key1, val1, key2, val2});
Box _ = new Box(null);
AtomicReference<Thread> edit = new AtomicReference<Thre ad>();
return BitmapIndexedNode.EMPTY
.assoc(edit, shift, key1hash, key1, val1, _)
.assoc(edit, shift, key2hash, key2, val2, _);
}
private static INode createNode(AtomicReference<Thread > edit,
int shift, Object key1, Object val1,
int key2hash, Object key2,
Object val2) {
int key1hash = Util.hash(key1);
if(key1hash == key2hash)
return
new HashCollisionNode(null, key1hash, 2,
new Object[] {key1, val1, key2, val2});
Box _ = new Box(null);
return BitmapIndexedNode.EMPTY
.assoc(edit, shift, key1hash, key1, val1, _)
.assoc(edit, shift, key2hash, key2, val2, _);
}
private static int bitpos(int hash, int shift){
return 1 << mask(hash, shift);
}
static final class NodeSeq extends ASeq {
final Object[] array;
9.79. PERSISTENTHASHMAP.JAVA 979
final int i;
final ISeq s;
NodeSeq(Object[] array, int i) {
this(null, array, i, null);
}
static ISeq create(Object[] array) {
return create(array, 0, null);
}
private static ISeq create(Object[] array, int i, ISeq s) {
if(s != null)
return new NodeSeq(null, array, i, s);
for(int j = i; j < array.length; j+=2) {
if(array[j] != null)
return new NodeSeq(null, array, j, null);
INode node = (INode) array[j+1];
if (node != null) {
ISeq nodeSeq = node.nodeSeq();
if(nodeSeq != null)
return new NodeSeq(null, array, j + 2, nodeSeq);
}
}
return null;
}
NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s ) {
super(meta);
this.array = array;
this.i = i;
this.s = s;
}
public Obj withMeta(IPersistentMap meta) {
return new NodeSeq(meta, array, i, s);
}
public Object first() {
if(s != null)
return s.first();
return new MapEntry(array[i], array[i+1]);
}
public ISeq next() {
if(s != null)
return create(array, i, s.next());
return create(array, i + 2, null);
}
}
980 CHAPTER 9. JVM/CLOJURE/LANG/
}
———-
9.80 PersistentHashSet.java
(APersistentSet [538]) (IObj [800]) (IEditableCollection [774])
— PersistentHashSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
import java.util.List;
public class PersistentHashSet
extends APersistentSet implements IObj, IEditableCollec tion {
static public final PersistentHashSet EMPTY =
new PersistentHashSet(null, PersistentHashMap.EMPTY);
final IPersistentMap _meta;
public static PersistentHashSet create(Object... init){
PersistentHashSet ret = EMPTY;
for(int i = 0; i < init.length; i++)
{
ret = (PersistentHashSet) ret.cons(init[i]);
}
return ret;
}
public static PersistentHashSet create(List init){
PersistentHashSet ret = EMPTY;
for(Object key : init)
{
ret = (PersistentHashSet) ret.cons(key);
}
return ret;
}
static public PersistentHashSet create(ISeq items){
PersistentHashSet ret = EMPTY;
for(; items != null; items = items.next())
9.80. PERSISTENTHASHSET.JAVA 981
{
ret = (PersistentHashSet) ret.cons(items.first());
}
return ret;
}
public static PersistentHashSet createWithCheck(Object ... init){
PersistentHashSet ret = EMPTY;
for(int i = 0; i < init.length; i++)
{
ret = (PersistentHashSet) ret.cons(init[i]);
if(ret.count() != i + 1)
throw new IllegalArgumentException(
"Duplicate key: " + init[i]);
}
return ret;
}
public static PersistentHashSet createWithCheck(List in it){
PersistentHashSet ret = EMPTY;
int i=0;
for(Object key : init)
{
ret = (PersistentHashSet) ret.cons(key);
if(ret.count() != i + 1)
throw new IllegalArgumentException("Duplicate key: " + ke y);
++i;
}
return ret;
}
static public PersistentHashSet createWithCheck(ISeq it ems){
PersistentHashSet ret = EMPTY;
for(int i=0; items != null; items = items.next(), ++i)
{
ret = (PersistentHashSet) ret.cons(items.first());
if(ret.count() != i + 1)
throw new IllegalArgumentException(
"Duplicate key: " + items.first());
}
return ret;
}
PersistentHashSet(IPersistentMap meta, IPersistentMap impl){
super(impl);
this._meta = meta;
}
public IPersistentSet disjoin(Object key) throws Excepti on{
if(contains(key))
982 CHAPTER 9. JVM/CLOJURE/LANG/
return new PersistentHashSet(meta(),impl.without(key) );
return this;
}
public IPersistentSet cons(Object o){
if(contains(o))
return this;
return new PersistentHashSet(meta(),impl.assoc(o,o));
}
public IPersistentCollection empty(){
return EMPTY.withMeta(meta());
}
public PersistentHashSet withMeta(IPersistentMap meta) {
return new PersistentHashSet(meta, impl);
}
public ITransientCollection asTransient() {
return
new TransientHashSet(((PersistentHashMap) impl).asTra nsient());
}
public IPersistentMap meta(){
return _meta;
}
static final class TransientHashSet extends ATransientSe t {
TransientHashSet(ITransientMap impl) {
super(impl);
}
public IPersistentCollection persistent() {
return new PersistentHashSet(null, impl.persistent());
}
}
}
———-
9.81 PersistentList.java
(ASeq[571])(IPersistentList[801])(IReduce[804])(List[1723])(C ounted[768])
— PersistentList.java —
/*
\getchunk{Clojure Copyright}
9.81. PERSISTENTLIST.JAVA 983
*/
package clojure.lang;
import java.io.Serializable;
import java.util.*;
public class PersistentList
extends ASeq implements IPersistentList, IReduce, List, C ounted {
private final Object _first;
private final IPersistentList _rest;
private final int _count;
public static IFn creator = new RestFn(){
final public int getRequiredArity(){
return 0;
}
final protected Object doInvoke(Object args) throws Excep tion{
if(args instanceof ArraySeq)
{
Object[] argsarray = (Object[]) ((ArraySeq) args).array;
IPersistentList ret = EMPTY;
for(int i = argsarray.length - 1; i >= 0; --i)
ret = (IPersistentList) ret.cons(argsarray[i]);
return ret;
}
LinkedList list = new LinkedList();
for(ISeq s = RT.seq(args); s != null; s = s.next())
list.add(s.first());
return create(list);
}
public IObj withMeta(IPersistentMap meta){
throw new UnsupportedOperationException();
}
public IPersistentMap meta(){
return null;
}
};
final public static EmptyList EMPTY = new EmptyList(null);
public PersistentList(Object first){
this._first = first;
this._rest = null;
this._count = 1;
}
984 CHAPTER 9. JVM/CLOJURE/LANG/
PersistentList(IPersistentMap meta,
Object _first,
IPersistentList _rest,
int _count){
super(meta);
this._first = _first;
this._rest = _rest;
this._count = _count;
}
public static IPersistentList create(List init){
IPersistentList ret = EMPTY;
for(ListIterator i = init.listIterator(init.size())
; i.hasPrevious();)
{
ret = (IPersistentList) ret.cons(i.previous());
}
return ret;
}
public Object first(){
return _first;
}
public ISeq next(){
if(_count == 1)
return null;
return (ISeq) _rest;
}
public Object peek(){
return first();
}
public IPersistentList pop(){
if(_rest == null)
return EMPTY.withMeta(_meta);
return _rest;
}
public int count(){
return _count;
}
public PersistentList cons(Object o){
return new PersistentList(meta(), o, this, _count + 1);
}
public IPersistentCollection empty(){
9.81. PERSISTENTLIST.JAVA 985
return EMPTY.withMeta(meta());
}
public PersistentList withMeta(IPersistentMap meta){
if(meta != _meta)
return new PersistentList(meta, _first, _rest, _count);
return this;
}
public Object reduce(IFn f) throws Exception{
Object ret = first();
for(ISeq s = next(); s != null; s = s.next())
ret = f.invoke(ret, s.first());
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start, first());
for(ISeq s = next(); s != null; s = s.next())
ret = f.invoke(ret, s.first());
return ret;
}
static class EmptyList
extends Obj implements IPersistentList, List, ISeq, Count ed{
public int hashCode(){
return 1;
}
public boolean equals(Object o) {
return (o instanceof Sequential ||
o instanceof List) &&
RT.seq(o) == null;
}
public boolean equiv(Object o){
return equals(o);
}
EmptyList(IPersistentMap meta){
super(meta);
}
public Object first() {
return null;
}
public ISeq next() {
986 CHAPTER 9. JVM/CLOJURE/LANG/
return null;
}
public ISeq more() {
return this;
}
public PersistentList cons(Object o){
return new PersistentList(meta(), o, null, 1);
}
public IPersistentCollection empty(){
return this;
}
public EmptyList withMeta(IPersistentMap meta){
if(meta != meta())
return new EmptyList(meta);
return this;
}
public Object peek(){
return null;
}
public IPersistentList pop(){
throw new IllegalStateException("Can’t pop empty list");
}
public int count(){
return 0;
}
public ISeq seq(){
return null;
}
public int size(){
return 0;
}
public boolean isEmpty(){
return true;
}
public boolean contains(Object o){
return false;
}
9.81. PERSISTENTLIST.JAVA 987
public Iterator iterator(){
return new Iterator(){
public boolean hasNext(){
return false;
}
public Object next(){
throw new NoSuchElementException();
}
public void remove(){
throw new UnsupportedOperationException();
}
};
}
public Object[] toArray(){
return RT.EMPTY_ARRAY;
}
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
}
public boolean addAll(Collection collection){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection collection){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection collection){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection collection){
return collection.isEmpty();
}
public Object[] toArray(Object[] objects){
988 CHAPTER 9. JVM/CLOJURE/LANG/
if(objects.length > 0)
objects[0] = null;
return objects;
}
//////////// List stuff /////////////////
private List reify(){
return Collections.unmodifiableList(new ArrayList(thi s));
}
public List subList(int fromIndex, int toIndex){
return reify().subList(fromIndex, toIndex);
}
public Object set(int index, Object element){
throw new UnsupportedOperationException();
}
public Object remove(int index){
throw new UnsupportedOperationException();
}
public int indexOf(Object o){
ISeq s = seq();
for(int i = 0; s != null; s = s.next(), i++)
{
if(Util.equiv(s.first(), o))
return i;
}
return -1;
}
public int lastIndexOf(Object o){
return reify().lastIndexOf(o);
}
public ListIterator listIterator(){
return reify().listIterator();
}
public ListIterator listIterator(int index){
return reify().listIterator(index);
}
public Object get(int index){
return RT.nth(this, index);
}
public void add(int index, Object element){
throw new UnsupportedOperationException();
9.82. PERSISTENTQUEUE.JAVA 989
}
public boolean addAll(int index, Collection c){
throw new UnsupportedOperationException();
}
}
}
———-
9.82 PersistentQueue.java
(Obj [947]) (IPersistentList [801]) (Collection [1723]) (Counted [768 ])
— PersistentQueue.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
import java.util.Collection;
import java.util.Iterator;
//import java.util.concurrent.ConcurrentLinkedQueue;
/**
* conses onto rear, peeks/pops from front
* See Okasaki’s Batched Queues
* This differs in that it uses a PersistentVector as the rear,
* which is in-order,
* so no reversing or suspensions required for persistent use
*/
public class PersistentQueue
extends Obj implements IPersistentList, Collection, Coun ted{
final public static PersistentQueue EMPTY =
new PersistentQueue(null, 0, null, null);
//*
final int cnt;
final ISeq f;
final PersistentVector r;
//static final int INITIAL_REAR_SIZE = 4;
int _hash = -1;
990 CHAPTER 9. JVM/CLOJURE/LANG/
PersistentQueue(IPersistentMap meta,
int cnt,
ISeq f,
PersistentVector r){
super(meta);
this.cnt = cnt;
this.f = f;
this.r = r;
}
public boolean equiv(Object obj){
if(!(obj instanceof Sequential))
return false;
ISeq ms = RT.seq(obj);
for(ISeq s = seq(); s != null; s = s.next(), ms = ms.next())
{
if(ms == null || !Util.equiv(s.first(), ms.first()))
return false;
}
return ms == null;
}
public boolean equals(Object obj){
if(!(obj instanceof Sequential))
return false;
ISeq ms = RT.seq(obj);
for(ISeq s = seq(); s != null; s = s.next(), ms = ms.next())
{
if(ms == null || !Util.equals(s.first(), ms.first()))
return false;
}
return ms == null;
}
public int hashCode(){
if(_hash == -1)
{
int hash = 0;
for(ISeq s = seq(); s != null; s = s.next())
{
hash = Util.hashCombine(hash, Util.hash(s.first()));
}
this._hash = hash;
}
return _hash;
}
9.82. PERSISTENTQUEUE.JAVA 991
public Object peek(){
return RT.first(f);
}
public PersistentQueue pop(){
if(f == null) //hmmm... pop of empty queue -> empty queue?
return this;
//throw new IllegalStateException("popping empty queue" );
ISeq f1 = f.next();
PersistentVector r1 = r;
if(f1 == null)
{
f1 = RT.seq(r);
r1 = null;
}
return new PersistentQueue(meta(), cnt - 1, f1, r1);
}
public int count(){
return cnt;
}
public ISeq seq(){
if(f == null)
return null;
return new Seq(f, RT.seq(r));
}
public PersistentQueue cons(Object o){
if(f == null) //empty
return new PersistentQueue(meta(), cnt + 1, RT.list(o), nu ll);
else
return new PersistentQueue(meta(), cnt + 1, f,
(r != null
? r
: PersistentVector.EMPTY).cons(o));
}
public IPersistentCollection empty(){
return EMPTY.withMeta(meta());
}
public PersistentQueue withMeta(IPersistentMap meta){
return new PersistentQueue(meta, cnt, f, r);
}
static class Seq extends ASeq{
final ISeq f;
final ISeq rseq;
992 CHAPTER 9. JVM/CLOJURE/LANG/
Seq(ISeq f, ISeq rseq){
this.f = f;
this.rseq = rseq;
}
Seq(IPersistentMap meta, ISeq f, ISeq rseq){
super(meta);
this.f = f;
this.rseq = rseq;
}
public Object first(){
return f.first();
}
public ISeq next(){
ISeq f1 = f.next();
ISeq r1 = rseq;
if(f1 == null)
{
if(rseq == null)
return null;
f1 = rseq;
r1 = null;
}
return new Seq(f1, r1);
}
public int count(){
return RT.count(f) + RT.count(rseq);
}
public Seq withMeta(IPersistentMap meta){
return new Seq(meta, f, rseq);
}
}
// java.util.Collection implementation
public Object[] toArray(){
return RT.seqToArray(seq());
}
public boolean add(Object o){
throw new UnsupportedOperationException();
}
public boolean remove(Object o){
throw new UnsupportedOperationException();
9.82. PERSISTENTQUEUE.JAVA 993
}
public boolean addAll(Collection c){
throw new UnsupportedOperationException();
}
public void clear(){
throw new UnsupportedOperationException();
}
public boolean retainAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean removeAll(Collection c){
throw new UnsupportedOperationException();
}
public boolean containsAll(Collection c){
for(Object o : c)
{
if(contains(o))
return true;
}
return false;
}
public Object[] toArray(Object[] a){
if(a.length >= count())
{
ISeq s = seq();
for(int i = 0; s != null; ++i, s = s.next())
{
a[i] = s.first();
}
if(a.length >= count())
a[count()] = null;
return a;
}
else
return toArray();
}
public int size(){
return count();
}
public boolean isEmpty(){
return count() == 0;
}
994 CHAPTER 9. JVM/CLOJURE/LANG/
public boolean contains(Object o){
for(ISeq s = seq(); s != null; s = s.next())
{
if(Util.equiv(s.first(), o))
return true;
}
return false;
}
public Iterator iterator(){
return new SeqIterator(seq());
}
/*
public static void main(String[] args){
if(args.length != 1)
{
System.err.println("Usage: PersistentQueue n");
return;
}
int n = Integer.parseInt(args[0]);
long startTime, estimatedTime;
Queue list = new LinkedList();
//Queue list = new ConcurrentLinkedQueue();
System.out.println("Queue");
startTime = System.nanoTime();
for(int i = 0; i < n; i++)
{
list.add(i);
list.add(i);
list.remove();
}
for(int i = 0; i < n - 10; i++)
{
list.remove();
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("time: " + estimatedTime / 1000000);
System.out.println("peek: " + list.peek());
PersistentQueue q = PersistentQueue.EMPTY;
System.out.println("PersistentQueue");
startTime = System.nanoTime();
for(int i = 0; i < n; i++)
{
9.83. PERSISTENTSTRUCTMAP.JAVA 995
q = q.cons(i);
q = q.cons(i);
q = q.pop();
}
// IPersistentList lastq = null;
// IPersistentList lastq2;
for(int i = 0; i < n - 10; i++)
{
//lastq2 = lastq;
//lastq = q;
q = q.pop();
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("time: " + estimatedTime / 1000000);
System.out.println("peek: " + q.peek());
IPersistentList q2 = q;
for(int i = 0; i < 10; i++)
{
q2 = (IPersistentList) q2.cons(i);
}
// for(ISeq s = q.seq();s != null;s = s.rest())
// System.out.println("q: " + s.first().toString());
// for(ISeq s = q2.seq();s != null;s = s.rest())
// System.out.println("q2: " + s.first().toString());
}
*/
}
———-
9.83 PersistentStructMap.java
(APersistentMap [530]) (IObj [800])
— PersistentStructMap.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 16, 2007 */
package clojure.lang;
import java.util.Iterator;
import java.util.Map;
import java.io.Serializable;
public class PersistentStructMap extends APersistentMap implements IObj{
996 CHAPTER 9. JVM/CLOJURE/LANG/
public static class Def implements Serializable{
final ISeq keys;
final IPersistentMap keyslots;
Def(ISeq keys, IPersistentMap keyslots){
this.keys = keys;
this.keyslots = keyslots;
}
}
final Def def;
final Object[] vals;
final IPersistentMap ext;
final IPersistentMap _meta;
static public Def createSlotMap(ISeq keys){
if(keys == null)
throw new IllegalArgumentException("Must supply keys");
int c = RT.count(keys);
Object[] v = new Object[2*c];
int i = 0;
for(ISeq s = keys; s != null; s = s.next(), i++)
{
v[2*i] = s.first();
v[2*i+1] = i;
}
return new Def(keys, RT.map(v));
}
static public PersistentStructMap create(Def def, ISeq ke yvals){
Object[] vals = new Object[def.keyslots.count()];
IPersistentMap ext = PersistentHashMap.EMPTY;
for(; keyvals != null; keyvals = keyvals.next().next())
{
if(keyvals.next() == null)
throw new IllegalArgumentException(String.format(
"No value supplied for key: %s", keyvals.first()));
Object k = keyvals.first();
Object v = RT.second(keyvals);
Map.Entry e = def.keyslots.entryAt(k);
if(e != null)
vals[(Integer) e.getValue()] = v;
else
ext = ext.assoc(k, v);
}
return new PersistentStructMap(null, def, vals, ext);
}
9.83. PERSISTENTSTRUCTMAP.JAVA 997
static public PersistentStructMap construct(Def def, ISe q valseq){
Object[] vals = new Object[def.keyslots.count()];
IPersistentMap ext = PersistentHashMap.EMPTY;
for(int i = 0;
i < vals.length && valseq != null; valseq = valseq.next(),
i++)
{
vals[i] = valseq.first();
}
if(valseq != null)
throw new IllegalArgumentException(
"Too many arguments to struct constructor");
return new PersistentStructMap(null, def, vals, ext);
}
static public IFn getAccessor(final Def def, Object key){
Map.Entry e = def.keyslots.entryAt(key);
if(e != null)
{
final int i = (Integer) e.getValue();
return new AFn(){
public Object invoke(Object arg1) throws Exception{
PersistentStructMap m = (PersistentStructMap) arg1;
if(m.def != def)
throw new Exception("Accessor/struct mismatch");
return m.vals[i];
}
};
}
throw new IllegalArgumentException("Not a key of struct") ;
}
protected PersistentStructMap(IPersistentMap meta, Def def,
Object[] vals, IPersistentMap ext){
this._meta = meta;
this.ext = ext;
this.def = def;
this.vals = vals;
}
/**
* Returns a new instance of PersistentStructMap using the gi ven
* parameters. This function is used instead of the
* PersistentStructMap constructor by all methods that retu rn a
* new PersistentStructMap. This is done so as to allow subcla sses
* to return instances of their class from all PersistentStru ctMap
* methods.
*/
protected PersistentStructMap makeNew(IPersistentMap m eta,
Def def,
998 CHAPTER 9. JVM/CLOJURE/LANG/
Object[] vals,
IPersistentMap ext){
return new PersistentStructMap(meta, def, vals, ext);
}
public IObj withMeta(IPersistentMap meta){
if(meta == _meta)
return this;
return makeNew(meta, def, vals, ext);
}
public IPersistentMap meta(){
return _meta;
}
public boolean containsKey(Object key){
return def.keyslots.containsKey(key) || ext.containsKe y(key);
}
public IMapEntry entryAt(Object key){
Map.Entry e = def.keyslots.entryAt(key);
if(e != null)
{
return new MapEntry(e.getKey(), vals[(Integer) e.getVal ue()]);
}
return ext.entryAt(key);
}
public IPersistentMap assoc(Object key, Object val){
Map.Entry e = def.keyslots.entryAt(key);
if(e != null)
{
int i = (Integer) e.getValue();
Object[] newVals = vals.clone();
newVals[i] = val;
return makeNew(_meta, def, newVals, ext);
}
return makeNew(_meta, def, vals, ext.assoc(key, val));
}
public Object valAt(Object key){
Integer i = (Integer) def.keyslots.valAt(key);
if(i != null)
{
return vals[i];
}
return ext.valAt(key);
}
public Object valAt(Object key, Object notFound){
9.83. PERSISTENTSTRUCTMAP.JAVA 999
Integer i = (Integer) def.keyslots.valAt(key);
if(i != null)
{
return vals[i];
}
return ext.valAt(key, notFound);
}
public IPersistentMap assocEx(Object key, Object val) thr ows Exception{
if(containsKey(key))
throw new Exception("Key already present");
return assoc(key, val);
}
public IPersistentMap without(Object key) throws Excepti on{
Map.Entry e = def.keyslots.entryAt(key);
if(e != null)
throw new Exception("Can’t remove struct key");
IPersistentMap newExt = ext.without(key);
if(newExt == ext)
return this;
return makeNew(_meta, def, vals, newExt);
}
public Iterator iterator(){
return new SeqIterator(seq());
}
public int count(){
return vals.length + RT.count(ext);
}
public ISeq seq(){
return new Seq(null, def.keys, vals, 0, ext);
}
public IPersistentCollection empty(){
return construct(def, null);
}
static class Seq extends ASeq{
final int i;
final ISeq keys;
final Object[] vals;
final IPersistentMap ext;
public Seq(IPersistentMap meta,
ISeq keys,
1000 CHAPTER 9. JVM/CLOJURE/LANG/
Object[] vals,
int i,
IPersistentMap ext){
super(meta);
this.i = i;
this.keys = keys;
this.vals = vals;
this.ext = ext;
}
public Obj withMeta(IPersistentMap meta){
if(meta != _meta)
return new Seq(meta, keys, vals, i, ext);
return this;
}
public Object first(){
return new MapEntry(keys.first(), vals[i]);
}
public ISeq next(){
if(i + 1 < vals.length)
return new Seq(_meta, keys.next(), vals, i + 1, ext);
return ext.seq();
}
}
}
———-
9.84 PersistentTreeMap.java
(APersistentMap [530]) (IObj [800]) (Reversible [1094]) (Sorted [11 41])
— PersistentTreeMap.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich May 20, 2006 */
package clojure.lang;
import java.util.*;
/**
* Persistent Red Black Tree
* Note that instances of this class are constant values
* i.e. add/remove etc return new values
9.84. PERSISTENTTREEMAP.JAVA 1001
* <p/>
* See Okasaki, Kahrs, Larsen et al
*/
public class PersistentTreeMap
extends APersistentMap implements IObj, Reversible, Sort ed{
public final Comparator comp;
public final Node tree;
public final int _count;
final IPersistentMap _meta;
final static public PersistentTreeMap EMPTY = new Persiste ntTreeMap();
static public IPersistentMap create(Map other){
IPersistentMap ret = EMPTY;
for(Object o : other.entrySet())
{
Map.Entry e = (Entry) o;
ret = ret.assoc(e.getKey(), e.getValue());
}
return ret;
}
public PersistentTreeMap(){
this(RT.DEFAULT_COMPARATOR);
}
public PersistentTreeMap withMeta(IPersistentMap meta) {
return new PersistentTreeMap(meta, comp, tree, _count);
}
private PersistentTreeMap(Comparator comp){
this(null, comp);
}
public PersistentTreeMap(IPersistentMap meta, Comparat or comp){
this.comp = comp;
this._meta = meta;
tree = null;
_count = 0;
}
PersistentTreeMap(IPersistentMap meta,
Comparator comp,
Node tree,
int _count){
this._meta = meta;
this.comp = comp;
1002 CHAPTER 9. JVM/CLOJURE/LANG/
this.tree = tree;
this._count = _count;
}
static public PersistentTreeMap create(ISeq items){
IPersistentMap ret = EMPTY;
for(; items != null; items = items.next().next())
{
if(items.next() == null)
throw new IllegalArgumentException(String.format(
"No value supplied for key: %s", items.first()));
ret = ret.assoc(items.first(), RT.second(items));
}
return (PersistentTreeMap) ret;
}
static public PersistentTreeMap create(Comparator comp, ISeq items){
IPersistentMap ret = new PersistentTreeMap(comp);
for(; items != null; items = items.next().next())
{
if(items.next() == null)
throw new IllegalArgumentException(String.format(
"No value supplied for key: %s", items.first()));
ret = ret.assoc(items.first(), RT.second(items));
}
return (PersistentTreeMap) ret;
}
public boolean containsKey(Object key){
return entryAt(key) != null;
}
public PersistentTreeMap assocEx(Object key, Object val)
throws Exception{
Box found = new Box(null);
Node t = add(tree, key, val, found);
if(t == null) //null == already contains key
{
throw new Exception("Key already present");
}
return new PersistentTreeMap(comp, t.blacken(), _count + 1, meta());
}
public PersistentTreeMap assoc(Object key, Object val){
Box found = new Box(null);
Node t = add(tree, key, val, found);
if(t == null) //null == already contains key
{
Node foundNode = (Node) found.val;
if(foundNode.val() == val) //note only get same collection
9.84. PERSISTENTTREEMAP.JAVA 1003
//on identity of val, not equals()
return this;
return
new PersistentTreeMap(comp,
replace(tree, key, val),
_count,
meta());
}
return new PersistentTreeMap(comp, t.blacken(), _count + 1, meta());
}
public PersistentTreeMap without(Object key){
Box found = new Box(null);
Node t = remove(tree, key, found);
if(t == null)
{
if(found.val == null)//null == doesn’t contain key
return this;
//empty
return new PersistentTreeMap(meta(), comp);
}
return new PersistentTreeMap(comp, t.blacken(), _count - 1, meta());
}
public ISeq seq(){
if(_count > 0)
return Seq.create(tree, true, _count);
return null;
}
public IPersistentCollection empty(){
return new PersistentTreeMap(meta(), comp);
}
public ISeq rseq() throws Exception{
if(_count > 0)
return Seq.create(tree, false, _count);
return null;
}
public Comparator comparator(){
return comp;
}
public Object entryKey(Object entry){
return ((IMapEntry) entry).key();
}
public ISeq seq(boolean ascending){
1004 CHAPTER 9. JVM/CLOJURE/LANG/
if(_count > 0)
return Seq.create(tree, ascending, _count);
return null;
}
public ISeq seqFrom(Object key, boolean ascending){
if(_count > 0)
{
ISeq stack = null;
Node t = tree;
while(t != null)
{
int c = doCompare(key, t.key);
if(c == 0)
{
stack = RT.cons(t, stack);
return new Seq(stack, ascending);
}
else if(ascending)
{
if(c < 0)
{
stack = RT.cons(t, stack);
t = t.left();
}
else
t = t.right();
}
else
{
if(c > 0)
{
stack = RT.cons(t, stack);
t = t.right();
}
else
t = t.left();
}
}
if(stack != null)
return new Seq(stack, ascending);
}
return null;
}
public NodeIterator iterator(){
return new NodeIterator(tree, true);
}
public NodeIterator reverseIterator(){
9.84. PERSISTENTTREEMAP.JAVA 1005
return new NodeIterator(tree, false);
}
public Iterator keys(){
return keys(iterator());
}
public Iterator vals(){
return vals(iterator());
}
public Iterator keys(NodeIterator it){
return new KeyIterator(it);
}
public Iterator vals(NodeIterator it){
return new ValIterator(it);
}
public Object minKey(){
Node t = min();
return t != null ? t.key : null;
}
public Node min(){
Node t = tree;
if(t != null)
{
while(t.left() != null)
t = t.left();
}
return t;
}
public Object maxKey(){
Node t = max();
return t != null ? t.key : null;
}
public Node max(){
Node t = tree;
if(t != null)
{
while(t.right() != null)
t = t.right();
}
return t;
}
public int depth(){
1006 CHAPTER 9. JVM/CLOJURE/LANG/
return depth(tree);
}
int depth(Node t){
if(t == null)
return 0;
return 1 + Math.max(depth(t.left()), depth(t.right()));
}
public Object valAt(Object key, Object notFound){
Node n = entryAt(key);
return (n != null) ? n.val() : notFound;
}
public Object valAt(Object key){
return valAt(key, null);
}
public int capacity(){
return _count;
}
public int count(){
return _count;
}
public Node entryAt(Object key){
Node t = tree;
while(t != null)
{
int c = doCompare(key, t.key);
if(c == 0)
return t;
else if(c < 0)
t = t.left();
else
t = t.right();
}
return t;
}
public int doCompare(Object k1, Object k2){
// if(comp != null)
return comp.compare(k1, k2);
// return ((Comparable) k1).compareTo(k2);
}
Node add(Node t, Object key, Object val, Box found){
if(t == null)
{
9.84. PERSISTENTTREEMAP.JAVA 1007
if(val == null)
return new Red(key);
return new RedVal(key, val);
}
int c = doCompare(key, t.key);
if(c == 0)
{
found.val = t;
return null;
}
Node ins = c < 0
? add(t.left(), key, val, found)
: add(t.right(), key, val, found);
if(ins == null) //found below
return null;
if(c < 0)
return t.addLeft(ins);
return t.addRight(ins);
}
Node remove(Node t, Object key, Box found){
if(t == null)
return null; //not found indicator
int c = doCompare(key, t.key);
if(c == 0)
{
found.val = t;
return append(t.left(), t.right());
}
Node del = c < 0
? remove(t.left(), key, found)
: remove(t.right(), key, found);
if(del == null && found.val == null) //not found below
return null;
if(c < 0)
{
if(t.left() instanceof Black)
return balanceLeftDel(t.key, t.val(), del, t.right());
else
return red(t.key, t.val(), del, t.right());
}
if(t.right() instanceof Black)
return balanceRightDel(t.key, t.val(), t.left(), del);
return red(t.key, t.val(), t.left(), del);
// return t.removeLeft(del);
// return t.removeRight(del);
}
static Node append(Node left, Node right){
if(left == null)
1008 CHAPTER 9. JVM/CLOJURE/LANG/
return right;
else if(right == null)
return left;
else if(left instanceof Red)
{
if(right instanceof Red)
{
Node app = append(left.right(), right.left());
if(app instanceof Red)
return
red(app.key, app.val(),
red(left.key, left.val(),
left.left(), app.left()),
red(right.key, right.val(),
app.right(), right.right()));
else
return
red(left.key, left.val(), left.left(),
red(right.key, right.val(), app, right.right()));
}
else
return red(left.key, left.val(), left.left(),
append(left.right(), right));
}
else if(right instanceof Red)
return red(right.key, right.val(),
append(left, right.left()), right.right());
else //black/black
{
Node app = append(left.right(), right.left());
if(app instanceof Red)
return
red(app.key, app.val(),
black(left.key, left.val(),
left.left(), app.left()),
black(right.key, right.val(),
app.right(), right.right()));
else
return balanceLeftDel(left.key, left.val(), left.left( ),
black(right.key, right.val(),
app, right.right()));
}
}
\getchunk{PersistentTreeMap balanceLeftDel method}
\getchunk{PersistentTreeMap balanceRightDel method}
\getchunk{PersistentTreeMap leftBalance method}
9.84. PERSISTENTTREEMAP.JAVA 1009
\getchunk{PersistentTreeMap rightBalance method}
\getchunk{PersistentTreeMap replace method}
PersistentTreeMap(Comparator comp, Node tree,
int count, IPersistentMap meta){
this._meta = meta;
this.comp = comp;
this.tree = tree;
this._count = count;
}
\getchunk{PersistentTreeMap red method}
\getchunk{PersistentTreeMap black method}
public IPersistentMap meta(){
return _meta;
}
\getchunk{PersistentTreeMap Node Class}
\getchunk{PersistentTreeMap Black Class}
\getchunk{PersistentTreeMap BlackVal Class}
\getchunk{PersistentTreeMap BlackBranch Class}
\getchunk{PersistentTreeMap BlackBranchVal Class}
\getchunk{PersistentTreeMap Red Class}
\getchunk{PersistentTreeMap RedVal Class}
\getchunk{PersistentTreeMap RedBranch Class}
\getchunk{PersistentTreeMap RedBranchVal Class}
\getchunk{PersistentTreeMap Seq Class}
\getchunk{PersistentTreeMap NodeIterator Class}
\getchunk{PersistentTreeMap KeyIterator Class}
\getchunk{PersistentTreeMap ValIterator Class}
/*
static public void main(String args[]){
if(args.length != 1)
System.err.println("Usage: RBTree n");
1010 CHAPTER 9. JVM/CLOJURE/LANG/
int n = Integer.parseInt(args[0]);
Integer[] ints = new Integer[n];
for(int i = 0; i < ints.length; i++)
{
ints[i] = i;
}
Collections.shuffle(Arrays.asList(ints));
//force the ListMap class loading now
// try
// {
//
// //PersistentListMap.EMPTY.assocEx(1, null)
// .assocEx(2,null).assocEx(3,null);
// }
// catch(Exception e)
// {
// e.printStackTrace(); //To change body of catch statemen t
// //use File | Settings | File Templates.
// }
System.out.println("Building set");
//IPersistentMap set = new PersistentArrayMap();
//IPersistentMap set = new PersistentHashtableMap(1001) ;
IPersistentMap set = PersistentHashMap.EMPTY;
//IPersistentMap set = new ListMap();
//IPersistentMap set = new ArrayMap();
//IPersistentMap set = new PersistentTreeMap();
// for(int i = 0; i < ints.length; i++)
// {
// Integer anInt = ints[i];
// set = set.add(anInt);
// }
long startTime = System.nanoTime();
for(Integer anInt : ints)
{
set = set.assoc(anInt, anInt);
}
//System.out.println("_count = " + set.count());
// System.out.println("_count = " + set._count +
// ", min: " + set.minKey() + ", max: " +
// set.maxKey()
// + ", depth: " + set.depth());
for(Object aSet : set)
{
IMapEntry o = (IMapEntry) aSet;
if(!set.contains(o.key()))
System.err.println("Can’t find: " + o.key());
//else if(n < 2000)
// System.out.print(o.key().toString() + ",");
}
9.84. PERSISTENTTREEMAP.JAVA 1011
Random rand = new Random(42);
for(int i = 0; i < ints.length / 2; i++)
{
Integer anInt = ints[rand.nextInt(n)];
set = set.without(anInt);
}
long estimatedTime = System.nanoTime() - startTime;
System.out.println();
System.out.println("_count = " + set.count() +
", time: " + estimatedTime / 1000000);
System.out.println("Building ht");
Hashtable ht = new Hashtable(1001);
startTime = System.nanoTime();
// for(int i = 0; i < ints.length; i++)
// {
// Integer anInt = ints[i];
// ht.put(anInt,null);
// }
for(Integer anInt : ints)
{
ht.put(anInt, anInt);
}
//System.out.println("size = " + ht.size());
//Iterator it = ht.entrySet().iterator();
for(Object o1 : ht.entrySet())
{
Map.Entry o = (Map.Entry) o1;
if(!ht.containsKey(o.getKey()))
System.err.println("Can’t find: " + o);
//else if(n < 2000)
// System.out.print(o.toString() + ",");
}
rand = new Random(42);
for(int i = 0; i < ints.length / 2; i++)
{
Integer anInt = ints[rand.nextInt(n)];
ht.remove(anInt);
}
estimatedTime = System.nanoTime() - startTime;
System.out.println();
System.out.println("size = " + ht.size() + ", time: " +
estimatedTime / 1000000);
System.out.println("set lookup");
startTime = System.nanoTime();
1012 CHAPTER 9. JVM/CLOJURE/LANG/
int c = 0;
for(Integer anInt : ints)
{
if(!set.contains(anInt))
++c;
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("notfound = " + c + ", time: " +
estimatedTime / 1000000);
System.out.println("ht lookup");
startTime = System.nanoTime();
c = 0;
for(Integer anInt : ints)
{
if(!ht.containsKey(anInt))
++c;
}
estimatedTime = System.nanoTime() - startTime;
System.out.println("notfound = " + c + ", time: " +
estimatedTime / 1000000);
// System.out.println("_count = " + set._count +
// ", min: " + set.minKey() +
// ", max: " + set.maxKey()
// + ", depth: " + set.depth());
}
*/
}
———-
9.85 PersistentTreeSet.java
(APersistentSet [538]) (IObj [800]) (Reversible [1094]) (Sorted [114 1])
— PersistentTreeSet.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
import java.util.Comparator;
public class PersistentTreeSet
extends APersistentSet implements IObj, Reversible, Sort ed{
9.85. PERSISTENTTREESET.JAVA 1013
static public final PersistentTreeSet EMPTY =
new PersistentTreeSet(null, PersistentTreeMap.EMPTY);
final IPersistentMap _meta;
static public PersistentTreeSet create(ISeq items){
PersistentTreeSet ret = EMPTY;
for(; items != null; items = items.next())
{
ret = (PersistentTreeSet) ret.cons(items.first());
}
return ret;
}
static public PersistentTreeSet create(Comparator comp, ISeq items){
PersistentTreeSet ret =
new PersistentTreeSet(null, new PersistentTreeMap(null , comp));
for(; items != null; items = items.next())
{
ret = (PersistentTreeSet) ret.cons(items.first());
}
return ret;
}
PersistentTreeSet(IPersistentMap meta, IPersistentMap impl){
super(impl);
this._meta = meta;
}
public IPersistentSet disjoin(Object key) throws Excepti on{
if(contains(key))
return new PersistentTreeSet(meta(),impl.without(key) );
return this;
}
public IPersistentSet cons(Object o){
if(contains(o))
return this;
return new PersistentTreeSet(meta(),impl.assoc(o,o));
}
public IPersistentCollection empty(){
return
new PersistentTreeSet(meta(),(PersistentTreeMap)impl .empty());
}
public ISeq rseq() throws Exception{
return APersistentMap.KeySeq.create(((Reversible) imp l).rseq());
}
1014 CHAPTER 9. JVM/CLOJURE/LANG/
public PersistentTreeSet withMeta(IPersistentMap meta) {
return new PersistentTreeSet(meta, impl);
}
public Comparator comparator(){
return ((Sorted)impl).comparator();
}
public Object entryKey(Object entry){
return entry;
}
public ISeq seq(boolean ascending){
PersistentTreeMap m = (PersistentTreeMap) impl;
return RT.keys(m.seq(ascending));
}
public ISeq seqFrom(Object key, boolean ascending){
PersistentTreeMap m = (PersistentTreeMap) impl;
return RT.keys(m.seqFrom(key,ascending));
}
public IPersistentMap meta(){
return _meta;
}
}
———-
9.86 PersistentVector.java
(APersistentVector [541]) (IObj [800]) (IEditableCollection [774])
— PersistentVector.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 5, 2007 */
package clojure.lang;
import java.io.Serializable;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
public class PersistentVector
extends APersistentVector implements IObj, IEditableCol lection{
9.86. PERSISTENTVECTOR.JAVA 1015
static class Node implements Serializable {
transient final AtomicReference<Thread> edit;
final Object[] array;
Node(AtomicReference<Thread> edit, Object[] array){
this.edit = edit;
this.array = array;
}
Node(AtomicReference<Thread> edit){
this.edit = edit;
this.array = new Object[32];
}
}
final static AtomicReference<Thread> NOEDIT =
new AtomicReference<Thread>(null);
final static Node EMPTY_NODE = new Node(NOEDIT, new Object[ 32]);
final int cnt;
final int shift;
final Node root;
final Object[] tail;
final IPersistentMap _meta;
public final static PersistentVector EMPTY =
new PersistentVector(0, 5, EMPTY_NODE, new Object[]{});
static public PersistentVector create(ISeq items){
TransientVector ret = EMPTY.asTransient();
for(; items != null; items = items.next())
ret = ret.conj(items.first());
return ret.persistent();
}
static public PersistentVector create(List items){
TransientVector ret = EMPTY.asTransient();
for(Object item : items)
ret = ret.conj(item);
return ret.persistent();
}
static public PersistentVector create(Object... items){
TransientVector ret = EMPTY.asTransient();
for(Object item : items)
ret = ret.conj(item);
return ret.persistent();
}
1016 CHAPTER 9. JVM/CLOJURE/LANG/
PersistentVector(int cnt, int shift, Node root, Object[] t ail){
this._meta = null;
this.cnt = cnt;
this.shift = shift;
this.root = root;
this.tail = tail;
}
PersistentVector(IPersistentMap meta, int cnt, int shift ,
Node root, Object[] tail){
this._meta = meta;
this.cnt = cnt;
this.shift = shift;
this.root = root;
this.tail = tail;
}
public TransientVector asTransient(){
return new TransientVector(this);
}
final int tailoff(){
if(cnt < 32)
return 0;
return ((cnt - 1) >>> 5) << 5;
}
public Object[] arrayFor(int i){
if(i >= 0 && i < cnt)
{
if(i >= tailoff())
return tail;
Node node = root;
for(int level = shift; level > 0; level -= 5)
node = (Node) node.array[(i >>> level) & 0x01f];
return node.array;
}
throw new IndexOutOfBoundsException();
}
public Object nth(int i){
Object[] node = arrayFor(i);
return node[i & 0x01f];
}
public Object nth(int i, Object notFound){
if(i >= 0 && i < cnt)
return nth(i);
9.86. PERSISTENTVECTOR.JAVA 1017
return notFound;
}
public PersistentVector assocN(int i, Object val){
if(i >= 0 && i < cnt)
{
if(i >= tailoff())
{
Object[] newTail = new Object[tail.length];
System.arraycopy(tail, 0, newTail, 0, tail.length);
newTail[i & 0x01f] = val;
return
new PersistentVector(meta(), cnt, shift, root, newTail);
}
return
new PersistentVector(meta(), cnt, shift,
doAssoc(shift, root, i, val), tail);
}
if(i == cnt)
return cons(val);
throw new IndexOutOfBoundsException();
}
private static Node doAssoc(int level, Node node, int i, Obj ect val){
Node ret = new Node(node.edit,node.array.clone());
if(level == 0)
{
ret.array[i & 0x01f] = val;
}
else
{
int subidx = (i >>> level) & 0x01f;
ret.array[subidx] =
doAssoc(level - 5, (Node) node.array[subidx], i, val);
}
return ret;
}
public int count(){
return cnt;
}
public PersistentVector withMeta(IPersistentMap meta){
return new PersistentVector(meta, cnt, shift, root, tail) ;
}
public IPersistentMap meta(){
return _meta;
}
1018 CHAPTER 9. JVM/CLOJURE/LANG/
public PersistentVector cons(Object val){
int i = cnt;
//room in tail?
// if(tail.length < 32)
if(cnt - tailoff() < 32)
{
Object[] newTail = new Object[tail.length + 1];
System.arraycopy(tail, 0, newTail, 0, tail.length);
newTail[tail.length] = val;
return
new PersistentVector(meta(), cnt + 1, shift, root, newTail );
}
//full tail, push into tree
Node newroot;
Node tailnode = new Node(root.edit,tail);
int newshift = shift;
//overflow root?
if((cnt >>> 5) > (1 << shift))
{
newroot = new Node(root.edit);
newroot.array[0] = root;
newroot.array[1] = newPath(root.edit,shift, tailnode);
newshift += 5;
}
else
newroot = pushTail(shift, root, tailnode);
return
new PersistentVector(meta(), cnt + 1, newshift,
newroot, new Object[]{val});
}
private Node pushTail(int level, Node parent, Node tailnod e){
//if parent is leaf, insert node,
// else does it map to an existing
// child? -> nodeToInsert = pushNode one more level
// else alloc new path
//return nodeToInsert placed in copy of parent
int subidx = ((cnt - 1) >>> level) & 0x01f;
Node ret = new Node(parent.edit, parent.array.clone());
Node nodeToInsert;
if(level == 5)
{
nodeToInsert = tailnode;
}
else
{
Node child = (Node) parent.array[subidx];
nodeToInsert = (child != null)?
9.86. PERSISTENTVECTOR.JAVA 1019
pushTail(level-5,child, tailnode)
:newPath(root.edit,level-5, tailnode);
}
ret.array[subidx] = nodeToInsert;
return ret;
}
private static Node newPath(AtomicReference<Thread> edi t,
int level, Node node){
if(level == 0)
return node;
Node ret = new Node(edit);
ret.array[0] = newPath(edit, level - 5, node);
return ret;
}
public IChunkedSeq chunkedSeq(){
if(count() == 0)
return null;
return new ChunkedSeq(this,0,0);
}
public ISeq seq(){
return chunkedSeq();
}
static public final class ChunkedSeq
extends ASeq implements IChunkedSeq{
public final PersistentVector vec;
final Object[] node;
final int i;
public final int offset;
public ChunkedSeq(PersistentVector vec, int i, int offset ){
this.vec = vec;
this.i = i;
this.offset = offset;
this.node = vec.arrayFor(i);
}
ChunkedSeq(IPersistentMap meta, PersistentVector vec,
Object[] node, int i, int offset){
super(meta);
this.vec = vec;
this.node = node;
this.i = i;
this.offset = offset;
}
1020 CHAPTER 9. JVM/CLOJURE/LANG/
ChunkedSeq(PersistentVector vec, Object[] node, int i, in t offset){
this.vec = vec;
this.node = node;
this.i = i;
this.offset = offset;
}
public IChunk chunkedFirst() throws Exception{
return new ArrayChunk(node, offset);
}
public ISeq chunkedNext(){
if(i + node.length < vec.cnt)
return new ChunkedSeq(vec,i+ node.length,0);
return null;
}
public ISeq chunkedMore(){
ISeq s = chunkedNext();
if(s == null)
return PersistentList.EMPTY;
return s;
}
public Obj withMeta(IPersistentMap meta){
if(meta == this._meta)
return this;
return new ChunkedSeq(meta, vec, node, i, offset);
}
public Object first(){
return node[offset];
}
public ISeq next(){
if(offset + 1 < node.length)
return new ChunkedSeq(vec, node, i, offset + 1);
return chunkedNext();
}
}
public IPersistentCollection empty(){
return EMPTY.withMeta(meta());
}
//private Node pushTail(int level, Node node,
// Object[] tailNode, Box expansion){
// Object newchild;
// if(level == 0)
// {
9.86. PERSISTENTVECTOR.JAVA 1021
// newchild = tailNode;
// }
// else
// {
// newchild =
// pushTail(level - 5,
// (Object[]) arr[arr.length - 1], tailNode, expansion);
// if(expansion.val == null)
// {
// Object[] ret = arr.clone();
// ret[arr.length - 1] = newchild;
// return ret;
// }
// else
// newchild = expansion.val;
// }
// //expansion
// if(arr.length == 32)
// {
// expansion.val = new Object[]{newchild};
// return arr;
// }
// Object[] ret = new Object[arr.length + 1];
// System.arraycopy(arr, 0, ret, 0, arr.length);
// ret[arr.length] = newchild;
// expansion.val = null;
// return ret;
//}
public PersistentVector pop(){
if(cnt == 0)
throw new IllegalStateException("Can’t pop empty vector" );
if(cnt == 1)
return EMPTY.withMeta(meta());
//if(tail.length > 1)
if(cnt-tailoff() > 1)
{
Object[] newTail = new Object[tail.length - 1];
System.arraycopy(tail, 0, newTail, 0, newTail.length);
return
new PersistentVector(meta(), cnt - 1, shift, root, newTail );
}
Object[] newtail = arrayFor(cnt - 2);
Node newroot = popTail(shift, root);
int newshift = shift;
if(newroot == null)
{
newroot = EMPTY_NODE;
}
1022 CHAPTER 9. JVM/CLOJURE/LANG/
if(shift > 5 && newroot.array[1] == null)
{
newroot = (Node) newroot.array[0];
newshift -= 5;
}
return
new PersistentVector(meta(), cnt - 1, newshift, newroot, n ewtail);
}
private Node popTail(int level, Node node){
int subidx = ((cnt-2) >>> level) & 0x01f;
if(level > 5)
{
Node newchild = popTail(level - 5, (Node) node.array[subid x]);
if(newchild == null && subidx == 0)
return null;
else
{
Node ret = new Node(root.edit, node.array.clone());
ret.array[subidx] = newchild;
return ret;
}
}
else if(subidx == 0)
return null;
else
{
Node ret = new Node(root.edit, node.array.clone());
ret.array[subidx] = null;
return ret;
}
}
static final class TransientVector
extends AFn implements ITransientVector, Counted{
int cnt;
int shift;
Node root;
Object[] tail;
TransientVector(int cnt, int shift, Node root, Object[] ta il){
this.cnt = cnt;
this.shift = shift;
this.root = root;
this.tail = tail;
}
TransientVector(PersistentVector v){
this(v.cnt, v.shift, editableRoot(v.root), editableTai l(v.tail));
}
9.86. PERSISTENTVECTOR.JAVA 1023
public int count(){
ensureEditable();
return cnt;
}
Node ensureEditable(Node node){
if(node.edit == root.edit)
return node;
return new Node(root.edit, node.array.clone());
}
void ensureEditable(){
Thread owner = root.edit.get();
if(owner == Thread.currentThread())
return;
if(owner != null)
throw new IllegalAccessError(
"Transient used by non-owner thread");
throw new IllegalAccessError(
"Transient used after persistent! call");
// root = editableRoot(root);
// tail = editableTail(tail);
}
static Node editableRoot(Node node){
return
new Node(new AtomicReference<Thread>(Thread.currentTh read()),
node.array.clone());
}
public PersistentVector persistent(){
ensureEditable();
// Thread owner = root.edit.get();
// if(owner != null && owner != Thread.currentThread())
// {
// throw new IllegalAccessError(
// "Mutation release by non-owner thread");
// }
root.edit.set(null);
Object[] trimmedTail = new Object[cnt-tailoff()];
System.arraycopy(tail,0,trimmedTail,0,trimmedTail.l ength);
return new PersistentVector(cnt, shift, root, trimmedTai l);
}
static Object[] editableTail(Object[] tl){
Object[] ret = new Object[32];
System.arraycopy(tl,0,ret,0,tl.length);
return ret;
1024 CHAPTER 9. JVM/CLOJURE/LANG/
}
public TransientVector conj(Object val){
ensureEditable();
int i = cnt;
//room in tail?
if(i - tailoff() < 32)
{
tail[i & 0x01f] = val;
++cnt;
return this;
}
//full tail, push into tree
Node newroot;
Node tailnode = new Node(root.edit, tail);
tail = new Object[32];
tail[0] = val;
int newshift = shift;
//overflow root?
if((cnt >>> 5) > (1 << shift))
{
newroot = new Node(root.edit);
newroot.array[0] = root;
newroot.array[1] = newPath(root.edit,shift, tailnode);
newshift += 5;
}
else
newroot = pushTail(shift, root, tailnode);
root = newroot;
shift = newshift;
++cnt;
return this;
}
private Node pushTail(int level, Node parent, Node tailnod e){
//if parent is leaf, insert node,
// else does it map to an existing
// child? -> nodeToInsert = pushNode one more level
// else alloc new path
//return nodeToInsert placed in parent
parent = ensureEditable(parent);
int subidx = ((cnt - 1) >>> level) & 0x01f;
Node ret = parent;
Node nodeToInsert;
if(level == 5)
{
nodeToInsert = tailnode;
}
else
{
9.86. PERSISTENTVECTOR.JAVA 1025
Node child = (Node) parent.array[subidx];
nodeToInsert =
(child != null)
? pushTail(level - 5, child, tailnode)
: newPath(root.edit, level - 5, tailnode);
}
ret.array[subidx] = nodeToInsert;
return ret;
}
final private int tailoff(){
if(cnt < 32)
return 0;
return ((cnt-1) >>> 5) << 5;
}
private Object[] arrayFor(int i){
if(i >= 0 && i < cnt)
{
if(i >= tailoff())
return tail;
Node node = root;
for(int level = shift; level > 0; level -= 5)
node = (Node) node.array[(i >>> level) & 0x01f];
return node.array;
}
throw new IndexOutOfBoundsException();
}
public Object valAt(Object key){
//note - relies on ensureEditable in 2-arg valAt
return valAt(key, null);
}
public Object valAt(Object key, Object notFound){
ensureEditable();
if(Util.isInteger(key))
{
int i = ((Number) key).intValue();
if(i >= 0 && i < cnt)
return nth(i);
}
return notFound;
}
public Object invoke(Object arg1) throws Exception{
//note - relies on ensureEditable in nth
if(Util.isInteger(arg1))
return nth(((Number) arg1).intValue());
throw new IllegalArgumentException("Key must be integer" );
1026 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Object nth(int i){
ensureEditable();
Object[] node = arrayFor(i);
return node[i & 0x01f];
}
public Object nth(int i, Object notFound){
if(i >= 0 && i < count())
return nth(i);
return notFound;
}
public TransientVector assocN(int i, Object val){
ensureEditable();
if(i >= 0 && i < cnt)
{
if(i >= tailoff())
{
tail[i & 0x01f] = val;
return this;
}
root = doAssoc(shift, root, i, val);
return this;
}
if(i == cnt)
return conj(val);
throw new IndexOutOfBoundsException();
}
public TransientVector assoc(Object key, Object val){
//note - relies on ensureEditable in assocN
if(Util.isInteger(key))
{
int i = ((Number) key).intValue();
return assocN(i, val);
}
throw new IllegalArgumentException("Key must be integer" );
}
private Node doAssoc(int level, Node node, int i, Object val ){
node = ensureEditable(node);
Node ret = node;
if(level == 0)
{
ret.array[i & 0x01f] = val;
}
else
9.86. PERSISTENTVECTOR.JAVA 1027
{
int subidx = (i >>> level) & 0x01f;
ret.array[subidx] =
doAssoc(level - 5, (Node) node.array[subidx], i, val);
}
return ret;
}
public TransientVector pop(){
ensureEditable();
if(cnt == 0)
throw new IllegalStateException("Can’t pop empty vector" );
if(cnt == 1)
{
cnt = 0;
return this;
}
int i = cnt - 1;
//pop in tail?
if((i & 0x01f) > 0)
{
--cnt;
return this;
}
Object[] newtail = arrayFor(cnt - 2);
Node newroot = popTail(shift, root);
int newshift = shift;
if(newroot == null)
{
newroot = new Node(root.edit);
}
if(shift > 5 && newroot.array[1] == null)
{
newroot = ensureEditable((Node) newroot.array[0]);
newshift -= 5;
}
root = newroot;
shift = newshift;
--cnt;
tail = newtail;
return this;
}
private Node popTail(int level, Node node){
node = ensureEditable(node);
int subidx = ((cnt - 2) >>> level) & 0x01f;
if(level > 5)
{
1028 CHAPTER 9. JVM/CLOJURE/LANG/
Node newchild =
popTail(level - 5, (Node) node.array[subidx]);
if(newchild == null && subidx == 0)
return null;
else
{
Node ret = node;
ret.array[subidx] = newchild;
return ret;
}
}
else if(subidx == 0)
return null;
else
{
Node ret = node;
ret.array[subidx] = null;
return ret;
}
}
}
/*
static public void main(String[] args){
if(args.length != 3)
{
System.err.println("Usage: PersistentVector size write s reads");
return;
}
int size = Integer.parseInt(args[0]);
int writes = Integer.parseInt(args[1]);
int reads = Integer.parseInt(args[2]);
// Vector v = new Vector(size);
ArrayList v = new ArrayList(size);
// v.setSize(size);
//PersistentArray p = new PersistentArray(size);
PersistentVector p = PersistentVector.EMPTY;
// MutableVector mp = p.mutable();
for(int i = 0; i < size; i++)
{
v.add(i);
// v.set(i, i);
//p = p.set(i, 0);
p = p.cons(i);
// mp = mp.conj(i);
}
Random rand;
rand = new Random(42);
9.86. PERSISTENTVECTOR.JAVA 1029
long tv = 0;
System.out.println("ArrayList");
long startTime = System.nanoTime();
for(int i = 0; i < writes; i++)
{
v.set(rand.nextInt(size), i);
}
for(int i = 0; i < reads; i++)
{
tv += (Integer) v.get(rand.nextInt(size));
}
long estimatedTime = System.nanoTime() - startTime;
System.out.println("time: " + estimatedTime / 1000000);
System.out.println("PersistentVector");
rand = new Random(42);
startTime = System.nanoTime();
long tp = 0;
// PersistentVector oldp = p;
//Random rand2 = new Random(42);
MutableVector mp = p.mutable();
for(int i = 0; i < writes; i++)
{
// p = p.assocN(rand.nextInt(size), i);
mp = mp.assocN(rand.nextInt(size), i);
// mp = mp.assoc(rand.nextInt(size), i);
//dummy set to force perverse branching
//oldp = oldp.assocN(rand2.nextInt(size), i);
}
for(int i = 0; i < reads; i++)
{
// tp += (Integer) p.nth(rand.nextInt(size));
tp += (Integer) mp.nth(rand.nextInt(size));
}
// p = mp.immutable();
//mp.cons(42);
estimatedTime = System.nanoTime() - startTime;
System.out.println("time: " + estimatedTime / 1000000);
for(int i = 0; i < size / 2; i++)
{
mp = mp.pop();
// p = p.pop();
v.remove(v.size() - 1);
}
p = (PersistentVector) mp.immutable();
//mp.pop(); //should fail
for(int i = 0; i < size / 2; i++)
{
tp += (Integer) p.nth(i);
1030 CHAPTER 9. JVM/CLOJURE/LANG/
tv += (Integer) v.get(i);
}
System.out.println("Done: " + tv + ", " + tp);
}
// */
}
———-
9.87 ProxyHandler.java
(InvocationHandler [1723])
— ProxyHandler.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Oct 4, 2007 */
package clojure.lang;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class ProxyHandler implements InvocationHandler{
//method-name-string->fn
final IPersistentMap fns;
public ProxyHandler(IPersistentMap fns){
this.fns = fns;
}
public Object invoke(Object proxy, Method method, Object[ ] args)
throws Throwable{
Class rt = method.getReturnType();
IFn fn = (IFn) fns.valAt(method.getName());
if(fn == null)
{
if(rt == Void.TYPE)
return null;
else if(method.getName().equals("equals"))
{
return proxy == args[0];
}
else if(method.getName().equals("hashCode"))
{
9.88. RANGE.JAVA 1031
return System.identityHashCode(proxy);
}
else if(method.getName().equals("toString"))
{
return "Proxy: " + System.identityHashCode(proxy);
}
throw new UnsupportedOperationException();
}
Object ret = fn.applyTo(ArraySeq.create(args));
if(rt == Void.TYPE)
return null;
else if(rt.isPrimitive())
{
if(rt == Character.TYPE)
return ret;
else if(rt == Integer.TYPE)
return ((Number) ret).intValue();
else if(rt == Long.TYPE)
return ((Number) ret).longValue();
else if(rt == Float.TYPE)
return ((Number) ret).floatValue();
else if(rt == Double.TYPE)
return ((Number) ret).doubleValue();
else if(rt == Boolean.TYPE && !(ret instanceof Boolean))
return ret == null ? Boolean.FALSE : Boolean.TRUE;
else if(rt == Byte.TYPE)
return (byte) ((Number) ret).intValue();
else if(rt == Short.TYPE)
return (short) ((Number) ret).intValue();
}
return ret;
}
}
———-
9.88 Range.java
(ASeq [571]) (IReduce [804]) (Counted [768])
— Range.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Apr 1, 2008 */
package clojure.lang;
1032 CHAPTER 9. JVM/CLOJURE/LANG/
public class Range extends ASeq implements IReduce, Counte d{
final int end;
final int n;
public Range(int start, int end){
this.end = end;
this.n = start;
}
public Range(IPersistentMap meta, int start, int end){
super(meta);
this.end = end;
this.n = start;
}
public Obj withMeta(IPersistentMap meta){
if(meta == meta())
return this;
return new Range(meta(), end, n);
}
public Object first(){
return n;
}
public ISeq next(){
if(n < end-1)
return new Range(_meta, n + 1, end);
return null;
}
public Object reduce(IFn f) throws Exception{
Object ret = n;
for(int x = n+1;x < end;x++)
ret = f.invoke(ret, x);
return ret;
}
public Object reduce(IFn f, Object start) throws Exception {
Object ret = f.invoke(start,n);
for(int x = n+1;x < end;x++)
ret = f.invoke(ret, x);
return ret;
}
public int count() {
return end - n;
}
}
9.89. RATIO.JAVA 1033
———-
9.89 Ratio.java
(Number [1723]) (Comparable [1723])
— Ratio.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 31, 2008 */
package clojure.lang;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.math.MathContext;
public class Ratio extends Number implements Comparable{
final public BigInteger numerator;
final public BigInteger denominator;
public Ratio(BigInteger numerator, BigInteger denominat or){
this.numerator = numerator;
this.denominator = denominator;
}
public boolean equals(Object arg0){
return arg0 != null
&& arg0 instanceof Ratio
&& ((Ratio) arg0).numerator.equals(numerator)
&& ((Ratio) arg0).denominator.equals(denominator);
}
public int hashCode(){
return numerator.hashCode() ^ denominator.hashCode();
}
public String toString(){
return numerator.toString() + "/" + denominator.toString ();
}
public int intValue(){
return (int) doubleValue();
}
public long longValue(){
return bigIntegerValue().longValue();
1034 CHAPTER 9. JVM/CLOJURE/LANG/
}
public float floatValue(){
return (float)doubleValue();
}
public double doubleValue(){
return decimalValue(MathContext.DECIMAL64).doubleVal ue();
}
public BigDecimal decimalValue(){
return decimalValue(MathContext.UNLIMITED);
}
public BigDecimal decimalValue(MathContext mc){
BigDecimal numerator = new BigDecimal(this.numerator);
BigDecimal denominator = new BigDecimal(this.denominato r);
return numerator.divide(denominator, mc);
}
public BigInteger bigIntegerValue(){
return numerator.divide(denominator);
}
public int compareTo(Object o){
Number other = (Number)o;
return Numbers.compare(this, other);
}
}
———-
9.90 Ref.java
(ARef [553]) (IFn [774]) (Comparable [1723]) (IRef [805])
— Ref.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 25, 2007 */
package clojure.lang;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWrite Lock;
9.90. REF.JAVA 1035
public class Ref extends ARef implements IFn, Comparable<R ef>, IRef{
public int compareTo(Ref ref) {
if(this.id == ref.id)
return 0;
else if(this.id < ref.id)
return -1;
else
return 1;
}
public int getMinHistory(){
return minHistory;
}
public Ref setMinHistory(int minHistory){
this.minHistory = minHistory;
return this;
}
public int getMaxHistory(){
return maxHistory;
}
public Ref setMaxHistory(int maxHistory){
this.maxHistory = maxHistory;
return this;
}
public static class TVal{
Object val;
long point;
long msecs;
TVal prior;
TVal next;
TVal(Object val, long point, long msecs, TVal prior){
this.val = val;
this.point = point;
this.msecs = msecs;
this.prior = prior;
this.next = prior.next;
this.prior.next = this;
this.next.prior = this;
}
TVal(Object val, long point, long msecs){
this.val = val;
this.point = point;
this.msecs = msecs;
1036 CHAPTER 9. JVM/CLOJURE/LANG/
this.next = this;
this.prior = this;
}
}
TVal tvals;
final AtomicInteger faults;
final ReentrantReadWriteLock lock;
LockingTransaction.Info tinfo;
//IFn validator;
final long id;
volatile int minHistory = 0;
volatile int maxHistory = 10;
static final AtomicLong ids = new AtomicLong();
public Ref(Object initVal) throws Exception{
this(initVal, null);
}
public Ref(Object initVal,IPersistentMap meta) throws Ex ception{
super(meta);
this.id = ids.getAndIncrement();
this.faults = new AtomicInteger();
this.lock = new ReentrantReadWriteLock();
tvals = new TVal(initVal, 0, System.currentTimeMillis()) ;
}
//the latest val
// ok out of transaction
Object currentVal(){
try
{
lock.readLock().lock();
if(tvals != null)
return tvals.val;
throw new IllegalStateException(
this.toString() + " is unbound.");
}
finally
{
lock.readLock().unlock();
}
}
//*
9.90. REF.JAVA 1037
public Object deref(){
LockingTransaction t = LockingTransaction.getRunning() ;
if(t == null)
return currentVal();
return t.doGet(this);
}
//void validate(IFn vf, Object val){
// try{
// if(vf != null && !RT.booleanCast(vf.invoke(val)))
// throw new IllegalStateException("Invalid ref state");
// }
// catch(RuntimeException re)
// {
// throw re;
// }
// catch(Exception e)
// {
// throw new IllegalStateException("Invalid ref state", e );
// }
//}
//
//public void setValidator(IFn vf){
// try
// {
// lock.writeLock().lock();
// validate(vf,currentVal());
// validator = vf;
// }
// finally
// {
// lock.writeLock().unlock();
// }
//}
//
//public IFn getValidator(){
// try
// {
// lock.readLock().lock();
// return validator;
// }
// finally
// {
// lock.readLock().unlock();
// }
//}
public Object set(Object val){
return LockingTransaction.getEx().doSet(this, val);
}
1038 CHAPTER 9. JVM/CLOJURE/LANG/
public Object commute(IFn fn, ISeq args) throws Exception{
return LockingTransaction.getEx().doCommute(this, fn, args);
}
public Object alter(IFn fn, ISeq args) throws Exception{
LockingTransaction t = LockingTransaction.getEx();
return t.doSet(this, fn.applyTo(RT.cons(t.doGet(this) , args)));
}
public void touch(){
LockingTransaction.getEx().doEnsure(this);
}
//*/
boolean isBound(){
try
{
lock.readLock().lock();
return tvals != null;
}
finally
{
lock.readLock().unlock();
}
}
public void trimHistory(){
try
{
lock.writeLock().lock();
if(tvals != null)
{
tvals.next = tvals;
tvals.prior = tvals;
}
}
finally
{
lock.writeLock().unlock();
}
}
public int getHistoryCount(){
try
{
lock.writeLock().lock();
return histCount();
}
9.90. REF.JAVA 1039
finally
{
lock.writeLock().unlock();
}
}
int histCount(){
if(tvals == null)
return 0;
else
{
int count = 0;
for(TVal tv = tvals.next;tv != tvals;tv = tv.next)
count++;
return count;
}
}
final public IFn fn(){
return (IFn) deref();
}
public Object call() throws Exception{
return invoke();
}
public void run(){
try
{
invoke();
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
public Object invoke()
throws Exception{
return fn().invoke();
}
public Object invoke(Object arg1)
throws Exception{
return fn().invoke(arg1);
}
public Object invoke(Object arg1, Object arg2)
throws Exception{
return fn().invoke(arg1, arg2);
1040 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
return fn().invoke(arg1, arg2, arg3);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
9.90. REF.JAVA 1041
Object arg10)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
1042 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
9.90. REF.JAVA 1043
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20, args);
}
public Object applyTo(ISeq arglist) throws Exception{
return AFn.applyToHelper(this, arglist);
}
}
———-
1044 CHAPTER 9. JVM/CLOJURE/LANG/
9.91 Reﬂector.java
— Reﬂector.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Apr 19, 2006 */
package clojure.lang;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;
public class Reflector{
public static Object invokeInstanceMethod(Object target ,
String methodName,
Object[] args)
throws Exception{
try
{
Class c = target.getClass();
List methods = getMethods(c, args.length, methodName, fal se);
return invokeMatchingMethod(methodName, methods, targe t, args);
}
catch(InvocationTargetException e)
{
if(e.getCause() instanceof Exception)
throw (Exception) e.getCause();
else if(e.getCause() instanceof Error)
throw (Error) e.getCause();
throw e;
}
}
private static String noMethodReport(String methodName, Object target){
return "No matching method found: " + methodName
+ (target==null?"":" for " + target.getClass());
}
static Object invokeMatchingMethod(String methodName,
List methods,
Object target,
Object[] args)
throws Exception{
9.91. REFLECTOR.JAVA 1045
Method m = null;
Object[] boxedArgs = null;
if(methods.isEmpty())
{
throw new IllegalArgumentException(
noMethodReport(methodName,target));
}
else if(methods.size() == 1)
{
m = (Method) methods.get(0);
boxedArgs = boxArgs(m.getParameterTypes(), args);
}
else //overloaded w/same arity
{
Method foundm = null;
for(Iterator i = methods.iterator(); i.hasNext();)
{
m = (Method) i.next();
Class[] params = m.getParameterTypes();
if(isCongruent(params, args))
{
if(foundm == null ||
Compiler.subsumes(params,
foundm.getParameterTypes()))
{
foundm = m;
boxedArgs = boxArgs(params, args);
}
}
}
m = foundm;
}
if(m == null)
throw new IllegalArgumentException(
noMethodReport(methodName,target));
if(!Modifier.isPublic(m.getDeclaringClass().getModi fiers()))
{
//public method of non-public class, try to find it in
//hierarchy
Method oldm = m;
m = getAsMethodOfPublicBase(m.getDeclaringClass(), m);
if(m == null)
throw new IllegalArgumentException(
"Can’t call public method of non-public class: " +
oldm.toString());
}
try
{
1046 CHAPTER 9. JVM/CLOJURE/LANG/
return prepRet(m.getReturnType(), m.invoke(target, box edArgs));
}
catch(InvocationTargetException e)
{
if(e.getCause() instanceof Exception)
throw (Exception) e.getCause();
else if(e.getCause() instanceof Error)
throw (Error) e.getCause();
throw e;
}
}
public static Method getAsMethodOfPublicBase(Class c, Me thod m){
for(Class iface : c.getInterfaces())
{
for(Method im : iface.getMethods())
{
if(im.getName().equals(m.getName())
&& Arrays.equals(m.getParameterTypes(),
im.getParameterTypes()))
{
return im;
}
}
}
Class sc = c.getSuperclass();
if(sc == null)
return null;
for(Method scm : sc.getMethods())
{
if(scm.getName().equals(m.getName())
&& Arrays.equals(m.getParameterTypes(),
scm.getParameterTypes())
&& Modifier.isPublic(scm.getDeclaringClass()
.getModifiers()))
{
return scm;
}
}
return getAsMethodOfPublicBase(sc, m);
}
public static Object invokeConstructor(Class c, Object[] args)
throws Exception{
try
{
Constructor[] allctors = c.getConstructors();
ArrayList ctors = new ArrayList();
for(int i = 0; i < allctors.length; i++)
9.91. REFLECTOR.JAVA 1047
{
Constructor ctor = allctors[i];
if(ctor.getParameterTypes().length == args.length)
ctors.add(ctor);
}
if(ctors.isEmpty())
{
throw new IllegalArgumentException("No matching ctor fou nd"
+ " for " + c);
}
else if(ctors.size() == 1)
{
Constructor ctor = (Constructor) ctors.get(0);
return
ctor.newInstance(
boxArgs(ctor.getParameterTypes(), args));
}
else //overloaded w/same arity
{
for(Iterator iterator = ctors.iterator();
iterator.hasNext();)
{
Constructor ctor = (Constructor) iterator.next();
Class[] params = ctor.getParameterTypes();
if(isCongruent(params, args))
{
Object[] boxedArgs = boxArgs(params, args);
return ctor.newInstance(boxedArgs);
}
}
throw new IllegalArgumentException("No matching ctor fou nd"
+ " for " + c);
}
}
catch(InvocationTargetException e)
{
if(e.getCause() instanceof Exception)
throw (Exception) e.getCause();
else if(e.getCause() instanceof Error)
throw (Error) e.getCause();
throw e;
}
}
public static Object invokeStaticMethodVariadic(String className,
String methodName,
Object... args)
throws Exception{
return invokeStaticMethod(className, methodName, args) ;
1048 CHAPTER 9. JVM/CLOJURE/LANG/
}
public static Object invokeStaticMethod(String classNam e,
String methodName,
Object[] args)
throws Exception{
Class c = RT.classForName(className);
try
{
return invokeStaticMethod(c, methodName, args);
}
catch(InvocationTargetException e)
{
if(e.getCause() instanceof Exception)
throw (Exception) e.getCause();
else if(e.getCause() instanceof Error)
throw (Error) e.getCause();
throw e;
}
}
public static Object invokeStaticMethod(Class c,
String methodName,
Object[] args)
throws Exception{
if(methodName.equals("new"))
return invokeConstructor(c, args);
List methods = getMethods(c, args.length, methodName, tru e);
return invokeMatchingMethod(methodName, methods, null, args);
}
public static Object getStaticField(String className,
String fieldName)
throws Exception{
Class c = RT.classForName(className);
return getStaticField(c, fieldName);
}
public static Object getStaticField(Class c,
String fieldName)
throws Exception{
// if(fieldName.equals("class"))
// return c;
Field f = getField(c, fieldName, true);
if(f != null)
{
return prepRet(f.getType(), f.get(null));
}
throw new IllegalArgumentException(
"No matching field found: " + fieldName
9.91. REFLECTOR.JAVA 1049
+ " for " + c);
}
public static Object setStaticField(String className,
String fieldName,
Object val)
throws Exception{
Class c = RT.classForName(className);
return setStaticField(c, fieldName, val);
}
public static Object setStaticField(Class c,
String fieldName,
Object val)
throws Exception{
Field f = getField(c, fieldName, true);
if(f != null)
{
f.set(null, boxArg(f.getType(), val));
return val;
}
throw new IllegalArgumentException(
"No matching field found: " + fieldName
+ " for " + c);
}
public static Object getInstanceField(Object target,
String fieldName)
throws Exception{
Class c = target.getClass();
Field f = getField(c, fieldName, false);
if(f != null)
{
return prepRet(f.getType(), f.get(target));
}
throw new IllegalArgumentException(
"No matching field found: " + fieldName
+ " for " + target.getClass());
}
public static Object setInstanceField(Object target,
String fieldName,
Object val)
throws Exception{
Class c = target.getClass();
Field f = getField(c, fieldName, false);
if(f != null)
{
f.set(target, boxArg(f.getType(), val));
return val;
1050 CHAPTER 9. JVM/CLOJURE/LANG/
}
throw new IllegalArgumentException(
"No matching field found: " + fieldName
+ " for " + target.getClass());
}
public static Object invokeNoArgInstanceMember(Object t arget,
String name)
throws Exception{
//favor method over field
List meths = getMethods(target.getClass(), 0, name, false );
if(meths.size() > 0)
return
invokeMatchingMethod(name, meths, target, RT.EMPTY_ARR AY);
else
return getInstanceField(target, name);
}
public static Object invokeInstanceMember(Object target ,
String name)
throws Exception{
//check for field first
Class c = target.getClass();
Field f = getField(c, name, false);
if(f != null) //field get
{
return prepRet(f.getType(), f.get(target));
}
return invokeInstanceMethod(target, name, RT.EMPTY_ARR AY);
}
public static Object invokeInstanceMember(String name,
Object target,
Object arg1)
throws Exception{
//check for field first
Class c = target.getClass();
Field f = getField(c, name, false);
if(f != null) //field set
{
f.set(target, boxArg(f.getType(), arg1));
return arg1;
}
return invokeInstanceMethod(target, name, new Object[]{ arg1});
}
public static Object invokeInstanceMember(String name,
Object target,
Object... args)
throws Exception{
9.91. REFLECTOR.JAVA 1051
return invokeInstanceMethod(target, name, args);
}
static public Field getField(Class c,
String name,
boolean getStatics){
Field[] allfields = c.getFields();
for(int i = 0; i < allfields.length; i++)
{
if(name.equals(allfields[i].getName())
&& Modifier.isStatic(allfields[i].getModifiers())
== getStatics)
return allfields[i];
}
return null;
}
static public List getMethods(Class c,
int arity,
String name,
boolean getStatics){
Method[] allmethods = c.getMethods();
ArrayList methods = new ArrayList();
ArrayList bridgeMethods = new ArrayList();
for(int i = 0; i < allmethods.length; i++)
{
Method method = allmethods[i];
if(name.equals(method.getName())
&& Modifier.isStatic(method.getModifiers()) == getStat ics
&& method.getParameterTypes().length == arity)
{
try
{
if(method.isBridge()
&& c.getMethod(method.getName(),
method.getParameterTypes())
.equals(method))
bridgeMethods.add(method);
else
methods.add(method);
}
catch(NoSuchMethodException e)
{
}
}
// && (!method.isBridge()
// || (c == StringBuilder.class &&
// c.getMethod(method.getName(),
// method.getParameterTypes())
1052 CHAPTER 9. JVM/CLOJURE/LANG/
// .equals(method))))
// {
// methods.add(allmethods[i]);
// }
}
if(methods.isEmpty())
methods.addAll(bridgeMethods);
if(!getStatics && c.isInterface())
{
allmethods = Object.class.getMethods();
for(int i = 0; i < allmethods.length; i++)
{
if(name.equals(allmethods[i].getName())
&& Modifier.isStatic(allmethods[i].getModifiers())
== getStatics
&& allmethods[i].getParameterTypes().length == arity)
{
methods.add(allmethods[i]);
}
}
}
return methods;
}
static Object boxArg(Class paramType, Object arg){
if(!paramType.isPrimitive())
return paramType.cast(arg);
else if(paramType == boolean.class)
return Boolean.class.cast(arg);
else if(paramType == char.class)
return Character.class.cast(arg);
else if(arg instanceof Number)
{
Number n = (Number) arg;
if(paramType == int.class)
return n.intValue();
else if(paramType == float.class)
return n.floatValue();
else if(paramType == double.class)
return n.doubleValue();
else if(paramType == long.class)
return n.longValue();
else if(paramType == short.class)
return n.shortValue();
else if(paramType == byte.class)
return n.byteValue();
}
9.91. REFLECTOR.JAVA 1053
throw new IllegalArgumentException(
"Unexpected param type, expected: " + paramType +
", given: " + arg.getClass().getName());
}
static Object[] boxArgs(Class[] params, Object[] args){
if(params.length == 0)
return null;
Object[] ret = new Object[params.length];
for(int i = 0; i < params.length; i++)
{
Object arg = args[i];
Class paramType = params[i];
ret[i] = boxArg(paramType, arg);
}
return ret;
}
static public boolean paramArgTypeMatch(Class paramType ,
Class argType){
if(argType == null)
return !paramType.isPrimitive();
if(paramType == argType || paramType.isAssignableFrom(a rgType))
return true;
if(paramType == int.class)
return argType == Integer.class
|| argType == long.class
|| argType == Long.class;// || argType==FixNum.class;
else if(paramType == float.class)
return argType == Float.class
|| argType == double.class;
else if(paramType == double.class)
return argType == Double.class
|| argType == float.class;
// || argType == DoubleNum.class;
else if(paramType == long.class)
return argType == Long.class
|| argType == int.class;
// || argType == BigNum.class;
else if(paramType == char.class)
return argType == Character.class;
else if(paramType == short.class)
return argType == Short.class;
else if(paramType == byte.class)
return argType == Byte.class;
else if(paramType == boolean.class)
return argType == Boolean.class;
return false;
}
1054 CHAPTER 9. JVM/CLOJURE/LANG/
static boolean isCongruent(Class[] params, Object[] args ){
boolean ret = false;
if(args == null)
return params.length == 0;
if(params.length == args.length)
{
ret = true;
for(int i = 0; ret && i < params.length; i++)
{
Object arg = args[i];
Class argType = (arg == null) ? null : arg.getClass();
Class paramType = params[i];
ret = paramArgTypeMatch(paramType, argType);
}
}
return ret;
}
public static Object prepRet(Class c, Object x){
if (!(c.isPrimitive() || c == Boolean.class))
return x;
if(x instanceof Boolean)
return ((Boolean) x)?Boolean.TRUE:Boolean.FALSE;
else if(x instanceof Integer)
{
return ((Integer)x).longValue();
}
else if(x instanceof Float)
return Double.valueOf(((Float) x).doubleValue());
return x;
}
}
———-
9.92 Repl.java
— Repl.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Oct 18, 2007 */
package clojure.lang;
import clojure.main;
9.93. RESTFN.JAVA 1055
public class Repl {
public static void main(String[] args) throws Exception{
main.legacy_repl(args);
}
}
———-
9.93 RestFn.java
(AFunction [519])
— RestFn.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public abstract class RestFn extends AFunction{
abstract public int getRequiredArity();
protected Object doInvoke(Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object args)
throws Exception{
1056 CHAPTER 9. JVM/CLOJURE/LANG/
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object args)
9.93. RESTFN.JAVA 1057
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object args)
throws Exception{
return null;
}
1058 CHAPTER 9. JVM/CLOJURE/LANG/
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object args)
throws Exception{
return null;
}
protected Object doInvoke(Object arg1, Object arg2, Objec t arg3,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object args)
throws Exception{
return null;
}
public Object applyTo(ISeq args) throws Exception{
if(RT.boundedLength(args, getRequiredArity()) <= getRe quiredArity())
{
return AFn.applyToHelper(this, Util.ret1(args,args = nu ll));
}
9.93. RESTFN.JAVA 1059
switch(getRequiredArity())
{
case 0:
return doInvoke(Util.ret1(args,args = null));
case 1:
return doInvoke(args.first()
, Util.ret1(args.next(),args=null));
case 2:
return doInvoke(args.first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 3:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 4:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 5:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 6:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 7:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 8:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
1060 CHAPTER 9. JVM/CLOJURE/LANG/
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 9:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 10:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 11:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 12:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
9.93. RESTFN.JAVA 1061
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 13:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 14:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 15:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
1062 CHAPTER 9. JVM/CLOJURE/LANG/
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 16:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 17:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 18:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
9.93. RESTFN.JAVA 1063
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 19:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
case 20:
return doInvoke(args.first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
1064 CHAPTER 9. JVM/CLOJURE/LANG/
, (args = args.next()).first()
, (args = args.next()).first()
, (args = args.next()).first()
, Util.ret1(args.next(),args=null));
}
return throwArity(-1);
}
public Object invoke() throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(null);
default:
return throwArity(0);
}
}
public Object invoke(Object arg1) throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null), null);
default:
return throwArity(1);
}
}
public Object invoke(Object arg1, Object arg2)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null),
ArraySeq.create(
Util.ret1(arg2, arg2 = null)));
case 2:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null), null);
default:
9.93. RESTFN.JAVA 1065
return throwArity(2);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null),
ArraySeq.create(
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null)));
case 2:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
ArraySeq.create(
Util.ret1(arg3, arg3 = null)));
case 3:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
null);
default:
return throwArity(3);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null),
ArraySeq.create(
Util.ret1(arg2, arg2 = null),
1066 CHAPTER 9. JVM/CLOJURE/LANG/
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null)));
case 2:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
ArraySeq.create(
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null)));
case 3:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
ArraySeq.create(
Util.ret1(arg4, arg4 = null)));
case 4:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null), null);
default:
return throwArity(4);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null),
ArraySeq.create(
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null)));
case 2:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
ArraySeq.create(
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
9.93. RESTFN.JAVA 1067
Util.ret1(arg5, arg5 = null)));
case 3:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
ArraySeq.create(
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null)));
case 4:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
ArraySeq.create(
Util.ret1(arg5, arg5 = null)));
case 5:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null), null);
default:
return throwArity(5);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(
Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null)));
case 1:
return doInvoke(Util.ret1(arg1, arg1 = null),
ArraySeq.create(
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null)));
case 2:
return doInvoke(Util.ret1(arg1, arg1 = null),
1068 CHAPTER 9. JVM/CLOJURE/LANG/
Util.ret1(arg2, arg2 = null),
ArraySeq.create(
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null)));
case 3:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
ArraySeq.create(
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null)));
case 4:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
ArraySeq.create(
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null)));
case 5:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
ArraySeq.create(
Util.ret1(arg6, arg6 = null)));
case 6:
return doInvoke(Util.ret1(arg1, arg1 = null),
Util.ret1(arg2, arg2 = null),
Util.ret1(arg3, arg3 = null),
Util.ret1(arg4, arg4 = null),
Util.ret1(arg5, arg5 = null),
Util.ret1(arg6, arg6 = null),
null);
default:
return throwArity(6);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
switch(getRequiredArity())
{
9.93. RESTFN.JAVA 1069
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
null);
default:
return throwArity(7);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8));
case 3:
1070 CHAPTER 9. JVM/CLOJURE/LANG/
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, null);
default:
return throwArity(8);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9));
case 5:
9.93. RESTFN.JAVA 1071
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, ArraySeq.create(arg9));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, null);
default:
return throwArity(9);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10));
1072 CHAPTER 9. JVM/CLOJURE/LANG/
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, ArraySeq.create(arg9, arg10));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, ArraySeq.create(arg10));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, null);
default:
return throwArity(10);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
9.93. RESTFN.JAVA 1073
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, ArraySeq.create(arg9, arg10, arg11));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, ArraySeq.create(arg10, arg11));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, ArraySeq.create(arg11));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, null);
default:
return throwArity(11);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
1074 CHAPTER 9. JVM/CLOJURE/LANG/
arg8, arg9, arg10, arg11, arg12));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, null);
default:
return throwArity(12);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
switch(getRequiredArity())
9.93. RESTFN.JAVA 1075
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
arg13));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12, arg13));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13));
1076 CHAPTER 9. JVM/CLOJURE/LANG/
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
null);
default:
return throwArity(13);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
arg13, arg14));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13,
arg14));
9.93. RESTFN.JAVA 1077
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12, arg13, arg14));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, null);
default:
return throwArity(14);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
1078 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13,
arg14, arg15));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12, arg13, arg14, arg15));
case 9:
9.93. RESTFN.JAVA 1079
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14, arg15));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, null);
default:
return throwArity(15);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
1080 CHAPTER 9. JVM/CLOJURE/LANG/
arg16));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15, arg16));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14, arg15, arg16));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15, arg16));
9.93. RESTFN.JAVA 1081
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15, arg16));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15,
arg16));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15, arg16));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15, arg16));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
ArraySeq.create(arg16));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, null);
default:
return throwArity(16);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17));
case 1:
return doInvoke(arg1,
1082 CHAPTER 9. JVM/CLOJURE/LANG/
ArraySeq.create(arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15, arg16, arg17));
9.93. RESTFN.JAVA 1083
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15, arg16, arg17));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15,
arg16, arg17));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15, arg16,
arg17));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15, arg16, arg17));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
ArraySeq.create(arg16, arg17));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16,
ArraySeq.create(arg17));
case 17:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, null);
default:
return throwArity(17);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
throws Exception{
switch(getRequiredArity())
{
case 0:
1084 CHAPTER 9. JVM/CLOJURE/LANG/
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17, arg18));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
9.93. RESTFN.JAVA 1085
arg13, arg14, arg15, arg16, arg17,
arg18));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15, arg16, arg17, arg18));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15,
arg16, arg17, arg18));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15, arg16,
arg17, arg18));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15, arg16, arg17,
arg18));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
ArraySeq.create(arg16, arg17, arg18));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16,
ArraySeq.create(arg17, arg18));
case 17:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17,
ArraySeq.create(arg18));
case 18:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, null);
default:
return throwArity(18);
}
1086 CHAPTER 9. JVM/CLOJURE/LANG/
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19));
case 2:
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
arg19));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
9.93. RESTFN.JAVA 1087
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16, arg17,
arg18, arg19));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
arg19));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15,
arg16, arg17, arg18, arg19));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15, arg16,
arg17, arg18, arg19));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15, arg16, arg17,
arg18, arg19));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
1088 CHAPTER 9. JVM/CLOJURE/LANG/
ArraySeq.create(arg16, arg17, arg18,
arg19));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16,
ArraySeq.create(arg17, arg18, arg19));
case 17:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17,
ArraySeq.create(arg18, arg19));
case 18:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
ArraySeq.create(arg19));
case 19:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, arg19,
null);
default:
return throwArity(19);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(ArraySeq.create(arg1, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20));
case 1:
return doInvoke(arg1,
ArraySeq.create(arg2, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20));
case 2:
9.93. RESTFN.JAVA 1089
return doInvoke(arg1, arg2,
ArraySeq.create(arg3, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 3:
return doInvoke(arg1, arg2, arg3,
ArraySeq.create(arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ArraySeq.create(arg5, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19,
arg20));
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ArraySeq.create(arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19,
arg20));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ArraySeq.create(arg7, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ArraySeq.create(arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ArraySeq.create(arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17, arg18,
arg19, arg20));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ArraySeq.create(arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ArraySeq.create(arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
1090 CHAPTER 9. JVM/CLOJURE/LANG/
arg19, arg20));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ArraySeq.create(arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19, arg20));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ArraySeq.create(arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ArraySeq.create(arg14, arg15, arg16,
arg17, arg18, arg19, arg20));
case 14:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ArraySeq.create(arg15, arg16, arg17,
arg18, arg19, arg20));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
ArraySeq.create(arg16, arg17, arg18,
arg19, arg20));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16,
ArraySeq.create(arg17, arg18, arg19,
arg20));
case 17:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17,
ArraySeq.create(arg18, arg19, arg20));
case 18:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
ArraySeq.create(arg19, arg20));
case 19:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, arg19,
ArraySeq.create(arg20));
case 20:
9.93. RESTFN.JAVA 1091
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, arg19,
arg20, null);
default:
return throwArity(20);
}
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
throws Exception{
switch(getRequiredArity())
{
case 0:
return doInvoke(
ontoArrayPrepend(args, arg1, arg2, arg3,
arg4, arg5, arg6, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19, arg20));
case 1:
return doInvoke(arg1,
ontoArrayPrepend(args, arg2, arg3, arg4,
arg5, arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 2:
return doInvoke(arg1, arg2,
ontoArrayPrepend(args, arg3, arg4, arg5,
arg6, arg7, arg8, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20));
case 3:
return doInvoke(arg1, arg2, arg3,
ontoArrayPrepend(args, arg4, arg5, arg6,
arg7, arg8, arg9, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 4:
return doInvoke(arg1, arg2, arg3, arg4,
ontoArrayPrepend(args, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
arg19, arg20));
1092 CHAPTER 9. JVM/CLOJURE/LANG/
case 5:
return doInvoke(arg1, arg2, arg3, arg4, arg5,
ontoArrayPrepend(args, arg6, arg7, arg8,
arg9, arg10, arg11, arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19,
arg20));
case 6:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6,
ontoArrayPrepend(args, arg7, arg8, arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20));
case 7:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
ontoArrayPrepend(args, arg8, arg9, arg10,
arg11, arg12, arg13, arg14, arg15, arg16,
arg17, arg18, arg19, arg20));
case 8:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8,
ontoArrayPrepend(args, arg9, arg10, arg11,
arg12, arg13, arg14, arg15, arg16, arg17,
arg18, arg19, arg20));
case 9:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9,
ontoArrayPrepend(args, arg10, arg11, arg12,
arg13, arg14, arg15, arg16, arg17, arg18,
arg19, arg20));
case 10:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10,
ontoArrayPrepend(args, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, arg19,
arg20));
case 11:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11,
ontoArrayPrepend(args, arg12, arg13, arg14,
arg15, arg16, arg17, arg18, arg19, arg20));
case 12:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12,
ontoArrayPrepend(args, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20));
case 13:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
ontoArrayPrepend(args, arg14, arg15, arg16,
arg17, arg18, arg19, arg20));
case 14:
9.93. RESTFN.JAVA 1093
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,
ontoArrayPrepend(args, arg15, arg16, arg17,
arg18, arg19, arg20));
case 15:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15,
ontoArrayPrepend(args, arg16, arg17, arg18,
arg19, arg20));
case 16:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16,
ontoArrayPrepend(args, arg17, arg18, arg19,
arg20));
case 17:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17,
ontoArrayPrepend(args, arg18, arg19,
arg20));
case 18:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18,
ontoArrayPrepend(args, arg19, arg20));
case 19:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14, arg15, arg16, arg17, arg18, arg19,
ontoArrayPrepend(args, arg20));
case 20:
return doInvoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
arg8, arg9, arg10, arg11, arg12, arg13,
arg14,arg15, arg16, arg17, arg18, arg19,
arg20, ArraySeq.create(args));
default:
return throwArity(21);
}
}
protected static ISeq ontoArrayPrepend(Object[] array,
Object... args){
ISeq ret = ArraySeq.create(array);
for(int i = args.length - 1; i >= 0; --i)
ret = RT.cons(args[i], ret);
1094 CHAPTER 9. JVM/CLOJURE/LANG/
return ret;
}
protected static ISeq findKey(Object key, ISeq args){
while(args != null)
{
if(key == args.first())
return args.next();
args = RT.next(args);
args = RT.next(args);
}
return null;
}
}
———-
9.94 Reversible.java
— Reversible.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 5, 2008 */
package clojure.lang;
public interface Reversible{
ISeq rseq() throws Exception;
}
———-
9.95 RT.java
— RT.java —
/*
\getchunk{Clojure Copyright}
*/
9.95. RT.JAVA 1095
/* rich Mar 25, 2006 4:28:27 PM */
package clojure.lang;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.Callable;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.net.URL;
import java.net.JarURLConnection;
import java.nio.charset.Charset;
public class RT{
static final public Boolean T =
Boolean.TRUE;//Keyword.intern(Symbol.intern(null, "t "));
static final public Boolean F =
Boolean.FALSE;//Keyword.intern(Symbol.intern(null, " t"));
static final public String LOADER_SUFFIX = "__init";
//simple-symbol->class
final static IPersistentMap DEFAULT_IMPORTS = map(
// Symbol.intern("RT"), "clojure.lang.RT",
// Symbol.intern("Num"), "clojure.lang.Num",
// Symbol.intern("Symbol"), "clojure.lang.Symbol",
// Symbol.intern("Keyword"), "clojure.lang.Keyword",
// Symbol.intern("Var"), "clojure.lang.Var",
// Symbol.intern("Ref"), "clojure.lang.Ref",
// Symbol.intern("IFn"), "clojure.lang.IFn",
// Symbol.intern("IObj"), "clojure.lang.IObj",
// Symbol.intern("ISeq"), "clojure.lang.ISeq",
// Symbol.intern("IPersistentCollection"),
// "clojure.lang.IPersistentCollection",
// Symbol.intern("IPersistentMap"), "clojure.lang.IPe rsistentMap",
// Symbol.intern("IPersistentList"), "clojure.lang.IP ersistentList",
// Symbol.intern("IPersistentVector"), "clojure.lang. IPersistentVector",
Symbol.intern("Boolean"), Boolean.class,
Symbol.intern("Byte"), Byte.class,
Symbol.intern("Character"), Character.class,
Symbol.intern("Class"), Class.class,
Symbol.intern("ClassLoader"), ClassLoader.class,
Symbol.intern("Compiler"), Compiler.class,
Symbol.intern("Double"), Double.class,
1096 CHAPTER 9. JVM/CLOJURE/LANG/
Symbol.intern("Enum"), Enum.class,
Symbol.intern("Float"), Float.class,
Symbol.intern("InheritableThreadLocal"), Inheritable ThreadLocal.class,
Symbol.intern("Integer"), Integer.class,
Symbol.intern("Long"), Long.class,
Symbol.intern("Math"), Math.class,
Symbol.intern("Number"), Number.class,
Symbol.intern("Object"), Object.class,
Symbol.intern("Package"), Package.class,
Symbol.intern("Process"), Process.class,
Symbol.intern("ProcessBuilder"), ProcessBuilder.clas s,
Symbol.intern("Runtime"), Runtime.class,
Symbol.intern("RuntimePermission"), RuntimePermissio n.class,
Symbol.intern("SecurityManager"), SecurityManager.cl ass,
Symbol.intern("Short"), Short.class,
Symbol.intern("StackTraceElement"), StackTraceElemen t.class,
Symbol.intern("StrictMath"), StrictMath.class,
Symbol.intern("String"), String.class,
Symbol.intern("StringBuffer"), StringBuffer.class,
Symbol.intern("StringBuilder"), StringBuilder.class,
Symbol.intern("System"), System.class,
Symbol.intern("Thread"), Thread.class,
Symbol.intern("ThreadGroup"), ThreadGroup.class,
Symbol.intern("ThreadLocal"), ThreadLocal.class,
Symbol.intern("Throwable"), Throwable.class,
Symbol.intern("Void"), Void.class,
Symbol.intern("Appendable"), Appendable.class,
Symbol.intern("CharSequence"), CharSequence.class,
Symbol.intern("Cloneable"), Cloneable.class,
Symbol.intern("Comparable"), Comparable.class,
Symbol.intern("Iterable"), Iterable.class,
Symbol.intern("Readable"), Readable.class,
Symbol.intern("Runnable"), Runnable.class,
Symbol.intern("Callable"), Callable.class,
Symbol.intern("BigInteger"), BigInteger.class,
Symbol.intern("BigDecimal"), BigDecimal.class,
Symbol.intern("ArithmeticException"), ArithmeticExce ption.class,
Symbol.intern("ArrayIndexOutOfBoundsException"),
ArrayIndexOutOfBoundsException.class,
Symbol.intern("ArrayStoreException"), ArrayStoreExce ption.class,
Symbol.intern("ClassCastException"), ClassCastExcept ion.class,
Symbol.intern("ClassNotFoundException"), ClassNotFou ndException.class,
Symbol.intern("CloneNotSupportedException"),
CloneNotSupportedException.class,
Symbol.intern("EnumConstantNotPresentException"),
EnumConstantNotPresentException.class,
Symbol.intern("Exception"), Exception.class,
Symbol.intern("IllegalAccessException"), IllegalAcce ssException.class,
Symbol.intern("IllegalArgumentException"),
IllegalArgumentException.class,
9.95. RT.JAVA 1097
Symbol.intern("IllegalMonitorStateException"),
IllegalMonitorStateException.class,
Symbol.intern("IllegalStateException"), IllegalState Exception.class,
Symbol.intern("IllegalThreadStateException"),
IllegalThreadStateException.class,
Symbol.intern("IndexOutOfBoundsException"),
IndexOutOfBoundsException.class,
Symbol.intern("InstantiationException"), Instantiati onException.class,
Symbol.intern("InterruptedException"), InterruptedEx ception.class,
Symbol.intern("NegativeArraySizeException"),
NegativeArraySizeException.class,
Symbol.intern("NoSuchFieldException"), NoSuchFieldEx ception.class,
Symbol.intern("NoSuchMethodException"), NoSuchMethod Exception.class,
Symbol.intern("NullPointerException"), NullPointerEx ception.class,
Symbol.intern("NumberFormatException"), NumberFormat Exception.class,
Symbol.intern("RuntimeException"), RuntimeException. class,
Symbol.intern("SecurityException"), SecurityExceptio n.class,
Symbol.intern("StringIndexOutOfBoundsException"),
StringIndexOutOfBoundsException.class,
Symbol.intern("TypeNotPresentException"),
TypeNotPresentException.class,
Symbol.intern("UnsupportedOperationException"),
UnsupportedOperationException.class,
Symbol.intern("AbstractMethodError"), AbstractMethod Error.class,
Symbol.intern("AssertionError"), AssertionError.clas s,
Symbol.intern("ClassCircularityError"), ClassCircula rityError.class,
Symbol.intern("ClassFormatError"), ClassFormatError. class,
Symbol.intern("Error"), Error.class,
Symbol.intern("ExceptionInInitializerError"),
ExceptionInInitializerError.class,
Symbol.intern("IllegalAccessError"), IllegalAccessEr ror.class,
Symbol.intern("IncompatibleClassChangeError"),
IncompatibleClassChangeError.class,
Symbol.intern("InstantiationError"), InstantiationEr ror.class,
Symbol.intern("InternalError"), InternalError.class,
Symbol.intern("LinkageError"), LinkageError.class,
Symbol.intern("NoClassDefFoundError"), NoClassDefFou ndError.class,
Symbol.intern("NoSuchFieldError"), NoSuchFieldError. class,
Symbol.intern("NoSuchMethodError"), NoSuchMethodErro r.class,
Symbol.intern("OutOfMemoryError"), OutOfMemoryError. class,
Symbol.intern("StackOverflowError"), StackOverflowEr ror.class,
Symbol.intern("ThreadDeath"), ThreadDeath.class,
Symbol.intern("UnknownError"), UnknownError.class,
Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLi nkError.class,
Symbol.intern("UnsupportedClassVersionError"),
UnsupportedClassVersionError.class,
Symbol.intern("VerifyError"), VerifyError.class,
Symbol.intern("VirtualMachineError"), VirtualMachine Error.class,
Symbol.intern("Thread$UncaughtExceptionHandler"),
Thread.UncaughtExceptionHandler.class,
1098 CHAPTER 9. JVM/CLOJURE/LANG/
Symbol.intern("Thread$State"), Thread.State.class,
Symbol.intern("Deprecated"), Deprecated.class,
Symbol.intern("Override"), Override.class,
Symbol.intern("SuppressWarnings"), SuppressWarnings. class
// Symbol.intern("Collection"), "java.util.Collection ",
// Symbol.intern("Comparator"), "java.util.Comparator ",
// Symbol.intern("Enumeration"), "java.util.Enumerati on",
// Symbol.intern("EventListener"), "java.util.EventLi stener",
// Symbol.intern("Formattable"), "java.util.Formattab le",
// Symbol.intern("Iterator"), "java.util.Iterator",
// Symbol.intern("List"), "java.util.List",
// Symbol.intern("ListIterator"), "java.util.ListIter ator",
// Symbol.intern("Map"), "java.util.Map",
// Symbol.intern("Map$Entry"), "java.util.Map$Entry",
// Symbol.intern("Observer"), "java.util.Observer",
// Symbol.intern("Queue"), "java.util.Queue",
// Symbol.intern("RandomAccess"), "java.util.RandomAc cess",
// Symbol.intern("Set"), "java.util.Set",
// Symbol.intern("SortedMap"), "java.util.SortedMap",
// Symbol.intern("SortedSet"), "java.util.SortedSet"
);
// single instance of UTF-8 Charset, so as to avoid
// catching UnsupportedCharsetExceptions everywhere
static public Charset UTF8 = Charset.forName("UTF-8");
static public final Namespace CLOJURE_NS =
Namespace.findOrCreate(Symbol.intern("clojure.core" ));
//static final Namespace USER_NS =
// Namespace.findOrCreate(Symbol.intern("user"));
final static public Var OUT =
Var.intern(CLOJURE_NS, Symbol.intern("*out*"),
new OutputStreamWriter(System.out))
.setDynamic();
final static public Var IN =
Var.intern(CLOJURE_NS, Symbol.intern("*in*"),
new LineNumberingPushbackReader(
new InputStreamReader(System.in)))
.setDynamic();
final static public Var ERR =
Var.intern(CLOJURE_NS, Symbol.intern("*err*"),
new PrintWriter(
new OutputStreamWriter(System.err), true))
.setDynamic();
final static Keyword TAG_KEY = Keyword.intern(null, "tag" );
final static public Var AGENT =
Var.intern(CLOJURE_NS, Symbol.intern("*agent*"), null )
.setDynamic();
final static public Var READEVAL =
9.95. RT.JAVA 1099
Var.intern(CLOJURE_NS, Symbol.intern("*read-eval*"), T)
.setDynamic();
final static public Var ASSERT =
Var.intern(CLOJURE_NS, Symbol.intern("*assert*"), T)
.setDynamic();
final static public Var MATH_CONTEXT =
Var.intern(CLOJURE_NS, Symbol.intern("*math-context* "), null)
.setDynamic();
static Keyword LINE_KEY = Keyword.intern(null, "line");
static Keyword FILE_KEY = Keyword.intern(null, "file");
static Keyword DECLARED_KEY = Keyword.intern(null, "decl ared");
static Keyword DOC_KEY = Keyword.intern(null, "doc");
final static public Var USE_CONTEXT_CLASSLOADER =
Var.intern(CLOJURE_NS,
Symbol.intern("*use-context-classloader*"), T)
.setDynamic();
//final static public Var CURRENT_MODULE =
// Var.intern(Symbol.intern("clojure.core", "current- module"),
// Module.findOrCreateModule("clojure/user"));
final static Symbol LOAD_FILE = Symbol.intern("load-file ");
final static Symbol IN_NAMESPACE = Symbol.intern("in-ns" );
final static Symbol NAMESPACE = Symbol.intern("ns");
static final Symbol IDENTICAL = Symbol.intern("identical ?");
final static Var CMD_LINE_ARGS =
Var.intern(CLOJURE_NS,
Symbol.intern("*command-line-args*"), null)
.setDynamic();
//symbol
final public static Var CURRENT_NS =
Var.intern(CLOJURE_NS, Symbol.intern("*ns*"), CLOJURE _NS)
.setDynamic();
final static Var FLUSH_ON_NEWLINE =
Var.intern(CLOJURE_NS, Symbol.intern("*flush-on-newl ine*"), T)
.setDynamic();
final static Var PRINT_META =
Var.intern(CLOJURE_NS, Symbol.intern("*print-meta*") , F)
.setDynamic();
final static Var PRINT_READABLY =
Var.intern(CLOJURE_NS, Symbol.intern("*print-readabl y*"), T)
.setDynamic();
final static Var PRINT_DUP =
Var.intern(CLOJURE_NS, Symbol.intern("*print-dup*"), F)
.setDynamic();
final static Var WARN_ON_REFLECTION =
Var.intern(CLOJURE_NS, Symbol.intern("*warn-on-refle ction*"), F)
.setDynamic();
final static Var ALLOW_UNRESOLVED_VARS =
Var.intern(CLOJURE_NS,
1100 CHAPTER 9. JVM/CLOJURE/LANG/
Symbol.intern("*allow-unresolved-vars*"), F)
.setDynamic();
final static Var IN_NS_VAR =
Var.intern(CLOJURE_NS, Symbol.intern("in-ns"), F);
final static Var NS_VAR =
Var.intern(CLOJURE_NS, Symbol.intern("ns"), F);
static final Var PRINT_INITIALIZED =
Var.intern(CLOJURE_NS, Symbol.intern("print-initiali zed"));
static final Var PR_ON =
Var.intern(CLOJURE_NS, Symbol.intern("pr-on"));
//final static Var IMPORTS =
// Var.intern(CLOJURE_NS, Symbol.intern("*imports*"),
// DEFAULT_IMPORTS);
final static IFn inNamespace = new AFn(){
public Object invoke(Object arg1) throws Exception{
Symbol nsname = (Symbol) arg1;
Namespace ns = Namespace.findOrCreate(nsname);
CURRENT_NS.set(ns);
return ns;
}
};
final static IFn bootNamespace = new AFn(){
public Object invoke(Object __form,
Object __env,Object arg1)
throws Exception{
Symbol nsname = (Symbol) arg1;
Namespace ns = Namespace.findOrCreate(nsname);
CURRENT_NS.set(ns);
return ns;
}
};
public static List<String> processCommandLine(String[] args){
List<String> arglist = Arrays.asList(args);
int split = arglist.indexOf("--");
if(split >= 0) {
CMD_LINE_ARGS.bindRoot(
RT.seq(arglist.subList(split + 1, args.length)));
return arglist.subList(0, split);
}
return arglist;
}
// duck typing stderr plays nice with e.g. swank
public static PrintWriter errPrintWriter(){
Writer w = (Writer) ERR.deref();
if (w instanceof PrintWriter) {
return (PrintWriter) w;
9.95. RT.JAVA 1101
} else {
return new PrintWriter(w);
}
}
static public final Object[] EMPTY_ARRAY = new Object[]{};
static public final Comparator DEFAULT_COMPARATOR =
new DefaultComparator();
private static final class DefaultComparator
implements Comparator, Serializable {
public int compare(Object o1, Object o2){
return Util.compare(o1, o2);
}
private Object readResolve() throws ObjectStreamExcepti on {
// ensures that we aren’t hanging onto a new default
// comparator for every sorted set, etc., we deserialize
return DEFAULT_COMPARATOR;
}
}
static AtomicInteger id = new AtomicInteger(1);
static public void addURL(Object url) throws Exception{
URL u =
(url instanceof String) ? (new URL((String) url)) : (URL) ur l;
ClassLoader ccl = Thread.currentThread().getContextCla ssLoader();
if(ccl instanceof DynamicClassLoader)
((DynamicClassLoader)ccl).addURL(u);
else
throw new IllegalAccessError(
"Context classloader is not a DynamicClassLoader");
}
static{
Keyword arglistskw = Keyword.intern(null, "arglists");
Symbol namesym = Symbol.intern("name");
OUT.setTag(Symbol.intern("java.io.Writer"));
CURRENT_NS.setTag(Symbol.intern("clojure.lang.Names pace"));
AGENT.setMeta(map(DOC_KEY,
"The agent currently running an action on "+
"this thread, else nil"));
AGENT.setTag(Symbol.intern("clojure.lang.Agent"));
MATH_CONTEXT.setTag(Symbol.intern("java.math.MathCo ntext"));
Var nv = Var.intern(CLOJURE_NS, NAMESPACE, bootNamespace );
nv.setMacro();
Var v;
v = Var.intern(CLOJURE_NS, IN_NAMESPACE, inNamespace);
v.setMeta(map(DOC_KEY,
1102 CHAPTER 9. JVM/CLOJURE/LANG/
"Sets *ns* to the namespace named by the symbol, "+
"creating it if needed.",
arglistskw, list(vector(namesym))));
v = Var.intern(CLOJURE_NS, LOAD_FILE,
new AFn(){
public Object invoke(Object arg1)
throws Exception{
return Compiler.loadFile((String) arg1);
}
});
v.setMeta(map(DOC_KEY,
"Sequentially read and evaluate the set of "+
"forms contained in the file.",
arglistskw, list(vector(namesym))));
try {
doInit();
}
catch(Exception e) {
throw new RuntimeException(e);
}
}
static public Var var(String ns, String name){
return
Var.intern(Namespace.findOrCreate(Symbol.intern(nul l, ns)),
Symbol.intern(null, name));
}
static public Var var(String ns, String name, Object init){
return
Var.intern(
Namespace.findOrCreate(Symbol.intern(null, ns)),
Symbol.intern(null, name), init);
}
public static void loadResourceScript(String name)
throws Exception{
loadResourceScript(name, true);
}
public static void maybeLoadResourceScript(String name)
throws Exception{
loadResourceScript(name, false);
}
public static void loadResourceScript(String name,
boolean failIfNotFound)
throws Exception{
loadResourceScript(RT.class, name, failIfNotFound);
9.95. RT.JAVA 1103
}
public static void loadResourceScript(Class c, String nam e)
throws Exception{
loadResourceScript(c, name, true);
}
public static void loadResourceScript(Class c,
String name,
boolean failIfNotFound)
throws Exception{
int slash = name.lastIndexOf(’/’);
String file = slash >= 0 ? name.substring(slash + 1) : name;
InputStream ins = baseLoader().getResourceAsStream(nam e);
if(ins != null) {
try {
Compiler.load(new InputStreamReader(ins, UTF8), name, f ile);
}
finally {
ins.close();
}
}
else if(failIfNotFound) {
throw new FileNotFoundException(
"Could not locate Clojure resource on classpath: " + name);
}
}
static public void init() throws Exception{
RT.errPrintWriter().println(
"No need to call RT.init() anymore");
}
static public long lastModified(URL url, String libfile)
throws Exception{
if(url.getProtocol().equals("jar")) {
return
((JarURLConnection) url.openConnection())
.getJarFile()
.getEntry(libfile)
.getTime();
}
else {
return url.openConnection().getLastModified();
}
}
static void compile(String cljfile) throws Exception{
InputStream ins = baseLoader().getResourceAsStream(clj file);
if(ins != null) {
1104 CHAPTER 9. JVM/CLOJURE/LANG/
try {
Compiler.compile(
new InputStreamReader(ins, UTF8), cljfile,
cljfile.substring(1 + cljfile.lastIndexOf("/")));
}
finally {
ins.close();
}
}
else
throw new FileNotFoundException(
"Could not locate Clojure resource on classpath: " + cljfile );
}
static public void load(String scriptbase) throws Excepti on{
load(scriptbase, true);
}
static public void load(String scriptbase, boolean failIf NotFound)
throws Exception{
String classfile = scriptbase + LOADER_SUFFIX + ".class";
String cljfile = scriptbase + ".clj";
URL classURL = baseLoader().getResource(classfile);
URL cljURL = baseLoader().getResource(cljfile);
boolean loaded = false;
if((classURL != null &&
(cljURL == null
|| lastModified(classURL, classfile) >
lastModified(cljURL, cljfile)))
|| classURL == null) {
try {
Var.pushThreadBindings(
RT.map(CURRENT_NS, CURRENT_NS.deref(),
WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref()));
loaded =
(loadClassForName(scriptbase.replace(’/’, ’.’) +
LOADER_SUFFIX) != null);
}
finally {
Var.popThreadBindings();
}
}
if(!loaded && cljURL != null) {
if(booleanCast(Compiler.COMPILE_FILES.deref()))
compile(cljfile);
else
loadResourceScript(RT.class, cljfile);
}
9.95. RT.JAVA 1105
else if(!loaded && failIfNotFound)
throw new FileNotFoundException(String.format(
"Could not locate %s or %s on classpath: ",
classfile, cljfile));
}
static void doInit() throws Exception{
load("clojure/core");
Var.pushThreadBindings(
RT.map(CURRENT_NS, CURRENT_NS.deref(),
WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref()));
try {
Symbol USER = Symbol.intern("user");
Symbol CLOJURE = Symbol.intern("clojure.core");
Var in_ns = var("clojure.core", "in-ns");
Var refer = var("clojure.core", "refer");
in_ns.invoke(USER);
refer.invoke(CLOJURE);
maybeLoadResourceScript("user.clj");
}
finally {
Var.popThreadBindings();
}
}
static public int nextID(){
return id.getAndIncrement();
}
////////////// Collections support /////////////////// //////////////
static public ISeq seq(Object coll){
if(coll instanceof ASeq)
return (ASeq) coll;
else if(coll instanceof LazySeq)
return ((LazySeq) coll).seq();
else
return seqFrom(coll);
}
static ISeq seqFrom(Object coll){
if(coll instanceof Seqable)
return ((Seqable) coll).seq();
else if(coll == null)
return null;
else if(coll instanceof Iterable)
return IteratorSeq.create(((Iterable) coll).iterator( ));
1106 CHAPTER 9. JVM/CLOJURE/LANG/
else if(coll.getClass().isArray())
return ArraySeq.createFromObject(coll);
else if(coll instanceof CharSequence)
return StringSeq.create((CharSequence) coll);
else if(coll instanceof Map)
return seq(((Map) coll).entrySet());
else {
Class c = coll.getClass();
Class sc = c.getSuperclass();
throw new IllegalArgumentException(
"Don’t know how to create ISeq from: " + c.getName());
}
}
static public ISeq keys(Object coll){
return APersistentMap.KeySeq.create(seq(coll));
}
static public ISeq vals(Object coll){
return APersistentMap.ValSeq.create(seq(coll));
}
static public IPersistentMap meta(Object x){
if(x instanceof IMeta)
return ((IMeta) x).meta();
return null;
}
public static int count(Object o){
if(o instanceof Counted)
return ((Counted) o).count();
return countFrom(Util.ret1(o, o = null));
}
static int countFrom(Object o){
if(o == null)
return 0;
else if(o instanceof IPersistentCollection) {
ISeq s = seq(o);
o = null;
int i = 0;
for(; s != null; s = s.next()) {
if(s instanceof Counted)
return i + s.count();
i++;
}
return i;
}
else if(o instanceof CharSequence)
return ((CharSequence) o).length();
9.95. RT.JAVA 1107
else if(o instanceof Collection)
return ((Collection) o).size();
else if(o instanceof Map)
return ((Map) o).size();
else if(o.getClass().isArray())
return Array.getLength(o);
throw new UnsupportedOperationException(
"count not supported on this type: " +
o.getClass().getSimpleName());
}
static public IPersistentCollection conj(IPersistentCo llection coll,
Object x){
if(coll == null)
return new PersistentList(x);
return coll.cons(x);
}
static public ISeq cons(Object x, Object coll){
//ISeq y = seq(coll);
if(coll == null)
return new PersistentList(x);
else if(coll instanceof ISeq)
return new Cons(x, (ISeq) coll);
else
return new Cons(x, seq(coll));
}
static public Object first(Object x){
if(x instanceof ISeq)
return ((ISeq) x).first();
ISeq seq = seq(x);
if(seq == null)
return null;
return seq.first();
}
static public Object second(Object x){
return first(next(x));
}
static public Object third(Object x){
return first(next(next(x)));
}
static public Object fourth(Object x){
return first(next(next(next(x))));
}
1108 CHAPTER 9. JVM/CLOJURE/LANG/
static public ISeq next(Object x){
if(x instanceof ISeq)
return ((ISeq) x).next();
ISeq seq = seq(x);
if(seq == null)
return null;
return seq.next();
}
static public ISeq more(Object x){
if(x instanceof ISeq)
return ((ISeq) x).more();
ISeq seq = seq(x);
if(seq == null)
return PersistentList.EMPTY;
return seq.more();
}
//static public Seqable more(Object x){
// Seqable ret = null;
// if(x instanceof ISeq)
// ret = ((ISeq) x).more();
// else
// {
// ISeq seq = seq(x);
// if(seq == null)
// ret = PersistentList.EMPTY;
// else
// ret = seq.more();
// }
// if(ret == null)
// ret = PersistentList.EMPTY;
// return ret;
//}
static public Object peek(Object x){
if(x == null)
return null;
return ((IPersistentStack) x).peek();
}
static public Object pop(Object x){
if(x == null)
return null;
return ((IPersistentStack) x).pop();
}
static public Object get(Object coll, Object key){
if(coll instanceof ILookup)
return ((ILookup) coll).valAt(key);
9.95. RT.JAVA 1109
return getFrom(coll, key);
}
static Object getFrom(Object coll, Object key){
if(coll == null)
return null;
else if(coll instanceof Map) {
Map m = (Map) coll;
return m.get(key);
}
else if(coll instanceof IPersistentSet) {
IPersistentSet set = (IPersistentSet) coll;
return set.get(key);
}
else if(key instanceof Number &&
(coll instanceof String ||
coll.getClass().isArray())) {
int n = ((Number) key).intValue();
if(n >= 0 && n < count(coll))
return nth(coll, n);
return null;
}
return null;
}
static public Object get(Object coll, Object key, Object no tFound){
if(coll instanceof ILookup)
return ((ILookup) coll).valAt(key, notFound);
return getFrom(coll, key, notFound);
}
static Object getFrom(Object coll, Object key, Object notF ound){
if(coll == null)
return notFound;
else if(coll instanceof Map) {
Map m = (Map) coll;
if(m.containsKey(key))
return m.get(key);
return notFound;
}
else if(coll instanceof IPersistentSet) {
IPersistentSet set = (IPersistentSet) coll;
if(set.contains(key))
return set.get(key);
return notFound;
}
else if(key instanceof Number &&
(coll instanceof String ||
coll.getClass().isArray())) {
1110 CHAPTER 9. JVM/CLOJURE/LANG/
int n = ((Number) key).intValue();
return n >= 0 && n < count(coll) ? nth(coll, n) : notFound;
}
return notFound;
}
static public Associative assoc(Object coll, Object key, O bject val){
if(coll == null)
return new PersistentArrayMap(new Object[]{key, val});
return ((Associative) coll).assoc(key, val);
}
static public Object contains(Object coll, Object key){
if(coll == null)
return F;
else if(coll instanceof Associative)
return ((Associative) coll).containsKey(key) ? T : F;
else if(coll instanceof IPersistentSet)
return ((IPersistentSet) coll).contains(key) ? T : F;
else if(coll instanceof Map) {
Map m = (Map) coll;
return m.containsKey(key) ? T : F;
}
else if(key instanceof Number &&
(coll instanceof String ||
coll.getClass().isArray())) {
int n = ((Number) key).intValue();
return n >= 0 && n < count(coll);
}
return F;
}
static public Object find(Object coll, Object key){
if(coll == null)
return null;
else if(coll instanceof Associative)
return ((Associative) coll).entryAt(key);
else {
Map m = (Map) coll;
if(m.containsKey(key))
return new MapEntry(key, m.get(key));
return null;
}
}
//takes a seq of key,val,key,val
//returns tail starting at val of matching key if found, else null
static public ISeq findKey(Keyword key, ISeq keyvals)
9.95. RT.JAVA 1111
throws Exception{
while(keyvals != null) {
ISeq r = keyvals.next();
if(r == null)
throw new Exception("Malformed keyword argslist");
if(keyvals.first() == key)
return r;
keyvals = r.next();
}
return null;
}
static public Object dissoc(Object coll, Object key)
throws Exception{
if(coll == null)
return null;
return ((IPersistentMap) coll).without(key);
}
static public Object nth(Object coll, int n){
if(coll instanceof Indexed)
return ((Indexed) coll).nth(n);
return nthFrom(Util.ret1(coll, coll = null), n);
}
static Object nthFrom(Object coll, int n){
if(coll == null)
return null;
else if(coll instanceof CharSequence)
return Character.valueOf(((CharSequence) coll).charAt (n));
else if(coll.getClass().isArray())
return Reflector.prepRet(coll.getClass().getComponen tType(),
Array.get(coll, n));
else if(coll instanceof RandomAccess)
return ((List) coll).get(n);
else if(coll instanceof Matcher)
return ((Matcher) coll).group(n);
else if(coll instanceof Map.Entry) {
Map.Entry e = (Map.Entry) coll;
if(n == 0)
return e.getKey();
else if(n == 1)
return e.getValue();
throw new IndexOutOfBoundsException();
}
else if(coll instanceof Sequential) {
ISeq seq = RT.seq(coll);
coll = null;
1112 CHAPTER 9. JVM/CLOJURE/LANG/
for(int i = 0; i <= n && seq != null; ++i, seq = seq.next()) {
if(i == n)
return seq.first();
}
throw new IndexOutOfBoundsException();
}
else
throw new UnsupportedOperationException(
"nth not supported on this type: " +
coll.getClass().getSimpleName());
}
static public Object nth(Object coll, int n, Object notFoun d){
if(coll instanceof Indexed) {
Indexed v = (Indexed) coll;
return v.nth(n, notFound);
}
return nthFrom(coll, n, notFound);
}
static Object nthFrom(Object coll, int n, Object notFound) {
if(coll == null)
return notFound;
else if(n < 0)
return notFound;
else if(coll instanceof CharSequence) {
CharSequence s = (CharSequence) coll;
if(n < s.length())
return Character.valueOf(s.charAt(n));
return notFound;
}
else if(coll.getClass().isArray()) {
if(n < Array.getLength(coll))
return
Reflector.prepRet(coll.getClass().getComponentType( ),
Array.get(coll, n));
return notFound;
}
else if(coll instanceof RandomAccess) {
List list = (List) coll;
if(n < list.size())
return list.get(n);
return notFound;
}
else if(coll instanceof Matcher) {
Matcher m = (Matcher) coll;
if(n < m.groupCount())
return m.group(n);
return notFound;
9.95. RT.JAVA 1113
}
else if(coll instanceof Map.Entry) {
Map.Entry e = (Map.Entry) coll;
if(n == 0)
return e.getKey();
else if(n == 1)
return e.getValue();
return notFound;
}
else if(coll instanceof Sequential) {
ISeq seq = RT.seq(coll);
coll = null;
for(int i = 0;
i <= n && seq != null;
++i, seq = seq.next()) {
if(i == n)
return seq.first();
}
return notFound;
}
else
throw new UnsupportedOperationException(
"nth not supported on this type: " +
coll.getClass().getSimpleName());
}
static public Object assocN(int n, Object val, Object coll) {
if(coll == null)
return null;
else if(coll instanceof IPersistentVector)
return ((IPersistentVector) coll).assocN(n, val);
else if(coll instanceof Object[]) {
//hmm... this is not persistent
Object[] array = ((Object[]) coll);
array[n] = val;
return array;
}
else
return null;
}
static boolean hasTag(Object o, Object tag){
return Util.equals(tag, RT.get(RT.meta(o), TAG_KEY));
}
/**
* ********************* Boxing/casts ***************** *************
*/
static public Object box(Object x){
return x;
1114 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public Character box(char x){
return Character.valueOf(x);
}
static public Object box(boolean x){
return x ? T : F;
}
static public Object box(Boolean x){
return x;// ? T : null;
}
static public Number box(byte x){
return x;//Num.from(x);
}
static public Number box(short x){
return x;//Num.from(x);
}
static public Number box(int x){
return x;//Num.from(x);
}
static public Number box(long x){
return x;//Num.from(x);
}
static public Number box(float x){
return x;//Num.from(x);
}
static public Number box(double x){
return x;//Num.from(x);
}
static public char charCast(Object x){
if(x instanceof Character)
return ((Character) x).charValue();
long n = ((Number) x).longValue();
if(n < Character.MIN_VALUE || n > Character.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for char: " + x);
return (char) n;
}
9.95. RT.JAVA 1115
static public boolean booleanCast(Object x){
if(x instanceof Boolean)
return ((Boolean) x).booleanValue();
return x != null;
}
static public boolean booleanCast(boolean x){
return x;
}
static public byte byteCast(Object x){
if(x instanceof Byte)
return ((Byte) x).byteValue();
long n = longCast(x);
if(n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for byte: " + x);
return (byte) n;
}
static public short shortCast(Object x){
if(x instanceof Short)
return ((Short) x).shortValue();
long n = longCast(x);
if(n < Short.MIN_VALUE || n > Short.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for short: " + x);
return (short) n;
}
static public int intCast(Object x){
if(x instanceof Integer)
return ((Integer)x).intValue();
if(x instanceof Number)
{
long n = longCast(x);
return intCast(n);
}
return ((Character) x).charValue();
}
static public int intCast(char x){
return x;
}
static public int intCast(byte x){
return x;
}
1116 CHAPTER 9. JVM/CLOJURE/LANG/
static public int intCast(short x){
return x;
}
static public int intCast(int x){
return x;
}
static public int intCast(float x){
if(x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for int: " + x);
return (int) x;
}
static public int intCast(long x){
int i = (int) x;
if(i != x)
throw new IllegalArgumentException(
"Value out of range for int: " + x);
return i;
}
static public int intCast(double x){
if(x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for int: " + x);
return (int) x;
}
static public long longCast(Object x){
if(x instanceof Integer || x instanceof Long)
return ((Number) x).longValue();
else if (x instanceof BigInt)
{
BigInt bi = (BigInt) x;
if(bi.bipart == null)
return bi.lpart;
else
throw new IllegalArgumentException(
"Value out of range for long: " + x);
}
else if (x instanceof BigInteger)
{
BigInteger bi = (BigInteger) x;
if(bi.bitLength() < 64)
return bi.longValue();
else
throw new IllegalArgumentException(
9.95. RT.JAVA 1117
"Value out of range for long: " + x);
}
return ((Number) x).longValue();
}
static public long longCast(int x){
return x;
}
static public long longCast(float x){
if(x < Long.MIN_VALUE || x > Long.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for long: " + x);
return (long) x;
}
static public long longCast(long x){
return x;
}
static public long longCast(double x){
if(x < Long.MIN_VALUE || x > Long.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for long: " + x);
return (long) x;
}
static public float floatCast(Object x){
if(x instanceof Float)
return ((Float) x).floatValue();
double n = ((Number) x).doubleValue();
if(n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for float: " + x);
return (float) n;
}
static public float floatCast(int x){
return x;
}
static public float floatCast(float x){
return x;
}
static public float floatCast(long x){
return x;
1118 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public float floatCast(double x){
if(x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
throw new IllegalArgumentException(
"Value out of range for float: " + x);
return (float) x;
}
static public double doubleCast(Object x){
return ((Number) x).doubleValue();
}
static public double doubleCast(int x){
return x;
}
static public double doubleCast(float x){
return x;
}
static public double doubleCast(long x){
return x;
}
static public double doubleCast(double x){
return x;
}
static public byte uncheckedByteCast(Object x){
return ((Number) x).byteValue();
}
static public byte uncheckedByteCast(byte x){
return x;
}
static public byte uncheckedByteCast(short x){
return (byte) x;
}
static public byte uncheckedByteCast(int x){
return (byte) x;
}
static public byte uncheckedByteCast(long x){
return (byte) x;
}
9.95. RT.JAVA 1119
static public byte uncheckedByteCast(float x){
return (byte) x;
}
static public byte uncheckedByteCast(double x){
return (byte) x;
}
static public short uncheckedShortCast(Object x){
return ((Number) x).shortValue();
}
static public short uncheckedShortCast(byte x){
return x;
}
static public short uncheckedShortCast(short x){
return x;
}
static public short uncheckedShortCast(int x){
return (short) x;
}
static public short uncheckedShortCast(long x){
return (short) x;
}
static public short uncheckedShortCast(float x){
return (short) x;
}
static public short uncheckedShortCast(double x){
return (short) x;
}
static public char uncheckedCharCast(Object x){
if(x instanceof Character)
return ((Character) x).charValue();
return (char) ((Number) x).longValue();
}
static public char uncheckedCharCast(byte x){
return (char) x;
}
static public char uncheckedCharCast(short x){
return (char) x;
}
1120 CHAPTER 9. JVM/CLOJURE/LANG/
static public char uncheckedCharCast(char x){
return x;
}
static public char uncheckedCharCast(int x){
return (char) x;
}
static public char uncheckedCharCast(long x){
return (char) x;
}
static public char uncheckedCharCast(float x){
return (char) x;
}
static public char uncheckedCharCast(double x){
return (char) x;
}
static public int uncheckedIntCast(Object x){
if(x instanceof Number)
return ((Number)x).intValue();
return ((Character) x).charValue();
}
static public int uncheckedIntCast(byte x){
return x;
}
static public int uncheckedIntCast(short x){
return x;
}
static public int uncheckedIntCast(char x){
return x;
}
static public int uncheckedIntCast(int x){
return x;
}
static public int uncheckedIntCast(long x){
return (int) x;
}
static public int uncheckedIntCast(float x){
return (int) x;
}
9.95. RT.JAVA 1121
static public int uncheckedIntCast(double x){
return (int) x;
}
static public long uncheckedLongCast(Object x){
return ((Number) x).longValue();
}
static public long uncheckedLongCast(byte x){
return x;
}
static public long uncheckedLongCast(short x){
return x;
}
static public long uncheckedLongCast(int x){
return x;
}
static public long uncheckedLongCast(long x){
return x;
}
static public long uncheckedLongCast(float x){
return (long) x;
}
static public long uncheckedLongCast(double x){
return (long) x;
}
static public float uncheckedFloatCast(Object x){
return ((Number) x).floatValue();
}
static public float uncheckedFloatCast(byte x){
return x;
}
static public float uncheckedFloatCast(short x){
return x;
}
static public float uncheckedFloatCast(int x){
return x;
}
static public float uncheckedFloatCast(long x){
return x;
1122 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public float uncheckedFloatCast(float x){
return x;
}
static public float uncheckedFloatCast(double x){
return (float) x;
}
static public double uncheckedDoubleCast(Object x){
return ((Number) x).doubleValue();
}
static public double uncheckedDoubleCast(byte x){
return x;
}
static public double uncheckedDoubleCast(short x){
return x;
}
static public double uncheckedDoubleCast(int x){
return x;
}
static public double uncheckedDoubleCast(long x){
return x;
}
static public double uncheckedDoubleCast(float x){
return x;
}
static public double uncheckedDoubleCast(double x){
return x;
}
static public IPersistentMap map(Object... init){
if(init == null)
return PersistentArrayMap.EMPTY;
else if(init.length <= PersistentArrayMap.HASHTABLE_TH RESHOLD)
return PersistentArrayMap.createWithCheck(init);
return PersistentHashMap.createWithCheck(init);
}
static public IPersistentSet set(Object... init){
return PersistentHashSet.createWithCheck(init);
}
9.95. RT.JAVA 1123
static public IPersistentVector vector(Object... init){
return LazilyPersistentVector.createOwning(init);
}
static public IPersistentVector
subvec(IPersistentVector v, int start, int end){
if(end < start || start < 0 || end > v.count())
throw new IndexOutOfBoundsException();
if(start == end)
return PersistentVector.EMPTY;
return new APersistentVector.SubVector(null, v, start, e nd);
}
/**
* **** list support ****
*/
static public ISeq list(){
return null;
}
static public ISeq list(Object arg1){
return new PersistentList(arg1);
}
static public ISeq list(Object arg1, Object arg2){
return listStar(arg1, arg2, null);
}
static public ISeq list(Object arg1, Object arg2, Object ar g3){
return listStar(arg1, arg2, arg3, null);
}
static public ISeq list(Object arg1, Object arg2, Object ar g3,
Object arg4){
return listStar(arg1, arg2, arg3, arg4, null);
}
static public ISeq list(Object arg1, Object arg2, Object ar g3,
Object arg4, Object arg5){
return listStar(arg1, arg2, arg3, arg4, arg5, null);
}
static public ISeq listStar(Object arg1, ISeq rest){
return (ISeq) cons(arg1, rest);
}
static public ISeq listStar(Object arg1, Object arg2, ISeq rest){
return (ISeq) cons(arg1, cons(arg2, rest));
1124 CHAPTER 9. JVM/CLOJURE/LANG/
}
static public ISeq listStar(Object arg1, Object arg2, Obje ct arg3,
ISeq rest){
return (ISeq) cons(arg1, cons(arg2, cons(arg3, rest)));
}
static public ISeq listStar(Object arg1, Object arg2, Obje ct arg3,
Object arg4, ISeq rest){
return
(ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest) )));
}
static public ISeq listStar(Object arg1, Object arg2, Obje ct arg3,
Object arg4, Object arg5, ISeq rest){
return
(ISeq) cons(arg1,
cons(arg2,
cons(arg3,
cons(arg4,
cons(arg5, rest)))));
}
static public ISeq arrayToList(Object[] a) throws Excepti on{
ISeq ret = null;
for(int i = a.length - 1; i >= 0; --i)
ret = (ISeq) cons(a[i], ret);
return ret;
}
static public Object[] object_array(Object sizeOrSeq){
if(sizeOrSeq instanceof Number)
return new Object[((Number) sizeOrSeq).intValue()];
else
{
ISeq s = RT.seq(sizeOrSeq);
int size = RT.count(s);
Object[] ret = new Object[size];
for(int i = 0; i < size && s != null; i++, s = s.next())
ret[i] = s.first();
return ret;
}
}
static public Object[] toArray(Object coll) throws Except ion{
if(coll == null)
return EMPTY_ARRAY;
else if(coll instanceof Object[])
return (Object[]) coll;
else if(coll instanceof Collection)
9.95. RT.JAVA 1125
return ((Collection) coll).toArray();
else if(coll instanceof Map)
return ((Map) coll).entrySet().toArray();
else if(coll instanceof String) {
char[] chars = ((String) coll).toCharArray();
Object[] ret = new Object[chars.length];
for(int i = 0; i < chars.length; i++)
ret[i] = chars[i];
return ret;
}
else if(coll.getClass().isArray()) {
ISeq s = (seq(coll));
Object[] ret = new Object[count(s)];
for(int i = 0; i < ret.length; i++, s = s.next())
ret[i] = s.first();
return ret;
}
else
throw new Exception("Unable to convert: " +
coll.getClass() + " to Object[]");
}
static public Object[] seqToArray(ISeq seq){
int len = length(seq);
Object[] ret = new Object[len];
for(int i = 0; seq != null; ++i, seq = seq.next())
ret[i] = seq.first();
return ret;
}
static public Object seqToTypedArray(ISeq seq) throws Exc eption{
Class type = (seq != null) ? seq.first().getClass() : Object .class;
return seqToTypedArray(type, seq);
}
static public Object seqToTypedArray(Class type, ISeq seq )
throws Exception{
Object ret = Array.newInstance(type, length(seq));
if(type == Integer.TYPE){
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, intCast(seq.first()));
}
} else if(type == Byte.TYPE) {
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, byteCast(seq.first()));
}
} else if(type == Float.TYPE) {
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, floatCast(seq.first()));
}
1126 CHAPTER 9. JVM/CLOJURE/LANG/
} else if(type == Short.TYPE) {
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, shortCast(seq.first()));
}
} else if(type == Character.TYPE) {
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, charCast(seq.first()));
}
} else {
for(int i = 0; seq != null; ++i, seq=seq.next()){
Array.set(ret, i, seq.first());
}
}
return ret;
}
static public int length(ISeq list){
int i = 0;
for(ISeq c = list; c != null; c = c.next()) {
i++;
}
return i;
}
static public int boundedLength(ISeq list, int limit)
throws Exception{
int i = 0;
for(ISeq c = list; c != null && i <= limit; c = c.next()) {
i++;
}
return i;
}
//// reader support ////
static Character readRet(int ret){
if(ret == -1)
return null;
return box((char) ret);
}
static public Character readChar(Reader r) throws Excepti on{
int ret = r.read();
return readRet(ret);
}
static public Character peekChar(Reader r) throws Excepti on{
int ret;
if(r instanceof PushbackReader) {
ret = r.read();
9.95. RT.JAVA 1127
((PushbackReader) r).unread(ret);
}
else {
r.mark(1);
ret = r.read();
r.reset();
}
return readRet(ret);
}
static public int getLineNumber(Reader r){
if(r instanceof LineNumberingPushbackReader)
return ((LineNumberingPushbackReader) r).getLineNumbe r();
return 0;
}
static public LineNumberingPushbackReader
getLineNumberingReader(Reader r){
if(isLineNumberingReader(r))
return (LineNumberingPushbackReader) r;
return new LineNumberingPushbackReader(r);
}
static public boolean isLineNumberingReader(Reader r){
return r instanceof LineNumberingPushbackReader;
}
static public String resolveClassNameInContext(String c lassName){
//todo - look up in context var
return className;
}
static public boolean suppressRead(){
//todo - look up in suppress-read var
return false;
}
static public String printString(Object x){
try {
StringWriter sw = new StringWriter();
print(x, sw);
return sw.toString();
}
catch(Exception e) {
throw new RuntimeException(e);
}
}
static public Object readString(String s){
1128 CHAPTER 9. JVM/CLOJURE/LANG/
PushbackReader r = new PushbackReader(new StringReader(s ));
try {
return LispReader.read(r, true, null, false);
}
catch(Exception e) {
throw new RuntimeException(e);
}
}
static public void print(Object x, Writer w) throws Excepti on{
//call multimethod
if(PRINT_INITIALIZED.isBound() &&
RT.booleanCast(PRINT_INITIALIZED.deref()))
PR_ON.invoke(x, w);
//*
else {
boolean readably = booleanCast(PRINT_READABLY.deref()) ;
if(x instanceof Obj) {
Obj o = (Obj) x;
if(RT.count(o.meta()) > 0 &&
((readably && booleanCast(PRINT_META.deref()))
|| booleanCast(PRINT_DUP.deref()))) {
IPersistentMap meta = o.meta();
w.write("#^");
if(meta.count() == 1 && meta.containsKey(TAG_KEY))
print(meta.valAt(TAG_KEY), w);
else
print(meta, w);
w.write(’ ’);
}
}
if(x == null)
w.write("nil");
else if(x instanceof ISeq || x instanceof IPersistentList) {
w.write(’(’);
printInnerSeq(seq(x), w);
w.write(’)’);
}
else if(x instanceof String) {
String s = (String) x;
if(!readably)
w.write(s);
else {
w.write(’"’);
//w.write(x.toString());
for(int i = 0; i < s.length(); i++) {
char c = s.charAt(i);
switch(c) {
case ’\n’:
w.write("\\n");
9.95. RT.JAVA 1129
break;
case ’\t’:
w.write("\\t");
break;
case ’\r’:
w.write("\\r");
break;
case ’"’:
w.write("\\\"");
break;
case ’\\’:
w.write("\\\\");
break;
case ’\f’:
w.write("\\f");
break;
case ’\b’:
w.write("\\b");
break;
default:
w.write(c);
}
}
w.write(’"’);
}
}
else if(x instanceof IPersistentMap) {
w.write(’{’);
for(ISeq s = seq(x); s != null; s = s.next()) {
IMapEntry e = (IMapEntry) s.first();
print(e.key(), w);
w.write(’ ’);
print(e.val(), w);
if(s.next() != null)
w.write(", ");
}
w.write(’}’);
}
else if(x instanceof IPersistentVector) {
IPersistentVector a = (IPersistentVector) x;
w.write(’[’);
for(int i = 0; i < a.count(); i++) {
print(a.nth(i), w);
if(i < a.count() - 1)
w.write(’ ’);
}
w.write(’]’);
}
else if(x instanceof IPersistentSet) {
w.write("#{");
1130 CHAPTER 9. JVM/CLOJURE/LANG/
for(ISeq s = seq(x); s != null; s = s.next()) {
print(s.first(), w);
if(s.next() != null)
w.write(" ");
}
w.write(’}’);
}
else if(x instanceof Character) {
char c = ((Character) x).charValue();
if(!readably)
w.write(c);
else {
w.write(’\\’);
switch(c) {
case ’\n’:
w.write("newline");
break;
case ’\t’:
w.write("tab");
break;
case ’ ’:
w.write("space");
break;
case ’\b’:
w.write("backspace");
break;
case ’\f’:
w.write("formfeed");
break;
case ’\r’:
w.write("return");
break;
default:
w.write(c);
}
}
}
else if(x instanceof Class) {
w.write("#=");
w.write(((Class) x).getName());
}
else if(x instanceof BigDecimal && readably) {
w.write(x.toString());
w.write(’M’);
}
else if(x instanceof BigInt && readably) {
w.write(x.toString());
w.write(’N’);
}
else if(x instanceof BigInteger && readably) {
9.95. RT.JAVA 1131
w.write(x.toString());
w.write("BIGINT");
}
else if(x instanceof Var) {
Var v = (Var) x;
w.write("#=(var " + v.ns.name + "/" + v.sym + ")");
}
else if(x instanceof Pattern) {
Pattern p = (Pattern) x;
w.write("#\"" + p.pattern() + "\"");
}
else w.write(x.toString());
}
//*/
}
private static void printInnerSeq(ISeq x, Writer w)
throws Exception{
for(ISeq s = x; s != null; s = s.next()) {
print(s.first(), w);
if(s.next() != null)
w.write(’ ’);
}
}
static public void formatAesthetic(Writer w, Object obj)
throws IOException{
if(obj == null)
w.write("null");
else
w.write(obj.toString());
}
static public void formatStandard(Writer w, Object obj)
throws IOException{
if(obj == null)
w.write("null");
else if(obj instanceof String) {
w.write(’"’);
w.write((String) obj);
w.write(’"’);
}
else if(obj instanceof Character) {
w.write(’\\’);
char c = ((Character) obj).charValue();
switch(c) {
case ’\n’:
w.write("newline");
break;
case ’\t’:
1132 CHAPTER 9. JVM/CLOJURE/LANG/
w.write("tab");
break;
case ’ ’:
w.write("space");
break;
case ’\b’:
w.write("backspace");
break;
case ’\f’:
w.write("formfeed");
break;
default:
w.write(c);
}
}
else
w.write(obj.toString());
}
static public Object format(Object o, String s, Object... a rgs)
throws Exception{
Writer w;
if(o == null)
w = new StringWriter();
else if(Util.equals(o, T))
w = (Writer) OUT.deref();
else
w = (Writer) o;
doFormat(w, s, ArraySeq.create(args));
if(o == null)
return w.toString();
return null;
}
static public ISeq doFormat(Writer w, String s, ISeq args)
throws Exception{
for(int i = 0; i < s.length();) {
char c = s.charAt(i++);
switch(Character.toLowerCase(c)) {
case ’~’:
char d = s.charAt(i++);
switch(Character.toLowerCase(d)) {
case ’%’:
w.write(’\n’);
break;
case ’t’:
w.write(’\t’);
break;
case ’a’:
if(args == null)
9.95. RT.JAVA 1133
throw new IllegalArgumentException(
"Missing argument");
RT.formatAesthetic(w, RT.first(args));
args = RT.next(args);
break;
case ’s’:
if(args == null)
throw new IllegalArgumentException(
"Missing argument");
RT.formatStandard(w, RT.first(args));
args = RT.next(args);
break;
case ’{’:
int j = s.indexOf("~}", i); //note - does not nest
if(j == -1)
throw new IllegalArgumentException("Missing ~}");
String subs = s.substring(i, j);
for(ISeq sargs = RT.seq(RT.first(args)); sargs != null;)
sargs = doFormat(w, subs, sargs);
args = RT.next(args);
i = j + 2; //skip ~}
break;
case ’^’:
if(args == null)
return null;
break;
case ’~’:
w.write(’~’);
break;
default:
throw new IllegalArgumentException(
"Unsupported ~ directive: " + d);
}
break;
default:
w.write(c);
}
}
return args;
}
///////////////////////////////// values //////////// //////////////
static public Object[] setValues(Object... vals){
//ThreadLocalData.setValues(vals);
if(vals.length > 0)
return vals;//[0];
return null;
}
1134 CHAPTER 9. JVM/CLOJURE/LANG/
static public ClassLoader makeClassLoader(){
return (ClassLoader) AccessController
.doPrivileged(new PrivilegedAction(){
public Object run(){
try{
Var.pushThreadBindings(
RT.map(USE_CONTEXT_CLASSLOADER, RT.T));
// getRootClassLoader();
return new DynamicClassLoader(baseLoader());
}
finally{
Var.popThreadBindings();
}
}
});
}
static public ClassLoader baseLoader(){
if(Compiler.LOADER.isBound())
return (ClassLoader) Compiler.LOADER.deref();
else if(booleanCast(USE_CONTEXT_CLASSLOADER.deref()) )
return Thread.currentThread().getContextClassLoader( );
return Compiler.class.getClassLoader();
}
static public Class classForName(String name)
throws ClassNotFoundException{
return Class.forName(name, true, baseLoader());
}
static public Class loadClassForName(String name)
throws ClassNotFoundException{
try
{
Class.forName(name, false, baseLoader());
}
catch(ClassNotFoundException e)
{
return null;
}
return Class.forName(name, true, baseLoader());
}
static public float aget(float[] xs, int i){
return xs[i];
}
static public float aset(float[] xs, int i, float v){
xs[i] = v;
9.95. RT.JAVA 1135
return v;
}
static public int alength(float[] xs){
return xs.length;
}
static public float[] aclone(float[] xs){
return xs.clone();
}
static public double aget(double[] xs, int i){
return xs[i];
}
static public double aset(double[] xs, int i, double v){
xs[i] = v;
return v;
}
static public int alength(double[] xs){
return xs.length;
}
static public double[] aclone(double[] xs){
return xs.clone();
}
static public int aget(int[] xs, int i){
return xs[i];
}
static public int aset(int[] xs, int i, int v){
xs[i] = v;
return v;
}
static public int alength(int[] xs){
return xs.length;
}
static public int[] aclone(int[] xs){
return xs.clone();
}
static public long aget(long[] xs, int i){
return xs[i];
}
static public long aset(long[] xs, int i, long v){
1136 CHAPTER 9. JVM/CLOJURE/LANG/
xs[i] = v;
return v;
}
static public int alength(long[] xs){
return xs.length;
}
static public long[] aclone(long[] xs){
return xs.clone();
}
static public char aget(char[] xs, int i){
return xs[i];
}
static public char aset(char[] xs, int i, char v){
xs[i] = v;
return v;
}
static public int alength(char[] xs){
return xs.length;
}
static public char[] aclone(char[] xs){
return xs.clone();
}
static public byte aget(byte[] xs, int i){
return xs[i];
}
static public byte aset(byte[] xs, int i, byte v){
xs[i] = v;
return v;
}
static public int alength(byte[] xs){
return xs.length;
}
static public byte[] aclone(byte[] xs){
return xs.clone();
}
static public short aget(short[] xs, int i){
return xs[i];
}
9.95. RT.JAVA 1137
static public short aset(short[] xs, int i, short v){
xs[i] = v;
return v;
}
static public int alength(short[] xs){
return xs.length;
}
static public short[] aclone(short[] xs){
return xs.clone();
}
static public boolean aget(boolean[] xs, int i){
return xs[i];
}
static public boolean aset(boolean[] xs, int i, boolean v){
xs[i] = v;
return v;
}
static public int alength(boolean[] xs){
return xs.length;
}
static public boolean[] aclone(boolean[] xs){
return xs.clone();
}
static public Object aget(Object[] xs, int i){
return xs[i];
}
static public Object aset(Object[] xs, int i, Object v){
xs[i] = v;
return v;
}
static public int alength(Object[] xs){
return xs.length;
}
static public Object[] aclone(Object[] xs){
return xs.clone();
}
}
1138 CHAPTER 9. JVM/CLOJURE/LANG/
———-
9.96 Script.java
— Script.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Oct 18, 2007 */
package clojure.lang;
import clojure.main;
public class Script {
public static void main(String[] args) throws Exception{
main.legacy_script(args);
}
}
———-
9.97 SeqEnumeration.java
(Enumeration [1723])
— SeqEnumeration.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 3, 2008 */
package clojure.lang;
import java.util.Enumeration;
public class SeqEnumeration implements Enumeration{
ISeq seq;
public SeqEnumeration(ISeq seq){
this.seq = seq;
}
9.98. SEQITERATOR.JAVA 1139
public boolean hasMoreElements(){
return seq != null;
}
public Object nextElement(){
Object ret = RT.first(seq);
seq = RT.next(seq);
return ret;
}
}
———-
9.98 SeqIterator.java
(Iterator [1723])
— SeqIterator.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jun 19, 2007 */
package clojure.lang;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class SeqIterator implements Iterator{
ISeq seq;
public SeqIterator(ISeq seq){
this.seq = seq;
}
public boolean hasNext(){
return seq != null;
}
public Object next() throws NoSuchElementException {
if(seq == null)
throw new NoSuchElementException();
Object ret = RT.first(seq);
seq = RT.next(seq);
return ret;
}
1140 CHAPTER 9. JVM/CLOJURE/LANG/
public void remove(){
throw new UnsupportedOperationException();
}
}
———-
9.99 Seqable.java
— Seqable.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jan 28, 2009 */
package clojure.lang;
public interface Seqable {
ISeq seq();
}
———-
9.100 Sequential.java
— Sequential.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure.lang;
public interface Sequential {
}
———-
9.101 Settable.java
— Settable.java —
9.102. SORTED.JAVA 1141
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 31, 2008 */
package clojure.lang;
public interface Settable {
Object doSet(Object val) throws Exception;
Object doReset(Object val) throws Exception;
}
———-
9.102 Sorted.java
— Sorted.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Apr 15, 2008 */
package clojure.lang;
import java.util.Comparator;
public interface Sorted{
Comparator comparator();
Object entryKey(Object entry);
ISeq seq(boolean ascending);
ISeq seqFrom(Object key, boolean ascending);
}
———-
9.103 StringSeq.java
(ASeq [571]) (IndexedSeq [799])
— StringSeq.java —
/*
1142 CHAPTER 9. JVM/CLOJURE/LANG/
\getchunk{Clojure Copyright}
*/
/* rich Dec 6, 2007 */
package clojure.lang;
public class StringSeq extends ASeq implements IndexedSeq {
public final CharSequence s;
public final int i;
static public StringSeq create(CharSequence s){
if(s.length() == 0)
return null;
return new StringSeq(null, s, 0);
}
StringSeq(IPersistentMap meta, CharSequence s, int i){
super(meta);
this.s = s;
this.i = i;
}
public Obj withMeta(IPersistentMap meta){
if(meta == meta())
return this;
return new StringSeq(meta, s, i);
}
public Object first(){
return Character.valueOf(s.charAt(i));
}
public ISeq next(){
if(i + 1 < s.length())
return new StringSeq(_meta, s, i + 1);
return null;
}
public int index(){
return i;
}
public int count(){
return s.length() - i;
}
}
———-
9.104. SYMBOL.JAVA 1143
9.104 Symbol.java
(AFn[509])(IObj[800])(Comparable[1723])(Named[861])(Serializable [1723])
— Symbol.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Mar 25, 2006 11:42:47 AM */
package clojure.lang;
import java.io.Serializable;
import java.io.ObjectStreamException;
public class Symbol
extends AFn implements IObj, Comparable, Named, Serializa ble{
\getchunk{Symbol private data}
\getchunk{Symbol method toString}
public String getNamespace(){
return ns;
}
public String getName(){
return name;
}
// the create thunks preserve binary compatibility with cod e compiled
// against earlier version of Clojure and can be removed (at s ome point).
static public Symbol create(String ns, String name) {
return Symbol.intern(ns, name);
}
static public Symbol create(String nsname) {
return Symbol.intern(nsname);
}
\getchunk{Symbol intern method 2}
\getchunk{Symbol intern method}
private Symbol(String ns_interned, String name_interned ){
this.name = name_interned;
this.ns = ns_interned;
this.hash = Util.hashCombine(name.hashCode(), Util.has h(ns));
this._meta = null;
1144 CHAPTER 9. JVM/CLOJURE/LANG/
}
\getchunk{Symbol method equals}
public int hashCode(){
return hash;
}
public IObj withMeta(IPersistentMap meta){
return new Symbol(meta, ns, name);
}
private Symbol(IPersistentMap meta, String ns, String nam e){
this.name = name;
this.ns = ns;
this._meta = meta;
this.hash = Util.hashCombine(name.hashCode(), Util.has h(ns));
}
public int compareTo(Object o){
Symbol s = (Symbol) o;
if(this.equals(o))
return 0;
if(this.ns == null && s.ns != null)
return -1;
if(this.ns != null)
{
if(s.ns == null)
return 1;
int nsc = this.ns.compareTo(s.ns);
if(nsc != 0)
return nsc;
}
return this.name.compareTo(s.name);
}
private Object readResolve() throws ObjectStreamExcepti on{
return intern(ns, name);
}
public Object invoke(Object obj) throws Exception{
return RT.get(obj, this);
}
public Object invoke(Object obj, Object notFound)
throws Exception{
return RT.get(obj, this, notFound);
}
public IPersistentMap meta(){
9.105. TRANSACTIONALHASHMAP.JAVA 1145
return _meta;
}
}
———-
9.105 TransactionalHashMap.java
(AbstractMap [1723]) (ConcurrentMap [1723])
— TransactionalHashMap.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 31, 2008 */
package clojure.lang;
import java.util.concurrent.ConcurrentMap;
import java.util.*;
public class TransactionalHashMap<K, V>
extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
final Ref[] bins;
IPersistentMap mapAt(int bin){
return (IPersistentMap) bins[bin].deref();
}
final int binFor(Object k){
//spread hashes, a la Cliff Click
int h = k.hashCode();
h ^= (h >>> 20) ^ (h >>> 12);
h ^= (h >>> 7) ^ (h >>> 4);
return h % bins.length;
// return k.hashCode() % bins.length;
}
Entry entryAt(Object k){
return mapAt(binFor(k)).entryAt(k);
}
public TransactionalHashMap() throws Exception{
this(421);
}
public TransactionalHashMap(int nBins) throws Exception {
1146 CHAPTER 9. JVM/CLOJURE/LANG/
bins = new Ref[nBins];
for(int i = 0; i < nBins; i++)
bins[i] = new Ref(PersistentHashMap.EMPTY);
}
public TransactionalHashMap(Map<? extends K, ? extends V> m)
throws Exception{
this(m.size());
putAll(m);
}
public int size(){
int n = 0;
for(int i = 0; i < bins.length; i++)
{
n += mapAt(i).count();
}
return n;
}
public boolean isEmpty(){
return size() == 0;
}
public boolean containsKey(Object k){
return entryAt(k) != null;
}
public V get(Object k){
Entry e = entryAt(k);
if(e != null)
return (V) e.getValue();
return null;
}
public V put(K k, V v){
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Object ret = map.valAt(k);
r.set(map.assoc(k, v));
return (V) ret;
}
public V remove(Object k){
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Object ret = map.valAt(k);
//checked exceptions are a bad idea, especially in an interf ace
try
{
9.105. TRANSACTIONALHASHMAP.JAVA 1147
r.set(map.without(k));
}
catch(Exception e)
{
throw new RuntimeException(e);
}
return (V) ret;
}
public void putAll(Map<? extends K, ? extends V> map){
for(Iterator i = map.entrySet().iterator(); i.hasNext() ;)
{
Entry<K, V> e = (Entry) i.next();
put(e.getKey(), e.getValue());
}
}
public void clear(){
for(int i = 0; i < bins.length; i++)
{
Ref r = bins[i];
IPersistentMap map = (IPersistentMap) r.deref();
if(map.count() > 0)
{
r.set(PersistentHashMap.EMPTY);
}
}
}
public Set<Entry<K, V>> entrySet(){
final ArrayList<Map.Entry<K, V>> entries =
new ArrayList(bins.length);
for(int i = 0; i < bins.length; i++)
{
IPersistentMap map = mapAt(i);
if(map.count() > 0)
entries.addAll((Collection) RT.seq(map));
}
return new AbstractSet<Entry<K, V>>(){
public Iterator iterator(){
return Collections.unmodifiableList(entries).iterato r();
}
public int size(){
return entries.size();
}
};
}
public V putIfAbsent(K k, V v){
1148 CHAPTER 9. JVM/CLOJURE/LANG/
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Entry e = map.entryAt(k);
if(e == null)
{
r.set(map.assoc(k, v));
return null;
}
else
return (V) e.getValue();
}
public boolean remove(Object k, Object v){
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Entry e = map.entryAt(k);
if(e != null && e.getValue().equals(v))
{
//checked exceptions are a bad idea, especially
//in an interface
try
{
r.set(map.without(k));
}
catch(Exception ex)
{
throw new RuntimeException(ex);
}
return true;
}
return false;
}
public boolean replace(K k, V oldv, V newv){
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Entry e = map.entryAt(k);
if(e != null && e.getValue().equals(oldv))
{
r.set(map.assoc(k, newv));
return true;
}
return false;
}
public V replace(K k, V v){
Ref r = bins[binFor(k)];
IPersistentMap map = (IPersistentMap) r.deref();
Entry e = map.entryAt(k);
if(e != null)
9.106. UTIL.JAVA 1149
{
r.set(map.assoc(k, v));
return (V) e.getValue();
}
return null;
}
}
———-
9.106 Util.java
— Util.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Apr 19, 2008 */
package clojure.lang;
import java.math.BigInteger;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.ref.SoftReference;
import java.lang.ref.ReferenceQueue;
public class Util{
static public boolean equiv(Object k1, Object k2){
if(k1 == k2)
return true;
if(k1 != null)
{
if(k1 instanceof Number && k2 instanceof Number)
return Numbers.equal((Number)k1, (Number)k2);
else if(k1 instanceof IPersistentCollection ||
k2 instanceof IPersistentCollection)
return pcequiv(k1,k2);
return k1.equals(k2);
}
return false;
}
static public boolean equiv(long k1, long k2){
return k1 == k2;
}
1150 CHAPTER 9. JVM/CLOJURE/LANG/
static public boolean equiv(Object k1, long k2){
return equiv(k1, (Object)k2);
}
static public boolean equiv(long k1, Object k2){
return equiv((Object)k1, k2);
}
static public boolean equiv(double k1, double k2){
return k1 == k2;
}
static public boolean equiv(Object k1, double k2){
return equiv(k1, (Object)k2);
}
static public boolean equiv(double k1, Object k2){
return equiv((Object)k1, k2);
}
static public boolean pcequiv(Object k1, Object k2){
if(k1 instanceof IPersistentCollection)
return ((IPersistentCollection)k1).equiv(k2);
return ((IPersistentCollection)k2).equiv(k1);
}
static public boolean equals(Object k1, Object k2){
if(k1 == k2)
return true;
return k1 != null && k1.equals(k2);
}
static public boolean identical(Object k1, Object k2){
return k1 == k2;
}
static public Class classOf(Object x){
if(x != null)
return x.getClass();
return null;
}
static public int compare(Object k1, Object k2){
if(k1 == k2)
return 0;
if(k1 != null)
{
if(k2 == null)
return 1;
9.106. UTIL.JAVA 1151
if(k1 instanceof Number)
return Numbers.compare((Number) k1, (Number) k2);
return ((Comparable) k1).compareTo(k2);
}
return -1;
}
static public int hash(Object o){
if(o == null)
return 0;
return o.hashCode();
}
static public int hashCombine(int seed, int hash){
//a la boost
seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2);
return seed;
}
static public boolean isPrimitive(Class c){
return c != null && c.isPrimitive() && !(c == Void.TYPE);
}
static public boolean isInteger(Object x){
return x instanceof Integer
|| x instanceof Long
|| x instanceof BigInt
|| x instanceof BigInteger;
}
static public Object ret1(Object ret, Object nil){
return ret;
}
static public ISeq ret1(ISeq ret, Object nil){
return ret;
}
static public <K,V> void
clearCache(ReferenceQueue rq,
ConcurrentHashMap<K, SoftReference<V>> cache){
//cleanup any dead entries
if(rq.poll() != null)
{
while(rq.poll() != null)
;
for(Map.Entry<K, SoftReference<V>> e : cache.entrySet() )
{
if(e.getValue().get() == null)
cache.remove(e.getKey(), e.getValue());
1152 CHAPTER 9. JVM/CLOJURE/LANG/
}
}
}
}
———-
9.107 Var.java
(ARef [553]) (IFn [774]) (IRef [805]) (Settable [1140])
— Var.java —
/*
\getchunk{Clojure Copyright}
*/
/* rich Jul 31, 2007 */
package clojure.lang;
import java.util.concurrent.atomic.AtomicBoolean;
public final class Var extends ARef implements IFn, IRef, Se ttable{
static class TBox{
volatile Object val;
final Thread thread;
public TBox(Thread t, Object val){
this.thread = t;
this.val = val;
}
}
static public class Unbound extends AFn{
final public Var v;
public Unbound(Var v){
this.v = v;
}
public String toString(){
return "Unbound: " + v;
}
public Object throwArity(int n){
throw new IllegalStateException(
9.107. VAR.JAVA 1153
"Attempting to call unbound fn: " + v);
}
}
static class Frame{
//Var->TBox
Associative bindings;
//Var->val
// Associative frameBindings;
Frame prev;
public Frame(){
this(PersistentHashMap.EMPTY, null);
}
public Frame(Associative bindings, Frame prev){
// this.frameBindings = frameBindings;
this.bindings = bindings;
this.prev = prev;
}
}
static final ThreadLocal<Frame> dvals = new ThreadLocal<F rame>(){
protected Frame initialValue(){
return new Frame();
}
};
static public volatile int rev = 0;
static Keyword privateKey = Keyword.intern(null, "privat e");
static IPersistentMap privateMeta =
new PersistentArrayMap(new Object[]{privateKey, Boolea n.TRUE});
static Keyword macroKey = Keyword.intern(null, "macro");
static Keyword nameKey = Keyword.intern(null, "name");
static Keyword nsKey = Keyword.intern(null, "ns");
//static Keyword tagKey = Keyword.intern(null, "tag");
private volatile Object root;
volatile boolean dynamic = false;
transient final AtomicBoolean threadBound;
public final Symbol sym;
public final Namespace ns;
//IPersistentMap _meta;
public static Object getThreadBindingFrame(){
1154 CHAPTER 9. JVM/CLOJURE/LANG/
Frame f = dvals.get();
if(f != null)
return f;
return new Frame();
}
public static void resetThreadBindingFrame(Object frame ){
dvals.set((Frame) frame);
}
public Var setDynamic(){
this.dynamic = true;
return this;
}
public Var setDynamic(boolean b){
this.dynamic = b;
return this;
}
public final boolean isDynamic(){
return dynamic;
}
public static Var intern(Namespace ns, Symbol sym, Object r oot){
return intern(ns, sym, root, true);
}
public static Var intern(Namespace ns,
Symbol sym,
Object root,
boolean replaceRoot){
Var dvout = ns.intern(sym);
if(!dvout.hasRoot() || replaceRoot)
dvout.bindRoot(root);
return dvout;
}
public String toString(){
if(ns != null)
return "#’" + ns.name + "/" + sym;
return "#<Var: " + (sym != null
? sym.toString()
: "--unnamed--") + ">";
}
public static Var find(Symbol nsQualifiedSym){
if(nsQualifiedSym.ns == null)
throw new IllegalArgumentException(
9.107. VAR.JAVA 1155
"Symbol must be namespace-qualified");
Namespace ns = Namespace.find(Symbol.intern(nsQualifie dSym.ns));
if(ns == null)
throw new IllegalArgumentException(
"No such namespace: " + nsQualifiedSym.ns);
return ns.findInternedVar(Symbol.intern(nsQualifiedS ym.name));
}
public static Var intern(Symbol nsName, Symbol sym){
Namespace ns = Namespace.findOrCreate(nsName);
return intern(ns, sym);
}
public static Var internPrivate(String nsName, String sym ){
Namespace ns = Namespace.findOrCreate(Symbol.intern(ns Name));
Var ret = intern(ns, Symbol.intern(sym));
ret.setMeta(privateMeta);
return ret;
}
public static Var intern(Namespace ns, Symbol sym){
return ns.intern(sym);
}
public static Var create(){
return new Var(null, null);
}
public static Var create(Object root){
return new Var(null, null, root);
}
Var(Namespace ns, Symbol sym){
this.ns = ns;
this.sym = sym;
this.threadBound = new AtomicBoolean(false);
this.root = new Unbound(this);
setMeta(PersistentHashMap.EMPTY);
}
Var(Namespace ns, Symbol sym, Object root){
this(ns, sym);
this.root = root;
++rev;
}
public boolean isBound(){
return
hasRoot() ||
1156 CHAPTER 9. JVM/CLOJURE/LANG/
(threadBound.get() && dvals.get().bindings.containsKe y(this));
}
final public Object get(){
if(!threadBound.get())
return root;
return deref();
}
final public Object deref(){
TBox b = getThreadBinding();
if(b != null)
return b.val;
return root;
}
public void setValidator(IFn vf){
if(hasRoot())
validate(vf, root);
validator = vf;
}
public Object alter(IFn fn, ISeq args) throws Exception{
set(fn.applyTo(RT.cons(deref(), args)));
return this;
}
public Object set(Object val){
validate(getValidator(), val);
TBox b = getThreadBinding();
if(b != null)
{
if(Thread.currentThread() != b.thread)
throw new IllegalStateException(String.format(
"Can’t set!: %s from non-binding thread", sym));
return (b.val = val);
}
throw new IllegalStateException(String.format(
"Can’t change/establish root binding of: %s with set", sym) );
}
public Object doSet(Object val) throws Exception {
return set(val);
}
public Object doReset(Object val) throws Exception {
bindRoot(val);
return val;
}
9.107. VAR.JAVA 1157
public void setMeta(IPersistentMap m) {
//ensure these basis keys
resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns));
}
public void setMacro() {
try
{
alterMeta(assoc, RT.list(macroKey, RT.T));
}
catch (Exception e)
{
throw new RuntimeException(e);
}
}
public boolean isMacro(){
return RT.booleanCast(meta().valAt(macroKey));
}
//public void setExported(boolean state){
// _meta = _meta.assoc(privateKey, state);
//}
public boolean isPublic(){
return !RT.booleanCast(meta().valAt(privateKey));
}
final public Object getRawRoot(){
return root;
}
public Object getTag(){
return meta().valAt(RT.TAG_KEY);
}
public void setTag(Symbol tag) {
try
{
alterMeta(assoc, RT.list(RT.TAG_KEY, tag));
}
catch (Exception e)
{
throw new RuntimeException(e);
}
}
final public boolean hasRoot(){
return !(root instanceof Unbound);
}
1158 CHAPTER 9. JVM/CLOJURE/LANG/
//binding root always clears macro flag
synchronized public void bindRoot(Object root){
validate(getValidator(), root);
Object oldroot = this.root;
this.root = root;
++rev;
try
{
alterMeta(dissoc, RT.list(macroKey));
}
catch (Exception e)
{
throw new RuntimeException(e);
}
notifyWatches(oldroot,this.root);
}
synchronized void swapRoot(Object root){
validate(getValidator(), root);
Object oldroot = this.root;
this.root = root;
++rev;
notifyWatches(oldroot,root);
}
synchronized public void unbindRoot(){
this.root = new Unbound(this);
++rev;
}
synchronized public void commuteRoot(IFn fn) throws Excep tion{
Object newRoot = fn.invoke(root);
validate(getValidator(), newRoot);
Object oldroot = root;
this.root = newRoot;
++rev;
notifyWatches(oldroot,newRoot);
}
synchronized public Object alterRoot(IFn fn, ISeq args)
throws Exception{
Object newRoot = fn.applyTo(RT.cons(root, args));
validate(getValidator(), newRoot);
Object oldroot = root;
this.root = newRoot;
++rev;
notifyWatches(oldroot,newRoot);
return newRoot;
}
9.107. VAR.JAVA 1159
public static void pushThreadBindings(Associative bindi ngs){
Frame f = dvals.get();
Associative bmap = f.bindings;
for(ISeq bs = bindings.seq(); bs != null; bs = bs.next())
{
IMapEntry e = (IMapEntry) bs.first();
Var v = (Var) e.key();
if(!v.dynamic)
throw new IllegalStateException(String.format(
"Can’t dynamically bind non-dynamic var: %s/%s",
v.ns, v.sym));
v.validate(v.getValidator(), e.val());
v.threadBound.set(true);
bmap =
bmap.assoc(v, new TBox(Thread.currentThread(), e.val() ));
}
dvals.set(new Frame(bmap, f));
}
public static void popThreadBindings(){
Frame f = dvals.get();
if(f.prev == null)
throw new IllegalStateException("Pop without matching pu sh");
dvals.set(f.prev);
}
public static Associative getThreadBindings(){
Frame f = dvals.get();
IPersistentMap ret = PersistentHashMap.EMPTY;
for(ISeq bs = f.bindings.seq(); bs != null; bs = bs.next())
{
IMapEntry e = (IMapEntry) bs.first();
Var v = (Var) e.key();
TBox b = (TBox) e.val();
ret = ret.assoc(v, b.val);
}
return ret;
}
public final TBox getThreadBinding(){
if(threadBound.get())
{
IMapEntry e = dvals.get().bindings.entryAt(this);
if(e != null)
return (TBox) e.val();
}
return null;
}
1160 CHAPTER 9. JVM/CLOJURE/LANG/
final public IFn fn(){
return (IFn) deref();
}
public Object call() throws Exception{
return invoke();
}
public void run(){
try
{
invoke();
}
catch(Exception e)
{
throw new RuntimeException(e);
}
}
public Object invoke()
throws Exception{
return fn().invoke();
}
public Object invoke(Object arg1)
throws Exception{
return fn().invoke(arg1);
}
public Object invoke(Object arg1, Object arg2)
throws Exception{
return fn().invoke(arg1, arg2);
}
public Object invoke(Object arg1, Object arg2, Object arg3 )
throws Exception{
return fn().invoke(arg1, arg2, arg3);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5);
}
9.107. VAR.JAVA 1161
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8)
throws Exception{
return fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg 7, arg8);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
1162 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16)
throws Exception{
return
9.107. VAR.JAVA 1163
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
1164 CHAPTER 9. JVM/CLOJURE/LANG/
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20);
}
public Object invoke(Object arg1, Object arg2, Object arg3 ,
Object arg4, Object arg5, Object arg6,
Object arg7, Object arg8, Object arg9,
Object arg10, Object arg11, Object arg12,
Object arg13, Object arg14, Object arg15,
Object arg16, Object arg17, Object arg18,
Object arg19, Object arg20, Object... args)
throws Exception{
return
fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 , arg9,
arg10, arg11, arg12, arg13, arg14, arg15,
arg16, arg17, arg18, arg19, arg20, args);
}
public Object applyTo(ISeq arglist) throws Exception{
return AFn.applyToHelper(this, arglist);
}
static IFn assoc = new AFn(){
@Override
public Object invoke(Object m, Object k, Object v) throws Ex ception {
return RT.assoc(m, k, v);
}
};
static IFn dissoc = new AFn() {
@Override
public Object invoke(Object c, Object k) throws Exception {
return RT.dissoc(c, k);
}
};
}
———-
9.108 XMLHandler.java
(DefaultHandler [1723])
— XMLHandler.java —
9.108. XMLHANDLER.JAVA 1165
/*
\getchunk{Clojure Copyright}
*/
/* rich Dec 17, 2007 */
package clojure.lang;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
public class XMLHandler extends DefaultHandler{
ContentHandler h;
public XMLHandler(ContentHandler h){
this.h = h;
}
public void setDocumentLocator(Locator locator){
h.setDocumentLocator(locator);
}
public void startDocument() throws SAXException{
h.startDocument();
}
public void endDocument() throws SAXException{
h.endDocument();
}
public void startPrefixMapping(String prefix, String uri )
throws SAXException{
h.startPrefixMapping(prefix, uri);
}
public void endPrefixMapping(String prefix)
throws SAXException{
h.endPrefixMapping(prefix);
}
public void startElement(String uri,
String localName,
String qName,
Attributes atts)
throws SAXException{
h.startElement(uri, localName, qName, atts);
}
1166 CHAPTER 9. JVM/CLOJURE/LANG/
public void endElement(String uri, String localName, Stri ng qName)
throws SAXException{
h.endElement(uri, localName, qName);
}
public void characters(char ch[], int start, int length)
throws SAXException{
h.characters(ch, start, length);
}
public void ignorableWhitespace(char ch[], int start, int length)
throws SAXException{
h.ignorableWhitespace(ch, start, length);
}
public void processingInstruction(String target, String data)
throws SAXException{
h.processingInstruction(target, data);
}
public void skippedEntity(String name) throws SAXExcepti on{
h.skippedEntity(name);
}
/*
public static void main(String[] args){
try
{
ContentHandler dummy = new DefaultHandler();
SAXParserFactory f = SAXParserFactory.newInstance();
//f.setNamespaceAware(true);
SAXParser p = f.newSAXParser();
p.parse("http://arstechnica.com/journals.rssx",
new XMLHandler(dummy));
}
catch(Exception e)
{
e.printStackTrace();
}
}
//*/
}
———-
Chapter 10
jvm/clojure
10.1 main.java
— main.java —
/*
\getchunk{Clojure Copyright}
*/
package clojure;
import clojure.lang.Symbol;
import clojure.lang.Var;
import clojure.lang.RT;
public class main{
final static private Symbol CLOJURE_MAIN =
Symbol.intern("clojure.main");
final static private Var REQUIRE =
RT.var("clojure.core", "require");
final static private Var LEGACY_REPL =
RT.var("clojure.main", "legacy-repl");
final static private Var LEGACY_SCRIPT =
RT.var("clojure.main", "legacy-script");
final static private Var MAIN =
RT.var("clojure.main", "main");
public static void legacy_repl(String[] args) throws Exce ption{
REQUIRE.invoke(CLOJURE_MAIN);
LEGACY_REPL.invoke(RT.seq(args));
}
1167
1168 CHAPTER 10. JVM/CLOJURE
public static void legacy_script(String[] args) throws Ex ception{
REQUIRE.invoke(CLOJURE_MAIN);
LEGACY_SCRIPT.invoke(RT.seq(args));
}
public static void main(String[] args) throws Exception{
REQUIRE.invoke(CLOJURE_MAIN);
MAIN.applyTo(RT.seq(args));
}
}
———-
Chapter 11
clj/clojure/
11.1 core.clj
— core.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "The core Clojure language."
:author "Rich Hickey"}
clojure.core)
(def unquote)
(def unquote-splicing)
(def
^{:arglists ’([& items])
:doc "Creates a new list containing the items."
:added "1.0"}
list (. clojure.lang.PersistentList creator))
(def
^{:arglists ’([x seq])
:doc "Returns a new seq where x is the first element and seq is
the rest."
:added "1.0"
:static true}
cons (fn* ^:static cons [x seq] (. clojure.lang.RT (cons x se q))))
;during bootstrap we don’t have destructuring let, loop or f n,
;will redefine later
(def
1169
1170 CHAPTER 11. CLJ/CLOJURE/
^{:macro true
:added "1.0"}
let (fn* let [&form &env & decl] (cons ’let* decl)))
(def
^{:macro true
:added "1.0"}
loop (fn* loop [&form &env & decl] (cons ’loop* decl)))
(def
^{:macro true
:added "1.0"}
fn (fn* fn [&form &env & decl]
(.withMeta ^clojure.lang.IObj (cons ’fn* decl)
(.meta ^clojure.lang.IMeta &form))))
(def
^{:arglists ’([coll])
:doc "Returns the first item in the collection. Calls seq on i ts
argument. If coll is nil, returns nil."
:added "1.0"
:static true}
first (fn ^:static first [coll] (. clojure.lang.RT (first c oll))))
(def
^{:arglists ’([coll])
:tag clojure.lang.ISeq
:doc "Returns a seq of the items after the first. Calls seq on i ts
argument. If there are no more items, returns nil."
:added "1.0"
:static true}
next (fn ^:static next [x] (. clojure.lang.RT (next x))))
(def
^{:arglists ’([coll])
:tag clojure.lang.ISeq
:doc "Returns a possibly empty seq of the items after the firs t.
Calls seq on its argument."
:added "1.0"
:static true}
rest (fn ^:static rest [x] (. clojure.lang.RT (more x))))
(def
^{:arglists ’([coll x] [coll x & xs])
:doc "conj[oin]. Returns a new collection with the xs
’added’. (conj nil item) returns (item). The ’addition’ may
happen at different ’places’ depending on the concrete type ."
:added "1.0"
:static true}
conj (fn ^:static conj
11.1. CORE.CLJ 1171
([coll x] (. clojure.lang.RT (conj coll x)))
([coll x & xs]
(if xs
(recur (conj coll x) (first xs) (next xs))
(conj coll x)))))
(def
^{:doc "Same as (first (next x))"
:arglists ’([x])
:added "1.0"
:static true}
second (fn ^:static second [x] (first (next x))))
(def
^{:doc "Same as (first (first x))"
:arglists ’([x])
:added "1.0"
:static true}
ffirst (fn ^:static ffirst [x] (first (first x))))
(def
^{:doc "Same as (next (first x))"
:arglists ’([x])
:added "1.0"
:static true}
nfirst (fn ^:static nfirst [x] (next (first x))))
(def
^{:doc "Same as (first (next x))"
:arglists ’([x])
:added "1.0"
:static true}
fnext (fn ^:static fnext [x] (first (next x))))
(def
^{:doc "Same as (next (next x))"
:arglists ’([x])
:added "1.0"
:static true}
nnext (fn ^:static nnext [x] (next (next x))))
(def
^{:arglists ’(^clojure.lang.ISeq [coll])
:doc "Returns a seq on the collection. If the collection is
empty, returns nil. (seq nil) returns nil. seq also works on
Strings, native Java arrays (of reference types) and any obj ects
that implement Iterable."
:tag clojure.lang.ISeq
:added "1.0"
:static true}
1172 CHAPTER 11. CLJ/CLOJURE/
seq (fn ^:static seq ^clojure.lang.ISeq [coll]
(. clojure.lang.RT (seq coll))))
(def
^{:arglists ’([^Class c x])
:doc "Evaluates x and tests if it is an instance of the class
c. Returns true or false"
:added "1.0"}
instance? (fn instance? [^Class c x] (. c (isInstance x))))
(def
^{:arglists ’([x])
:doc "Return true if x implements ISeq"
:added "1.0"
:static true}
seq? (fn ^:static seq? [x] (instance? clojure.lang.ISeq x) ))
(def
^{:arglists ’([x])
:doc "Return true if x is a Character"
:added "1.0"
:static true}
char? (fn ^:static char? [x] (instance? Character x)))
(def
^{:arglists ’([x])
:doc "Return true if x is a String"
:added "1.0"
:static true}
string? (fn ^:static string? [x] (instance? String x)))
(def
^{:arglists ’([x])
:doc "Return true if x implements IPersistentMap"
:added "1.0"
:static true}
map? (fn ^:static map? [x] (instance? clojure.lang.IPersi stentMap x)))
(def
^{:arglists ’([x])
:doc "Return true if x implements IPersistentVector"
:added "1.0"
:static true}
vector? (fn ^:static vector? [x]
(instance? clojure.lang.IPersistentVector x)))
(def
^{:arglists ’([map key val] [map key val & kvs])
:doc "assoc[iate]. When applied to a map, returns a new map of the
same (hashed/sorted) type, that contains the mapping of key (s) to
11.1. CORE.CLJ 1173
val(s). When applied to a vector, returns a new vector that
contains val at index. Note - index must be <= (count vector). "
:added "1.0"
:static true}
assoc
(fn ^:static assoc
([map key val] (. clojure.lang.RT (assoc map key val)))
([map key val & kvs]
(let [ret (assoc map key val)]
(if kvs
(recur ret (first kvs) (second kvs) (nnext kvs))
ret)))))
;;;;;;;;;;;;;;;;; metadata ;;;;;;;;;;;;;;;;;;;;;;;;;; ;
(def
^{:arglists ’([obj])
:doc "Returns the metadata of obj, returns nil if there is no
metadata."
:added "1.0"
:static true}
meta (fn ^:static meta [x]
(if (instance? clojure.lang.IMeta x)
(. ^clojure.lang.IMeta x (meta)))))
(def
^{:arglists ’([^clojure.lang.IObj obj m])
:doc "Returns an object of the same type and value as obj, with
map m as its metadata."
:added "1.0"
:static true}
with-meta (fn ^:static with-meta [^clojure.lang.IObj x m]
(. x (withMeta m))))
(def ^{:private true :dynamic true}
assert-valid-fdecl (fn [fdecl]))
(def
^{:private true}
sigs
(fn [fdecl]
(assert-valid-fdecl fdecl)
(let [asig
(fn [fdecl]
(let [arglist (first fdecl)
;elide implicit macro args
arglist
(if
(clojure.lang.Util/equals ’&form (first arglist))
(clojure.lang.RT/subvec arglist 2
(clojure.lang.RT/count arglist))
1174 CHAPTER 11. CLJ/CLOJURE/
arglist)
body (next fdecl)]
(if (map? (first body))
(if (next body)
(with-meta arglist
(conj
(if (meta arglist) (meta arglist) {})
(first body)))
arglist)
arglist)))]
(if (seq? (first fdecl))
(loop [ret [] fdecls fdecl]
(if fdecls
(recur (conj ret (asig (first fdecls))) (next fdecls))
(seq ret)))
(list (asig fdecl))))))
(def
^{:arglists ’([coll])
:doc "Return the last item in coll, in linear time"
:added "1.0"
:static true}
last (fn ^:static last [s]
(if (next s)
(recur (next s))
(first s))))
(def
^{:arglists ’([coll])
:doc "Return a seq of all but the last item in coll, in linear ti me"
:added "1.0"
:static true}
butlast (fn ^:static butlast [s]
(loop [ret [] s s]
(if (next s)
(recur (conj ret (first s)) (next s))
(seq ret)))))
(def
^{:doc "Same as (def name (fn [params* ] exprs*)) or (def
name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
to the var metadata"
:arglists ’([name doc-string? attr-map? [params*] body]
[name doc-string? attr-map?
([params*] body)+ attr-map?])
:added "1.0"}
defn (fn defn [&form &env name & fdecl]
(let [m (if (string? (first fdecl))
11.1. CORE.CLJ 1175
{:doc (first fdecl)}
{})
fdecl (if (string? (first fdecl))
(next fdecl)
fdecl)
m (if (map? (first fdecl))
(conj m (first fdecl))
m)
fdecl (if (map? (first fdecl))
(next fdecl)
fdecl)
fdecl (if (vector? (first fdecl))
(list fdecl)
fdecl)
m (if (map? (last fdecl))
(conj m (last fdecl))
m)
fdecl (if (map? (last fdecl))
(butlast fdecl)
fdecl)
m (conj {:arglists (list ’quote (sigs fdecl))} m)
m (let [inline (:inline m)
ifn (first inline)
iname (second inline)]
;; same as:
;; (if (and (= ’fn ifn) (not (symbol? iname))) ...)
(if
(if (clojure.lang.Util/equiv ’fn ifn)
(if (instance? clojure.lang.Symbol iname)
false true))
;; inserts the same fn name to the inline fn
;; if it does not have one
(assoc m :inline
(cons ifn
(cons (clojure.lang.Symbol/intern
(.concat
(.getName ^clojure.lang.Symbol name)
"__inliner"))
(next inline))))
m))
m (conj (if (meta name) (meta name) {}) m)]
(list ’def (with-meta name m)
;;todo - restore propagation of fn name
;;must figure out how to convey primitive hints
;;to self calls first
(cons ‘fn fdecl) ))))
(. (var defn) (setMacro))
(defn cast
1176 CHAPTER 11. CLJ/CLOJURE/
"Throws a ClassCastException if x is not a c, else returns x."
{:added "1.0"
:static true}
[^Class c x]
(. c (cast x)))
(defn to-array
"Returns an array of Objects containing the contents of coll , which
can be any Collection. Maps to java.util.Collection.toArr ay()."
{:tag "[Ljava.lang.Object;"
:added "1.0"
:static true}
[coll] (. clojure.lang.RT (toArray coll)))
(defn vector
"Creates a new vector containing the args."
{:added "1.0"
:static true}
([] [])
([a] [a])
([a b] [a b])
([a b c] [a b c])
([a b c d] [a b c d])
([a b c d & args]
(. clojure.lang.LazilyPersistentVector
(create (cons a (cons b (cons c (cons d args))))))))
(defn vec
"Creates a new vector containing the contents of coll."
{:added "1.0"
:static true}
([coll]
(if (instance? java.util.Collection coll)
(clojure.lang.LazilyPersistentVector/create coll)
(. clojure.lang.LazilyPersistentVector
(createOwning (to-array coll))))))
(defn hash-map
"keyval => key val
Returns a new hash map with supplied mappings."
{:added "1.0"
:static true}
([] {})
([& keyvals]
(. clojure.lang.PersistentHashMap (createWithCheck key vals))))
(defn hash-set
"Returns a new hash set with supplied keys."
{:added "1.0"
:static true}
11.1. CORE.CLJ 1177
([] #{})
([& keys]
(clojure.lang.PersistentHashSet/createWithCheck keys )))
(defn sorted-map
"keyval => key val
Returns a new sorted map with supplied mappings."
{:added "1.0"
:static true}
([& keyvals]
(clojure.lang.PersistentTreeMap/create keyvals)))
(defn sorted-map-by
"keyval => key val
Returns a new sorted map with supplied mappings,
using the supplied comparator."
{:added "1.0"
:static true}
([comparator & keyvals]
(clojure.lang.PersistentTreeMap/create comparator key vals)))
(defn sorted-set
"Returns a new sorted set with supplied keys."
{:added "1.0"
:static true}
([& keys]
(clojure.lang.PersistentTreeSet/create keys)))
(defn sorted-set-by
"Returns a new sorted set with supplied keys,
using the supplied comparator."
{:added "1.1"
:static true}
([comparator & keys]
(clojure.lang.PersistentTreeSet/create comparator key s)))
;;;;;;;;;;;;;;;;;;;;
(defn nil?
"Returns true if x is nil, false otherwise."
{:tag Boolean
:added "1.0"
:static true
:inline (fn [x] (list ’clojure.lang.Util/identical x nil) )}
[x] (clojure.lang.Util/identical x nil))
(def
^{:doc "Like defn, but the resulting function name is declar ed as a
macro and will be used as a macro by the compiler when it is
1178 CHAPTER 11. CLJ/CLOJURE/
called."
:arglists
’([name doc-string? attr-map? [params*] body]
[name doc-string? attr-map? ([params*] body)+ attr-map?] )
:added "1.0"}
defmacro (fn [&form &env
name & args]
(let [prefix (loop [p (list name) args args]
(let [f (first args)]
(if (string? f)
(recur (cons f p) (next args))
(if (map? f)
(recur (cons f p) (next args))
p))))
fdecl (loop [fd args]
(if (string? (first fd))
(recur (next fd))
(if (map? (first fd))
(recur (next fd))
fd)))
fdecl (if (vector? (first fdecl))
(list fdecl)
fdecl)
add-implicit-args (fn [fd]
(let [args (first fd)]
(cons
(vec (cons ’&form (cons ’&env args)))
(next fd))))
add-args (fn [acc ds]
(if (nil? ds)
acc
(let [d (first ds)]
(if (map? d)
(conj acc d)
(recur
(conj acc (add-implicit-args d))
(next ds))))))
fdecl (seq (add-args [] fdecl))
decl (loop [p prefix d fdecl]
(if p
(recur (next p) (cons (first p) d))
d))]
(list ’do
(cons ‘defn decl)
(list ’. (list ’var name) ’(setMacro))
(list ’var name)))))
(. (var defmacro) (setMacro))
11.1. CORE.CLJ 1179
(defmacro when
"Evaluates test. If logical true, evaluates body in an impli cit do."
{:added "1.0"}
[test & body]
(list ’if test (cons ’do body)))
(defmacro when-not
"Evaluates test. If logical false, evaluates body in an impl icit do."
{:added "1.0"}
[test & body]
(list ’if test nil (cons ’do body)))
(defn false?
"Returns true if x is the value false, false otherwise."
{:tag Boolean,
:added "1.0"
:static true}
[x] (clojure.lang.Util/identical x false))
(defn true?
"Returns true if x is the value true, false otherwise."
{:tag Boolean,
:added "1.0"
:static true}
[x] (clojure.lang.Util/identical x true))
(defn not
"Returns true if x is logical false, false otherwise."
{:tag Boolean
:added "1.0"
:static true}
[x] (if x false true))
(defn str
"With no args, returns the empty string. With one arg x, retur ns
x.toString(). (str nil) returns the empty string. With more than
one arg, returns the concatenation of the str values of the ar gs."
{:tag String
:added "1.0"
:static true}
(^String [] "")
(^String [^Object x]
(if (nil? x) "" (. x (toString))))
(^String [x & ys]
((fn [^StringBuilder sb more]
(if more
(recur (. sb (append (str (first more)))) (next more))
(str sb)))
(new StringBuilder (str x)) ys)))
1180 CHAPTER 11. CLJ/CLOJURE/
(defn symbol?
"Return true if x is a Symbol"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.Symbol x))
(defn keyword?
"Return true if x is a Keyword"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.Keyword x))
(defn symbol
"Returns a Symbol with the given namespace and name."
{:tag clojure.lang.Symbol
:added "1.0"
:static true}
([name] (if (symbol? name) name (clojure.lang.Symbol/int ern name)))
([ns name] (clojure.lang.Symbol/intern ns name)))
(defn gensym
"Returns a new symbol with a unique name. If a prefix string is
supplied, the name is prefix# where # is some unique number. I f
prefix is not supplied, the prefix is ’G__’."
{:added "1.0"
:static true}
([] (gensym "G__"))
([prefix-string]
(. clojure.lang.Symbol
(intern
(str prefix-string (str (. clojure.lang.RT (nextID)))))) ))
(defmacro cond
"Takes a set of test/expr pairs. It evaluates each test one at a
time. If a test returns logical true, cond evaluates and retu rns
the value of the corresponding expr and doesn’t evaluate any of the
other tests or exprs. (cond) returns nil."
{:added "1.0"}
[& clauses]
(when clauses
(list ’if (first clauses)
(if (next clauses)
(second clauses)
(throw (IllegalArgumentException.
"cond requires an even number of forms")))
(cons ’clojure.core/cond (next (next clauses))))))
(defn keyword
"Returns a Keyword with the given namespace and name. Do not u se :
11.1. CORE.CLJ 1181
in the keyword strings, it will be added automatically."
{:tag clojure.lang.Keyword
:added "1.0"
:static true}
([name] (cond (keyword? name) name
(symbol? name)
(clojure.lang.Keyword/intern ^clojure.lang.Symbol nam e)
(string? name)
(clojure.lang.Keyword/intern ^String name)))
([ns name] (clojure.lang.Keyword/intern ns name)))
(defn find-keyword
"Returns a Keyword with the given namespace and name if one al ready
exists. This function will not intern a new keyword. If the ke yword
has not already been interned, it will return nil. Do not use :
in the keyword strings, it will be added automatically."
{:tag clojure.lang.Keyword
:added "1.3"
:static true}
([name] (cond (keyword? name) name
(symbol? name)
(clojure.lang.Keyword/find ^clojure.lang.Symbol name)
(string? name)
(clojure.lang.Keyword/find ^String name)))
([ns name] (clojure.lang.Keyword/find ns name)))
(defn spread
{:private true
:static true}
[arglist]
(cond
(nil? arglist) nil
(nil? (next arglist)) (seq (first arglist))
:else (cons (first arglist) (spread (next arglist)))))
(defn list*
"Creates a new list containing the items prepended to the res t, the
last of which will be treated as a sequence."
{:added "1.0"
:static true}
([args] (seq args))
([a args] (cons a args))
([a b args] (cons a (cons b args)))
([a b c args] (cons a (cons b (cons c args))))
([a b c d & more]
(cons a (cons b (cons c (cons d (spread more)))))))
(defn apply
"Applies fn f to the argument list formed by prepending
1182 CHAPTER 11. CLJ/CLOJURE/
intervening arguments to args."
{:added "1.0"
:static true}
([^clojure.lang.IFn f args]
(. f (applyTo (seq args))))
([^clojure.lang.IFn f x args]
(. f (applyTo (list* x args))))
([^clojure.lang.IFn f x y args]
(. f (applyTo (list* x y args))))
([^clojure.lang.IFn f x y z args]
(. f (applyTo (list* x y z args))))
([^clojure.lang.IFn f a b c d & args]
(. f (applyTo (cons a (cons b (cons c (cons d (spread args))))) ))))
(defn vary-meta
"Returns an object of the same type and value as obj, with
(apply f (meta obj) args) as its metadata."
{:added "1.0"
:static true}
[obj f & args]
(with-meta obj (apply f (meta obj) args)))
(defmacro lazy-seq
"Takes a body of expressions that returns an ISeq or nil, and y ields
a Seqable object that will invoke the body only the first time seq
is called, and will cache the result and return it on all subse quent
seq calls."
{:added "1.0"}
[& body]
(list ’new ’clojure.lang.LazySeq (list* ’^{:once true} fn * [] body)))
(defn ^:static ^clojure.lang.ChunkBuffer chunk-buffer
^clojure.lang.ChunkBuffer [capacity]
(clojure.lang.ChunkBuffer. capacity))
(defn ^:static chunk-append [^clojure.lang.ChunkBuffer b x]
(.add b x))
(defn ^:static ^clojure.lang.IChunk chunk [^clojure.lan g.ChunkBuffer b]
(.chunk b))
(defn ^:static ^clojure.lang.IChunk chunk-first
^clojure.lang.IChunk [^clojure.lang.IChunkedSeq s]
(.chunkedFirst s))
(defn ^:static ^clojure.lang.ISeq chunk-rest
^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]
(.chunkedMore s))
(defn ^:static ^clojure.lang.ISeq chunk-next
11.1. CORE.CLJ 1183
^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]
(.chunkedNext s))
(defn ^:static chunk-cons [chunk rest]
(if (clojure.lang.Numbers/isZero (clojure.lang.RT/cou nt chunk))
rest
(clojure.lang.ChunkedCons. chunk rest)))
(defn ^:static chunked-seq? [s]
(instance? clojure.lang.IChunkedSeq s))
(defn concat
"Returns a lazy seq representing the concatenation of the
elements in the supplied colls."
{:added "1.0"
:static true}
([] (lazy-seq nil))
([x] (lazy-seq x))
([x y]
(lazy-seq
(let [s (seq x)]
(if s
(if (chunked-seq? s)
(chunk-cons (chunk-first s) (concat (chunk-rest s) y))
(cons (first s) (concat (rest s) y)))
y))))
([x y & zs]
(let [cat (fn cat [xys zs]
(lazy-seq
(let [xys (seq xys)]
(if xys
(if (chunked-seq? xys)
(chunk-cons (chunk-first xys)
(cat (chunk-rest xys) zs))
(cons (first xys) (cat (rest xys) zs)))
(when zs
(cat (first zs) (next zs)))))))]
(cat (concat x y) zs))))
;;;;at this point all the support for syntax-quote exists;; ;;
(defmacro delay
"Takes a body of expressions and yields a Delay object that wi ll
invoke the body only the first time it is forced (with force or
deref/@), and will cache the result and return it on all subse quent
force calls."
{:added "1.0"}
[& body]
(list ’new ’clojure.lang.Delay (list* ‘^{:once true} fn* [ ] body)))
(defn delay?
1184 CHAPTER 11. CLJ/CLOJURE/
"returns true if x is a Delay created with delay"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.Delay x))
(defn force
"If x is a Delay, returns the (possibly cached) value of its
expression, else returns x"
{:added "1.0"
:static true}
[x] (. clojure.lang.Delay (force x)))
(defmacro if-not
"Evaluates test. If logical false, evaluates and returns th en expr,
otherwise else expr, if supplied, else nil."
{:added "1.0"}
([test then] ‘(if-not ~test ~then nil))
([test then else]
‘(if (not ~test) ~then ~else)))
(defn identical?
"Tests if 2 arguments are the same object"
{:inline (fn [x y] ‘(. clojure.lang.Util identical ~x ~y))
:inline-arities #{2}
:added "1.0"}
([x y] (clojure.lang.Util/identical x y)))
;equiv-based
(defn =
"Equality. Returns true if x equals y, false if not. Same as
Java x.equals(y) except it also works for nil, and compares
numbers and collections in a type-independent manner. Cloj ure’s
immutable data structures define equals() (and thus =) as a v alue,
not an identity, comparison."
{:inline (fn [x y] ‘(. clojure.lang.Util equiv ~x ~y))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (clojure.lang.Util/equiv x y))
([x y & more]
(if (= x y)
(if (next more)
(recur y (first more) (next more))
(= y (first more)))
false)))
;equals-based
#_(defn =
"Equality. Returns true if x equals y, false if not. Same as Ja va
x.equals(y) except it also works for nil. Boxed numbers must have
11.1. CORE.CLJ 1185
same type. Clojure’s immutable data structures define equa ls() (and
thus =) as a value, not an identity, comparison."
{:inline (fn [x y] ‘(. clojure.lang.Util equals ~x ~y))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (clojure.lang.Util/equals x y))
([x y & more]
(if (= x y)
(if (next more)
(recur y (first more) (next more))
(= y (first more)))
false)))
(defn not=
"Same as (not (= obj1 obj2))"
{:tag Boolean
:added "1.0"
:static true}
([x] false)
([x y] (not (= x y)))
([x y & more]
(not (apply = x y more))))
(defn compare
"Comparator. Returns a negative number, zero, or a positive number
when x is logically ’less than’, ’equal to’, or ’greater than ’
y. Same as Java x.compareTo(y) except it also works for nil, a nd
compares numbers and collections in a type-independent man ner. x
must implement Comparable"
{
:inline (fn [x y] ‘(. clojure.lang.Util compare ~x ~y))
:added "1.0"}
[x y] (. clojure.lang.Util (compare x y)))
(defmacro and
"Evaluates exprs one at a time, from left to right. If a form
returns logical false (nil or false), and returns that value and
doesn’t evaluate any of the other expressions, otherwise it returns
the value of the last expr. (and) returns true."
{:added "1.0"}
([] true)
([x] x)
([x & next]
‘(let [and# ~x]
(if and# (and ~@next) and#))))
(defmacro or
1186 CHAPTER 11. CLJ/CLOJURE/
"Evaluates exprs one at a time, from left to right. If a form
returns a logical true value, or returns that value and doesn ’t
evaluate any of the other expressions, otherwise it returns the
value of the last expression. (or) returns nil."
{:added "1.0"}
([] nil)
([x] x)
([x & next]
‘(let [or# ~x]
(if or# or# (or ~@next)))))
;;;;;;;;;;;;;;;;;;; sequence fns ;;;;;;;;;;;;;;;;;;;;; ;;
(defn zero?
"Returns true if num is zero, else false"
{
:inline (fn [x] ‘(. clojure.lang.Numbers (isZero ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (isZero x)))
(defn count
"Returns the number of items in the collection. (count nil) r eturns
0. Also works on strings, arrays, and Java Collections and Ma ps"
{
:inline (fn [x] ‘(. clojure.lang.RT (count ~x)))
:added "1.0"}
[coll] (clojure.lang.RT/count coll))
(defn int
"Coerce to int"
{
:inline (fn [x]
‘(. clojure.lang.RT
(~(if *unchecked-math* ’uncheckedIntCast ’intCast) ~x)) )
:added "1.0"}
[x] (. clojure.lang.RT (intCast x)))
(defn nth
"Returns the value at the index. get returns nil if index out o f
bounds, nth throws an exception unless not-found is supplie d. nth
also works for strings, Java arrays, regex Matchers and List s, and,
in O(n) time, for sequences."
{:inline (fn [c i & nf] ‘(. clojure.lang.RT (nth ~c ~i ~@nf)))
:inline-arities #{2 3}
:added "1.0"}
([coll index] (. clojure.lang.RT (nth coll index)))
([coll index not-found]
(. clojure.lang.RT (nth coll index not-found))))
(defn <
"Returns non-nil if nums are in monotonically increasing or der,
11.1. CORE.CLJ 1187
otherwise false."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (lt ~x ~y)))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (. clojure.lang.Numbers (lt x y)))
([x y & more]
(if (< x y)
(if (next more)
(recur y (first more) (next more))
(< y (first more)))
false)))
(defn inc’
"Returns a number one greater than num. Supports arbitrary p recision.
See also: inc"
{:inline (fn [x] ‘(. clojure.lang.Numbers (incP ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (incP x)))
(defn inc
"Returns a number one greater than num. Does not auto-promot e
longs, will throw on overflow. See also: inc’"
{:inline (fn [x]
‘(. clojure.lang.Numbers
(~(if *unchecked-math* ’unchecked_inc ’inc) ~x)))
:added "1.2"}
[x] (. clojure.lang.Numbers (inc x)))
;; reduce is defined again later after InternalReduce loads
(defn ^:private ^:static
reduce1
([f coll]
(let [s (seq coll)]
(if s
(reduce1 f (first s) (next s))
(f))))
([f val coll]
(let [s (seq coll)]
(if s
(if (chunked-seq? s)
(recur f
(.reduce (chunk-first s) f val)
(chunk-next s))
(recur f (f val (first s)) (next s)))
val))))
(defn reverse
"Returns a seq of the items in coll in reverse order. Not lazy. "
{:added "1.0"
1188 CHAPTER 11. CLJ/CLOJURE/
:static true}
[coll]
(reduce1 conj () coll))
;;math stuff
(defn +’
"Returns the sum of nums. (+) returns 0. Supports arbitrary p recision.
See also: +"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (addP ~x ~y)))
:inline-arities #{2}
:added "1.0"}
([] 0)
([x] (cast Number x))
([x y] (. clojure.lang.Numbers (addP x y)))
([x y & more]
(reduce1 +’ (+’ x y) more)))
(defn +
"Returns the sum of nums. (+) returns 0. Does not auto-promot e
longs, will throw on overflow. See also: +’"
{:inline (fn [x y]
‘(. clojure.lang.Numbers
(~(if *unchecked-math* ’unchecked_add ’add) ~x ~y)))
:inline-arities #{2}
:added "1.2"}
([] 0)
([x] (cast Number x))
([x y] (. clojure.lang.Numbers (add x y)))
([x y & more]
(reduce1 + (+ x y) more)))
(defn *’
"Returns the product of nums. (*) returns 1. Supports arbitr ary
precision. See also: *"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (multiplyP ~x ~ y)))
:inline-arities #{2}
:added "1.0"}
([] 1)
([x] (cast Number x))
([x y] (. clojure.lang.Numbers (multiplyP x y)))
([x y & more]
(reduce1 *’ (*’ x y) more)))
(defn *
"Returns the product of nums. (*) returns 1. Does not auto-pr omote
longs, will throw on overflow. See also: *’"
{:inline
(fn [x y]
‘(. clojure.lang.Numbers
(~(if *unchecked-math* ’unchecked_multiply ’multiply) ~ x ~y)))
11.1. CORE.CLJ 1189
:inline-arities #{2}
:added "1.2"}
([] 1)
([x] (cast Number x))
([x y] (. clojure.lang.Numbers (multiply x y)))
([x y & more]
(reduce1 * (* x y) more)))
(defn /
"If no denominators are supplied, returns 1/numerator,
else returns numerator divided by all of the denominators."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (divide ~x ~y)) )
:inline-arities #{2}
:added "1.0"}
([x] (/ 1 x))
([x y] (. clojure.lang.Numbers (divide x y)))
([x y & more]
(reduce1 / (/ x y) more)))
(defn -’
"If no ys are supplied, returns the negation of x, else subtra cts
the ys from x and returns the result. Supports arbitrary prec ision.
See also: -"
{:inline (fn [& args] ‘(. clojure.lang.Numbers (minusP ~@a rgs)))
:inline-arities #{1 2}
:added "1.0"}
([x] (. clojure.lang.Numbers (minusP x)))
([x y] (. clojure.lang.Numbers (minusP x y)))
([x y & more]
(reduce1 -’ (-’ x y) more)))
(defn -
"If no ys are supplied, returns the negation of x, else subtra cts
the ys from x and returns the result. Does not auto-promote
longs, will throw on overflow. See also: -’"
{:inline
(fn [& args]
‘(. clojure.lang.Numbers
(~(if *unchecked-math* ’unchecked_minus ’minus) ~@args) ))
:inline-arities #{1 2}
:added "1.2"}
([x] (. clojure.lang.Numbers (minus x)))
([x y] (. clojure.lang.Numbers (minus x y)))
([x y & more]
(reduce1 - (- x y) more)))
(defn <=
"Returns non-nil if nums are in monotonically non-decreasi ng order,
otherwise false."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (lte ~x ~y)))
1190 CHAPTER 11. CLJ/CLOJURE/
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (. clojure.lang.Numbers (lte x y)))
([x y & more]
(if (<= x y)
(if (next more)
(recur y (first more) (next more))
(<= y (first more)))
false)))
(defn >
"Returns non-nil if nums are in monotonically decreasing or der,
otherwise false."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (gt ~x ~y)))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (. clojure.lang.Numbers (gt x y)))
([x y & more]
(if (> x y)
(if (next more)
(recur y (first more) (next more))
(> y (first more)))
false)))
(defn >=
"Returns non-nil if nums are in monotonically non-increasi ng order,
otherwise false."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (gte ~x ~y)))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (. clojure.lang.Numbers (gte x y)))
([x y & more]
(if (>= x y)
(if (next more)
(recur y (first more) (next more))
(>= y (first more)))
false)))
(defn ==
"Returns non-nil if nums all have the equivalent
value (type-independent), otherwise false"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (equiv ~x ~y)))
:inline-arities #{2}
:added "1.0"}
([x] true)
([x y] (. clojure.lang.Numbers (equiv x y)))
([x y & more]
11.1. CORE.CLJ 1191
(if (== x y)
(if (next more)
(recur y (first more) (next more))
(== y (first more)))
false)))
(defn max
"Returns the greatest of the nums."
{:added "1.0"
:static true}
([x] x)
([x y] (if (> x y) x y))
([x y & more]
(reduce1 max (max x y) more)))
(defn min
"Returns the least of the nums."
{:added "1.0"
:static true}
([x] x)
([x y] (if (< x y) x y))
([x y & more]
(reduce1 min (min x y) more)))
(defn dec’
"Returns a number one less than num. Supports arbitrary prec ision.
See also: dec"
{:inline (fn [x] ‘(. clojure.lang.Numbers (decP ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (decP x)))
(defn dec
"Returns a number one less than num. Does not auto-promote
longs, will throw on overflow. See also: dec’"
{:inline
(fn [x]
‘(. clojure.lang.Numbers
(~(if *unchecked-math* ’unchecked_dec ’dec) ~x)))
:added "1.2"}
[x] (. clojure.lang.Numbers (dec x)))
(defn unchecked-inc-int
"Returns a number one greater than x, an int.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_int _inc ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_int_inc x)))
(defn unchecked-inc
"Returns a number one greater than x, a long.
1192 CHAPTER 11. CLJ/CLOJURE/
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_inc ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_inc x)))
(defn unchecked-dec-int
"Returns a number one less than x, an int.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_int _dec ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_int_dec x)))
(defn unchecked-dec
"Returns a number one less than x, a long.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_dec ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_dec x)))
(defn unchecked-negate-int
"Returns the negation of x, an int.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_int _negate ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_int_negate x)))
(defn unchecked-negate
"Returns the negation of x, a long.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x] ‘(. clojure.lang.Numbers (unchecked_min us ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (unchecked_minus x)))
(defn unchecked-add-int
"Returns the sum of x and y, both int.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (unchecked_in t_add ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_int_add x y)))
(defn unchecked-add
"Returns the sum of x and y, both long.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (unchecked_ad d ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_add x y)))
(defn unchecked-subtract-int
"Returns the difference of x and y, both int.
Note - uses a primitive operator subject to overflow."
11.1. CORE.CLJ 1193
{:inline
(fn [x y] ‘(. clojure.lang.Numbers (unchecked_int_subtra ct ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_int_subtract x y )))
(defn unchecked-subtract
"Returns the difference of x and y, both long.
Note - uses a primitive operator subject to overflow."
{:inline (fn [x y] ‘(. clojure.lang.Numbers (unchecked_mi nus ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_minus x y)))
(defn unchecked-multiply-int
"Returns the product of x and y, both int.
Note - uses a primitive operator subject to overflow."
{:inline
(fn [x y] ‘(. clojure.lang.Numbers (unchecked_int_multip ly ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_int_multiply x y )))
(defn unchecked-multiply
"Returns the product of x and y, both long.
Note - uses a primitive operator subject to overflow."
{:inline
(fn [x y] ‘(. clojure.lang.Numbers (unchecked_multiply ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_multiply x y)))
(defn unchecked-divide-int
"Returns the division of x by y, both int.
Note - uses a primitive operator subject to truncation."
{:inline
(fn [x y] ‘(. clojure.lang.Numbers (unchecked_int_divide ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_int_divide x y)) )
(defn unchecked-remainder-int
"Returns the remainder of division of x by y, both int.
Note - uses a primitive operator subject to truncation."
{:inline
(fn [x y] ‘(. clojure.lang.Numbers (unchecked_int_remain der ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers (unchecked_int_remainder x y)))
(defn pos?
"Returns true if num is greater than zero, else false"
{
:inline (fn [x] ‘(. clojure.lang.Numbers (isPos ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (isPos x)))
1194 CHAPTER 11. CLJ/CLOJURE/
(defn neg?
"Returns true if num is less than zero, else false"
{
:inline (fn [x] ‘(. clojure.lang.Numbers (isNeg ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (isNeg x)))
(defn quot
"quot[ient] of dividing numerator by denominator."
{:added "1.0"
:static true
:inline (fn [x y] ‘(. clojure.lang.Numbers (quotient ~x ~y) ))}
[num div]
(. clojure.lang.Numbers (quotient num div)))
(defn rem
"remainder of dividing numerator by denominator."
{:added "1.0"
:static true
:inline (fn [x y] ‘(. clojure.lang.Numbers (remainder ~x ~y )))}
[num div]
(. clojure.lang.Numbers (remainder num div)))
(defn rationalize
"returns the rational value of num"
{:added "1.0"
:static true}
[num]
(. clojure.lang.Numbers (rationalize num)))
;;Bit ops
(defn bit-not
"Bitwise complement"
{:inline (fn [x] ‘(. clojure.lang.Numbers (not ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers not x))
(defn bit-and
"Bitwise and"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (and ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers and x y))
(defn bit-or
"Bitwise or"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (or ~x ~y)))
:added "1.0"}
11.1. CORE.CLJ 1195
[x y] (. clojure.lang.Numbers or x y))
(defn bit-xor
"Bitwise exclusive or"
{:inline (fn [x y] ‘(. clojure.lang.Numbers (xor ~x ~y)))
:added "1.0"}
[x y] (. clojure.lang.Numbers xor x y))
(defn bit-and-not
"Bitwise and with complement"
{:added "1.0"
:static true}
[x y] (. clojure.lang.Numbers andNot x y))
(defn bit-clear
"Clear bit at index n"
{:added "1.0"
:static true}
[x n] (. clojure.lang.Numbers clearBit x n))
(defn bit-set
"Set bit at index n"
{:added "1.0"
:static true}
[x n] (. clojure.lang.Numbers setBit x n))
(defn bit-flip
"Flip bit at index n"
{:added "1.0"
:static true}
[x n] (. clojure.lang.Numbers flipBit x n))
(defn bit-test
"Test bit at index n"
{:added "1.0"
:static true}
[x n] (. clojure.lang.Numbers testBit x n))
(defn bit-shift-left
"Bitwise shift left"
{:inline (fn [x n] ‘(. clojure.lang.Numbers (shiftLeft ~x ~ n)))
:added "1.0"}
[x n] (. clojure.lang.Numbers shiftLeft x n))
(defn bit-shift-right
"Bitwise shift right"
{:inline (fn [x n] ‘(. clojure.lang.Numbers (shiftRight ~x ~n)))
:added "1.0"}
1196 CHAPTER 11. CLJ/CLOJURE/
[x n] (. clojure.lang.Numbers shiftRight x n))
(defn even?
"Returns true if n is even, throws an exception if n is not an in teger"
{:added "1.0"
:static true}
[n] (zero? (bit-and n 1)))
(defn odd?
"Returns true if n is odd, throws an exception if n is not an int eger"
{:added "1.0"
:static true}
[n] (not (even? n)))
;;
(defn complement
"Takes a fn f and returns a fn that takes the same arguments as f ,
has the same effects, if any, and returns the opposite truth v alue."
{:added "1.0"
:static true}
[f]
(fn
([] (not (f)))
([x] (not (f x)))
([x y] (not (f x y)))
([x y & zs] (not (apply f x y zs)))))
(defn constantly
"Returns a function that takes any number of arguments and re turns x."
{:added "1.0"
:static true}
[x] (fn [& args] x))
(defn identity
"Returns its argument."
{:added "1.0"
:static true}
[x] x)
;;Collection stuff
;;list stuff
(defn peek
"For a list or queue, same as first, for a vector, same as, but m uch
more efficient than, last. If the collection is empty, retur ns nil."
{:added "1.0"
:static true}
[coll] (. clojure.lang.RT (peek coll)))
11.1. CORE.CLJ 1197
(defn pop
"For a list or queue, returns a new list/queue without the fir st
item, for a vector, returns a new vector without the last item . If
the collection is empty, throws an exception. Note - not the s ame
as next/butlast."
{:added "1.0"
:static true}
[coll] (. clojure.lang.RT (pop coll)))
;;map stuff
(defn contains?
"Returns true if key is present in the given collection, othe rwise
returns false. Note that for numerically indexed collectio ns like
vectors and Java arrays, this tests if the numeric key is with in the
range of indexes. ’contains?’ operates constant or logarit hmic time;
it will not perform a linear search for a value. See also ’some ’."
{:added "1.0"
:static true}
[coll key] (. clojure.lang.RT (contains coll key)))
(defn get
"Returns the value mapped to key, not-found or nil if key not p resent."
{:inline (fn [m k & nf] ‘(. clojure.lang.RT (get ~m ~k ~@nf)))
:inline-arities #{2 3}
:added "1.0"}
([map key]
(. clojure.lang.RT (get map key)))
([map key not-found]
(. clojure.lang.RT (get map key not-found))))
(defn dissoc
"dissoc[iate]. Returns a new map of the same (hashed/sorted ) type,
that does not contain a mapping for key(s)."
{:added "1.0"
:static true}
([map] map)
([map key]
(. clojure.lang.RT (dissoc map key)))
([map key & ks]
(let [ret (dissoc map key)]
(if ks
(recur ret (first ks) (next ks))
ret))))
(defn disj
"disj[oin]. Returns a new set of the same (hashed/sorted) ty pe, that
does not contain key(s)."
{:added "1.0"
1198 CHAPTER 11. CLJ/CLOJURE/
:static true}
([set] set)
([^clojure.lang.IPersistentSet set key]
(when set
(. set (disjoin key))))
([set key & ks]
(when set
(let [ret (disj set key)]
(if ks
(recur ret (first ks) (next ks))
ret)))))
(defn find
"Returns the map entry for key, or nil if key not present."
{:added "1.0"
:static true}
[map key] (. clojure.lang.RT (find map key)))
(defn select-keys
"Returns a map containing only those entries in map whose key
is in keys"
{:added "1.0"
:static true}
[map keyseq]
(loop [ret {} keys (seq keyseq)]
(if keys
(let [entry (. clojure.lang.RT (find map (first keys)))]
(recur
(if entry
(conj ret entry)
ret)
(next keys)))
ret)))
(defn keys
"Returns a sequence of the map’s keys."
{:added "1.0"
:static true}
[map] (. clojure.lang.RT (keys map)))
(defn vals
"Returns a sequence of the map’s values."
{:added "1.0"
:static true}
[map] (. clojure.lang.RT (vals map)))
(defn key
"Returns the key of the map entry."
{:added "1.0"
:static true}
11.1. CORE.CLJ 1199
[^java.util.Map$Entry e]
(. e (getKey)))
(defn val
"Returns the value in the map entry."
{:added "1.0"
:static true}
[^java.util.Map$Entry e]
(. e (getValue)))
(defn rseq
"Returns, in constant time, a seq of the items in rev (which
can be a vector or sorted-map), in reverse order. If rev is
empty returns nil"
{:added "1.0"
:static true}
[^clojure.lang.Reversible rev]
(. rev (rseq)))
(defn name
"Returns the name String of a string, symbol or keyword."
{:tag String
:added "1.0"
:static true}
[x]
(if (string? x) x (. ^clojure.lang.Named x (getName))))
(defn namespace
"Returns the namespace String of a symbol or keyword, or nil
if not present."
{:tag String
:added "1.0"
:static true}
[^clojure.lang.Named x]
(. x (getNamespace)))
(defmacro locking
"Executes exprs in an implicit do, while holding the monitor of x.
Will release the monitor of x in all circumstances."
{:added "1.0"}
[x & body]
‘(let [lockee# ~x]
(try
(monitor-enter lockee#)
~@body
(finally
(monitor-exit lockee#)))))
(defmacro ..
"form => fieldName-symbol or (instanceMethodName-symbol args*)
1200 CHAPTER 11. CLJ/CLOJURE/
Expands into a member access (.) of the first member on the fir st
argument, followed by the next member on the result, etc. For
instance:
(.. System (getProperties) (get \"os.name\"))
expands to:
(. (. System (getProperties)) (get \"os.name\"))
but is easier to write, read, and understand."
{:added "1.0"}
([x form] ‘(. ~x ~form))
([x form & more] ‘(.. (. ~x ~form) ~@more)))
(defmacro ->
"Threads the expr through the forms. Inserts x as the
second item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
second item in second form, etc."
{:added "1.0"}
([x] x)
([x form] (if (seq? form)
(with-meta ‘(~(first form) ~x ~@(next form)) (meta form))
(list form x)))
([x form & more] ‘(-> (-> ~x ~form) ~@more)))
(defmacro ->>
"Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc."
{:added "1.1"}
([x form] (if (seq? form)
(with-meta ‘(~(first form) ~@(next form) ~x) (meta form))
(list form x)))
([x form & more] ‘(->> (->> ~x ~form) ~@more)))
;;multimethods
(def global-hierarchy)
(defmacro defmulti
"Creates a new multimethod with the associated dispatch fun ction.
The docstring and attribute-map are optional.
Options are key-value pairs and may be one of:
:default the default dispatch value, defaults to :default
:hierarchy the isa? hierarchy to use for dispatching
defaults to the global hierarchy"
11.1. CORE.CLJ 1201
{:arglists ’([name docstring? attr-map? dispatch-fn & opt ions])
:added "1.0"}
[mm-name & options]
(let [docstring (if (string? (first options))
(first options)
nil)
options (if (string? (first options))
(next options)
options)
m (if (map? (first options))
(first options)
{})
options (if (map? (first options))
(next options)
options)
dispatch-fn (first options)
options (next options)
m (if docstring
(assoc m :doc docstring)
m)
m (if (meta mm-name)
(conj (meta mm-name) m)
m)]
(when (= (count options) 1)
(throw (Exception.
"The syntax for defmulti has changed.
Example: (defmulti name dispatch-fn :default dispatch-va lue)")))
(let [options (apply hash-map options)
default (get options :default :default)
hierarchy (get options :hierarchy #’global-hierarchy)]
‘(let [v# (def ~mm-name)]
(when-not (and (.hasRoot v#)
(instance? clojure.lang.MultiFn (deref v#)))
(def ~(with-meta mm-name m)
(new clojure.lang.MultiFn
~(name mm-name) ~dispatch-fn ~default ~hierarchy)))))))
(defmacro defmethod
"Creates and installs a new method of multimethod associate d
with dispatch-value. "
{:added "1.0"}
[multifn dispatch-val & fn-tail]
‘(. ~(with-meta multifn {:tag ’clojure.lang.MultiFn})
addMethod ~dispatch-val (fn ~@fn-tail)))
(defn remove-all-methods
"Removes all of the methods of multimethod."
{:added "1.2"
:static true}
[^clojure.lang.MultiFn multifn]
1202 CHAPTER 11. CLJ/CLOJURE/
(.reset multifn))
(defn remove-method
"Removes the method of multimethod associated with dispatc h-value."
{:added "1.0"
:static true}
[^clojure.lang.MultiFn multifn dispatch-val]
(. multifn removeMethod dispatch-val))
(defn prefer-method
"Causes the multimethod to prefer matches of dispatch-val- x
over dispatch-val-y
when there is a conflict"
{:added "1.0"
:static true}
[^clojure.lang.MultiFn multifn dispatch-val-x dispatch -val-y]
(. multifn preferMethod dispatch-val-x dispatch-val-y))
(defn methods
"Given a multimethod, returns a map of dispatch values -> dis patch fns"
{:added "1.0"
:static true}
[^clojure.lang.MultiFn multifn] (.getMethodTable multi fn))
(defn get-method
"Given a multimethod and a dispatch value, returns the dispa tch fn
that would apply to that value, or nil if none apply and no defa ult"
{:added "1.0"
:static true}
[^clojure.lang.MultiFn multifn dispatch-val]
(.getMethod multifn dispatch-val))
(defn prefers
"Given a multimethod, returns a map of preferred value -> set
of other values"
{:added "1.0"
:static true}
[^clojure.lang.MultiFn multifn] (.getPreferTable multi fn))
;;;;;;;;; var stuff
(defmacro ^{:private true} assert-args [fnname & pairs]
‘(do (when-not ~(first pairs)
(throw (IllegalArgumentException.
~(str fnname " requires " (second pairs)))))
~(let [more (nnext pairs)]
(when more
(list* ‘assert-args fnname more)))))
(defmacro if-let
11.1. CORE.CLJ 1203
"bindings => binding-form test
If test is true, evaluates then with binding-form bound to th e
value of test, if not, yields else"
{:added "1.0"}
([bindings then]
‘(if-let ~bindings ~then nil))
([bindings then else & oldform]
(assert-args if-let
(and (vector? bindings) (nil? oldform)) "a vector for its bi nding"
(= 2 (count bindings)) "exactly 2 forms in binding vector")
(let [form (bindings 0) tst (bindings 1)]
‘(let [temp# ~tst]
(if temp#
(let [~form temp#]
~then)
~else)))))
(defmacro when-let
"bindings => binding-form test
When test is true, evaluates body with binding-form bound to
the value of test"
{:added "1.0"}
[bindings & body]
(assert-args when-let
(vector? bindings) "a vector for its binding"
(= 2 (count bindings)) "exactly 2 forms in binding vector")
(let [form (bindings 0) tst (bindings 1)]
‘(let [temp# ~tst]
(when temp#
(let [~form temp#]
~@body)))))
(defn push-thread-bindings
"WARNING: This is a low-level function. Prefer high-level m acros like
binding where ever possible.
Takes a map of Var/value pairs. Binds each Var to the associat ed
value for the current thread. Each call *MUST* be accompanie d by
a matching call to pop-thread-bindings wrapped in a try-fin ally!
(push-thread-bindings bindings)
(try
...
(finally
(pop-thread-bindings)))"
{:added "1.1"
:static true}
[bindings]
1204 CHAPTER 11. CLJ/CLOJURE/
(clojure.lang.Var/pushThreadBindings bindings))
(defn pop-thread-bindings
"Pop one set of bindings pushed with push-binding before. It is an
error to pop bindings without pushing before."
{:added "1.1"
:static true}
[]
(clojure.lang.Var/popThreadBindings))
(defn get-thread-bindings
"Get a map with the Var/value pairs which is currently in effe ct
for the current thread."
{:added "1.1"
:static true}
[]
(clojure.lang.Var/getThreadBindings))
(defmacro binding
"binding => var-symbol init-expr
Creates new bindings for the (already-existing) vars, with the
supplied initial values, executes the exprs in an implicit d o, then
re-establishes the bindings that existed before. The new bi ndings
are made in parallel (unlike let); all init-exprs are evalua ted
before the vars are bound to their new values."
{:added "1.0"}
[bindings & body]
(assert-args binding
(vector? bindings) "a vector for its binding"
(even? (count bindings)) "an even number of forms in binding vector")
(let [var-ize (fn [var-vals]
(loop [ret [] vvs (seq var-vals)]
(if vvs
(recur
(conj
(conj ret ‘(var ~(first vvs)))
(second vvs))
(next (next vvs)))
(seq ret))))]
‘(let []
(push-thread-bindings (hash-map ~@(var-ize bindings)))
(try
~@body
(finally
(pop-thread-bindings))))))
(defn with-bindings*
"Takes a map of Var/value pairs. Installs for the given Vars t he
associated values as thread-local bindings. Then calls f wi th the
11.1. CORE.CLJ 1205
supplied arguments. Pops the installed bindings after f ret urned.
Returns whatever f returns."
{:added "1.1"
:static true}
[binding-map f & args]
(push-thread-bindings binding-map)
(try
(apply f args)
(finally
(pop-thread-bindings))))
(defmacro with-bindings
"Takes a map of Var/value pairs. Installs for the given Vars t he
associated values as thread-local bindings. The executes b ody.
Pops the installed bindings after body was evaluated. Retur ns the
value of body."
{:added "1.1"}
[binding-map & body]
‘(with-bindings* ~binding-map (fn [] ~@body)))
(defn bound-fn*
"Returns a function, which will install the same bindings in effect
as in the thread at the time bound-fn* was called and then call f
with any given arguments. This may be used to define a helper
function which runs on a different thread, but needs the same
bindings in place."
{:added "1.1"
:static true}
[f]
(let [bindings (get-thread-bindings)]
(fn [& args]
(apply with-bindings* bindings f args))))
(defmacro bound-fn
"Returns a function defined by the given fntail, which will i nstall
the same bindings in effect as in the thread at the time bound- fn
was called. This may be used to define a helper function which
runs on a different thread, but needs the same bindings in pla ce."
{:added "1.1"}
[& fntail]
‘(bound-fn* (fn ~@fntail)))
(defn find-var
"Returns the global var named by the namespace-qualified sy mbol, or
nil if no var with that name."
{:added "1.0"
:static true}
[sym] (. clojure.lang.Var (find sym)))
(defn binding-conveyor-fn
1206 CHAPTER 11. CLJ/CLOJURE/
{:private true
:added "1.3"}
[f]
(let [frame (clojure.lang.Var/getThreadBindingFrame)]
(fn
([]
(clojure.lang.Var/resetThreadBindingFrame frame)
(f))
([x]
(clojure.lang.Var/resetThreadBindingFrame frame)
(f x))
([x y]
(clojure.lang.Var/resetThreadBindingFrame frame)
(f x y))
([x y z]
(clojure.lang.Var/resetThreadBindingFrame frame)
(f x y z))
([x y z & args]
(clojure.lang.Var/resetThreadBindingFrame frame)
(apply f x y z args)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Refs ;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;
(defn ^{:private true}
setup-reference [^clojure.lang.ARef r options]
(let [opts (apply hash-map options)]
(when (:meta opts)
(.resetMeta r (:meta opts)))
(when (:validator opts)
(.setValidator r (:validator opts)))
r))
(defn agent
"Creates and returns an agent with an initial value of state a nd
zero or more options (in any order):
:meta metadata-map
:validator validate-fn
:error-handler handler-fn
:error-mode mode-keyword
If metadata-map is supplied, it will be come the metadata on t he
agent. validate-fn must be nil or a side-effect-free fn of on e
argument, which will be passed the intended new state on any s tate
change. If the new state is unacceptable, the validate-fn sh ould
return false or throw an exception. handler-fn is called if a n
action throws an exception or if validate-fn rejects a new st ate --
see set-error-handler! for details. The mode-keyword may b e either
11.1. CORE.CLJ 1207
:continue (the default if an error-handler is given) or :fai l (the
default if no error-handler is given) -- see set-error-mode ! for
details."
{:added "1.0"
:static true
}
([state & options]
(let [a (new clojure.lang.Agent state)
opts (apply hash-map options)]
(setup-reference a options)
(when (:error-handler opts)
(.setErrorHandler a (:error-handler opts)))
(.setErrorMode a (or (:error-mode opts)
(if (:error-handler opts) :continue :fail)))
a)))
(defn send
"Dispatch an action to an agent. Returns the agent immediate ly.
Subsequently, in a thread from a thread pool, the state of the agent
will be set to the value of:
(apply action-fn state-of-agent args)"
{:added "1.0"
:static true}
[^clojure.lang.Agent a f & args]
(.dispatch a (binding [*agent* a] (binding-conveyor-fn f) ) args false))
(defn send-off
"Dispatch a potentially blocking action to an agent. Return s the
agent immediately. Subsequently, in a separate thread, the state of
the agent will be set to the value of:
(apply action-fn state-of-agent args)"
{:added "1.0"
:static true}
[^clojure.lang.Agent a f & args]
(.dispatch a (binding [*agent* a] (binding-conveyor-fn f) ) args true))
(defn release-pending-sends
"Normally, actions sent directly or indirectly during anot her action
are held until the action completes (changes the agent’s
state). This function can be used to dispatch any pending sen t
actions immediately. This has no impact on actions sent duri ng a
transaction, which are still held until commit. If no action is
occurring, does nothing. Returns the number of actions disp atched."
{:added "1.0"
:static true}
[] (clojure.lang.Agent/releasePendingSends))
(defn add-watch
1208 CHAPTER 11. CLJ/CLOJURE/
"Alpha - subject to change.
Adds a watch function to an agent/atom/var/ref reference. T he watch
fn must be a fn of 4 args: a key, the reference, its old-state, i ts
new-state. Whenever the reference’s state might have been c hanged,
any registered watches will have their functions called. Th e watch fn
will be called synchronously, on the agent’s thread if an age nt,
before any pending sends if agent or ref. Note that an atom’s o r
ref’s state may have changed again prior to the fn call, so use
old/new-state rather than derefing the reference. Note als o that watch
fns may be called from multiple threads simultaneously. Var watchers
are triggered only by root binding changes, not thread-loca l
set!s. Keys must be unique per reference, and can be used to re move
the watch with remove-watch, but are otherwise considered o paque by
the watch mechanism."
{:added "1.0"
:static true}
[^clojure.lang.IRef reference key fn] (.addWatch referen ce key fn))
(defn remove-watch
"Alpha - subject to change.
Removes a watch (set by add-watch) from a reference"
{:added "1.0"
:static true}
[^clojure.lang.IRef reference key]
(.removeWatch reference key))
(defn agent-error
"Returns the exception thrown during an asynchronous actio n of the
agent if the agent is failed. Returns nil if the agent is not
failed."
{:added "1.2"
:static true}
[^clojure.lang.Agent a] (.getError a))
(defn restart-agent
"When an agent is failed, changes the agent state to new-stat e and
then un-fails the agent so that sends are allowed again. If
a :clear-actions true option is given, any actions queued on the
agent that were being held while it was failed will be discard ed,
otherwise those held actions will proceed. The new-state mu st pass
the validator if any, or restart will throw an exception and t he
agent will remain failed with its old state and error. Watche rs, if
any, will NOT be notified of the new state. Throws an exceptio n if
the agent is not failed."
{:added "1.2"
:static true
}
[^clojure.lang.Agent a, new-state & options]
(let [opts (apply hash-map options)]
(.restart a new-state (if (:clear-actions opts) true false ))))
11.1. CORE.CLJ 1209
(defn set-error-handler!
"Sets the error-handler of agent a to handler-fn. If an actio n
being run by the agent throws an exception or doesn’t pass the
validator fn, handler-fn will be called with two arguments: the
agent and the exception."
{:added "1.2"
:static true}
[^clojure.lang.Agent a, handler-fn]
(.setErrorHandler a handler-fn))
(defn error-handler
"Returns the error-handler of agent a, or nil if there is none .
See set-error-handler!"
{:added "1.2"
:static true}
[^clojure.lang.Agent a]
(.getErrorHandler a))
(defn set-error-mode!
"Sets the error-mode of agent a to mode-keyword, which must b e
either :fail or :continue. If an action being run by the agent
throws an exception or doesn’t pass the validator fn, an
error-handler may be called (see set-error-handler!), aft er which,
if the mode is :continue, the agent will continue as if neithe r the
action that caused the error nor the error itself ever happen ed.
If the mode is :fail, the agent will become failed and will sto p
accepting new ’send’ and ’send-off’ actions, and any previo usly
queued actions will be held until a ’restart-agent’. Deref w ill
still work, returning the state of the agent before the error ."
{:added "1.2"
:static true}
[^clojure.lang.Agent a, mode-keyword]
(.setErrorMode a mode-keyword))
(defn error-mode
"Returns the error-mode of agent a. See set-error-mode!"
{:added "1.2"
:static true}
[^clojure.lang.Agent a]
(.getErrorMode a))
(defn agent-errors
"DEPRECATED: Use ’agent-error’ instead.
Returns a sequence of the exceptions thrown during asynchro nous
actions of the agent."
{:added "1.0"
:deprecated "1.2"}
[a]
1210 CHAPTER 11. CLJ/CLOJURE/
(when-let [e (agent-error a)]
(list e)))
(defn clear-agent-errors
"DEPRECATED: Use ’restart-agent’ instead.
Clears any exceptions thrown during asynchronous actions o f the
agent, allowing subsequent actions to occur."
{:added "1.0"
:deprecated "1.2"}
[^clojure.lang.Agent a] (restart-agent a (.deref a)))
(defn shutdown-agents
"Initiates a shutdown of the thread pools that back the agent
system. Running actions will complete, but no new actions wi ll be
accepted"
{:added "1.0"
:static true}
[] (. clojure.lang.Agent shutdown))
(defn ref
"Creates and returns a Ref with an initial value of x and zero o r
more options (in any order):
:meta metadata-map
:validator validate-fn
:min-history (default 0)
:max-history (default 10)
If metadata-map is supplied, it will be come the metadata on t he
ref. validate-fn must be nil or a side-effect-free fn of one
argument, which will be passed the intended new state on any s tate
change. If the new state is unacceptable, the validate-fn sh ould
return false or throw an exception. validate-fn will be call ed on
transaction commit, when all refs have their final values.
Normally refs accumulate history dynamically as needed to d eal with
read demands. If you know in advance you will need history you can
set :min-history to ensure it will be available when first ne eded
(instead of after a read fault). History is limited, and the l imit
can be set with :max-history."
{:added "1.0"
:static true
}
([x] (new clojure.lang.Ref x))
([x & options]
(let [r ^clojure.lang.Ref (setup-reference (ref x) option s)
opts (apply hash-map options)]
(when (:max-history opts)
11.1. CORE.CLJ 1211
(.setMaxHistory r (:max-history opts)))
(when (:min-history opts)
(.setMinHistory r (:min-history opts)))
r)))
(defn deref
"Also reader macro: @ref/@agent/@var/@atom/@delay/@fut ure.
Within a transaction, returns the in-transaction-value of ref,
else returns the most-recently-committed value of ref. Whe n
applied to a var, agent or atom, returns its current state.
When applied to a delay, forces it if not already forced. When
applied to a future, will block if computation not complete"
{:added "1.0"
:static true}
[^clojure.lang.IDeref ref] (.deref ref))
(defn atom
"Creates and returns an Atom with an initial value of x and zer o or
more options (in any order):
:meta metadata-map
:validator validate-fn
If metadata-map is supplied, it will be come the metadata on t he
atom. validate-fn must be nil or a side-effect-free fn of one
argument, which will be passed the intended new state on any s tate
change. If the new state is unacceptable, the validate-fn sh ould
return false or throw an exception."
{:added "1.0"
:static true}
([x] (new clojure.lang.Atom x))
([x & options] (setup-reference (atom x) options)))
(defn swap!
"Atomically swaps the value of atom to be:
(apply f current-value-of-atom args). Note that f may be cal led
multiple times, and thus should be free of side effects. Retu rns
the value that was swapped in."
{:added "1.0"
:static true}
([^clojure.lang.Atom atom f] (.swap atom f))
([^clojure.lang.Atom atom f x] (.swap atom f x))
([^clojure.lang.Atom atom f x y] (.swap atom f x y))
([^clojure.lang.Atom atom f x y & args] (.swap atom f x y args) ))
(defn compare-and-set!
"Atomically sets the value of atom to newval if and only if the
current value of the atom is identical to oldval. Returns tru e if
set happened, else false"
1212 CHAPTER 11. CLJ/CLOJURE/
{:added "1.0"
:static true}
[^clojure.lang.Atom atom oldval newval]
(.compareAndSet atom oldval newval))
(defn reset!
"Sets the value of atom to newval without regard for the
current value. Returns newval."
{:added "1.0"
:static true}
[^clojure.lang.Atom atom newval] (.reset atom newval))
(defn set-validator!
"Sets the validator-fn for a var/ref/agent/atom. validato r-fn
must be nil or a side-effect-free fn of one argument, which wi ll
be passed the intended new state on any state change. If the ne w
state is unacceptable, the validator-fn should return fals e or
throw an exception. If the current state (root value if var)
is not acceptable to the new validator, an exception will be
thrown and the validator will not be changed."
{:added "1.0"
:static true}
[^clojure.lang.IRef iref validator-fn]
(. iref (setValidator validator-fn)))
(defn get-validator
"Gets the validator-fn for a var/ref/agent/atom."
{:added "1.0"
:static true}
[^clojure.lang.IRef iref] (. iref (getValidator)))
(defn alter-meta!
"Atomically sets the metadata for a namespace/var/ref/age nt/atom to be:
(apply f its-current-meta args)
f must be free of side-effects"
{:added "1.0"
:static true}
[^clojure.lang.IReference iref f & args] (.alterMeta iref f args))
(defn reset-meta!
"Atomically resets the metadata for a namespace/var/ref/a gent/atom"
{:added "1.0"
:static true}
[^clojure.lang.IReference iref metadata-map]
(.resetMeta iref metadata-map))
(defn commute
"Must be called in a transaction. Sets the in-transaction-v alue of
11.1. CORE.CLJ 1213
ref to:
(apply fun in-transaction-value-of-ref args)
and returns the in-transaction-value of ref.
At the commit point of the transaction, sets the value of ref t o be:
(apply fun most-recently-committed-value-of-ref args)
Thus fun should be commutative, or, failing that, you must ac cept
last-one-in-wins behavior. commute allows for more concur rency than
ref-set."
{:added "1.0"
:static true}
[^clojure.lang.Ref ref fun & args]
(. ref (commute fun args)))
(defn alter
"Must be called in a transaction. Sets the in-transaction-v alue of
ref to:
(apply fun in-transaction-value-of-ref args)
and returns the in-transaction-value of ref."
{:added "1.0"
:static true}
[^clojure.lang.Ref ref fun & args]
(. ref (alter fun args)))
(defn ref-set
"Must be called in a transaction. Sets the value of ref.
Returns val."
{:added "1.0"
:static true}
[^clojure.lang.Ref ref val]
(. ref (set val)))
(defn ref-history-count
"Returns the history count of a ref"
{:added "1.1"
:static true}
[^clojure.lang.Ref ref]
(.getHistoryCount ref))
(defn ref-min-history
"Gets the min-history of a ref, or sets it and returns the ref"
{:added "1.1"
:static true}
1214 CHAPTER 11. CLJ/CLOJURE/
([^clojure.lang.Ref ref]
(.getMinHistory ref))
([^clojure.lang.Ref ref n]
(.setMinHistory ref n)))
(defn ref-max-history
"Gets the max-history of a ref, or sets it and returns the ref"
{:added "1.1"
:static true}
([^clojure.lang.Ref ref]
(.getMaxHistory ref))
([^clojure.lang.Ref ref n]
(.setMaxHistory ref n)))
(defn ensure
"Must be called in a transaction. Protects the ref from modif ication
by other transactions. Returns the in-transaction-value o f
ref. Allows for more concurrency than (ref-set ref @ref)"
{:added "1.0"
:static true}
[^clojure.lang.Ref ref]
(. ref (touch))
(. ref (deref)))
(defmacro sync
"transaction-flags => TBD, pass nil for now
Runs the exprs (in an implicit do) in a transaction that encom passes
exprs and any nested calls. Starts a transaction if none is al ready
running on this thread. Any uncaught exception will abort th e
transaction and flow out of sync. The exprs may be run more tha n
once, but any effects on Refs will be atomic."
{:added "1.0"}
[flags-ignored-for-now & body]
‘(. clojure.lang.LockingTransaction
(runInTransaction (fn [] ~@body))))
(defmacro io!
"If an io! block occurs in a transaction, throws an
IllegalStateException, else runs body in an implicit do. If the
first expression in body is a literal string, will use that as the
exception message."
{:added "1.0"}
[& body]
(let [message (when (string? (first body)) (first body))
body (if message (next body) body)]
‘(if (clojure.lang.LockingTransaction/isRunning)
(throw
(new IllegalStateException ~(or message "I/O in transacti on")))
11.1. CORE.CLJ 1215
(do ~@body))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fn stuff ;;;;;;;;;;;;;; ;;
(defn comp
"Takes a set of functions and returns a fn that is the composit ion
of those fns. The returned fn takes a variable number of args,
applies the rightmost of fns to the args, the next
fn (right-to-left) to the result, etc."
{:added "1.0"
:static true}
([] identity)
([f] f)
([f g]
(fn
([] (f (g)))
([x] (f (g x)))
([x y] (f (g x y)))
([x y z] (f (g x y z)))
([x y z & args] (f (apply g x y z args)))))
([f g h]
(fn
([] (f (g (h))))
([x] (f (g (h x))))
([x y] (f (g (h x y))))
([x y z] (f (g (h x y z))))
([x y z & args] (f (g (apply h x y z args))))))
([f1 f2 f3 & fs]
(let [fs (reverse (list* f1 f2 f3 fs))]
(fn [& args]
(loop [ret (apply (first fs) args) fs (next fs)]
(if fs
(recur ((first fs) ret) (next fs))
ret))))))
(defn juxt
"Alpha - name subject to change.
Takes a set of functions and returns a fn that is the juxtaposi tion
of those fns. The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the
args (left-to-right).
((juxt a b c) x) => [(a x) (b x) (c x)]"
{:added "1.1"
:static true}
([f]
(fn
([] [(f)])
([x] [(f x)])
([x y] [(f x y)])
1216 CHAPTER 11. CLJ/CLOJURE/
([x y z] [(f x y z)])
([x y z & args] [(apply f x y z args)])))
([f g]
(fn
([] [(f) (g)])
([x] [(f x) (g x)])
([x y] [(f x y) (g x y)])
([x y z] [(f x y z) (g x y z)])
([x y z & args] [(apply f x y z args) (apply g x y z args)])))
([f g h]
(fn
([] [(f) (g) (h)])
([x] [(f x) (g x) (h x)])
([x y] [(f x y) (g x y) (h x y)])
([x y z] [(f x y z) (g x y z) (h x y z)])
([x y z & args]
[(apply f x y z args)
(apply g x y z args)
(apply h x y z args)])))
([f g h & fs]
(let [fs (list* f g h fs)]
(fn
([] (reduce1 #(conj %1 (%2)) [] fs))
([x] (reduce1 #(conj %1 (%2 x)) [] fs))
([x y] (reduce1 #(conj %1 (%2 x y)) [] fs))
([x y z] (reduce1 #(conj %1 (%2 x y z)) [] fs))
([x y z & args]
(reduce1 #(conj %1 (apply %2 x y z args)) [] fs))))))
(defn partial
"Takes a function f and fewer than the normal arguments to f, a nd
returns a fn that takes a variable number of additional args. When
called, the returned function calls f with args + additional args."
{:added "1.0"
:static true}
([f arg1]
(fn [& args] (apply f arg1 args)))
([f arg1 arg2]
(fn [& args] (apply f arg1 arg2 args)))
([f arg1 arg2 arg3]
(fn [& args] (apply f arg1 arg2 arg3 args)))
([f arg1 arg2 arg3 & more]
(fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))
;;;;;;;;;;;;;;;;;;; sequence fns ;;;;;;;;;;;;;;;;;;;;; ;;
(defn sequence
"Coerces coll to a (possibly empty) sequence, if it is not alr eady
one. Will not force a lazy seq. (sequence nil) yields ()"
{:added "1.0"
:static true}
11.1. CORE.CLJ 1217
[coll]
(if (seq? coll) coll
(or (seq coll) ())))
(defn every?
"Returns true if (pred x) is logical true for every x in coll, e lse
false."
{:tag Boolean
:added "1.0"
:static true}
[pred coll]
(cond
(nil? (seq coll)) true
(pred (first coll)) (recur pred (next coll))
:else false))
(def
^{:tag Boolean
:doc "Returns false if (pred x) is logical true for every x in
coll, else true."
:arglists ’([pred coll])
:added "1.0"}
not-every? (comp not every?))
(defn some
"Returns the first logical true value of (pred x) for any x in c oll,
else nil. One common idiom is to use a set as pred, for example
this will return :fred if :fred is in the sequence, otherwise nil:
(some #{:fred} coll)"
{:added "1.0"
:static true}
[pred coll]
(when (seq coll)
(or (pred (first coll)) (recur pred (next coll)))))
(def
^{:tag Boolean
:doc "Returns false if (pred x) is logical true for any x in col l,
else true."
:arglists ’([pred coll])
:added "1.0"}
not-any? (comp not some))
;will be redefed later with arg checks
(defmacro dotimes
"bindings => name n
Repeatedly executes body (presumably for side-effects) wi th name
bound to integers from 0 through n-1."
{:added "1.0"}
1218 CHAPTER 11. CLJ/CLOJURE/
[bindings & body]
(let [i (first bindings)
n (second bindings)]
‘(let [n# (clojure.lang.RT/longCast ~n)]
(loop [~i 0]
(when (< ~i n#)
~@body
(recur (unchecked-inc ~i)))))))
(defn map
"Returns a lazy sequence consisting of the result of applyin g f to the
set of first items of each coll, followed by applying f to the s et
of second items in each coll, until any one of the colls is
exhausted. Any remaining items in other colls are ignored. F unction
f should accept number-of-colls arguments."
{:added "1.0"
:static true}
([f coll]
(lazy-seq
(when-let [s (seq coll)]
(if (chunked-seq? s)
(let [c (chunk-first s)
size (int (count c))
b (chunk-buffer size)]
(dotimes [i size]
(chunk-append b (f (.nth c i))))
(chunk-cons (chunk b) (map f (chunk-rest s))))
(cons (f (first s)) (map f (rest s)))))))
([f c1 c2]
(lazy-seq
(let [s1 (seq c1) s2 (seq c2)]
(when (and s1 s2)
(cons (f (first s1) (first s2))
(map f (rest s1) (rest s2)))))))
([f c1 c2 c3]
(lazy-seq
(let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]
(when (and s1 s2 s3)
(cons (f (first s1) (first s2) (first s3))
(map f (rest s1) (rest s2) (rest s3)))))))
([f c1 c2 c3 & colls]
(let [step (fn step [cs]
(lazy-seq
(let [ss (map seq cs)]
(when (every? identity ss)
(cons (map first ss) (step (map rest ss)))))))]
(map #(apply f %) (step (conj colls c3 c2 c1))))))
(defn mapcat
"Returns the result of applying concat to the result of apply ing map
11.1. CORE.CLJ 1219
to f and colls. Thus function f should return a collection."
{:added "1.0"
:static true}
[f & colls]
(apply concat (apply map f colls)))
(defn filter
"Returns a lazy sequence of the items in coll for which
(pred item) returns true. pred must be free of side-effects. "
{:added "1.0"
:static true}
([pred coll]
(lazy-seq
(when-let [s (seq coll)]
(if (chunked-seq? s)
(let [c (chunk-first s)
size (count c)
b (chunk-buffer size)]
(dotimes [i size]
(when (pred (.nth c i))
(chunk-append b (.nth c i))))
(chunk-cons (chunk b) (filter pred (chunk-rest s))))
(let [f (first s) r (rest s)]
(if (pred f)
(cons f (filter pred r))
(filter pred r))))))))
(defn remove
"Returns a lazy sequence of the items in coll for which
(pred item) returns false. pred must be free of side-effects ."
{:added "1.0"
:static true}
[pred coll]
(filter (complement pred) coll))
(defn take
"Returns a lazy sequence of the first n items in coll, or all it ems if
there are fewer than n."
{:added "1.0"
:static true}
[n coll]
(lazy-seq
(when (pos? n)
(when-let [s (seq coll)]
(cons (first s) (take (dec n) (rest s)))))))
(defn take-while
"Returns a lazy sequence of successive items from coll while
(pred item) returns true. pred must be free of side-effects. "
1220 CHAPTER 11. CLJ/CLOJURE/
{:added "1.0"
:static true}
[pred coll]
(lazy-seq
(when-let [s (seq coll)]
(when (pred (first s))
(cons (first s) (take-while pred (rest s)))))))
(defn drop
"Returns a lazy sequence of all but the first n items in coll."
{:added "1.0"
:static true}
[n coll]
(let [step (fn [n coll]
(let [s (seq coll)]
(if (and (pos? n) s)
(recur (dec n) (rest s))
s)))]
(lazy-seq (step n coll))))
(defn drop-last
"Return a lazy sequence of all but the last n (default 1) items
in coll"
{:added "1.0"
:static true}
([s] (drop-last 1 s))
([n s] (map (fn [x _] x) s (drop n s))))
(defn take-last
"Returns a seq of the last n items in coll. Depending on the typ e
of coll may be no better than linear time. For vectors,
see also subvec."
{:added "1.1"
:static true}
[n coll]
(loop [s (seq coll), lead (seq (drop n coll))]
(if lead
(recur (next s) (next lead))
s)))
(defn drop-while
"Returns a lazy sequence of the items in coll starting from th e first
item for which (pred item) returns nil."
{:added "1.0"
:static true}
[pred coll]
(let [step (fn [pred coll]
(let [s (seq coll)]
(if (and s (pred (first s)))
(recur pred (rest s))
11.1. CORE.CLJ 1221
s)))]
(lazy-seq (step pred coll))))
(defn cycle
"Returns a lazy (infinite!) sequence of repetitions of the i tems
in coll."
{:added "1.0"
:static true}
[coll] (lazy-seq
(when-let [s (seq coll)]
(concat s (cycle s)))))
(defn split-at
"Returns a vector of [(take n coll) (drop n coll)]"
{:added "1.0"
:static true}
[n coll]
[(take n coll) (drop n coll)])
(defn split-with
"Returns a vector of [(take-while pred coll) (drop-while pr ed coll)]"
{:added "1.0"
:static true}
[pred coll]
[(take-while pred coll) (drop-while pred coll)])
(defn repeat
"Returns a lazy (infinite!, or length n if supplied) sequenc e of xs."
{:added "1.0"
:static true}
([x] (lazy-seq (cons x (repeat x))))
([n x] (take n (repeat x))))
(defn replicate
"DEPRECATED: Use ’repeat’ instead.
Returns a lazy seq of n xs."
{:added "1.0"
:deprecated "1.3"}
[n x] (take n (repeat x)))
(defn iterate
"Returns a lazy sequence of x, (f x), (f (f x)) etc.
f must be free of side-effects"
{:added "1.0"
:static true}
[f x] (cons x (lazy-seq (iterate f (f x)))))
(defn range
"Returns a lazy seq of nums from start (inclusive) to end
(exclusive), by step, where start defaults to 0, step to 1, an d end
1222 CHAPTER 11. CLJ/CLOJURE/
to infinity."
{:added "1.0"
:static true}
([] (range 0 Double/POSITIVE_INFINITY 1))
([end] (range 0 end 1))
([start end] (range start end 1))
([start end step]
(lazy-seq
(let [b (chunk-buffer 32)
comp (if (pos? step) < >)]
(loop [i start]
(if (and (< (count b) 32)
(comp i end))
(do
(chunk-append b i)
(recur (+ i step)))
(chunk-cons (chunk b)
(when (comp i end)
(range i end step)))))))))
(defn merge
"Returns a map that consists of the rest of the maps conj-ed on to
the first. If a key occurs in more than one map, the mapping fro m
the latter (left-to-right) will be the mapping in the result ."
{:added "1.0"
:static true}
[& maps]
(when (some identity maps)
(reduce1 #(conj (or %1 {}) %2) maps)))
(defn merge-with
"Returns a map that consists of the rest of the maps conj-ed on to
the first. If a key occurs in more than one map, the mapping(s)
from the latter (left-to-right) will be combined with the ma pping in
the result by calling (f val-in-result val-in-latter)."
{:added "1.0"
:static true}
[f & maps]
(when (some identity maps)
(let [merge-entry (fn [m e]
(let [k (key e) v (val e)]
(if (contains? m k)
(assoc m k (f (get m k) v))
(assoc m k v))))
merge2 (fn [m1 m2]
(reduce1 merge-entry (or m1 {}) (seq m2)))]
(reduce1 merge2 maps))))
11.1. CORE.CLJ 1223
(defn zipmap
"Returns a map with the keys mapped to the corresponding vals ."
{:added "1.0"
:static true}
[keys vals]
(loop [map {}
ks (seq keys)
vs (seq vals)]
(if (and ks vs)
(recur (assoc map (first ks) (first vs))
(next ks)
(next vs))
map)))
(defmacro declare
"defs the supplied var names with no bindings,
useful for making forward declarations."
{:added "1.0"}
[& names]
‘(do
~@(map #(list ’def (vary-meta % assoc :declared true)) name s)))
(defn line-seq
"Returns the lines of text from rdr as a lazy sequence of strin gs.
rdr must implement java.io.BufferedReader."
{:added "1.0"
:static true}
[^java.io.BufferedReader rdr]
(when-let [line (.readLine rdr)]
(cons line (lazy-seq (line-seq rdr)))))
(defn comparator
"Returns an implementation of java.util.Comparator based upon pred."
{:added "1.0"
:static true}
[pred]
(fn [x y]
(cond (pred x y) -1 (pred y x) 1 :else 0)))
(defn sort
"Returns a sorted sequence of the items in coll. If no compara tor is
supplied, uses compare. comparator must
implement java.util.Comparator."
{:added "1.0"
:static true}
([coll]
(sort compare coll))
([^java.util.Comparator comp coll]
(if (seq coll)
(let [a (to-array coll)]
1224 CHAPTER 11. CLJ/CLOJURE/
(. java.util.Arrays (sort a comp))
(seq a))
())))
(defn sort-by
"Returns a sorted sequence of the items in coll, where the sor t
order is determined by comparing (keyfn item). If no compara tor is
supplied, uses compare. comparator must
implement java.util.Comparator."
{:added "1.0"
:static true}
([keyfn coll]
(sort-by keyfn compare coll))
([keyfn ^java.util.Comparator comp coll]
(sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)) )
(defn partition
"Returns a lazy sequence of lists of n items each, at offsets s tep
apart. If step is not supplied, defaults to n, i.e. the partit ions
do not overlap. If a pad collection is supplied, use its eleme nts
as necessary to complete last partition upto n items. In case
there are not enough padding elements, return a partition wi th
less than n items."
{:added "1.0"
:static true}
([n coll]
(partition n n coll))
([n step coll]
(lazy-seq
(when-let [s (seq coll)]
(let [p (take n s)]
(when (= n (count p))
(cons p (partition n step (drop step s))))))))
([n step pad coll]
(lazy-seq
(when-let [s (seq coll)]
(let [p (take n s)]
(if (= n (count p))
(cons p (partition n step pad (drop step s)))
(list (take n (concat p pad)))))))))
;; evaluation
(defn eval
"Evaluates the form data structure (not text!) and returns t he result."
{:added "1.0"
:static true}
[form] (. clojure.lang.Compiler (eval form)))
(defmacro doseq
11.1. CORE.CLJ 1225
"Repeatedly executes body (presumably for side-effects) w ith
bindings and filtering as provided by \"for\". Does not reta in
the head of the sequence. Returns nil."
{:added "1.0"}
[seq-exprs & body]
(assert-args doseq
(vector? seq-exprs) "a vector for its binding"
(even? (count seq-exprs))
"an even number of forms in binding vector")
(let [step (fn step [recform exprs]
(if-not exprs
[true ‘(do ~@body)]
(let [k (first exprs)
v (second exprs)]
(if (keyword? k)
(let [steppair (step recform (nnext exprs))
needrec (steppair 0)
subform (steppair 1)]
(cond
(= k :let) [needrec ‘(let ~v ~subform)]
(= k :while)
[false ‘(when ~v
~subform
~@(when needrec [recform]))]
(= k :when)
[false ‘(if ~v
(do
~subform
~@(when needrec [recform]))
~recform)]))
(let [seq- (gensym "seq_")
chunk-
(with-meta (gensym "chunk_")
{:tag ’clojure.lang.IChunk})
count- (gensym "count_")
i- (gensym "i_")
recform ‘(recur (next ~seq-) nil 0 0)
steppair (step recform (nnext exprs))
needrec (steppair 0)
subform (steppair 1)
recform-chunk
‘(recur ~seq- ~chunk- ~count-
(unchecked-inc ~i-))
steppair-chunk
(step recform-chunk (nnext exprs))
subform-chunk (steppair-chunk 1)]
[true
‘(loop [~seq- (seq ~v), ~chunk- nil,
~count- 0, ~i- 0]
(if (< ~i- ~count-)
1226 CHAPTER 11. CLJ/CLOJURE/
(let [~k (.nth ~chunk- ~i-)]
~subform-chunk
~@(when needrec [recform-chunk]))
(when-let [~seq- (seq ~seq-)]
(if (chunked-seq? ~seq-)
(let [c# (chunk-first ~seq-)]
(recur (chunk-rest ~seq-) c#
(int (count c#)) (int 0)))
(let [~k (first ~seq-)]
~subform
~@(when needrec [recform]))))))])))))]
(nth (step nil (seq seq-exprs)) 1)))
(defn dorun
"When lazy sequences are produced via functions that have si de
effects, any effects other than those needed to produce the f irst
element in the seq do not occur until the seq is consumed. doru n can
be used to force any effects. Walks through the successive ne xts of
the seq, does not retain the head and returns nil."
{:added "1.0"
:static true}
([coll]
(when (seq coll)
(recur (next coll))))
([n coll]
(when (and (seq coll) (pos? n))
(recur (dec n) (next coll)))))
(defn doall
"When lazy sequences are produced via functions that have si de
effects, any effects other than those needed to produce the f irst
element in the seq do not occur until the seq is consumed. doal l can
be used to force any effects. Walks through the successive ne xts of
the seq, retains the head and returns it, thus causing the ent ire
seq to reside in memory at one time."
{:added "1.0"
:static true}
([coll]
(dorun coll)
coll)
([n coll]
(dorun n coll)
coll))
(defn await
"Blocks the current thread (indefinitely!) until all actio ns
dispatched thus far, from this thread or agent, to the agent( s) have
occurred. Will block on failed agents. Will never return if
a failed agent is restarted with :clear-actions true."
{:added "1.0"
11.1. CORE.CLJ 1227
:static true}
[& agents]
(io! "await in transaction"
(when *agent*
(throw (new Exception "Can’t await in agent action")))
(let [latch (new java.util.concurrent.CountDownLatch (c ount agents))
count-down (fn [agent] (. latch (countDown)) agent)]
(doseq [agent agents]
(send agent count-down))
(. latch (await)))))
(defn ^:static await1 [^clojure.lang.Agent a]
(when (pos? (.getQueueCount a))
(await a))
a)
(defn await-for
"Blocks the current thread until all actions dispatched thu s
far (from this thread or agent) to the agents have occurred, o r the
timeout (in milliseconds) has elapsed. Returns nil if retur ning due
to timeout, non-nil otherwise."
{:added "1.0"
:static true}
[timeout-ms & agents]
(io! "await-for in transaction"
(when *agent*
(throw (new Exception "Can’t await in agent action")))
(let [latch (new java.util.concurrent.CountDownLatch (c ount agents))
count-down (fn [agent] (. latch (countDown)) agent)]
(doseq [agent agents]
(send agent count-down))
(. latch
(await timeout-ms
(. java.util.concurrent.TimeUnit MILLISECONDS))))))
(defmacro dotimes
"bindings => name n
Repeatedly executes body (presumably for side-effects) wi th name
bound to integers from 0 through n-1."
{:added "1.0"}
[bindings & body]
(assert-args dotimes
(vector? bindings) "a vector for its binding"
(= 2 (count bindings)) "exactly 2 forms in binding vector")
(let [i (first bindings)
n (second bindings)]
‘(let [n# (long ~n)]
(loop [~i 0]
(when (< ~i n#)
1228 CHAPTER 11. CLJ/CLOJURE/
~@body
(recur (unchecked-inc ~i)))))))
#_(defn into
"Returns a new coll consisting of to-coll with all of the item s of
from-coll conjoined."
{:added "1.0"}
[to from]
(let [ret to items (seq from)]
(if items
(recur (conj ret (first items)) (next items))
ret)))
;;;;;;;;;;;;;;;;;;;;; editable collections ;;;;;;;;;;; ;;;;;;;;;;;;;;;;;
\getchunk{defn transient}
\getchunk{defn persistent!}
\getchunk{defn conj!}
\getchunk{defn assoc!}
\getchunk{defn dissoc!}
\getchunk{defn pop!}
\getchunk{defn disj!}
;redef into with batch support
(defn ^:private into1
"Returns a new coll consisting of to-coll with all of the item s of
from-coll conjoined."
{:added "1.0"
:static true}
[to from]
(if (instance? clojure.lang.IEditableCollection to)
(persistent! (reduce1 conj! (transient to) from))
(reduce1 conj to from)))
(defmacro import
"import-list => (package-symbol class-name-symbols*)
For each name in class-name-symbols, adds a mapping from nam e to the
class named by package.name to the current namespace. Use :i mport
in the ns macro in preference to calling this directly."
{:added "1.0"}
[& import-symbols-or-lists]
(let [specs (map #(if (and (seq? %) (= ’quote (first %))) (sec ond %) %)
import-symbols-or-lists)]
‘(do ~@(map #(list ’clojure.core/import* %)
11.1. CORE.CLJ 1229
(reduce1 (fn [v spec]
(if (symbol? spec)
(conj v (name spec))
(let [p (first spec) cs (rest spec)]
(into1 v (map #(str p "." %) cs)))))
[] specs)))))
(defn into-array
"Returns an array with components set to the values in aseq. T he
array’s component type is type if provided, or the type of the
first value in aseq if present, or Object. All values in aseq
must be compatible with the component type. Class objects fo r
must be compatible with the primitive types can be obtained
using, e.g., Integer/TYPE."
{:added "1.0"
:static true}
([aseq]
(clojure.lang.RT/seqToTypedArray (seq aseq)))
([type aseq]
(clojure.lang.RT/seqToTypedArray type (seq aseq))))
(defn ^{:private true}
array [& items]
(into-array items))
(defn class
"Returns the Class of x"
{:added "1.0"
:static true}
^Class [^Object x] (if (nil? x) x (. x (getClass))))
(defn type
"Returns the :type metadata of x, or its Class if none"
{:added "1.0"
:static true}
[x]
(or (get (meta x) :type) (class x)))
(defn num
"Coerce to Number"
{:tag Number
:inline (fn [x] ‘(. clojure.lang.Numbers (num ~x)))
:added "1.0"}
[x] (. clojure.lang.Numbers (num x)))
(defn long
"Coerce to long"
{:inline (fn [x] ‘(. clojure.lang.RT (longCast ~x)))
:added "1.0"}
[^Number x] (clojure.lang.RT/longCast x))
1230 CHAPTER 11. CLJ/CLOJURE/
(defn float
"Coerce to float"
{:inline (fn [x]
‘(. clojure.lang.RT
(~(if *unchecked-math* ’uncheckedFloatCast ’floatCast) ~x)))
:added "1.0"}
[^Number x] (clojure.lang.RT/floatCast x))
(defn double
"Coerce to double"
{:inline (fn [x] ‘(. clojure.lang.RT (doubleCast ~x)))
:added "1.0"}
[^Number x] (clojure.lang.RT/doubleCast x))
(defn short
"Coerce to short"
{:inline
(fn [x]
‘(. clojure.lang.RT
(~(if *unchecked-math* ’uncheckedShortCast ’shortCast) ~x)))
:added "1.0"}
[^Number x] (clojure.lang.RT/shortCast x))
(defn byte
"Coerce to byte"
{:inline
(fn [x]
‘(. clojure.lang.RT
(~(if *unchecked-math* ’uncheckedByteCast ’byteCast) ~x )))
:added "1.0"}
[^Number x] (clojure.lang.RT/byteCast x))
(defn char
"Coerce to char"
{:inline
(fn [x]
‘(. clojure.lang.RT
(~(if *unchecked-math* ’uncheckedCharCast ’charCast) ~x )))
:added "1.1"}
[x] (. clojure.lang.RT (charCast x)))
(defn boolean
"Coerce to boolean"
{
:inline (fn [x] ‘(. clojure.lang.RT (booleanCast ~x)))
:added "1.0"}
[x] (clojure.lang.RT/booleanCast x))
(defn unchecked-byte
11.1. CORE.CLJ 1231
"Coerce to byte. Subject to rounding or truncation."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedByteCast ~ x)))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedByteCast x))
(defn unchecked-short
"Coerce to short. Subject to rounding or truncation."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedShortCast ~x)))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedShortCast x))
(defn unchecked-char
"Coerce to char. Subject to rounding or truncation."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedCharCast ~ x)))
:added "1.3"}
[x] (. clojure.lang.RT (uncheckedCharCast x)))
(defn unchecked-int
"Coerce to int. Subject to rounding or truncation."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedIntCast ~x )))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedIntCast x))
(defn unchecked-long
"Coerce to long. Subject to rounding or truncation."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedLongCast ~ x)))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedLongCast x))
(defn unchecked-float
"Coerce to float. Subject to rounding."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedFloatCast ~x)))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedFloatCast x))
(defn unchecked-double
"Coerce to double. Subject to rounding."
{:inline (fn [x] ‘(. clojure.lang.RT (uncheckedDoubleCas t ~x)))
:added "1.3"}
[^Number x] (clojure.lang.RT/uncheckedDoubleCast x))
(defn number?
"Returns true if x is a Number"
{:added "1.0"
:static true}
[x]
(instance? Number x))
(defn integer?
1232 CHAPTER 11. CLJ/CLOJURE/
"Returns true if n is an integer"
{:added "1.0"
:static true}
[n]
(or (instance? Integer n)
(instance? Long n)
(instance? clojure.lang.BigInt n)
(instance? BigInteger n)
(instance? Short n)
(instance? Byte n)))
(defn mod
"Modulus of num and div. Truncates toward negative infinity ."
{:added "1.0"
:static true}
[num div]
(let [m (rem num div)]
(if (or (zero? m) (pos? (* num div)))
m
(+ m div))))
(defn ratio?
"Returns true if n is a Ratio"
{:added "1.0"
:static true}
[n] (instance? clojure.lang.Ratio n))
(defn numerator
"Returns the numerator part of a Ratio."
{:tag BigInteger
:added "1.2"
:static true}
[r]
(.numerator ^clojure.lang.Ratio r))
(defn denominator
"Returns the denominator part of a Ratio."
{:tag BigInteger
:added "1.2"
:static true}
[r]
(.denominator ^clojure.lang.Ratio r))
(defn decimal?
"Returns true if n is a BigDecimal"
{:added "1.0"
:static true}
[n] (instance? BigDecimal n))
(defn float?
11.1. CORE.CLJ 1233
"Returns true if n is a floating point number"
{:added "1.0"
:static true}
[n]
(or (instance? Double n)
(instance? Float n)))
(defn rational? [n]
"Returns true if n is a rational number"
{:added "1.0"
:static true}
(or (integer? n) (ratio? n) (decimal? n)))
(defn bigint
"Coerce to BigInt"
{:tag clojure.lang.BigInt
:static true
:added "1.3"}
[x] (cond
(instance? clojure.lang.BigInt x) x
(instance? BigInteger x) (clojure.lang.BigInt/fromBigI nteger x)
(decimal? x) (bigint (.toBigInteger ^BigDecimal x))
(ratio? x) (bigint (.bigIntegerValue ^clojure.lang.Rati o x))
(number? x) (clojure.lang.BigInt/valueOf (long x))
:else (bigint (BigInteger. x))))
(defn biginteger
"Coerce to BigInteger"
{:tag BigInteger
:added "1.0"
:static true}
[x] (cond
(instance? BigInteger x) x
(instance? clojure.lang.BigInt x)
(.toBigInteger ^clojure.lang.BigInt x)
(decimal? x) (.toBigInteger ^BigDecimal x)
(ratio? x) (.bigIntegerValue ^clojure.lang.Ratio x)
(number? x) (BigInteger/valueOf (long x))
:else (BigInteger. x)))
(defn bigdec
"Coerce to BigDecimal"
{:tag BigDecimal
:added "1.0"
:static true}
[x] (cond
(decimal? x) x
(float? x) (. BigDecimal valueOf (double x))
(ratio? x) (/ (BigDecimal. (.numerator x)) (.denominator x ))
(instance? BigInteger x) (BigDecimal. ^BigInteger x)
1234 CHAPTER 11. CLJ/CLOJURE/
(number? x) (BigDecimal/valueOf (long x))
:else (BigDecimal. x)))
(def ^:dynamic ^{:private true} print-initialized false)
(defmulti print-method (fn [x writer] (type x)))
(defmulti print-dup (fn [x writer] (class x)))
(defn pr-on
{:private true
:static true}
[x w]
(if *print-dup*
(print-dup x w)
(print-method x w))
nil)
(defn pr
"Prints the object(s) to the output stream that is the curren t value
of *out*. Prints the object(s), separated by spaces if there is
more than one. By default, pr and prn print in a way that object s
can be read by the reader"
{:dynamic true
:added "1.0"}
([] nil)
([x]
(pr-on x *out*))
([x & more]
(pr x)
(. *out* (append \space))
(if-let [nmore (next more)]
(recur (first more) nmore)
(apply pr more))))
(def ^:private ^String system-newline
(System/getProperty "line.separator"))
(defn newline
"Writes a platform-specific newline to *out*"
{:added "1.0"
:static true}
[]
(. *out* (append system-newline))
nil)
(defn flush
"Flushes the output stream that is the current value of
*out*"
{:added "1.0"
:static true}
11.1. CORE.CLJ 1235
[]
(. *out* (flush))
nil)
(defn prn
"Same as pr followed by (newline). Observes *flush-on-newl ine*"
{:added "1.0"
:static true}
[& more]
(apply pr more)
(newline)
(when *flush-on-newline*
(flush)))
(defn print
"Prints the object(s) to the output stream that is the curren t value
of *out*. print and println produce output for human consump tion."
{:added "1.0"
:static true}
[& more]
(binding [*print-readably* nil]
(apply pr more)))
(defn println
"Same as print followed by (newline)"
{:added "1.0"
:static true}
[& more]
(binding [*print-readably* nil]
(apply prn more)))
(defn read
"Reads the next object from stream, which must be an instance of
java.io.PushbackReader or some derivee. stream defaults t o the
current value of *in* ."
{:added "1.0"
:static true}
([]
(read *in*))
([stream]
(read stream true nil))
([stream eof-error? eof-value]
(read stream eof-error? eof-value false))
([stream eof-error? eof-value recursive?]
(. clojure.lang.LispReader
(read stream (boolean eof-error?) eof-value recursive?)) ))
(defn read-line
"Reads the next line from stream that is the current value of * in* ."
{:added "1.0"
1236 CHAPTER 11. CLJ/CLOJURE/
:static true}
[]
(if (instance? clojure.lang.LineNumberingPushbackRead er *in*)
(.readLine ^clojure.lang.LineNumberingPushbackReader *in*)
(.readLine ^java.io.BufferedReader *in*)))
(defn read-string
"Reads one object from the string s"
{:added "1.0"
:static true}
[s] (clojure.lang.RT/readString s))
(defn subvec
"Returns a persistent vector of the items in vector from
start (inclusive) to end (exclusive). If end is not supplied ,
defaults to (count vector). This operation is O(1) and very f ast, as
the resulting vector shares structure with the original and no
trimming is done."
{:added "1.0"
:static true}
([v start]
(subvec v start (count v)))
([v start end]
(. clojure.lang.RT (subvec v start end))))
(defmacro with-open
"bindings => [name init ...]
Evaluates body in a try expression with names bound to the val ues
of the inits, and a finally clause that calls (.close name) on each
name in reverse order."
{:added "1.0"}
[bindings & body]
(assert-args with-open
(vector? bindings) "a vector for its binding"
(even? (count bindings))
"an even number of forms in binding vector")
(cond
(= (count bindings) 0) ‘(do ~@body)
(symbol? (bindings 0)) ‘(let ~(subvec bindings 0 2)
(try
(with-open ~(subvec bindings 2) ~@body)
(finally
(. ~(bindings 0) close))))
:else (throw (IllegalArgumentException.
"with-open only allows Symbols in bindings"))))
(defmacro doto
"Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments. The fo rms
11.1. CORE.CLJ 1237
are evaluated in order. Returns x.
(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2) )"
{:added "1.0"}
[x & forms]
(let [gx (gensym)]
‘(let [~gx ~x]
~@(map (fn [f]
(if (seq? f)
‘(~(first f) ~gx ~@(next f))
‘(~f ~gx)))
forms)
~gx)))
(defmacro memfn
"Expands into code that creates a fn that expects to be passed an
object and any args and calls the named instance method on the
object passing the args. Use when you want to treat a Java meth od as
a first-class fn."
{:added "1.0"}
[name & args]
‘(fn [target# ~@args]
(. target# (~name ~@args))))
(defmacro time
"Evaluates expr and prints the time it took. Returns the valu e of
expr."
{:added "1.0"}
[expr]
‘(let [start# (. System (nanoTime))
ret# ~expr]
(prn (str "Elapsed time: "
(/ (double (- (. System (nanoTime)) start#)) 1000000.0)
" msecs"))
ret#))
(import ’(java.lang.reflect Array))
(defn alength
"Returns the length of the Java array. Works on arrays of all
types."
{:inline (fn [a] ‘(. clojure.lang.RT (alength ~a)))
:added "1.0"}
[array] (. clojure.lang.RT (alength array)))
(defn aclone
"Returns a clone of the Java array. Works on arrays of known
types."
1238 CHAPTER 11. CLJ/CLOJURE/
{:inline (fn [a] ‘(. clojure.lang.RT (aclone ~a)))
:added "1.0"}
[array] (. clojure.lang.RT (aclone array)))
(defn aget
"Returns the value at the index/indices. Works on Java array s of all
types."
{:inline (fn [a i] ‘(. clojure.lang.RT (aget ~a (int ~i))))
:inline-arities #{2}
:added "1.0"}
([array idx]
(clojure.lang.Reflector/prepRet
(.getComponentType (class array)) (. Array (get array idx) )))
([array idx & idxs]
(apply aget (aget array idx) idxs)))
(defn aset
"Sets the value at the index/indices. Works on Java arrays of
reference types. Returns val."
{:inline (fn [a i v] ‘(. clojure.lang.RT (aset ~a (int ~i) ~v) ))
:inline-arities #{3}
:added "1.0"}
([array idx val]
(. Array (set array idx val))
val)
([array idx idx2 & idxv]
(apply aset (aget array idx) idx2 idxv)))
(defmacro
^{:private true}
def-aset [name method coerce]
‘(defn ~name
{:arglists
’([~’array ~’idx ~’val] [~’array ~’idx ~’idx2 & ~’idxv])}
([array# idx# val#]
(. Array (~method array# idx# (~coerce val#)))
val#)
([array# idx# idx2# & idxv#]
(apply ~name (aget array# idx#) idx2# idxv#))))
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of int. Returns val."
:added "1.0"}
aset-int setInt int)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of long. Returns val."
:added "1.0"}
11.1. CORE.CLJ 1239
aset-long setLong long)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of boolean. Returns val."
:added "1.0"}
aset-boolean setBoolean boolean)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of float. Returns val."
:added "1.0"}
aset-float setFloat float)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of double. Returns val."
:added "1.0"}
aset-double setDouble double)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of short. Returns val."
:added "1.0"}
aset-short setShort short)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of byte. Returns val."
:added "1.0"}
aset-byte setByte byte)
(def-aset
^{:doc "Sets the value at the index/indices.
Works on arrays of char. Returns val."
:added "1.0"}
aset-char setChar char)
(defn make-array
"Creates and returns an array of instances of the specified c lass of
the specified dimension(s). Note that a class object is requ ired.
Class objects can be obtained by using their imported or
fully-qualified name. Class objects for the primitive type s can be
obtained using, e.g., Integer/TYPE."
{:added "1.0"
:static true}
([^Class type len]
(. Array (newInstance type (int len))))
([^Class type dim & more-dims]
(let [dims (cons dim more-dims)
1240 CHAPTER 11. CLJ/CLOJURE/
^"[I" dimarray (make-array (. Integer TYPE) (count dims))]
(dotimes [i (alength dimarray)]
(aset-int dimarray i (nth dims i)))
(. Array (newInstance type dimarray)))))
(defn to-array-2d
"Returns a (potentially-ragged) 2-dimensional array of Ob jects
containing the contents of coll, which can be any Collection of any
Collection."
{:tag "[[Ljava.lang.Object;"
:added "1.0"
:static true}
[^java.util.Collection coll]
(let
[ret
(make-array
(. Class (forName "[Ljava.lang.Object;"))
(. coll (size)))]
(loop [i 0 xs (seq coll)]
(when xs
(aset ret i (to-array (first xs)))
(recur (inc i) (next xs))))
ret))
(defn macroexpand-1
"If form represents a macro form, returns its expansion,
else returns form."
{:added "1.0"
:static true}
[form]
(. clojure.lang.Compiler (macroexpand1 form)))
(defn macroexpand
"Repeatedly calls macroexpand-1 on form until it no longer
represents a macro form, then returns it. Note neither
macroexpand-1 nor macroexpand expand macros in subforms."
{:added "1.0"
:static true}
[form]
(let [ex (macroexpand-1 form)]
(if (identical? ex form)
form
(macroexpand ex))))
(defn create-struct
"Returns a structure basis object."
{:added "1.0"
:static true}
[& keys]
(. clojure.lang.PersistentStructMap (createSlotMap key s)))
11.1. CORE.CLJ 1241
(defmacro defstruct
"Same as (def name (create-struct keys...))"
{:added "1.0"
:static true}
[name & keys]
‘(def ~name (create-struct ~@keys)))
(defn struct-map
"Returns a new structmap instance with the keys of the
structure-basis. keyvals may contain all, some or none of th e basis
keys - where values are not supplied they will default to nil.
keyvals can also contain keys not in the basis."
{:added "1.0"
:static true}
[s & inits]
(. clojure.lang.PersistentStructMap (create s inits)))
(defn struct
"Returns a new structmap instance with the keys of the
structure-basis. vals must be supplied for basis keys in ord er -
where values are not supplied they will default to nil."
{:added "1.0"
:static true}
[s & vals]
(. clojure.lang.PersistentStructMap (construct s vals)) )
(defn accessor
"Returns a fn that, given an instance of a structmap with the b asis,
returns the value at the key. The key must be in the basis. The
returned function should be (slightly) more efficient than using
get, but such use of accessors should be limited to known
performance-critical areas."
{:added "1.0"
:static true}
[s key]
(. clojure.lang.PersistentStructMap (getAccessor s key) ))
(defn load-reader
"Sequentially read and evaluate the set of forms contained i n the
stream/file"
{:added "1.0"
:static true}
[rdr] (. clojure.lang.Compiler (load rdr)))
(defn load-string
"Sequentially read and evaluate the set of forms contained i n the
string"
{:added "1.0"
:static true}
1242 CHAPTER 11. CLJ/CLOJURE/
[s]
(let [rdr (-> (java.io.StringReader. s)
(clojure.lang.LineNumberingPushbackReader.))]
(load-reader rdr)))
(defn set
"Returns a set of the distinct elements of coll."
{:added "1.0"
:static true}
[coll] (clojure.lang.PersistentHashSet/create (seq col l)))
(defn ^{:private true
:static true}
filter-key [keyfn pred amap]
(loop [ret {} es (seq amap)]
(if es
(if (pred (keyfn (first es)))
(recur (assoc ret (key (first es)) (val (first es))) (next es ))
(recur ret (next es)))
ret)))
(defn find-ns
"Returns the namespace named by the symbol or nil if it doesn’ t exist."
{:added "1.0"
:static true}
[sym] (clojure.lang.Namespace/find sym))
(defn create-ns
"Create a new namespace named by the symbol if one doesn’t alr eady
exist, returns it or the already-existing namespace of the s ame
name."
{:added "1.0"
:static true}
[sym] (clojure.lang.Namespace/findOrCreate sym))
(defn remove-ns
"Removes the namespace named by the symbol. Use with caution .
Cannot be used to remove the clojure namespace."
{:added "1.0"
:static true}
[sym] (clojure.lang.Namespace/remove sym))
(defn all-ns
"Returns a sequence of all namespaces."
{:added "1.0"
:static true}
[] (clojure.lang.Namespace/all))
(defn the-ns
"If passed a namespace, returns it. Else, when passed a symbo l,
11.1. CORE.CLJ 1243
returns the namespace named by it, throwing an exception if n ot
found."
{:added "1.0"
:static true}
^clojure.lang.Namespace [x]
(if (instance? clojure.lang.Namespace x)
x
(or (find-ns x)
(throw (Exception. (str "No namespace: " x " found"))))))
(defn ns-name
"Returns the name of the namespace, a symbol."
{:added "1.0"
:static true}
[ns]
(.getName (the-ns ns)))
(defn ns-map
"Returns a map of all the mappings for the namespace."
{:added "1.0"
:static true}
[ns]
(.getMappings (the-ns ns)))
(defn ns-unmap
"Removes the mappings for the symbol from the namespace."
{:added "1.0"
:static true}
[ns sym]
(.unmap (the-ns ns) sym))
;(defn export [syms]
; (doseq [sym syms]
; (.. *ns* (intern sym) (setExported true))))
(defn ns-publics
"Returns a map of the public intern mappings for the namespac e."
{:added "1.0"
:static true}
[ns]
(let [ns (the-ns ns)]
(filter-key val
(fn [^clojure.lang.Var v] (and (instance? clojure.lang.V ar v)
(= ns (.ns v))
(.isPublic v)))
(ns-map ns))))
(defn ns-imports
"Returns a map of the import mappings for the namespace."
{:added "1.0"
1244 CHAPTER 11. CLJ/CLOJURE/
:static true}
[ns]
(filter-key val (partial instance? Class) (ns-map ns)))
(defn ns-interns
"Returns a map of the intern mappings for the namespace."
{:added "1.0"
:static true}
[ns]
(let [ns (the-ns ns)]
(filter-key val
(fn [^clojure.lang.Var v] (and (instance? clojure.lang.V ar v)
(= ns (.ns v))))
(ns-map ns))))
(defn refer
"refers to all public vars of ns, subject to filters.
filters can include at most one each of:
:exclude list-of-symbols
:only list-of-symbols
:rename map-of-fromsymbol-tosymbol
For each public interned var in the namespace named by the sym bol,
adds a mapping from the name of the var to the var to the current
namespace. Throws an exception if name is already mapped to
something else in the current namespace. Filters can be used to
select a subset, via inclusion or exclusion, or to provide a m apping
to a symbol different from the var’s name, in order to prevent
clashes. Use :use in the ns macro in preference to calling thi s
directly."
{:added "1.0"}
[ns-sym & filters]
(let [ns (or (find-ns ns-sym)
(throw (new Exception (str "No namespace: " ns-sym))))
fs (apply hash-map filters)
nspublics (ns-publics ns)
rename (or (:rename fs) {})
exclude (set (:exclude fs))
to-do (or (:only fs) (keys nspublics))]
(doseq [sym to-do]
(when-not (exclude sym)
(let [v (nspublics sym)]
(when-not v
(throw (new java.lang.IllegalAccessError
(if (get (ns-interns ns) sym)
(str sym " is not public")
(str sym " does not exist")))))
(. *ns* (refer (or (rename sym) sym) v)))))))
11.1. CORE.CLJ 1245
(defn ns-refers
"Returns a map of the refer mappings for the namespace."
{:added "1.0"
:static true}
[ns]
(let [ns (the-ns ns)]
(filter-key val
(fn [^clojure.lang.Var v] (and (instance? clojure.lang.V ar v)
(not= ns (.ns v))))
(ns-map ns))))
(defn alias
"Add an alias in the current namespace to another
namespace. Arguments are two symbols: the alias to be used, a nd
the symbolic name of the target namespace. Use :as in the ns ma cro
in preference to calling this directly."
{:added "1.0"
:static true}
[alias namespace-sym]
(.addAlias *ns* alias (the-ns namespace-sym)))
(defn ns-aliases
"Returns a map of the aliases for the namespace."
{:added "1.0"
:static true}
[ns]
(.getAliases (the-ns ns)))
(defn ns-unalias
"Removes the alias for the symbol from the namespace."
{:added "1.0"
:static true}
[ns sym]
(.removeAlias (the-ns ns) sym))
(defn take-nth
"Returns a lazy seq of every nth item in coll."
{:added "1.0"
:static true}
[n coll]
(lazy-seq
(when-let [s (seq coll)]
(cons (first s) (take-nth n (drop n s))))))
(defn interleave
"Returns a lazy seq of the first item in each coll, then the
second etc."
{:added "1.0"
:static true}
([c1 c2]
1246 CHAPTER 11. CLJ/CLOJURE/
(lazy-seq
(let [s1 (seq c1) s2 (seq c2)]
(when (and s1 s2)
(cons (first s1) (cons (first s2)
(interleave (rest s1) (rest s2))))))))
([c1 c2 & colls]
(lazy-seq
(let [ss (map seq (conj colls c2 c1))]
(when (every? identity ss)
(concat (map first ss) (apply interleave (map rest ss)))))) ))
(defn var-get
"Gets the value in the var object"
{:added "1.0"
:static true}
[^clojure.lang.Var x] (. x (get)))
(defn var-set
"Sets the value in the var object to val. The var must be
thread-locally bound."
{:added "1.0"
:static true}
[^clojure.lang.Var x val] (. x (set val)))
(defmacro with-local-vars
"varbinding=> symbol init-expr
Executes the exprs in a context in which the symbols are bound to
vars with per-thread bindings to the init-exprs. The symbol s refer
to the var objects themselves, and must be accessed with var- get and
var-set"
{:added "1.0"}
[name-vals-vec & body]
(assert-args with-local-vars
(vector? name-vals-vec) "a vector for its binding"
(even? (count name-vals-vec))
"an even number of forms in binding vector")
‘(let [~@(interleave
(take-nth 2 name-vals-vec)
(repeat ’(.. clojure.lang.Var create setDynamic)))]
(. clojure.lang.Var
(pushThreadBindings (hash-map ~@name-vals-vec)))
(try
~@body
(finally (. clojure.lang.Var (popThreadBindings))))))
(defn ns-resolve
"Returns the var or Class to which a symbol will be resolved in the
namespace (unless found in the environement), else nil. Not e that
if the symbol is fully qualified, the var/Class to which it re solves
11.1. CORE.CLJ 1247
need not be present in the namespace."
{:added "1.0"
:static true}
([ns sym]
(ns-resolve ns nil sym))
([ns env sym]
(when-not (contains? env sym)
(clojure.lang.Compiler/maybeResolveIn (the-ns ns) sym) )))
(defn resolve
"same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env s ymbol)"
{:added "1.0"
:static true}
([sym] (ns-resolve *ns* sym))
([env sym] (ns-resolve *ns* env sym)))
(defn array-map
"Constructs an array-map."
{:added "1.0"
:static true}
([] (. clojure.lang.PersistentArrayMap EMPTY))
([& keyvals]
(clojure.lang.PersistentArrayMap/createWithCheck
(to-array keyvals))))
(defn nthnext
"Returns the nth next of coll, (seq coll) when n is 0."
{:added "1.0"
:static true}
[coll n]
(loop [n n xs (seq coll)]
(if (and xs (pos? n))
(recur (dec n) (next xs))
xs)))
;redefine let and loop with destructuring
(defn destructure [bindings]
(let [bents (partition 2 bindings)
pb (fn pb [bvec b v]
(let [pvec
(fn [bvec b val]
(let [gvec (gensym "vec__")]
(loop [ret (-> bvec (conj gvec) (conj val))
n 0
bs b
seen-rest? false]
(if (seq bs)
(let [firstb (first bs)]
(cond
1248 CHAPTER 11. CLJ/CLOJURE/
(= firstb ’&)
(recur
(pb ret
(second bs)
(list ‘nthnext gvec n))
n
(nnext bs)
true)
(= firstb :as) (pb ret (second bs) gvec)
:else (if seen-rest?
(throw (new Exception
"Unsupported binding form, only :as can follow & parameter" ))
(recur
(pb ret firstb
(list ‘nth gvec n nil))
(inc n)
(next bs)
seen-rest?))))
ret))))
pmap
(fn [bvec b v]
(let [gmap (or (:as b) (gensym "map__"))
defaults (:or b)]
(loop [ret (-> bvec (conj gmap) (conj v)
(conj gmap)
(conj
‘(if (seq? ~gmap)
(apply hash-map ~gmap)
~gmap)))
bes (reduce1
(fn [bes entry]
(reduce1
#(assoc %1 %2 ((val entry) %2))
(dissoc bes (key entry))
((key entry) bes)))
(dissoc b :as :or)
{:keys
#(keyword (str %)),
:strs str,
:syms #(list ‘quote %)})]
(if (seq bes)
(let [bb (key (first bes))
bk (val (first bes))
has-default (contains? defaults bb)]
(recur (pb ret bb
(if has-default
(list ‘get gmap bk (defaults bb))
(list ‘get gmap bk)))
(next bes)))
ret))))]
11.1. CORE.CLJ 1249
(cond
(symbol? b) (-> bvec (conj b) (conj v))
(vector? b) (pvec bvec b v)
(map? b) (pmap bvec b v)
:else
(throw
(new Exception
(str "Unsupported binding form: " b))))))
process-entry (fn [bvec b] (pb bvec (first b) (second b)))]
(if (every? symbol? (map first bents))
bindings
(reduce1 process-entry [] bents))))
(defmacro let
"binding => binding-form init-expr
Evaluates the exprs in a lexical context in which the symbols in
the binding-forms are bound to their respective init-exprs or parts
therein."
{:added "1.0", :special-form true,
:forms ’[(let [bindings*] exprs*)]}
[bindings & body]
(assert-args let
(vector? bindings) "a vector for its binding"
(even? (count bindings))
"an even number of forms in binding vector")
‘(let* ~(destructure bindings) ~@body))
(defn ^{:private true}
maybe-destructured
[params body]
(if (every? symbol? params)
(cons params body)
(loop [params params
new-params []
lets []]
(if params
(if (symbol? (first params))
(recur (next params) (conj new-params (first params)) lets )
(let [gparam (gensym "p__")]
(recur (next params) (conj new-params gparam)
(-> lets (conj (first params)) (conj gparam)))))
‘(~new-params
(let ~lets
~@body))))))
;redefine fn with destructuring and pre/post conditions
(defmacro fn
"params => positional-params* , or positional-params* & ne xt-param
positional-param => binding-form
1250 CHAPTER 11. CLJ/CLOJURE/
next-param => binding-form
name => symbol
Defines a function"
{:added "1.0", :special-form true,
:forms
’[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*) +)]}
[& sigs]
(let [name (if (symbol? (first sigs)) (first sigs) nil)
sigs (if name (next sigs) sigs)
sigs (if (vector? (first sigs)) (list sigs) sigs)
psig (fn* [sig]
(let [[params & body] sig
conds (when (and (next body) (map? (first body)))
(first body))
body (if conds (next body) body)
conds (or conds (meta params))
pre (:pre conds)
post (:post conds)
body (if post
‘((let [~’% ~(if (< 1 (count body))
‘(do ~@body)
(first body))]
~@(map (fn* [c] ‘(assert ~c)) post)
~’%))
body)
body (if pre
(concat (map (fn* [c] ‘(assert ~c)) pre)
body)
body)]
(maybe-destructured params body)))
new-sigs (map psig sigs)]
(with-meta
(if name
(list* ’fn* name new-sigs)
(cons ’fn* new-sigs))
(meta &form))))
(defmacro loop
"Evaluates the exprs in a lexical context in which the symbol s in
the binding-forms are bound to their respective init-exprs or parts
therein. Acts as a recur target."
{:added "1.0", :special-form true, :forms ’[(loop [bindin gs*] exprs*)]}
[bindings & body]
(assert-args loop
(vector? bindings) "a vector for its binding"
(even? (count bindings))
"an even number of forms in binding vector")
(let [db (destructure bindings)]
(if (= db bindings)
11.1. CORE.CLJ 1251
‘(loop* ~bindings ~@body)
(let [vs (take-nth 2 (drop 1 bindings))
bs (take-nth 2 bindings)
gs (map (fn [b] (if (symbol? b) b (gensym))) bs)
bfs (reduce1 (fn [ret [b v g]]
(if (symbol? b)
(conj ret g v)
(conj ret g v b g)))
[] (map vector bs vs gs))]
‘(let ~bfs
(loop* ~(vec (interleave gs gs))
(let ~(vec (interleave bs gs))
~@body)))))))
(defmacro when-first
"bindings => x xs
Same as (when (seq xs) (let [x (first xs)] body))"
{:added "1.0"}
[bindings & body]
(assert-args when-first
(vector? bindings) "a vector for its binding"
(= 2 (count bindings)) "exactly 2 forms in binding vector")
(let [[x xs] bindings]
‘(when (seq ~xs)
(let [~x (first ~xs)]
~@body))))
(defmacro lazy-cat
"Expands to code which yields a lazy sequence of the concaten ation
of the supplied colls. Each coll expr is not evaluated until i t is
needed.
(lazy-cat xs ys zs) ===
(concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"
{:added "1.0"}
[& colls]
‘(concat ~@(map #(list ‘lazy-seq %) colls)))
(defmacro for
"List comprehension. Takes a vector of one or more
binding-form/collection-expr pairs, each followed by zer o or more
modifiers, and yields a lazy sequence of evaluations of expr .
Collections are iterated in a nested fashion, rightmost fas test,
and nested coll-exprs can refer to bindings created in prior
binding-forms. Supported modifiers are: :let [binding-fo rm expr ...],
:while test, :when test.
(take 100
(for [x (range 100000000) y (range 1000000) :while (< y x)]
1252 CHAPTER 11. CLJ/CLOJURE/
[x y]))"
{:added "1.0"}
[seq-exprs body-expr]
(assert-args for
(vector? seq-exprs) "a vector for its binding"
(even? (count seq-exprs))
"an even number of forms in binding vector")
(let [to-groups (fn [seq-exprs]
(reduce1 (fn [groups [k v]]
(if (keyword? k)
(conj (pop groups)
(conj (peek groups) [k v]))
(conj groups [k v])))
[] (partition 2 seq-exprs)))
err (fn [& msg]
(throw
(IllegalArgumentException.
^String (apply str msg))))
emit-bind (fn emit-bind [[[bind expr & mod-pairs]
& [[_ next-expr] :as next-groups]]]
(let [giter (gensym "iter__")
gxs (gensym "s__")
do-mod
(fn do-mod [[[k v :as pair] & etc]]
(cond
(= k :let)
‘(let ~v ~(do-mod etc))
(= k :while)
‘(when ~v ~(do-mod etc))
(= k :when) ‘(if ~v
~(do-mod etc)
(recur (rest ~gxs)))
(keyword? k)
(err "Invalid ’for’ keyword " k)
next-groups
‘(let
[iterys#
~(emit-bind next-groups)
fs#
(seq (iterys# ~next-expr))]
(if fs#
(concat fs#
(~giter (rest ~gxs)))
(recur (rest ~gxs))))
:else ‘(cons
~body-expr
(~giter (rest ~gxs)))))]
(if next-groups
#_"not the inner-most loop"
‘(fn ~giter [~gxs]
11.1. CORE.CLJ 1253
(lazy-seq
(loop [~gxs ~gxs]
(when-first [~bind ~gxs]
~(do-mod mod-pairs)))))
#_"inner-most loop"
(let [gi (gensym "i__")
gb (gensym "b__")
do-cmod
(fn do-cmod [[[k v :as pair] & etc]]
(cond
(= k :let)
‘(let ~v ~(do-cmod etc))
(= k :while)
‘(when ~v ~(do-cmod etc))
(= k :when)
‘(if ~v
~(do-cmod etc)
(recur
(unchecked-inc ~gi)))
(keyword? k)
(err
"Invalid ’for’ keyword "
k)
:else
‘(do
(chunk-append
~gb ~body-expr)
(recur
(unchecked-inc ~gi)))))]
‘(fn ~giter [~gxs]
(lazy-seq
(loop [~gxs ~gxs]
(when-let [~gxs (seq ~gxs)]
(if (chunked-seq? ~gxs)
(let [c# (chunk-first ~gxs)
size# (int (count c#))
~gb (chunk-buffer size#)]
(if
(loop [~gi (int 0)]
(if (< ~gi size#)
(let
[~bind (.nth c# ~gi)]
~(do-cmod mod-pairs))
true))
(chunk-cons
(chunk ~gb)
(~giter (chunk-rest ~gxs)))
(chunk-cons (chunk ~gb) nil)))
(let [~bind (first ~gxs)]
~(do-mod mod-pairs)))))))))))]
1254 CHAPTER 11. CLJ/CLOJURE/
‘(let [iter# ~(emit-bind (to-groups seq-exprs))]
(iter# ~(second seq-exprs)))))
(defmacro comment
"Ignores body, yields nil"
{:added "1.0"}
[& body])
(defmacro with-out-str
"Evaluates exprs in a context in which *out* is bound to a fres h
StringWriter. Returns the string created by any nested prin ting
calls."
{:added "1.0"}
[& body]
‘(let [s# (new java.io.StringWriter)]
(binding [*out* s#]
~@body
(str s#))))
(defmacro with-in-str
"Evaluates body in a context in which *in* is bound to a fresh
StringReader initialized with the string s."
{:added "1.0"}
[s & body]
‘(with-open
[s# (-> (java.io.StringReader. ~s)
clojure.lang.LineNumberingPushbackReader.)]
(binding [*in* s#]
~@body)))
(defn pr-str
"pr to a string, returning it"
{:tag String
:added "1.0"
:static true}
[& xs]
(with-out-str
(apply pr xs)))
(defn prn-str
"prn to a string, returning it"
{:tag String
:added "1.0"
:static true}
[& xs]
(with-out-str
(apply prn xs)))
(defn print-str
"print to a string, returning it"
11.1. CORE.CLJ 1255
{:tag String
:added "1.0"
:static true}
[& xs]
(with-out-str
(apply print xs)))
(defn println-str
"println to a string, returning it"
{:tag String
:added "1.0"
:static true}
[& xs]
(with-out-str
(apply println xs)))
(defmacro assert
"Evaluates expr and throws an exception if it does not evalua te to
logical true."
{:added "1.0"}
[x]
(when *assert*
‘(when-not ~x
(throw
(new AssertionError (str "Assert failed: " (pr-str ’~x)))) )))
(defn test
"test [v] finds fn at key :test in var metadata and calls it,
presuming failure will throw exception"
{:added "1.0"}
[v]
(let [f (:test (meta v))]
(if f
(do (f) :ok)
:no-test)))
(defn re-pattern
"Returns an instance of java.util.regex.Pattern, for use, e.g. in
re-matcher."
{:tag java.util.regex.Pattern
:added "1.0"
:static true}
[s] (if (instance? java.util.regex.Pattern s)
s
(. java.util.regex.Pattern (compile s))))
(defn re-matcher
"Returns an instance of java.util.regex.Matcher, for use, e.g. in
re-find."
{:tag java.util.regex.Matcher
1256 CHAPTER 11. CLJ/CLOJURE/
:added "1.0"
:static true}
[^java.util.regex.Pattern re s]
(. re (matcher s)))
(defn re-groups
"Returns the groups from the most recent match/find. If ther e are no
nested groups, returns a string of the entire match. If there are
nested groups, returns a vector of the groups, the first elem ent
being the entire match."
{:added "1.0"
:static true}
[^java.util.regex.Matcher m]
(let [gc (. m (groupCount))]
(if (zero? gc)
(. m (group))
(loop [ret [] c 0]
(if (<= c gc)
(recur (conj ret (. m (group c))) (inc c))
ret)))))
(defn re-seq
"Returns a lazy sequence of successive matches of pattern in string,
using java.util.regex.Matcher.find(), each such match pr ocessed with
re-groups."
{:added "1.0"
:static true}
[^java.util.regex.Pattern re s]
(let [m (re-matcher re s)]
((fn step []
(when (. m (find))
(cons (re-groups m) (lazy-seq (step))))))))
(defn re-matches
"Returns the match, if any, of string to pattern, using
java.util.regex.Matcher.matches(). Uses re-groups to re turn the
groups."
{:added "1.0"
:static true}
[^java.util.regex.Pattern re s]
(let [m (re-matcher re s)]
(when (. m (matches))
(re-groups m))))
(defn re-find
"Returns the next regex match, if any, of string to pattern, u sing
java.util.regex.Matcher.find(). Uses re-groups to retur n the
groups."
{:added "1.0"
11.1. CORE.CLJ 1257
:static true}
([^java.util.regex.Matcher m]
(when (. m (find))
(re-groups m)))
([^java.util.regex.Pattern re s]
(let [m (re-matcher re s)]
(re-find m))))
(defn rand
"Returns a random floating point number between 0 (inclusiv e) and
n (default 1) (exclusive)."
{:added "1.0"
:static true}
([] (. Math (random)))
([n] (* n (rand))))
(defn rand-int
"Returns a random integer between 0 (inclusive) and n (exclu sive)."
{:added "1.0"
:static true}
[n] (int (rand n)))
(defmacro defn-
"same as defn, yielding non-public def"
{:added "1.0"}
[name & decls]
(list* ‘defn (with-meta name (assoc (meta name) :private tr ue))
decls))
(defn tree-seq
"Returns a lazy sequence of the nodes in a tree, via a depth-fi rst
walk.branch? must be a fn of one arg that returns true if passe d
a node that can have children (but may not). children must be a
fn of one arg that returns a sequence of the children. Will onl y
be called on nodes for which branch? returns true. Root is the
root node of the tree."
{:added "1.0"
:static true}
[branch? children root]
(let [walk (fn walk [node]
(lazy-seq
(cons node
(when (branch? node)
(mapcat walk (children node))))))]
(walk root)))
(defn file-seq
"A tree seq on java.io.Files"
{:added "1.0"
:static true}
1258 CHAPTER 11. CLJ/CLOJURE/
[dir]
(tree-seq
(fn [^java.io.File f] (. f (isDirectory)))
(fn [^java.io.File d] (seq (. d (listFiles))))
dir))
(defn xml-seq
"A tree seq on the xml elements as per xml/parse"
{:added "1.0"
:static true}
[root]
(tree-seq
(complement string?)
(comp seq :content)
root))
(defn special-symbol?
"Returns true if s names a special form"
{:added "1.0"
:static true}
[s]
(contains? (. clojure.lang.Compiler specials) s))
(defn var?
"Returns true if v is of type clojure.lang.Var"
{:added "1.0"
:static true}
[v] (instance? clojure.lang.Var v))
(defn subs
"Returns the substring of s beginning at start inclusive, an d ending
at end (defaults to length of string), exclusive."
{:added "1.0"
:static true}
(^String [^String s start] (. s (substring start)))
(^String [^String s start end] (. s (substring start end))))
(defn max-key
"Returns the x for which (k x), a number, is greatest."
{:added "1.0"
:static true}
([k x] x)
([k x y] (if (> (k x) (k y)) x y))
([k x y & more]
(reduce1 #(max-key k %1 %2) (max-key k x y) more)))
(defn min-key
"Returns the x for which (k x), a number, is least."
{:added "1.0"
:static true}
11.1. CORE.CLJ 1259
([k x] x)
([k x y] (if (< (k x) (k y)) x y))
([k x y & more]
(reduce1 #(min-key k %1 %2) (min-key k x y) more)))
(defn distinct
"Returns a lazy sequence of the elements of coll with
duplicates removed"
{:added "1.0"
:static true}
[coll]
(let [step (fn step [xs seen]
(lazy-seq
((fn [[f :as xs] seen]
(when-let [s (seq xs)]
(if (contains? seen f)
(recur (rest s) seen)
(cons f (step (rest s) (conj seen f))))))
xs seen)))]
(step coll #{})))
(defn replace
"Given a map of replacement pairs and a vector/collection, r eturns a
vector/seq with any elements = a key in smap replaced with the
corresponding val in smap"
{:added "1.0"
:static true}
[smap coll]
(if (vector? coll)
(reduce1 (fn [v i]
(if-let [e (find smap (nth v i))]
(assoc v i (val e))
v))
coll (range (count coll)))
(map #(if-let [e (find smap %)] (val e) %) coll)))
(defmacro dosync
"Runs the exprs (in an implicit do) in a transaction that enco mpasses
exprs and any nested calls. Starts a transaction if none is al ready
running on this thread. Any uncaught exception will abort th e
transaction and flow out of dosync. The exprs may be run more t han
once, but any effects on Refs will be atomic."
{:added "1.0"}
[& exprs]
‘(sync nil ~@exprs))
(defmacro with-precision
"Sets the precision and rounding mode to be used for
1260 CHAPTER 11. CLJ/CLOJURE/
BigDecimal operations.
Usage: (with-precision 10 (/ 1M 3))
or: (with-precision 10 :rounding HALF_DOWN (/ 1M 3))
The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DO WN,
HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP ."
{:added "1.0"}
[precision & exprs]
(let [[body rm] (if (= (first exprs) :rounding)
[(next (next exprs))
‘((. java.math.RoundingMode ~(second exprs)))]
[exprs nil])]
‘(binding [*math-context* (java.math.MathContext. ~pre cision ~@rm)]
~@body)))
(defn mk-bound-fn
{:private true}
[^clojure.lang.Sorted sc test key]
(fn [e]
(test (.. sc comparator (compare (. sc entryKey e) key)) 0)))
(defn subseq
"sc must be a sorted collection, test(s) one of <, <=, > or
>=. Returns a seq of those entries with keys ek for
which (test (.. sc comparator (compare ek key)) 0) is true"
{:added "1.0"
:static true}
([^clojure.lang.Sorted sc test key]
(let [include (mk-bound-fn sc test key)]
(if (#{> >=} test)
(when-let [[e :as s] (. sc seqFrom key true)]
(if (include e) s (next s)))
(take-while include (. sc seq true)))))
([^clojure.lang.Sorted sc start-test start-key end-test end-key]
(when-let [[e :as s] (. sc seqFrom start-key true)]
(take-while (mk-bound-fn sc end-test end-key)
(if ((mk-bound-fn sc start-test start-key) e) s (next s)))) ))
(defn rsubseq
"sc must be a sorted collection, test(s) one of <, <=, > or
>=. Returns a reverse seq of those entries with keys ek for
which (test (.. sc comparator (compare ek key)) 0) is true"
{:added "1.0"
:static true}
([^clojure.lang.Sorted sc test key]
(let [include (mk-bound-fn sc test key)]
(if (#{< <=} test)
(when-let [[e :as s] (. sc seqFrom key false)]
(if (include e) s (next s)))
11.1. CORE.CLJ 1261
(take-while include (. sc seq false)))))
([^clojure.lang.Sorted sc start-test start-key end-test end-key]
(when-let [[e :as s] (. sc seqFrom end-key false)]
(take-while (mk-bound-fn sc start-test start-key)
(if ((mk-bound-fn sc end-test end-key) e) s (next s))))))
(defn repeatedly
"Takes a function of no args, presumably with side effects, a nd
returns an infinite (or length n if supplied) lazy sequence o f calls
to it"
{:added "1.0"
:static true}
([f] (lazy-seq (cons (f) (repeatedly f))))
([n f] (take n (repeatedly f))))
(defn add-classpath
"DEPRECATED
Adds the url (String or URL object) to the classpath per
URLClassLoader.addURL"
{:added "1.0"
:deprecated "1.1"}
[url]
(println "WARNING: add-classpath is deprecated")
(clojure.lang.RT/addURL url))
(defn hash
"Returns the hash code of its argument"
{:added "1.0"
:static true}
[x] (. clojure.lang.Util (hash x)))
(defn interpose
"Returns a lazy seq of the elements of coll separated by sep"
{:added "1.0"
:static true}
[sep coll] (drop 1 (interleave (repeat sep) coll)))
(defmacro definline
"Experimental - like defmacro, except defines a named funct ion whose
body is the expansion, calls to which may be expanded inline a s if
it were a macro. Cannot be used with variadic (&) args."
{:added "1.0"}
[name & decl]
(let [[pre-args [args expr]] (split-with (comp not vector? ) decl)]
‘(do
(defn ~name ~@pre-args ~args
~(apply (eval (list ‘fn args expr)) args))
1262 CHAPTER 11. CLJ/CLOJURE/
(alter-meta! (var ~name) assoc :inline (fn ~name ~args ~exp r))
(var ~name))))
(defn empty
"Returns an empty collection of the same category as coll, or nil"
{:added "1.0"
:static true}
[coll]
(when (instance? clojure.lang.IPersistentCollection co ll)
(.empty ^clojure.lang.IPersistentCollection coll)))
(defmacro amap
"Maps an expression across an array a, using an index named id x, and
return value named ret, initialized to a clone of a, then sett ing
each element of ret to the evaluation of expr, returning the n ew
array ret."
{:added "1.0"}
[a idx ret expr]
‘(let [a# ~a
~ret (aclone a#)]
(loop [~idx 0]
(if (< ~idx (alength a#))
(do
(aset ~ret ~idx ~expr)
(recur (unchecked-inc ~idx)))
~ret))))
(defmacro areduce
"Reduces an expression across an array a, using an index name d idx,
and return value named ret, initialized to init, setting ret to the
evaluation of expr at each step, returning ret."
{:added "1.0"}
[a idx ret init expr]
‘(let [a# ~a]
(loop [~idx 0 ~ret ~init]
(if (< ~idx (alength a#))
(recur (unchecked-inc ~idx) ~expr)
~ret))))
(defn float-array
"Creates an array of floats"
{:inline (fn [& args] ‘(. clojure.lang.Numbers float_arra y ~@args))
:inline-arities #{1 2}
:added "1.0"}
([size-or-seq] (. clojure.lang.Numbers float_array size -or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers float_array size init-val-or-se q)))
(defn boolean-array
"Creates an array of booleans"
11.1. CORE.CLJ 1263
{:inline (fn [& args] ‘(. clojure.lang.Numbers boolean_ar ray ~@args))
:inline-arities #{1 2}
:added "1.1"}
([size-or-seq] (. clojure.lang.Numbers boolean_array si ze-or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers boolean_array size init-val-or- seq)))
(defn byte-array
"Creates an array of bytes"
{:inline (fn [& args] ‘(. clojure.lang.Numbers byte_array ~@args))
:inline-arities #{1 2}
:added "1.1"}
([size-or-seq] (. clojure.lang.Numbers byte_array size- or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers byte_array size init-val-or-seq )))
(defn char-array
"Creates an array of chars"
{:inline (fn [& args] ‘(. clojure.lang.Numbers char_array ~@args))
:inline-arities #{1 2}
:added "1.1"}
([size-or-seq] (. clojure.lang.Numbers char_array size- or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers char_array size init-val-or-seq )))
(defn short-array
"Creates an array of shorts"
{:inline (fn [& args] ‘(. clojure.lang.Numbers short_arra y ~@args))
:inline-arities #{1 2}
:added "1.1"}
([size-or-seq] (. clojure.lang.Numbers short_array size -or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers short_array size init-val-or-se q)))
(defn double-array
"Creates an array of doubles"
{:inline (fn [& args] ‘(. clojure.lang.Numbers double_arr ay ~@args))
:inline-arities #{1 2}
:added "1.0"}
([size-or-seq] (. clojure.lang.Numbers double_array siz e-or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers double_array size init-val-or-s eq)))
(defn object-array
"Creates an array of objects"
{:inline (fn [arg] ‘(. clojure.lang.RT object_array ~arg) )
:inline-arities #{1}
:added "1.2"}
([size-or-seq] (. clojure.lang.RT object_array size-or- seq)))
1264 CHAPTER 11. CLJ/CLOJURE/
(defn int-array
"Creates an array of ints"
{:inline (fn [& args] ‘(. clojure.lang.Numbers int_array ~ @args))
:inline-arities #{1 2}
:added "1.0"}
([size-or-seq] (. clojure.lang.Numbers int_array size-o r-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers int_array size init-val-or-seq) ))
(defn long-array
"Creates an array of longs"
{:inline (fn [& args] ‘(. clojure.lang.Numbers long_array ~@args))
:inline-arities #{1 2}
:added "1.0"}
([size-or-seq] (. clojure.lang.Numbers long_array size- or-seq))
([size init-val-or-seq]
(. clojure.lang.Numbers long_array size init-val-or-seq )))
(definline booleans
"Casts to boolean[]"
{:added "1.1"}
[xs] ‘(. clojure.lang.Numbers booleans ~xs))
(definline bytes
"Casts to bytes[]"
{:added "1.1"}
[xs] ‘(. clojure.lang.Numbers bytes ~xs))
(definline chars
"Casts to chars[]"
{:added "1.1"}
[xs] ‘(. clojure.lang.Numbers chars ~xs))
(definline shorts
"Casts to shorts[]"
{:added "1.1"}
[xs] ‘(. clojure.lang.Numbers shorts ~xs))
(definline floats
"Casts to float[]"
{:added "1.0"}
[xs] ‘(. clojure.lang.Numbers floats ~xs))
(definline ints
"Casts to int[]"
{:added "1.0"}
[xs] ‘(. clojure.lang.Numbers ints ~xs))
(definline doubles
"Casts to double[]"
11.1. CORE.CLJ 1265
{:added "1.0"}
[xs] ‘(. clojure.lang.Numbers doubles ~xs))
(definline longs
"Casts to long[]"
{:added "1.0"}
[xs] ‘(. clojure.lang.Numbers longs ~xs))
(import ’(java.util.concurrent BlockingQueue LinkedBlo ckingQueue))
(defn seque
"Creates a queued seq on another (presumably lazy) seq s. The queued
seq will produce a concrete seq in the background, and can get up to
n items ahead of the consumer. n-or-q can be an integer n buffe r
size, or an instance of java.util.concurrent BlockingQueu e. Note
that reading from a seque can block if the reader gets ahead of the
producer."
{:added "1.0"
:static true}
([s] (seque 100 s))
([n-or-q s]
(let [^BlockingQueue q (if (instance? BlockingQueue n-or- q)
n-or-q
(LinkedBlockingQueue. (int n-or-q)))
NIL (Object.) ;nil sentinel since LBQ doesn’t support nils
agt (agent (seq s))
fill (fn [s]
(try
(loop [[x & xs :as s] s]
(if s
(if (.offer q (if (nil? x) NIL x))
(recur xs)
s)
(.put q q))) ; q itself is eos sentinel
(catch Exception e
(.put q q)
(throw e))))
drain (fn drain []
(lazy-seq
(let [x (.take q)]
(if (identical? x q) ;q itself is eos sentinel
(do @agt nil) ;touch agent just to propagate errors
(do
(send-off agt fill)
(cons
(if (identical? x NIL) nil x)
(drain)))))))]
(send-off agt fill)
(drain))))
1266 CHAPTER 11. CLJ/CLOJURE/
(defn class?
"Returns true if x is an instance of Class"
{:added "1.0"
:static true}
[x] (instance? Class x))
(defn- is-annotation? [c]
(and (class? c)
(.isAssignableFrom java.lang.annotation.Annotation c) ))
(defn- is-runtime-annotation? [^Class c]
(boolean
(and (is-annotation? c)
(when-let [^java.lang.annotation.Retention r
(.getAnnotation c java.lang.annotation.Retention)]
(= (.value r) java.lang.annotation.RetentionPolicy/RUN TIME)))))
(defn- descriptor [^Class c] (clojure.asm.Type/getDescr iptor c))
(declare process-annotation)
(defn- add-annotation [^clojure.asm.AnnotationVisitor av name v]
(cond
(vector? v) (let [avec (.visitArray av name)]
(doseq [vval v]
(add-annotation avec "value" vval))
(.visitEnd avec))
(symbol? v) (let [ev (eval v)]
(cond
(instance? java.lang.Enum ev)
(.visitEnum av name (descriptor (class ev)) (str ev))
(class? ev)
(.visit av name (clojure.asm.Type/getType ev))
:else
(throw (IllegalArgumentException.
(str "Unsupported annotation value: " v
" of class " (class ev))))))
(seq? v) (let [[nested nv] v
c (resolve nested)
nav (.visitAnnotation av name (descriptor c))]
(process-annotation nav nv)
(.visitEnd nav))
:else (.visit av name v)))
(defn- process-annotation [av v]
(if (map? v)
(doseq [[k v] v]
(add-annotation av (name k) v))
(add-annotation av "value" v)))
(defn- add-annotations
11.1. CORE.CLJ 1267
([visitor m] (add-annotations visitor m nil))
([visitor m i]
(doseq [[k v] m]
(when (symbol? k)
(when-let [c (resolve k)]
(when (is-annotation? c)
;this is known duck/reflective as no common base
;of ASM Visitors
(let
[av (if i
(.visitParameterAnnotation visitor i
(descriptor c) (is-runtime-annotation? c))
(.visitAnnotation visitor
(descriptor c) (is-runtime-annotation? c)))]
(process-annotation av v)
(.visitEnd av))))))))
(defn alter-var-root
"Atomically alters the root binding of var v by applying f to i ts
current value plus any args"
{:added "1.0"
:static true}
[^clojure.lang.Var v f & args] (.alterRoot v f args))
(defn bound?
"Returns true if all of the vars provided as arguments have
any bound value, root or thread-local. Implies that deref’i ng
the provided vars will succeed. Returns true if no vars are pr ovided."
{:added "1.2"
:static true}
[& vars]
(every? #(.isBound ^clojure.lang.Var %) vars))
(defn thread-bound?
"Returns true if all of the vars provided as arguments have
thread-local bindings. Implies that set!’ing the provided vars
will succeed. Returns true if no vars are provided."
{:added "1.2"
:static true}
[& vars]
(every? #(.getThreadBinding ^clojure.lang.Var %) vars))
(defn make-hierarchy
"Creates a hierarchy object for use with derive, isa? etc."
{:added "1.0"
:static true}
[] {:parents {} :descendants {} :ancestors {}})
(def ^{:private true}
global-hierarchy (make-hierarchy))
1268 CHAPTER 11. CLJ/CLOJURE/
(defn not-empty
"If coll is empty, returns nil, else coll"
{:added "1.0"
:static true}
[coll] (when (seq coll) coll))
(defn bases
"Returns the immediate superclass and direct interfaces of c, if any"
{:added "1.0"
:static true}
[^Class c]
(when c
(let [i (.getInterfaces c)
s (.getSuperclass c)]
(not-empty
(if s (cons s i) i)))))
(defn supers
"Returns the immediate and indirect superclasses and
interfaces of c, if any"
{:added "1.0"
:static true}
[^Class class]
(loop [ret (set (bases class)) cs ret]
(if (seq cs)
(let [c (first cs) bs (bases c)]
(recur (into1 ret bs) (into1 (disj cs c) bs)))
(not-empty ret))))
(defn isa?
"Returns true if (= child parent), or child is directly or
indirectly derived from parent, either via a Java type
inheritance relationship or a relationship established vi a derive.
h must be a hierarchy obtained from make-hierarchy, if not
supplied defaults to the global hierarchy"
{:added "1.0"}
([child parent] (isa? global-hierarchy child parent))
([h child parent]
(or (= child parent)
(and (class? parent) (class? child)
(. ^Class parent isAssignableFrom child))
(contains? ((:ancestors h) child) parent)
(and (class? child)
(some #(contains? ((:ancestors h) %) parent)
(supers child)))
(and (vector? parent) (vector? child)
(= (count parent) (count child))
(loop [ret true i 0]
(if (or (not ret) (= i (count parent)))
11.1. CORE.CLJ 1269
ret
(recur (isa? h (child i) (parent i)) (inc i))))))))
(defn parents
"Returns the immediate parents of tag, either via a Java type
inheritance relationship or a relationship established vi a derive. h
must be a hierarchy obtained from make-hierarchy, if not sup plied
defaults to the global hierarchy"
{:added "1.0"}
([tag] (parents global-hierarchy tag))
([h tag] (not-empty
(let [tp (get (:parents h) tag)]
(if (class? tag)
(into1 (set (bases tag)) tp)
tp)))))
(defn ancestors
"Returns the immediate and indirect parents of tag, either v ia a
Java type inheritance relationship or a relationship estab lished
via derive. h must be a hierarchy obtained from make-hierarc hy,
if not supplied defaults to the global hierarchy"
{:added "1.0"}
([tag] (ancestors global-hierarchy tag))
([h tag] (not-empty
(let [ta (get (:ancestors h) tag)]
(if (class? tag)
(let [superclasses (set (supers tag))]
(reduce1 into1 superclasses
(cons ta
(map #(get (:ancestors h) %) superclasses))))
ta)))))
(defn descendants
"Returns the immediate and indirect children of tag, throug h a
relationship established via derive. h must be a hierarchy o btained
from make-hierarchy, if not supplied defaults to the global
hierarchy. Note: does not work on Java type inheritance
relationships."
{:added "1.0"}
([tag] (descendants global-hierarchy tag))
([h tag] (if (class? tag)
(throw (java.lang.UnsupportedOperationException.
"Can’t get descendants of classes"))
(not-empty (get (:descendants h) tag)))))
(defn derive
"Establishes a parent/child relationship between parent a nd
tag. Parent must be a namespace-qualified symbol or keyword and
child can be either a namespace-qualified symbol or keyword or a
class. h must be a hierarchy obtained from make-hierarchy, i f not
1270 CHAPTER 11. CLJ/CLOJURE/
supplied defaults to, and modifies, the global hierarchy."
{:added "1.0"}
([tag parent]
(assert (namespace parent))
(assert (or (class? tag)
(and (instance? clojure.lang.Named tag) (namespace tag)) ))
(alter-var-root #’global-hierarchy derive tag parent) ni l)
([h tag parent]
(assert (not= tag parent))
(assert (or (class? tag) (instance? clojure.lang.Named ta g)))
(assert (instance? clojure.lang.Named parent))
(let [tp (:parents h)
td (:descendants h)
ta (:ancestors h)
tf (fn [m source sources target targets]
(reduce1
(fn [ret k]
(assoc ret k
(reduce1 conj (get targets k #{})
(cons target (targets target)))))
m (cons source (sources source))))]
(or
(when-not (contains? (tp tag) parent)
(when (contains? (ta tag) parent)
(throw (Exception. (print-str tag
"already has" parent "as ancestor"))))
(when (contains? (ta parent) tag)
(throw (Exception. (print-str "Cyclic derivation:"
parent "has" tag "as ancestor"))))
{:parents (assoc (:parents h) tag (conj (get tp tag #{}) pare nt))
:ancestors (tf (:ancestors h) tag td parent ta)
:descendants (tf (:descendants h) parent ta tag td)})
h))))
(declare flatten)
(defn underive
"Removes a parent/child relationship between parent and
tag. h must be a hierarchy obtained from make-hierarchy, if n ot
supplied defaults to, and modifies, the global hierarchy."
{:added "1.0"}
([tag parent]
(alter-var-root #’global-hierarchy underive tag parent) nil)
([h tag parent]
(let [parentMap (:parents h)
childsParents (if (parentMap tag)
(disj (parentMap tag) parent) #{})
newParents (if (not-empty childsParents)
11.1. CORE.CLJ 1271
(assoc parentMap tag childsParents)
(dissoc parentMap tag))
deriv-seq (flatten
(map #(cons (key %)
(interpose (key %) (val %)))
(seq newParents)))]
(if (contains? (parentMap tag) parent)
(reduce1 #(apply derive %1 %2) (make-hierarchy)
(partition 2 deriv-seq))
h))))
(defn distinct?
"Returns true if no two of the arguments are ="
{:tag Boolean
:added "1.0"
:static true}
([x] true)
([x y] (not (= x y)))
([x y & more]
(if (not= x y)
(loop [s #{x y} [x & etc :as xs] more]
(if xs
(if (contains? s x)
false
(recur (conj s x) etc))
true))
false)))
(defn resultset-seq
"Creates and returns a lazy sequence of structmaps correspo nding to
the rows in the java.sql.ResultSet rs"
{:added "1.0"}
[^java.sql.ResultSet rs]
(let [rsmeta (. rs (getMetaData))
idxs (range 1 (inc (. rsmeta (getColumnCount))))
keys (map (comp keyword #(.toLowerCase ^String %))
(map (fn [i] (. rsmeta (getColumnLabel i))) idxs))
check-keys
(or (apply distinct? keys)
(throw (Exception.
"ResultSet must have unique column labels")))
row-struct (apply create-struct keys)
row-values
(fn [] (map (fn [^Integer i] (. rs (getObject i))) idxs))
rows
(fn thisfn []
(when (. rs (next))
(cons
(apply struct row-struct (row-values))
1272 CHAPTER 11. CLJ/CLOJURE/
(lazy-seq (thisfn)))))]
(rows)))
(defn iterator-seq
"Returns a seq on a java.util.Iterator. Note that most colle ctions
providing iterators implement Iterable and thus support se q directly."
{:added "1.0"
:static true}
[iter]
(clojure.lang.IteratorSeq/create iter))
(defn enumeration-seq
"Returns a seq on a java.util.Enumeration"
{:added "1.0"
:static true}
[e]
(clojure.lang.EnumerationSeq/create e))
(defn format
"Formats a string using java.lang.String.format,
see java.util.Formatter for format
string syntax"
{:added "1.0"
:static true}
^String [fmt & args]
(String/format fmt (to-array args)))
(defn printf
"Prints formatted output, as per format"
{:added "1.0"
:static true}
[fmt & args]
(print (apply format fmt args)))
(declare gen-class)
(defmacro with-loading-context [& body]
‘((fn loading# []
(. clojure.lang.Var
(pushThreadBindings {clojure.lang.Compiler/LOADER
(.getClassLoader (.getClass ^Object loading#))}))
(try
~@body
(finally
(. clojure.lang.Var (popThreadBindings)))))))
(defmacro ns
"Sets *ns* to the namespace named by name (unevaluated), cre ating it
if needed. references can be zero or more of: (:refer-clojur e ...)
(:require ...) (:use ...) (:import ...) (:load ...) (:gen-c lass)
11.1. CORE.CLJ 1273
with the syntax of refer-clojure/require/use/import/loa d/gen-class
respectively, except the arguments are unevaluated and nee d not be
quoted. (:gen-class ...), when supplied, defaults to :name
corresponding to the ns name, :main true, :impl-ns same as ns , and
:init-impl-ns true. All options of gen-class are
supported. The :gen-class directive is ignored when not
compiling. If :gen-class is not supplied, when compiled onl y an
nsname__init.class will be generated. If :refer-clojure i s not used, a
default (refer ’clojure) is used. Use of ns is preferred to
individual calls to in-ns/require/use/import:
(ns foo.bar
(:refer-clojure :exclude [ancestors printf])
(:require (clojure.contrib sql sql.tests))
(:use (my.lib this that))
(:import (java.util Date Timer Random)
(java.sql Connection Statement)))"
{:arglists ’([name docstring? attr-map? references*])
:added "1.0"}
[name & references]
(let [process-reference
(fn [[kname & args]]
‘(~(symbol "clojure.core" (clojure.core/name kname))
~@(map #(list ’quote %) args)))
docstring (when (string? (first references)) (first refer ences))
references (if docstring (next references) references)
name (if docstring
(vary-meta name assoc :doc docstring)
name)
metadata (when (map? (first references)) (first reference s))
references (if metadata (next references) references)
name (if metadata
(vary-meta name merge metadata)
name)
gen-class-clause
(first (filter #(= :gen-class (first %)) references))
gen-class-call
(when gen-class-clause
(list* ‘gen-class :name
(.replace (str name) \- \_)
:impl-ns name :main true (next gen-class-clause)))
references (remove #(= :gen-class (first %)) references)
;ns-effect (clojure.core/in-ns name)
]
‘(do
(clojure.core/in-ns ’~name)
(with-loading-context
~@(when gen-class-call (list gen-class-call))
~@(when (and (not= name ’clojure.core)
(not-any? #(= :refer-clojure (first %)) references))
1274 CHAPTER 11. CLJ/CLOJURE/
‘((clojure.core/refer ’~’clojure.core)))
~@(map process-reference references)))))
(defmacro refer-clojure
"Same as (refer ’clojure.core <filters>)"
{:added "1.0"}
[& filters]
‘(clojure.core/refer ’~’clojure.core ~@filters))
(defmacro defonce
"defs name to have the root value of the expr iff the named var
has no root value, else expr is unevaluated"
{:added "1.0"}
[name expr]
‘(let [v# (def ~name)]
(when-not (.hasRoot v#)
(def ~name ~expr))))
;;;; require/use/load, contributed by Stephen C. Gilardi ; ;;;;;;;;;;
(defonce ^:dynamic
^{:private true
:doc "A ref to a sorted set of symbols representing loaded lib s"}
*loaded-libs* (ref (sorted-set)))
(defonce ^:dynamic
^{:private true
:doc "the set of paths currently being loaded by this thread" }
*pending-paths* #{})
(defonce ^:dynamic
^{:private true :doc
"True while a verbose load is pending"}
*loading-verbosely* false)
(defn- throw-if
"Throws an exception with a message if pred is true"
[pred fmt & args]
(when pred
(let [^String message (apply format fmt args)
exception (Exception. message)
raw-trace (.getStackTrace exception)
boring?
#(not= (.getMethodName ^StackTraceElement %) "doInvoke" )
trace (into-array (drop 2 (drop-while boring? raw-trace)) )]
(.setStackTrace exception trace)
(throw exception))))
(defn- libspec?
"Returns true if x is a libspec"
11.1. CORE.CLJ 1275
[x]
(or (symbol? x)
(and (vector? x)
(or
(nil? (second x))
(keyword? (second x))))))
(defn- prependss
"Prepends a symbol or a seq to coll"
[x coll]
(if (symbol? x)
(cons x coll)
(concat x coll)))
(defn- root-resource
"Returns the root directory path for a lib"
{:tag String}
[lib]
(str \/
(.. (name lib)
(replace \- \_)
(replace \. \/))))
(defn- root-directory
"Returns the root resource path for a lib"
[lib]
(let [d (root-resource lib)]
(subs d 0 (.lastIndexOf d "/"))))
(declare load)
(defn- load-one
"Loads a lib given its name. If need-ns, ensures that the asso ciated
namespace exists after loading. If require, records the loa d so any
duplicate loads can be skipped."
[lib need-ns require]
(load (root-resource lib))
(throw-if (and need-ns (not (find-ns lib)))
"namespace ’%s’ not found after loading ’%s’"
lib (root-resource lib))
(when require
(dosync
(commute *loaded-libs* conj lib))))
(defn- load-all
"Loads a lib given its name and forces a load of any libs it
directly or indirectly loads. If need-ns, ensures that the
associated namespace exists after loading. If require, rec ords
the load so any duplicate loads can be skipped."
[lib need-ns require]
1276 CHAPTER 11. CLJ/CLOJURE/
(dosync
(commute *loaded-libs* #(reduce1 conj %1 %2)
(binding [*loaded-libs* (ref (sorted-set))]
(load-one lib need-ns require)
@*loaded-libs*))))
(defn- load-lib
"Loads a lib with options"
[prefix lib & options]
(throw-if (and prefix (pos? (.indexOf (name lib) (int \.))) )
"lib names inside prefix lists must not contain periods")
(let [lib (if prefix (symbol (str prefix \. lib)) lib)
opts (apply hash-map options)
{:keys [as reload reload-all require use verbose]} opts
loaded (contains? @*loaded-libs* lib)
load (cond reload-all
load-all
(or reload (not require) (not loaded))
load-one)
need-ns (or as use)
filter-opts (select-keys opts ’(:exclude :only :rename)) ]
(binding [*loading-verbosely* (or *loading-verbosely* v erbose)]
(if load
(load lib need-ns require)
(throw-if (and need-ns (not (find-ns lib)))
"namespace ’%s’ not found" lib))
(when (and need-ns *loading-verbosely*)
(printf "(clojure.core/in-ns ’%s)\n" (ns-name *ns*)))
(when as
(when *loading-verbosely*
(printf "(clojure.core/alias ’%s ’%s)\n" as lib))
(alias as lib))
(when use
(when *loading-verbosely*
(printf "(clojure.core/refer ’%s" lib)
(doseq [opt filter-opts]
(printf " %s ’%s" (key opt) (print-str (val opt))))
(printf ")\n"))
(apply refer lib (mapcat seq filter-opts))))))
(defn- load-libs
"Loads libs, interpreting libspecs, prefix lists, and flag s for
forwarding to load-lib"
[& args]
(let [flags (filter keyword? args)
opts (interleave flags (repeat true))
args (filter (complement keyword?) args)]
; check for unsupported options
(let [supported #{:as :reload :reload-all :require :use :v erbose}
unsupported (seq (remove supported flags))]
11.1. CORE.CLJ 1277
(throw-if unsupported
(apply str "Unsupported option(s) supplied: "
(interpose \, unsupported))))
; check a load target was specified
(throw-if (not (seq args)) "Nothing specified to load")
(doseq [arg args]
(if (libspec? arg)
(apply load-lib nil (prependss arg opts))
(let [[prefix & args] arg]
(throw-if (nil? prefix) "prefix cannot be nil")
(doseq [arg args]
(apply load-lib prefix (prependss arg opts))))))))
;; Public
(defn require
"Loads libs, skipping any that are already loaded. Each argu ment is
either a libspec that identifies a lib, a prefix list that ide ntifies
multiple libs whose names share a common prefix, or a flag tha t
modifies how all the identified libs are loaded. Use :requir e in
the ns macro in preference to calling this directly.
Libs
A ’lib’ is a named set of resources in classpath whose content s
define a library of Clojure code. Lib names are symbols and ea ch
lib is associated with a Clojure namespace and a Java package that
share its name. A lib’s name also locates its root directory w ithin
classpath using Java’s package name to classpath-relative path
mapping. All resources in a lib should be contained in the dir ectory
structure under its root directory. All definitions a lib ma kes
should be in its associated namespace.
’require loads a lib by loading its root resource. The root re source
path is derived from the lib name in the following manner:
Consider a lib named by the symbol ’x.y.z; it has the root dire ctory
<classpath>/x/y/, and its root resource is <classpath>/x/ y/z.clj. The
root resource should contain code to create the lib’s namesp ace
(usually by using the ns macro) and load any additional lib re sources.
Libspecs
A libspec is a lib name or a vector containing a lib name follow ed
by options expressed as sequential keywords and arguments.
Recognized options: :as
:as takes a symbol as its argument and makes that symbol an ali as
to the lib’s namespace in the current namespace.
1278 CHAPTER 11. CLJ/CLOJURE/
Prefix Lists
It’s common for Clojure code to depend on several libs whose n ames
have the same prefix. When specifying libs, prefix lists can be
used to reduce repetition. A prefix list contains the shared prefix
followed by libspecs with the shared prefix removed from the lib
names. After removing the prefix, the names that remain must not
contain any periods.
Flags
A flag is a keyword.
Recognized flags: :reload, :reload-all, :verbose
:reload forces loading of all the identified libs even if the y are
already loaded
:reload-all implies :reload and also forces loading of all l ibs that
the identified libs directly or indirectly load via require or use
:verbose triggers printing information about each load, al ias, and
refer
Example:
The following would load the libraries clojure.zip and cloj ure.set
abbreviated as ’s’.
(require ’(clojure zip [set :as s]))"
{:added "1.0"}
[& args]
(apply load-libs :require args))
(defn use
"Like ’require, but also refers to each lib’s namespace usin g
clojure.core/refer. Use :use in the ns macro in preference t o
calling this directly.
’use accepts additional options in libspecs: :exclude, :on ly,
:rename. The arguments and semantics for :exclude, :only, a nd
:rename are the same as those documented for clojure.core/r efer."
{:added "1.0"}
[& args] (apply load-libs :require :use args))
(defn loaded-libs
"Returns a sorted set of symbols naming the currently loaded libs"
{:added "1.0"}
[] @*loaded-libs*)
(defn load
"Loads Clojure code from resources in classpath. A path is
interpreted as classpath-relative if it begins with a slash
11.1. CORE.CLJ 1279
or relative to the root directory for the current namespace
otherwise."
{:added "1.0"}
[& paths]
(doseq [^String path paths]
(let [^String path (if (.startsWith path "/")
path
(str (root-directory (ns-name *ns*)) \/ path))]
(when *loading-verbosely*
(printf "(clojure.core/load \"%s\")\n" path)
(flush))
; (throw-if (*pending-paths* path)
; "cannot load ’%s’ again while it is loading"
; path)
(when-not (*pending-paths* path)
(binding [*pending-paths* (conj *pending-paths* path)]
(clojure.lang.RT/load (.substring path 1)))))))
(defn compile
"Compiles the namespace named by the symbol lib into a set of
classfiles. The source for the lib must be in a proper
classpath-relative directory. The output files will go int o the
directory specified by *compile-path*, and that directory too must
be in the classpath."
{:added "1.0"}
[lib]
(binding [*compile-files* true]
(load-one lib true true))
lib)
;;;;;;;;;;;;; nested associative ops ;;;;;;;;;;;
(defn get-in
"Returns the value in a nested associative structure,
where ks is a sequence of ke(ys. Returns nil if the key is not pr esent,
or the not-found value if supplied."
{:added "1.2"
:static true}
([m ks]
(reduce1 get m ks))
([m ks not-found]
(loop [sentinel (Object.)
m m
ks (seq ks)]
(if ks
(let [m (get m (first ks) sentinel)]
(if (identical? sentinel m)
not-found
(recur sentinel m (next ks))))
m))))
1280 CHAPTER 11. CLJ/CLOJURE/
(defn assoc-in
"Associates a value in a nested associative structure, wher e ks
is a sequence of keys and v is the new value and returns a new
nested structure. If any levels do not exist, hash-maps will be
created."
{:added "1.0"
:static true}
[m [k & ks] v]
(if ks
(assoc m k (assoc-in (get m k) ks v))
(assoc m k v)))
(defn update-in
"’Updates’ a value in a nested associative structure, where ks is a
sequence of keys and f is a function that will take the old valu e
and any supplied args and return the new value, and returns a n ew
nested structure. If any levels do not exist, hash-maps will be
created."
{:added "1.0"
:static true}
([m [k & ks] f & args]
(if ks
(assoc m k (apply update-in (get m k) ks f args))
(assoc m k (apply f (get m k) args)))))
(defn empty?
"Returns true if coll has no items - same as (not (seq coll)).
Please use the idiom (seq x) rather than (not (empty? x))"
{:added "1.0"
:static true}
[coll] (not (seq coll)))
(defn coll?
"Returns true if x implements IPersistentCollection"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.IPersistentCollection x))
(defn list?
"Returns true if x implements IPersistentList"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.IPersistentList x))
(defn set?
"Returns true if x implements IPersistentSet"
{:added "1.0"
:static true}
11.1. CORE.CLJ 1281
[x] (instance? clojure.lang.IPersistentSet x))
(defn ifn?
"Returns true if x implements IFn. Note that many data struct ures
(e.g. sets and maps) implement IFn"
{:added "1.0"
:static true}
[x] (instance? clojure.lang.IFn x))
(defn fn?
"Returns true if x implements Fn, i.e. is an object created vi a fn."
{:added "1.0"
:static true}
[x] (instance? clojure.lang.Fn x))
(defn associative?
"Returns true if coll implements Associative"
{:added "1.0"
:static true}
[coll] (instance? clojure.lang.Associative coll))
(defn sequential?
"Returns true if coll implements Sequential"
{:added "1.0"
:static true}
[coll] (instance? clojure.lang.Sequential coll))
(defn sorted?
"Returns true if coll implements Sorted"
{:added "1.0"
:static true}
[coll] (instance? clojure.lang.Sorted coll))
(defn counted?
"Returns true if coll implements count in constant time"
{:added "1.0"
:static true}
[coll] (instance? clojure.lang.Counted coll))
(defn reversible?
"Returns true if coll implements Reversible"
{:added "1.0"
:static true}
[coll] (instance? clojure.lang.Reversible coll))
(def ^:dynamic
^{:doc "bound in a repl thread to the most recent value printe d"
:added "1.0"}
*1)
1282 CHAPTER 11. CLJ/CLOJURE/
(def ^:dynamic
^{:doc "bound in a repl thread to the second most recent value printed"
:added "1.0"}
*2)
(def ^:dynamic
^{:doc "bound in a repl thread to the third most recent value p rinted"
:added "1.0"}
*3)
(def ^:dynamic
^{:doc "bound in a repl thread to the most recent exception ca ught
by the repl"
:added "1.0"}
*e)
(defn trampoline
"trampoline can be used to convert algorithms requiring mut ual
recursion without stack consumption. Calls f with supplied args, if
any. If f returns a fn, calls that fn with no arguments, and
continues to repeat, until the return value is not a fn, then
returns that non-fn value. Note that if you want to return a fn as a
final value, you must wrap it in some data structure and unpac k it
after trampoline returns."
{:added "1.0"
:static true}
([f]
(let [ret (f)]
(if (fn? ret)
(recur ret)
ret)))
([f & args]
(trampoline #(apply f args))))
(defn intern
"Finds or creates a var named by the symbol name in the namespa ce
ns (which can be a symbol or a namespace), setting its root bin ding
to val if supplied. The namespace must exist. The var will ado pt any
metadata from the name symbol. Returns the var."
{:added "1.0"
:static true}
([ns ^clojure.lang.Symbol name]
(let [v (clojure.lang.Var/intern (the-ns ns) name)]
(when (meta name) (.setMeta v (meta name)))
v))
([ns name val]
(let [v (clojure.lang.Var/intern (the-ns ns) name val)]
(when (meta name) (.setMeta v (meta name)))
v)))
11.1. CORE.CLJ 1283
(defmacro while
"Repeatedly executes body while test expression is true. Pr esumes
some side-effect will cause test to become false/nil. Retur ns nil"
{:added "1.0"}
[test & body]
‘(loop []
(when ~test
~@body
(recur))))
(defn memoize
"Returns a memoized version of a referentially transparent function.
The memoized version of the function keeps a cache of the mapp ing
from arguments to results and, when calls with the same argum ents
are repeated often, has higher performance at the expense of higher
memory use."
{:added "1.0"
:static true}
[f]
(let [mem (atom {})]
(fn [& args]
(if-let [e (find @mem args)]
(val e)
(let [ret (apply f args)]
(swap! mem assoc args ret)
ret)))))
(defmacro condp
"Takes a binary predicate, an expression, and a set of clause s.
Each clause can take the form of either:
test-expr result-expr
test-expr :>> result-fn
Note :>> is an ordinary keyword.
For each clause, (pred test-expr expr) is evaluated. If it re turns
logical true, the clause is a match. If a binary clause matche s, the
result-expr is returned, if a ternary clause matches, its re sult-fn,
which must be a unary function, is called with the result of th e
predicate as its argument, the result of that call being the r eturn
value of condp. A single default expression can follow the cl auses,
and its value will be returned if no clause matches. If no defa ult
expression is provided and no clause matches, an
IllegalArgumentException is thrown."
{:added "1.0"}
[pred expr & clauses]
1284 CHAPTER 11. CLJ/CLOJURE/
(let [gpred (gensym "pred__")
gexpr (gensym "expr__")
emit (fn emit [pred expr args]
(let [[[a b c :as clause] more]
(split-at (if (= :>> (second args)) 3 2) args)
n (count clause)]
(cond
(= 0 n)
‘(throw (IllegalArgumentException.
(str "No matching clause: " ~expr)))
(= 1 n) a
(= 2 n) ‘(if (~pred ~a ~expr)
~b
~(emit pred expr more))
:else ‘(if-let [p# (~pred ~a ~expr)]
(~c p#)
~(emit pred expr more)))))
gres (gensym "res__")]
‘(let [~gpred ~pred
~gexpr ~expr]
~(emit gpred gexpr clauses))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; var documentation ;;;;; ;;;;;;;;;;;;;;
(alter-meta! #’*agent* assoc :added "1.0")
(alter-meta! #’in-ns assoc :added "1.0")
(alter-meta! #’load-file assoc :added "1.0")
(defmacro add-doc-and-meta {:private true} [name docstri ng meta]
‘(alter-meta! (var ~name) merge (assoc ~meta :doc ~docstri ng)))
(add-doc-and-meta *file*
"The path of the file being evaluated, as a String.
Evaluates to nil when there is no file, eg. in the REPL."
{:added "1.0"})
(add-doc-and-meta *command-line-args*
"A sequence of the supplied command line arguments, or nil if
none were supplied"
{:added "1.0"})
(add-doc-and-meta *warn-on-reflection*
"When set to true, the compiler will emit warnings when refle ction is
needed to resolve Java method calls or field accesses.
Defaults to false."
{:added "1.0"})
(add-doc-and-meta *compile-path*
11.1. CORE.CLJ 1285
"Specifies the directory where ’compile’ will write out .cl ass
files. This directory must be in the classpath for ’compile’ to
work.
Defaults to \"classes\""
{:added "1.0"})
(add-doc-and-meta *compile-files*
"Set to true when compiling files, false otherwise."
{:added "1.0"})
(add-doc-and-meta *unchecked-math*
"While bound to true, compilations of +, -, *, inc, dec and the
coercions will be done without overflow checks. Default: fa lse."
{:added "1.3"})
(add-doc-and-meta *ns*
"A clojure.lang.Namespace object representing the curren t namespace."
{:added "1.0"})
(add-doc-and-meta *in*
"A java.io.Reader object representing standard input for r ead
operations.
Defaults to System/in, wrapped in a LineNumberingPushback Reader"
{:added "1.0"})
(add-doc-and-meta *out*
"A java.io.Writer object representing standard output for print
operations.
Defaults to System/out, wrapped in an OutputStreamWriter"
{:added "1.0"})
(add-doc-and-meta *err*
"A java.io.Writer object representing standard error for p rint
operations.
Defaults to System/err, wrapped in a PrintWriter"
{:added "1.0"})
(add-doc-and-meta *flush-on-newline*
"When set to true, output will be flushed whenever a newline i s
printed.
Defaults to true."
{:added "1.0"})
(add-doc-and-meta *print-meta*
"If set to logical true, when printing an object, its metadat a
1286 CHAPTER 11. CLJ/CLOJURE/
will also be printed in a form that can be read back by the reade r.
Defaults to false."
{:added "1.0"})
(add-doc-and-meta *print-dup*
"When set to logical true, objects will be printed in a way tha t
preserves their type when read in later.
Defaults to false."
{:added "1.0"})
(add-doc-and-meta *print-readably*
"When set to logical false, strings and characters will be pr inted
with non-alphanumeric characters converted to the appropr iate
escape sequences.
Defaults to true"
{:added "1.0"})
(add-doc-and-meta *read-eval*
"When set to logical false, the EvalReader (#=(...)) is disa bled
in the read/load in the thread-local binding.
Example:
(binding [*read-eval* false] (read-string \"#=(eval (def x 3))\"))
Defaults to true"
{:added "1.0"})
\getchunk{defn future?}
\getchunk{defn future-done?}
(defmacro letfn
"fnspec ==> (fname [params*] exprs) or (fname ([params*] ex prs)+)
Takes a vector of function specs and a body, and generates a se t of
bindings of functions to their names. All of the names are ava ilable
in all of the definitions of the functions, as well as the body ."
{:added "1.0", :forms ’[(letfn [fnspecs*] exprs*)],
:special-form true, :url nil}
[fnspecs & body]
‘(letfn* ~(vec (interleave (map first fnspecs)
(map #(cons ‘fn %) fnspecs)))
~@body))
;;;;;;; case ;;;;;;;;;;;;;
(defn- shift-mask [shift mask x]
(-> x (bit-shift-right shift) (bit-and mask)))
11.1. CORE.CLJ 1287
(defn- min-hash
"takes a collection of keys and returns [shift mask]"
[keys]
(let [hashes (map hash keys)
cnt (count keys)]
(when-not (apply distinct? hashes)
(throw (IllegalArgumentException. "Hashes must be distin ct")))
(or (first
(filter
(fn [[s m]]
(apply distinct? (map #(shift-mask s m %) hashes)))
(for [mask (map #(dec (bit-shift-left 1 %)) (range 1 14))
shift (range 0 31)]
[shift mask])))
(throw (IllegalArgumentException.
"No distinct mapping found")))))
(defmacro case
"Takes an expression, and a set of clauses.
Each clause can take the form of either:
test-constant result-expr
(test-constant1 ... test-constantN) result-expr
The test-constants are not evaluated. They must be compile- time
literals, and need not be quoted. If the expression is equal t o a
test-constant, the corresponding result-expr is returned . A single
default expression can follow the clauses, and its value wil l be
returned if no clause matches. If no default expression is pr ovided
and no clause matches, an IllegalArgumentException is thro wn.
Unlike cond and condp, case does a constant-time dispatch, t he
clauses are not considered sequentially. All manner of cons tant
expressions are acceptable in case, including numbers, str ings,
symbols, keywords, and (Clojure) composites thereof. Note that since
lists are used to group multiple constants that map to the sam e
expression, a vector can be used to match a list if needed. The
test-constants need not be all of the same type."
{:added "1.2"}
[e & clauses]
(let [ge (with-meta (gensym) {:tag Object})
default (if (odd? (count clauses))
(last clauses)
‘(throw (IllegalArgumentException.
(str "No matching clause: " ~ge))))
cases (partition 2 clauses)
1288 CHAPTER 11. CLJ/CLOJURE/
case-map (reduce1 (fn [m [test expr]]
(if (seq? test)
(into1 m (zipmap test (repeat expr)))
(assoc m test expr)))
{} cases)
[shift mask] (if (seq case-map) (min-hash (keys case-map)) [0 0])
hmap (reduce1 (fn [m [test expr :as te]]
(assoc m (shift-mask shift mask (hash test)) te))
(sorted-map) case-map)]
‘(let [~ge ~e]
~(condp = (count clauses)
0 default
1 default
‘(case* ~ge ~shift ~mask
~(key (first hmap)) ~(key (last hmap)) ~default ~hmap
~(every? keyword? (keys case-map)))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;; helper files ;;;;;;;;;;;; ;;;;;;;;;;;;;
(alter-meta! (find-ns ’clojure.core) assoc
:doc "Fundamental library of the Clojure language")
(load "core_proxy")
(load "core_print")
(load "genclass")
(load "core_deftype")
(load "core/protocols")
(load "gvec")
;; redefine reduce with internal-reduce
(defn reduce
"f should be a function of 2 arguments. If val is not supplied,
returns the result of applying f to the first 2 items in coll, t hen
applying f to that result and the 3rd item, etc. If coll contai ns no
items, f must accept no arguments as well, and reduce returns the
result of calling f with no arguments. If coll has only 1 item, it
is returned and f is not called. If val is supplied, returns th e
result of applying f to val and the first item in coll, then
applying f to that result and the 2nd item, etc. If coll contai ns no
items, returns val and f is not called."
{:added "1.0"}
([f coll]
(if-let [s (seq coll)]
(reduce f (first s) (next s))
(f)))
([f val coll]
(let [s (seq coll)]
(clojure.core.protocols/internal-reduce s f val))))
(defn into
"Returns a new coll consisting of to-coll with all of the item s of
11.1. CORE.CLJ 1289
from-coll conjoined."
{:added "1.0"
:static true}
[to from]
(if (instance? clojure.lang.IEditableCollection to)
(persistent! (reduce conj! (transient to) from))
(reduce conj to from)))
(require ’[clojure.java.io :as jio])
(defn- normalize-slurp-opts
[opts]
(if (string? (first opts))
(do
(println
"WARNING: (slurp f enc) is deprecated, use (slurp f :encodin g enc).")
[:encoding (first opts)])
opts))
(defn slurp
"Opens a reader on f and reads all its contents, returning a st ring.
See clojure.java.io/reader for a complete list of supporte d arguments."
{:added "1.0"}
([f & opts]
(let [opts (normalize-slurp-opts opts)
sb (StringBuilder.)]
(with-open [#^java.io.Reader r (apply jio/reader f opts)]
(loop [c (.read r)]
(if (neg? c)
(str sb)
(do
(.append sb (char c))
(recur (.read r)))))))))
(defn spit
"Opposite of slurp. Opens f with writer, writes content, the n
closes f. Options passed to clojure.java.io/writer."
{:added "1.2"}
[f content & options]
(with-open [#^java.io.Writer w (apply jio/writer f option s)]
(.write w (str content))))
\getchunk{defn future-call}
\getchunk{defmacro future}
\getchunk{defn future-cancel}
\getchunk{defn future-cancelled?}
1290 CHAPTER 11. CLJ/CLOJURE/
(defn pmap
"Like map, except f is applied in parallel. Semi-lazy in that the
parallel computation stays ahead of the consumption, but do esn’t
realize the entire result unless required. Only useful for
computationally intensive functions where the time of f dom inates
the coordination overhead."
{:added "1.0"
:static true}
([f coll]
(let [n (+ 2 (.. Runtime getRuntime availableProcessors))
rets (map #(future (f %)) coll)
step (fn step [[x & xs :as vs] fs]
(lazy-seq
(if-let [s (seq fs)]
(cons (deref x) (step xs (rest s)))
(map deref vs))))]
(step rets (drop n rets))))
([f coll & colls]
(let [step (fn step [cs]
(lazy-seq
(let [ss (map seq cs)]
(when (every? identity ss)
(cons (map first ss) (step (map rest ss)))))))]
(pmap #(apply f %) (step (cons coll colls))))))
(defn pcalls
"Executes the no-arg fns in parallel, returning a lazy seque nce of
their values"
{:added "1.0"
:static true}
[& fns] (pmap #(%) fns))
(defmacro pvalues
"Returns a lazy sequence of the values of the exprs, which are
evaluated in parallel"
{:added "1.0"
:static true}
[& exprs]
‘(pcalls ~@(map #(list ‘fn [] %) exprs)))
;;;;;;;;;;;;;;;;;;;;;;;; clojure version number ;;;;;;; ;;;;;;;;;;;;;;;
(let [version-stream (.getResourceAsStream (clojure.la ng.RT/baseLoader)
"clojure/version.properties")
properties
(doto (new java.util.Properties) (.load version-stream) )
prop (fn [k] (.getProperty properties (str "clojure.versi on." k)))
clojure-version
{:major (Integer/valueOf ^String (prop "major"))
11.1. CORE.CLJ 1291
:minor (Integer/valueOf ^String (prop "minor"))
:incremental (Integer/valueOf ^String (prop "incrementa l"))
:qualifier (prop "qualifier")}]
(def ^:dynamic *clojure-version*
(if (not (= (prop "interim") "false"))
(clojure.lang.RT/assoc clojure-version :interim true)
clojure-version)))
(add-doc-and-meta *clojure-version*
"The version info for Clojure core, as a map containing :majo r :minor
:incremental and :qualifier keys. Feature releases may inc rement
:minor and/or :major, bugfix releases will increment :incr emental.
Possible values of :qualifier include
\"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\""
{:added "1.0"})
(defn
clojure-version
"Returns clojure version as a printable string."
{:added "1.0"}
[]
(str (:major *clojure-version*)
"."
(:minor *clojure-version*)
(when-let [i (:incremental *clojure-version*)]
(str "." i))
(when-let [q (:qualifier *clojure-version*)]
(when (pos? (count q)) (str "-" q)))
(when (:interim *clojure-version*)
"-SNAPSHOT")))
\getchunk{defn promise}
\getchunk{defn deliver}
(defn flatten
"Takes any nested combination of sequential things (lists, vectors,
etc.) and returns their contents as a single, flat sequence.
(flatten nil) returns nil."
{:added "1.2"
:static true}
[x]
(filter (complement sequential?)
(rest (tree-seq sequential? seq x))))
(defn group-by
"Returns a map of the elements of coll keyed by the result of
f on each element. The value at each key will be a vector of the
corresponding elements, in the order they appeared in coll. "
{:added "1.2"
1292 CHAPTER 11. CLJ/CLOJURE/
:static true}
[f coll]
(persistent!
(reduce
(fn [ret x]
(let [k (f x)]
(assoc! ret k (conj (get ret k []) x))))
(transient {}) coll)))
(defn partition-by
"Applies f to each value in coll, splitting it each time f retu rns
a new value. Returns a lazy seq of partitions."
{:added "1.2"
:static true}
[f coll]
(lazy-seq
(when-let [s (seq coll)]
(let [fst (first s)
fv (f fst)
run (cons fst (take-while #(= fv (f %)) (rest s)))]
(cons run (partition-by f (drop (count run) s)))))))
(defn frequencies
"Returns a map from distinct items in coll to the number of tim es
they appear."
{:added "1.2"
:static true}
[coll]
(persistent!
(reduce (fn [counts x]
(assoc! counts x (inc (get counts x 0))))
(transient {}) coll)))
(defn reductions
"Returns a lazy seq of the intermediate values of the reducti on (as
per reduce) of coll by f, starting with init."
{:added "1.2"}
([f coll]
(lazy-seq
(if-let [s (seq coll)]
(reductions f (first s) (rest s))
(list (f)))))
([f init coll]
(cons init
(lazy-seq
(when-let [s (seq coll)]
(reductions f (f init (first s)) (rest s)))))))
(defn rand-nth
"Return a random element of the (sequential) collection. Wi ll have
11.1. CORE.CLJ 1293
the same performance characteristics as nth for the given
collection."
{:added "1.2"
:static true}
[coll]
(nth coll (rand-int (count coll))))
(defn partition-all
"Returns a lazy sequence of lists like partition, but may inc lude
partitions with fewer than n items at the end."
{:added "1.2"
:static true}
([n coll]
(partition-all n n coll))
([n step coll]
(lazy-seq
(when-let [s (seq coll)]
(cons (take n s) (partition-all n step (drop step s)))))))
(defn shuffle
"Return a random permutation of coll"
{:added "1.2"
:static true}
[^java.util.Collection coll]
(let [al (java.util.ArrayList. coll)]
(java.util.Collections/shuffle al)
(clojure.lang.RT/vector (.toArray al))))
(defn map-indexed
"Returns a lazy sequence consisting of the result of applyin g f to 0
and the first item of coll, followed by applying f to 1 and the s econd
item in coll, etc, until coll is exhausted. Thus function f sh ould
accept 2 arguments, index and item."
{:added "1.2"
:static true}
[f coll]
(letfn
[(mapi [idx coll]
(lazy-seq
(when-let [s (seq coll)]
(if (chunked-seq? s)
(let [c (chunk-first s)
size (int (count c))
b (chunk-buffer size)]
(dotimes [i size]
(chunk-append b (f (+ idx i) (.nth c i))))
(chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))
(cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]
(mapi 0 coll)))
1294 CHAPTER 11. CLJ/CLOJURE/
(defn keep
"Returns a lazy sequence of the non-nil results of (f item). N ote,
this means false return values will be included. f must be fre e of
side-effects."
{:added "1.2"
:static true}
([f coll]
(lazy-seq
(when-let [s (seq coll)]
(if (chunked-seq? s)
(let [c (chunk-first s)
size (count c)
b (chunk-buffer size)]
(dotimes [i size]
(let [x (f (.nth c i))]
(when-not (nil? x)
(chunk-append b x))))
(chunk-cons (chunk b) (keep f (chunk-rest s))))
(let [x (f (first s))]
(if (nil? x)
(keep f (rest s))
(cons x (keep f (rest s))))))))))
(defn keep-indexed
"Returns a lazy sequence of the non-nil results of (f index it em).
Note, this means false return values will be included. f must be
free of side-effects."
{:added "1.2"
:static true}
([f coll]
(letfn [(keepi [idx coll]
(lazy-seq
(when-let [s (seq coll)]
(if (chunked-seq? s)
(let [c (chunk-first s)
size (count c)
b (chunk-buffer size)]
(dotimes [i size]
(let [x (f (+ idx i) (.nth c i))]
(when-not (nil? x)
(chunk-append b x))))
(chunk-cons (chunk b)
(keepi (+ idx size) (chunk-rest s))))
(let [x (f idx (first s))]
(if (nil? x)
(keepi (inc idx) (rest s))
(cons x (keepi (inc idx) (rest s)))))))))]
(keepi 0 coll))))
(defn fnil
11.1. CORE.CLJ 1295
"Takes a function f, and returns a function that calls f, repl acing
a nil first argument to f with the supplied value x. Higher ari ty
versions can replace arguments in the second and third
positions (y, z). Note that the function f can take any number of
arguments, not just the one(s) being nil-patched."
{:added "1.2"
:static true}
([f x]
(fn
([a] (f (if (nil? a) x a)))
([a b] (f (if (nil? a) x a) b))
([a b c] (f (if (nil? a) x a) b c))
([a b c & ds] (apply f (if (nil? a) x a) b c ds))))
([f x y]
(fn
([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))
([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))
([f x y z]
(fn
([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))
([a b c & ds]
(apply f (if (nil? a) x a)
(if (nil? b) y b)
(if (nil? c) z c) ds)))))
(defn- ^{:dynamic true} assert-valid-fdecl
"A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn."
[fdecl]
(if-let [bad-args (seq (remove #(vector? %) (map first fdec l)))]
(throw (IllegalArgumentException. (str
"Parameter declaration " (first bad-args)
" should be a vector")))))
(defn with-redefs-fn
"Temporarily redefines Vars during a call to func. Each val o f
binding-map will replace the root value of its key which must be
a Var. After func is called with no args, the root values of all
the Vars will be set back to their old values. These temporary
changes will be visible in all threads. Useful for mocking ou t
functions during testing."
{:added "1.3"}
[binding-map func]
(let [root-bind (fn [m]
(doseq [[a-var a-val] m]
(.bindRoot ^clojure.lang.Var a-var a-val)))
old-vals (zipmap (keys binding-map)
(map deref (keys binding-map)))]
(try
1296 CHAPTER 11. CLJ/CLOJURE/
(root-bind binding-map)
(func)
(finally
(root-bind old-vals)))))
(defmacro with-redefs
"binding => var-symbol temp-value-expr
Temporarily redefines Vars while executing the body. The
temp-value-exprs will be evaluated and each resulting valu e will
replace in parallel the root value of its Var. After the body i s
executed, the root values of all the Vars will be set back to th eir
old values. These temporary changes will be visible in all th reads.
Useful for mocking out functions during testing."
{:added "1.3"}
[bindings & body]
‘(with-redefs-fn ~(zipmap (map #(list ‘var %) (take-nth 2 b indings))
(take-nth 2 (next bindings)))
(fn [] ~@body)))
———-
11.2 protocols.clj
— protocols.clj —
\getchunk{Clojure Copyright}
(ns clojure.core.protocols)
(defprotocol InternalReduce
"Protocol for concrete seq types that can reduce themselves
faster than first/next recursion. Called by clojure.core/ reduce."
(internal-reduce [seq f start]))
(extend-protocol InternalReduce
nil
(internal-reduce
[s f val]
val)
;; handles vectors and ranges
clojure.lang.IChunkedSeq
(internal-reduce
[s f val]
(if-let [s (seq s)]
(if (chunked-seq? s)
11.2. PROTOCOLS.CLJ 1297
(recur (chunk-next s)
f
(.reduce (chunk-first s) f val))
(internal-reduce s f val))
val))
clojure.lang.StringSeq
(internal-reduce
[str-seq f val]
(let [s (.s str-seq)]
(loop [i (.i str-seq)
val val]
(if (< i (.length s))
(recur (inc i) (f val (.charAt s i)))
val))))
clojure.lang.ArraySeq
(internal-reduce
[a-seq f val]
(let [^objects arr (.array a-seq)]
(loop [i (.index a-seq)
val val]
(if (< i (alength arr))
(recur (inc i) (f val (aget arr i)))
val))))
java.lang.Object
(internal-reduce
[s f val]
(loop [cls (class s)
s s
f f
val val]
(if-let [s (seq s)]
;; roll over to faster implementation if underlying seq chan ges type
(if (identical? (class s) cls)
(recur cls (next s) f (f val (first s)))
(internal-reduce s f val))
val))))
(def arr-impl
’(internal-reduce
[a-seq f val]
(let [arr (.array a-seq)]
(loop [i (.index a-seq)
val val]
(if (< i (alength arr))
(recur (inc i) (f val (aget arr i)))
val)))))
1298 CHAPTER 11. CLJ/CLOJURE/
(defn- emit-array-impls*
[syms]
(apply
concat
(map
(fn [s]
[(symbol (str "clojure.lang.ArraySeq$ArraySeq_" s))
arr-impl])
syms)))
(defmacro emit-array-impls
[& syms]
‘(extend-protocol InternalReduce
~@(emit-array-impls* syms)))
(emit-array-impls int long float double byte char boolean)
———-
11.3 core˙deftype.clj
— core˙deftype.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.core)
;;;;;;;;;;;;;;;;;;;;;;;; definterface ;;;;;;;;;;;;;;; ;;;;;;;;;;;;;
(defn namespace-munge
"Convert a Clojure namespace name to a legal Java package nam e."
{:added "1.2"}
[ns]
(.replace (str ns) \- \_))
;for now, built on gen-interface
(defmacro definterface
[name & sigs]
(let [tag (fn [x] (or (:tag (meta x)) Object))
psig (fn [[name [& args]]]
(vector name
(vec (map tag args))
(tag name)
(map meta args)))
cname (with-meta
(symbol (str (namespace-munge *ns*) "." name))
11.3. CORE˙DEFTYPE.CLJ 1299
(meta name))]
‘(let []
(gen-interface :name ~cname :methods ~(vec (map psig sigs) ))
(import ~cname))))
;;;;;;;;;;;;;;;;;;;;;;; reify/deftype ;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- parse-opts [s]
(loop [opts {} [k v & rs :as s] s]
(if (keyword? k)
(recur (assoc opts k v) rs)
[opts s])))
(defn- parse-impls [specs]
(loop [ret {} s specs]
(if (seq s)
(recur (assoc ret (first s) (take-while seq? (next s)))
(drop-while seq? (next s)))
ret)))
(defn- parse-opts+specs [opts+specs]
(let [[opts specs] (parse-opts opts+specs)
impls (parse-impls specs)
interfaces (-> (map #(if (var? (resolve %))
(:on (deref (resolve %)))
%)
(keys impls))
set
(disj ’Object ’java.lang.Object)
vec)
methods (map (fn [[name params & body]]
(cons name (maybe-destructured params body)))
(apply concat (vals impls)))]
(when-let [bad-opts (seq (remove #{:no-print} (keys opts) ))]
(throw (IllegalArgumentException.
(apply print-str "Unsupported option(s) -" bad-opts))))
[interfaces methods opts]))
(defmacro reify
"reify is a macro with the following structure:
(reify options* specs*)
Currently there are no options.
Each spec consists of the protocol or interface name followe d by zero
or more method bodies:
protocol-or-interface-or-Object
(methodName [args+] body)*
1300 CHAPTER 11. CLJ/CLOJURE/
Methods should be supplied for all methods of the desired
protocol(s) and interface(s). You can also define override s for
methods of Object. Note that the first parameter must be supp lied to
correspond to the target object (’this’ in Java parlance). T hus
methods for interfaces will take one more argument than do th e
interface declarations. Note also that recur calls to the me thod
head should *not* pass the target object, it will be supplied
automatically and can not be substituted.
The return type can be indicated by a type hint on the method na me,
and arg types can be indicated by a type hint on arg names. If yo u
leave out all hints, reify will try to match on same name/arit y
method in the protocol(s)/interface(s) - this is preferred . If you
supply any hints at all, no inference is done, so all hints (or
default of Object) must be correct, for both arguments and re turn
type. If a method is overloaded in a protocol/interface, mul tiple
independent method definitions must be supplied. If overlo aded with
same arity in an interface you must specify complete hints to
disambiguate - a missing hint implies Object.
recur works to method heads The method bodies of reify are lex ical
closures, and can refer to the surrounding local scope:
(str (let [f \"foo\"]
(reify Object
(toString [this] f))))
== \"foo\"
(seq (let [f \"foo\"]
(reify clojure.lang.Seqable
(seq [this] (seq f)))))
== (\\f \\o \\o))"
{:added "1.2"}
[& opts+specs]
(let [[interfaces methods] (parse-opts+specs opts+specs )]
(with-meta ‘(reify* ~interfaces ~@methods) (meta &form)) ))
(defn hash-combine [x y]
(clojure.lang.Util/hashCombine x (clojure.lang.Util/h ash y)))
(defn munge [s]
((if (symbol? s) symbol str) (clojure.lang.Compiler/mung e (str s))))
(defn- imap-cons
[^IPersistentMap this o]
(cond
(instance? java.util.Map$Entry o)
(let [^java.util.Map$Entry pair o]
(.assoc this (.getKey pair) (.getValue pair)))
11.3. CORE˙DEFTYPE.CLJ 1301
(instance? clojure.lang.IPersistentVector o)
(let [^clojure.lang.IPersistentVector vec o]
(.assoc this (.nth vec 0) (.nth vec 1)))
:else (loop [this this
o o]
(if (seq o)
(let [^java.util.Map$Entry pair (first o)]
(recur (.assoc this (.getKey pair) (.getValue pair))
(rest o)))
this))))
(defn- emit-defrecord
"Do not use this directly - use defrecord"
{:added "1.2"}
[tagname name fields interfaces methods]
(let [tag (keyword (str *ns*) (str tagname))
classname
(with-meta (symbol (str (namespace-munge *ns*) "." name))
(meta name))
interfaces (vec interfaces)
interface-set (set (map resolve interfaces))
methodname-set (set (map first methods))
hinted-fields fields
fields (vec (map #(with-meta % nil) fields))
base-fields fields
fields (conj fields ’__meta ’__extmap)]
(when (some #{:volatile-mutable :unsynchronized-mutabl e}
(mapcat (comp keys meta) hinted-fields))
(throw (IllegalArgumentException.
(str ":volatile-mutable or :unsynchronized-mutable not "
"supported for record fields"))))
(let [gs (gensym)]
(letfn
[(eqhash [[i m]]
[i
(conj m
‘(hashCode [this#]
(clojure.lang.APersistentMap/mapHash this#))
‘(equals [this# ~gs]
(clojure.lang.APersistentMap/mapEquals this# ~gs)))])
(iobj [[i m]]
[(conj i ’clojure.lang.IObj)
(conj m ‘(meta [this#] ~’__meta)
‘(withMeta [this# ~gs]
(new ~tagname ~@(replace {’__meta gs} fields))))])
(ilookup [[i m]]
[(conj i ’clojure.lang.ILookup ’clojure.lang.IKeywordL ookup)
(conj m ‘(valAt [this# k#] (.valAt this# k# nil))
‘(valAt [this# k# else#]
(case k# ~@(mapcat (fn [fld] [(keyword fld) fld])
1302 CHAPTER 11. CLJ/CLOJURE/
base-fields)
(get ~’__extmap k# else#)))
‘(getLookupThunk [this# k#]
(let [~’gclass (class this#)]
(case k#
~@(let [hinted-target
(with-meta ’gtarget {:tag tagname})]
(mapcat
(fn [fld]
[(keyword fld)
‘(reify clojure.lang.ILookupThunk
(get [~’thunk ~’gtarget]
(if
(identical?
(class ~’gtarget) ~’gclass)
(. ~hinted-target
~(keyword fld))
~’thunk)))])
base-fields))
nil))))])
(imap [[i m]]
[(conj i ’clojure.lang.IPersistentMap)
(conj m
‘(count [this#]
(+ ~(count base-fields) (count ~’__extmap)))
‘(empty [this#]
(throw (UnsupportedOperationException.
(str "Can’t create empty: " ~(str classname)))))
‘(cons [this# e#] ((var imap-cons) this# e#))
‘(equiv [this# ~gs]
(boolean
(or (identical? this# ~gs)
(when (identical? (class this#) (class ~gs))
(let [~gs ~(with-meta gs {:tag tagname})]
(and
~@(map
(fn [fld]
‘(= ~fld (. ~gs ~fld)))
base-fields)
(= ~’__extmap
(. ~gs ~’__extmap))))))))
‘(containsKey [this# k#]
(not (identical? this# (.valAt this# k# this#))))
‘(entryAt [this# k#]
(let [v# (.valAt this# k# this#)]
(when-not (identical? this# v#)
(clojure.lang.MapEntry. k# v#))))
‘(seq [this#]
(seq
(concat
11.3. CORE˙DEFTYPE.CLJ 1303
[~@(map
#(list ‘new ‘clojure.lang.MapEntry
(keyword %) %) base-fields)]
~’__extmap)))
‘(assoc [this# k# ~gs]
(condp identical? k#
~@(mapcat
(fn [fld]
[(keyword fld)
(list* ‘new tagname
(replace {fld gs} fields))])
base-fields)
(new ~tagname
~@(remove #{’__extmap} fields)
(assoc ~’__extmap k# ~gs))))
‘(without [this# k#]
(if
(contains? #{~@(map keyword base-fields)} k#)
(dissoc (with-meta (into {} this#) ~’__meta) k#)
(new ~tagname ~@(remove #{’__extmap} fields)
(not-empty (dissoc ~’__extmap k#))))))])
(ijavamap [[i m]]
[(conj i ’java.util.Map ’java.io.Serializable)
(conj m
‘(size [this#] (.count this#))
‘(isEmpty [this#] (= 0 (.count this#)))
‘(containsValue [this# v#]
(boolean (some #{v#} (vals this#))))
‘(get [this# k#] (.valAt this# k#))
‘(put [this# k# v#]
(throw (UnsupportedOperationException.)))
‘(remove [this# k#]
(throw (UnsupportedOperationException.)))
‘(putAll [this# m#]
(throw (UnsupportedOperationException.)))
‘(clear [this#]
(throw (UnsupportedOperationException.)))
‘(keySet [this#] (set (keys this#)))
‘(values [this#] (vals this#))
‘(entrySet [this#] (set this#)))])
]
(let [[i m]
(-> [interfaces methods] eqhash iobj ilookup imap ijavamap )]
‘(deftype* ~tagname ~classname
~(conj hinted-fields ’__meta ’__extmap)
:implements ~(vec i)
~@m))))))
(defmacro defrecord
"Alpha - subject to change
1304 CHAPTER 11. CLJ/CLOJURE/
(defrecord name [fields*] options* specs*)
Currently there are no options.
Each spec consists of a protocol or interface name followed b y zero
or more method bodies:
protocol-or-interface-or-Object
(methodName [args*] body)*
Dynamically generates compiled bytecode for class with the given
name, in a package with the same name as the current namespace , the
given fields, and, optionally, methods for protocols and/o r
interfaces.
The class will have the (immutable) fields named by
fields, which can have type hints. Protocols/interfaces an d methods
are optional. The only methods that can be supplied are those
declared in the protocols/interfaces. Note that method bod ies are
not closures, the local environment includes only the named fields,
and those fields can be accessed directy.
Method definitions take the form:
(methodname [args*] body)
The argument and return types can be hinted on the arg and
methodname symbols. If not supplied, they will be inferred, so type
hints should be reserved for disambiguation.
Methods should be supplied for all methods of the desired
protocol(s) and interface(s). You can also define override s for
methods of Object. Note that a parameter must be supplied to
correspond to the target object (’this’ in Java parlance). T hus
methods for interfaces will take one more argument than do th e
interface declarations. Note also that recur calls to the me thod
head should *not* pass the target object, it will be supplied
automatically and can not be substituted.
In the method bodies, the (unqualified) name can be used to na me the
class (for calls to new, instance? etc).
The class will have implementations of several (clojure.la ng)
interfaces generated automatically: IObj (metadata suppo rt) and
IPersistentMap, and all of their superinterfaces.
In addition, defrecord will define type-and-value-based e quality and
hashCode.
11.3. CORE˙DEFTYPE.CLJ 1305
When AOT compiling, generates compiled bytecode for a class with the
given name (a symbol), prepends the current ns as the package , and
writes the .class file to the *compile-path* directory.
Two constructors will be defined, one taking the designated fields
followed by a metadata map (nil for none) and an extension fie ld
map (nil for none), and one taking only the fields (using nil f or
meta and extension fields)."
{:added "1.2"}
[name [& fields] & opts+specs]
(let [gname name
[interfaces methods opts] (parse-opts+specs opts+specs)
classname (symbol (str (namespace-munge *ns*) "." gname))
tag (keyword (str *ns*) (str name))
hinted-fields fields
fields (vec (map #(with-meta % nil) fields))]
‘(let []
~(emit-defrecord name gname
(vec hinted-fields) (vec interfaces) methods)
(defmethod print-method ~classname [o# w#]
((var print-defrecord) o# w#))
(import ~classname)
#_(defn ~name
([~@fields] (new ~classname ~@fields nil nil))
([~@fields meta# extmap#]
(new ~classname ~@fields meta# extmap#))))))
(defn- print-defrecord [o ^Writer w]
(print-meta o w)
(.write w "#:")
(.write w (.getName (class o)))
(print-map
o
pr-on w))
(defn- emit-deftype*
"Do not use this directly - use deftype"
[tagname name fields interfaces methods]
(let [classname
(with-meta (symbol (str (namespace-munge *ns*) "." name))
(meta name))]
‘(deftype* ~tagname ~classname ~fields
:implements ~interfaces
~@methods)))
(defmacro deftype
"Alpha - subject to change
(deftype name [fields*] options* specs*)
1306 CHAPTER 11. CLJ/CLOJURE/
Currently there are no options.
Each spec consists of a protocol or interface name followed b y zero
or more method bodies:
protocol-or-interface-or-Object
(methodName [args*] body)*
Dynamically generates compiled bytecode for class with the given
name, in a package with the same name as the current namespace , the
given fields, and, optionally, methods for protocols and/o r
interfaces.
The class will have the (by default, immutable) fields named by
fields, which can have type hints. Protocols/interfaces an d methods
are optional. The only methods that can be supplied are those
declared in the protocols/interfaces. Note that method bod ies are
not closures, the local environment includes only the named fields,
and those fields can be accessed directy. Fields can be quali fied
with the metadata :volatile-mutable true or :unsynchroniz ed-mutable
true, at which point (set! afield aval) will be supported in m ethod
bodies. Note well that mutable fields are extremely difficu lt to use
correctly, and are present only to facilitate the building o f higher
level constructs, such as Clojure’s reference types, in Clo jure
itself. They are for experts only - if the semantics and
implications of :volatile-mutable or :unsynchronized-mu table are not
immediately apparent to you, you should not be using them.
Method definitions take the form:
(methodname [args*] body)
The argument and return types can be hinted on the arg and
methodname symbols. If not supplied, they will be inferred, so type
hints should be reserved for disambiguation.
Methods should be supplied for all methods of the desired
protocol(s) and interface(s). You can also define override s for
methods of Object. Note that a parameter must be supplied to
correspond to the target object (’this’ in Java parlance). T hus
methods for interfaces will take one more argument than do th e
interface declarations. Note also that recur calls to the me thod
head should *not* pass the target object, it will be supplied
automatically and can not be substituted.
In the method bodies, the (unqualified) name can be used to na me the
class (for calls to new, instance? etc).
When AOT compiling, generates compiled bytecode for a class with the
11.3. CORE˙DEFTYPE.CLJ 1307
given name (a symbol), prepends the current ns as the package , and
writes the .class file to the *compile-path* directory.
One constructors will be defined, taking the designated fie lds."
{:added "1.2"}
[name [& fields] & opts+specs]
(let [gname name
[interfaces methods opts] (parse-opts+specs opts+specs)
classname (symbol (str (namespace-munge *ns*) "." gname))
tag (keyword (str *ns*) (str name))
hinted-fields fields
fields (vec (map #(with-meta % nil) fields))]
‘(let []
~(emit-deftype* name gname
(vec hinted-fields) (vec interfaces) methods)
(import ~classname))))
;;;;;;;;;;;;;;;;;;;;;;; protocols ;;;;;;;;;;;;;;;;;;; ;;;;;
(defn- expand-method-impl-cache [^clojure.lang.Method ImplCache cache c f]
(let [cs
(into1 {}
(remove (fn [[c e]] (nil? e))
(map vec (partition 2 (.table cache)))))
cs (assoc cs c (clojure.lang.MethodImplCache$Entry. c f))
[shift mask] (min-hash (keys cs))
table (make-array Object (* 2 (inc mask)))
table
(reduce1 (fn [^objects t [c e]]
(let [i (* 2 (int (shift-mask shift mask (hash c))))]
(aset t i c)
(aset t (inc i) e)
t))
table cs)]
(clojure.lang.MethodImplCache.
(.protocol cache) (.methodk cache) shift mask table)))
(defn- super-chain [^Class c]
(when c
(cons c (super-chain (.getSuperclass c)))))
(defn- pref
([] nil)
([a] a)
([^Class a ^Class b]
(if (.isAssignableFrom a b) b a)))
1308 CHAPTER 11. CLJ/CLOJURE/
(defn find-protocol-impl [protocol x]
(if (instance? (:on-interface protocol) x)
x
(let [c (class x)
impl #(get (:impls protocol) %)]
(or (impl c)
(and c
(or
(first (remove nil? (map impl (butlast (super-chain c)))))
(when-let [t
(reduce1 pref
(filter impl (disj (supers c) Object)))]
(impl t))
(impl Object)))))))
(defn find-protocol-method [protocol methodk x]
(get (find-protocol-impl protocol x) methodk))
(defn- protocol?
[maybe-p]
(boolean (:on-interface maybe-p)))
(defn- implements? [protocol atype]
(and atype (.isAssignableFrom ^Class (:on-interface prot ocol) atype)))
(defn extends?
"Returns true if atype extends protocol"
{:added "1.2"}
[protocol atype]
(boolean (or (implements? protocol atype)
(get (:impls protocol) atype))))
(defn extenders
"Returns a collection of the types explicitly extending pro tocol"
{:added "1.2"}
[protocol]
(keys (:impls protocol)))
(defn satisfies?
"Returns true if x satisfies the protocol"
{:added "1.2"}
[protocol x]
(boolean (find-protocol-impl protocol x)))
(defn -cache-protocol-fn
[^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]
(let [cache (.__methodImplCache pf)
f (if (.isInstance c x)
interf
11.3. CORE˙DEFTYPE.CLJ 1309
(find-protocol-method (.protocol cache) (.methodk cache ) x))]
(when-not f
(throw (IllegalArgumentException.
(str "No implementation of method: " (.methodk cache)
" of protocol: " (:var (.protocol cache))
" found for class: " (if (nil? x) "nil"
(.getName (class x)))))))
(set! (.__methodImplCache pf)
(expand-method-impl-cache cache (class x) f))
f))
(defn- emit-method-builder [on-interface method on-meth od arglists]
(let [methodk (keyword method)
gthis (with-meta (gensym) {:tag ’clojure.lang.AFunction })
ginterf (gensym)]
‘(fn [cache#]
(let [~ginterf
(fn
~@(map
(fn [args]
(let [gargs (map #(gensym (str "gf__" % "__")) args)
target (first gargs)]
‘([~@gargs]
(. ~(with-meta target {:tag on-interface})
~(or on-method method) ~@(rest gargs)))))
arglists))
^clojure.lang.AFunction f#
(fn ~gthis
~@(map
(fn [args]
(let [gargs (map #(gensym (str "gf__" % "__")) args)
target (first gargs)]
‘([~@gargs]
(let [cache# (.__methodImplCache ~gthis)
f# (.fnFor cache#
(clojure.lang.Util/classOf ~target))]
(if f#
(f# ~@gargs)
((-cache-protocol-fn
~gthis ~target
~on-interface ~ginterf) ~@gargs))))))
arglists))]
(set! (.__methodImplCache f#) cache#)
f#))))
(defn -reset-methods [protocol]
(doseq [[^clojure.lang.Var v build] (:method-builders pr otocol)]
(let [cache
(clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]
(.bindRoot v (build cache)))))
1310 CHAPTER 11. CLJ/CLOJURE/
(defn- assert-same-protocol [protocol-var method-syms]
(doseq [m method-syms]
(let [v (resolve m)
p (:protocol (meta v))]
(when (and v (bound? v) (not= protocol-var p))
(binding [*out* *err*]
(println "Warning: protocol" protocol-var "is overwritin g"
(if p
(str "method " (.sym v) " of protocol " (.sym p))
(str "function " (.sym v)))))))))
(defn- emit-protocol [name opts+sigs]
(let [iname
(symbol (str (munge (namespace-munge *ns*)) "." (munge nam e)))
[opts sigs]
(loop [opts {:on (list ’quote iname) :on-interface iname}
sigs opts+sigs]
(condp #(%1 %2) (first sigs)
string? (recur (assoc opts :doc (first sigs)) (next sigs))
keyword?
(recur (assoc opts (first sigs) (second sigs))
(nnext sigs))
[opts sigs]))
sigs (reduce1
(fn [m s]
(let [name-meta (meta (first s))
mname (with-meta (first s) nil)
[arglists doc]
(loop [as [] rs (rest s)]
(if (vector? (first rs))
(recur (conj as (first rs)) (next rs))
[(seq as) (first rs)]))]
(when (some #{0} (map count arglists))
(throw (IllegalArgumentException.
(str "Protocol fn: " mname
" must take at least one arg"))))
(assoc m (keyword mname)
(merge name-meta
{:name (vary-meta mname assoc
:doc doc :arglists arglists)
:arglists arglists
:doc doc}))))
{} sigs)
meths (mapcat
(fn [sig]
(let [m (munge (:name sig))]
(map #(vector m
(vec (repeat (dec (count %))’Object))
’Object)
11.3. CORE˙DEFTYPE.CLJ 1311
(:arglists sig))))
(vals sigs))]
‘(do
(defonce ~name {})
(gen-interface :name ~iname :methods ~meths)
(alter-meta! (var ~name) assoc :doc ~(:doc opts))
(#’assert-same-protocol (var ~name) ’~(map :name (vals si gs)))
(alter-var-root (var ~name) merge
(assoc ~opts
:sigs ’~sigs
:var (var ~name)
:method-map
~(and (:on opts)
(apply hash-map
(mapcat
(fn [s]
[(keyword (:name s))
(keyword (or (:on s) (:name s)))])
(vals sigs))))
:method-builders
~(apply hash-map
(mapcat
(fn [s]
[‘(intern *ns*
(with-meta ’~(:name s)
(merge ’~s {:protocol (var ~name)})))
(emit-method-builder
(:on-interface opts)
(:name s)
(:on s)
(:arglists s))])
(vals sigs)))))
(-reset-methods ~name)
’~name)))
(defmacro defprotocol
"A protocol is a named set of named methods and their signatur es:
(defprotocol AProtocolName
;optional doc string
\"A doc string for AProtocol abstraction\"
;method signatures
(bar [this a b] \"bar docs\")
(baz [this a] [this a b] [this a b c] \"baz docs\"))
No implementations are provided. Docs can be specified for t he
protocol overall and for each method. The above yields a set o f
polymorphic functions and a protocol object. All are
namespace-qualified by the ns enclosing the definition The resulting
1312 CHAPTER 11. CLJ/CLOJURE/
functions dispatch on the type of their first argument, whic h is
required and corresponds to the implicit target object (’th is’ in
Java parlance). defprotocol is dynamic, has no special comp ile-time
effect, and defines no new types or classes. Implementation s of
the protocol methods can be provided using extend.
defprotocol will automatically generate a corresponding i nterface,
with the same name as the protocol, i.e. given a protocol:
my.ns/Protocol, an interface: my.ns.Protocol. The interf ace will
have methods corresponding to the protocol functions, and t he
protocol will automatically work with instances of the inte rface.
Note that you should not use this interface with deftype or
reify, as they support the protocol directly:
(defprotocol P
(foo [this])
(bar-me [this] [this y]))
(deftype Foo [a b c]
P
(foo [this] a)
(bar-me [this] b)
(bar-me [this y] (+ c y)))
(bar-me (Foo. 1 2 3) 42)
=> 45
(foo
(let [x 42]
(reify P
(foo [this] 17)
(bar-me [this] x)
(bar-me [this y] x))))
=> 17"
{:added "1.2"}
[name & opts+sigs]
(emit-protocol name opts+sigs))
(defn extend
"Implementations of protocol methods can be provided using
the extend construct:
(extend AType
AProtocol
{:foo an-existing-fn
:bar (fn [a b] ...)
:baz (fn ([a]...) ([a b] ...)...)}
BProtocol
{...}
11.3. CORE˙DEFTYPE.CLJ 1313
...)
extend takes a type/class (or interface, see below), and one or more
protocol + method map pairs. It will extend the polymorphism of the
protocol’s methods to call the supplied methods when an ATyp e is
provided as the first argument.
Method maps are maps of the keyword-ized method names to ordi nary
fns. This facilitates easy reuse of existing fns and fn maps, for
code reuse/mixins without derivation or composition. You c an extend
an interface to a protocol. This is primarily to facilitate i nterop
with the host (e.g. Java) but opens the door to incidental mul tiple
inheritance of implementation since a class can inherit fro m more
than one interface, both of which extend the protocol. It is T BD how
to specify which impl to use. You can extend a protocol on nil.
If you are supplying the definitions explicitly (i.e. not re using
exsting functions or mixin maps), you may find it more conven ient to
use the extend-type or extend-protocol macros.
Note that multiple independent extend clauses can exist for the same
type, not all protocols need be defined in a single extend cal l.
See also:
extends?, satisfies?, extenders"
{:added "1.2"}
[atype & proto+mmaps]
(doseq [[proto mmap] (partition 2 proto+mmaps)]
(when-not (protocol? proto)
(throw (IllegalArgumentException.
(str proto " is not a protocol"))))
(when (implements? proto atype)
(throw (IllegalArgumentException.
(str atype " already directly implements "
(:on-interface proto) " for protocol:"
(:var proto)))))
(-reset-methods
(alter-var-root (:var proto) assoc-in [:impls atype] mmap ))))
(defn- emit-impl [[p fs]]
[p (zipmap (map #(-> % first keyword) fs)
(map #(cons ’fn (drop 1 %)) fs))])
(defn- emit-hinted-impl [c [p fs]]
(let [hint (fn [specs]
(let [specs (if (vector? (first specs))
(list specs)
specs)]
(map (fn [[[target & args] & body]]
(cons
1314 CHAPTER 11. CLJ/CLOJURE/
(apply vector
(vary-meta target assoc :tag c) args)
body))
specs)))]
[p (zipmap (map #(-> % first keyword) fs)
(map #(cons ’fn (hint (drop 1 %))) fs))]))
(defn- emit-extend-type [c specs]
(let [impls (parse-impls specs)]
‘(extend ~c
~@(mapcat (partial emit-hinted-impl c) impls))))
(defmacro extend-type
"A macro that expands into an extend call. Useful when you are
supplying the definitions explicitly inline, extend-type
automatically creates the maps required by extend. Propaga tes the
class as a type hint on the first argument of all fns.
(extend-type MyType
Countable
(cnt [c] ...)
Foo
(bar [x y] ...)
(baz ([x] ...) ([x y & zs] ...)))
expands into:
(extend MyType
Countable
{:cnt (fn [c] ...)}
Foo
{:baz (fn ([x] ...) ([x y & zs] ...))
:bar (fn [x y] ...)})"
{:added "1.2"}
[t & specs]
(emit-extend-type t specs))
(defn- emit-extend-protocol [p specs]
(let [impls (parse-impls specs)]
‘(do
~@(map (fn [[t fs]]
‘(extend-type ~t ~p ~@fs))
impls))))
(defmacro extend-protocol
"Useful when you want to provide several implementations of the same
protocol all at once. Takes a single protocol and the impleme ntation
of that protocol for one or more types. Expands into calls to
extend-type:
11.4. CORE˙PRINT.CLJ 1315
(extend-protocol Protocol
AType
(foo [x] ...)
(bar [x y] ...)
BType
(foo [x] ...)
(bar [x y] ...)
AClass
(foo [x] ...)
(bar [x y] ...)
nil
(foo [x] ...)
(bar [x y] ...))
expands into:
(do
(clojure.core/extend-type AType Protocol
(foo [x] ...)
(bar [x y] ...))
(clojure.core/extend-type BType Protocol
(foo [x] ...)
(bar [x y] ...))
(clojure.core/extend-type AClass Protocol
(foo [x] ...)
(bar [x y] ...))
(clojure.core/extend-type nil Protocol
(foo [x] ...)
(bar [x y] ...)))"
{:added "1.2"}
[p & specs]
(emit-extend-protocol p specs))
———-
11.4 core˙print.clj
— core˙print.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.core)
;;;;;;;;;;;;;;;;;;;;;;;;;; printing ;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;
1316 CHAPTER 11. CLJ/CLOJURE/
(import ’(java.io Writer))
(def ^:dynamic
^{:doc "*print-length* controls how many items of each coll ection
the printer will print. If it is bound to logical false, there is
no limit. Otherwise, it must be bound to an integer indicatin g the
maximum number of items of each collection to print. If a coll ection
contains more items, the printer will print items up to the li mit
followed by ’...’ to represent the remaining items. The root binding
is nil indicating no limit."
:added "1.0"}
*print-length* nil)
(def ^:dynamic
^{:doc "*print-level* controls how many levels deep the pri nter will
print nested objects. If it is bound to logical false, there i s no
limit. Otherwise, it must be bound to an integer indicating t he
maximum level to print. Each argument to print is at level 0; i f
an argument is a collection, its items are at level 1; and so on .
If an object is a collection and is at a level greater than or eq ual
to the value bound to *print-level*, the printer prints ’#’ t o
represent it. The root binding is nil indicating no limit."
:added "1.0"}
*print-level* nil)
(defn- print-sequential [^String begin, print-one,
^String sep, ^String end, sequence,
^Writer w]
(binding [*print-level* (and (not *print-dup*)
*print-level*
(dec *print-level*))]
(if (and *print-level* (neg? *print-level*))
(.write w "#")
(do
(.write w begin)
(when-let [xs (seq sequence)]
(if (and (not *print-dup*) *print-length*)
(loop [[x & xs] xs
print-length *print-length*]
(if (zero? print-length)
(.write w "...")
(do
(print-one x w)
(when xs
(.write w sep)
(recur xs (dec print-length))))))
(loop [[x & xs] xs]
(print-one x w)
(when xs
(.write w sep)
11.4. CORE˙PRINT.CLJ 1317
(recur xs)))))
(.write w end)))))
(defn- print-meta [o, ^Writer w]
(when-let [m (meta o)]
(when (and (pos? (count m))
(or *print-dup*
(and *print-meta* *print-readably*)))
(.write w "^")
(if (and (= (count m) 1) (:tag m))
(pr-on (:tag m) w)
(pr-on m w))
(.write w " "))))
(defmethod print-method :default [o, ^Writer w]
(print-method (vary-meta o #(dissoc % :type)) w))
(defmethod print-method nil [o, ^Writer w]
(.write w "nil"))
(defmethod print-dup nil [o w] (print-method o w))
(defn print-ctor [o print-args ^Writer w]
(.write w "#=(")
(.write w (.getName ^Class (class o)))
(.write w ". ")
(print-args o w)
(.write w ")"))
(defmethod print-method Object [o, ^Writer w]
(.write w "#<")
(.write w (.getSimpleName (class o)))
(.write w " ")
(.write w (str o))
(.write w ">"))
(defmethod print-method clojure.lang.Keyword [o, ^Write r w]
(.write w (str o)))
(defmethod print-dup clojure.lang.Keyword [o w] (print-m ethod o w))
(defmethod print-method Number [o, ^Writer w]
(.write w (str o)))
(defmethod print-dup Number [o, ^Writer w]
(print-ctor o
(fn [o w]
(print-dup (str o) w))
w))
1318 CHAPTER 11. CLJ/CLOJURE/
(defmethod print-dup clojure.lang.Fn [o, ^Writer w]
(print-ctor o (fn [o w]) w))
(prefer-method print-dup
clojure.lang.IPersistentCollection clojure.lang.Fn)
(prefer-method print-dup java.util.Map clojure.lang.Fn )
(prefer-method print-dup java.util.Collection clojure. lang.Fn)
(defmethod print-method Boolean [o, ^Writer w]
(.write w (str o)))
(defmethod print-dup Boolean [o w] (print-method o w))
(defn print-simple [o, ^Writer w]
(print-meta o w)
(.write w (str o)))
(defmethod print-method clojure.lang.Symbol [o, ^Writer w]
(print-simple o w))
(defmethod print-dup clojure.lang.Symbol [o w] (print-me thod o w))
(defmethod print-method clojure.lang.Var [o, ^Writer w]
(print-simple o w))
(defmethod print-dup clojure.lang.Var [^clojure.lang.V ar o, ^Writer w]
(.write w (str "#=(var " (.name (.ns o)) "/" (.sym o) ")")))
(defmethod print-method clojure.lang.ISeq [o, ^Writer w]
(print-meta o w)
(print-sequential "(" pr-on " " ")" o w))
(defmethod print-dup clojure.lang.ISeq [o w] (print-meth od o w))
(defmethod print-dup
clojure.lang.IPersistentList [o w] (print-method o w))
(prefer-method print-method
clojure.lang.ISeq clojure.lang.IPersistentCollection )
(prefer-method print-dup
clojure.lang.ISeq clojure.lang.IPersistentCollection )
(prefer-method print-method clojure.lang.ISeq java.uti l.Collection)
(prefer-method print-dup clojure.lang.ISeq java.util.C ollection)
(defmethod print-dup java.util.Collection [o, ^Writer w]
(print-ctor o #(print-sequential "[" print-dup " " "]" %1 %2 ) w))
(defmethod print-dup clojure.lang.IPersistentCollecti on [o, ^Writer w]
(print-meta o w)
(.write w "#=(")
11.4. CORE˙PRINT.CLJ 1319
(.write w (.getName ^Class (class o)))
(.write w "/create ")
(print-sequential "[" print-dup " " "]" o w)
(.write w ")"))
(prefer-method print-dup
clojure.lang.IPersistentCollection java.util.Collect ion)
(def ^{:tag String
:doc "Returns escape string for char or nil if none"
:added "1.0"}
char-escape-string
{\newline "\\n"
\tab "\\t"
\return "\\r"
\" "\\\""
\\ "\\\\"
\formfeed "\\f"
\backspace "\\b"})
(defmethod print-method String [^String s, ^Writer w]
(if (or *print-dup* *print-readably*)
(do (.append w \")
(dotimes [n (count s)]
(let [c (.charAt s n)
e (char-escape-string c)]
(if e (.write w e) (.append w c))))
(.append w \"))
(.write w s))
nil)
(defmethod print-dup String [s w] (print-method s w))
(defmethod print-method clojure.lang.IPersistentVecto r [v, ^Writer w]
(print-meta v w)
(print-sequential "[" pr-on " " "]" v w))
(defn- print-map [m print-one w]
(print-sequential
"{"
(fn [e ^Writer w]
(do (print-one (key e) w) (.append w \space) (print-one (val e) w)))
", "
"}"
(seq m) w))
(defmethod print-method clojure.lang.IPersistentMap [m , ^Writer w]
(print-meta m w)
(print-map m pr-on w))
1320 CHAPTER 11. CLJ/CLOJURE/
(defmethod print-dup java.util.Map [m, ^Writer w]
(print-ctor m #(print-map (seq %1) print-dup %2) w))
(defmethod print-dup clojure.lang.IPersistentMap [m, ^W riter w]
(print-meta m w)
(.write w "#=(")
(.write w (.getName (class m)))
(.write w "/create ")
(print-map m print-dup w)
(.write w ")"))
(prefer-method print-dup
clojure.lang.IPersistentCollection java.util.Map)
(defmethod print-method clojure.lang.IPersistentSet [s , ^Writer w]
(print-meta s w)
(print-sequential "#{" pr-on " " "}" (seq s) w))
(def ^{:tag String
:doc "Returns name string for char or nil if none"
:added "1.0"}
char-name-string
{\newline "newline"
\tab "tab"
\space "space"
\backspace "backspace"
\formfeed "formfeed"
\return "return"})
(defmethod print-method java.lang.Character [^Characte r c, ^Writer w]
(if (or *print-dup* *print-readably*)
(do (.append w \\)
(let [n (char-name-string c)]
(if n (.write w n) (.append w c))))
(.append w c))
nil)
(defmethod print-dup java.lang.Character [c w] (print-me thod c w))
(defmethod print-dup java.lang.Integer [o w] (print-meth od o w))
(defmethod print-dup java.lang.Double [o w] (print-metho d o w))
(defmethod print-dup clojure.lang.Ratio [o w] (print-met hod o w))
(defmethod print-dup java.math.BigDecimal [o w] (print-m ethod o w))
(defmethod print-dup clojure.lang.BigInt [o w] (print-me thod o w))
(defmethod print-dup java.math.BigInteger [o w] (print-m ethod o w))
(defmethod print-dup
clojure.lang.PersistentHashMap [o w] (print-method o w))
(defmethod print-dup
clojure.lang.PersistentHashSet [o w] (print-method o w))
(defmethod print-dup
clojure.lang.PersistentVector [o w] (print-method o w))
11.4. CORE˙PRINT.CLJ 1321
(defmethod print-dup
clojure.lang.LazilyPersistentVector [o w] (print-metho d o w))
(def primitives-classnames
{Float/TYPE "Float/TYPE"
Integer/TYPE "Integer/TYPE"
Long/TYPE "Long/TYPE"
Boolean/TYPE "Boolean/TYPE"
Character/TYPE "Character/TYPE"
Double/TYPE "Double/TYPE"
Byte/TYPE "Byte/TYPE"
Short/TYPE "Short/TYPE"})
(defmethod print-method Class [^Class c, ^Writer w]
(.write w (.getName c)))
(defmethod print-dup Class [^Class c, ^Writer w]
(cond
(.isPrimitive c) (do
(.write w "#=(identity ")
(.write w ^String (primitives-classnames c))
(.write w ")"))
(.isArray c) (do
(.write w "#=(java.lang.Class/forName \"")
(.write w (.getName c))
(.write w "\")"))
:else (do
(.write w "#=")
(.write w (.getName c)))))
(defmethod print-method java.math.BigDecimal [b, ^Write r w]
(.write w (str b))
(.write w "M"))
(defmethod print-method clojure.lang.BigInt [b, ^Writer w]
(.write w (str b))
(.write w "N"))
(defmethod print-method java.math.BigInteger [b, ^Write r w]
(.write w (str b))
(.write w "BIGINT"))
(defmethod print-method java.util.regex.Pattern [p ^Wri ter w]
(.write w "#\"")
(loop [[^Character c & r :as s]
(seq (.pattern ^java.util.regex.Pattern p))
qmode false]
(when s
(cond
(= c \\) (let [[^Character c2 & r2] r]
1322 CHAPTER 11. CLJ/CLOJURE/
(.append w \\)
(.append w c2)
(if qmode
(recur r2 (not= c2 \E))
(recur r2 (= c2 \Q))))
(= c \") (do
(if qmode
(.write w "\\E\\\"\\Q")
(.write w "\\\""))
(recur r qmode))
:else (do
(.append w c)
(recur r qmode)))))
(.append w \"))
(defmethod print-dup
java.util.regex.Pattern [p ^Writer w] (print-method p w))
(defmethod print-dup
clojure.lang.Namespace [^clojure.lang.Namespace n ^Wri ter w]
(.write w "#=(find-ns ")
(print-dup (.name n) w)
(.write w ")"))
(defmethod print-method clojure.lang.IDeref [o ^Writer w ]
(print-sequential
(format "#<%s@%x%s: "
(.getSimpleName (class o))
(System/identityHashCode o)
(if (and (instance? clojure.lang.Agent o)
(agent-error o))
" FAILED"
""))
pr-on, "", ">",
(list
(cond
(and (future? o) (not (future-done? o)))
:pending
(and (instance? clojure.lang.IPromiseImpl o)
(not (.hasValue o)))
:not-delivered
:else @o)), w))
(def ^{:private true} print-initialized true)
———-
11.5. CORE˙PROXY.CLJ 1323
11.5 core˙proxy.clj
— core˙proxy.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.core)
;;;;;;;;;;;;;;;;;;;;;;;;;;;; proxy ;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;
(import
’(clojure.asm ClassWriter ClassVisitor Opcodes Type)
’(java.lang.reflect Modifier Constructor)
’(clojure.asm.commons Method GeneratorAdapter)
’(clojure.lang IProxy Reflector
DynamicClassLoader IPersistentMap PersistentHashMap RT ))
(defn method-sig [^java.lang.reflect.Method meth]
[(. meth (getName))
(seq (. meth (getParameterTypes))) (. meth getReturnType) ])
(defn- most-specific [rtypes]
(or (some (fn [t] (when (every? #(isa? t %) rtypes) t)) rtypes )
(throw (Exception. "Incompatible return types"))))
(defn- group-by-sig [coll]
"takes a collection of [msig meth] and returns a seq of maps
from return-types to meths."
(vals (reduce1 (fn [m [msig meth]]
(let [rtype (peek msig)
argsig (pop msig)]
(assoc m argsig (assoc (m argsig {}) rtype meth))))
{} coll)))
(defn proxy-name
{:tag String}
[^Class super interfaces]
(let [inames
(into1 (sorted-set) (map #(.getName ^Class %) interfaces) )]
(apply str (.replace (str *ns*) \- \_) ".proxy"
(interleave (repeat "$")
(concat
[(.getName super)]
(map #(subs % (inc (.lastIndexOf ^String % "."))) inames)
[(Integer/toHexString (hash inames))])))))
(defn- generate-proxy [^Class super interfaces]
(let [cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))
1324 CHAPTER 11. CLJ/CLOJURE/
cname (.replace (proxy-name super interfaces) \. \/)
;(str "clojure/lang/" (gensym "Proxy__"))
ctype (. Type (getObjectType cname))
iname (fn [^Class c] (.. Type (getType c) (getInternalName) ))
fmap "__clojureFnMap"
totype (fn [^Class c] (. Type (getType c)))
to-types (fn [cs] (if (pos? (count cs))
(into-array (map totype cs))
(make-array Type 0)))
super-type ^Type (totype super)
imap-type ^Type (totype IPersistentMap)
ifn-type (totype clojure.lang.IFn)
obj-type (totype Object)
sym-type (totype clojure.lang.Symbol)
rt-type (totype clojure.lang.RT)
ex-type (totype java.lang.UnsupportedOperationExcepti on)
gen-bridge
(fn [^java.lang.reflect.Method meth
^java.lang.reflect.Method dest]
(let [pclasses (. meth (getParameterTypes))
ptypes (to-types pclasses)
rtype ^Type (totype (. meth (getReturnType)))
m (new Method (. meth (getName)) rtype ptypes)
dtype (totype (.getDeclaringClass dest))
dm (new Method
(. dest (getName))
(totype (. dest (getReturnType)))
(to-types (. dest (getParameterTypes))))
gen (new GeneratorAdapter
(bit-or
(. Opcodes ACC_PUBLIC)
(. Opcodes ACC_BRIDGE)) m nil nil cv)]
(. gen (visitCode))
(. gen (loadThis))
(dotimes [i (count ptypes)]
(. gen (loadArg i)))
(if (-> dest .getDeclaringClass .isInterface)
(. gen (invokeInterface dtype dm))
(. gen (invokeVirtual dtype dm)))
(. gen (returnValue))
(. gen (endMethod))))
gen-method
(fn [^java.lang.reflect.Method meth else-gen]
(let [pclasses (. meth (getParameterTypes))
ptypes (to-types pclasses)
rtype ^Type (totype (. meth (getReturnType)))
m (new Method (. meth (getName)) rtype ptypes)
gen (new GeneratorAdapter
(. Opcodes ACC_PUBLIC) m nil nil cv)
else-label (. gen (newLabel))
11.5. CORE˙PROXY.CLJ 1325
end-label (. gen (newLabel))
decl-type
(. Type (getType (. meth (getDeclaringClass))))]
(. gen (visitCode))
(if (> (count pclasses) 18)
(else-gen gen m)
(do
(. gen (loadThis))
(. gen (getField ctype fmap imap-type))
(. gen (push (. meth (getName))))
;lookup fn in map
(. gen (invokeStatic rt-type
(. Method
(getMethod "Object get(Object, Object)"))))
(. gen (dup))
(. gen (ifNull else-label))
;if found
(.checkCast gen ifn-type)
(. gen (loadThis))
;box args
(dotimes [i (count ptypes)]
(. gen (loadArg i))
(. clojure.lang.Compiler$HostExpr
(emitBoxReturn nil gen (nth pclasses i))))
;call fn
(. gen (invokeInterface ifn-type
(new Method "invoke" obj-type
(into-array (cons obj-type
(replicate (count ptypes) obj-type))))))
;unbox return
(. gen (unbox rtype))
(when (= (. rtype (getSort)) (. Type VOID))
(. gen (pop)))
(. gen (goTo end-label))
;else call supplied alternative generator
(. gen (mark else-label))
(. gen (pop))
(else-gen gen m)
(. gen (mark end-label))))
(. gen (returnValue))
(. gen (endMethod))))]
;start class definition
(. cv (visit
(. Opcodes V1_5)
(+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))
cname nil (iname super)
(into-array (map iname (cons IProxy interfaces)))))
1326 CHAPTER 11. CLJ/CLOJURE/
;add field for fn mappings
(. cv (visitField
(+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_VOLATILE))
fmap (. imap-type (getDescriptor)) nil nil))
;add ctors matching/calling super’s
(doseq [^Constructor ctor (. super (getDeclaredConstruct ors))]
(when-not (. Modifier (isPrivate (. ctor (getModifiers))) )
(let [ptypes (to-types (. ctor (getParameterTypes)))
m (new Method "<init>" (. Type VOID_TYPE) ptypes)
gen (new GeneratorAdapter
(. Opcodes ACC_PUBLIC) m nil nil cv)]
(. gen (visitCode))
;call super ctor
(. gen (loadThis))
(. gen (dup))
(. gen (loadArgs))
(. gen (invokeConstructor super-type m))
(. gen (returnValue))
(. gen (endMethod)))))
;add IProxy methods
(let [m (. Method
(getMethod
"void __initClojureFnMappings(clojure.lang.IPersiste ntMap)"))
gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil c v)]
(. gen (visitCode))
(. gen (loadThis))
(. gen (loadArgs))
(. gen (putField ctype fmap imap-type))
(. gen (returnValue))
(. gen (endMethod)))
(let [m (. Method
(getMethod
"void __updateClojureFnMappings(clojure.lang.IPersis tentMap)"))
gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil c v)]
(. gen (visitCode))
(. gen (loadThis))
(. gen (dup))
(. gen (getField ctype fmap imap-type))
(.checkCast gen (totype clojure.lang.IPersistentCollec tion))
(. gen (loadArgs))
(. gen (invokeInterface (totype clojure.lang.IPersisten tCollection)
(. Method
(getMethod
"clojure.lang.IPersistentCollection cons(Object)"))) )
(. gen (checkCast imap-type))
(. gen (putField ctype fmap imap-type))
(. gen (returnValue))
11.5. CORE˙PROXY.CLJ 1327
(. gen (endMethod)))
(let [m (. Method
(getMethod
"clojure.lang.IPersistentMap __getClojureFnMappings( )"))
gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil c v)]
(. gen (visitCode))
(. gen (loadThis))
(. gen (getField ctype fmap imap-type))
(. gen (returnValue))
(. gen (endMethod)))
;calc set of supers’ non-private instance methods
(let [[mm considered]
(loop [mm {} considered #{} c super]
(if c
(let [[mm considered]
(loop [mm mm
considered considered
meths (concat
(seq (. c (getDeclaredMethods)))
(seq (. c (getMethods))))]
(if (seq meths)
(let [^java.lang.reflect.Method meth
(first meths)
mods (. meth (getModifiers))
mk (method-sig meth)]
(if (or (considered mk)
(not
(or
(Modifier/isPublic mods)
(Modifier/isProtected mods)))
;(. Modifier (isPrivate mods))
(. Modifier (isStatic mods))
(. Modifier (isFinal mods))
(= "finalize" (.getName meth)))
(recur mm
(conj considered mk) (next meths))
(recur
(assoc mm mk meth)
(conj considered mk)
(next meths))))
[mm considered]))]
(recur mm considered (. c (getSuperclass))))
[mm considered]))
ifaces-meths
(into1 {}
(for [^Class iface interfaces meth (. iface (getMethods))
:let [msig (method-sig meth)]
:when (not (considered msig))]
{msig meth}))
1328 CHAPTER 11. CLJ/CLOJURE/
mgroups (group-by-sig (concat mm ifaces-meths))
rtypes (map #(most-specific (keys %)) mgroups)
mb (map #(vector (%1 %2) (vals (dissoc %1 %2))) mgroups rtype s)
bridge? (reduce1 into1 #{} (map second mb))
ifaces-meths (remove bridge? (vals ifaces-meths))
mm (remove bridge? (vals mm))]
;add methods matching supers’, if no mapping -> call super
(doseq [[^java.lang.reflect.Method dest bridges] mb
^java.lang.reflect.Method meth bridges]
(gen-bridge meth dest))
(doseq [^java.lang.reflect.Method meth mm]
(gen-method meth
(fn [^GeneratorAdapter gen ^Method m]
(. gen (loadThis))
;push args
(. gen (loadArgs))
;call super
(. gen (visitMethodInsn
(. Opcodes INVOKESPECIAL)
(. super-type (getInternalName))
(. m (getName))
(. m (getDescriptor)))))))
;add methods matching interfaces’, if no mapping -> throw
(doseq [^java.lang.reflect.Method meth ifaces-meths]
(gen-method meth
(fn [^GeneratorAdapter gen ^Method m]
(. gen (throwException ex-type (. m (getName))))))))
;finish class def
(. cv (visitEnd))
[cname (. cv toByteArray)]))
(defn- get-super-and-interfaces [bases]
(if (. ^Class (first bases) (isInterface))
[Object bases]
[(first bases) (next bases)]))
(defn get-proxy-class
"Takes an optional single class followed by zero or more
interfaces. If not supplied class defaults to Object. Creat es an
returns an instance of a proxy class derived from the supplie d
classes. The resulting value is cached and used for any subse quent
requests for the same class set. Returns a Class object."
{:added "1.0"}
[& bases]
(let [[super interfaces] (get-super-and-interfaces base s)
pname (proxy-name super interfaces)]
(or (RT/loadClassForName pname)
(let [[cname bytecode] (generate-proxy super interfaces) ]
11.5. CORE˙PROXY.CLJ 1329
(. ^DynamicClassLoader
(deref clojure.lang.Compiler/LOADER)
(defineClass pname bytecode [super interfaces]))))))
(defn construct-proxy
"Takes a proxy class and any arguments for its superclass cto r and
creates and returns an instance of the proxy."
{:added "1.0"}
[c & ctor-args]
(. Reflector (invokeConstructor c (to-array ctor-args))) )
(defn init-proxy
"Takes a proxy instance and a map of strings (which must
correspond to methods of the proxy superclass/superinterf aces) to
fns (which must take arguments matching the corresponding m ethod,
plus an additional (explicit) first arg corresponding to th is, and
sets the proxy’s fn map. Returns the proxy."
{:added "1.0"}
[^IProxy proxy mappings]
(. proxy (__initClojureFnMappings mappings))
proxy)
(defn update-proxy
"Takes a proxy instance and a map of strings (which must
correspond to methods of the proxy superclass/superinterf aces) to
fns (which must take arguments matching the corresponding m ethod,
plus an additional (explicit) first arg corresponding to th is, and
updates (via assoc) the proxy’s fn map. nil can be passed inst ead of
a fn, in which case the corresponding method will revert to th e
default behavior. Note that this function can be used to upda te the
behavior of an existing instance without changing its ident ity.
Returns the proxy."
{:added "1.0"}
[^IProxy proxy mappings]
(. proxy (__updateClojureFnMappings mappings))
proxy)
(defn proxy-mappings
"Takes a proxy instance and returns the proxy’s fn map."
{:added "1.0"}
[^IProxy proxy]
(. proxy (__getClojureFnMappings)))
(defmacro proxy
"class-and-interfaces - a vector of class names
args - a (possibly empty) vector of arguments to the supercla ss
constructor.
f => (name [params*] body) or
1330 CHAPTER 11. CLJ/CLOJURE/
(name ([params*] body) ([params+] body) ...)
Expands to code which creates a instance of a proxy class that
implements the named class/interface(s) by calling the sup plied
fns. A single class, if provided, must be first. If not provid ed it
defaults to Object.
The interfaces names must be valid interface types. If a meth od fn
is not provided for a class method, the superclass methd will be
called. If a method fn is not provided for an interface method , an
UnsupportedOperationException will be thrown should it be
called. Method fns are closures and can capture the environm ent in
which proxy is called. Each method fn takes an additional imp licit
first arg, which is bound to ’this. Note that while method fns can
be provided to override protected methods, they have no othe r access
to protected members, nor to super, as these capabilities ca nnot be
proxied."
{:added "1.0"}
[class-and-interfaces args & fs]
(let [bases (map
#(or (resolve %)
(throw (Exception. (str "Can’t resolve: " %))))
class-and-interfaces)
[super interfaces] (get-super-and-interfaces bases)
compile-effect
(when *compile-files*
(let [[cname bytecode] (generate-proxy super interfaces) ]
(clojure.lang.Compiler/writeClassFile cname bytecode) ))
pc-effect (apply get-proxy-class bases)
pname (proxy-name super interfaces)]
;remember the class to prevent it from disappearing before u se
(intern *ns* (symbol pname) pc-effect)
‘(let [;pc# (get-proxy-class ~@class-and-interfaces)
p# (new ~(symbol pname) ~@args)]
;(construct-proxy pc# ~@args)]
(init-proxy p#
~(loop [fmap {} fs fs]
(if fs
(let [[sym & meths] (first fs)
meths (if (vector? (first meths))
(list meths)
meths)
meths
(map (fn [[params & body]]
(cons (apply vector ’this params) body))
meths)]
(if-not (contains? fmap (name sym))
(recur
(assoc fmap (name sym) (cons ‘fn meths)) (next fs))
(throw (IllegalArgumentException.
11.5. CORE˙PROXY.CLJ 1331
(str "Method ’" (name sym) "’ redefined")))))
fmap)))
p#)))
(defn proxy-call-with-super [call this meth]
(let [m (proxy-mappings this)]
(update-proxy this (assoc m meth nil))
(let [ret (call)]
(update-proxy this m)
ret)))
(defmacro proxy-super
"Use to call a superclass method in the body of a proxy method.
Note, expansion captures ’this"
{:added "1.0"}
[meth & args]
‘(proxy-call-with-super
(fn [] (. ~’this ~meth ~@args)) ~’this ~(name meth)))
(defn bean
"Takes a Java object and returns a read-only implementation of the
map abstraction based upon its JavaBean properties."
{:added "1.0"}
[^Object x]
(let [c (. x (getClass))
pmap
(reduce1 (fn [m ^java.beans.PropertyDescriptor pd]
(let [name (. pd (getName))
method (. pd (getReadMethod))]
(if (and method
(zero? (alength (. method (getParameterTypes)))))
(assoc m (keyword name)
(fn []
(clojure.lang.Reflector/prepRet
(.getPropertyType pd) (. method (invoke x nil)))))
m)))
{}
(seq (.. java.beans.Introspector
(getBeanInfo c)
(getPropertyDescriptors))))
v (fn [k] ((pmap k)))
snapshot (fn []
(reduce1 (fn [m e]
(assoc m (key e) ((val e))))
{} (seq pmap)))]
(proxy [clojure.lang.APersistentMap]
[]
(containsKey [k] (contains? pmap k))
(entryAt [k]
1332 CHAPTER 11. CLJ/CLOJURE/
(when (contains? pmap k) (new clojure.lang.MapEntry k (v k) )))
(valAt ([k] (v k))
([k default] (if (contains? pmap k) (v k) default)))
(cons [m] (conj (snapshot) m))
(count [] (count pmap))
(assoc [k v] (assoc (snapshot) k v))
(without [k] (dissoc (snapshot) k))
(seq []
((fn thisfn [plseq]
(lazy-seq
(when-let [pseq (seq plseq)]
(cons
(new clojure.lang.MapEntry (first pseq) (v (first pseq)))
(thisfn (rest pseq)))))) (keys pmap))))))
———-
11.6 data.clj
— data.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Stuart Halloway",
:doc "Non-core data functions."}
clojure.data
(:require [clojure.set :as set]))
(defn- atom-diff
"Internal helper for diff."
[a b]
(if (= a b) [nil nil a] [a b nil]))
;; for big things a sparse vector class would be better
(defn- vectorize
"Convert an associative-by-numeric-index collection int o
an equivalent vector, with nil for any missing keys"
[m]
(when (seq m)
(reduce
(fn [result [k v]] (assoc result k v))
(vec (repeat (apply max (keys m)) nil))
m)))
(declare diff)
11.6. DATA.CLJ 1333
(defprotocol ^{:added "1.3"} EqualityPartition
"Implementation detail. Subject to change."
(^{:added "1.3"} equality-partition [x]
"Implementation detail. Subject to change."))
(defprotocol ^{:added "1.3"} Diff
"Implementation detail. Subject to change."
(^{:added "1.3"} diff-similar [a b]
"Implementation detail. Subject to change."))
(extend nil
Diff
{:diff-similar atom-diff})
(extend Object
Diff
{:diff-similar atom-diff}
EqualityPartition
{:equality-partition
(fn [x] (if (.. x getClass isArray) :sequential :atom))})
(defn- diff-associative
"Diff associative things a and b, comparing only keys in ks."
[a b ks]
(reduce
(fn [diff1 diff2]
(map merge diff1 diff2))
[nil nil nil]
(map
(fn [k] (map #(when % {k %}) (diff (get a k) (get b k))))
ks)))
(extend-protocol EqualityPartition
nil
(equality-partition [x] :atom)
java.util.Set
(equality-partition [x] :set)
java.util.List
(equality-partition [x] :sequential)
java.util.Map
(equality-partition [x] :map))
(extend-protocol Diff
java.util.Set
(diff-similar [a b]
[(not-empty (set/difference a b))
1334 CHAPTER 11. CLJ/CLOJURE/
(not-empty (set/difference b a))
(not-empty (set/intersection a b))])
java.util.List
(diff-similar [a b]
(vec (map vectorize (diff-associative
(if (vector? a) a (vec a))
(if (vector? b) b (vec b))
(range (max (count a) (count b)))))))
java.util.Map
(diff-similar [a b]
(diff-associative a b (set/union (keys a) (keys b)))))
(defn diff
"Recursively compares a and b, returning a tuple of
[things-only-in-a things-only-in-b things-in-both].
Comparison rules:
* Maps are subdiffed where keys match and values differ.
* Sets are never subdiffed.
* All sequential things are treated as associative collecti ons
by their indexes, with results returned as vectors.
* Everything else (including strings!) is treated as
an atom and compared for equality."
{:added "1.3"}
[a b]
(if (= (equality-partition a) (equality-partition b))
(diff-similar a b)
(atom-diff a b)))
———-
11.7 genclass.clj
— genclass.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.core)
(import ’(java.lang.reflect Modifier Constructor)
’(clojure.asm ClassWriter ClassVisitor Opcodes Type)
’(clojure.asm.commons Method GeneratorAdapter)
’(clojure.lang IPersistentMap))
11.7. GENCLASS.CLJ 1335
;(defn method-sig [^java.lang.reflect.Method meth]
; [(. meth (getName)) (seq (. meth (getParameterTypes)))])
(defn- non-private-methods [^Class c]
(loop [mm {}
considered #{}
c c]
(if c
(let [[mm considered]
(loop [mm mm
considered considered
meths (seq (concat
(seq (. c (getDeclaredMethods)))
(seq (. c (getMethods)))))]
(if meths
(let [^java.lang.reflect.Method meth (first meths)
mods (. meth (getModifiers))
mk (method-sig meth)]
(if (or (considered mk)
(not (or (Modifier/isPublic mods)
(Modifier/isProtected mods)))
;(. Modifier (isPrivate mods))
(. Modifier (isStatic mods))
(. Modifier (isFinal mods))
(= "finalize" (.getName meth)))
(recur mm (conj considered mk) (next meths))
(recur (assoc mm mk meth)
(conj considered mk)
(next meths))))
[mm considered]))]
(recur mm considered (. c (getSuperclass))))
mm)))
(defn- ctor-sigs [^Class super]
(for [^Constructor ctor (. super (getDeclaredConstructor s))
:when (not (. Modifier (isPrivate (. ctor (getModifiers))) ))]
(apply vector (. ctor (getParameterTypes)))))
(defn- escape-class-name [^Class c]
(.. (.getSimpleName c)
(replace "[]" "<>")))
(defn- overload-name [mname pclasses]
(if (seq pclasses)
(apply str mname (interleave (repeat \-)
(map escape-class-name pclasses)))
(str mname "-void")))
(defn- ^java.lang.reflect.Field find-field [^Class c f]
(let [start-class c]
1336 CHAPTER 11. CLJ/CLOJURE/
(loop [c c]
(if (= c Object)
(throw (new Exception
(str "field, " f ", not defined in class,
" start-class ", or its ancestors")))
(let [dflds (.getDeclaredFields c)
rfld (first
(filter
#(= f (.getName ^java.lang.reflect.Field %))
dflds))]
(or rfld (recur (.getSuperclass c))))))))
;(distinct (map first(keys
; (mapcat non-private-methods [Object IPersistentMap])) ))
(def ^{:private true} prim->class
{’int Integer/TYPE
’long Long/TYPE
’float Float/TYPE
’double Double/TYPE
’void Void/TYPE
’short Short/TYPE
’boolean Boolean/TYPE
’byte Byte/TYPE
’char Character/TYPE})
(defn- ^Class the-class [x]
(cond
(class? x) x
(contains? prim->class x) (prim->class x)
:else (let [strx (str x)]
(clojure.lang.RT/classForName
(if (some #{\. \[} strx)
strx
(str "java.lang." strx))))))
;; someday this can be made codepoint aware
(defn- valid-java-method-name
[^String s]
(= s (clojure.lang.Compiler/munge s)))
(defn- validate-generate-class-options
[{:keys [methods]}]
(let [[mname]
(remove valid-java-method-name
(map (comp str first) methods))]
(when mname
(throw (IllegalArgumentException.
(str "Not a valid method name: " mname))))))
11.7. GENCLASS.CLJ 1337
(defn- generate-class [options-map]
(validate-generate-class-options options-map)
(let [default-options
{:prefix "-" :load-impl-ns true :impl-ns (ns-name *ns*)}
{:keys [name extends implements constructors methods main
factory state init exposes
exposes-methods prefix load-impl-ns impl-ns post-init]}
(merge default-options options-map)
name-meta (meta name)
name (str name)
super (if extends (the-class extends) Object)
interfaces (map the-class implements)
supers (cons super interfaces)
ctor-sig-map
(or constructors (zipmap (ctor-sigs super) (ctor-sigs sup er)))
cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))
cname (. name (replace "." "/"))
pkg-name name
impl-pkg-name (str impl-ns)
impl-cname (.. impl-pkg-name (replace "." "/") (replace \- \_))
ctype (. Type (getObjectType cname))
iname (fn [^Class c] (.. Type (getType c) (getInternalName) ))
totype (fn [^Class c] (. Type (getType c)))
to-types (fn [cs] (if (pos? (count cs))
(into-array (map totype cs))
(make-array Type 0)))
obj-type ^Type (totype Object)
arg-types (fn [n] (if (pos? n)
(into-array (replicate n obj-type))
(make-array Type 0)))
super-type ^Type (totype super)
init-name (str init)
post-init-name (str post-init)
factory-name (str factory)
state-name (str state)
main-name "main"
var-name (fn [s] (clojure.lang.Compiler/munge (str s "__v ar")))
class-type (totype Class)
rt-type (totype clojure.lang.RT)
var-type ^Type (totype clojure.lang.Var)
ifn-type (totype clojure.lang.IFn)
iseq-type (totype clojure.lang.ISeq)
ex-type (totype java.lang.UnsupportedOperationExcepti on)
all-sigs
(distinct
(concat
(map #(let[[m p] (key %)] {m [p]})
(mapcat non-private-methods supers))
(map (fn [[m p]] {(str m) [p]}) methods)))
sigs-by-name (apply merge-with concat {} all-sigs)
1338 CHAPTER 11. CLJ/CLOJURE/
overloads (into1 {} (filter (fn [[m s]] (next s)) sigs-by-na me))
var-fields (concat (when init [init-name])
(when post-init [post-init-name])
(when main [main-name])
;(when exposes-methods
; (map str (vals exposes-methods)))
(distinct
(concat
(keys sigs-by-name)
(mapcat
(fn [[m s]]
(map
#(overload-name m (map the-class %))
s))
overloads)
(mapcat
(comp (partial map str) vals val)
exposes))))
emit-get-var (fn [^GeneratorAdapter gen v]
(let [false-label (. gen newLabel)
end-label (. gen newLabel)]
(. gen getStatic ctype (var-name v) var-type)
(. gen dup)
(. gen invokeVirtual var-type
(. Method (getMethod "boolean isBound()")))
(. gen ifZCmp
(. GeneratorAdapter EQ) false-label)
(. gen invokeVirtual var-type
(. Method (getMethod "Object get()")))
(. gen goTo end-label)
(. gen mark false-label)
(. gen pop)
(. gen visitInsn (. Opcodes ACONST_NULL))
(. gen mark end-label)))
emit-unsupported
(fn [^GeneratorAdapter gen ^Method m]
(. gen (throwException ex-type
(str (. m (getName)) " ("
impl-pkg-name "/" prefix (.getName m)
" not defined?)"))))
emit-forwarding-method
(fn [name pclasses rclass as-static else-gen]
(let [mname (str name)
pmetas (map meta pclasses)
pclasses (map the-class pclasses)
rclass (the-class rclass)
ptypes (to-types pclasses)
rtype ^Type (totype rclass)
m (new Method mname rtype ptypes)
is-overload (seq (overloads mname))
11.7. GENCLASS.CLJ 1339
gen (new GeneratorAdapter
(+
(. Opcodes ACC_PUBLIC)
(if as-static (. Opcodes ACC_STATIC) 0))
m nil nil cv)
found-label (. gen (newLabel))
else-label (. gen (newLabel))
end-label (. gen (newLabel))]
(add-annotations gen (meta name))
(dotimes [i (count pmetas)]
(add-annotations gen (nth pmetas i) i))
(. gen (visitCode))
(if (> (count pclasses) 18)
(else-gen gen m)
(do
(when is-overload
(emit-get-var gen (overload-name mname pclasses))
(. gen (dup))
(. gen (ifNonNull found-label))
(. gen (pop)))
(emit-get-var gen mname)
(. gen (dup))
(. gen (ifNull else-label))
(when is-overload
(. gen (mark found-label)))
;if found
(.checkCast gen ifn-type)
(when-not as-static
(. gen (loadThis)))
;box args
(dotimes [i (count ptypes)]
(. gen (loadArg i))
(. clojure.lang.Compiler$HostExpr
(emitBoxReturn nil gen (nth pclasses i))))
;call fn
(. gen
(invokeInterface ifn-type
(new Method "invoke" obj-type
(to-types (replicate (+ (count ptypes)
(if as-static 0 1))
Object)))))
;(into-array
; (cons obj-type
; (replicate (count ptypes) obj-type))))))
;unbox return
(. gen (unbox rtype))
(when (= (. rtype (getSort)) (. Type VOID))
(. gen (pop)))
(. gen (goTo end-label))
1340 CHAPTER 11. CLJ/CLOJURE/
;else call supplied alternative generator
(. gen (mark else-label))
(. gen (pop))
(else-gen gen m)
(. gen (mark end-label))))
(. gen (returnValue))
(. gen (endMethod))))
]
;start class definition
(. cv (visit
(. Opcodes V1_5)
(+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))
cname nil (iname super)
(when-let [ifc (seq interfaces)]
(into-array (map iname ifc)))))
; class annotations
(add-annotations cv name-meta)
;static fields for vars
(doseq [v var-fields]
(. cv (visitField
(+ (. Opcodes ACC_PRIVATE)
(. Opcodes ACC_FINAL)
(. Opcodes ACC_STATIC))
(var-name v)
(. var-type getDescriptor)
nil nil)))
;instance field for state
(when state
(. cv (visitField (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_F INAL))
state-name
(. obj-type getDescriptor)
nil nil)))
;static init to set up var fields and load init
(let [gen (new GeneratorAdapter
(+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC))
(. Method getMethod "void <clinit> ()")
nil nil cv)]
(. gen (visitCode))
(doseq [v var-fields]
(. gen push impl-pkg-name)
(. gen push (str prefix v))
(. gen (invokeStatic var-type
(. Method
(getMethod
11.7. GENCLASS.CLJ 1341
"clojure.lang.Var internPrivate(String,String)"))))
(. gen putStatic ctype (var-name v) var-type))
(when load-impl-ns
(. gen push "clojure.core")
(. gen push "load")
(. gen
(invokeStatic rt-type
(. Method
(getMethod "clojure.lang.Var var(String,String)"))))
(. gen push (str "/" impl-cname))
(. gen
(invokeInterface ifn-type
(new Method "invoke" obj-type (to-types [Object]))))
; (. gen push (str (.replace impl-pkg-name \- \_) "__init"))
; (. gen
; (invokeStatic class-type
; (. Method (getMethod "Class forName(String)"))))
(. gen pop))
(. gen (returnValue))
(. gen (endMethod)))
;ctors
(doseq [[pclasses super-pclasses] ctor-sig-map]
(let [pclasses (map the-class pclasses)
super-pclasses (map the-class super-pclasses)
ptypes (to-types pclasses)
super-ptypes (to-types super-pclasses)
m (new Method "<init>" (. Type VOID_TYPE) ptypes)
super-m
(new Method "<init>" (. Type VOID_TYPE) super-ptypes)
gen
(new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)
no-init-label (. gen newLabel)
end-label (. gen newLabel)
no-post-init-label (. gen newLabel)
end-post-init-label (. gen newLabel)
nth-method (. Method (getMethod "Object nth(Object,int)" ))
local (. gen newLocal obj-type)]
(. gen (visitCode))
(if init
(do
(emit-get-var gen init-name)
(. gen dup)
(. gen ifNull no-init-label)
(.checkCast gen ifn-type)
;box init args
(dotimes [i (count pclasses)]
1342 CHAPTER 11. CLJ/CLOJURE/
(. gen (loadArg i))
(. clojure.lang.Compiler$HostExpr
(emitBoxReturn nil gen (nth pclasses i))))
;call init fn
(. gen (invokeInterface ifn-type
(new Method "invoke" obj-type
(arg-types (count ptypes)))))
;expecting [[super-ctor-args] state] returned
(. gen dup)
(. gen push (int 0))
(. gen (invokeStatic rt-type nth-method))
(. gen storeLocal local)
(. gen (loadThis))
(. gen dupX1)
(dotimes [i (count super-pclasses)]
(. gen loadLocal local)
(. gen push (int i))
(. gen (invokeStatic rt-type nth-method))
(. clojure.lang.Compiler$HostExpr
(emitUnboxArg nil gen (nth super-pclasses i))))
(. gen (invokeConstructor super-type super-m))
(if state
(do
(. gen push (int 1))
(. gen (invokeStatic rt-type nth-method))
(. gen (putField ctype state-name obj-type)))
(. gen pop))
(. gen goTo end-label)
;no init found
(. gen mark no-init-label)
(. gen (throwException ex-type
(str impl-pkg-name "/" prefix init-name
" not defined")))
(. gen mark end-label))
(if (= pclasses super-pclasses)
(do
(. gen (loadThis))
(. gen (loadArgs))
(. gen (invokeConstructor super-type super-m)))
(throw (new Exception
":init not specified, but ctor and super ctor args differ")) ))
(when post-init
(emit-get-var gen post-init-name)
(. gen dup)
(. gen ifNull no-post-init-label)
(.checkCast gen ifn-type)
11.7. GENCLASS.CLJ 1343
(. gen (loadThis))
;box init args
(dotimes [i (count pclasses)]
(. gen (loadArg i))
(. clojure.lang.Compiler$HostExpr
(emitBoxReturn nil gen (nth pclasses i))))
;call init fn
(. gen (invokeInterface ifn-type
(new Method "invoke" obj-type
(arg-types (inc (count ptypes))))))
(. gen pop)
(. gen goTo end-post-init-label)
;no init found
(. gen mark no-post-init-label)
(. gen (throwException ex-type
(str impl-pkg-name "/" prefix post-init-name
" not defined")))
(. gen mark end-post-init-label))
(. gen (returnValue))
(. gen (endMethod))
;factory
(when factory
(let [fm (new Method factory-name ctype ptypes)
gen (new GeneratorAdapter
(+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC))
fm nil nil cv)]
(. gen (visitCode))
(. gen newInstance ctype)
(. gen dup)
(. gen (loadArgs))
(. gen (invokeConstructor ctype m))
(. gen (returnValue))
(. gen (endMethod))))))
;add methods matching supers’, if no fn -> call super
(let [mm (non-private-methods super)]
(doseq [^java.lang.reflect.Method meth (vals mm)]
(emit-forwarding-method
(.getName meth)
(.getParameterTypes meth)
(.getReturnType meth)
false
(fn [^GeneratorAdapter gen ^Method m]
(. gen (loadThis))
;push args
(. gen (loadArgs))
;call super
(. gen (visitMethodInsn
(. Opcodes INVOKESPECIAL)
1344 CHAPTER 11. CLJ/CLOJURE/
(. super-type (getInternalName))
(. m (getName))
(. m (getDescriptor)))))))
;add methods matching interfaces’, if no fn -> throw
(reduce1 (fn [mm ^java.lang.reflect.Method meth]
(if (contains? mm (method-sig meth))
mm
(do
(emit-forwarding-method
(.getName meth)
(.getParameterTypes meth)
(.getReturnType meth)
false
emit-unsupported)
(assoc mm (method-sig meth) meth))))
mm (mapcat #(.getMethods ^Class %) interfaces))
;extra methods
(doseq [[mname pclasses rclass :as msig] methods]
(emit-forwarding-method mname pclasses rclass
(:static (meta msig))
emit-unsupported))
;expose specified overridden superclass methods
(doseq [[local-mname ^java.lang.reflect.Method m]
(reduce1
(fn [ms [[name _ _] m]]
(if (contains? exposes-methods (symbol name))
(conj ms [((symbol name) exposes-methods) m])
ms)) [] (seq mm))]
(let [ptypes (to-types (.getParameterTypes m))
rtype (totype (.getReturnType m))
exposer-m (new Method (str local-mname) rtype ptypes)
target-m (new Method (.getName m) rtype ptypes)
gen (new GeneratorAdapter
(. Opcodes ACC_PUBLIC) exposer-m nil nil cv)]
(. gen (loadThis))
(. gen (loadArgs))
(. gen (visitMethodInsn (. Opcodes INVOKESPECIAL)
(. super-type (getInternalName))
(. target-m (getName))
(. target-m (getDescriptor))))
(. gen (returnValue))
(. gen (endMethod)))))
;main
(when main
(let [m (. Method getMethod "void main (String[])")
gen (new GeneratorAdapter
(+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC))
m nil nil cv)
no-main-label (. gen newLabel)
end-label (. gen newLabel)]
11.7. GENCLASS.CLJ 1345
(. gen (visitCode))
(emit-get-var gen main-name)
(. gen dup)
(. gen ifNull no-main-label)
(.checkCast gen ifn-type)
(. gen loadArgs)
(. gen (invokeStatic rt-type
(. Method (getMethod "clojure.lang.ISeq seq(Object)"))) )
(. gen (invokeInterface ifn-type (new Method "applyTo" obj -type
(into-array [iseq-type]))))
(. gen pop)
(. gen goTo end-label)
;no main found
(. gen mark no-main-label)
(. gen (throwException ex-type
(str impl-pkg-name "/" prefix main-name " not defined")))
(. gen mark end-label)
(. gen (returnValue))
(. gen (endMethod))))
;field exposers
(doseq [[f {getter :get setter :set}] exposes]
(let [fld (find-field super (str f))
ftype (totype (.getType fld))
static? (Modifier/isStatic (.getModifiers fld))
acc (+ Opcodes/ACC_PUBLIC (if static? Opcodes/ACC_STATIC 0))]
(when getter
(let [m (new Method (str getter) ftype (to-types []))
gen (new GeneratorAdapter acc m nil nil cv)]
(. gen (visitCode))
(if static?
(. gen getStatic ctype (str f) ftype)
(do
(. gen loadThis)
(. gen getField ctype (str f) ftype)))
(. gen (returnValue))
(. gen (endMethod))))
(when setter
(let [m (new Method
(str setter) Type/VOID_TYPE (into-array [ftype]))
gen (new GeneratorAdapter acc m nil nil cv)]
(. gen (visitCode))
(if static?
(do
(. gen loadArgs)
(. gen putStatic ctype (str f) ftype))
(do
(. gen loadThis)
(. gen loadArgs)
(. gen putField ctype (str f) ftype)))
1346 CHAPTER 11. CLJ/CLOJURE/
(. gen (returnValue))
(. gen (endMethod))))))
;finish class def
(. cv (visitEnd))
[cname (. cv (toByteArray))]))
(defmacro gen-class
"When compiling, generates compiled bytecode for a class wi th the
given package-qualified :name (which, as all names in these
parameters, can be a string or symbol), and writes the .class file
to the *compile-path* directory. When not compiling, does
nothing. The gen-class construct contains no implementati on, as the
implementation will be dynamically sought by the generated class in
functions in an implementing Clojure namespace. Given a gen erated
class org.mydomain.MyClass with a method named mymethod, g en-class
will generate an implementation that looks for a function na med by
(str prefix mymethod) (default prefix: \"-\") in a
Clojure namespace specified by :impl-ns
(defaults to the current namespace). All inherited methods ,
generated methods, and init and main functions (see :method s, :init,
and :main below) will be found similarly prefixed. By defaul t, the
static initializer for the generated class will attempt to l oad the
Clojure support code for the class as a resource from the clas spath,
e.g. in the example case, ‘‘org/mydomain/MyClass__init.c lass‘‘. This
behavior can be controlled by :load-impl-ns
Note that methods with a maximum of 18 parameters are support ed.
In all subsequent sections taking types, the primitive type s can be
referred to by their Java names (int, float etc), and classes in the
java.lang package can be used without a package qualifier. A ll other
classes must be fully qualified.
Options should be a set of key/value pairs, all except for
:name are optional:
:name aname
The package-qualified name of the class to be generated
:extends aclass
Specifies the superclass, the non-private methods of which will be
overridden by the class. If not provided, defaults to Object .
:implements [interface ...]
One or more interfaces, the methods of which will be implemen ted
by the class.
11.7. GENCLASS.CLJ 1347
:init name
If supplied, names a function that will be called with the arg uments
to the constructor. Must return [ [superclass-constructor -args] state]
If not supplied, the constructor args are passed directly to
the superclass constructor and the state will be nil
:constructors {[param-types] [super-param-types], ...}
By default, constructors are created for the generated clas s which
match the signature(s) of the constructors for the supercla ss. This
parameter may be used to explicitly specify constructors, e ach entry
providing a mapping from a constructor signature to a superc lass
constructor signature. When you supply this, you must suppl y an :init
specifier.
:post-init name
If supplied, names a function that will be called with the obj ect as
the first argument, followed by the arguments to the constru ctor.
It will be called every time an object of this class is created ,
immediately after all the inherited constructors have comp leted.
It’s return value is ignored.
:methods [ [name [param-types] return-type], ...]
The generated class automatically defines all of the non-pr ivate
methods of its superclasses/interfaces. This parameter ca n be used
to specify the signatures of additional methods of the gener ated
class. Static methods can be specified with ^{:static true} in the
signature’s metadata. Do not repeat superclass/interface signatures
here.
:main boolean
If supplied and true, a static public main function will be ge nerated.
It will pass each string of the String[] argument as a separat e
argument to a function called (str prefix main).
:factory name
If supplied, a (set of) public static factory function(s) wi ll be
created with the given name, and the same signature(s) as the
constructor(s).
:state name
If supplied, a public final instance field with the given nam e will be
created. You must supply an :init function in order to provid e a
value for the state. Note that, though final, the state can be a ref
1348 CHAPTER 11. CLJ/CLOJURE/
or agent, supporting the creation of Java objects with trans actional
or asynchronous mutation semantics.
:exposes {protected-field-name {:get name :set name}, ... }
Since the implementations of the methods of the generated cl ass
occur in Clojure functions, they have no access to the inheri ted
protected fields of the superclass. This parameter can be us ed to
generate public getter/setter methods exposing the protec ted field(s)
for use in the implementation.
:exposes-methods {super-method-name exposed-name, ...}
It is sometimes necessary to call the superclass’ implement ation of an
overridden method. Those methods may be exposed and referre d in
the new method implementation by a local name.
:prefix string
Default: \"-\" Methods called e.g. Foo will be looked up in va rs called
prefixFoo in the implementing ns.
:impl-ns name
Default: the name of the current ns. Implementations of meth ods will be
looked up in this namespace.
:load-impl-ns boolean
Default: true. Causes the static initializer for the genera ted class
to reference the load code for the implementing namespace. S hould be
true when implementing-ns is the default, false if you inten d to
load the code via some other method."
{:added "1.0"}
[& options]
(when *compile-files*
(let [options-map (into1 {} (map vec (partition 2 options)) )
[cname bytecode] (generate-class options-map)]
(clojure.lang.Compiler/writeClassFile cname bytecode) )))
;;;;;;;;;;;;;;;;;;;; gen-interface ;;;;;;;;;;;;;;;;;; ;;;;
;; based on original contribution by Chris Houser
(defn- ^Type asm-type
"Returns an asm Type object for c, which may be a primitive cla ss
(such as Integer/TYPE), any other class (such as Double), or a
fully-qualified class name given as a string or symbol
(such as ’java.lang.String)"
[c]
11.7. GENCLASS.CLJ 1349
(if (or (instance? Class c) (prim->class c))
(Type/getType (the-class c))
(let [strx (str c)]
(Type/getObjectType
(.replace (if (some #{\.} strx)
strx
(str "java.lang." strx))
"." "/")))))
(defn- generate-interface
[{:keys [name extends methods]}]
(let [iname (.replace (str name) "." "/")
cv (ClassWriter. ClassWriter/COMPUTE_MAXS)]
(. cv visit Opcodes/V1_5 (+ Opcodes/ACC_PUBLIC
Opcodes/ACC_ABSTRACT
Opcodes/ACC_INTERFACE)
iname nil "java/lang/Object"
(when (seq extends)
(into-array (map #(.getInternalName (asm-type %)) extend s))))
(add-annotations cv (meta name))
(doseq [[mname pclasses rclass pmetas] methods]
(let [mv (. cv visitMethod
(+ Opcodes/ACC_PUBLIC Opcodes/ACC_ABSTRACT)
(str mname)
(Type/getMethodDescriptor (asm-type rclass)
(if pclasses
(into-array Type (map asm-type pclasses))
(make-array Type 0)))
nil nil)]
(add-annotations mv (meta mname))
(dotimes [i (count pmetas)]
(add-annotations mv (nth pmetas i) i))
(. mv visitEnd)))
(. cv visitEnd)
[iname (. cv toByteArray)]))
(defmacro gen-interface
"When compiling, generates compiled bytecode for an interf ace with
the given package-qualified :name (which, as all names in th ese
parameters, can be a string or symbol), and writes the .class file
to the *compile-path* directory. When not compiling, does n othing.
In all subsequent sections taking types, the primitive type s can be
referred to by their Java names (int, float etc), and classes in the
java.lang package can be used without a package qualifier. A ll other
classes must be fully qualified.
Options should be a set of key/value pairs, all except for :na me are
optional:
1350 CHAPTER 11. CLJ/CLOJURE/
:name aname
The package-qualified name of the class to be generated
:extends [interface ...]
One or more interfaces, which will be extended by this interf ace.
:methods [ [name [param-types] return-type], ...]
This parameter is used to specify the signatures of the metho ds of
the generated interface. Do not repeat superinterface sign atures
here."
{:added "1.0"}
[& options]
(let [options-map (apply hash-map options)
[cname bytecode] (generate-interface options-map)]
(if *compile-files*
(clojure.lang.Compiler/writeClassFile cname bytecode)
(.defineClass ^DynamicClassLoader
(deref clojure.lang.Compiler/LOADER)
(str (:name options-map)) bytecode options))))
(comment
(defn gen-and-load-class
"Generates and immediately loads the bytecode for the speci fied
class. Note that a class generated this way can be loaded only once
- the JVM supports only one class with a given name per
classloader. Subsequent to generation you can import it int o any
desired namespaces just like any other class. See gen-class for a
description of the options."
{:added "1.0"}
[& options]
(let [options-map (apply hash-map options)
[cname bytecode] (generate-class options-map)]
(.. (clojure.lang.RT/getRootClassLoader)
(defineClass cname bytecode options))))
)
———-
11.8. GVEC.CLJ 1351
11.8 gvec.clj
— gvec.clj —
\getchunk{Clojure Copyright}
;;; a generic vector implementation for vectors of primitiv es
(in-ns ’clojure.core)
;(set! *warn-on-reflection* true)
(deftype VecNode [edit arr])
(def EMPTY-NODE (VecNode. nil (object-array 32)))
(definterface IVecImpl
(^int tailoff [])
(arrayFor [^int i])
(pushTail [^int level
^clojure.core.VecNode parent
^clojure.core.VecNode tailnode])
(popTail [^int level node])
(newPath [edit ^int level node])
(doAssoc [^int level node ^int i val]))
(definterface ArrayManager
(array [^int size])
(^int alength [arr])
(aclone [arr])
(aget [arr ^int i])
(aset [arr ^int i val]))
(deftype ArrayChunk [^clojure.core.ArrayManager am arr
^int off ^int end]
clojure.lang.Indexed
(nth [_ i] (.aget am arr (+ off i)))
(count [_] (- end off))
clojure.lang.IChunk
(dropFirst [_]
(if (= off end)
(throw (IllegalStateException. "dropFirst of empty chunk "))
(new ArrayChunk am arr (inc off) end)))
(reduce [_ f init]
1352 CHAPTER 11. CLJ/CLOJURE/
(loop [ret init i off]
(if (< i end)
(recur (f ret (.aget am arr i)) (inc i))
ret)))
)
(deftype VecSeq [^clojure.core.ArrayManager am
^clojure.core.IVecImpl vec anode
^int i ^int offset]
:no-print true
clojure.core.protocols.InternalReduce
(internal-reduce
[_ f val]
(loop [result val
aidx offset]
(if (< aidx (count vec))
(let [node (.arrayFor vec aidx)
result
(loop [result result node-idx (bit-and 0x1f aidx)]
(if (< node-idx (.alength am node))
(recur (f result (.aget am node node-idx))
(inc node-idx))
result))]
(recur result (bit-and 0xffe0 (+ aidx 32))))
result)))
clojure.lang.ISeq
(first [_] (.aget am anode offset))
(next [this]
(if (< (inc offset) (.alength am anode))
(new VecSeq am vec anode i (inc offset))
(.chunkedNext this)))
(more [this]
(let [s (.next this)]
(or s (clojure.lang.PersistentList/EMPTY))))
(cons [this o]
(clojure.lang.Cons. o this))
(count [this]
(loop [i 1
s (next this)]
(if s
(if (instance? clojure.lang.Counted s)
(+ i (.count s))
(recur (inc i) (next s)))
i)))
(equiv [this o]
(cond
(identical? this o) true
(or (instance? clojure.lang.Sequential o)
11.8. GVEC.CLJ 1353
(instance? java.util.List o))
(loop [me this
you (seq o)]
(if (nil? me)
(nil? you)
(and (clojure.lang.Util/equiv (first me) (first you))
(recur (next me) (next you)))))
:else false))
(empty [_]
clojure.lang.PersistentList/EMPTY)
clojure.lang.Seqable
(seq [this] this)
clojure.lang.IChunkedSeq
(chunkedFirst [_] (ArrayChunk. am anode offset (.alength a m anode)))
(chunkedNext [_]
(let [nexti (+ i (.alength am anode))]
(when (< nexti (count vec))
(new VecSeq am vec (.arrayFor vec nexti) nexti 0))))
(chunkedMore [this]
(let [s (.chunkedNext this)]
(or s (clojure.lang.PersistentList/EMPTY)))))
(defmethod print-method ::VecSeq [v w]
((get (methods print-method) clojure.lang.ISeq) v w))
(deftype Vec [^clojure.core.ArrayManager am
^int cnt
^int shift
^clojure.core.VecNode root tail _meta]
Object
(equals [this o]
(cond
(identical? this o) true
(or (instance? clojure.lang.IPersistentVector o)
(instance? java.util.RandomAccess o))
(and (= cnt (count o))
(loop [i (int 0)]
(cond
(= i cnt) true
(.equals (.nth this i) (nth o i)) (recur (inc i))
:else false)))
(or (instance? clojure.lang.Sequential o)
(instance? java.util.List o))
(.equals (seq this) (seq o))
:else false))
;todo - cache
1354 CHAPTER 11. CLJ/CLOJURE/
(hashCode [this]
(loop [hash (int 1) i (int 0)]
(if (= i cnt)
hash
(let [val (.nth this i)]
(recur (unchecked-add-int (unchecked-multiply-int 31 ha sh)
(clojure.lang.Util/hash val))
(inc i))))))
clojure.lang.Counted
(count [_] cnt)
clojure.lang.IMeta
(meta [_] _meta)
clojure.lang.IObj
(withMeta [_ m] (new Vec am cnt shift root tail m))
clojure.lang.Indexed
(nth [this i]
(let [a (.arrayFor this i)]
(.aget am a (bit-and i (int 0x1f)))))
(nth [this i not-found]
(let [z (int 0)]
(if (and (>= i z) (< i (.count this)))
(.nth this i)
not-found)))
clojure.lang.IPersistentCollection
(cons [this val]
(if (< (- cnt (.tailoff this)) (int 32))
(let [new-tail (.array am (inc (.alength am tail)))]
(System/arraycopy tail 0 new-tail 0 (.alength am tail))
(.aset am new-tail (.alength am tail) val)
(new Vec am (inc cnt) shift root new-tail (meta this)))
(let [tail-node (VecNode. (.edit root) tail)]
(if (> (bit-shift-right cnt (int 5))
(bit-shift-left (int 1) shift)) ;overflow root?
(let [new-root (VecNode. (.edit root) (object-array 32))]
(doto ^objects (.arr new-root)
(aset 0 root)
(aset 1 (.newPath this (.edit root) shift tail-node)))
(new Vec am
(inc cnt)
(+ shift (int 5))
new-root
(let [tl (.array am 1)] (.aset am tl 0 val) tl)
(meta this)))
(new Vec am
(inc cnt)
11.8. GVEC.CLJ 1355
shift
(.pushTail this shift root tail-node)
(let [tl (.array am 1)]
(.aset am tl 0 val) tl) (meta this))))))
(empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))
(equiv [this o]
(cond
(or (instance? clojure.lang.IPersistentVector o)
(instance? java.util.RandomAccess o))
(and (= cnt (count o))
(loop [i (int 0)]
(cond
(= i cnt) true
(= (.nth this i) (nth o i)) (recur (inc i))
:else false)))
(or (instance? clojure.lang.Sequential o)
(instance? java.util.List o))
(clojure.lang.Util/equiv (seq this) (seq o))
:else false))
clojure.lang.IPersistentStack
(peek [this]
(when (> cnt (int 0))
(.nth this (dec cnt))))
(pop [this]
(cond
(zero? cnt)
(throw (IllegalStateException. "Can’t pop empty vector") )
(= 1 cnt)
(new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))
(> (- cnt (.tailoff this)) 1)
(let [new-tail (.array am (dec (.alength am tail)))]
(System/arraycopy tail 0 new-tail 0 (.alength am new-tail) )
(new Vec am (dec cnt) shift root new-tail (meta this)))
:else
(let [new-tail (.arrayFor this (- cnt 2))
new-root ^clojure.core.VecNode (.popTail this shift root )]
(cond
(nil? new-root)
(new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))
(and (> shift 5) (nil? (aget ^objects (.arr new-root) 1)))
(new Vec am
(dec cnt)
(- shift 5)
(aget ^objects (.arr new-root) 0)
new-tail
(meta this))
:else
1356 CHAPTER 11. CLJ/CLOJURE/
(new Vec am
(dec cnt)
shift
new-root
new-tail
(meta this))))))
clojure.lang.IPersistentVector
(assocN [this i val]
(cond
(and (<= (int 0) i) (< i cnt))
(if (>= i (.tailoff this))
(let [new-tail (.array am (.alength am tail))]
(System/arraycopy tail 0 new-tail 0 (.alength am tail))
(.aset am new-tail (bit-and i (int 0x1f)) val)
(new Vec am cnt shift root new-tail (meta this)))
(new Vec am cnt shift
(.doAssoc this shift root i val) tail (meta this)))
(= i cnt) (.cons this val)
:else (throw (IndexOutOfBoundsException.))))
clojure.lang.Reversible
(rseq [this]
(if (> (.count this) 0)
(clojure.lang.APersistentVector$RSeq. this (dec (.coun t this)))
nil))
clojure.lang.Associative
(assoc [this k v]
(if (clojure.lang.Util/isInteger k)
(.assocN this k v)
(throw (IllegalArgumentException. "Key must be integer") )))
(containsKey [this k]
(and (clojure.lang.Util/isInteger k)
(<= 0 (int k))
(< (int k) cnt)))
(entryAt [this k]
(if (.containsKey this k)
(clojure.lang.MapEntry. k (.nth this (int k)))
nil))
clojure.lang.ILookup
(valAt [this k not-found]
(if (clojure.lang.Util/isInteger k)
(let [i (int k)]
(if (and (>= i 0) (< i cnt))
(.nth this i)
not-found))
not-found))
11.8. GVEC.CLJ 1357
(valAt [this k] (.valAt this k nil))
clojure.lang.IFn
(invoke [this k]
(if (clojure.lang.Util/isInteger k)
(let [i (int k)]
(if (and (>= i 0) (< i cnt))
(.nth this i)
(throw (IndexOutOfBoundsException.))))
(throw (IllegalArgumentException. "Key must be integer") )))
clojure.lang.Seqable
(seq [this]
(if (zero? cnt)
nil
(VecSeq. am this (.arrayFor this 0) 0 0)))
clojure.lang.Sequential ;marker, no methods
clojure.core.IVecImpl
(tailoff [_]
(- cnt (.alength am tail)))
(arrayFor [this i]
(if (and (<= (int 0) i) (< i cnt))
(if (>= i (.tailoff this))
tail
(loop [node root level shift]
(if (zero? level)
(.arr node)
(recur
(aget ^objects (.arr node)
(bit-and (bit-shift-right i level) (int 0x1f)))
(- level (int 5))))))
(throw (IndexOutOfBoundsException.))))
(pushTail [this level parent tailnode]
(let [subidx (bit-and (bit-shift-right (dec cnt) level) (i nt 0x1f))
parent ^clojure.core.VecNode parent
ret (VecNode. (.edit parent) (aclone ^objects (.arr parent )))
node-to-insert
(if (= level (int 5))
tailnode
(let [child (aget ^objects (.arr parent) subidx)]
(if child
(.pushTail this (- level (int 5)) child tailnode)
(.newPath this (.edit root)
(- level (int 5)) tailnode))))]
(aset ^objects (.arr ret) subidx node-to-insert)
1358 CHAPTER 11. CLJ/CLOJURE/
ret))
(popTail [this level node]
(let [node ^clojure.core.VecNode node
subidx (bit-and
(bit-shift-right (- cnt (int 2)) level)
(int 0x1f))]
(cond
(> level 5)
(let [new-child
(.popTail this (- level 5)
(aget ^objects (.arr node) subidx))]
(if (and (nil? new-child) (zero? subidx))
nil
(let [arr (aclone ^objects (.arr node))]
(aset arr subidx new-child)
(VecNode. (.edit root) arr))))
(zero? subidx) nil
:else (let [arr (aclone ^objects (.arr node))]
(aset arr subidx nil)
(VecNode. (.edit root) arr)))))
(newPath [this edit ^int level node]
(if (zero? level)
node
(let [ret (VecNode. edit (object-array 32))]
(aset ^objects (.arr ret) 0
(.newPath this edit (- level (int 5)) node))
ret)))
(doAssoc [this level node i val]
(let [node ^clojure.core.VecNode node]
(if (zero? level)
;on this branch, array will need val type
(let [arr (.aclone am (.arr node))]
(.aset am arr (bit-and i (int 0x1f)) val)
(VecNode. (.edit node) arr))
(let [arr (aclone ^objects (.arr node))
subidx (bit-and (bit-shift-right i level) (int 0x1f))]
(aset arr subidx
(.doAssoc this (- level (int 5)) (aget arr subidx) i val))
(VecNode. (.edit node) arr)))))
java.lang.Comparable
(compareTo [this o]
(if (identical? this o)
0
(let [#^clojure.lang.IPersistentVector v
(cast clojure.lang.IPersistentVector o)
vcnt (.count v)]
11.8. GVEC.CLJ 1359
(cond
(< cnt vcnt) -1
(> cnt vcnt) 1
:else
(loop [i (int 0)]
(if (= i cnt)
0
(let [comp (clojure.lang.Util/compare (.nth this i)
(.nth v i))]
(if (= 0 comp)
(recur (inc i))
comp))))))))
java.lang.Iterable
(iterator [this]
(let [i (java.util.concurrent.atomic.AtomicInteger. 0) ]
(reify java.util.Iterator
(hasNext [_] (< (.get i) cnt))
(next [_] (.nth this (dec (.incrementAndGet i))))
(remove [_] (throw (UnsupportedOperationException.)))) ))
java.util.Collection
(contains [this o] (boolean (some #(= % o) this)))
(containsAll [this c] (every? #(.contains this %) c))
(isEmpty [_] (zero? cnt))
(toArray [this] (into-array Object this))
(toArray [this arr]
(if (>= (count arr) cnt)
(do
(dotimes [i cnt]
(aset arr i (.nth this i)))
arr)
(into-array Object this)))
(size [_] cnt)
(add [_ o] (throw (UnsupportedOperationException.)))
(addAll [_ c] (throw (UnsupportedOperationException.)))
(clear [_] (throw (UnsupportedOperationException.)))
(^boolean remove [_ o] (throw (UnsupportedOperationExcep tion.)))
(removeAll [_ c] (throw (UnsupportedOperationException. )))
(retainAll [_ c] (throw (UnsupportedOperationException. )))
java.util.List
(get [this i] (.nth this i))
(indexOf [this o]
(loop [i (int 0)]
(cond
(== i cnt) -1
(= o (.nth this i)) i
:else (recur (inc i)))))
(lastIndexOf [this o]
1360 CHAPTER 11. CLJ/CLOJURE/
(loop [i (dec cnt)]
(cond
(< i 0) -1
(= o (.nth this i)) i
:else (recur (dec i)))))
(listIterator [this] (.listIterator this 0))
(listIterator [this i]
(let [i (java.util.concurrent.atomic.AtomicInteger. i) ]
(reify java.util.ListIterator
(hasNext [_] (< (.get i) cnt))
(hasPrevious [_] (pos? i))
(next [_] (.nth this (dec (.incrementAndGet i))))
(nextIndex [_] (.get i))
(previous [_] (.nth this (.decrementAndGet i)))
(previousIndex [_] (dec (.get i)))
(add [_ e] (throw (UnsupportedOperationException.)))
(remove [_] (throw (UnsupportedOperationException.)))
(set [_ e] (throw (UnsupportedOperationException.))))))
(subList [this a z] (subvec this a z))
(add [_ i o] (throw (UnsupportedOperationException.)))
(addAll [_ i c] (throw (UnsupportedOperationException.)) )
(^Object remove [_ ^int i] (throw (UnsupportedOperationEx ception.)))
(set [_ i e] (throw (UnsupportedOperationException.)))
)
(defmethod print-method ::Vec [v w]
((get (methods print-method) clojure.lang.IPersistentV ector) v w))
(defmacro mk-am {:private true} [t]
(let [garr (gensym)
tgarr (with-meta garr {:tag (symbol (str t "s"))})]
‘(reify clojure.core.ArrayManager
(array [_ size#] (~(symbol (str t "-array")) size#))
(alength [_ ~garr] (alength ~tgarr))
(aclone [_ ~garr] (aclone ~tgarr))
(aget [_ ~garr i#] (aget ~tgarr i#))
(aset [_ ~garr i# val#] (aset ~tgarr i# (~t val#))))))
(def ^{:private true} ams
{:int (mk-am int)
:long (mk-am long)
:float (mk-am float)
:double (mk-am double)
:byte (mk-am byte)
:short (mk-am short)
:char (mk-am char)
:boolean (mk-am boolean)})
(defn vector-of
"Creates a new vector of a single primitive type t, where t is o ne
11.9. INSPECTOR.CLJ 1361
of :int :long :float :double :byte :short :char or :boolean. The
resulting vector complies with the interface of vectors in g eneral,
but stores the values unboxed internally."
{:added "1.2"}
[t]
(let [am ^clojure.core.ArrayManager (ams t)]
(Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))
———-
11.9 inspector.clj
— inspector.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "Graphical object inspector for Clojure data str uctures."
:author "Rich Hickey"}
clojure.inspector
(:import
(java.awt BorderLayout)
(java.awt.event ActionEvent ActionListener)
(javax.swing.tree TreeModel)
(javax.swing.table TableModel AbstractTableModel)
(javax.swing JPanel JTree JTable JScrollPane JFrame
JToolBar JButton SwingUtilities)))
(defn atom? [x]
(not (coll? x)))
(defn collection-tag [x]
(cond
(instance? java.util.Map$Entry x) :entry
(instance? java.util.Map x) :map
(sequential? x) :seq
:else :atom))
(defmulti is-leaf collection-tag)
(defmulti get-child (fn [parent index] (collection-tag pa rent)))
(defmulti get-child-count collection-tag)
(defmethod is-leaf :default [node]
(atom? node))
(defmethod get-child :default [parent index]
(nth parent index))
(defmethod get-child-count :default [parent]
(count parent))
1362 CHAPTER 11. CLJ/CLOJURE/
(defmethod is-leaf :entry [e]
(is-leaf (val e)))
(defmethod get-child :entry [e index]
(get-child (val e) index))
(defmethod get-child-count :entry [e]
(count (val e)))
(defmethod is-leaf :map [m]
false)
(defmethod get-child :map [m index]
(nth (seq m) index))
(defn tree-model [data]
(proxy [TreeModel] []
(getRoot [] data)
(addTreeModelListener [treeModelListener])
(getChild [parent index]
(get-child parent index))
(getChildCount [parent]
(get-child-count parent))
(isLeaf [node]
(is-leaf node))
(valueForPathChanged [path newValue])
(getIndexOfChild [parent child]
-1)
(removeTreeModelListener [treeModelListener])))
(defn old-table-model [data]
(let [row1 (first data)
colcnt (count row1)
cnt (count data)
vals (if (map? row1) vals identity)]
(proxy [TableModel] []
(addTableModelListener [tableModelListener])
(getColumnClass [columnIndex] Object)
(getColumnCount [] colcnt)
(getColumnName [columnIndex]
(if (map? row1)
(name (nth (keys row1) columnIndex))
(str columnIndex)))
(getRowCount [] cnt)
(getValueAt [rowIndex columnIndex]
(nth (vals (nth data rowIndex)) columnIndex))
(isCellEditable [rowIndex columnIndex] false)
(removeTableModelListener [tableModelListener]))))
(defn inspect-tree
"creates a graphical (Swing) inspector on the supplied hier archical
11.9. INSPECTOR.CLJ 1363
data"
{:added "1.0"}
[data]
(doto (JFrame. "Clojure Inspector")
(.add (JScrollPane. (JTree. (tree-model data))))
(.setSize 400 600)
(.setVisible true)))
(defn inspect-table
"creates a graphical (Swing) inspector on the supplied regu lar
data, which must be a sequential data structure of data struc tures
of equal length"
{:added "1.0"}
[data]
(doto (JFrame. "Clojure Inspector")
(.add (JScrollPane. (JTable. (old-table-model data))))
(.setSize 400 600)
(.setVisible true)))
(defmulti list-provider class)
(defmethod list-provider :default [x]
{:nrows 1
:get-value (fn [i] x) :get-label (fn [i] (.getName (class x) ))})
(defmethod list-provider java.util.List [c]
(let [v (if (vector? c) c (vec c))]
{:nrows (count v)
:get-value (fn [i] (v i))
:get-label (fn [i] i)}))
(defmethod list-provider java.util.Map [c]
(let [v (vec (sort (map (fn [[k v]] (vector k v)) c)))]
{:nrows (count v)
:get-value (fn [i] ((v i) 1))
:get-label (fn [i] ((v i) 0))}))
(defn list-model [provider]
(let [{:keys [nrows get-value get-label]} provider]
(proxy [AbstractTableModel] []
(getColumnCount [] 2)
(getRowCount [] nrows)
(getValueAt [rowIndex columnIndex]
(cond
(= 0 columnIndex) (get-label rowIndex)
(= 1 columnIndex) (print-str (get-value rowIndex)))))))
(defmulti table-model class)
1364 CHAPTER 11. CLJ/CLOJURE/
(defmethod table-model :default [x]
(proxy [AbstractTableModel] []
(getColumnCount [] 2)
(getRowCount [] 1)
(getValueAt [rowIndex columnIndex]
(if (zero? columnIndex)
(class x)
x))))
;(defn make-inspector [x]
; (agent {:frame frame :data x :parent nil :index 0}))
(defn inspect
"creates a graphical (Swing) inspector on the supplied obje ct"
{:added "1.0"}
[x]
(doto (JFrame. "Clojure Inspector")
(.add
(doto (JPanel. (BorderLayout.))
(.add (doto (JToolBar.)
(.add (JButton. "Back"))
(.addSeparator)
(.add (JButton. "List"))
(.add (JButton. "Table"))
(.add (JButton. "Bean"))
(.add (JButton. "Line"))
(.add (JButton. "Bar"))
(.addSeparator)
(.add (JButton. "Prev"))
(.add (JButton. "Next")))
BorderLayout/NORTH)
(.add
(JScrollPane.
(doto (JTable. (list-model (list-provider x)))
(.setAutoResizeMode JTable/AUTO_RESIZE_LAST_COLUMN)) )
BorderLayout/CENTER)))
(.setSize 400 400)
(.setVisible true)))
(comment
(load-file "src/inspector.clj")
(refer ’inspector)
(inspect-tree {:a 1 :b 2 :c [1 2 3 {:d 4 :e 5 :f [6 7 8]}]})
(inspect-table [[1 2 3][4 5 6][7 8 9][10 11 12]])
)
11.10. BROWSE.CLJ 1365
———-
11.10 browse.clj
— browse.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Christophe Grand",
:doc "Start a web browser from Clojure"}
clojure.java.browse
(:require [clojure.java.shell :as sh])
(:import (java.net URI)))
(defn- macosx? []
(-> "os.name" System/getProperty .toLowerCase
(.startsWith "mac os x")))
(def ^:dynamic *open-url-script* (when (macosx?) "/usr/b in/open"))
(defn- open-url-in-browser
"Opens url (a string) in the default system web browser. May n ot
work on all platforms. Returns url on success, nil if not
supported."
[url]
(try
(when (clojure.lang.Reflector/invokeStaticMethod "jav a.awt.Desktop"
"isDesktopSupported" (to-array nil))
(-> (clojure.lang.Reflector/invokeStaticMethod "java. awt.Desktop"
"getDesktop" (to-array nil))
(.browse (URI. url)))
url)
(catch ClassNotFoundException e
nil)))
(defn- open-url-in-swing
"Opens url (a string) in a Swing window."
[url]
; the implementation of this function resides in another
; namespace to be loaded "on demand"
; this fixes a bug on mac os x where the process turns into a GUI a pp
; see http://code.google.com/p/clojure-contrib/issues /detail?id=32
(require ’clojure.java.browse-ui)
((find-var ’clojure.java.browse-ui/open-url-in-swing ) url))
(defn browse-url
1366 CHAPTER 11. CLJ/CLOJURE/
"Open url in a browser"
{:added "1.2"}
[url]
(or (open-url-in-browser url)
(when *open-url-script* (sh/sh *open-url-script* (str ur l)) true)
(open-url-in-swing url)))
———-
11.11 browse˙ui.clj
— browse˙ui.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Christophe Grand",
:doc "Helper namespace for clojure.java.browse.
Prevents console apps from becoming GUI unnecessarily."}
clojure.java.browse-ui)
(defn- open-url-in-swing
[url]
(let [htmlpane (javax.swing.JEditorPane. url)]
(.setEditable htmlpane false)
(.addHyperlinkListener htmlpane
(proxy [javax.swing.event.HyperlinkListener] []
(hyperlinkUpdate [#^javax.swing.event.HyperlinkEvent e]
(when
(= (.getEventType e)
(. javax.swing.event.HyperlinkEvent$EventType ACTIVAT ED))
(if (instance?
javax.swing.text.html.HTMLFrameHyperlinkEvent e)
(-> htmlpane .getDocument
(.processHTMLFrameHyperlinkEvent e))
(.setPage htmlpane (.getURL e)))))))
(doto (javax.swing.JFrame.)
(.setContentPane (javax.swing.JScrollPane. htmlpane))
(.setBounds 32 32 700 900)
(.show))))
———-
11.12. IO.CLJ 1367
11.12 io.clj
— io.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Stuart Sierra, Chas Emerick, Stuart Halloway",
:doc "This file defines polymorphic I/O utility functions
for Clojure."}
clojure.java.io
(:import
(java.io Reader InputStream InputStreamReader PushbackR eader
BufferedReader File OutputStream
OutputStreamWriter BufferedWriter Writer
FileInputStream FileOutputStream ByteArrayOutputStrea m
StringReader ByteArrayInputStream
BufferedInputStream BufferedOutputStream
CharArrayReader Closeable)
(java.net URI URL MalformedURLException Socket)))
(def
^{:doc "Type object for a Java primitive byte array."
:private true
}
byte-array-type (class (make-array Byte/TYPE 0)))
(def
^{:doc "Type object for a Java primitive char array."
:private true}
char-array-type (class (make-array Character/TYPE 0)))
(defprotocol ^{:added "1.2"} Coercions
"Coerce between various ’resource-namish’ things."
(^{:tag java.io.File, :added "1.2"}
as-file [x] "Coerce argument to a file.")
(^{:tag java.net.URL, :added "1.2"}
as-url [x] "Coerce argument to a URL."))
(extend-protocol Coercions
nil
(as-file [_] nil)
(as-url [_] nil)
String
(as-file [s] (File. s))
(as-url [s] (URL. s))
1368 CHAPTER 11. CLJ/CLOJURE/
File
(as-file [f] f)
(as-url [f] (.toURL f))
URL
(as-url [u] u)
(as-file [u]
(if (= "file" (.getProtocol u))
(as-file (.getPath u))
(throw (IllegalArgumentException. (str "Not a file: " u))) ))
URI
(as-url [u] (.toURL u))
(as-file [u] (as-file (as-url u))))
(defprotocol ^{:added "1.2"} IOFactory
"Factory functions that create ready-to-use, buffered ver sions of
the various Java I/O stream types, on top of anything that can
be unequivocally converted to the requested kind of stream.
Common options include
:append true to open stream in append mode
:encoding string name of encoding to use, e.g. \"UTF-8\".
Callers should generally prefer the higher level API provid ed by
reader, writer, input-stream, and output-stream."
(^{:added "1.2"} make-reader [x opts]
"Creates a BufferedReader. See also IOFactory docs.")
(^{:added "1.2"} make-writer [x opts]
"Creates a BufferedWriter. See also IOFactory docs.")
(^{:added "1.2"} make-input-stream [x opts]
"Creates a BufferedInputStream. See also IOFactory docs." )
(^{:added "1.2"} make-output-stream [x opts]
"Creates a BufferedOutputStream. See also IOFactory docs. "))
(defn ^Reader reader
"Attempts to coerce its argument into an open java.io.Reade r.
Default implementations always return a java.io.Buffered Reader.
Default implementations are provided for Reader, Buffered Reader,
InputStream, File, URI, URL, Socket, byte arrays, characte r arrays,
and String.
If argument is a String, it tries to resolve it first as a URI, t hen
as a local file name. URIs with a ’file’ protocol are converte d to
local file names.
Should be used inside with-open to ensure the Reader is prope rly
closed."
11.12. IO.CLJ 1369
{:added "1.2"}
[x & opts]
(make-reader x (when opts (apply hash-map opts))))
(defn ^Writer writer
"Attempts to coerce its argument into an open java.io.Write r.
Default implementations always return a java.io.Buffered Writer.
Default implementations are provided for Writer, Buffered Writer,
OutputStream, File, URI, URL, Socket, and String.
If the argument is a String, it tries to resolve it first as a UR I,
then as a local file name. URIs with a ’file’ protocol are
converted to local file names.
Should be used inside with-open to ensure the Writer is prope rly
closed."
{:added "1.2"}
[x & opts]
(make-writer x (when opts (apply hash-map opts))))
(defn ^InputStream input-stream
"Attempts to coerce its argument into an open java.io.Input Stream.
Default implementations always return a java.io.Buffered InputStream.
Default implementations are defined for OutputStream, Fil e, URI, URL,
Socket, byte array, and String arguments.
If the argument is a String, it tries to resolve it first as a UR I,
then as a local file name. URIs with a ’file’ protocol are
converted to local file names.
Should be used inside with-open to ensure the InputStream is
properly closed."
{:added "1.2"}
[x & opts]
(make-input-stream x (when opts (apply hash-map opts))))
(defn ^OutputStream output-stream
"Attempts to coerce its argument into an open java.io.Outpu tStream.
Default implementations always return a java.io.Buffered OutputStream.
Default implementations are defined for OutputStream, Fil e, URI, URL,
Socket, and String arguments.
If the argument is a String, it tries to resolve it first as a UR I,
then as a local file name. URIs with a ’file’ protocol are
converted to local file names.
Should be used inside with-open to ensure the OutputStream i s
1370 CHAPTER 11. CLJ/CLOJURE/
properly closed."
{:added "1.2"}
[x & opts]
(make-output-stream x (when opts (apply hash-map opts))))
(defn- ^Boolean append? [opts]
(boolean (:append opts)))
(defn- ^String encoding [opts]
(or (:encoding opts) "UTF-8"))
(defn- buffer-size [opts]
(or (:buffer-size opts) 1024))
(def default-streams-impl
{:make-reader
(fn [x opts] (make-reader (make-input-stream x opts) opts) )
:make-writer
(fn [x opts] (make-writer (make-output-stream x opts) opts ))
:make-input-stream
(fn [x opts]
(throw (IllegalArgumentException.
(str "Cannot open <" (pr-str x) "> as an InputStream."))))
:make-output-stream
(fn [x opts]
(throw (IllegalArgumentException.
(str "Cannot open <" (pr-str x) "> as an OutputStream."))))} )
(defn- inputstream->reader
[^InputStream is opts]
(make-reader (InputStreamReader. is (encoding opts)) opt s))
(defn- outputstream->writer
[^OutputStream os opts]
(make-writer (OutputStreamWriter. os (encoding opts)) op ts))
(extend BufferedInputStream
IOFactory
(assoc default-streams-impl
:make-input-stream (fn [x opts] x)
:make-reader inputstream->reader))
(extend InputStream
IOFactory
(assoc default-streams-impl
:make-input-stream (fn [x opts] (BufferedInputStream. x) )
:make-reader inputstream->reader))
(extend Reader
IOFactory
11.12. IO.CLJ 1371
(assoc default-streams-impl
:make-reader (fn [x opts] (BufferedReader. x))))
(extend BufferedReader
IOFactory
(assoc default-streams-impl
:make-reader (fn [x opts] x)))
(extend Writer
IOFactory
(assoc default-streams-impl
:make-writer (fn [x opts] (BufferedWriter. x))))
(extend BufferedWriter
IOFactory
(assoc default-streams-impl
:make-writer (fn [x opts] x)))
(extend OutputStream
IOFactory
(assoc default-streams-impl
:make-output-stream (fn [x opts] (BufferedOutputStream. x))
:make-writer outputstream->writer))
(extend BufferedOutputStream
IOFactory
(assoc default-streams-impl
:make-output-stream (fn [x opts] x)
:make-writer outputstream->writer))
(extend File
IOFactory
(assoc default-streams-impl
:make-input-stream
(fn [^File x opts] (make-input-stream (FileInputStream. x ) opts))
:make-output-stream
(fn [^File x opts]
(make-output-stream (FileOutputStream. x (append? opts) ) opts))))
(extend URL
IOFactory
(assoc default-streams-impl
:make-input-stream (fn [^URL x opts]
(make-input-stream
(if (= "file" (.getProtocol x))
(FileInputStream. (.getPath x))
(.openStream x)) opts))
:make-output-stream
(fn [^URL x opts]
(if (= "file" (.getProtocol x))
1372 CHAPTER 11. CLJ/CLOJURE/
(make-output-stream (File. (.getPath x)) opts)
(throw (IllegalArgumentException.
(str "Can not write to non-file URL <" x ">")))))))
(extend URI
IOFactory
(assoc default-streams-impl
:make-input-stream
(fn [^URI x opts] (make-input-stream (.toURL x) opts))
:make-output-stream
(fn [^URI x opts] (make-output-stream (.toURL x) opts))))
(extend String
IOFactory
(assoc default-streams-impl
:make-input-stream (fn [^String x opts]
(try
(make-input-stream (URL. x) opts)
(catch MalformedURLException e
(make-input-stream (File. x) opts))))
:make-output-stream (fn [^String x opts]
(try
(make-output-stream (URL. x) opts)
(catch MalformedURLException err
(make-output-stream (File. x) opts))))))
(extend Socket
IOFactory
(assoc default-streams-impl
:make-input-stream
(fn [^Socket x opts]
(make-input-stream (.getInputStream x) opts))
:make-output-stream
(fn [^Socket x opts]
(make-output-stream (.getOutputStream x) opts))))
(extend byte-array-type
IOFactory
(assoc default-streams-impl
:make-input-stream
(fn [x opts] (make-input-stream (ByteArrayInputStream. x ) opts))))
(extend char-array-type
IOFactory
(assoc default-streams-impl
:make-reader (fn [x opts] (make-reader (CharArrayReader. x) opts))))
(extend Object
IOFactory
default-streams-impl)
11.12. IO.CLJ 1373
(defmulti
#^{:doc "Internal helper for copy"
:private true
:arglists ’([input output opts])}
do-copy
(fn [input output opts] [(type input) (type output)]))
(defmethod do-copy [InputStream OutputStream]
[#^InputStream input #^OutputStream output opts]
(let [buffer (make-array Byte/TYPE (buffer-size opts))]
(loop []
(let [size (.read input buffer)]
(when (pos? size)
(do (.write output buffer 0 size)
(recur)))))))
(defmethod do-copy [InputStream Writer]
[#^InputStream input #^Writer output opts]
(let [#^"[B" buffer (make-array Byte/TYPE (buffer-size op ts))]
(loop []
(let [size (.read input buffer)]
(when (pos? size)
(let [chars
(.toCharArray (String. buffer 0 size (encoding opts)))]
(do (.write output chars)
(recur))))))))
(defmethod do-copy [InputStream File]
[#^InputStream input #^File output opts]
(with-open [out (FileOutputStream. output)]
(do-copy input out opts)))
(defmethod do-copy [Reader OutputStream]
[#^Reader input #^OutputStream output opts]
(let [#^"[C" buffer (make-array Character/TYPE (buffer-s ize opts))]
(loop []
(let [size (.read input buffer)]
(when (pos? size)
(let [bytes
(.getBytes (String. buffer 0 size) (encoding opts))]
(do (.write output bytes)
(recur))))))))
(defmethod do-copy [Reader Writer] [#^Reader input #^Writ er output opts]
(let [#^"[C" buffer (make-array Character/TYPE (buffer-s ize opts))]
(loop []
(let [size (.read input buffer)]
(when (pos? size)
(do (.write output buffer 0 size)
1374 CHAPTER 11. CLJ/CLOJURE/
(recur)))))))
(defmethod do-copy [Reader File] [#^Reader input #^File ou tput opts]
(with-open [out (FileOutputStream. output)]
(do-copy input out opts)))
(defmethod do-copy [File OutputStream]
[#^File input #^OutputStream output opts]
(with-open [in (FileInputStream. input)]
(do-copy in output opts)))
(defmethod do-copy [File Writer] [#^File input #^Writer ou tput opts]
(with-open [in (FileInputStream. input)]
(do-copy in output opts)))
(defmethod do-copy [File File] [#^File input #^File output opts]
(with-open [in (FileInputStream. input)
out (FileOutputStream. output)]
(do-copy in out opts)))
(defmethod do-copy [String OutputStream]
[#^String input #^OutputStream output opts]
(do-copy (StringReader. input) output opts))
(defmethod do-copy [String Writer] [#^String input #^Writ er output opts]
(do-copy (StringReader. input) output opts))
(defmethod do-copy [String File] [#^String input #^File ou tput opts]
(do-copy (StringReader. input) output opts))
(defmethod do-copy [char-array-type OutputStream]
[input #^OutputStream output opts]
(do-copy (CharArrayReader. input) output opts))
(defmethod do-copy [char-array-type Writer] [input #^Wri ter output opts]
(do-copy (CharArrayReader. input) output opts))
(defmethod do-copy [char-array-type File] [input #^File o utput opts]
(do-copy (CharArrayReader. input) output opts))
(defmethod do-copy [byte-array-type OutputStream]
[#^"[B" input #^OutputStream output opts]
(do-copy (ByteArrayInputStream. input) output opts))
(defmethod do-copy [byte-array-type Writer]
[#^"[B" input #^Writer output opts]
(do-copy (ByteArrayInputStream. input) output opts))
(defmethod do-copy [byte-array-type File]
[#^"[B" input #^Writer output opts]
11.12. IO.CLJ 1375
(do-copy (ByteArrayInputStream. input) output opts))
(defn copy
"Copies input to output. Returns nil or throws IOException.
Input may be an InputStream, Reader, File, byte[], or String .
Output may be an OutputStream, Writer, or File.
Options are key/value pairs and may be one of
:buffer-size buffer size to use, default is 1024.
:encoding encoding to use if converting between
byte and char streams.
Does not close any streams except those it opens itself
(on a File)."
{:added "1.2"}
[input output & opts]
(do-copy input output (when opts (apply hash-map opts))))
(defn ^String as-relative-path
"Take an as-file-able thing and return a string if it is
a relative path, else IllegalArgumentException."
{:added "1.2"}
[x]
(let [^File f (as-file x)]
(if (.isAbsolute f)
(throw (IllegalArgumentException.
(str f " is not a relative path")))
(.getPath f))))
(defn ^File file
"Returns a java.io.File, passing each arg to as-file. Multi ple-arg
versions treat the first argument as parent and subsequent a rgs as
children relative to the parent."
{:added "1.2"}
([arg]
(as-file arg))
([parent child]
(File. ^File (as-file parent) ^String (as-relative-path c hild)))
([parent child & more]
(reduce file (file parent child) more)))
(defn delete-file
"Delete file f. Raise an exception if it fails unless silentl y is
true."
{:added "1.2"}
[f & [silently]]
(or (.delete (file f))
silently
(throw (java.io.IOException. (str "Couldn’t delete " f))) ))
1376 CHAPTER 11. CLJ/CLOJURE/
(defn make-parents
"Given the same arg(s) as for file, creates all parent direct ories of
the file they represent."
{:added "1.2"}
[f & more]
(.mkdirs (.getParentFile ^File (apply file f more))))
(defn ^URL resource
"Returns the URL for a named resource. Use the context class l oader
if no loader is specified."
{:added "1.2"}
([n] (resource n (.getContextClassLoader (Thread/curren tThread))))
([n ^ClassLoader loader] (.getResource loader n)))
———-
11.13 javadoc.clj
— javadoc.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Christophe Grand, Stuart Sierra",
:doc "A repl helper to quickly open javadocs."}
clojure.java.javadoc
(:use [clojure.java.browse :only (browse-url)] )
(:import
(java.io File)))
(def ^:dynamic *feeling-lucky-url*
"http://www.google.com/search?btnI=I%27m%20Feeling% 20Lucky&q=allinurl:")
(def ^:dynamic *feeling-lucky* true)
(def ^:dynamic *local-javadocs* (ref (list)))
(def ^:dynamic *core-java-api*
(if (= "1.5" (System/getProperty "java.specification.ve rsion"))
"http://java.sun.com/j2se/1.5.0/docs/api/"
"http://java.sun.com/javase/6/docs/api/"))
(def ^:dynamic *remote-javadocs*
(ref (sorted-map
"java." *core-java-api*
"javax." *core-java-api*
"org.ietf.jgss." *core-java-api*
11.13. JAVADOC.CLJ 1377
"org.omg." *core-java-api*
"org.w3c.dom." *core-java-api*
"org.xml.sax." *core-java-api*
"org.apache.commons.codec."
"http://commons.apache.org/codec/api-release/"
"org.apache.commons.io."
"http://commons.apache.org/io/api-release/"
"org.apache.commons.lang."
"http://commons.apache.org/lang/api-release/")))
(defn add-local-javadoc
"Adds to the list of local Javadoc paths."
{:added "1.2"}
[path]
(dosync (commute *local-javadocs* conj path)))
(defn add-remote-javadoc
"Adds to the list of remote Javadoc URLs. package-prefix is t he
beginning of the package name that has docs at this URL."
{:added "1.2"}
[package-prefix url]
(dosync (commute *remote-javadocs* assoc package-prefix url)))
(defn- javadoc-url
"Searches for a URL for the given class name. Tries
*local-javadocs* first, then *remote-javadocs*. Returns a string."
{:tag String,
:added "1.2"}
[^String classname]
(let [file-path (.replace classname \. File/separatorCha r)
url-path (.replace classname \. \/)]
(if-let [file ^File
(first
(filter #(.exists ^File %)
(map #(File. (str %) (str file-path ".html"))
@*local-javadocs*)))]
(-> file .toURI str)
;; If no local file, try remote URLs:
(or (some (fn [[prefix url]]
(when (.startsWith classname prefix)
(str url url-path ".html")))
@*remote-javadocs*)
;; if *feeling-lucky* try a web search
(when *feeling-lucky*
(str *feeling-lucky-url* url-path ".html"))))))
(defn javadoc
"Opens a browser window displaying the javadoc for the argum ent.
Tries *local-javadocs* first, then *remote-javadocs*."
{:added "1.2"}
1378 CHAPTER 11. CLJ/CLOJURE/
[class-or-object]
(let [^Class c (if (instance? Class class-or-object)
class-or-object
(class class-or-object))]
(if-let [url (javadoc-url (.getName c))]
(browse-url url)
(println "Could not find Javadoc for" c))))
———-
11.14 shell.clj
— shell.clj —
\getchunk{Clojure Copyright}
(ns
^{:author "Chris Houser, Stuart Halloway",
:doc "Conveniently launch a sub-process providing its stdi n and
collecting its stdout"}
clojure.java.shell
(:use [clojure.java.io :only (as-file copy)])
(:import
(java.io OutputStreamWriter ByteArrayOutputStream Stri ngWriter)
(java.nio.charset Charset)))
(def ^:dynamic *sh-dir* nil)
(def ^:dynamic *sh-env* nil)
(defmacro with-sh-dir
"Sets the directory for use with sh, see sh for details."
{:added "1.2"}
[dir & forms]
‘(binding [*sh-dir* ~dir]
~@forms))
(defmacro with-sh-env
"Sets the environment for use with sh, see sh for details."
{:added "1.2"}
[env & forms]
‘(binding [*sh-env* ~env]
~@forms))
(defn- aconcat
"Concatenates arrays of given type."
[type & xs]
(let [target (make-array type (apply + (map count xs)))]
11.14. SHELL.CLJ 1379
(loop [i 0 idx 0]
(when-let [a (nth xs i nil)]
(System/arraycopy a 0 target idx (count a))
(recur (inc i) (+ idx (count a)))))
target))
(defn- parse-args
[args]
(let [default-encoding "UTF-8" ;; see sh doc string
default-opts {:out-enc default-encoding
:in-enc default-encoding
:dir *sh-dir*
:env *sh-env*}
[cmd opts] (split-with string? args)]
[cmd (merge default-opts (apply hash-map opts))]))
(defn- ^"[Ljava.lang.String;" as-env-strings
"Helper so that callers can pass a Clojure map for the :env to s h."
[arg]
(cond
(nil? arg) nil
(map? arg)
(into-array String (map (fn [[k v]] (str (name k) "=" v)) arg) )
true arg))
(defn- stream-to-bytes
[in]
(with-open [bout (ByteArrayOutputStream.)]
(copy in bout)
(.toByteArray bout)))
(defn- stream-to-string
([in] (stream-to-string in (.name (Charset/defaultChars et))))
([in enc]
(with-open [bout (StringWriter.)]
(copy in bout :encoding enc)
(.toString bout))))
(defn- stream-to-enc
[stream enc]
(if (= enc :bytes)
(stream-to-bytes stream)
(stream-to-string stream enc)))
(defn sh
"Passes the given strings to Runtime.exec() to launch a sub- process.
Options are
:in may be given followed by a String or byte array specifying
1380 CHAPTER 11. CLJ/CLOJURE/
input to be fed to the sub-process’s stdin.
:in-enc option may be given followed by a String, used as a
character encoding name (for example \"UTF-8\" or
\"ISO-8859-1\") to convert the input string specified by
the :in option to the sub-process’s stdin. Defaults to
UTF-8. If the :in option provides a byte array, then the
bytes are passed unencoded, and this option is ignored.
:out-enc option may be given followed by :bytes or a String. I f a
String is given, it will be used as a character encoding
name (for example \"UTF-8\" or \"ISO-8859-1\") to convert
the sub-process’s stdout to a String which is returned.
If :bytes is given, the sub-process’s stdout will be stored
in a byte array and returned. Defaults to UTF-8.
:env override the process env with a map (or the underlying Ja va
String[] if you are a masochist).
:dir override the process dir with a String or java.io.File.
You can bind :env or :dir for multiple operations using with- sh-env
and with-sh-dir.
sh returns a map of
:exit => sub-process’s exit code
:out => sub-process’s stdout (as byte[] or String)
:err =>
sub-process’s stderr (String via platform default encodin g)"
{:added "1.2"}
[& args]
(let [[cmd opts] (parse-args args)
proc (.exec (Runtime/getRuntime)
^"[Ljava.lang.String;" (into-array cmd)
(as-env-strings (:env opts))
(as-file (:dir opts)))
{:keys [in in-enc out-enc]} opts]
(if in
(future
(if (instance? (class (byte-array 0)) in)
(with-open [os (.getOutputStream proc)]
(.write os ^"[B" in))
(with-open
[osw (OutputStreamWriter. (.getOutputStream proc)
^String in-enc)]
(.write osw ^String in))))
(.close (.getOutputStream proc)))
(with-open [stdout (.getInputStream proc)
stderr (.getErrorStream proc)]
(let [out (future (stream-to-enc stdout out-enc))
err (future (stream-to-string stderr))
exit-code (.waitFor proc)]
{:exit exit-code :out @out :err @err}))))
11.15. MAIN.CLJ 1381
(comment
(println (sh "ls" "-l"))
(println (sh "ls" "-l" "/no-such-thing"))
(println (sh "sed" "s/[aeiou]/oo/g" :in "hello there\n"))
(println (sh "cat" :in "x\u25bax\n"))
(println (sh "echo" "x\u25bax"))
; reads 4 single-byte chars
(println (sh "echo" "x\u25bax" :out-enc "ISO-8859-1"))
; reads binary file into bytes[]
(println (sh "cat" "myimage.png" :out-enc :bytes))
(println (sh "cmd" "/c dir 1>&2"))
)
———-
11.15 main.clj
— main.clj —
\getchunk{Clojure Copyright}
;; Originally contributed by Stephen C. Gilardi
(ns ^{:doc "Top-level main function for Clojure REPL and scr ipts."
:author "Stephen C. Gilardi and Rich Hickey"}
clojure.main
(:refer-clojure :exclude [with-bindings])
(:import (clojure.lang Compiler Compiler$CompilerExcep tion
LineNumberingPushbackReader RT))
(:use [clojure.repl :only (demunge root-cause stack-elem ent-str)]))
(declare main)
(defmacro with-bindings
"Executes body in the context of thread-local bindings for s everal
vars that often need to be set!: *ns* *warn-on-reflection*
*math-context* *print-meta* *print-length* *print-leve l*
*compile-path* *command-line-args* *1 *2 *3 *e"
[& body]
‘(binding [*ns* *ns*
*warn-on-reflection* *warn-on-reflection*
*math-context* *math-context*
*print-meta* *print-meta*
*print-length* *print-length*
*print-level* *print-level*
1382 CHAPTER 11. CLJ/CLOJURE/
*compile-path*
(System/getProperty "clojure.compile.path" "classes")
*command-line-args* *command-line-args*
*unchecked-math* *unchecked-math*
*assert* *assert*
*1 nil
*2 nil
*3 nil
*e nil]
~@body))
(defn repl-prompt
"Default :prompt hook for repl"
[]
(printf "%s=> " (ns-name *ns*)))
(defn skip-if-eol
"If the next character on stream s is a newline, skips it, othe rwise
leaves the stream untouched. Returns :line-start, :stream -end, or
:body to indicate the relative location of the next characte r on s.
The stream must either be an instance of LineNumberingPushb ackReader
or duplicate its behavior of both supporting .unread and col lapsing
all of CR, LF, and CRLF to a single \\newline."
[s]
(let [c (.read s)]
(cond
(= c (int \newline)) :line-start
(= c -1) :stream-end
:else (do (.unread s c) :body))))
(defn skip-whitespace
"Skips whitespace characters on stream s. Returns :line-st art,
:stream-end, or :body to indicate the relative location of t he next
character on s. Interprets comma as whitespace and semicolo n as
comment to end of line. Does not interpret #! as comment to end
of line because only one character of lookahead is available .
The stream must either be an instance of LineNumberingPushb ackReader
or duplicate its behavior of both supporting .unread and col lapsing
all of CR, LF, and CRLF to a single \\newline."
[s]
(loop [c (.read s)]
(cond
(= c (int \newline)) :line-start
(= c -1) :stream-end
(= c (int \;)) (do (.readLine s) :line-start)
(or (Character/isWhitespace (char c))
(= c (int \,)))
(recur (.read s))
:else (do (.unread s c) :body))))
11.15. MAIN.CLJ 1383
(defn repl-read
"Default :read hook for repl. Reads from *in* which must eith er be
an instance of LineNumberingPushbackReader or duplicate i ts behavior
of both supporting .unread and collapsing all of CR, LF, and C RLF
into a single
\\newline. repl-read:
- skips whitespace, then
- returns request-prompt on start of line, or
- returns request-exit on end of stream, or
- reads an object from the input stream, then
- skips the next input character if it’s end of line, then
- returns the object."
[request-prompt request-exit]
(or ({:line-start request-prompt :stream-end request-ex it}
(skip-whitespace *in*))
(let [input (read)]
(skip-if-eol *in*)
input)))
(defn repl-exception
"Returns the root cause of throwables"
[throwable]
(root-cause throwable))
(defn repl-caught
"Default :caught hook for repl"
[e]
(let [ex (repl-exception e)
tr (.getStackTrace ex)
el (when-not (zero? (count tr)) (aget tr 0))]
(binding [*out* *err*]
(println
(str (-> ex class .getSimpleName)
" " (.getMessage ex) " "
(when-not
(instance? clojure.lang.Compiler$CompilerException ex )
(str " "
(if el (stack-element-str el) "[trace missing]"))))))))
(defn repl
"Generic, reusable, read-eval-print loop. By default, rea ds from
*in*, writes to *out*, and prints exception summaries to *er r*.
If you use the default :read hook, *in* must either be an insta nce
of LineNumberingPushbackReader or duplicate its behavior of both
supporting .unread and collapsing CR, LF, and CRLF into a sin gle
\\newline. Options are sequential keyword-value pairs. Av ailable
options and their defaults:
- :init, function of no arguments, initialization hook call ed
with bindings for set!-able vars in place.
1384 CHAPTER 11. CLJ/CLOJURE/
default: #()
- :need-prompt, function of no arguments, called before eac h
read-eval-print except the first, the user will be prompted
if it returns true.
default: (if (instance? LineNumberingPushbackReader *in *)
#(.atLineStart *in*)
#(identity true))
- :prompt, function of no arguments, prompts for more input.
default: repl-prompt
- :flush, function of no arguments, flushes output
default: flush
- :read, function of two arguments, reads from *in*:
- returns its first argument to request a fresh prompt
- depending on need-prompt, this may cause the repl to
prompt before reading again
- returns its second argument to request an exit from the
repl
- else returns the next object read from the input stream
default: repl-read
- :eval, funtion of one argument, returns the evaluation of i ts
argument
default: eval
- :print, function of one argument, prints its argument to th e
output default: prn
- :caught, function of one argument, a throwable, called whe n
read, eval, or print throws an exception or error
default: repl-caught"
[& options]
(let [cl (.getContextClassLoader (Thread/currentThread ))]
(.setContextClassLoader
(Thread/currentThread) (clojure.lang.DynamicClassLoa der. cl)))
(let [{:keys [init need-prompt prompt flush read eval print caught]
:or {init #()
need-prompt
(if (instance? LineNumberingPushbackReader *in*)
#(.atLineStart ^LineNumberingPushbackReader *in*)
#(identity true))
prompt repl-prompt
flush flush
read repl-read
eval eval
print prn
caught repl-caught}}
11.15. MAIN.CLJ 1385
(apply hash-map options)
request-prompt (Object.)
request-exit (Object.)
read-eval-print
(fn []
(try
(let [input (read request-prompt request-exit)]
(or (#{request-prompt request-exit} input)
(let [value (eval input)]
(print value)
(set! *3 *2)
(set! *2 *1)
(set! *1 value))))
(catch Throwable e
(caught e)
(set! *e e))))]
(with-bindings
(try
(init)
(catch Throwable e
(caught e)
(set! *e e)))
(use ’[clojure.repl :only (source apropos dir pst doc find- doc)])
(use ’[clojure.java.javadoc :only (javadoc)])
(use ’[clojure.pprint :only (pp pprint)])
(prompt)
(flush)
(loop []
(when-not
(try (= (read-eval-print) request-exit)
(catch Throwable e
(caught e)
(set! *e e)
nil))
(when (need-prompt)
(prompt)
(flush))
(recur))))))
(defn load-script
"Loads Clojure source from a file or resource given its path. Paths
beginning with @ or @/ are considered relative to classpath. "
[^String path]
(if (.startsWith path "@")
(RT/loadResourceScript
(.substring path (if (.startsWith path "@/") 2 1)))
(Compiler/loadFile path)))
(defn- init-opt
"Load a script"
1386 CHAPTER 11. CLJ/CLOJURE/
[path]
(load-script path))
(defn- eval-opt
"Evals expressions in str, prints each non-nil result using prn"
[str]
(let [eof (Object.)
reader
(LineNumberingPushbackReader. (java.io.StringReader. str))]
(loop [input (read reader false eof)]
(when-not (= input eof)
(let [value (eval input)]
(when-not (nil? value)
(prn value))
(recur (read reader false eof)))))))
(defn- init-dispatch
"Returns the handler associated with an init opt"
[opt]
({"-i" init-opt
"--init" init-opt
"-e" eval-opt
"--eval" eval-opt} opt))
(defn- initialize
"Common initialize routine for repl, script, and null opts"
[args inits]
(in-ns ’user)
(set! *command-line-args* args)
(doseq [[opt arg] inits]
((init-dispatch opt) arg)))
(defn- main-opt
"Call the -main function from a namespace with string argume nts from
the command line."
[[_ main-ns & args] inits]
(with-bindings
(initialize args inits)
(apply (ns-resolve (doto (symbol main-ns) require) ’-main ) args)))
(defn- repl-opt
"Start a repl with args and inits. Print greeting if no eval op tions
were present"
[[_ & args] inits]
(when-not (some #(= eval-opt (init-dispatch (first %))) in its)
(println "Clojure" (clojure-version)))
(repl :init #(initialize args inits))
(prn)
(System/exit 0))
11.15. MAIN.CLJ 1387
(defn- script-opt
"Run a script from a file, resource, or standard in with args a nd
inits"
[[path & args] inits]
(with-bindings
(initialize args inits)
(if (= path "-")
(load-reader *in*)
(load-script path))))
(defn- null-opt
"No repl or script opt present, just bind args and run inits"
[args inits]
(with-bindings
(initialize args inits)))
(defn- help-opt
"Print help text for main"
[_ _]
(println (:doc (meta (var main)))))
(defn- main-dispatch
"Returns the handler associated with a main option"
[opt]
(or
({"-r" repl-opt
"--repl" repl-opt
"-m" main-opt
"--main" main-opt
nil null-opt
"-h" help-opt
"--help" help-opt
"-?" help-opt} opt)
script-opt))
(defn- legacy-repl
"Called by the clojure.lang.Repl.main stub to run a repl wit h args
specified the old way"
[args]
(println "WARNING: clojure.lang.Repl is deprecated.
Instead, use clojure.main like this:
java -cp clojure.jar clojure.main -i init.clj -r args...")
(let [[inits [sep & args]] (split-with (complement #{"--"} ) args)]
(repl-opt (concat ["-r"] args) (map vector (repeat "-i") in its))))
(defn- legacy-script
"Called by the clojure.lang.Script.main stub to run a scrip t with
args specified the old way"
[args]
(println "WARNING: clojure.lang.Script is deprecated.
1388 CHAPTER 11. CLJ/CLOJURE/
Instead, use clojure.main like this:
java -cp clojure.jar clojure.main -i init.clj script.clj a rgs...")
(let [[inits [sep & args]] (split-with (complement #{"--"} ) args)]
(null-opt args (map vector (repeat "-i") inits))))
(defn main
"Usage:
java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]
With no options or args, runs an interactive Read-Eval-Prin t Loop
init options:
-i, --init path Load a file or resource
-e, --eval string Evaluate expressions in string; print non -nil
values
main options:
-m, --main ns-name Call the -main function from a namespace
with args
-r, --repl Run a repl
path Run a script from from a file or resource
- Run a script from standard input
-h, -?, --help Print this help message and exit
operation:
- Establishes thread-local bindings for commonly set!-abl e vars
- Enters the user namespace
- Binds *command-line-args* to a seq of strings containing c ommand
line args that appear after any main option
- Runs all init options in order
- Calls a -main function or runs a repl or script if requested
The init options may be repeated and mixed freely, but must ap pear
before any main option. The appearance of any eval option bef ore
running a repl suppresses the usual repl greeting message:
\"Clojure ~(clojure-version)\".
Paths may be absolute or relative in the filesystem or relati ve to
classpath. Classpath-relative paths have prefix of @ or @/"
[& args]
(try
(if args
(loop [[opt arg & more :as args] args inits []]
(if (init-dispatch opt)
(recur more (conj inits [opt arg]))
((main-dispatch opt) args inits)))
(repl-opt nil nil))
(finally
(flush))))
11.16. PARALLEL.CLJ 1389
———-
11.16 parallel.clj
— parallel.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "DEPRECATED Wrapper of the ForkJoin library (JSR -166)."
:author "Rich Hickey"}
clojure.parallel)
(alias ’parallel ’clojure.parallel)
(comment "
The parallel library wraps the ForkJoin library scheduled f or
inclusion in JDK 7:
http://gee.cs.oswego.edu/dl/concurrency-interest/in dex.html
You’ll need jsr166y.jar in your classpath in order to use thi s
library. The basic idea is that Clojure collections, and mos t
efficiently vectors, can be turned into parallel arrays for use by
this library with the function par, although most of the func tions
take collections and will call par if needed, so normally you will
only need to call par explicitly in order to attach bound/fil ter/map
ops. Parallel arrays support the attachment of bounds, filt ers and
mapping functions prior to realization/calculation, whic h happens as
the result of any of several operations on the
array (pvec/psort/pfilter-nils/pfilter-dupes). Rather than perform
composite operations in steps, as would normally be done wit h
sequences, maps and filters are instead attached and thus co mposed by
providing ops to par. Note that there is an order sensitivity to the
attachments - bounds precede filters precede mappings. All operations
then happen in parallel, using multiple threads and a sophis ticated
work-stealing system supported by fork-join, either when t he array is
realized, or to perform aggregate operations like preduce/ pmin/pmax
etc. A parallel array can be realized into a Clojure vector us ing
pvec.
")
(import ’(jsr166y.forkjoin ParallelArray ParallelArray WithBounds
ParallelArrayWithFilter ParallelArrayWithMapping Ops$ Op
Ops$BinaryOp Ops$Reducer Ops$Predicate Ops$BinaryPredi cate
Ops$IntAndObjectPredicate Ops$IntAndObjectToObject))
1390 CHAPTER 11. CLJ/CLOJURE/
(defn- op [f]
(proxy [Ops$Op] []
(op [x] (f x))))
(defn- binary-op [f]
(proxy [Ops$BinaryOp] []
(op [x y] (f x y))))
(defn- int-and-object-to-object [f]
(proxy [Ops$IntAndObjectToObject] []
(op [i x] (f x i))))
(defn- reducer [f]
(proxy [Ops$Reducer] []
(op [x y] (f x y))))
(defn- predicate [f]
(proxy [Ops$Predicate] []
(op [x] (boolean (f x)))))
(defn- binary-predicate [f]
(proxy [Ops$BinaryPredicate] []
(op [x y] (boolean (f x y)))))
(defn- int-and-object-predicate [f]
(proxy [Ops$IntAndObjectPredicate] []
(op [i x] (boolean (f x i)))))
(defn par
"Creates a parallel array from coll. ops, if supplied, perfo rm
on-the-fly filtering or transformations during parallel r ealization
or calculation. ops form a chain, and bounds must precede fil ters,
must precede maps. ops must be a set of keyword value pairs of t he
following forms:
:bound [start end]
Only elements from start (inclusive) to end (exclusive) wil l be
processed when the array is realized.
:filter pred
Filter preds remove elements from processing when the array is
realized. pred must be a function of one argument whose retur n
will be processed via boolean.
:filter-index pred2
pred2 must be a function of two arguments, which will be an ele ment
of the collection and the corresponding index, whose return will be
11.16. PARALLEL.CLJ 1391
processed via boolean.
:filter-with [pred2 coll2]
pred2 must be a function of two arguments, which will be
corresponding elements of the 2 collections.
:map f
Map fns will be used to transform elements when the array is
realized. f must be a function of one argument.
:map-index f2
f2 must be a function of two arguments, which will be an elemen t of
the collection and the corresponding index.
:map-with [f2 coll2]
f2 must be a function of two arguments, which will be correspo nding
elements of the 2 collections."
([coll]
(if (instance? ParallelArrayWithMapping coll)
coll
(. ParallelArray createUsingHandoff
(to-array coll)
(. ParallelArray defaultExecutor))))
([coll & ops]
(reduce
(fn [pa [op args]]
(cond
(= op :bound)
(. pa withBounds (args 0) (args 1))
(= op :filter)
(. pa withFilter (predicate args))
(= op :filter-with)
(. pa withFilter (binary-predicate (args 0)) (par (args 1)) )
(= op :filter-index)
(. pa withIndexedFilter (int-and-object-predicate args) )
(= op :map)
(. pa withMapping (parallel/op args))
(= op :map-with)
(. pa withMapping (binary-op (args 0)) (par (args 1)))
(= op :map-index)
(. pa withIndexedMapping (int-and-object-to-object args ))
:else (throw (Exception. (str "Unsupported par op: " op)))) )
(par coll)
(partition 2 ops))))
1392 CHAPTER 11. CLJ/CLOJURE/
;;;;;;;;;;;;;;;;;;;;; aggregate operations ;;;;;;;;;;; ;;;;;;;;;;;
(defn pany
"Returns some (random) element of the coll if it satisfies th e
bound/filter/map"
[coll]
(. (par coll) any))
(defn pmax
"Returns the maximum element, presuming Comparable elemen ts, unless
a Comparator comp is supplied"
([coll] (. (par coll) max))
([coll comp] (. (par coll) max comp)))
(defn pmin
"Returns the minimum element, presuming Comparable elemen ts, unless
a Comparator comp is supplied"
([coll] (. (par coll) min))
([coll comp] (. (par coll) min comp)))
(defn- summary-map [s]
{:min (.min s) :max (.max s) :size (.size s)
:min-index (.indexOfMin s) :max-index (.indexOfMax s)})
(defn psummary
"Returns a map of summary statistics (min. max, size, min-in dex,
max-index, presuming Comparable elements, unless a Compar ator
comp is supplied"
([coll] (summary-map (. (par coll) summary)))
([coll comp] (summary-map (. (par coll) summary comp))))
(defn preduce
"Returns the reduction of the realized elements of coll
using function f. Note f will not necessarily be called
consecutively, and so must be commutative. Also note that
(f base an-element) might be performed many times, i.e. base is not
an initial value as with sequential reduce."
[f base coll]
(. (par coll) (reduce (reducer f) base)))
;;;;;;;;;;;;;;; collection-producing operations ;;;;;; ;;;;;;;;;;;;;;;;
(defn- pa-to-vec [pa]
(vec (. pa getArray)))
(defn- pall
"Realizes a copy of the coll as a parallel array, with any
bounds/filters/maps applied"
[coll]
(if (instance? ParallelArrayWithMapping coll)
(. coll all)
11.16. PARALLEL.CLJ 1393
(par coll)))
(defn pvec
"Returns the realized contents of the parallel array pa as
a Clojure vector"
[pa] (pa-to-vec (pall pa)))
(defn pdistinct
"Returns a parallel array of the distinct elements of coll"
[coll]
(pa-to-vec (. (pall coll) allUniqueElements)))
;this doesn’t work, passes null to reducer?
(defn- pcumulate [coll f init]
(.. (pall coll) (precumulate (reducer f) init)))
(defn psort
"Returns a new vector consisting of the realized items in col l,
sorted, presuming Comparable elements, unless a Comparato r comp
is supplied"
([coll] (pa-to-vec (. (pall coll) sort)))
([coll comp] (pa-to-vec (. (pall coll) sort comp))))
(defn pfilter-nils
"Returns a vector containing the non-nil (realized) elemen ts of coll"
[coll]
(pa-to-vec (. (pall coll) removeNulls)))
(defn pfilter-dupes
"Returns a vector containing the (realized) elements of col l,
without any consecutive duplicates"
[coll]
(pa-to-vec (. (pall coll) removeConsecutiveDuplicates)) )
(comment
(load-file "src/parallel.clj")
(refer ’parallel)
(pdistinct [1 2 3 2 1])
;(pcumulate [1 2 3 2 1] + 0) ;broken, not exposed
(def a (make-array Object 1000000))
(dotimes i (count a)
(aset a i (rand-int i)))
(time (reduce + 0 a))
(time (preduce + 0 a))
(time (count (distinct a)))
(time (count (pdistinct a)))
(preduce + 0 [1 2 3 2 1])
(preduce + 0 (psort a))
1394 CHAPTER 11. CLJ/CLOJURE/
(pvec (par [11 2 3 2] :filter-index (fn [x i] (> i x))))
(pvec (par [11 2 3 2] :filter-with [(fn [x y] (> y x)) [110 2 33 2] ]))
(psummary ;or pvec/pmax etc
(par [11 2 3 2]
:filter-with [(fn [x y] (> y x))
[110 2 33 2]]
:map #(* % 2)))
(preduce + 0
(par [11 2 3 2]
:filter-with [< [110 2 33 2]]))
(time (reduce + 0 (map #(* % %) (range 1000000))))
(time (preduce + 0 (par (range 1000000) :map-index *)))
(def v (range 1000000))
(time (preduce + 0 (par v :map-index *)))
(time (preduce + 0 (par v :map #(* % %))))
(time (reduce + 0 (map #(* % %) v)))
)
———-
11.17 cl˙format.clj
— cl˙format.clj —
\getchunk{Clojure Copyright}
;; Author: Tom Faulhaber
;; April 3, 2009
;; This module implements the Common Lisp compatible format
;; function as documented in "Common Lisp the Language, 2nd e dition",
;; Chapter 22 (available online at:
;; http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-r epository/
;; ai/html/cltl/clm/node200.html#SECTION002633000000 000000000)
(in-ns ’clojure.pprint)
;;; Forward references
(declare compile-format)
(declare execute-format)
(declare init-navigator)
;;; End forward references
11.17. CL˙FORMAT.CLJ 1395
(defn cl-format
"An implementation of a Common Lisp compatible format funct ion.
cl-format formats its arguments to an output stream or strin g based
on the format control string given. It supports sophisticat ed
formatting of structured data.
Writer is an instance of java.io.Writer, true to output to *o ut* or
nil to output to a string, format-in is the format control str ing
and the remaining arguments are the data to be formatted.
The format control string is a string to be output with embedd ed
’format directives’ describing how to format the various ar guments
passed in.
If writer is nil, cl-format returns the formatted result
string. Otherwise, cl-format returns nil.
For example:
(let [results [46 38 22]]
(cl-format true
\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\ "
(count results) results))
Prints to *out*:
There are 3 results: 46, 38, 22
Detailed documentation on format control strings is availa ble in the
\"Common Lisp the Language, 2nd edition\", Chapter 22 (avai lable
online at:
http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-rep ository/
ai/html/cltl/clm/node200.html#SECTION00263300000000 0000000)
and in the Common Lisp HyperSpec at
http://www.lispworks.com/documentation/HyperSpec/Bo dy/22_c.htm
"
{:added "1.2",
:see-also
[[(str "http://www.cs.cmu.edu/afs/cs.cmu.edu/project /"
"ai-repository/ai/html/cltl/clm/node200.html"
"#SECTION002633000000000000000" )
"Common Lisp the Language"]
["http://www.lispworks.com/documentation/HyperSpec/ Body/22_c.htm"
"Common Lisp HyperSpec"]]}
[writer format-in & args]
(let [compiled-format
(if (string? format-in) (compile-format format-in) forma t-in)
navigator (init-navigator args)]
(execute-format writer compiled-format navigator)))
(def ^:dynamic ^{:private true} *format-str* nil)
1396 CHAPTER 11. CLJ/CLOJURE/
(defn- format-error [message offset]
(let [full-message
(str message \newline *format-str* \newline
(apply str (repeat offset \space)) "^" \newline)]
(throw (RuntimeException. full-message))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Argument navigators manage the argument list
;;; as the format statement moves through the list
;;; (possibly going forwards and backwards as it does so)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defstruct ^{:private true}
arg-navigator :seq :rest :pos )
(defn- init-navigator
"Create a new arg-navigator from the sequence with the posit ion
set to 0"
{:skip-wiki true}
[s]
(let [s (seq s)]
(struct arg-navigator s s 0)))
;; TODO call format-error with offset
(defn- next-arg [ navigator ]
(let [ rst (:rest navigator) ]
(if rst
[(first rst)
(struct arg-navigator (:seq navigator ) (next rst)
(inc (:pos navigator)))]
(throw (new Exception
"Not enough arguments for format definition")))))
(defn- next-arg-or-nil [navigator]
(let [rst (:rest navigator)]
(if rst
[(first rst)
(struct arg-navigator (:seq navigator ) (next rst)
(inc (:pos navigator)))]
[nil navigator])))
;; Get an argument off the arg list and compile it if it’s
;; not already compiled
(defn- get-format-arg [navigator]
(let [[raw-format navigator] (next-arg navigator)
compiled-format (if (instance? String raw-format)
(compile-format raw-format)
raw-format)]
[compiled-format navigator]))
11.17. CL˙FORMAT.CLJ 1397
(declare relative-reposition)
(defn- absolute-reposition [navigator position]
(if (>= position (:pos navigator))
(relative-reposition navigator (- (:pos navigator) posit ion))
(struct arg-navigator (:seq navigator)
(drop position (:seq navigator)) position)))
(defn- relative-reposition [navigator position]
(let [newpos (+ (:pos navigator) position)]
(if (neg? position)
(absolute-reposition navigator newpos)
(struct arg-navigator (:seq navigator)
(drop position (:rest navigator)) newpos))))
(defstruct ^{:private true}
compiled-directive :func :def :params :offset)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; When looking at the parameter list, we may need to manipul ate
;;; the argument list as well (for ’V’ and ’#’ parameter types ).
;;; We hide all of this behind a function, but clients need to
;;; manage changing arg navigator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; TODO: validate parameters when they come from arg list
(defn- realize-parameter [[param [raw-val offset]] navig ator]
(let [[real-param new-navigator]
(cond
;pass flags through unchanged - this really isn’t necessary
(contains? #{ :at :colon } param)
[raw-val navigator]
(= raw-val :parameter-from-args)
(next-arg navigator)
(= raw-val :remaining-arg-count)
[(count (:rest navigator)) navigator]
true
[raw-val navigator])]
[[param [real-param offset]] new-navigator]))
(defn- realize-parameter-list [parameter-map navigator ]
(let [[pairs new-navigator]
(map-passing-context realize-parameter navigator param eter-map)]
[(into {} pairs) new-navigator]))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
1398 CHAPTER 11. CLJ/CLOJURE/
;;; Functions that support individual directives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Common handling code for ~A and ~S
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(declare opt-base-str)
(def ^{:private true}
special-radix-markers {2 "#b" 8 "#o", 16 "#x"})
(defn- format-simple-number [n]
(cond
(integer? n) (if (= *print-base* 10)
(str n (if *print-radix* "."))
(str
(if *print-radix*
(or (get special-radix-markers *print-base*)
(str "#" *print-base* "r")))
(opt-base-str *print-base* n)))
(ratio? n) (str
(if *print-radix*
(or (get special-radix-markers *print-base*)
(str "#" *print-base* "r")))
(opt-base-str *print-base* (.numerator n))
"/"
(opt-base-str *print-base* (.denominator n)))
:else nil))
(defn- format-ascii [print-func params arg-navigator off sets]
(let [ [arg arg-navigator] (next-arg arg-navigator)
^String base-output (or (format-simple-number arg)
(print-func arg))
base-width (.length base-output)
min-width (+ base-width (:minpad params))
width (if (>= min-width (:mincol params))
min-width
(+ min-width
(* (+ (quot (- (:mincol params) min-width 1)
(:colinc params) )
1)
(:colinc params))))
chars (apply str
(repeat (- width base-width) (:padchar params)))]
(if (:at params)
(print (str chars base-output))
(print (str base-output chars)))
arg-navigator))
11.17. CL˙FORMAT.CLJ 1399
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for the integer directives ~D, ~X, ~O, ~B and some
;;; of ~R
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- integral?
"returns true if a number is actually an integer (that is, has no
fractional part)"
[x]
(cond
(integer? x) true
(decimal? x) ; true iff no fractional part
(>= (.ulp (.stripTrailingZeros (bigdec 0))) 1)
(float? x) (= x (Math/floor x))
(ratio? x) (let [^clojure.lang.Ratio r x]
(= 0 (rem (.numerator r) (.denominator r))))
:else false))
(defn- remainders
"Return the list of remainders (essentially the ’digits’) o f val
in the given base"
[base val]
(reverse
(first
(consume #(if (pos? %)
[(rem % base) (quot % base)]
[nil nil])
val))))
;;; TODO: xlated-val does not seem to be used here.
(defn- base-str
"Return val as a string in the given base"
[base val]
(if (zero? val)
"0"
(let [xlated-val (cond
(float? val) (bigdec val)
(ratio? val)
(let [^clojure.lang.Ratio r val]
(/ (.numerator r) (.denominator r)))
:else val)]
(apply str
(map
#(if (< % 10)
(char (+ (int \0) %))
(char (+ (int \a) (- % 10))))
(remainders base val))))))
(def ^{:private true}
java-base-formats {8 "%o", 10 "%d", 16 "%x"})
1400 CHAPTER 11. CLJ/CLOJURE/
(defn- opt-base-str
"Return val as a string in the given base, using
clojure.core/format if supported
for improved performance"
[base val]
(let [format-str (get java-base-formats base)]
(if (and format-str
(integer? val)
(not (instance? clojure.lang.BigInt val)))
(clojure.core/format format-str val)
(base-str base val))))
(defn- group-by* [unit lis]
(reverse
(first
(consume (fn [x]
[(seq (reverse (take unit x)))
(seq (drop unit x))]) (reverse lis)))))
(defn- format-integer [base params arg-navigator offsets ]
(let [[arg arg-navigator] (next-arg arg-navigator)]
(if (integral? arg)
(let [neg (neg? arg)
pos-arg (if neg (- arg) arg)
raw-str (opt-base-str base pos-arg)
group-str
(if (:colon params)
(let [groups
(map #(apply str %)
(group-by* (:commainterval params) raw-str))
commas
(repeat (count groups) (:commachar params))]
(apply str (next (interleave commas groups))))
raw-str)
^String signed-str (cond
neg (str "-" group-str)
(:at params) (str "+" group-str)
true group-str)
padded-str
(if (< (.length signed-str) (:mincol params))
(str (apply str
(repeat (- (:mincol params) (.length signed-str))
(:padchar params)))
signed-str)
signed-str)]
(print padded-str))
(format-ascii print-str {:mincol (:mincol params)
:colinc 1 :minpad 0
:padchar (:padchar params) :at true}
11.17. CL˙FORMAT.CLJ 1401
(init-navigator [arg]) nil))
arg-navigator))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for english formats (~R and ~:R)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^{:private true}
english-cardinal-units
["zero" "one" "two" "three" "four" "five" "six" "seven" "ei ght"
"nine" "ten" "eleven" "twelve" "thirteen" "fourteen"
"fifteen" "sixteen" "seventeen" "eighteen" "nineteen"])
(def ^{:private true}
english-ordinal-units
["zeroth" "first" "second" "third" "fourth" "fifth" "sixt h"
"seventh" "eighth" "ninth"
"tenth" "eleventh" "twelfth" "thirteenth" "fourteenth"
"fifteenth" "sixteenth" "seventeenth" "eighteenth" "nin eteenth"])
(def ^{:private true}
english-cardinal-tens
["" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy"
"eighty" "ninety"])
(def ^{:private true}
english-ordinal-tens
["" "" "twentieth" "thirtieth" "fortieth" "fiftieth"
"sixtieth" "seventieth" "eightieth" "ninetieth"])
;; We use "short scale" for our units
;; (see http://en.wikipedia.org/wiki/Long_and_short_s cales)
;; Number names from http://www.jimloy.com/math/billion .htm
;; We follow the rules for writing numbers from the Blue Book
;; (http://www.grammarbook.com/numbers/numbers.asp)
(def ^{:private true}
english-scale-numbers
["" "thousand" "million" "billion" "trillion" "quadrilli on"
"quintillion" "sextillion" "septillion" "octillion" "no nillion"
"decillion" "undecillion" "duodecillion" "tredecillion "
"quattuordecillion" "quindecillion" "sexdecillion"
"septendecillion" "octodecillion" "novemdecillion"
"vigintillion"])
(defn- format-simple-cardinal
"Convert a number less than 1000 to a cardinal english string "
[num]
(let [hundreds (quot num 100)
tens (rem num 100)]
(str
1402 CHAPTER 11. CLJ/CLOJURE/
(if (pos? hundreds)
(str (nth english-cardinal-units hundreds) " hundred"))
(if (and (pos? hundreds) (pos? tens)) " ")
(if (pos? tens)
(if (< tens 20)
(nth english-cardinal-units tens)
(let [ten-digit (quot tens 10)
unit-digit (rem tens 10)]
(str
(if (pos? ten-digit) (nth english-cardinal-tens ten-digi t))
(if (and (pos? ten-digit) (pos? unit-digit)) "-")
(if (pos? unit-digit)
(nth english-cardinal-units unit-digit)))))))))
(defn- add-english-scales
"Take a sequence of parts, add scale numbers (e.g., million) and
combine into a string offset is a factor of 10^3 to multiply by "
[parts offset]
(let [cnt (count parts)]
(loop [acc []
pos (dec cnt)
this (first parts)
remainder (next parts)]
(if (nil? remainder)
(str (apply str (interpose ", " acc))
(if (and (not (empty? this)) (not (empty? acc))) ", ")
this
(if (and (not (empty? this)) (pos? (+ pos offset)))
(str " " (nth english-scale-numbers (+ pos offset)))))
(recur
(if (empty? this)
acc
(conj acc
(str this " " (nth english-scale-numbers (+ pos offset)))))
(dec pos)
(first remainder)
(next remainder))))))
(defn- format-cardinal-english [params navigator offset s]
(let [[arg navigator] (next-arg navigator)]
(if (= 0 arg)
(print "zero")
(let [abs-arg
(if (neg? arg)
(- arg)
arg) ; some numbers are too big for Math/abs
parts (remainders 1000 abs-arg)]
(if (<= (count parts) (count english-scale-numbers))
(let [parts-strs (map format-simple-cardinal parts)
full-str (add-english-scales parts-strs 0)]
11.17. CL˙FORMAT.CLJ 1403
(print (str (if (neg? arg) "minus ") full-str)))
(format-integer ;; for numbers > 10^63, we fall back on ~D
10
{ :mincol 0, :padchar \space, :commachar \,
:commainterval 3, :colon true}
(init-navigator [arg])
{ :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))
navigator))
(defn- format-simple-ordinal
"Convert a number less than 1000 to a ordinal english string
Note this should only be used for the last one in the sequence"
[num]
(let [hundreds (quot num 100)
tens (rem num 100)]
(str
(if (pos? hundreds)
(str (nth english-cardinal-units hundreds) " hundred"))
(if (and (pos? hundreds) (pos? tens)) " ")
(if (pos? tens)
(if (< tens 20)
(nth english-ordinal-units tens)
(let [ten-digit (quot tens 10)
unit-digit (rem tens 10)]
(if (and (pos? ten-digit) (not (pos? unit-digit)))
(nth english-ordinal-tens ten-digit)
(str
(if (pos? ten-digit) (nth english-cardinal-tens ten-digi t))
(if (and (pos? ten-digit) (pos? unit-digit)) "-")
(if (pos? unit-digit)
(nth english-ordinal-units unit-digit))))))
(if (pos? hundreds) "th")))))
(defn- format-ordinal-english [params navigator offsets ]
(let [[arg navigator] (next-arg navigator)]
(if (= 0 arg)
(print "zeroth")
(let [abs-arg
(if (neg? arg)
(- arg)
arg) ; some numbers are too big for Math/abs
parts (remainders 1000 abs-arg)]
(if (<= (count parts) (count english-scale-numbers))
(let [parts-strs (map format-simple-cardinal (drop-last parts))
head-str (add-english-scales parts-strs 1)
tail-str (format-simple-ordinal (last parts))]
(print (str (if (neg? arg) "minus ")
(cond
(and (not (empty? head-str))
(not (empty? tail-str)))
1404 CHAPTER 11. CLJ/CLOJURE/
(str head-str ", " tail-str)
(not (empty? head-str)) (str head-str "th")
:else tail-str))))
(do (format-integer ;; for numbers > 10^63, we fall back on ~D
10
{ :mincol 0, :padchar \space, :commachar \,
:commainterval 3, :colon true}
(init-navigator [arg])
{ :mincol 0, :padchar 0, :commachar 0 :commainterval 0})
(let [low-two-digits (rem arg 100)
not-teens (or (< 11 low-two-digits)
(> 19 low-two-digits))
low-digit (rem low-two-digits 10)]
(print (cond
(and (== low-digit 1) not-teens) "st"
(and (== low-digit 2) not-teens) "nd"
(and (== low-digit 3) not-teens) "rd"
:else "th")))))))
navigator))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for roman numeral formats (~@R and ~@:R)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^{:private true}
old-roman-table
[[ "I" "II" "III" "IIII" "V" "VI" "VII" "VIII" "VIIII"]
[ "X" "XX" "XXX" "XXXX" "L" "LX" "LXX" "LXXX" "LXXXX"]
[ "C" "CC" "CCC" "CCCC" "D" "DC" "DCC" "DCCC" "DCCCC"]
[ "M" "MM" "MMM"]])
(def ^{:private true}
new-roman-table
[[ "I" "II" "III" "IV" "V" "VI" "VII" "VIII" "IX"]
[ "X" "XX" "XXX" "XL" "L" "LX" "LXX" "LXXX" "XC"]
[ "C" "CC" "CCC" "CD" "D" "DC" "DCC" "DCCC" "CM"]
[ "M" "MM" "MMM"]])
(defn- format-roman
"Format a roman numeral using the specified look-up table"
[table params navigator offsets]
(let [[arg navigator] (next-arg navigator)]
(if (and (number? arg) (> arg 0) (< arg 4000))
(let [digits (remainders 10 arg)]
(loop [acc []
pos (dec (count digits))
digits digits]
(if (empty? digits)
11.17. CL˙FORMAT.CLJ 1405
(print (apply str acc))
(let [digit (first digits)]
(recur (if (= 0 digit)
acc
(conj acc (nth (nth table pos) (dec digit))))
(dec pos)
(next digits))))))
(format-integer ;; for anything <= 0 or > 3999, we fall back on ~D
10
{ :mincol 0, :padchar \space, :commachar \,
:commainterval 3, :colon true}
(init-navigator [arg])
{ :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))
navigator))
(defn- format-old-roman [params navigator offsets]
(format-roman old-roman-table params navigator offsets) )
(defn- format-new-roman [params navigator offsets]
(format-roman new-roman-table params navigator offsets) )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for character formats (~C)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^{:private true}
special-chars { 8 "Backspace", 9 "Tab", 10 "Newline",
13 "Return", 32 "Space"})
(defn- pretty-character [params navigator offsets]
(let [[c navigator] (next-arg navigator)
as-int (int c)
base-char (bit-and as-int 127)
meta (bit-and as-int 128)
special (get special-chars base-char)]
(if (> meta 0) (print "Meta-"))
(print (cond
special special
(< base-char 32) (str "Control-" (char (+ base-char 64)))
(= base-char 127) "Control-?"
:else (char base-char)))
navigator))
(defn- readable-character [params navigator offsets]
(let [[c navigator] (next-arg navigator)]
(condp = (:char-format params)
\o (cl-format true "\\o~3,’0o" (int c))
\u (cl-format true "\\u~4,’0x" (int c))
nil (pr c))
navigator))
1406 CHAPTER 11. CLJ/CLOJURE/
(defn- plain-character [params navigator offsets]
(let [[char navigator] (next-arg navigator)]
(print char)
navigator))
;; Check to see if a result is an abort (~^) construct
;; TODO: move these funcs somewhere more appropriate
(defn- abort? [context]
(let [token (first context)]
(or (= :up-arrow token) (= :colon-up-arrow token))))
;; Handle the execution of "sub-clauses" in bracket constru ctions
(defn- execute-sub-format [format args base-args]
(second
(map-passing-context
(fn [element context]
(if (abort? context)
[nil context] ; just keep passing it along
(let [[params args]
(realize-parameter-list (:params element) context)
[params offsets] (unzip-map params)
params (assoc params :base-args base-args)]
[nil (apply (:func element) [params args offsets])])))
args
format)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for real number formats
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; TODO - return exponent as int to eliminate double conversi on
(defn- float-parts-base
"Produce string parts for the mantissa (normalized 1-9) and exponent"
[^Object f]
(let [^String s (.toLowerCase (.toString f))
exploc (.indexOf s (int \e))]
(if (neg? exploc)
(let [dotloc (.indexOf s (int \.))]
(if (neg? dotloc)
[s (str (dec (count s)))]
[(str (subs s 0 dotloc) (subs s (inc dotloc)))
(str (dec dotloc))]))
[(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))])))
(defn- float-parts
"Take care of leading and trailing zeros in decomposed float s"
[f]
(let [[m ^String e] (float-parts-base f)
11.17. CL˙FORMAT.CLJ 1407
m1 (rtrim m \0)
m2 (ltrim m1 \0)
delta (- (count m1) (count m2))
^String e (if (and (pos? (count e)) (= (nth e 0) \+))
(subs e 1) e)]
(if (empty? m2)
["0" 0]
[m2 (- (Integer/valueOf e) delta)])))
(defn- round-str [m e d w]
(if (or d w)
(let [len (count m)
round-pos (if d (+ e d 1))
round-pos (if (and w (< (inc e) (dec w))
(or (nil? round-pos)
(< (dec w) round-pos)))
(dec w)
round-pos)
[m1 e1 round-pos len] (if (= round-pos 0)
[(str "0" m) (inc e) 1 (inc len)]
[m e round-pos len])]
(if round-pos
(if (neg? round-pos)
["0" 0 false]
(if (> len round-pos)
(let [round-char (nth m1 round-pos)
^String result (subs m1 0 round-pos)]
(if (>= (int round-char) (int \5))
(let [result-val (Integer/valueOf result)
leading-zeros
(subs result 0
(min (prefix-count result \0)
(- round-pos 1)))
round-up-result
(str leading-zeros
(String/valueOf (+ result-val
(if (neg? result-val) -1 1))))
expanded (> (count round-up-result)
(count result))]
[round-up-result e1 expanded])
[result e1 false]))
[m e false]))
[m e false]))
[m e false]))
(defn- expand-fixed [m e d]
(let [m1 (if (neg? e) (str (apply str (repeat (dec (- e)) \0)) m ) m)
len (count m1)
target-len (if d (+ e d 1) (inc e))]
(if (< len target-len)
1408 CHAPTER 11. CLJ/CLOJURE/
(str m1 (apply str (repeat (- target-len len) \0)))
m1)))
(defn- insert-decimal
"Insert the decimal point at the right spot in the number to
match an exponent"
[m e]
(if (neg? e)
(str "." m)
(let [loc (inc e)]
(str (subs m 0 loc) "." (subs m loc)))))
(defn- get-fixed [m e d]
(insert-decimal (expand-fixed m e d) e))
(defn- insert-scaled-decimal
"Insert the decimal point at the right spot in the number to
match an exponent"
[m k]
(if (neg? k)
(str "." m)
(str (subs m 0 k) "." (subs m k))))
;; the function to render ~F directives
;; TODO: support rationals. Back off to ~D/~A is the appropri ate cases
(defn- fixed-float [params navigator offsets]
(let [w (:w params)
d (:d params)
[arg navigator] (next-arg navigator)
[sign abs] (if (neg? arg) ["-" (- arg)] ["+" arg])
[mantissa exp] (float-parts abs)
scaled-exp (+ exp (:k params))
add-sign (or (:at params) (neg? arg))
append-zero (and (not d) (<= (dec (count mantissa)) scaled- exp))
[rounded-mantissa scaled-exp expanded]
(round-str mantissa scaled-exp
d (if w (- w (if add-sign 1 0))))
fixed-repr
(get-fixed rounded-mantissa
(if expanded (inc scaled-exp) scaled-exp) d)
prepend-zero (= (first fixed-repr) \.)]
(if w
(let [len (count fixed-repr)
signed-len (if add-sign (inc len) len)
prepend-zero (and prepend-zero (not (>= signed-len w)))
append-zero (and append-zero (not (>= signed-len w)))
full-len (if (or prepend-zero append-zero)
(inc signed-len)
signed-len)]
(if (and (> full-len w) (:overflowchar params))
11.17. CL˙FORMAT.CLJ 1409
(print (apply str (repeat w (:overflowchar params))))
(print (str
(apply str (repeat (- w full-len) (:padchar params)))
(if add-sign sign)
(if prepend-zero "0")
fixed-repr
(if append-zero "0")))))
(print (str
(if add-sign sign)
(if prepend-zero "0")
fixed-repr
(if append-zero "0"))))
navigator))
;; the function to render ~E directives
;; TODO: support rationals. Back off to ~D/~A is the appropri ate cases
;; TODO: define ~E representation for Infinity
(defn- exponential-float [params navigator offsets]
(let [[arg navigator] (next-arg navigator)]
(loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) ar g))]
(let [w (:w params)
d (:d params)
e (:e params)
k (:k params)
expchar (or (:exponentchar params) \E)
add-sign (or (:at params) (neg? arg))
prepend-zero (<= k 0)
^Integer scaled-exp (- exp (dec k))
scaled-exp-str (str (Math/abs scaled-exp))
scaled-exp-str (str expchar (if (neg? scaled-exp) \- \+)
(if e (apply str
(repeat
(- e
(count scaled-exp-str))
\0)))
scaled-exp-str)
exp-width (count scaled-exp-str)
base-mantissa-width (count mantissa)
scaled-mantissa
(str (apply str (repeat (- k) \0))
mantissa
(if d
(apply str
(repeat
(- d (dec base-mantissa-width)
(if (neg? k) (- k) 0)) \0))))
w-mantissa (if w (- w exp-width))
[rounded-mantissa _ incr-exp]
(round-str
1410 CHAPTER 11. CLJ/CLOJURE/
scaled-mantissa 0
(cond
(= k 0) (dec d)
(pos? k) d
(neg? k) (dec d))
(if w-mantissa (- w-mantissa (if add-sign 1 0))))
full-mantissa (insert-scaled-decimal rounded-mantissa k)
append-zero (and (= k (count rounded-mantissa)) (nil? d))]
(if (not incr-exp)
(if w
(let [len (+ (count full-mantissa) exp-width)
signed-len (if add-sign (inc len) len)
prepend-zero (and prepend-zero (not (= signed-len w)))
full-len (if prepend-zero (inc signed-len) signed-len)
append-zero (and append-zero (< full-len w))]
(if (and (or (> full-len w) (and e (> (- exp-width 2) e)))
(:overflowchar params))
(print (apply str (repeat w (:overflowchar params))))
(print (str
(apply str
(repeat
(- w full-len (if append-zero 1 0) )
(:padchar params)))
(if add-sign (if (neg? arg) \- \+))
(if prepend-zero "0")
full-mantissa
(if append-zero "0")
scaled-exp-str))))
(print (str
(if add-sign (if (neg? arg) \- \+))
(if prepend-zero "0")
full-mantissa
(if append-zero "0")
scaled-exp-str)))
(recur [rounded-mantissa (inc exp)]))))
navigator))
;; the function to render ~G directives
;; This just figures out whether to pass the request off to
;; ~F or ~E based on the algorithm in CLtL.
;; TODO: support rationals. Back off to ~D/~A is the appropri ate cases
;; TODO: refactor so that float-parts isn’t called twice
(defn- general-float [params navigator offsets]
(let [[arg _] (next-arg navigator)
[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))
w (:w params)
d (:d params)
e (:e params)
n (if (= arg 0.0) 0 (inc exp))
ee (if e (+ e 2) 4)
11.17. CL˙FORMAT.CLJ 1411
ww (if w (- w ee))
d (if d d (max (count mantissa) (min n 7)))
dd (- d n)]
(if (<= 0 dd d)
(let [navigator (fixed-float {:w ww, :d dd, :k 0,
:overflowchar (:overflowchar params),
:padchar (:padchar params),
:at (:at params)}
navigator offsets)]
(print (apply str (repeat ee \space)))
navigator)
(exponential-float params navigator offsets))))
;; the function to render ~$ directives
;; TODO: support rationals. Back off to ~D/~A is the appropri ate cases
(defn- dollar-float [params navigator offsets]
(let [[^Double arg navigator] (next-arg navigator)
[mantissa exp] (float-parts (Math/abs arg))
d (:d params) ; digits after the decimal
n (:n params) ; minimum digits before the decimal
w (:w params) ; minimum field width
add-sign (or (:at params) (neg? arg))
[rounded-mantissa scaled-exp expanded]
(round-str mantissa exp d nil)
^String fixed-repr
(get-fixed rounded-mantissa
(if expanded (inc scaled-exp) scaled-exp) d)
full-repr
(str
(apply str
(repeat (- n (.indexOf fixed-repr (int \.))) \0)) fixed-rep r)
full-len (+ (count full-repr) (if add-sign 1 0))]
(print (str
(if (and (:colon params) add-sign) (if (neg? arg) \- \+))
(apply str (repeat (- w full-len) (:padchar params)))
(if (and (not (:colon params)) add-sign)
(if (neg? arg) \- \+))
full-repr))
navigator))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for the ’~[...~]’ conditional construct in its
;;; different flavors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; ~[...~] without any modifiers chooses one of the clauses b ased
;; on the param or next argument
;; TODO check arg is positive int
(defn- choice-conditional [params arg-navigator offsets ]
(let [arg (:selector params)
1412 CHAPTER 11. CLJ/CLOJURE/
[arg navigator]
(if arg [arg arg-navigator] (next-arg arg-navigator))
clauses (:clauses params)
clause (if (or (neg? arg) (>= arg (count clauses)))
(first (:else params))
(nth clauses arg))]
(if clause
(execute-sub-format clause navigator (:base-args params ))
navigator)))
;; ~:[...~] with the colon reads the next argument treating i t
;; as a truth value
(defn- boolean-conditional [params arg-navigator offset s]
(let [[arg navigator] (next-arg arg-navigator)
clauses (:clauses params)
clause (if arg
(second clauses)
(first clauses))]
(if clause
(execute-sub-format clause navigator (:base-args params ))
navigator)))
;; ~@[...~] with the at sign executes the conditional if the n ext
;; arg is not nil/false without consuming the arg
(defn- check-arg-conditional [params arg-navigator offs ets]
(let [[arg navigator] (next-arg arg-navigator)
clauses (:clauses params)
clause (if arg (first clauses))]
(if arg
(if clause
(execute-sub-format clause arg-navigator (:base-args pa rams))
arg-navigator)
navigator)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for the ’~{...~}’ iteration construct in its
;;; different flavors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; ~{...~} without any modifiers uses the next argument as an
;; argument list that
;; is consumed by all the iterations
(defn- iterate-sublist [params navigator offsets]
(let [max-count (:max-iterations params)
param-clause (first (:clauses params))
[clause navigator] (if (empty? param-clause)
(get-format-arg navigator)
[param-clause navigator])
11.17. CL˙FORMAT.CLJ 1413
[arg-list navigator] (next-arg navigator)
args (init-navigator arg-list)]
(loop [count 0
args args
last-pos (num -1)]
(if (and (not max-count) (= (:pos args) last-pos) (> count 1) )
;; TODO get the offset in here and call format exception
(throw (RuntimeException.
"%{ construct not consuming any arguments: Infinite loop!" )))
(if (or (and (empty? (:rest args))
(or (not (:colon (:right-params params)))
(> count 0)))
(and max-count (>= count max-count)))
navigator
(let [iter-result
(execute-sub-format clause args (:base-args params))]
(if (= :up-arrow (first iter-result))
navigator
(recur (inc count) iter-result (:pos args))))))))
;; ~:{...~} with the colon treats the next argument as a list o f
;; sublists. Each of the sublists is used as the arglist for a
;; single iteration.
(defn- iterate-list-of-sublists [params navigator offse ts]
(let [max-count (:max-iterations params)
param-clause (first (:clauses params))
[clause navigator] (if (empty? param-clause)
(get-format-arg navigator)
[param-clause navigator])
[arg-list navigator] (next-arg navigator)]
(loop [count 0
arg-list arg-list]
(if (or (and (empty? arg-list)
(or (not (:colon (:right-params params)))
(> count 0)))
(and max-count (>= count max-count)))
navigator
(let [iter-result (execute-sub-format
clause
(init-navigator (first arg-list))
(init-navigator (next arg-list)))]
(if (= :colon-up-arrow (first iter-result))
navigator
(recur (inc count) (next arg-list))))))))
;; ~@{...~} with the at sign uses the main argument list as the a
;; rguments to the iterations is consumed by all the iteratio ns
(defn- iterate-main-list [params navigator offsets]
(let [max-count (:max-iterations params)
param-clause (first (:clauses params))
1414 CHAPTER 11. CLJ/CLOJURE/
[clause navigator] (if (empty? param-clause)
(get-format-arg navigator)
[param-clause navigator])]
(loop [count 0
navigator navigator
last-pos (num -1)]
(if (and (not max-count) (= (:pos navigator) last-pos) (> co unt 1))
;; TODO get the offset in here and call format exception
(throw (RuntimeException.
"%@{ construct not consuming any arguments: Infinite loop! ")))
(if (or (and (empty? (:rest navigator))
(or (not (:colon (:right-params params)))
(> count 0)))
(and max-count (>= count max-count)))
navigator
(let [iter-result
(execute-sub-format clause navigator (:base-args params ))]
(if (= :up-arrow (first iter-result))
(second iter-result)
(recur
(inc count) iter-result (:pos navigator))))))))
;; ~@:{...~} with both colon and at sign uses the main argumen t list
;; as a set of sublists, one of which is consumed with each iter ation
(defn- iterate-main-sublists [params navigator offsets]
(let [max-count (:max-iterations params)
param-clause (first (:clauses params))
[clause navigator] (if (empty? param-clause)
(get-format-arg navigator)
[param-clause navigator])
]
(loop [count 0
navigator navigator]
(if (or (and (empty? (:rest navigator))
(or (not (:colon (:right-params params)))
(> count 0)))
(and max-count (>= count max-count)))
navigator
(let [[sublist navigator] (next-arg-or-nil navigator)
iter-result
(execute-sub-format clause
(init-navigator sublist) navigator)]
(if (= :colon-up-arrow (first iter-result))
navigator
(recur (inc count) navigator)))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; The ’~< directive has two completely different meanings
;;; in the ’~<...~>’ form it does justification, but with
;;; ~<...~:>’ it represents the logical block operation of t he
11.17. CL˙FORMAT.CLJ 1415
;;; pretty printer.
;;;
;;; Unfortunately, the current architecture decides what f unction
;;; to call at form parsing time before the sub-clauses have b een
;;; folded, so it is left to run-time to make the decision.
;;;
;;; TODO: make it possible to make these decisions at compile -time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(declare format-logical-block)
(declare justify-clauses)
(defn- logical-block-or-justify [params navigator offse ts]
(if (:colon (:right-params params))
(format-logical-block params navigator offsets)
(justify-clauses params navigator offsets)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for the ’~<...~>’ justification directive
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- render-clauses [clauses navigator base-navigator ]
(loop [clauses clauses
acc []
navigator navigator]
(if (empty? clauses)
[acc navigator]
(let [clause (first clauses)
[iter-result result-str]
(binding
[*out* (java.io.StringWriter.)]
[(execute-sub-format clause navigator base-navigator)
(.toString *out*)])]
(if (= :up-arrow (first iter-result))
[acc (second iter-result)]
(recur (next clauses) (conj acc result-str) iter-result)) ))))
;; TODO support for ~:; constructions
(defn- justify-clauses [params navigator offsets]
(let [[[eol-str] new-navigator]
(when-let [else (:else params)]
(render-clauses else navigator (:base-args params)))
navigator (or new-navigator navigator)
[else-params new-navigator]
(when-let [p (:else-params params)]
(realize-parameter-list p navigator))
navigator (or new-navigator navigator)
min-remaining (or (first (:min-remaining else-params)) 0 )
max-columns (or (first (:max-columns else-params))
(get-max-column *out*))
1416 CHAPTER 11. CLJ/CLOJURE/
clauses (:clauses params)
[strs navigator]
(render-clauses clauses navigator (:base-args params))
slots
(max 1
(+ (dec (count strs))
(if (:colon params) 1 0) (if (:at params) 1 0)))
chars (reduce + (map count strs))
mincol (:mincol params)
minpad (:minpad params)
colinc (:colinc params)
minout (+ chars (* slots minpad))
result-columns
(if (<= minout mincol)
mincol
(+ mincol (* colinc
(+ 1 (quot (- minout mincol 1) colinc)))))
total-pad (- result-columns chars)
pad (max minpad (quot total-pad slots))
extra-pad (- total-pad (* pad slots))
pad-str (apply str (repeat pad (:padchar params)))]
(if (and eol-str
(> (+ (get-column (:base @@*out*))
min-remaining result-columns)
max-columns))
(print eol-str))
(loop [slots slots
extra-pad extra-pad
strs strs
pad-only (or (:colon params)
(and (= (count strs) 1) (not (:at params))))]
(if (seq strs)
(do
(print
(str (if (not pad-only) (first strs))
(if (or pad-only (next strs) (:at params)) pad-str)
(if (pos? extra-pad) (:padchar params))))
(recur
(dec slots)
(dec extra-pad)
(if pad-only strs (next strs))
false))))
navigator))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for case modification with ~(...~).
;;; We do this by wrapping the underlying writer with
;;; a special writer to do the appropriate modification. Thi s
;;; allows us to support arbitrary-sized output and sources
;;; that may block.
11.17. CL˙FORMAT.CLJ 1417
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- downcase-writer
"Returns a proxy that wraps writer, converting all characte rs to
lower case"
[^java.io.Writer writer]
(proxy [java.io.Writer] []
(close [] (.close writer))
(flush [] (.flush writer))
(write ([^chars cbuf ^Integer off ^Integer len]
(.write writer cbuf off len))
([x]
(condp = (class x)
String
(let [s ^String x]
(.write writer (.toLowerCase s)))
Integer
(let [c ^Character x]
(.write writer
(int (Character/toLowerCase (char c))))))))))
(defn- upcase-writer
"Returns a proxy that wraps writer, converting all characte rs to
upper case"
[^java.io.Writer writer]
(proxy [java.io.Writer] []
(close [] (.close writer))
(flush [] (.flush writer))
(write ([^chars cbuf ^Integer off ^Integer len]
(.write writer cbuf off len))
([x]
(condp = (class x)
String
(let [s ^String x]
(.write writer (.toUpperCase s)))
Integer
(let [c ^Character x]
(.write writer
(int (Character/toUpperCase (char c))))))))))
(defn- capitalize-string
"Capitalizes the words in a string. If first? is false, don’t
capitalize the first character of the string even if it’s a le tter."
[s first?]
(let [^Character f (first s)
s (if (and first? f (Character/isLetter f))
(str (Character/toUpperCase f) (subs s 1))
s)]
1418 CHAPTER 11. CLJ/CLOJURE/
(apply str
(first
(consume
(fn [s]
(if (empty? s)
[nil nil]
(let [m (re-matcher #"\W\w" s)
match (re-find m)
offset (and match (inc (.start m)))]
(if offset
[(str (subs s 0 offset)
(Character/toUpperCase
^Character (nth s offset)))
(subs s (inc offset))]
[s nil]))))
s)))))
(defn- capitalize-word-writer
"Returns a proxy that wraps writer, captializing all words"
[^java.io.Writer writer]
(let [last-was-whitespace? (ref true)]
(proxy [java.io.Writer] []
(close [] (.close writer))
(flush [] (.flush writer))
(write
([^chars cbuf ^Integer off ^Integer len]
(.write writer cbuf off len))
([x]
(condp = (class x)
String
(let [s ^String x]
(.write writer
^String (capitalize-string (.toLowerCase s)
@last-was-whitespace?))
(dosync
(ref-set last-was-whitespace?
(Character/isWhitespace
^Character (nth s (dec (count s)))))))
Integer
(let [c (char x)]
(let [mod-c (if @last-was-whitespace?
(Character/toUpperCase (char x))
c)]
(.write writer (int mod-c))
(dosync
(ref-set last-was-whitespace?
(Character/isWhitespace (char x))))))))))))
(defn- init-cap-writer
11.17. CL˙FORMAT.CLJ 1419
"Returns a proxy that wraps writer, capitalizing the first w ord"
[^java.io.Writer writer]
(let [capped (ref false)]
(proxy [java.io.Writer] []
(close [] (.close writer))
(flush [] (.flush writer))
(write ([^chars cbuf ^Integer off ^Integer len]
(.write writer cbuf off len))
([x]
(condp = (class x)
String
(let [s (.toLowerCase ^String x)]
(if (not @capped)
(let [m (re-matcher #"\S" s)
match (re-find m)
offset (and match (.start m))]
(if offset
(do (.write writer
(str (subs s 0 offset)
(Character/toUpperCase
^Character (nth s offset))
(.toLowerCase
^String (subs s (inc offset)))))
(dosync (ref-set capped true)))
(.write writer s)))
(.write writer (.toLowerCase s))))
Integer
(let [c ^Character (char x)]
(if (and (not @capped) (Character/isLetter c))
(do
(dosync (ref-set capped true))
(.write writer (int (Character/toUpperCase c))))
(.write writer
(int (Character/toLowerCase c)))))))))))
(defn- modify-case [make-writer params navigator offsets ]
(let [clause (first (:clauses params))]
(binding [*out* (make-writer *out*)]
(execute-sub-format clause navigator (:base-args params )))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; If necessary, wrap the writer in a PrettyWriter object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn get-pretty-writer
"Returns the java.io.Writer passed in wrapped in a pretty wr iter
proxy, unless it’s already a pretty writer. Generally, it is
unneccesary to call this function, since pprint, write, and
cl-format all call it if they need to. However if you want the
1420 CHAPTER 11. CLJ/CLOJURE/
state to be preserved across calls, you will want to wrap them
with this.
For example, when you want to generate column-aware output w ith
multiple calls to cl-format, do it like in this example:
(defn print-table [aseq column-width]
(binding [*out* (get-pretty-writer *out*)]
(doseq [row aseq]
(doseq [col row]
(cl-format true \"~4D~7,vT\" col column-width))
(prn))))
Now when you run:
user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11 )) 8)
It prints a table of squares and cubes for the numbers from 1 to 10:
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000"
{:added "1.2"}
[writer]
(if (pretty-writer? writer)
writer
(pretty-writer writer *print-right-margin* *print-mise r-width*)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for column-aware operations ~&, ~T
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn fresh-line
"Make a newline if *out* is not already at the beginning of the line.
If *out* is not a pretty writer (which keeps track of columns) , this
function always outputs a newline."
{:added "1.2"}
[]
(if (instance? clojure.lang.IDeref *out*)
(if (not (= 0 (get-column (:base @@*out*))))
(prn))
(prn)))
11.17. CL˙FORMAT.CLJ 1421
(defn- absolute-tabulation [params navigator offsets]
(let [colnum (:colnum params)
colinc (:colinc params)
current (get-column (:base @@*out*))
space-count (cond
(< current colnum) (- colnum current)
(= colinc 0) 0
:else (- colinc (rem (- current colnum) colinc)))]
(print (apply str (repeat space-count \space))))
navigator)
(defn- relative-tabulation [params navigator offsets]
(let [colrel (:colnum params)
colinc (:colinc params)
start-col (+ colrel (get-column (:base @@*out*)))
offset (if (pos? colinc) (rem start-col colinc) 0)
space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]
(print (apply str (repeat space-count \space))))
navigator)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Support for accessing the pretty printer from a format
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; TODO: support ~@; per-line-prefix separator
;; TODO: get the whole format wrapped so we can start the lb at a ny
;; column
(defn- format-logical-block [params navigator offsets]
(let [clauses (:clauses params)
clause-count (count clauses)
prefix (cond
(> clause-count 1)
(:string (:params (first (first clauses))))
(:colon params) "(")
body (nth clauses (if (> clause-count 1) 1 0))
suffix (cond
(> clause-count 2)
(:string (:params (first (nth clauses 2))))
(:colon params) ")")
[arg navigator] (next-arg navigator)]
(pprint-logical-block :prefix prefix :suffix suffix
(execute-sub-format
body
(init-navigator arg)
(:base-args params)))
navigator))
(defn- set-indent [params navigator offsets]
(let [relative-to (if (:colon params) :current :block)]
1422 CHAPTER 11. CLJ/CLOJURE/
(pprint-indent relative-to (:n params))
navigator))
;;; TODO: support ~:T section options for ~T
(defn- conditional-newline [params navigator offsets]
(let [kind (if (:colon params)
(if (:at params) :mandatory :fill)
(if (:at params) :miser :linear))]
(pprint-newline kind)
navigator))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; The table of directives we support, each with its params,
;;; properties, and the compilation function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; We start with a couple of helpers
(defn- process-directive-table-element
[ [ char params flags bracket-info & generator-fn ] ]
[char,
{:directive char,
:params ‘(array-map ~@params),
:flags flags,
:bracket-info bracket-info,
:generator-fn (concat ’(fn [ params offset]) generator-fn ) }])
(defmacro ^{:private true}
defdirectives
[ & directives ]
‘(def ^{:private true}
directive-table
(hash-map
~@(mapcat process-directive-table-element directives) )))
(defdirectives
(\A
[ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer ]
:padchar [\space Character] ]
#{ :at :colon :both} {}
#(format-ascii print-str %1 %2 %3))
(\S
[ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer ]
:padchar [\space Character] ]
#{ :at :colon :both} {}
#(format-ascii pr-str %1 %2 %3))
(\D
[ :mincol [0 Integer] :padchar [\space Character]
11.17. CL˙FORMAT.CLJ 1423
:commachar [\, Character] :commainterval [ 3 Integer]]
#{ :at :colon :both } {}
#(format-integer 10 %1 %2 %3))
(\B
[ :mincol [0 Integer] :padchar [\space Character]
:commachar [\, Character] :commainterval [ 3 Integer]]
#{ :at :colon :both } {}
#(format-integer 2 %1 %2 %3))
(\O
[ :mincol [0 Integer] :padchar [\space Character]
:commachar [\, Character] :commainterval [ 3 Integer]]
#{ :at :colon :both } {}
#(format-integer 8 %1 %2 %3))
(\X
[ :mincol [0 Integer] :padchar [\space Character]
:commachar [\, Character] :commainterval [ 3 Integer]]
#{ :at :colon :both } {}
#(format-integer 16 %1 %2 %3))
(\R
[:base [nil Integer] :mincol [0 Integer]
:padchar [\space Character] :commachar [\, Character]
:commainterval [ 3 Integer]]
#{ :at :colon :both } {}
(do
(cond ; ~R is overloaded with bizareness
(first (:base params)) #(format-integer (:base %1) %1 %2 %3 )
(and (:at params) (:colon params)) #(format-old-roman %1 % 2 %3)
(:at params) #(format-new-roman %1 %2 %3)
(:colon params) #(format-ordinal-english %1 %2 %3)
true #(format-cardinal-english %1 %2 %3))))
(\P
[ ]
#{ :at :colon :both } {}
(fn [params navigator offsets]
(let [navigator (if (:colon params)
(relative-reposition navigator -1)
navigator)
strs (if (:at params) ["y" "ies"] ["" "s"])
[arg navigator] (next-arg navigator)]
(print (if (= arg 1) (first strs) (second strs)))
navigator)))
(\C
[:char-format [nil Character]]
#{ :at :colon :both } {}
1424 CHAPTER 11. CLJ/CLOJURE/
(cond
(:colon params) pretty-character
(:at params) readable-character
:else plain-character))
(\F
[ :w [nil Integer] :d [nil Integer] :k [0 Integer]
:overflowchar [nil Character] :padchar [\space Character ] ]
#{ :at } {}
fixed-float)
(\E
[ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Inte ger]
:overflowchar [nil Character] :padchar [\space Character ]
:exponentchar [nil Character] ]
#{ :at } {}
exponential-float)
(\G
[ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Inte ger]
:overflowchar [nil Character] :padchar [\space Character ]
:exponentchar [nil Character] ]
#{ :at } {}
general-float)
(\$
[ :d [2 Integer] :n [1 Integer] :w [0 Integer]
:padchar [\space Character]]
#{ :at :colon :both} {}
dollar-float)
(\%
[ :count [1 Integer] ]
#{ } {}
(fn [params arg-navigator offsets]
(dotimes [i (:count params)]
(prn))
arg-navigator))
(\&
[ :count [1 Integer] ]
#{ :pretty } {}
(fn [params arg-navigator offsets]
(let [cnt (:count params)]
(if (pos? cnt) (fresh-line))
(dotimes [i (dec cnt)]
(prn)))
arg-navigator))
(\|
11.17. CL˙FORMAT.CLJ 1425
[ :count [1 Integer] ]
#{ } {}
(fn [params arg-navigator offsets]
(dotimes [i (:count params)]
(print \formfeed))
arg-navigator))
(\~
[ :n [1 Integer] ]
#{ } {}
(fn [params arg-navigator offsets]
(let [n (:n params)]
(print (apply str (repeat n \~)))
arg-navigator)))
(\newline ;; Whitespace supression is handled in the compil ation loop
[ ]
#{:colon :at} {}
(fn [params arg-navigator offsets]
(if (:at params)
(prn))
arg-navigator))
(\T
[ :colnum [1 Integer] :colinc [1 Integer] ]
#{ :at :pretty } {}
(if (:at params)
#(relative-tabulation %1 %2 %3)
#(absolute-tabulation %1 %2 %3)))
(\*
[ :n [1 Integer] ]
#{ :colon :at } {}
(fn [params navigator offsets]
(let [n (:n params)]
(if (:at params)
(absolute-reposition navigator n)
(relative-reposition navigator (if (:colon params) (- n) n )))
)))
(\?
[ ]
#{ :at } {}
(if (:at params)
(fn [params navigator offsets] ; args from main arg list
(let [[subformat navigator] (get-format-arg navigator)]
(execute-sub-format subformat navigator
(:base-args params))))
(fn [params navigator offsets] ; args from sub-list
(let [[subformat navigator] (get-format-arg navigator)
1426 CHAPTER 11. CLJ/CLOJURE/
[subargs navigator] (next-arg navigator)
sub-navigator (init-navigator subargs)]
(execute-sub-format subformat sub-navigator
(:base-args params))
navigator))))
(\(
[ ]
#{ :colon :at :both} { :right \), :allows-separator nil, :el se nil }
(let [mod-case-writer (cond
(and (:at params) (:colon params))
upcase-writer
(:colon params)
capitalize-word-writer
(:at params)
init-cap-writer
:else
downcase-writer)]
#(modify-case mod-case-writer %1 %2 %3)))
(\) [] #{} {} nil)
(\[
[ :selector [nil Integer] ]
#{ :colon :at } { :right \], :allows-separator true, :else :l ast }
(cond
(:colon params)
boolean-conditional
(:at params)
check-arg-conditional
true
choice-conditional))
(\; [:min-remaining [nil Integer] :max-columns [nil Integ er]]
#{ :colon } { :separator true } nil)
(\] [] #{} {} nil)
(\{
[ :max-iterations [nil Integer] ]
#{ :colon :at :both} { :right \}, :allows-separator false }
(cond
(and (:at params) (:colon params))
iterate-main-sublists
11.17. CL˙FORMAT.CLJ 1427
(:colon params)
iterate-list-of-sublists
(:at params)
iterate-main-list
true
iterate-sublist))
(\} [] #{:colon} {} nil)
(\<
[:mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer ]
:padchar [\space Character]]
#{:colon :at :both :pretty} { :right \>,
:allows-separator true, :else :first }
logical-block-or-justify)
(\> [] #{:colon} {} nil)
;; TODO: detect errors in cases where colon not allowed
(\^ [:arg1 [nil Integer] :arg2 [nil Integer] :arg3 [nil Inte ger]]
#{:colon} {}
(fn [params navigator offsets]
(let [arg1 (:arg1 params)
arg2 (:arg2 params)
arg3 (:arg3 params)
exit (if (:colon params) :colon-up-arrow :up-arrow)]
(cond
(and arg1 arg2 arg3)
(if (<= arg1 arg2 arg3) [exit navigator] navigator)
(and arg1 arg2)
(if (= arg1 arg2) [exit navigator] navigator)
arg1
(if (= arg1 0) [exit navigator] navigator)
true ; TODO: handle looking up the arglist stack for info
(if (if (:colon params)
(empty? (:rest (:base-args params)))
(empty? (:rest navigator)))
[exit navigator] navigator)))))
(\W
[]
#{:at :colon :both} {}
(if (or (:at params) (:colon params))
1428 CHAPTER 11. CLJ/CLOJURE/
(let [bindings (concat
(if (:at params) [:level nil :length nil] [])
(if (:colon params) [:pretty true] []))]
(fn [params navigator offsets]
(let [[arg navigator] (next-arg navigator)]
(if (apply write arg bindings)
[:up-arrow navigator]
navigator))))
(fn [params navigator offsets]
(let [[arg navigator] (next-arg navigator)]
(if (write-out arg)
[:up-arrow navigator]
navigator)))))
(\_
[]
#{:at :colon :both} {}
conditional-newline)
(\I
[:n [0 Integer]]
#{:colon} {}
set-indent)
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Code to manage the parameters and flags associated with e ach
;;; directive in the format string.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^{:private true}
param-pattern #"^([vV]|#|(’.)|([+-]?\d+)|(?=,))")
(def ^{:private true}
special-params #{ :parameter-from-args :remaining-arg- count })
(defn- extract-param [[s offset saw-comma]]
(let [m (re-matcher param-pattern s)
param (re-find m)]
(if param
(let [token-str (first (re-groups m))
remainder (subs s (.end m))
new-offset (+ offset (.end m))]
(if (not (= \, (nth remainder 0)))
[ [token-str offset] [remainder new-offset false]]
[ [token-str offset]
[(subs remainder 1) (inc new-offset) true]]))
(if saw-comma
(format-error
"Badly formed parameters in format directive" offset)
[ nil [s offset]]))))
11.17. CL˙FORMAT.CLJ 1429
(defn- extract-params [s offset]
(consume extract-param [s offset false]))
(defn- translate-param
"Translate the string representation of a param to the inter nalized
representation"
[[^String p offset]]
[(cond
(= (.length p) 0) nil
(and (= (.length p) 1)
(contains? #{\v \V} (nth p 0))) :parameter-from-args
(and (= (.length p) 1) (= \# (nth p 0))) :remaining-arg-count
(and (= (.length p) 2) (= \’ (nth p 0))) (nth p 1)
true (new Integer p))
offset])
(def ^{:private true}
flag-defs { \: :colon, \@ :at })
(defn- extract-flags [s offset]
(consume
(fn [[s offset flags]]
(if (empty? s)
[nil [s offset flags]]
(let [flag (get flag-defs (first s))]
(if flag
(if (contains? flags flag)
(format-error
(str
"Flag \"" (first s) "\" appears more than once in a directive" )
offset)
[true [(subs s 1) (inc offset)
(assoc flags flag [true offset])]])
[nil [s offset flags]]))))
[s offset {}]))
(defn- check-flags [def flags]
(let [allowed (:flags def)]
(if (and (not (:at allowed)) (:at flags))
(format-error
(str
"\"@\" is an illegal flag for format directive \"" (:directi ve def) "\"")
(nth (:at flags) 1)))
(if (and (not (:colon allowed)) (:colon flags))
(format-error (str
"\":\" is an illegal flag for format directive \"" (:directi ve def) "\"")
(nth (:colon flags) 1)))
(if (and (not (:both allowed)) (:at flags) (:colon flags))
1430 CHAPTER 11. CLJ/CLOJURE/
(format-error (str
"Cannot combine \"@\" and \":\" flags for format directive \ ""
(:directive def) "\"")
(min (nth (:colon flags) 1) (nth (:at flags) 1))))))
(defn- map-params
"Takes a directive definition and the list of actual paramet ers
and a map of flags and returns a map of the parameters and flags
with defaults filled in. We check to make sure that there are t he
right types and number of parameters as well."
[def params flags offset]
(check-flags def flags)
(if (> (count params) (count (:params def)))
(format-error
(cl-format
nil
(str
"Too many parameters for directive \"~C\": ~D~:* "
"~[were~;was~:;were~] specified but only ~D~:* "
"~[are~;is~:;are~] allowed")
(:directive def) (count params) (count (:params def)))
(second (first params))))
(doall
(map #(let [val (first %1)]
(if (not (or (nil? val) (contains? special-params val)
(instance? (second (second %2)) val)))
(format-error (str "Parameter " (name (first %2))
" has bad type in directive \"" (:directive def) "\": "
(class val))
(second %1))) )
params (:params def)))
(merge ; create the result map
(into (array-map) ; start with the default values,
; make sure the order is right
(reverse (for [[name [default]] (:params def)]
[name [default offset]])))
(reduce #(apply assoc %1 %2) {}
(filter #(first (nth % 1)) ; add the specified parameters,
; filtering out nils
(zipmap (keys (:params def)) params)))
flags)) ; and finally add the flags
(defn- compile-directive [s offset]
(let [[raw-params [rest offset]] (extract-params s offset )
[_ [rest offset flags]] (extract-flags rest offset)
directive (first rest)
def (get directive-table
(Character/toUpperCase ^Character directive))
params (if def
11.17. CL˙FORMAT.CLJ 1431
(map-params def (map translate-param raw-params)
flags offset))]
(if (not directive)
(format-error
"Format string ended in the middle of a directive" offset))
(if (not def)
(format-error (str "Directive \"" directive "\" is undefin ed")
offset))
[(struct compiled-directive ((:generator-fn def) params offset)
def params offset)
(let [remainder (subs rest 1)
offset (inc offset)
trim? (and (= \newline (:directive def))
(not (:colon params)))
trim-count
(if trim? (prefix-count remainder [\space \tab]) 0)
remainder (subs remainder trim-count)
offset (+ offset trim-count)]
[remainder offset])]))
(defn- compile-raw-string [s offset]
(struct compiled-directive
(fn [_ a _] (print s) a) nil { :string s } offset))
(defn- right-bracket [this] (:right (:bracket-info (:def this))))
(defn- separator? [this] (:separator (:bracket-info (:de f this))))
(defn- else-separator? [this]
(and (:separator (:bracket-info (:def this)))
(:colon (:params this))))
(declare collect-clauses)
(defn- process-bracket [this remainder]
(let [[subex remainder] (collect-clauses (:bracket-info (:def this))
(:offset this) remainder)]
[(struct compiled-directive
(:func this) (:def this)
(merge (:params this) (tuple-map subex (:offset this)))
(:offset this))
remainder]))
(defn- process-clause [bracket-info offset remainder]
(consume
(fn [remainder]
(if (empty? remainder)
(format-error "No closing bracket found." offset)
(let [this (first remainder)
remainder (next remainder)]
(cond
1432 CHAPTER 11. CLJ/CLOJURE/
(right-bracket this)
(process-bracket this remainder)
(= (:right bracket-info) (:directive (:def this)))
[ nil [:right-bracket (:params this) nil remainder]]
(else-separator? this)
[nil [:else nil (:params this) remainder]]
(separator? this)
[nil [:separator nil nil remainder]] ;; TODO: check to make
;; sure that there are
;; no params on ~;
true
[this remainder]))))
remainder))
(defn- collect-clauses [bracket-info offset remainder]
(second
(consume
(fn [[clause-map saw-else remainder]]
(let [[clause [type right-params else-params remainder]]
(process-clause bracket-info offset remainder)]
(cond
(= type :right-bracket)
[nil [(merge-with concat clause-map
{(if saw-else :else :clauses) [clause]
:right-params right-params})
remainder]]
(= type :else)
(cond
(:else clause-map)
(format-error
"Two else clauses (\"~:;\") inside bracket construction."
offset)
(not (:else bracket-info))
(format-error (str
"An else clause (\"~:;\") is in a bracket type that"
" doesn’t support it." )
offset)
(and (= :first (:else bracket-info))
(seq (:clauses clause-map)))
(format-error (str
"The else clause (\"~:;\") is only allowed in the first "
"position for this directive." )
offset)
11.17. CL˙FORMAT.CLJ 1433
true ; if the ~:; is in the last position, the else clause
; is next, this was a regular clause
(if (= :first (:else bracket-info))
[true [(merge-with concat clause-map
{ :else [clause] :else-params else-params})
false remainder]]
[true [(merge-with concat clause-map { :clauses [clause] } )
true remainder]]))
(= type :separator)
(cond
saw-else
(format-error (str
"A plain clause (with \"~;\") follows an else "
"clause (\"~:;\") inside bracket construction.") offset)
(not (:allows-separator bracket-info))
(format-error
(str "A separator (\"~;\") is in a bracket type that "
"doesn’t support it." )
offset)
true
[true [(merge-with concat clause-map { :clauses [clause] } )
false remainder]]))))
[{ :clauses [] } false remainder])))
(defn- process-nesting
"Take a linearly compiled format and process the bracket dir ectives
to give it the appropriate tree structure"
[format]
(first
(consume
(fn [remainder]
(let [this (first remainder)
remainder (next remainder)
bracket (:bracket-info (:def this))]
(if (:right bracket)
(process-bracket this remainder)
[this remainder])))
format)))
(defn- compile-format
"Compiles format-str into a compiled format which can be use d as
an argument to cl-format just like a plain format string. Use this
function for improved performance when you’re using the sam e format
string repeatedly"
[ format-str ]
; (prlabel compiling format-str)
1434 CHAPTER 11. CLJ/CLOJURE/
(binding [*format-str* format-str]
(process-nesting
(first
(consume
(fn [[^String s offset]]
(if (empty? s)
[nil s]
(let [tilde (.indexOf s (int \~))]
(cond
(neg? tilde)
[(compile-raw-string s offset)
["" (+ offset (.length s))]]
(zero? tilde) (compile-directive (subs s 1) (inc offset))
true
[(compile-raw-string (subs s 0 tilde) offset)
[(subs s tilde) (+ tilde offset)]]))))
[format-str 0])))))
(defn- needs-pretty
"determine whether a given compiled format has any directiv es
that depend on the column number or pretty printing"
[format]
(loop [format format]
(if (empty? format)
false
(if (or (:pretty (:flags (:def (first format))))
(some needs-pretty
(first (:clauses (:params (first format)))))
(some needs-pretty
(first (:else (:params (first format))))))
true
(recur (next format))))))
(defn- execute-format
"Executes the format with the arguments."
{:skip-wiki true}
([stream format args]
(let [^java.io.Writer real-stream
(cond
(not stream) (java.io.StringWriter.)
(true? stream) *out*
:else stream)
^java.io.Writer wrapped-stream
(if (and (needs-pretty format)
(not (pretty-writer? real-stream)))
(get-pretty-writer real-stream)
real-stream)]
(binding [*out* wrapped-stream]
(try
(execute-format format args)
11.17. CL˙FORMAT.CLJ 1435
(finally
(if-not (identical? real-stream wrapped-stream)
(.flush wrapped-stream))))
(if (not stream) (.toString real-stream)))))
([format args]
(map-passing-context
(fn [element context]
(if (abort? context)
[nil context]
(let [[params args] (realize-parameter-list
(:params element) context)
[params offsets] (unzip-map params)
params (assoc params :base-args args)]
[nil (apply (:func element) [params args offsets])])))
args
format)
nil))
;;; This is a bad idea, but it prevents us from leaking private symbols
;;; This should all be replaced by really compiled formats an yway.
(def ^{:private true} cached-compile (memoize compile-fo rmat))
(defmacro formatter
"Makes a function which can directly run format-in. The func tion is
fn [stream & args] ... and returns nil unless the stream is nil (meaning
output to a string) in which case it returns the resulting str ing.
format-in can be either a control string or a previously comp iled
format."
{:added "1.2"}
[format-in]
‘(let [format-in# ~format-in
my-c-c# (var-get (get (ns-interns (the-ns ’clojure.pprin t))
’~’cached-compile))
my-e-f# (var-get (get (ns-interns (the-ns ’clojure.pprin t))
’~’execute-format))
my-i-n# (var-get (get (ns-interns (the-ns ’clojure.pprin t))
’~’init-navigator))
cf# (if (string? format-in#) (my-c-c# format-in#) format- in#)]
(fn [stream# & args#]
(let [navigator# (my-i-n# args#)]
(my-e-f# stream# cf# navigator#)))))
(defmacro formatter-out
"Makes a function which can directly run format-in. The func tion is
fn [& args] ... and returns nil. This version of the formatter macro is
designed to be used with *out* set to an appropriate Writer. I n
particular, this is meant to be used as part of a pretty printe r
dispatch method.
1436 CHAPTER 11. CLJ/CLOJURE/
format-in can be either a control string or a previously comp iled
format."
{:added "1.2"}
[format-in]
‘(let [format-in# ~format-in
cf# (if (string? format-in#)
(#’clojure.pprint/cached-compile format-in#) format-i n#)]
(fn [& args#]
(let [navigator# (#’clojure.pprint/init-navigator args #)]
(#’clojure.pprint/execute-format cf# navigator#)))))
———-
11.18 column˙writer.clj
— column˙writer.clj —
\getchunk{Clojure Copyright}
;;; column_writer.clj -- part of the pretty printer for Cloj ure
;; Author: Tom Faulhaber
;; April 3, 2009
;; Revised to use proxy instead of gen-class April 2010
;; This module implements a column-aware wrapper around an
;; instance of java.io.Writer
(in-ns ’clojure.pprint)
(import [clojure.lang IDeref]
[java.io Writer])
(def ^:dynamic ^{:private true} *default-page-width* 72)
(defn- get-field [^Writer this sym]
(sym @@this))
(defn- set-field [^Writer this sym new-val]
(alter @this assoc sym new-val))
(defn- get-column [this]
(get-field this :cur))
(defn- get-line [this]
(get-field this :line))
(defn- get-max-column [this]
11.18. COLUMN˙WRITER.CLJ 1437
(get-field this :max))
(defn- set-max-column [this new-max]
(dosync (set-field this :max new-max))
nil)
(defn- get-writer [this]
(get-field this :base))
(defn- c-write-char [^Writer this ^Integer c]
(dosync (if (= c (int \newline))
(do
(set-field this :cur 0)
(set-field this :line (inc (get-field this :line))))
(set-field this :cur (inc (get-field this :cur)))))
(.write ^Writer (get-field this :base) c))
(defn- column-writer
([writer] (column-writer writer *default-page-width*))
([writer max-columns]
(let [fields (ref {:max max-columns, :cur 0,
:line 0 :base writer})]
(proxy [Writer IDeref] []
(deref [] fields)
(write
([^chars cbuf ^Integer off ^Integer len]
(let [^Writer writer (get-field this :base)]
(.write writer cbuf off len)))
([x]
(condp = (class x)
String
(let [^String s x
nl (.lastIndexOf s (int \newline))]
(dosync (if (neg? nl)
(set-field this :cur
(+ (get-field this :cur) (count s)))
(do
(set-field this :cur (- (count s) nl 1))
(set-field this :line
(+ (get-field this :line)
(count (filter #(= % \newline) s)))))))
(.write ^Writer (get-field this :base) s))
Integer
(c-write-char this x)
Long
(c-write-char this x))))))))
———-
1438 CHAPTER 11. CLJ/CLOJURE/
11.19 dispatch.clj
— dispatch.clj —
\getchunk{Clojure Copyright}
;; dispatch.clj -- part of the pretty printer for Clojure
;; Author: Tom Faulhaber
;; April 3, 2009
;; This module implements the default dispatch tables for pr etty
;; printing code and data.
(in-ns ’clojure.pprint)
(defn- use-method
"Installs a function as a new method of multimethod associat ed
with dispatch-value. "
[multifn dispatch-val func]
(. multifn addMethod dispatch-val func))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;
;; Implementations of specific dispatch table entries
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;
;;; Handle forms that can be "back-translated" to reader mac ros
;;; Not all reader macros can be dealt with this way or at all.
;;; Macros that we can’t deal with at all are:
;;; ; - The comment character is aborbed by the reader and neve r is
;;; part of the form
;;; ‘ - Is fully processed at read time into a lisp expression
;;; (which will contain concats and regular quotes).
;;; ~@ - Also fully eaten by the processing of ‘ and can’t be use d
;;; outside.
;;; , - is whitespace and is lost (like all other whitespace).
;;; Formats can generate commas where they deem them useful
;;; to help readability.
;;; ^ - Adding metadata completely disappears at read time an d the
;;; data appears to be completely lost.
;;;
;;; Most other syntax stuff is dealt with directly by the form ats
;;; (like (), [], {}, and #{}) or directly by printing the obje cts
;;; using Clojure’s built-in print functions (like :keywor d, \char,
;;; or ""). The notable exception is #() which is special-cas ed.
(def ^{:private true} reader-macros
{’quote "’", ’clojure.core/deref "@",
’var "#’", ’clojure.core/unquote "~"})
11.19. DISPATCH.CLJ 1439
(defn- pprint-reader-macro [alis]
(let [^String macro-char (reader-macros (first alis))]
(when (and macro-char (= 2 (count alis)))
(.write ^java.io.Writer *out* macro-char)
(write-out (second alis))
true)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;
;; Dispatch for the basic data types when interpreted
;; as data (as opposed to code).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;
;;; TODO: inline these formatter statements into funcs so th at we
;;; are a little easier on the stack. (Or, do "real" compilati on, a
;;; la Common Lisp)
;;; (def pprint-simple-list (formatter-out "~:<~@{~w~^ ~ _~}~:>"))
(defn- pprint-simple-list [alis]
(pprint-logical-block :prefix "(" :suffix ")"
(loop [alis (seq alis)]
(when alis
(write-out (first alis))
(when (next alis)
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next alis)))))))
(defn- pprint-list [alis]
(if-not (pprint-reader-macro alis)
(pprint-simple-list alis)))
;;; (def pprint-vector (formatter-out "~<[~;~@{~w~^ ~_~} ~;]~:>"))
(defn- pprint-vector [avec]
(pprint-logical-block :prefix "[" :suffix "]"
(loop [aseq (seq avec)]
(when aseq
(write-out (first aseq))
(when (next aseq)
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next aseq)))))))
(def ^{:private true} pprint-array
(formatter-out "~<[~;~@{~w~^, ~:_~}~;]~:>"))
;;; (def pprint-map
;;; (formatter-out "~<{~;~@{~<~w~^ ~_~w~:>~^, ~_~}~;}~: >"))
(defn- pprint-map [amap]
(pprint-logical-block :prefix "{" :suffix "}"
1440 CHAPTER 11. CLJ/CLOJURE/
(loop [aseq (seq amap)]
(when aseq
(pprint-logical-block
(write-out (ffirst aseq))
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(write-out (fnext (first aseq))))
(when (next aseq)
(.write ^java.io.Writer *out* ", ")
(pprint-newline :linear)
(recur (next aseq)))))))
(def ^{:private true} pprint-set
(formatter-out "~<#{~;~@{~w~^ ~:_~}~;}~:>"))
(def ^{:private true}
type-map {"core$future_call" "Future",
"core$promise" "Promise"})
(defn- map-ref-type
"Map ugly type names to something simpler"
[name]
(or (when-let [match (re-find #"^[^$]+\$[^$]+" name)]
(type-map match))
name))
(defn- pprint-ideref [o]
(let [prefix (format "#<%s@%x%s: "
(map-ref-type (.getSimpleName (class o)))
(System/identityHashCode o)
(if (and (instance? clojure.lang.Agent o)
(agent-error o))
" FAILED"
""))]
(pprint-logical-block :prefix prefix :suffix ">"
(pprint-indent :block (-> (count prefix) (- 2) -))
(pprint-newline :linear)
(write-out
(cond
(and (future? o) (not (future-done? o))) :pending
(and (instance? clojure.lang.IPromiseImpl o)
(not (.hasValue o))) :not-delivered
:else @o)))))
(def ^{:private true} pprint-pqueue
(formatter-out "~<<-(~;~@{~w~^ ~_~}~;)-<~:>"))
(defn- pprint-simple-default [obj]
(cond
(.isArray (class obj)) (pprint-array obj)
11.19. DISPATCH.CLJ 1441
(and *print-suppress-namespaces* (symbol? obj)) (print ( name obj))
:else (pr obj)))
(defmulti
simple-dispatch
"The pretty print dispatch function for simple data structu re format."
{:added "1.2" :arglists ’[[object]]}
class)
(use-method simple-dispatch clojure.lang.ISeq pprint-l ist)
(use-method simple-dispatch clojure.lang.IPersistentV ector pprint-vector)
(use-method simple-dispatch clojure.lang.IPersistentM ap pprint-map)
(use-method simple-dispatch clojure.lang.IPersistentS et pprint-set)
(use-method simple-dispatch clojure.lang.PersistentQu eue pprint-pqueue)
(use-method simple-dispatch clojure.lang.IDeref pprint -ideref)
(use-method simple-dispatch nil pr)
(use-method simple-dispatch :default pprint-simple-def ault)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
;;; Dispatch for the code table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
(declare pprint-simple-code-list)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
;;; Format something that looks like a simple def (sans metad ata,
;;; since the reader won’t give it to us now).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
(def ^{:private true} pprint-hold-first
(formatter-out "~:<~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:>"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
;;; Format something that looks like a defn or defmacro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;
;;; Format the params and body of a defn with a single arity
(defn- single-defn [alis has-doc-str?]
(if (seq alis)
(do
(if has-doc-str?
((formatter-out " ~_"))
((formatter-out " ~@_")))
((formatter-out "~{~w~^ ~_~}") alis))))
;;; Format the param and body sublists of a defn with multiple arities
(defn- multi-defn [alis has-doc-str?]
(if (seq alis)
((formatter-out " ~_~{~w~^ ~_~}") alis)))
1442 CHAPTER 11. CLJ/CLOJURE/
;;; TODO: figure out how to support capturing metadata
;;; in defns (we might need a special reader)
(defn- pprint-defn [alis]
(if (next alis)
(let [[defn-sym defn-name & stuff] alis
[doc-str stuff] (if (string? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])
[attr-map stuff] (if (map? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])]
(pprint-logical-block :prefix "(" :suffix ")"
((formatter-out "~w ~1I~@_~w") defn-sym defn-name)
(if doc-str
((formatter-out " ~_~w") doc-str))
(if attr-map
((formatter-out " ~_~w") attr-map))
;; Note: the multi-defn case will work OK for malformed defns too
(cond
(vector? (first stuff))
(single-defn stuff (or doc-str attr-map))
:else (multi-defn stuff (or doc-str attr-map)))))
(pprint-simple-code-list alis)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
;;; Format something with a binding form
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
(defn- pprint-binding-form [binding-vec]
(pprint-logical-block :prefix "[" :suffix "]"
(loop [binding binding-vec]
(when (seq binding)
(pprint-logical-block binding
(write-out (first binding))
(when (next binding)
(.write ^java.io.Writer *out* " ")
(pprint-newline :miser)
(write-out (second binding))))
(when (next (rest binding))
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next (rest binding))))))))
(defn- pprint-let [alis]
(let [base-sym (first alis)]
(pprint-logical-block :prefix "(" :suffix ")"
(if (and (next alis) (vector? (second alis)))
(do
((formatter-out "~w ~1I~@_") base-sym)
11.19. DISPATCH.CLJ 1443
(pprint-binding-form (second alis))
((formatter-out " ~_~{~w~^ ~_~}") (next (rest alis))))
(pprint-simple-code-list alis)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;
;;; Format something that looks like "if"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;
(def ^{:private true} pprint-if
(formatter-out "~:<~1I~w~^ ~@_~w~@{ ~_~w~}~:>"))
(defn- pprint-cond [alis]
(pprint-logical-block :prefix "(" :suffix ")"
(pprint-indent :block 1)
(write-out (first alis))
(when (next alis)
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(loop [alis (next alis)]
(when alis
(pprint-logical-block alis
(write-out (first alis))
(when (next alis)
(.write ^java.io.Writer *out* " ")
(pprint-newline :miser)
(write-out (second alis))))
(when (next (rest alis))
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next (rest alis)))))))))
(defn- pprint-condp [alis]
(if (> (count alis) 3)
(pprint-logical-block :prefix "(" :suffix ")"
(pprint-indent :block 1)
(apply (formatter-out "~w ~@_~w ~@_~w ~_") alis)
(loop [alis (seq (drop 3 alis))]
(when alis
(pprint-logical-block alis
(write-out (first alis))
(when (next alis)
(.write ^java.io.Writer *out* " ")
(pprint-newline :miser)
(write-out (second alis))))
(when (next (rest alis))
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next (rest alis)))))))
(pprint-simple-code-list alis)))
1444 CHAPTER 11. CLJ/CLOJURE/
;;; The map of symbols that are defined in an enclosing #()
;;; anonymous function
(def ^:dynamic ^{:private true} *symbol-map* {})
(defn- pprint-anon-func [alis]
(let [args (second alis)
nlis (first (rest (rest alis)))]
(if (vector? args)
(binding [*symbol-map* (if (= 1 (count args))
{(first args) "%"}
(into {}
(map
#(vector %1 (str \% %2))
args
(range 1 (inc (count args))))))]
((formatter-out "~<#(~;~@{~w~^ ~_~}~;)~:>") nlis))
(pprint-simple-code-list alis))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
;;; The master definitions for formatting lists in code (tha t
;;; is, (fn args...) or special forms).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
;;; This is the equivalent of (formatter-out "~:<~1I~@{~w~ ^ ~_~}~:>"),
;;; but is easier on the stack.
(defn- pprint-simple-code-list [alis]
(pprint-logical-block :prefix "(" :suffix ")"
(pprint-indent :block 1)
(loop [alis (seq alis)]
(when alis
(write-out (first alis))
(when (next alis)
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next alis)))))))
;;; Take a map with symbols as keys and add versions with no nam espace.
;;; That is, if ns/sym->val is in the map, add sym->val to the r esult.
(defn- two-forms [amap]
(into {}
(mapcat
identity
(for [x amap]
[x [(symbol (name (first x))) (second x)]]))))
(defn- add-core-ns [amap]
(let [core "clojure.core"]
(into {}
11.19. DISPATCH.CLJ 1445
(map #(let [[s f] %]
(if (not (or (namespace s) (special-symbol? s)))
[(symbol core (name s)) f]
%))
amap))))
(def ^:dynamic ^{:private true} *code-table*
(two-forms
(add-core-ns
{’def pprint-hold-first,
’defonce pprint-hold-first,
’defn pprint-defn,
’defn- pprint-defn,
’defmacro pprint-defn,
’fn pprint-defn,
’let pprint-let,
’loop pprint-let,
’binding pprint-let,
’with-local-vars pprint-let,
’with-open pprint-let,
’when-let pprint-let,
’if-let pprint-let,
’doseq pprint-let,
’dotimes pprint-let,
’when-first pprint-let,
’if pprint-if,
’if-not pprint-if,
’when pprint-if,
’when-not pprint-if,
’cond pprint-cond,
’condp pprint-condp,
’fn* pprint-anon-func,
’. pprint-hold-first,
’.. pprint-hold-first,
’-> pprint-hold-first,
’locking pprint-hold-first,
’struct pprint-hold-first,
’struct-map pprint-hold-first,
})))
(defn- pprint-code-list [alis]
(if-not (pprint-reader-macro alis)
(if-let [special-form (*code-table* (first alis))]
(special-form alis)
(pprint-simple-code-list alis))))
(defn- pprint-code-symbol [sym]
(if-let [arg-num (sym *symbol-map*)]
(print arg-num)
(if *print-suppress-namespaces*
1446 CHAPTER 11. CLJ/CLOJURE/
(print (name sym))
(pr sym))))
(defmulti
code-dispatch
"The pretty print dispatch function for pretty printing Clo jure code."
{:added "1.2" :arglists ’[[object]]}
class)
(use-method code-dispatch clojure.lang.ISeq pprint-cod e-list)
(use-method code-dispatch clojure.lang.Symbol pprint-c ode-symbol)
;; The following are all exact copies of simple-dispatch
(use-method code-dispatch clojure.lang.IPersistentVec tor pprint-vector)
(use-method code-dispatch clojure.lang.IPersistentMap pprint-map)
(use-method code-dispatch clojure.lang.IPersistentSet pprint-set)
(use-method code-dispatch clojure.lang.PersistentQueu e pprint-pqueue)
(use-method code-dispatch clojure.lang.IDeref pprint-i deref)
(use-method code-dispatch nil pr)
(use-method code-dispatch :default pprint-simple-defau lt)
(set-pprint-dispatch simple-dispatch)
;;; For testing
(comment
(with-pprint-dispatch code-dispatch
(pprint
’(defn cl-format
"An implementation of a Common Lisp compatible format funct ion"
[stream format-in & args]
(let [compiled-format
(if (string? format-in)
(compile-format format-in)
format-in)
navigator (init-navigator args)]
(execute-format stream compiled-format navigator)))))
(with-pprint-dispatch code-dispatch
(pprint
’(defn cl-format
[stream format-in & args]
(let [compiled-format
(if (string? format-in)
(compile-format format-in)
format-in)
navigator (init-navigator args)]
(execute-format stream compiled-format navigator)))))
11.19. DISPATCH.CLJ 1447
(with-pprint-dispatch code-dispatch
(pprint
’(defn- -write
([this x]
(condp = (class x)
String
(let [s0 (write-initial-lines this x)
s (.replaceFirst s0 "\\s+$" "")
white-space (.substring s0 (count s))
mode (getf :mode)]
(if (= mode :writing)
(dosync
(write-white-space this)
(.col_write this s)
(setf :trailing-white-space white-space))
(add-to-buffer this (make-buffer-blob s white-space))))
Integer
(let [c ^Character x]
(if (= (getf :mode) :writing)
(do
(write-white-space this)
(.col_write this x))
(if (= c (int \newline))
(write-initial-lines this "\n")
(add-to-buffer this
(make-buffer-blob (str (char c)) nil))))))))))
(with-pprint-dispatch code-dispatch
(pprint
’(defn pprint-defn [writer alis]
(if (next alis)
(let [[defn-sym defn-name & stuff] alis
[doc-str stuff] (if (string? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])
[attr-map stuff] (if (map? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])]
(pprint-logical-block writer :prefix "(" :suffix ")"
(cl-format true "~w ~1I~@_~w" defn-sym defn-name)
(if doc-str (cl-format true " ~_~w" doc-str))
(if attr-map (cl-format true " ~_~w" attr-map))
;; Note: the multi-defn case will work OK for
;; malformed defns too
(cond
(vector? (first stuff))
(single-defn stuff (or doc-str attr-map))
:else (multi-defn stuff (or doc-str attr-map)))))
(pprint-simple-code-list writer alis)))))
1448 CHAPTER 11. CLJ/CLOJURE/
)
nil
———-
11.20 pprint˙base.clj
— pprint˙base.clj —
\getchunk{Clojure Copyright}
;;; pprint_base.clj -- part of the pretty printer for Clojur e
;; Author: Tom Faulhaber
;; April 3, 2009
;; This module implements the generic pretty print function s and
;; special variables
(in-ns ’clojure.pprint)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; Variables that control the pretty printer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;;
;;; *print-length*, *print-level* and *print-dup* are def ined in
;;; clojure.core
;;; TODO: use *print-dup* here (or is it supplanted by other
;;; variables?)
;;; TODO: make dispatch items like "(let..." get counted in
;;; *print-length* constructs
(def ^:dynamic
^{:doc "Bind to true if you want write to use pretty printing" ,
:added "1.2"}
*print-pretty* true)
(defonce ^:dynamic ; If folks have added stuff here, don’t ov erwrite
^{:doc "The pretty print dispatch function. Use with-pprin t-dispatch
or set-pprint-dispatch to modify.",
:added "1.2"}
*print-pprint-dispatch* nil)
(def ^:dynamic
11.20. PPRINT˙BASE.CLJ 1449
^{:doc "Pretty printing will try to avoid anything going bey ond this
column. Set it to nil to have pprint let the line be arbitraril y
long. This will ignore all non-mandatory newlines.",
:added "1.2"}
*print-right-margin* 72)
(def ^:dynamic
^{:doc "The column at which to enter miser style. Depending o n the
dispatch table, miser style add newlines in more places to
try to keep lines short allowing for further levels of
nesting.",
:added "1.2"}
*print-miser-width* 40)
;;; TODO implement output limiting
(def ^:dynamic
^{:private true,
:doc "Maximum number of lines to print in a pretty print insta nce
(N.B. This is not yet used)"}
*print-lines* nil)
;;; TODO: implement circle and shared
(def ^:dynamic
^{:private true,
:doc "Mark circular structures (N.B. This is not yet used)"}
*print-circle* nil)
;;; TODO: should we just use *print-dup* here?
(def ^:dynamic
^{:private true,
:doc "Mark repeated structures rather than repeat them
(N.B. This is not yet used)"}
*print-shared* nil)
(def ^:dynamic
^{:doc "Don’t print namespaces with symbols. This is partic ularly
useful when pretty printing the results of macro expansions "
:added "1.2"}
*print-suppress-namespaces* nil)
;;; TODO: support print-base and print-radix in cl-format
;;; TODO: support print-base and print-radix in rationals
(def ^:dynamic
^{:doc "Print a radix specifier in front of integers and rati onals.
If *print-base* is 2, 8, or 16, then the radix specifier used
is #b, #o, or #x, respectively. Otherwise the radix specifie r
is in the form #XXr where XX is the decimal value of
*print-base* "
:added "1.2"}
*print-radix* nil)
1450 CHAPTER 11. CLJ/CLOJURE/
(def ^:dynamic
^{:doc "The base to use for printing integers and rationals. "
:added "1.2"}
*print-base* 10)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; Internal variables that keep track of where we are in the
;; structure
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^:dynamic ^{ :private true } *current-level* 0)
(def ^:dynamic ^{ :private true } *current-length* nil)
;; TODO: add variables for length, lines.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; Support for the write function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(declare format-simple-number)
(def ^{:private true} orig-pr pr)
(defn- pr-with-base [x]
(if-let [s (format-simple-number x)]
(print s)
(orig-pr x)))
(def ^{:private true} write-option-table
{;:array *print-array*
:base ’clojure.pprint/*print-base*,
;;:case *print-case*,
:circle ’clojure.pprint/*print-circle*,
;;:escape *print-escape*,
;;:gensym *print-gensym*,
:length ’clojure.core/*print-length*,
:level ’clojure.core/*print-level*,
:lines ’clojure.pprint/*print-lines*,
:miser-width ’clojure.pprint/*print-miser-width*,
:dispatch ’clojure.pprint/*print-pprint-dispatch*,
:pretty ’clojure.pprint/*print-pretty*,
:radix ’clojure.pprint/*print-radix*,
:readably ’clojure.core/*print-readably*,
:right-margin ’clojure.pprint/*print-right-margin*,
:suppress-namespaces ’clojure.pprint/*print-suppress -namespaces*})
11.20. PPRINT˙BASE.CLJ 1451
(defmacro ^{:private true} binding-map [amap & body]
(let []
‘(do
(. clojure.lang.Var (pushThreadBindings ~amap))
(try
~@body
(finally
(. clojure.lang.Var (popThreadBindings)))))))
(defn- table-ize [t m]
(apply hash-map
(mapcat
#(when-let [v (get t (key %))] [(find-var v) (val %)]) m)))
(defn- pretty-writer?
"Return true iff x is a PrettyWriter"
[x] (and (instance? clojure.lang.IDeref x) (:pretty-writ er @@x)))
(defn- make-pretty-writer
"Wrap base-writer in a PrettyWriter with the specified righ t-margin
and miser-width"
[base-writer right-margin miser-width]
(pretty-writer base-writer right-margin miser-width))
(defmacro ^{:private true} with-pretty-writer [base-wri ter & body]
‘(let [base-writer# ~base-writer
new-writer# (not (pretty-writer? base-writer#))]
(binding [*out* (if new-writer#
(make-pretty-writer base-writer#
*print-right-margin* *print-miser-width*)
base-writer#)]
~@body
(.flush *out*))))
;;;TODO: if pretty print is not set, don’t use pr but rather so mething
;;;that respects *print-base*, etc.
(defn write-out
"Write an object to *out* subject to the current bindings of t he
printer control variables. Use the kw-args argument to over ride
individual variables for this call (and any recursive calls ).
*out* must be a PrettyWriter if pretty printing is enabled.
This is the responsibility of the caller.
This method is primarily intended for use by pretty print dis patch
functions that already know that the pretty printer will hav e set up
their environment appropriately. Normal library clients s hould use
the standard \"write\" interface. "
1452 CHAPTER 11. CLJ/CLOJURE/
{:added "1.2"}
[object]
(let [length-reached (and
*current-length*
*print-length*
(>= *current-length* *print-length*))]
(if-not *print-pretty*
(pr object)
(if length-reached
(print "...")
(do
(if *current-length*
(set! *current-length* (inc *current-length*)))
(*print-pprint-dispatch* object))))
length-reached))
(defn write
"Write an object subject to the current bindings of the print er
control variables. Use the kw-args argument to override ind ividual
variables for this call (and any recursive calls). Returns t he
string result if :stream is nil or nil otherwise.
The following keyword arguments can be passed with values:
Keyword Meaning and Default value
:stream Writer for output or nil
true (indicates *out*)
:base Base to use for writing rationals
Current value of *print-base*
:circle* If true, mark circular structures
Current value of *print-circle*
:length Maximum elements to show in sublists
Current value of *print-length*
:level Maximum depth
Current value of *print-level*
:lines* Maximum lines of output
Current value of *print-lines*
:miser-width Width to enter miser mode
Current value of *print-miser-width*
:dispatch The pretty print dispatch function
Current value of *print-pprint-dispatch*
:pretty If true, do pretty printing
Current value of *print-pretty*
:radix If true, prepend a radix specifier
Current value of *print-radix*
:readably* If true, print readably
Current value of *print-readably*
:right-margin The column for the right margin
Current value of *print-right-margin*
:suppress-namespaces If true, no namespaces in symbols
Current value of *print-suppress-namespaces*
11.20. PPRINT˙BASE.CLJ 1453
* = not yet supported
"
{:added "1.2"}
[object & kw-args]
(let [options (merge {:stream true} (apply hash-map kw-arg s))]
(binding-map (table-ize write-option-table options)
(binding-map (if (or (not (= *print-base* 10))
*print-radix*)
{#’pr pr-with-base}
{})
(let [optval (if (contains? options :stream)
(:stream options)
true)
base-writer (condp = optval
nil (java.io.StringWriter.)
true *out*
optval)]
(if *print-pretty*
(with-pretty-writer base-writer
(write-out object))
(binding [*out* base-writer]
(pr object)))
(if (nil? optval)
(.toString ^java.io.StringWriter base-writer)))))))
(defn pprint
"Pretty print object to the optional output writer. If the wr iter
is not provided, print the object to the currently bound valu e
of *out*."
{:added "1.2"}
([object] (pprint object *out*))
([object writer]
(with-pretty-writer writer
(binding [*print-pretty* true]
(binding-map
(if (or (not (= *print-base* 10))
*print-radix*)
{#’pr pr-with-base}
{})
(write-out object)))
(if (not (= 0 (get-column *out*)))
(prn)))))
(defmacro pp
"A convenience macro that pretty prints the last thing outpu t.
This is exactly equivalent to (pprint *1)."
{:added "1.2"}
[] ‘(pprint *1))
1454 CHAPTER 11. CLJ/CLOJURE/
(defn set-pprint-dispatch
"Set the pretty print dispatch function to a function matchi ng
(fn [obj] ...) where obj is the object to pretty print. That
function will be called with *out* set to a pretty printing
writer to which it should do its printing.
For example functions, see simple-dispatch and code-dispa tch in
clojure.pprint.dispatch.clj."
{:added "1.2"}
[function]
(let [old-meta (meta #’*print-pprint-dispatch*)]
(alter-var-root #’*print-pprint-dispatch* (constantly function))
(alter-meta! #’*print-pprint-dispatch* (constantly old -meta)))
nil)
(defmacro with-pprint-dispatch
"Execute body with the pretty print dispatch function bound to
function."
{:added "1.2"}
[function & body]
‘(binding [*print-pprint-dispatch* ~function]
~@body))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;; Support for the functional interface to the pretty printe r
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- parse-lb-options [opts body]
(loop [body body
acc []]
(if (opts (first body))
(recur (drop 2 body) (concat acc (take 2 body)))
[(apply hash-map acc) body])))
(defn- check-enumerated-arg [arg choices]
(if-not (choices arg)
(throw
(IllegalArgumentException.
;; TODO clean up choices string
(str "Bad argument: " arg ". It must be one of " choices)))))
(defn- level-exceeded []
(and *print-level* (>= *current-level* *print-level*)))
(defmacro pprint-logical-block
"Execute the body as a pretty printing logical block with out put to
*out* which must be a pretty printing writer. When used from p print
or cl-format, this can be assumed.
11.20. PPRINT˙BASE.CLJ 1455
This function is intended for use when writing custom dispat ch
functions.
Before the body, the caller can optionally specify options:
:prefix, :per-line-prefix, and :suffix."
{:added "1.2", :arglists ’[[options* body]]}
[& args]
(let [[options body]
(parse-lb-options #{:prefix :per-line-prefix :suffix} a rgs)]
‘(do (if (#’clojure.pprint/level-exceeded)
(.write ^java.io.Writer *out* "#")
(do
(push-thread-bindings
{#’clojure.pprint/*current-level*
(inc (var-get #’clojure.pprint/*current-level*))
#’clojure.pprint/*current-length* 0})
(try
(#’clojure.pprint/start-block *out*
~(:prefix options)
~(:per-line-prefix options)
~(:suffix options))
~@body
(#’clojure.pprint/end-block *out*)
(finally
(pop-thread-bindings)))))
nil)))
(defn pprint-newline
"Print a conditional newline to a pretty printing stream. ki nd
specifies if the newline is :linear, :miser, :fill, or :mand atory.
This function is intended for use when writing custom dispat ch
functions.
Output is sent to *out* which must be a pretty printing writer ."
{:added "1.2"}
[kind]
(check-enumerated-arg kind #{:linear :miser :fill :manda tory})
(nl *out* kind))
(defn pprint-indent
"Create an indent at this point in the pretty printing stream . This
defines how following lines are indented. relative-to can b e either
:block or :current depending whether the indent should be co mputed
relative to the start of the logical block or the current colu mn
position. n is an offset.
This function is intended for use when writing custom dispat ch
functions.
1456 CHAPTER 11. CLJ/CLOJURE/
Output is sent to *out* which must be a pretty printing writer ."
{:added "1.2"}
[relative-to n]
(check-enumerated-arg relative-to #{:block :current})
(indent *out* relative-to n))
;; TODO a real implementation for pprint-tab
(defn pprint-tab
"Tab at this point in the pretty printing stream. kind specif ies
whether the tab is :line, :section, :line-relative, or
:section-relative.
Colnum and colinc specify the target column and the incremen t to
move the target forward if the output is already past the orig inal
target.
This function is intended for use when writing custom dispat ch
functions.
Output is sent to *out* which must be a pretty printing writer .
THIS FUNCTION IS NOT YET IMPLEMENTED."
{:added "1.2"}
[kind colnum colinc]
(check-enumerated-arg kind
#{:line :section :line-relative :section-relative})
(throw (UnsupportedOperationException.
"pprint-tab is not yet implemented")))
nil
———-
11.21 pretty˙writer.clj
— pretty˙writer.clj —
\getchunk{Clojure Copyright}
;;; pretty_writer.clj -- part of the pretty printer for Cloj ure
;; Author: Tom Faulhaber
;; April 3, 2009
;; Revised to use proxy instead of gen-class April 2010
;; This module implements a wrapper around a java.io.Writer which
;; implements the core of the XP algorithm.
11.21. PRETTY˙WRITER.CLJ 1457
(in-ns ’clojure.pprint)
(import [clojure.lang IDeref]
[java.io Writer])
;; TODO: Support for tab directives
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Forward declarations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(declare get-miser-width)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Macros to simplify dealing with types and classes. These are
;;; really utilities, but I’m experimenting with them here.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defmacro ^{:private true}
getf
"Get the value of the field a named by the argument
(which should be a keyword)."
[sym]
‘(~sym @@~’this))
(defmacro ^{:private true}
setf [sym new-val]
"Set the value of the field SYM to NEW-VAL"
‘(alter @~’this assoc ~sym ~new-val))
(defmacro ^{:private true}
deftype [type-name & fields]
(let [name-str (name type-name)]
‘(do
(defstruct ~type-name :type-tag ~@fields)
(alter-meta! #’~type-name assoc :private true)
(defn- ~(symbol (str "make-" name-str))
[& vals#] (apply struct ~type-name ~(keyword name-str) val s#))
(defn- ~(symbol (str name-str "?"))
[x#] (= (:type-tag x#) ~(keyword name-str))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; The data structures used by pretty-writer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defstruct ^{:private true} logical-block
:parent :section :start-col :indent
:done-nl :intra-block-nl
1458 CHAPTER 11. CLJ/CLOJURE/
:prefix :per-line-prefix :suffix
:logical-block-callback)
(defn- ancestor? [parent child]
(loop [child (:parent child)]
(cond
(nil? child) false
(identical? parent child) true
:else (recur (:parent child)))))
(defstruct ^{:private true} section :parent)
(defn- buffer-length [l]
(let [l (seq l)]
(if l
(- (:end-pos (last l)) (:start-pos (first l)))
0)))
; A blob of characters (aka a string)
(deftype buffer-blob :data :trailing-white-space :start -pos :end-pos)
; A newline
(deftype nl-t :type :logical-block :start-pos :end-pos)
(deftype start-block-t :logical-block :start-pos :end-p os)
(deftype end-block-t :logical-block :start-pos :end-pos )
(deftype indent-t :logical-block :relative-to :offset :s tart-pos
:end-pos)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Functions to write tokens in the output buffer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(def ^:private pp-newline
(memoize #(System/getProperty "line.separator")))
(declare emit-nl)
(defmulti ^{:private true} write-token #(:type-tag %2))
(defmethod write-token :start-block-t [^Writer this toke n]
(when-let [cb (getf :logical-block-callback)] (cb :start ))
(let [lb (:logical-block token)]
(dosync
(when-let [^String prefix (:prefix lb)]
(.write (getf :base) prefix))
(let [col (get-column (getf :base))]
(ref-set (:start-col lb) col)
(ref-set (:indent lb) col)))))
11.21. PRETTY˙WRITER.CLJ 1459
(defmethod write-token :end-block-t [^Writer this token]
(when-let [cb (getf :logical-block-callback)] (cb :end))
(when-let [^String suffix (:suffix (:logical-block token ))]
(.write (getf :base) suffix)))
(defmethod write-token :indent-t [^Writer this token]
(let [lb (:logical-block token)]
(ref-set (:indent lb)
(+ (:offset token)
(condp = (:relative-to token)
:block @(:start-col lb)
:current (get-column (getf :base)))))))
(defmethod write-token :buffer-blob [^Writer this token]
(.write (getf :base) ^String (:data token)))
(defmethod write-token :nl-t [^Writer this token]
; (prlabel wt @(:done-nl (:logical-block token)))
; (prlabel wt (:type token) (= (:type token) :mandatory))
(if (or (= (:type token) :mandatory)
(and (not (= (:type token) :fill))
@(:done-nl (:logical-block token))))
(emit-nl this token)
(if-let [^String tws (getf :trailing-white-space)]
(.write (getf :base) tws)))
(dosync (setf :trailing-white-space nil)))
(defn- write-tokens [^Writer this tokens force-trailing- whitespace]
(doseq [token tokens]
(if-not (= (:type-tag token) :nl-t)
(if-let [^String tws (getf :trailing-white-space)]
(.write (getf :base) tws)))
(write-token this token)
(setf :trailing-white-space (:trailing-white-space tok en)))
(let [^String tws (getf :trailing-white-space)]
(when (and force-trailing-whitespace tws)
(.write (getf :base) tws)
(setf :trailing-white-space nil))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; emit-nl? method defs for each type of new line. This makes
;;; the decision about whether to print this type of new line.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- tokens-fit? [^Writer this tokens]
;;; (prlabel tf? (get-column (getf :base) (buffer-length t okens))
(let [maxcol (get-max-column (getf :base))]
(or
1460 CHAPTER 11. CLJ/CLOJURE/
(nil? maxcol)
(< (+ (get-column (getf :base)) (buffer-length tokens)) ma xcol))))
(defn- linear-nl? [this lb section]
; (prlabel lnl? @(:done-nl lb) (tokens-fit? this section))
(or @(:done-nl lb)
(not (tokens-fit? this section))))
(defn- miser-nl? [^Writer this lb section]
(let [miser-width (get-miser-width this)
maxcol (get-max-column (getf :base))]
(and miser-width maxcol
(>= @(:start-col lb) (- maxcol miser-width))
(linear-nl? this lb section))))
(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))
(defmethod emit-nl? :linear [newl this section _]
(let [lb (:logical-block newl)]
(linear-nl? this lb section)))
(defmethod emit-nl? :miser [newl this section _]
(let [lb (:logical-block newl)]
(miser-nl? this lb section)))
(defmethod emit-nl? :fill [newl this section subsection]
(let [lb (:logical-block newl)]
(or @(:intra-block-nl lb)
(not (tokens-fit? this subsection))
(miser-nl? this lb section))))
(defmethod emit-nl? :mandatory [_ _ _ _]
true)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Various support functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- get-section [buffer]
(let [nl (first buffer)
lb (:logical-block nl)
section (seq
(take-while #(not (and (nl-t? %)
(ancestor? (:logical-block %) lb)))
(next buffer)))]
[section (seq (drop (inc (count section)) buffer))]))
(defn- get-sub-section [buffer]
(let [nl (first buffer)
11.21. PRETTY˙WRITER.CLJ 1461
lb (:logical-block nl)
section
(seq
(take-while
#(let [nl-lb (:logical-block %)]
(not (and (nl-t? %)
(or (= nl-lb lb) (ancestor? nl-lb lb)))))
(next buffer)))]
section))
(defn- update-nl-state [lb]
(dosync
(ref-set (:intra-block-nl lb) false)
(ref-set (:done-nl lb) true)
(loop [lb (:parent lb)]
(if lb
(do (ref-set (:done-nl lb) true)
(ref-set (:intra-block-nl lb) true)
(recur (:parent lb)))))))
(defn- emit-nl [^Writer this nl]
(.write (getf :base) (pp-newline))
(dosync (setf :trailing-white-space nil))
(let [lb (:logical-block nl)
^String prefix (:per-line-prefix lb)]
(if prefix
(.write (getf :base) prefix))
(let [^String istr
(apply str (repeat (- @(:indent lb) (count prefix))
\space))]
(.write (getf :base) istr))
(update-nl-state lb)))
(defn- split-at-newline [tokens]
(let [pre (seq (take-while #(not (nl-t? %)) tokens))]
[pre (seq (drop (count pre) tokens))]))
;;; Methods for showing token strings for debugging
(defmulti ^{:private true} tok :type-tag)
(defmethod tok :nl-t [token]
(:type token))
(defmethod tok :buffer-blob [token]
(str \" (:data token) (:trailing-white-space token) \"))
(defmethod tok :default [token]
(:type-tag token))
(defn- toks [toks] (map tok toks))
;;; write-token-string is called when the set of tokens in th e buffer
;;; is longer than the available space on the line
1462 CHAPTER 11. CLJ/CLOJURE/
(defn- write-token-string [this tokens]
(let [[a b] (split-at-newline tokens)]
;; (prlabel wts (toks a) (toks b))
(if a (write-tokens this a false))
(if b
(let [[section remainder] (get-section b)
newl (first b)]
;; (prlabel wts (toks section))
;; (prlabel wts (:type newl))
;; (prlabel wts (toks remainder))
(let [do-nl (emit-nl? newl this section (get-sub-section b ))
result (if do-nl
(do
;; (prlabel emit-nl (:type newl))
(emit-nl this newl)
(next b))
b)
long-section (not (tokens-fit? this result))
result (if long-section
(let [rem2 (write-token-string this section)]
;;; (prlabel recurse (toks rem2))
(if (= rem2 section)
(do ; If that didn’t produce any output, it
; has no nls so we’ll force it
(write-tokens this section false)
remainder)
(into [] (concat rem2 remainder))))
result)
;; ff (prlabel wts (toks result))
]
result)))))
(defn- write-line [^Writer this]
(dosync
(loop [buffer (getf :buffer)]
;; (prlabel wl1 (toks buffer))
(setf :buffer (into [] buffer))
(if (not (tokens-fit? this buffer))
(let [new-buffer (write-token-string this buffer)]
;; (prlabel wl new-buffer)
(if-not (identical? buffer new-buffer)
(recur new-buffer)))))))
;;; Add a buffer token to the buffer and see if it’s time to star t
;;; writing
(defn- add-to-buffer [^Writer this token]
; (prlabel a2b token)
(dosync
(setf :buffer (conj (getf :buffer) token))
11.21. PRETTY˙WRITER.CLJ 1463
(if (not (tokens-fit? this (getf :buffer)))
(write-line this))))
;;; Write all the tokens that have been buffered
(defn- write-buffered-output [^Writer this]
(write-line this)
(if-let [buf (getf :buffer)]
(do
(write-tokens this buf true)
(setf :buffer []))))
(defn- write-white-space [^Writer this]
(when-let [^String tws (getf :trailing-white-space)]
; (prlabel wws (str "*" tws "*"))
(.write (getf :base) tws)
(dosync
(setf :trailing-white-space nil))))
;;; If there are newlines in the string, print the lines up unt il
;;; the last newline, making the appropriate adjustments. R eturn
;;; the remainder of the string
(defn- write-initial-lines
[^Writer this ^String s]
(let [lines (.split s "\n" -1)]
(if (= (count lines) 1)
s
(dosync
(let [^String prefix (:per-line-prefix
(first (getf :logical-blocks)))
^String l (first lines)]
(if (= :buffering (getf :mode))
(let [oldpos (getf :pos)
newpos (+ oldpos (count l))]
(setf :pos newpos)
(add-to-buffer this
(make-buffer-blob l nil oldpos newpos))
(write-buffered-output this))
(do
(write-white-space this)
(.write (getf :base) l)))
(.write (getf :base) (int \newline))
(doseq [^String l (next (butlast lines))]
(.write (getf :base) l)
(.write (getf :base) (pp-newline))
(if prefix
(.write (getf :base) prefix)))
(setf :buffering :writing)
(last lines))))))
1464 CHAPTER 11. CLJ/CLOJURE/
(defn- p-write-char [^Writer this ^Integer c]
(if (= (getf :mode) :writing)
(do
(write-white-space this)
(.write (getf :base) c))
(if (= c \newline)
(write-initial-lines this "\n")
(let [oldpos (getf :pos)
newpos (inc oldpos)]
(dosync
(setf :pos newpos)
(add-to-buffer this
(make-buffer-blob (str (char c)) nil oldpos newpos)))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Initialize the pretty-writer instance
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- pretty-writer [writer max-columns miser-width]
(let [lb (struct logical-block nil nil (ref 0) (ref 0)
(ref false) (ref false))
fields (ref {:pretty-writer true
:base (column-writer writer max-columns)
:logical-blocks lb
:sections nil
:mode :writing
:buffer []
:buffer-block lb
:buffer-level 1
:miser-width miser-width
:trailing-white-space nil
:pos 0})]
(proxy [Writer IDeref] []
(deref [] fields)
(write
([x]
;; (prlabel write x (getf :mode))
(condp = (class x)
String
(let [^String s0 (write-initial-lines this x)
^String s (.replaceFirst s0 "\\s+$" "")
white-space (.substring s0 (count s))
mode (getf :mode)]
(dosync
(if (= mode :writing)
(do
(write-white-space this)
11.21. PRETTY˙WRITER.CLJ 1465
(.write (getf :base) s)
(setf :trailing-white-space white-space))
(let [oldpos (getf :pos)
newpos (+ oldpos (count s0))]
(setf :pos newpos)
(add-to-buffer this
(make-buffer-blob s white-space oldpos newpos))))))
Integer
(p-write-char this x)
Long
(p-write-char this x))))
(flush []
(if (= (getf :mode) :buffering)
(dosync
(write-tokens this (getf :buffer) true)
(setf :buffer []))
(write-white-space this)))
(close []
(.flush this)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Methods for pretty-writer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- start-block
[^Writer this
^String prefix ^String per-line-prefix ^String suffix]
(dosync
(let [lb (struct logical-block (getf :logical-blocks) nil
(ref 0) (ref 0) (ref false) (ref false)
prefix per-line-prefix suffix)]
(setf :logical-blocks lb)
(if (= (getf :mode) :writing)
(do
(write-white-space this)
(when-let [cb (getf :logical-block-callback)] (cb :start ))
(if prefix
(.write (getf :base) prefix))
(let [col (get-column (getf :base))]
(ref-set (:start-col lb) col)
(ref-set (:indent lb) col)))
(let [oldpos (getf :pos)
newpos (+ oldpos (if prefix (count prefix) 0))]
(setf :pos newpos)
(add-to-buffer this (make-start-block-t lb oldpos newpos )))))))
1466 CHAPTER 11. CLJ/CLOJURE/
(defn- end-block [^Writer this]
(dosync
(let [lb (getf :logical-blocks)
^String suffix (:suffix lb)]
(if (= (getf :mode) :writing)
(do
(write-white-space this)
(if suffix
(.write (getf :base) suffix))
(when-let [cb (getf :logical-block-callback)] (cb :end)) )
(let [oldpos (getf :pos)
newpos (+ oldpos (if suffix (count suffix) 0))]
(setf :pos newpos)
(add-to-buffer this (make-end-block-t lb oldpos newpos)) ))
(setf :logical-blocks (:parent lb)))))
(defn- nl [^Writer this type]
(dosync
(setf :mode :buffering)
(let [pos (getf :pos)]
(add-to-buffer this
(make-nl-t type (getf :logical-blocks) pos pos)))))
(defn- indent [^Writer this relative-to offset]
(dosync
(let [lb (getf :logical-blocks)]
(if (= (getf :mode) :writing)
(do
(write-white-space this)
(ref-set (:indent lb)
(+ offset (condp = relative-to
:block @(:start-col lb)
:current (get-column (getf :base))))))
(let [pos (getf :pos)]
(add-to-buffer this
(make-indent-t lb relative-to offset pos pos)))))))
(defn- get-miser-width [^Writer this]
(getf :miser-width))
(defn- set-miser-width [^Writer this new-miser-width]
(dosync (setf :miser-width new-miser-width)))
(defn- set-logical-block-callback [^Writer this f]
(dosync (setf :logical-block-callback f)))
———-
11.22. PRINT˙TABLE.CLJ 1467
11.22 print˙table.clj
— print˙table.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.pprint)
(defn print-table
"Alpha - subject to change.
Prints a collection of maps in a textual table. Prints table
headings ks, and then a line of output for each row, correspon ding
to the keys in ks. If ks are not specified, use the keys of the
first item in rows."
{:added "1.3"}
([ks rows]
(when (seq rows)
(let [widths
(map
(fn [k]
(apply max (count (str k))
(map #(count (str (get % k))) rows)))
ks)
fmts (map #(str "%-" % "s") widths)
fmt-row (fn [row]
(apply str
(interpose " | "
(for [[col fmt]
(map vector (map #(get row %) ks) fmts)]
(format fmt (str col))))))
header (fmt-row (zipmap ks ks))
bar (apply str (repeat (count header) "="))]
(println bar)
(println header)
(println bar)
(doseq [row rows]
(println (fmt-row row)))
(println bar))))
([rows] (print-table (keys (first rows)) rows)))
———-
11.23 utilities.clj
— utilities.clj —
1468 CHAPTER 11. CLJ/CLOJURE/
\getchunk{Clojure Copyright}
;;; utilities.clj -- part of the pretty printer for Clojure
;; Author: Tom Faulhaber
;; April 3, 2009
;; This module implements some utility function used in form atting
;; and pretty printing. The functions here could go in a more g eneral
;; purpose library, perhaps.
(in-ns ’clojure.pprint)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
;;; Helper functions for digesting formats in the various
;;; phases of their lives.
;;; These functions are actually pretty general.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
(defn- map-passing-context [func initial-context lis]
(loop [context initial-context
lis lis
acc []]
(if (empty? lis)
[acc context]
(let [this (first lis)
remainder (next lis)
[result new-context] (apply func [this context])]
(recur new-context remainder (conj acc result))))))
(defn- consume [func initial-context]
(loop [context initial-context
acc []]
(let [[result new-context] (apply func [context])]
(if (not result)
[acc new-context]
(recur new-context (conj acc result))))))
(defn- consume-while [func initial-context]
(loop [context initial-context
acc []]
(let [[result continue new-context] (apply func [context] )]
(if (not continue)
[acc context]
(recur new-context (conj acc result))))))
(defn- unzip-map [m]
"Take a map that has pairs in the value slots and produce a pair
of maps, the first having all the first elements of the pairs
and the second all the second elements of the pairs"
[(into {} (for [[k [v1 v2]] m] [k v1]))
11.23. UTILITIES.CLJ 1469
(into {} (for [[k [v1 v2]] m] [k v2]))])
(defn- tuple-map [m v1]
"For all the values, v, in the map, replace them with [v v1]"
(into {} (for [[k v] m] [k [v v1]])))
(defn- rtrim [s c]
"Trim all instances of c from the end of sequence s"
(let [len (count s)]
(if (and (pos? len) (= (nth s (dec (count s))) c))
(loop [n (dec len)]
(cond
(neg? n) ""
(not (= (nth s n) c)) (subs s 0 (inc n))
true (recur (dec n))))
s)))
(defn- ltrim [s c]
"Trim all instances of c from the beginning of sequence s"
(let [len (count s)]
(if (and (pos? len) (= (nth s 0) c))
(loop [n 0]
(if (or (= n len) (not (= (nth s n) c)))
(subs s n)
(recur (inc n))))
s)))
(defn- prefix-count [aseq val]
"Return the number of times that val occurs at the start of
sequence aseq, if val is a seq itself, count the number of
times any element of val occurs at the beginning of aseq"
(let [test (if (coll? val) (set val) #{val})]
(loop [pos 0]
(if (or (= pos (count aseq)) (not (test (nth aseq pos))))
pos
(recur (inc pos))))))
(defn- prerr [& args]
"Println to *err*"
(binding [*out* *err*]
(apply println args)))
(defmacro ^{:private true} prlabel [prefix arg & more-args ]
"Print args to *err* in name = value format"
‘(prerr ~@(cons
(list ’quote prefix)
(mapcat #(list (list ’quote %) "=" %)
(cons arg (seq more-args))))))
1470 CHAPTER 11. CLJ/CLOJURE/
———-
11.24 pprint.clj
— pprint.clj —
\getchunk{Clojure Copyright}
;;; pprint.clj -- Pretty printer and Common Lisp compatible format
;;; function (cl-format) for Clojure
;; Author: Tom Faulhaber
;; April 3, 2009
(ns
^{:author "Tom Faulhaber",
:doc "A Pretty Printer for Clojure
clojure.pprint implements a flexible system for printing s tructured
data in a pleasing, easy-to-understand format. Basic use of the
pretty printer is simple, just call pprint instead of printl n.
More advanced users can use the building blocks provided to c reate
custom output formats.
Out of the box, pprint supports a simple structured format fo r basic
data and a specialized format for Clojure source code. More a dvanced
formats, including formats that don’t look like Clojure dat a at all
like XML and JSON, can be rendered by creating custom dispatc h
functions.
In addition to the pprint function, this module contains cl- format,
a text formatting function which is fully compatible with th e format
function in Common Lisp. Because pretty printing directive s are
directly integrated with cl-format, it supports very conci se custom
dispatch. It also provides a more powerful alternative to Cl ojure’s
standard format function.
See documentation for pprint and cl-format for more informa tion or
complete documentation on the the clojure web site on github .",
:added "1.2"}
clojure.pprint
(:refer-clojure :exclude (deftype)))
(load "pprint/utilities")
(load "pprint/column_writer")
(load "pprint/pretty_writer")
(load "pprint/pprint_base")
11.24. PPRINT.CLJ 1471
(load "pprint/cl_format")
(load "pprint/dispatch")
(load "pprint/print_table")
nil
———-
11.24.1 java.clj
— java.clj —
\getchunk{Clojure Copyright}
(in-ns ’clojure.reflect)
(require ’[clojure.set :as set]
’[clojure.string :as str])
(import ’[clojure.asm ClassReader ClassVisitor Type]
’[java.lang.reflect Modifier]
java.io.InputStream)
(extend-protocol TypeReference
clojure.lang.Symbol
(typename [s] (str/replace (str s) "<>" "[]"))
Class
;; neither .getName not .getSimpleName returns the right th ing,
;; so best to delegate to Type
(typename
[c]
(typename (Type/getType c)))
Type
(typename
[t]
(-> (.getClassName t))))
(defn- typesym
"Given a typeref, create a legal Clojure symbol version of th e
type’s name."
[t]
(-> (typename t)
(str/replace "[]" "<>")
(symbol)))
(defn- resource-name
"Given a typeref, return implied resource name. Used by Refl ectors
such as ASM that need to find and read classbytes from files."
1472 CHAPTER 11. CLJ/CLOJURE/
[typeref]
(-> (typename typeref)
(str/replace "." "/")
(str ".class")))
(defn- access-flag
[[name flag & contexts]]
{:name name :flag flag :contexts (set (map keyword contexts ))})
(defn- field-descriptor->class-symbol
"Convert a Java field descriptor to a Clojure class symbol. F ield
descriptors are described in section 4.3.2 of the JVM spec, 2 nd ed.:
http://java.sun.com/docs/books/jvms/second_edition/ html/
ClassFile.doc.html#14152"
[^String d]
{:pre [(string? d)]}
(typesym (Type/getType d)))
(defn- internal-name->class-symbol
"Convert a Java internal name to a Clojure class symbol. Inte rnal
names uses slashes instead of dots, e.g. java/lang/String. See
Section 4.2 of the JVM spec, 2nd ed.:
http://java.sun.com/docs/books/jvms/second_edition/ html/
ClassFile.doc.html#14757"
[d]
{:pre [(string? d)]}
(typesym (Type/getObjectType d)))
(def ^{:doc "The Java access bitflags, along with their frie ndly
names and the kinds of objects to which they can apply."}
flag-descriptors
(vec
(map access-flag
[[:public 0x0001 :class :field :method]
[:private 0x002 :class :field :method]
[:protected 0x0004 :class :field :method]
[:static 0x0008 :field :method]
[:final 0x0010 :class :field :method]
;; :super is ancient history and is unfindable (?) by
;; reflection. skip it
#_[:super 0x0020 :class]
[:synchronized 0x0020 :method]
[:volatile 0x0040 :field]
[:bridge 0x0040 :method]
[:varargs 0x0080 :method]
[:transient 0x0080 :field]
[:native 0x0100 :method]
[:interface 0x0200 :class]
[:abstract 0x0400 :class :method]
11.24. PPRINT.CLJ 1473
[:strict 0x0800 :method]
[:synthetic 0x1000 :class :field :method]
[:annotation 0x2000 :class]
[:enum 0x4000 :class :field :inner]])))
(defn- parse-flags
"Convert reflection bitflags into a set of keywords."
[flags context]
(reduce
(fn [result fd]
(if (and (get (:contexts fd) context)
(not (zero? (bit-and flags (:flag fd)))))
(conj result (:name fd))
result))
#{}
flag-descriptors))
(defrecord Constructor
[name declaring-class parameter-types exception-types f lags])
(defn- constructor->map
[^java.lang.reflect.Constructor constructor]
(Constructor.
(symbol (.getName constructor))
(typesym (.getDeclaringClass constructor))
(vec (map typesym (.getParameterTypes constructor)))
(vec (map typesym (.getExceptionTypes constructor)))
(parse-flags (.getModifiers constructor) :method)))
(defn- declared-constructors
"Return a set of the declared constructors of class as a Cloju re map."
[^Class cls]
(set (map
constructor->map
(.getDeclaredConstructors cls))))
(defrecord Method
[name return-type declaring-class parameter-types
exception-types flags])
(defn- method->map
[^java.lang.reflect.Method method]
(Method.
(symbol (.getName method))
(typesym (.getReturnType method))
(typesym (.getDeclaringClass method))
(vec (map typesym (.getParameterTypes method)))
(vec (map typesym (.getExceptionTypes method)))
(parse-flags (.getModifiers method) :method)))
1474 CHAPTER 11. CLJ/CLOJURE/
(defn- declared-methods
"Return a set of the declared constructors of class as a Cloju re map."
[^Class cls]
(set (map
method->map
(.getDeclaredMethods cls))))
(defrecord Field
[name type declaring-class flags])
(defn- field->map
[^java.lang.reflect.Field field]
(Field.
(symbol (.getName field))
(typesym (.getType field))
(typesym (.getDeclaringClass field))
(parse-flags (.getModifiers field) :field)))
(defn- declared-fields
"Return a set of the declared fields of class as a Clojure map. "
[^Class cls]
(set (map
field->map
(.getDeclaredFields cls))))
(deftype JavaReflector [classloader]
Reflector
(do-reflect [_ typeref]
(let [cls (Class/forName (typename typeref) false classlo ader)]
{:bases (not-empty (set (map typesym (bases cls))))
:flags (parse-flags (.getModifiers cls) :class)
:members (set/union (declared-fields cls)
(declared-methods cls)
(declared-constructors cls))})))
(def ^:private default-reflector
(JavaReflector. (.getContextClassLoader (Thread/curre ntThread))))
(defn- parse-method-descriptor
[^String md]
{:parameter-types (vec (map typesym (Type/getArgumentTy pes md)))
:return-type (typesym (Type/getReturnType md))})
(defprotocol ClassResolver
(^InputStream resolve-class [this name]
"Given a class name, return that typeref’s class bytes
as an InputStream."))
(extend-protocol ClassResolver
clojure.lang.Fn
11.24. PPRINT.CLJ 1475
(resolve-class [this typeref] (this typeref))
ClassLoader
(resolve-class [this typeref]
(.getResourceAsStream this (resource-name typeref))))
(deftype AsmReflector [class-resolver]
Reflector
(do-reflect [_ typeref]
(with-open [is (resolve-class class-resolver typeref)]
(let [class-symbol (typesym typeref)
r (ClassReader. is)
result (atom {:bases #{} :flags #{} :members #{}})]
(.accept
r
(reify
ClassVisitor
(visit [_ version access name signature superName interfac es]
(let [flags (parse-flags access :class)
;; ignore java.lang.Object on interfaces to match reflecti on
superName (if (and (flags :interface)
(= superName "java/lang/Object"))
nil
superName)
bases (->> (cons superName interfaces)
(remove nil?)
(map internal-name->class-symbol)
(map symbol)
(set)
(not-empty))]
(swap! result merge {:bases bases
:flags flags})))
(visitSource [_ name debug])
(visitInnerClass [_ name outerName innerName access])
(visitField [_ access name desc signature value]
(swap! result update-in [:members] (fnil conj #{})
(Field. (symbol name)
(field-descriptor->class-symbol desc)
class-symbol
(parse-flags access :field)))
nil)
(visitMethod [_ access name desc signature exceptions]
(when-not (= name "<clinit>")
(let [constructor? (= name "<init>")]
(swap! result update-in
[:members] (fnil conj #{})
(let [{:keys
[parameter-types return-type]}
(parse-method-descriptor desc)
flags
1476 CHAPTER 11. CLJ/CLOJURE/
(parse-flags access :method)]
(if constructor?
(Constructor. class-symbol
class-symbol
parameter-types
(vec
(map
internal-name->class-symbol
exceptions))
flags)
(Method. (symbol name)
return-type
class-symbol
parameter-types
(vec
(map
internal-name->class-symbol
exceptions))
flags))))))
nil)
(visitEnd [_])
) 0)
@result))))
———-
11.25 reﬂect.clj
— reﬂect.clj —
\getchunk{Clojure Copyright}
(ns ^{:author "Stuart Halloway"
:added "1.3"
:doc "Reflection on Host Types
Alpha - subject to change.
Two main entry points:
* type-reflect reflects on something that implements TypeR eference.
* reflect (for REPL use) reflects on the class of an instance, or
on a class if passed a class
Key features:
* Exposes the read side of reflection as pure data. Reflectin g
on a type returns a map with keys :bases, :flags, and :members .
11.25. REFLECT.CLJ 1477
* Canonicalizes class names as Clojure symbols. Types can ex tend
to the TypeReference protocol to indicate that they can be
unambiguously resolved as a type name. The canonical format
requires one non-Java-ish convention: array brackets are < >
instead of [] so they can be part of a Clojure symbol.
* Pluggable Reflectors for different implementations. The default
JavaReflector is good when you have a class in hand, or use
the AsmReflector for \"hands off\" reflection without forc ing
classes to load.
Platform implementers must:
* Create an implementation of Reflector.
* Create one or more implementations of TypeReference.
* def default-reflector to be an instance that satisfies Ref lector."}
clojure.reflect
(:require [clojure.set :as set]))
(defprotocol Reflector
"Protocol for reflection implementers."
(do-reflect [reflector typeref]))
(defprotocol TypeReference
"A TypeReference can be unambiguously converted to a type na me on
the host platform.
All typerefs are normalized into symbols. If you need to
normalize a typeref yourself, call typesym."
(typename [o] "Returns Java name as returned by ASM getClass Name,
e.g. byte[], java.lang.String[]"))
(declare default-reflector)
(defn type-reflect
"Alpha - subject to change.
Reflect on a typeref, returning a map with :bases, :flags, an d
:members. In the discussion below, names are always Clojure symbols.
:bases a set of names of the type’s bases
:flags a set of keywords naming the boolean attributes
of the type.
:members a set of the type’s members. Each membrer is a map
and can be a constructor, method, or field.
Keys common to all members:
:name name of the type
:declaring-class name of the declarer
:flags keyword naming boolean attributes of the member
1478 CHAPTER 11. CLJ/CLOJURE/
Keys specific to constructors:
:parameter-types vector of parameter type names
:exception-types vector of exception type names
Key specific to methods:
:parameter-types vector of parameter type names
:exception-types vector of exception type names
:return-type return type name
Keys specific to fields:
:type type name
Options:
:ancestors in addition to the keys described above, also
include an :ancestors key with the entire set of
ancestors, and add all ancestor members to
:members.
:reflector implementation to use. Defaults to JavaReflect or,
AsmReflector is also an option."
{:added "1.3"}
[typeref & options]
(let [{:keys [ancestors reflector]}
(merge {:reflector default-reflector}
(apply hash-map options))
refl (partial do-reflect reflector)
result (refl typeref)]
;; could make simpler loop of two args: names an
(if ancestors
(let [make-ancestor-map (fn [names]
(zipmap names (map refl names)))]
(loop [reflections (make-ancestor-map (:bases result))]
(let [ancestors-visited (set (keys reflections))
ancestors-to-visit
(set/difference (set (mapcat :bases (vals reflections)))
ancestors-visited)]
(if (seq ancestors-to-visit)
(recur
(merge reflections
(make-ancestor-map ancestors-to-visit)))
(apply merge-with into result
{:ancestors ancestors-visited}
(map #(select-keys % [:members]) (vals reflections)))))) )
result)))
(defn reflect
"Alpha - subject to change.
Reflect on the type of obj (or obj itself if obj is a class).
Return value and options are the same as for type-reflect. "
11.26. REPL.CLJ 1479
{:added "1.3"}
[obj & options]
(apply type-reflect (if (class? obj) obj (class obj)) optio ns))
(load "reflect/java")
———-
11.26 repl.clj
— repl.clj —
\getchunk{Houser Copyright}
; Utilities meant to be used interactively at the REPL
(ns
#^{:author
"Chris Houser, Christophe Grand, Stephen Gilardi, Michel S alim"
:doc "Utilities meant to be used interactively at the REPL"}
clojure.repl
(:import (java.io LineNumberReader InputStreamReader Pu shbackReader)
(clojure.lang RT Reflector)))
(def ^:private special-doc-map
’{. {:url "java_interop#dot"
:forms [(.instanceMember instance args*)
(.instanceMember Classname args*)
(Classname/staticMethod args*)
Classname/staticField]
:doc "The instance member form works for both fields and meth ods.
They all expand into calls to the dot operator at macroexpans ion
time."}
def {:forms [(def symbol init?)]
:doc "Creates and interns a global var with the name
of symbol in the current namespace (*ns*) or locates such a va r if
it already exists. If init is supplied, it is evaluated, and t he
root binding of the var is set to the resulting value. If init i s
not supplied, the root binding of the var is unaffected."}
do {:forms [(do exprs*)]
:doc "Evaluates the expressions in order and returns the val ue
of the last. If no expressions are supplied, returns nil."}
if {:forms [(if test then else?)]
:doc "Evaluates test. If not the singular values nil or false ,
evaluates and yields then, otherwise, evaluates and yields else. If
else is not supplied it defaults to nil."}
monitor-enter {:forms [(monitor-enter x)]
1480 CHAPTER 11. CLJ/CLOJURE/
:doc "Synchronization primitive that should be
avoided in user code. Use the ’locking’ macro."}
monitor-exit {:forms [(monitor-exit x)]
:doc "Synchronization primitive that should be
avoided in user code. Use the ’locking’ macro."}
new {:forms [(Classname. args*) (new Classname args*)]
:url "java_interop#new"
:doc "The args, if any, are evaluated from left to right, and
passed to the constructor of the class named by Classname. Th e
constructed object is returned."}
quote {:forms [(quote form)]
:doc "Yields the unevaluated form."}
recur {:forms [(recur exprs*)]
:doc "Evaluates the exprs in order, then, in parallel,
rebinds the bindings of the recursion point to the values of t he
exprs. Execution then jumps back to the recursion point, a lo op or
fn method."}
set! {:forms[(set! var-symbol expr)
(set! (. instance-expr instanceFieldName-symbol) expr)
(set! (. Classname-symbol staticFieldName-symbol) expr) ]
:url "vars#set"
:doc "Used to set thread-local-bound vars, Java object inst ance
fields, and Java class static fields."}
throw {:forms [(throw expr)]
:doc "The expr is evaluated and thrown, therefore it should
yield an instance of some derivee of Throwable."}
try {:forms [(try expr* catch-clause* finally-clause?)]
:doc "catch-clause => (catch classname name expr*)
finally-clause => (finally expr*)
Catches and handles Java exceptions."}
var {:forms [(var symbol)]
:doc "The symbol must resolve to a var, and the Var object
itself (not its value) is returned. The reader macro #’x expa nds
to (var x)."}})
(defn- special-doc [name-symbol]
(assoc (or (special-doc-map name-symbol)
(meta (resolve name-symbol)))
:name name-symbol
:special-form true))
(defn- namespace-doc [nspace]
(assoc (meta nspace) :name (ns-name nspace)))
(defn- print-doc [m]
(println "-------------------------")
(println (str (when-let [ns (:ns m)] (str (ns-name ns) "/"))
(:name m)))
(cond
11.26. REPL.CLJ 1481
(:forms m) (doseq [f (:forms m)]
(print " ")
(prn f))
(:arglists m) (prn (:arglists m)))
(if (:special-form m)
(do
(println "Special Form")
(println " " (:doc m))
(if (contains? m :url)
(when (:url m)
(println (str "\n Please see http://clojure.org/" (:url m) )))
(println (str "\n Please see http://clojure.org/special_ forms#"
(:name m)))))
(do
(when (:macro m)
(println "Macro"))
(println " " (:doc m)))))
(defn find-doc
"Prints documentation for any var whose documentation or na me
contains a match for re-string-or-pattern"
{:added "1.0"}
[re-string-or-pattern]
(let [re (re-pattern re-string-or-pattern)
ms (concat (mapcat
#(sort-by :name (map meta (vals (ns-interns %))))
(all-ns))
(map namespace-doc (all-ns))
(map special-doc (keys special-doc-map)))]
(doseq [m ms
:when (and (:doc m)
(or (re-find (re-matcher re (:doc m)))
(re-find (re-matcher re (str (:name m))))))]
(print-doc m))))
(defmacro doc
"Prints documentation for a var or special form given its nam e"
{:added "1.0"}
[name]
(if-let [special-name (’{& fn catch try finally try} name)]
(#’print-doc (#’special-doc special-name))
(cond
(special-doc-map name) ‘(#’print-doc (#’special-doc ’~n ame))
(resolve name) ‘(#’print-doc (meta (var ~name)))
(find-ns name) ‘(#’print-doc (namespace-doc (find-ns ’~n ame))))))
;; ------------------------------------------------- ---------------------
;; Examine Clojure functions (Vars, really)
(defn source-fn
1482 CHAPTER 11. CLJ/CLOJURE/
"Returns a string of the source code for the given symbol, if i t can
find it. This requires that the symbol resolve to a Var define d in
a namespace for which the .clj is in the classpath. Returns ni l if
it can’t find the source. For most REPL usage, ’source’ is mor e
convenient.
Example: (source-fn ’filter)"
[x]
(when-let [v (resolve x)]
(when-let [filepath (:file (meta v))]
(when-let [strm (.getResourceAsStream (RT/baseLoader) f ilepath)]
(with-open [rdr (LineNumberReader. (InputStreamReader. strm))]
(dotimes [_ (dec (:line (meta v)))] (.readLine rdr))
(let [text (StringBuilder.)
pbr (proxy [PushbackReader] [rdr]
(read [] (let [i (proxy-super read)]
(.append text (char i))
i)))]
(read (PushbackReader. pbr))
(str text)))))))
(defmacro source
"Prints the source code for the given symbol, if it can find it .
This requires that the symbol resolve to a Var defined in a
namespace for which the .clj is in the classpath.
Example: (source filter)"
[n]
‘(println (or (source-fn ’~n) (str "Source not found"))))
(defn apropos
"Given a regular expression or stringable thing, return a se q of
all definitions in all currently-loaded namespaces that ma tch the
str-or-pattern."
[str-or-pattern]
(let [matches? (if (instance? java.util.regex.Pattern st r-or-pattern)
#(re-find str-or-pattern (str %))
#(.contains (str %) (str str-or-pattern)))]
(mapcat (fn [ns]
(filter matches? (keys (ns-publics ns))))
(all-ns))))
(defn dir-fn
"Returns a sorted seq of symbols naming public vars in
a namespace"
[ns]
(sort (map first (ns-publics (the-ns ns)))))
(defmacro dir
"Prints a sorted directory of public vars in a namespace"
11.26. REPL.CLJ 1483
[nsname]
‘(doseq [v# (dir-fn ’~nsname)]
(println v#)))
(def ^:private demunge-map
(into {"$" "/"}
(map (fn [[k v]] [v k]) clojure.lang.Compiler/CHAR_MAP)))
(def ^:private demunge-pattern
(re-pattern (apply str (interpose "|" (map #(str "\\Q" % "\\ E")
(keys demunge-map))))))
(defn- re-replace [re s f]
(let [m (re-matcher re s)
mseq (take-while identity
(repeatedly #(when (re-find m)
[(re-groups m) (.start m) (.end m)])))]
(apply str
(concat
(mapcat (fn [[_ _ start] [groups end]]
(if end
[(subs s start end) (f groups)]
[(subs s start)]))
(cons [0 0 0] mseq)
(concat mseq [nil]))))))
(defn demunge
"Given a string representation of a fn class,
as in a stack trace element, returns a readable version."
{:added "1.3"}
[fn-name]
(re-replace demunge-pattern fn-name demunge-map))
(defn root-cause
"Returns the initial cause of an exception or error by peelin g off
all of its wrappers"
{:added "1.3"}
[^Throwable t]
(loop [cause t]
(if (and (instance? clojure.lang.Compiler$CompilerExce ption cause)
(not= (.source
^clojure.lang.Compiler$CompilerException cause)
"NO_SOURCE_FILE"))
cause
(if-let [cause (.getCause cause)]
(recur cause)
cause))))
(defn stack-element-str
"Returns a (possibly unmunged) string representation of a
1484 CHAPTER 11. CLJ/CLOJURE/
StackTraceElement"
{:added "1.3"}
[^StackTraceElement el]
(let [file (.getFileName el)
clojure-fn? (and file (or (.endsWith file ".clj")
(= file "NO_SOURCE_FILE")))]
(str (if clojure-fn?
(demunge (.getClassName el))
(str (.getClassName el) "." (.getMethodName el)))
" (" (.getFileName el) ":" (.getLineNumber el) ")")))
(defn pst
"Prints a stack trace of the exception, to the depth requeste d. If
none supplied, uses the root cause of the most recent repl
exception (*e), and a depth of 12."
{:added "1.3"}
([] (pst 12))
([e-or-depth]
(if (instance? Throwable e-or-depth)
(pst e-or-depth 12)
(when-let [e *e]
(pst (root-cause e) e-or-depth))))
([^Throwable e depth]
(binding [*out* *err*]
(println (str (-> e class .getSimpleName) " " (.getMessage e )))
(let [st (.getStackTrace e)
cause (.getCause e)]
(doseq [el (take depth
(remove
#(#{"clojure.lang.RestFn" "clojure.lang.AFn"}
(.getClassName %))
st))]
(println (str \tab (stack-element-str el))))
(when cause
(println "Caused by:")
(pst cause (min depth
(+ 2 (- (count (.getStackTrace cause))
(count st))))))))))
;; ------------------------------------------------- ---------------------
;; Handle Ctrl-C keystrokes
(defn thread-stopper
"Returns a function that takes one arg and uses that as an
exception message to stop the given thread. Defaults to the
current thread"
([] (thread-stopper (Thread/currentThread)))
([thread] (fn [msg] (.stop thread (Error. msg)))))
(defn set-break-handler!
11.27. SET.CLJ 1485
"Register INT signal handler. After calling this, Ctrl-C wi ll cause
the given function f to be called with a single argument, the s ignal.
Uses thread-stopper if no function given."
([] (set-break-handler! (thread-stopper)))
([f]
(sun.misc.Signal/handle
(sun.misc.Signal. "INT")
(proxy [sun.misc.SignalHandler] []
(handle [signal]
(f (str "-- caught signal " signal)))))))
———-
11.27 set.clj
— set.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "Set operations such as union/intersection."
:author "Rich Hickey"}
clojure.set)
(defn- bubble-max-key [k coll]
"Move a maximal element of coll according to fn k (which retur ns a
number) to the front of coll."
(let [max (apply max-key k coll)]
(cons max (remove #(identical? max %) coll))))
(defn union
"Return a set that is the union of the input sets"
{:added "1.0"}
([] #{})
([s1] s1)
([s1 s2]
(if (< (count s1) (count s2))
(reduce conj s2 s1)
(reduce conj s1 s2)))
([s1 s2 & sets]
(let [bubbled-sets (bubble-max-key count (conj sets s2 s1) )]
(reduce into (first bubbled-sets) (rest bubbled-sets)))) )
(defn intersection
"Return a set that is the intersection of the input sets"
{:added "1.0"}
([s1] s1)
([s1 s2]
1486 CHAPTER 11. CLJ/CLOJURE/
(if (< (count s2) (count s1))
(recur s2 s1)
(reduce (fn [result item]
(if (contains? s2 item)
result
(disj result item)))
s1 s1)))
([s1 s2 & sets]
(let [bubbled-sets
(bubble-max-key #(- (count %)) (conj sets s2 s1))]
(reduce intersection
(first bubbled-sets) (rest bubbled-sets)))))
(defn difference
"Return a set that is the first set without elements of the
remaining sets"
{:added "1.0"}
([s1] s1)
([s1 s2]
(if (< (count s1) (count s2))
(reduce (fn [result item]
(if (contains? s2 item)
(disj result item)
result))
s1 s1)
(reduce disj s1 s2)))
([s1 s2 & sets]
(reduce difference s1 (conj sets s2))))
(defn select
"Returns a set of the elements for which pred is true"
{:added "1.0"}
[pred xset]
(reduce (fn [s k] (if (pred k) s (disj s k)))
xset xset))
(defn project
"Returns a rel of the elements of xrel with only the keys in ks"
{:added "1.0"}
[xrel ks]
(set (map #(select-keys % ks) xrel)))
(defn rename-keys
"Returns the map with the keys in kmap renamed to the vals in km ap"
{:added "1.0"}
[map kmap]
(reduce
(fn [m [old new]]
(if (and (not= old new)
11.27. SET.CLJ 1487
(contains? m old))
(-> m (assoc new (get m old)) (dissoc old))
m))
map kmap))
(defn rename
"Returns a rel of the maps in xrel with the keys in kmap renamed
to the vals in kmap"
{:added "1.0"}
[xrel kmap]
(set (map #(rename-keys % kmap) xrel)))
(defn index
"Returns a map of the distinct values of ks in the xrel mapped t o a
set of the maps in xrel with the corresponding values of ks."
{:added "1.0"}
[xrel ks]
(reduce
(fn [m x]
(let [ik (select-keys x ks)]
(assoc m ik (conj (get m ik #{}) x))))
{} xrel))
(defn map-invert
"Returns the map with the vals mapped to the keys."
{:added "1.0"}
[m] (reduce (fn [m [k v]] (assoc m v k)) {} m))
(defn join
"When passed 2 rels, returns the rel corresponding to the nat ural
join. When passed an additional keymap, joins on the corresp onding
keys."
{:added "1.0"}
([xrel yrel] ;natural join
(if (and (seq xrel) (seq yrel))
(let [ks (intersection (set (keys (first xrel)))
(set (keys (first yrel))))
[r s] (if (<= (count xrel) (count yrel))
[xrel yrel]
[yrel xrel])
idx (index r ks)]
(reduce (fn [ret x]
(let [found (idx (select-keys x ks))]
(if found
(reduce #(conj %1 (merge %2 x)) ret found)
ret)))
#{} s))
#{}))
([xrel yrel km] ;arbitrary key mapping
(let [[r s k] (if (<= (count xrel) (count yrel))
1488 CHAPTER 11. CLJ/CLOJURE/
[xrel yrel (map-invert km)]
[yrel xrel km])
idx (index r (vals k))]
(reduce (fn [ret x]
(let [found
(idx (rename-keys (select-keys x (keys k)) k))]
(if found
(reduce #(conj %1 (merge %2 x)) ret found)
ret)))
#{} s))))
(defn subset?
"Is set1 a subset of set2?"
{:added "1.2",
:tag Boolean}
[set1 set2]
(and (<= (count set1) (count set2))
(every? #(contains? set2 %) set1)))
(defn superset?
"Is set1 a superset of set2?"
{:added "1.2",
:tag Boolean}
[set1 set2]
(and (>= (count set1) (count set2))
(every? #(contains? set1 %) set2)))
(comment
(refer ’set)
(def xs #{{:a 11 :b 1 :c 1 :d 4}
{:a 2 :b 12 :c 2 :d 6}
{:a 3 :b 3 :c 3 :d 8 :f 42}})
(def ys #{{:a 11 :b 11 :c 11 :e 5}
{:a 12 :b 11 :c 12 :e 3}
{:a 3 :b 3 :c 3 :e 7 }})
(join xs ys)
(join xs (rename ys {:b :yb :c :yc}) {:a :a})
(union #{:a :b :c} #{:c :d :e })
(difference #{:a :b :c} #{:c :d :e})
(intersection #{:a :b :c} #{:c :d :e})
(index ys [:b])
)
———-
11.28. STACKTRACE.CLJ 1489
11.28 stacktrace.clj
— stacktrace.clj —
\getchunk{Clojure Copyright}
;;; stacktrace.clj: print Clojure-centric stack traces
;; by Stuart Sierra
;; January 6, 2009
(ns ^{:doc "Print stack traces oriented towards Clojure, no t Java."
:author "Stuart Sierra"}
clojure.stacktrace)
(defn root-cause
"Returns the last ’cause’ Throwable in a chain of Throwables ."
{:added "1.1"}
[tr]
(if-let [cause (.getCause tr)]
(recur cause)
tr))
(defn print-trace-element
"Prints a Clojure-oriented view of one element in a stack tra ce."
{:added "1.1"}
[e]
(let [class (.getClassName e)
method (.getMethodName e)]
(let [match (re-matches #"^([A-Za-z0-9_.-]+)\$(\w+)__\ d+$"
(str class))]
(if (and match (= "invoke" method))
(apply printf "%s/%s" (rest match))
(printf "%s.%s" class method))))
(printf " (%s:%d)" (or (.getFileName e) "") (.getLineNumbe r e)))
(defn print-throwable
"Prints the class and message of a Throwable."
{:added "1.1"}
[tr]
(printf "%s: %s" (.getName (class tr)) (.getMessage tr)))
(defn print-stack-trace
"Prints a Clojure-oriented stack trace of tr, a Throwable.
Prints a maximum of n stack frames (default: unlimited).
Does not print chained exceptions (causes)."
{:added "1.1"}
([tr] (print-stack-trace tr nil))
1490 CHAPTER 11. CLJ/CLOJURE/
([tr n]
(let [st (.getStackTrace tr)]
(print-throwable tr)
(newline)
(print " at ")
(print-trace-element (first st))
(newline)
(doseq [e (if (nil? n)
(rest st)
(take (dec n) (rest st)))]
(print " ")
(print-trace-element e)
(newline)))))
(defn print-cause-trace
"Like print-stack-trace but prints chained exceptions (ca uses)."
{:added "1.1"}
([tr] (print-cause-trace tr nil))
([tr n]
(print-stack-trace tr n)
(when-let [cause (.getCause tr)]
(print "Caused by: " )
(recur cause n))))
(defn e
"REPL utility. Prints a brief stack trace for the root cause o f the
most recent exception."
{:added "1.1"}
[]
(print-stack-trace (root-cause *e) 8))
———-
11.29 string.clj
— string.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "Clojure String utilities
It is poor form to (:use clojure.string). Instead, use requi re
with :as to specify a prefix, e.g.
(ns your.namespace.here
(:require [clojure.string :as str]))
11.29. STRING.CLJ 1491
Design notes for clojure.string:
1. Strings are objects (as opposed to sequences). As such, th e
string being manipulated is the first argument to a function ;
passing nil will result in a NullPointerException unless
documented otherwise. If you want sequence-y behavior inst ead,
use a sequence.
2. Functions are generally not lazy, and call straight to hos t
methods where those are available and efficient.
3. Functions take advantage of String implementation detai ls to
write high-performing loop/recurs instead of using higher -order
functions. (This is not idiomatic in general-purpose appli cation
code.)
4. When a function is documented to accept a string argument, it
will take any implementation of the correct *interface* on t he
host platform. In Java, this is CharSequence, which is more
general than String. In ordinary usage you will almost alway s
pass concrete strings. If you are doing something unusual,
e.g. passing a mutable implementation of CharSequence, the n
thead-safety is your responsibility."
:author "Stuart Sierra, Stuart Halloway, David Liebke"}
clojure.string
(:refer-clojure :exclude (replace reverse))
(:import (java.util.regex Pattern)
clojure.lang.LazilyPersistentVector))
(defn ^String reverse
"Returns s with its characters reversed."
{:added "1.2"}
[^CharSequence s]
(.toString (.reverse (StringBuilder. s))))
(defn- replace-by
[^CharSequence s re f]
(let [m (re-matcher re s)]
(let [buffer (StringBuffer. (.length s))]
(loop []
(if (.find m)
(do (.appendReplacement m buffer (f (re-groups m)))
(recur))
(do (.appendTail m buffer)
(.toString buffer)))))))
(defn ^String replace
"Replaces all instance of match with replacement in s.
match/replacement can be:
1492 CHAPTER 11. CLJ/CLOJURE/
string / string
char / char
pattern / (string or function of match).
See also replace-first."
{:added "1.2"}
[^CharSequence s match replacement]
(let [s (.toString s)]
(cond
(instance? Character match)
(.replace s ^Character match ^Character replacement)
(instance? CharSequence match)
(.replace s ^CharSequence match ^CharSequence replacemen t)
(instance? Pattern match)
(if (instance? CharSequence replacement)
(.replaceAll (re-matcher ^Pattern match s)
(.toString ^CharSequence replacement))
(replace-by s match replacement))
:else (throw (IllegalArgumentException.
(str "Invalid match arg: " match))))))
(defn- replace-first-by
[^CharSequence s ^Pattern re f]
(let [m (re-matcher re s)]
(let [buffer (StringBuffer. (.length s))]
(if (.find m)
(let [rep (f (re-groups m))]
(.appendReplacement m buffer rep)
(.appendTail m buffer)
(str buffer))))))
(defn- replace-first-char
[^CharSequence s ^Character match replace]
(let [s (.toString s)
i (.indexOf s (int match))]
(if (= -1 i)
s
(str (subs s 0 i) replace (subs s (inc i))))))
(defn ^String replace-first
"Replaces the first instance of match with replacement in s.
match/replacement can be:
char / char
string / string
pattern / (string or function of match).
See also replace-all."
11.29. STRING.CLJ 1493
{:added "1.2"}
[^CharSequence s match replacement]
(let [s (.toString s)]
(cond
(instance? Character match)
(replace-first-char s match replacement)
(instance? CharSequence match)
(.replaceFirst s (Pattern/quote (.toString ^CharSequenc e match))
(.toString ^CharSequence replacement))
(instance? Pattern match)
(if (instance? CharSequence replacement)
(.replaceFirst (re-matcher ^Pattern match s)
(.toString ^CharSequence replacement))
(replace-first-by s match replacement))
:else (throw (IllegalArgumentException.
(str "Invalid match arg: " match))))))
(defn ^String join
"Returns a string of all elements in coll, as returned by (seq coll),
separated by an optional separator."
{:added "1.2"}
([coll]
(apply str coll))
([separator coll]
(loop [sb (StringBuilder. (str (first coll)))
more (next coll)
sep (str separator)]
(if more
(recur (-> sb (.append sep) (.append (str (first more))))
(next more)
sep)
(str sb)))))
(defn ^String capitalize
"Converts first character of the string to upper-case, all o ther
characters to lower-case."
{:added "1.2"}
[^CharSequence s]
(let [s (.toString s)]
(if (< (count s) 2)
(.toUpperCase s)
(str (.toUpperCase (subs s 0 1))
(.toLowerCase (subs s 1))))))
(defn ^String upper-case
"Converts string to all upper-case."
{:added "1.2"}
[^CharSequence s]
(.. s toString toUpperCase))
1494 CHAPTER 11. CLJ/CLOJURE/
(defn ^String lower-case
"Converts string to all lower-case."
{:added "1.2"}
[^CharSequence s]
(.. s toString toLowerCase))
(defn split
"Splits string on a regular expression. Optional argument l imit is
the maximum number of splits. Not lazy. Returns vector of the splits."
{:added "1.2"}
([^CharSequence s ^Pattern re]
(LazilyPersistentVector/createOwning (.split re s)))
([ ^CharSequence s ^Pattern re limit]
(LazilyPersistentVector/createOwning (.split re s limit ))))
(defn split-lines
"Splits s on \\n or \\r\\n."
{:added "1.2"}
[^CharSequence s]
(split s #"\r?\n"))
(defn ^String trim
"Removes whitespace from both ends of string."
{:added "1.2"}
[^CharSequence s]
(.. s toString trim))
(defn ^String triml
"Removes whitespace from the left side of string."
{:added "1.2"}
[^CharSequence s]
(loop [index (int 0)]
(if (= (.length s) index)
""
(if (Character/isWhitespace (.charAt s index))
(recur (inc index))
(.. s (subSequence index (.length s)) toString)))))
(defn ^String trimr
"Removes whitespace from the right side of string."
{:added "1.2"}
[^CharSequence s]
(loop [index (.length s)]
(if (zero? index)
""
(if (Character/isWhitespace (.charAt s (dec index)))
(recur (dec index))
(.. s (subSequence 0 index) toString)))))
11.29. STRING.CLJ 1495
(defn ^String trim-newline
"Removes all trailing newline \\n or return \\r characters f rom
string. Similar to Perl’s chomp."
{:added "1.2"}
[^CharSequence s]
(loop [index (.length s)]
(if (zero? index)
""
(let [ch (.charAt s (dec index))]
(if (or (= ch \newline) (= ch \return))
(recur (dec index))
(.. s (subSequence 0 index) toString))))))
(defn blank?
"True if s is nil, empty, or contains only whitespace."
{:added "1.2"}
[^CharSequence s]
(if s
(loop [index (int 0)]
(if (= (.length s) index)
true
(if (Character/isWhitespace (.charAt s index))
(recur (inc index))
false)))
true))
(defn ^String escape
"Return a new string, using cmap to escape each character ch
from s as follows:
If (cmap ch) is nil, append ch to the new string.
If (cmap ch) is non-nil, append (str (cmap ch)) instead."
{:added "1.2"}
[^CharSequence s cmap]
(loop [index (int 0)
buffer (StringBuilder. (.length s))]
(if (= (.length s) index)
(.toString buffer)
(let [ch (.charAt s index)]
(if-let [replacement (cmap ch)]
(.append buffer replacement)
(.append buffer ch))
(recur (inc index) buffer)))))
———-
1496 CHAPTER 11. CLJ/CLOJURE/
11.30 template.clj
— template.clj —
\getchunk{Clojure Copyright}
;;; template.clj - anonymous functions that pre-evaluate s ub-expressions
;; By Stuart Sierra
;; June 23, 2009
;; CHANGE LOG
;;
;; June 23, 2009: complete rewrite, eliminated _1,_2,... ar gument
;; syntax
;;
;; January 20, 2009: added "template?" and checks for valid t emplate
;; expressions.
;;
;; December 15, 2008: first version
(ns ^{:doc "Macros that expand to repeated copies of a
template expression."
:author "Stuart Sierra"}
clojure.template
(:require [clojure.walk :as walk]))
(defn apply-template
"For use in macros. argv is an argument list, as in defn. expr i s
a quoted expression using the symbols in argv. values is a seq uence
of values to be used for the arguments.
apply-template will recursively replace argument symbols in expr
with their corresponding values, returning a modified expr .
Example: (apply-template ’[x] ’(+ x x) ’[2])
;=> (+ 2 2)"
[argv expr values]
(assert (vector? argv))
(assert (every? symbol? argv))
(walk/prewalk-replace (zipmap argv values) expr))
(defmacro do-template
"Repeatedly copies expr (in a do block) for each group of argu ments
in values. values are automatically partitioned by the numb er of
arguments in argv, an argument vector as in defn.
11.31. JUNIT.CLJ 1497
Example: (macroexpand ’(do-template [x y] (+ y x) 2 4 3 5))
;=> (do (+ 4 2) (+ 5 3))"
[argv expr & values]
(let [c (count argv)]
‘(do ~@(map (fn [a] (apply-template argv expr a))
(partition c values)))))
———-
11.31 junit.clj
— junit.clj —
\getchunk{Clojure Copyright}
;; test/junit.clj: Extension to clojure.test for JUnit-co mpatible
;; XML output
;; by Jason Sankey
;; June 2009
;; DOCUMENTATION
;;
(ns ^{:doc "clojure.test extension for JUnit-compatible X ML output.
JUnit (http://junit.org/) is the most popular unit-testin g library
for Java. As such, tool support for JUnit output formats is
common. By producing compatible output from tests, this too l
support can be exploited.
To use, wrap any calls to clojure.test/run-tests in the
with-junit-output macro, like this:
(use ’clojure.test)
(use ’clojure.test.junit)
(with-junit-output
(run-tests ’my.cool.library))
To write the output to a file, rebind clojure.test/*test-ou t* to
your own PrintWriter (perhaps opened using
clojure.java.io/writer)."
:author "Jason Sankey"}
clojure.test.junit
(:require [clojure.stacktrace :as stack]
[clojure.test :as t]))
1498 CHAPTER 11. CLJ/CLOJURE/
;; copied from clojure.contrib.lazy-xml
(def ^{:private true}
escape-xml-map
(zipmap "’<>\"&" (map #(str \& % \;) ’[apos lt gt quot amp])))
(defn- escape-xml [text]
(apply str (map #(escape-xml-map % %) text)))
(def ^:dynamic *var-context*)
(def ^:dynamic *depth*)
(defn indent
[]
(dotimes [n (* *depth* 4)] (print " ")))
(defn start-element
[tag pretty & [attrs]]
(if pretty (indent))
(print (str "<" tag))
(if (seq attrs)
(doseq [[key value] attrs]
(print (str " " (name key) "=\"" (escape-xml value) "\""))))
(print ">")
(if pretty (println))
(set! *depth* (inc *depth*)))
(defn element-content
[content]
(print (escape-xml content)))
(defn finish-element
[tag pretty]
(set! *depth* (dec *depth*))
(if pretty (indent))
(print (str "</" tag ">"))
(if pretty (println)))
(defn test-name
[vars]
(apply str (interpose "."
(reverse (map #(:name (meta %)) vars)))))
(defn package-class
[name]
(let [i (.lastIndexOf name ".")]
(if (< i 0)
[nil name]
[(.substring name 0 i) (.substring name (+ i 1))])))
(defn start-case
11.31. JUNIT.CLJ 1499
[name classname]
(start-element ’testcase true {:name name :classname clas sname}))
(defn finish-case
[]
(finish-element ’testcase true))
(defn suite-attrs
[package classname]
(let [attrs {:name classname}]
(if package
(assoc attrs :package package)
attrs)))
(defn start-suite
[name]
(let [[package classname] (package-class name)]
(start-element ’testsuite true (suite-attrs package clas sname))))
(defn finish-suite
[]
(finish-element ’testsuite true))
(defn message-el
[tag message expected-str actual-str]
(indent)
(start-element tag false (if message {:message message} {} ))
(element-content
(let [[file line] (t/file-position 5)
detail (apply str (interpose
"\n"
[(str "expected: " expected-str)
(str " actual: " actual-str)
(str " at: " file ":" line)]))]
(if message (str message "\n" detail) detail)))
(finish-element tag false)
(println))
(defn failure-el
[message expected actual]
(message-el ’failure message (pr-str expected) (pr-str ac tual)))
(defn error-el
[message expected actual]
(message-el ’error
message
(pr-str expected)
(if (instance? Throwable actual)
(with-out-str
(stack/print-cause-trace actual
1500 CHAPTER 11. CLJ/CLOJURE/
t/*stack-trace-depth*))
(prn actual))))
;; This multimethod will override test-is/report
(defmulti junit-report :type)
(defmethod junit-report :begin-test-ns [m]
(t/with-test-out
(start-suite (name (ns-name (:ns m))))))
(defmethod junit-report :end-test-ns [_]
(t/with-test-out
(finish-suite)))
(defmethod junit-report :begin-test-var [m]
(t/with-test-out
(let [var (:var m)]
(binding [*var-context* (conj *var-context* var)]
(start-case
(test-name *var-context*)
(name (ns-name (:ns (meta var)))))))))
(defmethod junit-report :end-test-var [m]
(t/with-test-out
(finish-case)))
(defmethod junit-report :pass [m]
(t/with-test-out
(t/inc-report-counter :pass)))
(defmethod junit-report :fail [m]
(t/with-test-out
(t/inc-report-counter :fail)
(failure-el (:message m)
(:expected m)
(:actual m))))
(defmethod junit-report :error [m]
(t/with-test-out
(t/inc-report-counter :error)
(error-el (:message m)
(:expected m)
(:actual m))))
(defmethod junit-report :default [_])
(defmacro with-junit-output
"Execute body with modified test-is reporting functions th at write
JUnit-compatible XML output."
{:added "1.1"}
11.32. TAP.CLJ 1501
[& body]
‘(binding [t/report junit-report
*var-context* (list)
*depth* 1]
(t/with-test-out
(println "<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
(println "<testsuites>"))
(let [result# ~@body]
(t/with-test-out (println "</testsuites>"))
result#)))
———-
11.32 tap.clj
— tap.clj —
\getchunk{Clojure Copyright}
;;; test_is/tap.clj: Extension to test for TAP output
;; by Stuart Sierra
;; March 31, 2009
;; Inspired by ClojureCheck by Meikel Brandmeyer:
;; http://kotka.de/projects/clojure/clojurecheck.htm l
;; DOCUMENTATION
;;
(ns ^{:doc "clojure.test extensions for the Test Anything P rotocol (TAP)
TAP is a simple text-based syntax for reporting test results . TAP
was originally develped for Perl, and now has implementatio ns in
several languages. For more information on TAP, see
http://testanything.org/ and
http://search.cpan.org/~petdance/TAP-1.0.0/TAP.pm
To use this library, wrap any calls to
clojure.test/run-tests in the with-tap-output macro,
like this:
(use ’clojure.test)
(use ’clojure.test.tap)
1502 CHAPTER 11. CLJ/CLOJURE/
(with-tap-output
(run-tests ’my.cool.library))"
:author "Stuart Sierra"}
clojure.test.tap
(:require [clojure.test :as t]
[clojure.stacktrace :as stack]))
(defn print-tap-plan
"Prints a TAP plan line like ’1..n’. n is the number of tests"
{:added "1.1"}
[n]
(println (str "1.." n)))
(defn print-tap-diagnostic
"Prints a TAP diagnostic line. data is a (possibly multi-lin e)
string."
{:added "1.1"}
[data]
(doseq [line (.split ^String data "\n")]
(println "#" line)))
(defn print-tap-pass
"Prints a TAP ’ok’ line. msg is a string, with no line breaks"
{:added "1.1"}
[msg]
(println "ok" msg))
(defn print-tap-fail
"Prints a TAP ’not ok’ line. msg is a string, with no line break s"
{:added "1.1"}
[msg]
(println "not ok" msg))
;; This multimethod will override test/report
(defmulti tap-report (fn [data] (:type data)))
(defmethod tap-report :default [data]
(t/with-test-out
(print-tap-diagnostic (pr-str data))))
(defmethod tap-report :pass [data]
(t/with-test-out
(t/inc-report-counter :pass)
(print-tap-pass (t/testing-vars-str))
(when (seq t/*testing-contexts*)
(print-tap-diagnostic (t/testing-contexts-str)))
(when (:message data)
(print-tap-diagnostic (:message data)))
(print-tap-diagnostic (str "expected:" (pr-str (:expect ed data))))
11.33. TEST.CLJ 1503
(print-tap-diagnostic (str " actual:" (pr-str (:actual da ta))))))
(defmethod tap-report :error [data]
(t/with-test-out
(t/inc-report-counter :error)
(print-tap-fail (t/testing-vars-str))
(when (seq t/*testing-contexts*)
(print-tap-diagnostic (t/testing-contexts-str)))
(when (:message data)
(print-tap-diagnostic (:message data)))
(print-tap-diagnostic "expected:" (pr-str (:expected da ta)))
(print-tap-diagnostic " actual: ")
(print-tap-diagnostic
(with-out-str
(if (instance? Throwable (:actual data))
(stack/print-cause-trace (:actual data) t/*stack-trace -depth*)
(prn (:actual data)))))))
(defmethod tap-report :summary [data]
(t/with-test-out
(print-tap-plan (+ (:pass data) (:fail data) (:error data) ))))
(defmacro with-tap-output
"Execute body with modified test reporting functions that p roduce
TAP output"
{:added "1.1"}
[& body]
‘(binding [t/report tap-report]
~@body))
———-
11.33 test.clj
— test.clj —
\getchunk{Clojure Copyright}
;;; test.clj: test framework for Clojure
;; by Stuart Sierra
;; March 28, 2009
;; Thanks to Chas Emerick, Allen Rohner, and Stuart Halloway for
;; contributions and suggestions.
1504 CHAPTER 11. CLJ/CLOJURE/
(ns
^{:author "Stuart Sierra, with contributions and suggesti ons by
Chas Emerick, Allen Rohner, and Stuart Halloway",
:doc "A unit testing framework.
ASSERTIONS
The core of the library is the \"is\" macro, which lets you mak e
assertions of any arbitrary expression:
(is (= 4 (+ 2 2)))
(is (instance? Integer 256))
(is (.startsWith \"abcde\" \"ab\"))
You can type an \"is\" expression directly at the REPL, which will
print a message if it fails.
user> (is (= 5 (+ 2 2)))
FAIL in (:1)
expected: (= 5 (+ 2 2))
actual: (not (= 5 4))
false
The \"expected:\" line shows you the original expression, a nd the
\"actual:\" shows you what actually happened. In this case, it
shows that (+ 2 2) returned 4, which is not = to 5. Finally, the
\"false\" on the last line is the value returned from the
expression. The \"is\" macro always returns the result of th e
inner expression.
There are two special assertions for testing exceptions. Th e
\"(is (thrown? c ...))\" form tests if an exception of class c is
thrown:
(is (thrown? ArithmeticException (/ 1 0)))
\"(is (thrown-with-msg? c re ...))\" does the same thing and also
tests that the message on the exception matches the regular
expression re:
(is (thrown-with-msg? ArithmeticException #\"Divide by z ero\"
(/ 1 0)))
DOCUMENTING TESTS
\"is\" takes an optional second argument, a string describi ng the
assertion. This message will be included in the error report .
(is (= 5 (+ 2 2)) \"Crazy arithmetic\")
11.33. TEST.CLJ 1505
In addition, you can document groups of assertions with the
\"testing\" macro, which takes a string followed by any numb er of
assertions. The string will be included in failure reports.
Calls to \"testing\" may be nested, and all of the strings wil l be
joined together with spaces in the final report, in a style
similar to RSpec <http://rspec.info/>
(testing \"Arithmetic\"
(testing \"with positive integers\"
(is (= 4 (+ 2 2)))
(is (= 7 (+ 3 4))))
(testing \"with negative integers\"
(is (= -4 (+ -2 -2)))
(is (= -1 (+ 3 -4)))))
Note that, unlike RSpec, the \"testing\" macro may only be us ed
INSIDE a \"deftest\" or \"with-test\" form (see below).
DEFINING TESTS
There are two ways to define tests. The \"with-test\" macro t akes
a defn or def form as its first argument, followed by any numbe r
of assertions. The tests will be stored as metadata on the
definition.
(with-test
(defn my-function [x y]
(+ x y))
(is (= 4 (my-function 2 2)))
(is (= 7 (my-function 3 4))))
As of Clojure SVN rev. 1221, this does not work with defmacro.
See http://code.google.com/p/clojure/issues/detail?i d=51
The other way lets you define tests separately from the rest o f
your code, even in a different namespace:
(deftest addition
(is (= 4 (+ 2 2)))
(is (= 7 (+ 3 4))))
(deftest subtraction
(is (= 1 (- 4 3)))
(is (= 3 (- 7 4))))
This creates functions named \"addition\" and \"subtracti on\", which
can be called like any other function. Therefore, tests can b e
grouped and composed, in a style similar to the test framewor k in
1506 CHAPTER 11. CLJ/CLOJURE/
Peter Seibel’s \"Practical Common Lisp\"
<http://www.gigamonkeys.com/book/
practical-building-a-unit-test-framework.html>
(deftest arithmetic
(addition)
(subtraction))
The names of the nested tests will be joined in a list, like
\"(arithmetic addition)\", in failure reports. You can use nested
tests to set up a context shared by several tests.
RUNNING TESTS
Run tests with the function \"(run-tests namespaces...)\" :
(run-tests ’your.namespace ’some.other.namespace)
If you don’t specify any namespaces, the current namespace i s
used. To run all tests in all namespaces, use \"(run-all-tes ts)\".
By default, these functions will search for all tests define d in
a namespace and run them in an undefined order. However, if yo u
are composing tests, as in the \"arithmetic\" example above , you
probably do not want the \"addition\" and \"subtraction\" t ests run
separately. In that case, you must define a special function
named \"test-ns-hook\" that runs your tests in the correct o rder:
(defn test-ns-hook []
(arithmetic))
Note: test-ns-hook prevents execution of fixtures (see bel ow).
OMITTING TESTS FROM PRODUCTION CODE
You can bind the variable \"*load-tests*\" to false when loa ding or
compiling code in production. This will prevent any tests fr om
being created by \"with-test\" or \"deftest\".
FIXTURES
Fixtures allow you to run code before and after tests, to set u p
the context in which tests should be run.
A fixture is just a function that calls another function pass ed as
an argument. It looks like this:
11.33. TEST.CLJ 1507
(defn my-fixture [f]
Perform setup, establish bindings, whatever.
(f) Then call the function we were passed.
Tear-down / clean-up code here.
)
Fixtures are attached to namespaces in one of two ways. \"eac h\"
fixtures are run repeatedly, once for each test function cre ated
with \"deftest\" or \"with-test\". \"each\" fixtures are u seful for
establishing a consistent before/after state for each test , like
clearing out database tables.
\"each\" fixtures can be attached to the current namespace l ike this:
(use-fixtures :each fixture1 fixture2 ...)
The fixture1, fixture2 are just functions like the example a bove.
They can also be anonymous functions, like this:
(use-fixtures :each (fn [f] setup... (f) cleanup...))
The other kind of fixture, a \"once\" fixture, is only run onc e,
around ALL the tests in the namespace. \"once\" fixtures are useful
for tasks that only need to be performed once, like establish ing
database connections, or for time-consuming tasks.
Attach \"once\" fixtures to the current namespace like this :
(use-fixtures :once fixture1 fixture2 ...)
Note: Fixtures and test-ns-hook are mutually incompatible . If you
are using test-ns-hook, fixture functions will *never* be r un.
SAVING TEST OUTPUT TO A FILE
All the test reporting functions write to the var *test-out* . By
default, this is the same as *out*, but you can rebind it to any
PrintWriter. For example, it could be a file opened with
clojure.java.io/writer.
EXTENDING TEST-IS (ADVANCED)
You can extend the behavior of the \"is\" macro by defining ne w
methods for the \"assert-expr\" multimethod. These method s are
called during expansion of the \"is\" macro, so they should r eturn
quoted forms to be evaluated.
You can plug in your own test-reporting framework by rebindi ng
the \"report\" function: (report event)
The ’event’ argument is a map. It will always have a :type key,
whose value will be a keyword signaling the type of event bein g
1508 CHAPTER 11. CLJ/CLOJURE/
reported. Standard events with :type value of :pass, :fail, and
:error are called when an assertion passes, fails, and throw s an
exception, respectively. In that case, the event will also h ave
the following keys:
:expected The form that was expected to be true
:actual A form representing what actually occurred
:message The string message given as an argument to ’is’
The \"testing\" strings will be a list in \"*testing-contex ts*\", and
the vars being tested will be a list in \"*testing-vars*\".
Your \"report\" function should wrap any printing calls in t he
\"with-test-out\" macro, which rebinds *out* to the curren t value
of *test-out*.
For additional event types, see the examples in the code.
"}
clojure.test
(:require [clojure.template :as temp]
[clojure.stacktrace :as stack]))
;; Nothing is marked "private" here, so you can rebind things to plug
;; in your own testing or reporting frameworks.
;;; USER-MODIFIABLE GLOBALS
(defonce ^:dynamic
^{:doc "True by default. If set to false, no test functions wi ll
be created by deftest, set-test, or with-test. Use this to om it
tests when compiling or loading production code."
:added "1.1"}
*load-tests* true)
(def ^:dynamic
^{:doc "The maximum depth of stack traces to print when an Exc eption
is thrown during a test. Defaults to nil, which means print th e
complete stack trace."
:added "1.1"}
*stack-trace-depth* nil)
;;; GLOBALS USED BY THE REPORTING FUNCTIONS
; bound to a ref of a map in test-ns
(def ^:dynamic *report-counters* nil)
; used to initialize *report-counters*
(def ^:dynamic *initial-report-counters*
11.33. TEST.CLJ 1509
{:test 0, :pass 0, :fail 0, :error 0})
; bound to hierarchy of vars being tested
(def ^:dynamic *testing-vars* (list))
; bound to hierarchy of "testing" strings
(def ^:dynamic *testing-contexts* (list))
; PrintWriter for test reporting output
(def ^:dynamic *test-out* *out*)
(defmacro with-test-out
"Runs body with *out* bound to the value of *test-out*."
{:added "1.1"}
[& body]
‘(binding [*out* *test-out*]
~@body))
;;; UTILITIES FOR REPORTING FUNCTIONS
(defn file-position
"Returns a vector [filename line-number] for the nth call up the
stack.
Deprecated in 1.2: The information needed for test reportin g is
now on :file and :line keys in the result map."
{:added "1.1"
:deprecated "1.2"}
[n]
(let [^StackTraceElement s
(nth (.getStackTrace (new java.lang.Throwable)) n)]
[(.getFileName s) (.getLineNumber s)]))
(defn testing-vars-str
"Returns a string representation of the current test. Rende rs names
in *testing-vars* as a list, then the source file and line of
current assertion."
{:added "1.1"}
[m]
(let [{:keys [file line]} m]
(str
;; Uncomment to include namespace in failure report:
;;(ns-name (:ns (meta (first *testing-vars*)))) "/ "
(reverse (map #(:name (meta %)) *testing-vars*))
" (" file ":" line ")")))
(defn testing-contexts-str
"Returns a string representation of the current test contex t. Joins
strings in *testing-contexts* with spaces."
{:added "1.1"}
1510 CHAPTER 11. CLJ/CLOJURE/
[]
(apply str (interpose " " (reverse *testing-contexts*))))
(defn inc-report-counter
"Increments the named counter in *report-counters*, a ref t o a map.
Does nothing if *report-counters* is nil."
{:added "1.1"}
[name]
(when *report-counters*
(dosync (commute *report-counters* assoc name
(inc (or (*report-counters* name) 0))))))
;;; TEST RESULT REPORTING
(defmulti
^{:doc "Generic reporting function, may be overridden to pl ug in
different report formats (e.g., TAP, JUnit). Assertions su ch as
’is’ call ’report’ to indicate results. The argument given t o
’report’ will be a map with a :type key. See the documentation at
the top of test_is.clj for more information on the types of
arguments for ’report’."
:dynamic true
:added "1.1"}
report :type)
(defn- file-and-line
[exception depth]
(let [^StackTraceElement s (nth (.getStackTrace exceptio n) depth)]
{:file (.getFileName s) :line (.getLineNumber s)}))
(defn do-report
"Add file and line information to a test result and call repor t.
If you are writing a custom assert-expr method, call this fun ction
to pass test results to report."
{:added "1.2"}
[m]
(report
(case
(:type m)
:fail (merge (file-and-line (new java.lang.Throwable) 1) m)
:error (merge (file-and-line (:actual m) 0) m)
m)))
(defmethod report :default [m]
(with-test-out (prn m)))
(defmethod report :pass [m]
(with-test-out (inc-report-counter :pass)))
(defmethod report :fail [m]
11.33. TEST.CLJ 1511
(with-test-out
(inc-report-counter :fail)
(println "\nFAIL in" (testing-vars-str m))
(when (seq *testing-contexts*) (println (testing-contex ts-str)))
(when-let [message (:message m)] (println message))
(println "expected:" (pr-str (:expected m)))
(println " actual:" (pr-str (:actual m)))))
(defmethod report :error [m]
(with-test-out
(inc-report-counter :error)
(println "\nERROR in" (testing-vars-str m))
(when (seq *testing-contexts*) (println (testing-contex ts-str)))
(when-let [message (:message m)] (println message))
(println "expected:" (pr-str (:expected m)))
(print " actual: ")
(let [actual (:actual m)]
(if (instance? Throwable actual)
(stack/print-cause-trace actual *stack-trace-depth*)
(prn actual)))))
(defmethod report :summary [m]
(with-test-out
(println "\nRan" (:test m) "tests containing"
(+ (:pass m) (:fail m) (:error m)) "assertions.")
(println (:fail m) "failures," (:error m) "errors.")))
(defmethod report :begin-test-ns [m]
(with-test-out
(println "\nTesting" (ns-name (:ns m)))))
;; Ignore these message types:
(defmethod report :end-test-ns [m])
(defmethod report :begin-test-var [m])
(defmethod report :end-test-var [m])
;;; UTILITIES FOR ASSERTIONS
(defn get-possibly-unbound-var
"Like var-get but returns nil if the var is unbound."
{:added "1.1"}
[v]
(try (var-get v)
(catch IllegalStateException e
nil)))
(defn function?
"Returns true if argument is a function or a symbol that resol ves to
1512 CHAPTER 11. CLJ/CLOJURE/
a function (not a macro)."
{:added "1.1"}
[x]
(if (symbol? x)
(when-let [v (resolve x)]
(when-let [value (get-possibly-unbound-var v)]
(and (fn? value)
(not (:macro (meta v))))))
(fn? x)))
(defn assert-predicate
"Returns generic assertion code for any functional predica te. The
’expected’ argument to ’report’ will contains the original form, the
’actual’ argument will contain the form with all its sub-for ms
evaluated. If the predicate returns false, the ’actual’ for m will
be wrapped in (not...)."
{:added "1.1"}
[msg form]
(let [args (rest form)
pred (first form)]
‘(let [values# (list ~@args)
result# (apply ~pred values#)]
(if result#
(do-report {:type :pass, :message ~msg,
:expected ’~form, :actual (cons ~pred values#)})
(do-report {:type :fail, :message ~msg,
:expected ’~form,
:actual (list ’~’not (cons ’~pred values#))}))
result#)))
(defn assert-any
"Returns generic assertion code for any test, including mac ros, Java
method calls, or isolated symbols."
{:added "1.1"}
[msg form]
‘(let [value# ~form]
(if value#
(do-report {:type :pass, :message ~msg,
:expected ’~form, :actual value#})
(do-report {:type :fail, :message ~msg,
:expected ’~form, :actual value#}))
value#))
;;; ASSERTION METHODS
;; You don’t call these, but you can add methods to extend the ’ is’
;; macro. These define different kinds of tests, based on the first
;; symbol in the test expression.
11.33. TEST.CLJ 1513
(defmulti assert-expr
(fn [msg form]
(cond
(nil? form) :always-fail
(seq? form) (first form)
:else :default)))
(defmethod assert-expr :always-fail [msg form]
;; nil test: always fail
‘(do-report {:type :fail, :message ~msg}))
(defmethod assert-expr :default [msg form]
(if (and (sequential? form) (function? (first form)))
(assert-predicate msg form)
(assert-any msg form)))
(defmethod assert-expr ’instance? [msg form]
;; Test if x is an instance of y.
‘(let [klass# ~(nth form 1)
object# ~(nth form 2)]
(let [result# (instance? klass# object#)]
(if result#
(do-report {:type :pass, :message ~msg,
:expected ’~form, :actual (class object#)})
(do-report {:type :fail, :message ~msg,
:expected ’~form, :actual (class object#)}))
result#)))
(defmethod assert-expr ’thrown? [msg form]
;; (is (thrown? c expr))
;; Asserts that evaluating expr throws an exception of class c.
;; Returns the exception thrown.
(let [klass (second form)
body (nthnext form 2)]
‘(try ~@body
(do-report {:type :fail, :message ~msg,
:expected ’~form, :actual nil})
(catch ~klass e#
(do-report {:type :pass, :message ~msg,
:expected ’~form, :actual e#})
e#))))
(defmethod assert-expr ’thrown-with-msg? [msg form]
;; (is (thrown-with-msg? c re expr))
;; Asserts that evaluating expr throws an exception of class c.
;; Also asserts that the message string of the exception matc hes
;; (with re-find) the regular expression re.
(let [klass (nth form 1)
re (nth form 2)
1514 CHAPTER 11. CLJ/CLOJURE/
body (nthnext form 3)]
‘(try ~@body
(do-report {:type :fail, :message ~msg, :expected ’~form,
:actual nil})
(catch ~klass e#
(let [m# (.getMessage e#)]
(if (re-find ~re m#)
(do-report {:type :pass, :message ~msg,
:expected ’~form, :actual e#})
(do-report {:type :fail, :message ~msg,
:expected ’~form, :actual e#})))
e#))))
(defmacro try-expr
"Used by the ’is’ macro to catch unexpected exceptions.
You don’t call this."
{:added "1.1"}
[msg form]
‘(try ~(assert-expr msg form)
(catch Throwable t#
(do-report {:type :error, :message ~msg,
:expected ’~form, :actual t#}))))
;;; ASSERTION MACROS
;; You use these in your tests.
(defmacro is
"Generic assertion macro. ’form’ is any predicate test.
’msg’ is an optional message to attach to the assertion.
Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")
Special forms:
(is (thrown? c body)) checks that an instance of c is thrown fr om
body, fails if not; then returns the thing thrown.
(is (thrown-with-msg? c re body)) checks that an instance of c is
thrown AND that the message on the exception matches (with
re-find) the regular expression re."
{:added "1.1"}
([form] ‘(is ~form nil))
([form msg] ‘(try-expr ~msg ~form)))
(defmacro are
"Checks multiple assertions with a template expression.
11.33. TEST.CLJ 1515
See clojure.template/do-template for an explanation of
templates.
Example: (are [x y] (= x y)
2 (+ 1 1)
4 (* 2 2))
Expands to:
(do (is (= 2 (+ 1 1)))
(is (= 4 (* 2 2))))
Note: This breaks some reporting features, such as line numb ers."
{:added "1.1"}
[argv expr & args]
‘(temp/do-template ~argv (is ~expr) ~@args))
(defmacro testing
"Adds a new string to the list of testing contexts. May be nest ed,
but must occur inside a test function (deftest)."
{:added "1.1"}
[string & body]
‘(binding [*testing-contexts* (conj *testing-contexts* ~string)]
~@body))
;;; DEFINING TESTS
(defmacro with-test
"Takes any definition form (that returns a Var) as the first a rgument.
Remaining body goes in the :test metadata function for that V ar.
When *load-tests* is false, only evaluates the definition, ignoring
the tests."
{:added "1.1"}
[definition & body]
(if *load-tests*
‘(doto ~definition (alter-meta! assoc :test (fn [] ~@body) ))
definition))
(defmacro deftest
"Defines a test function with no arguments. Test functions m ay call
other tests, so tests may be composed. If you compose tests, y ou
should also define a function named test-ns-hook; run-test s will
call test-ns-hook instead of testing all vars.
Note: Actually, the test body goes in the :test metadata on th e var,
and the real function (the value of the var) calls test-var on
itself.
1516 CHAPTER 11. CLJ/CLOJURE/
When *load-tests* is false, deftest is ignored."
{:added "1.1"}
[name & body]
(when *load-tests*
‘(def ~(vary-meta name assoc :test ‘(fn [] ~@body))
(fn [] (test-var (var ~name))))))
(defmacro deftest-
"Like deftest but creates a private var."
{:added "1.1"}
[name & body]
(when *load-tests*
‘(def ~(vary-meta name assoc :test ‘(fn [] ~@body) :private true)
(fn [] (test-var (var ~name))))))
(defmacro set-test
"Experimental.
Sets :test metadata of the named var to a fn with the given body .
The var must already exist. Does not modify the value of the va r.
When *load-tests* is false, set-test is ignored."
{:added "1.1"}
[name & body]
(when *load-tests*
‘(alter-meta! (var ~name) assoc :test (fn [] ~@body))))
;;; DEFINING FIXTURES
(defn- add-ns-meta
"Adds elements in coll to the current namespace metadata as t he
value of key."
{:added "1.1"}
[key coll]
(alter-meta! *ns* assoc key coll))
(defmulti use-fixtures
"Wrap test runs in a fixture function to perform setup and
teardown. Using a fixture-type of :each wraps every test
individually, while:once wraps the whole run in a single fun ction."
{:added "1.1"}
(fn [fixture-type & args] fixture-type))
(defmethod use-fixtures :each [fixture-type & args]
(add-ns-meta ::each-fixtures args))
(defmethod use-fixtures :once [fixture-type & args]
(add-ns-meta ::once-fixtures args))
11.33. TEST.CLJ 1517
(defn- default-fixture
"The default, empty, fixture function. Just calls its argum ent."
{:added "1.1"}
[f]
(f))
(defn compose-fixtures
"Composes two fixture functions, creating a new fixture fun ction
that combines their behavior."
{:added "1.1"}
[f1 f2]
(fn [g] (f1 (fn [] (f2 g)))))
(defn join-fixtures
"Composes a collection of fixtures, in order. Always return s a valid
fixture function, even if the collection is empty."
{:added "1.1"}
[fixtures]
(reduce compose-fixtures default-fixture fixtures))
;;; RUNNING TESTS: LOW-LEVEL FUNCTIONS
(defn test-var
"If v has a function in its :test metadata, calls that functio n,
with *testing-vars* bound to (conj *testing-vars* v)."
{:dynamic true, :added "1.1"}
[v]
(when-let [t (:test (meta v))]
(binding [*testing-vars* (conj *testing-vars* v)]
(do-report {:type :begin-test-var, :var v})
(inc-report-counter :test)
(try (t)
(catch Throwable e
(do-report {:type :error,
:message "Uncaught exception, not in assertion."
:expected nil, :actual e})))
(do-report {:type :end-test-var, :var v}))))
(defn test-all-vars
"Calls test-var on every var interned in the namespace, with fixtures."
{:added "1.1"}
[ns]
(let [once-fixture-fn (join-fixtures (::once-fixtures ( meta ns)))
each-fixture-fn (join-fixtures (::each-fixtures (meta n s)))]
(once-fixture-fn
(fn []
1518 CHAPTER 11. CLJ/CLOJURE/
(doseq [v (vals (ns-interns ns))]
(when (:test (meta v))
(each-fixture-fn (fn [] (test-var v)))))))))
(defn test-ns
"If the namespace defines a function named test-ns-hook, ca lls that.
Otherwise, calls test-all-vars on the namespace. ’ns’ is a
namespace object or a symbol.
Internally binds *report-counters* to a ref initialized to
*inital-report-counters*. Returns the final, dereferenc ed state of
*report-counters*."
{:added "1.1"}
[ns]
(binding [*report-counters* (ref *initial-report-count ers*)]
(let [ns-obj (the-ns ns)]
(do-report {:type :begin-test-ns, :ns ns-obj})
;; If the namespace has a test-ns-hook function, call that:
(if-let [v (find-var
(symbol (str (ns-name ns-obj)) "test-ns-hook"))]
((var-get v))
;; Otherwise, just test every var in the namespace.
(test-all-vars ns-obj))
(do-report {:type :end-test-ns, :ns ns-obj}))
@*report-counters*))
;;; RUNNING TESTS: HIGH-LEVEL FUNCTIONS
(defn run-tests
"Runs all tests in the given namespaces; prints results.
Defaults to current namespace if none given. Returns a map
summarizing test results."
{:added "1.1"}
([] (run-tests *ns*))
([& namespaces]
(let [summary (assoc (apply merge-with + (map test-ns names paces))
:type :summary)]
(do-report summary)
summary)))
(defn run-all-tests
"Runs all tests in all namespaces; prints results.
Optional argument is a regular expression; only namespaces with
names matching the regular expression (with re-matches) wi ll be
tested."
{:added "1.1"}
([] (apply run-tests (all-ns)))
([re] (apply run-tests
11.34. VERSION.PROPERTIES 1519
(filter #(re-matches re (name (ns-name %))) (all-ns)))))
(defn successful?
"Returns true if the given test summary indicates all tests
were successful, false otherwise."
{:added "1.1"}
[summary]
(and (zero? (:fail summary 0))
(zero? (:error summary 0))))
———-
11.34 version.properties
— version.properties —
clojure.version.major=1
clojure.version.minor=3
clojure.version.incremental=0
clojure.version.qualifier=master
clojure.version.interim=interim
———-
11.35 walk.clj
— walk.clj —
\getchunk{Clojure Copyright}
;;; walk.clj - generic tree walker with replacement
;; by Stuart Sierra
;; December 15, 2008
;; CHANGE LOG:
;;
;; * December 15, 2008: replaced ’walk’ with ’prewalk’ & ’pos twalk’
;;
;; * December 9, 2008: first version
(ns
^{:author "Stuart Sierra",
1520 CHAPTER 11. CLJ/CLOJURE/
:doc "This file defines a generic tree walker for Clojure dat a
structures. It takes any data structure (list, vector, map, set,
seq), calls a function on every element, and uses the return v alue
of the function in place of the original. This makes it fairly
easy to write recursive search-and-replace functions, as s hown in
the examples.
Note: \"walk\" supports all Clojure data structures EXCEPT maps
created with sorted-map-by. There is no (obvious) way to ret rieve
the sorting function."}
clojure.walk)
(defn walk
"Traverses form, an arbitrary data structure. inner and out er are
functions. Applies inner to each element of form, building u p a
data structure of the same type, then applies outer to the res ult.
Recognizes all Clojure data structures except sorted-map- by.
Consumes seqs as with doall."
{:added "1.1"}
[inner outer form]
(cond
(list? form) (outer (apply list (map inner form)))
(seq? form) (outer (doall (map inner form)))
(vector? form) (outer (vec (map inner form)))
(map? form) (outer (into (if (sorted? form) (sorted-map) {} )
(map inner form)))
(set? form) (outer (into (if (sorted? form) (sorted-set) #{ })
(map inner form)))
:else (outer form)))
(defn postwalk
"Performs a depth-first, post-order traversal of form. Cal ls f on
each sub-form, uses f’s return value in place of the original .
Recognizes all Clojure data structures except sorted-map- by.
Consumes seqs as with doall."
{:added "1.1"}
[f form]
(walk (partial postwalk f) f form))
(defn prewalk
"Like postwalk, but does pre-order traversal."
{:added "1.1"}
[f form]
(walk (partial prewalk f) identity (f form)))
;; Note: I wanted to write:
;;
;; (defn walk
;; [f form]
11.35. WALK.CLJ 1521
;; (let [pf (partial walk f)]
;; (if (coll? form)
;; (f (into (empty form) (map pf form)))
;; (f form))))
;;
;; but this throws a ClassCastException when applied to a map .
(defn postwalk-demo
"Demonstrates the behavior of postwalk by printing each for m as it is
walked. Returns form."
{:added "1.1"}
[form]
(postwalk (fn [x] (print "Walked: ") (prn x) x) form))
(defn prewalk-demo
"Demonstrates the behavior of prewalk by printing each form as it is
walked. Returns form."
{:added "1.1"}
[form]
(prewalk (fn [x] (print "Walked: ") (prn x) x) form))
(defn keywordize-keys
"Recursively transforms all map keys from strings to keywor ds."
{:added "1.1"}
[m]
(let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]
;; only apply to maps
(postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))
(defn stringify-keys
"Recursively transforms all map keys from keywords to strin gs."
{:added "1.1"}
[m]
(let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]
;; only apply to maps
(postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))
(defn prewalk-replace
"Recursively transforms form by replacing keys in smap with their
values. Like clojure/replace but works on any data structur e. Does
replacement at the root of the tree first."
{:added "1.1"}
[smap form]
(prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))
(defn postwalk-replace
"Recursively transforms form by replacing keys in smap with their
values. Like clojure/replace but works on any data structur e. Does
replacement at the leaves of the tree first."
1522 CHAPTER 11. CLJ/CLOJURE/
{:added "1.1"}
[smap form]
(postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))
(defn macroexpand-all
"Recursively performs all possible macroexpansions in for m."
{:added "1.1"}
[form]
(prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))
———-
11.36 xml.clj
— xml.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "XML reading/writing."
:author "Rich Hickey"}
clojure.xml
(:import (org.xml.sax ContentHandler Attributes SAXExce ption)
(javax.xml.parsers SAXParser SAXParserFactory)))
(def ^:dynamic *stack*)
(def ^:dynamic *current*)
(def ^:dynamic *state*) ; :element :chars :between
(def ^:dynamic *sb*)
(defstruct element :tag :attrs :content)
(def tag (accessor element :tag))
(def attrs (accessor element :attrs))
(def content (accessor element :content))
(def content-handler
(let [push-content
(fn [e c] (assoc e :content (conj (or (:content e) []) c)))
push-chars
(fn []
(when (and (= *state* :chars)
(some (complement
#(Character/isWhitespace (char %)))
(str *sb*)))
(set! *current*
(push-content *current* (str *sb*)))))]
11.36. XML.CLJ 1523
(new clojure.lang.XMLHandler
(proxy [ContentHandler] []
(startElement [uri local-name q-name ^Attributes atts]
(let [attrs (fn [ret i]
(if (neg? i)
ret
(recur
(assoc ret
(clojure.lang.Keyword/intern
(symbol (.getQName atts i)))
(.getValue atts (int i)))
(dec i))))
e (struct element
(. clojure.lang.Keyword
(intern (symbol q-name)))
(when (pos? (.getLength atts))
(attrs {} (dec (.getLength atts)))))]
(push-chars)
(set! *stack* (conj *stack* *current*))
(set! *current* e)
(set! *state* :element))
nil)
(endElement [uri local-name q-name]
(push-chars)
(set! *current* (push-content (peek *stack*) *current*))
(set! *stack* (pop *stack*))
(set! *state* :between)
nil)
(characters [^chars ch start length]
(when-not (= *state* :chars)
(set! *sb* (new StringBuilder)))
(let [^StringBuilder sb *sb*]
(.append sb ch (int start) (int length))
(set! *state* :chars))
nil)
(setDocumentLocator [locator])
(startDocument [])
(endDocument [])
(startPrefixMapping [prefix uri])
(endPrefixMapping [prefix])
(ignorableWhitespace [ch start length])
(processingInstruction [target data])
(skippedEntity [name])
))))
(defn startparse-sax [s ch]
(.. SAXParserFactory (newInstance) (newSAXParser) (pars e s ch)))
(defn parse
"Parses and loads the source s, which can be a File, InputStre am or
1524 CHAPTER 11. CLJ/CLOJURE/
String naming a URI. Returns a tree of the xml/element struct -map,
which has the keys :tag, :attrs, and :content. and accessor f ns tag,
attrs, and content. Other parsers can be supplied by passing
startparse, a fn taking a source and a ContentHandler and ret urning
a parser"
{:added "1.0"}
([s] (parse s startparse-sax))
([s startparse]
(binding [*stack* nil
*current* (struct element)
*state* :between
*sb* nil]
(startparse s content-handler)
((:content *current*) 0))))
(defn emit-element [e]
(if (instance? String e)
(println e)
(do
(print (str "<" (name (:tag e))))
(when (:attrs e)
(doseq [attr (:attrs e)]
(print (str " " (name (key attr)) "=’" (val attr)"’"))))
(if (:content e)
(do
(println ">")
(doseq [c (:content e)]
(emit-element c))
(println (str "</" (name (:tag e)) ">")))
(println "/>")))))
(defn emit [x]
(println "<?xml version=’1.0’ encoding=’UTF-8’?>")
(emit-element x))
;(export ’(tag attrs content parse element emit emit-eleme nt))
;(load-file "/Users/rich/dev/clojure/src/xml.clj")
;(def x (xml/parse "http://arstechnica.com/journals.rs sx"))
———-
11.37 zip.clj
— zip.clj —
\getchunk{Clojure Copyright}
11.37. ZIP.CLJ 1525
;functional hierarchical zipper, with navigation, editin g and
;enumeration see Huet
(ns ^{:doc "Functional hierarchical zipper, with navigati on, editing,
and enumeration. See Huet"
:author "Rich Hickey"}
clojure.zip
(:refer-clojure :exclude (replace remove next)))
(defn zipper
"Creates a new zipper structure.
branch? is a fn that, given a node, returns true if can have
children, even if it currently doesn’t.
children is a fn that, given a branch node, returns a seq of its
children.
make-node is a fn that, given an existing node and a seq of
children, returns a new branch node with the supplied childr en.
root is the root node."
{:added "1.0"}
[branch? children make-node root]
^{:zip/branch? branch? :zip/children children
:zip/make-node make-node}
[root nil])
(defn seq-zip
"Returns a zipper for nested sequences, given a root sequenc e"
{:added "1.0"}
[root]
(zipper seq?
identity
(fn [node children] (with-meta children (meta node)))
root))
(defn vector-zip
"Returns a zipper for nested vectors, given a root vector"
{:added "1.0"}
[root]
(zipper vector?
seq
(fn [node children] (with-meta (vec children) (meta node)) )
root))
(defn xml-zip
"Returns a zipper for xml elements (as from xml/parse),
given a root element"
{:added "1.0"}
1526 CHAPTER 11. CLJ/CLOJURE/
[root]
(zipper (complement string?)
(comp seq :content)
(fn [node children]
(assoc node :content
(and children (apply vector children))))
root))
(defn node
"Returns the node at loc"
{:added "1.0"}
[loc] (loc 0))
(defn branch?
"Returns true if the node at loc is a branch"
{:added "1.0"}
[loc]
((:zip/branch? (meta loc)) (node loc)))
(defn children
"Returns a seq of the children of node at loc, which must be a br anch"
{:added "1.0"}
[loc]
(if (branch? loc)
((:zip/children (meta loc)) (node loc))
(throw (Exception. "called children on a leaf node"))))
(defn make-node
"Returns a new branch node, given an existing node and new
children. The loc is only used to supply the constructor."
{:added "1.0"}
[loc node children]
((:zip/make-node (meta loc)) node children))
(defn path
"Returns a seq of nodes leading to this loc"
{:added "1.0"}
[loc]
(:pnodes (loc 1)))
(defn lefts
"Returns a seq of the left siblings of this loc"
{:added "1.0"}
[loc]
(seq (:l (loc 1))))
(defn rights
"Returns a seq of the right siblings of this loc"
{:added "1.0"}
[loc]
11.37. ZIP.CLJ 1527
(:r (loc 1)))
(defn down
"Returns the loc of the leftmost child of the node at this loc, or
nil if no children"
{:added "1.0"}
[loc]
(when (branch? loc)
(let [[node path] loc
[c & cnext :as cs] (children loc)]
(when cs
(with-meta [c {:l []
:pnodes
(if path (conj (:pnodes path) node) [node])
:ppath path
:r cnext}] (meta loc))))))
(defn up
"Returns the loc of the parent of the node at this loc, or nil if at
the top"
{:added "1.0"}
[loc]
(let [[node {l :l, ppath :ppath, pnodes :pnodes r
:r, changed? :changed?, :as path}] loc]
(when pnodes
(let [pnode (peek pnodes)]
(with-meta (if changed?
[(make-node loc pnode (concat l (cons node r)))
(and ppath (assoc ppath :changed? true))]
[pnode ppath])
(meta loc))))))
(defn root
"zips all the way up and returns the root node, reflecting any
changes."
{:added "1.0"}
[loc]
(if (= :end (loc 1))
(node loc)
(let [p (up loc)]
(if p
(recur p)
(node loc)))))
(defn right
"Returns the loc of the right sibling of the node at this loc, o r nil"
{:added "1.0"}
[loc]
(let [[node {l :l [r & rnext :as rs] :r :as path}] loc]
1528 CHAPTER 11. CLJ/CLOJURE/
(when (and path rs)
(with-meta [r (assoc path :l (conj l node) :r rnext)]
(meta loc)))))
(defn rightmost
"Returns the loc of the rightmost sibling of the node at this l oc,
or self"
{:added "1.0"}
[loc]
(let [[node {l :l r :r :as path}] loc]
(if (and path r)
(with-meta [(last r)
(assoc path :l (apply conj l node (butlast r)) :r nil)]
(meta loc))
loc)))
(defn left
"Returns the loc of the left sibling of the node at this loc, or nil"
{:added "1.0"}
[loc]
(let [[node {l :l r :r :as path}] loc]
(when (and path (seq l))
(with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))]
(meta loc)))))
(defn leftmost
"Returns the loc of the leftmost sibling of the node at this lo c,
or self"
{:added "1.0"}
[loc]
(let [[node {l :l r :r :as path}] loc]
(if (and path (seq l))
(with-meta [(first l)
(assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))
loc)))
(defn insert-left
"Inserts the item as the left sibling of the node at this loc,
without moving"
{:added "1.0"}
[loc item]
(let [[node {l :l :as path}] loc]
(if (nil? path)
(throw (new Exception "Insert at top"))
(with-meta [node (assoc path :l (conj l item) :changed? true )]
(meta loc)))))
(defn insert-right
"Inserts the item as the right sibling of the node at this loc,
without moving"
11.37. ZIP.CLJ 1529
{:added "1.0"}
[loc item]
(let [[node {r :r :as path}] loc]
(if (nil? path)
(throw (new Exception "Insert at top"))
(with-meta [node (assoc path :r (cons item r) :changed? true )]
(meta loc)))))
(defn replace
"Replaces the node at this loc, without moving"
{:added "1.0"}
[loc node]
(let [[_ path] loc]
(with-meta [node (assoc path :changed? true)] (meta loc))) )
(defn edit
"Replaces the node at this loc with the value of (f node args)"
{:added "1.0"}
[loc f & args]
(replace loc (apply f (node loc) args)))
(defn insert-child
"Inserts the item as the leftmost child of the node at this loc ,
without moving"
{:added "1.0"}
[loc item]
(replace loc
(make-node loc (node loc) (cons item (children loc)))))
(defn append-child
"Inserts the item as the rightmost child of the node at this lo c,
without moving"
{:added "1.0"}
[loc item]
(replace loc
(make-node loc (node loc) (concat (children loc) [item]))) )
(defn next
"Moves to the next loc in the hierarchy, depth-first. When re aching
the end, returns a distinguished loc detectable via end?. If already
at the end, stays there."
{:added "1.0"}
[loc]
(if (= :end (loc 1))
loc
(or
(and (branch? loc) (down loc))
(right loc)
(loop [p loc]
(if (up p)
1530 CHAPTER 11. CLJ/CLOJURE/
(or (right (up p)) (recur (up p)))
[(node p) :end])))))
(defn prev
"Moves to the previous loc in the hierarchy, depth-first. If already
at the root, returns nil."
{:added "1.0"}
[loc]
(if-let [lloc (left loc)]
(loop [loc lloc]
(if-let [child (and (branch? loc) (down loc))]
(recur (rightmost child))
loc))
(up loc)))
(defn end?
"Returns true if loc represents the end of a depth-first walk "
{:added "1.0"}
[loc]
(= :end (loc 1)))
(defn remove
"Removes the node at loc, returning the loc that would have pr eceded
it in a depth-first walk."
{:added "1.0"}
[loc]
(let [[node {l :l, ppath :ppath, pnodes
:pnodes, rs :r, :as path}] loc]
(if (nil? path)
(throw (new Exception "Remove at top"))
(if (pos? (count l))
(loop [loc (with-meta [(peek l)
(assoc path :l (pop l) :changed? true)]
(meta loc))]
(if-let [child (and (branch? loc) (down loc))]
(recur (rightmost child))
loc))
(with-meta [(make-node loc (peek pnodes) rs)
(and ppath (assoc ppath :changed? true))]
(meta loc))))))
(comment
(load-file "/Users/rich/dev/clojure/src/zip.clj")
(refer ’zip)
(def data ’[[a * b] + [c * d]])
(def dz (vector-zip data))
(right (down (right (right (down dz)))))
(lefts (right (down (right (right (down dz))))))
11.38. POM-TEMPLATE.XML 1531
(rights (right (down (right (right (down dz))))))
(up (up (right (down (right (right (down dz)))))))
(path (right (down (right (right (down dz))))))
(-> dz down right right down right)
(-> dz down right right down right (replace ’/) root)
(-> dz next next (edit str) next next next (replace ’/) root)
(-> dz next next next next next next next next next remove root )
(-> dz next next next next next next next next next remove
(insert-right ’e) root)
(-> dz next next next next next next next next next remove up
(append-child ’e) root)
(end? (-> dz next next next next next next next next next remov e next))
(-> dz next remove next remove root)
(loop [loc dz]
(if (end? loc)
(root loc)
(recur (next (if (= ’* (node loc))
(replace loc ’/)
loc)))))
(loop [loc dz]
(if (end? loc)
(root loc)
(recur (next (if (= ’* (node loc))
(remove loc)
loc)))))
)
———-
11.38 pom-template.xml
— pom-template.xml —
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http//www.w3.org/2001/XMLSchema-instance "
xsi:schemaLocation="http://maven.apache.org/POM/4.0 .0
http://maven.apache.org/maven-v4_0_0.xsd">
<modelVersion>4.0.0</modelVersion>
<groupId>org.clojure</groupId>
<artifactId>clojure</artifactId>
<name>clojure</name>
1532 CHAPTER 11. CLJ/CLOJURE/
<version>@clojure-version@</version>
<url>http://clojure.org/</url>
<description>
Clojure core environment and runtime library.
</description>
<licenses>
<license>
<name>Eclipse Public License 1.0</name>
<url>http://opensource.org/licenses/eclipse-1.0.php </url>
<distribution>repo</distribution>
</license>
</licenses>
</project>
———-
Chapter 12
test/clojure
12.1 test/test˙clojure.clj
— test/test˙clojure.clj —
\getchunk{Clojure Copyright}
;; clojure.test-clojure
;;
;; Tests for the facilities provided by Clojure
;;
;; scgilardi (gmail)
;; Created 22 October 2008
(ns clojure.test-clojure
(:require [clojure.test :as t])
(:gen-class))
(def test-names
[:reader
:printer
:compilation
:evaluation
:special
:macros
:metadata
:ns-libs
:logic
:predicates
:control
:data-structures
:numbers
1533
1534 CHAPTER 12. TEST/CLOJURE
:sequences
:for
:multimethods
:other-functions
:vars
:refs
:agents
:atoms
:parallel
:java-interop
:test
:test-fixtures
;; libraries
:clojure-set
:clojure-xml
:clojure-zip
:protocols
:genclass
:main
:vectors
:annotations
:pprint
:serialization
:rt
:repl
:java.io
:string
:java.javadoc
:java.shell
:transients
:def
:keywords
:data
:reflect
:errors
])
(def test-namespaces
(map #(symbol (str "clojure.test-clojure." (name %)))
test-names))
(defn run
"Runs all defined tests"
[]
(println "Loading tests...")
(apply require :reload-all test-namespaces)
(apply t/run-tests test-namespaces))
(defn run-ant
"Runs all defined tests, prints report to *err*, throw if
12.2. TEST/TEST˙HELPER.CLJ 1535
failures. This works well for running in an ant java task."
[]
(let [rpt t/report]
(binding [;; binding to *err* because, in ant, when the test
;; target runs after compile-clojure, *out* doesn’t
;; print anything
*out* *err*
t/*test-out* *err*
t/report
(fn report [m]
(if (= :summary (:type m))
(do (rpt m)
(if (or (pos? (:fail m)) (pos? (:error m)))
(throw (new Exception (str
(:fail m) " failures, "
(:error m) " errors.")))))
(rpt m)))]
(run))))
(defn -main
"Run all defined tests from the command line"
[& args]
(run)
(System/exit 0))
———-
12.2 test/test˙helper.clj
— test/test˙helper.clj —
\getchunk{Clojure Copyright}
;; clojure.test-helper
;;
;; Utility functions shared by various tests in the Clojure
;; test suite
;;
;; tomfaulhaber (gmail)
;; Created 04 November 2010
(ns clojure.test-helper
(:use clojure.test))
(let [nl (System/getProperty "line.separator")]
(defn platform-newlines [s] (.replace s "\n" nl)))
1536 CHAPTER 12. TEST/CLOJURE
(defn temp-ns
"Create and return a temporary ns, using clojure.core + uses "
[& uses]
(binding [*ns* *ns*]
(in-ns (gensym))
(apply clojure.core/use ’clojure.core uses)
*ns*))
(defmacro eval-in-temp-ns [& forms]
‘(binding [*ns* *ns*]
(in-ns (gensym))
(clojure.core/use ’clojure.core)
(eval
’(do ~@forms))))
(defn causes
[^Throwable throwable]
(loop [causes []
t throwable]
(if t (recur (conj causes t) (.getCause t)) causes)))
;; this is how I wish clojure.test/thrown? worked...
;; Does body throw expected exception, anywhere in the .getC ause chain?
(defmethod assert-expr ’fails-with-cause?
[msg [_ exception-class msg-re & body :as form]]
‘(try
~@body
(report {:type :fail, :message ~msg, :expected ’~form, :ac tual nil})
(catch Throwable t#
(if (some (fn [cause#]
(and
(= ~exception-class (class cause#))
(re-find ~msg-re (.getMessage cause#))))
(causes t#))
(report {:type :pass, :message ~msg,
:expected ’~form, :actual t#})
(report {:type :fail, :message ~msg,
:expected ’~form, :actual t#})))))
(defn get-field
"Access to private or protected field. field-name is a symbo l or
keyword."
([klass field-name]
(get-field klass field-name nil))
([klass field-name inst]
(-> klass (.getDeclaredField (name field-name))
(doto (.setAccessible true))
(.get inst))))
12.3. TEST/AGENTS.CLJ 1537
(defn set-var-roots
[maplike]
(doseq [[var val] maplike]
(alter-var-root var (fn [_] val))))
(defn with-var-roots*
"Temporarily set var roots, run block, then put original roo ts back."
[root-map f & args]
(let [originals (doall (map (fn [[var _]] [var @var]) root-m ap))]
(set-var-roots root-map)
(try
(apply f args)
(finally
(set-var-roots originals)))))
(defmacro with-var-roots
[root-map & body]
‘(with-var-roots* ~root-map (fn [] ~@body)))
(defn exception
"Use this function to ensure that execution of a program does n’t
reach certain point."
[]
(throw (new Exception "Exception which should never occur" )))
———-
12.3 test/agents.clj
— test/agents.clj —
\getchunk{Clojure Copyright}
;; Author: Shawn Hoover
(ns clojure.test-clojure.agents
(:use clojure.test)
(:import [java.util.concurrent CountDownLatch TimeUnit ]))
(deftest handle-all-throwables-during-agent-actions
;; Bug fixed in r1198;
;; previously hung Clojure or didn’t report agent errors
;; after OutOfMemoryError, yet wouldn’t execute new action s.
(let [agt (agent nil)]
(send agt
(fn [state] (throw (Throwable. "just testing Throwables") )))
(try
1538 CHAPTER 12. TEST/CLOJURE
;; Let the action finish; eat the "agent has errors" error
;; that bubbles up
(await-for 100 agt)
(catch RuntimeException _))
(is (instance? Throwable (first (agent-errors agt))))
(is (= 1 (count (agent-errors agt))))
;; And now send an action that should work
(clear-agent-errors agt)
(is (= nil @agt))
(send agt nil?)
(is (true? (await-for 100 agt)))
(is (true? @agt))))
(deftest default-modes
(is (= :fail (error-mode (agent nil))))
(is (= :continue (error-mode (agent nil :error-handler pri ntln)))))
(deftest continue-handler
(let [err (atom nil)
agt (agent 0 :error-mode :continue
:error-handler #(reset! err %&))]
(send agt /)
(is (true? (await-for 100 agt)))
(is (= 0 @agt))
(is (nil? (agent-error agt)))
(is (= agt (first @err)))
(is (true? (instance? ArithmeticException (second @err)) ))))
(deftest fail-handler
(let [err (atom nil)
agt (agent 0 :error-mode :fail :error-handler #(reset! err %&))]
(send agt /)
(Thread/sleep 100)
(is (true? (instance? ArithmeticException (agent-error a gt))))
(is (= 0 @agt))
(is (= agt (first @err)))
(is (true? (instance? ArithmeticException (second @err)) ))
(is (thrown? RuntimeException (send agt inc)))))
(deftest can-send-from-handler-before-popping-action -that-caused-error
(let [latch (CountDownLatch. 1)
target-agent (agent :before-error)
handler (fn [agt err]
(send target-agent
(fn [_] (.countDown latch))))
failing-agent (agent nil :error-handler handler)]
(send failing-agent (fn [_] (throw (RuntimeException.))) )
(is (.await latch 10 TimeUnit/SECONDS))))
12.3. TEST/AGENTS.CLJ 1539
(deftest
can-send-to-self-from-handler-before-popping-action -that-caused-error
(let [latch (CountDownLatch. 1)
handler (fn [agt err]
(send *agent*
(fn [_] (.countDown latch))))
failing-agent (agent nil :error-handler handler)]
(send failing-agent (fn [_] (throw (RuntimeException.))) )
(is (.await latch 10 TimeUnit/SECONDS))))
(deftest restart-no-clear
(let [p (promise)
agt (agent 1 :error-mode :fail)]
(send agt (fn [v] @p))
(send agt /)
(send agt inc)
(send agt inc)
(deliver p 0)
(Thread/sleep 100)
(is (= 0 @agt))
(is (= ArithmeticException (class (agent-error agt))))
(restart-agent agt 10)
(is (true? (await-for 100 agt)))
(is (= 12 @agt))
(is (nil? (agent-error agt)))))
(deftest restart-clear
(let [p (promise)
agt (agent 1 :error-mode :fail)]
(send agt (fn [v] @p))
(send agt /)
(send agt inc)
(send agt inc)
(deliver p 0)
(Thread/sleep 100)
(is (= 0 @agt))
(is (= ArithmeticException (class (agent-error agt))))
(restart-agent agt 10 :clear-actions true)
(is (true? (await-for 100 agt)))
(is (= 10 @agt))
(is (nil? (agent-error agt)))
(send agt inc)
(is (true? (await-for 100 agt)))
(is (= 11 @agt))
(is (nil? (agent-error agt)))))
(deftest invalid-restart
(let [p (promise)
agt (agent 2 :error-mode :fail :validator even?)]
(is (thrown? RuntimeException (restart-agent agt 4)))
1540 CHAPTER 12. TEST/CLOJURE
(send agt (fn [v] @p))
(send agt (partial + 2))
(send agt (partial + 2))
(deliver p 3)
(Thread/sleep 100)
(is (= 2 @agt))
(is (= IllegalStateException (class (agent-error agt))))
(is (thrown? RuntimeException (restart-agent agt 5)))
(restart-agent agt 6)
(is (true? (await-for 100 agt)))
(is (= 10 @agt))
(is (nil? (agent-error agt)))))
(deftest earmuff-agent-bound
(let [a (agent 1)]
(send a (fn [_] *agent*))
(await a)
(is (= a @a))))
(def ^:dynamic *bind-me* :root-binding)
(deftest thread-conveyance-to-agents
(let [a (agent nil)]
(doto (Thread.
(fn []
(binding [*bind-me* :thread-binding]
(send a (constantly *bind-me*)))
(await a)))
(.start)
(.join))
(is (= @a :thread-binding))))
; http://clojure.org/agents
; agent
; deref, @-reader-macro, agent-errors
; send send-off clear-agent-errors
; await await-for
; set-validator get-validator
; add-watch remove-watch
; shutdown-agents
———-
12.4. TEST/ANNOTATIONS.CLJ 1541
12.4 test/annotations.clj
— test/annotations.clj —
\getchunk{Clojure Copyright}
;; Authors: Stuart Halloway, Rich Hickey
(ns clojure.test-clojure.annotations
(:use clojure.test))
(defn vm-has-ws-annotations?
"Does the vm have the ws annotations we use to test some
annotation features. If not, fall back to Java 5 tests."
[]
(try
(doseq [n ["javax.xml.ws.soap.Addressing"
"javax.xml.ws.WebServiceRef"
"javax.xml.ws.WebServiceRefs"]]
(Class/forName n))
true
(catch ClassNotFoundException e
false)))
(if (vm-has-ws-annotations?)
(load "annotations/java_6_and_later")
(load "annotations/java_5"))
———-
12.5 test/atoms.clj
— test/atoms.clj —
\getchunk{Clojure Copyright}
;;Author: Frantisek Sodomka
(ns clojure.test-clojure.atoms
(:use clojure.test))
; http://clojure.org/atoms
; atom
; deref, @-reader-macro
1542 CHAPTER 12. TEST/CLOJURE
; swap! reset!
; compare-and-set!
———-
12.6 test/clojure˙set.clj
— test/clojure˙set.clj —
\getchunk{Clojure Copyright}
;; Author: Frantisek Sodomka
(ns clojure.test-clojure.clojure-set
(:use clojure.test)
(:require [clojure.set :as set]))
(deftest test-union
(are [x y] (= x y)
(set/union) #{}
; identity
(set/union #{}) #{}
(set/union #{1}) #{1}
(set/union #{1 2 3}) #{1 2 3}
; 2 sets, at least one is empty
(set/union #{} #{}) #{}
(set/union #{} #{1}) #{1}
(set/union #{} #{1 2 3}) #{1 2 3}
(set/union #{1} #{}) #{1}
(set/union #{1 2 3} #{}) #{1 2 3}
; 2 sets
(set/union #{1} #{2}) #{1 2}
(set/union #{1} #{1 2}) #{1 2}
(set/union #{2} #{1 2}) #{1 2}
(set/union #{1 2} #{3}) #{1 2 3}
(set/union #{1 2} #{2 3}) #{1 2 3}
; 3 sets, some are empty
(set/union #{} #{} #{}) #{}
(set/union #{1} #{} #{}) #{1}
(set/union #{} #{1} #{}) #{1}
(set/union #{} #{} #{1}) #{1}
12.6. TEST/CLOJURE˙SET.CLJ 1543
(set/union #{1 2} #{2 3} #{}) #{1 2 3}
; 3 sets
(set/union #{1 2} #{3 4} #{5 6}) #{1 2 3 4 5 6}
(set/union #{1 2} #{2 3} #{1 3 4}) #{1 2 3 4}
; different data types
(set/union #{1 2} #{:a :b} #{nil}
#{false true} #{\c "abc"} #{[] [1 2]}
#{{} {:a 1}} #{#{} #{1 2}})
#{1 2 :a :b nil false true \c "abc"
[] [1 2] {} {:a 1} #{} #{1 2}}
; different types of sets
(set/union (hash-set) (hash-set 1 2) (hash-set 2 3))
(hash-set 1 2 3)
(set/union (sorted-set) (sorted-set 1 2) (sorted-set 2 3))
(sorted-set 1 2 3)
(set/union (hash-set) (hash-set 1 2) (hash-set 2 3)
(sorted-set) (sorted-set 4 5) (sorted-set 5 6))
(hash-set 1 2 3 4 5 6) ; also equals (sorted-set 1 2 3 4 5 6)
))
(deftest test-intersection
; at least one argument is needed
(is (thrown? IllegalArgumentException (set/intersectio n)))
(are [x y] (= x y)
; identity
(set/intersection #{}) #{}
(set/intersection #{1}) #{1}
(set/intersection #{1 2 3}) #{1 2 3}
; 2 sets, at least one is empty
(set/intersection #{} #{}) #{}
(set/intersection #{} #{1}) #{}
(set/intersection #{} #{1 2 3}) #{}
(set/intersection #{1} #{}) #{}
(set/intersection #{1 2 3} #{}) #{}
; 2 sets
(set/intersection #{1 2} #{1 2}) #{1 2}
(set/intersection #{1 2} #{3 4}) #{}
(set/intersection #{1 2} #{1}) #{1}
(set/intersection #{1 2} #{2}) #{2}
(set/intersection #{1 2 4} #{2 3 4 5}) #{2 4}
; 3 sets, some are empty
(set/intersection #{} #{} #{}) #{}
(set/intersection #{1} #{} #{}) #{}
1544 CHAPTER 12. TEST/CLOJURE
(set/intersection #{1} #{1} #{}) #{}
(set/intersection #{1} #{} #{1}) #{}
(set/intersection #{1 2} #{2 3} #{}) #{}
; 3 sets
(set/intersection #{1 2} #{2 3} #{5 2}) #{2}
(set/intersection #{1 2 3} #{1 3 4} #{1 3}) #{1 3}
(set/intersection #{1 2 3} #{3 4 5} #{8 2 3}) #{3}
; different types of sets
(set/intersection (hash-set 1 2) (hash-set 2 3)) #{2}
(set/intersection (sorted-set 1 2) (sorted-set 2 3)) #{2}
(set/intersection
(hash-set 1 2) (hash-set 2 3)
(sorted-set 1 2) (sorted-set 2 3)) #{2} ))
(deftest test-difference
(are [x y] (= x y)
; identity
(set/difference #{}) #{}
(set/difference #{1}) #{1}
(set/difference #{1 2 3}) #{1 2 3}
; 2 sets
(set/difference #{1 2} #{1 2}) #{}
(set/difference #{1 2} #{3 4}) #{1 2}
(set/difference #{1 2} #{1}) #{2}
(set/difference #{1 2} #{2}) #{1}
(set/difference #{1 2 4} #{2 3 4 5}) #{1}
; 3 sets
(set/difference #{1 2} #{2 3} #{5 2}) #{1}
(set/difference #{1 2 3} #{1 3 4} #{1 3}) #{2}
(set/difference #{1 2 3} #{3 4 5} #{8 2 3}) #{1} ))
(deftest test-select
(are [x y] (= x y)
(set/select integer? #{}) #{}
(set/select integer? #{1 2}) #{1 2}
(set/select integer? #{1 2 :a :b :c}) #{1 2}
(set/select integer? #{:a :b :c}) #{}) )
(def compositions
#{{:name "Art of the Fugue" :composer "J. S. Bach"}
{:name "Musical Offering" :composer "J. S. Bach"}
{:name "Requiem" :composer "Giuseppe Verdi"}
{:name "Requiem" :composer "W. A. Mozart"}})
(deftest test-project
(are [x y] (= x y)
12.6. TEST/CLOJURE˙SET.CLJ 1545
(set/project compositions [:name]) #{{:name "Art of the Fu gue"}
{:name "Requiem"}
{:name "Musical Offering"}}
(set/project compositions [:composer]) #{{:composer "W. A. Mozart"}
{:composer "Giuseppe Verdi"}
{:composer "J. S. Bach"}}
(set/project compositions [:year]) #{{}}
(set/project #{{}} [:name]) #{{}} ))
(deftest test-rename
(are [x y] (= x y)
(set/rename compositions {:name :title})
#{{:title "Art of the Fugue" :composer "J. S. Bach"}
{:title "Musical Offering" :composer "J. S. Bach"}
{:title "Requiem" :composer "Giuseppe Verdi"}
{:title "Requiem" :composer "W. A. Mozart"}}
(set/rename compositions {:year :decade})
#{{:name "Art of the Fugue" :composer "J. S. Bach"}
{:name "Musical Offering" :composer "J. S. Bach"}
{:name "Requiem" :composer "Giuseppe Verdi"}
{:name "Requiem" :composer "W. A. Mozart"}}
(set/rename #{{}} {:year :decade}) #{{}}))
(deftest test-rename-keys
(are [x y] (= x y)
(set/rename-keys {:a "one" :b "two"} {:a :z}) {:z "one" :b "t wo"}
))
(deftest test-index
(are [x y] (= x y)
(set/index #{{:c 2} {:b 1} {:a 1 :b 2}} [:b]) {{:b 2}
#{{:a 1 :b 2}}, {:b 1} #{{:b 1}} {} #{{:c 2}}}
))
(deftest test-join
(are [x y] (= x y)
(set/join compositions compositions) compositions
(set/join compositions
#{{:name "Art of the Fugue" :genre "Classical"}})
#{{:name "Art of the Fugue" :composer "J. S. Bach"
:genre "Classical"}}
))
(deftest test-map-invert
(are [x y] (= x y)
(set/map-invert {:a "one" :b "two"}) {"one" :a "two" :b}))
(deftest test-subset?
(are [sub super] (set/subset? sub super)
#{} #{}
1546 CHAPTER 12. TEST/CLOJURE
#{} #{1}
#{1} #{1}
#{1 2} #{1 2}
#{1 2} #{1 2 42}
#{false} #{false}
#{nil} #{nil}
#{nil} #{nil false}
#{1 2 nil} #{1 2 nil 4})
(are [notsub super] (not (set/subset? notsub super))
#{1} #{}
#{2} #{1}
#{1 3} #{1}
#{nil} #{false}
#{false} #{nil}
#{false nil} #{nil}
#{1 2 nil} #{1 2}))
(deftest test-superset?
(are [super sub] (set/superset? super sub)
#{} #{}
#{1} #{}
#{1} #{1}
#{1 2} #{1 2}
#{1 2 42} #{1 2}
#{false} #{false}
#{nil} #{nil}
#{false nil} #{false}
#{1 2 4 nil false} #{1 2 nil})
(are [notsuper sub] (not (set/superset? notsuper sub))
#{} #{1}
#{2} #{1}
#{1} #{1 3}
#{nil} #{false}
#{false} #{nil}
#{nil} #{false nil}
#{nil 2 3} #{false nil 2 3}))
———-
12.7 test/clojure˙xml.clj
— test/clojure˙xml.clj —
\getchunk{Clojure Copyright}
;;Author: Frantisek Sodomka
12.8. TEST/CLOJURE˙ZIP.CLJ 1547
(ns clojure.test-clojure.clojure-xml
(:use clojure.test)
(:require [clojure.xml :as xml]))
; parse
; emit-element
; emit
———-
12.8 test/clojure˙zip.clj
— test/clojure˙zip.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.clojure-zip
(:use clojure.test)
(:require [clojure.zip :as zip]))
; zipper
;
; seq-zip
; vector-zip
; xml-zip
;
; node
; branch?
; children
; make-node
; path
; lefts
; rights
; down
; up
; root
; right
; rightmost
1548 CHAPTER 12. TEST/CLOJURE
; left
; leftmost
;
; insert-left
; insert-right
; replace
; edit
; insert-child
; append-child
; next
; prev
; end?
; remove
———-
12.9 test/compilation.clj
— test/compilation.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.compilation
(:use clojure.test))
; http://clojure.org/compilation
; compile
; gen-class, gen-interface
(deftest test-compiler-metadata
(let [m (meta #’when)]
(are [x y] (= x y)
(list? (:arglists m)) true
(> (count (:arglists m)) 0) true
(string? (:doc m)) true
(> (.length (:doc m)) 0) true
(string? (:file m)) true
(> (.length (:file m)) 0) true
12.9. TEST/COMPILATION.CLJ 1549
(integer? (:line m)) true
(> (:line m) 0) true
(:macro m) true
(:name m) ’when )))
(deftest test-embedded-constants
(testing "Embedded constants"
(is (eval ‘(= Boolean/TYPE ~Boolean/TYPE)))
(is (eval ‘(= Byte/TYPE ~Byte/TYPE)))
(is (eval ‘(= Character/TYPE ~Character/TYPE)))
(is (eval ‘(= Double/TYPE ~Double/TYPE)))
(is (eval ‘(= Float/TYPE ~Float/TYPE)))
(is (eval ‘(= Integer/TYPE ~Integer/TYPE)))
(is (eval ‘(= Long/TYPE ~Long/TYPE)))
(is (eval ‘(= Short/TYPE ~Short/TYPE)))))
(deftest test-compiler-resolution
(testing
"resolve nonexistent class create should return nil (assem bla #262)"
(is (nil? (resolve ’NonExistentClass.)))))
(deftest test-no-recur-across-try
(testing "don’t recur to function from inside try"
(is (thrown? Exception (eval ’(fn [x] (try (recur 1)))))))
(testing "don’t recur to loop from inside try"
(is (thrown? Exception (eval ’(loop [x] (try (recur 1)))))) )
(testing "don’t get confused about what the recur is targeti ng"
(is (thrown? Exception (eval ’(loop [x] (try (fn [x]) (recur 1)))))))
(testing "don’t allow recur accross binding"
(is (thrown? Exception (eval ’(fn [x] (binding [+ *] (recur 1 )))))))
(testing "allow loop/recur inside try"
(is (try
(eval ’(try (loop [x 3] (if (zero? x) x (recur (dec x))))))
(catch Exception _))))
(testing "allow fn/recur inside try"
(is (try
(eval ’(try
((fn [x]
(if (zero? x)
x
(recur (dec x))))
3)))
(catch Exception _)))))
———-
1550 CHAPTER 12. TEST/CLOJURE
12.10 test/control.clj
— test/control.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka, Mike Hinchey, Stuart Halloway
;;
;; Test "flow control" constructs.
;;
(ns clojure.test-clojure.control
(:use clojure.test
[clojure.test-helper :only (exception)]))
;; *** Helper functions ***
(defn maintains-identity [f]
(are [x] (= (f x) x)
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} ))
; http://clojure.org/special_forms
; http://clojure.org/macros
(deftest test-do
(are [x y] (= x y)
; no params => nil
(do) nil
; return last
(do 1) 1
(do 1 2) 2
(do 1 2 3 4 5) 5
12.10. TEST/CONTROL.CLJ 1551
; evaluate and return last
(let [a (atom 0)]
(do (reset! a (+ @a 1)) ; 1
(reset! a (+ @a 1)) ; 2
(reset! a (+ @a 1)) ; 3
@a)) 3 )
; identity (= (do x) x)
(maintains-identity (fn [_] (do _))) )
;; loop/recur
(deftest test-loop
(are [x y] (= x y)
1 (loop []
1)
3 (loop [a 1]
(if (< a 3)
(recur (inc a))
a))
[2 4 6] (loop [a []
b [1 2 3]]
(if (seq b)
(recur (conj a (* 2 (first b)))
(next b))
a))
[6 4 2] (loop [a ()
b [1 2 3]]
(if (seq b)
(recur (conj a (* 2 (first b)))
(next b))
a))
)
)
;; throw, try
; if: see logic.clj
(deftest test-when
(are [x y] (= x y)
1 (when true 1)
nil (when true)
nil (when false)
nil (when false (exception))
))
(deftest test-when-not
1552 CHAPTER 12. TEST/CLOJURE
(are [x y] (= x y)
1 (when-not false 1)
nil (when-not true)
nil (when-not false)
nil (when-not true (exception))
))
(deftest test-if-not
(are [x y] (= x y)
1 (if-not false 1)
1 (if-not false 1 (exception))
nil (if-not true 1)
2 (if-not true 1 2)
nil (if-not true (exception))
1 (if-not true (exception) 1)
))
(deftest test-when-let
(are [x y] (= x y)
1 (when-let [a 1]
a)
2 (when-let [[a b] ’(1 2)]
b)
nil (when-let [a false]
(exception))
))
(deftest test-if-let
(are [x y] (= x y)
1 (if-let [a 1]
a)
2 (if-let [[a b] ’(1 2)]
b)
nil (if-let [a false]
(exception))
1 (if-let [a false]
a 1)
1 (if-let [[a b] nil]
b 1)
1 (if-let [a false]
(exception)
1)
))
(deftest test-when-first
(are [x y] (= x y)
1 (when-first [a [1 2]]
a)
2 (when-first [[a b] ’((1 2) 3)]
b)
12.10. TEST/CONTROL.CLJ 1553
nil (when-first [a nil]
(exception))
))
(deftest test-cond
(are [x y] (= x y)
(cond) nil
(cond nil true) nil
(cond false true) nil
(cond true 1 true (exception)) 1
(cond nil 1 false 2 true 3 true 4) 3
(cond nil 1 false 2 true 3 true (exception)) 3 )
; false
(are [x] (= (cond x :a true :b) :b)
nil false )
; true
(are [x] (= (cond x :a true :b) :a)
true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} )
; evaluation
(are [x y] (= x y)
(cond (> 3 2) (+ 1 2) true :result true (exception)) 3
(cond (< 3 2) (+ 1 2) true :result true (exception)) :result )
; identity (= (cond true x) x)
(maintains-identity (fn [_] (cond true _))) )
(deftest test-condp
(are [x] (= :pass x)
(condp = 1
1 :pass
2 :fail)
1554 CHAPTER 12. TEST/CLOJURE
(condp = 1
2 :fail
1 :pass)
(condp = 1
2 :fail
:pass)
(condp = 1
:pass)
(condp = 1
2 :fail
;; doc of condp says result-expr is returned
;; shouldn’t it say similar to cond: "evaluates and returns
;; the value of the corresponding expr and doesn’t evaluate
;; any of the other tests or exprs."
(identity :pass))
(condp + 1
1 :>> #(if (= % 2) :pass :fail))
(condp + 1
1 :>> #(if (= % 3) :fail :pass))
)
(is (thrown? IllegalArgumentException
(condp = 1)
))
(is (thrown? IllegalArgumentException
(condp = 1
2 :fail)
))
)
; [for, doseq (for.clj)]
(deftest test-dotimes
;; dotimes always returns nil
(is (= nil (dotimes [n 1] n)))
;; test using an atom since dotimes is for modifying
;; test executes n times
(is (= 3
(let [a (atom 0)]
(dotimes [n 3]
(swap! a inc))
@a)
))
;; test all values of n
(is (= [0 1 2]
(let [a (atom [])]
(dotimes [n 3]
(swap! a conj n))
@a)))
(is (= []
12.10. TEST/CONTROL.CLJ 1555
(let [a (atom [])]
(dotimes [n 0]
(swap! a conj n))
@a)))
)
(deftest test-while
(is (= nil (while nil (throw (Exception. "never")))))
(is (= [0 nil]
;; a will dec to 0
;; while always returns nil
(let [a (atom 3)
w (while (pos? @a)
(swap! a dec))]
[@a w])))
(is (thrown? Exception
(while true (throw (Exception. "expected to throw")))))
)
; locking, monitor-enter, monitor-exit
; case
(deftest test-case
(testing "can match many kinds of things"
(let [two 2
test-fn
#(case %
1 :number
"foo" :string
\a :char
pow :symbol
:zap :keyword
(2 \b "bar") :one-of-many
[1 2] :sequential-thing
{:a 2} :map
{:r 2 :d 2} :droid
#{2 3 4 5} :set
[1 [[[2]]]] :deeply-nested
:default)]
(are [result input] (= result (test-fn input))
:number 1
:string "foo"
:char \a
:keyword :zap
:symbol ’pow
:one-of-many 2
:one-of-many \b
:one-of-many "bar"
:sequential-thing [1 2]
:sequential-thing (list 1 2)
1556 CHAPTER 12. TEST/CLOJURE
:sequential-thing [1 two]
:map {:a 2}
:map {:a two}
:set #{2 3 4 5}
:set #{two 3 4 5}
:default #{2 3 4 5 6}
:droid {:r 2 :d 2}
:deeply-nested [1 [[[two]]]]
:default :anything-not-appearing-above)))
(testing "throws IllegalArgumentException if no match"
(is (thrown-with-msg?
IllegalArgumentException #"No matching clause: 2"
(case 2 1 :ok))))
(testing "sorting doesn’t matter"
(let [test-fn
#(case %
{:b 2 :a 1} :map
#{3 2 1} :set
:default)]
(are [result input] (= result (test-fn input))
:map {:a 1 :b 2}
:map (sorted-map :a 1 :b 2)
:set #{3 2 1}
:set (sorted-set 2 1 3))))
(testing "test constants are *not* evaluated"
(let [test-fn
;; never write code like this...
#(case %
(throw (RuntimeException. "boom")) :piece-of-throw-exp r
:no-match)]
(are [result input] (= result (test-fn input))
:piece-of-throw-expr ’throw
:piece-of-throw-expr ’[RuntimeException. "boom"]
:no-match nil))))
———-
12.11 test/data.clj
— test/data.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.data
(:use clojure.data clojure.test))
(deftest diff-test
12.12. TEST/DATA˙STRUCTURES.CLJ 1557
(are [d x y] (= d (diff x y))
[nil nil nil] nil nil
[1 2 nil] 1 2
[nil nil [1 2 3]] [1 2 3] ’(1 2 3)
[1 [:a :b] nil] 1 [:a :b]
[{:a 1} :b nil] {:a 1} :b
[:team #{:p1 :p2} nil] :team #{:p1 :p2}
[{0 :a} [:a] nil] {0 :a} [:a]
[nil [nil 2] [1]] [1] [1 2]
[nil nil [1 2]] [1 2] (into-array [1 2])
[#{:a} #{:b} #{:c :d}] #{:a :c :d} #{:b :c :d}
[nil nil {:a 1}] {:a 1} {:a 1}
[{:a #{2}} {:a #{4}} {:a #{3}}] {:a #{2 3}} {:a #{3 4}}
[{:a {:c [1]}} {:a {:c [0]}}
{:a {:c [nil 2] :b 1}}]
{:a {:b 1 :c [1 2]}} {:a {:b 1 :c [0 2]}}))
———-
12.12 test/data˙structures.clj
— test/data˙structures.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.data-structures
(:use clojure.test))
;; *** Helper functions ***
(defn diff [s1 s2]
(seq (reduce disj (set s1) (set s2))))
;; *** General ***
(defstruct equality-struct :a :b)
(deftest test-equality
; nil is not equal to any other value
(are [x] (not (= nil x))
true false
1558 CHAPTER 12. TEST/CLOJURE
0 0.0
\space
"" #""
() [] #{} {}
(lazy-seq nil) ; SVN 1292: fixed (= (lazy-seq nil) nil)
(lazy-seq ())
(lazy-seq [])
(lazy-seq {})
(lazy-seq #{})
(lazy-seq "")
(lazy-seq (into-array []))
(new Object) )
; numbers equality across types (see tests below - NOT IMPLEM ENTED YET)
; ratios
(is (== 1/2 0.5))
(is (== 1/1000 0.001))
(is (not= 2/3 0.6666666666666666))
; vectors equal other seqs by items equality
(are [x y] (= x y)
’() [] ; regression fixed in r1208; was not equal
’(1) [1]
’(1 2) [1 2]
[] ’() ; same again, but vectors first
[1] ’(1)
[1 2] ’(1 2) )
(is (not= [1 2] ’(2 1))) ; order of items matters
; list and vector vs. set and map
(are [x y] (not= x y)
; only () equals []
() #{}
() {}
[] #{}
[] {}
#{} {}
; only ’(1) equals [1]
’(1) #{1}
[1] #{1} )
; sorted-map, hash-map and array-map - classes differ,
; but content is equal
;; TODO: reimplement all-are with new do-template?
;; (all-are (not= (class _1) (class _2))
;; (sorted-map :a 1)
;; (hash-map :a 1)
12.12. TEST/DATA˙STRUCTURES.CLJ 1559
;; (array-map :a 1))
;; (all-are (= _1 _2)
;; (sorted-map)
;; (hash-map)
;; (array-map))
;; (all-are (= _1 _2)
;; (sorted-map :a 1)
;; (hash-map :a 1)
;; (array-map :a 1))
;; (all-are (= _1 _2)
;; (sorted-map :a 1 :z 3 :c 2)
;; (hash-map :a 1 :z 3 :c 2)
;; (array-map :a 1 :z 3 :c 2))
; struct-map vs. sorted-map, hash-map and array-map
(are [x] (and (not= (class (struct equality-struct 1 2)) (cl ass x))
(= (struct equality-struct 1 2) x))
(sorted-map-by compare :a 1 :b 2)
(sorted-map :a 1 :b 2)
(hash-map :a 1 :b 2)
(array-map :a 1 :b 2))
; sorted-set vs. hash-set
(is (not= (class (sorted-set 1)) (class (hash-set 1))))
(are [x y] (= x y)
(sorted-set-by <) (hash-set)
(sorted-set-by < 1) (hash-set 1)
(sorted-set-by < 3 2 1) (hash-set 3 2 1)
(sorted-set) (hash-set)
(sorted-set 1) (hash-set 1)
(sorted-set 3 2 1) (hash-set 3 2 1) ))
;; *** Collections ***
(deftest test-count
(let [EMPTY clojure.lang.PersistentQueue/EMPTY]
(are [x y] (= (count x) y)
EMPTY 0
(into EMPTY [:a :b]) 2
(-> (into EMPTY [:a :b]) pop pop) 0
nil 0
() 0
’(1) 1
’(1 2 3) 3
[] 0
[1] 1
1560 CHAPTER 12. TEST/CLOJURE
[1 2 3] 3
#{} 0
#{1} 1
#{1 2 3} 3
{} 0
{:a 1} 1
{:a 1 :b 2 :c 3} 3
"" 0
"a" 1
"abc" 3
(into-array []) 0
(into-array [1]) 1
(into-array [1 2 3]) 3
(java.util.ArrayList. []) 0
(java.util.ArrayList. [1]) 1
(java.util.ArrayList. [1 2 3]) 3
(java.util.HashMap. {}) 0
(java.util.HashMap. {:a 1}) 1
(java.util.HashMap. {:a 1 :b 2 :c 3}) 3 ))
; different types
(are [x] (= (count [x]) 1)
nil true false
0 0.0 "" \space
() [] #{} {} ))
(deftest test-conj
; doesn’t work on strings or arrays
(is (thrown? ClassCastException (conj "" \a)))
(is (thrown? ClassCastException (conj (into-array []) 1)) )
(are [x y] (= x y)
(conj nil 1) ’(1)
(conj nil 3 2 1) ’(1 2 3)
(conj nil nil) ’(nil)
(conj nil nil nil) ’(nil nil)
(conj nil nil nil 1) ’(1 nil nil)
; list -> conj puts the item at the front of the list
(conj () 1) ’(1)
(conj () 1 2) ’(2 1)
12.12. TEST/DATA˙STRUCTURES.CLJ 1561
(conj ’(2 3) 1) ’(1 2 3)
(conj ’(2 3) 1 4 3) ’(3 4 1 2 3)
(conj () nil) ’(nil)
(conj () ()) ’(())
; vector -> conj puts the item at the end of the vector
(conj [] 1) [1]
(conj [] 1 2) [1 2]
(conj [2 3] 1) [2 3 1]
(conj [2 3] 1 4 3) [2 3 1 4 3]
(conj [] nil) [nil]
(conj [] []) [[]]
; map -> conj expects another (possibly single entry) map as t he
; item, and returns a new map which is the old map plus the
; entries from the new, which may overwrite entries of the old .
; conj also accepts a MapEntry or a vector of two items
;(key and value).
(conj {} {}) {}
(conj {} {:a 1}) {:a 1}
(conj {} {:a 1 :b 2}) {:a 1 :b 2}
(conj {} {:a 1 :b 2} {:c 3}) {:a 1 :b 2 :c 3}
(conj {} {:a 1 :b 2} {:a 3 :c 4}) {:a 3 :b 2 :c 4}
(conj {:a 1} {:a 7}) {:a 7}
(conj {:a 1} {:b 2}) {:a 1 :b 2}
(conj {:a 1} {:a 7 :b 2}) {:a 7 :b 2}
(conj {:a 1} {:a 7 :b 2} {:c 3}) {:a 7 :b 2 :c 3}
(conj {:a 1} {:a 7 :b 2} {:b 4 :c 5}) {:a 7 :b 4 :c 5}
(conj {} (first {:a 1})) {:a 1} ; MapEntry
(conj {:a 1} (first {:b 2})) {:a 1 :b 2}
(conj {:a 1} (first {:a 7})) {:a 7}
(conj {:a 1} (first {:b 2}) (first {:a 5})) {:a 5 :b 2}
(conj {} [:a 1]) {:a 1} ; vector
(conj {:a 1} [:b 2]) {:a 1 :b 2}
(conj {:a 1} [:a 7]) {:a 7}
(conj {:a 1} [:b 2] [:a 5]) {:a 5 :b 2}
(conj {} {nil {}}) {nil {}}
(conj {} {{} nil}) {{} nil}
(conj {} {{} {}}) {{} {}}
; set
(conj #{} 1) #{1}
1562 CHAPTER 12. TEST/CLOJURE
(conj #{} 1 2 3) #{1 2 3}
(conj #{2 3} 1) #{3 1 2}
(conj #{3 2} 1) #{1 2 3}
(conj #{2 3} 2) #{2 3}
(conj #{2 3} 2 3) #{2 3}
(conj #{2 3} 4 1 2 3) #{1 2 3 4}
(conj #{} nil) #{nil}
(conj #{} #{}) #{#{}} ))
;; *** Lists and Vectors ***
(deftest test-peek
; doesn’t work for sets and maps
(is (thrown? ClassCastException (peek #{1})))
(is (thrown? ClassCastException (peek {:a 1})))
(are [x y] (= x y)
(peek nil) nil
; list = first
(peek ()) nil
(peek ’(1)) 1
(peek ’(1 2 3)) 1
(peek ’(nil)) nil ; special cases
(peek ’(1 nil)) 1
(peek ’(nil 2)) nil
(peek ’(())) ()
(peek ’(() nil)) ()
(peek ’(() 2 nil)) ()
; vector = last
(peek []) nil
(peek [1]) 1
(peek [1 2 3]) 3
(peek [nil]) nil ; special cases
(peek [1 nil]) nil
(peek [nil 2]) 2
(peek [[]]) []
(peek [[] nil]) nil
(peek [[] 2 nil]) nil ))
(deftest test-pop
; doesn’t work for sets and maps
12.12. TEST/DATA˙STRUCTURES.CLJ 1563
(is (thrown? ClassCastException (pop #{1})))
(is (thrown? ClassCastException (pop #{:a 1})))
; collection cannot be empty
(is (thrown? IllegalStateException (pop ())))
(is (thrown? IllegalStateException (pop [])))
(are [x y] (= x y)
(pop nil) nil
; list - pop first
(pop ’(1)) ()
(pop ’(1 2 3)) ’(2 3)
(pop ’(nil)) ()
(pop ’(1 nil)) ’(nil)
(pop ’(nil 2)) ’(2)
(pop ’(())) ()
(pop ’(() nil)) ’(nil)
(pop ’(() 2 nil)) ’(2 nil)
; vector - pop last
(pop [1]) []
(pop [1 2 3]) [1 2]
(pop [nil]) []
(pop [1 nil]) [1]
(pop [nil 2]) [nil]
(pop [[]]) []
(pop [[] nil]) [[]]
(pop [[] 2 nil]) [[] 2] ))
;; *** Lists (IPersistentList) ***
(deftest test-list
(are [x] (list? x)
()
’()
(list)
(list 1 2 3) )
; order is important
(are [x y] (not (= x y))
(list 1 2) (list 2 1)
(list 3 1 2) (list 1 2 3) )
(are [x y] (= x y)
’() ()
(list) ’()
1564 CHAPTER 12. TEST/CLOJURE
(list 1) ’(1)
(list 1 2) ’(1 2)
; nesting
(list 1 (list 2 3) (list 3 (list 4 5 (list 6 (list 7)))))
’(1 (2 3) (3 (4 5 (6 (7)))))
; different data structures
(list true false nil)
’(true false nil)
(list 1 2.5 2/3 "ab" \x ’cd :kw)
’(1 2.5 2/3 "ab" \x cd :kw)
(list (list 1 2) [3 4] {:a 1 :b 2} #{:c :d})
’((1 2) [3 4] {:a 1 :b 2} #{:c :d})
; evaluation
(list (+ 1 2) [(+ 2 3) ’a] (list (* 2 3) 8))
’(3 [5 a] (6 8))
; special cases
(list nil) ’(nil)
(list 1 nil) ’(1 nil)
(list nil 2) ’(nil 2)
(list ()) ’(())
(list 1 ()) ’(1 ())
(list () 2) ’(() 2) ))
;; *** Maps (IPersistentMap) ***
(deftest test-find
(are [x y] (= x y)
(find {} :a) nil
(find {:a 1} :a) [:a 1]
(find {:a 1} :b) nil
(find {:a 1 :b 2} :a) [:a 1]
(find {:a 1 :b 2} :b) [:b 2]
(find {:a 1 :b 2} :c) nil
(find {} nil) nil
(find {:a 1} nil) nil
(find {:a 1 :b 2} nil) nil ))
(deftest test-contains?
; contains? is designed to work preferably on maps and sets
(are [x y] (= x y)
(contains? {} :a) false
12.12. TEST/DATA˙STRUCTURES.CLJ 1565
(contains? {} nil) false
(contains? {:a 1} :a) true
(contains? {:a 1} :b) false
(contains? {:a 1} nil) false
(contains? {:a 1 :b 2} :a) true
(contains? {:a 1 :b 2} :b) true
(contains? {:a 1 :b 2} :c) false
(contains? {:a 1 :b 2} nil) false
; sets
(contains? #{} 1) false
(contains? #{} nil) false
(contains? #{1} 1) true
(contains? #{1} 2) false
(contains? #{1} nil) false
(contains? #{1 2 3} 1) true
(contains? #{1 2 3} 3) true
(contains? #{1 2 3} 10) false
(contains? #{1 2 3} nil) false)
; numerically indexed collections (e.g. vectors and Java ar rays)
; => test if the numeric key is WITHIN THE RANGE OF INDEXES
(are [x y] (= x y)
(contains? [] 0) false
(contains? [] -1) false
(contains? [] 1) false
(contains? [1] 0) true
(contains? [1] -1) false
(contains? [1] 1) false
(contains? [1 2 3] 0) true
(contains? [1 2 3] 2) true
(contains? [1 2 3] 3) false
(contains? [1 2 3] -1) false
; arrays
(contains? (into-array []) 0) false
(contains? (into-array []) -1) false
(contains? (into-array []) 1) false
(contains? (into-array [1]) 0) true
(contains? (into-array [1]) -1) false
(contains? (into-array [1]) 1) false
(contains? (into-array [1 2 3]) 0) true
1566 CHAPTER 12. TEST/CLOJURE
(contains? (into-array [1 2 3]) 2) true
(contains? (into-array [1 2 3]) 3) false
(contains? (into-array [1 2 3]) -1) false)
; ’contains?’ operates constant or logarithmic time,
; it WILL NOT perform a linear search for a value.
(are [x] (= x false)
(contains? ’(1 2 3) 0)
(contains? ’(1 2 3) 1)
(contains? ’(1 2 3) 3)
(contains? ’(1 2 3) 10)
(contains? ’(1 2 3) nil)
(contains? ’(1 2 3) ()) ))
(deftest test-keys
(are [x y] (= x y) ; other than map data structures
(keys ()) nil
(keys []) nil
(keys #{}) nil
(keys "") nil )
(are [x y] (= x y)
; (class {:a 1}) => clojure.lang.PersistentArrayMap
(keys {}) nil
(keys {:a 1}) ’(:a)
; (keys {:a 1 :b 2}) ’(:a :b)
(diff (keys {:a 1 :b 2}) ’(:a :b)) nil
; (class (sorted-map :a 1)) => clojure.lang.PersistentTre eMap
(keys (sorted-map)) nil
(keys (sorted-map :a 1)) ’(:a)
; (keys (sorted-map :a 1 :b 2)) ’(:a :b)
(diff (keys (sorted-map :a 1 :b 2)) ’(:a :b)) nil
; (class (hash-map :a 1)) => clojure.lang.PersistentHashM ap
(keys (hash-map)) nil
(keys (hash-map :a 1)) ’(:a)
; (keys (hash-map :a 1 :b 2)) ’(:a :b)
(diff (keys (hash-map :a 1 :b 2)) ’(:a :b)) nil ))
(deftest test-vals
(are [x y] (= x y) ; other than map data structures
(vals ()) nil
(vals []) nil
(vals #{}) nil
(vals "") nil )
(are [x y] (= x y)
12.12. TEST/DATA˙STRUCTURES.CLJ 1567
; (class {:a 1}) => clojure.lang.PersistentArrayMap
(vals {}) nil
(vals {:a 1}) ’(1)
; (vals {:a 1 :b 2}) ’(1 2)
(diff (vals {:a 1 :b 2}) ’(1 2)) nil
; (class (sorted-map :a 1)) => clojure.lang.PersistentTre eMap
(vals (sorted-map)) nil
(vals (sorted-map :a 1)) ’(1)
; (vals (sorted-map :a 1 :b 2)) ’(1 2)
(diff (vals (sorted-map :a 1 :b 2)) ’(1 2)) nil
; (class (hash-map :a 1)) => clojure.lang.PersistentHashM ap
(vals (hash-map)) nil
(vals (hash-map :a 1)) ’(1)
; (vals (hash-map :a 1 :b 2)) ’(1 2)
(diff (vals (hash-map :a 1 :b 2)) ’(1 2)) nil ))
(deftest test-key
(are [x] (= (key (first (hash-map x :value))) x)
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} ))
(deftest test-val
(are [x] (= (val (first (hash-map :key x))) x)
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
1568 CHAPTER 12. TEST/CLOJURE
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} ))
(deftest test-get
(let [m {:a 1, :b 2, :c {:d 3, :e 4}, :f nil, :g false, nil {:h 5}}]
(is (thrown? IllegalArgumentException (get-in {:a 1} 5)))
(are [x y] (= x y)
(get m :a) 1
(get m :e) nil
(get m :e 0) 0
(get m :b 0) 2
(get m :f 0) nil
(get-in m [:c :e]) 4
(get-in m ’(:c :e)) 4
(get-in m [:c :x]) nil
(get-in m [:f]) nil
(get-in m [:g]) false
(get-in m [:h]) nil
(get-in m []) m
(get-in m nil) m
(get-in m [:c :e] 0) 4
(get-in m ’(:c :e) 0) 4
(get-in m [:c :x] 0) 0
(get-in m [:b] 0) 2
(get-in m [:f] 0) nil
(get-in m [:g] 0) false
(get-in m [:h] 0) 0
(get-in m [:x :y] {:y 1}) {:y 1}
(get-in m [] 0) m
(get-in m nil 0) m)))
;; *** Sets ***
(deftest test-hash-set
(are [x] (set? x)
#{}
#{1 2}
(hash-set)
(hash-set 1 2) )
; order isn’t important
(are [x y] (= x y)
#{1 2} #{2 1}
#{3 1 2} #{1 2 3}
(hash-set 1 2) (hash-set 2 1)
(hash-set 3 1 2) (hash-set 1 2 3) )
12.12. TEST/DATA˙STRUCTURES.CLJ 1569
(are [x y] (= x y)
; equal classes
(class #{}) (class (hash-set))
(class #{1 2}) (class (hash-set 1 2))
; creating
(hash-set) #{}
(hash-set 1) #{1}
(hash-set 1 2) #{1 2}
; nesting
(hash-set 1 (hash-set 2 3)
(hash-set 3 (hash-set 4 5 (hash-set 6 (hash-set 7)))))
#{1 #{2 3} #{3 #{4 5 #{6 #{7}}}}}
; different data structures
(hash-set true false nil)
#{true false nil}
(hash-set 1 2.5 2/3 "ab" \x ’cd :kw)
#{1 2.5 2/3 "ab" \x ’cd :kw}
(hash-set (list 1 2) [3 4] {:a 1 :b 2} #{:c :d})
#{’(1 2) [3 4] {:a 1 :b 2} #{:c :d}}
; evaluation
(hash-set (+ 1 2) [(+ 2 3) :a] (hash-set (* 2 3) 8))
#{3 [5 :a] #{6 8}}
; special cases
(hash-set nil) #{nil}
(hash-set 1 nil) #{1 nil}
(hash-set nil 2) #{nil 2}
(hash-set #{}) #{#{}}
(hash-set 1 #{}) #{1 #{}}
(hash-set #{} 2) #{#{} 2} ))
(deftest test-sorted-set
; only compatible types can be used
(is (thrown? ClassCastException (sorted-set 1 "a")))
(is (thrown? ClassCastException (sorted-set ’(1 2) [3 4])) )
; creates set?
(are [x] (set? x)
(sorted-set)
(sorted-set 1 2) )
; equal and unique
(are [x] (and (= (sorted-set x) #{x})
(= (sorted-set x x) (sorted-set x)))
1570 CHAPTER 12. TEST/CLOJURE
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ; ’(1 2)
[] [1 2]
{} ; {:a 1 :b 2}
#{} ; #{1 2}
)
; cannot be cast to java.lang.Comparable
(is (thrown? ClassCastException (sorted-set ’(1 2) ’(1 2)) ))
(is (thrown? ClassCastException (sorted-set {:a 1 :b 2} {:a 1 :b 2})))
(is (thrown? ClassCastException (sorted-set #{1 2} #{1 2}) ))
(are [x y] (= x y)
; generating
(sorted-set) #{}
(sorted-set 1) #{1}
(sorted-set 1 2) #{1 2}
; sorting
(seq (sorted-set 5 4 3 2 1)) ’(1 2 3 4 5)
; special cases
(sorted-set nil) #{nil}
(sorted-set 1 nil) #{nil 1}
(sorted-set nil 2) #{nil 2}
(sorted-set #{}) #{#{}} ))
(deftest test-sorted-set-by
; only compatible types can be used
; NB: not a ClassCastException, but a RuntimeException is th rown,
; requires discussion on whether this should be symmetric wi th
; test-sorted-set
(is (thrown? Exception (sorted-set-by < 1 "a")))
(is (thrown? Exception (sorted-set-by < ’(1 2) [3 4])))
; creates set?
(are [x] (set? x)
(sorted-set-by <)
(sorted-set-by < 1 2) )
12.12. TEST/DATA˙STRUCTURES.CLJ 1571
; equal and unique
(are [x] (and (= (sorted-set-by compare x) #{x})
(= (sorted-set-by compare x x)
(sorted-set-by compare x)))
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ; ’(1 2)
[] [1 2]
{} ; {:a 1 :b 2}
#{} ; #{1 2}
)
; cannot be cast to java.lang.Comparable
; NB: not a ClassCastException, but a RuntimeException is th rown,
; requires discussion on whether this should be symmetric wi th
; test-sorted-set
(is (thrown? Exception (sorted-set-by compare ’(1 2) ’(1 2) )))
(is (thrown? Exception (sorted-set-by compare {:a 1 :b 2}
{:a 1 :b 2})))
(is (thrown? Exception (sorted-set-by compare #{1 2} #{1 2} )))
(are [x y] (= x y)
; generating
(sorted-set-by >) #{}
(sorted-set-by > 1) #{1}
(sorted-set-by > 1 2) #{1 2}
; sorting
(seq (sorted-set-by < 5 4 3 2 1)) ’(1 2 3 4 5)
; special cases
(sorted-set-by compare nil) #{nil}
(sorted-set-by compare 1 nil) #{nil 1}
(sorted-set-by compare nil 2) #{nil 2}
(sorted-set-by compare #{}) #{#{}} ))
(deftest test-set
; set?
(are [x] (set? (set x))
() ’(1 2)
[] [1 2]
1572 CHAPTER 12. TEST/CLOJURE
#{} #{1 2}
{} {:a 1 :b 2}
(into-array []) (into-array [1 2])
"" "abc" )
; unique
(are [x] (= (set [x x]) #{x})
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} )
; conversion
(are [x y] (= (set x) y)
() #{}
’(1 2) #{1 2}
[] #{}
[1 2] #{1 2}
#{} #{} ; identity
#{1 2} #{1 2} ; identity
{} #{}
{:a 1 :b 2} #{[:a 1] [:b 2]}
(into-array []) #{}
(into-array [1 2]) #{1 2}
"" #{}
"abc" #{\a \b \c} ))
(deftest test-disj
; doesn’t work on lists, vectors or maps
(is (thrown? ClassCastException (disj ’(1 2) 1)))
(is (thrown? ClassCastException (disj [1 2] 1)))
(is (thrown? ClassCastException (disj {:a 1} :a)))
; identity
12.12. TEST/DATA˙STRUCTURES.CLJ 1573
(are [x] (= (disj x) x)
nil
#{}
#{1 2 3}
; different data types
#{nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
"" "abc"
’sym
:kw
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2}} )
; type identity
(are [x] (= (class (disj x)) (class x))
(hash-set)
(hash-set 1 2)
(sorted-set)
(sorted-set 1 2) )
(are [x y] (= x y)
(disj nil :a) nil
(disj nil :a :b) nil
(disj #{} :a) #{}
(disj #{} :a :b) #{}
(disj #{:a} :a) #{}
(disj #{:a} :a :b) #{}
(disj #{:a} :c) #{:a}
(disj #{:a :b :c :d} :a) #{:b :c :d}
(disj #{:a :b :c :d} :a :d) #{:b :c}
(disj #{:a :b :c :d} :a :b :c) #{:d}
(disj #{:a :b :c :d} :d :a :c :b) #{}
(disj #{nil} :a) #{nil}
(disj #{nil} #{}) #{nil}
(disj #{nil} nil) #{}
(disj #{#{}} nil) #{#{}}
(disj #{#{}} #{}) #{}
(disj #{#{nil}} #{nil}) #{} ))
1574 CHAPTER 12. TEST/CLOJURE
;; *** Queues ***
(deftest test-queues
(let [EMPTY clojure.lang.PersistentQueue/EMPTY]
(are [x y] (= x y)
EMPTY EMPTY
(into EMPTY (range 50)) (into EMPTY (range 50))
(range 5) (into EMPTY (range 5))
(range 1 6) (-> EMPTY
(into (range 6))
pop))
(are [x y] (not= x y)
(range 5) (into EMPTY (range 6))
(range 6) (into EMPTY (range 5))
(range 0 6) (-> EMPTY
(into (range 6))
pop)
(range 1 6) (-> EMPTY
(into (range 7))
pop))))
———-
12.13 test/def.clj
— test/def.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.def
(:use clojure.test clojure.test-helper
clojure.test-clojure.protocols))
(deftest defn-error-messages
(testing "bad arglist forms"
(is (fails-with-cause? IllegalArgumentException
’#"Parameter declaration arg1 should be a vector"
(eval-in-temp-ns (defn foo (arg1 arg2)))))))
(deftest dynamic-redefinition
;; too many contextual things for this kind of caching to work ...
(testing "classes are never cached, even if their bodies are the same"
(is (= :b
(eval
’(do
12.14. TEST/ERRORS.CLJ 1575
(defmacro my-macro [] :a)
(defn do-macro [] (my-macro))
(defmacro my-macro [] :b)
(defn do-macro [] (my-macro))
(do-macro)))))))
———-
12.14 test/errors.clj
— test/errors.clj —
\getchunk{Clojure Copyright}
;; Tests for error handling and messages
(ns clojure.test-clojure.errors
(:use clojure.test)
(:import clojure.lang.ArityException))
(defn f0 [] 0)
(defn f1 [a] a)
(defmacro m0 [] ‘(identity 0))
(defmacro m1 [a] ‘(inc ~a))
(deftest arity-exception
;; IllegalArgumentException is pre-1.3
(is (thrown-with-msg? IllegalArgumentException
#"Wrong number of args \(1\) passed to"
(f0 1)))
(is (thrown-with-msg? ArityException
#"Wrong number of args \(0\) passed to"
(f1)))
(is (thrown-with-msg? ArityException
#"Wrong number of args \(1\) passed to"
(macroexpand ‘(m0 1))))
(is (thrown-with-msg? ArityException
#"Wrong number of args \(2\) passed to"
(macroexpand ‘(m1 1 2)))))
———-
1576 CHAPTER 12. TEST/CLOJURE
12.15 test/evaluation.clj
— test/evaluation.clj —
\getchunk{Clojure Copyright}
;; Tests for the Clojure functions documented at the URL:
;;
;; http://clojure.org/Evaluation
;;
;; by J. McConnell
;; Created 22 October 2008
(ns clojure.test-clojure.evaluation
(:use clojure.test))
(import ’(java.lang Boolean)
’(clojure.lang Compiler Compiler$CompilerException))
(defmacro test-that
"Provides a useful way for specifying the purpose of tests. I f the
first-level forms are lists that make a call to a clojure.tes t
function, it supplies the purpose as the msg argument to thos e
functions. Otherwise, the purpose just acts like a comment a nd
the forms are run unchanged."
[purpose & test-forms]
(let [tests (map
#(if (= (:ns (meta (resolve (first %))))
(the-ns ’clojure.test))
(concat % (list purpose))
%)
test-forms)]
‘(do ~@tests)))
(deftest Eval
(is (= (eval ’(+ 1 2 3)) (Compiler/eval ’(+ 1 2 3))))
(is (= (eval ’(list 1 2 3)) ’(1 2 3)))
(is (= (eval ’(list + 1 2 3)) (list clojure.core/+ 1 2 3)))
(test-that "Non-closure fns are supported as code"
(is (= (eval (eval ’(list + 1 2 3))) 6)))
(is (= (eval (list ’+ 1 2 3)) 6)))
; not using Clojure’s RT/classForName since a bug in it could hide
; a bug in eval’s resolution
(defn class-for-name [name]
(java.lang.Class/forName name))
(defmacro in-test-ns [& body]
12.15. TEST/EVALUATION.CLJ 1577
‘(binding [*ns* *ns*]
(in-ns ’clojure.test-clojure.evaluation)
~@body))
;;; Literals tests ;;;
(defmacro #^{:private true} evaluates-to-itself? [expr]
‘(let [v# ~expr
q# (quote ~expr)]
(is (= (eval q#) q#) (str q# " does not evaluate to itself"))))
(deftest Literals
; Strings, numbers, characters, nil and keywords should eva luate
; to themselves
(evaluates-to-itself? "test")
(evaluates-to-itself? "test
multi-line
string")
(evaluates-to-itself? 1)
(evaluates-to-itself? 1.0)
(evaluates-to-itself? 1.123456789)
(evaluates-to-itself? 1/2)
(evaluates-to-itself? 1M)
(evaluates-to-itself? 999999999999999999)
(evaluates-to-itself? \a)
(evaluates-to-itself? \newline)
(evaluates-to-itself? nil)
(evaluates-to-itself? :test)
; Boolean literals should evaluate to Boolean.{TRUE|FALSE }
(is (identical? (eval true) Boolean/TRUE))
(is (identical? (eval false) Boolean/FALSE)))
;;; Symbol resolution tests ;;;
(def foo "abc")
(in-ns ’resolution-test)
(def bar 123)
(def #^{:private true} baz 456)
(in-ns ’clojure.test-clojure.evaluation)
(defn a-match? [re s] (not (nil? (re-matches re s))))
(defmacro throws-with-msg
([re form] ‘(throws-with-msg ~re ~form Exception))
([re form x] ‘(throws-with-msg
~re
~form
~(if (instance? Exception x) x Exception)
~(if (instance? String x) x nil)))
([re form class msg]
1578 CHAPTER 12. TEST/CLOJURE
‘(let [ex# (try
~form
(catch ~class e# e#)
(catch Exception e#
(let [cause# (.getCause e#)]
(if (= ~class (class cause#)) cause# (throw e#)))))]
(is (a-match? ~re (.toString ex#))
(or ~msg
(str "Expected exception that matched " (pr-str ~re)
", but got exception with message: \"" ex#))))))
(deftest SymbolResolution
(test-that
"If a symbol is namespace-qualified, the evaluated value is the value
of the binding of the global var named by the symbol"
(is (= (eval ’resolution-test/bar) 123)))
(test-that
"It is an error if there is no global var named by the symbol"
(throws-with-msg
#".*Unable to resolve symbol: bar.*" (eval ’bar)))
(test-that
"It is an error if the symbol reference is to a non-public var i n a
different namespace"
(throws-with-msg
#".*resolution-test/baz is not public.*"
(eval ’resolution-test/baz)
Compiler$CompilerException))
(test-that
"If a symbol is package-qualified, its value is the Java clas s
named by the symbol"
(is (= (eval ’java.lang.Math) (class-for-name "java.lang .Math"))))
(test-that
"If a symbol is package-qualified, it is an error if there is
no Class named by the symbol"
(is (thrown? Compiler$CompilerException (eval ’java.lan g.FooBar))))
(test-that
"If a symbol is not qualified, the following applies, in this order:
1. If it names a special form it is considered a special form,
and must be utilized accordingly.
2. A lookup is done in the current namespace to see if there is
a mapping from the symbol to a class. If so, the symbol is
considered to name a Java class object.
12.15. TEST/EVALUATION.CLJ 1579
3. If in a local scope (i.e. in a function definition), a looku p
is done to see if it names a local binding (e.g. a function
argument or let-bound name). If so, the value is the value of
the local binding.
4. A lookup is done in the current namespace to see if there is
a mapping from the symbol to a var. If so, the value is the
value of the binding of the var referred-to by the symbol.
5. It is an error."
; First
(doall (for [form ’(def if do let quote var fn loop recur throw try
monitor-enter monitor-exit)]
(is (thrown? Compiler$CompilerException (eval form)))))
(let [if "foo"]
(is (thrown? Compiler$CompilerException (eval ’if)))
; Second
(is (= (eval ’Boolean) (class-for-name "java.lang.Boolea n"))))
(let [Boolean "foo"]
(is (= (eval ’Boolean) (class-for-name "java.lang.Boolea n"))))
; Third
(is (= (eval ’(let [foo "bar"] foo)) "bar"))
; Fourth
(in-test-ns (is (= (eval ’foo) "abc")))
(is (thrown? Compiler$CompilerException
(eval ’bar))) ; not in this namespace
; Fifth
(is (thrown? Compiler$CompilerException (eval ’foobar)) )))
;;; Metadata tests ;;;
(defstruct struct-with-symbols (with-meta ’k {:a "A"}))
(deftest Metadata
(test-that
"find returns key symbols and their metadata"
(let [s (struct struct-with-symbols 1)]
(is (= {:a "A"} (meta (first (find s ’k))))))))
;;; Collections tests ;;;
(def x 1)
(def y 2)
(deftest Collections
1580 CHAPTER 12. TEST/CLOJURE
(in-test-ns
(test-that
"Vectors and Maps yield vectors and (hash) maps whose conten ts
are the evaluated values of the objects they contain."
(is (= (eval ’[x y 3]) [1 2 3]))
(is (= (eval ’{:x x :y y :z 3}) {:x 1 :y 2 :z 3}))
(is (instance? clojure.lang.IPersistentMap (eval ’{:x x : y y})))))
(in-test-ns
(test-that
"Metadata maps yield maps whose contents are the evaluated v alues
of the objects they contain. If a vector or map has metadata, t he
evaluated metadata map will become the metadata of the resul ting
value."
(is (= (eval #^{:x x} ’[x y]) #^{:x 1} [1 2]))))
(test-that
"An empty list () evaluates to an empty list."
(is (= (eval ’()) ()))
(is (empty? (eval ())))
(is (= (eval (list)) ())))
;aargh, fragile tests, please fix
#_(test-that
"Non-empty lists are considered calls"
(is (thrown? Compiler$CompilerException (eval ’(1 2 3)))) ))
(deftest Macros)
(deftest Loading)
———-
12.16 test/for.clj
— test/for.clj —
\getchunk{Clojure Copyright}
;; Tests for the Clojure ’for’ macro
;;
;; by Chouser
;; Created Dec 2008
(ns clojure.test-clojure.for
(:use clojure.test))
12.16. TEST/FOR.CLJ 1581
(deftest Docstring-Example
(is (= (take 100 (for [x (range 100000000)
y (range 1000000) :while (< y x)]
[x y]))
’([1 0] [2 0] [2 1] [3 0] [3 1] [3 2] [4 0] [4 1] [4 2] [4 3]
[5 0] [5 1] [5 2] [5 3] [5 4]
[6 0] [6 1] [6 2] [6 3] [6 4] [6 5]
[7 0] [7 1] [7 2] [7 3] [7 4] [7 5] [7 6]
[8 0] [8 1] [8 2] [8 3] [8 4] [8 5] [8 6] [8 7]
[9 0] [9 1] [9 2] [9 3] [9 4] [9 5] [9 6] [9 7] [9 8]
[10 0] [10 1] [10 2] [10 3] [10 4] [10 5] [10 6] [10 7]
[10 8] [10 9]
[11 0] [11 1] [11 2] [11 3] [11 4] [11 5] [11 6] [11 7]
[11 8] [11 9] [11 10]
[12 0] [12 1] [12 2] [12 3] [12 4] [12 5] [12 6] [12 7]
[12 8] [12 9] [12 10] [12 11]
[13 0] [13 1] [13 2] [13 3] [13 4] [13 5] [13 6] [13 7]
[13 8] [13 9] [13 10] [13 11] [13 12]
[14 0] [14 1] [14 2] [14 3] [14 4] [14 5] [14 6] [14 7]
[14 8]))))
(defmacro deftest-both [txt & ises]
‘(do
(deftest ~(symbol (str "For-" txt)) ~@ises)
(deftest ~(symbol (str "Doseq-" txt))
~@(map (fn [[x-is [x-= [x-for binds body] value]]]
(when (and (= x-is ’is) (= x-= ’=) (= x-for ’for))
‘(is (= (let [acc# (atom [])]
(doseq ~binds (swap! acc# conj ~body))
@acc#)
~value))))
ises))))
(deftest-both When
(is (= (for [x (range 10) :when (odd? x)] x) ’(1 3 5 7 9)))
(is (= (for [x (range 4) y (range 4) :when (odd? y)] [x y])
’([0 1] [0 3] [1 1] [1 3] [2 1] [2 3] [3 1] [3 3])))
(is (= (for [x (range 4) y (range 4) :when (odd? x)] [x y])
’([1 0] [1 1] [1 2] [1 3] [3 0] [3 1] [3 2] [3 3])))
(is (= (for [x (range 4) :when (odd? x) y (range 4)] [x y])
’([1 0] [1 1] [1 2] [1 3] [3 0] [3 1] [3 2] [3 3])))
(is (= (for [x (range 5) y (range 5) :when (< x y)] [x y])
’([0 1] [0 2] [0 3] [0 4] [1 2] [1 3] [1 4] [2 3] [2 4] [3 4]))))
(defn only
"Returns a lazy seq of increasing ints starting at 0. Trying t o get
the nth+1 value of the seq throws an exception. This is meant t o
help detecting over-eagerness in lazy seq consumers."
[n]
(lazy-cat (range n)
1582 CHAPTER 12. TEST/CLOJURE
(throw (Exception. "consumer went too far in lazy seq"))))
(deftest-both While
(is (= (for [x (only 6) :while (< x 5)] x) ’(0 1 2 3 4)))
(is (= (for [x (range 4) y (only 4) :while (< y 3)] [x y])
’([0 0] [0 1] [0 2] [1 0] [1 1] [1 2]
[2 0] [2 1] [2 2] [3 0] [3 1] [3 2])))
(is (= (for [x (range 4) y (range 4) :while (< x 3)] [x y])
’([0 0] [0 1] [0 2] [0 3] [1 0] [1 1] [1 2] [1 3]
[2 0] [2 1] [2 2] [2 3])))
(is (= (for [x (only 4) :while (< x 3) y (range 4)] [x y])
’([0 0] [0 1] [0 2] [0 3] [1 0] [1 1] [1 2] [1 3]
[2 0] [2 1] [2 2] [2 3])))
(is (= (for [x (range 4) y (range 4) :while (even? x)] [x y])
’([0 0] [0 1] [0 2] [0 3] [2 0] [2 1] [2 2] [2 3])))
(is (= (for [x (only 2) :while (even? x) y (range 4)] [x y])
’([0 0] [0 1] [0 2] [0 3])))
(is (= (for [x (range 4) y (only 4) :while (< y x)] [x y])
’([1 0] [2 0] [2 1] [3 0] [3 1] [3 2]))))
(deftest-both While-and-When
(is
(= (for [x (only 6) :while (< x 5) y (range 4) :when (odd? y)] [x y ])
’([0 1] [0 3] [1 1] [1 3] [2 1] [2 3] [3 1] [3 3] [4 1] [4 3])))
(is
(= (for [x (range 4) :when (odd? x) y (only 6) :while (< y 5)] [x y ])
’([1 0] [1 1] [1 2] [1 3] [1 4] [3 0] [3 1] [3 2] [3 3] [3 4])))
(is
(= (for [x (only 6) :while (< x 5) y (range 4) :when (odd? (+ x y)) ]
[x y])
’([0 1] [0 3] [1 0] [1 2] [2 1] [2 3] [3 0] [3 2] [4 1] [4 3])))
(is
(= (for [x (range 4) :when (odd? x) y (only 2) :while (odd? (+ x y ))]
[x y])
’([1 0] [3 0]))))
(deftest-both While-and-When-Same-Binding
(is (= (for [x (only 6) :while (< x 5) :when (odd? x)] x) ’(1 3)))
(is (= (for [x (only 6)
:while (< x 5) ; if :while is false, :when should not be evaled
:when (do (if (< x 5) (odd? x)))] x) ’(1 3)))
(is (= (for [a (range -2 5)
:when (not= a 0) ; :when may guard :while
:while (> (Math/abs (/ 1.0 a)) 1/3)] a) ’(-2 -1 1 2))))
(deftest-both Nesting
(is (= (for [x ’(a b) y (interpose x ’(1 2)) z (list x y)] [x y z])
’([a 1 a] [a 1 1] [a a a] [a a a] [a 2 a] [a 2 2]
[b 1 b] [b 1 1] [b b b] [b b b] [b 2 b] [b 2 2])))
(is (= (for [x [’a nil] y [x ’b]] [x y])
12.17. TEST/GENCLASS.CLJ 1583
’([a a] [a b] [nil nil] [nil b]))))
(deftest-both Destructuring
(is (= (for [{:syms [a b c]}
(map #(zipmap ’(a b c) (range % 5)) (range 3))
x [a b c]]
(Integer. (str a b c x)))
’(120 121 122 1231 1232 1233 2342 2343 2344))))
(deftest-both Let
(is (= (for [x (range 3) y (range 3) :let [z (+ x y)]
:when (odd? z)] [x y z])
’([0 1 1] [1 0 1] [1 2 3] [2 1 3])))
(is (= (for [x (range 6) :let [y (rem x 2)]
:when (even? y) z [8 9]] [x z])
’([0 8] [0 9] [2 8] [2 9] [4 8] [4 9]))))
; :while must skip all subsequent chunks as well as the remain der of
; the current chunk:
(deftest-both Chunked-While
(is (= (for [x (range 100) :while (even? x)] x) ’(0))))
———-
12.17 test/genclass.clj
— test/genclass.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "Tests for clojure.core/gen-class"
:author "Stuart Halloway, Daniel Solano Gmez"}
clojure.test-clojure.genclass
(:use clojure.test clojure.test-helper)
(:import [clojure.test_clojure.genclass.examples Exam pleClass
ExampleAnnotationClass]
[java.lang.annotation ElementType
Retention
RetentionPolicy
Target]))
(deftest arg-support
(let [example (ExampleClass.)
o (Object.)]
(is (= "foo with o, o" (.foo example o o)))
(is (= "foo with o, i" (.foo example o (int 1))))
(is (thrown? java.lang.UnsupportedOperationException
1584 CHAPTER 12. TEST/CLOJURE
(.foo example o)))))
(deftest name-munging
(testing "mapping from Java fields to Clojure vars"
(is (= #’clojure.test-clojure.genclass.examples/-foo- Object-int
(get-field ExampleClass ’foo_Object_int__var)))
(is (= #’clojure.test-clojure.genclass.examples/-toSt ring
(get-field ExampleClass ’toString__var)))))
;todo - fix this, it depends on the order of things out of a hash -map
#_(deftest test-annotations
(let [annot-class ExampleAnnotationClass
foo-method
(.getDeclaredMethod annot-class "foo" (into-array [Stri ng]))]
(testing "Class annotations:"
(is (= 2 (count (.getDeclaredAnnotations annot-class))))
(testing "@Deprecated"
(let [deprecated (.getAnnotation annot-class Deprecated )]
(is deprecated)))
(testing "@Target([])"
(let [resource (.getAnnotation annot-class Target)]
(is (= 0 (count (.value resource)))))))
(testing "Method annotations:"
(testing "@Deprecated void foo(String):"
(is (= 1 (count (.getDeclaredAnnotations foo-method))))
(is (.getAnnotation foo-method Deprecated))))
(testing "Parameter annotations:"
(let [param-annots (.getParameterAnnotations foo-metho d)]
(is (= 1 (alength param-annots)))
(let [first-param-annots (aget param-annots 0)]
(is (= 2 (alength first-param-annots)))
(testing "void foo(@Retention() String)"
(let [retention (aget first-param-annots 0)]
(is (instance? Retention retention))
(= RetentionPolicy/SOURCE (.value retention))))
(testing "void foo(@Target() String)"
(let [target (aget first-param-annots 1)]
(is (instance? Target target))
(is (= [ElementType/TYPE ElementType/PARAMETER]
(seq (.value target)))))))))))
(deftest genclass-option-validation
(is (fails-with-cause? IllegalArgumentException
#"Not a valid method name: has-hyphen"
(@#’clojure.core/validate-generate-class-options
{:methods ’[[fine [] void] [has-hyphen [] void]]}))))
———-
12.18. TEST/JAVA˙INTEROP.CLJ 1585
12.18 test/java˙interop.clj
— test/java˙interop.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.java-interop
(:use clojure.test))
; http://clojure.org/java_interop
; http://clojure.org/compilation
(deftest test-dot
; (.instanceMember instance args*)
(are [x] (= x "FRED")
(.toUpperCase "fred")
(. "fred" toUpperCase)
(. "fred" (toUpperCase)) )
(are [x] (= x true)
(.startsWith "abcde" "ab")
(. "abcde" startsWith "ab")
(. "abcde" (startsWith "ab")) )
; (.instanceMember Classname args*)
(are [x] (= x "java.lang.String")
(.getName String)
(. (identity String) getName)
(. (identity String) (getName)) )
; (Classname/staticMethod args*)
(are [x] (= x 7)
(Math/abs -7)
(. Math abs -7)
(. Math (abs -7)) )
; Classname/staticField
(are [x] (= x 2147483647)
Integer/MAX_VALUE
(. Integer MAX_VALUE) ))
(deftest test-double-dot
(is (= (.. System (getProperties) (get "os.name"))
1586 CHAPTER 12. TEST/CLOJURE
(. (. System (getProperties)) (get "os.name")))))
(deftest test-doto
(let [m (doto (new java.util.HashMap)
(.put "a" 1)
(.put "b" 2))]
(are [x y] (= x y)
(class m) java.util.HashMap
m {"a" 1 "b" 2} )))
(deftest test-new
; Integer
(are [expr cls value] (and (= (class expr) cls)
(= expr value))
(new java.lang.Integer 42) java.lang.Integer 42
(java.lang.Integer. 123) java.lang.Integer 123 )
; Date
(are [x] (= (class x) java.util.Date)
(new java.util.Date)
(java.util.Date.) ))
(deftest test-instance?
; evaluation
(are [x y] (= x y)
(instance? java.lang.Integer (+ 1 2)) false
(instance? java.lang.Long (+ 1 2)) true )
; different types
(are [type literal] (instance? literal type)
1 java.lang.Long
1.0 java.lang.Double
1M java.math.BigDecimal
\a java.lang.Character
"a" java.lang.String )
; it is a Long, nothing else
(are [x y] (= (instance? x 42) y)
java.lang.Integer false
java.lang.Long true
java.lang.Character false
java.lang.String false ))
; set!
; memfn
12.18. TEST/JAVA˙INTEROP.CLJ 1587
(deftest test-bean
(let [b (bean java.awt.Color/black)]
(are [x y] (= x y)
(map? b) true
(:red b) 0
(:green b) 0
(:blue b) 0
(:RGB b) -16777216
(:alpha b) 255
(:transparency b) 1
(:class b) java.awt.Color )))
; proxy, proxy-super
(deftest test-proxy-chain
(testing "That the proxy functions can chain"
(are [x y] (= x y)
(-> (get-proxy-class Object)
construct-proxy
(init-proxy {})
(update-proxy {"toString" (fn [_] "chain chain chain")})
str)
"chain chain chain"
(-> (proxy [Object] [] (toString [] "superfuzz bigmuff"))
(update-proxy {"toString" (fn [_] "chain chain chain")})
str)
"chain chain chain")))
(deftest test-bases
(are [x y] (= x y)
(bases java.lang.Math)
(list java.lang.Object)
(bases java.lang.Integer)
(list java.lang.Number java.lang.Comparable) ))
(deftest test-supers
(are [x y] (= x y)
(supers java.lang.Math)
#{java.lang.Object}
(supers java.lang.Integer)
#{java.lang.Number java.lang.Object
java.lang.Comparable java.io.Serializable} ))
1588 CHAPTER 12. TEST/CLOJURE
; Arrays: [alength] aget aset [make-array to-array into-ar ray
; to-array-2d aclone] [float-array, int-array, etc]
; amap, areduce
(defmacro deftest-type-array [type-array type]
‘(deftest ~(symbol (str "test-" type-array))
; correct type
#_(is (= (class (first (~type-array [1 2]))) (class (~type 1 ))))
; given size (and empty)
(are [x] (and (= (alength (~type-array x)) x)
(= (vec (~type-array x)) (repeat x 0)))
0 1 5 )
; copy of a sequence
(are [x] (and (= (alength (~type-array x)) (count x))
(= (vec (~type-array x)) x))
[]
[1]
[1 -2 3 0 5] )
; given size and init-value
(are [x] (and (= (alength (~type-array x 42)) x)
(= (vec (~type-array x 42)) (repeat x 42)))
0 1 5 )
; given size and init-seq
(are [x y z] (and (= (alength (~type-array x y)) x)
(= (vec (~type-array x y)) z))
0 [] []
0 [1] []
0 [1 2 3] []
1 [] [0]
1 [1] [1]
1 [1 2 3] [1]
5 [] [0 0 0 0 0]
5 [1] [1 0 0 0 0]
5 [1 2 3] [1 2 3 0 0]
5 [1 2 3 4 5] [1 2 3 4 5]
5 [1 2 3 4 5 6 7] [1 2 3 4 5] )))
(deftest-type-array int-array int)
(deftest-type-array long-array long)
;todo, fix, test broken for float/double, should compare to 1.0 2.0 etc
#_(deftest-type-array float-array float)
#_(deftest-type-array double-array double)
; separate test for exceptions (doesn’t work with above macr o...)
12.18. TEST/JAVA˙INTEROP.CLJ 1589
(deftest test-type-array-exceptions
(are [x] (thrown? NegativeArraySizeException x)
(int-array -1)
(long-array -1)
(float-array -1)
(double-array -1) ))
(deftest test-make-array
; negative size
(is (thrown? NegativeArraySizeException (make-array Int eger -1)))
; one-dimensional
(are [x] (= (alength (make-array Integer x)) x)
0 1 5 )
(let [a (make-array Long 5)]
(aset a 3 42)
(are [x y] (= x y)
(aget a 3) 42
(class (aget a 3)) Long ))
; multi-dimensional
(let [a (make-array Long 3 2 4)]
(aset a 0 1 2 987)
(are [x y] (= x y)
(alength a) 3
(alength (first a)) 2
(alength (first (first a))) 4
(aget a 0 1 2) 987
(class (aget a 0 1 2)) Long )))
(deftest test-to-array
(let [v [1 "abc" :kw \c []]
a (to-array v)]
(are [x y] (= x y)
; length
(alength a) (count v)
; content
(vec a) v
(class (aget a 0)) (class (nth v 0))
(class (aget a 1)) (class (nth v 1))
(class (aget a 2)) (class (nth v 2))
(class (aget a 3)) (class (nth v 3))
(class (aget a 4)) (class (nth v 4)) ))
; different kinds of collections
1590 CHAPTER 12. TEST/CLOJURE
(are [x] (and (= (alength (to-array x)) (count x))
(= (vec (to-array x)) (vec x)))
()
’(1 2)
[]
[1 2]
(sorted-set)
(sorted-set 1 2)
(int-array 0)
(int-array [1 2 3])
(to-array [])
(to-array [1 2 3]) ))
(deftest test-into-array
; compatible types only
(is (thrown? IllegalArgumentException
(into-array [1 "abc" :kw])))
(is (thrown? IllegalArgumentException
(into-array [1.2 4])))
(is (thrown? IllegalArgumentException
(into-array [(byte 2) (short 3)])))
(is (thrown? IllegalArgumentException
(into-array Byte/TYPE [100000000000000])))
; simple case
(let [v [1 2 3 4 5]
a (into-array v)]
(are [x y] (= x y)
(alength a) (count v)
(vec a) v
(class (first a)) (class (first v)) ))
(is (= \a (aget (into-array Character/TYPE [\a \b \c]) 0)))
(let [types [Integer/TYPE
Byte/TYPE
Float/TYPE
Short/TYPE
Double/TYPE
Long/TYPE]
values [(byte 2) (short 3) (int 4) 5]]
(for [t types]
(let [a (into-array t values)]
(is (== (aget a 0) 2))
(is (== (aget a 1) 3))
(is (== (aget a 2) 4))
(is (== (aget a 3) 5)))))
12.18. TEST/JAVA˙INTEROP.CLJ 1591
; different kinds of collections
(are [x] (and (= (alength (into-array x)) (count x))
(= (vec (into-array x)) (vec x))
(= (alength (into-array Long/TYPE x)) (count x))
(= (vec (into-array Long/TYPE x)) (vec x)))
()
’(1 2)
[]
[1 2]
(sorted-set)
(sorted-set 1 2)
(int-array 0)
(int-array [1 2 3])
(to-array [])
(to-array [1 2 3]) ))
(deftest test-to-array-2d
; needs to be a collection of collection(s)
(is (thrown? Exception (to-array-2d [1 2 3])))
; ragged array
(let [v [[1] [2 3] [4 5 6]]
a (to-array-2d v)]
(are [x y] (= x y)
(alength a) (count v)
(alength (aget a 0)) (count (nth v 0))
(alength (aget a 1)) (count (nth v 1))
(alength (aget a 2)) (count (nth v 2))
(vec (aget a 0)) (nth v 0)
(vec (aget a 1)) (nth v 1)
(vec (aget a 2)) (nth v 2) ))
; empty array
(let [a (to-array-2d [])]
(are [x y] (= x y)
(alength a) 0
(vec a) [] )))
(deftest test-alength
(are [x] (= (alength x) 0)
(int-array 0)
(long-array 0)
(float-array 0)
(double-array 0)
1592 CHAPTER 12. TEST/CLOJURE
(boolean-array 0)
(byte-array 0)
(char-array 0)
(short-array 0)
(make-array Integer/TYPE 0)
(to-array [])
(into-array [])
(to-array-2d []) )
(are [x] (= (alength x) 1)
(int-array 1)
(long-array 1)
(float-array 1)
(double-array 1)
(boolean-array 1)
(byte-array 1)
(char-array 1)
(short-array 1)
(make-array Integer/TYPE 1)
(to-array [1])
(into-array [1])
(to-array-2d [[1]]) )
(are [x] (= (alength x) 3)
(int-array 3)
(long-array 3)
(float-array 3)
(double-array 3)
(boolean-array 3)
(byte-array 3)
(char-array 3)
(short-array 3)
(make-array Integer/TYPE 3)
(to-array [1 "a" :k])
(into-array [1 2 3])
(to-array-2d [[1] [2 3] [4 5 6]]) ))
(deftest test-aclone
; clone all arrays except 2D
(are [x] (and (= (alength (aclone x)) (alength x))
(= (vec (aclone x)) (vec x)))
(int-array 0)
(long-array 0)
(float-array 0)
(double-array 0)
(boolean-array 0)
(byte-array 0)
(char-array 0)
(short-array 0)
12.18. TEST/JAVA˙INTEROP.CLJ 1593
(make-array Integer/TYPE 0)
(to-array [])
(into-array [])
(int-array [1 2 3])
(long-array [1 2 3])
(float-array [1 2 3])
(double-array [1 2 3])
(boolean-array [true false])
(byte-array [(byte 1) (byte 2)])
(char-array [\a \b \c])
(short-array [(short 1) (short 2)])
(make-array Integer/TYPE 3)
(to-array [1 "a" :k])
(into-array [1 2 3]) )
; clone 2D
(are [x] (and (= (alength (aclone x)) (alength x))
(= (map alength (aclone x)) (map alength x))
(= (map vec (aclone x)) (map vec x)))
(to-array-2d [])
(to-array-2d [[1] [2 3] [4 5 6]]) ))
; Type Hints, *warn-on-reflection*
; #^ints, #^floats, #^longs, #^doubles
; Coercions: [int, long, float, double, char, boolean, shor t, byte]
; num
; ints/longs/floats/doubles
(deftest test-boolean
(are [x y] (and (instance? java.lang.Boolean (boolean x))
(= (boolean x) y))
nil false
false false
true true
0 true
1 true
() true
[1] true
"" true
\space true
:kw true ))
(deftest test-char
; int -> char
1594 CHAPTER 12. TEST/CLOJURE
(is (instance? java.lang.Character (char 65)))
; char -> char
(is (instance? java.lang.Character (char \a)))
(is (= (char \a) \a)))
;; Note: More coercions in numbers.clj
———-
12.19 test/keywords.clj
— test/keywords.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.keywords
(:use clojure.test))
(let [this-ns (str (.name *ns*))]
(deftest test-find-keyword
:foo
::foo
(let [absent-keyword-sym (gensym "absent-keyword-sym") ]
(are [result lookup] (= result (find-keyword lookup))
:foo :foo
:foo ’foo
:foo "foo"
nil absent-keyword-sym
nil (str absent-keyword-sym))
(are [result lookup] (= result (find-keyword this-ns looku p))
::foo "foo"
nil (str absent-keyword-sym)))))
———-
12.20 test/logic.clj
— test/logic.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
12.20. TEST/LOGIC.CLJ 1595
;;
;; Created 1/29/2009
(ns clojure.test-clojure.logic
(:use clojure.test
[clojure.test-helper :only (exception)]))
;; *** Tests ***
(deftest test-if
; true/false/nil
(are [x y] (= x y)
(if true :t) :t
(if true :t :f) :t
(if true :t (exception)) :t
(if false :t) nil
(if false :t :f) :f
(if false (exception) :f) :f
(if nil :t) nil
(if nil :t :f) :f
(if nil (exception) :f) :f )
; zero/empty is true
(are [x] (= (if x :t :f) :t)
(byte 0)
(short 0)
(int 0)
(long 0)
(bigint 0)
(float 0)
(double 0)
(bigdec 0)
0/2
""
#""
(symbol "")
()
[]
{}
#{}
(into-array []) )
; anything except nil/false is true
(are [x] (= (if x :t :f) :t)
(byte 2)
1596 CHAPTER 12. TEST/CLOJURE
(short 2)
(int 2)
(long 2)
(bigint 2)
(float 2)
(double 2)
(bigdec 2)
2/3
\a
"abc"
#"a*b"
’abc
:kw
’(1 2)
[1 2]
{:a 1 :b 2}
#{1 2}
(into-array [1 2])
(new java.util.Date) ))
(deftest test-nil-punning
(are [x y] (= (if x :no :yes) y)
(first []) :yes
(next [1]) :yes
(rest [1]) :no
(butlast [1]) :yes
(seq nil) :yes
(seq []) :yes
(sequence nil) :no
(sequence []) :no
(lazy-seq nil) :no
(lazy-seq []) :no
(filter #(> % 10) [1 2 3]) :no
(map identity []) :no
(apply concat []) :no
(concat) :no
(concat []) :no
(reverse nil) :no
(reverse []) :no
12.20. TEST/LOGIC.CLJ 1597
(sort nil) :no
(sort []) :no ))
(deftest test-and
(are [x y] (= x y)
(and) true
(and true) true
(and nil) nil
(and false) false
(and true nil) nil
(and true false) false
(and 1 true :kw ’abc "abc") "abc"
(and 1 true :kw nil ’abc "abc") nil
(and 1 true :kw nil (exception) ’abc "abc") nil
(and 1 true :kw ’abc "abc" false) false
(and 1 true :kw ’abc "abc" false (exception)) false ))
(deftest test-or
(are [x y] (= x y)
(or) nil
(or true) true
(or nil) nil
(or false) false
(or nil false true) true
(or nil false 1 2) 1
(or nil false "abc" :kw) "abc"
(or false nil) nil
(or nil false) false
(or nil nil nil false) false
(or nil true false) true
(or nil true (exception) false) true
(or nil false "abc" (exception)) "abc" ))
(deftest test-not
; (is (thrown? IllegalArgumentException (not)))
(are [x] (= (not x) true)
nil
false )
(are [x] (= (not x) false)
1598 CHAPTER 12. TEST/CLOJURE
true
; numbers
0
0.0
42
1.2
0/2
2/3
; characters
\space
\tab
\a
; strings
""
"abc"
; regexes
#""
#"a*b"
; symbols
(symbol "")
’abc
; keywords
:kw
; collections/arrays
()
’(1 2)
[]
[1 2]
{}
{:a 1 :b 2}
#{}
#{1 2}
(into-array [])
(into-array [1 2])
; Java objects
(new java.util.Date) ))
———-
12.21. TEST/MACROS.CLJ 1599
12.21 test/macros.clj
— test/macros.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.macros
(:use clojure.test))
; http://clojure.org/macros
; ->
; defmacro definline macroexpand-1 macroexpand
———-
12.22 test/main.clj
— test/main.clj —
\getchunk{Clojure Copyright}
; Author: Stuart Halloway
(ns clojure.test-clojure.main
(:use clojure.test
[clojure.test-helper :only [platform-newlines]])
(:require [clojure.main :as main]))
(deftest eval-opt
(testing "evals and prints forms"
(is (= (platform-newlines "2\n4\n")
(with-out-str (#’clojure.main/eval-opt "(+ 1 1) (+ 2 2)")) )))
(testing "skips printing nils"
(is (= (platform-newlines ":a\n:c\n")
(with-out-str (#’clojure.main/eval-opt ":a nil :c")))))
(testing "does not block access to *in* (#299)"
(with-in-str "(+ 1 1)"
(is (= (platform-newlines "(+ 1 1)\n")
1600 CHAPTER 12. TEST/CLOJURE
(with-out-str (#’clojure.main/eval-opt "(read)")))))) )
(defmacro with-err-str
"Evaluates exprs in a context in which *err* is bound to a fres h
StringWriter. Returns the string created by any nested prin ting
calls."
[& body]
‘(let [s# (new java.io.StringWriter)
p# (new java.io.PrintWriter s#)]
(binding [*err* p#]
~@body
(str s#))))
(defn run-repl-and-return-err
"Run repl, swallowing stdout and returing stderr."
[in-str]
(with-err-str
(with-out-str
(with-in-str in-str
(main/repl)))))
;argh - test fragility, please fix
#_(deftest repl-exception-safety
(testing "catches and prints exception on bad equals"
(is (re-matches #"java\.lang\.NullPointerException\r? \n"
(run-repl-and-return-err
"(proxy [Object] [] (equals [o] (.toString nil)))")))))
———-
12.23 test/metadata.clj
— test/metadata.clj —
\getchunk{Clojure Copyright}
; Authors: Stuart Halloway, Frantisek Sodomka
(ns clojure.test-clojure.metadata
(:use clojure.test
[clojure.test-helper :only (eval-in-temp-ns)]))
(def public-namespaces
’[clojure.core
clojure.pprint
clojure.inspector
clojure.set
12.23. TEST/METADATA.CLJ 1601
clojure.stacktrace
clojure.test
clojure.walk
clojure.xml
clojure.zip
clojure.java.io
clojure.java.browse
clojure.java.javadoc
clojure.java.shell
clojure.string
clojure.data])
(doseq [ns public-namespaces]
(require ns))
(def public-vars
(mapcat #(vals (ns-publics %)) public-namespaces))
(def public-vars-with-docstrings
(filter (comp :doc meta) public-vars))
(deftest public-vars-with-docstrings-have-added
(is (= [] (remove (comp :added meta) public-vars-with-docs trings))))
(deftest interaction-of-def-with-metadata
(testing "initial def sets metadata"
(let [v (eval-in-temp-ns
(def ^{:a 1} foo 0)
#’foo)]
(is (= 1 (-> v meta :a)))))
#_(testing "subsequent declare doesn’t overwrite metadat a"
(let [v (eval-in-temp-ns
(def ^{:b 2} bar 0)
(declare bar)
#’bar)]
(is (= 2 (-> v meta :b))))
(testing "when compiled"
(let [v (eval-in-temp-ns
(def ^{:c 3} bar 0)
(defn declare-bar []
(declare bar))
(declare-bar)
#’bar)]
(is (= 3 (-> v meta :c))))))
(testing "subsequent def with init-expr *does* overwrite m etadata"
(let [v (eval-in-temp-ns
(def ^{:d 4} quux 0)
(def quux 1)
#’quux)]
(is (nil? (-> v meta :d))))
1602 CHAPTER 12. TEST/CLOJURE
(testing "when compiled"
(let [v (eval-in-temp-ns
(def ^{:e 5} quux 0)
(defn def-quux []
(def quux 1))
(def-quux)
#’quux)]
(is (nil? (-> v meta :e)))))))
———-
12.24 test/multimethods.clj
— test/multimethods.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka, Robert Lachlan
(ns clojure.test-clojure.multimethods
(:use clojure.test [clojure.test-helper :only (with-var -roots)])
(:require [clojure.set :as set]))
; http://clojure.org/multimethods
; defmulti
; defmethod
; remove-method
; prefer-method
; methods
; prefers
(defmacro for-all
[& args]
‘(dorun (for ~@args)))
(defn hierarchy-tags
"Return all tags in a derivation hierarchy"
[h]
(set/select
#(instance? clojure.lang.Named %)
(reduce into #{} (map keys (vals h)))))
(defn transitive-closure
"Return all objects reachable by calling f starting with o,
not including o itself. f should return a collection."
[o f]
12.24. TEST/MULTIMETHODS.CLJ 1603
(loop [results #{}
more #{o}]
(let [new-objects (set/difference more results)]
(if (seq new-objects)
(recur (set/union results more)
(reduce into #{} (map f new-objects)))
(disj results o)))))
(defn tag-descendants
"Set of descedants which are tags (i.e. Named)."
[& args]
(set/select
#(instance? clojure.lang.Named %)
(or (apply descendants args) #{})))
(defn assert-valid-hierarchy
[h]
(let [tags (hierarchy-tags h)]
(testing "ancestors are the transitive closure of parents"
(for-all [tag tags]
(is (= (transitive-closure tag #(parents h %))
(or (ancestors h tag) #{})))))
(testing "ancestors are transitive"
(for-all [tag tags]
(is (= (transitive-closure tag #(ancestors h %))
(or (ancestors h tag) #{})))))
(testing "tag descendants are transitive"
(for-all [tag tags]
(is (= (transitive-closure tag #(tag-descendants h %))
(or (tag-descendants h tag) #{})))))
(testing "a tag isa? all of its parents"
(for-all [tag tags
:let [parents (parents h tag)]
parent parents]
(is (isa? h tag parent))))
(testing "a tag isa? all of its ancestors"
(for-all [tag tags
:let [ancestors (ancestors h tag)]
ancestor ancestors]
(is (isa? h tag ancestor))))
(testing "all my descendants have me as an ancestor"
(for-all [tag tags
:let [descendants (descendants h tag)]
descendant descendants]
(is (isa? h descendant tag))))
(testing "there are no cycles in parents"
(for-all [tag tags]
(is (not (contains?
(transitive-closure tag #(parents h %)) tag)))))
(testing "there are no cycles in descendants"
1604 CHAPTER 12. TEST/CLOJURE
(for-all [tag tags]
(is (not (contains? (descendants h tag) tag)))))))
(def family
(reduce #(apply derive (cons %1 %2)) (make-hierarchy)
[[::parent-1 ::ancestor-1]
[::parent-1 ::ancestor-2]
[::parent-2 ::ancestor-2]
[::child ::parent-2]
[::child ::parent-1]]))
;tpd this should be a regex, but i don’t know how to split a rege x
;(deftest cycles-are-forbidden
; (testing "a tag cannot be its own parent"
; (is (thrown-with-msg? Throwable #"\(not= tag parent\)"
; (derive family ::child ::child))))
; (testing "a tag cannot be its own ancestor"
; (is
; (thrown-with-msg? Throwable
; (str "Cyclic derivation: :clojure.test-clojure.multim ethods/child "
; "has :clojure.test-clojure.multimethods/ancestor-1 a s ancestor")
; (derive family ::ancestor-1 ::child)))))
(deftest using-diamond-inheritance
(let [diamond (reduce #(apply derive (cons %1 %2)) (make-hi erarchy)
[[::mammal ::animal]
[::bird ::animal]
[::griffin ::mammal]
[::griffin ::bird]])
bird-no-more (underive diamond ::griffin ::bird)]
(assert-valid-hierarchy diamond)
(assert-valid-hierarchy bird-no-more)
(testing "a griffin is a mammal, indirectly through mammal a nd bird"
(is (isa? diamond ::griffin ::animal)))
(testing "a griffin is a bird"
(is (isa? diamond ::griffin ::bird)))
(testing "after underive, griffin is no longer a bird"
(is (not (isa? bird-no-more ::griffin ::bird))))
(testing "but it is still an animal, via mammal"
(is (isa? bird-no-more ::griffin ::animal)))))
(deftest derivation-world-bridges-to-java-inheritanc e
(let [h (derive (make-hierarchy) java.util.Map ::map)]
(testing "a Java class can be isa? a tag"
(is (isa? h java.util.Map ::map)))
(testing "if a Java class isa? a tag, so are its subclasses... "
(is (isa? h java.util.HashMap ::map)))
(testing "...but not its superclasses!"
(is (not (isa? h java.util.Collection ::map))))))
12.25. TEST/NS˙LIBS.CLJ 1605
(deftest global-hierarchy-test
(with-var-roots {#’clojure.core/global-hierarchy (mak e-hierarchy)}
(assert-valid-hierarchy @#’clojure.core/global-hiera rchy)
(testing "when you add some derivations..."
(derive ::lion ::cat)
(derive ::manx ::cat)
(assert-valid-hierarchy @#’clojure.core/global-hiera rchy))
(testing "...isa? sees the derivations"
(is (isa? ::lion ::cat))
(is (not (isa? ::cat ::lion))))
(testing "... you can traverse the derivations"
(is (= #{::manx ::lion} (descendants ::cat)))
(is (= #{::cat} (parents ::manx)))
(is (= #{::cat} (ancestors ::manx))))
(testing "then, remove a derivation..."
(underive ::manx ::cat))
(testing "... traversals update accordingly"
(is (= #{::lion} (descendants ::cat)))
(is (nil? (parents ::manx)))
(is (nil? (ancestors ::manx))))))
#_(defmacro for-all
"Better than the actual for-all, if only it worked."
[& args]
‘(reduce
#(and %1 %2)
(map true? (for ~@args))))
———-
12.25 test/ns˙libs.clj
— test/ns˙libs.clj —
\getchunk{Clojure Copyright}
; Authors: Frantisek Sodomka, Stuart Halloway
(ns clojure.test-clojure.ns-libs
(:use clojure.test))
; http://clojure.org/namespaces
; in-ns ns create-ns
; alias import intern refer
; all-ns find-ns
1606 CHAPTER 12. TEST/CLOJURE
; ns-name ns-aliases ns-imports ns-interns ns-map ns-publ ics ns-refers
; resolve ns-resolve namespace
; ns-unalias ns-unmap remove-ns
; http://clojure.org/libs
; require use
; loaded-libs
(deftest test-alias
(is (thrown-with-msg? Exception
#"No namespace: epicfail found" (alias ’bogus ’epicfail)) ))
(deftest test-require
(is (thrown? Exception (require :foo)))
(is (thrown? Exception (require))))
(deftest test-use
(is (thrown? Exception (use :foo)))
(is (thrown? Exception (use))))
(deftest reimporting-deftypes
(let [inst1 (binding [*ns* *ns*]
(eval ’(do (ns exporter)
(defrecord ReimportMe [a])
(ns importer)
(import exporter.ReimportMe)
(ReimportMe. 1))))
inst2 (binding [*ns* *ns*]
(eval ’(do (ns exporter)
(defrecord ReimportMe [a b])
(ns importer)
(import exporter.ReimportMe)
(ReimportMe. 1 2))))]
(testing "you can reimport a changed class and see the change s"
(is (= [:a] (keys inst1)))
(is (= [:a :b] (keys inst2))))
;fragile tests, please fix
#_(testing "you cannot import same local name from a differe nt namespace"
(is (thrown? clojure.lang.Compiler$CompilerException
#"ReimportMe already refers to: class exporter.ReimportM e
in namespace: importer"
(binding [*ns* *ns*]
(eval ’(do (ns exporter-2)
(defrecord ReimportMe [a b])
(ns importer)
(import exporter-2.ReimportMe)
(ReimportMe. 1 2)))))))))
12.26. TEST/NUMBERS.CLJ 1607
(deftest naming-types
(testing
"you cannot use a name already referred from another namespa ce"
(is (thrown? IllegalStateException
#"String already refers to: class java.lang.String"
(definterface String)))
(is (thrown? IllegalStateException
#"StringBuffer already refers to: class java.lang.String Buffer"
(deftype StringBuffer [])))
(is (thrown? IllegalStateException
#"Integer already refers to: class java.lang.Integer"
(defrecord Integer [])))))
(deftest resolution
(let [s (gensym)]
(are [result expr] (= result expr)
#’clojure.core/first (ns-resolve ’clojure.core ’first)
nil (ns-resolve ’clojure.core s)
nil (ns-resolve ’clojure.core {’first :local-first} ’fir st)
nil (ns-resolve ’clojure.core {’first :local-first} s))) )
(deftest refer-error-messages
(let [temp-ns (gensym)]
(binding [*ns* *ns*]
(in-ns temp-ns)
(eval ’(def ^{:private true} hidden-var)))
(testing "referring to something that does not exist"
(is (thrown-with-msg? IllegalAccessError
#"nonexistent-var does not exist"
(refer temp-ns :only ’(nonexistent-var)))))
(testing "referring to something non-public"
(is (thrown-with-msg? IllegalAccessError
#"hidden-var is not public"
(refer temp-ns :only ’(hidden-var)))))))
———-
12.26 test/numbers.clj
— test/numbers.clj —
\getchunk{Clojure Copyright}
; Author: Stephen C. Gilardi
;; scgilardi (gmail)
;; Created 30 October 2008
;;
1608 CHAPTER 12. TEST/CLOJURE
(ns clojure.test-clojure.numbers
(:use clojure.test
clojure.template))
; TODO:
; ==
; and more...
;; *** Types ***
(deftest Coerced-BigDecimal
(let [v (bigdec 3)]
(are [x] (true? x)
(instance? BigDecimal v)
(number? v)
(decimal? v)
(not (float? v)))))
(deftest BigInteger-conversions
(are [x] (biginteger x)
Long/MAX_VALUE
13178456923875639284562345789M
13178456923875639284562345789N))
(deftest unchecked-cast-num-obj
(do-template [prim-array cast]
(are [n]
(let [a (prim-array 1)]
(aset a 0 (cast n)))
(Byte. Byte/MAX_VALUE)
(Short. Short/MAX_VALUE)
(Integer. Integer/MAX_VALUE)
(Long. Long/MAX_VALUE)
(Float. Float/MAX_VALUE)
(Double. Double/MAX_VALUE))
byte-array
unchecked-byte
short-array
unchecked-short
char-array
unchecked-char
int-array
unchecked-int
long-array
unchecked-long
float-array
12.26. TEST/NUMBERS.CLJ 1609
unchecked-float
double-array
unchecked-double))
(deftest unchecked-cast-num-prim
(do-template [prim-array cast]
(are [n]
(let [a (prim-array 1)]
(aset a 0 (cast n)))
Byte/MAX_VALUE
Short/MAX_VALUE
Integer/MAX_VALUE
Long/MAX_VALUE
Float/MAX_VALUE
Double/MAX_VALUE)
byte-array
unchecked-byte
short-array
unchecked-short
char-array
unchecked-char
int-array
unchecked-int
long-array
unchecked-long
float-array
unchecked-float
double-array
unchecked-double))
(deftest unchecked-cast-char
; in keeping with the checked cast functions, char and Charac ter
; can only be cast to int
(is (unchecked-int (char 0xFFFF)))
(is (let [c (char 0xFFFF)] (unchecked-int c)))) ; force prim itive char
(def expected-casts
[
[:input [-1 0 1
Byte/MAX_VALUE Short/MAX_VALUE Integer/MAX_VALUE Long/ MAX_VALUE
Float/MAX_VALUE Double/MAX_VALUE]]
[char [:error (char 0) (char 1)
(char 127) (char 32767) :error :error
:error :error]]
[unchecked-char [(char 65535) (char 0) (char 1) (char 127)
(char 32767) (char 65535) (char 65535)
(char 65535) (char 65535)]]
[byte [-1 0 1 Byte/MAX_VALUE
:error :error :error :error
:error]]
1610 CHAPTER 12. TEST/CLOJURE
[unchecked-byte [-1 0 1 Byte/MAX_VALUE
-1 -1 -1 -1
-1]]
[short [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE :error :error :error
:error]]
[unchecked-short [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE -1 -1 -1
-1]]
[int [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE Integer/MAX_VALUE :error :error
:error]]
[unchecked-int [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE Integer/MAX_VALUE -1 Integer/MAX_VALUE
Integer/MAX_VALUE]]
[long [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE Integer/MAX_VALUE Long/MAX_VALUE
Long/MAX_VALUE Long/MAX_VALUE]]
[unchecked-long [-1 0 1 Byte/MAX_VALUE
Short/MAX_VALUE Integer/MAX_VALUE Long/MAX_VALUE
Long/MAX_VALUE Long/MAX_VALUE]]
;; 2.14748365E9 if when float/double conversion is avoided ...
[float [-1.0 0.0 1.0 127.0
32767.0 2.147483648E9 9.223372036854776E18
Float/MAX_VALUE :error]]
[unchecked-float [-1.0 0.0 1.0 127.0
32767.0 2.147483648E9 9.223372036854776E18
Float/MAX_VALUE Float/POSITIVE_INFINITY]]
[double [-1.0 0.0 1.0 127.0
32767.0 2.147483647E9 9.223372036854776E18
Float/MAX_VALUE Double/MAX_VALUE]]
[unchecked-double [-1.0 0.0 1.0 127.0
32767.0 2.147483647E9 9.223372036854776E18
Float/MAX_VALUE Double/MAX_VALUE]]])
(deftest test-expected-casts
(let [[[_ inputs] & expectations] expected-casts]
(doseq [[f vals] expectations]
(let [wrapped (fn [x]
(try
(f x)
(catch IllegalArgumentException e :error)))]
(is (= vals (map wrapped inputs)))))))
;; *** Functions ***
(defonce DELTA 1e-12)
(deftest test-add
(are [x y] (= x y)
12.26. TEST/NUMBERS.CLJ 1611
(+) 0
(+ 1) 1
(+ 1 2) 3
(+ 1 2 3) 6
(+ -1) -1
(+ -1 -2) -3
(+ -1 +2 -3) -2
(+ 1 -1) 0
(+ -1 1) 0
(+ 2/3) 2/3
(+ 2/3 1) 5/3
(+ 2/3 1/3) 1 )
(are [x y] (< (- x y) DELTA)
(+ 1.2) 1.2
(+ 1.1 2.4) 3.5
(+ 1.1 2.2 3.3) 6.6 )
; no overflow
(is (> (+ Integer/MAX_VALUE 10) Integer/MAX_VALUE))
; no string concatenation
(is (thrown? ClassCastException (+ "ab" "cd"))) )
(deftest test-subtract
(is (thrown? IllegalArgumentException (-)))
(are [x y] (= x y)
(- 1) -1
(- 1 2) -1
(- 1 2 3) -4
(- -2) 2
(- 1 -2) 3
(- 1 -2 -3) 6
(- 1 1) 0
(- -1 -1) 0
(- 2/3) -2/3
(- 2/3 1) -1/3
(- 2/3 1/3) 1/3 )
(are [x y] (< (- x y) DELTA)
(- 1.2) -1.2
(- 2.2 1.1) 1.1
(- 6.6 2.2 1.1) 3.3 )
1612 CHAPTER 12. TEST/CLOJURE
; no underflow
(is (< (- Integer/MIN_VALUE 10) Integer/MIN_VALUE)) )
(deftest test-multiply
(are [x y] (= x y)
(*) 1
(* 2) 2
(* 2 3) 6
(* 2 3 4) 24
(* -2) -2
(* 2 -3) -6
(* 2 -3 -1) 6
(* 1/2) 1/2
(* 1/2 1/3) 1/6
(* 1/2 1/3 -1/4) -1/24 )
(are [x y] (< (- x y) DELTA)
(* 1.2) 1.2
(* 2.0 1.2) 2.4
(* 3.5 2.0 1.2) 8.4 )
; no overflow
(is (> (* 3 (int (/ Integer/MAX_VALUE 2.0))) Integer/MAX_VA LUE)) )
(deftest test-ratios-simplify-to-ints-where-appropri ate
(testing "negative denominator (assembla #275)"
(is (integer? (/ 1 -1/2)))
(is (integer? (/ 0 -1/2)))))
(deftest test-divide
(are [x y] (= x y)
(/ 1) 1
(/ 2) 1/2
(/ 3 2) 3/2
(/ 4 2) 2
(/ 24 3 2) 4
(/ 24 3 2 -1) -4
(/ -1) -1
(/ -2) -1/2
(/ -3 -2) 3/2
(/ -4 -2) 2
(/ -4 2) -2 )
(are [x y] (< (- x y) DELTA)
(/ 4.5 3) 1.5
(/ 4.5 3.0 3.0) 0.5 )
12.26. TEST/NUMBERS.CLJ 1613
(is (thrown? ArithmeticException (/ 0)))
(is (thrown? ArithmeticException (/ 2 0)))
(is (thrown? IllegalArgumentException (/))) )
;; mod
;; http://en.wikipedia.org/wiki/Modulo_operation
;; http://mathforum.org/library/drmath/view/52343.ht ml
;;
;; is mod correct?
;; http://groups.google.com/group/clojure/
;; browse_frm/thread/2a0ee4d248f3d131#
;;
;; Issue 23: mod (modulo) operator
;; http://code.google.com/p/clojure/issues/detail?id =23
(deftest test-mod
; wrong number of args
; (is (thrown? IllegalArgumentException (mod)))
; (is (thrown? IllegalArgumentException (mod 1)))
; (is (thrown? IllegalArgumentException (mod 3 2 1)))
; divide by zero
(is (thrown? ArithmeticException (mod 9 0)))
(is (thrown? ArithmeticException (mod 0 0)))
(are [x y] (= x y)
(mod 4 2) 0
(mod 3 2) 1
(mod 6 4) 2
(mod 0 5) 0
(mod 2 1/2) 0
(mod 2/3 1/2) 1/6
(mod 1 2/3) 1/3
(mod 4.0 2.0) 0.0
(mod 4.5 2.0) 0.5
; |num| > |div|, num != k * div
(mod 42 5) 2 ; (42 / 5) * 5 + (42 mod 5) = 8 * 5 + 2 = 42
(mod 42 -5) -3 ; (42 / -5) * (-5) + (42 mod -5)
; = -9 * (-5) + (-3) = 42
(mod -42 5) 3 ; (-42 / 5) * 5 + (-42 mod 5) = -9 * 5 + 3
; = -42
(mod -42 -5) -2 ; (-42 / -5) * (-5) + (-42 mod -5)
; = 8 * (-5) + (-2) = -42
; |num| > |div|, num = k * div
1614 CHAPTER 12. TEST/CLOJURE
(mod 9 3) 0 ; (9 / 3) * 3 + (9 mod 3) = 3 * 3 + 0 = 9
(mod 9 -3) 0
(mod -9 3) 0
(mod -9 -3) 0
; |num| < |div|
(mod 2 5) 2 ; (2 / 5) * 5 + (2 mod 5)
; = 0 * 5 + 2 = 2
(mod 2 -5) -3 ; (2 / -5) * (-5) + (2 mod -5)
; = (-1) * (-5) + (-3) = 2
(mod -2 5) 3 ; (-2 / 5) * 5 + (-2 mod 5)
; = (-1) * 5 + 3 = -2
(mod -2 -5) -2 ; (-2 / -5) * (-5) + (-2 mod -5)
; = 0 * (-5) + (-2) = -2
; num = 0, div != 0
(mod 0 3) 0 ; (0 / 3) * 3 + (0 mod 3) = 0 * 3 + 0 = 0
(mod 0 -3) 0
)
)
;; rem & quot
;; http://en.wikipedia.org/wiki/Remainder
(deftest test-rem
; wrong number of args
; (is (thrown? IllegalArgumentException (rem)))
; (is (thrown? IllegalArgumentException (rem 1)))
; (is (thrown? IllegalArgumentException (rem 3 2 1)))
; divide by zero
(is (thrown? ArithmeticException (rem 9 0)))
(is (thrown? ArithmeticException (rem 0 0)))
(are [x y] (= x y)
(rem 4 2) 0
(rem 3 2) 1
(rem 6 4) 2
(rem 0 5) 0
(rem 2 1/2) 0
(rem 2/3 1/2) 1/6
(rem 1 2/3) 1/3
(rem 4.0 2.0) 0.0
(rem 4.5 2.0) 0.5
; |num| > |div|, num != k * div
(rem 42 5) 2 ; (8 * 5) + 2 == 42
(rem 42 -5) 2 ; (-8 * -5) + 2 == 42
12.26. TEST/NUMBERS.CLJ 1615
(rem -42 5) -2 ; (-8 * 5) + -2 == -42
(rem -42 -5) -2 ; (8 * -5) + -2 == -42
; |num| > |div|, num = k * div
(rem 9 3) 0
(rem 9 -3) 0
(rem -9 3) 0
(rem -9 -3) 0
; |num| < |div|
(rem 2 5) 2
(rem 2 -5) 2
(rem -2 5) -2
(rem -2 -5) -2
; num = 0, div != 0
(rem 0 3) 0
(rem 0 -3) 0
)
)
(deftest test-quot
; wrong number of args
; (is (thrown? IllegalArgumentException (quot)))
; (is (thrown? IllegalArgumentException (quot 1)))
; (is (thrown? IllegalArgumentException (quot 3 2 1)))
; divide by zero
(is (thrown? ArithmeticException (quot 9 0)))
(is (thrown? ArithmeticException (quot 0 0)))
(are [x y] (= x y)
(quot 4 2) 2
(quot 3 2) 1
(quot 6 4) 1
(quot 0 5) 0
(quot 2 1/2) 4
(quot 2/3 1/2) 1
(quot 1 2/3) 1
(quot 4.0 2.0) 2.0
(quot 4.5 2.0) 2.0
; |num| > |div|, num != k * div
(quot 42 5) 8 ; (8 * 5) + 2 == 42
(quot 42 -5) -8 ; (-8 * -5) + 2 == 42
(quot -42 5) -8 ; (-8 * 5) + -2 == -42
(quot -42 -5) 8 ; (8 * -5) + -2 == -42
1616 CHAPTER 12. TEST/CLOJURE
; |num| > |div|, num = k * div
(quot 9 3) 3
(quot 9 -3) -3
(quot -9 3) -3
(quot -9 -3) 3
; |num| < |div|
(quot 2 5) 0
(quot 2 -5) 0
(quot -2 5) 0
(quot -2 -5) 0
; num = 0, div != 0
(quot 0 3) 0
(quot 0 -3) 0
)
)
;; *** Predicates ***
;; pos? zero? neg?
(deftest test-pos?-zero?-neg?
(let [nums [[(byte 2) (byte 0) (byte -2)]
[(short 3) (short 0) (short -3)]
[(int 4) (int 0) (int -4)]
[(long 5) (long 0) (long -5)]
[(bigint 6) (bigint 0) (bigint -6)]
[(float 7) (float 0) (float -7)]
[(double 8) (double 0) (double -8)]
[(bigdec 9) (bigdec 0) (bigdec -9)]
[2/3 0 -2/3]]
pred-result [[pos? [true false false]]
[zero? [false true false]]
[neg? [false false true]]] ]
(doseq [pr pred-result]
(doseq [n nums]
(is (= (map (first pr) n) (second pr))
(pr-str (first pr) n))))))
;; even? odd?
(deftest test-even?
(are [x] (true? x)
(even? -4)
(not (even? -3))
(even? 0)
(not (even? 5))
12.26. TEST/NUMBERS.CLJ 1617
(even? 8))
(is (thrown? ArithmeticException (even? 1/2)))
(is (thrown? ArithmeticException (even? (double 10)))))
(deftest test-odd?
(are [x] (true? x)
(not (odd? -4))
(odd? -3)
(not (odd? 0))
(odd? 5)
(not (odd? 8)))
(is (thrown? ArithmeticException (odd? 1/2)))
(is (thrown? ArithmeticException (odd? (double 10)))))
(defn- expt
"clojure.contrib.math/expt is a better and much faster imp l,
but this works. Math/pow overflows to Infinity."
[x n] (apply *’ (replicate n x)))
(deftest test-bit-shift-left
(are [x y] (= x y)
2r10 (bit-shift-left 2r1 1)
2r100 (bit-shift-left 2r1 2)
2r1000 (bit-shift-left 2r1 3)
2r00101110 (bit-shift-left 2r00010111 1)
2r00101110 (apply bit-shift-left [2r00010111 1])
2r01 (bit-shift-left 2r10 -1)
(expt 2 32) (bit-shift-left 1 32)
(expt 2N 10000) (bit-shift-left 1N 10000)
))
(deftest test-bit-shift-right
(are [x y] (= x y)
2r0 (bit-shift-right 2r1 1)
2r010 (bit-shift-right 2r100 1)
2r001 (bit-shift-right 2r100 2)
2r000 (bit-shift-right 2r100 3)
2r0001011 (bit-shift-right 2r00010111 1)
2r0001011 (apply bit-shift-right [2r00010111 1])
2r100 (bit-shift-right 2r10 -1)
1 (bit-shift-right (expt 2 32) 32)
1N (bit-shift-right (expt 2N 10000) 10000)
))
;; arrays
(deftest test-array-types
(are [x y z] (= (Class/forName x) (class y) (class z))
"[Z" (boolean-array 1) (booleans (boolean-array 1 true))
"[B" (byte-array 1) (bytes (byte-array 1 (byte 1)))
1618 CHAPTER 12. TEST/CLOJURE
"[C" (char-array 1) (chars (char-array 1 \a))
"[S" (short-array 1) (shorts (short-array 1 (short 1)))
"[F" (float-array 1) (floats (float-array 1 1))
"[D" (double-array 1) (doubles (double-array 1 1))
"[I" (int-array 1) (ints (int-array 1 1))
"[J" (long-array 1) (longs (long-array 1 1))))
(deftest test-ratios
(is (== (denominator 1/2) 2))
(is (== (numerator 1/2) 1))
(is (= (bigint (/ 100000000000000000000 3)) 3333333333333 3333333))
(is (= (long 10000000000000000000/3) 333333333333333333 3)))
———-
12.27 test/other˙functions.clj
— test/other˙functions.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.other-functions
(:use clojure.test))
; http://clojure.org/other_functions
; [= not= (tests in data_structures.clj and elsewhere)]
(deftest test-identity
; exactly 1 argument needed
; (is (thrown? IllegalArgumentException (identity)))
; (is (thrown? IllegalArgumentException (identity 1 2)))
(are [x] (= (identity x) x)
nil
false true
0 42
0.0 3.14
2/3
0M 1M
\c
12.27. TEST/OTHER˙FUNCTIONS.CLJ 1619
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} )
; evaluation
(are [x y] (= (identity x) y)
(+ 1 2) 3
(> 5 0) true ))
(deftest test-name
(are [x y] (= x (name y))
"foo" :foo
"bar" ’bar
"quux" "quux"))
(deftest test-fnil
(let [f1 (fnil vector :a)
f2 (fnil vector :a :b)
f3 (fnil vector :a :b :c)]
(are [result input]
(= result [(apply f1 input) (apply f2 input) (apply f3 input) ])
[[1 2 3 4] [1 2 3 4] [1 2 3 4]] [1 2 3 4]
[[:a 2 3 4] [:a 2 3 4] [:a 2 3 4]] [nil 2 3 4]
[[:a nil 3 4] [:a :b 3 4] [:a :b 3 4]] [nil nil 3 4]
[[:a nil nil 4] [:a :b nil 4] [:a :b :c 4]] [nil nil nil 4]
[[:a nil nil nil] [:a :b nil nil]
[:a :b :c nil]] [nil nil nil nil]))
(are [x y] (= x y)
((fnil + 0) nil 42) 42
((fnil conj []) nil 42) [42]
(reduce #(update-in %1 [%2] (fnil inc 0)) {}
["fun" "counting" "words" "fun"])
{"words" 1, "counting" 1, "fun" 2}
(reduce #(update-in %1 [(first %2)] (fnil conj []) (second % 2)) {}
[[:a 1] [:a 2] [:b 3]])
{:b [3], :a [1 2]}))
; time assert comment doc
; partial
; comp
(deftest test-comp
(let [c0 (comp)]
(are [x] (= (identity x) (c0 x))
1620 CHAPTER 12. TEST/CLOJURE
nil
42
[1 2 3]
#{}
:foo)
(are [x y] (= (identity x) (c0 y))
(+ 1 2 3) 6
(keyword "foo") :foo)))
; complement
; constantly
; Printing
; pr prn print println newline
; pr-str prn-str print-str println-str [with-out-str (var s.clj)]
; Regex Support
; re-matcher re-find re-matches re-groups re-seq
———-
12.28 test/parallel.clj
— test/parallel.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
(ns clojure.test-clojure.parallel
(:use clojure.test))
;; !! Tests for the parallel library will be in a separate
;; file clojure_parallel.clj !!
; future-call
; future
; pmap
; pcalls
; pvalues
;; pmap
;;
(deftest pmap-does-its-thing
12.29. TEST/PPRINT.CLJ 1621
;; regression fixed in r1218; was OutOfMemoryError
(is (= ’(1) (pmap inc [0]))))
———-
12.29 test/pprint.clj
— test/pprint.clj —
\getchunk{Clojure Copyright}
;; Author: Tom Faulhaber
(ns clojure.test-clojure.pprint
(:refer-clojure :exclude [format])
(:use [clojure.test :only (deftest are run-tests)]
[clojure.test-helper :only [platform-newlines]]
clojure.test-clojure.pprint.test-helper
clojure.pprint))
;tpd too broken for me at the moment (load "pprint/test_cl_f ormat")
(load "pprint/test_pretty")
———-
12.30 test/predicates.clj
— test/predicates.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
;;
;; Created 1/28/2009
(ns clojure.test-clojure.predicates
(:use clojure.test))
;; *** Type predicates ***
(def myvar 42)
1622 CHAPTER 12. TEST/CLOJURE
(def sample-data {
:nil nil
:bool-true true
:bool-false false
:byte (byte 7)
:short (short 7)
:int (int 7)
:long (long 7)
:bigint (bigint 7)
:float (float 7)
:double (double 7)
:bigdec (bigdec 7)
:ratio 2/3
:character \a
:symbol ’abc
:keyword :kw
:empty-string ""
:empty-regex #""
:empty-list ()
:empty-lazy-seq (lazy-seq nil)
:empty-vector []
:empty-map {}
:empty-set #{}
:empty-array (into-array [])
:string "abc"
:regex #"a*b"
:list ’(1 2 3)
:lazy-seq (lazy-seq [1 2 3])
:vector [1 2 3]
:map {:a 1 :b 2 :c 3}
:set #{1 2 3}
:array (into-array [1 2 3])
:fn (fn [x] (* 2 x))
:class java.util.Date
:object (new java.util.Date)
:var (var myvar)
:delay (delay (+ 1 2))
})
12.30. TEST/PREDICATES.CLJ 1623
(def type-preds {
nil? [:nil]
true? [:bool-true]
false? [:bool-false]
; boolean?
integer? [:byte :short :int :long :bigint]
float? [:float :double]
decimal? [:bigdec]
ratio? [:ratio]
rational? [:byte :short :int :long :bigint :ratio :bigdec]
number? [:byte :short :int :long :bigint :ratio :bigdec
:float :double]
; character?
symbol? [:symbol]
keyword? [:keyword]
string? [:empty-string :string]
; regex?
list? [:empty-list :list]
vector? [:empty-vector :vector]
map? [:empty-map :map]
set? [:empty-set :set]
coll? [:empty-list :list
:empty-lazy-seq :lazy-seq
:empty-vector :vector
:empty-map :map
:empty-set :set]
seq? [:empty-list :list
:empty-lazy-seq :lazy-seq]
; array?
fn? [:fn]
ifn? [:fn
:empty-vector :vector :empty-map :map :empty-set :set
:keyword :symbol :var]
class? [:class]
var? [:var]
delay? [:delay]
})
;; Test all type predicates against all data types
;;
1624 CHAPTER 12. TEST/CLOJURE
(defn- get-fn-name [f]
(str
(apply str (nthnext (first (.split (str f) "_"))
(count "clojure.core$")))
"?"))
(deftest test-type-preds
(doseq [tp type-preds]
(doseq [dt sample-data]
(if (some #(= % (first dt)) (second tp))
(is ((first tp) (second dt))
(pr-str (list (get-fn-name (first tp)) (second dt))))
(is (not ((first tp) (second dt)))
(pr-str
(list ’not
(list (get-fn-name (first tp)) (second dt)))))))))
;; Additional tests:
;; http://groups.google.com/group/clojure/browse_thr ead/
;; thread/537761a06edb4b06/bfd4f0705b746a38
;;
(deftest test-string?-more
(are [x] (not (string? x))
(new java.lang.StringBuilder "abc")
(new java.lang.StringBuffer "xyz")))
———-
12.31 test/printer.clj
— test/printer.clj —
\getchunk{Clojure Copyright}
; Author: Stephen C. Gilardi
;; clojure.test-clojure.printer
;;
;; scgilardi (gmail)
;; Created 29 October 2008
(ns clojure.test-clojure.printer
(:use clojure.test))
(deftest print-length-empty-seq
(let [coll () val "()"]
12.31. TEST/PRINTER.CLJ 1625
(is (= val (binding [*print-length* 0] (print-str coll))))
(is (= val (binding [*print-length* 1] (print-str coll)))) ))
(deftest print-length-seq
(let [coll (range 5)
length-val ’((0 "(...)")
(1 "(0 ...)")
(2 "(0 1 ...)")
(3 "(0 1 2 ...)")
(4 "(0 1 2 3 ...)")
(5 "(0 1 2 3 4)"))]
(doseq [[length val] length-val]
(binding [*print-length* length]
(is (= val (print-str coll)))))))
(deftest print-length-empty-vec
(let [coll [] val "[]"]
(is (= val (binding [*print-length* 0] (print-str coll))))
(is (= val (binding [*print-length* 1] (print-str coll)))) ))
(deftest print-length-vec
(let [coll [0 1 2 3 4]
length-val ’((0 "[...]")
(1 "[0 ...]")
(2 "[0 1 ...]")
(3 "[0 1 2 ...]")
(4 "[0 1 2 3 ...]")
(5 "[0 1 2 3 4]"))]
(doseq [[length val] length-val]
(binding [*print-length* length]
(is (= val (print-str coll)))))))
(deftest print-level-seq
(let [coll ’(0 (1 (2 (3 (4)))))
level-val ’((0 "#")
(1 "(0 #)")
(2 "(0 (1 #))")
(3 "(0 (1 (2 #)))")
(4 "(0 (1 (2 (3 #))))")
(5 "(0 (1 (2 (3 (4)))))"))]
(doseq [[level val] level-val]
(binding [*print-level* level]
(is (= val (print-str coll)))))))
(deftest print-level-length-coll
(let [coll ’(if (member x y) (+ (first x) 3) (foo (a b c d "Baz")) )
level-length-val
’((0 1 "#")
(1 1 "(if ...)")
(1 2 "(if # ...)")
1626 CHAPTER 12. TEST/CLOJURE
(1 3 "(if # # ...)")
(1 4 "(if # # #)")
(2 1 "(if ...)")
(2 2 "(if (member x ...) ...)")
(2 3 "(if (member x y) (+ # 3) ...)")
(3 2 "(if (member x ...) ...)")
(3 3 "(if (member x y) (+ (first x) 3) ...)")
(3 4 "(if (member x y) (+ (first x) 3) (foo (a b c d ...)))")
(3 5 "(if (member x y) (+ (first x) 3) (foo (a b c d Baz)))"))]
(doseq [[level length val] level-length-val]
(binding [*print-level* level
*print-length* length]
(is (= val (print-str coll)))))))
———-
12.32 test/protocols.clj
— test/protocols.clj —
\getchunk{Clojure Copyright}
; Author: Stuart Halloway
(ns clojure.test-clojure.protocols
(:use clojure.test clojure.test-clojure.protocols.exa mples)
(:require [clojure.test-clojure.protocols.more-examp les :as other]
[clojure.set :as set]
clojure.test-helper)
(:import [clojure.test_clojure.protocols.examples Exa mpleInterface]))
;; temporary hack until I decide how to cleanly reload protoc ol
;; this no longer works
(defn reload-example-protocols
[]
(alter-var-root
#’clojure.test-clojure.protocols.examples/ExamplePr otocol
assoc :impls {})
(alter-var-root
#’clojure.test-clojure.protocols.more-examples/Simp leProtocol
assoc :impls {})
(require :reload
’clojure.test-clojure.protocols.examples
’clojure.test-clojure.protocols.more-examples))
(defn method-names
"return sorted list of method names on a class"
12.32. TEST/PROTOCOLS.CLJ 1627
[c]
(->> (.getMethods c)
(map #(.getName %))
(sort)))
(defrecord EmptyRecord [])
(defrecord TestRecord [a b])
(defn r
([a b] (TestRecord. a b))
([a b meta ext] (TestRecord. a b meta ext)))
(defrecord MapEntry [k v]
java.util.Map$Entry
(getKey [_] k)
(getValue [_] v))
;tpd i broke this by splitting the regex
(deftest protocols-test
(testing "protocol fns have useful metadata"
(let
[common-meta
{:ns (find-ns ’clojure.test-clojure.protocols.example s)
:protocol #’ExampleProtocol}]
(are [m f] (= (merge (quote m) common-meta)
(meta (var f)))
{:name foo :arglists ([a]) :doc "method with one arg"} foo
{:name bar :arglists ([a b]) :doc "method with two args"} bar
{:name baz :arglists ([a] [a b])
:doc "method with multiple arities" :tag String} baz
{:name with-quux :arglists ([a])
:doc "method name with a hyphen"} with-quux)))
; (testing
; "protocol fns throw IllegalArgumentException if no impl m atches"
; (is (thrown-with-msg?
; IllegalArgumentException
; (str "No implementation of method: :foo of protocol: "
; "#’clojure.test-clojure.protocols.examples/Example Protocol "
; "found for class: java.lang.Long")
; (foo 10))))
; (testing #"protocols generate a corresponding interface using _
; instead of - for method names"
; (is (= ["bar" "baz" "baz" "foo" "with_quux"]
; (method-names
; clojure.test_clojure.protocols.examples.ExamplePro tocol))))
; (testing
; #"protocol will work with instances of its interface
; (use for interop, not in Clojure!)"
; (let [obj (proxy
; [clojure.test_clojure.protocols.examples.ExamplePr otocol] []
; (foo [] "foo!"))]
; (is (= "foo!" (.foo obj)) "call through interface")
1628 CHAPTER 12. TEST/CLOJURE
; (is (= "foo!" (foo obj)) "call through protocol")))
(testing "you can implement just part of a protocol if you wan t"
(let [obj (reify ExampleProtocol
(baz [a b] "two-arg baz!"))]
(is (= "two-arg baz!" (baz obj nil)))
(is (thrown? AbstractMethodError (baz obj)))))
; (testing "you can redefine a protocol with different metho ds"
; (eval ’(defprotocol Elusive (old-method [x])))
; (eval ’(defprotocol Elusive (new-method [x])))
; (is (= :new-method
; (eval
; ’(new-method (reify Elusive (new-method [x] :new-method ))))))
; (is (fails-with-cause? IllegalArgumentException
; (str "No method of interface: user.Elusive found for funct ion: "
; "old-method of protocol: Elusive (The protocol method may "
; "have been defined before and removed.)")
; (eval
; ’(old-method
; (reify Elusive (new-method [x] :new-method)))))))
)
(deftype ExtendTestWidget [name])
(deftype HasProtocolInline []
ExampleProtocol
(foo [this] :inline))
(deftest extend-test
(testing "you can extend a protocol to a class"
(extend String ExampleProtocol
{:foo identity})
(is (= "pow" (foo "pow"))))
(testing #"you can have two methods with the same name.
Just use namespaces!"
(extend String other/SimpleProtocol
{:foo (fn [s] (.toUpperCase s))})
(is (= "POW" (other/foo "pow"))))
(testing "you can extend deftype types"
(extend
ExtendTestWidget
ExampleProtocol
{:foo (fn [this] (str "widget " (.name this)))})
(is (= "widget z" (foo (ExtendTestWidget. "z"))))))
;tpd i broke this because I split the regex
;(deftest illegal-extending
; (testing #"you cannot extend a protocol to a type that
; implements the protocol inline"
; (is (fails-with-cause? IllegalArgumentException
; #".*HasProtocolInline already directly implements inte rface"
; (eval
; ’(extend clojure.test_clojure.protocols.HasProtocol Inline
12.32. TEST/PROTOCOLS.CLJ 1629
; clojure.test-clojure.protocols.examples/ExamplePro tocol
; {:foo (fn [_] :extended)})))))
; (testing "you cannot extend to an interface"
; (is (fails-with-cause? IllegalArgumentException
; (str "interface "
; "clojure.test_clojure.protocols.examples.ExamplePr otocol "
; "is not a protocol")
; (eval ’(extend clojure.test_clojure.protocols.HasPro tocolInline
; clojure.test_clojure.protocols.examples.ExamplePro tocol
; {:foo (fn [_] :extended)}))))))
(deftype ExtendsTestWidget []
ExampleProtocol)
#_(deftest extends?-test
(reload-example-protocols)
(testing
"returns false if a type does not implement the protocol at al l"
(is (false? (extends? other/SimpleProtocol ExtendsTestW idget))))
;; semantics changed 4/15/2010
(testing "returns true if a type implements the protocol dir ectly"
(is (true? (extends? ExampleProtocol ExtendsTestWidget) )))
(testing "returns true if a type explicitly extends protoco l"
(extend
ExtendsTestWidget
other/SimpleProtocol
{:foo identity})
(is (true? (extends? other/SimpleProtocol ExtendsTestWi dget)))))
(deftype ExtendersTestWidget [])
#_(deftest extenders-test
(reload-example-protocols)
(testing "a fresh protocol has no extenders"
(is (nil? (extenders ExampleProtocol))))
(testing "extending with no methods doesn’t count!"
(deftype Something [])
(extend ::Something ExampleProtocol)
(is (nil? (extenders ExampleProtocol))))
(testing
#"extending a protocol (and including an impl)
adds an entry to extenders"
(extend ExtendersTestWidget ExampleProtocol {:foo ident ity})
(is (= [ExtendersTestWidget] (extenders ExampleProtocol )))))
(deftype SatisfiesTestWidget []
ExampleProtocol)
#_(deftest satisifies?-test
(reload-example-protocols)
(let [whatzit (SatisfiesTestWidget.)]
(testing #"returns false if a type does not
implement the protocol at all"
1630 CHAPTER 12. TEST/CLOJURE
(is (false? (satisfies? other/SimpleProtocol whatzit))) )
(testing "returns true if a type implements the protocol dir ectly"
(is (true? (satisfies? ExampleProtocol whatzit))))
(testing "returns true if a type explicitly extends protoco l"
(extend
SatisfiesTestWidget
other/SimpleProtocol
{:foo identity})
(is (true? (satisfies? other/SimpleProtocol whatzit)))) ) )
(deftype ReExtendingTestWidget [])
#_(deftest re-extending-test
(reload-example-protocols)
(extend
ReExtendingTestWidget
ExampleProtocol
{:foo (fn [_] "first foo")
:baz (fn [_] "first baz")})
(testing #"if you re-extend, the old implementation
is replaced (not merged!)"
(extend
ReExtendingTestWidget
ExampleProtocol
{:baz (fn [_] "second baz")
:bar (fn [_ _] "second bar")})
(let [whatzit (ReExtendingTestWidget.)]
(is (thrown? IllegalArgumentException (foo whatzit)))
(is (= "second bar" (bar whatzit nil)))
(is (= "second baz" (baz whatzit))))))
(defrecord DefrecordObjectMethodsWidgetA [a])
(defrecord DefrecordObjectMethodsWidgetB [a])
(deftest defrecord-object-methods-test
(testing "= depends on fields and type"
(is (true?
(= (DefrecordObjectMethodsWidgetA. 1)
(DefrecordObjectMethodsWidgetA. 1))))
(is (false?
(= (DefrecordObjectMethodsWidgetA. 1)
(DefrecordObjectMethodsWidgetA. 2))))
(is (false?
(= (DefrecordObjectMethodsWidgetA. 1)
(DefrecordObjectMethodsWidgetB. 1))))))
(deftest defrecord-acts-like-a-map
(let [rec (r 1 2)]
(is (.equals (r 1 3 {} {:c 4}) (merge rec {:b 3 :c 4})))
(is (.equals {:foo 1 :b 2} (set/rename-keys rec {:a :foo})))
(is (.equals {:a 11 :b 2 :c 10} (merge-with + rec {:a 10 :c 10})) )))
12.32. TEST/PROTOCOLS.CLJ 1631
(deftest degenerate-defrecord-test
(let [empty (EmptyRecord.)]
(is (nil? (seq empty)))
(is (not (.containsValue empty :a)))))
(deftest defrecord-interfaces-test
(testing "java.util.Map"
(let [rec (r 1 2)]
(is (= 2 (.size rec)))
(is (= 3 (.size (assoc rec :c 3))))
(is (not (.isEmpty rec)))
(is (.isEmpty (EmptyRecord.)))
(is (.containsKey rec :a))
(is (not (.containsKey rec :c)))
(is (.containsValue rec 1))
(is (not (.containsValue rec 3)))
(is (= 1 (.get rec :a)))
(is (thrown? UnsupportedOperationException (.put rec :a 1 )))
(is (thrown? UnsupportedOperationException (.remove rec :a)))
(is (thrown? UnsupportedOperationException (.putAll rec {})))
(is (thrown? UnsupportedOperationException (.clear rec) ))
(is (= #{:a :b} (.keySet rec)))
(is (= #{1 2} (set (.values rec))))
(is (= #{[:a 1] [:b 2]} (.entrySet rec)))
))
(testing "IPersistentCollection"
(testing ".cons"
(let [rec (r 1 2)]
(are [x] (= rec (.cons rec x))
nil {})
(is (= (r 1 3) (.cons rec {:b 3})))
(is (= (r 1 4) (.cons rec [:b 4])))
(is (= (r 1 5) (.cons rec (MapEntry. :b 5))))))))
(defrecord RecordWithSpecificFieldNames [this that k m o] )
(deftest defrecord-with-specific-field-names
(let [rec (new RecordWithSpecificFieldNames 1 2 3 4 5)]
(is (= rec rec))
(is (= 1 (:this (with-meta rec {:foo :bar}))))
(is (= 3 (get rec :k)))
(is (= (seq rec) ’([:this 1] [:that 2] [:k 3] [:m 4] [:o 5])))
(is (= (dissoc rec :k) {:this 1, :that 2, :m 4, :o 5}))))
(deftest reify-test
(testing "of an interface"
(let [s :foo
r (reify
java.util.List
(contains [_ o] (= s o)))]
1632 CHAPTER 12. TEST/CLOJURE
(testing "implemented methods"
(is (true? (.contains r :foo)))
(is (false? (.contains r :bar))))
(testing "unimplemented methods"
(is (thrown? AbstractMethodError (.add r :baz))))))
(testing "of two interfaces"
(let [r (reify
java.util.List
(contains [_ o] (= :foo o))
java.util.Collection
(isEmpty [_] false))]
(is (true? (.contains r :foo)))
(is (false? (.contains r :bar)))
(is (false? (.isEmpty r)))))
(testing "you can’t define a method twice"
(is (fails-with-cause?
java.lang.ClassFormatError
#"^(Repetitive|Duplicate) method name"
(eval ’(reify
java.util.List
(size [_] 10)
java.util.Collection
(size [_] 20))))))
(testing
"you can’t define a method not on an interface/protocol/j.l .Object"
(is (fails-with-cause?
IllegalArgumentException
#"^Can’t define method not in interfaces: foo"
(eval ’(reify java.util.List (foo [_]))))))
(testing "of a protocol"
(let [r (reify
ExampleProtocol
(bar [this o] o)
(baz [this] 1)
(baz [this o] 2))]
(= :foo (.bar r :foo))
(= 1 (.baz r))
(= 2 (.baz r nil))))
(testing "destructuring in method def"
(let [r (reify
ExampleProtocol
(bar [this [_ _ item]] item))]
(= :c (.bar r [:a :b :c]))))
(testing "methods can recur"
(let [r (reify
java.util.List
(get [_ index]
(if (zero? index)
:done
(recur (dec index)))))]
12.33. TEST/READER.CLJ 1633
(is (= :done (.get r 0)))
(is (= :done (.get r 1)))))
(testing "disambiguating with type hints"
(testing "you must hint an overloaded method"
(is (fails-with-cause?
IllegalArgumentException
#"Must hint overloaded method: hinted"
(eval ’(reify
clojure.test_clojure.protocols.examples.ExampleInte rface
(hinted [_ o]))))))
(testing "hinting"
(let [r (reify
ExampleInterface
(hinted [_ ^int i] (inc i))
(hinted [_ ^String s] (str s s)))]
(is (= 2 (.hinted r 1)))
(is (= "xoxo" (.hinted r "xo")))))))
———-
12.33 test/reader.clj
— test/reader.clj —
\getchunk{Clojure Copyright}
; Author: Stephen C. Gilardi
;;
;; Tests for the Clojure functions documented at the URL:
;;
;; http://clojure.org/Reader
;;
;; scgilardi (gmail)
;; Created 22 October 2008
(ns clojure.test-clojure.reader
(:use clojure.test)
(:import clojure.lang.BigInt))
;; Symbols
(deftest Symbols
(is (= ’abc (symbol "abc")))
(is (= ’*+!-_? (symbol "*+!-_?")))
(is (= ’abc:def:ghi (symbol "abc:def:ghi")))
1634 CHAPTER 12. TEST/CLOJURE
(is (= ’abc/def (symbol "abc" "def")))
(is (= ’abc.def/ghi (symbol "abc.def" "ghi")))
(is (= ’abc/def.ghi (symbol "abc" "def.ghi")))
(is (= ’abc:def/ghi:jkl.mno (symbol "abc:def" "ghi:jkl.m no")))
(is (instance? clojure.lang.Symbol ’alphabet))
)
;; Literals
(deftest Literals
; ’nil ’false ’true are reserved by Clojure and are not symbol s
(is (= ’nil nil))
(is (= ’false false))
(is (= ’true true)) )
;; Strings
(deftest Strings
(is (= "abcde" (str \a \b \c \d \e)))
(is (= "abc
def" (str \a \b \c \newline \space \space \d \e \f)))
)
;; Numbers
(deftest Numbers
; Read Integer
(is (instance? Long 2147483647))
(is (instance? Long +1))
(is (instance? Long 1))
(is (instance? Long +0))
(is (instance? Long 0))
(is (instance? Long -0))
(is (instance? Long -1))
(is (instance? Long -2147483648))
; Read Long
(is (instance? Long 2147483648))
(is (instance? Long -2147483649))
(is (instance? Long 9223372036854775807))
(is (instance? Long -9223372036854775808))
;; Numeric constants of different types don’t wash out. Regr ession
;; fixed in r1157. Previously the compiler saw 0 and 0.0 as the same
;; constant and caused the sequence to be built of Doubles.
(let [x 0.0]
(let [sequence (loop [i 0 l ’()]
(if (< i 5)
(recur (inc i) (conj l i))
12.33. TEST/READER.CLJ 1635
l))]
(is (= [4 3 2 1 0] sequence))
(is (every? #(instance? Long %)
sequence))))
; Read BigInteger
(is (instance? BigInt 9223372036854775808))
(is (instance? BigInt -9223372036854775809))
(is (instance? BigInt
10000000000000000000000000000000000000000000000000) )
(is (instance? BigInt
-10000000000000000000000000000000000000000000000000 ))
; Read Double
(is (instance? Double +1.0e+1))
(is (instance? Double +1.e+1))
(is (instance? Double +1e+1))
(is (instance? Double +1.0e1))
(is (instance? Double +1.e1))
(is (instance? Double +1e1))
(is (instance? Double +1.0e-1))
(is (instance? Double +1.e-1))
(is (instance? Double +1e-1))
(is (instance? Double 1.0e+1))
(is (instance? Double 1.e+1))
(is (instance? Double 1e+1))
(is (instance? Double 1.0e1))
(is (instance? Double 1.e1))
(is (instance? Double 1e1))
(is (instance? Double 1.0e-1))
(is (instance? Double 1.e-1))
(is (instance? Double 1e-1))
(is (instance? Double -1.0e+1))
(is (instance? Double -1.e+1))
(is (instance? Double -1e+1))
(is (instance? Double -1.0e1))
(is (instance? Double -1.e1))
(is (instance? Double -1e1))
(is (instance? Double -1.0e-1))
(is (instance? Double -1.e-1))
(is (instance? Double -1e-1))
1636 CHAPTER 12. TEST/CLOJURE
(is (instance? Double +1.0))
(is (instance? Double +1.))
(is (instance? Double 1.0))
(is (instance? Double 1.))
(is (instance? Double +0.0))
(is (instance? Double +0.))
(is (instance? Double 0.0))
(is (instance? Double 0.))
(is (instance? Double -0.0))
(is (instance? Double -0.))
(is (instance? Double -1.0))
(is (instance? Double -1.))
; Read BigDecimal
(is (instance? BigDecimal 9223372036854775808M))
(is (instance? BigDecimal -9223372036854775809M))
(is (instance? BigDecimal 2147483647M))
(is (instance? BigDecimal +1M))
(is (instance? BigDecimal 1M))
(is (instance? BigDecimal +0M))
(is (instance? BigDecimal 0M))
(is (instance? BigDecimal -0M))
(is (instance? BigDecimal -1M))
(is (instance? BigDecimal -2147483648M))
(is (instance? BigDecimal +1.0e+1M))
(is (instance? BigDecimal +1.e+1M))
(is (instance? BigDecimal +1e+1M))
(is (instance? BigDecimal +1.0e1M))
(is (instance? BigDecimal +1.e1M))
(is (instance? BigDecimal +1e1M))
(is (instance? BigDecimal +1.0e-1M))
(is (instance? BigDecimal +1.e-1M))
(is (instance? BigDecimal +1e-1M))
(is (instance? BigDecimal 1.0e+1M))
(is (instance? BigDecimal 1.e+1M))
(is (instance? BigDecimal 1e+1M))
(is (instance? BigDecimal 1.0e1M))
(is (instance? BigDecimal 1.e1M))
(is (instance? BigDecimal 1e1M))
12.33. TEST/READER.CLJ 1637
(is (instance? BigDecimal 1.0e-1M))
(is (instance? BigDecimal 1.e-1M))
(is (instance? BigDecimal 1e-1M))
(is (instance? BigDecimal -1.0e+1M))
(is (instance? BigDecimal -1.e+1M))
(is (instance? BigDecimal -1e+1M))
(is (instance? BigDecimal -1.0e1M))
(is (instance? BigDecimal -1.e1M))
(is (instance? BigDecimal -1e1M))
(is (instance? BigDecimal -1.0e-1M))
(is (instance? BigDecimal -1.e-1M))
(is (instance? BigDecimal -1e-1M))
(is (instance? BigDecimal +1.0M))
(is (instance? BigDecimal +1.M))
(is (instance? BigDecimal 1.0M))
(is (instance? BigDecimal 1.M))
(is (instance? BigDecimal +0.0M))
(is (instance? BigDecimal +0.M))
(is (instance? BigDecimal 0.0M))
(is (instance? BigDecimal 0.M))
(is (instance? BigDecimal -0.0M))
(is (instance? BigDecimal -0.M))
(is (instance? BigDecimal -1.0M))
(is (instance? BigDecimal -1.M))
)
;; Characters
(deftest t-Characters)
;; nil
(deftest t-nil)
;; Booleans
(deftest t-Booleans)
;; Keywords
(deftest t-Keywords
1638 CHAPTER 12. TEST/CLOJURE
(is (= :abc (keyword "abc")))
(is (= :abc (keyword ’abc)))
(is (= :*+!-_? (keyword "*+!-_?")))
(is (= :abc:def:ghi (keyword "abc:def:ghi")))
(is (= :abc/def (keyword "abc" "def")))
(is (= :abc/def (keyword ’abc/def)))
(is (= :abc.def/ghi (keyword "abc.def" "ghi")))
(is (= :abc/def.ghi (keyword "abc" "def.ghi")))
(is (= :abc:def/ghi:jkl.mno (keyword "abc:def" "ghi:jkl. mno")))
(is (instance? clojure.lang.Keyword :alphabet))
)
(deftest reading-keywords
(are [x y] (= x (read-string y))
:foo ":foo"
:foo/bar ":foo/bar"
:user/foo "::foo")
(are [err msg form] (thrown-with-msg? err msg (read-string form))
Exception #"Invalid token: foo:" "foo:"
Exception #"Invalid token: :bar/" ":bar/"
Exception #"Invalid token: ::does.not/exist" "::does.no t/exist"))
;; Lists
(deftest t-Lists)
;; Vectors
(deftest t-Vectors)
;; Maps
(deftest t-Maps)
;; Sets
(deftest t-Sets)
;; Macro characters
;; Quote (’)
(deftest t-Quote)
;; Character (\)
(deftest t-Character)
;; Comment (;)
(deftest t-Comment)
12.33. TEST/READER.CLJ 1639
;; Deref (@)
(deftest t-Deref)
;; Dispatch (#)
;; #{} - see Sets above
;; Regex patterns (#"pattern")
(deftest t-Regex)
;; Metadata (^ or #^ (deprecated))
(deftest t-Metadata
(is (= (meta ’^:static ^:awesome ^{:static false :bar :baz} sym)
{:awesome true, :bar :baz, :static true})))
;; Var-quote (#’)
(deftest t-Var-quote)
;; Anonymous function literal (#())
(deftest t-Anonymouns-function-literal)
;; Syntax-quote (‘, note, the "backquote" character), Unqu ote (~) and
;; Unquote-splicing (~@)
(deftest t-Syntax-quote
(are [x y] (= x y)
‘() () ; was NPE before SVN r1337
))
;; (read)
;; (read stream)
;; (read stream eof-is-error)
;; (read stream eof-is-error eof-value)
;; (read stream eof-is-error eof-value is-recursive)
(deftest t-read)
———-
1640 CHAPTER 12. TEST/CLOJURE
12.34 test/reﬂect.clj
— test/reﬂect.clj —
(ns clojure.test-clojure.reflect
(:use clojure.data [clojure.reflect
:as reflect] clojure.test clojure.pprint)
(:import [clojure.reflect AsmReflector JavaReflector]) )
(defn nodiff
[x y]
(let [[x-only y-only common] (diff x y)]
(when (or x-only y-only)
(is false (with-out-str (pprint {:x-only x-only
:y-only y-only
:common common}))))))
(deftest compare-reflect-and-asm
(let [cl (.getContextClassLoader (Thread/currentThread ))
asm-reflector (AsmReflector. cl)
java-reflector (JavaReflector. cl)]
(doseq [classname ’[java.lang.Runnable
java.lang.Object
java.io.FileInputStream
clojure.lang.Compiler
clojure.lang.PersistentVector]]
(nodiff (type-reflect classname :reflector asm-reflecto r)
(type-reflect classname :reflector java-reflector)))))
(deftest field-descriptor->class-symbol-test
(are [s d] (= s (@#’reflect/field-descriptor->class-symb ol d))
’clojure.asm.Type<><> "[[Lclojure/asm/Type;"
’int "I"
’java.lang.Object "Ljava.lang.Object;"))
(deftest internal-name->class-symbol-test
(are [s n] (= s (@#’reflect/internal-name->class-symbol n ))
’java.lang.Exception "java/lang/Exception"))
———-
12.35 test/refs.clj
— test/refs.clj —
\getchunk{Clojure Copyright}
12.36. TEST/REPL.CLJ 1641
; Author: Frantisek Sodomka
(ns clojure.test-clojure.refs
(:use clojure.test))
; http://clojure.org/refs
; ref
; deref, @-reader-macro
; dosync io!
; ensure ref-set alter commute
; set-validator get-validator
———-
12.36 test/repl.clj
— test/repl.clj —
(ns clojure.test-clojure.repl
(:use clojure.test
clojure.repl
[clojure.test-helper :only [platform-newlines]]
clojure.test-clojure.repl.example))
(deftest test-source
(is (= "(defn foo [])"
(source-fn ’clojure.test-clojure.repl.example/foo)))
(is (= (platform-newlines "(defn foo [])\n")
(with-out-str (source clojure.test-clojure.repl.examp le/foo))))
(is (nil? (source-fn ’non-existent-fn))))
(deftest test-dir
(is (thrown? Exception (dir-fn ’non-existent-ns)))
(is (= ’[bar foo] (dir-fn ’clojure.test-clojure.repl.exa mple)))
(is (= (platform-newlines "bar\nfoo\n")
(with-out-str (dir clojure.test-clojure.repl.example) ))))
(deftest test-apropos
(testing "with a regular expression"
(is (= ’[defmacro] (apropos #"^defmacro$")))
(is (some #{’defmacro} (apropos #"def.acr.")))
(is (= [] (apropos #"nothing-has-this-name"))))
1642 CHAPTER 12. TEST/CLOJURE
(testing "with a string"
(is (some #{’defmacro} (apropos "defmacro")))
(is (some #{’defmacro} (apropos "efmac")))
(is (= [] (apropos "nothing-has-this-name"))))
(testing "with a symbol"
(is (some #{’defmacro} (apropos ’defmacro)))
(is (some #{’defmacro} (apropos ’efmac)))
(is (= [] (apropos ’nothing-has-this-name)))))
———-
12.37 test/rt.clj
— test/rt.clj —
\getchunk{Clojure Copyright}
; Author: Stuart Halloway
(ns clojure.test-clojure.rt
(:use clojure.test clojure.test-helper))
(defmacro with-err-print-writer
"Evaluate with err pointing to a temporary PrintWriter, and
return err contents as a string."
[& body]
‘(let [s# (java.io.StringWriter.)
p# (java.io.PrintWriter. s#)]
(binding [*err* p#]
~@body
(str s#))))
(defmacro with-err-string-writer
"Evaluate with err pointing to a temporary StringWriter, an d
return err contents as a string."
[& body]
‘(let [s# (java.io.StringWriter.)]
(binding [*err* s#]
~@body
(str s#))))
(defmacro should-print-err-message
"Turn on all warning flags, and test that error message print s
correctly for all semi-reasonable bindings of *err*."
[msg-re form]
‘(binding [*warn-on-reflection* true]
12.37. TEST/RT.CLJ 1643
(is (re-matches ~msg-re
(with-err-string-writer (eval-in-temp-ns ~form))))
(is (re-matches ~msg-re
(with-err-print-writer (eval-in-temp-ns ~form))))))
(defn bare-rt-print
"Return string RT would print prior to print-initialize"
[x]
(with-out-str
(try
(push-thread-bindings {#’clojure.core/print-initiali zed false})
(clojure.lang.RT/print x *out*)
(finally
(pop-thread-bindings)))))
(deftest rt-print-prior-to-print-initialize
(testing "pattern literals"
(is (= "#\"foo\"" (bare-rt-print #"foo")))))
;tpd broke these tests by splitting the regex
(deftest error-messages
; (testing "binding a core var that already refers to somethi ng"
; (should-print-err-message
; (str "WARNING: prefers already refers to: "
; "#’clojure.core/prefers in namespace: .?")
; (defn prefers [] (throw (RuntimeException. "rebound!")) )))
; (testing "reflection cannot resolve field"
; (should-print-err-message
; (str "Reflection warning, NO_SOURCE_PATH: + - reference t o field "
; "blah can’t be resolved.?")
; (defn foo [x] (.blah x))))
; (testing "reflection cannot resolve instance method"
; (should-print-err-message
; (str "Reflection warning, NO_SOURCE_PATH:+ - call to zap c an’t "
; "be resolved.?")
; (defn foo [x] (.zap x 1))))
; (testing "reflection cannot resolve static method"
; (should-print-err-message
; (str "Reflection warning, NO_SOURCE_PATH:+ - call to valu eOf "
; "can’t be resolved.?")
; (defn foo [] (Integer/valueOf #"boom"))))
; (testing "reflection cannot resolve constructor"
; (should-print-err-message
; (str "Reflection warning, NO_SOURCE_PATH:+ - call to "
; "java.lang.String ctor can’t be resolved.?")
; (defn foo [] (String. 1 2 3))))
)
(def example-var)
(deftest binding-root-clears-macro-metadata
1644 CHAPTER 12. TEST/CLOJURE
(alter-meta! #’example-var assoc :macro true)
(is (contains? (meta #’example-var) :macro))
(.bindRoot #’example-var 0)
(is (not (contains? (meta #’example-var) :macro))))
(deftest last-var-wins-for-core
(testing "you can replace a core name, with warning"
(let [ns (temp-ns)
replacement (gensym)]
(with-err-string-writer (intern ns ’prefers replacement ))
(is (= replacement @(’prefers (ns-publics ns))))))
(testing "you can replace a name you defined before"
(let [ns (temp-ns)
s (gensym)
v1 (intern ns ’foo s)
v2 (intern ns ’bar s)]
(with-err-string-writer (.refer ns ’flatten v1))
(.refer ns ’flatten v2)
(is (= v2 (ns-resolve ns ’flatten)))))
(testing "you cannot intern over an existing non-core name"
(let [ns (temp-ns ’clojure.set)
replacement (gensym)]
(is (thrown? IllegalStateException
(intern ns ’subset? replacement)))
(is (nil? (’subset? (ns-publics ns))))
(is (= #’clojure.set/subset? (’subset? (ns-refers ns)))) ))
(testing "you cannot refer over an existing non-core name"
(let [ns (temp-ns ’clojure.set)
replacement (gensym)]
(is (thrown? IllegalStateException
(.refer ns ’subset? #’clojure.set/intersection)))
(is (nil? (’subset? (ns-publics ns))))
(is (= #’clojure.set/subset? (’subset? (ns-refers ns)))) )))
———-
12.38 test/sequences.clj
— test/sequences.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
; Contributors: Stuart Halloway
(ns clojure.test-clojure.sequences
(:use clojure.test))
12.38. TEST/SEQUENCES.CLJ 1645
;; *** Tests ***
; TODO:
; apply, map, filter, remove
; and more...
(deftest test-reduce-from-chunked-into-unchunked
(= [1 2 \a \b] (into [] (concat [1 2] "ab"))))
(deftest test-reduce
(let [int+ (fn [a b] (+ (int a) (int b)))
arange (range 100) ;; enough to cross nodes
avec (into [] arange)
alist (into () arange)
obj-array (into-array arange)
int-array
(into-array Integer/TYPE (map #(Integer. (int %)) arange) )
long-array (into-array Long/TYPE arange)
float-array (into-array Float/TYPE arange)
char-array (into-array Character/TYPE (map char arange))
double-array (into-array Double/TYPE arange)
byte-array (into-array Byte/TYPE (map byte arange))
int-vec (into (vector-of :int) arange)
long-vec (into (vector-of :long) arange)
float-vec (into (vector-of :float) arange)
char-vec (into (vector-of :char) (map char arange))
double-vec (into (vector-of :double) arange)
byte-vec (into (vector-of :byte) (map byte arange))
all-true (into-array Boolean/TYPE (repeat 10 true))]
(is (== 4950
(reduce + arange)
(reduce + avec)
(reduce + alist)
(reduce + obj-array)
(reduce + int-array)
(reduce + long-array)
(reduce + float-array)
(reduce int+ char-array)
(reduce + double-array)
(reduce int+ byte-array)
(reduce + int-vec)
(reduce + long-vec)
(reduce + float-vec)
(reduce int+ char-vec)
(reduce + double-vec)
(reduce int+ byte-vec)))
(is (== 4951
(reduce + 1 arange)
(reduce + 1 avec)
1646 CHAPTER 12. TEST/CLOJURE
(reduce + 1 alist)
(reduce + 1 obj-array)
(reduce + 1 int-array)
(reduce + 1 long-array)
(reduce + 1 float-array)
(reduce int+ 1 char-array)
(reduce + 1 double-array)
(reduce int+ 1 byte-array)
(reduce + 1 int-vec)
(reduce + 1 long-vec)
(reduce + 1 float-vec)
(reduce int+ 1 char-vec)
(reduce + 1 double-vec)
(reduce int+ 1 byte-vec)))
(is (= true
(reduce #(and %1 %2) all-true)
(reduce #(and %1 %2) true all-true)))))
(deftest test-equality
; lazy sequences
(are [x y] (= x y)
; fixed SVN 1288 - LazySeq and EmptyList equals/equiv
; http://groups.google.com/group/clojure/
; browse_frm/thread/286d807be9cae2a5#
(map inc nil) ()
(map inc ()) ()
(map inc []) ()
(map inc #{}) ()
(map inc {}) () ))
(deftest test-lazy-seq
(are [x] (seq? x)
(lazy-seq nil)
(lazy-seq [])
(lazy-seq [1 2]))
(are [x y] (= x y)
(lazy-seq nil) ()
(lazy-seq [nil]) ’(nil)
(lazy-seq ()) ()
(lazy-seq []) ()
(lazy-seq #{}) ()
(lazy-seq {}) ()
(lazy-seq "") ()
(lazy-seq (into-array [])) ()
(lazy-seq (list 1 2)) ’(1 2)
(lazy-seq [1 2]) ’(1 2)
12.38. TEST/SEQUENCES.CLJ 1647
(lazy-seq (sorted-set 1 2)) ’(1 2)
(lazy-seq (sorted-map :a 1 :b 2)) ’([:a 1] [:b 2])
(lazy-seq "abc") ’(\a \b \c)
(lazy-seq (into-array [1 2])) ’(1 2) ))
(deftest test-seq
(is (not (seq? (seq []))))
(is (seq? (seq [1 2])))
(are [x y] (= x y)
(seq nil) nil
(seq [nil]) ’(nil)
(seq ()) nil
(seq []) nil
(seq #{}) nil
(seq {}) nil
(seq "") nil
(seq (into-array [])) nil
(seq (list 1 2)) ’(1 2)
(seq [1 2]) ’(1 2)
(seq (sorted-set 1 2)) ’(1 2)
(seq (sorted-map :a 1 :b 2)) ’([:a 1] [:b 2])
(seq "abc") ’(\a \b \c)
(seq (into-array [1 2])) ’(1 2) ))
(deftest test-cons
(is (thrown? IllegalArgumentException (cons 1 2)))
(are [x y] (= x y)
(cons 1 nil) ’(1)
(cons nil nil) ’(nil)
(cons \a nil) ’(\a)
(cons \a "") ’(\a)
(cons \a "bc") ’(\a \b \c)
(cons 1 ()) ’(1)
(cons 1 ’(2 3)) ’(1 2 3)
(cons 1 []) [1]
(cons 1 [2 3]) [1 2 3]
(cons 1 #{}) ’(1)
(cons 1 (sorted-set 2 3)) ’(1 2 3)
(cons 1 (into-array [])) ’(1)
(cons 1 (into-array [2 3])) ’(1 2 3) ))
1648 CHAPTER 12. TEST/CLOJURE
(deftest test-empty
(are [x y] (and (= (empty x) y)
(= (class (empty x)) (class y)))
nil nil
() ()
’(1 2) ()
[] []
[1 2] []
{} {}
{:a 1 :b 2} {}
(sorted-map) (sorted-map)
(sorted-map :a 1 :b 2) (sorted-map)
#{} #{}
#{1 2} #{}
(sorted-set) (sorted-set)
(sorted-set 1 2) (sorted-set)
(seq ()) nil ; (seq ()) => nil
(seq ’(1 2)) ()
(seq []) nil ; (seq []) => nil
(seq [1 2]) ()
(seq "") nil ; (seq "") => nil
(seq "ab") ()
(lazy-seq ()) ()
(lazy-seq ’(1 2)) ()
(lazy-seq []) ()
(lazy-seq [1 2]) ()
; non-coll, non-seq => nil
42 nil
1.2 nil
"abc" nil ))
;Tests that the comparator is preservered
;The first element should be the same in each set if preserved .
(deftest test-empty-sorted
(let [inv-compare (comp - compare)]
(are [x y] (= (first (into (empty x) x))
12.38. TEST/SEQUENCES.CLJ 1649
(first y))
(sorted-set 1 2 3) (sorted-set 1 2 3)
(sorted-set-by inv-compare 1 2 3) (sorted-set-by inv-comp are 1 2 3)
(sorted-map 1 :a 2 :b 3 :c) (sorted-map 1 :a 2 :b 3 :c)
(sorted-map-by inv-compare 1 :a 2 :b 3 :c)
(sorted-map-by inv-compare 1 :a 2 :b 3 :c))))
(deftest test-not-empty
; empty coll/seq => nil
(are [x] (= (not-empty x) nil)
()
[]
{}
#{}
(seq ())
(seq [])
(lazy-seq ())
(lazy-seq []) )
; non-empty coll/seq => identity
(are [x] (and (= (not-empty x) x)
(= (class (not-empty x)) (class x)))
’(1 2)
[1 2]
{:a 1}
#{1 2}
(seq ’(1 2))
(seq [1 2])
(lazy-seq ’(1 2))
(lazy-seq [1 2]) ))
(deftest test-first
;(is (thrown? Exception (first)))
(is (thrown? IllegalArgumentException (first true)))
(is (thrown? IllegalArgumentException (first false)))
(is (thrown? IllegalArgumentException (first 1)))
;(is (thrown? IllegalArgumentException (first 1 2)))
(is (thrown? IllegalArgumentException (first \a)))
(is (thrown? IllegalArgumentException (first ’s)))
(is (thrown? IllegalArgumentException (first :k)))
(are [x y] (= x y)
(first nil) nil
; string
(first "") nil
(first "a") \a
(first "abc") \a
1650 CHAPTER 12. TEST/CLOJURE
; list
(first ()) nil
(first ’(1)) 1
(first ’(1 2 3)) 1
(first ’(nil)) nil
(first ’(1 nil)) 1
(first ’(nil 2)) nil
(first ’(())) ()
(first ’(() nil)) ()
(first ’(() 2 nil)) ()
; vector
(first []) nil
(first [1]) 1
(first [1 2 3]) 1
(first [nil]) nil
(first [1 nil]) 1
(first [nil 2]) nil
(first [[]]) []
(first [[] nil]) []
(first [[] 2 nil]) []
; set
(first #{}) nil
(first #{1}) 1
(first (sorted-set 1 2 3)) 1
(first #{nil}) nil
(first (sorted-set 1 nil)) nil
(first (sorted-set nil 2)) nil
(first #{#{}}) #{}
(first (sorted-set #{} nil)) nil
;(first (sorted-set #{} 2 nil)) nil
; map
(first {}) nil
(first (sorted-map :a 1)) ’(:a 1)
(first (sorted-map :a 1 :b 2 :c 3)) ’(:a 1)
; array
(first (into-array [])) nil
(first (into-array [1])) 1
(first (into-array [1 2 3])) 1
(first (to-array [nil])) nil
(first (to-array [1 nil])) 1
(first (to-array [nil 2])) nil ))
12.38. TEST/SEQUENCES.CLJ 1651
(deftest test-next
; (is (thrown? IllegalArgumentException (next)))
(is (thrown? IllegalArgumentException (next true)))
(is (thrown? IllegalArgumentException (next false)))
(is (thrown? IllegalArgumentException (next 1)))
;(is (thrown? IllegalArgumentException (next 1 2)))
(is (thrown? IllegalArgumentException (next \a)))
(is (thrown? IllegalArgumentException (next ’s)))
(is (thrown? IllegalArgumentException (next :k)))
(are [x y] (= x y)
(next nil) nil
; string
(next "") nil
(next "a") nil
(next "abc") ’(\b \c)
; list
(next ()) nil
(next ’(1)) nil
(next ’(1 2 3)) ’(2 3)
(next ’(nil)) nil
(next ’(1 nil)) ’(nil)
(next ’(1 ())) ’(())
(next ’(nil 2)) ’(2)
(next ’(())) nil
(next ’(() nil)) ’(nil)
(next ’(() 2 nil)) ’(2 nil)
; vector
(next []) nil
(next [1]) nil
(next [1 2 3]) [2 3]
(next [nil]) nil
(next [1 nil]) [nil]
(next [1 []]) [[]]
(next [nil 2]) [2]
(next [[]]) nil
(next [[] nil]) [nil]
(next [[] 2 nil]) [2 nil]
; set
(next #{}) nil
(next #{1}) nil
(next (sorted-set 1 2 3)) ’(2 3)
(next #{nil}) nil
1652 CHAPTER 12. TEST/CLOJURE
(next (sorted-set 1 nil)) ’(1)
(next (sorted-set nil 2)) ’(2)
(next #{#{}}) nil
(next (sorted-set #{} nil)) ’(#{})
;(next (sorted-set #{} 2 nil)) #{}
; map
(next {}) nil
(next (sorted-map :a 1)) nil
(next (sorted-map :a 1 :b 2 :c 3)) ’((:b 2) (:c 3))
; array
(next (into-array [])) nil
(next (into-array [1])) nil
(next (into-array [1 2 3])) ’(2 3)
(next (to-array [nil])) nil
(next (to-array [1 nil])) ’(nil)
;(next (to-array [1 (into-array [])])) (list (into-array [ ]))
(next (to-array [nil 2])) ’(2)
(next (to-array [(into-array [])])) nil
(next (to-array [(into-array []) nil])) ’(nil)
(next (to-array [(into-array []) 2 nil])) ’(2 nil) ))
(deftest test-last
(are [x y] (= x y)
(last nil) nil
; list
(last ()) nil
(last ’(1)) 1
(last ’(1 2 3)) 3
(last ’(nil)) nil
(last ’(1 nil)) nil
(last ’(nil 2)) 2
(last ’(())) ()
(last ’(() nil)) nil
(last ’(() 2 nil)) nil
; vector
(last []) nil
(last [1]) 1
(last [1 2 3]) 3
(last [nil]) nil
(last [1 nil]) nil
(last [nil 2]) 2
(last [[]]) []
12.38. TEST/SEQUENCES.CLJ 1653
(last [[] nil]) nil
(last [[] 2 nil]) nil
; set
(last #{}) nil
(last #{1}) 1
(last (sorted-set 1 2 3)) 3
(last #{nil}) nil
(last (sorted-set 1 nil)) 1
(last (sorted-set nil 2)) 2
(last #{#{}}) #{}
(last (sorted-set #{} nil)) #{}
;(last (sorted-set #{} 2 nil)) nil
; map
(last {}) nil
(last (sorted-map :a 1)) [:a 1]
(last (sorted-map :a 1 :b 2 :c 3)) [:c 3]
; string
(last "") nil
(last "a") \a
(last "abc") \c
; array
(last (into-array [])) nil
(last (into-array [1])) 1
(last (into-array [1 2 3])) 3
(last (to-array [nil])) nil
(last (to-array [1 nil])) nil
(last (to-array [nil 2])) 2 ))
;; (ffirst coll) = (first (first coll))
;;
(deftest test-ffirst
; (is (thrown? IllegalArgumentException (ffirst)))
(are [x y] (= x y)
(ffirst nil) nil
(ffirst ()) nil
(ffirst ’((1 2) (3 4))) 1
(ffirst []) nil
(ffirst [[1 2] [3 4]]) 1
(ffirst {}) nil
(ffirst {:a 1}) :a
1654 CHAPTER 12. TEST/CLOJURE
(ffirst #{}) nil
(ffirst #{[1 2]}) 1 ))
;; (fnext coll) = (first (next coll)) = (second coll)
;;
(deftest test-fnext
; (is (thrown? IllegalArgumentException (fnext)))
(are [x y] (= x y)
(fnext nil) nil
(fnext ()) nil
(fnext ’(1)) nil
(fnext ’(1 2 3 4)) 2
(fnext []) nil
(fnext [1]) nil
(fnext [1 2 3 4]) 2
(fnext {}) nil
(fnext (sorted-map :a 1)) nil
(fnext (sorted-map :a 1 :b 2)) [:b 2]
(fnext #{}) nil
(fnext #{1}) nil
(fnext (sorted-set 1 2 3 4)) 2 ))
;; (nfirst coll) = (next (first coll))
;;
(deftest test-nfirst
; (is (thrown? IllegalArgumentException (nfirst)))
(are [x y] (= x y)
(nfirst nil) nil
(nfirst ()) nil
(nfirst ’((1 2 3) (4 5 6))) ’(2 3)
(nfirst []) nil
(nfirst [[1 2 3] [4 5 6]]) ’(2 3)
(nfirst {}) nil
(nfirst {:a 1}) ’(1)
(nfirst #{}) nil
(nfirst #{[1 2]}) ’(2) ))
;; (nnext coll) = (next (next coll))
;;
12.38. TEST/SEQUENCES.CLJ 1655
(deftest test-nnext
; (is (thrown? IllegalArgumentException (nnext)))
(are [x y] (= x y)
(nnext nil) nil
(nnext ()) nil
(nnext ’(1)) nil
(nnext ’(1 2)) nil
(nnext ’(1 2 3 4)) ’(3 4)
(nnext []) nil
(nnext [1]) nil
(nnext [1 2]) nil
(nnext [1 2 3 4]) ’(3 4)
(nnext {}) nil
(nnext (sorted-map :a 1)) nil
(nnext (sorted-map :a 1 :b 2)) nil
(nnext (sorted-map :a 1 :b 2 :c 3 :d 4)) ’([:c 3] [:d 4])
(nnext #{}) nil
(nnext #{1}) nil
(nnext (sorted-set 1 2)) nil
(nnext (sorted-set 1 2 3 4)) ’(3 4) ))
(deftest test-nth
; maps, sets are not supported
(is (thrown? UnsupportedOperationException (nth {} 0)))
(is (thrown? UnsupportedOperationException (nth {:a 1 :b 2 } 0)))
(is (thrown? UnsupportedOperationException (nth #{} 0)))
(is (thrown? UnsupportedOperationException (nth #{1 2 3} 0 )))
; out of bounds
(is (thrown? IndexOutOfBoundsException (nth ’() 0)))
(is (thrown? IndexOutOfBoundsException (nth ’(1 2 3) 5)))
(is (thrown? IndexOutOfBoundsException (nth ’() -1)))
(is (thrown? IndexOutOfBoundsException (nth ’(1 2 3) -1)))
(is (thrown? IndexOutOfBoundsException (nth [] 0)))
(is (thrown? IndexOutOfBoundsException (nth [1 2 3] 5)))
(is (thrown? IndexOutOfBoundsException (nth [] -1)))
(is (thrown? IndexOutOfBoundsException (nth [1 2 3] -1))) ; ???
(is (thrown? IndexOutOfBoundsException (nth (into-array []) 0)))
(is (thrown? IndexOutOfBoundsException (nth (into-array [1 2 3]) 5)))
(is (thrown? IndexOutOfBoundsException (nth (into-array []) -1)))
(is (thrown? IndexOutOfBoundsException (nth (into-array [1 2 3]) -1)))
(is (thrown? StringIndexOutOfBoundsException (nth "" 0)) )
1656 CHAPTER 12. TEST/CLOJURE
(is (thrown? StringIndexOutOfBoundsException (nth "abc" 5)))
(is (thrown? StringIndexOutOfBoundsException (nth "" -1) ))
(is (thrown? StringIndexOutOfBoundsException (nth "abc" -1)))
(is (thrown? IndexOutOfBoundsException
(nth (java.util.ArrayList. []) 0)))
(is (thrown? IndexOutOfBoundsException
(nth (java.util.ArrayList. [1 2 3]) 5)))
(is (thrown? IndexOutOfBoundsException
(nth (java.util.ArrayList. []) -1))) ; ???
(is (thrown? IndexOutOfBoundsException
(nth (java.util.ArrayList. [1 2 3]) -1))) ; ???
(are [x y] (= x y)
(nth ’(1) 0) 1
(nth ’(1 2 3) 0) 1
(nth ’(1 2 3 4 5) 1) 2
(nth ’(1 2 3 4 5) 4) 5
(nth ’(1 2 3) 5 :not-found) :not-found
(nth [1] 0) 1
(nth [1 2 3] 0) 1
(nth [1 2 3 4 5] 1) 2
(nth [1 2 3 4 5] 4) 5
(nth [1 2 3] 5 :not-found) :not-found
(nth (into-array [1]) 0) 1
(nth (into-array [1 2 3]) 0) 1
(nth (into-array [1 2 3 4 5]) 1) 2
(nth (into-array [1 2 3 4 5]) 4) 5
(nth (into-array [1 2 3]) 5 :not-found) :not-found
(nth "a" 0) \a
(nth "abc" 0) \a
(nth "abcde" 1) \b
(nth "abcde" 4) \e
(nth "abc" 5 :not-found) :not-found
(nth (java.util.ArrayList. [1]) 0) 1
(nth (java.util.ArrayList. [1 2 3]) 0) 1
(nth (java.util.ArrayList. [1 2 3 4 5]) 1) 2
(nth (java.util.ArrayList. [1 2 3 4 5]) 4) 5
(nth (java.util.ArrayList. [1 2 3]) 5 :not-found) :not-fou nd )
; regex Matchers
(let [m (re-matcher #"(a)(b)" "ababaa")]
(re-find m) ; => ["ab" "a" "b"]
(are [x y] (= x y)
(nth m 0) "ab"
(nth m 1) "a"
12.38. TEST/SEQUENCES.CLJ 1657
(nth m 2) "b"
(nth m 3 :not-found) :not-found
(nth m -1 :not-found) :not-found )
(is (thrown? IndexOutOfBoundsException (nth m 3)))
(is (thrown? IndexOutOfBoundsException (nth m -1))))
(let [m (re-matcher #"c" "ababaa")]
(re-find m) ; => nil
(are [x y] (= x y)
(nth m 0 :not-found) :not-found
(nth m 2 :not-found) :not-found
(nth m -1 :not-found) :not-found )
(is (thrown? IllegalStateException (nth m 0)))
(is (thrown? IllegalStateException (nth m 2)))
(is (thrown? IllegalStateException (nth m -1)))))
; distinct was broken for nil & false:
; fixed in rev 1278:
; http://code.google.com/p/clojure/source/detail?r=1 278
;
(deftest test-distinct
(are [x y] (= x y)
(distinct ()) ()
(distinct ’(1)) ’(1)
(distinct ’(1 2 3)) ’(1 2 3)
(distinct ’(1 2 3 1 1 1)) ’(1 2 3)
(distinct ’(1 1 1 2)) ’(1 2)
(distinct ’(1 2 1 2)) ’(1 2)
(distinct []) ()
(distinct [1]) ’(1)
(distinct [1 2 3]) ’(1 2 3)
(distinct [1 2 3 1 2 2 1 1]) ’(1 2 3)
(distinct [1 1 1 2]) ’(1 2)
(distinct [1 2 1 2]) ’(1 2)
(distinct "") ()
(distinct "a") ’(\a)
(distinct "abc") ’(\a \b \c)
(distinct "abcabab") ’(\a \b \c)
(distinct "aaab") ’(\a \b)
(distinct "abab") ’(\a \b) )
(are [x] (= (distinct [x x]) [x])
nil
false true
0 42
0.0 3.14
2/3
1658 CHAPTER 12. TEST/CLOJURE
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} ))
(deftest test-interpose
(are [x y] (= x y)
(interpose 0 []) ()
(interpose 0 [1]) ’(1)
(interpose 0 [1 2]) ’(1 0 2)
(interpose 0 [1 2 3]) ’(1 0 2 0 3) ))
(deftest test-interleave
(are [x y] (= x y)
(interleave [1 2] [3 4]) ’(1 3 2 4)
(interleave [1] [3 4]) ’(1 3)
(interleave [1 2] [3]) ’(1 3)
(interleave [] [3 4]) ()
(interleave [1 2] []) ()
(interleave [] []) () ))
(deftest test-zipmap
(are [x y] (= x y)
(zipmap [:a :b] [1 2]) {:a 1 :b 2}
(zipmap [:a] [1 2]) {:a 1}
(zipmap [:a :b] [1]) {:a 1}
(zipmap [] [1 2]) {}
(zipmap [:a :b] []) {}
(zipmap [] []) {} ))
(deftest test-concat
(are [x y] (= x y)
(concat) ()
(concat []) ()
(concat [1 2]) ’(1 2)
12.38. TEST/SEQUENCES.CLJ 1659
(concat [1 2] [3 4]) ’(1 2 3 4)
(concat [] [3 4]) ’(3 4)
(concat [1 2] []) ’(1 2)
(concat [] []) ()
(concat [1 2] [3 4] [5 6]) ’(1 2 3 4 5 6) ))
(deftest test-cycle
(are [x y] (= x y)
(cycle []) ()
(take 3 (cycle [1])) ’(1 1 1)
(take 5 (cycle [1 2 3])) ’(1 2 3 1 2)
(take 3 (cycle [nil])) ’(nil nil nil) ))
(deftest test-partition
(are [x y] (= x y)
(partition 2 [1 2 3]) ’((1 2))
(partition 2 [1 2 3 4]) ’((1 2) (3 4))
(partition 2 []) ()
(partition 2 3 [1 2 3 4 5 6 7]) ’((1 2) (4 5))
(partition 2 3 [1 2 3 4 5 6 7 8]) ’((1 2) (4 5) (7 8))
(partition 2 3 []) ()
(partition 1 []) ()
(partition 1 [1 2 3]) ’((1) (2) (3))
(partition 5 [1 2 3]) ()
; (partition 0 [1 2 3]) (repeat nil) ; infinite sequence of nil
(partition -1 [1 2 3]) ()
(partition -2 [1 2 3]) () ))
(deftest test-reverse
(are [x y] (= x y)
(reverse nil) () ; since SVN 1294
(reverse []) ()
(reverse [1]) ’(1)
(reverse [1 2 3]) ’(3 2 1) ))
(deftest test-take
(are [x y] (= x y)
(take 1 [1 2 3 4 5]) ’(1)
(take 3 [1 2 3 4 5]) ’(1 2 3)
1660 CHAPTER 12. TEST/CLOJURE
(take 5 [1 2 3 4 5]) ’(1 2 3 4 5)
(take 9 [1 2 3 4 5]) ’(1 2 3 4 5)
(take 0 [1 2 3 4 5]) ()
(take -1 [1 2 3 4 5]) ()
(take -2 [1 2 3 4 5]) () ))
(deftest test-drop
(are [x y] (= x y)
(drop 1 [1 2 3 4 5]) ’(2 3 4 5)
(drop 3 [1 2 3 4 5]) ’(4 5)
(drop 5 [1 2 3 4 5]) ()
(drop 9 [1 2 3 4 5]) ()
(drop 0 [1 2 3 4 5]) ’(1 2 3 4 5)
(drop -1 [1 2 3 4 5]) ’(1 2 3 4 5)
(drop -2 [1 2 3 4 5]) ’(1 2 3 4 5) ))
(deftest test-take-nth
(are [x y] (= x y)
(take-nth 1 [1 2 3 4 5]) ’(1 2 3 4 5)
(take-nth 2 [1 2 3 4 5]) ’(1 3 5)
(take-nth 3 [1 2 3 4 5]) ’(1 4)
(take-nth 4 [1 2 3 4 5]) ’(1 5)
(take-nth 5 [1 2 3 4 5]) ’(1)
(take-nth 9 [1 2 3 4 5]) ’(1)
; infinite seq of 1s = (repeat 1)
;(take-nth 0 [1 2 3 4 5])
;(take-nth -1 [1 2 3 4 5])
;(take-nth -2 [1 2 3 4 5])
))
(deftest test-take-while
(are [x y] (= x y)
(take-while pos? []) ()
(take-while pos? [1 2 3 4]) ’(1 2 3 4)
(take-while pos? [1 2 3 -1]) ’(1 2 3)
(take-while pos? [1 -1 2 3]) ’(1)
(take-while pos? [-1 1 2 3]) ()
(take-while pos? [-1 -2 -3]) () ))
(deftest test-drop-while
(are [x y] (= x y)
(drop-while pos? []) ()
(drop-while pos? [1 2 3 4]) ()
12.38. TEST/SEQUENCES.CLJ 1661
(drop-while pos? [1 2 3 -1]) ’(-1)
(drop-while pos? [1 -1 2 3]) ’(-1 2 3)
(drop-while pos? [-1 1 2 3]) ’(-1 1 2 3)
(drop-while pos? [-1 -2 -3]) ’(-1 -2 -3) ))
(deftest test-butlast
(are [x y] (= x y)
(butlast []) nil
(butlast [1]) nil
(butlast [1 2 3]) ’(1 2) ))
(deftest test-drop-last
(are [x y] (= x y)
; as butlast
(drop-last []) ()
(drop-last [1]) ()
(drop-last [1 2 3]) ’(1 2)
; as butlast, but lazy
(drop-last 1 []) ()
(drop-last 1 [1]) ()
(drop-last 1 [1 2 3]) ’(1 2)
(drop-last 2 []) ()
(drop-last 2 [1]) ()
(drop-last 2 [1 2 3]) ’(1)
(drop-last 5 []) ()
(drop-last 5 [1]) ()
(drop-last 5 [1 2 3]) ()
(drop-last 0 []) ()
(drop-last 0 [1]) ’(1)
(drop-last 0 [1 2 3]) ’(1 2 3)
(drop-last -1 []) ()
(drop-last -1 [1]) ’(1)
(drop-last -1 [1 2 3]) ’(1 2 3)
(drop-last -2 []) ()
(drop-last -2 [1]) ’(1)
(drop-last -2 [1 2 3]) ’(1 2 3) ))
(deftest test-split-at
(is (vector? (split-at 2 [])))
(is (vector? (split-at 2 [1 2 3])))
1662 CHAPTER 12. TEST/CLOJURE
(are [x y] (= x y)
(split-at 2 []) [() ()]
(split-at 2 [1 2 3 4 5]) [(list 1 2) (list 3 4 5)]
(split-at 5 [1 2 3]) [(list 1 2 3) ()]
(split-at 0 [1 2 3]) [() (list 1 2 3)]
(split-at -1 [1 2 3]) [() (list 1 2 3)]
(split-at -5 [1 2 3]) [() (list 1 2 3)] ))
(deftest test-split-with
(is (vector? (split-with pos? [])))
(is (vector? (split-with pos? [1 2 -1 0 3 4])))
(are [x y] (= x y)
(split-with pos? []) [() ()]
(split-with pos? [1 2 -1 0 3 4]) [(list 1 2) (list -1 0 3 4)]
(split-with pos? [-1 2 3 4 5]) [() (list -1 2 3 4 5)]
(split-with number? [1 -2 "abc" \x])
[(list 1 -2) (list "abc" \x)] ))
(deftest test-repeat
;(is (thrown? IllegalArgumentException (repeat)))
; infinite sequence => use take
(are [x y] (= x y)
(take 0 (repeat 7)) ()
(take 1 (repeat 7)) ’(7)
(take 2 (repeat 7)) ’(7 7)
(take 5 (repeat 7)) ’(7 7 7 7 7) )
; limited sequence
(are [x y] (= x y)
(repeat 0 7) ()
(repeat 1 7) ’(7)
(repeat 2 7) ’(7 7)
(repeat 5 7) ’(7 7 7 7 7)
(repeat -1 7) ()
(repeat -3 7) () )
; test different data types
(are [x] (= (repeat 3 x) (list x x x))
nil
false true
0 42
0.0 3.14
2/3
12.38. TEST/SEQUENCES.CLJ 1663
0M 1M
\c
"" "abc"
’sym
:kw
() ’(1 2)
[] [1 2]
{} {:a 1 :b 2}
#{} #{1 2} ))
(deftest test-range
(are [x y] (= x y)
(range 0) () ; exclusive end!
(range 1) ’(0)
(range 5) ’(0 1 2 3 4)
(range -1) ()
(range -3) ()
(range 2.5) ’(0 1 2)
(range 7/3) ’(0 1 2)
(range 0 3) ’(0 1 2)
(range 0 1) ’(0)
(range 0 0) ()
(range 0 -3) ()
(range 3 6) ’(3 4 5)
(range 3 4) ’(3)
(range 3 3) ()
(range 3 1) ()
(range 3 0) ()
(range 3 -2) ()
(range -2 5) ’(-2 -1 0 1 2 3 4)
(range -2 0) ’(-2 -1)
(range -2 -1) ’(-2)
(range -2 -2) ()
(range -2 -5) ()
(range 3 9 0) ()
(range 3 9 1) ’(3 4 5 6 7 8)
(range 3 9 2) ’(3 5 7)
(range 3 9 3) ’(3 6)
(range 3 9 10) ’(3)
(range 3 9 -1) () ))
(deftest test-empty?
1664 CHAPTER 12. TEST/CLOJURE
(are [x] (empty? x)
nil
()
(lazy-seq nil) ; => ()
[]
{}
#{}
""
(into-array []) )
(are [x] (not (empty? x))
’(1 2)
(lazy-seq [1 2])
[1 2]
{:a 1 :b 2}
#{1 2}
"abc"
(into-array [1 2]) ))
(deftest test-every?
; always true for nil or empty coll/seq
(are [x] (= (every? pos? x) true)
nil
() [] {} #{}
(lazy-seq [])
(into-array []) )
(are [x y] (= x y)
true (every? pos? [1])
true (every? pos? [1 2])
true (every? pos? [1 2 3 4 5])
false (every? pos? [-1])
false (every? pos? [-1 -2])
false (every? pos? [-1 -2 3])
false (every? pos? [-1 2])
false (every? pos? [1 -2])
false (every? pos? [1 2 -3])
false (every? pos? [1 2 -3 4]) )
(are [x y] (= x y)
true (every? #{:a} [:a :a])
;! false (every? #{:a} [:a :b]) ; Issue 68: every? returns
; nil instead of false
; http://code.google.com/p/clojure/issues/detail?id= 68
;! false (every? #{:a} [:b :b])
))
12.38. TEST/SEQUENCES.CLJ 1665
(deftest test-not-every?
; always false for nil or empty coll/seq
(are [x] (= (not-every? pos? x) false)
nil
() [] {} #{}
(lazy-seq [])
(into-array []) )
(are [x y] (= x y)
false (not-every? pos? [1])
false (not-every? pos? [1 2])
false (not-every? pos? [1 2 3 4 5])
true (not-every? pos? [-1])
true (not-every? pos? [-1 -2])
true (not-every? pos? [-1 -2 3])
true (not-every? pos? [-1 2])
true (not-every? pos? [1 -2])
true (not-every? pos? [1 2 -3])
true (not-every? pos? [1 2 -3 4]) )
(are [x y] (= x y)
false (not-every? #{:a} [:a :a])
true (not-every? #{:a} [:a :b])
true (not-every? #{:a} [:b :b]) ))
(deftest test-not-any?
; always true for nil or empty coll/seq
(are [x] (= (not-any? pos? x) true)
nil
() [] {} #{}
(lazy-seq [])
(into-array []) )
(are [x y] (= x y)
false (not-any? pos? [1])
false (not-any? pos? [1 2])
false (not-any? pos? [1 2 3 4 5])
true (not-any? pos? [-1])
true (not-any? pos? [-1 -2])
false (not-any? pos? [-1 -2 3])
false (not-any? pos? [-1 2])
false (not-any? pos? [1 -2])
false (not-any? pos? [1 2 -3])
false (not-any? pos? [1 2 -3 4]) )
(are [x y] (= x y)
1666 CHAPTER 12. TEST/CLOJURE
false (not-any? #{:a} [:a :a])
false (not-any? #{:a} [:a :b])
true (not-any? #{:a} [:b :b]) ))
(deftest test-some
;; always nil for nil or empty coll/seq
(are [x] (= (some pos? x) nil)
nil
() [] {} #{}
(lazy-seq [])
(into-array []))
(are [x y] (= x y)
nil (some nil nil)
true (some pos? [1])
true (some pos? [1 2])
nil (some pos? [-1])
nil (some pos? [-1 -2])
true (some pos? [-1 2])
true (some pos? [1 -2])
:a (some #{:a} [:a :a])
:a (some #{:a} [:b :a])
nil (some #{:a} [:b :b])
:a (some #{:a} ’(:a :b))
:a (some #{:a} #{:a :b})
))
(deftest test-flatten-present
(are [expected nested-val] (= (flatten nested-val) expect ed)
;simple literals
[] nil
[] 1
[] ’test
[] :keyword
[] 1/2
[] #"[\r\n]"
[] true
[] false
;vectors
[1 2 3 4 5] [[1 2] [3 4 [5]]]
[1 2 3 4 5] [1 2 3 4 5]
[#{1 2} 3 4 5] [#{1 2} 3 4 5]
;sets
[] #{}
[] #{#{1 2} 3 4 5}
12.38. TEST/SEQUENCES.CLJ 1667
[] #{1 2 3 4 5}
[] #{#{1 2} 3 4 5}
;lists
[] ’()
[1 2 3 4 5] ‘(1 2 3 4 5)
;maps
[] {:a 1 :b 2}
[:a 1 :b 2] (seq {:a 1 :b 2})
[] {[:a :b] 1 :c 2}
[:a :b 1 :c 2] (seq {[:a :b] 1 :c 2})
[:a 1 2 :b 3] (seq {:a [1 2] :b 3})
;Strings
[] "12345"
[\1 \2 \3 \4 \5] (seq "12345")
;fns
[] count
[count even? odd?] [count even? odd?]))
(deftest test-group-by
(is (= (group-by even? [1 2 3 4 5])
{false [1 3 5], true [2 4]})))
(deftest test-partition-by
(are [test-seq] (= (partition-by (comp even? count) test-s eq)
[["a"] ["bb" "cccc" "dd"] ["eee" "f"] ["" "hh"]])
["a" "bb" "cccc" "dd" "eee" "f" "" "hh"]
’("a" "bb" "cccc" "dd" "eee" "f" "" "hh"))
(is (=(partition-by #{\a \e \i \o \u} "abcdefghijklm")
[[\a] [\b \c \d] [\e] [\f \g \h] [\i] [\j \k \l \m]])))
(deftest test-frequencies
(are [expected test-seq] (= (frequencies test-seq) expect ed)
{\p 2, \s 4, \i 4, \m 1} "mississippi"
{1 4 2 2 3 1} [1 1 1 1 2 2 3]
{1 4 2 2 3 1} ’(1 1 1 1 2 2 3)))
(deftest test-reductions
(is (= (reductions + nil)
[0]))
(is (= (reductions + [1 2 3 4 5])
[1 3 6 10 15]))
(is (= (reductions + 10 [1 2 3 4 5])
[10 11 13 16 20 25])))
(deftest test-rand-nth-invariants
(let [elt (rand-nth [:a :b :c :d])]
(is (#{:a :b :c :d} elt))))
(deftest test-partition-all
(is (= (partition-all 4 [1 2 3 4 5 6 7 8 9])
1668 CHAPTER 12. TEST/CLOJURE
[[1 2 3 4] [5 6 7 8] [9]]))
(is (= (partition-all 4 2 [1 2 3 4 5 6 7 8 9])
[[1 2 3 4] [3 4 5 6] [5 6 7 8] [7 8 9] [9]])))
(deftest test-shuffle-invariants
(is (= (count (shuffle [1 2 3 4])) 4))
(let [shuffled-seq (shuffle [1 2 3 4])]
(is (every? #{1 2 3 4} shuffled-seq))))
———-
12.39 test/serialization.clj
— test/serialization.clj —
\getchunk{Clojure Copyright}
;; Author: Chas Emerick
;; cemerick@snowtide.com
(ns clojure.test-clojure.serialization
(:use clojure.test)
(:import (java.io ObjectOutputStream ObjectInputStream
ByteArrayOutputStream ByteArrayInputStream)))
(defn- serialize
"Serializes a single object, returning a byte array."
[v]
(with-open [bout (ByteArrayOutputStream.)
oos (ObjectOutputStream. bout)]
(.writeObject oos v)
(.flush oos)
(.toByteArray bout)))
(defn- deserialize
"Deserializes and returns a single object from the given byt e array."
[bytes]
(with-open [ois (-> bytes ByteArrayInputStream. ObjectIn putStream.)]
(.readObject ois)))
(defrecord SerializationRecord [a b c])
(defstruct SerializationStruct :a :b :c)
(defn- build-via-transient
[coll]
(persistent!
12.39. TEST/SERIALIZATION.CLJ 1669
(reduce conj!
(transient coll) (map vec (partition 2 (range 1000))))))
(defn- roundtrip
[v]
(let [rt (-> v serialize deserialize)
rt-seq (-> v seq serialize deserialize)]
(and (= v rt)
(= (seq v) (seq rt))
(= (seq v) rt-seq))))
(deftest sequable-serialization
(are [val] (roundtrip val)
; lists and related
(list)
(apply list (range 10))
(cons 0 nil)
(clojure.lang.Cons. 0 nil)
; vectors
[]
(into [] (range 10))
(into [] (range 25))
(into [] (range 100))
(into [] (range 500))
(into [] (range 1000))
; maps
{}
{:a 5 :b 0}
(apply array-map (range 100))
(apply hash-map (range 100))
; sets
#{}
#{’a ’b ’c}
(set (range 10))
(set (range 25))
(set (range 100))
(set (range 500))
(set (range 1000))
(sorted-set)
(sorted-set ’a ’b ’c)
(apply sorted-set (reverse (range 10)))
(apply sorted-set (reverse (range 25)))
(apply sorted-set (reverse (range 100)))
(apply sorted-set (reverse (range 500)))
(apply sorted-set (reverse (range 1000)))
; queues
1670 CHAPTER 12. TEST/CLOJURE
clojure.lang.PersistentQueue/EMPTY
(into clojure.lang.PersistentQueue/EMPTY (range 50))
; lazy seqs
(lazy-seq nil)
(lazy-seq (range 50))
; transient / persistent! round-trip
(build-via-transient [])
(build-via-transient {})
(build-via-transient #{})
; array-seqs
(seq (make-array Object 10))
(seq (make-array Boolean/TYPE 10))
(seq (make-array Byte/TYPE 10))
(seq (make-array Character/TYPE 10))
(seq (make-array Double/TYPE 10))
(seq (make-array Float/TYPE 10))
(seq (make-array Integer/TYPE 10))
(seq (make-array Long/TYPE 10))
; "records"
(SerializationRecord. 0 :foo (range 20))
(struct SerializationStruct 0 :foo (range 20))
; misc seqs
(seq "s11n")
(range 50)
(rseq (apply sorted-set (reverse (range 100))))))
(deftest misc-serialization
(are [v] (= v (-> v serialize deserialize))
25/3
:keyword
::namespaced-keyword
’symbol))
(deftest interned-serializations
(are [v] (identical? v (-> v serialize deserialize))
clojure.lang.RT/DEFAULT_COMPARATOR
; namespaces just get deserialized back into the same-named
; ns in the present runtime
; (they’re referred to by defrecord instances)
*ns*))
(deftest function-serialization
(let [capture 5]
(are [f] (= capture ((-> f serialize deserialize)))
12.40. TEST/SPECIAL.CLJ 1671
(constantly 5)
(fn [] 5)
#(do 5)
(constantly capture)
(fn [] capture)
#(do capture))))
(deftest check-unserializable-objects
(are [t] (thrown? java.io.NotSerializableException (ser ialize t))
;; transients
(transient [])
(transient {})
(transient #{})
;; reference types
(atom nil)
(ref nil)
(agent nil)
#’+
;; stateful seqs
(enumeration-seq (java.util.Collections/enumeration ( range 50)))
(iterator-seq (.iterator (range 50)))))
———-
12.40 test/special.clj
— test/special.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka
;;
;; Test special forms, macros and metadata
;;
(ns clojure.test-clojure.special
(:use clojure.test))
; http://clojure.org/special_forms
; let, letfn
; quote
; var
; fn
1672 CHAPTER 12. TEST/CLOJURE
———-
12.41 test/string.clj
— test/string.clj —
(ns clojure.test-clojure.string
(:require [clojure.string :as s])
(:use clojure.test))
(deftest t-split
(is (= ["a" "b"] (s/split "a-b" #"-")))
(is (= ["a" "b-c"] (s/split "a-b-c" #"-" 2)))
(is (vector? (s/split "abc" #"-"))))
(deftest t-reverse
(is (= "tab" (s/reverse "bat"))))
(deftest t-replace
(is (= "faabar" (s/replace "foobar" \o \a)))
(is (= "barbarbar" (s/replace "foobarfoo" "foo" "bar")))
(is (= "FOObarFOO" (s/replace "foobarfoo" #"foo" s/upper- case))))
(deftest t-replace-first
(is (= "barbarfoo" (s/replace-first "foobarfoo" "foo" "ba r")))
(is (= "barbarfoo" (s/replace-first "foobarfoo" #"foo" "b ar")))
(is (= "z.ology" (s/replace-first "zoology" \o \.)))
(is (= "FOObarfoo" (s/replace-first "foobarfoo" #"foo" s/ upper-case))))
(deftest t-join
(are [x coll] (= x (s/join coll))
"" nil
"" []
"1" [1]
"12" [1 2])
(are [x sep coll] (= x (s/join sep coll))
"1,2,3" \, [1 2 3]
"" \, []
"1" \, [1]
"1 and-a 2 and-a 3" " and-a " [1 2 3]))
(deftest t-trim-newline
(is (= "foo" (s/trim-newline "foo\n")))
(is (= "foo" (s/trim-newline "foo\r\n")))
(is (= "foo" (s/trim-newline "foo")))
12.41. TEST/STRING.CLJ 1673
(is (= "" (s/trim-newline ""))))
(deftest t-capitalize
(is (= "Foobar" (s/capitalize "foobar")))
(is (= "Foobar" (s/capitalize "FOOBAR"))))
(deftest t-triml
(is (= "foo " (s/triml " foo ")))
(is (= "" (s/triml " "))))
(deftest t-trimr
(is (= " foo" (s/trimr " foo ")))
(is (= "" (s/trimr " "))))
(deftest t-trim
(is (= "foo" (s/trim " foo \r\n"))))
(deftest t-upper-case
(is (= "FOOBAR" (s/upper-case "Foobar"))))
(deftest t-lower-case
(is (= "foobar" (s/lower-case "FooBar"))))
(deftest nil-handling
(are [f args] (thrown? NullPointerException (apply f args) )
s/reverse [nil]
s/replace [nil #"foo" "bar"]
s/replace-first [nil #"foo" "bar"]
s/capitalize [nil]
s/upper-case [nil]
s/lower-case [nil]
s/split [nil #"-"]
s/split [nil #"-" 1]
s/trim [nil]
s/triml [nil]
s/trimr [nil]
s/trim-newline [nil]))
(deftest char-sequence-handling
(are [result f args] (let [[^CharSequence s & more] args]
(= result (apply f (StringBuffer. s) more)))
"paz" s/reverse ["zap"]
"foo:bar" s/replace ["foo-bar" \- \:]
"ABC" s/replace ["abc" #"\w" s/upper-case]
"faa" s/replace ["foo" #"o" (StringBuffer. "a")]
"baz::quux" s/replace-first ["baz--quux" #"--" "::"]
"baz::quux" s/replace-first ["baz--quux" (StringBuffer . "--")
(StringBuffer. "::")]
"zim-zam" s/replace-first ["zim zam" #" " (StringBuffer. " -")]
"Pow" s/capitalize ["POW"]
1674 CHAPTER 12. TEST/CLOJURE
"BOOM" s/upper-case ["boom"]
"whimper" s/lower-case ["whimPER"]
["foo" "bar"] s/split ["foo-bar" #"-"]
"calvino" s/trim [" calvino "]
"calvino " s/triml [" calvino "]
" calvino" s/trimr [" calvino "]
"the end" s/trim-newline ["the end\r\n\r\r\n"]
true s/blank? [" "]
["a" "b"] s/split-lines ["a\nb"]
"fa la la" s/escape ["fo lo lo" {\o \a}]))
(deftest t-escape
(is (= "&lt;foo&amp;bar&gt;"
(s/escape "<foo&bar>" {\& "&amp;" \< "&lt;" \> "&gt;"})))
(is (= " \\\"foo\\\" "
(s/escape " \"foo\" " {\" "\\\""})))
(is (= "faabor"
(s/escape "foobar" {\a \o, \o \a}))))
(deftest t-blank
(is (s/blank? nil))
(is (s/blank? ""))
(is (s/blank? " "))
(is (s/blank? " \t \n \r "))
(is (not (s/blank? " foo "))))
(deftest t-split-lines
(let [result (s/split-lines "one\ntwo\r\nthree")]
(is (= ["one" "two" "three"] result))
(is (vector? result)))
(is (= (list "foo") (s/split-lines "foo"))))
———-
12.42 test/test.clj
— test/test.clj —
\getchunk{Clojure Copyright}
;;; test_clojure/test.clj: unit tests for test.clj
;; by Stuart Sierra
;; January 16, 2009
;; Thanks to Chas Emerick, Allen Rohner, and Stuart Halloway for
12.42. TEST/TEST.CLJ 1675
;; contributions and suggestions.
(ns clojure.test-clojure.test
(:use clojure.test))
(deftest can-test-symbol
(let [x true]
(is x "Should pass"))
(let [x false]
(is x "Should fail")))
(deftest can-test-boolean
(is true "Should pass")
(is false "Should fail"))
(deftest can-test-nil
(is nil "Should fail"))
(deftest can-test-=
(is (= 2 (+ 1 1)) "Should pass")
(is (= 3 (+ 2 2)) "Should fail"))
(deftest can-test-instance
(is (instance? Long (+ 2 2)) "Should pass")
(is (instance? Float (+ 1 1)) "Should fail"))
(deftest can-test-thrown
(is (thrown? ArithmeticException (/ 1 0)) "Should pass")
;; No exception is thrown:
(is (thrown? Exception (+ 1 1)) "Should fail")
;; Wrong class of exception is thrown:
(is (thrown? ArithmeticException
(throw (RuntimeException.))) "Should error"))
(deftest can-test-thrown-with-msg
(is (thrown-with-msg? ArithmeticException
#"Divide by zero" (/ 1 0)) "Should pass")
;; Wrong message string:
(is (thrown-with-msg? ArithmeticException
#"Something else" (/ 1 0)) "Should fail")
;; No exception is thrown:
(is (thrown? Exception (+ 1 1)) "Should fail")
;; Wrong class of exception is thrown:
(is (thrown-with-msg? IllegalArgumentException
#"Divide by zero" (/ 1 0)) "Should error"))
(deftest can-catch-unexpected-exceptions
(is (= 1 (throw (Exception.))) "Should error"))
1676 CHAPTER 12. TEST/CLOJURE
(deftest can-test-method-call
(is (.startsWith "abc" "a") "Should pass")
(is (.startsWith "abc" "d") "Should fail"))
(deftest can-test-anonymous-fn
(is (#(.startsWith % "a") "abc") "Should pass")
(is (#(.startsWith % "d") "abc") "Should fail"))
(deftest can-test-regexps
(is (re-matches #"^ab.*$" "abbabba") "Should pass")
(is (re-matches #"^cd.*$" "abbabba") "Should fail")
(is (re-find #"ab" "abbabba") "Should pass")
(is (re-find #"cd" "abbabba") "Should fail"))
(deftest #^{:has-meta true} can-add-metadata-to-tests
(is (:has-meta (meta #’can-add-metadata-to-tests)) "Sho uld pass"))
;; still have to declare the symbol before testing unbound sy mbols
(declare does-not-exist)
#_(deftest can-test-unbound-symbol
(is (= nil does-not-exist) "Should error"))
#_(deftest can-test-unbound-function
(is (does-not-exist) "Should error"))
;; Here, we create an alternate version of test/report, that
;; compares the event with the message, then calls the origin al
;; ’report’ with modified arguments.
(declare ^:dynamic original-report)
(defn custom-report [data]
(let [event (:type data)
msg (:message data)
expected (:expected data)
actual (:actual data)
passed (cond
(= event :fail) (= msg "Should fail")
(= event :pass) (= msg "Should pass")
(= event :error) (= msg "Should error")
:else true)]
(if passed
(original-report {:type :pass, :message msg,
:expected expected, :actual actual})
(original-report {:type :fail, :message (str msg " but got " event)
:expected expected, :actual actual}))))
;; test-ns-hook will be used by test/test-ns to run tests in t his
12.43. TEST/TEST˙FIXTURES.CLJ 1677
;; namespace.
(defn test-ns-hook []
(binding [original-report report
report custom-report]
(test-all-vars (find-ns ’clojure.test-clojure.test))) )
———-
12.43 test/test˙ﬁxtures.clj
— test/test˙ﬁxtures.clj —
\getchunk{Clojure Copyright}
;
;;; test_fixtures.clj: unit tests for fixtures in test.clj
;; by Stuart Sierra
;; March 28, 2009
(ns clojure.test-clojure.test-fixtures
(:use clojure.test))
(declare ^:dynamic *a* ^:dynamic *b* ^:dynamic *c* ^:dynam ic *d*)
(def ^:dynamic *n* 0)
(defn fixture-a [f]
(binding [*a* 3] (f)))
(defn fixture-b [f]
(binding [*b* 5] (f)))
(defn fixture-c [f]
(binding [*c* 7] (f)))
(defn fixture-d [f]
(binding [*d* 11] (f)))
(defn inc-n-fixture [f]
(binding [*n* (inc *n*)] (f)))
(use-fixtures :once fixture-a fixture-b)
(use-fixtures :each fixture-c fixture-d inc-n-fixture)
(use-fixtures :each fixture-c fixture-d inc-n-fixture)
(deftest can-use-once-fixtures
1678 CHAPTER 12. TEST/CLOJURE
(is (= 3 *a*))
(is (= 5 *b*)))
(deftest can-use-each-fixtures
(is (= 7 *c*))
(is (= 11 *d*)))
(deftest use-fixtures-replaces
(is (= *n* 1)))
———-
12.44 test/transients.clj
— test/transients.clj —
(ns clojure.test-clojure.transients
(:use clojure.test))
(deftest popping-off
(testing "across a node boundary"
(are [n]
(let [v (-> (range n) vec)]
(= (subvec v 0 (- n 2)) (-> v transient pop! pop! persistent!)) )
33 (+ 32 (inc (* 32 32))) (+ 32 (inc (* 32 32 32)))))
(testing "off the end"
(is (thrown-with-msg? IllegalStateException #"Can’t pop empty vector"
(-> [] transient pop!)))))
———-
12.45 test/vars.clj
— test/vars.clj —
\getchunk{Clojure Copyright}
; Author: Frantisek Sodomka, Stephen C. Gilardi
(ns clojure.test-clojure.vars
(:use clojure.test))
; http://clojure.org/vars
12.45. TEST/VARS.CLJ 1679
; def
; defn defn- defonce
; declare intern binding find-var var
(def ^:dynamic a)
(deftest test-binding
(are [x y] (= x y)
(eval ‘(binding [a 4] a)) 4 ; regression in Clojure SVN r1370
))
; var-get var-set alter-var-root [var? (predicates.clj)]
; with-in-str with-out-str
; with-open
(deftest test-with-local-vars
(let [factorial (fn [x]
(with-local-vars [acc 1, cnt x]
(while (> @cnt 0)
(var-set acc (* @acc @cnt))
(var-set cnt (dec @cnt)))
@acc))]
(is (= (factorial 5) 120))))
(deftest test-with-precision
(are [x y] (= x y)
(with-precision 4 (+ 3.5555555M 1)) 4.556M
(with-precision 6 (+ 3.5555555M 1)) 4.55556M
(with-precision 6 :rounding CEILING (+ 3.5555555M 1)) 4.55 556M
(with-precision 6 :rounding FLOOR (+ 3.5555555M 1)) 4.5555 5M
(with-precision 6 :rounding HALF_UP (+ 3.5555555M 1)) 4.55 556M
(with-precision 6 :rounding HALF_DOWN (+ 3.5555555M 1)) 4. 55556M
(with-precision 6 :rounding HALF_EVEN (+ 3.5555555M 1)) 4. 55556M
(with-precision 6 :rounding UP (+ 3.5555555M 1)) 4.55556M
(with-precision 6 :rounding DOWN (+ 3.5555555M 1)) 4.55555 M
(with-precision 6 :rounding UNNECESSARY (+ 3.5555M 1)) 4.5 555M))
(deftest test-settable-math-context
(is (=
(clojure.main/with-bindings
(set! *math-context* (java.math.MathContext. 8))
(+ 3.55555555555555M 1))
4.5555556M)))
; set-validator get-validator
; doc find-doc test
(def stub-me :original)
1680 CHAPTER 12. TEST/CLOJURE
(deftest test-with-redefs-fn
(let [p (promise)]
(with-redefs-fn {#’stub-me :temp}
(fn []
(.start (Thread. #(deliver p stub-me)))
@p))
(is (= :temp @p))
(is (= :original stub-me))))
(deftest test-with-redefs
(let [p (promise)]
(with-redefs [stub-me :temp]
(.start (Thread. #(deliver p stub-me)))
@p)
(is (= :temp @p))
(is (= :original stub-me))))
(deftest test-with-redefs-throw
(let [p (promise)]
(is (thrown? Exception
(with-redefs [stub-me :temp]
(deliver p stub-me)
(throw (Exception. "simulated failure in with-redefs"))) ))
(is (= :temp @p))
(is (= :original stub-me))))
———-
12.46 test/vectors.clj
— test/vectors.clj —
\getchunk{Clojure Copyright}
; Author: Stuart Halloway, Daniel Solano Gmez
(ns clojure.test-clojure.vectors
(:use clojure.test))
(deftest test-reversed-vec
(let [r (range 6)
v (into (vector-of :int) r)
reversed (.rseq v)]
(testing "returns the right impl"
(is (= clojure.lang.APersistentVector$RSeq (class rever sed))))
(testing "RSeq methods"
12.46. TEST/VECTORS.CLJ 1681
(is (= [5 4 3 2 1 0] reversed))
(is (= 5 (.index reversed)))
(is (= 5 (.first reversed)))
(is (= [4 3 2 1 0] (.next reversed)))
(is (= [3 2 1 0] (.. reversed next next)))
(is (= 6 (.count reversed))))
(testing "clojure calling through"
(is (= 5 (first reversed)))
(is (= 5 (nth reversed 0))))
(testing "empty reverses to nil"
(is (nil? (.. v empty rseq))))))
(deftest test-vecseq
(let [r (range 100)
vs (into (vector-of :int) r)
vs-1 (next vs)
vs-32 (.chunkedNext (seq vs))]
(testing "="
(are [a b] (= a b)
vs vs
vs-1 vs-1
vs-32 vs-32)
(are [a b] (not= a b)
vs vs-1
vs-1 vs
vs vs-32
vs-32 vs))
(testing "IPersistentCollection.empty"
(are [a]
(identical? clojure.lang.PersistentList/EMPTY (.empty (seq a)))
vs vs-1 vs-32))
(testing "IPersistentCollection.cons"
(are [result input] (= result (.cons input :foo))
[:foo 1] (seq (into (vector-of :int) [1]))))
(testing "IPersistentCollection.count"
(are [ct s] (= ct (.count (seq s)))
100 vs
99 vs-1
68 vs-32)
;; can’t manufacture this scenario: ASeq defers to Counted, but
;; LazySeq doesn’t, so Counted never gets checked on reified seq
;; below
#_(testing "hops to counted when available"
(is (= 200
(.count (concat
(seq vs)
(reify clojure.lang.ISeq
(seq [this] this)
clojure.lang.Counted
(count [_] 100))))))))
1682 CHAPTER 12. TEST/CLOJURE
(testing "IPersistentCollection.equiv"
(are [a b] (true? (.equiv a b))
vs vs
vs-1 vs-1
vs-32 vs-32
vs r)
(are [a b] (false? (.equiv a b))
vs vs-1
vs-1 vs
vs vs-32
vs-32 vs
vs nil))))
(deftest test-vec-compare
(let [nums (range 1 100)
; randomly replaces a single item with the given value
rand-replace
(fn[val]
(let [r (rand-int 99)]
(concat (take r nums) [val] (drop (inc r) nums))))
; all num sequences in map
num-seqs {:standard nums
:empty ’()
; different lengths
:longer (concat nums [100])
:shorter (drop-last nums)
; greater by value
:first-greater (concat [100] (next nums))
:last-greater (concat (drop-last nums) [100])
:rand-greater-1 (rand-replace 100)
:rand-greater-2 (rand-replace 100)
:rand-greater-3 (rand-replace 100)
; lesser by value
:first-lesser (concat [0] (next nums))
:last-lesser (concat (drop-last nums) [0])
:rand-lesser-1 (rand-replace 0)
:rand-lesser-2 (rand-replace 0)
:rand-lesser-3 (rand-replace 0)}
; a way to create compare values based on num-seqs
create-vals
(fn [base-val]
(zipmap (keys num-seqs)
(map #(into base-val %1) (vals num-seqs))))
; Vecs made of int primitives
int-vecs (create-vals (vector-of :int))
; Vecs made of long primitives
long-vecs (create-vals (vector-of :long))
; standard boxing vectors
regular-vecs (create-vals [])
; the standard int Vec for comparisons
12.46. TEST/VECTORS.CLJ 1683
int-vec (:standard int-vecs)]
(testing "compare"
(testing "identical"
(is (= 0 (compare int-vec int-vec))))
(testing "equivalent"
(are [x y] (= 0 (compare x y))
; standard
int-vec (:standard long-vecs)
(:standard long-vecs) int-vec
int-vec (:standard regular-vecs)
(:standard regular-vecs) int-vec
; empty
(:empty int-vecs) (:empty long-vecs)
(:empty long-vecs) (:empty int-vecs)))
(testing "lesser"
(are [x] (= -1 (compare int-vec x))
(:longer int-vecs)
(:longer long-vecs)
(:longer regular-vecs)
(:first-greater int-vecs)
(:first-greater long-vecs)
(:first-greater regular-vecs)
(:last-greater int-vecs)
(:last-greater long-vecs)
(:last-greater regular-vecs)
(:rand-greater-1 int-vecs)
(:rand-greater-1 long-vecs)
(:rand-greater-1 regular-vecs)
(:rand-greater-2 int-vecs)
(:rand-greater-2 long-vecs)
(:rand-greater-2 regular-vecs)
(:rand-greater-3 int-vecs)
(:rand-greater-3 long-vecs)
(:rand-greater-3 regular-vecs))
(are [x] (= -1 (compare x int-vec))
nil
(:empty int-vecs)
(:empty long-vecs)
(:empty regular-vecs)
(:shorter int-vecs)
(:shorter long-vecs)
(:shorter regular-vecs)
(:first-lesser int-vecs)
(:first-lesser long-vecs)
(:first-lesser regular-vecs)
(:last-lesser int-vecs)
(:last-lesser long-vecs)
(:last-lesser regular-vecs)
(:rand-lesser-1 int-vecs)
(:rand-lesser-1 long-vecs)
1684 CHAPTER 12. TEST/CLOJURE
(:rand-lesser-1 regular-vecs)
(:rand-lesser-2 int-vecs)
(:rand-lesser-2 long-vecs)
(:rand-lesser-2 regular-vecs)
(:rand-lesser-3 int-vecs)
(:rand-lesser-3 long-vecs)
(:rand-lesser-3 regular-vecs)))
(testing "greater"
(are [x] (= 1 (compare int-vec x))
nil
(:empty int-vecs)
(:empty long-vecs)
(:empty regular-vecs)
(:shorter int-vecs)
(:shorter long-vecs)
(:shorter regular-vecs)
(:first-lesser int-vecs)
(:first-lesser long-vecs)
(:first-lesser regular-vecs)
(:last-lesser int-vecs)
(:last-lesser long-vecs)
(:last-lesser regular-vecs)
(:rand-lesser-1 int-vecs)
(:rand-lesser-1 long-vecs)
(:rand-lesser-1 regular-vecs)
(:rand-lesser-2 int-vecs)
(:rand-lesser-2 long-vecs)
(:rand-lesser-2 regular-vecs)
(:rand-lesser-3 int-vecs)
(:rand-lesser-3 long-vecs)
(:rand-lesser-3 regular-vecs))
(are [x] (= 1 (compare x int-vec))
(:longer int-vecs)
(:longer long-vecs)
(:longer regular-vecs)
(:first-greater int-vecs)
(:first-greater long-vecs)
(:first-greater regular-vecs)
(:last-greater int-vecs)
(:last-greater long-vecs)
(:last-greater regular-vecs)
(:rand-greater-1 int-vecs)
(:rand-greater-1 long-vecs)
(:rand-greater-1 regular-vecs)
(:rand-greater-2 int-vecs)
(:rand-greater-2 long-vecs)
(:rand-greater-2 regular-vecs)
(:rand-greater-3 int-vecs)
(:rand-greater-3 long-vecs)
(:rand-greater-3 regular-vecs))))
12.46. TEST/VECTORS.CLJ 1685
(testing "Comparable.compareTo"
(testing "incompatible"
(is (thrown? NullPointerException (.compareTo int-vec ni l)))
(are [x] (thrown? ClassCastException (.compareTo int-vec x))
’()
{}
#{}
(sorted-set)
(sorted-map)
nums
1))
(testing "identical"
(is (= 0 (.compareTo int-vec int-vec))))
(testing "equivalent"
(are [x] (= 0 (.compareTo int-vec x))
(:standard long-vecs)
(:standard regular-vecs)))
(testing "lesser"
(are [x] (= -1 (.compareTo int-vec x))
(:longer int-vecs)
(:longer long-vecs)
(:longer regular-vecs)
(:first-greater int-vecs)
(:first-greater long-vecs)
(:first-greater regular-vecs)
(:last-greater int-vecs)
(:last-greater long-vecs)
(:last-greater regular-vecs)
(:rand-greater-1 int-vecs)
(:rand-greater-1 long-vecs)
(:rand-greater-1 regular-vecs)
(:rand-greater-2 int-vecs)
(:rand-greater-2 long-vecs)
(:rand-greater-2 regular-vecs)
(:rand-greater-3 int-vecs)
(:rand-greater-3 long-vecs)
(:rand-greater-3 regular-vecs)))
(testing "greater"
(are [x] (= 1 (.compareTo int-vec x))
(:empty int-vecs)
(:empty long-vecs)
(:empty regular-vecs)
(:shorter int-vecs)
(:shorter long-vecs)
(:shorter regular-vecs)
(:first-lesser int-vecs)
(:first-lesser long-vecs)
(:first-lesser regular-vecs)
(:last-lesser int-vecs)
(:last-lesser long-vecs)
1686 CHAPTER 12. TEST/CLOJURE
(:last-lesser regular-vecs)
(:rand-lesser-1 int-vecs)
(:rand-lesser-1 long-vecs)
(:rand-lesser-1 regular-vecs)
(:rand-lesser-2 int-vecs)
(:rand-lesser-2 long-vecs)
(:rand-lesser-2 regular-vecs)
(:rand-lesser-3 int-vecs)
(:rand-lesser-3 long-vecs)
(:rand-lesser-3 regular-vecs))))))
(deftest test-vec-associative
(let [empty-v (vector-of :long)
v (into empty-v (range 1 6))]
(testing "Associative.containsKey"
(are [x] (.containsKey v x)
0 1 2 3 4)
(are [x] (not (.containsKey v x))
-1 -100 nil [] "" #"" #{} 5 100)
(are [x] (not (.containsKey empty-v x))
0 1))
(testing "contains?"
(are [x] (contains? v x)
0 2 4)
(are [x] (not (contains? v x))
-1 -100 nil "" 5 100)
(are [x] (not (contains? empty-v x))
0 1))
(testing "Associative.entryAt"
(are [idx val] (= (clojure.lang.MapEntry. idx val)
(.entryAt v idx))
0 1
2 3
4 5)
(are [idx] (nil? (.entryAt v idx))
-5 -1 5 10 nil "")
(are [idx] (nil? (.entryAt empty-v idx))
0 1))))
———-
12.47 test/java˙5.clj
— test/java˙5.clj —
;; java 5 annotation tests
(in-ns ’clojure.test-clojure.annotations)
12.47. TEST/JAVA˙5.CLJ 1687
(import [java.lang.annotation Annotation Retention
RetentionPolicy Target ElementType])
(definterface Foo (foo []))
(deftype #^{Deprecated true
Retention RetentionPolicy/RUNTIME}
Bar [#^int a
#^{:tag int
Deprecated true
Retention RetentionPolicy/RUNTIME} b]
Foo (#^{Deprecated true
Retention RetentionPolicy/RUNTIME}
foo [this] 42))
(defn annotation->map
"Converts a Java annotation (which conceals data)
into a map (which makes is usable). Not lazy.
Works recursively. Returns non-annotations unscathed."
[#^java.lang.annotation.Annotation o]
(cond
(instance? Annotation o)
(let [type (.annotationType o)
itfs (-> (into #{type} (supers type))
(disj java.lang.annotation.Annotation))
data-methods (into #{} (mapcat #(.getDeclaredMethods %) i tfs))]
(into
{:annotationType (.annotationType o)}
(map
(fn [m] [(keyword (.getName m))
(annotation->map (.invoke m o nil))])
data-methods)))
(or (sequential? o) (.isArray (class o)))
(map annotation->map o)
:else o))
(def expected-annotations
#{{:annotationType java.lang.annotation.Retention,
:value RetentionPolicy/RUNTIME}
{:annotationType java.lang.Deprecated}})
(deftest test-annotations-on-type
(is (=
expected-annotations
(into #{} (map annotation->map (.getAnnotations Bar))))) )
(deftest test-annotations-on-field
(is (=
expected-annotations
(into #{}
1688 CHAPTER 12. TEST/CLOJURE
(map annotation->map (.getAnnotations (.getField Bar "b" )))))))
(deftest test-annotations-on-method
(is (=
expected-annotations
(into #{}
(map annotation->map
(.getAnnotations (.getMethod Bar "foo" nil)))))))
———-
12.48 test/java˙6˙and˙later.clj
— test/java˙6˙and˙later.clj —
;; java 6 annotation tests
(in-ns ’clojure.test-clojure.annotations)
(import [java.lang.annotation Annotation Retention
RetentionPolicy Target ElementType]
[javax.xml.ws WebServiceRef WebServiceRefs])
(definterface Foo (foo []))
(deftype #^{Deprecated true
Retention RetentionPolicy/RUNTIME
javax.annotation.processing.SupportedOptions
["foo" "bar" "baz"]
javax.xml.ws.soap.Addressing {:enabled false :required true}
WebServiceRefs
[(WebServiceRef {:name "fred" :type String})
(WebServiceRef {:name "ethel" :mappedName "lucy"})]}
Bar [#^int a
#^{:tag int
Deprecated true
Retention RetentionPolicy/RUNTIME
javax.annotation.processing.SupportedOptions
["foo" "bar" "baz"]
javax.xml.ws.soap.Addressing {:enabled false :required true}
WebServiceRefs
[(WebServiceRef {:name "fred" :type String})
(WebServiceRef {:name "ethel" :mappedName "lucy"})]}
b]
Foo (#^{Deprecated true
Retention RetentionPolicy/RUNTIME
javax.annotation.processing.SupportedOptions
["foo" "bar" "baz"]
12.48. TEST/JAVA˙6˙AND˙LATER.CLJ 1689
javax.xml.ws.soap.Addressing {:enabled false :required true}
WebServiceRefs
[(WebServiceRef {:name "fred" :type String})
(WebServiceRef {:name "ethel" :mappedName "lucy"})]}
foo [this] 42))
(defn annotation->map
"Converts a Java annotation (which conceals data)
into a map (which makes is usable). Not lazy.
Works recursively. Returns non-annotations unscathed."
[#^java.lang.annotation.Annotation o]
(cond
(instance? Annotation o)
(let [type (.annotationType o)
itfs (-> (into #{type} (supers type))
(disj java.lang.annotation.Annotation))
data-methods (into #{} (mapcat #(.getDeclaredMethods %) i tfs))]
(into
{:annotationType (.annotationType o)}
(map
(fn [m] [(keyword (.getName m))
(annotation->map (.invoke m o nil))])
data-methods)))
(or (sequential? o) (.isArray (class o)))
(map annotation->map o)
:else o))
(def expected-annotations
#{{:annotationType java.lang.annotation.Retention,
:value RetentionPolicy/RUNTIME}
{:annotationType javax.xml.ws.WebServiceRefs,
:value [{:annotationType javax.xml.ws.WebServiceRef,
:name "fred", :mappedName "", :type java.lang.String,
:wsdlLocation "", :value java.lang.Object}
{:annotationType javax.xml.ws.WebServiceRef,
:name "ethel", :mappedName "lucy",
:type java.lang.Object,
:wsdlLocation "", :value java.lang.Object}]}
{:annotationType javax.xml.ws.soap.Addressing,
:enabled false, :required true}
{:annotationType javax.annotation.processing.Support edOptions,
:value ["foo" "bar" "baz"]}
{:annotationType java.lang.Deprecated}})
(deftest test-annotations-on-type
(is (=
expected-annotations
(into #{} (map annotation->map (.getAnnotations Bar))))) )
(deftest test-annotations-on-field
1690 CHAPTER 12. TEST/CLOJURE
(is (=
expected-annotations
(into #{}
(map annotation->map (.getAnnotations (.getField Bar "b" )))))))
(deftest test-annotations-on-method
(is (=
expected-annotations
(into #{}
(map annotation->map
(.getAnnotations (.getMethod Bar "foo" nil)))))))
———-
12.49 test/examples.clj
— test/examples.clj —
\getchunk{Clojure Copyright}
(ns ^{:doc "Test classes that are AOT-compile for the tests i n
clojure.test-clojure.genclass."
:author "Stuart Halloway, Daniel Solano Gmez"}
clojure.test-clojure.genclass.examples)
(definterface ExampleInterface
(foo [a])
(foo [a b])
(foo [a #^int b]))
(gen-class :name clojure.test_clojure.genclass.exampl es.ExampleClass
:implements
[clojure.test_clojure.genclass.examples.ExampleInte rface])
;; -foo-Object unimplemented to test missing fn case
(defn -foo-Object-Object
[_ o1 o2]
"foo with o, o")
(defn -foo-Object-int
[_ o i]
"foo with o, i")
(gen-class :name
^{Deprecated {}
12.50. TEST/IO.CLJ 1691
SuppressWarnings ["Warning1"] ; discarded
java.lang.annotation.Target []}
clojure.test_clojure.genclass.examples.ExampleAnnot ationClass
:prefix "annot-"
:methods [[^{Deprecated {}
Override {}} ;discarded
foo [^{java.lang.annotation.Retention
java.lang.annotation.RetentionPolicy/SOURCE
java.lang.annotation.Target
[java.lang.annotation.ElementType/TYPE
java.lang.annotation.ElementType/PARAMETER]}
String] void]])
———-
12.50 test/io.clj
— test/io.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.java.io
(:use clojure.test clojure.java.io
[clojure.test-helper :only [platform-newlines]])
(:import (java.io File BufferedInputStream
FileInputStream InputStreamReader InputStream
FileOutputStream OutputStreamWriter OutputStream
ByteArrayInputStream ByteArrayOutputStream)
(java.net URL URI Socket ServerSocket)))
(defn temp-file
[prefix suffix]
(doto (File/createTempFile prefix suffix)
(.deleteOnExit)))
(deftest test-spit-and-slurp
(let [f (temp-file "clojure.java.io" "test")]
(spit f "foobar")
(is (= "foobar" (slurp f)))
(spit f "foobar" :encoding "UTF-16")
(is (= "foobar" (slurp f :encoding "UTF-16")))
(testing "deprecated arity"
(is (=
(platform-newlines
"WARNING: (slurp f enc) is deprecated, use (slurp f :encodin g enc).\n")
(with-out-str
(is (= "foobar" (slurp f "UTF-16")))))))))
1692 CHAPTER 12. TEST/CLOJURE
(deftest test-streams-defaults
(let [f (temp-file "clojure.java.io" "test-reader-write r")
content "testing"]
(try
(is (thrown? Exception (reader (Object.))))
(is (thrown? Exception (writer (Object.))))
(are [write-to read-from]
(= content (do
(spit write-to content :encoding "UTF-8")
(slurp read-from :encoding "UTF-8")))
f f
(.getAbsolutePath f) (.getAbsolutePath f)
(.toURL f) (.toURL f)
(.toURI f) (.toURI f)
(FileOutputStream. f) (FileInputStream. f)
(OutputStreamWriter. (FileOutputStream. f) "UTF-8")
(reader f :encoding "UTF-8")
f (FileInputStream. f)
(writer f :encoding "UTF-8")
(InputStreamReader. (FileInputStream. f) "UTF-8"))
(is (= content (slurp (.getBytes content "UTF-8"))))
(is (= content (slurp (.toCharArray content))))
(finally
(.delete f)))))
(defn bytes-should-equal [byte-array-1 byte-array-2 msg ]
(is (= @#’clojure.java.io/byte-array-type (class byte-a rray-1)
(class byte-array-2)) msg)
(is (= (into [] byte-array-1) (into [] byte-array-2)) msg))
(defn data-fixture
"in memory fixture data for tests"
[encoding]
(let [bs (.getBytes "hello" encoding)
cs (.toCharArray "hello")
i (ByteArrayInputStream. bs)
r (InputStreamReader. i)
o (ByteArrayOutputStream.)
w (OutputStreamWriter. o)]
{:bs bs
:i i
:r r
:o o
:s "hello"
:cs cs
:w w}))
12.50. TEST/IO.CLJ 1693
(deftest test-copy
(dorun
(for [{:keys [in out flush] :as test}
[{:in :i :out :o}
{:in :i :out :w}
{:in :r :out :o}
{:in :r :out :w}
{:in :cs :out :o}
{:in :cs :out :w}
{:in :bs :out :o}
{:in :bs :out :w}]
opts
[{} {:buffer-size 256}]]
(let [{:keys [s o] :as d} (data-fixture "UTF-8")]
(apply copy (in d) (out d) (flatten (vec opts)))
#_(when (= out :w) (.flush (:w d)))
(.flush (out d))
(bytes-should-equal (.getBytes s "UTF-8")
(.toByteArray o)
(str "combination " test opts))))))
(deftest test-copy-encodings
(testing "from inputstream UTF-16 to writer UTF-8"
(let [{:keys [i s o w bs]} (data-fixture "UTF-16")]
(copy i w :encoding "UTF-16")
(.flush w)
(bytes-should-equal (.getBytes s "UTF-8") (.toByteArray o) "")))
(testing "from reader UTF-8 to output-stream UTF-16"
(let [{:keys [r o s]} (data-fixture "UTF-8")]
(copy r o :encoding "UTF-16")
(bytes-should-equal (.getBytes s "UTF-16") (.toByteArra y o) ""))))
(deftest test-as-file
(are [result input] (= result (as-file input))
(File. "foo") "foo"
(File. "bar") (File. "bar")
(File. "baz") (URL. "file:baz")
(File. "quux") (URI. "file:quux")
nil nil))
(deftest test-file
(are [result args] (= (File. result) (apply file args))
"foo" ["foo"]
"foo/bar" ["foo" "bar"]
"foo/bar/baz" ["foo" "bar" "baz"]))
(deftest test-as-url
(are [file-part input]
(= (URL. (str "file:" file-part)) (as-url input))
"foo" "file:foo"
1694 CHAPTER 12. TEST/CLOJURE
"baz" (URL. "file:baz")
"quux" (URI. "file:quux"))
(is (nil? (as-url nil))))
(deftest test-delete-file
(let [file (temp-file "test" "deletion")
not-file (File. (str (java.util.UUID/randomUUID)))]
(delete-file (.getAbsolutePath file))
(is (not (.exists file)))
(is (thrown? java.io.IOException (delete-file not-file) ))
(is (= :silently (delete-file not-file :silently)))))
(deftest test-as-relative-path
(testing "strings"
(is (= "foo" (as-relative-path "foo"))))
(testing "absolute path strings are forbidden"
(is (thrown? IllegalArgumentException
(as-relative-path (.getAbsolutePath (File. "baz"))))))
(testing "relative File paths"
(is (= "bar" (as-relative-path (File. "bar")))))
(testing "absolute File paths are forbidden"
(is (thrown? IllegalArgumentException
(as-relative-path
(File. (.getAbsolutePath (File. "quux"))))))))
(defn stream-should-have [stream expected-bytes msg]
(let [actual-bytes (byte-array (alength expected-bytes) )]
(.read stream actual-bytes)
(is (= -1 (.read stream)) (str msg " : should be end of stream") )
(is (= (seq expected-bytes) (seq actual-bytes))
(str msg " : byte arrays should match"))))
(deftest test-input-stream
(let [file (temp-file "test-input-stream" "txt")
bytes (.getBytes "foobar")]
(spit file "foobar")
(doseq [[expr msg]
[[file File]
[(FileInputStream. file) FileInputStream]
[(BufferedInputStream. (FileInputStream. file))
BufferedInputStream]
[(.. file toURI) URI]
[(.. file toURI toURL) URL]
[(.. file toURI toURL toString) "URL as String"]
[(.. file toString) "File as String"]]]
(with-open [s (input-stream expr)]
(stream-should-have s bytes msg)))))
(deftest test-streams-buffering
(let [data (.getBytes "")]
12.50. TEST/IO.CLJ 1695
(is (instance? java.io.BufferedReader
(reader data)))
(is (instance? java.io.BufferedWriter
(writer (java.io.ByteArrayOutputStream.))))
(is (instance? java.io.BufferedInputStream
(input-stream data)))
(is (instance? java.io.BufferedOutputStream
(output-stream (java.io.ByteArrayOutputStream.))))))
(deftest test-resource
(is (nil? (resource "non/existent/resource")))
(is (instance? URL (resource "clojure/core.clj")))
(let [file (temp-file "test-resource" "txt")
url (as-url (.getParentFile file))
loader (java.net.URLClassLoader. (into-array [url]))]
(is (nil? (resource "non/existent/resource" loader)))
(is (instance? URL (resource (.getName file) loader)))))
(deftest test-make-parents
(let [tmp (System/getProperty "java.io.tmpdir")]
(delete-file
(file tmp "test-make-parents" "child" "grandchild") :sil ently)
(delete-file
(file tmp "test-make-parents" "child") :silently)
(delete-file
(file tmp "test-make-parents") :silently)
(make-parents tmp "test-make-parents" "child" "grandchi ld")
(is (.isDirectory (file tmp "test-make-parents" "child") ))
(is (not
(.isDirectory
(file tmp "test-make-parents" "child" "grandchild"))))
(delete-file (file tmp "test-make-parents" "child"))
(delete-file (file tmp "test-make-parents"))))
(deftest test-socket-iofactory
(let [port 65321
server-socket (ServerSocket. port)
client-socket (Socket. "localhost" port)]
(try
(is (instance? InputStream (input-stream client-socket) ))
(is (instance? OutputStream (output-stream client-socke t)))
(finally (.close server-socket)
(.close client-socket)))))
———-
1696 CHAPTER 12. TEST/CLOJURE
12.51 test/javadoc.clj
— test/javadoc.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.java.javadoc
(:use clojure.test
[clojure.java.javadoc :as j])
(:import (java.io File)))
(deftest javadoc-url-test
(testing "for a core api"
(binding [*feeling-lucky* false]
(are [x y] (= x (#’j/javadoc-url y))
nil "foo.Bar"
(str *core-java-api* "java/lang/String.html")
"java.lang.String")))
(testing "for a remote javadoc"
(binding [*remote-javadocs*
(ref (sorted-map "java." "http://example.com/"))]
(is (= "http://example.com/java/lang/Number.html"
(#’j/javadoc-url "java.lang.Number"))))))
———-
12.52 test/shell.clj
— test/shell.clj —
\getchunk{Clojure Copyright}
(ns clojure.test-clojure.java.shell
(:use clojure.test
[clojure.java.shell :as sh])
(:import (java.io File)))
(def platform-enc (.name (java.nio.charset.Charset/def aultCharset)))
(def default-enc "UTF-8")
(deftest test-parse-args
(are [x y] (= x y)
[[] {:in-enc default-enc
:out-enc default-enc
:dir nil
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1697
:env nil}] (#’sh/parse-args [])
[["ls"] {:in-enc default-enc
:out-enc default-enc
:dir nil
:env nil}] (#’sh/parse-args ["ls"])
[["ls" "-l"] {:in-enc default-enc
:out-enc default-enc
:dir nil
:env nil}] (#’sh/parse-args ["ls" "-l"])
[["ls"] {:in-enc default-enc
:out-enc "ISO-8859-1"
:dir nil
:env nil}]
(#’sh/parse-args ["ls" :out-enc "ISO-8859-1"])
[[] {:in-enc platform-enc
:out-enc platform-enc
:dir nil
:env nil}]
(#’sh/parse-args [:in-enc platform-enc :out-enc platfor m-enc])))
(deftest test-with-sh-dir
(are [x y] (= x y)
nil *sh-dir*
"foo" (with-sh-dir "foo" *sh-dir*)))
(deftest test-with-sh-env
(are [x y] (= x y)
nil *sh-env*
{:KEY "VAL"} (with-sh-env {:KEY "VAL"} *sh-env*)))
(deftest test-as-env-strings
(are [x y] (= x y)
nil (#’sh/as-env-strings nil)
["FOO=BAR"]
(seq (#’sh/as-env-strings {"FOO" "BAR"}))
["FOO_SYMBOL=BAR"]
(seq (#’sh/as-env-strings {’FOO_SYMBOL "BAR"}))
["FOO_KEYWORD=BAR"]
(seq (#’sh/as-env-strings {:FOO_KEYWORD "BAR"}))))
———-
12.53 test/test˙cl˙format.clj
— test/test˙cl˙format.clj —
1698 CHAPTER 12. TEST/CLOJURE
\getchunk{Clojure Copyright}
;;; test_cl_format.clj -- part of the pretty printer for Clo jure
;; Author: Tom Faulhaber
;; April 3, 2009
;; This test set tests the basic cl-format functionality
(in-ns ’clojure.test-clojure.pprint)
(def format cl-format)
;; TODO tests for ~A, ~D, etc.
;; TODO add tests for ~F, etc.: 0.0, 9.9999 with rounding,
;; 9.9999E99 with rounding
(simple-tests d-tests
(cl-format nil "~D" 0) "0"
(cl-format nil "~D" 2e6) "2000000"
(cl-format nil "~D" 2000000) "2000000"
(cl-format nil "~:D" 2000000) "2,000,000"
(cl-format nil "~D" 1/2) "1/2"
(cl-format nil "~D" ’fred) "fred"
)
(simple-tests base-tests
(cl-format nil "~{~2r~^ ~}~%" (range 10))
"0 1 10 11 100 101 110 111 1000 1001\n"
(with-out-str
(dotimes [i 35]
(binding [*print-base* (+ i 2)] ;print the decimal number 40
(write 40) ;in each base from 2 to 36
(if (zero? (mod i 10)) (prn) (cl-format true " ")))))
"101000
1111 220 130 104 55 50 44 40 37 34
31 2c 2a 28 26 24 22 20 1j 1i
1h 1g 1f 1e 1d 1c 1b 1a 19 18
17 16 15 14 "
(with-out-str
(doseq [pb [2 3 8 10 16]]
(binding [*print-radix* true ;print the integer 10 and
*print-base* pb] ;the ratio 1/10 in bases 2,
(cl-format true "~&~S ~S~%" 10 1/10)))) ;3, 8, 10, 16
"#b1010 #b1/1010\n#3r101 #3r1/101\n#o12
#o1/12\n10. #10r1/10\n#xa #x1/a\n")
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1699
(simple-tests cardinal-tests
(cl-format nil "~R" 0) "zero"
(cl-format nil "~R" 4) "four"
(cl-format nil "~R" 15) "fifteen"
(cl-format nil "~R" -15) "minus fifteen"
(cl-format nil "~R" 25) "twenty-five"
(cl-format nil "~R" 20) "twenty"
(cl-format nil "~R" 200) "two hundred"
(cl-format nil "~R" 203) "two hundred three"
(cl-format nil "~R" 44879032)
"forty-four million, eight hundred seventy-nine thousand , thirty-two"
(cl-format nil "~R" -44879032)
(str "minus forty-four million, eight hundred seventy-nin e "
"thousand, thirty-two")
(cl-format nil "~R = ~:*~:D" 44000032)
"forty-four million, thirty-two = 44,000,032"
(cl-format nil "~R = ~:*~:D"
448790329480948209384389429384029384029842098420989 842094)
(str
"four hundred forty-eight septendecillion, seven hundred ninety "
"sexdecillion, three hundred twenty-nine quindecillion, four hundred "
"eighty quattuordecillion, nine hundred forty-eight tred ecillion, "
"two hundred nine duodecillion, three hundred eighty-four undecillion, "
"three hundred eighty-nine decillion, four hundred twenty -nine "
"nonillion, three hundred eighty-four octillion, twenty- nine "
"septillion, three hundred eighty-four sextillion, twent y-nine "
"quintillion, eight hundred forty-two quadrillion, ninet y-eight "
"trillion, four hundred twenty billion, nine hundred eight y-nine "
"million, eight hundred forty-two thousand, ninety-four = 448,790,"
"329,480,948,209,384,389,429,384,029,384,029,842,09 8,420,989,842,094")
(cl-format nil "~R = ~:*~:D"
(+ (* 44879032948094820938438942938402938402984209842 0
1000000000000000000000000000000000000000000000)
989842094490320942058747587584758375847593475))
(str "448,790,329,480,948,209,384,389,429,384,029,38 4,029,842,098,"
"420,989,842,094,490,320,942,058,747,587,584,758,37 5,847,593,"
"475 = 448,790,329,480,948,209,384,389,429,384,029,38 4,029,842,"
"098,420,989,842,094,490,320,942,058,747,587,584,75 8,375,847,"
"593,475")
(cl-format nil "~R = ~:*~:D" 2e6)
"two million = 2,000,000"
(cl-format nil "~R = ~:*~:D" 200000200000)
"two hundred billion, two hundred thousand = 200,000,200,0 00")
1700 CHAPTER 12. TEST/CLOJURE
(simple-tests ordinal-tests
(cl-format nil "~:R" 0) "zeroth"
(cl-format nil "~:R" 4) "fourth"
(cl-format nil "~:R" 15) "fifteenth"
(cl-format nil "~:R" -15) "minus fifteenth"
(cl-format nil "~:R" 25) "twenty-fifth"
(cl-format nil "~:R" 20) "twentieth"
(cl-format nil "~:R" 200) "two hundredth"
(cl-format nil "~:R" 203) "two hundred third"
(cl-format nil "~:R" 44879032)
(str "forty-four million, eight hundred seventy-nine thou sand,"
" thirty-second"
(cl-format nil "~:R" -44879032)
(str "minus forty-four million, eight hundred seventy-nin e "
"thousand, thirty-second"
(cl-format nil "~:R = ~:*~:D" 44000032)
"forty-four million, thirty-second = 44,000,032"
(cl-format nil "~:R = ~:*~:D"
448790329480948209384389429384029384029842098420989 842094)
(str "four hundred forty-eight septendecillion, seven hun dred ninety "
"sexdecillion, three hundred twenty-nine quindecillion, four hundred "
"eighty quattuordecillion, nine hundred forty-eight tred ecillion, two "
"hundred nine duodecillion, three hundred eighty-four und ecillion, "
"three hundred eighty-nine decillion, four hundred twenty -nine "
"nonillion, three hundred eighty-four octillion, twenty- nine "
"septillion, three hundred eighty-four sextillion, twent y-nine "
"quintillion, eight hundred forty-two quadrillion, ninet y-eight "
"trillion, four hundred twenty billion, nine hundred eight y-nine "
"million, eight hundred forty-two thousand, ninety-fourt h = "
"448,790,329,480,948,209,384,389,429,384,029,384,02 9,842,098,420,"
"989,842,094")
(cl-format nil "~:R = ~:*~:D"
(+ (* 44879032948094820938438942938402938402984209842 0
1000000000000000000000000000000000000000000000)
989842094490320942058747587584758375847593475))
(str "448,790,329,480,948,209,384,389,429,384,029,38 4,029,842,098,"
"420,989,842,094,490,320,942,058,747,587,584,758,37 5,847,593,"
"475th = 448,790,329,480,948,209,384,389,429,384,029, 384,029,"
"842,098,420,989,842,094,490,320,942,058,747,587,58 4,758,375,"
"847,593,475"
(cl-format nil "~:R = ~:*~:D"
(+ (* 44879032948094820938438942938402938402984209842 0
1000000000000000000000000000000000000000000000)
989842094490320942058747587584758375847593471))
"448,790,329,480,948,209,384,389,429,384,029,384,02 9,842,098,420,"
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1701
"989,842,094,490,320,942,058,747,587,584,758,375,84 7,593,471st = "
"448,790,329,480,948,209,384,389,429,384,029,384,02 9,842,098,420,"
"989,842,094,490,320,942,058,747,587,584,758,375,84 7,593,471"
(cl-format nil "~:R = ~:*~:D" 2e6)
"two millionth = 2,000,000")
(simple-tests ordinal1-tests
(cl-format nil "~:R" 1) "first"
(cl-format nil "~:R" 11) "eleventh"
(cl-format nil "~:R" 21) "twenty-first"
(cl-format nil "~:R" 20) "twentieth"
(cl-format nil "~:R" 220) "two hundred twentieth"
(cl-format nil "~:R" 200) "two hundredth"
(cl-format nil "~:R" 999) "nine hundred ninety-ninth"
)
(simple-tests roman-tests
(cl-format nil "~@R" 3) "III"
(cl-format nil "~@R" 4) "IV"
(cl-format nil "~@R" 9) "IX"
(cl-format nil "~@R" 29) "XXIX"
(cl-format nil "~@R" 429) "CDXXIX"
(cl-format nil "~@:R" 429) "CCCCXXVIIII"
(cl-format nil "~@:R" 3429) "MMMCCCCXXVIIII"
(cl-format nil "~@R" 3429) "MMMCDXXIX"
(cl-format nil "~@R" 3479) "MMMCDLXXIX"
(cl-format nil "~@R" 3409) "MMMCDIX"
(cl-format nil "~@R" 300) "CCC"
(cl-format nil "~@R ~D" 300 20) "CCC 20"
(cl-format nil "~@R" 5000) "5,000"
(cl-format nil "~@R ~D" 5000 20) "5,000 20"
(cl-format nil "~@R" "the quick") "the quick")
(simple-tests c-tests
(cl-format nil "~{~c~^, ~}~%" "hello") "h, e, l, l, o\n"
(cl-format nil "~{~:c~^, ~}~%" "hello") "h, e, l, l, o\n"
(cl-format nil "~@C~%" \m) "\\m\n"
(cl-format nil "~@C~%" (char 222)) "\\\n"
(cl-format nil "~@C~%" (char 8)) "\\backspace\n")
;tpd the control-C won’t pass latex.
;tpd I need some latex magic to fix it.
; (cl-format nil "~@C~%" (char 3)) "\\ctrl-\n")
(simple-tests e-tests
(cl-format nil "*~E*" 0.0) "*0.0E+0*"
(cl-format nil "*~6E*" 0.0) "*0.0E+0*"
(cl-format nil "*~6,0E*" 0.0) "* 0.E+0*"
(cl-format nil "*~7,2E*" 0.0) "*0.00E+0*"
(cl-format nil "*~5E*" 0.0) "*0.E+0*"
(cl-format nil "*~10,2,2,,’?E*" 2.8E120) "*??????????*"
1702 CHAPTER 12. TEST/CLOJURE
(cl-format nil "*~10,2E*" 9.99999) "* 1.00E+1*"
(cl-format nil "*~10,2E*" 9.99999E99) "* 1.00E+100*"
(cl-format nil "*~10,2,2E*" 9.99999E99) "* 1.00E+100*"
(cl-format nil "*~10,2,2,,’?E*" 9.99999E99) "*????????? ?*"
)
(simple-tests $-tests
(cl-format nil "~$" 22.3) "22.30"
(cl-format nil "~$" 22.375) "22.38"
(cl-format nil "~3,5$" 22.375) "00022.375"
(cl-format nil "~3,5,8$" 22.375) "00022.375"
(cl-format nil "~3,5,10$" 22.375) " 00022.375"
(cl-format nil "~3,5,14@$" 22.375) " +00022.375"
(cl-format nil "~3,5,14@$" 22.375) " +00022.375"
(cl-format nil "~3,5,14@:$" 22.375) "+ 00022.375"
(cl-format nil "~3,,14@:$" 0.375) "+ 0.375"
(cl-format nil "~1,1$" -12.0) "-12.0"
(cl-format nil "~1,1$" 12.0) "12.0"
(cl-format nil "~1,1$" 12.0) "12.0"
(cl-format nil "~1,1@$" 12.0) "+12.0"
(cl-format nil "~1,1,8,’ @:$" 12.0) "+ 12.0"
(cl-format nil "~1,1,8,’ @$" 12.0) " +12.0"
(cl-format nil "~1,1,8,’ :$" 12.0) " 12.0"
(cl-format nil "~1,1,8,’ $" 12.0) " 12.0"
(cl-format nil "~1,1,8,’ @:$" -12.0) "- 12.0"
(cl-format nil "~1,1,8,’ @$" -12.0) " -12.0"
(cl-format nil "~1,1,8,’ :$" -12.0) "- 12.0"
(cl-format nil "~1,1,8,’ $" -12.0) " -12.0"
(cl-format nil "~1,1$" 0.001) "0.0"
(cl-format nil "~2,1$" 0.001) "0.00"
(cl-format nil "~1,1,6$" 0.001) " 0.0"
(cl-format nil "~1,1,6$" 0.0015) " 0.0"
(cl-format nil "~2,1,6$" 0.005) " 0.01"
(cl-format nil "~2,1,6$" 0.01) " 0.01"
(cl-format nil "~$" 0.099) "0.10"
(cl-format nil "~1$" 0.099) "0.1"
(cl-format nil "~1$" 0.1) "0.1"
(cl-format nil "~1$" 0.99) "1.0"
(cl-format nil "~1$" -0.99) "-1.0")
(simple-tests f-tests
(cl-format nil "~,1f" -12.0) "-12.0"
(cl-format nil "~,0f" 9.4) "9."
(cl-format nil "~,0f" 9.5) "10."
(cl-format nil "~,0f" -0.99) "-1."
(cl-format nil "~,1f" -0.99) "-1.0"
(cl-format nil "~,2f" -0.99) "-0.99"
(cl-format nil "~,3f" -0.99) "-0.990"
(cl-format nil "~,0f" 0.99) "1."
(cl-format nil "~,1f" 0.99) "1.0"
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1703
(cl-format nil "~,2f" 0.99) "0.99"
(cl-format nil "~,3f" 0.99) "0.990"
(cl-format nil "~f" -1) "-1.0"
(cl-format nil "~2f" -1) "-1."
(cl-format nil "~3f" -1) "-1."
(cl-format nil "~4f" -1) "-1.0"
(cl-format nil "~8f" -1) " -1.0"
(cl-format nil "~1,1f" 0.1) ".1")
(simple-tests ampersand-tests
(cl-format nil
"The quick brown ~a jumped over ~d lazy dogs" ’elephant 5)
"The quick brown elephant jumped over 5 lazy dogs"
(cl-format nil
"The quick brown ~&~a jumped over ~d lazy dogs" ’elephant 5)
"The quick brown \nelephant jumped over 5 lazy dogs"
(cl-format nil (platform-newlines
"The quick brown ~&~a jumped\n~& over ~d lazy dogs") ’elepha nt 5)
"The quick brown \nelephant jumped\n over 5 lazy dogs"
(cl-format nil (platform-newlines
"~&The quick brown ~&~a jumped\n~& over ~d lazy dogs") ’elep hant 5)
"The quick brown \nelephant jumped\n over 5 lazy dogs"
(cl-format nil (platform-newlines
"~3&The quick brown ~&~a jumped\n~& over ~d lazy dogs") ’ele phant 5)
"\n\nThe quick brown \nelephant jumped\n over 5 lazy dogs"
(cl-format nil
"~@{~&The quick brown ~a jumped over ~d lazy dogs~}"
’elephant 5 ’fox 10)
(str "The quick brown elephant jumped over 5 lazy dogs\n"
"The quick brown fox jumped over 10 lazy dogs")
(cl-format nil "I ~[don’t ~:;d~&o ~]have one~%" 0) "I don’t h ave one\n"
(cl-format nil "I ~[don’t ~:;d~&o ~]have one~%" 1) "I d\no ha ve one\n")
(simple-tests t-tests
(cl-format nil "~@{~&~A~8,4T~:*~A~}"
’a ’aa ’aaa ’aaaa ’aaaaa ’aaaaaa ’aaaaaaa
’aaaaaaaa ’aaaaaaaaa ’aaaaaaaaaa)
(str "a a\naa aa\naaa aaa\naaaa aaaa\naaaaa "
"aaaaa\naaaaaa aaaaaa\naaaaaaa aaaaaaa\naaaaaaaa "
"aaaaaaaa\naaaaaaaaa aaaaaaaaa\naaaaaaaaaa aaaaaaaaaa ")
(cl-format nil "~@{~&~A~,4T~:*~A~}"
’a ’aa ’aaa ’aaaa ’aaaaa ’aaaaaa ’aaaaaaa ’aaaaaaaa ’aaaaaa aaa
’aaaaaaaaaa)
(str "a a\naa aa\naaa aaa\naaaa aaaa\naaaaa aaaaa\naaaaaa "
" aaaaaa\naaaaaaa aaaaaaa\naaaaaaaa aaaaaaaa\naaaaaaaa a "
"aaaaaaaaa\naaaaaaaaaa aaaaaaaaaa")
(cl-format nil "~@{~&~A~2,6@T~:*~A~}" ’a ’aa ’aaa ’aaaa ’a aaaa
’aaaaaa ’aaaaaaa ’aaaaaaaa ’aaaaaaaaa ’aaaaaaaaaa)
(str "a a\naa aa\naaa aaa\naaaa aaaa\naaaaa "
"aaaaa\naaaaaa aaaaaa\naaaaaaa aaaaaaa\naaaaaaaa"
1704 CHAPTER 12. TEST/CLOJURE
" aaaaaaaa\naaaaaaaaa aaaaaaaaa\naaaaaaaaaa aaaaaaaaaa ")
)
(simple-tests paren-tests
(cl-format nil "~(PLEASE SPEAK QUIETLY IN HERE~)")
"please speak quietly in here"
(cl-format nil "~@(PLEASE SPEAK QUIETLY IN HERE~)")
"Please speak quietly in here"
(cl-format nil "~@:(but this Is imporTant~)")
"BUT THIS IS IMPORTANT"
(cl-format nil "~:(the greAt gatsby~)!")
"The Great Gatsby!"
;; Test cases from CLtL 18.3 - string-upcase, et al.
(cl-format nil "~@:(~A~)" "Dr. Livingstone, I presume?")
"DR. LIVINGSTONE, I PRESUME?"
(cl-format nil "~(~A~)" "Dr. Livingstone, I presume?")
"dr. livingstone, i presume?"
(cl-format nil "~:(~A~)" " hello ")
" Hello "
(cl-format nil "~:(~A~)"
"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTIO N")
"Occluded Casements Forestall Inadvertent Defenestratio n"
(cl-format nil "~:(~A~)" ’kludgy-hash-search) "Kludgy-H ash-Search"
(cl-format nil "~:(~A~)" "DON’T!") "Don’T!" ;not "Don’t!"
(cl-format nil "~:(~A~)" "pipe 13a, foo16c") "Pipe 13a, Foo 16c"
)
(simple-tests square-bracket-tests
;; Tests for format without modifiers
(cl-format nil "I ~[don’t ~]have one~%" 0) "I don’t have one\ n"
(cl-format nil "I ~[don’t ~]have one~%" 1) "I have one\n"
(cl-format nil "I ~[don’t ~;do ~]have one~%" 0) "I don’t have one\n"
(cl-format nil "I ~[don’t ~;do ~]have one~%" 1) "I do have one \n"
(cl-format nil "I ~[don’t ~;do ~]have one~%" 2) "I have one\n "
(cl-format nil "I ~[don’t ~:;do ~]have one~%" 0) "I don’t hav e one\n"
(cl-format nil "I ~[don’t ~:;do ~]have one~%" 1) "I do have on e\n"
(cl-format nil "I ~[don’t ~:;do ~]have one~%" 2) "I do have on e\n"
(cl-format nil "I ~[don’t ~:;do ~]have one~%" 700) "I do have one\n"
;; Tests for format with a colon
(cl-format nil "I ~:[don’t ~;do ~]have one~%" true) "I do hav e one\n"
(cl-format nil "I ~:[don’t ~;do ~]have one~%" 700) "I do have one\n"
(cl-format nil "I ~:[don’t ~;do ~]have one~%" ’(a b)) "I do ha ve one\n"
(cl-format nil "I ~:[don’t ~;do ~]have one~%" nil) "I don’t h ave one\n"
(cl-format nil "I ~:[don’t ~;do ~]have one~%" false)
"I don’t have one\n"
;; Tests for format with an at sign
(cl-format nil "We had ~D wins~@[ (out of ~D tries)~].~%" 15 n il)
"We had 15 wins.\n"
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1705
(cl-format nil "We had ~D wins~@[ (out of ~D tries)~].~%" 15 1 7)
"We had 15 wins (out of 17 tries).\n"
;; Format tests with directives
(cl-format nil
"Max ~D: ~[Blue team ~D~;Red team ~D~:;No team ~A~].~%" 15, 0 , 7)
"Max 15: Blue team 7.\n"
(cl-format nil
"Max ~D: ~[Blue team ~D~;Red team ~D~:;No team ~A~].~%" 15, 1 , 12)
"Max 15: Red team 12.\n"
(cl-format nil
"Max ~D: ~[Blue team ~D~;Red team ~D~:;No team ~A~].~%"
15, -1, "(system failure)")
"Max 15: No team (system failure).\n"
;; Nested format tests
(cl-format nil
(str "Max ~D: ~[Blue team ~D~:[~; (complete success)~]~;"
"Red team ~D~:;No team ~].~%" )
15, 0, 7, true)
"Max 15: Blue team 7 (complete success).\n"
(cl-format nil
(str "Max ~D: ~[Blue team ~D~:[~; (complete success)~]~;"
"Red team ~D~:;No team ~].~%"
15, 0, 7, false)
"Max 15: Blue team 7.\n"
;; Test the selector as part of the argument
(cl-format nil
"The answer is ~#[nothing~;~D~;~D out of ~D~:;something cr azy~].")
"The answer is nothing."
(cl-format nil
"The answer is ~#[nothing~;~D~;~D out of ~D~:;something cr azy~]." 4)
"The answer is 4."
(cl-format nil
"The answer is ~#[nothing~;~D~;~D out of ~D~:;something cr azy~]."
7 22)
"The answer is 7 out of 22."
(cl-format nil
"The answer is ~#[nothing~;~D~;~D out of ~D~:;something cr azy~]."
1 2 3 4)
"The answer is something crazy."
)
(simple-tests curly-brace-plain-tests
;; Iteration from sublist
(cl-format nil "Coordinates are~{ [~D,~D]~}~%"
[ 0, 1, 1, 0, 3, 5, 2, 1 ])
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
1706 CHAPTER 12. TEST/CLOJURE
(cl-format nil "Coordinates are~2{ [~D,~D]~}~%"
[ 0, 1, 1, 0, 3, 5, 2, 1 ])
"Coordinates are [0,1] [1,0]\n"
(cl-format nil "Coordinates are~{ ~#[none~;<~D>~:;[~D,~ D]~]~}~%"
[ ])
"Coordinates are\n"
(cl-format nil "Coordinates are~{ ~#[none~;<~D>~:;[~D,~ D]~]~:}~%"
[ ])
"Coordinates are none\n"
(cl-format nil "Coordinates are~{ ~#[none~;<~D>~:;[~D,~ D]~]~:}~%"
[2 3 1])
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~{~:}~%" "" [])
"Coordinates are\n"
(cl-format nil
"Coordinates are~{~:}~%" " ~#[none~;<~D>~:;[~D,~D]~]" [ 2 3 1])
"Coordinates are [2,3] <1>\n"
(cl-format nil
"Coordinates are~{~:}~%" " ~#[none~;<~D>~:;[~D,~D]~]" [ ])
"Coordinates are none\n"
)
(simple-tests curly-brace-colon-tests
;; Iteration from list of sublists
(cl-format nil "Coordinates are~:{ [~D,~D]~}~%"
[ [0, 1], [1, 0], [3, 5], [2, 1] ])
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
(cl-format nil "Coordinates are~:{ [~D,~D]~}~%"
[ [0, 1, 0], [1, 0, 12], [3, 5], [2, 1] ])
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
(cl-format nil "Coordinates are~2:{ [~D,~D]~}~%"
[ [0, 1], [1, 0], [3, 5], [2, 1] ])
"Coordinates are [0,1] [1,0]\n"
(cl-format nil "Coordinates are~:{ ~#[none~;<~D>~:;[~D, ~D]~]~}~%"
[ ])
"Coordinates are\n"
(cl-format nil "Coordinates are~:{ ~#[none~;<~D>~:;[~D, ~D]~]~:}~%"
[ ])
"Coordinates are none\n"
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1707
(cl-format nil "Coordinates are~:{ ~#[none~;<~D>~:;[~D, ~D]~]~:}~%"
[[2 3] [1]])
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~:{~:}~%" "" [])
"Coordinates are\n"
(cl-format nil "Coordinates are~:{~:}~%" " ~#[none~;<~D> ~:;[~D,~D]~]"
[[2 3] [1]])
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~:{~:}~%" " ~#[none~;<~D> ~:;[~D,~D]~]"
[ ])
"Coordinates are none\n"
)
(simple-tests curly-brace-at-tests
;; Iteration from main list
(cl-format nil "Coordinates are~@{ [~D,~D]~}~%"
0, 1, 1, 0, 3, 5, 2, 1)
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
(cl-format nil "Coordinates are~2@{ [~D,~D]~}~%"
0, 1, 1, 0, 3, 5, 2, 1)
"Coordinates are [0,1] [1,0]\n"
(cl-format nil "Coordinates are~@{ ~#[none~;<~D>~:;[~D, ~D]~]~}~%")
"Coordinates are\n"
(cl-format nil "Coordinates are~@{ ~#[none~;<~D>~:;[~D, ~D]~]~:}~%")
"Coordinates are none\n"
(cl-format nil "Coordinates are~@{ ~#[none~;<~D>~:;[~D, ~D]~]~:}~%"
2 3 1)
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~@{~:}~%" "")
"Coordinates are\n"
(cl-format nil "Coordinates are~@{~:}~%" " ~#[none~;<~D> ~:;[~D,~D]~]"
2 3 1)
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~@{~:}~%" " ~#[none~;<~D> ~:;[~D,~D]~]")
"Coordinates are none\n"
)
(simple-tests curly-brace-colon-at-tests
;; Iteration from sublists on the main arg list
1708 CHAPTER 12. TEST/CLOJURE
(cl-format nil "Coordinates are~@:{ [~D,~D]~}~%"
[0, 1], [1, 0], [3, 5], [2, 1] )
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
(cl-format nil "Coordinates are~@:{ [~D,~D]~}~%"
[0, 1, 0], [1, 0, 12], [3, 5], [2, 1] )
"Coordinates are [0,1] [1,0] [3,5] [2,1]\n"
(cl-format nil "Coordinates are~2@:{ [~D,~D]~}~%"
[0, 1], [1, 0], [3, 5], [2, 1])
"Coordinates are [0,1] [1,0]\n"
(cl-format nil "Coordinates are~@:{ ~#[none~;<~D>~:;[~D ,~D]~]~}~%")
"Coordinates are\n"
(cl-format nil "Coordinates are~@:{ ~#[none~;<~D>~:;[~D ,~D]~]~:}~%")
"Coordinates are none\n"
(cl-format nil "Coordinates are~@:{ ~#[none~;<~D>~:;[~D ,~D]~]~:}~%"
[2 3] [1])
"Coordinates are [2,3] <1>\n"
(cl-format nil "Coordinates are~@:{~:}~%" "")
"Coordinates are\n"
(cl-format nil
"Coordinates are~@:{~:}~%" " ~#[none~;<~D>~:;[~D,~D]~] " [2 3] [1])
"Coordinates are [2,3] <1>\n"
(cl-format nil
"Coordinates are~@:{~:}~%" " ~#[none~;<~D>~:;[~D,~D]~] ")
"Coordinates are none\n"
)
;; TODO tests for ~^ in ~[ constructs and other brackets
;; TODO test ~:^ generates an error when used improperly
;; TODO test ~:^ works in ~@:{...~}
(let [aseq ’(a quick brown fox jumped over the lazy dog)
lseq (mapcat identity (for [x aseq] [x (.length (name x))])) ]
(simple-tests up-tests
(cl-format nil "~{~a~^, ~}" aseq)
"a, quick, brown, fox, jumped, over, the, lazy, dog"
(cl-format nil "~{~a~0^, ~}" aseq) "a"
(cl-format nil "~{~a~#,3^, ~}" aseq)
"a, quick, brown, fox, jumped, over"
(cl-format nil "~{~a~v,3^, ~}" lseq) "a, quick, brown, fox"
(cl-format nil "~{~a~3,v,4^, ~}" lseq) "a, quick, brown, fo x"
))
(simple-tests angle-bracket-tests
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1709
(cl-format nil "~<foo~;bar~;baz~>")
"foobarbaz"
(cl-format nil "~20<foo~;bar~;baz~>")
"foo bar baz"
(cl-format nil "~,,2<foo~;bar~;baz~>")
"foo bar baz"
(cl-format nil "~20<~A~;~A~;~A~>" "foo" "bar" "baz")
"foo bar baz"
(cl-format nil "~20:<~A~;~A~;~A~>" "foo" "bar" "baz")
" foo bar baz"
(cl-format nil "~20@<~A~;~A~;~A~>" "foo" "bar" "baz")
"foo bar baz "
(cl-format nil "~20@:<~A~;~A~;~A~>" "foo" "bar" "baz")
" foo bar baz "
(cl-format nil "~10,,2<~A~;~A~;~A~>" "foo" "bar" "baz")
"foo bar baz"
(cl-format nil "~10,10,2<~A~;~A~;~A~>" "foo" "bar" "baz" )
"foo bar baz"
(cl-format nil "~10,10<~A~;~A~;~A~>" "foo" "bar" "baz")
"foo barbaz"
(cl-format nil "~20<~A~;~^~A~;~^~A~>" "foo" "bar" "baz")
"foo bar baz"
(cl-format nil "~20<~A~;~^~A~;~^~A~>" "foo" "bar")
"foo bar"
(cl-format nil "~20@<~A~;~^~A~;~^~A~>" "foo")
"foo "
(cl-format nil "~20:<~A~;~^~A~;~^~A~>" "foo")
" foo"
)
(simple-tests angle-bracket-max-column-tests
(cl-format nil
"~%;; ~{~<~%;; ~1,50:; ~A~>~}.~%"
(into []
(.split
(str "This function computes the circular thermodynamic "
"coefficient of the thrombulator angle for use in "
"determining the reaction distance" "\\s"))))
(str "\n;; This function computes the circular\n;; "
"thermodynamic coefficient of the thrombulator\n;; "
"angle for use in determining the reaction\n;; distance.\n ")
(cl-format true "~%;; ~{~<~%;; ~:; ~A~>~}.~%"
(into [] (.split
(str "This function computes the circular thermodynamic co efficient"
" of the thrombulator angle for use in determining the reacti on"
" distance." "\\s")))))
(defn list-to-table [aseq column-width]
(let [stream (get-pretty-writer (java.io.StringWriter. ))]
(binding [*out* stream]
1710 CHAPTER 12. TEST/CLOJURE
(doseq [row aseq]
(doseq [col row]
(cl-format true "~4D~7,vT" col column-width))
(prn)))
(.flush stream)
(.toString (:base @@(:base @@stream)))))
(simple-tests column-writer-test
(list-to-table (map #(vector % (* % %) (* % % %)) (range 1 21)) 8 )
(str " 1 1 1 \n 2 4 8 \n 3 "
" 9 27 \n 4 16 64 \n 5 25 125"
" \n 6 36 216 \n 7 49 343 \n 8"
" 64 512 \n 9 81 729 \n 10 100 "
" 1000 \n 11 121 1331 \n 12 144 1728 \n"
" 13 169 2197 \n 14 196 2744 \n 15 225"
" 3375 \n 16 256 4096 \n 17 289 4913 "
" \n 18 324 5832 \n 19 361 6859 \n 20 "
"400 8000 \n"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;
;; The following tests are the various examples from the form at
;; documentation in Common Lisp, the Language, 2nd edition, Chapter 22.3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;
(defn expt [base pow] (reduce * (repeat pow base)))
(let [x 5, y "elephant", n 3]
(simple-tests cltl-intro-tests
(format nil "foo") "foo"
(format nil "The answer is ~D." x) "The answer is 5."
(format nil "The answer is ~3D." x) "The answer is 5."
(format nil "The answer is ~3,’0D." x) "The answer is 005."
(format nil "The answer is ~:D." (expt 47 x))
"The answer is 229,345,007."
(format nil "Look at the ~A!" y) "Look at the elephant!"
(format nil "Type ~:C to ~A." (char 4) "delete all your files" )
"Type Control-D to delete all your files."
(format nil "~D item~:P found." n) "3 items found."
(format nil "~R dog~:[s are~; is~] here." n (= n 1))
"three dogs are here."
(format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
"three dogs are here."
(format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
"Here are three puppies."))
(simple-tests cltl-B-tests
;; CLtL didn’t have the colons here, but the spec requires the m
(format nil "~,,’ ,4:B" 0xFACE) "1111 1010 1100 1110"
(format nil "~,,’ ,4:B" 0x1CE) "1 1100 1110"
(format nil "~19,,’ ,4:B" 0xFACE) "1111 1010 1100 1110"
;; This one was a nice idea, but nothing in the spec supports it
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1711
;; working this way
;; (and SBCL doesn’t work this way either)
;(format nil "~19,,’ ,4:B" 0x1CE) "0000 0001 1100 1110")
)
(simple-tests cltl-P-tests
(format nil "~D tr~:@P/~D win~:P" 7 1) "7 tries/1 win"
(format nil "~D tr~:@P/~D win~:P" 1 0) "1 try/0 wins"
(format nil "~D tr~:@P/~D win~:P" 1 3) "1 try/3 wins")
(defn foo [x]
(format nil "~6,2F|~6,2,1,’*F|~6,2,,’?F|~6F|~,2F|~F"
x x x x x x))
(simple-tests cltl-F-tests
(foo 3.14159) " 3.14| 31.42| 3.14|3.1416|3.14|3.14159"
(foo -3.14159) " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14 159"
(foo 100.0) "100.00|******|100.00| 100.0|100.00|100.0"
(foo 1234.0) "1234.00|******|??????|1234.0|1234.00|12 34.0"
(foo 0.006) " 0.01| 0.06| 0.01| 0.006|0.01|0.006")
(defn foo-e [x]
(format nil
"~9,2,1,,’*E|~10,3,2,2,’?,,’$E|~9,3,2,-2,’%@E|~9,2E "
x x x x))
;; Clojure doesn’t support float/double differences in rep resentation
(simple-tests cltl-E-tests
(foo-e 0.0314159) " 3.14E-2| 31.42$-03|+.003E+01| 3.14E- 2"
(foo-e 3.14159) " 3.14E+0| 31.42$-01|+.003E+03| 3.14E+0"
(foo-e -3.14159) " -3.14E+0|-31.42$-01|-.003E+03| -3.14 E+0"
(foo-e 1100.0) " 1.10E+3| 11.00$+02|+.001E+06| 1.10E+3"
; In Clojure, this is identical to the above
; (foo-e 1100.0L0) " 1.10L+3| 11.00$+02|+.001L+06| 1.10L+ 3"
(foo-e 1.1E13) "*********| 11.00$+12|+.001E+16| 1.10E+1 3"
(foo-e 1.1E120) "*********|??????????|%%%%%%%%%|1.10E +120"
; Clojure doesn’t support real numbers this large
; (foo-e 1.1L1200) "*********|??????????|%%%%%%%%%|1.1 0L+1200"
)
(simple-tests cltl-E-scale-tests
(map
(fn [k] (format nil "Scale factor ~2D~:*: |~13,6,2,VE|"
(- k 5) 3.14159)) ;Prints 13 lines
(range 13))
’("Scale factor -5: | 0.000003E+06|"
"Scale factor -4: | 0.000031E+05|"
"Scale factor -3: | 0.000314E+04|"
"Scale factor -2: | 0.003142E+03|"
"Scale factor -1: | 0.031416E+02|"
1712 CHAPTER 12. TEST/CLOJURE
"Scale factor 0: | 0.314159E+01|"
"Scale factor 1: | 3.141590E+00|"
"Scale factor 2: | 31.41590E-01|"
"Scale factor 3: | 314.1590E-02|"
"Scale factor 4: | 3141.590E-03|"
"Scale factor 5: | 31415.90E-04|"
"Scale factor 6: | 314159.0E-05|"
"Scale factor 7: | 3141590.E-06|"))
(defn foo-g [x]
(format nil
"~9,2,1,,’*G|~9,3,2,3,’?,,’$G|~9,3,2,0,’%G|~9,2G"
x x x x))
;; Clojure doesn’t support float/double differences in rep resentation
(simple-tests cltl-G-tests
(foo-g 0.0314159) " 3.14E-2|314.2$-04|0.314E-01| 3.14E- 2"
(foo-g 0.314159) " 0.31 |0.314 |0.314 | 0.31 "
(foo-g 3.14159) " 3.1 | 3.14 | 3.14 | 3.1 "
(foo-g 31.4159) " 31. | 31.4 | 31.4 | 31. "
(foo-g 314.159) " 3.14E+2| 314. | 314. | 3.14E+2"
(foo-g 3141.59) " 3.14E+3|314.2$+01|0.314E+04| 3.14E+3"
; In Clojure, this is identical to the above
; (foo-g 3141.59L0) " 3.14L+3|314.2$+01|0.314L+04| 3.14L +3"
(foo-g 3.14E12) "*********|314.0$+10|0.314E+13| 3.14E+ 12"
(foo-g 3.14E120) "*********|?????????|%%%%%%%%%|3.14E +120"
; Clojure doesn’t support real numbers this large
; (foo-g 3.14L1200) "*********|?????????|%%%%%%%%%|3.1 4L+1200"
)
(defn type-clash-error [fun nargs argnum right-type wrong -type]
(format nil ;; CLtL has this format string slightly wrong
"~&Function ~S requires its ~:[~:R ~;~*~]~
argument to be of type ~S,~%but it was called ~
with an argument of type ~S.~%"
fun (= nargs 1) argnum right-type wrong-type))
(simple-tests cltl-Newline-tests
(type-clash-error ’aref nil 2 ’integer ’vector)
"Function aref requires its second argument to be of type int eger,
but it was called with an argument of type vector.\n"
(type-clash-error ’car 1 1 ’list ’short-float)
"Function car requires its argument to be of type list,
but it was called with an argument of type short-float.\n")
(simple-tests cltl-?-tests
(format nil "~? ~D" "<~A ~D>" ’("Foo" 5) 7) "<Foo 5> 7"
(format nil "~? ~D" "<~A ~D>" ’("Foo" 5 14) 7) "<Foo 5> 7"
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) "<Foo 5> 7"
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) "<Foo 5> 14")
12.53. TEST/TEST˙CL˙FORMAT.CLJ 1713
(defn f [n] (format nil "~@(~R~) error~:P detected." n))
(simple-tests cltl-paren-tests
(format nil "~@R ~(~@R~)" 14 14) "XIV xiv"
(f 0) "Zero errors detected."
(f 1) "One error detected."
(f 23) "Twenty-three errors detected.")
(let [*print-level* nil *print-length* 5]
(simple-tests cltl-bracket-tests
(format nil "~@[ print level = ~D~]~@[ print length = ~D~]"
*print-level* *print-length*)
" print length = 5"))
(let [foo "Items:~#[ none~; ~S~; ~S and ~S~
~:;~@{~#[~; and~] ~
~S~^,~}~]."]
(simple-tests cltl-bracket1-tests
(format nil foo) "Items: none."
(format nil foo ’foo) "Items: foo."
(format nil foo ’foo ’bar) "Items: foo and bar."
(format nil foo ’foo ’bar ’baz) "Items: foo, bar, and baz."
(format nil foo ’foo ’bar ’baz ’quux)
"Items: foo, bar, baz, and quux."))
(simple-tests cltl-curly-bracket-tests
(format nil
"The winners are:~{ ~S~}."
’(fred harry jill))
"The winners are: fred harry jill."
(format nil "Pairs:~{ <~S,~S>~}." ’(a 1 b 2 c 3))
"Pairs: <a,1> <b,2> <c,3>."
(format nil "Pairs:~:{ <~S,~S>~}." ’((a 1) (b 2) (c 3)))
"Pairs: <a,1> <b,2> <c,3>."
(format nil "Pairs:~@{ <~S,~S>~}." ’a 1 ’b 2 ’c 3)
"Pairs: <a,1> <b,2> <c,3>."
(format nil "Pairs:~:@{ <~S,~S>~}." ’(a 1) ’(b 2) ’(c 3))
"Pairs: <a,1> <b,2> <c,3>.")
(simple-tests cltl-angle-bracket-tests
(format nil "~10<foo~;bar~>") "foo bar"
(format nil "~10:<foo~;bar~>") " foo bar"
(format nil "~10:@<foo~;bar~>") " foo bar "
(format nil "~10<foobar~>") " foobar"
(format nil "~10:<foobar~>") " foobar"
1714 CHAPTER 12. TEST/CLOJURE
(format nil "~10@<foobar~>") "foobar "
(format nil "~10:@<foobar~>") " foobar ")
(let [donestr "Done.~^ ~D warning~:P.~^ ~D error~:P."
;; The CLtL example is a little wrong here
tellstr "~@{~@(~@[~R~^ ~]~A~)~}."]
(simple-tests cltl-up-tests
(format nil donestr) "Done."
(format nil donestr 3) "Done. 3 warnings."
(format nil donestr 1 5) "Done. 1 warning. 5 errors."
(format nil tellstr 23) "Twenty-three."
(format nil tellstr nil "losers") "Losers."
(format nil tellstr 23 "losers") "Twenty-three losers."
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo)
" foo"
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo ’bar)
"foo bar"
(format nil "~15<~S~;~^~S~;~^~S~>" ’foo ’bar ’baz)
"foo bar baz"))
(simple-tests cltl-up-x3j13-tests
(format nil
"~:{/~S~^ ...~}"
’((hot dog) (hamburger) (ice cream) (french fries)))
"/hot .../hamburger/ice .../french ..."
(format nil
"~:{/~S~:^ ...~}"
’((hot dog) (hamburger) (ice cream) (french fries)))
"/hot .../hamburger .../ice .../french"
(format nil
"~:{/~S~#:^ ...~}" ;; This is wrong in CLtL
’((hot dog) (hamburger) (ice cream) (french fries)))
"/hot .../hamburger")
———-
12.54 test1/test˙helper.clj
— test1/test˙helper.clj —
\getchunk{Clojure Copyright}
;;; test_helper.clj -- part of the pretty printer for Clojur e
;; Author: Tom Faulhaber
12.55. TEST/TEST˙PRETTY.CLJ 1715
;; April 3, 2009
;; This is just a macro to make my tests a little cleaner
(ns clojure.test-clojure.pprint.test-helper
(:use [clojure.test :only (deftest is)]
[clojure.test-helper :only [platform-newlines]]))
(defn- back-match [x y] (re-matches y x))
(defmacro simple-tests [name & test-pairs]
‘(deftest ~name
~@(for [[x y] (partition 2 test-pairs)]
(cond
(instance? java.util.regex.Pattern y)
‘(is (#’clojure.test-clojure.pprint.test-helper/back -match
~x ~y))
(instance? java.lang.String y)
‘(is (= ~x (platform-newlines ~y)))
:else ‘(is (= ~x ~y))))))
———-
12.55 test/test˙pretty.clj
— test/test˙pretty.clj —
\getchunk{Clojure Copyright}
;;; test_pretty.clj -- part of the pretty printer for Clojur e
;; Author: Tom Faulhaber
;; April 3, 2009
(in-ns ’clojure.test-clojure.pprint)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
;;;
;;; Unit tests for the pretty printer
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;
(simple-tests xp-fill-test
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 38
1716 CHAPTER 12. TEST/CLOJURE
*print-miser-width* nil]
(cl-format nil "(let ~:<~@{~:<~w ~_~w~:>~^ ~:_~}~:>~_ ... )~%"
’((x 4) (*print-length* nil) (z 2) (list nil))))
"(let ((x 4) (*print-length* nil)\n (z 2) (list nil))\n ...) \n"
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 22]
(cl-format nil "(let ~:<~@{~:<~w ~_~w~:>~^ ~:_~}~:>~_ ... )~%"
’((x 4) (*print-length* nil) (z 2) (list nil))))
(str "(let ((x 4)\n"
" (*print-length*\n"
" nil)\n"
" (z 2)\n"
" (list nil))\n ...)\n"))
(simple-tests xp-miser-test
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 10, *print-miser-width* 9]
(cl-format nil "~:<LIST ~@_~W ~@_~W ~@_~W~:>" ’(first seco nd third)))
"(LIST\n first\n second\n third)"
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 10, *print-miser-width* 8]
(cl-format nil "~:<LIST ~@_~W ~@_~W ~@_~W~:>" ’(first seco nd third)))
"(LIST first second third)")
(simple-tests mandatory-fill-test
(cl-format nil
"<pre>~%~<Usage: ~:I~@{*~a*~^~:@_~}~:>~%</pre>~%"
[ "hello" "gooodbye" ])
"<pre>
Usage: *hello*
*gooodbye*
</pre>
")
(simple-tests prefix-suffix-test
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 10, *print-miser-width* 10]
(cl-format nil "~<{~;LIST ~@_~W ~@_~W ~@_~W~;}~:>"
’(first second third)))
"{LIST\n first\n second\n third}")
(simple-tests pprint-test
(binding [*print-pprint-dispatch* simple-dispatch]
(write
’(defn foo [x y]
(let [result (* x y)]
(if (> result 400)
(cl-format true "That number is too big")
12.55. TEST/TEST˙PRETTY.CLJ 1717
(cl-format true "The result of ~d x ~d is ~d" x y result))))
:stream nil))
"(defn
foo
[x y]
(let
[result (* x y)]
(if
(> result 400)
(cl-format true \"That number is too big\")
(cl-format true \"The result of ~d x ~d is ~d\" x y result))))"
(with-pprint-dispatch code-dispatch
(write
’(defn foo [x y]
(let [result (* x y)]
(if (> result 400)
(cl-format true "That number is too big")
(cl-format true "The result of ~d x ~d is ~d" x y result))))
:stream nil))
"(defn foo [x y]
(let [result (* x y)]
(if (> result 400)
(cl-format true \"That number is too big\")
(cl-format true \"The result of ~d x ~d is ~d\" x y result))))"
(binding [*print-pprint-dispatch* simple-dispatch
*print-right-margin* 15]
(write ’(fn (cons (car x) (cdr y))) :stream nil))
"(fn\n (cons\n (car x)\n (cdr y)))"
(with-pprint-dispatch code-dispatch
(binding [*print-right-margin* 52]
(write
’(add-to-buffer this (make-buffer-blob (str (char c)) nil ))
:stream nil)))
"(add-to-buffer\n this\n (make-buffer-blob (str (char c) ) nil))"
)
(simple-tests pprint-reader-macro-test
(with-pprint-dispatch code-dispatch
(write (read-string "(map #(first %) [[1 2 3] [4 5 6] [7]])")
:stream nil))
"(map #(first %) [[1 2 3] [4 5 6] [7]])"
(with-pprint-dispatch code-dispatch
(write (read-string "@@(ref (ref 1))")
:stream nil))
1718 CHAPTER 12. TEST/CLOJURE
"@@(ref (ref 1))"
(with-pprint-dispatch code-dispatch
(write (read-string "’foo")
:stream nil))
"’foo"
)
(simple-tests code-block-tests
(with-out-str
(with-pprint-dispatch code-dispatch
(pprint
’(defn cl-format
"An implementation of a Common Lisp compatible format funct ion"
[stream format-in & args]
(let [compiled-format
(if (string? format-in)
(compile-format format-in)
format-in)
navigator (init-navigator args)]
(execute-format stream compiled-format navigator))))))
"(defn cl-format
\"An implementation of a Common Lisp compatible format func tion\"
[stream format-in & args]
(let [compiled-format (if (string? format-in)
(compile-format format-in)
format-in)
navigator (init-navigator args)]
(execute-format stream compiled-format navigator)))
"
(with-out-str
(with-pprint-dispatch code-dispatch
(pprint
’(defn pprint-defn [writer alis]
(if (next alis)
(let [[defn-sym defn-name & stuff] alis
[doc-str stuff] (if (string? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])
[attr-map stuff] (if (map? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])]
(pprint-logical-block writer :prefix "(" :suffix ")"
(cl-format true "~w ~1I~@_~w" defn-sym defn-name)
(if doc-str
(cl-format true " ~_~w" doc-str))
(if attr-map
(cl-format true " ~_~w" attr-map))
;; Note: the multi-defn case will work OK for
12.55. TEST/TEST˙PRETTY.CLJ 1719
;; malformed defns too
(cond
(vector? (first stuff))
(single-defn stuff (or doc-str attr-map))
:else
(multi-defn stuff (or doc-str attr-map)))))
(pprint-simple-code-list writer alis))))))
"(defn pprint-defn [writer alis]
(if (next alis)
(let [[defn-sym defn-name & stuff] alis
[doc-str stuff] (if (string? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])
[attr-map stuff] (if (map? (first stuff))
[(first stuff) (next stuff)]
[nil stuff])]
(pprint-logical-block
writer
:prefix
\"(\"
:suffix
\")\"
(cl-format true \"~w ~1I~@_~w\" defn-sym defn-name)
(if doc-str (cl-format true \" ~_~w\" doc-str))
(if attr-map (cl-format true \" ~_~w\" attr-map))
(cond
(vector? (first stuff)) (single-defn
stuff
(or doc-str attr-map))
:else (multi-defn stuff (or doc-str attr-map)))))
(pprint-simple-code-list writer alis)))
")
(defn tst-pprint
"A helper function to pprint to a string with a restricted rig ht
margin"
[right-margin obj]
(binding [*print-right-margin* right-margin
*print-pretty* true]
(write obj :stream nil)))
;;; A bunch of predefined data to print
(def future-filled (future-call (fn [] 100)))
@future-filled
(def future-unfilled
(future-call (fn [] (.acquire (java.util.concurrent.Sem aphore. 0)))))
(def promise-filled (promise))
(deliver promise-filled ’(first second third))
(def promise-unfilled (promise))
1720 CHAPTER 12. TEST/CLOJURE
(def basic-agent (agent ’(first second third)))
(defn failed-agent
"must be a fn because you cannot await agents during load"
[]
(let [a (agent "foo")]
(send a +)
(try (await-for 100 a) (catch RuntimeException re))
a))
(def basic-atom (atom ’(first second third)))
(def basic-ref (ref ’(first second third)))
(def delay-forced (delay ’(first second third)))
(force delay-forced)
(def delay-unforced (delay ’(first second third)))
(defrecord pprint-test-rec [a b c])
(simple-tests pprint-datastructures-tests
(tst-pprint 20 future-filled)
#"#<Future@[0-9a-f]+: \r?\n 100>"
(tst-pprint 20 future-unfilled)
#"#<Future@[0-9a-f]+: \r?\n :pending>"
(tst-pprint 20 promise-filled)
#"#<Promise@[0-9a-f]+: \r?\n \(first\r?\n second\r?\n t hird\)>"
;; This hangs currently, cause we can’t figure out whether a p romise
;; is filled (tst-pprint 20 promise-unfilled)
;; #"#<Promise@[0-9a-f]+: \r?\n :pending>"
(tst-pprint 20 basic-agent)
#"#<Agent@[0-9a-f]+: \r?\n \(first\r?\n second\r?\n thi rd\)>"
(tst-pprint 20 (failed-agent))
#"#<Agent@[0-9a-f]+ FAILED: \r?\n \"foo\">"
(tst-pprint 20 basic-atom)
#"#<Atom@[0-9a-f]+: \r?\n \(first\r?\n second\r?\n thir d\r?\)>"
(tst-pprint 20 basic-ref)
#"#<Ref@[0-9a-f]+: \r?\n \(first\r?\n second\r?\n third \)>"
(tst-pprint 20 delay-forced)
#"#<Delay@[0-9a-f]+: \r?\n \(first\r?\n second\r?\n thi rd\)>"
;; Currently no way not to force the delay
;;(tst-pprint 20 delay-unforced)
#"#<Delay@[0-9a-f]+: \n :pending>"
;tpd i broke this
; (tst-pprint 20 (pprint-test-rec. ’first ’second ’third) )
; "{:a first,\n :b second,\n :c third}"
;; basic java arrays: fails owing to assembla ticket #346
;;(tst-pprint 10 (int-array (range 7)))
;; "[0,\n 1,\n 2,\n 3,\n 4,\n 5,\n 6]"
; (tst-pprint 15
; (reduce conj clojure.lang.PersistentQueue/EMPTY (rang e 10)))
; "<-(0\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9)-<"
)
12.56. TEST1/EXAMPLES.CLJ 1721
;;; Some simple tests of dispatch
(defmulti
test-dispatch
"A test dispatch method"
{:added "1.2" :arglists ’[[object]]}
#(and (seq %) (not (string? %))))
(defmethod test-dispatch true [avec]
(pprint-logical-block :prefix "[" :suffix "]"
(loop [aseq (seq avec)]
(when aseq
(write-out (first aseq))
(when (next aseq)
(.write ^java.io.Writer *out* " ")
(pprint-newline :linear)
(recur (next aseq)))))))
(defmethod test-dispatch false [aval] (pr aval))
(simple-tests dispatch-tests
(with-pprint-dispatch test-dispatch
(with-out-str
(pprint ’("hello" "there"))))
"[\"hello\" \"there\"]\n"
)
———-
12.56 test1/examples.clj
— test1/examples.clj —
(ns clojure.test-clojure.protocols.examples)
(defprotocol ExampleProtocol
"example protocol used by clojure tests"
(foo [a] "method with one arg")
(bar [a b] "method with two args")
(^String baz [a] [a b] "method with multiple arities")
(with-quux [a] "method name with a hyphen"))
(definterface ExampleInterface
1722 CHAPTER 12. TEST/CLOJURE
(hinted [^int i])
(hinted [^String s]))
———-
12.57 test/more˙examples.clj
— test/more˙examples.clj —
(ns clojure.test-clojure.protocols.more-examples)
(defprotocol SimpleProtocol
"example protocol used by clojure tests. Note that
foo collides with examples/ExampleProtocol."
(foo [a] ""))
———-
12.58 test/example.clj
— test/example.clj —
(ns clojure.test-clojure.repl.example)
;; sample namespace for repl tests, don’t add anything here
(defn foo [])
(defn bar [])
———-
Appendix A
External Java References
Click on a class name to go to the appropriate web page.
•AbstractMap
•Callable
•Collection
•Comparable
•Comparator
•ConcurrentMap
•DefaultHandler
•Enumeration
•IllegalArgumentException
•InvocationHandler
•Iterable
•Iterator
•List
•Map
•Map.Entry
•Number
•PushbackReader
•RandomAccess
•Runnable
•Serializable
•Set
•URLClassLoader
1723
1724 APPENDIX A. EXTERNAL JAVA REFERENCES
Appendix B
Copyright and Licenses
— Clojure License —
Eclipse Public License - v 1.0
THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DIS TRIBUTION OF
THE PROGRAM CONSTITUTES RECIPIENT’S ACCEPTANCE OF THIS AGR EEMENT.
1. DEFINITIONS
"Contribution" means:
a) in the case of the initial Contributor, the initial code an d
documentation distributed under this Agreement, and
b) in the case of each subsequent Contributor:
i) changes to the Program, and
ii) additions to the Program;
where such changes and/or additions to the Program originat e from and
are distributed by that particular Contributor. A Contribu tion
’originates’ from a Contributor if it was added to the Progra m by such
Contributor itself or anyone acting on such Contributor’s
behalf. Contributions do not include additions to the Progr am which:
(i) are separate modules of software distributed in conjunc tion with
the Program under their own license agreement, and (ii) are n ot
derivative works of the Program.
"Contributor" means any person or entity that distributes t he Program.
1725
1726 APPENDIX B. COPYRIGHT AND LICENSES
"Licensed Patents" mean patent claims licensable by a Contr ibutor
which are necessarily infringed by the use or sale of its Cont ribution
alone or when combined with the Program.
"Program" means the Contributions distributed in accordan ce with this
Agreement.
"Recipient" means anyone who receives the Program under thi s
Agreement, including all Contributors.
2. GRANT OF RIGHTS
a) Subject to the terms of this Agreement, each Contributor h ereby
grants Recipient a non-exclusive, worldwide, royalty-fre e copyright
license to reproduce, prepare derivative works of, publicl y display,
publicly perform, distribute and sublicense the Contribut ion of such
Contributor, if any, and such derivative works, in source co de and
object code form.
b) Subject to the terms of this Agreement, each Contributor h ereby
grants Recipient a non-exclusive, worldwide, royalty-fre e patent
license under Licensed Patents to make, use, sell, offer to s ell,
import and otherwise transfer the Contribution of such Cont ributor, if
any, in source code and object code form. This patent license shall
apply to the combination of the Contribution and the Program if, at
the time the Contribution is added by the Contributor, such a ddition
of the Contribution causes such combination to be covered by the
Licensed Patents. The patent license shall not apply to any o ther
combinations which include the Contribution. No hardware p er se is
licensed hereunder.
c) Recipient understands that although each Contributor gr ants the
licenses to its Contributions set forth herein, no assuranc es are
provided by any Contributor that the Program does not infrin ge the
patent or other intellectual property rights of any other en tity. Each
Contributor disclaims any liability to Recipient for claim s brought by
any other entity based on infringement of intellectual prop erty rights
or otherwise. As a condition to exercising the rights and lic enses
granted hereunder, each Recipient hereby assumes sole resp onsibility
to secure any other intellectual property rights needed, if any. For
example, if a third party patent license is required to allow
Recipient to distribute the Program, it is Recipient’s resp onsibility
to acquire that license before distributing the Program.
d) Each Contributor represents that to its knowledge it has s ufficient
copyright rights in its Contribution, if any, to grant the co pyright
license set forth in this Agreement.
3. REQUIREMENTS
1727
A Contributor may choose to distribute the Program in object code form
under its own license agreement, provided that:
a) it complies with the terms and conditions of this Agreemen t; and
b) its license agreement:
i) effectively disclaims on behalf of all Contributors all w arranties
and conditions, express and implied, including warranties or
conditions of title and non-infringement, and implied warr anties or
conditions of merchantability and fitness for a particular purpose;
ii) effectively excludes on behalf of all Contributors all l iability
for damages, including direct, indirect, special, inciden tal and
consequential damages, such as lost profits;
iii) states that any provisions which differ from this Agree ment are
offered by that Contributor alone and not by any other party; and
iv) states that source code for the Program is available from such
Contributor, and informs licensees how to obtain it in a reas onable
manner on or through a medium customarily used for software e xchange.
When the Program is made available in source code form:
a) it must be made available under this Agreement; and
b) a copy of this Agreement must be included with each copy of t he
Program.
Contributors may not remove or alter any copyright notices c ontained
within the Program.
Each Contributor must identify itself as the originator of i ts
Contribution, if any, in a manner that reasonably allows sub sequent
Recipients to identify the originator of the Contribution.
4. COMMERCIAL DISTRIBUTION
Commercial distributors of software may accept certain
responsibilities with respect to end users, business partn ers and the
like. While this license is intended to facilitate the comme rcial use
of the Program, the Contributor who includes the Program in a
commercial product offering should do so in a manner which do es not
create potential liability for other Contributors. Theref ore, if a
Contributor includes the Program in a commercial product of fering,
such Contributor ("Commercial Contributor") hereby agree s to defend
and indemnify every other Contributor ("Indemnified Contr ibutor")
against any losses, damages and costs (collectively "Losse s") arising
1728 APPENDIX B. COPYRIGHT AND LICENSES
from claims, lawsuits and other legal actions brought by a th ird party
against the Indemnified Contributor to the extent caused by the acts
or omissions of such Commercial Contributor in connection w ith its
distribution of the Program in a commercial product offerin g. The
obligations in this section do not apply to any claims or Loss es
relating to any actual or alleged intellectual property
infringement. In order to qualify, an Indemnified Contribu tor must: a)
promptly notify the Commercial Contributor in writing of su ch claim,
and b) allow the Commercial Contributor to control, and coop erate with
the Commercial Contributor in, the defense and any related s ettlement
negotiations. The Indemnified Contributor may participat e in any such
claim at its own expense.
For example, a Contributor might include the Program in a com mercial
product offering, Product X. That Contributor is then a Comm ercial
Contributor. If that Commercial Contributor then makes per formance
claims, or offers warranties related to Product X, those per formance
claims and warranties are such Commercial Contributor’s re sponsibility
alone. Under this section, the Commercial Contributor woul d have to
defend claims against the other Contributors related to tho se
performance claims and warranties, and if a court requires a ny other
Contributor to pay any damages as a result, the Commercial Co ntributor
must pay those damages.
5. NO WARRANTY
EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIO NS OF ANY
KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITAT ION, ANY
WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERC HANTABILITY
OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solel y
responsible for determining the appropriateness of using a nd
distributing the Program and assumes all risks associated w ith its
exercise of rights under this Agreement , including but not l imited to
the risks and costs of program errors, compliance with appli cable
laws, damage to or loss of data, programs or equipment, and
unavailability or interruption of operations.
6. DISCLAIMER OF LIABILITY
EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER REC IPIENT NOR
ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, IN DIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING
WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ( INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR
DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRA NTED
HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE S.
7. GENERAL
1729
If any provision of this Agreement is invalid or unenforceab le under
applicable law, it shall not affect the validity or enforcea bility of
the remainder of the terms of this Agreement, and without fur ther
action by the parties hereto, such provision shall be reform ed to the
minimum extent necessary to make such provision valid and en forceable.
If Recipient institutes patent litigation against any enti ty
(including a cross-claim or counterclaim in a lawsuit) alle ging that
the Program itself (excluding combinations of the Program w ith other
software or hardware) infringes such Recipient’s patent(s ), then such
Recipient’s rights granted under Section 2(b) shall termin ate as of
the date such litigation is filed.
All Recipient’s rights under this Agreement shall terminat e if it
fails to comply with any of the material terms or conditions o f this
Agreement and does not cure such failure in a reasonable peri od of
time after becoming aware of such noncompliance. If all Reci pient’s
rights under this Agreement terminate, Recipient agrees to cease use
and distribution of the Program as soon as reasonably
practicable. However, Recipient’s obligations under this Agreement and
any licenses granted by Recipient relating to the Program sh all
continue and survive.
Everyone is permitted to copy and distribute copies of this A greement,
but in order to avoid inconsistency the Agreement is copyrig hted and
may only be modified in the following manner. The Agreement S teward
reserves the right to publish new versions (including revis ions) of
this Agreement from time to time. No one other than the Agreem ent
Steward has the right to modify this Agreement. The Eclipse F oundation
is the initial Agreement Steward. The Eclipse Foundation ma y assign
the responsibility to serve as the Agreement Steward to a sui table
separate entity. Each new version of the Agreement will be gi ven a
distinguishing version number. The Program (including Con tributions)
may always be distributed subject to the version of the Agree ment
under which it was received. In addition, after a new version of the
Agreement is published, Contributor may elect to distribut e the
Program (including its Contributions) under the new versio n. Except as
expressly stated in Sections 2(a) and 2(b) above, Recipient receives
no rights or licenses to the intellectual property of any Con tributor
under this Agreement, whether expressly, by implication, e stoppel or
otherwise. All rights in the Program not expressly granted u nder this
Agreement are reserved.
This Agreement is governed by the laws of the State of New York and
the intellectual property laws of the United States of Ameri ca. No
party to this Agreement will bring a legal action under this A greement
more than one year after the cause of action arose. Each party waives
its rights to a jury trial in any resulting litigation.
1730 APPENDIX B. COPYRIGHT AND LICENSES
———-
— Clojure Copyright —
; Copyright (c) Rich Hickey. All rights reserved. The use and
; distribution terms for this software are covered by the Ecl ipse
; Public License 1.0
; (http://opensource.org/licenses/eclipse-1.0.php) wh ich can be
; found in the file epl-v10.html at the root of this distribut ion.
; By using this software in any fashion, you are agreeing to be
; bound by the terms of this license. You must not remove this
; notice, or any other, from this software.
———-
— France Telecom Copyright —
/***
* ASM: a very small and fast Java bytecode manipulation frame work
* Copyright (c) 2000-2005 INRIA, France Telecom
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or w ithout
* modification, are permitted provided that the following c onditions
* are met:
* 1. Redistributions of source code must retain the above cop yright
* notice, this list of conditions and the following disclaim er.
* 2. Redistributions in binary form must reproduce the above copyright
* notice, this list of conditions and the following disclaim er in the
* documentation and/or other materials provided with the
* distribution.
* 3. Neither the name of the copyright holders nor the names of its
* contributors may be used to endorse or promote products der ived
* from this software without specific prior written permiss ion.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONT RIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, B UT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL T HE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, I NDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGE S (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERV ICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HO WEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) AR ISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
1731
*/
———-
— Houser Copyright and License —
; Copyright (c) Chris Houser, Dec 2008. All rights reserved. The
; use and distribution terms for this software are covered by the
; Common Public License 1.0 (http://opensource.org/licen ses/cpl.php)
; which can be found in the file CPL.TXT at the root of this
; distribution. By using this software in any fashion, you ar e
; agreeing to be bound by the terms of this license. You must no t
; remove this notice, or any other, from this software.
———-
— L´ orange Copyright and License —
Copyright 2013 Jean Niklas L\’orange.
This text is licensed under the Creative Commons
Attribution-ShareAlike 3.0 Unported License, unless othe rwise
specified
———-
— Kingsbury Copyright and License —
Copyright 2013 Kyle Kingsbury.
Non-commercial re-use with attribution encouraged; all ot her rights reserved.
———-
— Kingsbury Copyright and License —
Copyright 2013 Kai Wu
Licensed under Common Public License 1.0
———-
1732 APPENDIX B. COPYRIGHT AND LICENSES
Appendix C
Building Clojure from this
document
C.1 The basic idea
Literate programs are T EXdocuments that contain executable source code. If
you have a running system you can use the included clojure code to e xtract
chunks at will. But what if you don’t have clojure yet? There has to be a
“bootstrap” mechanism and we supply that here.
First, you need to edit this ﬁle and clip out the “tangle” function writt en in C
below. You compile this with GCC. This gives you a small program that will
extract named chunks from this document.
Second, you extract the Makeﬁle chunk. This Makeﬁle will use the ta ngle func-
tion to create the clojure source tree, including the build.xml ﬁle whic h is used
by the ant build program. Note that this should be rewritten to be pa rt of the
build.xml but that is not part of Clojure.
Third, you run the Makeﬁle. It will extract all of the code into the pr oper places
in the source tree and run the ant build process to create a running Clojure.
C.2 The tangle function in C
— tangle.c —
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
1733
1734 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
#include <sys/mman.h>
#include <fcntl.h>
#define DEBUG 0
/* forward reference for the C compiler */
int getchunk(char *chunkname);
/* a memory mapped buffer copy of the file */
char *buffer;
int bufsize;
/* return the length of the next line */
int nextline(int i) {
int j;
if (i >= bufsize) return(-1);
for (j=0; ((i+j < bufsize) && (buffer[i+j] != ’\n’)); j++);
return(j);
}
/* output the line we need */
int printline(int i, int length) {
int j;
for (j=0; j<length; j++) { putchar(buffer[i+j]); }
printf("\n");
}
/* handle begin{chunk}{chunkname} */
/* is this chunk name we are looking for? */
int foundchunk(int i, char *chunkname) {
if ((strncmp(&buffer[i+14],chunkname,strlen(chunknam e)) == 0) &&
(buffer[i+13] == ’{’) &&
(buffer[i+14+strlen(chunkname)] == ’}’)) return(1);
return(0);
}
/* handle end{chunk} */
/* is it really an end? */
int foundEnd(int i) {
if ((buffer[i] == ’\\’) &&
(strncmp(&buffer[i+1],"end{chunk}",10) == 0)) {
return(1);
}
return(0);
}
/* handle getchunk{chunkname} */
/* is this line a getchunk? */
int foundGetchunk(int i, int linelen) {
int len;
C.2. THE TANGLE FUNCTION IN C 1735
if (strncmp(&buffer[i],"\\getchunk{",10) == 0) {
for(len=0; ((len < linelen) && (buffer[i+len] != ’}’)); len ++);
return(len-10);
}
return(0);
}
/* Somebody did a getchunk and we need a copy of the name */
/* malloc string storage for a copy of the getchunk name */
char *getChunkname(int k, int getlen) {
char *result = (char *)malloc(getlen+1);
strncpy(result,&buffer[k+10],getlen);
result[getlen]=’\0’;
return(result);
}
/* print lines in this chunk, possibly recursing into getchu nk */
int printchunk(int i, int chunklinelen, char *chunkname) {
int j;
int k;
int linelen;
char *getname;
int getlen = 0;
for (k=i+chunklinelen+1; ((linelen=nextline(k)) != -1); ) {
if (DEBUG==2) {
printf(">>>>"); printline(k,linelen); printf("<<<<\n" );
}
if ((getlen=foundGetchunk(k,linelen)) > 0) {
getname = getChunkname(k,getlen);
getchunk(getname);
free(getname);
k=k+getlen+12l;
} else {
if ((linelen >= 11) && (foundEnd(k) == 1)) {
if (DEBUG) { printf("=================\\end{%s}\n",chu nkname); }
return(k+12);
} else {
if (DEBUG==2) {
printf("======== printchunk else %d %d\n",k,linelen);
}
printline(k,linelen);
k=k+linelen+1;
}
}}
if (DEBUG==2) {
printf("=================\\out{%s} %d\n",chunkname,k );
}
return(k);
}
1736 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
/* find the named chunk and call printchunk on it */
int getchunk(char *chunkname) {
int i;
int j;
int linelen;
int chunklen = strlen(chunkname);
for (i=0; ((linelen=nextline(i)) != -1); ) {
if (DEBUG==2) {
printf("----"); printline(i,linelen); printf("----\n" );
}
if ((linelen >= chunklen+15) && (foundchunk(i,chunkname) == 1)) {
if (DEBUG) {
fprintf(stderr,"=================\\getchunk(%s)\n", chunkname);
}
i=printchunk(i,linelen,chunkname);
} else {
i=i+linelen+1;
}
}
if (DEBUG) {
fprintf(stderr,"=================getchunk returned=% d\n",i);
}
return(i);
}
/* memory map the input file into the global buffer and get the chunk */
int main(int argc, char *argv[]) {
int fd;
struct stat filestat;
if ((argc < 2) || (argc > 3)) {
perror("Usage: tangle filename chunkname");
exit(-1);
}
fd = open(argv[1],O_RDONLY);
if (fd == -1) {
perror("Error opening file for reading");
exit(-2);
}
if (fstat(fd,&filestat) < 0) {
perror("Error getting input file size");
exit(-3);
}
bufsize = (int)filestat.st_size;
buffer = mmap(0,filestat.st_size,PROT_READ,MAP_SHARED ,fd,0);
if (buffer == MAP_FAILED) {
close(fd);
perror("Error reading the file");
exit(-4);
}
getchunk(argv[2]);
C.3. MAKEFILE 1737
close(fd);
return(0);
}
———-
C.3 Makeﬁle
— Makeﬁle —
BOOK=clojure.pamphlet
WHERE=tpd
CLOJURE=${WHERE}/src/clj/clojure
CORE=${WHERE}//src/clj/clojure/core
JAVA=${WHERE}/src/clj/clojure/java
PPRINT=${WHERE}/src/clj/clojure/pprint
REFLECT=${WHERE}/src/clj/clojure/reflect
TEST=${WHERE}/src/clj/clojure/test
MAIN=${WHERE}/src/jvm/clojure
ASM=${WHERE}/src/jvm/clojure/asm
COMMONS=${WHERE}/src/jvm/clojure/asm/commons
LANG=${WHERE}/src/jvm/clojure/lang
TESTA=${WHERE}/test/clojure
TESTC=${WHERE}/test/clojure/test_clojure
TESTD=${WHERE}/test/clojure/test_clojure/annotation s
TESTE=${WHERE}/test/clojure/test_clojure/genclass
TESTF=${WHERE}/test/clojure/test_clojure/java
TESTG=${WHERE}/test/clojure/test_clojure/pprint
TESTH=${WHERE}/test/clojure/test_clojure/protocols
TESTI=${WHERE}/test/clojure/test_clojure/repl
all:
rm -rf ${WHERE}
mkdir -p ${CLOJURE}
mkdir -p ${CORE}
mkdir -p ${JAVA}
mkdir -p ${PPRINT}
mkdir -p ${REFLECT}
mkdir -p ${TEST}
mkdir -p ${ASM}
mkdir -p ${COMMONS}
mkdir -p ${LANG}
mkdir -p ${TESTA}
mkdir -p ${TESTC}
mkdir -p ${TESTD}
mkdir -p ${TESTE}
1738 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
mkdir -p ${TESTF}
mkdir -p ${TESTG}
mkdir -p ${TESTH}
mkdir -p ${TESTI}
tangle ${BOOK} build.xml >${WHERE}/build.xml
tangle ${BOOK} pom-template.xml >${WHERE}/pom-template .xml
tangle ${BOOK} protocols.clj >${CORE}/protocols.clj
tangle ${BOOK} core.clj >${CLOJURE}/core.clj
tangle ${BOOK} core_deftype.clj >${CLOJURE}/core_defty pe.clj
tangle ${BOOK} core_print.clj >${CLOJURE}/core_print.c lj
tangle ${BOOK} core_proxy.clj >${CLOJURE}/core_proxy.c lj
tangle ${BOOK} data.clj >${CLOJURE}/data.clj
tangle ${BOOK} genclass.clj >${CLOJURE}/genclass.clj
tangle ${BOOK} gvec.clj >${CLOJURE}/gvec.clj
tangle ${BOOK} inspector.clj >${CLOJURE}/inspector.clj
tangle ${BOOK} browse.clj >${JAVA}/browse.clj
tangle ${BOOK} browse_ui.clj >${JAVA}/browse_ui.clj
tangle ${BOOK} io.clj >${JAVA}/io.clj
tangle ${BOOK} javadoc.clj >${JAVA}/javadoc.clj
tangle ${BOOK} shell.clj >${JAVA}/shell.clj
tangle ${BOOK} main.clj >${CLOJURE}/main.clj
tangle ${BOOK} parallel.clj >${CLOJURE}/parallel.clj
tangle ${BOOK} cl_format.clj >${PPRINT}/cl_format.clj
tangle ${BOOK} column_writer.clj >${PPRINT}/column_wri ter.clj
tangle ${BOOK} dispatch.clj >${PPRINT}/dispatch.clj
tangle ${BOOK} pprint_base.clj >${PPRINT}/pprint_base. clj
tangle ${BOOK} pretty_writer.clj >${PPRINT}/pretty_wri ter.clj
tangle ${BOOK} print_table.clj >${PPRINT}/print_table. clj
tangle ${BOOK} utilities.clj >${PPRINT}/utilities.clj
tangle ${BOOK} pprint.clj >${CLOJURE}/pprint.clj
tangle ${BOOK} java.clj >${REFLECT}/java.clj
tangle ${BOOK} reflect.clj >${CLOJURE}/reflect.clj
tangle ${BOOK} repl.clj >${CLOJURE}/repl.clj
tangle ${BOOK} set.clj >${CLOJURE}/set.clj
tangle ${BOOK} stacktrace.clj >${CLOJURE}/stacktrace.c lj
tangle ${BOOK} string.clj >${CLOJURE}/string.clj
tangle ${BOOK} template.clj >${CLOJURE}/template.clj
tangle ${BOOK} junit.clj >${TEST}/junit.clj
tangle ${BOOK} tap.clj >${TEST}/tap.clj
tangle ${BOOK} test.clj >${CLOJURE}/test.clj
tangle ${BOOK} version.properties >${CLOJURE}/version. properties
tangle ${BOOK} walk.clj >${CLOJURE}/walk.clj
tangle ${BOOK} xml.clj >${CLOJURE}/xml.clj
tangle ${BOOK} zip.clj >${CLOJURE}/zip.clj
tangle ${BOOK} AnnotationVisitor.java \
>${ASM}/AnnotationVisitor.java
tangle ${BOOK} AnnotationWriter.java \
>${ASM}/AnnotationWriter.java
tangle ${BOOK} Attribute.java >${ASM}/Attribute.java
tangle ${BOOK} ByteVector.java >${ASM}/ByteVector.java
C.3. MAKEFILE 1739
tangle ${BOOK} ClassAdapter.java >${ASM}/ClassAdapter. java
tangle ${BOOK} ClassReader.java >${ASM}/ClassReader.ja va
tangle ${BOOK} ClassVisitor.java >${ASM}/ClassVisitor. java
tangle ${BOOK} ClassWriter.java >${ASM}/ClassWriter.ja va
tangle ${BOOK} ClassWriter.java >${ASM}/ClassWriter.ja va
tangle ${BOOK} AdviceAdapter.java \
>${COMMONS}/AdviceAdapter.java
tangle ${BOOK} AnalyzerAdapter.java \
>${COMMONS}/AnalyzerAdapter.java
tangle ${BOOK} CodeSizeEvaluator.java \
>${COMMONS}/CodeSizeEvaluator.java
tangle ${BOOK} EmptyVisitor.java \
>${COMMONS}/EmptyVisitor.java
tangle ${BOOK} GeneratorAdapter.java \
>${COMMONS}/GeneratorAdapter.java
tangle ${BOOK} LocalVariablesSorter.java \
>${COMMONS}/LocalVariablesSorter.java
tangle ${BOOK} Method.java >${COMMONS}/Method.java
tangle ${BOOK} SerialVersionUIDAdder.java \
>${COMMONS}/SerialVersionUIDAdder.java
tangle ${BOOK} StaticInitMerger.java \
>${COMMONS}/StaticInitMerger.java
tangle ${BOOK} TableSwitchGenerator.java \
>${COMMONS}/TableSwitchGenerator.java
tangle ${BOOK} Edge.java >${ASM}/Edge.java
tangle ${BOOK} FieldVisitor.java >${ASM}/FieldVisitor. java
tangle ${BOOK} FieldWriter.java >${ASM}/FieldWriter.ja va
tangle ${BOOK} Frame.java >${ASM}/Frame.java
tangle ${BOOK} Handler.java >${ASM}/Handler.java
tangle ${BOOK} Item.java >${ASM}/Item.java
tangle ${BOOK} Label.java >${ASM}/Label.java
tangle ${BOOK} MethodAdapter.java >${ASM}/MethodAdapte r.java
tangle ${BOOK} MethodVisitor.java >${ASM}/MethodVisito r.java
tangle ${BOOK} MethodWriter.java >${ASM}/MethodWriter. java
tangle ${BOOK} Opcodes.java >${ASM}/Opcodes.java
tangle ${BOOK} Type.java >${ASM}/Type.java
tangle ${BOOK} AFn.java >${LANG}/AFn.java
tangle ${BOOK} AFunction.java >${LANG}/AFunction.java
tangle ${BOOK} Agent.java >${LANG}/Agent.java
tangle ${BOOK} AMapEntry.java >${LANG}/AMapEntry.java
tangle ${BOOK} APersistentMap.java >${LANG}/APersisten tMap.java
tangle ${BOOK} APersistentSet.java >${LANG}/APersisten tSet.java
tangle ${BOOK} APersistentVector.java \
>${LANG}/APersistentVector.java
tangle ${BOOK} AReference.java >${LANG}/AReference.jav a
tangle ${BOOK} ARef.java >${LANG}/ARef.java
tangle ${BOOK} ArityException.java >${LANG}/ArityExcep tion.java
tangle ${BOOK} ArrayChunk.java >${LANG}/ArrayChunk.jav a
tangle ${BOOK} ArraySeq.java >${LANG}/ArraySeq.java
tangle ${BOOK} ASeq.java >${LANG}/ASeq.java
1740 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
tangle ${BOOK} Associative.java >${LANG}/Associative.j ava
tangle ${BOOK} Atom.java >${LANG}/Atom.java
tangle ${BOOK} ATransientMap.java >${LANG}/ATransientM ap.java
tangle ${BOOK} ATransientSet.java >${LANG}/ATransientS et.java
tangle ${BOOK} BigInt.java >${LANG}/BigInt.java
tangle ${BOOK} Binding.java >${LANG}/Binding.java
tangle ${BOOK} Box.java >${LANG}/Box.java
tangle ${BOOK} ChunkBuffer.java >${LANG}/ChunkBuffer.j ava
tangle ${BOOK} ChunkedCons.java >${LANG}/ChunkedCons.j ava
tangle ${BOOK} Compile.java >${LANG}/Compile.java
tangle ${BOOK} Compiler.java >${LANG}/Compiler.java
tangle ${BOOK} Cons.java >${LANG}/Cons.java
tangle ${BOOK} Counted.java >${LANG}/Counted.java
tangle ${BOOK} Delay.java >${LANG}/Delay.java
tangle ${BOOK} DynamicClassLoader.java \
>${LANG}/DynamicClassLoader.java
tangle ${BOOK} EnumerationSeq.java >${LANG}/Enumeratio nSeq.java
tangle ${BOOK} Fn.java >${LANG}/Fn.java
tangle ${BOOK} IChunkedSeq.java >${LANG}/IChunkedSeq.j ava
tangle ${BOOK} IChunk.java >${LANG}/IChunk.java
tangle ${BOOK} IDeref.java >${LANG}/IDeref.java
tangle ${BOOK} IEditableCollection.java \
>${LANG}/IEditableCollection.java
tangle ${BOOK} IFn.java >${LANG}/IFn.java
tangle ${BOOK} IKeywordLookup.java >${LANG}/IKeywordLo okup.java
tangle ${BOOK} ILookup.java >${LANG}/ILookup.java
tangle ${BOOK} ILookup.java >${LANG}/ILookup.java
tangle ${BOOK} ILookupSite.java >${LANG}/ILookupSite.j ava
tangle ${BOOK} ILookupThunk.java >${LANG}/ILookupThunk .java
tangle ${BOOK} IMapEntry.java >${LANG}/IMapEntry.java
tangle ${BOOK} IMeta.java >${LANG}/IMeta.java
tangle ${BOOK} Indexed.java >${LANG}/Indexed.java
tangle ${BOOK} IndexedSeq.java >${LANG}/IndexedSeq.jav a
tangle ${BOOK} IObj.java >${LANG}/IObj.java
tangle ${BOOK} IPersistentCollection.java \
>${LANG}/IPersistentCollection.java
tangle ${BOOK} IPersistentList.java \
>${LANG}/IPersistentList.java
tangle ${BOOK} IPersistentMap.java >${LANG}/IPersisten tMap.java
tangle ${BOOK} IPersistentSet.java >${LANG}/IPersisten tSet.java
tangle ${BOOK} IPersistentStack.java \
>${LANG}/IPersistentStack.java
tangle ${BOOK} IPersistentVector.java \
>${LANG}/IPersistentVector.java
tangle ${BOOK} IPromiseImpl.java >${LANG}/IPromiseImpl .java
tangle ${BOOK} IProxy.java >${LANG}/IProxy.java
tangle ${BOOK} IReduce.java >${LANG}/IReduce.java
tangle ${BOOK} IReference.java >${LANG}/IReference.jav a
tangle ${BOOK} IRef.java >${LANG}/IRef.java
tangle ${BOOK} ISeq.java >${LANG}/ISeq.java
C.3. MAKEFILE 1741
tangle ${BOOK} IteratorSeq.java >${LANG}/IteratorSeq.j ava
tangle ${BOOK} ITransientAssociative.java \
>${LANG}/ITransientAssociative.java
tangle ${BOOK} ITransientCollection.java \
>${LANG}/ITransientCollection.java
tangle ${BOOK} ITransientMap.java >${LANG}/ITransientM ap.java
tangle ${BOOK} ITransientSet.java >${LANG}/ITransientS et.java
tangle ${BOOK} ITransientVector.java \
>${LANG}/ITransientVector.java
tangle ${BOOK} Keyword.java >${LANG}/Keyword.java
tangle ${BOOK} KeywordLookupSite.java \
>${LANG}/KeywordLookupSite.java
tangle ${BOOK} LazilyPersistentVector.java \
>${LANG}/LazilyPersistentVector.java
tangle ${BOOK} LazySeq.java >${LANG}/LazySeq.java
tangle ${BOOK} LineNumberingPushbackReader.java \
>${LANG}/LineNumberingPushbackReader.java
tangle ${BOOK} LineNumberingPushbackReader.java \
>${LANG}/LineNumberingPushbackReader.java
tangle ${BOOK} LispReader.java >${LANG}/LispReader.jav a
tangle ${BOOK} LockingTransaction.java \
>${LANG}/LockingTransaction.java
tangle ${BOOK} MapEntry.java >${LANG}/MapEntry.java
tangle ${BOOK} MapEquivalence.java >${LANG}/MapEquival ence.java
tangle ${BOOK} MethodImplCache.java \
>${LANG}/MethodImplCache.java
tangle ${BOOK} MultiFn.java >${LANG}/MultiFn.java
tangle ${BOOK} Named.java >${LANG}/Named.java
tangle ${BOOK} Namespace.java >${LANG}/Namespace.java
tangle ${BOOK} Numbers.java >${LANG}/Numbers.java
tangle ${BOOK} Obj.java >${LANG}/Obj.java
tangle ${BOOK} PersistentArrayMap.java \
>${LANG}/PersistentArrayMap.java
tangle ${BOOK} PersistentHashMap.java \
>${LANG}/PersistentHashMap.java
tangle ${BOOK} PersistentHashSet.java \
>${LANG}/PersistentHashSet.java
tangle ${BOOK} PersistentList.java >${LANG}/Persistent List.java
tangle ${BOOK} PersistentQueue.java \
>${LANG}/PersistentQueue.java
tangle ${BOOK} PersistentStructMap.java \
>${LANG}/PersistentStructMap.java
tangle ${BOOK} PersistentTreeMap.java \
>${LANG}/PersistentTreeMap.java
tangle ${BOOK} PersistentTreeSet.java \
>${LANG}/PersistentTreeSet.java
tangle ${BOOK} PersistentVector.java \
>${LANG}/PersistentVector.java
tangle ${BOOK} ProxyHandler.java >${LANG}/ProxyHandler .java
tangle ${BOOK} Range.java >${LANG}/Range.java
1742 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
tangle ${BOOK} Ratio.java >${LANG}/Ratio.java
tangle ${BOOK} Ref.java >${LANG}/Ref.java
tangle ${BOOK} Reflector.java >${LANG}/Reflector.java
tangle ${BOOK} Repl.java >${LANG}/Repl.java
tangle ${BOOK} RestFn.java >${LANG}/RestFn.java
tangle ${BOOK} Reversible.java >${LANG}/Reversible.jav a
tangle ${BOOK} RT.java >${LANG}/RT.java
tangle ${BOOK} Script.java >${LANG}/Script.java
tangle ${BOOK} Seqable.java >${LANG}/Seqable.java
tangle ${BOOK} SeqEnumeration.java >${LANG}/SeqEnumera tion.java
tangle ${BOOK} SeqIterator.java >${LANG}/SeqIterator.j ava
tangle ${BOOK} Sequential.java >${LANG}/Sequential.jav a
tangle ${BOOK} Settable.java >${LANG}/Settable.java
tangle ${BOOK} Sorted.java >${LANG}/Sorted.java
tangle ${BOOK} StringSeq.java >${LANG}/StringSeq.java
tangle ${BOOK} Symbol.java >${LANG}/Symbol.java
tangle ${BOOK} TransactionalHashMap.java \
>${LANG}/TransactionalHashMap.java
tangle ${BOOK} Util.java >${LANG}/Util.java
tangle ${BOOK} Var.java >${LANG}/Var.java
tangle ${BOOK} XMLHandler.java >${LANG}/XMLHandler.jav a
tangle ${BOOK} main.java >${MAIN}/main.java
tangle ${BOOK} test/test_clojure.clj >${TESTA}/test_cl ojure.clj
tangle ${BOOK} test/test_helper.clj >${TESTA}/test_hel per.clj
tangle ${BOOK} test/agents.clj >${TESTC}/agents.clj
tangle ${BOOK} test/annotations.clj >${TESTC}/annotati ons.clj
tangle ${BOOK} test/atoms.clj >${TESTC}/atoms.clj
tangle ${BOOK} test/clojure_set.clj >${TESTC}/clojure_ set.clj
tangle ${BOOK} test/clojure_xml.clj >${TESTC}/clojure_ xml.clj
tangle ${BOOK} test/clojure_zip.clj >${TESTC}/clojure_ zip.clj
tangle ${BOOK} test/compilation.clj >${TESTC}/compilat ion.clj
tangle ${BOOK} test/control.clj >${TESTC}/control.clj
tangle ${BOOK} test/data.clj >${TESTC}/data.clj
tangle ${BOOK} test/data_structures.clj \
>${TESTC}/data_structures.clj
tangle ${BOOK} test/def.clj >${TESTC}/def.clj
tangle ${BOOK} test/errors.clj >${TESTC}/errors.clj
tangle ${BOOK} test/evaluation.clj >${TESTC}/evaluatio n.clj
tangle ${BOOK} test/for.clj >${TESTC}/for.clj
tangle ${BOOK} test/genclass.clj >${TESTC}/genclass.cl j
tangle ${BOOK} test/java_interop.clj >${TESTC}/java_in terop.clj
tangle ${BOOK} test/keywords.clj >${TESTC}/keywords.cl j
tangle ${BOOK} test/logic.clj >${TESTC}/logic.clj
tangle ${BOOK} test/macros.clj >${TESTC}/macros.clj
tangle ${BOOK} test/main.clj >${TESTC}/main.clj
tangle ${BOOK} test/metadata.clj >${TESTC}/metadata.cl j
tangle ${BOOK} test/multimethods.clj >${TESTC}/multime thods.clj
tangle ${BOOK} test/ns_libs.clj >${TESTC}/ns_libs.clj
tangle ${BOOK} test/numbers.clj >${TESTC}/numbers.clj
tangle ${BOOK} test/other_functions.clj \
C.3. MAKEFILE 1743
>${TESTC}/other_functions.clj
tangle ${BOOK} test/parallel.clj >${TESTC}/parallel.cl j
tangle ${BOOK} test/pprint.clj >${TESTC}/pprint.clj
tangle ${BOOK} test/predicates.clj >${TESTC}/predicate s.clj
tangle ${BOOK} test/printer.clj >${TESTC}/printer.clj
tangle ${BOOK} test/protocols.clj >${TESTC}/protocols. clj
tangle ${BOOK} test/reader.clj >${TESTC}/reader.clj
tangle ${BOOK} test/reflect.clj >${TESTC}/reflect.clj
tangle ${BOOK} test/refs.clj >${TESTC}/refs.clj
tangle ${BOOK} test/repl.clj >${TESTC}/repl.clj
tangle ${BOOK} test/rt.clj >${TESTC}/rt.clj
tangle ${BOOK} test/sequences.clj >${TESTC}/sequences. clj
tangle ${BOOK} test/serialization.clj >${TESTC}/serial ization.clj
tangle ${BOOK} test/special.clj >${TESTC}/special.clj
tangle ${BOOK} test/string.clj >${TESTC}/string.clj
tangle ${BOOK} test/test.clj >${TESTC}/test.clj
tangle ${BOOK} test/test_fixtures.clj >${TESTC}/test_f ixtures.clj
tangle ${BOOK} test/transients.clj >${TESTC}/transient s.clj
tangle ${BOOK} test/vars.clj >${TESTC}/vars.clj
tangle ${BOOK} test/vectors.clj >${TESTC}/vectors.clj
tangle ${BOOK} test/java_5.clj >${TESTD}/java_5.clj
tangle ${BOOK} test/java_6_and_later.clj \
>${TESTD}/java_6_and_later.clj
tangle ${BOOK} test/examples.clj >${TESTE}/examples.cl j
tangle ${BOOK} test/io.clj >${TESTF}/io.clj
tangle ${BOOK} test/javadoc.clj >${TESTF}/javadoc.clj
tangle ${BOOK} test/shell.clj >${TESTF}/shell.clj
tangle ${BOOK} test/test_cl_format.clj \
>${TESTG}/test_cl_format.clj
tangle ${BOOK} test1/test_helper.clj >${TESTG}/test_he lper.clj
tangle ${BOOK} test/test_pretty.clj >${TESTG}/test_pre tty.clj
tangle ${BOOK} test1/examples.clj >${TESTH}/examples.c lj
tangle ${BOOK} test/more_examples.clj >${TESTH}/more_e xamples.clj
tangle ${BOOK} test/example.clj >${TESTI}/example.clj
( cd ${WHERE} ; ant )
latex clojure.pamphlet
makeindex clojure.idx
latex clojure.pamphlet
dvipdf clojure.dvi
xpdf clojure.pdf &
java -cp tpd/clojure.jar clojure.main
clean:
rm -f *.ilg
rm -f *.ind
rm -f *.out
rm -f *.aux
rm -f *.dvi
rm -f *.idx
rm -f *.log
1744 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
rm -f *~
rm -f *.ps
rm -f *.tex
rm -f *.toc
rm -f *.pdf
———-
C.4 The tangle function in Clojure
This is the tangle function written in Clojure. It would be useful to mo dify
the reader to directly extract source code from literate documen ts. That would
make literate documents a native ﬁle format for Clojure.
C.4.1 Author and License
Timothy Daly (daly@axiom-developer.org)
License: Public Domain
C.4.2 Abstract and Use Cases
DonKnuthhasdeﬁnedliterateprogrammingasacombinationofdocu mentation
and source code in a single ﬁle. The TeX language is documented this wa y in
books. Knuth deﬁned two functions
•tangle -¿ extract the source code from a literate ﬁle
•weave -¿ extract the latex from a literate ﬁle
This seems unnecessarily complex. Latex is a full programming langua ge and
is capable of deﬁning “environments” that can handle code directly in Latex.
Here we deﬁne the correct environment macros. Thus, the “weav e” function is
not needed.
If this “tangle” function were added to Clojure then Clojure could r ead literate
ﬁles in Latex format and extract the code. We create the necessa ry ”tangle”
function here.
This program will extract the source code from a literate ﬁle.
A literate lisp ﬁle contains a mixture of latex and lisp sources code. The ﬁle
is intended to be in standard latex format. In order to delimit code ch unks we
deﬁne a latex “chunk” environment.
C.4. THE TANGLE FUNCTION IN CLOJURE 1745
Latex format ﬁles deﬁnes a newenvironment so that code chunks c an be delim-
ited by\begin{chunk}{name} ...\end{chunk} blocks. This is supported by the
following latex code.
So a trivial example of a literate latex ﬁle might look like
this is a file that is in a literate
form it has a chunk called
\begin{chunk}{first chunk}
THIS IS THE FIRST CHUNK
\end{chunk}
and this is a second chunk
\begin{chunk}{second chunk}
THIS IS THE SECOND CHUNK
\end{chunk}
and this is more in the first chunk
\begin{chunk}{first chunk}
\getchunk{second chunk}
THIS IS MORE IN THE FIRST CHUNK
\end{chunk}
\begin{chunk}{all}
\getchunk{first chunk}
\getchunk{second chunk}
\end{chunk}
and that’s it
From a ﬁle called “testcase” that contains the above text we want t o extract
the chunk names “second chunk”. We do this with:
(tangle "testcase" "second chunk")
which yields:
THIS IS THE SECOND CHUNK
From the same ﬁle we might extract the chunk named “ﬁrst chunk”. Notice
that this has the second chunk embedded recursively inside. So we e xecute:
(tangle "testcase" "first chunk")
which yields:
THIS IS THE FIRST CHUNK
THIS IS THE SECOND CHUNK
THIS IS MORE IN THE FIRST CHUNK
There is a third chunk called “all” which will extract both chunks:
1746 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
(tangle "testcase" "all")
which yields
THIS IS THE FIRST CHUNK
THIS IS THE SECOND CHUNK
THIS IS MORE IN THE FIRST CHUNK
THIS IS THE SECOND CHUNK
The tangle function takes a third argument which is the name of an ou tput ﬁle.
Thus, you can write the same results to a ﬁle with:
(tangle "testcase" "all" "outputfile")
It is also worth noting that all chunks with the same name will be merge d into
one chunk so it is possible to split chunks in mulitple parts and have them
extracted as one. That is,
\begin{chunk}{a partial chunk}
part 1 of the partial chunk
\end{chunk}
not part of the chunk
\begin{chunk}{a partial chunk}
part 2 of the partial chunk
\end{chunk}
These will be combined on output as a single chunk. Thus
(tangle "testmerge" "a partial chunk")
will yield
part 1 of the partial chunk
part 2 of the partial chunk
C.4.3 The Latex Support Code
The verbatim package quotes everything within its grasp and is used to hide
and quote the source code during latex formatting. The verbatim e nvironment
is built in but the package form lets us use it in our chunk environment a nd it
lets us change the font.
\usepackage{verbatim}
Make the verbatim font smaller Note that we have to temporarily cha nge the
’@’to be just a character because the @fontname uses it as a character
C.4. THE TANGLE FUNCTION IN CLOJURE 1747
\chardef\atcode=\catcode‘\@
\catcode‘\@=11
\renewcommand{\verbatim@font}{\ttfamily\small}
\catcode‘\@=\atcode
Thisdeclaresanewenvironmentnamed“chunk”whichhasoneargum entthatis
the name of the chunk. All code needs to live between the \begin{chunk}{name}
and the\end{chunk} The “name” is used to deﬁne the chunk. Reuse of the same
chunk name later concatenates the chunks
For those of you who can’t read latex this says: Make a new environm ent named
chunkwith oneargumentThe ﬁrstblockisthe code forthe \begin{chunk}{name}
The second block is the code for the \end{chunk} The%is the latex comment
character
We have two alternate markers, a lightweight one using dashes and a heavy-
weight one using the \beginand\endsyntax You can choose either one by
changing the comment char in column 1
\newenvironment{chunk}[1]{% we need the chunkname as an ar gument
{\ }\newline\noindent% make sure we are in column 1
%{\small $\backslash{}$begin\{chunk\}\{{\bf #1}\}}% al ternate begin mark
\hbox{\hskip 2.0cm}{\bf --- #1 ---}% mark the beginning
\verbatim}% say exactly what we see
{\endverbatim% process \end{chunk}
\par{}% we add a newline
\noindent{}% start in column 1
\hbox{\hskip 2.0cm}{\bf ----------}% mark the end
%$\backslash{}$end\{chunk\}% alternate end mark (commen ted)
\par% and a newline
\normalsize\noindent}% and return to the document
This declares the place where we want to expand a chunk Technically w e don’t
need this because a getchunk must always be properly nested within a chunk
and will be verbatim.
\providecommand{\getchunk}[1]{%
\noindent%
{\small $\backslash{}$begin\{chunk\}\{{\bf #1}\}}}% ma rk the reference
C.4.4 Imports
— Clojure tangle —
(import [java.io BufferedReader FileReader BufferedWrit er FileWriter])
(import [java.lang String])
1748 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
———-
C.4.5 The Tangle Command
The tangle command does all of the work of extracting code.
In latex form the code blocks are delimited by
\begin{chunk}{name}
... (code for name)...
\end{chunk}
and referenced by \getchunk{name} which gets replaced by the code
There are several ways to invoke the tangle function.
The ﬁrst argument is always the ﬁle from which to extract code
The second argument is the name of the chunk to extract
(tangle "clweb.pamphlet" "name")
The standard chunk name is “*” but any name can be used.
The third arument is the name of an output ﬁle:
(tangle "clweb.pamphlet" "clweb.chunk" "clweb.spadfile ")
C.4.6 The say function
This function will either write to the output ﬁle, or if null, to the conso le
— Clojure tangle —
(defn say [where what]
(if where
(do (.write where what) (.write where "\n"))
(println what)))
———-
C.4.7 The read-ﬁle function
Here we return a lazy sequence that will fetch lines as we need them f rom the
ﬁle.
— Clojure tangle —
C.4. THE TANGLE FUNCTION IN CLOJURE 1749
(defn read-file [streamname]
^{:doc "Implement read-sequence in GCL"}
(let [stream (BufferedReader. (FileReader. streamname)) ]
(line-seq stream)))
———-
C.4.8 The ischunk function
There is a built-in assumption (in the ischunk functions) that the chu nks occur
onseparatelinesandthattheindentationofthechunkreference hasnomeaning.
The ischunk function recognizes chunk names in latex convention
There are 3 cases to recognize:
\begin{chunk}{thechunkname} ==> ’define thechunkname
\end{chunk} ==> ’end nil
\getchunk{thechunkname} ==> ’refer thechunkname
The regex pattern #"^\\begin\{chunk\}\{.*\}$" matches
\begin{chunk}{anything here}
The regex pattern #"^\\end\{chunk\}$" matches
\end{chunk}
The regex pattern #"^\\getchunk\{.*\}$" matches
\getchunk{anything here}
— Clojure tangle —
(defn ischunk [line]
^{:doc "Find chunks delimited by latex syntax"}
(let [ begin #"^\\begin\{chunk\}\{.*\}$"
end #"^\\end\{chunk\}$"
get #"^\\getchunk\{.*\}$"
trimmed (.trim line) ]
(cond
(re-find begin trimmed)
(list ’define (apply str (butlast (drop 14 trimmed))))
(re-find end trimmed)
(list ’end nil)
(re-find get trimmed)
(list ’refer trimmed)
:else
(list nil trimmed))))
———-
1750 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
C.4.9 The haschunks function
The hashchunks function gathers the chunks and puts them in the hash table
If we ﬁnd the chunk syntax and it is a
•deﬁne ==¿ parse the chunkname and start gathering lines onto a st ack
•end ==¿ push the completed list of lines into a stack of chunks already in
the hash table
•otherwise ==¿ if we are gathering, push the line onto the stack
A hash table entry is a list of lists such as
(("6" "5") ("4" "3") ("2" "1"))
each of the sublists is a set of lines in reverse(stack) order each su blist is a single
chunk of lines. There is a new sublist for each reuse of the same chun kname
Calls to ischunk can have 4 results (deﬁne, end, refer, nil) where
•deﬁne == >we found a \begin{chunk}{...}
•end ==>we found a \end{chunk}
•refer == >we found a \getchunk{...}
•nil ==>ordinary text or program text
The variable gather is initially false, implying that we are not gathering c ode.
The variable gather is true if we are gathering a chunk.
— Clojure tangle —
(defn hashchunks [lines]
^{:doc "Gather all of the chunks and put them into a hash table "}
(loop [ line lines
gather false
hash (hash-map)
chunkname "" ]
(if (not (empty? line))
(let [[key value] (ischunk (first line))]
(condp = key
’define
(recur (rest line) true hash value)
’end
(recur (rest line) false hash chunkname)
’refer
(if gather
(recur (rest line) gather
(assoc hash chunkname
(conj (get hash chunkname) value)) chunkname)
C.4. THE TANGLE FUNCTION IN CLOJURE 1751
(recur (rest line) gather hash chunkname))
nil
(if gather
(recur (rest line) gather
(assoc hash chunkname
(conj (get hash chunkname) value)) chunkname)
(recur (rest line) gather hash chunkname))))
hash)))
———-
C.4.10 The expand function
The expand function will recursively expand chunks in the hash table .
Latex chunk names are just the chunkname itself e.g. chunkname
A hash table key is the chunk name and the value is a reverse list of all o f the
text in that chunk. To process the chunk we reverse the main list an d for each
sublist we reverse the sublist and process the lines
If a chunk name reference is encountered in a line we call expand rec ursively to
expand the inner chunkname.
— Clojure tangle —
(defn expand [chunkname where table]
^{:doc recursively expand latex getchunk tags}
(let [chunk (reverse (get table chunkname))]
(when chunk
(loop [lines chunk]
(when (not (empty? lines))
(let [line (first lines)]
(let [[key value] (ischunk line)]
(if (= key ’refer)
(do
(expand (apply str (butlast (drop 10 value))) where table)
(recur (rest lines)))
(do (say where line)
(recur (rest lines)))))))))))
———-
C.4.11 The tangle function
We expand all of the lines in the ﬁle that are surrounded by the reque sted chunk
name. These chunk names are looked up in the hash table built by hash chunks,
1752 APPENDIX C. BUILDING CLOJURE FROM THIS DOCUMENT
given the input ﬁlename. then we recursively expand the “topchunk ” to the
output stream
— Clojure tangle —
(defn tangle
^{:doc "Extract the source code from a pamphlet file,
optional file output"}
([filename topchunk] (tangle filename topchunk nil))
([filename topchunk file]
(if (string? file)
(with-open [where (BufferedWriter. (FileWriter. file))]
(expand topchunk where (hashchunks (read-file filename)) ))
(expand topchunk nil (hashchunks (read-file filename)))) ))
———-
Bibliography
[Bag00] Bagwell, Phil
“Fast and space eﬃcient trie searches”
Technical Report EPFL (2000)
http://lampwww.epfl.ch/papers/triesearches.pdf.gz
[Bag01] Bagwell, Phil
“Ideal Hash Trees”
Es Grands Champs (2001)
[Dal10] Daly, Timothy,
“Knuth’s literate programming ”tangle” function in Clojure”
groups.google.com/group/clojure
thread/browse_thread/thread/664a1d305f32ab90
[Dev12] Devlin, Sean
“Full Disclojure”
vimeo.com/channels/fulldisclojure
[DSST89] Driscoll, James; Sarnak, Neil; Sleator, Daniel; Tarjan, Rob ert
“Making Data Structures Persistent”
Journal of Computer and System Sciences 38, 86-124 (1989)
[Hal11] Halloway, Stuart
“Clojure Java Interop”
www.infoq.com/presentations/Clojure-Java-Interop
[Har05] Harper, Robert
“Programming in Standard ML”
www.cs.cmu.edu/~rwh/smlbook/online.pdf
[Hic10] Hickey, Rich
“Persistent Data Structures and Managed References”
[King13] Kingsbury, Kyle
“Clojure from the ground up”
1753
1754 BIBLIOGRAPHY
aphyr.com/posts/301-clojure-from-the-ground-up-welc ome
aphyr.com/posts/302-clojure-from-the-ground-up-basi c-types
[Knu84] Knuth, Donald
“Literate Programming (1984)”
Literate Programming CSLI, p99
[L13] L´ orange, Jean Niklas
“Understand Clojure’s Persistent Vectors”
hypirion.com/musings/understanding-persistent-vecto r-pt-1
hypirion.com/musings/understanding-persistent-vecto r-pt-2
[Oka98] Okasaki, Chris
“Purely Functional Data Structures”
Cambridge University Press (1998) ISBN 0-521-66350-4
[Ora11] Oracle
“java.lang.String class”
download.oracle.com/javase/1.4.2/docs/api/java/lang /String.html
[Que94] Queinnec, Christian
“Lisp in Small Pieces”
Cambridge University Press (1994) ISBN 0-521-56247-3
[Ste09] Steele, Guy
“Organizing Functional Code for Execution”
vimeo.com/6624203
[Ste11] Steele, Guy
“How to Think about Parallel Programming, Not!”
International Coonference on Functional Programming (ICFP) E dinburgh
(2009)
www.infoq.com/presentations/Thinking-Parallel-Progr amming
[Web11] Web
“Clojure’s unconventional symbols”
arcanesentiment.blogspot.com/2011/01/clojures-uncon ventional-symbols.html
[Wiki] Wikipedia
“Red-black tree”
en.wikipedia.org/wiki/Red-black_tree
[Wiki1] Wikipedia
“The ML programming language”
en.wikipedia.org/wiki/ML_(programming language)
[1] Wu, Kai
“An example of literate programming in Clojure”
limist.com/coding/an-example-of-literate-programmin g-in-clojure-using-emacsorg.html
Index
•AbstractMap, 1723
extended by 1145, 1145
Class, 1723
•AdviceAdapter, 413
extends 453, 413
implements 387, 413
Class, 413
•AFn, 509
extended by 519, 519
extended by 530, 530
extended by 538, 538
extended by 541, 541
extended by 579, 579
extended by 581, 581
extended by 82, 82
extended by 81, 81
extended by 74, 74
extended by 89, 89
extended by 83, 83
extended by 87, 87
extended by 86, 86
extended by 80, 80
extended by 81, 81
extended by 75, 75
extended by 852, 852
extended by 85, 85
extended by 87, 87
extended by 72, 72
extended by 1143, 1143
extended by 76, 76
extended by 80, 80
extended by 79, 79
extended by 89, 89
extended by 85, 85
extended by 80, 80
extended by 74, 74
implements 774, 509
Class, 509
•AFunction, 519
extended by 1055, 1055
extends 509, 519
implements 1723, 519
implements 772, 519
1755
1756 BIBLIOGRAPHY
implements 800, 519
implements 1723, 519
Class, 519
•Agent, 520
extends 553, 520
Class, 520
•AMapEntry, 527
extended by 850, 850
extended by 41, 41
extends 541, 527
implements 798, 527
Class, 527
•AnalyzerAdapter, 426
extends 314, 426
Class, 426
•AnnotationVisitor, 163
implemented by 165, 165
implemented by 449, 449
Interface, 163
•AnnotationWriter, 165
implements 163, 165
Class, 165
•APersistentMap, 530
extended by 995, 995
extended by 1000, 1000
extends 509, 530
implements 801, 530
implements 1723, 530
implements 850, 530
implements 1723, 530
implements 1723, 530
Class, 530
•APersistentSet, 538
extended by 980, 980
extended by 1012, 1012
extends 509, 538
implements 1723, 538
implements 802, 538
implements 1723, 538
implements 1723, 538
Class, 538
•APersistentVector, 541
extended by 527, 527
extended by 1014, 1014
extends 509, 541
BIBLIOGRAPHY 1757
implements 1723, 541
implements 802, 541
implements 1723, 541
implements 1723, 541
implements 1723, 541
implements 1723, 541
Class, 541
•ARef, 553
extended by 520, 520
extended by 577, 577
extended by 1034, 1034
extended by 1152, 1152
extends 552, 553
implements 805, 553
Class, 553
•AReference, 552
extended by 553, 553
extended by 861, 861
implements 804, 552
Class, 552
•ArgReader, 71
extends 509, 82
•ArgReader, class in 825, 82
•ArityException, 556
extends 1723, 556
Class, 556
•ArrayChunk, 556
implements 772, 556
implements 1723, 556
Class, 556
•ArrayNode, 58
implements 58, 955
•ArrayNode, class in 969, 955
•ArrayNode.ﬁnd, 58
•ArraySeq, 558
extends 571, 558
implements 804, 558
implements 799, 558
Class, 558
•ASeq, 571
extended by 558, 558
extended by 586, 586
extended by 766, 766
extended by 770, 770
extended by 806, 806
1758 BIBLIOGRAPHY
extended by 982, 982
extended by 1000, 60
extended by 1031, 1031
extended by 1141, 1141
extends 947, 571
implements 805, 571
implements 1723, 571
implements 1723, 571
Class, 571
•Associative, 100, 576
extended by 801, 801
extended by 802, 802
extends 797, 576
extends 800, 576
Interface, 576
•Atom, 577
extends 553, 577
Class, 577
•ATransientMap, 579
extends 509, 579
implements 808, 579
Class, 579
•ATransientSet, 581
extends 509, 581
implements 809, 581
Class, 581
•Attribute, 171
Class, 171
•balanceLeftDel, method in 1000, 53
•balanceRightDel, method in 1000, 52
•BigDecimal, 63
Class, 63
•BigInt, 582
extends 1723, 582
Class, 582
•BigInteger, 63
Class, 63
•Binding, 585
Class, 585
•bit-partitioning, 135
•BitmapIndexedNode, 59
implements 58, 959
•BitmapIndexedNode, class in 969, 959
•Black
BIBLIOGRAPHY 1759
extended by 44, 44
extended by 43, 43
extends 41, 42
•black, 42–45
•Black, class in 1000, 42
•black, method in 1000, 45
•BlackBranch
extended by 45, 45
extends 42, 44
•BlackBranch, class in 1000, 44
•BlackBranchVal
extends 44, 45
•BlackBranchVal, class in 1000, 45
•BlackVal
extends 42, 43
•BlackVal, class in 1000, 43
•Boolean, 63
Class, 63
•Box, 585
Class, 585
•ByteVector, 176
Class, 176
•Callable, 1723
extended by 774, 774
Interface, 1723
•CancellationException, 97
•Character, 63
Class, 63
•CharacterReader, 71
extends 509, 81
•CharacterReader, class in 825, 81
•ChunkBuﬀer, 586
implements 768, 586
Class, 586
•ChunkedCons, 586
extends 571, 586
implements 773, 586
Class, 586
•Class
AbstractMap, 1723
AdviceAdapter, 413
AFn, 509
AFunction, 519
1760 BIBLIOGRAPHY
Agent, 520
AMapEntry, 527
AnalyzerAdapter, 426
AnnotationWriter, 165
APersistentMap, 530
APersistentSet, 538
APersistentVector, 541
ARef, 553
AReference, 552
ArgReader in 825, 82
ArityException, 556
ArrayChunk, 556
ArrayNode in 969, 955
ArraySeq, 558
ASeq, 571
Atom, 577
ATransientMap, 579
ATransientSet, 581
Attribute, 171
BigDecimal, 63
BigInt, 582
BigInteger, 63
Binding, 585
BitmapIndexedNode in 969, 959
Black in 1000, 42
BlackBranch in 1000, 44
BlackBranchVal in 1000, 45
BlackVal in 1000, 43
Boolean, 63
Box, 585
ByteVector, 176
Character, 63
CharacterReader in 825, 81
ChunkBuﬀer, 586
ChunkedCons, 586
ClassAdapter, 183
ClassReader, 185
ClassWriter, 233
CodeSizeEvaluator, 445
CommentReader in 825, 74
Compile, 588
Compiler, 590
Cons, 766
DefaultHandler, 1723
Delay, 768
DiscardReader in 825, 89
BIBLIOGRAPHY 1761
DispatchReader in 825, 83
Double, 63
DynamicClassLoader, 769
Edge, 262
EmptyVisitor, 449
EnumerationSeq, 770
EvalReader in 825, 87
FieldWriter, 264
FnReader in 825, 86
Frame, 269
GeneratorAdapter, 453
Handler, 300
HashCollisionNode in 969, 965
IllegalArgumentException, 1723
Item, 301
IteratorSeq, 806
KeyIterator in 1000, 103
Keyword, 810
KeywordLookupSite, 816
Label, 305
LazilyPersistentVector, 817
LazySeq, 818
LineNumberingPushbackReader, 823
LispReader, 825
ListReader in 825, 80
LocalVariablesSorter, 484
LockingTransaction, 836
Long, 63
main, 1167
MapEntry, 850
MapReader in 825, 81
MetaReader in 825, 75
Method, 491
MethodAdapter, 314
MethodImplCache, 851
MethodWriter, 326
MultiFn, 852
Namespace, 861
Node, 41
NodeIterator in 1000, 103
Number, 1723
Obj, 947
Pattern, 63
PersistentArrayMap, 948
PersistentHashMap, 969
PersistentHashSet, 980
1762 BIBLIOGRAPHY
PersistentList, 982
PersistentQueue, 989
PersistentStructMap, 995
PersistentTreeMap, 1000
PersistentTreeSet, 1012
PersistentVector, 1014
ProxyHandler, 1030
PushbackReader, 1723
Range, 1031
Ratio, 1033
Red in 1000, 46
RedBranch in 1000, 48
RedBranchVal in 1000, 49
RedVal in 1000, 47
Ref, 1034
Reﬂector, 1044
RegexReader in 825, 85
Repl, 1054
RestFn, 1055
RT, 1094
Script, 1138
Seq in 1000, 60
SeqEnumeration, 1138
SeqIterator, 1139
SerialVersionUIDAdder, 496
SetReader in 825, 87
StaticInitMerger, 506
String, 63
StringReader in 825, 72
StringSeq, 1141
Symbol, 1143
SyntaxQuoteReader in 825, 76
TransactionalHashMap, 1145
Type, 394
UnmatchedDelimiterReader in 825, 80
UnquoteReader in 825, 79
UnreadableReader in 825, 89
URLClassLoader, 1723
Util, 1149
ValIterator in 1000, 104
Var, 1152
VarReader in 825, 85
VectorReader in 825, 80
WrappingReader in 825, 74
XMLHandler, 1164
BIBLIOGRAPHY 1763
•ClassAdapter, 183
extended by 496, 496
extended by 506, 506
implements 229, 183
Class, 183
•ClassReader, 185
Class, 185
•ClassVisitor, 229
implemented by 183, 183
implemented by 233, 233
implemented by 449, 449
Interface, 229
•ClassWriter, 233
implements 229, 233
Class, 233
•CodeSizeEvaluator, 445
extends 314, 445
implements 387, 445
Class, 445
•Collection, 1723
implemented by 538, 538
implemented by 989, 989
Interface, 1723
•CommentReader, 71, 84
extends 509, 74
•CommentReader, class in 825, 74
•Comparable, 1723
implemented by 541, 541
implemented by 810, 810
implemented by 1033, 1033
implemented by 1034, 1034
implemented by 1143, 1143
Interface, 1723
•Comparator, 1723
implemented by 519, 519
Interface, 1723
•Compile, 588
Class, 588
•Compiler, 590
implements 387, 590
Class, 590
•ConcurrentMap, 1723
implemented by 1145, 1145
Interface, 1723
1764 BIBLIOGRAPHY
•Cons, 766
extends 571, 766
implements 1723, 766
Class, 766
•Counted, 100, 768
extended by 801, 801
extended by 802, 802
extended by 808, 808
extended by 809, 809
extended by 799, 799
extended by 799, 799
implemented by 586, 586
implemented by 982, 982
implemented by 989, 989
implemented by 1031, 1031
Interface, 768
•DefaultHandler, 1723
extended by 1164, 1164
Class, 1723
•Delay, 768
implements 773, 768
Class, 768
•DiscardReader, 84
extends 509, 89
•DiscardReader, class in 825, 89
•Dispatch Macro Table, 71, 84
•dispatchMacros, 83, 84
•DispatchReader, 72, 83
extends 509, 83
•DispatchReader, class in 825, 83
•Double, 63
Class, 63
•DynamicClassLoader, 769
extends 1723, 769
Class, 769
•Edge, 262
Class, 262
•EmptyVisitor, 449
implements 163, 449
implements 229, 449
implements 263, 449
implements 317, 449
Class, 449
BIBLIOGRAPHY 1765
•Enumeration, 1723
implemented by 1138, 1138
Interface, 1723
•EnumerationSeq, 770
extends 571, 770
Class, 770
•equals, method in 1143, 69
•EvalReader, 84
extends 509, 87
•EvalReader, class in 825, 87
•exceptions, 95, 97
•Extends
AbstractMap, by TransactionalHashMap, 1145
AFn, by AFunction, 519
AFn, by APersistentMap, 530
AFn, by APersistentSet, 538
AFn, by APersistentVector, 541
AFn, by ArgReader, 82
AFn, by ATransientMap, 579
AFn, by ATransientSet, 581
AFn, by CharacterReader, 81
AFn, by CommentReader, 74
AFn, by DiscardReader, 89
AFn, by DispatchReader, 83
AFn, by EvalReader, 87
AFn, by FnReader, 86
AFn, by ListReader, 80
AFn, by MapReader, 81
AFn, by MetaReader, 75
AFn, by MultiFn, 852
AFn, by RegexReader, 85
AFn, by SetReader, 87
AFn, by StringReader, 72
AFn, by Symbol, 1143
AFn, by SyntaxQuoteReader, 76
AFn, by UnmatchedDelimiterReader, 80
AFn, by UnquoteReader, 79
AFn, by UnreadableReader, 89
AFn, by VarReader, 85
AFn, by VectorReader, 80
AFn, by WrappingReader, 74
AFunction, by RestFn, 1055
AMapEntry, by MapEntry, 850
AMapEntry, by Node, 41
APersistentMap, by PersistentStructMap, 995
1766 BIBLIOGRAPHY
APersistentMap, by PersistentTreeMap, 1000
APersistentSet, by PersistentHashSet, 980
APersistentSet, by PersistentTreeSet, 1012
APersistentVector, by AMapEntry, 527
APersistentVector, by PersistentVector, 1014
ARef, by Agent, 520
ARef, by Atom, 577
ARef, by Ref, 1034
ARef, by Var, 1152
AReference, by ARef, 553
AReference, by Namespace, 861
ASeq, by ArraySeq, 558
ASeq, by ChunkedCons, 586
ASeq, by Cons, 766
ASeq, by EnumerationSeq, 770
ASeq, by IteratorSeq, 806
ASeq, by PersistentList, 982
ASeq, by PersistentTreeMap, 60
ASeq, by Range, 1031
ASeq, by StringSeq, 1141
Associative, by IPersistentMap, 801
Associative, by IPersistentVector, 802
Black, by BlackBranch, 44
Black, by BlackVal, 43
BlackBranch, by BlackBranchVal, 45
Callable, by IFn, 774
ClassAdapter, by SerialVersionUIDAdder, 496
ClassAdapter, by StaticInitMerger, 506
Counted, by Indexed, 799
Counted, by IndexedSeq, 799
Counted, by IPersistentMap, 801
Counted, by IPersistentSet, 802
Counted, by ITransientMap, 808
Counted, by ITransientSet, 809
DefaultHandler, by XMLHandler, 1164
GeneratorAdapter, by AdviceAdapter, 413
IDeref, by IRef, 805
IllegalArgumentException, by ArityException, 556
ILookup, by Associative, 576
ILookup, by ITransientAssociative, 807
IMeta, by IObj, 800
IMeta, by IReference, 804
Indexed, by IChunk, 772
Indexed, by IPersistentVector, 802
Indexed, by ITransientVector, 809
IPersistentCollection, by Associative, 576
BIBLIOGRAPHY 1767
IPersistentCollection, by IPersistentSet, 802
IPersistentCollection, by IPersistentStack, 802
IPersistentCollection, by ISeq, 805
IPersistentStack, by IPersistentList, 801
IPersistentStack, by IPersistentVector, 802
ISeq, by IChunkedSeq, 773
ISeq, by IndexedSeq, 799
Iterable, by IPersistentMap, 801
ITransientAssociative, by ITransientMap, 808
ITransientAssociative, by ITransientVector, 809
ITransientCollection, by ITransientAssociative, 807
ITransientCollection, by ITransientSet, 809
LocalVariablesSorter, by GeneratorAdapter, 453
Map.Entry, by IMapEntry, 798
MethodAdapter, by AnalyzerAdapter, 426
MethodAdapter, by CodeSizeEvaluator, 445
MethodAdapter, by LocalVariablesSorter, 484
Node, by Black, 42
Node, by Red, 46
Number, by BigInt, 582
Number, by Ratio, 1033
Obj, by ASeq, 571
Obj, by LazySeq, 818
Obj, by PersistentQueue, 989
PushbackReader, by LineNumberingPushbackReader, 823
Red, by RedBranch, 48
Red, by RedVal, 47
RedBranch, by RedBranchVal, 49
Reversible, by IPersistentVector, 802
Runnable, by IFn, 774
Seqable, by IPersistentCollection, 800
Sequential, by IPersistentList, 801
Sequential, by IPersistentVector, 802
Sequential, by ISeq, 805
Serializable, by INode, 58
URLClassLoader, by DynamicClassLoader, 769
•FieldVisitor, 263
implemented by 449, 449
implemented by 264, 264
Interface, 263
•FieldWriter, 264
implements 263, 264
Class, 264
•ﬁnd, method in 955, 58
•Fn, 772
1768 BIBLIOGRAPHY
implemented by 519, 519
Interface, 772
•FnReader, 84
extends 509, 86
•FnReader, class in 825, 86
•Frame, 269
Class, 269
•future, 97, 98
•GeneratorAdapter, 453
extended by 413, 413
extends 484, 453
Class, 453
•Handler, 300
Class, 300
•HashCollisionNode, 59
implements 58, 965
•HashCollisionNode, class in 969, 965
•IChunk, 772
extends 799, 772
implemented by 556, 556
Interface, 772
•IChunkedSeq, 773
extends 805, 773
implemented by 586, 586
Interface, 773
•IDeref, 773
extended by 805, 805
implemented by 768, 768
Interface, 773
•IEditableCollection, 774
implemented by 948, 948
implemented by 969, 969
implemented by 980, 980
implemented by 1014, 1014
Interface, 774
•IFn, 71, 84, 774
extends 1723, 774
extends 1723, 774
implemented by 509, 509
implemented by 810, 810
implemented by 1034, 1034
implemented by 1152, 1152
Interface, 774
BIBLIOGRAPHY 1769
•IKeywordLookup, 100, 796
Interface, 796
•IllegalArgumentException, 1723
extended by 556, 556
Class, 1723
•IllegalStateException, 95
•ILookup, 100, 797
extended by 576, 576
extended by 807, 807
Interface, 797
•ILookupSite, 797
implemented by 816, 816
Interface, 797
•ILookupThunk, 798
implemented by 816, 816
Interface, 798
•IMapEntry, 798
extends 1723, 798
implemented by 527, 527
Interface, 798
•IMeta, 100, 799
extended by 800, 800
extended by 804, 804
Interface, 799
•Implements
AnnotationVisitor, by AnnotationWriter, 165
AnnotationVisitor, by EmptyVisitor, 449
ClassVisitor, by ClassAdapter, 183
ClassVisitor, by ClassWriter, 233
ClassVisitor, by EmptyVisitor, 449
Collection, by APersistentSet, 538
Collection, by PersistentQueue, 989
Comparable, by APersistentVector, 541
Comparable, by Keyword, 810
Comparable, by Ratio, 1033
Comparable, by Ref, 1034
Comparable, by Symbol, 1143
Comparator, by AFunction, 519
ConcurrentMap, by TransactionalHashMap, 1145
Counted, by ChunkBuﬀer, 586
Counted, by PersistentList, 982
Counted, by PersistentQueue, 989
Counted, by Range, 1031
Enumeration, by SeqEnumeration, 1138
FieldVisitor, by EmptyVisitor, 449
1770 BIBLIOGRAPHY
FieldVisitor, by FieldWriter, 264
Fn, by AFunction, 519
IChunk, by ArrayChunk, 556
IChunkedSeq, by ChunkedCons, 586
IDeref, by Delay, 768
IEditableCollection, by PersistentArrayMap, 948
IEditableCollection, by PersistentHashMap, 969
IEditableCollection, by PersistentHashSet, 980
IEditableCollection, by PersistentVector, 1014
IFn, by AFn, 509
IFn, by Keyword, 810
IFn, by Ref, 1034
IFn, by Var, 1152
ILookupSite, by KeywordLookupSite, 816
ILookupThunk, by KeywordLookupSite, 816
IMapEntry, by AMapEntry, 527
IndexedSeq, by ArraySeq, 558
IndexedSeq, by StringSeq, 1141
INode, by ArrayNode, 955
INode, by BitmapIndexedNode, 959
INode, by HashCollisionNode, 965
InvocationHandler, by ProxyHandler, 1030
IObj, by AFunction, 519
IObj, by Obj, 947
IObj, by PersistentArrayMap, 948
IObj, by PersistentHashMap, 969
IObj, by PersistentHashSet, 980
IObj, by PersistentStructMap, 995
IObj, by PersistentTreeMap, 1000
IObj, by PersistentTreeSet, 1012
IObj, by PersistentVector, 1014
IObj, by Symbol, 1143
IPersistentList, by PersistentList, 982
IPersistentList, by PersistentQueue, 989
IPersistentMap, by APersistentMap, 530
IPersistentSet, by APersistentSet, 538
IPersistentVector, by APersistentVector, 541
IReduce, by ArraySeq, 558
IReduce, by PersistentList, 982
IReduce, by Range, 1031
IRef, by ARef, 553
IRef, by Ref, 1034
IRef, by Var, 1152
IReference, by AReference, 552
ISeq, by ASeq, 571
ISeq, by LazySeq, 818
BIBLIOGRAPHY 1771
Iterable, by APersistentMap, 530
Iterable, by APersistentVector, 541
Iterator, by KeyIterator, 103
Iterator, by NodeIterator, 103
Iterator, by SeqIterator, 1139
Iterator, by ValIterator, 104
ITransientMap, by ATransientMap, 579
ITransientSet, by ATransientSet, 581
List, by APersistentVector, 541
List, by ASeq, 571
List, by LazySeq, 818
List, by PersistentList, 982
Map, by APersistentMap, 530
MapEquivalence, by APersistentMap, 530
MethodVisitor, by EmptyVisitor, 449
MethodVisitor, by MethodAdapter, 314
MethodVisitor, by MethodWriter, 326
Named, by Keyword, 810
Named, by Symbol, 1143
Opcodes, by AdviceAdapter, 413
Opcodes, by CodeSizeEvaluator, 445
Opcodes, by Compiler, 590
RandomAccess, by APersistentVector, 541
Reversible, by PersistentTreeMap, 1000
Reversible, by PersistentTreeSet, 1012
Serializable, by AFunction, 519
Serializable, by APersistentMap, 530
Serializable, by APersistentSet, 538
Serializable, by APersistentVector, 541
Serializable, by ArrayChunk, 556
Serializable, by ASeq, 571
Serializable, by Cons, 766
Serializable, by Keyword, 810
Serializable, by Namespace, 861
Serializable, by Obj, 947
Serializable, by Symbol, 1143
Set, by APersistentSet, 538
Settable, by Var, 1152
Sorted, by PersistentTreeMap, 1000
Sorted, by PersistentTreeSet, 1012
•Indexed, 799
extended by 772, 772
extended by 802, 802
extended by 809, 809
extends 768, 799
1772 BIBLIOGRAPHY
Interface, 799
•IndexedSeq, 799
extends 768, 799
extends 805, 799
implemented by 558, 558
implemented by 1141, 1141
Interface, 799
•INode, 58
extends 1723, 58
implemented by 955, 955
implemented by 959, 959
implemented by 965, 965
Interface, 58
•Interface
AnnotationVisitor, 163
Associative, 576
Callable, 1723
ClassVisitor, 229
Collection, 1723
Comparable, 1723
Comparator, 1723
ConcurrentMap, 1723
Counted, 768
Enumeration, 1723
FieldVisitor, 263
Fn, 772
IChunk, 772
IChunkedSeq, 773
IDeref, 773
IEditableCollection, 774
IFn, 774
IKeywordLookup, 796
ILookup, 797
ILookupSite, 797
ILookupThunk, 798
IMapEntry, 798
IMeta, 799
Indexed, 799
IndexedSeq, 799
INode, 58
InvocationHandler, 1723
IObj, 800
IPersistentCollection, 800
IPersistentList, 801
IPersistentMap, 801
BIBLIOGRAPHY 1773
IPersistentSet, 802
IPersistentStack, 802
IPersistentVector, 802
IPromiseImpl, 803
IProxy, 803
IReduce, 804
IRef, 805
IReference, 804
ISeq, 805
Iterable, 1723
Iterator, 1723
ITransientAssociative, 807
ITransientCollection, 808
ITransientMap, 808
ITransientSet, 809
ITransientVector, 809
List, 1723
Map, 1723
Map.Entry, 1723
MapEquivalence, 850
MethodVisitor, 317
Named, 861
Numbers, 867
Opcodes, 387
RandomAccess, 1723
Reversible, 1094
Runnable, 1723
Seqable, 1140
Sequential, 1140
Serializable, 1723
Set, 1723
Settable, 1140
Sorted, 1141
TableSwitchGenerator, 508
•intern(2), method in 1143, 68
•intern, method in 1143, 67
•InvocationHandler, 1723
implemented by 1030, 1030
Interface, 1723
•IObj, 100, 800
extends 799, 800
implemented by 519, 519
implemented by 947, 947
implemented by 948, 948
implemented by 969, 969
1774 BIBLIOGRAPHY
implemented by 980, 980
implemented by 995, 995
implemented by 1000, 1000
implemented by 1012, 1012
implemented by 1014, 1014
implemented by 1143, 1143
Interface, 800
•IPersistentCollection, 100, 800
extended by 576, 576
extended by 802, 802
extended by 802, 802
extended by 805, 805
extends 1140, 800
Interface, 800
•IPersistentList, 801
extends 802, 801
extends 1140, 801
implemented by 982, 982
implemented by 989, 989
Interface, 801
•IPersistentMap, 100, 801
extends 576, 801
extends 768, 801
extends 1723, 801
implemented by 530, 530
Interface, 801
•IPersistentSet, 802
extends 768, 802
extends 800, 802
implemented by 538, 538
Interface, 802
•IPersistentStack, 802
extended by 801, 801
extended by 802, 802
extends 800, 802
Interface, 802
•IPersistentVector, 802
extends 576, 802
extends 802, 802
extends 799, 802
extends 1094, 802
extends 1140, 802
implemented by 541, 541
Interface, 802
•IPromiseImpl, 803
BIBLIOGRAPHY 1775
Interface, 803
•IProxy, 803
Interface, 803
•IReduce, 804
implemented by 558, 558
implemented by 982, 982
implemented by 1031, 1031
Interface, 804
•IRef, 805
extends 773, 805
implemented by 553, 553
implemented by 1034, 1034
implemented by 1152, 1152
Interface, 805
•IReference, 804
extends 799, 804
implemented by 552, 552
Interface, 804
•ISeq, 805
extended by 773, 773
extended by 799, 799
extends 800, 805
extends 1140, 805
implemented by 571, 571
implemented by 818, 818
Interface, 805
•Item, 301
Class, 301
•Iterable, 1723
extended by 801, 801
implemented by 530, 530
implemented by 541, 541
Interface, 1723
•Iterator, 1723
implemented by 103, 103
implemented by 103, 103
implemented by 1139, 1139
implemented by 104, 104
Interface, 1723
•Iterators, 55
•IteratorSeq, 806
extends 571, 806
Class, 806
•ITransientAssociative, 807
extended by 808, 808
1776 BIBLIOGRAPHY
extended by 809, 809
extends 797, 807
extends 808, 807
Interface, 807
•ITransientCollection, 808
extended by 807, 807
extended by 809, 809
Interface, 808
•ITransientMap, 808
extends 768, 808
extends 807, 808
implemented by 579, 579
Interface, 808
•ITransientSet, 809
extends 768, 809
extends 808, 809
implemented by 581, 581
Interface, 809
•ITransientVector, 809
extends 807, 809
extends 799, 809
Interface, 809
•KeyIterator
implements 1723, 103
•KeyIterator, class in 1000, 103
•Keyword, 810
implements 1723, 810
implements 774, 810
implements 861, 810
implements 1723, 810
Class, 810
•KeywordLookupSite, 816
implements 797, 816
implements 798, 816
Class, 816
•Label, 305
Class, 305
•LazilyPersistentVector, 817
Class, 817
•LazySeq, 818
extends 947, 818
implements 805, 818
implements 1723, 818
Class, 818
BIBLIOGRAPHY 1777
•leftBalance, method in 1000, 54
•LineNumberingPushbackReader, 823
extends 1723, 823
Class, 823
•LispReader, 83, 825
Class, 825
•LispReader.read, 69
•LispReader$ArgReader, 82
•LispReader$CharacterReader, 81
•LispReader$CommentReader, 74
•LispReader$DiscardReader, 89
•LispReader$DispatchReader, 83
•LispReader$EvalReader, 87
•LispReader$FnReader, 86
•LispReader$ListReader, 80
•LispReader$MapReader, 81
•LispReader$MetaReader, 75
•LispReader$RegexReader, 85
•LispReader$SetReader, 87
•LispReader$StringReader, 72
•LispReader$SyntaxQuoteReader, 76
•LispReader$UnmatchedDelimiterReader, 80
•LispReader$UnquoteReader, 79
•LispReader$UnreadableReader, 89
•LispReader$VarReader, 85
•LispReader$VectorReader, 80
•LispReader$WrappingReader, 74
•List, 1723
implemented by 541, 541
implemented by 571, 571
implemented by 818, 818
implemented by 982, 982
Interface, 1723
•ListReader, 71
extends 509, 80
•ListReader, class in 825, 80
•LocalVariablesSorter, 484
extended by 453, 453
extends 314, 484
Class, 484
•LockingTransaction, 836
Class, 836
•Long, 63
1778 BIBLIOGRAPHY
Class, 63
•main, 1167
Class, 1167
•Makeﬁle, i, ii, 1737
•Map, 1723
implemented by 530, 530
Interface, 1723
•Map.Entry, 1723
extended by 798, 798
Interface, 1723
•MapEntry, 850
extends 527, 850
Class, 850
•MapEquivalence, 850
implemented by 530, 530
Interface, 850
•MapReader, 71
extends 509, 81
•MapReader, class in 825, 81
•mask, method in 969, 57
•MetaReader, 71, 84
extends 509, 75
•MetaReader, class in 825, 75
•Method, 491
Class, 491
•MethodAdapter, 314
extended by 426, 426
extended by 445, 445
extended by 484, 484
implements 317, 314
Class, 314
•MethodImplCache, 851
Class, 851
•MethodVisitor, 317
implemented by 449, 449
implemented by 314, 314
implemented by 326, 326
Interface, 317
•MethodWriter, 326
implements 317, 326
Class, 326
•MultiFn, 852
extends 509, 852
Class, 852
BIBLIOGRAPHY 1779
•Named, 861
implemented by 810, 810
implemented by 1143, 1143
Interface, 861
•Namespace, 861
extends 552, 861
implements 1723, 861
Class, 861
•Node, 41
extended by 42, 42
extended by 46, 46
extends 527, 41
Class, 41
•NodeIterator
implements 1723, 103
•NodeIterator, class in 1000, 103
•Number, 1723
extended by 582, 582
extended by 1033, 1033
Class, 1723
•Numbers, 867
Interface, 867
•Obj, 947
extended by 571, 571
extended by 818, 818
extended by 989, 989
implements 800, 947
implements 1723, 947
Class, 947
•Opcodes, 387
implemented by 413, 413
implemented by 445, 445
implemented by 590, 590
Interface, 387
•Pattern, 63
Class, 63
•PersistentArrayMap, 948
implements 774, 948
implements 800, 948
Class, 948
•PersistentHashMap, 57, 969
implements 774, 969
implements 800, 969
Class, 969
1780 BIBLIOGRAPHY
•PersistentHashMap.mask, 57
•PersistentHashMap$ArrayNode, 955
•PersistentHashMap$BitmapIndexedNode, 959
•PersistentHashMap$HashCollisionNode, 965
•PersistentHashSet, 980
extends 538, 980
implements 774, 980
implements 800, 980
Class, 980
•PersistentList, 982
extends 571, 982
implements 768, 982
implements 801, 982
implements 804, 982
implements 1723, 982
Class, 982
•PersistentQueue, 989
extends 947, 989
implements 1723, 989
implements 768, 989
implements 801, 989
Class, 989
•PersistentStructMap, 995
extends 530, 995
implements 800, 995
Class, 995
•PersistentTreeMap, 55, 1000
extends 530, 1000
extends 571, 60
implements 800, 1000
implements 1094, 1000
implements 1141, 1000
Class, 1000
•PersistentTreeMap.balanceLeftDel, 53
•PersistentTreeMap.balanceRightDel, 52
•PersistentTreeMap.black, 45
•PersistentTreeMap.leftBalance, 54
•PersistentTreeMap.red, 50
•PersistentTreeMap.remove, 1000
•PersistentTreeMap.removeRight, 42
•PersistentTreeMap.replace, 55
•PersistentTreeMap.rightBalance, 54
•PersistentTreeMap$Black, 42
•PersistentTreeMap$BlackBranch, 44
BIBLIOGRAPHY 1781
•PersistentTreeMap$BlackBranchVal, 45
•PersistentTreeMap$BlackVal, 43
•PersistentTreeMap$KeyIterator, 103
•PersistentTreeMap$NodeIterator, 103
•PersistentTreeMap$Red, 46
•PersistentTreeMap$RedBranch, 48
•PersistentTreeMap$RedBranchVal, 49
•PersistentTreeMap$RedVal, 47
•PersistentTreeMap$Seq, 60
•PersistentTreeMap$ValIterator, 104
•PersistentTreeSet, 1012
extends 538, 1012
implements 800, 1012
implements 1094, 1012
implements 1141, 1012
Class, 1012
•PersistentVector, 1014
extends 541, 1014
implements 774, 1014
implements 800, 1014
Class, 1014
•promise, 95
•ProxyHandler, 1030
implements 1723, 1030
Class, 1030
•PushbackReader, 1723
extended by 823, 823
Class, 1723
•RandomAccess, 1723
implemented by 541, 541
Interface, 1723
•Range, 1031
extends 571, 1031
implements 768, 1031
implements 804, 1031
Class, 1031
•Ratio, 1033
extends 1723, 1033
implements 1723, 1033
Class, 1033
•read, method in 825, 69
•Red
extended by 48, 48
1782 BIBLIOGRAPHY
extended by 47, 47
extends 41, 46
•red, 46–49
•Red, class in 1000, 46
•red, method in 1000, 50
•RedBranch
extended by 49, 49
extends 46, 48
•RedBranch, class in 1000, 48
•RedBranchVal
extends 48, 49
•RedBranchVal, class in 1000, 49
•RedVal
extends 46, 47
•RedVal, class in 1000, 47
•Ref, 1034
extends 553, 1034
implements 1723, 1034
implements 774, 1034
implements 805, 1034
Class, 1034
•Reﬂector, 1044
Class, 1044
•RegexReader, 84
extends 509, 85
•RegexReader, class in 825, 85
•remove, 52
•remove, method in 1000, 1000
•removeRight, 52
•removeRight, method in 1000, 42
•Repl, 1054
Class, 1054
•replace, method in 1000, 55
•RestFn, 1055
extends 519, 1055
Class, 1055
•Reversible, 1094
extended by 802, 802
implemented by 1000, 1000
implemented by 1012, 1012
Interface, 1094
•rightBalance, method in 1000, 54
•RT, 1094
Class, 1094
BIBLIOGRAPHY 1783
•Runnable, 1723
extended by 774, 774
Interface, 1723
•Script, 1138
Class, 1138
•Seq, class in 1000, 60
•Seqable, 100, 1140
extended by 800, 800
Interface, 1140
•SeqEnumeration, 1138
implements 1723, 1138
Class, 1138
•SeqIterator, 1139
implements 1723, 1139
Class, 1139
•Seqs, 55
•Sequential, 1140
extended by 801, 801
extended by 802, 802
extended by 805, 805
Interface, 1140
•Serializable, 1723
extended by 58, 58
implemented by 519, 519
implemented by 530, 530
implemented by 538, 538
implemented by 541, 541
implemented by 571, 571
implemented by 556, 556
implemented by 766, 766
implemented by 810, 810
implemented by 861, 861
implemented by 947, 947
implemented by 1143, 1143
Interface, 1723
•SerialVersionUIDAdder, 496
extends 183, 496
Class, 496
•Set, 1723
implemented by 538, 538
Interface, 1723
•SetReader, 84
extends 509, 87
•SetReader, class in 825, 87
1784 BIBLIOGRAPHY
•Settable, 1140
implemented by 1152, 1152
Interface, 1140
•Sorted, 1141
implemented by 1000, 1000
implemented by 1012, 1012
Interface, 1141
•StaticInitMerger, 506
extends 183, 506
Class, 506
•String, 63
Class, 63
•StringReader, 71
extends 509, 72
•StringReader, class in 825, 72
•StringSeq, 1141
extends 571, 1141
implements 799, 1141
Class, 1141
•Symbol, 1143
extends 509, 1143
implements 1723, 1143
implements 800, 1143
implements 861, 1143
implements 1723, 1143
Class, 1143
•Symbol.equals, 69
•Symbol.intern, 67
•Symbol.intern(2), 68
•Symbol.toString, 68
•Syntax Macro Table, 72, 83
•SyntaxQuoteReader, 71
extends 509, 76
•SyntaxQuoteReader, class in 825, 76
•TableSwitchGenerator, 508
Interface, 508
•tangle.c, i, 1733
•toString, method in 1143, 68
•TransactionalHashMap, 1145
extends 1723, 1145
implements 1723, 1145
Class, 1145
•Type, 394
BIBLIOGRAPHY 1785
Class, 394
•UnmatchedDelimiterReader, 71
extends 509, 80
•UnmatchedDelimiterReader, class in 825, 80
•UnquoteReader, 71
extends 509, 79
•UnquoteReader, class in 825, 79
•UnreadableReader, 84
extends 509, 89
•UnreadableReader, class in 825, 89
•URLClassLoader, 1723
extended by 769, 769
Class, 1723
•Util, 1149
Class, 1149
•ValIterator
implements 1723, 104
•ValIterator, class in 1000, 104
•Var, 1152
extends 553, 1152
implements 774, 1152
implements 805, 1152
implements 1140, 1152
Class, 1152
•VarReader, 83–85
extends 509, 85
•VarReader, class in 825, 85
•VectorReader, 71
extends 509, 80
•VectorReader, class in 825, 80
•WrappingReader, 71
extends 509, 74
•WrappingReader, class in 825, 74
•XMLHandler, 1164
extends 1723, 1164
Class, 1164

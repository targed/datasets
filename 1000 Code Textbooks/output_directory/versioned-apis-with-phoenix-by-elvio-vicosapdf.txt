Versioned APIswith PhoenixElvio Vicosa
About the authorMy name is Elvio Vicosa and I am a software developer based in Berlin, Germany. I've been working with software for over 10 years and throughout that time, I had the chance to found my own consultancy company, work in one of the greatest consultancy companies in the world, work as consultant in Fortune 500 companies, lead software development teams in small startups and multi-milion companies, join a health-tech startup as CTO.Although I have been using Erlang in the latest years, I discovered (and fall in love with) Elixir one year ago. Since then I am using it whenever it makes sense.You can ﬁnd more information about me and also my writtings about Elixir and Phoenix at http://www.elviovicosa.com.

About	this	bookAre you developing (or planning to develop) an API using Phoenix? If so, this book was written for you.“Versioned APIs with Phoenix” is about different ways of implementing API versioning and how they caneasily be done in Phoenix.This e-book is free. You can find the code samples at https://github.com/elvio/versioned-apis-with-phoenix. It includes the project code and tests.If you find any typo, please send an email to elvio@elviovicosa.com.
IntroductionTo build a house, it’s necessary to go through different phases before stacking the first brick. The architectneeds to pay attention to everything, drawing all the technical details and documenting the architecturedesign.After the drawings are finished, the construction materials need to be chosen and things like the bricktype, the insulation layer, the heating and plumbing systems affect how the house is going to be built.The construction phase starts when the architect gathered all the information and after some time thehouse is (hopefully) finished.What would happen, if after the house is finished, the family that owns the house asks the architect tochange the brick type? What would happen if the family realises that they want an extra floor?On the traditional manufacturing and construction industries, changes like these are not common,because they have prohibitive costs, and usually they are impossible.Software development is often compared with the construction of a house, where a development teamwould be able to forecast and plan all the details involving a project, but it couldn’t be more different.Differently from building a house, software evolves.Doesn’t matter the industry you are in or the programming language you use. If you are developingsoftware, one thing is guaranteed: it will change.
Product	EvolutionImagine you are a member of a software development team. Your company is building a mobileapplication that allows users to add information to their profiles. The application was not released yet.You work in the backend team, responsible for building and deploying the API that will support this mobileapplication.That’s one of the user stories you are going to work on:Scenario: User can set her/his favorite sport---------------------------------------------Given I am a UserAnd I am on my profile screenWhen I select one favorite sport from the sports listThen the item should be shown in my public profileBased on this user story, the backend team decides that storing the favorite sport item as a string in thedatabase is a good approach and communicate that decision to the mobile development team, that will beconsuming the API from the iOS and Android applications.After a couple of weeks the company releases the application and it instantly becomes a huge success. Itis downloaded by millions of people and everyone is happy.User feedback starts popping up and the product team recognizes that one feature is really annoying theusers: they are only able to select one favorite sport, but some of them want to select two or more. Theproduct team shares a user feedback:“Hey. Your app is amazing and I am using it everyday. I just want to let you know that the favorite sportthing is really weird. I love skiing during winter and sailing during summer, so for me it’s impossible tochoose only one. Do you plan supporting multiple favorite sports?”With that in mind, a new user story is prioritized for the next sprint:Scenario: User can set multiple favorite sports-----------------------------------------------Given I am a UserAnd I am on my profile screenWhen I select multiple favorite sports from the sports listThen these items should be shown in my public profileYou and the backend team decide that the best approach is to use an Array, migrating all the existing“favorite_sport” strings to an Array of one element, allowing the users of newer versions to define multiplefavorite sports.
There is one problem though: If you release a new version of the application where the API response isan Array of favorite sports, instead of a String of a single favorite sport, the users using the old version ofthe application won’t be able to show nor set the “favorite sport” item, because the API no longer supportsa single “favorite sport”.To not cause damage to the company, the development team needs to support both the previous versionof the application (used by people who didn’t update yet) and also the new one.
API	versioningVersioning enables an API to response with different content, based on the information sent by the client.As we know, software evolves and sometimes is really hard to keep its backward compatibility. As seenin the previous example, it’s very common to get into situations where the product evolves towards anincompatible version.Versioning your API solves this kind of problem, where a team needs to support variant versions of aproduct at the same time, without having to drop support to old versions, nor compromise futuredevelopment.There are different strategies on how to implement a version-aware API and throughout this book, we aregoing to cover three different strategies:Versioning using a request parameterVersioning using the URLVersioning using the Accept header
A	Phoenix	requestWhen a client performs a request to a Phoenix application, that’s what usually happens:
It starts with the endpoint of the application, that pipes the connection through a number of functions(plugs).Every plug is capable of performing transformations in the connection struct, passing the changedconnection to the next plug down the line.Let’s take a look at a plug example:123456789defmodule MyPlug do  import Plug.Conn  def init(opts), do: opts  def call(conn, _opts) do    assign(conn, :number, 42)  endendThe plug MyPlug sets the value of :number to 42 inside the connection assigns. You can imagine it tosomething similar to this:
The router plug is the last thing in the endpoint. Inside the router, you will find pipelines. A pipeline isbasically a group of plugs, that receives a conn struct, pipes it through the group, returning a conn struct.After passing through the router pipelines, the connection is then dispatched to a controller, where aresponse will be rendered.
Common	codeIn this book, you will see three different strategies to version our API. Independently of the strategy, ourchanges will only affect the routing layer.Bellow you will find the code of the controller and view that we will use throughout the book. These twofiles won’t change and it’s important to understand a bit about them before we continue.Controller12345678910111213defmodule Profiles.UserController do  use Profiles.Web, :controller  alias Profiles.User  def show(%{assigns: %{version: :v1}}=conn, _params) do    user = User.build(:v1)    render conn, "show.v1.json", user: user  end  def show(%{assigns: %{version: :v2}}=conn, _params) do    user = User.build(:v2)    render conn, "show.v2.json", user: user  endendweb/controllers/user_controller.ex - GithubThe UserController is able to handle two versions of the API: v1 and v2. You can see that we usepattern-matching to distinguish between the versions.On line 5 we pattern-match the version :v1, rendering the show.v1.json view on line 7.Something quite similar happens on line 9, this time we pattern-match the version :v2, rendering theshow.v2.json view on line 11.View
123456789101112131415161718defmodule Profiles.UserView do  use Profiles.Web, :view  def render("show.v1.json", %{user: user}) do    %{      id: user.id,      name: user.name,      favorite_sport: Enum.at(user.favorite_sports, 0)    }  end  def render("show.v2.json", %{user: user}) do    %{      id: user.id,      name: user.name,      favorite_sports: user.favorite_sports    }  endendweb/views/user_view.ex - GithubWe saw that depending on the version, the controller will either render the show.v1.json orshow.v2.json view. The view also uses pattern-matching to determine the content that will berendered.On line 4 and 11 we pattern-match the name of the view that was passed by the controller. Whenrendering show.v1.json view, the JSON structure contains the fields:idnamefavorite_sportWhen rendering show.v2.json view, the JSON structure contains the fields:idnamefavorite_sportsAs you can see, both controller and view rely on pattern-matching to render the different versions of theAPI. It means that to have this part of the application working as expected, we need to set the :versionvalue inside the connection assigns, to either :v1 or :v2. It will enable our controller and view to renderthe right version.In the next sections you will see how different strategies of API versioning achieve that.
Versioning	with	request	parameterThe first versioning strategy that we’ll cover is the parameter one. Based on the product changes wepreviously seen, we can imagine the following requests/responses:Requests to version v1$ curl http://localhost:4000/users/1?version=v1{  "name":"John Doe",  "id":1,  "favorite_sport":"Ski"}Requests to version v2$ curl http://localhost:4000/users/1?version=v2{  "name":"John Doe",  "id":1,  "favorite_sports": [    "Ski",    "Sailing"  ]}In this example, the value of the version parameter is used to determine which version the client is ableto handle, therefore rendering a different response to each version.
12345678910111213defmodule Profiles.Router do  use Profiles.Web, :router  pipeline :api do    plug :accepts, ["json"]    plug Profiles.Version, %{"v1" => :v1, "v2" => :v2}  end  scope "/", Profiles do    pipe_through :api    resources "/users", UserController, only: [:show]  endendweb/router.ex - GithubThe web/router.ex file is quite simple and you can see that we have only one scope on line 9. Thisscope uses the api pipeline, that’s present on line 4. This pipeline does two things:Says we are capable of handling JSON, on line 5Executes the plug Profiles.Version on line 6, passing a map to itOnly after executing the pipeline, the router is able to handle the user resource, on line 11.We know that the controller and the view are expecting the :version to be present as part of theconnection assigns value. The code responsible for setting the :version value is can be found in theplug Profiles.Version:123456789defmodule Profiles.Version do  import Plug.Conn  def init(versions), do: versions  def call(%{params: %{"version" => version}}=conn, versions) do    assign(conn, :version, Map.fetch!(versions, version))  endendweb/version.ex - GithubWhen a request is performed, the function call/2 (on line 6) is called, setting the value of :version inthe connection assigns. On line 6 you can see that we pattern-match the request parameters, extractingthe version parameter that was sent by the client (query-string). The versions map (passed by in
web/router.ex on line 6) is used to determine the :version that will be set.Versioning an API using parameters offers the flexibility to easily switch versions and test the API usingthe browser. One thing that you need to take care of, is to never use the version parameter (used in thisexample) in a different context, because it could override the API versioning feature.In the next section, you will see a different strategy, that also brings the flexibility to the API, but that offersa “cleaner” approach.
Versioning	with	URLThis strategy is really common, being used by the most popular public APIs. It offers the same flexibilitywe found in the parameter strategy, but offering a more robust approach.In order to deliver the product changes we had previously discussed, you can imagine this API to look likethe following:Requests to version v1$ curl http://localhost:4000/v1/users/1{  "name":"John Doe",  "id":1,  "favorite_sport":"Ski"}Requests to version v2$ curl http://localhost:4000/v2/users/1{  "name":"John Doe",  "id":1,  "favorite_sports": [    "Ski",    "Sailing"  ]}With this strategy, the client uses the URL to communicate the version it is able to handle. The /v1/...says the client is capable of handling the version :v1. Requests to /v2/... says the client is capable ofhandling the version :v2. Let’s take a look in what the web/router.ex looks like:
1234567891011121314151617181920212223defmodule Profiles.Router do  use Profiles.Web, :router  pipeline :v1 do    plug :accepts, ["json"]    plug Profiles.Version, version: :v1  end  pipeline :v2 do    plug :accepts, ["json"]    plug Profiles.Version, version: :v2  end  scope "/v1", Profiles do    pipe_through :v1    resources "/users", UserController, only: [:show]  end  scope "/v2", Profiles do    pipe_through :v2    resources "/users", UserController, only: [:show]  endendweb/router.ex - GithubThis time we have two scopes:/v1, pipes through the :v1 pipeline/v2, pipes through the :v2 pipelineBoth scopes handle the user resource and similarly to the parameter strategy, the pipeline runs the plugProfiles.Version, that’s the one responsible for setting the :version value in the connectionassigns. You can see on lines 6 and 11 that the :version value passed to the plug is hard-coded. Itwill be used inside the Profiles.Version plug:
12345678910defmodule Profiles.Version do  import Plug.Conn  @versions Application.get_env(:plug, :mimes)  def init(opts), do: opts  def call(conn, opts) do    assign(conn, :version, opts[:version])  endendweb/version.ex - GithubOn line 7, we set the :version value to the connection assigns. The value comes from the option:version that was set in the web/router.ex file.Similarly to the parameter strategy, versioning an API using the URL offers the flexibility to easily switchversions and test the API in the browser. It also makes the version clear to the API consumer, since allrequests will include the version as part of it.In the next section, we will take a look at the last strategy that is covered by this book.
Versioning	with	Accept	headerI personally prefer to use the Accept header when versioning APIs. Without changing the resource URI,you can communicate which version you are interested on and also the format. For example, theapplication/vnd.app.v1+json communicates to our API that we want the :v1 version with a JSONresponse. We could add support to XML responses, defining a header likeapplication/vnd.app.v1+xml.Considering the product changes that we had previously seen, we can imagine our APIrequests/responses look like:Requests to version v1$ curl -H "Accept: application/vnd.app.v1+json" http://localhost:4000/users/1{  "name":"John Doe",  "id":1,  "favorite_sport":"Ski"}Requests to version v2$ curl -H "Accept: application/vnd.app.v2+json" http://localhost:4000/users/1{  "name":"John Doe",  "id":1,  "favorite_sports": [    "Ski",    "Sailing"  ]}The Accept header communicates the version the client is able to support, including also informationabout the format (in this case JSON). In order to get your Phoenix application working with these customheaders, you will need to add the following lines to your config/config.exs file:
config :plug, :mimes, %{  "application/vnd.app.v1+json" => [:v1],  "application/vnd.app.v2+json" => [:v2]}We are registering two mimes: application/vnd.app.v1+json andapplication/vnd.app.v1+json. The first maps to :v1 and the second to :v2. We are going to usethem in our web/router.ex:12345678910111213defmodule Profiles.Router do  use Profiles.Web, :router  pipeline :api do    plug :accepts, [:v1, :v2]    plug Profiles.Version  end  scope "/", Profiles do    pipe_through :api    resources "/users", UserController, only: [:show]  endendweb/router.ex - GithubOn line 5 we make use of our new registered mimes, letting Phoenix know that we only accept :v1 and:v2.To get it working properly, after adding the lines above to your config.exs file, run the followingcommand:$ mix deps.clean plug --build && mix deps.getIt will prevent you from finding errors like this:[info] Running ActivityTracker.Endpoint with Cowboy using http://localhost:4000Interactive Elixir (1.3.1) - press Ctrl+C to exit (type h() ENTER for help)iex(1)> [info] GET /users/1[info] Sent 406 in 39ms...
The same way we used the Profiles.Version custom plug in the previous two strategies, we are alsogoing to use it here:123456789101112defmodule Profiles.Version do  import Plug.Conn  @versions Application.get_env(:plug, :mimes)  def init(opts), do: opts  def call(conn, _opts) do    [accept] = get_req_header(conn, "accept")    {:ok, [version]} = Map.fetch(@versions, accept)    assign(conn, :version, version)  endendweb/version.ex - GithubOn line 3 we set @versions with the map we defined in the config/config.exs file, where we mapdifferent mimes to a specific version (either :v1 or :v2). When a request is performed, we extract thevalue of the Accept header on line 8 and then we use the @versions map to get the version the valuemaps to.Differently from the previous two strategies, this one doesn’t offer you the flexibility to test the API usingthe browser (unless you use an advanced extension). Besides that, I prefer this strategy when workingwith APIs, because in my opinion it looks cleaner.
ConclusionIn this book we covered three different approaches on how to version an API using the Phoenixframework. There’s no right or wrong way, each strategy offers its own trade-offs. In the end, decidingwhich strategy is the best option is a technical decision, based on the project needs.Throughout this book, we changed the strategy three times, using completely different ways to achieveAPI versioning. Thanks to Phoenix framework design, this task was simple and we limited the scope ofthe changes to the routing layer.I would love to hear your feedback about this book and how it helped you. Feel free to send an email toelvio@elviovicosa.com.Thank you for reading this book and if you want to read more about Elixir and Phoenix, visit myhttp://www.elviovicosa.com/.
